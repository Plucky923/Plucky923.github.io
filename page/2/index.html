<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="随便记录">
<meta property="og:type" content="website">
<meta property="og:title" content="Plucky">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Plucky">
<meta property="og:description" content="随便记录">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Plucky">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Plucky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Plucky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Comfortably Numb</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/" class="post-title-link" itemprop="url">论文阅读 Making Memory Account Accountable：Analyzing and Detecting Memory Missing account bugs for Container Platforms</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-23 19:09:13" itemprop="dateCreated datePublished" datetime="2023-04-23T19:09:13+08:00">2023-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-03 18:12:16" itemprop="dateModified" datetime="2023-05-03T18:12:16+08:00">2023-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文精读</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">内核安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>35 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>摘要</strong></p>
<p>Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。</p>
<p>在本文中，我们首次系统地研究了内存记账缺失问题。我们首先对其在容器平台上的可利用性和安全性影响进行了深入分析。然后我们开发了一个名为MANTA(Memory Accounting Analyzer)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。</p>
<p>我们的分析表明，所有的容器运行时，包括runC和Kata容器，都容易受到基于内存记账缺失的攻击。此外，内存记账缺失可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而使单个节点甚至整个集群崩溃。我们的工具报告了53个可利用的内存记账缺失漏洞，其中37个被内核开发者确认，并提交了相应的补丁，还有两个新的CVE被分配。通过深入分析、自动检测、报告的错误和提交的补丁，我们相信我们的研究提高了容器平台内存核算的正确性和安全性。</p>
<p><strong>CCS CONCEPTS</strong></p>
<ul>
<li>Security and privacy → Operating systems security; Virtualization and security</li>
</ul>
<p><strong>KEYWORDS</strong></p>
<p>Cloud infrastructure, Linux kernel, memory accounting, missingaccount, DoS attack</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>计算和限制内存使用是每个操作系统内核的核心功能。特别是，Linux内核引入了内存控制组(memcg)，它可以在进程级别解释和限制内存使用。因此，与基于虚拟机(VM)的内存分区技术相比，memcg具有更细粒度和轻量级的特点。</p>
<p>由于其灵活性和高效性，memcg已经被容器平台广泛采用。众所周知，容器平台严重依赖资源共享来提高硬件资源的利用率。而memcg为容器在进程级别提供了唯一的内存使用记录和限制方法。因此，诸如Docker 、容器即服务平台（例如，OpenShift）和函数即服务平台（例如，OpenWhisk）等流行的容器平台，都采用memcg来控制其容器的内存使用。此外，基于虚拟机的容器运行时——Kata容器  也使用memcg来限制主机上的容器线程和其他服务线程的内存。此外，开放容器倡议（OCI）认证要求容器运行时必须使用memcg才能获得认证 。因此，memcg已经成为容器平台和云计算的基础技术。</p>
<p>不幸的是，尽管memcg被广泛使用，但由于其复杂性，它容易出错。具体来说，Linux内核选择将内存记账接口插入到内存分配&#x2F;释放路径中以实现记账，这可能由于高度复杂的内存使用和大量与内存使用相关的接口和代码路径，容易引入内存记账丢失错误（分配的内存未计入账户）。此外，即使记账接口位置正确，它们的记账行为也是有条件的，并受到记账标志的控制，我们发现这些标志经常缺失。因此，我们发现内存记账丢失错误很常见。</p>
<p>然而，即使memcg已经被广泛使用，其内存记账丢失漏洞从未得到系统分析。 memcg的现状是由两个原因造成的。首先，从来没有清楚地知道内存记账丢失漏洞会产生什么安全影响或者它们是否可利用。结果，记账丢失错误被内核开发人员忽略，并且没有特别努力消除这些问题。其次，没有自动检测内存记账丢失漏洞。正如之前讨论的那样，内存记帐设计和实现非常复杂，并深度集成到Linux kernel的复杂内存管理子系统中。因此，即使对于有经验的用户来说也很难正确理解记帐设计和策略。例如，我们发现Docker官方网站错误地声称“页面高速缓存的记忆费用在控制组之间分配”，并且“当一个cgroup终止时，它可能会增加另一个cgroup 的内存使用量“。因此，在没有自动检测的情况下手动推断记帐正确性几乎是不可能的更糟糕的是, 内存记账丢失是否可检测以及如何进行检测仍然是开放性问题。</p>
<p>本文首次对Linux内存记账丢失错误进行了系统分析和检测。我们首先进行了深入分析，以了解内存记账丢失错误在容器平台上的可利用性和安全影响。然后我们开发了一个名为MANTA（Memory AccouNTing Analyzer的简称）的工具，它结合了静态和动态分析技术来自动检测内存记账丢失错误。我们的分析显示，不仅普通容器运行时（如runC），而且安全容器运行时（如Kata容器）都容易受到由内存记账丢失错误引起的内存耗尽攻击。更糟糕的是，内存记账丢失错误可以被利用来攻击Docker、CaaS和FaaS平台，导致容器节点甚至整个集群崩溃。</p>
<p>由于memcg的复杂性，内存记账丢失检测面临两个挑战。首先，没有文档或现有研究定义了memcg使用的内存记账接口。现有的工作采用自然语言处理或包装函数分析来识别内存分配接口。然而，由于不匹配的启发式规则，这些技术无法直接应用于记账接口。为解决这个问题，MANTA提出了基于计数器的接口识别方法，自动检测所有与内存记账相关的接口。关键的观察是，所有内存记账接口最终都会在实现中增加&#x2F;减少相应的页面计数器。识别从页面计数器修改开始，迭代整个调用图以精确识别记账接口。</p>
<p>其次，分析内存分配和内存记账之间的映射具有挑战性。这种分析由于从内存分配位置到内存记账位置的深层和嵌套执行路径而变得复杂。它还需要跟踪分配的页面和计入账户的页面之间的数据流，以获得正确的别名集。此外，由于条件标志的控制，记账可能是有条件的。因此，MANTA提出了分配-消耗映射分析和记账标志分析来解决这个挑战。此外，为了验证检测到的内存记账丢失错误，MANTA进一步使用Linux测试项目来检查它们的可触发性和影响。</p>
<p>通过MANTA，我们检测并报告了memcg中的53个可利用错误，其中37个已经被内核开发人员确认并有已合并或待合并的补丁。报告的错误获得了两个新的CVE（一个正在等待）。总之，这项工作进行了深入调查，不仅分析了可利用性和影响，还系统地检测了内存记账丢失错误。我们相信，这些发现将有助于内核memcg开发人员在未来改进内存记账。本文做出了以下贡献。</p>
<ul>
<li><p>In-depth analysis of exploitability and impacts</p>
<p>我们设计了新的攻击来利用容器平台上的内存记账问题。我们的攻击表明，内存记账丢失漏洞可以很容易地被利用来攻击正常和安全的容器运行时(即runC和Kata容器)和流行的容器平台(即Docker, OpenShift和OpenWhisk)，导致容器节点甚至整个集群崩溃。</p>
</li>
<li><p>Automated detection with new techniques</p>
<p>我们提出了多种分析技术来有效地检测内存记账丢失错误，集成了静态分析和动态验证。我们实现了基于LLVM的检测，并使用Linux内存记账对其进行评估。我们进一步使用Linux Test Project (LTP)来验证检测到的错误的可触发性。</p>
</li>
<li><p>Community impact</p>
<p>我们在Linux v5.10中检测并报告了53个可利用的内存记账丢失错误，其中37个已被内核开发人员确认。分配了两个新的cve(一个正在等待)。我们的发现提高了内核社区对记账丢失的影响的认识，他们还邀请我们测试他们的下游内核。我们计划开源我们的检测工具，以进一步帮助社区提高内存计费的正确性和安全性。</p>
</li>
</ul>
<p>道德考虑：本文中的所有实验和攻击都是在一台专用的物理机器上进行的，这台机器仅由我们使用。我们负责任地向Linux内核开发人员披露了所有检测到的错误，并为所有经确认的错误提交了补丁。此外，我们还向Docker团队报告了关于内存记账的错误声明。</p>
<h1 id="BACKGROUD"><a href="#BACKGROUD" class="headerlink" title="BACKGROUD"></a>BACKGROUD</h1><h2 id="Linux-Memory-Accounting"><a href="#Linux-Memory-Accounting" class="headerlink" title="Linux Memory Accounting"></a>Linux Memory Accounting</h2><p>内存记帐是每个现代操作系统内核的核心功能。目前Linux内核采用内存控制组(memory control group, memcg)来实现内存计费。Memcg包含4种类型的内存:user、kernel、swap，and socket。</p>
<ul>
<li><p>user 记录所有用户空间内存页</p>
</li>
<li><p>kernel 记录内核空间内存页和对象</p>
</li>
<li><p>swap 记录交换区页面</p>
</li>
<li><p>socket 记录socket内存</p>
</li>
</ul>
<p>Memcg仅对用户空间进程的内存进行记账，并跳过对内核守护程序或内部内存使用的记账。需要注意的是，Linux内核v5.9引入了对象cgroup，它会对子页面内核内存使用（如内核对象）进行记账。对象cgroup可以将对象分配到不同的cgroups中，从而消除每个memcg的slab（内存分配池），节省大量的slab内存。</p>
<ul>
<li><p>Accounting：Linux内核针对不同类型的内存使用不同的记账接口。具体来说，Linux内核使用<code>mem_cgroup_charge</code>对用户和交换内存进行记账，使用<code>__memcg_kmem_charge</code>对内核内存进行记账。对于内核内存，Linux内核还要求在内存分配过程中设置<code>__GFP_ACCOUNT</code>标志以对内核页面进行记账。用户可以通过文件接口与memcg进行交互。例如，用户可以从<code>memory.usage_in_bytes</code>检查总内存使用情况。</p>
<p>一个memcg实例可能包含多个内存使用情况在其中进行记账的进程。memcg以树形层次结构组织，因此父节点上的内存限制也会影响所有子节点。memcg有两个版本：v1和v2。它们的主要区别在于层次结构和用户接口，而在记账方面的实现大致相同。目前两者都在使用。本文提到的是cgroups v1，大多数结论也适用于cgroups v2。</p>
</li>
<li><p>数据结构：memcg的核心数据结构是<code>mem_cgroup</code>，它代表一个memcg实例。memcg包含4个页面计数器，对应于之前讨论的4种类型的已记账内存。每个页面计数器使用<code>usage</code>（第14行）来计算分配的页面数量。同时，总内存限制（以页面为单位）设置在<code>max</code>（第16行）。在内存充电时，Linux内核调用消耗接口，依次调用<code>page_counter_try_charge</code>，这是一个计算总使用量（第24行）并将其与最大限制（第25行）进行检查的函数。</p>
</li>
<li><p>Accounting challenges：由于Linux内核中众多的内存分配接口和庞大的分配路径，正确地对Linux内核中的内存使用情况进行记账非常具有挑战性。很难调解所有内存分配路径，因此当前的记账机制容易出错。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">memory</span>;</span><span class="comment">/*Both v1 &amp; v2*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">swap</span>;</span><span class="comment">/*v2 only */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">memsw</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*Legacy consumer-oriented counters*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">kmem</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">tcpmem</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span>&#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> usage;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> max;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">page_counter_try_charge</span><span class="params">(<span class="keyword">struct</span> page_counter *counter,<span class="type">unsigned</span> <span class="type">long</span> nr pages,...)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">c</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    new = atomic_long_add_return(nr_pages, &amp;c-&gt;usage);</span><br><span class="line"><span class="keyword">if</span>(new&gt;c-&gt;max)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">goto</span> failed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Container-Runtimes-and-Platforms"><a href="#Container-Runtimes-and-Platforms" class="headerlink" title="Container Runtimes and Platforms"></a>Container Runtimes and Platforms</h2><p>Memcg可以记录和限制每个进程级别的内存使用情况。与基于虚拟机(VM)的内存控制技术相比，memcg粒度更细、更轻、更灵活。因此，memcg已经被Docker、CaaS (container -as- service)和FaaS (function -as- service)平台广泛采用。具体来说，CaaS平台为用户提供了已配置的容器实例。CaaS平台上的用户可以使用自定义的容器映像创建&#x2F;启动&#x2F;停止&#x2F;删除容器。另一方面，FaaS平台不向用户提供容器实例，而是允许用户输入函数和触发规则，并自动创建容器实例来执行输入函数。</p>
<p>Docker和CaaS&#x2F;FaaS平台通常为容器实例使用本地容器运行时(即runC)。为了提高容器之间的隔离性，人们提出了安全容器运行时，如gVisor和Kata容器。gVisor是谷歌开发的沙盒容器运行时。它在一个名为Sentry的用户空间内核上运行每个容器。Sentry拦截并处理来自容器的大多数系统调用。因此，Sentry减少了从容器在主机内核上调用的系统调用。除了沙盒运行时，容器社区还建议使用虚拟化来隔离容器实例。其中一个这样的虚拟化容器运行时是Kata容器，其中每个容器实例都在微型虚拟机中运行，以实现强隔离。</p>
<p>我们的实验表明，正常和安全的容器运行时(包括runC和Kata容器)都容易受到由记账丢失错误引起的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致单个节点甚至整个集群崩溃。</p>
<h1 id="A-STUDY-OF-EXPLOITABLITY-AND-IMPACT"><a href="#A-STUDY-OF-EXPLOITABLITY-AND-IMPACT" class="headerlink" title="A STUDY OF EXPLOITABLITY AND IMPACT"></a>A STUDY OF EXPLOITABLITY AND IMPACT</h1><p>生产环境中内存未记录错误的影响从未被系统地研究过。它们通常被视为一个较小的正确性问题，而不是安全问题。在这一部分中，我们展示了内存未记录错误可以被利用来导致容器主机甚至整个云平台的内存耗尽。特别是，我们分析了内存记账问题的可利用性，以了解其对容器平台的实际影响。我们设计了新的攻击方法来利用未记录错误。这些攻击表明，这些错误可用于攻击普通和安全的容器运行时。因此，它们可被利用在热门的CaaS和FaaS容器平台上造成DoS（主机机器崩溃）和财务费用问题。在以下内容中，我们首先讨论威胁模型和假设。接下来，我们详细介绍如何利用内存未记录问题。</p>
<h2 id="Threat-Model-and-Assumptions"><a href="#Threat-Model-and-Assumptions" class="headerlink" title="Threat Model and Assumptions"></a>Threat Model and Assumptions</h2><p>在我们的实验中，我们研究了三个容器平台 - Docker、容器即服务（CaaS）平台和函数即服务（FaaS）平台。我们使用广泛部署的CaaS平台 - OpenShift作为我们的CaaS平台，以及流行的OpenWhisk作为我们的FaaS平台。这三个平台使用本地运行时（即runC）作为它们的容器运行时。这三个平台上的所有容器都以非特权方式设置为具有默认功能和seccomp配置。对于Docker和CaaS平台，用户可以通过云提供的接口创建和启动带有自定义映像的容器。这是合理的，因为包括AWS、Google Cloud和Azure在内的所有云供应商都为用户提供了一个控制台来管理容器实例。对于FaaS平台，用户可以定义、部署和触发函数，其中每个函数实例都在一个容器中运行。</p>
<p>攻击者是使用Docker、CaaS和FaaS平台的恶意用户。他&#x2F;她可以在非特权容器内执行任意代码。然而，容器的功能受到默认功能的限制。为了进一步限制攻击者，我们假设攻击者无法从容器中逃逸，也无法提升他们的权限。攻击者的目标是破坏内存计算的限制，并耗尽主机上的所有内存，以使其他容器、函数或主机崩溃。</p>
<p>对于攻击环境，我们在本地机器上设置Docker，同时在Google Cloud上设置OpenShift和OpenWhisk集群。出于道德考虑，该集群构建在一个由Google Cloud提供的专用裸金属服务器上，仅供我们使用，因此不会影响其他用户。</p>
<h2 id="Exploit-Missing-Account-Problem"><a href="#Exploit-Missing-Account-Problem" class="headerlink" title="Exploit Missing-Account Problem"></a>Exploit Missing-Account Problem</h2><p>在本节中，我们将设计新的攻击来利用内存记帐中的记账问题，以了解其影响。如前所述，Linux内核中的当前内存记帐将内存记帐接口放在内存分配路径上，将内存取消记帐接口放在内存空闲路径上。然而，Linux内存管理是复杂的，包含数千个内存分配和自由路径。很难用正确的接口来调解所有这些问题。特别是，很容易遗漏一个内存分配路径，从而导致丢失帐户问题。</p>
<p>显示了内核中信号量对象和信号量数组上的记账丢失错误，由MANTA检测并由Linux开发人员确认。函数<code>sem_alloc</code>分配一组信号量，并使用<code>sem_array</code>对它们进行索引。第8行的分配站点调用<code>kvzalloc</code>为<code>sem_array</code>和信号量分配内存。当在<code>kvzalloc</code>的第三个参数中设置了<code>__GFP_ACCOUNT</code>标志时，内核只会考虑分配的内存。然而，在第8行对<code>kvzalloc</code>的调用没有指定<code>__GFP_ACCOUNT</code>标志，导致在分配的信号量和<code>sem_array</code>上丢失帐户。此外，<code>sem_alloc</code>由<code>semget</code>系统调用调用来分配信号量。因此，这个记账丢失的错误很容易从用户空间触发。我们进一步设计了新的攻击，以表明上述漏洞可以被利用来打破容器内存限制并耗尽所有主机内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sem_array *<span class="title function_">sem_alloc</span><span class="params">(<span class="type">size_t</span> nsems)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nsems &gt; (INT_MAX - <span class="keyword">sizeof</span>(*sma)) / <span class="keyword">sizeof</span>(sma-&gt;sems[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    sma = kvzalloc(struct_size(sma, sems, nsems),GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(unlikerly(!sma))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Attacking-Docker"><a href="#Attacking-Docker" class="headerlink" title="Attacking Docker"></a>Attacking Docker</h3><p>我们用默认的功能和seccomp配置来设置Docker。semget系统调用不需要任何功能，也不会被容器seccomp配置文件阻塞。因此，在我们的实验中，攻击程序在非特权容器中可以反复触发semget系统调用，从而打破内存记帐限制，耗尽所有主机内存。主机甚至会因为内存不足错误而崩溃。我们向Linux社区报告了上述错误并提交了补丁。补丁已经被合并到Linux主线上，一个新的CVE已经分配给我们了。</p>
<h3 id="Attacking-the-CaaS-Platform"><a href="#Attacking-the-CaaS-Platform" class="headerlink" title="Attacking the CaaS Platform"></a>Attacking the CaaS Platform</h3><p>我们在Google Cloud上搭建了一个自管理的OpenShift集群，运行所有的GCP虚拟机实例。该集群允许用户在一个具有15GB内存和Linux内核v5.14.14的节点上创建容器。我们将容器的内存限制设置为128MB，这是公共云中常用的内存大小。</p>
<p>为了发起攻击，恶意用户以普通用户权限创建一个容器，并在容器内分配大量信号量。恶意容器的内存使用量迅速增加，大约在20秒内达到节点的极限。相比之下，攻击者的计费内存使用量非常低，不到1.4MB。结果，恶意容器打破了128MB的内存限制，消耗了主机上的全部15GB内存。同一节点上的受害者容器由于内存不足无法执行任何操作。</p>
<h3 id="Attacking-the-FaaS-Platform"><a href="#Attacking-the-FaaS-Platform" class="headerlink" title="Attacking the FaaS Platform"></a>Attacking the FaaS Platform</h3><p>我们评估了对OpenWhisk的攻击，OpenWhisk是一个流行的开源FaaS平台，作为IBM Cloud Functions的基础设施。集群节点内存为15GB，运行Linux内核v5.11.0-1021-gcp。每个功能的内存限制设置为128MB。</p>
<p>为了发起攻击，恶意用户创建了一个反复消耗信号量的函数。然后，恶意用户反复触发恶意功能。导致节点上的内存很快耗尽。注意，当一个节点的内存耗尽时，连续的恶意函数将被分派到其他节点。导致集群内所有节点的内存被恶意用户耗尽，导致集群级DoS。</p>
<h3 id="Attacking-the-Secure-Runtime"><a href="#Attacking-the-Secure-Runtime" class="headerlink" title="Attacking the Secure Runtime"></a>Attacking the Secure Runtime</h3><p>我们进一步设计新的攻击来评估内存记账丢失对安全运行时- Kata容器的影响。我们的实验表明，内存记账丢失漏洞允许攻击者打破Kata容器的隔离并攻击主机和其他容器实例。</p>
<p>Kata容器是一种虚拟容器运行时，其中每个容器实例在微虚拟机中运行，以实现强隔离。但是，Kata micro-VM将文件操作转发给主机，这使得它容易受到基于内存记账丢失的攻击。更具体地说，通过利用内存记账丢失错误，攻击者可以耗尽微型虚拟机中Kata容器的主机内存。如图所示，恶意用户是容器中的普通用户，并发出fcntl系统调用，为一组文件分配大量POSIX锁。但是，客户机内核将请求转发给运行在主机上的virtio-fsd守护进程。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/attackKatacontainers.png" title alt data-align="center">

<p>因此，守护进程在主机内核中分配了 POSIX 锁。尽管 virtio-fsd 守护进程的内存使用受到 memcg（内存控制组）的限制，但锁对象所使用的内存没有被纳入统计。因此，恶意容器可以耗尽主机上的所有物理内存。我们向 Kata 容器社区报告了这种攻击。他们确认了这个问题，并为我们申请了一个新的 CVE（公开披露的计算机安全漏洞和漏洞）。</p>
<p>用通俗的语言来说，这段话描述了一个安全问题，其中，虚拟文件系统管理的守护程序在主机操作系统上分配了一种名为 POSIX 锁的资源。虽然这个守护程序的内存使用受到限制，但锁对象占用的内存没有被计算在内。这意味着一个恶意的容器（一种轻量级的虚拟化技术）可以利用这个问题耗尽主机的物理内存。作者报告了这个问题，并且 Kata 容器社区已经确认该问题，并正申请一个新的安全漏洞编号（CVE）。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>正如上述攻击所证明的那样，可以利用记账丢失漏洞攻击正常和安全的容器运行时、Docker和CaaS&#x2F;FaaS平台。攻击者可以利用这些漏洞耗尽所有内存，使容器节点甚至整个集群崩溃。更糟糕的是，攻击只需要普通用户权限，因此很容易启动。虽然内存丢失帐户漏洞可以被利用来攻击容器平台，但目前还没有系统的研究来检测和消除这些漏洞。因此，本文提出了第一个内存记账分析工具MANTA，来系统地检测这些问题。</p>
<h1 id="MISSING-ACCOUNT-BUG-DETECTION"><a href="#MISSING-ACCOUNT-BUG-DETECTION" class="headerlink" title="MISSING-ACCOUNT BUG DETECTION"></a>MISSING-ACCOUNT BUG DETECTION</h1><p>考虑到内存记账丢失错误的严重性，在操作系统内核实际在生产场景中运行之前的早期阶段检测这些问题非常重要。不幸的是，没有一种工具可以同时检测高代码覆盖率和高精度的遗漏帐户错误。因此，我们提出了MANTA(Memory AccouNTing Analyzer的缩写)来自动检测内存记账丢失错误。</p>
<ul>
<li><p>Design goals</p>
<p>MANTA旨在通过分析记帐接口放置的正确性来自动、系统地检测内存记账丢失错误。具体来说，MANTA需要检测具有高代码覆盖率的内存记账丢失错误。</p>
<p>为了实现这一点，MANTA利用静态分析来遍历Linux内核中的所有内存分配&#x2F;自由路径。此外，MANTA需要高精度地检测漏洞。因此，MANTA使用动态验证来测试检测到的错误的动态触发性。</p>
</li>
<li><p>Challenges</p>
<p>为了实现这两个目标，MANTA需要克服以下挑战。</p>
<ul>
<li><p>C1. MANTA需要识别内存记帐接口，这些接口在内核文档中没有描述，以前的工作也没有研究过。现有的用于内存分配的接口识别方法不能应用，因为它们的启发式方法不适用于内存计费接口</p>
</li>
<li><p>C2. MANTA需要决定每个内存分配是否被考虑并且只考虑一次。然而，在Linux内核中，从内存分配站点到内存记帐站点的执行路径往往是深的、嵌套的和交错的。此外，即使存在这样的路径，记帐也可能受到条件标志的影响，因为记帐同时需要记帐接口和记帐标志§2</p>
</li>
</ul>
</li>
<li><p>Analysis techniques and workflow</p>
<p>MANTA的体系结构如图所示。以整个内核IR作为输入，MANTA首先生成内核调用图。然后，它使用基于页面计数器的方法来识别所有会计接口以地址C1(§4.1)。基于记帐接口，MANTA建立了内存分配&#x2F;释放和内存记帐之间的映射(§4.2)。</p>
<p>之后，MANTA使用记帐标志分析来进一步分析内核内存记帐(§4.3)。这两种技术处理C2。随着检测到的内存记账错误，MANTA进一步评估每个错误与我们的动态触发性分析基于数千个测试用例从Linux测试项目(§4.4)。MANTA目前是为Linux内存记账实现的。下面，我们将详细介绍每种分析技术。</p>
</li>
</ul>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/challenge.png" title alt data-align="center">

<h2 id="Counter-based-Interface-Identification"><a href="#Counter-based-Interface-Identification" class="headerlink" title="Counter-based Interface Identification"></a>Counter-based Interface Identification</h2><p>MANTA首先需要识别内存记账接口。</p>
<p>这些接口是多种多样的，并且可以自定义。使用自然语言处理(NLP)或包装函数分析的现有技术存在精度问题。我们注意到内存记帐必须维护内存使用计数器(即<code>page_counter</code>)，这些计数器是通过特定的原子函数操作的。使用类型匹配可以很容易地找到内存使用计数器。因此，通过识别用于增加&#x2F;减少这些计数器的基本函数，MANTA可以自动找出对会计计数器执行增加&#x2F;减少操作的所有函数。</p>
<p>具体来说，MANTA遍历每个内核IR指令并检查它是否增加&#x2F;减少<code>page_counter</code>。如果是这样，则MANTA将直接包含该指令的函数标记为基本会计函数。由于在Linux内核中，<code>page_counter</code>仅由<code>memcg</code>使用，因此我们的方法可以达到较高的精度。</p>
<p>然后，MANTA根据基本的记账功能识别会计接口。MANTA使用DFS从基本记账函数向后遍历，并在内核调用图上标记所有访问过的函数。每当它到达<code>memcg</code>子系统之外的函数时，MANTA就会停止遍历，因为它不能是<code>memcg</code>接口。在这些记录内存使用情况的标记函数中，如果一个函数是从<code>memcg</code>子系统外部调用的，即，定义<code>memcg</code>功能的源文件，MANTA将其标记为一个记录接口。这样，MANTA就可以识别所有的计费接口。</p>
<p>让我们使用图中的示例来说明基于计数器的接口标识中的步骤。首先，MANTA遍历所有核函数的所有基本块。在<code>__memcg_kmem_charge</code>中，它标识<code>page_counter</code>函数(第6行)并双重确认第一个参数来自<code>memcg</code>。之后，MANTA进入<code>page_counter_try_charge</code>，发现它增加了<code>page_counter</code>的一个字段。由于<code>__memcg_kmem_charge</code>直接调用<code>page_counter</code>函数并增加<code>page_counter</code>的值，因此MANTA认为<code>__memcg_kmem_charge</code>是一个基本的计费接口。</p>
<p>类似地，对于减少<code>page_counter</code>值的接口，MANTA将其标记为未收费接口。此外，MANTA可以区分不同内存类型的接口，因为<code>memcg</code>对每种内存类型使用不同的<code>page_counters(§2)</code>。在第6行，<code>page_counter_try_charge</code>使用了<code>&amp;memcg-&gt; kmemm</code>，因此MANTA知道<code>__memcg_kmem_charge</code>用于内核内存记帐。</p>
<p>从基本的收费接口开始，MANTA然后沿着调用链逐步识别所有的收费接口包装器。如果一个函数调用基本的计费接口，并且计费量来自于它的参数，MANTA将把它标记为一个计费接口包装器。使用图中的相同示例，<code>__memcg_kmem_charge_page</code>调用基本收费接口<code>__memcg_kmem_charge</code>(第29行)，而收费金额<code>1&lt;&lt;order</code>由<code>__memcg_kmem_charge_page</code>的参数控制。</p>
<p>因此，MANTA认为<code>__memcg_kmem_charge_page</code>是一个收费包装器，因为它只是将收费数量传递给基本收费接口，并且对收费数量没有控制。</p>
<p>MANTA使用相同的方法来检测未充电的包装器。</p>
<p>对于charge&#x2F;uncharge接口，MANTA还需要识别内存分配&#x2F;空闲接口。MANTA采用现有技术来产生初步结果。此外，通过观察内存分配&#x2F;释放接口增加&#x2F;减少<code>struct free_area</code>的<code>nr_free</code>计数器，MANTA使用类似的基于计数器的方法来提高结果的精度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __memcg_kmem_charge(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">gfp_t</span> gfp,<span class="type">unsigned</span> <span class="type">int</span> nr_pages)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">counter</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!cgroup_subsys_on_dfl(memory_cgrp_subsys)&amp;&amp;!page_counter_try_charge(&amp;memcg-&gt;kmem,nr_pages,&amp;counter))</span><br><span class="line"></span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">page_counter_try_charge</span><span class="params">(<span class="keyword">struct</span> page_counter *counter,<span class="type">unsigned</span> <span class="type">long</span> nr_pages,<span class="keyword">struct</span> page_counter **fail)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(c = counter; c;c = c-&gt;parent)&#123;</span><br><span class="line">        <span class="type">long</span> new;</span><br><span class="line">        new = atomic_long_add_return(nr_pages,&amp;c-&gt;usage);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __memcg_kmem_charge_page(<span class="keyword">struct</span> page *page, <span class="type">gtp_t</span> gtp,<span class="type">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    memcg = get_mem_cgroup_from_current();</span><br><span class="line">    ...</span><br><span class="line">    ret = __memcg_kmem_charge(memcg,gfp,<span class="number">1</span>&lt;&lt;order);</span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">        page-&gt;mem_cgroup = memcg;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alloc-Charging-Mapping-Analysis"><a href="#Alloc-Charging-Mapping-Analysis" class="headerlink" title="Alloc-Charging Mapping Analysis"></a>Alloc-Charging Mapping Analysis</h2><p>直观地说，每个分配的对象应该只被计算一次。否则，对象可能会被漏记。因此，MANTA 的下一步是建立内存分配&#x2F;释放和计费&#x2F;取消计费之间的关系。基于这种关系，MANTA 可以识别比分配&#x2F;释放的内存少收费或多退费的情况，将其视为漏记错误。简洁起见，我们关注分配和计费。同样的技术可以应用于分析free-uncharging映射。</p>
<p>由于深层次的调用关系和复杂的内存指针传播，从源代码分析分配和计费之间的映射并非易事。为了解决这些问题，我们开发了分配计费(allocation and charging)映射分析。基本思路是首先将函数内的内存分配和计费总结为函数摘要(function summary)，然后基于函数摘要构建内存分配-计费映射，以检测漏记错误。更具体地说，我们使用基于访问路径的分析来生成每个函数的摘要。访问路径的概念首次用于 SATURN 框架，用于表示转义对象的每个函数摘要（即对象指针泄漏到当前函数之外）。</p>
<p>如图左侧算法所示，MANTA 首先为所有函数生成函数摘要（第 2 行）。接下来，对于一个函数𝑓，通过收集其被调用者的函数摘要并分析内存分配位置（IsAlloc），MANTA 可以构建 𝑓 内所有非转义对象的分配-计费映射（第 4-9 行）。具体而言，MANTA 用传递给被调用者的参数替换被调用者摘要中的变量，以计算 𝑓 中分配的页面，这被称为源敏感跟踪。然后，MANTA 通过调用 <code>CheckPage</code> 来分析 𝑓 内的分配-计费映射。在 <code>CheckPage</code> 中，MANTA 能够报告非转义对象的漏记错误（第 19 行）。对于从 𝑓 转义的对象（第 14-18 行），它们最终将在一个函数中（例如 𝑓 的调用者）处理，因为内核中的所有函数都被遍历（第 3-10 行）。此外，<code>IsCharged</code>（第 13 行）和 <code>IsDupCharged</code> 函数（第 21 行）都进行数据流分析，将局部对象连接到被调用函数的返回值或参数。这样，他们可以使用被调用者的函数摘要跟踪内核对象的计费状态。</p>
<p>我们使用图右侧的具体示例来演示算法。MANTA首先为底层内存分配函数<code>__alloc_pages_nodemask</code>生成摘要。 MANTA识别到页面由较低级别的函数<code>get_page_from_freelist</code>返回、充电，并返回。因此，页面既逸出又充电，函数摘要应为（<code>__alloc_pages_nodemask，retval，retval</code>）。当MANTA分析<code>do_anonymous_page</code>时，它会获取<code>alloc_zeroed_user_highpage_movable</code>的函数摘要，该函数是<code>__alloc_pages_nodemask</code>的包装器，具有相同的摘要。根据函数摘要，MANTA确定<code>do_anonymous_page</code>中的页面已经充电。在分析<code>do_anonymous_page</code>内部的分配-计费映射时，MANTA发现内存核算位于第18行可从第14行到达，页面可能在第18行再次被计费。因此，MANTA在这种情况下报告了一个冗余帐户警告。另一方面，如果当前函数中的页面未被计费且不会逸出，MANTA会报告一个未记录错误。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/algorithm.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span> * __alloc_pages_nodemask(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    page = <span class="built_in">get_page_from_freelist</span>(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcg_kmem_enabled</span>()&amp;&amp;(gtp_mask&amp;__GFP_ACCOUNT)&amp;&amp;page&amp;&amp;<span class="built_in">unlikely</span>(__memcg_kmem_charge_page(page,gfp_mask,order)!=<span class="number">0</span>))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title">do_anonymous_page</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    page = <span class="built_in">alloc_zeroed_user_highpage_movable</span>(vma, vmf-&gt;address);</span><br><span class="line">    <span class="keyword">if</span>(!page)</span><br><span class="line">        <span class="keyword">goto</span> oom;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mem_cgroup_charge</span>(page, vma-&gt;vm_mm, GFP_KERNEL)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Accounting-Flag-Analysis"><a href="#Accounting-Flag-Analysis" class="headerlink" title="Accounting Flag Analysis"></a>Accounting Flag Analysis</h2><p>发现仅依靠分配和记账站点的映射来检测记账丢失错误是不够的，因为内存记账通常是有条件的。特别是在 Linux 内核中，只有当将 <code>__GFP_ACCOUNT</code>标志传递给记账接口时，才会对内核对象内存进行记账。因此，如果没有提供<code> __GFP_ACCOUNT</code> 标志，记账接口仍然不会对内存进行记账。因此，分析记账标志的值对于检测记账丢失至关重要。因此，MANTA 对记账标志进行分析，以确定是否将记账标志 <code>__GFP_ACCOUNT</code> 传递给记账接口。</p>
<p><strong>Bit-wise and inter-procedural analysis</strong></p>
<p>MANTA采用程序间逐位数据流跟踪方法来实现会计标志分析。首先，在计费点，MANTA检查<code>GFP</code>标志本身是否为常数。如果是，MANTA直接检查<code>__GFP_ACCOUNT</code>的位。否则，MANTA将递归地跟踪标志的use-def chain，直到确认其记帐标志位。虽然LLVM提供了一个可以跟踪位值传播的值跟踪分析通道，但该分析仅限于过程内。为了跟踪程序间记帐位，MANTA用两个分析规则扩展了通道。具体来说，当MANTA跟踪函数的参数时，它跟踪所有调用函数以跟踪传递给参数的值;当MANTA跟踪调用站点的返回值时，它也跟踪被调用函数并跟踪所有可能的返回值。如果设置了<code>__GFP_ACCOUNT</code>, MANTA将内核内存标记为在分配点被占用。否则，即使有charging接口，MANTA也会将内存视为not-charged。</p>
<p>对<code>kmem_cache</code>分配的分析略有不同，因为分配也受到<code>kmem_cache</code>的创建标志的影响。</p>
<p>如果<code>kmem_cache</code>是用<code>SLAB_ACCOUNT</code>标志创建的，那么来自<code>kmem_cache</code>的所有分配都会被计算在内。因此，对于与<code>kmem_cache</code>相关的分配，MANTA也会找到<code>kmem_cache</code>的初始化位置，并采用相同的记帐标志分析技术来计算<code>SLAB_ACCOUNT</code>标志。</p>
<h2 id="Dynamic-Validation"><a href="#Dynamic-Validation" class="headerlink" title="Dynamic Validation"></a>Dynamic Validation</h2><p>静态分析可能有误报。MANTA检查每个记账丢失分配的系统调用的静态可达性，并过滤掉不可达的。然而，静态可达的bug不一定在运行时触发。因此，MANTA通过动态验证进一步分析静态检测错误的触发性。观察到Linux测试项目(LTP)包含所有300个系统调用的测试用例，我们利用这些测试用例来检查检测到的错误的动态触发性。更具体地说，我们首先检测代码以拦截每个丢失的记账分配，这样我们就可以确认是否确实达到了它。</p>
<p>接下来，我们运行LTP的系统调用和容器测试套件(包含1,469个测试用例)，以检查是否触发了错误。</p>
<p>此外，我们手动运行现有的工具或开发新的测试用例来触发LTP无法触发的错误。其中一些bug与特定的内核特性密切相关，不能被一般的LTP测试用例(例如keexec和selinux)触发。</p>
<p>因此，我们手动运行相关的用户空间工具来触发它们。</p>
<p>其他原因是由于LTP发现的特定系统调用参数，我们手动开发测试用例来传递这些参数。</p>
<p>对于可以动态触发的记账丢失错误，我们进一步开发了内存耗尽概念验证(PoC)来评估它们的安全风险。我们基于触发记账丢失错误的测试用例开发PoCs。特别是，我们反复调用可能触发PoCs中记账丢失错误的系统调用，并记录记账丢失的内存量。此外，一些记账丢失的分配受到某些约束，例如ulimit和sysctl变量。在不损失通用性的情况下，我们对Amazon Fargate等云服务采用了相同的约束设置。这些PoCs的细节将在§5.2中介绍。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>我们用4K行的c++代码将MANTA作为LLVM12的一个通道来实现。所分析的Linux内核是v5.10，具有x86-64的默认配置。MANTA使用wllvm和Clang在默认配置下为整个内核生成IR位码。</p>
<p>vmlinux的位码大小为481MB。MANTA使用PeX方法来解析间接调用并生成调用图。</p>
<p>使用建议的技术，MANTA能够在大约三分钟内完成分析，使其具有足够的可扩展性，可以应用于每个Linux主要版本。</p>
<h1 id="MANTA-RESULT"><a href="#MANTA-RESULT" class="headerlink" title="MANTA RESULT"></a>MANTA RESULT</h1><p>在本节中，我们首先给出了MANTA的分析结果。接下来，我们评估了MANTA的查准率和查全率。之后，我们将介绍影响分析以及Linux内核社区报告和修复的错误。最后，我们讨论了MANTA的局限性。</p>
<h2 id="Result-Overview"><a href="#Result-Overview" class="headerlink" title="Result Overview"></a>Result Overview</h2><p>MANTA检测到242个记账丢失的错误，这些错误可以通过60590个不同的路径从273个系统调用中静态地到达。具体来说，用户空间可触发的bug数量为162个，其中LTP触发的bug有134个，现有工具触发的bug有23个，手工开发的测试用例触发的bug有5个。</p>
<p>剩下的80个bug不能被触发，触发失败的原因主要是深度调用路径（80个案例中的72个）。其余的8个分配在内核文档中被明确标记为豁免，或者用于内核内部使用。请注意，这72个没有触发的bug并不都是假阳性，因为我们的测试案例只覆盖了一部分执行路径。保守地说，MANTA的精度大于66.9%（162&#x2F;242）。</p>
<p>我们还通过手动删除会计标志来评估MANTA的召回率。更具体地说，我们首先通过删除kernel&#x2F;子目录下现有的会计标志来生成一个评估集。所有受影响的分配点都被收集在评估集中。特别是，我们删除了11个SLAB_ACCOUNT标志，用GFP_KERNEL替换了5个GFP_KERNEL_ACCOUNT，总共影响了19个内存分配，如表所示。然后我们在修改后的内核代码上运行MANTA，评估结果显示，MANTA可以检测到所有19个缺失的站点。虽然评估的站点有限，但仍表明MANTA有很高的召回率。</p>
<p>此外，MANTA没有发现任何多余的账户漏洞。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/recall.png" title alt data-align="center">

<h2 id="Impact-Analysis"><a href="#Impact-Analysis" class="headerlink" title="Impact Analysis"></a>Impact Analysis</h2><p>如前所述，为了理解检测到的错误的影响，我们进一步开发基于LTP测试用例的概念验证(PoCs)。更具体地说，我们已经开发了17个PoCs，它们涵盖了47个可以从用户空间重复触发的错误，如表所示。我们在具有16GB RAM的QEMU x86_64机器上开发和测试PoCs。Linux发行版是带有Linux内核v5.10的Debian Buster。所有poc都运行在受memg限制的环境中，并具有Docker运行时应用的默认功能集。</p>
<p>除了PoCs覆盖的bug之外，由于时间和领域知识的限制，我们没有为其他可触发的bug开发PoCs。</p>
<p>然而，这些漏洞也可能被具有相应领域知识的攻击者反复可靠地触发。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bug.png" title alt data-align="center">

<h2 id="Reporting-to-Linux-Community"><a href="#Reporting-to-Linux-Community" class="headerlink" title="Reporting to Linux Community"></a>Reporting to Linux Community</h2><p>我们已经向Linux内核社区报告了53个bug，包括所有47个可以由17个用户空间poc触发的bug和6个可以由内核操作反复触发的bug。这些bug的完整列表列在附录A的表中。</p>
<p>在所有报告的bug中，有37个已经被内核开发人员确认。所有这37个bug的补丁都提交了，其中18个已经合并，19个待合并。</p>
<p>由于memcg子系统目前没有维护它的git子树，所以修补过程很慢。因此，memcg维护者不跟踪提交的补丁，并期望补丁作者将通过其他子系统维护者向上游推送补丁。这引入了许多额外的讨论和审查，从而显著地减缓了合并过程。</p>
<p>在与内核开发者的交流中，我们发现内核社区对这些bug非常关注。一位内核开发人员强调，memcg“不仅仅是粗略的记账估计”，而且“应该考虑由用户空间触发的未绑定分配”。此外，内核开发人员对MANTA非常感兴趣，并邀请我们使用我们的工具和实验来测试他们的内核。</p>
<p><img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bugs.png"></p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>MANTA目前有以下限制。</p>
<ul>
<li><p>Static analysis is not sound</p>
<p>由于路径不敏感的函数摘要，MANTA的分析可能会错过记账丢失的错误。当函数在另一条执行路径上对已分配的页进行收费时，它可能不会在其中一条执行路径上对该页收费。在这种情况下，MANTA仍然将功能总结为收费，并在以后的分析中忽略丢失帐户的错误。相反，如果MANTA将功能总结为不收费，则会忽略冗余帐户错误。在未来，我们计划采用像SATURN框架这样的路径敏感摘要来提高稳健性。</p>
</li>
<li><p>Dynamic triggerable test is not complete</p>
<p>目前，MANTA使用LTP测试用例来测试是否可以触发静态检测错误。LTP测试用例是有限的。这些测试用例不可能涵盖内核中所有可能的执行路径。</p>
<p>因此，由于不完整的代码覆盖，MANTA可能会错过一些可触发的错误。因此，我们未来的工作之一是开发更多的测试用例，并采用模糊测试技术来增加代码覆盖率。</p>
</li>
</ul>
<h1 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h1><h2 id="Memory-Accounting"><a href="#Memory-Accounting" class="headerlink" title="Memory Accounting"></a>Memory Accounting</h2><p>JRes为JVM实现内存计费接口。内存记帐接口在对象分配期间收取内存使用费用，在垃圾收集期间收取费用。但是，JRes没有为共享对象实现充电机制。</p>
<p>Price等和MzSchem为用户空间运行时环境提出了基于消费者的内存计费方案，以计算子任务的内存使用情况。它们选择向实际用户收取内存使用费用，而不是向内存分配器收取。它们修改运行时垃圾收集器，以便它可以在释放对象之前释放对象，并将其重新充值到保存其引用的实体中。然而，由于在内核中实现足够高效的垃圾收集仍然是一个挑战，因此很难在内核中直接采用它们。基于vm的工作提供了更好的内存隔离，并且可以解决单片内核中的每个进程记帐问题。然而，传统的基于vm的方案过于重量级，并且引入了很高的性能开销。与基于容器的方案相比，基于unikernel的方法实现了更低的启动延迟和更高的吞吐量，但缺乏兼容性。</p>
<p>MANTA的分配-充电映射分析类似于内存泄漏检测中使用的分配-自由映射分析。泄漏检查器使用上下文和路径敏感的分析方法来检测内存泄漏。Saber和FaskCheck使用按需稀疏价值流分析来检测内存泄漏。LeakFix首先尝试定位导致泄漏的空闲内存并修复它。AutoFix通过结合静态分析和运行时检查来检测和修复内存泄漏。PCA使用选择性流敏感算法进一步加快程序间数据流分析的内存泄漏检测。然而，这些工作依赖于手动输入或特定的启发式来决定分配&#x2F;释放接口，这不能应用于识别内存计费接口。</p>
<h2 id="Resource-Accounting"><a href="#Resource-Accounting" class="headerlink" title="Resource Accounting"></a>Resource Accounting</h2><p>Houdini的escape利用内核下半部分的工作线程、服务进程和中断来绕过控制组的限制。然而，它没有关注memcg，也没有分析对照组的实施情况。对比胡迪尼的越狱，我们系统地定义了memcg中可能存在的问题，识别并报告了memcg中的53个bug。Yang等提出了抽象资源的概念，并发现在容器内耗尽这些资源会导致对主机的DoS攻击。资源容器提出了一个操作系统级别的抽象来考虑整个系统的资源使用情况。它是描述在每个线程级别计算一般资源的方法的第一本书。与以前的工作相比，资源容器工作在系统内核上，可以解决由用户线程引起的内核资源消耗。Zhang等提出将内核下半进程的cpu时间使用收费给受影响的用户进程，以提高公平性。</p>
<p>Perez等人观察到EVM的气体计量与工作节点上的实际资源消耗，特别是CPU周期不一致。它表明，当页面缓存工作不佳时，实际的不一致性会进一步增加，而支付者则要为相同数量的gas付费。本文还提出了一种能够充分利用不一致性的自动合成有效载荷的方法。Liu发现CPU时间计量在各种真实的云平台上都很脆弱。他们提出了6种可以利用进程启动时或运行时的CPU计量的攻击。</p>
<h1 id="CONCLUSION-AND-FUTURE-WORK"><a href="#CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="CONCLUSION AND FUTURE WORK"></a>CONCLUSION AND FUTURE WORK</h1><p>本文首次系统地分析和检测了Linux系统中存在的内存记账缺失问题。我们进行了深入的分析，以了解容器平台上内存记账丢失错误的可利用性和安全影响。</p>
<p>我们的分析表明，所有容器运行时(包括正常运行时和安全运行时)都容易受到由记账丢失错误导致的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致节点甚至整个集群崩溃。</p>
<p>然后，我们提出了MANTA，它结合了静态和动态分析技术，以高代码覆盖率和精度自动检测内存记账丢失错误。我们的检测工具报告了53个可利用的内存丢失帐户错误，其中37个已被内核开发人员确认，分配了两个新的cve。结果表明，MANTA可以有效地缓解内存记帐系统中的记账丢失问题。</p>
<p>我们未来的工作是研究如何在不调解所有内存分配&#x2F;自由路径的情况下准确地计算内存使用情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/22/%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/22/%E5%BA%93/" class="post-title-link" itemprop="url">库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-22 10:39:33" itemprop="dateCreated datePublished" datetime="2023-04-22T10:39:33+08:00">2023-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-23 17:06:05" itemprop="dateModified" datetime="2023-04-23T17:06:05+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h1><ul>
<li><p>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量。</p>
</li>
<li><p>库是一种特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。</p>
</li>
<li><p>库文件有两种：静态库和动态库（共享库），区别是：静态库在程序的连接阶段被复制到了程序中；动态库在连接阶段没有被复制到程序，而是程序在运行时由系统动态加载到内存中供程序调用</p>
</li>
<li><p>库的好处：1、代码保密     2、方便部署和分发</p>
</li>
<li><p>命名规则</p>
<ul>
<li><p>Linux:<code>libXXX.a</code></p>
<ul>
<li><p>lib:前缀（固定）</p>
</li>
<li><p>XXX：库的名字，自己起</p>
</li>
<li><p>.a：后缀（固定）</p>
</li>
</ul>
</li>
<li><p>Windows：<code>libXXX.lib</code></p>
</li>
</ul>
</li>
<li><p>静态库的制作</p>
<ul>
<li><p>gcc获得.o文件</p>
</li>
<li><p>将.o文件打包，使用ar工具（archive）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br></pre></td></tr></table></figure>

<p>r 将文件插入备存文件中</p>
<p>c 建立备存文件</p>
<p>s 索引</p>
<h1 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h1><p>我们现在有如下文件：</p>
<img src="/2023/04/22/%E5%BA%93/tree.png" title alt data-align="center">

<p>首先我们将其编译为.o文件，运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c div.c mult.c sub.c</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<img src="/2023/04/22/%E5%BA%93/.o.png" title alt data-align="center">

<p>输入命令制作静态库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libcalc.a add.o sub.o mult.o div.o</span><br></pre></td></tr></table></figure>

<p>我们生成静态库文件如下：</p>
<img src="/2023/04/22/%E5%BA%93/lib文件.png" title alt data-align="center">

<h1 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h1><p>如图所示，在文件夹里我们有如下文件：</p>
<p><img src="/2023/04/22/%E5%BA%93/tree1.png"></p>
<p>我们从头编译静态库文件</p>
<p>我们在.&#x2F;library文件夹下依次运行如下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd src</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c div.c mult.c sub.c -I ../include/</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libcalc.a add.o div.o mult.o sub.o</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv libcalc.a ../lib/</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main,c -o app -I ./include/ -L ./lib/ -l calc</span><br></pre></td></tr></table></figure>

<p>执行完上述所有指令后我们运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="/2023/04/22/%E5%BA%93/tree2.png"></p>
<p>我们运行下列命令，运行app文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./app</span><br></pre></td></tr></table></figure>

<img src="/2023/04/22/%E5%BA%93/运行app.png" title alt data-align="center">

<h1 id="动态库的制作与使用"><a href="#动态库的制作与使用" class="headerlink" title="动态库的制作与使用"></a>动态库的制作与使用</h1><p>命名规则：</p>
<ul>
<li><p>Linux：libxxx.so</p>
<ul>
<li><p>lib:    前缀（固定）</p>
</li>
<li><p>xxx：库的名字，自己起</p>
</li>
<li><p>.so：后缀（固定）</p>
</li>
<li><p>在Linux下是一个可执行文件</p>
</li>
</ul>
</li>
<li><p>Windows：libxxx.dll</p>
</li>
</ul>
<p>动态库的制作：</p>
<ul>
<li>gcc得到.o文件，得到和位置无关的代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC a.c b.c</span><br></pre></td></tr></table></figure>

<ul>
<li>gcc得到动态库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br></pre></td></tr></table></figure>

<h2 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h2><p>如图所示我们有如下文件，我们按如下命令依次编译，并生成动态库文件，将库文件复制到lib文件夹内。</p>
<img src="/2023/04/22/%E5%BA%93/动态库.png" title alt data-align="center">

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic add.c div.c mult.c sub.c</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared *.o -o libcalc.so</span><br></pre></td></tr></table></figure>

<p>将libcalc.so文件复制到lib文件夹中，我们有如下文件：</p>
<img src="/2023/04/22/%E5%BA%93/动态库2.png" title alt data-align="center">

<h2 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h2><p>我们编译main.c文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o main -I include/ -L lib/ -l calc</span><br></pre></td></tr></table></figure>

<p>运行main文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>

<p>报错，报错信息如下：</p>
<img src="/2023/04/22/%E5%BA%93/动态库3.png" title alt data-align="center">

<h1 id="库工作原理"><a href="#库工作原理" class="headerlink" title="库工作原理"></a>库工作原理</h1><p>静态库：GCC进行连接时，会把静态库中代码打包到可执行程序中</p>
<p>动态库：GCC进行连接时，动态库的代码不会被打包到可执行程序中</p>
<p>程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系</p>
<p>当系统加载可执行代码时，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的DT_RPATH段-&gt;环境变量LD _LIBARAY_PATH-&gt;&#x2F;etc&#x2F;ld.so.cache文件列表-&gt;&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。</p>
<h1 id="动态库加载失败的原因和解决方法"><a href="#动态库加载失败的原因和解决方法" class="headerlink" title="动态库加载失败的原因和解决方法"></a>动态库加载失败的原因和解决方法</h1><p>我们运行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd main</span><br></pre></td></tr></table></figure>

<img src="/2023/04/22/%E5%BA%93/lddmain.png" title alt data-align="center">

<p>发现我们自己写的libcalc.so动态库找不到</p>
<p>添加环境变量，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib</span><br></pre></td></tr></table></figure>

<p>我们再运行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd main</span><br></pre></td></tr></table></figure>

<img src="/2023/04/22/%E5%BA%93/动态库4.png" title alt data-align="center">

<p>我们手动设置了动态库的路径，但是这只是临时的，关闭之后再次打开就会失效</p>
<p>我们进入到&#x2F;home目录下运行命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure>

<p>修改.bashrc文件，在最后一行插入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib</span><br></pre></td></tr></table></figure>

<p>保存之后退出，运行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>

<p>只要手动设置了动态库的路径，就可以运行.&#x2F;main</p>
<img src="/2023/04/22/%E5%BA%93/动态库6.png" title alt data-align="center">

<p>还可以通过修改&#x2F;etc&#x2F;ld.so.cache文件，将动态库文件放入&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib&#x2F;</p>
<h1 id="静态库和动态库的对比"><a href="#静态库和动态库的对比" class="headerlink" title="静态库和动态库的对比"></a>静态库和动态库的对比</h1><h2 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>静态库被打包到应用程序中，加载速度快</p>
</li>
<li><p>发布程序无须提供静态库，移植方便</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>浪费系统资源，浪费内存</p>
</li>
<li><p>更新、部署、发布麻烦</p>
</li>
</ul>
<h2 id="动态库的优缺点"><a href="#动态库的优缺点" class="headerlink" title="动态库的优缺点"></a>动态库的优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>可以实现进程间资源共享（共享库）</p>
</li>
<li><p>更新、部署、发布简单</p>
</li>
<li><p>可以控制何时加载动态库</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>加载速度比静态库慢</p>
</li>
<li><p>发布程序时需要依赖的动态库</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">GCC配置及使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-21 10:22:47" itemprop="dateCreated datePublished" datetime="2023-04-21T10:22:47+08:00">2023-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-22 15:49:49" itemprop="dateModified" datetime="2023-04-22T15:49:49+08:00">2023-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Linux开发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p>GCC原名为GUN C语言编译器（GUN C Compiler）</p>
</li>
<li><p>GCC（GUN Compiler Collection,GUN编译器套件）是由GUN开发的编程语言编译器。GUN编译器套件包括C、C++、Objective-C，Java，Ada和Go语言前端，也包括了这些语言的库（如libstdc++、libgcj等）</p>
</li>
<li><p>GCC不仅支持C的许多“方言”，也可以区别不同的C语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个标准，例如，当使用命令行参数<code>-std = c99</code>，启动GCC时，编译器支持C99标准</p>
</li>
</ul>
<h1 id="GCC安装"><a href="#GCC安装" class="headerlink" title="GCC安装"></a>GCC安装</h1><p>安装命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc g++</span><br></pre></td></tr></table></figure>

<p>查看版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc/g++ -v/--version</span><br></pre></td></tr></table></figure>

<h1 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h1><p>首先创建一个c代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch test.c</span><br></pre></td></tr></table></figure>

<p>在vscode中打开test.c,输入代码</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/test.c.png" title alt data-align="left">

<p>输入指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -E -o test.i</span><br></pre></td></tr></table></figure>

<p>生成预处理文件：</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/test.i.png" title alt data-align="center">

<p>之后输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.i -S -o test.s</span><br></pre></td></tr></table></figure>

<p>生成汇编文件：</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/test.s.png" title alt data-align="center">

<p>输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.s -c -o test.o</span><br></pre></td></tr></table></figure>

<p>生成目标代码文件：</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/test.o.png" title alt data-align="center">

<p>输入命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test.out</span><br></pre></td></tr></table></figure>

<p>生成可执行文件：</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/test.out.png" title alt data-align="center">

<p>运行可执行文件，移动到目录下，运行命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test.out</span><br></pre></td></tr></table></figure>

<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/runtest.out.png" title alt data-align="center">

<h1 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h1><p>使用g++也可以对C程序进行编译</p>
<h2 id="g-和gcc的区别"><a href="#g-和gcc的区别" class="headerlink" title="g++和gcc的区别"></a>g++和gcc的区别</h2><ul>
<li><p>误区一：gcc只能编译c代码，g++只能编译C++代码</p>
<ul>
<li><p>后缀为.c的文件，gcc把它当作是c程序，而g++把它当作是C++程序</p>
</li>
<li><p>后缀为.cpp的文件，两者都会认为是C++程序，C++的语法规则更加严谨一点</p>
</li>
<li><p>编译阶段g++会调用gcc，对于C++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库连接，所以通常用g++来完成连接，为了同一期间，干脆编译&#x2F;连接都用g++。</p>
</li>
</ul>
</li>
<li><p>误区二：gcc不会定义__cplusplus,而g++会</p>
<ul>
<li><p>实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释</p>
</li>
<li><p>如上所述，如果后缀为.c,并且采用gcc编译器，则该宏就是未定义的，否则就是已定义</p>
</li>
</ul>
</li>
<li><p>误区三：编译只能用gcc，连接只能用g++</p>
<ul>
<li><p>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc&#x2F;g++，而连接可以用g++或者gcc -lstdc++</p>
</li>
<li><p>gcc命令不能自动和C++程序使用的库连接，所以通常使用g++来完成连接，但在编译阶段，g++会自动调用gcc，二者等价</p>
</li>
</ul>
</li>
</ul>
<h1 id="编译选项-D"><a href="#编译选项-D" class="headerlink" title="编译选项 -D"></a>编译选项 -D</h1><p>我们编译运行如下程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello GCC\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br><span class="line">./test</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/runtest2.png" title alt data-align="center">

<p>运行结果没有输出Hello world</p>
<p>我们使用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span> -DDEBUG</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/runtest3.png" title alt data-align="center">

<p>-D表示在编译的时候，指定一个宏，相当于程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello GCC\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="编译选项-Wall"><a href="#编译选项-Wall" class="headerlink" title="编译选项 -Wall"></a>编译选项 -Wall</h1><p>运行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span> -Wall</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img src="/2023/04/21/GCC%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/-Wall.png" title alt data-align="center">

<h1 id="其他的一些编译选项"><a href="#其他的一些编译选项" class="headerlink" title="其他的一些编译选项"></a>其他的一些编译选项</h1><ul>
<li><p>-On：编译优化</p>
</li>
<li><p>-l：程序编译的时候，指定使用的库</p>
</li>
<li><p>-L：指定编译的时候，搜索的库的路径</p>
</li>
<li><p>-fPIC&#x2F;fpic：生成与位置无关的代码</p>
</li>
<li><p>-shared：生成共享目标文件，通常用在建立共享库时</p>
</li>
<li><p>-std：指定c方言，如-std&#x3D;c99</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">Linux开发环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-20 16:02:55 / Modified: 16:33:18" itemprop="dateCreated datePublished" datetime="2023-04-20T16:02:55+08:00">2023-04-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Linux开发</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>745</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="安装相关工具"><a href="#安装相关工具" class="headerlink" title="安装相关工具"></a>安装相关工具</h1><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.vmware.com/cn/products/workstation-pro.html">Windows 虚拟机 | Workstation Pro | VMware | CN</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/?dv=win">Visual Studio Code</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.xshell.com/zh/free-for-home-school/">Xshell和Xftp</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">清华大学Ubuntu镜像</a></p>
</li>
</ul>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><p>首先打开ubuntu，安装ssh服务端，输入指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<p>之后打开Xshell</p>
<img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Xshell新建.png" title alt data-align="center">

<p>点击新建，如下图:</p>
<img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Xshell配置.png" title alt data-align="center">

<p>在名称处填写连接的名称，在主机处填写Ubuntu的ip地址</p>
<p>打开Ubuntu，输入命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ifconfig.png" title alt data-align="center">

<p>得到ip地址为192.168.194.129</p>
<p>之后我们使用Xshell连接，此时会让我们填写用户名和密码，我们填写Ubuntu的用户名和它的密码即可</p>
<p>然后我们打开VScode，安装拓展</p>
<img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/VScoderemote.png" title alt data-align="center">

<img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/VScodeconfig.png" title alt data-align="center">

<p>之后会发现vscode多出一个远程资源管理器，我们点击远程资源管理器，然后打开SSH，配置文件，C:\Users\zc\ssh\config</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Read more about SSH config files: https://linux.die.net/man/5/ssh_config</span><br><span class="line">Host Ubuntu-plucky       填写主机名，随便起</span><br><span class="line">    HostName 192.168.194.129   Ubuntu的IP地址</span><br><span class="line">    User plucky    Ubuntu的用户名</span><br></pre></td></tr></table></figure>

<img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/vscode连接.png" title alt data-align="center">

<p>之后就可以连接主机和打开文件夹</p>
<p><img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9.png"></p>
<h1 id="配置SSH公私钥免密登录"><a href="#配置SSH公私钥免密登录" class="headerlink" title="配置SSH公私钥免密登录"></a>配置SSH公私钥免密登录</h1><p>首先在windows主机输入命令</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa</span><br></pre></td></tr></table></figure>

<p>随后所有设置都按回车</p>
<p>我们可以看到用户目录下</p>
<img src="/2023/04/20/Linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/windows.ssh.png" title alt data-align="center">

<p>id_rsa为私钥，id_rsa.pub为公钥</p>
<p>之后我们打开Ubuntu，输入命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>随后所有设置都按回车</p>
<p>之后</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ./ssh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure>

<p>将windows中的id_rsa.pub复制进authorized_keys中。</p>
<p>之后就可以实现无密登录了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/" class="post-title-link" itemprop="url">MIT6 S081 Operating System Engineering Lecture06 Isolation and system call entry/exit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-20 14:13:04 / Modified: 14:47:00" itemprop="dateCreated datePublished" datetime="2023-04-20T14:13:04+08:00">2023-04-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">课程学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/" itemprop="url" rel="index"><span itemprop="name">MIT6.S081 Operating System Engineering</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.5k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Trap机制"><a href="#Trap机制" class="headerlink" title="Trap机制"></a>Trap机制</h1><h2 id="程序完成用户空间和内核空间切换的时机"><a href="#程序完成用户空间和内核空间切换的时机" class="headerlink" title="程序完成用户空间和内核空间切换的时机"></a>程序完成用户空间和内核空间切换的时机</h2><ul>
<li><p>程序执行系统调用</p>
</li>
<li><p>程序出现了类似<code>page fault</code>，运算时除以0的错误</p>
</li>
<li><p>一个设备触发了中断使得当前程序运行需要相应内核设备驱动</p>
</li>
</ul>
<h2 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h2><p>用户空间和内核空间的切换通常被称为<code>trap</code></p>
<p><code>trap</code>涉及了许多小心的设计和重要的细节，这些细节对于实现安全隔离和性能来说非常重要。因为很多应用程序，要么因为系统调用，要么因为<code>page fault</code>，都会频繁的切换到内核中。所以，<code>trap</code>机制要尽可能的简单，这一点非常重要。</p>
<p>我们有一些用户应用程序，例如Shell，它运行在用户空间，同时我们还有内核空间。Shell可能会执行系统调用，将程序运行切换到内核。比如XV6启动之后Shell输出的一些提示信息，就是通过执行write系统调用来输出的。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>我们需要清楚如何让程序的运行，从只拥有user权限并且位于用户空间的Shell，切换到拥有supervisor权限的内核。在这个过程中，硬件的状态将会非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。</p>
<p>每个 RISC-V CPU都有一组控制寄存器，内核会写入这些寄存器以告诉 CPU 如何处理<code>trap</code>，并且内核可以读取这些寄存器以了解发生的陷阱。RISC-V 文档包含完整的信息。riscv.h（kernel&#x2F;riscv.h:1）包含 xv6 使用的定义。以下是最重要的几个寄存器概述：</p>
<ul>
<li><p>Program Counter Register:程序计数器</p>
</li>
<li><p>表明当前mode的标志位：这个标志位表明了当前是supervisor mode还是user mode。当我们在运行shell的时候，自然是在user mode。</p>
</li>
<li><p>SATP（Supervisor Address Translation and Protection）：包含了指向page table的物理地址</p>
</li>
<li><p>STVEC（Supervisor Trap Vector Base Address Register）：指向内核中处理<code>trap</code>指令的起始地址</p>
</li>
<li><p>SEPC（Supervisor Exception Program Counter），在<code>trap</code>的过程中保存程序计数器的值</p>
</li>
<li><p>SSRATCH（Supervisor Scratch Register）内核在此处放置一个值，在处理程序开始时非常方便</p>
</li>
</ul>
<h2 id="trap处理过程中的一些操作"><a href="#trap处理过程中的一些操作" class="headerlink" title="trap处理过程中的一些操作"></a>trap处理过程中的一些操作</h2><p>在<code>trap</code>的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。在<code>trap</code>处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中普通的C程序。接下来我们先来预览一下需要做的操作：</p>
<ul>
<li><p>首先，我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在<code>trap</code>之前，你必须先在某处保存这32个用户寄存器。</p>
</li>
<li><p>PC(程序计数器)也需要在某个地方保存，我们需要能够在用户程序运行中断的位置继续执行用户程序</p>
</li>
<li><p>我们需要将mode改为supervisor mode，因为我们想要使用内核中各种各样的指令</p>
</li>
<li><p>SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射，所以在运行内核代码之前，我们需要将SATP指向kernel page table。</p>
</li>
<li><p>我们需要将堆栈寄存器指向位于内核的一个地址，因此我们需要一个堆栈来调用内核的C函数</p>
</li>
<li><p>一旦我们都设置好了，并且所有的硬件状态都适合在内核中使用，我们需要跳入内核的C代码</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">C++学习 类与对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-16 20:31:16" itemprop="dateCreated datePublished" datetime="2023-04-16T20:31:16+08:00">2023-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-30 16:00:55" itemprop="dateModified" datetime="2023-04-30T16:00:55+08:00">2023-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>42 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++面向对象三大特性：封装、继承、多态</p>
<p>C++认为万事万物都皆为对象，对象上有其属性和行为</p>
<p>例如：</p>
<p>人可以作为对象，属性有姓名、年龄、身高、体重…..，行为有走、跑、跳……</p>
<p>具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li><p>将属性和行为作为一个整体，表现生活中的事物</p>
</li>
<li><p>将属性和行为加以权限控制</p>
</li>
</ul>
<h3 id="封装的意义一"><a href="#封装的意义一" class="headerlink" title="封装的意义一"></a>封装的意义一</h3><p>在设计类的时候，属性和行为写在一起，表现事物</p>
<p>语法：<code>class 类名 &#123; 访问权限 : 属性 / 行为 &#125;;</code></p>
<p>示例一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//设计一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//圆求周长的公式：2*PI*半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class代表设计一个类，类后面紧跟着的就是类名称</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//半径</span></span><br><span class="line">    <span class="type">int</span> m_r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//获取圆的周长</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过圆类 创建具体的圆 （对象）</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    <span class="comment">//给圆对象的属性进行赋值</span></span><br><span class="line">    c1.m_r = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>圆的周长为：62.8</p>
</blockquote>
<p>示例二：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//设计一个学生类，属性具有姓名和学号</span></span><br><span class="line"><span class="comment">//可以给姓名和学号赋值，可以显示学生的姓名和学号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//姓名和学号</span></span><br><span class="line">    string m_Name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> m_id;<span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//显示姓名和学号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给姓名赋值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个具体学生 实例化对象</span></span><br><span class="line">    Student s1;</span><br><span class="line">    Student s2;</span><br><span class="line">    <span class="comment">//给S1对象 进行属性复制操作</span></span><br><span class="line">    s1.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">setId</span>(<span class="number">1</span>);</span><br><span class="line">    s2.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    s2.m_id = <span class="number">2</span>;</span><br><span class="line">    s1.<span class="built_in">showStudent</span>();</span><br><span class="line">    s2.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名： 张三 学号：1<br>姓名： 李四 学号：2</p>
</blockquote>
<h3 id="封装的意义二"><a href="#封装的意义二" class="headerlink" title="封装的意义二"></a>封装的意义二</h3><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ul>
<li><p>public    公共权限</p>
</li>
<li><p>protected    保护权限</p>
</li>
<li><p>private    私有权限</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问权限</span></span><br><span class="line"><span class="comment">//三种</span></span><br><span class="line"><span class="comment">//公共权限 public        成员 类内可以访问    类外可以访问    </span></span><br><span class="line"><span class="comment">//保护权限 protected    成员 类内可以访问    类外不可以访问    儿子也可以访问父亲中的保护内容</span></span><br><span class="line"><span class="comment">//私有权限 private        成员 类内可以访问    类外不可以访问    儿子不可以访问父亲中的私有内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;<span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//保护权限</span></span><br><span class="line">    string m_Car;<span class="comment">//汽车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有权限</span></span><br><span class="line">    <span class="type">int</span> m_Password;<span class="comment">//银行卡密码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">        m_Password = <span class="number">123456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实例化具体对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    p1.m_Car = <span class="string">&quot;奔驰&quot;</span>;</span><br><span class="line">    p1.m_Password = <span class="number">654321</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/Error1.png" title alt data-align="center">

<p><img src="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/Error2.png"></p>
<h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><p>在C++中struct和class唯一的区别就在于默认的访问权限不同</p>
<p>区别：</p>
<ul>
<li><p>struct权限默认为公共</p>
</li>
<li><p>class权限默认为私有</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C1 c1;</span><br><span class="line">    c1.m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    C2 c2;</span><br><span class="line">    c2.m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/Error3.png" title alt data-align="center">

<h2 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h2><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员属性设置为私有</span></span><br><span class="line"><span class="comment">//1、可以自己控制读写权限</span></span><br><span class="line"><span class="comment">//2、对于写可以检测数据的有效性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄 只读</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置情人 只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//姓名    可读可写</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//年龄    只读</span></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="comment">//情人    只写</span></span><br><span class="line">    string m_Lover;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名为： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">//无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名为： 张三<br>年龄为：0</p>
</blockquote>
<p>优点2：对于写权限，我们可以检测数据的有效性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员属性设置为私有</span></span><br><span class="line"><span class="comment">//1、可以自己控制读写权限</span></span><br><span class="line"><span class="comment">//2、对于写可以检测数据的有效性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄 可读可写 如果想修改（年龄的范围必须是0~150之间）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置名字 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt;<span class="number">150</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;年龄错误&quot;</span> &lt;&lt; endl; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置情人 只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//姓名    可读可写</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//年龄    只读</span></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="comment">//情人    只写</span></span><br><span class="line">    string m_Lover;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名为： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">1000</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">//无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名为： 张三<br>年龄错误<br>年龄为：-858993460</p>
</blockquote>
<h2 id="练习案例一"><a href="#练习案例一" class="headerlink" title="练习案例一"></a>练习案例一</h2><p>设计立方体类（Cube）</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//立方体类设计</span></span><br><span class="line"><span class="comment">//1、创建立方体类</span></span><br><span class="line"><span class="comment">//2、创建属性</span></span><br><span class="line"><span class="comment">//3、设计行为 获取立方体面积和体积</span></span><br><span class="line"><span class="comment">//4、分别利用全局函数和成员函数 判断两个立方体是否相等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//设置获取长宽高</span></span><br><span class="line">    <span class="comment">// 设置长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setL</span><span class="params">(<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_L = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置宽</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_W = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取宽</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getW</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置高</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setH</span><span class="params">(<span class="type">int</span> H)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_H = H;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 获取高</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getH</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取立方体面积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * m_L * m_W + <span class="number">2</span> * m_L * m_H + <span class="number">2</span> * m_W * m_H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取立方体体积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_L * m_H * m_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用成员函数判断两个立方体是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameByClass</span><span class="params">(Cube&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getL</span>() == c.<span class="built_in">getL</span>() &amp;&amp; <span class="built_in">getW</span>() == c.<span class="built_in">getW</span>() &amp;&amp; <span class="built_in">getH</span>() == c.<span class="built_in">getH</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_L;<span class="comment">//长</span></span><br><span class="line">    <span class="type">int</span> m_W;<span class="comment">//宽</span></span><br><span class="line">    <span class="type">int</span> m_H;<span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用全局函数判断 两个立方体是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(Cube&amp; c1, Cube&amp; c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c1.<span class="built_in">getL</span>() == c2.<span class="built_in">getL</span>() &amp;&amp; c1.<span class="built_in">getW</span>() == c2.<span class="built_in">getW</span>() &amp;&amp; c1.<span class="built_in">getH</span>() == c2.<span class="built_in">getH</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建立方体对象</span></span><br><span class="line">    Cube c1;</span><br><span class="line">    c1.<span class="built_in">setL</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">setW</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">setH</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1的面积为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculateS</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1的体积为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculateV</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第二个立方体对象</span></span><br><span class="line">    Cube c2;</span><br><span class="line">    c2.<span class="built_in">setL</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">setW</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">setH</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2的面积为：&quot;</span> &lt;&lt; c2.<span class="built_in">calculateS</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2的体积为：&quot;</span> &lt;&lt; c2.<span class="built_in">calculateV</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用全局函数判断</span></span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">isSame</span>(c1, c2);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用成原函数判断</span></span><br><span class="line">    ret = c1.<span class="built_in">isSameByClass</span>(c2);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>c1的面积为：600<br>c1的体积为：1000<br>c2的面积为：600<br>c2的体积为：1000<br>c1和c2是相等的<br>c1和c2是相等的</p>
</blockquote>
<h2 id="练习案例二"><a href="#练习案例二" class="headerlink" title="练习案例二"></a>练习案例二</h2><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点与圆的关系案例</span></span><br><span class="line"><span class="comment">// 点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置x</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取x</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置y</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取y</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">    <span class="type">int</span> m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置半径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setR</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_R = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取半径</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getR</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置圆心</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(Point center)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Center = center;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">getCenter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Center;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_R;<span class="comment">//半径</span></span><br><span class="line">    Point m_Center;<span class="comment">//圆心</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点和圆的关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isInCircle</span><span class="params">(Circle&amp; c, Point&amp; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算两点之间距离的平方</span></span><br><span class="line">    <span class="type">int</span> distance =</span><br><span class="line">        (c.<span class="built_in">getCenter</span>().<span class="built_in">getX</span>() - p.<span class="built_in">getX</span>()) * (c.<span class="built_in">getCenter</span>().<span class="built_in">getX</span>() - p.<span class="built_in">getX</span>()) +</span><br><span class="line">        (c.<span class="built_in">getCenter</span>().<span class="built_in">getY</span>() - p.<span class="built_in">getY</span>()) * (c.<span class="built_in">getCenter</span>().<span class="built_in">getY</span>() - p.<span class="built_in">getY</span>());</span><br><span class="line">    <span class="comment">//计算半径的平方</span></span><br><span class="line">    <span class="type">int</span> rDistance = c.<span class="built_in">getR</span>() * c.<span class="built_in">getR</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断关系</span></span><br><span class="line">    <span class="keyword">if</span> (distance == rDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆上&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (distance &gt; rDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆外&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆内&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建圆</span></span><br><span class="line">    Circle c;</span><br><span class="line">    c.<span class="built_in">setR</span>(<span class="number">10</span>);</span><br><span class="line">    Point center;</span><br><span class="line">    center.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    center.<span class="built_in">setY</span>(<span class="number">0</span>);</span><br><span class="line">    c.<span class="built_in">setCenter</span>(center);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建点</span></span><br><span class="line">    Point p;</span><br><span class="line">    p.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">setY</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断关系</span></span><br><span class="line">    <span class="built_in">isInCircle</span>(c, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>点在圆上</p>
</blockquote>
<h1 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h1><ul>
<li><p>生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除一些自己的信息数据保证安全</p>
</li>
<li><p>C++中的面向对象来自于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置</p>
</li>
</ul>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>对象的初始化和清理也是两个非常重要的安全问题</p>
<p>一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的问题</p>
<p>C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现</p>
<ul>
<li><p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p>
</li>
<li><p>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作</p>
</li>
</ul>
<p>构造函数语法：<code>类名（）&#123;&#125;</code></p>
<p>1、构造函数：没有返回值也不写void</p>
<p>2、函数名称与类名相同</p>
<p>3、构造函数可以有参数，因此可以发生重载</p>
<p>4、程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次</p>
<p>析构函数语法：<code>~类名（）&#123;&#125;</code></p>
<p>1、析构函数：没有返回值也不写void</p>
<p>2、函数名称与类名相同，在名称前加上符号~</p>
<p>3、析构函数不可以有参数，因此不可以发生重载</p>
<p>4、程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的初始化和清理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 构造函数</span></span><br><span class="line">    <span class="comment">//没有返回值 不用写void</span></span><br><span class="line">    <span class="comment">//函数名与类名相同</span></span><br><span class="line">    <span class="comment">//构造函数可以有参数可以发生重载</span></span><br><span class="line">    <span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 析构函数</span></span><br><span class="line">    <span class="comment">//没有返回值 不写void</span></span><br><span class="line">    <span class="comment">//函数名和类名相同 在名称前加~</span></span><br><span class="line">    <span class="comment">//析构函数不可以有参数，不可以发生重载</span></span><br><span class="line">    <span class="comment">//对象在销毁前，会自动调用析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;<span class="comment">//在栈上的数据，test01执行完毕之后，释放这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person构造函数的调用<br>Person析构函数的调用</p>
</blockquote>
<h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><p>两种分类方式：</p>
<ul>
<li><p>按参数分为：有参数构造和无参数构造</p>
</li>
<li><p>按类型分为：普通构造和拷贝构造</p>
</li>
</ul>
<p>三种调用方式：</p>
<ul>
<li><p>括号法</p>
</li>
<li><p>显式法</p>
</li>
<li><p>隐式转换法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将传入的人的身上的所有属性，拷贝到我身上</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、括号法</span></span><br><span class="line">    Person p1  ;<span class="comment">//默认构造函数的调用</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="comment">//拷贝构造函数调用</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    <span class="comment">//注意事项</span></span><br><span class="line">    <span class="comment">//调用默认构造函数的时候，不要加（）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person的无参构造函数调用<br>Person的有参构造函数调用<br>Person的拷贝函数调用<br>p2的年龄为：10<br>p3的年龄为：10<br>Person的析构函数调用<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将传入的人的身上的所有属性，拷贝到我身上</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2、显示法</span></span><br><span class="line">    Person p1;</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象</span></span><br><span class="line"><span class="comment">//注意事项：不要利用拷贝构造函数 初始化匿名对象 编译器会认为是对象声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person的无参构造函数调用<br>Person的有参构造函数调用<br>Person的拷贝函数调用<br>Person的有参构造函数调用<br>Person的析构函数调用<br>Person的析构函数调用<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将传入的人的身上的所有属性，拷贝到我身上</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//3、隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>;</span><br><span class="line">    Person p5 = p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person的有参构造函数调用<br>Person的拷贝函数调用<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h2><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li><p>使用一个以及创建完毕的对象来初始化一个新对象</p>
</li>
<li><p>值传递的方式给函数参数传值</p>
</li>
<li><p>以值方式返回局部对象</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数调用时机</span></span><br><span class="line"><span class="comment">//1、使用一个已经创建完毕的对象来初始化一个对象</span></span><br><span class="line"><span class="comment">//2、值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//3、值方式返回局部对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、使用一个已经创建完毕的对象来初始化一个对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork1</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="built_in">doWork1</span>(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test01()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test02()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test03()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>test01()<br>Person有参构造函数调用<br>Person拷贝构造函数调用<br>p2的年龄为：20<br>Person析构函数调用<br>Person析构函数调用<br>test02()<br>Person默认构造函数调用<br>Person拷贝构造函数调用<br>Person析构函数调用<br>Person析构函数调用<br>test03()<br>Person默认构造函数调用<br>Person拷贝构造函数调用<br>Person析构函数调用<br>Person析构函数调用</p>
</blockquote>
<h2 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h2><p>  默认情况下，C++编译器至少给一个类添加3个函数</p>
<p>1、默认构造函数（无参，函数体为空）</p>
<p>2、默认析构函数（无参，函数体为空）</p>
<p>3、默认拷贝函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，C++不在提供默认无参构造，但会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，C++不会在提供其他构造函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数调用规则</span></span><br><span class="line"><span class="comment">//1、创建一个类，C++编译器会给每个类都添加至少3个函数</span></span><br><span class="line"><span class="comment">//默认构造（空实现）</span></span><br><span class="line"><span class="comment">//析构函数（空实现）</span></span><br><span class="line"><span class="comment">//拷贝构造（值拷贝）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Person(const Person&amp; p)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl;   </span></span><br><span class="line"><span class="comment">        m_Age = p.m_Age;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.m_Age = <span class="number">18</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>Person的默认构造函数调用<br>p2的年龄为：18<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p>如果利用编译器提供的拷贝构造函数，会做浅拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝与浅拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构代码，将堆区开辟的数据做释放操作</span></span><br><span class="line">        <span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Height;</span><br><span class="line">            m_Height = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="type">int</span>* m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发生错误</p>
<p>浅拷贝会带来堆区的内存重复释放</p>
<p>要自己实现拷贝构造函数，解决浅拷贝带来的问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝与浅拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">        <span class="comment">//编译器默认实现m_Height = p.m_Height;</span></span><br><span class="line">        <span class="comment">//深拷贝操作</span></span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Height);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构代码，将堆区开辟的数据做释放操作</span></span><br><span class="line">        <span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Height;</span><br><span class="line">            m_Height = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="type">int</span>* m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>Person的有参构造函数调用<br>p1的年龄为：18 身高为：160<br>Person的拷贝构造函数调用<br>p2的年龄为：18 身高为：160<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>作用：C++提供了初始化列表语法，用来初始化属性     </p>
<p>语法：构造函数（）：属性1（值1），属性2（值2）…{}</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">////传统初始化操作</span></span><br><span class="line">    <span class="comment">//Person(int a, int b, int c)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    m_A = a;</span></span><br><span class="line">    <span class="comment">//    m_B = b;</span></span><br><span class="line">    <span class="comment">//    m_C = c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//初始化列表初始化属性</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(a), <span class="built_in">m_C</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_C = &quot;</span> &lt;&lt; p.m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>m_A &#x3D; 10<br>m_B &#x3D; 10<br>m_C &#x3D; 30</p>
</blockquote>
<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类对象作为类成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string pName)</span><br><span class="line">    &#123;</span><br><span class="line">        m_PName = pName;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Phone</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_PName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//手机</span></span><br><span class="line">    Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当其他类对象作为本类成员，构造事先构造类对象，再构造自身,析构顺序与构造相反</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;iphone&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;的手机是&quot;</span> &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Phone的构造函数调用<br>Person的构造函数调用<br>张三的手机是iphone<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li><p>静态成员变量</p>
<ul>
<li><p>所有对象共享同一份数据</p>
</li>
<li><p>在编译阶段分配内存</p>
</li>
<li><p>类内声明，类外初始化</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1、所有对象都共享同一份数据</span></span><br><span class="line">    <span class="comment">//2、编译阶段就分配内存</span></span><br><span class="line">    <span class="comment">//3、类内声明，类外初始化操作</span></span><br><span class="line">    <span class="comment">//4、私有静态成员变量在类外访问不了</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量 不属于某个对象上，所有对象都共享同一份数据</span></span><br><span class="line">    <span class="comment">//因此静态成员变量有两种访问方式</span></span><br><span class="line">    <span class="comment">//1、通过对象进行访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2、通过类名进行访问</span></span><br><span class="line">    cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<blockquote>
<p>100<br>200<br>200<br>200</p>
</blockquote>
<ul>
<li><p>静态成员函数</p>
<ul>
<li><p>所有对象共享同一个函数</p>
</li>
<li><p>静态成员函数只能访问静态成员变量</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="comment">//所有对象共享同一个函数</span></span><br><span class="line"><span class="comment">//静态成员函数只能访问静态成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static void func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;<span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B;<span class="comment">//非静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span><span class="comment">//类外访问不到私有静态成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//有两种访问方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、通过对象访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//2、通过类名访问</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>static void func调用<br>static void func调用</p>
</blockquote>
<h1 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h1><h2 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h2><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//空对象占用内存空间为： 1</span></span><br><span class="line">    <span class="comment">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class="line">    <span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//非静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 4</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;<span class="comment">//静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 4</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;<span class="comment">//静态成员变量 不属于类的对象上</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//非静态成员函数 不属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 4</p>
</blockquote>
<h2 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h2><p>通过上述代码我们知道在C++中成员变量喝成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢?</p>
<p>C++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li><p>当形参和成员变量同名时，可用this指针来区分</p>
</li>
<li><p>在类的非静态成员函数中返回对象本身，可使用return *this</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1 解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1的年龄为-858993460</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1 解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1的年龄为18</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1 解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">//链式编程 </span></span><br><span class="line">    p2.<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1的年龄为18<br>p2的年龄为： 50</p>
</blockquote>
<h2 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h2><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//p-&gt;showClassName();</span></span><br><span class="line">    p-&gt;<span class="built_in">showPersonAge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会运行错误，报错原因是因为传入的指针是NULL</p>
<p>而下述代码不会报错</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">    <span class="comment">//p-&gt;showPersonAge();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">    p-&gt;<span class="built_in">showPersonAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也不会报错</p>
<h2 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h2><p> <strong>常函数</strong>：</p>
<ul>
<li><p>成员函数后加const后我们称这个函数为常函数</p>
</li>
<li><p>常函数内不可以修改成员属性</p>
</li>
<li><p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
</li>
</ul>
<p><strong>常对象</strong>：</p>
<ul>
<li><p>声明对象前加const称该对象为常对象</p>
</li>
<li><p>常对象只能调用常函数</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/" class="post-title-link" itemprop="url">论文阅读 Houdini’s Escape: Breaking the Resource Rein of Linux Control Groups</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-15 13:08:53" itemprop="dateCreated datePublished" datetime="2023-04-15T13:08:53+08:00">2023-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-22 19:50:35" itemprop="dateModified" datetime="2023-04-22T19:50:35+08:00">2023-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文精读</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">内核安全</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>44 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>摘要</strong></p>
<p>Linux Control Groups，即cgroups，是启用操作系统级容器化的关键构建块。cgroups机制将进程划分为分层的组，并应用不同的控制器来管理系统资源，包括CPU、内存、块I&#x2F;O等。新生成的子进程自动从父进程中复制cgroups属性以加强资源控制。不幸的是，通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。在本文中，我们设计了一套利用策略，通过将进程与原始进程组解关联来生成out-of-band工作负载。这样的工作负载所消耗的系统资源不会被计算到适当的cgroup中。</p>
<p>为了进一步证明可行性，我们提供了Docker容器中的五个案例研究，以演示如何在现实场景中打破cgroup的资源限制。更糟糕的是，通过利用这些cgroups在多租户容器环境中的不足，攻击容器能够极大地扩大所消耗的资源数量，显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们在本地测试平台和Amazon EC2云专用服务器上进行了大量的实验。实验结果表明，一个容器可以消耗系统资源(例如CPU)高达其极限的200倍，并使其他共存容器中特定工作负载的计算和I&#x2F;O性能降低95%。</p>
<p> <strong>CCS CONCEPT</strong></p>
<ul>
<li>Security and privacy → Virtualization and security</li>
</ul>
<p><strong>KEYWORDS</strong></p>
<p>Container；Control Group；Docker</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。</p>
<p>尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。</p>
<p>在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即namespaces)和Linux控制组(即cgroups)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。</p>
<p>容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞。</p>
<p>容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。</p>
<p>尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。</p>
<p>在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即命名空间)和Linux控制组(即cgroups1)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。</p>
<p>容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞</p>
<p>在本文中，我们打算系统地探讨一下来摆脱现有的cgroups机制的资源控制、<br>并了解其对容器的安全影响。新创建的子进程会自动继承其父进程的cgroups属性。这种机制保证了它们将被限制在相同的cgroups策略下。为了打破cgroups的资源约束，我们设计了一套利用策略，通过将进程与其原始cgroups分离，生成了一些带外工作负载。这意味着这些进程不再受到原始cgroups的资源限制，从而可能绕过原本的资源管理策略。这些进程可以从头开始创建，以处理在一个cgroup内发起的系统事件。在其他情况下，这些进程可以是休眠的内核线程或系统服务进程。在整个系统中共享，并将在需要时被激活。因此，相应的消耗的资源将被收取到其他 “受害者 “cgroups中。</p>
<p>为了进一步揭示现有cgroup机制不足的安全风险，我们使用Docker容器进行了五个案例研究，展示了在现实系统设置中逃脱cgroup资源控制的步骤。在这些案例研究中，我们分别利用了异常、文件系统和I&#x2F;O设备、Linux日志系统、容器引擎和softirqs处理的内核处理机制。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行实验。我们的实验表明，即使执行了多个cgroup控制器，一个对抗性去特权容器仍然可以显著耗尽CPU资源或产生大量的I&#x2F;O活动，而不需要任何cgroup控制器。</p>
<p>更糟糕的是，通过在多租户容器环境中利用这些机制，对抗性容器能够极大地扩大所消耗的资源量。由于对抗容器会发动多种攻击(如拒绝服务攻击和资源释放攻击)，可以显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们的实验证明，对手仅通过控制少量资源就能显著影响共存容器的性能。例如，一个容器可能会消耗系统资源(例如CPU)，超过其极限200倍，并使其他容器的特定基准的计算和I&#x2F;O性能降低95%。总体而言，本工作的主要贡献总结如下:</p>
<ul>
<li><p>我们提出了四种可能导致系统资源错误计算的开发策略，因此我们可以逃避cgroup控制器强制执行的资源约束。</p>
</li>
<li><p>我们在Docker容器环境中进行了五个案例研究，并证明了在现实场景中打破cgroup限制并消耗大量资源是可能的。</p>
</li>
<li><p>我们在两个具有不同配置的试验台上评估了所提出的方法的影响。实验结果表明了安全影响的严重性。</p>
</li>
</ul>
<p>本文的其余部分组织如下。第二节介绍了cgroup的背景。第3节介绍了逃脱cgroups机制控制的策略，并从内核的角度分析了其根本原因。第4节详细介绍了容器的几个案例研究，包括威胁模型、攻击向量以及对多租户容器环境的各种攻击的有效性。第5节从不同方面讨论了潜在的缓解措施。第6节对相关工作进行考察，并在第7节中进行总结。</p>
<h1 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h1><p>在Linux内核中，cgroups是用于管理一组任务及其所有子任务的系统资源(例如CPU、内存、磁盘I&#x2F;O、网络等)的关键特性。它是实现集装箱化的构建块之一。cgroup机制将进程组划分为具有控制行为的分层组。所有的子进程也从它们的父进程继承某些属性(例如，limits)，并由该机制控制。cgroups依赖于不同的资源控制器(或子系统)来限制、解释和隔离各种类型的系统资源，包括CPU时间、系统内存、块I&#x2F;O、网络带宽等。Linux容器利用控制组对每个容器实例应用资源限制，并防止单个容器耗尽主机资源。对于云计算中的计费模型，还可以使用cgroups为每个容器分配相应的资源并测量它们的使用情况。下面我们简要介绍cgroup层次结构的背景知识，现有容器环境中通常应用的四种典型的cgroup控制器，以及新生成进程的cgroup继承过程。</p>
<h2 id="cgroups-Hierarchy-and-Controllers"><a href="#cgroups-Hierarchy-and-Controllers" class="headerlink" title="cgroups Hierarchy and Controllers"></a>cgroups Hierarchy and Controllers</h2><p>在Linux中，cgroup是按层次结构组织的，其中一组cgroup被排列在树中。每个任务(例如，一个线程)只能与一个层次结构中的一个cgroup相关联，但可以是不同层次结构中的多个cgroup的成员。然后，每个层次结构都有一个或多个附加子系统，以便资源控制器可以对特定的系统资源应用每个cgroup限制。通过分层结构，cgroups机制能够限制一组进程(例如容器)的资源总量。</p>
<h3 id="The-cpu-controller"><a href="#The-cpu-controller" class="headerlink" title="The cpu controller"></a>The cpu controller</h3><p>cpu controller通过利用CFS(完全公平的调度器，在Linux 2.6.23中引入)调度cpu，以两种方式使cpu成为可管理的资源。</p>
<p>第一种方法是保证最少数量的CPU共享:每个组都提供相应的共享，以定义相对权重。该策略在CPU空闲时不限制cgroup的CPU使用率，当多个cgroup竞争相同的CPU资源时，按照权重的比例分配带宽。例如，如果共享为512的一个容器与共享为1024的另一个容器运行在同一个核心上。然后，第一个容器的CPU使用率大致为33.3%，而另一个容器的CPU使用率为66.7%。在Linux 3.2中进一步扩展了cpu控制器，通过指定配额和周期来提供额外的cpu带宽控制。</p>
<p>每个组只能在每个给定的“时间段”(以微秒为单位)内消耗“配额”微秒。如果一个组的CPU带宽消耗(由运行时变量跟踪)超过了限制，控制器将限制该任务，直到下一个时间段，此时容器的运行时被重新充电到其配额。cpu控制器被广泛应用于多租户容器环境，以限制一个容器的cpu使用。如果容器设置的配额为50,000，周期为100,000，则该容器最多可以消耗一个CPU核心总CPU周期的一半。</p>
<h3 id="The-cpusets-controller"><a href="#The-cpusets-controller" class="headerlink" title="The cpusets controller"></a>The cpusets controller</h3><p>cpusets控制器提供了一种机制，用于将一组任务约束到特定的cpu和内存节点。在多租户容器环境中，利用cpusets控制器来限制特定核心上容器的工作负载。容器的每个任务都附加到一个cpuset，其中包含一组允许使用的cpu和内存节点。对于CPU调度，任务的调度(通过系统调用sched_setaffinity)被过滤到任务的cpusset允许的那些CPU。任务的任何进一步的动态迁移也仅限于允许的cpuset。因此，cpusets控制器还可以用于将一个进程固定在特定的核心上。容器用户还可以利用用户空间应用程序(例如，taskset)在cpuset的限制范围内进一步设置亲和性。</p>
<h3 id="The-blkio-controller"><a href="#The-blkio-controller" class="headerlink" title="The blkio controller"></a>The blkio controller</h3><p>blkio cgroup通过应用I&#x2F;O控制来控制和限制对指定块设备的访问。内核级有两个策略可用。第一个是基于比例权重的基于时间的磁盘策略划分。每个cgroup都被分配了一个blkio。权重值，表示该组占用磁盘时间的比例。第二个是节流策略，它指定I&#x2F;O设备上的上限。</p>
<h3 id="The-pid-controller"><a href="#The-pid-controller" class="headerlink" title="The pid controller"></a>The pid controller</h3><p>pid cgroup子系统用于对容器的任务数量设置一定的限制。这可以通过在pid.max中设置最大任务数来实现。当前任务数保存在pid .current中。pid cgroup子系统将在达到限制(例如，pid.current&gt; pid .max)停止forking或克隆一个新任务(例如，返回错误信息)。因此，pid控制器可以有效防御多种耗尽攻击，如fork bomb。</p>
<h2 id="cgroups-Inheritance"><a href="#cgroups-Inheritance" class="headerlink" title="cgroups Inheritance"></a>cgroups Inheritance</h2><p>cgroups的一个重要特性是子进程从父进程继承cgroups属性。每当一个进程创建一个子进程(例如，fork或clone)时，它都会触发内核中的fork函数来复制初始化进程。当新派生的进程在开始时附加到根cgroup时，在复制寄存器和进程环境的其他适当部分(例如，命名空间)后，调用cgroup复制函数来复制父进程的cgroup。特别是，该函数通过递归遍历所有cgroup子系统，将任务附加到其父cgroup。因此，在复制过程之后，子任务将继承与其父任务完全相同的cgroups成员。</p>
<p>例如，如果cpusets资源控制器将父进程的the CPU affinity设置为第二个核心，那么新派生的子进程也将被固定在第二个核心上。同时，如果cpu子系统将父cgroup上的cpu配额限制为50,000，周期为100,000，那么在第二个核上，cgroup的总cpu利用率(包括新分叉的进程和它的父进程)不能超过50%。</p>
<h1 id="EXPLOITING-STRATEGIES"><a href="#EXPLOITING-STRATEGIES" class="headerlink" title="EXPLOITING STRATEGIES"></a>EXPLOITING STRATEGIES</h1><p>在本节中，我们将描述四种逃避cgroups机制的资源控制的策略，并解释现有cgroup无法跟踪所消耗资源的根本原因。如上所述，使用层次结构，cgroups机制可以限制一组进程(例如容器)的资源总量。这是通过附加资源控制器对特定的系统资源应用每cgroup限制来实现的。此外，cgroup中的继承机制确保了同一个cgroup中的所有进程及其子进程都可以被cgroup子系统控制，而不消耗额外的系统资源。</p>
<p>然而，由于Linux内核的复杂性和实现cgroups的难度，我们发现有几个机制没有考虑到，因此可以利用它们来逃避现有cgroups的约束。关键思想是生成工作负载，运行在没有直接从初始化cgroup派生出来的进程上，这导致了cgroup的去关联。特别是，如图所示，用户空间中没有根权限的普通进程可以利用四种策略逃脱cgroups的控制。</p>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/strategies.png" title alt data-align="center">

<h2 id="Exploiting-Upcalls-from-Kernel"><a href="#Exploiting-Upcalls-from-Kernel" class="headerlink" title="Exploiting Upcalls from Kernel"></a>Exploiting Upcalls from Kernel</h2><p>在cgroups机制中，所有内核线程都附加到根cgroup，因为内核线程是由内核创建的。因此，内核线程通过fork或clone创建的所有进程也都附加到与其父进程相同的cgroup(根cgroup)中。</p>
<p>因此，一个cgroup中的进程可以利用内核线程作为代理来产生新的进程，从而逃脱cgroup的控制。特别地，如图❶所示，一个进程可以先触发内核来初始化一个内核线程。</p>
<p>这个内核线程充当代理，进一步创建一个新进程。</p>
<p>由于内核线程附加到根cgroup，因此新创建的进程也附加到根cgroup。在新创建的进程上运行的所有工作负载将不受cgroup子系统的限制，从而打破资源控制。</p>
<p>但是，这种机制要求用户空间进程首先调用内核空间中的内核函数，然后从内核空间向上调用用户空间进程。虽然从用户空间调用特定的内核函数(例如系统调用)是很自然的，但相反的方向并不常见。一种可行的方法是通过usermode helper API，该API通过提供可执行变量和环境变量的名称，为在用户空间中创建流程提供了一个简单的接口。这个函数首先调用一个运行在内核线程中的工作队列(例如，kworker)。工作队列的处理函数进一步创建一个内核线程来启动用户进程。最后一步调用内核中的fork函数，将创建的用户进程附加到内核线程的cgroups。</p>
<p>用户模式助手API可用于多种场景，如加载模块、重新启动计算机、生成安全密钥和传递内核事件。虽然在用户空间中触发这些活动通常需要root权限，但仍然可以在用户空间中调用API，这将在4.1节中讨论。</p>
<h2 id="Delegating-Workloads-to-Kernel-Threads"><a href="#Delegating-Workloads-to-Kernel-Threads" class="headerlink" title="Delegating Workloads to Kernel Threads"></a>Delegating Workloads to Kernel Threads</h2><p>另一种利用内核线程来打破cgroup约束的方法是将工作负载委托给它们，如图❷所示。同样，由于所有内核线程都附加到根cgroup，因此这些工作负载所消耗的资源量将计入目标内核线程，而不是初始化用户空间进程。</p>
<p>Linux内核运行多个内核线程，处理各种内核函数并在进程上下文中运行内核代码。例如，kthread是内核线程守护进程，用于创建其他内核线程;引入Kworker来处理工作队列任务;Ksoftirqd服务于softirqs;迁移执行迁移作业，将任务从一个核心移动到另一个核心;kswapd管理交换空间。对于这些内核线程，根据它们的功能，内核可能只在系统中运行一个线程(例如kthread)，或者每个内核运行一个线程(例如ksoftirqd)，或者每个内核运行多个线程(例如kworker)。一直有报道称，由于各种bug和问题，内核线程会消耗大量的资源。因此，如果一个进程可以强制内核线程运行委托的工作负载，相应消耗的资源将不受cgroup的限制。</p>
<h2 id="Exploiting-Service-Processes"><a href="#Exploiting-Service-Processes" class="headerlink" title="Exploiting Service Processes"></a>Exploiting Service Processes</h2><p>除了由内核维护的内核线程外，Linux服务器还运行多个系统进程(例如systemd)，用于不同的目的，如进程管理、系统信息日志记录、调试等。这些流程监视其他流程，并在触发特定活动时生成工作负载。同时，许多用户空间进程作为其他进程的依赖关系，同时运行以支持其他进程的正常功能。如果一个用户进程能够在这些进程上生成内核工作负载(图中的策略❸ )，所消耗的资源就不会被分配给初始化进程，从而可以逃脱cgroups机制。</p>
<h2 id="Exploiting-Interrupt-Context"><a href="#Exploiting-Interrupt-Context" class="headerlink" title="Exploiting Interrupt Context"></a>Exploiting Interrupt Context</h2><p>最后一种策略是利用中断上下文中所消耗的资源。cgroup机制只计算在进程上下文中消耗的资源。一旦内核运行在其他上下文(如中断上下文,如图所示的策略❹),所有消耗的资源都不会被计入任何cgroup</p>
<p>特别地，Linux内核服务中断分为两部分:上半部分(即硬件中断)和下半部分(即软件中断)。由于硬件中断可能随时被引发，因此上半部分仅通过响应硬件中断来执行轻量级操作，然后安排(延迟)下半部分的执行。当在下半部分执行中断处理程序时，内核运行在软件中断上下文中，因此它不会为系统资源(例如CPU)收取任何进程的费用。</p>
<p>从内核3.6开始，softirq的处理(硬件中断引发的除外)与生成它们的进程绑定。</p>
<p>这意味着在softirq上下文中所消耗的所有资源都不会消耗所引发进程的任何配额。此外，softirqs的执行将抢占当前进程上的任何工作负载，所有进程将被延迟。</p>
<p>此外，如果处理softirqs的工作负载过重，内核将把它们卸载到内核线程ksoftirqd，这是一个每个CPU(即每个CPU一个线程)的内核线程，并以默认的进程优先级运行。一旦卸载，对softirqs的处理将在ksoftirqd的进程上下文中运行，因此任何资源消耗都将在线程ksoftirqd上计算。在这种情况下，它属于内核线程策略(如图所示的策略❷ )。总之，如果一个进程(称为进程A)能够引发大量的软件中断，内核将不得不在中断上下文或ksoftirqd的进程上下文中花费资源来处理软中断，而不向进程A支付费用。</p>
<h1 id="CASE-STUDIES-ON-CONTAINERS"><a href="#CASE-STUDIES-ON-CONTAINERS" class="headerlink" title="CASE STUDIES ON CONTAINERS"></a>CASE STUDIES ON CONTAINERS</h1><p>在前一节中，我们讨论了几种可能的策略来逃避cgroups的资源控制。然而，在现实的容器环境中，由于存在其他合作安全策略，开发更具挑战性。在本节中，我们将介绍在Docker容器环境中进行的五个案例研究，以演示利用cgroups弱点的详细步骤。</p>
<ul>
<li><p>Threat model</p>
<p>我们考虑一个多租户容器环境，其中属于不同租户的多个Docker容器共享同一台物理机器。目前，边缘和云平台都广泛采用了多租户环境。系统管理员使用cgroups为每个容器设置资源限制。每个容器都是去特权的，设置有有限的CPU时间、系统内存、块I&#x2F;O带宽，并固定到特定的核心。我们假设攻击者控制了一个容器实例，并试图利用cgroups中的不足(1)降低其他容器的性能，(2)获得不公平的优势。</p>
</li>
<li><p>Configuration</p>
<p>我们使用Docker容器通过提供的接口来设置cgroups的配置。此外，Docker还默认确保容器通过namespace隔离。特别是，启用USER namespace后，容器中的根用户将映射到主机上的非特权用户。</p>
<p>因此，容器中的特权操作不会影响主机内核。我们的案例研究就是在这样一个没有特权的容器中进行的。</p>
<p>为了演示每种利用的有效性，我们通过在空闲服务器上设置多个cgroup配置来初始化容器，并测量主机上系统资源的利用率。为了模拟边缘和云环境，我们选择了两个测试平台来进行实验:(1)我们实验室的本地机器;(2) Amazon EC2中的专用主机。特别是，虽然我们的本地测试台配备了7200 rpm的SATA硬盘驱动器，但我们在EC2服务器上选择了更好的I&#x2F;O配置。专用试验台的存储配置了1000iops的SSD(默认为400)，吞吐量比我们本地试验台提高20倍左右。因此，本地测试平台表示可能部署在边缘环境中的性能较低的节点，而强大的专用服务器可以模拟多租户容器云环境。</p>
</li>
<li><p>Ethical hacking concerns</p>
<p>使用cgroup将不可避免地产生主机级的影响，这可能会影响主机服务器上所有容器的性能。因此，对于我们在Amazon EC2上的实验，我们选择使用专用服务器，该服务器仅供我们使用，不与其他租户共享。</p>
<p>此外，它还允许我们模拟多租户容器环境并度量系统范围的影响。</p>
</li>
<li><p>Result summary</p>
<p>表给出了所有案例研究的总体总结、相应的开发策略和影响。第一个案例研究是利用内核中的异常处理机制，这涉及到策略❶。我们发现容器中引发的异常可以调用用户空间进程，其后果是容器可以消耗比cgroups限制多200倍的CPU资源。第二种情况是利用回写机制进行磁盘数据同步，这涉及到策略❷。容器可以不断调用全局数据同步，以降低主机上特定I&#x2F;O工作负载的速度，最高可达95%。第三种情况是利用系统服务日志(通过策略❸)，产生消耗CPU和块设备带宽的工作负载。第四种情况是利用容器引擎在容器引擎进程(策略❸)和内核线程(策略 ❷)上产生额外的未计算的工作负载(大约3倍)。最后一种情况是利用softirq处理机制在内核线程(策略 ❷)和中断上下文(策略❹)上消耗CPU周期。</p>
</li>
</ul>
<img title src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Summary2.png" alt data-align="center">

<h2 id="Case-1-Exception-Handling"><a href="#Case-1-Exception-Handling" class="headerlink" title="Case 1:Exception Handling"></a>Case 1:Exception Handling</h2><p>第一种情况是利用内核中的异常处理机制。我们发现可以调用用户模式助手API，并通过异常进一步触发用户空间流程(作为策略❶)。通过反复产生异常，一个容器消耗的CPU资源比限制多约200倍，从而使同一主机(不限于一个核)上其他容器的性能显著降低85% ~ 95%。</p>
<ul>
<li><p>Detailed analysis </p>
<p>Linux内核为各种异常提供了专用的异常处理程序，包括错误(例如，分割错误)和陷阱(例如，溢出)。内核维护一个中断描述符表(IDT)，其中包含每个中断或异常处理程序的地址。如果CPU在用户模式下引发异常，相应的处理程序将在内核模式下调用。处理器首先在内核堆栈中保存寄存器，然后相应地处理异常，最后返回到用户模式。整个过程在内核空间和触发异常的进程上下文中运行。因此，它将被充电到正确的相应的cgroups。</p>
<p>然而，这些异常将导致初始进程的终止并引发信号。这些信号将进一步触发内核转储功能，生成一个用于调试的内核转储文件。内核中的核心转储代码通过usermode辅助API从内核中调用一个用户空间的应用程序。在Ubuntu中，默认的用户空间核心转储程序是Apport，它将在每个异常情况下被触发。正如上一节所提到的，Apport所消耗的系统资源将不会由容器承担，因为该进程是由内核线程分叉的，而不是由容器化的进程。</p>
<p>新产生的Apport实例将被内核安排到所有的CPU核心，以达到负载平衡的目的，因此打破了cpusets的cgroup。同时，由于Apport进程的运行比轻量级的异常处理（即内核控制路径）消耗更多的资源，如果容器不断引发异常，整个CPU将被Apport进程完全占据。cpu cgroup的逃逸导致分配给容器的系统资源的巨大放大。</p>
</li>
<li><p>Workloads amplification</p>
<p>为了研究这种影响，我们在一个核心上启动并固定一个容器。我们通过调整周期和配额来为容器设置不同的CPU资源限制。</p>
<p>容器进入循环，不断引发异常。我们实现了几种用户空间程序可用的异常类型。由于不同类型的异常的结果是相似的，我们使用div 0异常作为例子。容器是唯一在我们的测试平台中运行的活动程序。我们通过top命令测量测试平台的CPU使用率，通过Docker的统计工具测量容器的CPU使用率。对于主机级别的使用情况，我们将所有内核的CPU使用量汇总在一起（因此12个内核的最大使用量为1200%）。我们将放大系数定义为主机的CPU利用率与容器的CPU利用率的比率。</p>
<p>图演示了用户模式助手API可以触发用户空间程序，从而显著提高容器的CPU使用率。在我们的本地测试平台上，容器使用的一个内核上的CPU利用率只有7.4%，整个12个内核都被占用了。当我们将分配给容器的CPU资源减少到仅10%内核(通过设置period为200,000,quota为20,000)后，这个问题无法缓解。我们进一步将容器的CPU限制降低到20%核心，并最终将12个核心的总利用率限制到1,065%，放大因子为207×。同时，系统内存使用增加了约1GB，而Docker测量的容器内存使用仅为15.58MB。</p>
<p>我们从EC2服务器上获得了类似的结果:容器的22.5%的利用率就可以耗尽36个内核。由于CPU频率不如我们的本地测试平台强大，一旦我们将容器的CPU资源限制为1&#x2F;10内核，它可以在所有36个内核上产生1907%的利用率。放大系数约为192×。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Workload.png" title alt data-align="center">

<ul>
<li><p>The pid controller</p>
<p>虽然放大要求容器不断抛出异常，但我们进一步使用pid cgroup子系统对容器的任务数量设置一定的限制。同样，如图所示，即使活动进程的数量被限制在50个，pid控制器也不能降低放大结果，这是一个非常小的数字，可能会对容器用户造成巨大的可用性影响。在单核CPU计算能力只有20%的情况下，将pid限制为50，放大系数可以降低到98×。在EC2服务器上，在单核10% CPU计算能力的容器上，通过将pid数量限制在50个，放大系数在144×左右.</p>
</li>
<li><p>Denial-of-service(DoS) attacks</p>
<p>当多个容器在同一个核心上运行时，它们将共享和竞争CPU资源。Linux的CFS系统根据每个容器的份额来分配CPU周期。CFS系统确保了完全的公平性，即容器可以完全利用其插槽中的所有资源。然而,如果一个恶意的容器可以在它自己的cgroup之外产生新的工作负载，CFS系统也会将CPU周期分配给这些进程，从而减少其他co-residence容器的使用。同时，CPU使用率的下降也可能影响其他的性能，如内存和I&#x2F;O吞吐量。</p>
<p>在我们的实验中，我们通过利用恶意容器中的异常处理机制来衡量DoS攻击的影响。我们运行两个容器:一个恶意容器和一个受害者。我们将攻击的性能与恶意容器运行正常工作负载(即基线)的情况进行比较。受害容器运行不同的sysbench工作负载来度量性能。</p>
<p>这两个服务器上的结果如表所示。我们首先将两个容器设置在相同的内核上，使用完全相同的CPU共享和配额。我们发现，在我们的本地测试平台上，抛出异常(导致内核转储)可以显著降低95%的CPU和内存性能，并降低17%左右的I&#x2F;O性能。在EC2服务器上，大约85%用于CPU和内存性能，82%用于I&#x2F;O性能。这是合理的，因为引发异常会导致大量用户空间核心转储应用程序与受害容器竞争CPU周期。</p>
<p>通过将容器固定在不同的核心上，我们进一步改变了恶意容器的核心亲缘性。尽管恶意容器不再与受害者竞争同一内核上的CPU资源，但它在受害者的性能上仍然显示出类似的结果。这是因为CPU资源的主要竞争对手不是恶意容器，而是那些触发内核转储的应用程序。</p>
<p>这一结果表明，恶意租户可以很容易地利用容器来显著降低同一主机上所有其他容器的性能，并降低服务供应商的服务质量，从而可能导致巨大的经济损失，而成本很少。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/DoSattackResult.png" title alt data-align="center">

<h2 id="Case-2-Data-Synchronization"><a href="#Case-2-Data-Synchronization" class="headerlink" title="Case 2:Data Synchronization"></a>Case 2:Data Synchronization</h2><p>我们的第二个案例是利用磁盘数据同步的回写机制，出于性能考虑，该机制被广泛采用。CPU只会将更新后的数据写入缓存，当缓存被清除时，数据才会写入磁盘。</p>
<p>由于懒惰的磁盘回写机制将启动I&#x2F;O的进程与同步磁盘写入的进程解耦，所以我们的利用可以逃避cgroups。有多种方法可以触发数据同步，包括定期回写和内存不足。它也可以由用户进程通过系统调用故意调用，如sync（将缓存文件数据的所有未决修改写回给底层文件系统）、syncfs（同步开放文件所指的文件系统）和fsync（将文件的所有修改数据传输到其常驻磁盘设备）。这些系统调用对Linux容器是可用的。特别是，我们发现，同步可以被利用来减慢整个系统的I&#x2F;O性能（例如，在序列写入上有超过87%的降级），发起无资源攻击，并建立秘密通道。</p>
<ul>
<li><p>Detailed analysis on sync</p>
<p>同步的第一步是启动一个内核线程，它将页缓存中包含的所有脏页刷新到磁盘。它通过扫描所有当前挂载的文件系统来查找要刷新的所有脏索引节点，并刷新相应的脏页。由于同步允许进程将所有脏缓冲区写回磁盘，任何I&#x2F;O操作都必须等待刷新。</p>
<p>更糟糕的是，由其他进程(可能属于另一个容器)生成的脏缓冲区也将被迫写回磁盘。</p>
<p>容器中的进程可以在不执行I&#x2F;O操作的情况下，以少量的工作负载重复调用sync。但是，与此同时，如果在其他共驻留容器上有I&#x2F;O操作，同步将回写所有脏页。在我们的实验中，我们运行了一个不断调用sync的容器。它不会导致超出容器限制的任何额外利用率。然而，一旦我们运行另一个容器，进行一些简单的写操作，同步操作就会导致大量的CPU等待时间，这是同步和写操作的组合所产生的。CPU等待时间用于指示I&#x2F;O等待所消耗的时间，其他工作负载仍然可以使用它。</p>
<p>但是，在其他容器上运行的特定工作负载的性能会受到显著影响。</p>
</li>
<li><p>blkio cgroup</p>
<p>正如2.1节中提到的，blkio cgroup子系统可以对块设备应用I&#x2F;O控制。虽然Docker只支持通过权重来限制相对I&#x2F;O吞吐量，但内核实际上可以为cgroups设置一个上限。我们使用blkio对运行同步的容器应用I&#x2F;O控制。不幸的是，基于Docker的统计工具，容器的I&#x2F;O吞吐量为零。因此，blkio控制器不能减少同步的影响。原因是由sync触发的所有回写工作负载都在内核线程中处理，调用sync的容器没有I&#x2F;O工作负载。</p>
</li>
<li><p>I&#x2F;O-based DoS attacks</p>
<p>不管发出I&#x2F;O操作的进程是否在容器内，在容器内调用系统调用同步将继续调用系统范围的回写。在某些情况下，回写会降低系统性能，因为特定的工作负载需要等待回写完成。为了测试有效性，我们运行两个固定在两个不同核心上的容器。恶意容器所做的唯一任务是调用系统调用sync，因此本身不会招致I&#x2F;O操作。</p>
<p>为了测量受害容器的性能，我们在受害容器内运行FIO基准测试来测量I&#x2F;O性能。特别地，我们进行了四种不同的FIO工作负载，包括序列&#x2F;随机写和序列&#x2F;随机读。我们还运行UnixBenchmark来测试除I&#x2F;O以外对性能的影响。我们通过将结果除以恶意容器中运行空闲循环的基线情况来计算性能下降。结果如图所示。对于UnixBenchmark，我们列出了性能显著下降的工作负载。总的来说，我们可以看到在受害者中运行的FIO基准测试的性能受到了很大的影响。通过在恶意容器中不断调用sync，所有四种类型I&#x2F;O操作的性能都会受到显著影响。对于顺序写入，在我们的本地测试床上性能下降到2%，在EC2服务器上下降到13%。</p>
<p>对于UnixBenchmark，运行shell脚本的性能也严重降低到不到一半。对于其他基准测试，退化约为5%到10%。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/sysperformance.png" title alt data-align="center">

<ul>
<li><p>Resource-Freeing Attack(RFA)</p>
<p>RFA攻击的目标是通过争夺受害者的瓶颈资源来为攻击者的实例释放特定的资源。在容器环境的情况下，两个容器在争夺系统资源，如CPU。恶意容器试图提高其工作负载的性能（被称为beneficiary），以获得更多的系统资源。因此，恶意容器运行另一个轻量级程序（被称为helper）来释放受害者容器使用的资源，以便受益者能够获得更多的资源。帮助者只消耗很少的系统资源（因此它对beneficiary几乎没有影响），但可以显著影响在受害者容器内运行的工作负载。例如，在恶意容器中，受益者程序可以运行CPU密集型的工作负载，并与受害者容器在同一CPU核心上竞争CPU资源。受害者容器运行I&#x2F;O密集型的工作负载，因此CPU活动与I&#x2F;O操作的频率相联系：更多的I&#x2F;O操作使受害者容器消耗更多的CPU周期来处理这些请求。然后，恶意者运行一个辅助程序，定期调用sync，触发回写，并减少受害者的I&#x2F;O活动。这样可以降低受害者容器的CPU使用率，恶意容器可以获得更多的CPU资源。<br>我们通过在同一个核上运行两个容器来模拟实验。在受害容器中，我们模拟了一个网络爬虫的情况，其中容器不断地将一个网页写入一个新文件。</p>
<p>我们使用sysbench来测量恶意容器的CPU和内存性能，其中值越高表示性能越好。恶意容器还会定期调用sync来触发全局回写。对于基线情况，只有攻击者的容器是活动的，因此不存在对所有系统资源的竞争。然后，我们运行这两个容器，并将攻击者容器的性能与基线情况进行比较。如图，在没有RFA攻击的情况下，由于两个容器争夺同一核上的CPU资源，CPU性能(即白条)约为无竞争情况(即黑条)的一半，内存性能约为无竞争情况的1&#x2F;3。然而，通过发起RFA攻击(即灰色条)，恶意容器内的受益人可以在两个测试平台上获得更好的性能。特别是，在我们的本地服务器上，性能几乎与没有竞争的情况相同。</p>
</li>
</ul>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/resource.png"></p>
<ul>
<li><p>Covert Channels</p>
<p>最后，我们证明了cgroups中的不足也可能被恶意攻击者利用，在不同的核心之间构建基于时间的隐蔽通道。其思想是利用由磁盘数据同步引起的性能差异。我们测量在一个容器中写入10个文件的时间，同时在另一个内核的另一个容器中运行sync。</p>
<p>我们重复实验100次，所需要的时间分布如图所示。我们可以观察到运行同步和不运行同步之间打开文件的明显时间差异。我们通过利用性能差异构建了一个概念验证通道，能够以2bits&#x2F;s的速率传输数据，错误率为2%。</p>
</li>
</ul>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Probability.png"></p>
<h2 id="Case-3-System-Process-Journald"><a href="#Case-3-System-Process-Journald" class="headerlink" title="Case 3:System Process - Journald"></a>Case 3:System Process - Journald</h2><p>我们的第三个案例是利用system - Journal服务，它提供了一个系统服务来收集系统日志数据，包括内核日志消息、系统日志消息(例如，syslog调用或Journal API)，以及通过审计子系统的审计记录。所有相关的活动都由系统进程日志记录。在我们的案例研究中，我们发现容器中的三类操作可以迫使日志进程记录日志，导致5%到20%的额外CPU利用率和平均2MB&#x2F;s的I&#x2F;O吞吐量，然后可以利用这些影响其他容器的性能。</p>
<ul>
<li><p>Detailed analysis</p>
<p>主机的系统进程被附加到不同于容器中的进程的cgroup中，因为它们是由操作系统维护的，以提供全系统的功能。因此，如果容器内的工作负载可以触发这些系统进程的活动，那么这些活动所消耗的资源将不会被计入容器的cgroup，从而逃避资源控制机制。但是，运行在主机上的系统进程会忽略容器内的大部分操作。例如，在主机上运行的用户空间进程的许多活动将由日志记录。但是如果流程在容器内运行，那么这些活动将被忽略。为了记录容器内的事件，主机上的系统管理员需要更改system -journal服务的配置。</p>
<p>特别是，Docker提供了一个选项来启用日志记录。</p>
<p>然而，我们发现，即使没有启用日志记录选项，在某些特定的情况下，容器仍然能够在日志系统进程上生成不可忽略的工作负载。</p>
<p>特别地，我们介绍了导致系统进程负载的三种类型的操作，从而逃脱了cgroup的控制。</p>
</li>
<li><p>Switch user (su) command</p>
<p>su命令提供了一种将登录会话的所有权切换到root用户的方法。</p>
<p>切换到root用户的操作将被记录在日志系统进程中。日志包含进程、用户帐户和环境切换的信息。日志服务也会记录用户的退出。使用USER namespace，容器内的根用户映射到主机上的无特权用户。因此，容器中的进程可能在USER名称空间中拥有完全的特权，但实际上在主机上被剥夺了特权。作为容器中的根用户，su命令可以进入另一个用户。不幸的是，在容器内切换帐户所引起的活动将触发system -journal服务来记录相关信息。</p>
</li>
<li><p>Add user&#x2F;group</p>
<p>在USER namespace中，容器用户可以添加新组或在现有组中添加新帐户。这些活动也将由主机上的日志系统进程记录。</p>
</li>
<li><p>Exception</p>
<p>最后，如前所述，内核无法区分所引发异常的上下文(在容器内部或外部)。因此，容器内异常引起的崩溃信息也会触发主机上系统进程的日志记录活动。</p>
<p>所有上述工作负载都将在日志中触发大量事件日志记录。同样，我们将一个容器设置为具有一个CPU核心计算能力，以继续调用上述命令。在我们的本地测试床上，我们观察到journald上的CPU使用率恒定为3.5%，auditd上的CPU使用率恒定为2.5%，kauditd上的CPU使用率恒定为1%。在EC2服务器中，由于其更好的I&#x2F;O性能，这个数字要大得多:我们观察到平均CPU利用率约为20%。我们还发现，journald进程的平均I&#x2F;O吞吐量约为2MB&#x2F;s，而容器的I&#x2F;O吞吐量为零。如果我们为容器分配更多的计算资源，这个数字将会增加。</p>
</li>
<li><p>DoS attacks</p>
<p>日志journald活动将产生不可忽略的I&#x2F;O操作，这将导致与其他容器的资源竞争。为了衡量结果，我们在主机的不同内核上运行两个容器。在恶意容器中，我们不断切换用户(即su)并退出当前用户(即exit)。在受害容器中，运行与case 2中描述的相同的基准测试。</p>
<p>图显示了结果。总的来说，我们看到整个系统的性能下降。在I&#x2F;O性能较差的服务器(例如，我们的本地测试平台)中，滥用journald的攻击将更加有效。如前所述，它在日志进程中可能导致超过2MB&#x2F;s的I&#x2F;O吞吐量。我们观察到它仍然可以使EC2专用服务器上的其他容器在1000iops(吞吐量约为15MB&#x2F;s)时变慢。在一个具有默认配置的专用服务器中(例如，400 IOPS，吞吐量约为6MB&#x2F;s)，我们可以观察到更明显的结果。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Performance%20degradation%20of%20DoS%20attacks%20exploiting%20journald..png" title alt data-align="center">

<ul>
<li><p>Residual effect</p>
<p>在I&#x2F;O性能较差的服务器上，系统进程的写工作负载可能超过服务器的I&#x2F;O能力。结果，大量的日志事件被排队，等待稍后被记录。这将导致一个残留效应:即使容器停止了它的工作负载(例如su)，系统仍将继续在journald中写入，直到队列中的工作负载完成。残留效应在我们的本地测试平台上很明显，并且持续的时间比工作负载的运行时间长得多。即使容器完全空闲，CPU和I&#x2F;O资源也会被消耗。更糟糕的是，这些写入操作将显著影响其他容器和主机的I&#x2F;O性能。</p>
</li>
</ul>
<h2 id="Case-4-Container-Engine"><a href="#Case-4-Container-Engine" class="headerlink" title="Case 4:Container Engine"></a>Case 4:Container Engine</h2><p>容器的第四种情况是通过在内核线程(例如kworker)和容器引擎上触发额外的工作负载来利用容器引擎，容器引擎需要在主机上运行以支持和管理容器实例。特别是，容器引擎作为系统上的特权守护进程运行，因此它作为容器实例附加到不同的cgroup上。容器实例上的cgroup限制将不能控制引擎上消耗的资源。总的来说，通过这种方式，我们发现一个容器可以将资源消耗增加到大约3倍。</p>
<ul>
<li><p>Detailed analysis</p>
<p>我们首先简要介绍Docker容器引擎及其cgroup层次结构。Docker创建一个包含所有容器实例的Docker cgroup。每个容器由其ID标识，并保存由fork创建的所有进程。从理论上讲，容器内运行的所有工作负载都将被计入容器cgroup。</p>
<p>此外，Docker构建在Docker引擎之上，其中一个守护进程(即dockerd)在后台运行，处理Docker映像的管理。Docker引擎然后与containd(一个守护进程)通信，以进一步使用runC来运行容器。dockerd进程对于每个容器实例都有多个子进程。这些进程被附加到所有系统服务的默认cgroup中。</p>
<p>此外，用户主要通过命令行接口(CLI)客户端(即Docker进程)控制和管理Docker, Docker进程通过Docker REST API与Docker守护进程交互。Docker CLI为用户提供了创建或执行容器的接口。它还提供了多个命令来设置与底层控制组相关的资源限制的配置。与Docker引擎进程类似，Docker CLI也不属于容器的cgroup。</p>
<p>利用容器引擎来打破cgroups的控制是相当容易的。一种简单的方法是利用终端子系统。当容器用户与tty设备交互时，数据首先经过CLI进程和容器守护进程，然后到达tty驱动程序进行进一步处理。具体来说，数据被发送到LDISC, LDISC连接高级通用接口(例如，读、写、ioctl)和终端系统中的低级设备驱动程序。通过在kworker内核线程中执行工作队列将数据刷新到LDISC。因此，内核线程上的所有工作负载和所有容器引擎进程都不会被计算到容器实例中。</p>
<p>我们通过在终端中反复显示主机中所有加载的模块来测量容器引擎中生成的工作负载，并将结果说明在图中。同样，容器的使用仅限于一个核心(如图中的container)。</p>
<p>总的来说，使用一个核心的计算能力(100%的利用率)，容器可以通过滥用docker引擎进程在主机上造成大约300%的工作负载。</p>
</li>
</ul>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/CPU%20utilization.png"></p>
<p>为了细分使用情况，docker进程属于主机的用户cgroup；其他docker进程属于一个系统cgroup：docker.service。其余的（大部分是内核线程kworker，由于流媒体工作负载，如第3.2节所解释）属于根cgroup。我们还在case 1中进行了与表类似的实验。通过利用Docker容器引擎，攻击者能够降低CPU和内存的性能大约15%。</p>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/DoSattackResult.png" title alt data-align="center">

<h2 id="Case-5-Softirq-Handling"><a href="#Case-5-Softirq-Handling" class="headerlink" title="Case 5:Softirq Handling"></a>Case 5:Softirq Handling</h2><p>最后一种情况是利用Linux内核中的softirq处理机制。当前内核定义了11种类型的softirq。特别是，硬件中断处理程序通常会引发软中断。</p>
<p>虽然大多数硬件中断可能不是由容器直接引发的，但容器用户能够操作网络接口上的工作负载生成NET softirq，或块设备生成block softirq。处理这些softirq会消耗内核线程进程上下文(例如ksoftirqd)或中断上下文上的CPU资源。</p>
<ul>
<li><p>NET softtirq</p>
<p>一旦NIC完成数据包传输，就会引发中断，而softirq负责在驱动程序缓冲区和网络堆栈之间移动数据包。但是，在流量带宽有限的情况下，使用softirqs带来的开销可以忽略不计:在之前的工作中，当网络流量超过1gbps时，开销为1%。</p>
<p>我们发现，由于网络流量引起的开销会被服务器上的防火墙系统(如iptables)大大放大。iptables建立在netfilter的基础上，提供了一个管理层，用于包过滤规则的添加和删除。netfilter将数据包挂在网络驱动程序和网络堆栈之间。所有的网络数据包首先通过过滤规则进行检查，然后进行进一步的操作(例如，转发、丢弃、由网络堆栈处理)。因此，iptables下的网络流量处理是在softirq上下文中处理的，因此不会向生成或接收流量的容器收费。</p>
<p>在Linux上，Docker依赖于配置iptables规则来为容器提供网络隔离。特别是，它可能为提供web或网络服务的容器设置多个规则。即使容器停止，规则也存在。更糟糕的是，在某些情况下，如果相关标志设置为true，容器可以对系统iptables规则进行更改。一旦有相当数量的规则，开销将是不可忽略的。</p>
<p>我们测量了softirq在不同数量的iptables规则下处理网络流量所带来的开销，如图所示。特别是，我们测量了所有ksoftirqd内核线程的CPU使用情况，以及花在中断上下文上的时间(来自top命令的hi和si)。在我们本地的测试台上，网卡的容量为100mbit &#x2F;s，网络流量约为20 ~ 30mbit &#x2F;s，明显小于中的Gbps级别。我们可以清楚地看到，处理网络流量会产生巨大的开销，并且与规则数量密切相关。当规则数量达到5000条时，CPU将浪费大量的时间(约16%)处理软tirq，并且不会向发起网络流量的容器收费。一旦服务器中有10,000条规则，开销约为40%，其中大多数集中在一个核心上。</p>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/iptable.png"></p>
<p>EC2服务器有一个非常强大的网卡，具有10,000 Mbit&#x2F;s的容量，与我们的本地测试平台相比带宽更高。因此，与我们的本地测试平台相比，开销略小。在我们的实验中，当网络流量约为300mbit &#x2F;s时，流量仍然会浪费不可忽略的CPU周期。如3.4节所述，软件中断的处理要么抢占当前工作，要么在内核线程中消耗CPU周期。因此，同一核心上的所有其他工作负载将被延迟。</p>
</li>
<li><p>BLOCK softirq</p>
<p>处理softirq时增加工作负载的另一个例子是块设备上的I&#x2F;O操作。Linux内核使用队列存储块请求I&#x2F;O，并将新的请求添加到队列中。一旦请求处理完成，它将引发在softirq上下文中处理的softirq，以进一步处理队列。然后，利用BLOCK softirq转义cgroups的基本思想类似于利用NET softirq。</p>
<p>在容器上下文中，可以通过持续查询完成队列中的事件并提交写或读操作来生成这样的工作负载。对于I&#x2F;O性能较差的设备，这种影响尤其明显。为了进一步定量度量影响，我们使用固定在一个内核上的容器，运行fio推荐来执行顺序读写。我们选择小块用于写入，大块用于读取。我们测量多个内核线程(如kworker)的CPU利用率。容器中的工作负载能够在我们的本地测试平台上的内核上生成不可忽略的工作量，包括相同内核的kworker上16.7%的工作负载。此外，对于序列I&#x2F;O读取，文件分配过程在jpd2和kswapd上分别产生了3.9%和3.8%的额外利用率。最后，我们还利用kworker来测量退化。我们在同一个内核上的内核线程kworker上创建工作负载，攻击者能够对受害者造成大约10%的性能损失(根据sysbench基准测试测量)。</p>
</li>
</ul>
<h1 id="MITIGATION-DISCUSSION"><a href="#MITIGATION-DISCUSSION" class="headerlink" title="MITIGATION DISCUSSION"></a>MITIGATION DISCUSSION</h1><p>在这一节中，我们将介绍我们在以下方面的初步努力应对现有cgroups机制的不足所带来的安全问题。由于大多数问题涉及多个内核子系统，因此很难部署一个单一的解决方案来全面彻底地解决所有问题。另外，解决一些问题可能需要重新设计当前的资源核算系统。在下文中，我们将从不同角度讨论潜在的缓解方法。</p>
<p>直观地说，通过考虑由一组进程(或容器)直接或间接生成的所有工作负载，cgroups应该具有细粒度的计算机制。例如，如果一个容器通过内核线程调用另一个用户空间进程，容器的cgroup应该由内核线程传递，这样它也会被复制到新的用户空间进程。因此，新调用的进程与容器属于同一个cgroup，而不是与内核线程属于根cgroup。虽然这种方法可以应用于新生成的进程，但很难处理系统中已经存在的进程。内核线程(如kworker、ksoftirqd)是由内核创建的，用于处理特定的内核工作负载，这些工作负载可能由附加到不同cgroup的不同进程触发。journald系统进程的情况也类似:它记录所有进程引发的所有相关事件，因此将整个日志进程附加到特定的cgroup是不合理的。因此，综合机制不应该改变这些线程的cgroup，而是应该跟踪特定工作量的系统资源，并将其收费给初始进程。例如，Iron跟踪处理每个网络数据包的CPU周期，并向相关进程收费。然而，这样的方法无疑需要大量的内核开发工作，并且由于将多个内核函数用于细粒度资源跟踪而带来大量的运行时开销。</p>
<p>对于某些工作负载，另一个有争议的问题是cgroup是否应该向容器收取这些系统资源。从隐私的角度考虑，主机服务器不应该记录容器实例中运行的任何敏感信息。journald提供了特定的选项来启用容器内的日志活动。但是，我们展示了，即使没有启用日志记录选项，主机仍然为容器记录多个事件。日志记录是由主机执行的，因此不应该向容器收费。此外，容器用户无法获得容器内引发的异常的核心转储信息。因此，一种可能的方法是通过区分容器上下文禁用所有潜在的日志记录或记录活动。完全解决这个问题的另一种方法是构建一个额外的cgroup子系统，专门用于日志记录。所有日志记录活动都将由新的日志记录cgroup子系统进行记录。</p>
<p>最后，有些问题即使使用细粒度的会计机制也无法解决。例如，虽然当前的cgroups机制清楚地提到回写工作负载不被计算在内，但Linux内核维护者已经开始开发新的cgroup机制(即cgroup v2)，它利用内存和blkio子系统来跟踪回写并为脏页的容器收费。然而，恶意容器可以在不生成任何I&#x2F;O工作负载的情况下继续调用sync。回写工作负载由具有I&#x2F;O操作的容器承担，而不是由恶意容器承担。同时，向调用数据同步的容器收取所有费用是不公平的。由于简单地禁用所有这些功能将不可避免地影响可用性，一个潜在可行的解决方案是对这些敏感操作施加速率限制。</p>
<h1 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h1><p>在本节中，我们调查了一些启发我们工作的研究工作，并强调了我们的工作与以往研究之间的差异。我们主要讨论以下两个方面的研究工作:</p>
<h2 id="Virtual-Machine-and-Container"><a href="#Virtual-Machine-and-Container" class="headerlink" title="Virtual Machine and Container"></a>Virtual Machine and Container</h2><p>虽然VM已经迎来了云计算时代，但尽管进行了大量的研究工作，其性能仍然不能令人满意。容器正变得越来越流行，因为它提供了一种启用轻量级虚拟化的替代方式，并允许在容器中运行的应用程序完全兼容。因此，研究人员对硬件虚拟化和容器之间的性能比较很好奇。Felter等人表明，通过使用一组涵盖CPU、内存、存储和网络资源的基准测试，Docker在所有情况下都可以实现比KVM更高的性能。</p>
<p>Spoiala等还证明了Docker优于KVM，并且可以使用Kurento Media Server来测试WebRTC服务器的性能，从而支持实时应用程序。Morabito et al进一步比较了传统hypervisor(例如KVM)和os级虚拟化(包括Docker和LXC)在计算、存储、内存和网络方面的性能，并观察到磁盘I&#x2F;O仍然是KVM hypervisor的瓶颈。所有这些工作都表明，基于容器的操作系统级虚拟化是比传统的基于vm的硬件虚拟化更有效的解决方案。虽然以前的大多数研究工作都集中在理解容器的性能上，但很少有人试图调查底层内核机制的资源共享的有效性。我们是第一批系统地研究由Cgroup不足引起的容器的性能和资源核算问题的人。</p>
<h3 id="Container-security"><a href="#Container-security" class="headerlink" title="Container security"></a>Container security</h3><p>除了性能，容器的安全性也受到了学术界和业界的广泛关注。Gupta首先简要介绍了Docker安全性。Bui从隔离和相应的内核安全机制方面对Docker容器进行了分析。虽然之前的工作声称Docker容器在默认配置下是相当安全的，但Lin等人发现，大多数现有的漏洞都可以通过默认配置成功地从容器内部发起攻击。Grattafiori等人总结了容器的各种潜在漏洞，包括基于内存的伪文件系统中的问题。Gao等人进一步对基于内存的伪文件系统由于namespace问题而产生的潜在安全影响进行了系统研究。Lei等人提出了一种名为SPEAKER的容器安全机制，以减少对应用程序的可用系统调用数量。Sun等人开发了两个安全命名空间，为容器实现自主安全控制，Arnautov等人提出使用Intel SGX保护Linux容器。</p>
<p>错误配置的能力也可以被利用来建立容器中的秘密通道。我们在cgroup方面的工作进一步补充了以前的的研究工作。</p>
<h2 id="Cloud-Security"><a href="#Cloud-Security" class="headerlink" title="Cloud Security"></a>Cloud Security</h2><h3 id="Co-residence"><a href="#Co-residence" class="headerlink" title="Co-residence"></a>Co-residence</h3><p>大量的研究工作也致力于理解云的安全问题，特别是不同租户共享相同计算基础设施的多租户云。在多租户云环境中，攻击者可以将恶意虚拟机与目标虚拟机共同驻留在同一台服务器上，然后发起包括侧通道和隐蔽通道攻击在内的各种攻击。同时，侧面攻击和隐蔽通道攻击是验证同一物理服务器上共存的常用方法。例如，基于缓存的隐蔽通道被广泛采用，因为多个实例共享同一个包上的最后一级缓存。Zhang等人进一步论证了在云上发起真实侧通道攻击的可行性。除了基于缓存的通道，其他方法如内存总线、内存重复数据删除、核心温度也可以有效地构建隐蔽通道。</p>
<p>虽然也提出了多种防御机制，但之前的两项工作表明，在现有的主流云服务中实现合住仍然是可行的(而且成本低廉)。Wang等人对三种无服务器计算服务进行了大规模的测量研究，发现了几个资源核算问题，租户可能会滥用这些问题来运行额外的工作负载。</p>
<h3 id="Denial-of-Service-attacks"><a href="#Denial-of-Service-attacks" class="headerlink" title="Denial-of-Service attacks"></a>Denial-of-Service attacks</h3><p>由于底层计算资源在不同的租户之间共享，因此争用是不可避免的。Varadarajan等人提出了资源释放攻击来释放受害者使用的资源，这样攻击者的实例就可以获得额外的利用。Zhang等人调查了内存DoS攻击的影响，并表明恶意云客户可以对电子商务网站造成38倍的延迟。对于针对I&#x2F;O性能的DoS攻击，Huang等提出了级联性能攻击，以耗尽hypervisor的I&#x2F;O处理能力。此外，多种攻击试图耗尽共享的基础设施资源，如电力设施，从而迫使数据中心的服务器关闭。与之前的工作不同，我们的工作表明，cgroups中的不足也可以被利用来在多租户容器环境中发起多次攻击。</p>
<h1 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h1><p>在本文中，我们开发了一套策略来打破Linux控制组的资源控制。我们证明了通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。我们可以通过与原始cgroup解关联的进程来生成带外工作负载。</p>
<p>我们进一步提出了五个案例研究，表明在Docker容器环境中实现这些攻击是可行的。恶意容器利用多租户容器环境中cgroups的这些不足，可以极大地耗尽主机的资源，并发起多种攻击，包括拒绝服务攻击、资源释放攻击和秘密通道攻击。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行了实验，并证明了一个容器可以将其工作负载放大200倍以上，并将其他容器的性能降低95%。</p>
<h1 id="My"><a href="#My" class="headerlink" title="My"></a>My</h1><h2 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h2><p>Linux 内核为各种异常提供了专用的异常处理程序。这些异常处理程序分为两类：错误和陷阱。错误是指程序在运行过程中遇到的问题，如分段错误。陷阱是指程序主动触发的事件，如溢出检测。</p>
<p>在处理这些异常时，内核维护了一个名为中断描述符表（IDT）的数据结构。IDT 包含每个异常处理程序的地址。当 CPU 在用户模式下引发异常时，相应的处理程序将在内核模式下运行。</p>
<ol>
<li><p><strong>寄存器保存和上下文切换</strong>：当异常发生时，处理器首先将当前的寄存器状态保存到内核堆栈中。这样，在异常处理完成后，处理器可以恢复原始状态并返回到用户模式。</p>
</li>
<li><p><strong>异常处理</strong>：在内核模式下，处理器会根据异常类型调用相应的处理程序。异常处理程序通常会执行一些特定的操作，如清理资源、记录错误信息等。在处理异常时，整个过程将在内核空间和触发异常的进程上下文中运行。因此，异常处理期间消耗的资源将被计入相应的 cgroups。</p>
</li>
<li><p><strong>信号处理和内核转储</strong>：异常处理程序可能会终止初始进程，并向其发送一个信号。这些信号会触发内核转储功能，生成一个用于调试的内核转储文件。在 Linux 内核中，核心转储代码通过 usermode 辅助 API 调用一个用户空间的应用程序来完成这个任务。</p>
</li>
<li><p><strong>用户空间核心转储程序</strong>：在 Ubuntu 中，默认的用户空间核心转储程序是 Apport，它会在每个异常情况下被触发。Apport 的资源消耗不会由容器承担，因为它是由内核线程创建的，而不是由容器化的进程创建的。</p>
</li>
<li><p><strong>负载平衡和资源放大</strong>：内核会将新生成的 Apport 实例调度到所有可用的 CPU 核心上，以实现负载平衡。这会导致打破 cpusets cgroup 的约束。同时，由于 Apport 进程比轻量级的异常处理（即内核控制路径）消耗更多资源，如果容器不断触发异常，整个 CPU 可能会被 Apport 进程占满。这种情况导致了分配给容器的系统资源的放大。</p>
</li>
</ol>
<p>总结一下，当用户程序触发异常时，Linux 内核会通过 IDT 找到相应的处理程序，并在内核模式下运行。处理程序可能会终止进程并触发内核转储功能。在 Ubuntu 中，这会调用用户空间的 Apport 程序来生成内核转储文件。Apport 的资源消耗不会由容器承担，但可能导致资源放大和 cpusets cgroup 的约束被打破。</p>
<p>当你在使用电脑时，有时会遇到一些问题，比如程序出错或者意外停止运行。这些问题通常是由于程序中的异常引起的。在 Linux 系统中，有一套专门处理这些异常的机制。</p>
<p>想象一下，当程序遇到异常时，就像一个球员在比赛中受伤了。这时，教练（内核）会派上另一个球员（异常处理程序）来处理这个问题。这个过程发生在球场内（内核空间），并且会记录下这个问题发生的原因。</p>
<p>在处理异常时，教练需要确保其他球员不受影响。因此，教练会将受伤球员的状态保存起来，等问题处理完后再恢复。这个过程就像是在现场给受伤球员做紧急处理。</p>
<p>有时，这个问题严重到需要告知其他人（发送信号）。在这种情况下，教练会通知医疗团队（Apport 程序）来处理。医疗团队会把受伤球员的情况记录下来（生成内核转储文件），以便在之后分析和处理。</p>
<p>需要注意的是，医疗团队（Apport）处理问题时所消耗的资源不会影响球队（容器），但有时他们的处理可能会让整个比赛（系统资源）受到影响，导致其他球员的表现受到一定程度的影响。</p>
<p>总之，当电脑遇到问题时，Linux 系统会通过一套内核机制来处理这些异常。在处理过程中，可能会涉及到一些额外的程序，如 Apport，在确保不影响其他程序运行的前提下，记录和处理异常。  </p>
<h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h2><ol>
<li><p><strong>磁盘数据同步回写机制</strong>：这是一种性能优化策略，使CPU只将更新后的数据写入缓存，而不是直接写入磁盘。当缓存被清除时，数据才会写入磁盘。这种机制通过将启动I&#x2F;O进程与同步磁盘写入进程解耦来提高性能。</p>
</li>
<li><p><strong>同步</strong>：同步是将缓存中的数据写回磁盘的过程。这可以通过多种方法触发，例如定期回写、内存不足，或者通过用户进程故意调用系统调用（如sync、syncfs和fsync）。这些系统调用对Linux容器是可用的。</p>
</li>
<li><p><strong>利用同步的攻击</strong>：由于同步允许进程将所有脏缓冲区写回磁盘，因此在同步期间，任何I&#x2F;O操作都必须等待。这可以被恶意进程利用，通过重复调用sync，以减慢整个系统的I&#x2F;O性能、发起无资源攻击，甚至建立秘密通道。</p>
</li>
<li><p><strong>绕过cgroup</strong>：cgroup是一种用于限制资源使用的机制，但由于同步操作是在内核线程中进行的，并且调用sync的容器没有I&#x2F;O工作负载，因此cgroup无法限制同步操作。在这种情况下，即使使用blkio cgroup子系统对运行同步的容器应用I&#x2F;O控制，仍然无法减少同步的影响。这是因为blkio控制器仅限制相对I&#x2F;O吞吐量，而不是绝对值。此外，Docker的统计工具显示，调用sync的容器的I&#x2F;O吞吐量为零，这意味着blkio限制不起作用。</p>
</li>
</ol>
<p>这个案例讲述了一个关于磁盘数据同步的技术，它叫做懒惰回写（lazy write-back）。这种技术的主要优点是提高电脑的性能。当我们在电脑上做一些改动时，这些改动首先会被保存在缓存中，而不是直接写入磁盘。只有当缓存被清空时，改动才会真正地被保存到磁盘里。这样的操作可以节省时间，因为写入磁盘的速度往往比写入缓存慢。</p>
<p>这种技术可以让一个攻击者绕过cgroups的限制。cgroups是一种用于限制程序在电脑上使用的资源的技术。简单来说，攻击者可以通过触发数据同步，让电脑的整体性能下降。这就像是在公路上开车，突然有人打开了所有的红绿灯，导致所有的车辆都必须停下来等待。</p>
<p>懒惰回写的关键在于同步（sync）。同步是一个过程，它会把缓存里的数据写入磁盘。当一个程序调用同步时，它会让电脑暂停其他操作，等待数据写入磁盘。如果一个攻击者不断地调用同步，那么电脑的性能就会受到影响，因为其他程序需要不断地等待同步完成。</p>
<p>现在我们来谈谈cgroups。cgroups是一种技术，可以用来限制程序使用电脑上的资源，比如CPU、内存和磁盘等。但是，在这个案例中，攻击者利用同步绕过了cgroups的限制。原因是，攻击者调用同步时，并没有直接进行磁盘读写操作，而是让内核（电脑的核心部分）进行了这些操作。因此，cgroups无法检测到攻击者的行为，也就无法限制它。</p>
<p>总之，这个案例向我们展示了一个攻击者可以利用懒惰回写的同步机制来绕过cgroups的限制。这可能会导致电脑的整体性能下降，给其他用户带来麻烦。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/" class="post-title-link" itemprop="url">C++学习 函数高级</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-15 08:36:52" itemprop="dateCreated datePublished" datetime="2023-04-15T08:36:52+08:00">2023-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-17 10:03:44" itemprop="dateModified" datetime="2023-04-17T10:03:44+08:00">2023-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h1><p>在C++中，函数形参列表中的形参是可以有默认值的</p>
<p>语法：<code>返回值类型 函数名 （参数 = 默认值）</code>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>60</p>
<p>70</p>
</blockquote>
<p>注意事项</p>
<ul>
<li>如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值</li>
</ul>
<img src="/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/Error1.png" title alt data-align="center">

<ul>
<li>声明和实现只能有一个有默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p><img src="/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/Error2.png"></p>
<h1 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h1><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用参数时必须填补该位置</p>
<p> 语法：<code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h2><p>作用：函数名可以相同，提高复用性</p>
<p>函数重载满足条件：</p>
<ul>
<li><p>同一个作用域下</p>
</li>
<li><p>函数名称相同</p>
</li>
<li><p>函数参数类型不同或者个数不同或者顺序不同</p>
</li>
</ul>
<p>注意：函数的返回值不可以作为函数重载的条件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,double b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a,int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">3.1</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>func()<br>func(int a)<br>func(int a,int b)<br>func(int a,double b)<br>func(double a,int b)</p>
</blockquote>
<h2 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h2><ul>
<li>引用作为函数重载条件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int &amp;a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(const int &amp;a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>func(int &amp;a)<br>func(const int &amp;a)</p>
</blockquote>
<ul>
<li>函数重载碰到默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a, int b = 10)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/Error3.png" title alt data-align="center">

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/" class="post-title-link" itemprop="url">MIT6 S081 Operating System Engineering Lecture05 Calling conventions and stack frames RISC-V(TA)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-14 15:14:27 / Modified: 20:59:02" itemprop="dateCreated datePublished" datetime="2023-04-14T15:14:27+08:00">2023-04-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">课程学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/" itemprop="url" rel="index"><span itemprop="name">MIT6.S081 Operating System Engineering</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C程序到汇编程序的转换"><a href="#C程序到汇编程序的转换" class="headerlink" title="C程序到汇编程序的转换"></a>C程序到汇编程序的转换</h1><p>当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。</p>
<p>所以通常来说，要让C语言能够运行在你的处理器之上。我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。</p>
<p>如果你们曾经注意过你们的lab目录，在运行完<em>make qemu</em>之后你会看到一些.o文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些.asm文件，这是由C语言编译生成的。</p>
<p>汇编语言不具备C语言的组织结构，在汇编语言中你只能看到一行行的指令，比如add，mult等等。汇编语言中没有很好的控制流程，没有循环（注，但是有基于lable的跳转），虽然有函数但是与你们知道的C语言函数不太一样，汇编语言中的函数是以label的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如C++，都会编译成汇编语言。运行任何编译型语言之前都需要先生成汇编语言。</p>
<p>以上就是让计算机能够理解我们的C代码的基本流程。</p>
<h1 id="RISC-V-vs-X86"><a href="#RISC-V-vs-X86" class="headerlink" title="RISC-V vs X86"></a>RISC-V vs X86</h1><p>RISC-V和x86并没有它们第一眼看起来那么相似。RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。这两者之间有一些关键的区别：</p>
<ul>
<li><p>首先是指令的数量。实际上，创造RISC-V的一个非常大的初衷就是因为Intel手册中指令数量太多了。x86-64指令介绍由3个文档组成，并且新的指令以每个月3条的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有多于15000条指令。RISC-V指令介绍由两个文档组成。在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣或者你发现你不能理解某个具体的指令的话，在课程网站的参考页面有RISC-V指令的两个文档链接。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多的多。这是有关RISC-V比较好的一个方面。所以在RISC-V中，我们有更少的指令数量。</p>
</li>
<li><p>除此之外，RISC-V指令也更加简单。在x86-64中，很多指令都做了不止一件事情。这些指令中的每一条都执行了一系列复杂的操作并返回结果。但是RISC-V不会这样做，RISC-V的指令趋向于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员的在底层设计时的取舍。并没有一些非常确定的原因说RISC比CISC更好。它们各自有各自的使用场景。</p>
</li>
<li><p>相比x86来说，RISC另一件有意思的事情是它是开源的。这是市场上唯一的一款开源指令集，这意味着任何人都可以为RISC-V开发主板。RISC-V是来自于UC-Berkly的一个研究项目，之后被大量的公司选中并做了支持，网上有这些公司的名单，许多大公司对于支持一个开源指令集都感兴趣。</p>
</li>
</ul>
<p>比如说ARM也是一个精简指令集，高通的Snapdragon处理器就是基于ARM。如果你使用一个Android手机，那么大概率你的手机运行在精简指令集上。如果你使用IOS，苹果公司也实现某种版本的ARM处理器，这些处理器运行在iPad，iPhone和大多数苹果移动设备上，甚至对于Mac，苹果公司也在尝试向ARM做迁移（注，刚刚发布的Macbook）。所以精简指令集出现在各种各样的地方。如果你想在现实世界中找到RISC-V处理器，你可以在一些嵌入式设备中找到。所以RISC-V也是有应用的，当然它可能没有x86那么流行。</p>
<p>在最近几年，由于Intel的指令集是在是太大了，精简指令集的使用越来越多。Intel的指令集之所以这么大，是因为Intel对于向后兼容非常看重。所以一个现代的Intel处理器还可以运行30&#x2F;40年前的指令。Intel并没有下线任何指令。而RISC-V提出的更晚，所以不存在历史包袱的问题。我们需要许多指令来实现向后兼容，向后兼容是否重要因人而异。另一方面，我认为这里许多指令都是cmd指令，用来完成一些特殊的操作。我从来没有见过一个Intel的汇编代码使用了所有的15000个指令。大多数这些指令都是为了向后兼容和cmd的需求创建。</p>
<p>如果查看RISC-V的文档，可以发现RISC-V的特殊之处在于：它区分了Base Integer Instruction Set和Standard Extension Instruction Set。Base Integer Instruction Set包含了所有的常用指令，比如add，mult。除此之外，处理器还可以选择性的支持Standard Extension Instruction Set。例如，一个处理器可以选择支持Standard Extension for Single-Precision Float-Point。这种模式使得RISC-V更容易支持向后兼容。 每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。</p>
<h1 id="gdb和汇编代码执行"><a href="#gdb和汇编代码执行" class="headerlink" title="gdb和汇编代码执行"></a>gdb和汇编代码执行</h1><p>这部分还不太会操作</p>
<h1 id="RISC-V寄存器"><a href="#RISC-V寄存器" class="headerlink" title="RISC-V寄存器"></a>RISC-V寄存器</h1><img title src="/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/Register.webp" alt data-align="center">

<p>这个表里面是RISC-V寄存器。寄存器是CPU或者处理器上，预先定义的可以用来存储数据的位置。寄存器之所以重要是因为汇编代码并不是在内存上执行，而是在寄存器上执行，也就是说，当我们在做<code>add</code>，<code>sub</code>时，我们是对寄存器进行操作。所以我们通常看到的汇编代码中的模式是，我们通过<code>load</code>将数据存放在寄存器中，这里的数据源可以是来自内存，也可以来自另一个寄存器。之后我们在寄存器上执行一些操作。如果我们对操作的结果关心的话，我们会将操作的结果<code>store</code>在某个地方。这里的目的地可能是内存中的某个地址，也可能是另一个寄存器。这就是通常使用寄存器的方法。</p>
<p>寄存器进行任何运算和数据读取的最快的方式。当调用函数时，我们调用函数时，我们会用ABI名字。</p>
<p><code>a0</code>到<code>a7</code>寄存器是用来作为函数的参数。如果一个函数有超过8个参数，我们就需要用内存了。从这里也可以看出，当可以使用寄存器的时候，我们不会使用内存，我们只在不得不使用内存的场景才使用它。</p>
<p>表单中的第4列，Saver列，当我们在讨论寄存器的时候也非常重要。它有两个可能的值Caller，Callee。</p>
<ul>
<li><p>Caller Saved寄存器在函数调用的时候不会保存</p>
</li>
<li><p>Callee Saved寄存器在函数调用的时候会保存</p>
</li>
</ul>
<p>这里的意思是，一个Caller Saved寄存器可能被其他函数重写。假设我们在函数a中调用函数b，任何被函数a使用的并且是Caller Saved寄存器，调用函数b可能重写这些寄存器。我认为一个比较好的例子就是Return address寄存器（注，保存的是函数返回的地址），你可以看到ra寄存器是Caller Saved，这一点很重要，它导致了当函数a调用函数b的时侯，b会重写Return address。所以基本上来说，任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。</p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。</p>
<p>对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样，即使在这个图里面看起来是一样大的。不同的函数有不同数量的本地变量，不同的寄存器，所以Stack Frame的大小是不一样的。但是有关Stack Frame有两件事情是确定的：</p>
<ul>
<li><p>Return address总是会出现在Stack Frame的第一位</p>
</li>
<li><p>指向前一个Stack Frame的指针也会出现在栈中的固定位置</p>
</li>
</ul>
<p>有关Stack Frame中有两个重要的寄存器，第一个是SP（Stack Pointer），它指向Stack的底部并代表了当前Stack Frame的位置。第二个是FP（Frame Pointer），它指向当前Stack Frame的顶部。因为Return address和指向前一个Stack Frame的的指针都在当前Stack Frame的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。</p>
<p>我们保存前一个Stack Frame的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个Frame Pointer存储到FP寄存器中。所以我们使用Frame Pointer来操纵我们的Stack Frames，并确保我们总是指向正确的函数。</p>
<p>Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。所以通常，在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epollgue。</p>
<h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>基本上来说，struct在内存中是一段连续的地址，如果我们有一个struct，并且有f1，f2，f3三个字段。当我们创建这样一个struct时，内存中相应的字段会彼此相邻。你可以认为struct像是一个数组，但是里面的不同字段的类型可以不一样。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="随便记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/" class="post-title-link" itemprop="url">C++学习 引用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-14 09:25:57" itemprop="dateCreated datePublished" datetime="2023-04-14T09:25:57+08:00">2023-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-30 15:59:29" itemprop="dateModified" datetime="2023-04-30T15:59:29+08:00">2023-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h1><p>作用：给变量起别名</p>
<p>语法：数据类型 &amp;别名 &#x3D; 原名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>a &#x3D; 10<br>b &#x3D; 10<br>a &#x3D; 100<br>b &#x3D; 100</p>
</blockquote>
<h1 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h1><ul>
<li><p>引用必须初始化 </p>
</li>
<li><p>引用在初始化后，不可以改变</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    b = c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>a &#x3D; 20<br>b &#x3D; 20<br>c &#x3D; 20</p>
</blockquote>
<h1 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h1><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>
<p>优点：可以简化指针修改实参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>swap a &#x3D; 20<br>swap b &#x3D; 10<br>a &#x3D; 20<br>b &#x3D; 10</p>
</blockquote>
<p>引用传递，形参会修饰实参</p>
<p>地址传递，形参会修饰实参</p>
<p>值传递，形参不会修饰实参</p>
<h1 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h1><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：不要返回局部变量引用</p>
<p>用法：函数调用作为左值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">test</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test</span>() = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>ref &#x3D; 10<br>ref &#x3D; 1000</p>
</blockquote>
<h1 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h1><p>本质：引用的本质是在C++内部实现一个指针常量</p>
<p><code>int&amp; ref = a;</code>等价于<code>int* const ref = a;</code></p>
<p><code>ref = 20</code>当编译器发现ref是引用，会自动帮我们解引用转换为<code>*ref = 20</code></p>
<h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><p>作用：常量引用主要用来修饰形参，防止误操作。</p>
<p>在函数形参列表中，可以加const 修饰形参，防止形参改变实参</p>
<p><img src="/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/ERROR.png"></p>
<p><img src="/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/ERROR1.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plucky</p>
  <div class="site-description" itemprop="description">随便记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:p1ucky@163.com" title="E-Mail → mailto:p1ucky@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plucky</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">411k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">12:27</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
