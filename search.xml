<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 学习 Linux系统编程 Makefile</title>
    <url>/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/</url>
    <content><![CDATA[<h1 id="什么是Makefile"><a href="#什么是Makefile" class="headerlink" title="什么是Makefile"></a>什么是Makefile</h1><p>一个工程中源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。</p>
<p>Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发效率。make是一个命令工具，是一个工程完全编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，Visual C++的make，Linux下GUN的make</p>
<h1 id="Makefile文件命名和规则"><a href="#Makefile文件命名和规则" class="headerlink" title="Makefile文件命名和规则"></a>Makefile文件命名和规则</h1><ul>
<li><p>文件命名</p>
<p>makefile或者Makefile</p>
</li>
<li><p>Makefile规则</p>
<p>一个Makefile文件中可以有一个或多个规则</p>
<blockquote>
<p>目标 …: 依赖 …</p>
<p>       命令（shell命令）</p>
<p>        …</p>
</blockquote>
<ul>
<li><p>目标：最终要生成的文件（伪目标除外）</p>
</li>
<li><p>依赖：生成目标文件所需要的文件或是目标</p>
</li>
<li><p>命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进）</p>
</li>
</ul>
</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们现在有文件：</p>
<img title src="/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/nowfile.png" alt data-align="center">

<p>编辑Makefile文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">app:sub.c add.c mult.c div.c main.c</span></span><br><span class="line">    gcc sub.c add.c mult.c div.c main.c -o app</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img title src="/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/makefile.png" alt data-align="center">

<h1 id="Makefile的工作原理"><a href="#Makefile的工作原理" class="headerlink" title="Makefile的工作原理"></a>Makefile的工作原理</h1><ul>
<li><p>命令在执行之前，需要先检查规则中的依赖是否存在</p>
<ul>
<li><p>如果存在，执行命令</p>
</li>
<li><p>如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</p>
</li>
</ul>
</li>
<li><p>检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</p>
<ul>
<li><p>如果依赖的时间比目标的时间晚，需要重新生成目标</p>
</li>
<li><p>如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行</p>
</li>
</ul>
</li>
</ul>
<p>我们修改Makefile文件内容为：   </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">app:sub.o add.o mult.o div.o main.o</span></span><br><span class="line">    gcc sub.o add.o mult.o div.o main.o -o app</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">    gcc -c sub.c -o sub.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">    gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">    gcc -c div.c -o div.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c -o main.o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </span><br></pre></td></tr></table></figure>

<p>我们输入命令<code>make</code></p>
<img title src="/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/makefile2.png" alt data-align="center">

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul>
<li><p>自定义变量</p>
<p>变量名 &#x3D; 变量值  var &#x3D; hello</p>
</li>
<li><p>预定义变量</p>
<ul>
<li><p>AR：归档维护程序的名称，默认值为ar</p>
</li>
<li><p>CC：C编译器的名称，默认值为cc</p>
</li>
<li><p>CXX：C++编译器的名称，默认值为g++</p>
</li>
<li><p>$@：目标的完整名称</p>
</li>
<li><p>$&lt;：第一个依赖文件的名称</p>
</li>
<li><p>$^：所有的依赖文件</p>
</li>
</ul>
</li>
<li><p>获取变量的值</p>
<ul>
<li>$(变量名)</li>
</ul>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line">    gcc -c main.c a.c b.c</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>上两段代码等价</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o:%.o</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>% 为通配符，匹配一个字符串</p>
</li>
<li><p>两个%匹配的是同一个字符串</p>
</li>
</ul>
<p>我们上述的Makefile文件也可改为</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = sub.o add.o mult.o div.o main.o</span><br><span class="line">target = app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line">    <span class="variable">$(CC)</span> &amp;(src) -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="wildcard-PATTERN-…"><a href="#wildcard-PATTERN-…" class="headerlink" title="$(wildcard PATTERN …)"></a>$(wildcard PATTERN …)</h2><ul>
<li><p>功能：获取指定目录下指定类型的文件列表</p>
</li>
<li><p>参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</p>
</li>
<li><p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</p>
</li>
<li><p>示例：</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> *.c ./sub/*c)</span></span><br></pre></td></tr></table></figure>

<p>返回值格式：a.c b.c c.c d.c e.c f.c</p>
<h2 id="patsubst-lt-pattern-gt-lt-replacement-gt-lt-text-gt"><a href="#patsubst-lt-pattern-gt-lt-replacement-gt-lt-text-gt" class="headerlink" title="$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)"></a>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</h2><ul>
<li><p>功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>,如果匹配的话，则以<replacement>替换。</replacement></pattern></text></p>
</li>
<li><p><pattern>可以包括通配符<code>%</code>,表示任意长度的字符串。如果<replacement>中也包含<code>%</code>，那么，<replacement>中的这个<code>%</code>将是<pattern>中的那个<code>%</code>所代表的字符串。（可以用<code>\</code>来转义，以<code>\%</code>来表示真实含义的<code>%</code>字符）</pattern></replacement></replacement></pattern></p>
</li>
<li><p>返回：函数返回被替换过后的字符串</p>
</li>
<li><p>示例</p>
</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, x.c bar.c)</span></span><br></pre></td></tr></table></figure>

<p>返回值格式：x.o bar.o</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line">target=app</span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm <span class="variable">$(objs)</span> -f</span><br></pre></td></tr></table></figure>

<p>之后运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p>就会自动删除<code>rm</code>指令</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习 Linux系统编程 GDB调试</title>
    <url>/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="什么是GDB"><a href="#什么是GDB" class="headerlink" title="什么是GDB"></a>什么是GDB</h1><p>GDB是由GUN软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境</p>
<p>一般来说，GDB主要帮助你完成下面四个方面的功能：</p>
<p>1、启动程序，可以按照自定义的要求随心所欲的运行程序</p>
<p>2、可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式）</p>
<p>3、当程序被停住时，可以检查此时程序中所发生的事</p>
<p>4、可以改变程序，将一个BUG产生的影响修正从而测试其他的BUG</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>通常在为调试而编译时，我们会关掉编译器的优化选项（-o），并打开调试选项（-g）。另外，-Wall在尽量不影响程序的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -g -Wall program.c -o program</span><br></pre></td></tr></table></figure>

<p>-g选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。 </p>
<h1 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h1><img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb1.png" alt data-align="center">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test -g</span><br></pre></td></tr></table></figure>

<p>之后运行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure>

<p><img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb2.png" alt data-align="center"><img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb2.png" alt data-align="center"></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>启动和退出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<ul>
<li>给程序设置参数&#x2F;获取设置参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set args 10 20</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show args</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb3.png" alt data-align="center">

<ul>
<li>GDB使用帮助</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">help</span><br></pre></td></tr></table></figure>

<ul>
<li><p>查看当前文件代码</p>
<p>从默认位置显示</p>
<p>从指定的行显示</p>
<p>从指定函数显示</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list/l</span><br><span class="line">list/l 行号</span><br><span class="line">list/l 函数名</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb4.png" alt data-align="center">

<ul>
<li>查看非当前文件代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list/l 文件名：行号</span><br><span class="line">list/l 文件名：函数名</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb5.png" alt data-align="center">

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb6.png" alt data-align="center">

<ul>
<li>设置显示的行数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show list/listsize</span><br><span class="line">set list/listsize 行数</span><br></pre></td></tr></table></figure>

<ul>
<li>设置断点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b/break 行号</span><br><span class="line">b/break 函数名</span><br><span class="line">b/break 文件名：行号</span><br><span class="line">b/break 文件名：函数</span><br></pre></td></tr></table></figure>

<ul>
<li>查看断点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">info/i break/b</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb7.png" alt data-align="center">

<ul>
<li>删除断点</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d/del/delte 断点编号</span><br></pre></td></tr></table></figure>

<ul>
<li>设置断点无效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dis/disable 断点编号</span><br></pre></td></tr></table></figure>

<ul>
<li>设置断点生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ena/enable 断点编号</span><br></pre></td></tr></table></figure>

<ul>
<li>设置断点条件（一般用在循环的位置）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b/break 10 if i==5</span><br></pre></td></tr></table></figure>

<h1 id="GDB命令-调试命令"><a href="#GDB命令-调试命令" class="headerlink" title="GDB命令-调试命令"></a>GDB命令-调试命令</h1><ul>
<li>运行GDB程序</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start(程序停在第一行)</span><br><span class="line">run(遇到断点才停)</span><br></pre></td></tr></table></figure>

<ul>
<li>继续运行，到下一个断点停</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">c/continue</span><br></pre></td></tr></table></figure>

<ul>
<li>向下执行一行代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n/next</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb8.png" alt data-align="center">

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb9.png" alt data-align="center">

<ul>
<li>变量操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">p/print 变量名(打印变量值)</span><br><span class="line">ptype 变量名(打印变量类型) </span><br></pre></td></tr></table></figure>

<ul>
<li>向下单步调试（遇到函数进入函数体）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s/step</span><br><span class="line">finish(跳出函数体)</span><br></pre></td></tr></table></figure>

<ul>
<li>自动变量操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">display num(自动打印指定变量的值)</span><br><span class="line">i/info display</span><br><span class="line">undisplay 编号</span><br></pre></td></tr></table></figure>

<ul>
<li>其他操作</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set var 变量名 = 变量值</span><br><span class="line">until (跳出循环)</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb11.png" alt data-align="center">

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb12.png" alt data-align="center">

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb13.png" alt data-align="center">

<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb14.png" alt data-align="center">

<ul>
<li>next和step的区别</li>
</ul>
<p>next是一步步往下运行代码，不会进入函数体中中</p>
<p><img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb15.png" alt data-align="center"><img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb15.png" alt data-align="center"></p>
<p><img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb16.png" alt data-align="center"><img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb16.png" alt data-align="center"></p>
<ul>
<li>自动设置变量例子</li>
</ul>
<img title src="/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/gdb17.png" alt data-align="center">
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习 Linux系统编程 库</title>
    <url>/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/</url>
    <content><![CDATA[<h1 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h1><ul>
<li><p>库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量。</p>
</li>
<li><p>库是一种特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。</p>
</li>
<li><p>库文件有两种：静态库和动态库（共享库），区别是：静态库在程序的连接阶段被复制到了程序中；动态库在连接阶段没有被复制到程序，而是程序在运行时由系统动态加载到内存中供程序调用</p>
</li>
<li><p>库的好处：1、代码保密     2、方便部署和分发</p>
</li>
<li><p>命名规则</p>
<ul>
<li><p>Linux:<code>libXXX.a</code></p>
<ul>
<li><p>lib:前缀（固定）</p>
</li>
<li><p>XXX：库的名字，自己起</p>
</li>
<li><p>.a：后缀（固定）</p>
</li>
</ul>
</li>
<li><p>Windows：<code>libXXX.lib</code></p>
</li>
</ul>
</li>
<li><p>静态库的制作</p>
<ul>
<li><p>gcc获得.o文件</p>
</li>
<li><p>将.o文件打包，使用ar工具（archive）</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br></pre></td></tr></table></figure>

<p>r 将文件插入备存文件中</p>
<p>c 建立备存文件</p>
<p>s 索引</p>
<h1 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h1><p>我们现在有如下文件：</p>
<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/tree.png" alt data-align="center">

<p>首先我们将其编译为.o文件，运行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c add.c div.c mult.c sub.c</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/.o.png" alt data-align="center">

<p>输入命令制作静态库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar rcs libcalc.a add.o sub.o mult.o div.o</span><br></pre></td></tr></table></figure>

<p>我们生成静态库文件如下：</p>
<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/lib文件.png" alt data-align="center">

<h1 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h1><p>如图所示，在文件夹里我们有如下文件：</p>
<p><img src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/tree1.png"></p>
<p>我们从头编译静态库文件</p>
<p>我们在.&#x2F;library文件夹下依次运行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd src</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c add.c div.c mult.c sub.c -I ../include/</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar rcs libcalc.a add.o div.o mult.o sub.o</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv libcalc.a ../lib/</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main,c -o app -I ./include/ -L ./lib/ -l calc</span><br></pre></td></tr></table></figure>

<p>执行完上述所有指令后我们运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/tree2.png"></p>
<p>我们运行下列命令，运行app文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./app</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/运行app.png" alt data-align="center">

<h1 id="动态库的制作与使用"><a href="#动态库的制作与使用" class="headerlink" title="动态库的制作与使用"></a>动态库的制作与使用</h1><p>命名规则：</p>
<ul>
<li><p>Linux：libxxx.so</p>
<ul>
<li><p>lib:    前缀（固定）</p>
</li>
<li><p>xxx：库的名字，自己起</p>
</li>
<li><p>.so：后缀（固定）</p>
</li>
<li><p>在Linux下是一个可执行文件</p>
</li>
</ul>
</li>
<li><p>Windows：libxxx.dll</p>
</li>
</ul>
<p>动态库的制作：</p>
<ul>
<li>gcc得到.o文件，得到和位置无关的代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC a.c b.c</span><br></pre></td></tr></table></figure>

<ul>
<li>gcc得到动态库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared a.o b.o -o libcalc.so</span><br></pre></td></tr></table></figure>

<h2 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h2><p>如图所示我们有如下文件，我们按如下命令依次编译，并生成动态库文件，将库文件复制到lib文件夹内。</p>
<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/动态库.png" alt data-align="center">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -fpic add.c div.c mult.c sub.c</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared *.o -o libcalc.so</span><br></pre></td></tr></table></figure>

<p>将libcalc.so文件复制到lib文件夹中，我们有如下文件：</p>
<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/动态库2.png" alt data-align="center">

<h2 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h2><p>我们编译main.c文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main -I include/ -L lib/ -l calc</span><br></pre></td></tr></table></figure>

<p>运行main文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>

<p>报错，报错信息如下：</p>
<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/动态库3.png" alt data-align="center">

<h1 id="库工作原理"><a href="#库工作原理" class="headerlink" title="库工作原理"></a>库工作原理</h1><p>静态库：GCC进行连接时，会把静态库中代码打包到可执行程序中</p>
<p>动态库：GCC进行连接时，动态库的代码不会被打包到可执行程序中</p>
<p>程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系</p>
<p>当系统加载可执行代码时，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的DT_RPATH段-&gt;环境变量LD _LIBARAY_PATH-&gt;&#x2F;etc&#x2F;ld.so.cache文件列表-&gt;&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。</p>
<h1 id="动态库加载失败的原因和解决方法"><a href="#动态库加载失败的原因和解决方法" class="headerlink" title="动态库加载失败的原因和解决方法"></a>动态库加载失败的原因和解决方法</h1><p>我们运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd main</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/lddmain.png" alt data-align="center">

<p>发现我们自己写的libcalc.so动态库找不到</p>
<p>添加环境变量，输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib</span><br></pre></td></tr></table></figure>

<p>我们再运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd main</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/动态库4.png" alt data-align="center">

<p>我们手动设置了动态库的路径，但是这只是临时的，关闭之后再次打开就会失效</p>
<p>我们进入到&#x2F;home目录下运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim .bashrc</span><br></pre></td></tr></table></figure>

<p>修改.bashrc文件，在最后一行插入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib</span><br></pre></td></tr></table></figure>

<p>保存之后退出，运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>

<p>只要手动设置了动态库的路径，就可以运行.&#x2F;main</p>
<img title src="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/动态库6.png" alt data-align="center">

<p>还可以通过修改&#x2F;etc&#x2F;ld.so.cache文件，将动态库文件放入&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib&#x2F;</p>
<h1 id="静态库和动态库的对比"><a href="#静态库和动态库的对比" class="headerlink" title="静态库和动态库的对比"></a>静态库和动态库的对比</h1><h2 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>静态库被打包到应用程序中，加载速度快</p>
</li>
<li><p>发布程序无须提供静态库，移植方便</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>浪费系统资源，浪费内存</p>
</li>
<li><p>更新、部署、发布麻烦</p>
</li>
</ul>
<h2 id="动态库的优缺点"><a href="#动态库的优缺点" class="headerlink" title="动态库的优缺点"></a>动态库的优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>可以实现进程间资源共享（共享库）</p>
</li>
<li><p>更新、部署、发布简单</p>
</li>
<li><p>可以控制何时加载动态库</p>
</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>加载速度比静态库慢</p>
</li>
<li><p>发布程序时需要依赖的动态库</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习 Linux系统编程 开发环境搭建</title>
    <url>/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="安装相关工具"><a href="#安装相关工具" class="headerlink" title="安装相关工具"></a>安装相关工具</h1><ul>
<li><p><a href="https://www.vmware.com/cn/products/workstation-pro.html">Windows 虚拟机 | Workstation Pro | VMware | CN</a></p>
</li>
<li><p><a href="https://code.visualstudio.com/docs/?dv=win">Visual Studio Code</a></p>
</li>
<li><p><a href="https://www.xshell.com/zh/free-for-home-school/">Xshell和Xftp</a></p>
</li>
<li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">清华大学Ubuntu镜像</a></p>
</li>
</ul>
<h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><p>首先打开ubuntu，安装ssh服务端，输入指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<p>之后打开Xshell</p>
<img title src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Xshell新建.png" alt data-align="center">

<p>点击新建，如下图:</p>
<img title src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Xshell配置.png" alt data-align="center">

<p>在名称处填写连接的名称，在主机处填写Ubuntu的ip地址打开Ubuntu，输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ifconfig.png" alt data-align="center">

<p>得到ip地址为192.168.194.129</p>
<p>之后我们使用Xshell连接，此时会让我们填写用户名和密码，我们填写Ubuntu的用户名和它的密码即可</p>
<p>然后我们打开VScode，安装拓展</p>
<img title src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/VScoderemote.png" alt data-align="center">

<img title src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/VScodeconfig.png" alt data-align="center">

<p>之后会发现vscode多出一个远程资源管理器，我们点击远程资源管理器，然后打开SSH，配置文件，C:\Users\zc\ssh\config</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read more about SSH config files: https://linux.die.net/man/5/ssh_config</span></span><br><span class="line">Host Ubuntu-plucky       填写主机名，随便起</span><br><span class="line">    HostName <span class="number">192.168</span>.<span class="number">194.129</span>   Ubuntu的IP地址</span><br><span class="line">    <span class="keyword">User</span> <span class="title">plucky</span>    Ubuntu的用户名</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/vscode连接.png" alt data-align="center">

<p>之后就可以连接主机和打开文件夹</p>
<p><img src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/vscode%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E5%A4%B9.png"></p>
<h1 id="配置SSH公私钥免密登录"><a href="#配置SSH公私钥免密登录" class="headerlink" title="配置SSH公私钥免密登录"></a>配置SSH公私钥免密登录</h1><p>首先在windows主机输入命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa</span><br></pre></td></tr></table></figure>

<p>随后所有设置都按回车</p>
<p>我们可以看到用户目录下</p>
<img title src="/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/windows.ssh.png" alt data-align="center">

<p>id_rsa为私钥，id_rsa.pub为公钥</p>
<p>之后我们打开Ubuntu，输入命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>

<p>随后所有设置都按回车</p>
<p>之后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./ssh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure>

<p>将windows中的id_rsa.pub复制进authorized_keys中。</p>
<p>之后就可以实现无密登录了</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 学习 Linux系统编程 文件IO</title>
    <url>/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<h1 id="标准C库IO函数和Linux系统IO函数对比"><a href="#标准C库IO函数和Linux系统IO函数对比" class="headerlink" title="标准C库IO函数和Linux系统IO函数对比"></a>标准C库IO函数和Linux系统IO函数对比</h1><h2 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h2><img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/标准C库IO函数.png" alt data-align="center">

<p>标准C库IO函数是跨平台的，第三方库</p>
<p>标准C库函数和Linux系统函数是调用和被调用的关系</p>
<p>Linux函数更加低级更底层一些，效率更高</p>
<p>C函数更高级一些</p>
<h2 id="标准C库IO函数和Linux系统IO的关系"><a href="#标准C库IO函数和Linux系统IO的关系" class="headerlink" title="标准C库IO函数和Linux系统IO的关系"></a>标准C库IO函数和Linux系统IO的关系</h2><img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/标准C库IO和Linux系统IO之间的关系.png" alt data-align="center">

<h1 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h1><img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/虚拟地址空间.png" alt data-align="center">

<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/文件描述符.png" alt data-align="center">

<h1 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h1><p>命令man可以查看详细信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man 2 (Linux系统IO函数)</span><br><span class="line">man 3 (C标准库函数)</span><br></pre></td></tr></table></figure>

<p>具体命令如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//1、第一个open函数：打开一个已经存在的文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags)</span>;<span class="comment">//不是函数重载，是通过可变参数实现这种效果</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//-pathname：要打开的文件路径</span></span><br><span class="line"><span class="comment">//- flags：对文件操作权限设置还有其他设置(O_RDONLY,O_WRONLY,O_RDWR这三个设置是互斥的)</span></span><br><span class="line"><span class="comment">//返回值：返回一个新的文件描述符，如果调用失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* s)</span>;</span><br><span class="line"><span class="comment">//参数s：用户描述，比如hello，最终输出的内容是 hello：xxx</span></span><br><span class="line"><span class="comment">// 作用：打印erroro对应的错误描述</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、第二个open函数：创建一个新的文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭</span></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/open函数.png" alt data-align="center">

<h2 id="open创建新文件"><a href="#open创建新文件" class="headerlink" title="open创建新文件"></a>open创建新文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- pathname：要创建文件的路径</span></span><br><span class="line"><span class="comment">//- flags：对文件的操作权限和其他的设置</span></span><br><span class="line"><span class="comment">//        必选项： O_RDONLY,O_WRONLY,O_RDWR这三个之间是互斥的</span></span><br><span class="line"><span class="comment">//        可选项：O_CREAT 文件不存在创建新文件</span></span><br><span class="line"><span class="comment">//- mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775</span></span><br><span class="line"><span class="comment">//        最终的权限是：mode &amp; ~umask（umask的作用是抹去某些权限）</span></span><br><span class="line"><span class="comment">// flags参数是一个int类型的数据，占四个字节，32位</span></span><br><span class="line"><span class="comment">// flags 32位，每一位就是一个标志位</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行这段代码之后，我们的文件夹中会创建一个create.txt文件</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/createtxt.png" alt data-align="center">

<h1 id="read、write函数"><a href="#read、write函数" class="headerlink" title="read、write函数"></a>read、write函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//-fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span></span><br><span class="line"><span class="comment">//- buf：需要读取数据存放的地方，数组的地址（传出参数）</span></span><br><span class="line"><span class="comment">//- count：指定的数组的大小</span></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//- 成功：</span></span><br><span class="line"><span class="comment">//    - 大于0：返回实际读取到的字节数</span></span><br><span class="line"><span class="comment">//    - 等于0：文件已经读取完了</span></span><br><span class="line"><span class="comment">//- 失败：-1，并且设置errno</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">size_t</span> count)</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- fd：文件描述符，open得到的，通过这个文件描述符操作某个文件</span></span><br><span class="line"><span class="comment">//- buf：要往磁盘</span></span><br><span class="line"><span class="comment">//- count：要写入的数据的实际的大小</span></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//- 成功：实际写入的字节数</span></span><br><span class="line"><span class="comment">//- 失败：返回-1，并写入errno</span></span><br></pre></td></tr></table></figure>

<h2 id="例子，copyfile-c函数"><a href="#例子，copyfile-c函数" class="headerlink" title="例子，copyfile.c函数"></a>例子，copyfile.c函数</h2><p>我们运行如下函数，将english.txt复制一份</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.通过open打开english.txt文件</span></span><br><span class="line">    <span class="type">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (srcfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建一个新的文件（拷贝文件）</span></span><br><span class="line">    <span class="type">int</span> destfd = open(<span class="string">&quot;cpy.txt&quot;</span>, O_WRONLY | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (destfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.频繁的读写操作</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = read(srcfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(destfd, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">     len = read(srcfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//4.关闭文件</span></span><br><span class="line">     close(destfd);</span><br><span class="line">     close(srcfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标准C库函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE* stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">//Linux系统函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">//- offset：偏移量</span></span><br><span class="line"><span class="comment">//- whence：</span></span><br><span class="line"><span class="comment">//  SEEK_SET:设置文件指针的偏移量</span></span><br><span class="line"><span class="comment">//  SEEK_CUR:设置偏移量，从当前位置加上当前参数offset的值</span></span><br><span class="line"><span class="comment">//  SEEK_END:设置偏移量，文件的大小加第二个参数offset的值</span></span><br><span class="line"><span class="comment">//返回值：返回文件指针所在的位置</span></span><br><span class="line"><span class="comment">//作用：</span></span><br><span class="line"><span class="comment">//1、移动文件指针到文件头   lseek(fd,0,SEEK_SET);</span></span><br><span class="line"><span class="comment">//2、获取当前文件指针的位置   lseek(fd,0,SEEK_CUR);</span></span><br><span class="line"><span class="comment">//3、获取文件长度   lseek(fd,0,SEEK_END);</span></span><br><span class="line"><span class="comment">//4、拓展文件长度，当前文件10b，拓展到110b   lseek(fd,100,SEEK_END); 需要写一次数据</span></span><br></pre></td></tr></table></figure>

<h2 id="例子：拓展hello-txt的文件长度"><a href="#例子：拓展hello-txt的文件长度" class="headerlink" title="例子：拓展hello.txt的文件长度"></a>例子：拓展hello.txt的文件长度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扩展文件的长度</span></span><br><span class="line">    <span class="type">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//写入空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/lseek.png" alt data-align="center">

<h1 id="stat、lstat函数"><a href="#stat、lstat函数" class="headerlink" title="stat、lstat函数"></a>stat、lstat函数</h1><h2 id="stat结构体"><a href="#stat结构体" class="headerlink" title="stat结构体"></a>stat结构体</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span>&#123;</span></span><br><span class="line">    <span class="type">dev_t</span> st_dev;<span class="comment">//文件的设备编号</span></span><br><span class="line">    <span class="type">ino_t</span> st_ino;<span class="comment">//节点</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode;<span class="comment">//文件的类型和存取的权限</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink;<span class="comment">//连接该文件的硬链接数目</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid;<span class="comment">//用户ID</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid;<span class="comment">//组ID</span></span><br><span class="line">    <span class="type">dev_t</span> st_rev;<span class="comment">//设备文件的设备编号</span></span><br><span class="line">    <span class="type">off_t</span> st_size;<span class="comment">//文件字节数，文件大小</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;<span class="comment">//块大小</span></span><br><span class="line">    <span class="type">blkcnt_t</span> t_blocks;<span class="comment">//块数</span></span><br><span class="line">    <span class="type">time_t</span> st_atime;<span class="comment">//最后一次访问时间</span></span><br><span class="line">    <span class="type">time_t</span> st_mtime;<span class="comment">//最后一次修改时间</span></span><br><span class="line">    <span class="type">time_t</span> st_ctime;<span class="comment">//最后一次改变事件，属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/stat.png" alt data-align="center">

<h2 id="st-mode"><a href="#st-mode" class="headerlink" title="st_mode"></a>st_mode</h2><p><img src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/statmode.png"></p>
<h2 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="keyword">struct</span> stat* statbuf)</span>;</span><br><span class="line"><span class="comment">//作用：获取一个文件相关的信息</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- pathname：操作文件的路径</span></span><br><span class="line"><span class="comment">//- statbuf：结构体变量，传出参数，用于保存获取到的文件信息</span></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//- 成功：返回0</span></span><br><span class="line"><span class="comment">//- 失败：返回-1，设置errno</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="keyword">struct</span> stat* statbuf)</span>;<span class="comment">//获取软连接信息</span></span><br></pre></td></tr></table></figure>

<h2 id="例子：获取文件a-txt的长度"><a href="#例子：获取文件a-txt的长度" class="headerlink" title="例子：获取文件a.txt的长度"></a>例子：获取文件a.txt的长度</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = stat(<span class="string">&quot;a.txt&quot;</span>, &amp;statbuf);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %ld\n&quot;</span>, statbuf.st_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/statsize.png" alt data-align="center">

<h1 id="模拟实现ls-l命令"><a href="#模拟实现ls-l命令" class="headerlink" title="模拟实现ls-l命令"></a>模拟实现ls-l命令</h1><p><code>ls -l</code>会列出当前文件的信息</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/ls-l.png" alt data-align="center">

<p>我们实现一个ls-l.c模拟实现<code>ls -l</code>命令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过stat函数获取用户传入的文件的信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">stat</span>(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取文件类型和文件权限</span></span><br><span class="line">    <span class="type">char</span> perms[<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//用于保存文件类型和文件权限的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.st_mode&amp;__S_IFMT)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __S_IFLNK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFDIR:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFREG:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFBLK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFCHR:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFSOCK:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __S_IFIFO:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所在组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//硬链接数</span></span><br><span class="line">    <span class="type">int</span> LinkNum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所有者</span></span><br><span class="line">    <span class="type">char</span>* fileuser = <span class="built_in">getpwuid</span>(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件所在组</span></span><br><span class="line">    <span class="type">char</span>* filegrp = <span class="built_in">getgrgid</span>(st.st_gid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件大小</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> filesize = st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取修改的时间</span></span><br><span class="line">    <span class="type">char</span>* time = <span class="built_in">ctime</span>(&amp;st.st_mtime);</span><br><span class="line">    <span class="type">char</span> mtime[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime, time, <span class="built_in">strlen</span>(time) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, LinkNum, fileuser, filegrp, filesize, mtime, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;Num, fileuser, filegrp, filesize, time, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/ls.png" alt data-align="center">

<h1 id="文件属性操作函数"><a href="#文件属性操作函数" class="headerlink" title="文件属性操作函数"></a>文件属性操作函数</h1><h2 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//作用：判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- pathname：判断文件路径</span></span><br><span class="line"><span class="comment">//- mode：R_OK是否有读权限，W_OK是否有写权限，X_OK是否有执行权限，F_OK判断文件是否存在</span></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<h3 id="例子：判断文件权限"><a href="#例子：判断文件权限" class="headerlink" title="例子：判断文件权限"></a>例子：判断文件权限</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;a.txt&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/access.png" alt data-align="center">

<h2 id="chmod函数"><a href="#chmod函数" class="headerlink" title="chmod函数"></a>chmod函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chmod</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//修改文件的权限</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- pathname：需要修改的文件的路径</span></span><br><span class="line"><span class="comment">//- mode：需要修改的权限值，八进制数</span></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<h3 id="例子：修改文件权限"><a href="#例子：修改文件权限" class="headerlink" title="例子：修改文件权限"></a>例子：修改文件权限</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">chmod</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0775</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="chown函数"><a href="#chown函数" class="headerlink" title="chown函数"></a>chown函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="truncate函数"><a href="#truncate函数" class="headerlink" title="truncate函数"></a>truncate函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">off_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">//作用：缩减或扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- path：需要修改的文件路径</span></span><br><span class="line"><span class="comment">//- length：需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1</span></span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">truncate</span>(<span class="string">&quot;a.txt&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/atxt.png" alt data-align="center">

<h1 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h1><h2 id="mkdir函数"><a href="#mkdir函数" class="headerlink" title="mkdir函数"></a>mkdir函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//作用：创建一个目录</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- pathname：创建的目录的路径</span></span><br><span class="line"><span class="comment">//- mode：权限，八进制的数</span></span><br><span class="line"><span class="comment">//返回值：失败返回-1，成功返回0</span></span><br></pre></td></tr></table></figure>

<p>例子：创建一个名为aaa的目录</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">mkdir</span>(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rmdir函数"><a href="#rmdir函数" class="headerlink" title="rmdir函数"></a>rmdir函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rmdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="rename函数"><a href="#rename函数" class="headerlink" title="rename函数"></a>rename函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* oldpath,<span class="type">const</span> <span class="type">char</span>* newpath)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例子：修改目录aaa为bbb</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">rename</span>(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;rename&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="chdir函数，getcwd函数"><a href="#chdir函数，getcwd函数" class="headerlink" title="chdir函数，getcwd函数"></a>chdir函数，getcwd函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br><span class="line"><span class="comment">//作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- path：需要修改的工作目录</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- buf：存储的路径，指向的是一个数组</span></span><br><span class="line"><span class="comment">//- size：数组的大小</span></span><br><span class="line"><span class="comment">//返回值：返回指向的一块内存，这个数据就是第一个参数</span></span><br></pre></td></tr></table></figure>

<p>例子：修改当前工作目录</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">getcwd</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line">    <span class="comment">//修改工作目录</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">chdir</span>(<span class="string">&quot;/home/plucky/Linux/lecture14/bbb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个新的文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的工作目录</span></span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">getcwd</span>(buf1, <span class="built_in">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/list.png" alt data-align="center">

<h1 id="目录遍历函数"><a href="#目录遍历函数" class="headerlink" title="目录遍历函数"></a>目录遍历函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR* <span class="title">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span></span>;</span><br><span class="line"><span class="comment">//功能：打开一个目录</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- name：需要打开的目录的名称</span></span><br><span class="line"><span class="comment">//返回值：DIR* 类型，理解为目录流，错误返回NULL</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">dirent</span>* <span class="built_in">readdir</span>(DIR* dirp);</span><br><span class="line"><span class="comment">//功能：读取目录中的数据</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- dirp：opendir返回的结果</span></span><br><span class="line"><span class="comment">//返回值：struct dirent*，代表读取到的文件的信息。读取到了文件末尾或者失败了返回NULL</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">closedir</span><span class="params">(DIR* dirp)</span></span>;</span><br><span class="line"><span class="comment">//功能：关闭目录</span></span><br></pre></td></tr></table></figure>

<p>例子：计算文件夹中普通文件的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFileNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br><span class="line"><span class="comment">//读取某个目录下所有普通文件的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">getFileNum</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普通文件的个数为：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于读取目录下所有普通文件的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFileNum</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、打开目录</span></span><br><span class="line">    DIR* dir = <span class="built_in">opendir</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录普通文件的个数</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dirent</span>* ptr;</span><br><span class="line">    <span class="keyword">while</span> ((ptr = <span class="built_in">readdir</span>(dir)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取名称</span></span><br><span class="line">        <span class="type">char</span>* dname = ptr-&gt;d_name;</span><br><span class="line">        <span class="comment">//忽略掉. 和..</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dname, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是普通文件还是目录</span></span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;d_type == DT_DIR)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//目录，需要继续读取这个目录</span></span><br><span class="line">            <span class="type">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s/%s&quot;</span>, path, dname);</span><br><span class="line">            total += <span class="built_in">getFileNum</span>(newpath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ptr-&gt;d_type == DT_REG)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭目录</span></span><br><span class="line">    <span class="built_in">closedir</span>(dir);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/readfilenum.png" alt data-align="center">

<h1 id="dup、dup2函数"><a href="#dup、dup2函数" class="headerlink" title="dup、dup2函数"></a>dup、dup2函数</h1><h2 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="comment">//作用：复制一个新的文件描述符</span></span><br><span class="line"><span class="comment">//fd=3，int fd1=dup（fd），两个文件描述符指向同一个文件</span></span><br><span class="line"><span class="comment">//从空闲的文件描述符中找一个最小的，作为新的拷贝的文件描述符</span></span><br></pre></td></tr></table></figure>

<p>例子：创建文件a.txt并且用dup复制的文件描述符修改a.txt</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">dup</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">write</span>(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span></span>;</span><br><span class="line"><span class="comment">//作用：重定向文件描述符</span></span><br><span class="line"><span class="comment">//oldfd指向a.txt,newfd指向b.txt</span></span><br><span class="line"><span class="comment">//调用函数成功后：newfd和b.txt做close，newfd指向了a.txt</span></span><br><span class="line"><span class="comment">//oldfd必须是一个有效的文件描述符</span></span><br><span class="line"><span class="comment">//oldfd和newfd值相同相当于什么都没有做</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d,fd1: fd1: %d\n&quot;</span>, fd, fd1);</span><br><span class="line">    <span class="type">int</span> fd2 = <span class="built_in">dup2</span>(fd, fd1);</span><br><span class="line">    <span class="keyword">if</span> (fd2 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;Hello,dup2&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">write</span>(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d,fd1: %d,fd2: %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/*argv*/</span>)</span></span>;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- fd：表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment">//- cmd：表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">//  F_DUPFD复制文件描述符，复制的是第一个参数fd，得到一个新的文件描述符</span></span><br><span class="line"><span class="comment">//      int ret = fcntl(fd,F_DUPFD);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  F_GETFL获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">//      获取的flag和我们通过open函数传递的flag是一个东西</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  F_SETFL：设置文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">//      必选项：O_RDONLY,O_WRONLY,O_RDWR不可以被修改</span></span><br><span class="line"><span class="comment">//      可选项：O_APPEND,NONBLOCK</span></span><br><span class="line"><span class="comment">//      O_APPEND表示追加数据</span></span><br><span class="line"><span class="comment">//      NONBLOCK设置成非阻塞</span></span><br><span class="line"><span class="comment">//      阻塞和非阻塞：描述的是函数调用的行为。</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改或者获取文件状态flag</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取文件描述符的状态flag</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    flag |= O_APPEND;</span><br><span class="line">    <span class="comment">//修改文件描述符状态的flag，给flag加入O_APPEND标记</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">fcntl</span>(fd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习 QT简介</title>
    <url>/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="QT的下载和安装"><a href="#QT的下载和安装" class="headerlink" title="QT的下载和安装"></a>QT的下载和安装</h1><p><a href="https://download.qt.io/">Index of &#x2F; (qt.io)</a></p>
<p><a href="https://mirrors.tuna.tsinghua.edu.cn/qt/">Index of &#x2F;qt&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p>下载在线安装包之后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\qt-unified-windows-x64-4.5.2-online.exe --mirror https://mirror.nju.edu.cn/qt</span><br></pre></td></tr></table></figure>

<p>运行这道命令将源换成国内的镜像之后进行安装</p>
<h1 id="Qt创建项目以及main和pro文件的生成"><a href="#Qt创建项目以及main和pro文件的生成" class="headerlink" title="Qt创建项目以及main和pro文件的生成"></a>Qt创建项目以及main和pro文件的生成</h1><h2 id="Qt创建项目"><a href="#Qt创建项目" class="headerlink" title="Qt创建项目"></a>Qt创建项目</h2><ul>
<li><p>创建项目</p>
<p><img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"></p>
</li>
<li><p>创建步骤</p>
<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT1.png" title alt data-align="center">

<p>这里我们选择qmake为例子学习，不然没有pro文件，CMake是一个txt文件</p>
<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT2.png" title alt data-align="center">

<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT3.png" title alt data-align="center">

<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QtBaseclass.png" title alt data-align="center">

<p>我们以QWidget为例</p>
<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT4.png" title alt data-align="center">

<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT5.png" title alt data-align="center">

<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT6.png" title alt data-align="center">

<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT7.png" title alt data-align="center">

<img src="/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/QT8.png" title alt data-align="center">

<p>此时QT项目已经创建完成</p>
</li>
</ul>
<h2 id="main文件和pro文件解析"><a href="#main文件和pro文件解析" class="headerlink" title="main文件和pro文件解析"></a>main文件和pro文件解析</h2><p><strong>main文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mywidget.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span><span class="comment">//应用程序类</span></span></span><br><span class="line"><span class="comment">//程序入口 argv 命令行变量数量 命令行变量数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a 应用程序对象，在Qt中应用程序对象有且仅有一个</span></span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//通过窗口类实例化对象 w</span></span><br><span class="line">    MyWidget w;</span><br><span class="line">    <span class="comment">//窗口是不会默认弹出的，需要调用show方法进行显示</span></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//a.exec();进入消息循环机制 阻塞功能</span></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pro文件</strong></p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="symbol">QT</span>       += core gui     //<span class="symbol">Qt</span>包含的模块</span><br><span class="line"></span><br><span class="line">greaterThan(<span class="symbol">QT_MAJOR_VERSION</span>, <span class="number">4</span>): <span class="symbol">QT</span> += widgets       //大于<span class="number">4</span>版本 加入widget模块</span><br><span class="line"></span><br><span class="line"><span class="symbol">CONFIG</span> += c++<span class="number">17</span></span><br><span class="line"></span><br><span class="line"># <span class="symbol">You</span> can make your code fail to compile if it uses deprecated <span class="symbol">APIs</span>.</span><br><span class="line"># <span class="symbol">In</span> order to do so, uncomment the following line.</span><br><span class="line">#<span class="symbol">DEFINES</span> += <span class="symbol">QT_DISABLE_DEPRECATED_BEFORE</span>=<span class="number">0x060000</span>    # disables all the <span class="symbol">APIs</span> deprecated before <span class="symbol">Qt</span> <span class="number">6.0</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">SOURCES</span> += \</span><br><span class="line">    main.cpp \</span><br><span class="line">    mywidget.cpp    //源文件</span><br><span class="line"></span><br><span class="line"><span class="symbol">HEADERS</span> += \</span><br><span class="line">    mywidget.h    //头文件</span><br><span class="line"></span><br><span class="line"># <span class="symbol">Default</span> rules for deployment.</span><br><span class="line">qnx: target.path = /tmp/$$&#123;<span class="symbol">TARGET</span>&#125;/bin</span><br><span class="line">else: unix:!android: target.path = /opt/$$&#123;<span class="symbol">TARGET</span>&#125;/bin</span><br><span class="line">!isEmpty(target.path): <span class="symbol">INSTALLS</span> += target</span><br></pre></td></tr></table></figure>

<h2 id="Qt6包含模块"><a href="#Qt6包含模块" class="headerlink" title="Qt6包含模块"></a>Qt6包含模块</h2><table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Qt Core</td>
<td align="center">下面其他模块使用的核心基础类（Qt Core是非图形模块）</td>
</tr>
<tr>
<td align="center">Qt D-Bus</td>
<td align="center">用于通过 D-Bus 协议进行进程间通信的类</td>
</tr>
<tr>
<td align="center">Qt GUI</td>
<td align="center">图形用户界面 （GUI） 组件的基类</td>
</tr>
<tr>
<td align="center">Qt Network</td>
<td align="center">使网络编程更轻松、更易移植的类</td>
</tr>
<tr>
<td align="center">Qt QML</td>
<td align="center">QML 和 JavaScript 语言的类</td>
</tr>
<tr>
<td align="center">Qt Quick</td>
<td align="center">一个声明性框架，用于构建具有自定义用户界面的高度动态的应用程序。</td>
</tr>
<tr>
<td align="center">Qt Quick Controls</td>
<td align="center">提供轻量级 QML 类，用于为桌面、嵌入式和移动设备创建高性能用户界面。这些类型采用简单的样式体系结构，并且非常高效。</td>
</tr>
<tr>
<td align="center">Qt Quick Dialogs</td>
<td align="center">用于从 Qt 快速应用程序创建系统对话框并与之交互的类。</td>
</tr>
<tr>
<td align="center">Qt Quick Layouts</td>
<td align="center">布局是用于在用户界面中排列基于 Qt Quick 2 的项目的项。</td>
</tr>
<tr>
<td align="center">Qt Quick Test</td>
<td align="center">QML 应用程序的单元测试框架，其中测试用例编写为 JavaScript 函数。Note: 二进制兼容性保证不适用于Qt快速测试。但是，它将保持源兼容。</td>
</tr>
<tr>
<td align="center">Qt Test</td>
<td align="center">用于单元测试 Qt 应用程序和库的类。Note: 二进制兼容性保证不适用于 Qt 测试。但是，它将保持源兼容。</td>
</tr>
<tr>
<td align="center">Qt Widgets</td>
<td align="center">使用C++ widget扩展Qt GUI的类。</td>
</tr>
</tbody></table>
<h2 id="命名规范和快捷键"><a href="#命名规范和快捷键" class="headerlink" title="命名规范和快捷键"></a>命名规范和快捷键</h2>]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>QT</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 Linux系统编程 进程使用</title>
    <url>/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：</p>
<ul>
<li><p>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）</p>
</li>
<li><p>机器语言指令：对程序算法进行编码。</p>
</li>
<li><p>程序入口地址：标识程序开始执行时的起始指令位置。</p>
</li>
<li><p>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</p>
</li>
<li><p>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试<br>和运行时的符号解析（动态链接）。</p>
</li>
<li><p>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以<br>及加载共享库的动态连接器的路径名。</p>
</li>
<li><p>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程</p>
</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的<br>一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是<br>基本的分配单元，也是基本的执行单元。</p>
<h3 id="程序和进程的关系"><a href="#程序和进程的关系" class="headerlink" title="程序和进程的关系"></a>程序和进程的关系</h3><p>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用<br>以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数<br>据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结<br>构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标<br>识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进<br>程资源使用及限制、当前工作目录和大量的其他信息</p>
<h2 id="单道、多道程序设计"><a href="#单道、多道程序设计" class="headerlink" title="单道、多道程序设计"></a>单道、多道程序设计</h2><ul>
<li><p>单道程序，即在计算机内存中只允许一个的程序运行。</p>
</li>
<li><p>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程<br>序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之<br>间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了<br>提高 CPU 的利用率。</p>
</li>
<li><p>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽<br>然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</p>
</li>
<li><p>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒<br>可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p>
</li>
</ul>
<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><ul>
<li><p>时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”<br>是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计<br>算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在<br>只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，<br>由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。</p>
</li>
<li><p>时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等<br>的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的<br>状态时，内核会重新为每个进程计算并分配时间片，如此往复</p>
</li>
</ul>
<h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><ul>
<li><p>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。</p>
</li>
<li><p>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的<br>轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，<br>只是把时间分成若干段，使多个进程快速交替的执行</p>
</li>
</ul>
<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><ul>
<li><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分<br>配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，<br>Linux 内核的进程控制块是 task_struct 结构体。</p>
</li>
<li><p>在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查<br>看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下<br>部分即可：</p>
<ul>
<li><p>进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</p>
</li>
<li><p>进程的状态：有就绪、运行、挂起、停止等状态</p>
</li>
<li><p>进程切换时需要保存和恢复的一些CPU寄存器</p>
</li>
<li><p>描述虚拟地址空间的信息</p>
</li>
<li><p>描述控制终端的信息当前工作目录（Current Working Directory）</p>
</li>
<li><p>umask 掩码</p>
</li>
<li><p>文件描述符表，包含很多指向 file 结构体的指针</p>
</li>
<li><p>和信号相关的信息</p>
</li>
<li><p>用户 id 和组 id</p>
</li>
<li><p>会话（Session）和进程组</p>
</li>
<li><p>进程可以使用的资源上限（Resource Limit）<br>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>

<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/ulimit.png" alt data-align="center"></li>
</ul>
</li>
</ul>
<h1 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h1><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p>进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。<br>在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型<br>中，进程分为新建态、就绪态，运行态，阻塞态，终止态。</p>
<ul>
<li><p>运行态：进程占有处理器正在运行</p>
</li>
<li><p>就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列</p>
</li>
<li><p>阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成</p>
</li>
</ul>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/进程三状态.png" alt data-align="center">

<ul>
<li><p>新建态：进程刚被创建时的状态，尚未进入就绪队列</p>
</li>
<li><p>终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程</p>
</li>
</ul>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/进程无状态.png" alt data-align="center">

<h2 id="进程相关命令"><a href="#进程相关命令" class="headerlink" title="进程相关命令"></a>进程相关命令</h2><ul>
<li><p>查看进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps ajx</span><br></pre></td></tr></table></figure>

<p>a：显示终端上的所有进程，包括其他用户的进程</p>
<p>u：显示进程的详细信息</p>
<p>x：显示没有控制终端的进程</p>
<p>j：列出与作业相关的控制进程</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/psaux.png" alt data-align="center">

<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/psajx.png" alt data-align="center">

<p>还有其他的命令我们可以运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man ps</span><br></pre></td></tr></table></figure>
</li>
<li><p>STAT参数的意义</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">D</td>
<td align="center">不可中断 Uninterruptible（usually IO）</td>
</tr>
<tr>
<td align="center">R</td>
<td align="center">正在运行，或在队列中的进程</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">处于休眠状态</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">停止或被追踪</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">僵尸进程</td>
</tr>
<tr>
<td align="center">W</td>
<td align="center">进入内存交换（从内核2.6开始无效）</td>
</tr>
<tr>
<td align="center">X</td>
<td align="center">死掉的进程</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">高优先级</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">低优先级</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">包含子进程</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">位于前台的进程组</td>
</tr>
</tbody></table>
</li>
<li><p>实时显示进程动态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<p>可以在使用top命令时加上 -d来指定显示信息更新的时间间隔，在<code>top</code>命令执行后，可以按以下按键对显示结果进行排序</p>
<ul>
<li><p>M 根据内存使用量排序</p>
</li>
<li><p>P 根据CPU占有率排序</p>
</li>
<li><p>T 根据进程运行时间长短排序</p>
</li>
<li><p>U 根据用户名来筛选进程</p>
</li>
<li><p>K 输入指定的PID杀死进程</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/top.png" alt data-align="center"></li>
</ul>
</li>
<li><p>杀死进程</p>
<ul>
<li><p>klil [-signal] pid</p>
</li>
<li><p>kill -l 列出所有信号</p>
</li>
<li><p>kill -SIGKILL 进程ID</p>
</li>
<li><p>kill -9 进程ID</p>
</li>
<li><p>killall name 根据进程名杀死进程</p>
</li>
</ul>
</li>
<li><p>进程号和相关函数</p>
<ul>
<li><p>每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。</p>
</li>
<li><p>任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。</p>
</li>
<li><p>进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。</p>
</li>
<li><p>进程号和进程相关函数</p>
<ul>
<li><p><code>pid_t getpid(void);</code></p>
</li>
<li><p><code>pid_t getppid(void);</code></p>
</li>
<li><p><code>pid_t getpgid(pid_t pid);</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h2><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//成功：子进程中返回0，父进程中返回子进程ID</span></span><br><span class="line"><span class="comment">//失败：返回-1</span></span><br><span class="line"><span class="comment">//失败的两个主要原因</span></span><br><span class="line"><span class="comment">//1、当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN</span></span><br><span class="line"><span class="comment">//2、系统内存不足，这是errno的值被设置为ENOMEM</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">//判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pid: %d\n&quot;</span>, pid);</span><br><span class="line">        <span class="comment">//如果大于0，返回的是创建的子进程的进程号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent process,pid: %d, ppid: %d\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process,pid: %d, ppid: %d\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i: %d  pid: %d\n&quot;</span>, i,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/fork.png" alt data-align="center">

<p>第一个pid：107838是子进程的ID，父进程ID为107837，父进程的父进程的ID：107575</p>
<p>父进程和子进程是交替运行的</p>
<p>父子进程之间的关系：</p>
<p>区别：</p>
<ul>
<li><p>fork()函数的返回值不同</p>
<ul>
<li><p>父进程中：&gt;0 返回子进程的ID</p>
</li>
<li><p>子进程中 &#x3D; 0</p>
</li>
</ul>
</li>
<li><p>PCB中的一些数据有区别</p>
<ul>
<li><p>当前进程的id，pid</p>
</li>
<li><p>当前进程的父进程id，ppid</p>
</li>
<li><p>信号集</p>
</li>
</ul>
</li>
</ul>
<p>共同点：</p>
<ul>
<li><p>某些状态下：子进程刚创建出来，还没有执行任何的写数据的操作</p>
<ul>
<li><p>用户区的数据</p>
</li>
<li><p>文件描述符表</p>
</li>
</ul>
</li>
</ul>
<p>父子进程对变量是不是共享的？</p>
<ul>
<li><p>刚开始的时候是一样的，是共享的，如果修改了数据就不共享了</p>
</li>
<li><p>读时共享（子进程被创建，两个进程没有做任何写的操作），写时拷贝</p>
</li>
</ul>
<h2 id="父子进程虚拟地址空间情况"><a href="#父子进程虚拟地址空间情况" class="headerlink" title="父子进程虚拟地址空间情况"></a>父子进程虚拟地址空间情况</h2><p>实际上，更准确来说，Linux的fork()使用是通过写时拷贝（copy - on - write）实现的。</p>
<p>写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</p>
<p>内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。</p>
<p>也就是说，资源的复制是在需要写入的时候才会运行，在此之前，只有以只读方式共享。</p>
<p>注意：fork之后父子进程共享文件。fork产生的子进程与父进程相同的文件，文件描述符指向相同的文件表，引用计数增加，共享文偏移指针。</p>
<h2 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h2><p>使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通<br>过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。</p>
<ul>
<li><p>设置调试父进程或者子进程：<code>set follow-fork-mode [parent（默认）| child]</code></p>
</li>
<li><p>设置调试模式：<code>set detach-on-fork [on | off]</code><br>默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进<br>程的时候，其它进程被 GDB 挂起。</p>
</li>
<li><p>查看调试的进程：<code>info inferiors</code></p>
</li>
<li><p>切换当前调试的进程：<code>inferior id</code></p>
</li>
<li><p>使进程脱离 GDB 调试：<code>detach inferiors id</code></p>
</li>
</ul>
<p>我们对如下程序进行GDB多进程调试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fork() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是父进程: pid = %d, ppid = %d\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>, i);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;我是子进程: pid = %d, ppid = %d\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;j = %d\n&quot;</span>, j);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述程序进行调试：GDB默认调试的是父进程</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/gdb默认.png" alt data-align="center">

<p>我们可以通过指令,修改默认跟踪的进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child</span><br></pre></td></tr></table></figure>

<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/更改追踪进程.png" alt data-align="center">

<p>修改之后我们默认调试的是子进程</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/gdb子进程.png" alt data-align="center">

<p>使用命令，更改调试模式off将子进程挂起</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> detach-on-fork off</span><br></pre></td></tr></table></figure>

<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/更改调试模式.png" alt data-align="center">

<p>我们重新调试程序</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/newgdb.png" alt data-align="center">

<p>通过运行命令查看当前调试的进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">info inferiors</span><br></pre></td></tr></table></figure>

<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/infoinferiors.png" alt data-align="center">

<p>我们运行命令切换到子进程继续调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inferior 2</span><br></pre></td></tr></table></figure>

<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/切换子进程调试.png" alt data-align="center">

<p>我们再次切换到父进程调试，并且将父进程运行结束</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/父进程运行结束.png" alt data-align="center">

<p>此时我们查看进程</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/父进程结束之后.png" alt data-align="center">

<p>我们切换到子进程继续调试并且运行结束</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/子进程运行结束.png" alt data-align="center">

<p>我们运行命令，使父进程脱离调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">detach inferiors 1</span><br></pre></td></tr></table></figure>

<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/detach父进程.png" alt data-align="center">

<h1 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h1><h2 id="exec函数族介绍"><a href="#exec函数族介绍" class="headerlink" title="exec函数族介绍"></a>exec函数族介绍</h2><ul>
<li><p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。</p>
</li>
<li><p>exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/*, (char *) NULL, char * </span></span></span><br><span class="line"><span class="comment"><span class="params">const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">//前六个是标准C库函数，最后一个是Linux系统函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<h2 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...<span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- path：需要制定执行的文件的路径或者名称</span></span><br><span class="line"><span class="comment">//- arg：是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">//      第一个参数一般没有什么作用，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">//      从第二个参数开始往后，就是程序执行所需要的参数列表</span></span><br><span class="line"><span class="comment">//      参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//只有当调用失败才会有返回值，并且返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">//如果调用成功，没有返回值</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个子进程，在子进程中执行exec函数族中的程序</span></span><br><span class="line">    <span class="type">__pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process,pid : %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process,pid : %d\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d,pid = %d\n&quot;</span>, i, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello文件是一段输出hello world的代码</p>
<p>代码运行结果如下：</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/execl.png" alt data-align="center">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个子进程，在子进程中执行exec函数族中的程序</span></span><br><span class="line">    <span class="type">__pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process,pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process,pid : %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d,pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会将子进程替代为运行Linux系统程序ps</p>
<h2 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ... <span class="comment">/* (char *) NULL */</span>)</span>;</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//- 会到环境变量中寻找可执行文件，如果找到则执行，如果找不到则执行失败</span></span><br><span class="line"><span class="comment">//- file：需要可执行文件的文件名</span></span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个子进程，在子进程中执行exec函数族中的程序</span></span><br><span class="line">    <span class="type">__pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process,pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process,pid : %d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d,pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与execl不同，execlp不用写入绝对路径就可以执行ps命令</p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><h3 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h3><img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/进程退出.png" alt data-align="center">

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="comment">//status是进程退出时的一个状态信息。父进程回收子进程资源时可以获取到</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用<code>_exit(0)</code>则只会打印hello不会打印world</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><ul>
<li><p>父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。</p>
</li>
<li><p>每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。</p>
</li>
<li><p>因此孤儿进程并不会有什么危害</p>
</li>
</ul>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><ul>
<li><p>每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。</p>
</li>
<li><p>进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。</p>
</li>
<li><p>僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免</p>
</li>
</ul>
<h2 id="进程回收"><a href="#进程回收" class="headerlink" title="进程回收"></a>进程回收</h2><ul>
<li><p>在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。</p>
</li>
<li><p>父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。</p>
</li>
<li><p>wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。</p>
</li>
<li><p>注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。</p>
</li>
</ul>
<h3 id="wait-函数"><a href="#wait-函数" class="headerlink" title="wait()函数"></a>wait()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>* wstatus)</span>;</span><br><span class="line"><span class="comment">//功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//进程退出时的状态信息，传入的是一个int类型的地址，传出参数</span></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//- 成功：返回被回收的子进程的ID</span></span><br><span class="line"><span class="comment">//- 失败：返回-1(所有子进程都结束</span></span><br><span class="line"><span class="comment">//调用wait函数的进程会被挂起(阻塞)，直到它的一个子进程退出或者收到一个不能忽略的信号（继续被执行)</span></span><br><span class="line"><span class="comment">//如果没有子进程，函数会立刻返回-1；如果子进程都已经结束了，也会立即返回-1，并且会回收子进程的资源</span></span><br></pre></td></tr></table></figure>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>wait.c程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//有一个父进程创建五个子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="comment">//创建五个子进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent,pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child,pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编译运行这段程序</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/wait.png" alt data-align="center">

<p>运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>

<p>我们发现wait程序生成的五个子进程变为了僵尸进程</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/wait僵尸进程.png" alt data-align="center">

<p>我们重新写一段wait.c程序，通过kill将子程序杀死</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// int ret = wait(NULL);</span></span><br><span class="line">            <span class="type">int</span> st;</span><br><span class="line">            <span class="type">int</span> ret = wait(&amp;st);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exit(0)</span></span><br><span class="line">&#125;<span class="string">&quot;, getpid());</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p> 使用kill命令杀死子进程</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/kill子进程.png" alt data-align="center">

<p>kill之后的运行结果为：</p>
<img title src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/kill之后运行结果.png" alt data-align="center">

<h3 id="退出信息相关宏函数"><a href="#退出信息相关宏函数" class="headerlink" title="退出信息相关宏函数"></a>退出信息相关宏函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WIFEXITED(status) <span class="comment">//非0，进程正常退出</span></span><br><span class="line">WEXITSTATUS(status) <span class="comment">//如果上宏为真，获取进程退出的状态（exit的参数）</span></span><br><span class="line">WIFSIGNALED(status) <span class="comment">//非0，进程异常终止</span></span><br><span class="line">WTERMSIG(status) <span class="comment">//如果上宏为真，获取使进程终止的信号编号</span></span><br><span class="line">WIFSTOPPED(status) <span class="comment">//非0，进程处于暂停状态</span></span><br><span class="line">WSTOPSIG(status) <span class="comment">//如果上宏为真，获取使进程暂停的信号的编号</span></span><br><span class="line">WIFCONTINUED(status) <span class="comment">//非0，进程暂停后已经继续运行</span></span><br></pre></td></tr></table></figure>

<h3 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid()函数"></a>waitpid()函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">//功能：回收指定进程号的进程，可设置是否阻塞</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- pid</span></span><br><span class="line"><span class="comment">//      pid&gt;0：某个子进程的pid</span></span><br><span class="line"><span class="comment">//      pid=0：回收当前进程组的所有子进程</span></span><br><span class="line"><span class="comment">//      pid=-1：表示回收所有的子进程，相当于wait()  最常用</span></span><br><span class="line"><span class="comment">//      pid&lt;-1：某个进程组的组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">//- options：设置阻塞或者非阻塞，0表示阻塞，WNOHANG表示非阻塞</span></span><br><span class="line"><span class="comment">//- 返回值</span></span><br><span class="line"><span class="comment">//      &gt;0：返回子进程ID</span></span><br><span class="line"><span class="comment">//      =0：options=WNOHANG，表示还有子进程</span></span><br><span class="line"><span class="comment">//      =-1：错误，或者没有子进程</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 Linux系统编程 线程</title>
    <url>/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li><p>与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）</p>
</li>
<li><p>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</p>
</li>
<li><p>线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。</p>
</li>
<li><p>查看指定进程的 LWP （线程）号：<code>ps –Lf pid</code></p>
</li>
</ul>
<h2 id="进程和线程区别"><a href="#进程和线程区别" class="headerlink" title="进程和线程区别"></a>进程和线程区别</h2><ul>
<li><p>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。</p>
</li>
<li><p>调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。</p>
</li>
<li><p>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</p>
</li>
<li><p>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表</p>
</li>
</ul>
<h2 id="线程之间共享和非共享资源"><a href="#线程之间共享和非共享资源" class="headerlink" title="线程之间共享和非共享资源"></a>线程之间共享和非共享资源</h2><ul>
<li><p>共享资源</p>
<ul>
<li><p>进程 ID 和父进程 ID</p>
</li>
<li><p>进程组 ID 和会话 ID</p>
</li>
<li><p>用户 ID 和 用户组 ID</p>
</li>
<li><p>文件描述符表</p>
</li>
<li><p>信号处置</p>
</li>
<li><p>文件系统的相关信息：文件权限掩码（umask）、当前工作目录</p>
</li>
<li><p>虚拟地址空间（除栈、.text）</p>
</li>
</ul>
</li>
<li><p>非共享资源</p>
<ul>
<li><p>线程 ID</p>
</li>
<li><p>信号掩码</p>
</li>
<li><p>线程特有数据</p>
</li>
<li><p>error 变量</p>
</li>
<li><p>实时调度策略和优先级</p>
</li>
<li><p>栈，本地变量和函数的调用链接信息</p>
</li>
</ul>
</li>
</ul>
<h2 id="NPTL"><a href="#NPTL" class="headerlink" title="NPTL"></a>NPTL</h2><ul>
<li><p>当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。</p>
</li>
<li><p>要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。</p>
</li>
<li><p>NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。</p>
</li>
<li><p>查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION</p>
<img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/NPTL.png" title alt data-align="center"></li>
</ul>
<h1 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h1><h2 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般情况下, main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span></span><br><span class="line"><span class="comment">// 称之为子线程。</span></span><br><span class="line"><span class="comment">// 程序中默认只有一个进程，fork()函数调用，2进行</span></span><br><span class="line"><span class="comment">// 程序中默认只有一个线程，pthread_create()函数调用，2个线程。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">void</span>* (*start_routine) (<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -功能：创建一个子线程</span></span><br><span class="line"><span class="comment">// - 参数：</span></span><br><span class="line"><span class="comment">// - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span></span><br><span class="line"><span class="comment">// - attr : 设置线程的属性，一般使用默认值，NULL</span></span><br><span class="line"><span class="comment">// - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">// - arg : 给第三个参数使用，传参</span></span><br><span class="line"><span class="comment">// - 返回值：</span></span><br><span class="line"><span class="comment">// 成功：0</span></span><br><span class="line"><span class="comment">// 失败：返回错误号。这个错误号和之前errno不太一样。</span></span><br><span class="line"><span class="comment">// 获取错误号的信息：  char* strerror(int errnum);</span></span><br></pre></td></tr></table></figure>

<p>pthread_create不是标准库定义的调用，所以在编译时需要连接第三方的库 -pthread</p>
<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread . . .\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value = %d\n&quot;</span>, *(<span class="type">int</span>*)arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="type">void</span>*)&amp;num);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果为：</p>
<img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_creat.png" title alt data-align="center">

<h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;</span><br><span class="line"><span class="comment">// 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span></span><br><span class="line"><span class="comment">// 参数：</span></span><br><span class="line"><span class="comment">// retval : 需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 功能：获取当前的线程的线程ID</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span></span>;</span><br><span class="line"><span class="comment">// 功能：比较两个线程ID是否相等</span></span><br><span class="line"><span class="comment">// 不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的</span></span><br><span class="line"><span class="comment">// 是使用结构体去实现的。</span></span><br><span class="line"><span class="comment">//一般跨平台等等必须要使用</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">50</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, <span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="comment">//让主线程退出,当主线程退出时，不会影响其他</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="连接已终止的进程"><a href="#连接已终止的进程" class="headerlink" title="连接已终止的进程"></a>连接已终止的进程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br><span class="line">        <span class="comment">// - 功能：和一个已经终止的线程进行连接</span></span><br><span class="line">        <span class="comment">//         回收子线程的资源</span></span><br><span class="line">        <span class="comment">//         这个函数是阻塞函数，调用一次只能回收一个子线程</span></span><br><span class="line">        <span class="comment">//         一般在主线程中使用</span></span><br><span class="line">        <span class="comment">// - 参数：</span></span><br><span class="line">        <span class="comment">//     - thread：需要回收的子线程的ID</span></span><br><span class="line">        <span class="comment">//     - retval: 接收子线程退出时的返回值</span></span><br><span class="line">        <span class="comment">// - 返回值：</span></span><br><span class="line">        <span class="comment">//     0 : 成功</span></span><br><span class="line">        <span class="comment">//     非0 : 失败，返回的错误号</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">pthread_exit</span>((<span class="type">void</span>*)&amp;value);<span class="comment">//return (void *)&amp;value;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//主线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程调用pthread_join()回收子线程的资源</span></span><br><span class="line">    <span class="type">int</span>* thread_retval;</span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(tid, (<span class="type">void</span>**)&amp;thread_retval);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data : %d\n&quot;</span>, *thread_retval);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程资源成功\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让主线程退出,当主线程退出时，不会影响其他</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/回收子线程资源.png" title alt data-align="center">

<h2 id="线程的分离"><a href="#线程的分离" class="headerlink" title="线程的分离"></a>线程的分离</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line">        <span class="comment">// - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span></span><br><span class="line">        <span class="comment">//   1.不能多次分离，会产生不可预料的行为。</span></span><br><span class="line">        <span class="comment">//   2.不能去连接一个已经分离的线程，会报错。</span></span><br><span class="line">        <span class="comment">// - 参数：需要分离的线程的ID</span></span><br><span class="line">        <span class="comment">// - 返回值：</span></span><br><span class="line">        <span class="comment">//     成功：0</span></span><br><span class="line">        <span class="comment">//     失败：返回错误号</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出主线程和子线程的ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = <span class="built_in">pthread_detach</span>(tid);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error2 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置分离以后，对分离的子线程进行连接 pthread_join()</span></span><br><span class="line">    ret = <span class="built_in">pthread_join</span>(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error3 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_detach.png" title alt data-align="center">

<h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br><span class="line">        <span class="comment">// - 功能：取消线程（让线程终止）</span></span><br><span class="line">        <span class="comment">//     取消某个线程，可以终止某个线程的运行，</span></span><br><span class="line">        <span class="comment">//     但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</span></span><br><span class="line">        <span class="comment">//     取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消线程</span></span><br><span class="line">    <span class="built_in">pthread_cancel</span>(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出主线程和子线程的ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<p><img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_cancel.png"></p>
<h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line">        <span class="comment">//- 初始化线程属性变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line">        <span class="comment">//- 释放线程属性的资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span></span>;</span><br><span class="line">        <span class="comment">//- 获取线程分离的状态属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line">        <span class="comment">//- 设置线程分离的状态属性    </span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, <span class="built_in">pthread_self</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程属性变量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">//初始化属性变量</span></span><br><span class="line">    <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置属性</span></span><br><span class="line">    <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="comment">//创建一个子线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span>* errstr = <span class="built_in">strerror</span>(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出主线程和子线程的ID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程的栈的大小</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="built_in">pthread_attr_getstacksize</span>(&amp;attr, &amp;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread stack size : %ld\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放线程属性资源</span></span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/pthread_attr.png" title alt data-align="center">

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul>
<li><p>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价<br>的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程<br>修改的变量。</p>
</li>
<li><p>临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是<br>同时访问同一共享资源的其他线程不应终端该片段的执行。</p>
</li>
<li><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进<br>行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处<br>于等待状态。</p>
</li>
</ul>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><ul>
<li><p>为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion<br>的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。</p>
</li>
<li><p>互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一<br>个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。</p>
</li>
<li><p>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议：</p>
<ul>
<li><p>针对共享资源锁定互斥量</p>
</li>
<li><p>访问共享资源</p>
</li>
<li><p>对互斥量解锁</p>
</li>
</ul>
</li>
<li><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示：<img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/互斥量.png" title alt data-align="center"></p>
</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用多线程实现卖票案例</span></span><br><span class="line"><span class="comment">//有3个窗口，一共是100张票</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tickets = <span class="number">100</span>;<span class="comment">//全局变量，所有线程都共享这一份资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个互斥量</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">sellticket</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖票</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, <span class="built_in">pthread_self</span>(), tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化互斥量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//创建三个子线程</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收子线程的资源,阻塞的函数</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid1);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid2);</span><br><span class="line">    <span class="built_in">pthread_detach</span>(tid3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);<span class="comment">//退出主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放互斥量资源</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互<br>斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。</p>
</li>
<li><p>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，<br>若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</p>
</li>
<li><p>死锁的几种场景：</p>
<ul>
<li><p>忘记释放锁</p>
</li>
<li><p>重复加锁</p>
</li>
<li><p>多线程多锁，抢占锁资源</p>
</li>
</ul>
</li>
</ul>
<img src="/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/死锁.png" title alt data-align="center">

<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><ul>
<li><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。</p>
</li>
<li><p>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。</p>
</li>
<li><p>读写锁的特点：</p>
<ul>
<li><p>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</p>
</li>
<li><p>如果有其它线程写数据，则其它线程都不允许读、写操作。</p>
</li>
<li><p>写是独占的，写的优先级高</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读写锁的类型 pthread_rwlock_t</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rstrict rwlock, <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *restrict attr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//案例：8个线程操作同一个全局变量</span></span><br><span class="line"><span class="comment">//3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个共享数据</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">writeNum</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++write, tid : %ld, num : %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), num);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">readNum</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===read,tid : %ld, num : %d\n&quot;</span>, <span class="built_in">pthread_self</span>(), num);</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> wtids[<span class="number">3</span>], rtids[<span class="number">5</span>];<span class="comment">//创建3个写线程，5个读线程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;wtids[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;rtids[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程分离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(wtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(rtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者消费者模型(简单版)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* newNode = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = <span class="built_in">rand</span>() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node , num : %d , tid : %ld\n&quot;</span>, newNode-&gt;num, <span class="built_in">pthread_self</span>());</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">customer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头节点的指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;delete node , num : %d , tid : %ld\n&quot;</span>, tmp-&gt;num, <span class="built_in">pthread_self</span>());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没有数据</span></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建5个生产者线程和5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ctids[i], <span class="literal">NULL</span>, custmer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ptids[i]);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码没有处理好一个问题，当有消费者想要消费但是缓冲区已经没有数据的时候，消费者会直接退出，当缓冲区有数据的时候却不会再通知这个消费者，我们需要通过一定手段解决这个问题</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件变量的类型 pthread_cond_t</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">const</span> <span class="type">pthread_condattr_t</span> *restrict attr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex)</span></span>;</span><br><span class="line">        <span class="comment">// - 等待，调用了该函数，线程会阻塞。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *restrict cond, <span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *restrict abstime)</span></span>;</span><br><span class="line">        <span class="comment">// - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">        <span class="comment">// - 唤醒一个或者多个等待的线程</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line">        <span class="comment">// - 唤醒所有的等待的线程</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者消费者模型(简单版)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建条件变量</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* newNode = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = <span class="built_in">rand</span>() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node , num : %d , tid : %ld\n&quot;</span>, newNode-&gt;num, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要生产了一个就通知消费者消费</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">customer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头节点的指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node , num : %d , tid : %ld\n&quot;</span>, tmp-&gt;num, <span class="built_in">pthread_self</span>()); </span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">            <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//没有数据 需要等待</span></span><br><span class="line">            <span class="comment">//当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞时，继续向下执行，会重新加锁。</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">NULL</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建5个生产者线程和5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ptids[i]);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用条件变量解决上述生产者和消费者的问题。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号量的类型 sem_t</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span>;</span><br><span class="line">    <span class="comment">// - 初始化信号量</span></span><br><span class="line">    <span class="comment">// - 参数：</span></span><br><span class="line">    <span class="comment">//     - sem : 信号量变量的地址</span></span><br><span class="line">    <span class="comment">//     - pshared : 0 用在线程间 ，非0 用在进程间</span></span><br><span class="line">    <span class="comment">//     - value : 信号量中的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">    <span class="comment">// - 释放资源</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">    <span class="comment">// - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span></span>;</span><br><span class="line">    <span class="comment">// - 对信号量解锁，调用一次对信号量的值+1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_t psem;</span></span><br><span class="line"><span class="comment">// sem_t csem;</span></span><br><span class="line"><span class="comment">// init(psem, 0, 8);</span></span><br><span class="line"><span class="comment">// init(csem, 0, 0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// producer() &#123;</span></span><br><span class="line"><span class="comment">//     sem_wait(&amp;psem);</span></span><br><span class="line"><span class="comment">//     sem_post(&amp;csem)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customer() &#123;</span></span><br><span class="line"><span class="comment">//     sem_wait(&amp;csem);</span></span><br><span class="line"><span class="comment">//     sem_post(&amp;psem)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产者消费者模型(简单版)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">//创建两个信号量</span></span><br><span class="line"><span class="type">sem_t</span> psem;</span><br><span class="line"><span class="type">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头结点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>* head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;psem);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* newNode = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = <span class="built_in">rand</span>() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node , num : %d , tid : %ld\n&quot;</span>, newNode-&gt;num, <span class="built_in">pthread_self</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;csem);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">customer</span><span class="params">(<span class="type">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;csem);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="comment">//保存头节点的指针</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span>* tmp = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 有数据</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node , num : %d , tid : %ld\n&quot;</span>, tmp-&gt;num, <span class="built_in">pthread_self</span>());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;psem);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建5个生产者线程和5个消费者线程</span></span><br><span class="line">    <span class="type">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ptids[i]);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量同样解决了上述生产者和消费者的问题</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 函数高级</title>
    <url>/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h1><p>在C++中，函数形参列表中的形参是可以有默认值的</p>
<p>语法：<code>返回值类型 函数名 （参数 = 默认值）</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>, <span class="type">int</span> c = <span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">30</span>) &lt;&lt; endl;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>60</p>
<p>70</p>
</blockquote>
<p>注意事项</p>
<ul>
<li>如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值</li>
</ul>
<img src="/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/Error1.png" title alt data-align="center">

<ul>
<li>声明和实现只能有一个有默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p><img src="/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/Error2.png"></p>
<h1 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h1><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用参数时必须填补该位置</p>
<p> 语法：<code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><h2 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h2><p>作用：函数名可以相同，提高复用性</p>
<p>函数重载满足条件：</p>
<ul>
<li><p>同一个作用域下</p>
</li>
<li><p>函数名称相同</p>
</li>
<li><p>函数参数类型不同或者个数不同或者顺序不同</p>
</li>
</ul>
<p>注意：函数的返回值不可以作为函数重载的条件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a,double b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(double a,int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">3.1</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">3.1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>func()<br>func(int a)<br>func(int a,int b)<br>func(int a,double b)<br>func(double a,int b)</p>
</blockquote>
<h2 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h2><ul>
<li>引用作为函数重载条件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int &amp;a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(const int &amp;a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(a);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>func(int &amp;a)<br>func(const int &amp;a)</p>
</blockquote>
<ul>
<li>函数重载碰到默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a, int b = 10)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/Error3.png" title alt data-align="center">
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 友元</title>
    <url>/2023/04/29/C++-%E5%AD%A6%E4%B9%A0-%E5%8F%8B%E5%85%83/</url>
    <content><![CDATA[<p>生活中你的家有客厅（public），有你的卧室（private）</p>
<p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p>
<p>但是呢，你也可以允许你的好闺蜜基友进去</p>
<p>在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p>
<p>友元的目的就是让一个函数或者类访问另一个类中的私有成员</p>
<p>友元的关键字为<code>friend</code></p>
<p>友元的三种实现</p>
<ul>
<li><p>全局函数做友元</p>
</li>
<li><p>类做友元</p>
</li>
<li><p>成员函数做友元</p>
</li>
</ul>
<h1 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//建筑物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//goodGuy全局函数是Building的好朋友，可以访问Building中私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGuy</span><span class="params">(Building* building)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGuy</span><span class="params">(Building *building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友的全局函数 正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友的全局函数 正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Building building;</span><br><span class="line">    <span class="built_in">goodGuy</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>好基友的全局函数 正在访问：客厅<br>好基友的全局函数 正在访问：卧室</p>
</blockquote>
<h1 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//建筑物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGuy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGuy</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//参观函数 访问Building中的属性</span></span><br><span class="line"></span><br><span class="line">    Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//GoodGuy类是本类的好朋友，可以访问本类中的私有成员</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGuy</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外写成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGuy::<span class="built_in">GoodGuy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建建筑物对象</span></span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGuy::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;好基友类正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GoodGuy gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>好基友类正在访问：客厅<br>好基友类正在访问：卧室</p>
</blockquote>
<h1 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGuy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GoodGuy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//让visit函数可以访问Building中的私有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">//让visit2函数不可以访问Building中私有成员</span></span><br><span class="line">    Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//告诉编译器 GoodGuy类下的visit成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGuy::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_SittingRoom;<span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line">    m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">    m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGuy::<span class="built_in">GoodGuy</span>()</span><br><span class="line">&#123;</span><br><span class="line">    building = <span class="keyword">new</span> Building;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGuy::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGuy::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;visit2函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;访问不了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    GoodGuy gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">    gg.<span class="built_in">visit2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>visit函数正在访问：客厅<br>visit函数正在访问：卧室<br>visit2函数正在访问：客厅</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 引用</title>
    <url>/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h1><p>作用：给变量起别名</p>
<p>语法：数据类型 &amp;别名 &#x3D; 原名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    b = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>a &#x3D; 10<br>b &#x3D; 10<br>a &#x3D; 100<br>b &#x3D; 100</p>
</blockquote>
<h1 id="引用的注意事项"><a href="#引用的注意事项" class="headerlink" title="引用的注意事项"></a>引用的注意事项</h1><ul>
<li><p>引用必须初始化 </p>
</li>
<li><p>引用在初始化后，不可以改变</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; b = a;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">20</span>;</span><br><span class="line">    b = c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>a &#x3D; 20<br>b &#x3D; 20<br>c &#x3D; 20</p>
</blockquote>
<h1 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h1><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>
<p>优点：可以简化指针修改实参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>swap a &#x3D; 20<br>swap b &#x3D; 10<br>a &#x3D; 20<br>b &#x3D; 10</p>
</blockquote>
<p>引用传递，形参会修饰实参</p>
<p>地址传递，形参会修饰实参</p>
<p>值传递，形参不会修饰实参</p>
<h1 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h1><p>作用：引用是可以作为函数的返回值存在的</p>
<p>注意：不要返回局部变量引用</p>
<p>用法：函数调用作为左值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">test</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test</span>() = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>ref &#x3D; 10<br>ref &#x3D; 1000</p>
</blockquote>
<h1 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h1><p>本质：引用的本质是在C++内部实现一个指针常量</p>
<p><code>int&amp; ref = a;</code>等价于<code>int* const ref = a;</code></p>
<p><code>ref = 20</code>当编译器发现ref是引用，会自动帮我们解引用转换为<code>*ref = 20</code></p>
<h1 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h1><p>作用：常量引用主要用来修饰形参，防止误操作。</p>
<p>在函数形参列表中，可以加const 修饰形参，防止形参改变实参</p>
<p><img src="/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/ERROR.png"></p>
<p><img src="/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/ERROR1.png"></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 多态</title>
    <url>/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h1><p>多态是C++面向对象三大特性之一</p>
<p>多态分为两类：</p>
<ul>
<li><p>静态多态：函数重载和运算符重载属于静态多态，复用函数名</p>
</li>
<li><p>动态多态：派生类和虚函数实现运行时多态</p>
</li>
</ul>
<p>静态多态和动态多态区别</p>
<ul>
<li><p>静态多态的函数地址早绑定-编译阶段确定函数地址</p>
</li>
<li><p>动态多态的函数地址晚绑定-运行阶段确定函数地址</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">//猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行说话的函数</span></span><br><span class="line"><span class="comment">//地址早绑定 在编译阶段确定函数地址 </span></span><br><span class="line"><span class="comment">//如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">doSpeak</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>动物在说话</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态多态满足条件</span></span><br><span class="line"><span class="comment">// 1、具有继承关系</span></span><br><span class="line"><span class="comment">// 2、子类要重写父类的虚函数</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 动态多态的使用</span></span><br><span class="line"><span class="comment">// 父类的指针或引用指向子类的应用</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行说话的函数</span></span><br><span class="line"><span class="comment">//地址早绑定 在编译阶段确定函数地址 </span></span><br><span class="line"><span class="comment">//如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">doSpeak</span>(cat);</span><br><span class="line">    Dog dog;</span><br><span class="line">    <span class="built_in">doSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>小猫在说话<br>小狗在说话</p>
</blockquote>
<p>动态多态满足条件</p>
<ul>
<li><p>具有继承关系</p>
</li>
<li><p>子类要重写父类的虚函数</p>
</li>
</ul>
<p>动态多态的使用</p>
<ul>
<li>父类的指针或引用指向子类对象</li>
</ul>
<h1 id="多态的原理剖析"><a href="#多态的原理剖析" class="headerlink" title="多态的原理剖析"></a>多态的原理剖析</h1><p>我们观察上述代码的Animal类结构,vfptr指向vftable</p>
<img src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/sizeofanimal.png" title alt data-align="center">

<p>我们观察Cat类的结构如下：</p>
<img src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/sizeofcat.png" title alt data-align="center">

<p>当父类指针或者引用指向子类对象的时候发生多态，即</p>
<p><code>Animal&amp; animal = cat</code></p>
<p><code>animal.speak()</code></p>
<p>当传入的对象是cat那么就是从cat的虚函数表里调用虚函数</p>
<h1 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一 计算器类"></a>多态案例一 计算器类</h1><p>案例描述：分别利用普通写法和多态技术，设计两个操作数进行运算的计算器类</p>
<p>多态的优点：</p>
<ul>
<li><p>代码组织结构清晰</p>
</li>
<li><p>可读性强</p>
</li>
<li><p>利于前期和后期的拓展以及维护</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分别利用普通写法和多态写法实现计算器</span></span><br><span class="line"><span class="comment">//普通写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>)<span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&quot;-&quot;</span>)<span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>)<span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;/&quot;</span>)<span class="keyword">return</span> m_Num1 / m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果要拓展新的功能，需要拓展源码</span></span><br><span class="line">    <span class="comment">//在真实的开发中提倡开闭原则</span></span><br><span class="line">    <span class="comment">//对拓展进行开发，对修改进行关闭</span></span><br><span class="line">    <span class="type">int</span> m_Num1;<span class="comment">//操作数1</span></span><br><span class="line">    <span class="type">int</span> m_Num2;<span class="comment">//操作数2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculator c;</span><br><span class="line">    c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">    c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;/&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用多态实现计算器</span></span><br><span class="line"><span class="comment">//实现计算机抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Num1;</span><br><span class="line">    <span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//加法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Num1 / m_Num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//多态使用条件</span></span><br><span class="line">    <span class="comment">//父类指针或者引用指向子类对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加法运算</span></span><br><span class="line">    AbstractCalculator* abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">100</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//用完后记得销毁</span></span><br><span class="line">    <span class="keyword">delete</span> abc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减法运算</span></span><br><span class="line">    abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">100</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乘法运算</span></span><br><span class="line">    abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">100</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除法运算</span></span><br><span class="line">    abc = <span class="keyword">new</span> DivCalculator;</span><br><span class="line">    abc-&gt;m_Num1 = <span class="number">100</span>;</span><br><span class="line">    abc-&gt;m_Num2 = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>10 + 10 &#x3D; 20<br>10 - 10 &#x3D; 0<br>10 * 10 &#x3D; 100<br>10 &#x2F; 10 &#x3D; 1<br>100 + 100 &#x3D; 200<br>100 - 100 &#x3D; 200<br>100 * 100 &#x3D; 10000<br>100 &#x2F; 100 &#x3D; 1</p>
</blockquote>
<h1 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h1><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p>
<p>因此可以将虚函数改为纯虚函数</p>
<p>纯虚函数语法：<code>virtual 返回值类型 函数名 (参数列表) = 0;</code></p>
<p>当类中有了纯虚函数，这个类也成为抽象类</p>
<p>抽象类特点：</p>
<ul>
<li><p>无法实例化对象</p>
</li>
<li><p>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚函数和抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//只要有一个纯虚函数，这个类称为抽象类</span></span><br><span class="line">    <span class="comment">//抽象类特点：</span></span><br><span class="line">    <span class="comment">//无法实例化对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/无法实例化对象.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚函数和抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//只要有一个纯虚函数，这个类称为抽象类</span></span><br><span class="line">    <span class="comment">//抽象类特点：</span></span><br><span class="line">    <span class="comment">//1、无法实例化对象</span></span><br><span class="line">    <span class="comment">//2、抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/抽象子类.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚函数和抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="comment">//只要有一个纯虚函数，这个类称为抽象类</span></span><br><span class="line">    <span class="comment">//抽象类特点：</span></span><br><span class="line">    <span class="comment">//1、无法实例化对象</span></span><br><span class="line">    <span class="comment">//2、抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;func函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;<span class="comment">//子类必须重写父类中的纯虚函数，否则不能实例化对象</span></span><br><span class="line">    Base* base = <span class="keyword">new</span> Son;</span><br><span class="line">    base-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>func函数调用</p>
</blockquote>
<h1 id="多态案例二-制作饮品"><a href="#多态案例二-制作饮品" class="headerlink" title="多态案例二 制作饮品"></a>多态案例二 制作饮品</h1><p>案例描述：制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料</p>
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多态案例2 制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//煮水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//制作饮品</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">makeDrink</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">Boil</span>();</span><br><span class="line">        <span class="built_in">Brew</span>();</span><br><span class="line">        <span class="built_in">PourInCup</span>();</span><br><span class="line">        <span class="built_in">PutSomething</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> :<span class="keyword">public</span> AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//煮水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮农夫山泉&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入糖和牛奶&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//制作茶</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> :<span class="keyword">public</span> AbstractDrinking</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//煮水</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;煮矿泉水&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//冲泡</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒入杯中</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入辅料</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;加入枸杞&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//制作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(AbstractDrinking* abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    abs-&gt;<span class="built_in">makeDrink</span>();</span><br><span class="line">    <span class="keyword">delete</span> abs;<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//制作咖啡</span></span><br><span class="line">    <span class="built_in">doWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//制作茶叶</span></span><br><span class="line">    <span class="built_in">doWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>煮农夫山泉<br>冲泡咖啡<br>倒入杯中<br>加入糖和牛奶</p>
<hr>
<p>煮矿泉水<br>冲泡茶叶<br>倒入杯中<br>加入枸杞</p>
</blockquote>
<h1 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h1><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li><p>可以解决父类指针释放子类对象</p>
</li>
<li><p>都需要有具体的函数实现</p>
</li>
</ul>
<p>虚析构和纯虚析构区别</p>
<ul>
<li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构语法：</p>
<p><code>virtual ~类名()&#123;&#125;</code></p>
<p>纯虚析构语法：</p>
<p><code>virtual ~类名() = 0</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚析构函数和纯虚析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数 </span></span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Name != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cat的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Animal的构造函数调用<br>Cat的构造函数调用<br>Tom小猫在说话<br>Animal的析构函数调用</p>
</blockquote>
<p>父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏</p>
<p>我们使用虚析构解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚析构函数和纯虚析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数 </span></span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以利用虚析构解决父类指针释放子类对象时不干净的问题</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Name != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cat的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Animal的构造函数调用<br>Cat的构造函数调用<br>Tom小猫在说话<br>Cat的析构函数调用<br>Animal的析构函数调用</p>
</blockquote>
<p>我们使用纯虚析构解决这个问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//虚析构函数和纯虚析构函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//纯虚函数 </span></span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以利用纯虚析构解决父类指针释放子类对象时不干净的问题</span></span><br><span class="line">    <span class="comment">//有了纯虚析构之后，这个类也属于抽象类，无法实例化对象</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Animal的纯虚析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Cat的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Name != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Cat的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">delete</span> m_Name;</span><br><span class="line">            m_Name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Animal的构造函数调用<br>Cat的构造函数调用<br>Tom小猫在说话<br>Cat的析构函数调用<br>Animal的纯虚析构函数调用</p>
</blockquote>
<h1 id="多态案例三-电脑组装"><a href="#多态案例三-电脑组装" class="headerlink" title="多态案例三 电脑组装"></a>多态案例三 电脑组装</h1><p>案例描述：</p>
<ul>
<li><p>电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储）</p>
</li>
<li><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商喝Lenovo厂商</p>
</li>
<li><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p>
</li>
<li><p>测试时组装三台不同的电脑进行工作</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象不同的类</span></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的计算函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象内存类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//抽象的存储函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Computer</span>(CPU* cpu, VideoCard* vc, Memory* mem)</span><br><span class="line">    &#123;</span><br><span class="line">        m_cpu = cpu;</span><br><span class="line">        m_vc = vc;</span><br><span class="line">        m_mem = mem;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供工作的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">        m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line">        m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line">        m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供析构函数 释放三个电脑零件</span></span><br><span class="line">    ~<span class="built_in">Computer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_cpu;</span><br><span class="line">            m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_vc;</span><br><span class="line">            m_vc = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_mem;</span><br><span class="line">            m_mem = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CPU* m_cpu;<span class="comment">//CPU的零件指针</span></span><br><span class="line">    VideoCard* m_vc;<span class="comment">//显卡的零件指针</span></span><br><span class="line">    Memory* m_mem;<span class="comment">//内存的零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//AMD厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMDCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AMD的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMDVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AMD的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AMDMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;AMD的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一台电脑零件</span></span><br><span class="line">    CPU* intelCpu = <span class="keyword">new</span> IntelCPU;    </span><br><span class="line">    VideoCard* intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">    Memory* intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第一台电脑</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Computer* computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu,intelCard,intelMem);</span><br><span class="line">    computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer1;</span><br><span class="line">    <span class="comment">//创建第二台电脑</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Computer* computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> AMDCPU, <span class="keyword">new</span> AMDVideoCard, <span class="keyword">new</span> AMDMemory);</span><br><span class="line">    computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer2;</span><br><span class="line">    <span class="comment">//创建第三台电脑</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Computer* computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> IntelCPU, <span class="keyword">new</span> AMDVideoCard, <span class="keyword">new</span> IntelMemory);</span><br><span class="line">    computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">delete</span> computer3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>第一台电脑开始工作<br>Intel的CPU开始计算了！<br>Intel的显卡开始显示了！<br>Intel的内存条开始存储了！</p>
<hr>
<p>第二台电脑开始工作：<br>AMD的CPU开始计算了！<br>AMD的显卡开始显示了！<br>AMD的内存条开始存储了！</p>
<hr>
<p>第三台电脑开始工作：<br>Intel的CPU开始计算了！<br>AMD的显卡开始显示了！<br>Intel的内存条开始存储了！</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 数据库编程</title>
    <url>/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h1><ul>
<li>Oracle安装连接：<a href="https://www.oracle.com/database/technologies/oracle-database-software-downloads.html">Database Software Downloads | Oracle</a></li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 文件操作</title>
    <url>/2023/05/05/C++-%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p>
<p>通过文件可以将数据持久化</p>
<p>C++中对文件操作需要包含头文件<fstream></fstream></p>
<p>文件类型分类两种：</p>
<ul>
<li><p>文本文件 - 文件以文本的ASCII码形式存储在计算机中</p>
</li>
<li><p>二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们</p>
</li>
</ul>
<p>操作文件的三大类：</p>
<ul>
<li><p>ofstream - 写操作</p>
</li>
<li><p>ifstream - 读操作</p>
</li>
<li><p>fstream - 读写操作</p>
</li>
</ul>
<h1 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h1><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h3 id="写文件步骤"><a href="#写文件步骤" class="headerlink" title="写文件步骤"></a>写文件步骤</h3><ol>
<li><p>包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建流对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream ofs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>,打开方式);</span><br></pre></td></tr></table></figure>
</li>
<li><p>写数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofs&lt;&lt;<span class="string">&quot;写入的数据&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件打开方式"><a href="#文件打开方式" class="headerlink" title="文件打开方式"></a>文件打开方式</h3><table>
<thead>
<tr>
<th align="center">打开方式</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::in</td>
<td align="center">为读文件而打开文件</td>
</tr>
<tr>
<td align="center">ios::out</td>
<td align="center">为写文件打开文件</td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">初始位置：文件尾</td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">追加方式写文件</td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">如果文件存在先删除，再创建</td>
</tr>
<tr>
<td align="center">ios::binary</td>
<td align="center">二进制方式</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：文件打开方式可以配合使用，利用|操作符</p>
<p><strong>例如</strong>：用二进制方式写文件 <code>ios::binary | ios::out</code></p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本文件 写文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、包含头文件fstream</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建流对象</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">//3、指定打开方式</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, ios::out);</span><br><span class="line">    <span class="comment">//4、写内容</span></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>文件操作必须包含头文件fstream</p>
</li>
<li><p>读文件可以利用ofstream，或者fstream类</p>
</li>
<li><p>打开文件时需要指定操作文件的路径，以及打开方式</p>
</li>
<li><p>利用&lt;&lt;可以向文件中写数据</p>
</li>
<li><p>操作完毕，要关闭文件</p>
</li>
</ul>
<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><h3 id="读文件步骤"><a href="#读文件步骤" class="headerlink" title="读文件步骤"></a>读文件步骤</h3><ol>
<li><p>包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建流对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifstream ifs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开文件并判断文件是否打开成功</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>,打开方式);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读数据</p>
<p>四种方式读取</p>
</li>
<li><p>关闭文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifs.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文本文件 读文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、包含头文件fstream</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建流对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//3、打开文件 并且判断是否打开成功</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;text.txt&quot;</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、读数据</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种读数据--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs &gt;&gt; buf)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二种读数据--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> buf1[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (ifs.<span class="built_in">getline</span>(buf1, <span class="built_in">sizeof</span>(buf1)))</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;buf1&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三种读数据--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string buf2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(ifs, buf2))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第四种读数据--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>读文件可以利用ifstream，或者fstream类</p>
</li>
<li><p>利用is_open函数可以判断文件是否打开成功</p>
</li>
<li><p>close关闭文件</p>
</li>
</ul>
<h1 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h1><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为<code>ios::bianary</code></p>
<h2 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h2><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型：<code>ostream&amp; write(const char* buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件 写文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_Name[<span class="number">64</span>];<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> m_Age;<span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建流对象</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    <span class="comment">//3、打开文件</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary);</span><br><span class="line">    <span class="comment">//4、写文件</span></span><br><span class="line">    Person p = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line">    ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文件输出流对象可以通过write函数，以二进制方式写函数</li>
</ul>
<h2 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h2><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char* buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件 读文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> m_Name[<span class="number">64</span>];<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> m_Age;<span class="comment">//年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、创建流对象</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    <span class="comment">//3、打开文件 判断文件是否打开成功</span></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、读文件</span></span><br><span class="line">    Person p;</span><br><span class="line">    ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;p, <span class="built_in">sizeof</span>(Person));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//5、关闭文件</span></span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名： 张三 年龄： 18</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 Linux系统编程 进程通信</title>
    <url>/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="进程间通信简介"><a href="#进程间通信简介" class="headerlink" title="进程间通信简介"></a>进程间通信简介</h1><h2 id="进程间通讯的概念"><a href="#进程间通讯的概念" class="headerlink" title="进程间通讯的概念"></a>进程间通讯的概念</h2><ul>
<li><p>进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。</p>
</li>
<li><p>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。</p>
</li>
<li><p>进程间通信的目的：</p>
<ul>
<li><p>数据传输：一个进程需要将它的数据发送给另一个进程。</p>
</li>
<li><p>通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p>
</li>
<li><p>资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。</p>
</li>
<li><p>进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制<br>进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Linux进程间通信方式"><a href="#Linux进程间通信方式" class="headerlink" title="Linux进程间通信方式"></a>Linux进程间通信方式</h2><img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/Linux进程间通信.png" alt data-align="center">

<h1 id="匿名管道概述"><a href="#匿名管道概述" class="headerlink" title="匿名管道概述"></a>匿名管道概述</h1><ul>
<li><p>管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，<br>所有的 UNIX 系统都支持这种通信机制。</p>
</li>
<li><p>统计一个目录中文件的数目命令：<code>ls | wc –l</code>，为了执行该命令，shell 创建了两<br>个进程来分别执行 <code>ls</code>和<code> wc</code>。</p>
</li>
</ul>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/匿名管道.png" alt data-align="center">

<h2 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点"></a>管道的特点</h2><ul>
<li><p>管道其实是一个在<mark>内核内存中</mark>维护的缓冲器，这个缓冲器的存储能力是有限的，不同的<br>操作系统大小不一定相同。</p>
</li>
<li><p>管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。</p>
</li>
<li><p>一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据<br>的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。</p>
</li>
<li><p>通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺<br>序是完全一样的。</p>
</li>
<li><p>在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。</p>
</li>
<li><p>从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写<br>更多的数据，在管道中无法使用 lseek() 来随机的访问数据。</p>
</li>
<li><p>匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘<br>关系）之间使用。</p>
</li>
</ul>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/匿名管道1.png" alt data-align="center">

<h2 id="为什么可以使用管道进行通信"><a href="#为什么可以使用管道进行通信" class="headerlink" title="为什么可以使用管道进行通信"></a>为什么可以使用管道进行通信</h2><img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/管道通信.png" alt data-align="center">

<h2 id="管道的数据结构"><a href="#管道的数据结构" class="headerlink" title="管道的数据结构"></a>管道的数据结构</h2><img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/管道的数据结构.png" alt data-align="center">

<h2 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">//功能：创建一个匿名管道，用来进程间通信</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//int pipefd[2]这个数组是一个传出参数</span></span><br><span class="line"><span class="comment">//pipefd[0]对应的是管道的读端，pipefd[1]对应的是管道的写端</span></span><br><span class="line"><span class="comment">//返回值： </span></span><br><span class="line"><span class="comment">//成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">//注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span></span><br><span class="line"><span class="comment">//管道是默认阻塞的，如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span></span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am prent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span> * str = <span class="string">&quot;hello,i am parent&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="comment">// bzero(buf, 1024);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/匿名管道运行结果.png" alt data-align="center">

<h2 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h2><ul>
<li><p>创建匿名管道</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看管道缓冲大小命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>

<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/管道缓冲大小.png" alt data-align="center">
</li>
<li><p>查看管道缓冲大小函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">fpathconf</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">    <span class="type">long</span> size = <span class="built_in">fpathconf</span>(pipefd[<span class="number">0</span>], _PC_PIPE_BUF);<span class="comment">//获取管道的大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pipe size : %ld\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行，结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/管道缓冲区大小2.png" alt data-align="center" width="441">
</li>
<li><p>一个案例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现ps aux | grep xxx 父子进程之间通信</span></span><br><span class="line"><span class="comment">    子进程：ps aux，子进程结束以后，将数据发送给父进程</span></span><br><span class="line"><span class="comment">    父进程：获取到数据，过滤</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pipe()</span></span><br><span class="line"><span class="comment">    execlp()</span></span><br><span class="line"><span class="comment">    子进程将标准输出stdout_fileno重定向到管道写端。dup2</span></span><br><span class="line"><span class="comment">    没有实现过滤功能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个管道</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pipe</span>(fd);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//从管道中读取</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">//过滤数据输出</span></span><br><span class="line">        <span class="keyword">while</span> ((len = <span class="built_in">read</span>(fd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="comment">//关闭读端</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        <span class="built_in">dup2</span>(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        <span class="comment">//执行 ps aux</span></span><br><span class="line">        <span class="built_in">execlp</span>(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
</li>
</ul>
<p>运行结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/pci执行.png" alt data-align="center">

<p>因为管道只有4096bytes，所以运行这个程序只会显示4096bytes，如果要显示所有的信息需要循环往管道中写数据</p>
<h2 id="管道的读写特点和管道设置为非阻塞"><a href="#管道的读写特点和管道设置为非阻塞" class="headerlink" title="管道的读写特点和管道设置为非阻塞"></a>管道的读写特点和管道设置为非阻塞</h2><p><strong>管道的读写特点：</strong></p>
<p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞的I&#x2F;O操作）</p>
<ul>
<li><p>所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p>
</li>
<li><p>如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了，才读取数据并返回。</p>
</li>
<li><p>如果所有指向管道读端的文件描述符都关闭（管道的读端引用计数大于0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。</p>
</li>
<li><p>如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道在写满时再次write会阻塞，直到管道中有空位置才能写入数据并返回。</p>
</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li><p>读管道</p>
<p>管道中有数据，read返回实际读到的字节数</p>
<p>管道中无数据：</p>
<ul>
<li><p>写端被全部关闭，read返回0，相当于读到文件的末尾</p>
</li>
<li><p>写端没有完全关闭，read阻塞等待</p>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道读端全部关闭，进程异常终止（进程收到SIGPIPE信号）</p>
</li>
<li><p>管道读端没有全部关闭：</p>
<ul>
<li><p>管道已满：write阻塞</p>
</li>
<li><p>管道未满：write将数据写入，并返回实际写入的字节数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK;            // 修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0], F_SETFL, flags);   // 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flags = <span class="built_in">fcntl</span>(pipefd[<span class="number">0</span>], F_GETFL);  <span class="comment">// 获取原来的flag</span></span><br><span class="line">        flags |= O_NONBLOCK;            <span class="comment">// 修改flag的值</span></span><br><span class="line">        <span class="built_in">fcntl</span>(pipefd[<span class="number">0</span>], F_SETFL, flags);   <span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="type">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            <span class="built_in">write</span>(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/noblock运行.png" alt data-align="center">

<ul>
<li><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。</p>
</li>
<li><p>有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样<br>即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。</p>
</li>
<li><p>一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。</p>
</li>
<li><p>有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于：</p>
<ul>
<li><p>FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。</p>
</li>
<li><p>当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。</p>
</li>
<li><p>FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。</p>
</li>
</ul>
</li>
</ul>
<h2 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h2><ul>
<li><p>通过命令创建有名管道</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfifo 名字</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过函数创建有名管道</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close、read、write、unlink等。</p>
</li>
<li><p>FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对它们的写则是把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p>
</li>
</ul>
<h3 id="mkfifo命令"><a href="#mkfifo命令" class="headerlink" title="mkfifo命令"></a>mkfifo命令</h3><img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/mkfifo命令.png" alt data-align="center">

<h3 id="mkfifo函数"><a href="#mkfifo函数" class="headerlink" title="mkfifo函数"></a>mkfifo函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- pathname：管道名称路径</span></span><br><span class="line"><span class="comment">//- mode：文件的权限，和open的权限是一样的</span></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//成功返回0，失败返回-1，并设置错误号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有名管道通信案例"><a href="#有名管道通信案例" class="headerlink" title="有名管道通信案例"></a>有名管道通信案例</h3><p><code>write.c</code>往管道中写入数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向管道中写数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、判断文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        <span class="comment">//2、创建管道文件</span></span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、以只写的方式打开管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello , %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>, buf);</span><br><span class="line">        <span class="built_in">write</span>(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>read.c</code>往管道中读数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向管道中读数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、打开管道文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接了....\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/有名管道通信案例.png" alt data-align="center">

<h3 id="有名管道注意事项"><a href="#有名管道注意事项" class="headerlink" title="有名管道注意事项"></a>有名管道注意事项</h3><ul>
<li><p>一个为只读而打开的一个管道的进程会阻塞，直到另一个进程为写打开管道</p>
</li>
<li><p>一个为只写而打开一个管道的进程会阻塞，直到另一个进程为只读打开管道</p>
</li>
<li><p>读管道：</p>
<ul>
<li><p>管道中有数据，read返回实际读到的字节数</p>
</li>
<li><p>管道中无数据</p>
<ul>
<li><p>管道写端被全部关闭，read返回0，（相当于读到文件末尾）</p>
</li>
<li><p>写端没有被全部关闭，read会阻塞等待</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>写管道：</p>
<ul>
<li><p>管道读端被全部关闭，进程会异常终止（收到一个SIGPIPE信号）</p>
</li>
<li><p>管道读端没有全部关闭</p>
<ul>
<li><p>管道已经满了，write会阻塞</p>
</li>
<li><p>管道没有满，write将数据写入，并返回实际写入的字节数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="有名管道实现简单版聊天功能"><a href="#有名管道实现简单版聊天功能" class="headerlink" title="有名管道实现简单版聊天功能"></a>有名管道实现简单版聊天功能</h3><p>使用有名管道完成聊天的功能</p>
<ul>
<li><p>进程A</p>
<ol>
<li><p>以只写的方式打开管道1</p>
</li>
<li><p>以只读的方式打开管道2</p>
</li>
<li><p>循环的写读数据</p>
<p>while(1)</p>
<p>{</p>
<p>获取键盘录入fgets</p>
<p>写管道1</p>
<p>读管道2<br>}</p>
</li>
</ol>
</li>
<li><p>进程A</p>
<ol>
<li><p>以只写的方式打开管道1</p>
</li>
<li><p>以只读的方式打开管道2</p>
</li>
<li><p>循环的写读数据</p>
<p>while(1)</p>
<p>{</p>
<p>读管道1</p>
<p>获取键盘录入fgets<br>}</p>
</li>
</ol>
</li>
</ul>
<p><strong>chatA.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">access</span>(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.以只写的方式打开管道fifo1</span></span><br><span class="line">    <span class="type">int</span> fdw = <span class="built_in">open</span>(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.以只读的方式打开管道fifo2</span></span><br><span class="line">    <span class="type">int</span> fdr = <span class="built_in">open</span>(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.循环的写读数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 获取标准输入的数据</span></span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">128</span>, stdin);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = <span class="built_in">write</span>(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = <span class="built_in">read</span>(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fdr);</span><br><span class="line">    <span class="built_in">close</span>(fdw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>chatB.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">access</span>(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">access</span>(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = <span class="built_in">mkfifo</span>(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.以只读的方式打开管道fifo1</span></span><br><span class="line">    <span class="type">int</span> fdr = <span class="built_in">open</span>(<span class="string">&quot;fifo1&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待读取...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道fifo2</span></span><br><span class="line">    <span class="type">int</span> fdw = <span class="built_in">open</span>(<span class="string">&quot;fifo2&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待写入...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.循环的读写数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = <span class="built_in">read</span>(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 获取标准输入的数据</span></span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">128</span>, stdin);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = <span class="built_in">write</span>(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fdr);</span><br><span class="line">    <span class="built_in">close</span>(fdw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/有名管道聊天.png" alt data-align="center">

<h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/内存映射.png" alt data-align="center">

<h2 id="内存映射相关系统调用"><a href="#内存映射相关系统调用" class="headerlink" title="内存映射相关系统调用"></a>内存映射相关系统调用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//功能：</span></span><br><span class="line"><span class="comment">//映射或解除映射一个设备到内存中</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- void *addr：NULL，由内核指定</span></span><br><span class="line"><span class="comment">//- length：要映射的数据的长度，不能为0，建议使用文件的长度</span></span><br><span class="line"><span class="comment">//- int prot：对申请的内存映射区的操作权限</span></span><br><span class="line"><span class="comment">//    PROT_EXEC：可执行的权限</span></span><br><span class="line"><span class="comment">//    PROT_WRITE：读权限</span></span><br><span class="line"><span class="comment">//    PROT_WRITE：写权限</span></span><br><span class="line"><span class="comment">//    PROT_NONE：没有权限</span></span><br><span class="line"><span class="comment">//    要操作映射区内存，必须要有读权限</span></span><br><span class="line"><span class="comment">//- flags：</span></span><br><span class="line"><span class="comment">//    MAP_SHEARED：映射区数据会自动和磁盘文件同步，进程间通信必须要设置这个选项</span></span><br><span class="line"><span class="comment">//    MAP_PRIVATE：不同步，内存映射区的数据变了，对原来的数据不会修改，会重新创建一个新的文件。（copy on write）</span></span><br><span class="line"><span class="comment">//- fd：需要映射的那个文件的文件描述符</span></span><br><span class="line"><span class="comment">//    通过open得到，open的是一个磁盘文件</span></span><br><span class="line"><span class="comment">//    注意文件大小不能为0，open指定的权限不能和prot参数有冲突</span></span><br><span class="line"><span class="comment">//    open：只读/读写    prot：PROT_READ</span></span><br><span class="line"><span class="comment">//    open：读写    prot:PROT_READ | PROT_WRITE</span></span><br><span class="line"><span class="comment">//- offset：偏移量，一般不用，必须指定为4K的整数倍，0表示不偏移</span></span><br><span class="line"><span class="comment">//- 返回值：返回创建的内存首地址，失败返回MAP_FAILED:(void*)-1 -1int munmap(void *addr, size_t length);</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">//功能：释放内存映射</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- addr：要释放的内存首地址</span></span><br><span class="line"><span class="comment">//- length：要释放的内存大小，要和mmap函数中的length参数的值一样</span></span><br></pre></td></tr></table></figure>

<h2 id="案例：父子进程使用内存映射通信"><a href="#案例：父子进程使用内存映射通信" class="headerlink" title="案例：父子进程使用内存映射通信"></a>案例：父子进程使用内存映射通信</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用内存映射实现进程间通信</span></span><br><span class="line"><span class="comment">//1、父子进程</span></span><br><span class="line"><span class="comment">//  - 还没有子进程的时候</span></span><br><span class="line"><span class="comment">//  - 通过唯一的父进程创建内存映射区</span></span><br><span class="line"><span class="comment">//  - 有了内存映射区以后再创建子进程</span></span><br><span class="line"><span class="comment">//  - 父子进程之间共享创建的内存映射区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、没有关系的进程间通信</span></span><br><span class="line"><span class="comment">//  - 准备一个大小不为0的磁盘文件 </span></span><br><span class="line"><span class="comment">//  - 进程1通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment">//  - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">//  - 进程2通过磁盘文件创建内存映射区</span></span><br><span class="line"><span class="comment">//  - 得到一个操作这块内存的指针</span></span><br><span class="line"><span class="comment">//  - 使用内存映射区进行通信</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意内存映射区通信不会阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、打开一个文件</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);<span class="comment">//获取文件的大小</span></span><br><span class="line">    <span class="comment">//2、创建内存映射区</span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr, <span class="string">&quot;hello,child&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, (<span class="type">char</span>*)ptr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read data : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭内存映射区</span></span><br><span class="line">    <span class="built_in">munmap</span>(ptr, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/mmap.png" alt data-align="center">

<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul>
<li><p>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</p>
<blockquote>
<p>void* ptr &#x3D; mmap(…);</p>
<p>ptr++;  可以对其进行++操作</p>
<p>munmap(ptr,len);  错误</p>
</blockquote>
</li>
<li><p>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</p>
<blockquote>
<p>错误，会返回MAP_FAILED</p>
<p>open()函数中的权限建议prot参数的权限保持一致</p>
</blockquote>
</li>
<li><p>如果文件偏移量为1000会怎样?</p>
<blockquote>
<p>偏移量必须是4K的整数倍，一般会返回MAP_FAILED</p>
</blockquote>
</li>
<li><p>mmap什么情况下会调用失败?</p>
<blockquote>
<p>第二个参数：length &#x3D; 0</p>
<p>第三个参数： prot</p>
<p>    - 只指定了写权限</p>
<p>    - prot PROT_READ | PROT_WRITE</p>
<p>        第五个参数fd通过open函数时指定的O_RDONLY &#x2F; O_WRONLY</p>
</blockquote>
</li>
<li><p>可以open的时候O_CREAT一个新文件来创建映射区吗？</p>
<blockquote>
<p>可以，但是如果创建的文件的大小不能为0</p>
<p>可以对新的文件进行拓展</p>
<p>    - lseek()</p>
<p>    - truncate()</p>
</blockquote>
</li>
<li><p>mmap后关闭文件描述符，对mmap映射有没有影响？</p>
<blockquote>
<p>int fd &#x3D; open(“XXX”);</p>
<p>mmap(,,,,fd,0);</p>
<p>close(fd);</p>
<p>映射区还是存在的，创建映射区的fd被关闭，没有任何影响</p>
</blockquote>
</li>
<li><p>对ptr越界操作会怎样？</p>
<blockquote>
<p>void* ptr &#x3D; mmap(NULL,100,,,);</p>
<p>4K</p>
<p>越界操作，操作的是非法内存-&gt;段错误</p>
</blockquote>
</li>
</ul>
<h2 id="案例：使用内存映射进行文件拷贝"><a href="#案例：使用内存映射进行文件拷贝" class="headerlink" title="案例：使用内存映射进行文件拷贝"></a>案例：使用内存映射进行文件拷贝</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用内存映射实现文件拷贝功能</span></span><br><span class="line"><span class="comment">//1、对原始文件进行内存映射</span></span><br><span class="line"><span class="comment">//2、创建一个新文件（拓展该文件）</span></span><br><span class="line"><span class="comment">//3、把新文件的数据映射到内存中</span></span><br><span class="line"><span class="comment">//4、通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中</span></span><br><span class="line"><span class="comment">//5、释放资源</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、对原始文件进行内存映射</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;english.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取原始文件的大小</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">lseek</span>(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="comment">//2、创建一个新文件 （拓展该文件）</span></span><br><span class="line">    <span class="type">int</span> fd1 = <span class="built_in">open</span>(<span class="string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对新创建的文件进行拓展 </span></span><br><span class="line">    <span class="built_in">truncate</span>(<span class="string">&quot;cpy.txt&quot;</span>, len);</span><br><span class="line">    <span class="built_in">write</span>(fd1, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、分别做内存映射</span></span><br><span class="line">    <span class="type">void</span>* ptr1 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="type">void</span>* ptr2 = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr1 == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ptr2 == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内存拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr2, ptr1, len);</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="built_in">munmap</span>(ptr1, len);</span><br><span class="line">    <span class="built_in">munmap</span>(ptr2, len);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="built_in">close</span>(fd1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="案例：父子进程使用匿名映射通信"><a href="#案例：父子进程使用匿名映射通信" class="headerlink" title="案例：父子进程使用匿名映射通信"></a>案例：父子进程使用匿名映射通信</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名映射：不需要文件实体</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、创建匿名内存映射区</span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">4096</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//父子间进程通信</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">strcpy</span>((<span class="type">char</span>*)ptr, <span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放内存映射区</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">munmap</span>(ptr, len);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="信号概述"><a href="#信号概述" class="headerlink" title="信号概述"></a>信号概述</h1><h2 id="信号的概念"><a href="#信号的概念" class="headerlink" title="信号的概念"></a>信号的概念</h2><ul>
<li><p>信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。</p>
</li>
<li><p>发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：</p>
<ul>
<li><p>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</p>
</li>
<li><p>硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。</p>
</li>
<li><p>系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU<br>时间超限，或者该进程的某个子进程退出。</p>
</li>
<li><p>运行 kill 命令或调用 kill 函数。</p>
</li>
</ul>
</li>
<li><p>使用信号的两个主要目的是：</p>
<ul>
<li><p>让进程知道已经发生了一个特定的事情。</p>
</li>
<li><p>强迫进程执行它自己代码中的信号处理程序。</p>
</li>
</ul>
</li>
<li><p>信号的特点：</p>
<ul>
<li><p>简单</p>
</li>
<li><p>不能携带大量信息</p>
</li>
<li><p>满足某个特定条件才发送</p>
</li>
<li><p>优先级比较高</p>
</li>
</ul>
</li>
<li><p>查看系统定义的信号列表：<code>kill -l</code></p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/kill-l.png" alt data-align="center">
</li>
<li><p>前 31 个信号为常规信号，其余为实时信号</p>
</li>
</ul>
<h2 id="重点信号"><a href="#重点信号" class="headerlink" title="重点信号"></a>重点信号</h2><table>
<thead>
<tr>
<th align="center">编号</th>
<th>信号名称</th>
<th align="center">对应事件</th>
<th align="center">默认动作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td>SIGINT</td>
<td align="center">当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">在运行中的由该终端启动的程序发出此信号</td>
<td>终止进程</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td>SIGQUIT</td>
<td align="center">用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">端向正在运行中的由该终端启动的程序发出些信号</td>
<td>终止进程</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">9</td>
<td>SIGKILL</td>
<td align="center">无条件终止进程。该信号不能被忽略，处理和阻塞</td>
<td align="center">终止进程，可以杀死任何进程</td>
</tr>
<tr>
<td align="center">11</td>
<td>SIGSEGV</td>
<td align="center">指示进程进行了无效内存访问(段错误)</td>
<td align="center">终止进程并产生core文件</td>
</tr>
<tr>
<td align="center">13</td>
<td>SIGPIPE</td>
<td align="center">Broken pipe向一个没有读端的管道写数据</td>
<td align="center">终止进程</td>
</tr>
<tr>
<td align="center">17</td>
<td>SIGCHLD</td>
<td align="center">子进程结束时，父进程会收到这个信号</td>
<td align="center">忽略这个信号</td>
</tr>
<tr>
<td align="center">18</td>
<td>SIGCONT</td>
<td align="center">如果进程已停止，则使其继续运行</td>
<td align="center">继续&#x2F;忽略</td>
</tr>
<tr>
<td align="center">19</td>
<td>SIGSTOP</td>
<td align="center">停止进程的执行。信号不能被忽略，处理和阻塞</td>
<td align="center">为终止进程</td>
</tr>
</tbody></table>
<h2 id="信号的5种默认处理动作"><a href="#信号的5种默认处理动作" class="headerlink" title="信号的5种默认处理动作"></a>信号的5种默认处理动作</h2><ul>
<li><p>查看信号的详细信息：<code>man 7 signal</code></p>
</li>
<li><p>信号的5种默认处理动作</p>
<ul>
<li><p>Term    终止进程</p>
</li>
<li><p>Ign    当前进程忽略掉这个信号</p>
</li>
<li><p>Core    终止进程，并生成一个Core文件</p>
</li>
<li><p>Stop    暂停当前进程</p>
</li>
<li><p>Cont    继续执行当前被暂停的进程</p>
</li>
</ul>
</li>
<li><p>信号的几种状态：产生、未决、递达</p>
</li>
<li><p>SIGKILL和SIGSTOP信号不能被捕捉、阻塞或者阻塞，只能执行默认动作</p>
</li>
</ul>
<h2 id="Core动作"><a href="#Core动作" class="headerlink" title="Core动作"></a>Core动作</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span>* buf;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们建立一个core.c文件，这个文件肯定是会运行错误的，char* buf是一个野内存，我们访问这个内存是进行了一个非法操作 </p>
<p>我们运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>

<p>查看core文件大小的限制</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/corefillsize.png" alt data-align="center">

<p>大小限制为0表示不会生成core文件</p>
<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -c 1024</span><br></pre></td></tr></table></figure>

<p>修改core文件限制，此时我们编译运行core.c文件</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/核心已转储.png" alt data-align="center">

<p>发现错误，并且生成了一个core文件，如果没有生成core文件，可能是由于ubuntu预装了apport错误收集系统，运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service apport stop</span><br></pre></td></tr></table></figure>

<p>再次运行，发现生成了一个core文件</p>
<p>调试一下a.out程序</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/core文件错误信息.png" alt data-align="center">

<p>可以看到core文件中的错误信息</p>
<h2 id="信号相关函数"><a href="#信号相关函数" class="headerlink" title="信号相关函数"></a>信号相关函数</h2><h3 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kill</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//功能：给任何进程或进程组，发送任何信号sig</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//    - pid：需要发送给的进程的pid</span></span><br><span class="line"><span class="comment">//        &gt;0：将信号发送给指定的进程</span></span><br><span class="line"><span class="comment">//        =0：将信号发送给当前的进程组</span></span><br><span class="line"><span class="comment">//        =-1：将信号发送给每一个有权限接受这个信号的进程</span></span><br><span class="line"><span class="comment">//        &lt;-1：这个pid=某个进程组的id取反</span></span><br><span class="line"><span class="comment">//    - sig：需要发送的信号或者宏值，0表示不发送任何信号</span></span><br><span class="line"><span class="built_in">kil</span>(<span class="built_in">getppid</span>(),<span class="number">9</span>);<span class="comment">//给父进程发送一个9号信号</span></span><br><span class="line"><span class="built_in">kil</span>(<span class="built_in">getpid</span>(),<span class="number">9</span>);<span class="comment">//给自己发送一个9号信号</span></span><br></pre></td></tr></table></figure>

<h3 id="raise函数"><a href="#raise函数" class="headerlink" title="raise函数"></a>raise函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">raise</span><span class="params">(<span class="type">int</span> sig)</span></span>;</span><br><span class="line"><span class="comment">//功能：给当前的进程发送信号</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//    - sig：要发送的信号</span></span><br><span class="line"><span class="comment">//返回值</span></span><br><span class="line"><span class="comment">//    - 成功返回0</span></span><br><span class="line"><span class="comment">//    - 失败返回</span></span><br></pre></td></tr></table></figure>

<h3 id="abort函数"><a href="#abort函数" class="headerlink" title="abort函数"></a>abort函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">abort</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">//功能：发送SIGABRT信号给当前的进程，杀死当前进程</span></span><br><span class="line"><span class="built_in">kill</span>(getpid,SIGABRT);</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;chile process\n&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kill child process now\n&quot;</span>);</span><br><span class="line">        <span class="built_in">kill</span>(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/kill案例.png" alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span></span>;</span><br><span class="line"><span class="comment">//功能：设置定时器（闹钟），函数调用开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALARM</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//    - seconds：倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发送信号）</span></span><br><span class="line"><span class="comment">//        取消一个定时器，通过alarm(0);</span></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//    - 之前没有定时器，返回0</span></span><br><span class="line"><span class="comment">//    - 之前有定时器，返回之前的定时器剩余的时间</span></span><br><span class="line"><span class="comment">//- SIGALARM：默认终止当前的进程，每个进程都有且只有唯一的一个定时器</span></span><br></pre></td></tr></table></figure>

<p><strong>案例1</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;chile process\n&quot;</span>);</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;kill child process now\n&quot;</span>);</span><br><span class="line">        <span class="built_in">kill</span>(pid, SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/alarm案例1.png" alt data-align="center">

<p><strong>案例2 计算一秒钟电脑能数多少个数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">alarm</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/alarm1.png" alt data-align="center">

<p>可以运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./alarm1 &gt;&gt;a.txt</span><br></pre></td></tr></table></figure>

<p>将此文件的输出结果放到<code>a.txt</code>中</p>
<p><strong>实际时间</strong> &#x3D; 内核时间 + 用户时间 +消耗的时间</p>
<p>进行文件IO操作比较浪费时间</p>
<p>定时器与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时</p>
<h3 id="setitimer定时器函数"><a href="#setitimer定时器函数" class="headerlink" title="setitimer定时器函数"></a>setitimer定时器函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval* new_value, <span class="keyword">struct</span> itimerval* old_value)</span></span>;</span><br><span class="line"><span class="comment">//功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，实现周期性定时</span></span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//  - which:定时器以什么时间计时</span></span><br><span class="line"><span class="comment">//      ITIMER_REAL：真实时间，时间到达，发送SIGALARM信号，常用</span></span><br><span class="line"><span class="comment">//      ITIMER_VIRTUAL：用户时间，时间到达，发送SIGVTALRM信号</span></span><br><span class="line"><span class="comment">//      ITIMER_PROF：以该进程在用户态和内核态下所消耗的时间来计算，时间到达发送SIGPROF信号</span></span><br><span class="line"><span class="comment">//  - new_calue:设置定时器的属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct itimerval &#123;  //定时器结构体</span></span><br><span class="line"><span class="comment">//     struct timeval it_interval; /* Interval for periodic timer */   //每个间断的时间</span></span><br><span class="line"><span class="comment">//     struct timeval it_value;    /* Time until next expiration */    //延迟多长时间执行定时器</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct timeval &#123; //时间的结构体</span></span><br><span class="line"><span class="comment">//     time_t      tv_sec;         /* seconds */    //秒数</span></span><br><span class="line"><span class="comment">//     suseconds_t tv_usec;        /* microseconds */   //微秒</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">//  过10秒后每个两秒定时一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  - old_value：记录上一次的定时的时间参数，指定NULL</span></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//  - 成功返回0</span></span><br><span class="line"><span class="comment">//  - 错误返回-1并设置错误号 </span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//过三秒以后每个两秒定时一次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">    <span class="comment">//设置间隔时间值</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置延迟的时间</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">setitimer</span>(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);<span class="comment">//非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了.....\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/setitimer.png" alt data-align="center">

<h3 id="signal信号捕捉函数"><a href="#signal信号捕捉函数" class="headerlink" title="signal信号捕捉函数"></a>signal信号捕捉函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//一个函数指针</span></span><br><span class="line"><span class="function"><span class="type">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span></span>;</span><br><span class="line"><span class="comment">//功能：设置某个信号的捕捉行为</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//  - signum：要捕捉的信号</span></span><br><span class="line"><span class="comment">//  - handler：捕捉到信号要如何处理</span></span><br><span class="line"><span class="comment">//      - SIG_IGN：忽略信号</span></span><br><span class="line"><span class="comment">//      - SIG_DFL：使用信号默认行为</span></span><br><span class="line"><span class="comment">//      - 回调函数：这个函数是内核调用，程序员只负责写，捕捉到信号后如何处理信号</span></span><br><span class="line"><span class="comment">//              - 回调函数需要程序员实现并且提前准备好，函数的类型根据实际需求，一般看函数指针的定义</span></span><br><span class="line"><span class="comment">//              - 不是程序员调用，而是当信号产生，内核调用</span></span><br><span class="line"><span class="comment">//              - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置</span></span><br><span class="line"><span class="comment">//返回值：</span></span><br><span class="line"><span class="comment">//  - 成功：返回上一次注册的信号处理函数的地址，第一次调用返回NULL</span></span><br><span class="line"><span class="comment">//  - 失败：返回SIG_ERR，设置错误号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGKILL和SIGSTOP不能被捕捉不能被忽略</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//过三秒以后每个两秒定时一次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myalarm</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号的编号是%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注册信号捕捉</span></span><br><span class="line">    <span class="comment">//signal(SIGALRM,SIG_DFL)</span></span><br><span class="line">    <span class="comment">//signal(SIGALRM, SIG_DFL);</span></span><br><span class="line">    <span class="type">__sighandler_t</span> ret = <span class="built_in">signal</span>(SIGALRM, myalarm);</span><br><span class="line">    <span class="keyword">if</span> (ret == SIG_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;signal&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">    <span class="comment">//设置间隔时间值</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置延迟的时间</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret1 = <span class="built_in">setitimer</span>(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);<span class="comment">//非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了.....\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/signal函数.png" alt data-align="center">

<h2 id="信号集及其相关函数"><a href="#信号集及其相关函数" class="headerlink" title="信号集及其相关函数"></a>信号集及其相关函数</h2><ul>
<li><p>许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。</p>
</li>
<li><p>在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。</p>
</li>
<li><p>信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</p>
</li>
<li><p>信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</p>
</li>
<li><p>信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。</p>
</li>
</ul>
<h3 id="阻塞信号集和未决信号集"><a href="#阻塞信号集和未决信号集" class="headerlink" title="阻塞信号集和未决信号集"></a>阻塞信号集和未决信号集</h3><blockquote>
<p>1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</p>
<p>2.信号产生但是没有被处理 （未决）<br>    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）<br>    - SIGINT信号状态被存储在第二个标志位上<br>        - 这个标志位的值为0， 说明信号不是未决状态<br>        - 这个标志位的值为1， 说明信号处于未决状态</p>
<p>3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<br>    - 阻塞信号集默认不阻塞任何的信号<br>    - 如果想要阻塞某些信号需要用户调用系统的API</p>
<p>4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了<br>    - 如果没有阻塞，这个信号就被处理<br>    - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</p>
</blockquote>
<h3 id="信号集函数"><a href="#信号集函数" class="headerlink" title="信号集函数"></a>信号集函数</h3><h3 id="自定义信号集函数"><a href="#自定义信号集函数" class="headerlink" title="自定义信号集函数"></a>自定义信号集函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;</span><br><span class="line"><span class="comment">//        - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0</span></span><br><span class="line"><span class="comment">//        - 参数：set,传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">//        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *set)</span></span>;</span><br><span class="line"><span class="comment">//        - 功能：将信号集中的所有的标志位置为1</span></span><br><span class="line"><span class="comment">//        - 参数：set,传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">//        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span></span><br><span class="line"><span class="comment">//        - 参数：</span></span><br><span class="line"><span class="comment">//            - set：传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">//            - signum：需要设置阻塞的那个信号</span></span><br><span class="line"><span class="comment">//        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span></span><br><span class="line"><span class="comment">//        - 参数：</span></span><br><span class="line"><span class="comment">//            - set：传出参数，需要操作的信号集</span></span><br><span class="line"><span class="comment">//            - signum：需要设置不阻塞的那个信号</span></span><br><span class="line"><span class="comment">//        - 返回值：成功返回0， 失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *set, <span class="type">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//        - 功能：判断某个信号是否阻塞</span></span><br><span class="line"><span class="comment">//        - 参数：</span></span><br><span class="line"><span class="comment">//            - set：需要操作的信号集</span></span><br><span class="line"><span class="comment">//            - signum：需要判断的那个信号</span></span><br><span class="line"><span class="comment">//        - 返回值：</span></span><br><span class="line"><span class="comment">//            1 ： signum被阻塞</span></span><br><span class="line"><span class="comment">//            0 ： signum不阻塞</span></span><br><span class="line"><span class="comment">//            -1 ： 失败</span></span><br></pre></td></tr></table></figure>

<p> <strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个信号集</span></span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空信号集的内容</span></span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SIGINT是否在set里面</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">sigismember</span>(&amp;set, SIGINT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT不阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加几个信号到信号集中</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGINT);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SIGINT是否在信号集中</span></span><br><span class="line">    ret = <span class="built_in">sigismember</span>(&amp;set, SIGINT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT不阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = <span class="built_in">sigismember</span>(&amp;set, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT不阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从信号集中删除一个信号</span></span><br><span class="line">    <span class="built_in">sigdelset</span>(&amp;set, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = <span class="built_in">sigismember</span>(&amp;set, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT不阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/sigset.png" alt data-align="center">

<h3 id="系统信号集函数"><a href="#系统信号集函数" class="headerlink" title="系统信号集函数"></a>系统信号集函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span>* set, <span class="type">sigset_t</span>* oldset)</span></span>;</span><br><span class="line"><span class="comment">// -功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span></span><br><span class="line"><span class="comment">// - 参数：</span></span><br><span class="line"><span class="comment">// - how : 如何对内核阻塞信号集进行处理</span></span><br><span class="line"><span class="comment">// SIG_BLOCK : 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span></span><br><span class="line"><span class="comment">// 假设内核中默认的阻塞信号集是mask， mask | set</span></span><br><span class="line"><span class="comment">// SIG_UNBLOCK : 根据用户设置的数据，对内核中的数据进行解除阻塞</span></span><br><span class="line"><span class="comment">// mask &amp;= ~set</span></span><br><span class="line"><span class="comment">// SIG_SETMASK : 覆盖内核中原来的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// - set ：已经初始化好的用户自定义的信号集</span></span><br><span class="line"><span class="comment">// - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span></span><br><span class="line"><span class="comment">// - 返回值：</span></span><br><span class="line"><span class="comment">// 成功：0</span></span><br><span class="line"><span class="comment">// 失败： - 1</span></span><br><span class="line"><span class="comment">// 设置错误号：EFAULT、EINVAL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigpending</span><span class="params">(<span class="type">sigset_t</span> * set)</span></span>;</span><br><span class="line"><span class="comment">// - 功能：获取内核中的未决信号集</span></span><br><span class="line"><span class="comment">// - 参数：set, 传出参数，保存的是内核中的未决信号集中的信息。</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写一个程序，把所有的常规信号（1 - 31）的未决状态打印到屏幕</span></span><br><span class="line"><span class="comment">//设置某些信号是阻塞的，通过键盘产生这些信号</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置2、3号信号阻塞</span></span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将2号和3号信号添加到信号集中</span></span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGINT);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改内核中的阻塞信号集</span></span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取当前的未决信号集的数据</span></span><br><span class="line">        <span class="type">sigset_t</span> pendingset;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;pendingset);</span><br><span class="line">        <span class="built_in">sigpending</span>(&amp;pendingset);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历前32位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">32</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;pendingset, i) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sigismember</span>(&amp;pendingset, i) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">perror</span>(<span class="string">&quot;sigismember&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/sigprocmask.png" alt data-align="center">

<h3 id="sigaction信号捕捉函数"><a href="#sigaction信号捕捉函数" class="headerlink" title="sigaction信号捕捉函数"></a>sigaction信号捕捉函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction* act,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> sigaction* oldact)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -功能：检查或者改变信号的处理。信号捕捉</span></span><br><span class="line"><span class="comment">// - 参数：</span></span><br><span class="line"><span class="comment">// - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span></span><br><span class="line"><span class="comment">// - act ：捕捉到信号之后的处理动作</span></span><br><span class="line"><span class="comment">// - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span></span><br><span class="line"><span class="comment">// - 返回值：</span></span><br><span class="line"><span class="comment">// 成功 0</span></span><br><span class="line"><span class="comment">// 失败 - 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> &#123;</span><br><span class="line">    <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">    <span class="built_in">void</span>     (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">// 不常用</span></span><br><span class="line">    <span class="built_in">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span>*, <span class="type">void</span>*);</span><br><span class="line">    <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">    <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">    <span class="type">int</span>        sa_flags;</span><br><span class="line">    <span class="comment">// 被废弃掉了</span></span><br><span class="line">    <span class="built_in">void</span>     (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//过三秒以后每个两秒定时一次</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myalarm</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号的编号是%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------------------\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = myalarm;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);<span class="comment">//清空临时阻塞信号集</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> new_value;</span><br><span class="line">    <span class="comment">//设置间隔时间值</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置延迟的时间</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret1 = <span class="built_in">setitimer</span>(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);<span class="comment">//非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了.....\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret1 == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行：</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/sigaction.png" alt data-align="center">

<h2 id="内核信号被捕捉的过程"><a href="#内核信号被捕捉的过程" class="headerlink" title="内核信号被捕捉的过程"></a>内核信号被捕捉的过程</h2><img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/内核信号被捕捉的过程.png" alt data-align="center">

<h2 id="SIGCHID信号"><a href="#SIGCHID信号" class="headerlink" title="SIGCHID信号"></a>SIGCHID信号</h2><ul>
<li><p>SIGCHLD信号产生的条件<br> 子进程终止时<br> 子进程接收到 SIGSTOP 信号停止时<br> 子进程处在停止态，接受到SIGCONT后唤醒时</p>
</li>
<li><p>以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号</p>
</li>
</ul>
<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFun</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到的信号:%d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回收子进程PCB的资源</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die , pid = %d \n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//说明还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//提前设置好阻塞信号集，阻塞SIGCHLD，因为可能子进程很快结束，父进程还没有注册完信号捕捉</span></span><br><span class="line">    <span class="type">sigset_t</span> set;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;set);</span><br><span class="line">    <span class="built_in">sigaddset</span>(&amp;set, SIGCHLD);</span><br><span class="line">    <span class="built_in">sigprocmask</span>(SIG_BLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//捕捉子进程死亡时发送的SIGCHLD信号</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        act.sa_handler = myFun;</span><br><span class="line">        <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">        <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册完信号捕捉以后，解除阻塞</span></span><br><span class="line">        <span class="built_in">sigprocmask</span>(SIG_UNBLOCK, &amp;set, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent process pid : %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process pid : %d\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/sigchld.png" alt data-align="center">

<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><ul>
<li><p>共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。</p>
</li>
<li><p>与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。</p>
</li>
</ul>
<h2 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h2><ul>
<li><p>调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。</p>
</li>
<li><p>使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。</p>
</li>
<li><p>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。</p>
</li>
<li><p>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。</p>
</li>
<li><p>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。</p>
</li>
</ul>
<h2 id="共享内存相关的函数"><a href="#共享内存相关的函数" class="headerlink" title="共享内存相关的函数"></a>共享内存相关的函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共享内存相关的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br><span class="line">    <span class="comment">// - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span></span><br><span class="line">    <span class="comment">//     新创建的内存段中的数据都会被初始化为0</span></span><br><span class="line">    <span class="comment">// - 参数：</span></span><br><span class="line">    <span class="comment">//     - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。</span></span><br><span class="line">    <span class="comment">//             一般使用16进制表示，非0值</span></span><br><span class="line">    <span class="comment">//     - size: 共享内存的大小</span></span><br><span class="line">    <span class="comment">//     - shmflg: 属性</span></span><br><span class="line">    <span class="comment">//         - 访问权限</span></span><br><span class="line">    <span class="comment">//         - 附加属性：创建/判断共享内存是不是存在</span></span><br><span class="line">    <span class="comment">//             - 创建：IPC_CREAT</span></span><br><span class="line">    <span class="comment">//             - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span></span><br><span class="line">    <span class="comment">//                 IPC_CREAT | IPC_EXCL | 0664</span></span><br><span class="line">    <span class="comment">//     - 返回值：</span></span><br><span class="line">    <span class="comment">//         失败：-1 并设置错误号</span></span><br><span class="line">    <span class="comment">//         成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span></span>;</span><br><span class="line">    <span class="comment">// - 功能：和当前的进程进行关联</span></span><br><span class="line">    <span class="comment">// - 参数：</span></span><br><span class="line">    <span class="comment">//     - shmid : 共享内存的标识（ID）,由shmget返回值获取</span></span><br><span class="line">    <span class="comment">//     - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定</span></span><br><span class="line">    <span class="comment">//     - shmflg : 对共享内存的操作</span></span><br><span class="line">    <span class="comment">//         - 读 ： SHM_RDONLY, 必须要有读权限</span></span><br><span class="line">    <span class="comment">//         - 读写： 0</span></span><br><span class="line">    <span class="comment">// - 返回值：</span></span><br><span class="line">    <span class="comment">//     成功：返回共享内存的首（起始）地址。  失败(void *) -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br><span class="line">    <span class="comment">// - 功能：解除当前进程和共享内存的关联</span></span><br><span class="line">    <span class="comment">// - 参数：</span></span><br><span class="line">    <span class="comment">//     shmaddr：共享内存的首地址</span></span><br><span class="line">    <span class="comment">// - 返回值：成功 0， 失败 -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br><span class="line">    <span class="comment">// - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span></span><br><span class="line">    <span class="comment">// - 参数：</span></span><br><span class="line">    <span class="comment">//     - shmid: 共享内存的ID</span></span><br><span class="line">    <span class="comment">//     - cmd : 要做的操作</span></span><br><span class="line">    <span class="comment">//         - IPC_STAT : 获取共享内存的当前的状态</span></span><br><span class="line">    <span class="comment">//         - IPC_SET : 设置共享内存的状态</span></span><br><span class="line">    <span class="comment">//         - IPC_RMID: 标记共享内存被销毁</span></span><br><span class="line">    <span class="comment">//     - buf：需要设置或者获取的共享内存的属性信息</span></span><br><span class="line">    <span class="comment">//         - IPC_STAT : buf存储数据</span></span><br><span class="line">    <span class="comment">//         - IPC_SET : buf中需要初始化数据，设置到内核中</span></span><br><span class="line">    <span class="comment">//         - IPC_RMID : 没有用，NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span></span>;</span><br><span class="line">    <span class="comment">// - 功能：根据指定的路径名，和int值，生成一个共享内存的key</span></span><br><span class="line">    <span class="comment">// - 参数：</span></span><br><span class="line">    <span class="comment">//     - pathname:指定一个存在的路径</span></span><br><span class="line">    <span class="comment">//     - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节</span></span><br><span class="line">    <span class="comment">//                范围 ： 0-255  一般指定一个字符 &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="案例：使用共享内存进行通信"><a href="#案例：使用共享内存进行通信" class="headerlink" title="案例：使用共享内存进行通信"></a>案例：使用共享内存进行通信</h2><p><strong>write.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、创建一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT | <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line">    <span class="comment">//2、和当前进程进行关联 </span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">//3、写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">//4、解除关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>read.c</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、获取一个共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line">    <span class="comment">//2、和当前进程进行关联 </span></span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span>*)ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="comment">//4、解除关联</span></span><br><span class="line">    <span class="built_in">shmdt</span>(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5、删除共享内存</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别编译运行</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/共享内存.png" alt data-align="center">

<h2 id="思考问题-1"><a href="#思考问题-1" class="headerlink" title="思考问题"></a>思考问题</h2><blockquote>
<p>问题1：操作系统如何知道一块共享内存被多少个进程关联？</p>
<p>    - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</p>
<p>    - shm_nattach 记录了关联的进程个数</p>
<p>问题2：可不可以对共享内存进行多次删除 shmctl</p>
<p>    - 可以的</p>
<p>    - 因为shmctl 标记删除共享内存，不是直接删除</p>
<p>    - 什么时候真正删除呢?</p>
<p>        当和共享内存关联的进程数为0的时候，就真正被删除</p>
<p>    - 当共享内存的key为0的时候，表示共享内存被标记删除了</p>
<p>        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</p>
<p>    共享内存和内存映射的区别</p>
<p>    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</p>
<p>    2.共享内存效果更高</p>
<p>    3.内存</p>
<p>        所有的进程操作的是同一块共享内存。</p>
<p>        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</p>
<p>    4.数据安全</p>
<p>        - 进程突然退出</p>
<p>            共享内存还存在</p>
<p>            内存映射区消失</p>
<p>        - 运行进程的电脑死机，宕机了</p>
<p>            数据存在在共享内存中，没有了</p>
<p>            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</p>
<p>    5.生命周期</p>
<p>        - 内存映射区：进程退出，内存映射区销毁</p>
<p>        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</p>
<p>            如果一个进程退出，会自动和共享内存进行取消关联。</p>
</blockquote>
<h2 id="共享内存操作命令"><a href="#共享内存操作命令" class="headerlink" title="共享内存操作命令"></a>共享内存操作命令</h2><ul>
<li><p>ipcs 用法</p>
<ul>
<li><p>ipcs -a &#x2F;&#x2F; 打印当前系统中所有的进程间通信方式的信息</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/ipcs-a.png" alt data-align="center">

<p>ipcs -m &#x2F;&#x2F; 打印出使用共享内存进行进程间通信的信息</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/ipcs-m.png" alt data-align="center">

<p>ipcs -q &#x2F;&#x2F; 打印出使用消息队列进行进程间通信的信息</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/ipcs-q.png" alt data-align="center">
</li>
<li><p>ipcs -s &#x2F;&#x2F; 打印出使用信号进行进程间通信的信息</p>
<img title src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/ipcs-s.png" alt data-align="center"></li>
</ul>
</li>
<li><p>ipcrm 用法</p>
<ul>
<li><p>ipcrm -M shmkey &#x2F;&#x2F; 移除用shmkey创建的共享内存段</p>
</li>
<li><p>ipcrm -m shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段</p>
</li>
<li><p>ipcrm -Q msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列</p>
</li>
<li><p>ipcrm -q msqid &#x2F;&#x2F; 移除用msqid标识的消息队列</p>
</li>
<li><p>ipcrm -S semkey &#x2F;&#x2F; 移除用semkey创建的信号</p>
</li>
<li><p>ipcrm -s semid &#x2F;&#x2F; 移除用semid标识的信号</p>
</li>
</ul>
</li>
</ul>
<h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ul>
<li><p>在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。</p>
<p>可以通过命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $$</span><br></pre></td></tr></table></figure>

<p>查看当前shell的进程号</p>
<p><img src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/bash.png"></p>
</li>
<li><p>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p>
</li>
<li><p>在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \ 会产生 SIGQUIT 信号</p>
</li>
</ul>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><ul>
<li><p>进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。</p>
</li>
<li><p>进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。</p>
</li>
<li><p>进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。</p>
</li>
</ul>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><ul>
<li><p>会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。</p>
</li>
<li><p>一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</p>
</li>
<li><p>在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。</p>
</li>
<li><p>当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。</p>
</li>
</ul>
<h2 id="进程组、会话、控制终端之间的关系"><a href="#进程组、会话、控制终端之间的关系" class="headerlink" title="进程组、会话、控制终端之间的关系"></a>进程组、会话、控制终端之间的关系</h2><img src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/关系.png" title alt data-align="center">

<p>运行的命令为：</p>
<ul>
<li><p><code>find / 2 &gt; /dev/null | wc -l &amp;</code></p>
</li>
<li><p><code>sort &lt; longlist | uniq -c</code></p>
</li>
</ul>
<h2 id="进程组、会话操作函数"><a href="#进程组、会话操作函数" class="headerlink" title="进程组、会话操作函数"></a>进程组、会话操作函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//获取当前进程的进程组ID</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>; <span class="comment">//获取指定进程的进程组ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span></span>; <span class="comment">//设置进程组的ID</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>; <span class="comment">//获取指定进程的会话的ID</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">//设置进程的会话ID</span></span><br></pre></td></tr></table></figure>

<h2 id="守护进程-1"><a href="#守护进程-1" class="headerlink" title="守护进程"></a>守护进程</h2><ul>
<li><p>守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。</p>
</li>
<li><p>守护进程具备下列特征：</p>
</li>
<li><p>生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。</p>
</li>
<li><p>它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。</p>
</li>
<li><p>Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等</p>
</li>
</ul>
<h3 id="守护进程创建步骤"><a href="#守护进程创建步骤" class="headerlink" title="守护进程创建步骤"></a>守护进程创建步骤</h3><ul>
<li><p>执行一个 fork()，之后父进程退出，子进程继续执行。</p>
</li>
<li><p>子进程调用 setsid() 开启一个新会话。</p>
</li>
<li><p>清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。</p>
</li>
<li><p>修改进程的当前工作目录，通常会改为根目录（&#x2F;）。</p>
</li>
<li><p>关闭守护进程从其父进程继承而来的所有打开着的文件描述符。</p>
</li>
<li><p>在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2() 使所有这些描述符指向这个设备。</p>
</li>
<li><p>核心业务逻辑</p>
</li>
</ul>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 捕捉到信号之后，获取系统时间，写入磁盘文件</span></span><br><span class="line">    <span class="type">time_t</span> tm = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* loc = <span class="built_in">localtime</span>(&amp;tm);</span><br><span class="line">    <span class="comment">// char buf[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sprintf(buf, &quot;%d-%d-%d %d:%d:%d\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon</span></span><br><span class="line">    <span class="comment">// ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%s\n&quot;, buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* str = <span class="built_in">asctime</span>(loc);</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">write</span>(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建子进程，退出父进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.将子进程重新创建一个会话</span></span><br><span class="line">    <span class="built_in">setsid</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.设置掩码</span></span><br><span class="line">    <span class="built_in">umask</span>(<span class="number">022</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.更改工作目录</span></span><br><span class="line">    <span class="built_in">chdir</span>(<span class="string">&quot;/home/plucky/Linux/lecture27&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 关闭、重定向文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDIN_FILENO);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDOUT_FILENO);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 捕捉定时信号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    act.sa_handler = work;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    <span class="built_in">sigaction</span>(SIGALRM, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> val;</span><br><span class="line">    val.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    val.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    val.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建定时器</span></span><br><span class="line">    <span class="built_in">setitimer</span>(ITIMER_REAL, &amp;val, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不让进程结束</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行</p>
<img src="/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/守护进程.png" title alt data-align="center">

<p>因为是守护进程，所以会新建一个会话，我们从控制终端上进行的操作不会影响到守护进程的执行，只能通过kill命令杀死守护进程</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 指针</title>
    <url>/2023/04/09/C++-%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="指针基本概念"><a href="#指针基本概念" class="headerlink" title="指针基本概念"></a>指针基本概念</h1><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p>
<ul>
<li><p>内存编号是从0开始记录的，一般用十六进制数字表示</p>
</li>
<li><p>可以利用指针变量保存地址</p>
</li>
</ul>
<p>可以通过一个指针来保存一个地址</p>
<h1 id="指针的定义和使用"><a href="#指针的定义和使用" class="headerlink" title="指针的定义和使用"></a>指针的定义和使用</h1><h2 id="定义指针"><a href="#定义指针" class="headerlink" title="定义指针"></a>定义指针</h2><p>指针定义的语法： <code>数据类型 \* 指针变量名</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a的地址为&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;指针p为&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>a的地址为00000087472FFC84<br>指针p为00000087472FFC84</p>
</blockquote>
<p>我们可以得到指针就是地址</p>
<h2 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h2><p>可以通过解引用的方式来找到指针指向的内存</p>
<p>指针前加 <code>*</code>代表解引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a的地址为&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;指针p为&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">1000</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>a的地址为0000003F9953F7C4<br>指针p为0000003F9953F7C4<br>a &#x3D; 1000<br>*p &#x3D; 1000</p>
</blockquote>
<p>通过<code>p</code>找到<code>a</code>的内存，并且可以通过<code>*p</code>修改内存</p>
<h1 id="指针所占内存空间"><a href="#指针所占内存空间" class="headerlink" title="指针所占内存空间"></a>指针所占内存空间</h1><p>指针也是一种数据类型，那么这种数据类型占用多少内存空间呢？</p>
<p>在32位操作系统下：占用4个字节空间</p>
<p>在64位操作系统下：占用8个字节空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>* p = &amp;a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof (p) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof (int *) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span> *) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof (char *) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof (float *) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof (double *) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>sizeof (p) &#x3D; 8<br>sizeof (int *) &#x3D; 8<br>sizeof (char *) &#x3D; 8<br>sizeof (float *) &#x3D; 8<br>sizeof (double *) &#x3D; 8</p>
</blockquote>
<p>因为指针是内存，所以不管是什么数据类型下，64位操作系统，指针都是占用8个字节空间大小</p>
<h1 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h1><h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p><strong>空指针</strong>：指针变量指向内存中为0的空间</p>
<p><strong>用途</strong>：初始化指针变量</p>
<p><strong>注意</strong>：空指针的内存是不可以访问的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>程序运行错误</p>
<p><img src="/2023/04/09/C++-%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/Error.png"></p>
<p>0~255之间的内存编号是系统占用的，因此不可以访问</p>
<h2 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h2><p><strong>野指针</strong>：指针变量指向一段非法的内存空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>程序运行错误</p>
<p><img src="/2023/04/09/C++-%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/Erro1.png"></p>
<p>在程序中尽量避免野指针</p>
<h1 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h1><p>const修饰指针有三种情况</p>
<h2 id="const修饰指针-常量指针"><a href="#const修饰指针-常量指针" class="headerlink" title="const修饰指针 - 常量指针"></a>const修饰指针 - 常量指针</h2><p>指针的指向可以修改，指针指向的值不能修改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * p;</span><br></pre></td></tr></table></figure>

<h2 id="const修饰常量-指针常量"><a href="#const修饰常量-指针常量" class="headerlink" title="const修饰常量 - 指针常量"></a>const修饰常量 - 指针常量</h2><p>指针的指向不可以改，指针指向的值可以改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<h2 id="const既修饰指针，又修饰常量"><a href="#const既修饰指针，又修饰常量" class="headerlink" title="const既修饰指针，又修饰常量"></a>const既修饰指针，又修饰常量</h2><p>指针的指向不可以改，指针指向的值也不可以改</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、const 修饰指针 常量指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * p1 = &amp;a;</span><br><span class="line">    <span class="comment">//*p1 = 20 错误</span></span><br><span class="line">    p1 = &amp;b;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、const 修饰常量 指针常量</span></span><br><span class="line">    <span class="type">int</span>* <span class="type">const</span> p2 = &amp;a;</span><br><span class="line">    *p2 = <span class="number">100</span>;<span class="comment">//正确</span></span><br><span class="line">    <span class="comment">//p2 = &amp;b; 错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、const 既修饰常量又修饰指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line">    <span class="comment">//*p3 = 100 错误</span></span><br><span class="line">    <span class="comment">//p3 = &amp;b 错误</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h1 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h1><p>利用指针访问数组中的数据元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="type">int</span>* p = arr;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一个元素为：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;指针访问第一个元素：&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>第一个元素为：1<br>指针访问第一个元素：1<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
</blockquote>
<h1 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h1><p>利用指针作为函数参数，可以修改实参的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap02</span><span class="params">(<span class="type">int</span>* p1, <span class="type">int</span>* p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//1、值传递</span></span><br><span class="line">    <span class="built_in">swap01</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap01后a的值为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap01后b的值为&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2、地址传递</span></span><br><span class="line">    <span class="built_in">swap02</span>(&amp;a, &amp;b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap02后a的值为&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap02后b的值为&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>swap01后a的值为10<br>swap01后b的值为20<br>swap02后a的值为20<br>swap02后b的值为10</p>
</blockquote>
<h1 id="指针、数组、函数"><a href="#指针、数组、函数" class="headerlink" title="指针、数组、函数"></a>指针、数组、函数</h1><p>案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果j&gt;j+1,交换数字</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、创建数组</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">4</span> , <span class="number">3</span> , <span class="number">6</span> , <span class="number">9</span> , <span class="number">1</span> , <span class="number">2</span> , <span class="number">10</span> , <span class="number">8</span> , <span class="number">7</span> , <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//数组长度</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//2、创建函数，实现冒泡排序</span></span><br><span class="line">    <span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line">    <span class="comment">//3、打印排序后的数组</span></span><br><span class="line">    <span class="built_in">printArray</span>(arr, len);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 程序的内存模型</title>
    <url>/2023/04/11/C++-%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>C++程序在执行时，将内存大方向划分为四个区域</p>
<ul>
<li><p>代码区：存放函数体的二进制代码，由操作系统进行管理</p>
</li>
<li><p>全局区：存放全局变量和静态变量以及常量</p>
</li>
<li><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</p>
</li>
<li><p>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收</p>
</li>
</ul>
<p>内存四区的意义：</p>
<p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程</p>
<h1 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h1><p>在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域</p>
<ul>
<li><p>代码区：</p>
<ul>
<li><p>存放CPU执行的机器指令</p>
</li>
<li><p>代码区是共享的，共享的目的是对于频繁执行的程序，只要在内存中有一份代码即可</p>
</li>
<li><p>代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令</p>
</li>
</ul>
</li>
<li><p>全局区：</p>
<ul>
<li><p>全局变量和静态变量存放在此</p>
</li>
<li><p>该区域的数据在程序结束后由操作系统释放</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量a的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;a&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部变量b的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;b&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_a的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;g_a&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局变量g_b的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;g_b&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_a的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;静态变量s_b的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量Hello World的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;<span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_a的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;全局常量c_g_b的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_a的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>) &amp; c_a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;局部常量c_b的地址&quot;</span> &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>) &amp; c_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>局部变量a的地址145921079908<br>局部变量b的地址145921079940<br>全局变量g_a的地址140702441787392<br>全局变量g_b的地址140702441787396<br>静态变量s_a的地址140702441787400<br>静态变量s_b的地址140702441787404<br>字符串常量Hello World的地址140702441778224<br>全局常量c_g_a的地址140702441778272<br>全局常量c_g_b的地址140702441778276<br>局部常量c_a的地址145921079972<br>局部常量c_b的地址145921080004</p>
</blockquote>
<h1 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h1><ul>
<li><p>栈区</p>
<p>由编译器自动分配释放存放函数的参数值（形参），局部变量等</p>
<p>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>10<br>-226279312</p>
</blockquote>
<ul>
<li><p>堆区</p>
<p> 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收</p>
<p>在C++中主要利用<code>new</code>在堆区开辟内存</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>10<br>10</p>
</blockquote>
<h1 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h1><p>C++中利用<code>new</code>操作符在堆区开辟数据</p>
<p>堆区开辟的数据，由程序员手动释放，释放利用操作符<code>delete</code></p>
<p>语法：<code>new 数据类型</code></p>
<p>利用<code>new</code>创建的数据，会返回该数据对应的类型的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span> (<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">delete</span>(p);</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<p><img src="/2023/04/11/C++-%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/ERROR.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] = i + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109</p>
</blockquote>
<p>delete之后，不能访问arr指针指向的内存，否则会发生跟上图一样的情况</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 模板</title>
    <url>/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="模板的概念"><a href="#模板的概念" class="headerlink" title="模板的概念"></a>模板的概念</h1><p>模板就是建立一个通用的模具，大大提高复用性</p>
<p>模板的特点：</p>
<ul>
<li><p>不能直接使用，他只是一个框架</p>
</li>
<li><p>模板的通用并不是万能的</p>
</li>
</ul>
<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><ul>
<li><p>C++另一种编程思想称为泛型编程，主要利用的技术就是模板</p>
</li>
<li><p>C++提供两种模板机制：函数模板和类模板</p>
</li>
</ul>
<h2 id="函数模板语法"><a href="#函数模板语法" class="headerlink" title="函数模板语法"></a>函数模板语法</h2><p>函数模板作用：</p>
<p>建立一个通用函数，其函数返回值类型和形参类型可以不具体指定用一个虚拟的类型来代表</p>
<p><strong>语法</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<p>template — 声明创建模板</p>
<p>typename — 表明其后面的符号是一种符号类型，可以用class代替</p>
<p>T — 通用的数据类型，名称可以替换，通常为大写字母</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个整形交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//声明一个模板，告诉编译器后面代码中紧跟着的T不要报错，T是一个通用数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swapInt</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">//利用函数模板，两种方式使用</span></span><br><span class="line">    <span class="comment">//1、自动类型推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//显式指定类型</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> c = <span class="number">1.1</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">2.2</span>;</span><br><span class="line">    <span class="built_in">swapDouble</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mySwap</span>(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//显式指定类型</span></span><br><span class="line">    <span class="built_in">mySwap</span>&lt;<span class="type">double</span>&gt;(c, d);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d = &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li><p>函数模板利用关键字template</p>
</li>
<li><p>使用函数模板有两种方式：自动类型推导，显示指定类型</p>
</li>
<li><p>模板的目的是为了提高复用性，将类型参数化</p>
</li>
</ul>
<h2 id="函数模板注意事项"><a href="#函数模板注意事项" class="headerlink" title="函数模板注意事项"></a>函数模板注意事项</h2><p>注意事项：</p>
<ul>
<li><p>自动类型推导，必须推导出一致的数据类型T才可以使用</p>
</li>
<li><p>模板必须要确定出T的数据类型，才可以使用</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板注意事项</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//typename可以替换成class</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、自动类型推导，必须推导出一致的数据类型T才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);<span class="comment">//正确；</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">mySwap</span>(a, c);<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/error1.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板注意事项</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="comment">//typename可以替换成class</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、自动类型推导，必须推导出一致的数据类型T才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);<span class="comment">//正确；</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、模板必须要确定出T的数据类型，才可以使用 </span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/error2.png" title alt data-align="center">

<h2 id="函数模板案例"><a href="#函数模板案例" class="headerlink" title="函数模板案例"></a>函数模板案例</h2><p>案例描述</p>
<ul>
<li><p>利用函数模板封装一个排序的函数，可以对不同数据类型的数组进行排序</p>
</li>
<li><p>排序规则从大到小，排序算法为选择排序</p>
</li>
<li><p>分别利用char数组和int数组进行测试</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> max = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">            &#123;</span><br><span class="line">                max = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> charArr[] = <span class="string">&quot;badcfe&quot;</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="built_in">mySort</span>(charArr, num); </span><br><span class="line">    <span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> intArr[] = &#123; <span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span> &#125;;</span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">mySort</span>(intArr, num);</span><br><span class="line">    <span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>f e d c b a<br>9 8 7 6 5 4 2 1</p>
</blockquote>
<h2 id="普通函数和函数模板的区别"><a href="#普通函数和函数模板的区别" class="headerlink" title="普通函数和函数模板的区别"></a>普通函数和函数模板的区别</h2><ul>
<li><p>普通函数调用时可以发生自动类型转换（隐式类型转换）</p>
</li>
<li><p>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</p>
<img src="/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/自动类型推导error.png" title alt data-align="center">
</li>
<li><p>如果利用显示指定类型的方式，可以发生隐式类型转换</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与函数模板区别</span></span><br><span class="line"><span class="comment">//1、普通函数调用可以发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数模板用自动类型推导，不可以发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//自动类型推导 不会发生隐式类型转换</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; myAdd02(a, c) &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//显示指定类型 会发生隐式类型转换</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>109<br>109</p>
</blockquote>
<h2 id="普通函数与函数模板的调用规则"><a href="#普通函数与函数模板的调用规则" class="headerlink" title="普通函数与函数模板的调用规则"></a>普通函数与函数模板的调用规则</h2><p>调用规则如下：</p>
<ul>
<li><p>如果函数模板和普通函数都可以实现，优先调用普通函数</p>
</li>
<li><p>可以通过空模板参数列表来强制调用函数模板</p>
</li>
<li><p>函数模板也可以发生重载</p>
</li>
<li><p>如果函数模板可以更好的匹配，有限调用函数模板</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与函数模板的调用规则</span></span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以调用，优先调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表强制调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板可以发生函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、如果函数模板可以更好的匹配，优先调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>调用的普通函数</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与函数模板的调用规则</span></span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以调用，优先调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表强制调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板可以发生函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、如果函数模板可以更好的匹配，优先调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//通过空模板参数列表，强制调用函数模板</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>调用的模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与函数模板的调用规则</span></span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以调用，优先调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表强制调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板可以发生函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、如果函数模板可以更好的匹配，优先调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的重载模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果为：</p>
<blockquote>
<p>调用的重载模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数与函数模板的调用规则</span></span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以调用，优先调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表强制调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板可以发生函数重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、如果函数模板可以更好的匹配，优先调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用的重载模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果函数模板产生更好的匹配，优先调用函数模板</span></span><br><span class="line">    <span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(c1, c2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>调用的模板</p>
</blockquote>
<h2 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h2><p>模板并不是万能的 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板的局限性</span></span><br><span class="line"><span class="comment">//模板并不是万能的，有些特定数据，需要具体化方式做特殊实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对比两个数据是否相等函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用具体化Person的版本实现代码，具体化优先调用</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person&amp; a, Person&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a == b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a != b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 == p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 != p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>a !&#x3D; b<br>p1 &#x3D;&#x3D; p2</p>
</blockquote>
<p>总结：</p>
<ul>
<li><p>利用具体化的模板，可以解决自定义类型的通用化</p>
</li>
<li><p>学习模板不是为了写模板，而是在STL能够运用系统提供的模板</p>
</li>
</ul>
<h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><h2 id="类模板语法"><a href="#类模板语法" class="headerlink" title="类模板语法"></a>类模板语法</h2><p>类模板作用：</p>
<ul>
<li>建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>)</span></span>;</span><br><span class="line">    p1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>name: 孙悟空 age: 999</p>
</blockquote>
<h2 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h2><p>类模板与函数模板区别主要有两点</p>
<ul>
<li>类模板没有自动类型推导的使用方式</li>
</ul>
<img src="/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/类模板无法使用自动类型推导.png" title alt data-align="center">

<ul>
<li>类模板在模板参数列表中可以有默认参数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>,<span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;string&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>name: 孙悟空 age: 999</p>
</blockquote>
<h2 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h2><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p>
<ul>
<li><p>普通类中的成员一开始就可以创建</p>
</li>
<li><p>类模板中的成员函数在调用时才创建</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T obj;</span><br><span class="line">    <span class="comment">//类模板中的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj.<span class="built_in">showPerson1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj.<span class="built_in">showPerson2</span>(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Myclass&lt;Person1&gt;m;</span><br><span class="line">    m.<span class="built_in">func1</span>();</span><br><span class="line">    <span class="comment">//m.func2();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person1 show</p>
</blockquote>
<h2 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h2><p>类模板实例化出的对象，像函数传参的方式</p>
<p>一共有三种传入方式：</p>
<ul>
<li><p>指定传入的类型  –  直接显示对象的数据类型（最常用）</p>
</li>
<li><p>参数模板化  –  将对象中的参数变为模板进行传递</p>
</li>
<li><p>整个类模板化  –  将这个对象类型模板化进行传递</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板对象做函数参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string,<span class="type">int</span>&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person &lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">    <span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">888</span>);</span><br><span class="line">    <span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名： 孙悟空 年龄： 999<br>姓名： 猪八戒 年龄： 888<br>T1的类型为： class std::basic_string&lt;char,struct std::char_traits<char>,class std::allocator<char> &gt;<br>T2的类型为： int<br>姓名： 唐僧 年龄： 30<br>T的类型为： class Person&lt;class std::basic_string&lt;char,struct std::char_traits<char>,class std::allocator<char> &gt;,int&gt;</char></char></char></char></p>
</blockquote>
<h2 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h2><p>当类模板碰到继承时，需要注意以下几点：</p>
<ul>
<li><p>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</p>
</li>
<li><p>如果不指定，编译器无法给子类分配内存</p>
</li>
<li><p>如果想灵活指定出父类中T的类型，子类也需变为类模板</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板与继承</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    T m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt;<span class="comment">//必须要指导父类中的类型，才能继承给子类</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果想灵活指定父类中T的类型，子类也需要变为类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    T1 obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt;s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>T1的类型为： int<br>T2的类型为： char</p>
</blockquote>
<h2 id="类模板成员函数类外实现"><a href="#类模板成员函数类外实现" class="headerlink" title="类模板成员函数类外实现"></a>类模板成员函数类外实现</h2><p>学习目标：能够掌握类模板中的成员函数的类外实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;  年龄： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">P</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    P.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名： Tom  年龄： 20</p>
</blockquote>
<h2 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h2><p>掌握类模板成员函数分文件编写产生的问题以及解决方式</p>
<p>问题：</p>
<ul>
<li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li>
</ul>
<p>解决：</p>
<ul>
<li><p>解决方式1：直接包含.cpp源文件</p>
</li>
<li><p>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</p>
</li>
</ul>
<img src="/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/分文件编写.png" title alt data-align="center">

<p><strong>person.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>test.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//第一种解决方式，直接包含源文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;person.cpp&quot;</span></span></span><br><span class="line"><span class="comment">//第二种解决方式，将.h和.cpp中的内容写到一起，将文件命名为.hpp文件</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板份分文件编写问题以及解决</span></span><br><span class="line"><span class="comment">//template&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="comment">//class Person</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">//    Person(T1 name, T2 age);</span></span><br><span class="line"><span class="comment">//    void showPerson();</span></span><br><span class="line"><span class="comment">//    T1 m_Name;</span></span><br><span class="line"><span class="comment">//    T2 m_Age;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//template&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="comment">//Person&lt;T1, T2&gt;::Person(T1 name, T2 age)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    this-&gt;m_Name = name;</span></span><br><span class="line"><span class="comment">//    this-&gt;m_Age = age;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//template&lt;class T1,class T2&gt;</span></span><br><span class="line"><span class="comment">//void Person&lt;T1,T2&gt;::showPerson()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Jerry&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>person.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;person.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">	<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h2><p>掌握类模板配合友元函数的类内和类外实现</p>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//通过全局函数 打印Person信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提前让编译器知道Person类存在</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外实现</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;类外实现 -- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//全局函数 类内实现</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;T1, T2&gt; p)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//全局函数 类外实现</span></span><br><span class="line">	<span class="comment">//加空模板参数列表</span></span><br><span class="line">	<span class="comment">//如果全局函数是类外实现，需要让编译器提前知道这个函数的存在</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T1 m_Name;</span><br><span class="line">	T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名： Tom 年龄： 20<br>类外实现 – 姓名： Tom 年龄： 20</p>
</blockquote>
<h2 id="类模板案例"><a href="#类模板案例" class="headerlink" title="类模板案例"></a>类模板案例</h2><p>实现一个通用的数组类，要求如下：</p>
<ul>
<li><p>可以对内置的数据类型以及自定义数据类型的数据进行存储</p>
</li>
<li><p>将数组中的数据存储到堆区</p>
</li>
<li><p>构造函数中可以传入数组的容量</p>
</li>
<li><p>提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题</p>
</li>
<li><p>提供尾插法和尾删法对数组中的数据进行增加和删除</p>
</li>
<li><p>可以通过下标的方式访问数组中的元素</p>
</li>
<li><p>可以获取数组中当前元素个数和数组的容量</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyArray.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line">	<span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	string m_Name;</span><br><span class="line">	<span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].m_Age &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyArray&lt;<span class="type">int</span>&gt;<span class="built_in">arr1</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr1的打印输出为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(arr1);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr1的容量为： &quot;</span> &lt;&lt; arr1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr1的大小为： &quot;</span> &lt;&lt; arr1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	MyArray&lt;<span class="type">int</span>&gt;<span class="built_in">arr2</span>(arr1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr2的打印输出为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(arr2);</span><br><span class="line">	<span class="comment">//尾删</span></span><br><span class="line">	arr2.<span class="built_in">pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr2尾删后的打印输出为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printIntArray</span>(arr2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	MyArray&lt;<span class="type">int</span>&gt;<span class="built_in">arr3</span>(<span class="number">100</span>);</span><br><span class="line">	arr3 = arr1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MyArray&lt;Person&gt;<span class="built_in">arr</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">999</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">700</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line">	<span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line">	<span class="comment">//将数据插入到数组中</span></span><br><span class="line">	arr.<span class="built_in">push_back</span>(p1);</span><br><span class="line">	arr.<span class="built_in">push_back</span>(p2);</span><br><span class="line">	arr.<span class="built_in">push_back</span>(p3);</span><br><span class="line">	arr.<span class="built_in">push_back</span>(p4);</span><br><span class="line">	arr.<span class="built_in">push_back</span>(p5);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr的打印输出为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printPersonArray</span>(arr);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr的容量为： &quot;</span> &lt;&lt; arr.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr的大小为： &quot;</span> &lt;&lt; arr.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">	arr.<span class="built_in">pop_back</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;arr尾删后的打印输出为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">printPersonArray</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>();</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>MyArray的有参构造调用<br>arr1的打印输出为：<br>0<br>1<br>2<br>3<br>4<br>arr1的容量为： 5<br>arr1的大小为： 5<br>MyArray的拷贝构造调用<br>arr2的打印输出为：<br>0<br>1<br>2<br>3<br>4<br>arr2尾删后的打印输出为：<br>0<br>1<br>2<br>3<br>MyArray的有参构造调用<br>MyArray的operator&#x3D;调用<br>MyArray的析构函数调用<br>MyArray的析构函数调用<br>MyArray的析构函数调用<br>MyArray的有参构造调用<br>arr的打印输出为：<br>姓名： 刘备 年龄： 999<br>姓名： 关羽 年龄： 800<br>姓名： 张飞 年龄： 700<br>姓名： 赵云 年龄： 800<br>姓名： 诸葛亮 年龄： 800<br>arr的容量为： 10<br>arr的大小为： 5<br>arr尾删后的打印输出为：<br>姓名： 刘备 年龄： 999<br>姓名： 关羽 年龄： 800<br>姓名： 张飞 年龄： 700<br>姓名： 赵云 年龄： 800<br>MyArray的析构函数调用</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 结构体</title>
    <url>/2023/04/10/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h1 id="结构体的基本概念"><a href="#结构体的基本概念" class="headerlink" title="结构体的基本概念"></a>结构体的基本概念</h1><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p>
<h1 id="结构体的定义和使用"><a href="#结构体的定义和使用" class="headerlink" title="结构体的定义和使用"></a>结构体的定义和使用</h1><p>语法： struct 结构体名（结构体成员列表）；</p>
<p>通过结构体创建变量的方式有三种：</p>
<ul>
<li><p>struct 结构体名 变量名</p>
</li>
<li><p>struct 结构体名 变量名 &#x3D; {成员1值 ， 成员2值…}</p>
</li>
<li><p>定义结构体时顺便创建变量</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;s3;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> s1;</span><br><span class="line">    s1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    s1.age = <span class="number">15</span>;</span><br><span class="line">    s1.score = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; s1.name &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; s1.age &lt;&lt; <span class="string">&quot;成绩： &quot;</span> &lt;&lt; s1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> s2 = &#123; <span class="string">&quot;李四&quot;</span> , <span class="number">16</span> , <span class="number">90</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; s2.name &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; s2.age &lt;&lt; <span class="string">&quot;成绩： &quot;</span> &lt;&lt; s2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    s3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">    s3.age = <span class="number">17</span>;</span><br><span class="line">    s3.score = <span class="number">85</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; s3.name &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; s3.age &lt;&lt; <span class="string">&quot;成绩： &quot;</span> &lt;&lt; s3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>姓名： 张三年龄： 15成绩： 100<br>姓名： 李四年龄： 16成绩： 90<br>姓名： 王五年龄： 17成绩： 85</p>
</blockquote>
<h1 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h1><p>作用：将自定义的结构体放入到数组中方便维护</p>
<p>语法：struct 结构体 数组名[元素个数] &#x3D; { {} ， {} ，… ，{} }</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> stuArray[<span class="number">3</span>] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;李四&quot;</span>, <span class="number">19</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>, <span class="number">85</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    stuArray[<span class="number">2</span>].name = <span class="string">&quot;赵六&quot;</span>;</span><br><span class="line">    stuArray[<span class="number">2</span>].age = <span class="number">15</span>;</span><br><span class="line">    stuArray[<span class="number">2</span>].score = <span class="number">95</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; stuArray[i].name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stuArray[i].age &lt;&lt; <span class="string">&quot; 分数： &quot;</span> &lt;&lt; stuArray[i].score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>姓名： 张三 年龄： 18 分数： 100<br>姓名： 李四 年龄： 19 分数： 90<br>姓名： 赵六 年龄： 15 分数： 95</p>
</blockquote>
<h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><p>作用：通过指针访问结构体中的成员</p>
<ul>
<li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> s = &#123; <span class="string">&quot;张三&quot;</span> , <span class="number">16</span> , <span class="number">98</span> &#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数： &quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名： 张三 年龄： 16 分数： 98</p>
</blockquote>
<h1 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h1><p>作用：结构体中的成员可以是另一个结构体</p>
<p>例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> stu;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">teacher</span> t;</span><br><span class="line">    t.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    t.id = <span class="number">100</span>;</span><br><span class="line">    t.age = <span class="number">45</span>;</span><br><span class="line">    t.stu.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    t.stu.age = <span class="number">16</span>;</span><br><span class="line">    t.stu.score = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;老师的姓名：&quot;</span> &lt;&lt; t.name &lt;&lt; <span class="string">&quot; 老师的id：&quot;</span> &lt;&lt; t.id &lt;&lt; <span class="string">&quot; 老师的年龄：&quot;</span> &lt;&lt; t.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;老师指导的学生的姓名：&quot;</span> &lt;&lt; t.stu.name &lt;&lt; <span class="string">&quot; 学生的年龄： &quot;</span> &lt;&lt; t.stu.age &lt;&lt; <span class="string">&quot; 学生的成绩：&quot;</span> &lt;&lt; t.stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>老师的姓名：张三 老师的id：100 老师的年龄：45<br>老师指导的学生的姓名：李四 学生的年龄： 16 学生的成绩：100</p>
</blockquote>
<h1 id="结构体做函数参数"><a href="#结构体做函数参数" class="headerlink" title="结构体做函数参数"></a>结构体做函数参数</h1><p>作用：将结构体作为参数向函数中传递</p>
<p>传递方式有两种：</p>
<ul>
<li><p>值传递</p>
</li>
<li><p>地址传递</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStu1</span><span class="params">(<span class="keyword">struct</span> student s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    s.age = <span class="number">19</span>;</span><br><span class="line">    s.score = <span class="number">90</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子函数1中学生姓名：&quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; s.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStu2</span><span class="params">(<span class="keyword">struct</span> student* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    p-&gt;age = <span class="number">19</span>;</span><br><span class="line">    p-&gt;score = <span class="number">90</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;子函数2中学生姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> s = &#123;  <span class="string">&quot;张三&quot;</span> , <span class="number">16</span>  , <span class="number">100</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main函数中学生姓名：&quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; s.score &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintStu1</span>(s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main函数中学生姓名：&quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; s.score &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PrintStu2</span>(&amp;s);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main函数中学生姓名：&quot;</span> &lt;&lt; s.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; s.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; s.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>main函数中学生姓名：张三 年龄：16 分数：100<br>子函数1中学生姓名：李四 年龄：19 分数：90<br>main函数中学生姓名：张三 年龄：16 分数：100<br>子函数2中学生姓名：李四 年龄：19 分数：90<br>main函数中学生姓名：李四 年龄：19 分数：90</p>
</blockquote>
<h1 id="结构体中const的使用场景"><a href="#结构体中const的使用场景" class="headerlink" title="结构体中const的使用场景"></a>结构体中const的使用场景</h1><p>作用：用const来防止误操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> </span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStu</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> student * s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s-&gt;name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> s = &#123;  <span class="string">&quot;张三&quot;</span> , <span class="number">16</span>  , <span class="number">100</span> &#125;;</span><br><span class="line">    <span class="built_in">PrintStu</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2023/04/10/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%93%E6%9E%84%E4%BD%93/Error.png"></p>
<p>程序报错，不能修改</p>
<h1 id="结构体案例一"><a href="#结构体案例一" class="headerlink" title="结构体案例一"></a>结构体案例一</h1><p>案例描述：<br>学校正在做毕设项目，每名老师带领五个学生，总共有三名老师，需求如下</p>
<p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放五名学生的数组作为成员</p>
<p>学生的成员有姓名、考试分数，创建数组存放三名老师，通过函数给每个老师及所带学生的学生数赋值</p>
<p>最终打印出老师数据以及老师所带学生的数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> </span><br><span class="line">&#123;</span><br><span class="line">    string sname;</span><br><span class="line">    <span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    string tname;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">student</span> stuArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inAll</span><span class="params">(<span class="keyword">struct</span> teacher * s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入老师的姓名：&quot;</span>);</span><br><span class="line">    cin &gt;&gt; s-&gt;tname;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n请输入第%d位同学的姓名和成绩&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">        cin&gt;&gt;s-&gt;stuArray[i].sname&gt;&gt;s-&gt;stuArray[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outAll</span><span class="params">(<span class="keyword">struct</span> teacher t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;老师的姓名&quot;</span> &lt;&lt; t.tname &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;学生&quot;</span> &lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;姓名为：&quot;</span>&lt;&lt; t.stuArray[i].sname &lt;&lt; <span class="string">&quot; 成绩为：&quot;</span> &lt;&lt; t.stuArray[i].score &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">teacher</span> tArray[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inAll</span>(&amp;tArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">outAll</span>(tArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>请输入老师的姓名：老师1</p>
<p>请输入第1位同学的姓名和成绩学生11 90</p>
<p>请输入第2位同学的姓名和成绩学生12 90</p>
<p>请输入第3位同学的姓名和成绩学生13 80</p>
<p>请输入第4位同学的姓名和成绩学生14 79</p>
<p>请输入第5位同学的姓名和成绩学生15 98<br>请输入老师的姓名：老师2</p>
<p>请输入第1位同学的姓名和成绩学生21 80</p>
<p>请输入第2位同学的姓名和成绩学生22 79</p>
<p>请输入第3位同学的姓名和成绩学生23 80</p>
<p>请输入第4位同学的姓名和成绩学生24 79</p>
<p>请输入第5位同学的姓名和成绩学生25 90<br>请输入老师的姓名：老师3</p>
<p>请输入第1位同学的姓名和成绩学生31 90</p>
<p>请输入第2位同学的姓名和成绩学生32 89</p>
<p>请输入第3位同学的姓名和成绩学生33 79</p>
<p>请输入第4位同学的姓名和成绩学生34 80</p>
<p>请输入第5位同学的姓名和成绩学生35 98<br>老师的姓名老师1<br>学生1姓名为：学生11 成绩为：90<br>学生2姓名为：学生12 成绩为：90<br>学生3姓名为：学生13 成绩为：80<br>学生4姓名为：学生14 成绩为：79<br>学生5姓名为：学生15 成绩为：98<br>老师的姓名老师2<br>学生1姓名为：学生21 成绩为：80<br>学生2姓名为：学生22 成绩为：79<br>学生3姓名为：学生23 成绩为：80<br>学生4姓名为：学生24 成绩为：79<br>学生5姓名为：学生25 成绩为：90<br>老师的姓名老师3<br>学生1姓名为：学生31 成绩为：90<br>学生2姓名为：学生32 成绩为：89<br>学生3姓名为：学生33 成绩为：79<br>学生4姓名为：学生34 成绩为：80<br>学生5姓名为：学生35 成绩为：98</p>
</blockquote>
<h1 id="结构体案例二"><a href="#结构体案例二" class="headerlink" title="结构体案例二"></a>结构体案例二</h1><p>案例描述：</p>
<p>设计一个英雄的结构体，包括成员姓名，年龄，性别：创建结构体数组，数组中存放五名英雄。</p>
<p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hero</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Hero</span> heroArray[<span class="number">5</span>] =</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;<span class="string">&quot;刘备&quot;</span>, <span class="number">21</span>, <span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">        &#123; <span class="string">&quot;关羽&quot;</span>,<span class="number">19</span>,<span class="string">&quot;男&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;张飞&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;赵云&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span> &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;黄忠&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(heroArray) / <span class="built_in">sizeof</span>(heroArray[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (heroArray[j+<span class="number">1</span>].age &gt; heroArray[j].age)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">Hero</span> temp = heroArray[j];</span><br><span class="line">                heroArray[j] = heroArray[j+<span class="number">1</span>];</span><br><span class="line">                heroArray[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; heroArray[i].name &lt;&lt; heroArray[i].age &lt;&lt; heroArray[i].sex &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>张飞23男<br>刘备21男<br>赵云20男<br>关羽19男<br>黄忠18男</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 类与对象</title>
    <url>/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>C++面向对象三大特性：封装、继承、多态</p>
<p>C++认为万事万物都皆为对象，对象上有其属性和行为</p>
<p>例如：</p>
<p>人可以作为对象，属性有姓名、年龄、身高、体重…..，行为有走、跑、跳……</p>
<p>具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><p>封装是C++面向对象三大特性之一</p>
<p>封装的意义：</p>
<ul>
<li><p>将属性和行为作为一个整体，表现生活中的事物</p>
</li>
<li><p>将属性和行为加以权限控制</p>
</li>
</ul>
<h3 id="封装的意义一"><a href="#封装的意义一" class="headerlink" title="封装的意义一"></a>封装的意义一</h3><p>在设计类的时候，属性和行为写在一起，表现事物</p>
<p>语法：<code>class 类名 &#123; 访问权限 : 属性 / 行为 &#125;;</code></p>
<p>示例一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//设计一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//圆求周长的公式：2*PI*半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//class代表设计一个类，类后面紧跟着的就是类名称</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//半径</span></span><br><span class="line">    <span class="type">int</span> m_r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//获取圆的周长</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * PI * m_r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过圆类 创建具体的圆 （对象）</span></span><br><span class="line">    Circle c1;</span><br><span class="line">    <span class="comment">//给圆对象的属性进行赋值</span></span><br><span class="line">    c1.m_r = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;圆的周长为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>圆的周长为：62.8</p>
</blockquote>
<p>示例二：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"><span class="comment">//设计一个学生类，属性具有姓名和学号</span></span><br><span class="line"><span class="comment">//可以给姓名和学号赋值，可以显示学生的姓名和学号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//访问权限</span></span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//姓名和学号</span></span><br><span class="line">    string m_Name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="type">int</span> m_id;<span class="comment">//学号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//显示姓名和学号</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给姓名赋值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setId</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个具体学生 实例化对象</span></span><br><span class="line">    Student s1;</span><br><span class="line">    Student s2;</span><br><span class="line">    <span class="comment">//给S1对象 进行属性复制操作</span></span><br><span class="line">    s1.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    s1.<span class="built_in">setId</span>(<span class="number">1</span>);</span><br><span class="line">    s2.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    s2.m_id = <span class="number">2</span>;</span><br><span class="line">    s1.<span class="built_in">showStudent</span>();</span><br><span class="line">    s2.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名： 张三 学号：1<br>姓名： 李四 学号：2</p>
</blockquote>
<h3 id="封装的意义二"><a href="#封装的意义二" class="headerlink" title="封装的意义二"></a>封装的意义二</h3><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p>
<p>访问权限有三种：</p>
<ul>
<li><p>public    公共权限</p>
</li>
<li><p>protected    保护权限</p>
</li>
<li><p>private    私有权限</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问权限</span></span><br><span class="line"><span class="comment">//三种</span></span><br><span class="line"><span class="comment">//公共权限 public        成员 类内可以访问    类外可以访问    </span></span><br><span class="line"><span class="comment">//保护权限 protected    成员 类内可以访问    类外不可以访问    儿子也可以访问父亲中的保护内容</span></span><br><span class="line"><span class="comment">//私有权限 private        成员 类内可以访问    类外不可以访问    儿子不可以访问父亲中的私有内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_Name;<span class="comment">//姓名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">//保护权限</span></span><br><span class="line">    string m_Car;<span class="comment">//汽车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//私有权限</span></span><br><span class="line">    <span class="type">int</span> m_Password;<span class="comment">//银行卡密码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">        m_Password = <span class="number">123456</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实例化具体对象</span></span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    p1.m_Car = <span class="string">&quot;奔驰&quot;</span>;</span><br><span class="line">    p1.m_Password = <span class="number">654321</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/Error1.png" title alt data-align="center">

<p><img src="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/Error2.png"></p>
<h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><p>在C++中struct和class唯一的区别就在于默认的访问权限不同</p>
<p>区别：</p>
<ul>
<li><p>struct权限默认为公共</p>
</li>
<li><p>class权限默认为私有</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C1 c1;</span><br><span class="line">    c1.m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    C2 c2;</span><br><span class="line">    c2.m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/Error3.png" title alt data-align="center">

<h2 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h2><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员属性设置为私有</span></span><br><span class="line"><span class="comment">//1、可以自己控制读写权限</span></span><br><span class="line"><span class="comment">//2、对于写可以检测数据的有效性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄 只读</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Age = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置情人 只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//姓名    可读可写</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//年龄    只读</span></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="comment">//情人    只写</span></span><br><span class="line">    string m_Lover;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名为： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">//无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名为： 张三<br>年龄为：0</p>
</blockquote>
<p>优点2：对于写权限，我们可以检测数据的有效性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员属性设置为私有</span></span><br><span class="line"><span class="comment">//1、可以自己控制读写权限</span></span><br><span class="line"><span class="comment">//2、对于写可以检测数据的有效性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取年龄 可读可写 如果想修改（年龄的范围必须是0~150之间）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置名字 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt;<span class="number">150</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;年龄错误&quot;</span> &lt;&lt; endl; </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置情人 只写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Lover = lover;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//姓名    可读可写</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//年龄    只读</span></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="comment">//情人    只写</span></span><br><span class="line">    string m_Lover;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;姓名为： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setAge</span>(<span class="number">1000</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年龄为：&quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">setLover</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">//无法访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>姓名为： 张三<br>年龄错误<br>年龄为：-858993460</p>
</blockquote>
<h2 id="练习案例一"><a href="#练习案例一" class="headerlink" title="练习案例一"></a>练习案例一</h2><p>设计立方体类（Cube）</p>
<p>求出立方体的面积和体积</p>
<p>分别用全局函数和成员函数判断两个立方体是否相等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//立方体类设计</span></span><br><span class="line"><span class="comment">//1、创建立方体类</span></span><br><span class="line"><span class="comment">//2、创建属性</span></span><br><span class="line"><span class="comment">//3、设计行为 获取立方体面积和体积</span></span><br><span class="line"><span class="comment">//4、分别利用全局函数和成员函数 判断两个立方体是否相等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cube</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="comment">//设置获取长宽高</span></span><br><span class="line">    <span class="comment">// 设置长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setL</span><span class="params">(<span class="type">int</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_L = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取长</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getL</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置宽</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_W = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取宽</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getW</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置高</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setH</span><span class="params">(<span class="type">int</span> H)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_H = H;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">// 获取高</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getH</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取立方体面积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateS</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * m_L * m_W + <span class="number">2</span> * m_L * m_H + <span class="number">2</span> * m_W * m_H;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取立方体体积</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateV</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_L * m_H * m_W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用成员函数判断两个立方体是否相等</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameByClass</span><span class="params">(Cube&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getL</span>() == c.<span class="built_in">getL</span>() &amp;&amp; <span class="built_in">getW</span>() == c.<span class="built_in">getW</span>() &amp;&amp; <span class="built_in">getH</span>() == c.<span class="built_in">getH</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_L;<span class="comment">//长</span></span><br><span class="line">    <span class="type">int</span> m_W;<span class="comment">//宽</span></span><br><span class="line">    <span class="type">int</span> m_H;<span class="comment">//高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用全局函数判断 两个立方体是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(Cube&amp; c1, Cube&amp; c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c1.<span class="built_in">getL</span>() == c2.<span class="built_in">getL</span>() &amp;&amp; c1.<span class="built_in">getW</span>() == c2.<span class="built_in">getW</span>() &amp;&amp; c1.<span class="built_in">getH</span>() == c2.<span class="built_in">getH</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建立方体对象</span></span><br><span class="line">    Cube c1;</span><br><span class="line">    c1.<span class="built_in">setL</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">setW</span>(<span class="number">10</span>);</span><br><span class="line">    c1.<span class="built_in">setH</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1的面积为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculateS</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c1的体积为：&quot;</span> &lt;&lt; c1.<span class="built_in">calculateV</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建第二个立方体对象</span></span><br><span class="line">    Cube c2;</span><br><span class="line">    c2.<span class="built_in">setL</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">setW</span>(<span class="number">10</span>);</span><br><span class="line">    c2.<span class="built_in">setH</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2的面积为：&quot;</span> &lt;&lt; c2.<span class="built_in">calculateS</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c2的体积为：&quot;</span> &lt;&lt; c2.<span class="built_in">calculateV</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//利用全局函数判断</span></span><br><span class="line">    <span class="type">bool</span> ret = <span class="built_in">isSame</span>(c1, c2);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用成原函数判断</span></span><br><span class="line">    ret = c1.<span class="built_in">isSameByClass</span>(c2);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c1和c2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>c1的面积为：600<br>c1的体积为：1000<br>c2的面积为：600<br>c2的体积为：1000<br>c1和c2是相等的<br>c1和c2是相等的</p>
</blockquote>
<h2 id="练习案例二"><a href="#练习案例二" class="headerlink" title="练习案例二"></a>练习案例二</h2><p>设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点与圆的关系案例</span></span><br><span class="line"><span class="comment">// 点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置x</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取x</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置y</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取y</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_X;</span><br><span class="line">    <span class="type">int</span> m_Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//设置半径</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setR</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_R = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取半径</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getR</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置圆心</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCenter</span><span class="params">(Point center)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_Center = center;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">getCenter</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Center;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_R;<span class="comment">//半径</span></span><br><span class="line">    Point m_Center;<span class="comment">//圆心</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断点和圆的关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isInCircle</span><span class="params">(Circle&amp; c, Point&amp; p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算两点之间距离的平方</span></span><br><span class="line">    <span class="type">int</span> distance =</span><br><span class="line">        (c.<span class="built_in">getCenter</span>().<span class="built_in">getX</span>() - p.<span class="built_in">getX</span>()) * (c.<span class="built_in">getCenter</span>().<span class="built_in">getX</span>() - p.<span class="built_in">getX</span>()) +</span><br><span class="line">        (c.<span class="built_in">getCenter</span>().<span class="built_in">getY</span>() - p.<span class="built_in">getY</span>()) * (c.<span class="built_in">getCenter</span>().<span class="built_in">getY</span>() - p.<span class="built_in">getY</span>());</span><br><span class="line">    <span class="comment">//计算半径的平方</span></span><br><span class="line">    <span class="type">int</span> rDistance = c.<span class="built_in">getR</span>() * c.<span class="built_in">getR</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断关系</span></span><br><span class="line">    <span class="keyword">if</span> (distance == rDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆上&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (distance &gt; rDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆外&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;点在圆内&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建圆</span></span><br><span class="line">    Circle c;</span><br><span class="line">    c.<span class="built_in">setR</span>(<span class="number">10</span>);</span><br><span class="line">    Point center;</span><br><span class="line">    center.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    center.<span class="built_in">setY</span>(<span class="number">0</span>);</span><br><span class="line">    c.<span class="built_in">setCenter</span>(center);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建点</span></span><br><span class="line">    Point p;</span><br><span class="line">    p.<span class="built_in">setX</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">setY</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断关系</span></span><br><span class="line">    <span class="built_in">isInCircle</span>(c, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>点在圆上</p>
</blockquote>
<h1 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h1><ul>
<li><p>生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除一些自己的信息数据保证安全</p>
</li>
<li><p>C++中的面向对象来自于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置</p>
</li>
</ul>
<h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><p>对象的初始化和清理也是两个非常重要的安全问题</p>
<p>一个对象或者变量没有初始状态，对其使用后果是未知</p>
<p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的问题</p>
<p>C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p>
<p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现</p>
<ul>
<li><p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</p>
</li>
<li><p>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作</p>
</li>
</ul>
<p>构造函数语法：<code>类名（）&#123;&#125;</code></p>
<p>1、构造函数：没有返回值也不写void</p>
<p>2、函数名称与类名相同</p>
<p>3、构造函数可以有参数，因此可以发生重载</p>
<p>4、程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次</p>
<p>析构函数语法：<code>~类名（）&#123;&#125;</code></p>
<p>1、析构函数：没有返回值也不写void</p>
<p>2、函数名称与类名相同，在名称前加上符号~</p>
<p>3、析构函数不可以有参数，因此不可以发生重载</p>
<p>4、程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的初始化和清理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1 构造函数</span></span><br><span class="line">    <span class="comment">//没有返回值 不用写void</span></span><br><span class="line">    <span class="comment">//函数名与类名相同</span></span><br><span class="line">    <span class="comment">//构造函数可以有参数可以发生重载</span></span><br><span class="line">    <span class="comment">//创建对象的时候，构造函数会自动调用，而且只调用一次</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 析构函数</span></span><br><span class="line">    <span class="comment">//没有返回值 不写void</span></span><br><span class="line">    <span class="comment">//函数名和类名相同 在名称前加~</span></span><br><span class="line">    <span class="comment">//析构函数不可以有参数，不可以发生重载</span></span><br><span class="line">    <span class="comment">//对象在销毁前，会自动调用析构函数</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构函数的调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;<span class="comment">//在栈上的数据，test01执行完毕之后，释放这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person构造函数的调用<br>Person析构函数的调用</p>
</blockquote>
<h2 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h2><p>两种分类方式：</p>
<ul>
<li><p>按参数分为：有参数构造和无参数构造</p>
</li>
<li><p>按类型分为：普通构造和拷贝构造</p>
</li>
</ul>
<p>三种调用方式：</p>
<ul>
<li><p>括号法</p>
</li>
<li><p>显式法</p>
</li>
<li><p>隐式转换法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将传入的人的身上的所有属性，拷贝到我身上</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、括号法</span></span><br><span class="line">    Person p1  ;<span class="comment">//默认构造函数的调用</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="comment">//拷贝构造函数调用</span></span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    <span class="comment">//注意事项</span></span><br><span class="line">    <span class="comment">//调用默认构造函数的时候，不要加（）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; p3.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person的无参构造函数调用<br>Person的有参构造函数调用<br>Person的拷贝函数调用<br>p2的年龄为：10<br>p3的年龄为：10<br>Person的析构函数调用<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将传入的人的身上的所有属性，拷贝到我身上</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2、显示法</span></span><br><span class="line">    Person p1;</span><br><span class="line">    Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//有参构造</span></span><br><span class="line">    Person p3 = <span class="built_in">Person</span>(p2);<span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="number">10</span>);<span class="comment">//匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象</span></span><br><span class="line"><span class="comment">//注意事项：不要利用拷贝构造函数 初始化匿名对象 编译器会认为是对象声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person的无参构造函数调用<br>Person的有参构造函数调用<br>Person的拷贝函数调用<br>Person的有参构造函数调用<br>Person的析构函数调用<br>Person的析构函数调用<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的无参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将传入的人的身上的所有属性，拷贝到我身上</span></span><br><span class="line">        age = p.age;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//3、隐式转换法</span></span><br><span class="line">    Person p4 = <span class="number">10</span>;</span><br><span class="line">    Person p5 = p4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Person的有参构造函数调用<br>Person的拷贝函数调用<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h2><p>C++中拷贝构造函数调用时机通常有三种情况</p>
<ul>
<li><p>使用一个以及创建完毕的对象来初始化一个新对象</p>
</li>
<li><p>值传递的方式给函数参数传值</p>
</li>
<li><p>以值方式返回局部对象</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造函数调用时机</span></span><br><span class="line"><span class="comment">//1、使用一个已经创建完毕的对象来初始化一个对象</span></span><br><span class="line"><span class="comment">//2、值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//3、值方式返回局部对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、使用一个已经创建完毕的对象来初始化一个对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、值传递的方式给函数参数传值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork1</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="built_in">doWork1</span>(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test01()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test02()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test03()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>test01()<br>Person有参构造函数调用<br>Person拷贝构造函数调用<br>p2的年龄为：20<br>Person析构函数调用<br>Person析构函数调用<br>test02()<br>Person默认构造函数调用<br>Person拷贝构造函数调用<br>Person析构函数调用<br>Person析构函数调用<br>test03()<br>Person默认构造函数调用<br>Person拷贝构造函数调用<br>Person析构函数调用<br>Person析构函数调用</p>
</blockquote>
<h2 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h2><p>  默认情况下，C++编译器至少给一个类添加3个函数</p>
<p>1、默认构造函数（无参，函数体为空）</p>
<p>2、默认析构函数（无参，函数体为空）</p>
<p>3、默认拷贝函数，对属性进行值拷贝</p>
<p>构造函数调用规则如下：</p>
<ul>
<li><p>如果用户定义有参构造函数，C++不在提供默认无参构造，但会提供默认拷贝构造</p>
</li>
<li><p>如果用户定义拷贝构造函数，C++不会在提供其他构造函数</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数调用规则</span></span><br><span class="line"><span class="comment">//1、创建一个类，C++编译器会给每个类都添加至少3个函数</span></span><br><span class="line"><span class="comment">//默认构造（空实现）</span></span><br><span class="line"><span class="comment">//析构函数（空实现）</span></span><br><span class="line"><span class="comment">//拷贝构造（值拷贝）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Person(const Person&amp; p)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl;   </span></span><br><span class="line"><span class="comment">        m_Age = p.m_Age;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.m_Age = <span class="number">18</span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>Person的默认构造函数调用<br>p2的年龄为：18<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<p>如果利用编译器提供的拷贝构造函数，会做浅拷贝操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝与浅拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构代码，将堆区开辟的数据做释放操作</span></span><br><span class="line">        <span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Height;</span><br><span class="line">            m_Height = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="type">int</span>* m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行发生错误</p>
<p>浅拷贝会带来堆区的内存重复释放</p>
<p>要自己实现拷贝构造函数，解决浅拷贝带来的问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝与浅拷贝</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的默认构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age, <span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = age;</span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的有参构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_Age = p.m_Age;</span><br><span class="line">        <span class="comment">//编译器默认实现m_Height = p.m_Height;</span></span><br><span class="line">        <span class="comment">//深拷贝操作</span></span><br><span class="line">        m_Height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Height);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//析构代码，将堆区开辟的数据做释放操作</span></span><br><span class="line">        <span class="keyword">if</span> (m_Height != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Height;</span><br><span class="line">            m_Height = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="type">int</span>* m_Height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; p1.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p1.m_Height &lt;&lt; endl;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; p2.m_Age &lt;&lt; <span class="string">&quot; 身高为：&quot;</span> &lt;&lt; *p2.m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<blockquote>
<p>Person的有参构造函数调用<br>p1的年龄为：18 身高为：160<br>Person的拷贝构造函数调用<br>p2的年龄为：18 身高为：160<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h2><p>作用：C++提供了初始化列表语法，用来初始化属性     </p>
<p>语法：构造函数（）：属性1（值1），属性2（值2）…{}</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">////传统初始化操作</span></span><br><span class="line">    <span class="comment">//Person(int a, int b, int c)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    m_A = a;</span></span><br><span class="line">    <span class="comment">//    m_B = b;</span></span><br><span class="line">    <span class="comment">//    m_C = c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//初始化列表初始化属性</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(a), <span class="built_in">m_C</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_B = &quot;</span> &lt;&lt; p.m_B &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_C = &quot;</span> &lt;&lt; p.m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>m_A &#x3D; 10<br>m_B &#x3D; 10<br>m_C &#x3D; 30</p>
</blockquote>
<h2 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h2><p>C++类中的成员可以是另一个类的对象，我们称该成员为对象成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类对象作为类成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string pName)</span><br><span class="line">    &#123;</span><br><span class="line">        m_PName = pName;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Phone</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_PName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="comment">//手机</span></span><br><span class="line">    Phone m_Phone;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当其他类对象作为本类成员，构造事先构造类对象，再构造自身,析构顺序与构造相反</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;iphone&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;的手机是&quot;</span> &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Phone的构造函数调用<br>Person的构造函数调用<br>张三的手机是iphone<br>Person的析构函数调用<br>Person的析构函数调用</p>
</blockquote>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p>
<p>静态成员分为：</p>
<ul>
<li><p>静态成员变量</p>
<ul>
<li><p>所有对象共享同一份数据</p>
</li>
<li><p>在编译阶段分配内存</p>
</li>
<li><p>类内声明，类外初始化</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1、所有对象都共享同一份数据</span></span><br><span class="line">    <span class="comment">//2、编译阶段就分配内存</span></span><br><span class="line">    <span class="comment">//3、类内声明，类外初始化操作</span></span><br><span class="line">    <span class="comment">//4、私有静态成员变量在类外访问不了</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">200</span>;</span><br><span class="line">    cout &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//静态成员变量 不属于某个对象上，所有对象都共享同一份数据</span></span><br><span class="line">    <span class="comment">//因此静态成员变量有两种访问方式</span></span><br><span class="line">    <span class="comment">//1、通过对象进行访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; p.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//2、通过类名进行访问</span></span><br><span class="line">    cout &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<blockquote>
<p>100<br>200<br>200<br>200</p>
</blockquote>
<ul>
<li><p>静态成员函数</p>
<ul>
<li><p>所有对象共享同一个函数</p>
</li>
<li><p>静态成员函数只能访问静态成员变量</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="comment">//所有对象共享同一个函数</span></span><br><span class="line"><span class="comment">//静态成员函数只能访问静态成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//静态成员函数</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;static void func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;<span class="comment">//静态成员变量</span></span><br><span class="line">    <span class="type">int</span> m_B;<span class="comment">//非静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span><span class="comment">//类外访问不到私有静态成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//有两种访问方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、通过对象访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//2、通过类名访问</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>static void func调用<br>static void func调用</p>
</blockquote>
<h1 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h1><h2 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h2><p>在C++中，类内的成员变量和成员函数分开存储</p>
<p>只有非静态成员变量才属于类的对象上 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    <span class="comment">//空对象占用内存空间为： 1</span></span><br><span class="line">    <span class="comment">//C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置</span></span><br><span class="line">    <span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//非静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 4</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;<span class="comment">//静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 4</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量 和 成员函数 分开存储的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_B;<span class="comment">//静态成员变量 不属于类的对象上</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//非静态成员函数 不属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of p &#x3D; 4</p>
</blockquote>
<h2 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h2><p>通过上述代码我们知道在C++中成员变量喝成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p>
<p>那么问题是：这一块代码是如何区分那个对象调用自己的呢?</p>
<p>C++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<ul>
<li><p>当形参和成员变量同名时，可用this指针来区分</p>
</li>
<li><p>在类的非静态成员函数中返回对象本身，可使用return *this</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1 解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1的年龄为-858993460</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1 解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1的年龄为18</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Person&amp; <span class="title">PersonAddAge</span><span class="params">(Person&amp; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1 解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为&quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="comment">//链式编程 </span></span><br><span class="line">    p2.<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1).<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1的年龄为18<br>p2的年龄为： 50</p>
</blockquote>
<h2 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h2><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p>
<p>如果用到this指针，需要加以判断保证代码的健壮性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//p-&gt;showClassName();</span></span><br><span class="line">    p-&gt;<span class="built_in">showPersonAge</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会运行错误，报错原因是因为传入的指针是NULL</p>
<p>而下述代码不会报错</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">    <span class="comment">//p-&gt;showPersonAge();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将代码修改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//空指针调用成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;this is Person class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age = &quot;</span> &lt;&lt; m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">showClassName</span>();</span><br><span class="line">    p-&gt;<span class="built_in">showPersonAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也不会报错</p>
<h2 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h2><p> <strong>常函数</strong>：</p>
<ul>
<li><p>成员函数后加const后我们称这个函数为常函数</p>
</li>
<li><p>常函数内不可以修改成员属性</p>
</li>
<li><p>成员属性声明时加关键字mutable后，在常函数中依然可以修改</p>
</li>
</ul>
<p><strong>常对象</strong>：</p>
<ul>
<li><p>声明对象前加const称该对象为常对象</p>
</li>
<li><p>常对象只能调用常函数</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 网络编程 socket通信基础</title>
    <url>/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="socket介绍"><a href="#socket介绍" class="headerlink" title="socket介绍"></a>socket介绍</h1><ul>
<li><p>所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p>
</li>
<li><p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。</p>
</li>
<li><p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。</p>
</li>
</ul>
<p><strong>套接字通信分为两部分</strong></p>
<ul>
<li>服务器端：被动接受连接，一般不会主动发起连接</li>
<li>客户端：主动向服务器发起连接</li>
</ul>
<p>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别</p>
<h1 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。</p>
</li>
<li><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。</p>
</li>
<li><p>字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</p>
</li>
</ul>
<h2 id="字节序举例"><a href="#字节序举例" class="headerlink" title="字节序举例"></a>字节序举例</h2><ul>
<li><p>字节(从高到低)：<code>0x 01 02 03 04 12 34 56 78</code></p>
</li>
<li><p>小端字节序，增长方向由低到高</p>
<p><img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/%E5%B0%8F%E6%AE%B5%E5%A2%9E%E9%95%BF.png"></p>
</li>
<li><p>大端字节序，增长方向由低到高</p>
<p><img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%AE%B5%E5%A2%9E%E9%95%BF.png"></p>
</li>
<li><p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字节序：字节在内存中存储的顺序</span></span><br><span class="line"><span class="comment">//小端字节序：数据的高位字节存储在内存的高位地址，低位字节存储在内存的低位地址</span></span><br><span class="line"><span class="comment">//大端字节序：数据的低位字节存储在内存的高位地址，高位字节存储在内存的低位地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代码检测当前主机的字节序</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> bytes[<span class="built_in">sizeof</span>(<span class="type">short</span>)]; <span class="comment">// char[2]</span></span><br><span class="line">    &#125;test;</span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((test.bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((test.bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.bytes[<span class="number">1</span>] == <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未知\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果为小段字节序</p>
</li>
</ul>
<h2 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h2><ul>
<li><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。</p>
</li>
<li><p>网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。</p>
</li>
<li><p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network 网络字节序</span><br><span class="line">s - <span class="type">short</span> <span class="type">unsigned</span> <span class="type">short</span></span><br><span class="line">l - <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//网络通信时，需要将主机字节序转换成网络字节序（大端）</span></span><br><span class="line"><span class="comment">//另外一段获取到数据以后根据情况将网络字节序转换成主机字节序</span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//htons 转换端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, a);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> b = <span class="built_in">htons</span>(a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------\n&quot;</span>);</span><br><span class="line">    <span class="comment">//htonl 转换IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123; <span class="number">192</span>,<span class="number">168</span>,<span class="number">1</span>,<span class="number">100</span> &#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)buf;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">htonl</span>(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">char</span>*)∑</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------------------------\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ntohl 转换IP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf1[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">168</span>,<span class="number">192</span> &#125;;    </span><br><span class="line">    <span class="type">int</span> num1 = *(<span class="type">int</span>*)buf1;</span><br><span class="line">    <span class="type">int</span> sum1 = <span class="built_in">ntohl</span>(num1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p1 = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;sum1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1 + <span class="number">1</span>), *(p1 + <span class="number">2</span>), *(p1 + <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<pre><code>//ntohs
</code></pre>
<p>}</p>
</li>
</ul>
<p>编译运行</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/转换函数.png" title alt data-align="center">

<h1 id="socket地址"><a href="#socket地址" class="headerlink" title="socket地址"></a>socket地址</h1><ul>
<li><p>socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。</p>
</li>
<li><p>客户端 -&gt; 服务器（IP, Port）</p>
</li>
</ul>
<h2 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h2><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span></span><br></pre></td></tr></table></figure>

<p>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：</p>
<table>
<thead>
<tr>
<th align="center">协议族</th>
<th align="center">地址族</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PF_UNIX</td>
<td align="center">AF_UNIX</td>
<td align="center">UNIX本地域协议族</td>
</tr>
<tr>
<td align="center">PF_INET</td>
<td align="center">AF_INET</td>
<td align="center">TCP&#x2F;IPv4协议族</td>
</tr>
<tr>
<td align="center">PF_INET6</td>
<td align="center">AF_INET6</td>
<td align="center">TCP&#x2F;IPv6协议族</td>
</tr>
</tbody></table>
<p>宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</p>
<table>
<thead>
<tr>
<th align="center">协议族</th>
<th align="center">地址值含义和长度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PF_UNIX</td>
<td align="center">文件的路径名，长度可达到108字节</td>
</tr>
<tr>
<td align="center">PF_INET</td>
<td align="center">16bit端口号和32bit IPv4地址，共6字节</td>
</tr>
<tr>
<td align="center">PF_INET6</td>
<td align="center">16bit端口号，32bit流标识，128bit IPv6地址，32bit 范围ID，共26字节</td>
</tr>
</tbody></table>
<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line"><span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="built_in">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h2><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/专用socket地址.png" title alt data-align="center">

<p>UNIX 本地域协议族使用如下专用的 socket 地址结构体：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin_family;</span><br><span class="line"><span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和IPv6：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span><span class="comment">//地址族类型</span></span><br><span class="line"><span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span><span class="comment">//端口号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">/* Internet address. */</span><span class="comment">//IP地址</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span><span class="comment">//填充部分</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line"><span class="built_in">sizeof</span> (<span class="type">in_port_t</span>) - <span class="built_in">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">sa_family_t</span> sin6_family;</span><br><span class="line"><span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr; <span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)</span></span><br></pre></td></tr></table></figure>

<p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地<br>址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</p>
<h1 id="IP地址转换（字符串IP转换成整数、主机网络字节序的转换）"><a href="#IP地址转换（字符串IP转换成整数、主机网络字节序的转换）" class="headerlink" title="IP地址转换（字符串IP转换成整数、主机网络字节序的转换）"></a>IP地址转换（字符串IP转换成整数、主机网络字节序的转换）</h1><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//af:地址族： AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">//src:需要转换的点分十进制的IP字符串</span></span><br><span class="line"><span class="comment">//dst:转换后的结果保存在这个里面</span></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//af:地址族： AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">//src: 要转换的ip的整数的地址</span></span><br><span class="line"><span class="comment">//dst: 转换成IP地址字符串保存的地方</span></span><br><span class="line"><span class="comment">//size：第三个参数的大小（数组的大小）</span></span><br><span class="line"><span class="comment">//返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个IP字符串，点分十进制的IP地址字符串</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, buf, &amp;num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* p = (<span class="type">unsigned</span> <span class="type">char</span>*)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p + <span class="number">1</span>), *(p + <span class="number">2</span>), *(p + <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line">    <span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="built_in">inet_ntop</span>(AF_INET, &amp;num, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ip == str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果如下：</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/IP地址转换.png" title alt data-align="center">

<h1 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>是否创建连接</strong></td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td align="center"><strong>是否可靠</strong></td>
<td align="center">不可靠</td>
<td align="center">可靠</td>
</tr>
<tr>
<td align="center"><strong>连接的对象个数</strong></td>
<td align="center">一对一、一对多、多对一、多对多</td>
<td align="center">支持一对一</td>
</tr>
<tr>
<td align="center"><strong>传输的方式</strong></td>
<td align="center">面向数据报</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center"><strong>首部开销</strong></td>
<td align="center">8个字节</td>
<td align="center">最少20个字节</td>
</tr>
<tr>
<td align="center"><strong>适用场景</strong></td>
<td align="center">实时应用（视频会议，直播）</td>
<td align="center">可靠性高的应用（文件传输）</td>
</tr>
</tbody></table>
<hr>
<img title src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP通信.png" alt data-align="center">

<h2 id="TCP通信的流程"><a href="#TCP通信的流程" class="headerlink" title="TCP通信的流程"></a>TCP通信的流程</h2><p><strong>服务器端</strong></p>
<ol>
<li><strong>创建一个用于监听的套接字</strong></li>
</ol>
<ul>
<li>监听：监听有客户端的连接</li>
<li>套接字：这个套接字其实就是一个文件描述符</li>
</ul>
<ol start="2">
<li><strong>将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</strong></li>
</ol>
<ul>
<li>客户端连接服务器的时候使用的就是这个IP和端口</li>
</ul>
<ol start="3">
<li><strong>设置监听，监听的fd开始工作</strong></li>
<li><strong>阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</strong></li>
<li><strong>通信</strong></li>
</ol>
<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
<ol start="6">
<li><strong>通信结束，断开连接</strong></li>
</ol>
<hr>
<p><strong>客户端</strong></p>
<ol>
<li><strong>创建一个用于通信的套接字（fd）</strong></li>
<li><strong>连接服务器，需要指定连接的服务器的 IP 和 端口</strong></li>
<li><strong>连接成功了，客户端可以直接和服务器通信</strong></li>
</ol>
<ul>
<li>接收数据</li>
<li>发送数据</li>
</ul>
<ol start="4">
<li><strong>通信结束，断开连接</strong></li>
</ol>
<h1 id="套接字函数"><a href="#套接字函数" class="headerlink" title="套接字函数"></a>套接字函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">- 参数：</span><br><span class="line">- domain: 协议族</span><br><span class="line">AF_INET : ipv4</span><br><span class="line">AF_INET6 : ipv6</span><br><span class="line">AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">- type: 通信过程中使用的协议类型</span><br><span class="line">SOCK_STREAM : 流式协议</span><br><span class="line">SOCK_DGRAM : 报式协议</span><br><span class="line">- protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">- 失败：<span class="number">-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>; <span class="comment">// socket命</span></span><br><span class="line">名</span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过<span class="built_in">socket</span>()函数得到的文件描述符</span><br><span class="line">- backlog : 未连接的和已经连接的和的最大值， <span class="number">5</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于监听的文件描述符</span><br><span class="line">- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功 ：用于通信的文件描述符</span><br><span class="line">- <span class="number">-1</span> ： 失败</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于通信的文件描述符</span><br><span class="line">- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">- addrlen : 第二个参数的内存大小</span><br><span class="line">- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure>

<h1 id="TCP通信实现"><a href="#TCP通信实现" class="headerlink" title="TCP通信实现"></a>TCP通信实现</h1><h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建socket(用于监听的套接字)</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.194.129&quot;, saddr.sin_addr.s_addr);</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.接收客户端连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> clientaddr;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;clientaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="type">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in">sizeof</span>(clientIP));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取客户端的数据</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;192.168.194.129&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>* data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        <span class="built_in">write</span>(fd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>编译运行如下</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP通信实现.png" title alt data-align="center">

<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。<br>TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。<br>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手来关闭一个连接。</p>
<p>三次握手的目的是保证双方互相之间建立了连接</p>
<p>三次握手发生在客户端连接的时候，当调用connect()，底层会通过TCP协议进行三次握手。</p>
<p><img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP%E5%A4%B4%E9%83%A8%E7%BB%93%E6%9E%84.png"></p>
<ul>
<li><p>16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。</p>
</li>
<li><p>32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。</p>
</li>
<li><p>32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。</p>
</li>
<li><p>4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示15，所以 TCP 头部最长是60 字节。</p>
</li>
<li><p>6 位标志位包含如下几项：</p>
<ul>
<li><p>URG 标志，表示紧急指针（urgent pointer）是否有效。</p>
</li>
<li><p>ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。</p>
</li>
<li><p>PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。</p>
</li>
<li><p>RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。</p>
</li>
<li><p>SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。</p>
</li>
<li><p>FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文段。</p>
</li>
<li><p>16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。</p>
</li>
<li><p>16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。</p>
</li>
<li><p>16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。</p>
</li>
</ul>
</li>
</ul>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP三次握手.png" title alt data-align="center">

<ul>
<li><p>第一次握手：</p>
<ol>
<li><p>客户端将SYN标志位置为1</p>
</li>
<li><p>生成一个随机的32位的序号，这个序号后边是可以携带数据（数据的大小</p>
</li>
</ol>
</li>
<li><p>第二次握手：</p>
<ol>
<li><p>服务器端接受客户端的连接：ACK  &#x3D;  1</p>
</li>
<li><p>服务器端会回发一个确认序号：ack &#x3D; 客户端的序号+数据端的长度+FIN&#x2F;SYN（按一个字节算）</p>
</li>
<li><p>服务器端会像向客户端发起连接请求： SYN  &#x3D;  1</p>
</li>
<li><p>服务器会生成一个随机序号： seq  &#x3D;  K</p>
</li>
</ol>
</li>
<li><p>第三次握手：</p>
<ol>
<li><p>客户端应答服务器的连接请求： ACK &#x3D;  1</p>
</li>
<li><p>客户端回复收到了服务器端的数据： ack &#x3D; 服务端的序号  +  数据长度  +  SYN&#x2F;FIN（按一个字节算）</p>
</li>
</ol>
</li>
</ul>
<h1 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h1><p>滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。<br>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0时，发送方一般不能再发送数据报。</p>
<p>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP滑动窗口.png" title alt data-align="center">

<p>TCP（传输控制协议）滑动窗口机制是一种流量控制和拥塞控制策略，用于保证数据包在不可靠的网络环境中可靠地传输。滑动窗口机制允许发送方在没有收到接收方确认（ACK）的情况下连续发送多个数据包。同时，接收方可以通过调整窗口大小来控制发送方的发送速率。</p>
<p>滑动窗口的主要组成部分包括：</p>
<ol>
<li><p>**发送窗口 (Send Window)**：发送方维护的一个缓冲区，用于存储尚未被确认的数据包。发送窗口的大小决定了发送方在等待确认之前可以发送多少数据包。</p>
</li>
<li><p>**接收窗口 (Receive Window)**：接收方维护的一个缓冲区，用于存储尚未被处理的数据包。接收窗口的大小决定了接收方可以一次接收多少数据包。</p>
</li>
</ol>
<p>滑动窗口机制的工作流程如下：</p>
<ol>
<li><p>发送方将数据划分为一个个数据包，将这些数据包依次存储在发送窗口中。</p>
</li>
<li><p>发送方将发送窗口中的数据包发送给接收方。发送窗口的大小决定了在等待确认之前可以发送多少数据包。</p>
</li>
<li><p>接收方收到数据包后，将数据包存储在接收窗口中，并向发送方发送确认（ACK）。</p>
</li>
<li><p>发送方收到接收方的确认后，将确认过的数据包从发送窗口中移除，并向前滑动窗口，以便继续发送更多数据包。</p>
</li>
<li><p>如果发送方在指定的超时时间内没有收到确认，将会重新发送未被确认的数据包。</p>
</li>
<li><p>接收方可以通过调整接收窗口的大小来控制发送方的发送速率。例如，当接收方的处理速度较慢时，接收方可以减小接收窗口的大小，从而降低发送方的发送速率。</p>
</li>
</ol>
<p>滑动窗口机制的优点：</p>
<ul>
<li>可以实现流量控制，防止接收方被发送方的数据包淹没。</li>
<li>可以提高网络传输的效率，因为发送方可以在不等待确认的情况下连续发送多个数据包。</li>
<li>可以实现拥塞控制，当网络出现拥塞时，发送方可以减小发送窗口的大小，降低发送速率。</li>
</ul>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p>四次挥手，在程序中调用了close()会使用TCP协议进行四次挥手</p>
<p>客户端和服务端都可以主动发起断开连接，谁先调用close()谁就是先发起。</p>
<p>因为在TCP连接的时候，采用三次握手的建立是双向的，在断开的时候也需要双向断开。</p>
<p>TCP四次挥手是指在TCP连接断开过程中，两个通信节点之间进行四次报文交互的过程。</p>
<p>四次挥手的过程如下：</p>
<ol>
<li><p><strong>第一次挥手（FIN_WAIT_1）</strong>：当主动关闭连接的一方（通常称为客户端）认为不再需要发送数据时，它会设置<code>FIN</code>标志并将此报文发送给另一方（通常称为服务器端）。这表示客户端已经完成了数据传输。</p>
</li>
<li><p><strong>第二次挥手（CLOSE_WAIT）</strong>：当服务器端收到带有<code>FIN</code>标志的报文时，它会发送一个确认报文（ACK）给客户端。确认报文的<code>ACK</code>序号等于接收到的<code>FIN</code>报文序号加1。此时，服务器端进入<code>CLOSE_WAIT</code>状态，表示它已经知道客户端不再发送数据。</p>
</li>
</ol>
<p>注意，此时TCP连接仍然是半开放的，因为服务器端仍然可以向客户端发送数据。</p>
<ol start="3">
<li><p><strong>第三次挥手（FIN_WAIT_2）</strong>：当客户端收到服务器端的确认报文后，它会进入<code>FIN_WAIT_2</code>状态。此时，客户端已经关闭了发送通道，但是仍然可以接收服务器端的数据。</p>
</li>
<li><p><strong>第四次挥手（TIME_WAIT）</strong>：当服务器端完成数据发送后，它也会设置<code>FIN</code>标志并发送给客户端。当客户端收到带有<code>FIN</code>标志的报文时，它会发送一个确认报文（ACK）给服务器端。确认报文的<code>ACK</code>序号等于接收到的<code>FIN</code>报文序号加1。此时，客户端进入<code>TIME_WAIT</code>状态，并等待一段时间（通常为2倍的最大报文生命周期）以确保服务器端收到确认报文。在等待期间，如果客户端收到服务器端的<code>FIN</code>重传，它会重新发送确认报文。</p>
</li>
</ol>
<p>当服务器端收到客户端的确认报文后，它会立即关闭连接。当客户端等待时间结束后，它也会关闭连接。</p>
<p>总之，TCP四次挥手过程是一个有序的连接关闭过程。这个过程可以确保双方都完成了数据传输，避免了数据丢失和连接半开放的问题。</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP四次挥手.png" title alt data-align="center">

<h1 id="TCP通信并发"><a href="#TCP通信并发" class="headerlink" title="TCP通信并发"></a>TCP通信并发</h1><p>要实现TCP通信服务器处理并发的任务，使用多线程或多线程来解决</p>
<p>思路：</p>
<ol>
<li><p>一个父进程，多个子进程</p>
</li>
<li><p>父进程负责等待并接受客户端的连接</p>
</li>
<li><p>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信</p>
</li>
</ol>
<hr>
<h2 id="多进程实现"><a href="#多进程实现" class="headerlink" title="多进程实现"></a>多进程实现</h2><p><strong>服务端实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recyleChild</span><span class="params">(<span class="type">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">waitpid</span>(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="built_in">sigaction</span>(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="built_in">sizeof</span>(cliIp));</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> cliPort = <span class="built_in">ntohs</span>(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(cfd, &amp;recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">write</span>(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;192.168.194.129&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(recvBuf, <span class="string">&quot;data : %d\n&quot;</span>, i++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给服务器端发送数据</span></span><br><span class="line">        <span class="built_in">write</span>(fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译运行</strong></p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/服务端.png" title alt data-align="center">

<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/客户端1.png" title alt data-align="center">

<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/客户端2.png" title alt data-align="center">

<hr>
<h2 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h2><p>只有服务端的代码需要修改为多线程的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockInfo</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 通信的文件描述符</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    <span class="type">pthread_t</span> tid;  <span class="comment">// 线程号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockInfo</span> sockinfos[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">working</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子线程和客户端通信   cfd 客户端的信息 线程号</span></span><br><span class="line">    <span class="comment">// 获取客户端的信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockInfo</span>* pinfo = (<span class="keyword">struct</span> sockInfo*)arg;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, <span class="built_in">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = <span class="built_in">ntohs</span>(pinfo-&gt;addr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(pinfo-&gt;fd, &amp;recvBuf, <span class="built_in">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">write</span>(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="type">int</span> max = <span class="built_in">sizeof</span>(sockinfos) / <span class="built_in">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        <span class="built_in">bzero</span>(&amp;sockinfos[i], <span class="built_in">sizeof</span>(sockinfos[i]));</span><br><span class="line">        sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockInfo</span>* pinfo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 从这个数组中找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span> (sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">pthread_detach</span>(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译运行</strong></p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/多线程.png" title alt data-align="center">

<h1 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h1><p><img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A21.png"></p>
<p><img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A22.png"></p>
<ul>
<li><p>2MSL（Maximum Segment Lifetime）<br>主动断开连接的一方, 最后进出入一个 TIME_WAIT状态, 这个状态会持续: 2msl</p>
<ul>
<li>msl: 官方建议: 2分钟, 实际是30s<br>当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方必须处于TIME_WAIT 状态并持续 2MSL 时间。<br>这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。</li>
</ul>
</li>
<li><p>半关闭</p>
<p>当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发送的数据，但是 A 已经不能再向 B 发送数据。</p>
<p>从程序的角度，可以使用API来控制实现半连接状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br><span class="line"><span class="comment">//sockfd: 需要关闭的socket的描述符</span></span><br><span class="line"><span class="comment">//how: 允许为shutdown操作选择以下几种方式:</span></span><br><span class="line"><span class="comment">//SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。</span></span><br><span class="line"><span class="comment">//该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span></span><br><span class="line"><span class="comment">//SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span></span><br><span class="line"><span class="comment">//SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span></span><br></pre></td></tr></table></figure>

<p>使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:</p>
<ol>
<li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。</li>
<li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。但如果一个进程 close(sfd) 将不会影响到其它进程。</li>
</ol>
</li>
</ul>
<h1 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h1><p>查看网络相关信息的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><p>-a 所有的socket</p>
</li>
<li><p>-p显示正在使用socket的程序的名称</p>
</li>
<li><p>-n直接使用IP地址，而不通过域名服务器</p>
</li>
</ul>
<hr>
<p><strong>案例</strong></p>
<p>服务端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="comment">//端口复用</span></span><br><span class="line">    <span class="comment">//int optval = 1;</span></span><br><span class="line">    <span class="comment">//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="built_in">sizeof</span>(optval));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accpet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端信息</span></span><br><span class="line">    <span class="type">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="built_in">sizeof</span>(cliIp));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> cliPort = <span class="built_in">ntohs</span>(cliaddr.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client&#x27;s ip is %s, and port is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="type">char</span> recvBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recv</span>(cfd, recvBuf, <span class="built_in">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小写转大写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            recvBuf[i] = <span class="built_in">toupper</span>(recvBuf[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大写字符串发给客户端</span></span><br><span class="line">        ret = <span class="built_in">send</span>(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(sendBuf, <span class="built_in">sizeof</span>(sendBuf), stdin);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">write</span>(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, sendBuf, <span class="built_in">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先运行server，然后运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep 9999</span><br></pre></td></tr></table></figure>

<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/启动server之后运行netstat命令.png" title alt data-align="center">

<p>然后运行client，再次运行netstat命令</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/运行client命令之后再次运行netstat.png" title alt data-align="center">

<p>之后断开server，再次运行netstat命令</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/断开server后运行netstat命令.png" title alt data-align="center">

<p>过一段时间之后再次运行netstat命令</p>
<img title src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/过一段时间再次运行netstat.png" alt data-align="center">

<p>如果我们结束server之后立即断开client，再次运行netstat命令</p>
<img src="/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/结束server之后立即结束client.png" title alt data-align="center">

<p>我们在断开server之后的一分钟之内不能再次启动server，因为端口已经被占用了</p>
<p>所以这个时候需要使用端口复用</p>
<hr>
<p>端口复用最常用的用途是:</p>
<ul>
<li><p>防止服务器重启时之前绑定的端口还未释放</p>
</li>
<li><p>程序突然退出而系统没有释放端口</p>
</li>
</ul>
<p>通过一个系统的API实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="comment">//设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="comment">//参数：</span></span><br><span class="line"><span class="comment">//- sockfd：要操作的文件描述符</span></span><br><span class="line"><span class="comment">//- level：级别 - SOLSOCKET(端口复用的级别)</span></span><br><span class="line"><span class="comment">//- optname：选项的名称</span></span><br><span class="line"><span class="comment">//    - SO_REUSEADDR</span></span><br><span class="line"><span class="comment">//    - SO_REUSEPORT</span></span><br><span class="line"><span class="comment">//- optval：端口复用的值（整形）</span></span><br><span class="line"><span class="comment">//    - 1：可以复用</span></span><br><span class="line"><span class="comment">//    - 0：不可以复用</span></span><br><span class="line"><span class="comment">//- optlen：optval参数的大小</span></span><br><span class="line"><span class="comment">//端口复用，设置的时机是在服务器绑定端口之前</span></span><br><span class="line"><span class="comment">//setsockopt();</span></span><br><span class="line"><span class="comment">//bind();</span></span><br></pre></td></tr></table></figure>

<p>在开启端口复用之后，断开server，在TIME_WAIT状态可以再次打开一个server</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 继承</title>
    <url>/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>继承是面向对象三大特性之一</p>
<p>有些类与类之间存在特殊的关系，定义这些类时，下级别的成员除了拥有上一级的共性还有自己的特性，这个时候我们可以考虑利用继承的技术减少重复代码。</p>
<h1 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h1><p>语法： <code>class 子类：继承方式 父类</code></p>
<p>子类也成为派生类，父类也成为基类</p>
<p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同，接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p>
<p>普通实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通实现页面</span></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...（公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共分类列表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...（公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共分类列表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...（公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共分类列表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java页面如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python页面如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++页面如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Cpp cpp;</span><br><span class="line">    cpp.<span class="built_in">header</span>();</span><br><span class="line">    cpp.<span class="built_in">footer</span>();</span><br><span class="line">    cpp.<span class="built_in">left</span>();</span><br><span class="line">    cpp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Java页面如下<br>首页、公开课、登录、注册…（公共头部）<br>帮助中心、交流合作、站内地图…（公共底部)<br>Java、Python、C++…（公共分类列表<br>Java学科视频</p>
<hr>
<p>Python页面如下<br>首页、公开课、登录、注册…（公共头部）<br>帮助中心、交流合作、站内地图…（公共底部)<br>Java、Python、C++…（公共分类列表<br>Python学科视频</p>
<hr>
<p>C++页面如下<br>首页、公开课、登录、注册…（公共头部）<br>帮助中心、交流合作、站内地图…（公共底部)<br>Java、Python、C++…（公共分类列表<br>C++学科视频</p>
</blockquote>
<p>继承实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承实现页面</span></span><br><span class="line"><span class="comment">//公共页面类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Basepage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...（公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java、Python、C++...（公共分类列表&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> Basepage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Java学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> Basepage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cpp</span> : <span class="keyword">public</span> Basepage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Java页面如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Java ja;</span><br><span class="line">    ja.<span class="built_in">header</span>();</span><br><span class="line">    ja.<span class="built_in">footer</span>();</span><br><span class="line">    ja.<span class="built_in">left</span>();</span><br><span class="line">    ja.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Python页面如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Python py;</span><br><span class="line">    py.<span class="built_in">header</span>();</span><br><span class="line">    py.<span class="built_in">footer</span>();</span><br><span class="line">    py.<span class="built_in">left</span>();</span><br><span class="line">    py.<span class="built_in">content</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C++页面如下&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Cpp cpp;</span><br><span class="line">    cpp.<span class="built_in">header</span>();</span><br><span class="line">    cpp.<span class="built_in">footer</span>();</span><br><span class="line">    cpp.<span class="built_in">left</span>();</span><br><span class="line">    cpp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Java页面如下<br>首页、公开课、登录、注册…（公共头部）<br>帮助中心、交流合作、站内地图…（公共底部)<br>Java、Python、C++…（公共分类列表<br>Java学科视频</p>
<hr>
<p>Python页面如下<br>首页、公开课、登录、注册…（公共头部）<br>帮助中心、交流合作、站内地图…（公共底部)<br>Java、Python、C++…（公共分类列表<br>Python学科视频</p>
<hr>
<p>C++页面如下<br>首页、公开课、登录、注册…（公共头部）<br>帮助中心、交流合作、站内地图…（公共底部)<br>Java、Python、C++…（公共分类列表<br>C++学科视频</p>
</blockquote>
<h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><p>继承的方式一共有三种</p>
<ul>
<li><p>公共继承</p>
</li>
<li><p>保护继承</p>
</li>
<li><p>私有继承</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">10</span>;<span class="comment">//父类中的公共权限成员到子类中依然是公共权限</span></span><br><span class="line">        m_B = <span class="number">10</span>;<span class="comment">//父类中的保护权限成员到子类中依然是保护权限</span></span><br><span class="line">        <span class="comment">//m_C = 10;//父类中的私有权限成员子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son1 s1;</span><br><span class="line">    s1.m_A = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//s1.m_B = 100;//到Son1中m_B是保护权限，类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">protected</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;<span class="comment">//父类中的公共权限成员到子类中变为保护权限</span></span><br><span class="line">        m_B = <span class="number">100</span>;<span class="comment">//父类中的保护权限成员到子类中依然是保护权限</span></span><br><span class="line">        <span class="comment">//m_C = 100;//父类中私有权限成员子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son2 s1;</span><br><span class="line">    <span class="comment">//s1.m_A = 10;//在Son2中 m_A变为保护权限，因此类外访问不到</span></span><br><span class="line">    <span class="comment">//s1.m_B = 10;//在Son2中 m_B变为保护权限，不可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span> :<span class="keyword">private</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;<span class="comment">//父类中的公共权限成员到子类中变为保护权限</span></span><br><span class="line">        m_B = <span class="number">100</span>;<span class="comment">//父类中的保护权限成员到子类中变为私有权限</span></span><br><span class="line">        <span class="comment">//m_C = 100;//父类中的私有成员子类访问不到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son3 s1;</span><br><span class="line">    <span class="comment">//s1.m_A = 10;//到Son3中变为私有成员，类外访问不了</span></span><br><span class="line">    <span class="comment">//s1.m_B = 10;//到Son3中变为私有成员，类外访问不了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h1><p>问题：从父类继承过来的成员，哪些属于子类对象中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//继承中的对象模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of Son &#x3D; 16</p>
</blockquote>
<p>父类中所有非静态成员属性都会被子类继承下去</p>
<p>父类中私有成员属性是被编译器给隐藏了，因此是访问不到，但是确实是被继承下去了</p>
<h2 id="开发人员命令提示工具查看对象模型"><a href="#开发人员命令提示工具查看对象模型" class="headerlink" title="开发人员命令提示工具查看对象模型"></a>开发人员命令提示工具查看对象模型</h2><p>打开vs开发人员命令提示工具</p>
<img src="/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/vs开发.png" title alt data-align="center">

<p>转到文件对应的路径</p>
<img src="/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/cd.png" title alt data-align="center">

<p>输入命令查看类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayout类名 文件名</span><br></pre></td></tr></table></figure>

<img src="/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/class.png" title alt data-align="center">

<h1 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h1><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//继承中的构造和析构顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base的构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base的析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son的构造函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son的析构函数！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Base的构造函数！<br>Son的构造函数！<br>Son的析构函数！<br>Base的析构函数！</p>
</blockquote>
<p>先构造父类再构造子类，析构相反</p>
<h1 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h1><p>访问子类同名成员，直接访问即可</p>
<p>访问父类同名成员，需要加作用域 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//如果通过子类对象，访问到父类中的同名成员，需要加作用域</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同名成员函数处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();<span class="comment">//直接调用的是子类中的同名成员</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员函数</span></span><br><span class="line">    s.Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>Son下的m_A &#x3D; 200<br>Base下的m_A &#x3D; 100<br>Son - func()调用<br>Base - func()调用<br>Base - func(int a)调用</p>
</blockquote>
<h1 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h1><p>静态成员和非静态成员同名，处理方式一致</p>
<p>访问子类同名成员，直接访问即可</p>
<p>访问父类同名成员，需要加作用域</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//继承中的同名静态成员的处理方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son - static void func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名静态成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、通过类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;<span class="comment">//第一个::代表通过类名方式访问，第二个::代表访问父类作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同名静态成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1、通过对象访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过对象访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son s;</span><br><span class="line">    s.<span class="built_in">func</span>();</span><br><span class="line">    s.Base::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//2、通过类名访问</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通过类名访问：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Son::<span class="built_in">func</span>();</span><br><span class="line">    Son::Base::<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//子类出现和父类同名静态成员函数，也会隐藏父类中所有的同名成员函数</span></span><br><span class="line">    <span class="comment">//如果想访问父类中被隐藏同名成员，需要加作用域</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>通过对象访问：<br>Son下的m_A &#x3D; 200<br>Base下的m_A &#x3D; 100<br>通过类名访问：<br>Son下的m_A &#x3D; 200<br>Base下的m_A &#x3D; 100<br>通过对象访问：<br>Son - static void func()调用<br>Base - static void func()调用<br>通过类名访问：<br>Son - static void func()调用<br>Base - static void func()调用<br>Base - static void func(int a)调用</p>
</blockquote>
<h1 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h1><p>C++允许一个类继承多个类</p>
<p>语法：<code>class 子类：继承方式 父类1，继承方式 父类2 ...</code></p>
<p> 多继承可能会引发父类中有同名成员出现，需要加作用域区分</p>
<p>C++实际开发中不建议使用多继承</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//多继承语法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_C = <span class="number">300</span>;</span><br><span class="line">        m_D = <span class="number">400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_C;</span><br><span class="line">    <span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Son s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base1::m_A = &quot;</span> &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Base2::m_A = &quot;</span> &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>size of Son &#x3D; 16<br>Base1::m_A &#x3D; 100<br>Base2::m_A &#x3D; 200</p>
</blockquote>
<img src="/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/多继承.png" title alt data-align="center">

<h1 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h1><p>菱形继承概念：</p>
<ul>
<li><p>两个派生类继承同一个基类</p>
</li>
<li><p>又有某个类同时继承两个派生类</p>
</li>
<li><p>这种继承被称为菱形继承或钻石继承</p>
</li>
</ul>
<p>不使用虚继承</p>
<img src="/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/SheepTuo.png" title alt data-align="center">

<img src="/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/SheepTuoVirtual.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//动物类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//利用虚继承解决菱形继承的问题</span></span><br><span class="line"><span class="comment">//继承之前加上关键字virtual变为虚继承</span></span><br><span class="line"><span class="comment">//Animal类称为虚基类 </span></span><br><span class="line"><span class="comment">//羊类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Animal </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//羊驼类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> :<span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">18</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">28</span>;</span><br><span class="line">    <span class="comment">//当菱形继承，两个父类拥有相同数据，需要加以作用域区分</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//这份数据我们知道 只要有一份就可以，菱形继承导致数据有两份，资源浪费</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>st.Sheep::m_Age &#x3D; 28<br>st.Tuo::m_Age &#x3D; 28</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 运算符重载</title>
    <url>/2023/04/30/C++-%E5%AD%A6%E4%B9%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h1 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h1><p>作用：实现两个自定义数据类型相加的运算</p>
<h2 id="成员函数重载"><a href="#成员函数重载" class="headerlink" title="成员函数重载"></a>成员函数重载</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//加号运算符重载</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person <span class="keyword">operator</span>+ (Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        Person temp;</span><br><span class="line">        temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">        temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">10</span>;</span><br><span class="line">    p1.m_B = <span class="number">10</span>;</span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">20</span>;</span><br><span class="line">    p2.m_B = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3.m_A = &quot;</span> &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3.m_B = &quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p3.m_A &#x3D; 30<br>p3.m_B &#x3D; 30</p>
</blockquote>
<p>成员函数重载本质调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person p3 = p1.<span class="keyword">operator</span>+(p2);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局函数重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line">Person <span class="keyword">operator</span>+ (Person&amp; p1, Person&amp; p2)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p1.m_A + p2.m_A;</span><br><span class="line">    temp.m_B = p1.m_B + p2.m_B;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">10</span>;</span><br><span class="line">    p1.m_B = <span class="number">10</span>;</span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_A = <span class="number">20</span>;</span><br><span class="line">    p2.m_B = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3.m_A = &quot;</span> &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3.m_B = &quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p3.m_A &#x3D; 30<br>p3.m_B &#x3D; 30</p>
</blockquote>
<p>全局函数重载本质调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Person p3 = <span class="keyword">operator</span>+(p1,p2);</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载也可以函数重载"><a href="#运算符重载也可以函数重载" class="headerlink" title="运算符重载也可以函数重载"></a>运算符重载也可以函数重载</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局函数重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line">Person <span class="keyword">operator</span>+ (Person&amp; p1,<span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_A = p1.m_A + num;</span><br><span class="line">    temp.m_B = p1.m_B + num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_A = <span class="number">10</span>;</span><br><span class="line">    p1.m_B = <span class="number">10</span>;</span><br><span class="line">    Person p3 = p1 + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3.m_A = &quot;</span> &lt;&lt; p3.m_A &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3.m_B = &quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p3.m_A &#x3D; 20<br>p3.m_B &#x3D; 20</p>
</blockquote>
<h1 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h1><p>作用：可以输出自定义的数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//左移运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用成员函数重载左移运算符&lt;&lt;</span></span><br><span class="line">    <span class="comment">//通常不会利用成员函数重载&lt;&lt;，因为不能实现cout在左侧</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_A;</span><br><span class="line">    <span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; m_B = &quot;</span> &lt;&lt; p.m_B;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.m_A = <span class="number">10</span>;</span><br><span class="line">    p.m_B = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>m_A &#x3D; 10 m_B &#x3D; 10</p>
</blockquote>
<h1 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h1><p>作用：通过重载递增运算符，实现自己的整型数据</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载递增运算符</span></span><br><span class="line"><span class="comment">//自定义整型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载前置++运算符  返回引用是为了一直对一个数据操作</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先做++运算</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//再返回自身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载后置++运算符 int代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先记录结果</span></span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//后递增</span></span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="comment">//返回记录的结果</span></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; myint.m_Num;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line">    cout &lt;&lt; ++myint &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInteger myint;</span><br><span class="line">    cout &lt;&lt; myint++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>1</p>
<p>0</p>
</blockquote>
<h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><p>C++编译器至少给一个类添加四个函数</p>
<p>1、默认构造函数（无参，函数体为空）</p>
<p>2、默认析构函数（无参，函数体为空）</p>
<p>3、默认拷贝构造函数，对属性进行值拷贝</p>
<p>4、赋值运算符operator&#x3D;对属性进行值拷贝</p>
<p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//赋值运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* m_Age;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>=(Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//编译器提供浅拷贝</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//应该先判断是否有属性在堆区，如果有，先释放干净，然后再深拷贝</span></span><br><span class="line">        <span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_Age;</span><br><span class="line">            m_Age = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回对象本身</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1的年龄为： &quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p3的年龄为： &quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1的年龄为： 18<br>p2的年龄为： 18<br>p3的年龄为： 18</p>
</blockquote>
<h1 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h1><p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载关系运算符</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Name = name;</span><br><span class="line">        m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="type">int</span> m_Age;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1和p2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1和p2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 != p2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1和p2是不相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1和p2是相等的&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>p1和p2是相等的<br>p1和p2是相等的</p>
</blockquote>
<h1 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h1><p>函数调用运算符（）也可以重载</p>
<p>由于重载后使用的方式非常像函数的调用，因此称为仿函数</p>
<p>仿函数没有固定写法，非常灵活</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数调用运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//重载函数调用运算符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPrint myPrint;</span><br><span class="line">    <span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仿函数非常灵活，没有固定的写法</span></span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyAdd myadd;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">myadd</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//匿名函数对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<blockquote>
<p>hello world<br>ret &#x3D; 200<br>200</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>语法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello ,my blog</title>
    <url>/2022/06/23/Hello-my-blog/</url>
    <content><![CDATA[<p>Zwei Dinge erfüllen das Gemuet mit immer neuer und zunehmender Bewunderung und Ehrfurcht, je öfter und anhaltender sich das Nachdenken damit beschäftigt:: der bestirnte Himmel über mir und das moralische Gesetz in mir.</p>
]]></content>
      <categories>
        <category>Dairy</category>
      </categories>
      <tags>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081 Operating System Engineering Lecture01 Intrduction and Examples</title>
    <url>/2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="课程目标"><a href="#课程目标" class="headerlink" title="课程目标"></a>课程目标</h2><ul>
<li><p>理解操作系统的设计和实现。理解整体结构和具体代码。</p>
</li>
<li><p>通过XV6操作系统获得实际动手经验。扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件</p>
</li>
</ul>
<h2 id="OS的目标"><a href="#OS的目标" class="headerlink" title="OS的目标"></a>OS的目标</h2><ul>
<li><p><strong>Abstract Hardware</strong></p>
</li>
<li><p><strong>Multiplex</strong></p>
</li>
<li><p><strong>Isolation</strong></p>
</li>
<li><p><strong>Sharing</strong></p>
</li>
<li><p><strong>Preformance</strong></p>
</li>
<li><p><strong>Access Control&#x2F;Security</strong></p>
</li>
<li><p><strong>Range Of Users</strong></p>
</li>
</ul>
<h1 id="OS的结构"><a href="#OS的结构" class="headerlink" title="OS的结构"></a>OS的结构</h1><h2 id="分层思想"><a href="#分层思想" class="headerlink" title="分层思想"></a>分层思想</h2><p><img src="/2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/OS.png" alt="OS-ORG"></p>
<h3 id="Userspace"><a href="#Userspace" class="headerlink" title="Userspace"></a>Userspace</h3><p>在架构的最上层，运行各种各样的应用程序例如文本编辑器（VI），C编辑器（CC），作为CLI存在的shell。</p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>区别于<code>userspace</code>，有一个特殊的程序总是会在运行。<code>Kernel</code>是计算机资源的守护者，当打开计算机时，<code>Kernel</code>总是第一个被启动。Kernel程序只有一个，维护数据来管理每一个用户空间进程。<code>Kernel</code>同时还维护了大量数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用。<code>Kernel</code>同时还会有大量内置的服务。例如，<code>Kernel</code>通常会有文件系统实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。所以用户空间的程序会与<code>Kernel</code>中的文件系统交互，文件系统再与磁盘交互。</p>
<p>我们主要关注在<strong>Kernel、连接Kernal和用户空间程序的接口、Kernel内软件的架构</strong> 。所以我们会关心Kernel内的服务。其中一个是文件系统，另一个就是进程管理系统。</p>
<ul>
<li><p><strong>Manage Process</strong>：每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。</p>
</li>
<li><p><strong>Allocate Memory</strong>：Kernel会管理内存的分配，不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。</p>
</li>
<li><p><strong>File System</strong>：文件系统通常有一些逻辑分区。目前而言，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有这些都被文件系统所管理。</p>
</li>
<li><p><strong>Security&#x2F;Access Control</strong>: 当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control机制会决定是否允许这样的操作。对于一个分时共享的计算机，例如Athena系统，这里可能会变得很复杂。因为在Athena系统中，每一个进程可能属于不同的用户，因此会有不同Access规则来约定哪些资源可以被访问。</p>
</li>
</ul>
<p>在一个真实的完备的操作系统中，会有很多很多其他的服务，比如在不同进程之间通信的进程间通信服务，比如一大票与网络关联的软件（TCP&#x2F;IP协议栈），比如支持声卡的软件，比如支持数百种不同磁盘，不同网卡的驱动。所以在一个完备的系统中，Kernel会包含大量的内容，数百万行代码。</p>
<h2 id="Kernel-API"><a href="#Kernel-API" class="headerlink" title="Kernel API"></a>Kernel API</h2><p><code>Kernel API</code>决定了应用程序如何访问Kernel。通常来说，这里通过系统调用<code>System Call</code>来完成。系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。</p>
<p><code>Kernel</code>的代码总是有特殊的权限。当机器启动<code>Kernel</code>时，<code>Kernel</code>会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;out&quot;</span>,<span class="number">1</span>);</span><br><span class="line">write(fd,<span class="string">&quot;hello\n&quot;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>第一个系统调用<code>open</code>，它会跳到Kernel，Kernel会获取到open的参数，执行一些实现了open的Kernel代码，或许会与磁盘有一些交互，最后返回一个文件描述符对象。上图中的fd全称就是<code>file descriptor</code>。之后应用程序可以使用这个文件描述符作为handle，来表示相应打开的文件。</p>
<p>第二个系统调用<code>write</code>，你需要向write传递一个由open返回的文件描述符作为参数。你还需要向write传递一个指向要写入数据的指针（数据通常是char型序列），在C语言中，可以简单传递一个双引号表示的字符串。第三个参数是你想要写入字符的数量。第二个参数的指针，实际上是内存中的地址。所以这里实际上告诉内核，将内存中这个地址起始的6个字节数据写入到fd对应的文件中。</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pid = fork();</span><br></pre></td></tr></table></figure>

<p><code>fork</code>是一个系统调用，它创建了一个与调用进程一模一样的新的进程，并返回新进程的<code>Process ID/PID</code>。</p>
<p>这些系统调用看起来跟普通的函数调用一样，但是它最终会跳到系统内核中。</p>
<h1 id="操作系统的难点"><a href="#操作系统的难点" class="headerlink" title="操作系统的难点"></a>操作系统的难点</h1><ul>
<li><p>内核的编程环境比较困难。当你在编写、修改，扩展内核，或者写一个新的操作系统内核时，你实际上在提供一个基础设施让别人来运行他们的程序。当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。</p>
</li>
<li><p>当你在设计一个操作系统时，你需要满足一些列矛盾的需求。</p>
<ul>
<li><p>你想要你的操作系统既高效又易用。高效通常意味着操作系统需要在离硬件近的low-level进行操作，而易用则要求操作系统为应用程序提供抽象的high-level可移植接口。所以，提供一个简单可移植，同时又高效的抽象接口需要一定的技巧。</p>
</li>
<li><p>我们想要提供一个非常强大的操作系统服务，这样操作系统才能分担运行应用程序的负担。同时，我们也想要有简单的接口。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。</p>
</li>
<li><p>你希望给与应用程序尽可能多的灵活性，你不会想要限制应用程序，所以你需要内核具备灵活的接口。但是另一方面，你的确需要在某种程度上限制应用程序，因为你会想要安全性。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为。</p>
</li>
</ul>
</li>
</ul>
<h1 id="read，write，exit系统调用"><a href="#read，write，exit系统调用" class="headerlink" title="read，write，exit系统调用"></a>read，write，exit系统调用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inclued <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> n = read(<span class="number">0</span>,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        write(<span class="number">1</span>,buf,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h2><ul>
<li><p>第一个参数是文件描述符，实际上是对以前打开文件的引用。Shell会确保默认情况下，当一个程序启动时，文件描述符0为连接到console的输入，文件描述符1为连接到了console的输出。所以我们可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。</p>
</li>
<li><p>第二个参数是只想某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。char buf[64]在栈中申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中。</p>
</li>
<li><p>第三个参数是代码想读取的最大长度。sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据。</p>
<p>如果第三个参数是65字节，操作系统会拷贝65个字节到你提供的内存中（第二个参数）。但是如果栈中的第65个字节有一些其他数据，那么这些数据会被覆盖，这里是个bug，或许会导致你的代码崩溃，或者一些异常的行为。</p>
</li>
<li><p>read的返回值</p>
<ul>
<li><p>可能是读到的字节数</p>
</li>
<li><p>如果从一个文件读数据，如果到达了文件的结尾没有更多的内容了，read会返回0。</p>
</li>
<li><p>如果出现了一些错误，比如文件描述符不存在，read或许会返回-1 。</p>
</li>
</ul>
</li>
</ul>
<h2 id="write系统调用"><a href="#write系统调用" class="headerlink" title="write系统调用"></a>write系统调用</h2><p>第一个参数为文件描述符，第二个参数是数据的指针，第三个参数是要写入的字节数   </p>
<p>数据被写入到了文件描述符对应的文件中</p>
<h1 id="open系统调用"><a href="#open系统调用" class="headerlink" title="open系统调用"></a>open系统调用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>,O_WRONLY | O_CREATE);</span><br><span class="line">    write(fd, <span class="string">&quot;ooo\n&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会创建一个叫做<code>output.txt</code>的新文件，并向它写入一些数据，最后退出。我们看不到任何输出，因为它只是向打开的文件中写入数据，但是我们可以查看output.txt的内容，并看到<code>open</code>程序写入的“ooo”。</p>
<p>所以执行<code>open</code>系统调用，将<code>out.txt</code>作为参数传入，第二个参数是一些标志位，用来告诉open系统调用在内核中的实现，用来告诉open系统调用在内核中的实现：我们将要创建并写入一个文件。open系统调用会返回一个新分配的文件描述符，这里的文件描述符是一个小的数字，可能是2，3，4或者其他的数字。然后将文件描述符传入write中。</p>
<ul>
<li><p>文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。</p>
</li>
<li><p>C语言与Python在文件描述符中的区别：Python提供了对与open调用的较好的封装，通常来说，Python提供的是更高级的函数，比如说Python不会使用指向内存的指针，并且Python会为你做更多的错误检查。当我们在Python中打开文件或者写入文件时，你在Python中的调用最终会走到跟我们例子中一样的系统调用。</p>
</li>
</ul>
<h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><p><code>Shell</code>通常也是人们说的命令行接口。如果你还没有用过Shell，Shell是一种对于Unix系统管理来说非常有用的接口，它提供了很多工具来管理文件，编写程序，编写脚本。当你输入内容时，你是在告诉Shell运行相应的程序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>ls的实际工作就是输出当前目录的文件列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls &gt; out</span><br></pre></td></tr></table></figure>

<p>Shell允许重定向IO，这里的实际意义是要求Shell允许ls命令，但是将输出重定向到一个叫做out的文件中。这里执行完成之后我们看不到任何的输出，因为输出都送到了out文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat out</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>cat</code>指令来读取一个文件，并显示文件的内容，之后我们可以看到ls指令相同的输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep x</span><br></pre></td></tr></table></figure>

<p>你也可以运行一个名为<code>grep</code>的指令，并将x作为参数传给grep。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep  x &lt; out</span><br></pre></td></tr></table></figure>

<p><code>grep x</code>会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。因为out文件包含了ls的输出，所以我们可以看出有3个文件名包含了x。</p>
<blockquote>
<p>编译器如何处理系统调用？生成的汇编语言是不是会调用一些由操作系统定义的代码段？</p>
<p>有一个特殊的RISC-V指令，程序可以调用这个指令，并将控制权交给内核。所以，实际上当你运行C语言并执行例如open或者write的系统调用时，从技术上来说，open是一个C函数，但是这个函数内的指令实际上是机器指令，也就是说我们调用的open函数并不是一个C语言函数，它是由汇编语言实现，组成这个系统调用的汇编语言实际上在RISC-V中被称为ecall。这个特殊的指令将控制权转给内核。之后内核检查进程的内存和寄存器，并确定相应的参数。</p>
</blockquote>
<h1 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fork() returned %d\n&quot;</span>,pid);</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后我们就有了两个完全一样的内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。</p>
<blockquote>
<p>返回</p>
<p>ffoorrkk(()) rreettuuttnende d 0</p>
<p>lc9h</p>
<p>ilpda</p>
<p>rent</p>
</blockquote>
<p><code>if（pid == 0）</code>，你可以看到代码检查pid。如果pid &#x3D; 0，这必然是子进程。在我们的例子中，调用进程通常称为父进程，父进程看到的pid必然大于0.所以父进程会打印“parent”,子进程会打印”child”。之后两个进程都会退出。</p>
<p>输出结果，实际发生二点是，<code>fork</code>系统调用之后，两个进程都在同时运行。它们会同时一个字节一个字节的输出，两个进程的输出交织在一起，所以你可以看到两个f，两个o等等。在第一行最后，你可以看到0，这是子进程的输出。</p>
<p>我猜父进程返回了19，作为子进程的进程ID。通常来说，这意味着这是操作系统启动之后的第19个进程。之后一个进程输出了child，一个进程输出了parent，这两个输出交织在一起。虽然这只是对于<code>fork</code>的一个简单应用，但是我们可以清晰的从输出看到这里创建了两个运行的进程，其中一个进程打印了child，另一个打印了parent。所以，<code>fork</code>（在子父进程中）返回不同的值是比较重要的。</p>
<p>父进程与子进程除了<code>fork</code>的返回值，两个进程是一样的。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。 在一个更加复杂的操作系统，有一些细节，我们现在并不关心，这些细节偶尔会导致父子进程不一致，但是在XV6中，父子进程除了fork的返回值，其他都是一样的。</p>
<p>除了内存是一样的以外，文件描述符的表单也从父进程拷贝到子进程。所以如果父进程打开了一个文件，子进程可以看到同一个文件描述符，尽管子进程看到的是一个文件描述符的表单的拷贝。除了拷贝内存以外，<code>fork</code>还会拷贝文件描述符表单。</p>
<h1 id="exec，wait系统调用"><a href="#exec，wait系统调用" class="headerlink" title="exec，wait系统调用"></a>exec，wait系统调用</h1><p>fork创建了一个新的进程。当我们在shell中运行东西的时候，shell实际上会创建一个新的进程来运行你输入的每一个指令。所以，当我输入ls时，我们需要shell通过fork创建一个进程来运行ls，这里需要某种方式来让这个新的进程来运行ls程序中的指令，加载名为ls的文件中的指令，也就是exec系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exec.c:replace a process with an executable file</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel.types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123; <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码会执行exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。所以系统调用exec会有这样的效果：操作系统从名为echo的文件中加载指令到当前的进程中，并替换了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec允许你传入一个命令行参数的数组，这里就是一个C语言中的指针数组，在上面代码设置好了一个字符指针的数组，这里的字符指针本质就是一个字符串（string）</p>
<p><code>echo</code> 程序是一个常见的命令行实用程序，用于在 Unix、Linux 和类 Unix 系统（如 macOS）上显示文本。它将传递给它的命令行参数（字符串）输出到标准输出（通常是终端或控制台）。<code>echo</code> 命令通常用于编写脚本或在控制台显示消息。</p>
<p>通过 <code>exec(&quot;echo&quot;, argv);</code> 系统调用执行。在这个例子中，<code>argv</code> 数组包含以下参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;this&quot;</span></span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">&quot;is&quot;</span></span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">&quot;echo&quot;</span></span><br><span class="line">argv[<span class="number">4</span>] = <span class="literal">NULL</span> (空指针)</span><br></pre></td></tr></table></figure>

<p>通常，<code>argv[0]</code> 是程序名称（在这里是 “echo”），后面是实际要传递的命令行参数（在这里是 “this”, “is”, “echo”）。<code>argv</code> 数组以空指针（<code>NULL</code>）结尾，表示参数列表的结束。</p>
<p>当 <code>echo</code> 程序执行时，它会输出 <code>&quot;this is echo&quot;</code>。</p>
<ul>
<li><p><code>exec</code>系统调用会保留当前的文件描述符表单。所以任何在<code>exec</code>系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。</p>
</li>
<li><p>通常来说<code>exec</code>系统调用不会返回，因为<code>exec</code>会完全替换当前进程的内存，相当于当前进程不复存在了，所以<code>exec</code>系统调用已经没有地方能返回了,在实例代码中，执行错误才会返回。</p>
</li>
</ul>
<p>这就是一个程序如何用文件中的另一个程序来替代自己。实际上，当我们在Shell中运行类似于“echo a b c”的指令，或者ls，或者任何命令，我们不会想要代替Shell进程，所以我们不会希望Shell执行exec系统调用。如果我们这么做了，这里会用echo指令来替代Shell进程，当echo退出了，一切就结束了。所以我们不想要echo替代Shell。实际上，Shell会执行fork，之后fork出的子进程再调用exec系统调用，这是一个非常常见的Unix程序调用风格。对于那些想要运行程序，但是还希望能拿回控制权的场景，可以先执行fork系统调用，然后在子进程中调用exec。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forkexec.c: fork then exec</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid, status;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span> ,<span class="string">&quot;THIS&quot;</span> ,<span class="string">&quot;IS&quot;</span> ,<span class="string">&quot;ECHO&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent waiting\n&quot;</span>);</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the child exited with status %d\n&quot;</span>,status);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fork</code>系统调用会创建一个新的子进程，是当前进程的一个副本。</p>
<p>如果<code>pid == 0</code>，即进程是子进程，则会调用<code>echo</code>程序，输出<code>&quot;THIS IS ECHO&quot;</code>，如果错误则返回1。并且子进程在<code>echo</code>程序执行结束之后就会退出。，之后继续进行父进程。</p>
<p>父进程会先输出<code>“parent waiting\n”</code>，之后使用wait系统调用，等待子进程返回，将子进程返回的状态传入<code>status</code>，<code>&amp;status</code>，是将<code>status</code>对应的地址传递给内核，内核会向这个地址写入子进程向<code>exit</code>传入的参数。</p>
<p>如果一个子进程退出成功了，那么<code>exit</code>的参数会是0，如果出现了错误，会向<code>exit</code>传入1。所以父进程读取的wait的参数取决于子进程是否成功的完成了。</p>
<h1 id="I-x2F-O-Redirect"><a href="#I-x2F-O-Redirect" class="headerlink" title="I&#x2F;O Redirect"></a>I&#x2F;O Redirect</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello &gt; out</span><br></pre></td></tr></table></figure>

<p><code>Shell</code>会将<code>echo</code>的输出送到文件out</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt; out</span><br></pre></td></tr></table></figure>

<p>之后可以运行cat指令，并将<code>out</code>指令作为输入，之后保存在<code>out</code>文件中的内容就是<code>echo</code>指令的输出</p>
<p><code>Shell</code>首先会先<code>fork</code>然后在子进程中，<code>Shell</code>改变了文件描述符。文件描述符1用来console输出，<code>Shell</code>会将文件描述符1改为output文件，之后再运行你的指令。同时，父进程的文件描述符1并没有改变。所以这里先<code>fork</code>再改变子进程的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//redirect.c: run a command with output redirected</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(<span class="number">1</span>);</span><br><span class="line">        open(<span class="string">&quot;output.txt, O_WRONLY|O_CREATE&quot;</span>);</span><br><span class="line">        <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;this&quot;</span> ,<span class="string">&quot;is&quot;</span> ,<span class="string">&quot;redirect&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        exec(<span class="string">&quot;echo&quot;</span>,argv);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exec failed!\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>if(pid == 0)</code>中，先检查pid的值，如果pid为0（在子进程中），则首先<code>close(1)</code>,<code>close(1)</code>的意义是，我们希望文件描述符1指向一个其他的位置。也就是说，在子进程中我们不想使用原本指向console输出的文件描述符1，即关闭标准输出。</p>
<p>使用 <code>open(&quot;output.txt&quot;, O_WRONLY | O_CREAT, 0666);</code> 打开或创建名为 “output.txt” 的文件，以只写模式（<code>O_WRONLY</code>）打开，并设置创建模式（<code>0666</code>，表示所有用户都可以读写此文件）。这将使得新打开的文件描述符成为子进程的标准输出。</p>
<p>使用 <code>exec(&quot;echo&quot;, argv);</code> 系统调用，替换子进程的映像为 <code>echo</code> 程序，并传递 <code>argv</code> 参数列表。 如果 <code>exec</code> 调用失败，输出 “exec failed!”。</p>
<p>在父进程中，调用 <code>wait((int *)0);</code> 函数，等待子进程结束。</p>
<p>当运行此程序时，它将执行 <code>echo</code> 命令，并将输出 “this is redirect echo” 重定向到 “output.txt” 文件。如果文件已存在，它将覆盖现有内容；如果文件不存在，它将创建一个新文件。</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>MIT6.S081 Operating System Engineering</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6 S081 Operating System Engineering Lecture03 OS Organization and System Call</title>
    <url>/2023/04/02/MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call/</url>
    <content><![CDATA[<h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><ul>
<li><p><strong>Isolation</strong>:Isolation是设计操作系统组织结构的驱动力</p>
</li>
<li><p><strong>System Call</strong>:System call是你的应用程序能够转换到内核执行的基本方法</p>
</li>
<li><p><strong>Kernel mode&#x2F;user mode</strong></p>
</li>
</ul>
<h1 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h1><h2 id="应用程序之间有隔离性"><a href="#应用程序之间有隔离性" class="headerlink" title="应用程序之间有隔离性"></a>应用程序之间有隔离性</h2><p>我们在用户空间有多个应用程序，例如<code>Shell</code>、<code>echo</code>、<code>find</code>等等。但是，如果你通过Shell运行你们的Prime代码（lab1中的一个部分）时，假设你们的代码出现了问题，Shell不应该会影响到其他的应用程序。举个反例，如果Shell出现问题时，杀掉了其他的进程，这将会非常糟糕。所以你需要在不同的应用程序之间有强隔离性。</p>
<h2 id="应用程序与操作系统之间有隔离性"><a href="#应用程序与操作系统之间有隔离性" class="headerlink" title="应用程序与操作系统之间有隔离性"></a>应用程序与操作系统之间有隔离性</h2><p>操作系统某种程度上为所有的应用程序服务。当你的应用程序出现问题时，你会希望操作系统不会因此而崩溃。比如说你向操作系统传递了一些奇怪的参数，你会希望操作系统仍然能够很好的处理它们（能较好的处理异常情况）。所以，你也需要在应用程序和操作系统之间有强隔离性。</p>
<h2 id="如果没有操作系统"><a href="#如果没有操作系统" class="headerlink" title="如果没有操作系统"></a>如果没有操作系统</h2><p>如果没有操作系统，或者操作系统只是一些库文件，比如说你在使用Python，通过import os你就可以将整个操作系统加载到你的应用程序中。那么现在，我们有一个Shell，并且我们引用了代表操作系统的库。同时，我们有一些其他的应用程序，例如echo。</p>
<p>通常来说，如果没有操作系统，应用程序会直接与硬件交互。比如，应用程序可以直接看到CPU的多个核，看到磁盘，内存。所以现在应用程序和硬件资源之间没有一个额外的抽象层。</p>
<h3 id="调度及复用隔离问题"><a href="#调度及复用隔离问题" class="headerlink" title="调度及复用隔离问题"></a>调度及复用隔离问题</h3><p>使用操作系统的一个目的是为了同时运行多个应用程序，所以时不时的，CPU会从一个应用程序切换到另一个应用程序。我们假设硬件资源里只有一个CPU核，并且我们现在在这个CPU核上运行Shell。但是时不时的，也需要让其他的应用程序也可以运行。现在我们没有操作系统来帮我们完成切换，所以Shell就需要时不时的释放CPU资源。</p>
<p>为了不变成一个恶意程序，Shell在发现自己运行了一段时间之后，需要让别的程序也有机会能运行。这种机制有时候称为协同调度（Cooperative Scheduling）。但是这里的场景并没有很好的隔离性，比如说Shell中的某个函数有一个死循环，那么Shell永远也不会释放CPU，进而其他的应用程序也不能够运行，甚至都不能运行一个第三方的程序来停止或者杀死Shell程序。所以这种场景下，我们基本上得不到真正的multiplexing（CPU在多进程同分时复用）。而这个特性是非常有用的，不论应用程序在执行什么操作，multiplexing都会迫使应用程序时不时的释放CPU，这样其他的应用程序才能运行。</p>
<h3 id="内存隔离问题"><a href="#内存隔离问题" class="headerlink" title="内存隔离问题"></a>内存隔离问题</h3><p>假设现在物理内存中的一部分被Shell使用，另一部分被echo使用。因为两个应用程序的内存之间没有边界，如果echo程序将数据存储在属于Shell的一个内存地址中，那么就echo就会覆盖Shell程序内存中的内容。</p>
<p>使用操作系统的一个原因，甚至可以说是主要原因就是为了实现multiplexing和内存隔离。如果你不使用操作系统，并且应用程序直接与硬件交互，就很难实现这两点。所以，将操作系统设计成一个库，并不是一种常见的设计。你或许可以在一些实时操作系统中看到这样的设计，因为在这些实时操作系统中，应用程序之间彼此相互信任。但是在大部分的其他操作系统中，都会强制实现硬件资源的隔离。</p>
<h2 id="从隔离的角度来看Unix接口"><a href="#从隔离的角度来看Unix接口" class="headerlink" title="从隔离的角度来看Unix接口"></a>从隔离的角度来看Unix接口</h2><p>如果我们从隔离的角度来稍微看看Unix接口，那么我们可以发现，接口被精心设计以实现资源的强隔离，也就是multiplexing和物理内存的隔离。接口通过抽象硬件资源，从而使得提供强隔离性成为可能。</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>之前通过fork创建了进程。进程本身不是CPU，但是它们对应了CPU，它们使得你可以在CPU上运行计算任务。所以你懂的，应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，进程抽象了CPU，这样操作系统才能在多个应用程序之间复用一个或者多个CPU。</p>
<p>我们在实验中使用的RISC-V处理器实际上是有4个核。所以你可以同时运行4个进程，一个进程占用一个核。但是假设你有8个应用程序，操作系统会分时复用这些CPU核，比如说对于一个进程运行100毫秒，之后内核会停止运行并将那个进程从CPU中卸载，再加载另一个应用程序并再运行100毫秒。通过这种方式使得每一个应用程序都不会连续运行超过100毫秒。这里只是一些基本概念，我们在接下来的几节课中会具体的看这里是如何实现的。</p>
<p>我们可以认为exec抽象了内存。当我们在执行exec系统调用的时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的内存镜像。内存镜像里面包括了程序对应的指令，全局的数据。应用程序可以逐渐扩展自己的内存，但是应用程序并没有直接访问物理内存的权限，例如应用程序不能直接访问物理内存的1000-2000这段地址。不能直接访问的原因是，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。exec是这样一种系统调用，它表明了应用程序不能直接访问物理内存。</p>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p>files基本上来说抽象了磁盘。应用程序不会直接读写挂在计算机上的磁盘本身，并且在Unix中这也是不被允许的。在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。</p>
<h1 id="Defensive"><a href="#Defensive" class="headerlink" title="Defensive"></a>Defensive</h1><ul>
<li><p>防御性：当你在做内核开发时，这是一种你需要熟悉的重要思想。操作系统需要确保所有的组件都能工作，所以它需要做好准备抵御来自应用程序的攻击。如果说应用程序无意或者恶意的向系统调用传入一些错误的参数就会导致操作系统崩溃，那就太糟糕了。在这种场景下，操作系统因为崩溃了会拒绝为其他所有的应用程序提供服务。所以操作系统需要以这样一种方式来完成：操作系统需要能够应对恶意的应用程序。</p>
</li>
<li><p>隔离性：另一个需要考虑的是，应用程序不能够打破对它的隔离。应用程序非常有可能是恶意的，它或许是由攻击者写出来的，攻击者或许想要打破对应用程序的隔离，进而控制内核。一旦有了对于内核的控制能力，你可以做任何事情，因为内核控制了所有的硬件资源。</p>
</li>
</ul>
<p>所以操作系统或者说内核需要具备防御性来避免类似的事情发生。实际中，要满足这些要求还有点棘手。在Linux中，时不时的有一些内核的bug使得应用程序可以打破它的隔离域并控制内核。这里需要持续的关注，并尽可能的提供最好的防御性。当你在开发内核时，防御性是你必须掌握的一个思想。实际中的应用程序或许就是恶意的，这意味着我们需要在应用程序和操作系统之间提供强隔离性。如果操作系统需要具备防御性，那么在应用程序和操作系统之间需要有一堵厚墙，并且操作系统可以在这堵墙上执行任何它想执行的策略。</p>
<p>通常来说，需要通过硬件来实现强隔离性。这里的硬件主要包括两部分，一个是user&#x2F;kernel mode，kernel mode在RISC-V中被称为Supervisor mode但是其实是同一种东西；第二部分是page table或者虚拟内存（Virtual Memory）</p>
<p>所以，所有的处理器，如果需要运行能够支持多个应用程序的操作系统，需要同时支持user&#x2F;kernle mode和虚拟内存。具体的实现或许会有细微的差别，但是基本上来说所有的处理器需要能支持这些。</p>
<h2 id="硬件对于强隔离的支持"><a href="#硬件对于强隔离的支持" class="headerlink" title="硬件对于强隔离的支持"></a>硬件对于强隔离的支持</h2><h3 id="user-x2F-kernel-mode"><a href="#user-x2F-kernel-mode" class="headerlink" title="user&#x2F;kernel mode"></a>user&#x2F;kernel mode</h3><p>为了支持user&#x2F;kernel mode，处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行特定权限的指令（privileged instructions）；当运行在user mode时，CPU只能运行普通权限的指令（unprivileged instructions）。</p>
<ul>
<li><p>普通权限的指令都是一些你们熟悉的指令，例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等等。这些都是普通权限指令，所有的应用程序都允许执行这些指令。</p>
</li>
<li><p>特殊权限指令主要是一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。</p>
</li>
</ul>
<p>举个例子，当一个应用程序尝试执行一条特殊权限指令，因为不允许在user mode执行特殊权限指令，处理器会拒绝执行这条指令。通常来说，这时会将控制权限从user mode切换到kernel mode，当操作系统拿到控制权之后，或许会杀掉进程，因为应用程序执行了不该执行的指令。</p>
<p>在处理器里面有一个flag。在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令，就像在运算时不能除以0一样。设置那个bit位的指令必须是特殊权限指令，因为应用程序不应该能够设置那个bit到kernel mode，否则的话应用程序就可以运行各种特殊权限指令了。所以那个bit是被保护的。</p>
<ul>
<li>RISC-V还有第三种模式称为machine mode。在大多数场景下，我们会忽略这种模式，所以我们实际上有三级权限user&#x2F;kernel&#x2F;machine。</li>
</ul>
<h3 id="page-table"><a href="#page-table" class="headerlink" title="page table"></a>page table</h3><p>每一个进程都会有自己独立的page table，这样的话，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的page table中。一个进程甚至都不能随意编造一个内存地址，然后通过这个内存地址来访问其他进程的物理内存。这样就给了我们内存的强隔离性。</p>
<p>基本上来说，page table定义了对于内存的视图，而每一个用户进程都有自己对于内存的独立视图。这给了我们非常强的内存隔离性。</p>
<h1 id="User-x2F-Kernel-mode切换"><a href="#User-x2F-Kernel-mode切换" class="headerlink" title="User&#x2F;Kernel mode切换"></a>User&#x2F;Kernel mode切换</h1><p>我们可以认为user&#x2F;kernel mode是分隔用户空间和内核空间的边界，用户空间运行的程序运行在user mode，内核空间的程序运行在kernel mode。操作系统位于内核空间。</p>
<p>当ls程序运行的时候，会调用read&#x2F;write系统调用；Shell程序会调用fork或者exec系统调用，所以必须要有一种方式可以使得用户的应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供相应的服务。</p>
<h2 id="Ecall"><a href="#Ecall" class="headerlink" title="Ecall"></a>Ecall</h2><p>在RISC-V中，有一个专门的指令用来实现控制权的转换功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。</p>
<p>ECALL会跳转到内核中一个特定，由内核控制的位置。在XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。举个例子，不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。</p>
<p>在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork。</p>
<p>用户空间和内核空间的界限是一个硬性的界限，用户不能直接调用fork，用户的应用程序执行系统调用的唯一方法就是通过这里的ECALL指令。</p>
<p>假设我现在要执行另一个系统调用write，相应的流程是类似的，write系统调用不能直接调用内核中的write代码，而是由封装好的系统调用函数执行ECALL指令。所以write函数实际上调用的是ECALL指令，指令的参数是代表了write系统调用的数字。之后控制权到了syscall函数，syscall会实际调用write系统调用。</p>
<h1 id="宏内核和微内核（Monolithic-Kernel-and-Micro-Kernel）"><a href="#宏内核和微内核（Monolithic-Kernel-and-Micro-Kernel）" class="headerlink" title="宏内核和微内核（Monolithic Kernel and Micro Kernel）"></a>宏内核和微内核（Monolithic Kernel and Micro Kernel）</h1><p>现在，我们有了一种方法，可以通过系统调用或者说ECALL指令，将控制权从应用程序转到操作系统中。之后内核负责实现具体的功能并检查参数以确保不会被一些坏的参数所欺骗。所以内核有时候也被称为可被信任的计算空间（Trusted Computing Base），在一些安全的术语中也被称为TCB。</p>
<p>基本上来说，要被称为TCB，内核首先要是正确且没有Bug的。假设内核中有Bug，攻击者可能会利用那个Bug，并将这个Bug转变成漏洞，这个漏洞使得攻击者可以打破操作系统的隔离性并接管内核。所以内核真的是需要越少的Bug越好。</p>
<p>另一方面，内核必须要将用户应用程序或者进程当做是恶意的。内核的设计人员在编写和实现内核代码时，必须要有安全的思想。这个目标很难实现，因为当你的操作系统变得足够大的时候，很多事情就不是那么直观了。几乎每一个你用过的或者被广泛使用的操作系统，时不时的都有一个安全漏洞。就算被修复了，但是过了一段时间，又会出现一个新的漏洞。我们之后会介绍为什么很难让所有部分都正确工作，但是你要知道是内核需要做一些tricky的工作，需要操纵硬件，需要非常小心做检查，所以很容易就出现一些小的疏漏，进而触发一个Bug。这也是可以理解的。</p>
<h2 id="宏内核（Monolithic-Kernel）"><a href="#宏内核（Monolithic-Kernel）" class="headerlink" title="宏内核（Monolithic Kernel）"></a>宏内核（Monolithic Kernel）</h2><p>让整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。比如，XV6中，所有的操作系统服务都在kernel mode中，这种形式被称为Monolithic Kernel Design。</p>
<ul>
<li><p>在一个宏内核中，任何一个操作系统的Bug都有可能成为漏洞。因为我们现在在内核中运行了一个巨大的操作系统，出现Bug的可能性更大了。你们可以去查一些统计信息，平均每3000行代码都会有几个Bug，所以如果有许多行代码运行在内核中，那么出现严重Bug的可能性也变得更大。所以从安全的角度来说，在内核中有大量的代码是宏内核的缺点。</p>
</li>
<li><p>如果你去看一个操作系统，它包含了各种各样的组成部分，比如说文件系统，虚拟内存，进程管理，这些都是操作系统内实现了特定功能的子模块。宏内核的优势在于，因为这些子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。例如Linux，它就有很不错的性能。</p>
</li>
</ul>
<h2 id="微内核（Micro-Kernel）"><a href="#微内核（Micro-Kernel）" class="headerlink" title="微内核（Micro Kernel）"></a>微内核（Micro Kernel）</h2><p>在这种模式下，希望在kernel mode中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块，例如，内核通常会有一些IPC的实现或者是Message passing；非常少的虚拟内存的支持，可能只支持了page table；以及分时复用CPU的一些支持。</p>
<p>微内核的目的在于将大部分的操作系统运行在内核之外。所以，我们还是会有user mode以及user&#x2F;kernel mode的边界。但是我们现在会将原来在内核中的其他部分，作为普通的用户程序来运行。比如文件系统可能就是个常规的用户空间程序。</p>
<p>某种程度上来说，这是一种好的设计。因为在内核中的代码的数量较小，更少的代码意味着更少的Bug。</p>
<p>但是这种设计也有相应的问题。假设我们需要让Shell能与文件系统交互，比如Shell调用了exec，必须有种方式可以接入到文件系统中。通常来说，这里工作的方式是，Shell会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统。</p>
<p>文件系统会完成它的工作之后会向IPC系统发送回一条消息说，这是你的exec系统调用的结果，之后IPC系统再将这条消息发送给Shell。</p>
<p>所以，这里是典型的通过消息来实现传统的系统调用。现在，对于任何文件系统的交互，都需要分别完成2次用户空间&lt;-&gt;内核空间的跳转。与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间&lt;-&gt;内核空间的跳转，所以微内核的的跳转是宏内核的两倍。通常微内核的挑战在于性能更差，这里有两个方面需要考虑：</p>
<ul>
<li><p>在user&#x2F;kernel mode反复跳转带来的性能损耗。</p>
</li>
<li><p>在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。</p>
</li>
</ul>
<p>在实际中，两种内核设计都会出现，出于历史原因大部分的桌面操作系统是宏内核，如果你运行需要大量内核计算的应用程序，例如在数据中心服务器上的操作系统，通常也是使用的宏内核，主要的原因是Linux提供了很好的性能。但是很多嵌入式系统，例如Minix，Cell，这些都是微内核设计。这两种设计都很流行，如果你从头开始写一个操作系统，你可能会从一个微内核设计开始。但是一旦你有了类似于Linux这样的宏内核设计，将它重写到一个微内核设计将会是巨大的工作。并且这样重构的动机也不足，因为人们总是想把时间花在实现新功能上，而不是重构他们的内核。</p>
<h1 id="编译运行Kernel"><a href="#编译运行Kernel" class="headerlink" title="编译运行Kernel"></a>编译运行Kernel</h1><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul>
<li><p>kernel：里面包含了基本上所有的内核文件。因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。</p>
</li>
<li><p>user：这基本上是运行在user mode的程序。这也是为什么一个目录称为kernel，另一个目录称为user的原因。</p>
</li>
<li><p>mkfs：它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。</p>
</li>
</ul>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><ul>
<li><p>Makefile（XV6目录下的文件）会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。</p>
</li>
<li><p>Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。</p>
</li>
<li><p>之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。</p>
</li>
<li><p>这里生成的内核文件就是我们将会在QEMU中运行的文件。同时，为了你们的方便，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，你们可以通过查看它来定位究竟是哪个指令导致了Bug。</p>
</li>
</ul>
<h2 id="传给QEMU的几个参数"><a href="#传给QEMU的几个参数" class="headerlink" title="传给QEMU的几个参数"></a>传给QEMU的几个参数</h2><ul>
<li><p>kernel ：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。</p>
</li>
<li><p>-m ：这里传递的是RISC-V虚拟机将会使用的内存数量。</p>
</li>
<li><p>smp：这里传递的是虚拟机可以使用的CPU核数</p>
</li>
<li><p>-drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件</p>
</li>
</ul>
<h1 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h1><p>直观来看，QEMU是一个大型的开源C程序，你可以下载或者git clone它。但是在内部，在QEMU的主循环中，只在做一件事情：</p>
<ul>
<li><p>读取4字节或者8字节的RISC-V指令。</p>
</li>
<li><p>解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。</p>
</li>
<li><p>之后，在软件中执行相应的指令。</p>
</li>
</ul>
<p>这基本上就是QEMU的全部工作了，对于每个CPU核，QEMU都会运行这么一个循环。</p>
<h1 id="XV6的启动过程"><a href="#XV6的启动过程" class="headerlink" title="XV6的启动过程"></a>XV6的启动过程</h1><p>QEMU 是一个通用的开源处理器模拟器和虚拟化程序，可以用于在物理计算机上模拟设备，并运行各种操作系统，如 xv6。以下是结合 QEMU 源代码和 xv6 源代码说明启动过程的概述：</p>
<ol>
<li><p><strong>启动 QEMU</strong>：从命令行启动 QEMU，并指定要加载的操作系统映像（在这种情况下为 xv6 操作系统）。命令可能如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">qemu-<span class="keyword">system</span>-i386 -nographic -<span class="type">serial</span> mon:stdio -hdb fs.img xv6.img -s -S</span><br></pre></td></tr></table></figure>

<p>在这里，<code>qemu-system-i386</code> 是针对 x86（32 位）系统的 QEMU 模拟器，<code>-nographic</code> 参数表示不使用图形界面，<code>-serial mon:stdio</code> 表示将监视器（QEMU 控制台）连接到标准输入&#x2F;输出，<code>-hdb fs.img</code> 指定要加载的 xv6 文件系统映像，<code>xv6.img</code> 是 xv6 操作系统映像，<code>-s</code> 和 <code>-S</code> 参数用于调试。</p>
</li>
<li><p><strong>QEMU 初始化虚拟硬件</strong>：QEMU 将根据所指定的参数和配置，初始化虚拟处理器、内存、硬盘和其他硬件设备。</p>
</li>
<li><p><strong>加载引导程序</strong>：QEMU 模拟 BIOS 行为，将 xv6.img 映像中的启动扇区加载到内存中，并将控制权交给这段代码。在 xv6 的情况下，引导程序位于 <code>bootasm.S</code>（汇编代码）和 <code>bootmain.c</code>（C 代码）中。</p>
</li>
<li><p><strong>引导程序运行</strong>：接下来的步骤与实际硬件上的启动过程相同。引导程序首先切换到保护模式，然后加载 ELF 格式的 xv6 内核映像到内存中。</p>
</li>
<li><p><strong>进入 xv6 内核</strong>：引导程序找到 xv6 内核的入口点（在 <code>kernel/entry.S</code> 中），并将控制权交给内核。内核现在开始运行并执行初始化任务。</p>
</li>
<li><p><strong>内核初始化</strong>：在 <code>main.c</code> 中的 <code>main()</code> 函数中，xv6 内核执行诸如设置分页、初始化中断控制器、初始化进程调度器等初始化任务。</p>
</li>
<li><p><strong>创建初始进程</strong>：xv6 创建第一个内核进程（<code>initcode.S</code>），它是一个用户程序，负责启动其他用户进程。内核通过 <code>fork()</code> 系统调用创建新进程，并通过 <code>exec()</code> 系统调用加载并执行 <code>initcode.S</code>。</p>
</li>
<li><p><strong>运行 init 进程</strong>：<code>initcode.S</code> 调用 <code>init</code> 程序（在 <code>init.c</code> 中），<code>init</code> 是一个用户空间程序，负责启动系统的第一个正常用户进程，通常是一个 shell 程序。在 xv6 中，这个程序是 <code>sh.c</code>。</p>
</li>
<li><p><strong>运行 shell 程序</strong>：<code>init</code> 进程通过 <code>fork()</code> 和 <code>exec()</code> 创建并运行 shell 程序。这时，用户可以在 shell 中输入命令并与操作系统进行交互。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>MIT6.S081 Operating System Engineering</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6 S081 Operating System Engineering Lecture05 Calling conventions and stack frames RISC-V(TA)</title>
    <url>/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/</url>
    <content><![CDATA[<h1 id="C程序到汇编程序的转换"><a href="#C程序到汇编程序的转换" class="headerlink" title="C程序到汇编程序的转换"></a>C程序到汇编程序的转换</h1><p>当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。</p>
<p>所以通常来说，要让C语言能够运行在你的处理器之上。我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。</p>
<p>如果你们曾经注意过你们的lab目录，在运行完<em>make qemu</em>之后你会看到一些.o文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些.asm文件，这是由C语言编译生成的。</p>
<p>汇编语言不具备C语言的组织结构，在汇编语言中你只能看到一行行的指令，比如add，mult等等。汇编语言中没有很好的控制流程，没有循环（注，但是有基于lable的跳转），虽然有函数但是与你们知道的C语言函数不太一样，汇编语言中的函数是以label的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如C++，都会编译成汇编语言。运行任何编译型语言之前都需要先生成汇编语言。</p>
<p>以上就是让计算机能够理解我们的C代码的基本流程。</p>
<h1 id="RISC-V-vs-X86"><a href="#RISC-V-vs-X86" class="headerlink" title="RISC-V vs X86"></a>RISC-V vs X86</h1><p>RISC-V和x86并没有它们第一眼看起来那么相似。RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。这两者之间有一些关键的区别：</p>
<ul>
<li><p>首先是指令的数量。实际上，创造RISC-V的一个非常大的初衷就是因为Intel手册中指令数量太多了。x86-64指令介绍由3个文档组成，并且新的指令以每个月3条的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有多于15000条指令。RISC-V指令介绍由两个文档组成。在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣或者你发现你不能理解某个具体的指令的话，在课程网站的参考页面有RISC-V指令的两个文档链接。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多的多。这是有关RISC-V比较好的一个方面。所以在RISC-V中，我们有更少的指令数量。</p>
</li>
<li><p>除此之外，RISC-V指令也更加简单。在x86-64中，很多指令都做了不止一件事情。这些指令中的每一条都执行了一系列复杂的操作并返回结果。但是RISC-V不会这样做，RISC-V的指令趋向于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员的在底层设计时的取舍。并没有一些非常确定的原因说RISC比CISC更好。它们各自有各自的使用场景。</p>
</li>
<li><p>相比x86来说，RISC另一件有意思的事情是它是开源的。这是市场上唯一的一款开源指令集，这意味着任何人都可以为RISC-V开发主板。RISC-V是来自于UC-Berkly的一个研究项目，之后被大量的公司选中并做了支持，网上有这些公司的名单，许多大公司对于支持一个开源指令集都感兴趣。</p>
</li>
</ul>
<p>比如说ARM也是一个精简指令集，高通的Snapdragon处理器就是基于ARM。如果你使用一个Android手机，那么大概率你的手机运行在精简指令集上。如果你使用IOS，苹果公司也实现某种版本的ARM处理器，这些处理器运行在iPad，iPhone和大多数苹果移动设备上，甚至对于Mac，苹果公司也在尝试向ARM做迁移（注，刚刚发布的Macbook）。所以精简指令集出现在各种各样的地方。如果你想在现实世界中找到RISC-V处理器，你可以在一些嵌入式设备中找到。所以RISC-V也是有应用的，当然它可能没有x86那么流行。</p>
<p>在最近几年，由于Intel的指令集是在是太大了，精简指令集的使用越来越多。Intel的指令集之所以这么大，是因为Intel对于向后兼容非常看重。所以一个现代的Intel处理器还可以运行30&#x2F;40年前的指令。Intel并没有下线任何指令。而RISC-V提出的更晚，所以不存在历史包袱的问题。我们需要许多指令来实现向后兼容，向后兼容是否重要因人而异。另一方面，我认为这里许多指令都是cmd指令，用来完成一些特殊的操作。我从来没有见过一个Intel的汇编代码使用了所有的15000个指令。大多数这些指令都是为了向后兼容和cmd的需求创建。</p>
<p>如果查看RISC-V的文档，可以发现RISC-V的特殊之处在于：它区分了Base Integer Instruction Set和Standard Extension Instruction Set。Base Integer Instruction Set包含了所有的常用指令，比如add，mult。除此之外，处理器还可以选择性的支持Standard Extension Instruction Set。例如，一个处理器可以选择支持Standard Extension for Single-Precision Float-Point。这种模式使得RISC-V更容易支持向后兼容。 每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。</p>
<h1 id="gdb和汇编代码执行"><a href="#gdb和汇编代码执行" class="headerlink" title="gdb和汇编代码执行"></a>gdb和汇编代码执行</h1><p>这部分还不太会操作</p>
<h1 id="RISC-V寄存器"><a href="#RISC-V寄存器" class="headerlink" title="RISC-V寄存器"></a>RISC-V寄存器</h1><img title src="/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/Register.webp" alt data-align="center">

<p>这个表里面是RISC-V寄存器。寄存器是CPU或者处理器上，预先定义的可以用来存储数据的位置。寄存器之所以重要是因为汇编代码并不是在内存上执行，而是在寄存器上执行，也就是说，当我们在做<code>add</code>，<code>sub</code>时，我们是对寄存器进行操作。所以我们通常看到的汇编代码中的模式是，我们通过<code>load</code>将数据存放在寄存器中，这里的数据源可以是来自内存，也可以来自另一个寄存器。之后我们在寄存器上执行一些操作。如果我们对操作的结果关心的话，我们会将操作的结果<code>store</code>在某个地方。这里的目的地可能是内存中的某个地址，也可能是另一个寄存器。这就是通常使用寄存器的方法。</p>
<p>寄存器进行任何运算和数据读取的最快的方式。当调用函数时，我们调用函数时，我们会用ABI名字。</p>
<p><code>a0</code>到<code>a7</code>寄存器是用来作为函数的参数。如果一个函数有超过8个参数，我们就需要用内存了。从这里也可以看出，当可以使用寄存器的时候，我们不会使用内存，我们只在不得不使用内存的场景才使用它。</p>
<p>表单中的第4列，Saver列，当我们在讨论寄存器的时候也非常重要。它有两个可能的值Caller，Callee。</p>
<ul>
<li><p>Caller Saved寄存器在函数调用的时候不会保存</p>
</li>
<li><p>Callee Saved寄存器在函数调用的时候会保存</p>
</li>
</ul>
<p>这里的意思是，一个Caller Saved寄存器可能被其他函数重写。假设我们在函数a中调用函数b，任何被函数a使用的并且是Caller Saved寄存器，调用函数b可能重写这些寄存器。我认为一个比较好的例子就是Return address寄存器（注，保存的是函数返回的地址），你可以看到ra寄存器是Caller Saved，这一点很重要，它导致了当函数a调用函数b的时侯，b会重写Return address。所以基本上来说，任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。</p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。</p>
<p>对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样，即使在这个图里面看起来是一样大的。不同的函数有不同数量的本地变量，不同的寄存器，所以Stack Frame的大小是不一样的。但是有关Stack Frame有两件事情是确定的：</p>
<ul>
<li><p>Return address总是会出现在Stack Frame的第一位</p>
</li>
<li><p>指向前一个Stack Frame的指针也会出现在栈中的固定位置</p>
</li>
</ul>
<p>有关Stack Frame中有两个重要的寄存器，第一个是SP（Stack Pointer），它指向Stack的底部并代表了当前Stack Frame的位置。第二个是FP（Frame Pointer），它指向当前Stack Frame的顶部。因为Return address和指向前一个Stack Frame的的指针都在当前Stack Frame的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。</p>
<p>我们保存前一个Stack Frame的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个Frame Pointer存储到FP寄存器中。所以我们使用Frame Pointer来操纵我们的Stack Frames，并确保我们总是指向正确的函数。</p>
<p>Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。所以通常，在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epollgue。</p>
<h1 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h1><p>基本上来说，struct在内存中是一段连续的地址，如果我们有一个struct，并且有f1，f2，f3三个字段。当我们创建这样一个struct时，内存中相应的字段会彼此相邻。你可以认为struct像是一个数组，但是里面的不同字段的类型可以不一样。</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>MIT6.S081 Operating System Engineering</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6 S081 Operating System Engineering Lecture04 Page Tables</title>
    <url>/2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/</url>
    <content><![CDATA[<h1 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h1><ul>
<li><p><strong>Address Spaces</strong></p>
</li>
<li><p><strong>支持虚拟内存的硬件</strong></p>
</li>
<li><p><strong>XV中的虚拟内存代码</strong></p>
</li>
</ul>
<h1 id="Address-Spaces"><a href="#Address-Spaces" class="headerlink" title="Address Spaces"></a>Address Spaces</h1><h2 id="为什么需要隔离性"><a href="#为什么需要隔离性" class="headerlink" title="为什么需要隔离性"></a>为什么需要隔离性</h2><p>创造虚拟内存的一个出发点是你可以通过它实现隔离性。如果你正确的设置了<code>page table</code>，并且通过代码对它进行正确的管理，那么原则上你可以实现强隔离。</p>
<p>我们期望的是，每个用户程序都被装进一个盒子里，这样它们就不会彼此影响了。类似的，我们也想让它们与内核操作系统相互独立，这样如果某个应用程序无意或者故意做了一些坏事，也不会影响到操作系统。</p>
<p>如果我们不做任何工作，默认情况下我们是没有内存隔离性的。</p>
<p>RISC-V主板上，内存是由一些DRAM芯片组成。在这些DRAM芯片中保存了程序的数据和代码。例如内存中的某一个部分是内核，包括了文本，数据，栈等等；如果运行了<code>Shell</code>，内存中的某个部分就是<code>Shell</code>；如果运行了<code>cat</code>程序，内存中的某个部分是<code>cat</code>程序。这里说的都是物理内存，它的地址从0开始到某个大的地址结束。结束地址取决于我们的机器现在究竟有多少物理内存。所有程序都必须存在于物理内存中，否则处理器甚至都不能处理程序的指令。</p>
<p>这里的风险很明显。我们简单化一下场景，假设Shell存在于内存地址1000-2000之间。</p>
<p>如果<code>cat</code>出现了程序错误，将内存地址<code>1000</code>，也就是<code>Shell</code>的起始地址加载到寄存器a0中。之后执行<code>sd $7, (a0)</code>，这里等效于将7写入内存地址<code>1000</code>。</p>
<p>现在<code>cat</code>程序弄乱了<code>Shell</code>程序的内存镜像，所以隔离性被破坏了，这是我们不想看到的现象。所以，我们想要某种机制，能够将不同程序之间的内存隔离开来，这样类似的事情就不会发生。一种实现方式是地址空间（Address Spaces）。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>这里的基本概念也很简单直观，我们给包括内核在内的所有程序专属的地址空间。所以，当我们运行<code>cat</code>时，它的地址空间从0到某个地址结束。当我们运行<code>Shell</code>时，它的地址也从0开始到某个地址结束。内核的地址空间也从0开始到某个地址结束。</p>
<p>如果<code>cat</code>程序想要向地址<code>1000</code>写入数据，那么<code>cat</code>只会向它自己的地址<code>1000</code>，而不是<code>Shell</code>的地址<code>1000</code>写入数据。所以，基本上来说，每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。在这种不同地址空间的概念中，<code>cat</code>程序甚至都不具备引用属于<code>Shell</code>的内存地址的能力。这是我们想要达成的终极目标，因为这种方式为我们提供了强隔离性，<code>cat</code>现在不能引用任何不属于自己的内存。</p>
<p>所以现在我们的问题是如何在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。</p>
<ul>
<li><p>虚拟内存可以比物理内存更大，物理内存也可以比虚拟内存更大</p>
</li>
<li><p>如果太多的进程使用了虚拟内存，有可能使物理内存耗尽</p>
</li>
<li><p><code>kalloc</code>保存了空余的<code>page</code>的列表，如果这个列表为空或者耗尽了，那么<code>kalloc</code>会返回一个空指针，内核会妥善处理并将结果返回给用户应用程序。并告诉用户应用程序，要么是对这个应用程序没有额外的内存了，要么整个机器都没有内存了。</p>
</li>
</ul>
<h1 id="Page页表"><a href="#Page页表" class="headerlink" title="Page页表"></a>Page页表</h1><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>页表是在硬件中通过处理器和内存管理单元（Memory Management Unit）实现。</p>
<p>CPU正在执行指令，例如<code>sd $7, (a0)</code>。</p>
<p>对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。假设<code>寄存器a0</code>中是地址<code>0x1000</code>，那么这是一个虚拟内存地址。虚拟内存地址会被转到内存管理单元（MMU，Memory Management Unit）</p>
<p>内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。</p>
<p>从CPU的角度来说，一旦<code>MMU</code>打开了，它执行的每条指令中的地址都是虚拟内存地址。</p>
<p>为了能够完成虚拟内存地址到物理内存地址的翻译，<code>MMU</code>会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。举个例子，虚拟内存地址<code>0x1000</code>对应了一个我随口说的物理内存地址<code>0xFFF0</code>。这样的表单可以非常灵活。</p>
<p>通常来说，内存地址对应关系的表单也保存在内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。现在，在内存的某个位置保存了地址关系表单，我们假设这个位置的物理内存地址是<code>0x10</code>。那么在RISC-V上一个叫做<code>SATP</code>的寄存器会保存地址<code>0x10</code>。</p>
<p>这样，CPU就可以告诉<code>MMU</code>，可以从哪找到将虚拟内存地址翻译成物理内存地址的表单。</p>
<p><code>page table</code>存储在内存中，<code>MMU</code>只是会去查看<code>page table</code>。</p>
<p>每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换<code>SATP</code>寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。这样的话，<code>cat</code>程序和<code>Shell</code>程序中相同的虚拟内存地址，就可以翻译到不同的物理内存地址，因为每个应用程序都有属于自己的不同的地址对应表单。</p>
<p>内核会写<code>SATP</code>寄存器，写<code>SATP</code>寄存器是一条特殊权限指令。所以，用户应用程序不能通过更新这个寄存器来更换一个地址对应表单，否则的话就会破坏隔离性。所以，只有运行在kernel mode的代码可以更新这个寄存器。</p>
<h2 id="虚拟地址到物理地址"><a href="#虚拟地址到物理地址" class="headerlink" title="虚拟地址到物理地址"></a>虚拟地址到物理地址</h2><p><img src="/2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/P18.png"></p>
<p>虚拟内存地址分为两个部分</p>
<ul>
<li><p><code>index</code>：用来查找<code>page</code></p>
</li>
<li><p><code>offset</code>：对应一个<code>page</code>中的字节</p>
</li>
</ul>
<p>当<code>MMU</code>在做地址翻译的时候，通过读取虚拟内存地址中的<code>index</code>可以知道物理内存中的<code>page</code>号，这个<code>page</code>号对应了物理内存中的4096个字节。之后虚拟内存地址中的<code>offset</code>指向了<code>page</code>中的4096个字节中的某一个，假设<code>offset</code>是12，那么<code>page</code>中的第12个字节被使用了。将<code>offset</code>加上<code>page</code>的起始地址，就可以得到物理内存地址。</p>
<h3 id="RSIC-V处理器"><a href="#RSIC-V处理器" class="headerlink" title="RSIC-V处理器"></a>RSIC-V处理器</h3><p>RISC-V的寄存器是64bit，但是并不是所有的64bit都被使用了，高25bit未被使用。</p>
<p>这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。</p>
<p>当然如果有必要的话，最新的处理器或许可以支持更大的地址空间，只需要将未使用的25bit拿出来作为虚拟内存地址的一部分即可。</p>
<p>在剩下的39bit中，有27bit被用来当作<code>index</code>，12bit被用来当作<code>offset</code>。<code>offset</code>必须是12bit，因为对应了一个<code>page</code>的4096个字节。</p>
<p>在RISC-V中，物理内存地址是56bit。所以物理内存地址可以大于单个内存地址空间，但是也最多到2^56。大多数主板还不支持2^56这么大的物理内存，但是原则上，如果你能造出这样的主板，那么最多可以支持2^56字节的物理内存。</p>
<p>物理内存地址是56bit，其中44bit是物理<code>page</code>号（<code>PPN,Physical Page Number</code>)，剩下的12bit是<code>offset</code>完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的<code>page</code>号，剩下的12bit<code>offset</code>直接拷贝过来即可。</p>
<h2 id="多级page-table"><a href="#多级page-table" class="headerlink" title="多级page table"></a>多级page table</h2><p><img src="/2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/Addresstransition.png"></p>
<p>我们之前提到的虚拟内存地址中的27bit的<code>index</code>，实际上是由3个9bit的数字组成（<code>L2</code>，<code>L1</code>，<code>L0</code>）。前9个bit被用来索引最高级的<code>page directory</code>（注：通常<code>page directory</code>是用来索引<code>page table</code>或者其他<code>page directory</code>物理地址的表单)</p>
<p>一个<code>directory</code>是4096Bytes，就跟<code>page</code>的大小是一样的。<code>Directory</code>中的一个条目被称为<code>PTE（Page Table Entry）</code>是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个<code>Directory page</code>有512个条目。</p>
<p>所以实际上，<code>SATP</code>寄存器会指向最高一级的<code>page directory</code>的物理内存地址，之后我们用虚拟内存中<code>index</code>的高9bit用来索引最高一级的<code>page directory</code>，这样我们就能得到一个<code>PPN</code>，也就是物理<code>page</code>号。这个<code>PPN</code>指向了中间级的<code>page directory</code>。</p>
<p>当我们在使用中间级的<code>page directory</code>时，我们通过虚拟内存地址中的<code>L1</code>部分完成索引。接下来会走到最低级的<code>page directory</code>，我们通过虚拟内存地址中的<code>L0</code>部分完成索引。在最低级的<code>page directory</code>中，我们可以得到对应于虚拟内存地址的物理内存地址。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>如果地址空间中大部分地址都没有使用，你不必为每一个<code>index</code>准备一个条目。举个例子，如果你的地址空间只使用了一个<code>page</code>，4096Bytes。除此之外，你没有使用任何其他的地址。现在，你需要多少个<code>page table entry</code>，或者<code>page table directory</code>来映射这一个<code>page</code>？</p>
<p>在最高级，你需要一个<code>page directory</code>。在这个<code>page directory</code>中，你需要一个数字是0的<code>PTE</code>，指向中间级<code>page directory</code>。所以在中间级，你也需要一个<code>page directory</code>，里面也是一个数字0的<code>PTE</code>，指向最低级<code>page directory</code>。所以这里总共需要3个<code>page directory</code>（也就是3 * 512个条目）。</p>
<p>而在单级<code>page table</code>中，虽然我们只使用了一个<code>page</code>，还是需要2^27个<code>PTE</code>。这个方案中，我们只需要3 * 512个<code>PTE</code>。所需的空间大大减少了。这是实际上硬件采用这种层次化的3级<code>page directory</code>结构的主要原因。</p>
<h3 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h3><ol>
<li><p><strong>物理页号（Physical Page Number，PPN）</strong>: 与物理地址字段类似，PPN存储与虚拟地址关联的物理内存地址。在RISC-V中，PTE的高位部分存储PPN。</p>
</li>
<li><p><strong>有效位（Valid，V）</strong>: 有效位表示此PTE中存储的映射是否有效。如果有效位设置为1，表示此PTE的虚拟地址已映射到物理内存中。如果设置为0，则表示该虚拟地址尚未映射。</p>
</li>
<li><p><strong>读（Read，R）</strong>: 读权限位表示允许对该页面进行读访问。</p>
</li>
<li><p><strong>写（Write，W）</strong>: 写权限位表示允许对该页面进行写访问。</p>
</li>
<li><p><strong>执行（Execute，X）</strong>: 执行权限位表示允许对该页面进行执行访问。</p>
</li>
<li><p><strong>用户（User，U）</strong>: 用户权限位表示该页面是否允许在用户模式下访问。如果设置为1，则允许用户模式访问；如果设置为0，则仅允许特权模式访问。</p>
</li>
<li><p><strong>全局（Global，G）</strong>: 全局位表示该页面是否对所有地址空间可见。如果设置为1，则表示该页面在地址空间切换时不会从转换查找缓冲器（Translation Lookaside Buffer，TLB）中清除。这对于操作系统内核和共享库等全局数据结构特别有用。</p>
</li>
<li><p><strong>访问（Accessed，A）</strong>: 访问位表示自上次清零以来该页面是否被访问过。当发生内存访问时，硬件会自动设置访问位。</p>
</li>
<li><p><strong>脏（Dirty，D）</strong>: 脏位表示自上次清零以来该页面是否被修改过。当某个页面的内容被修改时，硬件会自动设置脏位。</p>
</li>
<li><p><strong>软件可用位（Software Use，SW）</strong>: 这些位是为操作系统软件保留的，可以在页表遍历过程中用于自定义用途。</p>
</li>
</ol>
<h1 id="页表缓存（Translation-Lookaside-Buffer）"><a href="#页表缓存（Translation-Lookaside-Buffer）" class="headerlink" title="页表缓存（Translation Lookaside Buffer）"></a>页表缓存（Translation Lookaside Buffer）</h1><p>观察<code>page table</code>的结构，可以发现，当处理器从内存加载或者存储数据时，基本上都要做3次内存查找，第一次在最高级的<code>page directory</code>，第二次在中间级的<code>page directory</code>，最后一次在最低级的<code>page directory</code>。所以对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：<code>Translation Lookside Buffer</code>（通常翻译成页表缓存）。你会经常看到它的缩写<code>TLB</code>。基本上来说，这就是<code>Page Table Entry</code>的缓存，也就是<code>PTE</code>的缓存。</p>
<p>当处理器第一次查找一个虚拟地址时，硬件通过3级<code>page table</code>得到最终的<code>PPN</code>，<code>TLB</code>会保存虚拟地址到物理地址的映射关系。这样下一次当你访问同一个虚拟地址时，处理器可以查看<code>TLB</code>，<code>TLB</code>会直接返回物理地址，而不需要通过<code>page table</code>得到结果。</p>
<p><code>TLB</code>实现的具体细节不是我们要深入讨论的内容。这是处理器中的一些逻辑，对于操作系统来说是不可见的，操作系统也不需要知道<code>TLB</code>是如何工作的。你们需要知道TLB存在的唯一原因是，如果你切换了<code>page table</code>，操作系统需要告诉处理器当前正在切换<code>page table</code>，处理器会清空<code>TLB</code>。因为本质上来说，如果你切换了<code>page table</code>，<code>TLB</code>中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。所以操作系统知道<code>TLB</code>是存在的，但只会时不时的告诉操作系统，现在的TLB不能用了，因为要切换<code>page table</code>了。在RISC-V中，清空<code>TLB</code>的指令是<code>sfence_vma</code>。</p>
<p>整个CPU和<code>MMU</code>都在处理器芯片中，所以在一个RISC-V芯片中，有多个CPU核，<code>MMU</code>和<code>TLB</code>存在于每一个CPU核里面。RISC-V处理器有<code>L1 cache</code>，<code>L2 Cache</code>，有些<code>cache</code>是根据物理地址索引的，有些cache是根据虚拟地址索引的，由虚拟地址索引的<code>cache</code>位于<code>MMU</code>之前，由物理地址索引的<code>cache</code>位于<code>MMU</code>之后。</p>
<h1 id="Kernel-Page-Table"><a href="#Kernel-Page-Table" class="headerlink" title="Kernel Page Table"></a>Kernel Page Table</h1><p><img src="/2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/KernelPage.png"></p>
<p>在XV6中，<code>page table</code>是如何工作的?</p>
<p>当操作系统启动时，会从地址<code>0x80000000</code>开始运行，这个地址其实也是由硬件设计者决定的。</p>
<p>主板的设计人员决定了，在完成了虚拟到物理地址的翻译之后，如果得到的物理地址大于<code>0x80000000</code>会走向DRAM芯片，如果得到的物理地址低于<code>0x80000000</code>会走向不同的I&#x2F;O设备。这是由这个主板的设计人员决定的物理结构。</p>
<p>首先，地址<code>0</code>是保留的，地址<code>0x10090000</code>对应以太网，地址<code>0x80000000</code>对应DDR内存，处理器外的易失存储（Off-Chip Volatile Memory），也就是主板上的DRAM芯片。</p>
<p>所有的事情都是由硬件，即主板决定的，CPU只是主板的一小部分，DRAM芯片位于处理器之外。是主板设计者将处理器，DRAM和许多I&#x2F;O设备汇总在一起。对于一个操作系统来说，CPU只是一个部分，I&#x2F;O设备同样也很重要。所以当你在写一个操作系统时，你需要同时处理CPU和I&#x2F;O设备，比如你需要向互联网发送一个报文，操作系统需要调用网卡驱动和网卡来实际完成这个工作。</p>
<p>地址<code>0x1000</code>是<code>boot ROM</code>的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在<code>boot ROM</code>中的代码，当<code>boot</code>完成之后，会跳转到地址<code>0x80000000</code>，操作系统需要确保那个地址有一些数据能够接着启动操作系统。</p>
<p>物理地址还有一些其他的I&#x2F;O设备</p>
<ul>
<li><p>PLIC是中断控制器（Platform-Level Interrupt Controller）</p>
</li>
<li><p>CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。</p>
</li>
<li><p>UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。</p>
</li>
<li><p>VIRTIO disk，与磁盘进行交互。</p>
</li>
</ul>
<p>高于<code>0x80000000</code>的物理地址对应DRAM芯片，但是对于例如以太网接口，也有一个特定的低于<code>0x80000000</code>的物理地址，我们可以对这个叫做内存映射I&#x2F;O（Memory-mapped I&#x2F;O）的地址执行读写指令，来完成设备的操作。</p>
<p>地址<code>0x02000000</code>对应CLINT，当你向这个地址执行读写指令，你是向实现了CLINT的芯片执行读写。这里你可以认为你直接在与设备交互，而不是读写物理内存。</p>
<p>物理地址总共有2^56那么多，但是你不用在主板上接入那么多的内存。所以不论主板上有多少DRAM芯片，总是会有一部分物理地址没有被用到。实际上在XV6中，我们限制了内存的大小是128MB。</p>
<p>在RISC-V中有一个多路输出选择器（demultiplexer）可以帮助CPU将指令送到正确的I&#x2F;O设备。</p>
<p>两件重要的事情：</p>
<ul>
<li><p>有一些<code>page</code>在虚拟内存中的地址很靠后，比如<code>kernel stack</code>在虚拟内存中的地址就很靠后。这是因为在它之下有一个未被映射的<code>Guard page</code>，这个<code>Guard page</code>对应的<code>PTE</code>的<code>Valid</code> 标志位没有设置，这样，如果<code>kernel stack</code>耗尽了，它会溢出到<code>Guard page</code>，但是因为<code>Guard page</code>的<code>PTE</code>中<code>Valid</code>标志位未设置，会导致立即触发<code>page fault</code>，这样的结果好过内存越界之后造成的数据混乱。立即触发一个<code>panic</code>（也就是<code>page fault</code>），你就知道<code>kernel stack</code>出错了。同时我们也又不想浪费物理内存给<code>Guard page</code>，所以<code>Guard page</code>不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。&#96;</p>
<p>同时，<code>kernel stack</code>被映射了两次，在靠后的虚拟地址映射了一次，在<code>PHYSTOP</code>下的<code>Kernel data</code>中又映射了一次，但是实际使用的时候用的是上面的部分，因为有<code>Guard page</code>会更加安全。</p>
</li>
<li><p>权限：例如<code>Kernel text page</code>被标位<code>R-X</code>，意味着你可以读它，也可以在这个地址段执行指令，但是你不能向<code>Kernel text</code>写数据。通过设置权限我们可以尽早的发现Bug从而避免Bug。对于<code>Kernel data</code>需要能被写入，所以它的标志位是<code>RW-</code>，但是你不能在这个地址段运行指令，所以它的<code>X</code>标志位未被设置。（注，所以，<code>kernel text</code>用来存代码，代码可以读，可以运行，但是不能篡改，<code>kernel data</code>用来存数据，数据可以读写，但是不能通过数据伪装代码在kernel中运行）</p>
</li>
</ul>
<p>每一个用户进程都有一个对应的<code>kernel stack</code>。</p>
<p>在<code>kernel page table</code>中，有一段<code>Free Memory</code>，它对应了物理内存中的一段地址。XV6使用这段<code>free memory</code>来存放用户进程的<code>page table</code>，<code>text</code>和<code>data</code>。如果我们运行了非常多的用户进程，某个时间点我们会耗尽这段内存，这个时候<code>fork</code>或者<code>exec</code>会返回错误。</p>
<p>当kernel创建了一个进程，针对这个进程的<code>page table</code>也会从<code>Free memory</code>中分配出来。内核会为用户进程的<code>page table</code>分配几个<code>page</code>，并填入<code>PTE</code>。在某个时间点，当内核运行了这个进程，内核会将进程的根<code>page table</code>的地址加载到<code>SATP</code>中。从那个时间点开始，处理器会使用内核为那个进程构建的虚拟地址空间。</p>
<h1 id="Code-Creating-an-address-space"><a href="#Code-Creating-an-address-space" class="headerlink" title="Code:Creating an address space"></a>Code:Creating an address space</h1><p>大部分用于操作地址空间和页表的xv6代码位于vm.c（kernel&#x2F;vm.c）中。主要数据结构是<code>pagetable_t</code>，它实际上是指向RISC-V 35根页表页面的指针；<code>pagetable_t</code>可以是内核页表，也可以是每个进程的页表之一。主要函数为<code>walk</code>，该函数查找虚拟地址的<code>PTE</code>，并且<code>mappages</code>安装新映射的PTE。以<code>kvm</code>开头的函数操作内核页表；以<code>uvm</code>开头的函数操作用户页表；其他功能同时用于两者。<code>copyout</code>和<code>copyin</code>将数据复制和从作为系统调用参数提供的用户虚拟地址复制出来；它们在vm.c中因为需要明确翻译这些地址才能找到相应物理存储器。</p>
<p>在引导序列早期，<code>main</code>调用<code>kvminit</code>（kernel&#x2F;vm.c:54）使用<code>kvmmake</code>（kernel&#x2F;vm.c:20）创建内核页面表格。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  kernel_pagetable = kvmmake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pagetable_t</span></span><br><span class="line"><span class="title function_">kvmmake</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pagetable_t</span> kpgtbl;</span><br><span class="line"></span><br><span class="line">  kpgtbl = (<span class="type">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(kpgtbl, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  kvmmap(kpgtbl, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// allocate and map a kernel stack for each process.</span></span><br><span class="line">  proc_mapstacks(kpgtbl);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> kpgtbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此调用发生在xv6启动RISC-V分页之前，因此地址直接引用物理存储器。<code>kvmmake</code>首先分配一个物理存储器页面来保存根页面- 表示页面; 然后它调用<code>kvmmap</code>来安装内核所需的转换。这些转换包括内核指令和数据、<code>PHYSTOP</code>以下 的物理存储器以及实际上是设备的内存范围。</p>
<p><code>proc_mapstacks</code>（kernel&#x2F;proc.c:33）为每个进程分配一个内核堆栈。它调用<code>kvmmap</code>将每个堆栈映射到由<code>KSTACK</code>生成的虚拟地址，这样可以留出无效的堆栈保护页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a page for each process&#x27;s kernel stack.</span></span><br><span class="line"><span class="comment">// Map it high in memory, followed by an invalid</span></span><br><span class="line"><span class="comment">// guard page.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_mapstacks</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="type">char</span> *pa = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">    uint64 va = KSTACK((<span class="type">int</span>) (p - proc));</span><br><span class="line">    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kvmmap</code>（kernel&#x2F;vm.c:127）调用<code>mappages</code>（kernel&#x2F;vm.c:138），该函数为一系列虚拟地址范围安装映射到相应物理地址的页面表格中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它对于范围中的每个虚拟地址单独执行此操作，在页面间隔处执行此操作。对于要映射的每个虚拟地址，<code>mappages</code>都会调用<code>walk</code>来查找该地址<code>PTE</code>的位置。然后，它初始化<code>PTE</code>以保存相关物理页号、所需权限（<code>PTE_W</code>、<code>PTE_X</code>和&#x2F;或 <code>PTE_R</code>）和标记<code>PTE_V</code>作为有效(kernel&#x2F;vm.c:153)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 a, last;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  a = PGROUNDDOWN(va);</span><br><span class="line">  last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">    *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">    <span class="keyword">if</span>(a == last)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    a += PGSIZE;</span><br><span class="line">    pa += PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>walk</code>（kernel&#x2F;vm.c:81）模仿RISC-V分页硬件，查找虚拟地址的<code>PTE</code>。<code>walk</code>每次下降3级页面表9位。它使用每个级别的9位虚拟地址来查找下一级页面表或最终页面的<code>PTE</code>（kernel&#x2F;vm.c:87）。如果PTE无效，则尚未分配所需页面；如果设置了alloc参数，则walk将分配新的页表页并将其物理地址放入PTE中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它返回树中最低层的<code>PTE</code>地址。以上代码依赖于物理内存被直接映射到内核虚拟地址空间中。例如，当<code>walk</code>下降页面表级别时，它从<code>PTE</code>获取下一个向下级别页面表(物理)地址，并使用该地址作为虚拟地址获取下一个向下级别的 <code>PTE </code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ Switch h/w page table <span class="keyword">register</span> to the kernel<span class="number">&#x27;</span>s page table,</span><br><span class="line"><span class="comment">// and enable paging.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kvminithart</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// wait for any previous writes to the page table memory to finish.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line"></span><br><span class="line">  w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush stale entries from the TLB.</span></span><br><span class="line">  sfence_vma();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数调用<code>kvminithart</code>(kernel &#x2F; vm.c：62)安装内核页表。 它将根页表页的物理地址写入<code>satp</code>寄存器。之后CPU将使用内核页表翻译地址。由于内核使用身份映射，现在指令集合上一条指令对应正确的物理内存位置。</p>
<p>每个RISC-V CPU都会在转换前缓存TLB中相应信息，在xv6更改某一页时必须告诉CPU使相应的缓存TLB条目失效。如果没有这样做，那么在以后的某个时候，TLB可能会使用旧的缓存映射，指向此时已分配给另一个进程的物理页面，并且结果是进程可能能够涂写其他进程的内存。RISC-V有一种指令<code>sfence.vma</code>可以刷新当前CPU的<code>TLB</code>。Xv6在重新加载<code>satp</code>寄存器之后，在<code>kvminithart</code>中执行<code>sfence.vma</code>，并在跳板代码(kernel&#x2F;trampoline.S:79)中切换到36用户页表并返回用户空间前执行。</p>
<p>为了避免刷新完整的TLB，RISC-V CPU可以支持地址空间标识符（ASIDs）。然后内核只需清除特定地址空间的TLB条目即可</p>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>MIT6.S081 Operating System Engineering</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6 S081 Operating System Engineering Lecture06 Isolation and system call entry/exit</title>
    <url>/2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/</url>
    <content><![CDATA[<h1 id="Trap机制"><a href="#Trap机制" class="headerlink" title="Trap机制"></a>Trap机制</h1><h2 id="程序完成用户空间和内核空间切换的时机"><a href="#程序完成用户空间和内核空间切换的时机" class="headerlink" title="程序完成用户空间和内核空间切换的时机"></a>程序完成用户空间和内核空间切换的时机</h2><ul>
<li><p>程序执行系统调用</p>
</li>
<li><p>程序出现了类似<code>page fault</code>，运算时除以0的错误</p>
</li>
<li><p>一个设备触发了中断使得当前程序运行需要相应内核设备驱动</p>
</li>
</ul>
<h2 id="Trap"><a href="#Trap" class="headerlink" title="Trap"></a>Trap</h2><p>用户空间和内核空间的切换通常被称为<code>trap</code></p>
<p><code>trap</code>涉及了许多小心的设计和重要的细节，这些细节对于实现安全隔离和性能来说非常重要。因为很多应用程序，要么因为系统调用，要么因为<code>page fault</code>，都会频繁的切换到内核中。所以，<code>trap</code>机制要尽可能的简单，这一点非常重要。</p>
<p>我们有一些用户应用程序，例如Shell，它运行在用户空间，同时我们还有内核空间。Shell可能会执行系统调用，将程序运行切换到内核。比如XV6启动之后Shell输出的一些提示信息，就是通过执行write系统调用来输出的。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>我们需要清楚如何让程序的运行，从只拥有user权限并且位于用户空间的Shell，切换到拥有supervisor权限的内核。在这个过程中，硬件的状态将会非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。</p>
<p>每个 RISC-V CPU都有一组控制寄存器，内核会写入这些寄存器以告诉 CPU 如何处理<code>trap</code>，并且内核可以读取这些寄存器以了解发生的陷阱。RISC-V 文档包含完整的信息。riscv.h（kernel&#x2F;riscv.h:1）包含 xv6 使用的定义。以下是最重要的几个寄存器概述：</p>
<ul>
<li><p>Program Counter Register:程序计数器</p>
</li>
<li><p>表明当前mode的标志位：这个标志位表明了当前是supervisor mode还是user mode。当我们在运行shell的时候，自然是在user mode。</p>
</li>
<li><p>SATP（Supervisor Address Translation and Protection）：包含了指向page table的物理地址</p>
</li>
<li><p>STVEC（Supervisor Trap Vector Base Address Register）：指向内核中处理<code>trap</code>指令的起始地址</p>
</li>
<li><p>SEPC（Supervisor Exception Program Counter），在<code>trap</code>的过程中保存程序计数器的值</p>
</li>
<li><p>SSRATCH（Supervisor Scratch Register）内核在此处放置一个值，在处理程序开始时非常方便</p>
</li>
</ul>
<h2 id="trap处理过程中的一些操作"><a href="#trap处理过程中的一些操作" class="headerlink" title="trap处理过程中的一些操作"></a>trap处理过程中的一些操作</h2><p>在<code>trap</code>的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。在<code>trap</code>处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中普通的C程序。接下来我们先来预览一下需要做的操作：</p>
<ul>
<li><p>首先，我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在<code>trap</code>之前，你必须先在某处保存这32个用户寄存器。</p>
</li>
<li><p>PC(程序计数器)也需要在某个地方保存，我们需要能够在用户程序运行中断的位置继续执行用户程序</p>
</li>
<li><p>我们需要将mode改为supervisor mode，因为我们想要使用内核中各种各样的指令</p>
</li>
<li><p>SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射，所以在运行内核代码之前，我们需要将SATP指向kernel page table。</p>
</li>
<li><p>我们需要将堆栈寄存器指向位于内核的一个地址，因此我们需要一个堆栈来调用内核的C函数</p>
</li>
<li><p>一旦我们都设置好了，并且所有的硬件状态都适合在内核中使用，我们需要跳入内核的C代码</p>
</li>
</ul>
]]></content>
      <categories>
        <category>课程学习</category>
        <category>MIT6.S081 Operating System Engineering</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>《庄子 秋水》 阅读</title>
    <url>/2023/04/12/%E3%80%8A%E5%BA%84%E5%AD%90-%E7%A7%8B%E6%B0%B4%E3%80%8B-%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>         秋水时至，百川灌河。泾流之大，两涘渚崖之间，不辩牛马。于是焉河伯欣然自喜，以天下之美为尽在己。顺流而东行，至于北海，东面而视，不见水端。于是焉河伯始旋其面目，望洋向若而叹曰：“野语有之曰：‘闻道百，以为莫己若者。’我之谓也。且夫我尝闻少仲尼之闻而轻伯夷之义者，始吾弗信。今我睹子之难穷也，吾非至于子之门则殆矣，吾长见笑于大方之家。”北海若曰：“井蛙不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。今尔出于崖涘，观于大海，乃知尔丑，尔将可与语大理矣。天下之水，莫大于海：万川归之，不知何时止而不盈；尾闾泄之，不知何时已而不虚；春秋不变，水旱不知。此其过江河之流， 不可为量数。而吾未尝以此自多者，自以比形于天地，而受气于阴阳， 吾在于天地之间，犹小石小木之在大山也。方存乎见少，又奚以自多！ 计四海之在天地之间也，不似礨空之在大泽乎？计中国之在海内不似稊米之在太仓乎？号物之数谓之万，人处一焉；人卒九州，谷食之所生，舟车之所通，人处一焉。此其比万物也，不似豪末之在于马体乎？ 五帝之所连，三王之所争，仁人之所忧，任士之所劳，尽此矣！伯夷辞之以为名，仲尼语之以为博。此其自多也，不似尔向之自多于水乎？”</p>
<blockquote>
<p>        秋汛时节，大大小小的河流都灌入黄河之中，河流水势浩大，两岸之间一片苍茫，分不清是牛是马在那里活动。于是河伯沾沾自喜，认为天下美景都掌握在自己手中。但河伯顺着水流往东走，到达了北海，面朝大海，望着无边无际的海面，他收起了得意的神情，他仰着头向北海若感叹道：听闻许多道理，认为谁都不如自己，说的就是我这种人。而且我曾听说有人小看仲尼的见识，轻视伯夷的义气，如今我终于是相信了，今天我看到这无边无际的大海，如果没有到您这来，我大概要永远贻笑大方了。北海若说：井底之蛙不可以跟他谈论大海，因为他受空间的限制；夏天的虫不可以跟他谈论冰雪，因为他受时间的限制；浅陋的书生不可以跟他谈论大道，以为他受礼教的限制。如今你从河边来到大海，见识到了大海的无边无际，明白了自己的浅陋，那我就可以跟你讲讲大道理了。天下的水域，没有比海洋更辽阔的了，千万条江河不停的汇聚到海洋，但是海洋永远不会满，海洋从尾闾泄水，但是不知道何时才能够流尽，不论是春天还是秋天，干旱还是洪涝，海洋都丝毫不受影响。海洋的容量，比江河不知道大了多少，但是我从来不认为自己了不起。我从天地那里获得了形体，从阴阳那里获得了生气，我在天地间，就像一颗小石头在泰山之上，只会自以为小，又怎么会自满呢。想象一下，四海在天地之间，不就像一个蚁穴在大泽之中吗？一个国家在四海之间，不就像一粒米在粮仓中吗？世间物种千千万万，人只是其中一种。人聚集在九州之内，播种谷物粮食，舟车四通八达，一个人只不过是其一小部分而已。拿人和万物相比，不就像拿马身上的一根毫毛和马相比吗？五帝所继承的，三王所争夺的，仁人所忧虑的，以天下为己任的人所操劳的，其实不过如此。伯夷辞让王位来获得名声，仲尼谈论天下大事以显示知识渊博，他们自以为了不起，不就像你一样吗？</p>
</blockquote>
<p>　　河伯曰：“然则吾大天地而小豪末，可乎？”北海若曰：“否。夫物，量无穷，时无止，分无常，终始无故。是故大知观于远近，故小而不寡，大而不多：知量无穷。证向今故，故遥而不闷，掇而不跂： 知时无止。察乎盈虚，故得而不喜，失而不忧：知分之无常也。明乎坦涂，故生而不说，死而不祸：知终始之不可故也。计人之所知，不若其所不知；其生之时，不若未生之时；以其至小，求穷其至大之域， 是故迷乱而不能自得也。由此观之，又何以知毫末之足以定至细之倪， 又何以知天地之足以穷至大之域！”</p>
<blockquote>
<p>        河伯说：那么我以天地为大，以毫毛为小，这也可以吗？北海若说：不行，世间万物，在空间上是无法穷尽的，在时间上是没有止境的，不存在固定的区分，也不存在真正意义上的开始和结束。所以， 拥有大智慧的人，不以小为小，不以大为大，对于遥远的过去和将来，不会感到苦闷，对于切身体会的当下也不会刻意强求，有所得到也不会欣喜，有所失去也不会感到忧愁，因为变化是无常的。不会因为或者而雀跃，也不会因为死亡而悲恐，因为生死是无法解释的。一个人所知道的东西，远远比不上不知道的东西。一个人存活的时间，远远比不上未存活的时间。由试图用极小的事物来探究极大的范围，人们会变得迷惑不解，无法找到自己。从这个角度来看，我们怎么能知道一粒细微的尘埃足以决定最微妙的差别，又怎么能知道天地足以穷尽最大的范围呢？”</p>
</blockquote>
<p>　　河伯曰：“世之议者皆曰：‘至精无形，至大不可围。’是信情乎 ？”北海若曰：“夫自细视大者不尽，自大视细者不明。夫精，小之微也；郛，大之殷也：故异便。此势之有也。夫精粗者，期于有形者也；无形者，数之所不能分也；不可围者，数之所不能穷也。可以言论者，物之粗也；可以意致者，物之精也；言之所不能论，意之所不能察致者，不期精粗焉。是故大人之行：不出乎害人，不多仁恩；动不为利，不贱门隶；货财弗争，不多辞让；事焉不借人，不多食乎力 ，不贱贪污；行殊乎俗，不多辟异；为在从众，不贱佞谄；世之爵禄 不足以为劝，戮耻不足以为辱；知是非之不可为分，细大之不可为倪 。闻曰：‘道人不闻，至德不得，大人无己。’约分之至也。”</p>
<blockquote>
<p>        河伯问：世上的人都说，最精细的东西没有形体，最宏大的东西没有外围，这是真的吗？北海若说：以小的视角去看大的东西是看不全面的，以大的视角去看小的东西是看不清楚的，所以各有所偏，精是指小而微妙的事物；郛是指大而深远的事物：所以它们是不同的。这是因为事物的规模和形态是有差异的。所谓精和粗是对于有形的东西来说的，无形的东西就是小到无法分辨了，没有外围的东西就是大到无法计算了。可以用语言表达的是粗大的事物，可以想象的是精微的食物。无法用语言表达也不能想象的，则根本不适用于精粗的概念。因此，大人的行为：不伤害他人，不过分施恩；行动不是为了利益，不轻视门下之人；不争夺财物，不过分言辞谦让；做事不依赖他人，不过分依赖自己的力量，不轻视贪污；行为不同于俗人，不过分追求与众不同；处在大众之中，不轻视奉承谄媚；世俗的荣誉和地位不足以激发他的兴趣，屈辱和耻辱不足以使他感到羞耻；懂得是非无法明确区分，大小无法确定边界。有句话说：‘道之人不可闻，至德不可得，大人无己。’这就是对事物极限的了解。”</p>
</blockquote>
<p>　　河伯曰：“若物之外，若物之内，恶至而倪贵贱？恶至而倪小大？ ”北海若曰：“以道观之，物无贵贱；以物观之，自贵而相贱；以俗观之，贵贱不在己。以差观之，因其所大而大之，则万物莫不大；因其所小而小之，则万物莫不小。知天地之为稊米也，知毫末之为丘山也，则差数睹矣。以功观之，因其所有而有之，则万物莫不有； 因其所无而无之，则万物莫不无。知东西之相反而不可以相无，则功分定矣。以趣观之，因其所然而然之，则万物莫不然；因其所非而非 之，则万物莫不非。知尧、桀之自然而相非，则趣操睹矣。昔者尧、 舜让而帝，之、哙让而绝；汤、武争而王，白公争而灭。由此观之， 争让之礼，尧、桀之行，贵贱有时，未可以为常也。梁丽可以冲城而不可以窒穴，言殊器也；骐骥骅骝一日而驰千里，捕鼠不如狸狌，言殊技也；鸱鸺夜撮蚤，察毫末，昼出瞋目而不见丘山，言殊性也。故曰：盖师是而无非，师治而无乱乎？是未明天地之理，万物之情也。 是犹师天而无地，师阴而无阳，其不可行明矣！然且语而不舍，非愚则诬也！帝王殊禅，三代殊继。差其时，逆其俗者，谓之篡夫；当其时，顺其俗者，谓之义之徒。默默乎河伯，女恶知贵贱之门，小大之家！”</p>
<blockquote>
<p>        河伯问：在万物之外和万物之内，如何判断一件事物的贵贱和大小呢？北海若说：从大道的角度看，万物本无贵贱，从他物的角度看，都是自以为贵而以他物为贱，以世俗的角度看，贵贱不在自己，而在他人眼中，以差别的角度看，顺着大的一面来判断，则万物都是大的，顺着小的一面来判断，则万物都是小的。天地可以像一粒米一样小，毫毛也可以像一座山那么大。如果从万物的功能的角度看，如果以它们具有的功能来衡量，那么万物都有用，如果以它们没有的功能来衡量，那么万物都没有用。没有东就没有西，有和无相反相成，知道这一点，功能的区分也就明白了。如果从取向的一面去判断，如果顺着对的一面去判断，那么万物都是对的，如果顺着错的一面去判断，那么万物都是错的。就像尧、夏桀都认为自己是对的。尧、舜的禅让成为帝王，而燕王姬哙和燕相子之却因为禅让遭到灭顶之灾。商汤和周武王因为争夺而称王，白公胜却因为争斗而灭亡。从这些例子来看，争斗与禅让，尧和夏桀的行为，不能作为永恒的标准来衡量贵贱。攻城的利器不适用于堵塞小洞，这是因为器用不同。千里马可以一日千里，但捉老鼠不如狸狌，这是因为技能不同。猫头鹰虽然能在夜间捕捉跳蚤，看见秋毫之末，但是一到白天就会眼瞎，连山岳都看不到，这是因为秉性不同。人们总是说为什么不学习对的而抛弃错的，效法治世而抛弃乱世呢？这是不明白天地的道理、万物的实情才会说出的话。就像只接受天而不接受地，只接受阴而不接受阳，这显然是行不通的。帝王禅让还是继承，这是因时事而异。顺应时事和世俗，会被称为仁人义士，违背时事和世俗，会被称为大逆不道。沉默吧河伯，你哪知道怎么区分贵贱和大小。</p>
</blockquote>
<p>　　河伯曰：“然则我何为乎？何不为乎？吾辞受趣舍，吾终奈何？” 北海若曰：“以道观之，何贵何贱，是谓反衍；无拘而志，与道大蹇 。何少何多，是谓谢施；无一而行，与道参差。严乎若国之有君，其无私德；繇繇乎若祭之有社，其无私福；泛泛乎其若四方之无穷，其无所畛域。兼怀万物，其孰承翼？是谓无方。万物一齐，孰短孰长？ 道无终始，物有死生，不恃其成。一虚一满，不位乎其形。年不可举 ，时不可止。消息盈虚，终则有始。是所以语大义之方，论万物之理也。物之生也，若骤若驰。无动而不变，无时而不移。何为乎，何不为乎？夫固将自化。”</p>
<blockquote>
<p>        河伯说：那么我应该做什么，不应该做什么呢？我应该接受什么，不应该接受什么呢？北海若说：从道的角度看，没有贵贱之分，要回归道的本源。要做到无拘无束，心怀大道，顺应大道。不要计较物质的多少，学会舍弃得失。要做到无私，无所谓长短，与道同在。要像国家有君王一样严肃，但要无私地行德。要像祭祀有社稷一样庄重，但要追求无私的福报。要像四方一样无边无际，没有界限。要包容万物，没有固定的方向，这就是无方。不要计较万物的短长，道是无始无终的，万物则有生有死，不依赖于成就。一切的虚实、盈虚都不受形态所限。时间不可挽留，此虚彼赢，此消彼长，这里结束那里就开始，事物产生后，如快马奔驰般急速变化，一刻也不会停止。所以应该做什么不应该做什么？事物本身就在不断变化着啊。</p>
</blockquote>
<p>　　河伯曰：“然则何贵于道邪？”北海若曰：“知道者必达于理，达 于理者必明于权，明于权者不以物害己。至德者，火弗能热，水弗能溺，寒暑弗能害，禽兽弗能贼。非谓其薄之也，言察乎安危，宁于祸福，谨于去就，莫之能害也。故曰：‘天在内，人在外，德在乎天。 ’知天人之行，本乎天，位乎得，踯躅而屈伸，反要而语极。”曰： “何谓天？何谓人？”北海若曰：“牛马四足，是谓天；落马首，穿牛鼻，是谓人。故曰：‘无以人灭天，无以故灭命，无以得殉名。谨守而勿失，是谓反其真。‘“</p>
<blockquote>
<p>        河伯说：那么大道有什么用呢？北海若说：知晓大道，就能通达事物的道理，通达事物的道理，就能懂得随机应变，懂得随机应变，也就不会让外物侵害自己。得到之人，火不能烧，水不能淹，寒暑不能侵扰，禽兽不能伤害。并不是说他能够对抗这些东西，而是说他懂得观察安慰，并能在福祸之中保持安稳的心态，能够谨慎的进退，也就没有什么能够伤害他们了。所以说：天道是内在的根源，人为是外在的表象，真正的德在于遵循天道，明白一切人事，本源是天道。了解天与人的规律，要遵循自然法则，找到恰当的位置，灵活适应各种情况，回归根本，探究极致。河伯问：什么是天？什么是人？北海若说：牛和马长了四条腿，这就是天道，把辔头装在马头，把牛鼻子穿孔，这就是认为。所以说：不能让人为破坏自然法则，不能让造作毁灭性命，不以贪欲追求虚名，守住自然的天性，这就叫做返回最初的本真。</p>
</blockquote>
<p>　　夔怜蚿，蚿怜蛇，蛇怜风，风怜目，目怜心。夔谓蚿曰：“吾以一 足趻踔而不行，予无如矣。今子之使万足，独奈何？”蚿曰：“不然。 子不见夫唾者乎？喷则大者如珠，小者如雾，杂而下者不可胜数也。 今予动吾天机，而不知其所以然。”蚿谓蛇曰：“吾以众足行，而不及子之无足，何也？”蛇曰：“夫天机之所动，何可易邪？吾安用足 哉！”蛇谓风曰：“予动吾脊胁而行，则有似也。今子蓬蓬然起于北海，蓬蓬然入于南海，而似无有，何也？”风曰：“然，予蓬蓬然起于北海而入于南海也，然而指我则胜我，鰌我亦胜我。虽然，夫折大木，蜚大屋者，唯我能也。”故以众小不胜为大胜也。为大胜者，唯圣人能之。</p>
<blockquote>
<p>        独脚兽羡慕多足虫，多足虫羡慕蛇，蛇羡慕风，风羡慕眼，眼羡慕心。独脚兽跟多足虫说：我用一条腿走路都困难，你是怎么用那么多条腿走路的呢？多足虫说：我也是自然行走，我也不知道为什么这样。多足虫问蛇：我用这么多条腿走路结果还不如你不用腿走路走得快，为什么呢？蛇说：这是天然的机制，改变不了的，我哪用得着脚呢？蛇对风说：我用身体走路还有形迹，你呼呼从北海吹到南海，一点形迹也没有，为什么呢？风说：是的，我能呼呼的从北海吹到南海，但是手指脚踢我做不到啊。但是，吹断大树，吹翻房子只有我能做到。所以，以做不成众多小事为代价，成就大事，只有圣人能做到。 </p>
</blockquote>
<p>　孔子游于匡，宋人围之数币，而弦歌不惙。子路入见，曰：“何夫子之娱也？”孔子曰：“来，吾语女！我讳穷久矣，而不免，命也；求通久矣，而不得，时也。当尧、舜而天下无穷人，非知得也；当桀、纣而天下无通人，非知失也。时势适然。夫水行不避蛟龙者，渔人之勇也。陆行不避兕虎者，猎夫之勇也。白刃交于前，视死若生者，烈士之勇也。知穷之有命，知通之有时，临大难而不惧者，圣人之勇也。由，处矣！吾命有所制矣！”  无几何，将甲者进，辞曰：“以为阳虎也，故围之；今非也，请辞而退。”</p>
<blockquote>
<p>        孔子周游到匡地，卫国人一层又一层地包围了他，可是孔子仍在不停地弹琴诵读。子路进去见孔子说：“先生如此快乐是为什么呢？”孔子说：“来，我告诉你！我不想让自己困苦已经很久很久了，可是始终不能免除，这是命运啊。我寻求通达也已经很久很久了，可是始终未能达到，这是时运啊。当尧、舜的时代，天下没有一个困顿潦倒的人，并非因为他们都才智超人；当桀、纣的时代，天下没有一个通达的人，并非因为他们都才智低下。这都是时运所造成的。在水里活动而不躲避蛟龙的，乃是渔夫的勇敢；在陆上活动而不躲避犀牛老虎的，乃是猎人的勇敢；刀剑交错地横于眼前，看待死亡犹如生还的，乃是壮烈之士的勇敢。懂得困厄潦倒乃是命中注定，知道顺利通达乃是时运造成，面临大难而不畏惧的，这就是圣人的勇敢。仲由啊，你还是休息去吧！我这是命中注定！”</p>
</blockquote>
<p>　　公孙龙问于魏牟曰：“龙少学先王之道，长而明仁义之行；合同异 ，离坚白；然不然，可不可；困百家之知，穷众口之辩：吾自以为至 达已。今吾闻庄子之言，茫然异之。不知论之不及与？知之弗若与？ 今吾无所开吾喙，敢问其方。”公子牟隐机大息，仰天而笑曰：“子 独不闻夫埳井之蛙乎？谓东海之鳖曰：‘吾乐与！出跳梁乎井干之上， 入休乎缺甃之崖。赴水则接腋持颐，蹶泥则没足灭跗。还虷蟹与科斗， 莫吾能若也。且夫擅一壑之水，而跨跱埳井之乐，此亦至矣。夫子奚不时来入观乎？’东海之鳖左足未入，而右膝已絷矣。于是逡巡而却， 告之海曰：‘夫千里之远，不足以举其大；千仞之高，不足以极其深。 禹之时，十年九潦，而水弗为加益；汤之时，八年七旱，而崖不为加损。夫不为顷久推移，不以多少进退者，此亦东海之大乐也。’于是 埳井之蛙闻之，适适然惊，规规然自失也。且夫知不知是非之竟，而 犹欲观于庄子之言，是犹使蚊负山，商蚷驰河也，必不胜任矣。且夫 知不知论极妙之言，而自适一时之利者，是非埳井之蛙与？且彼方跐 黄泉而登大皇，无南无北，爽然四解，沦于不测；无东无西，始于玄冥，反于大通。子乃规规然而求之以察，索之以辩，是直用管窥天， 用锥指地也，不亦小乎？子往矣！且子独不闻夫寿陵余子之学于邯郸 与？未得国能，又失其故行矣，直匍匐而归耳。今子不去，将忘子之故，失子之业。”公孙龙口呿而不合，舌举而不下，乃逸而走。</p>
<blockquote>
<p>        公孙龙向魏牟问道：“我年少的时候学习古代圣王的主张，长大以后懂得了仁义的行为；能够把事物的不同与相同合而为一，把一个物体的质地坚硬与颜色洁白分离开来；能够把不对的说成是对的，把不应认可的看作是合宜的；能够使百家智士困惑不解，能够使众多善辩之口理屈辞穷：我自以为是最为通达的了。如今我听了庄子的言谈，感到十分茫然。不知是我的论辩比不上他呢，还是我的知识不如他呢？现在我已经没有办法再开口了，冒昧地向你请教其中的道理。”<br>　　魏牟靠着几案深深地叹了口气，然后又仰头朝天笑着说：“你不曾听说过那浅井里的青蛙吗？井蛙对东海里的鳖说：‘我实在快乐啊！我跳跃玩耍于井口栏杆之上，进到井里便在井壁砖块破损之处休息。跳入水中井水漫入腋下并且托起我的下巴，踏入泥里泥水就盖住了我的脚背，回过头来看看水中的那些赤虫、小蟹和蝌蚪，没有谁能像我这样的快乐！再说我独占一坑之水、盘踞一口浅井的快乐，这也是极其称心如意的了。你怎么不随时来井里看看呢？’东海之鳖左脚还未能跨入浅井，右膝就已经被绊住。于是迟疑了一阵子之后又把脚退了出来，把大海的情况告诉给浅井的青蛙，说：‘千里的遥远，不足以称述它的大；千仞的高旷，不足于探究它的深。夏禹时代十年里有九年水涝，而海水不会因此增多；商汤的时代八年里有七年大旱，而岸边的水位不会因此下降。不因为时间的短暂与长久而有所改变，不因为雨量的多少而有所增减，这就是东海最大的快乐。’浅井之蛙听了这一席话，惊惶不安，茫然不知所措。再说你公孙龙的才智还不足以知晓是与非的境界，却还想去察悉庄子的言谈，这就像驱使蚊虫去背负大山，驱使马蚿虫到河水里去奔跑，必定是不能胜任的。而你的才智不足以通晓极其玄妙的言论，竟自去迎合那些一时的胜利，这不就像是浅井里的青蛙吗？况且庄子的思想主张正俯极黄泉登临苍天，不论南北，释然四散通达无阻，深幽沉寂不可探测；不论东西，起于幽深玄妙之境，返归广阔通达之域。你竟拘泥浅陋地用察视的办法去探寻它的奥妙，用论辩的言辞去索求它的真谛，这只不过是用竹管去窥视高远的苍天，用锥子去测量浑厚的大地，不是太渺小了吗！你还是走吧！而且你就不曾听说过那燕国寿陵的小子到赵国的邯郸去学习走步之事吗？未能学会赵国的本事，又丢掉了他原来的本领，最后只得爬着回去了。现在你还不尽快离开我这里，必将忘掉你原有的本领，而且也必将失去你原有的学业。”<br>　　公孙龙听了这一番话张大着口而不能合拢，舌头高高抬起而不能放下，于是快速地逃走了。</p>
</blockquote>
<p>　　庄子钓于濮水。楚王使大夫二人往先焉，曰：“愿以境内累矣！” 庄子持竿不顾，曰：“吾闻楚有神龟，死已三千岁矣。王巾笥而藏之庙堂之上。此龟者，宁其死为留骨而贵乎？宁其生而曳尾于涂中乎？ ”二大夫曰：“宁生而曳尾涂中。”庄子曰：“往矣！吾将曳尾于涂中。”</p>
<p>　　惠子相梁，庄子往见之。或谓惠子曰：“庄子来，欲代子相。”于 是惠子恐，搜于国中三日三夜。庄子往见之，曰：“南方有鸟，其名 为鹓鹐，子知之乎？夫鹓鹐发于南海而飞于北海，非梧桐不止，非练 实不食，非醴泉不饮。于是鸱得腐鼠，鹓鹐过之，仰而视之曰：‘吓！’ 今子欲以子之梁国而吓我邪？”</p>
<p>　　庄子与惠子游于濠梁之上。庄子曰：“儵鱼出游从容，是鱼之乐也。” 惠子曰∶“子非鱼，安知鱼之乐？”庄子曰：“子非我，安知我不知 鱼之乐？”惠子曰“我非子，固不知子矣；子固非鱼也，子之不知鱼 之乐，全矣！”庄子曰：“请循其本。子曰‘汝安知鱼乐’云者，既 已知吾知之而问我。我知之濠上也。”</p>
<blockquote>
<p>庄子在濮水边垂钓，楚王派遣两位大臣先行前往致意，说：“楚王愿将国内政事委托给你而劳累你了。”  </p>
<p>        庄子手把钓竿头也不回地说：“我听说楚国有一神龟，已经死了三千年了，楚王用竹箱装着它，用巾饰覆盖着它，珍藏在宗庙里。这只神龟，是宁愿死去为了留下骨骸而显示尊贵呢，还是宁愿活着在泥水里拖着尾巴呢？”两位大臣说：“宁愿拖着尾巴活在泥水里。”庄子说：“你们走吧！我仍将拖着尾巴生活在泥水里。”  </p>
<p>        惠子在梁国做宰相，庄子前往看望他。有人对惠子说：“庄子来梁国，是想取代你做宰相。”于是惠子恐慌起来，在都城内搜寻庄子，整整三天三夜。  </p>
<p>        庄子前往看望惠子，说：“南方有一种鸟，它的名字叫鹓，你知道吗？鹓从南海出发飞到北海，不是梧桐树它不会停息，不是竹子的果实它不会进食，不是甘美的泉水它不会饮用。正在这时一只鹞鹰寻觅到一只腐烂了的老鼠，鹓刚巧从空中飞过，鹞鹰抬头看着鹓，发出一声怒气：‘嚇’！如今你也想用你的梁国来怒叱我吗？”   <br>        庄子和惠子一道在濠水的桥上游玩。庄子说：“儵鱼游得多么悠闲自在，这就是鱼儿的快乐。”惠子说：“你不是鱼，怎么知道鱼的快乐？”庄子说：“你不是我，怎么知道我不知道鱼儿的快乐？”惠子说：“我不是你，固然不知道你；你也不是鱼，你不知道鱼的快乐，也是完全可以肯定的。”庄子说：“还是让我们顺着先前的话来说。你刚才所说的‘你怎么知道鱼的快乐’的话，就是已经知道了我知道鱼儿的快乐而问我，而我则是在濠水的桥上知道鱼儿快乐的。”</p>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>庄子</tag>
        <tag>道家</tag>
      </tags>
  </entry>
  <entry>
    <title>《理想国》柏拉图 阅读</title>
    <url>/2023/03/29/%E3%80%8A%E7%90%86%E6%83%B3%E5%9B%BD%E3%80%8B%E6%9F%8F%E6%8B%89%E5%9B%BE%20%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>    《理想国》作为一本必读的哲学经典，是柏拉图在思想成熟时期所著，包含了古希腊当时个个方面的问题，包括哲学、教育、军事、政治、伦理、文艺、诗歌等等。柏拉图一步步构建出理念世界，并借苏格拉底之口讨论了哲学中的一些重要问题，苏格拉底运用“辩证法”一步步让对方发现自身观点的矛盾之处，可以说是压迫感极强，甚至说是阴阳怪气。再读《理想国》，意在让自己浅薄的思想能得到升华。本人希望通过阅读总结书中的思想，可能由于时代的局限性，某些思想在现在看来可能已经过时并且不够完善，但是我们也依然可以从中汲取智慧为自己的思想所用。</p>
<h1 id="财产-正义-节制"><a href="#财产-正义-节制" class="headerlink" title="财产 正义 节制"></a>财产 正义 节制</h1><p>开篇以苏格拉底和赛弗拉的对话开始，苏格拉底从年长者的问题入手，逐步引出财产，正义的讨论，并一步步进行了论证，反驳了当时流行的观点。</p>
<blockquote>
<p>当一个人对肉体上的享受越来越少时，那他对精神上的畅谈也就要求越多。</p>
</blockquote>
<blockquote>
<p> 我向来认为年长的人就像已经翻越千山万水的老旅客，你们曾经遇到的坎坷也可能是我之后要经历的，所以我对于过来人十分愿意与他们探讨一下旅途中的艰难险阻。</p>
</blockquote>
<h2 id="人在老年阶段是否会更艰难？"><a href="#人在老年阶段是否会更艰难？" class="headerlink" title="人在老年阶段是否会更艰难？"></a>人在老年阶段是否会更艰难？</h2><p>大部分人在年老时对年老的抱怨，在于不能像以前一样吃喝玩乐、或是体验爱情的快乐、或是美好的事物已成过往，有人埋怨至亲好友的忽视，有人埋怨年老是痛苦的根源。赛弗拉讲脱离所谓的情爱比喻成从一个暴君处脱离苦海，到了老年时代，对于情爱一事早已没了兴趣，人已经清心寡欲，有了另一种自由快乐的感受。</p>
<p>赛弗拉从此入手，论证年老时之所以会抱怨连连，不是因为年纪，而是性情。如果一个人性情是恬静的、心平气和的，那么年龄大并不是痛苦，如果不是，那么不管什么年龄都会是痛苦的。</p>
<p>苏格拉底故意激赛弗拉继续回答，苏格拉底评价赛弗拉是因为家财万贯而不是因为性情恬静，所以老年时才会快乐，之后引出财富的问题。</p>
<h2 id="你从财富上得到了什么？"><a href="#你从财富上得到了什么？" class="headerlink" title="你从财富上得到了什么？"></a>你从财富上得到了什么？</h2><blockquote>
<p>  自己赚钱的人不仅因为钱有用才喜欢它，而更是因为这是他们辛苦得来的，内心生出了一种强烈的占有欲，就像诗人爱自己的诗篇，父母疼爱自己的儿女一样。我看到这种人，就觉得他们很讨厌，他们说的内容不外乎是赞美金钱之类的。</p>
</blockquote>
<p>人从财富中获得的最大的好处就是，在赚取财富时的问心无愧，没有恐慌和忧虑。在人快死亡的时候，会有一种恐慌和忧虑，担心来世受到惩罚。如果一个人知道自己造孽颇深，就会过度悲观，惊恐万分，而问心无愧的人，便会心中坦然。</p>
<h2 id="正义是什么？"><a href="#正义是什么？" class="headerlink" title="正义是什么？"></a>正义是什么？</h2><h3 id="有话实说、欠债还债是否正义？"><a href="#有话实说、欠债还债是否正义？" class="headerlink" title="有话实说、欠债还债是否正义？"></a>有话实说、欠债还债是否正义？</h3><p>不是正义，这个观点是日常生活中某个情形下的正义行为，并不是正义的定义。如果如此定义正义，便会造成有时是正义的，有时不是正义的情形。</p>
<p>柏拉图借苏格拉底之口举例：</p>
<ul>
<li><p>你有个朋友在头脑清楚的时候，曾经把武器交给你，假如他后来疯了，再要回去，任何人都会说不能还给他，如果你还给他，这是不正义的行为。</p>
</li>
<li><p>把整个真实情况告诉疯子不是正义。</p>
</li>
<li><p>如果债主是敌人，还债是对他的帮助，则还债不是正义。</p>
</li>
</ul>
<p>即当有话实说或者欠债还债的对象不同时，根据不同情况，这种行为也有可能是不正义的。苏格拉底希望找到一种普遍的正义，我们想要看一种行为是否是正义的，不能光从自身的立场出发，还要从我们的对象能否收益来检验我们的行为是否是有利于对方的，还要判断收益的对象。</p>
<h3 id="把善给予友人，把恶给予敌人是否正义？"><a href="#把善给予友人，把恶给予敌人是否正义？" class="headerlink" title="把善给予友人，把恶给予敌人是否正义？"></a>把善给予友人，把恶给予敌人是否正义？</h3><p>把善给予友人：医生把医术给予病人，舵手在航海遇到风急浪险时维护船舶的安全。</p>
<p>把恶给予敌人：在战争中与盟友攻敌。</p>
<p>苏格拉底论证，在不生病的时候，医生是没有用处的，在人们不航海的时候，舵手是没有用处的，在不打仗的时候，正义者是没有用处的。而正义在不论任何时候都是有用处的。农名在种田时有用处，鞋匠在造鞋时有用处，但是鞋匠和农民不是正义者。</p>
<p>那么在平时什么事情上必须有正义？多人合作关系，例如订合同、立契约等等。下棋能手和正义者在下棋时，下棋能手更有用处，瓦匠和正义者在砌砖盖瓦建屋时，瓦匠更有用处，琴师和正义者在奏乐时，琴师更有用处，因此有用者并不等于正义者。这说明这样的正义定义太过狭窄。</p>
<p>事实上恰恰相反，一个正义的人和政府都是在平时就能做得很好才能保持自己和国家的久安。在涉及到金钱时，花钱与保管钱，同样都有比正义者更有用处的角色存在。</p>
<p>以此类推，如果一件事物有用，那么正义就没用，正义有用，那么这件事物就没用。是在平时就能做得很好才能保持自己和国家的久安。如果说正义平时也有用比如在替朋友保管钱财方面做到以善待友，那么就会得出钱财不用时正义有用，一旦钱财被使用了正义反而无用了。最后正义还要求“以恶对敌”这是不是意谓着还要替朋友去掠取敌人的东西呢？这样正义之举不就成了小偷行为了吗？这样的驳难看似荒唐，其实正好揭露出了这个定义本身所包含的内在矛盾。</p>
<p>    而根据命题的定义，我们有时也会混淆朋友和敌人，所谓的朋友是那些看上去好的人还是实际上真正好的人呢？你所谓的敌人是看上去坏的人还是那些看上去不坏但是真的坏人呢。如果弄错了，便会导致帮助坏人，对抗好人。这个也引出善恶的问题，柏拉图在之后也借苏格拉底之口对此进行了论证。</p>
<p>    根据讨论进一步完善定义，真正善良的朋友，报之以善，真正邪恶的敌人，报之以恶，才是正义。这个定义似乎更接近真理一些了。但是考虑如下例子：正义的人是否可以伤害他人呢？伤害他人是一件恶事，正义之人一定是善人，基于此，并考虑如下例子：善于骑马的人能够凭借其起码的技能让人不会骑马吗？音乐家能够凭借其音乐上的技能使人不懂音乐吗？正义者能以他的正义使人做不正义的事情吗？我们可以认为正义者作为一个善人不应该做伤害他人的恶事。</p>
<p>    所以根据上述的讨论，正义并非是把善给予友人，把恶给予敌人。</p>
<h3 id="正义就是强者的利益"><a href="#正义就是强者的利益" class="headerlink" title="正义就是强者的利益"></a>正义就是强者的利益</h3><p>正义就是强者的利益，区别于上述判断收益的对象以及对于友人的利益，这个命题认为正义是强者的利益，所以首先要明确的是何为”强者“。如果只是因为吃的比别人好而比别人强壮，这并不是强者，我们通常提到强者，首先想到的就是统治者，制定法律的人，违反法律的人就是不正义之人，而对于政府有利的百姓就是正义。因此，有人认为，所谓正义就是当时政府的利益，正义就是强者的利益。</p>
<p>苏格拉底对此进行了反驳。</p>
<ul>
<li><p>政府不是绝对不会出错的，如果治理得当，那么他们所立的法就是基于政府的利益的，而治理出现问题，就会与政府的利益违背，此时还是正义的吗？如果是正义的便会得到，即使与政府的利益违背，人民依旧需要服从，这仍然是正义。但是如果弱者服从了，实际上是损害了强者的利益，因此与命题相违背。</p>
</li>
<li><p>如果强者的利益指的是强者实际上的利益而不是强者心中认为的利益，并且是基于严格意义上的强者，即不会犯错误的强者。</p>
<p>苏格拉底做出了一个比喻，如果说技艺是完美的，如果技艺是不完美的，例如人的身体不完备的时候，需要医术来弥补，医术不完备的时候，需要其他的技艺来弥补。假设技艺在严格意义上是完美的不需要其他任何方式弥补的话，那么医生就不会考虑自身医术的利益，而会考虑病人的利益，骑马者不会考虑骑术的利益，而会考虑马的利益。以此类推，技艺本身是没有错误的，因此他担心的便是对象的利益，因为任何技艺都是为其对象服务的。那么不会犯错的强者可以比喻成完美的技艺，百姓可以比喻成技艺所服务的对象。那么一个统治者更多顾及的便是受统治者的利益而不是自身的利益，就像完美的技艺是为它的对象服务的。即名实相符的统治者会始终以人民的利益为前提，而不是以自己的利益为前提。</p>
</li>
</ul>
<h3 id="不正义比正义更有益"><a href="#不正义比正义更有益" class="headerlink" title="不正义比正义更有益"></a>不正义比正义更有益</h3><p>有人认为正义和正义者会白白给出利益，换言之，正义意味着强者和统治者得到利益，而弱者和被统治者失去利益。不正义与之相反。例如专制君主的暴政。</p>
<p>根据苏格拉底在上文的证明，一个名实相符的统治者，无论什么事都是以被统治者的利益为目的。</p>
<p>每种技艺除了普通的利益之外，应该要给人以特殊的利益，比如医术给人以健康的利益，航海之术给人以安渡大海的利益。除此之外，技艺应当还有特殊的功用，而这种功用不能与其他技艺的功用相混合。每种技艺的利益都不能与其他的技艺混为一谈，除了它自身的特殊功用外，具有同一功用的技艺之间必定有同一利益在其中，那么技艺者所得到得报酬，应该是技艺所附带的利益，而不是技艺本身的利益。报酬与各种技艺有连带关系，而掌握技艺饿人只要各尽所能，便可以施利于人，报酬自然在其中。凡是真正的技艺家，当他工作的时候或指挥他人的时候，是以他人的利益为中心的，而不应该掺杂自己的私欲。工作没有相当的报酬是没有人愿意尽力而为的。所以，统治者或治理者的工作也必须有报酬，他们才会尽心为人民服务。他们的报酬有三种：金钱、荣誉与不愿承担责任的惩罚。</p>
<p>金钱和荣誉可以理解，而惩罚是什么意思呢？惩罚如何能作为报酬？</p>
<p>对于高尚的人，名与利都不能使之动心。他们不愿意为拿报酬去做事，被人当佣人看待，更不愿意以阴谋的手段，假公济私，被人当强盗看待。因此，只能用损毁他们高洁的名节来惩罚他们，迫使他们不得不出来做事。也正因为这个缘故，那些急于做官的人受到轻视，而那些被逼出来做官的人则感受到莫大的尊荣。这种惩罚之所以最有效，是因为如果他们不出来，就用不如他们的人来管理他们的生活和行为。因此，这些人出来做官并不是因为他们有这个志向，也不是这里面有什么可贪图的，而是因为一时没有比他们更好的人或能力相同的人。所以，对他们来说，做官实在是刀架在脖子上，迫不得已的事。假如一个国家都是高尚的人，那么不想做官的肯定不会比今日想要做官的少。因此，真正的统治是要给他人以利益，而不是给自己以利益。如此，那么有谁会不愿意被统治，接受他人的利益呢？有谁会愿意做统治者，专门给他人以利益呢？所以，不得不以惩罚的手段迫使高尚者出来做官。</p>
<p>这进一步证明了正义不是强者的利益，初步证明了不正义不一定更有益，下面进一步证明。</p>
<p>如果能够治理国家和人民的纯粹的不正义者，会比正义者有能力得多，那么不正义者就会是明智的且有美德的，而正义便是其对立面。基于此，一个正义者不能够胜过其他的正义者即没有竞争，因为正义者是不明智的且无能的，并且所作所为不能有超过正义事业之外的事情，并且正义者获得的利益不能多于不正义者。而不正义者愿意获得比正义者更多的利益，并且愿意做正义之外的事情，所以不正义者在利益的竞争上要比正义者激烈，然后才能获取更多的利益。总结如下：正义者不愿意获得比同类更多的利益，而愿意获得比异类更多的利益；不正义者即愿意获得比同类更多的利益，也愿意获得比异类更多的利益。不正义者属于善而有智慧者的同类，正义者属于其异类。</p>
<p>我们再来看技艺家，人所拥有的技艺是不同的，例如一人为音乐家，一人为非音乐家，那么就音乐上的智慧来说，音乐家是聪明的。以此类推，医生也是这样的。音乐家在调整琴弦时不会有意想胜过别的音乐家，而会有意胜过非音乐家。医生在治病时不会做超出医生范围之外的事。再以知识与愚笨来说，有知识者的言行和其他有知识者的言行差不多，而愚笨的人会想要自己的言行超过有知识和无知识的人。有知识的人是聪明的而聪明的人是善良的（这段我无法推出，可能是由于当时的局限性对于善良，聪明等的定义并不明确，上文也出现了类似的情况），聪明又善良的人仅仅希望胜过异类，而不希望胜过同类，我们基于上文的假设得到这些结论。</p>
<p>而上文说不正义者常常想要胜过同类和异类，正义者只想胜过异类，而不想胜过同类，那么正义者则与聪明又有善德的相似，不正义者与无知而又没有善的的相似。那么现在正义者变成了聪明又有善德的人，不正义者变成了无知又没有善德的人，与上一段的结论矛盾。</p>
<h3 id="正义与不正义的性质"><a href="#正义与不正义的性质" class="headerlink" title="正义与不正义的性质"></a>正义与不正义的性质</h3><p>基于我们已经证明正义是美德和智慧，不正义是没有善德和愚蠢的。那么正义者比不正义者强是不言而喻的。现在我们假设，有一个国家或一支军队或一伙强盗或任何一些作恶的团伙，如果他们成员之间整天自相残杀，那么这个团伙一定是不能成功运作的，而如果不自相残杀，那么这些团伙的运作才能进行的更好。所以不正义会引发争端和仇恨，而正义能调和彼此之间的矛盾以达到和谐。（看到这里，我们应该也明白了，柏拉图对于正义和不正义的定义也是比较模糊的，一些证明看似有道理，但是细细思考一下，就会发现其中的纰漏）不正义既然有引发争论和仇恨的性质，那么凡是在不正义的地方，不论是努力还是自由人，他们会因此相互争斗，意见分歧，而不能有共同的行动。那么不正义在二人之间，则彼此会发生争论和激战，势必会称为仇敌，并且还会称为正义的敌人。而不正义在一个人身上，不正义会是其自相矛盾，言行前后不一，所以不正义不仅仅是正义的敌人，也是自我的敌人。所以不正义即使对个人也是有害的，一是会使人的言行不一致，二是会是人三心二意，使自己称为自己的敌人，并且也成为正义的敌人。</p>
<p>哪些共同作恶的人，之所以能够进行作恶行为，还不能算是真正的不正义者，假如他们是真正的不正义者，那么他们必定会自相残害，如果他们能够联合在一起为恶，那么还有一部分正义存在于其间，所以才能进行集体的行动。</p>
<p>凡物都有其专门独特的功能和事业，也一定会有它的一个特长，就像人的眼睛有它自身独特的功能。假如眼睛的特长不完备而有缺陷，那么眼睛就不能成就它的事业。那么有正义之心的人，自然就会生活得坦然自若，终身愉快，而不正义的人刚好相反。根据以上推论，只有正义者才能生活得安乐而幸福，不正义者则不能。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>柏拉图</tag>
        <tag>理想国</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu源码 /proc/meminfo</title>
    <url>/2023/04/06/%E5%AD%A6%E4%B9%A0%20Ubuntu%E6%BA%90%E7%A0%81-proc-meminfo/</url>
    <content><![CDATA[<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MemTotal</span>:        <span class="number">3982192</span> kB 系统总内存大小</span><br><span class="line"><span class="attribute">MemFree</span>:          <span class="number">333280</span> kB 系统中未使用的内存大小</span><br><span class="line"><span class="attribute">MemAvailable</span>:    <span class="number">2062852</span> kB 系统中可供分配的内存大小，包括缓存和缓冲区</span><br><span class="line"><span class="attribute">Buffers</span>:          <span class="number">149848</span> kB 用于文件I/O的临时存储区域的大小</span><br><span class="line"><span class="attribute">Cached</span>:          <span class="number">1762576</span> kB 被操作系统缓存的文件大小</span><br><span class="line"><span class="attribute">SwapCached</span>:          <span class="number">356</span> kB 已被交换且在内存中的数据大小</span><br><span class="line"><span class="attribute">Active</span>:          <span class="number">1183472</span> kB 正在使用或最近被使用过的内存大小</span><br><span class="line"><span class="attribute">Inactive</span>:        <span class="number">1406216</span> kB 最近没有被使用的内存大小</span><br><span class="line"><span class="attribute">Active</span>(anon):       <span class="number">2988</span> kB 活动匿名内存大小，不包括文件</span><br><span class="line"><span class="attribute">Inactive</span>(anon):   <span class="number">723692</span> kB 非活动匿名内存大小，不包括文件</span><br><span class="line"><span class="attribute">Active</span>(file):    <span class="number">1180484</span> kB 活动文件内存大小</span><br><span class="line"><span class="attribute">Inactive</span>(file):   <span class="number">682524</span> kB 非活动文件内存大小</span><br><span class="line"><span class="attribute">Unevictable</span>:           <span class="number">0</span> kB 无法驱逐的内存大小</span><br><span class="line"><span class="attribute">Mlocked</span>:               <span class="number">0</span> kB 锁定在内存中的内存大小</span><br><span class="line"><span class="attribute">SwapTotal</span>:       <span class="number">3991548</span> kB 系统总交换空间大小</span><br><span class="line"><span class="attribute">SwapFree</span>:        <span class="number">3987928</span> kB 系统交换空间空闲内存</span><br><span class="line"><span class="attribute">Zswap</span>:                 <span class="number">0</span> kB 使用 zswap 的压缩交换缓存大小</span><br><span class="line"><span class="attribute">Zswapped</span>:              <span class="number">0</span> kB 使用 zswap 的压缩交换缓存大小</span><br><span class="line"><span class="attribute">Dirty</span>:               <span class="number">180</span> kB 等待写回磁盘的内存大小</span><br><span class="line"><span class="attribute">Writeback</span>:             <span class="number">0</span> kB 正在写回磁盘的内存大小</span><br><span class="line"><span class="attribute">AnonPages</span>:        <span class="number">676928</span> kB 未映射到文件的匿名内存大小</span><br><span class="line"><span class="attribute">Mapped</span>:           <span class="number">339472</span> kB 映射到文件的内存大小</span><br><span class="line"><span class="attribute">Shmem</span>:             <span class="number">55032</span> kB 共享内存大小</span><br><span class="line"><span class="attribute">KReclaimable</span>:     <span class="number">142032</span> kB 可回收的内核内存大小</span><br><span class="line"><span class="attribute">Slab</span>:             <span class="number">417952</span> kB 内核数据结构缓存的大小</span><br><span class="line"><span class="attribute">SReclaimable</span>:     <span class="number">142032</span> kB 可回收的 Slab 内存大小</span><br><span class="line"><span class="attribute">SUnreclaim</span>:       <span class="number">275920</span> kB 不可回收的 Slab 内存大小</span><br><span class="line"><span class="attribute">KernelStack</span>:       <span class="number">11180</span> kB 内核栈使用的内存大小</span><br><span class="line"><span class="attribute">PageTables</span>:        <span class="number">16944</span> kB 页表使用的内存大小</span><br><span class="line"><span class="attribute">NFS_Unstable</span>:          <span class="number">0</span> kB NFS 不稳定页缓存的大小</span><br><span class="line"><span class="attribute">Bounce</span>:                <span class="number">0</span> kB 用于块设备 I/O 的跳跃缓冲区大小</span><br><span class="line"><span class="attribute">WritebackTmp</span>:          <span class="number">0</span> kB 临时写回内存大小</span><br><span class="line"><span class="attribute">CommitLimit</span>:     <span class="number">5982644</span> kB 基于内存和交换空间的提交限制</span><br><span class="line"><span class="attribute">Committed_AS</span>:    <span class="number">4906744</span> kB 已提交的内存大小，包括内存和交换空间</span><br><span class="line"><span class="attribute">VmallocTotal</span>: <span class="number">34359738367</span>kB 虚拟内存分配的总量，这是系统可以使用的虚拟内存总量</span><br><span class="line"><span class="attribute">VmallocUsed</span>:      <span class="number">251220</span> kB 已使用的虚拟内存量</span><br><span class="line"><span class="attribute">VmallocChunk</span>:          <span class="number">0</span> kB 最大连续虚拟内存空闲区域的大小</span><br><span class="line"><span class="attribute">Percpu</span>:           <span class="number">134656</span> kB 每个 CPU 的内存使用量，这个值是每个 CPU 的 per-CPU 区域的大小之和</span><br><span class="line"><span class="attribute">HardwareCorrupted</span>:     <span class="number">0</span> kB 由硬件错误导致的损坏内存量</span><br><span class="line"><span class="attribute">AnonHugePages</span>:      <span class="number">4096</span> kB 用于匿名映射的大内存页的总量，这些映射不会关联到任何文件</span><br><span class="line"><span class="attribute">ShmemHugePages</span>:        <span class="number">0</span> kB 用于共享内存（shmem）的大内存页的总量</span><br><span class="line"><span class="attribute">ShmemPmdMapped</span>:        <span class="number">0</span> kB 已映射到共享内存的PMD大小，PMD 是页中间目录的缩写</span><br><span class="line"><span class="attribute">FileHugePages</span>:         <span class="number">0</span> kB 用于文件映射的大内存页的总量</span><br><span class="line"><span class="attribute">FilePmdMapped</span>:         <span class="number">0</span> kB 已映射到文件的 PMD 大小</span><br><span class="line"><span class="attribute">HugePages_Total</span>:       <span class="number">0</span>    系统配置的大内存页的总数</span><br><span class="line"><span class="attribute">HugePages_Free</span>:        <span class="number">0</span>    当前可用的大内存页的数量</span><br><span class="line"><span class="attribute">HugePages_Rsvd</span>:        <span class="number">0</span>    已预留（保留）但尚未使用的大内存页的数量</span><br><span class="line"><span class="attribute">HugePages_Surp</span>:        <span class="number">0</span>    超出系统需求的大内存页的数量，这些页可以在需要时立即分配给应用程序</span><br><span class="line"><span class="attribute">Hugepagesize</span>:       <span class="number">2048</span> kB 系统配置的大内存页的大小</span><br><span class="line"><span class="attribute">Hugetlb</span>:               <span class="number">0</span> kB 当前使用的 hugetlb 内存池的总大小，hugetlb 是大内存页的缩写</span><br><span class="line"><span class="attribute">DirectMap4k</span>:      <span class="number">202624</span> kB 使用 <span class="number">4</span>KB 大小的页映射的物理内存大小</span><br><span class="line"><span class="attribute">DirectMap2M</span>:     <span class="number">3991552</span> kB 使用 <span class="number">2</span>MB 大小的页映射的物理内存大小</span><br><span class="line"><span class="attribute">DirectMap1G</span>:     <span class="number">2097152</span> kB 使用 <span class="number">1</span>GB 大小的页映射的物理内存大小</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Ubuntu源码</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>学习路径</title>
    <url>/2023/04/08/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h1><p>学习Rust的过程涉及多个阶段。这里提供了一个详细的Rust学习计划，帮助您逐步掌握这门语言：</p>
<p><strong>1. 基础阶段</strong></p>
<ul>
<li>阅读《Rust编程语言》（The Rust Programming Language，又称”The Book”）：这是学习Rust的官方教材，为初学者提供了全面的入门知识。在线版本可免费访问：<a href="https://doc.rust-lang.org/book/">The Rust Programming Language - The Rust Programming Language</a></li>
<li>学习Rust的基本语法、数据类型、控制结构、错误处理等概念。</li>
<li>完成《The Book》中的示例和练习，以巩固所学知识。</li>
<li>参加Rust社区活动，如阅读论坛帖子、加入聊天室和邮件列表，以了解最新动态和获得帮助。</li>
</ul>
<p><strong>2. 实践阶段</strong></p>
<ul>
<li>尝试解决一些简单的编程问题，例如LeetCode上的题目，以熟悉Rust的编程范式。</li>
<li>阅读Rust编写的开源项目代码，学习他人如何使用Rust解决实际问题。</li>
<li>参与开源项目，为Rust生态做贡献。这可以帮助您熟悉实际项目中的编程实践、代码审查和协作流程。</li>
<li>开始实现自己的项目，将学到的知识应用于实践。可以从一个简单的命令行工具或Web服务开始。</li>
</ul>
<p><strong>3. 进阶阶段</strong></p>
<ul>
<li>深入了解Rust的所有权（Ownership）、借用（Borrowing）和生命周期（Lifetime）系统。这是理解Rust内存安全的关键。</li>
<li>学习Rust的并发和异步编程。掌握如何使用线程、通道、异步I&#x2F;O和<code>async/await</code>编写高性能、可扩展的Rust代码。</li>
<li>阅读Rust的官方文档，例如《Rust异步编程》（Asynchronous Programming in Rust）和《Rust标准库文档》（The Rust Standard Library Documentation），以深入了解各种概念和API。</li>
<li>学习Rust的宏（Macros）系统，了解如何编写DRY（Don’t Repeat Yourself）代码和元编程。</li>
</ul>
<p><strong>4. 专业阶段</strong></p>
<ul>
<li><p>探索Rust在不同领域的应用，例如Web开发、嵌入式系统、游戏开发、区块链等。</p>
</li>
<li><p>阅读有关Rust性能优化、安全性和最佳实践的文章和教程。</p>
</li>
<li><p>参加Rust会议和研讨会，与其他Rust开发者交流经验和技巧。</p>
</li>
<li><p>考虑投入到Rust生态系统的开发中，例如编写库、工具和框架，为社区提供贡献。</p>
</li>
</ul>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>C++是一门功能强大的编程语言，学习过程可以分为多个阶段。以下是一份详细的C++学习计划，帮助您逐步掌握C++：</p>
<p><strong>1. 基础阶段</strong></p>
<ul>
<li>阅读C++的经典教材，如《C++ Primer》(by Stanley B. Lippman, Josée Lajoie, and Barbara E. Moo) 或《C++程序设计原理与实践》（Programming: Principles and Practice Using C++, by Bjarne Stroustrup）。</li>
<li>学习C++的基本语法、数据类型、控制结构、函数、类和对象等概念。</li>
<li>练习编写简单的C++程序，巩固所学知识。</li>
<li>参加在线C++社区活动，如Stack Overflow和C++ subreddit，了解最新动态和获得帮助。</li>
</ul>
<p><strong>2. 实践阶段</strong></p>
<ul>
<li>学习使用C++标准库（STL），掌握容器、算法和迭代器等重要概念。</li>
<li>尝试解决一些实际编程问题，例如LeetCode上的题目，以熟悉C++编程范式。</li>
<li>阅读开源C++项目的代码，学习他人如何使用C++解决实际问题。</li>
<li>参与开源项目，为C++生态做贡献。这可以帮助您熟悉实际项目中的编程实践、代码审查和协作流程。</li>
<li>开始实现自己的项目，将学到的知识应用于实践。可以从一个简单的命令行工具或图形界面应用开始。</li>
</ul>
<p><strong>3. 进阶阶段</strong></p>
<ul>
<li>深入学习C++的高级特性，如模板、异常处理、智能指针、多态等。</li>
<li>学习C++的并发和多线程编程，掌握线程、互斥量、条件变量等概念。</li>
<li>阅读有关C++性能优化、内存管理和最佳实践的文章和教程。</li>
<li>学习C++11、C++14、C++17、C++20等新标准中的新特性，以便编写现代、高效的C++代码。</li>
</ul>
<p><strong>4. 专业阶段</strong></p>
<ul>
<li>探索C++在不同领域的应用，例如游戏开发、高性能计算、嵌入式系统等。</li>
<li>学习使用C++编写跨平台应用程序，使用诸如Qt等框架。</li>
<li>参加C++会议和研讨会，与其他C++开发者交流经验和技巧。</li>
<li>考虑投入到C++生态系统的开发中，例如编写库、工具和框架，为社区提供贡献。</li>
</ul>
<h1 id="云系统内核安全"><a href="#云系统内核安全" class="headerlink" title="云系统内核安全"></a>云系统内核安全</h1><p>云系统内核安全是一个高度专业化的领域，涉及操作系统、虚拟化技术、硬件安全等多方面知识。以下是一份详细的云系统内核安全学习计划，帮助您逐步掌握相关知识：</p>
<p><strong>1. 基础阶段</strong></p>
<ul>
<li>学习计算机组成原理和计算机体系结构，了解CPU、内存、IO设备等基本概念。</li>
<li>学习操作系统基础知识，如进程、线程、内存管理、文件系统、设备驱动等。</li>
<li>学习网络基础知识，掌握TCP&#x2F;IP协议栈、网络设备、网络安全等概念。</li>
</ul>
<p><strong>2. 虚拟化技术阶段</strong></p>
<ul>
<li>学习虚拟化技术的基本原理，了解全虚拟化和半虚拟化的区别。</li>
<li>学习常见的虚拟化平台，如VMware、KVM、Xen、Hyper-V等，了解它们的架构和特点。</li>
<li>学习容器技术，如Docker和Kubernetes，了解与虚拟机相比的优势和局限。</li>
</ul>
<p><strong>3. 云安全阶段</strong></p>
<ul>
<li>学习云计算的基本概念，了解IaaS、PaaS、SaaS等服务模型。</li>
<li>学习主流云服务提供商（如AWS、Azure、Google Cloud、阿里云等）的安全服务和最佳实践。</li>
<li>了解云安全的共享责任模型，学会在云环境中保护数据、网络、应用和用户的安全。</li>
</ul>
<p><strong>4. 内核安全阶段</strong></p>
<ul>
<li>深入学习操作系统内核，了解内核态和用户态的区别，学习内核编程。</li>
<li>学习内核漏洞的类型和原理，例如缓冲区溢出、竞争条件、提权漏洞等。</li>
<li>学习内核漏洞的利用技术，如ROP、堆喷射、内核地址泄露等。</li>
<li>学习内核安全防护技术，如内核地址随机化（KASLR）、内核代码只读（RO）、内存保护扩展（MPX）等。</li>
</ul>
<p><strong>5. 云系统内核安全阶段</strong></p>
<ul>
<li>学习虚拟化环境下的内核安全挑战，如虚拟机逃逸、共享资源攻击等。</li>
<li>学习容器环境下的内核安全挑战，如容器逃逸、资源隔离不足等。</li>
<li>学习硬件安全技术，如安全引导（Secure Boot）、可信计算（TPM）、英特尔SGX等。</li>
<li>学习云环境下的内核安全加固措施，如安全基线、监控、自动化补丁等。</li>
</ul>
<p><strong>6. 实践阶段</strong></p>
<ul>
<li>参与开源内核安全项目，为社区提供贡献。</li>
<li>阅读内核安全相关的研究论文和技术报告，了解最新的研究动态。</li>
<li>参加内核安全和云安全的会议和研讨会，与同行交流经验和技巧。</li>
</ul>
<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><p>学习网络安全和 “pwn” 技能需要时间和努力，但通过制定一个合理的计划，你可以逐步掌握所需的知识和技能。以下是一个建议的学习计划：</p>
<ol>
<li><p>学习基础知识：</p>
<ul>
<li>计算机科学基础：了解计算机系统的基本原理，学习编程语言（如 Python, C, Java 或 JavaScript）。</li>
<li>计算机网络：学习网络基本原理，如 OSI 模型、TCP&#x2F;IP 协议、路由和交换等。</li>
<li>操作系统：熟悉 Windows、Linux 和 macOS 等操作系统的原理和使用。</li>
</ul>
</li>
<li><p>学习网络安全基础：</p>
<ul>
<li>加密与解密：学习基本的密码学原理，如对称加密、非对称加密、哈希函数等。</li>
<li>系统安全：了解常见的系统漏洞，如缓冲区溢出、SQL 注入、跨站脚本等。</li>
<li>安全工具：熟悉常用的安全工具，如 Wireshark、Nmap、Metasploit 等。</li>
</ul>
</li>
<li><p>掌握 Pwn 技能：</p>
<ul>
<li>静态分析：学习使用反汇编和调试工具（如 IDA Pro、Ghidra、OllyDbg 等）分析程序。</li>
<li>动态分析：学习使用调试器（如 GDB、x64dbg 等）调试程序，了解程序运行时的状态。</li>
<li>漏洞挖掘：学习如何发现潜在漏洞，如内存泄漏、整数溢出、格式化字符串等。</li>
<li>漏洞利用：学习编写利用代码，如利用 ROP 技术绕过 DEP、使用堆喷射绕过 ASLR 等。</li>
</ul>
</li>
<li><p>实践与进阶：</p>
<ul>
<li>参加 CTF 比赛：参加 Capture The Flag（CTF）比赛，提高实战能力。</li>
<li>研究漏洞案例：分析已知的漏洞案例，了解漏洞发现和利用的具体过程。</li>
<li>学习安全研究论文：阅读网络安全领域的学术论文，跟踪最新技术和研究成果。</li>
<li>参与开源项目：参与网络安全相关的开源项目，如漏洞扫描器、安全框架等。</li>
</ul>
</li>
<li><p>持续学习：</p>
<ul>
<li>关注安全领域的新闻和动态：关注网络安全领域的新闻、博客、漏洞报告等。</li>
<li>参加安全会议：参加网络安全会议（如 DEFCON、Black Hat 等），了解最新的安全趋势和技术。</li>
<li>建立个人网络：加入网络安全社区，与同行交流，分享经验和技巧。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>学习路径</category>
      </categories>
  </entry>
  <entry>
    <title>论文阅读 A Study on the Security Implications of Information Leakages in Container Clouds</title>
    <url>/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/</url>
    <content><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p><code>Container technology</code>提供了一个轻量级的操作系统虚拟主机环境。Container technology的出现深刻的改变了多层分布式应用的开发和部署范式（paradigms of multi-tier distributed applications）。然而，由于Linux系统内核中的系统资源隔离机制没有完全实现（system resource isolation mechanisms），在一个基于container的多租户云服务（<code>multi-tenancy container-based cloud service</code>）中，一些安全问题仍然存在。在本文，我们首先介绍了可以在containers内访问的信息泄露渠道。这些渠道暴露了一系列的系统范围的主机信息给没有适当资源分区的containers。通过利用泄露的主机信息，作为租户在container cloud中的恶意的攻击者就会更容易的发起可能影响云服务的可靠性的安全攻击。我们证明了信息泄露渠道将会被利用于推断隐私数据，检测和验证<code>co-residence</code>，建立隐蔽通道，发动更高级的基于云的攻击。我们讨论了container中的信息泄露的根本原因，并提出了一个两阶段的防御方法。正如评估中所证明的，我们的防御是有效的，并且性能开销非常小。   </p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>云计算已经广泛的运用于整合计算机资源。多租户是云计算的有利特征，允许来自不同租户的计算实例在同一物理服务器上运行。在不同类型的云服务中，多租户容器云最近作为传统的以云基础设施为基础的虚拟机VM的轻量级替代品出现。容器是一种OS级的虚拟化技术，在Linux内核中有多个building blocks，包括资源隔离&#x2F;控制技术（如<code>namespace</code>和<code>cgroup</code>）和安全机制（如<code>Capabilities</code>，<code>SELinux</code>，<code>AppArmor</code>和<code>seccomp</code>）。通过避免additional abstraction layers的开销，容器能够实现接近原生的性能，并且在几乎所有方面都超过了基于虚拟机的系统。除此之外，容器管理和orchestration系统的出现，如Docker和Kubernetes，深刻的改变了在云上构建、运输和部署多层分布式应用的生态系统。</p>
<p>尽管容器服务很成功，但是在同一个操作系统内核上运行多个可能属于不同租户的容器，始终存在安全和隐私问题。为了支持容器云上的多租户，Linux内核正在进行跨容器隔离和取消特权用户级别容器的努力。现有的容器启用内核功能大大缩小了暴露给容器租户的攻击面，并且可以限制大多数现有的恶意攻击。然而，并不是所有的Linux内核的子系统都能够区分容器和主机之间的执行上下文，因此它们可能会向容器化应用程序公开系统范围的信息。一些子系统被认为对容器适应性的优先级较低。其余的子系统面临着将代码库转换成容器形式的实现困难，并且它们的维护者不愿意接受激烈的变化。为了关闭这些漏洞，当前容器运行时软件和容器云提供商通常利用访问控制策略来隐藏这些与容器无关的子系统用户内核接口。然而，这种手动和临时修复只能覆盖一小部分暴露出来的攻击面。</p>
<p>在本文中，我们系统地探索和识别可能意外暴露主机操作系统和<code>co-residence</code>容器信息的容器内泄漏通道。这些信息泄漏包括主机系统状态信息（例如功耗、性能数据、全局内核数据和异步内核事件）以及单个进程执行信息（例如进程调度、cgroups 和进程运行状态）。在特定时间点暴露的区分特征信息可以帮助唯一地识别物理机器。此外，恶意租户可以通过提前获取系统范围的知识来优化攻击策略并最大化攻击效果。我们在 Docker 和 LinuX 容器 (LXC) 上的本地测试平台上发现了这些泄漏通道，并验证了它们在五个公共商业多租户容器云服务上（部分）存在。</p>
<p>我们证明了那些信息泄露渠道存在多个安全隐患。总的来说，尽管被挂载为只读，这些通道仍然会被恶意的容器租户利用来推断同一物理机上其他容器的私有数据，检测和验证共存关系，并建立隐蔽通道以偷偷地传输信息。我们提出了几种技术，攻击者可以通过利用那些信息泄露渠道来推断<code>co-residence</code>。与基于缓存的隐蔽信道等传统方法相比，我们的方法对云环境中的噪声更具韧性。我们根据它们的风险等级对这些通道进行排名。我们发现在容器实例中的活动会影响多个通道的系统范围的内的values。通过对运行在容器中的工作负载进行专门操作，攻击者可以实现可靠和高速的隐蔽通道，以突破云部署中采用的隔离机制。例如，通过故意获取和释放锁而不产生网络活动，从而攻击者可以在容器之间隐蔽的传输比特。这些泄露的信息可以被同一物理机上的所有容器观察到。为了揭示这些泄漏通道的安全风险，我们采用不同技术构建了两个隐蔽通道，并在真实的多租户云环境中测试它们的带宽。</p>
<p>我们进一步设计出了一种先进的攻击，称为<code>synergistic power attack</code>，来利用通过这些通道的看似无害的信息。我们证明这样的信息暴露可以极大地放大攻击效果，降低攻击成本，简化攻击编排。power attacks已被证明对现有的数据中心有事实的威胁。如果没有基础云架构运行状态的信息，现有的power attack只能盲目的启动power-intensive workloads，希望高峰能够触发branch circuit breakers来导致power outages。这样的攻击可能costly并且ineffective。</p>
<p>然而，通过学习系统范围内的状态信息，攻击者可以选择</p>
<ul>
<li><p>选择最佳时机发动攻击，也就是，在现有的power峰值下，由benign workloads触发，通过增加power-intensive workload来进行攻击。</p>
</li>
<li><p>通过检测被控制的容器的proximity-residence，同步对同一物理机&#x2F;机架的多次power attacks。我们在一个真实的容器云服务上进行了proof-of-concept实验 ，并定量证明了我们的攻击能够以更低的成本产生更高的power峰值。</p>
</li>
</ul>
<p>我们进一步深入分析了这些泄漏渠道的根本原因，并发现是Linux内核中容器implementation的incomplete coverage所致。我们提出了一个两阶段的防卫机制来解决这个在容器云上的问题。特别是，为了防卫<code>synergistic power attacks</code>，我们设计并实现了一个<code>power-based namespace</code>，在Linux内核中对power进行更细粒度（容器）级别的划分。我们和准确性，安全性和性能开销的角度评估了我们的<code>power-based namespace</code>。我们的实验结果表明，我们的系统可以在很小的系统开销下抵御<code>container-based power attack</code>。</p>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="Linux-Kernel-Support-for-Container-Technology"><a href="#Linux-Kernel-Support-for-Container-Technology" class="headerlink" title="Linux Kernel Support for Container Technology"></a>Linux Kernel Support for Container Technology</h2><p>容器依赖于多个独立的Linux内核组件来实现用户空间实例之间的隔离。与基于虚拟机的虚拟化方法相比，多个容器共享同一个操作系统内核，从而消除了启动和维护虚拟机所需的额外性能开销。容器在业界受到了广泛关注，并在近年来迅速发展，以提高应用程序性能、增强开发人员效率和促进服务部署。在这里，我们介绍两种关键技术<code>namespace</code>和<code>cgroup</code>，它们使得Linux上的容器化成为可能。</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>第一个<code>namespace</code>在Linux内核2.4.19中被引入。<code>namespace</code>的关键思想是为一组进程隔离和虚拟化系统资源，这些形成一个容器。每个进程可以与多个不同类型的<code>namespace</code>联系。内核为每个进程提供了一个基于<code>namespace</code>类型的定制化系统资源视图。对任何<code>namespace</code>系统资源的修改都会被限制在相关联的<code>namespace</code>里面，因此不会造成整个系统范围内的修改。</p>
<p>现有的内核有七种不同的<code>namespace</code>：<code>mount（MNT）namespace</code>，<code>UNIX timesharing system （UTS）namespace</code>，<code>PIDnamespace</code>， <code>network（NET） namespace</code>，<code>interprocess communications（IPC）namespace</code>，<code>USER namespace</code>，and <code>CGOUP namespace</code></p>
<ul>
<li><p><code>MNT namespace</code>：隔离一组文件系统<code>mount point</code>。在不同的MNT <code>namespace</code>中，进程对文件系统层次结构有不同的视图。</p>
</li>
<li><p><code>UTS namespace</code>：每个容器都有自己的主机名和域名，因此一个容器可以被视为独立节点。</p>
</li>
<li><p><code>PID namespace</code>：虚拟化进程标识符（<code>pids</code>），每个进程有两个<code>pid</code>：在其<code>namespace</code>中有一个<code>pid</code>，在主机上有一个（全局唯一）<code>pid</code>。</p>
</li>
<li><p><code>NET namespace</code>：包含独立的虚拟网络设备、IP地址、端口和IP路由表。IPC命名空间隔离了进程间通信资源，包括信号、管道和共享内存。</p>
</li>
<li><p><code>IPC namespace</code>：隔离进程间通信资源，包括信号、管道和共享内存。</p>
</li>
<li><p><code>USER namespace</code>：引入了用户和组ID号空间的隔离。它在容器内创建一个根用户到主机上非特权用户之间的映射关系。因此，进程可以在用户命名空间内拥有完全权限，但在主机上则被削弱了权限。</p>
</li>
<li><p><code>CGROUP namespace</code>：虚拟化<code>cgroup</code>资源，每个进程只能通过<code>cgroupfs</code>挂载和<code>/proc/self/cgroup</code>文件获得容器化的<code>cgroup</code>视图。</p>
</li>
</ul>
<h3 id="Cgroup"><a href="#Cgroup" class="headerlink" title="Cgroup"></a>Cgroup</h3><p>在Linux内核中，<code>cgroup</code>（control group）提供了一种机制，将进程和所有它们的子进程的group分层为具有可控行为的分层group。容器利用<code>cgroup</code>功能，对每个容器实例应用每个<code>cgroup</code>资源限制，从而防止单个容器耗尽主机资源。这些受控资源包括CPU、内存、块IO、网络等。在云计算的计费模型中，<code>cgroup</code>也可以用于为每个容器分配相应的资源并记录它们的使用情况。每个<code>cgroup</code>子系统提供了一个统一的sysfs接口，以简化用户空间中的<code>cgroup</code>操作。</p>
<h2 id="Container-Cloud"><a href="#Container-Cloud" class="headerlink" title="Container Cloud"></a>Container Cloud</h2><p>有了这些可用于资源隔离和管理的内核功能，Linux 内核可以在操作系统级别提供轻量级虚拟化功能。未来预计会将更多的<code>namespace</code>和 <code>cgroup </code>子系统合并到upstream Linux 内核中，以增强容器安全性。近年来，随着容器运行时软件的成熟，容器化已成为虚拟托管的流行选择。LXC 是第一个完整实现于 2008 年构建的 Linux 容器管理器。Docker 建立在 LXC（现在使用 libcontainer）之上，在最近几年已成为最受欢迎的容器管理工具。Docker 可以将应用程序及其依赖项（例如代码、运行时、系统工具和系统库）打包到镜像中，从而保证应用程序在不同平台上表现一致。许多云服务提供商已经提供了容器云服务，其中包括 Amazon ECS、IBM Bluemix、Microsoft Azure 和 Google Compute Engine 等等。对于多租户容器云服务来说，容器可以运行在裸机物理机或虚拟机上。无论是哪种情况下，不同租户的容器都与主机操作系统共享相同的 Linux 内核。</p>
<h2 id="Covert-Channels"><a href="#Covert-Channels" class="headerlink" title="Covert Channels"></a>Covert Channels</h2><p>隐蔽通道利用共享资源来打破隔离机制，从而使孤立的实体之间能够进行通信。具有隐秘性的隐蔽通道可用于检索敏感信息并绕过标准通道上的访问控制。广泛认为，即使在虚拟机和容器强制执行隔离技术的情况下，今天的云环境也容易受到隐蔽通道攻击。已经提出了各种技术来建立多租户云环境中的隐蔽通道。Ristenpart等人报告了在公共云中利用共享L2数据缓存达到0.2bps 的比特率。Xu等人使用VM之间的最后一级缓存，在Amazon EC2 环境中构建带宽为3.2bps 的隐藏信道。Wu等人通过利用内存总线上发生竞争实现110 bps 和误码率为0.75% 的隐藏信道。Masti等人成功地通过获取芯片传感器读数来构建隐藏信道，并以12.5bps 的比特率进行传输；Bartolini等人将基于温度的隐藏信道改进至相邻核心50bps 。在云环境中，除了泄露敏感数据的威胁外，隐蔽通道还可以进一步被滥用来检测和验证共存性，这是大多数基于云的攻击的前提条件。通过成功地通过隐蔽通道传输信息，攻击者可以确认两个实例是否在同一主机服务器上<code>co-residence</code>。因此，为了通过构建强大的防御机制来保护云端安全，发现新技术以构建隐蔽通道是一个重要步骤，并已经得到先前研究的密切关注。</p>
<h2 id="Power-Attacks-on-Data-Centers"><a href="#Power-Attacks-on-Data-Centers" class="headerlink" title="Power Attacks on Data Centers"></a>Power Attacks on Data Centers</h2><p><code>power attacks</code>已经被证明对现有的云基础设施有事实的威胁。考虑到升级power设施的成本，当前数据中心普遍采用<code>power oversubscription</code>来在现有电力供应能力范围内托管尽可能多的服务器。安全保障是基于这样一个假设：相邻的多个服务器同时达到峰值功耗的概率很低。虽然功率超额订阅允许部署更多服务器而不增加电源容量，但降低了电源冗余性，增加了停电可能性，这可能导致同一机架或同一配电单元（PDU）上的服务器被迫关闭。即使正常工作负载也可能产生引起停电的功率峰值。Facebook最近报告称，在2016年的六个月内预防了18次潜在停电事件。如果恶意对手故意投放“能量病毒”发动攻击，则情况将更为严重。停电带来的后果可能是灾难性的，例如Delta Airlines在2016年8月遭遇数据中心断电事件，导致大规模航班延误和取消。最近研究表明，无论是传统还是备用式数据中心都可以进行 power 攻击。</p>
<p>发起一个成功的<code>power attack</code> 需要三个关键因素：</p>
<ul>
<li><p>通过合法订阅服务得到目标数据中心的服务器访问权限</p>
</li>
<li><p>稳定的运行适度的工作负载，以增加服务器功耗至其上限。</p>
</li>
<li><p>突然切换到耗电量大的工作负载以触发功率峰值。通过在短时间窗口内引起功率峰值，断路器可以被跳闸以保护服务器免受过流或过载造成的物理损害。</p>
</li>
</ul>
<p>断路器的跳闸条件取决于power峰值的强度和持续时间。为了最大化攻击效果，攻击者需要在同一机架或者PDU所属的一组服务器上运行恶意工作负载。此外，发动攻击的时机也至关重要。如果数据中心的特定的一组服务器（例如，位于同一机架上）已经运行在其峰值功率状态下，则发动成功的<code>power attack</code>的可能性更高。</p>
<p>power 限制技术旨在防御<code>power attack</code>。在机架和PDU级别上，通过监控power消耗，数据中心可以通过基于功率的反馈环路限制服务器的功耗。在主机级别上，<code>Running Average Power Limit(RAPL)</code>是一种用于监视和限制单个服务器功耗的技术。自Sandy Bridge微体系结构以来，Intel引入了<code>RAPL</code>。它提供微秒级细粒度CPU级能源计量，并可用于限制一个包的功耗。</p>
<p>power限制机制显著缩小了功率攻击面，但它无法解决<code>power oversubscription</code>的问题，这是数据中心停电的根本原因。虽然单个服务器的主机级功率限制可以立即响应power surface，但机架或PDU级别的功率限制机制仍会遭受分钟级延迟。假设攻击者可以将电源病毒部署到物理相邻的服务器中，即使每个服务器消耗的电力低于其功率上限，所控制服务器总体聚合后的能量消耗仍可能超过供电容量并触发断路器。我们在以下章节中证明恶意容器租户可以通过控制其高能耗工作负载的部署和利用背景下良性工作负载来放大他们的<code>power attack</code>。</p>
<h1 id="Information-Leakages-In-Container-Clouds"><a href="#Information-Leakages-In-Container-Clouds" class="headerlink" title="Information Leakages In Container Clouds"></a>Information Leakages In Container Clouds</h1><p>Linux内核为容器抽象提供了大量支持以实现资源隔离和控制。这些内核机制是在多租户云上运行容器的启用技术。由于优先级和困难程度，Linux内核的某些组件尚未转化为支持容器化。我们打算系统地探索哪些部分的内核没有覆盖，根本原因是什么以及潜在对手如何利用它们。</p>
<h2 id="Container-Information-Leakages"><a href="#Container-Information-Leakages" class="headerlink" title="Container Information Leakages"></a>Container Information Leakages</h2><p>我们首先在本地安装了Docker和LXC容器，并在Linux机器上进行实验。系统设置为默认配置，所有容器都以用户特权启动，与商业容器云类似。Linux提供了两种从用户空间进程到内核的受控接口：系统调用和基于内存的伪文件系统。系统调用主要设计用于用户进程请求内核服务。这些系统调用具有严格的公共接口定义，并通常向后兼容。然而，基于内存的伪文件系统更灵活，可扩展内核功能（例如<code>ioctl</code>），访问内核数据（例如<code>procfs</code>）并调整内核参数（例如<code>sysctl</code>）。此外，这样的伪文件系统使得通过正常文件I&#x2F;O操作操纵内核数据成为可能。Linux有许多基于内存的伪文件系统（例如，<code>procfs</code>、<code>sysfs</code>、<code>devfs</code>、<code>securityfs</code>、<code>debugfs</code>等），这些文件系统服务于不同的内核操作目的。我们更感兴趣的是<code>procfs</code>和<code>sysfs</code>，默认情况下由容器运行时软件挂载。</p>
<p>如图所示，我们设计了一个交叉验证工具，自动发现这些将主机信息暴露给容器的基于内存的伪文件。关键思想是在两个执行上下文中递归探索<code>procfs</code>和<code>sysfs</code>下所有伪文件，在一个未经特权处理的容器中运行，并在主机上运行另一个。我们根据它们的路径对齐并重新排序这些文件，然后对相同内容之间进行成对差分分析。如果从特定虚拟文件访问到的系统资源没有被Linux内核<code>namespace</code>化，则主机和容器会达到相同片段（如图中❷的情况）。否则，如果正确<code>namespace</code>化，则容器可以检索到自己的私有和定制内核数据（如图中❶的情况）。使用这个交叉验证工具，我们可以快速识别可能将系统范围主机信息暴露给容器的伪文件（及其内部内核数据结构）。</p>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/Framework.png"></p>
<h2 id="Leakage-Channel-Analysis"><a href="#Leakage-Channel-Analysis" class="headerlink" title="Leakage Channel Analysis"></a>Leakage Channel Analysis</h2><p>我们在表中列出了可能泄露主机信息的所有伪文件。这些泄漏渠道包含主机信息的不同方面。容器用户可以检索内核数据结构（例如，<code>/proc/modules</code>显示加载模块列表），内核事件（例如，<code>/proc/interrupt</code>s显示每个IRQ的中断数）和硬件信息（例如，<code>/proc/cpuinfo</code>和<code>/proc/meminfo</code>分别显示CPU和内存规格）。此外，容器用户还可以通过某些通道获取性能统计数据。例如，容器可以通过<code>RAPL sysfs</code>接口获得硬件传感器数据（如果这些传感器在物理机上可用），如每个package、核心和DRAM的功耗，并通过数字温度传感器(DTS)<code>sysfs</code>接口获得每个核心的温度。此外，处理器、内存和磁盘I&#x2F;O的使用情况也暴露给容器。虽然乍一看泄露这样的信息似乎无害，但恶意对手可能利用它来发动攻击。</p>
<p>我们通过检查内核代码（在Linux内核版本4.7中）进一步调查了这些信息泄漏的根本原因。通常，泄漏问题是由于内核中<code>namespace</code>实现不完整引起的。更具体地说，我们总结了两个主要原因如下：（1）对于现有<code>namespace</code>缺少context check，以及（2）某些Linux子系统没有（完全）进行<code>namespace</code>隔离。我们提供了两个案例研究，分别是容器中的<code>net prio.ifpriomap</code>和<code>RAPL</code>，以揭示泄漏源头。</p>
<h3 id="Case-study-1-net-prio-ifpriomap"><a href="#Case-study-1-net-prio-ifpriomap" class="headerlink" title="Case study 1 - net_prio.ifpriomap"></a>Case study 1 - net_prio.ifpriomap</h3><p>伪文件<code>net prio.ifpriomap</code>（位于<code>/sys/fs/cgroup/net prio</code>下）包含了一个映射，该映射将从cgroup中的进程开始并离开系统的流量分配给不同接口。数据格式为<code>[ifname priority]</code>。我们发现，在<code>net prio.ifpriomap</code>上挂钩的内核处理程序函数不知道NET命名空间，因此它向容器化应用程序披露物理机器上所有网络接口。更具体地说，<code>net prio.ifpriomap</code>的读操作由<code>read_priomap</code>函数处理。从这个函数跟踪，我们发现它调用<code>for_each_netdev_rcu</code>，并将第一个参数设置为<code>init_net</code>地址。它迭代主机的所有网络设备，而不考虑NET命名空间。因此，在容器视图中，可以读取主机所有网络设备名称。</p>
<h3 id="Case-study-2-RAPL-in-containers"><a href="#Case-study-2-RAPL-in-containers" class="headerlink" title="Case study 2 - RAPL in containers"></a>Case study 2 - RAPL in containers</h3><p>RAPL是英特尔最近推出的用于设置单个服务器处理器包和DRAM功率限制的技术，可以在毫秒级别响应。在容器云中，<code>RAPL sysfs</code>接口位于<code>/sys/class/powercap/intel-rapl</code>，容器可以访问该接口。因此，容器租户可以通过这个sysfs接口获取主机的系统范围内电源状态，包括核心、DRAM和package等。例如，容器用户可以从伪文件energy uj中读取当前微焦耳能量计数器值。Intel RAPL Linux驱动程序中energy uj的函数处理程序是<code>get_energy_counte</code>r。该函数从<code>RAPL MSR</code>检索原始能量数据。由于尚未实现功率数据名称空间，则<code>energy_raw</code>指针引用主机的能量消耗数据。</p>
<p>我们进一步调查了采用Docker&#x2F;LXC容器引擎的容器云服务中存在的信息泄漏问题。我们选择了五个商业公共多租户容器云服务进行泄漏检测，并在表中呈现结果。在云提供商修补通道之前，我们对这些容器云服务的名称（CCi代表第i个Container Cloud）进行匿名化处理。如果结果与我们的容器实例配置不一致，则确认泄露存在。黑点表示通道不存在于该云中，而白点表示通道存在于该云中。我们发现大多数本地机器上的泄露渠道也可以在容器云服务上使用。其中一些由于缺乏特定硬件支持而无法使用（例如Sandy Bridge之前的英特尔处理器或不支持RAPL技术的AMD处理器）。对于CC5，我们发现某些通道信息与本地测试平台不同，这意味着云供应商已经定制了一些额外限制条件。例如，只有属于租户核心和内存相关信息是可用的。然而，这些渠道部分泄露主机信息仍可能被高级攻击者利用, 我们将它们标记为黑白点。</p>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/Files.png"></p>
<h2 id="Inference-of-Co-resident-Container"><a href="#Inference-of-Co-resident-Container" class="headerlink" title="Inference of Co-resident Container"></a>Inference of Co-resident Container</h2><p>我们进一步深入研究特定案例，以查看它们是否可以被利用来检测共存容器</p>
<h3 id="Co-residence-problems-in-cloud-settings"><a href="#Co-residence-problems-in-cloud-settings" class="headerlink" title="Co-residence problems in cloud settings"></a>Co-residence problems in cloud settings</h3><p><code>Co-residence</code>是云安全中一个众所周知的研究问题。为了提取受害者的信息，攻击者倾向于将恶意实例移动到与受害者相同的物理主机上。Zhang等人已经证明，攻击者可以使用共存实例劫持用户帐户并提取私钥。</p>
<p>此外，实现<code>Co-residence</code>的成本相当低。由于意图整合服务器资源和降低成本，<code>Co-residence</code>仍然是现有云中存在的问题。验证<code>Co-residence</code>的传统方法基于缓存或基于内存泄漏通道。这些方法的准确性可能会因云环境中高噪声而下降。</p>
<h3 id="Approaches-and-results-of-checking-co-resident-containers"><a href="#Approaches-and-results-of-checking-co-resident-containers" class="headerlink" title="Approaches and results of checking co-resident containers"></a>Approaches and results of checking co-resident containers</h3><p>由于容器可以通过我们发现的泄漏通道读取主机信息，因此我们倾向于测量某些通道是否可用于检查容器共存。我们定义了三个指标，即唯一性（U）、变化性（V）和操作性（M），以定量评估每个通道推断共存的能力。指标 U 表示该通道是否赋予特征数据，可以唯一地识别主机。这是确定两个容器是否位于同一主机最重要和准确的因素。我们已经发现了 17 个泄漏通道，满足这种度量标准。一般来说，我们可以将这些渠道分类为三组：</p>
<ul>
<li><p>包含唯一静态标识符的渠道。例如，在<code>/proc/sys/kernel/random</code> 下的引导 ID 是在启动时生成的随机字符串，并且对于每个运行内核都是唯一的。如果两个容器可以读取相同的引导 ID，则明显表示它们正在运行在同一个主机内核上。此组中渠道数据既是静态又是独特的。</p>
</li>
<li><p>容器租户可以动态植入独特签名到其中的渠道 。例如，在<code>/proc/sched debug</code>中 ，容器用户可以通过此接口检索所有活动进程信息的主机 。租户可以在容器内部启动一个带有独特制作的任务名称的进程。从其他容器中，他们可以通过在自己的 sched debug 中搜索此任务名称来验证共存。类似情况适用于计时器列表和锁。</p>
</li>
<li><p>包含唯一动态标识符的渠道。例如，在<code>/proc/uptime</code>中有两个数据字段：系统运行时间和自引导以来的系统空闲时间（以秒为单位）。它们是累积值，并且对于每台主机都是唯一的。同样，<code>RAPL sysfs</code> 接口中的能量 uj 是微焦耳中累积能量计数器 。从该组通道读取到 的 数据 在实时更改 ，但仍然是独特的代表主机 。我们根据其增长率对该组通道进行排名。较快的增长速度表示重复几率较低。</p>
</li>
</ul>
<p>度量V可以展示数据是否随时间变化。有了这个特性，两个容器可以同时定期地对该伪文件进行快照。然后，它们可以通过检查两个数据快照跟踪是否相互匹配来确定<code>co-residence</code>关系。例如，从同一时刻开始，在一分钟内每秒钟记录<code>/proc/meminfo</code>中的<code>MemFree</code>在两个容器中。如果这两个60点数据跟踪彼此匹配，则我们有信心认为这两个容器运行在同一个主机上。每个通道包含不同的信息推断共存的能力，可以通过联合香农熵自然地测量。我们用公式（1）定义熵H。</p>
<p>每个多重独立数据字段Xi，n表示独立数据字段的数量。每个Xi都有可能的值{xi1，· · · ，xim}。我们根据表中的熵结果对能够揭示<code>co-residence</code>能力的九个通道（其中U&#x3D;False且V&#x3D;True）进行排名。</p>
<p>指标M表示容器租户是否可以操作数据。如果租户可以直接将特制的数据嵌入通道中，我们会对其进行标记为黑色。例如，我们可以在容器内创建一个带有特殊任务名称的计时器程序。该任务名称及其关联的计时器将出现在<code>/proc/timer</code>列表中。另一个容器可以搜索计时器列表中的此特殊任务名称以验证共存性。如果租户只能间接影响此通道中的数据，则我们会标记为黑白色。例如，攻击者可以使用<code>taskset</code>命令将计算密集型工作负载绑定到特定核心，并从另一个容器检查CPU利用率、功耗或温度等信息。这些条目可能被高级攻击者利用作为隐蔽信道来传输信号。</p>
<p>对于那些没有这些 U V M 属性的通道，我们认为它们很难被利用。例如，在云数据中心中，大多数服务器可能安装了相同的操作系统分发版和相同的模块列表。虽然 <code>/proc/modules</code>泄漏了主机上加载模块的信息，但是使用此通道推断<code>co-resident</code>容器是困难的。</p>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/Leakage%20Channel.png"></p>
<h1 id="Constructing-Covert-Channels"><a href="#Constructing-Covert-Channels" class="headerlink" title="Constructing Covert Channels"></a>Constructing Covert Channels</h1><p>包含manipulation（M）的通道可以进一步利用，以在两个容器之间建立隐蔽通道。我们证明了这些信息泄漏通道中的动态标识符和性能数据都可以被滥用来传输信息。特别地，我们实现了两个通道并测试它们的吞吐量和错误率。</p>
<h2 id="Covert-channel-based-on-unique-dynamic-identifiers"><a href="#Covert-channel-based-on-unique-dynamic-identifiers" class="headerlink" title="Covert channel based on unique dynamic identifiers"></a>Covert channel based on unique dynamic identifiers</h2><p>我们以<code>/proc/locks</code>为例来演示隐蔽通道可以构建在唯一动态标识符之上。通道<code>/proc/locks</code>显示了操作系统中所有锁信息的概述，包括锁类型、相应的进程以及inode号。</p>
<p>这种泄漏也破坏了 pid命名空间，因为所有锁的全局pid都被泄露了。Linux内核的维护者在4.9版本中部分修复了<code>/proc/locks</code>。内核4.9版本中部分修复了<code>/proc/locks</code>，将当前pid命名空间中的所有pid屏蔽为零。然而，其他信息，如锁的数量和节点信息仍然在容器。</p>
<p>我们构建了一个基于<code>/proc/locks</code>的隐蔽通道。具体来说，发送方可以lock一个文件来表示1，并释放lock来表示0。虽然lock和文件不在容器之间共享，但接收器可以在<code>/proc/locks</code>中检查lock的存在。通过不断检查特定lock的状态，可以传输信息。此外，可以同时设置多个lock以传输多个比特。为了建立可靠的高带宽隐蔽信道，攻击者需要考虑几个因素。我们在算法1中详细介绍了构建基于锁的隐蔽信道的过程。</p>
<p>通道<code>/proc/locks</code>包含内部内核数据，因此它一直在更改。尤其是在存在噪声的云环境中，内容可能会发生巨大的波动。</p>
<p>可靠传输数据块的第一步是握手：接收方需要找出发送方使用的所有lock。特别地，握手过程负责：</p>
<ul>
<li><p>设置数据传输的起点.</p>
</li>
<li><p>锚定锁，用于同时传送一个block of bits.</p>
</li>
<li><p>同步发送器和接收器。</p>
</li>
</ul>
<p>我们通过为每个数据锁创建一个特定的模式来实现握手。对于一个简化的情况，发送方在短时间内不断获取和释放锁。然后，接收器检查每个数据锁的切换次数（锁定或解锁文件）。如果切换次数超过特定阈值，则接收器通过跟踪索引节点编号来记录该lock，该索引节点编号对于特定文件上的相同锁定是不变的。同时，我们使用一个额外的锁来表示传输信号，用于通知接收器每一轮传输的开始。</p>
<p>在创建特定模式之后，理论上发送方可以立即开始传输。然而，接收方的处理过程的时间是未知的和不确定的，特别是在多租户云环境中存在大量锁的情况下。如果发送方传输数据过快，则可能会丢失一个比特块。虽然发送方可以在发送下一个数据块之前等待一段时间，但这种方法将极大地影响传输速度。</p>
<p>我们进一步添加了一个ACK锁，用于同步发送方和接收方。在获得所有数据锁定之后，接收器通过设置ACK锁定来进行确认。发送器侧的ACK锁的检测类似于接收器侧的其他数据锁的检测方法。接收器在用ACK锁定进行应答之后进入准备状态，并等待数据传输。</p>
<p>对于数据传输，发送方通过获取或释放数据锁，在每一轮中发送一个数据块。例如，八个锁可以表示一个字节。接收器通过检查数据锁的状态来解码数据。一旦接收到ACK锁定，发送器就开始下一轮数据传输。</p>
<h2 id="Covert-channel-based-on-performance-data-variation"><a href="#Covert-channel-based-on-performance-data-variation" class="headerlink" title="Covert channel based on performance data variation"></a>Covert channel based on performance data variation</h2><p>通过这些信息的泄露，容器用户可以检索到主机服务器的全系统性能统计数据。例如，容器可以通过<code>/proc/stat</code>获取每个核心的CPU使用率，通过<code>/proc/meminfo</code>或<code>/proc/vmstat</code>获取内存使用率。性能数据的取值受容器运行状态的影响。尽管在云环境中，一个容器只能容纳有限的计算资源，但容器中的恶意用户可以仔细选择在容器中运行的工作负载。通过在性能通道中生成独特的模式，容器可以构建隐蔽通道来传输信息。我们建立了一个隐蔽通道，通过滥用<code>/proc/meminfo</code>中的内存使用信息。</p>
<p><code>/proc/meminfo</code>报告大量关于系统内存使用情况的有价值的信息，包括可用内存总量、系统未使用的物理RAM总量和脏内存总量。</p>
<p>这里我们利用了系统中未使用的内存量。</p>
<p>在云环境中，这个值可能有很大差异，因为每个容器用户都可能影响它。对于建立可靠的隐蔽数据传输来说，这种显著的变化是不可取的。但是，如果不运行内存密集型工作负载，使用情况可能在可接受的范围内波动。我们首先在服务器上记录一段时间的未使用内存，以获得基线值。如果该值变化不迅速且不显著，则表示可以建立隐蔽通道。然后，发送方容器可以分配不同数量的内存来表示位1和位0(例如，位1为100MB，位0为50MB)，这将导致<code>/proc/meminfo</code>中的<code>MemFree</code>字段dorp immediately。接收端可以通过监视空闲内存的变化来简单地转换数据。<code>MemFree</code>分为三个级别:基线情况、位1和位0。发送方在发送1或0后释放所有分配的内存，以便接收方可以知道上次传输的结束并为下一个比特做准备。</p>
<p>为了确保可靠的传输，握手是发送方和接收方之间的第一个必要步骤。</p>
<p>发送方可以选择发送一个固定的模式，比如8位直比特1，来发起一次传输。接收端获得握手模式后，将进入数据接收模式。具体算法见算法2。为了减少其他容器内存消耗所产生的噪声的影响，一旦<code>MemFree</code>落在预定义的范围内，接收端将标记数据传输。同时，增加内存分配量可以减少噪声的影响。但是，由于分配和释放内存需要消耗时间，因此会影响传输带宽。为了减少来自环境的干扰，用户可以进一步设计更高级别的可靠协议，例如使用校验和，以确保传输数据的完整性。</p>
<h2 id="Experiments-on-a-Multi-tenancy-Container-Cloud"><a href="#Experiments-on-a-Multi-tenancy-Container-Cloud" class="headerlink" title="Experiments on a Multi-tenancy Container Cloud"></a>Experiments on a Multi-tenancy Container Cloud</h2><p>为了测量在有真实噪声的环境下的性能，我们选择了一个商业多租户容器云来测试我们的隐蔽通道。我们反复启动容器，并通过检查惟一的静态标识符来验证共存。我们在同一物理机器上创建两个容器。</p>
<ul>
<li><p><code>Lock-based covert channel</code>: 我们在三种不同大小的数据(5,000字节、10,000字节和20,000字节)下测试了基于锁的隐蔽通道的带宽和错误率。我们还选择了四种不同数量的锁(即8、16、24、32)来衡量性能。我们根据经验为切换次数选择一个阈值，以确保所有锁都能被正确识别。握手过程的花费以秒为单位。然后，所有传输数据都是随机生成的。我们恢复接收端的所有数据，并与原始数据进行比较。</p>
<p>具有8个锁的基于锁的隐蔽通道的带宽约为5150 bps。显然，使用的锁越多，带宽就越高。在通道中使用32个数据锁(每轮传输4个字节)，带宽达到22186 bps。</p>
<p>此外，所有案例的错误率都在2%以下。结果表明，基于锁的隐蔽信道具有较高的可靠性。</p>
</li>
<li><p><code>Memory-based covert channel</code>: 对于构建在<code>/proc/meminfo</code>上的隐蔽通道，我们首先将位1和位0的内存分配分别设置为100,000KB和50,000KB。我们发送1000位来测试性能。然后我们逐渐减少内存分配，直到构建握手失败。带宽和错误率的结果如表3所示。带宽与内存分配大小成反比。但是，如果分配的内存太小，握手过程就会失败，从而导致传输中出现大量错误。最后，通过将65,000KB分配给bit 1, 35,000KB分配给bit 0，我们能够在真实的云环境中实现13.6 bps的带宽。</p>
</li>
</ul>
<p>基于锁的隐蔽通道提供了非常高的数据传输速率，同时仍然保持低错误率。虽然基于内存的隐蔽信道速度有限，但仍能可靠地传输数据。在基于内存的隐蔽信道中可以添加更多的优化方法。例如，我们可以使用更多的级别来每次传输多个比特。我们把它作为我们今后的工作。</p>
<p>值得注意的是，一旦两个容器共存于同一物理服务器上，无论使用相同的CPU包或核心，构建在信息泄漏通道上的隐蔽通道就可以工作。相反，只有当两个实例共享相同的CPU包时，基于最后一级缓存的通道才有效。另据报道，在真实的云环境中，基于内存总线的方法只能适用于近20%的<code>co-residence</code>情况。热隐蔽通道只能在两个核彼此靠近时起作用。</p>
<h1 id="Synergistic-Power-Attack"><a href="#Synergistic-Power-Attack" class="headerlink" title="Synergistic Power Attack"></a>Synergistic Power Attack</h1><p>由于procfs和sysfs在容器中都是只读挂载的，因此恶意租户只能读取这些信息，但不允许修改。我们认为，通过利用泄漏通道，攻击者可以通过学习主机的运行时状态来做出更好的决策。</p>
<p>我们将介绍潜在的<code>Synergistic Power Attack</code>，可能影响数据中心的可靠性，在power outage threats的范围内。我们证明，对手可以利用我们发现的这些信息泄漏来放大攻击效果，降低攻击成本，并促进攻击编排。所有实验都是在真实的容器云中进行的。</p>
<h2 id="Attack-Amplification"><a href="#Attack-Amplification" class="headerlink" title="Attack Amplification"></a>Attack Amplification</h2><p>发动成功的<code>power attack</code>的关键是产生短时间的高power峰值，可以超过电力设施的供应能力。正如我们在2.4节中提到的，电源攻击的根本原因是广泛采用电源<code>oversubscription</code>，这使得电源峰值超过安全阈值成为可能。此外，机架级功率封顶机制只能在分钟级时间粒度内反应，为短时间高功率峰值的发生留下了空间。在最严重的情况下，过度充电可能会跳闸分支断路器，导致停电，最终导致服务器瘫痪。能量峰值的高度主要由攻击者控制的资源决定。现有的电源攻击通过自定义电源密集型工作负载 customizing powerintensive workloads(称为电源病毒)来最大限度地提高功耗。Ganesan等人，利用遗传算法自动生成比正常stress基准消耗更多的power的power viruses。</p>
<p>根据Barroso等的报告，在真实的数据中心中，平均利用率约为20%至30%。在如此低的利用率下，不加区分地发起<code>power attack</code>而跳闸断路器的几率极低。</p>
<p>然而，虽然平均利用率较低，但在峰值需求下，数据中心仍然面临断电威胁。这说明物理服务器的功耗随着工作负载的变化会有很大的波动。</p>
<p>为了确认这一假设，我们进行了一个实验，监测容器云中8个物理服务器的整个系统功耗(通过第3节案例研究II中的<code>RAPL</code>泄漏通道)，持续一周。我们将结果显示在图中。我们首先以30秒为间隔对功率数据进行平均，并在第2天和第5天观察功率的剧烈变化。此外，我们在第2天选择一个高功耗区域，并以一秒(这是产生功率峰值的典型时间窗口)为间隔对数据进行平均。峰值功耗达到1199瓦(W)，在一周的时间内，总功耗相差34.72% (899W ~ 1199w)。</p>
<p>我们预计，如果我们能对其进行更长时间的监控，比如在黑色星期五这样的假日，当托管在云上的在线购物网站可能会产生巨大的电力激增时，功耗差异将会更大。</p>
<p>对于容器云中的<code>synergistic power attack</code>，攻击者可以通过RAPL通道监控整个系统的功耗，实时了解功耗模式的波峰和波谷，而不是不加区分地启动功耗密集型工作负载。因此，他们可以利用后台功耗(由同一主机上其他租户的良性工作负载产生)，并在服务器处于峰值运行时间时叠加他们的电源攻击。</p>
<p>这与金融市场的内幕交易现象类似——掌握更多内幕信息的人总是能在合适的时间交易。对手可以通过通过<code>RAPL</code>通道泄露的“内部”功耗信息，在已经很高的功耗基础上再增加一个更高的功耗峰值。</p>
<h2 id="Reduction-of-Attack-Costs"><a href="#Reduction-of-Attack-Costs" class="headerlink" title="Reduction of Attack Costs"></a>Reduction of Attack Costs</h2><p>从攻击者的角度来看，他们总是希望以最低的代价获得最大的攻击结果。持续运行功耗高的工作负载绝对可以捕获所有良性功耗的峰值。但是，由于几个原因，它对于真实世界的攻击可能并不实用。首先，它不是隐形的。要发起电源攻击，攻击者需要运行电源密集型工作负载。这种行为具有明显的模式，很容易被云提供商检测到。</p>
<p>其次，基于利用率的计费模式现在变得越来越流行。更多的云服务根据CPU&#x2F;内存利用率和网络流量提供更细粒度的价格。例如，Elastic Container为客户提供了基于CPU计量计费的容器。</p>
<p>IBM Cloud为云中的计算资源提供计费指标。Amazon EC2提供了Burstable性能实例，该实例偶尔会崩溃，但大多数时间不会完全运行。VMware按需定价计算器甚至给出了不同利用率水平的估计值。例如，对于一个拥有16个vcpu且平均利用率为1%的实例，它每月收费2.87美元，对于相同的服务器且利用率为100%的实例，每月收费167.25美元。在这些云计费模式下，持续的<code>power attack</code>可能最终导致昂贵的账单。</p>
<p>对于<code>synergistic power attack</code>，通过<code>RAPL</code>监视功耗几乎没有CPU占用。</p>
<p>为了达到相同的效果(功率峰值的高度)，与连续和周期性攻击相比，协同功率攻击可以显著降低攻击成本。我们比较了<code>synergistic power attack</code>和周期性攻击(每300秒发起一次<code>synergistic power attack</code>)的攻击效果。协同攻击在3000秒内只进行两次试验，就可以达到1359瓦的功率峰值，而周期性攻击则进行了9次试验，最多只能达到1280瓦。</p>
<h2 id="Attack-Orchestration"><a href="#Attack-Orchestration" class="headerlink" title="Attack Orchestration"></a>Attack Orchestration</h2><p>与传统的<code>power attack</code>不同，<code>synergistic power attack</code>的另一个独特特征是它的攻击编排。假设攻击者已经控制了一些容器实例。如果这些容器分散在数据中心的不同位置，那么它们在多个物理服务器上增加的power不会对电力设施造成压力。现有的功率封顶机制可以毫无困难地容忍来自不同位置的多个小power surges。发动实际电力攻击的唯一方法是将所有“弹药”聚集到相邻位置，同时攻击单个电源。在这里，我们将深入讨论攻击容器实例的编排。</p>
<p>正如我们在第3节中提到的，通过利用多个泄漏通道，攻击者可以将多个容器实例聚合到一个物理服务器中。具体来说，在CC1上的实验中，我们选择使用计时器列表来验证多个容器的共存。具体验证方法请参见3.3节。我们反复创建不在同一物理服务器上的容器实例和终止实例。通过这样做，我们可以轻松地在同一台服务器上部署三个容器。我们在每个容器中运行四个Prime基准测试副本，以充分利用四个分配的核心。每个容器可以贡献大约40W的功率。使用三个容器，攻击者可以轻松地将功耗提高到近230W，这比单个服务器的平均功耗高出约100W。</p>
<p>我们还发现<code>/proc/uptime</code>是另一个有趣的泄漏通道。正常运行时间包括两个数据项，物理服务器的启动时间和所有核心的空闲时间。</p>
<p>在我们的实验中，我们发现一些服务器的启动时间相似，但空闲时间不同。通常情况下，数据中心的服务器在安装和打开后不会重新启动。不同的空闲时间表明它们不是相同的物理服务器，而相似的引导时间表明它们很可能在同一时间段被安装和打开。这是强有力的证据，表明它们可能离得很近，共用同一个断路器。攻击者可以利用此通道将其攻击容器实例聚合到相邻的物理服务器中。这大大增加了他们跳闸导致停电的机会。</p>
<h1 id="Defense-Aproach"><a href="#Defense-Aproach" class="headerlink" title="Defense Aproach"></a>Defense Aproach</h1><h2 id="A-Two-Stage-Defense-Mechanism"><a href="#A-Two-Stage-Defense-Mechanism" class="headerlink" title="A Two-Stage Defense Mechanism"></a>A Two-Stage Defense Mechanism</h2><p>直观地说，解决方案应该消除所有泄漏，这样就不会通过这些渠道检索泄漏的信息。我们将防御机制划分为两个阶段:(1)屏蔽通道和(2)增强容器的资源隔离模型。</p>
<p>在第一阶段，系统管理员可以显式地拒绝对容器内通道的读访问，例如，通过AppArmor中的安全策略或挂载伪文件“不可读”。这不需要对内核代码进行任何更改(合并到上游Linux内核可能需要一些时间)，并且可以立即消除信息泄漏。此解决方案取决于容器中运行的合法应用程序是否使用这些通道。如果这些信息与容器化的应用程序正交，则屏蔽它不会对容器租户产生负面影响。我们已经向Docker和表中列出的所有云供应商报告了我们的结果，并收到了积极的回应。</p>
<p>我们与容器云供应商合作解决此信息泄漏问题，并将对容器中托管的应用程序的影响降至最低。这种屏蔽方法可以快速修复基于内存的伪文件系统中的所有泄漏，但它可能会对容器化应用程序的功能增加限制，这与容器提供通用计算平台的概念相矛盾。</p>
<p>在第二阶段，防御方法涉及修复丢失的<code>namespace</code>上下文检查和虚拟化更多的系统资源(即，实现新的<code>namespace</code>)以增强容器的隔离模型。</p>
<p>我们首先向Linux内核维护者报告了与现有<code>namespace</code>相关的信息披露错误，他们很快发布了针对其中一个问题的新补丁([CVE2017-5967])。对于没有<code>namespace</code>隔离保护的其他通道，我们需要更改内核代码，以强制使用更细粒度的系统资源分区。由于每个通道都需要单独修复，因此这种方法可能涉及大量工作。虚拟化一个特定的内核组件可能会影响多个内核子系统。另外，有些系统资源不容易精确地划分到每个容器中。但是，我们认为这是解决问题的根本办法。特别是，为了防御<code>synergistic power attack</code>，我们在Linux内核中设计并实现了一个<code>proof-of-concept power-based namespace</code>，以向每个容器显示分区的电源使用情况。</p>
<h2 id="Power-based-Namespace"><a href="#Power-based-Namespace" class="headerlink" title="Power-based Namespace"></a>Power-based Namespace</h2><p>我们提出了一个<code>power-based namespace</code>，通过未更改的<code>RAPL</code>接口向每个容器显示每个容器的power使用情况。在不泄漏整个系统功耗信息的情况下，攻击者无法推断主机的电源状态，从而消除了在良性电源峰值上叠加功耗密集型工作负载的机会。此外，有了每个容器的功率使用统计数据，我们可以动态地限制超过预定义功率阈值的容器的计算能力(或增加使用费用)。容器云管理员可以基于此基于功能的<code>namespace</code>设计粒度更细的计费模型。</p>
<p>我们的设计有三个目标。</p>
<ul>
<li><p>准确性:由于没有硬件支持每个容器的功率分区，我们基于软件的功率建模需要准确反映每个容器的功率使用情况。</p>
</li>
<li><p>透明性:容器内的应用程序不知道该命名空间外的功率变化，功率子系统的接口保持不变。</p>
</li>
<li><p>效率:功率分区不应在容器内或容器外引起重要的性能开销。</p>
</li>
</ul>
<p>我们在图中说明了系统的工作流程。我们基于功率的命名空间由三个主要组件组成:<strong>数据收集</strong>、<strong>功率建模</strong>和<strong>动态校准</strong>。我们在容器中保持相同的Intel <code>RAPL</code>接口，但是改变了处理能源使用的读取操作的实现。一旦检测到能源使用的读取操作，修改后的RAPL驱动程序检索每个容器的性能数据(数据收集)，使用检索到的数据来建模能源使用(功率建模)，最后校准建模的能源使用(动态校准)。</p>
<p>我们将在下面详细讨论每个组件。</p>
<h3 id="Data-collection"><a href="#Data-collection" class="headerlink" title="Data collection"></a>Data collection</h3><p>为了对每个容器的功耗进行建模，我们需要获得每个容器的 <code>fine-grained performance data</code>。每个容器都与一个<code>cpuacct cgroup</code>相关联。<code>cpuacct cgroup</code>表示容器的处理器核心上的CPU周期。CPU周期累计。我们只使用CPU周期来计算后面的缓存丢失率和分支丢失率。Linux内核还有一个<code>perf_event</code>子系统，它支持计算不同类型的性能事件。The granularity of<br>performance accounting 可以是单个进程或一组进程(视为一个<code>per_event cgroup</code>)。到目前为止，我们只为每个<code>perf_event cgroup</code>检索退役指令、缓存缺失和分支缺失(在下一个电源建模组件中需要)的数据。我们当前的实现是可扩展的，可以收集与未来电源建模的变化相对应的更多性能事件类型。</p>
<p>我们从<code>power-based namespace</code>的初始化监视性能事件，并创建多个<code>perf_events</code>，每个事件都与特定的性能事件类型和特定的CPU核心相关联。然后，我们将该容器的<code>perf_cgroup</code>与这些<code>perf_event</code>连接起来，开始计算。此外，我们需要将所有创建的<code>perf_event</code>的所有者设置为<code>TASK TOMBSTONE</code>，这表明这样的性能核算与任何用户进程都是分离的。</p>
<h2 id="Power-modeling"><a href="#Power-modeling" class="headerlink" title="Power modeling"></a>Power modeling</h2><p>要实现<code>power-based namespace</code>，我们需要将功率消耗归因于每个容器。RAPL不是提供瞬态功耗，而是分别为package、核心和DRAM提供累计能耗。power消耗可以通过测量时间单位窗口内的能源消耗来计算。</p>
<p>我们<code>power-based namespace</code>还以与原始RAPL接口相同的格式提供了每个容器的累计能量数据。</p>
<p>我们首先将核心的功耗归为属性。</p>
<p>传统的电源建模利用CPU利用率来确定核心的功耗。然而，Xu等证明，在相同的CPU利用率下，power消耗可能会有很大差异。底层管道和数据依赖可能导致CPU失速和功能单元空转。在相同的CPU利用率下，实际退出指令的数量是不同的。</p>
<p>图显示了退役指令和能量之间的关系。我们在四个不同的基准上进行测试:用C编写的空闲循环，prime, 462.SPECCPU2006中的libquantum，以及不同内存配置的strss。我们在主机上运行基准测试，并使用Perf来收集性能统计数据。我们可以看到，对于每个基准测试，能量消耗几乎严格地与退役指令的数量成线性。但是，随着应用类型的不同，拟合线的梯度也相应变化。为了使我们的模型更加准确，我们进一步加入cache miss rate和branch miss rate，建立一个多次多项式模型来拟合斜率。</p>
<p>对于DRAM，我们使用package失败的数量来分析power。图显示了核心实验中相同基准测试和相同配置的能耗。它清楚地表明cache miss的数量与DRAM能量近似线性。</p>
<p>在此基础上，我们利用的线性回归对DRAM能量进行建模。</p>
<p>对于package的功耗，我们将核心、DRAM和一个额外常数的值相加。具体模型如式所示，其中M为建模能量;CM、BM、C分别表示cache miss次数、branch miss次数和CPU周期;F为通过多次线性回归拟合斜率得到的函数。I是退役指令的数量。α， β， γ， λ是由图实验数据得出的常数。</p>
<img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/formula1.png" title alt data-align="center">

<p>这里我们讨论浮点指令对功率建模的影响。独立的浮点指令可能比整数操作消耗更多的能量。具有高浮点指令比例的工作负载实际上可能导致整体功耗较低，因为功能单元可能被迫在管道的不同阶段处于空闲状态。为了建立一个更精细的模型，有必要考虑微架构。我们计划在今后的工作中朝着这个方向努力。此外，α、β、γ参数的选择也受结构的影响。这样的问题可以在接下来的校准步骤中得到缓解。</p>
<h3 id="On-the-fly-calibration"><a href="#On-the-fly-calibration" class="headerlink" title="On-the-fly calibration"></a>On-the-fly calibration</h3><p>我们的系统还为主机的能量数据建模，并与通过RAPL获得的实际能量数据进行交叉验证。为了尽量减小建模数据的误差，我们使用下式对每个容器的建模能量数据进行校准。Econtainer表示返回给每个容器的能量值。这种实时校准是对RAPL接口的每个读取操作进行的，可以有效地减少前一步的错误数量。</p>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/formula2.png"></p>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/workflow.png"></p>
<h1 id="Defense-Ecaluation"><a href="#Defense-Ecaluation" class="headerlink" title="Defense Ecaluation"></a>Defense Ecaluation</h1><p>我们从三个方面评估本地机器上基于功能的名称空间:准确性、安全性和性能。我们的测试平台配备了Intel i7-6700 3.40GHz 8核CPU, 16GB RAM，运行Ubuntu Linux 16.04，内核版本为4.7.0。</p>
<h2 id="Accuracy"><a href="#Accuracy" class="headerlink" title="Accuracy"></a>Accuracy</h2><p>我们使用SPECCPU2006基准来测量power建模的准确性。我们将建模的power使用情况与通过RAPL获得的ground truth进行比较。</p>
<p>功耗等于每秒的能量消耗。由于Docker容器的安全策略的限制，我们选择了SPECCPU2006基准测试的一个子集，这些基准测试可以在容器内运行，并且与用于功率建模的基准测试没有重叠。误差ξ定义如下:</p>
<p>其中ERAPL是从主机上的RAPL读取的功耗，而Mcontainer是在容器中读取的相同工作负载的建模功耗。注意，主机和容器都在空闲状态下消耗电力，差别很小。我们使用常数∆diff作为修饰符，反映主机和容器在空闲状态下的功耗差异。结果如图所示，我们的power模型是准确的，因为所有测试基准的误差值都低于0.05。</p>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>我们也从安全的角度来评估我们的系统。</p>
<p>启用了<code>power-based namespace</code>后，容器应该只检索容器内消耗的功率，而不知道主机的电源状态。我们在测试平台中启动两个容器进行比较。我们在一个容器中运行SPECCPU2006基准测试，并将另一个容器闲置。我们记录容器和主机的每秒用电量。如图所示401.bzip2的结果。所有其他基准测试都表现出类似的模式。</p>
<p>当两个容器都没有工作负载时，它们的功耗与主机的功耗基本相同，从0到10s。一旦容器1在10s启动工作负载，我们可以发现容器1和主机的功耗同时激增。从10s到60s，容器1和主机的功耗基本一致，而容器2仍然处于较低的功耗水平。容器2不知道整个系统的功率波动，因为基于<code>power-based namespace</code>强制隔离。这表明我们的系统能够有效地隔离和划分多个容器的功耗。如果没有电源相关的信息，攻击者将无法发起<code>synergistic power attack</code>。</p>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>我们使用UnixBench来比较启用系统前后的性能开销。表列出了所有结果。</p>
<p>正如结果所示，诸如Dhrystone(测试整数和字符串操作)和Whetstone(测试浮点算术性能)这样的CPU基准测试所产生的开销可以忽略不计。</p>
<p>其他基准测试，如shell脚本、管道吞吐量和系统调用，也会触发很少的开销。</p>
<p>在一个并行副本的情况下，基于管道的上下文切换(pip-based context swtiching)确实会产生61.53%的开销，但在8个并行副本时，它会减少到1.63%。我们预计inter-cgroup context switching涉及启用&#x2F;禁用性能事件监视器，而intra-cgroup context switching不涉及任何此类开销。</p>
<p>这解释为什么在禁用<code>power-based namespace</code>情况下，8个并行副本可以保持相似的性能水平。此外，上下文切换只占整个系统性能开销的很小一部分，因此对正常使用的影响很小。</p>
<p>在我们的系统中，对于每个新创建的容器，内核将在每个内核上创建多个<code>perf_events</code>，以收集与性能相关的数据。此测量过程仅对容器过程进行。因此，测量开销将随着容器数量的增加而线性增加。但是，容器数量的增加对系统的影响很小。使用这种机制，在创建所有进程时，内核会检查该进程是否是容器进程。这个检查进程是Unix基准测试中进程创建开销的主要原因。</p>
<p>如表的最后一行所示，UnixBench的总体性能开销对于一个并行副本是9.66%，对于8个并行副本是7.03%。</p>
<p>我们的系统性能在很大程度上依赖于perf_event cgroup的实现，并且可以随着性能监视子系统的改进而提高。</p>
<h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><h2 id="Synnergistic-Power-Attack-without-the-RAPL-Channel"><a href="#Synnergistic-Power-Attack-without-the-RAPL-Channel" class="headerlink" title="Synnergistic Power Attack without the RAPL Channel"></a>Synnergistic Power Attack without the RAPL Channel</h2><p>我们还注意到，一些容器云中的服务器没有配备RAPL或其他类似的嵌入式power meters。这些服务器仍可能面临<code>power attack</code>。如果没有像RAPL这样的power-capping工具，这些服务器在一台机器上可能容易受到<code>host-level power attacks</code>。</p>
<p>此外，如果power data不能直接获得，高级攻击者会尝试根据资源利用信息(如CPU和内存利用率)来近似电源状态，这些信息在已识别的信息泄漏中仍然可用。最好让容器租户无法使用系统范围的性能统计数据。</p>
<h2 id="Complete-Container-Implementation"><a href="#Complete-Container-Implementation" class="headerlink" title="Complete Container Implementation"></a>Complete Container Implementation</h2><p>造成信息泄漏和<code>synergistic power attack</code>的根本原因是Linux内核中隔离机制的不完整实现。最好引入更多的安全特性，比如实现更多的<code>namespace</code>和<code>cgroup</code>。但是，一些系统资源仍然难以分区，如中断、调度信息、温度等。人们还认为，完整的容器实现与虚拟机没有什么不同，并且失去了容器的所有优点。这是容器之间的权衡。如何在容器云中平衡安全性、性能和可用性的问题需要进一步研究。</p>
<h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><p>由于容器最近变得流行，研究人员对容器和硬件虚拟化之间的性能比较感到好奇。Felter等人通过使用一套涵盖CPU、内存、存储和网络资源的基准测试来比较Docker和KVM的性能。他们的结果显示，Docker在所有情况下都能达到与KVM相同或更好的性能。Spoiala等人使用Kurento媒体服务器来比较Docker和KVM上的WebRTC服务器的性能。他们还证明了Docker的性能优于KVM，可以支持实时应用。Morabito等人比较了传统管理程序和操作系统级虚拟化在计算、存储、内存和网络方面的性能。他们对Docker、LXC和KVM进行了实验，观察到磁盘I&#x2F;O仍然是KVM管理程序的瓶颈。所有这些工作都表明，基于容器的操作系统级虚拟化可以实现比硬件虚拟化更高的性能。除了性能，容器云的安全性始终是一个重要的研究领域。Gupta简要介绍了Docker的安全性。Bui也对Docker容器进行了分析，包括隔离问题和相应的内核安全机制。他们声称，Docker容器在默认配置下是相当安全的。Grattafiori等人总结了容器的各种潜在漏洞。他们还提到了基于内存的伪文件系统中的几个通道。Luo等人证明了错误配置的能力可以被利用来在Docker中建立隐蔽的通道。之前关于容器的性能和安全性的研究工作鼓励我们更多地研究容器如何能够实现与硬件虚拟化相同的安全保证，但在性能方面的折衷却微不足道。我们是第一批系统地识别容器中的信息泄露问题，并研究建立在这些泄漏渠道的基于容器的潜在的power attcak。</p>
<h2 id="Cloud-Security-and-Side-x2F-Covert-Channel-Attacks"><a href="#Cloud-Security-and-Side-x2F-Covert-Channel-Attacks" class="headerlink" title="Cloud Security and Side&#x2F;Covert Channel Attacks"></a>Cloud Security and Side&#x2F;Covert Channel Attacks</h2><p>云安全已经受到学术界和业界的广泛关注。云环境下的<code>co-residence</code>检测是与我们工作最密切相关的研究课题。<code>co-residence</code>检测最早由Ristenpart等人提出。他们证明，攻击者可以将恶意VM与目标VM <code>co-residence</code> 在同一服务器上，然后发起侧通道和隐蔽通道攻击。在现有主流云服务中实现<code>co-residence</code>仍然是可行的。为了验证在同一物理服务器上的<code>co-residence</code>，攻击者通常利用侧通道或隐蔽通道，例如，一种广泛采用的方法是使用cahe-based channel。位于同一个包上的多个实例共享最后一级缓存。通过使用一些专用的操作(如cflush)，攻击者可以通过测量缓存访问时间来检测共驻留。Liu等证明了l3缓存侧通道攻击对于跨核和跨vm攻击是可行的。Zhang等人对云进行了真实的侧通道攻击，并提出了几种防御机制来缓解这些攻击。特别是，他们证明了跨租户侧通道攻击可以成功地在PaaS中使用共存服务器进行。除了基于缓存的通道外，内存总线和内存重复数据删除也已被证明是构造隐蔽通道的有效方法。与现有的侧&#x2F;隐蔽通道研究工作不同，我们在容器云设置中发现了系统范围的信息泄漏，并设计了一种新的方法来定量评估泄漏通道的容量，以用于共居检测。另外，与最小化虚拟机的内核攻击面研究相比，我们提出了一种两级防御机制，以最小化容器云上的信息泄漏和电源攻击空间。</p>
<p>系统状态信息，如核心温度和系统功耗，也被用于构建侧&#x2F;隐蔽通道。Thiele等提出了一种基于每个核心温度的热隐蔽通道，并在局部试验台测试了容量。功耗也可能被滥用来破坏AES。在工作中，我们不使用功耗数据作为传递信息的隐蔽通道。相反，我们证明了对手可以利用主机功耗泄漏来发起更高级的<code>power attack</code>。</p>
<h2 id="Power-Modeling"><a href="#Power-Modeling" class="headerlink" title="Power Modeling"></a>Power Modeling</h2><p>在没有<code>hardware-based power meter</code>的情况下，<code>power modeling</code>是逼近功耗的一种方法。</p>
<p>Russell等和Chakrabarti等提出了指令级功率建模。他们的工作表明，分支的数量影响功耗。对虚拟机功耗的近似研究有几种。有工作证明了VM级的功耗可以通过CPU利用率和最后一级缓存失误率来估计。Mobius等将VM的功耗分为CPU、缓存、内存和磁盘。BITWATTS在细粒度流程级别上对功耗进行了建模。Shen等提出了一种power容器来计算多核系统中请求的能量消耗。我们对synergistic的防御主要是受到power modeling approach for VMs的启发。我们提出了一种新的power分区技术来近似每个容器的功耗并重用RAPL接口，从而解决了容器设置中的RAPL数据泄漏问题。</p>
<h1 id="Conlusion"><a href="#Conlusion" class="headerlink" title="Conlusion"></a>Conlusion</h1><p>容器云服务因提供轻量级操作系统级虚拟主机环境而变得流行起来。容器技术的出现深刻地改变了在云中开发和部署分布式应用程序的生态系统。但是，由于Linux内核中系统资源分区机制的不完全实现，对于共享同一个内核的多个容器租户仍然存在一些安全问题。在本文中，我们首先提出了一种系统的方法来发现可能将主机信息暴露给容器的信息泄漏通道。通过利用这些泄露的主机信息，恶意容器租户可以发起一种新型的<code>power attack</code>，这可能会危及数据中心电源系统的可靠性。此外，我们讨论了这些信息泄漏的根本原因，并提出了一个两阶段的防御机制。我们的评估表明，所提出的解决方案是有效的，并引起微不足道的性能开销。</p>
<h1 id="My"><a href="#My" class="headerlink" title="My"></a>My</h1><h2 id="Linux的incomplete-coverage"><a href="#Linux的incomplete-coverage" class="headerlink" title="Linux的incomplete coverage"></a>Linux的incomplete coverage</h2><p>Linux内核提供了对各种容器化技术的支持，使用户能够在单个主机上运行多个隔离环境。Linux内核中的容器实现主要利用一组特性，如namespace、cgroup和seccomp。然而，在Linux内核中，容器实现的某些方面可能是不完整或有限制的。以下是一些潜在的incomplete coverage范围：</p>
<ul>
<li><p>namespace：通过创建系统资源的分离视图来为容器提供隔离。虽然Linux内核支持几种命名空间（mout、PID、NET、IPC、UTS和user），但某些资源类型可能没有相应的命名空间或具有有限的支持，这可能导致不完全隔离。</p>
</li>
<li><p>control groups（cgroups）：Cgroups用于限制、记录和隔离进程组使用资源（CPU、内存、I&#x2F;O等）。虽然存在cgroups v1和v2，但某些功能可能无法在两个版本之间得到充分支持或具有局限性。这会导致容器资源管理不完整或不一致。</p>
</li>
<li><p>安全性：Linux内核提供了诸如seccomp、AppArmor和SELinux之类的安全机制来强制访问控件并限制容器可以进行哪些系统调用。但是，这些机制可能存在漏洞或限制，可能会暴露潜在的安全风险。</p>
</li>
<li><p>兼容性：容器实现的某些功能（如文件系统快照或检查点&#x2F;恢复）可能取决于特定的内核版本、存储驱动程序或文件系统。这可能导致在某些配置上出现兼容性问题和限制。</p>
</li>
<li><p>性能：虽然Linux内核为容器工作负载提供了各种优化，但仍有一些领域可以改进，例如存储I&#x2F;O或网络吞吐量。</p>
</li>
<li><p>内核更新：随着新功能和改进被添加到Linux内核中，容器实现可能需要更新以利用这些增强功能。在某些情况下，这可能会导致容器支持方面存在差距，直到它们与新的内核特性完全集成并进行测试。</p>
</li>
</ul>
<p>值得注意的是，Linux内核正在积极开发中，并且对于容器支持的改进不断被提出和实施。此外，像Docker、Kubernetes和LXC之类的容器化解决方案建立在这些内核特性之上，并提供更完整、无缝的用户体验。</p>
<h2 id="数据中心的oversubscription"><a href="#数据中心的oversubscription" class="headerlink" title="数据中心的oversubscription"></a>数据中心的oversubscription</h2><p>电力超额订阅是数据中心使用的一种策略，其中分配给服务器、存储系统和网络设备的总电源供应超过实际可用电源供应。这种方法基于一个观察结果：并非所有设备同时消耗其最大额定功率。通过利用这一点，数据中心可以托管比其电力基础设施允许更多的服务器和设备。</p>
<h2 id="Linux子系统"><a href="#Linux子系统" class="headerlink" title="Linux子系统"></a>Linux子系统</h2><p>Linux子系统是Linux内核中的一部分，负责处理特定功能或设备。例如，文件系统、网络协议栈、进程调度等都可以被认为是Linux子系统。它们通常以模块的形式实现，并在运行时加载到内核中。这些子系统允许Linux内核与硬件和外部资源进行交互，以便为上层应用程序提供所需的功能。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文是操作系统在运行某个任务时的环境，它包括一个任务所需的所有状态信息。这包括程序计数器、堆栈指针、寄存器值、内存分配信息等。执行上下文使得操作系统能够在多个任务之间进行切换，以实现多任务并发执行。</p>
<h2 id="Linux子系统不能区分容器和主机之间的执行上下文，可能泄露系统信息"><a href="#Linux子系统不能区分容器和主机之间的执行上下文，可能泄露系统信息" class="headerlink" title="Linux子系统不能区分容器和主机之间的执行上下文，可能泄露系统信息"></a>Linux子系统不能区分容器和主机之间的执行上下文，可能泄露系统信息</h2><p>容器是一种轻量级的虚拟化技术，允许在同一主机上运行多个隔离的应用程序。容器与主机共享相同的内核，但每个容器都有其独立的文件系统、进程空间、网络接口等。容器技术的一个关键优势是资源隔离，这意味着每个容器只能访问分配给它的资源，而不能访问其他容器或主机的资源。</p>
<p>然而，某些Linux子系统可能无法区分容器和主机之间的执行上下文。这意味着当容器化应用程序访问这些子系统时，它们可能能够访问不应暴露给它们的系统范围信息。这可能导致安全和隐私问题，因为容器之间和容器与主机之间的隔离可能被破坏。</p>
<p>例如，如果某个Linux子系统负责处理系统范围的统计信息（如CPU使用率、内存使用情况等），那么容器内的应用程序可能能够访问这些信息，从而获取其他容器或主机的资源使用情况。这可能导致容器之间的信息泄露，破坏了它们之间的隔离。</p>
<p>为了解决这个问题，容器运行时和内核开发人员需要确保所有Linux子系统都能够正确地区分容器和主机之间的执行上下文，以实现更强大的隔离和安全性。这可能包括修改子系统的实现，以便它们能够识别和处理来自容器的请求，以及限制容器访问系统范围信息的能力。</p>
<h2 id="Namespace和cgroup以及具体实现"><a href="#Namespace和cgroup以及具体实现" class="headerlink" title="Namespace和cgroup以及具体实现"></a>Namespace和cgroup以及具体实现</h2><p>Linux中的Namespace和Cgroup是两种操作系统级别的资源管理和隔离技术。它们在容器技术（如Docker）中被广泛应用，用于实现轻量级虚拟化。</p>
<p><strong>Namespace（命名空间）</strong> 是Linux内核提供的一种隔离技术，允许创建多个独立的空间，每个空间内可以有自己的进程、文件系统、网络等资源。Namespace有以下几种类型：</p>
<ul>
<li>Mount Namespace：隔离不同命名空间的文件系统挂载点。</li>
<li>PID Namespace：隔离进程ID空间，使每个命名空间有独立的PID。</li>
<li>Network Namespace：隔离网络接口和路由表，使每个命名空间有独立的网络环境。</li>
<li>IPC Namespace：隔离System V IPC对象和POSIX消息队列。</li>
<li>UTS Namespace：隔离主机名和域名。</li>
<li>User Namespace：隔离用户和组ID。</li>
</ul>
<p><strong>Cgroup（控制组）</strong> 是Linux内核提供的一种资源管理技术，允许对一组进程进行资源限制、优先级调整等操作。Cgroup通过将进程组织到层次结构的控制组中来实现资源管理。主要有以下几类资源控制：</p>
<ul>
<li>CPU：限制进程的CPU使用率。</li>
<li>Memory：限制进程的内存使用。</li>
<li>Block I&#x2F;O：限制进程的磁盘I&#x2F;O。</li>
<li>Network：限制进程的网络带宽。</li>
</ul>
<p>以下是一个简单的Namespace和Cgroup的使用示例：</p>
<ol>
<li>安装相关工具：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cgroup-tools</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个新的Namespace（使用<code>unshare</code>命令）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo unshare --uts --pid --mount-proc --fork /bin/bash</span><br></pre></td></tr></table></figure>

<p>这个命令创建了一个新的Namespace，并在其中启动了一个新的bash进程。这个新的Namespace具有独立的UTS、PID和挂载的&#x2F;proc文件系统。</p>
<ol start="3">
<li>创建一个新的Cgroup（使用<code>cgcreate</code>命令）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cgcreate -g cpu,memory:/my_cgroup</span><br></pre></td></tr></table></figure>

<p>这个命令创建了一个名为<code>my_cgroup</code>的新Cgroup，用于管理CPU和内存资源。</p>
<ol start="4">
<li>为Cgroup分配资源限制（使用<code>cgset</code>命令）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cgset -r cpu.shares=512 my_cgroup</span><br><span class="line">sudo cgset -r memory.limit_in_bytes=100M my_cgroup</span><br></pre></td></tr></table></figure>

<p>这个命令为<code>my_cgroup</code>设置了CPU份额为512（相对权重）和内存限制为100MB。</p>
<ol start="5">
<li>将进程添加到Cgroup（使用<code>cgclassify</code>命令）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cgclassify -g cpu,memory:my_cgroup &lt;PID&gt;</span><br></pre></td></tr></table></figure>

<p>将指定的进程PID添加到<code>my_cgroup</code>中，使其受到Cgroup资源限制的约束。</p>
<p>以上示例展示了如何使用Namespace和Cgroup进行资源隔离和管理。在实际应用中，这些技术通常与容器运行时（如Docker）结合使用，以提供更高级别的抽象和管理工具。</p>
<h2 id="Namespace和Cgroup的具体使用"><a href="#Namespace和Cgroup的具体使用" class="headerlink" title="Namespace和Cgroup的具体使用"></a>Namespace和Cgroup的具体使用</h2><p><code>Namespace</code> 和 <code>cgroup</code> 是 Linux 内核提供的两个关键特性，它们在容器技术（如 Docker）中发挥着重要作用。<code>Namespace</code> 负责为容器提供独立的视图，使得容器在网络、进程、文件系统等方面与主机和其他容器隔离。而 <code>cgroup</code>（控制组）则负责限制和管理容器的资源使用（如 CPU、内存、磁盘 I&#x2F;O 等）。</p>
<p><strong>Namespace 例子：</strong></p>
<p>假设我们想要创建一个新的网络 Namespace，使容器具有独立的网络栈。我们可以使用 <code>ip</code> 命令来实现这一目标：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的网络 Namespace</span></span><br><span class="line">sudo ip netns add my_namespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将网络设备 veth0（容器端）和 veth1（主机端）添加到新的 Namespace</span></span><br><span class="line">sudo ip <span class="built_in">link</span> add veth0 <span class="built_in">type</span> veth peer name veth1</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 netns my_namespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置容器端网络设备</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> my_namespace ip addr add 192.168.1.2/24 dev veth0</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> my_namespace ip <span class="built_in">link</span> <span class="built_in">set</span> veth0 up</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> my_namespace ip route add default via 192.168.1.1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置主机端网络设备</span></span><br><span class="line">sudo ip addr add 192.168.1.1/24 dev veth1</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth1 up</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个新的网络 Namespace，并配置了一对虚拟以太网设备（<code>veth0</code> 和 <code>veth1</code>），将容器的网络与主机网络连接起来。这使得容器可以拥有独立的网络栈，与主机和其他容器隔离。</p>
<p><strong>cgroup 例子：</strong></p>
<p>假设我们想要限制容器的 CPU 和内存资源。我们可以使用 <code>cgroup</code> 来实现这一目标：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个新的 cgroup</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /sys/fs/cgroup/cpu/my_cgroup</span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /sys/fs/cgroup/memory/my_cgroup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制容器的 CPU 使用率为 50%</span></span><br><span class="line"><span class="built_in">echo</span> 50000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_us</span><br><span class="line"><span class="built_in">echo</span> 100000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_period_us</span><br><span class="line"></span><br><span class="line"><span class="comment"># 限制容器的内存使用为 100MB</span></span><br><span class="line"><span class="built_in">echo</span> 100000000 &gt; /sys/fs/cgroup/memory/my_cgroup/memory.limit_in_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个新的容器，并将其添加到我们之前创建的 cgroup</span></span><br><span class="line">docker run -itd --name=my_container ubuntu:18.04</span><br><span class="line"><span class="built_in">echo</span> $(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> my_container) &gt; /sys/fs/cgroup/cpu/my_cgroup/cgroup.procs</span><br><span class="line"><span class="built_in">echo</span> $(docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> my_container) &gt; /sys/fs/cgroup/memory/my_cgroup/cgroup.procs</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个新的 CPU 和内存 <code>cgroup</code>，并限制了容器的 CPU 使用率和内存使用。然后我们启动了一个新的容器，并将其添加到我们之前创建的 <code>cgroup</code> 中，这样容器的资源使用就受到了限制。</p>
<p>综上所述，<code>Namespace</code> 和 <code>cgroup</code> 在容器技术中发挥着重要作用，使得容器可以在资源使用和隔离方面实现更精细的控制。</p>
<h2 id="Linux中的pseudo-file"><a href="#Linux中的pseudo-file" class="headerlink" title="Linux中的pseudo file"></a>Linux中的pseudo file</h2><p>在 Linux 系统中，伪文件（pseudo file）是一种特殊类型的文件，它们提供了与系统内核和设备驱动程序交互的途径。伪文件并不包含实际的文件数据，而是在用户和内核空间之间提供了一个通信接口。这些文件通常位于 <code>/proc</code> 和 <code>/sys</code> 文件系统中。</p>
<p><code>/proc</code> 文件系统是一个虚拟文件系统，包含了许多伪文件，这些伪文件可以用来监控和调整系统内核的运行状态。例如，<code>/proc/cpuinfo</code> 提供了有关处理器的详细信息，<code>/proc/meminfo</code> 提供了关于系统内存使用情况的数据。这些伪文件可以像普通文件一样使用命令行工具（如 <code>cat</code>、<code>grep</code> 等）进行查看和操作。</p>
<p><code>/sys</code> 文件系统是另一个虚拟文件系统，用于 Linux 内核的设备管理。它包含了许多伪文件，这些伪文件提供了对系统设备的配置和状态信息的访问。<code>/sys</code> 文件系统的结构更加规范化，按照设备、总线和驱动程序的层次关系进行组织。</p>
<p>总之，伪文件在 Linux 系统中提供了一种简单、统一的方法，使用户能够方便地访问和修改系统内核和设备驱动程序的状态信息。</p>
<h2 id="pseudo-file和真实文件的区别"><a href="#pseudo-file和真实文件的区别" class="headerlink" title="pseudo file和真实文件的区别"></a>pseudo file和真实文件的区别</h2><p>伪文件（pseudo file）和真实文件在 Linux 系统中具有不同的特点和用途。以下是它们之间的主要区别：</p>
<ol>
<li><p><strong>数据存储</strong>：真实文件存储在磁盘上，包含实际的文件数据。而伪文件并不包含实际的文件数据，它们通常不存在于磁盘上，而是由内核动态生成，用于在用户空间和内核空间之间提供通信接口。</p>
</li>
<li><p><strong>用途</strong>：真实文件用于存储和读取数据，例如文档、图像或程序。伪文件主要用于提供系统信息、监控和调整内核参数或设备驱动程序的状态。它们可以让用户通过文件系统接口与内核交互，而无需使用特殊的系统调用。</p>
</li>
<li><p><strong>位置</strong>：真实文件通常分布在整个文件系统中，根据目录结构进行组织。伪文件主要位于特定的虚拟文件系统中，例如 <code>/proc</code>（用于内核参数和进程信息）和 <code>/sys</code>（用于设备管理）。</p>
</li>
<li><p><strong>访问方式</strong>：伪文件和真实文件都可以使用类似的命令行工具（如 <code>cat</code>、<code>grep</code> 等）进行查看和操作。然而，伪文件通常是只读的或仅支持特定操作，它们的内容可能会随着系统状态的变化而动态改变。</p>
</li>
</ol>
<p>总之，伪文件和真实文件在数据存储、用途、位置和访问方式上存在显著差异。伪文件主要用于提供与内核和设备驱动程序的交互途径，而真实文件用于存储和读取实际数据。</p>
<h2 id="伪文件例子"><a href="#伪文件例子" class="headerlink" title="伪文件例子"></a>伪文件例子</h2><p><code>/proc/loadavg</code> 伪文件是由内核动态生成的，不在磁盘上存在。它允许用户和程序通过熟悉的文件系统接口访问负载平均值信息，而无需使用特殊的系统调用。</p>
<p>要使用 <code>/proc/loadavg</code>，您可以像读取常规文件一样简单地读取其内容。例如，您可以使用 <code>cat</code> 命令在终端中显示其内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/loadavg</span><br></pre></td></tr></table></figure>

<p>输出可能类似于以下内容：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">0</span>.<span class="number">51</span> <span class="number">0</span>.<span class="number">38</span> <span class="number">0</span>.<span class="number">35</span> <span class="number">1</span>/<span class="number">1234</span> <span class="number">5678</span></span><br></pre></td></tr></table></figure>

<p>这些数字分别表示 1 分钟、5 分钟和 15 分钟的负载平均值，后面的数字表示当前正在运行的进程数&#x2F;系统总进程数，以及最近分配的进程 ID。</p>
<p>总之，<code>/proc/loadavg</code> 是一个伪文件的示例，它为访问 Linux 系统中的负载平均值信息提供了一个接口，无需使用特殊的系统调用。</p>
]]></content>
      <categories>
        <category>论文精读</category>
        <category>内核安全</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>云安全</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 Houdini’s Escape: Breaking the Resource Rein of Linux Control Groups</title>
    <url>/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/</url>
    <content><![CDATA[<p><strong>摘要</strong></p>
<p>Linux Control Groups，即cgroups，是启用操作系统级容器化的关键构建块。cgroups机制将进程划分为分层的组，并应用不同的控制器来管理系统资源，包括CPU、内存、块I&#x2F;O等。新生成的子进程自动从父进程中复制cgroups属性以加强资源控制。不幸的是，通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。在本文中，我们设计了一套利用策略，通过将进程与原始进程组解关联来生成out-of-band工作负载。这样的工作负载所消耗的系统资源不会被计算到适当的cgroup中。</p>
<p>为了进一步证明可行性，我们提供了Docker容器中的五个案例研究，以演示如何在现实场景中打破cgroup的资源限制。更糟糕的是，通过利用这些cgroups在多租户容器环境中的不足，攻击容器能够极大地扩大所消耗的资源数量，显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们在本地测试平台和Amazon EC2云专用服务器上进行了大量的实验。实验结果表明，一个容器可以消耗系统资源(例如CPU)高达其极限的200倍，并使其他共存容器中特定工作负载的计算和I&#x2F;O性能降低95%。</p>
<p> <strong>CCS CONCEPT</strong></p>
<ul>
<li>Security and privacy → Virtualization and security</li>
</ul>
<p><strong>KEYWORDS</strong></p>
<p>Container；Control Group；Docker</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。</p>
<p>尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。</p>
<p>在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即namespaces)和Linux控制组(即cgroups)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。</p>
<p>容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞。</p>
<p>容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。</p>
<p>尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。</p>
<p>在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即命名空间)和Linux控制组(即cgroups1)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。</p>
<p>容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞</p>
<p>在本文中，我们打算系统地探讨一下来摆脱现有的cgroups机制的资源控制、<br>并了解其对容器的安全影响。新创建的子进程会自动继承其父进程的cgroups属性。这种机制保证了它们将被限制在相同的cgroups策略下。为了打破cgroups的资源约束，我们设计了一套利用策略，通过将进程与其原始cgroups分离，生成了一些带外工作负载。这意味着这些进程不再受到原始cgroups的资源限制，从而可能绕过原本的资源管理策略。这些进程可以从头开始创建，以处理在一个cgroup内发起的系统事件。在其他情况下，这些进程可以是休眠的内核线程或系统服务进程。在整个系统中共享，并将在需要时被激活。因此，相应的消耗的资源将被收取到其他 “受害者 “cgroups中。</p>
<p>为了进一步揭示现有cgroup机制不足的安全风险，我们使用Docker容器进行了五个案例研究，展示了在现实系统设置中逃脱cgroup资源控制的步骤。在这些案例研究中，我们分别利用了异常、文件系统和I&#x2F;O设备、Linux日志系统、容器引擎和softirqs处理的内核处理机制。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行实验。我们的实验表明，即使执行了多个cgroup控制器，一个对抗性去特权容器仍然可以显著耗尽CPU资源或产生大量的I&#x2F;O活动，而不需要任何cgroup控制器。</p>
<p>更糟糕的是，通过在多租户容器环境中利用这些机制，对抗性容器能够极大地扩大所消耗的资源量。由于对抗容器会发动多种攻击(如拒绝服务攻击和资源释放攻击)，可以显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们的实验证明，对手仅通过控制少量资源就能显著影响共存容器的性能。例如，一个容器可能会消耗系统资源(例如CPU)，超过其极限200倍，并使其他容器的特定基准的计算和I&#x2F;O性能降低95%。总体而言，本工作的主要贡献总结如下:</p>
<ul>
<li><p>我们提出了四种可能导致系统资源错误计算的开发策略，因此我们可以逃避cgroup控制器强制执行的资源约束。</p>
</li>
<li><p>我们在Docker容器环境中进行了五个案例研究，并证明了在现实场景中打破cgroup限制并消耗大量资源是可能的。</p>
</li>
<li><p>我们在两个具有不同配置的试验台上评估了所提出的方法的影响。实验结果表明了安全影响的严重性。</p>
</li>
</ul>
<p>本文的其余部分组织如下。第二节介绍了cgroup的背景。第3节介绍了逃脱cgroups机制控制的策略，并从内核的角度分析了其根本原因。第4节详细介绍了容器的几个案例研究，包括威胁模型、攻击向量以及对多租户容器环境的各种攻击的有效性。第5节从不同方面讨论了潜在的缓解措施。第6节对相关工作进行考察，并在第7节中进行总结。</p>
<h1 id="BACKGROUND"><a href="#BACKGROUND" class="headerlink" title="BACKGROUND"></a>BACKGROUND</h1><p>在Linux内核中，cgroups是用于管理一组任务及其所有子任务的系统资源(例如CPU、内存、磁盘I&#x2F;O、网络等)的关键特性。它是实现集装箱化的构建块之一。cgroup机制将进程组划分为具有控制行为的分层组。所有的子进程也从它们的父进程继承某些属性(例如，limits)，并由该机制控制。cgroups依赖于不同的资源控制器(或子系统)来限制、解释和隔离各种类型的系统资源，包括CPU时间、系统内存、块I&#x2F;O、网络带宽等。Linux容器利用控制组对每个容器实例应用资源限制，并防止单个容器耗尽主机资源。对于云计算中的计费模型，还可以使用cgroups为每个容器分配相应的资源并测量它们的使用情况。下面我们简要介绍cgroup层次结构的背景知识，现有容器环境中通常应用的四种典型的cgroup控制器，以及新生成进程的cgroup继承过程。</p>
<h2 id="cgroups-Hierarchy-and-Controllers"><a href="#cgroups-Hierarchy-and-Controllers" class="headerlink" title="cgroups Hierarchy and Controllers"></a>cgroups Hierarchy and Controllers</h2><p>在Linux中，cgroup是按层次结构组织的，其中一组cgroup被排列在树中。每个任务(例如，一个线程)只能与一个层次结构中的一个cgroup相关联，但可以是不同层次结构中的多个cgroup的成员。然后，每个层次结构都有一个或多个附加子系统，以便资源控制器可以对特定的系统资源应用每个cgroup限制。通过分层结构，cgroups机制能够限制一组进程(例如容器)的资源总量。</p>
<h3 id="The-cpu-controller"><a href="#The-cpu-controller" class="headerlink" title="The cpu controller"></a>The cpu controller</h3><p>cpu controller通过利用CFS(完全公平的调度器，在Linux 2.6.23中引入)调度cpu，以两种方式使cpu成为可管理的资源。</p>
<p>第一种方法是保证最少数量的CPU共享:每个组都提供相应的共享，以定义相对权重。该策略在CPU空闲时不限制cgroup的CPU使用率，当多个cgroup竞争相同的CPU资源时，按照权重的比例分配带宽。例如，如果共享为512的一个容器与共享为1024的另一个容器运行在同一个核心上。然后，第一个容器的CPU使用率大致为33.3%，而另一个容器的CPU使用率为66.7%。在Linux 3.2中进一步扩展了cpu控制器，通过指定配额和周期来提供额外的cpu带宽控制。</p>
<p>每个组只能在每个给定的“时间段”(以微秒为单位)内消耗“配额”微秒。如果一个组的CPU带宽消耗(由运行时变量跟踪)超过了限制，控制器将限制该任务，直到下一个时间段，此时容器的运行时被重新充电到其配额。cpu控制器被广泛应用于多租户容器环境，以限制一个容器的cpu使用。如果容器设置的配额为50,000，周期为100,000，则该容器最多可以消耗一个CPU核心总CPU周期的一半。</p>
<h3 id="The-cpusets-controller"><a href="#The-cpusets-controller" class="headerlink" title="The cpusets controller"></a>The cpusets controller</h3><p>cpusets控制器提供了一种机制，用于将一组任务约束到特定的cpu和内存节点。在多租户容器环境中，利用cpusets控制器来限制特定核心上容器的工作负载。容器的每个任务都附加到一个cpuset，其中包含一组允许使用的cpu和内存节点。对于CPU调度，任务的调度(通过系统调用sched_setaffinity)被过滤到任务的cpusset允许的那些CPU。任务的任何进一步的动态迁移也仅限于允许的cpuset。因此，cpusets控制器还可以用于将一个进程固定在特定的核心上。容器用户还可以利用用户空间应用程序(例如，taskset)在cpuset的限制范围内进一步设置亲和性。</p>
<h3 id="The-blkio-controller"><a href="#The-blkio-controller" class="headerlink" title="The blkio controller"></a>The blkio controller</h3><p>blkio cgroup通过应用I&#x2F;O控制来控制和限制对指定块设备的访问。内核级有两个策略可用。第一个是基于比例权重的基于时间的磁盘策略划分。每个cgroup都被分配了一个blkio。权重值，表示该组占用磁盘时间的比例。第二个是节流策略，它指定I&#x2F;O设备上的上限。</p>
<h3 id="The-pid-controller"><a href="#The-pid-controller" class="headerlink" title="The pid controller"></a>The pid controller</h3><p>pid cgroup子系统用于对容器的任务数量设置一定的限制。这可以通过在pid.max中设置最大任务数来实现。当前任务数保存在pid .current中。pid cgroup子系统将在达到限制(例如，pid.current&gt; pid .max)停止forking或克隆一个新任务(例如，返回错误信息)。因此，pid控制器可以有效防御多种耗尽攻击，如fork bomb。</p>
<h2 id="cgroups-Inheritance"><a href="#cgroups-Inheritance" class="headerlink" title="cgroups Inheritance"></a>cgroups Inheritance</h2><p>cgroups的一个重要特性是子进程从父进程继承cgroups属性。每当一个进程创建一个子进程(例如，fork或clone)时，它都会触发内核中的fork函数来复制初始化进程。当新派生的进程在开始时附加到根cgroup时，在复制寄存器和进程环境的其他适当部分(例如，命名空间)后，调用cgroup复制函数来复制父进程的cgroup。特别是，该函数通过递归遍历所有cgroup子系统，将任务附加到其父cgroup。因此，在复制过程之后，子任务将继承与其父任务完全相同的cgroups成员。</p>
<p>例如，如果cpusets资源控制器将父进程的the CPU affinity设置为第二个核心，那么新派生的子进程也将被固定在第二个核心上。同时，如果cpu子系统将父cgroup上的cpu配额限制为50,000，周期为100,000，那么在第二个核上，cgroup的总cpu利用率(包括新分叉的进程和它的父进程)不能超过50%。</p>
<h1 id="EXPLOITING-STRATEGIES"><a href="#EXPLOITING-STRATEGIES" class="headerlink" title="EXPLOITING STRATEGIES"></a>EXPLOITING STRATEGIES</h1><p>在本节中，我们将描述四种逃避cgroups机制的资源控制的策略，并解释现有cgroup无法跟踪所消耗资源的根本原因。如上所述，使用层次结构，cgroups机制可以限制一组进程(例如容器)的资源总量。这是通过附加资源控制器对特定的系统资源应用每cgroup限制来实现的。此外，cgroup中的继承机制确保了同一个cgroup中的所有进程及其子进程都可以被cgroup子系统控制，而不消耗额外的系统资源。</p>
<p>然而，由于Linux内核的复杂性和实现cgroups的难度，我们发现有几个机制没有考虑到，因此可以利用它们来逃避现有cgroups的约束。关键思想是生成工作负载，运行在没有直接从初始化cgroup派生出来的进程上，这导致了cgroup的去关联。特别是，如图所示，用户空间中没有根权限的普通进程可以利用四种策略逃脱cgroups的控制。</p>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/strategies.png" title alt data-align="center">

<h2 id="Exploiting-Upcalls-from-Kernel"><a href="#Exploiting-Upcalls-from-Kernel" class="headerlink" title="Exploiting Upcalls from Kernel"></a>Exploiting Upcalls from Kernel</h2><p>在cgroups机制中，所有内核线程都附加到根cgroup，因为内核线程是由内核创建的。因此，内核线程通过fork或clone创建的所有进程也都附加到与其父进程相同的cgroup(根cgroup)中。</p>
<p>因此，一个cgroup中的进程可以利用内核线程作为代理来产生新的进程，从而逃脱cgroup的控制。特别地，如图❶所示，一个进程可以先触发内核来初始化一个内核线程。</p>
<p>这个内核线程充当代理，进一步创建一个新进程。</p>
<p>由于内核线程附加到根cgroup，因此新创建的进程也附加到根cgroup。在新创建的进程上运行的所有工作负载将不受cgroup子系统的限制，从而打破资源控制。</p>
<p>但是，这种机制要求用户空间进程首先调用内核空间中的内核函数，然后从内核空间向上调用用户空间进程。虽然从用户空间调用特定的内核函数(例如系统调用)是很自然的，但相反的方向并不常见。一种可行的方法是通过usermode helper API，该API通过提供可执行变量和环境变量的名称，为在用户空间中创建流程提供了一个简单的接口。这个函数首先调用一个运行在内核线程中的工作队列(例如，kworker)。工作队列的处理函数进一步创建一个内核线程来启动用户进程。最后一步调用内核中的fork函数，将创建的用户进程附加到内核线程的cgroups。</p>
<p>用户模式助手API可用于多种场景，如加载模块、重新启动计算机、生成安全密钥和传递内核事件。虽然在用户空间中触发这些活动通常需要root权限，但仍然可以在用户空间中调用API，这将在4.1节中讨论。</p>
<h2 id="Delegating-Workloads-to-Kernel-Threads"><a href="#Delegating-Workloads-to-Kernel-Threads" class="headerlink" title="Delegating Workloads to Kernel Threads"></a>Delegating Workloads to Kernel Threads</h2><p>另一种利用内核线程来打破cgroup约束的方法是将工作负载委托给它们，如图❷所示。同样，由于所有内核线程都附加到根cgroup，因此这些工作负载所消耗的资源量将计入目标内核线程，而不是初始化用户空间进程。</p>
<p>Linux内核运行多个内核线程，处理各种内核函数并在进程上下文中运行内核代码。例如，kthread是内核线程守护进程，用于创建其他内核线程;引入Kworker来处理工作队列任务;Ksoftirqd服务于softirqs;迁移执行迁移作业，将任务从一个核心移动到另一个核心;kswapd管理交换空间。对于这些内核线程，根据它们的功能，内核可能只在系统中运行一个线程(例如kthread)，或者每个内核运行一个线程(例如ksoftirqd)，或者每个内核运行多个线程(例如kworker)。一直有报道称，由于各种bug和问题，内核线程会消耗大量的资源。因此，如果一个进程可以强制内核线程运行委托的工作负载，相应消耗的资源将不受cgroup的限制。</p>
<h2 id="Exploiting-Service-Processes"><a href="#Exploiting-Service-Processes" class="headerlink" title="Exploiting Service Processes"></a>Exploiting Service Processes</h2><p>除了由内核维护的内核线程外，Linux服务器还运行多个系统进程(例如systemd)，用于不同的目的，如进程管理、系统信息日志记录、调试等。这些流程监视其他流程，并在触发特定活动时生成工作负载。同时，许多用户空间进程作为其他进程的依赖关系，同时运行以支持其他进程的正常功能。如果一个用户进程能够在这些进程上生成内核工作负载(图中的策略❸ )，所消耗的资源就不会被分配给初始化进程，从而可以逃脱cgroups机制。</p>
<h2 id="Exploiting-Interrupt-Context"><a href="#Exploiting-Interrupt-Context" class="headerlink" title="Exploiting Interrupt Context"></a>Exploiting Interrupt Context</h2><p>最后一种策略是利用中断上下文中所消耗的资源。cgroup机制只计算在进程上下文中消耗的资源。一旦内核运行在其他上下文(如中断上下文,如图所示的策略❹),所有消耗的资源都不会被计入任何cgroup</p>
<p>特别地，Linux内核服务中断分为两部分:上半部分(即硬件中断)和下半部分(即软件中断)。由于硬件中断可能随时被引发，因此上半部分仅通过响应硬件中断来执行轻量级操作，然后安排(延迟)下半部分的执行。当在下半部分执行中断处理程序时，内核运行在软件中断上下文中，因此它不会为系统资源(例如CPU)收取任何进程的费用。</p>
<p>从内核3.6开始，softirq的处理(硬件中断引发的除外)与生成它们的进程绑定。</p>
<p>这意味着在softirq上下文中所消耗的所有资源都不会消耗所引发进程的任何配额。此外，softirqs的执行将抢占当前进程上的任何工作负载，所有进程将被延迟。</p>
<p>此外，如果处理softirqs的工作负载过重，内核将把它们卸载到内核线程ksoftirqd，这是一个每个CPU(即每个CPU一个线程)的内核线程，并以默认的进程优先级运行。一旦卸载，对softirqs的处理将在ksoftirqd的进程上下文中运行，因此任何资源消耗都将在线程ksoftirqd上计算。在这种情况下，它属于内核线程策略(如图所示的策略❷ )。总之，如果一个进程(称为进程A)能够引发大量的软件中断，内核将不得不在中断上下文或ksoftirqd的进程上下文中花费资源来处理软中断，而不向进程A支付费用。</p>
<h1 id="CASE-STUDIES-ON-CONTAINERS"><a href="#CASE-STUDIES-ON-CONTAINERS" class="headerlink" title="CASE STUDIES ON CONTAINERS"></a>CASE STUDIES ON CONTAINERS</h1><p>在前一节中，我们讨论了几种可能的策略来逃避cgroups的资源控制。然而，在现实的容器环境中，由于存在其他合作安全策略，开发更具挑战性。在本节中，我们将介绍在Docker容器环境中进行的五个案例研究，以演示利用cgroups弱点的详细步骤。</p>
<ul>
<li><p>Threat model</p>
<p>我们考虑一个多租户容器环境，其中属于不同租户的多个Docker容器共享同一台物理机器。目前，边缘和云平台都广泛采用了多租户环境。系统管理员使用cgroups为每个容器设置资源限制。每个容器都是去特权的，设置有有限的CPU时间、系统内存、块I&#x2F;O带宽，并固定到特定的核心。我们假设攻击者控制了一个容器实例，并试图利用cgroups中的不足(1)降低其他容器的性能，(2)获得不公平的优势。</p>
</li>
<li><p>Configuration</p>
<p>我们使用Docker容器通过提供的接口来设置cgroups的配置。此外，Docker还默认确保容器通过namespace隔离。特别是，启用USER namespace后，容器中的根用户将映射到主机上的非特权用户。</p>
<p>因此，容器中的特权操作不会影响主机内核。我们的案例研究就是在这样一个没有特权的容器中进行的。</p>
<p>为了演示每种利用的有效性，我们通过在空闲服务器上设置多个cgroup配置来初始化容器，并测量主机上系统资源的利用率。为了模拟边缘和云环境，我们选择了两个测试平台来进行实验:(1)我们实验室的本地机器;(2) Amazon EC2中的专用主机。特别是，虽然我们的本地测试台配备了7200 rpm的SATA硬盘驱动器，但我们在EC2服务器上选择了更好的I&#x2F;O配置。专用试验台的存储配置了1000iops的SSD(默认为400)，吞吐量比我们本地试验台提高20倍左右。因此，本地测试平台表示可能部署在边缘环境中的性能较低的节点，而强大的专用服务器可以模拟多租户容器云环境。</p>
</li>
<li><p>Ethical hacking concerns</p>
<p>使用cgroup将不可避免地产生主机级的影响，这可能会影响主机服务器上所有容器的性能。因此，对于我们在Amazon EC2上的实验，我们选择使用专用服务器，该服务器仅供我们使用，不与其他租户共享。</p>
<p>此外，它还允许我们模拟多租户容器环境并度量系统范围的影响。</p>
</li>
<li><p>Result summary</p>
<p>表给出了所有案例研究的总体总结、相应的开发策略和影响。第一个案例研究是利用内核中的异常处理机制，这涉及到策略❶。我们发现容器中引发的异常可以调用用户空间进程，其后果是容器可以消耗比cgroups限制多200倍的CPU资源。第二种情况是利用回写机制进行磁盘数据同步，这涉及到策略❷。容器可以不断调用全局数据同步，以降低主机上特定I&#x2F;O工作负载的速度，最高可达95%。第三种情况是利用系统服务日志(通过策略❸)，产生消耗CPU和块设备带宽的工作负载。第四种情况是利用容器引擎在容器引擎进程(策略❸)和内核线程(策略 ❷)上产生额外的未计算的工作负载(大约3倍)。最后一种情况是利用softirq处理机制在内核线程(策略 ❷)和中断上下文(策略❹)上消耗CPU周期。</p>
</li>
</ul>
<img title src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Summary2.png" alt data-align="center">

<h2 id="Case-1-Exception-Handling"><a href="#Case-1-Exception-Handling" class="headerlink" title="Case 1:Exception Handling"></a>Case 1:Exception Handling</h2><p>第一种情况是利用内核中的异常处理机制。我们发现可以调用用户模式助手API，并通过异常进一步触发用户空间流程(作为策略❶)。通过反复产生异常，一个容器消耗的CPU资源比限制多约200倍，从而使同一主机(不限于一个核)上其他容器的性能显著降低85% ~ 95%。</p>
<ul>
<li><p>Detailed analysis </p>
<p>Linux内核为各种异常提供了专用的异常处理程序，包括错误(例如，分割错误)和陷阱(例如，溢出)。内核维护一个中断描述符表(IDT)，其中包含每个中断或异常处理程序的地址。如果CPU在用户模式下引发异常，相应的处理程序将在内核模式下调用。处理器首先在内核堆栈中保存寄存器，然后相应地处理异常，最后返回到用户模式。整个过程在内核空间和触发异常的进程上下文中运行。因此，它将被充电到正确的相应的cgroups。</p>
<p>然而，这些异常将导致初始进程的终止并引发信号。这些信号将进一步触发内核转储功能，生成一个用于调试的内核转储文件。内核中的核心转储代码通过usermode辅助API从内核中调用一个用户空间的应用程序。在Ubuntu中，默认的用户空间核心转储程序是Apport，它将在每个异常情况下被触发。正如上一节所提到的，Apport所消耗的系统资源将不会由容器承担，因为该进程是由内核线程分叉的，而不是由容器化的进程。</p>
<p>新产生的Apport实例将被内核安排到所有的CPU核心，以达到负载平衡的目的，因此打破了cpusets的cgroup。同时，由于Apport进程的运行比轻量级的异常处理（即内核控制路径）消耗更多的资源，如果容器不断引发异常，整个CPU将被Apport进程完全占据。cpu cgroup的逃逸导致分配给容器的系统资源的巨大放大。</p>
</li>
<li><p>Workloads amplification</p>
<p>为了研究这种影响，我们在一个核心上启动并固定一个容器。我们通过调整周期和配额来为容器设置不同的CPU资源限制。</p>
<p>容器进入循环，不断引发异常。我们实现了几种用户空间程序可用的异常类型。由于不同类型的异常的结果是相似的，我们使用div 0异常作为例子。容器是唯一在我们的测试平台中运行的活动程序。我们通过top命令测量测试平台的CPU使用率，通过Docker的统计工具测量容器的CPU使用率。对于主机级别的使用情况，我们将所有内核的CPU使用量汇总在一起（因此12个内核的最大使用量为1200%）。我们将放大系数定义为主机的CPU利用率与容器的CPU利用率的比率。</p>
<p>图演示了用户模式助手API可以触发用户空间程序，从而显著提高容器的CPU使用率。在我们的本地测试平台上，容器使用的一个内核上的CPU利用率只有7.4%，整个12个内核都被占用了。当我们将分配给容器的CPU资源减少到仅10%内核(通过设置period为200,000,quota为20,000)后，这个问题无法缓解。我们进一步将容器的CPU限制降低到20%核心，并最终将12个核心的总利用率限制到1,065%，放大因子为207×。同时，系统内存使用增加了约1GB，而Docker测量的容器内存使用仅为15.58MB。</p>
<p>我们从EC2服务器上获得了类似的结果:容器的22.5%的利用率就可以耗尽36个内核。由于CPU频率不如我们的本地测试平台强大，一旦我们将容器的CPU资源限制为1&#x2F;10内核，它可以在所有36个内核上产生1907%的利用率。放大系数约为192×。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Workload.png" title alt data-align="center">

<ul>
<li><p>The pid controller</p>
<p>虽然放大要求容器不断抛出异常，但我们进一步使用pid cgroup子系统对容器的任务数量设置一定的限制。同样，如图所示，即使活动进程的数量被限制在50个，pid控制器也不能降低放大结果，这是一个非常小的数字，可能会对容器用户造成巨大的可用性影响。在单核CPU计算能力只有20%的情况下，将pid限制为50，放大系数可以降低到98×。在EC2服务器上，在单核10% CPU计算能力的容器上，通过将pid数量限制在50个，放大系数在144×左右.</p>
</li>
<li><p>Denial-of-service(DoS) attacks</p>
<p>当多个容器在同一个核心上运行时，它们将共享和竞争CPU资源。Linux的CFS系统根据每个容器的份额来分配CPU周期。CFS系统确保了完全的公平性，即容器可以完全利用其插槽中的所有资源。然而,如果一个恶意的容器可以在它自己的cgroup之外产生新的工作负载，CFS系统也会将CPU周期分配给这些进程，从而减少其他co-residence容器的使用。同时，CPU使用率的下降也可能影响其他的性能，如内存和I&#x2F;O吞吐量。</p>
<p>在我们的实验中，我们通过利用恶意容器中的异常处理机制来衡量DoS攻击的影响。我们运行两个容器:一个恶意容器和一个受害者。我们将攻击的性能与恶意容器运行正常工作负载(即基线)的情况进行比较。受害容器运行不同的sysbench工作负载来度量性能。</p>
<p>这两个服务器上的结果如表所示。我们首先将两个容器设置在相同的内核上，使用完全相同的CPU共享和配额。我们发现，在我们的本地测试平台上，抛出异常(导致内核转储)可以显著降低95%的CPU和内存性能，并降低17%左右的I&#x2F;O性能。在EC2服务器上，大约85%用于CPU和内存性能，82%用于I&#x2F;O性能。这是合理的，因为引发异常会导致大量用户空间核心转储应用程序与受害容器竞争CPU周期。</p>
<p>通过将容器固定在不同的核心上，我们进一步改变了恶意容器的核心亲缘性。尽管恶意容器不再与受害者竞争同一内核上的CPU资源，但它在受害者的性能上仍然显示出类似的结果。这是因为CPU资源的主要竞争对手不是恶意容器，而是那些触发内核转储的应用程序。</p>
<p>这一结果表明，恶意租户可以很容易地利用容器来显著降低同一主机上所有其他容器的性能，并降低服务供应商的服务质量，从而可能导致巨大的经济损失，而成本很少。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/DoSattackResult.png" title alt data-align="center">

<h2 id="Case-2-Data-Synchronization"><a href="#Case-2-Data-Synchronization" class="headerlink" title="Case 2:Data Synchronization"></a>Case 2:Data Synchronization</h2><p>我们的第二个案例是利用磁盘数据同步的回写机制，出于性能考虑，该机制被广泛采用。CPU只会将更新后的数据写入缓存，当缓存被清除时，数据才会写入磁盘。</p>
<p>由于懒惰的磁盘回写机制将启动I&#x2F;O的进程与同步磁盘写入的进程解耦，所以我们的利用可以逃避cgroups。有多种方法可以触发数据同步，包括定期回写和内存不足。它也可以由用户进程通过系统调用故意调用，如sync（将缓存文件数据的所有未决修改写回给底层文件系统）、syncfs（同步开放文件所指的文件系统）和fsync（将文件的所有修改数据传输到其常驻磁盘设备）。这些系统调用对Linux容器是可用的。特别是，我们发现，同步可以被利用来减慢整个系统的I&#x2F;O性能（例如，在序列写入上有超过87%的降级），发起无资源攻击，并建立秘密通道。</p>
<ul>
<li><p>Detailed analysis on sync</p>
<p>同步的第一步是启动一个内核线程，它将页缓存中包含的所有脏页刷新到磁盘。它通过扫描所有当前挂载的文件系统来查找要刷新的所有脏索引节点，并刷新相应的脏页。由于同步允许进程将所有脏缓冲区写回磁盘，任何I&#x2F;O操作都必须等待刷新。</p>
<p>更糟糕的是，由其他进程(可能属于另一个容器)生成的脏缓冲区也将被迫写回磁盘。</p>
<p>容器中的进程可以在不执行I&#x2F;O操作的情况下，以少量的工作负载重复调用sync。但是，与此同时，如果在其他共驻留容器上有I&#x2F;O操作，同步将回写所有脏页。在我们的实验中，我们运行了一个不断调用sync的容器。它不会导致超出容器限制的任何额外利用率。然而，一旦我们运行另一个容器，进行一些简单的写操作，同步操作就会导致大量的CPU等待时间，这是同步和写操作的组合所产生的。CPU等待时间用于指示I&#x2F;O等待所消耗的时间，其他工作负载仍然可以使用它。</p>
<p>但是，在其他容器上运行的特定工作负载的性能会受到显著影响。</p>
</li>
<li><p>blkio cgroup</p>
<p>正如2.1节中提到的，blkio cgroup子系统可以对块设备应用I&#x2F;O控制。虽然Docker只支持通过权重来限制相对I&#x2F;O吞吐量，但内核实际上可以为cgroups设置一个上限。我们使用blkio对运行同步的容器应用I&#x2F;O控制。不幸的是，基于Docker的统计工具，容器的I&#x2F;O吞吐量为零。因此，blkio控制器不能减少同步的影响。原因是由sync触发的所有回写工作负载都在内核线程中处理，调用sync的容器没有I&#x2F;O工作负载。</p>
</li>
<li><p>I&#x2F;O-based DoS attacks</p>
<p>不管发出I&#x2F;O操作的进程是否在容器内，在容器内调用系统调用同步将继续调用系统范围的回写。在某些情况下，回写会降低系统性能，因为特定的工作负载需要等待回写完成。为了测试有效性，我们运行两个固定在两个不同核心上的容器。恶意容器所做的唯一任务是调用系统调用sync，因此本身不会招致I&#x2F;O操作。</p>
<p>为了测量受害容器的性能，我们在受害容器内运行FIO基准测试来测量I&#x2F;O性能。特别地，我们进行了四种不同的FIO工作负载，包括序列&#x2F;随机写和序列&#x2F;随机读。我们还运行UnixBenchmark来测试除I&#x2F;O以外对性能的影响。我们通过将结果除以恶意容器中运行空闲循环的基线情况来计算性能下降。结果如图所示。对于UnixBenchmark，我们列出了性能显著下降的工作负载。总的来说，我们可以看到在受害者中运行的FIO基准测试的性能受到了很大的影响。通过在恶意容器中不断调用sync，所有四种类型I&#x2F;O操作的性能都会受到显著影响。对于顺序写入，在我们的本地测试床上性能下降到2%，在EC2服务器上下降到13%。</p>
<p>对于UnixBenchmark，运行shell脚本的性能也严重降低到不到一半。对于其他基准测试，退化约为5%到10%。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/sysperformance.png" title alt data-align="center">

<ul>
<li><p>Resource-Freeing Attack(RFA)</p>
<p>RFA攻击的目标是通过争夺受害者的瓶颈资源来为攻击者的实例释放特定的资源。在容器环境的情况下，两个容器在争夺系统资源，如CPU。恶意容器试图提高其工作负载的性能（被称为beneficiary），以获得更多的系统资源。因此，恶意容器运行另一个轻量级程序（被称为helper）来释放受害者容器使用的资源，以便受益者能够获得更多的资源。帮助者只消耗很少的系统资源（因此它对beneficiary几乎没有影响），但可以显著影响在受害者容器内运行的工作负载。例如，在恶意容器中，受益者程序可以运行CPU密集型的工作负载，并与受害者容器在同一CPU核心上竞争CPU资源。受害者容器运行I&#x2F;O密集型的工作负载，因此CPU活动与I&#x2F;O操作的频率相联系：更多的I&#x2F;O操作使受害者容器消耗更多的CPU周期来处理这些请求。然后，恶意者运行一个辅助程序，定期调用sync，触发回写，并减少受害者的I&#x2F;O活动。这样可以降低受害者容器的CPU使用率，恶意容器可以获得更多的CPU资源。<br>我们通过在同一个核上运行两个容器来模拟实验。在受害容器中，我们模拟了一个网络爬虫的情况，其中容器不断地将一个网页写入一个新文件。</p>
<p>我们使用sysbench来测量恶意容器的CPU和内存性能，其中值越高表示性能越好。恶意容器还会定期调用sync来触发全局回写。对于基线情况，只有攻击者的容器是活动的，因此不存在对所有系统资源的竞争。然后，我们运行这两个容器，并将攻击者容器的性能与基线情况进行比较。如图，在没有RFA攻击的情况下，由于两个容器争夺同一核上的CPU资源，CPU性能(即白条)约为无竞争情况(即黑条)的一半，内存性能约为无竞争情况的1&#x2F;3。然而，通过发起RFA攻击(即灰色条)，恶意容器内的受益人可以在两个测试平台上获得更好的性能。特别是，在我们的本地服务器上，性能几乎与没有竞争的情况相同。</p>
</li>
</ul>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/resource.png"></p>
<ul>
<li><p>Covert Channels</p>
<p>最后，我们证明了cgroups中的不足也可能被恶意攻击者利用，在不同的核心之间构建基于时间的隐蔽通道。其思想是利用由磁盘数据同步引起的性能差异。我们测量在一个容器中写入10个文件的时间，同时在另一个内核的另一个容器中运行sync。</p>
<p>我们重复实验100次，所需要的时间分布如图所示。我们可以观察到运行同步和不运行同步之间打开文件的明显时间差异。我们通过利用性能差异构建了一个概念验证通道，能够以2bits&#x2F;s的速率传输数据，错误率为2%。</p>
</li>
</ul>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Probability.png"></p>
<h2 id="Case-3-System-Process-Journald"><a href="#Case-3-System-Process-Journald" class="headerlink" title="Case 3:System Process - Journald"></a>Case 3:System Process - Journald</h2><p>我们的第三个案例是利用system - Journal服务，它提供了一个系统服务来收集系统日志数据，包括内核日志消息、系统日志消息(例如，syslog调用或Journal API)，以及通过审计子系统的审计记录。所有相关的活动都由系统进程日志记录。在我们的案例研究中，我们发现容器中的三类操作可以迫使日志进程记录日志，导致5%到20%的额外CPU利用率和平均2MB&#x2F;s的I&#x2F;O吞吐量，然后可以利用这些影响其他容器的性能。</p>
<ul>
<li><p>Detailed analysis</p>
<p>主机的系统进程被附加到不同于容器中的进程的cgroup中，因为它们是由操作系统维护的，以提供全系统的功能。因此，如果容器内的工作负载可以触发这些系统进程的活动，那么这些活动所消耗的资源将不会被计入容器的cgroup，从而逃避资源控制机制。但是，运行在主机上的系统进程会忽略容器内的大部分操作。例如，在主机上运行的用户空间进程的许多活动将由日志记录。但是如果流程在容器内运行，那么这些活动将被忽略。为了记录容器内的事件，主机上的系统管理员需要更改system -journal服务的配置。</p>
<p>特别是，Docker提供了一个选项来启用日志记录。</p>
<p>然而，我们发现，即使没有启用日志记录选项，在某些特定的情况下，容器仍然能够在日志系统进程上生成不可忽略的工作负载。</p>
<p>特别地，我们介绍了导致系统进程负载的三种类型的操作，从而逃脱了cgroup的控制。</p>
</li>
<li><p>Switch user (su) command</p>
<p>su命令提供了一种将登录会话的所有权切换到root用户的方法。</p>
<p>切换到root用户的操作将被记录在日志系统进程中。日志包含进程、用户帐户和环境切换的信息。日志服务也会记录用户的退出。使用USER namespace，容器内的根用户映射到主机上的无特权用户。因此，容器中的进程可能在USER名称空间中拥有完全的特权，但实际上在主机上被剥夺了特权。作为容器中的根用户，su命令可以进入另一个用户。不幸的是，在容器内切换帐户所引起的活动将触发system -journal服务来记录相关信息。</p>
</li>
<li><p>Add user&#x2F;group</p>
<p>在USER namespace中，容器用户可以添加新组或在现有组中添加新帐户。这些活动也将由主机上的日志系统进程记录。</p>
</li>
<li><p>Exception</p>
<p>最后，如前所述，内核无法区分所引发异常的上下文(在容器内部或外部)。因此，容器内异常引起的崩溃信息也会触发主机上系统进程的日志记录活动。</p>
<p>所有上述工作负载都将在日志中触发大量事件日志记录。同样，我们将一个容器设置为具有一个CPU核心计算能力，以继续调用上述命令。在我们的本地测试床上，我们观察到journald上的CPU使用率恒定为3.5%，auditd上的CPU使用率恒定为2.5%，kauditd上的CPU使用率恒定为1%。在EC2服务器中，由于其更好的I&#x2F;O性能，这个数字要大得多:我们观察到平均CPU利用率约为20%。我们还发现，journald进程的平均I&#x2F;O吞吐量约为2MB&#x2F;s，而容器的I&#x2F;O吞吐量为零。如果我们为容器分配更多的计算资源，这个数字将会增加。</p>
</li>
<li><p>DoS attacks</p>
<p>日志journald活动将产生不可忽略的I&#x2F;O操作，这将导致与其他容器的资源竞争。为了衡量结果，我们在主机的不同内核上运行两个容器。在恶意容器中，我们不断切换用户(即su)并退出当前用户(即exit)。在受害容器中，运行与case 2中描述的相同的基准测试。</p>
<p>图显示了结果。总的来说，我们看到整个系统的性能下降。在I&#x2F;O性能较差的服务器(例如，我们的本地测试平台)中，滥用journald的攻击将更加有效。如前所述，它在日志进程中可能导致超过2MB&#x2F;s的I&#x2F;O吞吐量。我们观察到它仍然可以使EC2专用服务器上的其他容器在1000iops(吞吐量约为15MB&#x2F;s)时变慢。在一个具有默认配置的专用服务器中(例如，400 IOPS，吞吐量约为6MB&#x2F;s)，我们可以观察到更明显的结果。</p>
</li>
</ul>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/Performance%20degradation%20of%20DoS%20attacks%20exploiting%20journald..png" title alt data-align="center">

<ul>
<li><p>Residual effect</p>
<p>在I&#x2F;O性能较差的服务器上，系统进程的写工作负载可能超过服务器的I&#x2F;O能力。结果，大量的日志事件被排队，等待稍后被记录。这将导致一个残留效应:即使容器停止了它的工作负载(例如su)，系统仍将继续在journald中写入，直到队列中的工作负载完成。残留效应在我们的本地测试平台上很明显，并且持续的时间比工作负载的运行时间长得多。即使容器完全空闲，CPU和I&#x2F;O资源也会被消耗。更糟糕的是，这些写入操作将显著影响其他容器和主机的I&#x2F;O性能。</p>
</li>
</ul>
<h2 id="Case-4-Container-Engine"><a href="#Case-4-Container-Engine" class="headerlink" title="Case 4:Container Engine"></a>Case 4:Container Engine</h2><p>容器的第四种情况是通过在内核线程(例如kworker)和容器引擎上触发额外的工作负载来利用容器引擎，容器引擎需要在主机上运行以支持和管理容器实例。特别是，容器引擎作为系统上的特权守护进程运行，因此它作为容器实例附加到不同的cgroup上。容器实例上的cgroup限制将不能控制引擎上消耗的资源。总的来说，通过这种方式，我们发现一个容器可以将资源消耗增加到大约3倍。</p>
<ul>
<li><p>Detailed analysis</p>
<p>我们首先简要介绍Docker容器引擎及其cgroup层次结构。Docker创建一个包含所有容器实例的Docker cgroup。每个容器由其ID标识，并保存由fork创建的所有进程。从理论上讲，容器内运行的所有工作负载都将被计入容器cgroup。</p>
<p>此外，Docker构建在Docker引擎之上，其中一个守护进程(即dockerd)在后台运行，处理Docker映像的管理。Docker引擎然后与containd(一个守护进程)通信，以进一步使用runC来运行容器。dockerd进程对于每个容器实例都有多个子进程。这些进程被附加到所有系统服务的默认cgroup中。</p>
<p>此外，用户主要通过命令行接口(CLI)客户端(即Docker进程)控制和管理Docker, Docker进程通过Docker REST API与Docker守护进程交互。Docker CLI为用户提供了创建或执行容器的接口。它还提供了多个命令来设置与底层控制组相关的资源限制的配置。与Docker引擎进程类似，Docker CLI也不属于容器的cgroup。</p>
<p>利用容器引擎来打破cgroups的控制是相当容易的。一种简单的方法是利用终端子系统。当容器用户与tty设备交互时，数据首先经过CLI进程和容器守护进程，然后到达tty驱动程序进行进一步处理。具体来说，数据被发送到LDISC, LDISC连接高级通用接口(例如，读、写、ioctl)和终端系统中的低级设备驱动程序。通过在kworker内核线程中执行工作队列将数据刷新到LDISC。因此，内核线程上的所有工作负载和所有容器引擎进程都不会被计算到容器实例中。</p>
<p>我们通过在终端中反复显示主机中所有加载的模块来测量容器引擎中生成的工作负载，并将结果说明在图中。同样，容器的使用仅限于一个核心(如图中的container)。</p>
<p>总的来说，使用一个核心的计算能力(100%的利用率)，容器可以通过滥用docker引擎进程在主机上造成大约300%的工作负载。</p>
</li>
</ul>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/CPU%20utilization.png"></p>
<p>为了细分使用情况，docker进程属于主机的用户cgroup；其他docker进程属于一个系统cgroup：docker.service。其余的（大部分是内核线程kworker，由于流媒体工作负载，如第3.2节所解释）属于根cgroup。我们还在case 1中进行了与表类似的实验。通过利用Docker容器引擎，攻击者能够降低CPU和内存的性能大约15%。</p>
<img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/DoSattackResult.png" title alt data-align="center">

<h2 id="Case-5-Softirq-Handling"><a href="#Case-5-Softirq-Handling" class="headerlink" title="Case 5:Softirq Handling"></a>Case 5:Softirq Handling</h2><p>最后一种情况是利用Linux内核中的softirq处理机制。当前内核定义了11种类型的softirq。特别是，硬件中断处理程序通常会引发软中断。</p>
<p>虽然大多数硬件中断可能不是由容器直接引发的，但容器用户能够操作网络接口上的工作负载生成NET softirq，或块设备生成block softirq。处理这些softirq会消耗内核线程进程上下文(例如ksoftirqd)或中断上下文上的CPU资源。</p>
<ul>
<li><p>NET softtirq</p>
<p>一旦NIC完成数据包传输，就会引发中断，而softirq负责在驱动程序缓冲区和网络堆栈之间移动数据包。但是，在流量带宽有限的情况下，使用softirqs带来的开销可以忽略不计:在之前的工作中，当网络流量超过1gbps时，开销为1%。</p>
<p>我们发现，由于网络流量引起的开销会被服务器上的防火墙系统(如iptables)大大放大。iptables建立在netfilter的基础上，提供了一个管理层，用于包过滤规则的添加和删除。netfilter将数据包挂在网络驱动程序和网络堆栈之间。所有的网络数据包首先通过过滤规则进行检查，然后进行进一步的操作(例如，转发、丢弃、由网络堆栈处理)。因此，iptables下的网络流量处理是在softirq上下文中处理的，因此不会向生成或接收流量的容器收费。</p>
<p>在Linux上，Docker依赖于配置iptables规则来为容器提供网络隔离。特别是，它可能为提供web或网络服务的容器设置多个规则。即使容器停止，规则也存在。更糟糕的是，在某些情况下，如果相关标志设置为true，容器可以对系统iptables规则进行更改。一旦有相当数量的规则，开销将是不可忽略的。</p>
<p>我们测量了softirq在不同数量的iptables规则下处理网络流量所带来的开销，如图所示。特别是，我们测量了所有ksoftirqd内核线程的CPU使用情况，以及花在中断上下文上的时间(来自top命令的hi和si)。在我们本地的测试台上，网卡的容量为100mbit &#x2F;s，网络流量约为20 ~ 30mbit &#x2F;s，明显小于中的Gbps级别。我们可以清楚地看到，处理网络流量会产生巨大的开销，并且与规则数量密切相关。当规则数量达到5000条时，CPU将浪费大量的时间(约16%)处理软tirq，并且不会向发起网络流量的容器收费。一旦服务器中有10,000条规则，开销约为40%，其中大多数集中在一个核心上。</p>
<p><img src="/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/iptable.png"></p>
<p>EC2服务器有一个非常强大的网卡，具有10,000 Mbit&#x2F;s的容量，与我们的本地测试平台相比带宽更高。因此，与我们的本地测试平台相比，开销略小。在我们的实验中，当网络流量约为300mbit &#x2F;s时，流量仍然会浪费不可忽略的CPU周期。如3.4节所述，软件中断的处理要么抢占当前工作，要么在内核线程中消耗CPU周期。因此，同一核心上的所有其他工作负载将被延迟。</p>
</li>
<li><p>BLOCK softirq</p>
<p>处理softirq时增加工作负载的另一个例子是块设备上的I&#x2F;O操作。Linux内核使用队列存储块请求I&#x2F;O，并将新的请求添加到队列中。一旦请求处理完成，它将引发在softirq上下文中处理的softirq，以进一步处理队列。然后，利用BLOCK softirq转义cgroups的基本思想类似于利用NET softirq。</p>
<p>在容器上下文中，可以通过持续查询完成队列中的事件并提交写或读操作来生成这样的工作负载。对于I&#x2F;O性能较差的设备，这种影响尤其明显。为了进一步定量度量影响，我们使用固定在一个内核上的容器，运行fio推荐来执行顺序读写。我们选择小块用于写入，大块用于读取。我们测量多个内核线程(如kworker)的CPU利用率。容器中的工作负载能够在我们的本地测试平台上的内核上生成不可忽略的工作量，包括相同内核的kworker上16.7%的工作负载。此外，对于序列I&#x2F;O读取，文件分配过程在jpd2和kswapd上分别产生了3.9%和3.8%的额外利用率。最后，我们还利用kworker来测量退化。我们在同一个内核上的内核线程kworker上创建工作负载，攻击者能够对受害者造成大约10%的性能损失(根据sysbench基准测试测量)。</p>
</li>
</ul>
<h1 id="MITIGATION-DISCUSSION"><a href="#MITIGATION-DISCUSSION" class="headerlink" title="MITIGATION DISCUSSION"></a>MITIGATION DISCUSSION</h1><p>在这一节中，我们将介绍我们在以下方面的初步努力应对现有cgroups机制的不足所带来的安全问题。由于大多数问题涉及多个内核子系统，因此很难部署一个单一的解决方案来全面彻底地解决所有问题。另外，解决一些问题可能需要重新设计当前的资源核算系统。在下文中，我们将从不同角度讨论潜在的缓解方法。</p>
<p>直观地说，通过考虑由一组进程(或容器)直接或间接生成的所有工作负载，cgroups应该具有细粒度的计算机制。例如，如果一个容器通过内核线程调用另一个用户空间进程，容器的cgroup应该由内核线程传递，这样它也会被复制到新的用户空间进程。因此，新调用的进程与容器属于同一个cgroup，而不是与内核线程属于根cgroup。虽然这种方法可以应用于新生成的进程，但很难处理系统中已经存在的进程。内核线程(如kworker、ksoftirqd)是由内核创建的，用于处理特定的内核工作负载，这些工作负载可能由附加到不同cgroup的不同进程触发。journald系统进程的情况也类似:它记录所有进程引发的所有相关事件，因此将整个日志进程附加到特定的cgroup是不合理的。因此，综合机制不应该改变这些线程的cgroup，而是应该跟踪特定工作量的系统资源，并将其收费给初始进程。例如，Iron跟踪处理每个网络数据包的CPU周期，并向相关进程收费。然而，这样的方法无疑需要大量的内核开发工作，并且由于将多个内核函数用于细粒度资源跟踪而带来大量的运行时开销。</p>
<p>对于某些工作负载，另一个有争议的问题是cgroup是否应该向容器收取这些系统资源。从隐私的角度考虑，主机服务器不应该记录容器实例中运行的任何敏感信息。journald提供了特定的选项来启用容器内的日志活动。但是，我们展示了，即使没有启用日志记录选项，主机仍然为容器记录多个事件。日志记录是由主机执行的，因此不应该向容器收费。此外，容器用户无法获得容器内引发的异常的核心转储信息。因此，一种可能的方法是通过区分容器上下文禁用所有潜在的日志记录或记录活动。完全解决这个问题的另一种方法是构建一个额外的cgroup子系统，专门用于日志记录。所有日志记录活动都将由新的日志记录cgroup子系统进行记录。</p>
<p>最后，有些问题即使使用细粒度的会计机制也无法解决。例如，虽然当前的cgroups机制清楚地提到回写工作负载不被计算在内，但Linux内核维护者已经开始开发新的cgroup机制(即cgroup v2)，它利用内存和blkio子系统来跟踪回写并为脏页的容器收费。然而，恶意容器可以在不生成任何I&#x2F;O工作负载的情况下继续调用sync。回写工作负载由具有I&#x2F;O操作的容器承担，而不是由恶意容器承担。同时，向调用数据同步的容器收取所有费用是不公平的。由于简单地禁用所有这些功能将不可避免地影响可用性，一个潜在可行的解决方案是对这些敏感操作施加速率限制。</p>
<h1 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h1><p>在本节中，我们调查了一些启发我们工作的研究工作，并强调了我们的工作与以往研究之间的差异。我们主要讨论以下两个方面的研究工作:</p>
<h2 id="Virtual-Machine-and-Container"><a href="#Virtual-Machine-and-Container" class="headerlink" title="Virtual Machine and Container"></a>Virtual Machine and Container</h2><p>虽然VM已经迎来了云计算时代，但尽管进行了大量的研究工作，其性能仍然不能令人满意。容器正变得越来越流行，因为它提供了一种启用轻量级虚拟化的替代方式，并允许在容器中运行的应用程序完全兼容。因此，研究人员对硬件虚拟化和容器之间的性能比较很好奇。Felter等人表明，通过使用一组涵盖CPU、内存、存储和网络资源的基准测试，Docker在所有情况下都可以实现比KVM更高的性能。</p>
<p>Spoiala等还证明了Docker优于KVM，并且可以使用Kurento Media Server来测试WebRTC服务器的性能，从而支持实时应用程序。Morabito et al进一步比较了传统hypervisor(例如KVM)和os级虚拟化(包括Docker和LXC)在计算、存储、内存和网络方面的性能，并观察到磁盘I&#x2F;O仍然是KVM hypervisor的瓶颈。所有这些工作都表明，基于容器的操作系统级虚拟化是比传统的基于vm的硬件虚拟化更有效的解决方案。虽然以前的大多数研究工作都集中在理解容器的性能上，但很少有人试图调查底层内核机制的资源共享的有效性。我们是第一批系统地研究由Cgroup不足引起的容器的性能和资源核算问题的人。</p>
<h3 id="Container-security"><a href="#Container-security" class="headerlink" title="Container security"></a>Container security</h3><p>除了性能，容器的安全性也受到了学术界和业界的广泛关注。Gupta首先简要介绍了Docker安全性。Bui从隔离和相应的内核安全机制方面对Docker容器进行了分析。虽然之前的工作声称Docker容器在默认配置下是相当安全的，但Lin等人发现，大多数现有的漏洞都可以通过默认配置成功地从容器内部发起攻击。Grattafiori等人总结了容器的各种潜在漏洞，包括基于内存的伪文件系统中的问题。Gao等人进一步对基于内存的伪文件系统由于namespace问题而产生的潜在安全影响进行了系统研究。Lei等人提出了一种名为SPEAKER的容器安全机制，以减少对应用程序的可用系统调用数量。Sun等人开发了两个安全命名空间，为容器实现自主安全控制，Arnautov等人提出使用Intel SGX保护Linux容器。</p>
<p>错误配置的能力也可以被利用来建立容器中的秘密通道。我们在cgroup方面的工作进一步补充了以前的的研究工作。</p>
<h2 id="Cloud-Security"><a href="#Cloud-Security" class="headerlink" title="Cloud Security"></a>Cloud Security</h2><h3 id="Co-residence"><a href="#Co-residence" class="headerlink" title="Co-residence"></a>Co-residence</h3><p>大量的研究工作也致力于理解云的安全问题，特别是不同租户共享相同计算基础设施的多租户云。在多租户云环境中，攻击者可以将恶意虚拟机与目标虚拟机共同驻留在同一台服务器上，然后发起包括侧通道和隐蔽通道攻击在内的各种攻击。同时，侧面攻击和隐蔽通道攻击是验证同一物理服务器上共存的常用方法。例如，基于缓存的隐蔽通道被广泛采用，因为多个实例共享同一个包上的最后一级缓存。Zhang等人进一步论证了在云上发起真实侧通道攻击的可行性。除了基于缓存的通道，其他方法如内存总线、内存重复数据删除、核心温度也可以有效地构建隐蔽通道。</p>
<p>虽然也提出了多种防御机制，但之前的两项工作表明，在现有的主流云服务中实现合住仍然是可行的(而且成本低廉)。Wang等人对三种无服务器计算服务进行了大规模的测量研究，发现了几个资源核算问题，租户可能会滥用这些问题来运行额外的工作负载。</p>
<h3 id="Denial-of-Service-attacks"><a href="#Denial-of-Service-attacks" class="headerlink" title="Denial-of-Service attacks"></a>Denial-of-Service attacks</h3><p>由于底层计算资源在不同的租户之间共享，因此争用是不可避免的。Varadarajan等人提出了资源释放攻击来释放受害者使用的资源，这样攻击者的实例就可以获得额外的利用。Zhang等人调查了内存DoS攻击的影响，并表明恶意云客户可以对电子商务网站造成38倍的延迟。对于针对I&#x2F;O性能的DoS攻击，Huang等提出了级联性能攻击，以耗尽hypervisor的I&#x2F;O处理能力。此外，多种攻击试图耗尽共享的基础设施资源，如电力设施，从而迫使数据中心的服务器关闭。与之前的工作不同，我们的工作表明，cgroups中的不足也可以被利用来在多租户容器环境中发起多次攻击。</p>
<h1 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h1><p>在本文中，我们开发了一套策略来打破Linux控制组的资源控制。我们证明了通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。我们可以通过与原始cgroup解关联的进程来生成带外工作负载。</p>
<p>我们进一步提出了五个案例研究，表明在Docker容器环境中实现这些攻击是可行的。恶意容器利用多租户容器环境中cgroups的这些不足，可以极大地耗尽主机的资源，并发起多种攻击，包括拒绝服务攻击、资源释放攻击和秘密通道攻击。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行了实验，并证明了一个容器可以将其工作负载放大200倍以上，并将其他容器的性能降低95%。</p>
<h1 id="My"><a href="#My" class="headerlink" title="My"></a>My</h1><h2 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h2><p>Linux 内核为各种异常提供了专用的异常处理程序。这些异常处理程序分为两类：错误和陷阱。错误是指程序在运行过程中遇到的问题，如分段错误。陷阱是指程序主动触发的事件，如溢出检测。</p>
<p>在处理这些异常时，内核维护了一个名为中断描述符表（IDT）的数据结构。IDT 包含每个异常处理程序的地址。当 CPU 在用户模式下引发异常时，相应的处理程序将在内核模式下运行。</p>
<ol>
<li><p><strong>寄存器保存和上下文切换</strong>：当异常发生时，处理器首先将当前的寄存器状态保存到内核堆栈中。这样，在异常处理完成后，处理器可以恢复原始状态并返回到用户模式。</p>
</li>
<li><p><strong>异常处理</strong>：在内核模式下，处理器会根据异常类型调用相应的处理程序。异常处理程序通常会执行一些特定的操作，如清理资源、记录错误信息等。在处理异常时，整个过程将在内核空间和触发异常的进程上下文中运行。因此，异常处理期间消耗的资源将被计入相应的 cgroups。</p>
</li>
<li><p><strong>信号处理和内核转储</strong>：异常处理程序可能会终止初始进程，并向其发送一个信号。这些信号会触发内核转储功能，生成一个用于调试的内核转储文件。在 Linux 内核中，核心转储代码通过 usermode 辅助 API 调用一个用户空间的应用程序来完成这个任务。</p>
</li>
<li><p><strong>用户空间核心转储程序</strong>：在 Ubuntu 中，默认的用户空间核心转储程序是 Apport，它会在每个异常情况下被触发。Apport 的资源消耗不会由容器承担，因为它是由内核线程创建的，而不是由容器化的进程创建的。</p>
</li>
<li><p><strong>负载平衡和资源放大</strong>：内核会将新生成的 Apport 实例调度到所有可用的 CPU 核心上，以实现负载平衡。这会导致打破 cpusets cgroup 的约束。同时，由于 Apport 进程比轻量级的异常处理（即内核控制路径）消耗更多资源，如果容器不断触发异常，整个 CPU 可能会被 Apport 进程占满。这种情况导致了分配给容器的系统资源的放大。</p>
</li>
</ol>
<p>总结一下，当用户程序触发异常时，Linux 内核会通过 IDT 找到相应的处理程序，并在内核模式下运行。处理程序可能会终止进程并触发内核转储功能。在 Ubuntu 中，这会调用用户空间的 Apport 程序来生成内核转储文件。Apport 的资源消耗不会由容器承担，但可能导致资源放大和 cpusets cgroup 的约束被打破。</p>
<p>当你在使用电脑时，有时会遇到一些问题，比如程序出错或者意外停止运行。这些问题通常是由于程序中的异常引起的。在 Linux 系统中，有一套专门处理这些异常的机制。</p>
<p>想象一下，当程序遇到异常时，就像一个球员在比赛中受伤了。这时，教练（内核）会派上另一个球员（异常处理程序）来处理这个问题。这个过程发生在球场内（内核空间），并且会记录下这个问题发生的原因。</p>
<p>在处理异常时，教练需要确保其他球员不受影响。因此，教练会将受伤球员的状态保存起来，等问题处理完后再恢复。这个过程就像是在现场给受伤球员做紧急处理。</p>
<p>有时，这个问题严重到需要告知其他人（发送信号）。在这种情况下，教练会通知医疗团队（Apport 程序）来处理。医疗团队会把受伤球员的情况记录下来（生成内核转储文件），以便在之后分析和处理。</p>
<p>需要注意的是，医疗团队（Apport）处理问题时所消耗的资源不会影响球队（容器），但有时他们的处理可能会让整个比赛（系统资源）受到影响，导致其他球员的表现受到一定程度的影响。</p>
<p>总之，当电脑遇到问题时，Linux 系统会通过一套内核机制来处理这些异常。在处理过程中，可能会涉及到一些额外的程序，如 Apport，在确保不影响其他程序运行的前提下，记录和处理异常。  </p>
<h2 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h2><ol>
<li><p><strong>磁盘数据同步回写机制</strong>：这是一种性能优化策略，使CPU只将更新后的数据写入缓存，而不是直接写入磁盘。当缓存被清除时，数据才会写入磁盘。这种机制通过将启动I&#x2F;O进程与同步磁盘写入进程解耦来提高性能。</p>
</li>
<li><p><strong>同步</strong>：同步是将缓存中的数据写回磁盘的过程。这可以通过多种方法触发，例如定期回写、内存不足，或者通过用户进程故意调用系统调用（如sync、syncfs和fsync）。这些系统调用对Linux容器是可用的。</p>
</li>
<li><p><strong>利用同步的攻击</strong>：由于同步允许进程将所有脏缓冲区写回磁盘，因此在同步期间，任何I&#x2F;O操作都必须等待。这可以被恶意进程利用，通过重复调用sync，以减慢整个系统的I&#x2F;O性能、发起无资源攻击，甚至建立秘密通道。</p>
</li>
<li><p><strong>绕过cgroup</strong>：cgroup是一种用于限制资源使用的机制，但由于同步操作是在内核线程中进行的，并且调用sync的容器没有I&#x2F;O工作负载，因此cgroup无法限制同步操作。在这种情况下，即使使用blkio cgroup子系统对运行同步的容器应用I&#x2F;O控制，仍然无法减少同步的影响。这是因为blkio控制器仅限制相对I&#x2F;O吞吐量，而不是绝对值。此外，Docker的统计工具显示，调用sync的容器的I&#x2F;O吞吐量为零，这意味着blkio限制不起作用。</p>
</li>
</ol>
<p>这个案例讲述了一个关于磁盘数据同步的技术，它叫做懒惰回写（lazy write-back）。这种技术的主要优点是提高电脑的性能。当我们在电脑上做一些改动时，这些改动首先会被保存在缓存中，而不是直接写入磁盘。只有当缓存被清空时，改动才会真正地被保存到磁盘里。这样的操作可以节省时间，因为写入磁盘的速度往往比写入缓存慢。</p>
<p>这种技术可以让一个攻击者绕过cgroups的限制。cgroups是一种用于限制程序在电脑上使用的资源的技术。简单来说，攻击者可以通过触发数据同步，让电脑的整体性能下降。这就像是在公路上开车，突然有人打开了所有的红绿灯，导致所有的车辆都必须停下来等待。</p>
<p>懒惰回写的关键在于同步（sync）。同步是一个过程，它会把缓存里的数据写入磁盘。当一个程序调用同步时，它会让电脑暂停其他操作，等待数据写入磁盘。如果一个攻击者不断地调用同步，那么电脑的性能就会受到影响，因为其他程序需要不断地等待同步完成。</p>
<p>现在我们来谈谈cgroups。cgroups是一种技术，可以用来限制程序使用电脑上的资源，比如CPU、内存和磁盘等。但是，在这个案例中，攻击者利用同步绕过了cgroups的限制。原因是，攻击者调用同步时，并没有直接进行磁盘读写操作，而是让内核（电脑的核心部分）进行了这些操作。因此，cgroups无法检测到攻击者的行为，也就无法限制它。</p>
<p>总之，这个案例向我们展示了一个攻击者可以利用懒惰回写的同步机制来绕过cgroups的限制。这可能会导致电脑的整体性能下降，给其他用户带来麻烦。</p>
]]></content>
      <categories>
        <category>论文精读</category>
        <category>内核安全</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内核安全</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 Demons in the Shared Kernel: Abstract Resource Attacks Against</title>
    <url>/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/</url>
    <content><![CDATA[<p><strong>摘要</strong></p>
<p>由于其更快的启动速度和更好的资源利用效率，OS-level的虚拟化（virtualization）已被广泛采用，并成为云计算的一项基本技术。与硬件虚拟化相比，OS-level的虚拟化利用共享内核（shared-kernel）设计来实现高效率，并在共享内核上运行多个用户空间实例（又称容器）</p>
<p>然而，在本文中，我们揭示了一种新的攻击面，它是操作系统级虚拟化所固有的，会影响Linux、FreeBSD和Fuchsia。根本原因是操作系统级虚拟化中的共享内核设计导致容器直接或间接地共享成千上万的内核变量和数据结构。在不利用任何内核漏洞的情况下，非特权容器可以轻松耗尽共享的内核变量和数据结构实例，从而对其他容器发起DoS攻击。与物理资源相比，这些内核变量或数据结构实例(称为抽象资源)更普遍，但保护不足。</p>
<p>为了说明限制抽象资源的重要性，我们针对操作系统内核的不同方面进行了抽象资源攻击。结果表明，攻击抽象的资源是非常实用和关键的。我们进一步进行了系统分析，识别出Linux内核中脆弱的抽象资源，成功检测到1010个抽象资源，其中501个可以动态重复使用。我们还在前四家云供应商的自部署共享内核容器环境中进行了攻击实验。结果表明，所有环境都容易受到抽象资源攻击。我们得出结论，containing抽象资源是困难的，并给出了多种策略来降低风险</p>
<p><strong>CCS CONCEPTS</strong></p>
<p>Security and privacy -&gt; Virtualization and security</p>
<p><strong>KEYWORDS</strong></p>
<p>OS-level Virtualization；Shared Kernel；Abstract Resource Attack</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>OS-level虚拟化允许多个包含且隔离的用户空间环境在同一个内核上运行。与硬件虚拟化相比（虚拟机），OS-level虚拟化消除了为每个用户空间实例维护操作系统内核的负担，因此具有更快的启动速度和更好的资源利用效率。因此，OS-level虚拟化在近年来得到了广泛的应用，并成为云计算的基础技术。OS-level虚拟化中的空间实例在FreeBSD中命名为jails，在Solaris命名为Zones，在Linux中命名为containers。</p>
<p>尽管OS-level的虚拟化效率很高，但它也带来了多种安全问题。首先，由于共享内核，操作系统级虚拟化容易受到内核漏洞的攻击。因此，它不能隔离内核错误。一旦共享内核受到威胁，所有用户空间实例(称为容器)都将失去隔离和保护。此外，研究人员最近对容器技术的隔离提出了质疑，例如信息泄漏、隐蔽通道和out-of-band workloads 打破了cgroup。</p>
<p>然而，在本文中，我们揭示了OS-level虚拟化所固有的一种新的攻击面（attack surface）。与硬件虚拟化相比，OS-level虚拟化利用共享内核设计来实现高效率。在典型的OS-level虚拟化环境中，容器运行在相同的操作系统内核上，并通过300多个系统调用请求各种服务。请注意，底层OS内核包含数十万个变量和数据结构实例，用于为容器提供服务。因此，这些容器直接或间接地共享这些内核变量和数据结构实例。</p>
<p>不幸的是，这些共享的内核变量和数据结构实例是OS-level中的新攻击面。在不利用任何漏洞的情况下，非特权容器可以轻松耗尽某些内核变量和数据结构实例，从而在OS-level虚拟化环境中引起DoS攻击。因此，即使其他容器拥有足够的物理资源，但随着内核关键变量或数据结构实例的耗尽，它们仍然不能执行任何有意义的任务。与真实硬件所支持的物理资源相比，我们将这些内核变量或数据结构实例视为抽象资源，将对这些资源的用尽攻击视为抽象资源攻击（<code>abstract resource attack</code>）。</p>
<p>尽管抽象资源可以被用于DoS攻击，但它们往往得不到充分保护。内核和容器开发人员更关注保护物理资源，而不是抽象资源。例如，Linux内核提供了<code>cgroup</code>来限制每个容器实例的资源使用。但在13个<code>cgroup</code>中，有12个是物理资源<code>cgroup</code>，限制CPU、内存、存储、IO等资源的使用。只有pid cgroup是为限制抽象资源pid而设计的。因此，数百种容器共享的抽象资源没有任何限制，例如<code>global dirty ratio</code>、<code>open-file structs</code>和<code>pseudo-terminal structs</code>，这使它们容易受到DoS攻击。</p>
<p>为了展示在OS-level上限制抽象资源的重要性，我们在Linux内核上使用Docker容器进行攻击，针对操作系统服务的不同方面的抽象资源，包括进程管理、内存管理、存储管理和IO管理。</p>
<p>我们的实验证明攻击抽象资源是非常实用和关键的-它很容易地禁用新程序的执行，降低内存写入速度97.3%，使所有文件打开相关地操作崩溃，并拒绝所有新的SSH连接。更糟糕地是，它会影响操作系统服务的所有方面。此外，实验还表明，除了Linux FreeBSD和Fuchsia也容易受到抽象资源攻击。</p>
<p>遗憾的是，尽管抽象资源很重要，但由于几个基本原因，它们本身就很难contain。首先，在操作系统内核中列举所有可能的抽象资源是不切实际的。与很少的物理资源类型不同，内核中的抽象资源类型是多种多样的。第二，很容易形成导致抽象资源枯竭的条件。在内核中实现新特性时，开发人员经常关注物理资源的消耗，而很少关注抽象资源的消耗。此外，OS内核具有复杂的数据和路径依赖关系，导致内核中的抽象资源以各种方式耗尽。</p>
<p>因此，我们设计了一个基于LLVM的工具，系统地识别Linux内核中脆弱的抽象资源。我们提出了识别可共享抽象资源并分析其容器可控性的新技术。我们将我们的工具应用于新的Linux内核，并检测1010个抽象资源。其中501个可以动态地重复使用，从检测到的抽象资源中，我们根据我们的熟悉度挑选了7个影响操作系统各个方面的资源（即，我们知道耗尽该资源的影响）。我们进一步对部署在四大云供应商（包括AWS、MS Azure、谷歌cloud和阿里云）上的共享内核容器环境中的这些选定资源进行攻击实验。试验结果表明，所有环境都容易受到我们的攻击。最后给出了多种降低抽象资源攻击风险的策略。</p>
<p>本文的贡献如下：</p>
<ul>
<li><p>New Attack Surface：我们揭示了操作系统级虚拟化所固有的新的攻击面。我们提出了一种新的攻击方法，称为抽象资源攻击。我们证明了抽象资源攻击是非常实用的，并且是影响Linux、FreeBSD和Fuchsia的广泛攻击类别。</p>
</li>
<li><p>Systematic Analysis：我们设计并实现了一个基于LLVM的静态分析工具来识别Linux内核中脆弱的抽象资源，包括基于配置的分析和容器可控性分析。我们的工具检测501个可以在Linux内核中动态重复触发的抽象资源。</p>
</li>
<li><p>Practical Evaluation：我们评估了AWS、MS Azure、谷歌Cloud和阿里云上self-deployed共享内核容器环境中的7种抽象资源攻击。（目前的公共云供应商没有直接向不同的用户提供共享内核容器。公共云中的容器通常由虚拟机隔离。）所有环境都容易收到抽象资源攻击。其中有两个环境易受6 attacks，一个环境易受 5 attacks，另一个环境易受 4 attacks。我们负责地向所有云供应商披露了我们的调查结果。所有这些都证实了所确定的问题。</p>
</li>
<li><p>Community Impact：我们计划在<a href="https://github.com/ZJU-SEC/AbstractResourceAttack">GitHub - ZJU-SEC&#x2F;AbstractResourceAttack: This repository is used to analysis the shared resources of different containers</a>中开源我们的工具和识别出的抽象资源，这样它们就可以帮助Linux内核community和容器community识别出OS-level虚拟化中资源隔离的弱点。</p>
</li>
</ul>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>OS-level虚拟化依赖于底层操作系统内核进行资源隔离和containment。更具体地说，Linux内核为资源隔离提供了<code>namespace</code>，为资源containment提供了<code>cgroup</code>。</p>
<h2 id="Linux-Namespaces"><a href="#Linux-Namespaces" class="headerlink" title="Linux Namespaces"></a>Linux Namespaces</h2><p><code>Linux namespace</code>提供进程级资源隔离。目前，<code>Linux namespace</code>分为8种类型。根据它们的发布时间，如下：</p>
<ul>
<li><p>Mount：用于文件系统隔离</p>
</li>
<li><p>UTS：用于主机名和域名隔离</p>
</li>
<li><p>IPC：用于消息队列隔离</p>
</li>
<li><p>PID：用于进程ID隔离</p>
</li>
<li><p>Network：用于网络资源隔离</p>
</li>
<li><p>User：用于UID&#x2F;GID隔离</p>
</li>
<li><p>Cgroup：用于cgroup隔离</p>
</li>
<li><p>Time：用于时钟时间隔离</p>
</li>
</ul>
<p>一个进程可以被分配给不同类型的不同<code>namespace</code>。但是对于每种类型，它只能属于一个<code>namespace</code>。默认情况下，进程与其父进程在相同的<code>namespace</code>中。它可以在进程创建期间通过<code>pass specific flags</code>添加到新的<code>namespace</code>，或者在进程运行期间通过调用<code>setns</code>系统调用添加到新的<code>namespace</code>。理想情况下，只有同一<code>namespace</code>中的进程可以共享<code>namespace</code>隔离的资源。因此，资源是跨<code>namespace</code>隔离的。因此，一个<code>namespace</code>中的隔离资源耗尽不会影响其他<code>namespace</code>中的进程。这样的设计本质上要求<code>namespace</code>机制正确且彻底地contain资源。</p>
<p>然而，仍然有数百种抽象资源类型没有包含在<code>namespace</code>中。即使有<code>namespace</code>的保护，大型攻击面仍然存在。有人可能会主张使用<code>namespace</code>隔离所有抽象资源。然而，这是不切实际的:抽象资源的巨大数量和灵活性使得解决方案由于巨大的代码更改和高性能开销而无法接受。</p>
<h2 id="Linux-Control-Groups"><a href="#Linux-Control-Groups" class="headerlink" title="Linux Control Groups"></a>Linux Control Groups</h2><p>另一方面，<code>Linux cgroup</code>用于限制限制资源的实用。<code>cgroup</code>负责控制组内所有进程使用的资源。<code>cgroup</code>被组织成树状结构，其中<code>children</code>的资源也包括<code>parent</code>的资源。对资源使用的限制也在树上递归地强制执行，以便<code>cgroup</code>中的资源使用不应超过其所有祖先的限制。</p>
<p><code>cgroup</code>主要管理硬件资源，如CPU、内存、存储、IO等。有两个版本的<code>cgroup</code>，<code>v1</code>和<code>v2</code>，主要的区别是，<code>cgroup v1</code>对于每种类型的资源可以有一个树状层次结构，而控制组v2只有一个层次结构。<code>resource account</code>和<code>resource usage limit</code>的实现在<code>v1</code>和<code>v2</code>之间差别不大。目前默认使用<code>cgroup v1</code>，因为它更稳定，并提供更多对资源的控制。它管理13种资源类型，而v2目前只支持9种资源类型。更具体地说，在这13种资源中，有5种用于<code>CPU accouting</code>，包括<code>cpu</code>、<code>cpuacct</code>、<code>cpuset</code>、<code>freeze</code>、<code>pref_event</code>；其中3个是用于内存，包括<code>memory</code>、<code>hugetlb</code>、<code>rdma</code>；<code>blkio</code>用于storage；还有3个用于IO，包括<code>devices</code>、<code>net_cls</code>、<code>net_prio</code>。只有<code>PIDs cgroup</code>为PID的抽象资源。</p>
<p>虽然限制容器进程中共享抽象资源的使用可以减轻DoS攻击，但将<code>cgroup</code>扩展到包括所有抽象资源也是不切实际的。计算资源并对如此多类型的资源实施限制将引入不可接受的开销。</p>
<h1 id="Abstract-Resource-Attacks"><a href="#Abstract-Resource-Attacks" class="headerlink" title="Abstract Resource Attacks"></a>Abstract Resource Attacks</h1><ul>
<li><p>Threat model and assumptions：在本文中，由于我们的目标是OS-level虚拟化，所以我们假设容器运行在相同的共享内核上。容器执行最先进的保护，并在部署中遵循最安全的实践。更具体地说，容器以不同的非根用户运行，删除了所有功能。而内核则为容器强制使用尽可能多的<code>namespace</code>和<code>cgroup</code>。此外，内核还使用<code>seccomp</code>来阻止敏感的系统调用。我们进一步假设内核没有bug，所有安全机制都正常工作。</p>
<p>另一方面，攻击者控制一个容器，并试图破坏在同一内核上运行的其他容器。攻击者可以在容器内运行任何代码并调用<code>seccomp</code>允许的系统调用。但是，他&#x2F;她不允许利用内核漏洞。此外，攻击者作为非根用户处于非特权容器中，根本没有任何功能。最后，攻击者不允许升级特权或重新获得任何功能。在下面的文章中，我们展示了由于内核中的共享抽象资源，即使这样的攻击者仍然可以对其他容器发起DoS攻击。</p>
</li>
</ul>
<h2 id="Weaknesses-in-OS-level-Virtualization"><a href="#Weaknesses-in-OS-level-Virtualization" class="headerlink" title="Weaknesses in OS-level Virtualization"></a>Weaknesses in OS-level Virtualization</h2><p>在OS-level虚拟化中，容器直接或间接地共享成千上万的内核抽象资源，这使它们容易受到资源耗尽攻击。我们利用Linux内核中的一个示例来说明细节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">percpu_counter</span> <span class="title">nr_files</span> __<span class="title">cacheline_aligner_in_smp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">get_nr_files</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> percpu_counter_read_positive(&amp;nr_files);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> file *<span class="title function_">alloc_empty_file</span><span class="params">(<span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> old_max;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">goto</span> over;</span><br><span class="line">    &#125;</span><br><span class="line">    f = __alloc_file(flags, cred);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(f))</span><br><span class="line">        percpu_counter_inc(&amp;nr_files);</span><br><span class="line">    ...</span><br><span class="line">over:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENFILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它定义了一个每个CPU计数器<code>nr_files</code>，一个函数<code>get_nr_files()</code>和一个函数<code>alloc_empty_file()</code>。</p>
<ul>
<li><p><code>nr_files</code>：这是一个每个CPU计数器，用于跟踪每个CPU上分配的文件结构的数量。</p>
</li>
<li><p><code>get_nr_files()</code>：此函数通过读取<code>nr_files</code>计数器的正值，返回所有CPU上分配的文件结构的总数。</p>
</li>
<li><p><code>alloc_empty_file()</code>：此函数接受两个参数，<code>flags</code>和<code>cred</code>，并尝试分配一个空的文件结构。</p>
<ul>
<li><p>如果分配的文件结构的数量（<code>get_nr_files()</code>）大于或等于允许的最大值（<code>files_stat.max_files</code>），并且当前进程没有<code>CAP_SYS_ADMIN</code>能力，它将跳过文件分配并跳转到<code>over</code>标签。</p>
</li>
<li><p>如果满足条件，它将调用<code>__alloc_file()</code>函数来分配一个新的文件结构。</p>
</li>
<li><p>如果分配成功（即返回的指针不是错误），它会增加<code>nr_files</code>计数器。</p>
</li>
<li><p>如果分配失败或达到最大文件数且没有所需的权限，该函数将返回一个带有<code>-ENFILE</code>错误代码的错误指针。</p>
</li>
</ul>
</li>
</ul>
<p>代码显示了Linux内核中的全局变量<code>nr_files</code>和函数<code>alloc_empty_file</code>。<code>alloc_empty_file</code>分配<code>struct</code>文件(<code>f = __alloc_file(flags, cred);</code>)。对于每个分配的结构文件，<code>nr_files</code>通过增加计数器来计算(<code>ercpu_counter_inc(&amp;nr_files);</code>)。在主机Linux内核中，<code>struct</code>文件的总数受<code>files_stat</code>的限制。<code>Max_files(if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN))</code>。如果达到限制，<code>alloc_empty_file</code>返回一个错误(<code>return ERR_PTR(-ENFILE);</code>)。</p>
<p>然而，Linux内核并没有提供任何<code>namespace</code>或<code>cgroup</code>来隔离或限制<code>nr_files</code>。因此，<code>nr_files</code>是可以直接控制所有容器的–任何容器对结构文件的分配都会增加相同的共享全局变量<code>nr_files</code>。</p>
<p>这样的<code>nr_files</code>共享会导致新的攻击。在Linux中，所有东西都是一个文件。如此多的操作，如文件打开、进程创建、管道创建、新的网络连接创建，甚至计时器创建<code>(timerfd_create</code>)和事件生成(<code>eventfd</code>)，都增加了<code>nr_files</code>。恶意容器可以很容易地将nr_files弹出到其上限。实际上，在我们的实验中，<code>nr_files</code>的配额可以在几秒钟内快速耗尽。因此，所有使用<code>struct</code>文件的操作都将失败。</p>
<p>影响是严重的:受害者容器甚至不能运行命令(因为它需要打开命令文件)或执行新的二进制文件，导致程序崩溃。从上面的例子中，我们发现即使容器有足够的物理资源，比如CPU或内存，如果没有<code>nr_files</code>中的配额，它仍然不能运行任何新的程序。</p>
<p>为了证明抽象资源攻击会影响所有内核功能，我们针对Linux内核功能的每个方面(包括进程、内存、存储和IO管理)提出了一个抽象资源攻击。在本节中，我们将展示本地测试环境上的攻击结果.。</p>
<p>对于本地测试环境设置，测试机器具有Intel Core i5 CPU, 8 GB内存和500 GB HDD，运行Ubuntu 18.04和Linux内核v5.3.1。我们将其称为主机。在主机上，我们使用docker 18.06.0-ce建立了两个docker容器，分别作为攻击者容器和受害者容器使用。我们按照docker安全最佳实践设置了这两个容器，即在不同的非根用户中运行它们，删除所有功能，启用<code>namespace</code>和<code>cgroup</code>，并应用<code>seccomp</code>系统调用阻塞，如threat model中所讨论的那样。</p>
<h2 id="Attacks-on-Process-Management"><a href="#Attacks-on-Process-Management" class="headerlink" title="Attacks on Process Management"></a>Attacks on Process Management</h2><p>为了实现进程管理，Linux内核引入了一系列的抽象资源，如进程控制块<code>struct task_struct</code>、<code>pid</code>、<code>state</code>和各种数据结构来支持派生实体,如用于线程的s<code>truct thread_info</code>、<code>struct rq runqueues</code>用于调度,<code>struct shm_info</code>和<code>struct semaphore</code>用于进程间通信（IPC），<code>struct spinlock</code>和<code>struct semaphores</code>来实现同步。事实上，Linux中的进程管理引入了成千上万的抽象资源。在下面，我们介绍针对结构idr的攻击，作为一个的例子。</p>
<h3 id="Attacking-idr-of-PID"><a href="#Attacking-idr-of-PID" class="headerlink" title="Attacking idr of PID"></a>Attacking idr of PID</h3><p>Linux内核引入了用于整数ID管理的<code>struct idr</code>。进程管理也使用<code>idr</code>进行<code>pid</code>分配。代码显示了<code>alloc_pid</code>函数，该函数调用<code>idr_alloc_cyclic</code>来获得一个新的<code>pid</code>。<code>Idr_alloc_cyclic</code>在<code>idr</code>分配期间检查<code>pid_max</code>，如果<code>idr</code>增长超过<code>pid_max</code>，则返回一个负错误代码。稍后我们将展示，即使启用了<code>PID namespace</code>和<code>PID cgroup</code>，<code>idr</code>仍然可以被视为所有进程的全局共享资源。类似于<code>fork炸弹</code>，恶意容器进程可以重复<code>fork</code>耗尽所有<code>idr</code>。因此，共享内核上的所有容器都不能创建任何新的进程或线程。</p>
<p>在我们的实验中，攻击者-容器通过调用<code>fork</code>系统调用反复生成进程。结果，在受害容器中，所有与创建新进程相关的操作都失败，并报错“资源临时不可用”。即使是主机上的根用户也会遇到同样的故障。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> pid *<span class="title function_">alloc_pid</span><span class="params">(<span class="keyword">struct</span> pid_namespace *ns,<span class="type">pid_t</span> *set_tid, <span class="type">size_t</span> set_tid_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    nr = idr_alloc_cyclic(&amp;tmp-&gt;idr, <span class="literal">NULL</span>, pid_min, pid_max, GFP_ATOMIC);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(nr &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        retval = (nr == ENOSPC) ? -EAGAIN : nr;</span><br><span class="line">        <span class="keyword">goto</span> out_free;</span><br><span class="line">    &#125;</span><br><span class="line">    pid-&gt;numbers[i].nr = nr;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段C代码片段是Linux内核中的一部分，涉及到进程ID（<code>PID</code>）的分配。它定义了一个名为<code>alloc_pid</code>的函数，用于在给定的<code>namespace ns</code>中分配一个新的<code>PID</code>。</p>
<p><code>alloc_pid</code>函数接受以下参数：</p>
<ul>
<li><code>struct pid_namespace *ns</code>：进程ID的命名空间，用于将<code>PID</code>限制在特定的<code>namespace</code>范围内。</li>
<li><code>pid_t *set_tid</code>：指向一个包含线程ID的数组，这些线程ID与新分配的<code>PID</code>关联。通常用于<code>clone</code>系统调用。</li>
<li><code>size_t set_tid_size</code>：<code>set_tid</code>数组的大小。</li>
</ul>
<p>在函数的主体中：</p>
<ol>
<li><p><code>idr_alloc_cyclic()</code>函数被调用以在<code>tmp-&gt;idr</code>中分配一个新的ID，范围在<code>pid_min</code>和<code>pid_max</code>之间。<code>GFP_ATOMIC</code>标志表示内存分配应该是原子性的，即在不释放内核锁的情况下进行分配。</p>
</li>
<li><p>如果<code>nr</code>小于0，说明分配失败。根据失败的原因，<code>retval</code>被设置为<code>-EAGAIN</code>（当<code>nr</code>等于<code>ENOSPC</code>）或<code>nr</code>。然后跳转到<code>out_free</code>标签。</p>
</li>
<li><p>如果分配成功，<code>pid-&gt;numbers[i].nr</code>被设置为新分配的ID。</p>
</li>
</ol>
<p>这段代码负责在给定<code>namespace</code>中分配和管理进程ID。</p>
<h3 id="The-effectiveness-of-the-PID-namespace"><a href="#The-effectiveness-of-the-PID-namespace" class="headerlink" title="The effectiveness of the PID namespace"></a>The effectiveness of the PID namespace</h3><p>Linux v2.6.24引入了<code>PID namespace</code>，它为进程提供了一组独立的<code>PID</code>，这些<code>PID</code>来自其他<code>PID namespace</code>。但是，在<code>PID namespace</code>实现中，Linux内核会在根<code>PID namespace</code>中为其他<code>PID namespace</code>中分配的任何<code>PID</code>分配一个额外的<code>PID</code>，这样其他<code>PID namespace</code>中的所有<code>PID</code>都可以映射到根<code>PID namespace</code>。换句话说，根<code>PID namespace</code>仍然是全局共享的。因此，即使攻击者-容器处于分离的<code>PID namespace</code>中，其<code>PID</code>分配仍然会耗尽根<code>PID namespace</code>中的<code>PID</code>，从而导致victim-container和主机上的new-process-create失败。因此，即使启用了<code>PID namespace</code>，容器仍然容易受到上述<code>idr</code>耗尽攻击的攻击。</p>
<h3 id="The-effectiveness-of-the-PIDs-control-group"><a href="#The-effectiveness-of-the-PIDs-control-group" class="headerlink" title="The effectiveness of the PIDs control group"></a>The effectiveness of the PIDs control group</h3><p>最近在Linux v4.3中也引入了<code>PIDs  cgroup</code>。它的作用是用来限制分配在一个控制组中的PIDs的总数。更具体地说，PIDs控制组在进程分叉过程中检查进程的限制，如果PIDs控制组中的总进程数（<code>pids_cgroup-&gt;counter</code>）达到上限（<code>pids_cgroup -&gt;limit</code>），则返回错误并中止分叉。PIDs控制组在防御直接分叉方面是有效的。然而，它只向当前进程收取pid号。attacker-container可以欺骗内核来分叉大量的内核线程，比如频繁中止导致内核产生中断处理线程。通过这种方式，<code>idr</code>被内核线程耗尽，这就绕过了由 <code>PIDs cgroup</code>。</p>
<h2 id="Attacks-on-Memory-Management"><a href="#Attacks-on-Memory-Management" class="headerlink" title="Attacks on Memory Management"></a>Attacks on Memory Management</h2><p>Linux内核引入了各种内核数据结构，例如<code>mm_struct</code>用于保存进程的所有内存相关信息，<code>vm_area_struct</code>用于表示虚拟内存区域。此外，为了提高读写效率，Linux内核还使用内存作为缓冲区来缓存某些数据。此外，还介绍了回写方案，即只对内存进行写操作。脏内存页稍后将由内核线程写入磁盘。使用<code>write-back</code>方案，调用方只需要写入内存，而不需要等待耗时的磁盘io操作完成(即<code>wirtr-through</code>)，这大大提高了写性能。然而，我们发现内核并没有隔离或限制脏内存区域的使用，这给了攻击者耗尽所有脏内存的机会，这大大减慢了其他容器的速度。接下来，我们讨论对脏内存的攻击。</p>
<h3 id="Attacking-dirty-throttle-control-memory-dirty-ratio"><a href="#Attacking-dirty-throttle-control-memory-dirty-ratio" class="headerlink" title="Attacking dirty_throttle_control memory dirty ratio"></a>Attacking dirty_throttle_control memory dirty ratio</h3><p>Linux内核为脏区控制引入了<code>dirty_throttle_control</code>结构体，它使用<code>dirty</code>字段表示整个内核空间的<code>dirty ratio</code>。只要<code>dirty</code>值太高，内核就会唤醒后台线程，将脏内存同步到磁盘。但同时由于<code>dirty</code>比过高，内核会阻塞<code>write_back</code>，将所有写都转换为<code>write_through</code>，写性能大大降低。</p>
<p>不幸的是，内核没有为内存<code>dirty ratio</code>提供任何隔离。任何进程都可能影响全局内存dirty ratio。在我们的攻击中，攻击者-容器使用<code>dd</code>命令生成文件，快速占用所有脏内存，达到内存<code>dirty ratio</code>限制。结果，来自主机或受害者容器的所有写操作都被转换为<code>write_through</code>，这极大地降低了性能。在我们的实验中，由于攻击，受害者容器上的命令dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;mnt&#x2F;test bs&#x3D;1M count&#x3D;1024的性能从1.2 GB&#x2F;s下降到32.6 MB&#x2F;s，导致97.3%的减速。</p>
<p>此外，即使是主机上的特权根用户也有96.1%的性能下降。</p>
<p>请注意，当前Linux内核没有与内存管理相关的<code>namespace</code>，内存<code>cgroup</code>用于限制内存使用，而不是限制内存<code>dirty ratio</code>。因此，无法防御针对内存<code>dirty ratio</code>的攻击。</p>
<h2 id="Attacks-on-Storage-Management"><a href="#Attacks-on-Storage-Management" class="headerlink" title="Attacks on Storage Management"></a>Attacks on Storage Management</h2><p>操作系统内核将磁盘或其他辅助存储抽象为文件，并引入各种与文件相关的抽象资源。实际上，Linux内核中的存储管理是复杂的，它涉及数千个函数和数据结构。在我们的实验中，我们发现有133个与存储相关的抽象资源可以从容器进程中访问。不幸的是，内核没有提供任何<code>namespace</code>或<code>cgroup</code>来隔离或限制这些抽象资源的使用。因此，攻击者容器可以耗尽这些抽象资源，对共享内核上的其他容器发起DoS攻击。</p>
<p>接下来，我们将说明恶意容器如何利用文件限制变量<code>nr_files</code>进行DoS攻击。</p>
<h3 id="Attacking-nr-files"><a href="#Attacking-nr-files" class="headerlink" title="Attacking nr_files"></a>Attacking nr_files</h3><p><code>nr_files</code>是Linux内核中的一个全局变量，它计算内核中打开的文件总数。更具体地说，对于每个分配的结构文件，内核将nr_files加1。不幸的是，<code>nr_files</code>是所有进程共享的。它既不受<code>namespace</code>的隔离，也不受任何<code>cgroup</code>的限制。因此，攻击容器可以很容易地耗尽<code>nr_files</code>来实现DoS攻击。</p>
<p>为了验证这种攻击的可行性，我们的攻击容器生成了数百个进程，每个进程打开1024个文件。因此，<code>nr_files</code>达到其极限。结果，在主机和受害者容器上，所有文件打开操作都失败，内核发出“系统中打开的文件太多”的警告。我们的攻击证实，即使只有几百个进程，攻击者也能够耗尽<code>nr_files</code>。而为了可用性，<code>pid cgroup</code>通常允许数千个进程。因此，即使启用了<code>pid cgroup</code>，攻击者-容器仍然可以成功地对<code>nr_files</code>进行dos攻击。更糟糕的是，<code>nr_files</code>在所有进程(包括根进程和非根进程)之间共享。</p>
<p>因此，不仅非特权容器进程受到影响，主机上的根进程也不能执行任何文件打开操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">percpu_counter</span> <span class="title">nr_files</span> __<span class="title">cacheline_aligner_in_smp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">get_nr_files</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> percpu_counter_read_positive(&amp;nr_files);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> file *<span class="title function_">alloc_empty_file</span><span class="params">(<span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> old_max;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN))</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">goto</span> over;</span><br><span class="line">    &#125;</span><br><span class="line">    f = __alloc_file(flags, cred);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(f))</span><br><span class="line">        percpu_counter_inc(&amp;nr_files);</span><br><span class="line">    ...</span><br><span class="line">over:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(-ENFILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Attacks-on-IO-Management"><a href="#Attacks-on-IO-Management" class="headerlink" title="Attacks on IO Management"></a>Attacks on IO Management</h2><p>IO管理是操作系统的重要组成部分。为了便于管理，Linux内核将IO设备抽象到<code>/dev</code>文件中，并引入抽象资源(如<code>tty_struct</code>)来实现IO设备管理。与前面的情况类似，这些抽象资源不受任何<code>namespace</code>或控<code>cgroup</code>的隔离或限制，因此会导致新的攻击。下面，我们将介绍针对<code>pty_count</code>的攻击，它会导致SSH连接出现DoS。</p>
<h3 id="Attacking-pty-count"><a href="#Attacking-pty-count" class="headerlink" title="Attacking pty_count"></a>Attacking pty_count</h3><p>Linux内核将伪终端<code>pseudo-terminal</code>(缩写为<code>pty</code>)抽象为<code>/dev/ptmx</code>和<code>/dev/pts</code>。与此同时，内核还使用一个名为<code>pty_count</code>的全局变量来计算打开的<code>pseudo-terminal</code>的总数，每打开一次<code>/dev/ptmx</code>，<code>pseudo-terminal</code>的总数就增加1，如代码。但是，内核没有提供任何<code>namespace</code>或<code>cgroup</code>来隔离或限制<code>pty_count</code>的使用。因此，攻击者可以很容易地耗尽<code>pty_count</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">atomic_t</span> pty_count = ATOMIC_INIT(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">devpts_new_index</span><span class="params">(<span class="keyword">struct</span> pts_fs_info *fsi)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index = -ENOSPC;</span><br><span class="line">    <span class="keyword">if</span> (atomic_inc_return(&amp;pty_count) &gt;= (pty_limit - (fsi-&gt;mount_ops.reserve ? <span class="number">0</span> : pty_reserve)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ptmx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *flip)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    index = devpts_new_index(fsi);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段C代码片段是Linux内核中的一部分，涉及到伪终端（PTY）的分配和管理。它定义了一个名为<code>devpts_new_index</code>的函数，用于在给定的文件系统信息<code>fsi</code>中分配一个新的伪终端索引。此外，还展示了一个名为<code>ptmx_open</code>的函数，它在打开伪终端主设备（PTMX）时调用<code>devpts_new_index</code>。</p>
<ul>
<li><p>一个名为<code>pty_count</code>的原子变量被初始化为0。它表示当前分配的伪终端的数量。</p>
</li>
<li><p><code>devpts_new_index</code>函数接受一个参数：</p>
<ul>
<li><code>struct pts_fs_info *fsi</code>：一个指向伪终端文件系统信息的指针。</li>
</ul>
</li>
<li><p>在<code>devpts_new_index</code>函数中：</p>
<ul>
<li><p>初始化<code>index</code>为<code>-ENOSPC</code>，表示没有足够的空间分配新的索引。</p>
</li>
<li><p>增加<code>pty_count</code>的值。如果增加后的值大于等于<code>pty_limit - (fsi-&gt;mount_ops.reserve ? 0 : pty_reserve)</code>，则跳转到<code>out</code>标签。</p>
</li>
<li><p>返回<code>index</code>。</p>
</li>
</ul>
</li>
<li><p><code>ptmx_open</code>函数是在打开伪终端主设备（PTMX）时调用的。它接受两个参数：</p>
<ul>
<li><p><code>struct inode *inode</code>：表示伪终端主设备（PTMX）的inode结构。</p>
</li>
<li><p><code>struct file *flip</code>：表示伪终端主设备（PTMX）的file结构。</p>
</li>
</ul>
</li>
<li><p>在<code>ptmx_open</code>函数中，调用<code>devpts_new_index(fsi)</code>以获取一个新的伪终端索引。</p>
</li>
</ul>
<p>这段代码负责在给定的伪终端文件系统信息中分配和管理伪终端索引。当打开伪终端主设备（PTMX）时，会调用<code>devpts_new_index</code>函数以获取新的伪终端索引。</p>
<p>在我们的实验中，攻击者不断打开<code>/dev/ptmx</code>在触发<code>ptmx_open</code>，它调用<code>devpts_new_index</code>并增加<code>pty_count</code>。在几秒钟内，<code>pty_count</code>达到极限，所有接下来的<code>ptmx_open</code>操作都会失败。其后果很严重，因为<code>pty</code>设备被各种应用广泛使用，如SSH连接。结果是，由于伪终端打开失败，所有对任何其他容器的SSH连接尝试都会失败。更糟糕的是，主机无法启动任何新的容器，因为新容器的连接由于同样的错误而被拒绝。</p>
<h2 id="Attacking-FreeBSD-and-Fuchsia-Kernels"><a href="#Attacking-FreeBSD-and-Fuchsia-Kernels" class="headerlink" title="Attacking FreeBSD and Fuchsia Kernels"></a>Attacking FreeBSD and Fuchsia Kernels</h2><p>抽象资源攻击的根本原因是共享的内核数据(即抽象资源)。接下来，我们将演示共享内核数据还使FreeBSD和Fuchsia容易受到抽象资源攻击。</p>
<ul>
<li><p>Attacking FreeBSD</p>
<p>在FreeBSD内核中，在Linux内核中类似的资源之后，我们手动识别了5个共享的全局抽象资源，分别是<code>dp_dirty_total</code>、<code>numvnodes</code>、<code>openfiles</code>、<code>pid</code>和<code>pty</code>。我们的实验进一步证实了前两个可以被DoS攻击，而后三个则受到<code>rctl per-jail</code>的限制。</p>
<p>实验是在FreeBSD 13.0-RELEASE和Ezjail-admin v3.4.2上进行的，运行在具有Intel酷睿i5处理器、8GB内存和40GB硬盘的虚拟机上。<code>Ezjail</code>是一个<code>jail</code>管理框架。<code>ezjail</code>命令提供了一种使用FreeBSD的<code>jail</code>系统创建多个<code>jail</code>的简单方法。这里的<code>jail</code>类似于Linux上的容器。我们根据FreeBSD手册建立了两个<code>jail</code>，并使用<code>rctl</code>来限制每个<code>jail</code>的资源。我们使用这两个<code>jails</code>作为<code>attacker-jail</code>和<code>victim-jail</code>，这类似于§3.1中的容器设置。</p>
<p>对于脏计数器<code>dp_dirty_total</code>, FreeBSD中的<code>ZFS</code>引入了<code>dsl_pool</code>结构体来记录每个<code>ZFS</code>池的数据。<code>dsl_pool</code>结构体使用<code>dp_dirty_total</code>字段表示整个<code>ZFS</code>池脏数据。当<code>dp_dirty_total</code>达到<code>zfs_dirty_data_max</code>的限制时，ZFS将延迟即将进行的写操作，并等待脏数据同步到磁盘。不幸的是，FreeBSD没有为<code>dp_dirty_total</code>提供任何隔离。在attacker-jail中，我们运行命令<code>dd if=/dev/zero of=/mnt/test bs=1M count=1024</code>(与§3.3中的相同)来耗尽<code>dp_dirty_total</code>。因此，<code>victim-jail</code>的IO性能下降了46%。</p>
<p>对于<code>numvnode</code>s, FreeBSD使用<code>vnode</code>结构体来表示文件系统实体，例如文件或目录。FreeBSD还保留了一个全局变量<code>numvnodes</code>来记录整个内核中<code>vnode</code>的总数。极限在<code>maxvnodes</code>。在实验中，通过在<code>attacker-victim</code>中重复创建目录，我们可以很容易地耗尽主机的<code>numvnodes</code>并达到<code>maxvnodes</code>的限制。</p>
</li>
<li><p>Attacking Fushsia</p>
<p>Fuchsia使用<code>Zircon</code>内核，他引入了<code>handle</code>的概念，允许用户空间程序引用内核对象。<code>Zircon</code>维护了一个名为<code>gHandleTableArena</code>的全局数据结构，用于分配所有句柄。内核中<code>handle</code>的限制是<code>kMaxHandleCount</code>。<code>handle</code>在<code>Zircon</code>中使用非常频繁。令人惊讶的是，我们发现<code>handle</code>的创建不受限制。我们在Fuchsia模拟器上进一步确认了这个问题。具有基本权限(类似于Linux中的功能)的用户可以重复创建<code>handle</code>，耗尽所有<code>handle</code>，从而导致整个系统崩溃。我们向Fuchsia开发人员报告了这个问题。他们已经确认了这个问题，并计划在确定更多的攻击载体到本地DoS后修复这个问题。</p>
</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>从上面的讨论中，很容易看出抽象的资源攻击是非常实用的，后果是严重的。更糟糕的是，抽象资源在Linux内核中非常常见，影响Linux功能的各个方面。此外，抽象资源攻击是操作系统级虚拟化所固有的。它也适用于FreeBSD和Fuchsia内核。</p>
<h1 id="Static-Analysis-Of-Container-Exhaustible-Abstract-Resources"><a href="#Static-Analysis-Of-Container-Exhaustible-Abstract-Resources" class="headerlink" title="Static Analysis Of Container-Exhaustible Abstract Resources"></a>Static Analysis Of Container-Exhaustible Abstract Resources</h1><p>如前所述，抽象资源对容器至关重要。</p>
<p>另一方面，有成千上万的抽象资源，这使得几乎不可能列举所有这些资源。在本文中，我们迈出了识别容器共享的可耗尽抽象资源的第一步。</p>
<ul>
<li><p>Challenges</p>
<ul>
<li><p>首先，很难识别有意义的抽象资源，尤其是那些在内核中共享的资源。Linux内核中的抽象资源可以是变量或数据结构实例。然而，并非所有变量或数据结构实例都是有意义的抽象资源。我们需要找到对操作系统功能至关重要的抽象资源。此外，所识别的抽象资源需要在容器之间共享，以便一个容器可以耗尽这些资源来攻击其他容器。不幸的是，没有关于可共享抽象资源的文档。</p>
<p>为了解决这个问题，我们建议使用基于配置的分析<code>configuration-based analysis</code>和基于访问的分析<code>access-based analysis</code>来识别Linux内核中的各种共享抽象资源。</p>
</li>
<li><p>其次，决定容器是否可以用尽特定的抽象资源是一个挑战。与普通的用户空间程序不同，从容器中访问资源面临更多的限制，如<code>namespace</code>、<code>cgroup</code>和<code>seccomp</code>。此外，由于每个容器在一个单独的用户中运行，其资源消耗也受到每个用户的限制。因此，对资源消耗点的简单可达性分析不能说明容器对抽象资源的可控性。例如、对于被<code>namespace</code>隔离的抽象资源，即使容器可以消费这些抽象资源，由于<code>namespace</code>的隔离，它仍然可能不会影响其他容器。因此，为了克服这一挑战，我们提出了容器可控性分析，包括<code>seccomp</code>限制分析、<code>per-user</code>限制分析和<code>namespace</code>隔离分析，以进一步过滤容器可耗费的资源。</p>
</li>
</ul>
</li>
</ul>
<p>图显示了我们的工具的体系结构，它自动识别出容器可耗尽的抽象资源。分析工具以内核源<code>IR</code>作为输入。它首先使用§4.1中基于配置的分析和基于访问的分析来识别所有内核可共享的抽象资源。然后进行§4.2中的系统调用可达性分析和容器限制分析，包括<code>seccomp</code>、<code>per-user</code>和<code>namespace</code>限制分析，分析这些抽象资源上的容器可控性。</p>
<p>此外，我们在§4.3给出了分析结果。</p>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/architecture.png"></p>
<h2 id="Identification-of-Kernel-Shareable-Abstract-Resources"><a href="#Identification-of-Kernel-Shareable-Abstract-Resources" class="headerlink" title="Identification of Kernel Shareable Abstract Resources"></a>Identification of Kernel Shareable Abstract Resources</h2><p>如前所述，从成千上万的内核变量和数据结构实例中识别有意义的抽象资源具有挑战性。更困难的是，为了确保这些抽象资源在容器之间直接或间接地共享，我们需要将它们缩小到可共享的内核抽象资源。</p>
<p>为了克服这一挑战，我们利用内核编程范例并提出基于配置的分析和基于访问的分析来识别内核可共享资源。</p>
<h3 id="Configuration-based-Analysis"><a href="#Configuration-based-Analysis" class="headerlink" title="Configuration-based Analysis"></a>Configuration-based Analysis</h3><p>Linux内核在<code>/proc/sys</code>下提供<code>sysctl</code>接口，允许用户空间程序配置内核参数。我们的主要观察结果是，这些<code>sysctl</code>配置中的大多数用于抽象的资源限制，例如限制文件数<code>fs.file-nr</code>或内存大页<code>vm.nr_hugepages</code>。因此，所有容器都共享由<code>sysctl</code>配置指定的相同全局限制。这样的<code>sysctl</code>配置提供了关于容器之间可共享的抽象资源的重要线索。</p>
<p>基于上述观察，我们建议使用<code>sysctl</code>配置来识别可共享的内核抽象资源，称为基于配置的分析，它包括三个基本步骤。</p>
<ul>
<li><p>首先，它使用特定的<code>sysctl</code>数据类型来识别所有的<code>sysctl</code>相关数据结构。这些数据结构包含可配置的<code>sysctl</code>内核参数。</p>
</li>
<li><p>其次，<code>sysctl</code>数据结构通常包含在<code>/proc/sys/</code>文件夹中显示<code>sysctl</code>值的函数。因此，通过分析该函数，我们能够准确地找出该内核参数的变量。</p>
</li>
<li><p>最后，如果一个内核参数被用于限制资源消耗，它的相应变量应该出现在比较指令中。因此，我们按照使用-定义链来检查所确定的变量的使用情况，如果它在比较指令中被使用，就把它标记为抽象资源。</p>
</li>
</ul>
<p>我们在LLVM中设计并实现了一个过程间分析通道。我们在代码中使用一个示例来说明细节。具体来说，Linux内核使用类型<code>struct ctl_table</code>来配置<code>sysctl</code>内核参数，例如代码中的第1行所示的<code>fs_table</code>中的文件系统配置。</p>
<p>因此，该通道首先遍历所有的内核全局变量，收集所有的结构<code>ctl_table</code>变量，如代码中的<code>fs_table</code>。其次，<code>fs_table</code>使用<code>proc_handler</code>中的函数指针来显示<code>/proc/sys/</code>文件系统中的参数。因此，从遍历所有的内核全局变量来收集所有的结构<code>ctl_table</code>变量，如代码中的<code>fs_table</code>。</p>
<p>第二，<code>fs_table</code>使用<code>proc_handler</code>中的函数指针来显示<code>/proc/sys/</code>文件系统中的参数。因此，从<code>proc_handler</code>字段中，通证遵循其指向，启动程序间分析以获得确切的变量，其值显示在<code>sysctl</code>配置界面中。如代码第19行所示，我们的传递将nr_files标记为关键变量。</p>
<p>第三，我们的传递检查所有已识别的关键变量的使用情况。如果一个关键变量在比较指令中被使用（即<code>LLVM IR</code>中的<code>icmp</code>），我们的传递就会记录这些位置并将这个变量标记为抽象资源。例如，在代码的第25行，<code>nr_files</code>被用于比较。我们的传递进一步检测到，如果比较失败，在第25行和第27行会返回一个错误。因此，我们的传递将<code>nr_files</code>标记为一个抽象资源。通过分析所有的<code>struct ctl_table</code>，我们的传递得到一个抽象资源的集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">fs_table</span>[] =</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        .procname = <span class="string">&quot;file-nr&quot;</span>,</span><br><span class="line">        .data = &amp;files_stat,</span><br><span class="line">        .proc_handler =proc_nr_files,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> proc_nr_files(...)</span><br><span class="line">&#123;</span><br><span class="line">    files_stat.nr_files = get_nr_files();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">get_nr_files</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> percpu_counter_read_positive(&amp;nr_files);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> file *<span class="title function_">alloc_empty_file</span><span class="params">(<span class="type">int</span> flags, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(get_nr_files() &gt;= files_stat.max_files &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">goto</span> over;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码片段是一个C代码，用于管理Linux内核模块中的文件资源。它定义了一个名为<code>fs_table</code>的<code>ctl_table</code>结构数组、一个用于设置当前打开文件数量的<code>proc_nr_files</code>函数、一个返回打开文件数量的<code>get_nr_files</code>函数，以及一个在打开文件数量未超过允许的最大值时分配新文件结构的<code>alloc_empty_file</code>函数。</p>
<p>以下是各个组件的详细解释：</p>
<ol>
<li><p><code>fs_table</code>是一个<code>ctl_table</code>结构数组，用于定义<code>/proc/sys/fs/</code>目录中的sysctl条目。具有<code>procname</code>为”file-nr”的条目与当前打开文件的数量相关联。</p>
</li>
<li><p><code>proc_nr_files</code>是一个设置当前打开文件数量的函数。当调用该函数时，它会使用<code>get_nr_files()</code>函数返回的值更新<code>files_stat.nr_files</code>。</p>
</li>
<li><p><code>get_nr_files</code>是一个返回当前打开文件数量的函数。它通过从名为<code>nr_files</code>的<code>percpu_counter</code>结构中读取一个值来实现这一点。该结构用于以适用于多核系统的高效方式存储文件数量。</p>
</li>
<li><p><code>alloc_empty_file</code>是一个尝试分配空文件结构的函数。它检查当前打开文件的数量（由<code>get_nr_files()</code>返回）是否大于或等于最大允许的文件数量（存储在<code>files_stat.max_files</code>中）。如果满足此条件且调用者没有<code>CAP_SYS_ADMIN</code>能力，则跳转到标签<code>over</code>，这个标签可能处理文件数量超过最大值的情况。</p>
</li>
</ol>
<p>这个代码片段是Linux内核如何管理文件资源并对同时打开的文件数量施加限制的一个例子。</p>
<h3 id="Access-based-Analysis"><a href="#Access-based-Analysis" class="headerlink" title="Access_based Analysis"></a>Access_based Analysis</h3><p>除了sysctl配置外，Linux内核还使用锁或原子机制来保护并发访问的资源。因此，我们建议使用并发访问作为标识来标识一组可共享的抽象资源。</p>
<p>由于（race condition）竞态条件和并发性分析是一个老话题，我们采用现有的lockset检测方法。如果锁在数据结构的某个字段上，我们将该数据结构标记为抽象资源，并将该函数添加到敏感函数集中。具体来说，如果在某个数据结构的字段上使用了锁，那么可以将此数据结构标记为抽象资源，并将涉及该字段的函数添加到敏感函数集合中。这意味着这些函数可能需要特别关注，因为它们可能会受到并发访问的影响。此外，如果一个变量在lock和unlock函数之间被定量地修改，我们也将其标记为抽象资源。例如，多个线程在没有锁保护的情况下访问同一数据结构，那么可以将这组资源标记为抽象资源。如果某个变量在 lock 和 unlock 函数之间被定量地修改（即，在锁保护下发生了修改），那么也可以将其标记为抽象资源。这有助于进一步确定可能受到并发影响的资源。</p>
<p>除了锁定&#x2F;解锁，我们还观察到原子计数器和<code>percpu</code>计数器还用于保护并发访问的数据，例如<code>percpu_counter_inc</code>和<code>atomic_inc_return</code>。因此，我们实现了一个pass来分析所有原子计数器和percpu计数器的使用情况。我们的传递首先分析函数参数，并将所有具有<code>struct atomic_t</code>、<code>struct atomic64_t</code>和<code>struct percpu_counter</code>参数的函数添加到<code>原子/percpu</code>函数集中。其次，遍历所有内核函数中的所有语句，以检查<code>原子/percpu</code>函数的所有使用情况。如果一个变量被传递给一个<code>原子/percpu</code>函数，我们将它标记为一个抽象资源。</p>
<ul>
<li><p>识别具有<code>原子/percpu</code>计数器参数的函数.</p>
</li>
<li><p>遍历内核函数中的语句，检查<code>原子/percpu</code>函数的使用情况。</p>
</li>
</ul>
<p>在实现过程中，我们发现LLVM链接器合并了具有相同内存布局的结构类型，例如<code>typedef struct &#123;int counter;&#125;</code> <code>atomic_t</code>和<code>typedef struct &#123;uid_t val;&#125; kuid_t</code>。原因是uid_t的类型是unsigned int，它的大小与int相同。因此，LLVM链接器将它们合并，并错误地使用<code>kuid_t</code>代替<code>atomic_t</code>。为了解决这个问题，我们跟踪LLVM链接器，并发现<code>lib/ linker / irmove .cpp</code>中的get方法将新类型与现有类型进行比较，如果内存布局相同，则合并它们。因此，我们通过注释掉比较和合并代码来禁用合并。</p>
<h2 id="Container-Contorllability-Analysis"><a href="#Container-Contorllability-Analysis" class="headerlink" title="Container-Contorllability Analysis"></a>Container-Contorllability Analysis</h2><p>通过识别抽象资源，我们提出了容器可控性分析，以确保容器实际上可以消耗这些抽象资源。我们对容器可控性分析的想法是（two-fold）双重的。</p>
<ul>
<li><p>首先，我们需要确保容器进程可以到达§4.1中的抽象资源消耗点。为此，我们基于内核控制流图执行传统的反向控制流分析，其中基于结构类型解析间接调用。如果没有从系统调用项到抽象资源消耗点的路径，我们将该抽象资源标记为容器不可访问的。</p>
</li>
<li><p>其次，注意，单靠可达性分析是不够的，我们需要进一步确保路径上没有额外的特定于容器的限制。换句话说，我们需要检查路径上是否存在任何限制检查，以确保容器可以耗尽这些抽象资源。如前所述，与用户空间程序不同，容器面临更多限制，如<code>seccomp</code>、<code>namespace</code>、<code>cgroup</code>以及每个用户的资源限制。由于我们的可达性分析是标准的，在接下来的文章中，我们将重点关注限制分析。</p>
</li>
</ul>
<h3 id="Seccomp-Restriction-Analysis"><a href="#Seccomp-Restriction-Analysis" class="headerlink" title="Seccomp Restriction Analysis"></a>Seccomp Restriction Analysis</h3><p><code>Seccomp</code>是一种用于系统调用过滤的机制。我们对<code>seccomp</code>的限制分析如下。在我们的实现中，我们使用Docker默认的<code>seccomp</code>配置文件，它可以阻止超过50个系统调用。在从系统调用条目到资源消耗站点的所有路径中，我们过滤掉来自任何阻塞的系统调用的路径。</p>
<h3 id="Per-User-Restriction-Analysis"><a href="#Per-User-Restriction-Analysis" class="headerlink" title="Per-User Restriction Analysis"></a>Per-User Restriction Analysis</h3><p>在实际部署中，容器通常以不同的用户运行。因此，每个容器的资源消耗也受到peruser资源配额的限制。例如，Linux提供了<code>user-limits</code>命令<code>ulimit</code>，用于限制用户的资源消耗。而<code>ulimit</code>的底层实现是使用<code>rlimit</code>来设置多个每个用户的资源配额。</p>
<p>除了<code>ulimit</code>, Linux还提供了允许用户利用<code>PAM (Pluggable Authentication Module)</code>部署每个用户配额的接口。PAM使用<code>setup_limits</code>函数来设置每个用户的资源配额，该函数调用<code>setrlimit</code>来配置多个<code>rlimit</code>约束。对于<code>ulimit</code>、<code>rlimit</code>和<code>PAM</code>所限制的资源，攻击者容器不能消耗超过每个用户配额的资源。因此，它无法完全控制这些抽象资源来发起DoS攻击。由于<code>ulimit</code>和<code>PAM</code>都使用<code>rlimit</code>来设置每个用户的资源配额，因此我们需要分析<code>rlimit</code>并过滤出受其限制的抽象资源。</p>
<p>对于<code>rlimi</code>t分析，我们的关键观察是<code>rlimit</code>值通常在<code>struct rlimit</code>或<code>struct rlimit64</code>中指定。因此，我们首先遍历内核<code>IR</code>，以识别从<code>struct rlimit</code>或<code>struct rlimit64</code>加载的所有变量。然后，我们执行数据流分析，以跟踪这些变量的所有传播和使用，并在任何比较指令中使用这些函数时标记它们。在这些函数中，检查<code>rlimit</code>以限制某些资源。我们认为这些资源是攻击容器不可耗尽的，因此我们根据这些函数来过滤路径。我们的工具确定了40个检查<code>rlimit</code>的函数。</p>
<h3 id="Namespace-Isolation-Analysis"><a href="#Namespace-Isolation-Analysis" class="headerlink" title="Namespace Isolation Analysis"></a>Namespace Isolation Analysis</h3><p>如前所述，Linux内核为资源隔离引入了<code>namespace</code>。对于<code>namespace</code>隔离的资源，Linux内核在每个<code>namespace</code>下为其创建一个“<code>copy</code>”，以便一个<code>namespace</code>中的修改不会影响其他<code>namespace</code>。因此，为了确认容器的可控性，我们需要确保那些抽象资源不受<code>namespace</code>的保护。这里的挑战是，尽管Linux有关于<code>namespace</code>的文档，但没有关于哪些抽象资源由<code>namespace</code>隔离的规范。</p>
<p>因此，我们提出了<code>namespace</code>隔离分析来系统地识别受<code>namespace</code>保护的抽象资源。</p>
<p>我们的主要观察结果是，对于<code>namespace</code>隔离的资源，对应的数据结构有一个指针字段，指向它所属的<code>namespace</code>。因此，我们的工具首先遍历内核中每种数据结构类型的所有字段。如果该类型具有名称空间指针，则将其标记为隔离资源。其次，对于已识别的隔离资源，我们的工具使用它来过滤§4.1中识别的共享抽象资源。</p>
<p>请注意，由于不同<code>namesapce</code>之间的映射，一些<code>namespace</code>隔离的资源仍然容易受到抽象资源攻击。如§3.2.2所述，<code>idr</code>由<code>pid_namespace-&gt;idr</code>隔离。但是，在非根PID <code>namespace</code>中分配的每个<code>idr</code>都映射到根<code>PID namespace</code>中的一个新的<code>idr</code>，以便根<code>namespace</code>可以管理它。因此，根<code>PID namespace</code>被所有<code>PID namespace</code>中的所有容器全局共享。因此，它仍然容易受到<code>idr</code>耗尽攻击。</p>
<p>在我们的分析中，我们手动过滤掉这些资源。</p>
<h2 id="Analysis-Results"><a href="#Analysis-Results" class="headerlink" title="Analysis Results"></a>Analysis Results</h2><p>我们在LLVM 12.0中使用大约2500行c++代码实现了我们的分析工具。Linux内核<code>IR</code>是基于最新的Linux稳定版本v5.10和defconfig生成的。特别是，通过应用基于配置的分析和基于访问的分析，以及来自系统调用的可达性分析和<code>seccomp</code>限制分析，我们的工具确定了1844个容器可达的共享抽象资源。</p>
<ul>
<li><p>Resource Filtering</p>
<p>通过每个用户配额限制和<code>namespace</code>隔离分析，我们的工具可以找到342个受<code>rlimit</code>限制或具有指向<code>namespace</code>结构的指针的资源。这些资源要么对路径进行限制检查，要么对其进行<code>namespace</code>。</p>
<p>我们进一步进行手工分析。具体来说，对于已识别的抽象资源中的每个资源𝑅，我们将遍历所有检测到的𝑅或𝑅字段的修改。如果修改不是定量的，比如被赋值为布尔类型、枚举类型或字符串类型，则将此修改标记为非定量的。如果对𝑅和𝑅字段的所有修改都是非定量的，我们将𝑅标记为不可耗尽的。我们的手工分析确定了492种不可耗尽的抽象资源，经过人工分析，仍然有1010个抽象资源。</p>
</li>
<li><p>Dynamic Validation</p>
<p>为了进一步验证这1010个资源的动态耗尽，我们开发了一个资源消耗的动态验证方法。对于每个资源，我们首先从可控性分析中获得其消耗点和触发的系统调用。在此之后，我们对这些消耗站点进行测量，以监控实际的资源消耗。接下来，我们执行相应触发系统调用的测试用例，以重复触发消费并记录结果。我们利用来自Linux测试项目的1156个测试用例，并开发177个新的用例来覆盖更多的用例。我们还开发脚本来自动化上述步骤。</p>
<p>我们应用动态验证方法来测试所有1010个资源的消耗。</p>
<p>对于1010个检测到的资源，其中700个不在驱动程序文件夹中，而其他310个资源在驱动程序文件夹中，在700个非驱动资源中，有389个资源可以动态重复触发，真阳性率为55.6%。驱动程序文件夹中的资源需要特别处理，原因有两个。首先，驱动程序是特定于硬件的。如果没有相应的硬件，就无法动态触发驱动程序代码。我们的主要观察结果是，大多数硬件支持的驱动程序在<code>/dev</code>或<code>/sys/class</code>文件夹下公开特定的接口。基于这种观察，我们删除了硬件不支持的驱动程序中的92个资源。第二，LTP提供的测试用例可能不覆盖特定的驱动程序。</p>
<p>为了解决这个问题，我们修改LTP测试用例并为驱动程序开发新的测试用例。218个驱动资源中，有112个驱动资源可以重复触发，真阳性率为51.4%。</p>
<p>识别容器可耗尽抽象资源是一项非常具有挑战性的任务，因为它需要领域知识来触发抽象资源的耗尽，并且需要评估这些资源耗尽时的影响。在本文中，我们进行了初步分析。请注意，彻底的分析和风险评估需要来自Linux内核和容器社区的帮助。因此，我们计划开源我们的工具和检测到的抽象资源。我们认为这将有助于Linux内核和容器社区识别资源隔离的弱点，并开发健壮的资源遏制方案。</p>
</li>
</ul>
<h1 id="Abstract-Resource-Attacks-On-Cloud-Platforms"><a href="#Abstract-Resource-Attacks-On-Cloud-Platforms" class="headerlink" title="Abstract Resource Attacks On Cloud Platforms"></a>Abstract Resource Attacks On Cloud Platforms</h1><p>在本节中，我们将进一步评估针对公共云供应商容器环境的抽象资源攻击。我们首先介绍环境设置，然后给出结果。</p>
<h2 id="Environment-Setup-and-Ethical-Considerations"><a href="#Environment-Setup-and-Ethical-Considerations" class="headerlink" title="Environment Setup and Ethical Considerations"></a>Environment Setup and Ethical Considerations</h2><p>为了评估抽象资源攻击的有效性，我们在本地和云平台上建立了容器环境。</p>
<p>本地测试环境已在§3.1中给出。</p>
<ul>
<li><p>Ethical Considerations</p>
<p>对于云平台，我们打算尽可能减少我们的攻击对其他云用户的影响。因此，我们使用专用的虚拟服务器，如AWS EC2、Azure VM、谷歌GCE、阿里巴巴ECS来进行实验。此外，我们确保我们是该服务器的唯一用户。</p>
<p>此外，大多数容器用户利用容器编排系统来部署和管理容器。因此，我们选择了最流行的Kubernetes，并利用云供应商的Kubernetes服务在虚拟服务器上部署两个docker容器(即攻击者容器和受害者容器)。为了实现强隔离，我们为<code>attacker-container</code>和<code>victim-container</code>应用了不同的<code>Kubernetes namespace</code>。如§4.2所述，容器也受到每个用户配额的限制。为了在我们的实验中强制执行每个用户的配额，我们在不同的用户中运行攻<code>attacker-container</code>和<code>victim-container</code>，并强制执行每个用户的配额。我们还在§6中讨论了<code>PAM</code>可以部署的限制。</p>
</li>
<li><p>Amazon AWS</p>
<p>对于容器服务，我们使用Elastic Kubernetes Service (EKS)在EC2实例上部署两个容器实例。EC2实例包含4个cpu、8gb内存和20gb SSD磁盘。在容器部署期间，我们惊奇地发现“Amazon EKS默认pod安全策略”使用了EKS。特权为默认pod安全策略。请注意，此策略允许容器作为特权用户运行，还允许特权升级以及主机网络访问。</p>
<p>为了更好地演示我们提出的攻击的有效性，我们从本地测试环境采用了更强的安全策略，从EKS容器运行在非根用户中，删除所有特权，启用所有<code>namespace</code>和<code>cgroup</code>，并使用<code>docker seccomp</code>配置文件来阻止50多个敏感系统调用，包括<code>ptrace</code>、<code>pivot_root</code>等。我们对<code>attacker-container</code>和<code>victim-container</code>应用相同的安全策略。</p>
</li>
<li><p>MS Azure<br>我们使用Azure Kubernetes服务（AKS），在Azure虚拟机上部署了两个容器实例。Azure虚拟机包含2个CPU、8GB内存和120GB磁盘。为了提高部署的容器的安全性，Azure在AKS中提供了pod安全策略的最佳实践，通过在<code>yaml</code>文件中设置<code>runAsUser:1000</code>，以非root用户的身份运行容器，并通过设置<code>allowPrivilegeEscalation: false</code>，拒绝特权升级。然而，它仍然增加了两种能力，即<code>CAP_NET_ADMIN</code>和<code>CAP_SYS_TIME</code>，并且没有强制执行<code>seccomp</code>。与AWS的设置一样，我们对AKS上的容器采取了更严格的安全策略。除了最佳实践建议（即非root用户和不允许特权升级），我们以非root用户运行AKS容器，放弃所有功能，启用所有的<code>namespace</code>和<code>cgroup</code>，并使用<code>docker seccomp</code>配置文件。来阻止50多个敏感的系统调用。我们对<code>attacker-container</code>和<code>victim-container</code>应用相同的安全策略。</p>
</li>
<li><p>Google Cloud</p>
<p>对于容器服务，我们选择Kubernetes并使用谷歌Kubernetes Engine (GKE)在谷歌计算引擎实例上部署两个容器实例。我们使用的谷歌计算引擎(GCE)实例包含4个cpu、16gb内存和100gb SSD。更具体地说，我们应用一个GCE实例，并基于该GCE实例上的常规运行时部署两个容器(即<code>attacker-container</code>和<code>victim-container</code>)。</p>
<p>对于容器部署，我们遵循GKS容器设置向导。谷歌Cloud提供了操作容器的最佳实践，建议避免使用特权容器。因此，在yaml配置文件的securityContext中，我们不允许特权升级，以非特权用户运行容器，并删除所有功能。GKS设置向导默认启用6个<code>namespace</code>和13个<code>cgroup</code>。此外，我们应用docker默认的<code>seccomp</code>配置文件来过滤敏感的系统调用。</p>
<p>此外，GKE还提供了谷歌的安全容器运行时<code>- gvisor</code>，它利用名为<code>Sentry</code>的用户空间内核为来自应用程序的系统调用提供服务。哨兵调用大约50个主机系统调用，根据需要提供服务。<code>gVisor</code>被认为是容器的安全沙盒运行时。对于基于<code>gVisor</code>的容器部署，其所有安全设置(包括非特权用户、删除功能)都与GKE docker运行时设置相同。</p>
</li>
<li><p>Alibaba Cloud</p>
<p>在容器服务方面，阿里云提供了弹性容器实例、Kubernetes容器服务、容器注册和阿里云服务Mesh。我们使用Kubernetes的容器服务在一个弹性计算服务(ECS)实例上部署两个容器实例。ECS实例包含4个cpu、16gb内存和120gb SSD盘。对于容器安全性，我们遵循容器服务部署的官方指南，该指南通过将<code>runAsUser</code>设置为1000来使用非根用户运行容器。但是，它并不禁止特权升级，也不强制执行<code>seccomp</code>和<code>SELinux</code>。</p>
<p>我们采取了与以往相同的更强有力的安全政策。我们在非根用户中运行容器，删除所有功能，启用所有<code>namespace</code>和<code>cgroup</code>，并使用<code>docker seccomp</code>配置文件来阻止敏感的系统调用。我们对<code>attacker-container</code>和<code>victim-container</code>应用相同的安全策略。</p>
</li>
</ul>
<h2 id="Selection-of-Abstract-Resources"><a href="#Selection-of-Abstract-Resources" class="headerlink" title="Selection of Abstract Resources"></a>Selection of Abstract Resources</h2><p>为了进行攻击，我们需要选择有意义的抽象资源。为了演示抽象资源攻击的有效性，我们希望选择影响操作系统服务各个方面的抽象资源，包括进程管理、内存管理、存储管理和IO管理。</p>
<p>因此，我们首先根据它们的声明位置将所有标识的资源分为这四类，即用于进程、内存、存储和IO管理的资源。然后，我们根据我们的领域知识从每个类别中选择至少一个资源，即我们知道资源耗尽的影响。</p>
<p>最终，我们选择了涵盖所有四个方面的7个抽象资源，。资源名称列在表的第二列中。在所选的抽象资源中，基于访问分析识别出<code>PID idr</code>、<code>dirty ratio</code>、<code>inode</code>、<code>netns_ct-&gt;count</code>、<code>random entropy</code>个，基于配置分析识别出<code>nr_files</code>、<code>pty_count</code> 2个，如表第三列所示。我们还在表的第四列中列出了资源消耗函数，在表的最后一列中列出了用于触发攻击的系统调用。</p>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/Resource.png"></p>
<h2 id="Attacking-Results-on-Cloud-Platforms"><a href="#Attacking-Results-on-Cloud-Platforms" class="headerlink" title="Attacking Results on Cloud Platforms"></a>Attacking Results on Cloud Platforms</h2><p>如前一节所述，我们为我们提出的攻击设置了5个测试环境，包括本地、AWS、Azure、谷歌云和阿里云。对于每个测试环境，我们设置了两个具有严格安全策略的容器，作为<code>attacker-container</code>和<code>victim-container</code>。<code>attacker-container</code>针对某些抽象资源发起攻击。我们使用上述7个选定的抽象资源来发起攻击。在<code>victim-container</code>和主机上都运行一个基准测试，以测量它们在抽象资源攻击下的性能下降。结果如表所示。</p>
<ul>
<li><p><code>PID idr</code>攻击。<code>PID idr</code>攻击及其根源已在§3.2.1中详细介绍。针对厂商的PID攻击，所有受害容器，甚至在Local、AWS、Azure和谷歌测试环境中的主机都不能<code>fork</code>新的进程。<code>victim-container</code>甚至会被驱逐。阿里云不容易受到PID攻击。</p>
</li>
<li><p><code>dirty ratio</code>攻击。<code>dirty ratio</code>攻击已经在§3.3.1中讨论过。如果没有攻击，则认为IO性能为100%。在<code>dirty ratio</code>攻击下，受害容器在AWS、Azure和阿里云上的IO性能分别下降到6.3%、1.2%和6.7%。更糟糕的是，主机也容易受到这种攻击，其IO性能在AWS上下降到8.3%，在阿里云上下降到8.6%。这里MS Azure不提供对主机的任何访问，因此我们无法获得Azure主机IO性能。谷歌云不容易受到<code>dirty ratio</code>攻击。</p>
</li>
<li><p><code>inode</code>攻击。在<code>inode</code>攻击中，受害者容器不断分配<code>inode</code>结构。不幸的是，<code>mount namespace</code>没有隔离<code>inode</code>。Linux内核都不提供任何与<code>inode</code>相关的<code>cgroup</code>。结果，该分区上的所有<code>inode</code>都被耗尽。所有消耗<code>inode</code>的操作都会失败，包括来自<code>victim-container</code>或主机的操作。在我们的实验中，阿里云很容易受到<code>inode</code>攻击。<code>victim-container</code>甚至会被驱逐。此外，主机也不能创建任何新文件。</p>
</li>
<li><p><code>nr_files</code>攻击。<code>nr_files</code>攻击已经在§3.4.1中讨论过。<code>nr_files</code>由所有容器全局共享。没有<code>namespace</code>或<code>cgroup</code>来限制它的使用。当<code>nr_files</code>配额耗尽时，各种操作都会失败，包括打开文件、执行新程序、创建管道、创建套接字和创建计时器，因为Linux中的所有东西都是文件。我们的实验表明，所有排名前4的供应商都容易受到<code>nr_files</code>攻击。</p>
</li>
<li><p><code>pty_count</code>攻击。<code>pty_count</code>攻击已经在§3.5.1中讨论过，它会耗尽所有开放的伪终端配额。这将导致所有需要打开新的伪终端的操作失败，如SSH连接等。不幸的是，所有前4个供应商都容易受到<code>pty_count</code>攻击。</p>
</li>
<li><p><code>netns_ct-&gt;count</code>攻击。Linux内核中的<code>Netfilter</code>提供了连接跟踪功能，可以跟踪所有的逻辑网络连接。而总连接数是有限制的，由<code>struct netns_ct-&gt;count</code>来计数。主机和容器都需要维护连接。尽管容器位于不同的<code>net namespace</code>中，但它们的所有连接都需要使用<code>init_net.ct</code>。主机的<code>init net namespace</code>的计数。因此，如果在短时间内产生大量的TCP连接，就会消耗掉<code>init_net.ct</code>的所有配额。计数，导致<code>Netfilter</code>故障。在我们的实验中，<code>attacker-container</code>可以耗尽<code>init_net.ct</code>。数秒内计数，导致随机丢包。同样，前4个供应商的所有环境都容易受到结构体<code>netns_ct-&gt;count</code>攻击。</p>
</li>
<li><p><code>random entropy</code>攻击。在Linux内核中，每次读取<code>/dev/random</code>都会消耗<code>random entropy</code>。每当<code>random entropy</code>下降到阈值以下时，Linux内核就会阻塞对<code>/dev/random</code>的读取操作，并等待<code>entropy</code>增加。</p>
<p>由于没有<code>namespace</code>或<code>cgroup</code>来隔离<code>random entropy</code>，<code>attacker-container</code>很容易通过反复读取<code>/dev/random</code>来消耗所有的<code>random entropy</code>，从而导致良性的读取阻塞。最新的Linux内核v5.10通过将<code>/dev/random</code>读重定向到<code>/dev/urandom</code>修复了这个问题。然而，Azure和阿里云都容易受到这种攻击。</p>
</li>
</ul>
<p><img src="/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/result.png"></p>
<h2 id="Attacking-gVisor"><a href="#Attacking-gVisor" class="headerlink" title="Attacking gVisor"></a>Attacking gVisor</h2><p>我们还对gVisor进行了7种资源攻击。为了建立gVisor环境，我们在谷歌Kubernetes Engine (GKE)中选择runsc而不是runc作为容器运行时，如§5.1所述。其中<code>nr_files</code>攻击和<code>netns_ct-&gt;count</code>攻击两种攻击在<code>gVisor</code>环境下仍然有效。在接下来的文章中，我们将分析为什么这两种攻击可以在<code>gVisor</code>上工作。</p>
<p>对于<code>nr_files</code>, gVisor使用<code>Sentry</code>为系统调用服务，而Gofer为<code>Sentry</code>处理不同类型的IO。<code>Sentry</code>拦截来自容器的<code>open syscall</code>并将请求发送给Gofer。在另一边，Gofer通过调用主机操作系统的<code>openat</code>系统调用来处理该请求。最终，主机操作系统上的<code>openat</code>系统调用触发了<code>alloc_empty_file</code>函数，它消耗了<code>nr_files</code>。通过这种方式，gVisor的攻击者能够耗尽主机的nr_files。<br>对于<code>netns_ct-&gt;count</code>，<code>Sentry</code>拦截连接系统调用，并使用自己的网络堆栈将数据包转发到主机中创建的veth-peer网卡。<code>vth -peer</code>连接到主机中的虚拟网桥。当网络帧通过虚拟网桥转发时，主机上的netfilter被触发调用<code>nf_conntrack_alloc</code>函数，该函数消耗<code>netns_ct-&gt;count</code>。因此，gVisor中的攻击者仍然可以耗尽主机的<code>netns_ct-&gt;count</code>。</p>
<h2 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h2><p>对于自部署的共享内核容器环境，其中两个易受6次攻击，一个易受5攻击，另一个易受4攻击。令人惊讶的是，gVisor运行时也容易受到两种攻击——<code>nr_files</code>攻击和<code>netns_ct-&gt;count</code>攻击。我们已经向所有四个供应商报告了这些攻击。他们都确认了问题存在于他们的共享内核容器环境中。</p>
<p>尽管顶级供应商使用虚拟机来隔离不同租户的容器，但由于几个原因，抽象资源攻击仍然是可行的。首先，正如在Linux、FreeBSD和Fuchsia上所演示的，抽象资源攻击是操作系统级虚拟化所固有的，因此是一种广泛的攻击类型。其次，没有经验的用户可能不了解共享内核的风险，可能会使用容器进行sand-boxing。我们的论文将有助于提高对风险的认识。第三，即使在同一个租户中，竞争的团队也可能通过利用抽象资源来攻击对方。因此，监控和减轻此类攻击仍然是必要的。</p>
<h1 id="Mitigation-Discussions"><a href="#Mitigation-Discussions" class="headerlink" title="Mitigation Discussions"></a>Mitigation Discussions</h1><p>在本文中，我们揭示了除了物理资源，容器还共享底层运行内核的抽象资源。这些抽象资源很容易被攻击，后果很严重。在下面，我们给出了多种策略来降低抽象资源带来的风险。</p>
<ul>
<li><p>Using PAM for per-user quota restrictions</p>
<p>正如正如第4.2节中提到的，Linux内核提供了允许用户加载用户定制的PAM的接口。PAM能够限制18种资源，其中5种为抽象资源，包括<code>maxlogin/maxsyslogins</code>、<code>nofile</code>、<code>nproc</code>和<code>sigpending</code>。从我们与云计算供应商的沟通中，我们不知道有任何云计算供应商采用PAM。因此，我们建议对某些抽象资源的限制使用PAM。§4.2节提到的，Linux内核提供了允许用户加载用户定制的PAM的接口。<code>PAM</code>能够限制18种资源，其中5种为抽象资源，包括<code>maxlogin/maxsyslogins</code>、<code>nofile</code>、<code>nproc</code>和<code>sigpending</code>。从我们与云计算供应商的沟通中，我们不知道有任何云计算供应商采用PAM。因此，我们建议对某些抽象资源的限制使用PAM。</p>
</li>
<li><p>Using VM for strong isolation</p>
<p>对于安全关键型应用程序，我们建议不要使用多租户容器环境。更强的隔离方案，例如基于虚拟机的虚拟化，是更可取的。</p>
</li>
<li><p>Using Monitoring Tools</p>
<p>我们建议使用Kubernetes集群的监控工具，如Falco，来监控容器的资源消耗。对于敏感的抽象资源(如<code>nr_files</code>和<code>inode</code>)，用户应该自定义自己的规则来监视系统中特定的资源消耗。</p>
</li>
<li><p>Improving current isolation design</p>
<p>对于现有的<code>namespace</code>，如<code>PID namespace</code>，由于映射到根<code>namespace</code>的设计，无法防御资源耗尽攻击。如§3.2.2所述，Linux内核在根<code>PID namespace</code>中为在其他<code>PID namespace</code>中分配的任何idr分配一个额外的idr。因此，根PID namespace仍然是全局共享的。攻击者仍然可以很容易地耗尽根<code>PID namespace</code>中的PID，从而导致DoS攻击。出于类似的原因，即使被<code>NET namespace</code>隔离，<code>nf-conntrack</code> 数 <code>netns_ct-&gt;count</code>也可能被攻击。因此，Linux社区需要重新审视<code>namespace</code>的设计，消除<code>namespace</code>依赖关系以提高隔离性。</p>
</li>
<li><p>New kernel containment mechanisms</p>
<p>Linux内核社区和容器社区需要投入更多精力来保护抽象资源。实际上，我们已经向Docker安全团队报告了这个问题。反馈是“Linux容器只能使用可用的内核隔离机制。如果没有内核机制来控制限制，容器就不能做任何事情来限制它”。因此，我们首先需要对所有容器共享的抽象资源进行彻底的分析，以便我们能够理解，更重要的是，清除它们的数据依赖关系。这需要全面的内核领域知识和大量的内核代码更改。而且，Linux内核最初并不是为支持操作系统级虚拟化而设计的。它的资源隔离和遏制是不完整的。因此，需要新的<code>namespace</code>和<code>cgroup</code>。</p>
</li>
<li><p>More restrictive system call blocking</p>
<p>从容器方面来看，目前，即使执行了<code>seccomp</code>，容器中的应用程序仍然可以访问大约250个系统调用。在我们了解这些系统调用的数据依赖性之前，建议执行更严格的<code>seccomp</code>配置文件来阻止更多不必要的系统调用。容器用户可以使用技术来获得更严格的<code>seccomp</code>配置文件，以减少潜在的抽象资源攻击的可能性</p>
</li>
</ul>
<h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><h2 id="Virtualization-Techniques"><a href="#Virtualization-Techniques" class="headerlink" title="Virtualization Techniques"></a>Virtualization Techniques</h2><p>在云环境中有两种主流的虚拟化技术，基于vm的虚拟化和OS-level虚拟化。与基于vm的虚拟化相比，OS-level虚拟化越来越流行，因为它可以通过轻量级虚拟化实现完整的应用程序功能。为了充分了解性能优势，研究人员进行了一系列研究。Felter等人表明，通过使用一组涵盖多个资源的基准测试，Docker在所有情况下都可以获得比KVM更好的性能。Joy等人在性能和可伸缩性方面对Linux容器和虚拟机进行了比较。Zhang等人的研究表明，容器在大数据环境中具有比虚拟机更好的性能。</p>
<p>所有这些工作都表明，操作系统级虚拟化比传统的基于虚拟机的虚拟化具有更好的性能。然而，他们都没有注意到底层内核抽象资源的潜在影响。本文揭示了抽象资源引入的新的攻击面。</p>
<h2 id="Resource-Isolation"><a href="#Resource-Isolation" class="headerlink" title="Resource Isolation"></a>Resource Isolation</h2><p>Linux使用功能来禁止没有特定功能的进程访问相应类型的资源实例。</p>
<p>研究人员提出了基于Linux功能的方法，如Wedge ， Capsicum和ACES。这些工作执行更细粒度的能力控制，以减轻内存损坏攻击。然而，他们不能防御我们的DoS攻击，耗尽可访问的共享资源。</p>
<p>内存地址空间隔离是一种典型的资源空间隔离方案，避免内存地址资源耗尽。Linux命名空间隔离了§2.1中列出的8种资源。这些方案只能隔离有限类型的资源。资源容器建议扩展单片内核，隔离系统资源，在线程级对资源进行划分，类似于控制组。由于性能开销很大，使用资源容器来保护所有抽象资源是不切实际的。EdgeOS为边缘云部署了强隔离的操作系统。然而，采用没有硬件支持的微内核会比单片内核引入更多的开销。Faasm使用软件故障隔离(SFI)进行内存隔离，而在无服务器计算中使用名称空间隔离网络资源空间。然而，大多数共享资源仍然暴露在DoS攻击的威胁之下。</p>
<h2 id="Container-Security"><a href="#Container-Security" class="headerlink" title="Container Security"></a>Container Security</h2><p>除了资源隔离之外，还有对容器安全性的研究。Gao等人发现，可以利用&#x2F;proc或&#x2F;sys的信息泄露，发动电源攻击。而同一研究小组还进行了5次攻击，产生带外工作负载，以打破Linux控制组的资源约束。但它们主要针对信息泄露问题或攻击CPU、IO等物理资源，而不是抽象资源。</p>
<p>Lin等人表明容器不能隔离内核漏洞。另一项工作使用静态分析来分析Docker的代码，以找到漏洞和修补代码之间的差异。然而，这些工作主要针对现有的漏洞和利用。相反，我们的工作引入了针对共享抽象资源的新攻击。</p>
<p>此外，还有加固集装箱的工作。Lei等人提出了一种名为SPEAKER的容器安全机制，以减少应用程序在容器中可用的系统调用。Sun等人开发了为每个容器提供安全策略隔离的安全namespace。另一项工作使用Intel SGX保护容器，它提供了一个低性能开销的小型可信计算基础。Brady等人实现了容器图像的安全评估系统。然而，所有这些作品中的容器仍然依赖于内核提供各种服务，因此仍然容易受到抽象资源攻击。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>在本文中，我们揭示了共享内核在操作系统级虚拟化中引入的一种新的攻击面。这些容器直接或间接地共享成千上万的抽象资源，这些资源很容易被耗尽，从而导致对其他容器的DoS攻击。</p>
<p>为了显示限制抽象资源的重要性，我们进行了抽象资源攻击，针对操作系统内核的不同方面的抽象资源。结果表明，攻击抽象资源具有很强的实用性和关键性。</p>
<p>抽象资源本身就难以包含。为了了解这些攻击面，我们首先进行了一次系统分析，以识别Linux内核中易受攻击的抽象资源。我们的工具成功检测了501个动态触发的抽象资源，从中选取了7个，并在排名前4的云供应商的自部署共享内核容器环境中进行了攻击实验。结果表明，所有环境都容易受到我们的攻击。为了降低风险，我们为容器用户和开发人员提供了一些建议。</p>
<h1 id="My"><a href="#My" class="headerlink" title="My"></a>My</h1><h2 id="硬件虚拟化和OS-level虚拟化"><a href="#硬件虚拟化和OS-level虚拟化" class="headerlink" title="硬件虚拟化和OS-level虚拟化"></a>硬件虚拟化和OS-level虚拟化</h2><p>虚拟化技术通常可以分为两大类：操作系统级虚拟化（OS-level virtualization）和硬件虚拟化（hardware virtualization）。这两者的主要区别在于虚拟化层的位置以及资源分配方式。</p>
<h3 id="操作系统级虚拟化（OS-level-virtualization"><a href="#操作系统级虚拟化（OS-level-virtualization" class="headerlink" title="操作系统级虚拟化（OS-level virtualization)"></a>操作系统级虚拟化（OS-level virtualization)</h3><p>操作系统级虚拟化是一种轻量级虚拟化技术，它允许在单个操作系统内运行多个独立的、隔离的应用程序或服务。在这种方式下，所有虚拟实例共享相同的操作系统内核，但每个实例拥有自己的文件系统、进程、网络等资源。</p>
<p>详细说明：</p>
<ol>
<li>资源分配：操作系统级虚拟化使用容器（Container）技术将系统资源（如CPU、内存、磁盘、网络等）划分给各个虚拟实例。容器之间相互隔离，互不干扰。</li>
<li>性能：操作系统级虚拟化具有较低的性能开销，因为所有虚拟实例共享相同的操作系统内核，避免了多个操作系统之间的资源竞争。</li>
<li>灵活性：操作系统级虚拟化支持的操作系统类型受限于宿主机操作系统，因此在跨平台方面的灵活性较差。</li>
</ol>
<p>实现方式：</p>
<ol>
<li>Linux：LXC（Linux Containers）、Docker</li>
<li>FreeBSD：Jails</li>
<li>Solaris：Zones&#x2F;Containers</li>
</ol>
<h3 id="硬件虚拟化（Hardware-virtualization）"><a href="#硬件虚拟化（Hardware-virtualization）" class="headerlink" title="硬件虚拟化（Hardware virtualization）"></a>硬件虚拟化（Hardware virtualization）</h3><p>硬件虚拟化是一种全面的虚拟化技术，它允许在单个物理机器上运行多个独立的、完全隔离的操作系统实例。在这种方式下，虚拟化层位于操作系统和硬件之间，为每个虚拟机提供一个虚拟硬件环境。</p>
<p>详细说明：</p>
<ol>
<li>资源分配：硬件虚拟化使用虚拟机（Virtual Machine）技术将系统资源（如CPU、内存、磁盘、网络等）划分给各个虚拟实例。虚拟机之间相互隔离，互不干扰。</li>
<li>性能：硬件虚拟化具有较高的性能开销，因为每个虚拟机需要运行独立的操作系统内核，导致资源竞争和虚拟化开销。</li>
<li>灵活性：硬件虚拟化支持运行不同类型的操作系统，具有较强的跨平台灵活性。</li>
</ol>
<p>实现方式：</p>
<ol>
<li>基于软件的虚拟化：VMware Workstation、VirtualBox</li>
<li>基于硬件的虚拟化：Intel VT-x、AMD-V</li>
<li>虚拟化管理器（Hypervisor）：VMware ESXi、KVM（Kernel-based Virtual Machine）、Microsoft Hyper-V、Xen</li>
</ol>
<p>总结起来，操作系统级虚拟化和硬件虚拟化的主要区别在于虚拟化层的位置以及资源分配方式。操作系统级虚拟化通过共享相同的操作系统内核实现较低的性能开销，但跨平台灵活性较差；硬件虚拟化允许运行多个独立的操作系统实例，具有较强的跨平台灵活性，但性能开销较高。</p>
<h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><p>LLVM（Low Level Virtual Machine）是一个编译器基础设施项目，它提供了一系列模块化和可重用的编译器组件和工具链。LLVM的设计目标是为各种编程语言提供一个通用的中间表示（Intermediate Representation，IR），以及一套用于优化、分析和生成机器代码的编译器后端。LLVM项目包括一些子项目，如Clang（C、C++和Objective-C的编译器前端）和LLDB（一个调试器）。</p>
<p>LLVM的核心组件包括：</p>
<ol>
<li><p><strong>LLVM IR</strong>：LLVM中间表示是一种低级别、类型化、平台无关的编程语言，用于表示程序的结构和行为。LLVM IR既可以表示为人类可读的文本，也可以表示为二进制格式。</p>
</li>
<li><p><strong>编译器前端</strong>：编译器前端将源代码（如C、C++、Rust等）解析成LLVM IR。Clang是LLVM最著名的编译器前端，用于处理C、C++和Objective-C语言。其他语言也有针对LLVM的编译器前端。</p>
</li>
<li><p><strong>优化器</strong>：LLVM提供了一系列通用的代码优化和转换通道，这些通道可以在LLVM IR上进行操作，例如：常量折叠、死代码消除、循环不变式代码移动等。优化器可以根据需要配置和组合，以生成高度优化的代码。</p>
</li>
<li><p><strong>编译器后端</strong>：编译器后端将优化后的LLVM IR转换为特定架构的机器代码。LLVM支持多种目标平台，包括x86、ARM、MIPS、WebAssembly等。编译器后端还负责处理调用约定、寄存器分配和指令调度等底层细节。</p>
</li>
</ol>
<p>LLVM的优势在于其模块化、可扩展和可重用的设计。这使得LLVM可以很容易地支持新的编程语言和硬件架构，而不需要重新实现整个编译器。这也使得LLVM成为了许多编程语言（如Rust、Swift和Julia）和平台（如WebAssembly、GPUs和FPGAs）的编译器基础设施的首选。</p>
<h2 id="Linux-cgroup的组织和结构"><a href="#Linux-cgroup的组织和结构" class="headerlink" title="Linux cgroup的组织和结构"></a>Linux cgroup的组织和结构</h2><p>cgroup 是一种用于限制和控制进程资源使用的实用工具：</p>
<ol>
<li><p><strong>限制资源</strong>：Linux cgroup 的主要目的是限制进程使用的资源，如 CPU 使用率、内存、磁盘 I&#x2F;O 等。这有助于确保系统上的各个进程不会过度消耗资源，从而影响其他进程或整个系统的性能。</p>
</li>
<li><p><strong>控制组内进程</strong>：cgroup 负责管理和控制组内所有进程的资源使用。这意味着你可以将一组进程组织在一个 cgroup 中，并对整个组施加资源限制，而不是单独设置每个进程的限制。</p>
</li>
<li><p><strong>树状结构</strong>：cgroup 的组织方式是树状结构，其中每个节点（cgroup）可以包含若干子节点（子 cgroup）。这种结构允许你对资源使用进行分层管理，通过在不同层次施加不同的限制，可以更灵活地控制进程资源使用。</p>
</li>
<li><p><strong>子节点和父节点的资源关系</strong>：在 cgroup 树状结构中，子 cgroup 的资源限制包括其父 cgroup 的资源限制。这意味着子 cgroup 不能单独设置超出其父 cgroup 限制的资源使用。这有助于维护整体资源限制的一致性，并确保子 cgroup 不会因过度消耗资源而影响其父 cgroup 或整个系统。</p>
</li>
<li><p><strong>递归强制执行</strong>：cgroup 树结构中的资源限制是递归强制执行的。这意味着一个 cgroup 的资源使用限制将受到其所有祖先（父、祖父等）cgroup 限制的约束。这可以确保在整个 cgroup 树结构中，资源限制得到恰当的执行和遵守。</p>
</li>
</ol>
<p>总之，Linux cgroup 是一种用于限制和管理进程资源使用的实用工具。它采用树状结构来组织进程，允许分层管理资源，并通过递归强制执行来确保资源限制得到遵守。</p>
<h2 id="fork炸弹和idr"><a href="#fork炸弹和idr" class="headerlink" title="fork炸弹和idr"></a>fork炸弹和idr</h2><h3 id="fork炸弹"><a href="#fork炸弹" class="headerlink" title="fork炸弹"></a>fork炸弹</h3><p>Fork 炸弹是一种拒绝服务攻击（DoS攻击），其目的是通过创建大量子进程耗尽系统资源，从而导致系统崩溃或无法响应。攻击者可以编写一个简单的程序，使其反复调用 fork() 系统调用，每次调用都会创建一个新的子进程。这些子进程可能会继续创建更多子进程，从而导致进程数量迅速增加。这种攻击方法也被称为“逻辑炸弹”或“蠕虫炸弹”。</p>
<p>在 Linux 系统中，fork() 系统调用用于创建一个新进程，它是当前进程的一个副本。新进程（子进程）继承了父进程的资源（如打开的文件描述符、内存映射等），并从父进程的当前执行点开始执行。子进程拥有自己的独立地址空间和资源，并分配一个唯一的进程 ID。</p>
<h3 id="idr"><a href="#idr" class="headerlink" title="idr"></a>idr</h3><p>在 Linux 内核中，<code>IDR（ID Radix Tree）</code>是一种用于管理和查找整数类型对象标识符（如进程 ID、文件描述符等）的数据结构。<code>IDR</code> 是一种基于基数树（<code>radix tree</code>）的高效数据结构，可以快速查找、添加和删除 ID。<code>IDR</code> 用于分配唯一的 ID 给内核对象，如进程、线程、文件等，以便在内核中进行跟踪和管理。</p>
<p><code>fork</code> 炸弹会通过创建大量子进程来耗尽所有可用的进程 ID，从而导致系统无法创建新的进程。这可能会导致系统性能下降、响应缓慢甚至崩溃。为了防止这类攻击，系统管理员可以通过设置进程数资源限制（如使用 <code>ulimit</code> 命令）或在容器中使用<code>cgroup</code> 限制进程数来保护系统。</p>
<h3 id="clone系统调用"><a href="#clone系统调用" class="headerlink" title="clone系统调用"></a>clone系统调用</h3><p><code>clone()</code> 系统调用是 Linux 中用于创建进程和线程的一个底层函数。与 <code>fork()</code> 相比，<code>clone()</code> 提供了更多的选项和灵活性，因为它允许程序员指定哪些资源应该在父进程和新创建的子进程之间共享。这使得 <code>clone()</code> 适用于创建轻量级的线程以及新的独立进程。</p>
<p><code>clone()</code> 系统调用的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg, ...)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>fn</code>：一个函数指针，指向子进程或线程开始执行的函数。子进程或线程运行结束后，这个函数应该返回一个整数值，用于表示退出状态。</li>
<li><code>child_stack</code>：指向子进程或线程的栈空间的指针。子进程或线程在执行过程中将使用这个栈空间。</li>
<li><code>flags</code>：用于指定子进程或线程的行为和资源共享的位掩码。这些标志包括 <code>CLONE_VM</code>（共享内存空间）、<code>CLONE_FS</code>（共享文件系统信息）、<code>CLONE_FILES</code>（共享文件描述符表）等。通过组合这些标志，程序员可以精细控制子进程或线程的行为。</li>
<li><code>arg</code>：传递给 <code>fn</code> 函数的参数。通常，它是一个指向某种结构或数据的指针。</li>
</ul>
<p><code>clone()</code> 系统调用的返回值在父进程和子进程中有所不同。在父进程中，<code>clone()</code> 返回新创建的子进程或线程的进程 ID（PID）。在子进程中，<code>clone()</code> 返回 0。如果创建失败，<code>clone()</code> 返回 -1，并设置相应的错误码。</p>
<p><code>clone()</code> 系统调用的使用相对复杂，通常不直接在应用程序中使用。在实践中，程序员更倾向于使用更高级别的库函数，如 <code>pthread_create()</code>（用于创建线程）或 <code>fork()</code>（用于创建进程）。这些库函数在内部使用 <code>clone()</code> 系统调用来完成进程和线程的创建。</p>
<h2 id="脏内存"><a href="#脏内存" class="headerlink" title="脏内存"></a>脏内存</h2><p>脏内存（Dirty Memory）是计算机内存管理中的一个概念，指的是已经被修改过但尚未写回到持久存储（如硬盘）的内存数据。在操作系统和应用程序中，内存（RAM）被用作缓存，以加速对数据的访问。与磁盘相比，内存访问速度要快得多，因此将数据缓存在内存中可以提高系统性能。</p>
<p>当一个程序或操作系统修改了内存中的数据，与磁盘上的原始数据不再一致时，这部分内存就被称为 “脏内存”。脏内存中的数据最终需要写回到磁盘，以确保数据的一致性和持久性。以下是脏内存产生的一些常见场景：</p>
<ol>
<li><p><strong>文件系统缓存</strong>：操作系统通常会将磁盘上的文件数据缓存在内存中，以提高文件访问速度。当一个程序修改了文件内容时，内存中的缓存数据变为脏内存。这些脏内存数据最终需要同步回磁盘，以确保文件在磁盘上的内容与内存中的内容一致。</p>
</li>
<li><p><strong>数据库缓存</strong>：数据库系统经常使用内存来缓存数据库表和索引中的数据。当数据库事务修改了表中的数据时，相应的内存缓存数据也会变为脏内存。这些脏内存数据需要在适当的时机写回到磁盘，以确保数据的一致性和持久性。</p>
</li>
<li><p><strong>虚拟内存管理</strong>：在虚拟内存管理中，操作系统通过将内存中的数据与磁盘上的交换空间（或页面文件）进行交换，来模拟更大的内存空间。当操作系统需要将内存中的数据交换出去时，如果这部分数据是脏内存，操作系统需要先将其写回到磁盘，然后才能将其交换出去。</p>
</li>
</ol>
<p>操作系统通常会使用一些策略来平衡脏内存的处理和系统性能。例如，Linux 内核通过监控脏内存占比（<code>dirty ratio</code>），在必要时触发后台线程将脏内存同步到磁盘。这样可以在提高系统性能的同时，确保数据的一致性和持久性。</p>
<h2 id="Linux处理脏内存"><a href="#Linux处理脏内存" class="headerlink" title="Linux处理脏内存"></a>Linux处理脏内存</h2><p> Linux 内核如何处理脏内存（即已修改但尚未同步到磁盘的内存）的过程。在 Linux 内核中，<code>dirty_throttle_control</code> 结构体用于管理和控制脏内存。结构体中的 <code>dirty</code> 字段表示整个内核空间的脏内存占比（<code>dirty ratio</code>）。</p>
<p>当 <code>dirty</code> 值过高时，内核会唤醒后台线程（例如 pdflush、flusher 或 kswapd），将脏内存同步到磁盘。这有助于确保数据的一致性和持久性，防止意外丢失。</p>
<p>然而，如果 <code>dirty</code> 值太高，内核会阻塞 <code>write_back</code> 操作。这意味着内核将所有写操作都转换为 <code>write_through</code> 操作，从而降低写性能。接下来，我们解释 <code>write_back</code> 和 <code>write_through</code> 之间的区别：</p>
<ul>
<li><p><strong>write_back</strong>：在 <code>write_back</code> 操作中，数据首先写入缓存（例如 CPU 缓存或文件系统缓存）。一旦数据被写入缓存，操作就被认为是完成的，即使数据尚未同步到磁盘。在后台，脏数据会在适当的时机被刷新到磁盘。<code>write_back</code> 的优势在于它可以提供较高的写性能，因为写操作可以立即返回，而不需要等待磁盘同步。</p>
</li>
<li><p><strong>write_through</strong>：在 <code>write_through</code> 操作中，数据同时写入缓存和磁盘。写操作在数据被写入磁盘之前不会被认为已完成。虽然这可以确保数据的一致性和持久性，但 <code>write_through</code> 的性能通常低于 <code>write_back</code>，因为它需要等待磁盘同步。</p>
</li>
</ul>
<p>总之，这段话描述了 Linux 内核如何在处理脏内存时在性能和数据一致性之间寻求平衡。当脏内存占比过高时，内核会采取措施降低写性能，以确保数据的一致性和持久性。</p>
<h2 id="Linux伪终端"><a href="#Linux伪终端" class="headerlink" title="Linux伪终端"></a>Linux伪终端</h2><p>Linux 内核使用 <code>/dev/ptmx</code>（主设备）和 <code>/dev/pts</code>（从设备）来实现伪终端（pseudo-terminal，简称 pty）。伪终端是一种特殊的终端设备，它不直接连接到物理设备，而是通过软件来模拟终端的输入和输出。伪终端广泛应用于远程登录（如 SSH）、终端模拟器（如 xterm）和其他需要模拟终端行为的场景。</p>
<p>以下是关于伪终端和 <code>/dev/ptmx</code> 以及 <code>/dev/pts</code> 的一些详细信息：</p>
<ol>
<li><p><strong>主设备（&#x2F;dev&#x2F;ptmx）</strong>：<code>/dev/ptmx</code> 是一个字符设备文件，用于创建伪终端的主设备。当一个进程（如 SSH 服务器或终端模拟器）需要创建一个新的伪终端时，它会打开 <code>/dev/ptmx</code> 设备文件。内核会为这个进程分配一个未使用的伪终端，并返回一个指向伪终端主设备的文件描述符。主设备用于管理伪终端，如接收从设备的输入数据、向从设备发送输出数据等。</p>
</li>
<li><p><strong>从设备（&#x2F;dev&#x2F;pts）</strong>：<code>/dev/pts</code> 是一个虚拟文件系统（通常挂载在 <code>/dev/pts</code> 目录下），用于存储伪终端的从设备。当一个伪终端被创建时，内核会在 <code>/dev/pts</code> 目录下为其从设备分配一个唯一的编号（如 <code>/dev/pts/0</code>、<code>/dev/pts/1</code> 等）。从设备用于模拟终端的输入和输出操作，如读取用户输入、显示文本输出等。通常情况下，从设备会被分配给另一个进程（如 shell），以便它可以与主设备进行通信。</p>
</li>
</ol>
<p>通过主设备和从设备的交互，伪终端实现了终端模拟器和其他类似程序与 shell、远程会话等之间的通信。这种抽象使得伪终端可以在不依赖于特定硬件的情况下，提供与物理终端类似的功能。</p>
<h2 id="FreeBSD和Fuchsia"><a href="#FreeBSD和Fuchsia" class="headerlink" title="FreeBSD和Fuchsia"></a>FreeBSD和Fuchsia</h2><p><code>FreeBSD</code>和<code>Fuchsia</code>是两种不同的操作系统。下面我们分别详细解释这两个操作系统。</p>
<h3 id="FreeBSD"><a href="#FreeBSD" class="headerlink" title="FreeBSD"></a>FreeBSD</h3><p>FreeBSD是一个类Unix的开源操作系统，它基于创建Unix的Berkeley Software Distribution（BSD）的源代码。FreeBSD成立于1993年，是BSD家族的一个成员，与NetBSD和OpenBSD等其他BSD操作系统并行发展。</p>
<p>FreeBSD的特点：</p>
<ol>
<li><strong>开源</strong>：FreeBSD的源代码可以免费获取和修改，遵循BSD许可证。这使得许多公司和开发者可以根据自己的需求定制操作系统。</li>
<li><strong>稳定性</strong>：FreeBSD以其稳定性和可靠性而闻名，使其成为服务器和关键基础设施的理想选择。</li>
<li><strong>性能</strong>：FreeBSD的性能优异，被广泛应用于高性能计算、网络服务和存储解决方案。</li>
<li><strong>安全性</strong>：FreeBSD提供了多种安全功能，如强制访问控制、安全级别和防火墙集成。</li>
<li><strong>可移植性</strong>：FreeBSD支持多种硬件平台，包括x86、x86-64、ARM、MIPS和PowerPC等。</li>
</ol>
<h3 id="Fuchsia"><a href="#Fuchsia" class="headerlink" title="Fuchsia"></a>Fuchsia</h3><p>Fuchsia是由谷歌（Google）开发的一个开源操作系统。与FreeBSD不同，Fuchsia不是基于Unix的，而是基于名为Zircon的新内核构建的。Fuchsia的开发始于2016年，目标是创建一个高度模块化、可扩展且可用于各种设备的操作系统。</p>
<p>Fuchsia的特点：</p>
<ol>
<li><strong>开源</strong>：Fuchsia是一个开源项目，遵循BSD、MIT、Apache等许可证。这意味着开发者和公司可以免费访问和修改它的源代码。</li>
<li><strong>Zircon内核</strong>：Fuchsia基于Zircon内核，这是一个微内核设计，使得操作系统更加轻量化和高度模块化。</li>
<li><strong>跨平台</strong>：Fuchsia旨在成为一个统一的操作系统，适用于各种设备，包括智能手机、平板电脑、个人电脑以及物联网（IoT）设备。</li>
<li><strong>模块化和可扩展性</strong>：Fuchsia的设计允许开发者轻松地添加和移除组件，使得操作系统能够根据需求进行定制化。</li>
<li><strong>Flutter框架</strong>：Fuchsia使用谷歌的Flutter框架构建用户界面，Flutter支持跨平台应用开发，可以使Fuchsia应用在其他操作系统上运行。</li>
</ol>
<p>总结，FreeBSD是一个基于Unix的稳定、高性能的开源操作系统，主要用于服务器和高性能计算。而Fuchsia是谷歌开发的一个全新的、基于Zircon内核的操作系统，旨在提供统一的、跨设备的体验。</p>
<h2 id="sysctl接口"><a href="#sysctl接口" class="headerlink" title="sysctl接口"></a>sysctl接口</h2><p>Linux内核通过<code>/proc/sys</code>下的<code>sysctl</code>接口为用户空间程序提供了一种方式来查询和修改内核参数。<code>sysctl</code>可以通过文件系统访问，同时也可以通过命令行工具<code>sysctl</code>进行操作。这些参数涉及到许多内核子系统和组件，包括内存管理、网络设置、安全设置等。</p>
<p>在<code>sysctl</code>配置中，有很多参数涉及到抽象资源限制。这些限制通常用于约束系统资源的分配，以防止资源耗尽或者保证系统的稳定运行。以下是一些常见的资源限制相关的<code>sysctl</code>参数：</p>
<ol>
<li><p><strong>vm.max_map_count</strong>：这个参数用于限制一个进程可以拥有的最大内存映射区域数量。这个限制有助于防止资源耗尽，尤其是在内存分配密集型的应用场景中。</p>
</li>
<li><p><strong>kernel.pid_max</strong>：这个参数用于设置系统中分配的最大进程ID。通过限制进程ID的数量，可以防止恶意软件或编程错误导致的大量僵尸进程占用系统资源。</p>
</li>
<li><p><strong>kernel.threads-max</strong>：这个参数用于限制系统中可以创建的最大线程数量。线程数量的限制可以防止过多的线程导致系统资源耗尽。</p>
</li>
<li><p><strong>net.core.somaxconn</strong>：这个参数用于设置系统中最大的已完成连接队列长度。这个限制可以保障在高并发网络服务场景下，系统能够在资源有限的情况下处理连接请求。</p>
</li>
<li><p><strong>fs.file-max</strong>：这个参数用于限制系统中可以打开的最大文件描述符数量。这个限制可以防止过多的文件描述符导致内核资源耗尽。</p>
</li>
</ol>
<p>这些<code>sysctl</code>参数通常可以在系统启动时通过配置文件设置，也可以在运行时通过命令行工具<code>sysctl</code>进行动态调整。这为管理员和开发者提供了一种灵活的方式来优化系统性能和资源分配。</p>
<h2 id="seccomp"><a href="#seccomp" class="headerlink" title="seccomp"></a>seccomp</h2><p>seccomp（secure computing mode，安全计算模式）是一种Linux内核安全特性，允许在用户空间的进程将其可用的系统调用（syscalls）限制为一个最小的集合。这样做可以降低进程被攻击者利用的风险，因为攻击者可以使用的系统调用减少了。seccomp在容器、沙箱和其他高度安全的环境中非常有用，因为它可以限制潜在的攻击面。</p>
<p>seccomp的工作原理是允许进程定义一个系统调用白名单，只有在这个白名单上的系统调用才能被进程执行。当进程试图执行不在白名单上的系统调用时，内核会阻止进程，并根据seccomp的配置执行相应的操作。这些操作可能包括：终止进程、向进程发送信号或者返回一个错误码。</p>
<p>为了使用seccomp，进程需要使用<code>prctl</code>系统调用启用seccomp模式。接着，进程可以通过<code>seccomp</code>系统调用定义一个过滤器（通常是一个BPF（Berkeley Packet Filter）程序），用于检查系统调用的编号，并根据白名单执行相应的操作。</p>
<p>以下是一个简单的seccomp示例，演示了如何使用seccomp限制一个进程只能调用<code>read</code>、<code>write</code>、<code>exit</code>和<code>rt_sigreturn</code>系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/audit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOW_SYSCALL(syscall_nr) \</span></span><br><span class="line"><span class="meta">    BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall_nr, 0, 1), \</span></span><br><span class="line"><span class="meta">    BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义seccomp过滤器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">        <span class="comment">// 检查架构是否正确</span></span><br><span class="line">        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, arch)),</span><br><span class="line">        BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, AUDIT_ARCH_X86_64, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载系统调用编号</span></span><br><span class="line">        BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(<span class="keyword">struct</span> seccomp_data, nr)),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许白名单上的系统调用</span></span><br><span class="line">        ALLOW_SYSCALL(__NR_read),</span><br><span class="line">        ALLOW_SYSCALL(__NR_write),</span><br><span class="line">        ALLOW_SYSCALL(__NR_exit),</span><br><span class="line">        ALLOW_SYSCALL(__NR_rt_sigreturn),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不允许的系统调用将导致进程被终止</span></span><br><span class="line">        BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义seccomp过滤器的元数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">        .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter) / <span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">        .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用seccomp模式</span></span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;prctl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此处执行您的程序逻辑</span></span><br><span class="line">    <span class="comment">// 如果尝试执行不在白名单上的系统调用，进程将被终止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这个示例使用的是seccomp的BPF过滤器，该过滤器提供了一种灵活的方式来控制系统调用。这种方法在容器和沙箱环境中非常有用，因为它可以针对特定应用程序的需求定制系统调用的限制。然而，编写BPF过滤器可能相对复杂，因此在实践中，许多开发者选择使用像libseccomp这样的库来简</p>
<p>化seccomp过滤器的创建和管理。</p>
<p>以下是使用libseccomp库的示例，实现与前面相同的功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个新的seccomp上下文</span></span><br><span class="line">    scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ctx) &#123;</span><br><span class="line">        perror(<span class="string">&quot;seccomp_init&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向过滤器中添加允许的系统调用</span></span><br><span class="line">    <span class="keyword">if</span> (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">0</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), <span class="number">0</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(<span class="built_in">exit</span>), <span class="number">0</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">        seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;seccomp_rule_add&quot;</span>);</span><br><span class="line">        seccomp_release(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将过滤器加载到内核中</span></span><br><span class="line">    <span class="keyword">if</span> (seccomp_load(ctx) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;seccomp_load&quot;</span>);</span><br><span class="line">        seccomp_release(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    seccomp_release(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此处执行您的程序逻辑</span></span><br><span class="line">    <span class="comment">// 如果尝试执行不在白名单上的系统调用，进程将被终止</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例使用了libseccomp库提供的API，使得创建和管理seccomp过滤器更加简单。只需通过<code>seccomp_init</code>初始化一个新的上下文，使用<code>seccomp_rule_add</code>添加允许的系统调用，然后使用<code>seccomp_load</code>将过滤器加载到内核中。最后，使用<code>seccomp_release</code>释放资源。</p>
<p>总之，seccomp是一种在Linux内核中实现安全计算模式的机制，它允许进程限制其可用的系统调用集，从而降低潜在的攻击面。在容器、沙盒和其他高度安全的环境中，seccomp非常有用。使用BPF过滤器或第三方库（如libseccomp）可以帮助开发者更轻松地创建和管理seccomp过滤器。</p>
<h2 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h2><h3 id="inode是什么"><a href="#inode是什么" class="headerlink" title="inode是什么"></a>inode是什么</h3><p>在文件系统中，<code>inode</code>（索引节点）是一种数据结构，用于存储有关文件和目录的元数据（如权限、大小、创建时间等），但不包括文件名和实际文件数据。每个文件或目录在文件系统中都有一个唯一的<code>inode</code>，它们通过<code>inode</code>号进行识别。不同的文件系统类型（如ext4、XFS、Btrfs等）可能会有不同的<code>inode</code>实现，但其基本概念是相同的。</p>
<p>以下是<code>inode</code>可能包含的一些元数据信息：</p>
<ul>
<li>文件类型（普通文件、目录、符号链接等）</li>
<li>文件大小</li>
<li>文件的权限（读、写、执行）</li>
<li>文件的所有者和所属组</li>
<li>创建、修改和访问时间戳</li>
<li>文件数据所在的磁盘块的位置</li>
</ul>
<p>现在让我们通过一个简单的Python脚本示例来展示如何获取文件的<code>inode</code>信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;example.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取文件的 inode 信息</span></span><br><span class="line">file_stat = os.stat(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印详细的 inode 信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File path: <span class="subst">&#123;file_path&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Inode number: <span class="subst">&#123;file_stat.st_ino&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File size: <span class="subst">&#123;file_stat.st_size&#125;</span> bytes&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File owner: <span class="subst">&#123;file_stat.st_uid&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File group: <span class="subst">&#123;file_stat.st_gid&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File permissions: <span class="subst">&#123;<span class="built_in">oct</span>(file_stat.st_mode)[-<span class="number">4</span>:]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File creation time: <span class="subst">&#123;file_stat.st_ctime&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File modification time: <span class="subst">&#123;file_stat.st_mtime&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;File access time: <span class="subst">&#123;file_stat.st_atime&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们首先通过<code>os.stat()</code>函数获取了指定文件路径的<code>inode</code>信息。然后，我们可以从返回的<code>os.stat_result</code>对象中获取各种<code>inode</code>元数据，如文件大小、所有者、权限等。</p>
<p>需要注意的是，此示例仅适用于类Unix系统（如Linux和macOS）。在Windows系统上，文件元数据的管理方式与<code>inode</code>有所不同。可以使用Python的<code>os</code>模块的其他函数，如<code>os.path.getsize()</code>和<code>os.path.getctime()</code>等，来获取Windows系统上的文件元数据。</p>
<h3 id="inode攻击"><a href="#inode攻击" class="headerlink" title="inode攻击"></a>inode攻击</h3><p><code>inode</code>攻击是一种资源耗尽攻击，其目标是耗尽文件系统中可用的<code>inode</code>。在这种攻击中，攻击者会在受害者容器中不断创建新文件或目录，从而分配大量的<code>inode</code>结构。由于Linux内核没有针对<code>inode</code>的cgroup隔离，这种攻击会影响整个分区，导致分区上的所有<code>inode</code>都被耗尽。</p>
<p>当<code>inode</code>耗尽时，任何试图创建新文件或目录的操作都会失败，无论这些操作来自受害者容器还是主机。在这种情况下，受害者容器可能会被驱逐，而主机也不能创建任何新文件。阿里云容器服务容易受到<code>inode</code>攻击的影响。</p>
<p>为了防御<code>inode</code>攻击，可以考虑以下方法：</p>
<ol>
<li><p><strong>限制容器的存储使用</strong>：为容器设置存储配额，以限制每个容器可以使用的存储空间。这可以防止攻击者耗尽整个文件系统的<code>inode</code>。</p>
</li>
<li><p><strong>监控<code>inode</code>使用情况</strong>：定期检查文件系统的<code>inode</code>使用情况，以便在<code>inode</code>快速耗尽时发现潜在的攻击。</p>
</li>
<li><p><strong>设置警报和自动响应</strong>：在<code>inode</code>使用达到临界值时设置警报，并实施自动响应措施，例如限制或隔离可疑容器。</p>
</li>
<li><p><strong>运行时隔离</strong>：使用更高级别的运行时隔离技术，如gVisor或Kata Containers，以提供更强大的安全隔离。</p>
</li>
</ol>
<p>需要注意的是，防御<code>inode</code>攻击的方法可能会对性能产生影响，因此在实施这些措施时需要权衡安全性和性能。</p>
<h2 id="netns-ct-gt-count攻击"><a href="#netns-ct-gt-count攻击" class="headerlink" title="netns_ct-&gt;count攻击"></a>netns_ct-&gt;count攻击</h2><p>一种针对 Linux 内核中的连接跟踪功能（Netfilter）的攻击，该攻击涉及到利用 <code>netns_ct-&gt;count</code> 计数来消耗主机和容器的网络资源。这种攻击通常被称为连接消耗攻击（Connection Exhaustion Attack）或资源耗尽攻击（Resource Exhaustion Attack）。</p>
<p>攻击原理概述如下：</p>
<ol>
<li>攻击者在容器内产生大量的 TCP 连接，这些连接会被跟踪。</li>
<li>尽管这些容器位于不同的网络命名空间（net namespace）中，但它们的所有连接都需要使用主机的 <code>init_net.ct</code> 计数。</li>
<li>当攻击者在短时间内产生大量连接时，会消耗掉主机的 <code>init_net.ct</code> 计数配额。</li>
<li>一旦配额耗尽，Netfilter 功能将受到影响，可能导致随机丢包等问题。</li>
</ol>
<p>要防范这种攻击，可以采取以下措施：</p>
<ol>
<li><strong>限制容器的连接数</strong>：为每个容器设置连接数限制，以防止单个容器耗尽主机的连接资源。</li>
<li><strong>限制连接速率</strong>：使用 Netfilter 的 <code>iptables</code> 工具限制容器的连接速率。例如，可以设置每秒最多允许的新连接数，从而防止攻击者在短时间内产生大量连接。</li>
<li><strong>隔离网络命名空间</strong>：在某些情况下，可以为每个容器提供独立的网络命名空间，以降低资源争用的可能性。然而，这种方法可能会增加资源消耗和管理复杂性。</li>
<li><strong>监控和报警</strong>：实施实时网络连接监控，以便在攻击发生时迅速检测并采取相应措施。</li>
</ol>
<p>通过实施这些防范措施，可以降低容器和主机受到 <code>netns_ct-&gt;count</code> 攻击的风险。</p>
<h2 id="gVisor"><a href="#gVisor" class="headerlink" title="gVisor"></a>gVisor</h2><p><code>gVisor</code> 是一个开源的沙箱运行时，由谷歌开发，用于为容器提供隔离和安全性。<code>gVisor</code> 主要目标是为容器提供更高级别的安全性，同时保持接近原生容器的性能。它在容器与宿主机之间增加了一个用户空间内核，从而限制容器对宿主机内核的访问。这种方法降低了潜在安全漏洞对整个系统的影响。</p>
<p><code>gVisor</code> 的核心组件是名为 “Sentry” 的用户空间内核，它拦截和处理来自容器的系统调用。Sentry 为每个容器提供了一个独立的内核实例，从而限制容器之间的相互影响。此外，<code>gVisor</code> 还包括一个名为 “Gofer” 的文件系统代理，用于将容器的文件系统操作转发到宿主机。</p>
<p><code>gVisor</code> 与 Docker 和 Kubernetes 等容器运行时环境兼容，可以轻松集成到现有的容器部署中。为了在 Docker 中使用 <code>gVisor</code>，您需要安装 <code>gVisor</code> 并将其配置为 Docker 的运行时。以下是在 Docker 中使用 <code>gVisor</code> 的示例：</p>
<ol>
<li>首先，安装 <code>gVisor</code>：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc</span><br><span class="line">wget https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc.sha512</span><br><span class="line"><span class="built_in">sha512sum</span> -c runsc.sha512</span><br><span class="line"><span class="built_in">chmod</span> a+x runsc</span><br><span class="line">sudo <span class="built_in">mv</span> runsc /usr/local/bin</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 Docker 使用 <code>gVisor</code>：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;runtimes&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;runsc&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;path&quot;: &quot;/usr/local/bin/runsc&quot;,</span></span><br><span class="line"><span class="string">      &quot;runtimeArgs&quot;: [&quot;--platform=ptrace&quot;]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> | sudo <span class="built_in">tee</span> /etc/docker/daemon.json</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行一个使用 <code>gVisor</code> 的 Docker 容器：</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --runtime=runsc -it alpine sh</span><br></pre></td></tr></table></figure>

<p>这将启动一个使用 <code>gVisor</code> 作为沙箱运行时的新容器。通过使用 <code>gVisor</code>，您可以提高容器的安全性，降低潜在安全漏洞对整个系统的影响。然而，需要注意的是，<code>gVisor</code> 可能会带来一定的性能损失，因此在实际应用中需要权衡安全性和性能。</p>
<h2 id="Per-user-quota-restrictions"><a href="#Per-user-quota-restrictions" class="headerlink" title="Per-user quota restrictions"></a>Per-user quota restrictions</h2><p>Per-user quota restrictions 是一种在文件系统层面设置的资源限制方法，用于控制每个用户所能使用的磁盘空间和文件数量。这种限制方法通常用于多用户共享同一系统资源的环境，如共享主机或服务器，以防止单个用户占用过多的磁盘空间或文件数量，从而导致其他用户无法正常使用系统资源。</p>
<p>Per-user quota restrictions 主要包括以下两种类型：</p>
<ol>
<li><p><strong>磁盘空间限制（Block Quotas）</strong>：该限制用于限制每个用户所能使用的磁盘空间。系统管理员可以为每个用户分配一定量的磁盘空间，当用户达到分配的磁盘空间上限时，将无法继续写入或创建新文件。</p>
</li>
<li><p><strong>文件数量限制（Inode Quotas）</strong>：该限制用于限制每个用户所能创建的文件数量。系统管理员可以为每个用户分配一定数量的文件（或目录）创建权限，当用户达到分配的文件数量上限时，将无法继续创建新文件或目录。</p>
</li>
</ol>
<p>在 Linux 系统中，可以通过以下步骤设置 per-user quota restrictions：</p>
<ol>
<li><p>安装 quota 工具：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install quota quotatool</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 <code>/etc/fstab</code> 文件中启用用户配额。例如，为 <code>/home</code> 分区启用用户配额，可以将以下内容添加到 <code>/etc/fstab</code> 文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/dev/</span>sda1 /home ext4 defaults,usrquota,grpquota <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新挂载分区以应用更改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mount -o remount /home</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化配额文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo quotacheck -cug /home</span><br></pre></td></tr></table></figure>
</li>
<li><p>为特定用户设置配额限制。例如，为用户 <code>exampleuser</code> 设置 100MB 的磁盘空间限制和 1000 个文件数量限制：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo setquota -u exampleuser 100000 110000 1000 1100 /home</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>quota</code> 命令查看用户配额情况：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">quota -u exampleuser</span><br></pre></td></tr></table></figure></li>
</ol>
<p>通过实施 per-user quota restrictions，系统管理员可以确保系统资源在用户之间公平地分配，防止单个用户过度使用资源。</p>
]]></content>
      <categories>
        <category>论文精读</category>
        <category>内核安全</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>云安全</tag>
      </tags>
  </entry>
  <entry>
    <title>论文阅读 Making Memory Account Accountable：Analyzing and Detecting Memory Missing account bugs for Container Platforms</title>
    <url>/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/</url>
    <content><![CDATA[<p><strong>摘要</strong></p>
<p>Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。</p>
<p>在本文中，我们首次系统地研究了内存记账缺失问题。我们首先对其在容器平台上的可利用性和安全性影响进行了深入分析。然后我们开发了一个名为MANTA(Memory Accounting Analyzer)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。</p>
<p>我们的分析表明，所有的容器运行时，包括runC和Kata容器，都容易受到基于内存记账缺失的攻击。此外，内存记账缺失可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而使单个节点甚至整个集群崩溃。我们的工具报告了53个可利用的内存记账缺失漏洞，其中37个被内核开发者确认，并提交了相应的补丁，还有两个新的CVE被分配。通过深入分析、自动检测、报告的错误和提交的补丁，我们相信我们的研究提高了容器平台内存核算的正确性和安全性。</p>
<p><strong>CCS CONCEPTS</strong></p>
<ul>
<li>Security and privacy → Operating systems security; Virtualization and security</li>
</ul>
<p><strong>KEYWORDS</strong></p>
<p>Cloud infrastructure, Linux kernel, memory accounting, missingaccount, DoS attack</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>计算和限制内存使用是每个操作系统内核的核心功能。特别是，Linux内核引入了内存控制组(memcg)，它可以在进程级别解释和限制内存使用。因此，与基于虚拟机(VM)的内存分区技术相比，memcg具有更细粒度和轻量级的特点。</p>
<p>由于其灵活性和高效性，memcg已经被容器平台广泛采用。众所周知，容器平台严重依赖资源共享来提高硬件资源的利用率。而memcg为容器在进程级别提供了唯一的内存使用记录和限制方法。因此，诸如Docker 、容器即服务平台（例如，OpenShift）和函数即服务平台（例如，OpenWhisk）等流行的容器平台，都采用memcg来控制其容器的内存使用。此外，基于虚拟机的容器运行时——Kata容器  也使用memcg来限制主机上的容器线程和其他服务线程的内存。此外，开放容器倡议（OCI）认证要求容器运行时必须使用memcg才能获得认证 。因此，memcg已经成为容器平台和云计算的基础技术。</p>
<p>不幸的是，尽管memcg被广泛使用，但由于其复杂性，它容易出错。具体来说，Linux内核选择将内存记账接口插入到内存分配&#x2F;释放路径中以实现记账，这可能由于高度复杂的内存使用和大量与内存使用相关的接口和代码路径，容易引入内存记账丢失错误（分配的内存未计入账户）。此外，即使记账接口位置正确，它们的记账行为也是有条件的，并受到记账标志的控制，我们发现这些标志经常缺失。因此，我们发现内存记账丢失错误很常见。</p>
<p>然而，即使memcg已经被广泛使用，其内存记账丢失漏洞从未得到系统分析。 memcg的现状是由两个原因造成的。首先，从来没有清楚地知道内存记账丢失漏洞会产生什么安全影响或者它们是否可利用。结果，记账丢失错误被内核开发人员忽略，并且没有特别努力消除这些问题。其次，没有自动检测内存记账丢失漏洞。正如之前讨论的那样，内存记帐设计和实现非常复杂，并深度集成到Linux kernel的复杂内存管理子系统中。因此，即使对于有经验的用户来说也很难正确理解记帐设计和策略。例如，我们发现Docker官方网站错误地声称“页面高速缓存的记忆费用在控制组之间分配”，并且“当一个cgroup终止时，它可能会增加另一个cgroup 的内存使用量“。因此，在没有自动检测的情况下手动推断记帐正确性几乎是不可能的更糟糕的是, 内存记账丢失是否可检测以及如何进行检测仍然是开放性问题。</p>
<p>本文首次对Linux内存记账丢失错误进行了系统分析和检测。我们首先进行了深入分析，以了解内存记账丢失错误在容器平台上的可利用性和安全影响。然后我们开发了一个名为MANTA（Memory AccouNTing Analyzer的简称）的工具，它结合了静态和动态分析技术来自动检测内存记账丢失错误。我们的分析显示，不仅普通容器运行时（如runC），而且安全容器运行时（如Kata容器）都容易受到由内存记账丢失错误引起的内存耗尽攻击。更糟糕的是，内存记账丢失错误可以被利用来攻击Docker、CaaS和FaaS平台，导致容器节点甚至整个集群崩溃。</p>
<p>由于memcg的复杂性，内存记账丢失检测面临两个挑战。首先，没有文档或现有研究定义了memcg使用的内存记账接口。现有的工作采用自然语言处理或包装函数分析来识别内存分配接口。然而，由于不匹配的启发式规则，这些技术无法直接应用于记账接口。为解决这个问题，MANTA提出了基于计数器的接口识别方法，自动检测所有与内存记账相关的接口。关键的观察是，所有内存记账接口最终都会在实现中增加&#x2F;减少相应的页面计数器。识别从页面计数器修改开始，迭代整个调用图以精确识别记账接口。</p>
<p>其次，分析内存分配和内存记账之间的映射具有挑战性。这种分析由于从内存分配位置到内存记账位置的深层和嵌套执行路径而变得复杂。它还需要跟踪分配的页面和计入账户的页面之间的数据流，以获得正确的别名集。此外，由于条件标志的控制，记账可能是有条件的。因此，MANTA提出了分配-消耗映射分析和记账标志分析来解决这个挑战。此外，为了验证检测到的内存记账丢失错误，MANTA进一步使用Linux测试项目来检查它们的可触发性和影响。</p>
<p>通过MANTA，我们检测并报告了memcg中的53个可利用错误，其中37个已经被内核开发人员确认并有已合并或待合并的补丁。报告的错误获得了两个新的CVE（一个正在等待）。总之，这项工作进行了深入调查，不仅分析了可利用性和影响，还系统地检测了内存记账丢失错误。我们相信，这些发现将有助于内核memcg开发人员在未来改进内存记账。本文做出了以下贡献。</p>
<ul>
<li><p>In-depth analysis of exploitability and impacts</p>
<p>我们设计了新的攻击来利用容器平台上的内存记账问题。我们的攻击表明，内存记账丢失漏洞可以很容易地被利用来攻击正常和安全的容器运行时(即runC和Kata容器)和流行的容器平台(即Docker, OpenShift和OpenWhisk)，导致容器节点甚至整个集群崩溃。</p>
</li>
<li><p>Automated detection with new techniques</p>
<p>我们提出了多种分析技术来有效地检测内存记账丢失错误，集成了静态分析和动态验证。我们实现了基于LLVM的检测，并使用Linux内存记账对其进行评估。我们进一步使用Linux Test Project (LTP)来验证检测到的错误的可触发性。</p>
</li>
<li><p>Community impact</p>
<p>我们在Linux v5.10中检测并报告了53个可利用的内存记账丢失错误，其中37个已被内核开发人员确认。分配了两个新的cve(一个正在等待)。我们的发现提高了内核社区对记账丢失的影响的认识，他们还邀请我们测试他们的下游内核。我们计划开源我们的检测工具，以进一步帮助社区提高内存计费的正确性和安全性。</p>
</li>
</ul>
<p>道德考虑：本文中的所有实验和攻击都是在一台专用的物理机器上进行的，这台机器仅由我们使用。我们负责任地向Linux内核开发人员披露了所有检测到的错误，并为所有经确认的错误提交了补丁。此外，我们还向Docker团队报告了关于内存记账的错误声明。</p>
<h1 id="BACKGROUD"><a href="#BACKGROUD" class="headerlink" title="BACKGROUD"></a>BACKGROUD</h1><h2 id="Linux-Memory-Accounting"><a href="#Linux-Memory-Accounting" class="headerlink" title="Linux Memory Accounting"></a>Linux Memory Accounting</h2><p>内存记帐是每个现代操作系统内核的核心功能。目前Linux内核采用内存控制组(memory control group, memcg)来实现内存计费。Memcg包含4种类型的内存:user、kernel、swap，and socket。</p>
<ul>
<li><p>user 记录所有用户空间内存页</p>
</li>
<li><p>kernel 记录内核空间内存页和对象</p>
</li>
<li><p>swap 记录交换区页面</p>
</li>
<li><p>socket 记录socket内存</p>
</li>
</ul>
<p>Memcg仅对用户空间进程的内存进行记账，并跳过对内核守护程序或内部内存使用的记账。需要注意的是，Linux内核v5.9引入了对象cgroup，它会对子页面内核内存使用（如内核对象）进行记账。对象cgroup可以将对象分配到不同的cgroups中，从而消除每个memcg的slab（内存分配池），节省大量的slab内存。</p>
<ul>
<li><p>Accounting：Linux内核针对不同类型的内存使用不同的记账接口。具体来说，Linux内核使用<code>mem_cgroup_charge</code>对用户和交换内存进行记账，使用<code>__memcg_kmem_charge</code>对内核内存进行记账。对于内核内存，Linux内核还要求在内存分配过程中设置<code>__GFP_ACCOUNT</code>标志以对内核页面进行记账。用户可以通过文件接口与memcg进行交互。例如，用户可以从<code>memory.usage_in_bytes</code>检查总内存使用情况。</p>
<p>一个memcg实例可能包含多个内存使用情况在其中进行记账的进程。memcg以树形层次结构组织，因此父节点上的内存限制也会影响所有子节点。memcg有两个版本：v1和v2。它们的主要区别在于层次结构和用户接口，而在记账方面的实现大致相同。目前两者都在使用。本文提到的是cgroups v1，大多数结论也适用于cgroups v2。</p>
</li>
<li><p>数据结构：memcg的核心数据结构是<code>mem_cgroup</code>，它代表一个memcg实例。memcg包含4个页面计数器，对应于之前讨论的4种类型的已记账内存。每个页面计数器使用<code>usage</code>（第14行）来计算分配的页面数量。同时，总内存限制（以页面为单位）设置在<code>max</code>（第16行）。在内存充电时，Linux内核调用消耗接口，依次调用<code>page_counter_try_charge</code>，这是一个计算总使用量（第24行）并将其与最大限制（第25行）进行检查的函数。</p>
</li>
<li><p>Accounting challenges：由于Linux内核中众多的内存分配接口和庞大的分配路径，正确地对Linux内核中的内存使用情况进行记账非常具有挑战性。很难调解所有内存分配路径，因此当前的记账机制容易出错。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">memory</span>;</span><span class="comment">/*Both v1 &amp; v2*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">swap</span>;</span><span class="comment">/*v2 only */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">memsw</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*Legacy consumer-oriented counters*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">kmem</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">tcpmem</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span>&#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> usage;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> max;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">page_counter_try_charge</span><span class="params">(<span class="keyword">struct</span> page_counter *counter,<span class="type">unsigned</span> <span class="type">long</span> nr pages,...)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">c</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    new = atomic_long_add_return(nr_pages, &amp;c-&gt;usage);</span><br><span class="line"><span class="keyword">if</span>(new&gt;c-&gt;max)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">goto</span> failed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Container-Runtimes-and-Platforms"><a href="#Container-Runtimes-and-Platforms" class="headerlink" title="Container Runtimes and Platforms"></a>Container Runtimes and Platforms</h2><p>Memcg可以记录和限制每个进程级别的内存使用情况。与基于虚拟机(VM)的内存控制技术相比，memcg粒度更细、更轻、更灵活。因此，memcg已经被Docker、CaaS (container -as- service)和FaaS (function -as- service)平台广泛采用。具体来说，CaaS平台为用户提供了已配置的容器实例。CaaS平台上的用户可以使用自定义的容器映像创建&#x2F;启动&#x2F;停止&#x2F;删除容器。另一方面，FaaS平台不向用户提供容器实例，而是允许用户输入函数和触发规则，并自动创建容器实例来执行输入函数。</p>
<p>Docker和CaaS&#x2F;FaaS平台通常为容器实例使用本地容器运行时(即runC)。为了提高容器之间的隔离性，人们提出了安全容器运行时，如gVisor和Kata容器。gVisor是谷歌开发的沙盒容器运行时。它在一个名为Sentry的用户空间内核上运行每个容器。Sentry拦截并处理来自容器的大多数系统调用。因此，Sentry减少了从容器在主机内核上调用的系统调用。除了沙盒运行时，容器社区还建议使用虚拟化来隔离容器实例。其中一个这样的虚拟化容器运行时是Kata容器，其中每个容器实例都在微型虚拟机中运行，以实现强隔离。</p>
<p>我们的实验表明，正常和安全的容器运行时(包括runC和Kata容器)都容易受到由记账丢失错误引起的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致单个节点甚至整个集群崩溃。</p>
<h1 id="A-STUDY-OF-EXPLOITABLITY-AND-IMPACT"><a href="#A-STUDY-OF-EXPLOITABLITY-AND-IMPACT" class="headerlink" title="A STUDY OF EXPLOITABLITY AND IMPACT"></a>A STUDY OF EXPLOITABLITY AND IMPACT</h1><p>生产环境中内存未记录错误的影响从未被系统地研究过。它们通常被视为一个较小的正确性问题，而不是安全问题。在这一部分中，我们展示了内存未记录错误可以被利用来导致容器主机甚至整个云平台的内存耗尽。特别是，我们分析了内存记账问题的可利用性，以了解其对容器平台的实际影响。我们设计了新的攻击方法来利用未记录错误。这些攻击表明，这些错误可用于攻击普通和安全的容器运行时。因此，它们可被利用在热门的CaaS和FaaS容器平台上造成DoS（主机机器崩溃）和财务费用问题。在以下内容中，我们首先讨论威胁模型和假设。接下来，我们详细介绍如何利用内存未记录问题。</p>
<h2 id="Threat-Model-and-Assumptions"><a href="#Threat-Model-and-Assumptions" class="headerlink" title="Threat Model and Assumptions"></a>Threat Model and Assumptions</h2><p>在我们的实验中，我们研究了三个容器平台 - Docker、容器即服务（CaaS）平台和函数即服务（FaaS）平台。我们使用广泛部署的CaaS平台 - OpenShift作为我们的CaaS平台，以及流行的OpenWhisk作为我们的FaaS平台。这三个平台使用本地运行时（即runC）作为它们的容器运行时。这三个平台上的所有容器都以非特权方式设置为具有默认功能和seccomp配置。对于Docker和CaaS平台，用户可以通过云提供的接口创建和启动带有自定义映像的容器。这是合理的，因为包括AWS、Google Cloud和Azure在内的所有云供应商都为用户提供了一个控制台来管理容器实例。对于FaaS平台，用户可以定义、部署和触发函数，其中每个函数实例都在一个容器中运行。</p>
<p>攻击者是使用Docker、CaaS和FaaS平台的恶意用户。他&#x2F;她可以在非特权容器内执行任意代码。然而，容器的功能受到默认功能的限制。为了进一步限制攻击者，我们假设攻击者无法从容器中逃逸，也无法提升他们的权限。攻击者的目标是破坏内存计算的限制，并耗尽主机上的所有内存，以使其他容器、函数或主机崩溃。</p>
<p>对于攻击环境，我们在本地机器上设置Docker，同时在Google Cloud上设置OpenShift和OpenWhisk集群。出于道德考虑，该集群构建在一个由Google Cloud提供的专用裸金属服务器上，仅供我们使用，因此不会影响其他用户。</p>
<h2 id="Exploit-Missing-Account-Problem"><a href="#Exploit-Missing-Account-Problem" class="headerlink" title="Exploit Missing-Account Problem"></a>Exploit Missing-Account Problem</h2><p>在本节中，我们将设计新的攻击来利用内存记帐中的记账问题，以了解其影响。如前所述，Linux内核中的当前内存记帐将内存记帐接口放在内存分配路径上，将内存取消记帐接口放在内存空闲路径上。然而，Linux内存管理是复杂的，包含数千个内存分配和自由路径。很难用正确的接口来调解所有这些问题。特别是，很容易遗漏一个内存分配路径，从而导致丢失帐户问题。</p>
<p>显示了内核中信号量对象和信号量数组上的记账丢失错误，由MANTA检测并由Linux开发人员确认。函数<code>sem_alloc</code>分配一组信号量，并使用<code>sem_array</code>对它们进行索引。第8行的分配站点调用<code>kvzalloc</code>为<code>sem_array</code>和信号量分配内存。当在<code>kvzalloc</code>的第三个参数中设置了<code>__GFP_ACCOUNT</code>标志时，内核只会考虑分配的内存。然而，在第8行对<code>kvzalloc</code>的调用没有指定<code>__GFP_ACCOUNT</code>标志，导致在分配的信号量和<code>sem_array</code>上丢失帐户。此外，<code>sem_alloc</code>由<code>semget</code>系统调用调用来分配信号量。因此，这个记账丢失的错误很容易从用户空间触发。我们进一步设计了新的攻击，以表明上述漏洞可以被利用来打破容器内存限制并耗尽所有主机内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sem_array *<span class="title function_">sem_alloc</span><span class="params">(<span class="type">size_t</span> nsems)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nsems &gt; (INT_MAX - <span class="keyword">sizeof</span>(*sma)) / <span class="keyword">sizeof</span>(sma-&gt;sems[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    sma = kvzalloc(struct_size(sma, sems, nsems),GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(unlikerly(!sma))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Attacking-Docker"><a href="#Attacking-Docker" class="headerlink" title="Attacking Docker"></a>Attacking Docker</h3><p>我们用默认的功能和seccomp配置来设置Docker。semget系统调用不需要任何功能，也不会被容器seccomp配置文件阻塞。因此，在我们的实验中，攻击程序在非特权容器中可以反复触发semget系统调用，从而打破内存记帐限制，耗尽所有主机内存。主机甚至会因为内存不足错误而崩溃。我们向Linux社区报告了上述错误并提交了补丁。补丁已经被合并到Linux主线上，一个新的CVE已经分配给我们了。</p>
<h3 id="Attacking-the-CaaS-Platform"><a href="#Attacking-the-CaaS-Platform" class="headerlink" title="Attacking the CaaS Platform"></a>Attacking the CaaS Platform</h3><p>我们在Google Cloud上搭建了一个自管理的OpenShift集群，运行所有的GCP虚拟机实例。该集群允许用户在一个具有15GB内存和Linux内核v5.14.14的节点上创建容器。我们将容器的内存限制设置为128MB，这是公共云中常用的内存大小。</p>
<p>为了发起攻击，恶意用户以普通用户权限创建一个容器，并在容器内分配大量信号量。恶意容器的内存使用量迅速增加，大约在20秒内达到节点的极限。相比之下，攻击者的计费内存使用量非常低，不到1.4MB。结果，恶意容器打破了128MB的内存限制，消耗了主机上的全部15GB内存。同一节点上的受害者容器由于内存不足无法执行任何操作。</p>
<h3 id="Attacking-the-FaaS-Platform"><a href="#Attacking-the-FaaS-Platform" class="headerlink" title="Attacking the FaaS Platform"></a>Attacking the FaaS Platform</h3><p>我们评估了对OpenWhisk的攻击，OpenWhisk是一个流行的开源FaaS平台，作为IBM Cloud Functions的基础设施。集群节点内存为15GB，运行Linux内核v5.11.0-1021-gcp。每个功能的内存限制设置为128MB。</p>
<p>为了发起攻击，恶意用户创建了一个反复消耗信号量的函数。然后，恶意用户反复触发恶意功能。导致节点上的内存很快耗尽。注意，当一个节点的内存耗尽时，连续的恶意函数将被分派到其他节点。导致集群内所有节点的内存被恶意用户耗尽，导致集群级DoS。</p>
<h3 id="Attacking-the-Secure-Runtime"><a href="#Attacking-the-Secure-Runtime" class="headerlink" title="Attacking the Secure Runtime"></a>Attacking the Secure Runtime</h3><p>我们进一步设计新的攻击来评估内存记账丢失对安全运行时- Kata容器的影响。我们的实验表明，内存记账丢失漏洞允许攻击者打破Kata容器的隔离并攻击主机和其他容器实例。</p>
<p>Kata容器是一种虚拟容器运行时，其中每个容器实例在微虚拟机中运行，以实现强隔离。但是，Kata micro-VM将文件操作转发给主机，这使得它容易受到基于内存记账丢失的攻击。更具体地说，通过利用内存记账丢失错误，攻击者可以耗尽微型虚拟机中Kata容器的主机内存。如图所示，恶意用户是容器中的普通用户，并发出fcntl系统调用，为一组文件分配大量POSIX锁。但是，客户机内核将请求转发给运行在主机上的virtio-fsd守护进程。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/attackKatacontainers.png" title alt data-align="center">

<p>因此，守护进程在主机内核中分配了 POSIX 锁。尽管 virtio-fsd 守护进程的内存使用受到 memcg（内存控制组）的限制，但锁对象所使用的内存没有被纳入统计。因此，恶意容器可以耗尽主机上的所有物理内存。我们向 Kata 容器社区报告了这种攻击。他们确认了这个问题，并为我们申请了一个新的 CVE（公开披露的计算机安全漏洞和漏洞）。</p>
<p>用通俗的语言来说，这段话描述了一个安全问题，其中，虚拟文件系统管理的守护程序在主机操作系统上分配了一种名为 POSIX 锁的资源。虽然这个守护程序的内存使用受到限制，但锁对象占用的内存没有被计算在内。这意味着一个恶意的容器（一种轻量级的虚拟化技术）可以利用这个问题耗尽主机的物理内存。作者报告了这个问题，并且 Kata 容器社区已经确认该问题，并正申请一个新的安全漏洞编号（CVE）。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>正如上述攻击所证明的那样，可以利用记账丢失漏洞攻击正常和安全的容器运行时、Docker和CaaS&#x2F;FaaS平台。攻击者可以利用这些漏洞耗尽所有内存，使容器节点甚至整个集群崩溃。更糟糕的是，攻击只需要普通用户权限，因此很容易启动。虽然内存丢失帐户漏洞可以被利用来攻击容器平台，但目前还没有系统的研究来检测和消除这些漏洞。因此，本文提出了第一个内存记账分析工具MANTA，来系统地检测这些问题。</p>
<h1 id="MISSING-ACCOUNT-BUG-DETECTION"><a href="#MISSING-ACCOUNT-BUG-DETECTION" class="headerlink" title="MISSING-ACCOUNT BUG DETECTION"></a>MISSING-ACCOUNT BUG DETECTION</h1><p>考虑到内存记账丢失错误的严重性，在操作系统内核实际在生产场景中运行之前的早期阶段检测这些问题非常重要。不幸的是，没有一种工具可以同时检测高代码覆盖率和高精度的遗漏帐户错误。因此，我们提出了MANTA(Memory AccouNTing Analyzer的缩写)来自动检测内存记账丢失错误。</p>
<ul>
<li><p>Design goals</p>
<p>MANTA旨在通过分析记帐接口放置的正确性来自动、系统地检测内存记账丢失错误。具体来说，MANTA需要检测具有高代码覆盖率的内存记账丢失错误。</p>
<p>为了实现这一点，MANTA利用静态分析来遍历Linux内核中的所有内存分配&#x2F;自由路径。此外，MANTA需要高精度地检测漏洞。因此，MANTA使用动态验证来测试检测到的错误的动态触发性。</p>
</li>
<li><p>Challenges</p>
<p>为了实现这两个目标，MANTA需要克服以下挑战。</p>
<ul>
<li><p>C1. MANTA需要识别内存记帐接口，这些接口在内核文档中没有描述，以前的工作也没有研究过。现有的用于内存分配的接口识别方法不能应用，因为它们的启发式方法不适用于内存计费接口</p>
</li>
<li><p>C2. MANTA需要决定每个内存分配是否被考虑并且只考虑一次。然而，在Linux内核中，从内存分配站点到内存记帐站点的执行路径往往是深的、嵌套的和交错的。此外，即使存在这样的路径，记帐也可能受到条件标志的影响，因为记帐同时需要记帐接口和记帐标志§2</p>
</li>
</ul>
</li>
<li><p>Analysis techniques and workflow</p>
<p>MANTA的体系结构如图所示。以整个内核IR作为输入，MANTA首先生成内核调用图。然后，它使用基于页面计数器的方法来识别所有会计接口以地址C1(§4.1)。基于记帐接口，MANTA建立了内存分配&#x2F;释放和内存记帐之间的映射(§4.2)。</p>
<p>之后，MANTA使用记帐标志分析来进一步分析内核内存记帐(§4.3)。这两种技术处理C2。随着检测到的内存记账错误，MANTA进一步评估每个错误与我们的动态触发性分析基于数千个测试用例从Linux测试项目(§4.4)。MANTA目前是为Linux内存记账实现的。下面，我们将详细介绍每种分析技术。</p>
</li>
</ul>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/challenge.png" title alt data-align="center">

<h2 id="Counter-based-Interface-Identification"><a href="#Counter-based-Interface-Identification" class="headerlink" title="Counter-based Interface Identification"></a>Counter-based Interface Identification</h2><p>MANTA首先需要识别内存记账接口。</p>
<p>这些接口是多种多样的，并且可以自定义。使用自然语言处理(NLP)或包装函数分析的现有技术存在精度问题。我们注意到内存记帐必须维护内存使用计数器(即<code>page_counter</code>)，这些计数器是通过特定的原子函数操作的。使用类型匹配可以很容易地找到内存使用计数器。因此，通过识别用于增加&#x2F;减少这些计数器的基本函数，MANTA可以自动找出对会计计数器执行增加&#x2F;减少操作的所有函数。</p>
<p>具体来说，MANTA遍历每个内核IR指令并检查它是否增加&#x2F;减少<code>page_counter</code>。如果是这样，则MANTA将直接包含该指令的函数标记为基本会计函数。由于在Linux内核中，<code>page_counter</code>仅由<code>memcg</code>使用，因此我们的方法可以达到较高的精度。</p>
<p>然后，MANTA根据基本的记账功能识别会计接口。MANTA使用DFS从基本记账函数向后遍历，并在内核调用图上标记所有访问过的函数。每当它到达<code>memcg</code>子系统之外的函数时，MANTA就会停止遍历，因为它不能是<code>memcg</code>接口。在这些记录内存使用情况的标记函数中，如果一个函数是从<code>memcg</code>子系统外部调用的，即，定义<code>memcg</code>功能的源文件，MANTA将其标记为一个记录接口。这样，MANTA就可以识别所有的计费接口。</p>
<p>让我们使用图中的示例来说明基于计数器的接口标识中的步骤。首先，MANTA遍历所有核函数的所有基本块。在<code>__memcg_kmem_charge</code>中，它标识<code>page_counter</code>函数(第6行)并双重确认第一个参数来自<code>memcg</code>。之后，MANTA进入<code>page_counter_try_charge</code>，发现它增加了<code>page_counter</code>的一个字段。由于<code>__memcg_kmem_charge</code>直接调用<code>page_counter</code>函数并增加<code>page_counter</code>的值，因此MANTA认为<code>__memcg_kmem_charge</code>是一个基本的计费接口。</p>
<p>类似地，对于减少<code>page_counter</code>值的接口，MANTA将其标记为未收费接口。此外，MANTA可以区分不同内存类型的接口，因为<code>memcg</code>对每种内存类型使用不同的<code>page_counters(§2)</code>。在第6行，<code>page_counter_try_charge</code>使用了<code>&amp;memcg-&gt; kmemm</code>，因此MANTA知道<code>__memcg_kmem_charge</code>用于内核内存记帐。</p>
<p>从基本的收费接口开始，MANTA然后沿着调用链逐步识别所有的收费接口包装器。如果一个函数调用基本的计费接口，并且计费量来自于它的参数，MANTA将把它标记为一个计费接口包装器。使用图中的相同示例，<code>__memcg_kmem_charge_page</code>调用基本收费接口<code>__memcg_kmem_charge</code>(第29行)，而收费金额<code>1&lt;&lt;order</code>由<code>__memcg_kmem_charge_page</code>的参数控制。</p>
<p>因此，MANTA认为<code>__memcg_kmem_charge_page</code>是一个收费包装器，因为它只是将收费数量传递给基本收费接口，并且对收费数量没有控制。</p>
<p>MANTA使用相同的方法来检测未充电的包装器。</p>
<p>对于charge&#x2F;uncharge接口，MANTA还需要识别内存分配&#x2F;空闲接口。MANTA采用现有技术来产生初步结果。此外，通过观察内存分配&#x2F;释放接口增加&#x2F;减少<code>struct free_area</code>的<code>nr_free</code>计数器，MANTA使用类似的基于计数器的方法来提高结果的精度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __memcg_kmem_charge(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">gfp_t</span> gfp,<span class="type">unsigned</span> <span class="type">int</span> nr_pages)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">counter</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!cgroup_subsys_on_dfl(memory_cgrp_subsys)&amp;&amp;!page_counter_try_charge(&amp;memcg-&gt;kmem,nr_pages,&amp;counter))</span><br><span class="line"></span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">page_counter_try_charge</span><span class="params">(<span class="keyword">struct</span> page_counter *counter,<span class="type">unsigned</span> <span class="type">long</span> nr_pages,<span class="keyword">struct</span> page_counter **fail)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(c = counter; c;c = c-&gt;parent)&#123;</span><br><span class="line">        <span class="type">long</span> new;</span><br><span class="line">        new = atomic_long_add_return(nr_pages,&amp;c-&gt;usage);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __memcg_kmem_charge_page(<span class="keyword">struct</span> page *page, <span class="type">gtp_t</span> gtp,<span class="type">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    memcg = get_mem_cgroup_from_current();</span><br><span class="line">    ...</span><br><span class="line">    ret = __memcg_kmem_charge(memcg,gfp,<span class="number">1</span>&lt;&lt;order);</span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">        page-&gt;mem_cgroup = memcg;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alloc-Charging-Mapping-Analysis"><a href="#Alloc-Charging-Mapping-Analysis" class="headerlink" title="Alloc-Charging Mapping Analysis"></a>Alloc-Charging Mapping Analysis</h2><p>直观地说，每个分配的对象应该只被计算一次。否则，对象可能会被漏记。因此，MANTA 的下一步是建立内存分配&#x2F;释放和计费&#x2F;取消计费之间的关系。基于这种关系，MANTA 可以识别比分配&#x2F;释放的内存少收费或多退费的情况，将其视为漏记错误。简洁起见，我们关注分配和计费。同样的技术可以应用于分析free-uncharging映射。</p>
<p>由于深层次的调用关系和复杂的内存指针传播，从源代码分析分配和计费之间的映射并非易事。为了解决这些问题，我们开发了分配计费(allocation and charging)映射分析。基本思路是首先将函数内的内存分配和计费总结为函数摘要(function summary)，然后基于函数摘要构建内存分配-计费映射，以检测漏记错误。更具体地说，我们使用基于访问路径的分析来生成每个函数的摘要。访问路径的概念首次用于 SATURN 框架，用于表示转义对象的每个函数摘要（即对象指针泄漏到当前函数之外）。</p>
<p>如图左侧算法所示，MANTA 首先为所有函数生成函数摘要（第 2 行）。接下来，对于一个函数𝑓，通过收集其被调用者的函数摘要并分析内存分配位置（IsAlloc），MANTA 可以构建 𝑓 内所有非转义对象的分配-计费映射（第 4-9 行）。具体而言，MANTA 用传递给被调用者的参数替换被调用者摘要中的变量，以计算 𝑓 中分配的页面，这被称为源敏感跟踪。然后，MANTA 通过调用 <code>CheckPage</code> 来分析 𝑓 内的分配-计费映射。在 <code>CheckPage</code> 中，MANTA 能够报告非转义对象的漏记错误（第 19 行）。对于从 𝑓 转义的对象（第 14-18 行），它们最终将在一个函数中（例如 𝑓 的调用者）处理，因为内核中的所有函数都被遍历（第 3-10 行）。此外，<code>IsCharged</code>（第 13 行）和 <code>IsDupCharged</code> 函数（第 21 行）都进行数据流分析，将局部对象连接到被调用函数的返回值或参数。这样，他们可以使用被调用者的函数摘要跟踪内核对象的计费状态。</p>
<p>我们使用图右侧的具体示例来演示算法。MANTA首先为底层内存分配函数<code>__alloc_pages_nodemask</code>生成摘要。 MANTA识别到页面由较低级别的函数<code>get_page_from_freelist</code>返回、充电，并返回。因此，页面既逸出又充电，函数摘要应为（<code>__alloc_pages_nodemask，retval，retval</code>）。当MANTA分析<code>do_anonymous_page</code>时，它会获取<code>alloc_zeroed_user_highpage_movable</code>的函数摘要，该函数是<code>__alloc_pages_nodemask</code>的包装器，具有相同的摘要。根据函数摘要，MANTA确定<code>do_anonymous_page</code>中的页面已经充电。在分析<code>do_anonymous_page</code>内部的分配-计费映射时，MANTA发现内存核算位于第18行可从第14行到达，页面可能在第18行再次被计费。因此，MANTA在这种情况下报告了一个冗余帐户警告。另一方面，如果当前函数中的页面未被计费且不会逸出，MANTA会报告一个未记录错误。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/algorithm.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span> * __alloc_pages_nodemask(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    page = <span class="built_in">get_page_from_freelist</span>(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcg_kmem_enabled</span>()&amp;&amp;(gtp_mask&amp;__GFP_ACCOUNT)&amp;&amp;page&amp;&amp;<span class="built_in">unlikely</span>(__memcg_kmem_charge_page(page,gfp_mask,order)!=<span class="number">0</span>))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title">do_anonymous_page</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    page = <span class="built_in">alloc_zeroed_user_highpage_movable</span>(vma, vmf-&gt;address);</span><br><span class="line">    <span class="keyword">if</span>(!page)</span><br><span class="line">        <span class="keyword">goto</span> oom;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mem_cgroup_charge</span>(page, vma-&gt;vm_mm, GFP_KERNEL)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Accounting-Flag-Analysis"><a href="#Accounting-Flag-Analysis" class="headerlink" title="Accounting Flag Analysis"></a>Accounting Flag Analysis</h2><p>发现仅依靠分配和记账站点的映射来检测记账丢失错误是不够的，因为内存记账通常是有条件的。特别是在 Linux 内核中，只有当将 <code>__GFP_ACCOUNT</code>标志传递给记账接口时，才会对内核对象内存进行记账。因此，如果没有提供<code> __GFP_ACCOUNT</code> 标志，记账接口仍然不会对内存进行记账。因此，分析记账标志的值对于检测记账丢失至关重要。因此，MANTA 对记账标志进行分析，以确定是否将记账标志 <code>__GFP_ACCOUNT</code> 传递给记账接口。</p>
<p><strong>Bit-wise and inter-procedural analysis</strong></p>
<p>MANTA采用程序间逐位数据流跟踪方法来实现会计标志分析。首先，在计费点，MANTA检查<code>GFP</code>标志本身是否为常数。如果是，MANTA直接检查<code>__GFP_ACCOUNT</code>的位。否则，MANTA将递归地跟踪标志的use-def chain，直到确认其记帐标志位。虽然LLVM提供了一个可以跟踪位值传播的值跟踪分析通道，但该分析仅限于过程内。为了跟踪程序间记帐位，MANTA用两个分析规则扩展了通道。具体来说，当MANTA跟踪函数的参数时，它跟踪所有调用函数以跟踪传递给参数的值;当MANTA跟踪调用站点的返回值时，它也跟踪被调用函数并跟踪所有可能的返回值。如果设置了<code>__GFP_ACCOUNT</code>, MANTA将内核内存标记为在分配点被占用。否则，即使有charging接口，MANTA也会将内存视为not-charged。</p>
<p>对<code>kmem_cache</code>分配的分析略有不同，因为分配也受到<code>kmem_cache</code>的创建标志的影响。</p>
<p>如果<code>kmem_cache</code>是用<code>SLAB_ACCOUNT</code>标志创建的，那么来自<code>kmem_cache</code>的所有分配都会被计算在内。因此，对于与<code>kmem_cache</code>相关的分配，MANTA也会找到<code>kmem_cache</code>的初始化位置，并采用相同的记帐标志分析技术来计算<code>SLAB_ACCOUNT</code>标志。</p>
<h2 id="Dynamic-Validation"><a href="#Dynamic-Validation" class="headerlink" title="Dynamic Validation"></a>Dynamic Validation</h2><p>静态分析可能有误报。MANTA检查每个记账丢失分配的系统调用的静态可达性，并过滤掉不可达的。然而，静态可达的bug不一定在运行时触发。因此，MANTA通过动态验证进一步分析静态检测错误的触发性。观察到Linux测试项目(LTP)包含所有300个系统调用的测试用例，我们利用这些测试用例来检查检测到的错误的动态触发性。更具体地说，我们首先检测代码以拦截每个丢失的记账分配，这样我们就可以确认是否确实达到了它。</p>
<p>接下来，我们运行LTP的系统调用和容器测试套件(包含1,469个测试用例)，以检查是否触发了错误。</p>
<p>此外，我们手动运行现有的工具或开发新的测试用例来触发LTP无法触发的错误。其中一些bug与特定的内核特性密切相关，不能被一般的LTP测试用例(例如keexec和selinux)触发。</p>
<p>因此，我们手动运行相关的用户空间工具来触发它们。</p>
<p>其他原因是由于LTP发现的特定系统调用参数，我们手动开发测试用例来传递这些参数。</p>
<p>对于可以动态触发的记账丢失错误，我们进一步开发了内存耗尽概念验证(PoC)来评估它们的安全风险。我们基于触发记账丢失错误的测试用例开发PoCs。特别是，我们反复调用可能触发PoCs中记账丢失错误的系统调用，并记录记账丢失的内存量。此外，一些记账丢失的分配受到某些约束，例如ulimit和sysctl变量。在不损失通用性的情况下，我们对Amazon Fargate等云服务采用了相同的约束设置。这些PoCs的细节将在§5.2中介绍。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>我们用4K行的c++代码将MANTA作为LLVM12的一个通道来实现。所分析的Linux内核是v5.10，具有x86-64的默认配置。MANTA使用wllvm和Clang在默认配置下为整个内核生成IR位码。</p>
<p>vmlinux的位码大小为481MB。MANTA使用PeX方法来解析间接调用并生成调用图。</p>
<p>使用建议的技术，MANTA能够在大约三分钟内完成分析，使其具有足够的可扩展性，可以应用于每个Linux主要版本。</p>
<h1 id="MANTA-RESULT"><a href="#MANTA-RESULT" class="headerlink" title="MANTA RESULT"></a>MANTA RESULT</h1><p>在本节中，我们首先给出了MANTA的分析结果。接下来，我们评估了MANTA的查准率和查全率。之后，我们将介绍影响分析以及Linux内核社区报告和修复的错误。最后，我们讨论了MANTA的局限性。</p>
<h2 id="Result-Overview"><a href="#Result-Overview" class="headerlink" title="Result Overview"></a>Result Overview</h2><p>MANTA检测到242个记账丢失的错误，这些错误可以通过60590个不同的路径从273个系统调用中静态地到达。具体来说，用户空间可触发的bug数量为162个，其中LTP触发的bug有134个，现有工具触发的bug有23个，手工开发的测试用例触发的bug有5个。</p>
<p>剩下的80个bug不能被触发，触发失败的原因主要是深度调用路径（80个案例中的72个）。其余的8个分配在内核文档中被明确标记为豁免，或者用于内核内部使用。请注意，这72个没有触发的bug并不都是假阳性，因为我们的测试案例只覆盖了一部分执行路径。保守地说，MANTA的精度大于66.9%（162&#x2F;242）。</p>
<p>我们还通过手动删除会计标志来评估MANTA的召回率。更具体地说，我们首先通过删除kernel&#x2F;子目录下现有的会计标志来生成一个评估集。所有受影响的分配点都被收集在评估集中。特别是，我们删除了11个SLAB_ACCOUNT标志，用GFP_KERNEL替换了5个GFP_KERNEL_ACCOUNT，总共影响了19个内存分配，如表所示。然后我们在修改后的内核代码上运行MANTA，评估结果显示，MANTA可以检测到所有19个缺失的站点。虽然评估的站点有限，但仍表明MANTA有很高的召回率。</p>
<p>此外，MANTA没有发现任何多余的账户漏洞。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/recall.png" title alt data-align="center">

<h2 id="Impact-Analysis"><a href="#Impact-Analysis" class="headerlink" title="Impact Analysis"></a>Impact Analysis</h2><p>如前所述，为了理解检测到的错误的影响，我们进一步开发基于LTP测试用例的概念验证(PoCs)。更具体地说，我们已经开发了17个PoCs，它们涵盖了47个可以从用户空间重复触发的错误，如表所示。我们在具有16GB RAM的QEMU x86_64机器上开发和测试PoCs。Linux发行版是带有Linux内核v5.10的Debian Buster。所有poc都运行在受memg限制的环境中，并具有Docker运行时应用的默认功能集。</p>
<p>除了PoCs覆盖的bug之外，由于时间和领域知识的限制，我们没有为其他可触发的bug开发PoCs。</p>
<p>然而，这些漏洞也可能被具有相应领域知识的攻击者反复可靠地触发。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bug.png" title alt data-align="center">

<h2 id="Reporting-to-Linux-Community"><a href="#Reporting-to-Linux-Community" class="headerlink" title="Reporting to Linux Community"></a>Reporting to Linux Community</h2><p>我们已经向Linux内核社区报告了53个bug，包括所有47个可以由17个用户空间poc触发的bug和6个可以由内核操作反复触发的bug。这些bug的完整列表列在附录A的表中。</p>
<p>在所有报告的bug中，有37个已经被内核开发人员确认。所有这37个bug的补丁都提交了，其中18个已经合并，19个待合并。</p>
<p>由于memcg子系统目前没有维护它的git子树，所以修补过程很慢。因此，memcg维护者不跟踪提交的补丁，并期望补丁作者将通过其他子系统维护者向上游推送补丁。这引入了许多额外的讨论和审查，从而显著地减缓了合并过程。</p>
<p>在与内核开发者的交流中，我们发现内核社区对这些bug非常关注。一位内核开发人员强调，memcg“不仅仅是粗略的记账估计”，而且“应该考虑由用户空间触发的未绑定分配”。此外，内核开发人员对MANTA非常感兴趣，并邀请我们使用我们的工具和实验来测试他们的内核。</p>
<p><img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bugs.png"></p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>MANTA目前有以下限制。</p>
<ul>
<li><p>Static analysis is not sound</p>
<p>由于路径不敏感的函数摘要，MANTA的分析可能会错过记账丢失的错误。当函数在另一条执行路径上对已分配的页进行收费时，它可能不会在其中一条执行路径上对该页收费。在这种情况下，MANTA仍然将功能总结为收费，并在以后的分析中忽略丢失帐户的错误。相反，如果MANTA将功能总结为不收费，则会忽略冗余帐户错误。在未来，我们计划采用像SATURN框架这样的路径敏感摘要来提高稳健性。</p>
</li>
<li><p>Dynamic triggerable test is not complete</p>
<p>目前，MANTA使用LTP测试用例来测试是否可以触发静态检测错误。LTP测试用例是有限的。这些测试用例不可能涵盖内核中所有可能的执行路径。</p>
<p>因此，由于不完整的代码覆盖，MANTA可能会错过一些可触发的错误。因此，我们未来的工作之一是开发更多的测试用例，并采用模糊测试技术来增加代码覆盖率。</p>
</li>
</ul>
<h1 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h1><h2 id="Memory-Accounting"><a href="#Memory-Accounting" class="headerlink" title="Memory Accounting"></a>Memory Accounting</h2><p>JRes为JVM实现内存计费接口。内存记帐接口在对象分配期间收取内存使用费用，在垃圾收集期间收取费用。但是，JRes没有为共享对象实现充电机制。</p>
<p>Price等和MzSchem为用户空间运行时环境提出了基于消费者的内存计费方案，以计算子任务的内存使用情况。它们选择向实际用户收取内存使用费用，而不是向内存分配器收取。它们修改运行时垃圾收集器，以便它可以在释放对象之前释放对象，并将其重新充值到保存其引用的实体中。然而，由于在内核中实现足够高效的垃圾收集仍然是一个挑战，因此很难在内核中直接采用它们。基于vm的工作提供了更好的内存隔离，并且可以解决单片内核中的每个进程记帐问题。然而，传统的基于vm的方案过于重量级，并且引入了很高的性能开销。与基于容器的方案相比，基于unikernel的方法实现了更低的启动延迟和更高的吞吐量，但缺乏兼容性。</p>
<p>MANTA的分配-充电映射分析类似于内存泄漏检测中使用的分配-自由映射分析。泄漏检查器使用上下文和路径敏感的分析方法来检测内存泄漏。Saber和FaskCheck使用按需稀疏价值流分析来检测内存泄漏。LeakFix首先尝试定位导致泄漏的空闲内存并修复它。AutoFix通过结合静态分析和运行时检查来检测和修复内存泄漏。PCA使用选择性流敏感算法进一步加快程序间数据流分析的内存泄漏检测。然而，这些工作依赖于手动输入或特定的启发式来决定分配&#x2F;释放接口，这不能应用于识别内存计费接口。</p>
<h2 id="Resource-Accounting"><a href="#Resource-Accounting" class="headerlink" title="Resource Accounting"></a>Resource Accounting</h2><p>Houdini的escape利用内核下半部分的工作线程、服务进程和中断来绕过控制组的限制。然而，它没有关注memcg，也没有分析对照组的实施情况。对比胡迪尼的越狱，我们系统地定义了memcg中可能存在的问题，识别并报告了memcg中的53个bug。Yang等提出了抽象资源的概念，并发现在容器内耗尽这些资源会导致对主机的DoS攻击。资源容器提出了一个操作系统级别的抽象来考虑整个系统的资源使用情况。它是描述在每个线程级别计算一般资源的方法的第一本书。与以前的工作相比，资源容器工作在系统内核上，可以解决由用户线程引起的内核资源消耗。Zhang等提出将内核下半进程的cpu时间使用收费给受影响的用户进程，以提高公平性。</p>
<p>Perez等人观察到EVM的气体计量与工作节点上的实际资源消耗，特别是CPU周期不一致。它表明，当页面缓存工作不佳时，实际的不一致性会进一步增加，而支付者则要为相同数量的gas付费。本文还提出了一种能够充分利用不一致性的自动合成有效载荷的方法。Liu发现CPU时间计量在各种真实的云平台上都很脆弱。他们提出了6种可以利用进程启动时或运行时的CPU计量的攻击。</p>
<h1 id="CONCLUSION-AND-FUTURE-WORK"><a href="#CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="CONCLUSION AND FUTURE WORK"></a>CONCLUSION AND FUTURE WORK</h1><p>本文首次系统地分析和检测了Linux系统中存在的内存记账缺失问题。我们进行了深入的分析，以了解容器平台上内存记账丢失错误的可利用性和安全影响。</p>
<p>我们的分析表明，所有容器运行时(包括正常运行时和安全运行时)都容易受到由记账丢失错误导致的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致节点甚至整个集群崩溃。</p>
<p>然后，我们提出了MANTA，它结合了静态和动态分析技术，以高代码覆盖率和精度自动检测内存记账丢失错误。我们的检测工具报告了53个可利用的内存丢失帐户错误，其中37个已被内核开发人员确认，分配了两个新的cve。结果表明，MANTA可以有效地缓解内存记帐系统中的记账丢失问题。</p>
<p>我们未来的工作是研究如何在不调解所有内存分配&#x2F;自由路径的情况下准确地计算内存使用情况。</p>
]]></content>
      <categories>
        <category>论文精读</category>
        <category>内核安全</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 学习 网络编程 IO多路复用</title>
    <url>/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h1 id="I-x2F-O多路复用（I-x2F-O多路转接）"><a href="#I-x2F-O多路复用（I-x2F-O多路转接）" class="headerlink" title="I&#x2F;O多路复用（I&#x2F;O多路转接）"></a>I&#x2F;O多路复用（I&#x2F;O多路转接）</h1><img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/阻塞等待.png" title alt data-align="center">

<p><img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/BIO%E6%A8%A1%E5%9E%8B.png"></p>
<img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/非阻塞，忙轮询.png" title alt data-align="center">

<img title src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/NIO模型.png" alt data-align="center">

<p><img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/select.png"></p>
<img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll.png" title alt data-align="center">

<p>I&#x2F;O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的系统调用主要有 select、poll 和 epoll。</p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><h2 id="主旨思想"><a href="#主旨思想" class="headerlink" title="主旨思想"></a>主旨思想</h2><ol>
<li><p>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</p>
</li>
<li><p>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行了I&#x2F;O操作时，该函数才返回。</p>
<ul>
<li><p>这个函数是阻塞</p>
</li>
<li><p>函数对文件描述符的检测的操作是由内核完成的</p>
</li>
</ul>
</li>
<li><p>在返回时，它会告诉进程有多少描述符要进行I&#x2F;O操作。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">- nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">- 一般检测读操作</span><br><span class="line">- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲</span><br><span class="line">区</span><br><span class="line">- 是一个传入传出参数</span><br><span class="line">- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span><br><span class="line">- exceptfds : 检测发生异常的文件描述符的集合</span><br><span class="line">- timeout : 设置的超时时间</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line"><span class="type">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line">- <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">- tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">- tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">- 返回值 :</span><br><span class="line">- <span class="number">-1</span> : 失败</span><br><span class="line">- &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set *set);</span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *set)</span></span>;</span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="工作过程分析"><a href="#工作过程分析" class="headerlink" title="工作过程分析"></a>工作过程分析</h2><img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/select工作过程分析.png" title alt data-align="center">

<img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/select多路复用.png" title alt data-align="center">

<h2 id="select代码编写"><a href="#select代码编写" class="headerlink" title="select代码编写"></a>select代码编写</h2><p><strong>server</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, tmp;</span><br><span class="line">    <span class="built_in">FD_ZERO</span>(&amp;rdset);</span><br><span class="line">    <span class="built_in">FD_SET</span>(lfd, &amp;rdset);</span><br><span class="line">    <span class="type">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tmp = rdset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用select系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">select</span>(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(lfd, &amp;tmp)) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="built_in">FD_SET</span>(cfd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">FD_ISSET</span>(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(i, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line">                        <span class="built_in">FD_CLR</span>(i, &amp;rdset);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        <span class="built_in">write</span>(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>client</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> seraddr;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;seraddr, <span class="built_in">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        <span class="built_in">write</span>(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">read</span>(fd, sendBuf, <span class="built_in">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h1><h2 id="select的缺点"><a href="#select的缺点" class="headerlink" title="select的缺点"></a>select的缺点</h2><img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/select的缺点.png" title alt data-align="center">

<h2 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> myfd;</span><br><span class="line"></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT;<span class="comment">//既要读也要写</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd* fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// -参数：</span></span><br><span class="line"><span class="comment">// - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="comment">// - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1</span></span><br><span class="line"><span class="comment">// - timeout : 阻塞时长</span></span><br><span class="line"><span class="comment">//     0 : 不阻塞</span></span><br><span class="line"><span class="comment">//     - 1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span></span><br><span class="line"><span class="comment">//     &gt; 0 : 阻塞的时长</span></span><br><span class="line"><span class="comment">// - 返回值：</span></span><br><span class="line"><span class="comment">//     - 1 : 失败</span></span><br><span class="line"><span class="comment">//     &gt; 0（n） : 成功, n表示检测到集合中有n个文件描述符发生变化</span></span><br></pre></td></tr></table></figure>

<img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/poll参数.png" title alt data-align="center">

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><strong>server</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1024</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">        fds[i].events = POLLIN;</span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="type">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">poll</span>(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="number">1024</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fds[i].fd == <span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fds[i].revents &amp; POLLIN)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="type">int</span> len = <span class="built_in">read</span>(fds[i].fd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        <span class="built_in">close</span>(i);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        <span class="built_in">write</span>(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h1><h2 id="epoll-多路复用"><a href="#epoll-多路复用" class="headerlink" title="epoll()多路复用"></a>epoll()多路复用</h2><img src="/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/epoll多路复用.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检</span></span><br><span class="line"><span class="comment">// 测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向</span></span><br><span class="line"><span class="comment">// 链表）。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">// -参数：</span></span><br><span class="line"><span class="comment">// size : 目前没有意义了。随便写一个数，必须大于0</span></span><br><span class="line"><span class="comment">// - 返回值：</span></span><br><span class="line"><span class="comment">//   - 1 : 失败</span></span><br><span class="line"><span class="comment">//   &gt; 0 : 文件描述符，操作epoll实例的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;</span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 常见的Epoll检测事件：</span></span><br><span class="line"><span class="comment">//   - EPOLLIN</span></span><br><span class="line"><span class="comment">//   - EPOLLOUT</span></span><br><span class="line"><span class="comment">//   - EPOLLERR</span></span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span></span>;</span><br><span class="line"><span class="comment">// -参数：</span></span><br><span class="line"><span class="comment">//  - epfd : epoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">//  - op : 要进行什么操作</span></span><br><span class="line"><span class="comment">//      EPOLL_CTL_ADD : 添加</span></span><br><span class="line"><span class="comment">//      EPOLL_CTL_MOD : 修改</span></span><br><span class="line"><span class="comment">//      EPOLL_CTL_DEL : 删除</span></span><br><span class="line"><span class="comment">//  - fd : 要检测的文件描述符</span></span><br><span class="line"><span class="comment">//  - event : 检测文件描述符什么事情</span></span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span></span></span></span><br><span class="line"><span class="params"><span class="function">    timeout)</span></span>;</span><br><span class="line"><span class="comment">// -参数：</span></span><br><span class="line"><span class="comment">// - epfd : epoll实例对应的文件描述符</span></span><br><span class="line"><span class="comment">// - events : 传出参数，保存了发送了变化的文件描述符的信息</span></span><br><span class="line"><span class="comment">// - maxevents : 第二个参数结构体数组的大小</span></span><br><span class="line"><span class="comment">// - timeout : 阻塞时间</span></span><br><span class="line"><span class="comment">//      - 0 : 不阻塞</span></span><br><span class="line"><span class="comment">//      - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞</span></span><br><span class="line"><span class="comment">//      - &gt; 0 : 阻塞的时长（毫秒）</span></span><br><span class="line"><span class="comment">// - 返回值：</span></span><br><span class="line"><span class="comment">//      - 成功，返回发送变化的文件描述符的个数 &gt; 0</span></span><br><span class="line"><span class="comment">//      - 失败 - 1</span></span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="type">int</span> epfd = <span class="built_in">epoll_create</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epev;</span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> epevs[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                <span class="type">int</span> len = <span class="built_in">read</span>(curfd, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="built_in">close</span>(curfd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    <span class="built_in">write</span>(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line">    <span class="built_in">close</span>(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="epoll的两种工作模式"><a href="#epoll的两种工作模式" class="headerlink" title="epoll的两种工作模式"></a>epoll的两种工作模式</h2><h3 id="LT模式（水平触发）"><a href="#LT模式（水平触发）" class="headerlink" title="LT模式（水平触发）"></a>LT模式（水平触发）</h3><p>在水平触发模式下，当文件描述符（例如，socket）的缓冲区有数据可读时，Epoll 会通知用户。如果用户不处理这些数据（不读取），Epoll 会持续通知用户。用户可以选择读取全部数据，部分数据，或者不读取数据，但是只要缓冲区中还有数据，Epoll 就会一直通知用户。</p>
<p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这<br>种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操<br>作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h2 id="ET模式（边沿触发）"><a href="#ET模式（边沿触发）" class="headerlink" title="ET模式（边沿触发）"></a>ET模式（边沿触发）</h2><p>边沿触发模式与水平触发模式的主要区别在于，Epoll 仅在事件发生时通知用户一次。例如，当文件描述符的缓冲区有数据可读时，Epoll 会通知用户。如果用户不读取数据，那么下次 Epoll 检测到还有数据可读时，就不会再通知用户。用户需要在收到通知后尽可能地读取缓冲区中的全部数据，否则可能错过某些事件。</p>
<p>简单来说，边沿触发模式是当条件由不满足变为满足时（例如，从无数据可读变为有数据可读），Epoll 仅通知用户一次。用户需要在收到通知后尽快处理事件，否则可能错过后续的通知。这种模式通常适用于非阻塞的 socket。</p>
<p>总结一下，水平触发模式（LT）会在事件满足条件时持续通知用户，而边沿触发模式（ET）仅在事件发生时通知用户一次。在实际应用中，根据不同的使用场景和需求，可以灵活选择这两种模式。</p>
<p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述<br>符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，<br>并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述<br>符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成<br>未就绪），内核不会发送更多的通知（only once）。<br>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll<br>工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写<br>操作把处理多个文件描述符的任务饿死。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>C++学习 网络编程 UDP通信</title>
    <url>/2023/06/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><img src="/2023/06/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP%E9%80%9A%E4%BF%A1/UDP通信.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 通信的fd</span><br><span class="line">    - buf : 要发送的数据</span><br><span class="line">    - len : 发送数据的长度</span><br><span class="line">    - flags : <span class="number">0</span></span><br><span class="line">    - dest_addr : 通信的另外一端的地址信息</span><br><span class="line">    - addrlen : 地址的内存大小</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 通信的fd</span><br><span class="line">    - buf : 接收数据的数组</span><br><span class="line">    - len : 数组的大小</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>案例</strong></p>
<p>server</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, recvbuf, <span class="built_in">sizeof</span>(recvbuf), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, Port : %d\n&quot;</span>,</span><br><span class="line">            <span class="built_in">inet_ntop</span>(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="built_in">sizeof</span>(ipbuf)),</span><br><span class="line">            <span class="built_in">ntohs</span>(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">sendto</span>(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="built_in">sizeof</span>(cliaddr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , i am client %d \n&quot;</span>, num++);</span><br><span class="line">        <span class="built_in">sendto</span>(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;saddr, <span class="built_in">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, sendBuf, <span class="built_in">sizeof</span>(sendBuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, sendBuf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。</p>
<ul>
<li><p>只能在局域网中使用。</p>
</li>
<li><p>客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。</p>
</li>
</ul>
<p><img src="/2023/06/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP%E9%80%9A%E4%BF%A1/%E5%B9%BF%E6%92%AD.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置广播属性的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span></span></span></span><br><span class="line"><span class="params"><span class="function">optlen)</span></span>;</span><br><span class="line">- sockfd : 文件描述符</span><br><span class="line">- level : SOL_SOCKET</span><br><span class="line">- optname : SO_BROADCAST</span><br><span class="line">- optval : <span class="type">int</span>类型的值，为<span class="number">1</span>表示允许广播</span><br><span class="line">- optlen : optval的大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>案例</strong></p>
<p>server</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置广播属性</span></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, <span class="built_in">sizeof</span>(op));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.创建广播地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;192.168.194.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , client......%d\n&quot;</span>, num++);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">sendto</span>(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="built_in">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;广播的数据： %s\n&quot;</span>, sendBuf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="组播（多播）"><a href="#组播（多播）" class="headerlink" title="组播（多播）"></a>组播（多播）</h1><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。<br>单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网<br>使用。</p>
<ul>
<li><p>组播既可以用于局域网，也可以用于广域网</p>
</li>
<li><p>客户端需要加入多播组，才能接收到多播的数据</p>
</li>
</ul>
<hr>
<p><strong>组播地址</strong></p>
<table>
<thead>
<tr>
<th align="center">IP地址</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">224.0.0.0~224.0.0.255</td>
<td>局部链接多播地址：是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包</td>
</tr>
<tr>
<td align="center">224.0.1.0~224.0.1.255</td>
<td>预留多播地址：公用组播地址，可用于Internet；使用前需要申请</td>
</tr>
<tr>
<td align="center">224.0.2.0~238.255.255.255</td>
<td>预留多播地址：用户可用组播地址(临时组地址)，全网范围内有效</td>
</tr>
<tr>
<td align="center">239.0.0.0~239.255.255.255</td>
<td>本地管理组播地址，可供组织内部使用，类似于私有 IP 地址，不</td>
</tr>
<tr>
<td align="center"><br>能用于 Internet，可限制多播范围</td>
<td></td>
</tr>
</tbody></table>
<hr>
<p><strong>设置组播</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,<span class="type">const</span> <span class="type">void</span> *optval,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span> optlen)</span></span>;</span><br><span class="line"><span class="comment">// 服务器设置多播的信息，外出接口- level : IPPROTO_IP</span></span><br><span class="line">- optname : IP_MULTICAST_IF</span><br><span class="line">- optval : <span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line"><span class="comment">// 客户端加入到多播组：</span></span><br><span class="line">- level : IPPROTO_IP</span><br><span class="line">- optname : IP_ADD_MEMBERSHIP</span><br><span class="line">- optval : <span class="keyword">struct</span> <span class="title class_">ip_mreq</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ip_mreq</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* IP multicast address of group. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> imr_multiaddr; <span class="comment">// 组播的IP地址</span></span><br><span class="line"><span class="comment">/* Local IP address of interface. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> imr_interface; <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>案例</strong></p>
<p>server</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.设置多播属性，设置外出接口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> imr_multiaddr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化多播地址</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="built_in">sizeof</span>(imr_multiaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.初始化客户端地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> cliaddr;</span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , client......%d\n&quot;</span>, num++);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="built_in">sendto</span>(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr*)&amp;cliaddr, <span class="built_in">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;组播的数据： %s\n&quot;</span>, sendBuf);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">socket</span>(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip_mreq</span> op;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="comment">//加入到多播组</span></span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="built_in">sizeof</span>(op));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="本地套接字通信"><a href="#本地套接字通信" class="headerlink" title="本地套接字通信"></a>本地套接字通信</h1><p>本地套接字的作用：本地的进程间通信</p>
<ul>
<li><p>有关系的进程间的通信（父子进程）</p>
</li>
<li><p>没有关系的进程间的通信</p>
</li>
<li><p>本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。</p>
</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本地套接字通信的流程 - tcp</span></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="number">1.</span> 创建监听的套接字</span><br><span class="line"><span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr;</span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"><span class="built_in">bind</span>(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 监听</span><br><span class="line"><span class="built_in">listen</span>(lfd, <span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span> 等待并接受连接请求</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> cliaddr;</span><br><span class="line"><span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, &amp;cliaddr, len);</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">接收数据：read/recv</span><br><span class="line">发送数据：write/send</span><br><span class="line"><span class="number">6.</span> 关闭连接</span><br><span class="line"><span class="built_in">close</span>();</span><br><span class="line"><span class="comment">// 客户端的流程</span></span><br><span class="line"><span class="number">1.</span> 创建通信的套接字</span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">socket</span>(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的IP 端口</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr;</span><br><span class="line"><span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line"><span class="built_in">bind</span>(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 连接服务器</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> serveraddr;</span><br><span class="line"><span class="built_in">connect</span>(fd, &amp;serveraddr, <span class="built_in">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span> 通信</span><br><span class="line">接收数据：read/recv</span><br><span class="line">发送数据：write/send</span><br><span class="line"><span class="number">5.</span> 关闭连接</span><br><span class="line"><span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>案例</strong></p>
<p>server</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unlink</span>(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="type">int</span> lfd = <span class="built_in">socket</span>(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr;</span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> cliaddr;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="type">int</span> cfd = <span class="built_in">accept</span>(lfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recv</span>(cfd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">send</span>(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>client</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习 项目实战 webserver</title>
    <url>/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/</url>
    <content><![CDATA[<h1 id="阻塞和非阻塞、同步和异步（网络IO）"><a href="#阻塞和非阻塞、同步和异步（网络IO）" class="headerlink" title="阻塞和非阻塞、同步和异步（网络IO）"></a>阻塞和非阻塞、同步和异步（网络IO）</h1><p>典型的一次IO的两个阶段是什么？</p>
<ul>
<li><p>数据就绪：根据系统IO操作的就绪</p>
<ul>
<li>阻塞 - 调用IO方法的线程进入阻塞状态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span>* buf, <span class="type">size_t</span> len,<span class="type">int</span> flags)</span></span>;</span><br><span class="line">interesting</span><br></pre></td></tr></table></figure>

<ul>
<li>非阻塞 - 不会改变进程的状态，通过返回值判断</li>
</ul>
</li>
<li><p>数据读写：根据应用程序和内核的交互方式</p>
<ul>
<li><p>同步</p>
</li>
<li><p>异步</p>
</li>
</ul>
</li>
</ul>
<p>阻塞和非阻塞都是同步的IO，只有使用了特殊的API才是异步IO</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/同步异步API.png" title alt data-align="center">

<p>异步一般与非阻塞结合使用</p>
<hr>
<p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。<br>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。</p>
<h1 id="Unix、Linux上的五种IO模型"><a href="#Unix、Linux上的五种IO模型" class="headerlink" title="Unix、Linux上的五种IO模型"></a>Unix、Linux上的五种IO模型</h1><h2 id="阻塞blocking"><a href="#阻塞blocking" class="headerlink" title="阻塞blocking"></a>阻塞blocking</h2><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/阻塞.png" title alt data-align="center">

<h2 id="非阻塞non-blocking（NIO）"><a href="#非阻塞non-blocking（NIO）" class="headerlink" title="非阻塞non-blocking（NIO）"></a>非阻塞non-blocking（NIO）</h2><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/非阻塞.png" title alt data-align="center">

<h2 id="IO复用（IO-multiplexing）"><a href="#IO复用（IO-multiplexing）" class="headerlink" title="IO复用（IO multiplexing）"></a>IO复用（IO multiplexing）</h2><p>Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/IO复用.png" title alt data-align="center">

<h2 id="信号驱动（signal-driven）"><a href="#信号驱动（signal-driven）" class="headerlink" title="信号驱动（signal-driven）"></a>信号驱动（signal-driven）</h2><p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/信号驱动.png" title alt data-align="center">

<p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。</p>
<h2 id="异步（asynchronous）"><a href="#异步（asynchronous）" class="headerlink" title="异步（asynchronous）"></a>异步（asynchronous）</h2><p>Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/异步.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Asynchronous I/O control block. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">aiocb</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> aio_fildes; <span class="comment">/* File desriptor. */</span></span><br><span class="line"><span class="type">int</span> aio_lio_opcode; <span class="comment">/* Operation to be performed. */</span></span><br><span class="line"><span class="type">int</span> aio_reqprio; <span class="comment">/* Request priority offset. */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> *aio_buf; <span class="comment">/* Location of buffer. */</span></span><br><span class="line"><span class="type">size_t</span> aio_nbytes; <span class="comment">/* Length of transfer. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sigevent</span> aio_sigevent; <span class="comment">/* Signal number and value. */</span></span><br><span class="line"><span class="comment">/* Internal members. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">aiocb</span> *__next_prio;</span><br><span class="line"><span class="type">int</span> __abs_prio;</span><br><span class="line"><span class="type">int</span> __policy;</span><br><span class="line"><span class="type">int</span> __error_code;</span><br><span class="line"><span class="type">__ssize_t</span> __return_value;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line"><span class="type">__off_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line"><span class="type">char</span> __pad[<span class="built_in">sizeof</span> (<span class="type">__off64_t</span>) - <span class="built_in">sizeof</span> (<span class="type">__off_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">__off64_t</span> aio_offset; <span class="comment">/* File offset. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">char</span> __glibc_reserved[<span class="number">32</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Webserver简介和HTTP协议"><a href="#Webserver简介和HTTP协议" class="headerlink" title="Webserver简介和HTTP协议"></a>Webserver简介和HTTP协议</h1><h2 id="Webserver（网页服务器）"><a href="#Webserver（网页服务器）" class="headerlink" title="Webserver（网页服务器）"></a>Webserver（网页服务器）</h2><p>一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息。</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/webserver.png" title alt data-align="center">

<p>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。</p>
<h2 id="HTTP协议（应用层协议）"><a href="#HTTP协议（应用层协议）" class="headerlink" title="HTTP协议（应用层协议）"></a>HTTP协议（应用层协议）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。<br>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p>
<p>尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP&#x2F;IP 协议族使用 TCP 作为其传输层。<br>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p>以下是 HTTP 请求&#x2F;响应的步骤：</p>
<ol>
<li>客户端连接到 Web 服务器<br>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，<a href="http://www.baidu.com.(url)/">http://www.baidu.com。（URL）</a></li>
<li>发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。</li>
<li>服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。</li>
<li>释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li>
<li>客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据HTML 的语法对其进行格式化，并在浏览器窗口中显示。</li>
</ol>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<ol>
<li><p>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>
</li>
<li><p>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</p>
</li>
<li><p>浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>
</li>
<li><p>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</p>
</li>
<li><p>释放 TCP 连接;</p>
</li>
<li><p>浏览器将该 HTML 文本并显示内容。</p>
</li>
</ol>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/HTTP协议过程.png" title alt data-align="center">

<p>HTTP 协议是基于 TCP&#x2F;IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
<h3 id="HTTP请求报文与响应报文格式"><a href="#HTTP请求报文与响应报文格式" class="headerlink" title="HTTP请求报文与响应报文格式"></a>HTTP请求报文与响应报文格式</h3><img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/F12.png" title alt data-align="center">

<p>可以在浏览器界面按F12查看HTTP报文</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/请求报文格式.png" title alt data-align="center">

<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/响应报文格式.png" title alt data-align="center">

<h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p>HTTP&#x2F;1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p>
<ol>
<li>GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</li>
<li>HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li>
<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>
<li>PUT：向指定资源位置上传其最新内容。</li>
<li>DELETE：请求服务器删除 Request-URI 所标识的资源。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*’来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</li>
<li>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的 HTTP 代理服务器）。</li>
</ol>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态<br>的短语，彼此由空格分隔。<br>状态代码的第一个数字代表当前响应的类型：</p>
<ul>
<li><p>1xx消息——请求已被服务器接收，继续处理</p>
</li>
<li><p>2xx成功——请求已成功被服务器接收、理解、并接受</p>
</li>
<li><p>3xx重定向——需要后续操作才能完成这一请求</p>
</li>
<li><p>4xx请求错误——请求含有词法错误或者无法被执行</p>
</li>
<li><p>5xx服务器错误——服务器在处理某个正确请求时发生错误</p>
</li>
</ul>
<p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类别</th>
<th align="center">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">Informational（信息性状态码）</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">Success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">Client Error（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">Server Error（服务器错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<h1 id="服务器编程基本框架"><a href="#服务器编程基本框架" class="headerlink" title="服务器编程基本框架"></a>服务器编程基本框架</h1><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。</p>
<table>
<thead>
<tr>
<th align="center">模块</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">I&#x2F;O处理单元</td>
<td align="center">处理客户连接，读写网络数据</td>
</tr>
<tr>
<td align="center">逻辑单元</td>
<td align="center">业务进程或线程</td>
</tr>
<tr>
<td align="center">网络存储单元</td>
<td align="center">数据库、文件或缓存</td>
</tr>
<tr>
<td align="center">请求队列</td>
<td align="center">各单元之间的通信方式</td>
</tr>
</tbody></table>
<p>I&#x2F;O 处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I&#x2F;O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。<br>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I&#x2F;O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。<br>网络存储单元可以是数据库、缓存和文件，但不是必须的。<br>请求队列是各单元之间的通信方式的抽象。I&#x2F;O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。</p>
<h1 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h1><p>服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor 和 Proactor，同步 I&#x2F;O 模型通常用于实现 Reactor 模式，异步 I&#x2F;O 模型通常用于实现 Proactor 模式。</p>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>使用同步 I&#x2F;O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：</p>
<ol>
<li><p>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</p>
</li>
<li><p>主线程调用 epoll_wait 等待 socket 上有数据可读。</p>
</li>
<li><p>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</p>
</li>
<li><p>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll<br>内核事件表中注册该 socket 上的写就绪事件。</p>
</li>
<li><p>当主线程调用 epoll_wait 等待 socket 可写。</p>
</li>
<li><p>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</p>
</li>
<li><p>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。</p>
</li>
</ol>
<p>Reactor 模式的工作流程：</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/Reactor模式.png" title alt data-align="center">

<h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><p>Proactor 模式将所有 I&#x2F;O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。使用异步 I&#x2F;O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p>
<ol>
<li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li>
</ol>
<p>Proactor 模式的工作流程：</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/Proactor.png" title alt data-align="center">

<h2 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h2><p>使用同步 I&#x2F;O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。<br>使用同步 I&#x2F;O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：</p>
<ol>
<li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li>
<li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li>
<li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更<br>多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事<br>件表中注册 socket 上的写就绪事件。</li>
<li>主线程调用 epoll_wait 等待 socket 可写。</li>
<li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li>
</ol>
<p>同步 I&#x2F;O 模拟 Proactor 模式的工作流程：</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/模拟Proactor.png" title alt data-align="center">

<h1 id="线程同步机制类封装及线程池实现"><a href="#线程同步机制类封装及线程池实现" class="headerlink" title="线程同步机制类封装及线程池实现"></a>线程同步机制类封装及线程池实现</h1><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式：</p>
<ul>
<li><p>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</p>
</li>
<li><p>主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。</p>
</li>
</ul>
<p>线程池的一般模型为：</p>
<img src="/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/线程池模型.png" title alt data-align="center">

<ul>
<li><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。</p>
</li>
<li><p>空间换时间，浪费服务器的硬件资源，换取运行效率。</p>
</li>
<li><p>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</p>
</li>
<li><p>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。</p>
</li>
<li><p>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。</p>
</li>
</ul>
<hr>
<p><strong>线程池代码实现</strong></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>项目实战</category>
      </categories>
  </entry>
  <entry>
    <title>论文阅读 How to Get More Value From Your File System Directory Cache</title>
    <url>/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/</url>
    <content><![CDATA[<p><strong>Abstract</strong></p>
<p>应用程序经常请求文件系统操作来遍历文件系统目录树,例如打开文件或读取文件元数据。因此,在内存中缓存文件系统目录结构和元数据对操作系统内核的性能优化非常重要。</p>
<p>本文确定了几个设计原则,可以在应用程序和文件系统透明的情况下显著提高命中率并降低命中成本。具体而言,我们的目录缓存设计可以在恒定数量的散列表操作中查找目录,将查找路径与权限检查分离,对访问控制检查的结果进行记忆化,使用签名加速查找,并通过缓存目录完整性降低未命中率。</p>
<p>该设计可以满足POSIX、Linux安全模块、命名空间和装入别名等差异性要求的一系列要求。这些优化对实际应用程序是一个重要的净改进,例如可以将Dovecot IMAP服务器的吞吐量提高12%,并将updatedb实用程序的吞吐量提高29%。</p>
<blockquote>
<ul>
<li><p>文件系统目录缓存是将文件系统的目录结构和元数据信息缓存在内存中的技术。它的主要目的是提高文件系统操作的性能。</p>
<p>文件系统目录缓存的主要思想是:应用程序在访问文件系统时,大部分操作是在已访问过的目录下进行的。如果能将这些目录信息缓存在内存中,那么应用程序访问这些目录时就不需要再去实际的文件系统中加载目录信息,可以直接从缓存中获取,这样可以大大减少对文件系统的访问,提高性能。</p>
<p>文件系统目录缓存会缓存诸如:</p>
<ol>
<li><p>目录结构:将整个目录树缓存在内存中,包括子目录,文件等信息。</p>
</li>
<li><p>目录元数据:每个目录的元数据,如inode号,大小,权限,所有者等信息。</p>
</li>
<li><p>文件元数据:每个文件的元数据,如inode号,大小,权限,所有者等信息。</p>
</li>
<li><p>权限信息:已检查过的目录和文件的权限信息,避免重复检查。</p>
</li>
<li><p>签名信息:目录和文件的签名,用于加速查找。</p>
</li>
</ol>
<p>通过缓存这些信息,应用程序可以避免大量的文件系统访问,直接从缓存中获取需要的信息,从而提高性能。这对文件系统的操作密集型应用程序有很大帮助,如邮件服务器,数据库等。</p>
<p>所以,文件系统目录缓存的关键是通过缓存来减少文件系统访问,在应用程序与文件系统之间添加一层缓存,提高整体的目录操作性能。这是操作系统在管理文件系统与提高性能方面常用的一种技术手段。</p>
<hr>
</li>
<li><ol>
<li><p>应用程序经常需要遍历文件系统目录树来进行文件系统操作,如打开文件或读取文件元数据。这需要频繁访问文件系统,对操作系统内核的性能有很大影响。</p>
</li>
<li><p>因此,在内存中缓存文件系统目录结构和元数据信息可以显著优化操作系统内核的性能。这是因为应用程序可以直接从缓存中获取信息,避免访问文件系统。</p>
</li>
<li><p>本文提出了一些目录缓存的设计原则,可以在应用程序和文件系统之间transparently提高命中率和降低未命中成本。transparently意味着应用程序不需要改变代码,缓存的使用对其透明。</p>
</li>
<li><p>目录缓存设计使用散列表在恒定次数的操作中查找目录,可以加速目录查找。散列表是一种高效的数据结构,可以在固定次数内查找到信息。</p>
</li>
<li><p>将查找路径和权限检查分离,意思是首先查找目录,然后再进行权限检查。这避免了在权限检查时重复查找目录,提高性能。</p>
</li>
<li><p>对访问控制检查的结果进行记忆化,意思是缓存文件或目录的权限信息,避免下次再检查,提高性能。</p>
</li>
<li><p>使用签名加速查找,使用目录文件签名(如CRC码)进行查找,避免字符串比对,加速查找。</p>
</li>
<li><p>通过缓存目录完整性降低未命中率,意思是缓存整个目录树信息,使应用程序可以在缓存中完成大部分操作,避免访问文件系统,减少未命中。</p>
</li>
<li><p>该设计可以符合各种要求,如POSIX、Linux安全模块、命名空间和装入别名等,所以可以广泛使用。</p>
</li>
<li><p>该设计对实际应用程序有明显改进,可以提高Dovecot IMAP服务器12%的吞吐量,updatedb工具29%的吞吐量,展示了该方案的优异性能。</p>
</li>
</ol>
<hr>
</li>
</ul>
</blockquote>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>操作系统内核通常在虚拟文件系统(VFS)层中缓存文件系统数据和元数据,该层将底层文件系统抽象为常见API(如POSIX)。</p>
<blockquote>
<ul>
<li><p>指Linux内核。VFS是Linux内核中的一层,它虚拟化了底层的文件系统,如ext4、xfs等。VFS层会缓存从这些底层文件系统读取的数据和元数据(如文件属性)。VFS层对上层应用程序来说隐藏了底层文件系统的细节,它提供了常用的文件系统API,如POSIX接口。这使得应用程序可以通过VFS层访问底层不同的文件系统,而不需要关心它们的差异。</p>
<p>计算机底层的指令系统是不同的,如x86和ARM架构的指令系统不同。但我们编程时使用的指令是一致的,如加法指令都是+,这是因为编程语言将底层不同的指令系统虚拟化成一致的指令接口。程序员使用这一接口,不需要关心底层指令的差异。</p>
<p>同样,虚拟机将不同的物理计算机虚拟化成同一逻辑计算机,从而运行相同的操作系统和应用程序。虚拟机屏蔽了底层不同的物理机,为最终用户提供了统一的计算机接口。</p>
<p>所以,总结来说,虚拟化通过抽象和隐藏底层的差异与实现细节,提供了更高层的统一逻辑接口。这使得高层用户(如应用程序或最终用户)无需关心底层的异构与复杂性,可以更简单地使用接口所提供的功能。</p>
<p>VFS层虚拟化文件系统,就是采取这样的方式,将不同的文件系统抽象成统一的文件系统接口,屏蔽底层文件系统之间的差异,为应用程序和用户提供简单的文件系统操作方法。这有效地隔离了上层的Linux内核与应用程序与底层具体的文件系统实现。</p>
<hr>
</li>
<li><p>POSIX定义了一套统一的操作系统接口标准,包括API、系统调用、实用程序等,使得应用程序可以在不同的操作系统上移植和运行。Linux等操作系统都实现了POSIX接口,使得Linux下的应用程序可以很容易在其他POSIX兼容系统中使用。</p>
<p>VFS层提供的POSIX接口,就是遵循POSIX标准,实现了诸如open、read、fork等操作系统调用和API,从而屏蔽了底层文件的系统差异,使应用程序可以直接使用POSIX接口访问各种文件系统。</p>
</li>
</ul>
</blockquote>
<p>缓存层已经成为隐藏持久存储技术(如本地磁盘)访问延迟的普遍优化手段。目录缓存不仅仅是性能优化;它还简化了安装多个文件系统、一致的文件句柄行为和高级安全模型(如SELinux)的实现。</p>
<blockquote>
<ul>
<li><p>缓存层指的是在系统设计中加入的缓存机制,用于暂存数据或计算结果,从而优化性能。在这里,缓存层特指操作系统在虚拟文件系统(VFS)与具体文件系统之间加入的目录缓存机制。目录缓存缓存了文件系统的目录结构、元数据与访问信息,使VFS层可以直接从缓存中获取这些信息,减少对底层文件系统的访问,优化整体的文件系统性能。</p>
<hr>
</li>
<li><p>目录缓存可以简化在一个系统上安装和使用多个文件系统。因为目录缓存抽象了底层文件系统的差异,使上层可以以同一方式访问不同的文件系统。</p>
<hr>
</li>
<li><p>文件句柄是应用程序访问文件时使用的一个抽象接口。通过目录缓存,应用程序可以使用相同的文件句柄接口访问不同的文件系统,而不需要关心底层文件系统的差异与实现细节。</p>
<p>文件句柄是应用程序访问文件时使用的一个抽象表示。应用程序可以通过文件名打开一个文件,获取代表该文件的文件句柄,然后使用文件句柄对文件进行各种操作,如读写等,而不再指定文件名。</p>
<p>举个例子,在C语言中,应用程序可以通过fopen()函数使用文件名打开一个文件,获取FILE类型的文件句柄:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后应用程序可以通过文件句柄fp对文件进行操作:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fread(buf, <span class="number">1</span>, <span class="number">10</span>, fp);  <span class="comment">// 从文件读取10个字节</span></span><br><span class="line">fwrite(buf, <span class="number">1</span>, <span class="number">10</span>, fp); <span class="comment">// 向文件写入10个字节</span></span><br><span class="line">fclose(fp);              <span class="comment">// 关闭文件 </span></span><br></pre></td></tr></table></figure>

<p>在这里,FILE *fp就是文件file.txt的文件句柄,应用程序通过它对文件进行访问,而不再指定文件名。</p>
<p>所以,文件句柄的作用是:</p>
<ol>
<li><p>将文件在应用程序中的表示抽象化,屏蔽了底层文件的实现细节与差异。</p>
</li>
<li><p>使应用程序可以通过统一的文件句柄接口访问不同的文件,而不需要关心每种文件对应的实现方法。</p>
</li>
<li><p>方便应用程序通过文件句柄快速访问文件,而不需要反复指定文件名。</p>
</li>
</ol>
<p>返回到这句话,它表达的意思是:通过目录缓存,应用程序可以使用同样的文件句柄接口访问不同种类的文件系统,而不需要关心底层文件系统的差异。这是因为目录缓存抽象了底层文件系统的细节,为应用程序提供了统一的文件访问接口。</p>
</li>
</ul>
</blockquote>
<p>目录缓存对良好的应用程序性能至关重要。许多常见的系统调用必须对文件路径进行操作,这需要目录缓存查找。例如,iBench系统调用跟踪中的10-20%的系统调用执行路径查找。</p>
<blockquote>
<p>许多系统调用，如：open\stat\unlink等都需要使用文件的路径作为参数。这些系统调用在执行时,需要查找目录以定位文件,这需要目录缓存的支持。有10-20%的系统调用会执行路径查找。</p>
</blockquote>
<p>图1列出了几种常见的命令行应用程序在执行基于路径的系统调用时花费的总执行时间的百分比(有关这些应用程序和测试机器的更多详细信息,请参阅§6)。我们注意到,这些系统调用包括路径查找以外的工作,这些数字包括一些检测开销;尽管如此,除rm外,系统调用时间和计数以stat和open为主,其中路径查找是执行时间的重要组成部分。对于这些应用程序,基于路径的系统调用占总执行时间的6-54%。这意味着<mark>降低路径查找延迟</mark>是内核提高这些应用程序执行时间的最大机会之一。  </p>
<p><img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图1.png" title alt data-align="center">不幸的是,即使目录缓存命中也是昂贵的——我们的测试Linux系统上的<code>stat</code>为 0.3-1.1微秒,相比之下<code>getppid</code>只有0.04微秒,4 KB预读只有0.3微秒。这个问题在Linux内核社区尤其受到重视,该社区对其目录缓存进行了重大修订和越来越复杂的优化,以降低其命中成本,例如从读取路径中删除锁或在重试循环中用死锁避免替换锁定顺序。图2 plotting目录缓存命中延迟与Linux几个版本中更改的目录缓存代码行数,使用测试系统上的路径到inode查找微基准。这些努力已将命中延迟从2011年到2013年提高了47%,但在过去三年中已停滞不前。  </p>
<p>问题的根源似乎是POSIX路径权限语义要求与路径组件数量线性相关的工作,并严重限制内核开发人员的实现选项。<mark>例如,要打开&#x2F;X&#x2F;Y&#x2F;Z文件,必须对父目录&#x2F;、&#x2F;X和&#x2F;X&#x2F;Y有搜索权限,并且有权访问文件Z。Linux实现简单地从上至下遍历目录树以检查权限。</mark>不幸的是,当关键路径以指针为基础的数据结构(在某些体系结构上包含多核一致性的内存屏障)主导时,现代CPU最终由难以预取加载而停滞。此外,由于如此多的Linux功能是建立在此行为之上的,例如Linux 安全模块(LSM)、命名空间和安装别名,所以如果不破坏与其他Linux内核功能的后向兼容性,任何数据结构增强似乎都是不可能的。在理论上,不明显是否有更快的查找算法(如单一散列表查找)可以满足这些API规范和内核内部要求;据我们所知,以前没有人尝试过。</p>
<p>本文提出了目录缓存的一种分解,可以使大多数查找操作用单个散列表查找执行(§3),以及基于缓存中已有但未有效利用的信息优化以减少未命中率的优化(§5)。我们的设计通过几个关键性见解维持兼容性(§4),包括如何将路径索引与检查父权限分离,以及如何有效和安全地记忆访问控制检查的结果。</p>
<blockquote>
<ol>
<li><p>一种将目录缓存分解的方案,能使用<mark>散列表</mark>提高大多数查找的性能。</p>
</li>
<li><p>基于目录缓存中未充分利用的信息,提出的一些优化方法,以减少未命中率。</p>
</li>
<li><p>通过保持与Linux内核兼容性的几个关键设计,实现以上提高性能和减少未命中率的方案。这些关键设计包括分离路径索引和父目录权限检查、安全有效地缓存访问控制检查结果等。</p>
</li>
<li><p>作者认为,这种设计可以大幅提高目录缓存性能,解决目前Linux内核目录缓存的性能问题。</p>
</li>
</ol>
</blockquote>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图2.png" title alt data-align="center">

<p>我们的优化提高了频繁查找操作的性能,但引入了几个成本,详见§3和§6,我们认为这些成本是可以接受的,并且对应用程序而言是一个净改进。</p>
<ul>
<li><p>首先,这些优化会减慢对目录层次结构的不频繁修改,如目录的重命名、chmod和chown。然而,这些较慢的操作在iBench跟踪中占系统调用的不到0.01%。</p>
</li>
<li><p>其次,dcache的内存开销增加。</p>
</li>
<li><p>第三,查找由于签名冲突而有错误的可能性,可以调整为可以忽略不计且处于数据重复数据删除系统广泛使用的可接受阈值内。</p>
</li>
</ul>
<p>在图2的微基准测试中,我们的目录缓存优化提高了lookup延迟26%,超过未修改的Linux。</p>
<p>本文证明这些技术可以<mark>提高频繁使用目录缓存的应用程序的性能,而对于不受益的应用程序的危害则很小</mark>。这些变化封装在VFS中——单个文件系统不必更改其代码。本文描述了在Linux 3.14中实现这些改进的原型。第2节解释了Mac OS X、FreeBSD和Solaris的目录缓存结构相当相似,这些原理应该具有普遍性。</p>
<hr>
<p>本文的贡献如下:</p>
<ul>
<li><p>对路径查找成本和改进缓存命中延迟机会的性能分析。</p>
</li>
<li><p>目录缓存设计,通过如下技术改进路径查找延迟:</p>
<ul>
<li><p>按完整路径索引目录缓存,将平均情况下的查找从路径组件数量的线性减少到常量。</p>
</li>
<li><p>前缀检查缓存(PCC),将权限检查与路径缓存分离。PCC记忆权限检查,与LSM兼容。</p>
</li>
<li><p>使用路径签名减少检查散列桶冲突的成本。</p>
</li>
</ul>
</li>
<li><p>识别利用内核已经拥有的元数据减少未命中率的机会,如跟踪目录是否完全在缓存中。</p>
</li>
<li><p>仔细处理许多微妙的边缘情况,这些情况会阻碍这些技术的机械应用,例如与符号链接和Linux命名空间的集成。</p>
</li>
<li><p>这些优化的全面评估。例如,我们的优化提高了Dovecot IMAP服务器的吞吐量最高达12%,updatedb的延迟最高达29%。</p>
</li>
</ul>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>本节首先回顾目录缓存必须支持的Unix目录语义;然后解释了目录缓存是如何在现代操作系统中实现的，包括Linux、FreeBSD、Solaris、Mac OS X和Windows。</p>
<h2 id="Unix-Directory-Hierarchy-Semantics"><a href="#Unix-Directory-Hierarchy-Semantics" class="headerlink" title="Unix Directory Hierarchy Semantics"></a>Unix Directory Hierarchy Semantics</h2><p><mark>目录缓存执行的最常见操作是查找，它将路径字符串映射到内存中的索引节点结构</mark>。查找由所有基于路径的系统调用调用，包括open、stat和unlink。查找包括检查用户是否具有从进程的根目录或当前工作目录到文件的适当搜索权限，我们称之为前缀检查(prefix check)。</p>
<p>例如，为了让Alice读取<code>/home/ Alice / x</code>，她必须具有目录<code>/</code>、<code>/home</code>和<code>/home/ Alice</code>的<strong>搜索权限</strong>，以及文件x的<strong>读权限</strong>。为了节约起见，目录上的执行权限位编码了搜索权限。**搜索与读权限的不同之处在于，搜索只允许用户查询文件是否存在，但不能枚举文件的内容(暴力破解除外)**。SELinux和其他经过安全加固的Linux变体可以根据执行位之外的许多因素确定搜索权限，例如进程的角色或目录的扩展属性。</p>
<h2 id="Linux-Directory-Cache"><a href="#Linux-Directory-Cache" class="headerlink" title="Linux Directory Cache"></a>Linux Directory Cache</h2><p>Linux目录缓存(dcache)缓存dentry(目录条目)结构，它将路径映射到文件(或目录、设备等)的内存inode(其他Unix系统将索引节点的vfs级表示称为vnode)。inode存储与文件相关的元数据，如大小、权限和所有权，以及指向索引内存文件内容的基数树的指针。每个dentry至少由四个不同的结构跟踪:</p>
<ul>
<li><p>分层树结构，其中每个父节点都有一个未排序的、双链的子节点列表。</p>
</li>
<li><p>一个哈希表，以父节点虚拟地址和文件名为键。</p>
</li>
<li><p>别名列表，跟踪与给定索引节点相关联的硬链接。</p>
</li>
<li><p>LRU列表，用于根据需要压缩缓存。</p>
</li>
</ul>
<p>Linux将前缀检查与查找本身集成在一起，一次搜索一个组件的路径和检查权限。lookup不是直接使用树结构，而是使用散列表搜索每个组件。对于较大的目录，哈希表查找将比搜索未排序的子列表快。分层树结构的主要用途是自底向上驱逐条目，以维护隐式不变性，即任何条目的所有父条目也必须在缓存中。尽管所有dentry都存储在按路径键的哈希表中，但权限检查实现在哈希表中查找每个路径组件。</p>
<p><mark>Linux存储负dentry(negative dentries)，它缓存已知文件不存在于磁盘上的事实。</mark>负dentries的一个常见示例是在由环境变量指定的多个路径上搜索文件，例如<code>LD LIBRARY PATH</code>。</p>
<p><strong>Current dcache optimizations</strong></p>
<p>图2所示的大部分dcache优化工作都改善了缓存命中延迟，主要是通过减少使用读-复制更新(RCU)的查找函数中的同步成本。</p>
<p>RCU消除了读操作所需要的原子指令。其他Unix系统将索引节点的vfs级表示称为vnode。</p>
<p>锁定和对单个dentry进行引用计数，将一些额外的工作推到不经常修改目录结构的代码上，例如重命名和取消链接。</p>
<p>最新的Linux内核在检查路径权限时也使用乐观同步，使用序列锁(本质上是版本计数器)来检测子树何时可能与遍历同时发生更改。如果乐观快速路径由于并发修改而失败，内核将返回到使用父节点和子节点交替锁定的慢路径。</p>
<p>由于Linux开发人员社区已经在优化其dcache方面投入了大量精力，因此我们在本文中使用Linux作为案例研究。本文中的优化不是特定于linux的，但在某些情况下，构建在其他内核可以采用的优化之上。</p>
<h2 id="Other-Operating-Systems"><a href="#Other-Operating-Systems" class="headerlink" title="Other  Operating Systems"></a>Other  Operating Systems</h2><h3 id="FreeBSD-OS-X-and-Solaris"><a href="#FreeBSD-OS-X-and-Solaris" class="headerlink" title="FreeBSD, OS X, and Solaris."></a>FreeBSD, OS X, and Solaris.</h3><p>这些Unix变体都有一个目录缓存，其结构类似于Linux的[25,28,39]。每个系统都使用散列表组织其目录缓存，每次检查一个组件的路径，并存储负条目。在这里，我们使用FreeBSD作为BSD家族的一个代表性例子，根据最近的调查，它是最受欢迎的。OS X内核采用了FreeBSD的文件系统，并没有实质性地改变它们在目录元数据缓存方面的行为。</p>
<p>Linux的独特之处在于，hit路径避免调用低级文件系统，而其他Unix变体总是调用低级文件系统。低级文件系统可以选择退出默认结构，如果它有更专门的结构，比如大型目录，或者它可以直接实现自己的查找函数。直接管理文件系统的缓存部分是有问题的，因为对低级文件系统不可见挂载点。之前的一些研究发现这种限制很麻烦，特别是对于网络文件系统。这些Unix变体也没有在缓存中使用乐观同步，但这不是基本的。</p>
<p>Solaris dcache，称为直接名称查找缓存(DNLC)，具有复杂的缓存管理启发式，例如在替换决策中权衡相关性和时间局域性Solaris也有一个比FreeBSD更简单的缓存路径参考管理系统(更类似于Linux)。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows中的几乎所有的操作系统API抽象都由对象管理器表示。对象管理器是最接近Unix目录缓存的类比,它跟踪层次路径和权限。不幸的是,Windows内部结构的公开文档有限,尤其是对于未被动用的元数据的内部数据结构和缓存策略,所以详细比较困难。尽管如此,我们可以比较一些高级设计选择的影响。</p>
<p>首先,Windows只支持一种根文件系统格式,和非常有限的其他文件系统。因此,对文件系统元数据的一般目的的内存组织没有太大价值,Windows没有vnodes,dentries或其他VFS层面的概括。相反,缓存主要是文件系统的责任,磁盘和内存结构布局可能相同。</p>
<p>与Unix变种不同,当Windows文件系统路径没有缓存在对象管理器中时,底层文件系统负责解析完整路径,而不是一次解析一个组件。为此,Windows NT也将父目录权限传播到每个子目录的磁盘元数据,在创建或修改时间。这种方法可以直接查找,但也会产生一点易管理性问题。假设Alice使她的主目录对所有人可读:这个更改是否应传播到所有子目录?为了回答这个问题,Windows采用一个错误易发生的启发法,不改变手动修改的子权限。本文展示如何在内存中保留直接查找的性能优势,而不存储传播的分层权限在磁盘上产生的管理性问题。</p>
<h3 id="Opportunities-for-Improvement"><a href="#Opportunities-for-Improvement" class="headerlink" title="Opportunities for Improvement"></a>Opportunities for Improvement</h3><p>图3显示了Linux中路径查找的主要组件所花费的时间，其中四个路径的长度不断增加。</p>
<p>对查找时间的第一阶影响是路径本身的长度，它决定了对每个组件进行哈希、在哈希表中查找以及对每个目录的索引节点执行权限检查的次数。这些成本在路径组件的数量上是线性的。</p>
<p>本文中描述的命中延迟优化使大多数这些操作的时间不变，除了散列，它仍然是路径长度的函数。</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图3.png" title alt data-align="center">

<h1 id="Minimizing-Hit-Latency"><a href="#Minimizing-Hit-Latency" class="headerlink" title="Minimizing Hit Latency"></a>Minimizing Hit Latency</h1><p>本节描述dcache命中路径的算法改进。在缓存命中情况下,最昂贵的操作之一是检查进程的凭据是否允许进程从上到下搜索dentry路径(称为前缀检查prefix check)。本节展示了如何通过缓存前缀检查结果显着降低命中延迟。本节解释了优化方案,如何将其集成到现有的Linux目录缓存框架中,如何使这些缓存结果与其他文件系统操作保持一致,以及如何使用路径签名进一步加速查找。</p>
<h2 id="Caching-Prefix-Checks"><a href="#Caching-Prefix-Checks" class="headerlink" title="Caching Prefix Checks"></a>Caching Prefix Checks</h2><p>像许多Unix变体一样，Linux在哈希表中存储缓存的路径到索引节点映射(dentry)(§2.2)。这个散列表由父条目的虚拟地址和下一个路径组件字符串的组合作为键值，如图4所示。内核对象的虚拟地址不会随着时间的推移而改变，并且在各个进程之间是相同的。</p>
<p>在实践中，前缀检查具有高度的空间和时间局部性，非常适合缓存，即使这意味着将一些额外的工作推到不经常修改的目录结构上(例如，重命名目录)。RCU已经做了这个权衡(§2.2)。</p>
<p>为了缓存前缀检查结果，我们必须首先将查找dentry与前缀检查解耦。我们添加了第二个系统范围的哈希表，专门用于查找dentry，称为直接查找哈希表(DLHT)。DLHT存储最近访问的按完整的、规范化的路径散列的dentry。dentry通常存在于主哈希表中，也可能存在于DLHT中。DLHT是惰性填充的，为了与目录树修改保持一致，条目可以被删除(§3.2)。</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图4.png" title alt data-align="center">

<p>每个进程在与进程凭据(在4.1节中进一步讨论)关联的前缀检查缓存(PCC)中缓存以前前缀检查的结果,可以在具有相同权限的进程之间共享。PCC是一个散列表,缓存dentry虚拟地址和版本号(序列锁),用于检测陈旧条目(3.2节)。当前缀检查通过时,表示凭据被允许访问dentry,则将条目添加到PCC;根据LRU策略替换条目。PCC中的未命中可以表示权限被拒绝或权限检查最近未执行。</p>
<p>因此，给定任何路径，内核都有一个直接查找DLHT中的路径的快速路径。如果快速路径在DLHT中命中，则在进程的PCC中查找该齿列。</p>
<p>如果找到PCC条目并且版本计数器与缓存的计数器匹配，则使用缓存的前缀检查结果。</p>
<p>如果DLHT或PCC中的快速路径查找丢失，或者PCC条目中的版本计数器比dentry更老，则代码将返回到原始的Linux查找算法(慢路径)，只使用主哈希表并一次遍历一个组件。</p>
<p>在相对路径的情况下，例如目录<code>/home/alice</code>下的<code>foo/bar</code>，我们有效地将相对路径和当前工作目录的路径连接起来。为了实现相对路径，Linux已经在每个进程描述符(任务结构)中存储了一个指向当前工作目录条目的指针。我们没有对字符串进行记忆，而是在每个条目中存储哈希函数的中间状态，以便可以从任何前缀恢复哈希。</p>
<p>当前的设计包括两种非常罕见的边缘情况。首先，可以释放dentry并使用陈旧的PCC条目重新分配。我们通过使用单调递增的版本号初始化新分配的dentry来检测这种情况，允许PCC条目在重新分配时检测过时。释放一个牙齿将它从DLHT中移除。其次，版本号可以在新条目或重命名、chmod或非空目录的城镇的每2^32次初始化之后环绕;我们的设计目前通过使所有活动的pcc无效来处理封装。</p>
<p>图5说明了对Linux dentry结构的修改。快速dentry存储签名、标志、序列计数、挂载点、用于管理深度目录条目的列表(第5.2节)，以及用于将快速dentry添加到DLHT bucket的列表(哈希链)。PCC被添加到内核凭据结构(struct cred)中，并存储一个可调数量的由指针和序列号组成的元组;用64kb的PCC对系统进行评估。由于每个dentry指针的最高位和最低位是相同的，PCC只存储唯一的指针位(x86 64 Linux中的8-39位)以节省空间。</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图5.png" title alt data-align="center">

<h2 id="Coherence-with-Permission-and-Path-Changes"><a href="#Coherence-with-Permission-and-Path-Changes" class="headerlink" title="Coherence with Permission and Path Changes"></a>Coherence with Permission and Path Changes</h2><p>当目录或目录结构的权限被更改时(例如使用chmod或rename)，任何包含该目录的缓存前缀检查都必须无效。</p>
<p>我们的设计通过在更改层次结构之前使相关的PCC和DLHT条目失效，防止过时的慢路径查找被重新缓存，并利用vfs级同步来确保正确的慢路径行为，从而确保并发查找和更改的安全性。</p>
<p>首先，我们确保在更改目录结构后，快速路径查找不能使用陈旧的数据完成。</p>
<p>在发生突变(如重命名或chmod)之前，操作必须递归遍历dcache中的所有子节点，并增加<code>fast_dentry</code>版本计数器(seq)。</p>
<p>每个进程的PCC使用<code>fast_dentry</code>版本计数器来检测查找时缓存前缀检查的变化;增加此版本计数器将使该条目的所有PCC项无效，而无需直接修改每个PCC。对目录结构的更改(例如，mount和rename)也会从直接查找哈希表(DLHT)中删除新旧路径下的dentry。PCC和DLHT表项在慢路径上缓慢地重新填充。</p>
<p>其次，通过使用原子的全局序列计数器(invalidation)，我们确保不能将过时的慢路径查找的结果重新添加到DLHT或PCC中。在慢路径遍历之前和之后读取序列计数器;只有当计数器没有改变时，结果才被添加到DLHT和PCC中，这意味着没有并发关机。</p>
<p>第三，我们使用vfs级同步来确保慢路径与突变正确同步。例如，rename获取全局重命名锁序列锁，以及新旧父目录上的每个条目锁。当使用重命名锁进行写操作时，慢路径(即当前Linux代码)上的所有查找都必须以一种从根目录(或当前工作目录，对于相对路径)到目标子目录的交替方式锁定每个条目。在重命名完成之前，目标条目上的锁会阻止交替遍历。无效计数器防止缓存在获取dentry锁之前已经通过此点的慢路径查找的结果。我们的实现遵循VFS现有的锁定原则来避免死锁;它添加了版本计数器来检测不一致性，并退回到慢路径。</p>
<p>因此，相关的PCC和DLHT条目在重命名开始之前就已经失效了，阻断了快速路径； 慢速路径的遍历将被阻止，直到重命名完成和每个条目的锁被释放；并且一个序列计数器 序列计数器确保只有观察到新路径的慢速路径遍历可以重新填充DLR的 路径可以重新填充DLHT和PCC。<br>这些递归的遍历将目录权限和结构的变化从恒定的时间转变为与子树的大小成线性关系。子树的大小。作为一个例子，重命名或chmod一个有10,000个子目录，最多深度为4的目录需要大约需要330微秒来完成。在最初的Linux内核中，重命名和chmod几乎是恒定时间操作，只需要4.5和1.1微秒。一些应用程序，如aptitude或rsync，依靠rename来原子化地替换一个目录，但这只占其总工作的一小部分，而且比查找的频率低几个数量级，这使得总体上是一个很好的权衡。</p>
<p><strong>Directory References</strong> </p>
<p>Unix的语义允许人们cd进入一个目录，并在随后的权限改变后继续在该目录中工作，否则将禁止进一步访问。例如，假设一个进程在工作目录&#x2F;foo&#x2F;bar中，foo的权限发生了变化，使得该进程在未来不能进入bar。只要该进程不离开该目录或退出，该进程就应该能够继续打开bar下的文件。类似的语义也适用于打开的目录柄。在我们的设计中，这样的权限变化最终会导致一个被封锁的PCC条目，而快速路径查询将违反预期行为。我们的设计通过检查 打开的引用在PCC中是否仍然被允许。如果PCC有一个 更多的条目，将阻止重新打开这个句柄、查询将被强制采用慢速路径，并且这个陈旧的结果不会被添加到PCC中。结果不会被添加到PCC中。</p>
<h2 id="Accelerating-Lookuos-with-Signatures"><a href="#Accelerating-Lookuos-with-Signatures" class="headerlink" title="Accelerating Lookuos with Signatures"></a>Accelerating Lookuos with Signatures</h2><p>我们优化的查找使用240位签名来最小化密钥比较的成本。Linux通过链接在哈希表中查找dentry。当哈希表键是一个相对较短的路径组件时，简单地比较键的成本是可以接受的。但是，Linux上的完整路径最多可以有4,096个字符，即使比较中等长度的字符串也会损害直接查找的算法优势。我们可以通过创建路径的签名来避免这个开销，这样可以最小化键比较的开销。</p>
<p>使用签名会带来冲突的风险，这可能导致系统将路径映射到错误的入口。</p>
<p>我们首先解释签名碰撞如何在我们的设计中导致问题，然后解释所需的抗碰撞属性，最后解释我们如何选择签名大小以使这种风险最小化。</p>
<p><strong>Signature collisions</strong></p>
<p>当用户查找路径时，我们的设计首先计算规范化路径的签名，在全局DLHT中查找散列，如果DLHT中有命中，则在每个凭据PCC中查找dentry和序列号。</p>
<p>如果具有相同签名的另一个文件的dentry已经在DLHT中，并且该dentry在PCC中，则用户可能打开错误的文件。例如，如果Alice打开了带有X签名的文件<code>/home/alice/foo</code>，然后打开了同样带有X签名的文件<code>/home/alice/bar</code>，她的第二次打开实际上会创建一个文件foo的句柄。这就产生了一种担忧，即用户可能会由于自己的过错而损坏自己的文件。可以根据签名大小将此风险配置为非常小(下面将讨论)。</p>
<p>任何不正确的查找结果必须是进程(或具有相同凭据的另一个进程)有权访问的文件。要使快速路径查找返回任何内容，必须在任务的PCC中有匹配的dentry指针，该PCC对于具有相同凭据的任务是私有的。因此，碰撞不会导致Alice意外打开属于Bob的完全不相关的文件，否则她无法访问这些文件。</p>
<p>我们的设计正确地处理了两个用户使用相同签名访问不同文件的情况，因为PCC中的错误将导致两个用户都退回到慢路径。</p>
<p>假设Bob开了foo，它和Alice的酒吧相撞了。当Alice打开bar时，它的签名将在DLHT中匹配，但在PCC中会丢失。这将导致Alice的查找以慢路径重新执行前缀检查，最终打开正确的文件并将此条目添加到她的PCC中。</p>
<p>因此，如果Bob是对抗性的，他就不能通过改变缓存内部状态导致Alice打开错误的文件。</p>
<p>我们在启动时为签名哈希函数选择一个随机密钥，以降低确定性错误或离线冲突生成的风险，因为人们可能会使用这些错误来攻击基于用户输入打开文件的应用程序，例如web服务器。因此，相同的路径不会跨重启或相同内核的实例生成相同的签名。</p>
<p>尽管采取了所有这些措施，但对于以root身份运行的应用程序来说，这种风险仍然是不可接受的，因为它可以打开任何文件，特别是那些接受来自不受信任用户的输入的文件。</p>
<p>例如，假设恶意用户识别了一个与密码数据库具有相同签名的路径。该用户可以将此路径传递给setuid-root实用程序，并欺骗setuid实用程序覆盖密码数据库。通过不允许对特权二进制文件或对安全敏感的路径名进行基于签名的查找加速，可以消除这种风险，尽管这在我们的原型中没有实现。</p>
<p><strong>Collision Resistance Requirement</strong></p>
<p>我们设计的安全性取决于对手只能通过蛮力找到碰撞。我们的设计可以使用2通用哈希函数或伪随机函数族(PRF)来生成路径签名。在抗碰撞方面，2-universal hash散列和PRF之间的区别在于，攻击者可以通过观察2-universal hash函数的输出来学习密钥，但不能从PRF的输出中学习密钥。因为我们的dcache设计不向用户显示签名，只显示两条路径是否有签名冲突，所以任何一个族的散列函数都足够了。</p>
<p> 需要注意的是，使用双通用哈希函数时，必须小心计时和其他侧通道不会泄漏签名。例如，不能同时使用签名中的位来索引哈希表，因为可能会通过测量在给定哈希桶上遍历链的时间来了解签名的位。在我们选择的函数中，可以安全地使用256位哈希输出中的较低位，因为在我们的特定算法中，较低位不受较高位值的影响;因此，我们使用16位哈希表索引和240位签名。相反，当使用PRF生成签名时，可以避免从侧通道学习签名的问题。</p>
<p>我们的设计使用了2-universal multilinear hash函数。我们使用基于AES-NI硬件的prf做了几个实验，但没有找到一个足够快的函数来改进基线Linux。使用当前的128位AES硬件，我们可以提高4个或更多路径组件的性能，但是创建256位PRF需要更复杂的构造，这太昂贵了。更谨慎的实现可能更倾向于使用PRF，以避免任何被忽略的侧通道风险，特别是如果在未来几代硬件中可以使用快速的256位PRF。</p>
<p><strong>Probability of a signature collision</strong></p>
<p>我们选择了一个240位的签名，它与重复数据删除系统中使用的签名大小相当，范围从128位到256位。</p>
<p>重复数据删除设计通常选择一个签名大小，该签名大小引入的冲突风险大大小于未检测到的ECC RAM错误的风险。</p>
<p>我们假设对手正在用蛮力寻找碰撞。攻击者必须查找系统上的路径，例如通过打开本地文件或查询web服务器上的路径。因为我们的哈希函数是用一个随机值作为键的，并且输出对用户是隐藏的，所以攻击者只能在目标系统上搜索冲突。因此，攻击者受到系统上的查找速率以及目标系统在缓存中保存多个签名以供比较的能力的限制。</p>
<p>我们计算碰撞风险变得不可忽略(即高于2^-128)的预期时间，并对碰撞风险建模如下。首先，|H(X)| &#x3D; 2^240是可能的签名数。我们将缓存限制为n &#x3D; 2^35个条目(即，假设RAM中的dcache空间为10TB，每个条目为320字节)，并采用LRU替换策略。我们计算碰撞风险大于P &#x3D; 2^−128的查询次数(q)如下:</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/公式1.png" title alt data-align="center">

<p>以每秒1000亿次的查找速度(目前的核每秒可以查找大约300万次)，强力碰撞的概率超过2^-128的预期时间是4.8万年</p>
<h1 id="Generalizing-the-Fast-Path"><a href="#Generalizing-the-Fast-Path" class="headerlink" title="Generalizing the Fast Path"></a>Generalizing the Fast Path</h1><p>到目前为止，我们已经使用相对简单的规范路径名解释了快速路径优化。</p>
<p>本节解释如何将这些优化与Linux的高级安全模块集成，以及如何处理Unix路径语义中的一些边缘情况，例如挂载选项、挂载别名和符号链接。</p>
<h2 id="Generalizing-Credentials"><a href="#Generalizing-Credentials" class="headerlink" title="Generalizing Credentials"></a>Generalizing Credentials</h2><p>Linux包括一个可扩展的安全模块框架(LSMs)， SELinux、AppArmor等都是在此基础上构建的。LSM可以覆盖搜索权限检查的实现，检查目录层次结构或进程的自定义属性。因此，即使LSM覆盖了默认的访问控制规则，我们的dcache优化也必须能够正常工作。</p>
<p>我们的方法利用了Linux中的credit结构，该结构旨在存储进程(任务结构)的凭据，并具有几个有用的属性。首先，信用结构是全面的，包括影响默认权限的所有变量，并包括LSM存储元数据的不透明安全指针。其次，信用是写时复制(copy-on-write, COW)，因此当进程更改其凭据时，例如通过执行setuid二进制文件或更改SELinux中的角色，信用将被复制。我们手动检查了AppArmor和SELinux对私有元数据的更改是否遵守COW约定。此外，在常见情况下，一个信用可以被进程共享，例如一个shell脚本分支子进程具有相同的信用。</p>
<p>因此，cred结构满足了我们的大部分需求，只有一些变化，我们将在下面解释。</p>
<p>我们在每个信用结构中存储缓存的前缀检查(§3.1)，将前缀检查结果与不可变凭证耦合在一起。使用空PCC初始化新的信用结构。当更多进程共享PCC时，它们可以进一步减少慢路径查找的数量。</p>
<p>一个挑战是，即使凭证没有更改，Linux也经常分配新的信用结构。潜在的问题是，COW行为不是在页表中实现的，而是在可能修改信用的代码中按照约定实现的。在许多情况下，例如在exec中，只需提前分配另一个信用，而不是确定凭据是否将被更改，这要简单得多。这种自由分配新凭据的方式造成了在具有相同凭据的子进程之间重用前缀缓存项的问题。为了缓解这个问题，我们等待，直到一个新的信用被应用到一个进程(提交信用())。如果信用的内容没有改变，旧的信用和PCC被重用和共享。</p>
<p>我们的信用方法记忆了不同lsm的复杂和可能任意的权限评估函数。</p>
<h2 id="Non-Canonical-Paths-and-Symbolic-Links"><a href="#Non-Canonical-Paths-and-Symbolic-Links" class="headerlink" title="Non-Canonical Paths and Symbolic Links"></a>Non-Canonical Paths and Symbolic Links</h2><p>我们的优化哈希表是以全路径为键。然而，用户可以指定一个路径的变体，例如<code>/X/Y/./Z</code>代表<code>/X/Y/Z</code>。简单的变化在散列过程中很容易被规范化。<br>一个更复杂的情况是，如果&#x2F;X&#x2F;L是一个符号链接，路径<code>/X/L/.../Y</code>可以映射到&#x2F;X&#x2F;Y以外的路径。同样，如果用户没有搜索<code>/X/Z</code>的权限，即使用户有搜索<code>/X/Y</code>的权限，对<code>/X/Z/.../Y</code>的查询也应该失败。为了保持与Linux的bug-for-bug兼容，我们的原型在每个点上都会发出一个额外的fastpath查询来检查权限。保持Unix的语义会给非经典的 路径的开销。<br>我们发现使用Plan 9的词法路径语义。Plan 9通过预处理，将网络文件 通过对<code>/X/L/.../Y</code>这样的路径进行预处理，将网络文件系统的查询降到最低。到<code>/X/Y</code>。我们注意到，Plan 9在每次查找组件时都会进行 查询，但没有目录缓存。</p>
<p><strong>Symbollic Links</strong></p>
<p>我们在我们的查询中解决符号链接 我们通过为符号链接创建dentry aliases来解决符号链接。例如 例如，如果路径<code>/X/L</code>是<code>/X/Y</code>的别名，我们的内核会 创建dentries，将<code>/X/L/Z</code>重定向到<code>/X/Y/Z</code>。换句话说，符号链接被视为一种特殊的目录类型、 并可以创建子目录，对翻译进行缓存。 符号链接dentries存储240位的签名，代表目标路径。代表目标路径。PCC是单独检查 为目标目录。如果一个符号链接发生变化，我们必须 无效所有的后继别名，类似于目录重命名的无效化。目录重命名(rename)。这种重定向可以无缝地处理 的情况，即在翻译的路径上发生权限变化 路径上的权限变化，或者被引用的目录被删除以回收空间。</p>
<h2 id="Mount-Point"><a href="#Mount-Point" class="headerlink" title="Mount Point"></a>Mount Point</h2><p>我们的快速路径处理由挂载点引入的几个微妙的边缘情况。</p>
<p><strong>Mount options</strong></p>
<p>挂载选项(如read-only或nosuid)会影响文件访问权限检查。Linux dcache通常将挂载点作为分层文件系统遍历的一部分，并内联检查与权限相关的挂载标志。一旦消除了这种自上而下的行走，我们需要能够识别任何给定牙齿的当前挂载点。目前我们为每个dentry添加了一个指针，尽管可能有更节省空间的选项。</p>
<p><strong>Mount Aliases</strong></p>
<p>一些伪文件系统，如proc、dev和sysfs，可以在多个位置挂载相同的实例。chroot环境使用该特性，并在引导期间移动这些文件系统。绑定挂载还可以创建挂载别名。</p>
<p>在我们的系统中，一个dentry只存储一个签名，并且一次只能通过一个路径在直接查找哈希表中。我们目前的设计只是选择最近的优化位置。如果慢路径遍历注意到匹配的dentry(按路径)有不同的签名，在别名挂载下，并且已经在DLHT中，那么慢路径将替换签名，增加dentry版本计数，并更新指向该dentry挂载点的指针。</p>
<p>如果别名路径有不同的前缀检查结果，则需要增加版本计数。这种方法确保了所有情况下的正确性，并且对于任何挂载别名的入口，在最近使用的路径上都具有良好的性能。</p>
<p><strong>Mount Namespaces</strong></p>
<p>Linux中的挂载namespace允许进程创建私有挂载点，包括chroot环境，这些挂载点仅对进程及其后代可见。当进程创建一个新的挂载namespace时，它还分配一个新的、namespace-private的直接查找哈希表。slowpath总是包含任何挂载重定向，并且任何新的签名到dentry映射在名称空间中都是正确的。因此，名称空间内部的相同路径(和签名)将映射到不同于名称空间外部的dentry。类似地，前缀检查缓存(PCC)在名称空间中始终是私有的。</p>
<p>与挂载别名(Mount Aliases)一样，我们一次只允许一个dentry存在于一个直接查找哈希表上。这有利于局部性，并且当重命名的目录跨多个namespace共享时，使无效任务易于处理。用于目录树修改的无效代码只是将每个子条目从当前存储的DLHT中移除</p>
<p><strong>Network File Systems</strong></p>
<p>我们的原型不支持在网络文件系统上直接查找，例如NFS版本2和3。为了在无状态协议上实现从近到开的一致性，客户端必须在服务器上重新验证所有路径组件——有效地强制缓存丢失，并使命中路径的任何好处无效。我们期望这些优化可以使具有目录修改回调的有状态协议受益，例如AFS或NFS 4.1。</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>本节演示我们的目录缓存优化如何支持Linux在目录缓存上构建的各种特性，包括名称空间、增强的安全模块和符号链接。我们的原型主要集中在Linux上，可以说Linux的特性与目录缓存交织在一起，但是我们相信这些优化在其他系统上也可以工作，只需要适当的移植工作。</p>
<p>我们的设计有以下要求，我们期望任何posix兼容的目录缓存都能满足这些要求。</p>
<p>首先，POSIX权限语义要求对从当前根目录或工作目录到文件的路径进行目录访问检查(即前缀检查);我们的实现继承了Linux的不变量，即任何缓存目录的父目录都在缓存中，但是任何可以实现前缀检查的设计都应该足够了。其次，我们要求，如果一个目录的权限改变，有一个程序化的方式来找到所有的后代在缓存中(§3.2)。我们的实现集成了Linux dcache中的乐观同步，以获得良好的性能和一致性，但这种设计可以集成任何合理的同步方案，例如FreeBSD的读&#x2F;写锁。最后，我们利用Linux具有不可变凭证结构的事实(§4.1);适应可变的或不太统一的凭证将需要额外的工作。</p>
<h1 id="Improving-the-Hit-Rate"><a href="#Improving-the-Hit-Rate" class="headerlink" title="Improving the Hit Rate"></a>Improving the Hit Rate</h1><p>前几节解释了dcache结构的变化如何通过算法改进来降低平均命中延迟。本节将介绍几个可以提高命中率的简单更改。在dcache丢失的情况下，低级文件系统被调用来为系统调用提供服务。在最好的情况下，磁盘上的元数据格式仍在页缓存中，但必须转换为通用格式;在最坏的情况下，请求阻塞在磁盘I&#x2F;O上。虽然并不是每个应用程序都以非常低的命中率大量使用这些情况，但评估显示有几个广泛使用的应用程序从这些优化中受益匪浅。</p>
<h2 id="Caching-Directory-Completeness"><a href="#Caching-Directory-Completeness" class="headerlink" title="Caching Directory Completeness"></a>Caching Directory Completeness</h2><p>尽管Linux dcache跟踪目录的层次结构，但它并不知道目录的内容是全部还是部分在缓存中。假设Alice在本地文件系统上创建了一个新目录X;如果她的下一个系统调用试图创建文件<code>X/Y</code>，则dcache将错过此查找，并询问低级文件系统是否存在<code>X/Y</code>。如果VFS跟踪所有目录内容都在缓存中，则可以避免这种开销。</p>
<p>第二个例子是<code>readdir</code>，它列出目录中的文件，以及它们的inode号和类型，比如普通文件、字符设备、目录或符号链接。在当前的VFS<code> readdir</code>操作中，总是调用底层文件系统，即使整个目录都在缓存中。对于大到无法在用户提供的缓冲区中列出的目录，可以多次调用<code>readdir</code>，将偏移量存储到目录中。为了构造这个清单，底层文件系统必须重新解析和转换磁盘上的格式，并且可能需要将元数据块从磁盘读入缓冲区缓存。因此，<code>readdir</code>通常是一个昂贵的文件系统操作，特别是对于大型目录。</p>
<p>我们注意到，重复列出目录是文件系统中的常见行为。例如，用户或shell脚本可以在一个目录中重复运行<code>ls</code>命令。一些应用程序通过目录内容协调状态，需要频繁和重复的目录列表。例如，<code>maildir</code>是一种流行的电子邮件后端存储格式，它比旧的mbox格式产生更好的性能可伸缩性。<code>maildir</code>将每个收件箱或子文件夹存储为一个目录，每个单独的邮件都是该目录中的一个文件。文件名编码属性，包括标志和读&#x2F;未读状态。如果消息改变了状态，例如通过删除或标记为已读，IMAP服务器服务器将重命名或取消该文件的链接，并重新读取目录以同步邮件列表。类似地，作为单独进程运行的邮件传递代理(MDA)可以并发地将新消息写入目录，这要求IMAP服务器监视目录的更改，并定期重新读取目录的内容。</p>
<p>我们的Linux变体将低级文件系统返回的readdir结果缓存在目录缓存中。如果目录的所有子目录都在缓存中，则用新的DIR COMPLETE标志标记dentry。这个标志是在创建新目录(mkdir)时设置的，或者在一系列readdir系统调用完成时，没有在目录句柄上执行lseek()操作，也没有并发清除任何子目录以回收空间。我们注意到，并发文件的创建或删除与一系列readdir交织在一起，仍然会在缓存中，并产生正确的列表结果。在设置了DIR COMPLETE标志之后，后续的读DIR请求将直接从dentry的子列表中得到服务。一旦目录进入完整状态，只有在从缓存中删除子条目以回收空间时，它才会离开此状态。</p>
<p>这种方法需要注意的一点是，readdir返回通常会出现在inode中的部分信息，但不足以创建完整的inode。对于这些文件或子目录，我们添加不带inode的dentry作为目录的子目录。这些dentry在查找时必须与阴性dentry分开，并与适当的索引节点链接。这种方法允许将readdir结果用于后续查找，干净地与现有的dcache机制集成，并从每个磁盘I&#x2F;O中获得最大可能的用途，而不会引起不必要的I&#x2F;O。</p>
<p>我们注意到Solaris包含一个类似的完整目录缓存模式[25]，但它没有与readdir或查找以外的调用集成，是一个单独的缓存(因此相同的dentry可以存储两次，并且在丢失之前必须检查两个散列表)，并且注释表明它仅对大型目录具有性能价值。我们的结果表明，当适当地集成到目录缓存中时，跟踪完整的目录比以前认为的更有价值。</p>
<p><strong>File Creation</strong></p>
<p>目录完整性缓存还可以避免新文件创建时的强制遗漏。尽管负dentry缓存对于不存在的特定文件的重复查询效果很好，但是当应用程序请求不存在的不同文件时，负dentry的效果就不那么好了。</p>
<p>不可预测查找的一个常见示例来自安全临时文件创建实用程序。在我们的原型中，带有<code>DIR_COMPLETED</code>标志的目录下的缺失被视为发现了negative dentry，从而忽略了这种强制缺失。在我们当前的实现中，该标志只会在已读取或新创建的目录中设置，但其他用于检测频繁的negative dentry缺失和加载目录的启发式方法可能也很有用.</p>
<h2 id="Aggressive-Negative-Caching"><a href="#Aggressive-Negative-Caching" class="headerlink" title="Aggressive Negative Caching"></a>Aggressive Negative Caching</h2><p>negative dentries缓存磁盘上不存在的路径。本小节确定了几个更积极地使用负检索的机会，其中一些与直接查找协同工作</p>
<p><strong>Renaming and Deletion</strong></p>
<p>当文件被重命名或解除链接时，可以将旧路径转换为negative dentry。</p>
<p>虽然Linux会在取消链接时将缓存的但未使用的dentry转换为negative dentry，但对于仍在使用的文件的重命名和取消链接来说，情况并非如此。我们扩展了这些例程，以便在删除文件后保留负记录，以便以后重用该路径，就像创建锁文件或Emacs的备份(“波浪”)文件一样</p>
<p><strong>Pseudo File Systems</strong></p>
<p>伪文件系统，如<code>proc</code>、<code>sys</code>和<code>dev</code>，不会为搜索到的不存在的路径创建negative dentry。这是一种基于以下观察的简化:磁盘I&#x2F;O永远不会涉及到遗漏。因为我们的快速路径仍然比遗漏快得多，negative dentry甚至对内存中的文件系统也是有益的，可以加速查找不存在的频繁搜索文件。</p>
<p><strong>Deep Negative Dentries</strong></p>
<p>最后，我们扩展了直接查找快速路径(§3)，使其能够创建“深度”负输入。考虑这样一种情况:用户试图打开<code>/X/Y/Z/A</code>，而<code>/X/Y/Z</code>不存在。在慢路径中，查找将在找到第一个缺失的组件时失败，只缓存z的负条目就足够了。然而，对该路径的重复查找将永远不会找到快速路径，因为没有完整路径的条目。</p>
<p>为了在这种情况下使用快速路径，我们允许负面dentries创建负面子节点，以及深层子节点。</p>
<p>换句话说，我们允许negative dentry <code>/X/Y/Z</code>创建子节点<code>A</code>和<code>A/B</code>，它们可以服务于对不存在的路径的重复请求。如果为缓存为负的路径创建文件，并且该文件不是目录，则会从缓存中清除任何负的子文件。</p>
<p>我们还在常规文件下创建深度negative dentry，以捕获返回<code>ENOTDIR</code>而不是<code>ENOENT</code>的查找失败。当将文件名当作目录使用时，就会出现这种查找失败，并且搜索其下的路径。例如，如果<code>/X/Y/Z</code>是一个常规文件，并且用户搜索<code>/X/Y/Z/A</code>, Linux内核将返回<code>ENOTDIR</code>，并且永远不会创建negative dentry。我们用一个deep,<code>ENOTDIR</code>优化这个案例。</p>
<h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><p>本节评估我们的目录缓存优化，并试图回答以下问题:</p>
<ol>
<li><p>每种优化(查找快速路径、全目录缓存和更激进的negative dentries)对应用程序性能的改善有多大?</p>
</li>
<li><p>采用这些更改有多困难，特别是对于单个文件系统?</p>
</li>
</ol>
<p>评估包括微基准测试，用于测量在最佳情况和最坏情况下与文件系统相关的系统调用的延迟，以及选择实际应用程序，以显示我们的解决方案在实践中可能提高的性能。</p>
<p>所有的实验结果都收集在一台Supermicro超级服务器上，该服务器配备了12核2.40GHz的英特尔Core Xeon CPU、 64GB内存，和一个2TB，7200 RPM的ATA磁盘，格式化为日记式的ext4文件系统，配置为4096 字节块大小。操作系统是Ubuntu 14.04服务器，Linux内核 3.14. 所有的测量结果都是至少6次运行的平均值（对于运行时间较长的实验）；大多数测量是数百或数千次的运行，以确保一致的平均数。表格和图表表明95%的置信区间 用 “+&#x2F;-“列或误差条表示。</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图6.png" title alt data-align="center">

<h2 id="File-Lookup-Optimization"><a href="#File-Lookup-Optimization" class="headerlink" title="File Lookup Optimization"></a>File Lookup Optimization</h2><h3 id="Micro-benchmarks"><a href="#Micro-benchmarks" class="headerlink" title="Micro-benchmarks"></a>Micro-benchmarks</h3><p>我们使用扩展的LMBench 2.5 UNIX微基准套件来评估系统调用级别的路径查找延迟。图6显示了<code>stat</code>和<code>open</code>具有各种特征的示例路径的延迟，这些特征包括不同的长度、符号链接、父目录(dot dot)和未找到的文件。</p>
<p>我们观察到的主要趋势是，当路径有更多的组件时，我们的优化的相对增益就会增加。</p>
<p>对于单个组件文件，<code>stat</code>获得3%的收益，而<code>open</code>与基线Linux相当。对于更长的路径，增益分别增加到26%和12%。</p>
<p>为了评估最坏的情况，我们包括一组标有 “fastpath miss + slowpath “的条形图，它行使了快速路径代码，但是内核被配置为在PCC中总是miss。这模拟了执行优化的快速路径不成功，然后在缓存中走O(n)慢速路径的全部成本。这种情况下，不会一直错过到低级文件系统。开销通常在12-93%之间，除了路径neg-d。在neg-d的情况下，第一个组件是缺失的，一个组件一个时间的行走会比直接查找更快停止。一般来说，neg-d的情况会通过deep negative dentries来缓解。在实践中，这些开销只有在高速缓存中的强制缺失时才会被观察到，或者由一个表现出极度缺乏定位性的应用来观察。</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图7图8.png" title alt data-align="center">

<p>接下来，我们比较默认Linux父级(“dot dot”)语义与Plan 9的词法语义的成本。对带有父引用的路径强制执行Linux语义导致我们的优化性能比未修改的Linux差大约31%，因为这需要对每个父节点进行额外的查找。另一方面，词法路径语义允许我们继续使用单个查找进行优化，从而将性能提高43-52%。词法路径语义有一个独立的好处，可以减少在未修改的Linux中查找时需要遍历的组件数量。尽管这个差异很大，但是我们的测试应用程序并没有大量使用父目录指针，并且对这个差异并不敏感。</p>
<p>缓存符号链接的分辨率可使路径link-f和link-d的性能分别提高44%和48%。这种改进对链接发生在路径中的位置不敏感，因为link-f和link-d都遍历相同数量的组件(link-d将“LLL”映射到“XXX”)。</p>
<p>对于不存在的文件(negative dentries)，我们看到了与现有路径类似的改进。唯一的例外是路径早期目录下不存在的长路径。我们认为这种情况很少见，因为应用程序通常是自顶向下遍历目录树，而不是跳到一个不存在的目录。在这种情况下(path neg-d)，基线Linux停止处理路径的速度比我们的优化散列整个路径的速度要快，即使缓存deep negative dentries也是如此。尽管如此，deep negative dentries是一个重要的优化:没有它们，path neg-d的状态将比未修改的Linux差113%，open将差43%，而deep negative dentries则慢38%和16%。</p>
<p>Linux还包括<code>*at()</code>系统调用变体，它们在工作目录下操作—通常只使用单个组件。与上面的结果相对应，对于单个路径组件，<code>fstatat()</code>从我们的优化中获益12%，<code>openat()</code>比未修改的Linux快4%。一些应用程序将多个组件名称与<code>*at</code>调用结合使用;在这些情况下，优化的好处与路径长度成正比。</p>
<p>为了评估更新目录权限和改变目录结构的开销，我们测量chmod和重命名的延迟。在我们的解决方案中，影响这些开销的主要因素是缓存中的子目录数量（缓存外的目录子目录不会影响性能）。图7显示了不同深度和目录大小的目录上的chmod和重命名的性能。一般来说，重命名或chmod的成本随着子目录数量的增加而急剧增加，而基线Linux和ext4使这些操作的时间不变。即使有10,000个子目录都在缓存中，最坏的情况下的延迟也在330微秒左右。作为一个参考点，Linux 3.19源树包括51,562个文件和目录。几个Linux文件系统维护者的初步反馈表明 这种交易对于提高查询性能是可以接受的。</p>
<p><strong>Space Overhead</strong></p>
<p>我们的原型将dentry的大小从192字节增加到280字节。我们的设计还引入了大小为64 KB的每个凭据的PCC和第二个全局散列表(DLHT)，其中包括2^16个bucket。由于Linux没有对dcache大小施加任何硬限制(除了在内存压力下的极端情况)，因此很难标准化执行时间来考虑空间成本。在一个典型的系统上，dcache是几十到几百MB;将其增加50%可能在系统总内存的可接受范围内。或者，如果要限制总dcache大小，则会在更快的命中和更少的命中之间进行权衡。我们把这些权衡的探索留给未来的工作。</p>
<p><strong>Scalability</strong></p>
<p>图8显示了当系统上执行更多线程时，在同一路径上执行<code>stat/open</code>操作的延迟。在Linux上，查找的读端已经是线性可伸缩的，我们的优化并没有破坏这一趋势——只是提高了延迟。rename系统调用引入了显著的争用，并且在基线Linux中可伸缩性较差。例如，在我们</p>
<h2 id="Caching-Directory-Completeness-1"><a href="#Caching-Directory-Completeness-1" class="headerlink" title="Caching Directory Completeness"></a>Caching Directory Completeness</h2><img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图9.png" title alt data-align="center">

<p>图9显示了不同目录大小的<code>readdir</code>微基准测试的延迟。缓存<code>readdir</code>结果的能力提高了46-74%的性能。随着目录变大，缓存的帮助越来越大。OpenSolaris的注释表明，这个想法只对UFS中至少有1,024个条目的目录有利。我们的结果表明，即使只有10个子目录也有好处。</p>
<p>图9还显示了在不同大小的目录中创建一个安全的、随机命名的文件的延迟。我们对mkstemp库进行了1-8%的改进。尽管大多数应用程序的执行时间并不被安全文件的创建所支配，但它是许多应用程序的一项常见任务，而且边际成本低。</p>
<h2 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h2><p><strong>Command-Line Applications</strong></p>
<p>当然，应用程序从更快的查找中获得的改进与发出基于路径的系统调用所花费的运行时时间比例以及列出目录的时间数量成正比。我们测量一系列常用应用程序的性能。</p>
<p>在大多数情况下，这些应用程序从这些优化中受益匪浅;在最坏的情况下，性能损害是最小的。我们用于基准测试的应用程序包括:</p>
<ul>
<li><p>find:在Linux源目录中搜索文件名。</p>
</li>
<li><p>tar xzf:解压并解包Linux源代码。</p>
</li>
<li><p>rm -r:删除Linux源树。</p>
</li>
<li><p>make和make -j12:编译Linux内核。</p>
</li>
<li><p>du -s:在Linux源代码中递归列出目录大小。</p>
</li>
<li><p>updatedb:从一个干净的debootstrap中重建&#x2F;usr中常用搜索文件名的规范路径数据库。</p>
</li>
<li><p>git status和git diff:显示克隆的Linux内核git库的状态和未分级的更改</p>
</li>
</ul>
<p>对于我们测试的每个应用程序，我们在热缓存(表1)和冷缓存(表2)两种情况下评估性能。为了热缓存，我们运行一次实验并放弃第一次运行。对于热缓存测试，我们还提供了每个应用程序的路径特征的统计信息。</p>
<p>也许不足为奇的是，元数据密集型工作负载从我们的优化中获益最多，例如find和updatedb，速度可提高29%。注意，find、updatedb和du只使用*at() api，并且所有路径都是单组件;这些收益可归因于查找和目录完整性缓存的改进。</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/表1.png" title alt data-align="center">

<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/表2.png" title alt data-align="center">

<p>我们注意到目录搜索工作负载的性能对PCC的大小很敏感;当我们在一个比PCC大两倍的目录树上运行updatedb时，增益从29%下降到16.5%。这是因为在新访问的目录中，越来越多的第一次查找将不得不采用慢路径。</p>
<p>我们的原型有一个静态设置的PCC大小，我们用一个足够大的PCC进行评估，以便在温暖的缓存实验中缓存大多数相关的目录。我们希望一个生产系统能够动态地调整PCC的大小，使其达到最大的工作集；我们将研究一个适当的策略来决定何时增加PCC和驱逐条目的问题留待今后的工作中解决。</p>
<p>我们的命中优化主要改进的应用程序是git，它显示了4-9.9%的增益。由其他计算主导的情况，例如Linux编译，显示最小(≤2.3%的减速)。在冷缓存的情况下，所有的增益或损失都大致在实验噪声范围内，这表明这些优化不太可能对在冷系统上运行的应用程序造成损害。总的来说，这些结果肯定了普通的Linux应用程序不会因为我们的优化而受到损害，而且可以从中获得实质性的好处。</p>
<p>表1还显示了未修改Linux上这些工作负载的统计信息。一般来说，每个路径组件大约有8个字符，基于*at的应用程序通常查找单组件路径，而其他应用程序通常查找3-4个组件。我们的统计数据还表明，使用热缓存时，这些应用程序在缓存中应该看到84 - 100%的命中率，因此优化命中路径对性能至关重要。最后，make是唯一具有显著负dentries比例(大约20%)的应用程序，这是意料之中的，因为它正在创建新的二进制文件。</p>
<p><strong>Server Applications</strong></p>
<p>一个经常使用readdir的软件示例是使用MailDir存储格式的IMAP邮件服务器。我们通过为客户机创建10个邮箱来测试Dovecot IMAP服务器。我们使用客户端脚本随机选择不同邮箱中的消息，并将其标记为已读、已标记或未标记。在内部，标记邮件会导致重命名文件，并重新读取目录。为了消除网络延迟，我们在本地主机上运行网络测试;在实际部署中，网络延迟可能会掩盖客户端的这些改进，但服务器的负载仍然会减少。</p>
<p>图10显示了Dovecot邮件服务器在两个内核上的吞吐量。在两个内核上的吞吐量；改进范围为7.8-12.2%。与readdir微基准相呼应，较大的 目录通常会有更大的改善，在10%的收益中趋于平稳。我们同样使用Apache基准测试来锻炼Apache网络服务器生成文件列表的能力（表3）。这些页面没有被Apache缓存，而是为每个请求动态地生成。总的来说，这些结果表明，readdir缓存策略可以减少服务器的负载或提高服务器的吞吐量。</p>
<img src="/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/图10表3表4.png" title alt data-align="center">

<h2 id="Code-Changes"><a href="#Code-Changes" class="headerlink" title="Code Changes"></a>Code Changes</h2><p>为了估计采用的难度，表4列出了Linux原型中更改的代码行。所需的绝大多数更改(大约1,000个LoC)是本地化到dcache本身的钩子(dcache.c和name .c);大多数这些优化都在一组单独的文件中，总计约2,400个LoC。此外，我们测试的低级文件系统不需要任何更改就可以使用修改后的目录缓存。对其他子系统的主要影响实际上是对lsm的影响，这需要一些更改来正确地管理pcc。因此，采用其他内核子系统的负担非常小。</p>
<h2 id="Discussion-and-Future-Work"><a href="#Discussion-and-Future-Work" class="headerlink" title="Discussion and Future Work"></a>Discussion and Future Work</h2><p>如果愿意牺牲完全向后兼容性来最大化查找性能，那么改进的主要机会实际上可能是为基于路径的调用设计一个更简单的接口。</p>
<p>正如上面的评价所示，在这种设计中，有几个Linux&#x2F;POSIX特性的支持成本过高。例如，实现Plan 9风格的词法路径语义可以显著改善查找带有“dot dot”的路径。类似地，工作目录语义要求慢路径遍历。可以说，在这些点上，特定的实现选择已经“泄露”到接口规范中，并且这些特性限制了支持数据结构的选择。我们建议使用尽可能简单和无状态的接口;这个建议与其他关于可伸缩性的建议一致。</p>
<p>Linux静态地选择哈希表中的buckets数(默认情况下为262,144)。如果没有很好地选择这个数字，或者需求随着时间的推移而变化，则会浪费空间或bucket链变长，从而损害查找性能。</p>
<p>在我们的测试系统中，58%的bucket是空的，34%有一个条目，7%有两个条目，1%有3-10个条目，这表明有机会改进查找时间和空间使用。近年来开发了许多高性能哈希表，它们对搜索时间和浪费的空间施加了恒定的限制。</p>
<h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><p>大多数提高目录缓存效率的相关工作都是针对两个相互正交的问题:减少丢失延迟和预取条目。最类似于我们记忆前缀检查结果的优化，SQL Server缓存对象最近访问控制检查的结果。</p>
<p><strong>Reducing Miss Latency</strong></p>
<p>减少遗漏延迟的一个相关策略是将所有要查找的组件一次性传递给低级文件系统，本质上是创建一个预取提示。一些网络文件系统已经观察到，组件一次查找会为每个组件生成一条往返消息，而更有效的策略是将一个消息中的挂载点下的所有组件传递给服务器进行查找。类似的论点也适用于本地文件系统，通过知道完整的查找目标，可以更有效地从磁盘获取元数据索引。因此，Windows NT和Solaris采用了这种分工。需要注意的是，如果不将其作为预取“提示”，这可能会将大量VFS功能推入每个低级文件系统，例如处理挂载点的重定向、符号链接和权限检查。Chen等人注意到，将权限检查从VFS层向下推到单个文件系统是Linux中难以防止的内核bug的一个重要来源。相比之下，这个项目缓存先前的前缀检查结果，以减少内存中已经存在的路径的命中延迟，而不是使用完整路径作为预取提示。</p>
<p>另一种普遍存在的延迟减少策略是将元数据持久地存储在散列表中。为了减少网络流量，一些分布式文件系统、集群环境和基于云的应用程序已经使用元数据散列来确定地将元数据映射到节点，从而消除了对目录服务的需求。直接查找文件系统(Direct Lookup File System, DLFS)本质上是将整个磁盘组织成一个哈希表，按照文件系统内的路径进行键控，以便查找只有一个I&#x2F;O的文件。将磁盘组织为散列表会带来一些挑战，例如将目录重命名转换为数据和元数据的深度递归副本。DLFS通过将父权限表示为封闭形式表达式来解决前缀检查问题;这种方法本质上是硬编码传统的Unix自由访问控制，并且不容易扩展到Linux安全模块。我们工作的一个重要见解是，内存中的全路径哈希，而不是磁盘上的，可以实现类似的性能提升，但没有这些可用性问题，例如重命名时的深度目录复制或更新子目录权限时容易出错的启发式方法。</p>
<p><strong>VFS Cache Profetching</strong></p>
<p>一些文件系统优化了readdir后跟stat以访问子目录元数据的情况，例如使用ls -l命令。当请求读取目录时，这些低级文件系统推测性地将文件索引节点(通常位于相对较近的磁盘扇区)读取到私有内存缓存中，随后的查找或stat请求将从该缓存中得到服务。类似地，NFS版本2协议包括一个READDIRPLUS操作，它在一次消息往返中请求所有子节点的目录内容和属性。这些文件系统必须实现它们自己的启发式方法来管理这个缓存。预取与我们的工作是正交的，它更有效地缓存已经从低级文件系统请求的内容。</p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>本文提出了一种目录缓存设计，可以有效地将文件路径映射到操作系统内核中的内存数据结构。我们的设计将目录缓存分解为单独的缓存，用于权限检查和路径索引，支持单步路径查找，并促进基于签名和缓存符号链接解析的新优化。对于经常与文件系统目录树交互的应用程序，这些优化最多可以将性能提高29%。我们的优化保持了与一系列应用程序和内核扩展的兼容性，使它们适合实际部署。</p>
]]></content>
      <categories>
        <category>论文精读</category>
        <category>内核安全</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux cgroup入门</title>
    <url>/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><code>cgroup</code>（控制组）是 Linux 内核中的一个特性，用于限制、隔离和管理进程和系统资源的使用。它是一个层次化的组织结构，允许对进程进行分组，并为这些组分配系统资源，如 CPU、内存、磁盘 I&#x2F;O 和网络带宽。<code>cgroup</code> 主要用于操作系统的资源管理和容器技术，如 Docker 和 Kubernetes 等。</p>
<p>cgroup 的特点和功能包括：</p>
<ol>
<li><p><strong>资源限制</strong>：您可以为每个 cgroup 分配特定的系统资源，如 CPU 使用率、内存限制等。这有助于防止某个进程或组消耗过多资源，影响其他进程的运行。</p>
</li>
<li><p><strong>资源隔离</strong>：cgroup 可以将不同组的进程隔离，这样它们不会互相影响。例如，在一个容器中运行的进程可以被限制在其所分配的资源范围内，不会影响到其他容器或系统进程。</p>
</li>
<li><p><strong>资源监控</strong>：通过 cgroup，您可以监控每个组的资源使用情况，从而更好地了解系统的运行状态。这有助于发现性能瓶颈、优化资源分配等。</p>
</li>
<li><p><strong>优先级控制</strong>：cgroup 允许您为进程组分配不同的优先级，以确保关键任务始终优先获得资源。</p>
</li>
</ol>
<p>cgroup 分 <a href="https://www.kernel.org/doc/Documentation/cgroup-v1">v1</a> 和 <a href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt">v2</a> 两个版本，v1 实现较早，功能比较多，但是由于它里面的功能都是零零散散的实现的，所以规划的不是很好，导致了一些使用和维护上的不便，v2 的出现就是为了解决 v1 中这方面的问题，在 4.5 内核中，cgroup v2 声称已经可以用于生产环境了，但它所支持的功能还很有限，随着 v2 一起引入内核的还有 cgroup namespace。v1 和 v2 可以混合使用，但是这样会更复杂，所以一般没人会这样用。</p>
<h1 id="为什么需要cgroup"><a href="#为什么需要cgroup" class="headerlink" title="为什么需要cgroup"></a>为什么需要cgroup</h1><p>在 Linux 里，一直以来就有对进程进行分组的概念和需求，比如 <a href="https://www.win.tue.nl/~aeb/linux/lk/lk-10.html">session group， progress group</a> 等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和 IO 使用情况等，于是出现了 cgroup，用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理等。</p>
<h1 id="什么是cgroup"><a href="#什么是cgroup" class="headerlink" title="什么是cgroup"></a>什么是cgroup</h1><p>术语 cgroup 在不同的上下文中代表不同的意思，可以指整个 Linux 的 cgroup 技术，也可以指一个具体进程组。</p>
<p>cgroup 是 Linux 下的一种将进程按组进行管理的机制，在用户层看来，cgroup 技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个 <code>subsystem</code> 关联，树的作用是将进程分组，而 <code>subsystem</code> 的作用就是对这些组进行操作。cgroup 主要包括下面两部分：</p>
<ul>
<li>subsystem : 一个 subsystem 就是一个内核模块，他被关联到一颗 cgroup 树之后，就会在树的每个节点（进程组）上做具体的操作。subsystem 经常被称作 <code>resource controller</code>，因为它主要被用来调度或者限制每个进程组的资源，但是这个说法不完全准确，因为有时我们将进程分组只是为了做一些监控，观察一下他们的状态，比如 perf_event subsystem。到目前为止，Linux 支持 12 种 subsystem，比如限制 CPU 的使用时间，限制使用的内存，统计 CPU 的使用情况，冻结和恢复一组进程等</li>
<li>hierarchy : 一个 <code>hierarchy</code> 可以理解为一棵 cgroup 树，树的每个节点就是一个进程组，每棵树都会与零到多个 <code>subsystem</code> 关联。在一颗树里面，会包含 Linux 系统中的所有进程，但每个进程只能属于一个节点（进程组）。系统中可以有很多颗 cgroup 树，每棵树都和不同的 subsystem 关联，一个进程可以属于多颗树，即一个进程可以属于多个进程组，只是这些进程组和不同的 subsystem 关联。目前 Linux 支持 12 种 subsystem，如果不考虑不与任何 subsystem 关联的情况（systemd 就属于这种情况），Linux 里面最多可以建 12 颗 cgroup 树，每棵树关联一个 subsystem，当然也可以只建一棵树，然后让这棵树关联所有的 subsystem。当一颗 cgroup 树不和任何 subsystem 关联的时候，意味着这棵树只是将进程进行分组，至于要在分组的基础上做些什么，将由应用程序自己决定，<code>systemd</code> 就是一个这样的例子。</li>
</ul>
<h1 id="查看当前系统支持哪些subsystem"><a href="#查看当前系统支持哪些subsystem" class="headerlink" title="查看当前系统支持哪些subsystem"></a>查看当前系统支持哪些subsystem</h1><p>可以通过查看&#x2F;proc&#x2F;cgroups（Linux v5.19.0-38-generic），知道当前系统支持哪些subsystem</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#subsys_name    hierarchy    num_cgroups    enabled</span><br><span class="line">cpuset    0    149    1</span><br><span class="line">cpu    0    149    1</span><br><span class="line">cpuacct    0    149    1</span><br><span class="line">blkio    0    149    1</span><br><span class="line">memory    0    149    1</span><br><span class="line">devices    0    149    1</span><br><span class="line">freezer    0    149    1</span><br><span class="line">net_cls    0    149    1</span><br><span class="line">perf_event    0    149    1</span><br><span class="line">net_prio    0    149    1</span><br><span class="line">hugetlb    0    149    1</span><br><span class="line">pids    0    149    1</span><br><span class="line">rdma    0    149    1</span><br><span class="line">misc    0    149    1</span><br></pre></td></tr></table></figure>

<p>从左到右，字段的含义分别是：</p>
<ul>
<li><p>subsystem的名字</p>
</li>
<li><p>subsystem所关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么他们的这个字段将一样，比如这里的cpu和cpuacct就一样，表示他们绑定到了同一颗树。如果出现下面的情况，这个字段将为0：</p>
<ul>
<li><p>当前subsystem没有和任何cgroup树绑定</p>
</li>
<li><p>当前subsystem已经和cgroup v2的树绑定</p>
</li>
<li><p>当前subsystem没有被内核开启</p>
</li>
</ul>
</li>
<li><p>subsystem所关联的cgroup树中进程组的个数，也即树上节点的个数</p>
</li>
<li><p>1表示开启，0表示没有被开启(可以通过设置内核的启动参数“cgroup_disable”来控制subsystem的开启).</p>
</li>
</ul>
<h1 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h1><p><code>systemd</code> 是一个 Linux 系统和服务管理器，它成为许多主流 Linux 发行版（如 Debian、Ubuntu、Fedora、RHEL 和 CentOS 等）的默认初始化系统（init system）。systemd 负责在系统启动时引导和管理后台进程（称为服务或守护进程），并在运行过程中对这些服务进行监控和管理。</p>
<p>systemd 的主要特点和优点包括：</p>
<ol>
<li><strong>并行启动服务</strong>：systemd 能够并行启动服务，从而加快系统启动速度。</li>
<li><strong>按需启动服务</strong>：systemd 支持 socket 激活和 D-Bus 激活，可以根据需要按需启动服务。</li>
<li><strong>服务管理和监控</strong>：systemd 提供了在运行时管理和监控服务的功能，如自动重启失败的服务、记录服务状态和日志等。</li>
<li><strong>系统管理功能</strong>：除了管理服务，systemd 还提供了一些系统管理功能，如控制电源、管理用户会话和设备等。</li>
</ol>
<p>systemd 使用名为 <code>unit</code> 的配置文件来管理服务和资源。这些配置文件定义了服务的启动顺序、依赖关系、运行参数等信息。Unit 可以是以下类型之一：</p>
<ul>
<li><strong>服务（Service）</strong>：后台进程（守护进程）。</li>
<li><strong>套接字（Socket）</strong>：IPC 和网络套接字，用于按需启动服务。</li>
<li><strong>设备（Device）</strong>：设备节点。</li>
<li><strong>挂载点（Mount）</strong>：文件系统挂载点。</li>
<li><strong>自动挂载点（Automount）</strong>：自动挂载文件系统。</li>
<li><strong>目标（Target）</strong>：用于组织其他 Unit 的逻辑分组。</li>
<li><strong>路径（Path）</strong>：文件系统路径，用于监视文件系统事件。</li>
<li><strong>时间器（Timer）</strong>：定时器，用于定时启动其他 Unit。</li>
<li><strong>快照（Snapshot）</strong>：保存当前系统状态的快照。</li>
<li><strong>切片（Slice）</strong>：用于组织和管理系统资源的层次结构。</li>
</ul>
<p>systemd 提供了一些命令行工具，如 <code>systemctl</code>、<code>journalctl</code> 等，用于管理和查询系统和服务状态。例如，你可以使用 <code>systemctl start</code>、<code>systemctl stop</code>、<code>systemctl restart</code> 等命令来控制服务。</p>
<h2 id="所有的subsystems"><a href="#所有的subsystems" class="headerlink" title="所有的subsystems"></a>所有的subsystems</h2><p>目前Linux支持下面12种subsystem</p>
<ul>
<li><p><a href="https://link.segmentfault.com/?enc=G7/F4YXgyt1UK6t0e3Uh4g==.+xOOK0vsUFmLIMctXzs+yexka+CiMxUXyAR2amxHSI/tj9UVfyXSYGWJbKCnzEU5QYltu/nHbE51PvO0XaqFo6Jjg68q9kwaZqvXInyt5gI=">cpu</a> (since Linux 2.6.24; CONFIG_CGROUP_SCHED)<br>用来限制cgroup的CPU使用率。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=ze4xaRCzRdv2mcPDsyY7qg==.6DW9ygBZUTJ8uq/4ojQa/KkXNhJVdgxKT3aLyeVu+CdQlOjaNZT4EdyfKrUwC6i9l0MbTyp0oNar+YiwYFHghQ==">cpuacct</a> (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)<br>统计cgroup的CPU的使用率。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=I8XfAyxrI7Aa38k2jbgmbg==.EI3xapL3jqyLojQnYz91nqN8GimtqSQ0gHantjVtgmwgni/GaR7ahPE5uUQ9PE1f1VgrxIFxrXfNqqW68LaDGw==">cpuset</a> (since Linux 2.6.24; CONFIG_CPUSETS)<br>绑定cgroup到指定CPUs和NUMA节点。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=Zp6QLpalRqZevR3fUcftpg==.NE9jk40VWeE3S3mN4CXDz/PKleSUHVFt8Y+KW9o+cksJVnHDjfRwd5mNg9OnH95hXprRDmHtDyCHYmI9IjQyFw==">memory</a> (since Linux 2.6.25; CONFIG_MEMCG)<br>统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=KAPq/zQKISJ124SCkKhtuA==.usEILwMEdFIXX/NPSZdlq/nehWFve98LJP3zLhK38+0T2MGXiIE4ISTons7GYLSOZ8ktNqzLLb9Epsm4BIhPOA==">devices</a> (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)<br>限制cgroup创建(mknod)和访问设备的权限。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=4kMujOk9zcAHa4FE7+Gsew==.kG4t60Q5/gIiAmcQEDgy9UWEIxifrX/7pRXKi8sCwGJuGyjv2vUpPE2jKnAR6LKvJecmy+7N+H07ofhGQYjxNcMG+WrFje7vCmjfktTb3KY=">freezer</a> (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)<br>suspend和restore一个cgroup中的所有进程。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=csBA0HfpR9Kx4H+HqzZo0g==.VzeUnvRQJ91xrrmsRuDeyUrab5TjMVI1pY+6oKPpZTRA1HPnEQ4Gm9fkak0oS5YYuywfwtdBXydGVcVDFsW03A==">net_cls</a> (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)<br>将一个cgroup中进程创建的所有网络包加上一个classid标记，用于<a href="https://link.segmentfault.com/?enc=j203WMUVoEnMnYbt2Hmb0g==.eRzGY22xT5KGPoZzo7chbhvPupg3RYsLBaT+CDezN32SrNgfMp+Hhxya0J4qTsQp">tc</a>和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=+uleVDcXGN4P1MM6eRa1yw==./gt4q3xspaRMogNjui/S2QPOnm3xkJzxXz6c9/BgrkYkRYcYG+MvwZ51OllIIZj7UjrGbEpGGgyuMmTmhHIVVmDxRNGZOWmtMT/kIur9nhc=">blkio</a> (since Linux 2.6.33; CONFIG_BLK_CGROUP)<br>限制cgroup访问块设备的IO速度。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=+2FtLk39e1Nuzg8FkrMmww==.eDcpaRY9CyvZxG2FuzXF3FoNkIY5l9nRYlO/3xPjMN4i1iScXkn3QZYGVb9jmWApOnNQyr9An5H/ar4KweI2Vg==">perf_event</a> (since Linux 2.6.39; CONFIG_CGROUP_PERF)<br>对cgroup进行性能监控</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=CmkeQJbgChTIYs2byz46MQ==.ul4Ij2bBLezwBvlygVoJHgRuXYyFjuZFxm41QQKBEfgDEm07V12BO9X+FA3+4RRA+wuNc91gDygn+TyaG8kFTg==">net_prio</a> (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)<br>针对每个网络接口设置cgroup的访问优先级。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=uMqxK5R7ORxnrwyKHdjzPg==.zm1skoKGFhZQNGE1Q2JqD8jOf90d6/bgUh3VpiLlkhLV3u3CF85vhilGhkGTPZJp5cI3sjcSFRr4POyj2llqhQ==">hugetlb</a> (since Linux 3.5; CONFIG_CGROUP_HUGETLB)<br>限制cgroup的huge pages的使用量。</p>
</li>
<li><p><a href="https://link.segmentfault.com/?enc=dj4zuhUuHnNTwOmiTj5hqA==.wvR47uSrZEBUbKNB/fKBscNvlMvA0R3wHWDhyiqirBfkZwRpaQt248bwrOYVG2WaYIwyD6JBbLv+ZQ3ZYzLIkg==">pids</a> (since Linux 4.3; CONFIG_CGROUP_PIDS)<br>限制一个cgroup及其子孙cgroup中的总进程数。</p>
</li>
</ul>
<p>上面这些subsystem，有些需要做资源统计，有些需要做资源控制，有些即不统计也不控制。对于cgroup树来说，有些subsystem严重依赖继承关系，有些subsystem完全用不到继承关系，而有些对继承关系没有严格要求。</p>
<p>不同subsystem的工作方式可能差别较大，对系统性能的影响也不一样，本人不是这方面的专家，后续文章中只会从功能的角度来介绍不同的subsystem，不会涉及到他们内部的实现。</p>
<h1 id="如何使用cgroup"><a href="#如何使用cgroup" class="headerlink" title="如何使用cgroup"></a>如何使用cgroup</h1><p>cgroup相关的所有操作都是基于内核中的cgroup virtual filesystem，使用cgroup很简单，挂载这个文件系统就可以了。一般情况下都是挂载到&#x2F;sys&#x2F;fs&#x2F;cgroup目录下，当然挂载到其它任何目录都没关系。</p>
<p>这里假设目录&#x2F;sys&#x2F;fs&#x2F;cgroup已经存在，下面用到的xxx为任意字符串，取一个有意义的名字就可以了，当用mount命令查看的时候，xxx会显示在第一列。</p>
<ul>
<li><p>挂载一颗和所有subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t cgroup xxx /sys/fs/cgroup</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载一颗和cpuset subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/cpuset</span><br><span class="line">mount -t cgroup -o cpuset</span><br></pre></td></tr></table></figure>

<img src="/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/mount3.png" title alt data-align="center">
</li>
<li><p>挂载一颗与cpu和cpuacct subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/cpu,cpuacct</span><br><span class="line">mount -t cgroup -o cpu,cpuacct xxx /sys/fs/cgroup/cpu,cpuacct</span><br></pre></td></tr></table></figure>

<img src="/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/mount4.png" title alt data-align="center">
</li>
<li><p>挂载一棵cgroup树，但不关联任何subsystem，下面就是systemd所用到的方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /sys/fs/cgroup/systemd</span><br><span class="line">mount -t cgroup -o none,name=systemd xxx /sys/fs/cgroup/systemd</span><br></pre></td></tr></table></figure>

<img src="/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/mount5.png" title alt data-align="center">
</li>
<li><p>删除一个挂载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo umount ....</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在很多使用systemd的系统中，比如ubuntu 16.04，systemd已经帮我们将各个subsystem和cgroup树关联并挂载好了</p>
<p>运行命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount|grep cgroup</span><br></pre></td></tr></table></figure>

<img src="/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/mount.png" title alt data-align="center">

<h1 id="使用cgroup限制一个进程的CPU使用率-cgroup-v2"><a href="#使用cgroup限制一个进程的CPU使用率-cgroup-v2" class="headerlink" title="使用cgroup限制一个进程的CPU使用率(cgroup v2)"></a>使用cgroup限制一个进程的CPU使用率(cgroup v2)</h1><p>首先安装cgroup工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cgroup-tools</span><br></pre></td></tr></table></figure>

<p>确认系统正在使用cgroup v2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/self/cgroup</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/cgroupv2.png" title alt data-align="center"> 如果输出的第一行以<code>0::</code>开头，那么您的系统正在使用cgroup v2。</p>
<p>现在，我们将创建一个名为<code>my_cgroup</code>的cgroup，并限制其CPU使用率为50%。首先创建一个cgroup目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /sys/fs/cgroup/my_cgroup</span><br></pre></td></tr></table></figure>

<p>接下来，为这个cgroup设置CPU权重。cgroup v2使用权重值来调整CPU使用率，范围是1-10000。默认值为100。要将CPU使用率限制为50%，我们将权重设置为50：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 50 | sudo <span class="built_in">tee</span> /sys/fs/cgroup/my_cgroup/cpu.weight</span><br></pre></td></tr></table></figure>

<p>现在，我们将一个进程添加到<code>my_cgroup</code>。例如，假设我们有一个名为<code>my_process</code>的进程，其进程ID为<code>xxxxx</code>。要将此进程添加到<code>my_cgroup</code>，请执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> xxxxx | sudo <span class="built_in">tee</span> -a /sys/fs/cgroup/my_cgroup/cgroup.procs</span><br></pre></td></tr></table></figure>

<p>现在，<code>my_process</code>进程的CPU使用率将受到<code>my_cgroup</code>中的限制。</p>
<p>要查看cgroup的信息，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/xxxxx/cgroup</span><br><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/my_cgroup/cpu.weight</span><br></pre></td></tr></table></figure>

<img src="/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/my_group.png" title alt data-align="center">

<p>要删除一个cgroup，请使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rmdir</span> /sys/fs/cgroup/my_cgroup</span><br></pre></td></tr></table></figure>

<p>在删除cgroup目录之前，需要将所有进程移出这个cgroup。</p>
<p>查找属于cgroup的进程。通常，进程ID存储在<code>cgroup.procs</code>文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/my_cgroup/cgroup.procs</span><br></pre></td></tr></table></figure>

<p>将进程移出cgroup。或者将进程移到其他cgroup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> xxxxx | sudo <span class="built_in">tee</span> /sys/fs/cgroup/cgroup.procs</span><br></pre></td></tr></table></figure>

<p>确认<code>my_cgroup</code>中不再有进程。再次查看<code>cgroup.procs</code>文件，确保其中没有进程ID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/fs/cgroup/my_cgroup/cgroup.procs</span><br></pre></td></tr></table></figure>

<p>再次删除cgroup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rmdir</span> /sys/fs/cgroup/my_cgroup</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://icloudnative.io/posts/understanding-cgroups-part-1-basics/">Linux Cgroup 入门教程：基本概念 – 云原生实验室 - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|云原生 (icloudnative.io)</a></p>
<p><a href="https://segmentfault.com/a/1190000006917884">Linux Cgroup系列（01）：Cgroup概述 - Linux程序员 - SegmentFault 思否</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 Linux 内核操作</title>
    <url>/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="内核基本操作"><a href="#内核基本操作" class="headerlink" title="内核基本操作"></a>内核基本操作</h1><ul>
<li><p>查看系统存在的内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg --list | grep linux-image</span><br></pre></td></tr></table></figure>

<img src="/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/查看系统存在的内核.png" title alt data-align="center">
</li>
<li><p>更新menu.list</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>

<img src="/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/查看系统存在的内核2.png" title alt data-align="center">
</li>
<li><p>显示当前的内核</p>
<img src="/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/显示当前的内核.png" title alt data-align="center">
</li>
<li><p>升级内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除内核</p>
<p><mark>带有image的文件是需要删除的，一定要写全版本等字符。其他相关文件会自动删除。</mark></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove --purge linux-headers-2.6.32-24-generic</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统垃圾清理</p>
<ul>
<li><p>清理旧版本的软件缓存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoclean</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理所有软件缓存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get clean </span><br></pre></td></tr></table></figure>
</li>
<li><p>删除系统不再使用的孤立软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get autoremove</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><ul>
<li><p>安装必备软件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install make</span><br><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install libncurses5-dev</span><br><span class="line">sudo apt install bison</span><br><span class="line">sudo apt install flex</span><br><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>从<a href="https://www.kernel.org/">The Linux Kernel Archives</a>上下载源码，然后解压，并进入文件夹，运行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make mrproper</span><br><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><mark>权限不够就在命令前面加上sudo</mark></p>
<p>在执行完make menuconfig后，会产生图形界面。选择下方的save，将内核配置保存在.config文件中，然后选择exit退出。在编译内核之前，可以通过修改.config的内容来修改内核配置。<img src="/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/图形化界面.png" title alt data-align="center"></p>
</li>
<li><p>配置完成后，编译内核并安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p>如果下列错误</p>
<img src="/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/遇到错误.png" title alt data-align="center">

<p>运行下列命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libelf-dev</span><br></pre></td></tr></table></figure>

<p>继续进行编译，如果遇到如下错误</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">make[<span class="number">2</span>]: *** 没有规则可制作目标“debian<span class="regexp">/canonical-certs.pem”，由“certs/</span>x509_certificate_list” 需求。 停止。</span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">make[<span class="number">2</span>]: *** 没有规则可制作目标“debian<span class="regexp">/canonical-revoked-certs.pem”，由“certs/</span>x509_revocation_list” 需求。 停止。</span><br></pre></td></tr></table></figure>

<p>那么运行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts/config --disable SYSTEM_TRUSTED_KEYS</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scripts/config --disable SYSTEM_REVOCATION_KEYS</span><br></pre></td></tr></table></figure>

<p>之后继续编译至完成</p>
</li>
</ul>
<h1 id="切换运行内核"><a href="#切换运行内核" class="headerlink" title="切换运行内核"></a>切换运行内核</h1><ul>
<li><p>查看当前内核的启动顺序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /boot/grub/grub.cfg |grep menuentry</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改文件在启动时选择内核</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo  vim /etc/default/grub</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot now</span><br></pre></td></tr></table></figure>
</li>
<li><p>选择Advanced options for Ubuntu</p>
<img src="/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/Ubuntu启动选择1.png" title alt data-align="center">
</li>
<li><p>选择要启动的内核</p>
<img src="/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/ubuntu启动选择2.png" title alt data-align="center"></li>
</ul>
<h1 id="添加输出"><a href="#添加输出" class="headerlink" title="添加输出"></a>添加输出</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strstr</span>(current-&gt;comm, <span class="string">&quot;cat&quot;</span>))</span><br><span class="line">printk(<span class="string">&quot;%p&quot;</span>,f1);</span><br></pre></td></tr></table></figure>

<h1 id="切换cgroupv1-gt-cgroupv2"><a href="#切换cgroupv1-gt-cgroupv2" class="headerlink" title="切换cgroupv1-&gt;cgroupv2"></a>切换cgroupv1-&gt;cgroupv2</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo  vim /etc/default/grub</span><br><span class="line">systemd.unified_cgroup_hierarchy=1</span><br><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=&quot;systemd.unified_cgroup_hierarchy=1&quot;</span><br><span class="line">sudo update-grub</span><br><span class="line">sudo reboot now</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>学习 Linux tmpfs</title>
    <url>/2023/06/10/%E5%AD%A6%E4%B9%A0-Linux-tmpfs/</url>
    <content><![CDATA[<h1 id="tmpfs简介"><a href="#tmpfs简介" class="headerlink" title="tmpfs简介"></a>tmpfs简介</h1><p><strong>tmpfs</strong>（英语：<strong>t</strong>e<strong>mp</strong>orary <strong>f</strong>ile <strong>s</strong>ystem） 是<a href="https://zh.wikipedia.org/wiki/%E9%A1%9EUnix%E7%B3%BB%E7%B5%B1" title="类Unix系统">类Unix系统</a>上暂存档存储空间的常见名称，通常以挂载文件系统方式实现，并将资料存储在<a href="https://zh.wikipedia.org/wiki/%E6%8F%AE%E7%99%BC%E6%80%A7%E8%A8%98%E6%86%B6%E9%AB%94" title="易失性存储器">易失性存储器</a>而非永久存储设备中。和<a href="https://zh.wikipedia.org/wiki/RAM_disk" title="RAM disk">RAM disk</a>的概念近似，但后者会呈现出具有完整文件系统的虚拟磁盘。</p>
<p>tmpfs的工作原理是，它使用计算机的内存来模拟一个文件系统，就像在硬盘上创建了一个虚拟的文件柜。当你在tmpfs上创建文件或文件夹时，实际上它们是存储在内存中的。这样，访问这些文件会非常快，因为内存的速度比硬盘快得多。但是，需要注意的是，当计算机关闭或重启时，内存中的数据会丢失，所以存储在tmpfs上的文件也会消失。</p>
<p>tmpfs是一种特殊的文件系统，它可以让你把计算机的内存（RAM）当作硬盘来使用。这样做的优点是，因为内存的速度比硬盘快得多，所以访问存储在tmpfs上的文件会非常快。tmpfs通常用于存放临时文件，这些文件在计算机重启后会自动消失。这样可以避免硬盘上堆积很多不必要的临时文件，提高硬盘的使用效率和计算机的性能。</p>
<h1 id="tmpfs文件系统使用"><a href="#tmpfs文件系统使用" class="headerlink" title="tmpfs文件系统使用"></a>tmpfs文件系统使用</h1><h2 id="创建和挂载tmpfs文件系统"><a href="#创建和挂载tmpfs文件系统" class="headerlink" title="创建和挂载tmpfs文件系统"></a>创建和挂载tmpfs文件系统</h2><p>首先创建一个文件夹<code>/home/plucky/path</code></p>
<p>运行mount命令，挂载tmpfs文件系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t tmpfs -o size=512M tmpfs 文件夹（/home/plucky/path)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-t tmpfs</code>表示我们要挂载的文件系统类型是tmpfs</p>
</li>
<li><p><code>-o size=512M</code>表示tmpfs文件系统的大小为512M字节</p>
</li>
<li><p><code>tmpfs</code>是文件系统的名称</p>
</li>
<li><p>文件夹是挂载点的文件夹</p>
</li>
</ul>
<p>现在，你已经成功挂载了一个tmpfs文件系统。您可以像使用普通目录一样使用它，例如在其中创建文件和子目录。但请记住，存储在此tmpfs文件系统上的文件和目录将仅保存在内存中，计算机重启后它们将消失。</p>
<h2 id="在已经挂载的tmpfs文件系统中创建并存储一个新文件"><a href="#在已经挂载的tmpfs文件系统中创建并存储一个新文件" class="headerlink" title="在已经挂载的tmpfs文件系统中创建并存储一个新文件"></a>在已经挂载的tmpfs文件系统中创建并存储一个新文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;This is a test file.&quot;</span> &gt; /home/plucky/tmpfs/testfile.txt</span></span><br></pre></td></tr></table></figure>

<p>假设已经将 <code>tmpfs</code> 文件系统挂载到了 <code>/home/plucky/tmpfs</code> 目录下。这个命令将在 <code>/mnt/tmpfs</code> 文件夹中创建一个名为 <code>testfile.txt</code> 的新文件，并写入文本 “This is a test file.”。</p>
<p>当这个命令执行时，将发生以下事情：</p>
<ol>
<li><p>首先，shell 进程通过 <code>open</code> 或 <code>openat</code> 系统调用尝试创建或打开文件 <code>/home/plucky/tmpfs/testfile.txt</code>。系统调用的标志将包括 <code>O_WRONLY</code>（只写）和 <code>O_CREAT</code>（如果文件不存在则创建）。</p>
</li>
<li><p>内核将解析文件路径，并确认 <code>/home/plucky/tmpfs</code> 是一个已挂载的 <code>tmpfs</code> 文件系统。</p>
</li>
<li><p>在 <code>tmpfs</code> 文件系统中，内核将根据需要创建一个新的 inode。这涉及分配内存来存储 inode 本身以及文件的元数据（如权限、所有者等）。</p>
</li>
<li><p>文件创建成功后，shell 进程将获得一个文件描述符，用于写入文件。</p>
</li>
<li><p>然后，shell 进程通过 <code>write</code> 系统调用将文本 “This is a test file.” 写入文件。这将导致内核在 <code>tmpfs</code> 文件系统中分配内存来存储文件数据。</p>
</li>
<li><p>当文本被写入文件后，shell 进程使用 <code>close</code> 系统调用关闭文件描述符。</p>
</li>
</ol>
<h2 id="删除tmpfs文件系统的命令"><a href="#删除tmpfs文件系统的命令" class="headerlink" title="删除tmpfs文件系统的命令"></a>删除tmpfs文件系统的命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm /home/plucky/path/mytmpfs/testfile.txt </span><br></pre></td></tr></table></figure>

<p>当运行此命令时，会发生以下事情：</p>
<ol>
<li><p>首先，shell 进程通过 <code>unlink</code> 或 <code>unlinkat</code> 系统调用尝试删除文件 <code>/home/plucky/path/mytmpfs/testfile.txt</code>。</p>
</li>
<li><p>内核将解析文件路径，并确认 <code>/mnt/tmpfs</code> 是一个已挂载的 <code>tmpfs</code> 文件系统。</p>
</li>
<li><p>接下来，内核将通过 <code>tmpfs</code> 文件系统的 <code>inode_operations</code> 结构体中的 <code>unlink</code> 方法来执行删除操作。具体来说，对于 <code>tmpfs</code>，这个方法是 <code>shmem_unlink</code>。</p>
</li>
<li><p><code>shmem_unlink</code> 函数将处理文件的内存释放。这包括释放文件数据占用的内存和文件元数据（如 inode）占用的内存。</p>
</li>
<li><p>最后，文件从文件系统中删除，不再可访问。</p>
</li>
</ol>
<h2 id="重启机器之后，tmpfs文件夹"><a href="#重启机器之后，tmpfs文件夹" class="headerlink" title="重启机器之后，tmpfs文件夹"></a>重启机器之后，tmpfs文件夹</h2><p>tmpfs文件系统中的文件被删除，而tmpfs文件系统也被卸载</p>
<p>如果要在系统启动时自动挂载tmpfs命令，需要将挂载信息添加到系统的启动配置文件中。这样每次系统启动时，该文件系统都会自动挂载。例如，要将一个 <code>tmpfs</code> 文件系统挂载到 <code>/home/plucky/mytmpfs</code> 目录，可以在 <code>/etc/fstab</code> 文件中添加以下行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmpfs /home/plucky/mytmpfs tmpfs defaults 0 0</span><br></pre></td></tr></table></figure>

<p>即运行一下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh -c &#x27;echo &quot;tmpfs /home/plucky/path/mytmpfs tmpfs defaults 0 0&quot; &gt;&gt; /etc/fstab&#x27;</span><br></pre></td></tr></table></figure>

<p><code>sudo</code> 命令用于以管理员权限运行此命令，因为 <code>/etc/fstab</code> 文件需要管理员权限才能修改。</p>
<h1 id="tmpfs的实现"><a href="#tmpfs的实现" class="headerlink" title="tmpfs的实现"></a>tmpfs的实现</h1><h2 id="函数调用链（Linux-v6-3-6，v6-3-7为例）"><a href="#函数调用链（Linux-v6-3-6，v6-3-7为例）" class="headerlink" title="函数调用链（Linux v6.3.6，v6.3.7为例）"></a>函数调用链（Linux v6.3.6，v6.3.7为例）</h2><ol>
<li><p><strong>挂载<code>tmpfs</code>文件系统</strong>：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">mount</span><br><span class="line">    └── do_mount</span><br><span class="line">        └── path_mount</span><br><span class="line">           └── do_new_mount</span><br><span class="line">               ├── vfs_get_tree（基于给定的上下文创建并初始化一个新的文件系统实例）</span><br><span class="line">               │   └── <span class="keyword">shmem_get_tree</span></span><br><span class="line"><span class="keyword"></span>               │       └── <span class="keyword">shmem_fill_super</span></span><br><span class="line"><span class="keyword"></span>               │           └── <span class="keyword">shmem_get_inode</span></span><br><span class="line"><span class="keyword"></span>               └── do_new_mount_fs</span><br><span class="line">                   └── do_add_mount</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>存储文件进入<code>tmpfs</code>文件系统</strong>：</p>
<ul>
<li><p>打开文件或创建新文件：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">open</span><span class="params">()</span></span></span><br><span class="line">    └── do_sys_open</span><br><span class="line">        └── do_filp_open</span><br><span class="line">            ├── path_openat</span><br><span class="line">            │    ├── link_path_walk</span><br><span class="line">            │    │     ├── lookup_fast</span><br><span class="line">            │    │     │     └── __d_lookup_rcu</span><br><span class="line">            │    │     │         └── hlist_bl_for_each_entry_rcu</span><br><span class="line">            │    │     └── lookup_slow</span><br><span class="line">            │    │           └── __lookup_slow</span><br><span class="line">            │    │               └──simple_lookup</span><br><span class="line">            │    └── open_last_lookups（创建新文件）</span><br><span class="line">            │          └──shmem_create</span><br><span class="line">            │                 └── shmem_mknod</span><br><span class="line">            └── do_open</span><br><span class="line">                  └── vfs_open</span><br><span class="line">                        └── do_dentry_open</span><br></pre></td></tr></table></figure>
</li>
<li><p>读文件：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">read</span><span class="params">()</span></span></span><br><span class="line">    └── ksys_read</span><br><span class="line">        └── vfs_read</span><br><span class="line">            └── new_sync_read</span><br><span class="line">                └── call_read_iter</span><br><span class="line">                    └── shmem_file_read_iter</span><br></pre></td></tr></table></figure>
</li>
<li><p>写文件：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">write</span><span class="params">()</span></span></span><br><span class="line">    └── ksys_write</span><br><span class="line">        └── vfs_write</span><br><span class="line">            └── new_sync_write</span><br><span class="line">                └── call_write_iter</span><br><span class="line">                    └── generic_file_write_iter</span><br><span class="line">                        └── __generic_file_write_iter</span><br><span class="line">                            ├── generic_file_direct_write直写</span><br><span class="line">                            └── generic_perform_write回写</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>删除文件</strong>：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">unlink</span><span class="params">()</span></span></span><br><span class="line">    └── do_unlinkat</span><br><span class="line">        └── vfs_unlink</span><br><span class="line">            └── shmem_unlink</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="挂载tmpfs文件系统流程"><a href="#挂载tmpfs文件系统流程" class="headerlink" title="挂载tmpfs文件系统流程"></a>挂载tmpfs文件系统流程</h2><p>当用户运行mount命令时，首先执行mount系统调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -t tmpfs -o size=512M tmpfs 文件夹</span><br></pre></td></tr></table></figure>

<h3 id="mount系统调用"><a href="#mount系统调用" class="headerlink" title="mount系统调用"></a>mount系统调用</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/sys_mount">sys_mount identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统调用的定义，包括5个参数：dev_name, dir_name, type, flags, data。</span></span><br><span class="line">SYSCALL_DEFINE5(mount, <span class="type">char</span> __user *, dev_name, <span class="type">char</span> __user *, dir_name,</span><br><span class="line">        <span class="type">char</span> __user *, type, <span class="type">unsigned</span> <span class="type">long</span>, flags, <span class="type">void</span> __user *, data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret; <span class="comment">// 用于存储返回值</span></span><br><span class="line">    <span class="type">char</span> *kernel_type; <span class="comment">// 从用户空间拷贝的文件系统类型字符串</span></span><br><span class="line">    <span class="type">char</span> *kernel_dev; <span class="comment">// 从用户空间拷贝的设备名或源字符串</span></span><br><span class="line">    <span class="type">void</span> *options; <span class="comment">// 从用户空间拷贝的挂载选项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件系统类型从用户空间拷贝到内核空间</span></span><br><span class="line">    kernel_type = copy_mount_string(type);</span><br><span class="line">    <span class="comment">// 检查拷贝操作是否出错</span></span><br><span class="line">    ret = PTR_ERR(kernel_type);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kernel_type))</span><br><span class="line">        <span class="keyword">goto</span> out_type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将设备名或源从用户空间拷贝到内核空间</span></span><br><span class="line">    kernel_dev = copy_mount_string(dev_name);</span><br><span class="line">    <span class="comment">// 检查拷贝操作是否出错</span></span><br><span class="line">    ret = PTR_ERR(kernel_dev);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kernel_dev))</span><br><span class="line">        <span class="keyword">goto</span> out_dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将挂载选项从用户空间拷贝到内核空间</span></span><br><span class="line">    options = copy_mount_options(data);</span><br><span class="line">    <span class="comment">// 检查拷贝操作是否出错</span></span><br><span class="line">    ret = PTR_ERR(options);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(options))</span><br><span class="line">        <span class="keyword">goto</span> out_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行挂载操作</span></span><br><span class="line">    ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放挂载选项内存</span></span><br><span class="line">    kfree(options);</span><br><span class="line">out_data:</span><br><span class="line">    <span class="comment">// 释放设备名或源内存</span></span><br><span class="line">    kfree(kernel_dev);</span><br><span class="line">out_dev:</span><br><span class="line">    <span class="comment">// 释放文件系统类型内存</span></span><br><span class="line">    kfree(kernel_type);</span><br><span class="line">out_type:</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将<code>dev_name</code>、<code>dir_name</code>、<code>type</code>和<code>data</code>这些从用户空间传入的参数拷贝到内核空间。然后，它调用<code>do_mount</code>函数来执行实际的挂载操作。</p>
<h3 id="do-mount函数"><a href="#do-mount函数" class="headerlink" title="do_mount函数"></a>do_mount函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/do_mount">do_mount identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">const</span> <span class="type">char</span> __user *dir_name,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *type_page, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> *data_page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 用于存储挂载点的路径结构</span></span><br><span class="line">    <span class="type">int</span> ret; <span class="comment">// 用于存储返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户空间传入的挂载点路径，并将其解析为内核空间的路径结构</span></span><br><span class="line">    ret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path);</span><br><span class="line">    <span class="keyword">if</span> (ret) <span class="comment">// 检查路径解析是否成功</span></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行实际的挂载操作</span></span><br><span class="line">    ret = path_mount(dev_name, &amp;path, type_page, flags, data_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放路径结构的引用</span></span><br><span class="line">    path_put(&amp;path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>user_path_at</code>函数将用户空间传入的挂载点路径解析为内核空间的<code>path</code>结构。然后，调用<code>path_mount</code>函数执行实际的挂载操作。完成挂载操作后，释放<code>path</code>结构的引用。</p>
<h3 id="path-mount函数"><a href="#path-mount函数" class="headerlink" title="path_mount函数"></a>path_mount函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/path_mount">path_mount identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">path_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dev_name, <span class="keyword">struct</span> path *path,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *type_page, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> *data_page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mnt_flags = <span class="number">0</span>, sb_flags; <span class="comment">// 定义挂载标志和超级块标志</span></span><br><span class="line">    <span class="type">int</span> ret; <span class="comment">// 用于存储返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除挂载标志的幻数（magic number）</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL)</span><br><span class="line">        flags &amp;= ~MS_MGC_MSK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本的参数检查</span></span><br><span class="line">    <span class="keyword">if</span> (data_page)</span><br><span class="line">        ((<span class="type">char</span> *)data_page)[PAGE_SIZE - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查不允许用户挂载的情况</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOUSER)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全检查</span></span><br><span class="line">    ret = security_sb_mount(dev_name, path, type_page, flags, data_page);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (!may_mount())</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SB_MANDLOCK)</span><br><span class="line">        warn_mandlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认设置为relatime，除非显式指定noatime</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MS_NOATIME))</span><br><span class="line">        mnt_flags |= MNT_RELATIME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离每个挂载点的标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOSUID)</span><br><span class="line">        mnt_flags |= MNT_NOSUID;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NODEV)</span><br><span class="line">        mnt_flags |= MNT_NODEV;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOEXEC)</span><br><span class="line">        mnt_flags |= MNT_NOEXEC;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOATIME)</span><br><span class="line">        mnt_flags |= MNT_NOATIME;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NODIRATIME)</span><br><span class="line">        mnt_flags |= MNT_NODIRATIME;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_STRICTATIME)</span><br><span class="line">        mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_RDONLY)</span><br><span class="line">        mnt_flags |= MNT_READONLY;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOSYMFOLLOW)</span><br><span class="line">        mnt_flags |= MNT_NOSYMFOLLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保留atime的默认值</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; MS_REMOUNT) &amp;&amp;</span><br><span class="line">        ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |</span><br><span class="line">               MS_STRICTATIME)) == <span class="number">0</span>)) &#123;</span><br><span class="line">        mnt_flags &amp;= ~MNT_ATIME_MASK;</span><br><span class="line">        mnt_flags |= path-&gt;mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置超级块标志</span></span><br><span class="line">    sb_flags = flags &amp; (SB_RDONLY |</span><br><span class="line">                SB_SYNCHRONOUS |</span><br><span class="line">                SB_MANDLOCK |</span><br><span class="line">                SB_DIRSYNC |</span><br><span class="line">                SB_SILENT |</span><br><span class="line">                SB_POSIXACL |</span><br><span class="line">                SB_LAZYTIME |</span><br><span class="line">                SB_I_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新配置挂载点</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))</span><br><span class="line">        <span class="keyword">return</span> do_reconfigure_mnt(path, mnt_flags);</span><br><span class="line">    <span class="comment">// 重新挂载</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_REMOUNT)</span><br><span class="line">        <span class="keyword">return</span> do_remount(path, flags, sb_flags, mnt_flags, data_page);</span><br><span class="line">    <span class="comment">// 绑定挂载</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_BIND)</span><br><span class="line">        <span class="keyword">return</span> do_loopback(path, dev_name, flags &amp; MS_REC);</span><br><span class="line">    <span class="comment">// 更改挂载类型</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))</span><br><span class="line">        <span class="keyword">return</span> do_change_type(path, flags);</span><br><span class="line">    <span class="comment">// 移动挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_MOVE)</span><br><span class="line">        <span class="keyword">return</span> do_move_mount_old(path, dev_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行新的挂载操作</span></span><br><span class="line">    <span class="keyword">return</span> do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,</span><br><span class="line">                data_page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>path_mount</code>函数负责处理不同类型的挂载请求，包括重新挂载、绑定挂载、更改挂载类型和移动挂载点。首先，函数执行基本的参数检查、安全检查和设置挂载标志。接下来，根据不同的挂载标志，调用相应的处理函数。</p>
<h3 id="do-new-mount函数"><a href="#do-new-mount函数" class="headerlink" title="do_new_mount函数"></a>do_new_mount函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/do_new_mount">do_new_mount identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_new_mount</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">const</span> <span class="type">char</span> *fstype, <span class="type">int</span> sb_flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> mnt_flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">type</span>;</span> <span class="comment">// 文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span> <span class="comment">// 文件系统上下文</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *subtype = <span class="literal">NULL</span>; <span class="comment">// 子类型</span></span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>; <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证文件系统类型是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!fstype)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件系统类型</span></span><br><span class="line">    type = get_fs_type(fstype);</span><br><span class="line">    <span class="keyword">if</span> (!type)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件系统是否有子类型，并获取子类型</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &#123;</span><br><span class="line">        subtype = <span class="built_in">strchr</span>(fstype, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (subtype) &#123;</span><br><span class="line">            subtype++;</span><br><span class="line">            <span class="keyword">if</span> (!*subtype) &#123;</span><br><span class="line">                put_filesystem(type);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件系统上下文</span></span><br><span class="line">    fc = fs_context_for_mount(type, sb_flags);</span><br><span class="line">    put_filesystem(type); <span class="comment">// 减少文件系统类型的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(fc))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(fc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析文件系统子类型</span></span><br><span class="line">    <span class="keyword">if</span> (subtype)</span><br><span class="line">        err = vfs_parse_fs_string(fc, <span class="string">&quot;subtype&quot;</span>,</span><br><span class="line">                      subtype, <span class="built_in">strlen</span>(subtype));</span><br><span class="line">    <span class="comment">// 解析文件系统名称</span></span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; name)</span><br><span class="line">        err = vfs_parse_fs_string(fc, <span class="string">&quot;source&quot;</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="comment">// 解析挂载数据</span></span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        err = parse_monolithic_mount_data(fc, data);</span><br><span class="line">    <span class="comment">// 检查挂载权限</span></span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; !mount_capable(fc))</span><br><span class="line">        err = -EPERM;</span><br><span class="line">    <span class="comment">// 获取文件系统树</span></span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        err = vfs_get_tree(fc);</span><br><span class="line">    <span class="comment">// 完成挂载操作</span></span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        err = do_new_mount_fc(fc, path, mnt_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放文件系统上下文</span></span><br><span class="line">    put_fs_context(fc);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vfs-get-tree函数"><a href="#vfs-get-tree函数" class="headerlink" title="vfs_get_tree函数"></a>vfs_get_tree函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vfs_get_tree</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span> <span class="comment">// 超级块</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件系统上下文中已经有一个根目录，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;root)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用文件系统操作结构中的get_tree函数来获取文件系统树，并将根目录放在fc-&gt;root中</span></span><br><span class="line">    <span class="comment">// 同时增加根目录和超级块的引用计数</span></span><br><span class="line">    error = fc-&gt;ops-&gt;get_tree(fc);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果get_tree没有设置fc-&gt;root，则输出错误信息并触发BUG()</span></span><br><span class="line">    <span class="keyword">if</span> (!fc-&gt;root) &#123;</span><br><span class="line">        pr_err(<span class="string">&quot;Filesystem %s get_tree() didn&#x27;t set fc-&gt;root\n&quot;</span>,</span><br><span class="line">               fc-&gt;fs_type-&gt;name);</span><br><span class="line">        BUG();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取超级块</span></span><br><span class="line">    sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">    <span class="comment">// 检查超级块的块设备信息是否存在</span></span><br><span class="line">    WARN_ON(!sb-&gt;s_bdi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写内存屏障，确保超级块结构在设置SB_BORN标志位之前完成</span></span><br><span class="line">    smp_wmb();</span><br><span class="line">    <span class="comment">// 设置超级块的SB_BORN标志位</span></span><br><span class="line">    sb-&gt;s_flags |= SB_BORN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置安全模块的挂载选项</span></span><br><span class="line">    error = security_sb_set_mnt_opts(sb, fc-&gt;security, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">        <span class="comment">// 如果设置失败，释放文件系统上下文并返回错误</span></span><br><span class="line">        fc_drop_locked(fc);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件系统是否设置了错误的s_maxbytes值</span></span><br><span class="line">    WARN((sb-&gt;s_maxbytes &lt; <span class="number">0</span>), <span class="string">&quot;%s set sb-&gt;s_maxbytes to &quot;</span></span><br><span class="line">        <span class="string">&quot;negative value (%lld)\n&quot;</span>, fc-&gt;fs_type-&gt;name, sb-&gt;s_maxbytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_get_tree);</span><br></pre></td></tr></table></figure>

<h3 id="get-tree函数是如何被设置为shmem-init函数的"><a href="#get-tree函数是如何被设置为shmem-init函数的" class="headerlink" title="get_tree函数是如何被设置为shmem_init函数的"></a>get_tree函数是如何被设置为shmem_init函数的</h3><ol>
<li><p>当内核启动时，会执行<code>shmem_init</code>函数（定义在<code>mm/shmem.c</code>文件中）。这个函数会调用<code>register_filesystem</code>注册tmpfs文件系统。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_init">shmem_init identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">shmem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初始化 inode 缓存</span></span><br><span class="line">shmem_init_inodecache();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 tmpfs 文件系统</span></span><br><span class="line"><span class="type">int</span> error = register_filesystem(&amp;shmem_fs_type);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 若注册失败，打印错误信息</span></span><br><span class="line">    pr_err(<span class="string">&quot;Could not register tmpfs\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 跳转到 out2，执行清理操作</span></span><br><span class="line">    <span class="keyword">goto</span> out2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试挂载 tmpfs 文件系统</span></span><br><span class="line">shm_mnt = kern_mount(&amp;shmem_fs_type);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(shm_mnt)) &#123;</span><br><span class="line">    <span class="comment">// 若挂载失败，获取错误代码</span></span><br><span class="line">    error = PTR_ERR(shm_mnt);</span><br><span class="line">    <span class="comment">// 打印错误信息</span></span><br><span class="line">    pr_err(<span class="string">&quot;Could not kern_mount tmpfs\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 跳转到 out1，执行清理操作</span></span><br><span class="line">    <span class="keyword">goto</span> out1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line"><span class="comment">// 如果支持透明巨页，且巨页设置不为禁用，设置巨页选项</span></span><br><span class="line"><span class="keyword">if</span> (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY)</span><br><span class="line">    SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 否则，将巨页设置为永不使用，以防万一</span></span><br><span class="line">    shmem_huge = SHMEM_HUGE_NEVER;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功执行，函数返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">out1:</span><br><span class="line"><span class="comment">// 清理操作：注销 tmpfs 文件系统</span></span><br><span class="line">unregister_filesystem(&amp;shmem_fs_type);</span><br><span class="line"></span><br><span class="line">out2:</span><br><span class="line"><span class="comment">// 清理操作：销毁 inode 缓存</span></span><br><span class="line">shmem_destroy_inodecache();</span><br><span class="line"><span class="comment">// 设置 shm_mnt 为错误指针，表示初始化失败</span></span><br><span class="line">shm_mnt = ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shmem_fs_type</code>是一个<code>file_system_type</code>结构体，定义了tmpfs文件系统的基本信息。在这个结构体中，<code>init_fs_context</code>成员被设置为<code>shmem_init_fs_context</code>。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_fs_type">shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">shmem_fs_type</span> =</span> &#123;</span><br><span class="line">.owner          = THIS_MODULE, <span class="comment">// 指定文件系统模块的所有者</span></span><br><span class="line">.name           = <span class="string">&quot;tmpfs&quot;</span>, <span class="comment">// 文件系统的名称</span></span><br><span class="line">.init_fs_context = shmem_init_fs_context, <span class="comment">// 初始化文件系统上下文的回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">.parameters     = shmem_fs_parameters, <span class="comment">// 指定文件系统的挂载参数解析回调</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.kill_sb        = kill_litter_super, <span class="comment">// 用于销毁超级块的回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SHMEM</span></span><br><span class="line">.fs_flags       = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, <span class="comment">// 文件系统的标志（支持用户命名空间挂载和ID映射）</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">.fs_flags       = FS_USERNS_MOUNT, <span class="comment">// 文件系统的标志（仅支持用户命名空间挂载）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当用户发起挂载tmpfs文件系统的请求时，内核会根据<code>shmem_fs_type</code>结构体中的<code>init_fs_context</code>成员调用<code>shmem_init_fs_context</code>函数，以初始化文件系统上下文（<code>fs_context</code>结构体）。</p>
</li>
<li><p>在<code>shmem_init_fs_context</code>函数中，会创建一个<code>shmem_fs_context</code>结构体实例并将其存储在<code>fc-&gt;fs_private</code>成员中。然后，将<code>fs_context</code>结构体的<code>ops</code>成员设置为<code>&amp;shmem_fs_context_ops</code>。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_init_fs_context">shmem_init_fs_context identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmem_init_fs_context</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义一个指向 shmem_options 结构体的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmem_options</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 shmem_options 结构体分配内存</span></span><br><span class="line">ctx = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> shmem_options), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!ctx)</span><br><span class="line">    <span class="comment">// 如果内存分配失败，返回 ENOMEM 错误</span></span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件访问权限为 0777（用户、组和其他均有读、写和执行权限），并启用粘滞位</span></span><br><span class="line">ctx-&gt;mode = <span class="number">0777</span> | S_ISVTX;</span><br><span class="line"><span class="comment">// 获取当前进程的文件系统用户 ID，并将其设置为文件系统上下文的用户 ID</span></span><br><span class="line">ctx-&gt;uid = current_fsuid();</span><br><span class="line"><span class="comment">// 获取当前进程的文件系统组 ID，并将其设置为文件系统上下文的组 ID</span></span><br><span class="line">ctx-&gt;gid = current_fsgid();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将初始化后的 shmem_options 结构体赋给 fs_context 结构体的 fs_private 成员</span></span><br><span class="line">fc-&gt;fs_private = ctx;</span><br><span class="line"><span class="comment">// 设置 fs_context 结构体的操作函数集</span></span><br><span class="line">fc-&gt;ops = &amp;shmem_fs_context_ops;</span><br><span class="line"><span class="comment">// 返回 0，表示成功初始化文</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shmem_fs_context_ops</code>是一个<code>fs_context_operations</code>结构体，其中的<code>get_tree</code>成员被设置为<code>shmem_get_tree</code>。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_fs_context_ops">shmem_fs_context_ops identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> <span class="title">shmem_fs_context_ops</span> =</span> &#123;</span><br><span class="line">.<span class="built_in">free</span>            = shmem_free_fc,</span><br><span class="line">.get_tree        = shmem_get_tree,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">.parse_monolithic    = shmem_parse_options,</span><br><span class="line">.parse_param        = shmem_parse_one,</span><br><span class="line">.reconfigure        = shmem_reconfigure,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当内核继续执行挂载过程，调用<code>vfs_get_tree</code>函数时，会根据<code>fs_context</code>结构体的<code>ops</code>成员（即<code>&amp;shmem_fs_context_ops</code>）间接调用<code>shmem_get_tree</code>函数。</p>
</li>
</ol>
<h3 id="shmem-get-tree函数"><a href="#shmem-get-tree函数" class="headerlink" title="shmem_get_tree函数"></a>shmem_get_tree函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_get_tree">shmem_get_tree identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_get_tree</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> get_tree_nodev(fc, shmem_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shmem-fill-super函数"><a href="#shmem-fill-super函数" class="headerlink" title="shmem_fill_super函数"></a>shmem_fill_super函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_fill_super">shmem_fill_super identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_options</span> *<span class="title">ctx</span> =</span> fc-&gt;fs_private;</span><br><span class="line"><span class="comment">//ctx指向一个shmem_options结构体，包含了tmpfs实例的选项，如最大块数、最大inode数等。这些选项通常在挂载tmpfs时由用户指定。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"><span class="comment">//inode指向一个inode结构体，用于表示文件系统中的一个文件。这里的inode将用于表示tmpfs实例的根目录。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_sb_info</span> *<span class="title">sbinfo</span>;</span></span><br><span class="line"><span class="comment">//sbinfo指向一个shmem_sb_info结构体，包含了tmpfs实例的元数据，如最大块数、最大inode数、已使用的块数等。</span></span><br><span class="line">    <span class="comment">/* Round up to L1_CACHE_BYTES to resist false sharing */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为shmem_sb_info结构体分配内存，考虑缓存对齐 */</span></span><br><span class="line">    sbinfo = kzalloc(max((<span class="type">int</span>)<span class="keyword">sizeof</span>(<span class="keyword">struct</span> shmem_sb_info),</span><br><span class="line">                L1_CACHE_BYTES), GFP_KERNEL);</span><br><span class="line">    <span class="comment">/* 分配内存失败时返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (!sbinfo)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将shmem_sb_info结构体指针保存到super_block的s_fs_info字段 */</span></span><br><span class="line">    sb-&gt;s_fs_info = sbinfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Per default we only allow half of the physical ram per</span></span><br><span class="line"><span class="comment">     * tmpfs instance, limiting inodes to one per page of lowmem;</span></span><br><span class="line"><span class="comment">     * but the internal instance is left unlimited.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*默认情况下，我们只允许每</span></span><br><span class="line"><span class="comment">*tmpfs实例，将inode限制为每页lowmem一个；</span></span><br><span class="line"><span class="comment">*但是内部实例是不受限制的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//对于非内核挂载的tmpfs实例，设置默认的最大块数、最大inode数和是否使用64位inode编号。对于内核挂载的tmpfs实例，设置SB_N#ifdef CONFIG_TMPFS</span></span><br><span class="line"><span class="comment">/* 判断是否为内核挂载 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(sb-&gt;s_flags &amp; SB_KERNMOUNT)) &#123;</span><br><span class="line">        <span class="comment">/* 设置默认的最大块数（如果未指定） */</span></span><br><span class="line">        <span class="keyword">if</span> (!(ctx-&gt;seen &amp; SHMEM_SEEN_BLOCKS))</span><br><span class="line">            ctx-&gt;blocks = shmem_default_max_blocks();</span><br><span class="line">        <span class="comment">/* 设置默认的最大inode数（如果未指定） */</span></span><br><span class="line">        <span class="keyword">if</span> (!(ctx-&gt;seen &amp; SHMEM_SEEN_INODES))</span><br><span class="line">            ctx-&gt;inodes = shmem_default_max_inodes();</span><br><span class="line">        <span class="comment">/* 设置是否使用64位inode编号（如果未指定） */</span></span><br><span class="line">        <span class="keyword">if</span> (!(ctx-&gt;seen &amp; SHMEM_SEEN_INUMS))</span><br><span class="line">            ctx-&gt;full_inums = IS_ENABLED(CONFIG_TMPFS_INODE64);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 内核挂载的tmpfs实例，设置SB_NOUSER标志 */</span></span><br><span class="line">        sb-&gt;s_flags |= SB_NOUSER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置文件系统导出操作 */</span></span><br><span class="line">    sb-&gt;s_export_op = &amp;shmem_export_ops;</span><br><span class="line">    <span class="comment">/* 设置文件系统标志 */</span></span><br><span class="line">    sb-&gt;s_flags |= SB_NOSEC | SB_I_VERSION;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">/* 如果不支持tmpfs，设置SB_NOUSER标志 */</span></span><br><span class="line">    sb-&gt;s_flags |= SB_NOUSER;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 设置shmem_sb_info的最大块数字段 */</span></span><br><span class="line">    sbinfo-&gt;max_blocks = ctx-&gt;blocks;</span><br><span class="line">    <span class="comment">/* 设置shmem_sb_info的最大inode数量和空闲inode数量 */</span></span><br><span class="line">    sbinfo-&gt;free_inodes = sbinfo-&gt;max_inodes = ctx-&gt;inodes;</span><br><span class="line">    <span class="comment">/* 如果是内核挂载，为每个CPU分配一个ino_t类型的内存 */</span></span><br><span class="line">    <span class="keyword">if</span> (sb-&gt;s_flags &amp; SB_KERNMOUNT) &#123;</span><br><span class="line">        sbinfo-&gt;ino_batch = alloc_percpu(<span class="type">ino_t</span>);</span><br><span class="line">        <span class="comment">/* 分配失败时跳转到失败处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (!sbinfo-&gt;ino_batch)</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 设置uid和gid */</span></span><br><span class="line">    sbinfo-&gt;uid = ctx-&gt;uid;</span><br><span class="line">    sbinfo-&gt;gid = ctx-&gt;gid;</span><br><span class="line">    <span class="comment">/* 设置是否使用64位inode编号 */</span></span><br><span class="line">    sbinfo-&gt;full_inums = ctx-&gt;full_inums;</span><br><span class="line">    <span class="comment">/* 设置权限模式 */</span></span><br><span class="line">    sbinfo-&gt;mode = ctx-&gt;mode;</span><br><span class="line">    <span class="comment">/* 设置是否使用大页面 */</span></span><br><span class="line">    sbinfo-&gt;huge = ctx-&gt;huge;</span><br><span class="line">    <span class="comment">/* 设置内存分配策略 */</span></span><br><span class="line">    sbinfo-&gt;mpol = ctx-&gt;mpol;</span><br><span class="line">    <span class="comment">/* 清空ctx的mpol指针，避免后续释放 */</span></span><br><span class="line">    ctx-&gt;mpol = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化stat_lock自旋锁 */</span></span><br><span class="line">    raw_spin_lock_init(&amp;sbinfo-&gt;stat_lock);</span><br><span class="line">    <span class="comment">/* 初始化used_blocks per-CPU计数器 */</span></span><br><span class="line">    <span class="keyword">if</span> (percpu_counter_init(&amp;sbinfo-&gt;used_blocks, <span class="number">0</span>, GFP_KERNEL))</span><br><span class="line">        <span class="comment">/* 初始化失败时跳转到失败处理 */</span></span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="comment">/* 初始化shrinklist_lock自旋锁 */</span></span><br><span class="line">    spin_lock_init(&amp;sbinfo-&gt;shrinklist_lock);</span><br><span class="line">    <span class="comment">/* 初始化shrinklist链表头 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;sbinfo-&gt;shrinklist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置文件系统的最大文件大小 */</span></span><br><span class="line">    sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span><br><span class="line">    <span class="comment">/* 设置文件系统的块大小 */</span></span><br><span class="line">    sb-&gt;s_blocksize = PAGE_SIZE;</span><br><span class="line">    <span class="comment">/* 设置文件系统的块大小位数 */</span></span><br><span class="line">    sb-&gt;s_blocksize_bits = PAGE_SHIFT;</span><br><span class="line">    <span class="comment">/* 设置文件系统的魔数 */</span></span><br><span class="line">    sb-&gt;s_magic = TMPFS_MAGIC;</span><br><span class="line">    <span class="comment">/* 设置文件系统的操作函数集 */</span></span><br><span class="line">    sb-&gt;s_op = &amp;shmem_ops;</span><br><span class="line">    <span class="comment">/* 设置文件系统的时间粒度 */</span></span><br><span class="line">    sb-&gt;s_time_gran = <span class="number">1</span>;gran = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_XATTR</span></span><br><span class="line">    sb-&gt;s_xattr = shmem_xattr_handlers; <span class="comment">// 设置super_block的扩展属性处理器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_POSIX_ACL</span></span><br><span class="line">    sb-&gt;s_flags |= SB_POSIXACL; <span class="comment">// 如果支持POSIX ACL，设置super_block的POSIX ACL标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    uuid_gen(&amp;sb-&gt;s_uuid); <span class="comment">// 生成一个新的UUID，并设置给super_block</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为根目录分配一个inode，并设置其属性</span></span><br><span class="line">    inode = shmem_get_inode(&amp;nop_mnt_idmap, sb, <span class="literal">NULL</span>, S_IFDIR | sbinfo-&gt;mode, <span class="number">0</span>,</span><br><span class="line">                VM_NORESERVE);</span><br><span class="line">    <span class="keyword">if</span> (!inode)</span><br><span class="line">        <span class="keyword">goto</span> failed; <span class="comment">// 如果inode分配失败，跳转到failed标签</span></span><br><span class="line">    inode-&gt;i_uid = sbinfo-&gt;uid; <span class="comment">// 设置inode的用户ID</span></span><br><span class="line">    inode-&gt;i_gid = sbinfo-&gt;gid; <span class="comment">// 设置inode的组ID</span></span><br><span class="line">    sb-&gt;s_root = d_make_root(inode); <span class="comment">// 为根目录分配一个目录项</span></span><br><span class="line">    <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">        <span class="keyword">goto</span> failed; <span class="comment">// 如果目录项分配失败，跳转到failed标签</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 初始化成功，返回0</span></span><br><span class="line"></span><br><span class="line">failed: <span class="comment">// 发生错误时，执行清理操作</span></span><br><span class="line">    shmem_put_super(sb); <span class="comment">// 调用shmem_put_super进行清理</span></span><br><span class="line">    <span class="keyword">return</span> -ENOMEM; <span class="comment">// 返回-ENOMEM错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shmem-get-inode函数"><a href="#shmem-get-inode函数" class="headerlink" title="shmem_get_inode函数"></a>shmem_get_inode函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_get_inode">shmem_get_inode identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">shmem_get_inode</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> inode *dir, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> dev,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_sb_info</span> *<span class="title">sbinfo</span> =</span> SHMEM_SB(sb);</span><br><span class="line">    <span class="type">ino_t</span> ino;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新的inode预留一个系统内部的编号</span></span><br><span class="line">    <span class="keyword">if</span> (shmem_reserve_inode(sb, &amp;ino))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新的inode分配内存</span></span><br><span class="line">    inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (inode) &#123;</span><br><span class="line">        <span class="comment">// 设置inode的编号</span></span><br><span class="line">        inode-&gt;i_ino = ino;</span><br><span class="line">        <span class="comment">// 初始化inode的所有者和权限模式</span></span><br><span class="line">        inode_init_owner(idmap, inode, dir, mode);</span><br><span class="line">        <span class="comment">// 设置inode的磁盘块数为0</span></span><br><span class="line">        inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置inode的访问、修改和创建时间</span></span><br><span class="line">        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">        <span class="comment">// 设置inode的生成编号（用于NFS）</span></span><br><span class="line">        inode-&gt;i_generation = get_random_u32();</span><br><span class="line">        <span class="comment">// 获得shmem_inode_info结构（tmpfs专用）</span></span><br><span class="line">        info = SHMEM_I(inode);</span><br><span class="line">        <span class="comment">// 初始化shmem_inode_info结构</span></span><br><span class="line">        <span class="built_in">memset</span>(info, <span class="number">0</span>, (<span class="type">char</span> *)inode - (<span class="type">char</span> *)info);</span><br><span class="line">        spin_lock_init(&amp;info-&gt;lock);</span><br><span class="line">        <span class="type">atomic_set</span>(&amp;info-&gt;stop_eviction, <span class="number">0</span>);</span><br><span class="line">        info-&gt;seals = F_SEAL_SEAL;</span><br><span class="line">        info-&gt;flags = flags &amp; VM_NORESERVE;</span><br><span class="line">        info-&gt;i_crtime = inode-&gt;i_mtime;</span><br><span class="line">        info-&gt;fsflags = (dir == <span class="literal">NULL</span>) ? <span class="number">0</span> :</span><br><span class="line">            SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED;</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;fsflags)</span><br><span class="line">            shmem_set_inode_flags(inode, info-&gt;fsflags);</span><br><span class="line">        INIT_LIST_HEAD(&amp;info-&gt;shrinklist);</span><br><span class="line">        INIT_LIST_HEAD(&amp;info-&gt;swaplist);</span><br><span class="line">        simple_xattrs_init(&amp;info-&gt;xattrs);</span><br><span class="line">        cache_no_acl(inode);</span><br><span class="line">        mapping_set_large_folios(inode-&gt;i_mapping);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据不同的文件类型，设置相应的操作函数</span></span><br><span class="line">        <span class="keyword">switch</span> (mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            inode-&gt;i_op = &amp;shmem_special_inode_operations;</span><br><span class="line">            init_special_inode(inode, mode, dev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops;</span><br><span class="line">            inode-&gt;i_op = &amp;shmem_inode_operations;</span><br><span class="line">            inode-&gt;i_fop = &amp;shmem_file_operations;</span><br><span class="line">            mpol_shared_policy_init(&amp;info-&gt;policy,</span><br><span class="line">                         shmem_get_sbmpol(sbinfo));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            inc_nlink(inode);</span><br><span class="line">            inode-&gt;i_size = <span class="number">2</span> * BOGO_DIRENT_SIZE;</span><br><span class="line">            inode-&gt;i_op = &amp;shmem_dir_inode_operations;</span><br><span class="line">            inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            mpol_shared_policy_init(&amp;info-&gt;policy, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为锁依赖分析系统设置inode互斥锁的标记</span></span><br><span class="line">        lockdep_annotate_inode_mutex_key(inode);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果inode分配失败，则释放预留的编号</span></span><br><span class="line">        shmem_free_inode(sb);</span><br><span class="line">    <span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="do-new-mount-fc函数"><a href="#do-new-mount-fc函数" class="headerlink" title="do_new_mount_fc函数"></a>do_new_mount_fc函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/source/fs/namespace.c#L3001">namespace.c - fs&#x2F;namespace.c - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用超级块配置创建一个新的挂载，并请求将其添加到命名空间树。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_new_mount_fc</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> path *mountpoint,</span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> fc-&gt;root-&gt;d_sb;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对超级块进行安全检查</span></span><br><span class="line">    error = security_sb_kern_mount(sb);</span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; mount_too_revealing(sb, &amp;mnt_flags))</span><br><span class="line">        error = -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果出现错误，释放fs_context并返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">        fc_drop_locked(fc);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放超级块的umount锁</span></span><br><span class="line">    up_write(&amp;sb-&gt;s_umount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据fs_context创建一个新的struct mount结构，每个挂载的文件系统都对应这样的一个结构</span></span><br><span class="line">    mnt = vfs_create_mount(fc);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对挂载的时间戳过期发出警告</span></span><br><span class="line">    mnt_warn_timestamp_expiry(mountpoint, mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定挂载点</span></span><br><span class="line">    mp = lock_mount(mountpoint);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mp)) &#123;</span><br><span class="line">        mntput(mnt);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新挂载添加到挂载点并应用挂载标志，do_add_mount完成挂载操作</span></span><br><span class="line">    error = do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags);</span><br><span class="line">    unlock_mount(mp);</span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        mntput(mnt);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-add-mount函数"><a href="#do-add-mount函数" class="headerlink" title="do_add_mount函数"></a>do_add_mount函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/do_add_mount">do_add_mount identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将挂载添加到命名空间的挂载树中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_add_mount</span><span class="params">(<span class="keyword">struct</span> mount *newmnt, <span class="keyword">struct</span> mountpoint *mp,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取待挂载路径的父挂载实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">parent</span> =</span> real_mount(path-&gt;mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除内部挂载标志</span></span><br><span class="line">    mnt_flags &amp;= ~MNT_INTERNAL_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查父挂载实例是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!check_mnt(parent))) &#123;</span><br><span class="line">        <span class="comment">// 这只对在私有命名空间中进行的自动挂载是可接受的</span></span><br><span class="line">        <span class="keyword">if</span> (!(mnt_flags &amp; MNT_SHRINKABLE))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="comment">// 对于这些情况，我们最好确保挂载点仍然有效</span></span><br><span class="line">        <span class="keyword">if</span> (!parent-&gt;mnt_ns)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拒绝在相同挂载点上使用相同的文件系统</span></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp;</span><br><span class="line">        path-&gt;mnt-&gt;mnt_root == path-&gt;dentry)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新挂载的根目录是符号链接，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_symlink(newmnt-&gt;mnt.mnt_root))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新挂载的挂载标志</span></span><br><span class="line">    newmnt-&gt;mnt.mnt_flags = mnt_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新挂载添加到父挂载和挂载点</span></span><br><span class="line">    <span class="keyword">return</span> graft_tree(newmnt, parent, mp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h3><h4 id="struct-fs-context"><a href="#struct-fs-context" class="headerlink" title="struct fs_context"></a>struct fs_context</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.6/A/ident/fs_context">fs_context identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_context_operations</span> *<span class="title">ops</span>;</span> <span class="comment">// 文件系统操作指针，用于设置特定文件系统的操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">uapi_mutex</span>;</span>                <span class="comment">// 用户空间访问互斥锁，用于保护文件系统上下文的并发访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">fs_type</span>;</span>       <span class="comment">// 文件系统类型，指向一个描述文件系统特性的结构体</span></span><br><span class="line">    <span class="type">void</span> *fs_private;                       <span class="comment">// 文件系统私有上下文，用于存储特定文件系统实现的私有数据</span></span><br><span class="line">    <span class="type">void</span> *sget_key;                         <span class="comment">// 用于唯一标识文件系统实例的键，用于共享超级块的查找过程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root</span>;</span>                    <span class="comment">// 文件系统的根目录入口，指向一个dentry结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span>         <span class="comment">// 与此挂载关联的用户命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net_ns</span>;</span>                     <span class="comment">// 与此挂载关联的网络命名空间</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">cred</span>;</span>                <span class="comment">// 挂载者的凭据，包含用户/组ID等权限信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">p_log</span> <span class="title">log</span>;</span>                       <span class="comment">// 日志缓冲区，用于记录文件系统上下文的日志信息</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *source;                     <span class="comment">// 源名称（例如设备路径），用于标识挂载来源</span></span><br><span class="line">    <span class="type">void</span> *security;                         <span class="comment">// 用于存储Linux安全模块（LSM）的选项</span></span><br><span class="line">    <span class="type">void</span> *s_fs_info;                        <span class="comment">// 指向建议的s_fs_info数据，之后会存储在超级块的s_fs_info字段中</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sb_flags;                  <span class="comment">// 建议的超级块标志（SB_*），用于挂载选项控制</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sb_flags_mask;             <span class="comment">// 改变的超级块标志的掩码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> s_iflags;                  <span class="comment">// 与超级块s_iflags字段进行按位或的标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lsm_flags;                 <span class="comment">// 从文件系统到LSM的信息标志</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">fs_context_purpose</span> <span class="title">purpose</span>:</span><span class="number">8</span>;      <span class="comment">// 文件系统上下文的目的（例如挂载、重新挂载、移动挂载点等）</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">fs_context_phase</span> <span class="title">phase</span>:</span><span class="number">8</span>;          <span class="comment">// 文件系统上下文所处的阶段</span></span><br><span class="line">    <span class="type">bool</span> need_free:<span class="number">1</span>;                       <span class="comment">// 标记是否需要调用ops-&gt;free()释放文件系统上下文</span></span><br><span class="line">    <span class="type">bool</span> global:<span class="number">1</span>;                          <span class="comment">// 全局标志，表示是否进入&amp;init_user_ns的全局命名空间</span></span><br><span class="line">    <span class="type">bool</span> oldapi:<span class="number">1</span>;                          <span class="comment">// 标记是否来自旧API（即mount(2)系统调用）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体用于保存超级块的信息的<code>root</code>，而超级块本身包含了该实际文件系统的信息，因此通过该结构体，我们可以使该文件系统和<code>mount</code>结构体建立联系。在旧版的Linux源码中，我们需要使用<code>mount_fs()</code>函数去获取对应的<code>root</code>，而新版则可以通过<code>fs_context</code>直接获取。</p>
<h4 id="struct-vfsmount"><a href="#struct-vfsmount" class="headerlink" title="struct vfsmount"></a>struct vfsmount</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.6/A/ident/vfsmount">vfsmount identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span>       <span class="comment">// 指向已挂载文件系统树的根目录入口（dentry结构体）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span>    <span class="comment">// 指向与已挂载文件系统关联的超级块（super_block结构体）</span></span><br><span class="line">    <span class="type">int</span> mnt_flags;                 <span class="comment">// 挂载标志，表示挂载时的选项，如只读、异步等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">mnt_idmap</span>;</span>   <span class="comment">// 指向一个mnt_idmap结构体，用于存储用户和组ID的映射关系（仅在某些文件系统中使用，如NFS）</span></span><br><span class="line">&#125; __randomize_layout;             <span class="comment">// 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性</span></span><br></pre></td></tr></table></figure>

<p><code>vfsmount</code>结构体中<code>mnt_root</code> 是当前文件系统根目录的 <code>dentry</code>，<code>mnt_sb</code> 是指向超级块的指针。这里之所以会有<code>mnt_mountpoint</code>和<code>mnt_root</code>，是因为在挂载时该文件系统的根目录同时成为了其父文件系统的一个子目录（挂载点）。</p>
<h4 id="struct-mount"><a href="#struct-mount" class="headerlink" title="struct mount"></a>struct mount</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.6/A/ident/mount">mount identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_hash</span>;</span>                   <span class="comment">// 用于挂载点哈希表的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_parent</span>;</span>                     <span class="comment">// 指向父挂载点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span>                <span class="comment">// 指向挂载点位置的目录入口（dentry）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> <span class="title">mnt</span>;</span>                          <span class="comment">// 包含挂载文件系统相关信息的vfsmount结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">mnt_rcu</span>;</span>                  <span class="comment">// 用于RCU（Read-Copy-Update）同步的链表头</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">mnt_llist</span>;</span>              <span class="comment">// 用于延迟列表（llist）的链表节点</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_pcp</span> __<span class="title">percpu</span> *<span class="title">mnt_pcp</span>;</span>             <span class="comment">// 指向每个CPU的mnt_pcp结构体的指针（仅在多处理器系统中使用）</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> mnt_count;                                <span class="comment">// 挂载点的引用计数</span></span><br><span class="line">    <span class="type">int</span> mnt_writers;                              <span class="comment">// 写入操作的计数器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span>                    <span class="comment">// 子挂载点列表的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span>                    <span class="comment">// 与mnt_mounts链表相连的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_instance</span>;</span>                <span class="comment">// 超级块的s_mounts链表上的挂载实例列表节点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mnt_devname;                        <span class="comment">// 设备名称，如 /dev/dsk/hda1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span>                    <span class="comment">// 全局挂载点列表的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_expire</span>;</span>                    <span class="comment">// 特定文件系统的过期列表的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_share</span>;</span>                   <span class="comment">// 共享挂载点的循环列表链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave_list</span>;</span>              <span class="comment">// 从属挂载点的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave</span>;</span>                   <span class="comment">// 与mnt_slave_list链表相连的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_master</span>;</span>                     <span class="comment">// 指向主挂载点的指针，从属挂载点位于master-&gt;mnt_slave_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span>                 <span class="comment">// 包含此挂载点的命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mnt_mp</span>;</span>                    <span class="comment">// 指向挂载点位置的mountpoint结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_mp_list</span>;</span>            <span class="comment">// 具有相同挂载点的挂载列表链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_umount</span>;</span>             <span class="comment">// 用于卸载操作的链表节点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_umounting</span>;</span>               <span class="comment">// 用于卸载传播的链表节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span> *<span class="title">mnt_fsnotify_marks</span>;</span> <span class="comment">// 指向文件系统通知标记的指针</span></span><br><span class="line">    __u32 mnt_fsnotify_mask;                      <span class="comment">// 文件系统通知的掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> mnt_id;                                    <span class="comment">// 挂载点的唯一标识符</span></span><br><span class="line">    <span class="type">int</span> mnt_group_id;                            <span class="comment">// 同级挂载组的唯一标识符</span></span><br><span class="line">    <span class="type">int</span> mnt_expiry_mark;                            <span class="comment">// 如果已标记为过期，则为true</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_pins</span>;</span>                  <span class="comment">// 用于记录挂载点引脚的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_stuck_children</span>;</span>        <span class="comment">// 被卡住的子挂载点列表的链表头</span></span><br><span class="line">&#125; __randomize_layout;                           <span class="comment">// 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性</span></span><br></pre></td></tr></table></figure>

<h4 id="struct-dentry"><a href="#struct-dentry" class="headerlink" title="struct dentry"></a>struct dentry</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/dentry">dentry identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d_flags;        <span class="comment">/* 目录项的标志位，受 d_lock 保护 */</span></span><br><span class="line">    <span class="type">seqcount_spinlock_t</span> d_seq;    <span class="comment">/* 每个目录项的序列锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span>    <span class="comment">/* 用于查找的哈希列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>    <span class="comment">/* 父目录 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>             <span class="comment">/* 目录项的名称 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>        <span class="comment">/* 与目录名关联的 inode 结构指针，NULL 表示负目录项 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN];    <span class="comment">/* 短名称 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span>    <span class="comment">/* 每个目录项的锁和引用计数 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 目录项操作函数集 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>    <span class="comment">/* 目录项树的根节点 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> d_time;        <span class="comment">/* 用于 d_revalidate 的时间戳 */</span></span><br><span class="line">    <span class="type">void</span> *d_fsdata;            <span class="comment">/* 特定文件系统的数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>        <span class="comment">/* LRU（最近最少使用）列表 */</span></span><br><span class="line">        <span class="type">wait_queue_head_t</span> *d_wait;    <span class="comment">/* 仅用于查找中的目录项 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>    <span class="comment">/* 父目录项的子项列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>    <span class="comment">/* 子目录项列表 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span>    <span class="comment">/* inode 别名列表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_in_lookup_hash</span>;</span>    <span class="comment">/* 仅用于查找中的目录项 */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h4 id="struct-inode"><a href="#struct-inode" class="headerlink" title="struct inode"></a>struct inode</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/A/ident/inode">inode identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>            i_mode;          <span class="comment">/* 文件类型和访问权限 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>        i_opflags;       <span class="comment">/* inode 操作标志 */</span></span><br><span class="line">    <span class="type">kuid_t</span>            i_uid;           <span class="comment">/* 文件拥有者的用户 ID */</span></span><br><span class="line">    <span class="type">kgid_t</span>            i_gid;           <span class="comment">/* 文件拥有者的组 ID */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;         <span class="comment">/* 文件或目录的标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_acl</span>;</span>          <span class="comment">/* 访问控制列表 (ACL) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_default_acl</span>;</span>  <span class="comment">/* 默认访问控制列表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>    *<span class="title">i_op</span>;</span>  <span class="comment">/* inode 操作函数集 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>    *<span class="title">i_sb</span>;</span>           <span class="comment">/* 与 inode 关联的超级块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span>      <span class="comment">/* 文件内容的内存映射 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *i_security;     <span class="comment">/* 安全模块使用的 inode 信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        i_ino;           <span class="comment">/* inode 编号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;        <span class="comment">/* 硬链接计数 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">dev_t</span>            i_rdev;          <span class="comment">/* 特殊设备的设备号 */</span></span><br><span class="line">    <span class="type">loff_t</span>            i_size;          <span class="comment">/* 文件大小（字节） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_atime</span>;</span>         <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_mtime</span>;</span>         <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_ctime</span>;</span>         <span class="comment">/* 最后元数据更改时间 */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        i_lock;          <span class="comment">/* 保护 i_blocks, i_bytes 和可能的 i_size 的锁 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;        <span class="comment">/* 文件末尾未使用的字节数 */</span></span><br><span class="line">    u8            i_blkbits;       <span class="comment">/* 文件系统块大小的以 2 为底的对数 */</span></span><br><span class="line">    u8            i_write_hint;    <span class="comment">/* 写操作的优化提示 */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks;        <span class="comment">/* 文件占用的磁盘块数量 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="type">seqcount_t</span>        i_size_seqcount; <span class="comment">/* 有序 i_size 的序列计数器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        i_state;         <span class="comment">/* inode 状态标志 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>    <span class="title">i_rwsem</span>;</span>         <span class="comment">/* 读写信号量，用于保护 inode 结构 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        dirtied_when;    <span class="comment">/* 第一次被脏的时间，以 jiffies 计 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        dirtied_time_when; <span class="comment">/* 上次被脏的时间，以 jiffies 计 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">i_hash</span>;</span>          <span class="comment">/* 散列链表上的节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_io_list</span>;</span>       <span class="comment">/* 后备设备的 I/O 列表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>    *<span class="title">i_wb</span>;</span>           <span class="comment">/* 关联的 cgroup 写回控制器 */</span></span><br><span class="line">    <span class="type">int</span>            i_wb_frn_winner; <span class="comment">/* 外部 inode 检测的赢家 */</span></span><br><span class="line">    u16            i_wb_frn_avg_time; <span class="comment">/* 外部 inode 的平均时间 */</span></span><br><span class="line">    u16            i_wb_frn_history; <span class="comment">/* 外部 inode 的历史记录 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>           <span class="comment">/* inode LRU 列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span>       <span class="comment">/* 超级块列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>       <span class="comment">/* 后备设备写回列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">i_dentry</span>;</span>      <span class="comment">/* 目录项列表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>        <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">atomic64_t</span>        i_version;       <span class="comment">/* inode 版本 */</span></span><br><span class="line">    <span class="type">atomic64_t</span>        i_sequence;      <span class="comment">/* 用于 futex 的序列值 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_count;         <span class="comment">/* inode 引用计数 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_dio_count;     <span class="comment">/* 直接 I/O 计数 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_writecount;    <span class="comment">/* 写计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_readcount;     <span class="comment">/* 只读打开的文件计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span>  <span class="comment">/* 以前的 -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">        <span class="type">void</span> (*free_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>    *<span class="title">i_flctx</span>;</span>         <span class="comment">/* 文件锁上下文 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span>          <span class="comment">/* inode 的数据缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span>       <span class="comment">/* 设备列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>    *<span class="title">i_pipe</span>;</span>   <span class="comment">/* 管道 inode 信息 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>        *<span class="title">i_cdev</span>;</span>    <span class="comment">/* 字符设备 */</span></span><br><span class="line">        <span class="type">char</span>            *i_link;    <span class="comment">/* 符号链接的目标路径 */</span></span><br><span class="line">        <span class="type">unsigned</span>        i_dir_seq;  <span class="comment">/* 目录序列计数器 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32            i_generation;    <span class="comment">/* inode 生成计数器 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    __u32            i_fsnotify_mask; <span class="comment">/* inode 关心的所有事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>    *<span class="title">i_fsnotify_marks</span>;</span> <span class="comment">/* 文件系统通知标记连接器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span>    *<span class="title">i_crypt_info</span>;</span>   <span class="comment">/* 文件系统加密信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsverity_info</span>    *<span class="title">i_verity_info</span>;</span>  <span class="comment">/* 文件系统完整性信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            *i_private;       <span class="comment">/* 文件系统或设备的私有指针 */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h2 id="打开或者创建新文件"><a href="#打开或者创建新文件" class="headerlink" title="打开或者创建新文件"></a>打开或者创建新文件</h2><h3 id="open系统调用"><a href="#open系统调用" class="headerlink" title="open系统调用"></a>open系统调用</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/A/ident/sys_openat">sys_openat identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 open 的系统调用，该调用接受三个参数：filename（文件名），flags（标志）和 mode（模式）</span></span><br><span class="line">SYSCALL_DEFINE3(open, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">int</span>, flags, <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果需要处理大文件，将 O_LARGEFILE 标志添加到 flags 中</span></span><br><span class="line">    <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">        flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 do_sys_open 函数，传入当前工作目录的文件描述符 AT_FDCWD、filename、flags 和 mode 参数</span></span><br><span class="line">    <span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个名为 openat 的系统调用，该调用接受四个参数：dfd（目录文件描述符），filename（文件名），flags（标志）和 mode（模式）</span></span><br><span class="line">SYSCALL_DEFINE4(openat, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">int</span>, flags,</span><br><span class="line">        <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果需要处理大文件，将 O_LARGEFILE 标志添加到 flags 中</span></span><br><span class="line">    <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">        flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 do_sys_open 函数，传入 dfd（目录文件描述符）、filename、flags 和 mode 参数</span></span><br><span class="line">    <span class="keyword">return</span> do_sys_open(dfd, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>open - 这是一个较早版本的系统调用，它接受三个参数：filename，flags 和 mode。filename 参数是要打开或创建的文件名；flags 参数用于指定文件的打开方式，例如只读、只写或读写，以及其他一些选项，如创建新文件或截断文件；mode 参数用于指定新创建文件的权限。在处理大文件时，如果设置了 O_LARGEFILE 标志，open 会自动处理大文件。</p>
</li>
<li><p>openat - 与 open 类似，但多了一个参数 dfd（目录文件描述符）。这个系统调用支持从一个特定的目录开始解析相对路径。如果 dfd 是一个有效的目录文件描述符，那么 filename 参数将被解析为该目录下的相对路径。如果 dfd 是 AT_FDCWD，则 filename 会被视为当前工作目录下的相对路径。这个系统调用在处理多线程程序和文件系统命名空间时非常有用。</p>
</li>
</ul>
<h3 id="do-sys-open函数"><a href="#do-sys-open函数" class="headerlink" title="do_sys_open函数"></a>do_sys_open函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/do_sys_open">do_sys_open identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 do_sys_open 的函数，该函数接受四个参数：dfd（目录文件描述符），filename（文件名），flags（标志）和 mode（模式）</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">do_sys_open</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 build_open_how 函数根据 flags 和 mode 参数构造一个 open_how 结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">open_how</span> <span class="title">how</span> =</span> build_open_how(flags, mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 do_sys_openat2 函数，传入 dfd（目录文件描述符）、filename 和 how 结构体的指针</span></span><br><span class="line">    <span class="keyword">return</span> do_sys_openat2(dfd, filename, &amp;how);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-sys-openat2函数"><a href="#do-sys-openat2函数" class="headerlink" title="do_sys_openat2函数"></a>do_sys_openat2函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/do_sys_openat2">do_sys_openat2 identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 do_sys_openat2 的静态函数，该函数接受三个参数：dfd（目录文件描述符），filename（文件名）和 how（打开方式结构体指针）</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_sys_openat2</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> open_how *how)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">open_flags</span> <span class="title">op</span>;</span></span><br><span class="line">    <span class="comment">// 使用 build_open_flags 函数根据 how 结构体构造一个 open_flags 结构体，将结果存储在 op 变量中</span></span><br><span class="line">    <span class="type">int</span> fd = build_open_flags(how, &amp;op);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 fd 不为 0（表示出错），则返回 fd</span></span><br><span class="line">    <span class="keyword">if</span> (fd)</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 getname 函数获取 filename 参数的内核空间副本，并将其存储在 tmp 变量中</span></span><br><span class="line">    tmp = getname(filename);</span><br><span class="line">    <span class="comment">// 如果获取文件名出错，返回错误码</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(tmp))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 how-&gt;flags 获取未使用的文件描述符（fd），并将其存储在 fd 变量中</span></span><br><span class="line">    fd = get_unused_fd_flags(how-&gt;flags);</span><br><span class="line">    <span class="comment">// 如果 fd 大于等于 0（表示未使用的文件描述符可用）</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 do_filp_open 函数打开文件，传入 dfd（目录文件描述符）、tmp（文件名）和 op（打开方式）参数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> do_filp_open(dfd, tmp, &amp;op);</span><br><span class="line">        <span class="comment">// 如果打开文件出错，释放未使用的文件描述符并返回错误码</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">            put_unused_fd(fd);</span><br><span class="line">            fd = PTR_ERR(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果打开文件成功，调用 fsnotify_open 函数通知相关子系统</span></span><br><span class="line">            fsnotify_open(f);</span><br><span class="line">            <span class="comment">// 调用 fd_install 函数将文件描述符 fd 与打开的文件结构体 f 关联起来</span></span><br><span class="line">            fd_install(fd, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放 tmp 变量（即 filename 的内核空间副本）</span></span><br><span class="line">    putname(tmp);</span><br><span class="line">    <span class="comment">// 返回文件描述符 fd</span></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-filp-open函数"><a href="#do-filp-open函数" class="headerlink" title="do_filp_open函数"></a>do_filp_open函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/do_filp_open">do_filp_open identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 do_filp_open 的函数，该函数接受三个参数：dfd（目录文件描述符），pathname（文件名结构体指针）和 op（打开方式结构体指针）</span></span><br><span class="line"><span class="keyword">struct</span> file *<span class="title function_">do_filp_open</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *pathname,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">    <span class="comment">// 从 op 结构体中获取查找标志</span></span><br><span class="line">    <span class="type">int</span> flags = op-&gt;lookup_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 set_nameidata 函数初始化 nd 结构体，传入 dfd（目录文件描述符）、pathname（文件名结构体指针）和 NULL（用于初始化 nd-&gt;intent）</span></span><br><span class="line">    set_nameidata(&amp;nd, dfd, pathname, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 使用 path_openat 函数尝试打开文件，传入 nd（名字数据结构体）、op（打开方式结构体）和 flags（查找标志）；使用 LOOKUP_RCU 标志进行 RCU 优化</span></span><br><span class="line">    filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);</span><br><span class="line">    <span class="comment">// 如果文件打开失败并返回 -ECHILD 错误码，表明 RCU 优化失败，尝试使用非 RCU 优化方式打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(filp == ERR_PTR(-ECHILD)))</span><br><span class="line">        filp = path_openat(&amp;nd, op, flags);</span><br><span class="line">    <span class="comment">// 如果文件打开失败并返回 -ESTALE 错误码，表明文件系统状态陈旧，尝试使用 LOOKUP_REVAL 标志重新评估文件系统状态并打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(filp == ERR_PTR(-ESTALE)))</span><br><span class="line">        filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL);</span><br><span class="line">    <span class="comment">// 通过调用 restore_nameidata 函数恢复名字数据结构体（nd）的状态</span></span><br><span class="line">    restore_nameidata();</span><br><span class="line">    <span class="comment">// 返回文件结构体指针 filp</span></span><br><span class="line">    <span class="keyword">return</span> filp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_nameidata</span><span class="params">(<span class="keyword">struct</span> nameidata *p, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> path *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    __set_nameidata(p, dfd, name);</span><br><span class="line">    p-&gt;state = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(root)) &#123;</span><br><span class="line">        p-&gt;state = ND_ROOT_PRESET;</span><br><span class="line">        p-&gt;root = *root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __set_nameidata(<span class="keyword">struct</span> nameidata *p, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">old</span> =</span> current-&gt;nameidata;</span><br><span class="line">    p-&gt;<span class="built_in">stack</span> = p-&gt;internal;</span><br><span class="line">    p-&gt;depth = <span class="number">0</span>;</span><br><span class="line">    p-&gt;dfd = dfd;</span><br><span class="line">    p-&gt;name = name;</span><br><span class="line">    p-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;total_link_count = old ? old-&gt;total_link_count : <span class="number">0</span>;</span><br><span class="line">    p-&gt;saved = old;</span><br><span class="line">    current-&gt;nameidata = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="path-openat函数"><a href="#path-openat函数" class="headerlink" title="path_openat函数"></a>path_openat函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/path_openat">path_openat identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 path_openat 的静态函数，该函数接受三个参数：nd（名字数据结构体指针）、op（打开方式结构体指针）和 flags（打开标志）</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file *<span class="title function_">path_openat</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> open_flags *op, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 alloc_empty_file 函数分配一个空的文件结构体，传入打开标志和当前进程的认证信息</span></span><br><span class="line">    file = alloc_empty_file(op-&gt;open_flag, current_cred());</span><br><span class="line">    <span class="comment">// 如果分配文件结构体失败，返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件打开标志包含 __O_TMPFILE，调用 do_tmpfile 函数处理临时文件的打开操作</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123;</span><br><span class="line">        error = do_tmpfile(nd, flags, op, file);</span><br><span class="line">    <span class="comment">// 如果文件打开标志包含 O_PATH，调用 do_o_path 函数处理 O_PATH 标志的打开操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123;</span><br><span class="line">        error = do_o_path(nd, flags, file);</span><br><span class="line">    <span class="comment">// 否则，正常处理文件打开操作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 path_init 函数初始化 nd 结构体，并返回路径名字符串 s</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s = path_init(nd, flags);</span><br><span class="line">        <span class="comment">// 循环调用 link_path_walk 和 open_last_lookups 函数，直到路径名解析完成</span></span><br><span class="line">        <span class="keyword">while</span> (!(error = link_path_walk(s, nd)) &amp;&amp;</span><br><span class="line">               (s = open_last_lookups(nd, file, op)) != <span class="literal">NULL</span>)</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">// 路径名解析完成后，调用 do_open 函数处理文件打开操作</span></span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            error = do_open(nd, file, op);</span><br><span class="line">        <span class="comment">// 调用 terminate_walk 函数终止路径名解析操作</span></span><br><span class="line">        terminate_walk(nd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有错误发生，返回文件结构体指针</span></span><br><span class="line">    <span class="keyword">if</span> (likely(!error)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (likely(file-&gt;f_mode &amp; FMODE_OPENED))</span><br><span class="line">            <span class="keyword">return</span> file;</span><br><span class="line">        WARN_ON(<span class="number">1</span>);</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有错误发生，释放文件结构体并返回错误指针</span></span><br><span class="line">    fput(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果错误码为 -EOPENSTALE，根据 flags 参数设置错误码为 -ECHILD 或 -ESTALE</span></span><br><span class="line">    <span class="keyword">if</span> (error == -EOPENSTALE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU)</span><br><span class="line">            error = -ECHILD;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = -ESTALE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 必须和 terminate_walk() 配对使用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">path_init</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = nd-&gt;name-&gt;name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LOOKUP_CACHED 需要 RCU，要求调用者重试 */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*s)</span><br><span class="line">        flags &amp;= ~LOOKUP_RCU;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; LOOKUP_RCU)</span><br><span class="line">        rcu_read_lock(); <span class="comment">// 如果使用 RCU，则加锁</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nd-&gt;seq = nd-&gt;next_seq = <span class="number">0</span>; <span class="comment">// 否则，将序列号设置为 0</span></span><br><span class="line"></span><br><span class="line">    nd-&gt;flags = flags; <span class="comment">// 设置 nameidata 结构体的 flags</span></span><br><span class="line">    nd-&gt;state |= ND_JUMPED; <span class="comment">// 设置 nameidata 结构体的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 mount_lock 和 rename_lock 的序列号</span></span><br><span class="line">    nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount);</span><br><span class="line">    nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount);</span><br><span class="line">    smp_rmb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否预先设置了根路径</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;state &amp; ND_ROOT_PRESET) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root</span> =</span> nd-&gt;root.dentry;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> root-&gt;d_inode;</span><br><span class="line">        <span class="keyword">if</span> (*s &amp;&amp; unlikely(!d_can_lookup(root)))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOTDIR);</span><br><span class="line">        nd-&gt;path = nd-&gt;root; <span class="comment">// 将预设的根路径设置为当前路径</span></span><br><span class="line">        nd-&gt;inode = inode; <span class="comment">// 设置路径的 inode</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">            nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);</span><br><span class="line">            nd-&gt;root_seq = nd-&gt;seq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path_get(&amp;nd-&gt;path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nd-&gt;root.mnt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绝对路径 - 获取根路径（LOOKUP_IN_ROOT 使用 nd-&gt;dfd）</span></span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="string">&#x27;/&#x27;</span> &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123;</span><br><span class="line">        error = nd_jump_root(nd); <span class="comment">// 从根路径开始查找</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径 - 获取相对路径的起始点</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;dfd == AT_FDCWD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span> =</span> current-&gt;fs;</span><br><span class="line">            <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 fs_struct 获取 pwd（当前工作目录）</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                seq = read_seqcount_begin(&amp;fs-&gt;seq);</span><br><span class="line">                nd-&gt;path = fs-&gt;pwd;</span><br><span class="line">                nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">                nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);</span><br><span class="line">            &#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;fs-&gt;seq, seq));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); <span class="comment">// 获取当前进程的工作目录</span></span><br><span class="line">            nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用者必须检查起始路径组件的执行权限</span></span><br><span class="line">        <span class="keyword">struct</span> fd f = fdget_raw(nd-&gt;dfd); <span class="comment">// 根据文件描述符获取 fd 结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!f.file)</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-EBADF);</span><br><span class="line"></span><br><span class="line">        dentry = f.file-&gt;f_path.dentry;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123;</span><br><span class="line">            fdput(f);</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOTDIR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nd-&gt;path = f.file-&gt;f_path; <span class="comment">// 设置当前路径</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">            nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">            nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path_get(&amp;nd-&gt;path);</span><br><span class="line">            nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">        &#125;</span><br><span class="line">        fdput(f); <span class="comment">// 释放文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于受限制的查找，我们需要将 dirfd 也设置为根路径</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; LOOKUP_IS_SCOPED) &#123;</span><br><span class="line">        nd-&gt;root = nd-&gt;path;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">            nd-&gt;root_seq = nd-&gt;seq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path_get(&amp;nd-&gt;root);</span><br><span class="line">            nd-&gt;state |= ND_ROOT_GRABBED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="link-path-walk函数"><a href="#link-path-walk函数" class="headerlink" title="link_path_walk函数"></a>link_path_walk函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/link_path_walk">link_path_walk identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">link_path_walk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 初始化深度为 0，用于记录符号链接的嵌套层数</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 nd-&gt;last_type 和 nd-&gt;flags</span></span><br><span class="line">    nd-&gt;last_type = LAST_ROOT; <span class="comment">// 设置 nd-&gt;last_type 为 LAST_ROOT</span></span><br><span class="line">    nd-&gt;flags |= LOOKUP_PARENT; <span class="comment">// 更新 nd-&gt;flags，添加 LOOKUP_PARENT 标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径名是错误的，返回错误值</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(name)) <span class="comment">// 检查路径名是否有效（不是错误指针）</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(name); <span class="comment">// 如果无效，返回错误值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过路径名开头的 &#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (*name == <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 当路径名以 &#x27;/&#x27; 开头时，进入循环</span></span><br><span class="line">        name++; <span class="comment">// 将 name 指针向后移动一位，跳过 &#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径名为空，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (!*name) &#123; <span class="comment">// 检查路径名是否为空（在跳过开头的 &#x27;/&#x27; 之后）</span></span><br><span class="line">        nd-&gt;dir_mode = <span class="number">0</span>; <span class="comment">// 将 nd-&gt;dir_mode 设置为 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0，表示路径查找结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始循环处理路径名的每个组件</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，直到路径名的所有组件都被处理</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *link;</span><br><span class="line">        u64 hash_len;</span><br><span class="line">        <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件系统 ID 映射,文件系统 ID 映射用于将 VFS 中的用户和组 ID 转换为底层文件系统中的用户和组 ID。</span></span><br><span class="line">        idmap = mnt_idmap(nd-&gt;path.mnt); <span class="comment">// 获取 nd-&gt;path.mnt 对应的文件系统 ID 映射</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有权限执行查找操作</span></span><br><span class="line">        err = may_lookup(idmap, nd); <span class="comment">// 检查当前用户是否有权限查找</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="comment">// 如果没有权限</span></span><br><span class="line">            <span class="keyword">return</span> err; <span class="comment">// 返回错误值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前路径组件的哈希值和长度,这些值将用于在散列查找中快速比较路径名组件。</span></span><br><span class="line">        hash_len = hash_name(nd-&gt;path.dentry, name); <span class="comment">// 计算哈希值和长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前路径组件的类型（&#x27;.&#x27;、&#x27;..&#x27; 或普通组件）</span></span><br><span class="line">        type = LAST_NORM; <span class="comment">// 默认为普通组件</span></span><br><span class="line">        <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">switch</span> (hashlen_len(hash_len)) &#123; <span class="comment">// 如果组件以 &#x27;.&#x27; 开头，检查长度</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (name[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 如果组件为 &quot;..&quot;</span></span><br><span class="line">                    type = LAST_DOTDOT; <span class="comment">// 设置类型为 LAST_DOTDOT</span></span><br><span class="line">                    nd-&gt;state |= ND_JUMPED; <span class="comment">// 更新 nd-&gt;state，添。这个标志表示我们正跳转到父目录。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                type = LAST_DOT; <span class="comment">// 如果组件为 &quot;.&quot;，设置类型为 LAST_DOT</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (likely(type == LAST_NORM)) &#123; <span class="comment">// 如果组件类型为普通组件</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> nd-&gt;path.dentry; <span class="comment">// 获取当前组件的父目录</span></span><br><span class="line">            nd-&gt;state &amp;= ~ND_JUMPED; <span class="comment">// 清除 nd-&gt;state 的 ND_JUMPED 标志</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果需要，执行自定义哈希操作。某些文件系统可能需要自定义哈希操作以适应其特定的查找机制。</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; <span class="comment">// 检查父目录是否需要自定义哈希操作</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span> =</span> &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; <span class="comment">// 初始化 qstr 结构体</span></span><br><span class="line">                err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); <span class="comment">// 执行自定义哈希操作</span></span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="comment">// 如果操作失败</span></span><br><span class="line">                    <span class="keyword">return</span> err; <span class="comment">// 返回错误值</span></span><br><span class="line">                hash_len = this.hash_len; <span class="comment">// 更新哈希值和长度</span></span><br><span class="line">                name = this.name; <span class="comment">// 更新 name 指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// 更新 nd 的 last 和 last_type 成员</span></span><br><span class="line">        nd-&gt;last.hash_len = hash_len; <span class="comment">// 设置 nd-&gt;last 的哈希值和长度</span></span><br><span class="line">        nd-&gt;last.name = name; <span class="comment">// 设置 nd-&gt;last 的名称</span></span><br><span class="line">        nd-&gt;last_type = type; <span class="comment">// 设置 nd-&gt;last_type 为当前组件的类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 name 指针向后移动到下一个路径组件</span></span><br><span class="line">               name += hashlen_len(hash_len); <span class="comment">// 将 name 指针向后移动到下一个路径组件的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到达路径名的结尾，处理结束</span></span><br><span class="line">        <span class="keyword">if</span> (!*name) <span class="comment">// 检查是否到达路径名的结尾</span></span><br><span class="line">            <span class="keyword">goto</span> OK; <span class="comment">// 跳转到 OK 标签</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过连续的 &#x27;/&#x27;</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            name++; <span class="comment">// 将 name 指针向后移动一位</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (unlikely(*name == <span class="string">&#x27;/&#x27;</span>)); <span class="comment">// 当遇到 &#x27;/&#x27; 时，继续循环</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到达路径名的结尾，处理结束</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!*name)) &#123; <span class="comment">// 再次检查是否到达路径名的结尾</span></span><br><span class="line">OK:</span><br><span class="line">            <span class="comment">// pathname or trailing symlink, done</span></span><br><span class="line">            <span class="keyword">if</span> (!depth) &#123; <span class="comment">// 如果当前处理的路径组件不是符号链接的一部分</span></span><br><span class="line">                nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); <span class="comment">// 设置 nd-&gt;dir_vfsuid</span></span><br><span class="line">                nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; <span class="comment">// 设置 nd-&gt;dir_mode</span></span><br><span class="line">                nd-&gt;flags &amp;= ~LOOKUP_PARENT; <span class="comment">// 清除 nd-&gt;flags 的 LOOKUP_PARENT 标志</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0，表示路径查找结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// last component of nested symlink</span></span><br><span class="line">            name = nd-&gt;<span class="built_in">stack</span>[--depth].name; <span class="comment">// 获取符号链接栈中下一个组件的名称</span></span><br><span class="line">            link = walk_component(nd, <span class="number">0</span>); <span class="comment">// 处理当前组件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// not the last component</span></span><br><span class="line">            link = walk_component(nd, WALK_MORE); <span class="comment">// 处理当前组件，传递 WALK_MORE 标志</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 link 不为空，表示需要处理符号链接</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(link)) &#123; <span class="comment">// 检查 link 是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(link)) <span class="comment">// 如果 link 是错误指针</span></span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(link); <span class="comment">// 返回错误值</span></span><br><span class="line">            <span class="comment">// a symlink to follow</span></span><br><span class="line">            nd-&gt;<span class="built_in">stack</span>[depth++].name = name; <span class="comment">// 将当前组件的名称压入符号链接栈</span></span><br><span class="line">            name = link; <span class="comment">// 将 name 指针设置为符号链接的目标路径</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续循环处理符号链接的目标路径</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 dentry 是否可以执行查找操作</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; <span class="comment">// 如果不能执行查找操作</span></span><br><span class="line">            <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123; <span class="comment">// 如果 nd-&gt;flags 中包含 LOOKUP_RCU 标志</span></span><br><span class="line">                <span class="keyword">if</span> (!try_to_unlazy(nd)) <span class="comment">// 尝试取消对 nd 的懒加载</span></span><br><span class="line">                    <span class="keyword">return</span> -ECHILD; <span class="comment">// 如果取消失败，返回 -ECHILD 错误值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -ENOTDIR; <span class="comment">// 返回 -ENOTDIR 错误值，表示不是目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算路径组件的长度和哈希值，</span></span><br><span class="line"><span class="comment"> * 并将 &quot;hash_len&quot; 作为结果返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title function_">hash_name</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *salt, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> a = <span class="number">0</span>, b, x = <span class="number">0</span>, y = (<span class="type">unsigned</span> <span class="type">long</span>)salt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> adata, bdata, mask, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">word_at_a_time</span> <span class="title">constants</span> =</span> WORD_AT_A_TIME_CONSTANTS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化长度为 0</span></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> inside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 对 a, x, y 进行哈希混合</span></span><br><span class="line">        HASH_MIX(x, y, a);</span><br><span class="line">        <span class="comment">// 更新名称长度</span></span><br><span class="line">        len += <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">inside:</span><br><span class="line">        <span class="comment">// 在给定偏移量的名称字符串中加载一个未对齐的值</span></span><br><span class="line">        a = load_unaligned_zeropad(name+len);</span><br><span class="line">        <span class="comment">// 通过 XOR 操作找到与斜线字符不同的部分,循环找到</span></span><br><span class="line">        b = a ^ REPEAT_BYTE(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="comment">// 检查 a 和 b 中是否有零字节</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!(has_zero(a, &amp;adata, &amp;constants) | has_zero(b, &amp;bdata, &amp;constants)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 a 和 b 准备零掩码</span></span><br><span class="line">    adata = prep_zero_mask(a, adata, &amp;constants);</span><br><span class="line">    bdata = prep_zero_mask(b, bdata, &amp;constants);</span><br><span class="line">    <span class="comment">// 通过组合 a 和 b 的零掩码创建最终的零掩码</span></span><br><span class="line">    mask = create_zero_mask(adata | bdata);</span><br><span class="line">    <span class="comment">// 将 a 的零掩码应用于 x</span></span><br><span class="line">    x ^= a &amp; zero_bytemask(mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 x, y 和零掩码创建最终的哈希长度值</span></span><br><span class="line">    <span class="keyword">return</span> hashlen_create(fold_hash(x, y), len + find_zero(mask));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="walk-component函数"><a href="#walk-component函数" class="headerlink" title="walk_component函数"></a>walk_component函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/walk_component">walk_component identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 walk_component 的函数，参数包括一个指向 nameidata 结构体的指针和一个整数 flags</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">walk_component</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个指向 dentry 结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;.&quot; 和 &quot;..&quot; 是特殊的 - 尤其是 &quot;..&quot;，因为它必须知道当前根目录和</span></span><br><span class="line"><span class="comment">     * 父目录之间的关系。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果 nd-&gt;last_type 不是 LAST_NORM，则执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;last_type != LAST_NORM)) &#123;</span><br><span class="line">        <span class="comment">// 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth)</span><br><span class="line">            put_link(nd);</span><br><span class="line">        <span class="comment">// 调用 handle_dots 函数处理 &quot;.&quot; 和 &quot;..&quot;</span></span><br><span class="line">        <span class="keyword">return</span> handle_dots(nd, nd-&gt;last_type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 lookup_fast 函数进行快速查找</span></span><br><span class="line">    dentry = lookup_fast(nd);</span><br><span class="line">    <span class="comment">// 如果 dentry 是一个错误指针，则返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(dentry);</span><br><span class="line">    <span class="comment">// 如果 dentry 为 NULL，则执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dentry)) &#123;</span><br><span class="line">        <span class="comment">// 调用 lookup_slow 函数进行慢速查找</span></span><br><span class="line">        dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags);</span><br><span class="line">        <span class="comment">// 如果 dentry 是一个错误指针，则返回错误指针</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">            <span class="keyword">return</span> ERR_CAST(dentry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth)</span><br><span class="line">        put_link(nd);</span><br><span class="line">    <span class="comment">// 调用 step_into 函数进入下一个组件（目录或文件）</span></span><br><span class="line">    <span class="keyword">return</span> step_into(nd, flags, dentry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_link</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> *<span class="title">last</span> =</span> nd-&gt;<span class="built_in">stack</span> + --nd-&gt;depth;</span><br><span class="line">    do_delayed_call(&amp;last-&gt;done);</span><br><span class="line">    <span class="keyword">if</span> (!(nd-&gt;flags &amp; LOOKUP_RCU))</span><br><span class="line">        path_put(&amp;last-&gt;link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数handle_dots，用于处理路径名中的点（.）和点点（..）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">handle_dots</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前路径组件是两个点（..）</span></span><br><span class="line">    <span class="keyword">if</span> (type == LAST_DOTDOT) &#123;</span><br><span class="line">        <span class="comment">// 定义错误指针并初始化为NULL</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *error = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 定义一个dentry结构的父目录指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果nd（nameidata结构）的root成员为空</span></span><br><span class="line">        <span class="keyword">if</span> (!nd-&gt;root.mnt) &#123;</span><br><span class="line">            <span class="comment">// 调用set_root函数设置nd的根目录，并检查是否出现错误</span></span><br><span class="line">            error = ERR_PTR(set_root(nd));</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果nd的flags中包含LOOKUP_RCU标志</span></span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU)</span><br><span class="line">            <span class="comment">// 调用follow_dotdot_rcu函数，以RCU方式处理两个点（..）</span></span><br><span class="line">            parent = follow_dotdot_rcu(nd);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则，调用follow_dotdot函数处理两个点（..）</span></span><br><span class="line">            parent = follow_dotdot(nd);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果parent是一个错误指针，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(parent))</span><br><span class="line">            <span class="keyword">return</span> ERR_CAST(parent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用step_into函数进入parent目录，不跟随符号链接</span></span><br><span class="line">        error = step_into(nd, WALK_NOFOLLOW, parent);</span><br><span class="line">        <span class="comment">// 如果出现错误，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果nd的flags中包含LOOKUP_IS_SCOPED标志</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果我们的路径在进行重命名或挂载操作期间发生竞争，</span></span><br><span class="line"><span class="comment">             * 那么我们无法确定&quot;..&quot;是否跳过了nd-&gt;root（因此用户空间应该重试或使用一些回退方法）。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 读取内存屏障，确保正确的内存顺序</span></span><br><span class="line">            smp_rmb();</span><br><span class="line">            <span class="comment">// 如果mount_lock的序列计数器发生变化，返回错误EAGAIN</span></span><br><span class="line">            <span class="keyword">if</span> (__read_seqcount_retry(&amp;mount_lock.seqcount, nd-&gt;m_seq))</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line">            <span class="comment">// 如果rename_lock的序列计数器发生变化，返回错误EAGAIN</span></span><br><span class="line">            <span class="keyword">if</span> (__read_seqcount_retry(&amp;rename_lock.seqcount, nd-&gt;r_seq))</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是两个点（..），返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lookup-fast函数"><a href="#lookup-fast函数" class="headerlink" title="lookup_fast函数"></a>lookup_fast函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/lookup_fast">lookup_fast identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">lookup_fast</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, *<span class="title">parent</span> =</span> nd-&gt;path.dentry; <span class="comment">// 定义dentry指针，将nd中的path的dentry赋值给parent</span></span><br><span class="line">    <span class="type">int</span> status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Rename seqlock is not required here because in the off chance</span></span><br><span class="line"><span class="comment">     * of a false negative due to a concurrent rename, the caller is</span></span><br><span class="line"><span class="comment">     * going to fall back to non-racy lookup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123; <span class="comment">// 如果使用RCU（读-拷贝-更新）查找</span></span><br><span class="line">        dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); <span class="comment">// 用RCU方式查找目录项</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dentry)) &#123; <span class="comment">// 如果没有找到dentry</span></span><br><span class="line">            <span class="keyword">if</span> (!try_to_unlazy(nd)) <span class="comment">// 尝试将rcu锁升级为非rcu锁</span></span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 返回空指针</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This sequence count validates that the parent had no</span></span><br><span class="line"><span class="comment">         * changes while we did the lookup of the dentry above.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) <span class="comment">// 验证在查找dentry过程中parent没有发生变化</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误</span></span><br><span class="line"></span><br><span class="line">        status = d_revalidate(dentry, nd-&gt;flags); <span class="comment">// 验证dentry的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (likely(status &gt; <span class="number">0</span>)) <span class="comment">// 如果验证成功</span></span><br><span class="line">            <span class="keyword">return</span> dentry; <span class="comment">// 返回dentry</span></span><br><span class="line">        <span class="keyword">if</span> (!try_to_unlazy_next(nd, dentry)) <span class="comment">// 尝试将rcu锁升级为非rcu锁</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (status == -ECHILD)</span><br><span class="line">            <span class="comment">/* we&#x27;d been told to redo it in non-rcu mode */</span></span><br><span class="line">            status = d_revalidate(dentry, nd-&gt;flags); <span class="comment">// 在非RCU模式下重新验证dentry的有效性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果使用非RCU查找</span></span><br><span class="line">        dentry = __d_lookup(parent, &amp;nd-&gt;last); <span class="comment">// 查找目录项</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dentry)) <span class="comment">// 如果没有找到dentry</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 返回空指针</span></span><br><span class="line">        status = d_revalidate(dentry, nd-&gt;flags); <span class="comment">// 验证dentry的有效性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(status &lt;= <span class="number">0</span>)) &#123; <span class="comment">// 如果验证失败</span></span><br><span class="line">        <span class="keyword">if</span> (!status) <span class="comment">// 如果status为0</span></span><br><span class="line">            d_invalidate(dentry); <span class="comment">// 使dentry无效</span></span><br><span class="line">        dput(dentry); <span class="comment">// 释放dentry引用</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(status); <span class="comment">// 返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry; <span class="comment">// 返回dentry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux 为了提高目录项对象的处理效率，设计与实现了目录项高速缓存 <code>dentry cache</code>，简称 <code>dcache</code>，在上节中已有详细描述。<code>lookup_fast()</code>会在<code>dcache</code>中去试图找到该对应的<code>dentry</code>，实际最终会调用<a href="https://code.woboq.org/linux/linux/include/linux/rculist_bl.h.html#123%E8%BD%AE%E8%AF%A2%E5%88%97%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%9F%A5%E6%89%BE%E3%80%82">https://code.woboq.org/linux/linux/include/linux/rculist_bl.h.html#123轮询列表进行查找。</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __d_lookup - 搜索一个 dentry (容易出现竞争)</span></span><br><span class="line"><span class="comment"> * @parent: 父 dentry</span></span><br><span class="line"><span class="comment"> * @name: 我们希望找到的名字的 qstr</span></span><br><span class="line"><span class="comment"> * 返回: dentry，或者 NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup 类似于 d_lookup，但是由于与重命名无关的活动，它可能（很少）返回</span></span><br><span class="line"><span class="comment"> * 一个错误的负面结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup 通过避免读取 rename_lock seqlock，速度稍快，</span></span><br><span class="line"><span class="comment"> * 但必须谨慎使用，例如在失败时使用后续的 d_lookup。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup 调用者必须加注释。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_lookup</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = name-&gt;hash; <span class="comment">// 计算 name 的哈希值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> d_hash(hash); <span class="comment">// 获取哈希值对应的哈希桶</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> *<span class="title">node</span>;</span> <span class="comment">// 用于遍历哈希链表的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">found</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 用于存储找到的 dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 用于遍历哈希链表的临时 dentry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注意：这里与 __d_lookup_rcu 有很大的重复部分，这是为了防止单线程性能</span></span><br><span class="line"><span class="comment">     * 回归，特别是在 smp_rmb（在 seqcounts 中）代价高昂的架构上。</span></span><br><span class="line"><span class="comment">     * 保持这两个函数同步更新。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 哈希列表使用 RCU 保护。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在比较候选 dentry 时，获取 d_lock 以避免与 d_move() 的竞争。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 有可能并发的重命名操作会破坏我们这里的列表遍历，导致我们错过 dentry，</span></span><br><span class="line"><span class="comment">     * 从而产生错误的负面结果。d_lookup() 使用 rename_lock seqlock 来保护</span></span><br><span class="line"><span class="comment">     * 并发重命名。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 更多细节请参阅 Documentation/filesystems/path-lookup.txt。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rcu_read_lock(); <span class="comment">// 获取 RCU 读锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希链表</span></span><br><span class="line">    hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.hash != hash) <span class="comment">// 哈希值不匹配，继续下一个</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock); <span class="comment">// 获取 dentry 的自旋锁</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_parent != parent) <span class="comment">// 父 dentry 不匹配，跳到下一个</span></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line">        <span class="keyword">if</span> (d_unhashed(dentry)) <span class="comment">// 检查 dentry 是否已从哈希表中移除，如果是则跳到下一个</span></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!d_same_name(dentry, parent, name)) <span class="comment">// 名字不匹配，跳到下一个</span></span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        dentry-&gt;d_lockref.count++; <span class="comment">// 增加 dentry 的引用计数</span></span><br><span class="line">        found = dentry; <span class="comment">// 找到匹配的 dentry，赋值给 found</span></span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock); <span class="comment">// 释放 dentry 的自旋锁</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 结束循环</span></span><br><span class="line">    next:</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock); <span class="comment">// 释放 dentry 的自旋锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock(); <span class="comment">// 释放 RCU 读锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found; <span class="comment">// 返回找到的 dentry，如果没有找到返回 NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d-lookup-rcu函数"><a href="#d-lookup-rcu函数" class="headerlink" title="__d_lookup_rcu函数"></a>__d_lookup_rcu函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/__d_lookup_rcu">__d_lookup_rcu identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_lookup_rcu</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">                <span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">                <span class="title">unsigned</span> *<span class="title">seqp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u64 hashlen = name-&gt;hash_len; <span class="comment">// 计算名称的哈希长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *str = name-&gt;name; <span class="comment">// 获取名称字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> d_hash(hashlen_hash(hashlen)); <span class="comment">// 计算哈希值并获取散列表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> *<span class="title">node</span>;</span> <span class="comment">// 定义哈希表节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 定义目录项指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note: There is significant duplication with __d_lookup_rcu which is</span></span><br><span class="line"><span class="comment">     * required to prevent single threaded performance regressions</span></span><br><span class="line"><span class="comment">     * especially on architectures where smp_rmb (in seqcounts) are costly.</span></span><br><span class="line"><span class="comment">     * Keep the two functions in sync.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查父目录项是否包含自定义比较函数，如果有则调用特定的查找函数</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))</span><br><span class="line">        <span class="keyword">return</span> __d_lookup_rcu_op_compare(parent, name, seqp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The hash list is protected using RCU.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Carefully use d_seq when comparing a candidate dentry, to avoid</span></span><br><span class="line"><span class="comment">     * races with d_move().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is possible that concurrent renames can mess up our list</span></span><br><span class="line"><span class="comment">     * walk here and result in missing our dentry, resulting in the</span></span><br><span class="line"><span class="comment">     * false-negative result. d_lookup() protects against concurrent</span></span><br><span class="line"><span class="comment">     * renames using rename_lock seqlock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * See Documentation/filesystems/path-lookup.txt for more details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 使用 RCU 保护的哈希列表来遍历目录项</span></span><br><span class="line">    hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123;</span><br><span class="line">        <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The dentry sequence count protects us from concurrent</span></span><br><span class="line"><span class="comment">         * renames, and thus protects parent and name fields.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The caller must perform a seqcount check in order</span></span><br><span class="line"><span class="comment">         * to do anything useful with the returned dentry.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * NOTE! We do a &quot;raw&quot; seqcount_begin here. That means that</span></span><br><span class="line"><span class="comment">         * we don&#x27;t wait for the sequence count to stabilize if it</span></span><br><span class="line"><span class="comment">         * is in the middle of a sequence change. If we do the slow</span></span><br><span class="line"><span class="comment">         * dentry compare, we will do seqretries until it is stable,</span></span><br><span class="line"><span class="comment">         * and if we end up with a successful lookup, we actually</span></span><br><span class="line"><span class="comment">         * want to exit RCU lookup anyway.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Note that raw_seqcount_begin still *does* smp_rmb(), so</span></span><br><span class="line"><span class="comment">         * we are still guaranteed NUL-termination of -&gt;d_name.name.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); <span class="comment">// 获取 dentry 的序列计数</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_parent != parent) <span class="comment">// 检查 dentry 的父目录项是否与给定的父目录项相同</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d_unhashed(dentry)) <span class="comment">// 检查 dentry 是否已从散列表中删除</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.hash_len != hashlen) <span class="comment">// 检查 dentry 的名称哈希长度是否与给定名称相同</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dentry_cmp(dentry, str, hashlen_len(hashlen)) != <span class="number">0</span>) <span class="comment">// 比较 dentry 的名称与给定名称是否相同</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        *seqp = seq; <span class="comment">// 将序列计数赋值给 seqp</span></span><br><span class="line">        <span class="keyword">return</span> dentry; <span class="comment">// 返回找到的 dentry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果没有找到匹配的 dentry，则返回空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__d_lookup_rcu</code> 函数在给定的父目录项下查找具有给定名称的目录项（<code>dentry</code>）。它使用 RCU（读-拷贝-更新）机制遍历散列表，以便在遍历过程中保护数据结构。如果找到匹配的目录项，它将返回指向该目录项的指针，否则返回 <code>NULL</code>。</p>
<h3 id="hlist-bl-for-each-entry-rcu"><a href="#hlist-bl-for-each-entry-rcu" class="headerlink" title="hlist_bl_for_each_entry_rcu"></a>hlist_bl_for_each_entry_rcu</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hlist_bl_for_each_entry_rcu - iterate over rcu list of given type</span></span><br><span class="line"><span class="comment"> * @tpos:    the type * to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @pos:    the &amp;struct hlist_bl_node to use as a loop cursor.</span></span><br><span class="line"><span class="comment"> * @head:    the head for your list.</span></span><br><span class="line"><span class="comment"> * @member:    the name of the hlist_bl_node within the struct.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hlist_bl_for_each_entry_rcu(tpos, pos, head, member)        \</span></span><br><span class="line"><span class="meta">    <span class="comment">// 初始化 pos 为列表头的第一个元素</span></span></span><br><span class="line">    <span class="keyword">for</span> (pos = hlist_bl_first_rcu(head);                \</span><br><span class="line">        <span class="comment">// 当 pos 不为 NULL 时执行循环体内的代码</span></span><br><span class="line">        pos &amp;&amp;                            \</span><br><span class="line">        <span class="comment">// 使用宏 hlist_bl_entry 获取当前 pos 对应的结构体类型的指针，并赋值给 tpos</span></span><br><span class="line">        (&#123; tpos = hlist_bl_entry(pos, typeof(*tpos), member); <span class="number">1</span>; &#125;); \</span><br><span class="line">        <span class="comment">// 更新 pos 为下一个元素，使用 rcu_dereference_raw 进行 RCU 解引用</span></span><br><span class="line">        pos = rcu_dereference_raw(pos-&gt;next)) </span><br></pre></td></tr></table></figure>

<p>这个宏定义了一个 <code>for</code> 循环，用于遍历链表中的每个元素。在循环体内，它使用 <code>hlist_bl_entry</code> 宏获取当前 <code>pos</code> 对应的结构体类型的指针，并将其赋值给 <code>tpos</code>。循环将持续进行，直到遍历完链表。在每次迭代时，它都会使用 <code>rcu_dereference_raw</code> 函数对 <code>pos-&gt;next</code> 进行 RCU 解引用以获取下一个元素。</p>
<h3 id="lookup-slow"><a href="#lookup-slow" class="headerlink" title="lookup_slow"></a>lookup_slow</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/lookup_slow">lookup_slow identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">lookup_slow</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> qstr *name,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> dentry *dir,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dir-&gt;d_inode; <span class="comment">// 获取给定目录项（dir）对应的 inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span>;</span> <span class="comment">// 定义一个目录项指针，用于存储查找结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 inode 上的共享锁进行加锁，以保护查找过程中的数据结构</span></span><br><span class="line">    inode_lock_shared(inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 __lookup_slow 函数在给定目录项（dir）下查找与给定名称（name）匹配的目录项</span></span><br><span class="line">    res = __lookup_slow(name, dir, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 inode 上的共享锁进行解锁</span></span><br><span class="line">    inode_unlock_shared(inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回查找到的目录项（dentry），如果没有找到匹配的项，返回 NULL</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lookup-slow函数"><a href="#lookup-slow函数" class="headerlink" title="__lookup_slow函数"></a>__lookup_slow函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/__lookup_slow">__lookup_slow identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Fast lookup failed, do it the slow way */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">lookup_slow</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">                    <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dir</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dir-&gt;d_inode; <span class="comment">// 获取给定目录项（dir）对应的 inode</span></span><br><span class="line">    DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); <span class="comment">// 定义一个等待队列头变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 inode 已经是死亡状态，直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(IS_DEADDIR(inode)))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">// 分配一个新的 dentry，如果需要等待，则使用 wq 等待</span></span><br><span class="line">    dentry = d_alloc_parallel(dir, name, &amp;wq);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 dentry 不处于查找状态</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!d_in_lookup(dentry))) &#123;</span><br><span class="line">        <span class="comment">// 重新验证 dentry</span></span><br><span class="line">        <span class="type">int</span> error = d_revalidate(dentry, flags);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果验证失败，使 dentry 无效，释放 dentry，并重新尝试</span></span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                d_invalidate(dentry);</span><br><span class="line">                dput(dentry);</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放 dentry，并返回错误</span></span><br><span class="line">            dput(dentry);</span><br><span class="line">            dentry = ERR_PTR(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用文件系统特定的 lookup 函数查找 dentry</span></span><br><span class="line">        old = inode-&gt;i_op-&gt;lookup(inode, dentry, flags);</span><br><span class="line">        d_lookup_done(dentry); <span class="comment">// 完成查找操作</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(old)) &#123;</span><br><span class="line">            <span class="comment">// 如果找到旧的 dentry，释放新分配的 dentry，并使用旧的 dentry</span></span><br><span class="line">            dput(dentry);</span><br><span class="line">            dentry = old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回查找到的 dentry 或新创建的 dentry</span></span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__lookup_slow</code> 函数在给定的目录项（<code>dir</code>）下查找具有给定名称（<code>name</code>）的目录项（<code>dentry</code>）。此函数在快速查找失败的情况下使用慢速查找方法。首先，它获取给定目录项（<code>dir</code>）对应的 <code>inode</code>，然后分配一个新的 <code>dentry</code>。接着检查 <code>dentry</code> 是否处于查找状态，如果不是，则重新验证 <code>dentry</code>。如果验证失败，则使 <code>dentry</code> 无效并释放它，然后重新尝试。如果 <code>dentry</code> 处于查找状态，则调用文件系统特定的 <code>lookup</code> 函数查找 <code>dentry</code>。完成查找后，如果找到旧的 <code>dentry</code>，则释放新分配的 <code>dentry</code> 并使用旧的 <code>dentry</code>。最后，返回找到的或新创建的 <code>dentry</code>。</p>
<p>当查找成功时，<code>__lookup_slow</code> 函数返回找到的 <code>dentry</code>。如果没有找到匹配的目录项，<code>inode-&gt;i_op-&gt;lookup</code> 函数将创建一个新的目录项并返回它。创建新目录项的过程依赖于具体的文件系统实现，通常涉及分配一个新的 <code>dentry</code> 结构，并将其与给定的 <code>name</code> 和父目录项关联起来。</p>
<h3 id="inode-gt-i-op-gt-lookup函数指向-simple-lookup-函数"><a href="#inode-gt-i-op-gt-lookup函数指向-simple-lookup-函数" class="headerlink" title="inode-&gt;i_op-&gt;lookup函数指向 simple_lookup() 函数"></a>inode-&gt;i_op-&gt;lookup函数指向 simple_lookup() 函数</h3><p>首先我们参考上文中的<mark>get_tree函数是如何被设置为shmem_init函数</mark></p>
<p>可以了解到内核在启动时会初始化tmpfs文件系统</p>
<p>我们根据调用链shmem_get_tree - shmem_fill_super - shmem_get_inode，然后查看<code>shmem_get_inode</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">shmem_get_inode</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> inode *dir, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> dev,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_inode_info</span> *<span class="title">info</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmem_sb_info</span> *<span class="title">sbinfo</span> =</span> SHMEM_SB(sb);</span><br><span class="line">    <span class="type">ino_t</span> ino;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新的inode预留一个系统内部的编号</span></span><br><span class="line">    <span class="keyword">if</span> (shmem_reserve_inode(sb, &amp;ino))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新的inode分配内存</span></span><br><span class="line">    inode = new_inode(sb);</span><br><span class="line">    <span class="keyword">if</span> (inode) &#123;</span><br><span class="line">        <span class="comment">// 设置inode的编号</span></span><br><span class="line">        inode-&gt;i_ino = ino;</span><br><span class="line">        <span class="comment">// 初始化inode的所有者和权限模式</span></span><br><span class="line">        inode_init_owner(idmap, inode, dir, mode);</span><br><span class="line">        <span class="comment">// 设置inode的磁盘块数为0</span></span><br><span class="line">        inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 设置inode的访问、修改和创建时间</span></span><br><span class="line">        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">        <span class="comment">// 设置inode的生成编号（用于NFS）</span></span><br><span class="line">        inode-&gt;i_generation = get_random_u32();</span><br><span class="line">        <span class="comment">// 获得shmem_inode_info结构（tmpfs专用）</span></span><br><span class="line">        info = SHMEM_I(inode);</span><br><span class="line">        <span class="comment">// 初始化shmem_inode_info结构</span></span><br><span class="line">        <span class="built_in">memset</span>(info, <span class="number">0</span>, (<span class="type">char</span> *)inode - (<span class="type">char</span> *)info);</span><br><span class="line">        spin_lock_init(&amp;info-&gt;lock);</span><br><span class="line">        <span class="type">atomic_set</span>(&amp;info-&gt;stop_eviction, <span class="number">0</span>);</span><br><span class="line">        info-&gt;seals = F_SEAL_SEAL;</span><br><span class="line">        info-&gt;flags = flags &amp; VM_NORESERVE;</span><br><span class="line">        info-&gt;i_crtime = inode-&gt;i_mtime;</span><br><span class="line">        info-&gt;fsflags = (dir == <span class="literal">NULL</span>) ? <span class="number">0</span> :</span><br><span class="line">            SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED;</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;fsflags)</span><br><span class="line">            shmem_set_inode_flags(inode, info-&gt;fsflags);</span><br><span class="line">        INIT_LIST_HEAD(&amp;info-&gt;shrinklist);</span><br><span class="line">        INIT_LIST_HEAD(&amp;info-&gt;swaplist);</span><br><span class="line">        simple_xattrs_init(&amp;info-&gt;xattrs);</span><br><span class="line">        cache_no_acl(inode);</span><br><span class="line">        mapping_set_large_folios(inode-&gt;i_mapping);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据不同的文件类型，设置相应的操作函数</span></span><br><span class="line">        <span class="keyword">switch</span> (mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            inode-&gt;i_op = &amp;shmem_special_inode_operations;</span><br><span class="line">            init_special_inode(inode, mode, dev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops;</span><br><span class="line">            inode-&gt;i_op = &amp;shmem_inode_operations;</span><br><span class="line">            inode-&gt;i_fop = &amp;shmem_file_operations;</span><br><span class="line">            mpol_shared_policy_init(&amp;info-&gt;policy,</span><br><span class="line">                         shmem_get_sbmpol(sbinfo));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            inc_nlink(inode);</span><br><span class="line">            inode-&gt;i_size = <span class="number">2</span> * BOGO_DIRENT_SIZE;</span><br><span class="line">            inode-&gt;i_op = &amp;shmem_dir_inode_operations;</span><br><span class="line">            inode-&gt;i_fop = &amp;simple_dir_operations;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            mpol_shared_policy_init(&amp;info-&gt;policy, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为锁依赖分析系统设置inode互斥锁的标记</span></span><br><span class="line">        lockdep_annotate_inode_mutex_key(inode);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果inode分配失败，则释放预留的编号</span></span><br><span class="line">        shmem_free_inode(sb);</span><br><span class="line">    <span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><mark>设置文件类型为目录类型</mark></p>
<p>所以<code>inode-&gt;i_op = &amp;shmem_dir_inode_operations;</code></p>
<p>查看这个变量的定义</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_dir_inode_operations">shmem_dir_inode_operations identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">shmem_dir_inode_operations</span> =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">    .getattr    = shmem_getattr,</span><br><span class="line">    .create        = shmem_create,</span><br><span class="line">    .lookup        = simple_lookup,<span class="comment">//这里定义了lookup函数</span></span><br><span class="line">    .link        = shmem_link,</span><br><span class="line">    .unlink        = shmem_unlink,</span><br><span class="line">    .symlink    = shmem_symlink,</span><br><span class="line">    .mkdir        = shmem_mkdir,</span><br><span class="line">    .rmdir        = shmem_rmdir,</span><br><span class="line">    .mknod        = shmem_mknod,</span><br><span class="line">    .rename        = shmem_rename2,</span><br><span class="line">    .tmpfile    = shmem_tmpfile,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_XATTR</span></span><br><span class="line">    .listxattr    = shmem_listxattr,</span><br><span class="line">    .fileattr_get    = shmem_fileattr_get,</span><br><span class="line">    .fileattr_set    = shmem_fileattr_set,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_POSIX_ACL</span></span><br><span class="line">    .setattr    = shmem_setattr,</span><br><span class="line">    .set_acl    = simple_set_acl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lookup函数被设置为了simple_lookup</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/simple_lookup">simple_lookup identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找数据。这很简单 - 如果 dentry 不存在，</span></span><br><span class="line"><span class="comment"> * 我们知道它是负的。设置 d_op 以删除负 dentries。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 simple_lookup 函数，它接受一个指向 inode 的指针，</span></span><br><span class="line"><span class="comment">// 一个指向 dentry 的指针，以及一个无符号整数作为标志作为参数。</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">simple_lookup</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 dentry 名称的长度是否大于允许的最大值（NAME_MAX）。</span></span><br><span class="line">    <span class="comment">// 如果是，则返回带有 -ENAMETOOLONG 的错误指针。</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_name.len &gt; NAME_MAX)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENAMETOOLONG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 dentry 的超级块 d_op 字段为 NULL，</span></span><br><span class="line">    <span class="comment">// 将其设置为 simple_dentry_operations。</span></span><br><span class="line">    <span class="keyword">if</span> (!dentry-&gt;d_sb-&gt;s_d_op)</span><br><span class="line">        d_set_d_op(dentry, &amp;simple_dentry_operations);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 dentry 添加到 dcache 中，使用 NULL inode，</span></span><br><span class="line">    <span class="comment">// 表示负 dentry（即，文件不存在）。</span></span><br><span class="line">    d_add(dentry, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 NULL，表示查找已完成。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 simple_lookup 符号，使其可供其他模块使用。</span></span><br><span class="line">EXPORT_SYMBOL(simple_lookup);</span><br></pre></td></tr></table></figure>

<p>如果没有找到文件，simple_lookup会返回NULL，并且</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!dentry-&gt;d_sb-&gt;s_d_op)</span><br><span class="line">        d_set_d_op(dentry, &amp;simple_dentry_operations);</span><br></pre></td></tr></table></figure>

<p>这段代码将d_op设置为simple_dentry_operations</p>
<p>然后调用d_add添加一个负dentry(NULL inode),表示文件不存在。</p>
<h3 id="open-last-lookups函数"><a href="#open-last-lookups函数" class="headerlink" title="open_last_lookups函数"></a>open_last_lookups函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/open_last_lookups">open_last_lookups identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">open_last_lookups</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dir</span> =</span> nd-&gt;path.dentry; <span class="comment">// 获取路径对应的 dentry</span></span><br><span class="line">    <span class="type">int</span> open_flag = op-&gt;open_flag; <span class="comment">// 获取文件打开标志</span></span><br><span class="line">    <span class="type">bool</span> got_write = <span class="literal">false</span>; <span class="comment">// 标记是否获取到写权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *res;</span><br><span class="line"></span><br><span class="line">    nd-&gt;flags |= op-&gt;intent; <span class="comment">// 更新 nd 的标志，将 op-&gt;intent 合并到 nd-&gt;flags 中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理不是普通类型的路径分量（如 &#x27;..&#x27;, &#x27;.&#x27;）</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;last_type != LAST_NORM) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;depth)</span><br><span class="line">            put_link(nd); <span class="comment">// 如果 nd-&gt;depth 不为 0，释放符号链接</span></span><br><span class="line">        <span class="keyword">return</span> handle_dots(nd, nd-&gt;last_type); <span class="comment">// 处理 &#x27;.&#x27; 和 &#x27;..&#x27; 路径分量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未设置 O_CREAT，尝试在 RCU 模式下快速查找目录项</span></span><br><span class="line">    <span class="keyword">if</span> (!(open_flag &amp; O_CREAT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;last.name[nd-&gt;last.len])</span><br><span class="line">            nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;</span><br><span class="line">        dentry = lookup_fast(nd); <span class="comment">// 快速查找目录项</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">            <span class="keyword">return</span> ERR_CAST(dentry); <span class="comment">// 如果出错，返回错误指针</span></span><br><span class="line">        <span class="keyword">if</span> (likely(dentry))</span><br><span class="line">            <span class="keyword">goto</span> finish_lookup;</span><br><span class="line"></span><br><span class="line">        BUG_ON(nd-&gt;flags &amp; LOOKUP_RCU);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对于 O_CREAT 标志的处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前处于 RCU 模式，则尝试从 RCU 模式切换到非 RCU 模式</span></span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!try_to_unlazy(nd))</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line">        &#125;</span><br><span class="line">        audit_inode(nd-&gt;name, dir, AUDIT_INODE_PARENT); <span class="comment">// 审计相关操作</span></span><br><span class="line">        <span class="comment">// 检查路径名是否有尾随的 &#x27;/&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(nd-&gt;last.name[nd-&gt;last.len]))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-EISDIR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要获取写权限</span></span><br><span class="line">    <span class="keyword">if</span> (open_flag &amp; (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) &#123;</span><br><span class="line">        got_write = !mnt_want_write(nd-&gt;path.mnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果设置了 O_CREAT，对目录 inode 上锁；否则，对目录 inode 加共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (open_flag &amp; O_CREAT)</span><br><span class="line">        inode_lock(dir-&gt;d_inode);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inode_lock_shared(dir-&gt;d_inode);</span><br><span class="line">    <span class="comment">// 调用 lookup_open 函数进行打开或创建操作</span></span><br><span class="line">    dentry = lookup_open(nd, file, op, got_write);</span><br><span class="line">    <span class="comment">// 如果成功创建新文件，通知相关子系统</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(dentry) &amp;&amp; (file-&gt;f_mode &amp; FMODE_CREATED))</span><br><span class="line">        fsnotify_create(dir-&gt;d_inode, dentry);</span><br><span class="line">    <span class="comment">// 解锁目录 inode</span></span><br><span class="line">    <span class="keyword">if</span> (open_flag &amp; O_CREAT)</span><br><span class="line">        inode_unlock(dir-&gt;d_inode);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inode_unlock_shared(dir-&gt;d_inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已获取写权限，释放对挂载点的写权限</span></span><br><span class="line">    <span class="keyword">if</span> (got_write)</span><br><span class="line">        mnt_drop_write(nd-&gt;path.mnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(dentry); <span class="comment">// 如果出错，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件已打开或创建，更新 nd-&gt;path</span></span><br><span class="line">    <span class="keyword">if</span> (file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED)) &#123;</span><br><span class="line">        dput(nd-&gt;path.dentry);</span><br><span class="line">        nd-&gt;path.dentry = dentry;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish_lookup:</span><br><span class="line">    <span class="comment">// 结束查找，释放符号链接并进入下一个路径分量</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;depth)</span><br><span class="line">        put_link(nd);</span><br><span class="line">    res = step_into(nd, WALK_TRAILING, dentry);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(res))</span><br><span class="line">        nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lookup-open函数"><a href="#lookup-open函数" class="headerlink" title="lookup_open函数"></a>lookup_open函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">lookup_open</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> open_flags *op,</span></span><br><span class="line"><span class="params">                  <span class="type">bool</span> got_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dir</span> =</span> nd-&gt;path.dentry; <span class="comment">// 当前目录的 dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir_inode</span> =</span> dir-&gt;d_inode; <span class="comment">// 当前目录的 inode</span></span><br><span class="line">    <span class="type">int</span> open_flag = op-&gt;open_flag; <span class="comment">// 打开标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 最终要打开或创建的目录项</span></span><br><span class="line">    <span class="type">int</span> error, create_error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">umode_t</span> mode = op-&gt;mode; <span class="comment">// 文件模式</span></span><br><span class="line">    DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前目录已死，返回 -ENOENT 错误</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(IS_DEADDIR(dir_inode)))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">    file-&gt;f_mode &amp;= ~FMODE_CREATED;</span><br><span class="line">    <span class="comment">// 查找当前目录是否包含要打开或创建的目录项</span></span><br><span class="line">    dentry = d_lookup(dir, &amp;nd-&gt;last);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dentry) &#123;</span><br><span class="line">            dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">                <span class="keyword">return</span> dentry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d_in_lookup(dentry))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        error = d_revalidate(dentry, nd-&gt;flags);</span><br><span class="line">        <span class="keyword">if</span> (likely(error &gt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_dput;</span><br><span class="line">        d_invalidate(dentry);</span><br><span class="line">        dput(dentry);</span><br><span class="line">        dentry = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_inode) &#123;</span><br><span class="line">        <span class="comment">// 缓存的正 dentry：将在 f_op-&gt;open 中打开</span></span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查写权限</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!got_write))</span><br><span class="line">        open_flag &amp;= ~O_TRUNC;</span><br><span class="line">    idmap = mnt_idmap(nd-&gt;path.mnt);</span><br><span class="line">    <span class="keyword">if</span> (open_flag &amp; O_CREAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (open_flag &amp; O_EXCL)</span><br><span class="line">            open_flag &amp;= ~O_TRUNC;</span><br><span class="line">        mode = vfs_prepare_mode(idmap, dir-&gt;d_inode, mode, mode, mode);</span><br><span class="line">        <span class="keyword">if</span> (likely(got_write))</span><br><span class="line">            create_error = may_o_create(idmap, &amp;nd-&gt;path,</span><br><span class="line">                            dentry, mode);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            create_error = -EROFS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (create_error)</span><br><span class="line">        open_flag &amp;= ~O_CREAT;</span><br><span class="line">    <span class="keyword">if</span> (dir_inode-&gt;i_op-&gt;<span class="type">atomic_open</span>) &#123;</span><br><span class="line">        dentry = <span class="type">atomic_open</span>(nd, dentry, file, open_flag, mode);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(create_error) &amp;&amp; dentry == ERR_PTR(-ENOENT))</span><br><span class="line">            dentry = ERR_PTR(create_error);</span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_in_lookup(dentry)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span> =</span> dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry,</span><br><span class="line">                                 nd-&gt;flags);</span><br><span class="line">        d_lookup_done(dentry);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(res)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(res)) &#123;</span><br><span class="line">                error = PTR_ERR(res);</span><br><span class="line">                <span class="keyword">goto</span> out_dput;</span><br><span class="line">            &#125;</span><br><span class="line">            dput(dentry);</span><br><span class="line">            dentry = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Negative dentry，创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (!dentry-&gt;d_inode &amp;&amp; (open_flag &amp; O_CREAT)) &#123;</span><br><span class="line">        file-&gt;f_mode |= FMODE_CREATED;</span><br><span class="line">        audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE);</span><br><span class="line">        <span class="keyword">if</span> (!dir_inode-&gt;i_op-&gt;create) &#123;</span><br><span class="line">            error = -EACCES;</span><br><span class="line">            <span class="keyword">goto</span> out_dput;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新文件的关键代码</span></span><br><span class="line">        error = dir_inode-&gt;i_op-&gt;create(idmap, dir_inode, dentry,</span><br><span class="line">                        mode, open_flag &amp; O_EXCL);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> out_dput;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(create_error) &amp;&amp; !dentry-&gt;d_inode) &#123;</span><br><span class="line">        error = create_error;</span><br><span class="line">        <span class="keyword">goto</span> out_dput;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line"></span><br><span class="line">out_dput:</span><br><span class="line">    dput(dentry);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dir-inode-gt-i-op-gt-create指向shmem-create函数"><a href="#dir-inode-gt-i-op-gt-create指向shmem-create函数" class="headerlink" title="dir_inode-&gt;i_op-&gt;create指向shmem_create函数"></a>dir_inode-&gt;i_op-&gt;create指向shmem_create函数</h3><p>参考上文中的<code>inode-&gt;i_op-&gt;lookup函数</code>指向<code>simple_lookup()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">shmem_dir_inode_operations</span> =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">    .getattr    = shmem_getattr,</span><br><span class="line">    .create        = shmem_create,<span class="comment">//这里定义了create函数</span></span><br><span class="line">    .lookup        = simple_lookup,<span class="comment">//这里定义了lookup函数</span></span><br><span class="line">    .link        = shmem_link,</span><br><span class="line">    .unlink        = shmem_unlink,</span><br><span class="line">    .symlink    = shmem_symlink,</span><br><span class="line">    .mkdir        = shmem_mkdir,</span><br><span class="line">    .rmdir        = shmem_rmdir,</span><br><span class="line">    .mknod        = shmem_mknod,</span><br><span class="line">    .rename        = shmem_rename2,</span><br><span class="line">    .tmpfile    = shmem_tmpfile,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_XATTR</span></span><br><span class="line">    .listxattr    = shmem_listxattr,</span><br><span class="line">    .fileattr_get    = shmem_fileattr_get,</span><br><span class="line">    .fileattr_set    = shmem_fileattr_set,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_POSIX_ACL</span></span><br><span class="line">    .setattr    = shmem_setattr,</span><br><span class="line">    .set_acl    = simple_set_acl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;_setattr,</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>可以看到这个结构体中<code>.create = shmem_create</code>，我们再细看<code>shmem_create</code>函数</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_create">shmem_create identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_create</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">bool</span> excl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> shmem_mknod(idmap, dir, dentry, mode | S_IFREG, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="shmem-mknod函数"><a href="#shmem-mknod函数" class="headerlink" title="shmem_mknod函数"></a>shmem_mknod函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_mknod">shmem_mknod identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">shmem_mknod</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span> <span class="comment">// 用于存储新创建的 inode</span></span><br><span class="line">    <span class="type">int</span> error = -ENOSPC; <span class="comment">// 初始化错误码为 -ENOSPC（没有空间可用）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从共享内存文件系统获取新的 inode</span></span><br><span class="line">    inode = shmem_get_inode(idmap, dir-&gt;i_sb, dir, mode, dev, VM_NORESERVE);</span><br><span class="line">    <span class="keyword">if</span> (inode) &#123; <span class="comment">// 如果成功获取 inode</span></span><br><span class="line">        <span class="comment">// 创建简单 ACL（访问控制列表）</span></span><br><span class="line">        error = simple_acl_create(dir, inode);</span><br><span class="line">        <span class="keyword">if</span> (error) <span class="comment">// 如果创建失败，跳转到 out_iput 标签</span></span><br><span class="line">            <span class="keyword">goto</span> out_iput;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 inode 安全属性</span></span><br><span class="line">        error = security_inode_init_security(inode, dir,</span><br><span class="line">                             &amp;dentry-&gt;d_name,</span><br><span class="line">                             shmem_initxattrs, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 如果初始化失败且错误码不是 -EOPNOTSUPP，跳转到 out_iput 标签</span></span><br><span class="line">        <span class="keyword">if</span> (error &amp;&amp; error != -EOPNOTSUPP)</span><br><span class="line">            <span class="keyword">goto</span> out_iput;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 至此，文件创建成功，将错误码置为 0</span></span><br><span class="line">        error = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 更新目录 inode 大小</span></span><br><span class="line">        dir-&gt;i_size += BOGO_DIRENT_SIZE;</span><br><span class="line">        <span class="comment">// 更新目录 inode 访问和修改时间</span></span><br><span class="line">        dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(dir);</span><br><span class="line">        <span class="comment">// 递增目录 inode 的 i_version</span></span><br><span class="line">        inode_inc_iversion(dir);</span><br><span class="line">        <span class="comment">// 将新创建的 inode 与 dentry 关联</span></span><br><span class="line">        d_instantiate(dentry, inode);</span><br><span class="line">        <span class="comment">// 增加 dentry 引用计数</span></span><br><span class="line">        dget(dentry); <span class="comment">/* Extra count - pin the dentry in core */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line"></span><br><span class="line">out_iput: <span class="comment">// 处理创建过程中的错误</span></span><br><span class="line">    iput(inode); <span class="comment">// 释放 inode</span></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-open函数"><a href="#do-open函数" class="headerlink" title="do_open函数"></a>do_open函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/do_open">do_open identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理 open() 的最后一步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_open</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span></span><br><span class="line">    <span class="type">int</span> open_flag = op-&gt;open_flag;</span><br><span class="line">    <span class="type">bool</span> do_truncate;</span><br><span class="line">    <span class="type">int</span> acc_mode;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件未被打开或创建，完成路径名解析</span></span><br><span class="line">    <span class="keyword">if</span> (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123;</span><br><span class="line">        error = complete_walk(nd);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果文件未被创建，进行审计处理</span></span><br><span class="line">    <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CREATED))</span><br><span class="line">        audit_inode(nd-&gt;name, nd-&gt;path.dentry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件系统 ID 映射</span></span><br><span class="line">    idmap = mnt_idmap(nd-&gt;path.mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 O_CREAT 标志</span></span><br><span class="line">    <span class="keyword">if</span> (open_flag &amp; O_CREAT) &#123;</span><br><span class="line">        <span class="comment">// 如果设置了 O_EXCL 标志且文件未被创建，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED))</span><br><span class="line">            <span class="keyword">return</span> -EEXIST;</span><br><span class="line">        <span class="comment">// 如果目标是目录，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (d_is_dir(nd-&gt;path.dentry))</span><br><span class="line">            <span class="keyword">return</span> -EISDIR;</span><br><span class="line">        <span class="comment">// 检查是否有权限在粘滞位目录中创建文件</span></span><br><span class="line">        error = may_create_in_sticky(idmap, nd,</span><br><span class="line">                         d_backing_inode(nd-&gt;path.dentry));</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查目标是否是目录</span></span><br><span class="line">    <span class="keyword">if</span> ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))</span><br><span class="line">        <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 do_truncate 和 acc_mode</span></span><br><span class="line">    do_truncate = <span class="literal">false</span>;</span><br><span class="line">    acc_mode = op-&gt;acc_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件已被创建，跳过写权限检查和截断操作</span></span><br><span class="line">    <span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_CREATED) &#123;</span><br><span class="line">        open_flag &amp;= ~O_TRUNC;</span><br><span class="line">        acc_mode = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="comment">// 如果目标是普通文件且设置了 O_TRUNC 标志，检查写权限</span></span><br><span class="line">        error = mnt_want_write(nd-&gt;path.mnt);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        do_truncate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有权限打开文件</span></span><br><span class="line">    error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有错误且文件未被打开，调用 vfs_open 打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED))</span><br><span class="line">        error = vfs_open(&amp;nd-&gt;path, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对文件执行 IMA 审计</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        error = ima_file_check(file, op-&gt;acc_mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要截断，执行截断操作</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; do_truncate)</span><br><span class="line">        error = handle_truncate(idmap, file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果错误码大于 0，输出警告并设置错误码为 -EINVAL</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        WARN_ON(<span class="number">1</span>);</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进行了截断操作，释放写权限</span></span><br><span class="line">    <span class="keyword">if</span> (do_truncate)</span><br><span class="line">        mnt_drop_write(nd-&gt;path.mnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vfs-open函数"><a href="#vfs-open函数" class="headerlink" title="vfs_open函数"></a>vfs_open函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/vfs_open">vfs_open identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_open - 打开给定路径的文件</span></span><br><span class="line"><span class="comment"> * @path: 要打开的路径</span></span><br><span class="line"><span class="comment"> * @file: 新分配的文件，已初始化 f_flag</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_open</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将文件的路径设置为给定路径</span></span><br><span class="line">    file-&gt;f_path = *path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 do_dentry_open() 函数打开文件</span></span><br><span class="line">    <span class="comment">// 这里传递 NULL 作为 open() 函数的第三个参数，因为在 tmpfs 中，不需要特定的打开操作</span></span><br><span class="line">    <span class="keyword">return</span> do_dentry_open(file, d_backing_inode(path-&gt;dentry), <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-dentry-open函数"><a href="#do-dentry-open函数" class="headerlink" title="do_dentry_open函数"></a>do_dentry_open函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/do_dentry_open">do_dentry_open identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_dentry_open</span><span class="params">(<span class="keyword">struct</span> file *f,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">              <span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明一个空的文件操作结构</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">empty_fops</span> =</span> &#123;&#125;;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加路径的引用计数</span></span><br><span class="line">    path_get(&amp;f-&gt;f_path);</span><br><span class="line">    <span class="comment">// 设置文件的 inode</span></span><br><span class="line">    f-&gt;f_inode = inode;</span><br><span class="line">    <span class="comment">// 设置文件的地址空间（映射）</span></span><br><span class="line">    f-&gt;f_mapping = inode-&gt;i_mapping;</span><br><span class="line">    <span class="comment">// 从文件的地址空间中获取写回错误样本</span></span><br><span class="line">    f-&gt;f_wb_err = filemap_sample_wb_err(f-&gt;f_mapping);</span><br><span class="line">    <span class="comment">// 从文件中获取超级块错误样本</span></span><br><span class="line">    f-&gt;f_sb_err = file_sample_sb_err(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否以 O_PATH 标志打开，如果是，则设置文件模式和操作</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(f-&gt;f_flags &amp; O_PATH)) &#123;</span><br><span class="line">        f-&gt;f_mode = FMODE_PATH | FMODE_OPENED;</span><br><span class="line">        f-&gt;f_op = &amp;empty_fops;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件以读模式打开，增加读取计数</span></span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ) &#123;</span><br><span class="line">        i_readcount_inc(inode);</span><br><span class="line">    <span class="comment">// 如果文件以写模式打开且不是特殊文件，授予写访问权限</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !special_file(inode-&gt;i_mode)) &#123;</span><br><span class="line">        error = get_write_access(inode);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">goto</span> cleanup_file;</span><br><span class="line">        error = __mnt_want_write(f-&gt;f_path.mnt);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">            put_write_access(inode);</span><br><span class="line">            <span class="keyword">goto</span> cleanup_file;</span><br><span class="line">        &#125;</span><br><span class="line">        f-&gt;f_mode |= FMODE_WRITER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为常规文件和目录启用原子位置</span></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">        f-&gt;f_mode |= FMODE_ATOMIC_POS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置其他f_mode标志,获取shmem_file_operations作为f_op */</span></span><br><span class="line">    f-&gt;f_op = fops_get(inode-&gt;i_fop);</span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(!f-&gt;f_op)) &#123;</span><br><span class="line">        error = -ENODEV;</span><br><span class="line">        <span class="keyword">goto</span> cleanup_all;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用security_file_open()和break_lease() */</span></span><br><span class="line">    error = security_file_open(f);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> cleanup_all;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件上是否存在需要中断的活动租约</span></span><br><span class="line">    error = break_lease(file_inode(f), f-&gt;f_flags);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> cleanup_all;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为寻找、pread 和 pwrite 设置默认文件模式标志</span></span><br><span class="line">    f-&gt;f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE;</span><br><span class="line">    <span class="comment">// 使用文件操作提供的 open 函数，如果未提供，则使用默认值</span></span><br><span class="line">    <span class="keyword">if</span> (!open)</span><br><span class="line">        open = f-&gt;f_op-&gt;open;</span><br><span class="line">    <span class="keyword">if</span> (open) &#123;</span><br><span class="line">        error = open(inode, f);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> cleanup_all;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置文件模式标志以表示文件已打开</span></span><br><span class="line">    f-&gt;f_mode |= FMODE_OPENED;</span><br><span class="line">    <span class="comment">// 根据相应操作的可用性设置读写能力</span></span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;f_mode &amp; FMODE_READ) &amp;&amp;</span><br><span class="line">         likely(f-&gt;f_op-&gt;read || f-&gt;f_op-&gt;read_iter))</span><br><span class="line">        f-&gt;f_mode |= FMODE_CAN_READ;</span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp;</span><br><span class="line">         likely(f-&gt;f_op-&gt;write || f-&gt;f_op-&gt;write_iter))</span><br><span class="line">        f-&gt;f_mode |= FMODE_CAN_WRITE;</span><br><span class="line">    <span class="comment">// 如果 llseek 操作不可用，则禁用寻找</span></span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;f_mode &amp; FMODE_LSEEK) &amp;&amp; !f-&gt;f_op-&gt;llseek)</span><br><span class="line">        f-&gt;f_mode &amp;= ~FMODE_LSEEK;</span><br><span class="line">    <span class="comment">// 如果地址空间操作支持，则启用直接 I/O</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_mapping-&gt;a_ops &amp;&amp; f-&gt;f_mapping-&gt;a_ops-&gt;direct_IO)</span><br><span class="line">        f-&gt;f_mode |= FMODE_CAN_ODIRECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除不必要的打开标志</span></span><br><span class="line">    f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);</span><br><span class="line">    <span class="comment">// 为文件设置 iocb 标志</span></span><br><span class="line">    f-&gt;f_iocb_flags = iocb_flags(f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文件的预读状态</span></span><br><span class="line">    file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求 O_DIRECT 但不支持，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> ((f-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !(f-&gt;f_mode &amp; FMODE_CAN_ODIRECT))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件以写模式打开，请确保不使用巨大的页面缓存</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_mode &amp; FMODE_WRITE) &#123;</span><br><span class="line">        smp_mb(); <span class="comment">// 为后续操作确保内存排序</span></span><br><span class="line">        <span class="comment">// 检查页面缓存中是否有任何巨大的页面</span></span><br><span class="line">        <span class="keyword">if</span> (filemap_nr_thps(inode-&gt;i_mapping)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> inode-&gt;i_mapping;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 锁定页面缓存并使其无效</span></span><br><span class="line">            filemap_invalidate_lock(inode-&gt;i_mapping);</span><br><span class="line">            <span class="comment">// 取消映射文件的内存范围</span></span><br><span class="line">            unmap_mapping_range(mapping, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 截断页面缓存中的 inode 页面</span></span><br><span class="line">            truncate_inode_pages(mapping, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 解锁页面缓存</span></span><br><span class="line">            filemap_invalidate_unlock(inode-&gt;i_mapping);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cleanup_all:</span><br><span class="line">    <span class="comment">// 检查无效的正错误代码并重置为 -EINVAL</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(error &gt; <span class="number">0</span>))</span><br><span class="line">        error = -EINVAL;</span><br><span class="line">    <span class="comment">// 释放文件操作结构</span></span><br><span class="line">    fops_put(f-&gt;f_op);</span><br><span class="line">    <span class="comment">// 释放文件访问</span></span><br><span class="line">    put_file_access(f);</span><br><span class="line">cleanup_file:</span><br><span class="line">    <span class="comment">// 减少路径的引用计数并清除文件的路径和 inode</span></span><br><span class="line">    path_put(&amp;f-&gt;f_path);</span><br><span class="line">    f-&gt;f_path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;f_inode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="open-x3D-f-gt-f-op-gt-open设置为generic-filp-open函数"><a href="#open-x3D-f-gt-f-op-gt-open设置为generic-filp-open函数" class="headerlink" title="open &#x3D; f-&gt;f_op-&gt;open设置为generic_filp_open函数"></a>open &#x3D; f-&gt;f_op-&gt;open设置为generic_filp_open函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/generic_file_open">generic_file_open identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个通用文件打开函数，它在一个inode即将被打开时调用。</span></span><br><span class="line"><span class="comment">// 用于在32位系统中禁止打开大文件，除非调用者指定了O_LARGEFILE标志。</span></span><br><span class="line"><span class="comment">// 在64位系统中，sys_open函数会强制使用这个标志。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">generic_file_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查filp-&gt;f_flags是否设置了O_LARGEFILE标志。如果没有设置</span></span><br><span class="line">    <span class="comment">// 并且文件大小（通过i_size_read获取）大于MAX_NON_LFS（文件系统的最大文件限制），</span></span><br><span class="line">    <span class="comment">// 则禁止打开该文件。</span></span><br><span class="line">    <span class="keyword">if</span> (!(filp-&gt;f_flags &amp; O_LARGEFILE) &amp;&amp; i_size_read(inode) &gt; MAX_NON_LFS)</span><br><span class="line">        <span class="comment">// 如果条件满足，返回-EOVERFLOW表示文件太大，无法打开。</span></span><br><span class="line">        <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件大小在允许的范围内，返回0表示成功打开文件。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将generic_file_open函数导出为可供其他模块调用的符号。</span></span><br><span class="line">EXPORT_SYMBOL(generic_file_open);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先这段代码<code>f-&gt;f_op = fops_get(inode-&gt;i_fop);</code>将<code>f-&gt;f_op</code>设置为<code>shmem_file_operations</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义shmem文件系统的文件操作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shmem_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shmem_mmap, <span class="comment">// 映射文件到内存的操作</span></span><br><span class="line">    .open        = generic_file_open, <span class="comment">// 打开文件的通用操作</span></span><br><span class="line">    .get_unmapped_area = shmem_get_unmapped_area, <span class="comment">// 获取未映射区域的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">    .llseek        = shmem_file_llseek, <span class="comment">// 重定位文件读写指针的操作</span></span><br><span class="line">    .read_iter    = shmem_file_read_iter, <span class="comment">// 读取文件的操作</span></span><br><span class="line">    .write_iter    = generic_file_write_iter, <span class="comment">// 写入文件的通用操作</span></span><br><span class="line">    .fsync        = noop_fsync, <span class="comment">// 同步文件的空操作（因为shmem文件系统不需要同步）</span></span><br><span class="line">    .splice_read    = generic_file_splice_read, <span class="comment">// 从文件中读取并拼接数据的通用操作</span></span><br><span class="line">    .splice_write    = iter_file_splice_write, <span class="comment">// 向文件中拼接并写入数据的操作</span></span><br><span class="line">    .fallocate    = shmem_fallocate, <span class="comment">// 预分配文件空间的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么设置为<code>shmem_file_operations</code>呢？根据上文对<code>shmem_get_inode</code>的解析，里面有这一段代码<code>inode-&gt;i_fop = &amp;shmem_file_operations;</code></p>
</li>
</ul>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h4 id="read系统调用"><a href="#read系统调用" class="headerlink" title="read系统调用"></a>read系统调用</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/sys_read">sys_read identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(read, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">char</span> __user *, buf, <span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ksys_read(fd, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ksys-read函数"><a href="#ksys-read函数" class="headerlink" title="ksys_read函数"></a>ksys_read函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/ksys_read">ksys_read identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 ksys_read 函数，参数包括：文件描述符（fd），用户缓冲区（buf）和要读取的字节数（count）</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">ksys_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从给定的文件描述符（fd）获取文件描述符对象（f），并将返回值（ret）初始化为 -EBADF（错误：错误的文件描述符）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">    <span class="type">ssize_t</span> ret = -EBADF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件描述符对象有效（不为 NULL）</span></span><br><span class="line">    <span class="keyword">if</span> (f.file) &#123;</span><br><span class="line">        <span class="comment">// 声明一个变量（pos）来存储文件中的当前位置和指向位置的指针（ppos）</span></span><br><span class="line">        <span class="type">loff_t</span> pos, *ppos = file_ppos(f.file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果位置指针（ppos）不为 NULL，则将当前位置存储在变量（pos）中，并更新指针以指向它</span></span><br><span class="line">        <span class="keyword">if</span> (ppos) &#123;</span><br><span class="line">            pos = *ppos;</span><br><span class="line">            ppos = &amp;pos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 vfs_read 函数从文件中读取数据到用户缓冲区（buf），并将结果存储在返回值（ret）中</span></span><br><span class="line">        ret = vfs_read(f.file, buf, count, ppos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果读取操作成功（ret &gt;= 0）且位置指针不为 NULL，则更新文件描述符对象中的文件位置</span></span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; ppos)</span><br><span class="line">            f.file-&gt;f_pos = pos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放文件描述符对象并更新文件位置</span></span><br><span class="line">        fdput_pos(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回读取操作的结果（已读取的字节数或错误代码）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vfs-read函数"><a href="#vfs-read函数" class="headerlink" title="vfs_read函数"></a>vfs_read函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/vfs_read">vfs_read identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 vfs_read 函数，参数包括：文件指针 (file)，用户缓冲区 (buf)，要读取的字节数 (count)，文件位置指针 (pos)</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">vfs_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否可读，如果不可读则返回 -EBADF 错误</span></span><br><span class="line">    <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_READ))</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line">    <span class="comment">// 检查文件是否支持读操作，如果不支持则返回 -EINVAL 错误</span></span><br><span class="line">    <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CAN_READ))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">// 检查用户缓冲区是否可以被访问，如果不可访问则返回 -EFAULT 错误</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!access_ok(buf, count)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证读取区域是否合法，如果不合法则返回错误</span></span><br><span class="line">    ret = rw_verify_area(READ, file, pos, count);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// 如果要读取的字节数超过最大值，则将 count 设置为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_RW_COUNT)</span><br><span class="line">        count =  MAX_RW_COUNT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件操作结构中有 read 函数，则调用它执行读取操作</span></span><br><span class="line">    <span class="keyword">if</span> (file-&gt;f_op-&gt;read)</span><br><span class="line">        ret = file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line">    <span class="comment">// 如果文件操作结构中有 read_iter 函数，则调用 new_sync_read 函数执行同步读取操作</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;read_iter)</span><br><span class="line">        ret = new_sync_read(file, buf, count, pos);</span><br><span class="line">    <span class="comment">// 如果没有适当的读取函数，则返回 -EINVAL 错误</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果读取成功，执行文件访问通知并更新读取的字符数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fsnotify_access(file);</span><br><span class="line">        add_rchar(current, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加系统调用计数</span></span><br><span class="line">    inc_syscr(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回读取操作的结果（已读取的字节数或错误代码）</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="file-gt-f-op-gt-read-iter设置为shmem-file-read-iter"><a href="#file-gt-f-op-gt-read-iter设置为shmem-file-read-iter" class="headerlink" title="file-&gt;f_op-&gt;read_iter设置为shmem_file_read_iter"></a>file-&gt;f_op-&gt;read_iter设置为shmem_file_read_iter</h4><p>参考上文<code>open = f-&gt;f_op-&gt;open设置为generic_filp_open函数</code>，同理，<code>read_iter</code>被设置为<code>shmem_file_read_iter</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义shmem文件系统的文件操作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shmem_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shmem_mmap, <span class="comment">// 映射文件到内存的操作</span></span><br><span class="line">    .open        = generic_file_open, <span class="comment">// 打开文件的通用操作</span></span><br><span class="line">    .get_unmapped_area = shmem_get_unmapped_area, <span class="comment">// 获取未映射区域的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">    .llseek        = shmem_file_llseek, <span class="comment">// 重定位文件读写指针的操作</span></span><br><span class="line">    .read_iter    = shmem_file_read_iter, <span class="comment">// 读取文件的操作</span></span><br><span class="line">    .write_iter    = generic_file_write_iter, <span class="comment">// 写入文件的通用操作</span></span><br><span class="line">    .fsync        = noop_fsync, <span class="comment">// 同步文件的空操作（因为shmem文件系统不需要同步）</span></span><br><span class="line">    .splice_read    = generic_file_splice_read, <span class="comment">// 从文件中读取并拼接数据的通用操作</span></span><br><span class="line">    .splice_write    = iter_file_splice_write, <span class="comment">// 向文件中拼接并写入数据的操作</span></span><br><span class="line">    .fallocate    = shmem_fallocate, <span class="comment">// 预分配文件空间的</span></span><br></pre></td></tr></table></figure>

<p>由于<code>shmem_fille_operations</code>没有定义<code>read</code></p>
<p>根据如下<code>vfs_read</code>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果文件操作结构中有 read 函数，则调用它执行读取操作</span></span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_op-&gt;read)</span><br><span class="line">    ret = file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line"><span class="comment">// 如果文件操作结构中有 read_iter 函数，则调用 new_sync_read 函数执行同步读取操作</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;read_iter)</span><br><span class="line">    ret = new_sync_read(file, buf, count, pos);</span><br><span class="line"><span class="comment">// 如果没有适当的读取函数，则返回 -EINVAL 错误</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ret = -EINVAL;</span><br></pre></td></tr></table></figure>

<p>下面会调用<code>new_sync_read</code>函数</p>
<h4 id="new-sync-read函数"><a href="#new-sync-read函数" class="headerlink" title="new_sync_read函数"></a>new_sync_read函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/new_sync_read">new_sync_read identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个同步读取函数，用于从文件中读取数据到用户缓冲区</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">new_sync_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> len, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">kiocb</span>;</span> <span class="comment">// 定义一个IO控制块（IOCB）结构体实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">iter</span>;</span> <span class="comment">// 定义一个IO向量迭代器（用于描述用户缓冲区）</span></span><br><span class="line">    <span class="type">ssize_t</span> ret; <span class="comment">// 用于存储函数返回值（读取的字节数）</span></span><br><span class="line"></span><br><span class="line">    init_sync_kiocb(&amp;kiocb, filp); <span class="comment">// 使用文件指针初始化同步IOCB</span></span><br><span class="line">    kiocb.ki_pos = (ppos ? *ppos : <span class="number">0</span>); <span class="comment">// 设置IOCB的文件位置（如果ppos非空，则使用*ppos，否则使用0）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化IO向量迭代器，将其与用户缓冲区关联</span></span><br><span class="line">    iov_iter_ubuf(&amp;iter, ITER_DEST, buf, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用文件系统的read_iter方法（如果存在），并将结果存储到ret变量中</span></span><br><span class="line">    ret = call_read_iter(filp, &amp;kiocb, &amp;iter);</span><br><span class="line">    BUG_ON(ret == -EIOCBQUEUED); <span class="comment">// 如果返回值为-EIOCBQUEUED，触发内核bug（因为这是一个同步操作）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ppos) <span class="comment">// 如果ppos非空</span></span><br><span class="line">        *ppos = kiocb.ki_pos; <span class="comment">// 将IOCB的文件位置更新到ppos变量中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回读取的字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="call-read-iter函数"><a href="#call-read-iter函数" class="headerlink" title="call_read_iter函数"></a>call_read_iter函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/call_read_iter">call_read_iter identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">call_read_iter</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> kiocb *kio,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> file-&gt;f_op-&gt;read_iter(kio, iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shmem-file-read-iter函数"><a href="#shmem-file-read-iter函数" class="headerlink" title="shmem_file_read_iter函数"></a>shmem_file_read_iter函数</h4><p>由上文可知，<code>file-&gt;f_op-&gt;read_iter</code>设置为<code>shmem_file_read_read</code></p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_file_read_iter">shmem_file_read_iter identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义shmem文件系统的文件读取函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">shmem_file_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一些局部变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> inode-&gt;i_mapping;</span><br><span class="line">    <span class="type">pgoff_t</span> index;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> offset;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="type">loff_t</span> *ppos = &amp;iocb-&gt;ki_pos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要读取的页索引和页内偏移量</span></span><br><span class="line">    index = *ppos &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    offset = *ppos &amp; ~PAGE_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环读取数据，直到读完或出错</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">pgoff_t</span> end_index;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr, ret;</span><br><span class="line">        <span class="type">loff_t</span> i_size = i_size_read(inode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算文件的最后一个页索引</span></span><br><span class="line">        end_index = i_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; end_index)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == end_index) &#123;</span><br><span class="line">            nr = i_size &amp; ~PAGE_MASK;</span><br><span class="line">            <span class="keyword">if</span> (nr &lt;= offset)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所需页的folio</span></span><br><span class="line">        error = shmem_get_folio(inode, index, &amp;folio, SGP_READ);</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error == -EINVAL)</span><br><span class="line">                error = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (folio) &#123;</span><br><span class="line">            folio_unlock(folio);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取文件页</span></span><br><span class="line">            page = folio_file_page(folio, index);</span><br><span class="line">            <span class="keyword">if</span> (PageHWPoison(page)) &#123;</span><br><span class="line">                folio_put(folio);</span><br><span class="line">                error = -EIO;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算要读取的字节数</span></span><br><span class="line">        nr = PAGE_SIZE;</span><br><span class="line">        i_size = i_size_read(inode);</span><br><span class="line">        end_index = i_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line">        <span class="keyword">if</span> (index == end_index) &#123;</span><br><span class="line">            nr = i_size &amp; ~PAGE_MASK;</span><br><span class="line">            <span class="keyword">if</span> (nr &lt;= offset) &#123;</span><br><span class="line">                <span class="keyword">if</span> (folio)</span><br><span class="line">                    folio_put(folio);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nr -= offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (folio) &#123;</span><br><span class="line">            <span class="comment">// 如果有写入映射，刷新数据缓存</span></span><br><span class="line">            <span class="keyword">if</span> (mapping_writably_mapped(mapping))</span><br><span class="line">                flush_dcache_page(page);</span><br><span class="line">            <span class="comment">// 如果读取页的开始，标记页为已访问</span></span><br><span class="line">            <span class="keyword">if</span> (!offset)</span><br><span class="line">                folio_mark_accessed(folio);</span><br><span class="line">            <span class="comment">// 将页的内容复制到用户空间</span></span><br><span class="line">            ret = copy_page_to_iter(page, offset, nr, to);</span><br><span class="line">            folio_put(folio);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (user_backed_iter(to)) &#123;</span><br><span class="line">            <span class="comment">// 用零页代替清空用户空间，提高效率</span></span><br><span class="line">            ret = copy_page_to_iter(ZERO_PAGE(<span class="number">0</span>), offset, nr, to);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于管道等，避免连续两次提交相同的页</span></span><br><span class="line">            ret = iov_iter_zero(nr, to);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新读取计数和偏移量</span></span><br><span class="line">        retval += ret;</span><br><span class="line">        offset += ret;</span><br><span class="line">        index += offset &gt;&gt; PAGE_SHIFT;</span><br><span class="line">        offset &amp;= ~PAGE_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否还有数据需要读取</span></span><br><span class="line">        <span class="keyword">if</span> (!iov_iter_count(to))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; nr) &#123;</span><br><span class="line">            error = -EFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cond_resched();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新文件位置</span></span><br><span class="line">    *ppos = ((<span class="type">loff_t</span>) index &lt;&lt; PAGE_SHIFT) + offset;</span><br><span class="line">    <span class="comment">// 标记文件访问</span></span><br><span class="line">    file_accessed(file);</span><br><span class="line">    <span class="comment">// 返回读取的字节数或错误码</span></span><br><span class="line">    <span class="keyword">return</span> retval ? retval : error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><h4 id="write系统调用"><a href="#write系统调用" class="headerlink" title="write系统调用"></a>write系统调用</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/sys_write">sys_write identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(write, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> __user *, buf,</span><br><span class="line">        <span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ksys_write(fd, buf, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ksys-write函数"><a href="#ksys-write函数" class="headerlink" title="ksys_write函数"></a>ksys_write函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/ksys_write">ksys_write identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ksys_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123; <span class="comment">// 函数签名，接受三个参数：文件描述符 fd、用户空间缓冲区的指针 buf 和要写入的字节数 count</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd); <span class="comment">// 获取与文件描述符 fd 相关联的 struct fd 对象（同时获取文件对象和位置）</span></span><br><span class="line">    <span class="type">ssize_t</span> ret = -EBADF; <span class="comment">// 初始化返回值为 -EBADF（表示无效的文件描述符）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f.file) &#123; <span class="comment">// 如果文件描述符有效（即 f.file 非 NULL）</span></span><br><span class="line">        <span class="type">loff_t</span> pos, *ppos = file_ppos(f.file); <span class="comment">// 获取文件的当前写入位置</span></span><br><span class="line">        <span class="keyword">if</span> (ppos) &#123; <span class="comment">// 如果 ppos 非 NULL</span></span><br><span class="line">            pos = *ppos; <span class="comment">// 保存文件的当前写入位置到 pos</span></span><br><span class="line">            ppos = &amp;pos; <span class="comment">// ppos 指向 pos 的地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        ret = vfs_write(f.file, buf, count, ppos); <span class="comment">// 调用 vfs_write 函数进行实际的写操作，并将返回值赋给 ret</span></span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span> &amp;&amp; ppos) <span class="comment">// 如果写操作成功（ret &gt;= 0）且 ppos 非 NULL</span></span><br><span class="line">            f.file-&gt;f_pos = pos; <span class="comment">// 更新文件对象的写入位置</span></span><br><span class="line">        fdput_pos(f); <span class="comment">// 释放 struct fd 对象（减少引用计数）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回写操作的结果，如果成功则返回写入的字节数，否则返回一个负的错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vfs-write函数"><a href="#vfs-write函数" class="headerlink" title="vfs_write函数"></a>vfs_write函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/vfs_write">vfs_write identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">vfs_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123; <span class="comment">// 函数签名，接受四个参数：文件对象指针 file、用户空间缓冲区的指针 buf、要写入的字节数 count 和文件写入位置 pos 的指针</span></span><br><span class="line">    <span class="type">ssize_t</span> ret; <span class="comment">// 定义返回值变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITE))</span><br><span class="line">        <span class="keyword">return</span> -EBADF; <span class="comment">// 如果文件不可写，返回 -EBADF（错误的文件描述符）</span></span><br><span class="line">    <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL; <span class="comment">// 如果文件模式不允许写入，返回 -EINVAL（无效参数）</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!access_ok(buf, count)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT; <span class="comment">// 如果用户空间缓冲区不可访问，返回 -EFAULT（错误的地址）</span></span><br><span class="line"></span><br><span class="line">    ret = rw_verify_area(WRITE, file, pos, count); <span class="comment">// 验证写入请求是否合法，将结果赋给 ret</span></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 如果验证结果为非零值（错误），则返回该值</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; MAX_RW_COUNT)</span><br><span class="line">        count =  MAX_RW_COUNT; <span class="comment">// 如果要写入的字节数大于最大允许值，则限制写入字节数为最大允许值</span></span><br><span class="line"></span><br><span class="line">    file_start_write(file); <span class="comment">// 准备文件开始写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file-&gt;f_op-&gt;write)</span><br><span class="line">        ret = file-&gt;f_op-&gt;write(file, buf, count, pos); <span class="comment">// 如果定义了 write 函数，调用它进行实际的写操作，并将返回值赋给 ret</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;write_iter)</span><br><span class="line">        ret = new_sync_write(file, buf, count, pos); <span class="comment">// 否则，如果定义了 write_iter 函数，调用 new_sync_write 函数进行写操作，并将返回值赋给 ret</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = -EINVAL; <span class="comment">// 如果没有定义 write 或 write_iter 函数，返回 -EINVAL（无效参数）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果写操作成功（ret &gt; 0）</span></span><br><span class="line">        fsnotify_modify(file); <span class="comment">// 通知相关文件系统事件</span></span><br><span class="line">        add_wchar(current, ret); <span class="comment">// 更新当前进程的写入字符计数（增加 ret 个字符）</span></span><br><span class="line">    &#125;</span><br><span class="line">    inc_syscw(current); <span class="comment">// 增加当前进程的系统调用计数</span></span><br><span class="line"></span><br><span class="line">    file_end_write(file); <span class="comment">// 结束文件写入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回写操作的结果，如果成功则返回写入的字节数，否则返回一个负的错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="file-gt-f-op-gt-write-iter设置为generic-file-write-iter"><a href="#file-gt-f-op-gt-write-iter设置为generic-file-write-iter" class="headerlink" title="file-&gt;f_op-&gt;write_iter设置为generic_file_write_iter"></a>file-&gt;f_op-&gt;write_iter设置为generic_file_write_iter</h4><p>参考上文中的<code>file-&gt;f_op-&gt;read_iter设置为shmem_file_read_iter</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义shmem文件系统的文件操作结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shmem_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shmem_mmap, <span class="comment">// 映射文件到内存的操作</span></span><br><span class="line">    .open        = generic_file_open, <span class="comment">// 打开文件的通用操作</span></span><br><span class="line">    .get_unmapped_area = shmem_get_unmapped_area, <span class="comment">// 获取未映射区域的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">    .llseek        = shmem_file_llseek, <span class="comment">// 重定位文件读写指针的操作</span></span><br><span class="line">    .read_iter    = shmem_file_read_iter, <span class="comment">// 读取文件的操作</span></span><br><span class="line">    .write_iter    = generic_file_write_iter, <span class="comment">// 写入文件的通用操作</span></span><br><span class="line">    .fsync        = noop_fsync, <span class="comment">// 同步文件的空操作（因为shmem文件系统不需要同步）</span></span><br><span class="line">    .splice_read    = generic_file_splice_read, <span class="comment">// 从文件中读取并拼接数据的通用操作</span></span><br><span class="line">    .splice_write    = iter_file_splice_write, <span class="comment">// 向文件中拼接并写入数据的操作</span></span><br><span class="line">    .fallocate    = shmem_fallocate, <span class="comment">// 预分配文件空间的</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>write_iter</code>设置为<code>generic_file_write_iter</code></p>
<p>根据下面这段<code>vfs_write</code>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (file-&gt;f_op-&gt;write)</span><br><span class="line">    ret = file-&gt;f_op-&gt;write(file, buf, count, pos); <span class="comment">// 如果定义了 write 函数，调用它进行实际的写操作，并将返回值赋给 ret</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;write_iter)</span><br><span class="line">    ret = new_sync_write(file, buf, count, pos); <span class="comment">// 否则，如果定义了 write_iter 函数，调用 new_sync_write 函数进行写操作，并将返回值赋给 ret</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ret = -EINVAL; <span class="comment">// 如果没有定义 write 或 write_i</span></span><br></pre></td></tr></table></figure>

<p>因为<code>shmem_file_operation</code>没有设置<code>write</code>函数，所以下面进入<code>new_sync_write</code>函数</p>
<h4 id="new-sync-write函数"><a href="#new-sync-write函数" class="headerlink" title="new_sync_write函数"></a>new_sync_write函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/new_sync_write">new_sync_write identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">new_sync_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> len, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kiocb</span> <span class="title">kiocb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iov_iter</span> <span class="title">iter</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">    init_sync_kiocb(&amp;kiocb, filp);</span><br><span class="line">    kiocb.ki_pos = (ppos ? *ppos : <span class="number">0</span>);</span><br><span class="line">    iov_iter_ubuf(&amp;iter, ITER_SOURCE, (<span class="type">void</span> __user *)buf, len);</span><br><span class="line"></span><br><span class="line">    ret = call_write_iter(filp, &amp;kiocb, &amp;iter);</span><br><span class="line">    BUG_ON(ret == -EIOCBQUEUED);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span> &amp;&amp; ppos)</span><br><span class="line">        *ppos = kiocb.ki_pos;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="call-write-iter函数"><a href="#call-write-iter函数" class="headerlink" title="call_write_iter函数"></a>call_write_iter函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/call_write_iter">call_write_iter identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">call_write_iter</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> kiocb *kio,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> file-&gt;f_op-&gt;write_iter(kio, iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="generic-file-write-iter函数"><a href="#generic-file-write-iter函数" class="headerlink" title="generic_file_write_iter函数"></a>generic_file_write_iter函数</h4><p>  <a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/generic_file_write_iter">generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generic_file_write_iter - 将数据写入文件</span></span><br><span class="line"><span class="comment"> * @iocb:    IO 状态结构</span></span><br><span class="line"><span class="comment"> * @from:    带有要写入数据的 iov_iter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是一个用于大多数文件系统的 __generic_file_write_iter() 的封装。</span></span><br><span class="line"><span class="comment"> * 它负责在 O_SYNC 文件情况下同步文件，并根据需要获取 i_rwsem。</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> * * 如果没有写入任何数据或 vfs_fsync_range() 在同步写入时失败，则返回负错误代码</span></span><br><span class="line"><span class="comment"> * * 写入的字节数，即使是截断写入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_file_write_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp; <span class="comment">// 从 kiocb 获取文件指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file-&gt;f_mapping-&gt;host; <span class="comment">// 从文件的映射主机获取 inode</span></span><br><span class="line">    <span class="type">ssize_t</span> ret; <span class="comment">// 声明结果的返回变量</span></span><br><span class="line"></span><br><span class="line">    inode_lock(inode); <span class="comment">// 在写入之前锁定 inode</span></span><br><span class="line">    ret = generic_write_checks(iocb, from); <span class="comment">// 执行通用写入检查</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) <span class="comment">// 如果检查通过且允许写入</span></span><br><span class="line">        ret = __generic_file_write_iter(iocb, from); <span class="comment">// 调用实际的文件写入函数</span></span><br><span class="line">    inode_unlock(inode); <span class="comment">// 写入后解锁 inode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) <span class="comment">// 如果写入成功</span></span><br><span class="line">        ret = generic_write_sync(iocb, ret); <span class="comment">// 如果需要（例如，设置了 O_SYNC 标志），同步写入的数据</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回结果（写入的字节数或错误代码）</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(generic_file_write_iter);</span><br></pre></td></tr></table></figure>

<h4 id="generic-file-write-iter"><a href="#generic-file-write-iter" class="headerlink" title="__generic_file_write_iter"></a>__generic_file_write_iter</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/__generic_file_write_iter">__generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __generic_file_write_iter - 将数据写入文件</span></span><br><span class="line"><span class="comment"> * @iocb:    IO 状态结构（文件，偏移等）</span></span><br><span class="line"><span class="comment"> * @from:    带有要写入数据的 iov_iter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数完成实际将数据写入文件所需的所有工作。它执行所有基本检查，从文件中删除 SUID，</span></span><br><span class="line"><span class="comment"> * 更新修改时间，并根据我们执行直接 IO 还是标准缓冲写入来调用适当的子程序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 除非我们在块设备或类似不需要锁定的对象上工作，否则期望已获得 i_rwsem。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数*不*负责在 O_SYNC 写入时同步数据。调用者必须处理它。这主要是因为我们要</span></span><br><span class="line"><span class="comment"> * 避免在 i_rwsem 下进行同步。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> * * 写入的字节数，即使是截断的写入</span></span><br><span class="line"><span class="comment"> * * 如果没有写入任何数据，则为负错误代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> __generic_file_write_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp; <span class="comment">// 获取文件指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping; <span class="comment">// 获取文件的地址空间映射</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host; <span class="comment">// 获取映射主机的 inode</span></span><br><span class="line">    <span class="type">ssize_t</span>    written = <span class="number">0</span>; <span class="comment">// 初始化已写字节数为 0</span></span><br><span class="line">    <span class="type">ssize_t</span>    err; <span class="comment">// 错误变量</span></span><br><span class="line">    <span class="type">ssize_t</span>    status; <span class="comment">// 状态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们可以在页面回收中写回此队列</span></span><br><span class="line">    current-&gt;backing_dev_info = inode_to_bdi(inode);</span><br><span class="line">    err = file_remove_privs(file); <span class="comment">// 移除文件的特权</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = file_update_time(file); <span class="comment">// 更新文件时间</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123; <span class="comment">// 如果使用直接 IO</span></span><br><span class="line">        <span class="type">loff_t</span> pos, endbyte;</span><br><span class="line"></span><br><span class="line">        written = generic_file_direct_write(iocb, from); <span class="comment">// 执行直写</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果写入未完成，回退到缓冲写入。例如，某些文件系统对洞的写入就是这样。</span></span><br><span class="line"><span class="comment">         * 对于 DAX 文件，缓冲写入将无法成功（即使成功，DAX 也无法正确处理脏的</span></span><br><span class="line"><span class="comment">         * 页面缓存页面）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (written &lt; <span class="number">0</span> || !iov_iter_count(from) || IS_DAX(inode))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        pos = iocb-&gt;ki_pos;</span><br><span class="line">        status = generic_perform_write(iocb, from); <span class="comment">// 执行回写</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果 generic_perform_write() 返回了同步错误，则我们希望返回直接写入</span></span><br><span class="line"><span class="comment">         * 的字节数，或者如果为零，则返回错误代码。请注意，这与正常的直接 IO 语义</span></span><br><span class="line"><span class="comment">         * 不同，即使写入了一些字节，也会返回 -EFOO。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(status &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            err = status;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 我们需要确保页面缓存页面被写入磁盘并失效，以保留预期的 O_DIRECT 语义。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        endbyte = pos + status - <span class="number">1</span>;</span><br><span class="line">        err = filemap_write_and_wait_range(mapping, pos, endbyte);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;</span><br><span class="line">            iocb-&gt;ki_pos = endbyte + <span class="number">1</span>;</span><br><span class="line">            written += status;</span><br><span class="line">            invalidate_mapping_pages(mapping,</span><br><span class="line">                         pos &gt;&gt; PAGE_SHIFT,</span><br><span class="line">                         endbyte &gt;&gt; PAGE_SHIFT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 我们不知道写了多少，所以只返回直接写入的字节数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        written = generic_perform_write(iocb, from); <span class="comment">// 执行回写</span></span><br><span class="line">        <span class="keyword">if</span> (likely(written &gt; <span class="number">0</span>))</span><br><span class="line">            iocb-&gt;ki_pos += written;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    current-&gt;backing_dev_info = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> written ? written : err;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__generic_file_write_iter);</span><br></pre></td></tr></table></figure>

<h4 id="generic-file-direct-write函数"><a href="#generic-file-direct-write函数" class="headerlink" title="generic_file_direct_write函数"></a>generic_file_direct_write函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/generic_file_direct_write">generic_file_direct_write identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span>  </span><br><span class="line"><span class="title function_">generic_file_direct_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp;  <span class="comment">//获取文件对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;   <span class="comment">//获取地址空间    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;  <span class="comment">//获取索引节点对象 </span></span><br><span class="line">    <span class="type">loff_t</span> pos = iocb-&gt;ki_pos;  <span class="comment">//获取写入位置      </span></span><br><span class="line">    <span class="type">ssize_t</span> written;  </span><br><span class="line">    <span class="type">size_t</span> write_len;  </span><br><span class="line">    <span class="type">pgoff_t</span> end;  </span><br><span class="line"></span><br><span class="line">    write_len = iov_iter_count(from);  <span class="comment">//获取要写入的数据长度  </span></span><br><span class="line">    end = (pos + write_len - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;   <span class="comment">//计算结束页号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123;   <span class="comment">//如果是非阻塞IO   </span></span><br><span class="line">        <span class="comment">/* 如果有要写回的页面,返回 */</span>    </span><br><span class="line">        <span class="keyword">if</span> (filemap_range_has_page(file-&gt;f_mapping, pos,   <span class="comment">//判断范围内是否有页面  </span></span><br><span class="line">                       pos + write_len - <span class="number">1</span>))  </span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        written = filemap_write_and_wait_range(mapping, pos,   <span class="comment">//同步文件范围内的页面</span></span><br><span class="line">                            pos + write_len - <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">if</span> (written)  </span><br><span class="line">            <span class="keyword">goto</span> out;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * 在写入后,我们希望缓冲读取确实去磁盘获取  </span></span><br><span class="line"><span class="comment">     * 新数据。我们失效要写入区域的干净缓存页面。  </span></span><br><span class="line"><span class="comment">     * 我们在写入之前这样做,*之前*我们可以不破坏  </span></span><br><span class="line"><span class="comment">     * -&gt;direct_IO()返回的-EIOCBQUEUED。  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    written = invalidate_inode_pages2_range(mapping,   <span class="comment">//失效页面范围 </span></span><br><span class="line">                    pos &gt;&gt; PAGE_SHIFT, end);   </span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * 如果无法使页面无效,返回0以回退  </span></span><br><span class="line"><span class="comment">     * 到缓冲写入。  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">if</span> (written) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (written == -EBUSY)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">goto</span> out;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    written = mapping-&gt;a_ops-&gt;direct_IO(iocb, from);  <span class="comment">//执行direct IO写入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  </span></span><br><span class="line"><span class="comment">     * 最后,再试一次使干净页面无效,这些页面可能  </span></span><br><span class="line"><span class="comment">     * 被非直接读前读入高速缓存,或者如果写的源  </span></span><br><span class="line"><span class="comment">     * 是文件的映射区域,则可能由get_user_pages()引起故障。  </span></span><br><span class="line"><span class="comment">     * 其中任何一个都是相当疯狂的事情要做,  </span></span><br><span class="line"><span class="comment">     * 所以我们不完全支持它。如果此无效化  </span></span><br><span class="line"><span class="comment">     * 失败,那还行,写入仍然有效...  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 大多数时候我们不需要这么做,因为dio_complete()  </span></span><br><span class="line"><span class="comment">     * 会为我们做无效化。然而,有一些文件系统  </span></span><br><span class="line"><span class="comment">     * 最终不会调用dio_complete(),所以不要通过  </span></span><br><span class="line"><span class="comment">     * 完全删除它来破坏它们。  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 显著的例子是blkdev_direct_IO()。  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * 跳过异步写入的无效化或如果映射没有页面。  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">if</span> (written &gt; <span class="number">0</span> &amp;&amp; mapping-&gt;nrpages &amp;&amp;  </span><br><span class="line">        invalidate_inode_pages2_range(mapping, pos &gt;&gt; PAGE_SHIFT, end))  </span><br><span class="line">        dio_warn_stale_pagecache(file);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (written &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        pos += written;  <span class="comment">//更新写入位置 </span></span><br><span class="line">        write_len -= written;  </span><br><span class="line">        <span class="keyword">if</span> (pos &gt; i_size_read(inode) &amp;&amp; !S_ISBLK(inode-&gt;i_mode)) &#123;  <span class="comment">//更新文件大小</span></span><br><span class="line">            i_size_write(inode, pos);  </span><br><span class="line">            mark_inode_dirty(inode);  </span><br><span class="line">        &#125;  </span><br><span class="line">        iocb-&gt;ki_pos = pos;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (written != -EIOCBQUEUED)  </span><br><span class="line">        iov_iter_revert(from, write_len - iov_iter_count(from));  </span><br><span class="line">out:  </span><br><span class="line">    <span class="keyword">return</span> written;  </span><br><span class="line">&#125;  </span><br><span class="line">EXPORT_SYMBOL(generic_file_direct_write);</span><br></pre></td></tr></table></figure>

<h4 id="generic-perform-write函数"><a href="#generic-perform-write函数" class="headerlink" title="generic_perform_write函数"></a>generic_perform_write函数</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/generic_perform_write">generic_perform_write identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_perform_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp;  <span class="comment">//获取文件对象</span></span><br><span class="line">    <span class="type">loff_t</span> pos = iocb-&gt;ki_pos;  <span class="comment">//获取写入位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;  <span class="comment">//获取地址空间</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span> =</span> mapping-&gt;a_ops;  <span class="comment">//获取地址空间操作</span></span><br><span class="line">    <span class="type">long</span> status = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">ssize_t</span> written = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> offset;    <span class="comment">/* Offset into pagecache page */</span>  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bytes;    <span class="comment">/* Bytes to write to page */</span>  </span><br><span class="line">        <span class="type">size_t</span> copied;        <span class="comment">/* Bytes copied from user */</span>  </span><br><span class="line">        <span class="type">void</span> *fsdata = <span class="literal">NULL</span>;  </span><br><span class="line"></span><br><span class="line">        offset = (pos &amp; (PAGE_SIZE - <span class="number">1</span>));  </span><br><span class="line">        bytes = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, PAGE_SIZE - offset,  <span class="comment">//计算本次要写入的字节数</span></span><br><span class="line">                        iov_iter_count(i));</span><br><span class="line"></span><br><span class="line">again:  </span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         * 首先带入用户页面,我们要从中复制。  </span></span><br><span class="line"><span class="comment">         * 否则,如果未将其标记为最新,则会出现从  </span></span><br><span class="line"><span class="comment">         * 同一页面复制和写入的可怕死锁。  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="keyword">if</span> (unlikely(fault_in_iov_iter_readable(i, bytes) == bytes)) &#123;  </span><br><span class="line">            status = -EFAULT;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fatal_signal_pending(current)) &#123;  </span><br><span class="line">            status = -EINTR;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        status = a_ops-&gt;write_begin(file, mapping, pos, bytes,   <span class="comment">//执行写开始</span></span><br><span class="line">                        &amp;page, &amp;fsdata);  </span><br><span class="line">        <span class="keyword">if</span> (unlikely(status &lt; <span class="number">0</span>))  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mapping_writably_mapped(mapping))   <span class="comment">//刷新页高速缓存  </span></span><br><span class="line">            flush_dcache_page(page);  </span><br><span class="line"></span><br><span class="line">        copied = copy_page_from_iter_atomic(page, offset, bytes, i);  <span class="comment">//从迭代器复制数据到页面</span></span><br><span class="line">        flush_dcache_page(page);  </span><br><span class="line"></span><br><span class="line">        status = a_ops-&gt;write_end(file, mapping, pos, bytes, copied,  <span class="comment">//执行写结束  </span></span><br><span class="line">                        page, fsdata);  </span><br><span class="line">        <span class="keyword">if</span> (unlikely(status != copied)) &#123;  </span><br><span class="line">            iov_iter_revert(i, copied - max(status, <span class="number">0L</span>));  </span><br><span class="line">            <span class="keyword">if</span> (unlikely(status &lt; <span class="number">0</span>))  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        cond_resched();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(status == <span class="number">0</span>)) &#123;  </span><br><span class="line">            <span class="comment">/*  </span></span><br><span class="line"><span class="comment">             * 短复制导致-&gt;write_end()完全拒绝  </span></span><br><span class="line"><span class="comment">             * 该事物。可能是中途的内存中毒,可能与munmap的竞争,  </span></span><br><span class="line"><span class="comment">             * 可能是严重的内存压力。  </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">            <span class="keyword">if</span> (copied)  </span><br><span class="line">                bytes = copied;  </span><br><span class="line">            <span class="keyword">goto</span> again;  </span><br><span class="line">        &#125;  </span><br><span class="line">        pos += status;  <span class="comment">//更新写入位置  </span></span><br><span class="line">        written += status;  </span><br><span class="line"></span><br><span class="line">        balance_dirty_pages_ratelimited(mapping);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (iov_iter_count(i));  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> written ? written : status;  </span><br><span class="line">&#125;  </span><br><span class="line">EXPORT_SYMBOL(generic_perform_write);</span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><h3 id="unlink系统调用"><a href="#unlink系统调用" class="headerlink" title="unlink系统调用"></a>unlink系统调用</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/sys_unlink">sys_unlink identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> SYSCALL_DEFINE1(unlink, <span class="type">const</span> <span class="type">char</span> __user *, pathname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_unlinkat(AT_FDCWD, getname(pathname));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="do-unlinkat函数"><a href="#do-unlinkat函数" class="headerlink" title="do_unlinkat函数"></a>do_unlinkat函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/do_unlinkat">do_unlinkat identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确保文件的实际截断发生在其目录的 i_mutex 外部。</span></span><br><span class="line"><span class="comment"> * 如果发生大量写出，截断可能需要很长时间，</span></span><br><span class="line"><span class="comment"> * 我们不希望在等待 I/O 时阻止对目录的访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_unlinkat</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error; <span class="comment">// 错误码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 目录项指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 路径结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span> <span class="comment">// 最后一个路径组件的字符串</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 路径类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 文件 inode 指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 委托 inode 指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = <span class="number">0</span>; <span class="comment">// 查找标志</span></span><br><span class="line">retry: <span class="comment">// 重试标签</span></span><br><span class="line">    error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); <span class="comment">// 获取父目录</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> exit1; <span class="comment">// 如果出错，跳转到 exit1</span></span><br><span class="line"></span><br><span class="line">    error = -EISDIR; <span class="comment">// 设置错误码为 -EISDIR（是一个目录）</span></span><br><span class="line">    <span class="keyword">if</span> (type != LAST_NORM) <span class="comment">// 如果类型不是 LAST_NORM</span></span><br><span class="line">        <span class="keyword">goto</span> exit2; <span class="comment">// 跳转到 exit2</span></span><br><span class="line"></span><br><span class="line">    error = mnt_want_write(path.mnt); <span class="comment">// 检查是否允许写入</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> exit2; <span class="comment">// 如果出错，跳转到 exit2</span></span><br><span class="line">retry_deleg: <span class="comment">// 重试委托标签</span></span><br><span class="line">    inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); <span class="comment">// 对父目录进行加锁</span></span><br><span class="line">    dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); <span class="comment">// 查找目录项</span></span><br><span class="line">    error = PTR_ERR(dentry); <span class="comment">// 获取错误码</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(dentry)) &#123; <span class="comment">// 如果没有错误</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为什么要放在这里？因为我们需要正确的错误值</span></span><br><span class="line">        <span class="keyword">if</span> (last.name[last.len])</span><br><span class="line">            <span class="keyword">goto</span> slashes; <span class="comment">// 如果 last.name[last.len] 不为 0，跳转到 slashes</span></span><br><span class="line">        inode = dentry-&gt;d_inode; <span class="comment">// 获取文件的 inode</span></span><br><span class="line">        <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">            <span class="keyword">goto</span> slashes; <span class="comment">// 如果目录项是负的，跳转到 slashes</span></span><br><span class="line">        ihold(inode); <span class="comment">// 增加 inode 引用计数</span></span><br><span class="line">        error = security_path_unlink(&amp;path, dentry); <span class="comment">// 检查安全策略</span></span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> exit3; <span class="comment">// 如果出错，跳转到 exit3</span></span><br><span class="line">        error = vfs_unlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode,</span><br><span class="line">                           dentry, &amp;delegated_inode); <span class="comment">// 删除文件链接</span></span><br><span class="line">exit3:</span><br><span class="line">        dput(dentry); <span class="comment">// 释放目录项</span></span><br><span class="line">    &#125;</span><br><span class="line">    inode_unlock(path.dentry-&gt;d_inode); <span class="comment">// 解锁父目录</span></span><br><span class="line">    <span class="keyword">if</span> (inode)</span><br><span class="line">        iput(inode); <span class="comment">// 如果 inode 存在，截断 inode</span></span><br><span class="line">    inode = <span class="literal">NULL</span>; <span class="comment">// 将 inode 置为空</span></span><br><span class="line">    <span class="keyword">if</span> (delegated_inode) &#123; <span class="comment">// 如果委托 inode 存在</span></span><br><span class="line">        error = break_deleg_wait(&amp;delegated_inode); <span class="comment">// 等待委托中断</span></span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            <span class="keyword">goto</span> retry_deleg; <span class="comment">// 如果没有错误，跳转到 retry_deleg</span></span><br><span class="line">    &#125;</span><br><span class="line">    mnt_drop_write(path.mnt); <span class="comment">// 放弃写权限</span></span><br><span class="line">exit2:</span><br><span class="line">    path_put(&amp;path); <span class="comment">// 释放路径</span></span><br><span class="line">    <span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123; <span class="comment">// 如果需要重试</span></span><br><span class="line">        lookup_flags |= LOOKUP_REVAL; <span class="comment">// 更新查找标志</span></span><br><span class="line">        inode = <span class="literal">NULL</span>; <span class="comment">// 将 inode 置为空</span></span><br><span class="line">        <span class="keyword">goto</span> retry; <span class="comment">// 跳转到 retry</span></span><br><span class="line">    &#125;</span><br><span class="line">exit1:</span><br><span class="line">    putname(name); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line"></span><br><span class="line">slashes: <span class="comment">// slashes 标签</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry)) <span class="comment">// 如果目录项是负的</span></span><br><span class="line">        error = -ENOENT; <span class="comment">// 错误码设置为 -ENOENT（文件不存在）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d_is_dir(dentry)) <span class="comment">// 如果目录项是目录</span></span><br><span class="line">        error = -EISDIR; <span class="comment">// 错误码设置为 -EISDIR（是一个目录）</span></span><br><span class="line">    <span class="keyword">else</span>        error = -ENOTDIR; <span class="comment">// 错误码设置为 -ENOTDIR（不是一个目录）</span></span><br><span class="line">    <span class="keyword">goto</span> exit3; <span class="comment">// 跳转到 exit3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vfs-unlink函数"><a href="#vfs-unlink函数" class="headerlink" title="vfs_unlink函数"></a>vfs_unlink函数</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.7/C/ident/vfs_unlink">vfs_unlink identifier - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_unlink - 删除文件系统对象的链接</span></span><br><span class="line"><span class="comment"> * @idmap:    挂载点的 idmap</span></span><br><span class="line"><span class="comment"> * @dir:    父目录</span></span><br><span class="line"><span class="comment"> * @dentry:    受害者</span></span><br><span class="line"><span class="comment"> * @delegated_inode: 如果 inode 被委托，返回受害者 inode。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者必须持有 dir-&gt;i_mutex。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 vfs_unlink 发现一个委托，它将返回 -EWOULDBLOCK，并</span></span><br><span class="line"><span class="comment"> * 在 delegated_inode 中返回对 inode 的引用。调用者</span></span><br><span class="line"><span class="comment"> * 应该在那个 inode 上中断委托并重试。因为</span></span><br><span class="line"><span class="comment"> * 中断委托可能需要很长时间，调用者在执行此操作之前应放弃</span></span><br><span class="line"><span class="comment"> * dir-&gt;i_mutex。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者，调用者可以为 delegated_inode 传递 NULL。这可能</span></span><br><span class="line"><span class="comment"> * 适用于期望底层文件系统不是 NFS 导出的调用者。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过 idmapped 挂载找到了 inode，则必须通过 @idmap 传递 vfsmount 的 idmap。</span></span><br><span class="line"><span class="comment"> * 该函数将在检查权限之前根据 @idmap 映射 inode。</span></span><br><span class="line"><span class="comment"> * 在非 idmapped 挂载上或者对原始 inode 执行权限检查，只需传递 @nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unlink</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode **delegated_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">target</span> =</span> dentry-&gt;d_inode; <span class="comment">// 目标 inode</span></span><br><span class="line">    <span class="type">int</span> error = may_delete(idmap, dir, dentry, <span class="number">0</span>); <span class="comment">// 检查是否可以删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error) <span class="comment">// 如果有错误</span></span><br><span class="line">        <span class="keyword">return</span> error; <span class="comment">// 返回错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;unlink) <span class="comment">// 如果没有提供 unlink 操作</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM; <span class="comment">// 返回 -EPERM（不允许的操作）</span></span><br><span class="line"></span><br><span class="line">    inode_lock(target); <span class="comment">// 锁定目标 inode</span></span><br><span class="line">    <span class="keyword">if</span> (IS_SWAPFILE(target)) <span class="comment">// 如果目标是交换文件</span></span><br><span class="line">        error = -EPERM; <span class="comment">// 返回 -EPERM（不允许的操作）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_local_mountpoint(dentry)) <span class="comment">// 如果 dentry 是本地挂载点</span></span><br><span class="line">        error = -EBUSY; <span class="comment">// 返回 -EBUSY（设备或资源忙）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        error = security_inode_unlink(dir, dentry); <span class="comment">// 检查安全策略</span></span><br><span class="line">        <span class="keyword">if</span> (!error) &#123; <span class="comment">// 如果没有错误</span></span><br><span class="line">            error = try_break_deleg(target, delegated_inode); <span class="comment">// 尝试中断委托</span></span><br><span class="line">            <span class="keyword">if</span> (error) <span class="comment">// 如果有错误</span></span><br><span class="line">                <span class="keyword">goto</span> out; <span class="comment">// 跳转到 out</span></span><br><span class="line">            error = dir-&gt;i_op-&gt;unlink(dir, dentry); <span class="comment">// 执行 unlink 操作</span></span><br><span class="line">            <span class="keyword">if</span> (!error) &#123; <span class="comment">// 如果没有错误</span></span><br><span class="line">                dont_mount(dentry); <span class="comment">// 不要挂载 dentry</span></span><br><span class="line">                detach_mounts(dentry); <span class="comment">// 分离挂载点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out: <span class="comment">// out 标签</span></span><br><span class="line">    inode_unlock(target); <span class="comment">// 解锁目标 inode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不删除 NFS sillyrenamed 文件的 d_delete() - 它们仍然存在。</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; dentry-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) &#123;</span><br><span class="line">        fsnotify_unlink(dir, dentry); <span class="comment">// 发送文件系统通知</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        fsnotify_link_count(target); <span class="comment">// 更新链接计数</span></span><br><span class="line">        d_delete_notify(dir, dentry); <span class="comment">// 发送删除通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_unlink);</span><br></pre></td></tr></table></figure>

<h3 id="dir-gt-i-op-gt-unlink设置为shmem-unlink函数"><a href="#dir-gt-i-op-gt-unlink设置为shmem-unlink函数" class="headerlink" title="dir-&gt;i_op-&gt;unlink设置为shmem_unlink函数"></a>dir-&gt;i_op-&gt;unlink设置为shmem_unlink函数</h3><p> 参考上文中的<code>inode-&gt;i_op-&gt;lookup函数指向 simple_lookup() 函数</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">shmem_dir_inode_operations</span> =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">    .getattr    = shmem_getattr,</span><br><span class="line">    .create        = shmem_create,</span><br><span class="line">    .lookup        = simple_lookup,<span class="comment">//这里定义了lookup函数</span></span><br><span class="line">    .link        = shmem_link,</span><br><span class="line">    .unlink        = shmem_unlink,<span class="comment">//这里定义了unlink函数</span></span><br><span class="line">    .symlink    = shmem_symlink,</span><br><span class="line">    .mkdir        = shmem_mkdir,</span><br><span class="line">    .rmdir        = shmem_rmdir,</span><br><span class="line">    .mknod        = shmem_mknod,</span><br><span class="line">    .rename        = shmem_rename2,</span><br><span class="line">    .tmpfile    = shmem_tmpfile,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_XATTR</span></span><br><span class="line">    .listxattr    = shmem_listxattr,</span><br><span class="line">    .fileattr_get    = shmem_fileattr_get,</span><br><span class="line">    .fileattr_set    = shmem_fileattr_set,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS_POSIX_ACL</span></span><br><span class="line">    .setattr    = shmem_setattr,</span><br><span class="line">    .set_acl    = simple_set_acl,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_unlink">shmem_unlink identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_unlink</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> d_inode(dentry); <span class="comment">// 获取 dentry 对应的 inode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 inode 的链接数大于 1 且 inode 不是目录，则释放 inode</span></span><br><span class="line">    <span class="keyword">if</span> (inode-&gt;i_nlink &gt; <span class="number">1</span> &amp;&amp; !S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">        shmem_free_inode(inode-&gt;i_sb);</span><br><span class="line"></span><br><span class="line">    dir-&gt;i_size -= BOGO_DIRENT_SIZE; <span class="comment">// 减小父目录的大小</span></span><br><span class="line">    <span class="comment">// 更新 inode 和父目录的 ctime 和 mtime 为当前时间</span></span><br><span class="line">    inode-&gt;i_ctime = dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(inode);</span><br><span class="line">    inode_inc_iversion(dir); <span class="comment">// 增加父目录的 i_version</span></span><br><span class="line">    drop_nlink(inode); <span class="comment">// 减少 inode 的链接数</span></span><br><span class="line">    dput(dentry); <span class="comment">// 撤销 &quot;create&quot; 操作的计数，完成所有工作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0，表示成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://www.kernel.org/doc/html/latest/filesystems/tmpfs.html">Tmpfs — The Linux Kernel documentation — Tmpfs — Linux 内核文档</a></p>
</li>
<li><p><a href="https://zh.wikipedia.org/zh-cn/Tmpfs">tmpfs - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
</li>
<li><p><a href="https://wiki.archlinux.org/title/Tmpfs">tmpfs - ArchWiki (archlinux.org)</a></p>
</li>
<li><p><code>GPT-4</code></p>
</li>
<li><p><a href="https://ty-chen.github.io/linux-kernel-vfs/">Linux操作系统学习笔记（十二）虚拟文件系统 | Ty-Chen’s Home</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C++ 学习 Linux系统编程 GCC</title>
    <url>/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GCC/</url>
    <content><![CDATA[<h1 id="什么是GCC"><a href="#什么是GCC" class="headerlink" title="什么是GCC"></a>什么是GCC</h1><ul>
<li><p>GCC 原名为 GNU C语言编译器（GNU C Compiler）</p>
</li>
<li><p>GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言<br>译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前<br>端，也包括了这些语言的库（如 libstdc++，libgcj等）</p>
</li>
<li><p>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行<br>选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数<br><code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。</p>
</li>
<li><p>安装命令 <code>sudo apt install gcc g++ </code>（版本 &gt; 4.8.5）</p>
</li>
<li><p>查看版本<code> gcc/g++ -v/--version</code></p>
</li>
</ul>
<h1 id="GCC工作流程"><a href="#GCC工作流程" class="headerlink" title="GCC工作流程"></a>GCC工作流程</h1><img src="/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GCC/GCC工作流程.png" title alt data-align="center">

<h1 id="GCC和G-的区别"><a href="#GCC和G-的区别" class="headerlink" title="GCC和G++的区别"></a>GCC和G++的区别</h1><ul>
<li><p>gcc 和 g++都是GNU(组织)的一个编译器。</p>
</li>
<li><p>误区一：gcc 只能编译 c 代码，g++ 只能编译 c++ 代码。两者都可以，请注意：</p>
<ul>
<li><p>后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序</p>
</li>
<li><p>后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些</p>
</li>
<li><p>编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统一起见，干脆编译&#x2F;链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的</p>
</li>
</ul>
</li>
<li><p>误区二：gcc 不会定义 __cplusplus 宏，而 g++ 会</p>
<ul>
<li><p>实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释</p>
</li>
<li><p>如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义</p>
</li>
</ul>
</li>
<li><p>误区三：编译只能用 gcc，链接只能用 g++</p>
<ul>
<li><p>严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以gcc&#x2F;g++，而链接可以用 g++ 或者 gcc -lstdc++。</p>
</li>
<li><p>gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。但在编译阶段，g++ 会自动调用 gcc，二者等价</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
  </entry>
  <entry>
    <title>学习 Linux VFS虚拟文件系统</title>
    <url>/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>虚拟文件系统 （VFS） 或虚拟文件系统交换机是更具体的文件系统之上的抽象层。VFS 的目的是允许客户端应用程序以统一的方式访问不同类型的具体文件系统。例如，<mark>VFS 可用于透明地访问本地和网络存储设备，而客户端应用程序不会注意到差异。</mark> 即对于应用程序透明。它可用于弥Windows，经典Mac OS &#x2F; macOS和Unix文件系统之间的差异，以便应用程序可以访问这些类型的本地文件系统上的文件，而不必知道它们正在访问的文件系统类型。</p>
<p><mark>VFS 指定内核和具体文件系统之间的接口（或“协定”）。</mark>因此，只需履行协定即可轻松地向内核添加对新文件系统类型的支持。</p>
<p><strong>为了让添加新的文件系统更加容易，并且提供一个通用（generic）的文件API，VFS，一个虚拟文件系统层被加到了linux内核中。</strong> 而对于EXT2这样的真实（real）文件系统，是去调用VFS API的。新的文件系统和新类型的存储介质都能找到进入Linux之路，程序无需重写，甚至无需重新编译。</p>
<ul>
<li><p>在同一个目录结构中, 可以挂载着若干种不同的文件系统. VFS隐藏了它们的实现细节, 为使用者提供统一的接口;</p>
</li>
<li><p>目录结构本身并不是绝对的, 每个进程可能会看到不一样的目录结构. 目录结构是由”地址空间(namespace)”来描述的, 不同的进程可能拥有不同的namespace, 不同的namespace可能有着不同的目录结构(因为它们可能挂载了不同的文件系统)。</p>
</li>
</ul>
<h1 id="VFS层次结构"><a href="#VFS层次结构" class="headerlink" title="VFS层次结构"></a>VFS层次结构</h1><p>操作文件的本质是将磁盘文件数据映射到进程中。在这个过程中，涉及以下几个关键步骤：</p>
<ol>
<li><p><strong>进程发出文件操作命令</strong>：<br>当一个进程需要操作文件时，它会通过系统调用（如<code>sys_open</code>，<code>sys_read</code>，<code>sys_write</code>等）将请求传递给内核。系统调用是用户态进程与内核态代码之间的接口，用户态进程不能直接访问内核态资源，因此通过系统调用请求内核完成相应的操作。</p>
</li>
<li><p><strong>内核数据结构的创建和维护</strong>：<br>当内核收到进程的文件操作请求后，会为进程打开的文件和系统文件创建相应的数据结构。主要的数据结构包括：</p>
<ul>
<li>文件描述符（file descriptor）：一个非负整数，用于唯一标识进程中打开的文件。</li>
<li>文件对象（file object）：在内核中，文件对象与文件描述符关联，存储文件的元数据（如文件位置、访问权限等）。</li>
<li>inode：表示文件在磁盘上的元数据，包括文件类型、大小、权限、时间戳等。</li>
<li>dentry：缓存目录项的数据结构，用于快速查找文件系统中的文件。</li>
</ul>
</li>
<li><p><strong>虚拟文件系统（VFS）</strong>：<br>虚拟文件系统是一种<mark>文件系统抽象层</mark>，用于统一不同类型的文件系统和I&#x2F;O设备（如磁盘、管道、进程间通信、网络等）的接口。通过VFS，内核可以在不同的文件系统和设备之间提供统一的文件操作接口。</p>
</li>
<li><p><strong>实现虚拟文件系统和实际文件系统的挂载</strong>：<br>在VFS层之下，还有诸如ext4、FAT32等各种具体的文件系统实现。这些文件系统通过实现VFS定义的接口与VFS层进行交互。当一个文件系统被挂载到操作系统时，VFS会将文件系统的相关操作映射到对应的实现。</p>
</li>
<li><p><strong>设备驱动接口和缓存</strong>：<br>为了与不同类型的硬件设备进行交互，内核提供了设备驱动接口。设备驱动程序负责将文件系统的操作转换为特定硬件设备可以识别的指令。此外，内核还通过缓存技术来加快文件读写的速度。常见的缓存方式有页缓存（page cache）和缓冲区缓存（buffer cache）。</p>
</li>
</ol>
<img src="/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/VFS基本结构.png" title alt data-align="center">

<p>通用文件模型由对象组成：<strong>超级块对象、索引节点对象、目录项对象、文件对象。</strong></p>
<img src="/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/VFS整体层次.png" title alt data-align="center">

<h1 id="VFS实现"><a href="#VFS实现" class="headerlink" title="VFS实现"></a>VFS实现</h1><h2 id="VFS数据结构"><a href="#VFS数据结构" class="headerlink" title="VFS数据结构"></a>VFS数据结构</h2><p>三个不同进程已打开同一个文件，其中两个进程使用同一个硬链接。在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引节点对象，这个索引节点对象标识的是超级块对象以及普通磁盘文件。</p>
<img src="/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/VFS与进程交互.png" title alt data-align="center">

<p>VFS除了能为所有文件系统的实现提供一个通用接口外，它还具有另一个重要的作用，即提高系统性能。最近最常使用的目录项对象被放在所谓目录项高速缓存（dentry cache）的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。</p>
<p>inode是内核选择用于表示文件内容和相关元数据的方法。理论上，实现这个概念只需要一个数据结构（尽管很长），其中包含了所有必要的数据。实际上，数据分散到一系列较小的、布局清晰的结构中。</p>
<img src="/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/各个VFS组件的相互关系.png" title alt data-align="center">

<h3 id="超级块super-block"><a href="#超级块super-block" class="headerlink" title="超级块super_block"></a>超级块super_block</h3><p>存放系统当中已安装文件系统有关信息。对于基于磁盘的文件系统，这类对象通常对应存放在磁盘上的文件系统控制块（每个文件系统都有一个超级块对象）。</p>
<p>是一个全局的数据结构，不管是什么文件系统都有超级块。VFS也有超级块。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/source/include/linux/fs.h#L1136">fs.h - include&#x2F;linux&#x2F;fs.h - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> &#123;</span></span><br><span class="line"><span class="comment">//文件系统的整体信息成员如下：</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_list</span>;</span>        <span class="comment">/* Keep this first */</span> <span class="comment">//用来将所有超级块实例连接到全局链表super_blocks,指向超级快链表的指针</span></span><br><span class="line">    <span class="type">dev_t</span>            s_dev;        <span class="comment">/* search index; _not_ kdev_t */</span>  <span class="comment">//保存文件系统所在的块设备，s_dev保存设备具体文件系统的块设备标识符：/dev/hda1等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>        s_blocksize_bits; <span class="comment">//块大小的值所占用的位数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        s_blocksize; <span class="comment">//文件系统中数据库的大小，以字节为单位</span></span><br><span class="line">    <span class="type">loff_t</span>            s_maxbytes;    <span class="comment">/* Max file size */</span> <span class="comment">//文件最大长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span>    *<span class="title">s_type</span>;</span> <span class="comment">//指向文件系统类型file_system_type数据结构的指针</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span>    *<span class="title">s_op</span>;</span> <span class="comment">//指向特定文件系统用于超级快的函数的集合</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dquot_operations</span>    *<span class="title">dq_op</span>;</span> <span class="comment">//指向特定文件系统用于限额操作的函数集合</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">quotactl_ops</span>    *<span class="title">s_qcop</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">export_operations</span> *<span class="title">s_export_op</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        s_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        s_iflags;    <span class="comment">/* internal SB_I_* flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        s_magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>        *<span class="title">s_root</span>;</span> <span class="comment">//指向根目录的结构体dentry，将超级块与全局根目录的dentry项关联起来</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>    <span class="title">s_umount</span>;</span> <span class="comment">//对超级快读写时进行同步</span></span><br><span class="line">    <span class="type">int</span>            s_count; <span class="comment">//对超级快的使用计数</span></span><br><span class="line">    <span class="type">atomic_t</span>        s_active;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>                    *s_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">xattr_handler</span> **<span class="title">s_xattr</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_operations</span>    *<span class="title">s_cop</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_keyring</span>    *<span class="title">s_master_keys</span>;</span> <span class="comment">/* master crypto keys in use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fsverity_operations</span> *<span class="title">s_vop</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_UNICODE)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">unicode_map</span> *<span class="title">s_encoding</span>;</span></span><br><span class="line">    __u16 s_encoding_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span>    <span class="title">s_roots</span>;</span>    <span class="comment">/* alternate root dentries for NFS */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_mounts</span>;</span>    <span class="comment">/* list of mounts; _not_ for fs use */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span>    *<span class="title">s_bdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">s_bdi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span>        *<span class="title">s_mtd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">s_instances</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        s_quota_types;    <span class="comment">/* Bitmask of supported quota types */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quota_info</span>    <span class="title">s_dquot</span>;</span>    <span class="comment">/* Diskquota specific options */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sb_writers</span>    <span class="title">s_writers</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and</span></span><br><span class="line"><span class="comment">     * s_fsnotify_marks together for cache efficiency. They are frequently</span></span><br><span class="line"><span class="comment">     * accessed and rarely modified.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span>            *s_fs_info;    <span class="comment">/* Filesystem private info */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Granularity of c/m/atime in ns (cannot be worse than a second) */</span></span><br><span class="line">    u32            s_time_gran;</span><br><span class="line">    <span class="comment">/* Time limits for c/m/atime in seconds */</span></span><br><span class="line">    <span class="type">time64_t</span>           s_time_min;</span><br><span class="line">    <span class="type">time64_t</span>           s_time_max;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    __u32            s_fsnotify_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>    *<span class="title">s_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>            s_id[<span class="number">32</span>];    <span class="comment">/* Informational name */</span></span><br><span class="line">    <span class="type">uuid_t</span>            s_uuid;        <span class="comment">/* UUID */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        s_max_links;</span><br><span class="line">    <span class="type">fmode_t</span>            s_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The next field is for VFS *only*. No filesystems have any business</span></span><br><span class="line"><span class="comment">     * even looking at it. You had been warned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">s_vfs_rename_mutex</span>;</span>    <span class="comment">/* Kludge */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Filesystem subtype.  If non-empty the filesystem type field</span></span><br><span class="line"><span class="comment">     * in /proc/mounts will be &quot;type.subtype&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s_subtype;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">s_d_op</span>;</span> <span class="comment">/* default d_op for dentries */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">s_shrink</span>;</span>    <span class="comment">/* per-sb shrinker handle */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of inodes with nlink == 0 but still referenced */</span></span><br><span class="line">    <span class="type">atomic_long_t</span> s_remove_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Number of inode/mount/sb objects that are being watched, note that</span></span><br><span class="line"><span class="comment">     * inodes objects are currently double-accounted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">atomic_long_t</span> s_fsnotify_connectors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Being remounted read-only */</span></span><br><span class="line">    <span class="type">int</span> s_readonly_remount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* per-sb errseq_t for reporting writeback errors via syncfs */</span></span><br><span class="line">    <span class="type">errseq_t</span> s_wb_err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AIO completions deferred from interrupt context */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">s_dio_done_wq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">s_pins</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Owning user namespace and default context in which to</span></span><br><span class="line"><span class="comment">     * interpret filesystem uids, gids, quotas, device nodes,</span></span><br><span class="line"><span class="comment">     * xattrs and security labels.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">s_user_ns</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The list_lru structure is essentially just a pointer to a table</span></span><br><span class="line"><span class="comment">     * of per-node lru lists, each of which has its own spinlock.</span></span><br><span class="line"><span class="comment">     * There is no need to put them into separate cachelines.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_lru</span>        <span class="title">s_dentry_lru</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_lru</span>        <span class="title">s_inode_lru</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>        <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>    <span class="title">destroy_work</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">s_sync_lock</span>;</span>    <span class="comment">/* sync serialisation lock */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Indicates how deep in a filesystem stack this SB is</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> s_stack_depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* s_inode_list_lock protects s_inodes */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        s_inode_list_lock ____cacheline_aligned_in_smp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes</span>;</span>    <span class="comment">/* all inodes */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">spinlock_t</span>        s_inode_wblist_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">s_inodes_wb</span>;</span>    <span class="comment">/* writeback inodes */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>s_root将超级块与全局根目录的dentry项关联起来。<br>只有通常可见的文件系统的超级块，才指向&#x2F;（根）目录的dentry实例。具有特殊功能、不出现在通常的目录层次结构中的文件系统（例如，管道或套接字文件系统），指向专门的项，不能通过普通的文件命令访问。</p>
<p>处理文件系统对象的代码经常需要检查文件系统是否已经装载，而s_root可用于该目的。如果它为NULL，则该文件系统是一个伪文件系统，只在内核内部可见。否则，该文件系统在用户空间中是可见的。</p>
</li>
</ul>
<p>所有超级快对象是以双向环形链表形式进行链接在一起。链表中第一个元素和最后一个元素的地址分别存放在<code>super_blocks</code>变量的<code>s_list/next/prev</code>域中 。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/source/include/linux/types.h#L178">types.h - include&#x2F;linux&#x2F;types.h - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体架构如下：</p>
<img src="/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/super_block架构.png" title alt data-align="center">

<p>尽管每个文件系统在file_system_type中只出现一次，但在所有超级块实例的链表中，可能有几个同一文件系统类型的超级块实例，因为在各个块设备&#x2F;分区上可能存储了同一类型的几个文件系统。例如，大多数系统都有root和home分区，二者可能在不同的分区上，但通常使用相同类型的文件系统。在file_system_type中，同一文件系统类型只需定义一次，但这两个装载点的超级块不同，虽然都使用了同样的文件系统。</p>
<p>超级块结构的一个重要成员是一个列表，包括相关文件系统中所有修改过的inode（内核相当不敬地称之为<strong>脏</strong>inode）。根据该列表很容易标识已经修改过的文件和目录，以便将其写回到存储介质。回写必须经过协调，保证在一定程度上最小化开销，因为这是一个非常费时的操作（硬盘、软盘驱动器及其他介质与系统其余组件相比，速度很慢）。另一方面，如果写回修改数据的间隔太长也可能有严重后果，因为系统崩溃（或者，就Linux的情形而言，更可能的是停电）会导致不能恢复的数据丢失。内核会周期性扫描脏块的列表，并将修改传输到底层硬件。</p>
<h3 id="VFS索引节点inode"><a href="#VFS索引节点inode" class="headerlink" title="VFS索引节点inode"></a>VFS索引节点inode</h3><p>存放关于具体文件的一些信息。对于基于磁盘的文件系统，此类对象通常对应用于存放在磁盘上的文件控制块（PCB）。每一个文件都有一个索引节点对象，每一个索引节点对象都有一个索引节点号，唯一标识文件系统中的一个文件。</p>
<p>具体文件系统的索引节点是存储在磁盘上，是一种静态结构，我们要使用它，必须调入内存，填写VFS的索引节点（VFS索引节点是动态节点）。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/inode">inode identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Keep mostly read-only and often accessed (especially for</span></span><br><span class="line"><span class="comment"> * the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning</span></span><br><span class="line"><span class="comment"> * of the &#x27;struct inode&#x27;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="type">umode_t</span>            i_mode;          <span class="comment">/* 文件类型和访问权限 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>        i_opflags;       <span class="comment">/* inode 操作标志 */</span></span><br><span class="line">    <span class="type">kuid_t</span>            i_uid;           <span class="comment">/* 文件拥有者的标识号，用户 ID */</span></span><br><span class="line">    <span class="type">kgid_t</span>            i_gid;           <span class="comment">/* 文件拥有者的所在组的标识号，组 ID */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        i_flags;         <span class="comment">/* 文件或目录的标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_acl</span>;</span>          <span class="comment">/* 访问控制列表 (ACL) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span>    *<span class="title">i_default_acl</span>;</span>  <span class="comment">/* 默认访问控制列表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>    *<span class="title">i_op</span>;</span>  <span class="comment">/* inode 操作函数集 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>    *<span class="title">i_sb</span>;</span>           <span class="comment">/* 指向此文件系统超级块的指针 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">i_mapping</span>;</span>      <span class="comment">/* 文件内容的内存映射 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *i_security;     <span class="comment">/* 安全模块使用的 inode 信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        i_ino;           <span class="comment">/* inode 编号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">//与该节点建立链接的文件数量</span></span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;        <span class="comment">/* 硬链接计数 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">dev_t</span>            i_rdev;          <span class="comment">/* 实际设备标识号 */</span></span><br><span class="line">    <span class="type">loff_t</span>            i_size;          <span class="comment">/* 文件大小（字节） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_atime</span>;</span>         <span class="comment">/* 最后访问时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_mtime</span>;</span>         <span class="comment">/* 最后修改时间 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span>    <span class="title">i_ctime</span>;</span>         <span class="comment">/* 最后元数据更改时间 */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        i_lock;          <span class="comment">/* 保护 i_blocks, i_bytes 和可能的 i_size 的锁 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>          i_bytes;        <span class="comment">/* 文件末尾未使用的字节数 */</span></span><br><span class="line">    u8            i_blkbits;       <span class="comment">/* 文件系统块大小的以 2 为底的对数 */</span></span><br><span class="line">    u8            i_write_hint;    <span class="comment">/* 写操作的优化提示 */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>        i_blocks;        <span class="comment">/* 文件占用的磁盘块数量 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="type">seqcount_t</span>        i_size_seqcount; <span class="comment">/* 有序 i_size 的序列计数器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        i_state;         <span class="comment">/* inode 状态标志 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>    <span class="title">i_rwsem</span>;</span>         <span class="comment">/* 读写信号量，用于保护 inode 结构 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        dirtied_when;    <span class="comment">/* 第一次被脏的时间，以 jiffies 计 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        dirtied_time_when; <span class="comment">/* 上次被脏的时间，以 jiffies 计 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">i_hash</span>;</span>          <span class="comment">/* 散列链表上的节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_io_list</span>;</span>       <span class="comment">/* 后备设备的 I/O 列表 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span>    *<span class="title">i_wb</span>;</span>           <span class="comment">/* 关联的 cgroup 写回控制器 */</span></span><br><span class="line">    <span class="type">int</span>            i_wb_frn_winner; <span class="comment">/* 外部 inode 检测的赢家 */</span></span><br><span class="line">    u16            i_wb_frn_avg_time; <span class="comment">/* 外部 inode 的平均时间 */</span></span><br><span class="line">    u16            i_wb_frn_history; <span class="comment">/* 外部 inode 的历史记录 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_lru</span>;</span>           <span class="comment">/* inode LRU 列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_sb_list</span>;</span>       <span class="comment">/* 超级块列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_wb_list</span>;</span>       <span class="comment">/* 后备设备写回列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    <span class="title">i_dentry</span>;</span>      <span class="comment">/* 目录项列表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>        <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">atomic64_t</span>        i_version;       <span class="comment">/* inode 版本 */</span></span><br><span class="line">    <span class="type">atomic64_t</span>        i_sequence;      <span class="comment">/* 用于 futex 的序列值 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_count;         <span class="comment">/* inode 引用计数 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_dio_count;     <span class="comment">/* 直接 I/O 计数 */</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_writecount;    <span class="comment">/* 写计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)</span></span><br><span class="line">    <span class="type">atomic_t</span>        i_readcount;     <span class="comment">/* 只读打开的文件计数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">i_fop</span>;</span>  <span class="comment">/* 以前的 -&gt;i_op-&gt;default_file_ops */</span></span><br><span class="line">        <span class="type">void</span> (*free_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span>    *<span class="title">i_flctx</span>;</span>         <span class="comment">/* 文件锁上下文 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    <span class="title">i_data</span>;</span>          <span class="comment">/* inode 的数据缓冲区 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">i_devices</span>;</span>       <span class="comment">/* 设备列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>    *<span class="title">i_pipe</span>;</span>   <span class="comment">/* 管道 inode 信息 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>        *<span class="title">i_cdev</span>;</span>    <span class="comment">/* 字符设备 */</span></span><br><span class="line">        <span class="type">char</span>            *i_link;    <span class="comment">/* 符号链接的目标路径 */</span></span><br><span class="line">        <span class="type">unsigned</span>        i_dir_seq;  <span class="comment">/* 目录序列计数器 */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32            i_generation;    <span class="comment">/* inode 生成计数器 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    __u32            i_fsnotify_mask; <span class="comment">/* inode 关心的所有事件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span>    *<span class="title">i_fsnotify_marks</span>;</span> <span class="comment">/* 文件系统通知标记连接器 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span>    *<span class="title">i_crypt_info</span>;</span>   <span class="comment">/* 文件系统加密信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsverity_info</span>    *<span class="title">i_verity_info</span>;</span>  <span class="comment">/* 文件系统完整性信息 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>            *i_private;       <span class="comment">/* 文件系统或设备的私有指针 */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>每一个文件都有一个<code>inode</code>，每个<code>inode</code>都有一个索引节点号<code>i_ino</code>。在同一个文件系统时每个索引节点号都是唯一的，内核有时候根据索引节点号的哈希值查找其inode结构。</p>
<h3 id="目录项dentry"><a href="#目录项dentry" class="headerlink" title="目录项dentry"></a>目录项dentry</h3><p>存放目录项与对应文件进行链接的信息，VFS把每个目录看作一个由若干个子目录和文件组成的常规文件。</p>
<p>每个文件除了有一个索引节点inode数据结构之外，还有一个目录项dentry（directory entry）数据结构。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/dentry">dentry identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RCU lookup touched fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d_flags;        <span class="comment">/* 目录项的标志位，受 d_lock 保护 */</span></span><br><span class="line">    <span class="type">seqcount_spinlock_t</span> d_seq;    <span class="comment">/* 每个目录项的序列锁 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span>    <span class="comment">/* 目录项形成的用于查找的哈希列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>    <span class="comment">/* 父目录的目录项dentry */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>             <span class="comment">/* 目录项的名称（可以快速查找） */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>        <span class="comment">/* 与文件名称关联的，与目录名关联的 inode 结构指针，NULL 表示负目录项 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> d_iname[DNAME_INLINE_LEN];    <span class="comment">/* 短文件名称 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ref lookup also touches following */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lockref</span> <span class="title">d_lockref</span>;</span>    <span class="comment">/* 每个目录项的锁和引用计数 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">/* 目录项操作函数集 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>    <span class="comment">/* 目录项树的根节点（即文件的超级块） */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> d_time;        <span class="comment">/* 用于 d_revalidate 的时间戳 */</span></span><br><span class="line">    <span class="type">void</span> *d_fsdata;            <span class="comment">/* 特定文件系统的数据 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>        <span class="comment">/* LRU（最近最少使用）列表 */</span></span><br><span class="line">        <span class="type">wait_queue_head_t</span> *d_wait;    <span class="comment">/* 仅用于查找中的目录项 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_child</span>;</span>    <span class="comment">/* 父目录项的子项列表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_subdirs</span>;</span>    <span class="comment">/* 子目录项列表 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * d_alias and d_rcu can share memory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">d_alias</span>;</span>    <span class="comment">/* inode 别名列表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_in_lookup_hash</span>;</span>    <span class="comment">/* 仅用于查找中的目录项 */</span></span><br><span class="line">         <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">d_rcu</span>;</span></span><br><span class="line">    &#125; d_u;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>各个dentry实例组成了一个网络，与文件系统的结构形成一定的映射关系。与给定目录下的所有文件和子目录相关联的dentry实例，都归入到d_subdirs链表（在目录对应的dentry实例中）。子结点的d_child成员充当链表元素。</p>
<p>dentry结构的主要用途是建立文件名和相关的inode之间的关联。结构中有3个成员用于该目<br>的。</p>
<ul>
<li><p>d_inode是指向相关的inode实例的指针。</p>
<p>如果dentry对象是为一个不存在的文件名建立的，则d_inode为NULL指针。这有助于加速查找不存在的文件名，通常情况下，这与查找实际存在的文件名同样耗时。</p>
</li>
<li><p>d_name指定了文件的名称。qstr是一个内核字符串的包装器。它存储了实际的char *字符串以及字符串长度和散列值，这使得更容易处理查找工作。</p>
</li>
<li><p>d_op指向一个结构，其中包含了各种函数指针，提供对dentry对象的各种操作。这些操作必须由底层文件系统实现。</p>
</li>
<li><p>s_sb是一个指针，指向dentry对象所属文件系统超级块的实例。该指针使得各个dentry实例散布到可用的（已装载的）文件系统。由于每个超级块结构都包含了一个指针，指向该文件系统装载点对应目录的dentry实例，因此dentry组成的树可以划分为几个子树。</p>
</li>
<li><p>d_flags可以包含几个标志，标志在include&#x2F;linux&#x2F;dcache.h中定义。但其中只有两个与我们的目的相关：DCACHE_DISCONNECTED指定一个dentry当前没有连接到超级块的dentry树。DCACHE_UNHASHED表明该dentry实例没有包含在任何inode的散列表中。要注意，这两个标志是彼此完全独立的。</p>
</li>
<li><p>d_parent是一个指针，指向当前结点父目录的dentry实例，当前的dentry实例即位于父目录的。</p>
</li>
<li><p>d_subdirs链表中。对于根目录（没有父目录），d_parent指向其自身的dentry实例。<br>当前dentry对象表示一个装载点，那么d_mounted设置为1；否则其值为0。</p>
</li>
<li><p>d_alias用作链表元素，以连接表示相同文件的各个dentry对象。在利用硬链接用两个不同名称表示同一文件时，会发生这种情况。对应于文件的inode的i_dentry成员用作该链表的表头。各个dentry对象通过d_alias连接到该链表中。</p>
</li>
</ul>
<p>但其中<mark>并非完全映射文件系统的拓扑结构，因为dentry缓存只包含文件系统结构的一小部分</mark>。 最常用文件和目录对应的目录项才保存在内存中。原则上，可以为所有文件系统对象都生成dentry项，但物理内存空间和性能原因都限制了这样做。</p>
<p>dentry数据结构代表的是逻辑意义上的文件，所描述的是文件逻辑上的属性，<mark>目录项对象在磁盘上并没有对应的映像</mark>，而inode数据结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统（ex2&#x2F;3&#x2F;4等），ext3_inode结构在磁盘上就有对应的映像。<mark>一个索引节点对象可能对应多个目录项对象。</mark></p>
<p>每个目录项对象属于一下四种状态之一</p>
<ul>
<li><p>空闲状态（free）</p>
<p>处于该状态的目录项对象不包含有效的信息，还没有被VFS使用。它对应的内存区由slab分配器进行管理。</p>
</li>
<li><p>未使用状态（unused）</p>
<p>处于该状态的目录项对象当前还没有被内核使用。该对象的引用计数器d_count的值为NULL。但其d_inode域仍然指向相关的索引节点。该目录项对象包含有效的信息，但为了在必要时回收内存，它的内容可能被丢弃。</p>
</li>
<li><p>正在使用状态（inuse）</p>
<p>处于该状态的目录项对象当前正在被内核使用，该对象的引用计数器d_count的值为正数，而其d_inode域指向相关的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。</p>
</li>
<li><p>负状态（negative）</p>
<p>与目录项相关的索引节点不复存在，那是因为相应的磁盘索引节点已被删除。该目录项对象的d_inode域被置为NULL，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成。</p>
</li>
</ul>
<h3 id="文件file"><a href="#文件file" class="headerlink" title="文件file"></a>文件file</h3><p>存放打开文件与进程之间交互的有关信息。这类信息仅仅是在进程访问文件期间存在于内存的。文件对象表示进程已打开的文件，如果我们站在用户角度来看待VFS，文件对象会首先进入我们的视野。进程直接处理的是文件，而不是超级块、索引节点或目录项。文件对象由相应的open（）系统调用创建，由close（）系统调用撤销。file也是files_struct定义时用到的一个结构。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/file">file identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span>    <span class="title">f_llist</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>     <span class="title">f_rcuhead</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>         f_iocb_flags;</span><br><span class="line">    &#125;; <span class="comment">// 定义一个联合体，用于节省空间。联合体中只有一个成员会被实际使用。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>        <span class="title">f_path</span>;</span> <span class="comment">// 文件路径 包含目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>        *<span class="title">f_inode</span>;</span>    <span class="comment">/* 缓存的值 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>    *<span class="title">f_op</span>;</span> <span class="comment">// 文件操作函数指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 保护 f_ep 和 f_flags 的自旋锁。</span></span><br><span class="line"><span class="comment">     * 不得在 IRQ 上下文中使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span>        f_lock;</span><br><span class="line">    <span class="type">atomic_long_t</span>        f_count; <span class="comment">// 文件引用计数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>         f_flags; <span class="comment">// 文件标志</span></span><br><span class="line">    <span class="type">fmode_t</span>            f_mode; <span class="comment">// 文件模式</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>        <span class="title">f_pos_lock</span>;</span> <span class="comment">// 用于保护文件位置的互斥锁</span></span><br><span class="line">    <span class="type">loff_t</span>            f_pos; <span class="comment">// 文件位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fown_struct</span>    <span class="title">f_owner</span>;</span> <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span>    *<span class="title">f_cred</span>;</span> <span class="comment">// 指向文件凭证的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span>    <span class="title">f_ra</span>;</span> <span class="comment">// 文件读取状态</span></span><br><span class="line"></span><br><span class="line">    u64            f_version; <span class="comment">// 文件版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>            *f_security; <span class="comment">// 指向文件安全结构的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* 需要用于 tty 驱动程序，以及其他可能需要的程序 */</span></span><br><span class="line">    <span class="type">void</span>            *private_data; <span class="comment">// 私有数据指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_EPOLL</span></span><br><span class="line">    <span class="comment">/* 由 fs/eventpoll.c 使用，将所有钩子链接到此文件 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span>    *<span class="title">f_ep</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* #ifdef CONFIG_EPOLL */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">f_mapping</span>;</span> <span class="comment">// 文件映射地址空间</span></span><br><span class="line">    <span class="type">errseq_t</span>        f_wb_err; <span class="comment">// 写回错误序列</span></span><br><span class="line">    <span class="type">errseq_t</span>        f_sb_err; <span class="comment">// 用于 syncfs 的超级块错误序列</span></span><br><span class="line">&#125; __randomize_layout</span><br><span class="line">  __attribute__((aligned(<span class="number">4</span>)));    <span class="comment">/* 以防某些奇怪的设备认为 2 是合适的对齐方式 */</span></span><br></pre></td></tr></table></figure>

<p>f_path封装了下面两部分信息：</p>
<ul>
<li>文件名和inode之间的关联（dentry）</li>
</ul>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/C/ident/path">path identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<h3 id="索引节点-x2F-目录-x2F-块-高速缓存"><a href="#索引节点-x2F-目录-x2F-块-高速缓存" class="headerlink" title="索引节点&#x2F;目录&#x2F;块-高速缓存"></a>索引节点&#x2F;目录&#x2F;块-高速缓存</h3><ul>
<li><p>索引节点inode高速缓存</p>
<p> 加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中所有的索引节点（inode），可以避免频繁从磁盘读取索引节点信息）</p>
</li>
<li><p><mark>目录项dentry高速缓存</mark></p>
<p>加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中所有已经打开的目录项，可以避免频繁地从硬盘中读取目录项信息）。例如。我们经常需要编辑文件，随后进行编译或编辑，然后打印或拷贝，再进行编辑，诸如此类的情况中，同一个文件需要被反复访问。</p>
<p>目录项高速缓存由两种类型的数据结构组成：</p>
<ul>
<li><p>处于正在使用，未使用或负状态的目录项对象的集合。</p>
</li>
<li><p>一个散列表，从中能够快速获取与给定文件名和目录名对应的目录项对象，如果访问的对象不在目录项高速缓存中，散列函数返回一个空值。</p>
</li>
</ul>
<p>目录项高速缓存的作用也相当于索引节点高速缓存（inode cache）的控制器。内核内存中，与未使用目录项相关的索引节点未被丢弃，这是由于目录项高速缓存仍在使用他们，因此，它们的i_count域不为空。因此，这些索引节点对象保存在RAM中，并能够借助相应的目录项快速引用他们。</p>
<p>所有“未使用unused”的目录项都存放在一个“最近最少使用（LRU：Least Recently Used）”的双向链表中，该链表按照插入的时间排序。换句话说，最后释放的目录项对象放在链表的首部，所以最近最少使用的目录项总是靠近链表的尾部。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得多数最近经常使用的对象得以保留。LRU链表的首元素和尾元素的地址存放在变量dentry_unused中的next域和prev域。目录项对象的d_lcu域包含的指针指向该链表中相邻目录的对象。</p>
<p>每个“正在使用inuse”的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的i_dentry域所指向（由于每个索引节点可能与若干硬链接关联，所以需要一个链表）。目录项对象的d_alias域存放链表中相邻元素的地址。这两个域的类型都是struct list_head。</p>
<p>当指向相应文件的最后一个硬链接被删除后，一个“正在使用inuse”的目录项对象可能变成“负negative”状态。在这种情况下，该目录项对象被移到“未使用unused”目录项对象组成的LRU链表中。每当内核缩减目录项高速缓存时，“负negative”状态目录项对象就朝着LRU链表的尾部移动。这样一来，这些对象就逐渐被释放。</p>
<p>散列表是由dentry_hashtable数组实现的。数组中每个元素是一个指向链表的指针，这种链表就是把具有相同散列表值得目录项进行散列而形成得。该数组得长度取决于系统已安装RAM的数量。目录项对象的d_hash域包含指向具有相同散列值的链表中的相邻元素。散列函数产生的值是由目录及文件名的目录项对象的地址计算出来的。</p>
</li>
<li><p>块高速缓存</p>
<p>加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中已经读取过的块数据block，有效避免频繁从硬盘读取数据）。<mark>块高速缓存只适用于数据进行顺序访问的情况</mark>，如果对数据进行随机访问，导致大量无效的缓存命中和未命中反而降低性能。</p>
</li>
</ul>
<h3 id="Ext格式和目录存储以及文件缓存"><a href="#Ext格式和目录存储以及文件缓存" class="headerlink" title="Ext格式和目录存储以及文件缓存"></a>Ext格式和目录存储以及文件缓存</h3><ul>
<li><p>Ext文件系统：基于磁盘的文件系统，支持多个磁盘分区和超过2TB的大容量磁盘，主要版本：Ex2&#x2F;Ex3&#x2F;Ex4</p>
</li>
<li><p>目录存储：指在文件系统中用于组织和存储文件的一种层次结构。在Linux系统当中，所有的文件都存放在根目录（&#x2F;）下或其子目录下 ，而这些目录则以特定方式组织起来，形成一个层次化的目录结构，Linux文件系统采用树形结构组织文件和目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin 可执行二进制文件</span><br><span class="line">/dev 设备文件</span><br><span class="line">/etc 配置文件</span><br><span class="line">/lib 库文件</span><br><span class="line">/tmp 临时文件 </span><br></pre></td></tr></table></figure>
</li>
<li><p>文件缓存： 系统将硬盘上的文件暂时存在内存当中以提高访问效率的一种机制。</p>
<p>每一个inode结构与文件相关联所有元数据信息（创建事件，文件大小等)。 </p>
<p>比如在实际应用：写操作时，也可以将需要写入硬盘数据暂存到页高速缓存当中，并延迟实际写入硬盘的事件（延迟写），提升性能和减少I&#x2F;O负载，当需要刷新缓存并将数据同步回到硬盘时，直接调用sync&#x2F;fsnc函数来完成。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/mount">mount identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_hash</span>;</span>                   <span class="comment">// 用于挂载点哈希表的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_parent</span>;</span>                     <span class="comment">// 指向父挂载点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span>                <span class="comment">// 指向挂载点位置的目录入口（dentry）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> <span class="title">mnt</span>;</span>                          <span class="comment">// 包含挂载文件系统相关信息的vfsmount结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">mnt_rcu</span>;</span>                  <span class="comment">// 用于RCU（Read-Copy-Update）同步的链表头</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">mnt_llist</span>;</span>              <span class="comment">// 用于延迟列表（llist）的链表节点</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_pcp</span> __<span class="title">percpu</span> *<span class="title">mnt_pcp</span>;</span>             <span class="comment">// 指向每个CPU的mnt_pcp结构体的指针（仅在多处理器系统中使用）</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">int</span> mnt_count;                                <span class="comment">// 挂载点的引用计数</span></span><br><span class="line">    <span class="type">int</span> mnt_writers;                              <span class="comment">// 写入操作的计数器</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span>                    <span class="comment">// 子挂载点列表的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span>                    <span class="comment">// 与mnt_mounts链表相连的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_instance</span>;</span>                <span class="comment">// 超级块的s_mounts链表上的挂载实例列表节点</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mnt_devname;                        <span class="comment">// 设备名称，如 /dev/dsk/hda1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span>                    <span class="comment">// 全局挂载点列表的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_expire</span>;</span>                    <span class="comment">// 特定文件系统的过期列表的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_share</span>;</span>                   <span class="comment">// 共享挂载点的循环列表链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave_list</span>;</span>              <span class="comment">// 从属挂载点的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave</span>;</span>                   <span class="comment">// 与mnt_slave_list链表相连的链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_master</span>;</span>                     <span class="comment">// 指向主挂载点的指针，从属挂载点位于master-&gt;mnt_slave_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span>                 <span class="comment">// 包含此挂载点的命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mnt_mp</span>;</span>                    <span class="comment">// 指向挂载点位置的mountpoint结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_mp_list</span>;</span>            <span class="comment">// 具有相同挂载点的挂载列表链表节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_umount</span>;</span>             <span class="comment">// 用于卸载操作的链表节点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_umounting</span>;</span>               <span class="comment">// 用于卸载传播的链表节点</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span> *<span class="title">mnt_fsnotify_marks</span>;</span> <span class="comment">// 指向文件系统通知标记的指针</span></span><br><span class="line">    __u32 mnt_fsnotify_mask;                      <span class="comment">// 文件系统通知的掩码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> mnt_id;                                    <span class="comment">// 挂载点的唯一标识符</span></span><br><span class="line">    <span class="type">int</span> mnt_group_id;                            <span class="comment">// 同级挂载组的唯一标识符</span></span><br><span class="line">    <span class="type">int</span> mnt_expiry_mark;                            <span class="comment">// 如果已标记为过期，则为true</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_pins</span>;</span>                  <span class="comment">// 用于记录挂载点引脚的链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_stuck_children</span>;</span>        <span class="comment">// 被卡住的子挂载点列表的链表头</span></span><br><span class="line">&#125; __randomize_layout;                           <span class="comment">// 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件系统数据结构"><a href="#文件系统数据结构" class="headerlink" title="文件系统数据结构"></a>文件系统数据结构</h2><h4 id="file-system-type"><a href="#file-system-type" class="headerlink" title="file_system_type"></a>file_system_type</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/file_system_type">file_system_type identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">// 文件系统的名称</span></span><br><span class="line">    <span class="type">int</span> fs_flags; <span class="comment">// 文件系统的标识位</span></span><br><span class="line">    <span class="comment">// 文件系统标识位的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_REQUIRES_DEV         1  <span class="comment">// 文件系统需要一个设备</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_BINARY_MOUNTDATA     2  <span class="comment">// 文件系统的挂载数据是二进制格式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_HAS_SUBTYPE          4  <span class="comment">// 文件系统具有子类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_USERNS_MOUNT         8  <span class="comment">// 可以由用户命名空间的根目录挂载</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_DISALLOW_NOTIFY_PERM 16 <span class="comment">// 禁止 fanotify 权限事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_ALLOW_IDMAP          32 <span class="comment">// 文件系统已更新以处理 VFS ID 映射</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_RENAME_DOES_D_MOVE   32768 <span class="comment">// 在 rename() 期间，文件系统将内部处理 d_move()</span></span></span><br><span class="line">    <span class="type">int</span> (*init_fs_context)(<span class="keyword">struct</span> fs_context *); <span class="comment">// 初始化文件系统上下文的函数指针</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">fs_parameter_spec</span> *<span class="title">parameters</span>;</span> <span class="comment">// 文件系统参数的指针</span></span><br><span class="line">    <span class="comment">// 挂载文件系统的函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>) (<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>,</span></span><br><span class="line"><span class="class">               <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line">    <span class="type">void</span> (*kill_sb) (<span class="keyword">struct</span> super_block *); <span class="comment">// 销毁超级块的函数指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">// 指向文件系统所属模块的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> * <span class="title">next</span>;</span> <span class="comment">// 指向下一个文件系统类型的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span> <span class="comment">// 用于存放文件系统超级块的哈希链表头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下为各种锁的定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span> <span class="comment">// 超级块锁的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span> <span class="comment">// 卸载锁的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_vfs_rename_key</span>;</span> <span class="comment">// VFS 重命名锁的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_writers_key</span>[<span class="title">SB_FREEZE_LEVELS</span>];</span> <span class="comment">// 写入者锁的键数组</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_lock_key</span>;</span> <span class="comment">// inode 锁的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_key</span>;</span> <span class="comment">// inode 互斥量的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">invalidate_lock_key</span>;</span> <span class="comment">// 使 inode 无效的锁的键</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">i_mutex_dir_key</span>;</span> <span class="comment">// 目录 inode 互斥量的键</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>file_system_type用来描述各种特定文件系统类型。每种文件系统，不管有多少个实例安装到系统中，还是根本没有安装到系统中，都只有一个file_system结构。</p>
<p>name保存了文件系统的名称，是一个字符串（因此包含了例如reiserfs、ext3等类似的值）。fs_flags是使用的标志，例如标明只读装载、禁止setuid&#x2F;setgid操作或进行其他的微调。owner是一个指向module结构的指针，仅当文件系统以模块形式加载时，owner才包含有意义的值（NULL指针表示文件系统已经持久编译到内核中）。各个可用的文件系统通过next成员连接起来，这里无法利用标准的链表功能，因为这是一个单链表。</p>
<h4 id="vfsmount"><a href="#vfsmount" class="headerlink" title="vfsmount"></a>vfsmount</h4><p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/vfsmount">vfsmount identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span>       <span class="comment">// 指向已挂载文件系统树的根目录入口（dentry结构体）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span>    <span class="comment">// 指向与已挂载文件系统关联的超级块（super_block结构体）</span></span><br><span class="line">    <span class="type">int</span> mnt_flags;                 <span class="comment">// 挂载标志，表示挂载时的选项，如只读、异步等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">mnt_idmap</span>;</span>   <span class="comment">// 指向一个mnt_idmap结构体，用于存储用户和组ID的映射关系（仅在某些文件系统中使用，如NFS）</span></span><br><span class="line">&#125; __randomize_layout;             <span class="comment">// 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性</span></span><br></pre></td></tr></table></figure>

<p>当文件系统被实际安装到系统中，将有一个vfsmount结构体在安装点被创建，该结构体用来代表文件系统的实例-换句话说，代表一个安装点。理清文件系统和所有其他安装点之间的关系，是维护所有安装点链表中最复杂的工作。所以vfsmount结构体中维护的各种链表就是为了能够跟踪这些关联信息。文件系统本身的相对根目录所对应的dentry保存在mnt_root中。mnt_sb指针建立了与相关的超级块之间的关联（对每个装载的文件系统而言，都有且只有一个超级块实例）。在nmt_flags可以设置各种独立于文件系统的标志。</p>
<h3 id="vfs命名空间"><a href="#vfs命名空间" class="headerlink" title="vfs命名空间"></a>vfs命名空间</h3><p>VFS<strong>命名空间</strong>是所有已经装载、构成某个容器目录树的文件系统的集合。</p>
<p>通常调用fork或clone建立的进程会继承其父进程的命名空间。但可以设置CLONE_NEWNS标志，以建立一个新的VFS命名空间（在下文中，我不再区分VFS命名空间和命名空间，当然内核也提供了非VFS的命名空间。如果修改新的命名空间，改变不会传播到属于不同命名空间的进程。对其他命名空间的改变也不会影响新的命名空间。</p>
<p>struct task_struct包含的成员nsproxy，该成员负责命名空间的处理。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/nsproxy">nsproxy identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个结构体,包含指向每个进程命名空间的指针 </span></span><br><span class="line"><span class="comment"> * - fs(挂载),uts,网络,sysvipc 等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pid 命名空间是一个例外 - 它通过 task_active_pid_ns 访问。</span></span><br><span class="line"><span class="comment"> * 这里的 pid 命名空间是子进程将使用的命名空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;count&#x27; 是持有引用的任务数。</span></span><br><span class="line"><span class="comment"> * 因此,每个命名空间的计数将是指向它的 nsproxy 数,而不是任务数。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * nsproxy 由共享所有命名空间的任务共享。</span></span><br><span class="line"><span class="comment"> * 一旦单个命名空间被克隆或取消共享,nsproxy 就会被复制。</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> &#123;</span>   </span><br><span class="line">    <span class="type">atomic_t</span> count;   <span class="comment">/*原子计数器*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uts_namespace</span> *<span class="title">uts_ns</span>;</span>     <span class="comment">/*UTS命名空间结构体指针*/</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ipc_ns</span>;</span>    <span class="comment">/*IPC命名空间结构体指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span>    <span class="comment">/*挂载命名空间结构体指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns_for_children</span>;</span>   </span><br><span class="line">                                       <span class="comment">/*子进程使用的PID命名空间结构体指针*/</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span>          *<span class="title">net_ns</span>;</span>     <span class="comment">/*网络命名空间结构体指针*/</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">time_namespace</span> *<span class="title">time_ns</span>;</span>      <span class="comment">/*时间命名空间结构体指针*/</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">time_namespace</span> *<span class="title">time_ns_for_children</span>;</span> </span><br><span class="line">                                    <span class="comment">/*子进程使用的时间命名空间结构体指针*/</span>                  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_namespace</span> *<span class="title">cgroup_ns</span>;</span>   <span class="comment">/*cgroup命名空间结构体指针*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> <span class="title">init_nsproxy</span>;</span>        <span class="comment">/*外部变量:初始的nsproxy*/</span></span><br></pre></td></tr></table></figure>

<p>实现VFS命名空间所需信息的数量相对很少：</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/C/ident/mnt_namespace">mnt_namespace identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> &#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span>    <span class="title">ns</span>;</span>  <span class="comment">/*命名空间通用结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *    <span class="title">root</span>;</span> <span class="comment">/*根挂载点指针*/</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 遍历和修改 .list 是通过两种方式保护的:</span></span><br><span class="line"><span class="comment">     * - 以写方式获取namespace_sem, 或者</span></span><br><span class="line"><span class="comment">     * - 以读方式获取namespace_sem AND 获取 .ns_lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span>     <span class="comment">/*链表头*/</span></span><br><span class="line">    <span class="type">spinlock_t</span>        ns_lock;   <span class="comment">/*自旋锁*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span>    *<span class="title">user_ns</span>;</span>   <span class="comment">/*用户命名空间指针*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span>        *<span class="title">ucounts</span>;</span> <span class="comment">/*引用计数器*/</span></span><br><span class="line">    u64            seq;        <span class="comment">/*序列号,用于防止循环*/</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll;   <span class="comment">/*等待队列头*/</span></span><br><span class="line">    u64 event;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        mounts;   <span class="comment">/*命名空间中的挂载数*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        pending_mounts; <span class="comment">/*待定挂载数*/</span>  </span><br><span class="line">&#125; __randomize_layout;  <span class="comment">/*随机布局*/</span></span><br></pre></td></tr></table></figure>

<h2 id="进程相关数据结构"><a href="#进程相关数据结构" class="headerlink" title="进程相关数据结构"></a>进程相关数据结构</h2><p>系统中的每一个进程都有自己的一组打开的文件，像根文件系统，当前工作目录，安装点等。有三个数据结构将VFS层和系统的进程紧密联系在一起，它们分别是：files_struct、fs_struct、namespace结构体。</p>
<p>文件描述符（就是整数）用于在一个进程内唯一地标识打开的文件。这假定了内核能够在用户进程中的描述符和内核内部使用的结构之间，建立一种关联。每个进程的task_struct中包含了用于完成该工作的成员。</p>
<h3 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/task_struct">task_struct identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 文件系统信息 */</span></span><br><span class="line"><span class="type">int</span> link_count, total_link_count;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 文件系统信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* 打开文件信息 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line"><span class="comment">/* 命名空间 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件描述符（就是整数）用于在一个进程内唯一地标识打开的文件。这假定了内核能够在用户进程中的描述符和内核内部使用的结构之间，建立一种关联。每个进程的task_struct中包含了用于完成该工作的成员。</p>
<p>进程的文件系统相关数据保存在fs中。这些数据包含，例如当前工作目录和chroot限制有关的信息。整数成员link_count和total_link_count用于在查找环形链表时防止无限循环。</p>
<p>由于内核允许同时运行多个模仿独立系统的容器，从容器角度看似“全局”的每个资源，都由内核包装起来，分别根据每个容器进行管理。虚拟文件系统也受到影响，因为各个容器可能因装载点的不同导致不同的目录层次结构。对应的信息包含在ns_proxy-&gt;mnt_namespace中。</p>
<h3 id="files-struct"><a href="#files-struct" class="headerlink" title="files_struct"></a>files_struct</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/files_struct">files_struct identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 打开的文件表结构 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line"> <span class="comment">/*  </span></span><br><span class="line"><span class="comment"> *  主要读取部分</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">    <span class="type">atomic_t</span> count;           <span class="comment">//原子计数器，共享该表的进程数目  </span></span><br><span class="line">    <span class="type">bool</span> resize_in_progress;   <span class="comment">//重新调整进度  </span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> resize_wait; <span class="comment">//等待重新调整队列  </span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> __<span class="title">rcu</span> *<span class="title">fdt</span>;</span>   <span class="comment">//文件描述符表  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> <span class="title">fdtab</span>;</span>   </span><br><span class="line">  <span class="comment">/*  </span></span><br><span class="line"><span class="comment">   * SMP上单独的缓存线中的写入部分</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">    <span class="type">spinlock_t</span> file_lock ____cacheline_aligned_in_smp; <span class="comment">//文件锁  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> next_fd;       <span class="comment">//下一个文件描述符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> close_on_exec_init[<span class="number">1</span>]; <span class="comment">//执行时关闭的初始化  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> open_fds_init[<span class="number">1</span>];   <span class="comment">//打开的文件描述符初始化 </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> full_fds_bits_init[<span class="number">1</span>]; <span class="comment">//完整文件描述符位的初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span> <span class="comment">//文件描述符数组  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>next_fd表示下一次打开新文件时使用的文件描述符。close_on_exec_init和open_fds_init是位图。对执行exec时将关闭的所有文件描述符，在close_on_exec中对应的比特位都将置位。open_fds_init是最初的文件描述符集合。</p>
<p>fd_array的每个数组项都是一个指针，指向每个打开文件的struct file实例，稍后我会讨论该结构。默认情况下，内核允许每个进程打开NR_OPEN_DEFAULT个文件。该值定义在<a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/NR_OPEN_DEFAULT">NR_OPEN_DEFAULT identifier - Linux source code (v6.3.8) - Bootlin</a>中，默认值为BITS_PER_LONG。因此在32位系统上，允许打开文件的初始数目是32。64位系统可以同时处理64个文件。如果一个进程试图同时打开更多的文件，内核必须对files_struct中用于管理与进程相关的所有文件信息的各个成员，分配更多的内存空间。最重要的信息包含在fdtab中。内核为此定义了另一个数据结构fdtable。</p>
<h3 id="fdtable"><a href="#fdtable" class="headerlink" title="fdtable"></a>fdtable</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.8/C/ident/fdtable">fdtable identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_fds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> **<span class="title">fd</span>;</span>      <span class="comment">/* current fd array */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *close_on_exec;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *open_fds;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *full_fds_bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct files_struct中包含了该结构的一个实例和指向一个实例的指针，因为这里使用了RCU机制以便在无需锁定的情况下读取这些数据结构，这可以加速处理。在讨论具体的做法前，我们需要介绍各个成员的语义。</p>
<p>max_fds指定了进程当前可以处理的文件对象和文件描述符的最大数目。这里没有固有的上限，因为这两个值都可以在必要时增加（只要没有超出由Rlimit指定的值，但这与文件结构无关）。尽管内核使用的文件对象和文件描述符的数目总是相同的，但必须定义不同的最大数目。这归因于管理相关数据结构的方法。我会在下文解释这一点，但首先必须阐明该结构剩余成员的语义。</p>
<ul>
<li><p>fd是一个指针数组，每个数组项指向一个file结构的实例，管理一个打开文件的所有信息。用户空间进程的文件描述符充当数组索引。该数组当前的长度由max_fds定义。</p>
</li>
<li><p>open_fds是一个指向位域的指针，该位域管理着当前所有打开文件的描述符。每个可能的文件描述符都对应着一个比特位。如果该比特位置位，则对应的文件描述符处于使用中；否则该描述符未使用。当前比特位置的最大数目由max_fdset指定。</p>
</li>
<li><p>close_on_exec也是一个指向位域的指针，该位域保存了所有在exec系统调用时将要关闭的文件描述符的信息。</p>
</li>
</ul>
<h3 id="fs-struct"><a href="#fs-struct" class="headerlink" title="fs_struct"></a>fs_struct</h3><p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/fs_struct">fs_struct identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> users;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="type">seqcount_spinlock_t</span> seq;</span><br><span class="line">    <span class="type">int</span> umask;</span><br><span class="line">    <span class="type">int</span> in_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>, <span class="title">pwd</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="虚拟文件系统机制原理"><a href="#虚拟文件系统机制原理" class="headerlink" title="虚拟文件系统机制原理"></a>虚拟文件系统机制原理</h2><p>Linux内核当中负责管理和存储文件的模块，即文件系统模块。Linux文件系统的架构视图（用户空间、内核空间、硬件层面）</p>
<img src="/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/文件系统架构.png" title alt data-align="center">

<ul>
<li><p>挂载执行命令：<code>mount -t fstype device dir</code></p>
</li>
<li><p>卸载执行命令：<code>umount</code></p>
</li>
</ul>
<p>当我们写文件时，Linux内核系统模块会把数据保存在页缓存当中，不会立刻写到存储设备。使用<code>fsync</code>把文件修改过的属性和数据立即写到存储设备，使用<code>fsync</code>把文件修改过的属性和数据立即写到存储设备，或者使用<code>fdatasync</code>把文件修改过的数据理解写到存储设备。</p>
<p>我们应用程序可以使用glibc库封装的I&#x2F;O来访问文件（提供缓冲区，目的是尽可能减少调用read&#x2F;write的次数，提高性能）</p>
<hr>
<p>硬件层面：块设备（机械硬盘）、闪存（SSD）、NVDIMM设备。NOR闪存适合存储程序（一般情况下存储引导程序，U-Boot程序）。NAND闪存适合存储数据。</p>
<p>为什么要针对闪存专门设计文件系统？</p>
<ul>
<li><p>NAND存在坏块，软件需要识别且跳过坏块。</p>
</li>
<li><p>需要实现损耗均衡，损耗均衡就是使所有擦除块的擦除次数均衡，避免一部分擦除快先损坏。</p>
</li>
</ul>
<p>NAND闪存和机械硬盘的主要区别：</p>
<ul>
<li><p>机械硬盘最小读写单位为扇区，扇区大小一般为512字节；NAND闪存最小读写单位是页或子页。</p>
</li>
<li><p>机械硬盘可以直接写入数据；NAND在写入数据之前需要擦除一个擦除块。</p>
</li>
<li><p>机械硬盘的使用寿命比NAND闪存长；机械硬盘的扇区的写入次数没有限制；NAND闪存擦除快的擦除次数有限。</p>
</li>
<li><p>机械硬盘隐藏坏的扇区，软件不需要处理坏的扇区；NAND闪存的坏块对软件可见，软件需要处理坏块。</p>
</li>
</ul>
<hr>
<p>Linux内核空间层面：Linux内核的目录fs（内核支持多种文件系统类型）。为了不同文件系统实现能够共存，内核实现一个抽象层（称为虚拟文件系统）。文件系统分类：块设备文件系统（ext2&#x2F;3&#x2F;4、btrfs）、闪存文件系统（JFFS2、UBIFS）、内存文件系统（tmpfs）、伪文件系统（sockfs、proc、sysfs、hugetlbfs、cgroup)。</p>
<p>避免每次读写都需要访问块设备，内核实现块缓存，为每个块设备在内存中创建一个块缓存，缓存单位为块，块缓存基于页缓存实现。I&#x2F;O调度器用来决定读写请求的提交顺序，不同场景提供多种调度算法：NOOP（适合闪存类设备）、CFQ，Deadline（后两个适合机械硬盘）。</p>
<p>Linux内核把闪存称为存储技术设备（MTD）</p>
<hr>
<p>虚拟文件系统（VFS）数据结构：超级块(super_block)、索引节点(inode)(每个文件对应一个索引节点，每个索引节点有一个唯一的编号）、目录项(dentry)。</p>
<p>当进程打开一个文件时，虚拟文件系统就会创建文件的一个打开实例（file数据结构）。文件系统的第一块是超级块（super_block)</p>
<hr>
<p>挂载描述符：一个文件系统，只有挂载到内存当中目录树的 一个目录下，进程才能够访问这个文件系统。每次挂载文件系统，虚拟文件系统就会创建一个挂载描述符：mount结构体。挂载描述符用来描述文件系统的一个挂载实例，同一个存储设备上的文件系统可以多次挂载，每次挂载到不同的目录下。mount结构体。</p>
<hr>
<h2 id="文件系统安装"><a href="#文件系统安装" class="headerlink" title="文件系统安装"></a>文件系统安装</h2><p>在使用一个文件系统之前，必须执行两个操作：注册和安装。</p>
<p>或者在系统启动时，或者在安装某个文件系统的模块时，都需要进行注册。一旦一个文件系统完成注册，那么它具体的函数对内核就是可用的了，因此，这个文件系统就可以安装在系统的目录树上。在文件系统注册到内核时，文件系统是编译为模块，或者持久编译到内核中，都没有差别。如果不考虑注册的时间（持久编译到内核的文件系统在启动时注册，模块化文件系统在相关模块载入内核时注册），在两种情况下所用的技术方法是同样的。</p>
<p>每个文件系统都有它自己的根目录，如果某文件系统的根目录时系统目录树的根，那么该文件系统称为根文件系统。而其他文件系统可以安装到系统的目录树上，把这些文件系统要插入的那些目录就成为安装点（mount point）。</p>
<h3 id="注册文件系统"><a href="#注册文件系统" class="headerlink" title="注册文件系统"></a>注册文件系统</h3><p>在系统初始化期间，Linux v2.6调用函数filesystem_setup()来注册编译时指定的文件系统，而在最新版本的Linux中这个函数由其他函数替代。通过module_init()和相应的init_xxx_fs()函数来实现文件系统的注册。</p>
<p>对于每个不同类型的文件系统，以指向file_system_type类型的某个对象作为参数来调用register_filesystem()函数，因此，该对象就被插入到文件系统类型的链表中。</p>
<p>当某个文件系统的模块被装入时，也要调用register_filesystem()函数。在这种情况下，当该模块被卸载时，对应的文件系统也可以被注销（调用unregister_filesystem()函数）。</p>
<p>get_fs_type()函数（接受一个文件系统名作为它的参数）扫描已注册的文件系统链表，并返回指向相应的file_system_type对象的指针（如果存在）。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/get_fs_type">get_fs_type identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> file_system_type *<span class="title function_">get_fs_type</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>  </span><br><span class="line">&#123;                       <span class="comment">//根据文件系统名称获取文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">fs</span>;</span>  </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dot = <span class="built_in">strchr</span>(name, <span class="string">&#x27;.&#x27;</span>); <span class="comment">//查找点号</span></span><br><span class="line">    <span class="type">int</span> len = dot ? dot - name : <span class="built_in">strlen</span>(name);  <span class="comment">//获取文件系统类型名称的长度</span></span><br><span class="line"></span><br><span class="line">    fs = __get_fs_type(name, len);   <span class="comment">//根据名称和长度获取文件系统类型</span></span><br><span class="line">    <span class="keyword">if</span> (!fs &amp;&amp; (request_module(<span class="string">&quot;fs-%.*s&quot;</span>, len, name) == <span class="number">0</span>)) &#123;  </span><br><span class="line">                                   <span class="comment">//如果获取不到,加载文件系统模块</span></span><br><span class="line">        fs = __get_fs_type(name, len);  <span class="comment">//再次获取文件系统类型</span></span><br><span class="line">        <span class="keyword">if</span> (!fs)  </span><br><span class="line">            pr_warn_once(<span class="string">&quot;request_module fs-%.*s succeeded, but still no fs?\n&quot;</span>,   <span class="comment">//如果还是获取不到,打印警告信息</span></span><br><span class="line">                     len, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dot &amp;&amp; fs &amp;&amp; !(fs-&gt;fs_flags &amp; FS_HAS_SUBTYPE)) &#123;  <span class="comment">//如果文件系统名称包含点号,且文件系统类型不支持子类型</span></span><br><span class="line">        put_filesystem(fs); <span class="comment">//释放文件系统类型  </span></span><br><span class="line">        fs = <span class="literal">NULL</span>; <span class="comment">//设置为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fs;  <span class="comment">//返回文件系统类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>加载文件系统模块（如 ext4），并调用文件系统的注册函数。在注册函数中，需要提供一个指向 <code>file_system_type</code> 结构体的指针，该结构体包含文件系统的基本信息和操作指针。</p>
<ul>
<li><p>文件系统可以以两种方式存在于操作系统中：内建于内核中或作为可加载模块。内建文件系统直接编译进内核，而作为模块的文件系统可以在运行时动态加载。这种模块化设计可以节省内核空间和提高运行效率，因为只有在需要使用特定文件系统时，对应的模块才会被加载。</p>
</li>
<li><p>内建于内核的文件系统意味着文件系统的实现代码直接编译进内核二进制文件，而不是作为模块动态加载。内建文件系统在内核启动时就已经可用，不需要额外的加载过程。这种方式适用于一些基本或常用的文件系统，如 <code>ext4</code>、<code>proc</code> 、<code>tmpfs</code>等。</p>
</li>
</ul>
</li>
<li><p>使用 <code>register_filesystem()</code> 函数注册新的文件系统，将其添加到 VFS 支持的文件系统列表中。</p>
</li>
<li><p>当需要挂载该文件系统时（例如，通过 <code>mount</code> 命令），VFS 将调用 <code>file_system_type</code> 结构体中的 <code>mount</code> 函数指针。这将触发读取设备的超级块数据并创建一个对应的 VFS <code>super_block</code> 结构体实例。这个实例包含了该文件系统的类型、状态、操作等信息。</p>
</li>
</ol>
<hr>
<p><strong>以tmpfs文件系统为例</strong></p>
<ul>
<li><p>当内核启动时，会执行<code>shmem_init</code>函数（定义在<code>mm/shmem.c</code>文件中）。这个函数会调用<code>register_filesystem</code>注册tmpfs文件系统。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_init">shmem_init identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">shmem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 初始化 inode 缓存</span></span><br><span class="line">shmem_init_inodecache();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 tmpfs 文件系统</span></span><br><span class="line"><span class="type">int</span> error = register_filesystem(&amp;shmem_fs_type);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 若注册失败，打印错误信息</span></span><br><span class="line">    pr_err(<span class="string">&quot;Could not register tmpfs\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 跳转到 out2，执行清理操作</span></span><br><span class="line">    <span class="keyword">goto</span> out2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试挂载 tmpfs 文件系统</span></span><br><span class="line">shm_mnt = kern_mount(&amp;shmem_fs_type);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(shm_mnt)) &#123;</span><br><span class="line">    <span class="comment">// 若挂载失败，获取错误代码</span></span><br><span class="line">    error = PTR_ERR(shm_mnt);</span><br><span class="line">    <span class="comment">// 打印错误信息</span></span><br><span class="line">    pr_err(<span class="string">&quot;Could not kern_mount tmpfs\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 跳转到 out1，执行清理操作</span></span><br><span class="line">    <span class="keyword">goto</span> out1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line"><span class="comment">// 如果支持透明巨页，且巨页设置不为禁用，设置巨页选项</span></span><br><span class="line"><span class="keyword">if</span> (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY)</span><br><span class="line">    SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 否则，将巨页设置为永不使用，以防万一</span></span><br><span class="line">    shmem_huge = SHMEM_HUGE_NEVER;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功执行，函数返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">out1:</span><br><span class="line"><span class="comment">// 清理操作：注销 tmpfs 文件系统</span></span><br><span class="line">unregister_filesystem(&amp;shmem_fs_type);</span><br><span class="line"></span><br><span class="line">out2:</span><br><span class="line"><span class="comment">// 清理操作：销毁 inode 缓存</span></span><br><span class="line">shmem_destroy_inodecache();</span><br><span class="line"><span class="comment">// 设置 shm_mnt 为错误指针，表示初始化失败</span></span><br><span class="line">shm_mnt = ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>shmem_fs_type</code>是一个<code>file_system_type</code>结构体，定义了tmpfs文件系统的基本信息。在这个结构体中，<code>init_fs_context</code>成员被设置为<code>shmem_init_fs_context</code>。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/shmem_fs_type">shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">shmem_fs_type</span> =</span> &#123;</span><br><span class="line">.owner          = THIS_MODULE, <span class="comment">// 指定文件系统模块的所有者</span></span><br><span class="line">.name           = <span class="string">&quot;tmpfs&quot;</span>, <span class="comment">// 文件系统的名称</span></span><br><span class="line">.init_fs_context = shmem_init_fs_context, <span class="comment">// 初始化文件系统上下文的回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">.parameters     = shmem_fs_parameters, <span class="comment">// 指定文件系统的挂载参数解析回调</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.kill_sb        = kill_litter_super, <span class="comment">// 用于销毁超级块的回调函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SHMEM</span></span><br><span class="line">.fs_flags       = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, <span class="comment">// 文件系统的标志（支持用户命名空间挂载和ID映射）</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">.fs_flags       = FS_USERNS_MOUNT, <span class="comment">// 文件系统的标志（仅支持用户命名空间挂载）</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个新的文件系统需要被支持时，它需要使用 <code>register_filesystem()</code> 函数将自己注册到 VFS。这样，VFS 就可以识别和处理这个新的文件系统。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.6/C/ident/register_filesystem">register_filesystem identifier - Linux source code (v6.3.6) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    register_filesystem - 注册一个新的文件系统</span></span><br><span class="line"><span class="comment"> *    @fs: 文件系统结构体</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    将传入的文件系统添加到内核已知的文件系统列表中，供挂载和其他系统调用使用。</span></span><br><span class="line"><span class="comment"> *    成功时返回0，出错时返回一个负的errno错误码。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    传入的 &amp;struct file_system_type 结构体将链接到内核结构中，</span></span><br><span class="line"><span class="comment"> *    在文件系统未注销之前，不应该被释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_filesystem</span><span class="params">(<span class="keyword">struct</span> file_system_type * fs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 初始化结果为0，表示成功</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件系统参数是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;parameters &amp;&amp;</span><br><span class="line">        !fs_validate_description(fs-&gt;name, fs-&gt;parameters))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件系统名称中是否包含非法字符 &#x27;.&#x27;</span></span><br><span class="line">    BUG_ON(<span class="built_in">strchr</span>(fs-&gt;name, <span class="string">&#x27;.&#x27;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件系统是否已经链接到其他文件系统</span></span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 file_systems_lock 写锁，以保护 file_systems 链表</span></span><br><span class="line">    write_lock(&amp;file_systems_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找具有相同名称的文件系统</span></span><br><span class="line">    p = find_filesystem(fs-&gt;name, <span class="built_in">strlen</span>(fs-&gt;name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了具有相同名称的文件系统，返回 -EBUSY</span></span><br><span class="line">    <span class="keyword">if</span> (*p)</span><br><span class="line">        res = -EBUSY;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 否则，将新的文件系统链接到 file_systems 链表中</span></span><br><span class="line">        *p = fs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 file_systems_lock 写锁</span></span><br><span class="line">    write_unlock(&amp;file_systems_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(register_filesystem); <span class="comment">// 导出 register_filesystem 符号，供其他模块使用k);</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="安装根文件系统"><a href="#安装根文件系统" class="headerlink" title="安装根文件系统"></a>安装根文件系统</h3><p>安装根文件系统是系统初始化的关键部分。当系统启动时，就要在变量ROOT_DEV中寻找包含根文件系统的磁盘主码。当编译内核或向最初的启动装入程序传递一个合适的选项时，根文件系统可以被指定为&#x2F;dev目录下的一个设备文件。类似地，根文件系统的安装标志存放在root_mountflags变量中。用户可以指定这些标志，这是通过对已编译的内核映像使用&#x2F;sbin&#x2F;rdev外部程序，或者向最初的启动装入程序传递一个合适的选项来达到的。</p>
<p>在系统初始化期间，mount_root()安装根文件系统。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/mount_root">mount_root identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">mount_root</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ROOT_NFS   </span></span><br><span class="line">    <span class="comment">// 如果根文件系统位于 NFS 上,尝试挂载 NFS 根文件系统  </span></span><br><span class="line">    <span class="keyword">if</span> (ROOT_DEV == Root_NFS) &#123;     </span><br><span class="line">        <span class="keyword">if</span> (!mount_nfs_root())         </span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;VFS: Unable to mount root fs via NFS.\n&quot;</span>);     </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CIFS_ROOT   </span></span><br><span class="line">    <span class="comment">// 如果根文件系统位于 CIFS(SMB) 上,尝试挂载 CIFS 根文件系统  </span></span><br><span class="line">    <span class="keyword">if</span> (ROOT_DEV == Root_CIFS) &#123;     </span><br><span class="line">        <span class="keyword">if</span> (!mount_cifs_root())         </span><br><span class="line">            printk(KERN_ERR <span class="string">&quot;VFS: Unable to mount root fs via SMB.\n&quot;</span>);     </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">if</span> (ROOT_DEV == <span class="number">0</span> &amp;&amp; root_device_name &amp;&amp; root_fs_names) &#123;   </span><br><span class="line">        <span class="comment">// 如果根设备为空(0),并且命令行指定了根设备名和根文件系统类型,  </span></span><br><span class="line">        <span class="comment">// 尝试挂载一个无块设备的根文件系统(如 initramfs)。  </span></span><br><span class="line">        <span class="keyword">if</span> (mount_nodev_root() == <span class="number">0</span>)     </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLOCK    </span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="comment">// 为根块设备创建一个 /dev/root 节点    </span></span><br><span class="line">        <span class="type">int</span> err = create_dev(<span class="string">&quot;/dev/root&quot;</span>, ROOT_DEV);     </span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)         </span><br><span class="line">            pr_emerg(<span class="string">&quot;Failed to create /dev/root: %d\n&quot;</span>, err);      </span><br><span class="line">        <span class="comment">// 使用 /dev/root 和指定的挂载标志来挂载块设备根文件系统  </span></span><br><span class="line">        mount_block_root(<span class="string">&quot;/dev/root&quot;</span>, root_mountflags);  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装一个普通的文件系统"><a href="#安装一个普通的文件系统" class="headerlink" title="安装一个普通的文件系统"></a>安装一个普通的文件系统</h3><p>一旦完成对根文件系统的初始化，就可以安装其他的文件系统。其中的每一个都有自己的安装点，安装点仅仅是系统目录树中现有的一个目录。</p>
<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="查找inode"><a href="#查找inode" class="headerlink" title="查找inode"></a><mark>查找inode</mark></h3><p>一个主要操作是根据给定的文件名查找inode，这使得我们首先需要了解有关查找该信息的机制。</p>
<p>nameidata结构体用来查找函数传递参数数，并保存查找结果。</p>
<p><a href="https://elixir.bootlin.com/linux/v6.3.8/A/ident/nameidata">nameidata identifier - Linux source code (v6.3.8) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EMBEDDED_LEVELS 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 路径对象，表示路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span> <span class="comment">// 最后的路径组件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>;</span> <span class="comment">// 文件系统的根路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span> <span class="comment">// 指向路径中的目录项的节点 (path.dentry.d_inode)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags, state; <span class="comment">// 标志位和状态</span></span><br><span class="line">    <span class="type">unsigned</span> seq, next_seq, m_seq, r_seq; <span class="comment">// 用于序列号的变量</span></span><br><span class="line">    <span class="type">int</span> last_type; <span class="comment">// 最后路径组件的类型</span></span><br><span class="line">    <span class="type">unsigned</span> depth; <span class="comment">// 链接深度</span></span><br><span class="line">    <span class="type">int</span> total_link_count; <span class="comment">// 总的链接数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> &#123;</span> <span class="comment">// 保存结构，用于链接跟踪</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">link</span>;</span> <span class="comment">// 链接路径</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">delayed_call</span> <span class="title">done</span>;</span> <span class="comment">// 延迟调用</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name; <span class="comment">// 链接名称</span></span><br><span class="line">        <span class="type">unsigned</span> seq; <span class="comment">// 序列号</span></span><br><span class="line">    &#125; *<span class="built_in">stack</span>, internal[EMBEDDED_LEVELS]; <span class="comment">// 保存结构的栈和内部数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">name</span>;</span> <span class="comment">// 文件名对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">saved</span>;</span> <span class="comment">// 指向保存的nameidata结构</span></span><br><span class="line">    <span class="type">unsigned</span> root_seq; <span class="comment">// 根路径序列号</span></span><br><span class="line">    <span class="type">int</span> dfd; <span class="comment">// 目录文件描述符</span></span><br><span class="line">    <span class="type">vfsuid_t</span> dir_vfsuid; <span class="comment">// 目录的VFS用户ID</span></span><br><span class="line">    <span class="type">umode_t</span> dir_mode; <span class="comment">// 目录的模式 (权限)</span></span><br><span class="line">&#125; __randomize_layout; <span class="comment">// 随机化布局属性</span></span><br></pre></td></tr></table></figure>

<p>path包含了找到的文件系统项的数据，path结构包含dentry和mnt。</p>
<p>下面看到这个调用链</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">open</span><span class="params">()</span></span></span><br><span class="line">    └── do_sys_open</span><br><span class="line">        └── do_filp_open</span><br><span class="line">            ├── path_openat</span><br><span class="line">            │    ├── link_path_walk</span><br><span class="line">            │    │     ├── lookup_fast</span><br><span class="line">            │    │     │     └── __d_lookup_rcu</span><br><span class="line">            │    │     │         └── hlist_bl_for_each_entry_rcu</span><br><span class="line">            │    │     └── lookup_slow</span><br><span class="line">            │    │            └── __lookup_slow</span><br><span class="line">            │    │               └──simple_lookup</span><br><span class="line">            │    └── open_last_lookups（创建新文件）</span><br><span class="line">            │          └──shmem_create</span><br><span class="line">            │                 └── shmem_mknod</span><br><span class="line">            └── do_open</span><br><span class="line">                  └── vfs_open</span><br><span class="line">                        └── do_dentry_open</span><br></pre></td></tr></table></figure>

<p>首先在open()系统调用中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 open 的系统调用，该调用接受三个参数：filename（文件名），flags（标志）和 mode（模式）</span></span><br><span class="line">SYSCALL_DEFINE3(open, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">int</span>, flags, <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果需要处理大文件，将 O_LARGEFILE 标志添加到 flags 中</span></span><br><span class="line">    <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">        flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 do_sys_open 函数，传入当前工作目录的文件描述符 AT_FDCWD、filename、flags 和 mode 参数</span></span><br><span class="line">    <span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传入AT_FDCWD到do_sys_open函数中，即为当前工作目录的文件描述符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://tldp.org/LDP/khg/HyperNews/get/fs/vfstour.html">A tour of the Linux VFS (tldp.org)</a></p>
</li>
<li><p><a href="http://www.science.unitn.it/~fiorella/guidelinux/tlk/node102.html#vfsfigure">The Virtual File System (VFS) — 虚拟文件系统 （VFS） (unitn.it)</a></p>
</li>
<li><p><a href="https://www.win.tue.nl/~aeb/linux/lk/lk-8.html">The Linux kernel: The Linux Virtual File System — Linux 内核：Linux 虚拟文件系统 (tue.nl)</a></p>
</li>
<li><p><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/10986803?fromtitle=VFS&fromid=7519887">虚拟文件系统_百度百科 (baidu.com)</a></p>
</li>
<li><p><a href="https://ty-chen.github.io/linux-kernel-vfs/">Linux操作系统学习笔记（十二）虚拟文件系统 | Ty-Chen’s Home</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/Virtual_file_system">Virtual file system - Wikipedia — 虚拟文件系统 - 维基百科</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_39278265/article/details/88839027">[高级操作系统] VFS详解（虚拟文件系统）_宇内虹游的博客-CSDN博客</a></p>
</li>
<li><p><a href="https://en.wikipedia.org/wiki/File_system">File system - Wikipedia</a></p>
</li>
<li><p><a href="https://www.cs.jhu.edu/~yairamir/cs418/600-418.html">Yair Amir lectures (jhu.edu)</a></p>
</li>
<li><p><a href="http://www.2cto.com/os/201110/108845.html">linux虚拟文件系统浅析 - Linux操作系统：Ubuntu_Centos_Debian - 红黑联盟 (2cto.com)</a></p>
</li>
</ul>
]]></content>
  </entry>
</search>
