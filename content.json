{"meta":{"title":"Plucky","subtitle":"Comfortably Numb","description":"è®°å½•","author":"Plucky","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-06-23T08:09:59.000Z","updated":"2023-03-01T09:00:29.431Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"é¥¥é¥¿è‰ºæœ¯å®¶"},{"title":"categories","date":"2022-06-23T11:37:54.000Z","updated":"2022-06-23T11:44:50.961Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-23T11:37:08.000Z","updated":"2022-06-23T11:42:25.423Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2023-03-31T04:34:08.000Z","updated":"2023-05-12T13:02:28.648Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":"Friend Link Solar1s Hammour Placebo"}],"posts":[{"title":"å­¦ä¹  Linux container_of()","slug":"å­¦ä¹ -Linux-container-of","date":"2023-11-09T07:05:56.000Z","updated":"2023-11-18T08:59:40.290Z","comments":true,"path":"2023/11/09/å­¦ä¹ -Linux-container-of/","link":"","permalink":"http://example.com/2023/11/09/%E5%AD%A6%E4%B9%A0-Linux-container-of/","excerpt":"container_ofå®šä¹‰container_of.h - include&#x2F;linux&#x2F;container_of.h - Linux source code (v6.6) - Bootlin 1234567891011121314/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * * WARNING: any const qualifier of @ptr is lost. */#define container_of(ptr, type, member) (&#123; \\ void *__mptr = (void *)(ptr); \\ static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) || \\ __same_type(*(ptr), void), \\ &quot;pointer type mismatch in container_of()&quot;); \\ ((type *)(__mptr - offsetof(type, member))); &#125;)","text":"container_ofå®šä¹‰container_of.h - include&#x2F;linux&#x2F;container_of.h - Linux source code (v6.6) - Bootlin 1234567891011121314/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * * WARNING: any const qualifier of @ptr is lost. */#define container_of(ptr, type, member) (&#123; \\ void *__mptr = (void *)(ptr); \\ static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) || \\ __same_type(*(ptr), void), \\ &quot;pointer type mismatch in container_of()&quot;); \\ ((type *)(__mptr - offsetof(type, member))); &#125;) å®ƒçš„ä¸»è¦ä½œç”¨æ˜¯ï¼šæ ¹æ®ç»“æ„ä½“æŸä¸€æˆå‘˜çš„åœ°å€ï¼Œè·å–è¿™ä¸ªç»“æ„ä½“çš„é¦–åœ°å€ã€‚æ ¹æ®å®å®šä¹‰ï¼Œå¯çŸ¥è¿™ä¸ªå®æœ‰ä¸‰ä¸ªå‚æ•°ï¼š type ç»“æ„ä½“ç±»å‹ ptr ç»“æ„ä½“å†…memberæˆå‘˜çš„åœ°å€ member ç»“æ„ä½“å†…çš„æˆå‘˜ container_ofçš„ç”¨æ³•è¿™ä¸ªå®åœ¨å†…æ ¸ä¸­éå¸¸é‡è¦ã€‚åœ¨å†…æ ¸ä¸­ä¼šç»å¸¸æœ‰è¿™æ ·çš„éœ€æ±‚ï¼šæˆ‘ä»¬ä¼ é€’ç»™æŸä¸ªå‡½æ•°çš„å‚æ•°æ˜¯æŸä¸ªç»“æ„ä½“çš„æˆå‘˜å˜é‡ï¼Œç„¶ååœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œå¯èƒ½è¿˜ä¼šç”¨åˆ°æ­¤ç»“æ„ä½“çš„å…¶å®ƒæˆå‘˜å˜é‡ï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™æ€ä¹ˆåŠå‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ container_of å…ˆé€šè¿‡ç»“æ„ä½“æŸä¸€æˆå‘˜çš„è®¿é—®æ‰¾åˆ°è¿™ä¸ªç»“æ„ä½“çš„é¦–åœ°å€ï¼Œç„¶åå°±å¯ä»¥è®¿é—®å…¶å®ƒæˆå‘˜å˜é‡äº†ã€‚ 12345678910111213141516171819struct _box_t&#123; double length; // ç›’å­çš„é•¿åº¦ double breadth; // ç›’å­çš„å®½åº¦ double height; // ç›’å­çš„é«˜åº¦&#125;;int main(void)&#123; struct _box_t box = &#123;30.0, 20.0, 10.0&#125;; struct _box_t *p_box = NULL; p_box = container_of(&amp;box.height, struct _box_t, height); printf(&quot;%p\\n&quot;, p_box); printf(&quot;length: %f\\n&quot;, p_box-&gt;length); printf(&quot;breadth: %f\\n&quot;, p_box-&gt;breadth); return 0;&#125; åœ¨è¿™ä¸ªç¨‹åºä¸­ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªç»“æ„ä½“å˜é‡ boxï¼ŒçŸ¥é“äº†å®ƒçš„æˆå‘˜å˜é‡ height çš„åœ°å€ &amp;box.heightï¼Œå°±å¯ä»¥é€šè¿‡ container_of å®ç›´æ¥è·å¾— box ç»“æ„ä½“å˜é‡çš„é¦–åœ°å€ï¼Œç„¶åç›´æ¥è®¿é—® box ç»“æ„ä½“çš„å…¶å®ƒæˆå‘˜ p_box-&gt;length å’Œ p_box-&gt;breadthã€‚ å‚è€ƒ Linux å†…æ ¸ container_of å®è¯¦è§£_ç§¯æ­¥åƒé‡Œçš„åšå®¢-CSDNåšå®¢","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Cè¯­è¨€ å®","slug":"Cè¯­è¨€-å®","date":"2023-11-08T08:57:20.000Z","updated":"2023-11-08T09:20:49.194Z","comments":true,"path":"2023/11/08/Cè¯­è¨€-å®/","link":"","permalink":"http://example.com/2023/11/08/C%E8%AF%AD%E8%A8%80-%E5%AE%8F/","excerpt":"#defineç›¸å…³çŸ¥è¯† å¤§è‡´ç»“æ„ 12#define name stuff è‡ªå®šä¹‰å å†…å®¹","text":"#defineç›¸å…³çŸ¥è¯† å¤§è‡´ç»“æ„ 12#define name stuff è‡ªå®šä¹‰å å†…å®¹ å®å®šä¹‰æ˜¯C&#x2F;C++è¯­è¨€ä¸­çš„ä¸€ç§é¢„å¤„ç†æŒ‡ä»¤ï¼Œå¯ä»¥ç”¨æ¥å®šä¹‰å¸¸é‡ã€å‡½æ•°ä»¥åŠä»£ç ç‰‡æ®µã€‚åœ¨ä»£ç ä¸­åˆç†ä½¿ç”¨å®å®šä¹‰å¯ä»¥æé«˜ä»£ç çš„å¯è¯»æ€§ã€å¯ç»´æŠ¤æ€§å’Œå¯é‡ç”¨æ€§ã€‚ å®šä¹‰å¸¸é‡åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸éœ€è¦ä½¿ç”¨ä¸€äº›å¸¸é‡ï¼Œå¦‚Ï€ã€eç­‰ï¼Œå¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥å®šä¹‰è¿™äº›å¸¸é‡ï¼Œä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†Ï€çš„å€¼å¹¶ä½¿ç”¨ï¼š 12#define PI 3.14159265358979323846double area = PI * r * r; å®šä¹‰å‡½æ•°åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥å®šä¹‰å‡½æ•°ã€‚ä¸ä½¿ç”¨å‡½æ•°å®šä¹‰ä¸åŒï¼Œä½¿ç”¨å®å®šä¹‰å®šä¹‰çš„å‡½æ•°åœ¨ä»£ç ä¸­å°†è¢«æ›¿æ¢ä¸ºå®å®šä¹‰ä¸­çš„ä»£ç ç‰‡æ®µï¼Œä»è€Œå‡å°‘äº†å‡½æ•°è°ƒç”¨çš„å¼€é”€ï¼Œæé«˜äº†ä»£ç çš„æ€§èƒ½ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªæ±‚å¹³æ–¹çš„å®å®šä¹‰ï¼š 123#define SQUARE(x) ((x)*(x))int a = 3;int b = SQUARE(a); // b = 9 éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨å®å®šä¹‰å®šä¹‰å‡½æ•°ä¹Ÿæœ‰ä¸€äº›é™åˆ¶ï¼Œå¦‚ä¸èƒ½ä½¿ç”¨returnè¯­å¥ç­‰ã€‚ å‚æ•°åŒ–å®å®šä¹‰åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å‚æ•°æ¥å®šä¹‰å®å®šä¹‰ï¼Œä»è€Œä½¿å®å®šä¹‰æ›´åŠ çµæ´»å’Œå¯é‡ç”¨ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå‚æ•°åŒ–å®å®šä¹‰ï¼Œç”¨æ¥æ¯”è¾ƒä¸¤ä¸ªæ•°çš„å¤§å° 12345#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))...int a = 3;int b = 5;int max = MAX(a, b); // max = 5 ä½¿ç”¨å‚æ•°åŒ–å®å®šä¹‰å¯ä»¥æ–¹ä¾¿åœ°å®šä¹‰ä¸€äº›é€šç”¨çš„ä»£ç ç‰‡æ®µï¼Œæé«˜ä»£ç çš„å¯é‡ç”¨æ€§ã€‚ ä½¿ç”¨#ifdefä¿æŠ¤å®å®šä¹‰åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨#ifdefæ¥ä¿æŠ¤å®å®šä¹‰ï¼Œä»¥é˜²æ­¢å¤šæ¬¡å®šä¹‰æˆ–æœªå®šä¹‰ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç ä½¿ç”¨#ifdefè¯­å¥æ¥ä¿æŠ¤ä¸€ä¸ªå®å®šä¹‰ï¼š 123#ifndef SQUARE#define SQUARE(x) ((x)*(x))#endif è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œå¦‚æœSQUAREå®æ²¡æœ‰è¢«å®šä¹‰ï¼Œé‚£ä¹ˆå°±å®šä¹‰å®ƒã€‚å¦‚æœå·²ç»è¢«å®šä¹‰äº†ï¼Œé‚£ä¹ˆå°±è·³è¿‡è¿™ä¸ªå®šä¹‰ã€‚è¿™æ ·å¯ä»¥é¿å…åœ¨å¤šä¸ªæ–‡ä»¶ä¸­å¤šæ¬¡å®šä¹‰åŒä¸€ä¸ªå®ï¼Œä»è€Œå‡å°‘ç¼–è¯‘é”™è¯¯çš„å‘ç”Ÿã€‚ ä½¿ç”¨å®å®šä¹‰è¿›è¡Œè°ƒè¯•åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œè°ƒè¯•ï¼Œä»¥ä¾¿åœ¨éœ€è¦æ—¶æ‰“å°è¾“å‡ºè°ƒè¯•ä¿¡æ¯ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå®æ¥è¾“å‡ºè°ƒè¯•ä¿¡æ¯ï¼š 12345#ifdef DEBUG#define DEBUG_PRINT(x) printf x#else#define DEBUG_PRINT(x) do &#123;&#125; while (0)#endif è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œå¦‚æœå®šä¹‰äº†DEBUGå®ï¼Œé‚£ä¹ˆå°±ä½¿ç”¨printfå‡½æ•°è¾“å‡ºè°ƒè¯•ä¿¡æ¯ã€‚å¦åˆ™ï¼Œå°±ä½¿ç”¨ä¸€ä¸ªç©ºè¯­å¥å—æ¥å¿½ç•¥è¿™ä¸ªå®ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨DEBUG_PRINTå®å¯ä»¥æ–¹ä¾¿åœ°è¾“å‡ºè°ƒè¯•ä¿¡æ¯ï¼Œè€Œåœ¨æ­£å¼å‘å¸ƒæ—¶åªéœ€è¦å°†DEBUGå®æ³¨é‡Šæ‰å³å¯ã€‚ ä½¿ç”¨å®å®šä¹‰è¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥ï¼Œä»è€Œæ–¹ä¾¿åœ°ç”Ÿæˆä¸€äº›ä»£ç ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå®æ¥è¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥ï¼š 1234#define STRINGIFY(x) #x#define STRING_CONCAT(x, y) x##yint STRING_CONCAT(a, 1) = 2;const char* str = STRINGIFY(hello world); è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œä½¿ç”¨STRINGIFYå®å¯ä»¥å°†ä¸€ä¸ªå®å®šä¹‰è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œä½¿ç”¨STRING_CONCATå®å¯ä»¥å°†ä¸¤ä¸ªå®å®šä¹‰æ‹¼æ¥åœ¨ä¸€èµ·ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ä¸¤ä¸ªå®å¯ä»¥æ–¹ä¾¿åœ°ç”Ÿæˆä¸€äº›å­—ç¬¦ä¸²å¸¸é‡å’Œå˜é‡åã€‚ ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œæ¡ä»¶ç¼–è¯‘åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œæ¡ä»¶ç¼–è¯‘ï¼Œä»¥ä¾¿æ ¹æ®ä¸åŒçš„æ¡ä»¶ç¼–è¯‘ä¸åŒçš„ä»£ç ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå®æ¥æ§åˆ¶æ˜¯å¦ç¼–è¯‘æŸæ®µä»£ç ï¼š 12345#ifdef DEBUG// debug code#else// release code#endif è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œå¦‚æœå®šä¹‰äº†DEBUGå®ï¼Œé‚£ä¹ˆå°±ç¼–è¯‘debug codeï¼Œå¦åˆ™å°±ç¼–è¯‘release codeã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨#ifdefè¯­å¥å¯ä»¥æ ¹æ®ä¸åŒçš„æ¡ä»¶ç¼–è¯‘ä¸åŒçš„ä»£ç ï¼Œä»è€Œæ–¹ä¾¿åœ°è¿›è¡Œè°ƒè¯•å’Œå‘å¸ƒã€‚ ä½¿ç”¨å®å®šä¹‰è¿›è¡Œç±»å‹è½¬æ¢åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œç±»å‹è½¬æ¢ï¼Œä»è€Œæ–¹ä¾¿åœ°å°†ä¸€ç§ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå®æ¥å°†ä¸€ä¸ªæŒ‡é’ˆè½¬æ¢ä¸ºä¸€ä¸ªæ•´æ•°ï¼š 123#define PTR2INT(p) ((int)(intptr_t)(p))int* p = new int(10);int n = PTR2INT(p); è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œä½¿ç”¨PTR2INTå®å¯ä»¥å°†ä¸€ä¸ªæŒ‡é’ˆè½¬æ¢ä¸ºä¸€ä¸ªæ•´æ•°ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ä¸ªå®å¯ä»¥æ–¹ä¾¿åœ°è¿›è¡Œç±»å‹è½¬æ¢ï¼Œä»è€Œæ–¹ä¾¿åœ°è¿›è¡Œä¸€äº›æ“ä½œã€‚ ä½¿ç”¨å®å®šä¹‰è¿›è¡Œä½æ“ä½œåœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œä½æ“ä½œï¼Œä»è€Œæ–¹ä¾¿åœ°è¿›è¡Œä¸€äº›ä½è¿ç®—ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€äº›å®æ¥è¿›è¡Œä½æ“ä½œï¼š 123456789101112#define SET_BIT(x, n) ((x) |= (1 &lt;&lt; (n)))#define CLEAR_BIT(x, n) ((x) &amp;= ~(1 &lt;&lt; (n)))#define TOGGLE_BIT(x, n) ((x) ^= (1 &lt;&lt; (n)))#define TEST_BIT(x, n) ((x) &amp; (1 &lt;&lt; (n)))unsigned int num = 0x12345678;SET_BIT(num, 3); // set the 3rd bit to 1CLEAR_BIT(num, 7); // clear the 7th bit to 0TOGGLE_BIT(num, 15); // toggle the 15th bitif (TEST_BIT(num, 2)) &#123; // test the 2nd bit // do something&#125; è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œä½¿ç”¨SET_BITå®å¯ä»¥å°†ä¸€ä¸ªæ•°çš„æŸä¸€ä½è®¾ç½®ä¸º1ï¼Œä½¿ç”¨CLEAR_BITå®å¯ä»¥å°†ä¸€ä¸ªæ•°çš„æŸä¸€ä½æ¸…é›¶ï¼Œä½¿ç”¨TOGGLE_BITå®å¯ä»¥å°†ä¸€ä¸ªæ•°çš„æŸä¸€ä½å–åï¼Œä½¿ç”¨TEST_BITå®å¯ä»¥æµ‹è¯•ä¸€ä¸ªæ•°çš„æŸä¸€ä½æ˜¯å¦ä¸º1ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™äº›å®å¯ä»¥æ–¹ä¾¿åœ°è¿›è¡Œä½æ“ä½œï¼Œä»è€Œæ–¹ä¾¿åœ°è¿›è¡Œä¸€äº›æ“ä½œã€‚ ä½¿ç”¨å®å®šä¹‰è¿›è¡Œå˜é‡å®šä¹‰åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œå˜é‡å®šä¹‰ï¼Œä»è€Œæ–¹ä¾¿åœ°ç”Ÿæˆä¸€äº›å¸¸é‡æˆ–å˜é‡ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå®æ¥ç”Ÿæˆä¸€ä¸ªå¸¸é‡ï¼š 1234#define DEFINE_CONST(type, name, value) \\\\\\\\ const type name = value;DEFINE_CONST(int, MAX_NUM, 100); è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œä½¿ç”¨DEFINE_CONSTå®å¯ä»¥æ–¹ä¾¿åœ°ç”Ÿæˆä¸€ä¸ªå¸¸é‡ï¼Œå®ƒçš„ç±»å‹ã€åç§°å’Œå€¼éƒ½ç”±å®å®šä¹‰ä¼ å…¥ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ä¸ªå®å¯ä»¥æ–¹ä¾¿åœ°ç”Ÿæˆä¸€äº›å¸¸é‡ï¼Œä»è€Œæ–¹ä¾¿åœ°è¿›è¡Œä¸€äº›æ“ä½œã€‚ ä½¿ç”¨å®å®šä¹‰è¿›è¡Œå¼‚å¸¸å¤„ç†åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œå¼‚å¸¸å¤„ç†ï¼Œä»è€Œæ–¹ä¾¿åœ°å‘ç°å’Œå¤„ç†å¼‚å¸¸ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå®æ¥æ£€æŸ¥ä¸€ä¸ªæŒ‡é’ˆæ˜¯å¦ä¸ºç©ºï¼š 123456789#define CHECK_PTR(ptr) do &#123; if ((ptr) == nullptr) &#123; throw std::invalid_argument(&quot;null pointer&quot;); &#125; &#125; while (0)int* p = nullptr;CHECK_PTR(p); // throw an exception è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œä½¿ç”¨CHECK_PTRå®å¯ä»¥æ–¹ä¾¿åœ°æ£€æŸ¥ä¸€ä¸ªæŒ‡é’ˆæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºå°±æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ä¸ªå®å¯ä»¥æ–¹ä¾¿åœ°è¿›è¡Œå¼‚å¸¸å¤„ç†ï¼Œä»è€Œæ–¹ä¾¿åœ°å‘ç°å’Œå¤„ç†å¼‚å¸¸ã€‚ ä½¿ç”¨å®å®šä¹‰è¿›è¡Œå¤šçº¿ç¨‹ç¼–ç¨‹åœ¨C&#x2F;C++ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®å®šä¹‰æ¥è¿›è¡Œå¤šçº¿ç¨‹ç¼–ç¨‹ï¼Œä»è€Œæ–¹ä¾¿åœ°åˆ›å»ºå’Œæ“ä½œçº¿ç¨‹ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªå®æ¥åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼š 1234567891011#define CREATE_THREAD(func, arg) do &#123; std::thread t(func, arg); t.detach(); &#125; while (0)void* thread_func(void* arg) &#123; // do something return nullptr;&#125;CREATE_THREAD(thread_func, nullptr); è¿™æ®µä»£ç çš„æ„æ€æ˜¯ï¼Œä½¿ç”¨CREATE_THREADå®å¯ä»¥æ–¹ä¾¿åœ°åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œå®ƒçš„å‡½æ•°å’Œå‚æ•°éƒ½ç”±å®å®šä¹‰ä¼ å…¥ã€‚åœ¨ä»£ç ä¸­ä½¿ç”¨è¿™ä¸ªå®å¯ä»¥æ–¹ä¾¿åœ°è¿›è¡Œå¤šçº¿ç¨‹ç¼–ç¨‹ï¼Œä»è€Œæ–¹ä¾¿åœ°åˆ›å»ºå’Œæ“ä½œçº¿ç¨‹ã€‚ å‚è€ƒèµ„æ–™ C&#x2F;C++è¯­è¨€ä¸­çš„å®å®šä¹‰æŠ€å·§ - çŸ¥ä¹ (zhihu.com) Cè¯­è¨€ä¹‹å®è¯¦è§£ï¼ˆè¶…çº§è¯¦ç»†ï¼ï¼‰_cè¯­è¨€å®å®šä¹‰è¯¦è§£-CSDNåšå®¢","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"R4L:ç¼–è¯‘Rust for Linux","slug":"R4L-ç¼–è¯‘Rust-for-Linux","date":"2023-10-07T08:39:05.000Z","updated":"2023-10-11T06:30:55.873Z","comments":true,"path":"2023/10/07/R4L-ç¼–è¯‘Rust-for-Linux/","link":"","permalink":"http://example.com/2023/10/07/R4L-%E7%BC%96%E8%AF%91Rust-for-Linux/","excerpt":"è·å–rust for linuxæºç å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤ç›´æ¥ä»githubä¸Šä¸‹è½½æºç  1git clone git@github.com:Rust-for-Linux/linux.git","text":"è·å–rust for linuxæºç å¯ä»¥é€šè¿‡ä»¥ä¸‹å‘½ä»¤ç›´æ¥ä»githubä¸Šä¸‹è½½æºç  1git clone git@github.com:Rust-for-Linux/linux.git ç¼–è¯‘æ„å»ºå†…æ ¸æºç ç¯å¢ƒéƒ¨ç½² åŸºæœ¬å¿…å¤‡è½¯ä»¶å®‰è£… 12sudo apt install libncurses-dev flex bison openssl libssl-dev \\ dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf å®‰è£…rustup 1curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh é…ç½®rustupç¯å¢ƒå˜é‡ï¼ˆå®‰è£…å®Œrustupä¼šæé†’ï¼‰ 1source &quot;/root/.cargo/env&quot;&quot; å®‰è£…rustc 1rustup override set $(scripts/min-tool-version.sh rustc) 1rustup component add rust-src å®‰è£…llvm&#x2F;clangå¥—ä»¶ 1sudo apt install llvm lld libclang-dev å®‰è£…bingen 1cargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen é…ç½®å¯ç”¨æ”¯æŒrustçš„å†…æ ¸å‚æ•°å¦‚æœä¸Šè¿°å·¥å…·é“¾æ­£ç¡®ï¼Œè¿è¡Œä¸‹åˆ—å‘½ä»¤ 1make LLVM=1 rustavailable åˆ™ä¼šå‡ºç°Rust is aviliableé‚£ä¹ˆæ¥ä¸‹æ¥å°±å¯ä»¥è¿›è¡Œç¼–è¯‘å†…æ ¸ æ‰§è¡ŒGeneral setup -&gt; Rust supportå¯ç”¨ è¿è¡Œ 1make menuconfig å‡ºç°å›¾å½¢åŒ–ç•Œé¢ï¼Œå¦‚æœGeneral setupä¸­æ²¡æœ‰å‡ºç°Rust supprotï¼Œåˆ™æŒ‰/æœç´¢RUST å¯ä»¥çœ‹åˆ° 1Depends on: HAVE_RUST [=y] &amp;&amp; RUST_IS_AVAILABLE [=y] &amp;&amp; !MODVERSIONS [=n] &amp;&amp; !GCC_PLUGINS [=n] &amp;&amp; !RANDSTRUCT [=n] &amp;&amp; (!DEBUG_INFO_BTF [=n] ||PAHOLE_HAS_LANG_EXCLUDE [=n]) æ‰€ä»¥æ ¹æ®è¿™ä¸ªå¯ä»¥å¾—åˆ°ï¼š HAVE_RUST &#x3D; y RUST_IS_AVAILABLE &#x3D; y MODVERSIONS &#x3D; n GCC_PLUGINS &#x3D; n RANDSTRUCT &#x3D; n (!DEBUG_INFO_BTF [&#x3D;n] ||PAHOLE_HAS_LANG_EXCLUDE [&#x3D;n])ä¹Ÿå°±æ˜¯è¯´ DEBUG_INFO_BTF &#x3D; næˆ–è€…PAHOLE_HAS_LANG_EXCLUDE &#x3D; y å¦‚æœä¸Šè¿°æ¡ä»¶æ²¡æœ‰è¾¾æˆï¼Œåˆ™æŒ‰/æœç´¢å¯¹åº”çš„æ¡ä»¶ï¼Œå¹¶è¿›è¡Œä¿®æ”¹ï¼Œä¿®æ”¹å®Œæˆä¹‹åå°±å¯ä»¥æ‰¾åˆ°Rust Supporté€‰é¡¹ Kernel hacking-&gt;Sample kernel code-&gt;Rust sample å¯ç”¨ ä¹‹åé€€å‡ºå¹¶ä¿å­˜ ç¼–è¯‘æºç 1make LLVM=1 -j$(nproc) é”™è¯¯è§£å†³ ERROR: modpost: â€œriscv_cbom_block_sizeâ€ undefined è¯¥é”™è¯¯å‡ºç°åœ¨ç¼–è¯‘è™šæ‹ŸåŒ–æ¨¡å—kvmæ—¶å‡ºç°ï¼Œåœ¨å†…æ ¸é…ç½®ä¸­å…³æ‰è¿™ä¸ªæ¨¡å—å³å¯: â€œKernel-based Virtual Machine (KVM) supportâ€ make[3]: *** No rule to make target â€˜debian&#x2F;canonical-certs.pemâ€™, needed by â€˜certs&#x2F;x509_certificate_listâ€™. Stop. ç¼–è¾‘.configæ–‡ä»¶(åˆšæ‰åœ¨ç»ˆç«¯ä¸­æ‰§è¡Œè¿‡é…ç½®å†…æ ¸çš„å‘½ä»¤#make menuconfig åä¼šåœ¨è¯¥ç›®å½•ä¸‹ç”Ÿæˆä¸€ä¸ªéšè—æ–‡ä»¶.config) ä¿®æ”¹CONFIG_SYSTEM_TRUSTED_KEYSï¼Œå°†å…¶èµ‹ç©ºå€¼ ä¿®æ”¹å‰ï¼š 1CONFIG_SYSTEM_TRUSTED_KEYS=&quot;debian/canonical-certs.pem&quot; ä¿®æ”¹åï¼š 1CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot; make[3]: *** No rule to make target â€˜debian&#x2F;canonical-revoked-certs.pemâ€™, needed by â€˜certs&#x2F;x509_revocation_listâ€™. Stop. å‚è€ƒé”™è¯¯2","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 15 ç”Ÿå‘½å‘¨æœŸè¿›é˜¶","slug":"Rustå­¦ä¹ -ç»ƒä¹ 14-ç”Ÿå‘½å‘¨æœŸè¿›é˜¶","date":"2023-09-27T01:19:11.000Z","updated":"2023-09-27T03:26:14.582Z","comments":true,"path":"2023/09/27/Rustå­¦ä¹ -ç»ƒä¹ 14-ç”Ÿå‘½å‘¨æœŸè¿›é˜¶/","link":"","permalink":"http://example.com/2023/09/27/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A014-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%9B%E9%98%B6/","excerpt":"&amp;â€™static and T: â€˜static&#39;static æ˜¯ä¸€ä¸ª Rust ä¿ç•™çš„ç”Ÿå‘½å‘¨æœŸåç§°ï¼Œåœ¨ä¹‹å‰æˆ‘ä»¬å¯èƒ½å·²ç»è§è¿‡å¥½å‡ æ¬¡äº†: 12345678910#![allow(unused)]fn main() &#123;// å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ &#x27;static :let s: &amp;&#x27;static str = &quot;hello world&quot;;// &#x27;static ä¹Ÿå¯ä»¥ç”¨äºç‰¹å¾çº¦æŸä¸­:fn generic&lt;T&gt;(x: T) where T: &#x27;static &#123;&#125;&#125;","text":"&amp;â€™static and T: â€˜static&#39;static æ˜¯ä¸€ä¸ª Rust ä¿ç•™çš„ç”Ÿå‘½å‘¨æœŸåç§°ï¼Œåœ¨ä¹‹å‰æˆ‘ä»¬å¯èƒ½å·²ç»è§è¿‡å¥½å‡ æ¬¡äº†: 12345678910#![allow(unused)]fn main() &#123;// å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ &#x27;static :let s: &amp;&#x27;static str = &quot;hello world&quot;;// &#x27;static ä¹Ÿå¯ä»¥ç”¨äºç‰¹å¾çº¦æŸä¸­:fn generic&lt;T&gt;(x: T) where T: &#x27;static &#123;&#125;&#125; è™½ç„¶å®ƒä»¬éƒ½æ˜¯ &#39;staticï¼Œä½†æ˜¯ä¹Ÿç¨æœ‰ä¸åŒã€‚ &amp;â€™staticä½œä¸ºä¸€ä¸ªå¼•ç”¨ç”Ÿå‘½å‘¨æœŸï¼Œ&amp;&#39;static è¯´æ˜è¯¥å¼•ç”¨æŒ‡å‘çš„æ•°æ®å¯ä»¥è·Ÿç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œä½†æ˜¯è¯¥å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸä¾ç„¶æœ‰å¯èƒ½è¢«å¼ºè½¬ä¸ºä¸€ä¸ªæ›´çŸ­çš„ç”Ÿå‘½å‘¨æœŸã€‚ ğŸŒŸğŸŒŸ æœ‰å¥½å‡ ç§æ–¹æ³•å¯ä»¥å°†ä¸€ä¸ªå˜é‡æ ‡è®°ä¸º &#39;static ç”Ÿå‘½å‘¨æœŸ, å…¶ä¸­ä¸¤ç§éƒ½æ˜¯å’Œä¿å­˜åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ç›¸å…³( ä¾‹å¦‚å­—ç¬¦ä¸²å­—é¢é‡å°±æ˜¯ä¿å­˜åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸæ˜¯ &#39;static )ã€‚ 12345678910111213/* ä½¿ç”¨ä¸¤ç§æ–¹æ³•å¡«ç©º */fn main() &#123; __; need_static(v); println!(&quot;Success!&quot;)&#125;fn need_static(r : &amp;&#x27;static str) &#123; assert_eq!(r, &quot;hello&quot;);&#125; My Answer 12345678910111213/* ä½¿ç”¨ä¸¤ç§æ–¹æ³•å¡«ç©º */fn main() &#123; let v = &quot;hello&quot;; need_static(v); println!(&quot;Success!&quot;)&#125;fn need_static(r : &amp;&#x27;static str) &#123; assert_eq!(r, &quot;hello&quot;);&#125; 12345678910fn main() &#123; const v: &amp;str = &quot;hello&quot;; need_static(v); println!(&quot;Success!&quot;)&#125;fn need_static(r : &amp;&#x27;static str) &#123; assert_eq!(r, &quot;hello&quot;);&#125; ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ ä½¿ç”¨ Box::leak ä¹Ÿå¯ä»¥äº§ç”Ÿ &#39;static ç”Ÿå‘½å‘¨æœŸ 123456789101112131415161718192021222324#[derive(Debug)]struct Config &#123; a: String, b: String,&#125;static mut config: Option&lt;&amp;mut Config&gt; = None;/* è®©ä»£ç å·¥ä½œï¼Œä½†ä¸è¦ä¿®æ”¹å‡½æ•°çš„ç­¾å */fn init() -&gt; Option&lt;&amp;&#x27;static mut Config&gt; &#123; Some(&amp;mut Config &#123; a: &quot;A&quot;.to_string(), b: &quot;B&quot;.to_string(), &#125;)&#125;fn main() &#123; unsafe &#123; config = init(); println!(&quot;&#123;:?&#125;&quot;,config) &#125;&#125; Answer 123456789101112131415161718192021222324#[derive(Debug)]struct Config &#123; a: String, b: String,&#125;static mut config: Option&lt;&amp;mut Config&gt; = None;fn init() -&gt; Option&lt;&amp;&#x27;static mut Config&gt; &#123; let c = Box::new(Config &#123; a: &quot;A&quot;.to_string(), b: &quot;B&quot;.to_string(), &#125;); Some(Box::leak(c))&#125;fn main() &#123; unsafe &#123; config = init(); println!(&quot;&#123;:?&#125;&quot;,config) &#125;&#125; ğŸŒŸ &amp;&#39;static åªèƒ½è¯´æ˜å¼•ç”¨æŒ‡å‘çš„æ•°æ®æ˜¯èƒ½ä¸€ç›´å­˜æ´»çš„ï¼Œä½†æ˜¯å¼•ç”¨æœ¬èº«ä¾ç„¶å—é™äºå®ƒçš„ä½œç”¨åŸŸ 123456789101112fn main() &#123; &#123; // å­—ç¬¦ä¸²å­—é¢é‡èƒ½è·Ÿç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå› æ­¤ `static_string` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `&#x27;static` let static_string = &quot;I&#x27;m in read-only memory&quot;; println!(&quot;static_string: &#123;&#125;&quot;, static_string); // å½“ `static_string` è¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œè¯¥å¼•ç”¨å°±æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å¼•ç”¨æŒ‡å‘çš„æ•°æ®( å­—ç¬¦ä¸²å­—é¢é‡ ) ä¾ç„¶ä¿å­˜åœ¨äºŒè¿›åˆ¶ binary æ‰€å ç”¨çš„å†…å­˜ä¸­ &#125; println!(&quot;static_string reference remains alive: &#123;&#125;&quot;, static_string);&#125; My Answer 12345678910fn main() &#123; // å­—ç¬¦ä¸²å­—é¢é‡èƒ½è·Ÿç¨‹åºæ´»å¾—ä¸€æ ·ä¹…ï¼Œå› æ­¤ `static_string` çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ `&#x27;static` let static_string = &quot;I&#x27;m in read-only memory&quot;; println!(&quot;static_string: &#123;&#125;&quot;, static_string); // å½“ `static_string` è¶…å‡ºä½œç”¨åŸŸæ—¶ï¼Œè¯¥å¼•ç”¨å°±æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å¼•ç”¨æŒ‡å‘çš„æ•°æ®( å­—ç¬¦ä¸²å­—é¢é‡ ) ä¾ç„¶ä¿å­˜åœ¨äºŒè¿›åˆ¶ binary æ‰€å ç”¨çš„å†…å­˜ä¸­ println!(&quot;static_string reference remains alive: &#123;&#125;&quot;, static_string);&#125; Answer 1234567fn main() &#123; // Make a `string` literal and print it: let static_string = &quot;I&#x27;m in read-only memory&quot;; println!(&quot;static_string: &#123;&#125;&quot;, static_string); println!(&quot;static_string reference remains alive: &#123;&#125;&quot;, static_string);&#125; &amp;&#39;static å¯ä»¥è¢«å¼ºè½¬æˆä¸€ä¸ªè¾ƒçŸ­çš„ç”Ÿå‘½å‘¨æœŸ ç¤ºä¾‹ 1234567891011121314151617181920// å£°æ˜ä¸€ä¸ª static å¸¸é‡ï¼Œå®ƒæ‹¥æœ‰ `&#x27;static` ç”Ÿå‘½å‘¨æœŸ.static NUM: i32 = 18;// è¿”å›å¸¸é‡ `Num` çš„å¼•ç”¨ï¼Œæ³¨æ„ï¼Œè¿™é‡Œçš„ç”Ÿå‘½å‘¨æœŸä» `&#x27;static` å¼ºè½¬ä¸º `&#x27;a`fn coerce_static&lt;&#x27;a&gt;(_: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123; &amp;NUM&#125;fn main() &#123; &#123; let lifetime_num = 9; let coerced_static = coerce_static(&amp;lifetime_num); println!(&quot;coerced_static: &#123;&#125;&quot;, coerced_static); &#125; println!(&quot;NUM: &#123;&#125; stays accessible!&quot;, NUM);&#125; T: â€˜staticå…³äº &#39;static çš„ç‰¹å¾çº¦æŸè¯¦ç»†è§£é‡Šï¼Œè¯·å‚è§ Rust è¯­è¨€åœ£ç»ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚ ğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930/* è®©ä»£ç å·¥ä½œ */use std::fmt::Debug;fn print_it&lt;T: Debug + &#x27;static&gt;( input: T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it1( input: impl Debug + &#x27;static ) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it2&lt;T: Debug + &#x27;static&gt;( input: &amp;T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn main() &#123; // i æ˜¯æœ‰æ‰€æœ‰æƒçš„æ•°æ®ï¼Œå¹¶æ²¡æœ‰åŒ…å«ä»»ä½•å¼•ç”¨ï¼Œå› æ­¤å®ƒæ˜¯ &#x27;static let i = 5; print_it(i); // ä½†æ˜¯ &amp;i æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œç”Ÿå‘½å‘¨æœŸå—é™äºä½œç”¨åŸŸï¼Œå› æ­¤å®ƒä¸æ˜¯ &#x27;static print_it(&amp;i); print_it1(&amp;i); // ä½†æ˜¯ä¸‹é¢çš„ä»£ç å¯ä»¥æ­£å¸¸è¿è¡Œ ! print_it2(&amp;i);&#125; Answer 1234567891011121314151617181920212223242526272829use std::fmt::Debug;fn print_it&lt;T: Debug + &#x27;static&gt;( input: T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it1( input: impl Debug + &#x27;static ) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it2&lt;T: Debug + &#x27;static&gt;( input: &amp;T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn main() &#123; // i is owned and contains no references, thus it&#x27;s &#x27;static: const i:i32 = 5; print_it(i); // oops, &amp;i only has the lifetime defined by the scope of // main(), so it&#x27;s not &#x27;static: print_it(&amp;i); print_it1(&amp;i); // but this one WORKS ! print_it2(&amp;i);&#125; ğŸŒŸğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546use std::fmt::Display;fn main() &#123; let mut string = &quot;First&quot;.to_owned(); string.push_str(string.to_uppercase().as_str()); print_a(&amp;string); print_b(&amp;string); print_c(&amp;string); // Compilation error print_d(&amp;string); // Compilation error print_e(&amp;string); print_f(&amp;string); print_g(&amp;string); // Compilation error&#125;fn print_a&lt;T: Display + &#x27;static&gt;(t: &amp;T) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_b&lt;T&gt;(t: &amp;T)where T: Display + &#x27;static,&#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_c(t: &amp;&#x27;static dyn Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_d(t: &amp;&#x27;static impl Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_e(t: &amp;(dyn Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_f(t: &amp;(impl Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_g(t: &amp;&#x27;static String) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125; Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445use std::fmt::Display;fn main() &#123; let mut string = &quot;First&quot;.to_owned(); string.push_str(string.to_uppercase().as_str()); print_a(&amp;string); print_b(&amp;string); print_c(Box::leak(Box::new(string.clone()))); // Compilation error print_d(Box::leak(Box::new(string.clone()))); // Compilation error print_e(&amp;string); print_f(&amp;string); print_g(Box::leak(Box::new(string))); // Compilation error&#125;fn print_a&lt;T: Display + &#x27;static&gt;(t: &amp;T) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_b&lt;T&gt;(t: &amp;T) where T: Display + &#x27;static,&#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_c(t: &amp;&#x27;static dyn Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_d(t: &amp;&#x27;static impl Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_e(t: &amp;(dyn Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_f(t: &amp;(impl Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_g(t: &amp;&#x27;static String) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125; æ·±å…¥ç”Ÿå‘½å‘¨æœŸç‰¹å¾çº¦æŸå°±åƒæ³›å‹ç±»å‹å¯ä»¥æœ‰çº¦æŸä¸€æ ·ï¼Œç”Ÿå‘½å‘¨æœŸä¹Ÿå¯ä»¥æœ‰çº¦æŸ ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š T: &#39;aï¼Œæ‰€æœ‰å¼•ç”¨åœ¨ T å¿…é¡»è¶…è¿‡ç”Ÿå‘½å‘¨æœŸ &#39;a T: Trait + &#39;a: T å¿…é¡»å®ç°ç‰¹å¾ Trait å¹¶ä¸”æ‰€æœ‰å¼•ç”¨åœ¨ T å¿…é¡»è¶…è¿‡ç”Ÿå‘½å‘¨æœŸ &#39;a ç¤ºä¾‹ 12345678910111213141516171819202122232425262728293031use std::fmt::Debug; // ç‰¹å¾çº¦æŸä½¿ç”¨#[derive(Debug)]struct Ref&lt;&#x27;a, T: &#x27;a&gt;(&amp;&#x27;a T);// `Ref` åŒ…å«å¯¹æ³›å‹ç±»å‹ `T` çš„å¼•ç”¨ï¼Œè¯¥æ³›å‹ç±»å‹å…·æœ‰// æœªçŸ¥çš„ç”Ÿå‘½å‘¨æœŸ `&#x27;a`. `T` æ˜¯çº¦å®šä»»ä½•// å¼•ç”¨åœ¨ `T` å¿…é¡»å¤§äº `&#x27;a` ã€‚æ­¤å¤–ï¼Œåœ¨ç”Ÿå‘½å‘¨æœŸ// é‡Œ `Ref` ä¸èƒ½è¶…è¿‡ `&#x27;a`ã€‚// ä½¿ç”¨ `Debug` ç‰¹å¾æ‰“å°çš„é€šç”¨å‡½æ•°ã€‚fn print&lt;T&gt;(t: T) where T: Debug &#123; println!(&quot;`print`: t is &#123;:?&#125;&quot;, t);&#125;// è¿™é‡Œå¼•ç”¨ `T` ä½¿ç”¨ where `T` å®ç°// `Debug` å’Œæ‰€æœ‰å¼•ç”¨ `T` éƒ½è¦æ¯” `&#x27;a` é•¿// æ­¤å¤–ï¼Œ`&#x27;a`å¿…é¡»è¦æ¯”å‡½æ•°å£°æ˜å‘¨æœŸé•¿fn print_ref&lt;&#x27;a, T&gt;(t: &amp;&#x27;a T) where T: Debug + &#x27;a &#123; println!(&quot;`print_ref`: t is &#123;:?&#125;&quot;, t);&#125;fn main() &#123; let x = 7; let ref_x = Ref(&amp;x); print_ref(&amp;ref_x); print(ref_x);&#125; ğŸŒŸ 123456789101112/* ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šç»“æ„ä½“1. `r` å’Œ `s` å¿…é¡»æ˜¯ä¸åŒç”Ÿå‘½å‘¨æœŸ2. `s` çš„ç”Ÿå‘½å‘¨æœŸéœ€è¦å¤§äº &#x27;r&#x27;*/struct DoubleRef&lt;T&gt; &#123; r: &amp;T, s: &amp;T&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; My Answer 123456789101112/* ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šç»“æ„ä½“1. `r` å’Œ `s` å¿…é¡»æ˜¯ä¸åŒç”Ÿå‘½å‘¨æœŸ2. `s` çš„ç”Ÿå‘½å‘¨æœŸéœ€è¦å¤§äº &#x27;r&#x27;*/struct DoubleRef&lt;&#x27;a,&#x27;b:&#x27;a,T&gt; &#123; r: &amp;&#x27;a T, s: &amp;&#x27;b T&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 1234567struct DoubleRef&lt;&#x27;a,&#x27;b:&#x27;a, T&gt; &#123; r: &amp;&#x27;a T, s: &amp;&#x27;b T&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸ 12345678910111213141516/* æ·»åŠ ç±»å‹çº¦æŸä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a, &#x27;b&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516/* æ·»åŠ ç±»å‹çº¦æŸä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a:&#x27;b, &#x27;b&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a: &#x27;b, &#x27;b&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸ 12345678910/* æ·»åŠ ç±»å‹çº¦æŸä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */fn f&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, mut y: &amp;&#x27;b i32) &#123; y = x; let r: &amp;&#x27;b &amp;&#x27;a i32 = &amp;&amp;0; &#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 1234567fn f&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, mut y: &amp;&#x27;b i32) where &#x27;a: &#x27;b &#123; y = x; // &amp;&#x27;a i32 is a subtype of &amp;&#x27;b i32 because &#x27;a: &#x27;b let r: &amp;&#x27;b &amp;&#x27;a i32 = &amp;&amp;0; // &amp;&#x27;b &amp;&#x27;a i32 is well formed because &#x27;a: &#x27;b&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; HRTBï¼ˆæ›´é«˜ç­‰çº§ç‰¹å¾çº¦æŸï¼‰(Higher-ranked trait bounds)ç±»å‹çº¦æŸå¯èƒ½åœ¨ç”Ÿå‘½å‘¨æœŸä¸­æ’åæ›´é«˜ã€‚è¿™äº›çº¦æŸæŒ‡å®šäº†ä¸€ä¸ªçº¦æŸå¯¹äºæ‰€æœ‰ç”Ÿå‘½å‘¨æœŸéƒ½ä¸ºçœŸã€‚ä¾‹å¦‚ï¼Œè¯¸å¦‚æ­¤ç±»çš„çº¦æŸ for&lt;&#39;a&gt; &amp;&#39;a T: PartialEq&lt;i32&gt; éœ€è¦å¦‚ä¸‹å®ç°ï¼š 123impl&lt;&#x27;a&gt; PartialEq&lt;i32&gt; for &amp;&#x27;a T &#123; // ...&#125; ç„¶åå¯ä»¥ç”¨äºå°†ä¸€ä¸ª &amp;&#39;a T ä¸ä»»ä½•ç”Ÿå‘½å‘¨æœŸè¿›è¡Œæ¯”è¾ƒ i32 ã€‚ è¿™é‡Œåªèƒ½ä½¿ç”¨æ›´é«˜çº§åˆ«çš„çº¦æŸï¼Œå› ä¸ºå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸæ¯”å‡½æ•°ä¸Šä»»ä½•å¯èƒ½çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°éƒ½çŸ­ã€‚ ğŸŒŸğŸŒŸğŸŒŸ 12345678910/* æ·»åŠ  HRTB ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œï¼ */fn call_on_ref_zero&lt;&#x27;a, F&gt;(f: F) where F: Fn(&amp;&#x27;a i32) &#123; let zero = 0; f(&amp;zero);&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; My Answer 12345678910/* æ·»åŠ  HRTB ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œï¼ */fn call_on_ref_zero&lt;F&gt;(f: F) where F: Fn(&amp; i32) &#123; let zero = 0; f(&amp;zero);&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 12345678fn call_on_ref_zero&lt;F&gt;(f: F) where for&lt;&#x27;a&gt; F: Fn(&amp;&#x27;a i32) &#123; let zero = 0; f(&amp;zero);&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; 1234fn call_on_ref_zero&lt;F&gt;(f: F) where F: for&lt;&#x27;a&gt; Fn(&amp;&#x27;a i32) &#123; let zero = 0; f(&amp;zero);&#125; NLLï¼ˆéè¯æ±‡ç”Ÿå‘½å‘¨æœŸï¼‰(Non-Lexical Lifetime)åœ¨è§£é‡Š NLL ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€æ®µä»£ç ï¼š 1234567891011fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; let r2 = &amp;s; println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2); let r3 = &amp;mut s; println!(&quot;&#123;&#125;&quot;, r3);&#125; æ ¹æ®æˆ‘ä»¬ç›®å‰çš„çŸ¥è¯†ï¼Œè¿™æ®µä»£ç ä¼šå› ä¸ºè¿å Rust ä¸­çš„å€Ÿç”¨è§„åˆ™è€Œå¯¼è‡´é”™è¯¯ã€‚ ä½†æ˜¯ï¼Œå¦‚æœæ‚¨æ‰§è¡Œ cargo run ï¼Œé‚£ä¹ˆä¸€åˆ‡éƒ½æ²¡é—®é¢˜ï¼Œé‚£ä¹ˆè¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ ç¼–è¯‘å™¨åœ¨ä½œç”¨åŸŸç»“æŸä¹‹å‰åˆ¤æ–­ä¸å†ä½¿ç”¨å¼•ç”¨çš„èƒ½åŠ›ç§°ä¸º éè¯æ³•ç”Ÿå‘½å‘¨æœŸï¼ˆç®€ç§° NLL ï¼‰ã€‚ æœ‰äº†è¿™ç§èƒ½åŠ›ï¼Œç¼–è¯‘å™¨å°±çŸ¥é“æœ€åä¸€æ¬¡ä½¿ç”¨å¼•ç”¨æ˜¯ä»€ä¹ˆæ—¶å€™ï¼Œå¹¶æ ¹æ®è¿™äº›çŸ¥è¯†ä¼˜åŒ–å€Ÿç”¨è§„åˆ™ã€‚ 123456789101112131415161718192021#![allow(unused)]fn main() &#123;let mut u = 0i32;let mut v = 1i32;let mut w = 2i32;// lifetime of `a` = Î± âˆª Î² âˆª Î³let mut a = &amp;mut u; // --+ Î±. lifetime of `&amp;mut u` --+ lexical &quot;lifetime&quot; of `&amp;mut u`,`&amp;mut u`, `&amp;mut w` and `a`use(a); // | |*a = 3; // &lt;-----------------+ |... // |a = &amp;mut v; // --+ Î². lifetime of `&amp;mut v` |use(a); // | |*a = 4; // &lt;-----------------+ |... // |a = &amp;mut w; // --+ Î³. lifetime of `&amp;mut w` |use(a); // | |*a = 5; // &lt;-----------------+ &lt;--------------------------+&#125; å†å€Ÿç”¨å­¦ä¹ äº† NLL ä¹‹åï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¾ˆå®¹æ˜“åœ°ç†è§£å†å€Ÿç”¨äº†ã€‚ ç¤ºä¾‹ 1234567891011121314151617181920212223242526#[derive(Debug)]struct Point &#123; x: i32, y: i32,&#125;impl Point &#123; fn move_to(&amp;mut self, x: i32, y: i32) &#123; self.x = x; self.y = y; &#125;&#125;fn main() &#123; let mut p = Point &#123; x: 0, y: 0 &#125;; let r = &amp;mut p; // è¿™é‡Œæ˜¯å†å€Ÿç”¨ let rr: &amp;Point = &amp;*r; println!(&quot;&#123;:?&#125;&quot;, rr); // è¿™é‡Œç»“æŸå†å€Ÿç”¨ // å†å€Ÿç”¨ç»“æŸï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥ç»§ç»­ä½¿ç”¨ `r` r.move_to(10, 10); println!(&quot;&#123;:?&#125;&quot;, r);&#125; ğŸŒŸğŸŒŸ 123456789101112/* é€šè¿‡é‡æ–°æ’åºä¸€äº›ä»£ç ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */fn main() &#123; let mut data = 10; let ref1 = &amp;mut data; let ref2 = &amp;mut *ref1; *ref1 += 1; *ref2 += 2; println!(&quot;&#123;&#125;&quot;, data);&#125; My Answer 123456789101112/* é€šè¿‡é‡æ–°æ’åºä¸€äº›ä»£ç ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */fn main() &#123; let mut data = 10; let ref1 = &amp;mut data; *ref1 += 1; let ref2 = &amp;mut *ref1; *ref2 += 2; println!(&quot;&#123;&#125;&quot;, data);&#125; Answer 12345678910fn main() &#123; let mut data = 10; let ref1 = &amp;mut data; let ref2 = &amp;mut *ref1; *ref2 += 2; *ref1 += 1; println!(&quot;&#123;&#125;&quot;, data);&#125; æœªçº¦æŸçš„ç”Ÿå‘½å‘¨æœŸ]åœ¨ Nomicon - Unbounded Lifetimes ä¸­æŸ¥çœ‹æ›´å¤šä¿¡æ¯ã€‚ æ›´å¤šçœç•¥è§„åˆ™12345678910111213#![allow(unused)]fn main() &#123;impl&lt;&#x27;a&gt; Reader for BufReader&lt;&#x27;a&gt; &#123; // &#x27;a åœ¨ä»¥ä¸‹æ–¹æ³•ä¸­ä¸ä½¿ç”¨&#125;// å¯ä»¥å†™ä¸ºï¼šimpl Reader for BufReader&lt;&#x27;_&gt; &#123; &#125;&#125; 1234567891011121314#![allow(unused)]fn main() &#123;// Rust 2015struct Ref&lt;&#x27;a, T: &#x27;a&gt; &#123; field: &amp;&#x27;a T&#125;// Rust 2018struct Ref&lt;&#x27;a, T&gt; &#123; field: &amp;&#x27;a T&#125;&#125; è‰°éš¾çš„ç»ƒä¹  ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */struct Interface&lt;&#x27;a&gt; &#123; manager: &amp;&#x27;a mut Manager&lt;&#x27;a&gt;&#125;impl&lt;&#x27;a&gt; Interface&lt;&#x27;a&gt; &#123; pub fn noop(self) &#123; println!(&quot;interface consumed&quot;); &#125;&#125;struct Manager&lt;&#x27;a&gt; &#123; text: &amp;&#x27;a str&#125;struct List&lt;&#x27;a&gt; &#123; manager: Manager&lt;&#x27;a&gt;,&#125;impl&lt;&#x27;a&gt; List&lt;&#x27;a&gt; &#123; pub fn get_interface(&amp;&#x27;a mut self) -&gt; Interface &#123; Interface &#123; manager: &amp;mut self.manager &#125; &#125;&#125;fn main() &#123; let mut list = List &#123; manager: Manager &#123; text: &quot;hello&quot; &#125; &#125;; list.get_interface().noop(); println!(&quot;Interface should be dropped here and the borrow released&quot;); use_list(&amp;list);&#125;fn use_list(list: &amp;List) &#123; println!(&quot;&#123;&#125;&quot;, list.manager.text);&#125; Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* ä½¿ä¸‹é¢ä»£ç æ­£å¸¸è¿è¡Œ */struct Interface&lt;&#x27;a&gt; &#123; manager: &amp;&#x27;a mut Manager&lt;&#x27;a&gt;&#125;impl&lt;&#x27;a&gt; Interface&lt;&#x27;a&gt; &#123; pub fn noop(self) &#123; println!(&quot;interface consumed&quot;); &#125;&#125;struct Manager&lt;&#x27;a&gt; &#123; text: &amp;&#x27;a str&#125;struct List&lt;&#x27;a&gt; &#123; manager: Manager&lt;&#x27;a&gt;,&#125;impl&lt;&#x27;a&gt; List&lt;&#x27;a&gt; &#123; pub fn get_interface(&amp;&#x27;a mut self) -&gt; Interface &#123; Interface &#123; manager: &amp;mut self.manager &#125; &#125;&#125;fn main() &#123; let mut list = List &#123; manager: Manager &#123; text: &quot;hello&quot; &#125; &#125;; list.get_interface().noop(); println!(&quot;Interface should be dropped here and the borrow released&quot;); use_list(&amp;list);&#125;fn use_list(list: &amp;List) &#123; println!(&quot;&#123;&#125;&quot;, list.manager.text);&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 13 æ ¼å¼åŒ–è¾“å‡º","slug":"Rustå­¦ä¹ -ç»ƒä¹ 13-æ ¼å¼åŒ–è¾“å‡º","date":"2023-09-26T00:47:04.000Z","updated":"2023-09-26T01:38:07.077Z","comments":true,"path":"2023/09/26/Rustå­¦ä¹ -ç»ƒä¹ 13-æ ¼å¼åŒ–è¾“å‡º/","link":"","permalink":"http://example.com/2023/09/26/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A013-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/","excerpt":"ä½ç½®å‚æ•°1.ğŸŒŸğŸŒŸ 1234567/* å¡«ç©º */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2), __); assert_eq!(format!(__, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125;","text":"ä½ç½®å‚æ•°1.ğŸŒŸğŸŒŸ 1234567/* å¡«ç©º */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2), __); assert_eq!(format!(__, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125; My Answer 1234567/* å¡«ç©º */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2),&quot;21&quot;); assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&#123;0&#125;&#123;1&#125;&quot;, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125; Answer 1234567/* å¡«ç©º */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 2,1), &quot;12&quot;); assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&#123;&#125;&#123;&#125;&quot;, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125; å…·åå‚æ•°2.ğŸŒŸğŸŒŸ 12345678910111213fn main() &#123; println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot; /* å¡«ç©º */ assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, __), &quot;21&quot;); assert_eq!(format!(__,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;); /* ä¿®å¤é”™è¯¯ */ // å…·åå‚æ•°å¿…é¡»æ”¾åœ¨å…¶å®ƒå‚æ•°åé¢ println!(&quot;&#123;abc&#125; &#123;1&#125;&quot;, abc = &quot;def&quot;, 2); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213fn main() &#123; println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot; /* å¡«ç©º */ assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, name = &quot;2&quot;), &quot;21&quot;); assert_eq!(format!(&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;); /* ä¿®å¤é”™è¯¯ */ // å…·åå‚æ•°å¿…é¡»æ”¾åœ¨å…¶å®ƒå‚æ•°åé¢ println!(&quot;&#123;abc&#125; &#123;0&#125;&quot;, 2 ,abc = &quot;def&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213fn main() &#123; println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot; /* å¡«ç©º */ assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, name=2), &quot;21&quot;); assert_eq!(format!(&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;); /* ä¿®å¤é”™è¯¯ */ // å…·åå‚æ•°å¿…é¡»æ”¾åœ¨å…¶å®ƒå‚æ•°åé¢ println!(&quot;&#123;abc&#125;&#123;&#125;&quot;, 2,abc = &quot;def&quot;); println!(&quot;Success!&quot;)&#125; å­—ç¬¦ä¸²å¯¹é½3.ğŸŒŸğŸŒŸ é»˜è®¤æƒ…å†µä¸‹ï¼Œé€šè¿‡ç©ºæ ¼æ¥å¡«å……å­—ç¬¦ä¸² 1234567891011fn main() &#123; // ä¸‹é¢ä¸¤ä¸ªéƒ½æ˜¯é€šè¿‡ 5 ä¸ªç©ºæ ¼æ¥å¡«å…… println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt; &quot;Hello x !&quot; println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt; &quot;Hello x !&quot; /* å¡«ç©º */ assert_eq!(format!(&quot;Hello __!&quot;, 5, &quot;x&quot;), &quot;Hello x !&quot;); assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;, width = 5), &quot;Hello x !&quot;); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011fn main() &#123; // ä¸‹é¢ä¸¤ä¸ªéƒ½æ˜¯é€šè¿‡ 5 ä¸ªç©ºæ ¼æ¥å¡«å…… println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt; &quot;Hello x !&quot; println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt; &quot;Hello x !&quot; /* å¡«ç©º */ assert_eq!(format!(&quot;Hello &#123;1:0$&#125;!&quot;, 5, &quot;x&quot;), &quot;Hello x !&quot;); assert_eq!(format!(&quot;Hello &#123;0:width$&#125;!&quot;, &quot;x&quot;, width = 5), &quot;Hello x !&quot;); println!(&quot;Success!&quot;)&#125; Answer 1234567891011fn main() &#123; // ä¸‹é¢ä¸¤ä¸ªéƒ½æ˜¯é€šè¿‡ 5 ä¸ªç©ºæ ¼æ¥å¡«å…… println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt; &quot;Hello x !&quot; println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt; &quot;Hello x !&quot; /* å¡«ç©º */ assert_eq!(format!(&quot;Hello &#123;1:0$&#125;!&quot;, 5, &quot;x&quot;), &quot;Hello x !&quot;); assert_eq!(format!(&quot;Hello &#123;:width$&#125;!&quot;, &quot;x&quot;, width = 5), &quot;Hello x !&quot;); println!(&quot;Success!&quot;)&#125; 4.ğŸŒŸğŸŒŸğŸŒŸ å·¦å¯¹é½, å³å¯¹é½, ä½¿ç”¨æŒ‡å®šçš„å­—ç¬¦å¡«å…… 12345678910111213fn main() &#123; // å·¦å¯¹é½ println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x ! // å³å¯¹é½ assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;), &quot;Hello x!&quot;); // å±…ä¸­å¯¹é½ assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;), &quot;Hello x !&quot;); // å·¦å¯¹é½ï¼Œå¹¶ä½¿ç”¨ `&amp;` å¡«å…… assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), __); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213fn main() &#123; // å·¦å¯¹é½ println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x ! // å³å¯¹é½ assert_eq!(format!(&quot;Hello &#123;:&gt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x!&quot;); // å±…ä¸­å¯¹é½ assert_eq!(format!(&quot;Hello &#123;:^5&#125;!&quot;, &quot;x&quot;), &quot;Hello x !&quot;); // å·¦å¯¹é½ï¼Œå¹¶ä½¿ç”¨ `&amp;` å¡«å…… assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x&amp;&amp;&amp;&amp;!&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213fn main() &#123; // å·¦å¯¹é½ println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x ! // å³å¯¹é½ assert_eq!(format!(&quot;Hello &#123;:&gt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x!&quot;); // å±…ä¸­å¯¹é½ assert_eq!(format!(&quot;Hello &#123;:^5&#125;!&quot;, &quot;x&quot;), &quot;Hello x !&quot;); // å·¦å¯¹é½ï¼Œå¹¶ä½¿ç”¨ `&amp;` å¡«å…… assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x&amp;&amp;&amp;&amp;!&quot;); println!(&quot;Success!&quot;)&#125; 5.ğŸŒŸğŸŒŸ æˆ‘ä»¬è¿˜èƒ½ä½¿ç”¨ 0 æ¥å¡«å……æ•°å­— 1234567891011fn main() &#123; println!(&quot;Hello &#123;:5&#125;!&quot;, 5); // =&gt; Hello 5! println!(&quot;Hello &#123;:+&#125;!&quot;, 5); // =&gt; Hello +5! println!(&quot;Hello &#123;:05&#125;!&quot;, 5); // =&gt; Hello 00005! println!(&quot;Hello &#123;:05&#125;!&quot;, -5); // =&gt; Hello -0005! /* å¡«ç©º */ assert!(format!(&quot;&#123;number:0&gt;width$&#125;&quot;, number=1, width=6) == __); println!(&quot;Success!&quot;)&#125; Answer 1234567891011fn main() &#123; println!(&quot;Hello &#123;:5&#125;!&quot;, 5); // =&gt; Hello 5! println!(&quot;Hello &#123;:+&#125;!&quot;, 5); // =&gt; Hello +5! println!(&quot;Hello &#123;:05&#125;!&quot;, 5); // =&gt; Hello 00005! println!(&quot;Hello &#123;:05&#125;!&quot;, -5); // =&gt; Hello -0005! /* å¡«ç©º */ assert!(format!(&quot;&#123;number:0&gt;width$&#125;&quot;, number=1, width=6) == &quot;000001&quot;); println!(&quot;Success!&quot;)&#125; ç²¾åº¦6.ğŸŒŸğŸŒŸ æµ®ç‚¹æ•°ç²¾åº¦ 123456789101112/* å¡«ç©º */fn main() &#123; let v = 3.1415926; println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416 assert_eq!(format!(&quot;__&quot;, v), &quot;3.14&quot;); assert_eq!(format!(&quot;__&quot;, v), &quot;+3.14&quot;); assert_eq!(format!(&quot;__&quot;, v), &quot;3&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112/* å¡«ç©º */fn main() &#123; let v = 3.1415926; println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416 assert_eq!(format!(&quot;&#123;:.2&#125;&quot;, v), &quot;3.14&quot;); assert_eq!(format!(&quot;&#123;:+.2&#125;&quot;, v), &quot;+3.14&quot;); assert_eq!(format!(&quot;&#123;:.0&#125;&quot;, v), &quot;3&quot;); println!(&quot;Success!&quot;)&#125; Answer 123456789101112/* å¡«ç©º */fn main() &#123; let v = 3.1415926; println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416 assert_eq!(format!(&quot;&#123;:.2&#125;&quot;, v), &quot;3.14&quot;); assert_eq!(format!(&quot;&#123;:+.2&#125;&quot;, v), &quot;+3.14&quot;); assert_eq!(format!(&quot;&#123;:.0&#125;&quot;, v), &quot;3&quot;); println!(&quot;Success!&quot;)&#125; 7.ğŸŒŸğŸŒŸğŸŒŸ å­—ç¬¦ä¸²é•¿åº¦ 123456789fn main() &#123; let s = &quot;Hello, world!&quot;; println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello assert_eq!(format!(&quot;Hello __!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789fn main() &#123; let s = &quot;Hello, world!&quot;; println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello assert_eq!(format!(&quot;Hello &#123;1:.0$&#125;!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;); println!(&quot;Success!&quot;)&#125; Answer 123456789fn main() &#123; let s = &quot;Hello, world!&quot;; println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello assert_eq!(format!(&quot;Hello &#123;1:.0$&#125;!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;); println!(&quot;Success!&quot;)&#125; äºŒè¿›åˆ¶ã€å…«è¿›åˆ¶ã€åå…­è¿›åˆ¶ format!(â€œ{}â€, foo) -&gt; â€œ3735928559â€ format!(â€œ0x{:X}â€, foo) -&gt; â€œ0xDEADBEEFâ€ format!(â€œ0o{:o}â€, foo) -&gt; â€œ0o33653337357â€ 8.ğŸŒŸğŸŒŸ 123456789101112fn main() &#123; assert_eq!(format!(&quot;__&quot;, 27), &quot;0b11011&quot;); assert_eq!(format!(&quot;__&quot;, 27), &quot;0o33&quot;); assert_eq!(format!(&quot;__&quot;, 27), &quot;0x1b&quot;); assert_eq!(format!(&quot;__&quot;, 27), &quot;0x1B&quot;); println!(&quot;&#123;:x&#125;!&quot;, 27); // æ²¡æœ‰å‰ç¼€çš„åå…­è¿›åˆ¶ =&gt; 1b println!(&quot;&#123;:#010b&#125;&quot;, 27); // ä½¿ç”¨ 0 æ¥å¡«å……äºŒè¿›åˆ¶ï¼Œå®½åº¦ä¸º 10 =&gt; 0b00011011 println!(&quot;Success!&quot;)&#125; My Answer 123456789101112fn main() &#123; assert_eq!(format!(&quot;&#123;:#b&#125;&quot;, 27), &quot;0b11011&quot;); assert_eq!(format!(&quot;&#123;:#o&#125;&quot;, 27), &quot;0o33&quot;); assert_eq!(format!(&quot;&#123;:#x&#125;&quot;, 27), &quot;0x1b&quot;); assert_eq!(format!(&quot;&#123;:#X&#125;&quot;, 27), &quot;0x1B&quot;); println!(&quot;&#123;:x&#125;!&quot;, 27); // æ²¡æœ‰å‰ç¼€çš„åå…­è¿›åˆ¶ =&gt; 1b println!(&quot;&#123;:#010b&#125;&quot;, 27); // ä½¿ç”¨ 0 æ¥å¡«å……äºŒè¿›åˆ¶ï¼Œå®½åº¦ä¸º 10 =&gt; 0b00011011 println!(&quot;Success!&quot;)&#125; Answer 123456789101112fn main() &#123; assert_eq!(format!(&quot;&#123;:#b&#125;&quot;, 27), &quot;0b11011&quot;); assert_eq!(format!(&quot;&#123;:#o&#125;&quot;, 27), &quot;0o33&quot;); assert_eq!(format!(&quot;&#123;:#x&#125;&quot;, 27), &quot;0x1b&quot;); assert_eq!(format!(&quot;&#123;:#X&#125;&quot;, 27), &quot;0x1B&quot;); println!(&quot;&#123;:x&#125;!&quot;, 27); // æ²¡æœ‰å‰ç¼€çš„åå…­è¿›åˆ¶ =&gt; 1b println!(&quot;&#123;:#010b&#125;&quot;, 27); // ä½¿ç”¨ 0 æ¥å¡«å……äºŒè¿›åˆ¶ï¼Œå®½åº¦ä¸º 10 =&gt; 0b00011011 println!(&quot;Success!&quot;)&#125; æ•è·ç¯å¢ƒä¸­çš„å€¼9.ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617181920212223fn get_person() -&gt; String &#123; String::from(&quot;sunface&quot;)&#125;fn get_format() -&gt; (usize, usize) &#123; (4, 1)&#125;fn main() &#123; let person = get_person(); println!(&quot;Hello, &#123;person&#125;!&quot;); let (width, precision) = get_format(); let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)]; /* è®©ä¸‹é¢çš„ä»£ç è¾“å‡º: sunface: 99.1 jack: 60.3 */ for (name, score) in scores &#123; println!(&quot;&#123;name&#125;: __&quot;); &#125;&#125; My Answer 1234567891011121314151617181920212223fn get_person() -&gt; String &#123; String::from(&quot;sunface&quot;)&#125;fn get_format() -&gt; (usize, usize) &#123; (4, 1)&#125;fn main() &#123; let person = get_person(); println!(&quot;Hello, &#123;person&#125;!&quot;); let (width, precision) = get_format(); let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)]; /* è®©ä¸‹é¢çš„ä»£ç è¾“å‡º: sunface: 99.1 jack: 60.3 */ for (name, score) in scores &#123; println!(&quot;&#123;name&#125;: &#123;score:.1&#125;&quot;); &#125;&#125; Answer 1234567891011121314151617181920212223fn get_person() -&gt; String &#123; String::from(&quot;sunface&quot;)&#125;fn get_format() -&gt; (usize, usize) &#123; (4, 1)&#125;fn main() &#123; let person = get_person(); println!(&quot;Hello, &#123;person&#125;!&quot;); let (width, precision) = get_format(); let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)]; /* è®©ä¸‹é¢çš„ä»£ç è¾“å‡º: sunface: 99.1 jack: 60.3 */ for (name, score) in scores &#123; println!(&quot;&#123;name&#125;: &#123;score:.1&#125;&quot;);//æˆ–è€…ï¼š println!(&quot;&#123;name&#125;: &#123;score:width$.precision$&#125;&quot;); &#125;&#125; OthersExample 123456789101112fn main() &#123; // æŒ‡æ•° println!(&quot;&#123;:2e&#125;&quot;, 1000000000); // =&gt; 1e9 println!(&quot;&#123;:2E&#125;&quot;, 1000000000); // =&gt; 1E9 // æŒ‡é’ˆåœ°å€ let v= vec![1, 2, 3]; println!(&quot;&#123;:p&#125;&quot;, v.as_ptr()); // =&gt; 0x600002324050 // è½¬ä¹‰ println!(&quot;Hello &#123;&#123;&#125;&#125;&quot;); // =&gt; Hello &#123;&#125;&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"è®ºæ–‡é˜…è¯» Lost along the Way-Understanding and Mitigating Path-Misresolution Threats to Container Isolation","slug":"è®ºæ–‡é˜…è¯»-Lost-along-the-Way-Understanding-and-Mitigating","date":"2023-09-19T05:03:47.000Z","updated":"2023-09-20T06:18:21.561Z","comments":true,"path":"2023/09/19/è®ºæ–‡é˜…è¯»-Lost-along-the-Way-Understanding-and-Mitigating/","link":"","permalink":"http://example.com/2023/09/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Lost-along-the-Way-Understanding-and-Mitigating/","excerpt":"Abstract äººä»¬å‘ç°ï¼Œåœ¨å®¹å™¨å·¥å…·è¶Šæ¥è¶Šå¤šåœ°åˆ©ç”¨ä¸»æœº-å®¹å™¨äº¤äº’çš„æƒ…å†µä¸‹ï¼Œç”±å½“ä»Šå®¹å™¨æŠ€æœ¯å¼ºåˆ¶å®æ–½çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ•ˆæœè¾ƒå·®ã€‚è¿™ç§è¢«å‰Šå¼±çš„éš”ç¦»å¯¼è‡´äº†ä¸€ç§è·¯å¾„é”™è¯¯è§£å†³ path misresolution(Pamir)æ¼æ´ï¼Œè¿™ç§æ¼æ´è¢«è®¤ä¸ºæ˜¯é«˜é£é™©çš„ï¼Œå¤šå¹´æ¥ä¸æ–­æœ‰æŠ¥å‘Šã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ç¬¬ä¸€ä¸ªç³»ç»Ÿçš„ç ”ç©¶å¸•ç±³å°”é£é™©å’Œç°æœ‰çš„ä¿®å¤ç›¸å…³æ¼æ´ã€‚æˆ‘ä»¬çš„ç ”ç©¶è¡¨æ˜ï¼Œå°½ç®¡æˆ‘ä»¬åœ¨ä¿®è¡¥æ˜“å—æ”»å‡»çš„å®¹å™¨å·¥å…·å’Œè§£å†³é£é™©æ–¹é¢åšå‡ºäº†é‡å¤§åŠªåŠ›ï¼Œä½†å¸•ç±³å°”æ¼æ´ä»åœ¨ç»§ç»­è¢«å‘ç°ï¼ŒåŒ…æ‹¬æˆ‘ä»¬ä»ä¿®è¡¥è½¯ä»¶ä¸­é‡æ–°å‘ç°çš„ä¸€ä¸ªæ–°æ¼æ´(CVE-2023-0778)ã€‚æˆ‘ä»¬ç ”ç©¶çš„ä¸€ä¸ªå…³é”®è§‚ç‚¹æ˜¯ï¼Œç”±äºå®¹å™¨å·¥å…·ä¸¥é‡ä¾èµ–ç¬¬ä¸‰æ–¹ç»„ä»¶ï¼ŒPamiré£é™©æœ¬è´¨ä¸Šå¾ˆéš¾åœ¨å®¹å™¨å·¥å…·çº§åˆ«ä¸Šé¢„é˜²ã€‚è™½ç„¶åº”è¯¥å°†å®‰å…¨æ£€æŸ¥åº”ç”¨äºæ‰€æœ‰ç»„ä»¶ä»¥è°ƒè§£ä¸»æœºå®¹å™¨äº¤äº’ï¼Œä½†ç¬¬ä¸‰æ–¹ç»„ä»¶å¼€å‘äººå‘˜å€¾å‘äºè®¤ä¸ºå®¹å™¨å·¥å…·åº”è¯¥åœ¨è°ƒç”¨å…¶ç»„ä»¶ä¹‹å‰æ‰§è¡Œå®‰å…¨æ£€æŸ¥ï¼Œå› æ­¤ä¸æ„¿æ„ç”¨ç‰¹å®šäºå®¹å™¨çš„ä¿æŠ¤æ¥ä¿®è¡¥ä»–ä»¬çš„ä»£ç ã€‚æ­¤å¤–ï¼Œç”±äºä»Šå¤©çš„å®¹å™¨å·¥å…·æ‰€ä¾èµ–çš„å¤§é‡ç»„ä»¶ï¼Œé‡æ–°å®ç°å®ƒä»¬æ˜¯ä¸åˆ‡å®é™…çš„ã€‚ æˆ‘ä»¬çš„ç ”ç©¶è¡¨æ˜ï¼ŒåŸºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ˜¯ç¡®ä¿åœ¨ä¸»æœº-å®¹å™¨äº¤äº’æœŸé—´å§‹ç»ˆä¿æŒéš”ç¦»çš„å”¯ä¸€æ–¹æ³•ã€‚åœ¨æˆ‘ä»¬çš„ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬è®¾è®¡å¹¶å®ç°äº†ç¬¬ä¸€ä¸ªè¿™æ ·çš„æ–¹æ³•ï¼Œå°†æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ‰©å±•åˆ°dentryå¯¹è±¡ï¼Œé€šè¿‡æ–‡ä»¶ç³»ç»Ÿå¯¹ä¸»æœº-å®¹å™¨äº¤äº’å®æ–½è®¿é—®æ§åˆ¶ã€‚æˆ‘ä»¬çš„è®¾è®¡è§£å†³äº†å½“å‰å®¹å™¨å•å‘éš”ç¦»çš„åŸºæœ¬é™åˆ¶ï¼Œä½¿ç”¨ç²¾å¿ƒè®¾è®¡çš„ç­–ç•¥æ¥ç¡®ä¿å‡†ç¡®å’Œå…¨é¢çš„äº¤äº’æ§åˆ¶ï¼Œå¹¶å°†ä¿æŠ¤æ¤å…¥åˆ°æ­£ç¡®çš„å†…æ ¸ä½ç½®ä»¥æœ€å°åŒ–æ€§èƒ½å½±å“ã€‚æˆ‘ä»¬ä½¿ç”¨æ¨¡å‹æ£€æŸ¥éªŒè¯äº†æˆ‘ä»¬çš„æ–¹æ³•ï¼Œè¯æ˜äº†å®ƒåœ¨æ¶ˆé™¤å¸•ç±³å°”é£é™©æ–¹é¢çš„æœ‰æ•ˆæ€§ã€‚æˆ‘ä»¬çš„è¯„ä¼°è¿›ä¸€æ­¥è¡¨æ˜ï¼Œæˆ‘ä»¬çš„æ–¹æ³•äº§ç”Ÿçš„å¼€é”€å¯ä»¥å¿½ç•¥ä¸è®¡ï¼Œå¤§å¤§ä¼˜äºæ‰€æœ‰ç°æœ‰çš„Pamirè¡¥ä¸ï¼Œå¹¶ä¿æŒä¸æ‰€æœ‰ä¸»æµå®¹å™¨å·¥å…·çš„å…¼å®¹æ€§ã€‚æˆ‘ä»¬å·²ç»å‘å¸ƒäº†æˆ‘ä»¬çš„ä»£ç ï¼Œå¹¶æäº¤äº†å°†æˆ‘ä»¬çš„æŠ€æœ¯åˆå¹¶åˆ°Linuxå†…æ ¸ä¸­çš„è¯·æ±‚ã€‚","text":"Abstract äººä»¬å‘ç°ï¼Œåœ¨å®¹å™¨å·¥å…·è¶Šæ¥è¶Šå¤šåœ°åˆ©ç”¨ä¸»æœº-å®¹å™¨äº¤äº’çš„æƒ…å†µä¸‹ï¼Œç”±å½“ä»Šå®¹å™¨æŠ€æœ¯å¼ºåˆ¶å®æ–½çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ•ˆæœè¾ƒå·®ã€‚è¿™ç§è¢«å‰Šå¼±çš„éš”ç¦»å¯¼è‡´äº†ä¸€ç§è·¯å¾„é”™è¯¯è§£å†³ path misresolution(Pamir)æ¼æ´ï¼Œè¿™ç§æ¼æ´è¢«è®¤ä¸ºæ˜¯é«˜é£é™©çš„ï¼Œå¤šå¹´æ¥ä¸æ–­æœ‰æŠ¥å‘Šã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ç¬¬ä¸€ä¸ªç³»ç»Ÿçš„ç ”ç©¶å¸•ç±³å°”é£é™©å’Œç°æœ‰çš„ä¿®å¤ç›¸å…³æ¼æ´ã€‚æˆ‘ä»¬çš„ç ”ç©¶è¡¨æ˜ï¼Œå°½ç®¡æˆ‘ä»¬åœ¨ä¿®è¡¥æ˜“å—æ”»å‡»çš„å®¹å™¨å·¥å…·å’Œè§£å†³é£é™©æ–¹é¢åšå‡ºäº†é‡å¤§åŠªåŠ›ï¼Œä½†å¸•ç±³å°”æ¼æ´ä»åœ¨ç»§ç»­è¢«å‘ç°ï¼ŒåŒ…æ‹¬æˆ‘ä»¬ä»ä¿®è¡¥è½¯ä»¶ä¸­é‡æ–°å‘ç°çš„ä¸€ä¸ªæ–°æ¼æ´(CVE-2023-0778)ã€‚æˆ‘ä»¬ç ”ç©¶çš„ä¸€ä¸ªå…³é”®è§‚ç‚¹æ˜¯ï¼Œç”±äºå®¹å™¨å·¥å…·ä¸¥é‡ä¾èµ–ç¬¬ä¸‰æ–¹ç»„ä»¶ï¼ŒPamiré£é™©æœ¬è´¨ä¸Šå¾ˆéš¾åœ¨å®¹å™¨å·¥å…·çº§åˆ«ä¸Šé¢„é˜²ã€‚è™½ç„¶åº”è¯¥å°†å®‰å…¨æ£€æŸ¥åº”ç”¨äºæ‰€æœ‰ç»„ä»¶ä»¥è°ƒè§£ä¸»æœºå®¹å™¨äº¤äº’ï¼Œä½†ç¬¬ä¸‰æ–¹ç»„ä»¶å¼€å‘äººå‘˜å€¾å‘äºè®¤ä¸ºå®¹å™¨å·¥å…·åº”è¯¥åœ¨è°ƒç”¨å…¶ç»„ä»¶ä¹‹å‰æ‰§è¡Œå®‰å…¨æ£€æŸ¥ï¼Œå› æ­¤ä¸æ„¿æ„ç”¨ç‰¹å®šäºå®¹å™¨çš„ä¿æŠ¤æ¥ä¿®è¡¥ä»–ä»¬çš„ä»£ç ã€‚æ­¤å¤–ï¼Œç”±äºä»Šå¤©çš„å®¹å™¨å·¥å…·æ‰€ä¾èµ–çš„å¤§é‡ç»„ä»¶ï¼Œé‡æ–°å®ç°å®ƒä»¬æ˜¯ä¸åˆ‡å®é™…çš„ã€‚ æˆ‘ä»¬çš„ç ”ç©¶è¡¨æ˜ï¼ŒåŸºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ˜¯ç¡®ä¿åœ¨ä¸»æœº-å®¹å™¨äº¤äº’æœŸé—´å§‹ç»ˆä¿æŒéš”ç¦»çš„å”¯ä¸€æ–¹æ³•ã€‚åœ¨æˆ‘ä»¬çš„ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬è®¾è®¡å¹¶å®ç°äº†ç¬¬ä¸€ä¸ªè¿™æ ·çš„æ–¹æ³•ï¼Œå°†æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ‰©å±•åˆ°dentryå¯¹è±¡ï¼Œé€šè¿‡æ–‡ä»¶ç³»ç»Ÿå¯¹ä¸»æœº-å®¹å™¨äº¤äº’å®æ–½è®¿é—®æ§åˆ¶ã€‚æˆ‘ä»¬çš„è®¾è®¡è§£å†³äº†å½“å‰å®¹å™¨å•å‘éš”ç¦»çš„åŸºæœ¬é™åˆ¶ï¼Œä½¿ç”¨ç²¾å¿ƒè®¾è®¡çš„ç­–ç•¥æ¥ç¡®ä¿å‡†ç¡®å’Œå…¨é¢çš„äº¤äº’æ§åˆ¶ï¼Œå¹¶å°†ä¿æŠ¤æ¤å…¥åˆ°æ­£ç¡®çš„å†…æ ¸ä½ç½®ä»¥æœ€å°åŒ–æ€§èƒ½å½±å“ã€‚æˆ‘ä»¬ä½¿ç”¨æ¨¡å‹æ£€æŸ¥éªŒè¯äº†æˆ‘ä»¬çš„æ–¹æ³•ï¼Œè¯æ˜äº†å®ƒåœ¨æ¶ˆé™¤å¸•ç±³å°”é£é™©æ–¹é¢çš„æœ‰æ•ˆæ€§ã€‚æˆ‘ä»¬çš„è¯„ä¼°è¿›ä¸€æ­¥è¡¨æ˜ï¼Œæˆ‘ä»¬çš„æ–¹æ³•äº§ç”Ÿçš„å¼€é”€å¯ä»¥å¿½ç•¥ä¸è®¡ï¼Œå¤§å¤§ä¼˜äºæ‰€æœ‰ç°æœ‰çš„Pamirè¡¥ä¸ï¼Œå¹¶ä¿æŒä¸æ‰€æœ‰ä¸»æµå®¹å™¨å·¥å…·çš„å…¼å®¹æ€§ã€‚æˆ‘ä»¬å·²ç»å‘å¸ƒäº†æˆ‘ä»¬çš„ä»£ç ï¼Œå¹¶æäº¤äº†å°†æˆ‘ä»¬çš„æŠ€æœ¯åˆå¹¶åˆ°Linuxå†…æ ¸ä¸­çš„è¯·æ±‚ã€‚ CCS CONCEPTSâ€¢ Security and privacy â†’ Virtualization and security. KEYWORDScloud native technology, OS-level virtualization, container security Introductionå®¹å™¨æŠ€æœ¯ä¿è¯äº†å®‰å…¨ã€ç»æµã€çµæ´»å’Œé«˜æ•ˆçš„è½¯ä»¶éƒ¨ç½²å’Œå¼€å‘ã€‚è¿™äº›æŠ€æœ¯å°†åº”ç”¨ç¨‹åºçš„ä»£ç ã€æ•°æ®å’Œä¾èµ–å…³ç³»æ‰“åŒ…åˆ°å®¹å™¨ä¸­ï¼Œå®¹å™¨åˆ©ç”¨å¤šä¸ªå†…æ ¸æœºåˆ¶(å¦‚åç§°ç©ºé—´å’Œcgroups)å®ç°åº”ç”¨ç¨‹åºè¿è¡Œæ—¶ç¯å¢ƒ(åŒ…æ‹¬æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œã€è¿›ç¨‹å’Œå…¶ä»–ç³»ç»Ÿèµ„æº)ä¸å…¶ä»–åº”ç”¨ç¨‹åºåŠå…¶ä¸»æœºæ“ä½œç³»ç»Ÿ(OS)çš„è½»é‡çº§éš”ç¦»ã€‚ç‰¹åˆ«çš„ï¼Œå®¹å™¨å¯¹æ–‡ä»¶ç³»ç»Ÿçš„éš”ç¦»ï¼Œæœ€æµè¡Œçš„å®¹å™¨æ˜¯ä½¿ç”¨chrootæ¥é˜²æ­¢å®¹å™¨å†…çš„è¿›ç¨‹è®¿é—®ä¸»æœºã€‚å°½ç®¡å¦‚æ­¤ï¼Œéšç€CI&#x2F;CDç­‰äº‘åŸç”Ÿå¼€å‘å®è·µçš„å‡ºç°ï¼Œä»¥åŠå®ƒæä¾›çš„æ–°ç‰¹æ€§(å¦‚å¤åˆ¶å’Œå·)ï¼Œä¸»æœº-å®¹å™¨äº¤äº’ç°åœ¨å˜å¾—å¿…è¦ã€‚ ç„¶è€Œï¼Œè¿™ç§äº¤äº’ä¸ºå®‰å…¨æ¼æ´æä¾›äº†æ–°çš„æœºä¼šï¼Œå…è®¸å®¹å™¨åŒ–çš„æ¶æ„åº”ç”¨ç¨‹åºæ‰“ç ´éš”ç¦»ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œè¿™ç§äº¤äº’é€šå¸¸æ˜¯ç”±å®¹å™¨çš„æ‰€æœ‰è€…å‘èµ·çš„ï¼Œç›®çš„æ˜¯å°†ä¸»æœºèµ„æºå¯¼å…¥åˆ°å®¹å™¨ä¸­ï¼Œæˆ–è€…å°†å®¹å™¨æœåŠ¡çš„ç»“æœå¯¼å‡ºå›ä¸»æœºã€‚ ç„¶è€Œï¼Œç›®å‰å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ä¸è¶³ä»¥é˜²æ­¢ç”±äºæ­¤ç±»äº¤äº’çš„æ¥å£è€Œäº§ç”Ÿçš„æ½œåœ¨å®‰å…¨è¿è§„ã€‚äº‹å®ä¸Šï¼Œåœ¨è¿‡å»çš„6å¹´é‡Œï¼Œä¸€ç§è·¯å¾„é”™è¯¯è§£æ(åˆåPamir)é£é™©ä¸€ç›´å­˜åœ¨äºè¿™äº›æ¥å£ä¸Šï¼Œå¹¶ä¸”å¯¼è‡´äº†æµè¡Œå®¹å™¨å·¥å…·æŠ¥å‘Šçš„27ä¸ªé«˜ä¸¥é‡æ€§æ¼æ´ä¸­çš„è¿‘ä¸€åŠï¼ŒåŒ…æ‹¬ç¼–æ’å¹³å°(ä¾‹å¦‚Kubernetes)ã€ç®¡ç†å¼•æ“(ä¾‹å¦‚Dockerå’ŒPodman)å’Œè¿è¡Œæ—¶(ä¾‹å¦‚containerdå’Œrunc)ã€‚ å¯ä»¥é€šè¿‡åœ¨äº¤äº’æœŸé—´æ“çºµè·¯å¾„è§£ææ¥åˆ©ç”¨è¿™äº›æ¼æ´ï¼Œä»è€Œå®ç°ä»å®¹å™¨çš„é€ƒé€¸ã€‚æ›´ä»¤äººæ‹…å¿§çš„æ˜¯ï¼Œè¿™äº›æ¼æ´ç»§ç»­åœ¨æ‰€æœ‰å®¹å™¨å·¥å…·ä¸­æš´éœ²å‡ºæ¥ã€‚ äº†è§£å®¹å™¨å·¥å…·çš„å¸•ç±³å°”é£é™©ã€‚åœ¨æˆ‘ä»¬çš„ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬å¯¹Pamiré£é™©è¿›è¡Œäº†ç¬¬ä¸€æ¬¡åˆ†æï¼Œç ”ç©¶äº†12ä¸ªå¼•äººæ³¨ç›®çš„æ¼æ´ï¼Œä»¥åŠç”±Pamiré£é™©å¼•èµ·çš„ä¸€ç³»åˆ—é”™è¯¯ï¼Œæ¶‰åŠå‰é¢æåˆ°çš„äº”ä¸ªæœ€çªå‡ºçš„å®¹å™¨å·¥å…·ã€‚ä¸ºäº†ç¡®å®šè¿™äº›æ¼æ´çš„æ¥æºä»¥åŠè§£å†³è¿™äº›æ¼æ´çš„æ­¥éª¤ï¼Œæˆ‘ä»¬ä»è¿™äº›å®¹å™¨å·¥å…·ä¸­æå–å¹¶æ¯”è¾ƒäº†ä¸æ¼æ´ç›¸å…³çš„å¤šä¸ªè°ƒç”¨å›¾ã€‚æ¯ä¸ªè°ƒç”¨å›¾éƒ½æ˜¯ä»è¿™äº›å·¥å…·çš„æ˜“å—æ”»å‡»ç‰ˆæœ¬ä¸­ç»˜åˆ¶çš„ï¼Œå¹¶æ ¹æ®GitHubé—®é¢˜è¿›è¡Œç›¸å…³ä¿®å¤ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜æ‰‹åŠ¨åˆ†æäº†GitHubä¸Šå¯¹ä¿®å¤çš„è¯„è®ºï¼Œä»¥äº†è§£å®ƒä»¬æ˜¯å¦‚ä½•æ¼”å˜çš„ã€‚ é€šè¿‡ç ”ç©¶è¿™äº›æ¼æ´å’Œé”™è¯¯çš„åˆ†å¸ƒï¼Œæˆ‘ä»¬å‘ç°æ¯ä¸ªå®¹å™¨å·¥å…·çš„ç¤¾åŒºå¤šå¹´æ¥ä¸€ç›´åœ¨åŠªåŠ›è§£å†³Pamiré£é™©ã€‚ç„¶è€Œï¼Œè¿™ä¸ªé—®é¢˜ä¼¼ä¹å¾ˆéš¾è§£å†³ï¼Œå› ä¸ºç°æœ‰çš„ä¿®å¤ç¨‹åºå¾€å¾€æ˜¯å¯ä»¥è§„é¿çš„ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ç”šè‡³ä¼šå¼•å…¥æ–°çš„æ¼æ´ã€‚ç‰¹åˆ«æœ‰è¶£çš„æ˜¯ï¼Œè§‚å¯Ÿåˆ°å³ä½¿ç»è¿‡å¤šæ¬¡è¿­ä»£ï¼Œå½“å®‰å…¨ä¿®å¤å·²ç»æ”¹è¿›åˆ°ç»™å®šå®¹å™¨å·¥å…·çš„Pamiré£é™©ç¡®å®å¯ä»¥è§£å†³çš„æ°´å¹³æ—¶ï¼Œå‡çº§å·¥å…·çš„æ–°åŠŸèƒ½ä¹Ÿä¼šå¿½ç•¥ä¿®å¤å¹¶ä½¿å·¥å…·å†æ¬¡æš´éœ²äºç›¸åŒçš„é£é™©ï¼Œæ­£å¦‚æˆ‘ä»¬åœ¨Podmanä¸­å‘ç°çš„ä¸€ä¸ªæ–°æ¼æ´(CVE-2023-0778)æ‰€è¯æ˜çš„é‚£æ ·ï¼Œå…¶Pamiræ¼æ´ä¹‹å‰å·²ç»è¢«ä¿®è¡¥è¿‡ã€‚ æˆ‘ä»¬ç ”ç©¶çš„ä¸€ä¸ªå…³é”®è§‚ç‚¹æ˜¯ï¼Œå¸•ç±³å°”é£é™©åœ¨ä¸»æœºåº”ç”¨ç¨‹åº(å¦‚å®¹å™¨å·¥å…·)å±‚é¢åŸºæœ¬ä¸Šå¾ˆéš¾é¢„é˜²ï¼Œå› ä¸ºå®ƒä»¬ä¸¥é‡ä¾èµ–ç¬¬ä¸‰æ–¹ç»„ä»¶(åº“ã€ç¬¬ä¸‰æ–¹å¯æ‰§è¡Œæ–‡ä»¶ã€æ“ä½œç³»ç»Ÿæ¥å£ç­‰)ã€‚ è¿™ä¸ªé—®é¢˜æ¥è‡ªäºå½“ä»Šå®¹å™¨å†…æ–‡ä»¶ç³»ç»Ÿçš„å•å‘éš”ç¦»:å½“æ–‡ä»¶ç³»ç»Ÿä¹‹å¤–çš„èµ„æºè¶…å‡ºå®¹å™¨çš„åç§°ç©ºé—´ï¼Œå› æ­¤å¯¹å®¹å™¨åŒ–çš„åº”ç”¨ç¨‹åºä¸å¯è§æ—¶ï¼Œä¸»æœºå¯æ‰§è¡Œæ–‡ä»¶(åŒ…æ‹¬å®¹å™¨å·¥å…·å’Œå®ƒæ‰€ä¾èµ–çš„ç»„ä»¶)åœ¨è®¿é—®å®¹å™¨å†…æ–‡ä»¶ç³»ç»Ÿæ—¶ä¸ä¼šçœ‹åˆ°ä»»ä½•çº¦æŸã€‚å› æ­¤ï¼Œå¯¹ä¸»æœºå®¹å™¨äº¤äº’çš„ä»»ä½•å®‰å…¨æ§åˆ¶éƒ½éœ€è¦å¯¹ä¸»æœºå¯æ‰§è¡Œæ–‡ä»¶åŠå…¶ç»„ä»¶æ‰§è¡Œçš„æ‰€æœ‰ä¸æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„æ“ä½œå®æ–½ã€‚ å½“æ¶‰åŠåˆ°å®¹å™¨å·¥å…·ä½¿ç”¨çš„ç¬¬ä¸‰æ–¹ç»„ä»¶æ—¶ï¼Œè¿™å˜å¾—å¾ˆå›°éš¾:ä¾‹å¦‚ï¼ŒKuberneteséœ€è¦LinuxæŒ‚è½½å·¥å…·æ¥å®ç°å·ç‰¹æ€§ã€‚ä½¿è¿™ç§ä¿æŠ¤ç­–ç•¥å‡ ä¹ä¸å¯èƒ½å®ç°çš„åŸå› æ˜¯ï¼Œè¿™äº›ç»„ä»¶çš„å¼€å‘äººå‘˜æ ¹æœ¬æ²¡æœ‰å®ç°è¿™ç§ç‰¹å®šäºå®¹å™¨çš„æ§åˆ¶çš„åŠ¨æœºï¼Œè€Œæ˜¯è®¤ä¸ºåœ¨è°ƒç”¨å…¶ä¾èµ–çš„ç»„ä»¶ä¹‹å‰åº”è¯¥ç”±å®¹å™¨å·¥å…·æ‰§è¡Œå®‰å…¨æ£€æŸ¥ã€‚ ä¸ºäº†æ‘†è„±è¿™ç§å›°å¢ƒï¼Œå½“ä»Šå®¹å™¨å·¥å…·çš„å¼€å‘äººå‘˜æå‡ºäº†å„ç§ç‰¹åˆ«çš„è§£å†³æ–¹æ¡ˆï¼Œä»¥é¿å…ç¬¬ä¸‰æ–¹ç»„ä»¶çš„å±é™©è¡Œä¸ºï¼Œä¾‹å¦‚åœ¨äº¤äº’ä¹‹å‰ä¸ºç»„ä»¶é¢„åŠ è½½å—ä¿¡ä»»çš„åŠ¨æ€é“¾æ¥åº“ã€‚ç„¶è€Œï¼Œè¿™äº›è¡¥ä¸ä¼šå¸¦æ¥æ˜¾è‘—çš„æ€§èƒ½è´Ÿæ‹…:ä¾‹å¦‚ï¼Œä¿®å¤â€™ docker cp â€˜ä¸Šçš„Pamiré£é™©çš„å¼€é”€å¯ä»¥è¾¾åˆ°200%(ç¬¬6èŠ‚)ã€‚æ›´ä¸¥é‡çš„æ˜¯ï¼Œè¿™äº›è¡¥ä¸æ˜¯è„†å¼±çš„ï¼Œå¯ä»¥é€šè¿‡å¯¹ç»„ä»¶æˆ–å…¶ä¾›åº”é“¾çš„ä»»ä½•æ›´æ–°æ¥è§„é¿ç”šè‡³å®Œå…¨ç¦ç”¨ã€‚ä¸€ä¸ªä¾‹å­æ˜¯å‰é¢æåˆ°çš„å¯¹Dockeræ¼æ´CVE-2019-14271çš„ä¿®å¤ï¼Œè¯¥æ¼æ´åœ¨æ›´æ–°glibcæ—¶ä¸å†æœ‰æ•ˆï¼Œè¯¥æ›´æ–°å…è®¸åœ¨ä¸Šä¸‹æ–‡åˆ‡æ¢æœŸé—´è‡ªåŠ¨é‡æ–°åŠ è½½é¢„åŠ è½½çš„åº“ã€‚ä½œä¸ºæœ€åçš„æ‰‹æ®µï¼Œä¸€äº›å®¹å™¨å·¥å…·çš„å¼€å‘äººå‘˜è¢«è¿«éƒ¨åˆ†åœ°é‡æ–°å®ç°ä¸å…¼å®¹ç»„ä»¶çš„æ›¿æ¢ã€‚æˆ‘ä»¬çš„åˆ†æè¡¨æ˜ï¼Œè¿™å°†éœ€è¦ç›¸å½“å¤§çš„å·¥ç¨‹åŠªåŠ›ï¼Œå› ä¸ºæ¯ä¸ªå®¹å™¨å·¥å…·çš„è„†å¼±ç‰¹å¾å¹³å‡ä¸è¶…è¿‡1,090ä¸ªGolangåŒ…ç›¸å…³ã€‚éšç€æ›´å¤šçš„åŠŸèƒ½è¢«æ·»åŠ åˆ°å®¹å™¨å·¥å…·ä¸­ï¼Œæ›´å¤šçš„ç¬¬ä¸‰æ–¹ç»„ä»¶å˜å¾—ä¸å¯é¿å…ï¼Œä½¿å¾—è¿™ç§é‡æ–°å®ç°å˜å¾—è¶Šæ¥è¶Šå›°éš¾ã€‚ æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆã€‚æˆ‘ä»¬å¯¹å·²çŸ¥Pamiræ¼æ´çš„ç³»ç»Ÿåˆ†æè¡¨æ˜ï¼Œå®¹å™¨å·¥å…·æ— æ³•åœ¨ç”¨æˆ·å±‚é¢æœ‰æ•ˆæ§åˆ¶æ­¤å®‰å…¨é£é™©ã€‚å› æ­¤ï¼ŒåŸºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æˆä¸ºå”¯ä¸€å¯è¡Œçš„è§£å†³æ–¹æ¡ˆï¼Œå¯ä»¥å…¨é¢åè°ƒæ¥è‡ªä¸åŒç±»å‹ç¬¬ä¸‰æ–¹ç»„ä»¶çš„æ–‡ä»¶ç³»ç»Ÿè®¿é—®ï¼Œä»è€Œç¡®ä¿åœ¨ä¸»æœº-å®¹å™¨äº¤äº’æœŸé—´å§‹ç»ˆä¿æŒéš”ç¦»ã€‚ç„¶è€Œï¼Œç”±äºå½“å‰çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»è®¾è®¡ï¼Œè¿™ç§åŠªåŠ›ä¸æ˜¯å¾®ä¸è¶³é“çš„ï¼Œå®ƒç”šè‡³å¯¹å†…æ ¸ä¹Ÿæ˜¯é€æ˜çš„ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œä¸ºäº†æœ€å°åŒ–ä¸­ä»‹è®¿é—®æ–‡ä»¶ç³»ç»Ÿçš„å¼€é”€ï¼Œå½“å‰çš„è®¾è®¡åªæ˜¯éš”ç¦»å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„æŒ‚è½½ç‚¹ï¼Œå°†å®¹å™¨åº”ç”¨ç¨‹åºçš„æ“ä½œé™åˆ¶åœ¨å…¶åç§°ç©ºé—´å†…ã€‚å› æ­¤ï¼Œä»è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ(VFS)ä¸­ï¼Œå†…æ ¸æ— æ³•åˆ¤æ–­ç›®å½•æ¡ç›®(dentry)å¯¹è±¡æ˜¯å¦å±äºå®¹å™¨ã€‚è¿™ä½¿å¾—å¯¹æ–‡ä»¶ç³»ç»Ÿçš„ä»»ä½•éæ³•è®¿é—®éƒ½éš¾ä»¥è¯†åˆ«ï¼Œåªè¦è®¿é—®è¯·æ±‚çš„è·¯å¾„å¯ä»¥é€šè¿‡VFSè½¬æ¢ä¸ºdentryå¯¹è±¡ã€‚æ­¤å¤–ï¼Œå³ä½¿ç»™å®šäº†è®¿é—®ç›®æ ‡ä¿¡æ¯(æ— è®ºæ˜¯å¦ä¸ºå®¹å™¨)ï¼Œè®¾è®¡å‡†ç¡®ã€å…¨é¢çš„è®¿é—®æ§åˆ¶ç­–ç•¥ä»ç„¶å…·æœ‰æŒ‘æˆ˜æ€§:ä¾‹å¦‚ï¼Œè™½ç„¶å®¹å™¨å·¥å…·åº”è¯¥è¢«å…è®¸è®¿é—®å®¹å™¨å¤–éƒ¨çš„å¯¹è±¡ï¼Œè¿™ä¸ªè®¿é—®è¯·æ±‚ä¸åº”è¯¥ç”±å®¹å™¨å†…éƒ¨çš„åº”ç”¨ç¨‹åºå¼•èµ·(ç¬¬3.2èŠ‚)ã€‚æœ€åï¼Œè¿˜éœ€è¦ä»”ç»†è€ƒè™‘ç­–ç•¥çš„å®æ–½ï¼Œä»¥é¿å…å¯¹ç³»ç»Ÿæ€§èƒ½äº§ç”Ÿä»»ä½•é‡å¤§å½±å“ï¼Œå¹¶ç¡®ä¿è®¿é—®çš„å®Œå…¨ä¸­ä»‹ã€‚ åœ¨æˆ‘ä»¬çš„ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬è®¾è®¡å¹¶å®ç°äº†é’ˆå¯¹å¸•ç±³å°”é£é™©çš„ç¬¬ä¸€ä¸ªå†…æ ¸ç«¯é˜²å¾¡ã€‚æˆ‘ä»¬çš„æ–¹æ³•ï¼Œç§°ä¸ºPatrol (Pamir control)ï¼Œå°†æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ‰©å±•åˆ°dentryå¯¹è±¡ï¼Œç¡®ä¿ä¸»æœº-å®¹å™¨æ–‡ä»¶ç³»ç»Ÿç›¸å…³äº¤äº’çš„å®Œå…¨ä¸­ä»‹ã€‚ ä¸ºæ­¤ï¼ŒPatrolæ ¹æ®dentryä¸å®¹å™¨çš„å…³ç³»å¯¹å®ƒä»¬è¿›è¡Œæ ‡è®°ï¼Œå¹¶ä½¿ç”¨ä¸€ç»„ç²¾å¿ƒè®¾è®¡çš„ç­–ç•¥æ¥è§„èŒƒå¯¹è¿™äº›å¯¹è±¡çš„è®¿é—®ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜åˆ†æäº†å°†ç”¨æˆ·ç©ºé—´è·¯å¾„è½¬æ¢ä¸ºVFSä¸­çš„dentryå¯¹è±¡çš„è¿‡ç¨‹ï¼Œåœ¨è·¯å¾„æŸ¥æ‰¾å‡½æ•°ä¸­ç¡®å®šæ‰§è¡Œç­–ç•¥çš„æœ€ä½³ä½ç½®ï¼Œä»è€Œç¡®ä¿å¯¹ä¸»æœº-å®¹å™¨äº¤äº’çš„å®Œæ•´å’Œæœ‰æ•ˆæ§åˆ¶ã€‚ æˆ‘ä»¬é€šè¿‡æ¨¡å‹æ£€æŸ¥éªŒè¯äº†Patrolçš„è®¾è®¡ï¼Œè¡¨æ˜å®ƒèƒ½å¤Ÿå®Œå…¨æ¶ˆé™¤å¸•ç±³å°”é£é™©ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥è¯„ä¼°äº†æˆ‘ä»¬åœ¨Dockerã€Podmanå’ŒKubernetesä¸Šçš„å®ç°ã€‚æˆ‘ä»¬çš„ç ”ç©¶è¡¨æ˜ï¼ŒPatrolåœ¨æ˜“å—æ”»å‡»çš„å®¹å™¨å·¥å…·ä¸Šçš„æ€§èƒ½å¤§å¤§ä¼˜äºæ‰€æœ‰ç”¨æˆ·ä¿®å¤ï¼Œå¹¶ä¸”å¹³å‡åªäº§ç”Ÿä¸åˆ°4%çš„å¼€é”€ã€‚æ­¤å¤–ï¼ŒPatrolä¸æ‰€æœ‰ä¸»æµå®¹å™¨å·¥å…·å®Œå…¨å…¼å®¹ï¼Œå¹¶ä¸”æ˜¯å®Œå…¨é€æ˜çš„:å®ƒä¸ä¼šå½±å“å®¹å™¨å·¥å…·ã€å®ƒä»¬æ‰€ä¾èµ–çš„ç»„ä»¶å’Œå…¶ä»–åº”ç”¨ç¨‹åºçš„æ“ä½œã€‚æˆ‘ä»¬å·²ç»å‘å¸ƒäº†æˆ‘ä»¬çš„ä»£ç ï¼Œå¹¶æäº¤äº†å°†æˆ‘ä»¬çš„æŠ€æœ¯åˆå¹¶åˆ°Linuxå†…æ ¸ä¸­çš„è¯·æ±‚ã€‚ æœ¬æ–‡çš„è´¡çŒ®æ¦‚è¿°å¦‚ä¸‹: è°ƒæŸ¥ç»“æœå’Œç»“è®ºã€‚æˆ‘ä»¬å¯¹é«˜å½±å“çš„Pamiré£é™©è¿›è¡Œäº†ç¬¬ä¸€æ¬¡ç³»ç»Ÿç ”ç©¶ï¼Œå¹¶è¯æ˜äº†è¿™ç§é£é™©ä»æ ¹æœ¬ä¸Šæ˜¯ç”±å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ä¸è¶³é€ æˆçš„ï¼Œç›®å‰çš„ä¿æŠ¤æ— æ³•è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä½œä¸ºå½“ä»Šè§£å†³æ–¹æ¡ˆå±€é™æ€§çš„è¯æ®ï¼Œæˆ‘ä»¬å‘ç°å¹¶æŠ¥å‘Šäº†å®¹å™¨å·¥å…·ä¸­ä»¥å‰å·²ç»ä¿®è¡¥è¿‡çš„æ–°çš„Pamiræ¼æ´ã€‚ æ–°çš„é˜²å¾¡æŠ€æœ¯ã€‚æˆ‘ä»¬è®¾è®¡äº†ä¸€ç§æ–°çš„éš”ç¦»æŠ€æœ¯ï¼Œå¹¶æœ‰æ•ˆè€Œå…¨é¢åœ°è§£å†³äº†åœ¨å†…æ ¸å†…éƒ¨å®ç°çš„æŠ€æœ¯éš¾é¢˜ã€‚æˆ‘ä»¬çš„æ–¹æ³•å·²ç»é€šè¿‡æ¨¡å‹æ£€æŸ¥å’Œä¸»æµå®¹å™¨å·¥å…·çš„è¯„ä¼°å¾—åˆ°äº†éªŒè¯ï¼Œè¯æ˜äº†æ–°çš„è§£å†³æ–¹æ¡ˆæ¯”ç›®å‰æå‡ºçš„ä»»ä½•æ›¿ä»£æ–¹æ¡ˆéƒ½æ›´æœ‰æ•ˆï¼Œè€Œä¸”æ›´å®ç”¨ï¼Œå¯¹æ€§èƒ½çš„å½±å“éå¸¸ä½ã€‚ BackgroundVirtual Filesystem â€œä¸€åˆ‡éƒ½æ˜¯æ–‡ä»¶â€æ˜¯Linuxçš„åŸºæœ¬ç†å¿µä¹‹ä¸€ã€‚ä¸ä»…æ™®é€šæ–‡ä»¶ï¼ŒåŒ…æ‹¬ç›®å½•ã€å­—ç¬¦è®¾å¤‡ã€å—è®¾å¤‡ã€å¥—æ¥å­—ç­‰ï¼Œéƒ½å¯ä»¥è¢«è§†ä¸ºæ–‡ä»¶ã€‚è¿™ç§è®¾è®¡çš„åŸºç¡€æ˜¯Linuxçš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ(VFS)æœºåˆ¶ã€‚å®ƒä¸ºç”¨æˆ·ç¨‹åºæ“ä½œæ–‡ä»¶æä¾›äº†ç»Ÿä¸€çš„æ¥å£å±‚ï¼Œå±è”½äº†ä¸åŒæ–‡ä»¶ç³»ç»Ÿçš„å·®å¼‚å’Œæ“ä½œç»†èŠ‚ã€‚ Dentry and Dentry tree. Dentryæ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œè¡¨ç¤ºå†…æ ¸ä¸­çš„æ–‡ä»¶æˆ–ç›®å½•å¯¹è±¡ã€‚dentryåŒ…å«ç›¸åº”æ–‡ä»¶æˆ–ç›®å½•çš„åç§°ï¼Œå¯ä»¥ç›´æ¥æ˜ å°„æ–‡ä»¶å’Œç›®å½•ä¹‹é—´çš„å±‚æ¬¡å…³ç³»ã€‚æ¯ä¸ªdentryéƒ½åŒ…å«æŒ‡å‘å…¶çˆ¶dentryçš„æŒ‡é’ˆå’Œå…¶å­dentryçš„åˆ—è¡¨ï¼Œè¿™ä½¿å¾—dentryå½¢æˆäº†ä¸€ä¸ªdentryæ ‘ã€‚VFSä½¿ç”¨dentryæ ‘æ¥ç»´æŠ¤æ–‡ä»¶å’Œç›®å½•å¯¹è±¡çš„å±‚æ¬¡ç»“æ„ã€‚å½“ç„¶ï¼Œå¯¹äºå¤§å‹ç³»ç»Ÿï¼Œä¸å¯èƒ½å°†æ–‡ä»¶ç³»ç»Ÿçš„æ‰€æœ‰æ¡ç›®éƒ½æ”¾å…¥å†…å­˜ä¸­ã€‚æ‰€ä»¥æ ‘ä¸­çš„è¿™äº›dentryæ˜¯å¼•ç”¨è®¡æ•°çš„ã€‚Dentryç¼“å­˜(Dcache)åªç»´æŠ¤è¢«å¼•ç”¨çš„Dentryï¼Œå¹¶ä»Dentryæ ‘ä¸­åˆ é™¤æœªå¼•ç”¨çš„Dentryä»¥é‡Šæ”¾å†…å­˜ã€‚ Filesystem mounting Linuxå†…æ ¸æ„é€ æŒ‚è½½æ ‘æ¥ç»´æŠ¤ç³»ç»Ÿä¸­çš„æŒ‚è½½ä¿¡æ¯ã€‚å¦‚å›¾1æ‰€ç¤ºï¼ŒæŒ‚è½½æ ‘çš„å¶å­æ˜¯ä¸€ä¸ªåä¸ºâ€œmountâ€çš„æ•°æ®ç»“æ„ã€‚mountç»“æ„åŒ…å«æŒ‡å‘æ–°æ–‡ä»¶ç³»ç»ŸæŒ‚è½½çš„æŒ‚è½½ç‚¹dentryçš„æŒ‡é’ˆï¼Œä»¥åŠæŒ‡å‘æ–°æ–‡ä»¶ç³»ç»Ÿæ ¹ç›®å½•dentryçš„æŒ‡é’ˆã€‚æŒ‚è½½ç‚¹çš„dentryå’Œæ–°æ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•æ²¡æœ‰ç›´æ¥çš„çˆ¶å­å…³ç³»ï¼Œä½†æ˜¯mountç»“æ„å……å½“äº†è¿æ¥å…·æœ‰æŒ‚è½½å…³ç³»çš„æ–‡ä»¶ç³»ç»Ÿdentryçš„æ¡¥æ¢ã€‚ Path lookup VFSä¸­æœ€å¸¸è§çš„æ“ä½œæ˜¯è·¯å¾„æŸ¥æ‰¾ã€‚å†…æ ¸ä½¿ç”¨è·¯å¾„æŸ¥æ‰¾å°†è·¯å¾„åä»userlandè½¬æ¢ä¸ºå†…æ ¸ä¸­ç›¸åº”çš„dentryå¯¹è±¡ã€‚é€šå¸¸ï¼Œå¯¹äºæ¯ä¸ªä¸æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨(å¦‚openã€readã€writeã€statã€mountç­‰)ï¼Œè§£æpathnameçš„è·¯å¾„æŸ¥æ‰¾æ˜¯å¿…è¦çš„ã€‚å…·ä½“æ¥è¯´ï¼Œè·¯å¾„æŸ¥æ‰¾æ˜¯éå†è·¯å¾„åå¹¶æ‰¾åˆ°è·¯å¾„åä¸­æœ€ç»ˆç»„ä»¶å¯¹åº”çš„dentry(æˆ‘ä»¬ç§°ä¹‹ä¸ºæœ€ç»ˆdentry)ï¼Œå…¶ä¸­ç»„ä»¶æ˜¯ç”±â€™ &#x2F; â€˜å­—ç¬¦åˆ†éš”çš„å­å­—ç¬¦ä¸²ã€‚æ¯ä¸ªæŸ¥æ‰¾è¿‡ç¨‹åˆ›å»ºä¸€ä¸ªnameidataå¯¹è±¡æ¥å­˜å‚¨å…¶ä¸­é—´ç»“æœ(ä¾‹å¦‚ï¼Œç»„ä»¶çš„dentries)ã€‚åœ¨è·¯å¾„æŸ¥æ‰¾å¼€å§‹æ—¶ï¼Œä½¿ç”¨è¯¥æŸ¥æ‰¾è¿‡ç¨‹çš„èµ·å§‹ç‚¹åˆå§‹åŒ–nameidataå¯¹è±¡ä¸­çš„ç¬¬ä¸€ä¸ªç»„ä»¶çš„dentryï¼Œè¯¥èµ·å§‹ç‚¹ç”±è·¯å¾„åçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ç¡®å®šã€‚å¦‚æœè·¯å¾„åä»¥â€™ &#x2F; â€˜å­—ç¬¦å¼€å¤´ï¼Œåˆ™èµ·ç‚¹æ˜¯è°ƒç”¨è¿›ç¨‹æ ¹ç›®å½•çš„dentryã€‚å¦åˆ™ï¼Œå®ƒæ˜¯è¿›ç¨‹å½“å‰å·¥ä½œç›®å½•çš„dentryã€‚ç„¶åï¼Œåœ¨å‰ä¸€ä¸ªç»„ä»¶dentryçš„å­ç»„ä»¶ä¸­æŸ¥æ‰¾è·¯å¾„åçš„æ¯ä¸ªç»„ä»¶ã€‚ è¿™æ˜¯é€šè¿‡æ¯”è¾ƒç»„ä»¶çš„åç§°ä¸å­˜å‚¨åœ¨dentryä¸­çš„åç§°æ¥å®Œæˆçš„ã€‚å‘ç°çš„dentryé€šè¿‡å†…æ ¸å‡½æ•°path_to_nameidataä¿å­˜åˆ°nameidataå¯¹è±¡ä¸­ã€‚å¦‚æœæ‰¾ä¸åˆ°ç»„ä»¶çš„dentryï¼Œåˆ™è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹å°†ä»¥å¤±è´¥å‘Šç»ˆã€‚æ— è®ºè·¯å¾„æŸ¥æ‰¾æ˜¯å¦æˆåŠŸï¼Œåœ¨æŸ¥æ‰¾è¿‡ç¨‹ç»“æŸæ—¶éƒ½ä¼šè°ƒç”¨å†…æ ¸å‡½æ•°complete_walkæ¥å®Œæˆè·¯å¾„æŸ¥æ‰¾å¹¶è¿”å›çŠ¶æ€ç ã€‚ åœ¨æŸ¥æ‰¾è¿‡ç¨‹ä¸­ï¼Œå¦‚æœä¸€ä¸ªdentryè¡¨ç¤ºä¸€ä¸ªç¬¦å·é“¾æ¥(ä¹Ÿå°±æ˜¯sym_link)ï¼Œå†…æ ¸å‡½æ•°trailing_symlinkæ¥è·Ÿè¸ªæ­¤ç¬¦å·é“¾æ¥å¹¶æå–æŒ‡å‘çš„è·¯å¾„åã€‚ ç„¶åï¼Œè¯¥è·¯å¾„åæ›¿æ¢ç¬¦å·é“¾æ¥ä»¥ç»§ç»­è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ã€‚å¦‚æœä¸€ä¸ªdentryä½œä¸ºæŒ‚è½½ç‚¹ï¼Œé‚£ä¹ˆæŸ¥æ‰¾è¿‡ç¨‹å°†éµå¾ªæŒ‚è½½æ ‘ä¸­ç›¸åº”çš„â€œmountâ€ç»“æ„æ¥å®šä½è¡¨ç¤ºæŒ‚è½½æ–‡ä»¶ç³»ç»Ÿæ ¹ç›®å½•çš„dentryï¼Œå¹¶ç»§ç»­ä»è¯¥dentryæŸ¥æ‰¾ç»„ä»¶ã€‚ é€šå¸¸ï¼Œèµ·ç‚¹å’ŒæŒ‚è½½ç‚¹æ˜¯å†³å®šè·¯å¾„æŸ¥æ‰¾ç»“æœçš„ä¸¤ä¸ªå…³é”®å…ƒç´ ã€‚å¦‚æœè¿›ç¨‹é€šè¿‡è¿™æ ·çš„ç³»ç»Ÿè°ƒç”¨chrootåˆ°è¾¾ä¸åŒçš„æ ¹ç›®å½•ï¼Œåˆ™æ›´æ”¹çš„æŸ¥æ‰¾èµ·å§‹ç‚¹å°†æŠŠç›¸åŒçš„è·¯å¾„åå¼•å¯¼åˆ°ä¸åŒçš„æ ¹ç›®å½•ã€‚æ­¤å¤–ï¼Œå¦‚æœè¿›ç¨‹å°†ä¸€ä¸ªæ–°çš„æŒ‚è½½åç§°ç©ºé—´ä¸ä¸€ä¸ªå­¤ç«‹çš„æŒ‚è½½æ ‘è¿æ¥èµ·æ¥ï¼Œé‚£ä¹ˆè·¯å¾„æŸ¥æ‰¾ä¹Ÿä¼šå¾—åˆ°åŒºåˆ«ï¼Œå› ä¸ºä¸åŒçš„æŒ‚è½½åç§°ç©ºé—´å¯èƒ½åœ¨åŒä¸€æŒ‚è½½ç‚¹ä¸‹å‘ˆç°ä¸åŒçš„æŒ‚è½½è§†å›¾ã€‚ Container Filesystem IsolationLinuxå†…æ ¸åŒæ—¶åˆ©ç”¨åç§°ç©ºé—´å’Œç±»ä¼¼chrootçš„åŠŸèƒ½æ¥éš”ç¦»å®¹å™¨æ–‡ä»¶ç³»ç»Ÿã€‚Linuxå‘½åç©ºé—´å¼ºåˆ¶è¿›ç¨‹çº§èµ„æºéš”ç¦»ã€‚ç‰¹åˆ«æ˜¯ï¼Œä½¿ç”¨æŒ‚è½½åç§°ç©ºé—´ï¼Œå¯ä»¥ä¸ºæ¯ä¸ªåç§°ç©ºé—´åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„æ–‡ä»¶ç³»ç»ŸæŒ‚è½½å±‚æ¬¡ç»“æ„ã€‚è¿™ç¡®ä¿äº†åœ¨æ¯ä¸ªæŒ‚è½½åç§°ç©ºé—´ä¸­è¿è¡Œçš„è¿›ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„æŒ‚è½½ç‚¹è§†å›¾ã€‚ æ­¤å¤–ï¼Œç±»ä¼¼chrootçš„åŠŸèƒ½å¯ä»¥ä¸ºè¿›ç¨‹æŒ‡å®šä¸€ä¸ªæ–°çš„æ ¹ç›®å½•ï¼Œé™åˆ¶å®ƒä»¬åœ¨è¿™ä¸ªæ–°æ ¹ç›®å½•ä¸­å¯ä»¥è®¿é—®çš„èµ„æºã€‚æŒ‚è½½ç‚¹çš„ç‹¬ç«‹è§†å›¾é˜²æ­¢è¿›ç¨‹è®¿é—®æŒ‚è½½åœ¨å…¶ä»–æŒ‚è½½åç§°ç©ºé—´ä¸­çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè€Œchrootå¼ºåˆ¶è¿›ç¨‹åªèƒ½è®¿é—®ç»™å®šç›®å½•ä¸­çš„èµ„æºã€‚å› æ­¤ï¼Œè¯¥è¿›ç¨‹ä¸æœªç»æˆæƒçš„èµ„æºå®Œå…¨éš”ç¦»ã€‚ å…·ä½“æ¥è¯´ï¼Œåˆ›å»ºå’Œéš”ç¦»å®¹å™¨æ–‡ä»¶ç³»ç»Ÿçš„è¿‡ç¨‹å¦‚å›¾1æ‰€ç¤ºã€‚æœ€åˆï¼Œå®¹å™¨å·¥å…·ä»å®¹å™¨æ˜ åƒä¸­æå–rootfså¹¶å°†å…¶æŒ‚è½½åˆ°ç»™å®šä¸»æœºçš„ç›®å½•(â‘ )ä¸Šï¼Œä¾‹å¦‚â€œ&#x2F;var&#x2F;lib&#x2F;docker&#x2F;[storage driver]&#x2F;[ID:sha256]&#x2F;â€ã€‚ ç„¶åï¼Œå®¹å™¨å·¥å…·è°ƒç”¨å¸¦æœ‰CLONE_NEWNSæ ‡å¿—çš„ç³»ç»Ÿè°ƒç”¨å…‹éš†ï¼Œä»¥åˆ›å»ºå®¹å™¨çš„åˆå§‹è¿›ç¨‹ã€‚è¿™å°†ä¸è¯¥è¿›ç¨‹ä¸€èµ·ç”Ÿæˆä¸€ä¸ªæ–°çš„æŒ‚è½½åç§°ç©ºé—´ï¼Œå¹¶ä¸”å®¹å™¨å†…çš„æ‰€æœ‰è¿›ç¨‹éƒ½åŠ å…¥è¯¥åç§°ç©ºé—´(â‘¡)ã€‚é€šå¸¸ï¼Œä»è°ƒç”¨è¿›ç¨‹çš„æŒ‚è½½åç§°ç©ºé—´å…‹éš†ä¸€ä¸ªæ–°çš„æŒ‚è½½åç§°ç©ºé—´ï¼Œè¿™å°†å¯¼è‡´å®¹å™¨çš„æŒ‚è½½åç§°ç©ºé—´ç»§æ‰¿ä¸»æœºçš„æŒ‚è½½æ ‘ã€‚åªæœ‰åœ¨è¿™äº›åç§°ç©ºé—´ä¸­æ·»åŠ çš„æ–°æŒ‚è½½å¯¹å…¶ä»–åç§°ç©ºé—´æ˜¯ä¸å¯è§çš„ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®¹å™¨è¿›ç¨‹ä»ç„¶å¯ä»¥éå†ä¸»æœºçš„æ–‡ä»¶ç³»ç»Ÿã€‚å› æ­¤ï¼Œä½¿ç”¨ç±»ä¼¼chrootçš„ç³»ç»Ÿè°ƒç”¨pivot_rootæ¥ç”¨å®¹å™¨çš„rootfs(â‘¢)é‡ç½®è¿™äº›è¿›ç¨‹çš„æ ¹ç›®å½•ï¼Œä»¥ç¡®ä¿è¿›ç¨‹åªèƒ½è®¿é—®rootfsä¸‹çš„æ–‡ä»¶å’Œç›®å½•ï¼ŒåŒ…æ‹¬æŒ‚è½½ç‚¹ã€‚å°½ç®¡å¦‚æ­¤ï¼Œè¿™ç§éš”ç¦»ä»ç„¶æ˜¯ä¸å®Œæ•´çš„ï¼Œè®¸å¤šæ¼æ´å¯ä»¥ç»•è¿‡å®ƒã€‚ INCOMPLETE FILESYSTEM ISOLATIONå°½ç®¡æ¯ä¸ªå®¹å™¨éƒ½æœ‰ä¸€ä¸ªç‹¬ç«‹äºä¸»æœºçš„æ–‡ä»¶ç³»ç»Ÿè§†å›¾ï¼Œä½†æ˜¯å®ƒä»¬çš„æ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„éš”ç¦»å¹¶æ²¡æœ‰å®Œå…¨å®Œæˆã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆæ¾„æ¸…å¨èƒæ¨¡å‹ï¼Œç„¶åè®¨è®ºå®¹å™¨éš”ç¦»ä¸­çš„Pamiræ¼æ´(bugé—®é¢˜&#x2F; cve)ã€‚æœ€åï¼Œæˆ‘ä»¬å°†å±•ç¤ºæˆ‘ä»¬ä»å½“å‰é’ˆå¯¹æ­¤ç±»æ¼æ´çš„è¡Œä¸šè§£å†³æ–¹æ¡ˆä¸­è·å¾—çš„åº¦é‡å’Œç†è§£ã€‚ Threat Modelæˆ‘ä»¬è€ƒè™‘ç”±å®¹å™¨å·¥å…·(ä¾‹å¦‚Dockerå’ŒKubernetes)ç®¡ç†çš„åŸºäºå®¹å™¨çš„å¹³å°ï¼Œåœ¨è¿™äº›å¹³å°ä¸Šè¿è¡Œçš„å¤šç§Ÿæˆ·å®¹å™¨å¯ä»¥å…±äº«ç›¸åŒçš„æ“ä½œç³»ç»Ÿã€‚å®¹å™¨å·¥å…·å’Œå¹³å°ä¸Šçš„æ“ä½œç³»ç»Ÿæ˜¯å¯ä¿¡çš„ï¼Œä½†å®¹æ˜“å—åˆ°æ”»å‡»ã€‚åŸºäºå®¹å™¨çš„å¹³å°ä¸­çš„æ”»å‡»è€…å¯ä»¥æ§åˆ¶å¤šä¸ªå®¹å™¨ï¼Œå¹¶è¯•å›¾ç ´åæ“ä½œç³»ç»Ÿæˆ–å…¶ä»–ç§Ÿæˆ·çš„å®¹å™¨ã€‚è€Œä¸”ï¼Œæ”»å‡»è€…æœ‰èƒ½åŠ›æ“çºµå®¹å™¨ä¸­çš„æ‰€æœ‰èµ„æºï¼Œæ¯”å¦‚æ–‡ä»¶ç³»ç»Ÿå’Œè¿›ç¨‹ã€‚æ­¤å¤–ï¼Œä»–ä»¬è¿˜å¯ä»¥åˆ©ç”¨åˆæ³•çš„æ¥å£æ¥æç¤ºå¹³å°ä¸è¿™äº›èµ„æºè¿›è¡Œäº¤äº’ï¼Œä»¥ä¾¿è¿›è¡Œè¶Šç‹±ã€‚è¿™äº›åˆæ³•æ¥å£å°è£…äº†å®¹å™¨å·¥å…·çš„åŠŸèƒ½ï¼Œå¦‚å¤åˆ¶ã€è¿è¡Œå’Œå·ã€‚è¿™ä¹Ÿæ˜¯æ‰€æœ‰å…¶ä»–å®¹å™¨é€ƒé€¸åœºæ™¯ä¸­çš„å…¸å‹å¨èƒæ¨¡å‹ã€‚ Pamir Vulnerabilitiesåœ¨ä¸»æœº-å®¹å™¨äº¤äº’æœŸé—´ï¼Œå„ç§å®¹å™¨å·¥å…·ä»ä¸»æœºä¸Šä¸‹æ–‡è®¿é—®å®¹å™¨æ–‡ä»¶ç³»ç»Ÿã€‚ç„¶è€Œï¼Œå®¹å™¨åœ¨è¿™äº›å·¥å…·çœ¼ä¸­è¢«è®¤ä¸ºæ˜¯ä¸å¯ä¿¡çš„ï¼Œå¹¶ä¸”å¯èƒ½æ¬ºéª—å®ƒä»¬è®¿é—®å…¶æ–‡ä»¶ç³»ç»Ÿä¸­çš„æ¶æ„æœ‰æ•ˆè´Ÿè½½ã€‚ç”±äºè·¯å¾„é”™è¯¯è§£æ(Pamir)è€Œå‡ºç°çš„æ¼æ´åå¤æš´éœ²åœ¨è¿™äº›å±æ€§ä¸­ï¼Œå¹¶å¯¹æ‰€æœ‰å¹¿æ³›ä½¿ç”¨çš„å®¹å™¨å·¥å…·äº§ç”Ÿå½±å“ï¼Œå°½ç®¡å®ƒä»¬æ˜¯ç”±ä¸åŒçš„ç¤¾åŒºå¼€å‘çš„(å‚è§å›¾2)ã€‚è¿™äº›æ¼æ´ä¸»è¦é€šè¿‡ä¸¤ç§æ–¹å¼è¢«åˆ©ç”¨æ¥ç ´åä¸»æœºï¼Œä»è€Œå®ç°ä¿¡æ¯æ³„éœ²ã€ç‰¹æƒå‡çº§ã€ä»»æ„æ–‡ä»¶æ“ä½œå’Œå…¶ä»–ç›¸å…³å®‰å…¨é—®é¢˜ã€‚ ç¬¦å·é“¾æ¥è§£ææ¬ºéª—æ˜¯åˆ©ç”¨Pamiræ¼æ´çš„æ–¹æ³•ä¹‹ä¸€ã€‚é€šå¸¸ï¼Œåœ¨ä¸»æœº-å®¹å™¨äº¤äº’æœŸé—´ï¼Œå®¹å™¨å·¥å…·å¯ä»¥è®¿é—®å®¹å™¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„ç¬¦å·é“¾æ¥ï¼Œå¯¹å…¶è¿›è¡Œè¯»æˆ–å†™æ“ä½œã€‚ä½†æ˜¯ï¼Œè¿™ä¸ªç¬¦å·é“¾æ¥æ˜¯åœ¨ä¸»æœºä¸Šä¸‹æ–‡ä¸­è§£æçš„ï¼Œè€Œä¸æ˜¯åœ¨å®¹å™¨ä¸Šä¸‹æ–‡ä¸­è§£æçš„ã€‚æ¶æ„å®¹å™¨ä¸­çš„å¤æ‚ç¬¦å·é“¾æ¥å¯ä»¥æ¬ºéª—å®¹å™¨å·¥å…·å¯¼èˆªåˆ°å®¹å™¨æ–‡ä»¶ç³»ç»Ÿä¹‹å¤–ï¼Œå¹¶è®¿é—®ä¸»æœºä¸Šçš„æ•æ„Ÿä½ç½®(ä¾‹å¦‚â€™ &#x2F;etc&#x2F;passwd â€˜)ã€‚ æ¶æ„å®¹å™¨å¯ä»¥åˆ©ç”¨å…·æœ‰Pamiræ¼æ´çš„â€œå·â€ç‰¹æ€§æ¥éå†ä¸»æœºä¸Šçš„ä»»æ„æ–‡ä»¶ã€‚â€œvolumeâ€ç‰¹æ€§ç”¨äºå°†å·æŒ‚è½½åˆ°å®¹å™¨æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå®ƒå¯ä»¥æ˜¯ä¸»æœºçš„ç›®å½•ï¼Œä»¥æä¾›æŒä¹…å­˜å‚¨ã€‚æ­¤å¤–ï¼ŒKubernetesä¸­çš„â€œsubPathâ€å±æ€§å…è®¸å°†ä¸€ä¸ªå®¹å™¨ä½¿ç”¨çš„å·ä¸­çš„å­ç›®å½•æŒ‚è½½åˆ°å…¶ä»–å®¹å™¨ä¸­ã€‚ä½†æ˜¯ï¼Œå¦‚æœè¯¥å­ç›®å½•è¢«æ¶æ„å®¹å™¨æ›¿æ¢ä¸ºç¬¦å·é“¾æ¥ï¼Œåˆ™è¯¥ç¬¦å·é“¾æ¥æ‰€å¼•ç”¨çš„ä¸»æœºä¸Šçš„ä»»æ„ç›®å½•å°†è¢«æŒ‚è½½åˆ°å¦ä¸€ä¸ªæ¶æ„å®¹å™¨ä¸­ï¼Œä»è€Œå¯¼è‡´Kubernetesâ€œvolumeâ€ç‰¹æ€§ä¸­æœ€æ—©çš„æ¼æ´CVE-2017-1002101ã€‚ è™½ç„¶Kuberneteså·²ç»çº æ­£äº†è¿™ä¸ªé—®é¢˜ï¼Œä½†ç±»ä¼¼çš„æ”»å‡»é¢ä»ç„¶å­˜åœ¨äºå®ƒçš„ä¾èµ–ç»„ä»¶ä¸­ï¼Œå¯¼è‡´ç±»ä¼¼çš„æ¼æ´ï¼Œå¦‚CVE-2022-23648å’ŒCVE-2021-30465åˆ†åˆ«åœ¨containdå’Œruncä¸­å­˜åœ¨ã€‚Cç‰ˆæœ¬çš„runcä¹Ÿæœ‰ç›¸åŒçš„æ¼æ´ã€‚ ç±»ä¼¼çš„æ¼æ´ä¹Ÿå­˜åœ¨äºâ€œå¤åˆ¶â€åŠŸèƒ½ä¸­ï¼Œå¹¶å…è®¸éå†ä¸»æœºä¸Šçš„æ–‡ä»¶ä»¥åŠè¦†ç›–ä»»ä½•ä¸»æœºçš„æ–‡ä»¶ã€‚â€œå¤åˆ¶â€ç‰¹æ€§æ˜¯ç”±å®¹å™¨å·¥å…·å®ç°çš„ï¼Œç”¨äºåœ¨å®¹å™¨å’Œä¸»æœºä¹‹é—´å¤åˆ¶æ–‡ä»¶ã€‚ä½†æ˜¯ï¼Œæ— è®ºæ˜¯ä»å®¹å™¨å¤åˆ¶è¿˜æ˜¯å‘å®¹å™¨å¤åˆ¶ï¼Œæ— è®ºæ˜¯æºå®¹å™¨è¿˜æ˜¯ç›®æ ‡å®¹å™¨éƒ½å—ä¸ä¿¡ä»»çš„å®¹å™¨æ§åˆ¶ã€‚å…·ä½“æ¥è¯´ï¼Œå¦‚æœæ¶æ„ç¬¦å·é“¾æ¥å–ä»£äº†ä»å®¹å™¨å¤åˆ¶çš„æ–‡ä»¶ï¼Œåˆ™å¤åˆ¶æºå¯èƒ½é€šè¿‡è¯¥ç¬¦å·é“¾æ¥è¢«å¸¦å‡ºå®¹å™¨ã€‚ç±»ä¼¼åœ°ï¼Œæ›¿ä»£å®¹å™¨ä¸­å¤åˆ¶ç›®æ ‡çš„æ¶æ„ç¬¦å·é“¾æ¥å¯èƒ½ä¼šè¯¯å¯¼æ–‡ä»¶è¢«å¤åˆ¶åˆ°ä¸»æœºä¸Šçš„ä»»æ„ç›®å½•ï¼Œè€Œä¸æ˜¯è¯¥å®¹å™¨ã€‚ç±»ä¼¼çš„æ¼æ´CVE-2019-10152å’ŒCVE-2019-18466ä¹Ÿå‡ºç°åœ¨Podmanä¸­ï¼Œå°½ç®¡Podmançš„å¼€å‘äººå‘˜å—åˆ°CVE-2018-15664[30]çš„å¯å‘ï¼ŒåŠªåŠ›é¿å…è¿™ç±»æ¼æ´ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜åœ¨Podmançš„â€œexport volumeâ€åŠŸèƒ½ä¸­å‘ç°äº†ä¸€ä¸ªæ¼æ´CVE-2023-0778ï¼Œè¯¥æ¼æ´éµå¾ªç›¸åŒçš„åŸç†ã€‚ ä¸å—ä¿¡ä»»çš„å®¹å™¨æ§åˆ¶ã€‚å…·ä½“æ¥è¯´ï¼Œå¦‚æœæ¶æ„ç¬¦å·é“¾æ¥å–ä»£äº†ä»å®¹å™¨å¤åˆ¶çš„æ–‡ä»¶ï¼Œåˆ™å¤åˆ¶æºå¯èƒ½é€šè¿‡è¯¥ç¬¦å·é“¾æ¥è¢«å¸¦å‡ºå®¹å™¨ã€‚ç±»ä¼¼åœ°ï¼Œæ›¿ä»£å®¹å™¨ä¸­å¤åˆ¶ç›®æ ‡çš„æ¶æ„ç¬¦å·é“¾æ¥å¯èƒ½ä¼šè¯¯å¯¼æ–‡ä»¶è¢«å¤åˆ¶åˆ°ä¸»æœºä¸Šçš„ä»»æ„ç›®å½•ï¼Œè€Œä¸æ˜¯è¯¥å®¹å™¨ã€‚ç±»ä¼¼çš„æ¼æ´CVE-2019-10152å’ŒCVE-2019-18466ä¹Ÿå‡ºç°åœ¨Podmanä¸­ï¼Œå°½ç®¡Podmançš„å¼€å‘äººå‘˜å—åˆ°CVE-2018-15664çš„å¯å‘ï¼ŒåŠªåŠ›é¿å…è¿™ç±»æ¼æ´ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜åœ¨Podmançš„â€œexport volumeâ€åŠŸèƒ½ä¸­å‘ç°äº†ä¸€ä¸ªæ¼æ´CVE-2023-0778ï¼Œè¯¥æ¼æ´éµå¾ªç›¸åŒçš„åŸç†ã€‚ è¯±å¯¼éæ³•æ–‡ä»¶æ‰§è¡Œæ˜¯åˆ©ç”¨Pamiræ¼æ´çš„å¦ä¸€ç§æ–¹æ³•ã€‚é™¤äº†å¯ä»¥è¯»å†™ä¹‹å¤–ï¼Œå®¹å™¨ä¸­çš„æ–‡ä»¶è¿˜å¯ä»¥åœ¨ä¸»æœº-å®¹å™¨äº¤äº’æœŸé—´ç”±ä¸»æœºçš„è¿›ç¨‹(ä¾‹å¦‚å®¹å™¨å·¥å…·)æ‰§è¡Œã€‚ä½†æ˜¯ï¼Œæ­¤æ‰§è¡Œå¯èƒ½ä¼šå¯¼è‡´å®¹å™¨ä¸­çš„æ¶æ„æœ‰æ•ˆè´Ÿè½½åœ¨ä¸»æœºä¸Šä¸‹æ–‡ä¸­èµ·ä½œç”¨ã€‚ å°½ç®¡æ‰€æœ‰å®¹å™¨å·¥å…·éƒ½åŠªåŠ›é¿å…è¿™ç§æ‰§è¡Œï¼Œä½†è®¸å¤šä¸å¯é¢„è§çš„æ‰§è¡Œä»ç„¶éšè—åœ¨å®ƒä»¬çš„ç‰¹æ€§ä¸­ã€‚ ä¾‹å¦‚ï¼ŒDockerä¸çŸ¥é“å®ƒä¼šåœ¨å®¹å™¨ä¸­åŠ è½½ä¸€ä¸ªåŠ¨æ€é“¾æ¥çš„åº“â€™ nsswitch â€˜ ã€‚ å…·ä½“æ¥è¯´ï¼Œè¿™ä¸ªåº“æ˜¯ç”±ä¸€ä¸ªGolangåŒ…æ‰€éœ€è¦å’ŒåŠ è½½çš„ï¼ŒDockerè°ƒç”¨è¿™ä¸ªåŒ…æ¥æ†ç»‘å¤åˆ¶çš„æ–‡ä»¶ï¼Œä½†æ˜¯è¿™ä¸ªåŒ…æ²¡æœ‰æ„è¯†åˆ°è¿™ä¸ªåŠ è½½æ˜¯åœ¨è°ƒç”¨ç³»ç»Ÿè°ƒç”¨chrootä¹‹åå‘ç”Ÿçš„ã€‚ä½¿ç”¨sycall chrootæ˜¯ä¿®å¤æ¼æ´CVE-2018-15664çš„æ–¹æ³•ï¼Œè¯¥æ¼æ´é™åˆ¶äº†å®¹å™¨å†…çš„ç¬¦å·é“¾æ¥è§£æã€‚ç„¶è€Œï¼Œé€šè¿‡è¿™ç§æ–¹å¼ï¼Œåº“â€™ nsswitch â€˜ä¹Ÿè¢«è¿«åœ¨å®¹å™¨æ–‡ä»¶ç³»ç»Ÿä¸­è§£æã€‚ä½†è¯¥è¿›ç¨‹ä»ç„¶å±äºä¸»æœºï¼Œä»è€Œå¯¼è‡´æ–°çš„æ¼æ´CVE-2019-14271ã€‚ç±»ä¼¼åœ°ï¼ŒPodmanä¸­çš„CVE-2022-1227æ¼æ´æºäºé€šè¿‡ä¸»æœºä¸Šä¸‹æ–‡ä¸­çš„â€œPodman topâ€åŠŸèƒ½è°ƒç”¨å®¹å™¨ä¸­çš„â€œnsenterâ€å¯æ‰§è¡Œæ–‡ä»¶ã€‚ æ­¤å¤–ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä¸»æœºä¸Šè¿è¡Œçš„ç³»ç»Ÿè¿›ç¨‹ä¸èƒ½é¿å…æ‰§è¡Œæ¥è‡ªä¸å—ä¿¡ä»»å®¹å™¨çš„ç¯¡æ”¹æ–‡ä»¶ã€‚è¿™ç±»æ–‡ä»¶ç”±Cgroupfsæä¾›ï¼Œä½œä¸ºä¸»æœºå’Œå®¹å™¨ä¹‹é—´å…±äº«cgroupsä¿¡æ¯çš„äº¤äº’æ¥å£ã€‚å…¶ä¸­ï¼ŒCgroupfsä¸­çš„ä¸€ä¸ªç‰¹æ®Šæ–‡ä»¶â€™ release_agent â€˜å°†åœ¨å®¹å™¨ç»ˆæ­¢åç”±ä¸»æœºç³»ç»Ÿè¿›ç¨‹æ‰§è¡Œã€‚ CVE-2022-0492æ¼æ´æ˜¯è¯¥æ–‡ä»¶è¢«æ¶æ„å®¹å™¨ç ´åçš„ç›´æ¥ç»“æœã€‚é€šå¸¸ï¼Œå®¹å™¨åªèƒ½ä»è‡ªå·±çš„æ–‡ä»¶ç³»ç»Ÿä¸­çš„â€™ &#x2F;sys&#x2F;fs&#x2F;cgroup â€˜è®¿é—®â€™ release_agent â€˜æ–‡ä»¶;ä½†æ˜¯ï¼Œå®‰å…¨æ€§é…ç½®ä¸è¶³çš„å®¹å™¨å¯ä»¥ç»•è¿‡æƒé™æ£€æŸ¥å¹¶æ›´æ”¹æ­¤æ–‡ä»¶ã€‚è¿™å…è®¸åœ¨ä¸»æœºç³»ç»Ÿä¸Šæ‰§è¡Œâ€™ release_agent â€˜æ–‡ä»¶ä¸­çš„ä»»ä½•æ¶æ„è´Ÿè½½ã€‚ Understanding Fixing Methodså°½ç®¡ä¸»æµå®¹å™¨å·¥å…·ç¤¾åŒºè¿›è¡Œäº†è®¸å¤šå°è¯•æ¥è§£å†³Pamiræ¼æ´ï¼Œä½†å®ƒä»¬ä»ç„¶å­˜åœ¨ã€‚ä¸ºäº†ç¡®å®šè¿™äº›å°è¯•ä¿®å¤çš„ç¼ºç‚¹ï¼Œæˆ‘ä»¬ä½¿ç”¨go-callviså¼€æºå·¥å…·ä»å‰é¢æåˆ°çš„å®¹å™¨å·¥å…·çš„è„†å¼±ç‰ˆæœ¬å’Œæ›´æ–°ç‰ˆæœ¬ä¸­æå–è°ƒç”¨å›¾ã€‚é€šè¿‡æ‰‹å·¥åˆ†æç›¸å…³çš„è°ƒç”¨å›¾å’Œä»”ç»†æ£€æŸ¥GitHubä¸Šçš„æ‰€æœ‰ç›¸å…³è¯„è®ºï¼Œæˆ‘ä»¬èƒ½å¤Ÿå…¨é¢äº†è§£è¿™äº›ä¿®å¤çš„æ¼”å˜ è§‚å¯Ÿ1 -å®¹å™¨å·¥å…·çš„ç¬¬ä¸‰æ–¹ç»„ä»¶é˜»ç¢äº†æ¼æ´çš„å½»åº•ä¿®å¤ ä¿®å¤å®¹å™¨å·¥å…·ä¸­çš„æ¼æ´å¯èƒ½æ— æ³•æ¶ˆé™¤å…¶ä¾èµ–ç»„ä»¶ä¸­çš„æ”»å‡»é¢ï¼Œè¿™ä¼šå¸¦æ¥ä¸¥é‡çš„é£é™©ã€‚ ä¸ºäº†åº”å¯¹ç¬¦å·é“¾æ¥è§£æä½œå¼Šï¼Œå¼€å‘äº†ä¸€ä¸ªæ–°çš„åŒ…â€™ secureJoin â€˜æ¥å–ä»£GolangåŒ…â€™ filepath â€˜ï¼Œç›®çš„æ˜¯é€šè¿‡éªŒè¯ç¬¦å·é“¾æ¥æ˜¯å¦è¢«è§£æåˆ°æŒ‡å®šç›®å½•(ä¾‹å¦‚ï¼Œå®¹å™¨çš„æ ¹ç›®å½•)æ¥å®ç°å®‰å…¨çš„è·¯å¾„è§£æã€‚ç„¶è€Œï¼Œå°½ç®¡åœ¨å·¥ç¨‹ä¸Šåšå‡ºäº†é‡å¤§åŠªåŠ›æ¥å®ç°è¿™ä¸€ä¿®å¤ï¼Œä½†ä½œå¼Šçš„å›ºæœ‰é£é™©å¹¶æœªå®Œå…¨æ¶ˆé™¤ã€‚è¿™æ˜¯ç”±äºåˆ†è¾¨ç‡æ£€æŸ¥è¿‡ç¨‹å’Œéšåçš„è·¯å¾„ç›¸å…³æ“ä½œ(ä¾‹å¦‚å¤åˆ¶æˆ–æŒ‚è½½)ä¹‹é—´å­˜åœ¨ç«äº‰æ¡ä»¶ï¼Œè¿™å¯ä»¥é€šè¿‡TOCTTOUæ”»å‡»æ¥åˆ©ç”¨æ¶æ„ç¬¦å·é“¾æ¥æ›¿æ¢å·²éªŒè¯çš„è·¯å¾„ã€‚ å…·ä½“æ¥è¯´ï¼Œè¿™ç§æ›¿æ¢æ˜¯åœ¨ä¸»æœºä¸Šçš„å®¹å™¨å·¥å…·å®Œæˆè§£ææ£€æŸ¥åï¼Œæ”»å‡»è€…åœ¨å®¹å™¨å†…æ‰§è¡Œçš„ã€‚è¿™å¯¼è‡´å„ç§å®¹å™¨å·¥å…·ä¸­å­˜åœ¨ä¸€ç³»åˆ—æ¼æ´ï¼Œä¾‹å¦‚CVE-2018-15664ã€CVE-2021-30465ã€CVE-2021-25741ã€CVE-2022-23648å’ŒCVE-2023-0778ã€‚ å°½ç®¡äººä»¬å°è¯•ä¿®å¤å®¹å™¨å·¥å…·ä¸­çš„æ¼æ´ï¼Œä½†å®ƒä»¬ä»ç„¶å¾ˆå®¹æ˜“å—åˆ°æ”»å‡»ã€‚ä¾‹å¦‚ï¼ŒPodmanç¤¾åŒºé€‰æ‹©åœ¨å®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿè¢«Podmanè®¿é—®æ—¶æš‚åœå®¹å™¨ï¼Œå› ä¸ºå†»ç»“çš„å®¹å™¨æ— æ³•è¿›è¡Œç«äº‰ã€‚ç„¶è€Œï¼Œè¿™ä¸ªä¿®å¤å¸¦æ¥äº†å·¨å¤§çš„å¼€é”€(å‚è§ç¬¬6èŠ‚)ï¼Œå¹¶ä¸”å·²ç»ç¡®å®šäº†ä¸€ä¸ªå¯ä»¥ç»•è¿‡å®ƒçš„å¼±ç‚¹ã€‚ å…·ä½“æ¥è¯´ï¼Œå¦‚æœä¸¤ä¸ªå®¹å™¨å…±äº«ä¸€ä¸ªå·ï¼Œé‚£ä¹ˆå½“Podmanä¸å†»ç»“çš„å®¹å™¨äº¤äº’æ—¶ï¼Œä¸€ä¸ªå®¹å™¨ä»ç„¶å¯ä»¥è®¿é—®å·å¹¶è¿›è¡ŒTOCTTOUæ”»å‡»ã€‚ æ­¤å¤–ï¼ŒKubernetesã€containardå’Œruncç¤¾åŒºè¯•å›¾é€šè¿‡åŸå­åŒ–è§£ææ£€æŸ¥å’Œéšåçš„è·¯å¾„ç›¸å…³æ“ä½œæ¥æ¶ˆé™¤ç«äº‰æ¡ä»¶ã€‚ä½†æ˜¯ï¼Œè¿™äº›åç»­æ“ä½œè°ƒç”¨çš„ä»»ä½•ç¬¬ä¸‰æ–¹å¯æ‰§è¡Œæ–‡ä»¶éƒ½å¯èƒ½ç ´åè¿™ç§åŸå­åŒ–ã€‚å…·ä½“åœ°è¯´ï¼Œè¿™ç§åŸå­åŒ–æ˜¯é€šè¿‡ç”¨â€œ&#x2F;proc&#x2F;[pid]&#x2F;fd&#x2F;[fd]â€è¿™ä¸ªé­”æœ¯é“¾æ¥æ›¿æ¢é€‰ä¸­çš„è·¯å¾„æ¥å®ç°çš„ï¼Œä»¥ä¾›åç»­æ“ä½œä½¿ç”¨ã€‚è¿™ä¸ªç¥å¥‡çš„é“¾æ¥æ€»æ˜¯æŒ‡å‘è¢«æ£€æŸ¥çš„è·¯å¾„ï¼Œä½†æ˜¯åœ¨Kubernetesçš„â€™ volume â€˜ç‰¹æ€§ä¸­ï¼Œè§£ææ£€æŸ¥åè°ƒç”¨çš„LinuxæŒ‚è½½å·¥å…·é»˜è®¤ä¼šè§£æè¿™ä¸ªç¥å¥‡çš„é“¾æ¥ï¼Œå¹¶ä½¿ç”¨è§£æç»“æœåœ¨æœ€åè°ƒç”¨sycallæŒ‚è½½ã€‚è¿™å¯¼è‡´äº†æ¼æ´CVE-2021-25741ï¼Œè¯¥æ¼æ´åªèƒ½é€šè¿‡è°ƒç”¨å¸¦æœ‰-no-canonicalizeæ ‡å¿—çš„æŒ‚è½½å·¥å…·æ¥ç¦ç”¨è§£ææ¥ä¿®å¤ã€‚ Dockerç¤¾åŒºçš„ä¿®å¤æ—¨åœ¨æ¶ˆé™¤å…¶â€œå¤åˆ¶â€ç‰¹æ€§ä¸­çš„ç¬¦å·é“¾æ¥è§£ææ¬ºéª—ï¼Œä½†ç”±äºç¬¬ä¸‰æ–¹åŒ…çš„ä¸å¯æ§è¡Œä¸ºè€Œå¯¼è‡´éæ³•æ‰§è¡Œé—®é¢˜ã€‚ â€˜copy â€˜ç‰¹æ€§ä¸­çš„ä¿®å¤ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨chrootåœ¨è®¿é—®å®¹å™¨çš„è·¯å¾„ä¹‹å‰è¿›å…¥å®¹å™¨æ–‡ä»¶ç³»ç»Ÿï¼Œç¡®ä¿æ­¤è·¯å¾„ä¸­çš„ä»»ä½•ç¬¦å·é“¾æ¥æ€»æ˜¯åœ¨å®¹å™¨ä¸­è§£æã€‚ ç„¶è€Œï¼Œè¢«â€™ copy â€˜åŠŸèƒ½è°ƒç”¨çš„ç¬¬ä¸‰æ–¹åŒ…å¯èƒ½æ²¡æœ‰æ„è¯†åˆ°chrootä¼šå°†å®ƒä»¬å¸¦å…¥ä¸å—ä¿¡ä»»çš„ç¯å¢ƒï¼Œä¾‹å¦‚ï¼ŒCVE-2019-14271æ˜¯ç”±â€™ nsswitch â€˜åº“æ„å¤–åŠ è½½åˆ°å®¹å™¨ä¸­å¼•èµ·çš„(å‚è§3.2èŠ‚)ã€‚ç¤¾åŒºé€šè¿‡åœ¨å¤åˆ¶å¼€å§‹æ—¶åŠ è½½æ‰€æœ‰åŠ¨æ€åº“ä¸´æ—¶ä¿®å¤äº†æ­¤æ¼æ´ã€‚GNU Cåº“(glibc)çš„æ›´æ–°(å®ƒå¯¹ä»»ä½•å®¹å™¨å·¥å…·éƒ½æ˜¯é€æ˜çš„)å¯èƒ½ä¼šä½¿æ­¤ä¿®å¤æ— æ•ˆã€‚æ­¤æ›´æ–°ä½¿glibcåº“ï¼ŒåŒ…æ‹¬â€™ nsswitch â€˜ï¼Œåœ¨chrootè§¦å‘ä¸Šä¸‹æ–‡åˆ‡æ¢åè‡ªåŠ¨é‡æ–°åŠ è½½ã€‚ è§‚å¯Ÿ2 -æ“ä½œç³»ç»Ÿæ¥å£ç›¸å…³çš„æ¼æ´å¾ˆéš¾è¢«å®¹å™¨å·¥å…·å½»åº•ä¿®å¤ å®¹å™¨å·¥å…·æ— æ³•æ¶ˆé™¤ä¸ä¼ªæ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„æ­¤ç±»æ¼æ´ã€‚ è€ƒè™‘åˆ°æ¼æ´CVE-2019-5736ï¼Œä¿®å¤åªèƒ½é˜»æ­¢æ”»å‡»åæœï¼Œè€Œä¸èƒ½æ¶ˆé™¤Procfsä¸­çš„æ”»å‡»é¢ã€‚å…·ä½“åœ°è¯´ï¼Œæ­¤ä¿®å¤æ—¨åœ¨ç”Ÿæˆruncå¯æ‰§è¡Œæ–‡ä»¶çš„å‰¯æœ¬ï¼Œä»¥æ‰§è¡Œæ¯ä¸ªä¸»æœº-å®¹å™¨äº¤äº’ã€‚å³ä½¿CVE-2019-5736æ¼æ´å¯ä»¥è¢«æˆåŠŸåˆ©ç”¨ï¼Œä¹Ÿåªæ˜¯è¦†ç›–å‰¯æœ¬è€Œä¸æ˜¯åŸå§‹å‰¯æœ¬ã€‚æ­¤å¤–ï¼ŒCgroupfsæ¥å£ç›¸å…³çš„æ¼æ´CVE-2022-0492ä¹Ÿæ— æ³•é€šè¿‡å®¹å™¨å·¥å…·æ¶ˆé™¤ã€‚ä»–ä»¬çš„è§£å†³æ–¹æ¡ˆåªæ˜¯å‡å°‘å®¹å™¨çš„ç‰¹æƒ(å³ç¦ç”¨ç‰¹æƒç”¨æˆ·åç©ºé—´)ï¼Œä»¥é¿å…å®¹å™¨ä¿®æ”¹â€œrelease_agentâ€ï¼Œä½†è¿™ä¼šå½±å“è¿è¡Œå®¹å™¨çš„èƒ½åŠ›ã€‚æœ€åï¼Œå†…æ ¸è¡¥ä¸å¯¹æ˜“å—æ”»å‡»çš„æ¥å£å®æ–½è®¿é—®æ§åˆ¶ï¼Œå½»åº•ä¿®å¤äº†è¿™ä¸ªæ¼æ´ã€‚ Insightç”¨æˆ·åŸŸä¸­çš„ä¿®å¤å—åˆ°å®¹å™¨å·¥å…·ä¸­çš„ç¬¬ä¸‰æ–¹ç»„ä»¶çš„é˜»ç¢ï¼Œè¿™äº›ç»„ä»¶æ— æ³•æ¶ˆé™¤æ— å¤„ä¸åœ¨çš„Pamiré£é™©çš„æ ¹æœ¬åŸå› ã€‚ä»æ ¹æœ¬ä¸Šè¯´ï¼Œå¸•ç±³å°”é£é™©æºäºä¸å®Œæ•´çš„åŸºäºå†…æ ¸çš„éš”ç¦»ã€‚æ”¹è¿›è¿™ç§æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ˜¯è§£å†³è¿™ä¸ªé—®é¢˜çš„æœ€ä½³æ–¹æ¡ˆã€‚ æ´å¯Ÿ1 -åœ¨ç”¨æˆ·åŒºä¿®å¤æ˜¯æ— æ•ˆå’Œä¸åˆ‡å®é™…çš„æ ¹é™¤å¸•ç±³å°”é£é™©ã€‚ å…³äºPamiré£é™©ï¼Œå¯¹å®¹å™¨å·¥å…·çš„å…¨é¢æ£€æŸ¥åªèƒ½å¤„ç†å®¹å™¨å·¥å…·æœ¬èº«çš„æ”»å‡»é¢ï¼Œè€Œä¸èƒ½å¤„ç†å…¶ç›¸å…³ç»„ä»¶ã€‚ä¾‹å¦‚ï¼ŒKubernetesç¤¾åŒºå¢åŠ äº†å¤§çº¦3700è¡Œä»£ç æ¥æ‰§è¡Œè·¯å¾„è§£ææ£€æŸ¥ï¼Œè¿™åªä¼šå‡è½»CVE-2017-1002101æ¼æ´ï¼ŒåŒæ—¶åœ¨å…¶ç›¸å…³ç»„ä»¶ä¸­æš´éœ²ç›¸åŒçš„æ”»å‡»é¢ã€‚CVE-2021-30465å’ŒCVE-2021-25741ç­‰æ¼æ´å¯ä»¥ç»•è¿‡è¿™äº›æ£€æŸ¥ã€‚å®¹å™¨å·¥å…·ä½¿ç”¨ç‰¹åˆ«çš„è§£å†³æ–¹æ¡ˆæ¥è§„é¿ç¬¬ä¸‰æ–¹ç»„ä»¶ä¸­çš„å±é™©è¡Œä¸ºï¼Œä½†æ˜¯è¿™äº›è§£å†³æ–¹æ¡ˆå¾ˆè„†å¼±ï¼Œå¾ˆéš¾è¿›è¡Œå‘¨å¯†çš„è®¾è®¡ã€‚ä¾‹å¦‚ï¼ŒCVE-2019-14271çš„ä¿®å¤(åœ¨3.3èŠ‚ä¸­è®¨è®º)æ˜¯ä¸€ä¸ªä¸´æ—¶è§£å†³æ–¹æ¡ˆã€‚ ä¸ºæ­¤ï¼Œå¼€å‘äººå‘˜å€¾å‘äºåœ¨ç›¸å…³ç»„ä»¶ä¸­æ·»åŠ å®‰å…¨æ£€æŸ¥ï¼Œä½†è¿™æ ·çš„å»ºè®®é€šå¸¸ä¸è¢«æ¥å—ã€‚ç”±å®¹å™¨å·¥å…·ç¤¾åŒºå¼€å‘çš„åŒ…â€™ secureJoin â€˜æ˜¯GolangåŒ…â€™ filepath â€˜çš„æ‰©å±•ï¼Œå®ƒå°†è·¯å¾„è§£ææ£€æŸ¥æ·»åŠ åˆ°åŒ…â€™ filepath â€˜(åœ¨ç¬¬3.3èŠ‚ä¸­æåˆ°)ã€‚ç„¶è€Œï¼ŒGolangç¤¾åŒºæ‹’ç»å°†è¿™ä¸ªåŒ…åˆå¹¶åˆ°å®ƒçš„æ ‡å‡†åº“ä¸­ã€‚ç¤¾åŒºè®¤ä¸ºè¿™ä¸ªåŒ…åªæ˜¯ä¸ºå®¹å™¨å·¥å…·é‡èº«å®šåˆ¶çš„ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå¯ä»¥åœ¨å…¶ä»–åœ°æ–¹ä½¿ç”¨çš„é€šç”¨åŠŸèƒ½ã€‚ æ­¤å¤–ï¼ŒGolangç¤¾åŒºè®¤ä¸ºï¼Œå®¹å™¨å·¥å…·åœ¨è°ƒç”¨å…¶åº“ä¹‹å‰åº”è¯¥è¿›è¡Œå®‰å…¨æ£€æŸ¥ï¼Œå¹¶ä¸”ä¸è®¤ä¸ºè¿™æ˜¯ä»»ä½•Golangåº“çš„è´£ä»»ã€‚ ç¬¬ä¸‰æ–¹ç»„ä»¶è¯·æ±‚å®¹å™¨å·¥å…·è´Ÿè´£å®‰å…¨æ£€æŸ¥ï¼Œä½†è¿™äº›æ£€æŸ¥å¹¶ä¸èƒ½æ¶ˆé™¤å…¶ä¸­æ½œåœ¨çš„æ”»å‡»é¢ï¼Œè¿™æ˜¯ä¸€ä¸ªæ‚–è®ºã€‚é‡æ–°å®ç°æœ‰é£é™©çš„ç¬¬ä¸‰æ–¹ç»„ä»¶å¯èƒ½æˆä¸ºè§£å†³Pamiré£é™©çš„æœ€åä¸€ç§æ–¹æ³•ï¼Œä½†å®ƒéœ€è¦å¤§é‡çš„å·¥ç¨‹åŠªåŠ›ï¼Œå¹¶ä¸”å¯èƒ½ä¸ç¬¦åˆè½¯ä»¶å·¥ç¨‹ä¸­çš„æœ€ä½³å®è·µã€‚ä¾‹å¦‚ï¼ŒPodmanç¤¾åŒºä¿®æ”¹äº†40,836è¡Œä»£ç æ¥éƒ¨åˆ†å®ç°Podmanä¸­çš„Linuxå®ç”¨ç¨‹åºâ€™ nsenter â€˜ï¼Œä»…ä»…æ˜¯ä¸ºäº†è§£å†³â€™ Podman top â€˜åŠŸèƒ½ä¸­çš„CVE-20221227ã€‚æ­¤å¤–ï¼Œè¿˜æœ‰7,498è¡Œä»£ç ä¿®æ”¹æ¥å®ç°â€™ docker cp â€˜åŠŸèƒ½ä¸­çš„ç¬¬ä¸‰æ–¹åŒ…â€™ archive&#x2F;tar â€˜çš„åˆ†å‰²åŠŸèƒ½ï¼Œåœ¨ä¸´æ—¶ä¿®å¤ä¸å†æœ‰æ•ˆåï¼Œå·²å¼ƒç”¨è¯¥åŠŸèƒ½ä»¥é¿å…CVE-2019-14271ã€‚ å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯¹å®¹å™¨å·¥å…·è°ƒç”¨çš„ç¬¬ä¸‰æ–¹åŒ…çš„åˆ†æå¼ºè°ƒäº†é‡æ–°å®ç°è¿™äº›ç»„ä»¶çš„ä¸åˆç†æ€§å’Œä¸å¯æŒç»­æ€§ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬åˆ©ç”¨Golangå†…ç½®çš„åŒ…ç®¡ç†å·¥å…·æ¥è¯†åˆ«æ˜“å—æ”»å‡»ç‰¹æ€§è°ƒç”¨çš„åŒ…ï¼Œå¹¶é€’å½’æŸ¥è¯¢ç½‘ç«™pkg.go.dev[18]æ¥è¿½è¸ªè¿™äº›åŒ…çš„ä¾›åº”é“¾ã€‚ç»“æœè¡¨æ˜ï¼Œç›®å‰ï¼Œè¶…è¿‡5,458ä¸ªGolangåŒ…ä¸å®¹å™¨å·¥å…·ç›¸å…³(æˆ‘ä»¬çš„ç½‘ç«™æä¾›äº†æ›´å¤šä¿¡æ¯)ã€‚éšç€å®¹å™¨å·¥å…·çº³å…¥æ›´å¤šéœ€è¦ç®¡ç†çš„ç¬¬ä¸‰æ–¹ç»„ä»¶ï¼Œæ•°é‡å°†ä¸å¯é¿å…åœ°å¢åŠ ã€‚ æ´å¯Ÿ2 -åº”è¯¥å¢å¼ºå®¹å™¨å’Œä¸»æœºä¹‹é—´åŸºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ï¼Œä»¥æ¶ˆé™¤æ— ç©·æ— å°½çš„Pamiræ¼æ´ã€‚ å®¹å™¨å’Œä¸»æœºä¹‹é—´ä¸å®Œå…¨çš„åŸºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ˜¯æŒç»­å­˜åœ¨çš„Pamiræ¼æ´çš„æ ¹æœ¬åŸå› ã€‚mountåç§°ç©ºé—´å’Œpivot_rootæä¾›äº†ä¸€å®šç¨‹åº¦çš„éš”ç¦»ï¼Œä½†å®ƒä»¬å¹¶ä¸èƒ½å®Œå…¨è¦†ç›–æ‰€æœ‰VFSå¯¹è±¡ï¼Œæ¯”å¦‚dentryï¼Œè¿™ä½¿å¾—å†…æ ¸åœ¨è§£æäº†ç”¨æˆ·ç©ºé—´è·¯å¾„åå¾ˆéš¾åŒºåˆ†dentryå¯¹è±¡æ˜¯å¦å±äºå®¹å™¨ã€‚è¿™ç§ä¸å®Œå…¨éš”ç¦»æ„å‘³ç€ä¸»æœºä¸Šçš„è¿›ç¨‹æ— æ³•åŒºåˆ†å®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿï¼Œå¦‚æœå®‰å…¨æ£€æŸ¥ä¸é™åˆ¶è¯¥è¿›ç¨‹ï¼Œåˆ™å¯èƒ½å°†å…¶è§†ä¸ºå—ä¿¡ä»»çš„ç¯å¢ƒã€‚æ­¤å¤–ï¼Œä¸å®Œå…¨éš”ç¦»ä¸ä¼šé˜»æ­¢å®¹å™¨çš„è¿›ç¨‹é€šè¿‡éæ³•é€šé“(å¦‚â€™ &#x2F;proc&#x2F;self&#x2F;exe â€˜)è®¿é—®ä¸»æœºçš„æ–‡ä»¶ç³»ç»Ÿ(å¦‚æ¼æ´CVE-2019-5736æ‰€ç¤º)ã€‚å› æ­¤ï¼Œå¢å¼ºå®¹å™¨å’Œä¸»æœºä¹‹é—´åŸºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»å¯¹äºæ¶ˆé™¤Pamiré£é™©è‡³å…³é‡è¦ã€‚ æ€»ä¹‹ï¼Œæˆ‘ä»¬è®¤ä¸ºPamiré£é™©çš„æ ¹æœ¬åŸå› åœ¨äºå†…æ ¸ä¸­ä¸å®Œæ•´çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ã€‚å› æ­¤ï¼Œä¸ºäº†å®Œå…¨è€Œä¼˜é›…åœ°æ¶ˆé™¤é£é™©ï¼Œæˆ‘ä»¬å¿…é¡»é‡æ„å†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æœºåˆ¶ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦å°†æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æ‰©å±•åˆ°VFSä¸­çš„dentryå¯¹è±¡ï¼Œå¹¶ç¡®å®šæ¯ä¸ªdentryæ˜¯å±äºå®¹å™¨æ–‡ä»¶ç³»ç»Ÿè¿˜æ˜¯å±äºä¸»æœºã€‚ç„¶åï¼Œè¿™ç§æ‰©å±•çš„éš”ç¦»æœºåˆ¶å¯ä»¥åŸºäºè¿›ç¨‹å’Œdentryå±æ€§å¼ºåˆ¶æ‰§è¡Œè®¿é—®æ§åˆ¶ç­–ç•¥ï¼Œä»¥é˜²æ­¢å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„éæ³•è®¿é—®ã€‚é€šè¿‡å®ç°è¿™äº›æªæ–½ï¼Œæˆ‘ä»¬å¯ä»¥è§£å†³å¯¼è‡´Pamiré£é™©çš„æ½œåœ¨é—®é¢˜ï¼Œå¹¶æé«˜å®¹å™¨ç¯å¢ƒçš„æ•´ä½“å®‰å…¨æ€§ã€‚ PATROLæœ¬æ–‡æå‡ºäº†ä¸€ç§åä¸ºPAth misresolution conTROL (PATROL)çš„å®¹å™¨æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æœºåˆ¶ï¼Œè¯¥æœºåˆ¶å¯ä»¥é™åˆ¶è¡Œä¸ºï¼Œé˜²å¾¡Pamiræ”»å‡»ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†è¯¦ç»†ä»‹ç»Patrolçš„è®¾è®¡ï¼Œä»¥åŠå®ƒå¦‚ä½•ä»¥ç³»ç»Ÿçš„æ–¹å¼æ¶ˆé™¤ä¸æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„å®¹å™¨é€ƒé€¸é—®é¢˜ã€‚ Guidelinesä¸ºäº†æœ‰æ•ˆåœ°å¢å¼ºå®¹å™¨æ–‡ä»¶ç³»ç»Ÿçš„éš”ç¦»æ€§ï¼Œéœ€è¦åŠ å¼ºæŒ‚è½½åç§°ç©ºé—´ï¼Œå¹¶åŠ å¿«æˆ‘ä»¬çš„åŸå‹çš„åˆå¹¶ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œæˆ‘ä»¬å¸Œæœ›è®¾è®¡èƒ½å¤Ÿæ»¡è¶³ä»¥ä¸‹è¦æ±‚ã€‚ å®Œæ•´çš„ä¿æŠ¤ã€‚è¦æ°¸ä¹…è§£å†³å®¹å™¨è½¬ä¹‰ä¸­ä¸æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„æ¼æ´ï¼ŒPatrolå¿…é¡»èƒ½å¤Ÿéš”ç¦»æ¶æ„ç¬¦å·é“¾æ¥è§£æï¼Œå¹¶å¯¹è·¨åç§°ç©ºé—´æ–‡ä»¶è®¿é—®æ‰§è¡Œå®Œæ•´çš„æƒé™æ£€æŸ¥ã€‚ å®Œæ•´çš„å…¼å®¹æ€§ã€‚æˆ‘ä»¬å¸Œæœ›ä¸ºç”¨æˆ·åº”ç”¨ç¨‹åºæä¾›é€æ˜çš„ä¿æŠ¤ï¼Œè¿™æ ·å°±ä¸ä¼šå¯¹å®¹å™¨å·¥å…·è¿›è¡Œä»»ä½•ä¿®æ”¹ï¼Œä¹Ÿä¸ä¼šå¯¹å®¹å™¨å†…è¿è¡Œçš„ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºè¿›è¡Œä»»ä½•ä¿®æ”¹ã€‚å¹¶ä¸”Patrolä¸æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨æ¥å£åº”è¯¥æ²¡æœ‰å…¼å®¹æ€§é—®é¢˜ã€‚ æœ€å°çš„æ€§èƒ½æŸå¤±ã€‚åœ¨æ— æœåŠ¡å™¨è®¡ç®—æˆ–åŠŸèƒ½å³æœåŠ¡çš„èƒŒæ™¯ä¸‹ï¼Œäº‘æœåŠ¡æä¾›å•†å’Œç”¨æˆ·éƒ½æœŸæœ›å¿«é€Ÿéƒ¨ç½²æ— æœåŠ¡å™¨åŠŸèƒ½ã€‚æ­¤å¤–ï¼Œé¢„è®¡ä»»ä½•è¿è¡Œæ—¶æ£€æŸ¥éƒ½ä¸ä¼šæ˜¾è‘—æŸå®³æ€§èƒ½ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„å®‰å…¨å¢å¼ºå†…æ ¸çš„å®ç°æ—¢ç®€å•åˆä¼˜é›…ï¼ŒåŒæ—¶ä¿æŒä¸æœ¬æœºLinuxç›¸å½“çš„æ€§èƒ½ã€‚ Overview æˆ‘ä»¬çš„æ€»ä½“ç›®æ ‡æ˜¯ä¿æŒç³»ç»Ÿå¹³ç¨³è¿è¡Œï¼ŒåŒæ—¶å°½å¯èƒ½åœ°éš”ç¦»å®¹å™¨å’Œä¸»æœºæ–‡ä»¶ç³»ç»Ÿã€‚ åœ¨Patrolçš„è®¾è®¡èƒŒåï¼Œä¸»è¦æ€æƒ³æ˜¯å¢å¼ºåŸºäºå†…æ ¸çš„å®¹å™¨æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ã€‚ å›¾3è¯´æ˜äº†ä¸æˆ‘ä»¬æ‰©å±•çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ç›¸å…³çš„æ–°è®¾è®¡ã€‚é€šè¿‡åœ¨æ¯ä¸ªå®¹å™¨å†…çš„dentryä¸Šæ”¾ç½®æ ‡è®°ï¼ŒPatrolå°†éš”ç¦»æ‰©å±•åˆ°VFSå¯¹è±¡ã€‚æˆ‘ä»¬ç§°è¿™ä¸ªè¿‡ç¨‹ä¸ºâ€œæ¸²æŸ“â€ã€‚åº”è¯¥æ³¨æ„çš„æ˜¯ï¼Œä¸»æœºè¿›ç¨‹ä¹Ÿå¯ä»¥é€šè¿‡å®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿå¹¶è®¿é—®ä¸»æœºçš„dentry(åœ¨3.2èŠ‚ä¸­æåˆ°)ï¼Œå› æ­¤å¼€å§‹æ—¶çš„é™æ€å‘ˆç°æ˜¯ä¸å¤Ÿçš„ã€‚å› æ­¤ï¼ŒPatrolè¿˜æ‰§è¡ŒåŠ¨æ€è·¯å¾„æŸ¥æ‰¾å‘ˆç°ï¼Œå¹¶åœ¨è·¯å¾„è§£ææœŸé—´è°ƒèŠ‚å¯¹è¿™äº›dentryçš„è®¿é—®ã€‚é€šè¿‡å°†å‘ˆç°è¿‡ç¨‹å’Œè®¿é—®æ§åˆ¶é›†æˆåˆ°Linuxè·¯å¾„æŸ¥æ‰¾ä¾‹ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä½¿éš”ç¦»æˆä¸ºä¸€ä¸ªå®Œæ•´çš„éƒ¨åˆ†ã€‚è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œåœ¨æ„å»ºè¿‡ç¨‹ä¸­ï¼ŒPatrolå¯ä»¥éå¸¸è½»é‡çº§å’Œç´§å‡‘ï¼Œå°½å¯èƒ½å‡å°‘å†—ä½™ä»£ç ï¼Œå¹¶å°†æ€§èƒ½å¼€é”€é™è‡³æœ€ä½ã€‚ åŒºåˆ†å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„dentriesã€‚ åœ¨å®¹å™¨åˆå§‹åŒ–æœŸé—´ï¼Œæˆ‘ä»¬éœ€è¦è¯†åˆ«VFSä¸­å®¹å™¨æ–‡ä»¶ç³»ç»Ÿçš„dentryå¯¹è±¡ï¼Œå¹¶åŒºåˆ†å®¹å™¨æ–‡ä»¶ç³»ç»Ÿå’Œä¸»æœºæ–‡ä»¶ç³»ç»Ÿä¸­çš„å¯¹è±¡ã€‚è¿™ç§è¯†åˆ«å¯¹äºä¸ºä»¥åçš„è®¿é—®æ§åˆ¶å»ºç«‹åŸºç¡€è‡³å…³é‡è¦ã€‚å‘ˆç°æ˜¯æŒ‡ç¤ºæ¡ç›®æ‰€å±èŒƒå›´çš„æœ‰æ•ˆæ–¹æ³•ã€‚ ä½¿ç”¨ç‰¹å®šçš„ä¿¡æ¯ï¼Œæ¯”å¦‚å®¹å™¨æ–‡ä»¶ç³»ç»Ÿçš„æ ¹è·¯å¾„ï¼Œæ“ä½œç³»ç»Ÿå¯ä»¥é€šè¿‡dentryæ ‘ç¡®å®šdentryçš„èŒƒå›´ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬ç»“åˆäº†é™æ€åˆå§‹å‘ˆç°å’ŒåŠ¨æ€è·¯å¾„æŸ¥æ‰¾å‘ˆç°æœºåˆ¶æ¥å®ŒæˆåŒºåˆ†å’Œéš”ç¦»æœºåˆ¶(è¯¦è§4.3èŠ‚)ã€‚ ç„¶è€Œï¼Œè®¸å¤šç°æœ‰çš„å®¹å™¨å·¥å…·æä¾›äº†ä¸€ä¸ªâ€œå…±äº«å·â€æ¥å£(ä¾‹å¦‚â€™ docker run -v â€˜)ï¼Œå®ƒå…è®¸åœ¨å®¹å™¨ä¹‹é—´æˆ–åœ¨ä¸»æœºå’Œå®¹å™¨ä¹‹é—´å…±äº«æ–‡ä»¶ï¼Œè¿™ä½¿å¾—å‘ˆç°æ›´åŠ å¤æ‚ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å®šä¹‰åœ¨è€ƒè™‘å®é™…å®¹å™¨æ–‡ä»¶è®¿é—®åœºæ™¯æ—¶ä½¿ç”¨å¤šä¸ªå®‰å…¨çº§åˆ«ã€‚ç›®æ ‡æ–‡ä»¶å¯ä»¥ä½äºä»¥ä¸‹ä¸‰ç§æ–‡ä»¶ä¹‹ä¸€:åœ¨å®¹å™¨æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œåœ¨ä¸»æœºçš„æ–‡ä»¶ç³»ç»Ÿä¸Šï¼Œæˆ–è€…åœ¨ä¸»æœºå’Œ(å¤šä¸ª)å®¹å™¨ä¹‹é—´å…±äº«ã€‚é¦–å…ˆï¼Œæ­£å¦‚æˆ‘ä»¬çš„å¨èƒæ¨¡å‹(ç¬¬3.1èŠ‚)æ‰€æè¿°çš„ï¼Œå®¹å™¨æ˜¯ä¸å¯ä¿¡çš„ã€‚æ”»å‡»è€…å¯ä»¥æ“çºµå…¶å®¹å™¨ä¸­çš„æ‰€æœ‰å†…å®¹ï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»å¯¹æ¯ä¸ªå®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿåº”ç”¨æœ€ä¸¥æ ¼çš„è®¿é—®æ§åˆ¶ç­–ç•¥ã€‚ä¸ºäº†å°†æ•°æ®æŒä¹…åŒ–åˆ°å…±äº«å·ä¸­ï¼Œåº•å±‚å®ç°ä½¿ç”¨â€œbind mountâ€1å°†ä¸»æœºä¸­çš„è·¯å¾„ç»‘å®šåˆ°å®¹å™¨ã€‚å…±äº«å·å¯ä»¥çœ‹ä½œæ˜¯å®¹å™¨æ–‡ä»¶ç³»ç»Ÿçš„æ‰©å±•ï¼Œä½†æ˜¯å†…å®¹å¯ä»¥ç”±ä¸åŒçš„å…±äº«æ–¹è®¿é—®ã€‚å› æ­¤ï¼Œå…¶æ¬¡ï¼Œæˆ‘ä»¬åº”è¯¥åœ¨è¿è¡Œæ—¶è®¾ç½®æ ‡ç­¾ï¼Œä»¥åŒºåˆ†å¯¹å…±äº«å·å…·æœ‰è®¿é—®æƒé™çš„ä¸»é¢˜ã€‚æœ€åï¼Œä¸»æœºæ–‡ä»¶å…·æœ‰æœ€ä½çš„é£é™©çº§åˆ«(å³æœ€é«˜çš„å®‰å…¨çº§åˆ«)ï¼Œåªèƒ½ç”±ä¸»æœºè¿›ç¨‹è®¿é—®ã€‚ è®¿é—®æ§åˆ¶å’Œç­–ç•¥å®æ–½ã€‚ å‘ˆç°ä¹‹åï¼ŒPatrolçŸ¥é“åˆ†é…ç»™æ¯ä¸€æ–¹çš„æ¡ç›®ã€‚è¿™å…è®¸è®¿é—®æ§åˆ¶æªæ–½çš„å®ç°ï¼Œæœ€ç»ˆé˜»æ­¢ä»»ä½•æ¶æ„çš„ä¼å›¾ã€‚ä¸ºäº†é˜»æ­¢å®¹å™¨é€ƒé€¸ï¼Œä¸€ä¸ªç®€å•çš„ç­–ç•¥æ˜¯ï¼Œå®¹å™¨ä¸­çš„ä»»ä½•æ–‡ä»¶è·¯å¾„éƒ½ä¸èƒ½åœ¨å®¹å™¨æ–‡ä»¶ç³»ç»Ÿä¹‹å¤–è¢«è§£æã€‚ç„¶è€Œï¼Œè¿™ç§ç®€å•çš„è®¿é—®æ§åˆ¶è®¾è®¡æ˜¯ä¸å‡†ç¡®å’Œå…¨é¢çš„ã€‚ä¾‹å¦‚ï¼Œå±äºå®¹å™¨å·¥å…·çš„ä¸»æœºè¿›ç¨‹å…·æœ‰å¯¹å®¹å™¨å¤–éƒ¨å¯¹è±¡çš„è®¿é—®æƒé™ï¼Œè€Œè¯¥è®¿é—®è¯·æ±‚ä¸åº”ç”±å®¹å™¨å†…éƒ¨çš„åº”ç”¨ç¨‹åºè¯±å¯¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦é™åˆ¶è·¯å¾„è§£æè¯·æ±‚ï¼Œè¿™äº›è¯·æ±‚æ¥è‡ªä¸»æœºè¿›ç¨‹ï¼Œä½†æ„å‘³ç€åœ¨å®¹å™¨å†…äº§ç”Ÿå½±å“ã€‚ æˆ‘ä»¬çš„è®¿é—®æ§åˆ¶ç­–ç•¥(å¦‚ç¬¬4.4èŠ‚æ‰€è¿°)åœ¨ç¬¬4.5èŠ‚æ‰€è¿°çš„è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­å¼ºåˆ¶æ‰§è¡Œã€‚æˆ‘ä»¬çš„ç­–ç•¥åŒ…æ‹¬æ£€æŸ¥è·¯å¾„è§£æç»“æœå’Œæ–‡ä»¶æ‰§è¡Œæƒé™ã€‚è¿™äº›ç­–ç•¥å¯¹åº”äºæˆ‘ä»¬è®¾è®¡çš„ä¸¤ç§ç±»å‹çš„è§„åˆ™â€”â€”ä¸€ç§ä¸å¯¹è±¡è®¿é—®æœ‰å…³ï¼Œå¦ä¸€ç§ä¸æ§åˆ¶ä¼ è¾“æœ‰å…³ã€‚ ä¸ºäº†ç¡®ä¿ç­–ç•¥æ‰§è¡Œä¸ä¼šæ˜¾è‘—å½±å“ç³»ç»Ÿæ€§èƒ½å¹¶å……åˆ†è°ƒèŠ‚è®¿é—®ï¼Œæˆ‘ä»¬æ‹¦æˆªæ‰€æœ‰è·¯å¾„è§£æè¯·æ±‚ï¼Œè¿™æ˜¯æ”¯æ’‘Patrolå¼€å‘çš„æ ¸å¿ƒæ¦‚å¿µã€‚æˆ‘ä»¬å°†Patrolè®¾è®¡ä¸ºä¸x86æ¶æ„ä¸Šçš„Linuxå†…æ ¸5.4.1å…¼å®¹ï¼Œæ€»å…±æ’å…¥å¤§çº¦420ä¸ªlocï¼Œè¿™äº›locæ€»æ˜¯è¢«è°ƒç”¨å¹¶ä¸”è¶³å¤Ÿå°ã€‚ä¸ºäº†ç¡®ä¿å®Œå…¨å…¼å®¹ï¼Œæˆ‘ä»¬è¿˜æ”¹è¿›äº†Patrolçš„å®ç°ï¼Œä»¥å……åˆ†åˆ©ç”¨å†…æ ¸å¯¹ç‰¹å®šä¿¡æ¯çš„æ¨ç†èƒ½åŠ›(è§4.6èŠ‚)ã€‚è¿™æ„å‘³ç€å®ƒå¯ä»¥åœ¨å†…æ ¸ä¸­åº”ç”¨ï¼Œè€Œä¸ä¼šå½±å“ä¸Šå±‚åº”ç”¨ç¨‹åºã€‚æˆ‘ä»¬ä½¿ç”¨å¯å‘å¼è§„åˆ™æ¥åŒ…å«ç¬¦å·é“¾æ¥çš„è§£æèŒƒå›´ã€‚ Multi-Stage Renderingä»VFSä¸­ï¼Œå†…æ ¸æ— æ³•åˆ¤æ–­ç›®å½•æ¡ç›®(dentry)å¯¹è±¡æ˜¯å¦å±äºå®¹å™¨ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åœ¨VFSä¸­æ ‡è®°dentriesæ¥åŒºåˆ†å®ƒä»¬ã€‚åŒæ—¶ï¼Œä¸ºäº†è¯†åˆ«æœ€ç»ˆè·å¾—çš„dentryåœ¨è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­æ˜¯å¦å­˜åœ¨å®‰å…¨é£é™©ï¼Œè¿™é‡Œæˆ‘ä»¬å°†é™æ€(åˆå§‹å‘ˆç°)å’ŒåŠ¨æ€(è·¯å¾„æŸ¥æ‰¾å‘ˆç°)æ–¹æ³•ç»“åˆèµ·æ¥å¹¶ä½¿ç”¨æ­¤å¤šé˜¶æ®µå‘ˆç°ç­–ç•¥æ¥è·Ÿè¸ªè·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹æ‰€è·¨è¶Šçš„èŒƒå›´ï¼Œä»¥ä¾¿ä»¥åè¿›è¡Œè®¿é—®æ§åˆ¶ã€‚ åœ¨ä¸åŒèŒƒå›´ä¸Šçš„åˆå§‹æ¸²æŸ“ã€‚ æˆ‘ä»¬ç»™å‡ºäº†ä½œç”¨åŸŸçš„å®šä¹‰ï¼Œå®ƒæ˜¯å±äºå®¹å™¨æˆ–å…±äº«å·çš„ä¸€ç»„æ¡ç›®ï¼Œå…¶åŠŸèƒ½å—æˆ‘ä»¬çš„å®‰å…¨ç­–ç•¥é™åˆ¶ã€‚ æˆ‘ä»¬æ‰©å±•äº†PIDå‘½åç©ºé—´ç»“æ„ï¼Œæ·»åŠ äº†ä¸€ä¸ªenumå˜é‡â€œsecurity_levelâ€ä½œä¸ºå®‰å…¨çº§åˆ«æ ‡å¿—ã€‚è¯¥æ ‡å¿—æœ‰ä¸‰ä¸ªå¯èƒ½çš„å€¼:strict (-2)ï¼Œ shared(-1)å’Œnormal(0)ï¼Œå®ƒä»¬åˆ†åˆ«ä»£è¡¨ä¸‰ä¸ªèŒƒå›´ã€‚ä¸ºäº†æ ‡è®°ä¸åŒçš„ä½œç”¨åŸŸï¼Œæ‰©å±•äº†â€™ dentry â€˜ç»“æ„ï¼Œå¹¶æ·»åŠ äº†PIDåç§°ç©ºé—´æŒ‡é’ˆä½œä¸ºæ ‡è®°ï¼Œç”¨äºåŒºåˆ†å½“å‰dentryæ‰€å±çš„åç§°ç©ºé—´ã€‚PIDåç§°ç©ºé—´ä¸­çš„å®‰å…¨çº§åˆ«æ ‡å¿—è¡¨ç¤ºå…¥å£çš„å±é™©çº§åˆ«ã€‚ç”±äºæˆ‘ä»¬ä¸ä¿¡ä»»å®¹å™¨ï¼Œå®¹å™¨ä¸­çš„æ–‡ä»¶(ç”±dentrieså¼•ç”¨)åº”è¯¥è¢«æ ‡è®°ä¸ºæœ€é«˜é£é™©çº§åˆ«(ä¹Ÿå°±æ˜¯æœ€ä½å®‰å…¨çº§åˆ«)â€”â€”â€œstrictâ€ã€‚é¡¾åæ€ä¹‰ï¼Œæˆ‘ä»¬å°†åˆ†åˆ«ä¸ºå…±äº«å·å’Œä¸»æœºä¸­çš„dentryåˆ†é…â€œsharedâ€å’Œâ€œnormalâ€ã€‚è¿™ç§å‘ˆç°ç­–ç•¥çš„ä¼˜ç‚¹æ˜¯ï¼Œåç§°ç©ºé—´å¯ä»¥è‡ªç„¶åœ°åŒºåˆ†ä¸åŒçš„å®¹å™¨ï¼Œå¹¶å¯ç”¨äºé˜²æ­¢ä»¥ååœ¨ä¸»æœºå’Œå®¹å™¨ä¹‹é—´è¿›è¡Œéæ³•è®¿é—®ã€‚ åœ¨å®¹å™¨å¯åŠ¨æœŸé—´ï¼Œå°†åˆ›å»ºä¸€ä¸ªç›¸å…³çš„æ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶ä¸ºå®¹å™¨çš„dentryåˆ†é…ä¸€ä¸ªèŒƒå›´å”¯ä¸€çš„æ ‡è®°ã€‚pivot_rootå‡½æ•°ç”¨äºå°†å®¹å™¨è¿›ç¨‹åˆ‡æ¢åˆ°å®¹å™¨rootfsçš„æ ¹ç›®å½•ã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨pivot_rootçš„ç›®æ ‡ç›®å½•ä½œä¸ºèµ·ç‚¹ï¼Œéå†å…¶ä¸‹çš„æ‰€æœ‰dentryã€‚dentryæ˜¯é€’å½’åœ°éå†çš„ï¼Œå¦‚æœä¸€ä¸ªdentryæ˜¯æŒ‚è½½ç‚¹ï¼Œé‚£ä¹ˆå±äºæŒ‚è½½æ–‡ä»¶ç³»ç»Ÿçš„dentryä¹Ÿä¼šè¢«æ ‡è®°ã€‚å±äºå®¹å™¨çš„å…¥å£çš„å®‰å…¨çº§åˆ«æ ‡å¿—è¢«è®¾ç½®ä¸ºâ€œstrictâ€ã€‚åœ¨å…±äº«å·çš„æƒ…å†µä¸‹ï¼Œè¢«ç»‘å®šæŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿç”±ä¸»æœºå’Œå®¹å™¨å…±äº«ã€‚åˆ†é…ä¸€ä¸ªæ–°çš„ä¸´æ—¶PIDåç§°ç©ºé—´æ¥æ ‡è®°å…±äº«å·ä¸­çš„dentryï¼Œå¹¶å°†å®‰å…¨çº§åˆ«æ ‡å¿—è®¾ç½®ä¸ºâ€œsharedâ€ã€‚ ã€‚ä»…ä»…ä¾é åŸºäºåˆå§‹PIDåç§°ç©ºé—´çš„dentryæ ‡è¯†æ˜¯ä¸è¶³ä»¥è¿›è¡Œè®¿é—®æ§åˆ¶çš„ã€‚ä¾‹å¦‚ï¼Œå½“ä¸»æœºè¿›ç¨‹è®¿é—®å¹¶è§£æå®¹å™¨ä¸­çš„ç¬¦å·é“¾æ¥æ—¶ï¼Œå¯ä»¥è·å¾—ä¸»æœºæ–‡ä»¶çš„dentryã€‚ è·¯å¾„æŸ¥æ‰¾ç»“æœè¡¨æ˜ä¸»æœºè¿›ç¨‹è®¿é—®äº†ä¸€ä¸ªä¸»æœºæ–‡ä»¶ï¼Œè¿™ä¼¼ä¹æ˜¯åˆæ³•çš„ã€‚ä½†æ˜¯ï¼Œè¯¥è¿›ç¨‹å®é™…ä¸Šè¿›å…¥äº†ä¸€ä¸ªä¸å—ä¿¡ä»»çš„å®¹å™¨æ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶ä¸”é€šè¿‡æ¶æ„ç¬¦å·é“¾æ¥è¯±å¯¼äº†å¯¹å®¹å™¨å¤–éƒ¨çš„éæ³•è®¿é—®ã€‚ è¿™å°†å¸¦æ¥é‡å¤§çš„å®‰å…¨é£é™©ï¼Œéœ€è¦åŠ ä»¥æ§åˆ¶ã€‚ ç”±äºè·¯å¾„æŸ¥æ‰¾å°†è·¨è¶Šä¸»æœºå’Œå®¹å™¨ä¹‹é—´çš„åç§°ç©ºé—´ï¼Œå› æ­¤åº”è¯¥æ‰§è¡ŒåŠ¨æ€è·¯å¾„æŸ¥æ‰¾å‘ˆç°ï¼Œä»¥ç¡®å®šæ­¤æŸ¥æ‰¾è¿‡ç¨‹æ˜¯å¦è¿›å…¥äº†å…·æœ‰è¾ƒä½å®‰å…¨çº§åˆ«çš„åç§°ç©ºé—´ã€‚ è·¯å¾„æŸ¥æ‰¾æ¸²æŸ“ ä»…ä»…ä¾é åŸºäºåˆå§‹PIDåç§°ç©ºé—´çš„dentryæ ‡è¯†æ˜¯ä¸è¶³ä»¥è¿›è¡Œè®¿é—®æ§åˆ¶çš„ã€‚ä¾‹å¦‚ï¼Œå½“ä¸»æœºè¿›ç¨‹è®¿é—®å¹¶è§£æå®¹å™¨ä¸­çš„ç¬¦å·é“¾æ¥æ—¶ï¼Œå¯ä»¥è·å¾—ä¸»æœºæ–‡ä»¶çš„dentryã€‚ è·¯å¾„æŸ¥æ‰¾ç»“æœè¡¨æ˜ä¸»æœºè¿›ç¨‹è®¿é—®äº†ä¸€ä¸ªä¸»æœºæ–‡ä»¶ï¼Œè¿™ä¼¼ä¹æ˜¯åˆæ³•çš„ã€‚ä½†æ˜¯ï¼Œè¯¥è¿›ç¨‹å®é™…ä¸Šè¿›å…¥äº†ä¸€ä¸ªä¸å—ä¿¡ä»»çš„å®¹å™¨æ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶ä¸”é€šè¿‡æ¶æ„ç¬¦å·é“¾æ¥è¯±å¯¼äº†å¯¹å®¹å™¨å¤–éƒ¨çš„éæ³•è®¿é—®ã€‚ è¿™å°†å¸¦æ¥é‡å¤§çš„å®‰å…¨é£é™©ï¼Œéœ€è¦åŠ ä»¥æ§åˆ¶ã€‚ ç”±äºè·¯å¾„æŸ¥æ‰¾å°†è·¨è¶Šä¸»æœºå’Œå®¹å™¨ä¹‹é—´çš„åç§°ç©ºé—´ï¼Œå› æ­¤åº”è¯¥æ‰§è¡ŒåŠ¨æ€è·¯å¾„æŸ¥æ‰¾æ¸²æŸ“ï¼Œä»¥ç¡®å®šæ­¤æŸ¥æ‰¾è¿‡ç¨‹æ˜¯å¦è¿›å…¥äº†å…·æœ‰è¾ƒä½å®‰å…¨çº§åˆ«çš„åç§°ç©ºé—´ã€‚ åœ¨è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­ï¼Œâ€™ nameidata â€˜å¯¹è±¡ç”¨äºè®°å½•ä¸­é—´ç»“æœã€‚å› æ­¤ï¼Œæˆ‘ä»¬å‘è¯¥å¯¹è±¡æ·»åŠ ä¸€ä¸ªå¸¦æœ‰PIDåç§°ç©ºé—´æ ‡ç­¾çš„æˆå‘˜ï¼Œä»¥è·Ÿè¸ªåœ¨æ¯æ¬¡è·¯å¾„æŸ¥æ‰¾ä¸­éå†çš„æœ€å±é™©èŒƒå›´ï¼Œå¹¶ä½¿ç”¨å½“å‰è¿›ç¨‹çš„PIDåç§°ç©ºé—´æŒ‡é’ˆåœ¨è·¯å¾„æŸ¥æ‰¾å¼€å§‹æ—¶åˆå§‹åŒ–è¯¥æ ‡ç­¾ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬é€šè¿‡æ‹¦æˆªå†…æ ¸å‡½æ•°path_to_nameidataåœ¨è·¯å¾„æŸ¥æ‰¾çš„æ¯ä¸€æ­¥è°ƒç”¨æ¥æ‰§è¡ŒåŠ¨æ€æ¸²æŸ“ï¼Œä»¥å°†æ¸²æŸ“ç»“æœæ›´æ–°ä¸ºâ€™ nameidata â€˜å¯¹è±¡ã€‚æ·»åŠ åˆ°è¯¥å‡½æ•°ä¸­çš„å‘ˆç°è¿‡ç¨‹é¦–å…ˆå°†â€™ nameidata â€˜ä¸­çš„å½“å‰æ ‡è®°ä¸åˆšåˆšå‘ç°çš„dentryä¸­çš„æ ‡è®°è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åå°†â€™ nameidata â€˜ä¸­çš„æ ‡è®°å‘ˆç°ä¸ºå…·æœ‰è¾ƒä½å®‰å…¨çº§åˆ«çš„æ ‡è®°ã€‚è¿™ç§å‘ˆç°åœ¨æ¯ä¸ªè·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­éƒ½æ˜¯ä¸å¯é€†çš„ï¼Œä»¥ç¡®ä¿å¯ä»¥è¯†åˆ«ä»å¯ä¿¡ç¯å¢ƒåˆ°ä¸å¯ä¿¡ç¯å¢ƒçš„è®¿é—®ã€‚æˆ‘ä»¬åœ¨å›¾4ä¸­å±•ç¤ºäº†ç¤ºä¾‹:è¿™é‡Œçš„å­å›¾æè¿°äº†ä¸‰ç§ä¸åŒç±»å‹çš„è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­çš„åŠ¨æ€å‘ˆç°ï¼ŒåŒ…æ‹¬ä¸»æœºè¿›ç¨‹å¯¹å®¹å™¨å’Œå…±äº«å·ä¸­çš„èµ„æºçš„è®¿é—®ï¼Œä»¥åŠå®¹å™¨è¿›ç¨‹å¯¹å…±äº«å·ä¸­çš„èµ„æºçš„è®¿é—®ã€‚è¿™äº›å›¾ä¸­çš„æ¯ä¸ªç®­å¤´éƒ½æè¿°äº†æŸ¥æ‰¾dentryå’Œè°ƒç”¨path_to_nameidataå‡½æ•°çš„æ­¥éª¤ï¼Œè€Œç®­å¤´çš„é¢œè‰²æ˜¾ç¤ºäº†åœ¨â€™ nameidata â€˜å¯¹è±¡ä¸­å‘ˆç°çš„å®‰å…¨çº§åˆ«ã€‚åœ¨è¿™äº›é¢œè‰²ä¸­ï¼Œç™½è‰²è¡¨ç¤ºæœ€é«˜å®‰å…¨çº§åˆ«(â€œnormalâ€)ï¼Œé»„è‰²é˜´å½±è¡¨ç¤ºç¬¬äºŒé«˜çº§åˆ«(â€œsharedâ€)ï¼Œæœ€ä½å®‰å…¨çº§åˆ«(â€œstrictâ€)ç”¨å®é»„è‰²è¡¨ç¤ºã€‚ Access Control Policiesæ¸²æŸ“ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥å¼ºåˆ¶æ‰§è¡Œç”±æŸäº›æ ‡è®°ç¡®å®šçš„è®¿é—®æ§åˆ¶ã€‚ä¸€èˆ¬çš„è®¿é—®æ§åˆ¶è§„åˆ™å¦‚ä¸‹ã€‚ ç”±äºå®¹å™¨ä¸å—ä¿¡ä»»ï¼Œå› æ­¤å®¹å™¨è¿›ç¨‹è‚¯å®šä¸èƒ½åœ¨ä¸»æœºä¸Šè¯»å–ã€å†™å…¥æˆ–æ‰§è¡Œä»»ä½•æ–‡ä»¶ï¼Œè€Œä¸»æœºè¿›ç¨‹ä¹Ÿä¸èƒ½æ‰§è¡Œå®¹å™¨å†…çš„æ–‡ä»¶ã€‚å…±äº«å·ä¹Ÿå¯ä»¥çœ‹ä½œæ˜¯å®¹å™¨æ–‡ä»¶ç³»ç»Ÿçš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€è¦é™åˆ¶ä¸»æœºåœ¨è¿™äº›å…±äº«å·ä¸Šçš„è¡Œä¸ºã€‚ æˆ‘ä»¬å‚è€ƒäº†åŸºäºè½¯ä»¶çš„æ•…éšœéš”ç¦»ä¸­æ¦‚è¿°çš„è§„åˆ™åˆ¶å®šæŒ‡å—ã€‚æ ¹æ®æ•°æ®è®¿é—®å’Œæ§åˆ¶æµç­–ç•¥è®¾è®¡çš„åŸåˆ™ï¼Œåˆ¶å®šäº†ä¸¤æ¡ç­–ç•¥ã€‚ P1 -çº¦æŸå¯¹è±¡è®¿é—®ç»“æœã€‚ ç¬¬ä¸€æ¡è§„åˆ™æ˜¯å¯¹è·¯å¾„è§£æç»“æœè¿›è¡Œæ²™ç®±å¤„ç†ã€‚åªè¦è·¯å¾„æŸ¥æ‰¾è¿›å…¥ä¸å—ä¿¡ä»»èŒƒå›´(æ— è®ºæ˜¯ä»å®¹å™¨å¼€å§‹æŸ¥æ‰¾è¿˜æ˜¯ç¨åè¿›å…¥å®¹å™¨)ï¼Œè·¯å¾„æŸ¥æ‰¾çš„æœ€ç»ˆè¿”å›å€¼(ç»“æœ)å¿…é¡»ä½äºæ­¤ä¸å—ä¿¡ä»»åŒºåŸŸã€‚ P2 -çº¦æŸæ§åˆ¶è½¬ç§»è¡Œä¸ºã€‚ ç¬¬äºŒä¸ªç­–ç•¥æ˜¯ç”±ä¸å—ä¿¡ä»»çš„å®¹å™¨è¿›è¡Œçš„æ§åˆ¶æµä¼ è¾“å¿…é¡»ç•™åœ¨ä¸å—ä¿¡ä»»çš„åŒºåŸŸå†…ã€‚ä»»ä½•å—ä¿¡ä»»åŒºåŸŸ(å…·æœ‰æ›´é«˜çš„å®‰å…¨çº§åˆ«)ä¸­çš„è¿›ç¨‹éƒ½ä¸å…è®¸æ‰§è¡Œä¸å—ä¿¡ä»»èŒƒå›´ä¸­çš„æ–‡ä»¶ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œä»»ä½•ä»å®¹å™¨çš„å¯æ‰§è¡Œæ–‡ä»¶æ´¾ç”Ÿå‡ºæ¥ä½†å®é™…åœ¨ä¸»æœºä¸Šæ‰§è¡Œçš„æ–°è¿›ç¨‹éƒ½åº”è¯¥è¢«é˜»æ­¢ï¼Œå› ä¸ºæ§åˆ¶æƒå·²ç»è½¬ç§»åˆ°æ¶æ„å®¹å™¨ã€‚ä¸»æœºè¢«æ ‡è¯†ä¸ºå—ä¿¡ä»»åŒºåŸŸï¼Œè€Œæ‰€æœ‰å…¶ä»–åŒºåŸŸå¯¹ä¸»æœºæ¥è¯´éƒ½æ˜¯ä¸å—ä¿¡ä»»çš„ï¼Œå› æ­¤ä¸å—ä¿¡ä»»çš„å®¹å™¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„æ–‡ä»¶ä¸å…è®¸ç”±ä¸»æœºæ‰§è¡Œã€‚ Path Lookup Interceptionæˆ‘ä»¬çš„å®ç°é€šè¿‡åœ¨æŸäº›å†…æ ¸å‡½æ•°ä¸­æ’å…¥æŸäº›æ£€æŸ¥å’Œæ”¾ç½®æ …æ æ¥æä¾›å®‰å…¨ç›‘è§†æœºåˆ¶ï¼Œä½¿è¿™ä¸¤ä¸ªç­–ç•¥æˆä¸ºä¸€ä¸ªå®Œæ•´çš„è§£å†³æ–¹æ¡ˆã€‚ æˆ‘ä»¬åœ¨è·¯å¾„æŸ¥æ‰¾çš„ä¾‹ç¨‹ä¸­å®æ–½è®¿é—®æ§åˆ¶ç­–ç•¥ï¼Œæ›´å…·ä½“åœ°è¯´ï¼Œåœ¨å†…æ ¸å‡½æ•°complete_walkä¸­ã€‚ åœ¨è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­ï¼Œæ‰§è¡Œæµå¿…é¡»ç»è¿‡æ­¤å‡½æ•°ã€‚complete_walkæ˜¯ä¸€ä¸ªå¤„ç†è·¯å¾„æŸ¥æ‰¾æœ€ç»ˆç»“æœçš„å‡½æ•°ã€‚å› æ­¤ï¼Œåœ¨å…¶ä¸­å®æ–½è®¿é—®æ§åˆ¶å¯ä»¥æœ‰æ•ˆåœ°è¦†ç›–è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ï¼Œè€Œä¸ä¼šä¸¢å¤±ä»»ä½•è¯·æ±‚ã€‚ ä¸ºäº†æ‰§è¡ŒP1, Patrolå°†æ£€æŸ¥è¿›ç¨‹çš„æ ‡è®°æ˜¯å¦ä¸æ¸²æŸ“é˜¶æ®µåˆ†é…ç»™dentryçš„æ ‡è®°ä¸€è‡´ã€‚ å¦‚æœè¿›ç¨‹ä¸­çš„PIDåç§°ç©ºé—´æŒ‡é’ˆï¼Œâ€™ nameidata â€˜ä¸­çš„PIDåç§°ç©ºé—´æ ‡è®°å’Œåˆšåˆšè·å¾—çš„dentryä¸­çš„PIDåç§°ç©ºé—´æ ‡è®°ä¸åŒï¼Œåˆ™åœ¨å‡½æ•°complete_walkä¸­æ‰§è¡Œä»¥ä¸‹ç»†ç²’åº¦è®¿é—®æ§åˆ¶ã€‚å¦‚æœè¿›ç¨‹æ ‡è®°çš„å®‰å…¨çº§åˆ«ä½äºæŸ¥æ‰¾è¿‡ç¨‹ç»“æŸæ—¶å‘ç°çš„æœ€ç»ˆæ¡ç›®çš„æ ‡è®°ï¼Œåˆ™å¼ºåˆ¶é¦–å…ˆé˜»æ­¢è®¿é—®ã€‚å½“å®¹å™¨è¿›ç¨‹è¯•å›¾è®¿é—®ä¸»æœºçš„æ–‡ä»¶æ—¶ï¼Œå¯èƒ½ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚æ­¤å¤–ï¼Œå½“æœ€åä¸€ä¸ªdentryçš„æ ‡è®°çš„å®‰å…¨çº§åˆ«ä¸æ˜¯å…±äº«çš„å¹¶ä¸”é«˜äºâ€™ nameidata â€˜å¯¹è±¡ä¸­çš„æ ‡è®°æ—¶ï¼Œè®¿é—®ä¹Ÿä¼šè¢«é˜»æ­¢ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒP1å¯ä»¥é˜²æ­¢ç¬¦å·é“¾æ¥è§£æä½œå¼Šçš„é—®é¢˜(åœ¨3.2èŠ‚ä¸­æè¿°)ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œåˆ©ç”¨æ­¤ç±»æ¼æ´çš„CVE-2018-15664å°†å¯åŠ¨è·¯å¾„æŸ¥æ‰¾ï¼Œä»¥å‘ç°åº”è¯¥ä»å®¹å™¨å¤åˆ¶çš„æ–‡ä»¶ã€‚å¦‚å›¾5(å·¦)æ‰€ç¤ºï¼Œåœ¨æ­¤è·¯å¾„æŸ¥æ‰¾è¿›å…¥å®¹å™¨æ–‡ä»¶ç³»ç»Ÿåï¼Œâ€™ nameidate â€˜å¯¹è±¡è¢«æ ‡è®°ä¸ºæœ€ä½å®‰å…¨çº§åˆ«ï¼Œè€Œå®¹å™¨å†…æ¶æ„ç¬¦å·é“¾æ¥è¯¯å¯¼è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ï¼Œä»¥å‘ç°å…·æœ‰æœ€é«˜å®‰å…¨çº§åˆ«çš„æœ€ç»ˆdentryã€‚æ­¤ç»“æœä¸P1å¼ºåˆ¶æ‰§è¡Œçš„ç¦ç”¨æƒ…å†µä¸€è‡´ï¼ŒP1åœ¨è·¯å¾„æŸ¥æ‰¾ç»“æŸæ—¶è¢«æ¿€æ´»ï¼Œä»¥ç»ˆæ­¢æ­¤ç±»éæ³•è®¿é—®ã€‚ æ­¤å¤–ï¼Œä»ä¸»æœºåˆ°å…±äº«å·çš„è®¿é—®(ä½†å…¶ç»“æœæœ€ç»ˆåœ¨å…±äº«å·ä¹‹å¤–è§£æ)å¯ä»¥å—åˆ°P1çš„é™åˆ¶ï¼Œå› ä¸ºå­˜åœ¨ä»å±é™©åŒºåŸŸåˆ°å¯ä¿¡åŒºåŸŸçš„è®¿é—®è·¯å¾„(å¯èƒ½é€šè¿‡ç¬¦å·é“¾æ¥)ã€‚ ä¸ºäº†æ‰§è¡ŒP2ï¼Œæˆ‘ä»¬çš„é˜²å¾¡å°†åœ¨è·¯å¾„æŸ¥æ‰¾æœŸé—´å¯¹è¦æ‰“å¼€çš„ç›®æ ‡æ–‡ä»¶æ‰§è¡Œæ‰§è¡Œæƒé™æ£€æŸ¥ã€‚ä¸ºäº†æ›´å¥½åœ°ä¿ƒè¿›æ£€æŸ¥ï¼Œæˆ‘ä»¬åœ¨â€™ nameidata â€˜ç»“æ„ä¸­æ·»åŠ äº†è®¿é—®æ¨¡å¼æ ‡å¿—ä½œä¸ºæˆå‘˜ï¼Œä»¥æŒ‡ç¤ºåœ¨è·¯å¾„æŸ¥æ‰¾ä¹‹åæ˜¯å¦æ‰§è¡Œã€‚è¿™ä¸ªè®¿é—®æ¨¡å¼æ ‡å¿—æ˜¯ä»å¯åŠ¨è·¯å¾„æŸ¥æ‰¾çš„ç³»ç»Ÿè°ƒç”¨æœåŠ¡ä¾‹ç¨‹(å¦‚sys_openæˆ–sys_execve)çš„å‚æ•°ä¸­æ£€ç´¢å’Œåˆå§‹åŒ–çš„ã€‚å¦‚æœè°ƒç”¨sycallæœåŠ¡ä¾‹ç¨‹çš„è¿›ç¨‹çš„PIDåç§°ç©ºé—´å’Œdentryä¸­çš„PIDåç§°ç©ºé—´æ ‡ç­¾ä¸ä¸€æ ·ï¼Œpatrolå¼€å§‹åœ¨complete_walkä¸­æ£€æŸ¥P2æ˜¯å¦æ»¡è¶³ã€‚ä¸€æ—¦è¿›ç¨‹æ‹¥æœ‰æ‰§è¡Œæƒé™ï¼Œå¹¶ä¸”è¯¥è¿›ç¨‹çš„å®‰å…¨çº§åˆ«æ ‡å¿—å¤§äºdentryä¸­çš„å®‰å…¨çº§åˆ«æ ‡å¿—ï¼Œå°±ä¼šé˜»æ­¢å¯¹dentryçš„è®¿é—®ã€‚ å›¾5(å³)æè¿°äº†P2å¦‚ä½•é˜»æ­¢åˆ©ç”¨CVE-2019-14271æ¼æ´çš„æ”»å‡»ã€‚åœ¨æ”»å‡»è¿‡ç¨‹ä¸­ï¼Œå®‰å…¨çº§åˆ«æœ€é«˜çš„Dockerè¿›ç¨‹ä¼šå‘èµ·ä¸€æ¬¡è·¯å¾„æŸ¥æ‰¾ï¼ŒæŸ¥æ‰¾éœ€è¦æ‰§è¡Œçš„åŠ¨æ€é“¾æ¥åº“ã€‚ä½†æ˜¯ï¼Œæœ€åå‘ç°çš„dentryå…·æœ‰æœ€ä½çš„å®‰å…¨çº§åˆ«ï¼Œè¿™è¡¨æ˜è¯¥åº“ä½äºå®¹å™¨ä¸­ã€‚å› æ­¤ï¼ŒP2åœ¨è·¯å¾„æŸ¥æ‰¾çš„æœ€åè¢«å¼ºåˆ¶æ‰§è¡Œï¼Œä»¥ç»ˆæ­¢å°†è¦æ‰§è¡Œå…·æœ‰è¾ƒä½å®‰å…¨çº§åˆ«çš„æ–‡ä»¶(ä¾‹å¦‚ï¼Œâ€™ nsswitch â€˜)çš„Dockerè¿›ç¨‹ã€‚ Optimizations for Compatibilityä¸ºäº†åœ¨ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åºä¸­å®ç°å®Œå…¨é€æ˜ï¼Œæˆ‘ä»¬å®ç°äº†ä¸¤ç§ä¼˜åŒ–æ–¹æ¡ˆã€‚ Pivot_root overloading ç”±äºpivot_rootç³»ç»Ÿè°ƒç”¨æ˜¯åˆ‡æ¢åˆ°å®¹å™¨æ–‡ä»¶ç³»ç»Ÿçš„åŸºæœ¬æ“ä½œï¼Œå› æ­¤Patrolå¯ä»¥ä»ä¸­æˆªå–â€™ new_root â€˜å‚æ•°ï¼Œä»¥æŒ‡ç¤ºä¸¥æ ¼ä½œç”¨åŸŸçš„æ ¹è·¯å¾„ã€‚å½“ç³»ç»Ÿè°ƒç”¨è¢«é‡è½½æ—¶ï¼Œå°†æ‰§è¡Œä»¥ä¸‹å‡½æ•°ã€‚ä»æ¥æ”¶åˆ°çš„å‚æ•°â€”â€”ç›®æ ‡æ ¹çš„è·¯å¾„å¼€å§‹ï¼Œå®ƒé€’å½’åœ°éå†å…¶ä¸‹æ‰€æœ‰æ–‡ä»¶ç³»ç»Ÿçš„ç›®å½•æ¡ç›®ï¼Œå¹¶ä½¿ç”¨å½“å‰è¿›ç¨‹çš„ä¸¥æ ¼èŒƒå›´æ ‡è®°(åœ¨4.3èŠ‚ä¸­æè¿°)æ¥æ ‡è®°ç›¸å…³çš„æ¡ç›®ã€‚åªæœ‰å½“è°ƒç”¨pivot_rootç³»ç»Ÿè°ƒç”¨çš„è¿›ç¨‹ä½äºä¸å…¶çˆ¶è¿›ç¨‹ä¸åŒçš„æŒ‚è½½åç§°ç©ºé—´ä¸­æ—¶ï¼Œä¸Šè¿°é‡è½½å‡½æ•°æ‰ä¼šç”Ÿæ•ˆã€‚ Symlink containing ä¸ºäº†æ›´å¥½çš„å¯ç”¨æ€§å’Œé˜»æ­¢æˆ‘ä»¬ä¸¥æ ¼èŒƒå›´å†…æ¶æ„ç¬¦å·é“¾æ¥çš„å½±å“ï¼ŒPatrolå¯ä»¥å¼ºåˆ¶æ‰§è¡Œé¢å¤–çš„é™åˆ¶ï¼Œä»¥ç¡®ä¿æ‰€æœ‰ç¬¦å·é“¾æ¥éƒ½åœ¨æ¯ä¸ªä¸¥æ ¼&#x2F;å…±äº«èŒƒå›´çš„æ­£ç¡®æ ¹ç›®å½•ä¸‹è§£æï¼Œè€Œä¸æ˜¯ç®€å•åœ°é˜»æ­¢å®ƒä»¬ã€‚ è¿™é‡Œè¿˜é‡è½½äº†å†…æ ¸å‡½æ•°trailing_symlinkï¼Œç”¨äºé‡ç½®æŸ¥æ‰¾èµ·ç‚¹ï¼Œè¿™æ˜¯ä¸èƒ½ç»•è¿‡çš„ï¼Œå› ä¸ºç¬¦å·é“¾æ¥åº”è¯¥è€Œä¸”åªèƒ½é€šè¿‡å®ƒæ¥è§£æã€‚ æˆ‘ä»¬åœ¨PIDå‘½åç©ºé—´ç»“æ„ä¸­æ·»åŠ ä¸€ä¸ªæˆå‘˜â€™ root_path â€˜ï¼Œå®ƒå°†å­˜å‚¨æ¯ä¸ªä½œç”¨åŸŸçš„æ ¹ç›®å½•ã€‚å½“è°ƒç”¨pivot_rootæ—¶ï¼ŒPatrolå°†å®¹å™¨rootfsçš„æ ¹ç›®å½•è®¾ç½®ä¸ºâ€™ root_path â€˜å˜é‡ã€‚åœ¨trailing_symlinkä¸­ï¼ŒPatrolåœ¨å½“å‰è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­è·å–â€™ nameidata â€˜ä¸­çš„å‘½åç©ºé—´æ ‡ç­¾ï¼Œå³æŒ‡å‘PIDå‘½åç©ºé—´ç»“æ„çš„æŒ‡é’ˆ;ç„¶åï¼Œæ ¹æ®â€™ root_path â€˜é‡ç½®æŸ¥æ‰¾èµ·ç‚¹(åœ¨2.1èŠ‚ä¸­æè¿°)ã€‚ç”±äºæˆ‘ä»¬é˜²å¾¡çš„é¢„æœŸç›®æ ‡æ˜¯é˜²æ­¢ç¬¦å·é“¾æ¥åœ¨ä¸å¯ä¿¡èŒƒå›´ä¹‹å¤–è¢«è§£æï¼Œå› æ­¤æˆ‘ä»¬å®šä¹‰äº†ä»¥ä¸‹è§„åˆ™:å¦‚æœåœ¨å®¹å™¨ä¸­è§£æç¬¦å·é“¾æ¥ï¼Œåˆ™æŸ¥æ‰¾èµ·ç‚¹æ›´æ–°ä¸ºæ ¹æ®æ ‡è®°ä¿å­˜çš„æ ¹è·¯å¾„;å¦‚æœä»å®¹å™¨è§£æå…±äº«å·ä¸­çš„ç¬¦å·é“¾æ¥ï¼Œåˆ™æŸ¥æ‰¾èµ·ç‚¹ä»ç„¶æ˜¯ä¿å­˜çš„æ ¹è·¯å¾„;å¦‚æœä»ä¸»æœºè¿›ç¨‹è§£æå…±äº«å·ä¸­çš„ç¬¦å·é“¾æ¥ï¼Œåˆ™å°†èµ·ç‚¹è®¾ç½®ä¸ºå…±äº«å·çš„æŒ‚è½½ç‚¹ã€‚ SECURITY ANALYSISåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æ¼”ç¤ºæˆ‘ä»¬æå‡ºçš„é˜²å¾¡å·¡é€»å¯ä»¥é€šè¿‡å½¢å¼åŒ–åˆ†æå¢å¼ºå®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å°†å½±å“VFSä¸­è·¯å¾„æŸ¥æ‰¾ç»“æœçš„æ“ä½œ(ä¾‹å¦‚ï¼Œç³»ç»Ÿè°ƒç”¨æœåŠ¡ä¾‹ç¨‹)å»ºæ¨¡ä¸ºä¸€ä¸ªè½¬æ¢ç³»ç»Ÿï¼Œå¹¶åˆ©ç”¨Spin(ä¸€ç§ç°æˆçš„æ¨¡å‹æ£€æŸ¥)å·¥å…·)æ¥è¯†åˆ«å…·ä½“æ¨¡å‹ä¸­çš„å¸•ç±³å°”ç¼ºé™·ã€‚ç»“æœè¡¨æ˜ï¼ŒPatrolæ¶ˆé™¤äº†å½“å‰å®¹å™¨æ–‡ä»¶ç³»ç»Ÿéš”ç¦»ä¸­å‘ç°çš„æ‰€æœ‰ç¼ºé™·ã€‚ æ›´å…·ä½“åœ°è¯´ï¼Œè·¯å¾„æŸ¥æ‰¾æ˜¯é€šè¿‡æœç´¢VFSä¸­çš„dentryæ ‘å°†è·¯å¾„å­—ç¬¦ä¸²ä»ç”¨æˆ·ç©ºé—´æ˜ å°„åˆ°å†…æ ¸ç©ºé—´ä¸­ç›¸åº”çš„dentryçš„å”¯ä¸€æ–¹æ³•ã€‚æ­¤æœç´¢çš„èµ·å§‹ç‚¹ç”±æ‰§è¡Œè·¯å¾„æŸ¥æ‰¾çš„è¿›ç¨‹çš„æ ¹ç›®å½•æˆ–å½“å‰å·¥ä½œç›®å½•å†³å®šã€‚å¦‚æœæ‰¾åˆ°äº†dentryï¼Œåˆ™åœ¨æƒé™æ£€æŸ¥é€šè¿‡åï¼Œè¿›ç¨‹å¯ä»¥é€šè¿‡è¯¥dentryæ‰€æŒ‡å‘çš„inodeè®¿é—®ä¸å…¶å…³è”çš„æ–‡ä»¶ã€‚ä¸ºäº†é˜»æ­¢ä¸»æœºå’Œå®¹å™¨ä¹‹é—´çš„éæ³•è®¿é—®ï¼ŒPatrolå°†éš”ç¦»æ‰©å±•åˆ°dentryï¼Œå¹¶å¯¹Linuxçš„è·¯å¾„è§£æä¾‹ç¨‹å®æ–½è®¿é—®æ§åˆ¶ã€‚ä¸ºäº†æ­£å¼è¯„ä¼°Patrolçš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬é¦–å…ˆå»ºç«‹äº†ä¸€ä¸ªé€šç”¨æ¨¡å‹æ¥æè¿°ä¸VFSä¸­è·¯å¾„æŸ¥æ‰¾ç›¸å…³çš„çŠ¶æ€å’ŒçŠ¶æ€è½¬æ¢(ç¬¬5.1èŠ‚)ã€‚ ç„¶åï¼Œæˆ‘ä»¬åŸºäºä¸€èˆ¬æ¨¡å‹å®šä¹‰å®ç°ä¸¤ä¸ªå…·ä½“æ¨¡å‹(ä¸€ä¸ªå…·æœ‰åŸå§‹è·¯å¾„æŸ¥æ‰¾ï¼Œå¦ä¸€ä¸ªå°†Patrolé›†æˆåˆ°è·¯å¾„æŸ¥æ‰¾ä¸­)ï¼Œå¹¶ä½¿ç”¨SpinæŸ¥æ‰¾è¿™ä¸¤ä¸ªæ¨¡å‹ä¸­çš„ç¼ºé™·(ç¬¬5.2èŠ‚)ã€‚ EVALUATIONDISCUSSIONRELATED WORKCONCLUSIONæœ¬æ–‡ç³»ç»Ÿåœ°ç ”ç©¶äº†å®¹å™¨å’Œä¸»æœºä¹‹é—´æ–‡ä»¶ç³»ç»Ÿä¸å®Œå…¨éš”ç¦»åŠå…¶ç›¸äº’ä½œç”¨æ‰€å¼•èµ·çš„Pamiré£é™©ã€‚è¿™ç§ç±»å‹çš„é£é™©å¯¹ä»…é€šè¿‡å®¹å™¨å·¥å…·è¿›è¡Œç¼“è§£æ„æˆäº†é‡å¤§æŒ‘æˆ˜ã€‚æˆ‘ä»¬çš„ç ”ç©¶è¡¨æ˜ï¼Œæ¶ˆé™¤Pamiré£é™©çš„å·¨å¤§éšœç¢æ˜¯å®¹å™¨å·¥å…·ä½¿ç”¨çš„ç¬¬ä¸‰æ–¹ç»„ä»¶ï¼Œä½†åœ¨ç”¨æˆ·é¢†åŸŸæ²¡æœ‰åˆç†çš„è§£å†³æ–¹æ¡ˆæ¥è§£å†³è¿™ä¸€éšœç¢ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§åŸºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿéš”ç¦»æŠ€æœ¯ï¼Œç§°ä¸ºPatrolã€‚æ¨¡å‹æ£€éªŒè¡¨æ˜ï¼ŒPatrolå®Œå…¨æ¶ˆé™¤äº†å¸•ç±³å°”é£é™©ã€‚æˆ‘ä»¬çš„æ–¹æ³•åªç»™å†…æ ¸å’Œå®¹å™¨å·¥å…·å¸¦æ¥å¾ˆå°çš„æ€§èƒ½æŸå¤±ï¼ŒåŒæ—¶æä¾›äº†å‡ºè‰²çš„å…¼å®¹æ€§ã€‚æˆ‘ä»¬çš„å‘ç°å’Œæ–°çš„éš”ç¦»å¢å¼ºæœç€æ›´å¥½åœ°ä¸ºæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–è®¾è®¡å¥å£®çš„éš”ç¦»è¿ˆå‡ºäº†ä¸€æ­¥ã€‚","categories":[{"name":"è®ºæ–‡ç²¾è¯»","slug":"è®ºæ–‡ç²¾è¯»","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"å†…æ ¸å®‰å…¨","slug":"è®ºæ–‡ç²¾è¯»/å†…æ ¸å®‰å…¨","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"æ–‡ä»¶ç³»ç»Ÿ","slug":"æ–‡ä»¶ç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 12 åŒ…å’Œæ¨¡å—","slug":"Rustå­¦ä¹ -ç»ƒä¹ 12-åŒ…å’Œæ¨¡å—","date":"2023-09-13T05:08:07.000Z","updated":"2023-09-13T11:32:12.626Z","comments":true,"path":"2023/09/13/Rustå­¦ä¹ -ç»ƒä¹ 12-åŒ…å’Œæ¨¡å—/","link":"","permalink":"http://example.com/2023/09/13/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A012-%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 11 è¿”å›å€¼å’Œpanic!","slug":"Rustå­¦ä¹ -ç»ƒä¹ 11-è¿”å›å€¼å’Œpanic","date":"2023-09-12T12:13:13.000Z","updated":"2023-09-12T14:00:38.128Z","comments":true,"path":"2023/09/12/Rustå­¦ä¹ -ç»ƒä¹ 11-è¿”å›å€¼å’Œpanic/","link":"","permalink":"http://example.com/2023/09/12/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A011-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8Cpanic/","excerpt":"panicï¼æ·±å…¥å‰–æRust ä¸­æœ€ç®€å•çš„é”™è¯¯å¤„ç†æ–¹å¼å°±æ˜¯ä½¿ç”¨ panicã€‚å®ƒä¼šæ‰“å°å‡ºä¸€æ¡é”™è¯¯ä¿¡æ¯å¹¶æ‰“å°å‡ºæ ˆè°ƒç”¨æƒ…å†µï¼Œæœ€ç»ˆç»“æŸå½“å‰çº¿ç¨‹: è‹¥ panic å‘ç”Ÿåœ¨ main çº¿ç¨‹ï¼Œé‚£ç¨‹åºä¼šéšä¹‹é€€å‡º å¦‚æœæ˜¯åœ¨ç”Ÿæˆçš„( spawn )å­çº¿ç¨‹ä¸­å‘ç”Ÿ panic, é‚£ä¹ˆå½“å‰çš„çº¿ç¨‹ä¼šç»“æŸï¼Œä½†æ˜¯ç¨‹åºä¾ç„¶ä¼šç»§ç»­è¿è¡Œ","text":"panicï¼æ·±å…¥å‰–æRust ä¸­æœ€ç®€å•çš„é”™è¯¯å¤„ç†æ–¹å¼å°±æ˜¯ä½¿ç”¨ panicã€‚å®ƒä¼šæ‰“å°å‡ºä¸€æ¡é”™è¯¯ä¿¡æ¯å¹¶æ‰“å°å‡ºæ ˆè°ƒç”¨æƒ…å†µï¼Œæœ€ç»ˆç»“æŸå½“å‰çº¿ç¨‹: è‹¥ panic å‘ç”Ÿåœ¨ main çº¿ç¨‹ï¼Œé‚£ç¨‹åºä¼šéšä¹‹é€€å‡º å¦‚æœæ˜¯åœ¨ç”Ÿæˆçš„( spawn )å­çº¿ç¨‹ä¸­å‘ç”Ÿ panic, é‚£ä¹ˆå½“å‰çš„çº¿ç¨‹ä¼šç»“æŸï¼Œä½†æ˜¯ç¨‹åºä¾ç„¶ä¼šç»§ç»­è¿è¡Œ ğŸŒŸğŸŒŸ 123456789101112131415161718// å¡«ç©ºfn drink(beverage: &amp;str) &#123; if beverage == &quot;lemonade&quot; &#123; println!(&quot;Success!&quot;); // å®ç°ä¸‹é¢çš„ä»£ç  __ &#125; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;fn main() &#123; drink(__); println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; My Answer 123456789101112131415161718// å¡«ç©ºfn drink(beverage: &amp;str) &#123; if beverage == &quot;lemonade&quot; &#123; println!(&quot;Success!&quot;); // å®ç°ä¸‹é¢çš„ä»£ç  panic!(&quot;Test&quot;); &#125; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;fn main() &#123; drink(&quot;lemonade&quot;); println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; Answer 1234567891011121314151617use core::panic;fn drink(beverage: &amp;str) &#123; if beverage == &quot;lemonade&quot; &#123; println!(&quot;Success!&quot;); // IMPLEMENT the below code panic!(&quot;drinked, duang.....peng!&quot;) &#125; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;fn main() &#123; drink(&quot;lemonade&quot;); println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; å¸¸è§çš„panic ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728293031323334// ä¿®å¤æ‰€æœ‰çš„ panicï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; assert_eq!(&quot;abc&quot;.as_bytes(), [96, 97, 98]); let v = vec![1, 2, 3]; let ele = v[3]; let ele = v.get(3).unwrap(); // å¤§éƒ¨åˆ†æ—¶å€™ç¼–è¯‘å™¨æ˜¯å¯ä»¥å¸®æˆ‘ä»¬æå‰å‘ç°æº¢å‡ºé”™è¯¯ï¼Œå¹¶é˜»æ­¢ç¼–è¯‘é€šè¿‡ã€‚ä½†æ˜¯ä¹Ÿæœ‰ä¸€äº›æ—¶å€™ï¼Œè¿™ç§æº¢å‡ºé—®é¢˜ç›´åˆ°è¿è¡ŒæœŸæ‰ä¼šå‡ºç° let v = production_rate_per_hour(2); divide(15, 0); println!(&quot;Success!&quot;)&#125;fn divide(x:u8, y:u8) &#123; println!(&quot;&#123;&#125;&quot;, x / y)&#125;fn production_rate_per_hour(speed: u8) -&gt; f64 &#123; let cph: u8 = 221; match speed &#123; 1..=4 =&gt; (speed * cph) as f64, 5..=8 =&gt; (speed * cph) as f64 * 0.9, 9..=10 =&gt; (speed * cph) as f64 * 0.77, _ =&gt; 0 as f64, &#125;&#125;pub fn working_items_per_minute(speed: u8) -&gt; u32 &#123; (production_rate_per_hour(speed) / 60 as f64) as u32&#125; My Answer 12345678910111213141516171819202122232425262728293031323334// ä¿®å¤æ‰€æœ‰çš„ panicï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; assert_eq!(&quot;abc&quot;.as_bytes(), [97, 98, 99]); let v = vec![1, 2, 3]; let ele = v[2]; let ele = v.get(2).unwrap(); // å¤§éƒ¨åˆ†æ—¶å€™ç¼–è¯‘å™¨æ˜¯å¯ä»¥å¸®æˆ‘ä»¬æå‰å‘ç°æº¢å‡ºé”™è¯¯ï¼Œå¹¶é˜»æ­¢ç¼–è¯‘é€šè¿‡ã€‚ä½†æ˜¯ä¹Ÿæœ‰ä¸€äº›æ—¶å€™ï¼Œè¿™ç§æº¢å‡ºé—®é¢˜ç›´åˆ°è¿è¡ŒæœŸæ‰ä¼šå‡ºç° let v = production_rate_per_hour(2); divide(15, 1); println!(&quot;Success!&quot;)&#125;fn divide(x:u8, y:u8) &#123; println!(&quot;&#123;&#125;&quot;, x / y)&#125;fn production_rate_per_hour(speed: u8) -&gt; f64 &#123; let cph: u8 = 22; match speed &#123; 1..=4 =&gt; (speed * cph) as f64, 5..=8 =&gt; (speed * cph) as f64 * 0.9, 9..=10 =&gt; (speed * cph) as f64 * 0.77, _ =&gt; 0 as f64, &#125;&#125;pub fn working_items_per_minute(speed: u8) -&gt; u32 &#123; (production_rate_per_hour(speed) / 60 as f64) as u32&#125; Answer 1234567891011121314151617181920212223242526272829303132333435// MAKE the code work by fixing all panicsfn main() &#123; assert_eq!(&quot;abc&quot;.as_bytes(), [97, 98, 99]); let v = vec![1, 2, 3]; let ele = v[2]; // unwrap may panic when get return a None let ele = v.get(2).unwrap(); // Sometimes, the compiler is unable to find the overflow errors for you in compile time ,so a panic will occur let v = production_rate_per_hour(2); // because of the same reason as above, we have to wrap it in a function to make the panic occur divide(15, 1); println!(&quot;Success!&quot;)&#125;fn divide(x:u8, y:u8) &#123; println!(&quot;&#123;&#125;&quot;, x / y)&#125;fn production_rate_per_hour(speed: u8) -&gt; f64 &#123; let cph: u8 = 21; match speed &#123; 1..=4 =&gt; (speed * cph) as f64, 5..=8 =&gt; (speed * cph) as f64 * 0.9, 9..=10 =&gt; (speed * cph) as f64 * 0.77, _ =&gt; 0 as f64, &#125;&#125;pub fn working_items_per_minute(speed: u8) -&gt; u32 &#123; (production_rate_per_hour(speed) / 60 as f64) as u32&#125; è¯¦ç»†çš„æ ˆè°ƒç”¨ä¿¡æ¯é»˜è®¤æƒ…å†µä¸‹ï¼Œæ ˆè°ƒç”¨åªä¼šå±•ç¤ºæœ€åŸºæœ¬çš„ä¿¡æ¯: 123thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, src/main.rs:4:5note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace ä½†æ˜¯æœ‰æ—¶å€™ï¼Œæˆ‘ä»¬è¿˜å¸Œæœ›è·å–æ›´è¯¦ç»†çš„ä¿¡æ¯: ğŸŒŸ 1234567891011121314151617181920## å¡«ç©ºä»¥æ‰“å°å…¨éƒ¨çš„è°ƒç”¨æ ˆ## æç¤º: ä½ å¯ä»¥åœ¨ä¹‹å‰çš„é»˜è®¤ panic ä¿¡æ¯ä¸­æ‰¾åˆ°ç›¸å…³çº¿ç´¢$ __ cargo runthread &#x27;main&#x27; panicked at &#x27;assertion failed: `(left == right)` left: `[97, 98, 99]`, right: `[96, 97, 98]`&#x27;, src/main.rs:3:5stack backtrace: 0: rust_begin_unwind at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/std/src/panicking.rs:498:5 1: core::panicking::panic_fmt at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:116:14 2: core::panicking::assert_failed_inner 3: core::panicking::assert_failed at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:154:5 4: study_cargo::main at ./src/main.rs:3:5 5: core::ops::function::FnOnce::call_once at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/ops/function.rs:227:5note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace. unwindingå’Œabortå½“å‡ºç° panic! æ—¶ï¼Œç¨‹åºæä¾›äº†ä¸¤ç§æ–¹å¼æ¥å¤„ç†ç»ˆæ­¢æµç¨‹ï¼šæ ˆå±•å¼€å’Œç›´æ¥ç»ˆæ­¢ã€‚ å…¶ä¸­ï¼Œé»˜è®¤çš„æ–¹å¼å°±æ˜¯ æ ˆå±•å¼€ï¼Œè¿™æ„å‘³ç€ Rust ä¼šå›æº¯æ ˆä¸Šæ•°æ®å’Œå‡½æ•°è°ƒç”¨ï¼Œå› æ­¤ä¹Ÿæ„å‘³ç€æ›´å¤šçš„å–„åå·¥ä½œï¼Œå¥½å¤„æ˜¯å¯ä»¥ç»™å‡ºå……åˆ†çš„æŠ¥é”™ä¿¡æ¯å’Œæ ˆè°ƒç”¨ä¿¡æ¯ï¼Œä¾¿äºäº‹åçš„é—®é¢˜å¤ç›˜ã€‚ç›´æ¥ç»ˆæ­¢ï¼Œé¡¾åæ€ä¹‰ï¼Œä¸æ¸…ç†æ•°æ®å°±ç›´æ¥é€€å‡ºç¨‹åºï¼Œå–„åå·¥ä½œäº¤ä¸æ“ä½œç³»ç»Ÿæ¥è´Ÿè´£ã€‚ å¯¹äºç»å¤§å¤šæ•°ç”¨æˆ·ï¼Œä½¿ç”¨é»˜è®¤é€‰æ‹©æ˜¯æœ€å¥½çš„ï¼Œä½†æ˜¯å½“ä½ å…³å¿ƒæœ€ç»ˆç¼–è¯‘å‡ºçš„äºŒè¿›åˆ¶å¯æ‰§è¡Œæ–‡ä»¶å¤§å°æ—¶ï¼Œé‚£ä¹ˆå¯ä»¥å°è¯•å»ä½¿ç”¨ç›´æ¥ç»ˆæ­¢çš„æ–¹å¼ï¼Œä¾‹å¦‚ä¸‹é¢çš„é…ç½®ä¿®æ”¹ Cargo.toml æ–‡ä»¶ï¼Œå®ç°åœ¨ release æ¨¡å¼ä¸‹é‡åˆ° panic ç›´æ¥ç»ˆæ­¢ï¼š 12345#![allow(unused)]fn main() &#123;[profile.release]panic = &#x27;abort&#x27;&#125; result and ï¼ŸResult&lt;T&gt; æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ç”¨äºæè¿°è¿”å›çš„ç»“æœæˆ–é”™è¯¯ï¼Œå®ƒåŒ…å«ä¸¤ä¸ªæˆå‘˜(å˜ä½“ variants) : Ok(T): è¿”å›ä¸€ä¸ªç»“æœå€¼ T Err(e): è¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œe æ˜¯å…·ä½“çš„é”™è¯¯å€¼ ç®€è€Œè¨€ä¹‹ï¼Œå¦‚æœæœŸå¾…ä¸€ä¸ªæ­£ç¡®çš„ç»“æœï¼Œå°±è¿”å› Okï¼Œåä¹‹åˆ™æ˜¯ Errã€‚ ğŸŒŸğŸŒŸ 1234567891011121314151617181920// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯use std::num::ParseIntError;fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ &#123; let n1 = n1_str.parse::&lt;i32&gt;(); let n2 = n2_str.parse::&lt;i32&gt;(); Ok(n1.unwrap() * n2.unwrap())&#125;fn main() &#123; let result = multiply(&quot;10&quot;, &quot;2&quot;); assert_eq!(result, __); let result = multiply(&quot;t&quot;, &quot;2&quot;); assert_eq!(result.__, 8); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617181920// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯use std::num::ParseIntError;fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32,ParseIntError&gt; &#123; let n1 = n1_str.parse::&lt;i32&gt;()?; let n2 = n2_str.parse::&lt;i32&gt;()?; Ok(n1 * n2)&#125;fn main() &#123; let result = multiply(&quot;10&quot;, &quot;2&quot;); assert_eq!(result, Ok(20)); let result = multiply(&quot;4&quot;, &quot;2&quot;); assert_eq!(result.unwrap(), 8); println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314151617use std::num::ParseIntError;fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; let n1 = n1_str.parse::&lt;i32&gt;(); let n2 = n2_str.parse::&lt;i32&gt;(); Ok(n1.unwrap() * n2.unwrap())&#125;fn main() &#123; let result = multiply(&quot;10&quot;, &quot;2&quot;); assert_eq!(result, Ok(20)); let result = multiply(&quot;4&quot;, &quot;2&quot;); assert_eq!(result.unwrap(), 8); println!(&quot;Success!&quot;)&#125; ?? è·Ÿ unwrap éå¸¸åƒï¼Œä½†æ˜¯ ? ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œè€Œä¸æ˜¯ç›´æ¥ panic. ğŸŒŸğŸŒŸ 12345678910111213use std::num::ParseIntError;// ä½¿ç”¨ `?` æ¥å®ç° multiply// ä¸è¦ä½¿ç”¨ unwrap !fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ &#123;&#125;fn main() &#123; assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516use std::num::ParseIntError;// ä½¿ç”¨ `?` æ¥å®ç° multiply// ä¸è¦ä½¿ç”¨ unwrap !fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32,ParseIntError&gt; &#123; let a = n1_str.parse::&lt;i32&gt;()?; let b = n2_str.parse::&lt;i32&gt;()?; Ok(a*b)&#125;fn main() &#123; assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12); println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314use std::num::ParseIntError;// IMPLEMENT multiply with ?// DON&#x27;T use unwrap herefn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; let n1 = n1_str.parse::&lt;i32&gt;()?; let n2 = n2_str.parse::&lt;i32&gt;()?; Ok(n1 * n2)&#125;fn main() &#123; assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12); println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930313233use std::fs::File;use std::io::&#123;self, Read&#125;;fn read_file1() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(&quot;hello.txt&quot;); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125;// å¡«ç©º// ä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn read_file2() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); __; Ok(s)&#125;fn main() &#123; assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string()); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031use std::fs::File;use std::io::&#123;self, Read&#125;;fn read_file1() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(&quot;hello.txt&quot;); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125;// å¡«ç©º// ä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn read_file2() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?; Ok(s)&#125;fn main() &#123; assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string()); println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314151617181920212223242526272829use std::fs::File;use std::io::&#123;self, Read&#125;;fn read_file1() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(&quot;hello.txt&quot;); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125;fn read_file2() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?; Ok(s)&#125;fn main() &#123; assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string()); println!(&quot;Success!&quot;)&#125; map&amp;and_thenmap and and_then æ˜¯ä¸¤ä¸ªå¸¸ç”¨çš„ç»„åˆå™¨( combinator )ï¼Œå¯ä»¥ç”¨äº Result&lt;T, E&gt; (ä¹Ÿå¯ç”¨äº Option&lt;T&gt;). ğŸŒŸğŸŒŸ 12345678910111213use std::num::ParseIntError;// ä½¿ç”¨ä¸¤ç§æ–¹å¼å¡«ç©º: map, and thenfn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().__&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213use std::num::ParseIntError;// ä½¿ç”¨ä¸¤ç§æ–¹å¼å¡«ç©º: map, and thenfn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().map(|i|i+2)&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; 12345678910111213use std::num::ParseIntError;// ä½¿ç”¨ä¸¤ç§æ–¹å¼å¡«ç©º: map, and thenfn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().and_then(|i|Ok(i+2))&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; Answer 1234567891011use std::num::ParseIntError;fn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().map(|num| num +2)&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; 1234567891011use std::num::ParseIntError;fn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().and_then(|num| Ok(num +2))&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930313233343536373839404142use std::num::ParseIntError;// ä½¿ç”¨ Result é‡å†™åï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡å¼åŒ¹é…çš„æ–¹å¼æ¥å¤„ç†ï¼Œè€Œæ— éœ€ä½¿ç”¨ `unwrap`// ä½†æ˜¯è¿™ç§å†™æ³•å®åœ¨è¿‡äºå•°å—¦..fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; match n1_str.parse::&lt;i32&gt;() &#123; Ok(n1) =&gt; &#123; match n2_str.parse::&lt;i32&gt;() &#123; Ok(n2) =&gt; &#123; Ok(n1 * n2) &#125;, Err(e) =&gt; Err(e), &#125; &#125;, Err(e) =&gt; Err(e), &#125;&#125;// é‡å†™ä¸Šé¢çš„ `multiply` ï¼Œè®©å®ƒå°½é‡ç®€ä»‹// æç¤ºï¼šä½¿ç”¨ `and_then` å’Œ `map`fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; // å®ç°...&#125;fn print(result: Result&lt;i32, ParseIntError&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; let twenty = multiply1(&quot;10&quot;, &quot;2&quot;); print(twenty); // ä¸‹é¢çš„è°ƒç”¨ä¼šæä¾›æ›´æœ‰å¸®åŠ©çš„é”™è¯¯ä¿¡æ¯ let tt = multiply(&quot;t&quot;, &quot;2&quot;); print(tt); println!(&quot;Success!&quot;)&#125; My Answer 1ä¸ä¼š Answer 123456789101112131415161718192021222324252627282930313233343536373839404142use std::num::ParseIntError;// ä½¿ç”¨ Result é‡å†™åï¼Œæˆ‘ä»¬ä½¿ç”¨æ¨¡å¼åŒ¹é…çš„æ–¹å¼æ¥å¤„ç†ï¼Œè€Œæ— éœ€ä½¿ç”¨ `unwrap`// ä½†æ˜¯è¿™ç§å†™æ³•å®åœ¨è¿‡äºå•°å—¦..fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; match n1_str.parse::&lt;i32&gt;() &#123; Ok(n1) =&gt; &#123; match n2_str.parse::&lt;i32&gt;() &#123; Ok(n2) =&gt; &#123; Ok(n1 * n2) &#125;, Err(e) =&gt; Err(e), &#125; &#125;, Err(e) =&gt; Err(e), &#125;&#125;// é‡å†™ä¸Šé¢çš„ `multiply` ï¼Œè®©å®ƒå°½é‡ç®€ä»‹// æç¤ºï¼šä½¿ç”¨ `and_then` å’Œ `map`fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n1_str.parse::&lt;i32&gt;().and_then(|n1| &#123;n2_str.parse::&lt;i32&gt;().map(|n2|n1*n2)&#125;)&#125;fn print(result: Result&lt;i32, ParseIntError&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; let twenty = multiply1(&quot;10&quot;, &quot;2&quot;); print(twenty); // ä¸‹é¢çš„è°ƒç”¨ä¼šæä¾›æ›´æœ‰å¸®åŠ©çš„é”™è¯¯ä¿¡æ¯ let tt = multiply(&quot;2&quot;, &quot;2&quot;); print(tt); println!(&quot;Success!&quot;)&#125; ç±»å‹åˆ«åå¦‚æœæˆ‘ä»¬è¦åœ¨ä»£ç ä¸­åˆ°å¤„ä½¿ç”¨ std::result::Result&lt;T, ParseIntError&gt; ï¼Œé‚£æ¯«æ— ç–‘é—®ï¼Œä»£ç å°†å˜å¾—ç‰¹åˆ«å†—é•¿å’Œå•°å—¦ï¼Œå¯¹äºè¿™ç§æƒ…å†µï¼Œå¯ä»¥ä½¿ç”¨ç±»å‹åˆ«åæ¥è§£å†³ã€‚ ä¾‹å¦‚åœ¨æ ‡å‡†åº“ä¸­ï¼Œå°±åœ¨å¤§é‡ä½¿ç”¨è¿™ç§æ–¹å¼æ¥ç®€åŒ–ä»£ç : io::Result. ğŸŒŸ 123456789101112131415161718192021222324252627use std::num::ParseIntError;// å¡«ç©ºtype __;// ä½¿ç”¨ä¸Šé¢çš„åˆ«åæ¥å¼•ç”¨åŸæ¥çš„ `Result` ç±»å‹fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; &#123; first_number_str.parse::&lt;i32&gt;().and_then(|first_number| &#123; second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number) &#125;)&#125;// åŒæ ·, è¿™é‡Œä¹Ÿä½¿ç”¨äº†ç±»å‹åˆ«åæ¥ç®€åŒ–ä»£ç fn print(result: Res&lt;i32&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; print(multiply(&quot;10&quot;, &quot;2&quot;)); print(multiply(&quot;t&quot;, &quot;2&quot;)); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627use std::num::ParseIntError;// å¡«ç©ºtype Res&lt;T&gt; = Result&lt;T,ParseIntError&gt;;// ä½¿ç”¨ä¸Šé¢çš„åˆ«åæ¥å¼•ç”¨åŸæ¥çš„ `Result` ç±»å‹fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; &#123; first_number_str.parse::&lt;i32&gt;().and_then(|first_number| &#123; second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number) &#125;)&#125;// åŒæ ·, è¿™é‡Œä¹Ÿä½¿ç”¨äº†ç±»å‹åˆ«åæ¥ç®€åŒ–ä»£ç fn print(result: Res&lt;i32&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; print(multiply(&quot;10&quot;, &quot;2&quot;)); print(multiply(&quot;t&quot;, &quot;2&quot;)); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021222324use std::num::ParseIntError;// Define a generic alias for a `Result` with the error type `ParseIntError`.type Res&lt;T&gt; = Result&lt;T, ParseIntError&gt;;// Use the above alias to refer to our specific `Result` type.fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; &#123; first_number_str.parse::&lt;i32&gt;().and_then(|first_number| &#123; second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number) &#125;)&#125;// Here, the alias again allows us to save some space.fn print(result: Res&lt;i32&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; print(multiply(&quot;10&quot;, &quot;2&quot;)); print(multiply(&quot;t&quot;, &quot;2&quot;));&#125; åœ¨fn mainä¸­ä½¿ç”¨Resultä¸€ä¸ªå…¸å‹çš„ main å‡½æ•°é•¿è¿™æ ·: 123fn main() &#123; println!(&quot;Hello World!&quot;);&#125; äº‹å®ä¸Š main å‡½æ•°è¿˜å¯ä»¥è¿”å›ä¸€ä¸ª Result ç±»å‹ï¼šå¦‚æœ main å‡½æ•°å†…éƒ¨å‘ç”Ÿäº†é”™è¯¯ï¼Œé‚£è¯¥é”™è¯¯ä¼šè¢«è¿”å›å¹¶ä¸”æ‰“å°å‡ºä¸€æ¡é”™è¯¯çš„ debug ä¿¡æ¯ã€‚ 12345678910111213use std::num::ParseIntError;fn main() -&gt; Result&lt;(), ParseIntError&gt; &#123; let number_str = &quot;10&quot;; let number = match number_str.parse::&lt;i32&gt;() &#123; Ok(number) =&gt; number, Err(e) =&gt; return Err(e), &#125;; println!(&quot;&#123;&#125;&quot;, number); Ok(())&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 10 è®¤è¯†ç”Ÿå‘½å‘¨æœŸ","slug":"Rustå­¦ä¹ -ç»ƒä¹ 10-è®¤è¯†ç”Ÿå‘½å‘¨æœŸ","date":"2023-09-12T02:08:26.000Z","updated":"2023-09-12T12:13:48.050Z","comments":true,"path":"2023/09/12/Rustå­¦ä¹ -ç»ƒä¹ 10-è®¤è¯†ç”Ÿå‘½å‘¨æœŸ/","link":"","permalink":"http://example.com/2023/09/12/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A010-%E8%AE%A4%E8%AF%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"ç¼–è¯‘å™¨é€šè¿‡ç”Ÿå‘½å‘¨æœŸæ¥ç¡®ä¿æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯åˆæ³•çš„ï¼Œå…¸å‹çš„ï¼Œä¸€ä¸ªå˜é‡åœ¨åˆ›å»ºæ—¶ç”Ÿå‘½å‘¨æœŸéšä¹‹å¼€å§‹ï¼Œé”€æ¯æ—¶ç”Ÿå‘½å‘¨æœŸä¹Ÿéšä¹‹ç»“æŸã€‚ ç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´ ğŸŒŸ","text":"ç¼–è¯‘å™¨é€šè¿‡ç”Ÿå‘½å‘¨æœŸæ¥ç¡®ä¿æ‰€æœ‰çš„å€Ÿç”¨éƒ½æ˜¯åˆæ³•çš„ï¼Œå…¸å‹çš„ï¼Œä¸€ä¸ªå˜é‡åœ¨åˆ›å»ºæ—¶ç”Ÿå‘½å‘¨æœŸéšä¹‹å¼€å§‹ï¼Œé”€æ¯æ—¶ç”Ÿå‘½å‘¨æœŸä¹Ÿéšä¹‹ç»“æŸã€‚ ç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´ ğŸŒŸ 123456789101112131415161718/* ä¸º `i` å’Œ `borrow2` æ ‡æ³¨åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸèŒƒå›´ */// `i` æ‹¥æœ‰æœ€é•¿çš„ç”Ÿå‘½å‘¨æœŸï¼Œå› ä¸ºå®ƒçš„ä½œç”¨åŸŸå®Œæ•´çš„åŒ…å«äº† `borrow1` å’Œ `borrow2` ã€‚// è€Œ `borrow1` å’Œ `borrow2` çš„ç”Ÿå‘½å‘¨æœŸå¹¶æ— å…³è”ï¼Œå› ä¸ºå®ƒä»¬çš„ä½œç”¨åŸŸæ²¡æœ‰é‡å fn main() &#123; let i = 3; &#123; let borrow1 = &amp;i; // `borrow1` ç”Ÿå‘½å‘¨æœŸå¼€å§‹. â”€â”€â” // â”‚ println!(&quot;borrow1: &#123;&#125;&quot;, borrow1); // â”‚ &#125; // `borrow1` ç”Ÿå‘½å‘¨æœŸç»“æŸ. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ &#123; let borrow2 = &amp;i; println!(&quot;borrow2: &#123;&#125;&quot;, borrow2); &#125; &#125; My Answer ç›´æ¥å‚è€ƒç­”æ¡ˆ Answer 1234567891011121314151617fn main() &#123; let i = 3; // Lifetime for `i` starts. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” // â”‚ &#123; // â”‚ let borrow1 = &amp;i; // `borrow1` lifetime starts. â”€â”€â”â”‚ // â”‚â”‚ println!(&quot;borrow1: &#123;&#125;&quot;, borrow1); // â”‚â”‚ &#125; // `borrow1 ends. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ // â”‚ // â”‚ &#123; // â”‚ let borrow2 = &amp;i; // `borrow2` lifetime starts. â”€â”€â”â”‚ // â”‚â”‚ println!(&quot;borrow2: &#123;&#125;&quot;, borrow2); // â”‚â”‚ &#125; // `borrow2` ends. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ // â”‚&#125; // Lifetime ends. â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ğŸŒŸğŸŒŸ ç¤ºä¾‹ 1234567891011#![allow(unused)]fn main() &#123;&#123; let x = 5; // ----------+-- &#x27;b // | let r = &amp;x; // --+-- &#x27;a | // | | println!(&quot;r: &#123;&#125;&quot;, r); // | | // --+ |&#125; // ----------+&#125; 1234567891011121314/* åƒä¸Šé¢çš„ç¤ºä¾‹ä¸€æ ·ï¼Œä¸º `r` å’Œ `x` æ ‡å‡†ç”Ÿå‘½å‘¨æœŸï¼Œç„¶åä»ç”Ÿå‘½å‘¨æœŸçš„è§’åº¦. */fn main() &#123; &#123; let r; // ---------+-- &#x27;a // | &#123; // | let x = 5; // -+-- &#x27;b | r = &amp;x; // | | &#125; // -+ | // | println!(&quot;r: &#123;&#125;&quot;, r); // | &#125; // ---------+&#125; ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨Rust çš„å€Ÿç”¨æ£€æŸ¥å™¨ä½¿ç”¨æ˜¾å¼çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æ¥ç¡®å®šä¸€ä¸ªå¼•ç”¨çš„åˆæ³•èŒƒå›´ã€‚ä½†æ˜¯å¯¹äºç”¨æˆ·æ¥è¯´ï¼Œæˆ‘ä»¬åœ¨å¤§å¤šæ•°åœºæ™¯ä¸‹ï¼Œéƒ½æ— éœ€æ‰‹åŠ¨å»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼ŒåŸå› æ˜¯ç¼–è¯‘å™¨ä¼šåœ¨æŸäº›æƒ…å†µä¸‹è‡ªåŠ¨åº”ç”¨ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™ã€‚ åœ¨äº†è§£ç¼–è¯‘å™¨ä½¿ç”¨å“ªäº›è§„åˆ™å¸®æˆ‘ä»¬æ¶ˆé™¤ç”Ÿå‘½å‘¨æœŸä¹‹å‰ï¼Œé¦–å…ˆè¿˜æ˜¯éœ€è¦çŸ¥é“è¯¥å¦‚ä½•æ‰‹åŠ¨æ ‡è®°ç”Ÿå‘½å‘¨æœŸã€‚ å‡½æ•°å¤§å®¶å…ˆå¿½ç•¥ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ï¼Œå‡½æ•°ç­¾åä¸­çš„ç”Ÿå‘½å‘¨æœŸæœ‰å“ªäº›é™åˆ¶: éœ€è¦ä¸ºæ¯ä¸ªå¼•ç”¨æ ‡æ³¨ä¸Šåˆé€‚çš„ç”Ÿå‘½å‘¨æœŸ è¿”å›å€¼ä¸­çš„å¼•ç”¨ï¼Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸè¦ä¹ˆè·ŸæŸä¸ªå¼•ç”¨å‚æ•°ç›¸åŒï¼Œè¦ä¹ˆæ˜¯ &#39;static ç¤ºä¾‹ 1234567891011121314151617181920212223242526272829303132// å¼•ç”¨å‚æ•°ä¸­çš„ç”Ÿå‘½å‘¨æœŸ &#x27;a è‡³å°‘è¦è·Ÿå‡½æ•°æ´»å¾—ä¸€æ ·ä¹…fn print_one&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) &#123; println!(&quot;`print_one`: x is &#123;&#125;&quot;, x);&#125;// å¯å˜å¼•ç”¨ä¾ç„¶éœ€è¦æ ‡å‡†ç”Ÿå‘½å‘¨æœŸfn add_one&lt;&#x27;a&gt;(x: &amp;&#x27;a mut i32) &#123; *x += 1;&#125;// ä¸‹é¢ä»£ç ä¸­ï¼Œæ¯ä¸ªå‚æ•°éƒ½æ‹¥æœ‰è‡ªå·±ç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸï¼Œäº‹å®ä¸Šï¼Œè¿™ä¸ªä¾‹å­è¶³å¤Ÿç®€å•ï¼Œå› æ­¤å®ƒä»¬åº”è¯¥è¢«æ ‡è®°ä¸Šç›¸åŒçš„ç”Ÿå‘½å‘¨æœŸ `&#x27;a`ï¼Œä½†æ˜¯å¯¹äºå¤æ‚çš„ä¾‹å­è€Œè¨€ï¼Œç‹¬ç«‹çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨æ˜¯å¯èƒ½å­˜åœ¨çš„fn print_multi&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;`print_multi`: x is &#123;&#125;, y is &#123;&#125;&quot;, x, y);&#125;// è¿”å›ä¸€ä¸ªé€šè¿‡å‚æ•°ä¼ å…¥çš„å¼•ç”¨æ˜¯å¾ˆå¸¸è§çš„ï¼Œä½†æ˜¯è¿™ç§æƒ…å†µä¸‹éœ€è¦æ ‡æ³¨ä¸Šæ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸfn pass_x&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, _: &amp;&#x27;b i32) -&gt; &amp;&#x27;a i32 &#123; x &#125;fn main() &#123; let x = 7; let y = 9; print_one(&amp;x); print_multi(&amp;x, &amp;y); let z = pass_x(&amp;x, &amp;y); print_one(z); let mut t = 3; add_one(&amp;mut t); print_one(&amp;t);&#125; ğŸŒŸ 12345678910/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main() &#123;&#125; My Answer 12345678910/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ï¼Œè®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main() &#123;&#125; Answer 123456789fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main() &#123;&#125; ğŸŒŸğŸŒŸğŸŒŸ 1234567/* ä½¿ç”¨ä¸‰ç§æ–¹æ³•ä¿®å¤ä¸‹é¢çš„é”™è¯¯ */fn invalid_output&lt;&#x27;a&gt;() -&gt; &amp;&#x27;a String &#123; &amp;String::from(&quot;foo&quot;) &#125;fn main() &#123;&#125; My Answer 1234567/* ä½¿ç”¨ä¸‰ç§æ–¹æ³•ä¿®å¤ä¸‹é¢çš„é”™è¯¯ */fn invalid_output() -&gt; String &#123; String::from(&quot;foo&quot;) &#125;fn main() &#123;&#125; 1234567/* ä½¿ç”¨ä¸‰ç§æ–¹æ³•ä¿®å¤ä¸‹é¢çš„é”™è¯¯ */fn invalid_output() -&gt; Box&lt;String&gt; &#123; Box::new(String::from(&quot;foo&quot;))&#125;fn main() &#123;&#125; Answer 1234567/* ä½¿ç”¨ä¸‰ç§æ–¹æ³•ä¿®å¤ä¸‹é¢çš„é”™è¯¯ */fn invalid_output() -&gt; &amp;&#x27;static str &#123; &amp;&quot;foo&quot; &#125;fn main() &#123;&#125; 12345fn invalid_output() -&gt; String &#123; String::from(&quot;foo&quot;) &#125;fn main() &#123;&#125; 12345fn invalid_output&lt;&#x27;a&gt;(s: &amp;&#x27;a String) -&gt; &amp;&#x27;a String &#123; s&#125;fn main() &#123;&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526// `print_refs` æœ‰ä¸¤ä¸ªå¼•ç”¨å‚æ•°ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸ `&#x27;a` å’Œ `&#x27;b` è‡³å°‘å¾—è·Ÿå‡½æ•°æ´»å¾—ä¸€æ ·ä¹…fn print_refs&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;x is &#123;&#125; and y is &#123;&#125;&quot;, x, y);&#125;/* è®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */fn failed_borrow&lt;&#x27;a&gt;() &#123; let _x = 12; // ERROR: `_x` æ´»å¾—ä¸å¤Ÿä¹…does not live long enough let y: &amp;&#x27;a i32 = &amp;_x; // åœ¨å‡½æ•°å†…ä½¿ç”¨ `&#x27;a` å°†ä¼šæŠ¥é”™ï¼ŒåŸå› æ˜¯ `&amp;_x` çš„ç”Ÿå‘½å‘¨æœŸæ˜¾ç„¶æ¯” `&#x27;a` è¦å° // ä½ ä¸èƒ½å°†ä¸€ä¸ªå°çš„ç”Ÿå‘½å‘¨æœŸå¼ºè½¬æˆå¤§çš„&#125;fn main() &#123; let (four, nine) = (4, 9); print_refs(&amp;four, &amp;nine); // è¿™é‡Œï¼Œfour å’Œ nice çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»è¦æ¯”å‡½æ•° print_refs é•¿ failed_borrow(); // `failed_borrow` æ²¡æœ‰ä¼ å…¥ä»»ä½•å¼•ç”¨å»é™åˆ¶ç”Ÿå‘½å‘¨æœŸ `&#x27;a`ï¼Œå› æ­¤ï¼Œæ­¤æ—¶çš„ `&#x27;a` ç”Ÿå‘½å‘¨æœŸæ˜¯æ²¡æœ‰ä»»ä½•é™åˆ¶çš„ï¼Œå®ƒé»˜è®¤æ˜¯ `&#x27;static`&#125; My Answer 1234567891011121314151617181920212223242526// `print_refs` æœ‰ä¸¤ä¸ªå¼•ç”¨å‚æ•°ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸ `&#x27;a` å’Œ `&#x27;b` è‡³å°‘å¾—è·Ÿå‡½æ•°æ´»å¾—ä¸€æ ·ä¹…fn print_refs&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;x is &#123;&#125; and y is &#123;&#125;&quot;, x, y);&#125;/* è®©ä¸‹é¢çš„ä»£ç å·¥ä½œ */fn failed_borrow&lt;&#x27;a&gt;() &#123; let _x = 12; // ERROR: `_x` æ´»å¾—ä¸å¤Ÿä¹…does not live long enough let y: &amp;i32 = &amp;_x; // åœ¨å‡½æ•°å†…ä½¿ç”¨ `&#x27;a` å°†ä¼šæŠ¥é”™ï¼ŒåŸå› æ˜¯ `&amp;_x` çš„ç”Ÿå‘½å‘¨æœŸæ˜¾ç„¶æ¯” `&#x27;a` è¦å° // ä½ ä¸èƒ½å°†ä¸€ä¸ªå°çš„ç”Ÿå‘½å‘¨æœŸå¼ºè½¬æˆå¤§çš„&#125;fn main() &#123; let (four, nine) = (4, 9); print_refs(&amp;four, &amp;nine); // è¿™é‡Œï¼Œfour å’Œ nice çš„ç”Ÿå‘½å‘¨æœŸå¿…é¡»è¦æ¯”å‡½æ•° print_refs é•¿ failed_borrow(); // `failed_borrow` æ²¡æœ‰ä¼ å…¥ä»»ä½•å¼•ç”¨å»é™åˆ¶ç”Ÿå‘½å‘¨æœŸ `&#x27;a`ï¼Œå› æ­¤ï¼Œæ­¤æ—¶çš„ `&#x27;a` ç”Ÿå‘½å‘¨æœŸæ˜¯æ²¡æœ‰ä»»ä½•é™åˆ¶çš„ï¼Œå®ƒé»˜è®¤æ˜¯ `&#x27;static`&#125; Answer 123456789101112131415161718fn print_refs&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;x is &#123;&#125; and y is &#123;&#125;&quot;, x, y);&#125;/* Make it work */fn failed_borrow&lt;&#x27;a&gt;() &#123; let _x = 12; let y: &amp;i32 = &amp;_x;&#125;fn main() &#123; let (four, nine) = (4, 9); print_refs(&amp;four, &amp;nine); failed_borrow();&#125; struct ğŸŒŸ 123456789101112131415161718192021222324252627282930313233/* å¢åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡å‡†ï¼Œè®©ä»£ç å·¥ä½œ */// `i32` çš„å¼•ç”¨å¿…é¡»æ¯” `Borrowed` æ´»å¾—æ›´ä¹…#[derive(Debug)]struct Borrowed(&amp;i32);// ç±»ä¼¼çš„ï¼Œä¸‹é¢ä¸¤ä¸ªå¼•ç”¨ä¹Ÿå¿…é¡»æ¯”ç»“æ„ä½“ `NamedBorrowed` æ´»å¾—æ›´ä¹…#[derive(Debug)]struct NamedBorrowed &#123; x: &amp;i32, y: &amp;i32,&#125;#[derive(Debug)]enum Either &#123; Num(i32), Ref(&amp;i32),&#125;fn main() &#123; let x = 18; let y = 15; let single = Borrowed(&amp;x); let double = NamedBorrowed &#123; x: &amp;x, y: &amp;y &#125;; let reference = Either::Ref(&amp;x); let number = Either::Num(y); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, single); println!(&quot;x and y are borrowed in &#123;:?&#125;&quot;, double); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, reference); println!(&quot;y is *not* borrowed in &#123;:?&#125;&quot;, number);&#125; My Answer 123456789101112131415161718192021222324252627282930313233/* å¢åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸæ ‡å‡†ï¼Œè®©ä»£ç å·¥ä½œ */// `i32` çš„å¼•ç”¨å¿…é¡»æ¯” `Borrowed` æ´»å¾—æ›´ä¹…#[derive(Debug)]struct Borrowed&lt;&#x27;a&gt;(&amp;&#x27;a i32);// ç±»ä¼¼çš„ï¼Œä¸‹é¢ä¸¤ä¸ªå¼•ç”¨ä¹Ÿå¿…é¡»æ¯”ç»“æ„ä½“ `NamedBorrowed` æ´»å¾—æ›´ä¹…#[derive(Debug)]struct NamedBorrowed&lt;&#x27;a&gt;&#123; x: &amp;&#x27;a i32, y: &amp;&#x27;a i32,&#125;#[derive(Debug)]enum Either&lt;&#x27;a&gt;&#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123; let x = 18; let y = 15; let single = Borrowed(&amp;x); let double = NamedBorrowed &#123; x: &amp;x, y: &amp;y &#125;; let reference = Either::Ref(&amp;x); let number = Either::Num(y); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, single); println!(&quot;x and y are borrowed in &#123;:?&#125;&quot;, double); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, reference); println!(&quot;y is *not* borrowed in &#123;:?&#125;&quot;, number);&#125; Answer 123456789101112131415161718192021222324252627282930313233// A type `Borrowed` which houses a reference to an// `i32`. The reference to `i32` must outlive `Borrowed`.#[derive(Debug)]struct Borrowed&lt;&#x27;a&gt;(&amp;&#x27;a i32);// Similarly, both references here must outlive this structure.#[derive(Debug)]struct NamedBorrowed&lt;&#x27;a&gt; &#123; x: &amp;&#x27;a i32, y: &amp;&#x27;a i32,&#125;// An enum which is either an `i32` or a reference to one.#[derive(Debug)]enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123; let x = 18; let y = 15; let single = Borrowed(&amp;x); let double = NamedBorrowed &#123; x: &amp;x, y: &amp;y &#125;; let reference = Either::Ref(&amp;x); let number = Either::Num(y); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, single); println!(&quot;x and y are borrowed in &#123;:?&#125;&quot;, double); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, reference); println!(&quot;y is *not* borrowed in &#123;:?&#125;&quot;, number);&#125; ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425/* è®©ä»£ç å·¥ä½œ */#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;fn main()&#123; let var_a = 35; let example: Example; &#123; let var_b = NoCopyType &#123;&#125;; /* ä¿®å¤é”™è¯¯ */ example = Example &#123; a: &amp;var_a, b: &amp;var_b &#125;; &#125; println!(&quot;(Success!) &#123;:?&#125;&quot;, example);&#125; My Answer 12345678910111213141516171819202122232425/* è®©ä»£ç å·¥ä½œ */#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType,&#125;fn main() &#123; let var_a = 35; let example: Example; let var_b = NoCopyType &#123;&#125;; /* ä¿®å¤é”™è¯¯ */ example = Example &#123; a: &amp;var_a, b: &amp;var_b, &#125;; println!(&quot;(Success!) &#123;:?&#125;&quot;, example);&#125; Answer 1234567891011121314151617181920212223242526272829/* Make it work */#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType,&#125;fn main() &#123; /* &#x27;a tied to fn-main stackframe */ let var_a = 35; let example: Example; // &#123; /* lifetime &#x27;b tied to new stackframe/scope */ let var_b = NoCopyType &#123;&#125;; /* fixme */ example = Example &#123; a: &amp;var_a, b: &amp;var_b, &#125;; // &#125; println!(&quot;(Success!) &#123;:?&#125;&quot;, example);&#125; ğŸŒŸğŸŒŸ 123456789101112131415161718192021#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]#[allow(dead_code)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;/* ä¿®å¤å‡½æ•°çš„ç­¾å */fn fix_me(foo: &amp;Example) -&gt; &amp;NoCopyType&#123; foo.b &#125;fn main()&#123; let no_copy = NoCopyType &#123;&#125;; let example = Example &#123; a: &amp;1, b: &amp;no_copy &#125;; fix_me(&amp;example); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]#[allow(dead_code)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;/* ä¿®å¤å‡½æ•°çš„ç­¾å */fn fix_me&lt;&#x27;a&gt;(foo: &amp;&#x27;a Example) -&gt; &amp;&#x27;a NoCopyType&#123; foo.b &#125;fn main()&#123; let no_copy = NoCopyType &#123;&#125;; let example = Example &#123; a: &amp;1, b: &amp;no_copy &#125;; fix_me(&amp;example); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]#[allow(dead_code)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;/* Fix function signature */fn fix_me&lt;&#x27;b&gt;(foo: &amp;Example&lt;&#x27;_, &#x27;b&gt;) -&gt; &amp;&#x27;b NoCopyType&#123; foo.b &#125;fn main()&#123; let no_copy = NoCopyType &#123;&#125;; let example = Example &#123; a: &amp;1, b: &amp;no_copy &#125;; fix_me(&amp;example); print!(&quot;Success!&quot;)&#125; æ–¹æ³•æ–¹æ³•çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨è·Ÿå‡½æ•°ç±»ä¼¼ã€‚ ç¤ºä¾‹ 123456789101112131415struct Owner(i32);impl Owner &#123; fn add_one&lt;&#x27;a&gt;(&amp;&#x27;a mut self) &#123; self.0 += 1; &#125; fn print&lt;&#x27;a&gt;(&amp;&#x27;a self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;fn main() &#123; let mut owner = Owner(18); owner.add_one(); owner.print();&#125; ğŸŒŸğŸŒŸ 123456789101112/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸè®©ä¸‹é¢ä»£ç å·¥ä½œ */struct ImportantExcerpt &#123; part: &amp;str,&#125;impl ImportantExcerpt &#123; fn level(&amp;&#x27;a self) -&gt; i32 &#123; 3 &#125;&#125;fn main() &#123;&#125; My Answer 123456789101112/* æ·»åŠ åˆé€‚çš„ç”Ÿå‘½å‘¨æœŸè®©ä¸‹é¢ä»£ç å·¥ä½œ */struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl ImportantExcerpt&lt;&#x27;_&gt; &#123; fn level&lt;&#x27;a&gt;(&amp;&#x27;a self) -&gt; i32 &#123; 3 &#125;&#125;fn main() &#123;&#125; Answer 1234567891011struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn level(&amp;&#x27;a self) -&gt; i32 &#123; 3 &#125;&#125;fn main() &#123;&#125; ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤ï¼ˆElision)æœ‰ä¸€äº›ç”Ÿå‘½å‘¨æœŸçš„æ ‡æ³¨æ–¹å¼å¾ˆå¸¸è§ï¼Œå› æ­¤ç¼–è¯‘å™¨æä¾›äº†ä¸€äº›è§„åˆ™ï¼Œå¯ä»¥è®©æˆ‘ä»¬åœ¨ä¸€äº›åœºæ™¯ä¸‹æ— éœ€å»æ ‡æ³¨ç”Ÿå‘½å‘¨æœŸï¼Œæ—¢èŠ‚çœäº†æ•²å‡»é”®ç›˜çš„ç¹çï¼Œåˆèƒ½æå‡å¯è¯»æ€§ã€‚ è¿™ç§è§„åˆ™è¢«ç§°ä¸ºç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤è§„åˆ™( Elision )ï¼Œè¯¥è§„åˆ™ä¹‹æ‰€ä»¥å­˜åœ¨ï¼Œä»…ä»…æ˜¯å› ä¸ºè¿™äº›åœºæ™¯å¤ªé€šç”¨äº†ï¼Œä¸ºäº†æ–¹ä¾¿ç”¨æˆ·è€Œå·²ã€‚äº‹å®ä¸Šå¯¹äºå€Ÿç”¨æ£€æŸ¥å™¨è€Œè¨€ï¼Œè¯¥æœ‰çš„ç”Ÿå‘½å‘¨æœŸä¸€ä¸ªéƒ½ä¸èƒ½å°‘ï¼Œåªä¸è¿‡å¯¹äºç”¨æˆ·è€Œè¨€ï¼Œå¯ä»¥çœå»ä¸€äº›ã€‚ ğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829303132/* ç§»é™¤æ‰€æœ‰å¯ä»¥æ¶ˆé™¤çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ */fn nput&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) &#123; println!(&quot;`annotated_input`: &#123;&#125;&quot;, x);&#125;fn pass&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123; x &#125;fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str &#123; x&#125;struct Owner(i32);impl Owner &#123; fn add_one&lt;&#x27;a&gt;(&amp;&#x27;a mut self) &#123; self.0 += 1; &#125; fn print&lt;&#x27;a&gt;(&amp;&#x27;a self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;struct Person&lt;&#x27;a&gt; &#123; age: u8, name: &amp;&#x27;a str,&#125;enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123;&#125; My Answer 1234567891011121314151617181920212223242526272829303132/* ç§»é™¤æ‰€æœ‰å¯ä»¥æ¶ˆé™¤çš„ç”Ÿå‘½å‘¨æœŸæ ‡æ³¨ */fn nput(x: &amp; i32) &#123; println!(&quot;`annotated_input`: &#123;&#125;&quot;, x);&#125;fn pass(x: &amp; i32) -&gt; &amp; i32 &#123; x &#125;fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str &#123; x&#125;struct Owner(i32);impl Owner &#123; fn add_one(&amp; mut self) &#123; self.0 += 1; &#125; fn print(&amp; self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;struct Person&lt;&#x27;a&gt; &#123; age: u8, name: &amp;&#x27;a str,&#125;enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123;&#125; Answer 12345678910111213141516171819202122232425262728293031fn nput(x: &amp;i32) &#123; println!(&quot;`annotated_input`: &#123;&#125;&quot;, x);&#125;fn pass(x: &amp;i32) -&gt; &amp;i32 &#123; x &#125;fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str &#123; x&#125;struct Owner(i32);impl Owner &#123; // Annotate lifetimes as in a standalone function. fn add_one(&amp;mut self) &#123; self.0 += 1; &#125; fn print(&amp;self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;struct Person&lt;&#x27;a&gt; &#123; age: u8, name: &amp;&#x27;a str,&#125;enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123;&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 9 é›†åˆç±»å‹","slug":"Rustå­¦ä¹ -ç»ƒä¹ 9-é›†åˆç±»å‹","date":"2023-09-11T12:57:21.000Z","updated":"2023-09-12T01:19:14.438Z","comments":true,"path":"2023/09/11/Rustå­¦ä¹ -ç»ƒä¹ 9-é›†åˆç±»å‹/","link":"","permalink":"http://example.com/2023/09/11/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A09-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"åŠ¨æ€æ•°ç»„Vectorç›¸æ¯” [T; N] å½¢å¼çš„æ•°ç»„ï¼Œ Vector æœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯å¯ä»¥åŠ¨æ€è°ƒæ•´é•¿åº¦ã€‚ åŸºæœ¬æ“ä½œ","text":"åŠ¨æ€æ•°ç»„Vectorç›¸æ¯” [T; N] å½¢å¼çš„æ•°ç»„ï¼Œ Vector æœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯å¯ä»¥åŠ¨æ€è°ƒæ•´é•¿åº¦ã€‚ åŸºæœ¬æ“ä½œ ğŸŒŸğŸŒŸğŸŒŸ 123456789101112131415161718192021222324fn main() &#123; let arr: [u8; 3] = [1, 2, 3]; let v = Vec::from(arr); is_vec(v); let v = vec![1, 2, 3]; is_vec(v); // vec!(..) å’Œ vec![..] æ˜¯åŒæ ·çš„å®ï¼Œå®å¯ä»¥ä½¿ç”¨ []ã€()ã€&#123;&#125;ä¸‰ç§å½¢å¼ï¼Œå› æ­¤... let v = vec!(1, 2, 3); is_vec(v); // ...åœ¨ä¸‹é¢çš„ä»£ç ä¸­, v æ˜¯ Vec&lt;[u8; 3]&gt; , è€Œä¸æ˜¯ Vec&lt;u8&gt; // ä½¿ç”¨ Vec::new å’Œ `for` æ¥é‡å†™ä¸‹é¢è¿™æ®µä»£ç  let v1 = vec!(arr); is_vec(v1); assert_eq!(v, v1); println!(&quot;Success!&quot;)&#125;fn is_vec(v: Vec&lt;u8&gt;) &#123;&#125; My Answer 123456789101112131415161718192021222324252627fn main() &#123; let arr: [u8; 3] = [1, 2, 3]; let v = Vec::from(arr); is_vec(v.clone()); let v = vec![1, 2, 3]; is_vec(v.clone()); // vec!(..) å’Œ vec![..] æ˜¯åŒæ ·çš„å®ï¼Œå®å¯ä»¥ä½¿ç”¨ []ã€()ã€&#123;&#125;ä¸‰ç§å½¢å¼ï¼Œå› æ­¤... let v = vec!(1, 2, 3); is_vec(v.clone()); // ...åœ¨ä¸‹é¢çš„ä»£ç ä¸­, v æ˜¯ Vec&lt;[u8; 3]&gt; , è€Œä¸æ˜¯ Vec&lt;u8&gt; // ä½¿ç”¨ Vec::new å’Œ `for` æ¥é‡å†™ä¸‹é¢è¿™æ®µä»£ç  let mut v1 = Vec::new(); for i in &amp;arr&#123; v1.push(*i); &#125; is_vec(v1.clone()); assert_eq!(v, v1); println!(&quot;Success!&quot;)&#125;fn is_vec(v: Vec&lt;u8&gt;) &#123;&#125; Answer 123456789101112131415161718192021222324fn main() &#123; let arr: [u8; 3] = [1, 2, 3]; let v = Vec::from(arr); is_vec(v); let v = vec![1, 2, 3]; is_vec(v); // vec!(..) å’Œ vec![..] æ˜¯åŒæ ·çš„å®ï¼Œå®å¯ä»¥ä½¿ç”¨ []ã€()ã€&#123;&#125;ä¸‰ç§å½¢å¼ï¼Œå› æ­¤... let v = vec!(1, 2, 3); is_vec(v); // ...åœ¨ä¸‹é¢çš„ä»£ç ä¸­, v æ˜¯ Vec&lt;[u8; 3]&gt; , è€Œä¸æ˜¯ Vec&lt;u8&gt; // ä½¿ç”¨ Vec::new å’Œ `for` æ¥é‡å†™ä¸‹é¢è¿™æ®µä»£ç  let v1 = vec!(arr); is_vec(v1); assert_eq!(v, v1); println!(&quot;Success!&quot;)&#125;fn is_vec(v: Vec&lt;u8&gt;) &#123;&#125; ğŸŒŸğŸŒŸ Vec å¯ä»¥ä½¿ç”¨ extend æ–¹æ³•è¿›è¡Œæ‰©å±• 12345678910111213// å¡«ç©ºfn main() &#123; let mut v1 = Vec::from([1, 2, 4]); v1.pop(); v1.push(3); let mut v2 = Vec::new(); v2.__; assert_eq!(v1, v2); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213// å¡«ç©ºfn main() &#123; let mut v1 = Vec::from([1, 2, 4]); v1.pop(); v1.push(3); let mut v2 = Vec::new(); v2.extend([1,2,3]); assert_eq!(v1, v2); println!(&quot;Success!&quot;)&#125; Answer 123456789101112fn main() &#123; let mut v1 = Vec::from([1, 2, 4]); v1.pop(); v1.push(3); let mut v2 = Vec::new(); v2.extend([1, 2, 3]); assert_eq!(format!(&quot;&#123;:?&#125;&quot;,v1), format!(&quot;&#123;:?&#125;&quot;,v2)); println!(&quot;Success!&quot;)&#125; å°†Xç±»å‹è½¬æ¢ï¼ˆFrom&#x2F;Intoç‰¹å¾ï¼‰æˆVecåªè¦ä¸º Vec å®ç°äº† From&lt;T&gt; ç‰¹å¾ï¼Œé‚£ä¹ˆ T å°±å¯ä»¥è¢«è½¬æ¢æˆ Vecã€‚ ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829// å¡«ç©ºfn main() &#123; // array -&gt; Vec // impl From&lt;[T; N]&gt; for Vec let arr = [1, 2, 3]; let v1 = __(arr); let v2: Vec&lt;i32&gt; = arr.__(); assert_eq!(v1, v2); // String -&gt; Vec // impl From&lt;String&gt; for Vec let s = &quot;hello&quot;.to_string(); let v1: Vec&lt;u8&gt; = s.__(); let s = &quot;hello&quot;.to_string(); let v2 = s.into_bytes(); assert_eq!(v1, v2); // impl&lt;&#x27;_&gt; From&lt;&amp;&#x27;_ str&gt; for Vec let s = &quot;hello&quot;; let v3 = Vec::__(s); assert_eq!(v2, v3); // è¿­ä»£å™¨ Iterators å¯ä»¥é€šè¿‡ collect å˜æˆ Vec let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect(); assert_eq!(v4, vec![0; 10]); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031// å¡«ç©º fn main() &#123; // array -&gt; Vec // impl From&lt;[T; N]&gt; for Vec let arr = [1, 2, 3]; let v1 = Vec::from(arr); let v2: Vec&lt;i32&gt; = arr.to_vec(); assert_eq!(v1, v2); // String -&gt; Vec // impl From&lt;String&gt; for Vec let s = &quot;hello&quot;.to_string(); let v1: Vec&lt;u8&gt; = Vec::from(s); let s = &quot;hello&quot;.to_string(); let v2 = s.into_bytes(); assert_eq!(v1, v2); // impl&lt;&#x27;_&gt; From&lt;&amp;&#x27;_ str&gt; for Vec let s = &quot;hello&quot;; let v3 = Vec::from(s); assert_eq!(v2, v3); // è¿­ä»£å™¨ Iterators å¯ä»¥é€šè¿‡ collect å˜æˆ Vec let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect(); assert_eq!(v4, vec![0; 10]); println!(&quot;Success!&quot;) &#125; Answer 1234567891011121314151617181920212223fn main() &#123; // array -&gt; Vec let arr = [1, 2, 3]; let v1 = Vec::from(arr); let v2: Vec&lt;i32&gt; = arr.into(); assert_eq!(v1, v2); // String -&gt; Vec let s = &quot;hello&quot;.to_string(); let v1: Vec&lt;u8&gt; = s.into(); let s = &quot;hello&quot;.to_string(); let v2 = s.into_bytes(); assert_eq!(v1, v2); let s = &quot;hello&quot;; let v3 = Vec::from(s); assert_eq!(v2, v3); println!(&quot;Success!&quot;) &#125; ç´¢å¼• ğŸŒŸğŸŒŸğŸŒŸ 123456789101112131415// ä¿®å¤é”™è¯¯å¹¶å®ç°ç¼ºå¤±çš„ä»£ç fn main() &#123; let mut v = Vec::from([1, 2, 3]); for i in 0..5 &#123; println!(&quot;&#123;:?&#125;&quot;, v[i]) &#125; for i in 0..5 &#123; // å®ç°è¿™é‡Œçš„ä»£ç ... &#125; assert_eq!(v, vec![2, 3, 4, 5, 6]); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819// ä¿®å¤é”™è¯¯å¹¶å®ç°ç¼ºå¤±çš„ä»£ç fn main() &#123; let mut v = Vec::from([1, 2, 3]); for i in 0..5 &#123; println!(&quot;&#123;:?&#125;&quot;, v.get(i)); &#125; for i in 0..5 &#123; // å®ç°è¿™é‡Œçš„ä»£ç ... match v.get(i) &#123; Some(p) =&gt; v[i]+=1 , None =&gt; v.push(i+2), &#125; &#125; assert_eq!(v, vec![2, 3, 4, 5, 6]); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415// ä¿®å¤é”™è¯¯å¹¶å®ç°ç¼ºå¤±çš„ä»£ç fn main() &#123; let mut v = Vec::from([1, 2, 3]); for i in 0..5 &#123; println!(&quot;&#123;:?&#125;&quot;, v[i]) &#125; for i in 0..5 &#123; // å®ç°è¿™é‡Œçš„ä»£ç ... &#125; assert_eq!(v, vec![2, 3, 4, 5, 6]); println!(&quot;Success!&quot;)&#125; åˆ‡ç‰‡ä¸ String çš„åˆ‡ç‰‡ç±»ä¼¼ï¼Œ Vec ä¹Ÿå¯ä»¥ä½¿ç”¨åˆ‡ç‰‡ã€‚å¦‚æœè¯´ Vec æ˜¯å¯å˜çš„ï¼Œé‚£å®ƒçš„åˆ‡ç‰‡å°±æ˜¯ä¸å¯å˜æˆ–è€…è¯´åªè¯»çš„ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ &amp; æ¥è·å–åˆ‡ç‰‡ã€‚ åœ¨ Rust ä¸­ï¼Œå°†åˆ‡ç‰‡ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’æ˜¯æ›´å¸¸è§çš„ä½¿ç”¨æ–¹å¼ï¼Œä¾‹å¦‚å½“ä¸€ä¸ªå‡½æ•°åªéœ€è¦å¯è¯»æ€§æ—¶ï¼Œé‚£ä¼ é€’ Vec æˆ– String çš„åˆ‡ç‰‡ &amp;[T] &#x2F; &amp;str ä¼šæ›´åŠ é€‚åˆã€‚ ğŸŒŸğŸŒŸ 12345678910111213141516171819202122// ä¿®å¤é”™è¯¯fn main() &#123; let mut v = vec![1, 2, 3]; let slice1 = &amp;v[..]; // è¶Šç•Œè®¿é—®å°†å¯¼è‡´ panic. // ä¿®æ”¹æ—¶å¿…é¡»ä½¿ç”¨ `v.len` let slice2 = &amp;v[0..4]; assert_eq!(slice1, slice2); // åˆ‡ç‰‡æ˜¯åªè¯»çš„ // æ³¨æ„ï¼šåˆ‡ç‰‡å’Œ `&amp;Vec` æ˜¯ä¸åŒçš„ç±»å‹ï¼Œåè€…ä»…ä»…æ˜¯ `Vec` çš„å¼•ç”¨ï¼Œå¹¶å¯ä»¥é€šè¿‡è§£å¼•ç”¨ç›´æ¥è·å– `Vec` let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v; (*vec_ref).push(4); let slice3 = &amp;mut v[0..3]; slice3.push(4); assert_eq!(slice3, &amp;[1, 2, 3, 4]); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021// ä¿®å¤é”™è¯¯fn main() &#123; let mut v = vec![1, 2, 3]; let slice1 = &amp;v[..]; // è¶Šç•Œè®¿é—®å°†å¯¼è‡´ panic. // ä¿®æ”¹æ—¶å¿…é¡»ä½¿ç”¨ `v.len` let slice2 = &amp;v[0..v.len()]; assert_eq!(slice1, slice2); // åˆ‡ç‰‡æ˜¯åªè¯»çš„ // æ³¨æ„ï¼šåˆ‡ç‰‡å’Œ `&amp;Vec` æ˜¯ä¸åŒçš„ç±»å‹ï¼Œåè€…ä»…ä»…æ˜¯ `Vec` çš„å¼•ç”¨ï¼Œå¹¶å¯ä»¥é€šè¿‡è§£å¼•ç”¨ç›´æ¥è·å– `Vec` let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v; (*vec_ref).push(4); let slice3 = &amp;mut v[0..3]; assert_eq!(slice3, &amp;[1, 2, 3]); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021// FIX the errorsfn main() &#123; let mut v = vec![1, 2, 3]; let slice1 = &amp;v[..]; // out of bounds will cause a panic // You must use `v.len` here let slice2 = &amp;v[0..v.len()]; assert_eq!(slice1, slice2); // slice are read only // Note: slice and &amp;Vec are different let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v; (*vec_ref).push(4); let slice3 = &amp;mut v[0..]; assert_eq!(slice3, &amp;[1, 2, 3, 4]); println!(&quot;Success!&quot;)&#125; å®¹é‡å®¹é‡ capacity æ˜¯å·²ç»åˆ†é…å¥½çš„å†…å­˜ç©ºé—´ï¼Œç”¨äºå­˜å‚¨æœªæ¥æ·»åŠ åˆ° Vec ä¸­çš„å…ƒç´ ã€‚è€Œé•¿åº¦ len åˆ™æ˜¯å½“å‰ Vec ä¸­å·²ç»å­˜å‚¨çš„å…ƒç´ æ•°é‡ã€‚å¦‚æœè¦æ·»åŠ æ–°å…ƒç´ æ—¶ï¼Œé•¿åº¦å°†è¦è¶…è¿‡å·²æœ‰çš„å®¹é‡ï¼Œé‚£å®¹é‡ä¼šè‡ªåŠ¨è¿›è¡Œå¢é•¿ï¼šRust ä¼šé‡æ–°åˆ†é…ä¸€å—æ›´å¤§çš„å†…å­˜ç©ºé—´ï¼Œç„¶åå°†ä¹‹å‰çš„ Vec æ‹·è´è¿‡å»ï¼Œå› æ­¤ï¼Œè¿™é‡Œå°±ä¼šå‘ç”Ÿæ–°çš„å†…å­˜åˆ†é…( ç›®å‰ Rust çš„å®¹é‡è°ƒæ•´ç­–ç•¥æ˜¯åŠ å€ï¼Œä¾‹å¦‚ 2 -&gt; 4 -&gt; 8 ..)ã€‚ è‹¥è¿™æ®µä»£ç ä¼šé¢‘ç¹å‘ç”Ÿï¼Œé‚£é¢‘ç¹çš„å†…å­˜åˆ†é…ä¼šå¤§å¹…å½±å“æˆ‘ä»¬ç³»ç»Ÿçš„æ€§èƒ½ï¼Œæœ€å¥½çš„åŠæ³•å°±æ˜¯æå‰åˆ†é…å¥½è¶³å¤Ÿçš„å®¹é‡ï¼Œå°½é‡å‡å°‘å†…å­˜åˆ†é…ã€‚ ğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829// ä¿®å¤é”™è¯¯fn main() &#123; let mut vec = Vec::with_capacity(10); assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), 10); // ç”±äºæå‰è®¾ç½®äº†è¶³å¤Ÿçš„å®¹é‡ï¼Œè¿™é‡Œçš„å¾ªç¯ä¸ä¼šé€ æˆä»»ä½•å†…å­˜åˆ†é…... for i in 0..10 &#123; vec.push(i); &#125; assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), __); // ...ä½†æ˜¯ä¸‹é¢çš„ä»£ç ä¼šé€ æˆæ–°çš„å†…å­˜åˆ†é… vec.push(11); assert_eq!(vec.len(), 11); assert!(vec.capacity() &gt;= 11); // å¡«å†™ä¸€ä¸ªåˆé€‚çš„å€¼ï¼Œåœ¨ `for` å¾ªç¯è¿è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œä¸ä¼šé€ æˆä»»ä½•å†…å­˜åˆ†é… let mut vec = Vec::with_capacity(__); for i in 0..100 &#123; vec.push(i); &#125; assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), __); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031// ä¿®å¤é”™è¯¯ fn main() &#123; let mut vec = Vec::with_capacity(10); assert_eq!(vec.len(), 0); assert_eq!(vec.capacity(), 10); // ç”±äºæå‰è®¾ç½®äº†è¶³å¤Ÿçš„å®¹é‡ï¼Œè¿™é‡Œçš„å¾ªç¯ä¸ä¼šé€ æˆä»»ä½•å†…å­˜åˆ†é…... for i in 0..10 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 10); assert_eq!(vec.capacity(), 10); // ...ä½†æ˜¯ä¸‹é¢çš„ä»£ç ä¼šé€ æˆæ–°çš„å†…å­˜åˆ†é… vec.push(11); assert_eq!(vec.len(), 11); assert!(vec.capacity() &gt;= 11); // å¡«å†™ä¸€ä¸ªåˆé€‚çš„å€¼ï¼Œåœ¨ `for` å¾ªç¯è¿è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œä¸ä¼šé€ æˆä»»ä½•å†…å­˜åˆ†é… let mut vec = Vec::with_capacity(100); for i in 0..100 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 100); assert_eq!(vec.capacity(), 100); println!(&quot;Success!&quot;) &#125; Answer 1234567891011121314151617181920212223242526272829303132// FIX the errors fn main() &#123; let mut vec = Vec::with_capacity(10); // The vector contains no items, even though it has capacity for more assert_eq!(vec.len(), 0); assert_eq!(vec.capacity(), 10); // These are all done without reallocating... for i in 0..10 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 10); assert_eq!(vec.capacity(), 10); // ...but this may make the vector reallocate vec.push(11); assert_eq!(vec.len(), 11); assert!(vec.capacity() &gt;= 11); // fill in an appropriate value to make the `for` done without reallocating let mut vec = Vec::with_capacity(100); for i in 0..100 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 100); assert_eq!(vec.capacity(), 100); println!(&quot;Success!&quot;) &#125; åœ¨Vecä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ Vec ä¸­çš„å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç ä¼šå‘ç”Ÿé”™è¯¯: 123fn main() &#123; let v = vec![1, 2.0, 3];&#125; ä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æšä¸¾æˆ–ç‰¹å¾å¯¹è±¡æ¥å­˜å‚¨ä¸åŒçš„ç±»å‹. ğŸŒŸğŸŒŸ 123456789101112131415#[derive(Debug)]enum IpAddr &#123; V4(String), V6(String),&#125;fn main() &#123; // å¡«ç©º let v : Vec&lt;IpAddr&gt;= __; // æšä¸¾çš„æ¯”è¾ƒéœ€è¦æ´¾ç”Ÿ PartialEq ç‰¹å¾ assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string())); assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string())); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415#[derive(Debug,PartialEq)]enum IpAddr &#123; V4(String), V6(String),&#125;fn main() &#123; // å¡«ç©º let v : Vec&lt;IpAddr&gt;= vec![IpAddr::V4(&quot;127.0.0.1&quot;.to_string()),IpAddr::V6(&quot;::1&quot;.to_string())]; // æšä¸¾çš„æ¯”è¾ƒéœ€è¦æ´¾ç”Ÿ PartialEq ç‰¹å¾ assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string())); assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string())); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819#[derive(Debug, PartialEq)]enum IpAddr &#123; V4(String), V6(String),&#125;fn main() &#123; // FILL in the blank let v: Vec&lt;IpAddr&gt; = vec![ IpAddr::V4(&quot;127.0.0.1&quot;.to_string()), IpAddr::V6(&quot;::1&quot;.to_string()) ]; // Comparing two enums need to derive the PartialEq trait assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string())); assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string())); println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728trait IpAddr &#123; fn display(&amp;self);&#125;struct V4(String);impl IpAddr for V4 &#123; fn display(&amp;self) &#123; println!(&quot;ipv4: &#123;:?&#125;&quot;,self.0) &#125;&#125;struct V6(String);impl IpAddr for V6 &#123; fn display(&amp;self) &#123; println!(&quot;ipv6: &#123;:?&#125;&quot;,self.0) &#125;&#125;fn main() &#123; // å¡«ç©º let v: __= vec![ Box::new(V4(&quot;127.0.0.1&quot;.to_string())), Box::new(V6(&quot;::1&quot;.to_string())), ]; for ip in v &#123; ip.display(); &#125;&#125; My Answer 12345678910111213141516171819202122232425262728trait IpAddr &#123; fn display(&amp;self);&#125;struct V4(String);impl IpAddr for V4 &#123; fn display(&amp;self) &#123; println!(&quot;ipv4: &#123;:?&#125;&quot;,self.0) &#125;&#125;struct V6(String);impl IpAddr for V6 &#123; fn display(&amp;self) &#123; println!(&quot;ipv6: &#123;:?&#125;&quot;,self.0) &#125;&#125;fn main() &#123; // å¡«ç©º let v:Vec&lt;Box&lt;dyn IpAddr&gt;&gt;= vec![ Box::new(V4(&quot;127.0.0.1&quot;.to_string())), Box::new(V6(&quot;::1&quot;.to_string())), ]; for ip in v &#123; ip.display(); &#125;&#125; Answer 123456789101112131415161718192021222324252627trait IpAddr &#123; fn display(&amp;self);&#125;struct V4(String);impl IpAddr for V4 &#123; fn display(&amp;self) &#123; println!(&quot;ipv4: &#123;:?&#125;&quot;,self.0) &#125;&#125;struct V6(String);impl IpAddr for V6 &#123; fn display(&amp;self) &#123; println!(&quot;ipv6: &#123;:?&#125;&quot;,self.0) &#125;&#125;fn main() &#123; let v: Vec&lt;Box&lt;dyn IpAddr&gt;&gt; = vec![ Box::new(V4(&quot;127.0.0.1&quot;.to_string())), Box::new(V6(&quot;::1&quot;.to_string())), ]; for ip in v &#123; ip.display(); &#125;&#125; HashMapHashMap é»˜è®¤ä½¿ç”¨ SipHash 1-3 å“ˆå¸Œç®—æ³•ï¼Œè¯¥ç®—æ³•å¯¹äºæŠµæŠ— HashDos æ”»å‡»éå¸¸æœ‰æ•ˆã€‚åœ¨æ€§èƒ½æ–¹é¢ï¼Œå¦‚æœä½ çš„ key æ˜¯ä¸­å‹å¤§å°çš„ï¼Œé‚£è¯¥ç®—æ³•éå¸¸ä¸é”™ï¼Œä½†æ˜¯å¦‚æœæ˜¯å°å‹çš„ key( ä¾‹å¦‚æ•´æ•° )äº¦æˆ–æ˜¯å¤§å‹çš„ key ( ä¾‹å¦‚å­—ç¬¦ä¸² )ï¼Œé‚£ä½ éœ€è¦é‡‡ç”¨ç¤¾åŒºæä¾›çš„å…¶å®ƒç®—æ³•æ¥æé«˜æ€§èƒ½ã€‚ å“ˆå¸Œè¡¨çš„ç®—æ³•æ˜¯åŸºäº Google çš„ SwissTableï¼Œä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ° C++ çš„å®ç°ï¼ŒåŒæ—¶åœ¨ CppCon talk ä¸Šä¹Ÿæœ‰å…³äºç®—æ³•å¦‚ä½•å·¥ä½œçš„æ¼”è®²ã€‚ åŸºæœ¬æ“ä½œ ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯use std::collections::HashMap;fn main() &#123; let mut scores = HashMap::new(); scores.insert(&quot;Sunface&quot;, 98); scores.insert(&quot;Daniel&quot;, 95); scores.insert(&quot;Ashley&quot;, 69.0); scores.insert(&quot;Katie&quot;, &quot;58&quot;); // get è¿”å›ä¸€ä¸ª Option&lt;&amp;V&gt; æšä¸¾å€¼ let score = scores.get(&quot;Sunface&quot;); assert_eq!(score, Some(98)); if scores.contains_key(&quot;Daniel&quot;) &#123; // ç´¢å¼•è¿”å›ä¸€ä¸ªå€¼ V let score = scores[&quot;Daniel&quot;]; assert_eq!(score, __); scores.remove(&quot;Daniel&quot;); &#125; assert_eq!(scores.len(), __); for (name, score) in scores &#123; println!(&quot;The score of &#123;&#125; is &#123;&#125;&quot;, name, score) &#125;&#125; My Answer 12345678910111213141516171819202122232425262728// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯use std::collections::HashMap;fn main() &#123; let mut scores = HashMap::new(); scores.insert(&quot;Sunface&quot;, 98); scores.insert(&quot;Daniel&quot;, 95); scores.insert(&quot;Ashley&quot;, 69); scores.insert(&quot;Katie&quot;, 58); // get è¿”å›ä¸€ä¸ª Option&lt;&amp;V&gt; æšä¸¾å€¼ let score = scores.get(&quot;Sunface&quot;); assert_eq!(score, Some(98).as_ref()); if scores.contains_key(&quot;Daniel&quot;) &#123; // ç´¢å¼•è¿”å›ä¸€ä¸ªå€¼ V let score = scores[&quot;Daniel&quot;]; assert_eq!(score, 95); scores.remove(&quot;Daniel&quot;); &#125; assert_eq!(scores.len(), 3); for (name, score) in scores &#123; println!(&quot;The score of &#123;&#125; is &#123;&#125;&quot;, name, score) &#125;&#125; Answer 1234567891011121314151617181920212223242526// FILL in the blanks and FIX the errosuse std::collections::HashMap;fn main() &#123; let mut scores = HashMap::new(); scores.insert(&quot;Sunface&quot;, 98); scores.insert(&quot;Daniel&quot;, 95); scores.insert(&quot;Ashley&quot;, 69); scores.insert(&quot;Katie&quot;, 58); // get returns a Option&lt;&amp;V&gt; let score = scores.get(&quot;Sunface&quot;); assert_eq!(score, Some(&amp;98)); if scores.contains_key(&quot;Daniel&quot;) &#123; // indexing return a value V let score = scores[&quot;Daniel&quot;]; assert_eq!(score, 95); scores.remove(&quot;Daniel&quot;); &#125; assert_eq!(scores.len(), 3); for (name, score) in scores &#123; println!(&quot;The score of &#123;&#125; is &#123;&#125;&quot;, name, score) &#125;&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617181920212223use std::collections::HashMap;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; // ä½¿ç”¨ä¸¤ç§æ–¹æ³•å®ç° team_map2 // æç¤º:å…¶ä¸­ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ `collect` æ–¹æ³• let teams_map2... assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617181920212223use std::collections::HashMap;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; // ä½¿ç”¨ä¸¤ç§æ–¹æ³•å®ç° team_map2 // æç¤º:å…¶ä¸­ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ `collect` æ–¹æ³• let teams_map2:HashMap&lt;&amp;str, i32&gt; = teams.into_iter().collect(); assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819use std::collections::HashMap;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; let teams_map2: HashMap&lt;_,_&gt; = teams.into_iter().collect(); assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; 123456789101112131415161718use std::&#123;collections::HashMap&#125;;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; let teams_map2 = HashMap::from(teams); assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829// å¡«ç©ºuse std::collections::HashMap;fn main() &#123; // ç¼–è¯‘å™¨å¯ä»¥æ ¹æ®åç»­çš„ä½¿ç”¨æƒ…å†µå¸®æˆ‘è‡ªåŠ¨æ¨æ–­å‡º HashMap çš„ç±»å‹ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥æ˜¾å¼åœ°æ ‡æ³¨ç±»å‹ï¼šHashMap&lt;&amp;str, u8&gt; let mut player_stats = HashMap::new(); // æŸ¥è¯¢æŒ‡å®šçš„ key, è‹¥ä¸å­˜åœ¨æ—¶ï¼Œåˆ™æ’å…¥æ–°çš„ kv å€¼ player_stats.entry(&quot;health&quot;).or_insert(100); assert_eq!(player_stats[&quot;health&quot;], __); // é€šè¿‡å‡½æ•°æ¥è¿”å›æ–°çš„å€¼ player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff); assert_eq!(player_stats[&quot;health&quot;], __); let health = player_stats.entry(&quot;health&quot;).or_insert(50); assert_eq!(health, __); *health -= 50; assert_eq!(*health, __); println!(&quot;Success!&quot;)&#125;fn random_stat_buff() -&gt; u8 &#123; // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨éšæœºï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªå›ºå®šçš„å€¼ 42&#125; My Answer 1234567891011121314151617181920212223242526272829// å¡«ç©ºuse std::collections::HashMap;fn main() &#123; // ç¼–è¯‘å™¨å¯ä»¥æ ¹æ®åç»­çš„ä½¿ç”¨æƒ…å†µå¸®æˆ‘è‡ªåŠ¨æ¨æ–­å‡º HashMap çš„ç±»å‹ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥æ˜¾å¼åœ°æ ‡æ³¨ç±»å‹ï¼šHashMap&lt;&amp;str, u8&gt; let mut player_stats = HashMap::new(); // æŸ¥è¯¢æŒ‡å®šçš„ key, è‹¥ä¸å­˜åœ¨æ—¶ï¼Œåˆ™æ’å…¥æ–°çš„ kv å€¼ player_stats.entry(&quot;health&quot;).or_insert(100); assert_eq!(player_stats[&quot;health&quot;], 100); // é€šè¿‡å‡½æ•°æ¥è¿”å›æ–°çš„å€¼ player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff); assert_eq!(player_stats[&quot;health&quot;], 100); let health = player_stats.entry(&quot;health&quot;).or_insert(50); assert_eq!(health, &amp;100); *health -= 50; assert_eq!(*health, 50); println!(&quot;Success!&quot;)&#125;fn random_stat_buff() -&gt; u8 &#123; // ä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨éšæœºï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªå›ºå®šçš„å€¼ 42&#125; Answer 123456789101112131415161718192021222324252627282930313233// FILL in the blanksuse std::collections::HashMap;fn main() &#123; // type inference lets us omit an explicit type signature (which // would be `HashMap&lt;&amp;str, u8&gt;` in this example). let mut player_stats = HashMap::new(); // insert a key only if it doesn&#x27;t already exist player_stats.entry(&quot;health&quot;).or_insert(100); assert_eq!(player_stats[&quot;health&quot;], 100); // insert a key using a function that provides a new value only if it // doesn&#x27;t already exist player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff); assert_eq!(player_stats[&quot;health&quot;], 100); // Ensures a value is in the entry by inserting the default if empty, and returns // a mutable reference to the value in the entry. let health = player_stats.entry(&quot;health&quot;).or_insert(50); assert_eq!(health, &amp;100); *health -= 50; assert_eq!(*health, 50); println!(&quot;Success!&quot;)&#125;fn random_stat_buff() -&gt; u8 &#123; // could actually return some random value here - let&#x27;s just return // some fixed value for now 42&#125; HashMap Keyçš„é™åˆ¶ä»»ä½•å®ç°äº† Eq å’Œ Hash ç‰¹å¾çš„ç±»å‹éƒ½å¯ä»¥ç”¨äº HashMap çš„ keyï¼ŒåŒ…æ‹¬: bool (è™½ç„¶å¾ˆå°‘ç”¨åˆ°ï¼Œå› ä¸ºå®ƒåªèƒ½è¡¨è¾¾ä¸¤ç§ key) int, uint ä»¥åŠå®ƒä»¬çš„å˜ä½“ï¼Œä¾‹å¦‚ u8ã€i32 ç­‰ String å’Œ &amp;str (æç¤º: HashMap çš„ key æ˜¯ String ç±»å‹æ—¶ï¼Œä½ å…¶å®å¯ä»¥ä½¿ç”¨ &amp;str é…åˆ get æ–¹æ³•è¿›è¡ŒæŸ¥è¯¢ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œf32 å’Œ f64 å¹¶æ²¡æœ‰å®ç° Hashï¼ŒåŸå› æ˜¯ æµ®ç‚¹æ•°ç²¾åº¦ çš„é—®é¢˜ä¼šå¯¼è‡´å®ƒä»¬æ— æ³•è¿›è¡Œç›¸ç­‰æ¯”è¾ƒã€‚ å¦‚æœä¸€ä¸ªé›†åˆç±»å‹çš„æ‰€æœ‰å­—æ®µéƒ½å®ç°äº† Eq å’Œ Hash,é‚£è¯¥é›†åˆç±»å‹ä¼šè‡ªåŠ¨å®ç° Eq å’Œ Hashã€‚ä¾‹å¦‚ Vect&lt;T&gt; è¦å®ç° Hashï¼Œé‚£ä¹ˆé¦–å…ˆéœ€è¦ T å®ç° Hashã€‚ ğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930313233// ä¿®å¤é”™è¯¯// æç¤º: `derive` æ˜¯å®ç°ä¸€äº›å¸¸ç”¨ç‰¹å¾çš„å¥½åŠæ³•use std::collections::HashMap;struct Viking &#123; name: String, country: String,&#125;impl Viking &#123; fn new(name: &amp;str, country: &amp;str) -&gt; Viking &#123; Viking &#123; name: name.to_string(), country: country.to_string(), &#125; &#125;&#125;fn main() &#123; // ä½¿ç”¨ HashMap æ¥å­˜å‚¨ viking çš„ç”Ÿå‘½å€¼ let vikings = HashMap::from([ (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25), (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24), (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12), ]); // ä½¿ç”¨ derive çš„æ–¹å¼æ¥æ‰“å° viking çš„å½“å‰çŠ¶æ€ for (viking, health) in &amp;vikings &#123; println!(&quot;&#123;:?&#125; has &#123;&#125; hp&quot;, viking, health); &#125;&#125; My Answer 123456789101112131415161718192021222324252627282930313233// ä¿®å¤é”™è¯¯// æç¤º: `derive` æ˜¯å®ç°ä¸€äº›å¸¸ç”¨ç‰¹å¾çš„å¥½åŠæ³•use std::collections::HashMap;#[derive(PartialEq, Eq, Debug, Hash)]struct Viking &#123; name: String, country: String,&#125;impl Viking &#123; fn new(name: &amp;str, country: &amp;str) -&gt; Viking &#123; Viking &#123; name: name.to_string(), country: country.to_string(), &#125; &#125;&#125;fn main() &#123; // ä½¿ç”¨ HashMap æ¥å­˜å‚¨ viking çš„ç”Ÿå‘½å€¼ let vikings = HashMap::from([ (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25), (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24), (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12), ]); // ä½¿ç”¨ derive çš„æ–¹å¼æ¥æ‰“å° viking çš„å½“å‰çŠ¶æ€ for (viking, health) in &amp;vikings &#123; println!(&quot;&#123;:?&#125; has &#123;&#125; hp&quot;, viking, health); &#125;&#125; Answer 12345678910111213141516171819202122232425262728293031use std::collections::HashMap;#[derive(Hash, Eq, PartialEq, Debug)]struct Viking &#123; name: String, country: String,&#125;impl Viking &#123; /// Creates a new Viking. fn new(name: &amp;str, country: &amp;str) -&gt; Viking &#123; Viking &#123; name: name.to_string(), country: country.to_string(), &#125; &#125;&#125;fn main() &#123; // Use a HashMap to store the vikings&#x27; health points. let vikings = HashMap::from([ (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25), (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24), (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12), ]); // Use derived implementation to print the status of the vikings. for (viking, health) in &amp;vikings &#123; println!(&quot;&#123;:?&#125; has &#123;&#125; hp&quot;, viking, health); &#125;&#125; å®¹é‡å…³äºå®¹é‡ï¼Œæˆ‘ä»¬åœ¨ä¹‹å‰çš„ Vector ä¸­æœ‰è¯¦ç»†çš„ä»‹ç»ï¼Œè€Œ HashMap ä¹Ÿå¯ä»¥è°ƒæ•´å®¹é‡: ä½ å¯ä»¥é€šè¿‡ HashMap::with_capacity(uint) ä½¿ç”¨æŒ‡å®šçš„å®¹é‡æ¥åˆå§‹åŒ–ï¼Œæˆ–è€…ä½¿ç”¨ HashMap::new() ï¼Œåè€…ä¼šæä¾›ä¸€ä¸ªé»˜è®¤çš„åˆå§‹åŒ–å®¹é‡ã€‚ ç¤ºä¾‹ 1234567891011121314151617181920use std::collections::HashMap;fn main() &#123; let mut map: HashMap&lt;i32, i32&gt; = HashMap::with_capacity(100); map.insert(1, 2); map.insert(3, 4); // äº‹å®ä¸Šï¼Œè™½ç„¶æˆ‘ä»¬ä½¿ç”¨äº† 100 å®¹é‡æ¥åˆå§‹åŒ–ï¼Œä½†æ˜¯ map çš„å®¹é‡å¾ˆå¯èƒ½ä¼šæ¯” 100 æ›´å¤š assert!(map.capacity() &gt;= 100); // å¯¹å®¹é‡è¿›è¡Œæ”¶ç¼©ï¼Œä½ æä¾›çš„å€¼ä»…ä»…æ˜¯ä¸€ä¸ªå…è®¸çš„æœ€å°å€¼ï¼Œå®é™…ä¸Šï¼ŒRust ä¼šæ ¹æ®å½“å‰å­˜å‚¨çš„æ•°æ®é‡è¿›è¡Œè‡ªåŠ¨è®¾ç½®ï¼Œå½“ç„¶ï¼Œè¿™ä¸ªå€¼ä¼šå°½é‡é è¿‘ä½ æä¾›çš„å€¼ï¼ŒåŒæ—¶è¿˜å¯èƒ½ä¼šé¢„ç•™ä¸€äº›è°ƒæ•´ç©ºé—´ map.shrink_to(50); assert!(map.capacity() &gt;= 50); // è®© Rust è‡ªè¡Œè°ƒæ•´åˆ°ä¸€ä¸ªåˆé€‚çš„å€¼ï¼Œå‰©ä½™ç­–ç•¥åŒä¸Š map.shrink_to_fit(); assert!(map.capacity() &gt;= 2); println!(&quot;Success!&quot;)&#125; æ‰€æœ‰æƒå¯¹äºå®ç°äº† Copy ç‰¹å¾çš„ç±»å‹ï¼Œä¾‹å¦‚ i32ï¼Œé‚£ç±»å‹çš„å€¼ä¼šè¢«æ‹·è´åˆ° HashMap ä¸­ã€‚è€Œå¯¹äºæœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œä¾‹å¦‚ Stringï¼Œå®ƒä»¬çš„å€¼çš„æ‰€æœ‰æƒå°†è¢«è½¬ç§»åˆ° HashMap ä¸­ã€‚ ğŸŒŸğŸŒŸ 12345678910111213141516171819// ä¿®å¤é”™è¯¯ï¼Œå°½å¯èƒ½å°‘çš„å»ä¿®æ”¹ä»£ç // ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œï¼use std::collections::HashMap;fn main() &#123; let v1 = 10; let mut m1 = HashMap::new(); m1.insert(v1, v1); println!(&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;, v1); let v2 = &quot;hello&quot;.to_string(); let mut m2 = HashMap::new(); // æ‰€æœ‰æƒåœ¨è¿™é‡Œå‘ç”Ÿäº†è½¬ç§» m2.insert(v2, v1); assert_eq!(v2, &quot;hello&quot;); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819// ä¿®å¤é”™è¯¯ï¼Œå°½å¯èƒ½å°‘çš„å»ä¿®æ”¹ä»£ç // ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œï¼use std::collections::HashMap;fn main() &#123; let v1 = 10; let mut m1 = HashMap::new(); m1.insert(v1, v1); println!(&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;, v1); let v2 = &quot;hello&quot;.to_string(); let mut m2 = HashMap::new(); // æ‰€æœ‰æƒåœ¨è¿™é‡Œå‘ç”Ÿäº†è½¬ç§» m2.insert(v2.clone(), v1); assert_eq!(v2, &quot;hello&quot;); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415use std::collections::HashMap;fn main() &#123; let v1 = 10; let mut m1 = HashMap::new(); m1.insert(v1, v1); println!(&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;, v1); // &amp;str implements Copy trait let v2 = &quot;hello&quot;; let mut m2 = HashMap::new(); m2.insert(v2, v1); assert_eq!(v2, &quot;hello&quot;);&#125; ä¸‰æ–¹åº“Hashåº“åœ¨å¼€å¤´ï¼Œæˆ‘ä»¬æåˆ°è¿‡å¦‚æœç°æœ‰çš„ SipHash 1-3 çš„æ€§èƒ½æ— æ³•æ»¡è¶³ä½ çš„éœ€æ±‚ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ç¤¾åŒºæä¾›çš„æ›¿ä»£ç®—æ³•ã€‚ ä¾‹å¦‚å…¶ä¸­ä¸€ä¸ªç¤¾åŒºåº“çš„ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š 1234567891011121314#![allow(unused)]fn main() &#123;use std::hash::BuildHasherDefault;use std::collections::HashMap;// å¼•å…¥ç¬¬ä¸‰æ–¹çš„å“ˆå¸Œå‡½æ•°use twox_hash::XxHash64;let mut hash: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = Default::default();hash.insert(42, &quot;the answer&quot;);assert_eq!(hash.get(&amp;42), Some(&amp;&quot;the answer&quot;));&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 8 æ³›å‹å’Œç‰¹å¾","slug":"Rustå­¦ä¹ -ç»ƒä¹ 8-æ³›å‹å’Œç‰¹å¾","date":"2023-09-09T09:05:27.000Z","updated":"2023-09-12T11:52:22.261Z","comments":true,"path":"2023/09/09/Rustå­¦ä¹ -ç»ƒä¹ 8-æ³›å‹å’Œç‰¹å¾/","link":"","permalink":"http://example.com/2023/09/09/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A08-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E5%BE%81/","excerpt":"æ³›å‹å‡½æ•° ğŸŒŸğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425// å¡«ç©ºstruct A; // å…·ä½“çš„ç±»å‹ `A`.struct S(A); // å…·ä½“çš„ç±»å‹ `S`.struct SGen&lt;T&gt;(T); // æ³›å‹ `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // ä½¿ç”¨éæ³›å‹å‡½æ•° reg_fn(__); // å…·ä½“çš„ç±»å‹ gen_spec_t(__); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `A`. gen_spec_i32(__); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•°`i32`. // æ˜¾å¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char` generic::&lt;char&gt;(__); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char`. generic(__);&#125; My Answer 12345678910111213141516171819202122232425// å¡«ç©ºstruct A; // å…·ä½“çš„ç±»å‹ `A`.struct S(A); // å…·ä½“çš„ç±»å‹ `S`.struct SGen&lt;T&gt;(T); // æ³›å‹ `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // ä½¿ç”¨éæ³›å‹å‡½æ•° reg_fn(S(A)); // å…·ä½“çš„ç±»å‹ gen_spec_t(SGen(A)); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `A`. gen_spec_i32(SGen(1)); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•°`i32`. // æ˜¾å¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char` generic::&lt;char&gt;(SGen(&#x27;1&#x27;)); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char`. generic(SGen(&#x27;1&#x27;));&#125; Answer 123456789101112131415161718192021222324struct A; // Concrete type `A`.struct S(A); // Concrete type `S`.struct SGen&lt;T&gt;(T); // Generic type `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // Using the non-generic functions reg_fn(S(A)); // Concrete type. gen_spec_t(SGen(A)); // Implicitly specified type parameter `A`. gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`. // Explicitly specified type parameter `char` to `generic()`. generic::&lt;char&gt;(SGen(&#x27;a&#x27;)); // Implicitly specified type parameter `char` to `generic()`. generic(SGen(&#x27;c&#x27;));&#125; ğŸŒŸğŸŒŸ 12345678// å®ç°ä¸‹é¢çš„æ³›å‹å‡½æ•° sumfn sumfn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; My Answer 12345678910// å®ç°ä¸‹é¢çš„æ³›å‹å‡½æ•° sumfn sum&lt;T :std::ops::Add&lt;Output = T&gt;&gt;(val1: T,val2: T) -&gt; T&#123; val1+val2&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; Answer 123456789fn sum&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125;","text":"æ³›å‹å‡½æ•° ğŸŒŸğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425// å¡«ç©ºstruct A; // å…·ä½“çš„ç±»å‹ `A`.struct S(A); // å…·ä½“çš„ç±»å‹ `S`.struct SGen&lt;T&gt;(T); // æ³›å‹ `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // ä½¿ç”¨éæ³›å‹å‡½æ•° reg_fn(__); // å…·ä½“çš„ç±»å‹ gen_spec_t(__); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `A`. gen_spec_i32(__); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•°`i32`. // æ˜¾å¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char` generic::&lt;char&gt;(__); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char`. generic(__);&#125; My Answer 12345678910111213141516171819202122232425// å¡«ç©ºstruct A; // å…·ä½“çš„ç±»å‹ `A`.struct S(A); // å…·ä½“çš„ç±»å‹ `S`.struct SGen&lt;T&gt;(T); // æ³›å‹ `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // ä½¿ç”¨éæ³›å‹å‡½æ•° reg_fn(S(A)); // å…·ä½“çš„ç±»å‹ gen_spec_t(SGen(A)); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `A`. gen_spec_i32(SGen(1)); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•°`i32`. // æ˜¾å¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char` generic::&lt;char&gt;(SGen(&#x27;1&#x27;)); // éšå¼åœ°æŒ‡å®šç±»å‹å‚æ•° `char`. generic(SGen(&#x27;1&#x27;));&#125; Answer 123456789101112131415161718192021222324struct A; // Concrete type `A`.struct S(A); // Concrete type `S`.struct SGen&lt;T&gt;(T); // Generic type `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // Using the non-generic functions reg_fn(S(A)); // Concrete type. gen_spec_t(SGen(A)); // Implicitly specified type parameter `A`. gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`. // Explicitly specified type parameter `char` to `generic()`. generic::&lt;char&gt;(SGen(&#x27;a&#x27;)); // Implicitly specified type parameter `char` to `generic()`. generic(SGen(&#x27;c&#x27;));&#125; ğŸŒŸğŸŒŸ 12345678// å®ç°ä¸‹é¢çš„æ³›å‹å‡½æ•° sumfn sumfn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; My Answer 12345678910// å®ç°ä¸‹é¢çš„æ³›å‹å‡½æ•° sumfn sum&lt;T :std::ops::Add&lt;Output = T&gt;&gt;(val1: T,val2: T) -&gt; T&#123; val1+val2&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; Answer 123456789fn sum&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; ç»“æ„ä½“å’Œimpl ğŸŒŸ 123456// å®ç°ä¸€ä¸ªç»“æ„ä½“ Point è®©ä»£ç å·¥ä½œfn main() &#123;let integer = Point &#123; x: 5, y: 10 &#125;;let float = Point &#123; x: 1.0, y: 4.0 &#125;;&#125; My Answer 12345678910// å®ç°ä¸€ä¸ªç»“æ„ä½“ Point è®©ä»£ç å·¥ä½œ struct Point&lt;T&gt; &#123; x: T, y: T, &#125; fn main() &#123; let integer = Point &#123; x: 5, y: 10 &#125;; let float = Point &#123; x: 1.0, y: 4.0 &#125;; &#125; Answer 123456789struct Point&lt;T&gt; &#123; x: T, y: T,&#125;fn main() &#123; let integer = Point &#123; x: 5, y: 10 &#125;; let float = Point &#123; x: 1.0, y: 4.0 &#125;;&#125; ğŸŒŸğŸŒŸ 12345678910// ä¿®æ”¹ä»¥ä¸‹ç»“æ„ä½“è®©ä»£ç å·¥ä½œstruct Point&lt;T&gt; &#123; x: T, y: T,&#125;fn main() &#123; // ä¸è¦ä¿®æ”¹è¿™è¡Œä»£ç ï¼ let p = Point&#123;x: 5, y : &quot;hello&quot;.to_string()&#125;;&#125; My Answer 12345678910// ä¿®æ”¹ä»¥ä¸‹ç»“æ„ä½“è®©ä»£ç å·¥ä½œstruct Point&lt;M,N&gt; &#123; x: M, y: N,&#125;fn main() &#123; // ä¸è¦ä¿®æ”¹è¿™è¡Œä»£ç ï¼ let p = Point&#123;x: 5, y : &quot;hello&quot;.to_string()&#125;;&#125; Answer 12345678910// modify this struct to make the code workstruct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;fn main() &#123; // DON&#x27;T modify here let p = Point&#123;x: 5, y : &quot;hello&quot;.to_string()&#125;;&#125; ğŸŒŸğŸŒŸ 123456789101112131415// ä¸º Val å¢åŠ æ³›å‹å‚æ•°ï¼Œä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç struct Val &#123; val: f64,&#125;impl Val &#123; fn value(&amp;self) -&gt; &amp;f64 &#123; &amp;self.val &#125;&#125;fn main() &#123; let x = Val&#123; val: 3.0 &#125;; let y = Val&#123; val: &quot;hello&quot;.to_string()&#125;; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, x.value(), y.value()); &#125; My Answer 123456789101112131415161718// ä¸º Val å¢åŠ æ³›å‹å‚æ•°ï¼Œä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç struct Val&lt;T&gt; &#123; val: T,&#125;impl&lt;T&gt; Val&lt;T&gt; &#123; fn value(&amp;self) -&gt; &amp;T &#123; &amp;self.val &#125;&#125;fn main() &#123; let x = Val &#123; val: 3.0 &#125;; let y = Val &#123; val: &quot;hello&quot;.to_string(), &#125;; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, x.value(), y.value());&#125; Answer 1234567891011121314struct Val&lt;T&gt; &#123; val: T,&#125;impl&lt;T&gt; Val&lt;T&gt; &#123; fn value(&amp;self) -&gt; &amp;T &#123; &amp;self.val &#125;&#125;fn main() &#123; let x = Val&#123; val: 3.0 &#125;; let y = Val&#123; val: &quot;hello&quot;.to_string()&#125;; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, x.value(), y.value()); &#125; æ–¹æ³• ğŸŒŸğŸŒŸğŸŒŸ 12345678910111213141516171819struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; // å®ç° mixupï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç ï¼ fn mixup&#125;fn main() &#123; let p1 = Point &#123; x: 5, y: 10 &#125;; let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;ä¸­&#x27;&#125;; let p3 = p1.mixup(p2); assert_eq!(p3.x, 5); assert_eq!(p3.y, &#x27;ä¸­&#x27;);&#125; My Answer 123456789101112131415161718192021222324252627struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; // å®ç° mixupï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç ï¼ fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123; Point &#123; x: self.x, y: other.y, &#125; &#125;&#125;fn main() &#123; let p1 = Point &#123; x: 5, y: 10 &#125;; let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;ä¸­&#x27;, &#125;; let p3 = p1.mixup(p2); assert_eq!(p3.x, 5); assert_eq!(p3.y, &#x27;ä¸­&#x27;);&#125; Answer 1234567891011121314151617181920212223struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123; Point &#123; x: self.x, y: other.y, &#125; &#125;&#125;fn main() &#123; let p1 = Point &#123; x: 5, y: 10 &#125;; let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;ä¸­&#x27;&#125;; let p3 = p1.mixup(p2); assert_eq!(p3.x, 5); assert_eq!(p3.y, &#x27;ä¸­&#x27;);&#125; ğŸŒŸğŸŒŸ 12345678910111213141516// ä¿®å¤é”™è¯¯ï¼Œè®©ä»£ç å·¥ä½œstruct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl Point&lt;f32&gt; &#123; fn distance_from_origin(&amp;self) -&gt; f32 &#123; (self.x.powi(2) + self.y.powi(2)).sqrt() &#125;&#125;fn main() &#123; let p = Point&#123;x: 5, y: 10&#125;; println!(&quot;&#123;&#125;&quot;,p.distance_from_origin())&#125; My Answer 12345678910111213141516171819// ä¿®å¤é”™è¯¯ï¼Œè®©ä»£ç å·¥ä½œstruct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl Point&lt;f32&gt; &#123; fn distance_from_origin(&amp;self) -&gt; f32 &#123; (self.x.powi(2) + self.y.powi(2)).sqrt() &#125;&#125;fn main() &#123; let p = Point &#123; x: 5.0_f32, y: 10.0_f32, &#125;; println!(&quot;&#123;&#125;&quot;, p.distance_from_origin())&#125; Answer 123456789101112131415struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl Point&lt;f32&gt; &#123; fn distance_from_origin(&amp;self) -&gt; f32 &#123; (self.x.powi(2) + self.y.powi(2)).sqrt() &#125;&#125;fn main() &#123; let p = Point&#123;x: 5.0_f32, y: 10.0_f32&#125;; println!(&quot;&#123;&#125;&quot;,p.distance_from_origin())&#125; constæ³›å‹ç¤ºä¾‹ ä¸‹é¢çš„ä¾‹å­åŒæ—¶ä½¿ç”¨æ³›å‹å’Œ const æ³›å‹æ¥å®ç°ä¸€ä¸ªç»“æ„ä½“ï¼Œè¯¥ç»“æ„ä½“çš„å­—æ®µä¸­çš„æ•°ç»„é•¿åº¦æ˜¯å¯å˜çš„ 12345678struct ArrayPair&lt;T, const N: usize&gt; &#123; left: [T; N], right: [T; N],&#125;impl&lt;T: Debug, const N: usize&gt; Debug for ArrayPair&lt;T, N&gt; &#123; // ...&#125; ç›®å‰ï¼Œconst æ³›å‹å‚æ•°åªèƒ½ä½¿ç”¨ä»¥ä¸‹å½¢å¼çš„å®å‚: ä¸€ä¸ªå•ç‹¬çš„ const æ³›å‹å‚æ•° ä¸€ä¸ªå­—é¢é‡ (i.e. æ•´æ•°, å¸ƒå°”å€¼æˆ–å­—ç¬¦). ä¸€ä¸ªå…·ä½“çš„ const è¡¨è¾¾å¼( è¡¨è¾¾å¼ä¸­ä¸èƒ½åŒ…å«ä»»ä½•æ³›å‹å‚æ•°) 123456789101112131415fn foo&lt;const N: usize&gt;() &#123;&#125;fn bar&lt;T, const M: usize&gt;() &#123; foo::&lt;M&gt;(); // ok: ç¬¦åˆç¬¬ä¸€ç§ foo::&lt;2021&gt;(); // ok: ç¬¦åˆç¬¬äºŒç§ foo::&lt;&#123;20 * 100 + 20 * 10 + 1&#125;&gt;(); // ok: ç¬¦åˆç¬¬ä¸‰ç§ foo::&lt;&#123; M + 1 &#125;&gt;(); // error: è¿èƒŒç¬¬ä¸‰ç§ï¼Œconst è¡¨è¾¾å¼ä¸­ä¸èƒ½æœ‰æ³›å‹å‚æ•° M foo::&lt;&#123; std::mem::size_of::&lt;T&gt;() &#125;&gt;(); // error: æ³›å‹è¡¨è¾¾å¼åŒ…å«äº†æ³›å‹å‚æ•° T let _: [u8; M]; // ok: ç¬¦åˆç¬¬ä¸€ç§ let _: [u8; std::mem::size_of::&lt;T&gt;()]; // error: æ³›å‹è¡¨è¾¾å¼åŒ…å«äº†æ³›å‹å‚æ•° T&#125;fn main() &#123;&#125; const æ³›å‹è¿˜èƒ½å¸®æˆ‘ä»¬é¿å…ä¸€äº›è¿è¡Œæ—¶æ£€æŸ¥ï¼Œæå‡æ€§èƒ½ 1234567891011121314151617181920pub struct MinSlice&lt;T, const N: usize&gt; &#123; pub head: [T; N], pub tail: [T],&#125;fn main() &#123; let slice: &amp;[u8] = b&quot;Hello, world&quot;; let reference: Option&lt;&amp;u8&gt; = slice.get(6); // æˆ‘ä»¬çŸ¥é“ `.get` è¿”å›çš„æ˜¯ `Some(b&#x27; &#x27;)` // ä½†ç¼–è¯‘å™¨ä¸çŸ¥é“ assert!(reference.is_some()); let slice: &amp;[u8] = b&quot;Hello, world&quot;; // å½“ç¼–è¯‘æ„å»º MinSlice æ—¶ä¼šè¿›è¡Œé•¿åº¦æ£€æŸ¥ï¼Œä¹Ÿå°±æ˜¯åœ¨ç¼–è¯‘æœŸæˆ‘ä»¬å°±çŸ¥é“å®ƒçš„é•¿åº¦æ˜¯ 12 // åœ¨è¿è¡ŒæœŸï¼Œä¸€æ—¦ `unwrap` æˆåŠŸï¼Œåœ¨ `MinSlice` çš„ä½œç”¨åŸŸå†…ï¼Œå°±å†æ— éœ€ä»»ä½•æ£€æŸ¥ let minslice = MinSlice::&lt;u8, 12&gt;::from_slice(slice).unwrap(); let value: u8 = minslice.head[6]; assert_eq!(value, b&#x27; &#x27;)&#125; ç»ƒä¹  ğŸŒŸğŸŒŸ &lt;T, const N: usize&gt; æ˜¯ç»“æ„ä½“ç±»å‹çš„ä¸€éƒ¨åˆ†ï¼Œå’Œæ•°ç»„ç±»å‹ä¸€æ ·ï¼Œè¿™æ„å‘³ç€é•¿åº¦ä¸åŒä¼šå¯¼è‡´ç±»å‹ä¸åŒï¼š Array&lt;i32, 3&gt; å’Œ Array&lt;i32, 4&gt; æ˜¯ä¸åŒçš„ç±»å‹ 123456789101112131415161718// ä¿®å¤é”™è¯¯struct Array&lt;T, const N: usize&gt; &#123; data : [T; N]&#125;fn main() &#123; let arrays = [ Array&#123; data: [1, 2, 3], &#125;, Array &#123; data: [1.0, 2.0, 3.0], &#125;, Array &#123; data: [1, 2] &#125; ];&#125; My Answer 123456789101112131415161718// ä¿®å¤é”™è¯¯struct Array&lt;T, const N: usize&gt; &#123; data : [T; N]&#125;fn main() &#123; let arrays = [ Array&#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 3] &#125; ];&#125; Answer 1234567891011121314151617struct Array&lt;T, const N: usize&gt; &#123; data : [T; N]&#125;fn main() &#123; let arrays = [ Array&#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 4] &#125; ];&#125; ğŸŒŸğŸŒŸ 1234567891011// å¡«ç©ºfn print_array&lt;__&gt;(__) &#123; println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123; let arr = [1, 2, 3]; print_array(arr); let arr = [&quot;hello&quot;, &quot;world&quot;]; print_array(arr);&#125; My Answer 1234567891011// å¡«ç©ºfn print_array&lt;T: std::fmt::Debug&gt;(arr: &amp;[T]) &#123; println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123; let arr = [1, 2, 3]; print_array(&amp;arr); let arr = [&quot;hello&quot;, &quot;world&quot;]; print_array(&amp;arr);&#125; Answer 12345678910fn print_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: [T; N]) &#123; println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123; let arr = [1, 2, 3]; print_array(arr); let arr = [&quot;hello&quot;, &quot;world&quot;]; print_array(arr);&#125; ğŸŒŸğŸŒŸğŸŒŸ æœ‰æ—¶æˆ‘ä»¬å¸Œæœ›èƒ½é™åˆ¶ä¸€ä¸ªå˜é‡å ç”¨å†…å­˜çš„å¤§å°ï¼Œä¾‹å¦‚åœ¨åµŒå…¥å¼ç¯å¢ƒä¸­ï¼Œæ­¤æ—¶ const æ³›å‹å‚æ•°çš„ç¬¬ä¸‰ç§å½¢å¼ const è¡¨è¾¾å¼ å°±éå¸¸é€‚åˆ. 1234567891011121314151617181920212223 #![allow(incomplete_features)] #![feature(generic_const_exprs)] fn check_size&lt;T&gt;(val: T) where Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; 768 &#125;&gt;: IsTrue, &#123; //... &#125; // ä¿®å¤ main å‡½æ•°ä¸­çš„é”™è¯¯ fn main() &#123; check_size([0u8; 767]); check_size([0i32; 191]); check_size([&quot;helloä½ å¥½&quot;; __]); // size of &amp;str ? check_size([(); __].map(|_| &quot;helloä½ å¥½&quot;.to_string())); // size of String? check_size([&#x27;ä¸­&#x27;; __]); // size of char ? &#125;pub enum Assert&lt;const CHECK: bool&gt; &#123;&#125;pub trait IsTrue &#123;&#125;impl IsTrue for Assert&lt;true&gt; &#123;&#125; My Answer 1234567891011121314151617181920212223#![allow(incomplete_features)] #![feature(generic_const_exprs)] fn check_size&lt;T&gt;(val: T) where Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; 768 &#125;&gt;: IsTrue, &#123; //... &#125; // ä¿®å¤ main å‡½æ•°ä¸­çš„é”™è¯¯ fn main() &#123; check_size([0u8; 767]); check_size([0i32; 191]); check_size([&quot;helloä½ å¥½&quot;; 1]); // size of &amp;str ? check_size([(); 1].map(|_| &quot;helloä½ å¥½&quot;.to_string())); // size of String? check_size([&#x27;ä¸­&#x27;; 1]); // size of char ? &#125;pub enum Assert&lt;const CHECK: bool&gt; &#123;&#125;pub trait IsTrue &#123;&#125;impl IsTrue for Assert&lt;true&gt; &#123;&#125; Answer 1234567891011121314151617181920212223#![allow(incomplete_features)] #![feature(generic_const_exprs)] fn check_size&lt;T&gt;(val: T) where Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; 768 &#125;&gt;: IsTrue, &#123; //... &#125; // fix the errors in main fn main() &#123; check_size([0u8; 767]); check_size([0i32; 191]); check_size([&quot;helloä½ å¥½&quot;; 47]); // &amp;str is a string reference, containing a pointer and string length in it, so it takes two word long, in x86-64, 1 word = 8 bytes check_size([(); 31].map(|_| &quot;helloä½ å¥½&quot;.to_string())); // String is a smart pointer struct, it has three fields: pointer, length and capacity, each takes 8 bytes check_size([&#x27;ä¸­&#x27;; 191]); // A char takes 4 bytes in Rust &#125; pub enum Assert&lt;const CHECK: bool&gt; &#123;&#125; pub trait IsTrue &#123;&#125; impl IsTrue for Assert&lt;true&gt; &#123;&#125; ç‰¹å¾ç¤ºä¾‹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Sheep &#123; naked: bool, name: String &#125;impl Sheep &#123; fn is_naked(&amp;self) -&gt; bool &#123; self.naked &#125; fn shear(&amp;mut self) &#123; if self.is_naked() &#123; // `Sheep` ç»“æ„ä½“ä¸Šå®šä¹‰çš„æ–¹æ³•å¯ä»¥è°ƒç”¨ `Sheep` æ‰€å®ç°çš„ç‰¹å¾çš„æ–¹æ³• println!(&quot;&#123;&#125; is already naked...&quot;, self.name()); &#125; else &#123; println!(&quot;&#123;&#125; gets a haircut!&quot;, self.name); self.naked = true; &#125; &#125;&#125;trait Animal &#123; // å…³è”å‡½æ•°ç­¾åï¼›`Self` æŒ‡ä»£å®ç°è€…çš„ç±»å‹ // ä¾‹å¦‚æˆ‘ä»¬åœ¨ä¸º Pig ç±»å‹å®ç°ç‰¹å¾æ—¶ï¼Œé‚£ `new` å‡½æ•°å°±ä¼šè¿”å›ä¸€ä¸ª `Pig` ç±»å‹çš„å®ä¾‹ï¼Œè¿™é‡Œçš„ `Self` æŒ‡ä»£çš„å°±æ˜¯ `Pig` ç±»å‹ fn new(name: String) -&gt; Self; // æ–¹æ³•ç­¾å fn name(&amp;self) -&gt; String; fn noise(&amp;self) -&gt; String; // æ–¹æ³•è¿˜èƒ½æä¾›é»˜è®¤çš„å®šä¹‰å®ç° fn talk(&amp;self) &#123; println!(&quot;&#123;&#125; says &#123;&#125;&quot;, self.name(), self.noise()); &#125;&#125;impl Animal for Sheep &#123; // `Self` è¢«æ›¿æ¢æˆå…·ä½“çš„å®ç°è€…ç±»å‹ï¼š `Sheep` fn new(name: String) -&gt; Sheep &#123; Sheep &#123; name: name, naked: false &#125; &#125; fn name(&amp;self) -&gt; String &#123; self.name.clone() &#125; fn noise(&amp;self) -&gt; String &#123; if self.is_naked() &#123; &quot;baaaaah?&quot;.to_string() &#125; else &#123; &quot;baaaaah!&quot;.to_string() &#125; &#125; // é»˜è®¤çš„ç‰¹å¾æ–¹æ³•å¯ä»¥è¢«é‡å†™ fn talk(&amp;self) &#123; println!(&quot;&#123;&#125; pauses briefly... &#123;&#125;&quot;, self.name, self.noise()); &#125;&#125;fn main() &#123; // è¿™é‡Œçš„ç±»å‹æ³¨é‡Šæ—¶å¿…é¡»çš„ let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;.to_string()); // TODO ^ å°è¯•å»é™¤ç±»å‹æ³¨é‡Šï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆ dolly.talk(); dolly.shear(); dolly.talk();&#125; ç»ƒä¹  ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728// å®Œæˆä¸¤ä¸ª `impl` è¯­å¥å—// ä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç trait Hello &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String;&#125;struct Student &#123;&#125;impl Hello for Student &#123;&#125;struct Teacher &#123;&#125;impl Hello for Teacher &#123;&#125;fn main() &#123; let s = Student &#123;&#125;; assert_eq!(s.say_hi(), &quot;hi&quot;); assert_eq!(s.say_something(), &quot;I&#x27;m a good student&quot;); let t = Teacher &#123;&#125;; assert_eq!(t.say_hi(), &quot;Hi, I&#x27;m your new teacher&quot;); assert_eq!(t.say_something(), &quot;I&#x27;m not a bad teacher&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142// å®Œæˆä¸¤ä¸ª `impl` è¯­å¥å—// ä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç trait Hello &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String;&#125;struct Student &#123;&#125;impl Hello for Student &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m a good student&quot;) &#125;&#125;struct Teacher &#123;&#125;impl Hello for Teacher &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;Hi, I&#x27;m your new teacher&quot;) &#125; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m not a bad teacher&quot;) &#125;&#125;fn main() &#123; let s = Student &#123;&#125;; assert_eq!(s.say_hi(), &quot;hi&quot;); assert_eq!(s.say_something(), &quot;I&#x27;m a good student&quot;); let t = Teacher &#123;&#125;; assert_eq!(t.say_hi(), &quot;Hi, I&#x27;m your new teacher&quot;); assert_eq!(t.say_something(), &quot;I&#x27;m not a bad teacher&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031323334trait Hello &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String;&#125;struct Student &#123;&#125;impl Hello for Student &#123; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m a good student&quot;) &#125;&#125;struct Teacher &#123;&#125;impl Hello for Teacher &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;Hi, I&#x27;m your new teacher&quot;) &#125; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m not a bad teacher&quot;) &#125;&#125;fn main() &#123; let s = Student &#123;&#125;; assert_eq!(s.say_hi(), &quot;hi&quot;); assert_eq!(s.say_something(), &quot;I&#x27;m a good student&quot;); let t = Teacher &#123;&#125;; assert_eq!(t.say_hi(), &quot;Hi, I&#x27;m your new teacher&quot;); assert_eq!(t.say_something(), &quot;I&#x27;m not a bad teacher&quot;);&#125; Deriveæ´¾ç”Ÿæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ #[derive] å±æ€§æ¥æ´¾ç”Ÿä¸€äº›ç‰¹å¾ï¼Œå¯¹äºè¿™äº›ç‰¹å¾ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è¿›è¡Œé»˜è®¤å®ç°ï¼Œå¯¹äºæ—¥å¸¸ä»£ç å¼€å‘è€Œè¨€ï¼Œè¿™æ˜¯éå¸¸æ–¹ä¾¿çš„ï¼Œä¾‹å¦‚å¤§å®¶ç»å¸¸ç”¨åˆ°çš„ Debug ç‰¹å¾ï¼Œå°±æ˜¯ç›´æ¥é€šè¿‡æ´¾ç”Ÿæ¥è·å–é»˜è®¤å®ç°ï¼Œè€Œæ— éœ€æˆ‘ä»¬æ‰‹åŠ¨å»å®Œæˆè¿™ä¸ªå·¥ä½œã€‚ æƒ³è¦æŸ¥çœ‹æ›´å¤šä¿¡æ¯ï¼Œå¯ä»¥è®¿é—®è¿™é‡Œã€‚ ğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930313233343536373839404142// `Centimeters`, ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“ï¼Œå¯ä»¥è¢«æ¯”è¾ƒå¤§å°#[derive(PartialEq, PartialOrd)]struct Centimeters(f64);// `Inches`, ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“å¯ä»¥è¢«æ‰“å°#[derive(Debug)]struct Inches(i32);impl Inches &#123; fn to_centimeters(&amp;self) -&gt; Centimeters &#123; let &amp;Inches(inches) = self; Centimeters(inches as f64 * 2.54) &#125;&#125;// æ·»åŠ ä¸€äº›å±æ€§è®©ä»£ç å·¥ä½œ// ä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç ï¼struct Seconds(i32);fn main() &#123; let _one_second = Seconds(1); println!(&quot;One second looks like: &#123;:?&#125;&quot;, _one_second); let _this_is_true = _one_second == _one_second; let _this_is_true = _one_second &gt; _one_second; let foot = Inches(12); println!(&quot;One foot equals &#123;:?&#125;&quot;, foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() &lt; meter &#123; &quot;smaller&quot; &#125; else &#123; &quot;bigger&quot; &#125;; println!(&quot;One foot is &#123;&#125; than one meter.&quot;, cmp);&#125; My Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344// `Centimeters`, ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“ï¼Œå¯ä»¥è¢«æ¯”è¾ƒå¤§å°#[derive(PartialEq, PartialOrd)]struct Centimeters(f64);// `Inches`, ä¸€ä¸ªå…ƒç»„ç»“æ„ä½“å¯ä»¥è¢«æ‰“å°#[derive(Debug)]struct Inches(i32);impl Inches &#123; fn to_centimeters(&amp;self) -&gt; Centimeters &#123; let &amp;Inches(inches) = self; Centimeters(inches as f64 * 2.54) &#125;&#125;// æ·»åŠ ä¸€äº›å±æ€§è®©ä»£ç å·¥ä½œ// ä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç ï¼#[derive(Debug)]#[derive(PartialEq, PartialOrd)]struct Seconds(i32);fn main() &#123; let _one_second = Seconds(1); println!(&quot;One second looks like: &#123;:?&#125;&quot;, _one_second); let _this_is_true = _one_second == _one_second; let _this_is_true = _one_second &gt; _one_second; let foot = Inches(12); println!(&quot;One foot equals &#123;:?&#125;&quot;, foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() &lt; meter &#123; &quot;smaller&quot; &#125; else &#123; &quot;bigger&quot; &#125;; println!(&quot;One foot is &#123;&#125; than one meter.&quot;, cmp);&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243// `Centimeters`, a tuple struct that can be compared#[derive(PartialEq, PartialOrd)]struct Centimeters(f64);// `Inches`, a tuple struct that can be printed#[derive(Debug)]struct Inches(i32);impl Inches &#123; fn to_centimeters(&amp;self) -&gt; Centimeters &#123; let &amp;Inches(inches) = self; Centimeters(inches as f64 * 2.54) &#125;&#125;// Add some attributes to make the code work// DON&#x27;T modify other codes#[derive(Debug,PartialEq,PartialOrd)]struct Seconds(i32);fn main() &#123; let _one_second = Seconds(1); println!(&quot;One second looks like: &#123;:?&#125;&quot;, _one_second); let _this_is_true = (_one_second == _one_second); let _this_is_false = (_one_second &gt; _one_second); let foot = Inches(12); println!(&quot;One foot equals &#123;:?&#125;&quot;, foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() &lt; meter &#123; &quot;smaller&quot; &#125; else &#123; &quot;bigger&quot; &#125;; println!(&quot;One foot is &#123;&#125; than one meter.&quot;, cmp);&#125; è¿ç®—ç¬¦åœ¨ Rust ä¸­ï¼Œè®¸å¤šè¿ç®—ç¬¦éƒ½å¯ä»¥è¢«é‡è½½ï¼Œäº‹å®ä¸Šï¼Œè¿ç®—ç¬¦ä»…ä»…æ˜¯ç‰¹å¾æ–¹æ³•è°ƒç”¨çš„è¯­æ³•ç³–ã€‚ä¾‹å¦‚ a + b ä¸­çš„ + æ˜¯ std::ops::Add ç‰¹å¾çš„ add æ–¹æ³•è°ƒç”¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°è¯¥ç‰¹å¾æ¥æ”¯æŒè¯¥ç±»å‹çš„åŠ æ³•è¿ç®—ã€‚ ğŸŒŸğŸŒŸ 12345678910111213use std::ops;// å®ç° fn multiply æ–¹æ³•// å¦‚ä¸Šæ‰€è¿°ï¼Œ`+` éœ€è¦ `T` ç±»å‹å®ç° `std::ops::Add` ç‰¹å¾// é‚£ä¹ˆ, `*` è¿ç®—ç¬¦éœ€è¦å®ç°ä»€ä¹ˆç‰¹å¾å‘¢? ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ç­”æ¡ˆ: https://doc.rust-lang.org/core/ops/fn multiplyfn main() &#123; assert_eq!(6, multiply(2u8, 3u8)); assert_eq!(5.0, multiply(1.0, 5.0)); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415use std::ops;// å®ç° fn multiply æ–¹æ³•// å¦‚ä¸Šæ‰€è¿°ï¼Œ`+` éœ€è¦ `T` ç±»å‹å®ç° `std::ops::Add` ç‰¹å¾// é‚£ä¹ˆ, `*` è¿ç®—ç¬¦éœ€è¦å®ç°ä»€ä¹ˆç‰¹å¾å‘¢? ä½ å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ç­”æ¡ˆ: https://doc.rust-lang.org/core/ops/fn multiply&lt;T: ops::Mul&lt;Output = T&gt;&gt;(a:T,b:T) -&gt;T&#123; a*b&#125;fn main() &#123; assert_eq!(6, multiply(2u8, 3u8)); assert_eq!(5.0, multiply(1.0, 5.0)); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213use std::ops;// implement fn multiply to make the code work// As mentioned above, `+` needs `T` to implement `std::ops::Add` Trait// so, what about `*` ? You can find the answer here: https://doc.rust-lang.org/core/ops/fn multiply&lt;T: ops::Mul&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x * y&#125;fn main() &#123; assert_eq!(6, multiply(2u8, 3u8)); assert_eq!(5.0, multiply(1.0, 5.0));&#125; ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829303132333435// ä¿®å¤é”™è¯¯ï¼Œä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç !use std::ops;struct Foo;struct Bar;struct FooBar;struct BarFoo;// ä¸‹é¢çš„ä»£ç å®ç°äº†è‡ªå®šä¹‰ç±»å‹çš„ç›¸åŠ ï¼š Foo + Bar = FooBarimpl ops::Add&lt;Bar&gt; for Foo &#123; type Output = FooBar; fn add(self, _rhs: Bar) -&gt; FooBar &#123; FooBar &#125;&#125;impl ops::Sub&lt;Foo&gt; for Bar &#123; type Output = BarFoo; fn sub(self, _rhs: Foo) -&gt; BarFoo &#123; BarFoo &#125;&#125;fn main() &#123; // ä¸è¦ä¿®æ”¹ä¸‹é¢ä»£ç  // ä½ éœ€è¦ä¸º FooBar æ´¾ç”Ÿä¸€äº›ç‰¹å¾æ¥è®©ä»£ç å·¥ä½œ assert_eq!(Foo + Bar, FooBar); assert_eq!(Foo - Bar, BarFoo); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617181920212223242526272829303132333435363738// ä¿®å¤é”™è¯¯ï¼Œä¸è¦ä¿®æ”¹ `main` ä¸­çš„ä»£ç !use std::ops;struct Foo;struct Bar;#[derive(Debug,PartialEq)]struct FooBar;#[derive(Debug,PartialEq)]struct BarFoo;// ä¸‹é¢çš„ä»£ç å®ç°äº†è‡ªå®šä¹‰ç±»å‹çš„ç›¸åŠ ï¼š Foo + Bar = FooBarimpl ops::Add&lt;Bar&gt; for Foo &#123;type Output = FooBar;fn add(self, _rhs: Bar) -&gt; FooBar &#123; FooBar&#125;&#125;impl ops::Sub&lt;Bar&gt; for Foo &#123;type Output = BarFoo;fn sub(self, _rhs: Bar) -&gt; BarFoo &#123; BarFoo&#125;fn main() &#123;// ä¸è¦ä¿®æ”¹ä¸‹é¢ä»£ç // ä½ éœ€è¦ä¸º FooBar æ´¾ç”Ÿä¸€äº›ç‰¹å¾æ¥è®©ä»£ç å·¥ä½œassert_eq!(Foo + Bar, FooBar);assert_eq!(Foo - Bar, BarFoo);println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021222324252627282930313233343536use std::ops;struct Foo;struct Bar;#[derive(PartialEq, Debug)]struct FooBar;#[derive(PartialEq, Debug)]struct BarFoo;// The `std::ops::Add` trait is used to specify the functionality of `+`.// Here, we make `Add&lt;Bar&gt;` - the trait for addition with a RHS of type `Bar`.// The following block implements the operation: Foo + Bar = FooBarimpl ops::Add&lt;Bar&gt; for Foo &#123; type Output = FooBar; fn add(self, _rhs: Bar) -&gt; FooBar &#123; FooBar &#125;&#125;impl ops::Sub&lt;Bar&gt; for Foo &#123; type Output = BarFoo; fn sub(self, _rhs: Bar) -&gt; BarFoo &#123; BarFoo &#125;&#125;fn main() &#123; // DON&#x27;T modify the below code // you need to derive some trait for FooBar to make it comparable assert_eq!(Foo + Bar, FooBar); assert_eq!(Foo - Bar, BarFoo);&#125; ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°å‚æ•°é™¤äº†ä½¿ç”¨å…·ä½“ç±»å‹æ¥ä½œä¸ºå‡½æ•°å‚æ•°ï¼Œæˆ‘ä»¬è¿˜èƒ½é€šè¿‡ impl Trait çš„æ–¹å¼æ¥æŒ‡å®šå®ç°äº†è¯¥ç‰¹å¾çš„å‚æ•°ï¼šè¯¥å‚æ•°èƒ½æ¥å—çš„ç±»å‹å¿…é¡»è¦å®ç°æŒ‡å®šçš„ç‰¹å¾ã€‚ ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// å®ç° `fn summary` // ä¿®å¤é”™è¯¯ä¸”ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œtrait Summary &#123; fn summarize(&amp;self) -&gt; String;&#125;#[derive(Debug)]struct Post &#123; title: String, author: String, content: String,&#125;impl Summary for Post &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;The author of post &#123;&#125; is &#123;&#125;&quot;, self.title, self.author) &#125;&#125;#[derive(Debug)]struct Weibo &#123; username: String, content: String,&#125;impl Summary for Weibo &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125; published a weibo &#123;&#125;&quot;, self.username, self.content) &#125;&#125;fn main() &#123; let post = Post &#123; title: &quot;Popular Rust&quot;.to_string(), author: &quot;Sunface&quot;.to_string(), content: &quot;Rust is awesome!&quot;.to_string(), &#125;; let weibo = Weibo &#123; username: &quot;sunface&quot;.to_string(), content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(), &#125;; summary(post); summary(weibo); println!(&quot;&#123;:?&#125;&quot;, post); println!(&quot;&#123;:?&#125;&quot;, weibo);&#125;// åœ¨ä¸‹é¢å®ç° `fn summary` å‡½æ•° My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// å®ç° `fn summary` // ä¿®å¤é”™è¯¯ä¸”ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œ trait Summary &#123; fn summarize(&amp;self) -&gt; String; &#125; #[derive(Debug)] struct Post &#123; title: String, author: String, content: String, &#125; impl Summary for Post &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;The author of post &#123;&#125; is &#123;&#125;&quot;, self.title, self.author) &#125; &#125; #[derive(Debug)] struct Weibo &#123; username: String, content: String, &#125; impl Summary for Weibo &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125; published a weibo &#123;&#125;&quot;, self.username, self.content) &#125; &#125; fn main() &#123; let post = Post &#123; title: &quot;Popular Rust&quot;.to_string(), author: &quot;Sunface&quot;.to_string(), content: &quot;Rust is awesome!&quot;.to_string(), &#125;; let weibo = Weibo &#123; username: &quot;sunface&quot;.to_string(), content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(), &#125;; summary(&amp;post); summary(&amp;weibo); println!(&quot;&#123;:?&#125;&quot;, post); println!(&quot;&#123;:?&#125;&quot;, weibo); &#125; // åœ¨ä¸‹é¢å®ç° `fn summary` å‡½æ•° fn summary&lt;T: Summary&gt;(item: &amp;T) &#123; item.summarize(); &#125; Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344// implement `fn summary` to make the code work // fix the errors without removing any code line trait Summary &#123; fn summarize(&amp;self) -&gt; String; &#125; #[derive(Debug)] struct Post &#123; title: String, author: String, content: String, &#125; impl Summary for Post &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;The author of post &#123;&#125; is &#123;&#125;&quot;, self.title, self.author) &#125; &#125; #[derive(Debug)] struct Weibo &#123; username: String, content: String, &#125; impl Summary for Weibo &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125; published a weibo &#123;&#125;&quot;, self.username, self.content) &#125; &#125; fn main() &#123; let post = Post &#123; title: &quot;Popular Rust&quot;.to_string(), author: &quot;Sunface&quot;.to_string(), content: &quot;Rust is awesome!&quot;.to_string(), &#125;; let weibo = Weibo &#123; username: &quot;sunface&quot;.to_string(), content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(), &#125;; summary(&amp;post); summary(&amp;weibo); println!(&quot;&#123;:?&#125;&quot;, post); println!(&quot;&#123;:?&#125;&quot;, weibo); &#125; fn summary(t: &amp;impl Summary) &#123; let _ = t.summarize(); &#125; ä½¿ç”¨ç‰¹å¾ä½œä¸ºå‡½æ•°è¿”å›å€¼æˆ‘ä»¬è¿˜å¯ä»¥åœ¨å‡½æ•°çš„è¿”å›å€¼ä¸­ä½¿ç”¨ impl Trait è¯­æ³•ã€‚ç„¶ååªæœ‰åœ¨è¿”å›å€¼æ˜¯åŒä¸€ä¸ªç±»å‹æ—¶ï¼Œæ‰èƒ½è¿™ä¹ˆä½¿ç”¨ï¼Œå¦‚æœè¿”å›å€¼æ˜¯ä¸åŒçš„ç±»å‹ï¼Œä½ å¯èƒ½æ›´éœ€è¦ç‰¹å¾å¯¹è±¡ã€‚ ğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829struct Sheep &#123;&#125;struct Cow &#123;&#125; trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125; impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125; impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125; // è¿”å›ä¸€ä¸ªç±»å‹ï¼Œè¯¥ç±»å‹å®ç°äº† Animal ç‰¹å¾ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸èƒ½åœ¨ç¼–è¯‘æœŸè·çŸ¥å…·ä½“è¿”å›äº†å“ªä¸ªç±»å‹// ä¿®å¤è¿™é‡Œçš„é”™è¯¯ï¼Œä½ å¯ä»¥ä½¿ç”¨è™šå‡çš„éšæœºï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ç‰¹å¾å¯¹è±¡fn random_animal(random_number: f64) -&gt; impl Animal &#123; if random_number &lt; 0.5 &#123; Sheep &#123;&#125; &#125; else &#123; Cow &#123;&#125; &#125;&#125; fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; My Answer 12345678910111213141516171819202122232425262728293031323334struct Sheep &#123;&#125;struct Cow &#123;&#125;trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125;impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125;impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125;// è¿”å›ä¸€ä¸ªç±»å‹ï¼Œè¯¥ç±»å‹å®ç°äº† Animal ç‰¹å¾ï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸èƒ½åœ¨ç¼–è¯‘æœŸè·çŸ¥å…·ä½“è¿”å›äº†å“ªä¸ªç±»å‹// ä¿®å¤è¿™é‡Œçš„é”™è¯¯ï¼Œä½ å¯ä»¥ä½¿ç”¨è™šå‡çš„éšæœºï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ç‰¹å¾å¯¹è±¡fn random_animal(random_number: f64) -&gt; impl Animal &#123; if random_number &lt; 0.5 &#123; Sheep &#123;&#125; &#125; else &#123; Sheep&#123;&#125; &#125;&#125;fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; Answer 12345678910111213141516171819202122232425262728293031323334struct Sheep &#123;&#125;struct Cow &#123;&#125;trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125;impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125;impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125;// Returns some struct that implements Animal, but we don&#x27;t know which one at compile time.// FIX the erros here, you can make a fake random, or you can use trait objectfn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; &#123; if random_number &lt; 0.5 &#123; Box::new(Sheep &#123;&#125;) &#125; else &#123; Box::new(Cow&#123;&#125;) &#125;&#125;fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; 12345678910111213141516171819202122232425262728293031323334struct Sheep &#123;&#125;struct Cow &#123;&#125;trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125;impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125;impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125;// Returns some struct that implements Animal, but we don&#x27;t know which one at compile time.// FIX the erros here, you can make a fake random, or you can use trait objectfn random_animal(random_number: f64) -&gt; impl Animal &#123; if random_number &lt; 0.5 &#123; Sheep &#123;&#125; &#125; else &#123; Sheep &#123;&#125; &#125;&#125;fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; ç‰¹å¾çº¦æŸimpl Trait è¯­æ³•éå¸¸ç›´è§‚ç®€æ´ï¼Œä½†å®ƒå®é™…ä¸Šæ˜¯ç‰¹å¾çº¦æŸçš„è¯­æ³•ç³–ã€‚ å½“ä½¿ç”¨æ³›å‹å‚æ•°æ—¶ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦ä¸ºè¯¥å‚æ•°æŒ‡å®šç‰¹å®šçš„è¡Œä¸ºï¼Œè¿™ç§æŒ‡å®šæ–¹å¼å°±æ˜¯é€šè¿‡ç‰¹å¾çº¦æŸæ¥å®ç°çš„ã€‚ ğŸŒŸğŸŒŸ 12345678fn main() &#123; assert_eq!(sum(1, 2), 3);&#125;// é€šè¿‡ä¸¤ç§æ–¹æ³•ä½¿ç”¨ç‰¹å¾çº¦æŸæ¥å®ç° `fn sum`fn sum&lt;T&gt;(x: T, y: T) -&gt; T &#123; x + y&#125; My Answer 12345678fn main() &#123; assert_eq!(sum(1, 2), 3);&#125;// é€šè¿‡ä¸¤ç§æ–¹æ³•ä½¿ç”¨ç‰¹å¾çº¦æŸæ¥å®ç° `fn sum`fn sum&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125; 12345678910fn main() &#123; assert_eq!(sum(1, 2), 3);&#125;// é€šè¿‡ä¸¤ç§æ–¹æ³•ä½¿ç”¨ç‰¹å¾çº¦æŸæ¥å®ç° `fn sum`fn sum&lt;T&gt;(x: T, y: T) -&gt; T where T: std::ops::Add&lt;Output = T&gt;&#123; x + y&#125; Answer 12345678fn main() &#123; assert_eq!(sum(1, 2), 3); assert_eq!(sum(1.0, 2.0), 3.0);&#125;fn sum&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125; 1234567891011fn main() &#123; assert_eq!(sum(1, 2), 3); assert_eq!(sum(1.0, 2.0), 3.0);&#125;fn sum&lt;T&gt;(x: T, y: T) -&gt; Twhere T: std::ops::Add&lt;Output = T&gt;,&#123; x + y&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829303132333435// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(&quot;The largest member is x = &#123;:?&#125;&quot;, self.x); &#125; else &#123; println!(&quot;The largest member is y = &#123;:?&#125;&quot;, self.y); &#125; &#125;&#125;struct Unit(i32);fn main() &#123; let pair = Pair&#123; x: Unit(1), y: Unit(3) &#125;; pair.cmp_display();&#125; My Answer 1234567891011121314151617181920212223242526272829303132333435// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(&quot;The largest member is x = &#123;:?&#125;&quot;, self.x); &#125; else &#123; println!(&quot;The largest member is y = &#123;:?&#125;&quot;, self.y); &#125; &#125;&#125;#[derive(Debug,PartialEq, PartialOrd)]struct Unit(i32);fn main() &#123; let pair = Pair&#123; x: Unit(1), y: Unit(3) &#125;; pair.cmp_display();&#125; Answer 1234567891011121314151617181920212223242526272829303132333435struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(&quot;The largest member is x = &#123;:?&#125;&quot;, self.x); &#125; else &#123; println!(&quot;The largest member is y = &#123;:?&#125;&quot;, self.y); &#125; &#125;&#125;#[derive(Debug, PartialEq, PartialOrd)]struct Unit(i32);fn main() &#123; let pair = Pair&#123; x: Unit(1), y: Unit(3) &#125;; pair.cmp_display();&#125; ğŸŒŸğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// å¡«ç©ºfn example1() &#123; // `T: Trait` æ˜¯æœ€å¸¸ä½¿ç”¨çš„æ–¹å¼ // `T: Fn(u32) -&gt; u32` è¯´æ˜ `T` åªèƒ½æ¥æ”¶é—­åŒ…ç±»å‹çš„å‚æ•° struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(10), __); assert_eq!(cacher.value(15), __);&#125;fn example2() &#123;// è¿˜å¯ä»¥ä½¿ç”¨ `where` æ¥çº¦æŸ Tstruct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32,&#123; calculation: T, value: Option&lt;u32&gt;,&#125;impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32,&#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125;&#125;let mut cacher = Cacher::new(|x| x+1);assert_eq!(cacher.value(20), __);assert_eq!(cacher.value(25), __);&#125;fn main() &#123;example1();example2();println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// å¡«ç©º fn example1() &#123; // `T: Trait` æ˜¯æœ€å¸¸ä½¿ç”¨çš„æ–¹å¼ // `T: Fn(u32) -&gt; u32` è¯´æ˜ `T` åªèƒ½æ¥æ”¶é—­åŒ…ç±»å‹çš„å‚æ•° struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(10), 11); assert_eq!(cacher.value(15), 11); &#125;fn example2() &#123; // è¿˜å¯ä»¥ä½¿ç”¨ `where` æ¥çº¦æŸ T struct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(20), 21); assert_eq!(cacher.value(25), 21); &#125;fn main() &#123; example1(); example2(); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273fn example1() &#123; // `T: Trait` is the commonly used way // `T: Fn(u32) -&gt; u32` specifies that we can only pass a closure to `T` struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(10), 11); assert_eq!(cacher.value(15), 11);&#125;fn example2() &#123; // We can also use `where` to constrain `T` struct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(20), 21); assert_eq!(cacher.value(25), 21);&#125;fn main() &#123;example1();example2();&#125; ç‰¹å¾å¯¹è±¡åœ¨ç‰¹å¾ç»ƒä¹ ä¸­ æˆ‘ä»¬å·²ç»çŸ¥é“å½“å‡½æ•°è¿”å›å¤šä¸ªç±»å‹æ—¶ï¼Œimpl Trait æ˜¯æ— æ³•ä½¿ç”¨çš„ã€‚ å¯¹äºæ•°ç»„è€Œè¨€ï¼Œå…¶ä¸­ä¸€ä¸ªé™åˆ¶å°±æ˜¯æ— æ³•å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ï¼Œä½†æ˜¯é€šè¿‡ä¹‹å‰çš„å­¦ä¹ ï¼Œå¤§å®¶åº”è¯¥çŸ¥é“æšä¸¾å¯ä»¥åœ¨éƒ¨åˆ†åœºæ™¯è§£å†³è¿™ç§é—®é¢˜ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•å±€é™æ€§è¾ƒå¤§ã€‚æ­¤æ—¶å°±éœ€è¦æˆ‘ä»¬çš„ä¸»è§’ç™»åœºäº†ã€‚ ä½¿ç”¨dynè¿”å›ç‰¹å¾Rust ç¼–è¯‘å™¨éœ€è¦çŸ¥é“ä¸€ä¸ªå‡½æ•°çš„è¿”å›ç±»å‹å ç”¨å¤šå°‘å†…å­˜ç©ºé—´ã€‚ç”±äºç‰¹å¾çš„ä¸åŒå®ç°ç±»å‹å¯èƒ½ä¼šå ç”¨ä¸åŒçš„å†…å­˜ï¼Œå› æ­¤é€šè¿‡ impl Trait è¿”å›å¤šä¸ªç±»å‹æ˜¯ä¸è¢«å…è®¸çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥è¿”å›ä¸€ä¸ª dyn ç‰¹å¾å¯¹è±¡æ¥è§£å†³é—®é¢˜ã€‚ ğŸŒŸğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051trait Bird &#123; fn quack(&amp;self) -&gt; String;&#125;struct Duck;impl Duck &#123; fn swim(&amp;self) &#123; println!(&quot;Look, the duck is swimming&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) -&gt; String&#123; &quot;duck duck&quot;.to_string() &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) -&gt; String&#123; &quot;swan swan&quot;.to_string() &#125;&#125;fn main() &#123; // å¡«ç©º let duck = __; duck.swim(); let bird = hatch_a_bird(2); // å˜æˆé¸Ÿå„¿åï¼Œå®ƒå¿˜è®°äº†å¦‚ä½•æ¸¸ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ // bird.swim(); // ä½†å®ƒä¾ç„¶å¯ä»¥å«å”¤ assert_eq!(bird.quack(), &quot;duck duck&quot;); let bird = hatch_a_bird(1); // è¿™åªé¸Ÿå„¿å¿˜äº†å¦‚ä½•é£ç¿”ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ // bird.fly(); // ä½†å®ƒä¹Ÿå¯ä»¥å«å”¤ assert_eq!(bird.quack(), &quot;swan swan&quot;); println!(&quot;Success!&quot;)&#125; // å®ç°ä»¥ä¸‹å‡½æ•°fn hatch_a_bird... My Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556trait Bird &#123; fn quack(&amp;self) -&gt; String;&#125;struct Duck;impl Duck &#123; fn swim(&amp;self) &#123; println!(&quot;Look, the duck is swimming&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) -&gt; String&#123; &quot;duck duck&quot;.to_string() &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) -&gt; String&#123; &quot;swan swan&quot;.to_string() &#125;&#125;fn main() &#123; // å¡«ç©º let duck = Duck; duck.swim(); let bird = hatch_a_bird(2); // å˜æˆé¸Ÿå„¿åï¼Œå®ƒå¿˜è®°äº†å¦‚ä½•æ¸¸ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ // bird.swim(); // ä½†å®ƒä¾ç„¶å¯ä»¥å«å”¤ assert_eq!(bird.quack(), &quot;duck duck&quot;); let bird = hatch_a_bird(1); // è¿™åªé¸Ÿå„¿å¿˜äº†å¦‚ä½•é£ç¿”ï¼Œå› æ­¤ä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ // bird.fly(); // ä½†å®ƒä¹Ÿå¯ä»¥å«å”¤ assert_eq!(bird.quack(), &quot;swan swan&quot;); println!(&quot;Success!&quot;)&#125; // å®ç°ä»¥ä¸‹å‡½æ•°fn hatch_a_bird(s:u8) -&gt;Box&lt;dyn Bird&gt; &#123; match s &#123; 1 =&gt; Box::new(Swan&#123;&#125;), _ =&gt; Box::new(Duck&#123;&#125;) &#125;&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455trait Bird &#123; fn quack(&amp;self) -&gt; String;&#125;struct Duck;impl Duck &#123; fn swim(&amp;self) &#123; println!(&quot;Look, the duck is swimming&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) -&gt; String&#123; &quot;duck duck&quot;.to_string() &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) -&gt; String&#123; &quot;swan swan&quot;.to_string() &#125;&#125;fn main() &#123; let duck = Duck; duck.swim(); let bird = hatch_a_bird(2); // this bird has forgotten how to swim, so below line will cause an error // bird.swim(); // but it can quack assert_eq!(bird.quack(), &quot;duck duck&quot;); let bird = hatch_a_bird(1); // this bird has forgotten how to fly, so below line will cause an error // bird.fly(); // but it can quack too assert_eq!(bird.quack(), &quot;swan swan&quot;); println!(&quot;Success!&quot;)&#125; fn hatch_a_bird(species: u8) -&gt;Box&lt;dyn Bird&gt; &#123; if species == 1 &#123; Box::new(Swan&#123;&#125;) &#125; else &#123; Box::new(Duck&#123;&#125;) &#125;&#125; åœ¨æ•°ç»„ä¸­ä½¿ç”¨ç‰¹å¾å¯¹è±¡ ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728293031323334353637383940trait Bird &#123; fn quack(&amp;self);&#125;struct Duck;impl Duck &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck is flying&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;duck duck&quot;); &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;swan swan&quot;); &#125;&#125;fn main() &#123; // å¡«ç©º let birds __; for bird in birds &#123; bird.quack(); // å½“ duck å’Œ swan å˜æˆ bird åï¼Œå®ƒä»¬éƒ½å¿˜äº†å¦‚ä½•ç¿±ç¿”äºå¤©é™…ï¼Œåªè®°å¾—è¯¥æ€ä¹ˆå«å”¤äº†ã€‚ã€‚ // å› æ­¤ï¼Œä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ // bird.fly(); &#125;&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637383940trait Bird &#123; fn quack(&amp;self);&#125;struct Duck;impl Duck &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck is flying&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;duck duck&quot;); &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;swan swan&quot;); &#125;&#125;fn main() &#123; // å¡«ç©º let birds: [Box&lt;dyn Bird&gt;; 2] = [Box::new(Duck &#123;&#125;), Box::new(Swan &#123;&#125;)]; for bird in birds &#123; bird.quack(); // å½“ duck å’Œ swan å˜æˆ bird åï¼Œå®ƒä»¬éƒ½å¿˜äº†å¦‚ä½•ç¿±ç¿”äºå¤©é™…ï¼Œåªè®°å¾—è¯¥æ€ä¹ˆå«å”¤äº†ã€‚ã€‚ // å› æ­¤ï¼Œä»¥ä¸‹ä»£ç ä¼šæŠ¥é”™ // bird.fly(); &#125;&#125; Answer 123456789101112131415161718192021222324252627282930313233343536373839trait Bird &#123; fn quack(&amp;self);&#125;struct Duck;impl Duck &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck is flying&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;duck duck&quot;); &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;swan swan&quot;); &#125;&#125;fn main() &#123; let birds: [Box&lt;dyn Bird&gt;; 2] = [Box::new(Duck &#123;&#125;), Box::new(Swan &#123;&#125;)]; for bird in birds &#123; bird.quack(); // when duck and swan turn into Bird, they all forget how to fly, and only remember how to quack // so, the below code will cause an error // bird.fly(); &#125;&#125; &amp;dyn and Box ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728293031323334353637// å¡«ç©ºtrait Draw &#123; fn draw(&amp;self) -&gt; String;&#125;impl Draw for u8 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Draw for f64 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;f64: &#123;&#125;&quot;, *self) &#125;&#125;fn main() &#123; let x = 1.1f64; let y = 8u8; // draw x draw_with_box(__); // draw y draw_with_ref(&amp;y); println!(&quot;Success!&quot;)&#125;fn draw_with_box(x: Box&lt;dyn Draw&gt;) &#123; x.draw();&#125;fn draw_with_ref(x: __) &#123; x.draw();&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637// å¡«ç©ºtrait Draw &#123; fn draw(&amp;self) -&gt; String;&#125;impl Draw for u8 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Draw for f64 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;f64: &#123;&#125;&quot;, *self) &#125;&#125;fn main() &#123; let x = 1.1f64; let y = 8u8; // draw x draw_with_box(Box::new(x)); // draw y draw_with_ref(&amp;y); println!(&quot;Success!&quot;)&#125;fn draw_with_box(x: Box&lt;dyn Draw&gt;) &#123; x.draw();&#125;fn draw_with_ref(x: &amp;dyn Draw) &#123; x.draw();&#125; Answer 12345678910111213141516171819202122232425262728293031323334trait Draw &#123; fn draw(&amp;self) -&gt; String;&#125;impl Draw for u8 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Draw for f64 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;f64: &#123;&#125;&quot;, *self) &#125;&#125;fn main() &#123; let x = 1.1f64; let y = 8u8; // draw x draw_with_box(Box::new(x)); // draw y draw_with_ref(&amp;y);&#125;fn draw_with_box(x: Box&lt;dyn Draw&gt;) &#123; x.draw();&#125;fn draw_with_ref(x: &amp;dyn Draw) &#123; x.draw();&#125; é™æ€åˆ†å‘å’ŒåŠ¨æ€åˆ†å‘Static and Dynamic dispatchå…³äºè¿™å—å†…å®¹çš„è§£æä»‹ç»ï¼Œè¯·å‚è§ Rustè¯­è¨€åœ£ç»ã€‚ ğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627trait Foo &#123; fn method(&amp;self) -&gt; String;&#125;impl Foo for u8 &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Foo for String &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;string: &#123;&#125;&quot;, *self) &#125;&#125;// é€šè¿‡æ³›å‹å®ç°ä»¥ä¸‹å‡½æ•°fn static_dispatch...// é€šè¿‡ç‰¹å¾å¯¹è±¡å®ç°ä»¥ä¸‹å‡½æ•°fn dynamic_dispatch...fn main() &#123; let x = 5u8; let y = &quot;Hello&quot;.to_string(); static_dispatch(x); dynamic_dispatch(&amp;y); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627282930313233trait Foo &#123; fn method(&amp;self) -&gt; String;&#125;impl Foo for u8 &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Foo for String &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;string: &#123;&#125;&quot;, *self) &#125;&#125;// é€šè¿‡æ³›å‹å®ç°ä»¥ä¸‹å‡½æ•°fn static_dispatch&lt;T:Foo&gt;(x:T)&#123; x.method();&#125;// é€šè¿‡ç‰¹å¾å¯¹è±¡å®ç°ä»¥ä¸‹å‡½æ•°fn dynamic_dispatch(x:&amp;dyn Foo)&#123; x.method();&#125;fn main() &#123; let x = 5u8; let y = &quot;Hello&quot;.to_string(); static_dispatch(x); dynamic_dispatch(&amp;y); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031trait Foo &#123; fn method(&amp;self) -&gt; String;&#125;impl Foo for u8 &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Foo for String &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;string: &#123;&#125;&quot;, *self) &#125;&#125;// implement below with genericsfn static_dispatch&lt;T: Foo&gt;(x: T) &#123; x.method();&#125;// implement below with trait objectsfn dynamic_dispatch(x: &amp;dyn Foo) &#123; x.method();&#125;fn main() &#123; let x = 5u8; let y = &quot;Hello&quot;.to_string(); static_dispatch(x); dynamic_dispatch(&amp;y); println!(&quot;Success!&quot;)&#125; å¯¹è±¡å®‰å…¨ä¸€ä¸ªç‰¹å¾èƒ½å˜æˆç‰¹å¾å¯¹è±¡ï¼Œé¦–å…ˆè¯¥ç‰¹å¾å¿…é¡»æ˜¯å¯¹è±¡å®‰å…¨çš„ï¼Œå³è¯¥ç‰¹å¾çš„æ‰€æœ‰æ–¹æ³•éƒ½å¿…é¡»æ‹¥æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š è¿”å›ç±»å‹ä¸èƒ½æ˜¯ Self. ä¸èƒ½ä½¿ç”¨æ³›å‹å‚æ•° ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ 123456789101112131415161718192021222324// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•è®©ä»£ç å·¥ä½œ// ä¸è¦æ·»åŠ /åˆ é™¤ä»»ä½•ä»£ç è¡Œtrait MyTrait &#123; fn f(&amp;self) -&gt; Self;&#125;impl MyTrait for u32 &#123; fn f(&amp;self) -&gt; Self &#123; 42 &#125;&#125;impl MyTrait for String &#123; fn f(&amp;self) -&gt; Self &#123; self.clone() &#125;&#125;fn my_function(x: Box&lt;dyn MyTrait&gt;) &#123; x.f()&#125;fn main() &#123; my_function(Box::new(13_u32)); my_function(Box::new(String::from(&quot;abc&quot;))); println!(&quot;Success!&quot;)&#125; My Answer ä¸ä¼š Answer 1234567891011121314151617181920trait MyTrait &#123; fn f(&amp;self) -&gt; Self;&#125;impl MyTrait for u32 &#123; fn f(&amp;self) -&gt; u32 &#123; 42 &#125;&#125;impl MyTrait for String &#123; fn f(&amp;self) -&gt; String &#123; self.clone() &#125;&#125;fn my_function(x: impl MyTrait) -&gt; impl MyTrait &#123; x.f()&#125;fn main() &#123; my_function(13_u32); my_function(String::from(&quot;abc&quot;));&#125; 1234567891011121314151617181920trait MyTrait &#123; fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt;;&#125;impl MyTrait for u32 &#123; fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(42) &#125;&#125;impl MyTrait for String &#123; fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(self.clone()) &#125;&#125;fn my_function(x: Box&lt;dyn MyTrait&gt;) -&gt; Box&lt;dyn MyTrait&gt; &#123; x.f()&#125;fn main() &#123; my_function(Box::new(13_u32)); my_function(Box::new(String::from(&quot;abc&quot;)));&#125; è¿›ä¸€æ­¥æ·±å…¥ç‰¹å¾ç±»å‹å…³è”ç±»å‹å…³è”ç±»å‹ä¸»è¦ç”¨äºæå‡ä»£ç çš„å¯è¯»æ€§ï¼Œä¾‹å¦‚ä»¥ä¸‹ä»£ç  : 123456789#![allow(unused)]fn main() &#123;pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable &#123; type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash; fn is_null(&amp;self) -&gt; bool;&#125;&#125; ç›¸æ¯” AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hashï¼Œ Address çš„ä½¿ç”¨å¯ä»¥æå¤§çš„å‡å°‘å…¶å®ƒç±»å‹åœ¨å®ç°è¯¥ç‰¹å¾æ—¶æ‰€éœ€çš„æ¨¡ç‰ˆä»£ç . ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Container(i32, i32);// ä½¿ç”¨å…³è”ç±»å‹å®ç°é‡æ–°å®ç°ä»¥ä¸‹ç‰¹å¾// trait Contains &#123;// type A;// type B;trait Contains&lt;A, B&gt; &#123; fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; fn first(&amp;self) -&gt; i32; fn last(&amp;self) -&gt; i32;&#125;impl Contains&lt;i32, i32&gt; for Container &#123; fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123; (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2) &#125; // Grab the first number. fn first(&amp;self) -&gt; i32 &#123; self.0 &#125; // Grab the last number. fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;&#125;fn difference&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) -&gt; i32 &#123; container.last() - container.first()&#125;fn main() &#123; let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;, &amp;number_1, &amp;number_2, container.contains(&amp;number_1, &amp;number_2)); println!(&quot;First number: &#123;&#125;&quot;, container.first()); println!(&quot;Last number: &#123;&#125;&quot;, container.last()); println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Container(i32, i32);// ä½¿ç”¨å…³è”ç±»å‹å®ç°é‡æ–°å®ç°ä»¥ä¸‹ç‰¹å¾// trait Contains &#123;// type A;// type B;trait Contains &#123; type A; type B; fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool; fn first(&amp;self) -&gt; i32; fn last(&amp;self) -&gt; i32;&#125; impl Contains for Container &#123; type A = i32; type B = i32; fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123; (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2) &#125; // Grab the first number. fn first(&amp;self) -&gt; i32 &#123; self.0 &#125; // Grab the last number. fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;&#125;fn difference&lt;C:Contains&gt;(container: &amp;C) -&gt; i32 &#123; container.last() - container.first()&#125;fn main() &#123; let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;, &amp;number_1, &amp;number_2, container.contains(&amp;number_1, &amp;number_2)); println!(&quot;First number: &#123;&#125;&quot;, container.first()); println!(&quot;Last number: &#123;&#125;&quot;, container.last()); println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));&#125; Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct Container(i32, i32);// A trait which checks if 2 items are stored inside of container.// Also retrieves first or last value.trait Contains &#123; // Define generic types here which methods will be able to utilize. type A; type B; fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool; fn first(&amp;self) -&gt; i32; fn last(&amp;self) -&gt; i32;&#125;impl Contains for Container &#123; // Specify what types `A` and `B` are. If the `input` type // is `Container(i32, i32)`, the `output` types are determined // as `i32` and `i32`. type A = i32; type B = i32; // `&amp;Self::A` and `&amp;Self::B` are also valid here. fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123; (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2) &#125; // Grab the first number. fn first(&amp;self) -&gt; i32 &#123; self.0 &#125; // Grab the last number. fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;&#125;fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 &#123; container.last() - container.first()&#125;fn main() &#123; let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;, &amp;number_1, &amp;number_2, container.contains(&amp;number_1, &amp;number_2)); println!(&quot;First number: &#123;&#125;&quot;, container.first()); println!(&quot;Last number: &#123;&#125;&quot;, container.last()); println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));&#125; å®šä¹‰é»˜è®¤çš„æ³›å‹ç±»å‹å‚æ•°å½“æˆ‘ä»¬ä½¿ç”¨æ³›å‹ç±»å‹å‚æ•°æ—¶ï¼Œå¯ä»¥ä¸ºè¯¥æ³›å‹å‚æ•°æŒ‡å®šä¸€ä¸ªå…·ä½“çš„é»˜è®¤ç±»å‹ï¼Œè¿™æ ·å½“å®ç°è¯¥ç‰¹å¾æ—¶ï¼Œå¦‚æœè¯¥é»˜è®¤ç±»å‹å¯ä»¥ä½¿ç”¨ï¼Œé‚£ç”¨æˆ·å†æ— éœ€æ‰‹åŠ¨æŒ‡å®šå…·ä½“çš„ç±»å‹ã€‚ ğŸŒŸğŸŒŸ 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// ç”¨ä¸‰ç§æ–¹æ³•å¡«ç©º: å…¶ä¸­ä¸¤ç§ä½¿ç”¨é»˜è®¤çš„æ³›å‹å‚æ•°ï¼Œå¦å¤–ä¸€ç§ä¸ä½¿ç”¨impl __ &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// ç”¨ä¸‰ç§æ–¹æ³•å¡«ç©º: å…¶ä¸­ä¸¤ç§ä½¿ç”¨é»˜è®¤çš„æ³›å‹å‚æ•°ï¼Œå¦å¤–ä¸€ç§ä¸ä½¿ç”¨impl&lt;T:Sub&lt;Output = T&gt;&gt; Sub for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// ç”¨ä¸‰ç§æ–¹æ³•å¡«ç©º: å…¶ä¸­ä¸¤ç§ä½¿ç”¨é»˜è®¤çš„æ³›å‹å‚æ•°ï¼Œå¦å¤–ä¸€ç§ä¸ä½¿ç”¨impl&lt;T:Sub&lt;Output = T&gt;&gt; Sub&lt;Point&lt;T&gt;&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Point&lt;T&gt;) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// ç”¨ä¸‰ç§æ–¹æ³•å¡«ç©º: å…¶ä¸­ä¸¤ç§ä½¿ç”¨é»˜è®¤çš„æ³›å‹å‚æ•°ï¼Œå¦å¤–ä¸€ç§ä¸ä½¿ç”¨impl&lt;T:Sub&lt;Output = T&gt;&gt; Sub&lt;Self&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Point&lt;T&gt;) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; Answer 12345678910impl&lt;T: Sub&lt;Output = T&gt;&gt; Sub&lt;Point&lt;T&gt;&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125; 12345678910impl&lt;T: Sub&lt;Output = T&gt;&gt; Sub&lt;Self&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125; 12345678910impl&lt;T: Sub&lt;Output = T&gt;&gt; Sub for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125; å®Œå…¨é™å®šè¯­æ³•åœ¨ Rust ä¸­ï¼Œä¸¤ä¸ªä¸åŒç‰¹å¾çš„æ–¹æ³•å®Œå…¨å¯ä»¥åŒåï¼Œä¸”ä½ å¯ä»¥ä¸ºåŒä¸€ä¸ªç±»å‹åŒæ—¶å®ç°è¿™ä¸¤ä¸ªç‰¹å¾ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå°±å‡ºç°äº†ä¸€ä¸ªé—®é¢˜ï¼šè¯¥å¦‚ä½•è°ƒç”¨è¿™ä¸¤ä¸ªç‰¹å¾ä¸Šå®šä¹‰çš„åŒåæ–¹æ³•ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨å®Œå…¨é™å®šè¯­æ³•( Fully Qualified Syntax )ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344trait UsernameWidget &#123; fn get(&amp;self) -&gt; String;&#125;trait AgeWidget &#123; fn get(&amp;self) -&gt; u8;&#125;struct Form &#123; username: String, age: u8,&#125;impl UsernameWidget for Form &#123; fn get(&amp;self) -&gt; String &#123; self.username.clone() &#125;&#125;impl AgeWidget for Form &#123; fn get(&amp;self) -&gt; u8 &#123; self.age &#125;&#125;fn main() &#123; let form = Form&#123; username: &quot;rustacean&quot;.to_owned(), age: 28, &#125;; // å¦‚æœä½ åæ³¨é‡Šä¸‹é¢ä¸€è¡Œä»£ç ï¼Œå°†çœ‹åˆ°ä¸€ä¸ªé”™è¯¯: Fully Qualified Syntax // æ¯•ç«Ÿï¼Œè¿™é‡Œæœ‰å¥½å‡ ä¸ªåŒåçš„ `get` æ–¹æ³• // // println!(&quot;&#123;&#125;&quot;, form.get()); let username = UsernameWidget::get(&amp;form); assert_eq!(&quot;rustacean&quot;.to_owned(), username); let age = AgeWidget::get(&amp;form); // ä½ è¿˜å¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¯­æ³• `&lt;Form as AgeWidget&gt;::get` assert_eq!(28, age); println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸ 123456789101112131415161718192021222324252627282930313233343536373839trait Pilot &#123; fn fly(&amp;self) -&gt; String;&#125;trait Wizard &#123; fn fly(&amp;self) -&gt; String;&#125;struct Human;impl Pilot for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;This is your captain speaking.&quot;) &#125;&#125;impl Wizard for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;Up!&quot;) &#125;&#125;impl Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;*waving arms furiously*&quot;) &#125;&#125;fn main() &#123; let person = Human; assert_eq!(__, &quot;This is your captain speaking.&quot;); assert_eq!(__, &quot;Up!&quot;); assert_eq!(__, &quot;*waving arms furiously*&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839trait Pilot &#123; fn fly(&amp;self) -&gt; String;&#125;trait Wizard &#123; fn fly(&amp;self) -&gt; String;&#125;struct Human;impl Pilot for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;This is your captain speaking.&quot;) &#125;&#125;impl Wizard for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;Up!&quot;) &#125;&#125;impl Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;*waving arms furiously*&quot;) &#125;&#125;fn main() &#123; let person = Human; assert_eq!(Pilot::fly(&amp;person), &quot;This is your captain speaking.&quot;); assert_eq!(Wizard::fly(&amp;person), &quot;Up!&quot;); assert_eq!(person.fly(), &quot;*waving arms furiously*&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637trait Pilot &#123; fn fly(&amp;self) -&gt; String;&#125;trait Wizard &#123; fn fly(&amp;self) -&gt; String;&#125;struct Human;impl Pilot for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;This is your captain speaking.&quot;) &#125;&#125;impl Wizard for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;Up!&quot;) &#125;&#125;impl Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;*waving arms furiously*&quot;) &#125;&#125;fn main() &#123; let person = Human; assert_eq!(Pilot::fly(&amp;person), &quot;This is your captain speaking.&quot;); assert_eq!(Wizard::fly(&amp;person), &quot;Up!&quot;); assert_eq!(person.fly(), &quot;*waving arms furiously*&quot;); println!(&quot;Success!&quot;)&#125; Supertraitsæœ‰äº›æ—¶å€™æˆ‘ä»¬å¸Œæœ›åœ¨ç‰¹å¾ä¸Šå®ç°ç±»ä¼¼ç»§æ‰¿çš„ç‰¹æ€§ï¼Œä¾‹å¦‚è®©ä¸€ä¸ªç‰¹å¾ A ä½¿ç”¨å¦ä¸€ä¸ªç‰¹å¾ B çš„åŠŸèƒ½ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œä¸€ä¸ªç±»å‹è¦å®ç°ç‰¹å¾ A é¦–å…ˆè¦å®ç°ç‰¹å¾ Bï¼Œ ç‰¹å¾ B å°±è¢«ç§°ä¸º supertrait ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253trait Person &#123; fn name(&amp;self) -&gt; String;&#125;// Person æ˜¯ Student çš„ supertrait .// å®ç° Student éœ€è¦åŒæ—¶å®ç° Person.trait Student: Person &#123; fn university(&amp;self) -&gt; String;&#125;trait Programmer &#123; fn fav_language(&amp;self) -&gt; String;&#125;// CompSciStudent (computer science student) æ˜¯ Programmer // å’Œ Student çš„ subtrait. å®ç° CompSciStudent éœ€è¦å…ˆå®ç°è¿™ä¸¤ä¸ª supertraits.trait CompSciStudent: Programmer + Student &#123; fn git_username(&amp;self) -&gt; String;&#125;fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String &#123; format!( &quot;My name is &#123;&#125; and I attend &#123;&#125;. My favorite language is &#123;&#125;. My Git username is &#123;&#125;&quot;, student.name(), student.university(), student.fav_language(), student.git_username() )&#125;struct CSStudent &#123; name: String, university: String, fav_language: String, git_username: String&#125;// ä¸º CSStudent å®ç°æ‰€éœ€çš„ç‰¹å¾impl ...fn main() &#123; let student = CSStudent &#123; name: &quot;Sunfei&quot;.to_string(), university: &quot;XXX&quot;.to_string(), fav_language: &quot;Rust&quot;.to_string(), git_username: &quot;sunface&quot;.to_string() &#125;; // å¡«ç©º println!(&quot;&#123;&#125;&quot;, comp_sci_student_greeting(__));&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475trait Person &#123; fn name(&amp;self) -&gt; String;&#125;// Person æ˜¯ Student çš„ supertrait .// å®ç° Student éœ€è¦åŒæ—¶å®ç° Person.trait Student: Person &#123; fn university(&amp;self) -&gt; String;&#125;trait Programmer &#123; fn fav_language(&amp;self) -&gt; String;&#125;// CompSciStudent (computer science student) æ˜¯ Programmer // å’Œ Student çš„ subtrait. å®ç° CompSciStudent éœ€è¦å…ˆå®ç°è¿™ä¸¤ä¸ª supertraits.trait CompSciStudent: Programmer + Student &#123; fn git_username(&amp;self) -&gt; String;&#125;fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String &#123; format!( &quot;My name is &#123;&#125; and I attend &#123;&#125;. My favorite language is &#123;&#125;. My Git username is &#123;&#125;&quot;, student.name(), student.university(), student.fav_language(), student.git_username() )&#125;struct CSStudent &#123; name: String, university: String, fav_language: String, git_username: String&#125;// ä¸º CSStudent å®ç°æ‰€éœ€çš„ç‰¹å¾impl Person for CSStudent&#123; fn name(&amp;self) -&gt; String &#123; self.name.clone() &#125;&#125;impl Student for CSStudent&#123; fn university(&amp;self) -&gt; String &#123; self.university.clone() &#125;&#125;impl Programmer for CSStudent&#123; fn fav_language(&amp;self) -&gt; String &#123; self.fav_language.clone() &#125;&#125;impl CompSciStudent for CSStudent&#123; fn git_username(&amp;self) -&gt; String &#123; self.git_username.clone() &#125;&#125;fn main() &#123; let student = CSStudent &#123; name: &quot;Sunfei&quot;.to_string(), university: &quot;XXX&quot;.to_string(), fav_language: &quot;Rust&quot;.to_string(), git_username: &quot;sunface&quot;.to_string() &#125;; // å¡«ç©º println!(&quot;&#123;&#125;&quot;, comp_sci_student_greeting(&amp;student));&#125; Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071trait Person &#123; fn name(&amp;self) -&gt; String;&#125;// Person is a supertrait of Student.// Implementing Student requires you to also impl Person.trait Student: Person &#123; fn university(&amp;self) -&gt; String;&#125;trait Programmer &#123; fn fav_language(&amp;self) -&gt; String;&#125;// CompSciStudent (computer science student) is a subtrait of both Programmer // and Student. Implementing CompSciStudent requires you to impl both supertraits.trait CompSciStudent: Programmer + Student &#123; fn git_username(&amp;self) -&gt; String;&#125;fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String &#123; format!( &quot;My name is &#123;&#125; and I attend &#123;&#125;. My favorite language is &#123;&#125;. My Git username is &#123;&#125;&quot;, student.name(), student.university(), student.fav_language(), student.git_username() )&#125;struct CSStudent &#123; name: String, university: String, fav_language: String, git_username: String&#125;impl Person for CSStudent &#123; fn name(&amp;self) -&gt; String &#123; self.name.clone() &#125;&#125;impl Student for CSStudent &#123; fn university(&amp;self) -&gt; String &#123; self.university.clone() &#125;&#125;impl Programmer for CSStudent &#123; fn fav_language(&amp;self) -&gt; String &#123; self.fav_language.clone() &#125;&#125;impl CompSciStudent for CSStudent &#123; fn git_username(&amp;self) -&gt; String &#123; self.git_username.clone() &#125;&#125;fn main() &#123; let student = CSStudent &#123; name: &quot;Sunfei&quot;.to_string(), university: &quot;XXX&quot;.to_string(), fav_language: &quot;Rust&quot;.to_string(), git_username: &quot;sunface&quot;.to_string() &#125;; println!(&quot;&#123;&#125;&quot;, comp_sci_student_greeting(&amp;student));&#125; å…³äºå­¤å„¿åŸåˆ™çš„è¯¦ç»†ä»‹ç»è¯·å‚è§ç‰¹å¾å®šä¹‰ä¸å®ç°çš„ä½ç½®å­¤å„¿è§„åˆ™ å’Œ åœ¨å¤–éƒ¨ç±»å‹ä¸Šå®ç°å¤–éƒ¨ç‰¹å¾ã€‚ ğŸŒŸğŸŒŸ 12345678910111213141516use std::fmt;// å®šä¹‰ä¸€ä¸ª newtype `Pretty`impl fmt::Display for Pretty &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; write!(f, &quot;\\&quot;&#123;&#125;\\&quot;&quot;, self.0.clone() + &quot;, world&quot;) &#125;&#125;fn main() &#123; let w = Pretty(&quot;hello&quot;.to_string()); println!(&quot;w = &#123;&#125;&quot;, w);&#125; My Answer 12345678910111213141516use std::fmt;// å®šä¹‰ä¸€ä¸ª newtype `Pretty`struct Pretty(String);impl fmt::Display for Pretty &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; write!(f, &quot;\\&quot;&#123;&#125;\\&quot;&quot;, self.0.clone() + &quot;, world&quot;) &#125;&#125;fn main() &#123; let w = Pretty(&quot;hello&quot;.to_string()); println!(&quot;w = &#123;&#125;&quot;, w);&#125; Answer 123456789101112131415use std::fmt;// DEFINE a newtype `Pretty`struct Pretty(String);impl fmt::Display for Pretty &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; write!(f, &quot;\\&quot;&#123;&#125;\\&quot;&quot;, self.0.clone() + &quot;, world&quot;) &#125;&#125;fn main() &#123; let w = Pretty(&quot;hello&quot;.to_string()); println!(&quot;w = &#123;&#125;&quot;, w);&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 7 æ–¹æ³•å’Œå…³è”å‡½æ•°","slug":"Rustå­¦ä¹ -ç»ƒä¹ 7-æ–¹æ³•å’Œå…³è”å‡½æ•°","date":"2023-09-09T06:44:49.000Z","updated":"2023-09-10T07:39:28.845Z","comments":true,"path":"2023/09/09/Rustå­¦ä¹ -ç»ƒä¹ 7-æ–¹æ³•å’Œå…³è”å‡½æ•°/","link":"","permalink":"http://example.com/2023/09/09/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A07-%E6%96%B9%E6%B3%95%E5%92%8C%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0/","excerpt":"ç¤ºä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104struct Point &#123; x: f64, y: f64,&#125;// `Point` çš„å…³è”å‡½æ•°éƒ½æ”¾åœ¨ä¸‹é¢çš„ `impl` è¯­å¥å—ä¸­impl Point &#123; // å…³è”å‡½æ•°çš„ä½¿ç”¨æ–¹æ³•è·Ÿæ„é€ å™¨éå¸¸ç±»ä¼¼ fn origin() -&gt; Point &#123; Point &#123; x: 0.0, y: 0.0 &#125; &#125; // å¦å¤–ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œæœ‰ä¸¤ä¸ªå‚æ•° fn new(x: f64, y: f64) -&gt; Point &#123; Point &#123; x: x, y: y &#125; &#125;&#125;struct Rectangle &#123; p1: Point, p2: Point,&#125;impl Rectangle &#123; // è¿™æ˜¯ä¸€ä¸ªæ–¹æ³• // `&amp;self` æ˜¯ `self: &amp;Self` çš„è¯­æ³•ç³– // `Self` æ˜¯å½“å‰è°ƒç”¨å¯¹è±¡çš„ç±»å‹ï¼Œå¯¹äºæœ¬ä¾‹æ¥è¯´ `Self` = `Rectangle` fn area(&amp;self) -&gt; f64 &#123; // ä½¿ç”¨ç‚¹æ“ä½œç¬¦å¯ä»¥è®¿é—® `self` ä¸­çš„ç»“æ„ä½“å­—æ®µ let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; // `abs` æ˜¯ä¸€ä¸ª `f64` ç±»å‹çš„æ–¹æ³•ï¼Œä¼šè¿”å›è°ƒç”¨è€…çš„ç»å¯¹å€¼ ((x1 - x2) * (y1 - y2)).abs() &#125; fn perimeter(&amp;self) -&gt; f64 &#123; let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; 2.0 * ((x1 - x2).abs() + (y1 - y2).abs()) &#125; // è¯¥æ–¹æ³•è¦æ±‚è°ƒç”¨è€…æ˜¯å¯å˜çš„ï¼Œ`&amp;mut self` æ˜¯ `self: &amp;mut Self` çš„è¯­æ³•ç³– fn translate(&amp;mut self, x: f64, y: f64) &#123; self.p1.x += x; self.p2.x += x; self.p1.y += y; self.p2.y += y; &#125;&#125;// `Pair` æŒæœ‰ä¸¤ä¸ªåˆ†é…åœ¨å †ä¸Šçš„æ•´æ•°struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);impl Pair &#123; // è¯¥æ–¹æ³•ä¼šæ‹¿èµ°è°ƒç”¨è€…çš„æ‰€æœ‰æƒ // `self` æ˜¯ `self: Self` çš„è¯­æ³•ç³– fn destroy(self) &#123; let Pair(first, second) = self; println!(&quot;Destroying Pair(&#123;&#125;, &#123;&#125;)&quot;, first, second); // `first` å’Œ `second` åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸå¹¶è¢«é‡Šæ”¾ &#125;&#125;fn main() &#123; let rectangle = Rectangle &#123; // å…³è”å‡½æ•°çš„è°ƒç”¨ä¸æ˜¯é€šè¿‡ç‚¹æ“ä½œç¬¦ï¼Œè€Œæ˜¯ä½¿ç”¨ `::` p1: Point::origin(), p2: Point::new(3.0, 4.0), &#125;; // æ–¹æ³•æ‰æ˜¯é€šè¿‡ç‚¹æ“ä½œç¬¦è°ƒç”¨ // æ³¨æ„ï¼Œè¿™é‡Œçš„æ–¹æ³•éœ€è¦çš„æ˜¯ `&amp;self` ä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨ `(&amp;rectangle).perimeter()` æ¥è°ƒç”¨ï¼ŒåŸå› åœ¨äºï¼š // ç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨å–å¼•ç”¨ // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)` println!(&quot;Rectangle perimeter: &#123;&#125;&quot;, rectangle.perimeter()); println!(&quot;Rectangle area: &#123;&#125;&quot;, rectangle.area()); let mut square = Rectangle &#123; p1: Point::origin(), p2: Point::new(1.0, 1.0), &#125;; // é”™è¯¯ï¼`rectangle` æ˜¯ä¸å¯å˜çš„ï¼Œä½†æ˜¯è¿™ä¸ªæ–¹æ³•è¦æ±‚ä¸€ä¸ªå¯å˜çš„å¯¹è±¡ //rectangle.translate(1.0, 0.0); // TODO ^ è¯•ç€åæ³¨é‡Šæ­¤è¡Œï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆ // å¯ä»¥ï¼å¯å˜å¯¹è±¡å¯ä»¥è°ƒç”¨å¯å˜çš„æ–¹æ³• square.translate(1.0, 1.0); let pair = Pair(Box::new(1), Box::new(2)); pair.destroy(); // Error! ä¸Šä¸€ä¸ª `destroy` è°ƒç”¨æ‹¿èµ°äº† `pair` çš„æ‰€æœ‰æƒ //pair.destroy(); // TODO ^ è¯•ç€åæ³¨é‡Šæ­¤è¡Œ&#125; æ–¹æ³•ï¼ˆmethodï¼‰","text":"ç¤ºä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104struct Point &#123; x: f64, y: f64,&#125;// `Point` çš„å…³è”å‡½æ•°éƒ½æ”¾åœ¨ä¸‹é¢çš„ `impl` è¯­å¥å—ä¸­impl Point &#123; // å…³è”å‡½æ•°çš„ä½¿ç”¨æ–¹æ³•è·Ÿæ„é€ å™¨éå¸¸ç±»ä¼¼ fn origin() -&gt; Point &#123; Point &#123; x: 0.0, y: 0.0 &#125; &#125; // å¦å¤–ä¸€ä¸ªå…³è”å‡½æ•°ï¼Œæœ‰ä¸¤ä¸ªå‚æ•° fn new(x: f64, y: f64) -&gt; Point &#123; Point &#123; x: x, y: y &#125; &#125;&#125;struct Rectangle &#123; p1: Point, p2: Point,&#125;impl Rectangle &#123; // è¿™æ˜¯ä¸€ä¸ªæ–¹æ³• // `&amp;self` æ˜¯ `self: &amp;Self` çš„è¯­æ³•ç³– // `Self` æ˜¯å½“å‰è°ƒç”¨å¯¹è±¡çš„ç±»å‹ï¼Œå¯¹äºæœ¬ä¾‹æ¥è¯´ `Self` = `Rectangle` fn area(&amp;self) -&gt; f64 &#123; // ä½¿ç”¨ç‚¹æ“ä½œç¬¦å¯ä»¥è®¿é—® `self` ä¸­çš„ç»“æ„ä½“å­—æ®µ let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; // `abs` æ˜¯ä¸€ä¸ª `f64` ç±»å‹çš„æ–¹æ³•ï¼Œä¼šè¿”å›è°ƒç”¨è€…çš„ç»å¯¹å€¼ ((x1 - x2) * (y1 - y2)).abs() &#125; fn perimeter(&amp;self) -&gt; f64 &#123; let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; 2.0 * ((x1 - x2).abs() + (y1 - y2).abs()) &#125; // è¯¥æ–¹æ³•è¦æ±‚è°ƒç”¨è€…æ˜¯å¯å˜çš„ï¼Œ`&amp;mut self` æ˜¯ `self: &amp;mut Self` çš„è¯­æ³•ç³– fn translate(&amp;mut self, x: f64, y: f64) &#123; self.p1.x += x; self.p2.x += x; self.p1.y += y; self.p2.y += y; &#125;&#125;// `Pair` æŒæœ‰ä¸¤ä¸ªåˆ†é…åœ¨å †ä¸Šçš„æ•´æ•°struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);impl Pair &#123; // è¯¥æ–¹æ³•ä¼šæ‹¿èµ°è°ƒç”¨è€…çš„æ‰€æœ‰æƒ // `self` æ˜¯ `self: Self` çš„è¯­æ³•ç³– fn destroy(self) &#123; let Pair(first, second) = self; println!(&quot;Destroying Pair(&#123;&#125;, &#123;&#125;)&quot;, first, second); // `first` å’Œ `second` åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸå¹¶è¢«é‡Šæ”¾ &#125;&#125;fn main() &#123; let rectangle = Rectangle &#123; // å…³è”å‡½æ•°çš„è°ƒç”¨ä¸æ˜¯é€šè¿‡ç‚¹æ“ä½œç¬¦ï¼Œè€Œæ˜¯ä½¿ç”¨ `::` p1: Point::origin(), p2: Point::new(3.0, 4.0), &#125;; // æ–¹æ³•æ‰æ˜¯é€šè¿‡ç‚¹æ“ä½œç¬¦è°ƒç”¨ // æ³¨æ„ï¼Œè¿™é‡Œçš„æ–¹æ³•éœ€è¦çš„æ˜¯ `&amp;self` ä½†æ˜¯æˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨ `(&amp;rectangle).perimeter()` æ¥è°ƒç”¨ï¼ŒåŸå› åœ¨äºï¼š // ç¼–è¯‘å™¨ä¼šå¸®æˆ‘ä»¬è‡ªåŠ¨å–å¼•ç”¨ // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)` println!(&quot;Rectangle perimeter: &#123;&#125;&quot;, rectangle.perimeter()); println!(&quot;Rectangle area: &#123;&#125;&quot;, rectangle.area()); let mut square = Rectangle &#123; p1: Point::origin(), p2: Point::new(1.0, 1.0), &#125;; // é”™è¯¯ï¼`rectangle` æ˜¯ä¸å¯å˜çš„ï¼Œä½†æ˜¯è¿™ä¸ªæ–¹æ³•è¦æ±‚ä¸€ä¸ªå¯å˜çš„å¯¹è±¡ //rectangle.translate(1.0, 0.0); // TODO ^ è¯•ç€åæ³¨é‡Šæ­¤è¡Œï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆ // å¯ä»¥ï¼å¯å˜å¯¹è±¡å¯ä»¥è°ƒç”¨å¯å˜çš„æ–¹æ³• square.translate(1.0, 1.0); let pair = Pair(Box::new(1), Box::new(2)); pair.destroy(); // Error! ä¸Šä¸€ä¸ª `destroy` è°ƒç”¨æ‹¿èµ°äº† `pair` çš„æ‰€æœ‰æƒ //pair.destroy(); // TODO ^ è¯•ç€åæ³¨é‡Šæ­¤è¡Œ&#125; æ–¹æ³•ï¼ˆmethodï¼‰ ğŸŒŸğŸŒŸ æ–¹æ³•è·Ÿå‡½æ•°ç±»ä¼¼ï¼šéƒ½æ˜¯ä½¿ç”¨ fn å£°æ˜ï¼Œæœ‰å‚æ•°å’Œè¿”å›å€¼ã€‚ä½†æ˜¯ä¸å‡½æ•°ä¸åŒçš„æ˜¯ï¼Œæ–¹æ³•å®šä¹‰åœ¨ç»“æ„ä½“çš„ä¸Šä¸‹æ–‡ä¸­(æšä¸¾ã€ç‰¹å¾å¯¹è±¡ä¹Ÿå¯ä»¥å®šä¹‰æ–¹æ³•)ï¼Œè€Œä¸”æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸€å®šæ˜¯ self æˆ–å…¶å˜ä½“ &amp;self ã€&amp;mut selfï¼Œself ä»£è¡¨äº†å½“å‰è°ƒç”¨çš„ç»“æ„ä½“å®ä¾‹ã€‚ 123456789101112131415struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // å®Œæˆ area æ–¹æ³•ï¼Œè¿”å›çŸ©å½¢ Rectangle çš„é¢ç§¯ fn area&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; assert_eq!(rect1.area(), 1500);&#125; My Answer 1234567891011121314151617struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // å®Œæˆ area æ–¹æ³•ï¼Œè¿”å›çŸ©å½¢ Rectangle çš„é¢ç§¯ fn area(self) -&gt; u32&#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; assert_eq!(rect1.area(), 1500);&#125; Answer 12345678910111213141516struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; assert_eq!(rect1.area(), 1500);&#125; ğŸŒŸğŸŒŸ self ä¼šæ‹¿èµ°å½“å‰ç»“æ„ä½“å®ä¾‹(è°ƒç”¨å¯¹è±¡)çš„æ‰€æœ‰æƒï¼Œè€Œ &amp;self å´åªä¼šå€Ÿç”¨ä¸€ä¸ªä¸å¯å˜å¼•ç”¨ï¼Œ&amp;mut self ä¼šå€Ÿç”¨ä¸€ä¸ªå¯å˜å¼•ç”¨ 1234567891011121314151617181920// åªå¡«ç©ºï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œ!#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; pub fn show_state(__) &#123; println!(&quot;the current state is &#123;&#125;&quot;, __.color); &#125;&#125;fn main() &#123; let light = TrafficLight&#123; color: &quot;red&quot;.to_owned(), &#125;; // ä¸è¦æ‹¿èµ° `light` çš„æ‰€æœ‰æƒ light.show_state(); // å¦åˆ™ä¸‹é¢ä»£ç ä¼šæŠ¥é”™ println!(&quot;&#123;:?&#125;&quot;, light);&#125; My Answer 1234567891011121314151617181920// åªå¡«ç©ºï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œ!#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; pub fn show_state(&amp;self) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125;&#125;fn main() &#123; let light = TrafficLight&#123; color: &quot;red&quot;.to_owned(), &#125;; // ä¸è¦æ‹¿èµ° `light` çš„æ‰€æœ‰æƒ light.show_state(); // å¦åˆ™ä¸‹é¢ä»£ç ä¼šæŠ¥é”™ println!(&quot;&#123;:?&#125;&quot;, light);&#125; Answer 1234567891011121314151617181920#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; pub fn show_state(&amp;self) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125;&#125;fn main() &#123; let light = TrafficLight &#123; color: &quot;red&quot;.to_owned(), &#125;; // Don&#x27;t take the ownership of `light` here light.show_state(); // ..otherwise, there will be an error below println!(&quot;&#123;:?&#125;&quot;, light);&#125; ğŸŒŸğŸŒŸ &amp;self å®é™…ä¸Šæ˜¯ self: &amp;Self çš„ç¼©å†™æˆ–è€…è¯´è¯­æ³•ç³– 12345678910111213141516struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // ä½¿ç”¨ `Self` å¡«ç©º pub fn show_state(__) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125; // å¡«ç©ºï¼Œä¸è¦ä½¿ç”¨ `Self` æˆ–å…¶å˜ä½“ pub fn change_state(__) &#123; self.color = &quot;green&quot;.to_string() &#125;&#125;fn main() &#123;&#125; My Answer æ²¡ç†è§£é¢˜ç›®æ˜¯ä»€ä¹ˆæ„æ€ Answer 1234567891011121314151617struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // using `Self` to fill in the blank pub fn show_state(self: &amp;Self) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125; // fill in the blank, DON&#x27;T use any variants of `Self` pub fn change_state(&amp;mut self) &#123; self.color = &quot;green&quot;.to_string() &#125;&#125;fn main() &#123;&#125; å…³è”å‡½æ•° ğŸŒŸğŸŒŸ å®šä¹‰åœ¨ impl è¯­å¥å—ä¸­çš„å‡½æ•°è¢«ç§°ä¸ºå…³è”å‡½æ•°ï¼Œå› ä¸ºå®ƒä»¬è·Ÿå½“å‰ç±»å‹å…³è”åœ¨ä¸€èµ·ã€‚å…³è”å‡½æ•°ä¸æ–¹æ³•æœ€å¤§çš„åŒºåˆ«å°±æ˜¯å®ƒç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯ self ï¼ŒåŸå› æ˜¯å®ƒä»¬ä¸éœ€è¦ä½¿ç”¨å½“å‰çš„å®ä¾‹ï¼Œå› æ­¤å…³è”å‡½æ•°å¾€å¾€å¯ä»¥ç”¨äºæ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–ä¸€ä¸ªå®ä¾‹å¯¹è±¡ã€‚ 1234567891011121314151617181920#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // 1. å®ç°ä¸‹é¢çš„å…³è”å‡½æ•° `new`, // 2. è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª TrafficLight å®ä¾‹ï¼ŒåŒ…å« `color` &quot;red&quot; // 3. è¯¥å‡½æ•°å¿…é¡»ä½¿ç”¨ `Self` ä½œä¸ºç±»å‹ï¼Œä¸èƒ½åœ¨ç­¾åæˆ–è€…å‡½æ•°ä½“ä¸­ä½¿ç”¨ `TrafficLight` pub fn new() pub fn get_state(&amp;self) -&gt; &amp;str &#123; &amp;self.color &#125;&#125;fn main() &#123; let light = TrafficLight::new(); assert_eq!(light.get_state(), &quot;red&quot;);&#125; My Answer 12345678910111213141516171819202122#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // 1. å®ç°ä¸‹é¢çš„å…³è”å‡½æ•° `new`, // 2. è¯¥å‡½æ•°è¿”å›ä¸€ä¸ª TrafficLight å®ä¾‹ï¼ŒåŒ…å« `color` &quot;red&quot; // 3. è¯¥å‡½æ•°å¿…é¡»ä½¿ç”¨ `Self` ä½œä¸ºç±»å‹ï¼Œä¸èƒ½åœ¨ç­¾åæˆ–è€…å‡½æ•°ä½“ä¸­ä½¿ç”¨ `TrafficLight` pub fn new(color:String) -&gt; TrafficLight&#123; TrafficLight &#123; color:color &#125; &#125; pub fn get_state(&amp;self) -&gt; &amp;str &#123; &amp;self.color &#125;&#125;fn main() &#123; let light = TrafficLight::new(&quot;red&quot;.to_string()); assert_eq!(light.get_state(), &quot;red&quot;);&#125; Answer 123456789101112131415161718192021222324#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // 1. implement a associated function `new`, // 2. it will return a TrafficLight contains color &quot;red&quot; // 3. must use `Self`, DONT use `TrafficLight` pub fn new() -&gt; Self &#123; Self &#123; color: &quot;red&quot;.to_string() &#125; &#125; pub fn get_state(&amp;self) -&gt; &amp;str &#123; &amp;self.color &#125;&#125;fn main() &#123; let light = TrafficLight::new(); assert_eq!(light.get_state(), &quot;red&quot;);&#125; å¤šä¸ªimplè¯­å¥å— ğŸŒŸ æ¯ä¸€ä¸ªç»“æ„ä½“å…è®¸æ‹¥æœ‰å¤šä¸ª impl è¯­å¥å— 12345678910111213141516struct Rectangle &#123; width: u32, height: u32,&#125;// ä½¿ç”¨å¤šä¸ª `impl` è¯­å¥å—é‡å†™ä¸‹é¢çš„ä»£ç impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;fn main() &#123;&#125; My Answer 1234567891011121314151617181920struct Rectangle &#123; width: u32, height: u32, &#125; // ä½¿ç”¨å¤šä¸ª `impl` è¯­å¥å—é‡å†™ä¸‹é¢çš„ä»£ç  impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125; &#125; impl Rectangle &#123; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125; &#125; fn main() &#123;&#125; Answer 12345678910111213141516171819struct Rectangle &#123; width: u32, height: u32,&#125;// rewrite Rectangle to use multiple `impl` blocksimpl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;impl Rectangle &#123; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;fn main() &#123;&#125; ä¸ºæšä¸¾ç±»å‹å®ç°æ–¹æ³• ğŸŒŸğŸŒŸğŸŒŸ æˆ‘ä»¬è¿˜å¯ä»¥ä¸ºæšä¸¾ç±»å‹å®šä¹‰æ–¹æ³• 12345678910111213141516171819#[derive(Debug)]enum TrafficLightColor &#123; Red, Yellow, Green,&#125;// ä¸º TrafficLightColor å®ç°æ‰€éœ€çš„æ–¹æ³•impl TrafficLightColor &#123;&#125;fn main() &#123; let c = TrafficLightColor::Yellow; assert_eq!(c.color(), &quot;yellow&quot;); println!(&quot;&#123;:?&#125;&quot;,c);&#125; My Answer 12345678910111213141516171819#[derive(Debug)]enum TrafficLightColor &#123; Red, Yellow, Green,&#125;// ä¸º TrafficLightColor å®ç°æ‰€éœ€çš„æ–¹æ³•impl TrafficLightColor &#123;&#125;fn main() &#123; let c = TrafficLightColor::Yellow; assert_eq!(c.color(), &quot;yellow&quot;); println!(&quot;&#123;:?&#125;&quot;,c);&#125; Answer 12345678910111213141516171819202122232425#[derive(Debug)]enum TrafficLightColor &#123; Red, Yellow, Green,&#125;// implement TrafficLightColor with a methodimpl TrafficLightColor &#123; fn color(&amp;self) -&gt; String &#123; match *self &#123; TrafficLightColor::Red =&gt; &quot;red&quot;.to_string(), TrafficLightColor::Yellow =&gt; &quot;yellow&quot;.to_string(), TrafficLightColor::Green =&gt; &quot;green&quot;.to_string(), &#125; &#125;&#125;fn main() &#123; let c = TrafficLightColor::Yellow; assert_eq!(c.color(), &quot;yellow&quot;); println!(&quot;&#123;:?&#125;&quot;, c);&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 6 æ¨¡å¼åŒ¹é…","slug":"Rustå­¦ä¹ -ç»ƒä¹ 6-æ¨¡å¼åŒ¹é…","date":"2023-09-06T00:53:30.000Z","updated":"2023-09-10T07:39:13.140Z","comments":true,"path":"2023/09/06/Rustå­¦ä¹ -ç»ƒä¹ 6-æ¨¡å¼åŒ¹é…/","link":"","permalink":"http://example.com/2023/09/06/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A06-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"matchï¼Œmatchesï¼å’Œif letmatch ğŸŒŸğŸŒŸ 123456789101112131415161718// å¡«ç©ºenum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), __ =&gt; &#123; // åœ¨è¿™é‡ŒåŒ¹é… South æˆ– North println!(&quot;South or North&quot;); &#125;, _ =&gt; println!(__), &#125;;&#125; My Answer 12345678910111213141516171819// å¡«ç©ºenum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), Direction::South | Direction::North =&gt; &#123; // åœ¨è¿™é‡ŒåŒ¹é… South æˆ– North println!(&quot;South or North&quot;); &#125; _ =&gt; println!(&quot;other&quot;), &#125;;&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; ğŸŒŸğŸŒŸ match æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤å¯ä»¥ç”¨åœ¨èµ‹å€¼è¯­å¥ä¸­ 1234567891011fn main() &#123; let boolean = true; // ä½¿ç”¨ match è¡¨è¾¾å¼å¡«ç©ºï¼Œå¹¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = __; assert_eq!(binary, 1);&#125; My Answer 1234567891011121314fn main() &#123; let boolean = true; // ä½¿ç”¨ match è¡¨è¾¾å¼å¡«ç©ºï¼Œå¹¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean&#123; true =&gt; 1, false =&gt; 0, &#125;; assert_eq!(binary, 1);&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; ğŸŒŸğŸŒŸ ä½¿ç”¨ match åŒ¹é…å‡ºæšä¸¾æˆå‘˜æŒæœ‰çš„å€¼ 123456789101112131415161718192021222324252627282930313233// å¡«ç©ºenum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; __ =&gt; &#123; // è¿™é‡ŒåŒ¹é… Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, __); assert_eq!(b, __); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; My Answer 123456789101112131415161718192021222324252627282930313233// å¡«ç©ºenum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move &#123;x:a, y:b&#125; =&gt; &#123; // è¿™é‡ŒåŒ¹é… Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; Answer 1234567891011121314151617181920212223242526272829303132enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move&#123;x: a, y: b&#125; =&gt; &#123; // match Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; _ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125;","text":"matchï¼Œmatchesï¼å’Œif letmatch ğŸŒŸğŸŒŸ 123456789101112131415161718// å¡«ç©ºenum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), __ =&gt; &#123; // åœ¨è¿™é‡ŒåŒ¹é… South æˆ– North println!(&quot;South or North&quot;); &#125;, _ =&gt; println!(__), &#125;;&#125; My Answer 12345678910111213141516171819// å¡«ç©ºenum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), Direction::South | Direction::North =&gt; &#123; // åœ¨è¿™é‡ŒåŒ¹é… South æˆ– North println!(&quot;South or North&quot;); &#125; _ =&gt; println!(&quot;other&quot;), &#125;;&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; ğŸŒŸğŸŒŸ match æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤å¯ä»¥ç”¨åœ¨èµ‹å€¼è¯­å¥ä¸­ 1234567891011fn main() &#123; let boolean = true; // ä½¿ç”¨ match è¡¨è¾¾å¼å¡«ç©ºï¼Œå¹¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = __; assert_eq!(binary, 1);&#125; My Answer 1234567891011121314fn main() &#123; let boolean = true; // ä½¿ç”¨ match è¡¨è¾¾å¼å¡«ç©ºï¼Œå¹¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean&#123; true =&gt; 1, false =&gt; 0, &#125;; assert_eq!(binary, 1);&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; ğŸŒŸğŸŒŸ ä½¿ç”¨ match åŒ¹é…å‡ºæšä¸¾æˆå‘˜æŒæœ‰çš„å€¼ 123456789101112131415161718192021222324252627282930313233// å¡«ç©ºenum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; __ =&gt; &#123; // è¿™é‡ŒåŒ¹é… Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, __); assert_eq!(b, __); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; My Answer 123456789101112131415161718192021222324252627282930313233// å¡«ç©ºenum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move &#123;x:a, y:b&#125; =&gt; &#123; // è¿™é‡ŒåŒ¹é… Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; Answer 1234567891011121314151617181920212223242526272829303132enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move&#123;x: a, y: b&#125; =&gt; &#123; // match Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; _ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; matches!matches! çœ‹èµ·æ¥åƒ match, ä½†æ˜¯å®ƒå¯ä»¥åšä¸€äº›ç‰¹åˆ«çš„äº‹æƒ… ğŸŒŸğŸŒŸ 12345678fn main() &#123; let alphabets = [&#x27;a&#x27;, &#x27;E&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;x&#x27;, &#x27;9&#x27; , &#x27;Y&#x27;]; // ä½¿ç”¨ `matches` å¡«ç©º for ab in alphabets &#123; assert!(__) &#125;&#125; My Answer 12345678fn main() &#123; let alphabets = [&#x27;a&#x27;, &#x27;E&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;x&#x27;, &#x27;9&#x27; , &#x27;Y&#x27;]; // ä½¿ç”¨ `matches` å¡«ç©º for ab in alphabets &#123; assert!(matches!(ab,&#x27;a&#x27;..=&#x27;z&#x27;|&#x27;A&#x27;..=&#x27;Z&#x27;|&#x27;0&#x27;..=&#x27;9&#x27;)); &#125;&#125; Answer 12345678fn main() &#123; let alphabets = [&#x27;a&#x27;, &#x27;E&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;x&#x27;, &#x27;9&#x27; , &#x27;Y&#x27;]; // fill the blank with `matches!` to make the code work for ab in alphabets &#123; assert!(matches!(ab, &#x27;a&#x27;..=&#x27;z&#x27; | &#x27;A&#x27;..=&#x27;Z&#x27; | &#x27;0&#x27;..=&#x27;9&#x27;)) &#125;&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617enum MyEnum &#123; Foo, Bar&#125;fn main() &#123; let mut count = 0; let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo]; for e in v &#123; if e == MyEnum::Foo &#123; // ä¿®å¤é”™è¯¯ï¼Œåªèƒ½ä¿®æ”¹æœ¬è¡Œä»£ç  count += 1; &#125; &#125; assert_eq!(count, 2);&#125; My Answer 1234567891011121314151617enum MyEnum &#123; Foo, Bar&#125;fn main() &#123; let mut count = 0; let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo]; for e in v &#123; if matches!(e,MyEnum::Foo) &#123; // ä¿®å¤é”™è¯¯ï¼Œåªèƒ½ä¿®æ”¹æœ¬è¡Œä»£ç  count += 1; &#125; &#125; assert_eq!(count, 2);&#125; Answer 1234567891011121314151617enum MyEnum &#123; Foo, Bar&#125;fn main() &#123; let mut count = 0; let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo]; for e in v &#123; if matches!(e , MyEnum::Foo) &#123; // fix the error with changing only this line count += 1; &#125; &#125; assert_eq!(count, 2);&#125; if letåœ¨æœ‰äº›æ—¶å€™, ä½¿ç”¨ match åŒ¹é…æšä¸¾æœ‰äº›å¤ªé‡äº†ï¼Œæ­¤æ—¶ if let å°±éå¸¸é€‚åˆ. ğŸŒŸ 1234567891011fn main() &#123; let o = Some(7); // ç§»é™¤æ•´ä¸ª `match` è¯­å¥å—ï¼Œä½¿ç”¨ `if let` æ›¿ä»£ match o &#123; Some(i) =&gt; &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125; _ =&gt; &#123;&#125; &#125;;&#125; My Answer 12345678fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125; // ç§»é™¤æ•´ä¸ª `match` è¯­å¥å—ï¼Œä½¿ç”¨ `if let` æ›¿ä»£&#125; Answer 1234567fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125;&#125; ğŸŒŸğŸŒŸ 123456789101112// å¡«ç©ºenum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); __ &#123; println!(&quot;foobar æŒæœ‰çš„å€¼æ˜¯: &#123;&#125;&quot;, i); &#125;&#125; My Answer 12345678fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125; // ç§»é™¤æ•´ä¸ª `match` è¯­å¥å—ï¼Œä½¿ç”¨ `if let` æ›¿ä»£&#125; Answer 1234567fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125;&#125; ğŸŒŸğŸŒŸ 123456789101112// å¡«ç©ºenum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); __ &#123; println!(&quot;foobar æŒæœ‰çš„å€¼æ˜¯: &#123;&#125;&quot;, i); &#125;&#125; My Answer 123456789101112// å¡«ç©ºenum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); if let Foo::Bar(i) = a &#123; println!(&quot;foobar æŒæœ‰çš„å€¼æ˜¯: &#123;&#125;&quot;, i); &#125;&#125; Answer 1234567891011enum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); if let Foo::Bar(i) = a &#123; println!(&quot;foobar holds the value: &#123;&#125;&quot;, i); &#125;&#125; ğŸŒŸğŸŒŸ 123456789101112131415161718enum Foo &#123; Bar, Baz, Qux(u32)&#125;fn main() &#123; let a = Foo::Qux(10); // ç§»é™¤ä»¥ä¸‹ä»£ç ï¼Œä½¿ç”¨ `match` ä»£æ›¿ if let Foo::Bar = a &#123; println!(&quot;match foo::bar&quot;) &#125; else if let Foo::Baz = a &#123; println!(&quot;match foo::baz&quot;) &#125; else &#123; println!(&quot;match others&quot;) &#125;&#125; My Answer 12345678910111213141516enum Foo &#123; Bar, Baz, Qux(u32)&#125;fn main() &#123; let a = Foo::Qux(10); // ç§»é™¤ä»¥ä¸‹ä»£ç ï¼Œä½¿ç”¨ `match` ä»£æ›¿ match a &#123; Foo::Bar =&gt; println!(&quot;match foo::bar&quot;), Foo::Baz =&gt; println!(&quot;match foo::baz&quot;), _ =&gt; println!(&quot;match others&quot;) &#125;&#125; Answer 123456789101112131415enum Foo &#123; Bar, Baz, Qux(u32)&#125;fn main() &#123; let a = Foo::Qux(10); match a &#123; Foo::Bar =&gt; println!(&quot;match foo::bar&quot;), Foo::Baz =&gt; println!(&quot;match foo::baz&quot;), _ =&gt; println!(&quot;match others&quot;) &#125;&#125; å˜é‡é®è”½ï¼ˆshadowingï¼‰ ğŸŒŸğŸŒŸ 12345678910111213// å°±åœ°ä¿®å¤é”™è¯¯fn main() &#123; let age = Some(30); if let Some(age) = age &#123; // åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œè¯¥å˜é‡ä¸ä¹‹å‰çš„ `age` å˜é‡åŒå assert_eq!(age, Some(30)); &#125; // æ–°çš„ `age` å˜é‡åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸ match age &#123; // `match` ä¹Ÿèƒ½å®ç°å˜é‡é®è”½ Some(age) =&gt; println!(&quot;age æ˜¯ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå®ƒçš„å€¼æ˜¯ &#123;&#125;&quot;,age), _ =&gt; () &#125; &#125; My Answer 12345678910111213// å°±åœ°ä¿®å¤é”™è¯¯fn main() &#123; let age = Some(30); if let Some(age) = age &#123; // åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ï¼Œè¯¥å˜é‡ä¸ä¹‹å‰çš„ `age` å˜é‡åŒå assert_eq!(age, 30); &#125; // æ–°çš„ `age` å˜é‡åœ¨è¿™é‡Œè¶…å‡ºä½œç”¨åŸŸ match age &#123; // `match` ä¹Ÿèƒ½å®ç°å˜é‡é®è”½ Some(age) =&gt; println!(&quot;age æ˜¯ä¸€ä¸ªæ–°çš„å˜é‡ï¼Œå®ƒçš„å€¼æ˜¯ &#123;&#125;&quot;,age), _ =&gt; () &#125; &#125; Answer 123456789101112fn main() &#123; let age = Some(30); if let Some(age) = age &#123; // create a new variable with the same name as previous `age` assert_eq!(age, 30); &#125; // the new variable `age` goes out of scope here match age &#123; // match can also introduce a new shadowed variable Some(age) =&gt; println!(&quot;age is a new variable, it&#x27;s value is &#123;&#125;&quot;,age), _ =&gt; () &#125; &#125; æ¨¡å¼ ğŸŒŸğŸŒŸ ä½¿ç”¨ | å¯ä»¥åŒ¹é…å¤šä¸ªå€¼, è€Œä½¿ç”¨ ..= å¯ä»¥åŒ¹é…ä¸€ä¸ªé—­åŒºé—´çš„æ•°å€¼åºåˆ— 12345678910111213141516fn main() &#123;&#125;fn match_number(n: i32) &#123; match n &#123; // åŒ¹é…ä¸€ä¸ªå•ç‹¬çš„å€¼ 1 =&gt; println!(&quot;One!&quot;), // ä½¿ç”¨ `|` å¡«ç©ºï¼Œä¸è¦ä½¿ç”¨ `..` æˆ– `..=` __ =&gt; println!(&quot;match 2 -&gt; 5&quot;), // åŒ¹é…ä¸€ä¸ªé—­åŒºé—´çš„æ•°å€¼åºåˆ— 6..=10 =&gt; &#123; println!(&quot;match 6 -&gt; 10&quot;) &#125;, _ =&gt; &#123; println!(&quot;match 11 -&gt; +infinite&quot;) &#125; &#125;&#125; My Answer 123456789101112131415161718fn main() &#123; match_number(3);&#125;fn match_number(n: i32) &#123; match n &#123; // åŒ¹é…ä¸€ä¸ªå•ç‹¬çš„å€¼ 1 =&gt; println!(&quot;One!&quot;), // ä½¿ç”¨ `|` å¡«ç©ºï¼Œä¸è¦ä½¿ç”¨ `..` æˆ– `..=` 2|3|4|5 =&gt; println!(&quot;match 2 -&gt; 5&quot;), // åŒ¹é…ä¸€ä¸ªé—­åŒºé—´çš„æ•°å€¼åºåˆ— 6..=10 =&gt; &#123; println!(&quot;match 6 -&gt; 10&quot;) &#125;, _ =&gt; &#123; println!(&quot;match 11 -&gt; +infinite&quot;) &#125; &#125;&#125; Answer 12345678910111213141516fn main() &#123;&#125;fn match_number(n: i32) &#123; match n &#123; // match a single value 1 =&gt; println!(&quot;One!&quot;), // fill in the blank with `|`, DON&#x27;T use `..` ofr `..=` 2 | 3 | 4 | 5 =&gt; println!(&quot;match 2 -&gt; 5&quot;), // match an inclusive range 6..=10 =&gt; &#123; println!(&quot;match 6 -&gt; 10&quot;) &#125;, _ =&gt; &#123; println!(&quot;match 11 -&gt; +infinite&quot;) &#125; &#125;&#125; ğŸŒŸğŸŒŸğŸŒŸ @ æ“ä½œç¬¦å¯ä»¥è®©æˆ‘ä»¬å°†ä¸€ä¸ªä¸æ¨¡å¼ç›¸åŒ¹é…çš„å€¼ç»‘å®šåˆ°æ–°çš„å˜é‡ä¸Š 12345678910111213141516struct Point &#123; x: i32, y: i32,&#125;fn main() &#123; // å¡«ç©ºï¼Œè®© p åŒ¹é…ç¬¬äºŒä¸ªåˆ†æ”¯ let p = Point &#123; x: __, y: __ &#125;; match p &#123; Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x), // ç¬¬äºŒä¸ªåˆ†æ”¯ Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y), Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y), &#125;&#125; My Answer 12345678910111213141516struct Point &#123; x: i32, y: i32,&#125;fn main() &#123; // å¡«ç©ºï¼Œè®© p åŒ¹é…ç¬¬äºŒä¸ªåˆ†æ”¯ let p = Point &#123; x: 0, y: 20 &#125;; match p &#123; Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x), // ç¬¬äºŒä¸ªåˆ†æ”¯ Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y), Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y), &#125;&#125; Answer 12345678910111213141516struct Point &#123; x: i32, y: i32,&#125;fn main() &#123; // fill in the blank to let p match the second arm let p = Point &#123; x: 2, y: 20 &#125;; // x can be [0, 5], y can be 10 20 or 30 match p &#123; Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x), // second arm Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y), Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y), &#125;&#125; ğŸŒŸğŸŒŸğŸŒŸ 123456789101112131415161718// ä¿®å¤é”™è¯¯enum Message &#123; Hello &#123; id: i32 &#125;,&#125;fn main() &#123; let msg = Message::Hello &#123; id: 5 &#125;; match msg &#123; Message::Hello &#123; id: 3..=7, &#125; =&gt; println!(&quot;id å€¼çš„èŒƒå›´åœ¨ [3, 7] ä¹‹é—´: &#123;&#125;&quot;, id), Message::Hello &#123; id: newid@10 | 11 | 12 &#125; =&gt; &#123; println!(&quot;id å€¼çš„èŒƒå›´åœ¨ [10, 12] ä¹‹é—´: &#123;&#125;&quot;, newid) &#125; Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id), &#125;&#125; My Answer 123456789101112131415161718// ä¿®å¤é”™è¯¯enum Message &#123; Hello &#123; id: i32 &#125;,&#125;fn main() &#123; let msg = Message::Hello &#123; id: 5 &#125;; match msg &#123; Message::Hello &#123; id: id@3..=7, &#125; =&gt; println!(&quot;id å€¼çš„èŒƒå›´åœ¨ [3, 7] ä¹‹é—´: &#123;&#125;&quot;, id), Message::Hello &#123; id: newid@(10 | 11 | 12) &#125; =&gt; &#123; println!(&quot;id å€¼çš„èŒƒå›´åœ¨ [10, 12] ä¹‹é—´: &#123;&#125;&quot;, newid) &#125; Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id), &#125;&#125; Answer 1234567891011121314151617enum Message &#123; Hello &#123; id: i32 &#125;,&#125;fn main() &#123; let msg = Message::Hello &#123; id: 5 &#125;; match msg &#123; Message::Hello &#123; id: id@3..=7, &#125; =&gt; println!(&quot;Found an id in range [3, 7]: &#123;&#125;&quot;, id), Message::Hello &#123; id: newid@(10 | 11 | 12) &#125; =&gt; &#123; println!(&quot;Found an id in another range [10, 12]: &#123;&#125;&quot;, newid) &#125; Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id), &#125;&#125; ğŸŒŸğŸŒŸ åŒ¹é…å®ˆå«ï¼ˆmatch guardï¼‰æ˜¯ä¸€ä¸ªä½äº match åˆ†æ”¯æ¨¡å¼ä¹‹åçš„é¢å¤– if æ¡ä»¶ï¼Œå®ƒèƒ½ä¸ºåˆ†æ”¯æ¨¡å¼æä¾›æ›´è¿›ä¸€æ­¥çš„åŒ¹é…æ¡ä»¶ã€‚ 12345678910// å¡«ç©ºè®©ä»£ç å·¥ä½œï¼Œå¿…é¡»ä½¿ç”¨ `split`fn main() &#123; let num = Some(4); let split = 5; match num &#123; Some(x) __ =&gt; assert!(x &lt; split), Some(x) =&gt; assert!(x &gt;= split), None =&gt; (), &#125;&#125; My Answer 12345678910// å¡«ç©ºè®©ä»£ç å·¥ä½œï¼Œå¿…é¡»ä½¿ç”¨ `split`fn main() &#123; let num = Some(4); let split = 5; match num &#123; Some(x) if x &lt; split =&gt; assert!(x &lt; split), Some(x) =&gt; assert!(x &gt;= split), None =&gt; (), &#125;&#125; Answer 123456789fn main() &#123; let num = Some(4); let split = 5; match num &#123; Some(x) if x &lt; split =&gt; assert!(x &lt; split), Some(x) =&gt; assert!(x &gt;= split), None =&gt; (), &#125;&#125; ğŸŒŸğŸŒŸğŸŒŸ ä½¿ç”¨ .. å¿½ç•¥ä¸€éƒ¨åˆ†å€¼ 1234567891011// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048); match numbers &#123; __ =&gt; &#123; assert_eq!(first, 2); assert_eq!(last, 2048); &#125; &#125;&#125; My Answer 1234567891011// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048); match numbers &#123; (first,..,last) =&gt; &#123; assert_eq!(first, 2); assert_eq!(last, 2048); &#125; &#125;&#125; Answer 12345678910fn main() &#123; let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048); match numbers &#123; (first,..,last) =&gt; &#123; assert_eq!(first, 2); assert_eq!(last, 2048); &#125; &#125;&#125; ğŸŒŸğŸŒŸ ä½¿ç”¨æ¨¡å¼ &amp;mut V å»åŒ¹é…ä¸€ä¸ªå¯å˜å¼•ç”¨æ—¶ï¼Œä½ éœ€è¦æ ¼å¤–å°å¿ƒï¼Œå› ä¸ºåŒ¹é…å‡ºæ¥çš„ V æ˜¯ä¸€ä¸ªå€¼ï¼Œè€Œä¸æ˜¯å¯å˜å¼•ç”¨ 12345678910// ä¿®å¤é”™è¯¯ï¼Œå°½é‡å°‘åœ°ä¿®æ”¹ä»£ç // ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let mut v = String::from(&quot;hello,&quot;); let r = &amp;mut v; match r &#123; &amp;mut value =&gt; value.push_str(&quot; world!&quot;) &#125;&#125; My Answer 12345678910// ä¿®å¤é”™è¯¯ï¼Œå°½é‡å°‘åœ°ä¿®æ”¹ä»£ç // ä¸è¦ç§»é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let mut v = String::from(&quot;hello,&quot;); let r = &amp;mut v; match r &#123; value =&gt; value.push_str(&quot; world!&quot;) &#125;&#125; Answer 123456789fn main() &#123; let mut v = String::from(&quot;hello,&quot;); let r = &amp;mut v; match r &#123; // The type of value is &amp;mut String value =&gt; value.push_str(&quot; world!&quot;) &#125;&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 5 æµç¨‹æ§åˆ¶","slug":"Rustå­¦ä¹ -ç»ƒä¹ 5-æµç¨‹æ§åˆ¶","date":"2023-09-05T13:58:13.000Z","updated":"2023-09-10T07:42:49.702Z","comments":true,"path":"2023/09/05/Rustå­¦ä¹ -ç»ƒä¹ 5-æµç¨‹æ§åˆ¶/","link":"","permalink":"http://example.com/2023/09/05/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"if&#x2F;else ğŸŒŸ 123456789101112// å¡«ç©ºfn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; __ n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; __ &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; My Answer 123456789101112// å¡«ç©ºfn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; Answer 1234567891011fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; ğŸŒŸğŸŒŸ if&#x2F;else å¯ä»¥ç”¨ä½œè¡¨è¾¾å¼æ¥è¿›è¡Œèµ‹å€¼ 1234567891011121314151617// ä¿®å¤é”™è¯¯fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; æ•°å­—å¤ªå°ï¼Œå…ˆå¢åŠ  10 å€å†è¯´&quot;); 10 * n &#125; else &#123; println!(&quot;æ•°å­—å¤ªå¤§ï¼Œæˆ‘ä»¬å¾—è®©å®ƒå‡åŠ&quot;); n / 2.0 ; &#125; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; My Answer 1234567891011121314151617// ä¿®å¤é”™è¯¯fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; æ•°å­—å¤ªå°ï¼Œå…ˆå¢åŠ  10 å€å†è¯´&quot;); 10 * n &#125; else &#123; println!(&quot;æ•°å­—å¤ªå¤§ï¼Œæˆ‘ä»¬å¾—è®©å®ƒå‡åŠ&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; 1 Answer 12345678910111213141516fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot;, and is a small number, increase ten-fold&quot;); 10 * n &#125; else &#123; println!(&quot;, and is a big number, halve the number&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125;","text":"if&#x2F;else ğŸŒŸ 123456789101112// å¡«ç©ºfn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; __ n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; __ &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; My Answer 123456789101112// å¡«ç©ºfn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; Answer 1234567891011fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; ğŸŒŸğŸŒŸ if&#x2F;else å¯ä»¥ç”¨ä½œè¡¨è¾¾å¼æ¥è¿›è¡Œèµ‹å€¼ 1234567891011121314151617// ä¿®å¤é”™è¯¯fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; æ•°å­—å¤ªå°ï¼Œå…ˆå¢åŠ  10 å€å†è¯´&quot;); 10 * n &#125; else &#123; println!(&quot;æ•°å­—å¤ªå¤§ï¼Œæˆ‘ä»¬å¾—è®©å®ƒå‡åŠ&quot;); n / 2.0 ; &#125; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; My Answer 1234567891011121314151617// ä¿®å¤é”™è¯¯fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; æ•°å­—å¤ªå°ï¼Œå…ˆå¢åŠ  10 å€å†è¯´&quot;); 10 * n &#125; else &#123; println!(&quot;æ•°å­—å¤ªå¤§ï¼Œæˆ‘ä»¬å¾—è®©å®ƒå‡åŠ&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; 1 Answer 12345678910111213141516fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot;, and is a small number, increase ten-fold&quot;); 10 * n &#125; else &#123; println!(&quot;, and is a big number, halve the number&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; for ğŸŒŸ for in å¯ä»¥ç”¨äºè¿­ä»£ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¾‹å¦‚åºåˆ— a..b. 1234567fn main() &#123; for n in 1..=100 &#123; if n == 100 &#123; panic!(&quot;NEVER LET THIS RUN&quot;) &#125; &#125;&#125; My Answer 1234567fn main() &#123; for n in 1..100 &#123; if n == 100 &#123; panic!(&quot;NEVER LET THIS RUN&quot;) &#125; &#125;&#125; Answer 1234567fn main() &#123; for n in 1..100 &#123; if n == 100 &#123; panic!(&quot;NEVER LET THIS RUN&quot;) &#125; &#125;&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617// ä¿®å¤é”™è¯¯ï¼Œä¸è¦æ–°å¢æˆ–åˆ é™¤ä»£ç è¡Œfn main() &#123; let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)]; for name in names &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, names); let numbers = [1, 2, 3]; // numbersä¸­çš„å…ƒç´ å®ç°äº† Copyï¼Œå› æ­¤æ— éœ€è½¬ç§»æ‰€æœ‰æƒ for n in numbers &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, numbers);&#125; My Answer 1234567891011121314151617// ä¿®å¤é”™è¯¯ï¼Œä¸è¦æ–°å¢æˆ–åˆ é™¤ä»£ç è¡Œfn main() &#123; let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)]; for name in &amp;names &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, names); let numbers = [1, 2, 3]; // numbersä¸­çš„å…ƒç´ å®ç°äº† Copyï¼Œå› æ­¤æ— éœ€è½¬ç§»æ‰€æœ‰æƒ for n in numbers &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, numbers);&#125; Answer 1234567891011121314151617// ä¿®å¤é”™è¯¯ï¼Œä¸è¦æ–°å¢æˆ–åˆ é™¤ä»£ç è¡Œfn main() &#123; let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)]; for name in &amp;names &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, names); let numbers = [1, 2, 3]; // numbersä¸­çš„å…ƒç´ å®ç°äº† Copyï¼Œå› æ­¤æ— éœ€è½¬ç§»æ‰€æœ‰æƒ for n in numbers &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, numbers);&#125; ğŸŒŸ 12345678fn main() &#123; let a = [4,3,2,1]; // é€šè¿‡ç´¢å¼•å’Œå€¼çš„æ–¹å¼è¿­ä»£æ•°ç»„ `a` for (i,v) in a.__ &#123; println!(&quot;ç¬¬&#123;&#125;ä¸ªå…ƒç´ æ˜¯&#123;&#125;&quot;,i+1,v); &#125;&#125; My Answer 12345678fn main() &#123; let a = [4,3,2,1]; // é€šè¿‡ç´¢å¼•å’Œå€¼çš„æ–¹å¼è¿­ä»£æ•°ç»„ `a` for (i,v) in a.iter().enumerate() &#123; println!(&quot;ç¬¬&#123;&#125;ä¸ªå…ƒç´ æ˜¯&#123;&#125;&quot;,i+1,v); &#125;&#125; Answer 12345678fn main() &#123; let a = [4, 3, 2, 1]; // iterate the indexing and value in &#x27;a&#x27; for (i, v) in a.iter().enumerate() &#123; println!(&quot;The &#123;&#125;th element is &#123;&#125;&quot;, i + 1, v); &#125;&#125; while ğŸŒŸğŸŒŸ å½“æ¡ä»¶ä¸º true æ—¶ï¼Œwhile å°†ä¸€ç›´å¾ªç¯ 12345678910111213141516// å¡«ç©ºï¼Œè®©æœ€åä¸€è¡Œçš„ println! å·¥ä½œ !fn main() &#123; // ä¸€ä¸ªè®¡æ•°å€¼ let mut n = 1; // å½“æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œä¸åœçš„å¾ªç¯ while n __ 10 &#123; if n % 15 == 0 &#123; println!(&quot;fizzbuzz&quot;); &#125; else if n % 3 == 0 &#123; println!(&quot;fizz&quot;); &#125; else if n % 5 == 0 &#123; println!(&quot;buzz&quot;); &#125; else &#123; println!(&quot;&#123;&#125;&quot;, n); &#125; __; &#125; println!(&quot;n çš„å€¼æ˜¯ &#123;&#125;, å¾ªç¯ç»“æŸ&quot;,n); } 123456789101112131415161718192021222324252627- My Answer ```rust // å¡«ç©ºï¼Œè®©æœ€åä¸€è¡Œçš„ println! å·¥ä½œ ! fn main() &#123; // ä¸€ä¸ªè®¡æ•°å€¼ let mut n = 1; // å½“æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œä¸åœçš„å¾ªç¯ while n &lt;= 10 &#123; if n % 15 == 0 &#123; println!(&quot;fizzbuzz&quot;); &#125; else if n % 3 == 0 &#123; println!(&quot;fizz&quot;); &#125; else if n % 5 == 0 &#123; println!(&quot;buzz&quot;); &#125; else &#123; println!(&quot;&#123;&#125;&quot;, n); &#125; n = n+1; &#125; println!(&quot;n çš„å€¼æ˜¯ &#123;&#125;, å¾ªç¯ç»“æŸ&quot;,n); &#125; Answer 123456789101112131415fn main() &#123; // A counter variable let mut n = 1; // Loop while the condition is true while n &lt; 10 &#123; if n % 15 == 0 &#123; println!(&quot;fizzbuzz&quot;); &#125; else if n % 3 == 0 &#123; println!(&quot;fizz&quot;); &#125; else if n % 5 == 0 &#123; println!(&quot;buzz&quot;); &#125; else &#123; println!(&quot;&#123;&#125;&quot;, n); &#125; n += 1; &#125; println!(&quot;n reached &#123;&#125;, soloop is over&quot;, n); } 123456789101112131415161718# continue and break7. ğŸŒŸ ä½¿ç”¨ `break` å¯ä»¥è·³å‡ºå¾ªç¯```rust// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n == 66 &#123; __ &#125; n += 1; &#125; assert_eq!(n, 66);&#125; My Answer 123456789101112// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n == 66 &#123; break; &#125; n += 1; &#125; assert_eq!(n, 66);&#125; Answer 1234567891011fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n == 66 &#123; break; &#125; n += 1; &#125; assert_eq!(n, 66);&#125; ğŸŒŸğŸŒŸ continue ä¼šç»“æŸå½“æ¬¡å¾ªç¯å¹¶ç«‹å³å¼€å§‹ä¸‹ä¸€æ¬¡å¾ªç¯ 1234567891011121314// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n != 66 &#123; n+=1; __; &#125; __ &#125; assert_eq!(n, 66);&#125; My Answer 1234567891011121314// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n != 66 &#123; n+=1; continue; &#125; break; &#125; assert_eq!(n, 66);&#125; Answer 12345678910111213fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n != 66 &#123; n += 1; continue; &#125; break; &#125; assert_eq!(n, 66);&#125; loop ğŸŒŸğŸŒŸ loop ä¸€èˆ¬éƒ½éœ€è¦é…åˆ break æˆ– continue ä¸€èµ·ä½¿ç”¨ã€‚ 12345678910111213141516171819202122232425262728// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn main() &#123; let mut count = 0u32; println!(&quot;Let&#x27;s count until infinity!&quot;); // æ— é™å¾ªç¯ loop &#123; count += 1; if count == 3 &#123; println!(&quot;three&quot;); // è·³è¿‡å½“æ­¤å¾ªç¯çš„å‰©ä½™ä»£ç  __; &#125; println!(&quot;&#123;&#125;&quot;, count); if count == 5 &#123; println!(&quot;OK, that&#x27;s enough&quot;); __; &#125; &#125; assert_eq!(count, 5);&#125; My Answer 12345678910111213141516171819202122232425262728// å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç fn main() &#123; let mut count = 0u32; println!(&quot;Let&#x27;s count until infinity!&quot;); // æ— é™å¾ªç¯ loop &#123; count += 1; if count == 3 &#123; println!(&quot;three&quot;); // è·³è¿‡å½“æ­¤å¾ªç¯çš„å‰©ä½™ä»£ç  continue; &#125; println!(&quot;&#123;&#125;&quot;, count); if count == 5 &#123; println!(&quot;OK, that&#x27;s enough&quot;); break; &#125; &#125; assert_eq!(count, 5);&#125; Answer 123456789101112131415161718192021222324252627fn main() &#123; let mut count = 0u32; println!(&quot;Let&#x27;s count until infinity!&quot;); // Infinite loop loop &#123; count += 1; if count == 3 &#123; println!(&quot;three&quot;); // Skip the rest of this iteration continue; &#125; println!(&quot;&#123;&#125;&quot;, count); if count == 5 &#123; println!(&quot;OK, that&#x27;s enough&quot;); break; &#125; &#125; assert_eq!(count, 5);&#125; ğŸŒŸğŸŒŸ loop æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é…åˆ break æ¥è¿”å›ä¸€ä¸ªå€¼ 1234567891011121314// å¡«ç©ºfn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; __; &#125; &#125;; assert_eq!(result, 20);&#125; My Answer 1234567891011121314// å¡«ç©ºfn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter*2; &#125; &#125;; assert_eq!(result, 20);&#125; Answer 12345678910111213fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2; &#125; &#125;; assert_eq!(result, 20);&#125; ğŸŒŸğŸŒŸğŸŒŸ å½“æœ‰å¤šå±‚å¾ªç¯æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨ continue æˆ– break æ¥æ§åˆ¶å¤–å±‚çš„å¾ªç¯ã€‚è¦å®ç°è¿™ä¸€ç‚¹ï¼Œå¤–éƒ¨çš„å¾ªç¯å¿…é¡»æ‹¥æœ‰ä¸€ä¸ªæ ‡ç­¾ &#39;label, ç„¶ååœ¨ break æˆ– continue æ—¶æŒ‡å®šè¯¥æ ‡ç­¾ 12345678910111213141516171819202122232425// å¡«ç©ºfn main() &#123; let mut count = 0; &#x27;outer: loop &#123; &#x27;inner1: loop &#123; if count &gt;= 20 &#123; // è¿™åªä¼šè·³å‡º inner1 å¾ªç¯ break &#x27;inner1; // è¿™é‡Œä½¿ç”¨ `break` ä¹Ÿæ˜¯ä¸€æ ·çš„ &#125; count += 2; &#125; count += 5; &#x27;inner2: loop &#123; if count &gt;= 30 &#123; break &#x27;outer; &#125; continue &#x27;outer; &#125; &#125; assert!(count == __)&#125; My Answer 12345678910111213141516171819202122232425// å¡«ç©ºfn main() &#123; let mut count = 0; &#x27;outer: loop &#123; &#x27;inner1: loop &#123; if count &gt;= 20 &#123; // è¿™åªä¼šè·³å‡º inner1 å¾ªç¯ break &#x27;inner1; // è¿™é‡Œä½¿ç”¨ `break` ä¹Ÿæ˜¯ä¸€æ ·çš„ &#125; count += 2; &#125; count += 5; &#x27;inner2: loop &#123; if count &gt;= 30 &#123; break &#x27;outer; &#125; continue &#x27;outer; &#125; &#125; assert!(count == 30)&#125; Answer 1234567891011121314151617181920212223242526fn main() &#123; let mut count = 0; &#x27;outer: loop &#123; &#x27;inner1: loop &#123; if count &gt;= 20 &#123; // This would break only the inner1 loop break &#x27;inner1; // `break` is also ok &#125; count += 2; &#125; count += 5; &#x27;inner2: loop &#123; if count &gt;= 30 &#123; // This breaks the outer loop break &#x27;outer; &#125; // This will continue the outer loop continue &#x27;outer; &#125; &#125; assert!(count == 30)&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 4 å¤åˆç±»å‹","slug":"Rustå­¦ä¹ -ç»ƒä¹ 4-å¤åˆç±»å‹","date":"2023-09-02T12:07:46.000Z","updated":"2023-09-10T07:58:32.337Z","comments":true,"path":"2023/09/02/Rustå­¦ä¹ -ç»ƒä¹ 4-å¤åˆç±»å‹/","link":"","permalink":"http://example.com/2023/09/02/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A04-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"å¤åˆç±»å‹ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) å­—ç¬¦ä¸²å­—ç¬¦ä¸²å­—é¢é‡çš„ç±»å‹æ˜¯ &amp;strï¼Œ ä¾‹å¦‚ let s: &amp;str = &quot;hello, world&quot; ä¸­çš„ &quot;hello, world&quot; çš„ç±»å‹å°±æ˜¯ &amp;strã€‚","text":"å¤åˆç±»å‹ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) å­—ç¬¦ä¸²å­—ç¬¦ä¸²å­—é¢é‡çš„ç±»å‹æ˜¯ &amp;strï¼Œ ä¾‹å¦‚ let s: &amp;str = &quot;hello, world&quot; ä¸­çš„ &quot;hello, world&quot; çš„ç±»å‹å°±æ˜¯ &amp;strã€‚ strå’Œ&amp;str ğŸŒŸ æ­£å¸¸æƒ…å†µä¸‹æˆ‘ä»¬æ— æ³•ä½¿ç”¨ str ç±»å‹ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨ &amp;str æ¥æ›¿ä»£ 1234// ä¿®å¤é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œfn main() &#123; let s: str = &quot;hello, world&quot;;&#125; My Answer 1234// ä¿®å¤é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œfn main() &#123; let s: &amp;str = &quot;hello, world&quot;;&#125; Answer 123fn main() &#123; let s: &amp;str = &quot;hello, world&quot;; &#125; ğŸŒŸğŸŒŸ å¦‚æœè¦ä½¿ç”¨ str ç±»å‹ï¼Œåªèƒ½é…åˆ Boxã€‚ &amp; å¯ä»¥ç”¨æ¥å°† Box&lt;str&gt; è½¬æ¢ä¸º &amp;str ç±»å‹ 123456789// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•æ¥ä¿®å¤é”™è¯¯fn main() &#123; let s: Box&lt;str&gt; = &quot;hello, world&quot;.into(); greetings(s)&#125;fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 123456789// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•æ¥ä¿®å¤é”™è¯¯fn main() &#123; let s: Box&lt;str&gt; = &quot;hello, world&quot;.into(); greetings(&amp;s)&#125;fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; Answer 12345678fn main() &#123; let s: Box&lt;str&gt; = &quot;hello, world&quot;.into(); greetings(&amp;s) &#125; fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;,s) &#125; 12345678fn main() &#123; let s: Box&lt;&amp;str&gt; = &quot;hello, world&quot;.into(); greetings(*s)&#125;fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;, s);&#125; stringString æ˜¯å®šä¹‰åœ¨æ ‡å‡†åº“ä¸­çš„ç±»å‹ï¼Œåˆ†é…åœ¨å †ä¸Šï¼Œå¯ä»¥åŠ¨æ€çš„å¢é•¿ã€‚å®ƒçš„åº•å±‚å­˜å‚¨æ˜¯åŠ¨æ€å­—èŠ‚æ•°ç»„çš„æ–¹å¼( Vec&lt;u8&gt; )ï¼Œä½†æ˜¯ä¸å­—èŠ‚æ•°ç»„ä¸åŒï¼ŒString æ˜¯ UTF-8 ç¼–ç ã€‚ ğŸŒŸ 12345678// å¡«ç©ºfn main() &#123; let mut s = __; s.push_str(&quot;hello, world&quot;); s.push(&#x27;!&#x27;); assert_eq!(s, &quot;hello, world!&quot;);&#125; My Answer 12345678// å¡«ç©ºfn main() &#123; let mut s = String::from(&quot;&quot;); s.push_str(&quot;hello, world&quot;); s.push(&#x27;!&#x27;); assert_eq!(s, &quot;hello, world!&quot;);&#125; Answer 1234567fn main() &#123; let mut s = String::new(); s.push_str(&quot;hello, world&quot;); s.push(&#x27;!&#x27;); assert_eq!(s, &quot;hello, world!&quot;); &#125; ğŸŒŸğŸŒŸğŸŒŸ 123456789// ä¿®å¤æ‰€æœ‰é”™è¯¯ï¼Œå¹¶ä¸”ä¸è¦æ–°å¢ä»£ç è¡Œfn main() &#123; let s = String::from(&quot;hello&quot;); s.push(&#x27;,&#x27;); s.push(&quot; world&quot;); s += &quot;!&quot;.to_string(); println!(&quot;&#123;&#125;&quot;, s)&#125; My Answer 123456789// ä¿®å¤æ‰€æœ‰é”™è¯¯ï¼Œå¹¶ä¸”ä¸è¦æ–°å¢ä»£ç è¡Œfn main() &#123; let mut s = String::from(&quot;hello&quot;); s.push(&#x27;,&#x27;); s.push_str(&quot; world&quot;); s += &quot;!&quot;; println!(&quot;&#123;&#125;&quot;, s)&#125; Answer 12345678fn main() &#123; let mut s = String::from(&quot;hello&quot;); s.push(&#x27;,&#x27;); s.push_str(&quot; world&quot;); s += &quot;!&quot;; println!(&quot;&#123;&#125;&quot;, s) &#125; ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ç”¨ replace æ–¹æ³•æ¥æ›¿æ¢æŒ‡å®šçš„å­å­—ç¬¦ä¸² 12345678// å¡«ç©ºfn main() &#123; let s = String::from(&quot;I like dogs&quot;); // ä»¥ä¸‹æ–¹æ³•ä¼šé‡æ–°åˆ†é…ä¸€å—å†…å­˜ç©ºé—´ï¼Œç„¶åå°†ä¿®æ”¹åçš„å­—ç¬¦ä¸²å­˜åœ¨è¿™é‡Œ let s1 = s.__(&quot;dogs&quot;, &quot;cats&quot;); assert_eq!(s1, &quot;I like cats&quot;)&#125; My Answer 12345678// å¡«ç©ºfn main() &#123; let s = String::from(&quot;I like dogs&quot;); // ä»¥ä¸‹æ–¹æ³•ä¼šé‡æ–°åˆ†é…ä¸€å—å†…å­˜ç©ºé—´ï¼Œç„¶åå°†ä¿®æ”¹åçš„å­—ç¬¦ä¸²å­˜åœ¨è¿™é‡Œ let s1 = s.replace(&quot;dogs&quot;, &quot;cats&quot;); assert_eq!(s1, &quot;I like cats&quot;)&#125; Answer 1234567fn main() &#123; let s = String::from(&quot;I like dogs&quot;); // Allocate new memory and store the modified string there let s1 = s.replace(&quot;dogs&quot;, &quot;cats&quot;); assert_eq!(s1, &quot;I like cats&quot;) &#125; åœ¨æ ‡å‡†åº“çš„ String æ¨¡å—ä¸­ï¼Œæœ‰æ›´å¤šçš„å®ç”¨æ–¹æ³•ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥çœ‹çœ‹ã€‚ ğŸŒŸğŸŒŸ ä½ åªèƒ½å°† String è·Ÿ &amp;str ç±»å‹è¿›è¡Œæ‹¼æ¥ï¼Œå¹¶ä¸” String çš„æ‰€æœ‰æƒåœ¨æ­¤è¿‡ç¨‹ä¸­ä¼šè¢« move 12345678// ä¿®å¤æ‰€æœ‰é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä¸€è¡Œä»£ç fn main() &#123; let s1 = String::from(&quot;hello,&quot;); let s2 = String::from(&quot;world!&quot;); let s3 = s1 + s2; assert_eq!(s3,&quot;hello,world!&quot;); println!(&quot;&#123;&#125;&quot;,s1);&#125; My Answer 12345678// ä¿®å¤æ‰€æœ‰é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä¸€è¡Œä»£ç fn main() &#123; let s1 = String::from(&quot;hello,&quot;); let s2 = String::from(&quot;world!&quot;); let s3 = s1 + &amp;s2; assert_eq!(s3,&quot;hello,world!&quot;); println!(&quot;&#123;&#125;&quot;,s3);&#125; Answer 1234567fn main() &#123; let s1 = String::from(&quot;hello,&quot;); let s2 = String::from(&quot;world!&quot;); let s3 = s1.clone() + &amp;s2; assert_eq!(s3,&quot;hello,world!&quot;); println!(&quot;&#123;&#125;&quot;,s1);&#125; &amp;strå’ŒStringä¸ str çš„å¾ˆå°‘ä½¿ç”¨ç›¸æ¯”ï¼Œ&amp;str å’Œ String ç±»å‹å´éå¸¸å¸¸ç”¨ï¼Œå› æ­¤ä¹Ÿéå¸¸é‡è¦ã€‚ ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤ç§æ–¹æ³•å°† &amp;str è½¬æ¢æˆ String ç±»å‹ 123456789// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•æ¥ä¿®å¤é”™è¯¯fn main() &#123; let s = &quot;hello, world&quot;; greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 123456789// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•æ¥ä¿®å¤é”™è¯¯fn main() &#123; let s = &quot;hello, world&quot;; greetings(s.to_string())&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 123456789// ä½¿ç”¨è‡³å°‘ä¸¤ç§æ–¹æ³•æ¥ä¿®å¤é”™è¯¯fn main() &#123; let s = String::from(&quot;hello, world&quot;); greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; Answer 12345678fn main() &#123; let s = &quot;hello, world&quot;.to_string(); greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 12345678fn main() &#123; let s = String::from(&quot;hello, world&quot;); greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ String::from æˆ– to_string å°† &amp;str è½¬æ¢æˆ String ç±»å‹ 12345// ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥è§£å†³é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œfn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = s;&#125; My Answer 12345// ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥è§£å†³é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œfn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = &amp;s;&#125; 12345// ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥è§£å†³é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œfn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = &amp;s[..];&#125; Answer 1234fn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = &amp;s;&#125; 1234fn main() &#123; let s = &quot;hello, world&quot;; let s1: &amp;str = s;&#125; 1234fn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: String = s;&#125; å­—ç¬¦ä¸²è½¬ä¹‰ ğŸŒŸ 1234567891011121314151617181920fn main() &#123; // ä½ å¯ä»¥ä½¿ç”¨è½¬ä¹‰çš„æ–¹å¼æ¥è¾“å‡ºæƒ³è¦çš„å­—ç¬¦ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨åå…­è¿›åˆ¶çš„å€¼ï¼Œä¾‹å¦‚ \\x73 ä¼šè¢«è½¬ä¹‰æˆå°å†™å­—æ¯ &#x27;s&#x27; // å¡«ç©ºä»¥è¾“å‡º &quot;I&#x27;m writing Rust&quot; let byte_escape = &quot;I&#x27;m writing Ru\\x73__!&quot;; println!(&quot;What are you doing\\x3F (\\\\x3F means ?) &#123;&#125;&quot;, byte_escape); // ä¹Ÿå¯ä»¥ä½¿ç”¨ Unicode å½¢å¼çš„è½¬ä¹‰å­—ç¬¦ let unicode_codepoint = &quot;\\u&#123;211D&#125;&quot;; let character_name = &quot;\\&quot;DOUBLE-STRUCK CAPITAL R\\&quot;&quot;; println!(&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;, unicode_codepoint, character_name ); // è¿˜èƒ½ä½¿ç”¨ \\ æ¥è¿æ¥å¤šè¡Œå­—ç¬¦ä¸² let long_string = &quot;String literals can span multiple lines. The linebreak and indentation here \\ can be escaped too!&quot;; println!(&quot;&#123;&#125;&quot;, long_string);&#125; ğŸŒŸğŸŒŸğŸŒŸ æœ‰æ—¶å€™éœ€è¦è½¬ä¹‰çš„å­—ç¬¦å¾ˆå¤šï¼Œæˆ‘ä»¬ä¼šå¸Œæœ›ä½¿ç”¨æ›´æ–¹ä¾¿çš„æ–¹å¼æ¥ä¹¦å†™å­—ç¬¦ä¸²: raw string. 123456789101112131415161718/* å¡«ç©ºå¹¶ä¿®å¤æ‰€æœ‰é”™è¯¯ */fn main() &#123; let raw_str = r&quot;Escapes don&#x27;t work here: \\x3F \\u&#123;211D&#125;&quot;; // ä¿®æ”¹ä¸Šé¢çš„è¡Œè®©ä»£ç å·¥ä½œ assert_eq!(raw_str, &quot;Escapes don&#x27;t work here: ? â„&quot;); // å¦‚æœä½ å¸Œæœ›åœ¨å­—ç¬¦ä¸²ä¸­ä½¿ç”¨åŒå¼•å·ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å½¢å¼ let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#; println!(&quot;&#123;&#125;&quot;, quotes); // å¦‚æœå¸Œæœ›åœ¨å­—ç¬¦ä¸²ä¸­ä½¿ç”¨ # å·ï¼Œå¯ä»¥å¦‚ä¸‹ä½¿ç”¨ï¼š let delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###; println!(&quot;&#123;&#125;&quot;, delimiter); // å¡«ç©º let long_delimiter = __; assert_eq!(long_delimiter, &quot;Hello, \\&quot;##\\&quot;&quot;)&#125; å­—èŠ‚å­—ç¬¦ä¸²æƒ³è¦ä¸€ä¸ªé UTF-8 å½¢å¼çš„å­—ç¬¦ä¸²å—(æˆ‘ä»¬ä¹‹å‰çš„ str, &amp;str, String éƒ½æ˜¯ UTF-8 å­—ç¬¦ä¸²) ? å¯ä»¥è¯•è¯•å­—èŠ‚å­—ç¬¦ä¸²æˆ–è€…è¯´å­—èŠ‚æ•°ç»„: ç¤ºä¾‹: 1234567891011121314151617181920212223242526272829303132333435363738use std::str;fn main() &#123; // æ³¨æ„ï¼Œè¿™å¹¶ä¸æ˜¯ `&amp;str` ç±»å‹äº†ï¼ let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;; // å­—èŠ‚æ•°ç»„æ²¡æœ‰å®ç° `Display` ç‰¹å¾ï¼Œå› æ­¤åªèƒ½ä½¿ç”¨ `Debug` çš„æ–¹å¼å»æ‰“å° println!(&quot;A byte string: &#123;:?&#125;&quot;, bytestring); // å­—èŠ‚æ•°ç»„ä¹Ÿå¯ä»¥ä½¿ç”¨è½¬ä¹‰ let escaped = b&quot;\\x52\\x75\\x73\\x74 as bytes&quot;; // ...ä½†æ˜¯ä¸æ”¯æŒ unicode è½¬ä¹‰ // let escaped = b&quot;\\u&#123;211D&#125; is not allowed&quot;; println!(&quot;Some escaped bytes: &#123;:?&#125;&quot;, escaped); // raw string let raw_bytestring = br&quot;\\u&#123;211D&#125; is not escaped here&quot;; println!(&quot;&#123;:?&#125;&quot;, raw_bytestring); // å°†å­—èŠ‚æ•°ç»„è½¬æˆ `str` ç±»å‹å¯èƒ½ä¼šå¤±è´¥ if let Ok(my_str) = str::from_utf8(raw_bytestring) &#123; println!(&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;, my_str); &#125; let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \\ like with normal raw strings&quot;#; // å­—èŠ‚æ•°ç»„å¯ä»¥ä¸æ˜¯ UTF-8 æ ¼å¼ let shift_jis = b&quot;\\x82\\xe6\\x82\\xa8\\x82\\xb1\\x82\\xbb&quot;; // &quot;ã‚ˆã†ã“ã&quot; in SHIFT-JIS // ä½†æ˜¯å®ƒä»¬æœªå¿…èƒ½è½¬æ¢æˆ `str` ç±»å‹ match str::from_utf8(shift_jis) &#123; Ok(my_str) =&gt; println!(&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;, my_str), Err(e) =&gt; println!(&quot;Conversion failed: &#123;:?&#125;&quot;, e), &#125;;&#125; å¦‚æœå¤§å®¶æƒ³è¦äº†è§£æ›´å¤šå…³äºå­—ç¬¦ä¸²å­—é¢é‡ã€è½¬ä¹‰å­—ç¬¦çš„è¯ï¼Œå¯ä»¥çœ‹çœ‹ Rust Reference çš„ â€˜Tokensâ€™ ç« èŠ‚. å­—ç¬¦ä¸²ç´¢å¼•string index ğŸŒŸğŸŒŸ ä½ æ— æ³•é€šè¿‡ç´¢å¼•çš„æ–¹å¼å»è®¿é—®å­—ç¬¦ä¸²ä¸­çš„æŸä¸ªå­—ç¬¦ï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨åˆ‡ç‰‡çš„æ–¹å¼ &amp;s1[start..end] ï¼Œä½†æ˜¯start å’Œ end å¿…é¡»å‡†ç¡®è½åœ¨å­—ç¬¦çš„è¾¹ç•Œå¤„. 12345678fn main() &#123; let s1 = String::from(&quot;hi,ä¸­å›½&quot;); let h = s1[0]; // ä¿®æ”¹å½“å‰è¡Œæ¥ä¿®å¤é”™è¯¯ï¼Œæç¤º: `h` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­åªéœ€è¦ 1 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º assert_eq!(h, &quot;h&quot;); let h1 = &amp;s1[3..5];// ä¿®æ”¹å½“å‰è¡Œæ¥ä¿®å¤é”™è¯¯ï¼Œæç¤º: `ä¸­` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­éœ€è¦ 3 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º assert_eq!(h1, &quot;ä¸­&quot;);&#125; My Answer 12345678fn main() &#123; let s1 = String::from(&quot;hi,ä¸­å›½&quot;); let h = &amp;s1[0..1]; // ä¿®æ”¹å½“å‰è¡Œæ¥ä¿®å¤é”™è¯¯ï¼Œæç¤º: `h` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­åªéœ€è¦ 1 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º assert_eq!(h, &quot;h&quot;); let h1 = &amp;s1[3..6];// ä¿®æ”¹å½“å‰è¡Œæ¥ä¿®å¤é”™è¯¯ï¼Œæç¤º: `ä¸­` å­—ç¬¦åœ¨ UTF-8 æ ¼å¼ä¸­éœ€è¦ 3 ä¸ªå­—èŠ‚æ¥è¡¨ç¤º assert_eq!(h1, &quot;ä¸­&quot;);&#125; Answer 12345678fn main() &#123; let s1 = String::from(&quot;hi,ä¸­å›½&quot;); let h = &amp;s1[0..1]; assert_eq!(h, &quot;h&quot;); let h1 = &amp;s1[3..6]; assert_eq!(h1, &quot;ä¸­&quot;);&#125; æ“ä½œUTF-8å­—ç¬¦ä¸² ğŸŒŸ 123456fn main() &#123; // å¡«ç©ºï¼Œæ‰“å°å‡º &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot; ä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦ for c in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;.__ &#123; println!(&quot;&#123;&#125;&quot;, c) &#125;&#125; My Answer 123456fn main() &#123; // å¡«ç©ºï¼Œæ‰“å°å‡º &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot; ä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦ for c in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;.chars() &#123; println!(&quot;&#123;&#125;&quot;, c) &#125;&#125; Answer 12345fn main() &#123; for c in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;.chars() &#123; println!(&quot;&#123;&#125;&quot;, c) &#125;&#125; åˆ‡ç‰‡åˆ‡ç‰‡è·Ÿæ•°ç»„ç›¸ä¼¼ï¼Œä½†æ˜¯åˆ‡ç‰‡çš„é•¿åº¦æ— æ³•åœ¨ç¼–è¯‘æœŸå¾—çŸ¥ï¼Œå› æ­¤ä½ æ— æ³•ç›´æ¥ä½¿ç”¨åˆ‡ç‰‡ç±»å‹ã€‚ ğŸŒŸğŸŒŸ è¿™é‡Œ, [i32] å’Œ str éƒ½æ˜¯åˆ‡ç‰‡ç±»å‹ï¼Œä½†æ˜¯ç›´æ¥ä½¿ç”¨å®ƒä»¬ä¼šé€ æˆç¼–è¯‘é”™è¯¯ï¼Œå¦‚ä¸‹ä»£ç æ‰€ç¤ºã€‚ä¸ºäº†è§£å†³ï¼Œä½ éœ€è¦ä½¿ç”¨åˆ‡ç‰‡çš„å¼•ç”¨ï¼š &amp;[i32]ï¼Œ&amp;strã€‚ 1234567// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œ!fn main() &#123; let arr = [1, 2, 3]; let s1: [i32] = arr[0..2]; let s2: str = &quot;hello, world&quot; as str;&#125; My Answer 1234567// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯ï¼Œä¸è¦æ–°å¢ä»£ç è¡Œ!fn main() &#123; let arr = [1, 2, 3]; let s1: &amp;[i32] = &amp;arr[0..2]; let s2: &amp;str = &quot;hello, world&quot; as &amp;str;&#125; Answer 123456fn main() &#123; let arr = [1, 2, 3]; let s1: &amp;[i32] = &amp;arr[0..2]; let s2: &amp;str = &quot;hello, world&quot;;&#125; ä¸€ä¸ªåˆ‡ç‰‡å¼•ç”¨å ç”¨äº†2ä¸ªå­—å¤§å°çš„å†…å­˜ç©ºé—´( ä»ç°åœ¨å¼€å§‹ï¼Œä¸ºäº†ç®€æ´æ€§è€ƒè™‘ï¼Œå¦‚æ— ç‰¹æ®ŠåŸå› ï¼Œæˆ‘ä»¬ç»Ÿä¸€ä½¿ç”¨åˆ‡ç‰‡æ¥ç‰¹æŒ‡åˆ‡ç‰‡å¼•ç”¨ )ã€‚ è¯¥åˆ‡ç‰‡çš„ç¬¬ä¸€ä¸ªå­—æ˜¯æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆï¼Œç¬¬äºŒä¸ªå­—æ˜¯åˆ‡ç‰‡çš„é•¿åº¦ã€‚å­—çš„å¤§å°å–å†³äºå¤„ç†å™¨æ¶æ„ï¼Œä¾‹å¦‚åœ¨ x86-64 ä¸Šï¼Œå­—çš„å¤§å°æ˜¯ 64 ä½ä¹Ÿå°±æ˜¯ 8 ä¸ªå­—èŠ‚ï¼Œé‚£ä¹ˆä¸€ä¸ªåˆ‡ç‰‡å¼•ç”¨å°±æ˜¯ 16 ä¸ªå­—èŠ‚å¤§å°ã€‚ åˆ‡ç‰‡( å¼•ç”¨ )å¯ä»¥ç”¨æ¥å€Ÿç”¨æ•°ç»„çš„æŸä¸ªè¿ç»­çš„éƒ¨åˆ†ï¼Œå¯¹åº”çš„ç­¾åæ˜¯ &amp;[T]ï¼Œå¤§å®¶å¯ä»¥ä¸æ•°ç»„çš„ç­¾åå¯¹æ¯”ä¸‹ [T; Length]ã€‚ ğŸŒŸğŸŒŸğŸŒŸ 123456789fn main() &#123; let arr: [char; 3] = [&#x27;ä¸­&#x27;, &#x27;å›½&#x27;, &#x27;äºº&#x27;]; let slice = &amp;arr[..2]; // ä¿®æ”¹æ•°å­— `8` è®©ä»£ç å·¥ä½œ // å°æç¤º: åˆ‡ç‰‡å’Œæ•°ç»„ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯å¼•ç”¨ã€‚å¦‚æœæ˜¯æ•°ç»„çš„è¯ï¼Œé‚£ä¸‹é¢çš„ `assert!` å°†ä¼šé€šè¿‡ï¼š &#x27;ä¸­&#x27;å’Œ&#x27;å›½&#x27;æ˜¯charç±»å‹ï¼Œcharç±»å‹æ˜¯Unicodeç¼–ç ï¼Œå¤§å°å›ºå®šä¸º4å­—èŠ‚ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸º8å­—èŠ‚ã€‚ assert!(std::mem::size_of_val(&amp;slice) == 8);&#125; My Answer 12345678fn main() &#123; let arr: [char; 3] = [&#x27;ä¸­&#x27;, &#x27;å›½&#x27;, &#x27;äºº&#x27;]; let slice = &amp;arr[..2]; // TIPS: slice( reference ) IS NOT an array, because if it is, then `assert!` will passed: each of the two UTF-8 chars &#x27;ä¸­&#x27; and &#x27;å›½&#x27; occupies 4 bytes, 2 * 4 = 8 assert!(std::mem::size_of_val(&amp;slice) == 16);&#125; Answer 12345678fn main() &#123; let arr: [char; 3] = [&#x27;ä¸­&#x27;, &#x27;å›½&#x27;, &#x27;äºº&#x27;]; let slice = &amp;arr[..2]; // TIPS: slice( reference ) IS NOT an array, because if it is, then `assert!` will passed: each of the two UTF-8 chars &#x27;ä¸­&#x27; and &#x27;å›½&#x27; occupies 4 bytes, 2 * 4 = 8 assert!(std::mem::size_of_val(&amp;slice) == 16);&#125; ğŸŒŸğŸŒŸ 123456fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; // å¡«ç©ºè®©ä»£ç å·¥ä½œèµ·æ¥ let slice: __ = __; assert_eq!(slice, &amp;[2, 3, 4]);&#125; My Answer 123456fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; // å¡«ç©ºè®©ä»£ç å·¥ä½œèµ·æ¥ let slice: &amp;[i32]= &amp;arr[1..4]; assert_eq!(slice, &amp;[2, 3, 4]);&#125; Answer 12345fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; let slice: &amp;[i32] = &amp;arr[1..4]; assert_eq!(slice, &amp;[2, 3, 4]);&#125; å­—ç¬¦ä¸²åˆ‡ç‰‡ ğŸŒŸ 123456789fn main() &#123; let s = String::from(&quot;hello&quot;); let slice1 = &amp;s[0..2]; // å¡«ç©ºï¼Œä¸è¦å†ä½¿ç”¨ 0..2 let slice2 = &amp;s[__]; assert_eq!(slice1, slice2);&#125; My Answer 123456789fn main() &#123; let s = String::from(&quot;hello&quot;); let slice1 = &amp;s[0..2]; // å¡«ç©ºï¼Œä¸è¦å†ä½¿ç”¨ 0..2 let slice2 = &amp;s[..2]; assert_eq!(slice1, slice2);&#125; Answer 12345678fn main() &#123; let s = String::from(&quot;hello&quot;); let slice1 = &amp;s[0..2]; let slice2 = &amp;s[..2]; assert_eq!(slice1, slice2);&#125; ğŸŒŸ 1234567fn main() &#123; let s = &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;; // ä¿®æ”¹ä»¥ä¸‹ä»£ç è¡Œï¼Œè®©ä»£ç å·¥ä½œèµ·æ¥ let slice = &amp;s[0..2]; assert!(slice == &quot;ä½ &quot;);&#125; My Answer 1234567fn main() &#123; let s = &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;; // ä¿®æ”¹ä»¥ä¸‹ä»£ç è¡Œï¼Œè®©ä»£ç å·¥ä½œèµ·æ¥ let slice = &amp;s[0..3]; assert!(slice == &quot;ä½ &quot;);&#125; Answer 123456fn main() &#123; let s = &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;; let slice = &amp;s[0..3]; assert!(slice == &quot;ä½ &quot;);&#125; ğŸŒŸğŸŒŸ &amp;String å¯ä»¥è¢«éšå¼åœ°è½¬æ¢æˆ &amp;str ç±»å‹. 123456789101112131415// ä¿®å¤æ‰€æœ‰é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello world&quot;); // è¿™é‡Œ, &amp;s æ˜¯ `&amp;String` ç±»å‹ï¼Œä½†æ˜¯ `first_character` å‡½æ•°éœ€è¦çš„æ˜¯ `&amp;str` ç±»å‹ã€‚ // å°½ç®¡ä¸¤ä¸ªç±»å‹ä¸ä¸€æ ·ï¼Œä½†æ˜¯ä»£ç ä»ç„¶å¯ä»¥å·¥ä½œï¼ŒåŸå› æ˜¯ `&amp;String` ä¼šè¢«éšå¼åœ°è½¬æ¢æˆ `&amp;str` ç±»å‹ï¼Œå¦‚æœå¤§å®¶æƒ³è¦çŸ¥é“æ›´å¤šï¼Œå¯ä»¥çœ‹çœ‹ Deref ç« èŠ‚: https://course.rs/advance/smart-pointer/deref.html let ch = first_character(&amp;s); s.clear(); // error! println!(&quot;the first character is: &#123;&#125;&quot;, ch);&#125;fn first_character(s: &amp;str) -&gt; &amp;str &#123; &amp;s[..1]&#125; My Answerï¼ˆé‡è¦ï¼‰ 123456789101112131415// ä¿®å¤æ‰€æœ‰é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello world&quot;); // è¿™é‡Œ, &amp;s æ˜¯ `&amp;String` ç±»å‹ï¼Œä½†æ˜¯ `first_character` å‡½æ•°éœ€è¦çš„æ˜¯ `&amp;str` ç±»å‹ã€‚ // å°½ç®¡ä¸¤ä¸ªç±»å‹ä¸ä¸€æ ·ï¼Œä½†æ˜¯ä»£ç ä»ç„¶å¯ä»¥å·¥ä½œï¼ŒåŸå› æ˜¯ `&amp;String` ä¼šè¢«éšå¼åœ°è½¬æ¢æˆ `&amp;str` ç±»å‹ï¼Œå¦‚æœå¤§å®¶æƒ³è¦çŸ¥é“æ›´å¤šï¼Œå¯ä»¥çœ‹çœ‹ Deref ç« èŠ‚: https://course.rs/advance/smart-pointer/deref.html let ch = first_character(&amp;s); println!(&quot;the first character is: &#123;&#125;&quot;, ch); s.clear(); // error!&#125;fn first_character(s: &amp;str) -&gt; &amp;str &#123; &amp;s[..1]&#125; Answer 123456789101112131415fn main() &#123; let mut s = String::from(&quot;hello world&quot;); // here, &amp;s is `&amp;String` type, but `first_word` need a `&amp;str` type. // it works because `&amp;String` can be implicitly converted to `&amp;str, If you want know more ,this is called `Deref` let word = first_word(&amp;s); println!(&quot;the first word is: &#123;&#125;&quot;, word); s.clear();&#125;fn first_word(s: &amp;str) -&gt; &amp;str &#123; &amp;s[..1]&#125; Stringstd::string::String æ˜¯ UTF-8 ç¼–ç ã€å¯å¢é•¿çš„åŠ¨æ€å­—ç¬¦ä¸². å®ƒä¹Ÿæ˜¯æˆ‘ä»¬æ—¥å¸¸å¼€å‘ä¸­æœ€å¸¸ç”¨çš„å­—ç¬¦ä¸²ç±»å‹ï¼ŒåŒæ—¶å¯¹äºå®ƒæ‰€æ‹¥æœ‰çš„å†…å®¹æ‹¥æœ‰æ‰€æœ‰æƒã€‚ åŸºæœ¬æ“ä½œ ğŸŒŸğŸŒŸ 123456789101112131415161718// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯// 1. ä¸è¦ä½¿ç”¨ `to_string()`// 2. ä¸è¦æ·»åŠ /åˆ é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let mut s: String = &quot;hello, &quot;; s.push_str(&quot;world&quot;.to_string()); s.push(__); move_ownership(s); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125;fn move_ownership(s: String) &#123; println!(&quot;ownership of \\&quot;&#123;&#125;\\&quot; is moved here!&quot;, s)&#125; My Answer 123456789101112131415161718// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯// 1. ä¸è¦ä½¿ç”¨ `to_string()`// 2. ä¸è¦æ·»åŠ /åˆ é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let mut s: String = String::from(&quot;hello, &quot;); s.push_str(&quot;world&quot;); s.push(&#x27;!&#x27;); move_ownership(s.clone()); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125;fn move_ownership(s: String) &#123; println!(&quot;ownership of \\&quot;&#123;&#125;\\&quot; is moved here!&quot;, s)&#125; Answer 123456789101112131415fn main() &#123; let mut s: String = String::from(&quot;hello, &quot;); s.push_str(&quot;world&quot;); s.push(&#x27;!&#x27;); move_ownership(s.clone()); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125;fn move_ownership(s: String) &#123; println!(&quot;ownership of \\&quot;&#123;&#125;\\&quot; is moved here!&quot;, s)&#125; String and &amp;strè™½ç„¶ String çš„åº•å±‚æ˜¯ Vec&lt;u8&gt; ä¹Ÿå°±æ˜¯å­—èŠ‚æ•°ç»„çš„å½¢å¼å­˜å‚¨çš„ï¼Œä½†æ˜¯å®ƒæ˜¯åŸºäº UTF-8 ç¼–ç çš„å­—ç¬¦åºåˆ—ã€‚String åˆ†é…åœ¨å †ä¸Šã€å¯å¢é•¿ä¸”ä¸æ˜¯ä»¥ null ç»“å°¾ã€‚ è€Œ &amp;str æ˜¯åˆ‡ç‰‡å¼•ç”¨ç±»å‹( &amp;[u8] )ï¼ŒæŒ‡å‘ä¸€ä¸ªåˆæ³•çš„ UTF-8 å­—ç¬¦åºåˆ—ï¼Œæ€»ä¹‹ï¼Œ&amp;str å’Œ String çš„å…³ç³»ç±»ä¼¼äº &amp;[T] å’Œ Vec&lt;T&gt; ã€‚ å¦‚æœå¤§å®¶æƒ³äº†è§£æ›´å¤šï¼Œå¯ä»¥çœ‹çœ‹æ˜“æ··æ·†æ¦‚å¿µè§£æ - &amp;str å’Œ Stringã€‚ ğŸŒŸğŸŒŸ 12345678910111213141516// å¡«ç©ºfn main() &#123; let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = __; // ä½¿ç”¨ä¸¤ç§æ–¹æ³• assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = __; assert_eq!(slice2, &quot;hello&quot;); let slice3: __ = __; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516// å¡«ç©ºfn main() &#123; let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = &amp;s; // ä½¿ç”¨ä¸¤ç§æ–¹æ³• assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = &amp;s[..5]; assert_eq!(slice2, &quot;hello&quot;); let slice3:&amp;mut String = &amp;mut s; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819// FILL in the blanksfn main() &#123; // get a slice of String with reference: String -&gt; &amp;str let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = &amp;s; // in two ways assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = &amp;s[0..5]; assert_eq!(slice2, &quot;hello&quot;); //Note! The type here cant be `&amp;mut str` due to `push` is ONLY defined on String type and its mut reference: `&amp;mut String` ! // So you can&#x27;t use `s.as_mut_str()` let slice3: &amp;mut String = &amp;mut s; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; 1234567891011121314151617fn main() &#123; let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = s.as_str(); assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = &amp;s[0..5]; assert_eq!(slice2, &quot;hello&quot;); //Note! The type here cant be `&amp;mut str` due to `push` is ONLY defined on String type and its mut reference: `&amp;mut String` ! // So you can&#x27;t use `s.as_mut_str()` let slice3: &amp;mut String = &amp;mut s; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617// é—®é¢˜: æˆ‘ä»¬çš„ä»£ç ä¸­å‘ç”Ÿäº†å¤šå°‘æ¬¡å †å†…å­˜åˆ†é…ï¼Ÿ// ä½ çš„å›ç­”: fn main() &#123; // åŸºäº `&amp;str` ç±»å‹åˆ›å»ºä¸€ä¸ª String, // å­—ç¬¦ä¸²å­—é¢é‡çš„ç±»å‹æ˜¯ `&amp;str` let s: String = String::from(&quot;hello, world!&quot;); // åˆ›å»ºä¸€ä¸ªåˆ‡ç‰‡å¼•ç”¨æŒ‡å‘ String `s` let slice: &amp;str = &amp;s; // åŸºäºåˆšåˆ›å»ºçš„åˆ‡ç‰‡æ¥åˆ›å»ºä¸€ä¸ª String let s: String = slice.to_string(); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; My Answer 2 Answer 2 UTF-8&amp;ç´¢å¼•ç”±äº String éƒ½æ˜¯ UTF-8 ç¼–ç çš„ï¼Œè¿™ä¼šå¸¦æ¥å‡ ä¸ªå½±å“: å¦‚æœä½ éœ€è¦çš„æ˜¯é UTF-8 å­—ç¬¦ä¸²ï¼Œå¯ä»¥è€ƒè™‘ OsString æ— æ³•é€šè¿‡ç´¢å¼•çš„æ–¹å¼è®¿é—®ä¸€ä¸ª String å…·ä½“è¯·çœ‹å­—ç¬¦ä¸²ç´¢å¼•ã€‚ ğŸŒŸğŸŒŸğŸŒŸ æˆ‘ä»¬æ— æ³•é€šè¿‡ç´¢å¼•çš„æ–¹å¼è®¿é—®å­—ç¬¦ä¸²ä¸­çš„æŸä¸ªå­—ç¬¦ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡åˆ‡ç‰‡çš„æ–¹å¼æ¥è·å–å­—ç¬¦ä¸²çš„æŸä¸€éƒ¨åˆ† &amp;s1[start..end] 123456789101112131415161718// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯fn main() &#123; let s = String::from(&quot;hello, ä¸–ç•Œ&quot;); let slice1 = s[0]; //æç¤º: `h` åœ¨ UTF-8 ç¼–ç ä¸­åªå ç”¨ 1 ä¸ªå­—èŠ‚ assert_eq!(slice1, &quot;h&quot;); let slice2 = &amp;s[3..5];// æç¤º: `ä¸–` åœ¨ UTF-8 ç¼–ç ä¸­å ç”¨ 3 ä¸ªå­—èŠ‚ assert_eq!(slice2, &quot;ä¸–&quot;); // è¿­ä»£ s ä¸­çš„æ‰€æœ‰å­—ç¬¦ for (i, c) in s.__ &#123; if i == 7 &#123; assert_eq!(c, &#x27;ä¸–&#x27;) &#125; &#125; println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯fn main() &#123; let s = String::from(&quot;hello, ä¸–ç•Œ&quot;); let slice1 = &amp;s[0..1]; //æç¤º: `h` åœ¨ UTF-8 ç¼–ç ä¸­åªå ç”¨ 1 ä¸ªå­—èŠ‚ assert_eq!(slice1, &quot;h&quot;); let slice2 = &amp;s[7..10];// æç¤º: `ä¸–` åœ¨ UTF-8 ç¼–ç ä¸­å ç”¨ 3 ä¸ªå­—èŠ‚ assert_eq!(slice2, &quot;ä¸–&quot;); // è¿­ä»£ s ä¸­çš„æ‰€æœ‰å­—ç¬¦ for (i, c) in s.chars().enumerate() &#123; if i == 7 &#123; assert_eq!(c, &#x27;ä¸–&#x27;) &#125; &#125; println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516fn main() &#123; let s = String::from(&quot;hello, ä¸–ç•Œ&quot;); let slice1 = &amp;s[0..1]; //modify this line to fix the error, tips: `h` only takes 1 byte in UTF8 format assert_eq!(slice1, &quot;h&quot;); let slice2 = &amp;s[7..10];//modify this line to fix the error, tips: `ä¸­` takes 3 bytes in UTF8 format assert_eq!(slice2, &quot;ä¸–&quot;); for (i, c) in s.chars().enumerate() &#123; if i == 7 &#123; assert_eq!(c, &#x27;ä¸–&#x27;) &#125; &#125; println!(&quot;Success!&quot;)&#125; utf8_sliceæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ utf8_slice æ¥æŒ‰ç…§å­—ç¬¦çš„è‡ªç„¶ç´¢å¼•æ–¹å¼å¯¹ UTF-8 å­—ç¬¦ä¸²è¿›è¡Œåˆ‡ç‰‡è®¿é—®ï¼Œä¸ä¹‹å‰çš„åˆ‡ç‰‡æ–¹å¼ç›¸æ¯”ï¼Œå®ƒç´¢å¼•çš„æ˜¯å­—ç¬¦ï¼Œè€Œä¹‹å‰çš„æ–¹å¼ç´¢å¼•çš„æ˜¯å­—èŠ‚. ç¤ºä¾‹ 1234567use utf8_slice;fn main() &#123; let s = &quot;The ğŸš€ goes to the ğŸŒ‘!&quot;; let rocket = utf8_slice::slice(s, 4, 5); // Will equal &quot;ğŸš€&quot;&#125; ğŸŒŸğŸŒŸğŸŒŸ æç¤º: ä¹Ÿè®¸ä½ éœ€è¦ä½¿ç”¨ from_utf8 æ–¹æ³• 123456789101112131415// å¡«ç©ºfn main() &#123; let mut s = String::new(); __; let v = vec![104, 101, 108, 108, 111]; // å°†å­—èŠ‚æ•°ç»„è½¬æ¢æˆ String let s1 = __; assert_eq!(s, s1); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617// FILL in the blanks fn main() &#123; let mut s = String::new(); s.push_str(&quot;hello&quot;); // some bytes, in a vector let v = vec![104, 101, 108, 108, 111]; // Turn a bytes vector into a String // We know these bytes are valid, so we&#x27;ll use `unwrap()`. let s1 = String::from_utf8(v).unwrap(); assert_eq!(s, s1); println!(&quot;Success!&quot;) &#125; Answer 1234567891011121314151617// FILL in the blanks fn main() &#123; let mut s = String::new(); s.push_str(&quot;hello&quot;); // some bytes, in a vector let v = vec![104, 101, 108, 108, 111]; // Turn a bytes vector into a String // We know these bytes are valid, so we&#x27;ll use `unwrap()`. let s1 = String::from_utf8(v).unwrap(); assert_eq!(s, s1); println!(&quot;Success!&quot;) &#125; äº‹å®ä¸Š String æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒä½œä¸ºä¸€ä¸ªç»“æ„ä½“å­˜å‚¨åœ¨æ ˆä¸Šï¼Œç„¶åæŒ‡å‘å­˜å‚¨åœ¨å †ä¸Šçš„å­—ç¬¦ä¸²åº•å±‚æ•°æ®ã€‚ å­˜å‚¨åœ¨æ ˆä¸Šçš„æ™ºèƒ½æŒ‡é’ˆç»“æ„ä½“ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šä¸€ä¸ªæŒ‡é’ˆåªæŒ‡å‘å †ä¸Šçš„å­—èŠ‚æ•°ç»„ï¼Œå·²ä½¿ç”¨çš„é•¿åº¦ä»¥åŠå·²åˆ†é…çš„å®¹é‡ capacity (å·²ä½¿ç”¨çš„é•¿åº¦å°äºç­‰äºå·²åˆ†é…çš„å®¹é‡ï¼Œå½“å®¹é‡ä¸å¤Ÿæ—¶ï¼Œä¼šé‡æ–°åˆ†é…å†…å­˜ç©ºé—´)ã€‚ ğŸŒŸğŸŒŸ å¦‚æœ String çš„å½“å‰å®¹é‡è¶³å¤Ÿï¼Œé‚£ä¹ˆæ·»åŠ å­—ç¬¦å°†ä¸ä¼šå¯¼è‡´æ–°çš„å†…å­˜åˆ†é… 123456789101112131415161718```rust// ä¿®æ”¹ä¸‹é¢çš„ä»£ç ä»¥æ‰“å°å¦‚ä¸‹å†…å®¹: // 25// 25// 25// å¾ªç¯ä¸­ä¸ä¼šå‘ç”Ÿä»»ä½•å†…å­˜åˆ†é…fn main() &#123; let mut s = String::new(); println!(&quot;&#123;&#125;&quot;, s.capacity()); for _ in 0..2 &#123; s.push_str(&quot;hello&quot;); println!(&quot;&#123;&#125;&quot;, s.capacity()); &#125; println!(&quot;Success!&quot;)&#125; 123456789101112131415- My Answer ```rust fn main() &#123; let mut s = String::with_capacity(25); println!(&quot;&#123;&#125;&quot;, s.capacity()); for _ in 0..2 &#123; s.push_str(&quot;hello&quot;); println!(&quot;&#123;&#125;&quot;, s.capacity()); &#125; println!(&quot;Success!&quot;) &#125; Answer 123456789101112fn main() &#123; let mut s = String::with_capacity(25); println!(&quot;&#123;&#125;&quot;, s.capacity()); for _ in 0..2 &#123; s.push_str(&quot;hello&quot;); println!(&quot;&#123;&#125;&quot;, s.capacity()); &#125; println!(&quot;Success!&quot;)&#125; -7. ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617181920212223// å¡«ç©ºuse std::mem;fn main() &#123; let story = String::from(&quot;Rust By Practice&quot;); // é˜»æ­¢ String çš„æ•°æ®è¢«è‡ªåŠ¨ drop let mut story = mem::ManuallyDrop::new(story); let ptr = story.__(); let len = story.__(); let capacity = story.__(); assert_eq!(16, len); // æˆ‘ä»¬å¯ä»¥åŸºäº ptr æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡æ¥é‡æ–°æ„å»º String. // è¿™ç§æ“ä½œå¿…é¡»æ ‡è®°ä¸º unsafeï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦è‡ªå·±æ¥ç¡®ä¿è¿™é‡Œçš„æ“ä½œæ˜¯å®‰å…¨çš„ let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;; assert_eq!(*story, s); println!(&quot;Success!&quot;)&#125; My Answer ä¸ä¼š Answer 123456789101112131415161718192021222324use std::mem;fn main() &#123; let story = String::from(&quot;Rust By Practice&quot;); // Prevent automatically dropping the String&#x27;s data let mut story = mem::ManuallyDrop::new(story); let ptr = story.as_mut_ptr(); let len = story.len(); let capacity = story.capacity(); // story has nineteen bytes assert_eq!(16, len); // We can re-build a String out of ptr, len, and capacity. This is all // unsafe because we are responsible for making sure the components are // valid: let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;; assert_eq!(*story, s); println!(&quot;Success!&quot;)&#125; å…ƒç»„ ğŸŒŸ å…ƒç»„ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒçš„ç±»å‹ã€‚å…ƒç»„çš„ç±»å‹ç­¾åæ˜¯ (T1, T2, ...), è¿™é‡Œ T1, T2 æ˜¯ç›¸å¯¹åº”çš„å…ƒç»„æˆå‘˜çš„ç±»å‹. 1234567fn main() &#123; let _t0: (u8,i16) = (0, -1); // å…ƒç»„çš„æˆå‘˜è¿˜å¯ä»¥æ˜¯ä¸€ä¸ªå…ƒç»„ let _t1: (u8, (i16, u32)) = (0, (-1, 1)); // å¡«ç©ºè®©ä»£ç å·¥ä½œ let t: (u8, __, i64, __, __) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));&#125; My Answer 1234567fn main() &#123; let _t0: (u8,i16) = (0, -1); // å…ƒç»„çš„æˆå‘˜è¿˜å¯ä»¥æ˜¯ä¸€ä¸ªå…ƒç»„ let _t1: (u8, (i16, u32)) = (0, (-1, 1)); // å¡«ç©ºè®©ä»£ç å·¥ä½œ let t: (u8, u16, i64, &amp;str, String) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));&#125; Answer 123456fn main() &#123; let _t0: (u8,i16) = (0, -1); // Tuples can be tuple&#x27;s members let _t1: (u8, (i16, u32)) = (0, (-1, 1)); let t: (u8, u16, i64, &amp;str, String) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));&#125; ğŸŒŸ å¯ä»¥ä½¿ç”¨ç´¢å¼•æ¥è·å–å…ƒç»„çš„æˆå‘˜ 12345// ä¿®æ”¹åˆé€‚çš„åœ°æ–¹ï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;); assert_eq!(t.1, &quot;sunface&quot;);&#125; My Answer 12345// ä¿®æ”¹åˆé€‚çš„åœ°æ–¹ï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;); assert_eq!(t.2, &quot;sunface&quot;);&#125; Answer 1234fn main() &#123; let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;); assert_eq!(t.2, &quot;sunface&quot;); &#125; ğŸŒŸ è¿‡é•¿çš„å…ƒç»„æ— æ³•è¢«æ‰“å°è¾“å‡º 12345// ä¿®å¤ä»£ç é”™è¯¯fn main() &#123; let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13); println!(&quot;too long tuple: &#123;:?&#125;&quot;, too_long_tuple);&#125; My Answer 12345// ä¿®å¤ä»£ç é”™è¯¯fn main() &#123; let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12); println!(&quot;too long tuple: &#123;:?&#125;&quot;, too_long_tuple);&#125; Answer 1234fn main() &#123; let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12); println!(&quot;too long tuple: &#123;:?&#125;&quot;, too_long_tuple);&#125; ğŸŒŸ ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è§£æ„å…ƒç»„ 12345678910fn main() &#123; let tup = (1, 6.4, &quot;hello&quot;); // å¡«ç©º let __ = tup; assert_eq!(x, 1); assert_eq!(y, &quot;hello&quot;); assert_eq!(z, 6.4);&#125; My Answer 12345678910fn main() &#123; let tup = (1, 6.4, &quot;hello&quot;); // å¡«ç©º let (x,z,y) = tup; assert_eq!(x, 1); assert_eq!(y, &quot;hello&quot;); assert_eq!(z, 6.4);&#125; Answer 123456789fn main() &#123; let tup = (1, 6.4, &quot;hello&quot;); let (x, z, y) = tup; assert_eq!(x, 1); assert_eq!(y, &quot;hello&quot;); assert_eq!(z, 6.4);&#125; ğŸŒŸğŸŒŸ è§£æ„å¼èµ‹å€¼ 12345678910fn main() &#123; let (x, y, z); // å¡«ç©º __ = (1, 2, 3); assert_eq!(x, 3); assert_eq!(y, 1); assert_eq!(z, 2);&#125; My Answer 12345678910fn main() &#123; let (x, y, z); // å¡«ç©º (y,z,x) = (1, 2, 3); assert_eq!(x, 3); assert_eq!(y, 1); assert_eq!(z, 2);&#125; Answer 12345678910fn main() &#123; let (x, y, z); // fill the blank (y, z, x) = (1, 2, 3); assert_eq!(x, 3); assert_eq!(y, 1); assert_eq!(z, 2);&#125; ğŸŒŸğŸŒŸ å…ƒç»„å¯ä»¥ç”¨äºå‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ 1234567891011fn main() &#123; // å¡«ç©ºï¼Œéœ€è¦ç¨å¾®è®¡ç®—ä¸‹ let (x, y) = sum_multiply(__); assert_eq!(x, 5); assert_eq!(y, 6);&#125;fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) &#123; (nums.0 + nums.1, nums.0 * nums.1)&#125; My Answer 1234567891011fn main() &#123; // å¡«ç©ºï¼Œéœ€è¦ç¨å¾®è®¡ç®—ä¸‹ let (x, y) = sum_multiply((2,3)); assert_eq!(x, 5); assert_eq!(y, 6);&#125;fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) &#123; (nums.0 + nums.1, nums.0 * nums.1)&#125; Answer 12345678910fn main() &#123; let (x, y) = sum_multiply((2, 3)); assert_eq!(x, 5); assert_eq!(y, 6); &#125; fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) &#123; (nums.0 + nums.1, nums.0 * nums.1) &#125; ç»“æ„ä½“ä¸‰ç§ç±»å‹çš„ç»“æ„ä½“ ğŸŒŸ å¯¹äºç»“æ„ä½“ï¼Œæˆ‘ä»¬å¿…é¡»ä¸ºå…¶ä¸­çš„æ¯ä¸€ä¸ªå­—æ®µéƒ½æŒ‡å®šå…·ä½“çš„å€¼ 12345678910111213// fix the errorstruct Person &#123; name: String, age: u8, hobby: String&#125;fn main() &#123; let age = 30; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;;&#125; My Answer 1234567891011121314// fix the errorstruct Person &#123; name: String, age: u8, hobby: String&#125;fn main() &#123; let age = 30; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, hobby: String::from(&quot;baseball&quot;) &#125;;&#125; Answer 12345678910111213struct Person &#123; name: String, age: u8, hobby: String&#125;fn main() &#123; let age = 30; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, hobby: &quot;coding&quot;.to_string() &#125;;&#125; ğŸŒŸ å•å…ƒç»“æ„ä½“æ²¡æœ‰ä»»ä½•å­—æ®µã€‚ 123456789101112131415struct Unit;trait SomeTrait &#123; // ...å®šä¹‰ä¸€äº›è¡Œä¸º&#125;// æˆ‘ä»¬å¹¶ä¸å…³å¿ƒç»“æ„ä½“ä¸­æœ‰ä»€ä¹ˆæ•°æ®( å­—æ®µ )ï¼Œä½†æˆ‘ä»¬å…³å¿ƒå®ƒçš„è¡Œä¸ºã€‚// å› æ­¤è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨æ²¡æœ‰ä»»ä½•å­—æ®µçš„å•å…ƒç»“æ„ä½“ï¼Œç„¶åä¸ºå®ƒå®ç°ä¸€äº›è¡Œä¸ºimpl SomeTrait for Unit &#123; &#125;fn main() &#123; let u = Unit; do_something_with_unit(u);&#125; // å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œfn do_something_with_unit(u: __) &#123; &#125; My Answer 123456789101112131415struct Unit;trait SomeTrait &#123; // ...å®šä¹‰ä¸€äº›è¡Œä¸º&#125;// æˆ‘ä»¬å¹¶ä¸å…³å¿ƒç»“æ„ä½“ä¸­æœ‰ä»€ä¹ˆæ•°æ®( å­—æ®µ )ï¼Œä½†æˆ‘ä»¬å…³å¿ƒå®ƒçš„è¡Œä¸ºã€‚// å› æ­¤è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨æ²¡æœ‰ä»»ä½•å­—æ®µçš„å•å…ƒç»“æ„ä½“ï¼Œç„¶åä¸ºå®ƒå®ç°ä¸€äº›è¡Œä¸ºimpl SomeTrait for Unit &#123; &#125;fn main() &#123; let u = Unit; do_something_with_unit(u);&#125; // å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œfn do_something_with_unit(u: Unit) &#123; &#125; Answer 123456789101112131415struct Unit;trait SomeTrait &#123; // ...Some behavours defines here&#125;// We don&#x27;t care the the fields are in Unit, but we care its behaviors.// So we use a struct with no fields and implement some behaviors for itimpl SomeTrait for Unit &#123; &#125;fn main() &#123; let u = Unit; do_something_with_unit(u);&#125; // fill the blank to make the code workfn do_something_with_unit(u: Unit) &#123; &#125; ğŸŒŸğŸŒŸğŸŒŸ å…ƒç»„ç»“æ„ä½“çœ‹èµ·æ¥è·Ÿå…ƒç»„å¾ˆåƒï¼Œä½†æ˜¯å®ƒæ‹¥æœ‰ä¸€ä¸ªç»“æ„ä½“çš„åç§°ï¼Œè¯¥åç§°å¯ä»¥èµ‹äºˆå®ƒä¸€å®šçš„æ„ä¹‰ã€‚ç”±äºå®ƒå¹¶ä¸å…³å¿ƒå†…éƒ¨æ•°æ®åˆ°åº•æ˜¯ä»€ä¹ˆåç§°ï¼Œå› æ­¤æ­¤æ—¶å…ƒç»„ç»“æ„ä½“å°±éå¸¸é€‚åˆã€‚ 1234567891011121314// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() &#123; let v = Point(__, __, __); check_color(v);&#125; fn check_color(p: Color) &#123; let (x, _, _) = p; assert_eq!(x, 0); assert_eq!(p.1, 127); assert_eq!(__, 255); &#125; My Answer 1234567891011121314// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() &#123; let v = Color(0, 127, 255); check_color(v);&#125; fn check_color(p: Color) &#123; let Color(x,_,_) = p; assert_eq!(x, 0); assert_eq!(p.1, 127); assert_eq!(p.2, 255); &#125; Answer 12345678910111213struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() &#123; let v = Point(0, 127, 255); check_color(v);&#125; fn check_color(p: Point) &#123; let Point(x, _, _) = p; assert_eq!(x, 0); assert_eq!(p.1, 127); assert_eq!(p.2, 255);&#125; ç»“æ„ä½“ä¸Šçš„ä¸€äº›æ“ä½œ ğŸŒŸ ä½ å¯ä»¥åœ¨å®ä¾‹åŒ–ä¸€ä¸ªç»“æ„ä½“æ—¶å°†å®ƒæ•´ä½“æ ‡è®°ä¸ºå¯å˜çš„ï¼Œä½†æ˜¯ Rust ä¸å…è®¸æˆ‘ä»¬å°†ç»“æ„ä½“çš„æŸä¸ªå­—æ®µä¸“é—¨æŒ‡å®šä¸ºå¯å˜çš„. 123456789101112131415161718// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯ï¼Œä¸è¦å¢åŠ æˆ–ç§»é™¤ä»£ç è¡Œstruct Person &#123; name: String, age: u8,&#125;fn main() &#123; let age = 18; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;; // how can you believe sunface is only 18? p.age = 30; // å¡«ç©º __ = String::from(&quot;sunfei&quot;);&#125; My Answer 123456789101112131415161718// å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯ï¼Œä¸è¦å¢åŠ æˆ–ç§»é™¤ä»£ç è¡Œstruct Person &#123; name: String, age: u8,&#125;fn main() &#123; let age = 18; let mut p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;; // how can you believe sunface is only 18? p.age = 30; // å¡«ç©º p.name = String::from(&quot;sunfei&quot;);&#125; Answer 12345678910111213141516struct Person &#123; name: String, age: u8,&#125;fn main() &#123; let age = 18; let mut p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;; // how can you believe sunface is only 18? p.age = 30; p.name = String::from(&quot;sunfei&quot;);&#125; ğŸŒŸ ä½¿ç”¨ç»“æ„ä½“å­—æ®µåˆå§‹åŒ–ç¼©ç•¥è¯­æ³•å¯ä»¥å‡å°‘ä¸€äº›é‡å¤ä»£ç  12345678910111213// å¡«ç©ºstruct Person &#123; name: String, age: u8,&#125;fn main() &#123;&#125; fn build_person(name: String, age: u8) -&gt; Person &#123; Person &#123; age, __ &#125;&#125; My Answer 12345678910111213// å¡«ç©ºstruct Person &#123; name: String, age: u8,&#125;fn main() &#123;&#125; fn build_person(name: String, age: u8) -&gt; Person &#123; Person &#123; age, name &#125;&#125; Answer 123456789101112struct Person &#123; name: String, age: u8,&#125;fn main() &#123;&#125; fn build_person(name: String, age: u8) -&gt; Person &#123; Person &#123; age, name &#125;&#125; ğŸŒŸ ä½ å¯ä»¥ä½¿ç”¨ç»“æ„ä½“æ›´æ–°è¯­æ³•åŸºäºä¸€ä¸ªç»“æ„ä½“å®ä¾‹æ¥æ„é€ å¦ä¸€ä¸ª 123456789101112131415161718192021222324// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œstruct User &#123; active: bool, username: String, email: String, sign_in_count: u64,&#125;fn main() &#123; let u1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;sunface&quot;), active: true, sign_in_count: 1, &#125;; let u2 = set_email(u1);&#125; fn set_email(u: User) -&gt; User &#123; User &#123; email: String::from(&quot;contact@im.dev&quot;), __ &#125;&#125; My Answer 123456789101112131415161718192021222324// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œstruct User &#123; active: bool, username: String, email: String, sign_in_count: u64,&#125;fn main() &#123; let u1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;sunface&quot;), active: true, sign_in_count: 1, &#125;; let u2 = set_email(u1);&#125; fn set_email(u: User) -&gt; User &#123; User &#123; email: String::from(&quot;contact@im.dev&quot;), ..u &#125;&#125; Answer 1234567891011121314151617181920212223struct User &#123; active: bool, username: String, email: String, sign_in_count: u64,&#125;fn main() &#123; let u1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;sunface&quot;), active: true, sign_in_count: 1, &#125;; let u2 = set_email(u1);&#125; fn set_email(u: User) -&gt; User &#123; User &#123; email: String::from(&quot;contact@im.dev&quot;), ..u &#125;&#125; æ‰“å°ç»“æ„ä½“ ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ #[derive(Debug)] è®©ç»“æ„ä½“å˜æˆå¯æ‰“å°çš„. 123456789101112131415161718// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ#[__]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let scale = 2; let rect1 = Rectangle &#123; width: dbg!(30 * scale), // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr,å¹¶å°† `30 * scale` çš„å€¼èµ‹ç»™ `width` height: 50, &#125;; dbg!(&amp;rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr println!(__, rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†è¾“å‡º stdout&#125; My Answer 123456789101112131415161718// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let scale = 2; let rect1 = Rectangle &#123; width: dbg!(30 * scale), // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr,å¹¶å°† `30 * scale` çš„å€¼èµ‹ç»™ `width` height: 50, &#125;; dbg!(&amp;rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†é”™è¯¯è¾“å‡º stderr println!(&quot;&#123;:?&#125;&quot;, rect1); // æ‰“å° debug ä¿¡æ¯åˆ°æ ‡å‡†è¾“å‡º stdout&#125; Answer 1234567891011121314151617#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let scale = 2; let rect1 = Rectangle &#123; width: dbg!(30 * scale), // print debug info to stderr and assign the value of `30 * scale` to `width` height: 50, &#125;; dbg!(&amp;rect1); // print debug info to stderr println!(&quot;&#123;:?&#125;&quot;, rect1); // print debug info to stdout&#125; ç»“æ„ä½“çš„æ‰€æœ‰æƒå½“è§£æ„ä¸€ä¸ªå˜é‡æ—¶ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ move å’Œå¼•ç”¨æ¨¡å¼ç»‘å®šçš„æ–¹å¼ã€‚å½“è¿™ä¹ˆåšæ—¶ï¼Œéƒ¨åˆ† move å°±ä¼šå‘ç”Ÿï¼šå˜é‡ä¸­ä¸€éƒ¨åˆ†çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™å…¶å®ƒå˜é‡ï¼Œè€Œå¦ä¸€éƒ¨åˆ†æˆ‘ä»¬è·å–äº†å®ƒçš„å¼•ç”¨ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒåŸå˜é‡å°†æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å®ƒæ²¡æœ‰è½¬ç§»æ‰€æœ‰æƒçš„é‚£ä¸€éƒ¨åˆ†ä¾ç„¶å¯ä»¥ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¹‹å‰è¢«å¼•ç”¨çš„é‚£éƒ¨åˆ†ã€‚ ç¤ºä¾‹ 1234567891011121314151617181920212223242526fn main() &#123; #[derive(Debug)] struct Person &#123; name: String, age: Box&lt;u8&gt;, &#125; let person = Person &#123; name: String::from(&quot;Alice&quot;), age: Box::new(20), &#125;; // é€šè¿‡è¿™ç§è§£æ„å¼æ¨¡å¼åŒ¹é…ï¼Œperson.name çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™æ–°çš„å˜é‡ `name` // ä½†æ˜¯ï¼Œè¿™é‡Œ `age` å˜é‡å´æ˜¯å¯¹ person.age çš„å¼•ç”¨, è¿™é‡Œ ref çš„ä½¿ç”¨ç›¸å½“äº: let age = &amp;person.age let Person &#123; name, ref age &#125; = person; println!(&quot;The person&#x27;s age is &#123;&#125;&quot;, age); println!(&quot;The person&#x27;s name is &#123;&#125;&quot;, name); // Error! åŸå› æ˜¯ person çš„ä¸€éƒ¨åˆ†å·²ç»è¢«è½¬ç§»äº†æ‰€æœ‰æƒï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•å†ä½¿ç”¨å®ƒ //println!(&quot;The person struct is &#123;:?&#125;&quot;, person); // è™½ç„¶ `person` ä½œä¸ºä¸€ä¸ªæ•´ä½“æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯ `person.age` ä¾ç„¶å¯ä»¥ä½¿ç”¨ println!(&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;, person.age);&#125; ğŸŒŸğŸŒŸ 1234567891011121314151617// ä¿®å¤é”™è¯¯#[derive(Debug)]struct File &#123; name: String, data: String,&#125;fn main() &#123; let f = File &#123; name: String::from(&quot;readme.md&quot;), data: &quot;Rust By Practice&quot;.to_string() &#125;; let _name = f.name; // åªèƒ½ä¿®æ”¹è¿™ä¸€è¡Œ println!(&quot;&#123;&#125;, &#123;&#125;, &#123;:?&#125;&quot;,f.name, f.data, f);&#125; My Answer 1234567891011121314151617// ä¿®å¤é”™è¯¯#[derive(Debug)]struct File &#123; name: String, data: String,&#125;fn main() &#123; let f = File &#123; name: String::from(&quot;readme.md&quot;), data: &quot;Rust By Practice&quot;.to_string() &#125;; let _name = f.name; // åªèƒ½ä¿®æ”¹è¿™ä¸€è¡Œ println!(&quot;&#123;&#125;&quot;,f.data);&#125; Answer 123456789101112131415#[derive(Debug)]struct File &#123; name: String, data: String,&#125;fn main() &#123; let f = File &#123; name: String::from(&quot;readme.md&quot;), data: &quot;Rust By Practice&quot;.to_string() &#125;; let _name = f.name; println!(&quot;&#123;&#125;&quot;, f.data);&#125; æšä¸¾ ğŸŒŸğŸŒŸ åœ¨åˆ›å»ºæšä¸¾æ—¶ï¼Œä½ å¯ä»¥ä½¿ç”¨æ˜¾å¼çš„æ•´æ•°è®¾å®šæšä¸¾æˆå‘˜çš„å€¼ 12345678910111213141516171819// ä¿®å¤é”™è¯¯enum Number &#123; Zero, One, Two,&#125;enum Number1 &#123; Zero = 0, One, Two,&#125;// Cè¯­è¨€é£æ ¼çš„æšä¸¾å®šä¹‰enum Number2 &#123; Zero = 0.0, One = 1.0, Two = 2.0,&#125; fn main() { // é€šè¿‡ `as` å¯ä»¥å°†æšä¸¾å€¼å¼ºè½¬ä¸ºæ•´æ•°ç±»å‹ assert_eq!(Number::One, Number1::One); assert_eq!(Number1::One, Number2::One); } 12345678910111213141516171819202122232425262728293031323334- My Answer æ²¡ç†è§£- Answer ```rust // ä¿®å¤é”™è¯¯ enum Number &#123; Zero, One, Two, &#125; enum Number1 &#123; Zero = 0, One, Two, &#125; // Cè¯­è¨€é£æ ¼çš„æšä¸¾å®šä¹‰ enum Number2 &#123; Zero = 0, One = 1, Two = 2, &#125; fn main() &#123; // é€šè¿‡ `as` å¯ä»¥å°†æšä¸¾å€¼å¼ºè½¬ä¸ºæ•´æ•°ç±»å‹ assert_eq!(Number::One as u8, Number1::One as u8); assert_eq!(Number1::One as u8, Number2::One as u8); &#125; ğŸŒŸ æšä¸¾æˆå‘˜å¯ä»¥æŒæœ‰å„ç§ç±»å‹çš„å€¼ 123456789101112// å¡«ç©ºenum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg1 = Message::Move&#123;__&#125;; // ä½¿ç”¨x = 1, y = 2 æ¥åˆå§‹åŒ– let msg2 = Message::Write(__); // ä½¿ç”¨ &quot;hello, world!&quot; æ¥åˆå§‹åŒ–&#125; My Answer 123456789101112// å¡«ç©ºenum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg1 = Message::Move&#123;x: 1,y: 2&#125;; // ä½¿ç”¨x = 1, y = 2 æ¥åˆå§‹åŒ– let msg2 = Message::Write(&quot;hello,world!&quot;.to_string()); // ä½¿ç”¨ &quot;hello, world!&quot; æ¥åˆå§‹åŒ–&#125; Answer 1234567891011enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg1 = Message::Move&#123;x: 1, y: 2&#125;; // instantiating with x = 1, y = 2 let msg2 = Message::Write(String::from(&quot;hello, world&quot;)); // instantiating with &quot;hello, world!&quot;&#125; ğŸŒŸğŸŒŸ æšä¸¾æˆå‘˜ä¸­çš„å€¼å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…æ¥è·å– 1234567891011121314151617// ä»…å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg = Message::Move&#123;x: 1, y: 2&#125;; if let Message::Move&#123;__&#125; = msg &#123; assert_eq!(a, b); &#125; else &#123; panic!(&quot;ä¸è¦è®©è¿™è¡Œä»£ç è¿è¡Œï¼&quot;); &#125;&#125; My Answer 1234567891011121314151617// ä»…å¡«ç©ºå¹¶ä¿®å¤é”™è¯¯enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg = Message::Move&#123;x: 1, y: 2&#125;; if let Message::Move&#123;x,y&#125; = msg &#123; assert_eq!(1, 1); &#125; else &#123; panic!(&quot;ä¸è¦è®©è¿™è¡Œä»£ç è¿è¡Œï¼&quot;); &#125;&#125; Answer 12345678910111213141516enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg = Message::Move&#123;x: 1, y: 1&#125;; if let Message::Move&#123;x: a, y: b&#125; = msg &#123; assert_eq!(a, b); &#125; else &#123; panic!(&quot;NEVER LET THIS RUNï¼&quot;); &#125;&#125; ğŸŒŸğŸŒŸ ä½¿ç”¨æšä¸¾å¯¹ç±»å‹è¿›è¡ŒåŒä¸€åŒ– 1234567891011121314151617181920212223// å¡«ç©ºï¼Œå¹¶ä¿®å¤é”™è¯¯enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs: __ = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; println!(&quot;&#123;&#125;&quot;, msg);&#125; My Answer æ³¨æ„ Answer 1234567891011121314151617181920212223#[derive(Debug)]enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs: [Message; 3] = [ Message::Quit, Message::Move &#123; x: 1, y: 3 &#125;, Message::ChangeColor(255, 255, 0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125;fn show_message(msg: Message) &#123; println!(&quot;&#123;:?&#125;&quot;, msg);&#125; ğŸŒŸğŸŒŸ Rust ä¸­æ²¡æœ‰ nullï¼Œæˆ‘ä»¬é€šè¿‡ Option&lt;T&gt; æšä¸¾æ¥å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µ 12345678910111213141516171819// å¡«ç©ºè®© `println` è¾“å‡ºï¼ŒåŒæ—¶æ·»åŠ ä¸€äº›ä»£ç ä¸è¦è®©æœ€åä¸€è¡Œçš„ `panic` æ‰§è¡Œåˆ°fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None); if let __ = six &#123; println!(&quot;&#123;&#125;&quot;, n) &#125; panic!(&quot;ä¸è¦è®©è¿™è¡Œä»£ç è¿è¡Œï¼&quot;);&#125; fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; __ =&gt; None, __ =&gt; Some(i + 1), &#125;&#125; My Answer 123456789101112131415161718192021// å¡«ç©ºè®© `println` è¾“å‡ºï¼ŒåŒæ—¶æ·»åŠ ä¸€äº›ä»£ç ä¸è¦è®©æœ€åä¸€è¡Œçš„ `panic` æ‰§è¡Œåˆ°fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None); if let five = six &#123; println!(&quot;&#123;&#125;&quot;, 1) &#125; else &#123; panic!(&quot;ä¸è¦è®©è¿™è¡Œä»£ç è¿è¡Œï¼&quot;); &#125; &#125; fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125; Answer 12345678910111213141516171819fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None); if let Some(n) = six &#123; println!(&quot;&#123;&#125;&quot;, n); return &#125; panic!(&quot;NEVER LET THIS RUNï¼&quot;);&#125; fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125; ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ ä½¿ç”¨æšä¸¾æ¥å®ç°é“¾è¡¨. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// å¡«ç©ºï¼Œè®©ä»£ç è¿è¡Œuse crate::List::*;enum List &#123; // Cons: é“¾è¡¨ä¸­åŒ…å«æœ‰å€¼çš„èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹æ˜¯å…ƒç»„ç±»å‹ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯èŠ‚ç‚¹çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ Cons(u32, Box&lt;List&gt;), // Nil: é“¾è¡¨ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç”¨äºè¯´æ˜é“¾è¡¨çš„ç»“æŸ Nil,&#125;// ä¸ºæšä¸¾å®ç°ä¸€äº›æ–¹æ³•impl List &#123; // åˆ›å»ºç©ºçš„é“¾è¡¨ fn new() -&gt; List &#123; // å› ä¸ºæ²¡æœ‰èŠ‚ç‚¹ï¼Œæ‰€ä»¥ç›´æ¥è¿”å› Nil èŠ‚ç‚¹ // æšä¸¾æˆå‘˜ Nil çš„ç±»å‹æ˜¯ List Nil &#125; // åœ¨è€çš„é“¾è¡¨å‰é¢æ–°å¢ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¿”å›æ–°çš„é“¾è¡¨ fn prepend(self, elem: u32) -&gt; __ &#123; Cons(elem, Box::new(self)) &#125; // è¿”å›é“¾è¡¨çš„é•¿åº¦ fn len(&amp;self) -&gt; u32 &#123; match *self &#123; // è¿™é‡Œæˆ‘ä»¬ä¸èƒ½æ‹¿èµ° tail çš„æ‰€æœ‰æƒï¼Œå› æ­¤éœ€è¦è·å–å®ƒçš„å¼•ç”¨ Cons(_, __ tail) =&gt; 1 + tail.len(), // ç©ºé“¾è¡¨çš„é•¿åº¦ä¸º 0 Nil =&gt; 0 &#125; &#125; // è¿”å›é“¾è¡¨çš„å­—ç¬¦ä¸²è¡¨ç°å½¢å¼ï¼Œç”¨äºæ‰“å°è¾“å‡º fn stringify(&amp;self) -&gt; String &#123; match *self &#123; Cons(head, ref tail) =&gt; &#123; // é€’å½’ç”Ÿæˆå­—ç¬¦ä¸² format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail.__()) &#125;, Nil =&gt; &#123; format!(&quot;Nil&quot;) &#125;, &#125; &#125;&#125;fn main() &#123; // åˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨(ä¹Ÿæ˜¯ç©ºçš„) let mut list = List::new(); // æ·»åŠ ä¸€äº›å…ƒç´  list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // æ‰“å°åˆ—è¡¨çš„å½“å‰çŠ¶æ€ println!(&quot;é“¾è¡¨çš„é•¿åº¦æ˜¯: &#123;&#125;&quot;, list.len()); println!(&quot;&#123;&#125;&quot;, list.stringify());&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// å¡«ç©ºï¼Œè®©ä»£ç è¿è¡Œuse crate::List::*;enum List &#123; // Cons: é“¾è¡¨ä¸­åŒ…å«æœ‰å€¼çš„èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹æ˜¯å…ƒç»„ç±»å‹ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯èŠ‚ç‚¹çš„å€¼ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ Cons(u32, Box&lt;List&gt;), // Nil: é“¾è¡¨ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œç”¨äºè¯´æ˜é“¾è¡¨çš„ç»“æŸ Nil,&#125;// ä¸ºæšä¸¾å®ç°ä¸€äº›æ–¹æ³•impl List &#123; // åˆ›å»ºç©ºçš„é“¾è¡¨ fn new() -&gt; List &#123; // å› ä¸ºæ²¡æœ‰èŠ‚ç‚¹ï¼Œæ‰€ä»¥ç›´æ¥è¿”å› Nil èŠ‚ç‚¹ // æšä¸¾æˆå‘˜ Nil çš„ç±»å‹æ˜¯ List Nil &#125; // åœ¨è€çš„é“¾è¡¨å‰é¢æ–°å¢ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¿”å›æ–°çš„é“¾è¡¨ fn prepend(self, elem: u32) -&gt; List &#123; Cons(elem, Box::new(self)) &#125; // è¿”å›é“¾è¡¨çš„é•¿åº¦ fn len(&amp;self) -&gt; u32 &#123; match *self &#123; // è¿™é‡Œæˆ‘ä»¬ä¸èƒ½æ‹¿èµ° tail çš„æ‰€æœ‰æƒï¼Œå› æ­¤éœ€è¦è·å–å®ƒçš„å¼•ç”¨ Cons(elem, ref tail) =&gt; 1 + tail.len(), // ç©ºé“¾è¡¨çš„é•¿åº¦ä¸º 0 Nil =&gt; 0 &#125; &#125; // è¿”å›é“¾è¡¨çš„å­—ç¬¦ä¸²è¡¨ç°å½¢å¼ï¼Œç”¨äºæ‰“å°è¾“å‡º fn stringify(&amp;self) -&gt; String &#123; match *self &#123; Cons(head, ref tail) =&gt; &#123; // é€’å½’ç”Ÿæˆå­—ç¬¦ä¸² format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail)//ä¸ä¼š &#125;, Nil =&gt; &#123; format!(&quot;Nil&quot;) &#125;, &#125; &#125;&#125;fn main() &#123; // åˆ›å»ºä¸€ä¸ªæ–°çš„é“¾è¡¨(ä¹Ÿæ˜¯ç©ºçš„) let mut list = List::new(); // æ·»åŠ ä¸€äº›å…ƒç´  list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // æ‰“å°åˆ—è¡¨çš„å½“å‰çŠ¶æ€ println!(&quot;é“¾è¡¨çš„é•¿åº¦æ˜¯: &#123;&#125;&quot;, list.len()); println!(&quot;&#123;&#125;&quot;, list.stringify());&#125; Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869use crate::List::*;enum List &#123; // Cons: Tuple struct that wraps an element and a pointer to the next node Cons(u32, Box&lt;List&gt;), // Nil: A node that signifies the end of the linked list Nil,&#125;// Methods can be attached to an enumimpl List &#123; // Create an empty list fn new() -&gt; List &#123; // `Nil` has type `List` Nil &#125; // Consume a list, and return the same list with a new element at its front fn prepend(self, elem: u32) -&gt; List &#123; // `Cons` also has type List Cons(elem, Box::new(self)) &#125; // Return the length of the list fn len(&amp;self) -&gt; u32 &#123; // `self` has to be matched, because the behavior of this method // depends on the variant of `self` // `self` has type `&amp;List`, and `*self` has type `List`, matching on a // concrete type `T` is preferred over a match on a reference `&amp;T` // after Rust 2018 you can use self here and tail (with no ref) below as well, // rust will infer &amp;s and ref tail. // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html match *self &#123; // Can&#x27;t take ownership of the tail, because `self` is borrowed; // instead take a reference to the tail Cons(_, ref tail) =&gt; 1 + tail.len(), // Base Case: An empty list has zero length Nil =&gt; 0 &#125; &#125; // Return representation of the list as a (heap allocated) string fn stringify(&amp;self) -&gt; String &#123; match *self &#123; Cons(head, ref tail) =&gt; &#123; // `format!` is similar to `print!`, but returns a heap // allocated string instead of printing to the console format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail.stringify()) &#125; Nil =&gt; &#123; format!(&quot;Nil&quot;) &#125; &#125; &#125;&#125;fn main() &#123; // Create an empty linked list let mut list = List::new(); // Prepend some elements list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // Show the final state of the list println!(&quot;linked list has length: &#123;&#125;&quot;, list.len()); println!(&quot;&#123;&#125;&quot;, list.stringify());&#125; æ•°ç»„æ•°ç»„çš„ç±»å‹æ˜¯ [T; Length]ï¼Œå°±å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œæ•°ç»„çš„é•¿åº¦æ˜¯ç±»å‹ç­¾åçš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤æ•°ç»„çš„é•¿åº¦å¿…é¡»åœ¨ç¼–è¯‘æœŸå°±å·²çŸ¥ï¼Œä¾‹å¦‚ä½ ä¸èƒ½ä½¿ç”¨ä»¥ä¸‹æ–¹å¼æ¥å£°æ˜ä¸€ä¸ªæ•°ç»„: 123fn create_arr(n: i32) &#123; let arr = [1; n];&#125; ä»¥ä¸Šå‡½æ•°å°†æŠ¥é”™ï¼Œå› ä¸ºç¼–è¯‘å™¨æ— æ³•åœ¨ç¼–è¯‘æœŸçŸ¥é“ n çš„å…·ä½“å¤§å°ã€‚ ğŸŒŸ 1234567fn main() &#123; // ä½¿ç”¨åˆé€‚çš„ç±»å‹å¡«ç©º let arr: __ = [1, 2, 3, 4, 5]; // ä¿®æ”¹ä»¥ä¸‹ä»£ç ï¼Œè®©å®ƒé¡ºåˆ©è¿è¡Œ assert!(arr.len() == 4);&#125; My Answer 1234567fn main() &#123; // ä½¿ç”¨åˆé€‚çš„ç±»å‹å¡«ç©º let arr: [u8;5] = [1, 2, 3, 4, 5]; // ä¿®æ”¹ä»¥ä¸‹ä»£ç ï¼Œè®©å®ƒé¡ºåˆ©è¿è¡Œ assert!(arr.len() == 5);&#125; Answer 12345fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; assert!(arr.len() == 5);&#125; ğŸŒŸğŸŒŸ 12345678910fn main() &#123; // å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ•°ç»„çš„éƒ¨åˆ†ç±»å‹ï¼Œä¹Ÿå¯ä»¥å¿½ç•¥å…¨éƒ¨ç±»å‹ï¼Œè®©ç¼–è¯‘å™¨å¸®åŠ©æˆ‘ä»¬æ¨å¯¼ let arr0 = [1, 2, 3]; let arr: [_; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; // å¡«ç©º // æ•°ç»„åˆ†é…åœ¨æ ˆä¸Šï¼Œ `std::mem::size_of_val` å‡½æ•°ä¼šè¿”å›æ•´ä¸ªæ•°ç»„å ç”¨çš„å†…å­˜ç©ºé—´ // æ•°ç»„ä¸­çš„æ¯ä¸ª char å…ƒç´ å ç”¨ 4 å­—èŠ‚çš„å†…å­˜ç©ºé—´ï¼Œå› ä¸ºåœ¨ Rust ä¸­ï¼Œ char æ˜¯ Unicode å­—ç¬¦ assert!(std::mem::size_of_val(&amp;arr) == __);&#125; My Answer 12345678910fn main() &#123; // å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥æ•°ç»„çš„éƒ¨åˆ†ç±»å‹ï¼Œä¹Ÿå¯ä»¥å¿½ç•¥å…¨éƒ¨ç±»å‹ï¼Œè®©ç¼–è¯‘å™¨å¸®åŠ©æˆ‘ä»¬æ¨å¯¼ let arr0 = [1, 2, 3]; let arr: [char; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; // å¡«ç©º // æ•°ç»„åˆ†é…åœ¨æ ˆä¸Šï¼Œ `std::mem::size_of_val` å‡½æ•°ä¼šè¿”å›æ•´ä¸ªæ•°ç»„å ç”¨çš„å†…å­˜ç©ºé—´ // æ•°ç»„ä¸­çš„æ¯ä¸ª char å…ƒç´ å ç”¨ 4 å­—èŠ‚çš„å†…å­˜ç©ºé—´ï¼Œå› ä¸ºåœ¨ Rust ä¸­ï¼Œ char æ˜¯ Unicode å­—ç¬¦ assert!(std::mem::size_of_val(&amp;arr) == 12);&#125; Answer 123456789fn main() &#123; // we can ignore parts of the array type or even the whole type, let the compiler infer it for us let arr0 = [1, 2, 3]; let arr: [_; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; // Arrays are stack allocated, `std::mem::size_of_val` return the bytes which array occupies // A char takes 4 byte in Rust: Unicode char assert!(std::mem::size_of_val(&amp;arr) == 12);&#125; ğŸŒŸ æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ å¯ä»¥ä¸€èµ·åˆå§‹åŒ–ä¸ºåŒä¸€ä¸ªå€¼ 1234567fn main() &#123; // å¡«ç©º let list: [i32; 100] = __ ; assert!(list[0] == 1); assert!(list.len() == 100);&#125; My Answer 1234567fn main() &#123; // å¡«ç©º let list: [i32; 100] = [1;100] ; assert!(list[0] == 1); assert!(list.len() == 100);&#125; Answer 123456fn main() &#123; let list: [i32; 100] = [1; 100]; assert!(list[0] == 1); assert!(list.len() == 100);&#125; ğŸŒŸ æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ç±»å‹ 1234fn main() &#123; // ä¿®å¤é”™è¯¯ let _arr = [1, 2, &#x27;3&#x27;];&#125; My Answer 1234fn main() &#123; // ä¿®å¤é”™è¯¯ let _arr = [1, 2, 3];&#125; Answer 1234fn main() &#123; // fix the error let _arr = [1, 2, 3];&#125; ğŸŒŸ æ•°ç»„çš„ä¸‹æ ‡ç´¢å¼•ä» 0 å¼€å§‹. 1234567fn main() &#123; let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; let ele = arr[1]; // åªä¿®æ”¹æ­¤è¡Œæ¥è®©ä»£ç å·¥ä½œ assert!(ele == &#x27;a&#x27;);&#125; My Answer 1234567fn main() &#123; let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; let ele = arr[0]; // åªä¿®æ”¹æ­¤è¡Œæ¥è®©ä»£ç å·¥ä½œ assert!(ele == &#x27;a&#x27;);&#125; Answer 1234567fn main() &#123; let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; let ele = arr[0]; assert!(ele == &#x27;a&#x27;);&#125; ğŸŒŸ è¶Šç•Œç´¢å¼•ä¼šå¯¼è‡´ä»£ç çš„ panic. 12345678910// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯fn main() &#123; let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()]; // `get` è¿”å› `Option&lt;T&gt;` ç±»å‹ï¼Œå› æ­¤å®ƒçš„ä½¿ç”¨éå¸¸å®‰å…¨ let name0 = names.get(0).unwrap(); // ä½†æ˜¯ä¸‹æ ‡ç´¢å¼•å°±å­˜åœ¨è¶Šç•Œçš„é£é™©äº† let _name1 = &amp;names[2];&#125; My Answer 12345678910// ä¿®å¤ä»£ç ä¸­çš„é”™è¯¯fn main() &#123; let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()]; // `get` è¿”å› `Option&lt;T&gt;` ç±»å‹ï¼Œå› æ­¤å®ƒçš„ä½¿ç”¨éå¸¸å®‰å…¨ let name0 = names.get(0).unwrap(); // ä½†æ˜¯ä¸‹æ ‡ç´¢å¼•å°±å­˜åœ¨è¶Šç•Œçš„é£é™©äº† let _name1 = &amp;names[0];&#125; Answer 123456789fn main() &#123; let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()]; // `get` returns an Option&lt;T&gt;, it&#x27;s safe to use let name0 = names.get(0).unwrap(); // but indexing is not safe let _name1 = &amp;names[1];&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 3 æ‰€æœ‰æƒå’Œå€Ÿç”¨","slug":"Rustå­¦ä¹ -ç»ƒä¹ 3-æ‰€æœ‰æƒå’Œå€Ÿç”¨","date":"2023-08-31T13:52:30.000Z","updated":"2023-09-10T07:42:50.171Z","comments":true,"path":"2023/08/31/Rustå­¦ä¹ -ç»ƒä¹ 3-æ‰€æœ‰æƒå’Œå€Ÿç”¨/","link":"","permalink":"http://example.com/2023/08/31/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A03-%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8/","excerpt":"æ‰€æœ‰æƒå’Œå€Ÿç”¨ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) æ‰€æœ‰æƒ ğŸŒŸğŸŒŸ 123456fn main() &#123; // ä½¿ç”¨å°½å¯èƒ½å¤šçš„æ–¹æ³•æ¥é€šè¿‡ç¼–è¯‘ let x = String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; My Answer 123456fn main() &#123; // ä½¿ç”¨å°½å¯èƒ½å¤šçš„æ–¹æ³•æ¥é€šè¿‡ç¼–è¯‘ let x: &amp;str = &quot;hello,world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 123456fn main() &#123; // ä½¿ç”¨å°½å¯èƒ½å¤šçš„æ–¹æ³•æ¥é€šè¿‡ç¼–è¯‘ let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; Answer 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &quot;hello, world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &amp;String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.as_str(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; ğŸŒŸğŸŒŸ 123456789101112// ä¸è¦ä¿®æ”¹ main ä¸­çš„ä»£ç fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !fn take_ownership(s: String) &#123; println!(&quot;&#123;&#125;&quot;, s);&#125; My Answer 12345678910111213// ä¸è¦ä¿®æ”¹ main ä¸­çš„ä»£ç fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !fn take_ownership(s: String) -&gt;String&#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; Answer 12345678910111213// Don&#x27;t modify code in main!fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// Only modify the code below!fn take_ownership(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; ğŸŒŸğŸŒŸ 12345678910111213fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec // å°† String è½¬æ¢æˆ Vec ç±»å‹ let _s = s.into_bytes(); s&#125; My Answer ä¸ä¼š Answer 123456789101112fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec let _s = s.as_bytes(); s&#125; 12345678910fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); s&#125; ğŸŒŸğŸŒŸ 123456789101112// ä¿®å¤é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 12345678910111213// ä¿®å¤é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let s = String::from(&quot;hello, world&quot;); let s = print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;,s); s&#125; Answer 1234567891011fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s.clone()); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 12345678fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(&amp;s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: &amp;String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; ğŸŒŸğŸŒŸ 123456// ä¸è¦ä½¿ç”¨ cloneï¼Œä½¿ç”¨ copy çš„æ–¹å¼æ›¿ä»£fn main() &#123; let x = (1, 2, (), &quot;hello&quot;.to_string()); let y = x.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; My Answer 123456// ä¸è¦ä½¿ç”¨ cloneï¼Œä½¿ç”¨ copy çš„æ–¹å¼æ›¿ä»£fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; Answer 12345fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125;","text":"æ‰€æœ‰æƒå’Œå€Ÿç”¨ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) æ‰€æœ‰æƒ ğŸŒŸğŸŒŸ 123456fn main() &#123; // ä½¿ç”¨å°½å¯èƒ½å¤šçš„æ–¹æ³•æ¥é€šè¿‡ç¼–è¯‘ let x = String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; My Answer 123456fn main() &#123; // ä½¿ç”¨å°½å¯èƒ½å¤šçš„æ–¹æ³•æ¥é€šè¿‡ç¼–è¯‘ let x: &amp;str = &quot;hello,world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 123456fn main() &#123; // ä½¿ç”¨å°½å¯èƒ½å¤šçš„æ–¹æ³•æ¥é€šè¿‡ç¼–è¯‘ let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; Answer 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &quot;hello, world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &amp;String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.as_str(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; ğŸŒŸğŸŒŸ 123456789101112// ä¸è¦ä¿®æ”¹ main ä¸­çš„ä»£ç fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !fn take_ownership(s: String) &#123; println!(&quot;&#123;&#125;&quot;, s);&#125; My Answer 12345678910111213// ä¸è¦ä¿®æ”¹ main ä¸­çš„ä»£ç fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !fn take_ownership(s: String) -&gt;String&#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; Answer 12345678910111213// Don&#x27;t modify code in main!fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// Only modify the code below!fn take_ownership(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; ğŸŒŸğŸŒŸ 12345678910111213fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// åªèƒ½ä¿®æ”¹ä¸‹é¢çš„ä»£ç !fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec // å°† String è½¬æ¢æˆ Vec ç±»å‹ let _s = s.into_bytes(); s&#125; My Answer ä¸ä¼š Answer 123456789101112fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec let _s = s.as_bytes(); s&#125; 12345678910fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); s&#125; ğŸŒŸğŸŒŸ 123456789101112// ä¿®å¤é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 12345678910111213// ä¿®å¤é”™è¯¯ï¼Œä¸è¦åˆ é™¤ä»»ä½•ä»£ç è¡Œfn main() &#123; let s = String::from(&quot;hello, world&quot;); let s = print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;,s); s&#125; Answer 1234567891011fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s.clone()); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 12345678fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(&amp;s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: &amp;String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; ğŸŒŸğŸŒŸ 123456// ä¸è¦ä½¿ç”¨ cloneï¼Œä½¿ç”¨ copy çš„æ–¹å¼æ›¿ä»£fn main() &#123; let x = (1, 2, (), &quot;hello&quot;.to_string()); let y = x.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; My Answer 123456// ä¸è¦ä½¿ç”¨ cloneï¼Œä½¿ç”¨ copy çš„æ–¹å¼æ›¿ä»£fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; Answer 12345fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; å¯å˜æ€§å½“æ‰€æœ‰æƒè½¬ç§»æ—¶ï¼Œå¯å˜æ€§ä¹Ÿå¯ä»¥éšä¹‹æ”¹å˜ã€‚ ğŸŒŸ 12345678fn main() &#123; let s = String::from(&quot;hello, &quot;); // åªä¿®æ”¹ä¸‹é¢è¿™è¡Œä»£ç  ! let s1 = s; s1.push_str(&quot;world&quot;)&#125; My Answer 12345678fn main() &#123; let s = String::from(&quot;hello, &quot;); // åªä¿®æ”¹ä¸‹é¢è¿™è¡Œä»£ç  ! let mut s1 = s; s1.push_str(&quot;world&quot;)&#125; Answer 12345678fn main() &#123; let s = String::from(&quot;hello, &quot;); // modify this line only ! let mut s1 = s; s1.push_str(&quot;world&quot;)&#125; ğŸŒŸğŸŒŸğŸŒŸ 123456789fn main() &#123; let x = Box::new(5); let ... // å®Œæˆè¯¥è¡Œä»£ç ï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒè¡Œï¼ *y = 4; assert_eq!(*x, 5);&#125; My Answer 123456789fn main() &#123; let x = Box::new(5); let mut y = Box::new(1); // å®Œæˆè¯¥è¡Œä»£ç ï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒè¡Œï¼ *y = 4; assert_eq!(*x, 5);&#125; Answer 123456789fn main() &#123; let x = Box::new(5); let mut y = Box::new(3); // implement this line, dont change other lines! *y = 4; assert_eq!(*x, 5);&#125; éƒ¨åˆ†moveå½“è§£æ„ä¸€ä¸ªå˜é‡æ—¶ï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ move å’Œå¼•ç”¨æ¨¡å¼ç»‘å®šçš„æ–¹å¼ã€‚å½“è¿™ä¹ˆåšæ—¶ï¼Œéƒ¨åˆ† move å°±ä¼šå‘ç”Ÿï¼šå˜é‡ä¸­ä¸€éƒ¨åˆ†çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™å…¶å®ƒå˜é‡ï¼Œè€Œå¦ä¸€éƒ¨åˆ†æˆ‘ä»¬è·å–äº†å®ƒçš„å¼•ç”¨ã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒåŸå˜é‡å°†æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯å®ƒæ²¡æœ‰è½¬ç§»æ‰€æœ‰æƒçš„é‚£ä¸€éƒ¨åˆ†ä¾ç„¶å¯ä»¥ä½¿ç”¨ï¼Œä¹Ÿå°±æ˜¯ä¹‹å‰è¢«å¼•ç”¨çš„é‚£éƒ¨åˆ†ã€‚ ç¤ºä¾‹1234567891011121314151617181920212223242526fn main() &#123; #[derive(Debug)] struct Person &#123; name: String, age: Box&lt;u8&gt;, &#125; let person = Person &#123; name: String::from(&quot;Alice&quot;), age: Box::new(20), &#125;; // é€šè¿‡è¿™ç§è§£æ„å¼æ¨¡å¼åŒ¹é…ï¼Œperson.name çš„æ‰€æœ‰æƒè¢«è½¬ç§»ç»™æ–°çš„å˜é‡ `name` // ä½†æ˜¯ï¼Œè¿™é‡Œ `age` å˜é‡å´æ˜¯å¯¹ person.age çš„å¼•ç”¨, è¿™é‡Œ ref çš„ä½¿ç”¨ç›¸å½“äº: let age = &amp;person.age let Person &#123; name, ref age &#125; = person; println!(&quot;The person&#x27;s age is &#123;&#125;&quot;, age); println!(&quot;The person&#x27;s name is &#123;&#125;&quot;, name); // Error! åŸå› æ˜¯ person çš„ä¸€éƒ¨åˆ†å·²ç»è¢«è½¬ç§»äº†æ‰€æœ‰æƒï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•å†ä½¿ç”¨å®ƒ //println!(&quot;The person struct is &#123;:?&#125;&quot;, person); // è™½ç„¶ `person` ä½œä¸ºä¸€ä¸ªæ•´ä½“æ— æ³•å†è¢«ä½¿ç”¨ï¼Œä½†æ˜¯ `person.age` ä¾ç„¶å¯ä»¥ä½¿ç”¨ println!(&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;, person.age);&#125; ç»ƒä¹  ğŸŒŸ 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); let _s = t.0; // ä»…ä¿®æ”¹ä¸‹é¢è¿™è¡Œä»£ç ï¼Œä¸”ä¸è¦ä½¿ç”¨ `_s` println!(&quot;&#123;:?&#125;&quot;, t);&#125; My Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); let _s = t.0; // ä»…ä¿®æ”¹ä¸‹é¢è¿™è¡Œä»£ç ï¼Œä¸”ä¸è¦ä½¿ç”¨ `_s` println!(&quot;&#123;:?&#125;&quot;, t.1);&#125; Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); let _s = t.0; // modify this line only, don&#x27;t use `_s` println!(&quot;&#123;:?&#125;&quot;, t.1); &#125; ğŸŒŸğŸŒŸ 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); // å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç  let (__, __) = __; println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)&#125; My Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); // å¡«ç©ºï¼Œä¸è¦ä¿®æ”¹å…¶å®ƒä»£ç  let (s1, s2) = t.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)&#125; Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); // fill the blanks let (s1, s2) = t.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)&#125; å¼•ç”¨å’Œå€Ÿç”¨å¼•ç”¨ ğŸŒŸ 1234567fn main() &#123; let x = 5; // å¡«å†™ç©ºç™½å¤„ let p = __; println!(&quot;x çš„å†…å­˜åœ°å€æ˜¯ &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84&#125; My Answer 1234567fn main() &#123; let x = 5; // å¡«å†™ç©ºç™½å¤„ let p = &amp;x; println!(&quot;x çš„å†…å­˜åœ°å€æ˜¯ &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84&#125; Answer 1234567fn main() &#123; let x = 5; // fill the blank let p = &amp;x; println!(&quot;the memory address of x is &#123;:p&#125;&quot;, p); // one possible output: 0x16fa3ac84&#125; ğŸŒŸ 1234567fn main() &#123; let x = 5; let y = &amp;x; // åªèƒ½ä¿®æ”¹ä»¥ä¸‹è¡Œ assert_eq!(5, y);&#125; My Answer 1234567fn main() &#123; let x = 5; let y = &amp;x; // åªèƒ½ä¿®æ”¹ä»¥ä¸‹è¡Œ assert_eq!(5, *y);&#125; Answer 1234567fn main() &#123; let x = 5; let y = &amp;x; // modify this line only assert_eq!(5, *y);&#125; ğŸŒŸ 12345678// ä¿®å¤é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(s)&#125;fn borrow_object(s: &amp;String) &#123;&#125; My Answer 12345678// ä¿®å¤é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s)&#125;fn borrow_object(s: &amp;String) &#123;&#125; Answer 1234567fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s)&#125;fn borrow_object(s: &amp;String) &#123;&#125; ğŸŒŸ 12345678910// ä¿®å¤é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello, &quot;); push_str(s)&#125;fn push_str(s: &amp;mut String) &#123; s.push_str(&quot;world&quot;)&#125; My Answer 12345678910// ä¿®å¤é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello, &quot;); push_str(&amp; mut s)&#125;fn push_str(s: &amp;mut String) &#123; s.push_str(&quot;world&quot;)&#125; Answer 123456789fn main() &#123; let mut s = String::from(&quot;hello, &quot;); push_str(&amp;mut s)&#125;fn push_str(s: &amp;mut String) &#123; s.push_str(&quot;world&quot;)&#125; ğŸŒŸğŸŒŸ 12345678fn main() &#123; let mut s = String::from(&quot;hello, &quot;); // å¡«å†™ç©ºç™½å¤„ï¼Œè®©ä»£ç å·¥ä½œ let p = __; p.push_str(&quot;world&quot;);&#125; My Answer 12345678fn main() &#123; let mut s = String::from(&quot;hello, &quot;); // å¡«å†™ç©ºç™½å¤„ï¼Œè®©ä»£ç å·¥ä½œ let p = &amp;mut s; p.push_str(&quot;world&quot;);&#125; Answer 12345678fn main() &#123; let mut s = String::from(&quot;hello, &quot;); // fill the blank to make it work let p = &amp;mut s; p.push_str(&quot;world&quot;);&#125; refref ä¸ &amp; ç±»ä¼¼ï¼Œå¯ä»¥ç”¨æ¥è·å–ä¸€ä¸ªå€¼çš„å¼•ç”¨ï¼Œä½†æ˜¯å®ƒä»¬çš„ç”¨æ³•æœ‰æ‰€ä¸åŒã€‚ ğŸŒŸğŸŒŸğŸŒŸ 1234567891011121314151617fn main() &#123; let c = &#x27;ä¸­&#x27;; let r1 = &amp;c; // å¡«å†™ç©ºç™½å¤„ï¼Œä½†æ˜¯ä¸è¦ä¿®æ”¹å…¶å®ƒè¡Œçš„ä»£ç  let __ r2 = c; assert_eq!(*r1, *r2); // åˆ¤æ–­ä¸¤ä¸ªå†…å­˜åœ°å€çš„å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ assert_eq!(get_addr(r1),get_addr(r2));&#125;// è·å–ä¼ å…¥å¼•ç”¨çš„å†…å­˜åœ°å€çš„å­—ç¬¦ä¸²å½¢å¼fn get_addr(r: &amp;char) -&gt; String &#123; format!(&quot;&#123;:p&#125;&quot;, r)&#125; My Answer 1234567891011121314151617fn main() &#123; let c = &#x27;ä¸­&#x27;; let r1 = &amp;c; // å¡«å†™ç©ºç™½å¤„ï¼Œä½†æ˜¯ä¸è¦ä¿®æ”¹å…¶å®ƒè¡Œçš„ä»£ç  let ref r2 = c; assert_eq!(*r1, *r2); // åˆ¤æ–­ä¸¤ä¸ªå†…å­˜åœ°å€çš„å­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰ assert_eq!(get_addr(r1),get_addr(r2));&#125;// è·å–ä¼ å…¥å¼•ç”¨çš„å†…å­˜åœ°å€çš„å­—ç¬¦ä¸²å½¢å¼fn get_addr(r: &amp;char) -&gt; String &#123; format!(&quot;&#123;:p&#125;&quot;, r)&#125; Answer 1234567891011121314151617fn main() &#123; let c = &#x27;ä¸­&#x27;; let r1 = &amp;c; // fill the blankï¼Œdont change other code let ref r2 = c; assert_eq!(*r1, *r2); // check the equality of the two address strings assert_eq!(get_addr(r1),get_addr(r2));&#125;// get memory address stringfn get_addr(r: &amp;char) -&gt; String &#123; format!(&quot;&#123;:p&#125;&quot;, r)&#125; å€Ÿç”¨è§„åˆ™ ğŸŒŸ 12345678910// ç§»é™¤ä»£ç æŸä¸ªéƒ¨åˆ†ï¼Œè®©å®ƒå·¥ä½œ// ä½ ä¸èƒ½ç§»é™¤æ•´è¡Œçš„ä»£ç ï¼fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125; My Answer 12345678910// ç§»é™¤ä»£ç æŸä¸ªéƒ¨åˆ†ï¼Œè®©å®ƒå·¥ä½œ// ä½ ä¸èƒ½ç§»é™¤æ•´è¡Œçš„ä»£ç ï¼fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; let r2 = &amp;s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125; Answer 12345678fn main() &#123; let s = String::from(&quot;hello&quot;); let r1 = &amp;s; let r2 = &amp;s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125; å¯å˜æ€§ ğŸŒŸ é”™è¯¯: ä»ä¸å¯å˜å¯¹è±¡å€Ÿç”¨å¯å˜ 12345678fn main() &#123; // é€šè¿‡ä¿®æ”¹ä¸‹é¢ä¸€è¡Œä»£ç æ¥ä¿®å¤é”™è¯¯ let s = String::from(&quot;hello, &quot;); borrow_object(&amp;mut s)&#125;fn borrow_object(s: &amp;mut String) &#123;&#125; My Answer 12345678fn main() &#123; // é€šè¿‡ä¿®æ”¹ä¸‹é¢ä¸€è¡Œä»£ç æ¥ä¿®å¤é”™è¯¯ let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;mut s)&#125;fn borrow_object(s: &amp;mut String) &#123;&#125; Answer 12345678fn main() &#123; //fix error by modifying this line let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;mut s)&#125;fn borrow_object(s: &amp;mut String) &#123;&#125; ğŸŒŸğŸŒŸ Ok: ä»å¯å˜å¯¹è±¡å€Ÿç”¨ä¸å¯å˜ 12345678910// ä¸‹é¢çš„ä»£ç æ²¡æœ‰ä»»ä½•é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s); s.push_str(&quot;world&quot;);&#125;fn borrow_object(s: &amp;String) &#123;&#125; My Answer 12345678910// ä¸‹é¢çš„ä»£ç æ²¡æœ‰ä»»ä½•é”™è¯¯fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s); s.push_str(&quot;world&quot;);&#125;fn borrow_object(s: &amp;String) &#123;&#125; NLL ğŸŒŸğŸŒŸ 1234567891011// æ³¨é‡Šæ‰ä¸€è¡Œä»£ç è®©å®ƒå·¥ä½œfn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; r1.push_str(&quot;world&quot;); let r2 = &amp;mut s; r2.push_str(&quot;!&quot;); println!(&quot;&#123;&#125;&quot;,r1);&#125; My Answer 1234567891011// æ³¨é‡Šæ‰ä¸€è¡Œä»£ç è®©å®ƒå·¥ä½œfn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; r1.push_str(&quot;world&quot;); let r2 = &amp;mut s; r2.push_str(&quot;!&quot;); //println!(&quot;&#123;&#125;&quot;,r1);&#125; Answer 12345678910fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; r1.push_str(&quot;world&quot;); let r2 = &amp;mut s; r2.push_str(&quot;!&quot;); // println!(&quot;&#123;&#125;&quot;,r1);&#125; ğŸŒŸğŸŒŸ 123456789fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; // åœ¨ä¸‹é¢å¢åŠ ä¸€è¡Œä»£ç äººä¸ºåˆ¶é€ ç¼–è¯‘é”™è¯¯ï¼šcannot borrow `s` as mutable more than once at a time // ä½ ä¸èƒ½åŒæ—¶ä½¿ç”¨ r1 å’Œ r2&#125; My Answer 12345678910fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; // åœ¨ä¸‹é¢å¢åŠ ä¸€è¡Œä»£ç äººä¸ºåˆ¶é€ ç¼–è¯‘é”™è¯¯ï¼šcannot borrow `s` as mutable more than once at a time println!(&quot;&#123;&#125;&quot;,r1); // ä½ ä¸èƒ½åŒæ—¶ä½¿ç”¨ r1 å’Œ r2&#125; Answer 12345678910fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; // add one line below to make a compiler error: cannot borrow `s` as mutable more than once at a time // you can&#x27;t use r1 and r2 at the same time r1.push_str(&quot;world&quot;);&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 2 åŸºæœ¬ç±»å‹","slug":"Rustå­¦ä¹ -ç»ƒä¹ 2-åŸºæœ¬ç±»å‹","date":"2023-08-25T11:04:01.000Z","updated":"2023-09-10T07:42:50.997Z","comments":true,"path":"2023/08/25/Rustå­¦ä¹ -ç»ƒä¹ 2-åŸºæœ¬ç±»å‹/","link":"","permalink":"http://example.com/2023/08/25/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A02-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","excerpt":"åŸºæœ¬ç±»å‹ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) æ•°å€¼ç±»å‹æ•´æ•°","text":"åŸºæœ¬ç±»å‹ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) æ•°å€¼ç±»å‹æ•´æ•° ğŸŒŸ Tips: å¦‚æœæˆ‘ä»¬æ²¡æœ‰æ˜¾å¼çš„ç»™äºˆå˜é‡ä¸€ä¸ªç±»å‹ï¼Œé‚£ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬æ¨å¯¼ä¸€ä¸ªç±»å‹ 123456789// ç§»é™¤æŸä¸ªéƒ¨åˆ†è®©ä»£ç å·¥ä½œfn main() &#123; let x: i32 = 5; let mut y: u32 = 5; y = x; let z = 10; // è¿™é‡Œ z çš„ç±»å‹æ˜¯? &#125; My Answer 1234// ç§»é™¤æŸä¸ªéƒ¨åˆ†è®©ä»£ç å·¥ä½œfn main() &#123; let x: i32 = 5; let mut y: u32 = 5; let z = 10; // è¿™é‡Œ z çš„ç±»å‹æ˜¯? } 1 Answer 12345678fn main() &#123; let x: i32 = 5; let mut y = 5; y = x; let z = 10; // type of z : i32&#125; ğŸŒŸ 1234// å¡«ç©ºfn main() &#123; let v: u16 = 38_u8 as __;&#125; My Answer 1234// å¡«ç©ºfn main() &#123; let v: u16 = 38_u8 as u16;&#125; Answer 123fn main() &#123; let v: u16 = 38_u8 as u16;&#125; ğŸŒŸğŸŒŸğŸŒŸ Tips: å¦‚æœæˆ‘ä»¬æ²¡æœ‰æ˜¾å¼çš„ç»™äºˆå˜é‡ä¸€ä¸ªç±»å‹ï¼Œé‚£ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬æ¨å¯¼ä¸€ä¸ªç±»å‹ 12345678910// ä¿®æ”¹ `assert_eq!` è®©ä»£ç å·¥ä½œfn main() &#123; let x = 5; assert_eq!(&quot;u32&quot;.to_string(), type_of(&amp;x));&#125;// ä»¥ä¸‹å‡½æ•°å¯ä»¥è·å–ä¼ å…¥å‚æ•°çš„ç±»å‹ï¼Œå¹¶è¿”å›ç±»å‹çš„å­—ç¬¦ä¸²å½¢å¼ï¼Œä¾‹å¦‚ &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; My Answer 12345678910// ä¿®æ”¹ `assert_eq!` è®©ä»£ç å·¥ä½œfn main() &#123; let x = 5; assert_eq!(&quot;u32&quot;.to_string(), type_of(&amp;x));&#125;// ä»¥ä¸‹å‡½æ•°å¯ä»¥è·å–ä¼ å…¥å‚æ•°çš„ç±»å‹ï¼Œå¹¶è¿”å›ç±»å‹çš„å­—ç¬¦ä¸²å½¢å¼ï¼Œä¾‹å¦‚ &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; Answer 123456789fn main() &#123; let x = 5; assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x));&#125;// get the type of given variable, return a string representation of the type , e.g &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; ğŸŒŸğŸŒŸ 12345// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; assert_eq!(i8::MAX, __); assert_eq!(u8::MAX, __); &#125; My Answer 12345// å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œfn main() &#123; assert_eq!(i8::MAX, 127); assert_eq!(u8::MAX, 255); &#125; Answer 1234fn main() &#123; assert_eq!(i8::MAX, 127); assert_eq!(u8::MAX, 255); &#125; ğŸŒŸğŸŒŸ 123456// è§£å†³ä»£ç ä¸­çš„é”™è¯¯å’Œ `panic`fn main() &#123; let v1 = 251_u8 + 8; let v2 = i8::checked_add(251, 8).unwrap(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);&#125; My Answer 123456// è§£å†³ä»£ç ä¸­çš„é”™è¯¯å’Œ `panic`fn main() &#123; let v1 = 251_u16 + 8_u16; let v2 = u8::checked_add(251, 8).unwrap(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);&#125; Answer 12345fn main() &#123; let v1 = 247_u8 + 8; let v2 = i8::checked_add(119, 8).unwrap(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2); &#125; ğŸŒŸğŸŒŸ 1234 fn main() &#123; let v = 1_024 + 0xff + 0o77 + 0b1111_1111; assert!(v == 1597);&#125; My Answer 12345// ä¿®æ”¹ `assert!` è®©ä»£ç å·¥ä½œfn main() &#123; let v = 1_024 + 0xff + 0o77 + 0b1111_1111; assert!(v == 1597);&#125; Answer 12345// ä¿®æ”¹ `assert!` è®©ä»£ç å·¥ä½œfn main() &#123; let v = 1_024 + 0xff + 0o77 + 0b1111_1111; assert!(v == 1597);&#125; æµ®ç‚¹æ•° ğŸŒŸ 123456// å°† ? æ›¿æ¢æˆä½ çš„ç­”æ¡ˆfn main() &#123; let x = 1_000.000_1; // ? let y: f32 = 0.12; // f32 let z = 0.01_f64; // f64&#125; My Answer 123456// å°† ? æ›¿æ¢æˆä½ çš„ç­”æ¡ˆfn main() &#123; let x = 1_000.000_1; // f64 let y: f32 = 0.12; // f32 let z = 0.01_f64; // f64&#125; Answer 123456789101112fn main() &#123; let x = 1_000.000_1; // f64 let y: f32 = 0.12; // f32 let z = 0.01_f64; // f64 assert_eq!(type_of(&amp;x), &quot;f64&quot;.to_string()); println!(&quot;Success!&quot;);&#125;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; ğŸŒŸğŸŒŸ ä½¿ç”¨ä¸¤ç§æ–¹æ³•æ¥è®©ä¸‹é¢ä»£ç å·¥ä½œ 123fn main() &#123; assert!(0.1+0.2==0.3);&#125; My Answer 123fn main() &#123; assert!(0.1_f32+0.2_f32==0.3_f32);&#125; Answer 123fn main() &#123; assert!(0.1_f32+0.2_f32==0.3_f32);&#125; 123fn main() &#123; assert!((0.1_f64+ 0.2 - 0.3).abs() &lt; 0.001);&#125; åºåˆ— ğŸŒŸğŸŒŸ ä¸¤ä¸ªç›®æ ‡: 1. ä¿®æ”¹ assert! è®©å®ƒå·¥ä½œ 2. è®© println! è¾“å‡º: 97 - 122 123456789101112fn main() &#123; let mut sum = 0; for i in -3..2 &#123; sum += i &#125; assert!(sum == -3); for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123; println!(&quot;&#123;&#125;&quot;,c); &#125;&#125; My Answer 123456789101112fn main() &#123; let mut sum = 0; for i in -3..2 &#123; sum += i &#125; assert!(sum == -5); for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123; println!(&quot;&#123;&#125;&quot;,c as u8); &#125;&#125; Answer 123456789101112fn main() &#123; let mut sum = 0; for i in -3..2 &#123; sum += i &#125; assert!(sum == -5); for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123; println!(&quot;&#123;&#125;&quot;,c as u8); &#125;&#125; ğŸŒŸğŸŒŸ 123456// å¡«ç©ºuse std::ops::&#123;Range, RangeInclusive&#125;;fn main() &#123; assert_eq!((1..__), Range&#123; start: 1, end: 5 &#125;); assert_eq!((1..__), RangeInclusive::new(1, 5));&#125; My Answer 123456// å¡«ç©ºuse std::ops::&#123;Range, RangeInclusive&#125;;fn main() &#123; assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;); assert_eq!((1..=5), RangeInclusive::new(1, 5));&#125; Answer 123456// å¡«ç©ºuse std::ops::&#123;Range, RangeInclusive&#125;;fn main() &#123; assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;); assert_eq!((1..=5), RangeInclusive::new(1, 5));&#125; è®¡ç®— ğŸŒŸ 123456789101112131415161718192021222324252627// å¡«ç©ºï¼Œå¹¶è§£å†³é”™è¯¯fn main() &#123; // æ•´æ•°åŠ æ³• assert!(1u32 + 2 == __); // æ•´æ•°å‡æ³• assert!(1i32 - 2 == __); assert!(1u8 - 2 == -1); assert!(3 * 50 == __); assert!(9.6 / 3.2 == 3.0); // error ! ä¿®æ”¹å®ƒè®©ä»£ç å·¥ä½œ assert!(24 % 5 == __); // é€»è¾‘ä¸æˆ–éæ“ä½œ assert!(true &amp;&amp; false == __); assert!(true || false == __); assert!(!true == __); // ä½æ“ä½œ println!(&quot;0011 AND 0101 is &#123;:04b&#125;&quot;, 0b0011u32 &amp; 0b0101); println!(&quot;0011 OR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 | 0b0101); println!(&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 ^ 0b0101); println!(&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;, 1u32 &lt;&lt; 5); println!(&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;, 0x80u32 &gt;&gt; 2);&#125; My Answer 123456789101112131415161718192021222324252627// å¡«ç©ºï¼Œå¹¶è§£å†³é”™è¯¯fn main() &#123; // æ•´æ•°åŠ æ³• assert!(1u32 + 2 == 3); // æ•´æ•°å‡æ³• assert!(1i32 - 2 == -1); assert!(1i8 - 2 == -1); assert!(3 * 50 == 150); assert!(9 / 3 == 3); // error ! ä¿®æ”¹å®ƒè®©ä»£ç å·¥ä½œ assert!(24 % 5 == 4); // é€»è¾‘ä¸æˆ–éæ“ä½œ assert!(true &amp;&amp; false == false); assert!(true || false == true); assert!(!true == false); // ä½æ“ä½œ println!(&quot;0011 AND 0101 is &#123;:04b&#125;&quot;, 0b0011u32 &amp; 0b0101); println!(&quot;0011 OR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 | 0b0101); println!(&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 ^ 0b0101); println!(&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;, 1u32 &lt;&lt; 5); println!(&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;, 0x80u32 &gt;&gt; 2);&#125; Answer 12345678910111213141516171819202122232425fn main() &#123; // Integer addition assert!(1u32 + 2 == 3); // Integer subtraction assert!(1i32 - 2 == -1); assert!(1i8 - 2 == -1); assert!(3 * 50 == 150); assert!(9 / 3 == 3); // error ! make it work assert!(24 % 5 == 4); // Short-circuiting boolean logic assert!(true &amp;&amp; false == false); assert!(true || false == true); assert!(!true == false); // Bitwise operations println!(&quot;0011 AND 0101 is &#123;:04b&#125;&quot;, 0b0011u32 &amp; 0b0101); println!(&quot;0011 OR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 | 0b0101); println!(&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 ^ 0b0101); println!(&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;, 1u32 &lt;&lt; 5); println!(&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;, 0x80u32 &gt;&gt; 2);&#125; å­—ç¬¦ã€å¸ƒå°”ã€å•å…ƒç±»å‹å­—ç¬¦ ğŸŒŸ 123456789101112// ä¿®æ”¹2å¤„ `assert_eq!` è®©ä»£ç å·¥ä½œuse std::mem::size_of_val;fn main() &#123; let c1 = &#x27;a&#x27;; assert_eq!(size_of_val(&amp;c1),1); let c2 = &#x27;ä¸­&#x27;; assert_eq!(size_of_val(&amp;c2),3); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112// ä¿®æ”¹2å¤„ `assert_eq!` è®©ä»£ç å·¥ä½œuse std::mem::size_of_val;fn main() &#123; let c1 = &#x27;a&#x27;; assert_eq!(size_of_val(&amp;c1),4); let c2 = &#x27;ä¸­&#x27;; assert_eq!(size_of_val(&amp;c2),4); println!(&quot;Success!&quot;)&#125; Answer 123456789use std::mem::size_of_val;fn main() &#123; let c1 = &#x27;a&#x27;; assert_eq!(size_of_val(&amp;c1), 4); let c2 = &#x27;ä¸­&#x27;; assert_eq!(size_of_val(&amp;c2), 4);&#125; ğŸŒŸ 123456789// ä¿®æ”¹ä¸€è¡Œè®©ä»£ç æ­£å¸¸æ‰“å°fn main() &#123; let c1 = &quot;ä¸­&quot;; print_char(c1);&#125; fn print_char(c : char) &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; My Answer 123456789// ä¿®æ”¹ä¸€è¡Œè®©ä»£ç æ­£å¸¸æ‰“å°fn main() &#123; let c1 = &quot;ä¸­&quot;; print_char(c1);&#125; fn print_char(c : &amp;str) &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; Answer 12345678fn main() &#123; let c1 = &#x27;ä¸­&#x27;; print_char(c1);&#125;fn print_char(c: char) &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; å¸ƒå°” ğŸŒŸ 123456789// ä½¿æˆåŠŸæ‰“å°fn main() &#123; let _f: bool = false; let t = true; if !t &#123; println!(&quot;Success!&quot;) &#125;&#125; My Answer 123456789// ä½¿æˆåŠŸæ‰“å°fn main() &#123; let _f: bool = false; let t = true; if t &#123; println!(&quot;Success!&quot;) &#125;&#125; Answer 12345678fn main() &#123; let _f: bool = false; let t = false; if !t &#123; println!(&quot;hello, world&quot;); &#125;&#125; ğŸŒŸ 1234567fn main() &#123; let f = true; let t = true &amp;&amp; false; assert_eq!(t, f); println!(&quot;Success!&quot;)&#125; My Answer 1234567fn main() &#123; let f = true; let t = true || false; assert_eq!(t, f); println!(&quot;Success!&quot;)&#125; Answer 12345fn main() &#123; let f = true; let t = true || false; assert_eq!(t, f);&#125; å•å…ƒç±»å‹ ğŸŒŸğŸŒŸ 123456789101112131415161718// è®©ä»£ç å·¥ä½œï¼Œä½†ä¸è¦ä¿®æ”¹ `implicitly_ret_unit` !fn main() &#123; let _v: () = (); let v = (2, 3); assert_eq!(v, implicitly_ret_unit()); println!(&quot;Success!&quot;)&#125;fn implicitly_ret_unit() &#123; println!(&quot;I will return a ()&quot;)&#125;// ä¸è¦ä½¿ç”¨ä¸‹é¢çš„å‡½æ•°ï¼Œå®ƒåªç”¨äºæ¼”ç¤ºï¼fn explicitly_ret_unit() -&gt; () &#123; println!(&quot;I will return a ()&quot;)&#125; My Answer 123456789101112131415161718// è®©ä»£ç å·¥ä½œï¼Œä½†ä¸è¦ä¿®æ”¹ `implicitly_ret_unit` !fn main() &#123; let u: () = (); let _vv = (2, 3); assert_eq!(u, implicitly_ret_unit()); println!(&quot;Success!&quot;)&#125;fn implicitly_ret_unit() &#123; println!(&quot;I will return a ()&quot;)&#125;// ä¸è¦ä½¿ç”¨ä¸‹é¢çš„å‡½æ•°ï¼Œå®ƒåªç”¨äºæ¼”ç¤ºï¼fn explicitly_ret_unit() -&gt; () &#123; println!(&quot;I will return a ()&quot;)&#125; Answer 123456789101112131415fn main() &#123; let v0: () = (); let v = (2, 3); assert_eq!(v0, implicitly_ret_unit())&#125;fn implicitly_ret_unit() &#123; println!(&quot;I will return a ()&quot;)&#125;// don&#x27;t use this onefn explicitly_ret_unit() -&gt; () &#123; println!(&quot;I will return a ()&quot;)&#125; ğŸŒŸğŸŒŸ å•å…ƒç±»å‹å ç”¨çš„å†…å­˜å¤§å°æ˜¯å¤šå°‘ï¼Ÿ 12345678// è®©ä»£ç å·¥ä½œï¼šä¿®æ”¹ `assert!` ä¸­çš„ `4` use std::mem::size_of_val;fn main() &#123; let unit: () = (); assert!(size_of_val(&amp;unit) == 4); println!(&quot;Success!&quot;)&#125; My Answer 1 &#x2F;&#x2F; è®©ä»£ç å·¥ä½œï¼šä¿®æ”¹ assert! ä¸­çš„ 4use std::mem::size_of_val;fn main() { let unit: () = (); assert!(size_of_val(&amp;unit) == 0); println!(&quot;Success!&quot;) } 1 Answer 1234567use std::mem::size_of_val;fn main() &#123; let unit: () = (); // unit type does&#x27;t occupy any memeory space assert!(size_of_val(&amp;unit) == 0);&#125; è¯­å¥å’Œè¡¨è¾¾å¼ç¤ºä¾‹1234567891011121314151617181920fn main() &#123; let x = 5u32; let y = &#123; let x_squared = x * x; let x_cube = x_squared * x; // ä¸‹é¢è¡¨è¾¾å¼çš„å€¼å°†è¢«èµ‹ç»™ `y` x_cube + x_squared + x &#125;; let z = &#123; // åˆ†å·è®©è¡¨è¾¾å¼å˜æˆäº†è¯­å¥ï¼Œå› æ­¤è¿”å›çš„ä¸å†æ˜¯è¡¨è¾¾å¼ `2 * x` çš„å€¼ï¼Œè€Œæ˜¯è¯­å¥çš„å€¼ `()` 2 * x; &#125;; println!(&quot;x is &#123;:?&#125;&quot;, x); println!(&quot;y is &#123;:?&#125;&quot;, y); println!(&quot;z is &#123;:?&#125;&quot;, z);&#125; ç»ƒä¹  ğŸŒŸğŸŒŸ 123456789// ä½¿ç”¨ä¸¤ç§æ–¹æ³•è®©ä»£ç å·¥ä½œèµ·æ¥fn main() &#123; let v = &#123; let mut x = 1; x += 2 &#125;; assert_eq!(v, 3);&#125; My Answer 123456789// ä½¿ç”¨ä¸¤ç§æ–¹æ³•è®©ä»£ç å·¥ä½œèµ·æ¥fn main() &#123; let v = &#123; let mut x = 1; x += 2 &#125;; assert_eq!(v, ());&#125; 12345678910// ä½¿ç”¨ä¸¤ç§æ–¹æ³•è®©ä»£ç å·¥ä½œèµ·æ¥fn main() &#123; let v = &#123; let mut x = 1; x += 2; x &#125;; assert_eq!(v, 3);&#125; Answer 12345678fn main() &#123; let v = &#123; let mut x = 1; x += 2 &#125;; assert_eq!(v, ()); &#125; 123456789fn main() &#123; let v = &#123; let mut x = 1; x += 2; x &#125;; assert_eq!(v, 3);&#125; ğŸŒŸ 12345fn main() &#123; let v = (let x = 3); assert!(v == 3);&#125; My Answer 12345678fn main() &#123; let v = &#123; let x = 3; x &#125;; assert!(v == 3);&#125; Answer 12345678fn main() &#123; let v = &#123; let x = 3; x &#125;; assert!(v == 3);&#125; ğŸŒŸ 12345678fn main() &#123; let s = sum(1 , 2); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y;&#125; My Answer 12345678fn main() &#123; let s = sum(1 , 2); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y&#125; Answer 12345678fn main() &#123; let s = sum(1 , 2); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y&#125; å‡½æ•° ğŸŒŸğŸŒŸğŸŒŸ 1234567891011fn main() &#123; // ä¸è¦ä¿®æ”¹ä¸‹é¢ä¸¤è¡Œä»£ç ! let (x, y) = (1, 2); let s = sum(x, y); assert_eq!(s, 3);&#125;fn sum(x, y: i32) &#123; x + y;&#125; My Answer 1234567891011fn main() &#123; // ä¸è¦ä¿®æ”¹ä¸‹é¢ä¸¤è¡Œä»£ç ! let (x, y) = (1, 2); let s = sum(x, y); assert_eq!(s, 3);&#125;fn sum(x : i32, y: i32) -&gt; i32&#123; x + y&#125; Answer 1234567891011fn main() &#123; // don&#x27;t modify the following two lines! let (x, y) = (1, 2); let s = sum(x, y); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y&#125; ğŸŒŸğŸŒŸ 12345678fn main() &#123; print();&#125;// ä½¿ç”¨å¦ä¸€ä¸ªç±»å‹æ¥æ›¿ä»£ i32fn print() -&gt; i32 &#123; println!(&quot;hello,world&quot;);&#125; My Answer 12345678fn main() &#123; print();&#125;// ä½¿ç”¨å¦ä¸€ä¸ªç±»å‹æ¥æ›¿ä»£ i32fn print() -&gt; () &#123; println!(&quot;hello,world&quot;);&#125; Answer 12345678fn main() &#123; print();&#125;// replace i32 with another typefn print() -&gt; () &#123; println!(&quot;hello,world&quot;);&#125; ğŸŒŸğŸŒŸğŸŒŸ 123456789// ç”¨ä¸¤ç§æ–¹æ³•æ±‚è§£fn main() &#123; never_return();&#125;fn never_return() -&gt; ! &#123; // å®ç°è¿™ä¸ªå‡½æ•°ï¼Œä¸è¦ä¿®æ”¹å‡½æ•°ç­¾å!&#125; My Answer ä¸ä¼š Answer 12345678fn main() &#123; never_return();&#125;fn never_return() -&gt; ! &#123; // implement this function, don&#x27;t modify fn signatures panic!(&quot;I return nothing!&quot;)&#125; ğŸŒŸğŸŒŸ å‘æ•£å‡½æ•°( Diverging function )ä¸ä¼šè¿”å›ä»»ä½•å€¼ï¼Œå› æ­¤å®ƒä»¬å¯ä»¥ç”¨äºæ›¿ä»£éœ€è¦è¿”å›ä»»ä½•å€¼çš„åœ°æ–¹ 12345678910111213141516171819202122fn main() &#123; println!(&quot;Success!&quot;);&#125;fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123; match tp &#123; 1 =&gt; &#123; // TODO &#125; _ =&gt; &#123; // TODO &#125; &#125;; // è¿™é‡Œä¸å…¶è¿”å›ä¸€ä¸ª Noneï¼Œä¸å¦‚ä½¿ç”¨å‘æ•£å‡½æ•°æ›¿ä»£ never_return_fn()&#125;// ä½¿ç”¨ä¸‰ç§æ–¹æ³•å®ç°ä»¥ä¸‹å‘æ•£å‡½æ•°fn never_return_fn() -&gt; ! &#123;&#125; My Answer ä¸ä¼š Answer 12345678910111213141516171819202122fn main() &#123; println!(&quot;Success!&quot;);&#125;fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123; match tp &#123; 1 =&gt; &#123; // TODO &#125; _ =&gt; &#123; // TODO &#125; &#125;; never_return_fn()&#125;// IMPLEMENT this function// DON&#x27;T change any code elsefn never_return_fn() -&gt; ! &#123; unimplemented!()&#125; 1234// IMPLEMENT this function in THREE waysfn never_return_fn() -&gt; ! &#123; panic!()&#125; 1234// IMPLEMENT this function in THREE waysfn never_return_fn() -&gt; ! &#123; todo!();&#125; 123456// IMPLEMENT this function in THREE waysfn never_return_fn() -&gt; ! &#123; loop &#123; std::thread::sleep(std::time::Duration::from_secs(1)) &#125;&#125; ğŸŒŸğŸŒŸ 123456789101112131415fn main() &#123; // å¡«ç©º let b = __; let _v = match b &#123; true =&gt; 1, // å‘æ•£å‡½æ•°ä¹Ÿå¯ä»¥ç”¨äº `match` è¡¨è¾¾å¼ï¼Œç”¨äºæ›¿ä»£ä»»ä½•ç±»å‹çš„å€¼ false =&gt; &#123; println!(&quot;Success!&quot;); panic!(&quot;we have no value for `false`, but we can panic&quot;) &#125; &#125;; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; My Answer 123456789101112131415fn main() &#123; // å¡«ç©º let b = true; let _v = match b &#123; true =&gt; 1, // å‘æ•£å‡½æ•°ä¹Ÿå¯ä»¥ç”¨äº `match` è¡¨è¾¾å¼ï¼Œç”¨äºæ›¿ä»£ä»»ä½•ç±»å‹çš„å€¼ false =&gt; &#123; println!(&quot;Success!&quot;); panic!(&quot;we have no value for `false`, but we can panic&quot;) &#125; &#125;; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; Answer 123456789101112131415fn main() &#123; // FILL in the blank let b = false; let _v = match b &#123; true =&gt; 1, // Diverging functions can also be used in match expression false =&gt; &#123; println!(&quot;Success!&quot;); panic!(&quot;we have no value for `false`, but we can panic&quot;) &#125; &#125;; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rustå­¦ä¹  ç»ƒä¹ 1 å˜é‡ç»‘å®šä¸è§£æ„","slug":"Rustå­¦ä¹ -ç»ƒä¹ 1-å˜é‡ç»‘å®šä¸è§£æ„","date":"2023-08-23T13:01:30.000Z","updated":"2023-09-11T13:11:33.952Z","comments":true,"path":"2023/08/23/Rustå­¦ä¹ -ç»ƒä¹ 1-å˜é‡ç»‘å®šä¸è§£æ„/","link":"","permalink":"http://example.com/2023/08/23/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A01-%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84/","excerpt":"å˜é‡ç»‘å®šä¸è§£æ„ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) å˜é‡ç»‘å®šä¸è§£æ„ç»‘å®šä¸å¯å˜æ€§","text":"å˜é‡ç»‘å®šä¸è§£æ„ - Rust By Practice( Rust ç»ƒä¹ å®è·µ ) å˜é‡ç»‘å®šä¸è§£æ„ç»‘å®šä¸å¯å˜æ€§ ğŸŒŸ å˜é‡åªæœ‰åœ¨åˆå§‹åŒ–åæ‰èƒ½è¢«ä½¿ç”¨ 123456// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶å°½å¯èƒ½å°‘çš„ä¿®æ”¹fn main() &#123; let x: i32; // æœªåˆå§‹åŒ–ï¼Œä½†è¢«ä½¿ç”¨ let y: i32; // æœªåˆå§‹åŒ–ï¼Œä¹Ÿæœªè¢«ä½¿ç”¨ println!(&quot;x is equal to &#123;&#125;&quot;, x); &#125; My Answer 123456// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶å°½å¯èƒ½å°‘çš„ä¿®æ”¹fn main() &#123; let x: i32 = 10; // æœªåˆå§‹åŒ–ï¼Œä½†è¢«ä½¿ç”¨ let y: i32; // æœªåˆå§‹åŒ–ï¼Œä¹Ÿæœªè¢«ä½¿ç”¨ println!(&quot;&#123;&#125; is equal to 10&quot;, x); &#125; Answer 12345fn main() &#123; let x: i32 = 5; // unintialized but using, ERROR ! let y: i32; // uninitialized but also unusing, only warning println!(&quot;&#123;&#125; is equal to 5&quot;, x);&#125; -2. ğŸŒŸğŸŒŸ å¯ä»¥ä½¿ç”¨ mut å°†å˜é‡æ ‡è®°ä¸ºå¯å˜ 1234567// å®Œå½¢å¡«ç©ºï¼Œè®©ä»£ç ç¼–è¯‘fn main() &#123; let __ = 1; __ += 2; println!(&quot;x = &#123;&#125;&quot;, x); &#125; My Answer 1234567// å®Œå½¢å¡«ç©ºï¼Œè®©ä»£ç ç¼–è¯‘fn main() &#123; let mut x = 1; x += 2; println!(&quot;x = &#123;&#125;&quot;, x); &#125; Answer 123456fn main() &#123; let mut x = 1; x += 2; println!(&quot;&#123;&#125; is equal to 3&quot;, x);&#125; å˜é‡ä½œç”¨åŸŸ ğŸŒŸ ä½œç”¨åŸŸæ˜¯ä¸€ä¸ªå˜é‡åœ¨ç¨‹åºä¸­èƒ½å¤Ÿä¿æŒåˆæ³•çš„èŒƒå›´ 123456789// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶ä½¿ç”¨å°½å¯èƒ½å°‘çš„æ”¹å˜fn main() &#123; let x: i32 = 10; &#123; let y: i32 = 5; println!(&quot;x çš„å€¼æ˜¯ &#123;&#125;, y çš„å€¼æ˜¯ &#123;&#125;&quot;, x, y); &#125; println!(&quot;x çš„å€¼æ˜¯ &#123;&#125;, y çš„å€¼æ˜¯ &#123;&#125;&quot;, x, y); &#125; My Answer 1234567891011// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶ä½¿ç”¨å°½å¯èƒ½å°‘çš„æ”¹å˜fn main() &#123; let x: i32 = 10; let y: i32 = 10; &#123; let y: i32 = 5; let x: i32 = 5; println!(&quot;x çš„å€¼æ˜¯ &#123;&#125;, y çš„å€¼æ˜¯ &#123;&#125;&quot;, x, y); &#125; println!(&quot;x çš„å€¼æ˜¯ &#123;&#125;, y çš„å€¼æ˜¯ &#123;&#125;&quot;, x, y); &#125; Answer 123456789fn main() &#123; let x: i32 = 10; let y: i32 = 20; &#123; let y: i32 = 5; println!(&quot;The value of x is &#123;&#125; and value of y is &#123;&#125;&quot;, x, y); &#125; println!(&quot;The value of x is &#123;&#125; and value of y is &#123;&#125;&quot;, x, y); &#125; ğŸŒŸğŸŒŸ 12345678// ä¿®å¤é”™è¯¯fn main() &#123; println!(&quot;&#123;&#125;, world&quot;, x); &#125;fn define_x() &#123; let x = &quot;hello&quot;;&#125; My Answer 12345678910// ä¿®å¤é”™è¯¯fn main() &#123; let x = define_x(); println!(&quot;&#123;&#125;, world&quot;, x); &#125;fn define_x() -&gt; String&#123; let x = &quot;hello&quot;.to_string(); x&#125; Answer 123456789fn main() &#123; let x = define_x(); println!(&quot;&#123;&#125;, world&quot;, x);&#125;fn define_x() -&gt; String &#123; let x = &quot;hello&quot;.to_string(); x&#125; 123456789fn main() &#123; let x = define_x(); println!(&quot;&#123;:?&#125;, world&quot;, x);&#125;fn define_x() -&gt; &amp;&#x27;static str &#123; let x = &quot;hello&quot;; x&#125; å˜é‡é®è”½ ğŸŒŸğŸŒŸ è‹¥åé¢çš„å˜é‡å£°æ˜çš„åç§°å’Œä¹‹å‰çš„å˜é‡ç›¸åŒï¼Œåˆ™æˆ‘ä»¬è¯´ï¼šç¬¬ä¸€ä¸ªå˜é‡è¢«ç¬¬äºŒä¸ªåŒåå˜é‡é®è”½äº†( shadowing ) 12345678910111213// åªå…è®¸ä¿®æ”¹ `assert_eq!` æ¥è®© `println!` å·¥ä½œ(åœ¨ç»ˆç«¯è¾“å‡º `42`)fn main() &#123; let x: i32 = 5; &#123; let x = 12; assert_eq!(x, 5); &#125; assert_eq!(x, 12); let x = 42; println!(&quot;&#123;&#125;&quot;, x); // è¾“å‡º &quot;42&quot;.&#125; My Answer 12345678910111213// åªå…è®¸ä¿®æ”¹ `assert_eq!` æ¥è®© `println!` å·¥ä½œ(åœ¨ç»ˆç«¯è¾“å‡º `42`)fn main() &#123; let x: i32 = 5; &#123; let x = 12; assert_eq!(x, 12); &#125; assert_eq!(x, 5); let x = 42; println!(&quot;&#123;&#125;&quot;, x); // è¾“å‡º &quot;42&quot;.&#125; Answer 123456789101112fn main() &#123; let x: i32 = 5; &#123; let x = 12; assert_eq!(x, 12); &#125; assert_eq!(x, 5); let x = 42; println!(&quot;&#123;&#125;&quot;, x); // Prints &quot;42&quot;.&#125; ğŸŒŸğŸŒŸ ä¿®æ”¹ä¸€è¡Œä»£ç ä»¥é€šè¿‡ç¼–è¯‘ 123456fn main() &#123; let mut x: i32 = 1; x = 7; // é®è”½ä¸”å†æ¬¡ç»‘å®š let x = x; x += 3; let y = 4; // é®è”½ let y = &quot;I can also be bound to text!&quot;; } 123456789101112131415- My Answer ```rust fn main() &#123; let mut x: i32 = 1; x = 7; // é®è”½ä¸”å†æ¬¡ç»‘å®š let mut x = x; x += 3; let y = 4; // é®è”½ let y = &quot;I can also be bound to text!&quot;; &#125; Answer 12345fn main() &#123; let mut x: i32 = 1; x = 7; // Shadowing and re-binding let x = x; let y = 4; // Shadowing let y = &quot;I can also be bound to text!&quot;; println!(&quot;Success!&quot;); } æœªä½¿ç”¨çš„å˜é‡ ä½¿ç”¨ä»¥ä¸‹æ–¹æ³•æ¥ä¿®å¤ç¼–è¯‘å™¨è¾“å‡ºçš„ warning : ğŸŒŸ ä¸€ç§æ–¹æ³• ğŸŒŸğŸŒŸ ä¸¤ç§æ–¹æ³• 12345fn main() &#123; let x = 1; &#125;// compiler warning: unused variable: `x` My Answer 123456fn main() &#123; let _x = 1; &#125;// compiler warning: unused variable: `x` Answer 1234#[allow(unused_variables)]fn main() &#123; let x = 1;&#125; 123fn main() &#123; let _x = 1;&#125; å˜é‡è§£æ„ ğŸŒŸğŸŒŸ æˆ‘ä»¬å¯ä»¥å°† let è·Ÿä¸€ä¸ªæ¨¡å¼ä¸€èµ·ä½¿ç”¨æ¥è§£æ„ä¸€ä¸ªå…ƒç»„ï¼Œæœ€ç»ˆå°†å®ƒè§£æ„ä¸ºå¤šä¸ªç‹¬ç«‹çš„å˜é‡ æç¤º: å¯ä»¥ä½¿ç”¨å˜é‡é®è”½æˆ–å¯å˜æ€§ 12345678// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶å°½å¯èƒ½å°‘çš„ä¿®æ”¹fn main() &#123; let (x, y) = (1, 2); x += 2; assert_eq!(x, 3); assert_eq!(y, 2);&#125; My Answer 12345678// ä¿®å¤ä¸‹é¢ä»£ç çš„é”™è¯¯å¹¶å°½å¯èƒ½å°‘çš„ä¿®æ”¹fn main() &#123; let (mut x, y) = (1, 2); x += 2; assert_eq!(x, 3); assert_eq!(y, 2);&#125; Answer 1234567fn main() &#123; let (mut x, y) = (1, 2); x += 2; assert_eq!(x, 3); assert_eq!(y, 2);&#125; 1234567fn main() &#123; let (x, y) = (1, 2); let x = 3; assert_eq!(x, 3); assert_eq!(y, 2);&#125; è§£æ„å¼èµ‹å€¼è¯¥åŠŸèƒ½äº Rust 1.59 ç‰ˆæœ¬å¼•å…¥ï¼šä½ å¯ä»¥åœ¨èµ‹å€¼è¯­å¥çš„å·¦å¼ä¸­ä½¿ç”¨å…ƒç»„ã€åˆ‡ç‰‡æˆ–ç»“æ„ä½“è¿›è¡ŒåŒ¹é…èµ‹å€¼ã€‚ ğŸŒŸğŸŒŸ 1234567fn main() &#123; let (x, y); (x,..) = (3, 4); [.., y] = [1, 2]; // å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ assert_eq!([x,y], __);&#125; My Answer 1234567fn main() &#123; let (x, y); (x,..) = (3, 4); [.., y] = [1, 2]; // å¡«ç©ºï¼Œè®©ä»£ç å·¥ä½œ assert_eq!([x,y], [3,2]);&#125; Answer 1234567fn main() &#123; let (x, y); (x, ..) = (3, 4); [.., y] = [1, 2]; // fill the blank to make the code work assert_eq!([x, y], [3, 2]);&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"å­¦ä¹  Linux fs/namespace.cæºç åˆ†æ","slug":"å­¦ä¹ -Linux-fs-namespace-cæºç åˆ†æ","date":"2023-08-17T04:46:51.000Z","updated":"2023-08-20T10:36:33.193Z","comments":true,"path":"2023/08/17/å­¦ä¹ -Linux-fs-namespace-cæºç åˆ†æ/","link":"","permalink":"http://example.com/2023/08/17/%E5%AD%A6%E4%B9%A0-Linux-fs-namespace-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: GPL-2.0-only/* * linux/fs/namespace.c * * (C) Copyright Al Viro 2000, 2001 * * Based on code from fs/super.c, copyright Linus Torvalds and others. * Heavily rewritten. */#include &lt;linux/syscalls.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/capability.h&gt;#include &lt;linux/mnt_namespace.h&gt;#include &lt;linux/user_namespace.h&gt;#include &lt;linux/namei.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/cred.h&gt;#include &lt;linux/idr.h&gt;#include &lt;linux/init.h&gt; /* init_rootfs */#include &lt;linux/fs_struct.h&gt; /* get_fs_root et.al. */#include &lt;linux/fsnotify.h&gt; /* fsnotify_vfsmount_delete */#include &lt;linux/file.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/proc_ns.h&gt;#include &lt;linux/magic.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/task_work.h&gt;#include &lt;linux/sched/task.h&gt;#include &lt;uapi/linux/mount.h&gt;#include &lt;linux/fs_context.h&gt;#include &lt;linux/shmem_fs.h&gt;#include &lt;linux/mnt_idmapping.h&gt;#include &quot;pnode.h&quot;#include &quot;internal.h&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Maximum number of mounts in a mount namespace */static unsigned int sysctl_mount_max __read_mostly = 100000;static unsigned int m_hash_mask __read_mostly;static unsigned int m_hash_shift __read_mostly;static unsigned int mp_hash_mask __read_mostly;static unsigned int mp_hash_shift __read_mostly;static __initdata unsigned long mhash_entries;// è®¾ç½®mhash_entriesçš„å€¼static int __init set_mhash_entries(char *str)&#123; if (!str) return 0; mhash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// åœ¨å†…æ ¸å¯åŠ¨æ—¶è®¾ç½®mhash_entriesçš„å€¼__setup(&quot;mhash_entries=&quot;, set_mhash_entries);static __initdata unsigned long mphash_entries;// è®¾ç½®mphash_entriesçš„å€¼static int __init set_mphash_entries(char *str)&#123; if (!str) return 0; mphash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// åœ¨å†…æ ¸å¯åŠ¨æ—¶è®¾ç½®mphash_entriesçš„å€¼__setup(&quot;mphash_entries=&quot;, set_mphash_entries);static u64 event;static DEFINE_IDA(mnt_id_ida); // æŒ‚è½½ç‚¹IDåˆ†é…å™¨static DEFINE_IDA(mnt_group_ida); // æŒ‚è½½ç»„IDåˆ†é…å™¨static struct hlist_head *mount_hashtable __read_mostly; // æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨static struct hlist_head *mountpoint_hashtable __read_mostly; // æŒ‚è½½ç›®å½•å“ˆå¸Œè¡¨static struct kmem_cache *mnt_cache __read_mostly; // æŒ‚è½½ç»“æ„ä½“çš„SLABç¼“å­˜static DECLARE_RWSEM(namespace_sem); // å‘½åç©ºé—´ä¿¡å·é‡static HLIST_HEAD(unmounted); /* æœªæŒ‚è½½çš„æŒ‚è½½ç‚¹é“¾è¡¨ï¼Œç”±namespace_semä¿æŠ¤ */static LIST_HEAD(ex_mountpoints); /* å·²å­˜åœ¨çš„æŒ‚è½½ç›®å½•é“¾è¡¨ï¼Œç”±namespace_semä¿æŠ¤ */ 123456789101112131415161718192021222324252627282930313233struct mount_kattr &#123; unsigned int attr_set; // æŒ‚è½½å±æ€§è®¾ç½® unsigned int attr_clr; // æŒ‚è½½å±æ€§æ¸…é™¤ unsigned int propagation; // æŒ‚è½½ä¼ æ’­æ ‡å¿— unsigned int lookup_flags; // æŒ‚è½½ç‚¹æŸ¥æ‰¾æ ‡å¿— bool recurse; // æ˜¯å¦é€’å½’ struct user_namespace *mnt_userns; // æŒ‚è½½çš„ç”¨æˆ·å‘½åç©ºé—´ struct mnt_idmap *mnt_idmap; // æŒ‚è½½çš„IDæ˜ å°„&#125;;/* /sys/fs */struct kobject *fs_kobj; // æ–‡ä»¶ç³»ç»Ÿçš„å†…æ ¸å¯¹è±¡/* * vfsmounté”å¯èƒ½è¢«ä»¥è¯»æ¨¡å¼è·å–ï¼Œä»¥é˜²æ­¢å¯¹vfsmountå“ˆå¸Œè¡¨çš„æ›´æ”¹ï¼Œ * ä¾‹å¦‚åœ¨æŒ‚è½½ç‚¹æŸ¥æ‰¾æˆ–å‘ä¸Šéå†æ ‘æ—¶ã€‚ * * åœ¨æ‰€æœ‰ä¿®æ”¹vfsmountæ ‘æˆ–å“ˆå¸Œè¡¨çš„æƒ…å†µä¸‹ï¼Œæˆ–è€…åœ¨ä¿®æ”¹vfsmountç»“æ„ä½“æ—¶ï¼Œ * åº”ä»¥å†™æ¨¡å¼è·å–è¯¥é”ã€‚ */__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock); // vfsmounté”// è·å–mount_lockå†™é”çš„è¾…åŠ©å‡½æ•°static inline void lock_mount_hash(void)&#123; write_seqlock(&amp;mount_lock);&#125;// é‡Šæ”¾mount_lockå†™é”çš„è¾…åŠ©å‡½æ•°static inline void unlock_mount_hash(void)&#123; write_sequnlock(&amp;mount_lock);&#125;","text":"12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: GPL-2.0-only/* * linux/fs/namespace.c * * (C) Copyright Al Viro 2000, 2001 * * Based on code from fs/super.c, copyright Linus Torvalds and others. * Heavily rewritten. */#include &lt;linux/syscalls.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/capability.h&gt;#include &lt;linux/mnt_namespace.h&gt;#include &lt;linux/user_namespace.h&gt;#include &lt;linux/namei.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/cred.h&gt;#include &lt;linux/idr.h&gt;#include &lt;linux/init.h&gt; /* init_rootfs */#include &lt;linux/fs_struct.h&gt; /* get_fs_root et.al. */#include &lt;linux/fsnotify.h&gt; /* fsnotify_vfsmount_delete */#include &lt;linux/file.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/proc_ns.h&gt;#include &lt;linux/magic.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/task_work.h&gt;#include &lt;linux/sched/task.h&gt;#include &lt;uapi/linux/mount.h&gt;#include &lt;linux/fs_context.h&gt;#include &lt;linux/shmem_fs.h&gt;#include &lt;linux/mnt_idmapping.h&gt;#include &quot;pnode.h&quot;#include &quot;internal.h&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Maximum number of mounts in a mount namespace */static unsigned int sysctl_mount_max __read_mostly = 100000;static unsigned int m_hash_mask __read_mostly;static unsigned int m_hash_shift __read_mostly;static unsigned int mp_hash_mask __read_mostly;static unsigned int mp_hash_shift __read_mostly;static __initdata unsigned long mhash_entries;// è®¾ç½®mhash_entriesçš„å€¼static int __init set_mhash_entries(char *str)&#123; if (!str) return 0; mhash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// åœ¨å†…æ ¸å¯åŠ¨æ—¶è®¾ç½®mhash_entriesçš„å€¼__setup(&quot;mhash_entries=&quot;, set_mhash_entries);static __initdata unsigned long mphash_entries;// è®¾ç½®mphash_entriesçš„å€¼static int __init set_mphash_entries(char *str)&#123; if (!str) return 0; mphash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// åœ¨å†…æ ¸å¯åŠ¨æ—¶è®¾ç½®mphash_entriesçš„å€¼__setup(&quot;mphash_entries=&quot;, set_mphash_entries);static u64 event;static DEFINE_IDA(mnt_id_ida); // æŒ‚è½½ç‚¹IDåˆ†é…å™¨static DEFINE_IDA(mnt_group_ida); // æŒ‚è½½ç»„IDåˆ†é…å™¨static struct hlist_head *mount_hashtable __read_mostly; // æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨static struct hlist_head *mountpoint_hashtable __read_mostly; // æŒ‚è½½ç›®å½•å“ˆå¸Œè¡¨static struct kmem_cache *mnt_cache __read_mostly; // æŒ‚è½½ç»“æ„ä½“çš„SLABç¼“å­˜static DECLARE_RWSEM(namespace_sem); // å‘½åç©ºé—´ä¿¡å·é‡static HLIST_HEAD(unmounted); /* æœªæŒ‚è½½çš„æŒ‚è½½ç‚¹é“¾è¡¨ï¼Œç”±namespace_semä¿æŠ¤ */static LIST_HEAD(ex_mountpoints); /* å·²å­˜åœ¨çš„æŒ‚è½½ç›®å½•é“¾è¡¨ï¼Œç”±namespace_semä¿æŠ¤ */ 123456789101112131415161718192021222324252627282930313233struct mount_kattr &#123; unsigned int attr_set; // æŒ‚è½½å±æ€§è®¾ç½® unsigned int attr_clr; // æŒ‚è½½å±æ€§æ¸…é™¤ unsigned int propagation; // æŒ‚è½½ä¼ æ’­æ ‡å¿— unsigned int lookup_flags; // æŒ‚è½½ç‚¹æŸ¥æ‰¾æ ‡å¿— bool recurse; // æ˜¯å¦é€’å½’ struct user_namespace *mnt_userns; // æŒ‚è½½çš„ç”¨æˆ·å‘½åç©ºé—´ struct mnt_idmap *mnt_idmap; // æŒ‚è½½çš„IDæ˜ å°„&#125;;/* /sys/fs */struct kobject *fs_kobj; // æ–‡ä»¶ç³»ç»Ÿçš„å†…æ ¸å¯¹è±¡/* * vfsmounté”å¯èƒ½è¢«ä»¥è¯»æ¨¡å¼è·å–ï¼Œä»¥é˜²æ­¢å¯¹vfsmountå“ˆå¸Œè¡¨çš„æ›´æ”¹ï¼Œ * ä¾‹å¦‚åœ¨æŒ‚è½½ç‚¹æŸ¥æ‰¾æˆ–å‘ä¸Šéå†æ ‘æ—¶ã€‚ * * åœ¨æ‰€æœ‰ä¿®æ”¹vfsmountæ ‘æˆ–å“ˆå¸Œè¡¨çš„æƒ…å†µä¸‹ï¼Œæˆ–è€…åœ¨ä¿®æ”¹vfsmountç»“æ„ä½“æ—¶ï¼Œ * åº”ä»¥å†™æ¨¡å¼è·å–è¯¥é”ã€‚ */__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock); // vfsmounté”// è·å–mount_lockå†™é”çš„è¾…åŠ©å‡½æ•°static inline void lock_mount_hash(void)&#123; write_seqlock(&amp;mount_lock);&#125;// é‡Šæ”¾mount_lockå†™é”çš„è¾…åŠ©å‡½æ•°static inline void unlock_mount_hash(void)&#123; write_sequnlock(&amp;mount_lock);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)&#123; // è®¡ç®—å“ˆå¸Œå€¼ unsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES); tmp += ((unsigned long)dentry / L1_CACHE_BYTES); tmp = tmp + (tmp &gt;&gt; m_hash_shift); // è¿”å›å“ˆå¸Œè¡¨ä¸­çš„å¤´èŠ‚ç‚¹ return &amp;mount_hashtable[tmp &amp; m_hash_mask];&#125;static inline struct hlist_head *mp_hash(struct dentry *dentry)&#123; // è®¡ç®—å“ˆå¸Œå€¼ unsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES); tmp = tmp + (tmp &gt;&gt; mp_hash_shift); // è¿”å›å“ˆå¸Œè¡¨ä¸­çš„å¤´èŠ‚ç‚¹ return &amp;mountpoint_hashtable[tmp &amp; mp_hash_mask];&#125;static int mnt_alloc_id(struct mount *mnt)&#123; // åˆ†é…ä¸€ä¸ªæ–°çš„æŒ‚è½½ç‚¹ID int res = ida_alloc(&amp;mnt_id_ida, GFP_KERNEL); if (res &lt; 0) return res; // å°†åˆ†é…çš„IDèµ‹å€¼ç»™æŒ‚è½½ç‚¹ç»“æ„ä½“ mnt-&gt;mnt_id = res; return 0;&#125;static void mnt_free_id(struct mount *mnt)&#123; // é‡Šæ”¾æŒ‚è½½ç‚¹ID ida_free(&amp;mnt_id_ida, mnt-&gt;mnt_id);&#125;/* * åˆ†é…ä¸€ä¸ªæ–°çš„å¯¹ç­‰ç»„ID */static int mnt_alloc_group_id(struct mount *mnt)&#123; // åˆ†é…ä¸€ä¸ªæœ€å°çš„å¯¹ç­‰ç»„ID int res = ida_alloc_min(&amp;mnt_group_ida, 1, GFP_KERNEL); if (res &lt; 0) return res; // å°†åˆ†é…çš„IDèµ‹å€¼ç»™æŒ‚è½½ç‚¹ç»“æ„ä½“ mnt-&gt;mnt_group_id = res; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static struct mount *alloc_vfsmnt(const char *name)&#123; // åˆ†é…ä¸€ä¸ªæ–°çš„æŒ‚è½½ç‚¹ç»“æ„ä½“ struct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL); if (mnt) &#123; int err; // åˆ†é…ä¸€ä¸ªæ–°çš„æŒ‚è½½ç‚¹ID err = mnt_alloc_id(mnt); if (err) goto out_free_cache; if (name) &#123; // å¤åˆ¶è®¾å¤‡åç§°åˆ°mnt_devname mnt-&gt;mnt_devname = kstrdup_const(name, GFP_KERNEL_ACCOUNT); if (!mnt-&gt;mnt_devname) goto out_free_id; &#125;#ifdef CONFIG_SMP // ä¸ºmnt_pcpåˆ†é…percpuå˜é‡ mnt-&gt;mnt_pcp = alloc_percpu(struct mnt_pcp); if (!mnt-&gt;mnt_pcp) goto out_free_devname; // åœ¨æœ¬åœ°CPUå˜é‡ä¸­å¢åŠ mnt_count this_cpu_add(mnt-&gt;mnt_pcp-&gt;mnt_count, 1);#else // è®¾ç½®mnt_countå’Œmnt_writers mnt-&gt;mnt_count = 1; mnt-&gt;mnt_writers = 0;#endif // åˆå§‹åŒ–mnt_hashã€mnt_childã€mnt_mountsã€mnt_listã€mnt_expireã€mnt_shareã€mnt_slave_listã€mnt_slaveã€mnt_mp_listã€mnt_umountingã€mnt_stuck_children INIT_HLIST_NODE(&amp;mnt-&gt;mnt_hash); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_child); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_mounts); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_list); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_expire); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_share); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_slave_list); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_slave); INIT_HLIST_NODE(&amp;mnt-&gt;mnt_mp_list); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_umounting); INIT_HLIST_HEAD(&amp;mnt-&gt;mnt_stuck_children); mnt-&gt;mnt.mnt_idmap = &amp;nop_mnt_idmap; &#125; return mnt;#ifdef CONFIG_SMPout_free_devname: // é‡Šæ”¾mnt_devnameçš„å†…å­˜ kfree_const(mnt-&gt;mnt_devname);#endifout_free_id: // é‡Šæ”¾æŒ‚è½½ç‚¹ID mnt_free_id(mnt);out_free_cache: // é‡Šæ”¾æŒ‚è½½ç‚¹ç»“æ„ä½“çš„å†…å­˜ kmem_cache_free(mnt_cache, mnt); return NULL;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/* * å¤§å¤šæ•°å¯¹æ–‡ä»¶ç³»ç»Ÿçš„åªè¯»æ£€æŸ¥æ˜¯é’ˆå¯¹éœ€è¦ç¦»æ•£æ—¶é—´çš„æ“ä½œï¼Œæ¯”å¦‚write()æˆ–unlink()ã€‚ * æˆ‘ä»¬å¿…é¡»è·Ÿè¸ªè¿™äº›æ“ä½œçš„å¼€å§‹æ—¶é—´ï¼ˆç”¨äºæƒé™æ£€æŸ¥ï¼‰å’Œç»“æŸæ—¶é—´ï¼Œä»¥ä¾¿ç¡®å®šä½•æ—¶å¯ä»¥å¯¹æ–‡ä»¶ç³»ç»Ÿè¿›è¡Œå†™æ“ä½œã€‚ *//* * __mnt_is_readonly: æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ä¸ºåªè¯» * @mnt: è¦æ£€æŸ¥å…¶å†™å…¥çŠ¶æ€çš„æŒ‚è½½ç‚¹ * * è¿™ä¸ªå‡½æ•°ä¸åº”è¯¥ç›´æ¥åœ¨VFSä¹‹å¤–ä½¿ç”¨ã€‚ * å®ƒä¸èƒ½ä¿è¯æ–‡ä»¶ç³»ç»Ÿå°†ä¿æŒè¯»/å†™çŠ¶æ€ï¼Œåªèƒ½è¡¨ç¤ºå½“å‰çŠ¶æ€ã€‚ä¸èƒ½å°†å…¶ç”¨äºæ›¿ä»£IS_RDONLY(inode)ã€‚ * mnt_want/drop_write()å°†ä¿æŒæ–‡ä»¶ç³»ç»Ÿçš„è¯»/å†™çŠ¶æ€ã€‚ */bool __mnt_is_readonly(struct vfsmount *mnt)&#123; // æ£€æŸ¥æŒ‚è½½ç‚¹çš„mnt_flagsæ˜¯å¦åŒ…å«MNT_READONLYæ ‡å¿—ï¼Œæˆ–è€…é€šè¿‡sb_rdonly()å‡½æ•°æ£€æŸ¥mnt_sbæ˜¯å¦ä¸ºåªè¯» return (mnt-&gt;mnt_flags &amp; MNT_READONLY) || sb_rdonly(mnt-&gt;mnt_sb);&#125;EXPORT_SYMBOL_GPL(__mnt_is_readonly);static inline void mnt_inc_writers(struct mount *mnt)&#123;#ifdef CONFIG_SMP // åœ¨æœ¬åœ°CPUå˜é‡ä¸­å¢åŠ mnt_writers this_cpu_inc(mnt-&gt;mnt_pcp-&gt;mnt_writers);#else // å¢åŠ mnt_writers mnt-&gt;mnt_writers++;#endif&#125;static inline void mnt_dec_writers(struct mount *mnt)&#123;#ifdef CONFIG_SMP // åœ¨æœ¬åœ°CPUå˜é‡ä¸­å‡å°‘mnt_writers this_cpu_dec(mnt-&gt;mnt_pcp-&gt;mnt_writers);#else // å‡å°‘mnt_writers mnt-&gt;mnt_writers--;#endif&#125; 123456789101112131415161718192021222324252627static unsigned int mnt_get_writers(struct mount *mnt)&#123;#ifdef CONFIG_SMP unsigned int count = 0; int cpu; // éå†æ‰€æœ‰å¯èƒ½çš„CPUï¼Œç´¯åŠ mnt_writers for_each_possible_cpu(cpu) &#123; count += per_cpu_ptr(mnt-&gt;mnt_pcp, cpu)-&gt;mnt_writers; &#125; return count;#else // è¿”å›mnt_writers return mnt-&gt;mnt_writers;#endif&#125;static int mnt_is_readonly(struct vfsmount *mnt)&#123; if (mnt-&gt;mnt_sb-&gt;s_readonly_remount) return 1; /* åœ¨do_remount()ä¸­è®¾ç½®s_flags/s_readonly_remountçš„é¡ºåº */ smp_rmb(); // è°ƒç”¨__mnt_is_readonly()å‡½æ•°æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ä¸ºåªè¯» return __mnt_is_readonly(mnt);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * å¤§å¤šæ•°å¯¹æ–‡ä»¶ç³»ç»Ÿçš„åªè¯»å’Œå†»ç»“æ£€æŸ¥æ˜¯é’ˆå¯¹éœ€è¦ç¦»æ•£æ—¶é—´çš„æ“ä½œï¼Œæ¯”å¦‚write()æˆ–unlink()ã€‚ * æˆ‘ä»¬å¿…é¡»è·Ÿè¸ªè¿™äº›æ“ä½œçš„å¼€å§‹æ—¶é—´ï¼ˆç”¨äºæƒé™æ£€æŸ¥ï¼‰å’Œç»“æŸæ—¶é—´ï¼Œä»¥ä¾¿ç¡®å®šä½•æ—¶å¯ä»¥å¯¹æ–‡ä»¶ç³»ç»Ÿè¿›è¡Œå†™æ“ä½œã€‚ *//** * __mnt_want_write - åœ¨æ²¡æœ‰å†»ç»“ä¿æŠ¤çš„æƒ…å†µä¸‹è·å–å¯¹æŒ‚è½½ç‚¹çš„å†™è®¿é—®æƒé™ * @m: è¦è¿›è¡Œå†™æ“ä½œçš„æŒ‚è½½ç‚¹ * * è¿™å‘Šè¯‰åº•å±‚æ–‡ä»¶ç³»ç»Ÿå°†è¦å¯¹å…¶æ‰§è¡Œå†™æ“ä½œï¼Œå¹¶ç¡®ä¿åœ¨è¿”å›æˆåŠŸä¹‹å‰å…è®¸å†™æ“ä½œï¼ˆæŒ‚è½½ç‚¹ä¸ºè¯»å†™çŠ¶æ€ï¼‰ã€‚ * æ­¤æ“ä½œä¸ä¿æŠ¤æ–‡ä»¶ç³»ç»Ÿçš„å†»ç»“çŠ¶æ€ã€‚åœ¨å†™æ“ä½œå®Œæˆåï¼Œå¿…é¡»è°ƒç”¨__mnt_drop_write()å‡½æ•°ã€‚è¿™å®é™…ä¸Šæ˜¯ä¸€ä¸ªå¼•ç”¨è®¡æ•°ã€‚ */int __mnt_want_write(struct vfsmount *m)&#123; struct mount *mnt = real_mount(m); int ret = 0; preempt_disable(); // åœ¨æœ¬åœ°CPUå˜é‡ä¸­å¢åŠ mnt_writers mnt_inc_writers(mnt); /* * å¯¹mnt_inc_writersçš„å­˜å‚¨å¿…é¡»åœ¨æˆ‘ä»¬é€šè¿‡MNT_WRITE_HOLDå¾ªç¯ä¹‹å‰å¯è§ï¼Œ * è¿™æ ·æ…¢è·¯å¾„å¯ä»¥åœ¨è®¾ç½®MNT_WRITE_HOLDåçœ‹åˆ°æˆ‘ä»¬å¢åŠ çš„è®¡æ•°ã€‚ */ smp_mb(); might_lock(&amp;mount_lock.lock); while (READ_ONCE(mnt-&gt;mnt.mnt_flags) &amp; MNT_WRITE_HOLD) &#123; if (!IS_ENABLED(CONFIG_PREEMPT_RT)) &#123; // åœ¨éå®æ—¶å†…æ ¸ä¸­ï¼Œæ”¾æ¾CPUä»¥å‡å°‘è‡ªæ—‹ cpu_relax(); &#125; else &#123; /* * è¿™å¯ä»¥é˜²æ­¢ä¼˜å…ˆçº§å€’ç½®ï¼Œå¦‚æœè®¾ç½®MNT_WRITE_HOLDçš„ä»»åŠ¡åœ¨è¿œç¨‹CPUä¸Šè¢«æŠ¢å ï¼Œ * å¹¶ä¸”å®ƒå¯ä»¥é˜²æ­¢ç”Ÿæ´»é”å®šï¼Œå¦‚æœè®¾ç½®MNT_WRITE_HOLDçš„ä»»åŠ¡å…·æœ‰è¾ƒä½çš„ä¼˜å…ˆçº§å¹¶ä¸”ç»‘å®šåˆ°ä¸æ­¤å¤„è‡ªæ—‹çš„ä»»åŠ¡ç›¸åŒçš„CPUã€‚ */ preempt_enable(); lock_mount_hash(); unlock_mount_hash(); preempt_disable(); &#125; &#125; /* * åœ¨æ…¢è·¯å¾„æ¸…é™¤MNT_WRITE_HOLDä¹‹åï¼Œmnt_is_readonlyå°†è¢«è®¾ç½®ä¸ºä¸å…¶è¦æ±‚åŒ¹é…çš„å€¼ã€‚ * å› æ­¤ï¼Œåœ¨æ¸…é™¤MNT_WRITE_HOLDä¹‹å‰ï¼Œæˆ‘ä»¬ä¸èƒ½åŠ è½½mnt_is_readonlyã€‚ */ smp_rmb(); if (mnt_is_readonly(m)) &#123; // å‡å°‘mnt_writers mnt_dec_writers(mnt); ret = -EROFS; &#125; preempt_enable(); return ret;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * mnt_want_write - è·å–å¯¹æŒ‚è½½ç‚¹çš„å†™è®¿é—®æƒé™ * @m: è¦è¿›è¡Œå†™æ“ä½œçš„æŒ‚è½½ç‚¹ * * è¿™å‘Šè¯‰åº•å±‚æ–‡ä»¶ç³»ç»Ÿå³å°†å¯¹å…¶è¿›è¡Œå†™æ“ä½œï¼Œå¹¶ç¡®ä¿åœ¨è¿”å›æˆåŠŸä¹‹å‰å…è®¸å†™æ“ä½œï¼ˆæŒ‚è½½ç‚¹ä¸ºè¯»å†™çŠ¶æ€ï¼Œ... ret; // å¼€å§‹å†™æ“ä½œ sb_start_write(m-&gt;mnt_sb); // è°ƒç”¨__mnt_want_writeå‡½æ•°è·å–å†™è®¿é—®æƒé™ ret = __mnt_want_write(m); if (ret) // å¦‚æœè·å–å†™è®¿é—®æƒé™å¤±è´¥ï¼Œåˆ™ç»“æŸå†™æ“ä½œ sb_end_write(m-&gt;mnt_sb); return ret;&#125;EXPORT_SYMBOL_GPL(mnt_want_write);/** * __mnt_want_write_file - è·å–å¯¹æ–‡ä»¶çš„å†™è®¿é—®æƒé™ * @file: è¦è¿›è¡Œå†™æ“ä½œçš„æ–‡ä»¶ * * è¿™ç±»ä¼¼äº__mnt_want_writeï¼Œä½†å¦‚æœæ–‡ä»¶å·²ç»ä»¥å†™æ¨¡å¼æ‰“å¼€ï¼Œåˆ™è·³è¿‡å¢åŠ mnt_writersçš„æ­¥éª¤ï¼ˆå› ä¸ºæ‰“å¼€çš„æ–‡ä»¶å·²ç»æœ‰ä¸€ä¸ªå¼•ç”¨ï¼‰ï¼Œ * è€Œåªè¿›è¡Œç´§æ€¥åªè¯»é‡æ–°æŒ‚è½½çš„æ£€æŸ¥ã€‚è¿™å¿…é¡»ä¸__mnt_drop_write_fileé…å¯¹ä½¿ç”¨ã€‚ */int __mnt_want_write_file(struct file *file)&#123; if (file-&gt;f_mode &amp; FMODE_WRITER) &#123; /* * å½“ä»ç„¶å­˜åœ¨å¯å†™çš„æ–‡ä»¶æè¿°ç¬¦æ—¶ï¼Œè¶…çº§å—å¯èƒ½å·²å˜ä¸ºåªè¯»çŠ¶æ€ï¼Œ * ä¾‹å¦‚ç”±äºå…·æœ‰errors=remount-roçš„æ–‡ä»¶ç³»ç»Ÿé”™è¯¯ */ if (__mnt_is_readonly(file-&gt;f_path.mnt)) return -EROFS; return 0; &#125; // è°ƒç”¨__mnt_want_writeå‡½æ•°è·å–å†™è®¿é—®æƒé™ return __mnt_want_write(file-&gt;f_path.mnt);&#125;/** * mnt_want_write_file - è·å–å¯¹æ–‡ä»¶çš„å†™è®¿é—®æƒé™ * @file: è¦è¿›è¡Œå†™æ“ä½œçš„æ–‡ä»¶ * * è¿™ç±»ä¼¼äºmnt_want_writeï¼Œä½†å¦‚æœæ–‡ä»¶å·²ç»ä»¥å†™æ¨¡å¼æ‰“å¼€ï¼Œåˆ™è·³è¿‡å¢åŠ mnt_writersçš„æ­¥éª¤ï¼ˆå› ä¸ºæ‰“å¼€çš„æ–‡ä»¶å·²ç»æœ‰ä¸€ä¸ªå¼•ç”¨ï¼‰ï¼Œ * è€Œåªè¿›è¡Œå†»ç»“ä¿æŠ¤å’Œç´§æ€¥åªè¯»é‡æ–°æŒ‚è½½çš„æ£€æŸ¥ã€‚è¿™å¿…é¡»ä¸mnt_drop_write_fileé…å¯¹ä½¿ç”¨ã€‚ */int mnt_want_write_file(struct file *file)&#123; int ret; // å¼€å§‹å†™æ“ä½œ sb_start_write(file_inode(file)-&gt;i_sb); // è°ƒç”¨__mnt_want_write_fileå‡½æ•°è·å–å†™è®¿é—®æƒé™ ret = __mnt_want_write_file(file); if (ret) // å¦‚æœè·å–å†™è®¿é—®æƒé™å¤±è´¥ï¼Œåˆ™ç»“æŸå†™æ“ä½œ sb_end_write(file_inode(file)-&gt;i_sb); return ret;&#125;EXPORT_SYMBOL_GPL(mnt_want_write_file); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * __mnt_drop_write - æ”¾å¼ƒå¯¹æŒ‚è½½ç‚¹çš„å†™è®¿é—®æƒé™ * @mnt: è¦æ”¾å¼ƒå†™è®¿é—®æƒé™çš„æŒ‚è½½ç‚¹ * * å‘Šè¯‰åº•å±‚æ–‡ä»¶ç³»ç»Ÿæˆ‘ä»¬å·²ç»å®Œæˆå¯¹å…¶çš„å†™æ“ä½œã€‚å¿…é¡»ä¸ä¸Šé¢çš„__mnt_want_write()è°ƒç”¨åŒ¹é…ã€‚ */void __mnt_drop_write(struct vfsmount *mnt)&#123; preempt_disable(); // å‡å°‘mnt_writers mnt_dec_writers(real_mount(mnt)); preempt_enable();&#125;/** * mnt_drop_write - æ”¾å¼ƒå¯¹æŒ‚è½½ç‚¹çš„å†™è®¿é—®æƒé™ * @mnt: è¦æ”¾å¼ƒå†™è®¿é—®æƒé™çš„æŒ‚è½½ç‚¹ * * ... å‘Šè¯‰åº•å±‚æ–‡ä»¶ç³»ç»Ÿæˆ‘ä»¬å·²ç»å®Œæˆå¯¹å…¶çš„å†™æ“ä½œï¼Œå¹¶å…è®¸æ–‡ä»¶ç³»ç»Ÿå†æ¬¡è¢«å†»ç»“ã€‚ * å¿…é¡»ä¸ä¸Šé¢çš„mnt_want_write()è°ƒç”¨åŒ¹é…ã€‚ */void mnt_drop_write(struct vfsmount *mnt)&#123; // è°ƒç”¨__mnt_drop_writeå‡½æ•°æ”¾å¼ƒå†™è®¿é—®æƒé™ __mnt_drop_write(mnt); // ç»“æŸå†™æ“ä½œ sb_end_write(mnt-&gt;mnt_sb);&#125;EXPORT_SYMBOL_GPL(mnt_drop_write);void __mnt_drop_write_file(struct file *file)&#123; if (!(file-&gt;f_mode &amp; FMODE_WRITER)) // å¦‚æœæ–‡ä»¶ä¸æ˜¯ä»¥å†™æ¨¡å¼æ‰“å¼€ï¼Œåˆ™è°ƒç”¨__mnt_drop_writeå‡½æ•°æ”¾å¼ƒå†™è®¿é—®æƒé™ __mnt_drop_write(file-&gt;f_path.mnt);&#125;void mnt_drop_write_file(struct file *file)&#123; // è°ƒç”¨__mnt_drop_write_fileå‡½æ•°æ”¾å¼ƒå†™è®¿é—®æƒé™ __mnt_drop_write_file(file); // ç»“æŸå†™æ“ä½œ sb_end_write(file_inode(file)-&gt;i_sb);&#125;EXPORT_SYMBOL(mnt_drop_write_file); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static int mnt_make_readonly(struct mount *mnt)&#123; int ret; ret = mnt_hold_writers(mnt); // è°ƒç”¨å‡½æ•° mnt_hold_writers() æ¥è·å–å†™é” if (!ret) mnt-&gt;mnt.mnt_flags |= MNT_READONLY; // å°† MNT_READONLY æ ‡å¿—ä½è®¾ç½®ä¸º 1ï¼Œè¡¨ç¤ºæŒ‚è½½ç‚¹åªè¯» mnt_unhold_writers(mnt); // é‡Šæ”¾å†™é” return ret;&#125;int sb_prepare_remount_readonly(struct super_block *sb)&#123; struct mount *mnt; int err = 0; /* Racy optimization. Recheck the counter under MNT_WRITE_HOLD */ if (atomic_long_read(&amp;sb-&gt;s_remove_count)) // æ£€æŸ¥ s_remove_count è®¡æ•°å™¨çš„å€¼ return -EBUSY; // å¦‚æœè®¡æ•°å™¨çš„å€¼ä¸ä¸º 0ï¼Œåˆ™è¿”å›å¿™ç¢Œé”™è¯¯ç  lock_mount_hash(); // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ list_for_each_entry(mnt, &amp;sb-&gt;s_mounts, mnt_instance) &#123; if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_READONLY)) &#123; // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ä¸ºåªè¯» err = mnt_hold_writers(mnt); // è°ƒç”¨å‡½æ•° mnt_hold_writers() æ¥è·å–å†™é” if (err) break; &#125; &#125; if (!err &amp;&amp; atomic_long_read(&amp;sb-&gt;s_remove_count)) // å†æ¬¡æ£€æŸ¥ s_remove_count è®¡æ•°å™¨çš„å€¼ err = -EBUSY; // å¦‚æœè®¡æ•°å™¨çš„å€¼ä¸ä¸º 0ï¼Œåˆ™è¿”å›å¿™ç¢Œé”™è¯¯ç  if (!err) &#123; sb-&gt;s_readonly_remount = 1; // å°† s_readonly_remount æ ‡å¿—ä½è®¾ç½®ä¸º 1ï¼Œè¡¨ç¤ºå‡†å¤‡è¿›è¡Œåªè¯»é‡æ–°æŒ‚è½½ smp_wmb(); // å†…å­˜å±éšœï¼Œç¡®ä¿æ ‡å¿—ä½çš„ä¿®æ”¹å¯¹å…¶ä»– CPU å¯è§ &#125; list_for_each_entry(mnt, &amp;sb-&gt;s_mounts, mnt_instance) &#123; if (mnt-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD) // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦æŒæœ‰å†™é” mnt-&gt;mnt.mnt_flags &amp;= ~MNT_WRITE_HOLD; // æ¸…é™¤ MNT_WRITE_HOLD æ ‡å¿—ä½ &#125; unlock_mount_hash(); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ return err;&#125;static void free_vfsmnt(struct mount *mnt)&#123; mnt_idmap_put(mnt_idmap(&amp;mnt-&gt;mnt)); // é‡Šæ”¾æŒ‚è½½ç‚¹çš„ ID æ˜ å°„ kfree_const(mnt-&gt;mnt_devname); // é‡Šæ”¾æŒ‚è½½ç‚¹çš„è®¾å¤‡åç§°å†…å­˜#ifdef CONFIG_SMP free_percpu(mnt-&gt;mnt_pcp); // é‡Šæ”¾æŒ‚è½½ç‚¹çš„ percpu å˜é‡#endif kmem_cache_free(mnt_cache, mnt); // é‡Šæ”¾æŒ‚è½½ç‚¹çš„å†…å­˜&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * lookup_mnt - è¿”å›æŒ‚è½½åœ¨è·¯å¾„ä¸Šçš„ç¬¬ä¸€ä¸ªå­æŒ‚è½½ç‚¹ * * &quot;ç¬¬ä¸€ä¸ª&quot; æŒ‡çš„æ˜¯æŒ‰æ—¶é—´é¡ºåºç¬¬ä¸€ä¸ªæŒ‚è½½çš„ã€‚å¦‚æœä½ åˆ›å»ºäº†ä»¥ä¸‹æŒ‚è½½ç‚¹ï¼š * * mount /dev/sda1 /mnt * mount /dev/sda2 /mnt * mount /dev/sda3 ... /mnt * * é‚£ä¹ˆåœ¨æ ¹æŒ‚è½½ç‚¹ä¸Šçš„åŸºç¡€è·¯å¾„ /mnt ä¸Šè°ƒç”¨ lookup_mnt() å°†ä¾æ¬¡è¿”å› ... /dev/sda1 çš„æ ¹ dentry å’Œ vfsmountï¼Œ * ç„¶åæ˜¯ /dev/sda2ï¼Œç„¶åæ˜¯ /dev/sda3ï¼Œç„¶åæ˜¯ NULLã€‚ * * ... lookup_mnt() ä¼šå¼•ç”¨æ‰¾åˆ°çš„ vfsmountã€‚ */struct vfsmount *lookup_mnt(const struct path *path)&#123; struct mount *child_mnt; struct vfsmount *m; unsigned seq; rcu_read_lock(); // è¯»å–é”å®š RCU do &#123; seq = m; // è¯»å–åºåˆ—å· child_mnt = m; // è·å–å­æŒ‚è½½ç‚¹ if (child_mnt) &#123; m = &amp;child_mnt-&gt;mnt; if (mnt_is_cursor(child_mnt)) // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ä¸ºæ¸¸æ ‡æŒ‚è½½ç‚¹ break; &#125; else &#123; m = NULL; &#125; &#125; while (m); rcu_read_unlock(); // è§£é” RCU return m; // è¿”å›æ‰¾åˆ°çš„ vfsmount&#125;static inline void lock_ns_list(struct mnt_namespace *ns)&#123; spin_lock(&amp;ns-&gt;ns_lock); // é”å®šå‘½åç©ºé—´çš„é”&#125;static inline void unlock_ns_list(struct mnt_namespace *ns)&#123; spin_unlock(&amp;ns-&gt;ns_lock); // è§£é”å‘½åç©ºé—´çš„é”&#125;static inline bool mnt_is_cursor(struct mount *mnt)&#123; return mnt-&gt;mnt.mnt_flags &amp; MNT_CURSOR; // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ä¸ºæ¸¸æ ‡æŒ‚è½½ç‚¹&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * __is_local_mountpoint - æµ‹è¯•dentryæ˜¯å¦æ˜¯å½“å‰æŒ‚è½½å‘½åç©ºé—´ä¸­çš„æŒ‚è½½ç‚¹ã€‚ * * é€šå¸¸æƒ…å†µä¸‹ï¼Œdentryæ ¹æœ¬ä¸æ˜¯æŒ‚è½½ç‚¹ï¼Œè¿™ç§æƒ…å†µåœ¨å†…è”ä¸­å¤„ç†ã€‚ * å½“æˆ‘ä»¬å®é™…å¤„ç†æŸç§ç±»å‹çš„æŒ‚è½½ç‚¹æ—¶ï¼Œä¼šéå†å½“å‰æŒ‚è½½å‘½åç©ºé—´ä¸­çš„æ‰€æœ‰æŒ‚è½½ï¼Œå¹¶æµ‹è¯•dentryæ˜¯å¦æ˜¯æŒ‚è½½ç‚¹ã€‚ * * åœ¨æ­¤ä¸Šä¸‹æ–‡ä¸­ï¼Œæ— æ³•ä½¿ç”¨mount_hashtableï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦è¯†åˆ«å¯èƒ½åœ¨å½“å‰æŒ‚è½½å‘½åç©ºé—´ä¸­çš„æ‰€æœ‰æŒ‚è½½ï¼Œ * è€Œä¸ä»…ä»…æ˜¯å…·æœ‰æŸä¸ªæŒ‡å®šçˆ¶æŒ‚è½½çš„æŒ‚è½½ã€‚ */bool __is_local_mountpoint(struct dentry *dentry)&#123; struct mnt_namespace *ns = current-&gt;nsproxy-&gt;mnt_ns; // è·å–å½“å‰è¿›ç¨‹çš„æŒ‚è½½å‘½åç©ºé—´ struct mount *mnt; bool is_covered = false; // æ ‡è®°dentryæ˜¯å¦æ˜¯æŒ‚è½½ç‚¹ down_read(&amp;namespace_sem); // è·å–å‘½åç©ºé—´ä¿¡å·é‡ï¼Œé˜²æ­¢å¹¶å‘è®¿é—® lock_ns_list(ns); // é”å®šæŒ‚è½½åˆ—è¡¨ï¼Œé˜²æ­¢å¹¶å‘è®¿é—® list_for_each_entry(mnt, &amp;ns-&gt;list, mnt_list) &#123; if (mnt_is_cursor(mnt)) continue; is_covered = (mnt-&gt;mnt_mountpoint == dentry); // åˆ¤æ–­dentryæ˜¯å¦æ˜¯æŒ‚è½½ç‚¹ if (is_covered) break; &#125; unlock_ns_list(ns); // è§£é”æŒ‚è½½åˆ—è¡¨ up_read(&amp;namespace_sem); // é‡Šæ”¾å‘½åç©ºé—´ä¿¡å·é‡ return is_covered;&#125;/* * lookup_mountpoint - æŸ¥æ‰¾æŒ‡å®šdentryçš„æŒ‚è½½ç‚¹ã€‚ * * éå†æŒ‡å®šdentryçš„å“ˆå¸Œé“¾è¡¨ï¼ŒæŸ¥æ‰¾ä¸ä¹‹åŒ¹é…çš„æŒ‚è½½ç‚¹ã€‚ * å¦‚æœæ‰¾åˆ°åŒ¹é…çš„æŒ‚è½½ç‚¹ï¼Œåˆ™å¢åŠ å…¶å¼•ç”¨è®¡æ•°å¹¶è¿”å›è¯¥æŒ‚è½½ç‚¹ã€‚ * å¦‚æœæœªæ‰¾åˆ°åŒ¹é…çš„æŒ‚è½½ç‚¹ï¼Œåˆ™è¿”å›NULLã€‚ */static struct mountpoint *lookup_mountpoint(struct dentry *dentry)&#123; struct hlist_head *chain = mp_hash(dentry); // è·å–æŒ‡å®šdentryçš„å“ˆå¸Œé“¾è¡¨å¤´ struct mountpoint *mp; hlist_for_each_entry(mp, chain, m_hash) &#123; if (mp-&gt;m_dentry == dentry) &#123; mp-&gt;m_count++; // å¢åŠ æŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•° return mp; &#125; &#125; return NULL;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static struct mountpoint *get_mountpoint(struct dentry *dentry)&#123; struct mountpoint *mp, *new = NULL; int ret; if (d_mountpoint(dentry)) &#123; /* å¯èƒ½å€¼å¾—ä¸€ä¸ª WARN_ON() */ if (d_unlinked(dentry)) return ERR_PTR(-ENOENT);mountpoint: read_seqlock_excl(&amp;mount_lock); // è·å–æŒ‚è½½é”ï¼Œé˜²æ­¢å¹¶å‘è®¿é—® mp = lookup_mountpoint(dentry); // æŸ¥æ‰¾æŒ‡å®šdentryçš„æŒ‚è½½ç‚¹ read_sequnlock_excl(&amp;mount_lock); // é‡Šæ”¾æŒ‚è½½é” if (mp) goto done; &#125; if (!new) new = kmalloc(sizeof(struct mountpoint), GFP_KERNEL); // åˆ†é…æ–°çš„æŒ‚è½½ç‚¹ç»“æ„ä½“ if (!new) return ERR_PTR(-ENOMEM); // å†…å­˜åˆ†é…å¤±è´¥ /* åªæœ‰ä¸€ä¸ªè¿›ç¨‹å¯ä»¥è®¾ç½® d_mounted */ ret = d_set_mounted(dentry); // è®¾ç½®dentryçš„d_mountedæ ‡å¿—ä½ /* æœ‰å…¶ä»–è¿›ç¨‹è®¾ç½®äº† d_mounted? */ if (ret == -EBUSY) goto mountpoint; /* dentryä¸å¯ç”¨ä½œæŒ‚è½½ç‚¹? */ mp = ERR_PTR(ret); if (ret) goto done; /* å°†æ–°çš„æŒ‚è½½ç‚¹æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­ */ read_seqlock_excl(&amp;mount_lock); // è·å–æŒ‚è½½é”ï¼Œé˜²æ­¢å¹¶å‘è®¿é—® new-&gt;m_dentry = dget(dentry); // å¢åŠ dentryçš„å¼•ç”¨è®¡æ•° new-&gt;m_count = 1; // è®¾ç½®æŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•° hlist_add_head(&amp;new-&gt;m_hash, mp_hash(dentry)); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­ INIT_HLIST_HEAD(&amp;new-&gt;m_list); // åˆå§‹åŒ–æŒ‚è½½ç‚¹çš„é“¾è¡¨å¤´ read_sequnlock_excl(&amp;mount_lock); // é‡Šæ”¾æŒ‚è½½é” mp = new; new = NULL;done: kfree(new); // é‡Šæ”¾æ–°çš„æŒ‚è½½ç‚¹ç»“æ„ä½“çš„å†…å­˜ return mp;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * vfsmounté”å¿…é¡»è¢«æŒæœ‰ã€‚æ­¤å¤–ï¼Œè°ƒç”¨è€…è´Ÿè´£å¯¹ç»™å®šçš„å¤„ç†åˆ—è¡¨è¿›è¡Œåºåˆ—åŒ–è°ƒç”¨ã€‚ */static void __put_mountpoint(struct mountpoint *mp, struct list_head *list)&#123; if (!--mp-&gt;m_count) &#123; // å¦‚æœæŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•°å‡ä¸º0 struct dentry *dentry = mp-&gt;m_dentry; BUG_ON(!hlist_empty(&amp;mp-&gt;m_list)); // æ–­è¨€æŒ‚è½½ç‚¹çš„é“¾è¡¨ä¸ºç©º spin_lock(&amp;dentry-&gt;d_lock); // è·å–dentryçš„è‡ªæ—‹é” dentry-&gt;d_flags &amp;= ~DCACHE_MOUNTED; // æ¸…é™¤dentryçš„DCACHE_MOUNTEDæ ‡å¿—ä½ spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾dentryçš„è‡ªæ—‹é” dput_to_list(dentry, list); // å°†dentryæ”¾å…¥æŒ‡å®šçš„åˆ—è¡¨ä¸­ hlist_del(&amp;mp-&gt;m_hash); // ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤æŒ‚è½½ç‚¹ kfree(mp); // é‡Šæ”¾æŒ‚è½½ç‚¹çš„å†…å­˜ &#125;&#125;/* åœ¨namespace_lockå’Œvfsmounté”çš„ä¿æŠ¤ä¸‹è°ƒç”¨ */static void put_mountpoint(struct mountpoint *mp)&#123; __put_mountpoint(mp, &amp;ex_mountpoints); // è°ƒç”¨__put_mountpointå‡½æ•°ï¼Œå°†æŒ‚è½½ç‚¹æ”¾å…¥ex_mountpointsåˆ—è¡¨ä¸­&#125;static inline int check_mnt(struct mount *mnt)&#123; return mnt-&gt;mnt_ns == current-&gt;nsproxy-&gt;mnt_ns; // æ£€æŸ¥ç»™å®šçš„æŒ‚è½½æ˜¯å¦å±äºå½“å‰è¿›ç¨‹çš„æŒ‚è½½å‘½åç©ºé—´&#125;/* * vfsmounté”å¿…é¡»è¢«æŒæœ‰ï¼ˆå†™æ¨¡å¼ï¼‰ */static void touch_mnt_namespace(struct mnt_namespace *ns)&#123; if (ns) &#123; ns-&gt;event = ++event; // æ›´æ–°æŒ‚è½½å‘½åç©ºé—´çš„äº‹ä»¶è®¡æ•° wake_up_interruptible(&amp;ns-&gt;poll); // å”¤é†’ç­‰å¾…æŒ‚è½½å‘½åç©ºé—´äº‹ä»¶çš„è¿›ç¨‹ &#125;&#125;/* * vfsmounté”å¿…é¡»è¢«æŒæœ‰ï¼ˆå†™æ¨¡å¼ï¼‰ */static void __touch_mnt_namespace(struct mnt_namespace *ns)&#123; if (ns &amp;&amp; ns-&gt;event != event) &#123; ns-&gt;event = event; // æ›´æ–°æŒ‚è½½å‘½åç©ºé—´çš„äº‹ä»¶è®¡æ•° wake_up_interruptible(&amp;ns-&gt;poll); // å”¤é†’ç­‰å¾…æŒ‚è½½å‘½åç©ºé—´äº‹ä»¶çš„è¿›ç¨‹ &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/* * vfsmount lock must be held for write */static struct mountpoint *unhash_mnt(struct mount *mnt)&#123; struct mountpoint *mp; mnt-&gt;mnt_parent = mnt; // å°†mntçš„çˆ¶æŒ‚è½½è®¾ç½®ä¸ºè‡ªèº« mnt-&gt;mnt_mountpoint = ... *mp, // å°†mntçš„æŒ‚è½½ç‚¹è®¾ç½®ä¸º... *mp struct mount *child_mnt) &#123; mp-&gt;m_count++; // å¢åŠ mpçš„å¼•ç”¨è®¡æ•° mnt_add_count(mnt, 1); // å¢åŠ mntçš„å¼•ç”¨è®¡æ•° child_mnt-&gt;mnt_mountpoint = mp-&gt;m_dentry; // å°†child_mntçš„æŒ‚è½½ç‚¹è®¾ç½®ä¸ºmpçš„dentry child_mnt-&gt;mnt_parent = ... mnt; // å°†child_mntçš„çˆ¶æŒ‚è½½è®¾ç½®ä¸ºmnt child_mnt-&gt;mnt_mp = mp; // å°†child_mntçš„mnt_mpè®¾ç½®ä¸ºmp hlist_add_head(&amp;child_mnt-&gt;mnt_mp_list, &amp;mp-&gt;m_list); // å°†child_mntæ·»åŠ åˆ°mpçš„m_listé“¾è¡¨å¤´éƒ¨ &#125;&#125;static void __attach_mnt(struct mount *mnt, struct mount *parent)&#123; hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash, ... m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint)); // å°†mntæ·»åŠ åˆ°parentçš„mnt_hashé“¾è¡¨å¤´éƒ¨ list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts); // å°†mntæ·»åŠ åˆ°parentçš„mnt_mountsé“¾è¡¨å°¾éƒ¨&#125;/* * vfsmount lock must be held for write */static void attach_mnt(struct mount *mnt, struct mount *parent, struct ... mountpoint *mp)&#123; mnt_set_mountpoint(parent, mp, mnt); // è®¾ç½®parentçš„æŒ‚è½½ç‚¹ä¸ºmpï¼Œå°†mntè®¾ç½®ä¸ºmpçš„æŒ‚è½½ __attach_mnt(mnt, parent); // å°†mntæ·»åŠ åˆ°parentçš„mnt_hashé“¾è¡¨å¤´éƒ¨ï¼Œå°†mntæ·»åŠ åˆ°parentçš„mnt_mountsé“¾è¡¨å°¾éƒ¨&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)&#123; // ä¿å­˜æ—§çš„æŒ‚è½½ç‚¹å’Œçˆ¶æŒ‚è½½ struct mountpoint *old_mp = mnt-&gt;mnt_mp; struct mount *old_parent = mnt-&gt;mnt_parent; // ä»ç›¸å…³é“¾è¡¨ä¸­åˆ é™¤å½“å‰æŒ‚è½½ list_del_init(&amp;mnt-&gt;mnt_child); hlist_del_init(&amp;mnt-&gt;mnt_mp_list); hlist_del_init_rcu(&amp;mnt-&gt;mnt_hash); // å°†å½“å‰æŒ‚è½½ç‚¹é™„åŠ åˆ°æ–°çš„çˆ¶æŒ‚è½½å’ŒæŒ‚è½½ç‚¹ä¸Š attach_mnt(mnt, parent, mp); // é‡Šæ”¾æ—§çš„æŒ‚è½½ç‚¹ put_mountpoint(old_mp); // æ›´æ–°æ—§çš„çˆ¶æŒ‚è½½çš„æŒ‚è½½è®¡æ•° mnt_add_count(old_parent, -1);&#125;/* * vfsmount lock must be held for write */static void commit_tree(struct mount *mnt)&#123; // è·å–çˆ¶æŒ‚è½½ struct mount *parent = mnt-&gt;mnt_parent; struct mount *m; LIST_HEAD(head); struct mnt_namespace *n = parent-&gt;mnt_ns; // æ£€æŸ¥çˆ¶æŒ‚è½½å’Œå½“å‰æŒ‚è½½æ˜¯å¦ç›¸åŒ BUG_ON(parent == mnt); // å°†å½“å‰æŒ‚è½½æ·»åŠ åˆ°é“¾è¡¨å¤´éƒ¨ list_add_tail(&amp;head, &amp;mnt-&gt;mnt_list); // éå†é“¾è¡¨ä¸­çš„æ¯ä¸ªæŒ‚è½½ï¼Œå°†å®ƒä»¬çš„å‘½åç©ºé—´è®¾ç½®ä¸ºçˆ¶æŒ‚è½½çš„å‘½åç©ºé—´ list_for_each_entry(m, &amp;head, mnt_list) m-&gt;mnt_ns = n; // å°†é“¾è¡¨æ’å…¥åˆ°å‘½åç©ºé—´çš„æœ«å°¾ list_splice(&amp;head, n-&gt;list.prev); // æ›´æ–°å‘½åç©ºé—´çš„æŒ‚è½½è®¡æ•°å’Œå¾…æŒ‚è½½è®¡æ•° n-&gt;mounts += n-&gt;pending_mounts; n-&gt;pending_mounts = 0; // å°†å½“å‰æŒ‚è½½é™„åŠ åˆ°çˆ¶æŒ‚è½½ __attach_mnt(mnt, parent); // æ›´æ–°å‘½åç©ºé—´çš„è®¿é—®æ—¶é—´æˆ³ touch_mnt_namespace(n);&#125;static struct mount *next_mnt(struct mount *p, struct mount *root)&#123; // è·å–ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ struct list_head *next = p-&gt;mnt_mounts.next; if (next == &amp;p-&gt;mnt_mounts) &#123; while (1) &#123; // å¦‚æœå·²ç»åˆ°è¾¾æ ¹æŒ‚è½½ç‚¹ï¼Œåˆ™è¿”å›ç©º if (p == root) return NULL; // è·å–çˆ¶æŒ‚è½½çš„ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ next = p-&gt;mnt_child.next; // å¦‚æœä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ä¸æ˜¯çˆ¶æŒ‚è½½çš„é“¾è¡¨å¤´ï¼Œåˆ™è·³å‡ºå¾ªç¯ if (next != &amp;p-&gt;mnt_parent-&gt;mnt_mounts) break; // æ›´æ–°çˆ¶æŒ‚è½½ä¸ºå½“å‰æŒ‚è½½çš„çˆ¶æŒ‚è½½ p = p-&gt;mnt_parent; &#125; &#125; // è¿”å›ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ return list_entry(next, struct mount, mnt_child);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static struct mount *skip_mnt_tree(struct mount *p)&#123; // è·å–ä¸Šä¸€ä¸ªæŒ‚è½½ç‚¹ struct list_head *prev = p-&gt;mnt_mounts.prev; while (prev != &amp;p-&gt;mnt_mounts) &#123; // å°†ä¸Šä¸€ä¸ªæŒ‚è½½ç‚¹èµ‹å€¼ç»™å½“å‰æŒ‚è½½ç‚¹ï¼Œå¹¶ç»§ç»­å‘å‰éå† p = list_entry(prev, struct mount, mnt_child); prev = p-&gt;mnt_mounts.prev; &#125; // è¿”å›æœ€åä¸€ä¸ªæŒ‚è½½ç‚¹ return p;&#125;/** * vfs_create_mount - Create a mount for a configured superblock * @fc: The configuration context with the superblock attached * * Create a mount to an already configured superblock. If necessary, the * caller should invoke vfs_get_tree() before calling this. * * Note that this does not attach the mount to anything. */struct vfsmount *vfs_create_mount(struct fs_context *fc)&#123; struct mount *mnt; // æ£€æŸ¥æ ¹ç›®å½•æ˜¯å¦å­˜åœ¨ if (!fc-&gt;root) return ERR_PTR(-EINVAL); // åˆ†é…ä¸€ä¸ªæ–°çš„æŒ‚è½½ç»“æ„ä½“ mnt = alloc_vfsmnt(fc-&gt;source ?: &quot;none&quot;); if (!mnt) return ERR_PTR(-ENOMEM); // å¦‚æœæ˜¯å†…æ ¸æŒ‚è½½ï¼Œåˆ™è®¾ç½®æŒ‚è½½æ ‡å¿—ä¸ºMNT_INTERNAL if (fc-&gt;sb_flags &amp; SB_KERNMOUNT) mnt-&gt;mnt.mnt_flags = MNT_INTERNAL; // å¢åŠ è¶…çº§å—çš„æ´»è·ƒå¼•ç”¨è®¡æ•° atomic_inc(&amp;fc-&gt;root-&gt;d_sb-&gt;s_active); // è®¾ç½®æŒ‚è½½çš„è¶…çº§å—ã€æ ¹ç›®å½•ã€æŒ‚è½½ç‚¹å’Œçˆ¶æŒ‚è½½ mnt-&gt;mnt.mnt_sb = fc-&gt;root-&gt;d_sb; mnt-&gt;mnt.mnt_root = dget(fc-&gt;root); mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root; mnt-&gt;mnt_parent = mnt; // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ lock_mount_hash(); // å°†æŒ‚è½½æ·»åŠ åˆ°è¶…çº§å—çš„æŒ‚è½½é“¾è¡¨æœ«å°¾ list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;mnt-&gt;mnt.mnt_sb-&gt;s_mounts); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ unlock_mount_hash(); // è¿”å›æŒ‚è½½ç»“æ„ä½“æŒ‡é’ˆ return &amp;mnt-&gt;mnt;&#125;EXPORT_SYMBOL(vfs_create_mount);struct vfsmount *fc_mount(struct fs_context *fc)&#123; // è·å–æ–‡ä»¶ç³»ç»Ÿæ ‘ int err = vfs_get_tree(fc); if (!err) &#123; // é‡Šæ”¾è¶…çº§å—çš„å¸è½½ä¿¡å·é‡ up_write(&amp;fc-&gt;root-&gt;d_sb-&gt;s_umount); // åˆ›å»ºæŒ‚è½½ return vfs_create_mount(fc); &#125; // è¿”å›é”™è¯¯ç  return ERR_PTR(err);&#125;EXPORT_SYMBOL(fc_mount); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static struct mount *skip_mnt_tree(struct mount *p)&#123; // è·å–ä¸Šä¸€ä¸ªæŒ‚è½½ç‚¹ struct list_head *prev = p-&gt;mnt_mounts.prev; while (prev != &amp;p-&gt;mnt_mounts) &#123; // å°†ä¸Šä¸€ä¸ªæŒ‚è½½ç‚¹èµ‹å€¼ç»™å½“å‰æŒ‚è½½ç‚¹ï¼Œå¹¶ç»§ç»­å‘å‰éå† p = list_entry(prev, struct mount, mnt_child); prev = p-&gt;mnt_mounts.prev; &#125; // è¿”å›æœ€åä¸€ä¸ªæŒ‚è½½ç‚¹ return p;&#125;/** * vfs_create_mount - ä¸ºå·²é…ç½®çš„è¶…çº§å—åˆ›å»ºä¸€ä¸ªæŒ‚è½½ç‚¹ * @fc: å¸¦æœ‰å·²è¿æ¥è¶…çº§å—çš„é…ç½®ä¸Šä¸‹æ–‡ * * ä¸ºå·²é…ç½®çš„è¶…çº§å—åˆ›å»ºä¸€ä¸ªæŒ‚è½½ç‚¹ã€‚å¦‚æœéœ€è¦ï¼Œåœ¨è°ƒç”¨æ­¤å‡½æ•°ä¹‹å‰ï¼Œè°ƒç”¨è€…åº”è¯¥è°ƒç”¨vfs_get_tree()ã€‚ * * æ³¨æ„ï¼Œè¿™ä¸ä¼šå°†æŒ‚è½½ç‚¹é™„åŠ åˆ°ä»»ä½•ä½ç½®ã€‚ */struct vfsmount *vfs_create_mount(struct fs_context *fc)&#123; struct mount *mnt; // æ£€æŸ¥æ ¹ç›®å½•æ˜¯å¦å­˜åœ¨ if (!fc-&gt;root) return ERR_PTR(-EINVAL); // åˆ†é…ä¸€ä¸ªæ–°çš„æŒ‚è½½ç»“æ„ä½“ mnt = alloc_vfsmnt(fc-&gt;source ?: &quot;none&quot;); if (!mnt) return ERR_PTR(-ENOMEM); // å¦‚æœæ˜¯å†…æ ¸æŒ‚è½½ï¼Œåˆ™è®¾ç½®æŒ‚è½½æ ‡å¿—ä¸ºMNT_INTERNAL if (fc-&gt;sb_flags &amp; SB_KERNMOUNT) mnt-&gt;mnt.mnt_flags = MNT_INTERNAL; // å¢åŠ è¶…çº§å—çš„æ´»è·ƒå¼•ç”¨è®¡æ•° atomic_inc(&amp;fc-&gt;root-&gt;d_sb-&gt;s_active); // è®¾ç½®æŒ‚è½½çš„è¶…çº§å—ã€æ ¹ç›®å½•ã€æŒ‚è½½ç‚¹å’Œçˆ¶æŒ‚è½½ mnt-&gt;mnt.mnt_sb = fc-&gt;root-&gt;d_sb; mnt-&gt;mnt.mnt_root = dget(fc-&gt;root); mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root; mnt-&gt;mnt_parent = mnt; // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ lock_mount_hash(); // å°†æŒ‚è½½æ·»åŠ åˆ°è¶…çº§å—çš„æŒ‚è½½é“¾è¡¨æœ«å°¾ list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;mnt-&gt;mnt.mnt_sb-&gt;s_mounts); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ unlock_mount_hash(); // è¿”å›æŒ‚è½½ç»“æ„ä½“æŒ‡é’ˆ return &amp;mnt-&gt;mnt;&#125;EXPORT_SYMBOL(vfs_create_mount);struct vfsmount *fc_mount(struct fs_context *fc)&#123; // è·å–æ–‡ä»¶ç³»ç»Ÿæ ‘ int err = vfs_get_tree(fc); if (!err) &#123; // é‡Šæ”¾è¶…çº§å—çš„å¸è½½ä¿¡å·é‡ up_write(&amp;fc-&gt;root-&gt;d_sb-&gt;s_umount); // åˆ›å»ºæŒ‚è½½ return vfs_create_mount(fc); &#125; // è¿”å›é”™è¯¯ç  return ERR_PTR(err);&#125;EXPORT_SYMBOL(fc_mount); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct vfsmount *vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)&#123; // åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ struct fs_context *fc; // æŒ‚è½½ç‚¹ struct vfsmount *mnt; // è¿”å›å€¼ int ret = 0; // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿç±»å‹æ˜¯å¦ä¸ºç©º if (!type) return ERR_PTR(-EINVAL); // ä¸ºæŒ‚è½½åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ fc = fs_context_for_mount(type, flags); if (IS_ERR(fc)) return ERR_CAST(fc); // å¦‚æœæŒ‡å®šäº†æŒ‚è½½åå­—ï¼Œåˆ™è§£ææŒ‚è½½æºå­—ç¬¦ä¸² if (name) ret = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // å¦‚æœè§£ææŒ‚è½½æºå­—ç¬¦ä¸²æˆåŠŸï¼Œåˆ™è§£ææŒ‚è½½æ•°æ® if (!ret) ret = parse_monolithic_mount_data(fc, data); // å¦‚æœè§£ææŒ‚è½½æ•°æ®æˆåŠŸï¼Œåˆ™è¿›è¡ŒæŒ‚è½½ if (!ret) mnt = fc_mount(fc); else mnt = ERR_PTR(ret); // é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ put_fs_context(fc); // è¿”å›æŒ‚è½½ç‚¹ return mnt;&#125;EXPORT_SYMBOL_GPL(vfs_kern_mount);struct vfsmount *vfs_submount(const struct dentry *mountpoint, struct file_system_type *type, const char *name, void *data)&#123; /* ç›®å‰è¿˜æ²¡æœ‰è§£å†³å¦‚ä½•ä»çˆ¶æŒ‚è½½ä¼ é€’ç”¨æˆ·å‘½åç©ºé—´åˆ°å­æŒ‚è½½ï¼Œ * å› æ­¤ä¸æ”¯æŒå¸¦æœ‰å­æŒ‚è½½çš„éç‰¹æƒæŒ‚è½½ã€‚ */ if (mountpoint-&gt;d_sb-&gt;s_user_ns != &amp;init_user_ns) return ERR_PTR(-EPERM); // è°ƒç”¨vfs_kern_mountè¿›è¡Œå­æŒ‚è½½ return vfs_kern_mount(type, SB_SUBMOUNT, name, data);&#125;EXPORT_SYMBOL_GPL(vfs_submount); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static struct mount *clone_mnt(struct mount *old, struct dentry *root, int flag)&#123; // å…‹éš†ä¸€ä¸ªæŒ‚è½½ç‚¹ç»“æ„ä½“ struct super_block *sb = old-&gt;mnt.mnt_sb; struct mount *mnt; int err; // åˆ†é…ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹ mnt = alloc_vfsmnt(old-&gt;mnt_devname); if (!mnt) return ERR_PTR(-ENOMEM); // è®¾ç½®æŒ‚è½½ç‚¹çš„ç»„ID if (flag &amp; (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE)) mnt-&gt;mnt_group_id = 0; /* ä¸æ˜¯åŸå§‹æŒ‚è½½ç‚¹çš„å¯¹ç­‰ç‚¹ */ else mnt-&gt;mnt_group_id = old-&gt;mnt_group_id; // å¦‚æœéœ€è¦åˆ›å»ºå…±äº«æŒ‚è½½ç‚¹ï¼Œå¹¶ä¸”æŒ‚è½½ç‚¹æ²¡æœ‰ç»„IDï¼Œåˆ™åˆ†é…ä¸€ä¸ªç»„ID if ((flag &amp; CL_MAKE_SHARED) &amp;&amp; !mnt-&gt;mnt_group_id) &#123; err = mnt_alloc_group_id(mnt); if (err) goto out_free; &#125; // å¤åˆ¶æŒ‚è½½ç‚¹çš„æ ‡å¿—ä½ mnt-&gt;mnt.mnt_flags = old-&gt;mnt.mnt_flags; mnt-&gt;mnt.mnt_flags &amp;= ~(MNT_WRITE_HOLD | MNT_MARKED | MNT_INTERNAL); // å¢åŠ è¶…çº§å—çš„æ´»è·ƒå¼•ç”¨è®¡æ•° atomic_inc(&amp;sb-&gt;s_active); // è·å–æŒ‚è½½ç‚¹çš„IDæ˜ å°„ mnt-&gt;mnt.mnt_idmap = mnt_idmap_get(mnt_idmap(&amp;old-&gt;mnt)); // è®¾ç½®æŒ‚è½½ç‚¹çš„è¶…çº§å—ã€æ ¹ç›®å½•ã€æŒ‚è½½ç‚¹å’Œçˆ¶æŒ‚è½½ç‚¹ mnt-&gt;mnt.mnt_sb = sb; mnt-&gt;mnt.mnt_root = dget(root); mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root; mnt-&gt;mnt_parent = mnt; lock_mount_hash(); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°è¶…çº§å—çš„æŒ‚è½½ç‚¹é“¾è¡¨ä¸­ list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;sb-&gt;s_mounts); unlock_mount_hash(); // å¦‚æœæ˜¯ä»å±æŒ‚è½½ç‚¹æˆ–è€…æ˜¯å…±äº«ç»™ä»å±æŒ‚è½½ç‚¹çš„æŒ‚è½½ç‚¹ if ((flag &amp; CL_SLAVE) || ((flag &amp; CL_SHARED_TO_SLAVE) &amp;&amp; IS_MNT_SHARED(old))) &#123; // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°åŸå§‹æŒ‚è½½ç‚¹çš„ä»å±æŒ‚è½½ç‚¹é“¾è¡¨ä¸­ list_add(&amp;mnt-&gt;mnt_slave, &amp;old-&gt;mnt_slave_list); mnt-&gt;mnt_master = old; CLEAR_MNT_SHARED(mnt); &#125; // å¦‚æœä¸æ˜¯ç§æœ‰æŒ‚è½½ç‚¹ else if (!(flag &amp; CL_PRIVATE)) &#123; // å¦‚æœéœ€è¦åˆ›å»ºå…±äº«æŒ‚è½½ç‚¹æˆ–è€…åŸå§‹æŒ‚è½½ç‚¹æ˜¯å…±äº«çš„ï¼Œåˆ™å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°åŸå§‹æŒ‚è½½ç‚¹çš„å…±äº«æŒ‚è½½ç‚¹é“¾è¡¨ä¸­ if ((flag &amp; CL_MAKE_SHARED) || IS_MNT_SHARED(old)) list_add(&amp;mnt-&gt;mnt_share, &amp;old-&gt;mnt_share); // å¦‚æœåŸå§‹æŒ‚è½½ç‚¹æ˜¯ä»å±æŒ‚è½½ç‚¹ï¼Œåˆ™å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°åŸå§‹æŒ‚è½½ç‚¹çš„ä»å±æŒ‚è½½ç‚¹é“¾è¡¨ä¸­ if (IS_MNT_SLAVE(old)) list_add(&amp;mnt-&gt;mnt_slave, &amp;old-&gt;mnt_slave); mnt-&gt;mnt_master = old-&gt;mnt_master; &#125; // å¦‚æœæ˜¯ç§æœ‰æŒ‚è½½ç‚¹ else &#123; CLEAR_MNT_SHARED(mnt); &#125; // å¦‚æœéœ€è¦åˆ›å»ºå…±äº«æŒ‚è½½ç‚¹ï¼Œåˆ™è®¾ç½®æŒ‚è½½ç‚¹ä¸ºå…±äº«çš„ if (flag &amp; CL_MAKE_SHARED) set_mnt_shared(mnt); // å¦‚æœéœ€è¦è®¾ç½®æŒ‚è½½ç‚¹çš„è¿‡æœŸæ—¶é—´ï¼Œå¹¶ä¸”åŸå§‹æŒ‚è½½ç‚¹çš„è¿‡æœŸé“¾è¡¨ä¸ä¸ºç©ºï¼Œåˆ™å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°åŸå§‹æŒ‚è½½ç‚¹çš„è¿‡æœŸé“¾è¡¨ä¸­ if (flag &amp; CL_EXPIRE) &#123; if (!list_empty(&amp;old-&gt;mnt_expire)) list_add(&amp;mnt-&gt;mnt_expire, &amp;old-&gt;mnt_expire); &#125; return mnt; out_free: mnt_free_id(mnt); free_vfsmnt(mnt); return ERR_PTR(err);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static void cleanup_mnt(struct mount *mnt)&#123; struct hlist_node *p; struct mount *m; /* * è¿™é‡Œçš„è­¦å‘Šå¯èƒ½è¡¨ç¤ºæŸäººæä¹±äº†mnt_want/drop_write()å¯¹ã€‚å¦‚æœå‘ç”Ÿè¿™ç§æƒ…å†µï¼Œ * æ–‡ä»¶ç³»ç»Ÿå¯èƒ½æ— æ³•è¿›è¡Œè¯»å†™-&gt;åªè¯»çš„è½¬æ¢ã€‚åœ¨å¤„ç†mnt_countå‡å°‘æ—¶ä½¿ç”¨çš„é”æä¾›äº†å±éšœï¼Œ * æ‰€ä»¥ä¸‹é¢çš„mnt_get_writers()æ˜¯å®‰å…¨çš„ã€‚ */ WARN_ON(mnt_get_writers(mnt)); // å¦‚æœæŒ‚è½½ç‚¹æœ‰å¼•ç”¨è®¡æ•°ï¼Œåˆ™æ€æ­»å¼•ç”¨è®¡æ•° if (unlikely(mnt-&gt;mnt_pins.first)) mnt_pin_kill(mnt); // éå†æŒ‚è½½ç‚¹çš„æŒ‚èµ·å­æŒ‚è½½ç‚¹é“¾è¡¨ï¼Œåˆ é™¤æ¯ä¸ªå­æŒ‚è½½ç‚¹å¹¶é‡Šæ”¾å¼•ç”¨è®¡æ•° hlist_for_each_entry_safe(m, p, &amp;mnt-&gt;mnt_stuck_children, mnt_umount) &#123; hlist_del(&amp;m-&gt;mnt_umount); mntput(&amp;m-&gt;mnt); &#125; // åˆ é™¤æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥çš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹ fsnotify_vfsmount_delete(&amp;mnt-&gt;mnt); // é‡Šæ”¾æ ¹ç›®å½•çš„å¼•ç”¨è®¡æ•° dput(mnt-&gt;mnt.mnt_root); // åœç”¨è¶…çº§å— deactivate_super(mnt-&gt;mnt.mnt_sb); // é‡Šæ”¾æŒ‚è½½ç‚¹çš„ID mnt_free_id(mnt); // è°ƒç”¨å»¶è¿Ÿé‡Šæ”¾è™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹çš„å›è°ƒå‡½æ•° call_rcu(&amp;mnt-&gt;mnt_rcu, delayed_free_vfsmnt);&#125;static void __cleanup_mnt(struct rcu_head *head)&#123; // è°ƒç”¨cleanup_mntå‡½æ•°è¿›è¡ŒæŒ‚è½½ç‚¹çš„æ¸…ç† cleanup_mnt(container_of(head, struct mount, mnt_rcu));&#125;// å®šä¹‰å»¶è¿Ÿé‡Šæ”¾æŒ‚è½½ç‚¹çš„å·¥ä½œé˜Ÿåˆ—static LLIST_HEAD(delayed_mntput_list);static void delayed_mntput(struct work_struct *unused)&#123; // ä»å»¶è¿ŸæŒ‚è½½ç‚¹åˆ—è¡¨ä¸­åˆ é™¤æ‰€æœ‰èŠ‚ç‚¹ struct llist_node *node = llist_del_all(&amp;delayed_mntput_list); struct mount *m, *t; // éå†å»¶è¿ŸæŒ‚è½½ç‚¹åˆ—è¡¨ä¸­çš„æ¯ä¸ªæŒ‚è½½ç‚¹ï¼Œè°ƒç”¨cleanup_mntå‡½æ•°è¿›è¡Œæ¸…ç† llist_for_each_entry_safe(m, t, node, mnt_llist) cleanup_mnt(m);&#125;// å£°æ˜å»¶è¿ŸæŒ‚è½½ç‚¹çš„å·¥ä½œstatic DECLARE_DELAYED_WORK(delayed_mntput_work, delayed_mntput); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static void mntput_no_expire(struct mount *mnt)&#123; LIST_HEAD(list); // å®šä¹‰ä¸€ä¸ªé“¾è¡¨å¤´ int count; // å®šä¹‰ä¸€ä¸ªè®¡æ•°å™¨ rcu_read_lock(); // è·å–è¯»å–RCUé” if (likely(READ_ONCE(mnt-&gt;mnt_ns))) &#123; // å¦‚æœmntçš„mnt_nså­—æ®µéç©º /* * ç”±äºæˆ‘ä»¬åœ¨è¿™é‡Œæ²¡æœ‰æ‰§è¡Œlock_mount_hash()ï¼Œ * -&gt;mnt_ns å¯èƒ½åœ¨æˆ‘ä»¬çš„æ“ä½œæœŸé—´å‘ç”Ÿå˜åŒ–ã€‚ * ä½†æ˜¯ï¼Œå¦‚æœå®ƒéç©ºï¼Œåˆ™å­˜åœ¨ä¸€ä¸ªå¼•ç”¨ï¼Œ * ç›´åˆ°å°† -&gt;mnt_ns å˜ä¸º NULL ä¹‹åçš„ RCU å»¶è¿Ÿä¹‹åæ‰ä¼šè¢«é‡Šæ”¾ã€‚ * å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬åœ¨ rcu_read_lock() ä¸‹è§‚å¯Ÿåˆ°å®ƒéç©ºï¼Œ * åˆ™æˆ‘ä»¬è¦é‡Šæ”¾çš„å¼•ç”¨ä¸æ˜¯æœ€åä¸€ä¸ªå¼•ç”¨ã€‚ */ mnt_add_count(mnt, -1); // å‡å°‘mntçš„å¼•ç”¨è®¡æ•° rcu_read_unlock(); // é‡Šæ”¾RCUé” return; &#125; lock_mount_hash(); // é”å®šmountå“ˆå¸Œè¡¨ /* * ç¡®ä¿å¦‚æœ __legitimize_mnt() åœ¨æˆ‘ä»¬è·å– mount_lock ä¹‹å‰æ²¡æœ‰çœ‹åˆ°æˆ‘ä»¬ï¼Œ * æˆ‘ä»¬å°†åœ¨æ­¤å¤„çœ‹åˆ°ä»–ä»¬çš„å¼•ç”¨è®¡æ•°å¢åŠ ã€‚ */ smp_mb(); // å†…å­˜å±éšœ mnt_add_count(mnt, -1); // å‡å°‘mntçš„å¼•ç”¨è®¡æ•° count = mnt_get_count(mnt); // è·å–mntçš„å¼•ç”¨è®¡æ•° if (count != 0) &#123; // å¦‚æœå¼•ç”¨è®¡æ•°ä¸ä¸º0 WARN_ON(count &lt; 0); // å‘å‡ºè­¦å‘Š rcu_read_unlock(); // é‡Šæ”¾RCUé” unlock_mount_hash(); // è§£é”mountå“ˆå¸Œè¡¨ return; &#125; if (unlikely(mnt-&gt;mnt.mnt_flags &amp; MNT_DOOMED)) &#123; // å¦‚æœmntçš„mnt_flagså­—æ®µåŒ…å«MNT_DOOMEDæ ‡å¿— rcu_read_unlock(); // é‡Šæ”¾RCUé” unlock_mount_hash(); // è§£é”mountå“ˆå¸Œè¡¨ return; &#125; mnt-&gt;mnt.mnt_flags |= MNT_DOOMED; // è®¾ç½®mntçš„mnt_flagså­—æ®µçš„MNT_DOOMEDæ ‡å¿— rcu_read_unlock(); // é‡Šæ”¾RCUé” list_del(&amp;mnt-&gt;mnt_instance); // ä»é“¾è¡¨ä¸­åˆ é™¤mntèŠ‚ç‚¹ if (unlikely(!list_empty(&amp;mnt-&gt;mnt_mounts))) &#123; // å¦‚æœmntçš„mnt_mountsé“¾è¡¨éç©º struct mount *p, *tmp; list_for_each_entry_safe(p, tmp, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; // éå†mntçš„mnt_mountsé“¾è¡¨ __put_mountpoint(unhash_mnt(p), &amp;list); // é‡Šæ”¾pçš„æŒ‚è½½ç‚¹ hlist_add_head(&amp;p-&gt;mnt_umount, &amp;mnt-&gt;mnt_stuck_children); // å°†pçš„mnt_umountèŠ‚ç‚¹æ·»åŠ åˆ°mntçš„mnt_stuck_childrenå“ˆå¸Œé“¾è¡¨å¤´éƒ¨ &#125; &#125; unlock_mount_hash(); // è§£é”mountå“ˆå¸Œè¡¨ shrink_dentry_list(&amp;list); // æ”¶ç¼©é“¾è¡¨ if (likely(!(mnt-&gt;mnt.mnt_flags &amp; MNT_INTERNAL))) &#123; // å¦‚æœmntçš„mnt_flagså­—æ®µä¸åŒ…å«MNT_INTERNALæ ‡å¿— struct task_struct *task = current; // è·å–å½“å‰è¿›ç¨‹çš„task_structç»“æ„ä½“æŒ‡é’ˆ if (likely(!(task-&gt;flags &amp; PF_KTHREAD))) &#123; // å¦‚æœå½“å‰è¿›ç¨‹ä¸æ˜¯å†…æ ¸çº¿ç¨‹ init_task_work(&amp;mnt-&gt;mnt_rcu, __cleanup_mnt); // åˆå§‹åŒ–mntçš„mnt_rcuå­—æ®µ if (!task_work_add(task, &amp;mnt-&gt;mnt_rcu, TWA_RESUME)) // å°†mntçš„mnt_rcuå­—æ®µæ·»åŠ åˆ°å½“å‰è¿›ç¨‹çš„task_structçš„å·¥ä½œé˜Ÿåˆ—ä¸­ return; &#125; if (llist_add(&amp;mnt-&gt;mnt_llist, &amp;delayed_mntput_list)) // å°†mntçš„mnt_llistèŠ‚ç‚¹æ·»åŠ åˆ°delayed_mntput_listé“¾è¡¨ä¸­ schedule_delayed_work(&amp;delayed_mntput_work, 1); // å»¶è¿Ÿæ‰§è¡Œdelayed_mntput_workå‡½æ•° return; &#125; cleanup_mnt(mnt); // æ¸…ç†mnt&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void mntput(struct vfsmount *mnt)&#123; if (mnt) &#123; // å¦‚æœmntéç©º struct mount *m = real_mount(mnt); // è·å–mntå¯¹åº”çš„mountç»“æ„ä½“æŒ‡é’ˆ /* é¿å…ç¼“å­˜è¡Œæ¥å›è·³åŠ¨ï¼Œå¸Œæœ›gccä¸ä¼šå˜å¾—â€œèªæ˜â€ */ if (unlikely(m-&gt;mnt_expiry_mark)) // å¦‚æœmountçš„mnt_expiry_markå­—æ®µä¸ºçœŸ m-&gt;mnt_expiry_mark = 0; // å°†mountçš„mnt_expiry_markå­—æ®µç½®ä¸º0 mntput_no_expire(m); // è°ƒç”¨mntput_no_expireå‡½æ•°é‡Šæ”¾mount &#125;&#125;EXPORT_SYMBOL(mntput); // å¯¼å‡ºmntputå‡½æ•°struct vfsmount *mntget(struct vfsmount *mnt)&#123; if (mnt) mnt_add_count(real_mount(mnt), 1); // å¢åŠ mntå¯¹åº”çš„mountçš„å¼•ç”¨è®¡æ•° return mnt;&#125;EXPORT_SYMBOL(mntget); // å¯¼å‡ºmntgetå‡½æ•°/* * ä½¿æŒ‚è½½ç‚¹å¯¹æ–°çš„æŸ¥æ‰¾ä¸å¯è®¿é—®ã€‚ * å› ä¸ºå¯èƒ½ä»ç„¶æœ‰å½“å‰ç”¨æˆ·ï¼Œè°ƒç”¨è€…å¿…é¡»åœ¨é”€æ¯æŒ‚è½½ç‚¹ä¹‹å‰ç­‰å¾…RCUå®½é™æœŸã€‚ */void mnt_make_shortterm(struct vfsmount *mnt)&#123; if (mnt) real_mount(mnt)-&gt;mnt_ns = NULL; // å°†mntå¯¹åº”çš„mountçš„mnt_nså­—æ®µç½®ä¸ºNULL&#125;/** * path_is_mountpoint() - æ£€æŸ¥è·¯å¾„æ˜¯å¦æ˜¯å½“å‰å‘½åç©ºé—´ä¸­çš„æŒ‚è½½ç‚¹ã€‚ * @path: è¦æ£€æŸ¥çš„è·¯å¾„ * * d_mountpoint() åªèƒ½å¯é åœ°ç”¨äºç¡®å®šä¸€ä¸ªdentryæ˜¯å¦æœªåœ¨ä»»ä½•å‘½åç©ºé—´ä¸­æŒ‚è½½ï¼Œ * å¹¶ä¸”è¿™ç§å¸¸è§æƒ…å†µåœ¨å†…è”ä¸­å¤„ç†ã€‚ * d_mountpoint() ä¸çŸ¥é“å¯èƒ½æœ‰å¤šä¸ªæŒ‚è½½ä½¿ç”¨ç»™å®šdentryçš„å¯èƒ½æ€§ï¼Œ * è€Œè¿™äº›æŒ‚è½½ä½äºä¸åŒçš„å‘½åç©ºé—´ä¸­ã€‚æ­¤å‡½æ•°æ£€æŸ¥ä¼ å…¥çš„è·¯å¾„æ˜¯å¦æ˜¯æŒ‚è½½ç‚¹ï¼Œè€Œä¸ä»…ä»…æ˜¯dentryæœ¬èº«ã€‚ */bool path_is_mountpoint(const struct path *path)&#123; unsigned seq; bool res; if (!d_mountpoint(path-&gt;dentry)) // å¦‚æœdentryä¸æ˜¯æŒ‚è½½ç‚¹ return false; rcu_read_lock(); // è·å–è¯»å–RCUé” do &#123; seq = read_seqbegin(&amp;mount_lock); // è¯»å–mount_lockçš„åºåˆ—å· res = __path_is_mountpoint(path); // è°ƒç”¨__path_is_mountpointå‡½æ•°æ£€æŸ¥è·¯å¾„æ˜¯å¦æ˜¯æŒ‚è½½ç‚¹ &#125; while (read_seqretry(&amp;mount_lock, seq)); // å¦‚æœmount_lockçš„åºåˆ—å·å‘ç”Ÿå˜åŒ–ï¼Œåˆ™é‡è¯• rcu_read_unlock(); // é‡Šæ”¾RCUé” return res;&#125;EXPORT_SYMBOL(path_is_mountpoint); // å¯¼å‡ºpath_is_mountpointå‡½æ•° 123456789struct vfsmount *mnt_clone_internal(const struct path *path)&#123; struct mount *p; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct mountç»“æ„ä½“çš„æŒ‡é’ˆp p = clone_mnt(real_mount(path-&gt;mnt), path-&gt;dentry, CL_PRIVATE); // è°ƒç”¨clone_mntå‡½æ•°å…‹éš†mountï¼Œå¹¶å°†ç»“æœèµ‹å€¼ç»™p if (IS_ERR(p)) // å¦‚æœpæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆ return ERR_CAST(p); // è¿”å›å°†pè½¬æ¢ä¸ºé”™è¯¯ç±»å‹çš„æŒ‡é’ˆ p-&gt;mnt.mnt_flags |= MNT_INTERNAL; // å°†mountçš„mnt_flagså­—æ®µçš„MNT_INTERNALæ ‡å¿—ç½®ä¸ºçœŸ return &amp;p-&gt;mnt; // è¿”å›æŒ‡å‘mountçš„mntå­—æ®µ_mountsç»“æ„ä½“ä¸­çš„nsæˆå‘˜å’ŒprevæŒ‡å‘çš„struct list_headç»“æ„ä½“&#125; 1234567891011121314151617181920212223242526272829303132333435363738#ifdef CONFIG_PROC_FSstatic struct mount *mnt_list_next(struct mnt_namespace *ns, struct list_head *p)&#123; struct mount *mnt, *ret = NULL; // å®šä¹‰ä¸¤ä¸ªæŒ‡å‘struct mountç»“æ„ä½“çš„æŒ‡é’ˆmntå’Œret lock_ns_list(ns); // é”å®šå‘½åç©ºé—´çš„åˆ—è¡¨ list_for_each_continue(p, &amp;ns-&gt;list) &#123; // éå†å‘½åç©ºé—´çš„åˆ—è¡¨ mnt = list_entry(p, typeof(*mnt), mnt_list); // å°†pè½¬æ¢ä¸ºstruct mountç»“æ„ä½“æŒ‡é’ˆmnt if (!mnt_is_cursor(mnt)) &#123; // å¦‚æœmntä¸æ˜¯æ¸¸æ ‡ ret = mnt; // å°†mntèµ‹å€¼ç»™ret break; // è·³å‡ºå¾ªç¯ &#125; &#125; unlock_ns_list(ns); // è§£é”å‘½åç©ºé—´çš„åˆ—è¡¨ return ret; // è¿”å›ret&#125;/* iterator; we want it to have access to namespace_sem, thus here... ... */static void *m_start(struct seq_file *m, loff_t *pos)&#123; struct proc_mounts *p = m-&gt;private; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct proc_mountsç»“æ„ä½“çš„æŒ‡é’ˆpï¼ŒæŒ‡å‘seq_fileç»“æ„ä½“çš„privateæˆå‘˜ struct list_head *prev; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct list_headç»“æ„ä½“çš„æŒ‡é’ˆprev down_read(&amp;namespace_sem); // è·å–è¯»å–é”ï¼Œä¿è¯å¹¶å‘å®‰å…¨æ€§ if (!*pos) &#123; // å¦‚æœposæŒ‡å‘çš„å€¼ä¸º0 prev = &amp;p-&gt;ns-&gt;list; // prevæŒ‡å‘pæŒ‡å‘çš„struct proc_mountsç»“æ„ä½“ä¸­çš„nsæˆå‘˜çš„listæˆå‘˜ &#125; else &#123; // å¦åˆ™ prev = &amp;p-&gt;cursor.mnt_list; // prevæŒ‡å‘pæŒ‡å‘çš„struct proc_mountsç»“æ„ä½“ä¸­çš„cursoræˆå‘˜çš„mnt_listæˆå‘˜ /* Read after we&#x27;d reached the end? */ if (list_empty(prev)) // å¦‚æœprevæŒ‡å‘çš„é“¾è¡¨ä¸ºç©º return NULL; // è¿”å›ç©ºæŒ‡é’ˆ &#125; return mnt_list_next(p-&gt;ns, prev); // è¿”å›è°ƒç”¨mnt_list_nextå‡½æ•°çš„ç»“æœï¼Œä¼ å…¥å‚æ•°pæŒ‡å‘çš„struct proc_mountsç»“æ„ä½“ä¸­çš„nsæˆå‘˜å’ŒprevæŒ‡å‘çš„struct list_headç»“æ„ä½“&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void *m_next(struct seq_file *m, void *v, loff_t *pos)&#123; struct proc_mounts *p = m-&gt;private; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct proc_mountsç»“æ„ä½“çš„æŒ‡é’ˆpï¼ŒæŒ‡å‘seq_fileç»“æ„ä½“çš„privateæˆå‘˜ struct mount *mnt = v; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct mountç»“æ„ä½“çš„æŒ‡é’ˆmntï¼ŒæŒ‡å‘å‚æ•°v ++*pos; // å¢åŠ posæŒ‡å‘çš„å€¼ return mnt_list_next(p-&gt;ns, &amp;mnt-&gt;mnt_list); // è¿”å›è°ƒç”¨mnt_list_nextå‡½æ•°çš„ç»“æœï¼Œä¼ å…¥å‚æ•°pæŒ‡å‘çš„struct proc_mountsç»“æ„ä½“ä¸­çš„nsæˆå‘˜å’ŒmntæŒ‡å‘çš„struct mountç»“æ„ä½“çš„mnt_listæˆå‘˜&#125;static void m_stop(struct seq_file *m, void *v)&#123; struct proc_mounts *p = m-&gt;private; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct proc_mountsç»“æ„ä½“çš„æŒ‡é’ˆpï¼ŒæŒ‡å‘seq_fileç»“æ„ä½“çš„privateæˆå‘˜ struct mount *mnt = v; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct mountç»“æ„ä½“çš„æŒ‡é’ˆmntï¼ŒæŒ‡å‘å‚æ•°v lock_ns_list(p-&gt;ns); // é”å®šå‘½åç©ºé—´çš„åˆ—è¡¨ if (mnt) list_move_tail(&amp;p-&gt;cursor.mnt_list, &amp;mnt-&gt;mnt_list); // å°†pæŒ‡å‘çš„struct proc_mountsç»“æ„ä½“ä¸­çš„cursoræˆå‘˜çš„mnt_listæˆå‘˜ç§»åŠ¨åˆ°mntæŒ‡å‘çš„struct mountç»“æ„ä½“çš„mnt_listæˆå‘˜ä¹‹å else list_del_init(&amp;p-&gt;cursor.mnt_list); // ä»pæŒ‡å‘çš„struct proc_mountsç»“æ„ä½“ä¸­çš„cursoræˆå‘˜çš„mnt_listæˆå‘˜ä¸­åˆ é™¤å¹¶åˆå§‹åŒ– unlock_ns_list(p-&gt;ns); // è§£é”å‘½åç©ºé—´çš„åˆ—è¡¨ up_read(&amp;namespace_sem); // é‡Šæ”¾è¯»å–é”&#125;static int m_show(struct seq_file *m, void *v)&#123; struct proc_mounts *p = m-&gt;private; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct proc_mountsç»“æ„ä½“çš„æŒ‡é’ˆpï¼ŒæŒ‡å‘seq_fileç»“æ„ä½“çš„privateæˆå‘˜ struct mount *r = v; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘struct mountç»“æ„ä½“çš„æŒ‡é’ˆrï¼ŒæŒ‡å‘å‚æ•°v return p-&gt;show(m, &amp;r-&gt;mnt); // è°ƒç”¨pæŒ‡å‘çš„struct proc_mountsç»“æ„ä½“ä¸­çš„showæˆå‘˜å‡½æ•°ï¼Œä¼ å…¥å‚æ•°må’ŒræŒ‡å‘çš„struct mountç»“æ„ä½“çš„mntæˆå‘˜çš„åœ°å€&#125;const struct seq_operations mounts_op = &#123; .start = m_start, // è®¾ç½®startæˆå‘˜ä¸ºm_startå‡½æ•° .next = m_next, // è®¾ç½®nextæˆå‘˜ä¸ºm_nextå‡½æ•° .stop = m_stop, // è®¾ç½®stopæˆå‘˜ä¸ºm_stopå‡½æ•° .show = m_show, // è®¾ç½®showæˆå‘˜ä¸ºm_showå‡½æ•°&#125;;void mnt_cursor_del(struct mnt_namespace *ns, struct mount *cursor)&#123; down_read(&amp;namespace_sem); // è·å–è¯»å–é”ï¼Œä¿è¯å¹¶å‘å®‰å…¨æ€§ lock_ns_list(ns); // é”å®šå‘½åç©ºé—´çš„åˆ—è¡¨ list_del(&amp;cursor-&gt;mnt_list); // ä»cursoræŒ‡å‘çš„struct mountç»“æ„ä½“çš„mnt_listæˆå‘˜ä¸­åˆ é™¤ unlock_ns_list(ns); // è§£é”å‘½åç©ºé—´çš„åˆ—è¡¨ up_read(&amp;namespace_sem); // é‡Šæ”¾è¯»å–é”&#125;#endif /* CONFIG_PROC_FS */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * may_umount_tree - æ£€æŸ¥æŒ‚è½½æ ‘æ˜¯å¦ç¹å¿™ * @m: æŒ‚è½½æ ‘çš„æ ¹èŠ‚ç‚¹ * * æ­¤å‡½æ•°ç”¨äºæ£€æŸ¥æŒ‚è½½æ ‘ä¸­æ˜¯å¦æœ‰æ‰“å¼€çš„æ–‡ä»¶ã€å½“å‰å·¥ä½œç›®å½•ã€chrootæˆ–å­æŒ‚è½½ç‚¹å¤„äºç¹å¿™çŠ¶æ€ã€‚ */int may_umount_tree(struct vfsmount *m)&#123; struct mount *mnt = real_mount(m); // è·å–å®é™…çš„æŒ‚è½½ç‚¹ int actual_refs = 0; // å®é™…å¼•ç”¨è®¡æ•° int minimum_refs = 0; // æœ€å°å¼•ç”¨è®¡æ•° struct mount *p; // ç”¨äºéå†æŒ‚è½½ç‚¹çš„æŒ‡é’ˆ BUG_ON(!m); // æ–­è¨€ï¼Œå¦‚æœmä¸ºç©ºï¼Œåˆ™è§¦å‘BUG /* éœ€è¦å†™é”æ¥è·å–mntçš„å¼•ç”¨è®¡æ•° */ lock_mount_hash(); // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ for (p = mnt; p; p = next_mnt(p, mnt)) &#123; actual_refs += mnt_get_count(p); // ç´¯åŠ å®é™…å¼•ç”¨è®¡æ•° minimum_refs += 2; // æœ€å°å¼•ç”¨è®¡æ•°åŠ 2 &#125; unlock_mount_hash(); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ if (actual_refs &gt; minimum_refs) return 0; // å¦‚æœå®é™…å¼•ç”¨è®¡æ•°å¤§äºæœ€å°å¼•ç”¨è®¡æ•°ï¼Œåˆ™è¿”å›0ï¼Œè¡¨ç¤ºç¹å¿™ return 1; // å¦åˆ™è¿”å›1ï¼Œè¡¨ç¤ºæœªç¹å¿™&#125;EXPORT_SYMBOL(may_umount_tree); // å¯¼å‡ºç¬¦å·ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨/** * may_umount - æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ç¹å¿™ * @mnt: æŒ‚è½½ç‚¹çš„æ ¹èŠ‚ç‚¹ * * æ­¤å‡½æ•°ç”¨äºæ£€æŸ¥æŒ‚è½½ç‚¹ä¸­æ˜¯å¦æœ‰æ‰“å¼€çš„æ–‡ä»¶ã€å½“å‰å·¥ä½œç›®å½•ã€chrootæˆ–å­æŒ‚è½½ç‚¹ã€‚å¦‚æœæŒ‚è½½ç‚¹æœ‰å­æŒ‚è½½ç‚¹ï¼Œæ— è®ºå­æŒ‚è½½ç‚¹æ˜¯å¦ç¹å¿™ï¼Œéƒ½å°†è¿”å›ç¹å¿™çŠ¶æ€ã€‚ * * ä¸è€ƒè™‘é…é¢ç­‰å› ç´ ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒå¯èƒ½ä¼šç»™å‡ºé”™è¯¯çš„ç»“æœã€‚å®ƒå­˜åœ¨çš„ä¸»è¦åŸå› æ˜¯æˆ‘ä»¬éœ€è¦ä¸€ç§éç ´åæ€§çš„æ–¹å¼æ¥æŸ¥æ‰¾å¯ä»¥è½»æ¾å¸è½½çš„æ–‡ä»¶ç³»ç»Ÿã€‚ */int may_umount(struct vfsmount *mnt)&#123; int ret = 1; // è¿”å›å€¼ï¼Œé»˜è®¤ä¸º1ï¼Œè¡¨ç¤ºæœªç¹å¿™ down_read(&amp;namespace_sem); // è·å–å‘½åç©ºé—´ä¿¡å·é‡çš„è¯»é” lock_mount_hash(); // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ if (propagate_mount_busy(real_mount(mnt), 2)) // å¦‚æœæŒ‚è½½ç‚¹æˆ–å…¶å­æŒ‚è½½ç‚¹ç¹å¿™ ret = 0; // å°†è¿”å›å€¼è®¾ä¸º0ï¼Œè¡¨ç¤ºç¹å¿™ unlock_mount_hash(); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ up_read(&amp;namespace_sem); // é‡Šæ”¾å‘½åç©ºé—´ä¿¡å·é‡çš„è¯»é” return ret; // è¿”å›ç»“æœ&#125;EXPORT_SYMBOL(may_umount); // å¯¼å‡ºç¬¦å·ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨ 1234567891011121314151617181920212223242526272829303132333435static void namespace_unlock(void)&#123; struct hlist_head head; // å“ˆå¸Œè¡¨å¤´ struct hlist_node *p; // å“ˆå¸Œè¡¨èŠ‚ç‚¹æŒ‡é’ˆ struct mount *m; // æŒ‚è½½ç‚¹æŒ‡é’ˆ LIST_HEAD(list); // é“¾è¡¨å¤´ hlist_move_list(&amp;unmounted, &amp;head); // å°†unmountedé“¾è¡¨ç§»åŠ¨åˆ°headå“ˆå¸Œè¡¨ä¸­ list_splice_init(&amp;ex_mountpoints, &amp;list); // å°†ex_mountpointsé“¾è¡¨åˆå¹¶åˆ°listé“¾è¡¨ä¸­ up_write(&amp;namespace_sem); // é‡Šæ”¾å‘½åç©ºé—´ä¿¡å·é‡çš„å†™é” shrink_dentry_list(&amp;list); // æ”¶ç¼©dentryåˆ—è¡¨ if (likely(hlist_empty(&amp;head))) return; // å¦‚æœheadå“ˆå¸Œè¡¨ä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å› synchronize_rcu_expedited(); // åŒæ­¥RCU hlist_for_each_entry_safe(m, p, &amp;head, mnt_umount) &#123; hlist_del(&amp;m-&gt;mnt_umount); // ä»headå“ˆå¸Œè¡¨ä¸­åˆ é™¤æŒ‚è½½ç‚¹ mntput(&amp;m-&gt;mnt); // é‡Šæ”¾æŒ‚è½½ç‚¹ &#125;&#125;static inline void namespace_lock(void)&#123; down_write(&amp;namespace_sem); // è·å–å‘½åç©ºé—´ä¿¡å·é‡çš„å†™é”&#125;enum umount_tree_flags &#123; UMOUNT_SYNC = 1, // åŒæ­¥å¸è½½æ ‡å¿— UMOUNT_PROPAGATE = 2, // ä¼ æ’­å¸è½½æ ‡å¿— UMOUNT_CONNECTED = 4, // è¿æ¥å¸è½½æ ‡å¿—&#125;; 12345678910111213141516171819202122232425static bool disconnect_mount(struct mount *mnt, enum umount_tree_flags how)&#123; /* åªæœ‰å¯¹äºå»¶è¿Ÿå¸è½½ï¼Œä¿æŒæŒ‚è½½è¿æ¥æ‰æœ‰æ•ˆ */ if (how &amp; UMOUNT_SYNC) return true; // è¿”å›trueï¼Œè¡¨ç¤ºä¿æŒè¿æ¥ /* æ²¡æœ‰çˆ¶æŒ‚è½½ç‚¹çš„æŒ‚è½½ç‚¹æ— éœ€è¿æ¥ */ if (!mnt_has_parent(mnt)) return true; // è¿”å›trueï¼Œè¡¨ç¤ºæ— éœ€è¿æ¥ /* å› ä¸ºåœ¨æŒ‚è½½ç‚¹å¸è½½å’Œè¿æ¥æ—¶å¼•ç”¨è®¡æ•°è§„åˆ™å‘ç”Ÿå˜åŒ–ï¼Œå·²å¸è½½çš„æŒ‚è½½ç‚¹ä¸èƒ½è¿æ¥åˆ°å·²æŒ‚è½½çš„æŒ‚è½½ç‚¹ */ if (!(mnt-&gt;mnt_parent-&gt;mnt.mnt_flags &amp; MNT_UMOUNT)) return true; // è¿”å›trueï¼Œè¡¨ç¤ºæ— éœ€è¿æ¥ /* æ˜¯å¦è¯·æ±‚ä¿æŒæŒ‚è½½è¿æ¥ï¼Ÿ */ if (how &amp; UMOUNT_CONNECTED) return false; // è¿”å›falseï¼Œè¡¨ç¤ºä¿æŒè¿æ¥ /* æŒ‚è½½ç‚¹æ˜¯å¦è¢«é”å®šéœ€è¦ä¿æŒè¿æ¥ï¼Ÿ */ if (IS_MNT_LOCKED(mnt)) return false; // è¿”å›falseï¼Œè¡¨ç¤ºä¿æŒè¿æ¥ /* é»˜è®¤æƒ…å†µä¸‹æ–­å¼€æŒ‚è½½è¿æ¥ */ return true; // è¿”å›trueï¼Œè¡¨ç¤ºæ–­å¼€è¿æ¥&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * mount_lock must be held * namespace_sem must be held for write */static void umount_tree(struct mount *mnt, enum umount_tree_flags how)&#123; LIST_HEAD(tmp_list); // å®šä¹‰ä¸´æ—¶é“¾è¡¨tmp_list struct mount *p; // å®šä¹‰æŒ‚è½½ç‚¹æŒ‡é’ˆp if (how &amp; UMOUNT_PROPAGATE) propagate_mount_unlock(mnt); // å¦‚æœè®¾ç½®äº†UMOUNT_PROPAGATEæ ‡å¿—ï¼Œåˆ™è§£é”æŒ‚è½½ç‚¹çš„ä¼ æ’­ /* æ”¶é›†éœ€è¦å¸è½½çš„æŒ‚è½½ç‚¹ */ for (p = mnt; p; p = next_mnt(p, mnt)) &#123; p-&gt;mnt.mnt_flags |= MNT_UMOUNT; // è®¾ç½®æŒ‚è½½ç‚¹çš„å¸è½½æ ‡å¿— list_move(&amp;p-&gt;mnt_list, &amp;tmp_list); // å°†æŒ‚è½½ç‚¹ä»mnt_mountsé“¾è¡¨ç§»åŠ¨åˆ°tmp_listé“¾è¡¨ä¸­ &#125; /* ä»mnt_mountsé“¾è¡¨ä¸­éšè—æŒ‚è½½ç‚¹ */ list_for_each_entry(p, &amp;tmp_list, mnt_list) &#123; list_del_init(&amp;p-&gt;mnt_child); // ä»æŒ‚è½½ç‚¹çš„çˆ¶æŒ‚è½½ç‚¹çš„mnt_mountsé“¾è¡¨ä¸­åˆ é™¤æŒ‚è½½ç‚¹ &#125; /* å°†ä¼ æ’­çš„æŒ‚è½½ç‚¹æ·»åŠ åˆ°tmp_listé“¾è¡¨ä¸­ */ if (how &amp; UMOUNT_PROPAGATE) propagate_umount(&amp;tmp_list); // å°†ä¼ æ’­çš„æŒ‚è½½ç‚¹æ·»åŠ åˆ°tmp_listé“¾è¡¨ä¸­ while (!list_empty(&amp;tmp_list)) &#123; struct mnt_namespace *ns; // å‘½åç©ºé—´æŒ‡é’ˆ bool disconnect; // æ˜¯å¦æ–­å¼€è¿æ¥çš„æ ‡å¿— p = list_first_entry(&amp;tmp_list, struct mount, mnt_list); // è·å–tmp_listé“¾è¡¨çš„ç¬¬ä¸€ä¸ªæŒ‚è½½ç‚¹ list_del_init(&amp;p-&gt;mnt_expire); // ä»tmp_listé“¾è¡¨ä¸­åˆ é™¤æŒ‚è½½ç‚¹ list_del_init(&amp;p-&gt;mnt_list); // ä»tmp_listé“¾è¡¨ä¸­åˆ é™¤æŒ‚è½½ç‚¹ ns = p-&gt;mnt_ns; // è·å–æŒ‚è½½ç‚¹æ‰€å±çš„å‘½åç©ºé—´ if (ns) &#123; ns-&gt;mounts--; // å‘½åç©ºé—´çš„æŒ‚è½½ç‚¹æ•°å‡1 __touch_mnt_namespace(ns); // æ›´æ–°å‘½åç©ºé—´çš„æ—¶é—´æˆ³ &#125; p-&gt;mnt_ns = NULL; // å°†æŒ‚è½½ç‚¹çš„å‘½åç©ºé—´æŒ‡é’ˆç½®ä¸ºNULL if (how &amp; UMOUNT_SYNC) p-&gt;mnt.mnt_flags |= MNT_SYNC_UMOUNT; // å¦‚æœè®¾ç½®äº†UMOUNT_SYNCæ ‡å¿—ï¼Œåˆ™è®¾ç½®æŒ‚è½½ç‚¹çš„åŒæ­¥å¸è½½æ ‡å¿— disconnect = disconnect_mount(p, how); // æ£€æŸ¥æ˜¯å¦éœ€è¦æ–­å¼€æŒ‚è½½è¿æ¥ if (mnt_has_parent(p)) &#123; mnt_add_count(p-&gt;mnt_parent, -1); // çˆ¶æŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•°å‡1 if (!disconnect) &#123; /* ä¸è¦å¿˜è®°p */ list_add_tail(&amp;p-&gt;mnt_child, &amp;p-&gt;mnt_parent-&gt;mnt_mounts); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°çˆ¶æŒ‚è½½ç‚¹çš„mnt_mountsé“¾è¡¨æœ«å°¾ &#125; else &#123; umount_mnt(p); // å¸è½½æŒ‚è½½ç‚¹ &#125; &#125; change_mnt_propagation(p, MS_PRIVATE); // ä¿®æ”¹æŒ‚è½½ç‚¹çš„ä¼ æ’­æ ‡å¿—ä¸ºMS_PRIVATE if (disconnect) hlist_add_head(&amp;p-&gt;mnt_umount, &amp;unmounted); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°unmountedå“ˆå¸Œè¡¨ä¸­ &#125;&#125;static void shrink_submounts(struct mount *mnt); 1234567891011121314151617181920212223242526272829303132333435static int do_umount_root(struct super_block *sb)&#123; int ret = 0; // è·å–è¶…çº§å—çš„å¸è½½ä¿¡å·é‡çš„å†™é” down_write(&amp;sb-&gt;s_umount); // æ£€æŸ¥è¶…çº§å—æ˜¯å¦ä¸ºåªè¯» if (!sb_rdonly(sb)) &#123; struct fs_context *fc; // åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ï¼Œç”¨äºå°†è¶…çº§å—çš„æ ¹ç›®å½•é‡æ–°é…ç½®ä¸ºåªè¯» fc = fs_context_for_reconfigure(sb-&gt;s_root, SB_RDONLY, SB_RDONLY); // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„åˆ›å»ºæ˜¯å¦æˆåŠŸ if (IS_ERR(fc)) &#123; ret = PTR_ERR(fc); // å°†è¿”å›å€¼è®¾ç½®ä¸ºé”™è¯¯ä»£ç  &#125; else &#123; // è§£ææ•´ä½“æŒ‚è½½æ•°æ®ï¼Œå¹¶æ ¹æ®è§£æç»“æœè®¾ç½®è¿”å›å€¼ ret = parse_monolithic_mount_data(fc, NULL); // å¦‚æœè§£ææˆåŠŸï¼Œåˆ™é‡æ–°é…ç½®è¶…çº§å—ï¼Œå¹¶æ ¹æ®ç»“æœè®¾ç½®è¿”å›å€¼ if (!ret) ret = reconfigure_super(fc); // é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ put_fs_context(fc); &#125; &#125; // é‡Šæ”¾è¶…çº§å—çš„å¸è½½ä¿¡å·é‡çš„å†™é” up_write(&amp;sb-&gt;s_umount); return ret; // è¿”å›æœ€ç»ˆçš„è¿”å›å€¼&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static int do_umount(struct mount *mnt, int flags)&#123; struct super_block *sb = mnt-&gt;mnt.mnt_sb; int retval; // è°ƒç”¨å®‰å…¨æ¨¡å—çš„ sb_umount å‡½æ•°ï¼Œæ£€æŸ¥æ˜¯å¦å…è®¸å¸è½½æ“ä½œ retval = security_sb_umount(&amp;mnt-&gt;mnt, flags); if (retval) return retval; /* * å…è®¸ç”¨æˆ·ç©ºé—´è¯·æ±‚è¿‡æœŸæŒ‚è½½ç‚¹è€Œä¸æ˜¯æ— æ¡ä»¶å¸è½½ã€‚åªæœ‰åœ¨ä»¥ä¸‹æƒ…å†µä¸‹æ‰ä¼šæ‰§è¡Œå¸è½½æ“ä½œï¼š * (1) æ ‡è®°å·²ç»è¢«è®¾ç½®ï¼ˆæ ‡è®°ä¼šåœ¨ mntput() ä¸­æ¸…é™¤ï¼‰ * (2) ä½¿ç”¨è®¡æ•° == 1ï¼ˆçˆ¶ vfsmountï¼‰+ 1ï¼ˆsys_umountï¼‰ */ if (flags &amp; MNT_EXPIRE) &#123; if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt || flags &amp; (MNT_FORCE | MNT_DETACH)) return -EINVAL; /* * å¦‚æœæˆ‘ä»¬æ£€æŸ¥äº†æ‰€æœ‰ç«äº‰æƒ…å†µï¼Œå¯èƒ½ä¸ä¸€å®šéœ€è¦åœ¨è¿™é‡ŒåŠ é”ï¼Œä½†è¿™æ˜¯ä¸€ä¸ªæ…¢è·¯å¾„ã€‚ */ lock_mount_hash(); if (mnt_get_count(mnt) != 2) &#123; unlock_mount_hash(); return -EBUSY; &#125; unlock_mount_hash(); if (!xchg(&amp;mnt-&gt;mnt_expiry_mark, 1)) return -EAGAIN; &#125; /* * å¦‚æœæˆ‘ä»¬å¯èƒ½éœ€è¦ä¸­æ­¢æ“ä½œä»¥é€€å‡ºæ­¤æŒ‚è½½ç‚¹ï¼Œå¹¶ä¸”å®ƒä»¬æœ¬èº«å°†æŒæœ‰èµ„æºï¼Œæˆ‘ä»¬å¿…é¡»å…è®¸æ–‡ä»¶ç³»ç»Ÿæ‰§è¡Œæ“ä½œã€‚ * åœ¨â€œUnix ä»¥ç”¨æˆ·ç©ºé—´ä¸ºä¸­å¿ƒâ€çš„ä¼ ç»Ÿä¸­ï¼Œumount_begin å¯èƒ½æ— æ³•åœ¨ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶å®Œæˆï¼Œå› ä¸ºå…¶ä»–ä»»åŠ¡å¿…é¡»è¿”å›ç­‰ç­‰ã€‚è¿™æ˜¯æŒ‚è½½ç¨‹åºç›®å‰éœ€è¦æ‹…å¿ƒçš„é—®é¢˜ã€‚ */ if (flags &amp; MNT_FORCE &amp;&amp; sb-&gt;s_op-&gt;umount_begin) &#123; sb-&gt;s_op-&gt;umount_begin(sb); &#125; /* * æ²¡æœ‰å¿…è¦ä¸ºæ­¤æµ‹è¯•è·å–é”ï¼Œä½†æµ‹è¯•æœ¬èº«çœ‹èµ·æ¥æœ‰äº›é”™è¯¯ã€‚æœ‰æ›´å¥½çš„æ›¿ä»£æ–¹æ¡ˆå—ï¼Ÿ * å“¦å“¼...åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è§†ä¸ºå¸è½½ + åˆ‡æ¢åˆ° rootfsã€‚GC æœ€ç»ˆä¼šå¤„ç†æ—§çš„ vfsmountã€‚ * å®é™…ä¸Šæ˜¯æœ‰æ„ä¹‰çš„ï¼Œç‰¹åˆ«æ˜¯å¦‚æœ rootfs åŒ…å«ä¸€ä¸ª /reboot - é™æ€äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå®ƒä¼šå…³é—­æ‰€æœ‰æè¿°ç¬¦å¹¶è°ƒç”¨ reboot(9)ã€‚ç„¶å init(8) å¯ä»¥å¸è½½ root å¹¶æ‰§è¡Œ /rebootã€‚ */ if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt &amp;&amp; !(flags &amp; MNT_DETACH)) &#123; /* * ç‰¹æ®Šæƒ…å†µä¸‹çš„â€œå¸è½½â€æ ¹ç›®å½•... * æˆ‘ä»¬åªå°è¯•å°†å…¶é‡æ–°æŒ‚è½½ä¸ºåªè¯»ã€‚ */ if (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) return -EPERM; return do_umount_root(sb); &#125; namespace_lock(); lock_mount_hash(); /* åœ¨æŒæœ‰é”çš„æƒ…å†µä¸‹é‡æ–°æ£€æŸ¥ MNT_LOCKED */ retval = -EINVAL; if (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out; event++; if (flags &amp; MNT_DETACH) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE); retval = 0; &#125; else &#123; shrink_submounts(mnt); retval = -EBUSY; if (!propagate_mount_busy(mnt, 2)) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC); retval = 0; &#125; &#125;out: unlock_mount_hash(); namespace_unlock(); return retval;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static int do_umount(struct mount *mnt, int flags)&#123; struct super_block *sb = mnt-&gt;mnt.mnt_sb; int retval; // è°ƒç”¨å®‰å…¨æ¨¡å—çš„ sb_umount å‡½æ•°ï¼Œæ£€æŸ¥æ˜¯å¦å…è®¸å¸è½½æ“ä½œ retval = security_sb_umount(&amp;mnt-&gt;mnt, flags); if (retval) return retval; /* * å…è®¸ç”¨æˆ·ç©ºé—´è¯·æ±‚è¿‡æœŸæŒ‚è½½ç‚¹è€Œä¸æ˜¯æ— æ¡ä»¶å¸è½½ã€‚åªæœ‰åœ¨ä»¥ä¸‹æƒ…å†µä¸‹æ‰ä¼šæ‰§è¡Œå¸è½½æ“ä½œï¼š * (1) æ ‡è®°å·²ç»è¢«è®¾ç½®ï¼ˆæ ‡è®°ä¼šåœ¨ mntput() ä¸­æ¸…é™¤ï¼‰ * (2) ä½¿ç”¨è®¡æ•° == 1ï¼ˆçˆ¶ vfsmountï¼‰+ 1ï¼ˆsys_umountï¼‰ */ if (flags &amp; MNT_EXPIRE) &#123; if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt || flags &amp; (MNT_FORCE | MNT_DETACH)) return -EINVAL; /* * å¦‚æœæˆ‘ä»¬æ£€æŸ¥äº†æ‰€æœ‰ç«äº‰æƒ…å†µï¼Œå¯èƒ½ä¸ä¸€å®šéœ€è¦åœ¨è¿™é‡ŒåŠ é”ï¼Œä½†è¿™æ˜¯ä¸€ä¸ªæ…¢è·¯å¾„ã€‚ */ lock_mount_hash(); if (mnt_get_count(mnt) != 2) &#123; unlock_mount_hash(); return -EBUSY; &#125; unlock_mount_hash(); if (!xchg(&amp;mnt-&gt;mnt_expiry_mark, 1)) return -EAGAIN; &#125; /* * å¦‚æœæˆ‘ä»¬å¯èƒ½éœ€è¦ä¸­æ­¢æ“ä½œä»¥é€€å‡ºæ­¤æŒ‚è½½ç‚¹ï¼Œå¹¶ä¸”å®ƒä»¬æœ¬èº«å°†æŒæœ‰èµ„æºï¼Œæˆ‘ä»¬å¿…é¡»å…è®¸æ–‡ä»¶ç³»ç»Ÿæ‰§è¡Œæ“ä½œã€‚ * åœ¨â€œUnix ä»¥ç”¨æˆ·ç©ºé—´ä¸ºä¸­å¿ƒâ€çš„ä¼ ç»Ÿä¸­ï¼Œumount_begin å¯èƒ½æ— æ³•åœ¨ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶å®Œæˆï¼Œå› ä¸ºå…¶ä»–ä»»åŠ¡å¿…é¡»è¿”å›ç­‰ç­‰ã€‚è¿™æ˜¯æŒ‚è½½ç¨‹åºç›®å‰éœ€è¦æ‹…å¿ƒçš„é—®é¢˜ã€‚ */ if (flags &amp; MNT_FORCE &amp;&amp; sb-&gt;s_op-&gt;umount_begin) &#123; sb-&gt;s_op-&gt;umount_begin(sb); &#125; /* * æ²¡æœ‰å¿…è¦ä¸ºæ­¤æµ‹è¯•è·å–é”ï¼Œä½†æµ‹è¯•æœ¬èº«çœ‹èµ·æ¥æœ‰äº›é”™è¯¯ã€‚æœ‰æ›´å¥½çš„æ›¿ä»£æ–¹æ¡ˆå—ï¼Ÿ * å“¦å“¼...åŸåˆ™ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è§†ä¸ºå¸è½½ + åˆ‡æ¢åˆ° rootfsã€‚GC æœ€ç»ˆä¼šå¤„ç†æ—§çš„ vfsmountã€‚ * å®é™…ä¸Šæ˜¯æœ‰æ„ä¹‰çš„ï¼Œç‰¹åˆ«æ˜¯å¦‚æœ rootfs åŒ…å«ä¸€ä¸ª /reboot - é™æ€äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå®ƒä¼šå…³é—­æ‰€æœ‰æè¿°ç¬¦å¹¶è°ƒç”¨ reboot(9)ã€‚ç„¶å init(8) å¯ä»¥å¸è½½ root å¹¶æ‰§è¡Œ /rebootã€‚ */ if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt &amp;&amp; !(flags &amp; MNT_DETACH)) &#123; /* * ç‰¹æ®Šæƒ…å†µä¸‹çš„â€œå¸è½½â€æ ¹ç›®å½•... * æˆ‘ä»¬åªå°è¯•å°†å…¶é‡æ–°æŒ‚è½½ä¸ºåªè¯»ã€‚ */ if (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) return -EPERM; return do_umount_root(sb); &#125; namespace_lock(); lock_mount_hash(); /* åœ¨æŒæœ‰é”çš„æƒ…å†µä¸‹é‡æ–°æ£€æŸ¥ MNT_LOCKED */ retval = -EINVAL; if (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out; event++; if (flags &amp; MNT_DETACH) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE); retval = 0; &#125; else &#123; shrink_submounts(mnt); retval = -EBUSY; if (!propagate_mount_busy(mnt, 2)) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC); retval = 0; &#125; &#125;out: unlock_mount_hash(); namespace_unlock(); return retval;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * __detach_mounts - æ‡’æƒ°åœ°å¸è½½æŒ‡å®š dentry ä¸Šçš„æ‰€æœ‰æŒ‚è½½ç‚¹ * * åœ¨ unlinkã€rmdir å’Œ d_drop è¿‡ç¨‹ä¸­ï¼Œæœ‰å¯èƒ½ä¸¢å¤±å¯¹ç°æœ‰æŒ‚è½½ç‚¹çš„è·¯å¾„ï¼Œ * å¯¼è‡´æŒ‚è½½ç‚¹æ³„æ¼ã€‚detach_mounts å…è®¸æ‡’æƒ°åœ°å¸è½½è¿™äº›æŒ‚è½½ç‚¹ï¼Œè€Œä¸æ˜¯æ³„æ¼å®ƒä»¬ã€‚ * * è°ƒç”¨è€…å¯èƒ½æŒæœ‰ dentry-&gt;d_inode-&gt;i_mutexã€‚ */void __detach_mounts(struct dentry *dentry)&#123; struct mountpoint *mp; struct mount *mnt; namespace_lock(); // é”å®šå‘½åç©ºé—´ lock_mount_hash(); // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ mp = lookup_mountpoint(dentry); // æŸ¥æ‰¾æŒ‚è½½ç‚¹ if (!mp) goto out_unlock; event++; // å¢åŠ äº‹ä»¶è®¡æ•° while (!hlist_empty(&amp;mp-&gt;m_list)) &#123; mnt = hlist_entry(mp-&gt;m_list.first, struct mount, mnt_mp_list); if (mnt-&gt;mnt.mnt_flags &amp; MNT_UMOUNT) &#123; umount_mnt(mnt); // å¸è½½æŒ‚è½½ç‚¹ hlist_add_head(&amp;mnt-&gt;mnt_umount, &amp;unmounted); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°å·²å¸è½½åˆ—è¡¨ &#125; else umount_tree(mnt, UMOUNT_CONNECTED); // å¸è½½æ•´ä¸ªæŒ‚è½½æ ‘ &#125; put_mountpoint(mp); // é‡Šæ”¾æŒ‚è½½ç‚¹å¼•ç”¨è®¡æ•°out_unlock: unlock_mount_hash(); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ namespace_unlock(); // è§£é”å‘½åç©ºé—´&#125;/* * è°ƒç”¨è€…æ˜¯å¦è¢«å…è®¸ä¿®æ”¹å…¶å‘½åç©ºé—´ï¼Ÿ */bool may_mount(void)&#123; return ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN); // æ£€æŸ¥æ˜¯å¦å…·æœ‰ CAP_SYS_ADMIN æƒé™&#125;static void warn_mandlock(void)&#123; pr_warn_once(&quot;=======================================================\\n&quot; &quot;è­¦å‘Šï¼šmand æŒ‚è½½é€‰é¡¹å·²è¢«å¼ƒç”¨ï¼Œå¹¶ä¸”åœ¨æ­¤å†…æ ¸ä¸­è¢«å¿½ç•¥ã€‚\\n&quot; &quot;ä»æŒ‚è½½ä¸­åˆ é™¤ mand é€‰é¡¹ä»¥æ¶ˆé™¤æ­¤è­¦å‘Šã€‚\\n&quot; &quot;=======================================================\\n&quot;);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int can_umount(const struct path *path, int flags)&#123; struct mount *mnt = real_mount(path-&gt;mnt); if (!may_mount()) return -EPERM; // å¦‚æœè°ƒç”¨è€…æ²¡æœ‰æŒ‚è½½æƒé™ï¼Œåˆ™è¿”å›æƒé™é”™è¯¯ if (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root) return -EINVAL; // å¦‚æœè·¯å¾„çš„ dentry ä¸æ˜¯æŒ‚è½½ç‚¹çš„æ ¹ç›®å½•ï¼Œåˆ™è¿”å›æ— æ•ˆå‚æ•°é”™è¯¯ if (!check_mnt(mnt)) return -EINVAL; // å¦‚æœæŒ‚è½½ç‚¹æ— æ•ˆï¼Œåˆ™è¿”å›æ— æ•ˆå‚æ•°é”™è¯¯ if (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) /* Check optimistically */ return -EINVAL; // å¦‚æœæŒ‚è½½ç‚¹è¢«é”å®šï¼Œåˆ™è¿”å›æ— æ•ˆå‚æ•°é”™è¯¯ if (flags &amp; MNT_FORCE &amp;&amp; !capable(CAP_SYS_ADMIN)) return -EPERM; // å¦‚æœå¼ºåˆ¶å¸è½½æ ‡å¿—è¢«è®¾ç½®ä¸”è°ƒç”¨è€…æ²¡æœ‰ CAP_SYS_ADMIN æƒé™ï¼Œåˆ™è¿”å›æƒé™é”™è¯¯ return 0; // è¿”å›æˆåŠŸ&#125;// caller is responsible for flags being saneint path_umount(struct path *path, int flags)&#123; struct mount *mnt = real_mount(path-&gt;mnt); int ret; ret = can_umount(path, flags); // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¸è½½ if (!ret) ret = do_umount(mnt, flags); // æ‰§è¡Œå¸è½½æ“ä½œ /* we mustn&#x27;t call path_put() as that would clear mnt_expiry_mark */ dput(path-&gt;dentry); // é‡Šæ”¾ dentry å¼•ç”¨è®¡æ•° mntput_no_expire(mnt); // é‡Šæ”¾æŒ‚è½½ç‚¹å¼•ç”¨è®¡æ•°ï¼Œä¸æ›´æ–°è¿‡æœŸæ ‡è®° return ret; // è¿”å›ç»“æœ&#125;static int ksys_umount(char __user *name, int flags)&#123; int lookup_flags = LOOKUP_MOUNTPOINT; struct path path; int ret; // basic validity checks done first if (flags &amp; ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW)) return -EINVAL; // å¦‚æœæ ‡å¿—ä½ä¸­åŒ…å«æœªå®šä¹‰çš„æ ‡å¿—ï¼Œåˆ™è¿”å›æ— æ•ˆå‚æ•°é”™è¯¯ if (!(flags &amp; UMOUNT_NOFOLLOW)) lookup_flags |= LOOKUP_FOLLOW; // å¦‚æœæ²¡æœ‰è®¾ç½® UMOUNT_NOFOLLOW æ ‡å¿—ï¼Œåˆ™è®¾ç½® LOOKUP_FOLLOW æ ‡å¿— ret = user_path_at(AT_FDCWD, name, lookup_flags, &amp;path); // è·å–è·¯å¾„å¯¹åº”çš„ path ç»“æ„ä½“ if (ret) return ret; // å¦‚æœè·å–è·¯å¾„å¤±è´¥ï¼Œåˆ™è¿”å›é”™è¯¯ return path_umount(&amp;path, flags); // æ‰§è¡Œè·¯å¾„å¸è½½æ“ä½œ&#125; 123456789101112131415161718192021222324252627282930313233SYSCALL_DEFINE2(umount, char __user *, name, int, flags)&#123; return ksys_umount(name, flags);&#125;#ifdef __ARCH_WANT_SYS_OLDUMOUNT/* * 2.0å…¼å®¹çš„umountï¼Œæ²¡æœ‰æ ‡å¿—ä½ã€‚ */SYSCALL_DEFINE1(oldumount, char __user *, name)&#123; return ksys_umount(name, 0);&#125;#endifstatic bool is_mnt_ns_file(struct dentry *dentry)&#123; /* è¿™æ˜¯ä¸€ä¸ªç”¨äºæŒ‚è½½å‘½åç©ºé—´çš„ä»£ç†å—ï¼Ÿ */ return dentry-&gt;d_op == &amp;ns_dentry_operations &amp;&amp; dentry-&gt;d_fsdata == &amp;mntns_operations;&#125;static struct mnt_namespace *to_mnt_ns(struct ns_common *ns)&#123; return container_of(ns, struct mnt_namespace, ns);&#125;struct ns_common *from_mnt_ns(struct mnt_namespace *mnt)&#123; return &amp;mnt-&gt;ns;&#125; 12345678910static bool mnt_ns_loop(struct dentry *dentry)&#123; /* ç»‘å®šæŒ‚è½½æŒ‚è½½å‘½åç©ºé—´inodeæ˜¯å¦ä¼šå¯¼è‡´æŒ‚è½½å‘½åç©ºé—´å¾ªç¯ï¼Ÿ */ struct mnt_namespace *mnt_ns; if (!is_mnt_ns_file(dentry)) return false; mnt_ns = to_mnt_ns(get_proc_ns(dentry-&gt;d_inode)); return current-&gt;nsproxy-&gt;mnt_ns-&gt;seq &gt;= mnt_ns-&gt;seq;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879struct mount *copy_tree(struct mount *mnt, struct dentry *dentry, int flag)&#123; // å¤åˆ¶æŒ‚è½½æ ‘ struct mount *res, *p, *q, *r, *parent; // å¦‚æœæ ‡å¿—ä½ä¸­ä¸åŒ…å«CL_COPY_UNBINDABLEï¼Œå¹¶ä¸”mntæ˜¯ä¸å¯è§£ç»‘çš„ï¼Œåˆ™è¿”å›é”™è¯¯ç EINVAL if (!(flag &amp; CL_COPY_UNBINDABLE) &amp;&amp; IS_MNT_UNBINDABLE(mnt)) return ERR_PTR(-EINVAL); // å¦‚æœæ ‡å¿—ä½ä¸­ä¸åŒ…å«CL_COPY_MNT_NS_FILEï¼Œå¹¶ä¸”dentryæ˜¯æŒ‚è½½å‘½åç©ºé—´æ–‡ä»¶ï¼Œåˆ™è¿”å›é”™è¯¯ç EINVAL if (!(flag &amp; CL_COPY_MNT_NS_FILE) &amp;&amp; is_mnt_ns_file(dentry)) return ERR_PTR(-EINVAL); // å…‹éš†æŒ‚è½½ç‚¹ res = q = clone_mnt(mnt, dentry, flag); if (IS_ERR(q)) return q; // è®¾ç½®å…‹éš†çš„æŒ‚è½½ç‚¹çš„æŒ‚è½½ç‚¹ q-&gt;mnt_mountpoint = mnt-&gt;mnt_mountpoint; // éå†æŒ‚è½½ç‚¹çš„å­æŒ‚è½½ç‚¹ p = mnt; list_for_each_entry(r, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; struct mount *s; // å¦‚æœrçš„æŒ‚è½½ç‚¹ä¸æ˜¯dentryçš„å­ç›®å½•ï¼Œåˆ™ç»§ç»­ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ if (!is_subdir(r-&gt;mnt_mountpoint, dentry)) continue; // éå†råŠå…¶å­æŒ‚è½½ç‚¹ for (s = r; s; s = next_mnt(s, r)) &#123; // å¦‚æœæ ‡å¿—ä½ä¸­ä¸åŒ…å«CL_COPY_UNBINDABLEï¼Œå¹¶ä¸”sæ˜¯ä¸å¯è§£ç»‘çš„ if (!(flag &amp; CL_COPY_UNBINDABLE) &amp;&amp; IS_MNT_UNBINDABLE(s)) &#123; // å¦‚æœsè¢«é”å®šï¼Œåˆ™è¿”å›é”™è¯¯ç EPERMï¼›å¦åˆ™è·³è¿‡è¯¥æŒ‚è½½ç‚¹åŠå…¶å­æŒ‚è½½ç‚¹ if (s-&gt;mnt.mnt_flags &amp; MNT_LOCKED) &#123; /* åŒæ—¶ä¸å¯è§£ç»‘å’Œè¢«é”å®šã€‚ */ q = ERR_PTR(-EPERM); goto out; &#125; else &#123; s = skip_mnt_tree(s); continue; &#125; &#125; // å¦‚æœæ ‡å¿—ä½ä¸­ä¸åŒ…å«CL_COPY_MNT_NS_FILEï¼Œå¹¶ä¸”sæ˜¯æŒ‚è½½å‘½åç©ºé—´æ–‡ä»¶ï¼Œåˆ™è·³è¿‡è¯¥æŒ‚è½½ç‚¹åŠå…¶å­æŒ‚è½½ç‚¹ if (!(flag &amp; CL_COPY_MNT_NS_FILE) &amp;&amp; is_mnt_ns_file(s-&gt;mnt.mnt_root)) &#123; s = skip_mnt_tree(s); continue; &#125; // å°†på’Œqç§»åŠ¨åˆ°sçš„çˆ¶æŒ‚è½½ç‚¹ while (p != s-&gt;mnt_parent) &#123; p = p-&gt;mnt_parent; q = q-&gt;mnt_parent; &#125; p = s; parent = q; // å…‹éš†æŒ‚è½½ç‚¹ q = clone_mnt(p, p-&gt;mnt.mnt_root, flag); if (IS_ERR(q)) goto out; // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ï¼Œå°†å…‹éš†çš„æŒ‚è½½ç‚¹æ·»åŠ åˆ°ç»“æœæŒ‚è½½ç‚¹çš„é“¾è¡¨ä¸­ï¼Œå¹¶å»ºç«‹æŒ‚è½½å…³ç³» lock_mount_hash(); list_add_tail(&amp;q-&gt;mnt_list, &amp;res-&gt;mnt_list); attach_mnt(q, parent, p-&gt;mnt_mp); unlock_mount_hash(); &#125; &#125; return res;out: // å¦‚æœå‡ºé”™ï¼Œåˆ™é‡Šæ”¾å·²åˆ†é…çš„èµ„æº if (res) &#123; lock_mount_hash(); umount_tree(res, UMOUNT_SYNC); unlock_mount_hash(); &#125; return q;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * collect_mounts - æ”¶é›†æŒ‚è½½ç‚¹ * @path: è¦æ”¶é›†çš„è·¯å¾„ * * è°ƒç”¨è€…åº”è¯¥æ£€æŸ¥è¿”å›çš„æŒ‡é’ˆæ˜¯å¦æœ‰é”™è¯¯ã€‚ */struct vfsmount *collect_mounts(const struct path *path)&#123; struct mount *tree; namespace_lock(); // è·å–å‘½åç©ºé—´é” if (!check_mnt(real_mount(path-&gt;mnt))) // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦æœ‰æ•ˆ tree = ERR_PTR(-EINVAL); else tree = copy_tree(real_mount(path-&gt;mnt), path-&gt;dentry, CL_COPY_ALL | CL_PRIVATE); // å¤åˆ¶æŒ‚è½½ç‚¹æ ‘ namespace_unlock(); // é‡Šæ”¾å‘½åç©ºé—´é” if (IS_ERR(tree)) // æ£€æŸ¥æ˜¯å¦å‡ºé”™ return ERR_CAST(tree); return &amp;tree-&gt;mnt; // è¿”å›æŒ‚è½½ç‚¹æ ‘&#125;static void free_mnt_ns(struct mnt_namespace *);static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *, bool);void dissolve_on_fput(struct vfsmount *mnt)&#123; struct mnt_namespace *ns; namespace_lock(); // è·å–å‘½åç©ºé—´é” lock_mount_hash(); // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ ns = real_mount(mnt)-&gt;mnt_ns; if (ns) &#123; if (is_anon_ns(ns)) umount_tree(real_mount(mnt), UMOUNT_CONNECTED); // è§£é™¤è¿æ¥çš„æŒ‚è½½ç‚¹æ ‘ else ns = NULL; &#125; unlock_mount_hash(); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ namespace_unlock(); // é‡Šæ”¾å‘½åç©ºé—´é” if (ns) free_mnt_ns(ns); // é‡Šæ”¾æŒ‚è½½å‘½åç©ºé—´&#125;void drop_collected_mounts(struct vfsmount *mnt)&#123; namespace_lock(); // è·å–å‘½åç©ºé—´é” lock_mount_hash(); // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ umount_tree(real_mount(mnt), 0); // å¸è½½æŒ‚è½½ç‚¹æ ‘ unlock_mount_hash(); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ namespace_unlock(); // é‡Šæ”¾å‘½åç©ºé—´é”&#125;static bool has_locked_children(struct mount *mnt, struct dentry *dentry)&#123; struct mount *child; list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; if (!is_subdir(child-&gt;mnt_mountpoint, dentry)) // æ£€æŸ¥æ˜¯å¦ä¸ºå­ç›®å½• continue; if (child-&gt;mnt.mnt_flags &amp; MNT_LOCKED) // æ£€æŸ¥æ˜¯å¦æœ‰è¢«é”å®šçš„å­æŒ‚è½½ç‚¹ return true; &#125; return false;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static void lock_mnt_tree(struct mount *mnt)&#123; struct mount *p; // éå†æŒ‚è½½ç‚¹æ ‘ for (p = mnt; p; p = next_mnt(p, mnt)) &#123; int flags = p-&gt;mnt.mnt_flags; /* ä¸å…è®¸éç‰¹æƒç”¨æˆ·æ›´æ”¹æŒ‚è½½æ ‡å¿— */ flags |= MNT_LOCK_ATIME; // å°†æŒ‚è½½æ ‡å¿—ä¸­çš„MNT_LOCK_ATIMEè®¾ç½®ä¸º1 if (flags &amp; MNT_READONLY) // å¦‚æœæŒ‚è½½æ ‡å¿—ä¸­åŒ…å«MNT_READONLY flags |= MNT_LOCK_READONLY; // å°†æŒ‚è½½æ ‡å¿—ä¸­çš„MNT_LOCK_READONLYè®¾ç½®ä¸º1 if (flags &amp; MNT_NODEV) // å¦‚æœæŒ‚è½½æ ‡å¿—ä¸­åŒ…å«MNT_NODEV flags |= MNT_LOCK_NODEV; // å°†æŒ‚è½½æ ‡å¿—ä¸­çš„MNT_LOCK_NODEVè®¾ç½®ä¸º1 if (flags &amp; MNT_NOSUID) // å¦‚æœæŒ‚è½½æ ‡å¿—ä¸­åŒ…å«MNT_NOSUID flags |= MNT_LOCK_NOSUID; // å°†æŒ‚è½½æ ‡å¿—ä¸­çš„MNT_LOCK_NOSUIDè®¾ç½®ä¸º1 if (flags &amp; MNT_NOEXEC) // å¦‚æœæŒ‚è½½æ ‡å¿—ä¸­åŒ…å«MNT_NOEXEC flags |= MNT_LOCK_NOEXEC; // å°†æŒ‚è½½æ ‡å¿—ä¸­çš„MNT_LOCK_NOEXECè®¾ç½®ä¸º1 /* ä¸å…è®¸éç‰¹æƒç”¨æˆ·æŸ¥çœ‹æŒ‚è½½ç‚¹ä¸‹çš„å†…å®¹ */ if (list_empty(&amp;p-&gt;mnt_expire)) flags |= MNT_LOCKED; // å°†æŒ‚è½½æ ‡å¿—ä¸­çš„MNT_LOCKEDè®¾ç½®ä¸º1 p-&gt;mnt.mnt_flags = flags; // æ›´æ–°æŒ‚è½½ç‚¹çš„æŒ‚è½½æ ‡å¿— &#125;&#125;static void cleanup_group_ids(struct mount *mnt, struct mount *end)&#123; struct mount *p; // æ¸…ç†æŒ‚è½½ç‚¹çš„ç»„ID for (p = mnt; p != end; p = next_mnt(p, mnt)) &#123; if (p-&gt;mnt_group_id &amp;&amp; !IS_MNT_SHARED(p)) mnt_release_group_id(p); // é‡Šæ”¾æŒ‚è½½ç‚¹çš„ç»„ID &#125;&#125;static int invent_group_ids(struct mount *mnt, bool recurse)&#123; struct mount *p; // ä¸ºæŒ‚è½½ç‚¹åˆ†é…ç»„ID for (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) &#123; if (!p-&gt;mnt_group_id &amp;&amp; !IS_MNT_SHARED(p)) &#123; int err = mnt_alloc_group_id(p); // åˆ†é…æŒ‚è½½ç‚¹çš„ç»„ID if (err) &#123; cleanup_group_ids(mnt, p); // åˆ†é…å¤±è´¥æ—¶æ¸…ç†ä¹‹å‰åˆ†é…çš„ç»„ID return err; &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122int count_mounts(struct mnt_namespace *ns, struct mount *mnt)&#123; unsigned int max = READ_ONCE(sysctl_mount_max); // è¯»å–sysctl_mount_maxçš„å€¼å¹¶èµ‹ç»™max unsigned int mounts = 0; // åˆå§‹åŒ–mountsä¸º0ï¼Œç”¨äºè®¡æ•° struct mount *p; if (ns-&gt;mounts &gt;= max) // å¦‚æœnsçš„mountsè®¡æ•°è¶…è¿‡äº†max return -ENOSPC; // è¿”å›&quot;æ²¡æœ‰ç©ºé—´&quot;çš„é”™è¯¯ç  max -= ns-&gt;mounts; // æ›´æ–°maxçš„å€¼ï¼Œå‡å»å·²æœ‰çš„mountsè®¡æ•° if (ns-&gt;pending_mounts &gt;= max) // å¦‚æœnsçš„pending_mountsè®¡æ•°è¶…è¿‡äº†max return -ENOSPC; // è¿”å›&quot;æ²¡æœ‰ç©ºé—´&quot;çš„é”™è¯¯ç  max -= ns-&gt;pending_mounts; // æ›´æ–°maxçš„å€¼ï¼Œå‡å»å·²æœ‰çš„pending_mountsè®¡æ•° for (p = mnt; p; p = next_mnt(p, mnt)) // éå†æŒ‚è½½ç‚¹é“¾è¡¨ mounts++; // æ¯éå†ä¸€ä¸ªæŒ‚è½½ç‚¹ï¼Œmountsè®¡æ•°åŠ 1 if (mounts &gt; max) // å¦‚æœmountsè®¡æ•°è¶…è¿‡äº†max return -ENOSPC; // è¿”å›&quot;æ²¡æœ‰ç©ºé—´&quot;çš„é”™è¯¯ç  ns-&gt;pending_mounts += mounts; // æ›´æ–°nsçš„pending_mountsè®¡æ•°ï¼ŒåŠ ä¸Šæ–°çš„mountsè®¡æ•° return 0; // è¿”å›æˆåŠŸçš„çŠ¶æ€ç &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * @source_mnt : è¦é™„åŠ çš„æŒ‚è½½æ ‘ * @nd : å°†æŒ‚è½½æ ‘ @source_mnt é™„åŠ åˆ°çš„ä½ç½® * @parent_nd : å¦‚æœéç©ºï¼Œå°† source_mnt ä»å…¶çˆ¶èŠ‚ç‚¹åˆ†ç¦»ï¼Œå¹¶å­˜å‚¨çˆ¶èŠ‚ç‚¹æŒ‚è½½å’ŒæŒ‚è½½ç‚¹ dentryã€‚ * ï¼ˆå½“ç§»åŠ¨ source_mnt æ—¶æ‰§è¡Œæ­¤æ“ä½œï¼‰ * * æ³¨æ„ï¼šä¸‹è¡¨è§£é‡Šäº†ç»™å®šç±»å‹çš„æºæŒ‚è½½é™„åŠ åˆ°ç»™å®šç±»å‹çš„ç›®æ ‡æŒ‚è½½æ—¶çš„è¯­ä¹‰ã€‚ * --------------------------------------------------------------------------- * | ç»‘å®šæŒ‚è½½æ“ä½œ | * |************************************************************************** * | source--&gt;| å…±äº« | ç§æœ‰ | ä»å± | ä¸å¯è§£ç»‘ | * | dest | | | | | * | | | | | | | * | v | | | | | * |************************************************************************** * | å…±äº« | å…±äº« (++) | å…±äº« (+) | å…±äº«(+++) | æ— æ•ˆ | * | | | | | | * |éå…±äº« | å…±äº« (+) | ç§æœ‰ | ä»å± (*) | æ— æ•ˆ | * *************************************************************************** * ç»‘å®šæ“ä½œå…‹éš†æºæŒ‚è½½å¹¶å°†å…‹éš†æŒ‚è½½åˆ°ç›®æ ‡æŒ‚è½½ä¸Šã€‚ * * (++) å…‹éš†çš„æŒ‚è½½ä¼ æ’­åˆ°ç›®æ ‡æŒ‚è½½çš„ä¼ æ’­æ ‘ä¸­çš„æ‰€æœ‰æŒ‚è½½ç‚¹ï¼Œå¹¶å°†å…‹éš†çš„æŒ‚è½½æ·»åŠ åˆ°æºæŒ‚è½½çš„å¯¹ç­‰ç»„ä¸­ã€‚ * (+) å…‹éš†çš„æŒ‚è½½åœ¨ç›®æ ‡æŒ‚è½½ä¸‹åˆ›å»ºï¼Œå¹¶æ ‡è®°ä¸ºå…±äº«ã€‚å…‹éš†çš„æŒ‚è½½æ·»åŠ åˆ°æºæŒ‚è½½çš„å¯¹ç­‰ç»„ä¸­ã€‚ * (+++) æŒ‚è½½ä¼ æ’­åˆ°ç›®æ ‡æŒ‚è½½çš„ä¼ æ’­æ ‘ä¸­çš„æ‰€æœ‰æŒ‚è½½ç‚¹ï¼Œå¹¶å°†å…‹éš†çš„æŒ‚è½½ä½œä¸ºæºæŒ‚è½½çš„ä»å±æŒ‚è½½ï¼Œä¸æºæŒ‚è½½ç›¸åŒçš„ä¸»æŒ‚è½½ã€‚å…‹éš†çš„æŒ‚è½½æ ‡è®°ä¸ºâ€œå…±äº«å’Œä»å±â€ã€‚ * (*) å…‹éš†çš„æŒ‚è½½ä½œä¸ºæºæŒ‚è½½çš„ä»å±æŒ‚è½½ï¼Œä¸æºæŒ‚è½½ç›¸åŒçš„ä¸»æŒ‚è½½ã€‚ * * --------------------------------------------------------------------------- * | ç§»åŠ¨æŒ‚è½½æ“ä½œ | * |************************************************************************** * | source--&gt;| å…±äº« | ç§æœ‰ | ä»å± | ä¸å¯è§£ç»‘ | * | dest | | | | | * | | | | | | | * | v | | | | | * |************************************************************************** * | å…±äº« | å…±äº« (+) | å…±äº« (+) | å…±äº«(+++) | æ— æ•ˆ | * | | | | | | * |éå…±äº« | å…±äº« (+*) | ç§æœ‰ | ä»å± (*) | ä¸å¯è§£ç»‘ | * *************************************************************************** * * (+) æŒ‚è½½è¢«ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼Œå¹¶ä¼ æ’­åˆ°ç›®æ ‡æŒ‚è½½çš„ä¼ æ’­æ ‘ä¸­çš„æ‰€æœ‰æŒ‚è½½ç‚¹ã€‚ * (+*) æŒ‚è½½è¢«ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ã€‚ * (+++) æŒ‚è½½è¢«ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®ï¼Œå¹¶ä¼ æ’­åˆ°ç›®æ ‡æŒ‚è½½çš„ä¼ æ’­æ ‘ä¸­çš„æ‰€æœ‰æŒ‚è½½ç‚¹ã€‚æŒ‚è½½è¢«æ ‡è®°ä¸ºâ€œå…±äº«å’Œä»å±â€ã€‚ * (*) æŒ‚è½½åœ¨æ–°ä½ç½®ç»§ç»­ä½œä¸ºä»å±æŒ‚è½½ã€‚ * * å¦‚æœæºæŒ‚è½½æ˜¯ä¸€ä¸ªæ ‘ï¼Œåˆ™ä¸Šè¿°æ“ä½œå°†åº”ç”¨äºæ ‘ä¸­çš„æ¯ä¸ªæŒ‚è½½ã€‚ * å¿…é¡»åœ¨æœªæŒæœ‰è‡ªæ—‹é”çš„æƒ…å†µä¸‹è°ƒç”¨æ­¤å‡½æ•°ï¼Œå› ä¸ºæ­¤å‡½æ•°å¯èƒ½ä¼šåœ¨åˆ†é…æ—¶ä¼‘çœ ã€‚ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static int attach_recursive_mnt(struct mount *source_mnt, struct mount *dest_mnt, struct mountpoint *dest_mp, bool moving)&#123; // è·å–å½“å‰è¿›ç¨‹çš„ç”¨æˆ·å‘½åç©ºé—´ struct user_namespace *user_ns = current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns; // åˆ›å»ºä¸€ä¸ªå“ˆå¸Œé“¾è¡¨ç”¨äºå­˜å‚¨æ ‘çŠ¶ç»“æ„çš„æŒ‚è½½ç‚¹ HLIST_HEAD(tree_list); // è·å–ç›®æ ‡æŒ‚è½½ç‚¹çš„å‘½åç©ºé—´ struct mnt_namespace *ns = dest_mnt-&gt;mnt_ns; struct mountpoint *smp; struct mount *child, *p; struct hlist_node *n; int err; /* Preallocate a mountpoint in case the new mounts need * to be tucked under other mounts. */ // é¢„åˆ†é…ä¸€ä¸ªæŒ‚è½½ç‚¹ï¼Œä»¥ä¾¿å°†æ–°çš„æŒ‚è½½ç‚¹æ”¾ç½®åœ¨å…¶ä»–æŒ‚è½½ç‚¹ä¸‹é¢ smp = get_mountpoint(source_mnt-&gt;mnt.mnt_root); if (IS_ERR(smp)) return PTR_ERR(smp); /* Is there space to add these mounts to the mount namespace? */ // æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç©ºé—´å°†è¿™äº›æŒ‚è½½ç‚¹æ·»åŠ åˆ°æŒ‚è½½å‘½åç©ºé—´ä¸­ if (!moving) &#123; err = count_mounts(ns, source_mnt); if (err) goto out; &#125; if (IS_MNT_SHARED(dest_mnt)) &#123; // ä¸ºæºæŒ‚è½½ç‚¹åˆ›å»ºç»„ID err = invent_group_ids(source_mnt, true); if (err) goto out; // å°†æºæŒ‚è½½ç‚¹ä¼ æ’­åˆ°ç›®æ ‡æŒ‚è½½ç‚¹ä¸‹çš„æ ‘çŠ¶ç»“æ„ä¸­ err = propagate_mnt(dest_mnt, dest_mp, source_mnt, &amp;tree_list); lock_mount_hash(); if (err) goto out_cleanup_ids; // å°†æºæŒ‚è½½ç‚¹åŠå…¶å­æŒ‚è½½ç‚¹è®¾ç½®ä¸ºå…±äº«æŒ‚è½½ç‚¹ for (p = source_mnt; p; p = next_mnt(p, source_mnt)) set_mnt_shared(p); &#125; else &#123; lock_mount_hash(); &#125; if (moving) &#123; // ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤æºæŒ‚è½½ç‚¹ unhash_mnt(source_mnt); // å°†æºæŒ‚è½½ç‚¹é™„åŠ åˆ°ç›®æ ‡æŒ‚è½½ç‚¹ä¸‹çš„æŒ‚è½½ç‚¹ attach_mnt(source_mnt, dest_mnt, dest_mp); // æ›´æ–°æºæŒ‚è½½ç‚¹æ‰€å±çš„æŒ‚è½½å‘½åç©ºé—´ touch_mnt_namespace(source_mnt-&gt;mnt_ns); &#125; else &#123; if (source_mnt-&gt;mnt_ns) &#123; /* move from anon - the caller will destroy */ // ä»åŒ¿åå‘½åç©ºé—´ä¸­ç§»åŠ¨æŒ‚è½½ç‚¹ï¼Œè°ƒç”¨è€…å°†é”€æ¯è¯¥æŒ‚è½½ç‚¹ list_del_init(&amp;source_mnt-&gt;mnt_ns-&gt;list); &#125; // è®¾ç½®æºæŒ‚è½½ç‚¹çš„æŒ‚è½½ç‚¹ä¿¡æ¯ mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt); // æäº¤æºæŒ‚è½½ç‚¹çš„æ ‘çŠ¶ç»“æ„ commit_tree(source_mnt); &#125; // éå†æ ‘çŠ¶ç»“æ„ä¸­çš„æ¯ä¸ªå­æŒ‚è½½ç‚¹ hlist_for_each_entry_safe(child, n, &amp;tree_list, mnt_hash) &#123; struct mount *q; // ä»æ ‘çŠ¶ç»“æ„ä¸­ç§»é™¤å­æŒ‚è½½ç‚¹ hlist_del_init(&amp;child-&gt;mnt_hash); // æŸ¥æ‰¾å­æŒ‚è½½ç‚¹çš„çˆ¶æŒ‚è½½ç‚¹ q = __lookup_mnt(&amp;child-&gt;mnt_parent-&gt;mnt, child-&gt;mnt_mountpoint); if (q) // æ›´æ”¹å­æŒ‚è½½ç‚¹çš„æŒ‚è½½ç‚¹ä¿¡æ¯ mnt_change_mountpoint(child, smp, q); /* Notice when we are propagating across user namespaces */ // å½“åœ¨ç”¨æˆ·å‘½åç©ºé—´ä¹‹é—´ä¼ æ’­æ—¶ï¼Œéœ€è¦é”å®šæŒ‚è½½æ ‘ if (child-&gt;mnt_parent-&gt;mnt_ns-&gt;user_ns != user_ns) lock_mnt_tree(child); // æ¸…é™¤å­æŒ‚è½½ç‚¹çš„é”å®šæ ‡å¿— child-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED; // æäº¤å­æŒ‚è½½ç‚¹çš„æ ‘çŠ¶ç»“æ„ commit_tree(child); &#125; // é‡Šæ”¾æŒ‚è½½ç‚¹ put_mountpoint(smp); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ unlock_mount_hash(); return 0;out_cleanup_ids: // æ¸…ç†ç»„ID while (!hlist_empty(&amp;tree_list)) &#123; child = hlist_entry(tree_list.first, struct mount, mnt_hash); child-&gt;mnt_parent-&gt;mnt_ns-&gt;pending_mounts = 0; // å¸è½½å­æŒ‚è½½ç‚¹çš„æ ‘çŠ¶ç»“æ„ umount_tree(child, UMOUNT_SYNC); &#125; unlock_mount_hash(); // æ¸…ç†ç»„ID cleanup_group_ids(source_mnt, NULL);out: ns-&gt;pending_mounts = 0; read_seqlock_excl(&amp;mount_lock); // é‡Šæ”¾æŒ‚è½½ç‚¹ put_mountpoint(smp); read_sequnlock_excl(&amp;mount_lock); return err;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static struct mountpoint *lock_mount(struct path *path)&#123; struct vfsmount *mnt; struct dentry *dentry = path-&gt;dentry;retry: // é”å®šinode inode_lock(dentry-&gt;d_inode); if (unlikely(cant_mount(dentry))) &#123; // å¦‚æœæ— æ³•æŒ‚è½½ï¼Œåˆ™è§£é”inodeå¹¶è¿”å›é”™è¯¯æŒ‡é’ˆ inode_unlock(dentry-&gt;d_inode); return ERR_PTR(-ENOENT); &#125; // é”å®šå‘½åç©ºé—´ namespace_lock(); // æŸ¥æ‰¾æŒ‚è½½ç‚¹ mnt = lookup_mnt(path); if (likely(!mnt)) &#123; // å¦‚æœæ‰¾ä¸åˆ°æŒ‚è½½ç‚¹ï¼Œåˆ™è·å–æŒ‚è½½ç‚¹ struct mountpoint *mp = get_mountpoint(dentry); if (IS_ERR(mp)) &#123; // å¦‚æœè·å–æŒ‚è½½ç‚¹å¤±è´¥ï¼Œåˆ™è§£é”å‘½åç©ºé—´å’Œinodeï¼Œå¹¶è¿”å›é”™è¯¯æŒ‡é’ˆ namespace_unlock(); inode_unlock(dentry-&gt;d_inode); return mp; &#125; // è¿”å›æŒ‚è½½ç‚¹ return mp; &#125; // è§£é”å‘½åç©ºé—´å’Œinode namespace_unlock(); inode_unlock(path-&gt;dentry-&gt;d_inode); // é‡Šæ”¾è·¯å¾„ï¼Œå¹¶å°†mntèµ‹å€¼ç»™è·¯å¾„çš„mntæˆå‘˜ï¼Œå°†mntçš„mnt_rootèµ‹å€¼ç»™è·¯å¾„çš„dentryæˆå‘˜ path_put(path); path-&gt;mnt = mnt; dentry = path-&gt;dentry = dget(mnt-&gt;mnt_root); // é‡æ–°å°è¯• goto retry;&#125;static void unlock_mount(struct mountpoint *where)&#123; struct dentry *dentry = where-&gt;m_dentry; // è·å–è¯»å†™åºåˆ—é” read_seqlock_excl(&amp;mount_lock); // é‡Šæ”¾æŒ‚è½½ç‚¹ put_mountpoint(where); // è§£é”è¯»å†™åºåˆ—é” read_sequnlock_excl(&amp;mount_lock); // è§£é”å‘½åç©ºé—´å’Œinode namespace_unlock(); inode_unlock(dentry-&gt;d_inode);&#125;static int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)&#123; // æ£€æŸ¥æ˜¯å¦ç¦æ­¢ç”¨æˆ·æŒ‚è½½ if (mnt-&gt;mnt.mnt_sb-&gt;s_flags &amp; SB_NOUSER) return -EINVAL; // æ£€æŸ¥æŒ‚è½½ç‚¹å’ŒæŒ‚è½½æºæ˜¯å¦éƒ½ä¸ºç›®å½• if (d_is_dir(mp-&gt;m_dentry) != d_is_dir(mnt-&gt;mnt.mnt_root)) return -ENOTDIR; // é€’å½’æŒ‚è½½å­æ ‘ return attach_recursive_mnt(mnt, p, mp, false);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * æ£€æŸ¥æ›´æ”¹æŒ‚è½½ç‚¹ä¼ æ’­æ ‡å¿—çš„æ ‡å¿—ä½æ˜¯å¦åˆæ³•ã€‚ */static int flags_to_propagation_type(int ms_flags)&#123; int type = ms_flags &amp; ~(MS_REC | MS_SILENT); /* å¦‚æœè®¾ç½®äº†éä¼ æ’­æ ‡å¿—ï¼Œåˆ™å¤±è´¥ */ if (type &amp; ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) return 0; /* åªèƒ½è®¾ç½®ä¸€ä¸ªä¼ æ’­æ ‡å¿— */ if (!is_power_of_2(type)) return 0; return type;&#125;/* * é€’å½’åœ°æ›´æ”¹æŒ‚è½½ç‚¹çš„ç±»å‹ã€‚ */static int do_change_type(struct path *path, int ms_flags)&#123; struct mount *m; struct mount *mnt = real_mount(path-&gt;mnt); int recurse = ms_flags &amp; MS_REC; int type; int err = 0; if (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root) return -EINVAL; type = flags_to_propagation_type(ms_flags); if (!type) return -EINVAL; // é”å®šå‘½åç©ºé—´ namespace_lock(); if (type == MS_SHARED) &#123; // ä¸ºæŒ‚è½½ç‚¹åˆ›å»ºç»„ID err = invent_group_ids(mnt, recurse); if (err) goto out_unlock; &#125; // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ lock_mount_hash(); for (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL)) // æ›´æ”¹æŒ‚è½½ç‚¹çš„ä¼ æ’­ç±»å‹ change_mnt_propagation(m, type); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ unlock_mount_hash();out_unlock: // è§£é”å‘½åç©ºé—´ namespace_unlock(); return err;&#125;static struct mount *__do_loopback(struct path *old_path, int recurse)&#123; struct mount *mnt = ERR_PTR(-EINVAL), *old = real_mount(old_path-&gt;mnt); // å¦‚æœæŒ‚è½½ç‚¹ä¸å¯è§£ç»‘ï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ if (IS_MNT_UNBINDABLE(old)) return mnt; // å¦‚æœæŒ‚è½½ç‚¹æ— æ•ˆä¸”dentryæ“ä½œä¸æ˜¯ns_dentry_operationsï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ if (!check_mnt(old) &amp;&amp; old_path-&gt;dentry-&gt;d_op != &amp;ns_dentry_operations) return mnt; // å¦‚æœä¸é€’å½’ä¸”æŒ‚è½½ç‚¹æœ‰é”å®šçš„å­èŠ‚ç‚¹ï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ if (!recurse &amp;&amp; has_locked_children(old, old_path-&gt;dentry)) return mnt; if (recurse) // å¤åˆ¶æ ‘ç»“æ„ mnt = copy_tree(old, old_path-&gt;dentry, CL_COPY_MNT_NS_FILE); else // å…‹éš†æŒ‚è½½ç‚¹ mnt = clone_mnt(old, old_path-&gt;dentry, 0); if (!IS_ERR(mnt)) // æ¸…é™¤MNT_LOCKEDæ ‡å¿— mnt-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED; return mnt;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * æ‰§è¡Œå›ç¯æŒ‚è½½ã€‚ */static int do_loopback(struct path *path, const char *old_name, int recurse)&#123; struct path old_path; struct mount *mnt = NULL, *parent; struct mountpoint *mp; int err; if (!old_name || !*old_name) return -EINVAL; // è·å–æ—§è·¯å¾„ err = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &amp;old_path); if (err) return err; err = -EINVAL; // å¦‚æœæ—§è·¯å¾„çš„dentryå±äºmntå‘½åç©ºé—´ï¼Œåˆ™è·³è½¬åˆ°out if (mnt_ns_loop(old_path.dentry)) goto out; // é”å®šæŒ‚è½½ç‚¹ mp = lock_mount(path); if (IS_ERR(mp)) &#123; err = PTR_ERR(mp); goto out; &#125; // è·å–æŒ‚è½½ç‚¹çš„çœŸå®æŒ‚è½½ parent = real_mount(path-&gt;mnt); // å¦‚æœæŒ‚è½½ç‚¹æ— æ•ˆï¼Œåˆ™è·³è½¬åˆ°out2 if (!check_mnt(parent)) goto out2; // æ‰§è¡Œå›ç¯æŒ‚è½½ mnt = __do_loopback(&amp;old_path, recurse); if (IS_ERR(mnt)) &#123; err = PTR_ERR(mnt); goto out2; &#125; // å°†å›ç¯æŒ‚è½½çš„å­æ ‘æ¥å…¥åˆ°çˆ¶æŒ‚è½½ç‚¹ä¸‹ err = graft_tree(mnt, parent, mp); if (err) &#123; // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ lock_mount_hash(); // å¸è½½å›ç¯æŒ‚è½½çš„å­æ ‘ umount_tree(mnt, UMOUNT_SYNC); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ unlock_mount_hash(); &#125;out2: // è§£é”æŒ‚è½½ç‚¹ unlock_mount(mp);out: // é‡Šæ”¾æ—§è·¯å¾„ path_put(&amp;old_path); return err;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static struct file *open_detached_copy(struct path *path, bool recursive)&#123; struct user_namespace *user_ns = current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns; struct mnt_namespace *ns = alloc_mnt_ns(user_ns, true); struct mount *mnt, *p; struct file *file; if (IS_ERR(ns)) return ERR_CAST(ns); // é”å®šå‘½åç©ºé—´ namespace_lock(); // æ‰§è¡Œå›ç¯æŒ‚è½½ mnt = __do_loopback(path, recursive); if (IS_ERR(mnt)) &#123; namespace_unlock(); free_mnt_ns(ns); return ERR_CAST(mnt); &#125; // é”å®šæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ lock_mount_hash(); for (p = mnt; p; p = next_mnt(p, mnt)) &#123; // è®¾ç½®æŒ‚è½½ç‚¹çš„å‘½åç©ºé—´ p-&gt;mnt_ns = ns; ns-&gt;mounts++; &#125; // è®¾ç½®å‘½åç©ºé—´çš„æ ¹æŒ‚è½½ç‚¹ ns-&gt;root = mnt; // å°†å‘½åç©ºé—´æ·»åŠ åˆ°æŒ‚è½½ç‚¹çš„é“¾è¡¨ä¸­ list_add_tail(&amp;ns-&gt;list, &amp;mnt-&gt;mnt_list); mntget(&amp;mnt-&gt;mnt); // è§£é”æŒ‚è½½ç‚¹å“ˆå¸Œè¡¨ unlock_mount_hash(); // è§£é”å‘½åç©ºé—´ namespace_unlock(); // é‡Šæ”¾åŸè·¯å¾„çš„æŒ‚è½½ç‚¹ mntput(path-&gt;mnt); // å°†æ–°çš„æŒ‚è½½ç‚¹èµ‹å€¼ç»™è·¯å¾„çš„mntæˆå‘˜ path-&gt;mnt = &amp;mnt-&gt;mnt; // æ‰“å¼€è·¯å¾„å¯¹åº”çš„æ–‡ä»¶ file = dentry_open(path, O_PATH, current_cred()); if (IS_ERR(file)) // å¦‚æœæ‰“å¼€æ–‡ä»¶å¤±è´¥ï¼Œåˆ™è§£æ•£æŒ‚è½½ç‚¹ dissolve_on_fput(path-&gt;mnt); else // å¦‚æœæˆåŠŸæ‰“å¼€æ–‡ä»¶ï¼Œåˆ™è®¾ç½®æ–‡ä»¶çš„f_modeæ ‡å¿— file-&gt;f_mode |= FMODE_NEED_UNMOUNT; return file;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152SYSCALL_DEFINE3(open_tree, int, dfd, const char __user *, filename, unsigned, flags)&#123; struct file *file; // æ–‡ä»¶æŒ‡é’ˆ struct path path; // è·¯å¾„ç»“æ„ä½“ int lookup_flags = LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW; // æŸ¥æ‰¾æ ‡å¿— bool detached = flags &amp; OPEN_TREE_CLONE; // æ˜¯å¦åˆ†ç¦» int error; // é”™è¯¯ç  int fd; // æ–‡ä»¶æè¿°ç¬¦ BUILD_BUG_ON(OPEN_TREE_CLOEXEC != O_CLOEXEC); // ç¼–è¯‘æ—¶æ£€æŸ¥ if (flags &amp; ~(AT_EMPTY_PATH | AT_NO_AUTOMOUNT | AT_RECURSIVE | AT_SYMLINK_NOFOLLOW | OPEN_TREE_CLONE | OPEN_TREE_CLOEXEC)) return -EINVAL; // å‚æ•°é”™è¯¯ if ((flags &amp; (AT_RECURSIVE | OPEN_TREE_CLONE)) == AT_RECURSIVE) return -EINVAL; // å‚æ•°é”™è¯¯ if (flags &amp; AT_NO_AUTOMOUNT) lookup_flags &amp;= ~LOOKUP_AUTOMOUNT; // ä¸è‡ªåŠ¨æŒ‚è½½ if (flags &amp; AT_SYMLINK_NOFOLLOW) lookup_flags &amp;= ~LOOKUP_FOLLOW; // ä¸è·Ÿéšç¬¦å·é“¾æ¥ if (flags &amp; AT_EMPTY_PATH) lookup_flags |= LOOKUP_EMPTY; // ç©ºè·¯å¾„ if (detached &amp;&amp; !may_mount()) return -EPERM; // æ²¡æœ‰æƒé™ fd = get_unused_fd_flags(flags &amp; O_CLOEXEC); // è·å–æœªä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦ if (fd &lt; 0) return fd; // è·å–å¤±è´¥ error = user_path_at(dfd, filename, lookup_flags, &amp;path); // è·å–ç”¨æˆ·è·¯å¾„ if (unlikely(error)) &#123; file = ERR_PTR(error); // é”™è¯¯å¤„ç† &#125; else &#123; if (detached) file = open_detached_copy(&amp;path, flags &amp; AT_RECURSIVE); // åˆ†ç¦»å¤åˆ¶ else file = dentry_open(&amp;path, O_PATH, current_cred()); // æ‰“å¼€ç›®å½•é¡¹ path_put(&amp;path); // é‡Šæ”¾è·¯å¾„ &#125; if (IS_ERR(file)) &#123; put_unused_fd(fd); // é‡Šæ”¾æ–‡ä»¶æè¿°ç¬¦ return PTR_ERR(file); // è¿”å›é”™è¯¯ç  &#125; fd_install(fd, file); // å®‰è£…æ–‡ä»¶æè¿°ç¬¦ return fd; // è¿”å›æ–‡ä»¶æè¿°ç¬¦&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * ä¸å…è®¸æ¸…é™¤å·²é”å®šçš„æŒ‚è½½æ ‡å¿—ã€‚ * * åœ¨æµ‹è¯•å„ç§MNT_LOCKæ ‡å¿—æ—¶ï¼Œæ­¤å¤„ä¸éœ€è¦æŒæœ‰ä»»ä½•é”å®šï¼Œå› ä¸ºä¸€æ—¦è®¾ç½®äº†è¿™äº›æ ‡å¿—ï¼Œå®ƒä»¬å°±ä¸èƒ½è¢«æ¸…é™¤ã€‚ */static bool can_change_locked_flags(struct mount *mnt, unsigned int mnt_flags)&#123; unsigned int fl = mnt-&gt;mnt.mnt_flags; // è·å–æŒ‚è½½æ ‡å¿— if ((fl &amp; MNT_LOCK_READONLY) &amp;&amp; !(mnt_flags &amp; MNT_READONLY)) return false; // å¦‚æœå·²é”å®šåªè¯»æ ‡å¿—ä¸”è¯·æ±‚ä¸æ˜¯åªè¯»ï¼Œåˆ™è¿”å›false if ((fl &amp; MNT_LOCK_NODEV) &amp;&amp; !(mnt_flags &amp; MNT_NODEV)) return false; // å¦‚æœå·²é”å®šæ— è®¾å¤‡æ ‡å¿—ä¸”è¯·æ±‚ä¸æ˜¯æ— è®¾å¤‡ï¼Œåˆ™è¿”å›false if ((fl &amp; MNT_LOCK_NOSUID) &amp;&amp; !(mnt_flags &amp; MNT_NOSUID)) return false; // å¦‚æœå·²é”å®šæ— SUIDæ ‡å¿—ä¸”è¯·æ±‚ä¸æ˜¯æ— SUIDï¼Œåˆ™è¿”å›false if ((fl &amp; MNT_LOCK_NOEXEC) &amp;&amp; !(mnt_flags &amp; MNT_NOEXEC)) return false; // å¦‚æœå·²é”å®šæ— æ‰§è¡Œæ ‡å¿—ä¸”è¯·æ±‚ä¸æ˜¯æ— æ‰§è¡Œï¼Œåˆ™è¿”å›false if ((fl &amp; MNT_LOCK_ATIME) &amp;&amp; ((fl &amp; MNT_ATIME_MASK) != (mnt_flags &amp; MNT_ATIME_MASK))) return false; // å¦‚æœå·²é”å®šè®¿é—®æ—¶é—´æ ‡å¿—ä¸”è¯·æ±‚çš„è®¿é—®æ—¶é—´æ ‡å¿—ä¸å·²æœ‰æ ‡å¿—ä¸åŒ¹é…ï¼Œåˆ™è¿”å›false return true; // å…¶ä»–æƒ…å†µè¿”å›true&#125;static int change_mount_ro_state(struct mount *mnt, unsigned int mnt_flags)&#123; bool readonly_request = (mnt_flags &amp; MNT_READONLY); // æ˜¯å¦è¯·æ±‚åªè¯» if (readonly_request == __mnt_is_readonly(&amp;mnt-&gt;mnt)) return 0; // å¦‚æœè¯·æ±‚åªè¯»çŠ¶æ€ä¸å½“å‰çŠ¶æ€ç›¸åŒï¼Œåˆ™è¿”å›0 if (readonly_request) return mnt_make_readonly(mnt); // è®¾ç½®ä¸ºåªè¯» mnt-&gt;mnt.mnt_flags &amp;= ~MNT_READONLY; // æ¸…é™¤åªè¯»æ ‡å¿— return 0;&#125;static void set_mount_attributes(struct mount *mnt, unsigned int mnt_flags)&#123; mnt_flags |= mnt-&gt;mnt.mnt_flags &amp; ~MNT_USER_SETTABLE_MASK; // è®¾ç½®æŒ‚è½½æ ‡å¿— mnt-&gt;mnt.mnt_flags = mnt_flags; // æ›´æ–°æŒ‚è½½æ ‡å¿— touch_mnt_namespace(mnt-&gt;mnt_ns); // æ›´æ–°æŒ‚è½½å‘½åç©ºé—´&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static void mnt_warn_timestamp_expiry(struct path *mountpoint, struct vfsmount *mnt)&#123; struct super_block *sb = mnt-&gt;mnt_sb; // è·å–è¶…çº§å— if (!__mnt_is_readonly(mnt) &amp;&amp; // å¦‚æœæŒ‚è½½ç‚¹ä¸æ˜¯åªè¯» (!(sb-&gt;s_iflags &amp; SB_I_TS_EXPIRY_WARNED)) &amp;&amp; // å¦‚æœè¶…çº§å—çš„æ—¶é—´æˆ³è¿‡æœŸè­¦å‘Šæ ‡å¿—æœªè®¾ç½® (ktime_get_real_seconds() + TIME_UPTIME_SEC_MAX &gt; sb-&gt;s_time_max)) &#123; // å¦‚æœå½“å‰æ—¶é—´åŠ ä¸Šæœ€å¤§è¿è¡Œæ—¶é—´å°äºè¶…çº§å—çš„æœ€å¤§æ—¶é—´æˆ³ char *buf = (char *)__get_free_page(GFP_KERNEL); // åˆ†é…å†…å­˜é¡µ char *mntpath = buf ? d_path(mountpoint, buf, PAGE_SIZE) : ERR_PTR(-ENOMEM); // è·å–æŒ‚è½½è·¯å¾„ struct tm tm; time64_to_tm(sb-&gt;s_time_max, 0, &amp;tm); // å°†æ—¶é—´æˆ³è½¬æ¢ä¸ºtmç»“æ„ä½“ pr_warn(&quot;%s filesystem being %s at %s supports timestamps until %04ld (0x%llx)\\n&quot;, sb-&gt;s_type-&gt;name, is_mounted(mnt) ? &quot;remounted&quot; : &quot;mounted&quot;, mntpath, tm.tm_year+1900, (unsigned long long)sb-&gt;s_time_max); // æ‰“å°è­¦å‘Šä¿¡æ¯ free_page((unsigned long)buf); // é‡Šæ”¾å†…å­˜é¡µ sb-&gt;s_iflags |= SB_I_TS_EXPIRY_WARNED; // è®¾ç½®è¶…çº§å—çš„æ—¶é—´æˆ³è¿‡æœŸè­¦å‘Šæ ‡å¿— &#125;&#125;/* * ä»…å¤„ç†æŒ‚è½½ç‚¹çš„é‡æ–°é…ç½®ï¼Œè€Œä¸ä¿®æ”¹å®ƒæ‰€å¼•ç”¨çš„è¶…çº§å—ã€‚è¿™æ˜¯é€šè¿‡åœ¨mount(2)ä¸­æŒ‡å®šMS_REMOUNT|MS_BINDæ¥è§¦å‘çš„ã€‚ */static int do_reconfigure_mnt(struct path *path, unsigned int mnt_flags)&#123; struct super_block *sb = path-&gt;mnt-&gt;mnt_sb; // è·å–è¶…çº§å— struct mount *mnt = real_mount(path-&gt;mnt); // è·å–æŒ‚è½½ç»“æ„ä½“ int ret; if (!check_mnt(mnt)) return -EINVAL; // æ£€æŸ¥æŒ‚è½½ç»“æ„ä½“æ˜¯å¦æœ‰æ•ˆ if (path-&gt;dentry != mnt-&gt;mnt.mnt_root) return -EINVAL; // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ä¸ºæ ¹ç›®å½• if (!can_change_locked_flags(mnt, mnt_flags)) return -EPERM; // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ›´æ”¹å·²é”å®šçš„æŒ‚è½½æ ‡å¿— /* * æˆ‘ä»¬åªæ£€æŸ¥è¶…çº§å—æ˜¯å¦ä¸ºåªè¯»ï¼Œè€Œä¸ä¿®æ”¹å®ƒï¼Œå› æ­¤åªä½¿ç”¨down_read(&amp;sb-&gt;s_umount)ã€‚ */ down_read(&amp;sb-&gt;s_umount); // è¯»å–é”å®šè¶…çº§å— lock_mount_hash(); // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ ret = change_mount_ro_state(mnt, mnt_flags); // æ›´æ”¹æŒ‚è½½çš„åªè¯»çŠ¶æ€ if (ret == 0) set_mount_attributes(mnt, mnt_flags); // è®¾ç½®æŒ‚è½½å±æ€§ unlock_mount_hash(); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ up_read(&amp;sb-&gt;s_umount); // è§£é”è¶…çº§å— mnt_warn_timestamp_expiry(path, &amp;mnt-&gt;mnt); // æ£€æŸ¥æ—¶é—´æˆ³è¿‡æœŸè­¦å‘Š return ret; // è¿”å›ç»“æœ&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * æ›´æ”¹æ–‡ä»¶ç³»ç»Ÿæ ‡å¿—ã€‚diråº”è¯¥æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„ç‰©ç†æ ¹ç›®å½•ã€‚ * å¦‚æœä½ åœ¨æŸä¸ªåœ°æ–¹æŒ‚è½½äº†ä¸€ä¸ªéæ ¹ç›®å½•ï¼Œå¹¶ä¸”æƒ³å¯¹å…¶è¿›è¡Œé‡æ–°æŒ‚è½½ - å¾ˆé—æ†¾ã€‚ */static int do_remount(struct path *path, int ms_flags, int sb_flags, int mnt_flags, void *data)&#123; int err; struct super_block *sb = path-&gt;mnt-&gt;mnt_sb; // è·å–è¶…çº§å— struct mount *mnt = real_mount(path-&gt;mnt); // è·å–æŒ‚è½½ç‚¹ struct fs_context *fc; if (!check_mnt(mnt)) // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦æœ‰æ•ˆ return -EINVAL; if (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root) // æ£€æŸ¥è·¯å¾„æ˜¯å¦ä¸ºæ ¹ç›®å½• return -EINVAL; if (!can_change_locked_flags(mnt, mnt_flags)) // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ›´æ”¹é”å®šçš„æ ‡å¿— return -EPERM; fc = fs_context_for_reconfigure(path-&gt;dentry, sb_flags, MS_RMT_MASK); // ä¸ºé‡æ–°é…ç½®è·å–æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ if (IS_ERR(fc)) return PTR_ERR(fc); fc-&gt;oldapi = true; err = parse_monolithic_mount_data(fc, data); // è§£ææŒ‚è½½æ•°æ® if (!err) &#123; down_write(&amp;sb-&gt;s_umount); // è·å–è¶…çº§å—çš„å†™é” err = -EPERM; if (ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) &#123; // æ£€æŸ¥æ˜¯å¦å…·æœ‰ç®¡ç†å‘˜æƒé™ err = reconfigure_super(fc); // é‡æ–°é…ç½®è¶…çº§å— if (!err) &#123; lock_mount_hash(); // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ set_mount_attributes(mnt, mnt_flags); // è®¾ç½®æŒ‚è½½ç‚¹çš„å±æ€§ unlock_mount_hash(); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ &#125; &#125; up_write(&amp;sb-&gt;s_umount); // é‡Šæ”¾è¶…çº§å—çš„å†™é” &#125; mnt_warn_timestamp_expiry(path, &amp;mnt-&gt;mnt); // è­¦å‘ŠæŒ‚è½½ç‚¹çš„æ—¶é—´æˆ³è¿‡æœŸ put_fs_context(fc); // é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ return err;&#125;static inline int tree_contains_unbindable(struct mount *mnt)&#123; struct mount *p; for (p = mnt; p; p = next_mnt(p, mnt)) &#123; // éå†æŒ‚è½½ç‚¹åŠå…¶å­æŒ‚è½½ç‚¹ if (IS_MNT_UNBINDABLE(p)) // æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦ä¸å¯è§£ç»‘ return 1; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * æ£€æŸ¥æŒ‡å®šå­æ ‘ä¸­æ˜¯å¦å­˜åœ¨å¯¹å…ˆå‰/ç›¸åŒæŒ‚è½½å‘½åç©ºé—´çš„å¼•ç”¨ã€‚ * è¿™æ ·çš„å¼•ç”¨å¯ä»¥ä½œä¸ºæŒ‚è½½å‘½åç©ºé—´çš„é”šç‚¹ï¼Œè€Œä¸ä¼šè¢«æŒ‚è½½å¾ªç¯æ£€æŸ¥ä»£ç æ£€æŸ¥åˆ°ï¼Œä»è€Œå…è®¸å½¢æˆå¾ªç¯ã€‚ */static bool check_for_nsfs_mounts(struct mount *subtree)&#123; struct mount *p; bool ret = false; lock_mount_hash(); // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ for (p = subtree; p; p = next_mnt(p, subtree)) // éå†å­æ ‘ä¸­çš„æŒ‚è½½ç‚¹ if (mnt_ns_loop(p-&gt;mnt.mnt_root)) // æ£€æŸ¥æ˜¯å¦å­˜åœ¨æŒ‚è½½å‘½åç©ºé—´å¾ªç¯å¼•ç”¨ goto out; ret = true;out: unlock_mount_hash(); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ return ret;&#125;static int do_set_group(struct path *from_path, struct path *to_path)&#123; struct mount *from, *to; int err; from = real_mount(from_path-&gt;mnt); // è·å–æºæŒ‚è½½ç‚¹ to = real_mount(to_path-&gt;mnt); // è·å–ç›®æ ‡æŒ‚è½½ç‚¹ namespace_lock(); // é”å®šå‘½åç©ºé—´ err = -EINVAL; /* æºå’Œç›®æ ‡éƒ½å¿…é¡»å·²æŒ‚è½½ */ if (!is_mounted(&amp;from-&gt;mnt)) goto out; if (!is_mounted(&amp;to-&gt;mnt)) goto out; err = -EPERM; /* æˆ‘ä»¬åº”è¯¥è¢«å…è®¸ä¿®æ”¹æºå’Œç›®æ ‡æŒ‚è½½ç‚¹çš„æŒ‚è½½å‘½åç©ºé—´ */ if (!ns_capable(from-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN)) goto out; if (!ns_capable(to-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN)) goto out; err = -EINVAL; /* æºå’Œç›®æ ‡è·¯å¾„åº”è¯¥æ˜¯æŒ‚è½½çš„æ ¹ç›®å½• */ if (from_path-&gt;dentry != from_path-&gt;mnt-&gt;mnt_root) goto out; if (to_path-&gt;dentry != to_path-&gt;mnt-&gt;mnt_root) goto out; /* è®¾ç½®å…±äº«ç»„åªå…è®¸åœ¨ç›¸åŒçš„è¶…çº§å—ä¸Šè¿›è¡Œ */ if (from-&gt;mnt.mnt_sb != to-&gt;mnt.mnt_sb) goto out; /* æºæŒ‚è½½ç‚¹çš„æ ¹ç›®å½•åº”è¯¥æ¯”ç›®æ ‡æŒ‚è½½ç‚¹çš„æ ¹ç›®å½•æ›´å®½ */ if (!is_subdir(to-&gt;mnt.mnt_root, from-&gt;mnt.mnt_root)) goto out; /* æºæŒ‚è½½ç‚¹çš„å­æŒ‚è½½ç‚¹ä¸åº”è¯¥é”å®šç›®æ ‡æŒ‚è½½ç‚¹çš„æ ¹ç›®å½• */ if (has_locked_children(from, to-&gt;mnt.mnt_root)) goto out; /* è®¾ç½®å…±äº«ç»„åªå…è®¸åœ¨ç§æœ‰æŒ‚è½½ç‚¹ä¸Šè¿›è¡Œ */ if (IS_MNT_SHARED(to) || IS_MNT_SLAVE(to)) goto out; /* æºæŒ‚è½½ç‚¹ä¸åº”è¯¥æ˜¯ç§æœ‰çš„ */ if (!IS_MNT_SHARED(from) &amp;&amp; !IS_MNT_SLAVE(from)) goto out; if (IS_MNT_SLAVE(from)) &#123; struct mount *m = from-&gt;mnt_master; list_add(&amp;to-&gt;mnt_slave, &amp;m-&gt;mnt_slave_list); to-&gt;mnt_master = m; &#125; if (IS_MNT_SHARED(from)) &#123; to-&gt;mnt_group_id = from-&gt;mnt_group_id; list_add(&amp;to-&gt;mnt_share, &amp;from-&gt;mnt_share); lock_mount_hash(); // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ set_mnt_shared(to); // è®¾ç½®æŒ‚è½½ç‚¹ä¸ºå…±äº« unlock_mount_hash(); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ &#125; err = 0;out: namespace_unlock(); // è§£é”å‘½åç©ºé—´ return err;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static int do_move_mount(struct path *old_path, struct path *new_path)&#123; struct mnt_namespace *ns; // å‘½åç©ºé—´ struct mount *p; // æ–°æŒ‚è½½ç‚¹ struct mount *old; // æ—§æŒ‚è½½ç‚¹ struct mount *parent; // æ—§æŒ‚è½½ç‚¹çš„çˆ¶æŒ‚è½½ç‚¹ struct mountpoint *mp, *old_mp; // æŒ‚è½½ç‚¹å’Œæ—§æŒ‚è½½ç‚¹çš„æŒ‚è½½ç‚¹ int err; // é”™è¯¯ç  bool attached; // æ˜¯å¦å·²æŒ‚è½½ mp = lock_mount(new_path); // é”å®šæ–°æŒ‚è½½ç‚¹ if (IS_ERR(mp)) return PTR_ERR(mp); old = real_mount(old_path-&gt;mnt); // è·å–çœŸå®çš„æ—§æŒ‚è½½ç‚¹ p = real_mount(new_path-&gt;mnt); // è·å–çœŸå®çš„æ–°æŒ‚è½½ç‚¹ parent = old-&gt;mnt_parent; // è·å–æ—§æŒ‚è½½ç‚¹çš„çˆ¶æŒ‚è½½ç‚¹ attached = mnt_has_parent(old); // æ£€æŸ¥æ—§æŒ‚è½½ç‚¹æ˜¯å¦å·²æŒ‚è½½ old_mp = old-&gt;mnt_mp; // è·å–æ—§æŒ‚è½½ç‚¹çš„æŒ‚è½½ç‚¹ ns = old-&gt;mnt_ns; // è·å–æ—§æŒ‚è½½ç‚¹çš„å‘½åç©ºé—´ err = -EINVAL; /* æŒ‚è½½ç‚¹å¿…é¡»åœ¨æˆ‘ä»¬çš„å‘½åç©ºé—´ä¸­ */ if (!check_mnt(p)) goto out; /* è¢«ç§»åŠ¨çš„å¯¹è±¡å¿…é¡»å·²æŒ‚è½½... */ if (!is_mounted(&amp;old-&gt;mnt)) goto out; /* ... å¹¶ä¸”è¦ä¹ˆæ˜¯æˆ‘ä»¬çš„æŒ‚è½½ç‚¹ï¼Œè¦ä¹ˆæ˜¯åŒ¿åå‘½åç©ºé—´çš„æ ¹æŒ‚è½½ç‚¹ */ if (!(attached ? check_mnt(old) : is_anon_ns(ns))) goto out; if (old-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out; if (old_path-&gt;dentry != old_path-&gt;mnt-&gt;mnt_root) goto out; if (d_is_dir(new_path-&gt;dentry) != d_is_dir(old_path-&gt;dentry)) goto out; /* * ä¸è¦ç§»åŠ¨ä½äºå…±äº«çˆ¶æŒ‚è½½ç‚¹ä¸­çš„æŒ‚è½½ç‚¹ã€‚ */ if (attached &amp;&amp; IS_MNT_SHARED(parent)) goto out; /* * ä¸è¦å°†åŒ…å«ä¸å¯è§£ç»‘æŒ‚è½½ç‚¹çš„æŒ‚è½½æ ‘ç§»åŠ¨åˆ°å…±äº«çš„ç›®æ ‡æŒ‚è½½ç‚¹ã€‚ */ if (IS_MNT_SHARED(p) &amp;&amp; tree_contains_unbindable(old)) goto out; err = -ELOOP; if (!check_for_nsfs_mounts(old)) goto out; for (; mnt_has_parent(p); p = p-&gt;mnt_parent) if (p == old) goto out; err = attach_recursive_mnt(old, real_mount(new_path-&gt;mnt), mp, attached); if (err) goto out; /* å¦‚æœæŒ‚è½½ç‚¹è¢«ç§»åŠ¨ï¼Œå®ƒä¸åº”å†è‡ªåŠ¨è¿‡æœŸ */ list_del_init(&amp;old-&gt;mnt_expire); if (attached) put_mountpoint(old_mp);out: unlock_mount(mp); if (!err) &#123; if (attached) mntput_no_expire(parent); else free_mnt_ns(ns); &#125; return err;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int do_move_mount_old(struct path *path, const char *old_name)&#123; struct path old_path; // æ—§è·¯å¾„ int err; // é”™è¯¯ç  if (!old_name || !*old_name) return -EINVAL; err = kern_path(old_name, LOOKUP_FOLLOW, &amp;old_path); // è·å–æ—§è·¯å¾„ if (err) return err; err = do_move_mount(&amp;old_path, path); // ç§»åŠ¨æŒ‚è½½ç‚¹ path_put(&amp;old_path); // é‡Šæ”¾æ—§è·¯å¾„ return err;&#125;/* * å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°å‘½åç©ºé—´çš„æŒ‚è½½æ ‘ä¸­ */static int do_add_mount(struct mount *newmnt, struct mountpoint *mp, const struct path *path, int mnt_flags)&#123; struct mount *parent = real_mount(path-&gt;mnt); // è·å–çˆ¶æŒ‚è½½ç‚¹ mnt_flags &amp;= ~MNT_INTERNAL_FLAGS; if (unlikely(!check_mnt(parent))) &#123; /* åªæœ‰åœ¨ç§æœ‰å‘½åç©ºé—´ä¸­è¿›è¡Œçš„è‡ªåŠ¨æŒ‚è½½æ‰æ˜¯å¯æ¥å—çš„ */ if (!(mnt_flags &amp; MNT_SHRINKABLE)) return -EINVAL; /* ... å¹¶ä¸”å¯¹äºè¿™äº›æƒ…å†µï¼Œæœ€å¥½æŒ‚è½½ç‚¹ä»ç„¶å­˜åœ¨ */ if (!parent-&gt;mnt_ns) return -EINVAL; &#125; /* æ‹’ç»åœ¨ç›¸åŒæŒ‚è½½ç‚¹ä¸ŠæŒ‚è½½ç›¸åŒçš„æ–‡ä»¶ç³»ç»Ÿ */ if (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp; path-&gt;mnt-&gt;mnt_root == path-&gt;dentry) return -EBUSY; if (d_is_symlink(newmnt-&gt;mnt.mnt_root)) return -EINVAL; newmnt-&gt;mnt.mnt_flags = mnt_flags; return graft_tree(newmnt, parent, mp); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°æŒ‚è½½æ ‘ä¸­&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041static bool mount_too_revealing(const struct super_block *sb, int *new_mnt_flags);/* * ä½¿ç”¨è¶…çº§å—é…ç½®åˆ›å»ºä¸€ä¸ªæ–°çš„æŒ‚è½½ç‚¹ï¼Œå¹¶è¯·æ±‚å°†å…¶æ·»åŠ åˆ°å‘½åç©ºé—´æ ‘ä¸­ã€‚ */static int do_new_mount_fc(struct fs_context *fc, struct path *mountpoint, unsigned int mnt_flags)&#123; struct vfsmount *mnt; // è™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹ struct mountpoint *mp; // æŒ‚è½½ç‚¹ struct super_block *sb = fc-&gt;root-&gt;d_sb; // è¶…çº§å— int error; // é”™è¯¯ç  error = security_sb_kern_mount(sb); // å®‰å…¨æ£€æŸ¥ if (!error &amp;&amp; mount_too_revealing(sb, &amp;mnt_flags)) // æ£€æŸ¥æ˜¯å¦è¿‡äºæš´éœ² error = -EPERM; if (unlikely(error)) &#123; fc_drop_locked(fc); return error; &#125; up_write(&amp;sb-&gt;s_umount); // è§£é”è¶…çº§å—çš„å¸è½½ä¿¡å·é‡ mnt = vfs_create_mount(fc); // åˆ›å»ºæŒ‚è½½ç‚¹ if (IS_ERR(mnt)) return PTR_ERR(mnt); mnt_warn_timestamp_expiry(mountpoint, mnt); // æ£€æŸ¥æŒ‚è½½ç‚¹çš„è¿‡æœŸæ—¶é—´ mp = lock_mount(mountpoint); // é”å®šæŒ‚è½½ç‚¹ if (IS_ERR(mp)) &#123; mntput(mnt); return PTR_ERR(mp); &#125; error = do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°æŒ‚è½½æ ‘ä¸­ unlock_mount(mp); // è§£é”æŒ‚è½½ç‚¹ if (error &lt; 0) mntput(mnt); return error;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * ä¸ºç”¨æˆ·ç©ºé—´åˆ›å»ºä¸€ä¸ªæ–°çš„æŒ‚è½½ç‚¹ï¼Œå¹¶è¯·æ±‚å°†å…¶æ·»åŠ åˆ°å‘½åç©ºé—´çš„æ ‘ä¸­ */static int do_new_mount(struct path *path, const char *fstype, int sb_flags, int mnt_flags, const char *name, void *data)&#123; struct file_system_type *type; // æ–‡ä»¶ç³»ç»Ÿç±»å‹ struct fs_context *fc; // æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ const char *subtype = NULL; // å­ç±»å‹ int err = 0; // é”™è¯¯ç  if (!fstype) return -EINVAL; type = get_fs_type(fstype); // è·å–æ–‡ä»¶ç³»ç»Ÿç±»å‹ if (!type) return -ENODEV; if (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &#123; subtype = strchr(fstype, &#x27;.&#x27;); if (subtype) &#123; subtype++; if (!*subtype) &#123; put_filesystem(type); return -EINVAL; &#125; &#125; &#125; fc = fs_context_for_mount(type, sb_flags); // åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ put_filesystem(type); if (IS_ERR(fc)) return PTR_ERR(fc); if (subtype) err = vfs_parse_fs_string(fc, &quot;subtype&quot;, subtype, strlen(subtype)); if (!err &amp;&amp; name) err = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); if (!err) err = parse_monolithic_mount_data(fc, data); if (!err &amp;&amp; !mount_capable(fc)) err = -EPERM; if (!err) err = vfs_get_tree(fc); if (!err) err = do_new_mount_fc(fc, path, mnt_flags); // åˆ›å»ºæ–°çš„æŒ‚è½½ç‚¹ put_fs_context(fc); return err;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int finish_automount(struct vfsmount *m, const struct path *path)&#123; struct dentry *dentry = path-&gt;dentry; // è·å–è·¯å¾„çš„ç›®å½•é¡¹ struct mountpoint *mp; // æŒ‚è½½ç‚¹ç»“æ„ä½“æŒ‡é’ˆ struct mount *mnt; // æŒ‚è½½ç»“æ„ä½“æŒ‡é’ˆ int err; // é”™è¯¯ç  if (!m) // å¦‚æœæŒ‚è½½ç»“æ„ä½“ä¸ºç©º return 0; // è¿”å›0 if (IS_ERR(m)) // å¦‚æœæŒ‚è½½ç»“æ„ä½“æ˜¯é”™è¯¯æŒ‡é’ˆ return PTR_ERR(m); // è¿”å›é”™è¯¯ç  mnt = real_mount(m); // è·å–çœŸå®çš„æŒ‚è½½ç»“æ„ä½“ /* æ–°çš„æŒ‚è½½è®°å½•åº”è¯¥è‡³å°‘æœ‰2ä¸ªå¼•ç”¨ï¼Œä»¥é˜²æ­¢åœ¨æˆ‘ä»¬æ·»åŠ ä¹‹å‰è¿‡æœŸ */ BUG_ON(mnt_get_count(mnt) &lt; 2); // å¦‚æœæŒ‚è½½ç»“æ„ä½“çš„å¼•ç”¨è®¡æ•°å°äº2ï¼Œè§¦å‘BUG if (m-&gt;mnt_sb == path-&gt;mnt-&gt;mnt_sb &amp;&amp; // å¦‚æœæŒ‚è½½çš„è¶…çº§å—å’Œè·¯å¾„çš„è¶…çº§å—ç›¸åŒ m-&gt;mnt_root == dentry) &#123; // å¹¶ä¸”æŒ‚è½½çš„æ ¹ç›®å½•å’Œè·¯å¾„çš„ç›®å½•é¡¹ç›¸åŒ err = -ELOOP; // è®¾ç½®é”™è¯¯ç ä¸º-ELOOPï¼ˆå¾ªç¯é“¾æ¥ï¼‰ goto discard; // è·³è½¬åˆ°discardæ ‡ç­¾å¤„ &#125; /* * æˆ‘ä»¬ä¸æƒ³ä½¿ç”¨lock_mount() - åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰¾åˆ°è¦†ç›–æˆ‘ä»¬æŒ‚è½½ç‚¹çš„ä¸œè¥¿æ„å‘³ç€â€œé™é»˜åœ°ä¸¢å¼ƒæˆ‘ä»¬å·²ç»æœ‰çš„â€ï¼Œè€Œä¸æ˜¯â€œå°è¯•åœ¨å…¶ä¸ŠæŒ‚è½½â€ã€‚ */ inode_lock(dentry-&gt;d_inode); // é”å®šç›®å½•é¡¹çš„ç´¢å¼•èŠ‚ç‚¹ namespace_lock(); // é”å®šå‘½åç©ºé—´ if (unlikely(cant_mount(dentry))) &#123; // å¦‚æœæ— æ³•æŒ‚è½½ç›®å½•é¡¹ err = -ENOENT; // è®¾ç½®é”™è¯¯ç ä¸º-ENOENTï¼ˆæ‰¾ä¸åˆ°æ–‡ä»¶æˆ–ç›®å½•ï¼‰ goto discard_locked; // è·³è½¬åˆ°discard_lockedæ ‡ç­¾å¤„ &#125; rcu_read_lock(); // è¯»å–RCUé” if (unlikely(__lookup_mnt(path-&gt;mnt, dentry))) &#123; // å¦‚æœåœ¨è·¯å¾„çš„æŒ‚è½½ç‚¹ä¸­æŸ¥æ‰¾åˆ°ç›®å½•é¡¹ rcu_read_unlock(); // è§£é”RCUé” err = 0; // è®¾ç½®é”™è¯¯ç ä¸º0 goto discard_locked; // è·³è½¬åˆ°discard_lockedæ ‡ç­¾å¤„ &#125; rcu_read_unlock(); // è§£é”RCUé” mp = get_mountpoint(dentry); // è·å–ç›®å½•é¡¹çš„æŒ‚è½½ç‚¹ if (IS_ERR(mp)) &#123; // å¦‚æœæŒ‚è½½ç‚¹æ˜¯é”™è¯¯æŒ‡é’ˆ err = PTR_ERR(mp); // è·å–é”™è¯¯ç  goto discard_locked; // è·³è½¬åˆ°discard_lockedæ ‡ç­¾å¤„ &#125; err = do_add_mount(mnt, mp, path, path-&gt;mnt-&gt;mnt_flags | MNT_SHRINKABLE); // æ·»åŠ æŒ‚è½½ unlock_mount(mp); // è§£é”æŒ‚è½½ç‚¹ if (unlikely(err)) // å¦‚æœå‘ç”Ÿé”™è¯¯ goto discard; // è·³è½¬åˆ°discardæ ‡ç­¾å¤„ mntput(m); // é‡Šæ”¾æŒ‚è½½ç»“æ„ä½“å¼•ç”¨è®¡æ•° return 0; // è¿”å›0discard_locked: namespace_unlock(); // è§£é”å‘½åç©ºé—´ inode_unlock(dentry-&gt;d_inode); // è§£é”ç›®å½•é¡¹çš„ç´¢å¼•èŠ‚ç‚¹discard: /* ä»ä»»ä½•å¯èƒ½çš„è¿‡æœŸåˆ—è¡¨ä¸­åˆ é™¤m */ if (!list_empty(&amp;mnt-&gt;mnt_expire)) &#123; // å¦‚æœæŒ‚è½½ç»“æ„ä½“çš„è¿‡æœŸåˆ—è¡¨ä¸ä¸ºç©º namespace_lock(); // é”å®šå‘½åç©ºé—´ list_del_init(&amp;mnt-&gt;mnt_expire); // ä»è¿‡æœŸåˆ—è¡¨ä¸­åˆ é™¤æŒ‚è½½ç»“æ„ä½“ namespace_unlock(); // è§£é”å‘½åç©ºé—´ &#125; mntput(m); // é‡Šæ”¾æŒ‚è½½ç»“æ„ä½“å¼•ç”¨è®¡æ•° mntput(m); // é‡Šæ”¾æŒ‚è½½ç»“æ„ä½“å¼•ç”¨è®¡æ•° return err; // è¿”å›é”™è¯¯ç &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * mnt_set_expiry - å°†æŒ‚è½½ç‚¹æ”¾å…¥è¿‡æœŸåˆ—è¡¨ * @mnt: è¦æ”¾å…¥åˆ—è¡¨çš„æŒ‚è½½ç‚¹ * @expiry_list: è¦æ·»åŠ æŒ‚è½½ç‚¹çš„åˆ—è¡¨ */void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)&#123; namespace_lock(); // é”å®šå‘½åç©ºé—´ list_add_tail(&amp;real_mount(mnt)-&gt;mnt_expire, expiry_list); // å°†æŒ‚è½½ç‚¹æ·»åŠ åˆ°è¿‡æœŸåˆ—è¡¨çš„å°¾éƒ¨ namespace_unlock(); // è§£é”å‘½åç©ºé—´&#125;EXPORT_SYMBOL(mnt_set_expiry); // å¯¼å‡ºmnt_set_expiryç¬¦å·/* * å¤„ç†ä¸€ä¸ªå¯è¿‡æœŸçš„æŒ‚è½½ç‚¹åˆ—è¡¨ï¼Œç›®çš„æ˜¯ä¸¢å¼ƒä»»ä½•æœªä½¿ç”¨ä¸”è‡ªä¸Šæ¬¡è®¿é—®ä»¥æ¥æœªè¢«è§¦ç¢°çš„æŒ‚è½½ç‚¹ */void mark_mounts_for_expiry(struct list_head *mounts)&#123; struct mount *mnt, *next; LIST_HEAD(graveyard); // åˆ›å»ºä¸€ä¸ªä¸´æ—¶åˆ—è¡¨ç”¨äºå­˜æ”¾è¦ä¸¢å¼ƒçš„æŒ‚è½½ç‚¹ if (list_empty(mounts)) // å¦‚æœæŒ‚è½½ç‚¹åˆ—è¡¨ä¸ºç©º return; namespace_lock(); // é”å®šå‘½åç©ºé—´ lock_mount_hash(); // é”å®šæŒ‚è½½å“ˆå¸Œè¡¨ /* ä»è¿‡æœŸåˆ—è¡¨ä¸­æå–æ¯ä¸ªæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„vfsmountï¼š * - åªè¢«å…¶çˆ¶vfsmountå¼•ç”¨ * - ä»ç„¶æ ‡è®°ä¸ºè¿‡æœŸï¼ˆåœ¨ä¸Šæ¬¡è°ƒç”¨æ­¤å‡½æ•°æ—¶æ ‡è®°çš„ï¼›æ ‡è®°ä¼šåœ¨mntput()ä¸­æ¸…é™¤ï¼‰ */ list_for_each_entry_safe(mnt, next, mounts, mnt_expire) &#123; if (!xchg(&amp;mnt-&gt;mnt_expiry_mark, 1) || // å¦‚æœæŒ‚è½½ç‚¹çš„è¿‡æœŸæ ‡è®°å·²ç»è¢«æ¸…é™¤æˆ–è€… propagate_mount_busy(mnt, 1)) // æŒ‚è½½ç‚¹æ­£åœ¨è¢«ä½¿ç”¨ continue; list_move(&amp;mnt-&gt;mnt_expire, &amp;graveyard); // å°†æŒ‚è½½ç‚¹ä»è¿‡æœŸåˆ—è¡¨ä¸­ç§»åŠ¨åˆ°ä¸´æ—¶åˆ—è¡¨ä¸­ &#125; while (!list_empty(&amp;graveyard)) &#123; // å½“ä¸´æ—¶åˆ—è¡¨ä¸ä¸ºç©ºæ—¶ mnt = list_first_entry(&amp;graveyard, struct mount, mnt_expire); // è·å–ä¸´æ—¶åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªæŒ‚è½½ç‚¹ touch_mnt_namespace(mnt-&gt;mnt_ns); // æ›´æ–°æŒ‚è½½ç‚¹æ‰€å±çš„å‘½åç©ºé—´ umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC); // å¸è½½æŒ‚è½½ç‚¹åŠå…¶å­æŒ‚è½½ç‚¹ &#125; unlock_mount_hash(); // è§£é”æŒ‚è½½å“ˆå¸Œè¡¨ namespace_unlock(); // è§£é”å‘½åç©ºé—´&#125;EXPORT_SYMBOL_GPL(mark_mounts_for_expiry); // å¯¼å‡ºmark_mounts_for_expiryç¬¦å· 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * select_submounts()çš„å‰½çªƒç‰ˆæœ¬ * * åœ¨å­æŒ‚è½½ç‚¹åˆ—è¡¨ä¸­æœç´¢ç»™å®šçš„æŒ‚è½½ç‚¹ï¼Œå¹¶å°†ä»»ä½•å¯æ”¶ç¼©çš„å­æŒ‚è½½ç‚¹ç§»åŠ¨åˆ°â€œgraveyardâ€åˆ—è¡¨ä¸­ã€‚ */static int select_submounts(struct mount *parent, struct list_head *graveyard)&#123; struct mount *this_parent = parent; // å½“å‰çˆ¶æŒ‚è½½ç‚¹ struct list_head *next; // ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ int found = 0; // æ‰¾åˆ°çš„å­æŒ‚è½½ç‚¹æ•°é‡repeat: next = this_parent-&gt;mnt_mounts.next; // è·å–ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹resume: while (next != &amp;this_parent-&gt;mnt_mounts) &#123; // å½“ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ä¸æ˜¯çˆ¶æŒ‚è½½ç‚¹çš„å­æŒ‚è½½ç‚¹åˆ—è¡¨çš„æœ«å°¾æ—¶ struct list_head *tmp = next; // ä¸´æ—¶æŒ‡é’ˆæŒ‡å‘ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ struct mount *mnt = list_entry(tmp, struct mount, mnt_child); // è·å–æŒ‚è½½ç»“æ„ä½“ next = tmp-&gt;next; // æ›´æ–°ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_SHRINKABLE)) // å¦‚æœæŒ‚è½½ç‚¹ä¸å¯æ”¶ç¼© continue; /* * å¦‚æœd_mountsåˆ—è¡¨éç©ºï¼Œåˆ™ä¸‹é™ä¸€çº§ã€‚ */ if (!list_empty(&amp;mnt-&gt;mnt_mounts)) &#123; this_parent = mnt; // æ›´æ–°å½“å‰çˆ¶æŒ‚è½½ç‚¹ goto repeat; // è·³è½¬åˆ°repeatæ ‡ç­¾å¤„ &#125; if (!propagate_mount_busy(mnt, 1)) &#123; // å¦‚æœæŒ‚è½½ç‚¹æœªè¢«ä½¿ç”¨ list_move_tail(&amp;mnt-&gt;mnt_expire, graveyard); // å°†æŒ‚è½½ç‚¹ç§»åŠ¨åˆ°graveyardåˆ—è¡¨çš„æœ«å°¾ found++; // å¢åŠ æ‰¾åˆ°çš„å­æŒ‚è½½ç‚¹æ•°é‡ &#125; &#125; /* * åœ¨æ­¤çº§åˆ«å®Œæˆ...ä¸Šå‡å¹¶æ¢å¤æœç´¢ */ if (this_parent != parent) &#123; // å¦‚æœå½“å‰çˆ¶æŒ‚è½½ç‚¹ä¸æ˜¯åˆå§‹çˆ¶æŒ‚è½½ç‚¹ next = this_parent-&gt;mnt_child.next; // è·å–ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ this_parent = this_parent-&gt;mnt_parent; // æ›´æ–°å½“å‰çˆ¶æŒ‚è½½ç‚¹ä¸ºä¸Šä¸€çº§çˆ¶æŒ‚è½½ç‚¹ goto resume; // è·³è½¬åˆ°resumeæ ‡ç­¾å¤„ &#125; return found; // è¿”å›æ‰¾åˆ°çš„å­æŒ‚è½½ç‚¹æ•°é‡&#125;/* * å¤„ç†ä¸€ä¸ªå¯è¿‡æœŸçš„æŒ‚è½½ç‚¹åˆ—è¡¨ï¼Œç›®çš„æ˜¯ä¸¢å¼ƒç‰¹å®šçˆ¶æŒ‚è½½ç‚¹çš„ä»»ä½•å­æŒ‚è½½ç‚¹ * * å¿…é¡»æŒæœ‰mount_lockçš„å†™é” */static void shrink_submounts(struct mount *mnt)&#123; LIST_HEAD(graveyard); // åˆ›å»ºä¸€ä¸ªä¸´æ—¶åˆ—è¡¨ç”¨äºå­˜æ”¾è¦ä¸¢å¼ƒçš„å­æŒ‚è½½ç‚¹ struct mount *m; /* ä»è¿‡æœŸåˆ—è¡¨ä¸­æå–&#x27;mountpoint&#x27;çš„å­æŒ‚è½½ç‚¹ */ while (select_submounts(mnt, &amp;graveyard)) &#123; while (!list_empty(&amp;graveyard)) &#123; m = list_first_entry(&amp;graveyard, struct mount, mnt_expire); // è·å–ä¸´æ—¶åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå­æŒ‚è½½ç‚¹ touch_mnt_namespace(m-&gt;mnt_ns); // æ›´æ–°å­æŒ‚è½½ç‚¹æ‰€å±çš„å‘½åç©ºé—´ umount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC); // å¸è½½å­æŒ‚è½½ç‚¹åŠå…¶å­æŒ‚è½½ç‚¹ &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930static void *copy_mount_options(const void __user *data)&#123; char *copy; // ç”¨äºå­˜å‚¨æ‹·è´åçš„æ•°æ®çš„æŒ‡é’ˆ unsigned left, offset; // ç”¨äºè®°å½•å‰©ä½™çš„æ•°æ®é•¿åº¦å’Œåç§»é‡ if (!data) // å¦‚æœè¾“å…¥æ•°æ®ä¸ºç©ºï¼Œåˆ™è¿”å›ç©ºæŒ‡é’ˆ return NULL; copy = kmalloc(PAGE_SIZE, GFP_KERNEL); // åˆ†é…å†…å­˜ç©ºé—´ï¼Œå¤§å°ä¸ºPAGE_SIZEï¼Œä½¿ç”¨GFP_KERNELæ ‡å¿— if (!copy) // å¦‚æœå†…å­˜åˆ†é…å¤±è´¥ï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ return ERR_PTR(-ENOMEM); left = copy_from_user(copy, data, ... offset)) // ä»ç”¨æˆ·ç©ºé—´æ‹·è´æ•°æ®åˆ°å†…æ ¸ç©ºé—´ï¼Œè¿”å›å‰©ä½™çš„æœªæ‹·è´çš„æ•°æ®é•¿åº¦ break; copy[offset] = c; // å°†æ‹·è´çš„æ•°æ®å­˜å‚¨åˆ°æŒ‡å®šåç§»é‡çš„ä½ç½® left--; // å‰©ä½™æ•°æ®é•¿åº¦å‡ä¸€ offset++; // åç§»é‡å¢åŠ ä¸€ if (left == PAGE_SIZE) &#123; // å¦‚æœå‰©ä½™æ•°æ®é•¿åº¦ç­‰äºPAGE_SIZEï¼Œåˆ™è¡¨ç¤ºæ‹·è´å¤±è´¥ï¼Œé‡Šæ”¾å†…å­˜å¹¶è¿”å›é”™è¯¯æŒ‡é’ˆ kfree(copy); return ERR_PTR(-EFAULT); &#125; return copy; // è¿”å›æ‹·è´åçš„æ•°æ®æŒ‡é’ˆ&#125;static char *copy_mount_string(const void __user *data)&#123; return data ? strndup_user(data, PATH_MAX) : NULL; // å¦‚æœè¾“å…¥æ•°æ®ä¸ä¸ºç©ºï¼Œåˆ™ä½¿ç”¨strndup_userå‡½æ•°æ‹·è´æ•°æ®å¹¶è¿”å›æ‹·è´åçš„å­—ç¬¦ä¸²æŒ‡é’ˆï¼Œå¦åˆ™è¿”å›ç©ºæŒ‡é’ˆ&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * Flagsæ˜¯ä¸€ä¸ª32ä½çš„å€¼ï¼Œå…è®¸åœ¨mount()è°ƒç”¨ä¸­ä¼ é€’æœ€å¤š31ä¸ªä¸æ–‡ä»¶ç³»ç»Ÿæ— å…³çš„æ ‡å¿—ï¼ˆä¾‹å¦‚ï¼šåªè¯»ã€æ— è®¾å¤‡ã€æ— SUIDç­‰ï¼‰ã€‚ * * dataæ˜¯ä¸€ä¸ª(void *)ï¼Œå¯ä»¥æŒ‡å‘ä»»ä½•å¤§å°ä¸è¶…è¿‡PAGE_SIZE-1å­—èŠ‚çš„ç»“æ„ï¼Œå…¶ä¸­å¯ä»¥åŒ…å«ä»»æ„ä¸æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„ä¿¡æ¯ï¼ˆæˆ–ä¸ºNULLï¼‰ã€‚ * * åœ¨0.97ç‰ˆæœ¬ä¹‹å‰çš„mount()å‡½æ•°ä¸­æ²¡æœ‰flagså‚æ•°ã€‚ * å½“å¼•å…¥flagså‚æ•°æ—¶ï¼Œè¦æ±‚å…¶é«˜åŠéƒ¨åˆ†å¿…é¡»å…·æœ‰é­”æœ¯å€¼0xC0EDï¼Œç›´åˆ°2.4.0-test9ç‰ˆæœ¬ä¸ºæ­¢ã€‚ * å› æ­¤ï¼Œå¦‚æœå­˜åœ¨è¿™ä¸ªé­”æœ¯æ•°ï¼Œå®ƒä¸æºå¸¦ä»»ä½•ä¿¡æ¯ï¼Œå¿…é¡»è¢«ä¸¢å¼ƒã€‚ */int path_mount(const char *dev_name, struct path *path,const char *type_page, unsigned long flags, void *data_page)&#123; unsigned int mnt_flags = 0, sb_flags; int ret; /* ä¸¢å¼ƒé­”æœ¯æ•° */ if ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL) flags &amp;= ~MS_MGC_MSK; /* åŸºæœ¬çš„åˆæ³•æ€§æ£€æŸ¥ */ if (data_page) ((char *)data_page)[PAGE_SIZE - 1] = 0; if (flags &amp; MS_NOUSER) return -EINVAL; ret = security_sb_mount(dev_name, path, type_page, flags, data_page); if (ret) return ret; if (!may_mount()) return -EPERM; if (flags &amp; SB_MANDLOCK) warn_mandlock(); /* é»˜è®¤ä½¿ç”¨relatimeï¼Œé™¤éè¢«è¦†ç›– */ if (!(flags &amp; MS_NOATIME)) mnt_flags |= MNT_RELATIME; /* åˆ†ç¦»æ¯ä¸ªæŒ‚è½½ç‚¹çš„æ ‡å¿— */ if (flags &amp; MS_NOSUID) mnt_flags |= MNT_NOSUID; if (flags &amp; MS_NODEV) mnt_flags |= MNT_NODEV; if (flags &amp; MS_NOEXEC) mnt_flags |= MNT_NOEXEC; if (flags &amp; MS_NOATIME) mnt_flags |= MNT_NOATIME; if (flags &amp; MS_NODIRATIME) mnt_flags |= MNT_NODIRATIME; if (flags &amp; MS_STRICTATIME) mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME); if (flags &amp; MS_RDONLY) mnt_flags |= MNT_READONLY; if (flags &amp; MS_NOSYMFOLLOW) mnt_flags |= MNT_NOSYMFOLLOW; /* remountçš„é»˜è®¤atimeæ˜¯ä¿ç•™çš„ */ if ((flags &amp; MS_REMOUNT) &amp;&amp; ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME | MS_STRICTATIME)) == 0)) &#123; mnt_flags &amp;= ~MNT_ATIME_MASK; mnt_flags |= path-&gt;mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK; &#125; sb_flags = flags &amp; (SB_RDONLY | SB_SYNCHRONOUS | SB_MANDLOCK | SB_DIRSYNC | SB_SILENT | SB_POSIXACL | SB_LAZYTIME | SB_I_VERSION); if ((flags &amp; (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND)) return do_reconfigure_mnt(path, mnt_flags); if (flags &amp; MS_REMOUNT) return do_remount(path, flags, sb_flags, mnt_flags, data_page); if (flags &amp; MS_BIND) return do_loopback(path, dev_name, flags &amp; MS_REC); if (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) return do_change_type(path, flags); if (flags &amp; MS_MOVE) return do_move_mount_old(path, dev_name); return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name, data_page);&#125;long do_mount(const char *dev_name, const char __user *dir_name, const char *type_page, unsigned long flags, void *data_page)&#123; struct path path; int ret; ret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path); if (ret) return ret; ret = path_mount(dev_name, &amp;path, type_page, flags, data_page); path_put(&amp;path); return ret;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static struct ucounts *inc_mnt_namespaces(struct user_namespace *ns)&#123; // å¢åŠ æŒ‚è½½å‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•° return inc_ucount(ns, current_euid(), UCOUNT_MNT_NAMESPACES);&#125;// å¢åŠ æŒ‚è½½å‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•°static void dec_mnt_namespaces(struct ucounts *ucounts)&#123; dec_ucount(ucounts, UCOUNT_MNT_NAMESPACES);&#125;// é‡Šæ”¾æŒ‚è½½å‘½åç©ºé—´static void free_mnt_ns(struct mnt_namespace *ns)&#123; // å¦‚æœä¸æ˜¯åŒ¿åå‘½åç©ºé—´ï¼Œåˆ™é‡Šæ”¾å‘½åç©ºé—´çš„inode if (!is_anon_ns(ns)) ns_free_inum(&amp;ns-&gt;ns); // å‡å°‘æŒ‚è½½å‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•° dec_mnt_namespaces(ns-&gt;ucounts); // é‡Šæ”¾ç”¨æˆ·å‘½åç©ºé—´ put_user_ns(ns-&gt;user_ns); // é‡Šæ”¾å‘½åç©ºé—´ç»“æ„ä½“å†…å­˜ kfree(ns);&#125;/* * åˆ†é…ä¸€ä¸ªæŒ‚è½½å‘½åç©ºé—´ï¼Œå¹¶åˆ†é…ä¸€ä¸ªåºåˆ—å·ï¼Œç”¨äºæ£€æµ‹æ˜¯å¦å°è¯•å°†æ—§çš„æŒ‚è½½å‘½åç©ºé—´ç»‘å®šåˆ°å½“å‰æŒ‚è½½å‘½åç©ºé—´ï¼Œ * ä»¥é˜²æ­¢å¼•ç”¨è®¡æ•°å¾ªç¯ã€‚ä¸€ä¸ªä»¥10Ghzé€’å¢çš„64ä½æ•°å­—éœ€è¦12427å¹´æ‰èƒ½å¾ªç¯ï¼Œæ‰€ä»¥å¯ä»¥å¿½ç•¥è¿™ç§å¯èƒ½æ€§ã€‚ */static atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);// åˆ†é…ä¸€ä¸ªæŒ‚è½½å‘½åç©ºé—´static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns, bool anon)&#123; struct mnt_namespace *new_ns; struct ucounts *ucounts; int ret; // å¢åŠ æŒ‚è½½å‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•° ucounts = inc_mnt_namespaces(user_ns); if (!ucounts) return ERR_PTR(-ENOSPC); // åˆ†é…æŒ‚è½½å‘½åç©ºé—´ç»“æ„ä½“å†…å­˜ new_ns = kzalloc(sizeof(struct mnt_namespace), GFP_KERNEL_ACCOUNT); if (!new_ns) &#123; // åˆ†é…å¤±è´¥ï¼Œå‡å°‘æŒ‚è½½å‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•° dec_mnt_namespaces(ucounts); return ERR_PTR(-ENOMEM); &#125; if (!anon) &#123; // å¦‚æœä¸æ˜¯åŒ¿åå‘½åç©ºé—´ï¼Œåˆ™åˆ†é…å‘½åç©ºé—´çš„inode ret = ns_alloc_inum(&amp;new_ns-&gt;ns); if (ret) &#123; kfree(new_ns); dec_mnt_namespaces(ucounts); return ERR_PTR(ret); &#125; &#125; new_ns-&gt;ns.ops = &amp;mntns_operations; if (!anon) // åˆ†é…ä¸€ä¸ªåºåˆ—å·ç»™æ–°çš„æŒ‚è½½å‘½åç©ºé—´ new_ns-&gt;seq = atomic64_add_return(1, &amp;mnt_ns_seq); refcount_set(&amp;new_ns-&gt;ns.count, 1); INIT_LIST_HEAD(&amp;new_ns-&gt;list); init_waitqueue_head(&amp;new_ns-&gt;poll); spin_lock_init(&amp;new_ns-&gt;ns_lock); new_ns-&gt;user_ns = get_user_ns(user_ns); new_ns-&gt;ucounts = ucounts; return new_ns;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980__latent_entropystruct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns, struct user_namespace *user_ns, struct fs_struct *new_fs)&#123; struct mnt_namespace *new_ns; // å®šä¹‰ä¸€ä¸ªæ–°çš„mnt_namespaceç»“æ„ä½“æŒ‡é’ˆnew_ns struct vfsmount *rootmnt = NULL, *pwdmnt = NULL; // å®šä¹‰vfsmountç»“æ„ä½“æŒ‡é’ˆrootmntå’Œpwdmntï¼Œå¹¶åˆå§‹åŒ–ä¸ºNULL struct mount *p, *q; // å®šä¹‰mountç»“æ„ä½“æŒ‡é’ˆpå’Œq struct mount *old; // å®šä¹‰mountç»“æ„ä½“æŒ‡é’ˆold struct mount *new; // å®šä¹‰mountç»“æ„ä½“æŒ‡é’ˆnew int copy_flags; // å®šä¹‰æ•´å‹å˜é‡copy_flags BUG_ON(!ns); // æ£€æŸ¥nsæ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºåˆ™è§¦å‘BUG_ONå® if (likely(!(flags &amp; CLONE_NEWNS))) &#123; // å¦‚æœflagsä¸­ä¸åŒ…å«CLONE_NEWNSæ ‡å¿—ä½ get_mnt_ns(ns); // å¢åŠ mnt_namespaceçš„å¼•ç”¨è®¡æ•° return ns; // è¿”å›nsæŒ‡é’ˆ &#125; old = ns-&gt;root; // å°†nsçš„rootæˆå‘˜èµ‹å€¼ç»™old new_ns = alloc_mnt_ns(user_ns, false); // åˆ†é…ä¸€ä¸ªæ–°çš„mnt_namespaceç»“æ„ä½“new_nsï¼Œå¹¶å°†user_nsèµ‹å€¼ç»™å®ƒçš„user_nsæˆå‘˜ if (IS_ERR(new_ns)) // å¦‚æœnew_nsæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆ return new_ns; // è¿”å›new_nsæŒ‡é’ˆ namespace_lock(); // é”å®šå‘½åç©ºé—´ /* ç¬¬ä¸€éå¾ªç¯ï¼šå¤åˆ¶æ ‘çš„æ‹“æ‰‘ç»“æ„ */ copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE; // è®¾ç½®copy_flagsä¸ºCL_COPY_UNBINDABLEå’ŒCL_EXPIREçš„æŒ‰ä½æˆ–ç»“æœ if (user_ns != ns-&gt;user_ns) // å¦‚æœuser_nsä¸ç­‰äºnsçš„user_ns copy_flags |= CL_SHARED_TO_SLAVE; // å°†CL_SHARED_TO_SLAVEæ ‡å¿—ä½åŠ å…¥copy_flags new = copy_tree(old, old-&gt;mnt.mnt_root, copy_flags); // å¤åˆ¶oldçš„æ ‘æ‹“æ‰‘ç»“æ„åˆ°newï¼Œå¹¶æ ¹æ®copy_flagsè¿›è¡Œç›¸åº”çš„å¤„ç† if (IS_ERR(new)) &#123; // å¦‚æœnewæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆ namespace_unlock(); // è§£é”å‘½åç©ºé—´ free_mnt_ns(new_ns); // é‡Šæ”¾new_ns return ERR_CAST(new); // è¿”å›newæŒ‡é’ˆ &#125; if (user_ns != ns-&gt;user_ns) &#123; // å¦‚æœuser_nsä¸ç­‰äºnsçš„user_ns lock_mount_hash(); // é”å®šmountå“ˆå¸Œè¡¨ lock_mnt_tree(new); // é”å®šnewçš„mnt_tree unlock_mount_hash(); // è§£é”mountå“ˆå¸Œè¡¨ &#125; new_ns-&gt;root = new; // å°†newèµ‹å€¼ç»™new_nsçš„rootæˆå‘˜ list_add_tail(&amp;new_ns-&gt;list, &amp;new-&gt;mnt_list); // å°†new_nsæ·»åŠ åˆ°newçš„mnt_listçš„å°¾éƒ¨ /* * ç¬¬äºŒéå¾ªç¯ï¼šåˆ‡æ¢tsk-&gt;fs-&gt;*å…ƒç´ å¹¶æ ‡è®°æ–°çš„vfsmountå±äºæ–°çš„å‘½åç©ºé—´ã€‚ * æˆ‘ä»¬å·²ç»è·å–äº†ä¸€ä¸ªç§æœ‰çš„fs_structï¼Œæ‰€ä»¥ä¸éœ€è¦tsk-&gt;fs-&gt;lockã€‚ */ p = old; // å°†oldèµ‹å€¼ç»™p q = new; // å°†newèµ‹å€¼ç»™q while (p) &#123; // å¾ªç¯ç›´åˆ°pä¸ºç©ºæŒ‡é’ˆ q-&gt;mnt_ns = new_ns; // å°†new_nsèµ‹å€¼ç»™qçš„mnt_nsæˆå‘˜ new_ns-&gt;mounts++; // å¢åŠ new_nsçš„mountsè®¡æ•° if (new_fs) &#123; // å¦‚æœnew_fsä¸ä¸ºç©º if (&amp;p-&gt;mnt == new_fs-&gt;root.mnt) &#123; // å¦‚æœpçš„mntç­‰äºnew_fsçš„root.mnt new_fs-&gt;root.mnt = mntget(&amp;q-&gt;mnt); // å°†qçš„mntå¢åŠ å¼•ç”¨è®¡æ•°å¹¶èµ‹å€¼ç»™new_fsçš„root.mnt rootmnt = &amp;p-&gt;mnt; // å°†pçš„mntèµ‹å€¼ç»™rootmnt &#125; if (&amp;p-&gt;mnt == new_fs-&gt;pwd.mnt) &#123; // å¦‚æœpçš„mntç­‰äºnew_fsçš„pwd.mnt new_fs-&gt;pwd.mnt = mntget(&amp;q-&gt;mnt); // å°†qçš„mntå¢åŠ å¼•ç”¨è®¡æ•°å¹¶èµ‹å€¼ç»™new_fsçš„pwd.mnt pwdmnt = &amp;p-&gt;mnt; // å°†pçš„mntèµ‹å€¼ç»™pwdmnt &#125; &#125; p = next_mnt(p, old); // è·å–oldä¸­pçš„ä¸‹ä¸€ä¸ªmountç»“æ„ä½“æŒ‡é’ˆï¼Œå¹¶èµ‹å€¼ç»™p q = next_mnt(q, new); // è·å–newä¸­qçš„ä¸‹ä¸€ä¸ªmountç»“æ„ä½“æŒ‡é’ˆï¼Œå¹¶èµ‹å€¼ç»™q if (!q) // å¦‚æœqä¸ºç©ºæŒ‡é’ˆ break; // è·³å‡ºå¾ªç¯ // è·³è¿‡æˆ‘ä»¬è·³è¿‡çš„mntnsç»‘å®šï¼Ÿ while (p-&gt;mnt.mnt_root != q-&gt;mnt.mnt_root) // å½“pçš„mnt_rootä¸ç­‰äºqçš„mnt_rootæ—¶ p = next_mnt(skip_mnt_tree(p), old); // è·å–oldä¸­pçš„ä¸‹ä¸€ä¸ªmountç»“æ„ä½“æŒ‡é’ˆï¼Œå¹¶èµ‹å€¼ç»™p &#125; namespace_unlock(); // è§£é”å‘½åç©ºé—´ if (rootmnt) // å¦‚æœrootmntä¸ä¸ºç©ºæŒ‡é’ˆ mntput(rootmnt); // å‡å°‘rootmntçš„å¼•ç”¨è®¡æ•° if (pwdmnt) // å¦‚æœpwdmntä¸ä¸ºç©ºæŒ‡é’ˆ mntput(pwdmnt); // å‡å°‘pwdmntçš„å¼•ç”¨è®¡æ•° return new_ns; // è¿”å›new_nsæŒ‡é’ˆ&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct dentry *mount_subtree(struct vfsmount *m, const char *name)&#123; struct mount *mnt = real_mount(m); // è·å–vfsmountå¯¹åº”çš„mountç»“æ„ä½“æŒ‡é’ˆmnt struct mnt_namespace *ns; // å®šä¹‰mnt_namespaceç»“æ„ä½“æŒ‡é’ˆns struct super_block *s; // å®šä¹‰super_blockç»“æ„ä½“æŒ‡é’ˆs struct path path; // å®šä¹‰pathç»“æ„ä½“path int err; // å®šä¹‰æ•´å‹å˜é‡err ns = alloc_mnt_ns(&amp;init_user_ns, true); // åˆ†é…ä¸€ä¸ªæ–°çš„mnt_namespaceç»“æ„ä½“nsï¼Œå¹¶å°†init_user_nsèµ‹å€¼ç»™å®ƒçš„user_nsæˆå‘˜ if (IS_ERR(ns)) &#123; // å¦‚æœnsæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆ mntput(m); // å‡å°‘mçš„å¼•ç”¨è®¡æ•° return ERR_CAST(ns); // è¿”å›nsæŒ‡é’ˆ &#125; mnt-&gt;mnt_ns = ns; // å°†nsèµ‹å€¼ç»™mntçš„mnt_nsæˆå‘˜ ns-&gt;root = mnt; // å°†mntèµ‹å€¼ç»™nsçš„rootæˆå‘˜ ns-&gt;mounts++; // å¢åŠ nsçš„mountsè®¡æ•° list_add(&amp;mnt-&gt;mnt_list, &amp;ns-&gt;list); // å°†mntæ·»åŠ åˆ°nsçš„listä¸­ err = vfs_path_lookup(m-&gt;mnt_root, m, name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &amp;path); // åœ¨mçš„mnt_rootä¸‹æŸ¥æ‰¾nameå¯¹åº”çš„è·¯å¾„ï¼Œå¹¶å°†ç»“æœä¿å­˜åœ¨pathä¸­ put_mnt_ns(ns); // å‡å°‘nsçš„å¼•ç”¨è®¡æ•° if (err) // å¦‚æœerrä¸ä¸º0 return ERR_PTR(err); // è¿”å›é”™è¯¯æŒ‡é’ˆerr /* äº¤æ¢ä¸€ä¸ªvfsmountå¼•ç”¨ä»¥è·å¾—æ´»åŠ¨çš„super_blockå¼•ç”¨ */ s = path.mnt-&gt;mnt_sb; // è·å–pathå¯¹åº”çš„super_blockç»“æ„ä½“æŒ‡é’ˆs atomic_inc(&amp;s-&gt;s_active); // å¢åŠ sçš„s_activeè®¡æ•° mntput(path.mnt); // å‡å°‘path.mntçš„å¼•ç”¨è®¡æ•° /* é”å®šsuper_block */ down_write(&amp;s-&gt;s_umount); // å†™é”å®šsçš„s_umountä¿¡å·é‡ /* è¿”å›(sub)treeçš„æ ¹èŠ‚ç‚¹ */ return *kernel_dev; // è¿”å›kernel_devæŒ‡é’ˆ void *options; kernel_type = copy_mount_string(type); // å¤åˆ¶typeå­—ç¬¦ä¸²åˆ°kernel_type ret = PTR_ERR(kernel_type); // å°†kernel_typeè½¬æ¢ä¸ºé”™è¯¯ç å¹¶èµ‹å€¼ç»™ret if (IS_ERR(kernel_type)) // å¦‚æœkernel_typeæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆ goto out_type; // è·³è½¬åˆ°out_typeæ ‡ç­¾å¤„ kernel_dev = copy_mount_string(dev_name); // å¤åˆ¶dev_nameå­—ç¬¦ä¸²åˆ°kernel_dev ret = PTR_ERR(kernel_dev); // å°†kernel_devè½¬æ¢ä¸ºé”™è¯¯ç å¹¶èµ‹å€¼ç»™ret if (IS_ERR(kernel_dev)) // å¦‚æœkernel_devæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆ goto out_dev; // è·³è½¬åˆ°out_devæ ‡ç­¾å¤„ options = copy_mount_options(data); // å¤åˆ¶dataå­—ç¬¦ä¸²åˆ°options ret = PTR_ERR(options); // å°†optionsè½¬æ¢ä¸ºé”™è¯¯ç å¹¶èµ‹å€¼ç»™ret if (IS_ERR(options)) // å¦‚æœoptionsæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆ goto out_data; // è·³è½¬åˆ°out_dataæ ‡ç­¾å¤„ ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options); // æ‰§è¡ŒæŒ‚è½½æ“ä½œ kfree(options); // é‡Šæ”¾optionsçš„å†…å­˜out_data: kfree(kernel_dev); // é‡Šæ”¾kernel_devçš„å†…å­˜out_dev: kfree(kernel_type); // é‡Šæ”¾kernel_typeçš„å†…å­˜out_type: return ret; // è¿”å›ret&#125;#define FSMOUNT_VALID_FLAGS \\ (MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOSUID | MOUNT_ATTR_NODEV | \\ MOUNT_ATTR_NOEXEC | MOUNT_ATTR__ATIME | MOUNT_ATTR_NODIRATIME | \\ MOUNT_ATTR_NOSYMFOLLOW)#define MOUNT_SETATTR_VALID_FLAGS (FSMOUNT_VALID_FLAGS | MOUNT_ATTR_IDMAP)#define MOUNT_SETATTR_PROPAGATION_FLAGS \\ (MS_UNBINDABLE | MS_PRIVATE | MS_SLAVE | MS_SHARED) 12345678910111213141516171819static unsigned int attr_flags_to_mnt_flags(u64 attr_flags)&#123; unsigned int mnt_flags = 0; if (attr_flags &amp; MOUNT_ATTR_RDONLY) mnt_flags |= MNT_READONLY; // å¦‚æœattr_flagsä¸­åŒ…å«MOUNT_ATTR_RDONLYæ ‡å¿—ä½ï¼Œåˆ™å°†MNT_READONLYæ ‡å¿—ä½åŠ å…¥mnt_flags if (attr_flags &amp; MOUNT_ATTR_NOSUID) mnt_flags |= MNT_NOSUID; // å¦‚æœattr_flagsä¸­åŒ…å«MOUNT_ATTR_NOSUIDæ ‡å¿—ä½ï¼Œåˆ™å°†MNT_NOSUIDæ ‡å¿—ä½åŠ å…¥mnt_flags if (attr_flags &amp; MOUNT_ATTR_NODEV) mnt_flags |= MNT_NODEV; // å¦‚æœattr_flagsä¸­åŒ…å«MOUNT_ATTR_NODEVæ ‡å¿—ä½ï¼Œåˆ™å°†MNT_NODEVæ ‡å¿—ä½åŠ å…¥mnt_flags if (attr_flags &amp; MOUNT_ATTR_NOEXEC) mnt_flags |= MNT_NOEXEC; // å¦‚æœattr_flagsä¸­åŒ…å«MOUNT_ATTR_NOEXECæ ‡å¿—ä½ï¼Œåˆ™å°†MNT_NOEXECæ ‡å¿—ä½åŠ å…¥mnt_flags if (attr_flags &amp; MOUNT_ATTR_NODIRATIME) mnt_flags |= MNT_NODIRATIME; // å¦‚æœattr_flagsä¸­åŒ…å«MOUNT_ATTR_NODIRATIMEæ ‡å¿—ä½ï¼Œåˆ™å°†MNT_NODIRATIMEæ ‡å¿—ä½åŠ å…¥mnt_flags if (attr_flags &amp; MOUNT_ATTR_NOSYMFOLLOW) mnt_flags |= MNT_NOSYMFOLLOW; // å¦‚æœattr_flagsä¸­åŒ…å«MOUNT_ATTR_NOSYMFOLLOWæ ‡å¿—ä½ï¼Œåˆ™å°†MNT_NOSYMFOLLOWæ ‡å¿—ä½åŠ å…¥mnt_flags return mnt_flags;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* * ä¸ºä¸€ä¸ªæ–°çš„ã€å‡†å¤‡å¥½çš„è¶…çº§å—ï¼ˆç”±fs_fdæŒ‡å®šï¼‰åˆ›å»ºä¸€ä¸ªå†…æ ¸æŒ‚è½½è¡¨ç¤ºï¼Œå¹¶é™„åŠ åˆ°ç±»ä¼¼äºopen_treeçš„æ–‡ä»¶æè¿°ç¬¦ã€‚ */SYSCALL_DEFINE3(fsmount, int, fs_fd, unsigned int, flags, unsigned int, attr_flags)&#123; struct mnt_namespace *ns; // æŒ‡å‘mnt_namespaceç»“æ„ä½“çš„æŒ‡é’ˆ struct fs_context *fc; // æŒ‡å‘fs_contextç»“æ„ä½“çš„æŒ‡é’ˆ struct file *file; // æŒ‡å‘fileç»“æ„ä½“çš„æŒ‡é’ˆ struct path newmount; // æŒ‡å‘pathç»“æ„ä½“çš„æŒ‡é’ˆ struct mount *mnt; // æŒ‡å‘mountç»“æ„ä½“çš„æŒ‡é’ˆ struct fd f; // fdç»“æ„ä½“ unsigned int mnt_flags = 0; // æŒ‚è½½æ ‡å¿— long ret; // è¿”å›å€¼ if (!may_mount()) // æ£€æŸ¥æ˜¯å¦æœ‰æŒ‚è½½æƒé™ return -EPERM; if ((flags &amp; ~(FSMOUNT_CLOEXEC)) != 0) // æ£€æŸ¥flagsæ˜¯å¦åˆæ³• return -EINVAL; if (attr_flags &amp; ~FSMOUNT_VALID_FLAGS) // æ£€æŸ¥attr_flagsæ˜¯å¦åˆæ³• return -EINVAL; mnt_flags = attr_flags_to_mnt_flags(attr_flags); // å°†attr_flagsè½¬æ¢ä¸ºmnt_flags switch (attr_flags &amp; MOUNT_ATTR__ATIME) &#123; // æ ¹æ®attr_flagsçš„ATIMEä½è¿›è¡Œåˆ¤æ–­ case MOUNT_ATTR_STRICTATIME: // å¦‚æœæ˜¯STRICTATIME break; case MOUNT_ATTR_NOATIME: // å¦‚æœæ˜¯NOATIME mnt_flags |= MNT_NOATIME; // è®¾ç½®mnt_flagsçš„MNT_NOATIMEä½ break; case MOUNT_ATTR_RELATIME: // å¦‚æœæ˜¯RELATIME mnt_flags |= MNT_RELATIME; // è®¾ç½®mnt_flagsçš„MNT_RELATIMEä½ break; default: return -EINVAL; // å…¶ä»–æƒ…å†µè¿”å›é”™è¯¯ &#125; f = fdget(fs_fd); // è·å–æ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„æ–‡ä»¶ if (!f.file) return -EBADF; // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿”å›é”™è¯¯ ret = -EINVAL; if (f.file-&gt;f_op != &amp;fscontext_fops) // æ£€æŸ¥æ–‡ä»¶æ“ä½œæ˜¯å¦æ­£ç¡® goto err_fsfd; fc = f.file-&gt;private_data; // è·å–æ–‡ä»¶çš„ç§æœ‰æ•°æ® ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex); // åŠ é” if (ret &lt; 0) goto err_fsfd; /* å¿…é¡»æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„è¶…çº§å—æ‰èƒ½è¿›è¡ŒæŒ‚è½½ */ ret = -EINVAL; if (!fc-&gt;root) goto err_unlock; ret = -EPERM; if (mount_too_revealing(fc-&gt;root-&gt;d_sb, &amp;mnt_flags)) &#123; // æ£€æŸ¥æŒ‚è½½æ˜¯å¦è¿‡äºæš´éœ² pr_warn(&quot;VFS: Mount too revealing\\n&quot;); goto err_unlock; &#125; ret = -EBUSY; if (fc-&gt;phase != FS_CONTEXT_AWAITING_MOUNT) // æ£€æŸ¥æŒ‚è½½é˜¶æ®µæ˜¯å¦æ­£ç¡® goto err_unlock; if (fc-&gt;sb_flags &amp; SB_MANDLOCK) // æ£€æŸ¥è¶…çº§å—æ ‡å¿—æ˜¯å¦åŒ…å«SB_MANDLOCK warn_mandlock(); // å‘å‡ºè­¦å‘Š newmount.mnt = vfs_create_mount(fc); // åˆ›å»ºæŒ‚è½½ç‚¹ if (IS_ERR(newmount.mnt)) &#123; ret = PTR_ERR(newmount.mnt); goto err_unlock; &#125; newmount.dentry = dget(fc-&gt;root); // è·å–æ ¹ç›®å½•çš„dentry newmount.mnt-&gt;mnt_flags = mnt_flags; // è®¾ç½®æŒ‚è½½ç‚¹çš„mnt_flags /* å®ŒæˆæŒ‚è½½æ“ä½œåï¼Œå°†æ–‡ä»¶ä¸Šä¸‹æ–‡è®¾ç½®ä¸ºç±»ä¼¼äºfspick()çš„çŠ¶æ€ã€‚ * æ­¤æ—¶ä¸å¸Œæœ›è¿›è¡Œä»»ä½•å†…å­˜åˆ†é…ç­‰æ“ä½œï¼Œå› ä¸ºä¸å¸Œæœ›å¤„ç†ä»»ä½•å¯èƒ½å‘ç”Ÿçš„é”™è¯¯ã€‚ */ vfs_clean_context(fc); ns = alloc_mnt_ns(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, true); // åˆ†é…mnt_namespaceç»“æ„ä½“ if (IS_ERR(ns)) &#123; ret = PTR_ERR(ns); goto err_path; &#125; mnt = real_mount(newmount.mnt); // è·å–å®é™…çš„mountç»“æ„ä½“ mnt-&gt;mnt_ns = ns; // è®¾ç½®mnt_namespace ns-&gt;root = mnt; ns-&gt;mounts = 1; list_add(&amp;mnt-&gt;mnt_list, &amp;ns-&gt;list); mntget(newmount.mnt); /* ä½¿ç”¨O_PATHæ ‡å¿—æ‰“å¼€ä¸€ä¸ªè¡¨é¢ä¸Šçš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå¹¶æ ‡è®°éœ€è¦å¸è½½è€Œä¸ä»…ä»…æ˜¯é‡Šæ”¾ */ file = dentry_open(&amp;newmount, O_PATH, fc-&gt;cred); // æ‰“å¼€æ–‡ä»¶æè¿°ç¬¦ if (IS_ERR(file)) &#123; dissolve_on_fput(newmount.mnt); ret = PTR_ERR(file); goto err_path; &#125; file-&gt;f_mode |= FMODE_NEED_UNMOUNT; // è®¾ç½®æ–‡ä»¶æ¨¡å¼çš„FMODE_NEED_UNMOUNTä½ ret = get_unused_fd_flags((flags &amp; FSMOUNT_CLOEXEC) ? O_CLOEXEC : 0); // è·å–æœªä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦ if (ret &gt;= 0) fd_install(ret, file); // å®‰è£…æ–‡ä»¶æè¿°ç¬¦ else fput(file);err_path: path_put(&amp;newmount);err_unlock: mutex_unlock(&amp;fc-&gt;uapi_mutex);err_fsfd: fdput(f); return ret;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * å°†ä¸€ä¸ªæŒ‚è½½ç‚¹ä»ä¸€ä¸ªä½ç½®ç§»åŠ¨åˆ°å¦ä¸€ä¸ªä½ç½®ã€‚ä¸fsopen()/fsmount()ç»“åˆä½¿ç”¨ï¼Œç”¨äºå®‰è£…æ–°çš„æŒ‚è½½ç‚¹ï¼Œ * ä¸open_tree(OPEN_TREE_CLONE [| AT_RECURSIVE])ç»“åˆä½¿ç”¨ï¼Œå¯ä»¥ç”¨äºå¤åˆ¶æŒ‚è½½å­æ ‘ã€‚ * * æ³¨æ„ï¼Œflagså€¼æ˜¯MOVE_MOUNT_*æ ‡å¿—çš„ç»„åˆã€‚ */SYSCALL_DEFINE5(move_mount, // å®šä¹‰åä¸ºmove_mountçš„ç³»ç»Ÿè°ƒç”¨ï¼Œæ¥å—5ä¸ªå‚æ•° int, from_dfd, const char __user *, from_pathname, // æºæ–‡ä»¶æè¿°ç¬¦å’Œè·¯å¾„å int, to_dfd, const char __user *, to_pathname, // ç›®æ ‡æ–‡ä»¶æè¿°ç¬¦å’Œè·¯å¾„å unsigned int, flags) // ç§»åŠ¨æŒ‚è½½ç‚¹çš„æ ‡å¿—&#123; struct path from_path, to_path; // å®šä¹‰æºè·¯å¾„å’Œç›®æ ‡è·¯å¾„çš„ç»“æ„ä½“ unsigned int lflags; // æŸ¥æ‰¾æ ‡å¿— int ret = 0; // è¿”å›å€¼ï¼Œé»˜è®¤ä¸º0 if (!may_mount()) // æ£€æŸ¥æ˜¯å¦å…·æœ‰æŒ‚è½½æƒé™ return -EPERM; // æ²¡æœ‰æƒé™åˆ™è¿”å›EPERMé”™è¯¯ if (flags &amp; ~MOVE_MOUNT__MASK) // æ£€æŸ¥flagsæ˜¯å¦åŒ…å«æ— æ•ˆçš„æ ‡å¿—ä½ return -EINVAL; // åŒ…å«æ— æ•ˆæ ‡å¿—ä½åˆ™è¿”å›EINVALé”™è¯¯ /* å¦‚æœæœ‰äººæä¾›äº†è·¯å¾„åï¼Œåˆ™ä¸å…è®¸ä»éœ€è¦å¸è½½çš„æ–‡ä»¶æè¿°ç¬¦ç§»åŠ¨ï¼Œ * å› ä¸ºæˆ‘ä»¬æ— æ³•è®¿é—®æ ‡å¿—ä»¥åœ¨ä¹‹åæ¸…é™¤å®ƒã€‚ */ lflags = 0; // åˆå§‹åŒ–æŸ¥æ‰¾æ ‡å¿— if (flags &amp; MOVE_MOUNT_F_SYMLINKS) lflags |= LOOKUP_FOLLOW; // å¦‚æœflagsåŒ…å«MOVE_MOUNT_F_SYMLINKSæ ‡å¿—ï¼Œåˆ™è®¾ç½®æŸ¥æ‰¾æ ‡å¿—ä¸ºLOOKUP_FOLLOW if (flags &amp; MOVE_MOUNT_F_AUTOMOUNTS) lflags |= LOOKUP_AUTOMOUNT; // å¦‚æœflagsåŒ…å«MOVE_MOUNT_F_AUTOMOUNTSæ ‡å¿—ï¼Œåˆ™è®¾ç½®æŸ¥æ‰¾æ ‡å¿—ä¸ºLOOKUP_AUTOMOUNT if (flags &amp; MOVE_MOUNT_F_EMPTY_PATH) lflags |= LOOKUP_EMPTY; // å¦‚æœflagsåŒ…å«MOVE_MOUNT_F_EMPTY_PATHæ ‡å¿—ï¼Œåˆ™è®¾ç½®æŸ¥æ‰¾æ ‡å¿—ä¸ºLOOKUP_EMPTY ret = user_path_at(from_dfd, from_pathname, lflags, &amp;from_path); // è·å–æºè·¯å¾„çš„struct pathç»“æ„ if (ret &lt; 0) return ret; // è·å–å¤±è´¥åˆ™è¿”å›é”™è¯¯ç  lflags = 0; // åˆå§‹åŒ–æŸ¥æ‰¾æ ‡å¿— if (flags &amp; MOVE_MOUNT_T_SYMLINKS) lflags |= LOOKUP_FOLLOW; // å¦‚æœflagsåŒ…å«MOVE_MOUNT_T_SYMLINKSæ ‡å¿—ï¼Œåˆ™è®¾ç½®æŸ¥æ‰¾æ ‡å¿—ä¸ºLOOKUP_FOLLOW if (flags &amp; MOVE_MOUNT_T_AUTOMOUNTS) lflags |= LOOKUP_AUTOMOUNT; // å¦‚æœflagsåŒ…å«MOVE_MOUNT_T_AUTOMOUNTSæ ‡å¿—ï¼Œåˆ™è®¾ç½®æŸ¥æ‰¾æ ‡å¿—ä¸ºLOOKUP_AUTOMOUNT if (flags &amp; MOVE_MOUNT_T_EMPTY_PATH) lflags |= LOOKUP_EMPTY; // å¦‚æœflagsåŒ…å«MOVE_MOUNT_T_EMPTY_PATHæ ‡å¿—ï¼Œåˆ™è®¾ç½®æŸ¥æ‰¾æ ‡å¿—ä¸ºLOOKUP_EMPTY ret = user_path_at(to_dfd, to_pathname, lflags, &amp;to_path); // è·å–ç›®æ ‡è·¯å¾„çš„struct pathç»“æ„ if (ret &lt; 0) goto out_from; // è·å–å¤±è´¥åˆ™è·³è½¬åˆ°out_fromæ ‡ç­¾å¤„è¿›è¡Œæ¸…ç†æ“ä½œ ret = security_move_mount(&amp;from_path, &amp;to_path); // è¿›è¡Œå®‰å…¨æ£€æŸ¥ if (ret &lt; 0) goto out_to; // å®‰å…¨æ£€æŸ¥å¤±è´¥åˆ™è·³è½¬åˆ°out_toæ ‡ç­¾å¤„è¿›è¡Œæ¸…ç†æ“ä½œ if (flags &amp; MOVE_MOUNT_SET_GROUP) ret = do_set_group(&amp;from_path, &amp;to_path); // å¦‚æœflagsåŒ…å«MOVE_MOUNT_SET_GROUPæ ‡å¿—ï¼Œåˆ™è®¾ç½®æºè·¯å¾„å’Œç›®æ ‡è·¯å¾„çš„ç»„ else ret = do_move_mount(&amp;from_path, &amp;to_path); // å¦åˆ™è¿›è¡ŒæŒ‚è½½ç‚¹çš„ç§»åŠ¨æ“ä½œout_to: path_put(&amp;to_path); // é‡Šæ”¾ç›®æ ‡è·¯å¾„ç»“æ„çš„å¼•ç”¨è®¡æ•°out_from: path_put(&amp;from_path); // é‡Šæ”¾æºè·¯å¾„ç»“æ„çš„å¼•ç”¨è®¡æ•° return ret; // è¿”å›æ“ä½œç»“æœ&#125; 123456789101112131415161718192021222324252627/* * å¦‚æœè·¯å¾„ä»æ ¹ç›®å½•å¯è¾¾ï¼Œåˆ™è¿”å›true * * namespace_semæˆ–mount_lockè¢«æŒæœ‰ */bool is_path_reachable(struct mount *mnt, struct dentry *dentry, const struct path *root)&#123; while (&amp;mnt-&gt;mnt != root-&gt;mnt &amp;&amp; mnt_has_parent(mnt)) &#123; dentry = mnt-&gt;mnt_mountpoint; // æ›´æ–°dentryä¸ºå½“å‰æŒ‚è½½ç‚¹çš„dentry mnt = mnt-&gt;mnt_parent; // æ›´æ–°mntä¸ºå½“å‰æŒ‚è½½ç‚¹çš„çˆ¶æŒ‚è½½ç‚¹ &#125; return &amp;mnt-&gt;mnt == root-&gt;mnt &amp;&amp; is_subdir(dentry, root-&gt;dentry); // åˆ¤æ–­æ˜¯å¦å¯è¾¾æ ¹ç›®å½•å¹¶ä¸”æ˜¯å­ç›®å½•&#125;/* * åˆ¤æ–­path1æ˜¯å¦åœ¨path2ä¸‹é¢ */bool path_is_under(const struct path *path1, const struct path *path2)&#123; bool res; read_seqlock_excl(&amp;mount_lock); // è·å–mount_lockçš„è¯»é” res = is_path_reachable(real_mount(path1-&gt;mnt), path1-&gt;dentry, path2); // è°ƒç”¨is_path_reachableå‡½æ•°åˆ¤æ–­è·¯å¾„æ˜¯å¦å¯è¾¾ read_sequnlock_excl(&amp;mount_lock); // é‡Šæ”¾mount_lockçš„è¯»é” return res; // è¿”å›åˆ¤æ–­ç»“æœ&#125;EXPORT_SYMBOL(path_is_under); // å¯¼å‡ºpath_is_underå‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* * pivot_root Semantics: * Moves the root file system of the current process to the directory put_old, * makes new_root as the new root file system of the current process, and sets * root/cwd of all processes which had them on the current root to new_root. * * Restrictions: * The new_root and put_old must be directories, and must not be on the * same file system as the current process root. The put_old must be * underneath new_root, i.e. adding a non-zero number of /.. to the string * pointed to by put_old must yield the same directory as new_root. No other * file system may be mounted on put_old. After all, new_root is a mountpoint. * * Also, the current root cannot be on the &#x27;rootfs&#x27; (initial ramfs) filesystem. * See Documentation/filesystems/ramfs-rootfs-initramfs.rst for alternatives * in this situation. * * Notes: * - we don&#x27;t move root/cwd if they are not at the root (reason: if something * cared enough to change them, it&#x27;s probably wrong to force them elsewhere) * - it&#x27;s okay to pick a root that isn&#x27;t the root of a file system, e.g. * /nfs/my_root where /nfs is the mount point. It must be a mountpoint, * though, so you may need to say mount --bind /nfs/my_root /nfs/my_root * first. */SYSCALL_DEFINE2(pivot_root, const char __user *, new_root, const char __user *, put_old)&#123; struct path new, old, root; struct mount *new_mnt, *root_mnt, *old_mnt, *root_parent, *ex_parent; struct mountpoint *old_mp, *root_mp; int error; if (!may_mount()) return -EPERM; error = user_path_at(AT_FDCWD, new_root, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &amp;new); if (error) goto out0; error = user_path_at(AT_FDCWD, put_old, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &amp;old); if (error) goto out1; error = security_sb_pivotroot(&amp;old, &amp;new); if (error) goto out2; get_fs_root(current-&gt;fs, &amp;root); old_mp = lock_mount(&amp;old); error = PTR_ERR(old_mp); if (IS_ERR(old_mp)) goto out3; error = -EINVAL; new_mnt = real_mount(new.mnt); root_mnt = real_mount(root.mnt); old_mnt = real_mount(old.mnt); ex_parent = new_mnt-&gt;mnt_parent; root_parent = root_mnt-&gt;mnt_parent; if (IS_MNT_SHARED(old_mnt) || IS_MNT_SHARED(ex_parent) || IS_MNT_SHARED(root_parent)) goto out4; if (!check_mnt(root_mnt) || !check_mnt(new_mnt)) goto out4; if (new_mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out4; error = -ENOENT; if (d_unlinked(new.dentry)) goto out4; error = -EBUSY; if (new_mnt == root_mnt || old_mnt == root_mnt) goto out4; /* loop, on the same file system */ error = -EINVAL; if (root.mnt-&gt;mnt_root != root.dentry) goto out4; /* not a mountpoint */ if (!mnt_has_parent(root_mnt)) goto out4; /* not attached */ if (new.mnt-&gt;mnt_root != new.dentry) goto out4; /* not a mountpoint */ if (!mnt_has_parent(new_mnt)) goto out4; /* not attached */ /* make sure we can reach put_old from new_root */ if (!is_path_reachable(old_mnt, old.dentry, &amp;new)) goto out4; /* make certain new is below the root */ if (!is_path_reachable(new_mnt, new.dentry, &amp;root)) goto out4; lock_mount_hash(); umount_mnt(new_mnt); root_mp = unhash_mnt(root_mnt); /* we&#x27;ll need its mountpoint */ if (root_mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) &#123; new_mnt-&gt;mnt.mnt_flags |= MNT_LOCKED; root_mnt-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED; &#125; /* mount old root on put_old */ attach_mnt(root_mnt, old_mnt, old_mp); /* mount new_root on / */ attach_mnt(new_mnt, root_parent, root_mp); mnt_add_count(root_parent, -1); touch_mnt_namespace(current-&gt;nsproxy-&gt;mnt_ns); /* A moved mount should not expire automatically */ list_del_init(&amp;new_mnt-&gt;mnt_expire); put_mountpoint(root_mp); unlock_mount_hash(); chroot_fs_refs(&amp;root, &amp;new); error = 0;out4: unlock_mount(old_mp); if (!error) mntput_no_expire(ex_parent);out3: path_put(&amp;root);out2: path_put(&amp;old);out1: path_put(&amp;new);out0: return error;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static unsigned int recalc_flags(struct mount_kattr *kattr, struct mount *mnt)&#123; unsigned int flags = mnt-&gt;mnt.mnt_flags; /* è¦æ¸…é™¤çš„æ ‡å¿—ä½ */ flags &amp;= ~kattr-&gt;attr_clr; /* è¦è®¾ç½®çš„æ ‡å¿—ä½ */ flags |= kattr-&gt;attr_set; return flags;&#125;static int can_idmap_mount(const struct mount_kattr *kattr, struct mount *mnt)&#123; struct vfsmount *m = &amp;mnt-&gt;mnt; struct user_namespace *fs_userns = m-&gt;mnt_sb-&gt;s_user_ns; if (!kattr-&gt;mnt_idmap) return 0; /* * ä½¿ç”¨æ–‡ä»¶ç³»ç»ŸèŒƒå›´çš„idæ˜ å°„åˆ›å»ºidæ˜ å°„çš„æŒ‚è½½ç‚¹æ²¡æœ‰æ„ä¹‰ï¼Œå› æ­¤é˜»æ­¢è¯¥æ“ä½œã€‚ * æˆ‘ä»¬ä¸å…è®¸æ¨¡ç³Šçš„è¯­ä¹‰ã€‚ */ if (!check_fsmapping(kattr-&gt;mnt_idmap, m-&gt;mnt_sb)) return -EINVAL; /* * ä¸€æ—¦æŒ‚è½½ç‚¹è¿›è¡Œäº†idæ˜ å°„ï¼Œå°±ä¸å…è®¸æ›´æ”¹å…¶æ˜ å°„å…³ç³»ã€‚ * è¿™æ ·å¯ä»¥ç®€åŒ–äº‹æƒ…ï¼Œè°ƒç”¨è€…å¯ä»¥åˆ›å»ºå¦ä¸€ä¸ªç»‘å®šæŒ‚è½½ç‚¹æ¥è¿›è¡Œidæ˜ å°„ã€‚ */ if (is_idmapped_mnt(m)) return -EPERM; /* åº•å±‚æ–‡ä»¶ç³»ç»Ÿå°šä¸æ”¯æŒidæ˜ å°„çš„æŒ‚è½½ç‚¹ã€‚ */ if (!(m-&gt;mnt_sb-&gt;s_type-&gt;fs_flags &amp; FS_ALLOW_IDMAP)) return -EINVAL; /* æˆ‘ä»¬æ²¡æœ‰æ§åˆ¶è¶…çº§å—çš„æƒé™ã€‚ */ if (!ns_capable(fs_userns, CAP_SYS_ADMIN)) return -EPERM; /* æŒ‚è½½ç‚¹å·²ç»åœ¨æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡ç»“æ„ä¸­å¯è§ã€‚ */ if (!is_anon_ns(mnt-&gt;mnt_ns)) return -EINVAL; return 0;&#125;/** * mnt_allow_writers() - æ£€æŸ¥å±æ€§æ›´æ”¹æ˜¯å¦å…è®¸å†™å…¥æ“ä½œ * @kattr: æ–°çš„æŒ‚è½½å±æ€§ * @mnt: å°†åº”ç”¨@kattrçš„æŒ‚è½½ç‚¹ * * æ£€æŸ¥@katträ¸­çš„æ–°æŒ‚è½½å±æ€§æ˜¯å¦å…è®¸å¹¶å‘å†™å…¥æ“ä½œã€‚ * * è¿”å›å€¼ï¼šå¦‚æœéœ€è¦ä¿æŒå†™å…¥æ“ä½œï¼Œåˆ™è¿”å›trueï¼›å¦åˆ™è¿”å›falseã€‚ */static inline bool mnt_allow_writers(const struct mount_kattr *kattr, const struct mount *mnt)&#123; return (!(kattr-&gt;attr_set &amp; MNT_READONLY) || (mnt-&gt;mnt.mnt_flags &amp; MNT_READONLY)) &amp;&amp; !kattr-&gt;mnt_idmap;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static int mount_setattr_prepare(struct mount_kattr *kattr, struct mount *mnt)&#123; struct mount *m; int err; // éå†æŒ‚è½½ç‚¹é“¾è¡¨ for (m = mnt; m; m = next_mnt(m, mnt)) &#123; // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ›´æ”¹æŒ‚è½½ç‚¹çš„æ ‡å¿—ä½ if (!can_change_locked_flags(m, recalc_flags(kattr, m))) &#123; err = -EPERM; break; &#125; // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œidæ˜ å°„ err = can_idmap_mount(kattr, m); if (err) break; // æ£€æŸ¥æ˜¯å¦å…è®¸å†™å…¥æ“ä½œ if (!mnt_allow_writers(kattr, m)) &#123; err = mnt_hold_writers(m); if (err) break; &#125; // å¦‚æœä¸éœ€è¦é€’å½’å¤„ç†ï¼Œåˆ™ç›´æ¥è¿”å› if (!kattr-&gt;recurse) return 0; &#125; if (err) &#123; struct mount *p; /* * å¦‚æœè°ƒç”¨äº†mnt_hold_writers()ï¼Œåˆ™åœ¨mnt_flagsä¸­è®¾ç½®äº†MNT_WRITE_HOLDæ ‡å¿—ä½ã€‚ * å¾ªç¯å°†æ‰€æœ‰æŒ‚è½½ç‚¹çš„MNT_WRITE_HOLDæ ‡å¿—ä½å–æ¶ˆï¼Œå¹¶ä¸”éœ€è¦åŒ…æ‹¬ç¬¬ä¸€ä¸ªæŒ‚è½½ç‚¹ã€‚ */ for (p = mnt; p; p = next_mnt(p, mnt)) &#123; // å¦‚æœä¹‹å‰è°ƒç”¨äº†mnt_hold_writers()ï¼Œåˆ™è§£é™¤é˜»å¡ if (p-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD) mnt_unhold_writers(p); /* * å½“ç¬¬ä¸€ä¸ªè¢«æ›´æ”¹çš„æŒ‚è½½ç‚¹çš„MNT_WRITE_HOLDæ ‡å¿—ä½è¢«å–æ¶ˆåï¼Œå¾ªç¯ç»“æŸã€‚ */ if (p == m) break; &#125; &#125; return err;&#125;static void do_idmap_mount(const struct mount_kattr *kattr, struct mount *mnt)&#123; // å¦‚æœæ²¡æœ‰è®¾ç½®mnt_idmapï¼Œåˆ™ç›´æ¥è¿”å› if (!kattr-&gt;mnt_idmap) return; /* * ä¸mnt_idmap()ä¸­çš„smp_load_acquire()é…å¯¹ä½¿ç”¨ã€‚ * * ç”±äºæˆ‘ä»¬åªå…è®¸ä¸€ä¸ªæŒ‚è½½ç‚¹æ›´æ”¹idæ˜ å°„ï¼Œå¹¶ä¸”åœ¨can_idmap_mount()ä¸­è¿›è¡Œäº†éªŒè¯ï¼Œ * æˆ‘ä»¬çŸ¥é“è¯¥æŒ‚è½½ç‚¹å·²ç»é™„åŠ äº†@nop_mnt_idmapã€‚å› æ­¤ï¼Œä¸éœ€è¦é‡Šæ”¾ä»»ä½•å¼•ç”¨ã€‚ */ smp_store_release(&amp;mnt-&gt;mnt.mnt_idmap, mnt_idmap_get(kattr-&gt;mnt_idmap));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798static void mount_setattr_commit(struct mount_kattr *kattr, struct mount *mnt)&#123; struct mount *m; // éå†æŒ‚è½½ç‚¹é“¾è¡¨ for (m = mnt; m; m = next_mnt(m, mnt)) &#123; unsigned int flags; // æ‰§è¡Œidæ˜ å°„æ“ä½œ do_idmap_mount(kattr, m); // é‡æ–°è®¡ç®—æ ‡å¿—ä½ flags = recalc_flags(kattr, m); // ä½¿ç”¨WRITE_ONCEåŸå­æ“ä½œè®¾ç½®mnt_flags WRITE_ONCE(m-&gt;mnt.mnt_flags, flags); // å¦‚æœä¹‹å‰è°ƒç”¨äº†mnt_hold_writers()ï¼Œåˆ™è§£é™¤é˜»å¡ if (m-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD) mnt_unhold_writers(m); // å¦‚æœè®¾ç½®äº†propagationï¼Œåˆ™æ›´æ”¹æŒ‚è½½ç‚¹çš„ä¼ æ’­å±æ€§ if (kattr-&gt;propagation) change_mnt_propagation(m, kattr-&gt;propagation); // å¦‚æœä¸éœ€è¦é€’å½’å¤„ç†ï¼Œåˆ™è·³å‡ºå¾ªç¯ if (!kattr-&gt;recurse) break; &#125; // æ›´æ–°æŒ‚è½½ç‚¹å‘½åç©ºé—´çš„æ—¶é—´æˆ³ touch_mnt_namespace(mnt-&gt;mnt_ns);&#125;static int do_mount_setattr(struct path *path, struct mount_kattr *kattr)&#123; struct mount *mnt = real_mount(path-&gt;mnt); int err = 0; // å¦‚æœpathçš„dentryä¸æ˜¯mntçš„æ ¹èŠ‚ç‚¹ï¼Œåˆ™è¿”å›é”™è¯¯ if (path-&gt;dentry != mnt-&gt;mnt.mnt_root) return -EINVAL; // å¦‚æœè®¾ç½®äº†mnt_usernsï¼Œåˆ™åˆ†é…mnt_idmap if (kattr-&gt;mnt_userns) &#123; struct mnt_idmap *mnt_idmap; mnt_idmap = alloc_mnt_idmap(kattr-&gt;mnt_userns); if (IS_ERR(mnt_idmap)) return PTR_ERR(mnt_idmap); kattr-&gt;mnt_idmap = mnt_idmap; &#125; // å¦‚æœè®¾ç½®äº†propagationï¼Œåˆ™è·å–namespace_lock if (kattr-&gt;propagation) &#123; /* * åªæœ‰åœ¨å®é™…æ›´æ”¹ä¼ æ’­å±æ€§æ—¶æ‰è·å–namespace_lockã€‚ */ namespace_lock(); if (kattr-&gt;propagation == MS_SHARED) &#123; err = invent_group_ids(mnt, kattr-&gt;recurse); if (err) &#123; namespace_unlock(); return err; &#125; &#125; &#125; err = -EINVAL; lock_mount_hash(); /* ç¡®ä¿è¿™ä¸æ˜¯çº¯ç²¹çš„VFSå†…éƒ¨æ“ä½œã€‚ */ if (!is_mounted(&amp;mnt-&gt;mnt)) goto out; /* * å¦‚æœè¿™æ˜¯ä¸€ä¸ªå·²é™„åŠ çš„æŒ‚è½½ç‚¹ï¼Œåˆ™ç¡®ä¿å®ƒä½äºè°ƒç”¨è€…çš„æŒ‚è½½å‘½åç©ºé—´ä¸­ã€‚ * å¦‚æœä¸æ˜¯ï¼Œåˆ™ä¸å…è®¸è°ƒç”¨è€…ä¸ä¹‹äº¤äº’ã€‚ * å¦‚æœè¿™æ˜¯ä¸€ä¸ªå·²åˆ†ç¦»çš„æŒ‚è½½ç‚¹ï¼Œåˆ™ç¡®ä¿å®ƒé™„åŠ äº†ä¸€ä¸ªåŒ¿åæŒ‚è½½å‘½åç©ºé—´ï¼Œå³é€šè¿‡OPEN_TREE_CLONEåˆ›å»ºã€‚ */ if (!(mnt_has_parent(mnt) ? check_mnt(mnt) : is_anon_ns(mnt-&gt;mnt_ns))) goto out; /* * é¦–å…ˆï¼Œæˆ‘ä»¬å°†æŒ‚è½½æ ‘è°ƒæ•´ä¸ºå¯ä»¥æ— æ•…éšœæ›´æ”¹æŒ‚è½½å±æ€§çš„çŠ¶æ€ã€‚ * å¦‚æœæˆåŠŸï¼Œåˆ™æäº¤æ‰€æœ‰æ›´æ”¹ï¼›å¦‚æœå¤±è´¥ï¼Œåˆ™è¿›è¡Œæ¸…ç†ã€‚ */ err = mount_setattr_prepare(kattr, mnt); if (!err) mount_setattr_commit(kattr, mnt);out: unlock_mount_hash(); if (kattr-&gt;propagation) &#123; if (err) cleanup_group_ids(mnt, NULL); namespace_unlock(); &#125; return err;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static int build_mount_idmapped(const struct mount_attr *attr, size_t usize,struct mount_kattr *kattr, unsigned int flags)&#123; int err = 0; struct ns_common *ns; struct user_namespace *mnt_userns; struct file *file; // å¦‚æœatträ¸­æ²¡æœ‰è®¾ç½®MOUNT_ATTR_IDMAPï¼Œåˆ™ç›´æ¥è¿”å› if (!((attr-&gt;attr_set | attr-&gt;attr_clr) &amp; MOUNT_ATTR_IDMAP)) return 0; /* * ç›®å‰æˆ‘ä»¬ä¸æ”¯æŒæ¸…é™¤idæ˜ å°„çš„æŒ‚è½½ç‚¹ã€‚å¦‚æœæœ‰è¿™æ ·çš„éœ€æ±‚ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°è€ƒè™‘ï¼Œ * ä½†ç›®å‰è®©æˆ‘ä»¬ä¿æŒç®€å•ï¼Œä¸å…è®¸æ¸…é™¤idæ˜ å°„ã€‚ */ if (attr-&gt;attr_clr &amp; MOUNT_ATTR_IDMAP) return -EINVAL; // å¦‚æœuserns_fdè¶…è¿‡INT_MAXï¼Œåˆ™è¿”å›é”™è¯¯ if (attr-&gt;userns_fd &gt; INT_MAX) return -EINVAL; file = fget(attr-&gt;userns_fd); if (!file) return -EBADF; // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸ºprocæ–‡ä»¶ç³»ç»Ÿçš„å‘½åç©ºé—´æ–‡ä»¶ if (!proc_ns_file(file)) &#123; err = -EINVAL; goto out_fput; &#125; // è·å–æ–‡ä»¶å¯¹åº”çš„å‘½åç©ºé—´ ns = get_proc_ns(file_inode(file)); if (ns-&gt;ops-&gt;type != CLONE_NEWUSER) &#123; err = -EINVAL; goto out_fput; &#125; /* * åˆå§‹idæ˜ å°„ä¸èƒ½ç”¨äºåˆ›å»ºidæ˜ å°„çš„æŒ‚è½½ç‚¹ã€‚ * æˆ‘ä»¬ä½¿ç”¨åˆå§‹idæ˜ å°„ä½œä¸ºéidæ˜ å°„æŒ‚è½½ç‚¹çš„æŒ‡ç¤ºå™¨ã€‚ * å®ƒå¯ä»¥ä½œä¸ºä¸€ä¸ªæ–¹ä¾¿çš„å¿«æ·æ–¹å¼ä¼ é€’ç»™äº†è§£idæ˜ å°„æŒ‚è½½ç‚¹çš„è¾…åŠ©å‡½æ•°ã€‚ * ç”¨æˆ·å¯ä»¥åˆ›å»ºä¸€ä¸ªä¸“ç”¨çš„èº«ä»½æ˜ å°„æ¥å®ç°ç›¸åŒçš„ç»“æœã€‚ */ mnt_userns = container_of(ns, struct user_namespace, ns); if (mnt_userns == &amp;init_user_ns) &#123; err = -EPERM; goto out_fput; &#125; /* æˆ‘ä»¬ä¸æ§åˆ¶ç›®æ ‡å‘½åç©ºé—´ã€‚ */ if (!ns_capable(mnt_userns, CAP_SYS_ADMIN)) &#123; err = -EPERM; goto out_fput; &#125; // è·å–mnt_usernsçš„å¼•ç”¨ kattr-&gt;mnt_userns = get_user_ns(mnt_userns);out_fput: fput(file); return err;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static int build_mount_kattr(const struct mount_attr *attr, size_t usize, struct mount_kattr *kattr, unsigned int flags)&#123; // è®¾ç½®lookup_flagsï¼Œé»˜è®¤ä¸ºLOOKUP_AUTOMOUNT | LOOKUP_FOLLOW unsigned int lookup_flags = LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW; // æ ¹æ®flagsçš„å€¼ä¿®æ”¹lookup_flags if (flags &amp; AT_NO_AUTOMOUNT) lookup_flags &amp;= ~LOOKUP_AUTOMOUNT; if (flags &amp; AT_SYMLINK_NOFOLLOW) lookup_flags &amp;= ~LOOKUP_FOLLOW; if (flags &amp; AT_EMPTY_PATH) lookup_flags |= LOOKUP_EMPTY; // å°†lookup_flagsèµ‹å€¼ç»™kattrçš„lookup_flagsæˆå‘˜ *kattr = (struct mount_kattr) &#123; .lookup_flags = lookup_flags, .recurse = !!(flags &amp; AT_RECURSIVE), &#125;; // æ£€æŸ¥attrçš„propagationå­—æ®µæ˜¯å¦åˆæ³• if (attr-&gt;propagation &amp; ~MOUNT_SETATTR_PROPAGATION_FLAGS) return -EINVAL; // æ£€æŸ¥attrçš„propagationå­—æ®µæ˜¯å¦åªæœ‰ä¸€ä¸ªæ ‡å¿—ä½è¢«è®¾ç½® if (hweight32(attr-&gt;propagation &amp; MOUNT_SETATTR_PROPAGATION_FLAGS) &gt; 1) return -EINVAL; // å°†attrçš„propagationå­—æ®µèµ‹å€¼ç»™kattrçš„propagationæˆå‘˜ kattr-&gt;propagation = attr-&gt;propagation; // æ£€æŸ¥attrçš„attr_setå’Œattr_clrå­—æ®µæ˜¯å¦åˆæ³• if ((attr-&gt;attr_set | attr-&gt;attr_clr) &amp; ~MOUNT_SETATTR_VALID_FLAGS) return -EINVAL; // å°†attrçš„attr_setå­—æ®µè½¬æ¢ä¸ºmnt_flagsï¼Œå¹¶èµ‹å€¼ç»™kattrçš„attr_setæˆå‘˜ kattr-&gt;attr_set = attr_flags_to_mnt_flags(attr-&gt;attr_set); // å°†attrçš„attr_clrå­—æ®µè½¬æ¢ä¸ºmnt_flagsï¼Œå¹¶èµ‹å€¼ç»™kattrçš„attr_clræˆå‘˜ kattr-&gt;attr_clr = attr_flags_to_mnt_flags(attr-&gt;attr_clr); /* * ç”±äºMOUNT_ATTR_&lt;atime&gt;çš„å€¼æ˜¯ä¸€ä¸ªæšä¸¾ç±»å‹ï¼Œè€Œä¸æ˜¯ä½å›¾ï¼Œ * æ‰€ä»¥æƒ³è¦åˆ‡æ¢åˆ°ä¸åŒçš„atimeè®¾ç½®çš„ç”¨æˆ·ä¸èƒ½ä»…åœ¨attr_setä¸­æŒ‡å®šatimeè®¾ç½®ï¼Œ * è¿˜å¿…é¡»åœ¨attr_clrå­—æ®µä¸­æŒ‡å®šMOUNT_ATTR__ATIMEã€‚ * å› æ­¤ï¼Œç¡®ä¿MOUNT_ATTR__ATIMEä¸èƒ½åœ¨attr_clrä¸­éƒ¨åˆ†è®¾ç½®ï¼Œ * å¹¶ä¸”å¦‚æœattr_clrä¸­æ²¡æœ‰è®¾ç½®MOUNT_ATTR__ATIMEï¼Œåˆ™attr_setä¸­ä¸èƒ½è®¾ç½®ä»»ä½•atimeä½ã€‚ */ if (attr-&gt;attr_clr &amp; MOUNT_ATTR__ATIME) &#123; if ((attr-&gt;attr_clr &amp; MOUNT_ATTR__ATIME) != MOUNT_ATTR__ATIME) return -EINVAL; /* * æ¸…é™¤æ‰€æœ‰å…ˆå‰çš„æ—¶é—´è®¾ç½®ï¼Œå› ä¸ºå®ƒä»¬æ˜¯äº’æ–¥çš„ã€‚ */ kattr-&gt;attr_clr |= MNT_RELATIME | MNT_NOATIME; switch (attr-&gt;attr_set &amp; MOUNT_ATTR__ATIME) &#123; case MOUNT_ATTR_RELATIME: kattr-&gt;attr_set |= MNT_RELATIME; break; case MOUNT_ATTR_NOATIME: kattr-&gt;attr_set |= MNT_NOATIME; break; case MOUNT_ATTR_STRICTATIME: break; default: return -EINVAL; &#125; &#125; else &#123; if (attr-&gt;attr_set &amp; MOUNT_ATTR__ATIME) return -EINVAL; &#125; // è°ƒç”¨build_mount_idmappedå‡½æ•°è¿›è¡Œè¿›ä¸€æ­¥å¤„ç† return build_mount_idmapped(attr, usize, kattr, flags);&#125;static void finish_mount_kattr(struct mount_kattr *kattr)&#123; // é‡Šæ”¾kattrçš„mnt_usernsæˆå‘˜ put_user_ns(kattr-&gt;mnt_userns); kattr-&gt;mnt_userns = NULL; // é‡Šæ”¾kattrçš„mnt_idmapæˆå‘˜ if (kattr-&gt;mnt_idmap) mnt_idmap_put(kattr-&gt;mnt_idmap);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657SYSCALL_DEFINE5(mount_setattr, int, dfd, const char __user *, path, unsigned int, flags, struct mount_attr __user *, uattr, size_t, usize)&#123; int err; struct path target; struct mount_attr attr; struct mount_kattr kattr; // æ£€æŸ¥struct mount_attrçš„å¤§å°æ˜¯å¦æ­£ç¡® BUILD_BUG_ON(sizeof(struct mount_attr) != MOUNT_ATTR_SIZE_VER0); // æ£€æŸ¥flagsæ˜¯å¦åŒ…å«éæ³•æ ‡å¿—ä½ if (flags &amp; ~(AT_EMPTY_PATH | AT_RECURSIVE | AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT)) return -EINVAL; // æ£€æŸ¥usizeæ˜¯å¦è¶…è¿‡é¡µå¤§å° if (unlikely(usize &gt; PAGE_SIZE)) return -E2BIG; // æ£€æŸ¥usizeæ˜¯å¦å°äºMOUNT_ATTR_SIZE_VER0 if (unlikely(usize &lt; MOUNT_ATTR_SIZE_VER0)) return -EINVAL; // æ£€æŸ¥æ˜¯å¦æœ‰æƒé™è¿›è¡ŒæŒ‚è½½æ“ä½œ if (!may_mount()) return -EPERM; // ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶struct mount_attråˆ°å†…æ ¸ç©ºé—´çš„attrå˜é‡ err = copy_struct_from_user(&amp;attr, sizeof(attr), uattr, usize); if (err) return err; /* å¦‚æœattrçš„attr_setã€attr_clrå’Œpropagationå­—æ®µéƒ½ä¸º0ï¼Œåˆ™ä¸éœ€è¦éå†æŒ‚è½½ç‚¹ã€‚ */ if (attr.attr_set == 0 &amp;&amp; attr.attr_clr == 0 &amp;&amp; attr.propagation == 0) return 0; // æ„å»ºmount_kattrç»“æ„ä½“ err = build_mount_kattr(&amp;attr, usize, &amp;kattr, flags); if (err) return err; // è·å–ç›®æ ‡è·¯å¾„çš„struct path err = user_path_at(dfd, path, kattr.lookup_flags, &amp;target); if (!err) &#123; // æ‰§è¡ŒæŒ‚è½½å±æ€§è®¾ç½®æ“ä½œ err = do_mount_setattr(&amp;target, &amp;kattr); path_put(&amp;target); &#125; // å®Œæˆmount_kattrç»“æ„ä½“çš„å¤„ç† finish_mount_kattr(&amp;kattr); return err;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778static void __init init_mount_tree(void)&#123; struct vfsmount *mnt; struct mount *m; struct mnt_namespace *ns; struct path root; // ä½¿ç”¨rootfs_fs_typeæŒ‚è½½æ ¹æ–‡ä»¶ç³»ç»Ÿ mnt = vfs_kern_mount(&amp;rootfs_fs_type, 0, &quot;rootfs&quot;, NULL); if (IS_ERR(mnt)) panic(&quot;Can&#x27;t create rootfs&quot;); // åˆ†é…åˆå§‹å‘½åç©ºé—´ ns = alloc_mnt_ns(&amp;init_user_ns, false); if (IS_ERR(ns)) panic(&quot;Can&#x27;t allocate initial namespace&quot;); m = real_mount(mnt); m-&gt;mnt_ns = ns; ns-&gt;root = m; ns-&gt;mounts = 1; list_add(&amp;m-&gt;mnt_list, &amp;ns-&gt;list); init_task.nsproxy-&gt;mnt_ns = ns; get_mnt_ns(ns); root.mnt = mnt; root.dentry = mnt-&gt;mnt_root; mnt-&gt;mnt_flags |= MNT_LOCKED; // è®¾ç½®å½“å‰è¿›ç¨‹çš„æ–‡ä»¶ç³»ç»Ÿæ ¹ç›®å½•å’Œå½“å‰å·¥ä½œç›®å½• set_fs_pwd(current-&gt;fs, &amp;root); set_fs_root(current-&gt;fs, &amp;root);&#125;void __init mnt_init(void)&#123; int err; // åˆ›å»ºmnt_cacheå†…å­˜ç¼“å­˜ mnt_cache = kmem_cache_create(&quot;mnt_cache&quot;, sizeof(struct mount), 0, SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL); // åˆ†é…mount_hashtableå’Œmountpoint_hashtableå“ˆå¸Œè¡¨ mount_hashtable = alloc_large_system_hash(&quot;Mount-cache&quot;, sizeof(struct hlist_head), mhash_entries, 19, HASH_ZERO, &amp;m_hash_shift, &amp;m_hash_mask, 0, 0); mountpoint_hashtable = alloc_large_system_hash(&quot;Mountpoint-cache&quot;, sizeof(struct hlist_head), mphash_entries, 19, HASH_ZERO, &amp;mp_hash_shift, &amp;mp_hash_mask, 0, 0); // æ£€æŸ¥æ˜¯å¦æˆåŠŸåˆ†é…å“ˆå¸Œè¡¨ if (!mount_hashtable || !mountpoint_hashtable) panic(&quot;Failed to allocate mount hash table\\n&quot;); // åˆå§‹åŒ–kernfsæ–‡ä»¶ç³»ç»Ÿ kernfs_init(); // åˆå§‹åŒ–sysfsæ–‡ä»¶ç³»ç»Ÿ err = sysfs_init(); if (err) printk(KERN_WARNING &quot;%s: sysfs_init error: %d\\n&quot;, __func__, err); fs_kobj = kobject_create_and_add(&quot;fs&quot;, NULL); if (!fs_kobj) printk(KERN_WARNING &quot;%s: kobj create error\\n&quot;, __func__); // åˆå§‹åŒ–shmemæ–‡ä»¶ç³»ç»Ÿ shmem_init(); // åˆå§‹åŒ–rootfs init_rootfs(); // åˆå§‹åŒ–æŒ‚è½½æ ‘ init_mount_tree();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void put_mnt_ns(struct mnt_namespace *ns)&#123; // å¦‚æœå¼•ç”¨è®¡æ•°ä¸ä¸º0ï¼Œåˆ™å‡å°‘å¼•ç”¨è®¡æ•°å¹¶è¿”å› if (!refcount_dec_and_test(&amp;ns-&gt;ns.count)) return; // é‡Šæ”¾æŒ‚è½½ç‚¹å’Œå‘½åç©ºé—´ drop_collected_mounts(&amp;ns-&gt;root-&gt;mnt); free_mnt_ns(ns);&#125;// æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿstruct vfsmount *kern_mount(struct file_system_type *type)&#123; struct vfsmount *mnt; // è°ƒç”¨vfs_kern_mountå‡½æ•°æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿ mnt = vfs_kern_mount(type, SB_KERNMOUNT, type-&gt;name, NULL); // å¦‚æœæŒ‚è½½æˆåŠŸ if (!IS_ERR(mnt)) &#123; /* * è¿™æ˜¯ä¸€ä¸ªé•¿æœŸæŒ‚è½½ï¼Œç›´åˆ°æ–‡ä»¶ç³»ç»Ÿæ³¨é”€ä¹‹å‰ä¸è¦é‡Šæ”¾mnt */ real_mount(mnt)-&gt;mnt_ns = MNT_NS_INTERNAL; &#125; return mnt;&#125;EXPORT_SYMBOL_GPL(kern_mount);// å¸è½½æŒ‚è½½ç‚¹void kern_unmount(struct vfsmount *mnt)&#123; // é‡Šæ”¾é•¿æœŸæŒ‚è½½ï¼Œä»¥ä¾¿å¯ä»¥é‡Šæ”¾æŒ‚è½½ç‚¹ if (!IS_ERR(mnt)) &#123; mnt_make_shortterm(mnt); synchronize_rcu();// åŒæ­¥RCU mntput(mnt); &#125;&#125;EXPORT_SYMBOL(kern_unmount);// æ‰¹é‡å¸è½½æŒ‚è½½ç‚¹void kern_unmount_array(struct vfsmount *mnt[], unsigned int num)&#123; unsigned int i; // å°†æŒ‚è½½ç‚¹è®¾ç½®ä¸ºçŸ­æœŸæŒ‚è½½ for (i = 0; i &lt; num; i++) mnt_make_shortterm(mnt[i]); synchronize_rcu_expedited(); // å¿«é€ŸåŒæ­¥RCU // é‡Šæ”¾æŒ‚è½½ç‚¹ for (i = 0; i &lt; num; i++) mntput(mnt[i]);&#125;EXPORT_SYMBOL(kern_unmount_array);// æ£€æŸ¥æŒ‚è½½ç‚¹æ˜¯å¦å±äºæˆ‘ä»¬çš„å‘½åç©ºé—´bool our_mnt(struct vfsmount *mnt)&#123; return check_mnt(real_mount(mnt));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192bool current_chrooted(void)&#123; /* å½“å‰è¿›ç¨‹æ˜¯å¦å…·æœ‰éæ ‡å‡†æ ¹ç›®å½• */ struct path ns_root; struct path fs_root; bool chrooted; /* æŸ¥æ‰¾å‘½åç©ºé—´çš„æ ¹ç›®å½• */ ns_root.mnt = &amp;current-&gt;nsproxy-&gt;mnt_ns-&gt;root-&gt;mnt; ns_root.dentry = ns_root.mnt-&gt;mnt_root; path_get(&amp;ns_root); // å¾ªç¯å‘ä¸‹éå†ï¼Œç›´åˆ°æ‰¾åˆ°éæŒ‚è½½ç‚¹çš„ç›®å½• while (d_mountpoint(ns_root.dentry) &amp;&amp; follow_down_one(&amp;ns_root)) ; // è·å–æ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½• get_fs_root(current-&gt;fs, &amp;fs_root); // åˆ¤æ–­æ˜¯å¦ä¸ºchrootç¯å¢ƒ chrooted = !path_equal(&amp;fs_root, &amp;ns_root); path_put(&amp;fs_root); path_put(&amp;ns_root); return chrooted;&#125;static bool mnt_already_visible(struct mnt_namespace *ns, const struct super_block *sb, int *new_mnt_flags)&#123; int new_flags = *new_mnt_flags; struct mount *mnt; bool visible = false; down_read(&amp;namespace_sem); lock_ns_list(ns); // éå†å‘½åç©ºé—´ä¸­çš„æŒ‚è½½ç‚¹åˆ—è¡¨ list_for_each_entry(mnt, &amp;ns-&gt;list, mnt_list) &#123; struct mount *child; int mnt_flags; if (mnt_is_cursor(mnt)) continue; // å¦‚æœæŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿç±»å‹ä¸åŒ¹é…ï¼Œåˆ™ç»§ç»­ä¸‹ä¸€ä¸ªæŒ‚è½½ç‚¹ if (mnt-&gt;mnt.mnt_sb-&gt;s_type != sb-&gt;s_type) continue; /* å¦‚æœæŒ‚è½½ç‚¹çš„æ ¹ç›®å½•ä¸æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•ï¼Œåˆ™è¯¥æŒ‚è½½ç‚¹ä¸æ˜¯å®Œå…¨å¯è§çš„ */ if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root) continue; /* è·å–æŒ‚è½½ç‚¹çš„æŒ‚è½½æ ‡å¿— */ mnt_flags = mnt-&gt;mnt.mnt_flags; /* å¦‚æœæ–‡ä»¶ç³»ç»Ÿçš„è¶…çº§å—æ ‡å¿—ä¸­åŒ…å«åªè¯»æ ‡å¿—ï¼Œåˆ™åœ¨æŒ‚è½½æ ‡å¿—ä¸­æ·»åŠ åªè¯»é”å®šæ ‡å¿— */ if (sb_rdonly(mnt-&gt;mnt.mnt_sb)) mnt_flags |= MNT_LOCK_READONLY; /* éªŒè¯æŒ‚è½½æ ‡å¿—æ˜¯å¦ä¸æ–°æŒ‚è½½çš„æ ‡å¿—ç›¸ç­‰æˆ–æ›´åŠ å®½æ¾ */ if ((mnt_flags &amp; MNT_LOCK_READONLY) &amp;&amp; !(new_flags &amp; MNT_READONLY)) continue; if ((mnt_flags &amp; MNT_LOCK_ATIME) &amp;&amp; ((mnt_flags &amp; MNT_ATIME_MASK) != (new_flags &amp; MNT_ATIME_MASK))) continue; /* å¦‚æœå­˜åœ¨ä»»ä½•è¢«é”å®šçš„å­æŒ‚è½½ç‚¹è¦†ç›–é™¤ç©ºç›®å½•ä»¥å¤–çš„å†…å®¹ï¼Œåˆ™è¯¥æŒ‚è½½ç‚¹ä¸æ˜¯å®Œå…¨å¯è§çš„ */ list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; struct inode *inode = child-&gt;mnt_mountpoint-&gt;d_inode; /* åªå…³æ³¨è¢«é”å®šçš„æŒ‚è½½ç‚¹ */ if (!(child-&gt;mnt.mnt_flags &amp; MNT_LOCKED)) continue; /* ç›®å½•æ˜¯å¦æ°¸ä¹…ä¸ºç©ºï¼Ÿ */ if (!is_empty_dir_inode(inode)) goto next; &#125; /* ä¿ç•™è¢«é”å®šçš„å±æ€§ */ *new_mnt_flags |= mnt_flags &amp; (MNT_LOCK_READONLY | \\ MNT_LOCK_ATIME); visible = true; goto found; next:; &#125;found: unlock_ns_list(ns); up_read(&amp;namespace_sem); return visible;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static bool mount_too_revealing(const struct super_block *sb, int *new_mnt_flags)&#123; const unsigned long required_iflags = SB_I_NOEXEC | SB_I_NODEV; struct mnt_namespace *ns = current-&gt;nsproxy-&gt;mnt_ns; unsigned long s_iflags; // å¦‚æœå‘½åç©ºé—´çš„ç”¨æˆ·å‘½åç©ºé—´æ˜¯åˆå§‹ç”¨æˆ·å‘½åç©ºé—´ï¼Œåˆ™ä¸ä¼šè¿‡åº¦æš´éœ² if (ns-&gt;user_ns == &amp;init_user_ns) return false; /* æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å¯èƒ½è¿‡åº¦æš´éœ²ï¼Ÿ */ s_iflags = sb-&gt;s_iflags; if (!(s_iflags &amp; SB_I_USERNS_VISIBLE)) return false; // æ£€æŸ¥s_iflagsæ˜¯å¦åŒ…å«æ‰€éœ€çš„æ ‡å¿—ä½ if ((s_iflags &amp; required_iflags) != required_iflags) &#123; WARN_ONCE(1, &quot;Expected s_iflags to contain 0x%lx\\n&quot;, required_iflags); return true; &#125; return !mnt_already_visible(ns, sb, new_mnt_flags);&#125;bool mnt_may_suid(struct vfsmount *mnt)&#123; /* * å¤–éƒ¨æŒ‚è½½ç‚¹ï¼ˆé€šè¿‡fchdiræˆ–é€šè¿‡/procç¬¦å·é“¾æ¥è®¿é—®ï¼‰å§‹ç»ˆè¢«è§†ä¸ºnosuidã€‚ * è¿™æ ·å¯ä»¥é˜²æ­¢å‘½åç©ºé—´ä¿¡ä»»å¯èƒ½ä¸å®‰å…¨çš„suid/sgidä½ã€æ–‡ä»¶èƒ½åŠ›æˆ–å®‰å…¨æ ‡ç­¾ï¼Œ * è¿™äº›éƒ½æ¥è‡ªå…¶ä»–å‘½åç©ºé—´ã€‚ */ return !(mnt-&gt;mnt_flags &amp; MNT_NOSUID) &amp;&amp; check_mnt(real_mount(mnt)) &amp;&amp; current_in_userns(mnt-&gt;mnt_sb-&gt;s_user_ns);&#125;static struct ns_common *mntns_get(struct task_struct *task)&#123; struct ns_common *ns = NULL; struct nsproxy *nsproxy; task_lock(task); nsproxy = task-&gt;nsproxy; if (nsproxy) &#123; ns = &amp;nsproxy-&gt;mnt_ns-&gt;ns; get_mnt_ns(to_mnt_ns(ns)); &#125; task_unlock(task); return ns;&#125;","categories":[],"tags":[]},{"title":"å­¦ä¹  Linux /fs/dcache.cæºç åˆ†æ","slug":"å­¦ä¹ -Linux-fs-dcache-cæºç åˆ†æ","date":"2023-08-13T07:04:17.000Z","updated":"2023-08-17T04:04:27.441Z","comments":true,"path":"2023/08/13/å­¦ä¹ -Linux-fs-dcache-cæºç åˆ†æ/","link":"","permalink":"http://example.com/2023/08/13/%E5%AD%A6%E4%B9%A0-Linux-fs-dcache-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// SPDX-License-Identifier: GPL-2.0-only/*- fs/dcache.c-- å®Œå…¨é‡æ–°å®ç°- (C) 1997 Thomas Schoebel-Theuer,- Linus Torvaldsåšäº†å¤§é‡æ”¹åŠ¨- åˆ†é…ç­–ç•¥æ³¨é‡Š:-- dcacheæ˜¯icacheçš„ä¸»äºº - å½“ä¸€ä¸ªdcacheæ¡ç›®å­˜åœ¨æ—¶,- inodeæ€»æ˜¯ä¼šå­˜åœ¨ã€‚å½“dcacheæ¡ç›®è¢«åˆ é™¤æˆ–åƒåœ¾å›æ”¶æ—¶ä¼šè°ƒç”¨&quot;iput()&quot;ã€‚*/#include &lt;linux/ratelimit.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/fscrypt.h&gt;#include &lt;linux/fsnotify.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/hash.h&gt;#include &lt;linux/cache.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/seqlock.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/bit_spinlock.h&gt;#include &lt;linux/rculist_bl.h&gt;#include &lt;linux/list_lru.h&gt;#include &quot;internal.h&quot;#include &quot;mount.h&quot;/*- ä½¿ç”¨æ–¹æ³•:- dcache-&gt;d_inode-&gt;i_lock ä¿æŠ¤:- - i_dentry, d_u.d_alias, åˆ«åçš„d_inode- dcache_hash_bucketé”ä¿æŠ¤:- - dcacheå“ˆå¸Œè¡¨- s_roots blé“¾è¡¨è‡ªæ—‹é”ä¿æŠ¤:- - s_rootsåˆ—è¡¨(__d_drop)- dentry-&gt;d_sb-&gt;s_dentry_lru_lockä¿æŠ¤:- - dcache LRUåˆ—è¡¨å’Œè®¡æ•°å™¨- d_lockä¿æŠ¤:- - d_flags- - d_name- - d_lru- - d_count- - d_unhashed()- - d_parentå’Œd_subdirs- - å­èŠ‚ç‚¹çš„d_childå’Œd_parent- - d_u.d_alias, d_inode-- é¡ºåº:- dentry-&gt;d_inode-&gt;i_lock- dentry-&gt;d_lock dentry-&gt;d_sb-&gt;s_dentry_lru_lock dcache_hash_bucketé” s_rootsé”-- å¦‚æœå­˜åœ¨ç¥–å…ˆå…³ç³»:- dentry-&gt;d_parent-&gt;...-&gt;d_parent-&gt;d_lock- ... dentry-&gt;d_parent-&gt;d_lock dentry-&gt;d_lock-- å¦‚æœæ²¡æœ‰ç¥–å…ˆå…³ç³»:- ä»»æ„é¡ºåº,å› ä¸ºå®ƒåœ¨rename_lockä¸Šåºåˆ—åŒ– */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int sysctl_vfs_cache_pressure __read_mostly = 100;EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure); //å¯¼å‡ºåªè¯»å˜é‡sysctl_vfs_cache_pressureç»™GPLæ¨¡å—__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock); //å®šä¹‰ä¸€ä¸ªåºåˆ—é”rename_lock,åœ¨SMPç³»ç»Ÿä¸­ç¼“å­˜å¯¹é½EXPORT_SYMBOL(rename_lock); //å¯¼å‡ºrename_lockå˜é‡static struct kmem_cache *dentry_cache __read_mostly; //å®šä¹‰ä¸€ä¸ªé™æ€çš„dentryç¼“å­˜æŒ‡é’ˆ,åªè¯»const struct qstr empty_name = QSTR_INIT(&quot;&quot;, 0); //å®šä¹‰ä¸€ä¸ªç©ºåçš„é™æ€constç»“æ„ä½“qstrEXPORT_SYMBOL(empty_name); //å¯¼å‡ºempty_nameconst struct qstr slash_name = QSTR_INIT(&quot;/&quot;, 1); //å®šä¹‰ä¸€ä¸ª&quot;/&quot;åçš„é™æ€constç»“æ„ä½“qstrEXPORT_SYMBOL(slash_name); //å¯¼å‡ºslash_name const struct qstr dotdot_name = QSTR_INIT(&quot;..&quot;, 2); //å®šä¹‰ä¸€ä¸ª&quot;..&quot;åçš„é™æ€constç»“æ„ä½“qstrEXPORT_SYMBOL(dotdot_name); //å¯¼å‡ºdotdot_name/** è¿™æ˜¯å…³äºdcacheæœ€å…³é”®çš„æ•°æ®ç»“æ„:ç”¨äºæŸ¥æ‰¾çš„å“ˆå¸Œè¡¨ã€‚* æœ‰äººåº”è¯¥è¯•ç€ä½¿è¿™ä¸ªå˜å¥½ - æˆ‘åªæ˜¯ä½¿å®ƒå¯ç”¨ã€‚** è¿™ä¸ªæ•£åˆ—å‡½æ•°è¯•å›¾é¿å…æŸå¤±è¿‡å¤šçš„æ•£åˆ—ä¿¡æ¯* åˆé¿å…ä½¿ç”¨ç´ æ•°æ•£åˆ—å¤§å°æˆ–ç±»ä¼¼çš„ã€‚*/static unsigned int d_hash_shift __read_mostly; //å®šä¹‰ä¸€ä¸ªé™æ€çš„æ•£åˆ—åç§»é‡,åªè¯»static struct hlist_bl_head *dentry_hashtable __read_mostly; //å®šä¹‰ä¸€ä¸ªé™æ€çš„dentryå“ˆå¸Œè¡¨æŒ‡é’ˆ,åªè¯»static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; return dentry_hashtable + (hash &gt;&gt; d_hash_shift); //è®¡ç®—å¹¶è¿”å›æ•£åˆ—æ¡¶çš„åœ°å€&#125;#define IN_LOOKUP_SHIFT 10static struct hlist_bl_head in_lookup_hashtable[1 &lt;&lt; IN_LOOKUP_SHIFT]; //å®šä¹‰ä¸€ä¸ªåœ¨æŸ¥æ‰¾æ—¶ä½¿ç”¨çš„å“ˆå¸Œè¡¨static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent, unsigned int hash)&#123; hash += (unsigned long) parent / L1_CACHE_BYTES; //å¢åŠ çˆ¶ç›®å½•çš„å½±å“ return in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT); //è®¡ç®—å¹¶è¿”å›æ•£åˆ—æ¡¶çš„åœ°å€ &#125;struct dentry_stat_t &#123; //å®šä¹‰ä¸€ä¸ªdentryç»Ÿè®¡ç»“æ„ä½“ long nr_dentry; long nr_unused; long age_limit; /* age in seconds */ long want_pages; /* pages requested by system */ long nr_negative; /* # of unused negative dentries */ long dummy; /* Reserved for future use */&#125;;static DEFINE_PER_CPU(long, nr_dentry); //å®šä¹‰ä¸€ä¸ªæ¯ä¸ªCPUä¸€ä¸ªçš„dentryè®¡æ•°å™¨static DEFINE_PER_CPU(long, nr_dentry_unused); //å®šä¹‰ä¸€ä¸ªæ¯ä¸ªCPUä¸€ä¸ªçš„æœªä½¿ç”¨dentryè®¡æ•°å™¨static DEFINE_PER_CPU(long, nr_dentry_negative); //å®šä¹‰ä¸€ä¸ªæ¯ä¸ªCPUä¸€ä¸ªçš„è´Ÿdentryè®¡æ•°å™¨#if defined(CONFIG_SYSCTL) &amp;&amp; defined(CONFIG_PROC_FS)/* ç»Ÿè®¡æ”¶é›†ã€‚*/static struct dentry_stat_t dentry_stat = &#123; .age_limit = 45,&#125;;","text":"dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// SPDX-License-Identifier: GPL-2.0-only/*- fs/dcache.c-- å®Œå…¨é‡æ–°å®ç°- (C) 1997 Thomas Schoebel-Theuer,- Linus Torvaldsåšäº†å¤§é‡æ”¹åŠ¨- åˆ†é…ç­–ç•¥æ³¨é‡Š:-- dcacheæ˜¯icacheçš„ä¸»äºº - å½“ä¸€ä¸ªdcacheæ¡ç›®å­˜åœ¨æ—¶,- inodeæ€»æ˜¯ä¼šå­˜åœ¨ã€‚å½“dcacheæ¡ç›®è¢«åˆ é™¤æˆ–åƒåœ¾å›æ”¶æ—¶ä¼šè°ƒç”¨&quot;iput()&quot;ã€‚*/#include &lt;linux/ratelimit.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/fscrypt.h&gt;#include &lt;linux/fsnotify.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/hash.h&gt;#include &lt;linux/cache.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/seqlock.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/bit_spinlock.h&gt;#include &lt;linux/rculist_bl.h&gt;#include &lt;linux/list_lru.h&gt;#include &quot;internal.h&quot;#include &quot;mount.h&quot;/*- ä½¿ç”¨æ–¹æ³•:- dcache-&gt;d_inode-&gt;i_lock ä¿æŠ¤:- - i_dentry, d_u.d_alias, åˆ«åçš„d_inode- dcache_hash_bucketé”ä¿æŠ¤:- - dcacheå“ˆå¸Œè¡¨- s_roots blé“¾è¡¨è‡ªæ—‹é”ä¿æŠ¤:- - s_rootsåˆ—è¡¨(__d_drop)- dentry-&gt;d_sb-&gt;s_dentry_lru_lockä¿æŠ¤:- - dcache LRUåˆ—è¡¨å’Œè®¡æ•°å™¨- d_lockä¿æŠ¤:- - d_flags- - d_name- - d_lru- - d_count- - d_unhashed()- - d_parentå’Œd_subdirs- - å­èŠ‚ç‚¹çš„d_childå’Œd_parent- - d_u.d_alias, d_inode-- é¡ºåº:- dentry-&gt;d_inode-&gt;i_lock- dentry-&gt;d_lock dentry-&gt;d_sb-&gt;s_dentry_lru_lock dcache_hash_bucketé” s_rootsé”-- å¦‚æœå­˜åœ¨ç¥–å…ˆå…³ç³»:- dentry-&gt;d_parent-&gt;...-&gt;d_parent-&gt;d_lock- ... dentry-&gt;d_parent-&gt;d_lock dentry-&gt;d_lock-- å¦‚æœæ²¡æœ‰ç¥–å…ˆå…³ç³»:- ä»»æ„é¡ºåº,å› ä¸ºå®ƒåœ¨rename_lockä¸Šåºåˆ—åŒ– */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int sysctl_vfs_cache_pressure __read_mostly = 100;EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure); //å¯¼å‡ºåªè¯»å˜é‡sysctl_vfs_cache_pressureç»™GPLæ¨¡å—__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock); //å®šä¹‰ä¸€ä¸ªåºåˆ—é”rename_lock,åœ¨SMPç³»ç»Ÿä¸­ç¼“å­˜å¯¹é½EXPORT_SYMBOL(rename_lock); //å¯¼å‡ºrename_lockå˜é‡static struct kmem_cache *dentry_cache __read_mostly; //å®šä¹‰ä¸€ä¸ªé™æ€çš„dentryç¼“å­˜æŒ‡é’ˆ,åªè¯»const struct qstr empty_name = QSTR_INIT(&quot;&quot;, 0); //å®šä¹‰ä¸€ä¸ªç©ºåçš„é™æ€constç»“æ„ä½“qstrEXPORT_SYMBOL(empty_name); //å¯¼å‡ºempty_nameconst struct qstr slash_name = QSTR_INIT(&quot;/&quot;, 1); //å®šä¹‰ä¸€ä¸ª&quot;/&quot;åçš„é™æ€constç»“æ„ä½“qstrEXPORT_SYMBOL(slash_name); //å¯¼å‡ºslash_name const struct qstr dotdot_name = QSTR_INIT(&quot;..&quot;, 2); //å®šä¹‰ä¸€ä¸ª&quot;..&quot;åçš„é™æ€constç»“æ„ä½“qstrEXPORT_SYMBOL(dotdot_name); //å¯¼å‡ºdotdot_name/** è¿™æ˜¯å…³äºdcacheæœ€å…³é”®çš„æ•°æ®ç»“æ„:ç”¨äºæŸ¥æ‰¾çš„å“ˆå¸Œè¡¨ã€‚* æœ‰äººåº”è¯¥è¯•ç€ä½¿è¿™ä¸ªå˜å¥½ - æˆ‘åªæ˜¯ä½¿å®ƒå¯ç”¨ã€‚** è¿™ä¸ªæ•£åˆ—å‡½æ•°è¯•å›¾é¿å…æŸå¤±è¿‡å¤šçš„æ•£åˆ—ä¿¡æ¯* åˆé¿å…ä½¿ç”¨ç´ æ•°æ•£åˆ—å¤§å°æˆ–ç±»ä¼¼çš„ã€‚*/static unsigned int d_hash_shift __read_mostly; //å®šä¹‰ä¸€ä¸ªé™æ€çš„æ•£åˆ—åç§»é‡,åªè¯»static struct hlist_bl_head *dentry_hashtable __read_mostly; //å®šä¹‰ä¸€ä¸ªé™æ€çš„dentryå“ˆå¸Œè¡¨æŒ‡é’ˆ,åªè¯»static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; return dentry_hashtable + (hash &gt;&gt; d_hash_shift); //è®¡ç®—å¹¶è¿”å›æ•£åˆ—æ¡¶çš„åœ°å€&#125;#define IN_LOOKUP_SHIFT 10static struct hlist_bl_head in_lookup_hashtable[1 &lt;&lt; IN_LOOKUP_SHIFT]; //å®šä¹‰ä¸€ä¸ªåœ¨æŸ¥æ‰¾æ—¶ä½¿ç”¨çš„å“ˆå¸Œè¡¨static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent, unsigned int hash)&#123; hash += (unsigned long) parent / L1_CACHE_BYTES; //å¢åŠ çˆ¶ç›®å½•çš„å½±å“ return in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT); //è®¡ç®—å¹¶è¿”å›æ•£åˆ—æ¡¶çš„åœ°å€ &#125;struct dentry_stat_t &#123; //å®šä¹‰ä¸€ä¸ªdentryç»Ÿè®¡ç»“æ„ä½“ long nr_dentry; long nr_unused; long age_limit; /* age in seconds */ long want_pages; /* pages requested by system */ long nr_negative; /* # of unused negative dentries */ long dummy; /* Reserved for future use */&#125;;static DEFINE_PER_CPU(long, nr_dentry); //å®šä¹‰ä¸€ä¸ªæ¯ä¸ªCPUä¸€ä¸ªçš„dentryè®¡æ•°å™¨static DEFINE_PER_CPU(long, nr_dentry_unused); //å®šä¹‰ä¸€ä¸ªæ¯ä¸ªCPUä¸€ä¸ªçš„æœªä½¿ç”¨dentryè®¡æ•°å™¨static DEFINE_PER_CPU(long, nr_dentry_negative); //å®šä¹‰ä¸€ä¸ªæ¯ä¸ªCPUä¸€ä¸ªçš„è´Ÿdentryè®¡æ•°å™¨#if defined(CONFIG_SYSCTL) &amp;&amp; defined(CONFIG_PROC_FS)/* ç»Ÿè®¡æ”¶é›†ã€‚*/static struct dentry_stat_t dentry_stat = &#123; .age_limit = 45,&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨è‡ªå·±çš„è®¡æ•°å™¨è€Œä¸æ˜¯ä½¿ç”¨é€šç”¨çš„æ¯ä¸ªCPUè®¡æ•°å™¨* ä»¥ä¿æŒä¸vfs inodeä»£ç æ‰€åšçš„ä¸€è‡´ã€‚é€šè¿‡æ‹¥æœ‰è‡ªå·±çš„ä¸“ç”¨è®¡æ•°å™¨,æˆ‘ä»¬æœŸæœ›* æ”¶è·æ›´å¥½çš„ä»£ç å’Œæ€§èƒ½ã€‚** è¯·æ³¨æ„,å¾ªç¯æ˜¯åœ¨æ‰€æœ‰å¯èƒ½çš„CPUä¸Šå®Œæˆçš„,è€Œä¸æ˜¯åœ¨æ‰€æœ‰åœ¨çº¿CPUä¸Šã€‚* åšè¿™ä¸ªçš„åŸå› æ˜¯æˆ‘ä»¬ä¸æƒ³ç©CPUå¼€å…³çš„æ¸¸æˆã€‚å¦‚æœå…¶ä¸­ä¸€ä¸ªå…³é—­äº†,æˆ‘ä»¬* å°†åªä¿ç•™å®ƒä»¬çš„è®¡æ•°å™¨ã€‚** glommer:æœ‰å…³è¯¦ç»†ä¿¡æ¯,è¯·å‚è§cffbc8a,å¦‚æœæ‚¨æ‰“ç®—å¯¹æ­¤è¿›è¡Œæ›´æ”¹,* è¯·æ›´æ–°æ‰€æœ‰ä¸ä¹‹åŒ¹é…çš„vfsè®¡æ•°å™¨ã€‚*/static long get_nr_dentry(void) &#123; int i; long sum = 0; for_each_possible_cpu(i) //å¾ªç¯æ¯ä¸ªå¯èƒ½çš„CPU sum += per_cpu(nr_dentry, i); //ç´¯åŠ å„ä¸ªCPUä¸Šçš„dentryè®¡æ•° return sum &lt; 0 ? 0 : sum; //è¿”å›æ€»å’Œ&#125;static long get_nr_dentry_unused(void)&#123; int i; long sum = 0; for_each_possible_cpu(i) //å¾ªç¯æ¯ä¸ªå¯èƒ½çš„CPU sum += per_cpu(nr_dentry_unused, i); //ç´¯åŠ å„ä¸ªCPUä¸Šçš„æœªä½¿ç”¨dentryè®¡æ•° return sum &lt; 0 ? 0 : sum; //è¿”å›æ€»å’Œ&#125;static long get_nr_dentry_negative(void) &#123; int i; long sum = 0; for_each_possible_cpu(i) //å¾ªç¯æ¯ä¸ªå¯èƒ½çš„CPU sum += per_cpu(nr_dentry_negative, i); //ç´¯åŠ å„ä¸ªCPUä¸Šçš„è´Ÿdentryè®¡æ•° return sum &lt; 0 ? 0 : sum; //è¿”å›æ€»å’Œ&#125;static int proc_nr_dentry(struct ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos)&#123; dentry_stat.nr_dentry = get_nr_dentry(); //è·å¾—dentryæ€»æ•° dentry_stat.nr_unused = get_nr_dentry_unused(); //è·å¾—æœªä½¿ç”¨dentryæ•° dentry_stat.nr_negative = get_nr_dentry_negative(); //è·å¾—è´Ÿdentryæ•° return proc_doulongvec_minmax(table, write, buffer, lenp, ppos); //å†™å…¥procæ–‡ä»¶ç³»ç»Ÿ&#125;static struct ctl_table fs_dcache_sysctls[] = &#123; //å®šä¹‰dcacheçš„sysctlè¡¨ &#123; .procname = &quot;dentry-state&quot;, //è¡¨é¡¹å .data = &amp;dentry_stat, //è¡¨é¡¹æ•°æ® .maxlen = 6*sizeof(long), //è¡¨é¡¹æ•°æ®æœ€å¤§é•¿åº¦ .mode = 0444, //è¡¨é¡¹æƒé™ .proc_handler = proc_nr_dentry, //è¡¨é¡¹å¤„ç†å‡½æ•° &#125;, &#123; &#125; &#125;;static int __init init_fs_dcache_sysctls(void) &#123; register_sysctl_init(&quot;fs&quot;, fs_dcache_sysctls); //æ³¨å†Œdcacheçš„sysctlè¡¨ return 0;&#125;fs_initcall(init_fs_dcache_sysctls); //æ¨¡å—åˆå§‹åŒ–t++; tcount--; &#125; while (tcount); return 0; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** æ¯”è¾ƒä¸¤ä¸ªåå­—å­—ç¬¦ä¸²,å¦‚æœåŒ¹é…è¿”å›0,å¦åˆ™é0ã€‚* ä¸¤ä¸ªå­—ç¬¦ä¸²é•¿åº¦éƒ½æ˜¯countå­—èŠ‚,counté0ã€‚*/#ifdef CONFIG_DCACHE_WORD_ACCESS #include &lt;asm/word-at-a-time.h&gt;/** æ³¨æ„!&#x27;cs&#x27;å’Œ&#x27;scount&#x27;æ¥è‡ªä¸€ä¸ªdentry,æ‰€ä»¥å®ƒæœ‰å¯¹é½çš„åˆ†é…* å¯¹äºè¿™ä¸ªç‰¹å®šçš„ç»„ä»¶ã€‚æˆ‘ä»¬ä¸ä¸¥æ ¼éœ€è¦load_unaligned_zeropad()* çš„å®‰å…¨æ€§,ä½†å®ƒä¹Ÿä¸ä¼šæœ‰å®³ã€‚** ç›¸æ¯”ä¹‹ä¸‹,&#x27;ct&#x27;å’Œ&#x27;tcount&#x27;å¯èƒ½æ¥è‡ªä¸€ä¸ªè·¯å¾„å,å¹¶éœ€è¦* å°å¿ƒçš„éå¯¹é½å¤„ç†ã€‚*/static inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)&#123; unsigned long a,b,mask; for (;;) &#123; a = read_word_at_a_time(cs); // ä¸€æ¬¡è¯»ä¸€ä¸ªæœºå™¨å­— b = load_unaligned_zeropad(ct); //å°å¿ƒåœ°è¯»ä¸€ä¸ªæœºå™¨å­— if (tcount &lt; sizeof(unsigned long)) //è‹¥å‰©ä½™æ¯”è¾ƒå­—èŠ‚æ•°ä¸è¶³ä¸€ä¸ªæœºå™¨å­—,åˆ™é€€å‡ºå¾ªç¯ break; if (unlikely(a != b)) //è‹¥ä¸¤ä¸ªæœºå™¨å­—ä¸ç›¸ç­‰,è¿”å›ä¸åŒ¹é… return 1; cs += sizeof(unsigned long); ct += sizeof(unsigned long); tcount -= sizeof(unsigned long); if (!tcount) //è‹¥å·²ç»æ¯”è¾ƒå®Œ,è¿”å›åŒ¹é… return 0; &#125; mask = bytemask_from_count(tcount); //è·å¾—å‰©ä½™å­—èŠ‚æ©ç  return unlikely(!!((a ^ b) &amp; mask)); //æŒ‰æ©ç æ¯”è¾ƒå‰©ä½™å­—èŠ‚&#125;#elsestatic inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)&#123; do &#123; if (*cs != *ct) //é€å­—èŠ‚æ¯”è¾ƒ return 1; cs++; ct++; tcount--; &#125; while (tcount); return 0; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175// å®šä¹‰ä¸€ä¸ªå†…è”å‡½æ•°ï¼Œç”¨äºæ¯”è¾ƒç›®å½•é¡¹çš„åç§°static inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)&#123; /* * åœ¨RCUï¼ˆRead-Copy-Updateï¼‰éå†è¿‡ç¨‹ä¸­ï¼Œè¦å°å¿ƒé‡å‘½åæ“ä½œçš„ç«æ€æ¡ä»¶ï¼› * ä½¿ç”¨&#x27;READ_ONCE&#x27;æ¥è·å–åç§°æŒ‡é’ˆã€‚ * * æ³¨æ„ï¼å³ä½¿ç”±äºé‡å‘½åå¯¼è‡´é•¿åº¦ä¸èƒ½åŸå­æ€§åœ°åŠ è½½ï¼Œæˆ‘ä»¬ä¹Ÿä¸åœ¨ä¹ã€‚å› ä¸ºRCUéå† * æœ€ç»ˆä¼šæ£€æŸ¥åºåˆ—è®¡æ•°ï¼Œå¹¶æŠ“ä½å®ƒã€‚å¹¶ä¸”æˆ‘ä»¬ä¸ä¼šè¶…è¿‡ç¼“å†²åŒºï¼Œå› ä¸ºæˆ‘ä»¬ä»¥åŸå­æ–¹å¼è¯»å– * åç§°æŒ‡é’ˆï¼Œè€Œä¸”ç›®å½•é¡¹åç§°ä¿è¯ä»¥NULå­—èŠ‚æ­£ç¡®ç»ˆæ­¢ã€‚ * * æœ€ç»ˆç»“æœï¼šå³ä½¿&#x27;len&#x27;æ˜¯é”™çš„ï¼Œæˆ‘ä»¬ä¹Ÿä¼šæå‰é€€å‡ºï¼Œå› ä¸ºæ•°æ®ä¸èƒ½åŒ¹é…ï¼ˆåœ¨ct/tcountæ•°æ®ä¸­ * ä¸èƒ½æœ‰NULï¼‰ */ // è·å–ç›®å½•é¡¹çš„åç§° const unsigned char *cs = READ_ONCE(dentry-&gt;d_name.name); // è°ƒç”¨dentry_string_cmpå‡½æ•°æ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸² return dentry_string_cmp(cs, ct, tcount);&#125;// å®šä¹‰ä¸€ä¸ªå¤–éƒ¨åç§°ç»“æ„struct external_name &#123; // å®šä¹‰ä¸€ä¸ªè”åˆä½“ï¼ŒåŒ…å«ä¸€ä¸ªåŸå­ç±»å‹çš„è®¡æ•°å™¨å’Œä¸€ä¸ªRCUå¤´éƒ¨ union &#123; atomic_t count; struct rcu_head head; &#125; u; // å®šä¹‰ä¸€ä¸ªæ— ç¬¦å·å­—ç¬¦æ•°ç»„æ¥å­˜å‚¨åç§° unsigned char name[];&#125;;// å®šä¹‰ä¸€ä¸ªå†…è”å‡½æ•°ï¼Œç”¨äºè·å–ç›®å½•é¡¹çš„å¤–éƒ¨åç§°static inline struct external_name *external_name(struct dentry *dentry)&#123; // é€šè¿‡åç§°è·å–å¤–éƒ¨åç§°çš„ç»“æ„ä½“ return container_of(dentry-&gt;d_name.name, struct external_name, name[0]);&#125;// å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨RCUå›è°ƒä¸­é‡Šæ”¾dentrystatic void __d_free(struct rcu_head *head)&#123; // è·å–RCUå¤´éƒ¨æ‰€åœ¨çš„dentry struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu); // ä½¿ç”¨kmem_cache_freeå‡½æ•°é‡Šæ”¾dentryçš„ç¼“å­˜ kmem_cache_free(dentry_cache, dentry); &#125;// å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºåœ¨RCUå›è°ƒä¸­é‡Šæ”¾å«æœ‰å¤–éƒ¨åç§°çš„dentrystatic void __d_free_external(struct rcu_head *head)&#123; // è·å–RCUå¤´éƒ¨æ‰€åœ¨çš„dentry struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu); // é‡Šæ”¾å¤–éƒ¨åç§° kfree(external_name(dentry)); // é‡Šæ”¾dentryçš„ç¼“å­˜ kmem_cache_free(dentry_cache, dentry);&#125;// å®šä¹‰ä¸€ä¸ªå†…è”å‡½æ•°ï¼Œç”¨äºåˆ¤æ–­dentryçš„åç§°æ˜¯å¦ä¸ºå¤–éƒ¨åç§°static inline int dname_external(const struct dentry *dentry)&#123; // å¦‚æœdentryçš„åç§°ä¸ç­‰äºå†…éƒ¨åç§°ï¼Œåˆ™è¿”å›çœŸï¼ˆå³ï¼Œåç§°æ˜¯å¤–éƒ¨çš„ï¼‰ return dentry-&gt;d_name.name != dentry-&gt;d_iname;&#125;// å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºè·å–dentryçš„åç§°å¿«ç…§void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)&#123; // é”å®šdentry spin_lock(&amp;dentry-&gt;d_lock); // å°†dentryçš„åç§°èµ‹å€¼ç»™å¿«ç…§ name-&gt;name = dentry-&gt;d_name; // å¦‚æœdentryçš„åç§°æ˜¯å¤–éƒ¨çš„ if (unlikely(dname_external(dentry))) &#123; // å¢åŠ å¤–éƒ¨åç§°çš„å¼•ç”¨è®¡æ•° atomic_inc(&amp;external_name(dentry)-&gt;u.count); &#125; else &#123; // å¦‚æœdentryçš„åç§°æ˜¯å†…éƒ¨çš„ï¼Œå°†åç§°å¤åˆ¶åˆ°å¿«ç…§çš„å†…è”åç§°ä¸­ memcpy(name-&gt;inline_name, dentry-&gt;d_iname, // å¤åˆ¶dentryçš„å†…éƒ¨åç§°åˆ°å¿«ç…§çš„å†…è”åç§°ä¸­ï¼Œé•¿åº¦ä¸ºdentryåç§°çš„é•¿åº¦åŠ 1ï¼ˆåŠ ä¸Šç»“æŸç¬¦ï¼‰ dentry-&gt;d_name.len + 1); // è®¾ç½®å¿«ç…§çš„åç§°ä¸ºå¿«ç…§çš„å†…è”åç§° name-&gt;name.name = name-&gt;inline_name; &#125; // è§£é”dentry spin_unlock(&amp;dentry-&gt;d_lock);&#125;// å¯¼å‡ºtake_dentry_name_snapshotå‡½æ•°ï¼Œä½¿å…¶å¯ä»¥åœ¨å†…æ ¸çš„å…¶ä»–æ¨¡å—ä¸­ä½¿ç”¨EXPORT_SYMBOL(take_dentry_name_snapshot);void release_dentry_name_snapshot(struct name_snapshot *name)&#123; if (unlikely(name-&gt;name.name != name-&gt;inline_name)) &#123; // å¦‚æœname-&gt;name.nameä¸ç­‰äºname-&gt;inline_nameï¼Œè¯´æ˜nameä½¿ç”¨äº†external_nameç»“æ„ struct external_name *p; p = container_of(name-&gt;name.name, struct external_name, name[0]); // é€šè¿‡name-&gt;name.nameè·å–external_nameç»“æ„çš„æŒ‡é’ˆp if (unlikely(atomic_dec_and_test(&amp;p-&gt;u.count))) // é€’å‡p-&gt;u.countçš„å€¼ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦ä¸º0 kfree_rcu(p, u.head); // å¦‚æœp-&gt;u.countä¸º0ï¼Œåˆ™é‡Šæ”¾pæ‰€æŒ‡å‘çš„external_nameç»“æ„ &#125;&#125;EXPORT_SYMBOL(release_dentry_name_snapshot);static inline void __d_set_inode_and_type(struct dentry *dentry, struct inode *inode, unsigned type_flags)&#123; unsigned flags; dentry-&gt;d_inode = inode; flags = READ_ONCE(dentry-&gt;d_flags); flags &amp;= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU); flags |= type_flags; smp_store_release(&amp;dentry-&gt;d_flags, flags); // è®¾ç½®dentryçš„inodeå’Œç±»å‹æ ‡å¿—&#125;static inline void __d_clear_type_and_inode(struct dentry *dentry)&#123; unsigned flags = READ_ONCE(dentry-&gt;d_flags); flags &amp;= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU); WRITE_ONCE(dentry-&gt;d_flags, flags); dentry-&gt;d_inode = NULL; if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) this_cpu_inc(nr_dentry_negative); // æ¸…é™¤dentryçš„ç±»å‹æ ‡å¿—å’Œinodeï¼Œå¹¶æ ¹æ®éœ€è¦æ›´æ–°è®¡æ•°å™¨&#125;static void dentry_free(struct dentry *dentry)&#123; WARN_ON(!hlist_unhashed(&amp;dentry-&gt;d_u.d_alias)); if (unlikely(dname_external(dentry))) &#123; struct external_name *p = external_name(dentry); if (likely(atomic_dec_and_test(&amp;p-&gt;u.count))) &#123; call_rcu(&amp;dentry-&gt;d_u.d_rcu, __d_free_external); return; &#125; &#125; // æ£€æŸ¥dentryæ˜¯å¦ä½¿ç”¨äº†external_nameç»“æ„ï¼Œå¦‚æœæ˜¯åˆ™é€’å‡å¼•ç”¨è®¡æ•° // å¦‚æœå¼•ç”¨è®¡æ•°ä¸º0ï¼Œåˆ™é‡Šæ”¾external_nameç»“æ„ if (dentry-&gt;d_flags &amp; DCACHE_NORCU) __d_free(&amp;dentry-&gt;d_u.d_rcu); else call_rcu(&amp;dentry-&gt;d_u.d_rcu, __d_free); // æ ¹æ®dentryçš„RCUæ ‡å¿—ï¼Œé€‰æ‹©ç«‹å³é‡Šæ”¾æˆ–é€šè¿‡RCUæœºåˆ¶é‡Šæ”¾dentry&#125;/* * é‡Šæ”¾dentryçš„inodeï¼Œå¦‚æœå®šä¹‰äº†æ–‡ä»¶ç³»ç»Ÿçš„d_iput()æ“ä½œã€‚ */static void dentry_unlink_inode(struct dentry *dentry) __releases(dentry-&gt;d_lock) __releases(dentry-&gt;d_inode-&gt;i_lock)&#123; struct inode *inode = dentry-&gt;d_inode; raw_write_seqcount_begin(&amp;dentry-&gt;d_seq); __d_clear_type_and_inode(dentry); hlist_del_init(&amp;dentry-&gt;d_u.d_alias); raw_write_seqcount_end(&amp;dentry-&gt;d_seq); spin_unlock(&amp;dentry-&gt;d_lock); spin_unlock(&amp;inode-&gt;i_lock); if (!inode-&gt;i_nlink) fsnotify_inoderemove(inode); if (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_iput) dentry-&gt;d_op-&gt;d_iput(dentry, inode); else iput(inode); // é‡Šæ”¾dentryçš„inodeå¹¶æ‰§è¡Œç›¸åº”çš„æ“ä½œï¼ˆå¦‚é€šçŸ¥æ–‡ä»¶ç³»ç»Ÿæˆ–é‡Šæ”¾inodeï¼‰&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/* * å½“&#x27;d_lru&#x27;æ¡ç›®æ­£åœ¨ä½¿ç”¨æ—¶ï¼ŒDCACHE_LRU_LISTä½è®¾ç½®ä¸º1ï¼Œ * è¿™åŒ…æ‹¬&quot;çœŸæ­£&quot;çš„æ¯ä¸ªè¶…çº§å—LRUåˆ—è¡¨å’ŒDCACHE_SHRINK_LISTçš„ä½¿ç”¨ã€‚ */#define D_FLAG_VERIFY(dentry,x) WARN_ON_ONCE(((dentry)-&gt;d_flags &amp; (DCACHE_LRU_LIST | DCACHE_SHRINK_LIST)) != (x))// å°†dentryæ·»åŠ åˆ°LRUåˆ—è¡¨ä¸­static void d_lru_add(struct dentry *dentry)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸º0ï¼Œå³æœªè®¾ç½®DCACHE_LRU_LISTå’ŒDCACHE_SHRINK_LISTä½ D_FLAG_VERIFY(dentry, 0); // å°†DCACHE_LRU_LISTä½è®¾ç½®ä¸º1ï¼Œè¡¨ç¤ºdentryåœ¨ä½¿ç”¨ä¸­ dentry-&gt;d_flags |= DCACHE_LRU_LIST; // å¢åŠ å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_inc(nr_dentry_unused); // å¦‚æœdentryæ˜¯è´Ÿçš„ï¼ˆè¡¨ç¤ºä¸å­˜åœ¨çš„æ–‡ä»¶æˆ–ç›®å½•ï¼‰ï¼Œå¢åŠ å½“å‰CPUçš„nr_dentry_negativeè®¡æ•°å™¨çš„å€¼ if (d_is_negative(dentry)) this_cpu_inc(nr_dentry_negative); // å‘dentryæ‰€å±çš„è¶…çº§å—çš„s_dentry_lruåˆ—è¡¨æ·»åŠ dentryçš„d_lruèŠ‚ç‚¹ // å°†dentryæ·»åŠ åˆ°è¶…çº§å—çš„LRUåˆ—è¡¨ä¸­ WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// ä»LRUåˆ—è¡¨ä¸­åˆ é™¤dentrystatic void d_lru_del(struct dentry *dentry)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸ºDCACHE_LRU_LISTï¼Œè¡¨ç¤ºdentryåœ¨LRUåˆ—è¡¨ä¸­ D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // æ¸…é™¤DCACHE_LRU_LISTä½ï¼Œè¡¨ç¤ºdentryä¸å†åœ¨LRUåˆ—è¡¨ä¸­ dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST; // å‡å°‘å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_dec(nr_dentry_unused); // å¦‚æœdentryæ˜¯è´Ÿçš„ï¼ˆè¡¨ç¤ºä¸å­˜åœ¨çš„æ–‡ä»¶æˆ–ç›®å½•ï¼‰ï¼Œå‡å°‘å½“å‰CPUçš„nr_dentry_negativeè®¡æ•°å™¨çš„å€¼ if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // ä»dentryæ‰€å±çš„è¶…çº§å—çš„s_dentry_lruåˆ—è¡¨ä¸­åˆ é™¤dentryçš„d_lruèŠ‚ç‚¹ // ä»è¶…çº§å—çš„LRUåˆ—è¡¨ä¸­åˆ é™¤dentry WARN_ON_ONCE(!list_lru_del(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// ä»æ”¶ç¼©åˆ—è¡¨ä¸­åˆ é™¤dentrystatic void d_shrink_del(struct dentry *dentry)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸ºDCACHE_SHRINK_LISTå’ŒDCACHE_LRU_LISTï¼Œè¡¨ç¤ºdentryåœ¨æ”¶ç¼©åˆ—è¡¨ä¸­ D_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // ä»dentryçš„d_lruèŠ‚ç‚¹æ‰€åœ¨çš„é“¾è¡¨ä¸­åˆ é™¤dentry // æ¸…é™¤DCACHE_SHRINK_LISTå’ŒDCACHE_LRU_LISTä½ï¼Œè¡¨ç¤ºdentryä¸å†åœ¨æ”¶ç¼©åˆ—è¡¨å’ŒLRUåˆ—è¡¨ä¸­ list_del_init(&amp;dentry-&gt;d_lru); dentry-&gt;d_flags &amp;= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // å‡å°‘å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_dec(nr_dentry_unused);&#125;// å°†dentryæ·»åŠ åˆ°æ”¶ç¼©åˆ—è¡¨ä¸­static void d_shrink_add(struct dentry *dentry, struct list_head *list)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸º0ï¼Œå³æœªè®¾ç½®DCACHE_LRU_LISTå’ŒDCACHE_SHRINK_LISTä½ D_FLAG_VERIFY(dentry, 0); // å°†dentryçš„d_lruèŠ‚ç‚¹æ·»åŠ åˆ°æŒ‡å®šçš„é“¾è¡¨ä¸­ list_add(&amp;dentry-&gt;d_lru, list); // è®¾ç½®DCACHE_SHRINK_LISTå’ŒDCACHE_LRU_LISTä½ï¼Œè¡¨ç¤ºdentryåœ¨æ”¶ç¼©åˆ—è¡¨å’ŒLRUåˆ—è¡¨ä¸­ dentry-&gt;d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST; // å¢åŠ å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_inc(nr_dentry_unused);&#125;/* * è¿™äº›å‡½æ•°åªèƒ½åœ¨å…¨å±€LRè°¢è°¢æŒ‡æ­£ï¼Œä»¥ä¸‹æ˜¯å¯¹æ¯ä¸€è¡Œä»£ç çš„æ³¨é‡Šï¼š```c/* * å½“&#x27;d_lru&#x27;æ¡ç›®æ­£åœ¨ä½¿ç”¨æ—¶ï¼ŒDCACHE_LRU_LISTä½è®¾ç½®ä¸º1ï¼Œ * è¿™åŒ…æ‹¬&quot;çœŸæ­£&quot;çš„æ¯ä¸ªè¶…çº§å—LRUåˆ—è¡¨å’ŒDCACHE_SHRINK_LISTçš„ä½¿ç”¨ã€‚ */#define D_FLAG_VERIFY(dentry,x) WARN_ON_ONCE(((dentry)-&gt;d_flags &amp; (DCACHE_LRU_LIST | DCACHE_SHRINK_LIST)) != (x))// å°†dentryæ·»åŠ åˆ°LRUåˆ—è¡¨ä¸­static void d_lru_add(struct dentry *dentry)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸º0ï¼Œå³æœªè®¾ç½®DCACHE_LRU_LISTå’ŒDCACHE_SHRINK_LISTä½ D_FLAG_VERIFY(dentry, 0); // å°†DCACHE_LRU_LISTä½è®¾ç½®ä¸º1ï¼Œè¡¨ç¤ºdentryåœ¨ä½¿ç”¨ä¸­ dentry-&gt;d_flags |= DCACHE_LRU_LIST; // å¢åŠ å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_inc(nr_dentry_unused); // å¦‚æœdentryæ˜¯è´Ÿçš„ï¼ˆè¡¨ç¤ºä¸å­˜åœ¨çš„æ–‡ä»¶æˆ–ç›®å½•ï¼‰ï¼Œå¢åŠ å½“å‰CPUçš„nr_dentry_negativeè®¡æ•°å™¨çš„å€¼ if (d_is_negative(dentry)) this_cpu_inc(nr_dentry_negative); // å‘dentryæ‰€å±çš„è¶…çº§å—çš„s_dentry_lruåˆ—è¡¨æ·»åŠ dentryçš„d_lruèŠ‚ç‚¹ // å°†dentryæ·»åŠ åˆ°è¶…çº§å—çš„LRUåˆ—è¡¨ä¸­ WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// ä»LRUåˆ—è¡¨ä¸­åˆ é™¤dentrystatic void d_lru_del(struct dentry *dentry)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸ºDCACHE_LRU_LISTï¼Œè¡¨ç¤ºdentryåœ¨LRUåˆ—è¡¨ä¸­ D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // æ¸…é™¤DCACHE_LRU_LISTä½ï¼Œè¡¨ç¤ºdentryä¸å†åœ¨LRUåˆ—è¡¨ä¸­ dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST; // å‡å°‘å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_dec(nr_dentry_unused); // å¦‚æœdentryæ˜¯è´Ÿçš„ï¼ˆè¡¨ç¤ºä¸å­˜åœ¨çš„æ–‡ä»¶æˆ–ç›®å½•ï¼‰ï¼Œå‡å°‘å½“å‰CPUçš„nr_dentry_negativeè®¡æ•°å™¨çš„å€¼ if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // ä»dentryæ‰€å±çš„è¶…çº§å—çš„s_dentry_lruåˆ—è¡¨ä¸­åˆ é™¤dentryçš„d_lruèŠ‚ç‚¹ // ä»è¶…çº§å—çš„LRUåˆ—è¡¨ä¸­åˆ é™¤dentry WARN_ON_ONCE(!list_lru_del(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// ä»æ”¶ç¼©åˆ—è¡¨ä¸­åˆ é™¤dentrystatic void d_shrink_del(struct dentry *dentry)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸ºDCACHE_SHRINK_LISTå’ŒDCACHE_LRU_LISTï¼Œè¡¨ç¤ºdentryåœ¨æ”¶ç¼©åˆ—è¡¨ä¸­ D_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // ä»dentryçš„d_lruèŠ‚ç‚¹æ‰€åœ¨çš„é“¾è¡¨ä¸­åˆ é™¤dentry // æ¸…é™¤DCACHE_SHRINK_LISTå’ŒDCACHE_LRU_LISTä½ï¼Œè¡¨ç¤ºdentryä¸å†åœ¨æ”¶ç¼©åˆ—è¡¨å’ŒLRUåˆ—è¡¨ä¸­ list_del_init(&amp;dentry-&gt;d_lru); dentry-&gt;d_flags &amp;= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // å‡å°‘å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_dec(nr_dentry_unused);&#125;// å°†dentryæ·»åŠ åˆ°æ”¶ç¼©åˆ—è¡¨ä¸­static void d_shrink_add(struct dentry *dentry, struct list_head *list)&#123; // ç¡®ä¿d_flagsçš„å€¼ä¸º0ï¼Œå³æœªè®¾ç½®DCACHE_LRU_LISTå’ŒDCACHE_SHRINK_LISTä½ D_FLAG_VERIFY(dentry, 0); // å°†dentryçš„d_lruèŠ‚ç‚¹æ·»åŠ åˆ°æŒ‡å®šçš„é“¾è¡¨ä¸­ list_add(&amp;dentry-&gt;d_lru, list); // è®¾ç½®DCACHE_SHRINK_LISTå’ŒDCACHE_LRU_LISTä½ï¼Œè¡¨ç¤ºdentryåœ¨æ”¶ç¼©åˆ—è¡¨å’ŒLRUåˆ—è¡¨ä¸­ dentry-&gt;d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST; // å¢åŠ å½“å‰CPUçš„nr_dentry_unusedè®¡æ•°å™¨çš„å€¼ this_cpu_inc(nr_dentry_unused);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* * è¿™äº›å‡½æ•°åªèƒ½åœ¨å…¨å±€ LRU é”å®šæœŸé—´è°ƒç”¨ï¼Œå³åœ¨é‡Šæ”¾ LRU åˆ—è¡¨çš„å›è°ƒå‡½æ•°ä¸­ã€‚ * å‡½æ•° `d_lru_isolate` å°†ç»™å®šçš„ dentry ä» LRU åˆ—è¡¨ä¸­ç§»é™¤ï¼Œè€Œå‡½æ•° `d_lru_shrink_move` åˆ™å°†å…¶ç§»åŠ¨åˆ°æŒ‡å®šçš„ç§æœ‰åˆ—è¡¨ä¸­ã€‚ */static void d_lru_isolate(struct list_lru_one *lru, struct dentry *dentry)&#123; // ç¡®ä¿ dentry çš„æ ‡å¿—ä½ä¸­åŒ…å« DCACHE_LRU_LIST D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // æ¸…é™¤ dentry çš„æ ‡å¿—ä½ DCACHE_LRU_LIST dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST; // å‡å°‘æœªä½¿ç”¨çš„ dentry çš„è®¡æ•°å™¨ this_cpu_dec(nr_dentry_unused); // å¦‚æœ dentry æ˜¯è´Ÿé¢çš„ï¼ˆä¸å­˜åœ¨çš„ï¼‰ï¼Œåˆ™å‡å°‘è´Ÿé¢ dentry çš„è®¡æ•°å™¨ if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // å°† dentry ä» LRU åˆ—è¡¨ä¸­éš”ç¦»å‡ºæ¥ list_lru_isolate(lru, &amp;dentry-&gt;d_lru);&#125;static void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry, struct list_head *list)&#123; // ç¡®ä¿ dentry çš„æ ‡å¿—ä½ä¸­åŒ…å« DCACHE_LRU_LIST D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // å°† dentry çš„æ ‡å¿—ä½è®¾ç½®ä¸º DCACHE_SHRINK_LIST dentry-&gt;d_flags |= DCACHE_SHRINK_LIST; // å¦‚æœ dentry æ˜¯è´Ÿé¢çš„ï¼ˆä¸å­˜åœ¨çš„ï¼‰ï¼Œåˆ™å‡å°‘è´Ÿé¢ dentry çš„è®¡æ•°å™¨ if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // å°† dentry ä» LRU åˆ—è¡¨ä¸­ç§»åŠ¨åˆ°æŒ‡å®šçš„åˆ—è¡¨ä¸­ list_lru_isolate_move(lru, &amp;dentry-&gt;d_lru, list);&#125;static void ___d_drop(struct dentry *dentry)&#123; struct hlist_bl_head *b; /* * å“ˆå¸Œçš„ dentry é€šå¸¸ä½äº dentry å“ˆå¸Œè¡¨ä¸­ï¼Œ * ä½†æ˜¯é€šè¿‡ d_obtain_root æ–°åˆ†é…çš„ dentry ä¾‹å¤–ï¼Œ * å®ƒä»¬æ€»æ˜¯ IS_ROOT çš„ï¼š */ if (unlikely(IS_ROOT(dentry))) // å¦‚æœ dentry æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåˆ™ä½¿ç”¨ s_roots ä½œä¸ºå“ˆå¸Œè¡¨å¤´éƒ¨ b = &amp;dentry-&gt;d_sb-&gt;s_roots; else // å¦åˆ™ï¼Œæ ¹æ® dentry çš„å“ˆå¸Œå€¼ç¡®å®šå“ˆå¸Œè¡¨å¤´éƒ¨ b = d_hash(dentry-&gt;d_name.hash); // å¯¹å“ˆå¸Œè¡¨å¤´éƒ¨è¿›è¡ŒåŠ é” hlist_bl_lock(b); // ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ dentry __hlist_bl_del(&amp;dentry-&gt;d_hash); // è§£é”å“ˆå¸Œè¡¨å¤´éƒ¨ hlist_bl_unlock(b);&#125;void __d_drop(struct dentry *dentry)&#123; // å¦‚æœ dentry ä¸æ˜¯æœªå“ˆå¸Œçš„ï¼ˆå·²ç»åœ¨å“ˆå¸Œè¡¨ä¸­ï¼‰ if (!d_unhashed(dentry)) &#123; // æ‰§è¡ŒçœŸæ­£çš„åˆ é™¤æ“ä½œ ___d_drop(dentry); // å°† dentry çš„ d_hash.pprev è®¾ç½®ä¸º NULL dentry-&gt;d_hash.pprev = NULL; // ä½¿ dentry çš„ d_seq å¤±æ•ˆ write_seqcount_invalidate(&amp;dentry-&gt;d_seq); &#125;&#125;EXPORT_SYMBOL(__d_drop); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * d_drop - åˆ é™¤ä¸€ä¸ª dentry * @dentry: è¦åˆ é™¤çš„ dentry * * d_drop() ä»çˆ¶çº§ dentry çš„å“ˆå¸Œè¡¨ä¸­å–æ¶ˆå“ˆå¸Œï¼Œè¿™æ ·å°±æ— æ³•é€šè¿‡ VFS æŸ¥æ‰¾æ‰¾åˆ°å®ƒäº†ã€‚ * æ³¨æ„ï¼Œè¿™ä¸åˆ é™¤ dentry ä¸åŒ - d_delete() ä¼šå°è¯•æ ‡è®° dentry ä¸ºè´Ÿé¢ï¼ˆnegativeï¼‰ï¼Œ * ä»è€Œè¿›è¡Œä¸€æ¬¡æˆåŠŸçš„è´Ÿé¢æŸ¥æ‰¾ï¼Œè€Œ d_drop() åªä¼šä½¿ç¼“å­˜æŸ¥æ‰¾å¤±è´¥ã€‚ * * d_drop() ä¸»è¦ç”¨äºå¸Œæœ›å‡ºäºæŸç§åŸå› ä½¿ dentry å¤±æ•ˆçš„æ“ä½œï¼ˆå¦‚ NFS è¶…æ—¶æˆ– autofs åˆ é™¤ï¼‰ã€‚ * * __d_drop éœ€è¦ dentry-&gt;d_lock é”å®šã€‚ * * ___d_drop ä¸æ ‡è®° dentry ä¸º &quot;unhashed&quot; * ï¼ˆdentry-&gt;d_hash.pprev å°†æ˜¯ LIST_POISON2ï¼Œè€Œä¸æ˜¯ NULLï¼‰ã€‚ */void d_drop(struct dentry *dentry)&#123; spin_lock(&amp;dentry-&gt;d_lock); __d_drop(dentry); spin_unlock(&amp;dentry-&gt;d_lock);&#125;EXPORT_SYMBOL(d_drop);static inline void dentry_unlist(struct dentry *dentry, struct dentry *parent)&#123; struct dentry *next; /* * é€šçŸ¥ d_walk() å’Œ shrink_dentry_list()ï¼Œæˆ‘ä»¬ä¸å†é™„åŠ åˆ° dentry æ ‘ä¸Š */ dentry-&gt;d_flags |= DCACHE_DENTRY_KILLED; if (unlikely(list_empty(&amp;dentry-&gt;d_child))) return; __list_del_entry(&amp;dentry-&gt;d_child); /* * æ¸¸æ ‡å¯èƒ½åœ¨å­åˆ—è¡¨ä¸­ç§»åŠ¨ã€‚å½“æˆ‘ä»¬æ˜¯ä¸€ä¸ªæ™®é€šçš„åˆ—è¡¨æˆå‘˜æ—¶ï¼Œè¿™æ²¡å…³ç³» - * -&gt;d_child.next å°†ä¼šè¢«æ›´æ–°ã€‚ç„¶è€Œï¼Œä»ç°åœ¨å¼€å§‹ï¼Œå®ƒä¸ä¼šè¢«æ›´æ–°ï¼Œ * å¯¹äºåƒ d_walk() è¿™æ ·çš„å‡½æ•°æ¥è¯´ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€ä¸ªä¸å¥½çš„ç»“æœã€‚ * é€šå¸¸æƒ…å†µä¸‹ï¼Œd_walk() ä¸å…³å¿ƒæ¸¸æ ‡çš„ç§»åŠ¨ - çˆ¶çº§çš„ -&gt;d_lock ä¼šé˜»æ­¢ç§»åŠ¨ï¼Œ * å¹¶ä¸”ç”±äºæ¸¸æ ‡æœ¬èº«æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸è§£é”çˆ¶çº§çš„æƒ…å†µä¸‹å®Œæˆéå†ã€‚ * ä½†æ˜¯æœ‰ä¸€ä¸ªä¾‹å¤– - å¦‚æœæˆ‘ä»¬ä»ä¸€ä¸ªåœ¨è§£é”åç«‹å³è¢«åˆ é™¤çš„å­èŠ‚ç‚¹ä¸Šå‡ï¼Œ * ä¸‹ä¸€ä¸ªå…„å¼ŸèŠ‚ç‚¹æ˜¯ä½¿ç”¨å…¶ -&gt;d_child.next ä¸­çš„å€¼æ‰¾åˆ°çš„ã€‚ * å¦‚æœ _é‚£ä¸ª_ æŒ‡å‘ä¸€ä¸ªæ¸¸æ ‡ï¼Œå¹¶ä¸”åœ¨ d_walk() é‡æ–°è·å¾— parent-&gt;d_lock ä¹‹å‰ï¼Œ * æ¸¸æ ‡è¢«ç§»åŠ¨äº†ï¼ˆä¾‹å¦‚é€šè¿‡ lseek()ï¼‰ï¼Œæˆ‘ä»¬ä¼šè·³è¿‡æ¸¸æ ‡å·²ç»ç§»è¿‡çš„æ‰€æœ‰å†…å®¹ã€‚ * * è§£å†³æ–¹æ¡ˆï¼šç¡®ä¿åœ¨ -&gt;d_child.next ä¸­ç•™ä¸‹çš„æŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªä¸ä¼šç§»åŠ¨çš„ä¸œè¥¿ã€‚ * å³è·³è¿‡æ¸¸æ ‡ã€‚ */ while (dentry-&gt;d_child.next != &amp;parent-&gt;d_subdirs) &#123; next = list_entry(dentry-&gt;d_child.next, struct dentry, d_child); if (likely(!(next-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR))) break; dentry-&gt;d_child.next = next-&gt;d_child.next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990static void __dentry_kill(struct dentry *dentry)&#123; struct dentry *parent = NULL; // åˆå§‹åŒ–çˆ¶çº§ dentry ä¸º NULL bool can_free = true; // åˆå§‹åŒ–å¯ä»¥é‡Šæ”¾æ ‡å¿—ä¸º true if (!IS_ROOT(dentry)) parent = dentry-&gt;d_parent; // å¦‚æœä¸æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåˆ™è·å–çˆ¶çº§ dentry /* * ç°åœ¨ï¼Œdentry å¯¹äºç³»ç»Ÿæ¥è¯´å·²ç»æ˜¯æ— æ³•æ¢å¤çš„æ­»äº¡çŠ¶æ€ã€‚ */ lockref_mark_dead(&amp;dentry-&gt;d_lockref); /* * é€šè¿‡ d_prune é€šçŸ¥æ–‡ä»¶ç³»ç»Ÿï¼Œæ­¤ dentry å³å°†è¢«å–æ¶ˆå“ˆå¸Œå’Œé”€æ¯ã€‚ */ if (dentry-&gt;d_flags &amp; DCACHE_OP_PRUNE) dentry-&gt;d_op-&gt;d_prune(dentry); if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) &#123; if (!(dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST)) d_lru_del(dentry); &#125; /* å¦‚æœå®ƒåœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œåˆ™å°†å…¶ç§»é™¤ */ __d_drop(dentry); dentry_unlist(dentry, parent); if (parent) spin_unlock(&amp;parent-&gt;d_lock); if (dentry-&gt;d_inode) dentry_unlink_inode(dentry); else spin_unlock(&amp;dentry-&gt;d_lock); this_cpu_dec(nr_dentry); if (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_release) dentry-&gt;d_op-&gt;d_release(dentry); spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; dentry-&gt;d_flags |= DCACHE_MAY_FREE; can_free = false; &#125; spin_unlock(&amp;dentry-&gt;d_lock); if (likely(can_free)) dentry_free(dentry); cond_resched();&#125;static struct dentry *__lock_parent(struct dentry *dentry)&#123; struct dentry *parent; rcu_read_lock(); spin_unlock(&amp;dentry-&gt;d_lock);again: parent = READ_ONCE(dentry-&gt;d_parent); spin_lock(&amp;parent-&gt;d_lock); /* * æˆ‘ä»¬ä¸èƒ½ç›²ç›®åœ°é”å®š dentryï¼Œç›´åˆ°ç¡®å®šä¸ä¼šè¿åé”å®šé¡ºåºã€‚ * ä»»ä½•å¯¹ dentry-&gt;d_parent çš„æ›´æ”¹å¿…é¡»åœ¨ parent-&gt;d_lock é”å®šçš„æƒ…å†µä¸‹å®Œæˆï¼Œ * æ‰€ä»¥ä¸Šé¢çš„ spin_lock() å¯¹äºæ£€æŸ¥å®ƒæ˜¯å¦ä»ç„¶æ˜¯æˆ‘ä»¬çš„å­èŠ‚ç‚¹è¶³å¤Ÿäº†. */ if (unlikely(parent != dentry-&gt;d_parent)) &#123; spin_unlock(&amp;parent-&gt;d_lock); goto again; &#125; rcu_read_unlock(); if (parent != dentry) spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); else parent = NULL; return parent;&#125;static inline struct dentry *lock_parent(struct dentry *dentry)&#123; struct dentry *parent = dentry-&gt;d_parent; if (IS_ROOT(dentry)) return NULL; if (likely(spin_trylock(&amp;parent-&gt;d_lock))) return parent; return __lock_parent(dentry);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130static inline bool retain_dentry(struct dentry *dentry)&#123; // æ£€æŸ¥æ˜¯å¦åœ¨æŸ¥æ‰¾è¿‡ç¨‹ä¸­ WARN_ON(d_in_lookup(dentry)); /* Unreachable? Get rid of it */ // å¦‚æœ dentry ä¸åœ¨å“ˆå¸Œè¡¨ä¸­ if (unlikely(d_unhashed(dentry))) return false; // å¦‚æœ dentry è¢«æ–­å¼€è¿æ¥ if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DISCONNECTED)) return false; // å¦‚æœæ ‡è®°ä¸ºéœ€è¦æ‰§è¡Œåˆ é™¤æ“ä½œ if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE)) &#123; // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„åˆ é™¤å‡½æ•° if (dentry-&gt;d_op-&gt;d_delete(dentry)) return false; &#125; // å¦‚æœæ ‡è®°ä¸ºä¸ç¼“å­˜ if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DONTCACHE)) return false; /* retain; LRU fodder */ // å¼•ç”¨è®¡æ•°å‡ä¸€ dentry-&gt;d_lockref.count--; // å¦‚æœä¸åœ¨ LRU åˆ—è¡¨ä¸­ if (unlikely(!(dentry-&gt;d_flags &amp; DCACHE_LRU_LIST))) // æ·»åŠ åˆ° LRU åˆ—è¡¨ d_lru_add(dentry); // å¦‚æœæ²¡æœ‰è¢«å¼•ç”¨ else if (unlikely(!(dentry-&gt;d_flags &amp; DCACHE_REFERENCED))) // æ ‡è®°ä¸ºå·²å¼•ç”¨ dentry-&gt;d_flags |= DCACHE_REFERENCED; return true;&#125;void d_mark_dontcache(struct inode *inode)&#123; struct dentry *de; spin_lock(&amp;inode-&gt;i_lock); // éå† inode çš„ dentry é“¾è¡¨ hlist_for_each_entry(de, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; spin_lock(&amp;de-&gt;d_lock); // æ ‡è®°ä¸ºä¸ç¼“å­˜ de-&gt;d_flags |= DCACHE_DONTCACHE; spin_unlock(&amp;de-&gt;d_lock); &#125; // inode æ ‡è®°ä¸ºä¸ç¼“å­˜ inode-&gt;i_state |= I_DONTCACHE; spin_unlock(&amp;inode-&gt;i_lock);&#125;EXPORT_SYMBOL(d_mark_dontcache); // å¯¼å‡ºç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨/* * Finish off a dentry we&#x27;ve decided to kill. * dentry-&gt;d_lock must be held, returns with it unlocked. * Returns dentry requiring refcount drop, or NULL if we&#x27;re done. */static struct dentry *dentry_kill(struct dentry *dentry) __releases(dentry-&gt;d_lock)&#123; struct inode *inode = dentry-&gt;d_inode; struct dentry *parent = NULL; // å¦‚æœ inode å­˜åœ¨ä¸”æ— æ³•è·å–é”ï¼Œåˆ™è·³è½¬åˆ° slow_positive æ ‡ç­¾å¤„ if (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock))) goto slow_positive; // å¦‚æœä¸æ˜¯æ ¹èŠ‚ç‚¹ if (!IS_ROOT(dentry)) &#123; parent = dentry-&gt;d_parent; // å¦‚æœæ— æ³•è·å–çˆ¶çº§ dentry çš„é” if (unlikely(!spin_trylock(&amp;parent-&gt;d_lock))) &#123; // è·å–çˆ¶çº§ dentry çš„é” parent = __lock_parent(dentry); // å¦‚æœ inode å­˜åœ¨æˆ–è€… dentry-&gt;d_inode ä¸ºç©º if (likely(inode || !dentry-&gt;d_inode)) goto got_locks; // negative that became positive if (parent) spin_unlock(&amp;parent-&gt;d_lock); inode = dentry-&gt;d_inode; goto slow_positive; &#125; &#125; // æ‰§è¡ŒçœŸæ­£çš„ dentry é”€æ¯æ“ä½œ __dentry_kill(dentry); return parent;slow_positive: spin_unlock(&amp;dentry-&gt;d_lock); spin_lock(&amp;inode-&gt;i_lock); spin_lock(&amp;dentry-&gt;d_lock); // è·å–çˆ¶çº§ dentry çš„é” parent = lock_parent(dentry);got_locks: // å¦‚æœ dentry å¼•ç”¨è®¡æ•°ä¸ä¸º1 if (unlikely(dentry-&gt;d_lockref.count != 1)) &#123; dentry-&gt;d_lockref.count--; &#125; // å¦‚æœä¸ä¿ç•™è¯¥ dentry else if (likely(!retain_dentry(dentry))) &#123; // æ‰§è¡ŒçœŸæ­£çš„ dentry é”€æ¯æ“ä½œ __dentry_kill(dentry); return parent; &#125; // we are keeping it, after all if (inode) spin_unlock(&amp;inode-&gt;i_lock); if (parent) spin_unlock(&amp;parent-&gt;d_lock); spin_unlock(&amp;dentry-&gt;d_lock); return NULL;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * å°è¯•æ— é”çš„ dput() æ“ä½œï¼Œå¹¶è¿”å›æ˜¯å¦æˆåŠŸã€‚ * * å¦‚æœä¸æˆåŠŸï¼Œæˆ‘ä»¬è¿”å› falseï¼Œå¹¶å·²ç»è·å–äº† dentry é”ã€‚ * * è°ƒç”¨è€…éœ€è¦æŒæœ‰ RCU è¯»é”ï¼Œä»¥ç¡®ä¿å³ä½¿å¼•ç”¨è®¡æ•°é™è‡³é›¶ï¼Œdentry ä»ç„¶å­˜åœ¨ï¼ */static inline bool fast_dput(struct dentry *dentry)&#123; int ret; unsigned int d_flags; /* * å¦‚æœå­˜åœ¨ d_op-&gt;d_delete() æ“ä½œï¼Œæˆ‘ä»¬ä¸åº”è¯¥è®© dentry è®¡æ•°é™è‡³é›¶ï¼Œå› æ­¤ä½¿ç”¨ &quot;put_or_lock&quot;ã€‚ */ if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE)) return lockref_put_or_lock(&amp;dentry-&gt;d_lockref); /* * .. å¦åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•ä»…ä»…å‡å°‘ lockrefã€‚ */ ret = lockref_put_return(&amp;dentry-&gt;d_lockref); /* * å¦‚æœ lockref_put_return() ç”±äºå…¶ä»–äººæŒæœ‰é”è€Œå¤±è´¥ï¼Œ * å¿«é€Ÿè·¯å¾„å¤±è´¥ã€‚æˆ‘ä»¬éœ€è¦è·å–é”ï¼Œç„¶åå†æ¬¡æ£€æŸ¥è®¡æ•°ã€‚ */ if (unlikely(ret &lt; 0)) &#123; spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_lockref.count &gt; 1) &#123; dentry-&gt;d_lockref.count--; spin_unlock(&amp;dentry-&gt;d_lock); return true; &#125; return false; &#125; /* * å¦‚æœæˆ‘ä»¬ä¸æ˜¯æœ€åä¸€ä¸ªå¼•ç”¨ï¼Œæˆ‘ä»¬å®Œæˆäº†ã€‚ */ if (ret) return true; /* * å°å¿ƒï¼Œå°å¿ƒã€‚å¼•ç”¨è®¡æ•°é™è‡³é›¶ï¼Œä½†æˆ‘ä»¬æ²¡æœ‰æŒæœ‰ dentry é”ï¼Œ * å› æ­¤å…¶ä»–äººå¯èƒ½å†æ¬¡è·å–å®ƒï¼Œå¹¶è¿›è¡Œå¦ä¸€ä¸ª dput()ï¼Œ * æˆ‘ä»¬ä¸èƒ½ä¸ä¹‹ç«äº‰ã€‚ * * ç„¶è€Œï¼Œæœ‰ä¸€ç§éå¸¸ç‰¹æ®Šä¸”å¸¸è§çš„æƒ…å†µï¼Œæˆ‘ä»¬ä¸å…³å¿ƒï¼Œ * å› ä¸ºæ²¡æœ‰ä»»ä½•æ“ä½œè¦æ‰§è¡Œï¼šdentry ä»ç„¶åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œ * æ²¡æœ‰ &#x27;delete&#x27; æ“ä½œï¼Œå®ƒå·²ç»è¢«å¼•ç”¨å¹¶ä¸”å·²ç»åœ¨ LRU åˆ—è¡¨ä¸­ã€‚ * * æ³¨æ„ï¼ç”±äºæˆ‘ä»¬æ²¡æœ‰åŠ é”ï¼Œè¿™äº›å€¼ä¸æ˜¯ &quot;ç¨³å®šçš„&quot;ã€‚ * ä½†æ˜¯ï¼Œåªè¦åœ¨æˆ‘ä»¬é‡Šæ”¾å¼•ç”¨ä¹‹åçš„æŸä¸ªæ—¶åˆ»ï¼Œ * dentry è¢«å“ˆå¸Œå¹¶ä¸”æ ‡å¿—å…·æœ‰æ­£ç¡®çš„å€¼å°±è¶³å¤Ÿäº†ã€‚ * å…¶ä»–çš„ dentry ä½¿ç”¨è€…å¯èƒ½é‡æ–°è·å–å¯¹ dentry çš„å¼•ç”¨å¹¶æ›´æ”¹å®ƒï¼Œ * ä½†æ˜¯æˆ‘ä»¬çš„å·¥ä½œå·²ç»å®Œæˆ - æˆ‘ä»¬å¯ä»¥ä¿ç•™å…·æœ‰é›¶å¼•ç”¨è®¡æ•°çš„ dentryã€‚ * * ç„¶è€Œï¼Œæœ‰ä¸¤ç§æƒ…å†µä¸‹æˆ‘ä»¬åº”è¯¥é”€æ¯ dentryã€‚ * 1. å½“æ–­å¼€è¿æ¥çš„ dentry çš„å¼•ç”¨è®¡æ•°è¾¾åˆ°é›¶æ—¶ï¼Œç«‹å³é‡Šæ”¾ã€‚ * 2. å¦‚æœä¸åº”ç¼“å­˜ dentryï¼Œåˆ™é‡Šæ”¾å®ƒä»¬ã€‚ */ smp_rmb(); d_flags = READ_ONCE(dentry-&gt;d_flags); d_flags &amp;= DCACHE_REFERENCED | DCACHE_LRU_LIST | DCACHE_DISCONNECTED | DCACHE_DONTCACHE; /* æ²¡æœ‰è¦æ‰§è¡Œçš„æ“ä½œï¼Ÿé‡Šæ”¾å¼•ç”¨è®¡æ•°å°±æ˜¯æˆ‘ä»¬æ‰€éœ€è¦çš„ï¼Ÿ */ if (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) &amp;&amp; !d_unhashed(dentry)) return true; /* * ä¸æ˜¯å¿«é€Ÿå¸¸è§„æƒ…å†µï¼Ÿè·å–é”ã€‚æˆ‘ä»¬å·²ç»å‡å°‘äº†å¼•ç”¨è®¡æ•°ï¼Œ * ä½†åœ¨è·å–é”ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦é‡æ–°æ£€æŸ¥æƒ…å†µã€‚ */ spin_lock(&amp;dentry-&gt;d_lock); /* * æ˜¯å¦æœ‰å…¶ä»–äººåœ¨æ­¤æœŸé—´è·å–äº†å¯¹å®ƒçš„å¼•ç”¨ï¼Œæˆ‘ä»¬ä¸å†æ˜¯æœ€åä¸€ä¸ªç”¨æˆ·ï¼Ÿ * æˆ–è€…ï¼Œå…¶ä»–äººå¯èƒ½å·²ç»é”€æ¯å®ƒå¹¶æ ‡è®°ä¸ºæ— æ•ˆã€‚æ— è®ºå“ªç§æƒ…å†µï¼Œæˆ‘ä»¬éƒ½ä¸éœ€è¦åšå…¶ä»–æ“ä½œã€‚ */ if (dentry-&gt;d_lockref.count) &#123; spin_unlock(&amp;dentry-&gt;d_lock); return true; &#125; /* * é‡æ–°è·å–æˆ‘ä»¬ä¹è§‚åœ°é‡Šæ”¾çš„å¼•ç”¨ã€‚æˆ‘ä»¬æŒæœ‰é”ï¼Œå¹¶ä¸”åˆšåˆšæµ‹è¯•è¿‡è®¡æ•°ä¸ºé›¶ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†å…¶è®¾ç½®ä¸º1ã€‚ */ dentry-&gt;d_lockref.count = 1; return false;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// dput - é‡Šæ”¾ä¸€ä¸ªdentry// @dentry: è¦é‡Šæ”¾çš„dentry// é‡Šæ”¾ä¸€ä¸ªdentryã€‚è¿™å°†ä¼šé™ä½ä½¿ç”¨è®¡æ•°ï¼Œå¦‚æœé€‚å½“çš„è¯ï¼Œ// ä¼šè°ƒç”¨dentryçš„unlinkæ–¹æ³•ï¼ŒåŒæ—¶å°†å…¶ä»é˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œå¹¶é‡Šæ”¾å…¶èµ„æºã€‚// å¦‚æœçˆ¶dentryä¹Ÿè¢«å®‰æ’é‡Šæ”¾ï¼Œå®ƒä»¬ä¹Ÿå¯èƒ½ç°åœ¨è¢«åˆ é™¤ã€‚void dput(struct dentry *dentry)&#123; while (dentry) &#123; might_sleep(); // å¯èƒ½ä¼šä½¿å½“å‰ä»»åŠ¡è¿›å…¥ç¡çœ çŠ¶æ€ rcu_read_lock(); // è¯»å–RCUé” if (likely(fast_dput(dentry))) &#123; // å¦‚æœèƒ½å¿«é€Ÿé‡Šæ”¾dentry rcu_read_unlock(); // è§£é”RCU return; &#125; // æ…¢é€Ÿæƒ…å†µï¼šæ­¤æ—¶å·²ç»æŒæœ‰dentryé” rcu_read_unlock(); // è§£é”RCU if (likely(retain_dentry(dentry))) &#123; // å¦‚æœèƒ½ä¿ç•™dentry spin_unlock(&amp;dentry-&gt;d_lock); // è§£é”dentry return; &#125; dentry = dentry_kill(dentry); // æ€æ­»dentry &#125;&#125;EXPORT_SYMBOL(dput); // å¯¼å‡ºdputç¬¦å·static void __dput_to_list(struct dentry *dentry, struct list_head list)__must_hold(&amp;dentry-&gt;d_lock) // å¿…é¡»æŒæœ‰dentryé”&#123; if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; // å¦‚æœdentryåœ¨æ”¶ç¼©åˆ—è¡¨ä¸­ --dentry-&gt;d_lockref.count; // å‡å°‘dentryçš„é”å¼•ç”¨è®¡æ•° &#125; else &#123; if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) // å¦‚æœdentryåœ¨LRUåˆ—è¡¨ä¸­ d_lru_del(dentry); // ä»LRUåˆ—è¡¨ä¸­åˆ é™¤dentry if (!--dentry-&gt;d_lockref.count) // å¦‚æœdentryçš„é”å¼•ç”¨è®¡æ•°é™ä¸º0 d_shrink_add(dentry, list); // å°†dentryæ·»åŠ åˆ°æ”¶ç¼©åˆ—è¡¨ä¸­ &#125;&#125;void dput_to_list(struct dentry *dentry, struct list_head *list)&#123; rcu_read_lock(); // è¯»å–RCUé” if (likely(fast_dput(dentry))) &#123; // å¦‚æœèƒ½å¿«é€Ÿé‡Šæ”¾dentry rcu_read_unlock(); // è§£é”RCU return; &#125; rcu_read_unlock(); // è§£é”RCU if (!retain_dentry(dentry)) // å¦‚æœä¸èƒ½ä¿ç•™dentry __dput_to_list(dentry, list); // å°†dentryæ·»åŠ åˆ°åˆ—è¡¨ä¸­ spin_unlock(&amp;dentry-&gt;d_lock); // è§£é”dentry&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* This must be called with d_lock held *//* å¿…é¡»åœ¨æŒæœ‰ d_lock é”çš„æƒ…å†µä¸‹è°ƒç”¨ */static inline void __dget_dlock(struct dentry *dentry)&#123; dentry-&gt;d_lockref.count++;&#125;static inline void __dget(struct dentry *dentry)&#123; lockref_get(&amp;dentry-&gt;d_lockref);&#125;/* è·å–çˆ¶ç›®å½•çš„ dentry ç»“æ„ä½“ */struct dentry *dget_parent(struct dentry *dentry)&#123; int gotref; struct dentry *ret; unsigned seq; /* * Do optimistic parent lookup without any * locking. */ rcu_read_lock(); seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); /* å¼€å§‹è¯»å–åºåˆ—è®¡æ•°å™¨ */ ret = READ_ONCE(dentry-&gt;d_parent); /* è¯»å–çˆ¶ç›®å½•çš„ dentry */ gotref = lockref_get_not_zero(&amp;ret-&gt;d_lockref); /* è·å–çˆ¶ç›®å½•çš„å¼•ç”¨è®¡æ•° */ rcu_read_unlock(); if (likely(gotref)) &#123; if (!read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) /* æ£€æŸ¥åºåˆ—è®¡æ•°å™¨æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æœä¸æ­£ç¡®åˆ™é‡è¯• */ return ret; /* è¿”å›çˆ¶ç›®å½•çš„ dentry */ dput(ret); /* å‡å°‘çˆ¶ç›®å½•çš„å¼•ç”¨è®¡æ•° */ &#125;repeat: /* * Don&#x27;t need rcu_dereference because we re-check it was correct under * the lock. */ rcu_read_lock(); ret = dentry-&gt;d_parent; /* é‡æ–°è¯»å–çˆ¶ç›®å½•çš„ dentry */ spin_lock(&amp;ret-&gt;d_lock); /* è·å–çˆ¶ç›®å½•çš„é” */ if (unlikely(ret != dentry-&gt;d_parent)) &#123; /* æ£€æŸ¥çˆ¶ç›®å½•çš„ dentry æ˜¯å¦å‘ç”Ÿå˜åŒ– */ spin_unlock(&amp;ret-&gt;d_lock); rcu_read_unlock(); goto repeat; /* å¦‚æœå‘ç”Ÿå˜åŒ–ï¼Œåˆ™é‡è¯• */ &#125; rcu_read_unlock(); BUG_ON(!ret-&gt;d_lockref.count); /* æ£€æŸ¥çˆ¶ç›®å½•çš„å¼•ç”¨è®¡æ•°æ˜¯å¦ä¸ºé›¶ */ ret-&gt;d_lockref.count++; /* å¢åŠ çˆ¶ç›®å½•çš„å¼•ç”¨è®¡æ•° */ spin_unlock(&amp;ret-&gt;d_lock); /* é‡Šæ”¾çˆ¶ç›®å½•çš„é” */ return ret; /* è¿”å›çˆ¶ç›®å½•çš„ dentry */&#125;EXPORT_SYMBOL(dget_parent); /* å¯¼å‡º dget_parent å‡½æ•°ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static struct dentry * __d_find_any_alias(struct inode *inode)&#123; struct dentry *alias; if (hlist_empty(&amp;inode-&gt;i_dentry)) return NULL; alias = hlist_entry(inode-&gt;i_dentry.first, struct dentry, d_u.d_alias); __dget(alias); /* å¢åŠ åˆ«åçš„å¼•ç”¨è®¡æ•° */ return alias; /* è¿”å›åˆ«åçš„ dentry */&#125;/** * d_find_any_alias - find any alias for a given inode * @inode: inode to find an alias for * * If any aliases exist for the given inode, take and return a * reference for one of them. If no aliases exist, return %NULL. *//* æŸ¥æ‰¾ç»™å®š inode çš„ä»»ä½•åˆ«å */struct dentry *d_find_any_alias(struct inode *inode)&#123; struct dentry *de; spin_lock(&amp;inode-&gt;i_lock); /* è·å– inode çš„é” */ de = __d_find_any_alias(inode); /* æŸ¥æ‰¾ä»»ä½•åˆ«åçš„ dentry */ spin_unlock(&amp;inode-&gt;i_lock); /* é‡Šæ”¾ inode çš„é” */ return de; /* è¿”å›æ‰¾åˆ°çš„åˆ«åçš„ dentry */&#125;EXPORT_SYMBOL(d_find_any_alias); /* å¯¼å‡º d_find_any_alias å‡½æ•°ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨ */static struct dentry *__d_find_alias(struct inode *inode)&#123; struct dentry *alias; if (S_ISDIR(inode-&gt;i_mode)) return __d_find_any_alias(inode); /* å¯¹äºç›®å½•ç±»å‹çš„ inodeï¼ŒæŸ¥æ‰¾ä»»ä½•åˆ«åçš„ dentry */ hlist_for_each_entry(alias, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; spin_lock(&amp;alias-&gt;d_lock); /* è·å–åˆ«åçš„é” */ if (!d_unhashed(alias)) &#123; /* æ£€æŸ¥åˆ«åæ˜¯å¦å·²ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤ */ __dget_dlock(alias); /* å¢åŠ åˆ«åçš„å¼•ç”¨è®¡æ•° */ spin_unlock(&amp;alias-&gt;d_lock); /* é‡Šæ”¾åˆ«åçš„é” */ return alias; /* è¿”å›æ‰¾åˆ°çš„åˆ«åçš„ dentry */ &#125; spin_unlock(&amp;alias-&gt;d_lock); /* é‡Šæ”¾åˆ«åçš„é” */ &#125; return NULL; /* å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•åˆ«åï¼Œåˆ™è¿”å› NULL */&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * d_find_alias - è·å– inode çš„å“ˆå¸Œåˆ«å * @inode: ç›®æ ‡ inode * * å¦‚æœ inode æœ‰ä¸€ä¸ªå“ˆå¸Œåˆ«åï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªç›®å½•å¹¶ä¸”æœ‰ä»»ä½•åˆ«åï¼Œ * è·å–å¹¶è¿”å›åˆ«åçš„å¼•ç”¨ã€‚å¦åˆ™è¿”å› NULLã€‚ * æ³¨æ„ï¼Œå¦‚æœ inode æ˜¯ä¸€ä¸ªç›®å½•ï¼Œå®ƒåªèƒ½æœ‰ä¸€ä¸ªåˆ«åï¼Œ * åªæœ‰å½“å®ƒæ²¡æœ‰å­ç›®å½•ï¼Œæˆ–è€…æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•ï¼Œæˆ–è€…æ˜¯ç›®å½•è¢«é‡å‘½åä¸” d_revalidate æ˜¯ç¬¬ä¸€ä¸ª vfs æ“ä½œæ¥æ³¨æ„åˆ°æ—¶ï¼Œå®ƒæ‰èƒ½æ²¡æœ‰å“ˆå¸Œåˆ«åã€‚ * * å¦‚æœ inode æœ‰ IS_ROOTã€DCACHE_DISCONNECTED åˆ«åï¼Œåˆ™ä¼˜å…ˆé€‰æ‹©å…¶ä»–å“ˆå¸Œåˆ«åã€‚ */struct dentry *d_find_alias(struct inode *inode)&#123; struct dentry *de = NULL; if (!hlist_empty(&amp;inode-&gt;i_dentry)) &#123; spin_lock(&amp;inode-&gt;i_lock); /* è·å– inode çš„é” */ de = __d_find_alias(inode); /* æŸ¥æ‰¾ inode çš„åˆ«å */ spin_unlock(&amp;inode-&gt;i_lock); /* é‡Šæ”¾ inode çš„é” */ &#125; return de; /* è¿”å›æ‰¾åˆ°çš„åˆ«åçš„ dentry */&#125;EXPORT_SYMBOL(d_find_alias); /* å¯¼å‡º d_find_alias å‡½æ•°ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨ *//* * è°ƒç”¨è€…å¿…é¡»æŒæœ‰ rcu_read_lock()ï¼Œå¹¶ç¡®ä¿åœ¨ rcu_read_unlock() ä¹‹å‰ inode ä¸ä¼šè¢«é‡Šæ”¾ã€‚ */struct dentry *d_find_alias_rcu(struct inode *inode)&#123; struct hlist_head *l = &amp;inode-&gt;i_dentry; struct dentry *de = NULL; spin_lock(&amp;inode-&gt;i_lock); /* è·å– inode çš„é” */ // -&gt;i_dentry å’Œ -&gt;i_rcu æ˜¯æ”¾åœ¨ä¸€èµ·çš„ï¼Œä½†åªæœ‰åœ¨è®¾ç½®äº† I_FREEING æ—¶æ‰ä¼šä½¿ç”¨åè€…ï¼Œè¿™æ„å‘³ç€æ²¡æœ‰å‰©ä½™çš„åˆ«å if (likely(!(inode-&gt;i_state &amp; I_FREEING) &amp;&amp; !hlist_empty(l))) &#123; if (S_ISDIR(inode-&gt;i_mode)) &#123; de = hlist_entry(l-&gt;first, struct dentry, d_u.d_alias); &#125; else &#123; hlist_for_each_entry(de, l, d_u.d_alias) if (!d_unhashed(de)) break; &#125; &#125; spin_unlock(&amp;inode-&gt;i_lock); /* é‡Šæ”¾ inode çš„é” */ return de; /* è¿”å›æ‰¾åˆ°çš„åˆ«åçš„ dentry */&#125;/* * å°è¯•æ¸…é™¤ä¸è¯¥ inode å…³è”çš„ dentryã€‚ * è­¦å‘Šï¼šæ‚¨å¿…é¡»æ‹¥æœ‰å¯¹ inode çš„å¼•ç”¨ã€‚ */void d_prune_aliases(struct inode *inode)&#123; struct dentry *dentry;restart: spin_lock(&amp;inode-&gt;i_lock); /* è·å– inode çš„é” */ hlist_for_each_entry(dentry, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; spin_lock(&amp;dentry-&gt;d_lock); /* è·å– dentry çš„é” */ if (!dentry-&gt;d_lockref.count) &#123; struct dentry *parent = lock_parent(dentry); /* è·å–çˆ¶ç›®å½•çš„ dentry */ if (likely(!dentry-&gt;d_lockref.count)) &#123; __dentry_kill(dentry); /* æ¸…é™¤ dentry */ dput(parent); goto restart; &#125; if (parent) spin_unlock(&amp;parent-&gt;d_lock); /* é‡Šæ”¾çˆ¶ç›®å½•çš„é” */ &#125; spin_unlock(&amp;dentry-&gt;d_lock); /* é‡Šæ”¾ dentry çš„é” */ &#125; spin_unlock(&amp;inode-&gt;i_lock); /* é‡Šæ”¾ inode çš„é” */&#125;EXPORT_SYMBOL(d_prune_aliases); /* å¯¼å‡º d_prune_aliases å‡½æ•°ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨ */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * Lock a dentry from shrink list. * Called under rcu_read_lock() and dentry-&gt;d_lock; the former * guarantees that nothing we access will be freed under us. * Note that dentry is *not* protected from concurrent dentry_kill(), * d_delete(), etc. * * Return false if dentry has been disrupted or grabbed, leaving * the caller to kick it off-list. Otherwise, return true and have * that dentry&#x27;s inode and parent both locked. */static bool shrink_lock_dentry(struct dentry *dentry)&#123; // æ£€æŸ¥dentryçš„å¼•ç”¨è®¡æ•°æ˜¯å¦éé›¶ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è¿”å›false if (dentry-&gt;d_lockref.count) return false; struct inode *inode; struct dentry *parent; inode = dentry-&gt;d_inode; // å¦‚æœdentryçš„inodeå­˜åœ¨ï¼Œå¹¶ä¸”æ— æ³•è·å–inodeçš„è‡ªæ—‹é”ï¼Œåˆ™é‡Šæ”¾dentryçš„è‡ªæ—‹é”ï¼Œ // è·å–inodeçš„è‡ªæ—‹é”ï¼Œå†è·å–dentryçš„è‡ªæ—‹é”ï¼Œç„¶åæ£€æŸ¥dentryçš„å¼•ç”¨è®¡æ•°æ˜¯å¦éé›¶ï¼Œ // å¦‚æœæ˜¯ï¼Œåˆ™è·³è½¬åˆ°outæ ‡ç­¾å¤„ï¼Œå¦åˆ™æ£€æŸ¥inodeæ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è·³è½¬åˆ°outæ ‡ç­¾å¤„ if (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock))) &#123; spin_unlock(&amp;dentry-&gt;d_lock); spin_lock(&amp;inode-&gt;i_lock); spin_lock(&amp;dentry-&gt;d_lock); if (unlikely(dentry-&gt;d_lockref.count)) goto out; /* changed inode means that somebody had grabbed it */ if (unlikely(inode != dentry-&gt;d_inode)) goto out; &#125; parent = dentry-&gt;d_parent; // å¦‚æœdentryæ˜¯æ ¹èŠ‚ç‚¹ï¼Œæˆ–è€…å¯ä»¥è·å–åˆ°çˆ¶èŠ‚ç‚¹çš„è‡ªæ—‹é”ï¼Œåˆ™è¿”å›true if (IS_ROOT(dentry) || likely(spin_trylock(&amp;parent-&gt;d_lock))) return true; spin_unlock(&amp;dentry-&gt;d_lock); spin_lock(&amp;parent-&gt;d_lock); // æ£€æŸ¥çˆ¶èŠ‚ç‚¹æ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™é‡Šæ”¾çˆ¶èŠ‚ç‚¹çš„è‡ªæ—‹é”ï¼Œè·å–dentryçš„è‡ªæ—‹é”ï¼Œç„¶åè·³è½¬åˆ°outæ ‡ç­¾å¤„ if (unlikely(parent != dentry-&gt;d_parent)) &#123; spin_unlock(&amp;parent-&gt;d_lock); spin_lock(&amp;dentry-&gt;d_lock); goto out; &#125; spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); // æ£€æŸ¥dentryçš„å¼•ç”¨è®¡æ•°æ˜¯å¦éé›¶ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è¿”å›true if (likely(!dentry-&gt;d_lockref.count)) return true; spin_unlock(&amp;parent-&gt;d_lock);out: if (inode) spin_unlock(&amp;inode-&gt;i_lock); return false;&#125; 1234567891011121314151617181920212223242526272829303132333435void shrink_dentry_list(struct list_head *list)&#123; while (!list_empty(list)) &#123; struct dentry *dentry, *parent; // ä»åˆ—è¡¨ä¸­è·å–æœ€åä¸€ä¸ªdentryï¼Œå¹¶è·å–å…¶è‡ªæ—‹é” dentry = list_entry(list-&gt;prev, struct dentry, d_lru); spin_lock(&amp;dentry-&gt;d_lock); rcu_read_lock(); // å°è¯•é”å®šdentryçš„inodeå’Œçˆ¶èŠ‚ç‚¹ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æˆåŠŸ if (!shrink_lock_dentry(dentry)) &#123; bool can_free = false; rcu_read_unlock(); // ä»æ”¶ç¼©åˆ—è¡¨ä¸­åˆ é™¤dentry d_shrink_del(dentry); // æ£€æŸ¥dentryçš„å¼•ç”¨è®¡æ•°æ˜¯å¦å°äº0ï¼Œä»¥åŠæ˜¯å¦å¯ä»¥é‡Šæ”¾ if (dentry-&gt;d_lockref.count &lt; 0) can_free = dentry-&gt;d_flags &amp; DCACHE_MAY_FREE; spin_unlock(&amp;dentry-&gt;d_lock); // å¦‚æœå¯ä»¥é‡Šæ”¾ï¼Œåˆ™é‡Šæ”¾dentry if (can_free) dentry_free(dentry); continue; &#125; rcu_read_unlock(); // ä»æ”¶ç¼©åˆ—è¡¨ä¸­åˆ é™¤dentry d_shrink_del(dentry); parent = dentry-&gt;d_parent; // å¦‚æœdentryçš„çˆ¶èŠ‚ç‚¹ä¸æ˜¯å®ƒè‡ªå·±ï¼Œåˆ™å°†çˆ¶èŠ‚ç‚¹æ·»åŠ å›åˆ—è¡¨ä¸­ if (parent != dentry) __dput_to_list(parent, list); // é”€æ¯dentry __dentry_kill(dentry); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344static enum lru_status dentry_lru_isolate(struct list_head *item, struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)&#123; struct list_head *freeable = arg; struct dentry *dentry = container_of(item, struct dentry, d_lru); // å°è¯•è·å–dentryçš„é”ï¼Œå¦‚æœè·å–å¤±è´¥åˆ™è·³è¿‡ if (!spin_trylock(&amp;dentry-&gt;d_lock)) return LRU_SKIP; // å¦‚æœdentryæœ‰å¼•ç”¨è®¡æ•°ï¼Œè¡¨ç¤ºä»åœ¨ä½¿ç”¨ä¸­ï¼Œä»LRUä¸­ç§»é™¤ if (dentry-&gt;d_lockref.count) &#123; d_lru_isolate(lru, dentry); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED; &#125; // å¦‚æœdentryè¢«æ ‡è®°ä¸ºå·²å¼•ç”¨ï¼Œåˆ™æ¸…é™¤æ ‡è®°å¹¶è¿›è¡ŒLRUæ—‹è½¬ if (dentry-&gt;d_flags &amp; DCACHE_REFERENCED) &#123; dentry-&gt;d_flags &amp;= ~DCACHE_REFERENCED; spin_unlock(&amp;dentry-&gt;d_lock); /* * åˆ—è¡¨çš„ç§»åŠ¨ç”±é€šç”¨çš„LRUä»£ç å®Œæˆã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å·²ç»é‡Šæ”¾äº†dentry-&gt;d_lockï¼Œ * ä½†ä¿æŒäº†lrué”ã€‚è¿™æ ·åšæ˜¯å®‰å…¨çš„ï¼Œå› ä¸ºå³ä½¿åŒæ—¶æŒæœ‰ä¸¤ä¸ªé”ï¼Œæ‰€æœ‰çš„åˆ—è¡¨ç§»åŠ¨ * éƒ½å—åˆ°lrué”çš„ä¿æŠ¤ã€‚ * * è¿™æ˜¯å› ä¸ºæ‰€æœ‰çš„LRUç®¡ç†å‡½æ•°éƒ½é€šè¿‡LRU APIè°ƒç”¨ï¼ˆå¦‚list_lru_addå’Œlist_lru_delï¼‰ * è¿›è¡Œä¸­ä»‹ã€‚æ­¤æ–‡ä»¶ä¸­çš„åˆ—è¡¨ç§»åŠ¨åªä¼šé€šè¿‡è¿™äº›å‡½æ•°æˆ–é€šè¿‡ä»LRU APIè°ƒç”¨çš„å›è°ƒå‡½æ•° * ï¼ˆå¦‚æ­¤å¤„çš„å›è°ƒå‡½æ•°ï¼‰è¿›è¡Œã€‚ * * å”¯ä¸€çš„ä¾‹å¤–æ˜¯åƒshrink_dentry_listè¿™æ ·çš„å‡½æ•°ï¼Œä»¥åŠé¦–å…ˆæ£€æŸ¥DCACHE_SHRINK_LIST * æ ‡å¿—çš„ä»£ç ã€‚è¿™äº›å‡½æ•°ä¿è¯åªåœ¨æ­£ç¡®ä»ä¸»åˆ—è¡¨ä¸­éš”ç¦»åï¼Œä»…ä¸æä¾›çš„å †æ ˆåˆ—è¡¨è¿›è¡Œæ“ä½œã€‚ * å› æ­¤ï¼Œå®ƒå§‹ç»ˆæ˜¯å±€éƒ¨è®¿é—®ã€‚ */ return LRU_ROTATE; &#125; // å°†dentryç§»åŠ¨åˆ°å¯é‡Šæ”¾åˆ—è¡¨ä¸­ d_lru_shrink_move(lru, dentry, freeable); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED;&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * prune_dcache_sb - æ”¶ç¼©dcache * @sb: è¶…çº§å— * @sc: æ”¶ç¼©æ§åˆ¶å‚æ•°ï¼Œä¼ é€’ç»™list_lru_shrink_walk() * * å°è¯•é€šè¿‡@sc-&gt;nr_to_scanä¸ªæ¡ç›®æ¥æ”¶ç¼©è¶…çº§å—dcacheçš„LRUã€‚å½“æˆ‘ä»¬éœ€è¦æ›´å¤šå†…å­˜æ—¶ï¼Œ * ä»è¶…çº§å—æ”¶ç¼©å™¨å‡½æ•°è°ƒç”¨æ­¤å‡½æ•°ã€‚ * * å¦‚æœæ‰€æœ‰çš„dentryéƒ½åœ¨ä½¿ç”¨ä¸­ï¼Œæ­¤å‡½æ•°å¯èƒ½æ— æ³•é‡Šæ”¾ä»»ä½•èµ„æºã€‚ */long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)&#123; LIST_HEAD(dispose); long freed; freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc, dentry_lru_isolate, &amp;dispose); shrink_dentry_list(&amp;dispose); return freed;&#125;static enum lru_status dentry_lru_isolate_shrink(struct list_head *item, struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)&#123; struct list_head *freeable = arg; struct dentry *dentry = container_of(item, struct dentry, d_lru); // å°è¯•è·å–dentryçš„é”ï¼Œå¦‚æœè·å–å¤±è´¥åˆ™è·³è¿‡ if (!spin_trylock(&amp;dentry-&gt;d_lock)) return LRU_SKIP; // å°†dentryç§»åŠ¨åˆ°å¯é‡Šæ”¾åˆ—è¡¨ä¸­ d_lru_shrink_move(lru, dentry, freeable); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * prune_dcache_sb - æ”¶ç¼©dcache * @sb: è¶…çº§å— * @sc: æ”¶ç¼©æ§åˆ¶å‚æ•°ï¼Œä¼ é€’ç»™list_lru_shrink_walk() * * å°è¯•é€šè¿‡@sc-&gt;nr_to_scanä¸ªæ¡ç›®æ¥æ”¶ç¼©è¶…çº§å—dcacheçš„LRUã€‚å½“æˆ‘ä»¬éœ€è¦æ›´å¤šå†…å­˜æ—¶ï¼Œ * ä»è¶…çº§å—æ”¶ç¼©å™¨å‡½æ•°è°ƒç”¨æ­¤å‡½æ•°ã€‚ * * å¦‚æœæ‰€æœ‰çš„dentryéƒ½åœ¨ä½¿ç”¨ä¸­ï¼Œæ­¤å‡½æ•°å¯èƒ½æ— æ³•é‡Šæ”¾ä»»ä½•èµ„æºã€‚ */long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)&#123; // åˆ›å»ºä¸€ä¸ªé“¾è¡¨å¤´ç”¨äºå­˜å‚¨å¾…é‡Šæ”¾çš„dentry LIST_HEAD(dispose); long freed; // è°ƒç”¨list_lru_shrink_walkå‡½æ•°æ¥éå†è¶…çº§å—çš„dentry LRUåˆ—è¡¨ï¼Œå¹¶å°†æ»¡è¶³æ¡ä»¶çš„dentryæ·»åŠ åˆ°disposeé“¾è¡¨ä¸­ freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc, dentry_lru_isolate, &amp;dispose); // è°ƒç”¨shrink_dentry_listå‡½æ•°æ¥é‡Šæ”¾disposeé“¾è¡¨ä¸­çš„dentryèµ„æº shrink_dentry_list(&amp;dispose); return freed;&#125;static enum lru_status dentry_lru_isolate_shrink(struct list_head *item, struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)&#123; // å°†ä¼ å…¥çš„å‚æ•°è½¬æ¢ä¸ºå¯¹åº”çš„ç±»å‹ struct list_head *freeable = arg; struct dentry *dentry = container_of(item, struct dentry, d_lru); // å°è¯•è·å–dentryçš„é”ï¼Œå¦‚æœè·å–å¤±è´¥åˆ™è·³è¿‡ if (!spin_trylock(&amp;dentry-&gt;d_lock)) return LRU_SKIP; // å°†dentryç§»åŠ¨åˆ°å¯é‡Šæ”¾åˆ—è¡¨ä¸­ d_lru_shrink_move(lru, dentry, freeable); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED;&#125; 1234567891011121314151617181920212223242526/** * shrink_dcache_sb - æ”¶ç¼©æŒ‡å®šè¶…çº§å—çš„dcache * @sb: è¶…çº§å— * * æ”¶ç¼©æŒ‡å®šè¶…çº§å—çš„dcacheã€‚åœ¨å¸è½½æ–‡ä»¶ç³»ç»Ÿä¹‹å‰ï¼Œç”¨äºé‡Šæ”¾dcacheã€‚ */void shrink_dcache_sb(struct super_block *sb)&#123; // å¾ªç¯æ‰§è¡Œï¼Œç›´åˆ°æ»¡è¶³é€€å‡ºæ¡ä»¶ do &#123; LIST_HEAD(dispose); // æ£€æŸ¥è¶…çº§å—çš„dentry LRUåˆ—è¡¨æ˜¯å¦è¿˜æœ‰å‰©ä½™çš„dentry if (list_lru_count(&amp;sb-&gt;s_dentry_lru) &gt; 0) &#123; // è°ƒç”¨list_lru_shrink_walkå‡½æ•°æ¥æ”¶ç¼©è¶…çº§å—çš„dcache // å°†æ»¡è¶³æ¡ä»¶çš„dentryæ·»åŠ åˆ°disposeé“¾è¡¨ä¸­ freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc, dentry_lru_isolate, &amp;dispose); // è°ƒç”¨shrink_dentry_listå‡½æ•°æ¥é‡Šæ”¾disposeé“¾è¡¨ä¸­çš„dentryèµ„æº shrink_dentry_list(&amp;dispose); &#125; &#125; while (list_lru_count(&amp;sb-&gt;s_dentry_lru) &gt; 0); // å¯¼å‡ºshrink_dcache_sbå‡½æ•°çš„ç¬¦å· EXPORT_SYMBOL(shrink_dcache_sb);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * enum d_walk_ret - æ ‘éå†æœŸé—´çš„æ“ä½œ * @D_WALK_CONTINUE: ç»§ç»­éå† * @D_WALK_QUIT: ç»ˆæ­¢éå† * @D_WALK_NORETRY: éœ€è¦é‡è¯•æ—¶ç»ˆæ­¢éå† * @D_WALK_SKIP: è·³è¿‡å½“å‰dentryåŠå…¶å­èŠ‚ç‚¹ */enum d_walk_ret &#123; D_WALK_CONTINUE, D_WALK_QUIT, D_WALK_NORETRY, D_WALK_SKIP,&#125;;/** * d_walk - éå†dentryæ ‘ * @parent: éå†çš„èµ·å§‹dentry * @data: ä¼ é€’ç»™enter()å’Œfinish()çš„æ•°æ® * @enter: è¿›å…¥dentryæ—¶çš„å›è°ƒå‡½æ•° * * åœ¨è°ƒç”¨enter()å›è°ƒå‡½æ•°æ—¶ï¼Œä¼šæŒæœ‰d_locké”ã€‚ */static void d_walk(struct dentry *parent, void *data, enum d_walk_ret (*enter)(void *, struct dentry *))&#123; struct dentry *this_parent; struct list_head *next; unsigned seq = 0; enum d_walk_ret ret; bool retry = true;again: read_seqbegin_or_lock(&amp;rename_lock, &amp;seq); this_parent = parent; spin_lock(&amp;this_parent-&gt;d_lock); ret = enter(data, this_parent); switch (ret) &#123; case D_WALK_CONTINUE: break; case D_WALK_QUIT: case D_WALK_SKIP: goto out_unlock; case D_WALK_NORETRY: retry = false; break; &#125;repeat: next = this_parent-&gt;d_subdirs.next;resume: while (next != &amp;this_parent-&gt;d_subdirs) &#123; struct list_head *tmp = next; struct dentry *dentry = list_entry(tmp, struct dentry, d_child); next = tmp-&gt;next; if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR)) continue; spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); ret = enter(data, dentry); switch (ret) &#123; case D_WALK_CONTINUE: break; case D_WALK_QUIT: spin_unlock(&amp;dentry-&gt;d_lock); goto out_unlock; case D_WALK_NORETRY: retry = false; break; case D_WALK_SKIP: spin_unlock(&amp;dentry-&gt;d_lock); continue; &#125; if (!list_empty(&amp;dentry-&gt;d_subdirs)) &#123; spin_unlock(&amp;this_parent-&gt;d_lock); spin_release(&amp;dentry-&gt;d_lock.dep_map, _RET_IP_); this_parent = dentry; spin_acquire(&amp;this_parent-&gt;d_lock.dep_map, 0, 1, _RET_IP_); goto repeat; &#125; spin_unlock(&amp;dentry-&gt;d_lock); &#125; /* * å½“å‰å±‚çº§éå†å®Œæˆï¼Œå‘ä¸Šå›æº¯å¹¶ç»§ç»­æœç´¢ã€‚ */ rcu_read_lock();ascend: if (this_parent != parent) &#123; struct dentry *child = this_parent; this_parent = child-&gt;d_parent; spin_unlock(&amp;child-&gt;d_lock); spin_lock(&amp;this_parent-&gt;d_lock); /* * å¦‚æœå­˜åœ¨é‡å‘½åæ“ä½œï¼Œå¯èƒ½ä¼šå›åˆ°é”™è¯¯çš„çˆ¶èŠ‚ç‚¹ã€‚ */ if (need_seqretry(&amp;rename_lock, seq)) goto rename_retry; /* * è¿›å…¥ä¸‹ä¸€ä¸ªä»ç„¶å­˜åœ¨çš„å…„å¼ŸèŠ‚ç‚¹ã€‚ */ do &#123; next = child-&gt;d_child.next; if (next == &amp;this_parent-&gt;d_subdirs) goto ascend; child = list_entry(next, struct dentry, d_child); &#125; while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)); rcu_read_unlock(); goto resume; &#125; if (need_seqretry(&amp;rename_lock, seq)) goto rename_retry; rcu_read_unlock();out_unlock: spin_unlock(&amp;this_parent-&gt;d_lock); done_seqretry(&amp;rename_lock, seq); return;rename_retry: spin_unlock(&amp;this_parent-&gt;d_lock); rcu_read_unlock(); BUG_ON(seq &amp; 1); if (!retry) return; seq = 1; goto again;&#125; 1234567891011121314151617181920struct check_mount &#123; struct vfsmount *mnt; // æ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹çš„æŒ‡é’ˆ unsigned int mounted; // è¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å·²æŒ‚è½½çš„æ ‡å¿—ä½&#125;;static enum d_walk_ret path_check_mount(void *data, struct dentry *dentry)&#123; struct check_mount *info = data; // å°†ä¼ å…¥çš„dataå‚æ•°è½¬æ¢ä¸ºcheck_mountç»“æ„ä½“æŒ‡é’ˆ struct path path = &#123; .mnt = info-&gt;mnt, .dentry = dentry &#125;; // åˆ›å»ºpathç»“æ„ä½“ï¼Œè¡¨ç¤ºæ–‡ä»¶è·¯å¾„ if (likely(!d_mountpoint(dentry))) // æ£€æŸ¥ç»™å®šçš„dentryæ˜¯å¦ä¸ºæŒ‚è½½ç‚¹ return D_WALK_CONTINUE; // å¦‚æœä¸æ˜¯æŒ‚è½½ç‚¹ï¼Œåˆ™ç»§ç»­éå† if (__path_is_mountpoint(&amp;path)) &#123; // æ£€æŸ¥ç»™å®šçš„è·¯å¾„æ˜¯å¦ä¸ºæŒ‚è½½ç‚¹ info-&gt;mounted = 1; // å¦‚æœæ˜¯æŒ‚è½½ç‚¹ï¼Œåˆ™å°†mountedæ ‡å¿—ä½è®¾ç½®ä¸º1 return D_WALK_QUIT; // å¹¶åœæ­¢éå† &#125; return D_WALK_CONTINUE; // å¦‚æœä¸æ˜¯æŒ‚è½½ç‚¹ï¼Œåˆ™ç»§ç»­éå†&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * path_has_submounts - æ£€æŸ¥å½“å‰å‘½åç©ºé—´ä¸­çš„çˆ¶è·¯å¾„æˆ–å…¶å­ç›®å½•æ˜¯å¦åŒ…å«æŒ‚è½½ç‚¹ã€‚ * @parent: è¦æ£€æŸ¥çš„è·¯å¾„ã€‚ * * å¦‚æœçˆ¶è·¯å¾„æˆ–å…¶å­ç›®å½•ä¸­åŒ…å«å½“å‰å‘½åç©ºé—´ä¸­çš„æŒ‚è½½ç‚¹ï¼Œåˆ™è¿”å›trueã€‚ */int path_has_submounts(const struct path *parent)&#123; struct check_mount data = &#123; .mnt = parent-&gt;mnt, .mounted = 0 &#125;; read_seqlock_excl(&amp;mount_lock); // è·å–mount_lockçš„è¯»å–é” d_walk(parent-&gt;dentry, &amp;data, path_check_mount); // éå†çˆ¶è·¯å¾„çš„dentryï¼Œå¹¶æ£€æŸ¥æ˜¯å¦åŒ…å«æŒ‚è½½ç‚¹ read_sequnlock_excl(&amp;mount_lock); // é‡Šæ”¾mount_lockçš„è¯»å–é” return data.mounted; // è¿”å›æ˜¯å¦å­˜åœ¨æŒ‚è½½ç‚¹çš„æ ‡å¿—ä½&#125;EXPORT_SYMBOL(path_has_submounts); // å¯¼å‡ºpath_has_submountsç¬¦å·ï¼Œä½¿å…¶å¯åœ¨å…¶ä»–æ¨¡å—ä¸­ä½¿ç”¨/* * Called by mount code to set a mountpoint and check if the mountpoint is * reachable (e.g. NFS can unhash a directory dentry and then the complete * subtree can become unreachable). * * Only one of d_invalidate() and d_set_mounted() must succeed. For * this reason take rename_lock and d_lock on dentry and ancestors. */int d_set_mounted(struct dentry *dentry)&#123; struct dentry *p; int ret = -ENOENT; write_seqlock(&amp;rename_lock); // è·å–rename_lockçš„å†™å…¥é” for (p = dentry-&gt;d_parent; !IS_ROOT(p); p = p-&gt;d_parent) &#123; /* Need exclusion wrt. d_invalidate() */ spin_lock(&amp;p-&gt;d_lock); // è·å–çˆ¶dentryçš„è‡ªæ—‹é” if (unlikely(d_unhashed(p))) &#123; // æ£€æŸ¥çˆ¶dentryæ˜¯å¦æœªå“ˆå¸Œ spin_unlock(&amp;p-&gt;d_lock); // å¦‚æœæœªå“ˆå¸Œï¼Œåˆ™é‡Šæ”¾è‡ªæ—‹é” goto out; // è·³è½¬åˆ°outæ ‡ç­¾å¤„ &#125; spin_unlock(&amp;p-&gt;d_lock); // é‡Šæ”¾çˆ¶dentryçš„è‡ªæ—‹é” &#125; spin_lock(&amp;dentry-&gt;d_lock); // è·å–å½“å‰dentryçš„è‡ªæ—‹é” if (!d_unlinked(dentry)) &#123; ret = -EBUSY; if (!d_mountpoint(dentry)) &#123; // æ£€æŸ¥å½“å‰dentryæ˜¯å¦ä¸ºæŒ‚è½½ç‚¹ dentry-&gt;d_flags |= DCACHE_MOUNTED; // è®¾ç½®å½“å‰dentryçš„æŒ‚è½½æ ‡å¿—ä½ ret = 0; &#125; &#125; spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾å½“å‰dentryçš„è‡ªæ—‹é”out: write_sequnlock(&amp;rename_lock); // é‡Šæ”¾rename_lockçš„å†™å…¥é” return ret; // è¿”å›æ“ä½œç»“æœ&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Search the dentry child list of the specified parent, * and move any unused dentries to the end of the unused * list for prune_dcache(). We descend to the next level * whenever the d_subdirs list is non-empty and continue * searching. * * It returns zero iff there are no unused children, * otherwise it returns the number of children moved to * the end of the unused list. This may not be the total * number of unused children, because select_parent can * drop the lock and return early due to latency * constraints. */struct select_data &#123; struct dentry *start; // èµ·å§‹dentry union &#123; long found; // æ‰¾åˆ°çš„æœªä½¿ç”¨çš„dentryæ•°é‡ struct dentry *victim; // å¾…å¤„ç†çš„dentry &#125;; struct list_head dispose; // å¾…å¤„ç†çš„dentryé“¾è¡¨&#125;;static enum d_walk_ret select_collect(void *_data, struct dentry *dentry)&#123; struct select_data *data = _data; enum d_walk_ret ret = D_WALK_CONTINUE; if (data-&gt;start == dentry) goto out; if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; // æ£€æŸ¥dentryæ˜¯å¦åœ¨æ”¶ç¼©åˆ—è¡¨ä¸­ data-&gt;found++; // å¢åŠ æ‰¾åˆ°çš„æœªä½¿ç”¨çš„dentryæ•°é‡ &#125; else &#123; if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) d_lru_del(dentry); // ä»LRUåˆ—è¡¨ä¸­åˆ é™¤dentry if (!dentry-&gt;d_lockref.count) &#123; // æ£€æŸ¥dentryçš„é”å¼•ç”¨è®¡æ•°æ˜¯å¦ä¸º0 d_shrink_add(dentry, &amp;data-&gt;dispose); // å°†dentryæ·»åŠ åˆ°å¾…å¤„ç†é“¾è¡¨ä¸­ data-&gt;found++; // å¢åŠ æ‰¾åˆ°çš„æœªä½¿ç”¨çš„dentryæ•°é‡ &#125; &#125; /* * å¦‚æœæˆ‘ä»¬æ‰¾åˆ°äº†ä¸€äº›æœªä½¿ç”¨çš„dentryï¼Œæˆ‘ä»¬å¯ä»¥è¿”å›ç»™è°ƒç”¨è€…ï¼ˆè¿™ç¡®ä¿äº†å‰è¿›ï¼‰ã€‚ * æˆ‘ä»¬å°†ä¼šå›æ¥æ‰¾åˆ°å‰©ä¸‹çš„ã€‚ */ if (!list_empty(&amp;data-&gt;dispose)) ret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;out: return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243static enum d_walk_ret select_collect2(void *_data, struct dentry *dentry)&#123; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘ select_data ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œå¹¶å°† _data å¼ºåˆ¶è½¬æ¢ä¸º select_data ç±»å‹ struct select_data *data = _data; // å®šä¹‰ä¸€ä¸ªæšä¸¾ç±»å‹çš„å˜é‡ retï¼Œå¹¶åˆå§‹åŒ–ä¸º D_WALK_CONTINUE enum d_walk_ret ret = D_WALK_CONTINUE; // å¦‚æœ data-&gt;start ç­‰äºå½“å‰éå†åˆ°çš„ dentryï¼Œåˆ™è·³è½¬åˆ° out æ ‡ç­¾å¤„ if (data-&gt;start == dentry) goto out; // å¦‚æœ dentry çš„ d_flags ä¸­åŒ…å« DCACHE_SHRINK_LIST æ ‡å¿—ä½ if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; // å¦‚æœ dentry çš„ d_lockref.count ä¸º 0 if (!dentry-&gt;d_lockref.count) &#123; // è·å– RCU è¯»é” rcu_read_lock(); // å°†å½“å‰çš„ dentry èµ‹å€¼ç»™ data-&gt;victim data-&gt;victim = dentry; // è¿”å› D_WALK_QUITï¼Œè¡¨ç¤ºéå†ç»“æŸ return D_WALK_QUIT; &#125; &#125; else &#123; // å¦‚æœ dentry çš„ d_flags ä¸­åŒ…å« DCACHE_LRU_LIST æ ‡å¿—ä½ if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) // ä» LRU åˆ—è¡¨ä¸­åˆ é™¤å½“å‰çš„ dentry d_lru_del(dentry); // å¦‚æœ dentry çš„ d_lockref.count ä¸º 0 if (!dentry-&gt;d_lockref.count) // å°†å½“å‰çš„ dentry æ·»åŠ åˆ° dispose åˆ—è¡¨ä¸­ d_shrink_add(dentry, &amp;data-&gt;dispose); &#125; /* * å¦‚æœ dispose åˆ—è¡¨ä¸ä¸ºç©ºï¼Œåˆ™è®¾ç½® ret ä¸º D_WALK_NORETRYï¼Œ * å¦‚æœéœ€è¦è°ƒåº¦ï¼Œåˆ™è®¾ç½® ret ä¸º D_WALK_QUITï¼Œä»¥ç¡®ä¿å‘è°ƒç”¨è€…è¿”å›ã€‚ * æˆ‘ä»¬å°†ä¼šç»§ç»­éå†å‰©ä½™çš„ dentryã€‚ */ if (!list_empty(&amp;data-&gt;dispose)) ret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;out: // è¿”å› ret return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * shrink_dcache_parent - prune dcache * @parent: parent of entries to prune * * Prune the dcache to remove unused children of the parent dentry. */void shrink_dcache_parent(struct dentry *parent)&#123; // æ— é™å¾ªç¯ for (;;) &#123; // å®šä¹‰ä¸€ä¸ª select_data ç»“æ„ä½“ï¼Œå¹¶åˆå§‹åŒ– start å­—æ®µä¸º parent struct select_data data = &#123;.start = parent&#125;; // åˆå§‹åŒ– dispose åˆ—è¡¨çš„å¤´èŠ‚ç‚¹ INIT_LIST_HEAD(&amp;data.dispose); // éå† parent çš„å­èŠ‚ç‚¹ï¼Œå¹¶å°†ä¸éœ€è¦çš„å­èŠ‚ç‚¹æ·»åŠ åˆ° dispose åˆ—è¡¨ä¸­ d_walk(parent, &amp;data, select_collect); // å¦‚æœ dispose åˆ—è¡¨ä¸ä¸ºç©ºï¼Œåˆ™é‡Šæ”¾ dispose åˆ—è¡¨ä¸­çš„ dentryï¼Œå¹¶ç»§ç»­ä¸‹ä¸€è½®å¾ªç¯ if (!list_empty(&amp;data.dispose)) &#123; shrink_dentry_list(&amp;data.dispose); continue; &#125; // è°ƒåº¦å½“å‰è¿›ç¨‹ï¼Œä»¥ä¾¿å…¶ä»–ä»»åŠ¡æœ‰æœºä¼šæ‰§è¡Œ cond_resched(); // å¦‚æœæ²¡æœ‰æ‰¾åˆ°éœ€è¦é‡Šæ”¾çš„å­èŠ‚ç‚¹ï¼Œåˆ™è·³å‡ºå¾ªç¯ if (!data.found) break; // å°† victim å­—æ®µç½®ä¸ºç©º data.victim = NULL; // å†æ¬¡éå† parent çš„å­èŠ‚ç‚¹ï¼Œå¹¶å°†ä¸éœ€è¦çš„å­èŠ‚ç‚¹æ·»åŠ åˆ° dispose åˆ—è¡¨ä¸­ d_walk(parent, &amp;data, select_collect2); // å¦‚æœæ‰¾åˆ°äº†éœ€è¦é‡Šæ”¾çš„å­èŠ‚ç‚¹ if (data.victim) &#123; struct dentry *parent; // è·å– victim çš„ d_lock è‡ªæ—‹é” spin_lock(&amp;data.victim-&gt;d_lock); // å¦‚æœæˆåŠŸè·å–åˆ°äº† shrink_lock_dentry é” if (!shrink_lock_dentry(data.victim)) &#123; // é‡Šæ”¾ victim çš„ d_lock è‡ªæ—‹é”ï¼Œå¹¶è§£é” RCU è¯»é” spin_unlock(&amp;data.victim-&gt;d_lock); rcu_read_unlock(); &#125; else &#123; // è§£é” RCU è¯»é” rcu_read_unlock(); // è·å– victim çš„çˆ¶èŠ‚ç‚¹ parent = data.victim-&gt;d_parent; // å¦‚æœ parent ä¸æ˜¯ victim æœ¬èº«ï¼Œåˆ™å°† parent æ·»åŠ åˆ° dispose åˆ—è¡¨ä¸­ if (parent != data.victim) __dput_to_list(parent, &amp;data.dispose); // é‡Šæ”¾ victim çš„èµ„æº __dentry_kill(data.victim); &#125; &#125; // å¦‚æœ dispose åˆ—è¡¨ä¸ä¸ºç©ºï¼Œåˆ™é‡Šæ”¾ dispose åˆ—è¡¨ä¸­çš„ dentry if (!list_empty(&amp;data.dispose)) shrink_dentry_list(&amp;data.dispose); &#125;&#125;EXPORT_SYMBOL(shrink_dcache_parent); 123456789101112131415161718192021222324static enum d_walk_ret umount_check(void *_data, struct dentry *dentry)&#123; /* å¦‚æœå­˜åœ¨ç¹å¿™çš„å­ç›®å½•ï¼Œåˆ™å¿½ç•¥å½“å‰çš„ dentry */ if (!list_empty(&amp;dentry-&gt;d_subdirs)) return D_WALK_CONTINUE; /* å¦‚æœæ˜¯æ ¹ç›®å½•ä¸”å¼•ç”¨è®¡æ•°ä¸º1ï¼Œåˆ™å¿½ç•¥å½“å‰çš„ dentry */ if (dentry == _data &amp;&amp; dentry-&gt;d_lockref.count == 1) return D_WALK_CONTINUE; /* æ‰“å°é”™è¯¯ä¿¡æ¯ï¼ŒæŒ‡ç¤ºå½“å‰çš„ dentry ä»åœ¨ä½¿ç”¨ä¸­ */ printk(KERN_ERR &quot;BUG: Dentry %p&#123;i=%lx,n=%pd&#125; &quot; &quot; still in use (%d) [unmount of %s %s]\\n&quot;, dentry, dentry-&gt;d_inode ? dentry-&gt;d_inode-&gt;i_ino : 0UL, dentry, dentry-&gt;d_lockref.count, dentry-&gt;d_sb-&gt;s_type-&gt;name, dentry-&gt;d_sb-&gt;s_id); /* è§¦å‘è­¦å‘Šï¼Œè¡¨ç¤ºå‘ç°äº†ä¸€ä¸ªé”™è¯¯ */ WARN_ON(1); return D_WALK_CONTINUE;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static void do_one_tree(struct dentry *dentry)&#123; // æ”¶ç¼© dcacheï¼Œç§»é™¤çˆ¶ç›®å½• dentry çš„æœªä½¿ç”¨å­èŠ‚ç‚¹ shrink_dcache_parent(dentry); // éå† dentry çš„å­èŠ‚ç‚¹ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æœ‰ä»åœ¨ä½¿ç”¨çš„ dentry d_walk(dentry, dentry, umount_check); // ä¸¢å¼ƒ dentry çš„å¼•ç”¨è®¡æ•° d_drop(dentry); // é‡Šæ”¾ dentry dput(dentry);&#125;/* * åœ¨å¸è½½æ—¶é”€æ¯ä¸è¶…çº§å—å…³è”çš„ dentry */void shrink_dcache_for_umount(struct super_block *sb)&#123; struct dentry *dentry; // æ£€æŸ¥ s_umount æ˜¯å¦å·²ç»è¢«é”å®š WARN(down_read_trylock(&amp;sb-&gt;s_umount), &quot;s_umount should&#x27;ve been locked&quot;); // å¤„ç†æ ¹ç›®å½•çš„ dentry dentry = sb-&gt;s_root; sb-&gt;s_root = NULL; do_one_tree(dentry); // å¤„ç† s_roots é“¾è¡¨ä¸­çš„æ‰€æœ‰ dentry while (!hlist_bl_empty(&amp;sb-&gt;s_roots)) &#123; dentry = dget(hlist_bl_entry(hlist_bl_first(&amp;sb-&gt;s_roots), struct dentry, d_hash)); do_one_tree(dentry); &#125;&#125;static enum d_walk_ret find_submount(void *_data, struct dentry *dentry)&#123; struct dentry **victim = _data; // å¦‚æœ dentry æ˜¯æŒ‚è½½ç‚¹ if (d_mountpoint(dentry)) &#123; // è·å– dentry çš„ d_lock è‡ªæ—‹é” __dget_dlock(dentry); // å°† dentry èµ‹å€¼ç»™ victim *victim = dentry; // è¿”å› D_WALK_QUITï¼Œè¡¨ç¤ºéå†ç»“æŸ return D_WALK_QUIT; &#125; // è¿”å› D_WALK_CONTINUEï¼Œç»§ç»­éå† return D_WALK_CONTINUE;&#125; 123456789101112131415161718192021222324252627282930/** * d_invalidate - åˆ†ç¦»å­æŒ‚è½½ç‚¹ï¼Œä¿®å‰ª dcacheï¼Œå¹¶ä¸¢å¼ƒ * @dentry: éœ€è¦ä½¿æ— æ•ˆçš„ dentryï¼ˆå³åˆ†ç¦»ã€ä¿®å‰ªå’Œä¸¢å¼ƒçš„ dentryï¼‰ */void d_invalidate(struct dentry *dentry)&#123; bool had_submounts = true; // æ˜¯å¦å­˜åœ¨å­æŒ‚è½½ç‚¹çš„æ ‡å¿— if (!dentry-&gt;d_inode) return; // åˆ†ç¦»å­æŒ‚è½½ç‚¹å¹¶ä¿®å‰ª dcache shrink_dcache_parent(dentry); for (;;) &#123; struct dentry *victim = NULL; // éå† dentry åŠå…¶å­èŠ‚ç‚¹ï¼ŒæŸ¥æ‰¾å­æŒ‚è½½ç‚¹ d_walk(dentry, &amp;victim, find_submount); if (!victim) &#123; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å­æŒ‚è½½ç‚¹ if (had_submounts) &#123; // å¦‚æœä¹‹å‰å­˜åœ¨å­æŒ‚è½½ç‚¹ï¼Œåˆ™å†æ¬¡ä¿®å‰ª dcache shrink_dcache_parent(dentry); &#125; return; &#125; // åˆ†ç¦»æŒ‚è½½ç‚¹å¹¶ä¸¢å¼ƒ detach_mounts(victim); dput(victim); &#125;&#125;EXPORT_SYMBOL(d_invalidate); 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * è¿™æ®µä»£ç åº”è¯¥ç­‰åŒäº d_instantiate() + unlock_new_inode()ï¼Œ * ä½†åœ¨æ‰§è¡Œå…¶ä»–æ“ä½œä¹‹å‰ï¼Œå…ˆæ‰§è¡Œ unlock_new_inode() ä¸­ä¸ lockdep ç›¸å…³çš„éƒ¨åˆ†ã€‚ * ä½¿ç”¨è¿™ä¸ªå‡½æ•°æ›¿ä»£æ‰‹åŠ¨ç¼–å†™çš„ d_instantiate() å’Œ unlock_new_inode() çš„ç»„åˆã€‚ */void d_instantiate_new(struct dentry *entry, struct inode *inode)&#123; // æ£€æŸ¥ entry æ˜¯å¦å·²ç»åœ¨åˆ«çš„å“ˆå¸Œè¡¨ä¸­ BUG_ON(!hlist_unhashed(&amp;entry-&gt;d_u.d_alias)); // æ£€æŸ¥ inode æ˜¯å¦ä¸ºç©º BUG_ON(!inode); // ä¸º inode çš„äº’æ–¥é”æ·»åŠ  lockdep æ³¨è§£ lockdep_annotate_inode_mutex_key(inode); // è°ƒç”¨å®‰å…¨æ¨¡å—çš„ d_instantiate() å‡½æ•° security_d_instantiate(entry, inode); // è·å– inode çš„è‡ªæ—‹é” spin_lock(&amp;inode-&gt;i_lock); // è°ƒç”¨å†…éƒ¨å‡½æ•° __d_instantiate() æ¥å®ä¾‹åŒ– dentry å’Œ inode __d_instantiate(entry, inode); // æ£€æŸ¥ inode çš„çŠ¶æ€æ˜¯å¦ä¸º I_NEW WARN_ON(!(inode-&gt;i_state &amp; I_NEW)); // æ¸…é™¤ inode çš„çŠ¶æ€æ ‡å¿— I_NEW å’Œ I_CREATING inode-&gt;i_state &amp;= ~I_NEW &amp; ~I_CREATING; // ç¡®ä¿åœ¨ä¿®æ”¹ inode çŠ¶æ€åçš„å†…å­˜å±éšœ smp_mb(); // å”¤é†’ç­‰å¾… inode çŠ¶æ€å˜ä¸º __I_NEW çš„è¿›ç¨‹ wake_up_bit(&amp;inode-&gt;i_state, __I_NEW); // é‡Šæ”¾ inode çš„è‡ªæ—‹é” spin_unlock(&amp;inode-&gt;i_lock);&#125;// å¯¼å‡º d_instantiate_new() å‡½æ•°ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨EXPORT_SYMBOL(d_instantiate_new); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct dentry *d_make_root(struct inode *root_inode)&#123; struct dentry *res = NULL; // å¦‚æœ root_inode ä¸ä¸ºç©º if (root_inode) &#123; // ä¸º root_inode åˆ†é…ä¸€ä¸ªåŒ¿åçš„ dentry res = d_alloc_anon(root_inode-&gt;i_sb); if (res) &#123; // å°† root_inode å’Œ dentry å…³è”èµ·æ¥ d_instantiate(res, root_inode); &#125; else &#123; // å¦‚æœæ— æ³•åˆ†é… dentryï¼Œåˆ™é‡Šæ”¾ root_inode iput(root_inode); &#125; &#125; return res;&#125;EXPORT_SYMBOL(d_make_root);static struct dentry *__d_instantiate_anon(struct dentry *dentry, struct inode *inode, bool disconnected)&#123; struct dentry *res; unsigned add_flags; // è°ƒç”¨å®‰å…¨æ¨¡å—çš„ d_instantiate() å‡½æ•° security_d_instantiate(dentry, inode); // è·å– inode çš„è‡ªæ—‹é” spin_lock(&amp;inode-&gt;i_lock); // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ä¸ inode å…³è”çš„ dentry res = __d_find_any_alias(inode); if (res) &#123; // å¦‚æœå·²ç»å­˜åœ¨ï¼Œåˆ™é‡Šæ”¾å½“å‰çš„ dentryï¼Œå¹¶è¿”å›å·²å­˜åœ¨çš„ dentry spin_unlock(&amp;inode-&gt;i_lock); dput(dentry); goto out_iput; &#125; // ä¸º inode è®¾ç½®æ ‡å¿—ä½ add_flags = d_flags_for_inode(inode); // å¦‚æœæ˜¯æ–­å¼€çš„ dentryï¼Œåˆ™è®¾ç½® DCACHE_DISCONNECTED æ ‡å¿—ä½ if (disconnected) add_flags |= DCACHE_DISCONNECTED; // è·å– dentry çš„è‡ªæ—‹é” spin_lock(&amp;dentry-&gt;d_lock); // å°† inode å’Œç±»å‹ä¿¡æ¯è®¾ç½®åˆ° dentry ä¸­ __d_set_inode_and_type(dentry, inode, add_flags); // å°† dentry æ·»åŠ åˆ° inode çš„åˆ«åé“¾è¡¨ä¸­ hlist_add_head(&amp;dentry-&gt;d_u.d_alias, &amp;inode-&gt;i_dentry); // å¦‚æœä¸æ˜¯æ–­å¼€çš„ dentryï¼Œåˆ™å°† dentry æ·»åŠ åˆ°è¶…çº§å—çš„æ ¹ç›®å½•é“¾è¡¨ä¸­ if (!disconnected) &#123; hlist_bl_lock(&amp;dentry-&gt;d_sb-&gt;s_roots); hlist_bl_add_head(&amp;dentry-&gt;d_hash, &amp;dentry-&gt;d_sb-&gt;s_roots); hlist_bl_unlock(&amp;dentry-&gt;d_sb-&gt;s_roots); &#125; // é‡Šæ”¾ dentry çš„è‡ªæ—‹é”å’Œ inode çš„è‡ªæ—‹é” spin_unlock(&amp;dentry-&gt;d_lock); spin_unlock(&amp;inode-&gt;i_lock); return dentry;out_iput: // é‡Šæ”¾ inode iput(inode); return res;&#125;struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)&#123; // è°ƒç”¨å†…éƒ¨å‡½æ•° __d_instantiate_anon() æ¥å®ä¾‹åŒ–åŒ¿åçš„ dentry å’Œ inode return __d_instantiate_anon(dentry, inode, true);&#125;EXPORT_SYMBOL(d_instantiate_anon); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677static struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)&#123; struct dentry *tmp; struct dentry *res; // å¦‚æœ inode ä¸ºç©ºï¼Œåˆ™è¿”å›é”™è¯¯ç  -ESTALE if (!inode) return ERR_PTR(-ESTALE); // å¦‚æœ inode æ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œåˆ™å°†å…¶è½¬æ¢ä¸ºé”™è¯¯ç±»å‹å¹¶è¿”å› if (IS_ERR(inode)) return ERR_CAST(inode); // æŸ¥æ‰¾ä¸ inode å…³è”çš„ä»»æ„åˆ«åçš„ dentry res = d_find_any_alias(inode); if (res) goto out_iput; // ä¸º inode åˆ†é…ä¸€ä¸ªåŒ¿åçš„ dentry tmp = d_alloc_anon(inode-&gt;i_sb); if (!tmp) &#123; // å¦‚æœæ— æ³•åˆ†é… dentryï¼Œåˆ™è¿”å›é”™è¯¯ç  -ENOMEM res = ERR_PTR(-ENOMEM); goto out_iput; &#125; // è°ƒç”¨å†…éƒ¨å‡½æ•° __d_instantiate_anon() æ¥å®ä¾‹åŒ–åŒ¿åçš„ dentry å’Œ inode return __d_instantiate_anon(tmp, inode, disconnected);out_iput: // é‡Šæ”¾ inode iput(inode); return res;&#125;/** * d_obtain_alias - find or allocate a DISCONNECTED dentry for a given inode * @inode: inode to allocate the dentry for * * è·å–ç»™å®š inode çš„ä¸€ä¸ª dentryï¼Œç”¨äº NFS æ–‡ä»¶å¥æŸ„è½¬æ¢æˆ–ç±»ä¼¼çš„é€šè¿‡å¥æŸ„æ‰“å¼€æ“ä½œã€‚ * è¿”å›çš„ dentry å¯èƒ½æ˜¯åŒ¿åçš„ï¼Œä¹Ÿå¯èƒ½å…·æœ‰å®Œæ•´çš„åç§°ï¼ˆå¦‚æœ inode å·²ç»åœ¨ç¼“å­˜ä¸­ï¼‰ã€‚ * * å½“åœ¨ç›®å½• inode ä¸Šè°ƒç”¨æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿ inode åªæœ‰ä¸€ä¸ª dentryã€‚ * å¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ª dentryï¼Œåˆ™è¿”å›è¯¥ dentry è€Œä¸æ˜¯åˆ†é…ä¸€ä¸ªæ–°çš„ã€‚ * * åœ¨æˆåŠŸè¿”å›æ—¶ï¼Œinode çš„å¼•ç”¨å·²ç»è½¬ç§»åˆ°äº† dentry ä¸Šã€‚ * åœ¨å‡ºç°é”™è¯¯çš„æƒ…å†µä¸‹ï¼Œé‡Šæ”¾äº† inode çš„å¼•ç”¨ã€‚ * ä¸ºäº†åœ¨å¯¼å‡ºæ“ä½œä¸­æ›´å®¹æ˜“ä½¿ç”¨ï¼Œå¯ä»¥ä¼ å…¥ä¸€ä¸ª %NULL æˆ– IS_ERR çš„ inodeï¼Œ * é”™è¯¯å°†ä¼ æ’­åˆ°è¿”å›å€¼ï¼Œå°† %NULL çš„ inode æ›¿æ¢ä¸º ERR_PTR(-ESTALE)ã€‚ */struct dentry *d_obtain_alias(struct inode *inode)&#123; // è°ƒç”¨å†…éƒ¨å‡½æ•° __d_obtain_alias() æ¥è·å–ä¸€ä¸ª DISCONNECTED çš„ dentry return __d_obtain_alias(inode, true);&#125;EXPORT_SYMBOL(d_obtain_alias);/** * d_obtain_root - find or allocate a dentry for a given inode * @inode: inode to allocate the dentry for * * è·å–ç»™å®š inode çš„ä¸€ä¸ª IS_ROOT dentryï¼Œç”¨äºæ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•ã€‚ * * æˆ‘ä»¬å¿…é¡»ç¡®ä¿ç›®å½• inode åªæœ‰ä¸€ä¸ª dentryã€‚ * å¦‚æœæ‰¾åˆ°äº†ä¸€ä¸ª dentryï¼Œåˆ™è¿”å›è¯¥ dentry è€Œä¸æ˜¯åˆ†é…ä¸€ä¸ªæ–°çš„ã€‚ * * åœ¨æˆåŠŸè¿”å›æ—¶ï¼Œinode çš„å¼•ç”¨å·²ç»è½¬ç§»åˆ°äº† dentry ä¸Šã€‚ * åœ¨å‡ºç°é”™è¯¯çš„æƒ…å†µä¸‹ï¼Œé‡Šæ”¾äº† inode çš„å¼•ç”¨ã€‚ * å¯ä»¥ä¼ å…¥ä¸€ä¸ª %NULL æˆ– IS_ERR çš„ inodeï¼Œå¹¶å°†é”™è¯¯ä¼ æ’­åˆ°è¿”å›å€¼ï¼Œ * å°† %NULL çš„ inode æ›¿æ¢ä¸º ERR_PTR(-ESTALE)ã€‚ */struct dentry *d_obtain_root(struct inode *inode)&#123; // è°ƒç”¨å†…éƒ¨å‡½æ•° __d_obtain_alias() æ¥è·å–ä¸€ä¸ªæ ¹ç›®å½•çš„ dentry return __d_obtain_alias(inode, false);&#125;EXPORT_SYMBOL(d_obtain_root); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * d_add_ci - æŸ¥æ‰¾æˆ–åˆ†é…å…·æœ‰å¤§å°å†™ç²¾ç¡®åç§°çš„æ–°çš„dentry * @inode: å·²æ‰¾åˆ°çš„ä¸åŒºåˆ†å¤§å°å†™çš„æŸ¥æ‰¾çš„inode * @dentry: ä¼ é€’ç»™çˆ¶çº§æŸ¥æ‰¾å‡½æ•°çš„è´Ÿé¢dentry * @name: è¦ä¸è¿”å›çš„dentryå…³è”çš„å¤§å°å†™ç²¾ç¡®åç§° * * è¿™æ˜¯ä¸ºäº†é¿å…åœ¨dcacheä¸­å¡«å……å…·æœ‰ä¸åŒºåˆ†å¤§å°å†™çš„åç§°åˆ°ç›¸åŒçš„inodeï¼Œ * åªæœ‰å®é™…çš„æ­£ç¡®å¤§å°å†™å­˜å‚¨åœ¨dcacheä¸­ï¼Œç”¨äºä¸åŒºåˆ†å¤§å°å†™çš„æ–‡ä»¶ç³»ç»Ÿã€‚ * * å¯¹äºä¸åŒºåˆ†å¤§å°å†™çš„æŸ¥æ‰¾åŒ¹é…ï¼Œå¦‚æœdcacheä¸­å·²ç»å­˜åœ¨å¤§å°å†™ç²¾ç¡®çš„dentryï¼Œ * åˆ™ä½¿ç”¨å®ƒå¹¶è¿”å›å®ƒã€‚ * * å¦‚æœä¸å­˜åœ¨å…·æœ‰ç²¾ç¡®å¤§å°å†™åç§°çš„æ¡ç›®ï¼Œåˆ™åˆ†é…å…·æœ‰ç²¾ç¡®å¤§å°å†™çš„æ–°çš„dentryï¼Œå¹¶è¿”å›æ‹¼æ¥çš„æ¡ç›®ã€‚ */struct dentry *d_add_ci(struct dentry *dentry, struct inode *inode, struct qstr *name)&#123; struct dentry *found, *res; /* é¦–å…ˆæ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ä¸åç§°åŒ¹é…çš„dentryï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™ç«‹å³åˆ›å»ºå®ƒã€‚ */ found = d_hash_and_lookup(dentry-&gt;d_parent, name); if (found) &#123; iput(inode); return found; &#125; if (d_in_lookup(dentry)) &#123; /* å¦‚æœdentryæ­£åœ¨è¿›è¡ŒæŸ¥æ‰¾ï¼Œåˆ™å¹¶è¡Œåˆ†é…æ–°çš„dentry */ found = d_alloc_parallel(dentry-&gt;d_parent, name, dentry-&gt;d_wait); if (IS_ERR(found) || !d_in_lookup(found)) &#123; iput(inode); return found; &#125; &#125; else &#123; /* å¦åˆ™ï¼Œåˆ†é…æ–°çš„dentry */ found = d_alloc(dentry-&gt;d_parent, name); if (!found) &#123; iput(inode); return ERR_PTR(-ENOMEM); &#125; &#125; /* å°†inodeä¸æ–°çš„dentryè¿›è¡Œå…³è” */ res = d_splice_alias(inode, found); if (res) &#123; d_lookup_done(found); dput(found); return res; &#125; return found;&#125;EXPORT_SYMBOL(d_add_ci); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * d_same_name - æ¯”è¾ƒdentryçš„åç§°ä¸å¤§å°å†™ç²¾ç¡®åç§° * @parent: çˆ¶çº§dentry * @dentry: ä¼ é€’ç»™çˆ¶çº§æŸ¥æ‰¾å‡½æ•°çš„è´Ÿé¢dentry * @name: è¦ä¸è¿”å›çš„dentryå…³è”çš„å¤§å°å†™ç²¾ç¡®åç§° * * è¿”å›å€¼ï¼šå¦‚æœåç§°ç›¸åŒåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false */bool d_same_name(const struct dentry *dentry, const struct dentry *parent, const struct qstr *name)&#123; if (likely(!(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))) &#123; /* å¦‚æœçˆ¶çº§dentryæ²¡æœ‰DCACHE_OP_COMPAREæ ‡å¿—ï¼Œåˆ™ç›´æ¥æ¯”è¾ƒåç§° */ if (dentry-&gt;d_name.len != name-&gt;len) return false; return dentry_cmp(dentry, name-&gt;name, name-&gt;len) == 0; &#125; /* å¦åˆ™ï¼Œè°ƒç”¨çˆ¶çº§dentryçš„d_compareå‡½æ•°è¿›è¡Œæ¯”è¾ƒ */ return parent-&gt;d_op-&gt;d_compare(dentry, dentry-&gt;d_name.len, dentry-&gt;d_name.name, name) == 0;&#125;EXPORT_SYMBOL_GPL(d_same_name);/* * å½“çˆ¶çº§dentryå…·æœ‰DCACHE_OP_COMPAREæ ‡å¿—æ—¶ï¼Œè¿™æ˜¯__d_lookup_rcu()çš„å®ç°ï¼Œè¿™ä¼šä½¿äº‹æƒ…å˜å¾—æ›´åŠ å¤æ‚ã€‚ */static noinline struct dentry *__d_lookup_rcu_op_compare( const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); struct hlist_bl_node *node; struct dentry *dentry; hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; int tlen; const char *tname; unsigned seq; seqretry: seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); if (dentry-&gt;d_parent != parent) continue; if (d_unhashed(dentry)) continue; if (dentry-&gt;d_name.hash != hashlen_hash(hashlen)) continue; tlen = dentry-&gt;d_name.len; tname = dentry-&gt;d_name.name; /* æˆ‘ä»¬å¸Œæœ›å¾—åˆ°ä¸€å¯¹ä¸€è‡´çš„ï¼ˆname,lenï¼‰ */ if (read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) &#123; cpu_relax(); goto seqretry; &#125; if (parent-&gt;d_op-&gt;d_compare(dentry, tlen, tname, name) != 0) continue; *seqp = seq; return dentry; &#125; return NULL;&#125; 123456789101112131415161718192021222324/** * d_same_name - æ¯”è¾ƒdentryçš„åç§°ä¸å¤§å°å†™ç²¾ç¡®åç§° * @parent: çˆ¶çº§dentry * @dentry: ä¼ é€’ç»™çˆ¶çº§æŸ¥æ‰¾å‡½æ•°çš„è´Ÿé¢dentry * @name: è¦ä¸è¿”å›çš„dentryå…³è”çš„å¤§å°å†™ç²¾ç¡®åç§° * * è¿”å›å€¼ï¼šå¦‚æœåç§°ç›¸åŒåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false */bool d_same_name(const struct dentry *dentry, const struct dentry *parent, const struct qstr *name)&#123; if (likely(!(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))) &#123; // å¦‚æœçˆ¶çº§dentryæ²¡æœ‰DCACHE_OP_COMPAREæ ‡å¿—ï¼Œåˆ™ç›´æ¥æ¯”è¾ƒåç§° if (dentry-&gt;d_name.len != name-&gt;len) return false; return dentry_cmp(dentry, name-&gt;name, name-&gt;len) == 0; &#125; // å¦åˆ™ï¼Œè°ƒç”¨çˆ¶çº§dentryçš„d_compareå‡½æ•°è¿›è¡Œæ¯”è¾ƒ return parent-&gt;d_op-&gt;d_compare(dentry, dentry-&gt;d_name.len, dentry-&gt;d_name.name, name) == 0;&#125;EXPORT_SYMBOL_GPL(d_same_name); 1234567891011121314151617181920212223242526272829303132333435363738394041/* * å½“çˆ¶çº§dentryå…·æœ‰DCACHE_OP_COMPAREæ ‡å¿—æ—¶ï¼Œè¿™æ˜¯__d_lookup_rcu()çš„å®ç°ï¼Œè¿™ä¼šä½¿äº‹æƒ…å˜å¾—æ›´åŠ å¤æ‚ã€‚ */static noinline struct dentry *__d_lookup_rcu_op_compare( const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // è·å–nameçš„å“ˆå¸Œé•¿åº¦ struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // è·å–å“ˆå¸Œè¡¨çš„å¤´æŒ‡é’ˆ struct hlist_bl_node *node; struct dentry *dentry; // éå†å“ˆå¸Œè¡¨ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; int tlen; const char *tname; unsigned seq; seqretry: seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // å¼€å§‹è¯»å–åºåˆ—è®¡æ•°å™¨ if (dentry-&gt;d_parent != parent) // å¦‚æœdentryçš„çˆ¶çº§ä¸æ˜¯æŒ‡å®šçš„parent continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ if (d_unhashed(dentry)) // å¦‚æœdentryæœªå“ˆå¸Œ continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ if (dentry-&gt;d_name.hash != hashlen_hash(hashlen)) // å¦‚æœdentryçš„å“ˆå¸Œå€¼ä¸æŒ‡å®šçš„å“ˆå¸Œå€¼ä¸åŒ¹é… continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ tlen = dentry-&gt;d_name.len; // è·å–dentryçš„åç§°é•¿åº¦ tname = dentry-&gt;d_name.name; // è·å–dentryçš„åç§° // æˆ‘ä»¬å¸Œæœ›å¾—åˆ°ä¸€å¯¹ä¸€è‡´çš„ï¼ˆname,lenï¼‰ if (read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) &#123; // å¦‚æœåºåˆ—è®¡æ•°å™¨å‘ç”Ÿå˜åŒ– cpu_relax(); // è®©å‡ºCPUæ—¶é—´ç‰‡ goto seqretry; // é‡æ–°å°è¯•è¯»å–åºåˆ—è®¡æ•°å™¨ &#125; if (parent-&gt;d_op-&gt;d_compare(dentry, tlen, tname, name) != 0) // å¦‚æœçˆ¶çº§dentryçš„d_compareå‡½æ•°è¿”å›éé›¶å€¼ continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ *seqp = seq; // å°†åºåˆ—è®¡æ•°å™¨çš„å€¼èµ‹ç»™seqpæŒ‡é’ˆæŒ‡å‘çš„å˜é‡ return dentry; // è¿”å›æ‰¾åˆ°çš„dentry &#125; return NULL; // æœªæ‰¾åˆ°åŒ¹é…çš„dentryï¼Œè¿”å›NULL&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * __d_lookup_rcu - æœç´¢dentryï¼ˆæœ‰ç«äº‰ï¼Œæ— å­˜å‚¨ï¼‰ * @parent: çˆ¶çº§dentry * @name: è¦æŸ¥æ‰¾çš„åç§°çš„qstr * @seqp: è¿”å›æ‰¾åˆ°dentryæ—¶çš„d_seqå€¼ * è¿”å›å€¼: dentryï¼Œæˆ–è€…NULL * * __d_lookup_rcuæ˜¯rcu-walkåç§°è§£æï¼ˆæ— å­˜å‚¨è·¯å¾„éå†ï¼‰è®¾è®¡ä¸­çš„dcacheæŸ¥æ‰¾å‡½æ•°ï¼Œ * å…¶è®¾è®¡åœ¨Documentation/filesystems/path-lookup.txtä¸­æœ‰æè¿°ã€‚ * * è¿™ä¸ªå‡½æ•°åªèƒ½åœ¨æ ¸å¿ƒvfsä¸­ä½¿ç”¨ã€‚ * * __d_lookup_rcuåªèƒ½åœ¨rcu-walkæ¨¡å¼ä¸‹ä½¿ç”¨ï¼Œå³åœ¨æŒæœ‰vfsmounté”å’Œrcu_read_lockçš„æƒ…å†µä¸‹ã€‚ * è¿”å›çš„dentryä¸èƒ½åœ¨æ²¡æœ‰è·å–d_lockå¹¶æ£€æŸ¥d_seqåºåˆ—è®¡æ•°ä¸è¿™é‡Œè¿”å›çš„@seqç›¸æ¯”è¾ƒä¹‹å‰å­˜å‚¨ã€‚ * * å¯ä»¥ä½¿ç”¨d_rcu_to_refcountå‡½æ•°å¯¹æ‰¾åˆ°çš„dentryè¿›è¡Œå¼•ç”¨è®¡æ•°ã€‚ * * æˆ–è€…ï¼Œå¯ä»¥å†æ¬¡è°ƒç”¨__d_lookup_rcuæ¥æŸ¥æ‰¾è¿”å›çš„dentryçš„å­èŠ‚ç‚¹ï¼Œåªè¦åœ¨æŸ¥æ‰¾å­èŠ‚ç‚¹ä¹‹åæ£€æŸ¥å…¶çˆ¶èŠ‚ç‚¹çš„åºåˆ—é”ã€‚ * å› æ­¤ï¼Œå½¢æˆäº†ä¸€ä¸ªäº¤é”™çš„åºåˆ—é”æ£€æŸ¥ï¼Œä¿è¯äº†è·¯å¾„éå†çš„å®Œæ•´æ€§ã€‚ * * æ³¨æ„ï¼è°ƒç”¨è€…åœ¨ä½¿ç”¨è¿”å›çš„dentryçŠ¶æ€ä¹‹å‰å¿…é¡»æ£€æŸ¥ç»“æœdentryä¸æˆ‘ä»¬è¿”å›çš„åºåˆ—å·æ˜¯å¦åŒ¹é…ï¼ */struct dentry *__d_lookup_rcu(const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // è·å–nameçš„å“ˆå¸Œé•¿åº¦ const unsigned char *str = name-&gt;name; // è·å–nameçš„åç§°å­—ç¬¦ä¸² struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // è·å–å“ˆå¸Œè¡¨çš„å¤´æŒ‡é’ˆ struct hlist_bl_node *node; struct dentry *dentry; /* * æ³¨æ„ï¼šè¿™é‡Œä¸__d_lookup_rcuå­˜åœ¨é‡å¤ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢å•çº¿ç¨‹æ€§èƒ½é€€åŒ–ï¼Œ * ç‰¹åˆ«æ˜¯åœ¨smp_rmbï¼ˆåœ¨åºåˆ—è®¡æ•°å™¨ä¸­ï¼‰å¼€é”€è¾ƒå¤§çš„ä½“ç³»ç»“æ„ä¸Šã€‚ * ä¿æŒè¿™ä¸¤ä¸ªå‡½æ•°åŒæ­¥ã€‚ */ if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE)) return __d_lookup_rcu_op_compare(parent, name, seqp); /* * å“ˆå¸Œåˆ—è¡¨å—RCUä¿æŠ¤ã€‚ * * åœ¨æ¯”è¾ƒå€™é€‰dentryæ—¶ï¼Œå°å¿ƒä½¿ç”¨d_seqï¼Œä»¥é¿å…ä¸d_move()ç«äº‰ã€‚ * * å¹¶å‘é‡å‘½åå¯èƒ½ä¼šåœ¨è¿™é‡Œç ´åæˆ‘ä»¬çš„åˆ—è¡¨éå†ï¼Œå¯¼è‡´æ‰¾ä¸åˆ°æˆ‘ä»¬çš„dentryï¼Œä»è€Œå¯¼è‡´é”™è¯¯çš„è´Ÿç»“æœã€‚ * d_lookup()ä½¿ç”¨rename_lockåºåˆ—é”æ¥ä¿æŠ¤å…å—å¹¶å‘é‡å‘½åçš„å½±å“ã€‚ * * æ›´å¤šç»†èŠ‚è¯·å‚è§Documentation/filesystems/path-lookup.txtã€‚ */ hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; unsigned seq; /* * dentryåºåˆ—è®¡æ•°å™¨ä¿æŠ¤æˆ‘ä»¬å…å—å¹¶å‘é‡å‘½åçš„å½±å“ï¼Œå› æ­¤ä¿æŠ¤äº†çˆ¶çº§å’Œåç§°å­—æ®µã€‚ * * è°ƒç”¨è€…å¿…é¡»æ‰§è¡Œåºåˆ—è®¡æ•°å™¨æ£€æŸ¥ï¼Œä»¥ä¾¿å¯¹è¿”å›çš„dentryæ‰§è¡Œæœ‰ç”¨çš„æ“ä½œã€‚ * * æ³¨æ„ï¼è¿™é‡Œä½¿ç”¨çš„æ˜¯â€œrawâ€ seqcount_beginã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æœåºåˆ—è®¡æ•°å™¨å¤„äºåºåˆ—æ›´æ”¹çš„ä¸­é—´çŠ¶æ€ï¼Œ * æˆ‘ä»¬ä¸ä¼šç­‰å¾…åºåˆ—è®¡æ•°å™¨ç¨³å®šã€‚å¦‚æœæˆ‘ä»¬æ‰§è¡Œäº†æ…¢é€Ÿçš„dentryæ¯”è¾ƒï¼Œæˆ‘ä»¬å°†è¿›è¡Œåºåˆ—é‡è¯•ï¼Œç›´åˆ°å®ƒç¨³å®šä¸‹æ¥ï¼Œ * å¦‚æœæˆ‘ä»¬æœ€ç»ˆæ‰¾åˆ°äº†ä¸€ä¸ªæˆåŠŸçš„æŸ¥æ‰¾ï¼Œæˆ‘ä»¬å®é™…ä¸Šå¸Œæœ›é€€å‡ºRCUæŸ¥æ‰¾ã€‚ * * è¯·æ³¨æ„ï¼Œraw_seqcount_beginä»ç„¶ä¼šæ‰§è¡Œsmp_rmb()ï¼Œå› æ­¤æˆ‘ä»¬ä»ç„¶ä¿è¯-&gt;d_name.nameçš„NULç»ˆæ­¢ã€‚ */ seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // å¼€å§‹è¯»å–åºåˆ—è®¡æ•°å™¨ if (dentry-&gt;d_parent != parent) // å¦‚æœdentryçš„çˆ¶çº§ä¸æ˜¯æŒ‡å®šçš„parent continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ if (d_unhashed(dentry)) // å¦‚æœdentryæœªå“ˆå¸Œ continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ if (dentry-&gt;d_name.hash_len != hashlen) // å¦‚æœdentryçš„å“ˆå¸Œé•¿åº¦ä¸æŒ‡å®šçš„å“ˆå¸Œé•¿åº¦ä¸åŒ¹é… continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ if (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0) // å¦‚æœdentryä¸æŒ‡å®šçš„åç§°ä¸åŒ¹é… continue; // ç»§ç»­ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ *seqp = seq; // å°†åºåˆ—è®¡æ•°å™¨çš„å€¼èµ‹ç»™seqpæŒ‡é’ˆæŒ‡å‘çš„å˜é‡ return dentry; // è¿”å›æ‰¾åˆ°çš„dentry &#125; return NULL; // æœªæ‰¾åˆ°åŒ¹é…çš„dentryï¼Œè¿”å›NULL&#125; 123456789101112131415161718192021222324/** * d_lookup - æœç´¢dentry * @parent: çˆ¶çº§dentry * @name: è¦æŸ¥æ‰¾çš„åç§°çš„qstr * è¿”å›å€¼: dentryï¼Œæˆ–è€…NULL * * d_lookupæœç´¢çˆ¶çº§dentryçš„å­èŠ‚ç‚¹ï¼ŒæŸ¥æ‰¾æŒ‡å®šçš„åç§°ã€‚å¦‚æœæ‰¾åˆ°dentryï¼Œå®ƒçš„å¼•ç”¨è®¡æ•°å°†å¢åŠ ï¼Œå¹¶è¿”å›è¯¥dentryã€‚ * è°ƒç”¨è€…å¿…é¡»ä½¿ç”¨dputé‡Šæ”¾ä½¿ç”¨å®Œæ¯•çš„dentryã€‚å¦‚æœdentryä¸å­˜åœ¨ï¼Œåˆ™è¿”å›NULLã€‚ */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; do &#123; seq = read_seqbegin(&amp;rename_lock); // å¼€å§‹è¯»å–åºåˆ—è®¡æ•°å™¨ dentry = __d_lookup(parent, name); // è°ƒç”¨__d_lookupå‡½æ•°æŸ¥æ‰¾dentry if (dentry) break; &#125; while (read_seqretry(&amp;rename_lock, seq)); // å¦‚æœåºåˆ—è®¡æ•°å™¨å‘ç”Ÿå˜åŒ–ï¼Œåˆ™é‡è¯• return dentry; // è¿”å›æ‰¾åˆ°çš„dentry&#125;EXPORT_SYMBOL(d_lookup); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * __d_lookup - search for a dentry (racy) * @parent: parent dentry * @name: qstr of name we wish to find * Returns: dentry, or NULL * * __d_lookup is like d_lookup, however it may (rarely) return a * false-negative result due to unrelated rename activity. * * __d_lookup is slightly faster by avoiding rename_lock read seqlock, * however it must be used carefully, eg. with a following d_lookup in * the case of failure. * * __d_lookup callers must be commented. */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; struct hlist_bl_head *b = d_hash(hash); struct hlist_bl_node *node; struct dentry *found = NULL; struct dentry *dentry; /* * Note: There is significant duplication with __d_lookup_rcu which is * required to prevent single threaded performance regressions * especially on architectures where smp_rmb (in seqcounts) are costly. * Keep the two functions in sync. */ /* * The hash list is protected using RCU. * * Take d_lock when comparing a candidate dentry, to avoid races * with d_move(). * * It is possible that concurrent renames can mess up our list * walk here and result in missing our dentry, resulting in the * false-negative result. d_lookup() protects against concurrent * renames using rename_lock seqlock. * * See Documentation/filesystems/path-lookup.txt for more details. */ rcu_read_lock(); hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) continue; spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_parent != parent) goto next; if (d_unhashed(dentry)) goto next; if (!d_same_name(dentry, parent, name)) goto next; dentry-&gt;d_lockref.count++; found = dentry; spin_unlock(&amp;dentry-&gt;d_lock); break;next: spin_unlock(&amp;dentry-&gt;d_lock); &#125; rcu_read_unlock(); return found;&#125; 12345678910111213141516171819202122/** * d_hash_and_lookup - å¯¹qstrè¿›è¡Œå“ˆå¸Œç„¶åæœç´¢dentry * @dir: è¦æœç´¢çš„ç›®å½• * @name: è¦æŸ¥æ‰¾çš„åç§°çš„qstr * * åœ¨æŸ¥æ‰¾å¤±è´¥æ—¶è¿”å›NULLï¼›åœ¨åç§°é”™è¯¯æ—¶è¿”å›ERR_PTR(-error)ã€‚ */struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)&#123; /* * æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„å“ˆå¸Œå‡½æ•°ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬å¿…é¡»å…ˆè®¡ç®—æ ‡å‡†å“ˆå¸Œå€¼ï¼Œ * å› ä¸ºd_op-&gt;d_hash()å‡½æ•°å¯èƒ½é€‰æ‹©ä¿æŒå“ˆå¸Œå€¼ä¸å˜ã€‚ */ name-&gt;hash = full_name_hash(dir, name-&gt;name, name-&gt;len); // è®¡ç®—æ ‡å‡†å“ˆå¸Œå€¼ if (dir-&gt;d_flags &amp; DCACHE_OP_HASH) &#123; // æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„å“ˆå¸Œå‡½æ•° int err = dir-&gt;d_op-&gt;d_hash(dir, name); // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„å“ˆå¸Œå‡½æ•° if (unlikely(err &lt; 0)) return ERR_PTR(err); // è¿”å›é”™è¯¯æŒ‡é’ˆ &#125; return d_lookup(dir, name); // è°ƒç”¨d_lookupå‡½æ•°è¿›è¡ŒæŸ¥æ‰¾&#125;EXPORT_SYMBOL(d_hash_and_lookup); // å¯¼å‡ºd_hash_and_lookupå‡½æ•° 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * å½“ä¸€ä¸ªæ–‡ä»¶è¢«åˆ é™¤æ—¶ï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªé€‰é¡¹ï¼š * - å°†è¿™ä¸ªdentryè½¬æ¢ä¸ºä¸€ä¸ªè´Ÿçš„dentry * - å–æ¶ˆå“ˆå¸Œè¿™ä¸ªdentryå¹¶é‡Šæ”¾å®ƒ * * é€šå¸¸æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªæƒ³å°†å…¶è½¬æ¢ä¸ºè´Ÿçš„dentryï¼Œä½†å¦‚æœæœ‰å…¶ä»–äººæ­£åœ¨ä½¿ç”¨è¯¥dentryæˆ–è€…inodeï¼Œ * æˆ‘ä»¬å°±æ— æ³•è¿™æ ·åšï¼Œåªèƒ½å°†å…¶ä»å“ˆå¸Œé˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œå¹¶ç­‰å¾…å®ƒåœ¨æ²¡æœ‰ç”¨æˆ·æ—¶è¢«åˆ é™¤ *//** * d_delete - åˆ é™¤ä¸€ä¸ªdentry * @dentry: è¦åˆ é™¤çš„dentry * * å¦‚æœå¯èƒ½ï¼Œå°†dentryè½¬æ¢ä¸ºè´Ÿçš„dentryï¼Œå¦åˆ™ä»å“ˆå¸Œé˜Ÿåˆ—ä¸­ç§»é™¤å®ƒï¼Œä»¥ä¾¿ç¨ååˆ é™¤ */void d_delete(struct dentry *dentry)&#123; struct inode *inode = dentry-&gt;d_inode; spin_lock(&amp;inode-&gt;i_lock); // è·å–inodeçš„è‡ªæ—‹é” spin_lock(&amp;dentry-&gt;d_lock); // è·å–dentryçš„è‡ªæ—‹é” /* * æˆ‘ä»¬æ˜¯å”¯ä¸€çš„ç”¨æˆ·å—ï¼Ÿ */ if (dentry-&gt;d_lockref.count == 1) &#123; dentry-&gt;d_flags &amp;= ~DCACHE_CANT_MOUNT; // æ¸…é™¤dentryçš„DCACHE_CANT_MOUNTæ ‡å¿—ä½ dentry_unlink_inode(dentry); // è§£é™¤dentryä¸inodeçš„å…³è” &#125; else &#123; __d_drop(dentry); // ä»å“ˆå¸Œé˜Ÿåˆ—ä¸­ç§»é™¤dentry spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾dentryçš„è‡ªæ—‹é” spin_unlock(&amp;inode-&gt;i_lock); // é‡Šæ”¾inodeçš„è‡ªæ—‹é” &#125;&#125;EXPORT_SYMBOL(d_delete); // å¯¼å‡ºd_deleteå‡½æ•°ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨static void __d_rehash(struct dentry *entry)&#123; struct hlist_bl_head *b = d_hash(entry-&gt;d_name.hash); // è·å–å“ˆå¸Œæ¡¶ hlist_bl_lock(b); // é”å®šå“ˆå¸Œæ¡¶ hlist_bl_add_head_rcu(&amp;entry-&gt;d_hash, b); // å°†dentryæ·»åŠ åˆ°å“ˆå¸Œæ¡¶ä¸­ hlist_bl_unlock(b); // è§£é”å“ˆå¸Œæ¡¶&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * d_rehash - å°†ä¸€ä¸ªæ¡ç›®é‡æ–°æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­ * @entry: è¦æ·»åŠ åˆ°å“ˆå¸Œè¡¨çš„dentry * * æ ¹æ®dentryçš„åç§°å°†å…¶æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­ã€‚ */void d_rehash(struct dentry *entry)&#123; spin_lock(&amp;entry-&gt;d_lock); // è·å–dentryçš„è‡ªæ—‹é” __d_rehash(entry); // è°ƒç”¨å†…éƒ¨å‡½æ•°å°†dentryé‡æ–°æ·»åŠ åˆ°å“ˆå¸Œè¡¨ä¸­ spin_unlock(&amp;entry-&gt;d_lock); // é‡Šæ”¾dentryçš„è‡ªæ—‹é”&#125;EXPORT_SYMBOL(d_rehash); // å¯¼å‡ºd_rehashå‡½æ•°ï¼Œä½¿å…¶å¯è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨static inline unsigned start_dir_add(struct inode *dir)&#123; preempt_disable_nested(); // ç¦ç”¨æŠ¢å ï¼Œå¹¶è¿›å…¥åµŒå¥—æ¨¡å¼ for (;;) &#123; unsigned n = dir-&gt;i_dir_seq; if (!(n &amp; 1) &amp;&amp; cmpxchg(&amp;dir-&gt;i_dir_seq, n, n + 1) == n) return n; cpu_relax(); // CPUè‡ªæ—‹ç­‰å¾… &#125;&#125;static inline void end_dir_add(struct inode *dir, unsigned int n, wait_queue_head_t *d_wait)&#123; smp_store_release(&amp;dir-&gt;i_dir_seq, n + 2); // å­˜å‚¨å¹¶é‡Šæ”¾å†…å­˜å±éšœï¼Œæ›´æ–°i_dir_seqçš„å€¼ preempt_enable_nested(); // å¯ç”¨æŠ¢å ï¼Œå¹¶é€€å‡ºåµŒå¥—æ¨¡å¼ wake_up_all(d_wait); // å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰è¿›ç¨‹&#125;static void d_wait_lookup(struct dentry *dentry)&#123; if (d_in_lookup(dentry)) &#123; DECLARE_WAITQUEUE(wait, current); // å£°æ˜ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—é¡¹ add_wait_queue(dentry-&gt;d_wait, &amp;wait); // å°†ç­‰å¾…é˜Ÿåˆ—é¡¹æ·»åŠ åˆ°dentryçš„ç­‰å¾…é˜Ÿåˆ—ä¸­ do &#123; set_current_state(TASK_UNINTERRUPTIBLE); // è®¾ç½®å½“å‰è¿›ç¨‹çš„çŠ¶æ€ä¸ºä¸å¯ä¸­æ–­ spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾dentryçš„è‡ªæ—‹é” schedule(); // è¿›ç¨‹è°ƒåº¦ï¼Œåˆ‡æ¢åˆ°å…¶ä»–å¯è¿è¡Œçš„è¿›ç¨‹ spin_lock(&amp;dentry-&gt;d_lock); // è·å–dentryçš„è‡ªæ—‹é” &#125; while (d_in_lookup(dentry)); // å½“dentryå¤„äºæŸ¥æ‰¾çŠ¶æ€æ—¶å¾ªç¯æ‰§è¡Œ &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109struct dentry *d_alloc_parallel(struct dentry *parent, const struct qstr *name, wait_queue_head_t *wq)&#123; unsigned int hash = name-&gt;hash; struct hlist_bl_head *b = in_lookup_hash(parent, hash); struct hlist_bl_node *node; struct dentry *new = d_alloc(parent, name); struct dentry *dentry; unsigned seq, r_seq, d_seq; if (unlikely(!new)) return ERR_PTR(-ENOMEM);retry: rcu_read_lock(); seq = smp_load_acquire(&amp;parent-&gt;d_inode-&gt;i_dir_seq); r_seq = read_seqbegin(&amp;rename_lock); dentry = __d_lookup_rcu(parent, name, &amp;d_seq); if (unlikely(dentry)) &#123; if (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123; rcu_read_unlock(); goto retry; &#125; if (read_seqcount_retry(&amp;dentry-&gt;d_seq, d_seq)) &#123; rcu_read_unlock(); dput(dentry); goto retry; &#125; rcu_read_unlock(); dput(new); return dentry; &#125; if (unlikely(read_seqretry(&amp;rename_lock, r_seq))) &#123; rcu_read_unlock(); goto retry; &#125; if (unlikely(seq &amp; 1)) &#123; rcu_read_unlock(); goto retry; &#125; hlist_bl_lock(b); if (unlikely(READ_ONCE(parent-&gt;d_inode-&gt;i_dir_seq) != seq)) &#123; hlist_bl_unlock(b); rcu_read_unlock(); goto retry; &#125; /* * No changes for the parent since the beginning of d_lookup(). * Since all removals from the chain happen with hlist_bl_lock(), * any potential in-lookup matches are going to stay here until * we unlock the chain. All fields are stable in everything * we encounter. */ hlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) &#123; if (dentry-&gt;d_name.hash != hash) continue; if (dentry-&gt;d_parent != parent) continue; if (!d_same_name(dentry, parent, name)) continue; hlist_bl_unlock(b); /* now we can try to grab a reference */ if (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123; rcu_read_unlock(); goto retry; &#125; rcu_read_unlock(); /* * somebody is likely to be still doing lookup for it; * wait for them to finish */ spin_lock(&amp;dentry-&gt;d_lock); d_wait_lookup(dentry); /* * it&#x27;s not in-lookup anymore; in principle we should repeat * everything from dcache lookup, but it&#x27;s likely to be what * d_lookup() would&#x27;ve found anyway. If it is, just return it; * otherwise we really have to repeat the whole thing. */ if (unlikely(dentry-&gt;d_name.hash != hash)) goto mismatch; if (unlikely(dentry-&gt;d_parent != parent)) goto mismatch; if (unlikely(d_unhashed(dentry))) goto mismatch; if (unlikely(!d_same_name(dentry, parent, name))) goto mismatch; /* OK, it *is* a hashed match; return it */ spin_unlock(&amp;dentry-&gt;d_lock); dput(new); return dentry; &#125; rcu_read_unlock(); /* we can&#x27;t take -&gt;d_lock here; it&#x27;s OK, though. */ new-&gt;d_flags |= DCACHE_PAR_LOOKUP; new-&gt;d_wait = wq; hlist_bl_add_head_rcu(&amp;new-&gt;d_u.d_in_lookup_hash, b); hlist_bl_unlock(b); return new;mismatch: spin_unlock(&amp;dentry-&gt;d_lock); dput(dentry); goto retry;&#125;EXPORT_SYMBOL(d_alloc_parallel); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * - å–æ¶ˆå“ˆå¸ŒåŒ–çš„dentry * - æ£€ç´¢å¹¶æ¸…é™¤dentryä¸­çš„ç­‰å¾…é˜Ÿåˆ—å¤´ * - è¿”å›ç­‰å¾…é˜Ÿåˆ—å¤´ */static wait_queue_head_t *__d_lookup_unhash(struct dentry *dentry)&#123; wait_queue_head_t *d_wait; // ç­‰å¾…é˜Ÿåˆ—å¤´æŒ‡é’ˆ struct hlist_bl_head *b; // å“ˆå¸Œè¡¨å¤´æŒ‡é’ˆ lockdep_assert_held(&amp;dentry-&gt;d_lock); // æ–­è¨€dentryçš„é”å·²ç»è¢«æŒæœ‰ b = in_lookup_hash(dentry-&gt;d_parent, dentry-&gt;d_name.hash); // åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾dentryçš„çˆ¶ç›®å½•å’Œå“ˆå¸Œå€¼å¯¹åº”çš„è¡¨å¤´ hlist_bl_lock(b); // é”å®šå“ˆå¸Œè¡¨ dentry-&gt;d_flags &amp;= ~DCACHE_PAR_LOOKUP; // æ¸…é™¤dentryçš„æ ‡å¿—ä½ __hlist_bl_del(&amp;dentry-&gt;d_u.d_in_lookup_hash); // ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤dentry d_wait = dentry-&gt;d_wait; // è·å–ç­‰å¾…é˜Ÿåˆ—å¤´ dentry-&gt;d_wait = NULL; // æ¸…ç©ºç­‰å¾…é˜Ÿåˆ—å¤´ hlist_bl_unlock(b); // è§£é”å“ˆå¸Œè¡¨ INIT_HLIST_NODE(&amp;dentry-&gt;d_u.d_alias); // åˆå§‹åŒ–dentryçš„åˆ«åå“ˆå¸Œé“¾è¡¨èŠ‚ç‚¹ INIT_LIST_HEAD(&amp;dentry-&gt;d_lru); // åˆå§‹åŒ–dentryçš„LRUé“¾è¡¨å¤´ return d_wait; // è¿”å›ç­‰å¾…é˜Ÿåˆ—å¤´&#125;void __d_lookup_unhash_wake(struct dentry *dentry)&#123; spin_lock(&amp;dentry-&gt;d_lock); // è‡ªæ—‹é”ä½dentryçš„é” wake_up_all(__d_lookup_unhash(dentry)); // å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰è¿›ç¨‹ spin_unlock(&amp;dentry-&gt;d_lock); // è§£é”dentryçš„é”&#125;EXPORT_SYMBOL(__d_lookup_unhash_wake); // å¯¼å‡ºç¬¦å·__d_lookup_unhash_wake/* å¦‚æœinodeéç©ºï¼Œåˆ™æŒæœ‰inode-&gt;i_lock */static inline void __d_add(struct dentry *dentry, struct inode *inode)&#123; wait_queue_head_t *d_wait; // ç­‰å¾…é˜Ÿåˆ—å¤´æŒ‡é’ˆ struct inode *dir = NULL; // ç›®å½•inodeæŒ‡é’ˆ unsigned n; // ç›®å½•æ·»åŠ è®¡æ•°å™¨ spin_lock(&amp;dentry-&gt;d_lock); // è‡ªæ—‹é”ä½dentryçš„é” if (unlikely(d_in_lookup(dentry))) &#123; // å¦‚æœdentryæ­£åœ¨è¿›è¡ŒæŸ¥æ‰¾æ“ä½œ dir = dentry-&gt;d_parent-&gt;d_inode; // è·å–dentryçš„çˆ¶ç›®å½•inode n = start_dir_add(dir); // å¼€å§‹ç›®å½•æ·»åŠ æ“ä½œï¼Œè¿”å›ç›®å½•æ·»åŠ è®¡æ•°å™¨ d_wait = __d_lookup_unhash(dentry); // å–æ¶ˆå“ˆå¸ŒåŒ–dentryå¹¶è·å–ç­‰å¾…é˜Ÿåˆ—å¤´ &#125; if (inode) &#123; unsigned add_flags = d_flags_for_inode(inode); // è·å–inodeçš„æ ‡å¿—ä½ hlist_add_head(&amp;dentry-&gt;d_u.d_alias, &amp;inode-&gt;i_dentry); // å°†dentryæ·»åŠ åˆ°inodeçš„åˆ«åå“ˆå¸Œé“¾è¡¨å¤´ raw_write_seqcount_begin(&amp;dentry-&gt;d_seq); // å¼€å§‹å†™åºåˆ—è®¡æ•°å™¨ __d_set_inode_and_type(dentry, inode, add_flags); // è®¾ç½®dentryçš„inodeå’Œç±»å‹ raw_write_seqcount_end(&amp;dentry-&gt;d_seq); // ç»“æŸå†™åºåˆ—è®¡æ•°å™¨ fsnotify_update_flags(dentry); // æ›´æ–°dentryçš„æ ‡å¿—ä½ &#125; __d_rehash(dentry); // é‡æ–°å“ˆå¸ŒåŒ–dentry if (dir) end_dir_add(dir, n, d_wait); // ç»“æŸç›®å½•æ·»åŠ æ“ä½œï¼Œä¼ å…¥ç›®å½•inodeã€ç›®å½•æ·»åŠ è®¡æ•°å™¨å’Œç­‰å¾…é˜Ÿåˆ—å¤´ spin_unlock(&amp;dentry-&gt;d_lock); // è§£é”dentryçš„é” if (inode) spin_unlock(&amp;inode-&gt;i_lock); // è§£é”inodeçš„é”&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * d_add - å°†dentryæ·»åŠ åˆ°å“ˆå¸Œé˜Ÿåˆ— * @entry: è¦æ·»åŠ çš„dentry * @inode: è¦é™„åŠ åˆ°æ­¤dentryçš„inode * * è¿™å°†entryæ·»åŠ åˆ°å“ˆå¸Œé˜Ÿåˆ—å¹¶åˆå§‹åŒ–inodeã€‚ * entryå®é™…ä¸Šæ˜¯åœ¨d_alloc()æœŸé—´å¡«å……çš„ã€‚ */void d_add(struct dentry *entry, struct inode *inode)&#123; if (inode) &#123; security_d_instantiate(entry, inode); // è°ƒç”¨å®‰å…¨å‡½æ•°security_d_instantiateï¼Œå°†entryå’Œinodeå…³è”èµ·æ¥ spin_lock(&amp;inode-&gt;i_lock); // è·å–inodeçš„é” &#125; __d_add(entry, inode); // è°ƒç”¨å†…éƒ¨å‡½æ•°__d_addï¼Œå°†entryæ·»åŠ åˆ°å“ˆå¸Œé˜Ÿåˆ—ä¸­&#125;EXPORT_SYMBOL(d_add); // å¯¼å‡ºd_addç¬¦å·ï¼Œä½¿å…¶å¯åœ¨å…¶ä»–æ¨¡å—ä¸­ä½¿ç”¨/** * d_exact_alias - æŸ¥æ‰¾å¹¶å“ˆå¸Œä¸€ä¸ªç¡®åˆ‡çš„æœªå“ˆå¸Œåˆ«å * @entry: è¦æ·»åŠ çš„dentry * @inode: ä¸æ­¤dentryå…³è”çš„inode * * å¦‚æœå…·æœ‰ç›¸åŒåç§°/çˆ¶ç›®å½•å’Œæ‰€éœ€inodeçš„æœªå“ˆå¸Œdentryå·²ç»å­˜åœ¨ï¼Œåˆ™å“ˆå¸Œå¹¶è¿”å›å®ƒã€‚å¦åˆ™ï¼Œè¿”å›NULLã€‚ * * çˆ¶ç›®å½•åº”è¯¥è¢«é”å®šã€‚ */struct dentry *d_exact_alias(struct dentry *entry, struct inode *inode)&#123; struct dentry *alias; // å®šä¹‰ä¸€ä¸ªåˆ«ådentryæŒ‡é’ˆ unsigned int hash = entry-&gt;d_name.hash; // è·å–entryçš„åç§°å“ˆå¸Œå€¼ spin_lock(&amp;inode-&gt;i_lock); // è·å–inodeçš„é” hlist_for_each_entry(alias, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; // éå†inodeçš„dentryé“¾è¡¨ /* * è¿™é‡Œä¸éœ€è¦alias-&gt;d_lockï¼Œå› ä¸ºå…·æœ‰d_parent == entry-&gt;d_parentçš„åˆ«åä¸å—åç§°æˆ–çˆ¶ç›®å½•æ›´æ”¹çš„å½±å“ï¼Œå› ä¸ºæŒæœ‰çˆ¶ç›®å½•inode i_mutexã€‚ */ if (alias-&gt;d_name.hash != hash) // å¦‚æœåˆ«åçš„åç§°å“ˆå¸Œå€¼ä¸entryçš„ä¸ç›¸ç­‰ï¼Œåˆ™ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯ continue; if (alias-&gt;d_parent != entry-&gt;d_parent) // å¦‚æœåˆ«åçš„çˆ¶ç›®å½•ä¸entryçš„çˆ¶ç›®å½•ä¸ç›¸ç­‰ï¼Œåˆ™ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯ continue; if (!d_same_name(alias, entry-&gt;d_parent, &amp;entry-&gt;d_name)) // å¦‚æœåˆ«åä¸entryçš„åç§°ä¸ç›¸åŒï¼Œåˆ™ç»§ç»­ä¸‹ä¸€æ¬¡å¾ªç¯ continue; spin_lock(&amp;alias-&gt;d_lock); // è·å–åˆ«åçš„é” if (!d_unhashed(alias)) &#123; // å¦‚æœåˆ«åå·²ç»è¢«å“ˆå¸Œï¼Œåˆ™è§£é”å¹¶å°†åˆ«åç½®ä¸ºNULL spin_unlock(&amp;alias-&gt;d_lock); alias = NULL; &#125; else &#123; __dget_dlock(alias); // è·å–åˆ«åçš„å¼•ç”¨è®¡æ•° __d_rehash(alias); // å°†åˆ«åé‡æ–°å“ˆå¸Œ spin_unlock(&amp;alias-&gt;d_lock); // è§£é”åˆ«å &#125; spin_unlock(&amp;inode-&gt;i_lock); // è§£é”inode return alias; // è¿”å›æ‰¾åˆ°çš„åˆ«å &#125; spin_unlock(&amp;inode-&gt;i_lock); // è§£é”inode return NULL; // æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„åˆ«åï¼Œè¿”å›NULL&#125;EXPORT_SYMBOL(d_exact_alias); // å¯¼å‡ºd_exact_aliasç¬¦å·ï¼Œä½¿å…¶å¯åœ¨å…¶ä»–æ¨¡å—ä¸­ä½¿ç”¨ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void swap_names(struct dentry *dentry, struct dentry *target)&#123; if (unlikely(dname_external(target))) &#123; if (unlikely(dname_external(dentry))) &#123; /* * Both external: swap the pointers */ swap(target-&gt;d_name.name, dentry-&gt;d_name.name); // äº¤æ¢ä¸¤ä¸ªå¤–éƒ¨åç§°çš„æŒ‡é’ˆ &#125; else &#123; /* * dentry:internal, target:external. Steal target&#x27;s * storage and make target internal. */ memcpy(target-&gt;d_iname, dentry-&gt;d_name.name, dentry-&gt;d_name.len + 1); // å°†dentryçš„åç§°å¤åˆ¶åˆ°targetçš„å†…éƒ¨å­˜å‚¨ä¸­ dentry-&gt;d_name.name = target-&gt;d_name.name; // å°†targetçš„åç§°æŒ‡é’ˆèµ‹å€¼ç»™dentry target-&gt;d_name.name = target-&gt;d_iname; // å°†targetçš„å†…éƒ¨å­˜å‚¨æŒ‡é’ˆèµ‹å€¼ç»™targetçš„åç§°æŒ‡é’ˆ &#125; &#125; else &#123; if (unlikely(dname_external(dentry))) &#123; /* * dentry:external, target:internal. Give dentry&#x27;s * storage to target and make dentry internal */ memcpy(dentry-&gt;d_iname, target-&gt;d_name.name, target-&gt;d_name.len + 1); // å°†targetçš„åç§°å¤åˆ¶åˆ°dentryçš„å†…éƒ¨å­˜å‚¨ä¸­ target-&gt;d_name.name = dentry-&gt;d_name.name; // å°†dentryçš„åç§°æŒ‡é’ˆèµ‹å€¼ç»™target dentry-&gt;d_name.name = dentry-&gt;d_iname; // å°†dentryçš„å†…éƒ¨å­˜å‚¨æŒ‡é’ˆèµ‹å€¼ç»™dentryçš„åç§°æŒ‡é’ˆ &#125; else &#123; /* * Both are internal. */ unsigned int i; BUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long))); for (i = 0; i &lt; DNAME_INLINE_LEN / sizeof(long); i++) &#123; swap(((long *) &amp;dentry-&gt;d_iname)[i], ((long *) &amp;target-&gt;d_iname)[i]); // äº¤æ¢ä¸¤ä¸ªå†…éƒ¨åç§°çš„å€¼ &#125; &#125; &#125; swap(dentry-&gt;d_name.hash_len, target-&gt;d_name.hash_len); // äº¤æ¢ä¸¤ä¸ªåç§°çš„å“ˆå¸Œé•¿åº¦&#125;static void copy_name(struct dentry *dentry, struct dentry *target)&#123; struct external_name *old_name = NULL; if (unlikely(dname_external(dentry))) old_name = external_name(dentry); // è·å–dentryçš„å¤–éƒ¨åç§°æŒ‡é’ˆ if (unlikely(dname_external(target))) &#123; atomic_inc(&amp;external_name(target)-&gt;u.count); // å¢åŠ targetçš„å¤–éƒ¨åç§°å¼•ç”¨è®¡æ•° dentry-&gt;d_name = target-&gt;d_name; // å°†targetçš„åç§°èµ‹å€¼ç»™dentryçš„åç§° &#125; else &#123; memcpy(dentry-&gt;d_iname, target-&gt;d_name.name, target-&gt;d_name.len + 1); // å°†targetçš„åç§°å¤åˆ¶åˆ°dentryçš„å†…éƒ¨å­˜å‚¨ä¸­ dentry-&gt;d_name.name = dentry-&gt;d_iname; // å°†dentryçš„å†…éƒ¨å­˜å‚¨æŒ‡é’ˆèµ‹å€¼ç»™dentryçš„åç§°æŒ‡é’ˆ dentry-&gt;d_name.hash_len = target-&gt;d_name.hash_len; // å°†targetçš„åç§°å“ˆå¸Œé•¿åº¦èµ‹å€¼ç»™dentryçš„åç§°å“ˆå¸Œé•¿åº¦ &#125; if (old_name &amp;&amp; likely(atomic_dec_and_test(&amp;old_name-&gt;u.count))) kfree_rcu(old_name, u.head); // å‡å°‘æ—§çš„å¤–éƒ¨åç§°çš„å¼•ç”¨è®¡æ•°ï¼Œå¹¶åœ¨å¼•ç”¨è®¡æ•°ä¸º0æ—¶é‡Šæ”¾å†…å­˜&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/* * __d_move - ç§»åŠ¨ä¸€ä¸ªdentry * @dentry: è¦ç§»åŠ¨çš„dentry * @target: æ–°çš„dentry * @exchange: äº¤æ¢è¿™ä¸¤ä¸ªdentry * * æ›´æ–°dcacheä»¥åæ˜ æ–‡ä»¶åçš„ç§»åŠ¨ã€‚è´Ÿçš„dcacheæ¡ç›®ä¸åº”ä»¥è¿™ç§æ–¹å¼ç§»åŠ¨ã€‚è°ƒç”¨è€…å¿…é¡»æŒæœ‰rename_lockã€æºç›®å½•å’Œç›®æ ‡ç›®å½•çš„i_mutexï¼Œä»¥åŠå¦‚æœå®ƒä»¬ä¸åŒï¼Œåˆ™æŒæœ‰sb-&gt;s_vfs_rename_mutexã€‚å‚è§lock_rename()ã€‚ */static void __d_move(struct dentry *dentry, struct dentry *target, bool exchange)&#123; // å£°æ˜å˜é‡ struct dentry *old_parent, *p; wait_queue_head_t *d_wait; struct inode *dir = NULL; unsigned n; // æ£€æŸ¥dentryæ˜¯å¦æœ‰å…³è”çš„inode WARN_ON(!dentry-&gt;d_inode); // æ£€æŸ¥dentryå’Œtargetæ˜¯å¦ç›¸åŒ if (WARN_ON(dentry == target)) return; // æ£€æŸ¥targetæ˜¯å¦æ˜¯dentryçš„ç¥–å…ˆ BUG_ON(d_ancestor(target, dentry)); // ä¿å­˜dentryçš„æ—§çˆ¶ç›®å½• old_parent = dentry-&gt;d_parent; // æ£€æŸ¥targetæ˜¯å¦æ˜¯dentryçš„ç¥–å…ˆæˆ–è€…dentryæ˜¯å¦æ˜¯targetçš„ç¥–å…ˆ p = d_ancestor(old_parent, target); // å¦‚æœdentryæ˜¯æ ¹ç›®å½• if (IS_ROOT(dentry)) &#123; BUG_ON(p); // é”å®štargetçš„çˆ¶ç›®å½• spin_lock(&amp;target-&gt;d_parent-&gt;d_lock); &#125; else if (!p) &#123; /* targetä¸æ˜¯dentry-&gt;d_parentçš„åä»£ */ // é”å®štargetçš„çˆ¶ç›®å½• spin_lock(&amp;target-&gt;d_parent-&gt;d_lock); // é”å®šæ—§çˆ¶ç›®å½• spin_lock_nested(&amp;old_parent-&gt;d_lock, DENTRY_D_LOCK_NESTED); &#125; else &#123; BUG_ON(p == dentry); // é”å®šæ—§çˆ¶ç›®å½• spin_lock(&amp;old_parent-&gt;d_lock); // å¦‚æœpä¸ç­‰äºtargetï¼Œåˆ™é”å®štargetçš„çˆ¶ç›®å½• if (p != target) spin_lock_nested(&amp;target-&gt;d_parent-&gt;d_lock, DENTRY_D_LOCK_NESTED); &#125; // é”å®šdentry spin_lock_nested(&amp;dentry-&gt;d_lock, 2); // é”å®štarget spin_lock_nested(&amp;target-&gt;d_lock, 3); // å¦‚æœtargetæ­£åœ¨è¿›è¡ŒæŸ¥æ‰¾æ“ä½œ if (unlikely(d_in_lookup(target))) &#123; // è·å–targetçš„çˆ¶ç›®å½•çš„inode dir = target-&gt;d_parent-&gt;d_inode; // å¼€å§‹ç›®å½•æ·»åŠ æ“ä½œ n = start_dir_add(dir); // è·å–ç­‰å¾…é˜Ÿåˆ—å¤´ d_wait = __d_lookup_unhash(target); &#125; // å¼€å§‹å†™åºåˆ—è®¡æ•° write_seqcount_begin(&amp;dentry-&gt;d_seq); // å¼€å§‹åµŒå¥—å†™åºåˆ—è®¡æ•° write_seqcount_begin_nested(&amp;target-&gt;d_seq, DENTRY_D_LOCK_NESTED); /* å–æ¶ˆå“ˆå¸Œä¸¤ä¸ªdentry */ // å¦‚æœdentryæ²¡æœ‰è¢«å–æ¶ˆå“ˆå¸Œ if (!d_unhashed(dentry)) ___d_drop(dentry); // å¦‚æœtargetæ²¡æœ‰è¢«å–æ¶ˆå“ˆå¸Œ if (!d_unhashed(target)) ___d_drop(target); /* ... å¹¶åœ¨æ ‘ä¸­äº¤æ¢å®ƒä»¬ */ // è®¾ç½®dentryçš„çˆ¶ç›®å½•ä¸ºtargetçš„çˆ¶ç›®å½• dentry-&gt;d_parent = target-&gt;d_parent; // å¦‚æœä¸æ˜¯äº¤æ¢æ“ä½œ if (!exchange) &#123; // å¤åˆ¶åç§° copy_name(dentry, target); // è®¾ç½®targetçš„å“ˆå¸Œå‰é©±ä¸ºNULL target-&gt;d_hash.pprev = NULL; // å¢åŠ dentryçš„çˆ¶ç›®å½•çš„é”å¼•ç”¨è®¡æ•° dentry-&gt;d_parent-&gt;d_lockref.count++; // å¦‚æœdentryä¸æ˜¯æ—§çˆ¶ç›®å½• if (dentry != old_parent) /* ä¸æ˜¯IS_ROOT */ // å‡å°‘æ—§çˆ¶ç›®å½•çš„é”å¼•ç”¨è®¡æ•° WARN_ON(!--old_parent-&gt;d_lockref.count); &#125; else &#123; // è®¾ç½®targetçš„çˆ¶ç›®å½•ä¸ºæ—§çˆ¶ç›®å½• target-&gt;d_parent = old_parent; // äº¤æ¢åç§° swap_names(dentry, target); // å°†targetä»targetçš„çˆ¶ç›®å½•çš„å­ç›®å½•åˆ—è¡¨ä¸­ç§»åŠ¨åˆ°dentryçš„çˆ¶ç›®å½•çš„å­ç›®å½•åˆ—è¡¨ä¸­ list_move(&amp;target-&gt;d_child, &amp;target-&gt;d_parent-&gt;d_subdirs); // é‡æ–°å“ˆå¸Œtarget __d_rehash(target); // æ›´æ–°targetçš„æ ‡å¿—ä½ fsnotify_update_flags(target); &#125; // å°†dentryä»dentryçš„çˆ¶ç›®å½•çš„å­ç›®å½•åˆ—è¡¨ä¸­ç§»åŠ¨åˆ°targetçš„çˆ¶ç›®å½•çš„å­ç›®å½•åˆ—è¡¨ä¸­ list_move(&amp;dentry-&gt;d_child, &amp;dentry-&gt;d_parent-&gt;d_subdirs); // é‡æ–°å“ˆå¸Œdentry __d_rehash(dentry); // æ›´æ–°dentryçš„æ ‡å¿—ä½ fsnotify_update_flags(dentry); // å¤„ç†dentryçš„ç§»åŠ¨æ“ä½œ fscrypt_handle_d_move(dentry); // ç»“æŸå†™åºåˆ—è®¡æ•° write_seqcount_end(&amp;target-&gt;d_seq); // ç»“æŸå†™åºåˆ—è®¡æ•° write_seqcount_end(&amp;dentry-&gt;d_seq); // å¦‚æœdirä¸ä¸ºç©º if (dir) // ç»“æŸç›®å½•æ·»åŠ æ“ä½œ end_dir_add(dir, n, d_wait); // å¦‚æœdentryçš„çˆ¶ç›®å½•ä¸ç­‰äºæ—§çˆ¶ç›®å½• if (dentry-&gt;d_parent != old_parent) // è§£é”dentryçš„çˆ¶ç›®å½• spin_unlock(&amp;dentry-&gt;d_parent-&gt;d_lock); // å¦‚æœdentryä¸ç­‰äºæ—§çˆ¶ç›®å½• if (dentry != old_parent) // è§£é”æ—§çˆ¶ç›®å½• spin_unlock(&amp;old_parent-&gt;d_lock); // è§£é”target spin_unlock(&amp;target-&gt;d_lock); // è§£é”dentry spin_unlock(&amp;dentry-&gt;d_lock);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * d_move - ç§»åŠ¨ä¸€ä¸ªdentry * @dentry: è¦ç§»åŠ¨çš„dentry * @target: æ–°çš„dentry * * æ›´æ–°dcacheä»¥åæ˜ æ–‡ä»¶åçš„ç§»åŠ¨ã€‚è´Ÿçš„dcacheæ¡ç›®ä¸åº”ä»¥è¿™ç§æ–¹å¼ç§»åŠ¨ã€‚è¯·å‚é˜…__d_moveçš„é”å®šè¦æ±‚ã€‚ */void d_move(struct dentry *dentry, struct dentry *target)&#123; write_seqlock(&amp;rename_lock); // è·å–é‡å‘½åé” __d_move(dentry, target, false); // è°ƒç”¨å†…éƒ¨å‡½æ•°__d_moveè¿›è¡Œç§»åŠ¨ write_sequnlock(&amp;rename_lock); // é‡Šæ”¾é‡å‘½åé”&#125;EXPORT_SYMBOL(d_move); // å¯¼å‡ºd_moveå‡½æ•°/* * d_exchange - äº¤æ¢ä¸¤ä¸ªdentry * @dentry1: ç¬¬ä¸€ä¸ªdentry * @dentry2: ç¬¬äºŒä¸ªdentry */void d_exchange(struct dentry *dentry1, struct dentry *dentry2)&#123; write_seqlock(&amp;rename_lock); // è·å–é‡å‘½åé” WARN_ON(!dentry1-&gt;d_inode); // å¦‚æœdentry1çš„d_inodeä¸ºç©ºï¼Œåˆ™å‘å‡ºè­¦å‘Š WARN_ON(!dentry2-&gt;d_inode); // å¦‚æœdentry2çš„d_inodeä¸ºç©ºï¼Œåˆ™å‘å‡ºè­¦å‘Š WARN_ON(IS_ROOT(dentry1)); // å¦‚æœdentry1æ˜¯æ ¹ç›®å½•ï¼Œåˆ™å‘å‡ºè­¦å‘Š WARN_ON(IS_ROOT(dentry2)); // å¦‚æœdentry2æ˜¯æ ¹ç›®å½•ï¼Œåˆ™å‘å‡ºè­¦å‘Š __d_move(dentry1, dentry2, true); // è°ƒç”¨å†…éƒ¨å‡½æ•°__d_moveè¿›è¡Œäº¤æ¢ write_sequnlock(&amp;rename_lock); // é‡Šæ”¾é‡å‘½åé”&#125;/** * d_ancestor - æœç´¢ç¥–å…ˆ * @p1: ç¥–å…ˆdentry * @p2: å­dentry * * å¦‚æœp1æ˜¯p2çš„ç¥–å…ˆï¼Œåˆ™è¿”å›p2çš„ç¥–å…ˆdentryï¼Œå¦åˆ™è¿”å›NULLã€‚ */struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)&#123; struct dentry *p; for (p = p2; !IS_ROOT(p); p = p-&gt;d_parent) &#123; // ä»p2å¼€å§‹å‘ä¸Šéå†dentryçš„çˆ¶èŠ‚ç‚¹ï¼Œç›´åˆ°æ ¹èŠ‚ç‚¹ if (p-&gt;d_parent == p1) // å¦‚æœæ‰¾åˆ°p1ä½œä¸ºp2çš„çˆ¶èŠ‚ç‚¹ï¼Œåˆ™è¿”å›p2çš„ç¥–å…ˆdentry return p; &#125; return NULL; // å¦‚æœp1ä¸æ˜¯p2çš„ç¥–å…ˆï¼Œåˆ™è¿”å›NULL&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * This helper attempts to cope with remotely renamed directories * è¿™ä¸ªè¾…åŠ©å‡½æ•°è¯•å›¾å¤„ç†è¿œç¨‹é‡å‘½åçš„ç›®å½• * * It assumes that the caller is already holding * dentry-&gt;d_parent-&gt;d_inode-&gt;i_mutex, and rename_lock * å®ƒå‡è®¾è°ƒç”¨è€…å·²ç»æŒæœ‰dentry-&gt;d_parent-&gt;d_inode-&gt;i_mutexå’Œrename_lock * * Note: If ever the locking in lock_rename() changes, then please * remember to update this too... * æ³¨æ„ï¼šå¦‚æœlock_rename()ä¸­çš„é”å®šå‘ç”Ÿå˜åŒ–ï¼Œè¯·è®°å¾—æ›´æ–°æ­¤å¤„... */static int __d_unalias(struct inode *inode, struct dentry *dentry, struct dentry *alias)&#123; struct mutex *m1 = NULL; // äº’æ–¥é”m1 struct rw_semaphore *m2 = NULL; // è¯»å†™ä¿¡å·é‡m2 int ret = -ESTALE; // è¿”å›å€¼ï¼Œé»˜è®¤ä¸ºESTALE /* If alias and dentry share a parent, then no extra locks required */ /* å¦‚æœaliaså’Œdentryå…±äº«ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ï¼Œåˆ™ä¸éœ€è¦é¢å¤–çš„é” */ if (alias-&gt;d_parent == dentry-&gt;d_parent) goto out_unalias; // è·³è½¬åˆ°out_unaliasæ ‡ç­¾ /* See lock_rename() */ /* å‚è§lock_rename() */ if (!mutex_trylock(&amp;dentry-&gt;d_sb-&gt;s_vfs_rename_mutex)) goto out_err; // å¦‚æœæ— æ³•è·å–vfs_rename_mutexé”ï¼Œåˆ™è·³è½¬åˆ°out_erræ ‡ç­¾ m1 = &amp;dentry-&gt;d_sb-&gt;s_vfs_rename_mutex; // å°†vfs_rename_mutexé”èµ‹å€¼ç»™m1 if (!inode_trylock_shared(alias-&gt;d_parent-&gt;d_inode)) goto out_err; // å¦‚æœæ— æ³•è·å–aliasçš„çˆ¶èŠ‚ç‚¹çš„inodeçš„å…±äº«é”ï¼Œåˆ™è·³è½¬åˆ°out_erræ ‡ç­¾ m2 = &amp;alias-&gt;d_parent-&gt;d_inode-&gt;i_rwsem; // å°†aliasçš„çˆ¶èŠ‚ç‚¹çš„inodeçš„è¯»å†™ä¿¡å·é‡èµ‹å€¼ç»™m2out_unalias: __d_move(alias, dentry, false); // è°ƒç”¨å†…éƒ¨å‡½æ•°__d_moveè¿›è¡Œç§»åŠ¨ ret = 0; // è®¾ç½®è¿”å›å€¼ä¸º0ï¼Œè¡¨ç¤ºæˆåŠŸout_err: if (m2) up_read(m2); // é‡Šæ”¾è¯»å–é”m2 if (m1) mutex_unlock(m1); // é‡Šæ”¾äº’æ–¥é”m1 return ret; // è¿”å›ç»“æœ&#125; 123456789101112131415161718192021222324252627282930313233343536373839/** * d_splice_alias - å°†ä¸€ä¸ªæ–­å¼€çš„dentryæ‹¼æ¥åˆ°æ ‘ä¸­ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ * @inode: å¯èƒ½æœ‰ä¸€ä¸ªæ–­å¼€çš„dentryçš„inode * @dentry: æˆ‘ä»¬æƒ³è¦æŒ‡å‘è¯¥inodeçš„ä¸€ä¸ªè´Ÿçš„dentry * * å¦‚æœinodeæ˜¯ä¸€ä¸ªç›®å½•å¹¶ä¸”æœ‰ä¸€ä¸ªIS_ROOTåˆ«åï¼Œåˆ™å°†å…¶d_moveåˆ°ç»™å®šçš„dentryçš„ä½ç½®å¹¶è¿”å›å®ƒï¼Œå¦åˆ™åªæ˜¯å°†inodeæ·»åŠ åˆ°dentryä¸­å¹¶è¿”å›NULLã€‚ * * å¦‚æœæ‰¾åˆ°ä¸€ä¸ªéIS_ROOTçš„ç›®å½•ï¼Œåˆ™æ–‡ä»¶ç³»ç»Ÿå·²æŸåï¼Œæˆ‘ä»¬åº”è¯¥æŠ¥é”™ï¼šç›®å½•ä¸èƒ½æœ‰å¤šä¸ªåˆ«åã€‚ * * è¿™åœ¨ä»»ä½•å¯å¯¼å‡ºçš„æ–‡ä»¶ç³»ç»Ÿï¼ˆé€šè¿‡knfsdï¼‰çš„æŸ¥æ‰¾ä¾‹ç¨‹ä¸­æ˜¯å¿…éœ€çš„ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥æœ‰æ•ˆåœ°æ„å»ºåˆ°ç›®å½•çš„dcacheè·¯å¾„ã€‚ * * å¦‚æœæ‰¾åˆ°å¹¶ç§»åŠ¨äº†ä¸€ä¸ªdentryï¼Œåˆ™è¿”å›å®ƒã€‚å¦åˆ™è¿”å›NULLã€‚ * ... æ£€æŸ¥dentryæ˜¯å¦å·²ç»è¢«å“ˆå¸Œï¼Œä»…åœ¨æœ€åä¸€ç§æƒ…å†µä¸‹è¿›è¡Œæ£€æŸ¥ã€‚ */struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)&#123; if (IS_ERR(inode)) return ERR_CAST(inode); BUG_ON(!d_unhashed(dentry)); if (inode-&gt;i_mode &amp; S_IFDIR) &#123; // å¦‚æœinodeæ˜¯ä¸€ä¸ªç›®å½• struct dentry *alias = d_find_alias(inode); // æŸ¥æ‰¾inodeçš„åˆ«å if (alias) &#123; // å¦‚æœæ‰¾åˆ°åˆ«å if (IS_ROOT(alias)) &#123; // å¦‚æœåˆ«åæ˜¯æ ¹ç›®å½• struct dentry *moved = d_move(alias, dentry); // å°†åˆ«åç§»åŠ¨åˆ°ç»™å®šçš„dentryçš„ä½ç½® if (moved) return moved; // è¿”å›ç§»åŠ¨åçš„dentry &#125; else &#123; WARN_ON(1); // æ–‡ä»¶ç³»ç»Ÿå·²æŸåï¼Œç›®å½•ä¸èƒ½æœ‰å¤šä¸ªåˆ«å return ERR_PTR(-EIO); // è¿”å›é”™è¯¯æŒ‡é’ˆ &#125; &#125; &#125; d_add(dentry, inode); // å°†inodeæ·»åŠ åˆ°dentryä¸­ return NULL; // è¿”å›NULLï¼Œè¡¨ç¤ºæ²¡æœ‰ç§»åŠ¨dentry&#125;EXPORT_SYMBOL(d_splice_alias); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * Test whether new_dentry is a subdirectory of old_dentry. * æµ‹è¯•new_dentryæ˜¯å¦æ˜¯old_dentryçš„å­ç›®å½•ã€‚ * * Trivially implemented using the dcache structure * ä½¿ç”¨dcacheç»“æ„ç®€å•å®ç° *//** * is_subdir - is new dentry a subdirectory of old_dentry * is_subdir - åˆ¤æ–­new_dentryæ˜¯å¦æ˜¯old_dentryçš„å­ç›®å½• * @new_dentry: new dentry * @old_dentry: old dentry * * Returns true if new_dentry is a subdirectory of the parent (at any depth). * è¿”å›trueï¼Œå¦‚æœnew_dentryæ˜¯çˆ¶ç›®å½•çš„å­ç›®å½•ï¼ˆåœ¨ä»»ä½•æ·±åº¦ï¼‰ã€‚ * Returns false otherwise. * å¦åˆ™è¿”å›falseã€‚ * Caller must ensure that &quot;new_dentry&quot; is pinned before calling is_subdir() * è°ƒç”¨è€…å¿…é¡»ç¡®ä¿åœ¨è°ƒç”¨is_subdir()ä¹‹å‰&quot;new_dentry&quot;å·²ç»è¢«å›ºå®šã€‚ */bool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)&#123; bool result; unsigned seq; if (new_dentry == old_dentry) return true; // å¦‚æœnew_dentryå’Œold_dentryç›¸ç­‰ï¼Œåˆ™è¿”å›true do &#123; /* for restarting inner loop in case of seq retry */ seq = read_seqbegin(&amp;rename_lock); // è¯»å–åºåˆ—å· /* * Need rcu_readlock ... to protect against the d_parent trashing * due to d_move */ rcu_read_lock(); // è·å–RCUè¯»é” if (d_ancestor(old_dentry, new_dentry)) result = true; // å¦‚æœnew_dentryæ˜¯old_dentryçš„ç¥–å…ˆç›®å½•ï¼Œåˆ™è®¾ç½®resultä¸ºtrue else result = false; // å¦åˆ™è®¾ç½®resultä¸ºfalse rcu_read_unlock(); // é‡Šæ”¾RCUè¯»é” &#125; while (read_seqretry(&amp;rename_lock, seq)); // å¦‚æœåºåˆ—å·é‡è¯•ï¼Œåˆ™é‡æ–°æ‰§è¡Œå¾ªç¯ return result; // è¿”å›ç»“æœ&#125;EXPORT_SYMBOL(is_subdir); // å¯¼å‡ºis_subdirç¬¦å·static enum d_walk_ret d_genocide_kill(void *data, struct dentry *dentry)&#123; struct dentry *root = data; // è·å–æ ¹èŠ‚ç‚¹ if (dentry != root) &#123; // å¦‚æœdentryä¸æ˜¯æ ¹èŠ‚ç‚¹ if (d_unhashed(dentry) || !dentry-&gt;d_inode) // å¦‚æœdentryæœªå“ˆå¸Œæˆ–è€…æ²¡æœ‰å…³è”çš„inode return D_WALK_SKIP; // è·³è¿‡è¯¥dentry if (!(dentry-&gt;d_flags &amp; DCACHE_GENOCIDE)) &#123; // å¦‚æœdentryçš„æ ‡å¿—ä½ä¸­æ²¡æœ‰DCACHE_GENOCIDEæ ‡å¿— dentry-&gt;d_flags |= DCACHE_GENOCIDE; // è®¾ç½®dentryçš„æ ‡å¿—ä½ä¸ºDCACHE_GENOCIDE dentry-&gt;d_lockref.count--; // å‡å°‘dentryçš„é”å¼•ç”¨è®¡æ•° &#125; &#125; return D_WALK_CONTINUE; // è¿”å›D_WALK_CONTINUEï¼Œè¡¨ç¤ºç»§ç»­éå†&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void d_genocide(struct dentry *parent)&#123; // éå†çˆ¶ç›®å½•ä¸‹çš„æ‰€æœ‰ç›®å½•é¡¹ï¼Œå¹¶è°ƒç”¨d_genocide_killå‡½æ•° d_walk(parent, parent, d_genocide_kill);&#125;EXPORT_SYMBOL(d_genocide);void d_tmpfile(struct file *file, struct inode *inode)&#123; // è·å–æ–‡ä»¶çš„ç›®å½•é¡¹ struct dentry *dentry = file-&gt;f_path.dentry; // å‡å°‘inodeçš„é“¾æ¥è®¡æ•° inode_dec_link_count(inode); // æ£€æŸ¥ç›®å½•é¡¹çš„åç§°æ˜¯å¦ç­‰äºç›®å½•é¡¹çš„å†…éƒ¨åç§° // æ£€æŸ¥ç›®å½•é¡¹æ˜¯å¦æœªåœ¨åˆ«åå“ˆå¸Œè¡¨ä¸­ // æ£€æŸ¥ç›®å½•é¡¹æ˜¯å¦å·²è¢«åˆ é™¤ BUG_ON(dentry-&gt;d_name.name != dentry-&gt;d_iname || !hlist_unhashed(&amp;dentry-&gt;d_u.d_alias) || !d_unlinked(dentry)); // è·å–ç›®å½•é¡¹çš„çˆ¶ç›®å½•é”å’Œç›®å½•é¡¹é” spin_lock(&amp;dentry-&gt;d_parent-&gt;d_lock); spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); // å°†inodeçš„ç¼–å·è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶æ›´æ–°ç›®å½•é¡¹çš„åç§°å’Œå†…éƒ¨åç§° dentry-&gt;d_name.len = sprintf(dentry-&gt;d_iname, &quot;#%llu&quot;, (unsigned long long)inode-&gt;i_ino); // é‡Šæ”¾ç›®å½•é¡¹é”å’Œçˆ¶ç›®å½•é” spin_unlock(&amp;dentry-&gt;d_lock); spin_unlock(&amp;dentry-&gt;d_parent-&gt;d_lock); // åœ¨ç›®å½•é¡¹ä¸­å®ä¾‹åŒ–inode d_instantiate(dentry, inode);&#125;EXPORT_SYMBOL(d_tmpfile);static __initdata unsigned long dhash_entries;// è®¾ç½®dhash_entriesçš„å€¼static int __init set_dhash_entries(char *str)&#123; if (!str) return 0; dhash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// åœ¨å†…æ ¸å¯åŠ¨æ—¶è®¾ç½®dhash_entriesçš„å€¼__setup(&quot;dhash_entries=&quot;, set_dhash_entries);static void __init dcache_init_early(void)&#123; // å¦‚æœå“ˆå¸Œåˆ†å¸ƒåœ¨NUMAèŠ‚ç‚¹ä¸Šï¼Œåˆ™å»¶è¿Ÿå“ˆå¸Œåˆ†é…ç›´åˆ°vmallocç©ºé—´å¯ç”¨ if (hashdist) return; // åˆ†é…dentryå“ˆå¸Œè¡¨ dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_EARLY | HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374static void __init dcache_init(void)&#123; /* * å¯ä»¥ä¸ºç¨³å®šçŠ¶æ€ï¼ˆå¦‚åˆ—è¡¨ï¼‰æ·»åŠ æ„é€ å‡½æ•°ï¼Œä½†ç”±äºdcacheçš„ç¼“å­˜ç‰¹æ€§ï¼Œå¯èƒ½ä¸å€¼å¾—è¿™æ ·åšã€‚ */ // åˆ›å»ºdentryç¼“å­˜ dentry_cache = KMEM_CACHE_USERCOPY(dentry, SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | SLAB_MEM_SPREAD | SLAB_ACCOUNT, d_iname); /* å¦‚æœåœ¨dcache_init_earlyä¸­è®¾ç½®äº†å“ˆå¸Œè¡¨ï¼Œåˆ™ç›´æ¥è¿”å› */ if (!hashdist) return; // åˆ†é…dentryå“ˆå¸Œè¡¨ dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125;/* ç”¨äº__getname()å‡½æ•°çš„SLABç¼“å­˜ */struct kmem_cache *names_cachep __read_mostly;EXPORT_SYMBOL(names_cachep);void __init vfs_caches_init_early(void)&#123; int i; // åˆå§‹åŒ–in_lookup_hashtableæ•°ç»„ä¸­çš„æ¯ä¸ªå“ˆå¸Œè¡¨å¤´ for (i = 0; i &lt; ARRAY_SIZE(in_lookup_hashtable); i++) INIT_HLIST_BL_HEAD(&amp;in_lookup_hashtable[i]); // åˆå§‹åŒ–dcache dcache_init_early(); // åˆå§‹åŒ–inode inode_init_early();&#125;void __init vfs_caches_init(void)&#123; // åˆ›å»ºnames_cachepç¼“å­˜ names_cachep = kmem_cache_create_usercopy(&quot;names_cache&quot;, PATH_MAX, 0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, 0, PATH_MAX, NULL); // åˆå§‹åŒ–dcache dcache_init(); // åˆå§‹åŒ–inode inode_init(); // åˆå§‹åŒ–files files_init(); // åˆå§‹åŒ–files_maxfiles files_maxfiles_init(); // åˆå§‹åŒ–mnt mnt_init(); // åˆå§‹åŒ–bdevç¼“å­˜ bdev_cache_init(); // åˆå§‹åŒ–chrdev chrdev_init();&#125; 1","categories":[],"tags":[]},{"title":"å­¦ä¹  Linux /fs/namei.cæºç åˆ†æ","slug":"å­¦ä¹ -Linux-fs-namei-cæºç åˆ†æ","date":"2023-07-29T01:11:29.000Z","updated":"2023-08-20T10:35:57.890Z","comments":true,"path":"2023/07/29/å­¦ä¹ -Linux-fs-namei-cæºç åˆ†æ/","link":"","permalink":"http://example.com/2023/07/29/%E5%AD%A6%E4%B9%A0-Linux-fs-namei-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"namei.c - fs&#x2F;namei.c - Linux source code (v6.3.7) - Bootlin 12#define EMBEDDED_NAME_MAX (PATH_MAX - offsetof(struct filename, iname))// å®šä¹‰ EMBEDDED_NAME_MAXï¼Œè¿™æ˜¯åµŒå…¥å¼æ–‡ä»¶åçš„æœ€å¤§é•¿åº¦ã€‚é•¿åº¦ç­‰äº PATH_MAXï¼ˆä¸€ä¸ªè·¯å¾„çš„æœ€å¤§é•¿åº¦ï¼‰å‡å» struct filename ä¸­ iname å­—æ®µçš„åç§»é‡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118struct filename *getname_flags(const char __user *filename, int flags, int *empty)// è¿™ä¸ªå‡½æ•°æ˜¯ä»ç”¨æˆ·ç©ºé—´è·å–æ–‡ä»¶åï¼Œå¹¶å°†å…¶å¤åˆ¶åˆ°å†…æ ¸ç©ºé—´ã€‚å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šç”¨æˆ·æä¾›çš„æ–‡ä»¶åï¼Œä¸€ç»„æ ‡å¿—ï¼Œä»¥åŠä¸€ä¸ªæŒ‡å‘æ•´æ•°çš„æŒ‡é’ˆï¼Œç”¨äºæŒ‡ç¤ºè·¯å¾„æ˜¯å¦ä¸ºç©ºã€‚&#123; struct filename *result; char *kname; int len; // å®šä¹‰ä¸‰ä¸ªå˜é‡ï¼šä¸€ä¸ªæŒ‡å‘ struct filename çš„æŒ‡é’ˆï¼Œä¸€ä¸ªå­—ç¬¦æŒ‡é’ˆï¼Œä»¥åŠä¸€ä¸ªæ•´æ•°ã€‚ result = audit_reusename(filename); // å°è¯•é‡ç”¨ç»™å®šçš„æ–‡ä»¶åã€‚å¦‚æœæˆåŠŸï¼Œè¿”å›æŒ‡å‘é‡ç”¨çš„æ–‡ä»¶åçš„æŒ‡é’ˆã€‚ if (result) return result; // å¦‚æœé‡ç”¨æˆåŠŸï¼Œè¿”å›ç»“æœã€‚ result = __getname(); // å°è¯•ä»åå­—ç¼“å­˜ä¸­è·å–ä¸€ä¸ªæ–°çš„æ–‡ä»¶åã€‚ if (unlikely(!result)) return ERR_PTR(-ENOMEM); // å¦‚æœæ— æ³•è·å–æ–°çš„æ–‡ä»¶åï¼ˆå¯èƒ½æ˜¯å› ä¸ºå†…å­˜ä¸è¶³ï¼‰ï¼Œåˆ™è¿”å›é”™è¯¯ã€‚ kname = (char *)result-&gt;iname; // è·å–æ–°æ–‡ä»¶åçš„ iname å­—æ®µï¼Œè¿™æ˜¯ä¸€ä¸ªå†…éƒ¨çš„åå­—ã€‚ result-&gt;name = kname; // å°†å†…éƒ¨åå­—èµ‹ç»™å¤–éƒ¨åå­—ã€‚ len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX); // å°è¯•ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æ–‡ä»¶ååˆ°å†…æ ¸ç©ºé—´ã€‚æœ€å¤šå¤åˆ¶ EMBEDDED_NAME_MAX ä¸ªå­—ç¬¦ã€‚ if (unlikely(len &lt; 0)) &#123; __putname(result); // å¦‚æœå¤åˆ¶å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰è·å–çš„æ–‡ä»¶åã€‚ return ERR_PTR(len); // è¿”å›é”™è¯¯ã€‚ &#125; if (unlikely(len == EMBEDDED_NAME_MAX)) &#123; const size_t size = offsetof(struct filename, iname[1]); // å¦‚æœå¤åˆ¶çš„é•¿åº¦ç­‰äº EMBEDDED_NAME_MAXï¼Œéœ€è¦é‡æ–°åˆ†é…å†…å­˜ã€‚è®¡ç®—æ–°çš„å¤§å°ã€‚ kname = (char *)result; // ä¿å­˜å½“å‰çš„ç»“æœã€‚ result = kzalloc(size, GFP_KERNEL); // ä¸ºæ–°çš„æ–‡ä»¶ååˆ†é…å†…å­˜ã€‚ if (unlikely(!result)) &#123; __putname(kname); // å¦‚æœåˆ†é…å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰çš„ç»“æœã€‚ return ERR_PTR(-ENOMEM); // è¿”å›é”™è¯¯ã€‚ &#125; result-&gt;name = kname; // å°†åå­—èµ‹ç»™æ–°çš„ç»“æœã€‚ len = strncpy_from_user(kname, filename, PATH_MAX); // ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æ–‡ä»¶ååˆ°å†…æ ¸ç©ºé—´ã€‚è¿™æ¬¡å¤åˆ¶çš„æœ€å¤§é•¿åº¦æ˜¯ PATH_MAXã€‚ if (unlikely(len &lt; 0)) &#123; __putname(kname); // å¦‚æœå¤åˆ¶å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰çš„ç»“æœã€‚ kfree(result); // é‡Šæ”¾æ–°çš„ç»“æœã€‚ return ERR_PTR(len); // è¿”å›é”™è¯¯ã€‚ &#125; if (unlikely(len == PATH_MAX)) &#123; __putname(kname); // å¦‚æœå¤åˆ¶çš„é•¿åº¦ç­‰äº PATH_MAXï¼Œé‡Šæ”¾ä¹‹å‰çš„ç»“æœã€‚ kfree(result); // é‡Šæ”¾æ–°çš„ç»“æœã€‚ return ERR_PTR(-ENAMETOOLONG); // è¿”å›é”™è¯¯ï¼Œè¡¨ç¤ºåå­—è¿‡é•¿ã€‚ &#125; &#125; result-&gt;refcnt = 1; // è®¾ç½®æ–°çš„ç»“æœçš„å¼•ç”¨è®¡æ•°ä¸º 1ã€‚ if (unlikely(!len)) &#123; if (empty) *empty = 1; // å¦‚æœæ–‡ä»¶åçš„é•¿åº¦ä¸º 0ï¼ˆå³æ–‡ä»¶åä¸ºç©ºï¼‰ï¼Œè®¾ç½® *empty ä¸º 1ã€‚ if (!(flags &amp; LOOKUP_EMPTY)) &#123; putname(result); // å¦‚æœä¸å…è®¸æŸ¥æ‰¾ç©ºçš„æ–‡ä»¶åï¼Œé‡Šæ”¾ç»“æœã€‚ return ERR_PTR(-ENOENT); // è¿”å›é”™è¯¯ï¼Œè¡¨ç¤ºæ²¡æœ‰è¿™ä¸ªæ–‡ä»¶æˆ–ç›®å½•ã€‚ &#125; &#125; result-&gt;uptr = filename; result-&gt;uptr = filename; // è®¾ç½®æ–°çš„ç»“æœçš„ç”¨æˆ·ç©ºé—´æŒ‡é’ˆä¸ºä¼ å…¥çš„ filenameã€‚ result-&gt;aname = NULL; // è®¾ç½®æ–°çš„ç»“æœçš„å®¡è®¡åå­—ä¸º NULLã€‚ audit_getname(result); // è·å–æ–°çš„ç»“æœçš„å®¡è®¡åå­—ã€‚ return result; // è¿”å›æ–°çš„ç»“æœã€‚&#125;","text":"namei.c - fs&#x2F;namei.c - Linux source code (v6.3.7) - Bootlin 12#define EMBEDDED_NAME_MAX (PATH_MAX - offsetof(struct filename, iname))// å®šä¹‰ EMBEDDED_NAME_MAXï¼Œè¿™æ˜¯åµŒå…¥å¼æ–‡ä»¶åçš„æœ€å¤§é•¿åº¦ã€‚é•¿åº¦ç­‰äº PATH_MAXï¼ˆä¸€ä¸ªè·¯å¾„çš„æœ€å¤§é•¿åº¦ï¼‰å‡å» struct filename ä¸­ iname å­—æ®µçš„åç§»é‡ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118struct filename *getname_flags(const char __user *filename, int flags, int *empty)// è¿™ä¸ªå‡½æ•°æ˜¯ä»ç”¨æˆ·ç©ºé—´è·å–æ–‡ä»¶åï¼Œå¹¶å°†å…¶å¤åˆ¶åˆ°å†…æ ¸ç©ºé—´ã€‚å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šç”¨æˆ·æä¾›çš„æ–‡ä»¶åï¼Œä¸€ç»„æ ‡å¿—ï¼Œä»¥åŠä¸€ä¸ªæŒ‡å‘æ•´æ•°çš„æŒ‡é’ˆï¼Œç”¨äºæŒ‡ç¤ºè·¯å¾„æ˜¯å¦ä¸ºç©ºã€‚&#123; struct filename *result; char *kname; int len; // å®šä¹‰ä¸‰ä¸ªå˜é‡ï¼šä¸€ä¸ªæŒ‡å‘ struct filename çš„æŒ‡é’ˆï¼Œä¸€ä¸ªå­—ç¬¦æŒ‡é’ˆï¼Œä»¥åŠä¸€ä¸ªæ•´æ•°ã€‚ result = audit_reusename(filename); // å°è¯•é‡ç”¨ç»™å®šçš„æ–‡ä»¶åã€‚å¦‚æœæˆåŠŸï¼Œè¿”å›æŒ‡å‘é‡ç”¨çš„æ–‡ä»¶åçš„æŒ‡é’ˆã€‚ if (result) return result; // å¦‚æœé‡ç”¨æˆåŠŸï¼Œè¿”å›ç»“æœã€‚ result = __getname(); // å°è¯•ä»åå­—ç¼“å­˜ä¸­è·å–ä¸€ä¸ªæ–°çš„æ–‡ä»¶åã€‚ if (unlikely(!result)) return ERR_PTR(-ENOMEM); // å¦‚æœæ— æ³•è·å–æ–°çš„æ–‡ä»¶åï¼ˆå¯èƒ½æ˜¯å› ä¸ºå†…å­˜ä¸è¶³ï¼‰ï¼Œåˆ™è¿”å›é”™è¯¯ã€‚ kname = (char *)result-&gt;iname; // è·å–æ–°æ–‡ä»¶åçš„ iname å­—æ®µï¼Œè¿™æ˜¯ä¸€ä¸ªå†…éƒ¨çš„åå­—ã€‚ result-&gt;name = kname; // å°†å†…éƒ¨åå­—èµ‹ç»™å¤–éƒ¨åå­—ã€‚ len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX); // å°è¯•ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æ–‡ä»¶ååˆ°å†…æ ¸ç©ºé—´ã€‚æœ€å¤šå¤åˆ¶ EMBEDDED_NAME_MAX ä¸ªå­—ç¬¦ã€‚ if (unlikely(len &lt; 0)) &#123; __putname(result); // å¦‚æœå¤åˆ¶å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰è·å–çš„æ–‡ä»¶åã€‚ return ERR_PTR(len); // è¿”å›é”™è¯¯ã€‚ &#125; if (unlikely(len == EMBEDDED_NAME_MAX)) &#123; const size_t size = offsetof(struct filename, iname[1]); // å¦‚æœå¤åˆ¶çš„é•¿åº¦ç­‰äº EMBEDDED_NAME_MAXï¼Œéœ€è¦é‡æ–°åˆ†é…å†…å­˜ã€‚è®¡ç®—æ–°çš„å¤§å°ã€‚ kname = (char *)result; // ä¿å­˜å½“å‰çš„ç»“æœã€‚ result = kzalloc(size, GFP_KERNEL); // ä¸ºæ–°çš„æ–‡ä»¶ååˆ†é…å†…å­˜ã€‚ if (unlikely(!result)) &#123; __putname(kname); // å¦‚æœåˆ†é…å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰çš„ç»“æœã€‚ return ERR_PTR(-ENOMEM); // è¿”å›é”™è¯¯ã€‚ &#125; result-&gt;name = kname; // å°†åå­—èµ‹ç»™æ–°çš„ç»“æœã€‚ len = strncpy_from_user(kname, filename, PATH_MAX); // ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æ–‡ä»¶ååˆ°å†…æ ¸ç©ºé—´ã€‚è¿™æ¬¡å¤åˆ¶çš„æœ€å¤§é•¿åº¦æ˜¯ PATH_MAXã€‚ if (unlikely(len &lt; 0)) &#123; __putname(kname); // å¦‚æœå¤åˆ¶å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰çš„ç»“æœã€‚ kfree(result); // é‡Šæ”¾æ–°çš„ç»“æœã€‚ return ERR_PTR(len); // è¿”å›é”™è¯¯ã€‚ &#125; if (unlikely(len == PATH_MAX)) &#123; __putname(kname); // å¦‚æœå¤åˆ¶çš„é•¿åº¦ç­‰äº PATH_MAXï¼Œé‡Šæ”¾ä¹‹å‰çš„ç»“æœã€‚ kfree(result); // é‡Šæ”¾æ–°çš„ç»“æœã€‚ return ERR_PTR(-ENAMETOOLONG); // è¿”å›é”™è¯¯ï¼Œè¡¨ç¤ºåå­—è¿‡é•¿ã€‚ &#125; &#125; result-&gt;refcnt = 1; // è®¾ç½®æ–°çš„ç»“æœçš„å¼•ç”¨è®¡æ•°ä¸º 1ã€‚ if (unlikely(!len)) &#123; if (empty) *empty = 1; // å¦‚æœæ–‡ä»¶åçš„é•¿åº¦ä¸º 0ï¼ˆå³æ–‡ä»¶åä¸ºç©ºï¼‰ï¼Œè®¾ç½® *empty ä¸º 1ã€‚ if (!(flags &amp; LOOKUP_EMPTY)) &#123; putname(result); // å¦‚æœä¸å…è®¸æŸ¥æ‰¾ç©ºçš„æ–‡ä»¶åï¼Œé‡Šæ”¾ç»“æœã€‚ return ERR_PTR(-ENOENT); // è¿”å›é”™è¯¯ï¼Œè¡¨ç¤ºæ²¡æœ‰è¿™ä¸ªæ–‡ä»¶æˆ–ç›®å½•ã€‚ &#125; &#125; result-&gt;uptr = filename; result-&gt;uptr = filename; // è®¾ç½®æ–°çš„ç»“æœçš„ç”¨æˆ·ç©ºé—´æŒ‡é’ˆä¸ºä¼ å…¥çš„ filenameã€‚ result-&gt;aname = NULL; // è®¾ç½®æ–°çš„ç»“æœçš„å®¡è®¡åå­—ä¸º NULLã€‚ audit_getname(result); // è·å–æ–°çš„ç»“æœçš„å®¡è®¡åå­—ã€‚ return result; // è¿”å›æ–°çš„ç»“æœã€‚&#125; 1234567891011struct filename *getname_uflags(const char __user *filename, int uflags)// è¿™ä¸ªå‡½æ•°ç”¨äºæ ¹æ®ç”¨æˆ·ç©ºé—´çš„æ ‡å¿—è·å–æ–‡ä»¶åã€‚&#123; int flags = (uflags &amp; AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0; // å¦‚æœç”¨æˆ·ç©ºé—´çš„æ ‡å¿—åŒ…å« AT_EMPTY_PATHï¼Œåˆ™è®¾ç½®å†…æ ¸ç©ºé—´çš„æ ‡å¿—ä¸º LOOKUP_EMPTYï¼›å¦åˆ™è®¾ç½®ä¸º 0ã€‚ return getname_flags(filename, flags, NULL); // è°ƒç”¨ getname_flags å‡½æ•°è·å–æ–‡ä»¶åï¼Œå¹¶ä¼ å…¥ä¸Šé¢è®¡ç®—å‡ºçš„æ ‡å¿—ã€‚è¿™ä¸ªå‡½æ•°ä¸å¤„ç† &quot;empty&quot; å‚æ•°ï¼Œæ‰€ä»¥ç›´æ¥ä¼ å…¥ NULLã€‚&#125; 12345678struct filename *getname(const char __user * filename)// è¿™ä¸ªå‡½æ•°ç”¨äºè·å–æ–‡ä»¶åï¼Œä¸æ¥å—ä»»ä½•æ ‡å¿—ã€‚&#123; return getname_flags(filename, 0, NULL); // è°ƒç”¨ getname_flags å‡½æ•°è·å–æ–‡ä»¶åï¼Œæ ‡å¿—è®¾ç½®ä¸º 0ï¼Œä¸å¤„ç† &quot;empty&quot; å‚æ•°ï¼Œæ‰€ä»¥ç›´æ¥ä¼ å…¥ NULLã€‚&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct filename *getname_kernel(const char * filename)// è¿™ä¸ªå‡½æ•°ç”¨äºè·å–å†…æ ¸ç©ºé—´çš„æ–‡ä»¶åã€‚&#123; struct filename *result; int len = strlen(filename) + 1; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘ struct filename çš„æŒ‡é’ˆï¼Œå¹¶è®¡ç®—æ–‡ä»¶åçš„é•¿åº¦ï¼ˆåŒ…æ‹¬ç»“æŸç¬¦ï¼‰ã€‚ result = __getname(); // ä»åå­—ç¼“å­˜ä¸­è·å–ä¸€ä¸ªæ–°çš„æ–‡ä»¶åã€‚ if (unlikely(!result)) return ERR_PTR(-ENOMEM); // å¦‚æœæ— æ³•è·å–æ–°çš„æ–‡ä»¶åï¼ˆå¯èƒ½æ˜¯å› ä¸ºå†…å­˜ä¸è¶³ï¼‰ï¼Œåˆ™è¿”å›é”™è¯¯ã€‚ if (len &lt;= EMBEDDED_NAME_MAX) &#123; result-&gt;name = (char *)result-&gt;iname; // å¦‚æœæ–‡ä»¶åçš„é•¿åº¦å°äºç­‰äº EMBEDDED_NAME_MAXï¼Œåˆ™å°†æ–‡ä»¶åå­˜å‚¨åœ¨ iname å­—æ®µä¸­ã€‚ &#125; else if (len &lt;= PATH_MAX) &#123; const size_t size = offsetof(struct filename, iname[1]); struct filename *tmp; // å¦‚æœæ–‡ä»¶åçš„é•¿åº¦å¤§äº EMBEDDED_NAME_MAX ä½†å°äºç­‰äº PATH_MAXï¼Œåˆ™éœ€è¦é‡æ–°åˆ†é…å†…å­˜ã€‚è®¡ç®—æ–°çš„å¤§å°ã€‚ tmp = kmalloc(size, GFP_KERNEL); // ä¸ºæ–°çš„æ–‡ä»¶ååˆ†é…å†…å­˜ã€‚ if (unlikely(!tmp)) &#123; __putname(result); // å¦‚æœåˆ†é…å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰è·å–çš„æ–‡ä»¶åã€‚ return ERR_PTR(-ENOMEM); // è¿”å›é”™è¯¯ã€‚ &#125; tmp-&gt;name = (char *)result; // å°†ä¹‹å‰è·å–çš„æ–‡ä»¶åèµ‹ç»™æ–°çš„æ–‡ä»¶åã€‚ result = tmp; // æ›´æ–°ç»“æœã€‚ &#125; else &#123; __putname(result); // å¦‚æœæ–‡ä»¶åçš„é•¿åº¦å¤§äº PATH_MAXï¼Œé‡Šæ”¾ä¹‹å‰è·å–çš„æ–‡ä»¶åã€‚ return ERR_PTR(-ENAMETOOLONG); // è¿”å›é”™è¯¯ï¼Œè¡¨ç¤ºåå­—è¿‡é•¿ã€‚ &#125; memcpy((char *)result-&gt;name, filename, len); // å¤åˆ¶æ–‡ä»¶ååˆ°ç»“æœã€‚ result-&gt;uptr = NULL; // è®¾ç½®ç”¨æˆ·ç©ºé—´æŒ‡é’ˆä¸º NULLï¼Œå› ä¸ºè¿™ä¸ªå‡½æ•°æ¥å—çš„æ˜¯å†…æ ¸ç©ºé—´çš„æ–‡ä»¶åã€‚ result-&gt;aname = NULL; // è®¾ç½®å®¡è®¡åå­—ä¸º NULLã€‚ result-&gt;refcnt = 1; // è®¾ç½®å¼•ç”¨è®¡æ•°ä¸º 1ã€‚ audit_getname(result); // è·å–å®¡è®¡åå­—ã€‚ return result; // è¿”å›ç»“æœã€‚&#125; 1234567891011121314151617181920212223void putname(struct filename *name)// è¿™ä¸ªå‡½æ•°ç”¨äºå‡å°‘æ–‡ä»¶åçš„å¼•ç”¨è®¡æ•°ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶é‡Šæ”¾æ–‡ä»¶åã€‚&#123; if (IS_ERR(name)) return; // å¦‚æœæ–‡ä»¶åæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œç›´æ¥è¿”å›ã€‚ BUG_ON(name-&gt;refcnt &lt;= 0); // å¦‚æœæ–‡ä»¶åçš„å¼•ç”¨è®¡æ•°å°äºç­‰äº 0ï¼Œè§¦å‘ BUGã€‚ if (--name-&gt;refcnt &gt; 0) return; // å‡å°‘æ–‡ä»¶åçš„å¼•ç”¨è®¡æ•°ï¼Œå¦‚æœå¼•ç”¨è®¡æ•°å¤§äº 0ï¼Œç›´æ¥è¿”å›ã€‚ if (name-&gt;name != name-&gt;iname) &#123; __putname(name-&gt;name); kfree(name); // å¦‚æœæ–‡ä»¶åä¸æ˜¯å­˜å‚¨åœ¨ iname å­—æ®µä¸­çš„ï¼Œè°ƒç”¨ __putname é‡Šæ”¾æ–‡ä»¶åï¼Œå¹¶é‡Šæ”¾æ•´ä¸ª filename ç»“æ„ã€‚ &#125; else __putname(name); // å¦åˆ™ï¼Œç›´æ¥è°ƒç”¨ __putname é‡Šæ”¾æ•´ä¸ª filename ç»“æ„ã€‚&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * check_acl - perform ACL permission checking * @idmap: idmap of the mount the inode was found from * @inode: inode to check permissions on * @mask: right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...) * * This function performs the ACL permission checking. Since this function * retrieve POSIX acls it needs to know whether it is called from a blocking or * non-blocking context and thus cares about the MAY_NOT_BLOCK bit. * * If the inode has been found through an idmapped mount the idmap of * the vfsmount must be passed through @idmap. This function will then take * care to map the inode according to @idmap before checking permissions. * On non-idmapped mounts or if permission checking is to be performed on the * raw inode simply pass @nop_mnt_idmap. */static int check_acl(struct mnt_idmap *idmap, struct inode *inode, int mask)// è¿™ä¸ªå‡½æ•°ç”¨äºæ£€æŸ¥ ACL è®¿é—®æƒé™ã€‚å¦‚æœæ–‡ä»¶èŠ‚ç‚¹æ˜¯é€šè¿‡ idmapped æŒ‚è½½æ‰¾åˆ°çš„ï¼Œéœ€è¦ä¼ å…¥ idmap å‚æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨æ£€æŸ¥æƒé™ä¹‹å‰å…ˆæ˜ å°„æ–‡ä»¶èŠ‚ç‚¹ã€‚// å¯¹äºé idmapped æŒ‚è½½ï¼Œæˆ–è€…è¦æ£€æŸ¥åŸå§‹æ–‡ä»¶èŠ‚ç‚¹çš„æƒé™ï¼Œç›´æ¥ä¼ å…¥ nop_mnt_idmapã€‚&#123;#ifdef CONFIG_FS_POSIX_ACL // å¦‚æœå¯ç”¨äº† POSIX ACLï¼Œæ‰§è¡Œä»¥ä¸‹ä»£ç ã€‚ struct posix_acl *acl; if (mask &amp; MAY_NOT_BLOCK) &#123; acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS); if (!acl) return -EAGAIN; // å¦‚æœ mask åŒ…å« MAY_NOT_BLOCKï¼Œä» RCU ç¼“å­˜ä¸­è·å– ACLï¼Œå¦‚æœè·å–ä¸åˆ°ï¼Œè¿”å› -EAGAINã€‚ /* no -&gt;get_inode_acl() calls in RCU mode... */ if (is_uncached_acl(acl)) return -ECHILD; // åœ¨ RCU æ¨¡å¼ä¸‹ä¸è°ƒç”¨ get_inode_acl()ï¼Œå¦‚æœ ACL ä¸åœ¨ç¼“å­˜ä¸­ï¼Œè¿”å› -ECHILDã€‚ return posix_acl_permission(idmap, inode, acl, mask); // è¿”å› posix_acl_permission çš„è°ƒç”¨ç»“æœï¼Œæ­¤å‡½æ•°ç”¨äºæ£€æŸ¥æƒé™ã€‚ &#125; acl = get_inode_acl(inode, ACL_TYPE_ACCESS); // è·å– inode çš„ ACLã€‚ if (IS_ERR(acl)) return PTR_ERR(acl); // å¦‚æœ ACL æ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œè¿”å›é”™è¯¯ã€‚ if (acl) &#123; int error = posix_acl_permission(idmap, inode, acl, mask); posix_acl_release(acl); return error; // å¦‚æœ ACL å­˜åœ¨ï¼Œæ£€æŸ¥æƒé™ï¼Œç„¶åé‡Šæ”¾ ACLï¼Œè¿”å›æ£€æŸ¥ç»“æœã€‚ &#125;#endif return -EAGAIN; // å¦‚æœæœªå¯ç”¨ POSIX ACLï¼Œæˆ–è€… ACL ä¸å­˜åœ¨ï¼Œè¿”å› -EAGAINã€‚&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * acl_permission_check - perform basic UNIX permission checking * @idmap: idmap of the mount the inode was found from * @inode: inode to check permissions on * @mask: right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...) * * This function performs the basic UNIX permission checking. Since this * function may retrieve POSIX acls it needs to know whether it is called from a * blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit. * * If the inode has been found through an idmapped mount the idmap of * the vfsmount must be passed through @idmap. This function will then take * care to map the inode according to @idmap before checking permissions. * On non-idmapped mounts or if permission checking is to be performed on the * raw inode simply passs @nop_mnt_idmap. */static int acl_permission_check(struct mnt_idmap *idmap, struct inode *inode, int mask)// è¿™ä¸ªå‡½æ•°æ‰§è¡ŒåŸºæœ¬çš„UNIXæƒé™æ£€æŸ¥ã€‚å¦‚æœæ–‡ä»¶èŠ‚ç‚¹æ˜¯é€šè¿‡ idmapped æŒ‚è½½æ‰¾åˆ°çš„ï¼Œéœ€è¦ä¼ å…¥ idmap å‚æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨æ£€æŸ¥æƒé™ä¹‹å‰å…ˆæ˜ å°„æ–‡ä»¶èŠ‚ç‚¹ã€‚// å¯¹äºé idmapped æŒ‚è½½ï¼Œæˆ–è€…è¦æ£€æŸ¥åŸå§‹æ–‡ä»¶èŠ‚ç‚¹çš„æƒé™ï¼Œç›´æ¥ä¼ å…¥ nop_mnt_idmapã€‚&#123; unsigned int mode = inode-&gt;i_mode; // è·å– inode çš„æ¨¡å¼ã€‚ vfsuid_t vfsuid; /* Are we the owner? If so, ACL&#x27;s don&#x27;t matter */ vfsuid = i_uid_into_vfsuid(idmap, inode); if (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) &#123; mask &amp;= 7; mode &gt;&gt;= 6; return (mask &amp; ~mode) ? -EACCES : 0; &#125; // å¦‚æœæˆ‘ä»¬æ˜¯æ‰€æœ‰è€…ï¼ŒACLæ— å…³ç´§è¦ã€‚æˆ‘ä»¬åªéœ€æ£€æŸ¥ç”¨æˆ·çš„æƒé™ã€‚ /* Do we have ACL&#x27;s? */ if (IS_POSIXACL(inode) &amp;&amp; (mode &amp; S_IRWXG)) &#123; int error = check_acl(idmap, inode, mask); if (error != -EAGAIN) return error; &#125; // å¦‚æœæˆ‘ä»¬æœ‰ACLï¼Œå¹¶ä¸”è®¾ç½®äº†ç»„æƒé™ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥ACLã€‚å¦‚æœæ²¡æœ‰é”™è¯¯å‘ç”Ÿï¼Œè¿”å›æ£€æŸ¥çš„ç»“æœã€‚ /* Only RWX matters for group/other mode bits */ mask &amp;= 7; // ä»…ä¿ç•™RWXï¼ˆè¯»/å†™/æ‰§è¡Œï¼‰æƒé™ä½ã€‚ /* * Are the group permissions different from * the other permissions in the bits we care * about? Need to check group ownership if so. */ if (mask &amp; (mode ^ (mode &gt;&gt; 3))) &#123; vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode); if (vfsgid_in_group_p(vfsgid)) mode &gt;&gt;= 3; &#125; // å¦‚æœç»„æƒé™ä¸å…¶ä»–æƒé™åœ¨æˆ‘ä»¬å…³å¿ƒçš„ä½ä¸Šä¸åŒï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥ç»„æ‰€æœ‰æƒã€‚ /* Bits in &#x27;mode&#x27; clear that we require? */ return (mask &amp; ~mode) ? -EACCES : 0; // å¦‚æœæˆ‘ä»¬éœ€è¦çš„æƒé™ä½åœ¨&#x27;mode&#x27;ä¸­è¢«æ¸…é™¤äº†ï¼Œè¿”å› -EACCESï¼Œå¦åˆ™è¿”å› 0ã€‚&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * generic_permission - check for access rights on a Posix-like filesystem * @idmap: idmap of the mount the inode was found from * @inode: inode to check access rights for * @mask: right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, * %MAY_NOT_BLOCK ...) * * Used to check for read/write/execute permissions on a file. * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions * for filesystem access without changing the &quot;normal&quot; uids which * are used for other things. * * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk * request cannot be satisfied (eg. requires blocking or too much complexity). * It would then be called again in ref-walk mode. * * If the inode has been found through an idmapped mount the idmap of * the vfsmount must be passed through @idmap. This function will then take * care to map the inode according to @idmap before checking permissions. * On non-idmapped mounts or if permission checking is to be performed on the * raw inode simply passs @nop_mnt_idmap. */int generic_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)&#123; int ret; /* * Do the basic permission checks. */ ret = acl_permission_check(idmap, inode, mask); if (ret != -EACCES) return ret; // é¦–å…ˆè¿›è¡ŒåŸºæœ¬æƒé™æ£€æŸ¥ï¼Œå¦‚æœè¿”å›å€¼ä¸æ˜¯ -EACCESï¼Œåˆ™ç›´æ¥è¿”å›ç»“æœã€‚ if (S_ISDIR(inode-&gt;i_mode)) &#123; /* DACs are overridable for directories */ if (!(mask &amp; MAY_WRITE)) if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_READ_SEARCH)) return 0; if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_OVERRIDE)) return 0; return -EACCES; &#125; // å¦‚æœ inode æ˜¯ç›®å½•ï¼Œç‰¹æƒç”¨æˆ·å¯ä»¥è¦†ç›– DAC æƒé™ã€‚å¦‚æœæ²¡æœ‰å†™æƒé™ï¼Œä½†ç”¨æˆ·æœ‰ CAP_DAC_READ_SEARCH èƒ½åŠ›ï¼Œåˆ™è¿”å›0ã€‚ // å¦‚æœç”¨æˆ·æœ‰ CAP_DAC_OVERRIDE èƒ½åŠ›ï¼Œåˆ™è¿”å›0ã€‚å¦åˆ™è¿”å› -EACCESã€‚ /* * Searching includes executable on directories, else just read. */ mask &amp;= MAY_READ | MAY_WRITE | MAY_EXEC; if (mask == MAY_READ) if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_READ_SEARCH)) return 0; // å¦‚æœæƒé™æ©ç ä»…åŒ…å«è¯»æƒé™ï¼Œè€Œç”¨æˆ·å…·æœ‰ CAP_DAC_READ_SEARCH èƒ½åŠ›ï¼Œåˆ™è¿”å› 0ã€‚ /* * Read/write DACs are always overridable. * Executable DACs are overridable when there is * at least one exec bit set. */ if (!(mask &amp; MAY_EXEC) || (inode-&gt;i_mode &amp; S_IXUGO)) if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_OVERRIDE)) return 0; // è¯»/å†™ DAC æ€»æ˜¯å¯ä»¥è¢«è¦†ç›–ã€‚å¦‚æœæƒé™æ©ç ä¸­æ²¡æœ‰æ‰§è¡Œæƒé™ï¼Œæˆ–è€… inode çš„æ¨¡å¼ä¸­è‡³å°‘æœ‰ä¸€ä¸ªæ‰§è¡Œä½ï¼Œè€Œç”¨æˆ·å…·æœ‰ CAP_DAC_OVERRIDE èƒ½åŠ›ï¼Œåˆ™è¿”å› 0ã€‚ return -EACCES; // å¦‚æœä¸Šè¿°æ‰€æœ‰æ¡ä»¶éƒ½ä¸æ»¡è¶³ï¼Œè¿”å› -EACCESã€‚&#125;EXPORT_SYMBOL(generic_permission);// å°†å‡½æ•° generic_permission å¯¼å‡ºï¼Œä½¿å…¶å¯ä»¥è¢«å…¶ä»–æ¨¡å—ä½¿ç”¨ã€‚ 12345678910111213141516171819static inline int do_inode_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)&#123; // å¦‚æœinodeçš„æ“ä½œæ ‡è®°ä¸IOP_FASTPERMåšANDè¿ç®—çš„ç»“æœä¸ä¸ºçœŸï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œinodeæ²¡æœ‰è®¾ç½®ä½¿ç”¨å¿«é€Ÿæƒé™æ£€æŸ¥çš„æ ‡è®°ï¼‰ if (unlikely(!(inode-&gt;i_opflags &amp; IOP_FASTPERM))) &#123; // å¦‚æœinodeçš„æ“ä½œå¯¹è±¡æœ‰æƒé™æ£€æŸ¥å‡½æ•° if (likely(inode-&gt;i_op-&gt;permission)) // åˆ™è°ƒç”¨è¯¥å‡½æ•°è¿›è¡Œæƒé™æ£€æŸ¥ return inode-&gt;i_op-&gt;permission(idmap, inode, mask); // å¦‚æœinodeçš„æ“ä½œå¯¹è±¡æ²¡æœ‰æƒé™æ£€æŸ¥å‡½æ•°ï¼Œåˆ™è·å–inodeçš„é” spin_lock(&amp;inode-&gt;i_lock); // å¹¶è®¾ç½®ä½¿ç”¨å¿«é€Ÿæƒé™æ£€æŸ¥çš„æ ‡è®° inode-&gt;i_opflags |= IOP_FASTPERM; // é‡Šæ”¾inodeçš„é” spin_unlock(&amp;inode-&gt;i_lock); &#125; // å¦‚æœinodeè®¾ç½®äº†ä½¿ç”¨å¿«é€Ÿæƒé™æ£€æŸ¥çš„æ ‡è®°ï¼Œæˆ–è€…inodeçš„æ“ä½œå¯¹è±¡æ²¡æœ‰æƒé™æ£€æŸ¥å‡½æ•°ï¼Œåˆ™ç›´æ¥è°ƒç”¨é€šç”¨æƒé™æ£€æŸ¥å‡½æ•° return generic_permission(idmap, inode, mask);&#125; 123456789101112131415static int sb_permission(struct super_block *sb, struct inode *inode, int mask)&#123; // å¦‚æœè¯·æ±‚çš„æƒé™åŒ…å«å†™æƒé™ if (unlikely(mask &amp; MAY_WRITE)) &#123; // è·å–inodeçš„æ¨¡å¼ umode_t mode = inode-&gt;i_mode; // å¦‚æœæ–‡ä»¶ç³»ç»Ÿæ˜¯åªè¯»çš„ï¼Œå¹¶ä¸”inodeæ˜¯å¸¸è§„æ–‡ä»¶ã€ç›®å½•æˆ–è€…ç¬¦å·é“¾æ¥ if (sb_rdonly(sb) &amp;&amp; (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))) // åˆ™è¿”å›é”™è¯¯ï¼Œå› ä¸ºæ²¡æœ‰äººèƒ½å¤Ÿè·å–åªè¯»æ–‡ä»¶ç³»ç»Ÿçš„å†™æƒé™ return -EROFS; &#125; // å¦‚æœè¯·æ±‚çš„æƒé™ä¸åŒ…å«å†™æƒé™ï¼Œæˆ–è€…æ–‡ä»¶ç³»ç»Ÿä¸æ˜¯åªè¯»çš„ï¼Œæˆ–è€…inodeä¸æ˜¯å¸¸è§„æ–‡ä»¶ã€ç›®å½•æˆ–è€…ç¬¦å·é“¾æ¥ï¼Œåˆ™è¿”å›æˆåŠŸ return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940int inode_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)&#123; int retval; // é¦–å…ˆè¿›è¡Œè¶…çº§å—çº§åˆ«çš„æƒé™æ£€æŸ¥ retval = sb_permission(inode-&gt;i_sb, inode, mask); // å¦‚æœè¿”å›é”™è¯¯ï¼Œåˆ™ç›´æ¥è¿”å›é”™è¯¯ if (retval) return retval; // å¦‚æœè¯·æ±‚çš„æƒé™åŒ…å«å†™æƒé™ if (unlikely(mask &amp; MAY_WRITE)) &#123; // å¦‚æœinodeæ˜¯ä¸å¯å˜çš„ if (IS_IMMUTABLE(inode)) // åˆ™è¿”å›é”™è¯¯ï¼Œå› ä¸ºæ²¡æœ‰äººèƒ½å¤Ÿè·å–ä¸å¯å˜æ–‡ä»¶çš„å†™æƒé™ return -EPERM; // å¦‚æœæ›´æ–°mtimeå¯èƒ½å¯¼è‡´i_uidå’Œi_gidè¢«é”™è¯¯åœ°å†™å›ï¼Œä¾‹å¦‚å®ƒä»¬çš„çœŸå®å€¼å¯¹vfsæ¥è¯´æ˜¯æœªçŸ¥çš„ if (HAS_UNMAPPED_ID(idmap, inode)) // åˆ™è¿”å›é”™è¯¯ return -EACCES; &#125; // ç„¶åè¿›è¡Œinodeçº§åˆ«çš„æƒé™æ£€æŸ¥ retval = do_inode_permission(idmap, inode, mask); // å¦‚æœè¿”å›é”™è¯¯ï¼Œåˆ™ç›´æ¥è¿”å›é”™è¯¯ if (retval) return retval; // ç„¶åè¿›è¡Œè®¾å¤‡æ§åˆ¶ç»„çº§åˆ«çš„æƒé™æ£€æŸ¥ retval = devcgroup_inode_permission(inode, mask); // å¦‚æœè¿”å›é”™è¯¯ï¼Œåˆ™ç›´æ¥è¿”å›é”™è¯¯ if (retval) return retval; // æœ€åè¿›è¡Œå®‰å…¨æ¨¡å—çº§åˆ«çš„æƒé™æ£€æŸ¥ return security_inode_permission(inode, mask);&#125;// å¯¼å‡ºinode_permissionç¬¦å·ï¼Œä½¿å¾—å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨è¯¥å‡½æ•°EXPORT_SYMBOL(inode_permission); 123456789101112131415/** * path_get - å¢åŠ è·¯å¾„çš„å¼•ç”¨è®¡æ•° * @path: è¦å¢åŠ å¼•ç”¨è®¡æ•°çš„è·¯å¾„ * * ç»™å®šä¸€ä¸ªè·¯å¾„ï¼Œå¢åŠ å…¶ç›®å½•é¡¹ï¼ˆdentryï¼‰å’Œè™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹ï¼ˆvfsmountï¼‰çš„å¼•ç”¨è®¡æ•°ã€‚ */void path_get(const struct path *path)&#123; // å¢åŠ è™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•° mntget(path-&gt;mnt); // å¢åŠ ç›®å½•é¡¹çš„å¼•ç”¨è®¡æ•° dget(path-&gt;dentry);&#125;// å¯¼å‡ºpath_getç¬¦å·ï¼Œä½¿å¾—å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨è¯¥å‡½æ•°EXPORT_SYMBOL(path_get); 123456789101112131415/** * path_put - å‡å°‘è·¯å¾„çš„å¼•ç”¨è®¡æ•° * @path: è¦å‡å°‘å¼•ç”¨è®¡æ•°çš„è·¯å¾„ * * ç»™å®šä¸€ä¸ªè·¯å¾„ï¼Œå‡å°‘å…¶ç›®å½•é¡¹ï¼ˆdentryï¼‰å’Œè™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹ï¼ˆvfsmountï¼‰çš„å¼•ç”¨è®¡æ•°ã€‚ */void path_put(const struct path *path)&#123; // å‡å°‘ç›®å½•é¡¹çš„å¼•ç”¨è®¡æ•° dput(path-&gt;dentry); // å‡å°‘è™šæ‹Ÿæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•° mntput(path-&gt;mnt);&#125;// å¯¼å‡ºpath_putç¬¦å·ï¼Œä½¿å¾—å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨è¯¥å‡½æ•°EXPORT_SYMBOL(path_put); 12// å®šä¹‰åµŒå¥—å±‚çº§ä¸º2#define EMBEDDED_LEVELS 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344// nameidata ç»“æ„ä½“ï¼Œç”¨äºå¤„ç†æ–‡ä»¶åæŸ¥æ‰¾æ—¶çš„è·¯å¾„åè§£æstruct nameidata &#123; // ä¿å­˜è¢«æŸ¥æ‰¾å¯¹è±¡çš„è·¯å¾„ struct path path; // ä¿å­˜æœ€åä¸€ä¸ªè¢«è§£æçš„è·¯å¾„ç»„ä»¶åç§° struct qstr last; // ä¿å­˜æŸ¥æ‰¾çš„æ ¹è·¯å¾„ struct path root; // æŒ‡å‘è·¯å¾„ä¸­ç›®å½•é¡¹çš„inodeèŠ‚ç‚¹ struct inode *inode; /* path.dentry.d_inode */ // æŸ¥æ‰¾æ ‡è®° unsigned int flags, state; // åºåˆ—å· unsigned seq, next_seq, m_seq, r_seq; // ä¸Šä¸€æ¬¡è§£æçš„è·¯å¾„ç»„ä»¶ç±»å‹ int last_type; // åµŒå¥—æ·±åº¦ unsigned depth; // ç¬¦å·é“¾æ¥çš„æ€»æ•° int total_link_count; // ä¿å­˜ä¹‹å‰çš„çŠ¶æ€ï¼Œç”¨äºåœ¨å¤„ç†ç¬¦å·é“¾æ¥æ—¶å›æº¯ struct saved &#123; // ç¬¦å·é“¾æ¥çš„è·¯å¾„ struct path link; // å»¶è¿Ÿè°ƒç”¨çš„å‡½æ•° struct delayed_call done; // ç¬¦å·é“¾æ¥çš„åç§° const char *name; // åºåˆ—å· unsigned seq; &#125; *stack, internal[EMBEDDED_LEVELS]; // æ‰€æŸ¥æ‰¾çš„æ–‡ä»¶å struct filename *name; // ä¿å­˜çš„nameidataç»“æ„ä½“ï¼Œç”¨äºæ¢å¤ä¹‹å‰çš„çŠ¶æ€ struct nameidata *saved; // æ ¹è·¯å¾„çš„åºåˆ—å· unsigned root_seq; // ç›®å½•æ–‡ä»¶æè¿°ç¬¦ int dfd; // ç›®å½•çš„vfsç”¨æˆ·ID vfsuid_t dir_vfsuid; // ç›®å½•çš„æ¨¡å¼ umode_t dir_mode;&#125; __randomize_layout; 1234// å®šä¹‰æ ‡è®°å€¼#define ND_ROOT_PRESET 1 // æ ¹è·¯å¾„å·²é¢„è®¾#define ND_ROOT_GRABBED 2 // æ ¹è·¯å¾„å·²è·å–#define ND_JUMPED 4 // å·²ç»è·³è½¬ 12345678910111213141516171819// è®¾ç½® nameidata ç»“æ„ä½“çš„å€¼static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)&#123; // è·å–å½“å‰çº¿ç¨‹çš„ nameidata struct nameidata *old = current-&gt;nameidata; // åˆå§‹åŒ– nameidata ç»“æ„ä½“ p-&gt;stack = p-&gt;internal; p-&gt;depth = 0; p-&gt;dfd = dfd; p-&gt;name = name; p-&gt;path.mnt = NULL; p-&gt;path.dentry = NULL; p-&gt;total_link_count = old ? old-&gt;total_link_count : 0; p-&gt;saved = old; // è®¾ç½®å½“å‰çº¿ç¨‹çš„ nameidata current-&gt;nameidata = p;&#125; 123456789101112// è®¾ç½® nameidata ç»“æ„ä½“çš„å€¼ï¼Œå¹¶åˆå§‹åŒ–çŠ¶æ€static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name, const struct path *root)&#123; __set_nameidata(p, dfd, name); p-&gt;state = 0; // å¦‚æœ root ä¸ä¸º NULLï¼Œåˆ™å°† state è®¾ç½®ä¸º ND_ROOT_PRESETï¼ŒåŒæ—¶è®¾ç½® root è·¯å¾„ if (unlikely(root)) &#123; p-&gt;state = ND_ROOT_PRESET; p-&gt;root = *root; &#125;&#125; 123456789101112131415// æ¢å¤ nameidata ç»“æ„ä½“static void restore_nameidata(void)&#123; // è·å–å½“å‰å’Œä¹‹å‰çš„ nameidata struct nameidata *now = current-&gt;nameidata, *old = now-&gt;saved; // æ¢å¤å½“å‰çº¿ç¨‹çš„ nameidata current-&gt;nameidata = old; // å¦‚æœ old å­˜åœ¨ï¼Œåˆ™æ›´æ–° total_link_count if (old) old-&gt;total_link_count = now-&gt;total_link_count; // å¦‚æœ stack æŒ‡å‘çš„ä¸æ˜¯å†…éƒ¨æ•°ç»„ï¼Œåˆ™é‡Šæ”¾å†…å­˜ if (now-&gt;stack != now-&gt;internal) kfree(now-&gt;stack);&#125; 123456789101112131415// ä¸º nameidata ç»“æ„ä½“åˆ†é…å†…å­˜static bool nd_alloc_stack(struct nameidata *nd)&#123; struct saved *p; // åˆ†é…å†…å­˜ p= kmalloc_array(MAXSYMLINKS, sizeof(struct saved), nd-&gt;flags &amp; LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL); if (unlikely(!p)) return false; // å¤åˆ¶å†…éƒ¨æ•°ç»„åˆ°æ–°åˆ†é…çš„å†…å­˜ memcpy(p, nd-&gt;internal, sizeof(nd-&gt;internal)); nd-&gt;stack = p; return true;&#125; 1234567891011121314151617/** * path_connected - éªŒè¯ dentry æ˜¯å¦åœ¨ mnt.mnt_root ä¸‹é¢ * * é‡å‘½åæ“ä½œæœ‰æ—¶ä¼šå°†æ–‡ä»¶æˆ–ç›®å½•ç§»å‡ºç»‘å®šæŒ‚è½½ï¼Œ * path_connected å…è®¸æ£€æµ‹è¿™äº›æƒ…å†µã€‚ */static bool path_connected(struct vfsmount *mnt, struct dentry *dentry)&#123; struct super_block *sb = mnt-&gt;mnt_sb; // ç»‘å®šæŒ‚è½½å¯ä»¥æœ‰æ–­å¼€çš„è·¯å¾„ if (mnt-&gt;mnt_root == sb-&gt;s_root) return true; // åˆ¤æ–­ dentry æ˜¯å¦æ˜¯ mnt.mnt_root çš„å­ç›®å½• return is_subdir(dentry, mnt-&gt;mnt_root);&#125; 123456789101112// æ¸…é™¤é“¾æ¥static void drop_links(struct nameidata *nd)&#123; int i = nd-&gt;depth; while (i--) &#123; struct saved *last = nd-&gt;stack + i; // æ‰§è¡Œå»¶è¿Ÿè°ƒç”¨ do_delayed_call(&amp;last-&gt;done); // æ¸…é™¤å»¶è¿Ÿè°ƒç”¨ clear_delayed_call(&amp;last-&gt;done); &#125;&#125; 1234567// ç¦»å¼€ RCU è¯»å–åŒºåŸŸstatic void leave_rcu(struct nameidata *nd)&#123; nd-&gt;flags &amp;= ~LOOKUP_RCU; nd-&gt;seq = nd-&gt;next_seq = 0; rcu_read_unlock();&#125; 1234567891011121314151617181920212223242526// ç»ˆæ­¢è·¯å¾„è§£æstatic void terminate_walk(struct nameidata *nd)&#123; // æ¸…é™¤é“¾æ¥ drop_links(nd); if (!(nd-&gt;flags &amp; LOOKUP_RCU)) &#123; int i; // é‡Šæ”¾ path å¼•ç”¨ path_put(&amp;nd-&gt;path); for (i = 0; i &lt; nd-&gt;depth; i++) // é‡Šæ”¾ stack ä¸­çš„æ‰€æœ‰ link å¼•ç”¨ path_put(&amp;nd-&gt;stack[i].link); if (nd-&gt;state &amp; ND_ROOT_GRABBED) &#123; // å¦‚æœ root è¢«æŠ“å–ï¼Œåˆ™é‡Šæ”¾ root å¼•ç”¨å¹¶æ¸…é™¤ ND_ROOT_GRABBED æ ‡å¿— path_put(&amp;nd-&gt;root); nd-&gt;state &amp;= ~ND_ROOT_GRABBED; &#125; &#125; else &#123; // å¦‚æœåœ¨ RCU è¯»å–åŒºåŸŸï¼Œåˆ™ç¦»å¼€ RCU è¯»å–åŒºåŸŸ leave_rcu(nd); &#125; // é‡ç½® depth å’Œ path nd-&gt;depth = 0; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL;&#125; 1234567891011121314151617181920// æ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œä¹‹åéƒ½éœ€è¦ path_putstatic bool __legitimize_path(struct path *path, unsigned seq, unsigned mseq)&#123; // éªŒè¯mntç»“æ„ä½“æ˜¯å¦åˆæ³• int res = __legitimize_mnt(path-&gt;mnt, mseq); // å¦‚æœä¸åˆæ³•ï¼Œåˆ™å°†mntå’Œdentryè®¾ä¸ºNULLå¹¶è¿”å›false if (unlikely(res)) &#123; if (res &gt; 0) path-&gt;mnt = NULL; path-&gt;dentry = NULL; return false; &#125; // å¦‚æœdentryçš„d_lockrefæ˜¯æ­»çš„ï¼Œåˆ™å°†dentryè®¾ä¸ºNULLå¹¶è¿”å›false if (unlikely(!lockref_get_not_dead(&amp;path-&gt;dentry-&gt;d_lockref))) &#123; path-&gt;dentry = NULL; return false; &#125; // å¦‚æœè¯»å–åºåˆ—å·å¤±è´¥ï¼Œåˆ™è¿”å›false return !read_seqcount_retry(&amp;path-&gt;dentry-&gt;d_seq, seq);&#125; 123456// éªŒè¯è·¯å¾„æ˜¯å¦åˆæ³•static inline bool legitimize_path(struct nameidata *nd, struct path *path, unsigned seq)&#123; return __legitimize_path(path, seq, nd-&gt;m_seq);&#125; 1234567891011121314151617181920212223// éªŒè¯é“¾æ¥æ˜¯å¦åˆæ³•static bool legitimize_links(struct nameidata *nd)&#123; int i; // å¦‚æœæœ‰LOOKUP_CACHEDæ ‡å¿—ï¼Œé‚£ä¹ˆæ¸…é™¤é“¾æ¥å¹¶å°†depthè®¾ä¸º0ï¼Œç„¶åè¿”å›false if (unlikely(nd-&gt;flags &amp; LOOKUP_CACHED)) &#123; drop_links(nd); nd-&gt;depth = 0; return false; &#125; // éå†stackä¸­çš„æ‰€æœ‰å…ƒç´ ï¼ŒéªŒè¯æ¯ä¸ªé“¾æ¥æ˜¯å¦åˆæ³• for (i = 0; i &lt; nd-&gt;depth; i++) &#123; struct saved *last = nd-&gt;stack + i; // å¦‚æœé“¾æ¥ä¸åˆæ³•ï¼Œé‚£ä¹ˆæ¸…é™¤é“¾æ¥å¹¶å°†depthè®¾ä¸ºi+1ï¼Œç„¶åè¿”å›false if (unlikely(!legitimize_path(nd, &amp;last-&gt;link, last-&gt;seq))) &#123; drop_links(nd); nd-&gt;depth = i + 1; return false; &#125; &#125; // æ‰€æœ‰é“¾æ¥éƒ½åˆæ³•ï¼Œè¿”å›true return true;&#125; 1234567891011// éªŒè¯rootæ˜¯å¦åˆæ³•static bool legitimize_root(struct nameidata *nd)&#123; // å¦‚æœnd-&gt;rootæ˜¯0æˆ–è€…è¢«VFSç”¨æˆ·ç®¡ç†ï¼Œé‚£ä¹ˆä¸éœ€è¦åšä»»ä½•äº‹æƒ…ï¼Œç›´æ¥è¿”å›true if (!nd-&gt;root.mnt || (nd-&gt;state &amp; ND_ROOT_PRESET)) return true; // è®¾ç½®ND_ROOT_GRABBEDæ ‡å¿— nd-&gt;state |= ND_ROOT_GRABBED; // éªŒè¯rootè·¯å¾„æ˜¯å¦åˆæ³• return legitimize_path(nd, &amp;nd-&gt;root, nd-&gt;root_seq);&#125; 12345678910/* * Path walking has 2 modes, rcu-walk and ref-walk (see * Documentation/filesystems/path-lookup.txt). In situations when we can&#x27;t * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab * normal reference counts on dentries and vfsmounts to transition to ref-walk * mode. Refcounts are grabbed at the last known good point before rcu-walk * got stuck, so ref-walk may continue from there. If this is not successful * (eg. a seqcount has changed), then failure is returned and it&#x27;s up to caller * to restart the path walk from the beginning in ref-walk mode. */ 1234567891011121314151617181920212223242526272829303132/** * try_to_unlazy - å°è¯•åˆ‡æ¢åˆ°å¼•ç”¨éå†æ¨¡å¼ã€‚ * @nd: nameidataè·¯å¾„éå†æ•°æ® * è¿”å›: æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false * * try_to_unlazy å°è¯•å°†å½“å‰çš„nd-&gt;pathå’Œnd-&gt;rootåˆæ³•åŒ–ä¸ºå¼•ç”¨éå†æ¨¡å¼ã€‚ * å¿…é¡»åœ¨rcu-walkä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ã€‚ * åœ¨try_to_unlazy()å¤±è´¥å’Œterminate_walk()ä¹‹é—´ï¼Œä¸åº”è§¦åŠnameidataã€‚ */static bool try_to_unlazy(struct nameidata *nd)&#123; struct dentry *parent = nd-&gt;path.dentry; BUG_ON(!(nd-&gt;flags &amp; LOOKUP_RCU)); if (unlikely(!legitimize_links(nd))) goto out1; if (unlikely(!legitimize_path(nd, &amp;nd-&gt;path, nd-&gt;seq))) goto out; if (unlikely(!legitimize_root(nd))) goto out; leave_rcu(nd); BUG_ON(nd-&gt;inode != parent-&gt;d_inode); return true;out1: nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL;out: leave_rcu(nd); return false;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * try_to_unlazy_next - å°è¯•åˆ‡æ¢åˆ°å¼•ç”¨éå†æ¨¡å¼ã€‚ * @nd: nameidataè·¯å¾„éå†æ•°æ® * @dentry: éœ€è¦æ­¥å…¥çš„ä¸‹ä¸€ä¸ªdentry * è¿”å›: æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false * * ç±»ä¼¼äºtry_to_unlazy()ï¼Œä½†åœ¨è¿™é‡Œæˆ‘ä»¬å·²ç»é€šè¿‡rcu-walké€‰æ‹©äº†ä¸‹ä¸€ä¸ªdentryï¼Œ * å¹¶å¸Œæœ›é™¤äº†å½“å‰çš„nd-&gt;pathå’Œnd-&gt;rootå¤–ï¼Œè¿˜è¦å°†å…¶åˆæ³•åŒ–ä¸ºå¼•ç”¨éå†æ¨¡å¼ã€‚ * å¿…é¡»åœ¨rcu-walkä¸Šä¸‹æ–‡ä¸­è°ƒç”¨ã€‚ * åœ¨try_to_unlazy_next()å¤±è´¥å’Œterminate_walk()ä¹‹é—´ï¼Œä¸åº”è§¦åŠnameidataã€‚ */static bool try_to_unlazy_next(struct nameidata *nd, struct dentry *dentry)&#123; int res; BUG_ON(!(nd-&gt;flags &amp; LOOKUP_RCU)); if (unlikely(!legitimize_links(nd))) goto out2; res = __legitimize_mnt(nd-&gt;path.mnt, nd-&gt;m_seq); if (unlikely(res)) &#123; if (res &gt; 0) goto out2; goto out1; &#125; if (unlikely(!lockref_get_not_dead(&amp;nd-&gt;path.dentry-&gt;d_lockref))) goto out1; /* * æˆ‘ä»¬éœ€è¦å°†çˆ¶èŠ‚ç‚¹å’Œdentryä»RCUé¢†åŸŸç§»åŠ¨åˆ°é€‚å½“çš„å¼•ç”¨è®¡æ•°ã€‚ * å¹¶ä¸”dentryä¸­çš„åºåˆ—å·éªŒè¯äº†*ä¸¤ä¸ª* dentryè®¡æ•°å™¨ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨è·å–å­åºåˆ—å·åæ£€æŸ¥äº†çˆ¶åºåˆ—å·ã€‚ * æ‰€ä»¥æˆ‘ä»¬çŸ¥é“å¦‚æœå­åºåˆ—å·æ˜¯æœ‰æ•ˆçš„ï¼Œé‚£ä¹ˆçˆ¶èŠ‚ç‚¹å¿…é¡»ä»ç„¶æ˜¯æœ‰æ•ˆçš„ã€‚ */ if (unlikely(!lockref_get_not_dead(&amp;dentry-&gt;d_lockref))) goto out; if (read_seqcount_retry(&amp;dentry-&gt;d_seq, nd-&gt;next_seq)) goto out_dput; /* * åºåˆ—è®¡æ•°åŒ¹é…ã€‚ç°åœ¨ç¡®ä¿rootä»ç„¶æœ‰æ•ˆï¼Œå¹¶åœ¨éœ€è¦æ—¶è·å–å®ƒã€‚ */ if (unlikely(!legitimize_root(nd))) goto out_dput; leave_rcu(nd); return true;out2: nd-&gt;path.mnt = NULL;out1: nd-&gt;path.dentry = NULL;out: leave_rcu(nd); return false;out_dput: leave_rcu(nd); dput(dentry); return false;&#125; 12345678910// æ£€æŸ¥dentryæ˜¯å¦éœ€è¦è¿›ä¸€æ­¥éªŒè¯static inline int d_revalidate(struct dentry *dentry, unsigned int flags)&#123; // å¦‚æœdentryè®¾ç½®äº†DCACHE_OP_REVALIDATEæ ‡å¿—ï¼Œåˆ™è°ƒç”¨d_revalidateè¿›è¡ŒéªŒè¯ if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE)) return dentry-&gt;d_op-&gt;d_revalidate(dentry, flags); else // å¦åˆ™ç›´æ¥è¿”å›1è¡¨ç¤ºéªŒè¯æˆåŠŸ return 1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * complete_walk - å®Œæˆè·¯å¾„éå† * @nd: nameidataæŒ‡é’ˆ * * å¦‚æœæˆ‘ä»¬å¤„äºRCUæ¨¡å¼ï¼Œé€€å‡ºå®ƒå¹¶åˆæ³•åŒ–nd-&gt;pathã€‚ * é™¤éæˆ‘ä»¬åœ¨è·¯å¾„éå†è¿‡ç¨‹ä¸­å·²ç»å®Œæˆäº†éªŒè¯ï¼Œæˆ–è€…æ–‡ä»¶ç³»ç»Ÿä¸éœ€è¦éªŒè¯ï¼Œå¦åˆ™é‡æ–°éªŒè¯æœ€åçš„ç»“æœã€‚ * æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-errorã€‚åœ¨å¤±è´¥çš„æƒ…å†µä¸‹ï¼Œè°ƒç”¨è€…æ— éœ€ä¸¢å¼ƒnd-&gt;pathã€‚ */static int complete_walk(struct nameidata *nd)&#123; struct dentry *dentry = nd-&gt;path.dentry; // è·å–è·¯å¾„çš„dentry int status; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœåœ¨RCUæ¨¡å¼ä¸‹ /* * å¯¹äºscoped-lookupsæˆ–å¤–éƒ¨ç®¡ç†çš„nd-&gt;rootï¼Œæˆ‘ä»¬ä¸æƒ³å°†nd-&gt;rootç½®ä¸º0ã€‚ */ if (!(nd-&gt;state &amp; ND_ROOT_PRESET)) // å¦‚æœnd-&gt;stateæ²¡æœ‰è®¾ç½®ND_ROOT_PRESET if (!(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) // å¦‚æœæ²¡æœ‰è®¾ç½®LOOKUP_IS_SCOPED nd-&gt;root.mnt = NULL; // å°†nd-&gt;root.mntç½®ä¸ºNULL nd-&gt;flags &amp;= ~LOOKUP_CACHED; // æ¸…é™¤LOOKUP_CACHEDæ ‡å¿— if (!try_to_unlazy(nd)) // å°è¯•é€€å‡ºlazyæ¨¡å¼ return -ECHILD; // å¦‚æœå¤±è´¥ï¼Œè¿”å›-ECHILD &#125; if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123; // å¦‚æœè®¾ç½®äº†LOOKUP_IS_SCOPED /* * å°½ç®¡LOOKUP_IS_SCOPEDçš„ä¿è¯å¤§æ¦‚æ˜¯&quot;åœ¨æŸ¥æ‰¾è¿‡ç¨‹ä¸­ä¸è¦èµ°å‡ºroot&quot;ï¼Œè¿™åº”è¯¥å·²ç»è¢«nameiçš„å…¶ä½™éƒ¨åˆ†ä¿è¯äº†ï¼Œ * ä½†æˆ‘ä»¬å¸Œæœ›é¿å…nameiçš„BUGå¯¼è‡´ç”¨æˆ·ç©ºé—´å¾—åˆ°ä¸€ä¸ªåœ¨æŸ¥æ‰¾è¿‡ç¨‹ä¸­æŸä¸ªæ—¶ç‚¹ä¸åœ¨rootå†…çš„è·¯å¾„ã€‚ * * å› æ­¤ï¼Œè¿›è¡Œæœ€åçš„å¥å…¨æ€§æ£€æŸ¥ï¼Œç¡®ä¿åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼ˆå®Œå…¨ç»•è¿‡LOOKUP_IS_SCOPEDï¼‰æˆ‘ä»¬ä¸ä¼šæ— å£°æ— æ¯åœ° * å°†ä¸€ä¸ªå®Œå…¨åœ¨è¯·æ±‚çš„rootå¤–çš„fdè¿”å›ç»™ç”¨æˆ·ç©ºé—´ã€‚ * * ç”¨æˆ·ç©ºé—´å¯èƒ½ä¼šåœ¨è¿™ä¸ªæ£€æŸ¥ä¹‹åå°†è·¯å¾„ç§»å‡ºrootï¼Œä½†æ˜¯å¦‚å…¶ä»–åœ°æ–¹æ‰€è®¨è®ºçš„ï¼Œè¿™ä¸æ˜¯é—®é¢˜ï¼ˆè§£æçš„æ–‡ä»¶æ›¾ç»åœ¨rootå†…ï¼‰ã€‚ */ if (!path_is_under(&amp;nd-&gt;path, &amp;nd-&gt;root)) // åˆ¤æ–­nd-&gt;pathæ˜¯å¦åœ¨nd-&gt;rootä¸‹ return -EXDEV; // å¦‚æœä¸åœ¨ï¼Œè¿”å›-EXDEV &#125; if (likely(!(nd-&gt;state &amp; ND_JUMPED))) // å¦‚æœnd-&gt;stateæ²¡æœ‰è®¾ç½®ND_JUMPED return 0; // è¿”å›0 if (likely(!(dentry-&gt;d_flags &amp; DCACHE_OP_WEAK_REVALIDATE))) // å¦‚æœdentryçš„d_flagsæ²¡æœ‰è®¾ç½®DCACHE_OP_WEAK_REVALIDATE return 0; // è¿”å›0 status = dentry-&gt;d_op-&gt;d_weak_revalidate(dentry, nd-&gt;flags); // æ‰§è¡Œå¼±éªŒè¯ if (status &gt; 0) // å¦‚æœéªŒè¯æˆåŠŸ return 0; // è¿”å›0 if (!status) // å¦‚æœéªŒè¯å¤±è´¥ status = -ESTALE; // è®¾ç½®statusä¸º-ESTALE return status; // è¿”å›status&#125; 12345678910111213141516171819202122232425static int set_root(struct nameidata *nd)&#123; struct fs_struct *fs = current-&gt;fs; // è·å–å½“å‰çš„æ–‡ä»¶ç³»ç»Ÿç»“æ„ /* * åœ¨scoped-lookupä¸­è·³è½¬åˆ°å®é™…çš„rootæ˜¯nameiçš„BUGï¼Œä½†æˆ‘ä»¬ä»ç„¶å¿…é¡»ç¡®ä¿å®ƒä¸ä¼šå‘ç”Ÿï¼Œ * å› ä¸ºå®ƒä¼šå¯¼è‡´ä»dirfdä¸­è·³å‡ºã€‚ */ if (WARN_ON(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) // å¦‚æœè®¾ç½®äº†LOOKUP_IS_SCOPEDï¼Œå‘å‡ºè­¦å‘Š return -ENOTRECOVERABLE; // è¿”å›-ENOTRECOVERABLE if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœåœ¨RCUæ¨¡å¼ä¸‹ unsigned seq; do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); // è¯»å–fsçš„seq nd-&gt;root = fs-&gt;root; nd-&gt;root_seq = __read_seqcount_begin(&amp;nd-&gt;root.dentry-&gt;d_seq); // è¯»å–nd-&gt;rootçš„dentryçš„d_seq &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); // å¦‚æœfsçš„seqæœ‰å˜åŠ¨ï¼Œé‡è¯• &#125; else &#123; get_fs_root(fs, &amp;nd-&gt;root); // è·å–fsçš„rootï¼Œè®¾ç½®åˆ°nd-&gt;root nd-&gt;state |= ND_ROOT_GRABBED; // è®¾ç½®nd-&gt;stateçš„ND_ROOT_GRABBED &#125; return 0; // è¿”å›0&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int nd_jump_root(struct nameidata *nd)&#123; // å¦‚æœè®¾ç½®äº†LOOKUP_BENEATHæ ‡å¿—ï¼Œè¿”å›-EXDEV if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) return -EXDEV; // å¦‚æœè®¾ç½®äº†LOOKUP_NO_XDEVæ ‡å¿— if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) &#123; /* Absolute path arguments to path_init() are allowed. */ // å¦‚æœnd-&gt;path.mntä¸ä¸ºç©ºï¼Œå¹¶ä¸”nd-&gt;path.mntä¸ç­‰äºnd-&gt;root.mntï¼Œè¿”å›-EXDEV if (nd-&gt;path.mnt != NULL &amp;&amp; nd-&gt;path.mnt != nd-&gt;root.mnt) return -EXDEV; &#125; // å¦‚æœnd-&gt;root.mntä¸ºç©º if (!nd-&gt;root.mnt) &#123; // è°ƒç”¨set_rootè®¾ç½®rootï¼Œå¹¶æ£€æŸ¥è¿”å›å€¼ int error = set_root(nd); if (error) return error; &#125; // å¦‚æœè®¾ç½®äº†LOOKUP_RCUæ ‡å¿— if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; struct dentry *d; nd-&gt;path = nd-&gt;root; // å°†nd-&gt;rootèµ‹å€¼ç»™nd-&gt;path d = nd-&gt;path.dentry; // è·å–nd-&gt;pathçš„dentry nd-&gt;inode = d-&gt;d_inode; // è·å–dentryçš„inodeèµ‹å€¼ç»™nd-&gt;inode nd-&gt;seq = nd-&gt;root_seq; // å°†nd-&gt;root_seqèµ‹å€¼ç»™nd-&gt;seq // å¦‚æœd-&gt;d_seqå’Œnd-&gt;seqä¸åŒ¹é…ï¼Œè¿”å›-ECHILD if (read_seqcount_retry(&amp;d-&gt;d_seq, nd-&gt;seq)) return -ECHILD; &#125; else &#123; // å¦‚æœæ²¡æœ‰è®¾ç½®LOOKUP_RCUæ ‡å¿— path_put(&amp;nd-&gt;path); // é€’å‡nd-&gt;pathçš„å¼•ç”¨è®¡æ•° nd-&gt;path = nd-&gt;root; // å°†nd-&gt;rootèµ‹å€¼ç»™nd-&gt;path path_get(&amp;nd-&gt;path); // é€’å¢nd-&gt;pathçš„å¼•ç”¨è®¡æ•° nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // è·å–nd-&gt;pathçš„dentryçš„inodeèµ‹å€¼ç»™nd-&gt;inode &#125; // è®¾ç½®ND_JUMPEDæ ‡å¿— nd-&gt;state |= ND_JUMPED; return 0; // è¿”å›0&#125; 12345678910111213141516171819202122232425262728293031323334/* * Helper to directly jump to a known parsed path from -&gt;get_link, * caller must have taken a reference to path beforehand. */int nd_jump_link(const struct path *path)&#123; int error = -ELOOP; // åˆå§‹åŒ–errorä¸º-ELOOP struct nameidata *nd = current-&gt;nameidata; // è·å–å½“å‰çš„nameidata // å¦‚æœè®¾ç½®äº†LOOKUP_NO_MAGICLINKSæ ‡å¿— if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_MAGICLINKS)) goto err; error = -EXDEV; // å°†errorè®¾ç½®ä¸º-EXDEV // å¦‚æœè®¾ç½®äº†LOOKUP_NO_XDEVæ ‡å¿— if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) &#123; if (nd-&gt;path.mnt != path-&gt;mnt) // å¦‚æœnd-&gt;path.mntä¸ç­‰äºpath-&gt;mnt goto err; &#125; // å¦‚æœè®¾ç½®äº†LOOKUP_IS_SCOPEDæ ‡å¿— if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) goto err; path_put(&amp;nd-&gt;path); // é€’å‡nd-&gt;pathçš„å¼•ç”¨è®¡æ•° nd-&gt;path = *path; // å°†*pathèµ‹å€¼ç»™nd-&gt;path nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // è·å–nd-&gt;pathçš„dentryçš„inodeèµ‹å€¼ç»™nd-&gt;inode nd-&gt;state |= ND_JUMPED; // è®¾ç½®ND_JUMPEDæ ‡å¿— return 0; // è¿”å›0err: path_put(path); // é€’å‡pathçš„å¼•ç”¨è®¡æ•° return error; // è¿”å›error&#125; 123456789101112static inline void put_link(struct nameidata *nd)&#123; // è·å–nd-&gt;stackä¸­çš„æœ€åä¸€ä¸ªå…ƒç´  struct saved *last = nd-&gt;stack + --nd-&gt;depth; // å»¶è¿Ÿè°ƒç”¨ do_delayed_call(&amp;last-&gt;done); // å¦‚æœæ²¡è®¾ç½®LOOKUP_RCUæ ‡å¿—ï¼Œåˆ™é€’å‡last-&gt;linkçš„å¼•ç”¨è®¡æ•° if (!(nd-&gt;flags &amp; LOOKUP_RCU)) path_put(&amp;last-&gt;link);&#125; 12345// å®šä¹‰å››ä¸ªé™æ€æ•´å‹å˜é‡ï¼Œç”¨äºå­˜å‚¨ç³»ç»Ÿé…ç½®ä¿¡æ¯ï¼Œ__read_mostlyæŒ‡ç¤ºè¿™äº›æ•°æ®ä¸»è¦æ˜¯è¢«è¯»å–static int sysctl_protected_symlinks __read_mostly;static int sysctl_protected_hardlinks __read_mostly;static int sysctl_protected_fifos __read_mostly;static int sysctl_protected_regular __read_mostly; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#ifdef CONFIG_SYSCTL// å®šä¹‰ä¸€ä¸ªåŒ…å«å››ä¸ªå…ƒç´ çš„ctl_tableæ•°ç»„ï¼Œ// ç”¨äºå­˜å‚¨å››ä¸ªä¸åŒçš„ç³»ç»Ÿé…ç½®é¡¹çš„ä¿¡æ¯static struct ctl_table namei_sysctls[] = &#123; &#123; // ç³»ç»Ÿé…ç½®é¡¹çš„åç§° .procname = &quot;protected_symlinks&quot;, // æŒ‡å‘å­˜å‚¨é…ç½®é¡¹å€¼çš„å˜é‡çš„æŒ‡é’ˆ .data = &amp;sysctl_protected_symlinks, // å­˜å‚¨é…ç½®é¡¹å€¼çš„å˜é‡çš„å¤§å° .maxlen = sizeof(int), // é…ç½®é¡¹çš„æƒé™ .mode = 0644, // å¤„ç†é…ç½®é¡¹å€¼çš„å‡½æ•° .proc_handler = proc_dointvec_minmax, // é…ç½®é¡¹å€¼çš„æœ€å°å€¼ .extra1 = SYSCTL_ZERO, // é…ç½®é¡¹å€¼çš„æœ€å¤§å€¼ .extra2 = SYSCTL_ONE, &#125;, // ä»¥ä¸‹ä¸‰ä¸ªå…ƒç´ ä¸ç¬¬ä¸€ä¸ªç±»ä¼¼ï¼Œä¸å†èµ˜è¿° &#123; .procname = &quot;protected_hardlinks&quot;, .data = &amp;sysctl_protected_hardlinks, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax, .extra1 = SYSCTL_ZERO, .extra2 = SYSCTL_ONE, &#125;, &#123; .procname = &quot;protected_fifos&quot;, .data = &amp;sysctl_protected_fifos, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax, .extra1 = SYSCTL_ZERO, .extra2 = SYSCTL_TWO, &#125;, &#123; .procname = &quot;protected_regular&quot;, .data = &amp;sysctl_protected_regular, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax, .extra1 = SYSCTL_ZERO, .extra2 = SYSCTL_TWO, &#125;, // ç»“æŸæ ‡å¿— &#123; &#125;&#125;;// åˆå§‹åŒ–å‡½æ•°static int __init init_fs_namei_sysctls(void)&#123; // æ³¨å†Œç³»ç»Ÿé…ç½®é¡¹ register_sysctl_init(&quot;fs&quot;, namei_sysctls); return 0;&#125;// å°†åˆå§‹åŒ–å‡½æ•°æ·»åŠ åˆ°fs_initcallåˆ—è¡¨ä¸­ï¼Œ// è¿™æ ·åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œinit_fs_namei_sysctlsä¼šè¢«è‡ªåŠ¨è°ƒç”¨fs_initcall(init_fs_namei_sysctls);#endif /* CONFIG_SYSCTL */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * may_follow_link - æ£€æŸ¥ç¬¦å·é“¾æ¥çš„è·Ÿè¸ªæ˜¯å¦å­˜åœ¨ä¸å®‰å…¨æƒ…å†µ * @nd: nameidataè·¯å¾„éå†æ•°æ® * * åœ¨å¯ç”¨sysctl_protected_symlinksç³»ç»Ÿé…ç½®é¡¹çš„æƒ…å†µä¸‹ï¼Œ * å¦‚æœç¬¦å·é“¾æ¥ä½äºç²˜æ€§å…¨å±€å¯å†™ç›®å½•ä¸­ï¼Œéœ€è¦ç‰¹åˆ«å¿½ç•¥CAP_DAC_OVERRIDEã€‚ * è¿™æ˜¯ä¸ºäº†ä¿æŠ¤ç‰¹æƒè¿›ç¨‹ä¸å—è·¯å¾„åå¯èƒ½å› å…¶ä»–ç”¨æˆ·åˆ›å»ºæ¶æ„ç¬¦å·é“¾æ¥è€Œæ”¹å˜çš„ç«æ€æ¡ä»¶çš„å½±å“ã€‚ * å®ƒå°†åªå…è®¸åœ¨ç²˜æ€§å…¨å±€å¯å†™ç›®å½•å¤–éƒ¨ï¼Œæˆ–è€…ç¬¦å·é“¾æ¥çš„uidä¸è·Ÿéšè€…åŒ¹é…ï¼Œ * æˆ–è€…ç›®å½•æ‰€æœ‰è€…ä¸ç¬¦å·é“¾æ¥çš„æ‰€æœ‰è€…åŒ¹é…æ—¶è·Ÿè¸ªç¬¦å·é“¾æ¥ã€‚ * * å¦‚æœå…è®¸è·Ÿè¸ªç¬¦å·é“¾æ¥ï¼Œåˆ™è¿”å›0ï¼Œå¦‚æœå‡ºé”™ï¼Œåˆ™è¿”å›-veã€‚ */static inline int may_follow_link(struct nameidata *nd, const struct inode *inode)&#123; // å£°æ˜å˜é‡ struct mnt_idmap *idmap; vfsuid_t vfsuid; // å¦‚æœæœªå¯ç”¨sysctl_protected_symlinksç³»ç»Ÿé…ç½®é¡¹ï¼Œè¿”å›0 if (!sysctl_protected_symlinks) return 0; // è·å–nd-&gt;path.mntçš„mnt_idmap idmap = mnt_idmap(nd-&gt;path.mnt); // å°†inodeçš„i_uidè½¬æ¢ä¸ºvfsuid vfsuid = i_uid_into_vfsuid(idmap, inode); // å¦‚æœæ‰€æœ‰è€…å’Œè·Ÿéšè€…åŒ¹é…ï¼Œåˆ™å…è®¸ if (vfsuid_eq_kuid(vfsuid, current_fsuid())) return 0; // å¦‚æœçˆ¶ç›®å½•ä¸æ˜¯ç²˜æ€§çš„å’Œå…¨å±€å¯å†™çš„ï¼Œåˆ™å…è®¸ if ((nd-&gt;dir_mode &amp; (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH)) return 0; // å¦‚æœçˆ¶ç›®å½•å’Œé“¾æ¥æ‰€æœ‰è€…åŒ¹é…ï¼Œåˆ™å…è®¸ if (vfsuid_valid(nd-&gt;dir_vfsuid) &amp;&amp; vfsuid_eq(nd-&gt;dir_vfsuid, vfsuid)) return 0; // å¦‚æœè®¾ç½®äº†LOOKUP_RCUæ ‡å¿—ï¼Œè¿”å›-ECHILD if (nd-&gt;flags &amp; LOOKUP_RCU) return -ECHILD; // å®¡è®¡inode audit_inode(nd-&gt;name, nd-&gt;stack[0].link.dentry, 0); // è®°å½•è¢«æ‹’ç»çš„è·¯å¾„ audit_log_path_denied(AUDIT_ANOM_LINK, &quot;follow_link&quot;); // è¿”å›-EACCES return -EACCES;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * safe_hardlink_source - æ£€æŸ¥å®‰å…¨çš„ç¡¬é“¾æ¥æ¡ä»¶ * @idmap: inodeæ‰€åœ¨æŒ‚è½½ç‚¹çš„idmap * @inode: è¦ä»ä¸­åˆ›å»ºç¡¬é“¾æ¥çš„æºinode * * å¦‚æœæ»¡è¶³ä»¥ä¸‹ä»»ä¸€æ¡ä»¶ï¼Œè¿”å›falseï¼š * - inodeä¸æ˜¯ä¸€ä¸ªæ™®é€šæ–‡ä»¶ * - inodeæ˜¯setuid * - inodeæ˜¯setgidå¹¶ä¸”æ˜¯ç»„å¯æ‰§è¡Œçš„ * - è¯»å†™è®¿é—®å¤±è´¥ * * å¦åˆ™è¿”å›trueã€‚ */static bool safe_hardlink_source(struct mnt_idmap *idmap, struct inode *inode)&#123; // è·å–inodeçš„æ¨¡å¼ umode_t mode = inode-&gt;i_mode; // å¦‚æœinodeä¸æ˜¯ä¸€ä¸ªæ™®é€šæ–‡ä»¶ï¼Œè¿”å›false if (!S_ISREG(mode)) return false; // å¦‚æœinodeæ˜¯setuidï¼Œè¿”å›false if (mode &amp; S_ISUID) return false; // å¦‚æœinodeæ˜¯å¯æ‰§è¡Œçš„setgidæ–‡ä»¶ï¼Œè¿”å›false if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) return false; // å¦‚æœæ— æ³•è¯»å–æˆ–å†™å…¥æºæ–‡ä»¶ï¼Œåˆ™åˆ›å»ºç¡¬é“¾æ¥æ˜¯å±é™©çš„ï¼Œè¿”å›false if (inode_permission(idmap, inode, MAY_READ | MAY_WRITE)) return false; // å¦åˆ™è¿”å›true return true;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * may_linkat - æ£€æŸ¥åˆ›å»ºç¡¬é“¾æ¥çš„æƒé™ * @idmap: inode æ‰€åœ¨æŒ‚è½½ç‚¹çš„ idmap * @link: è¦ä»å“ªé‡Œåˆ›å»ºç¡¬é“¾æ¥ * * é˜»æ­¢ä»¥ä¸‹æƒ…å†µçš„ç¡¬é“¾æ¥åˆ›å»ºï¼š * - å¯ç”¨äº† sysctl_protected_hardlinks * - fsuid ä¸ inode ä¸åŒ¹é… * - ç¡¬é“¾æ¥æºä¸å®‰å…¨ï¼ˆå‚è§ä¸Šè¿° safe_hardlink_source()ï¼‰ * - åœ¨ inode æ‰€æœ‰è€… uid æ˜ å°„çš„å‘½åç©ºé—´ä¸­ï¼Œä¸æ˜¯ CAP_FOWNER * * å¦‚æœé€šè¿‡ idmapped æŒ‚è½½æ‰¾åˆ° inodeï¼Œåˆ™å¿…é¡»é€šè¿‡ @idmap ä¼ é€’ vfsmount çš„ idmapã€‚ * æ­¤å‡½æ•°å°†ä¼šæ ¹æ® @idmap æ˜ å°„ inodeï¼Œç„¶åè¿›è¡Œæƒé™æ£€æŸ¥ã€‚ * åœ¨é idmapped æŒ‚è½½ä¸Šæˆ–è€…å¦‚æœè¦å¯¹åŸå§‹ inode è¿›è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’ @nop_mnt_idmap å³å¯ã€‚ * * å¦‚æœæˆåŠŸï¼Œåˆ™è¿”å› 0ï¼›å¦‚æœå‡ºé”™ï¼Œåˆ™è¿”å›è´Ÿå€¼ã€‚ */int may_linkat(struct mnt_idmap *idmap, const struct path *link)&#123; // ä»é“¾æ¥è·¯å¾„ä¸­è·å– inode struct inode *inode = link-&gt;dentry-&gt;d_inode; // å¦‚æœ uid æˆ– gid æ— æ•ˆï¼Œåˆ™ inode å†™å›ä¸å®‰å…¨ if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) || !vfsgid_valid(i_gid_into_vfsgid(idmap, inode))) return -EOVERFLOW; // å¦‚æœæ²¡æœ‰å¯ç”¨ sysctl_protected_hardlinksï¼Œåˆ™å‡½æ•°å¯ä»¥æˆåŠŸè¿”å› if (!sysctl_protected_hardlinks) return 0; // å¦‚æœæ˜¯å®‰å…¨çš„ç¡¬é“¾æ¥æºï¼Œæˆ–è€…æ˜¯æº inode çš„æ‰€æœ‰è€…ï¼ˆæˆ–è€…æ˜¯ CAP_FOWNERï¼‰ï¼Œåˆ™å¯ä»¥æˆåŠŸè¿”å› if (safe_hardlink_source(idmap, inode) || inode_owner_or_capable(idmap, inode)) return 0; // å¦‚æœåˆ°è¾¾è¿™é‡Œï¼Œè¯´æ˜é“¾æ¥è¢«æ‹’ç»ï¼Œå› æ­¤è®°å½•å®ƒå¹¶è¿”å›æƒé™é”™è¯¯ audit_log_path_denied(AUDIT_ANOM_LINK, &quot;linkat&quot;); return -EPERM;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * may_create_in_sticky - æ£€æŸ¥åœ¨ç²˜æ€§ç›®å½•ä¸­æ˜¯å¦åº”å…è®¸ O_CREAT æ‰“å¼€å·²å­˜åœ¨çš„æ–‡ä»¶ * @idmap: inode æ‰€åœ¨æŒ‚è½½ç‚¹çš„ idmap * @nd: è·¯å¾„éå†æ•°æ® * @inode: è¦æ‰“å¼€çš„æ–‡ä»¶çš„ inode * * å½“ä»¥ä¸‹æ¡ä»¶æ»¡è¶³æ—¶ï¼Œé˜»æ­¢ O_CREAT æ‰“å¼€ FIFOï¼ˆæˆ–å¸¸è§„æ–‡ä»¶ï¼‰ï¼š * - å¯ç”¨äº† sysctl_protected_fifosï¼ˆæˆ– sysctl_protected_regularï¼‰ * - æ–‡ä»¶å·²ç»å­˜åœ¨ * - æˆ‘ä»¬åœ¨ç²˜æ€§ç›®å½•å†… * - æˆ‘ä»¬ä¸æ‹¥æœ‰æ–‡ä»¶ * - ç›®å½•çš„æ‰€æœ‰è€…ä¸æ‹¥æœ‰æ–‡ä»¶ * - ç›®å½•æ˜¯å…¨ä¸–ç•Œå¯å†™çš„ * å¦‚æœå°† sysctl_protected_fifosï¼ˆæˆ– sysctl_protected_regularï¼‰è®¾ç½®ä¸º 2ï¼Œ * é‚£ä¹ˆç›®å½•ä¸å¿…æ˜¯å…¨ä¸–ç•Œå¯å†™çš„ï¼šåªéœ€è¦æ˜¯ç»„å¯å†™å°±è¶³å¤Ÿäº†ã€‚ * * å¦‚æœé€šè¿‡ idmapped æŒ‚è½½æ‰¾åˆ° inodeï¼Œåˆ™å¿…é¡»é€šè¿‡ @idmap ä¼ é€’ vfsmount çš„ idmapã€‚ * æ­¤å‡½æ•°å°†ä¼šæ ¹æ® @idmap æ˜ å°„ inodeï¼Œç„¶åè¿›è¡Œæƒé™æ£€æŸ¥ã€‚ * åœ¨é idmapped æŒ‚è½½ä¸Šæˆ–è€…å¦‚æœè¦å¯¹åŸå§‹ inode è¿›è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’ @nop_mnt_idmap å³å¯ã€‚ * * å¦‚æœå…è®¸æ‰“å¼€ï¼Œåˆ™è¿”å› 0ï¼›å¦‚æœå‡ºé”™ï¼Œåˆ™è¿”å›è´Ÿå€¼ã€‚ */static int may_create_in_sticky(struct mnt_idmap *idmap, struct nameidata *nd, struct inode *const inode)&#123; // è·å–ç›®å½•æ¨¡å¼å’Œ uid umode_t dir_mode = nd-&gt;dir_mode; vfsuid_t dir_vfsuid = nd-&gt;dir_vfsuid; // å¦‚æœæ²¡æœ‰å¯ç”¨ sysctl_protected_fifosï¼Œæˆ–è€…æ²¡æœ‰å¯ç”¨ sysctl_protected_regularï¼Œæˆ–è€…ç›®å½•ä¸æ˜¯ç²˜æ€§çš„ï¼Œæˆ–è€… inode çš„ uid ä¸ç›®å½•çš„ uid æˆ–å½“å‰çš„ fsuid åŒ¹é…ï¼Œåˆ™æˆåŠŸè¿”å› if ((!sysctl_protected_fifos &amp;&amp;S_ISFIFO(inode-&gt;i_mode)) || (!sysctl_protected_regular &amp;&amp; S_ISREG(inode-&gt;i_mode)) || likely(!(dir_mode &amp; S_ISVTX)) || vfsuid_eq(i_uid_into_vfsuid(idmap, inode), dir_vfsuid) || vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), current_fsuid())) return 0; // å¦‚æœç›®å½•æ˜¯å…¨ä¸–ç•Œå¯å†™çš„ï¼Œæˆ–è€…å½“ sysctl_protected_fifosï¼ˆæˆ– sysctl_protected_regularï¼‰è®¾ç½®ä¸º 2 æ—¶ï¼Œç›®å½•æ˜¯ç»„å¯å†™çš„ï¼Œé‚£ä¹ˆè®°å½•å¹¶è¿”å›æƒé™é”™è¯¯ if (likely(dir_mode &amp; 0002) || (dir_mode &amp; 0020 &amp;&amp; ((sysctl_protected_fifos &gt;= 2 &amp;&amp; S_ISFIFO(inode-&gt;i_mode)) || (sysctl_protected_regular &gt;= 2 &amp;&amp; S_ISREG(inode-&gt;i_mode))))) &#123; const char *operation = S_ISFIFO(inode-&gt;i_mode) ? &quot;sticky_create_fifo&quot; : &quot;sticky_create_regular&quot;; audit_log_path_denied(AUDIT_ANOM_CREAT, operation); return -EACCES; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * follow_up - æ‰¾åˆ°è·¯å¾„çš„ vfsmount çš„æŒ‚è½½ç‚¹ * * ç»™å®šä¸€ä¸ªè·¯å¾„ï¼Œæ‰¾åˆ°å…¶æºæ–‡ä»¶ç³»ç»Ÿçš„æŒ‚è½½ç‚¹ã€‚ * å°† @path æ›¿æ¢ä¸ºçˆ¶æŒ‚è½½ç‚¹ä¸­çš„æŒ‚è½½ç‚¹è·¯å¾„ã€‚ * Up æ˜¯æŒ‡å‘ / çš„æ–¹å‘ã€‚ * * å¦‚æœæˆ‘ä»¬ä¸Šå‡äº†ä¸€çº§ï¼Œåˆ™è¿”å› 1ï¼›å¦‚æœæˆ‘ä»¬å·²ç»åœ¨æ ¹ç›®å½•ï¼Œåˆ™è¿”å› 0ã€‚ */int follow_up(struct path *path)&#123; // è·å–è·¯å¾„çš„æŒ‚è½½ç‚¹ struct mount *mnt = real_mount(path-&gt;mnt); struct mount *parent; struct dentry *mountpoint; // è¯»å–æŒ‚è½½é” read_seqlock_excl(&amp;mount_lock); // è·å–çˆ¶æŒ‚è½½ç‚¹ parent = mnt-&gt;mnt_parent; // å¦‚æœçˆ¶æŒ‚è½½ç‚¹å°±æ˜¯å½“å‰æŒ‚è½½ç‚¹ï¼Œè¡¨ç¤ºå·²ç»åˆ°è¾¾æ ¹ç›®å½•ï¼Œæ­¤æ—¶é‡Šæ”¾é”å¹¶è¿”å› 0 if (parent == mnt) &#123; read_sequnlock_excl(&amp;mount_lock); return 0; &#125; // ä¸ç„¶ï¼Œå¢åŠ çˆ¶æŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•° mntget(&amp;parent-&gt;mnt); // è·å–æŒ‚è½½ç‚¹çš„ dentry mountpoint = dget(mnt-&gt;mnt_mountpoint); // é‡Šæ”¾é” read_sequnlock_excl(&amp;mount_lock); // é‡Šæ”¾åŸæ¥è·¯å¾„çš„ dentry dput(path-&gt;dentry); // å°†è·¯å¾„çš„ dentry æ›¿æ¢ä¸ºæŒ‚è½½ç‚¹çš„ dentry path-&gt;dentry = mountpoint; // é‡Šæ”¾åŸæ¥è·¯å¾„çš„æŒ‚è½½ç‚¹ mntput(path-&gt;mnt); // å°†è·¯å¾„çš„æŒ‚è½½ç‚¹æ›¿æ¢ä¸ºçˆ¶æŒ‚è½½ç‚¹ path-&gt;mnt = &amp;parent-&gt;mnt; // è¿”å› 1ï¼Œè¡¨ç¤ºæˆ‘ä»¬ä¸Šå‡äº†ä¸€çº§ return 1;&#125;EXPORT_SYMBOL(follow_up); 123456789101112131415161718192021222324252627282930// choose_mountpoint_rcu å‡½æ•°// è¯¥å‡½æ•°é€šè¿‡ RCUï¼ˆRead-Copy-Updateï¼‰æœºåˆ¶é€‰æ‹©æŒ‚è½½ç‚¹static bool choose_mountpoint_rcu(struct mount *m, const struct path *root, struct path *path, unsigned *seqp)&#123; // å½“æŒ‚è½½ç‚¹ m æœ‰çˆ¶æŒ‚è½½ç‚¹æ—¶ï¼Œæ‰§è¡Œå¾ªç¯ä½“ while (mnt_has_parent(m)) &#123; // è·å–æŒ‚è½½ç‚¹ m çš„æŒ‚è½½ç‚¹ struct dentry *mountpoint = m-&gt;mnt_mountpoint; // å°† m æ›´æ–°ä¸ºå…¶çˆ¶æŒ‚è½½ç‚¹ m = m-&gt;mnt_parent; // å¦‚æœ root çš„ dentry ä¸ mountpoint ç›¸åŒï¼Œå¹¶ä¸” root çš„ mnt ä¸ m çš„ mnt ç›¸åŒï¼Œåˆ™è·³å‡ºå¾ªç¯ if (unlikely(root-&gt;dentry == mountpoint &amp;&amp; root-&gt;mnt == &amp;m-&gt;mnt)) break; // å¦‚æœ mountpoint ä¸ç­‰äº m çš„ mnt_root if (mountpoint != m-&gt;mnt.mnt_root) &#123; // æ›´æ–° path çš„ mnt å’Œ dentry path-&gt;mnt = &amp;m-&gt;mnt; path-&gt;dentry = mountpoint; // è¯»å– mountpoint çš„åºåˆ—å·åˆ° seqp *seqp = read_seqcount_begin(&amp;mountpoint-&gt;d_seq); // è¿”å› true return true; &#125; &#125; // å¦‚æœå¾ªç¯ç»“æŸè¿˜æ²¡æœ‰è¿”å›ï¼Œé‚£ä¹ˆè¿”å› false return false;&#125; 12345678910111213141516171819202122232425262728293031323334353637// choose_mountpoint å‡½æ•°// é€‰æ‹©æŒ‚è½½ç‚¹static bool choose_mountpoint(struct mount *m, const struct path *root, struct path *path)&#123; bool found; // ç”¨äºå­˜å‚¨æŸ¥æ‰¾ç»“æœ // è·å– RCU è¯»é” rcu_read_lock(); // æ— é™å¾ªç¯ï¼Œç›´åˆ°æ»¡è¶³ä¸€å®šæ¡ä»¶è·³å‡º while (1) &#123; unsigned seq, mseq = read_seqbegin(&amp;mount_lock); // è°ƒç”¨ choose_mountpoint_rcu å‡½æ•° found = choose_mountpoint_rcu(m, root, path, &amp;seq); // å¦‚æœæ²¡æœ‰æ‰¾åˆ° if (unlikely(!found)) &#123; // å¦‚æœ seq æ²¡æœ‰æ”¹å˜ï¼Œè·³å‡ºå¾ªç¯ if (!read_seqretry(&amp;mount_lock, mseq)) break; &#125; else &#123; // å¦‚æœè·¯å¾„åˆæ³•ï¼Œè·³å‡ºå¾ªç¯ if (likely(__legitimize_path(path, seq, mseq))) break; // å…¶ä»–æƒ…å†µï¼Œé‡Šæ”¾ RCU è¯»é” rcu_read_unlock(); // é‡Šæ”¾è·¯å¾„ path_put(path); // é‡æ–°è·å– RCU è¯»é” rcu_read_lock(); &#125; &#125; // é‡Šæ”¾ RCU è¯»é” rcu_read_unlock(); // è¿”å›æŸ¥æ‰¾ç»“æœ return found;&#125; 123456789101112131415161718192021222324// follow_automount å‡½æ•°// æ‰§è¡Œè‡ªåŠ¨æŒ‚è½½static int follow_automount(struct path *path, int *count, unsigned lookup_flags)&#123; // è·å–è·¯å¾„çš„ dentry struct dentry *dentry = path-&gt;dentry; // å¦‚æœåªæ˜¯è¿›è¡ŒçŠ¶æ€æŸ¥è¯¢ï¼Œä¸æ‰§è¡ŒæŒ‚è½½ï¼Œé™¤éæŸ¥è¯¢çš„æ˜¯ä¸€ä¸ªç›®å½•å¹¶ä¸”åœ¨åç§°åé¢åŠ ä¸Šäº† &#x27;/&#x27; // å¦‚æœå¸Œæœ›åœ¨æŒ‚è½½ç‚¹ä¸‹é¢æ‰“å¼€æˆ–åˆ›å»ºä»»ä½•ç±»å‹çš„æ–‡ä»¶ï¼Œæˆ–è€…å¸Œæœ›ç©¿è¶ŠæŒ‚è½½ç‚¹ï¼Œæˆ–è€…å¸Œæœ›æ‰“å¼€å·²ç»æŒ‚è½½çš„ç›®å½•ï¼Œ // æˆ–è€… autofs å°†è´Ÿçš„ dentry æ ‡è®°ä¸ºè‡ªåŠ¨æŒ‚è½½ç‚¹ï¼Œé‚£ä¹ˆæ‰§è¡ŒæŒ‚è½½ if (!(lookup_flags &amp; (LOOKUP_PARENT | LOOKUP_DIRECTORY | LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &amp;&amp; dentry-&gt;d_inode) // è¿”å› -EISDIRï¼Œè¡¨ç¤ºæ˜¯ä¸€ä¸ªç›®å½• return -EISDIR; // å¦‚æœç¬¦å·é“¾æ¥çš„æ•°é‡å¤§äºç­‰äº MAXSYMLINKS if (count &amp;&amp; (*count)++ &gt;= MAXSYMLINKS) // è¿”å› -ELOOPï¼Œè¡¨ç¤ºæœ‰è¿‡å¤šçš„ç¬¦å·é“¾æ¥ return -ELOOP; // è°ƒç”¨ finish_automount å‡½æ•°å®Œæˆè‡ªåŠ¨æŒ‚è½½ return finish_automount(dentry-&gt;d_op-&gt;d_automount(path), path);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// __traverse_mounts å‡½æ•°// è¯¥å‡½æ•°ç”¨äºåœ¨æŒ‚è½½ç‚¹ä¹‹é—´è¿›è¡Œéå†static int __traverse_mounts(struct path *path, unsigned flags, bool *jumped, int *count, unsigned lookup_flags)&#123; struct vfsmount *mnt = path-&gt;mnt; // è·å–è·¯å¾„çš„æŒ‚è½½ç‚¹ bool need_mntput = false; // åˆå§‹åŒ–ä¸€ä¸ªæ ‡å¿—ï¼Œè¡¨ç¤ºæ˜¯å¦éœ€è¦é‡Šæ”¾æŒ‚è½½ç‚¹ int ret = 0; // åˆå§‹åŒ–è¿”å›å€¼ // å½“ dentry æ˜¯ç”±æ–‡ä»¶ç³»ç»Ÿç®¡ç†çš„æ—¶å€™ï¼Œæ‰§è¡Œå¾ªç¯ while (flags &amp; DCACHE_MANAGED_DENTRY) &#123; // å¦‚æœæ–‡ä»¶ç³»ç»Ÿç®¡ç†äº† transit if (flags &amp; DCACHE_MANAGE_TRANSIT) &#123; // è®©æ–‡ä»¶ç³»ç»Ÿç®¡ç† transit ret = path-&gt;dentry-&gt;d_op-&gt;d_manage(path, false); // è·å–æ–°çš„ flags flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); // å¦‚æœè¿”å›å€¼å°äº0ï¼Œè·³å‡ºå¾ªç¯ if (ret &lt; 0) break; &#125; // å¦‚æœåœ¨ dentry ä¸ŠæŒ‚è½½äº†ä¸œè¥¿ if (flags &amp; DCACHE_MOUNTED) &#123; // æŸ¥æ‰¾æŒ‚è½½ç‚¹ struct vfsmount *mounted = lookup_mnt(path); // å¦‚æœåœ¨æˆ‘ä»¬çš„å‘½åç©ºé—´ä¸­æ‰¾åˆ°äº†æŒ‚è½½ç‚¹ if (mounted) &#123; // é‡Šæ”¾æ—§çš„ dentryï¼Œæ›´æ–°è·¯å¾„çš„æŒ‚è½½ç‚¹å’Œ dentry dput(path-&gt;dentry); if (need_mntput) mntput(path-&gt;mnt); path-&gt;mnt = mounted; path-&gt;dentry = dget(mounted-&gt;mnt_root); // åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬çŸ¥é“å®ƒæ˜¯ positive çš„ flags = path-&gt;dentry-&gt;d_flags; need_mntput = true; continue; &#125; &#125; // å¦‚æœä¸éœ€è¦è‡ªåŠ¨æŒ‚è½½ï¼Œè·³å‡ºå¾ªç¯ if (!(flags &amp; DCACHE_NEED_AUTOMOUNT)) break; // å¦‚æœå‘ç° uncovered çš„è‡ªåŠ¨æŒ‚è½½ç‚¹ï¼Œæ‰§è¡Œè‡ªåŠ¨æŒ‚è½½ ret = follow_automount(path, count, lookup_flags); flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); if (ret &lt; 0) break; &#125; // å¦‚æœè¿”å›å€¼æ˜¯ -EISDIRï¼Œå°†å…¶è®¾ç½®ä¸º 0 if (ret == -EISDIR) ret = 0; // å¦‚æœä½ ä¸å¤šä¸ª mount --move ç«äº‰ï¼Œè¿™æ˜¯å¯èƒ½çš„ if (need_mntput &amp;&amp; path-&gt;mnt == mnt) mntput(path-&gt;mnt); // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œä½†æ˜¯ flags æ˜¯ negative çš„ï¼Œè¿”å› -ENOENT if (!ret &amp;&amp; unlikely(d_flags_negative(flags))) ret = -ENOENT; *jumped = need_mntput; // æ›´æ–° jumped çš„å€¼ return ret; // è¿”å›ç»“æœ&#125; 123456789101112131415161718// traverse_mounts å‡½æ•°// è¿™æ˜¯ä¸€ä¸ªå†…è”å‡½æ•°ï¼Œç”¨äºéå†æŒ‚è½½ç‚¹static inline int traverse_mounts(struct path *path, bool *jumped, int *count, unsigned lookup_flags)&#123; // è·å– dentry çš„ flags unsigned flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); // å¿«é€Ÿè·¯å¾„ï¼šå¦‚æœ dentry ä¸æ˜¯ç”±æ–‡ä»¶ç³»ç»Ÿç®¡ç†çš„ï¼Œè®¾ç½® jumped ä¸º false å¹¶è¿”å› if (likely(!(flags &amp; DCACHE_MANAGED_DENTRY))) &#123; *jumped = false; if (unlikely(d_flags_negative(flags))) return -ENOENT; return 0; &#125; // å¦åˆ™ï¼Œè°ƒç”¨ __traverse_mounts å‡½æ•°è¿›è¡Œéå† return __traverse_mounts(path, flags, jumped, count, lookup_flags);&#125; 12345678910111213141516171819202122// follow_down_one å‡½æ•°// è¿™ä¸ªå‡½æ•°ä¼šæŸ¥æ‰¾å¹¶è¿”å›å½“å‰è·¯å¾„ä¸‹çš„æŒ‚è½½ç‚¹int follow_down_one(struct path *path)&#123; struct vfsmount *mounted; // æŸ¥æ‰¾å½“å‰è·¯å¾„çš„æŒ‚è½½ç‚¹ mounted = lookup_mnt(path); if (mounted) &#123; // å¦‚æœæ‰¾åˆ°æŒ‚è½½ç‚¹ï¼Œé‡Šæ”¾å½“å‰è·¯å¾„çš„ dentry å’Œ mnt dput(path-&gt;dentry); mntput(path-&gt;mnt); // å¹¶æ›´æ–°è·¯å¾„çš„ mnt å’Œ dentry ä¸ºæ–°æ‰¾åˆ°çš„æŒ‚è½½ç‚¹ path-&gt;mnt = mounted; path-&gt;dentry = dget(mounted-&gt;mnt_root); // è¿”å› 1 è¡¨ç¤ºæˆåŠŸæ‰¾åˆ°æŒ‚è½½ç‚¹ return 1; &#125; // è¿”å› 0 è¡¨ç¤ºæ²¡æœ‰æ‰¾åˆ° &#125; return 0;&#125;EXPORT_SYMBOL(follow_down_one); // æŠŠå‡½æ•° follow_down_one å¯¼å‡ºï¼Œä½¿å¾—å…¶ä»–æ¨¡å—ä¹Ÿèƒ½å¤Ÿè°ƒç”¨ 12345678910111213141516171819/* * follow_down å‡½æ•° * è¿™ä¸ªå‡½æ•°ä¼šéå†å¹¶æ‰¾åˆ°å½“å‰ç”¨æˆ·å¯è§çš„è¦†ç›–æŒ‚è½½ç‚¹ * åœ¨æ¯ä¸ªç‚¹ï¼Œéƒ½ä¼šæŸ¥è¯¢æ‹¥æœ‰è¯¥ dentry çš„æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å…è®¸è°ƒç”¨è€…è¿›è¡Œä¸‹ä¸€æ­¥ */int follow_down(struct path *path, unsigned int flags)&#123; struct vfsmount *mnt = path-&gt;mnt; // è·å–å½“å‰è·¯å¾„çš„æŒ‚è½½ç‚¹ bool jumped; // è°ƒç”¨ traverse_mounts å‡½æ•°è¿›è¡ŒæŒ‚è½½ç‚¹çš„éå† int ret = traverse_mounts(path, &amp;jumped, NULL, flags); // å¦‚æœè·¯å¾„çš„æŒ‚è½½ç‚¹å‘ç”Ÿäº†æ”¹å˜ï¼Œé‡Šæ”¾åŸæ¥çš„æŒ‚è½½ç‚¹ if (path-&gt;mnt != mnt) mntput(mnt); // è¿”å›éå†ç»“æœ return ret;&#125;EXPORT_SYMBOL(follow_down); // æŠŠå‡½æ•° follow_down å¯¼å‡ºï¼Œä½¿å¾—å…¶ä»–æ¨¡å—ä¹Ÿèƒ½å¤Ÿè°ƒç”¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * __follow_mount_rcu å‡½æ•° * è¿™ä¸ªå‡½æ•°å°è¯•åœ¨ rcuwalk æ¨¡å¼ä¸‹è·³åˆ°æŒ‚è½½ç‚¹å †çš„é¡¶éƒ¨ * å¦‚æœé‡åˆ°éœ€è¦é˜»å¡çš„ç®¡ç† dentryï¼Œæ“ä½œå¤±è´¥ */static bool __follow_mount_rcu(struct nameidata *nd, struct path *path)&#123; struct dentry *dentry = path-&gt;dentry; // è·å–å½“å‰è·¯å¾„çš„ dentry unsigned int flags = dentry-&gt;d_flags; // è·å– dentry çš„ flags // å¦‚æœ dentry ä¸æ˜¯ç”±æ–‡ä»¶ç³»ç»Ÿç®¡ç†çš„ï¼Œè¿”å› true if (likely(!(flags &amp; DCACHE_MANAGED_DENTRY))) return true; // å¦‚æœä¸å…è®¸è·¨è®¾å¤‡æŸ¥æ‰¾ï¼Œè¿”å› false if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) return false; for (;;) &#123; // å¦‚æœ dentry å¸Œæœ›é˜»å¡ transitï¼Œé‚£ä¹ˆå®ƒå¯èƒ½ä¸æ˜¯æŒ‚è½½ç‚¹çš„ç®¡ç† dentry if (unlikely(flags &amp; DCACHE_MANAGE_TRANSIT)) &#123; // æŸ¥è¯¢æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å…è®¸è¿›è¡Œä¸‹ä¸€æ­¥ int res = dentry-&gt;d_op-&gt;d_manage(path, true); // å¦‚æœè¿”å›ç»“æœä¸ä¸º 0ï¼Œè¿”å›ç»“æœæ˜¯å¦ä¸º -EISDIR if (res) return res == -EISDIR; // æ›´æ–° flags flags = dentry-&gt;d_flags; &#125; // å¦‚æœ dentry æ˜¯æŒ‚è½½ç‚¹ï¼ŒæŸ¥æ‰¾æŒ‚è½½ç‚¹ if (flags &amp; DCACHE_MOUNTED) &#123; struct mount *mounted = __lookup_mnt(path-&gt;mnt, dentry); // å¦‚æœæ‰¾åˆ°äº†æŒ‚è½½ç‚¹ï¼Œæ›´æ–°è·¯å¾„çš„ mnt å’Œ dentry if (mounted) &#123; path-&gt;mnt = &amp;mounted-&gt;mnt; dentry = path-&gt;dentry = mounted-&gt;mnt.mnt_root; // æ›´æ–° nd çš„çŠ¶æ€ nd-&gt;state |= ND_JUMPED; nd-&gt;next_seq = read_seqcount_begin(&amp;dentry-&gt;d_seq); // æ›´æ–° flags flags = dentry-&gt;d_flags; // ç¡®ä¿é RCU è·¯å¾„éå†å¯ä»¥è¾¾åˆ°è¿™ä¸ªçŠ¶æ€ if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) return false; continue; &#125; // å¦‚æœè¯»å–åºåˆ—å·å¤±è´¥ï¼Œè¿”å› false if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) return false; &#125; // å¦‚æœä¸éœ€è¦è‡ªåŠ¨æŒ‚è½½ï¼Œè¿”å› true return !(flags &amp; DCACHE_NEED_AUTOMOUNT); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839/* * handle_mounts å‡½æ•° * ç”¨äºå¤„ç†æŒ‚è½½ç‚¹ï¼ŒåŒ…æ‹¬ RCU æ¨¡å¼ä¸‹çš„æŒ‚è½½ç‚¹è·Ÿè¸ªï¼Œä»¥åŠæŒ‚è½½ç‚¹çš„éå† */static inline int handle_mounts(struct nameidata *nd, struct dentry *dentry, struct path *path)&#123; bool jumped; int ret; path-&gt;mnt = nd-&gt;path.mnt; // è·å–å½“å‰è·¯å¾„çš„æŒ‚è½½ç‚¹ path-&gt;dentry = dentry; // è·å–å½“å‰è·¯å¾„çš„ dentry if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœå¯ç”¨äº† RCU æŸ¥æ‰¾ unsigned int seq = nd-&gt;next_seq; // è°ƒç”¨ __follow_mount_rcu å‡½æ•°è¿›è¡Œ RCU æ¨¡å¼ä¸‹çš„æŒ‚è½½ç‚¹è·Ÿè¸ª if (likely(__follow_mount_rcu(nd, path))) return 0; // *path å’Œ nd-&gt;next_seq å¯èƒ½å·²ç»è¢«ä¿®æ”¹ path-&gt;mnt = nd-&gt;path.mnt; path-&gt;dentry = dentry; nd-&gt;next_seq = seq; if (!try_to_unlazy_next(nd, dentry)) return -ECHILD; &#125; // è°ƒç”¨ traverse_mounts å‡½æ•°è¿›è¡ŒæŒ‚è½½ç‚¹çš„éå† ret = traverse_mounts(path, &amp;jumped, &amp;nd-&gt;total_link_count, nd-&gt;flags); if (jumped) &#123; // å¦‚æœæˆåŠŸè·³è½¬åˆ°äº†æ–°çš„æŒ‚è½½ç‚¹ if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) ret = -EXDEV; else nd-&gt;state |= ND_JUMPED; &#125; if (unlikely(ret)) &#123; // å¦‚æœéå†è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ dput(path-&gt;dentry); // é‡Šæ”¾ dentry if (path-&gt;mnt != nd-&gt;path.mnt) // å¦‚æœæŒ‚è½½ç‚¹å·²ç»æ”¹å˜ mntput(path-&gt;mnt); // é‡Šæ”¾æ—§çš„æŒ‚è½½ç‚¹ &#125; return ret;&#125; 123456789101112131415161718192021/* * lookup_dcache å‡½æ•° * è¿™ä¸ªå‡½æ•°åœ¨ dcache ä¸­æŸ¥æ‰¾åç§°ï¼Œå¹¶å¯èƒ½å¯¹æ‰¾åˆ°çš„ dentry è¿›è¡Œé‡æ–°éªŒè¯ * å¦‚æœåœ¨ç¼“å­˜ä¸­ä¸å­˜åœ¨ dentryï¼Œåˆ™è¿”å› NULL */static struct dentry *lookup_dcache(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct dentry *dentry = d_lookup(dir, name); // åœ¨ç›®å½•ä¸­æŸ¥æ‰¾ dentry if (dentry) &#123; // å¦‚æœæ‰¾åˆ°äº† dentry int error = d_revalidate(dentry, flags); // å¯¹ dentry è¿›è¡Œé‡æ–°éªŒè¯ if (unlikely(error &lt;= 0)) &#123; // å¦‚æœéªŒè¯å¤±è´¥ if (!error) d_invalidate(dentry); // ä½¿ dentry æ— æ•ˆ dput(dentry); // é‡Šæ”¾ dentry return ERR_PTR(error); // é”™è¯¯å¤„ç† &#125; &#125; return dentry;&#125; 123456789101112131415161718192021222324252627282930313233/* * __lookup_hash å‡½æ•° * åœ¨çˆ¶ç›®å½•çš„ inode è¢«ç‹¬å é”å®šçš„æƒ…å†µä¸‹è¿›è¡ŒæŸ¥æ‰¾ * è¿™æ˜¯å”¯ä¸€ä¸€ä¸ªåœ¨é in-lookup dentries ä¸Šè°ƒç”¨ -&gt;lookup() çš„æƒ…å†µ * äº‹å®ä¸Šï¼Œè¿™åªåœ¨ç›®å½•ä¿è¯æ²¡æœ‰ in-lookup å­é¡¹çš„æƒ…å†µä¸‹è¢«è°ƒç”¨ */static struct dentry *__lookup_hash(const struct qstr *name, struct dentry *base, unsigned int flags)&#123; struct dentry *dentry = lookup_dcache(name, base, flags); // åœ¨ dcache ä¸­æŸ¥æ‰¾ dentry struct dentry *old; struct inode *dir = base-&gt;d_inode; // è·å–åŸºç¡€ dentry çš„ inode if (dentry) // å¦‚æœæ‰¾åˆ°äº† dentry return dentry; // å¯¹äºæ­»ç›®å½•ï¼Œä¸åˆ›å»ºå­ dentry if (unlikely(IS_DEADDIR(dir))) return ERR_PTR(-ENOENT); // ä¸ºåŸºç¡€ dentry å’Œåç§°åˆ†é…ä¸€ä¸ªæ–°çš„ dentry dentry = d_alloc(base, name); if (unlikely(!dentry)) // å¦‚æœåˆ†é…å¤±è´¥ return ERR_PTR(-ENOMEM); // è°ƒç”¨ -&gt;lookup() å‡½æ•°è¿›è¡ŒæŸ¥æ‰¾ old = dir-&gt;i_op-&gt;lookup(dir, dentry, flags); if (unlikely(old)) &#123; // å¦‚æœæŸ¥æ‰¾ç»“æœå­˜åœ¨ dput(dentry); // é‡Šæ”¾æ–°åˆ†é…çš„ dentry dentry = old; // ä½¿ç”¨æŸ¥æ‰¾åˆ°çš„è€çš„ dentry &#125; return dentry;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283static struct dentry *lookup_fast(struct nameidata *nd)&#123; // å®šä¹‰ä¸€ä¸ªåä¸ºlookup_fastçš„å‡½æ•°ï¼Œå‚æ•°ä¸ºåä¸ºndçš„nameidataç±»å‹çš„æŒ‡é’ˆ struct dentry *dentry, *parent = nd-&gt;path.dentry; // å®šä¹‰ä¸¤ä¸ªdentryç±»å‹çš„æŒ‡é’ˆï¼Œä¸€ä¸ªåä¸ºdentryï¼Œå¦ä¸€ä¸ªåä¸ºparentï¼Œå¹¶å°†ndçš„pathçš„dentryèµ‹å€¼ç»™parent int status = 1; // å®šä¹‰ä¸€ä¸ªæ•´å‹å˜é‡statusï¼Œå¹¶åˆå§‹åŒ–ä¸º1 /* * Rename seqlock is not required here because in the off chance * of a false negative due to a concurrent rename, the caller is * going to fall back to non-racy lookup. */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœndçš„flagsä¸LOOKUP_RCUåšæŒ‰ä½ä¸æ“ä½œç»“æœä¸ºçœŸ dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); // è°ƒç”¨__d_lookup_rcuå‡½æ•°ï¼Œå°†ç»“æœèµ‹å€¼ç»™dentry if (unlikely(!dentry)) &#123; // å¦‚æœdentryä¸ºNULL if (!try_to_unlazy(nd)) // å¦‚æœtry_to_unlazyå‡½æ•°è¿”å›å€¼ä¸º0 return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆERR_PTRï¼Œé”™è¯¯ç ä¸º-ECHILD return NULL; // è¿”å›NULL &#125; /* * This sequence count validates that the parent had no * changes while we did the lookup of the dentry above. */ if (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) // å¦‚æœread_seqcount_retryå‡½æ•°è¿”å›å€¼ä¸ºçœŸ return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆERR_PTRï¼Œé”™è¯¯ç ä¸º-ECHILD status = d_revalidate(dentry, nd-&gt;flags); // è°ƒç”¨d_revalidateå‡½æ•°ï¼Œå°†è·å¾—çš„çŠ¶æ€èµ‹å€¼ç»™status if (likely(status &gt; 0)) // å¦‚æœstatusçš„å€¼å¤§äº0 return dentry; // è¿”å›dentry if (!try_to_unlazy_next(nd, dentry)) // å¦‚æœtry_to_unlazy_nextå‡½æ•°è¿”å›å€¼ä¸º0 return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆERR_PTRï¼Œé”™è¯¯ç ä¸º-ECHILD if (status == -ECHILD) // å¦‚æœstatusçš„å€¼ä¸º-ECHILD /* we&#x27;d been told to redo it in non-rcu mode */ status = d_revalidate(dentry, nd-&gt;flags); // é‡æ–°è°ƒç”¨d_revalidateå‡½æ•°ï¼Œå°†è·å¾—çš„çŠ¶æ€èµ‹å€¼ç»™status &#125; else &#123; dentry = __d_lookup(parent, &amp;nd-&gt;last); // è°ƒç”¨__d_lookupå‡½æ•°ï¼Œå°†ç»“æœèµ‹å€¼ç»™dentry if (unlikely(!dentry)) // å¦‚æœdentryä¸ºNULL return NULL; // è¿”å›NULL status = d_revalidate(dentry, nd-&gt;flags); // è°ƒç”¨d_revalidateå‡½æ•°ï¼Œå°†è·å¾—çš„çŠ¶æ€èµ‹å€¼ç»™status &#125; if (unlikely(status &lt;= 0)) &#123; // å¦‚æœstatusçš„å€¼å°äºç­‰äº0 if (!status) // å¦‚æœstatusçš„å€¼ä¸º0 d_invalidate(dentry); // è°ƒç”¨d_invalidateå‡½æ•°ï¼Œä½¿dentryæ— æ•ˆ dput(dentry); // è°ƒç”¨dputå‡½æ•°ï¼Œå‡å°‘dentryçš„ä½¿ç”¨è®¡æ•° return ERR_PTR(status); // è¿”å›é”™è¯¯æŒ‡é’ˆERR_PTRï¼Œé”™è¯¯ç ä¸ºstatus &#125; return dentry; // è¿”å›dentry&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Fast lookup failed, do it the slow way */static struct dentry *__lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; // å®šä¹‰ä¸€ä¸ªæ…¢é€ŸæŸ¥æ‰¾å‡½æ•°ï¼Œè¾“å…¥å‚æ•°ä¸ºè¦æŸ¥æ‰¾çš„æ–‡ä»¶åï¼Œçˆ¶ç›®å½•çš„dentryå’ŒæŸ¥æ‰¾æ ‡å¿— struct dentry *dentry, *old; struct inode *inode = dir-&gt;d_inode; DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // å®šä¹‰ç­‰å¾…é˜Ÿåˆ—å¤´wq /* Don&#x27;t go there if it&#x27;s already dead */ if (unlikely(IS_DEADDIR(inode))) return ERR_PTR(-ENOENT); // å¦‚æœinodeå·²ç»æ­»äº¡ï¼ˆè¢«åˆ é™¤æˆ–æ— æ•ˆï¼‰ï¼Œç›´æ¥è¿”å›é”™è¯¯ç ENOENTagain: dentry = d_alloc_parallel(dir, name, &amp;wq); if (IS_ERR(dentry)) return dentry; // å¹¶è¡Œåˆ†é…ä¸€ä¸ªæ–°çš„dentryï¼Œå¦‚æœè¿”å›å€¼æ˜¯é”™è¯¯æŒ‡é’ˆï¼Œç›´æ¥è¿”å› if (unlikely(!d_in_lookup(dentry))) &#123; int error = d_revalidate(dentry, flags); if (unlikely(error &lt;= 0)) &#123; if (!error) &#123; d_invalidate(dentry); dput(dentry); goto again; &#125; // å¦‚æœdentryä¸åœ¨æŸ¥æ‰¾çŠ¶æ€ï¼Œè¿›è¡Œé‡éªŒè¯ï¼Œå¦‚æœéªŒè¯å¤±è´¥ï¼Œä½¿dentryæ— æ•ˆï¼Œå‡å°‘å…¶å¼•ç”¨è®¡æ•°ï¼Œç„¶åé‡æ–°è¿›è¡ŒæŸ¥æ‰¾ dput(dentry); dentry = ERR_PTR(error); &#125; &#125; else &#123; old = inode-&gt;i_op-&gt;lookup(inode, dentry, flags); d_lookup_done(dentry); if (unlikely(old)) &#123; dput(dentry); dentry = old; &#125; // å¦‚æœdentryåœ¨æŸ¥æ‰¾çŠ¶æ€ï¼Œè°ƒç”¨æŸ¥æ‰¾å‡½æ•°ï¼Œç»“æŸæŸ¥æ‰¾ï¼Œå¦‚æœæœ‰æ—§çš„dentryï¼Œå‡å°‘æ–°dentryçš„å¼•ç”¨è®¡æ•°ï¼Œç„¶åä½¿ç”¨æ—§çš„dentry &#125; return dentry; // è¿”å›æŸ¥æ‰¾ç»“æœdentry&#125; 1234567891011121314static struct dentry *lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; // å®šä¹‰ä¸€ä¸ªæ…¢é€ŸæŸ¥æ‰¾çš„åŒ…è£…å‡½æ•°ï¼Œè¾“å…¥å‚æ•°ä¸ºè¦æŸ¥æ‰¾çš„æ–‡ä»¶åï¼Œçˆ¶ç›®å½•çš„dentryå’ŒæŸ¥æ‰¾æ ‡å¿— struct inode *inode = dir-&gt;d_inode; struct dentry *res; inode_lock_shared(inode); res = __lookup_slow(name, dir, flags); inode_unlock_shared(inode); return res; // å¯¹inodeè¿›è¡Œå…±äº«é”å®šï¼Œç„¶åè¿›è¡Œæ…¢é€ŸæŸ¥æ‰¾ï¼ŒæŸ¥æ‰¾ç»“æŸåè§£é”ï¼Œç„¶åè¿”å›æŸ¥æ‰¾ç»“æœ&#125; 12345678910111213141516static inline int may_lookup(struct mnt_idmap *idmap, struct nameidata *nd)&#123; // å®šä¹‰ä¸€ä¸ªå†…è”å‡½æ•°ï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦å¯ä»¥è¿›è¡ŒæŸ¥æ‰¾ï¼Œå‚æ•°ä¸ºidmapå’Œnd if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; int err = inode_permission(idmap, nd-&gt;inode, MAY_EXEC|MAY_NOT_BLOCK); // å¦‚æœndçš„flagsä¸LOOKUP_RCUæŒ‰ä½ä¸çš„ç»“æœä¸ºçœŸï¼Œåˆ™è°ƒç”¨inode_permissionå‡½æ•°ä»¥æ£€æŸ¥æƒé™ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°errä¸­ if (err != -ECHILD || !try_to_unlazy(nd)) return err; // å¦‚æœerrçš„å€¼ä¸ç­‰äº-ECHILDï¼Œæˆ–è€…try_to_unlazyå‡½æ•°çš„è¿”å›å€¼ä¸º0ï¼Œåˆ™è¿”å›err &#125; return inode_permission(idmap, nd-&gt;inode, MAY_EXEC); // è¿”å›inode_permissionå‡½æ•°çš„è¿”å›å€¼ï¼Œç”¨äºæ£€æŸ¥æ˜¯å¦æœ‰æ‰§è¡Œæƒé™&#125; 12345678910111213141516171819202122232425262728293031323334353637static int reserve_stack(struct nameidata *nd, struct path *link)&#123; // å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºé¢„ç•™å †æ ˆï¼Œå‚æ•°ä¸ºndå’Œlink if (unlikely(nd-&gt;total_link_count++ &gt;= MAXSYMLINKS)) return -ELOOP; // å¦‚æœndçš„total_link_countå¢åŠ åå¤§äºç­‰äºMAXSYMLINKSï¼Œåˆ™è¿”å›-ELOOP if (likely(nd-&gt;depth != EMBEDDED_LEVELS)) return 0; // å¦‚æœndçš„depthä¸ç­‰äºEMBEDDED_LEVELSï¼Œåˆ™è¿”å›0 if (likely(nd-&gt;stack != nd-&gt;internal)) return 0; // å¦‚æœndçš„stackä¸ç­‰äºndçš„internalï¼Œåˆ™è¿”å›0 if (likely(nd_alloc_stack(nd))) return 0; // å¦‚æœè°ƒç”¨nd_alloc_stackå‡½æ•°åè¿”å›é0ï¼Œé‚£ä¹ˆè¿”å›0 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // we need to grab link before we do unlazy. And we can&#x27;t skip // unlazy even if we fail to grab the link - cleanup needs it bool grabbed_link = legitimize_path(nd, link, nd-&gt;next_seq); // å¦‚æœndçš„flagsä¸LOOKUP_RCUæŒ‰ä½ä¸çš„ç»“æœä¸ºçœŸï¼Œåˆ™åœ¨è°ƒç”¨unlazyä¹‹å‰éœ€è¦è·å–link if (!try_to_unlazy(nd) || !grabbed_link) return -ECHILD; // å¦‚æœtry_to_unlazyå‡½æ•°çš„è¿”å›å€¼ä¸º0ï¼Œæˆ–è€…grabbed_linkä¸ºfalseï¼Œåˆ™è¿”å›-ECHILD if (nd_alloc_stack(nd)) return 0; // å¦‚æœè°ƒç”¨nd_alloc_stackå‡½æ•°åè¿”å›é0ï¼Œé‚£ä¹ˆè¿”å›0 &#125; return -ENOMEM; // è¿”å›-ENOMEMï¼Œè¡¨ç¤ºå†…å­˜ä¸è¶³&#125; 12enum &#123;WALK_TRAILING = 1, WALK_MORE = 2, WALK_NOFOLLOW = 4&#125;;// å®šä¹‰ä¸€ä¸ªæšä¸¾ï¼Œæšä¸¾å€¼ä¸ºWALK_TRAILINGï¼ŒWALK_MOREï¼ŒWALK_NOFOLLOWï¼Œå€¼åˆ†åˆ«ä¸º1ï¼Œ2ï¼Œ4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109static const char *pick_link(struct nameidata *nd, struct path *link, struct inode *inode, int flags)&#123; // å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºé€‰æ‹©é“¾æ¥ï¼Œå‚æ•°ä¸ºndï¼Œlinkï¼Œinodeå’Œflags struct saved *last; const char *res; int error = reserve_stack(nd, link); // é¢„ç•™å †æ ˆï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°errorä¸­ if (unlikely(error)) &#123; if (!(nd-&gt;flags &amp; LOOKUP_RCU)) path_put(link); // å¦‚æœerroré0ï¼Œä¸”ndçš„flagsä¸LOOKUP_RCUæŒ‰ä½ä¸çš„ç»“æœä¸ºfalseï¼Œé‡Šæ”¾è·¯å¾„ return ERR_PTR(error); // è¿”å›é”™è¯¯æŒ‡é’ˆ &#125; last = nd-&gt;stack + nd-&gt;depth++; // æ›´æ–°lastä¸ºndçš„stackä¸ndçš„depthçš„å’Œï¼Œndçš„depthè‡ªå¢ last-&gt;link = *link; // æ›´æ–°lastçš„linkä¸º*link clear_delayed_call(&amp;last-&gt;done); // æ¸…é™¤lastçš„doneä¸­çš„å»¶è¿Ÿè°ƒç”¨ last-&gt;seq = nd-&gt;next_seq; // æ›´æ–°lastçš„seqä¸ºndçš„next_seq if (flags &amp; WALK_TRAILING) &#123; error = may_follow_link(nd, inode); if (unlikely(error)) return ERR_PTR(error); // å¦‚æœflagsä¸WALK_TRAILINGæŒ‰ä½ä¸çš„ç»“æœä¸ºçœŸï¼Œè°ƒç”¨may_follow_linkå‡½æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°errorä¸­ï¼Œå¦‚æœerroré0ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ &#125; if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_SYMLINKS) || unlikely(link-&gt;mnt-&gt;mnt_flags &amp; MNT_NOSYMFOLLOW)) return ERR_PTR(-ELOOP); // å¦‚æœndçš„flagsä¸LOOKUP_NO_SYMLINKSæŒ‰ä½ä¸çš„ç»“æœä¸ºçœŸï¼Œæˆ–è€…linkçš„mntçš„mnt_flagsä¸MNT_NOSYMFOLLOWæŒ‰ä½ä¸çš„ç»“æœä¸ºçœŸï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ if (!(nd-&gt;flags &amp; LOOKUP_RCU)) &#123; touch_atime(&amp;last-&gt;link); cond_resched(); // å¦‚æœndçš„flagsä¸LOOKUP_RCUæŒ‰ä½ä¸çš„ç»“æœä¸ºfalseï¼Œæ›´æ–°lastçš„linkçš„è®¿é—®æ—¶é—´ï¼Œå¹¶å°è¯•è¿›è¡Œè°ƒåº¦ &#125; else if (atime_needs_update(&amp;last-&gt;link, inode)) &#123; if (!try_to_unlazy(nd)) return ERR_PTR(-ECHILD); touch_atime(&amp;last-&gt;link); // å¦åˆ™ï¼Œå¦‚æœlastçš„linkçš„è®¿é—®æ—¶é—´éœ€è¦æ›´æ–°ï¼Œå°è¯•è°ƒç”¨try_to_unlazyå‡½æ•°ï¼Œå¦‚æœè¿”å›å€¼ä¸º0ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆï¼Œå¦åˆ™ï¼Œæ›´æ–°lastçš„linkçš„è®¿é—®æ—¶é—´ &#125; error = security_inode_follow_link(link-&gt;dentry, inode, nd-&gt;flags &amp; LOOKUP_RCU); if (unlikely(error)) return ERR_PTR(error); // è°ƒç”¨security_inode_follow_linkå‡½æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°errorä¸­ï¼Œå¦‚æœerroré0ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ res = READ_ONCE(inode-&gt;i_link); // è¯»å–ä¸€æ¬¡inodeçš„i_linkï¼Œå°†ç»“æœå­˜å‚¨åˆ°resä¸­ if (!res) &#123; const char * (*get)(struct dentry *, struct inode *, struct delayed_call *); get = inode-&gt;i_op-&gt;get_link; // å¦‚æœresä¸ºNULLï¼Œå®šä¹‰ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆgetï¼Œå¹¶å°†å…¶æŒ‡å‘inodeçš„i_opçš„get_linkå‡½æ•° if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; res = get(NULL, inode, &amp;last-&gt;done); if (res == ERR_PTR(-ECHILD) &amp;&amp; try_to_unlazy(nd)) res = get(link-&gt;dentry, inode, &amp;last-&gt;done); // å¦‚æœndçš„flagsä¸LOOKUP_RCUæŒ‰ä½ä¸çš„ç»“æœä¸ºçœŸï¼Œè°ƒç”¨getå‡½æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°resä¸­ï¼Œå¦‚æœresä¸ºé”™è¯¯æŒ‡é’ˆä¸”try_to_unlazyå‡½æ•°çš„è¿”å›å€¼ä¸ºé0ï¼Œå†æ¬¡è°ƒç”¨getå‡½æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°resä¸­ &#125; else &#123; res = get(link-&gt;dentry, inode, &amp;last-&gt;done); // å¦åˆ™ï¼Œè°ƒç”¨getå‡½æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°resä¸­ &#125; if (!res) goto all_done; // å¦‚æœresä¸ºNULLï¼Œè·³è½¬åˆ°all_doneæ ‡ç­¾ if (IS_ERR(res)) return res; // å¦‚æœresä¸ºé”™è¯¯æŒ‡é’ˆï¼Œè¿”å›res &#125; if (*res == &#x27;/&#x27;) &#123; error = nd_jump_root(nd); if (unlikely(error)) return ERR_PTR(error); // å¦‚æœresçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸º&#x27;/&#x27;ï¼Œè°ƒç”¨nd_jump_rootå‡½æ•°ï¼Œå¹¶å°†```c if (*res == &#x27;/&#x27;) &#123; error = nd_jump_root(nd); if (unlikely(error)) return ERR_PTR(error); // å¦‚æœresçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸º&#x27;/&#x27;ï¼Œè°ƒç”¨nd_jump_rootå‡½æ•°ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°errorä¸­ï¼Œå¦‚æœerroré0ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ while (unlikely(*++res == &#x27;/&#x27;)) ; // å¦‚æœresçš„ä¸‹ä¸€ä¸ªå­—ç¬¦ä¸º&#x27;/&#x27;ï¼Œå°†reså‘åç§»åŠ¨ä¸€ä½ï¼Œç›´åˆ°resçš„å½“å‰å­—ç¬¦ä¸ä¸º&#x27;/&#x27; &#125; if (*res) return res; // å¦‚æœresçš„ç¬¬ä¸€ä¸ªå­—ç¬¦éç©ºï¼Œè¿”å›resall_done: // pure jump put_link(nd); // è°ƒç”¨put_linkå‡½æ•°ï¼Œè¾“å…¥å‚æ•°ä¸ºnd return NULL; // è¿”å›NULL&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * æˆ‘ä»¬æ˜¯å¦éœ€è¦è·Ÿè¸ªé“¾æ¥ï¼Ÿæˆ‘ä»¬_çœŸçš„_å¸Œæœ›èƒ½å¤Ÿåœ¨ä¸å¿…æŸ¥çœ‹inode-&gt;i_opçš„æƒ…å†µä¸‹è¿›è¡Œæ­¤æ£€æŸ¥ï¼Œ * å› æ­¤ï¼Œå¯¹äºå¸¸è§æƒ…å†µï¼Œæˆ‘ä»¬ä¿ç•™ä¸€ä¸ª&quot;ä¸ï¼Œè¿™ä¸éœ€è¦follow_link&quot;çš„ç¼“å­˜ã€‚ * * æ³¨æ„ï¼šdentryå¿…é¡»æ˜¯nd-&gt;next_seqå·²é‡‡æ ·çš„å†…å®¹ã€‚ */static const char *step_into(struct nameidata *nd, int flags, struct dentry *dentry)&#123; struct path path; struct inode *inode; int err = handle_mounts(nd, dentry, &amp;path); // å¤„ç†æŒ‚è½½æƒ…å†µ if (err &lt; 0) return ERR_PTR(err); // å¦‚æœå¤„ç†å‡ºé”™ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ inode = path.dentry-&gt;d_inode; if (likely(!d_is_symlink(path.dentry)) || // å¦‚æœdentryä¸æ˜¯ç¬¦å·é“¾æ¥ ((flags &amp; WALK_TRAILING) &amp;&amp; !(nd-&gt;flags &amp; LOOKUP_FOLLOW)) || // æˆ–è€…æˆ‘ä»¬ä¸éœ€è¦è·Ÿè¸ªé“¾æ¥ (flags &amp; WALK_NOFOLLOW)) &#123; // æˆ–è€…æ˜ç¡®æŒ‡å®šä¸éœ€è¦è·Ÿè¸ªé“¾æ¥ /* not a symlink or should not follow */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq)) return ERR_PTR(-ECHILD); // å¦‚æœåºåˆ—å·ä¸åŒ¹é…ï¼Œè¿”å›é”™è¯¯ if (unlikely(!inode)) return ERR_PTR(-ENOENT); // å¦‚æœinodeä¸å­˜åœ¨ï¼Œè¿”å›é”™è¯¯ &#125; else &#123; dput(nd-&gt;path.dentry); if (nd-&gt;path.mnt != path.mnt) mntput(nd-&gt;path.mnt); &#125; nd-&gt;path = path; nd-&gt;inode = inode; nd-&gt;seq = nd-&gt;next_seq; return NULL; &#125; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; /* ç¡®ä¿ä¸Šé¢çš„d_is_symlinkåŒ¹é…inode */ if (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq)) return ERR_PTR(-ECHILD); // å¦‚æœåºåˆ—å·ä¸åŒ¹é…ï¼Œè¿”å›é”™è¯¯ &#125; else &#123; if (path.mnt == nd-&gt;path.mnt) mntget(path.mnt); &#125; return pick_link(nd, &amp;path, inode, flags); // é€‰æ‹©é“¾æ¥è¿›è¡Œå¤„ç†&#125; 123456789101112131415161718192021222324252627282930313233343536373839static struct dentry *follow_dotdot_rcu(struct nameidata *nd) // å®šä¹‰ä¸€ä¸ªå‡½æ•°follow_dotdot_rcuï¼Œæ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œè¿”å›ä¸€ä¸ªstruct dentryæŒ‡é’ˆã€‚&#123; struct dentry *parent, *old; // å®šä¹‰ä¸¤ä¸ªstruct dentryæŒ‡é’ˆï¼Œparentå’Œold if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) // å¦‚æœnd-&gt;pathç­‰äºnd-&gt;root goto in_root; // è·³è½¬åˆ°in_rootæ ‡ç­¾ if (unlikely(nd-&gt;path.dentry == nd-&gt;path.mnt-&gt;mnt_root)) &#123; // å¦‚æœnd-&gt;path.dentryç­‰äºnd-&gt;path.mnt-&gt;mnt_root struct path path; // å®šä¹‰ä¸€ä¸ªstruct```c unsigned seq; // å®šä¹‰ä¸€ä¸ªæ— ç¬¦å·æ•´å‹å˜é‡seq if (!choose_mountpoint_rcu(real_mount(nd-&gt;path.mnt), &amp;nd-&gt;root, &amp;path, &amp;seq)) // å¦‚æœæ²¡æœ‰é€‰æ‹©RCUæŒ‚è½½ç‚¹ goto in_root; // è·³è½¬åˆ°in_rootæ ‡ç­¾ if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) // å¦‚æœnd-&gt;flagsåŒ…å«LOOKUP_NO_XDEV return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆ nd-&gt;path = path; // å°†pathèµ‹å€¼ç»™nd-&gt;path nd-&gt;inode = path.dentry-&gt;d_inode; // å°†path.dentry-&gt;d_inodeèµ‹å€¼ç»™nd-&gt;inode nd-&gt;seq = seq; // å°†seqèµ‹å€¼ç»™nd-&gt;seq // ç¡®ä¿éRCUè·¯å¾„æ­¥è¿›å¯ä»¥åˆ°è¾¾è¿™ä¸ªçŠ¶æ€ if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) // å¦‚æœè¯»å–åºåˆ—é‡è¯• return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆ /* æˆ‘ä»¬çŸ¥é“æŒ‚è½½ç‚¹è¢«å›ºå®š */ &#125; old = nd-&gt;path.dentry; // å°†nd-&gt;path.dentryèµ‹å€¼ç»™old parent = old-&gt;d_parent; // å°†old-&gt;d_parentèµ‹å€¼ç»™parent nd-&gt;next_seq = read_seqcount_begin(&amp;parent-&gt;d_seq); // è¯»å–parent-&gt;d_seqçš„åºåˆ—è®¡æ•°å¼€å§‹ï¼Œå¹¶èµ‹å€¼ç»™nd-&gt;next_seq // ç¡®ä¿éRCUè·¯å¾„æ­¥è¿›å¯ä»¥åˆ°è¾¾è¿™ä¸ªçŠ¶æ€ if (read_seqcount_retry(&amp;old-&gt;d_seq, nd-&gt;seq)) // å¦‚æœè¯»å–old-&gt;d_seqçš„åºåˆ—è®¡æ•°é‡è¯• return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆ if (unlikely(!path_connected(nd-&gt;path.mnt, parent))) // å¦‚æœnd-&gt;path.mntå’Œparentæ²¡æœ‰è¿æ¥ return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆ return parent; // è¿”å›parentin_root: // in_rootæ ‡ç­¾ if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) // å¦‚æœè¯»å–åºåˆ—é‡è¯• return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆ if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) // å¦‚æœnd-&gt;flagsåŒ…å«LOOKUP_BENEATH return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆ nd-&gt;next_seq = nd-&gt;seq; // å°†nd-&gt;seqèµ‹å€¼ç»™nd-&gt;next_seq return nd-&gt;path.dentry; // è¿”å›nd-&gt;path.dentry&#125; 12345678910111213141516171819202122232425262728293031static struct dentry *follow_dotdot(struct nameidata *nd)&#123; struct dentry *parent; if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) // å¦‚æœå½“å‰è·¯å¾„å·²ç»æ˜¯æ ¹è·¯å¾„ goto in_root; if (unlikely(nd-&gt;path.dentry == nd-&gt;path.mnt-&gt;mnt_root)) &#123; // å¦‚æœå½“å‰çš„dentryæ˜¯æŒ‚è½½ç‚¹çš„æ ¹ struct path path; if (!choose_mountpoint(real_mount(nd-&gt;path.mnt), // é€‰æ‹©ä¸€ä¸ªæ–°çš„æŒ‚è½½ç‚¹ &amp;nd-&gt;root, &amp;path)) goto in_root; path_put(&amp;nd-&gt;path); // é‡Šæ”¾æ—§çš„è·¯å¾„ nd-&gt;path = path; // æ›´æ–°æ–°çš„è·¯å¾„ nd-&gt;inode = path.dentry-&gt;d_inode; // æ›´æ–°inode if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) // å¦‚æœä¸å…è®¸è·¨è®¾å¤‡ return ERR_PTR(-EXDEV); &#125; /* rare case of legitimate dget_parent()... */ parent = dget_parent(nd-&gt;path.dentry); // è·å–çˆ¶ç›®å½• if (unlikely(!path_connected(nd-&gt;path.mnt, parent))) &#123; // å¦‚æœè·¯å¾„æ²¡æœ‰è¿æ¥ dput(parent); return ERR_PTR(-ENOENT); &#125; return parent; // è¿”å›çˆ¶ç›®å½•in_root: if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) // å¦‚æœæ ‡å¿—è®¾ç½®äº†LOOKUP_BENEATH return ERR_PTR(-EXDEV); return dget(nd-&gt;path.dentry); // è¿”å›å½“å‰è·¯å¾„çš„dentry&#125; 12345678910111213141516171819202122232425262728293031323334353637static const char *handle_dots(struct nameidata *nd, int type)&#123; if (type == LAST_DOTDOT) &#123; // å¦‚æœæ˜¯&quot;..&quot; const char *error = NULL; struct dentry *parent; if (!nd-&gt;root.mnt) &#123; // å¦‚æœæ²¡æœ‰è®¾ç½®æ ¹æŒ‚è½½ç‚¹ error = ERR_PTR(set_root(nd)); // è®¾ç½®æ ¹è·¯å¾„ if (error) return error; &#125; if (nd-&gt;flags &amp; LOOKUP_RCU) // å¦‚æœæ˜¯RCUæ–¹å¼ parent = follow_dotdot_rcu(nd); // ä½¿ç”¨RCUæ–¹å¼è·å–çˆ¶ç›®å½• else parent = follow_dotdot(nd); // å¦åˆ™ç›´æ¥è·å–çˆ¶ç›®å½• if (IS_ERR(parent)) // å¦‚æœå‡ºé”™ return ERR_CAST(parent); error = step_into(nd, WALK_NOFOLLOW, parent); // è¿›å…¥çˆ¶ç›®å½• if (unlikely(error)) // å¦‚æœå‡ºé”™ return error; if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123; // å¦‚æœæ˜¯å—é™åˆ¶çš„æŸ¥æ‰¾ /* * If there was a racing rename or mount along our * path, then we can&#x27;t be sure that &quot;..&quot; hasn&#x27;t jumped * above nd-&gt;root (and so userspace should retry or use * some fallback). */ smp_rmb(); if (__read_seqcount_retry(&amp;mount_lock.seqcount, nd-&gt;m_seq)) // å¦‚æœæœ‰å¹¶å‘çš„æŒ‚è½½æ“ä½œ return ERR_PTR(-EAGAIN); if (__read_seqcount_retry(&amp;rename_lock.seqcount, nd-&gt;r_seq)) // å¦‚æœæœ‰å¹¶å‘çš„é‡å‘½åæ“ä½œ return ERR_PTR(-EAGAIN); &#125; &#125; return NULL;&#125; 123456789101112131415161718192021222324252627static const char *walk_component(struct nameidata *nd, int flags)&#123; struct dentry *dentry; // å®šä¹‰ä¸€ä¸ªç›®å½•é¡¹ /* * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has * to be able to know about the current root directory and * parent relationships. */ // &quot;.&quot; å’Œ &quot;..&quot; æ˜¯ç‰¹æ®Šçš„ï¼Œç‰¹åˆ«æ˜¯ &quot;..&quot;ï¼Œå› ä¸ºå®ƒéœ€è¦çŸ¥é“å½“å‰çš„æ ¹ç›®å½•å’Œçˆ¶ç›®å½•å…³ç³» if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // å¦‚æœæœ€åä¸€ä¸ªç±»å‹ä¸æ˜¯å¸¸è§„çš„ if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) // å¦‚æœæ²¡æœ‰æ›´å¤šçš„è·¯å¾„å¹¶ä¸”æ·±åº¦ä¸ä¸º0 put_link(nd); // é‡Šæ”¾é“¾æ¥ return handle_dots(nd, nd-&gt;last_type); // å¤„ç† &quot;..&quot; å’Œ &quot;.&quot; &#125; dentry = lookup_fast(nd); // å¿«é€ŸæŸ¥æ‰¾ if (IS_ERR(dentry)) // å¦‚æœå‡ºé”™ return ERR_CAST(dentry); // è¿”å›é”™è¯¯ if (unlikely(!dentry)) &#123; // å¦‚æœç›®å½•é¡¹ä¸ºç©º dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // æ…¢é€ŸæŸ¥æ‰¾ if (IS_ERR(dentry)) // å¦‚æœå‡ºé”™ return ERR_CAST(dentry); // è¿”å›é”™è¯¯ &#125; if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) // å¦‚æœæ²¡æœ‰æ›´å¤šçš„è·¯å¾„å¹¶ä¸”æ·±åº¦ä¸ä¸º0 put_link(nd); // é‡Šæ”¾é“¾æ¥ return step_into(nd, flags, dentry); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* * æˆ‘ä»¬å¯ä»¥ä¸€æ¬¡ä¸€ä¸ªå•è¯åœ°è¿›è¡Œå…³é”®çš„ dentry åç§°æ¯”è¾ƒå’Œæ•£åˆ—æ“ä½œï¼Œä½†æˆ‘ä»¬åªé™äºï¼š * * - æ”¯æŒå¿«é€Ÿæ— å¯¹é½å­—è®¿é—®çš„æ¶æ„ã€‚å¦‚æœè¿™æœ‰åŠ©äºæé«˜é€Ÿåº¦ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ &quot;get_unaligned()&quot;ã€‚ * * - é CONFIG_DEBUG_PAGEALLOC é…ç½®ï¼ˆè¿™æ ·æˆ‘ä»¬å°±ä¸ä¼šåœ¨è·¨é¡µæ“ä½œçš„ï¼ˆæå°‘è§çš„ï¼‰æƒ…å†µä¸‹é™·å…¥é™·é˜±ï¼‰ã€‚ * * - æ­¤å¤–ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé«˜æ•ˆçš„ 64 ä½ç¼–è¯‘æ¥ç”Ÿæˆ &quot;æœ€ç»ˆæ©ç ä¸­çš„å­—èŠ‚æ•°&quot;ã€‚å†æ¬¡ï¼Œè¿™å¯ä»¥ç”¨é«˜æ•ˆçš„äººå£ç»Ÿè®¡è®¡æ•°æŒ‡ä»¤æˆ–ç±»ä¼¼çš„ä¸œè¥¿æ›¿æ¢ã€‚ */#ifdef CONFIG_DCACHE_WORD_ACCESS // å¦‚æœå®šä¹‰äº† CONFIG_DCACHE_WORD_ACCESS#include &lt;asm/word-at-a-time.h&gt; // åŒ…å«å¤´æ–‡ä»¶ &lt;asm/word-at-a-time.h&gt;#ifdef HASH_MIX // å¦‚æœå®šä¹‰äº† HASH_MIX/* æ¶æ„åœ¨ &lt;asm/hash.h&gt; ä¸­æä¾›äº† HASH_MIX å’Œ fold_hash() */#elif defined(CONFIG_64BIT) // å¦åˆ™ï¼Œå¦‚æœå®šä¹‰äº† CONFIG_64BIT/* * æ··åˆå‡½æ•°ä¸­çš„å¯„å­˜å™¨å‹åŠ›æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œå°¤å…¶æ˜¯åœ¨ 32 ä½çš„ x86 ä¸Šï¼Œä½†å‡ ä¹ä»»ä½•å‡½æ•°éƒ½éœ€è¦ä¸€ä¸ªçŠ¶æ€å€¼å’Œä¸€ä¸ªä¸´æ—¶å€¼ã€‚ * å–è€Œä»£ä¹‹çš„æ˜¯ï¼Œä½¿ç”¨ä¸€ä¸ªä¸ºä¸¤ä¸ªçŠ¶æ€å€¼å’Œé›¶ä¸´æ—¶å€¼è®¾è®¡çš„å‡½æ•°ã€‚ * * è¿™ä¸ªå‡½æ•°ä¸èƒ½åœ¨åªæœ‰ä¸¤æ¬¡è¿­ä»£çš„æƒ…å†µä¸‹åˆ›å»ºä¸€ä¸ªå†²çªï¼Œæ‰€ä»¥æˆ‘ä»¬æœ‰ä¸¤æ¬¡è¿­ä»£å»å®ç°é›ªå´©æ•ˆåº”ã€‚åœ¨è¿™ä¸¤æ¬¡è¿­ä»£ä¸­ï¼Œ * æˆ‘ä»¬æœ‰å…­å±‚æ··åˆï¼Œè¿™è¶³ä»¥å°†ä¸€ä¸ªæ¯”ç‰¹çš„å½±å“æ‰©æ•£åˆ° 2^6 = 64 çš„çŠ¶æ€æ¯”ç‰¹ã€‚ * * æ—‹è½¬å¸¸æ•°æ˜¯é€šè¿‡è€ƒè™‘64ä¸ªä¸€æ¯”ç‰¹è¾“å…¥å·®æˆ–2016ä¸ªä¸¤æ¯”ç‰¹è¾“å…¥å·®ï¼Œå¹¶æ‰¾åˆ°è¯¥å·®å¯¼è‡´æ¯ä¸ª128ä¸ªè¾“å‡ºæ¯”ç‰¹æ”¹å˜çš„æ¦‚ç‡ï¼Œ * ä½¿ç”¨éšæœºåˆå§‹çŠ¶æ€çš„æ ·æœ¬ï¼Œå¾—å‡ºçš„ã€‚ * * ç„¶åå°†è®¡ç®—çš„æ¦‚ç‡çš„ Shannon ç†µæ±‚å’Œï¼Œå¾—å‡ºä¸€ä¸ªåˆ†æ•°ã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œä»»ä½•è¾“å…¥å˜åŒ–éƒ½æœ‰ 50% çš„å‡ ç‡åˆ‡æ¢ä»»ä½•ç»™å®šçš„è¾“å‡ºæ¯”ç‰¹ã€‚ * * æ··åˆåˆ†æ•°ï¼ˆä»¥ä½ä¸ºå•ä½ï¼‰å¯¹äºï¼ˆ12,45ï¼‰ï¼š * è¾“å…¥å·®ï¼š1æ¯”ç‰¹ 2æ¯”ç‰¹ * 1è½®ï¼š 713.3 42542.6 * 2è½®ï¼š 2753.7 140389.8 * 3è½®ï¼š 5954.1 233458.2 * 4è½®ï¼š 7862.6 256672.2 * å®Œç¾çš„ï¼š 8192 258048 * (64*128) (64*63/2 * 128) */#define HASH_MIX(x, y, a) \\ ( x ^= (a), \\ y ^= x, x = rol64(x,12),\\ x += y, y = rol64(y,45),\\ y *= 9 )/* * å°†ä¸¤ä¸ª longs æŠ˜å æˆä¸€ä¸ª 32 ä½çš„å“ˆå¸Œå€¼ã€‚è¿™å¿…é¡»å¾ˆå¿«ï¼Œä½† * å»¶è¿Ÿå¹¶ä¸é‚£ä¹ˆå…³é”®ï¼Œå› ä¸ºåœ¨å“ˆå¸Œå€¼è¢«ä½¿ç”¨ä¹‹å‰è¿˜æœ‰ç›¸å½“å¤šçš„é¢å¤– * å·¥ä½œè¦åšã€‚ */static inline unsigned int fold_hash(unsigned long x, unsigned long y)&#123; y ^= x * GOLDEN_RATIO_64; y *= GOLDEN_RATIO_64; return y &gt;&gt; 32;&#125;#else /* 32-bit case *//* * æ··åˆåˆ†æ•°ï¼ˆä»¥ä½ä¸ºå•ä½ï¼‰å¯¹äºï¼ˆ7,20ï¼‰ï¼š * è¾“å…¥å·®ï¼š1æ¯”ç‰¹ 2-bit * 1è½®ï¼š 330.3 9201.6 * 2è½®ï¼š 1246.4 25475.4 * 3è½®ï¼š 1907.1 31295.1 * 4è½®ï¼š 2042.3 31718.6 * å®Œç¾ï¼š 2048 31744 * (32*64) (32*31/2 * 64) * * è¿™éƒ¨åˆ†æ³¨é‡Šæè¿°äº†ä¸€ç§å“ˆå¸Œæ··åˆæ–¹æ³•çš„æ€§èƒ½ã€‚å¯¹äºä¸€ä¸ªå’Œä¸¤ä¸ªæ¯”ç‰¹çš„è¾“å…¥å·®ï¼Œåˆ†åˆ«è¿›è¡Œ1è½®ã€2è½®ã€3è½®å’Œ4è½®çš„æ··åˆæ“ä½œåï¼Œå¾—å‡ºçš„æ··åˆåˆ†æ•°ä¸ç†æƒ³æƒ…å†µä¸‹çš„åˆ†æ•°è¿›è¡Œæ¯”è¾ƒã€‚ * æ··åˆåˆ†æ•°è¶Šæ¥è¿‘ç†æƒ³åˆ†æ•°ï¼ˆå®Œç¾ï¼‰ï¼Œè¯´æ˜è¿™ç§æ··åˆæ–¹æ³•çš„æ€§èƒ½è¶Šå¥½ã€‚ */#define HASH_MIX(x, y, a) \\ ( x ^= (a), \\ y ^= x, x = rol32(x, 7),\\ x += y, y = rol32(y,20),\\ y *= 9 )/* * å®šä¹‰äº†ä¸€ä¸ªåä¸º HASH_MIX çš„å®ï¼Œå®ƒæ¥å—ä¸‰ä¸ªå‚æ•°ï¼šxï¼Œyå’Œaã€‚ * å®çš„ä¸»ä½“æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼åºåˆ—ï¼Œå…¶ä¸­åŒ…æ‹¬å‡ ä¸ªä½æ“ä½œå’Œç®—æœ¯æ“ä½œï¼Œ * è¿™äº›æ“ä½œå¯ä»¥æ··åˆå’Œæ‰©æ•£è¾“å…¥å€¼çš„æ¯”ç‰¹ï¼Œä»¥æ”¹å–„å“ˆå¸Œå‡½æ•°çš„æ€§èƒ½ã€‚ */static inline unsigned int fold_hash(unsigned long x, unsigned long y)&#123; /* Use arch-optimized multiply if one exists */ return __hash_32(y ^ __hash_32(x));&#125;/* * å®šä¹‰äº†ä¸€ä¸ªåä¸º fold_hash çš„å†…è”å‡½æ•°ï¼Œå®ƒæ¥å—ä¸¤ä¸ª unsigned long å‚æ•°ï¼šx å’Œ yã€‚ * å‡½æ•°é¦–å…ˆæ‰§è¡Œ XOR æ“ä½œï¼Œç„¶åè°ƒç”¨ __hash_32 å‡½æ•°å°†ç»“æœæŠ˜å ä¸ºä¸€ä¸ª32ä½çš„å“ˆå¸Œå€¼ã€‚ * è¿™ä¸ªå‡½æ•°ä¹Ÿè€ƒè™‘äº†ç³»ç»Ÿæ¶æ„çš„ä¼˜åŒ–ï¼Œå¦‚æœå­˜åœ¨é’ˆå¯¹ç‰¹å®šæ¶æ„ä¼˜åŒ–çš„ä¹˜æ³•æ“ä½œï¼Œå®ƒä¼šä½¿ç”¨ã€‚ */#endif/* * &#x27;#endif&#x27; æ˜¯é¢„å¤„ç†å™¨æŒ‡ä»¤çš„ç»“æŸæ ‡å¿—ï¼Œè¡¨ç¤ºå‰é¢çš„æ¡ä»¶ç¼–è¯‘å—ç»“æŸã€‚ */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* * è¿”å›å·²çŸ¥é•¿åº¦å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ã€‚è¿™ä¸ªå‡½æ•°è¢«ç²¾å¿ƒè®¾è®¡æ¥åŒ¹é… hash_name() å‡½æ•°ï¼Œåè€…æ˜¯æ›´é‡è¦çš„å‡½æ•°ã€‚ * ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å¿…é¡»é€šè¿‡å“ˆå¸Œä¸€ä¸ªæœ€ç»ˆçš„åŒ…å«0..7ä¸ªæœ‰æ•ˆå­—èŠ‚çš„è¯æ¥ç»“æŸï¼Œ * ä»¥åŒ¹é… hash_name() å‡½æ•°è¿­ä»£ç›´åˆ°æ‰¾åˆ°åå­—åçš„åˆ†éš”ç¬¦çš„æ–¹å¼ã€‚ */unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)&#123; unsigned long a, x = 0, y = (unsigned long)salt; for (;;) &#123; if (!len) goto done; // å¦‚æœé•¿åº¦ä¸º0ï¼Œç›´æ¥è·³åˆ°done a = load_unaligned_zeropad(name); // ä»nameåŠ è½½ä¸€ä¸ªæœªå¯¹é½çš„å€¼ï¼Œå¹¶è¡¥0 if (len &lt; sizeof(unsigned long)) break; // å¦‚æœé•¿åº¦å°äºunsigned longçš„å­—èŠ‚é•¿åº¦ï¼Œè·³å‡ºå¾ªç¯ HASH_MIX(x, y, a); // æ‰§è¡Œå“ˆå¸Œæ··åˆæ“ä½œ name += sizeof(unsigned long); // ç§»åŠ¨nameçš„æŒ‡é’ˆ len -= sizeof(unsigned long); // å‡å°‘lençš„å€¼ &#125; x ^= a &amp; bytemask_from_count(len); // æ‰§è¡ŒXORæ“ä½œdone: return fold_hash(x, y); // è¿”å›æŠ˜å åçš„å“ˆå¸Œå€¼&#125;EXPORT_SYMBOL(full_name_hash); // å¯¼å‡ºfull_name_hashç¬¦å·/* è¿”å›ä¸€ä¸ªä»¥ç©ºå­—ç¬¦ç»“æŸçš„å­—ç¬¦ä¸²çš„&quot;hash_len&quot;ï¼ˆå“ˆå¸Œå€¼å’Œé•¿åº¦ï¼‰ */u64 hashlen_string(const void *salt, const char *name)&#123; unsigned long a = 0, x = 0, y = (unsigned long)salt; unsigned long adata, mask, len; const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS; len = 0; goto inside; // ç›´æ¥è·³åˆ°insideæ ‡ç­¾ do &#123; HASH_MIX(x, y, a); // æ‰§è¡Œå“ˆå¸Œæ··åˆæ“ä½œ len += sizeof(unsigned long); // å¢åŠ lençš„å€¼inside: a = load_unaligned_zeropad(name+len); // ä»name+lenåŠ è½½ä¸€ä¸ªæœªå¯¹é½çš„å€¼ï¼Œå¹¶è¡¥0 &#125; while (!has_zero(a, &amp;adata, &amp;constants)); // å¾ªç¯ç›´åˆ°aä¸­æœ‰0 adata = prep_zero_mask(a, adata, &amp;constants); // å‡†å¤‡é›¶æ©ç  mask = create_zero_mask(adata); // åˆ›å»ºé›¶æ©ç  x ^= a &amp; zero_bytemask(mask); // æ‰§è¡ŒXORæ“ä½œ return hashlen_create(fold_hash(x, y), len + find_zero(mask)); // åˆ›å»ºhashlen&#125;EXPORT_SYMBOL(hashlen_string); // å¯¼å‡ºhashlen_stringç¬¦å·/* * è®¡ç®—è·¯å¾„ç»„ä»¶çš„é•¿åº¦å’Œå“ˆå¸Œå€¼ï¼Œå¹¶è¿”å›&quot;hash_len&quot;ä½œä¸ºç»“æœã€‚ */static inline u64 hash_name(const void *salt, const char *name)&#123; unsigned long a = 0, b, x = 0, y = (unsigned long)salt; unsigned long adata, bdata, mask, len; const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS; len = 0; goto inside; // ç›´æ¥è·³åˆ°insideæ ‡ç­¾ do &#123; HASH_MIX(x, y, a); // æ‰§è¡Œå“ˆå¸Œæ··åˆæ“ä½œ len += sizeof(unsigned long); // å¢åŠ lençš„å€¼inside: a = load_unaligned_zeropad(name+len); // ä»name+lenåŠ è½½ä¸€ä¸ªæœªå¯¹é½çš„å€¼ï¼Œå¹¶è¡¥0 b = a ^ REPEAT_BYTE(&#x27;/&#x27;); // æ‰§è¡ŒXORæ“ä½œ &#125; while (!(has_zero(a, &amp;adata, &amp;constants) | has_zero(b, &amp;bdata, &amp;constants))); // å¾ªç¯ç›´åˆ°aæˆ–bä¸­æœ‰0 adata = prep_zero_mask(a, adata, &amp;constants); // å‡†å¤‡é›¶æ©ç  bdata = prep_zero_mask(b, bdata, &amp;constants); // å‡†å¤‡é›¶æ©ç  mask = create_zero_mask(adata | bdata); // åˆ›å»ºé›¶æ©ç  x ^= a &amp; zero_bytemask(mask); // æ‰§è¡ŒXORæ“ä½œ return hashlen_create(fold_hash(x, y), len + find_zero(mask)); // åˆ›å»ºhash```c#else /* !CONFIG_DCACHE_WORD_ACCESS: æ…¢é€Ÿï¼Œé€å­—èŠ‚ç‰ˆæœ¬ *//* è¿”å›å·²çŸ¥é•¿åº¦å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ */unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)&#123; unsigned long hash = init_name_hash(salt); // åˆå§‹åŒ–åå­—å“ˆå¸Œå€¼ while (len--) hash = partial_name_hash((unsigned char)*name++, hash); // å¯¹æ¯ä¸€ä¸ªå­—èŠ‚è¿›è¡Œå“ˆå¸Œ return end_name_hash(hash); // ç»“æŸåå­—å“ˆå¸Œ&#125;EXPORT_SYMBOL(full_name_hash); // å¯¼å‡ºfull_name_hashç¬¦å·/* è¿”å›ä¸€ä¸ªä»¥ç©ºå­—ç¬¦ç»“æŸçš„å­—ç¬¦ä¸²çš„&quot;hash_len&quot;ï¼ˆå“ˆå¸Œå€¼å’Œé•¿åº¦ï¼‰ */u64 hashlen_string(const void *salt, const char *name)&#123; unsigned long hash = init_name_hash(salt); // åˆå§‹åŒ–åå­—å“ˆå¸Œå€¼ unsigned long len = 0, c; c = (unsigned char)*name; while (c) &#123; len++; hash = partial_name_hash(c, hash); // å¯¹æ¯ä¸€ä¸ªå­—èŠ‚è¿›è¡Œå“ˆå¸Œ c = (unsigned char)name[len]; &#125; return hashlen_create(end_name_hash(hash), len); // åˆ›å»ºhashlen&#125;EXPORT_SYMBOL(hashlen_string); // å¯¼å‡ºhashlen_stringç¬¦å·/* * æˆ‘ä»¬çŸ¥é“è¿™é‡Œè‡³å°‘æœ‰ä¸€ä¸ªçœŸå®çš„è·¯å¾„ç»„ä»¶ã€‚ */static inline u64 hash_name(const void *salt, const char *name)&#123; unsigned long hash = init_name_hash(salt); // åˆå§‹åŒ–åå­—å“ˆå¸Œå€¼ unsigned long len = 0, c; c = (unsigned char)*name; do &#123; len++; hash = partial_name_hash(c, hash); // å¯¹æ¯ä¸€ä¸ªå­—èŠ‚è¿›è¡Œå“ˆå¸Œ c = (unsigned char)name[len]; &#125; while (c &amp;&amp; c != &#x27;/&#x27;); // å¾ªç¯ç›´åˆ°é‡åˆ°ç©ºå­—ç¬¦æˆ–è€…&#x27;/&#x27; return hashlen_create(end_name_hash(hash), len); // åˆ›å»ºhashlen&#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static int link_path_walk(const char *name, struct nameidata *nd)&#123; int depth = 0; // åˆå§‹åŒ–æ·±åº¦ä¸º 0ï¼Œç”¨äºè®°å½•ç¬¦å·é“¾æ¥çš„åµŒå¥—å±‚æ•° int err; // åˆå§‹åŒ– nd-&gt;last_type å’Œ nd-&gt;flags nd-&gt;last_type = LAST_ROOT; // è®¾ç½® nd-&gt;last_type ä¸º LAST_ROOT nd-&gt;flags |= LOOKUP_PARENT; // æ›´æ–° nd-&gt;flagsï¼Œæ·»åŠ  LOOKUP_PARENT æ ‡å¿— // å¦‚æœè·¯å¾„åæ˜¯é”™è¯¯çš„ï¼Œè¿”å›é”™è¯¯å€¼ if (IS_ERR(name)) // æ£€æŸ¥è·¯å¾„åæ˜¯å¦æœ‰æ•ˆï¼ˆä¸æ˜¯é”™è¯¯æŒ‡é’ˆï¼‰ return PTR_ERR(name); // å¦‚æœæ— æ•ˆï¼Œè¿”å›é”™è¯¯å€¼ // è·³è¿‡è·¯å¾„åå¼€å¤´çš„ &#x27;/&#x27; while (*name == &#x27;/&#x27;) // å½“è·¯å¾„åä»¥ &#x27;/&#x27; å¼€å¤´æ—¶ï¼Œè¿›å…¥å¾ªç¯ name++; // å°† name æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½ï¼Œè·³è¿‡ &#x27;/&#x27; // å¦‚æœè·¯å¾„åä¸ºç©ºï¼Œè¿”å› 0 if (!*name) &#123; // æ£€æŸ¥è·¯å¾„åæ˜¯å¦ä¸ºç©ºï¼ˆåœ¨è·³è¿‡å¼€å¤´çš„ &#x27;/&#x27; ä¹‹åï¼‰ nd-&gt;dir_mode = 0; // å°† nd-&gt;dir_mode è®¾ç½®ä¸º 0 return 0; // è¿”å› 0ï¼Œè¡¨ç¤ºè·¯å¾„æŸ¥æ‰¾ç»“æŸ &#125; // å¼€å§‹å¾ªç¯å¤„ç†è·¯å¾„åçš„æ¯ä¸ªç»„ä»¶ for (;;) &#123; // æ— é™å¾ªç¯ï¼Œç›´åˆ°è·¯å¾„åçš„æ‰€æœ‰ç»„ä»¶éƒ½è¢«å¤„ç† struct mnt_idmap *idmap; const char *link; u64 hash_len; int type; // è·å–æ–‡ä»¶ç³»ç»Ÿ ID æ˜ å°„,æ–‡ä»¶ç³»ç»Ÿ ID æ˜ å°„ç”¨äºå°† VFS ä¸­çš„ç”¨æˆ·å’Œç»„ ID è½¬æ¢ä¸ºåº•å±‚æ–‡ä»¶ç³»ç»Ÿä¸­çš„ç”¨æˆ·å’Œç»„ IDã€‚ idmap = mnt_idmap(nd-&gt;path.mnt); // è·å– nd-&gt;path.mnt å¯¹åº”çš„æ–‡ä»¶ç³»ç»Ÿ ID æ˜ å°„ // æ£€æŸ¥æ˜¯å¦æœ‰æƒé™æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œ err = may_lookup(idmap, nd); // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æœ‰æƒé™æŸ¥æ‰¾ if (err) // å¦‚æœæ²¡æœ‰æƒé™ return err; // è¿”å›é”™è¯¯å€¼ // è®¡ç®—å½“å‰è·¯å¾„ç»„ä»¶çš„å“ˆå¸Œå€¼å’Œé•¿åº¦,è¿™äº›å€¼å°†ç”¨äºåœ¨æ•£åˆ—æŸ¥æ‰¾ä¸­å¿«é€Ÿæ¯”è¾ƒè·¯å¾„åç»„ä»¶ã€‚ hash_len = hash_name(nd-&gt;path.dentry, name); // è®¡ç®—å“ˆå¸Œå€¼å’Œé•¿åº¦ // åˆ¤æ–­å½“å‰è·¯å¾„ç»„ä»¶çš„ç±»å‹ï¼ˆ&#x27;.&#x27;ã€&#x27;..&#x27; æˆ–æ™®é€šç»„ä»¶ï¼‰ type = LAST_NORM; // é»˜è®¤ä¸ºæ™®é€šç»„ä»¶ if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; // å¦‚æœç»„ä»¶ä»¥ &#x27;.&#x27; å¼€å¤´ï¼Œæ£€æŸ¥é•¿åº¦ case 2: if (name[1] == &#x27;.&#x27;) &#123; // å¦‚æœç»„ä»¶ä¸º &quot;..&quot; type = LAST_DOTDOT; // è®¾ç½®ç±»å‹ä¸º LAST_DOTDOT nd-&gt;state |= ND_JUMPED; // æ›´æ–° nd-&gt;stateï¼Œæ·»ã€‚è¿™ä¸ªæ ‡å¿—è¡¨ç¤ºæˆ‘ä»¬æ­£è·³è½¬åˆ°çˆ¶ç›®å½•ã€‚ &#125; break; case 1: type = LAST_DOT; // å¦‚æœç»„ä»¶ä¸º &quot;.&quot;ï¼Œè®¾ç½®ç±»å‹ä¸º LAST_DOT &#125; if (likely(type == LAST_NORM)) &#123; // å¦‚æœç»„ä»¶ç±»å‹ä¸ºæ™®é€šç»„ä»¶ struct dentry *parent = nd-&gt;path.dentry; // è·å–å½“å‰ç»„ä»¶çš„çˆ¶ç›®å½• nd-&gt;state &amp;= ~ND_JUMPED; // æ¸…é™¤ nd-&gt;state çš„ ND_JUMPED æ ‡å¿— // å¦‚æœéœ€è¦ï¼Œæ‰§è¡Œè‡ªå®šä¹‰å“ˆå¸Œæ“ä½œã€‚æŸäº›æ–‡ä»¶ç³»ç»Ÿå¯èƒ½éœ€è¦è‡ªå®šä¹‰å“ˆå¸Œæ“ä½œä»¥é€‚åº”å…¶ç‰¹å®šçš„æŸ¥æ‰¾æœºåˆ¶ã€‚ if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; // æ£€æŸ¥çˆ¶ç›®å½•æ˜¯å¦éœ€è¦è‡ªå®šä¹‰å“ˆå¸Œæ“ä½œ struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; // åˆå§‹åŒ– qstr ç»“æ„ä½“ err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); // æ‰§è¡Œè‡ªå®šä¹‰å“ˆå¸Œæ“ä½œ if (err &lt; 0) // å¦‚æœæ“ä½œå¤±è´¥ return err; // è¿”å›é”™è¯¯å€¼ hash_len = this.hash_len; // æ›´æ–°å“ˆå¸Œå€¼å’Œé•¿åº¦ name = this.name; // æ›´æ–° name æŒ‡é’ˆ &#125; &#125; //--------------------------------------------------------------------- // æ›´æ–° nd çš„ last å’Œ last_type æˆå‘˜ nd-&gt;last.hash_len = hash_len; // è®¾ç½® nd-&gt;last çš„å“ˆå¸Œå€¼å’Œé•¿åº¦ nd-&gt;last.name = name; // è®¾ç½® nd-&gt;last çš„åç§° nd-&gt;last_type = type; // è®¾ç½® nd-&gt;last_type ä¸ºå½“å‰ç»„ä»¶çš„ç±»å‹ // å°† name æŒ‡é’ˆå‘åç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªè·¯å¾„ç»„ä»¶ name += hashlen_len(hash_len); // å°† name æŒ‡é’ˆå‘åç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªè·¯å¾„ç»„ä»¶çš„èµ·å§‹ä½ç½® // å¦‚æœåˆ°è¾¾è·¯å¾„åçš„ç»“å°¾ï¼Œå¤„ç†ç»“æŸ if (!*name) // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾è·¯å¾„åçš„ç»“å°¾ goto OK; // è·³è½¬åˆ° OK æ ‡ç­¾ // è·³è¿‡è¿ç»­çš„ &#x27;/&#x27; do &#123; name++; // å°† name æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½ &#125; while (unlikely(*name == &#x27;/&#x27;)); // å½“é‡åˆ° &#x27;/&#x27; æ—¶ï¼Œç»§ç»­å¾ªç¯ // å¦‚æœåˆ°è¾¾è·¯å¾„åçš„ç»“å°¾ï¼Œå¤„ç†ç»“æŸ if (unlikely(!*name)) &#123; // å†æ¬¡æ£€æŸ¥æ˜¯å¦åˆ°è¾¾è·¯å¾„åçš„ç»“å°¾OK: // pathname or trailing symlink, done if (!depth) &#123; // å¦‚æœå½“å‰å¤„ç†çš„è·¯å¾„ç»„ä»¶ä¸æ˜¯ç¬¦å·é“¾æ¥çš„ä¸€éƒ¨åˆ† nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); // è®¾ç½® nd-&gt;dir_vfsuid nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; // è®¾ç½® nd-&gt;dir_mode nd-&gt;flags &amp;= ~LOOKUP_PARENT; // æ¸…é™¤ nd-&gt;flags çš„ LOOKUP_PARENT æ ‡å¿— return 0; // è¿”å› 0ï¼Œè¡¨ç¤ºè·¯å¾„æŸ¥æ‰¾ç»“æŸ &#125; // last component of nested symlink name = nd-&gt;stack[--depth].name; // è·å–ç¬¦å·é“¾æ¥æ ˆä¸­ä¸‹ä¸€ä¸ªç»„ä»¶çš„åç§° link = walk_component(nd, 0); // å¤„ç†å½“å‰ç»„ä»¶ &#125; else &#123; // not the last component link = walk_component(nd, WALK_MORE); // å¤„ç†å½“å‰ç»„ä»¶ï¼Œä¼ é€’ WALK_MORE æ ‡å¿— &#125; // å¦‚æœ link ä¸ä¸ºç©ºï¼Œè¡¨ç¤ºéœ€è¦å¤„ç†ç¬¦å·é“¾æ¥ if (unlikely(link)) &#123; // æ£€æŸ¥ link æ˜¯å¦ä¸ºç©º if (IS_ERR(link)) // å¦‚æœ link æ˜¯é”™è¯¯æŒ‡é’ˆ return PTR_ERR(link); // è¿”å›é”™è¯¯å€¼ // a symlink to follow nd-&gt;stack[depth++].name = name; // å°†å½“å‰ç»„ä»¶çš„åç§°å‹å…¥ç¬¦å·é“¾æ¥æ ˆ name = link; // å°† name æŒ‡é’ˆè®¾ç½®ä¸ºç¬¦å·é“¾æ¥çš„ç›®æ ‡è·¯å¾„ continue; // ç»§ç»­å¾ªç¯å¤„ç†ç¬¦å·é“¾æ¥çš„ç›®æ ‡è·¯å¾„ &#125; // æ£€æŸ¥ dentry æ˜¯å¦å¯ä»¥æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œ if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; // å¦‚æœä¸èƒ½æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœ nd-&gt;flags ä¸­åŒ…å« LOOKUP_RCU æ ‡å¿— if (!try_to_unlazy(nd)) // å°è¯•å–æ¶ˆå¯¹ nd çš„æ‡’åŠ è½½ return -ECHILD; // å¦‚æœå–æ¶ˆå¤±è´¥ï¼Œè¿”å› -ECHILD é”™è¯¯å€¼ &#125; return -ENOTDIR; // è¿”å› -ENOTDIR é”™è¯¯å€¼ï¼Œè¡¨ç¤ºä¸æ˜¯ç›®å½• &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * æ­¤å‡½æ•°åˆå§‹åŒ–è·¯å¾„æŸ¥æ‰¾ã€‚è¿”å›çš„å­—ç¬¦ä¸²æŒ‡é’ˆæ˜¯è·¯å¾„åçš„å‰©ä½™éƒ¨åˆ†ã€‚ */static const char *path_init(struct nameidata *nd, unsigned flags)&#123; int error; const char *s = nd-&gt;name-&gt;name; // è·å–è·¯å¾„å /* å¦‚æœåªè®¾ç½®äº† LOOKUP_CACHED è€Œæœªè®¾ç½® LOOKUP_RCUï¼Œåˆ™è¦æ±‚è°ƒç”¨æ–¹é‡è¯• */ if ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED) return ERR_PTR(-EAGAIN); if (!*s) // å¦‚æœè·¯å¾„åä¸ºç©ºï¼Œåˆ™å…³é—­ LOOKUP_RCU flags &amp;= ~LOOKUP_RCU; if (flags &amp; LOOKUP_RCU) // å¦‚æœè®¾ç½®äº† LOOKUP_RCUï¼Œåˆ™è¿›è¡Œ RCU è¯»é”å®š rcu_read_lock(); else nd-&gt;seq = nd-&gt;next_seq = 0; nd-&gt;flags = flags; // è®¾ç½®æ ‡å¿—ä½ nd-&gt;state |= ND_JUMPED; // è®¾ç½®çŠ¶æ€ä¸ºå·²è·³è½¬ // å¼€å§‹è¯»å–æŒ‚è½½é”å’Œé‡å‘½åé”çš„åºåˆ—è®¡æ•° nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount); nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount); smp_rmb(); if (nd-&gt;state &amp; ND_ROOT_PRESET) &#123; // å¦‚æœè®¾ç½®äº† ND_ROOT_PRESET struct dentry *root = nd-&gt;root.dentry; // è·å–æ ¹ç›®å½•é¡¹ struct inode *inode = root-&gt;d_inode; // è·å–æ ¹ç›®å½•é¡¹çš„ç´¢å¼•èŠ‚ç‚¹ if (*s &amp;&amp; unlikely(!d_can_lookup(root))) // å¦‚æœè·¯å¾„åä¸ä¸ºç©ºä¸”æ ¹ç›®å½•é¡¹æ— æ³•æŸ¥æ‰¾ï¼Œåˆ™è¿”å›é”™è¯¯ return ERR_PTR(-ENOTDIR); nd-&gt;path = nd-&gt;root; // è®¾ç½®è·¯å¾„ä¸ºæ ¹è·¯å¾„ nd-&gt;inode = inode; // è®¾ç½®ç´¢å¼•èŠ‚ç‚¹ if (flags &amp; LOOKUP_RCU) &#123; // å¦‚æœè®¾ç½®äº† LOOKUP_RCU nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); // å¼€å§‹è¯»å–è·¯å¾„çš„ç›®å½•é¡¹çš„åºåˆ—è®¡æ•° nd-&gt;root_seq = nd-&gt;seq; // è®¾ç½®æ ¹åºåˆ—è®¡æ•° &#125; else &#123; path_get(&amp;nd-&gt;path); // è·å–è·¯å¾„ &#125; return s; // è¿”å›è·¯å¾„åçš„å‰©ä½™éƒ¨åˆ† &#125; nd-&gt;root.mnt = NULL; /* å¦‚æœæ˜¯ç»å¯¹è·¯å¾„åï¼Œåˆ™è·å–æ ¹ç›®å½• */ if (*s == &#x27;/&#x27; &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123; error = nd_jump_root(nd); // è·³è½¬åˆ°æ ¹ç›®å½• if (unlikely(error)) // å¦‚æœè¿”å›é”™è¯¯ï¼Œåˆ™è¿”å›é”™è¯¯ return ERR_PTR(error); return s; // è¿”å›è·¯å¾„åçš„å‰©ä½™éƒ¨åˆ† &#125; /* å¦‚æœæ˜¯ç›¸å¯¹è·¯å¾„åï¼Œåˆ™è·å–å®ƒç›¸å¯¹çš„èµ·å§‹ç‚¹ */ if (nd-&gt;dfd == AT_FDCWD) &#123; if (flags &amp; LOOKUP_RCU) &#123; // å¦‚æœè®¾ç½®äº† LOOKUP_RCU struct fs_struct *fs = current-&gt;fs; unsigned seq; do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); // å¼€å§‹è¯»å–æ–‡ä»¶ç³»ç»Ÿçš„åºåˆ—è®¡æ•° nd-&gt;path = fs-&gt;pwd; // è®¾ç½®è·¯å¾„ä¸ºå½“å‰å·¥ä½œç›®å½• nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // è®¾ç½®ç´¢å¼•èŠ‚ç‚¹ nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); // å¼€å§‹è¯»å–è·¯å¾„çš„ç›®å½•é¡¹çš„åºåˆ—è®¡æ•° &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); // å¦‚æœæ–‡ä»¶ç³»ç»Ÿçš„åºåˆ—è®¡æ•°æœ‰å˜ï¼Œåˆ™é‡è¯• &#125; else &#123; get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); // è·å–å½“å‰å·¥ä½œç›®å½• nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // è®¾ç½®ç´¢å¼•èŠ‚ç‚¹ &#125; &#125; else &#123; /* è°ƒç”¨æ–¹å¿…é¡»æ£€æŸ¥èµ·å§‹è·¯å¾„ç»„ä»¶çš„æ‰§è¡Œæƒé™ */ struct fd f = fdget_raw(nd-&gt;dfd); // è·å–æ–‡ä»¶æè¿°ç¬¦ struct dentry *dentry; if (!f.file) // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™è¿”å›é”™è¯¯ return ERR_PTR(-EBADF); dentry = f.file-&gt;f_path.dentry; // è·å–æ–‡ä»¶çš„ç›®å½•```c if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123; // å¦‚æœè·¯å¾„åä¸ä¸ºç©ºä¸”ç›®å½•é¡¹æ— æ³•æŸ¥æ‰¾ï¼Œåˆ™è¿”å›é”™è¯¯ fdput(f); // é‡Šæ”¾æ–‡ä»¶æè¿°ç¬¦ return ERR_PTR(-ENOTDIR); &#125; nd-&gt;path = f.file-&gt;f_path; // è®¾ç½®è·¯å¾„ä¸ºæ–‡ä»¶çš„è·¯å¾„ if (flags &amp; LOOKUP_RCU) &#123; // å¦‚æœè®¾ç½®äº† LOOKUP_RCU nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // è®¾ç½®ç´¢å¼•èŠ‚ç‚¹ nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); // å¼€å§‹è¯»å–è·¯å¾„çš„ç›®å½•é¡¹çš„åºåˆ—è®¡æ•° &#125; else &#123; path_get(&amp;nd-&gt;path); // è·å–è·¯å¾„ nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // è®¾ç½®ç´¢å¼•èŠ‚ç‚¹ &#125; fdput(f); // é‡Šæ”¾æ–‡ä»¶æè¿°ç¬¦ &#125; /* å¯¹äºé™å®šèŒƒå›´çš„æŸ¥æ‰¾ï¼Œæˆ‘ä»¬éœ€è¦å°†æ ¹è®¾ç½®ä¸º dirfd */ if (flags &amp; LOOKUP_IS_SCOPED) &#123; nd-&gt;root = nd-&gt;path; // è®¾ç½®æ ¹ä¸ºè·¯å¾„ if (flags &amp; LOOKUP_RCU) &#123; // å¦‚æœè®¾ç½®äº† LOOKUP_RCU nd-&gt;root_seq = nd-&gt;seq; // è®¾ç½®æ ¹åºåˆ—è®¡æ•° &#125; else &#123; path_get(&amp;nd-&gt;root); // è·å–æ ¹è·¯å¾„ nd-&gt;state |= ND_ROOT_GRABBED; // è®¾ç½®çŠ¶æ€ä¸ºå·²è·å–æ ¹ &#125; &#125; return s; // è¿”å›è·¯å¾„åçš„å‰©ä½™éƒ¨åˆ†&#125; 12345678/* è¿™ä¸ªå‡½æ•°è´Ÿè´£æŸ¥æ‰¾è·¯å¾„çš„æœ€åä¸€ä¸ªç»„ä»¶ï¼Œå¦‚æœæœ€åä¸€ä¸ªç»„ä»¶æ˜¯æ™®é€šç±»å‹ä¸”åé¢è¿˜æœ‰å­—ç¬¦ï¼Œåˆ™è®¾ç½®æŸ¥æ‰¾æ ‡å¿—ä¸º FOLLOW å’Œ DIRECTORYï¼Œå¹¶èµ°å‘ä¸‹ä¸€ä¸ªç»„ä»¶ */static inline const char *lookup_last(struct nameidata *nd)&#123; if (nd-&gt;last_type == LAST_NORM &amp;&amp; nd-&gt;last.name[nd-&gt;last.len]) nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; return walk_component(nd, WALK_TRAILING);&#125; 12345678/* è¿™ä¸ªå‡½æ•°å¤„ç†è·¯å¾„ä¸‹é™çš„æƒ…å†µï¼Œå¦‚æœä¸åœ¨ RCU æ¨¡å¼ä¸‹ï¼Œåˆ™è·å–ç›®å½•é¡¹çš„å¼•ç”¨ï¼Œç„¶åè¿›å…¥ä¸‹ä¸€æ­¥ */static int handle_lookup_down(struct nameidata *nd)&#123; if (!(nd-&gt;flags &amp; LOOKUP_RCU)) dget(nd-&gt;path.dentry); nd-&gt;next_seq = nd-&gt;seq; return PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd-&gt;path.dentry));&#125; 123456789101112131415161718192021222324252627282930313233343536/* è¿™ä¸ªå‡½æ•°è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ï¼Œåˆå§‹åŒ–è·¯å¾„åï¼Œå¦‚æœè®¾ç½®äº† LOOKUP_DOWNï¼Œåˆ™å¤„ç†è·¯å¾„ä¸‹é™çš„æƒ…å†µï¼Œç„¶åè¿›è¡Œé“¾æ¥è·¯å¾„çš„éå†ï¼Œå®Œæˆè·¯å¾„çš„éå†åï¼Œæ£€æŸ¥æ˜¯å¦è®¾ç½®äº† LOOKUP_MOUNTPOINTï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å†æ¬¡å¤„ç†è·¯å¾„ä¸‹é™çš„æƒ…å†µï¼Œæœ€åå¦‚æœè®¾ç½®äº† LOOKUP_DIRECTORYï¼Œåˆ™æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œç›®å½•æŸ¥æ‰¾ï¼Œå¦‚æœä¸èƒ½åˆ™è¿”å›é”™è¯¯ï¼Œå¦åˆ™è®¾ç½®è·¯å¾„å¹¶ç»ˆæ­¢è·¯å¾„éå† */static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)&#123; const char *s = path_init(nd, flags); // åˆå§‹åŒ–è·¯å¾„ int err; if (unlikely(flags &amp; LOOKUP_DOWN) &amp;&amp; !IS_ERR(s)) &#123; // å¦‚æœè®¾ç½®äº† LOOKUP_DOWNï¼Œåˆ™å¤„ç†è·¯å¾„ä¸‹é™çš„æƒ…å†µ err = handle_lookup_down(nd); if (unlikely(err &lt; 0)) s = ERR_PTR(err); &#125; while (!(err = link_path_walk(s, nd)) &amp;&amp; // éå†é“¾æ¥è·¯å¾„ (s = lookup_last(nd)) != NULL) // æŸ¥æ‰¾è·¯å¾„çš„æœ€åä¸€ä¸ªç»„ä»¶ ; if (!err &amp;&amp; unlikely(nd-&gt;flags &amp; LOOKUP_MOUNTPOINT)) &#123; // å¦‚æœæ²¡æœ‰é”™è¯¯ä¸”è®¾ç½®äº† LOOKUP_MOUNTPOINTï¼Œåˆ™å¤„ç†è·¯å¾„ä¸‹é™çš„æƒ…å†µ err = handle_lookup_down(nd); nd-&gt;state &amp;= ~ND_JUMPED; // no d_weak_revalidate(), please... &#125; if (!err) // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œåˆ™å®Œæˆè·¯å¾„éå† err = complete_walk(nd); if (!err &amp;&amp; nd-&gt;flags &amp; LOOKUP_DIRECTORY) // å¦‚æœæ²¡æœ‰é”™è¯¯ä¸”è®¾ç½®äº† LOOKUP_DIRECTORYï¼Œåˆ™æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œç›®å½•æŸ¥æ‰¾ if (!d_can_lookup(nd-&gt;path.dentry)) err = -ENOTDIR; if (!err) &#123; // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œåˆ™è®¾ç½®è·¯å¾„ *path = nd-&gt;path; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL; &#125; terminate_walk(nd); // ç»ˆæ­¢è·¯å¾„éå† return err;&#125; 123456789101112131415161718192021/* è¿™ä¸ªå‡½æ•°è´Ÿè´£æŸ¥æ‰¾æ–‡ä»¶åå¯¹åº”çš„è·¯å¾„ï¼Œé¦–å…ˆè®¾ç½®åç§°æ•°æ®ï¼Œç„¶åè¿›è¡Œè·¯å¾„æŸ¥æ‰¾ã€‚å¦‚æœè¿”å›å€¼æ˜¯ -ECHILD æˆ–è€… -ESTALEï¼Œå°±ä¼šå†æ¬¡è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ï¼Œæœ€åå¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œå°±ä¼šå®¡è®¡èŠ‚ç‚¹å¹¶æ¢å¤åç§°æ•°æ® */int filename_lookup(int dfd, struct filename *name, unsigned flags, struct path *path, struct path *root)&#123; int retval; struct nameidata nd; if (IS_ERR(name)) // å¦‚æœæ–‡ä»¶åå‡ºé”™ï¼Œè¿”å›é”™è¯¯ return PTR_ERR(name); set_nameidata(&amp;nd, dfd, name, root); // è®¾ç½®åç§°æ•°æ® retval = path_lookupat(&amp;nd, flags | LOOKUP_RCU, path); // è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ if (unlikely(retval == -ECHILD)) // å¦‚æœè¿”å›å€¼æ˜¯ -ECHILDï¼Œå†æ¬¡è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ retval = path_lookupat(&amp;nd, flags, path); if (unlikely(retval == -ESTALE)) // å¦‚æœè¿”å›å€¼æ˜¯ -ESTALEï¼Œå†æ¬¡è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ retval = path_lookupat(&amp;nd, flags | LOOKUP_REVAL, path); if (likely(!retval)) // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œå®¡è®¡èŠ‚ç‚¹ audit_inode(name, path-&gt;dentry, flags &amp; LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0); restore_nameidata(); // æ¢å¤åç§°æ•°æ® return retval;&#125; 12345678910111213141516/* è¿™ä¸ªå‡½æ•°è´Ÿè´£è·å–è·¯å¾„çš„çˆ¶è·¯å¾„ï¼Œé¦–å…ˆåˆå§‹åŒ–è·¯å¾„ï¼Œç„¶åè¿›è¡Œé“¾æ¥è·¯å¾„éå†ï¼Œæœ€åå®Œæˆè·¯å¾„éå†å¹¶è®¾ç½®çˆ¶è·¯å¾„ */static int path_parentat(struct nameidata *nd, unsigned flags, struct path *parent)&#123; const char *s = path_init(nd, flags); // åˆå§‹åŒ–è·¯å¾„ int err = link_path_walk(s, nd); // éå†é“¾æ¥è·¯å¾„ if (!err) // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œå®Œæˆè·¯å¾„éå† err = complete_walk(nd); if (!err) &#123; // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œè®¾ç½®çˆ¶è·¯å¾„ *parent = nd-&gt;path; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL; &#125; terminate_walk(nd); // ç»ˆæ­¢è·¯å¾„éå† return err;&#125; 123456789101112131415161718192021222324/* è¿™ä¸ªå‡½æ•°è·å–æ–‡ä»¶åçš„çˆ¶è·¯å¾„ï¼Œé¦–å…ˆè®¾ç½®åç§°æ•°æ®ï¼Œç„¶åè·å–çˆ¶è·¯å¾„ã€‚å¦‚æœè¿”å›å€¼æ˜¯ -ECHILD æˆ–è€… -ESTALEï¼Œå°±ä¼šå†æ¬¡è·å–çˆ¶è·¯å¾„ï¼Œæœ€åå¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œå°±ä¼šè®¾ç½®æœ€åä¸€ä¸ªç»„ä»¶çš„åç§°å’Œç±»å‹ï¼Œå¹¶å®¡è®¡èŠ‚ç‚¹ */static int filename_parentat(int dfd, struct filename *name, unsigned int flags, struct path *parent, struct qstr *last, int *type)&#123; int retval; struct nameidata nd; if (IS_ERR(name)) // å¦‚æœæ–‡ä»¶åå‡ºé”™ï¼Œè¿”å›é”™è¯¯ return PTR_ERR(name); set_nameidata(&amp;nd, dfd, name, NULL); // è®¾ç½®åç§°æ•°æ® retval = path_parentat(&amp;nd, flags | LOOKUP_RCU, parent); // è·å–çˆ¶è·¯å¾„ if (unlikely(retval == -ECHILD)) // å¦‚æœè¿”å›å€¼æ˜¯ -ECHILDï¼Œå†æ¬¡è·å–çˆ¶è·¯å¾„ retval = path_parentat(&amp;nd, flags, parent); if (unlikely(retval == -ESTALE)) // å¦‚æœè¿”å›å€¼æ˜¯ -ESTALEï¼Œå†æ¬¡è·å–çˆ¶è·¯å¾„ retval = path_parentat(&amp;nd, flags | LOOKUP_REVAL, parent); if (likely(!retval)) &#123; // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œè®¾ç½®æœ€åä¸€ä¸ªç»„ä»¶çš„åç§°å’Œç±»å‹ï¼Œå¹¶å®¡è®¡èŠ‚ç‚¹ *last = nd.last; *type = nd.last_type; audit_inode(name, parent-&gt;dentry, AUDIT_INODE_PARENT); &#125; restore_nameidata(); // æ¢å¤åç§°æ•°æ® return retval;&#125; 12345678910111213141516171819202122/* è¿™ä¸ªå‡½æ•°é¦–å…ˆè·å–æ–‡ä»¶åçš„çˆ¶è·¯å¾„ï¼Œç„¶åå¦‚æœç±»å‹ä¸æ˜¯ LAST_NORMï¼Œå°±ä¼šé‡Šæ”¾è·¯å¾„å¹¶è¿”å›é”™è¯¯ã€‚ç„¶åé”å®šçˆ¶èŠ‚ç‚¹å¹¶è¿›è¡ŒæŸ¥æ‰¾ã€‚å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œå°±ä¼šè§£é”å¹¶é‡Šæ”¾è·¯å¾„ã€‚ */static struct dentry *__kern_path_locked(struct filename *name, struct path *path)&#123; struct dentry *d; struct qstr last; int type, error; error = filename_parentat(AT_FDCWD, name, 0, path, &amp;last, &amp;type); // è·å–æ–‡ä»¶åçš„çˆ¶è·¯å¾„ if (error) // å¦‚æœå‡ºé”™ï¼Œè¿”å›é”™è¯¯ return ERR_PTR(error); if (unlikely(type != LAST_NORM)) &#123; // å¦‚æœç±»å‹ä¸æ˜¯ LAST_NORMï¼Œé‡Šæ”¾è·¯å¾„å¹¶è¿”å›é”™è¯¯ path_put(path); return ERR_PTR(-EINVAL); &#125; inode_lock_nested(path-&gt;dentry-&gt;d_inode, I_MUTEX_PARENT); // é”å®šçˆ¶èŠ‚ç‚¹ d = __lookup_hash(&amp;last, path-&gt;dentry, 0); // è¿›è¡ŒæŸ¥æ‰¾ if (IS_ERR(d)) &#123; // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè§£é”å¹¶é‡Šæ”¾è·¯å¾„ inode_unlock(path-&gt;dentry-&gt;d_inode); path_put(path); &#125; return d;&#125; 123456789/* è¿™ä¸ªå‡½æ•°è·å–æ–‡ä»¶åï¼Œå¹¶è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ï¼Œæœ€åé‡Šæ”¾æ–‡ä»¶å */struct dentry *kern_path_locked(const char *name, struct path *path)&#123; struct filename *filename = getname_kernel(name); // è·å–æ–‡ä»¶å struct dentry *res = __kern_path_locked(filename, path); // è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ putname(filename); // é‡Šæ”¾æ–‡ä»¶å return res;&#125; 1234567891011/* è¿™ä¸ªå‡½æ•°è·å–æ–‡ä»¶åï¼Œå¹¶è¿›è¡Œæ–‡ä»¶åæŸ¥æ‰¾ï¼Œæœ€åé‡Šæ”¾æ–‡ä»¶å */int kern_path(const char *name, unsigned int flags, struct path *path)&#123; struct filename *filename = getname_kernel(name); // è·å–æ–‡ä»¶å int ret = filename_lookup(AT_FDCWD, filename, flags, path, NULL); // è¿›è¡Œæ–‡ä»¶åæŸ¥æ‰¾ putname(filename); // é‡Šæ”¾æ–‡ä»¶å return ret;&#125;EXPORT_SYMBOL(kern_path); 12345678910111213141516171819202122232425/** * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair * @dentry: pointer to dentry of the base directory * @mnt: pointer to vfs mount of the base directory * @name: pointer to file name * @flags: lookup flags * @path: pointer to struct path to fill * * è¿™ä¸ªå‡½æ•°é¦–å…ˆè·å–æ–‡ä»¶åï¼Œç„¶åè¿›è¡Œæ–‡ä»¶åæŸ¥æ‰¾ï¼Œæœ€åé‡Šæ”¾æ–‡ä»¶å */int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt, const char *name, unsigned int flags, struct path *path)&#123; struct filename *filename; struct path root = &#123;.mnt = mnt, .dentry = dentry&#125;; // è®¾ç½®æ ¹è·¯å¾„ int ret; filename = getname_kernel(name); // è·å–æ–‡ä»¶å /* the first argument of filename_lookup() is ignored with root */ ret = filename_lookup(AT_FDCWD, filename, flags, path, &amp;root); // è¿›è¡Œæ–‡ä»¶åæŸ¥æ‰¾ putname(filename); // é‡Šæ”¾æ–‡ä»¶å return ret;&#125;EXPORT_SYMBOL(vfs_path_lookup); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* å®šä¹‰ä¸€ä¸ªå‡½æ•° lookup_one_commonï¼Œè¯¥å‡½æ•°ç”¨äºåœ¨åŸºç¡€ç›®å½•ä¸­æŸ¥æ‰¾æŒ‡å®šåç§°çš„ç›®å½•é¡¹ã€‚idmap: ç”¨æˆ·å’Œç»„çš„èº«ä»½æ˜ å°„ï¼›name: éœ€è¦æŸ¥æ‰¾çš„ç›®å½•é¡¹åç§°ï¼›base: åŸºç¡€ç›®å½•ï¼›len: åç§°çš„é•¿åº¦ï¼›this: qstrï¼ˆquick stringï¼‰ç»“æ„çš„æŒ‡é’ˆï¼Œç”¨äºå­˜å‚¨æŸ¥æ‰¾çš„ç»“æœã€‚*/static int lookup_one_common(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len, struct qstr *this)&#123; /* åˆå§‹åŒ– this ç»“æ„ */ this-&gt;name = name; this-&gt;len = len; /* è®¡ç®—å¹¶è®¾ç½®å“ˆå¸Œå€¼ */ this-&gt;hash = full_name_hash(base, name, len); /* å¦‚æœåç§°é•¿åº¦ä¸º0ï¼Œè¿”å›é”™è¯¯ */ if (!len) return -EACCES; /* å¦‚æœåç§°ä»¥&#x27;.&#x27;å¼€å§‹ï¼Œä¸”é•¿åº¦å°äº2æˆ–è€…é•¿åº¦ç­‰äº2ä¸”ç¬¬äºŒä¸ªå­—ç¬¦ä¹Ÿä¸º&#x27;.&#x27;ï¼Œè¿”å›é”™è¯¯ */ if (unlikely(name[0] == &#x27;.&#x27;)) &#123; if (len &lt; 2 || (len == 2 &amp;&amp; name[1] == &#x27;.&#x27;)) return -EACCES; &#125; /* å¦‚æœåç§°ä¸­åŒ…å«&#x27;/&#x27;æˆ–è€…&#x27;\\0&#x27;ï¼Œè¿”å›é”™è¯¯ */ while (len--) &#123; unsigned int c = *(const unsigned char *)name++; if (c == &#x27;/&#x27; || c == &#x27;\\0&#x27;) return -EACCES; &#125; /* å¦‚æœåŸºç¡€ç›®å½•çš„æ ‡å¿—ä½åŒ…å« DCACHE_OP_HASHï¼Œå°è¯•ä½¿ç”¨åº•å±‚æ–‡ä»¶ç³»ç»Ÿçš„å“ˆå¸Œå‡½æ•° */ if (base-&gt;d_flags &amp; DCACHE_OP_HASH) &#123; int err = base-&gt;d_op-&gt;d_hash(base, this); if (err &lt; 0) return err; &#125; /* æ£€æŸ¥æƒé™ */ return inode_permission(idmap, base-&gt;d_inode, MAY_EXEC);&#125; 1234567891011121314151617181920212223242526/*å®šä¹‰ä¸€ä¸ªå‡½æ•° try_lookup_one_lenï¼Œè¯¥å‡½æ•°ç”¨äºåœ¨åŸºç¡€ç›®å½•ä¸­æŸ¥æ‰¾å¹¶è¿”å›æŒ‡å®šåç§°çš„ç›®å½•é¡¹ï¼Œå¦‚æœè¯¥ç›®å½•é¡¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› NULLã€‚name: éœ€è¦æŸ¥æ‰¾çš„ç›®å½•é¡¹åç§°ï¼›base: åŸºç¡€ç›®å½•ï¼›len: åç§°çš„é•¿åº¦ã€‚*/struct dentry *try_lookup_one_len(const char *name, struct dentry *base, int len)&#123; struct qstr this; int err; /* æ£€æŸ¥åŸºç¡€ç›®å½•çš„ inode æ˜¯å¦è¢«é”å®šï¼Œå¦‚æœæ²¡æœ‰è¢«é”å®šï¼Œå‘å‡ºè­¦å‘Š */ WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode)); /* è°ƒç”¨ lookup_one_common å‡½æ•°è¿›è¡ŒæŸ¥æ‰¾ */ err = lookup_one_common(&amp;nop_mnt_idmap, name, base, len, &amp;this); /* å¦‚æœæŸ¥æ‰¾è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¿”å›ä¸€ä¸ªåŒ…å«é”™è¯¯ç çš„æŒ‡é’ˆ */ if (err) return ERR_PTR(err); /* åœ¨ dcache ä¸­æŸ¥æ‰¾å¹¶è¿”å›ç›®å½•é¡¹ */ return lookup_dcache(&amp;this, base, 0);&#125;/* å¯¼å‡º try_lookup_one_len ç¬¦å·ï¼Œä½¿å¾—å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨è¿™ä¸ªå‡½æ•° */EXPORT_SYMBOL(try_lookup_one_len); 12345678910111213141516171819202122232425262728293031/*å®šä¹‰ä¸€ä¸ªå‡½æ•° lookup_one_lenï¼Œè¯¥å‡½æ•°ç”¨äºåœ¨åŸºç¡€ç›®å½•ä¸­æŸ¥æ‰¾å¹¶è¿”å›æŒ‡å®šåç§°çš„ç›®å½•é¡¹ã€‚å¦‚æœåœ¨ç›®å½•é¡¹ç¼“å­˜ä¸­æ‰¾ä¸åˆ°ï¼Œåˆ™ä¼šè°ƒç”¨__lookup_slowè¿›è¡Œæ…¢é€ŸæŸ¥æ‰¾ã€‚name: éœ€è¦æŸ¥æ‰¾çš„ç›®å½•é¡¹åç§°ï¼›base: åŸºç¡€ç›®å½•ï¼›len: åç§°çš„é•¿åº¦ã€‚æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„å¸®åŠ©å‡½æ•°ï¼Œä¸åº”è¢«é€šç”¨ä»£ç è°ƒç”¨ã€‚è°ƒç”¨è€…å¿…é¡»æŒæœ‰ base-&gt;i_mutexã€‚*/struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)&#123; struct dentry *dentry; struct qstr this; int err; /* æ£€æŸ¥åŸºç¡€ç›®å½•çš„ inode æ˜¯å¦è¢«é”å®šï¼Œå¦‚æœæ²¡æœ‰è¢«é”å®šï¼Œå‘å‡ºè­¦å‘Š */ WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode)); /* è°ƒç”¨ lookup_one_common å‡½æ•°è¿›è¡ŒæŸ¥æ‰¾ */ err = lookup_one_common(&amp;nop_mnt_idmap, name, base, len, &amp;this); /* å¦‚æœæŸ¥æ‰¾è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¿”å›ä¸€ä¸ªåŒ…å«é”™è¯¯ç çš„æŒ‡é’ˆ */ if (err) return ERR_PTR(err); /* åœ¨ dcache ä¸­æŸ¥æ‰¾å¹¶è¿”å›ç›®å½•é¡¹ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™è¿›è¡Œæ…¢é€ŸæŸ¥æ‰¾ */ dentry = lookup_dcache(&amp;this, base, 0); return dentry ? dentry : __lookup_slow(&amp;this, base, 0);&#125;/* å¯¼å‡º lookup_one_len ç¬¦å·ï¼Œä½¿å¾—å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨è¿™ä¸ªå‡½æ•° */EXPORT_SYMBOL(lookup_one_len); 1234567891011121314151617181920212223242526272829303132/*å®šä¹‰ä¸€ä¸ªå‡½æ•° lookup_oneï¼Œè¯¥å‡½æ•°ç”¨äºåœ¨åŸºç¡€ç›®å½•ä¸­æŸ¥æ‰¾å¹¶è¿”å›æŒ‡å®šåç§°çš„ç›®å½•é¡¹ã€‚å¦‚æœåœ¨ç›®å½•é¡¹ç¼“å­˜ä¸­æ‰¾ä¸åˆ°ï¼Œåˆ™ä¼šè°ƒç”¨__lookup_slowè¿›è¡Œæ…¢é€ŸæŸ¥æ‰¾ã€‚idmap: ç”¨æˆ·å’Œç»„çš„èº«ä»½æ˜ å°„ï¼›name: éœ€è¦æŸ¥æ‰¾çš„ç›®å½•é¡¹åç§°ï¼›base: åŸºç¡€ç›®å½•ï¼›len: åç§°çš„é•¿åº¦ã€‚æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„å¸®åŠ©å‡½æ•°ï¼Œä¸åº”è¢«é€šç”¨ä»£ç è°ƒç”¨ã€‚è°ƒç”¨è€…å¿…é¡»æŒæœ‰ base-&gt;i_mutexã€‚*/struct dentry *lookup_one(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct dentry *dentry; struct qstr this; int err; /* æ£€æŸ¥åŸºç¡€ç›®å½•çš„ inode æ˜¯å¦è¢«é”å®šï¼Œå¦‚æœæ²¡æœ‰è¢«é”å®šï¼Œå‘å‡ºè­¦å‘Š */ WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode)); /* è°ƒç”¨ lookup_one_common å‡½æ•°è¿›è¡ŒæŸ¥æ‰¾ */ err = lookup_one_common(idmap, name, base, len, &amp;this); /* å¦‚æœæŸ¥æ‰¾è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼Œè¿”å›ä¸€ä¸ªåŒ…å«é”™è¯¯ç çš„æŒ‡é’ˆ */ if (err) return ERR_PTR(err); /* åœ¨ dcache ä¸­æŸ¥æ‰¾å¹¶è¿”å›ç›®å½•é¡¹ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œåˆ™è¿›è¡Œæ…¢é€ŸæŸ¥æ‰¾ */ dentry = lookup_dcache(&amp;this, base, 0); return dentry ? dentry : __lookup_slow(&amp;this, base, 0);&#125;/* å¯¼å‡º lookup_one ç¬¦å·ï¼Œä½¿å¾—å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨è¿™ä¸ªå‡½æ•° */EXPORT_SYMBOL(lookup_one); 123456789101112131415161718192021222324252627282930/** * lookup_one_unlocked - æ–‡ä»¶ç³»ç»ŸåŠ©æ‰‹å‡½æ•°ï¼Œç”¨äºæŸ¥æ‰¾å•ä¸ªè·¯å¾„åç»„ä»¶ * @idmap: æ‰§è¡ŒæŸ¥æ‰¾çš„æŒ‚è½½ç‚¹çš„idmap * @name: è¦æŸ¥æ‰¾çš„è·¯å¾„åç»„ä»¶ * @base: è¦ä»ä¸­æŸ¥æ‰¾çš„åŸºç¡€ç›®å½• * @len: åº”è§£é‡Šä¸ºæœ€å¤§é•¿åº¦@len * * æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°åªæ˜¯æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨çš„åŠ©æ‰‹ï¼Œå¹¶ä¸åº”ç”±é€šç”¨ä»£ç è°ƒç”¨ã€‚ * * ä¸lookup_one_lenä¸åŒï¼Œè¿™ä¸ªå‡½æ•°åº”åœ¨æ²¡æœ‰å ç”¨çˆ¶ç›®å½•i_mutexçš„æƒ…å†µä¸‹è°ƒç”¨ï¼Œ * å¹¶ä¸”å¦‚æœéœ€è¦ï¼Œå®ƒä¼šè‡ªå·±è·å–i_mutexã€‚ */struct dentry *lookup_one_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct qstr this; int err; struct dentry *ret; //å®šä¹‰è¿”å›å€¼ err = lookup_one_common(idmap, name, base, len, &amp;this); //è°ƒç”¨lookup_one_commonå‡½æ•°æŸ¥æ‰¾ if (err) return ERR_PTR(err); //å¦‚æœå‡ºé”™ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ ret = lookup_dcache(&amp;this, base, 0); //åœ¨ç›®å½•ç¼“å­˜ä¸­æŸ¥æ‰¾ if (!ret) ret = lookup_slow(&amp;this, base, 0); //å¦‚æœåœ¨ç›®å½•ç¼“å­˜ä¸­æ‰¾ä¸åˆ°ï¼Œæ‰§è¡Œæ…¢æŸ¥è¯¢ return ret; //è¿”å›æŸ¥æ‰¾ç»“æœ&#125;EXPORT_SYMBOL(lookup_one_unlocked); //å¯¼å‡ºç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—è°ƒç”¨ 1234567891011121314151617181920212223242526272829/** * lookup_one_positive_unlocked - æ–‡ä»¶ç³»ç»ŸåŠ©æ‰‹å‡½æ•°ï¼Œç”¨äºæŸ¥æ‰¾å•ä¸ªè·¯å¾„åç»„ä»¶ * @idmap: æ‰§è¡ŒæŸ¥æ‰¾çš„æŒ‚è½½ç‚¹çš„idmap * @name: è¦æŸ¥æ‰¾çš„è·¯å¾„åç»„ä»¶ * @base: è¦ä»ä¸­æŸ¥æ‰¾çš„åŸºç¡€ç›®å½• * @len: åº”è§£é‡Šä¸ºæœ€å¤§é•¿åº¦@len * * å¦‚æœæ‰¾åˆ°çš„æ˜¯è´Ÿå‘é¡¹ï¼Œæ­¤åŠ©æ‰‹å‡½æ•°å°†è¿”å›ERR_PTR(-ENOENT)ã€‚åŠ©æ‰‹è¿”å›å·²çŸ¥çš„æ­£å‘é¡¹æˆ–ERR_PTR()ã€‚è¿™æ˜¯å¤§å¤šæ•°ç”¨æˆ·æƒ³è¦çš„ã€‚ * * æ³¨æ„ï¼Œå›ºå®šçš„è´Ÿå‘é¡¹å¯ä»¥åœ¨ä»»ä½•æ—¶å€™å˜æˆæ­£å‘é¡¹ï¼Œæ‰€ä»¥è°ƒç”¨lookup_one_unlocked()çš„å‡½æ•°éœ€è¦éå¸¸å°å¿ƒï¼› * å›ºå®šçš„æ­£å‘é¡¹&gt;d_inodeæ˜¯ç¨³å®šçš„ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°é¿å…äº†è¿™æ ·çš„é—®é¢˜ã€‚ * * æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°åªæ˜¯æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨çš„åŠ©æ‰‹ï¼Œå¹¶ä¸åº”ç”±é€šç”¨ä»£ç è°ƒç”¨ã€‚ * * åœ¨è°ƒç”¨è¿™ä¸ªåŠ©æ‰‹å‡½æ•°æ—¶ï¼Œä¸åº”è¯¥æŒæœ‰i_mutexã€‚ */struct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct dentry *ret = lookup_one_unlocked(idmap, name, base, len); //è°ƒç”¨lookup_one_unlockedå‡½æ•°æŸ¥æ‰¾ if (!IS_ERR(ret) &amp;&amp; d_flags_negative(smp_load_acquire(&amp;ret-&gt;d_flags))) &#123; //å¦‚æœæ‰¾åˆ°çš„æ˜¯è´Ÿå‘é¡¹ dput(ret); //å‡å°‘ç›®å½•é¡¹çš„å¼•ç”¨è®¡æ•° ret = ERR_PTR(-ENOENT); //è¿”å›æ–‡ä»¶æœªæ‰¾åˆ°çš„é”™è¯¯ &#125; return ret; //è¿”å›æŸ¥æ‰¾ç»“æœ&#125;EXPORT_SYMBOL(lookup_one_positive_unlocked); //å¯¼å‡ºç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—è°ƒç”¨ 123456789101112131415161718192021222324252627282930/** * lookup_one_unlocked - æ–‡ä»¶ç³»ç»ŸåŠ©æ‰‹å‡½æ•°ï¼Œç”¨äºæŸ¥æ‰¾å•ä¸ªè·¯å¾„åç»„ä»¶ * @idmap: æ‰§è¡ŒæŸ¥æ‰¾çš„æŒ‚è½½ç‚¹çš„idmap * @name: è¦æŸ¥æ‰¾çš„è·¯å¾„åç»„ä»¶ * @base: è¦ä»ä¸­æŸ¥æ‰¾çš„åŸºç¡€ç›®å½• * @len: åº”è§£é‡Šä¸ºæœ€å¤§é•¿åº¦@len * * æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°åªæ˜¯æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨çš„åŠ©æ‰‹ï¼Œå¹¶ä¸åº”ç”±é€šç”¨ä»£ç è°ƒç”¨ã€‚ * * ä¸lookup_one_lenä¸åŒï¼Œè¿™ä¸ªå‡½æ•°åº”åœ¨æ²¡æœ‰å ç”¨çˆ¶ç›®å½•i_mutexçš„æƒ…å†µä¸‹è°ƒç”¨ï¼Œ * å¹¶ä¸”å¦‚æœéœ€è¦ï¼Œå®ƒä¼šè‡ªå·±è·å–i_mutexã€‚ */struct dentry *lookup_one_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct qstr this; int err; struct dentry *ret; //å®šä¹‰è¿”å›å€¼ err = lookup_one_common(idmap, name, base, len, &amp;this); //è°ƒç”¨lookup_one_commonå‡½æ•°æŸ¥æ‰¾ if (err) return ERR_PTR(err); //å¦‚æœå‡ºé”™ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ ret = lookup_dcache(&amp;this, base, 0); //åœ¨ç›®å½•ç¼“å­˜ä¸­æŸ¥æ‰¾ if (!ret) ret = lookup_slow(&amp;this, base, 0); //å¦‚æœåœ¨ç›®å½•ç¼“å­˜ä¸­æ‰¾ä¸åˆ°ï¼Œæ‰§è¡Œæ…¢æŸ¥è¯¢ return ret; //è¿”å›æŸ¥æ‰¾ç»“æœ&#125;EXPORT_SYMBOL(lookup_one_unlocked); //å¯¼å‡ºç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—è°ƒç”¨ 1234567891011121314151617181920212223242526272829/** * lookup_one_positive_unlocked - æ–‡ä»¶ç³»ç»ŸåŠ©æ‰‹å‡½æ•°ï¼Œç”¨äºæŸ¥æ‰¾å•ä¸ªè·¯å¾„åç»„ä»¶ * @idmap: æ‰§è¡ŒæŸ¥æ‰¾çš„æŒ‚è½½ç‚¹çš„idmap * @name: è¦æŸ¥æ‰¾çš„è·¯å¾„åç»„ä»¶ * @base: è¦ä»ä¸­æŸ¥æ‰¾çš„åŸºç¡€ç›®å½• * @len: åº”è§£é‡Šä¸ºæœ€å¤§é•¿åº¦@len * * å¦‚æœæ‰¾åˆ°çš„æ˜¯è´Ÿå‘é¡¹ï¼Œæ­¤åŠ©æ‰‹å‡½æ•°å°†è¿”å›ERR_PTR(-ENOENT)ã€‚åŠ©æ‰‹è¿”å›å·²çŸ¥çš„æ­£å‘é¡¹æˆ–ERR_PTR()ã€‚è¿™æ˜¯å¤§å¤šæ•°ç”¨æˆ·æƒ³è¦çš„ã€‚ * * æ³¨æ„ï¼Œå›ºå®šçš„è´Ÿå‘é¡¹å¯ä»¥åœ¨ä»»ä½•æ—¶å€™å˜æˆæ­£å‘é¡¹ï¼Œæ‰€ä»¥è°ƒç”¨lookup_one_unlocked()çš„å‡½æ•°éœ€è¦éå¸¸å°å¿ƒï¼› * å›ºå®šçš„æ­£å‘é¡¹&gt;d_inodeæ˜¯ç¨³å®šçš„ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°é¿å…äº†è¿™æ ·çš„é—®é¢˜ã€‚ * * æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°åªæ˜¯æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨çš„åŠ©æ‰‹ï¼Œå¹¶ä¸åº”ç”±é€šç”¨ä»£ç è°ƒç”¨ã€‚ * * åœ¨è°ƒç”¨è¿™ä¸ªåŠ©æ‰‹å‡½æ•°æ—¶ï¼Œä¸åº”è¯¥æŒæœ‰i_mutexã€‚ */struct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct dentry *ret = lookup_one_unlocked(idmap, name, base, len); //è°ƒç”¨lookup_one_unlockedå‡½æ•°æŸ¥æ‰¾ if (!IS_ERR(ret) &amp;&amp; d_flags_negative(smp_load_acquire(&amp;ret-&gt;d_flags))) &#123; //å¦‚æœæ‰¾åˆ°çš„æ˜¯è´Ÿå‘é¡¹ dput(ret); //å‡å°‘ç›®å½•é¡¹çš„å¼•ç”¨è®¡æ•° ret = ERR_PTR(-ENOENT); //è¿”å›æ–‡ä»¶æœªæ‰¾åˆ°çš„é”™è¯¯ &#125; return ret; //è¿”å›æŸ¥æ‰¾ç»“æœ&#125;EXPORT_SYMBOL(lookup_one_positive_unlocked); //å¯¼å‡ºç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—è°ƒç”¨ 1234567891011121314151617/** * lookup_one_len_unlocked - æ–‡ä»¶ç³»ç»ŸåŠ©æ‰‹å‡½æ•°ï¼Œç”¨äºæŸ¥æ‰¾å•ä¸ªè·¯å¾„åç»„ä»¶ * @name: è¦æŸ¥æ‰¾çš„è·¯å¾„åç»„ä»¶ * @base: è¦ä»ä¸­æŸ¥æ‰¾çš„åŸºç¡€ç›®å½• * @len: åº”è§£é‡Šä¸ºæœ€å¤§é•¿åº¦@len * * æ³¨æ„ï¼Œè¿™ä¸ªå‡½æ•°åªæ˜¯æ–‡ä»¶ç³»ç»Ÿä½¿ç”¨çš„åŠ©æ‰‹ï¼Œå¹¶ä¸åº”ç”±é€šç”¨ä»£ç è°ƒç”¨ã€‚ * * ä¸lookup_one_lenä¸åŒï¼Œè¿™ä¸ªå‡½æ•°åº”åœ¨æ²¡æœ‰å ç”¨çˆ¶ç›®å½•i_mutexçš„æƒ…å†µä¸‹è°ƒç”¨ï¼Œ * å¹¶ä¸”å¦‚æœéœ€è¦ï¼Œå®ƒä¼šè‡ªå·±è·å–i_mutexã€‚ */struct dentry *lookup_one_len_unlocked(const char *name, struct dentry *base, int len)&#123; return lookup_one_unlocked(&amp;nop_mnt_idmap, name, base, len); //è°ƒç”¨lookup_one_unlockedå‡½æ•°æŸ¥æ‰¾&#125;EXPORT_SYMBOL(lookup_one_len_unlocked); //å¯¼å‡ºç¬¦å· 12345678910111213/* * ä¸lookup_one_len_unlocked()ç±»ä¼¼ï¼Œåªæ˜¯åœ¨å¦å®šçš„æƒ…å†µä¸‹è¿”å›ERR_PTR(-ENOENT)ã€‚ * è¿”å›å·²çŸ¥çš„æ­£æ•°æˆ–ERR_PTR()ï¼›è¿™æ˜¯å¤§å¤šæ•°ç”¨æˆ·æƒ³è¦çš„ã€‚æ³¨æ„ï¼Œå¸¦æœ‰è§£é”çˆ¶é¡¹çš„å›ºå®šè´Ÿæ•° * å¯ä»¥åœ¨ä»»ä½•æ—¶å€™å˜ä¸ºæ­£æ•°ï¼Œæ‰€ä»¥lookup_one_len_unlocked()çš„è°ƒç”¨è€…éœ€è¦éå¸¸å°å¿ƒï¼› * å›ºå®šæ­£æ•°çš„-&gt;d_inodeæ˜¯ç¨³å®šçš„ï¼Œæ‰€ä»¥è¿™ä¸ªå‡½æ•°é¿å…äº†è¿™æ ·çš„é—®é¢˜ã€‚ */struct dentry *lookup_positive_unlocked(const char *name, struct dentry *base, int len)&#123; // æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œï¼Œè¿”å›ç›®å½•é¡¹æˆ–é”™è¯¯æŒ‡é’ˆã€‚ return lookup_one_positive_unlocked(&amp;nop_mnt_idmap, name, base, len);&#125;EXPORT_SYMBOL(lookup_positive_unlocked); // å¯¼å‡ºç¬¦å·ï¼Œä½¿å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨æ­¤å‡½æ•°ã€‚ 123456789101112131415161718192021222324#ifdef CONFIG_UNIX98_PTYSint path_pts(struct path *path)&#123; // åœ¨ä¸è¾“å…¥è·¯å¾„ç›¸åŒçš„ç›®å½•ä¸­æ‰¾åˆ°æŒ‚è½½åœ¨&quot;pts&quot;ä¸Šçš„ä¸œè¥¿ã€‚ struct dentry *parent = dget_parent(path-&gt;dentry); // è·å–çˆ¶ç›®å½•é¡¹ã€‚ struct dentry *child; struct qstr this = QSTR_INIT(&quot;pts&quot;, 3); // åˆå§‹åŒ–åä¸º&quot;pts&quot;çš„qstrç»“æ„ä½“ã€‚ if (unlikely(!path_connected(path-&gt;mnt, parent))) &#123; // å¦‚æœè·¯å¾„æœªè¿æ¥ã€‚ dput(parent); // é‡Šæ”¾ç›®å½•é¡¹ã€‚ return -ENOENT; // è¿”å›é”™è¯¯ã€‚ &#125; dput(path-&gt;dentry); // é‡Šæ”¾ç›®å½•é¡¹ã€‚ path-&gt;dentry = parent; // å°†çˆ¶ç›®å½•é¡¹èµ‹ç»™è·¯å¾„çš„dentryã€‚ child = d_hash_and_lookup(parent, &amp;this); // åœ¨çˆ¶ç›®å½•é¡¹ä¸­æŸ¥æ‰¾å¹¶è¿”å›å­ç›®å½•é¡¹ã€‚ if (!child) // å¦‚æœæ‰¾ä¸åˆ°å­ç›®å½•é¡¹ã€‚ return -ENOENT; // è¿”å›é”™è¯¯ã€‚ path-&gt;dentry = child; // å°†æŸ¥æ‰¾åˆ°çš„å­ç›®å½•é¡¹èµ‹ç»™è·¯å¾„çš„dentryã€‚ dput(parent); // é‡Šæ”¾çˆ¶ç›®å½•é¡¹ã€‚ follow_down(path, 0); // è·Ÿè¸ªè·¯å¾„ã€‚ return 0;&#125;#endif 12345678910111213int user_path_at_empty(int dfd, const char __user *name, unsigned flags, struct path *path, int *empty)&#123; // è·å–ç”¨æˆ·ç©ºé—´çš„æ–‡ä»¶åã€‚ struct filename *filename = getname_flags(name, flags, empty); // æŸ¥æ‰¾æ–‡ä»¶åï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨pathä¸­ã€‚ int ret = filename_lookup(dfd, filename, flags, path, NULL); // é‡Šæ”¾filenameçš„å†…å­˜ã€‚ putname(filename); return ret; // è¿”å›ç»“æœã€‚&#125;EXPORT_SYMBOL(user_path_at_empty); // å¯¼å‡ºç¬¦å·ï¼Œä½¿å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨æ­¤å‡½æ•°ã€‚ 12345678910111213141516int __check_sticky(struct mnt_idmap *idmap, struct inode *dir, struct inode *inode)&#123; // è·å–å½“å‰çš„æ–‡ä»¶ç³»ç»Ÿç”¨æˆ·IDã€‚ kuid_t fsuid = current_fsuid(); // æ£€æŸ¥inodeçš„ç”¨æˆ·IDæ˜¯å¦ä¸å½“å‰çš„æ–‡ä»¶ç³»ç»Ÿç”¨æˆ·IDç›¸ç­‰ã€‚ if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), fsuid)) return 0; // æ£€æŸ¥dirçš„ç”¨æˆ·IDæ˜¯å¦ä¸å½“å‰çš„æ–‡ä»¶ç³»ç»Ÿç”¨æˆ·IDç›¸ç­‰ã€‚ if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, dir), fsuid)) return 0; // æ£€æŸ¥æ˜¯å¦å…·æœ‰å¯¹inodeè¿›è¡Œæ“ä½œçš„æƒé™ã€‚ return !capable_wrt_inode_uidgid(idmap, inode, CAP_FOWNER);&#125;EXPORT_SYMBOL(__check_sticky); // å¯¼å‡ºç¬¦å·ï¼Œä½¿å…¶ä»–æ¨¡å—å¯ä»¥ä½¿ç”¨æ­¤å‡½æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦å¯ä»¥ä»ç›®å½•diråˆ é™¤é“¾æ¥victimï¼Œæ£€æŸ¥victimçš„ç±»å‹æ˜¯å¦æ­£ç¡®ã€‚ * 1. å¦‚æœdiræ˜¯åªè¯»çš„ï¼Œæˆ‘ä»¬ä¸èƒ½åšè¿™ä¸ªï¼ˆåœ¨permission()ä¸­å·²ç»å®Œæˆï¼‰ * 2. æˆ‘ä»¬åº”è¯¥å¯¹diræœ‰å†™å’Œæ‰§è¡Œæƒé™ * 3. æˆ‘ä»¬ä¸èƒ½ä»åªè¿½åŠ çš„dirä¸­åˆ é™¤ä»»ä½•ä¸œè¥¿ * 4. æˆ‘ä»¬ä¸èƒ½å¯¹ä¸å¯æ”¹å˜çš„diråšä»»ä½•äº‹æƒ…ï¼ˆåœ¨permission()ä¸­å·²ç»å®Œæˆï¼‰ * 5. å¦‚æœdirçš„ç²˜æ»ä½è¢«è®¾ç½®ï¼Œæˆ‘ä»¬åº”è¯¥ * a. æ˜¯dirçš„æ‰€æœ‰è€…ï¼Œæˆ– * b. æ˜¯victimçš„æ‰€æœ‰è€…ï¼Œæˆ– * c. æœ‰CAP_FOWNERèƒ½åŠ› * 6. å¦‚æœvictimæ˜¯åªè¿½åŠ çš„æˆ–ä¸å¯å˜çš„ï¼Œæˆ‘ä»¬ä¸èƒ½åšä»»ä½•å…³äºæŒ‡å‘å®ƒçš„é“¾æ¥çš„äº‹æƒ… * 7. å¦‚æœvictimæœ‰æœªçŸ¥çš„uidæˆ–gidï¼Œæˆ‘ä»¬ä¸èƒ½æ›´æ”¹inodeã€‚ * 8. å¦‚æœæˆ‘ä»¬è¢«è¦æ±‚åˆ é™¤ä¸€ä¸ªç›®å½•ï¼Œvictimä¸æ˜¯ä¸€ä¸ª - ENOTDIRã€‚ * 9. å¦‚æœæˆ‘ä»¬è¢«è¦æ±‚åˆ é™¤ä¸€ä¸ªéç›®å½•ï¼Œvictimæ˜¯ä¸€ä¸ª - EISDIRã€‚ * 10. æˆ‘ä»¬ä¸èƒ½åˆ é™¤æ ¹ç›®å½•æˆ–æŒ‚è½½ç‚¹ã€‚ * 11. æˆ‘ä»¬ä¸å…è®¸åˆ é™¤NFS sillyrenamedæ–‡ä»¶ï¼›è¿™æ˜¯ç”±nfs_async_unlink()å¤„ç†çš„ã€‚ */static int may_delete(struct mnt_idmap *idmap, struct inode *dir, struct dentry *victim, bool isdir)&#123; struct inode *inode = d_backing_inode(victim); // è·å–victimçš„inodeã€‚ int error; if (d_is_negative(victim)) // å¦‚æœvictimæ˜¯è´Ÿçš„ã€‚ return -ENOENT; // è¿”å›é”™è¯¯ã€‚ BUG_ON(!inode); // å¦‚æœinodeä¸å­˜åœ¨ï¼ŒæŠ¥é”™ã€‚ BUG_ON(victim-&gt;d_parent-&gt;d_inode != dir); // å¦‚æœvictimçš„çˆ¶inodeä¸æ˜¯dirï¼ŒæŠ¥é”™ã€‚ // å½“uidæˆ–gidæ— æ•ˆæ—¶ï¼ŒInodeå›å†™ä¸æ˜¯å®‰å…¨çš„ã€‚ if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) || !vfsgid_valid(i_gid_into_vfsgid(idmap, inode))) return -EOVERFLOW; // è¿”å›é”™è¯¯ã€‚ audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE); // å®¡è®¡æ—¥å¿—ã€‚ // æ£€æŸ¥å¯¹dirçš„æƒé™ã€‚ error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC); if (error) // å¦‚æœæœ‰é”™è¯¯ã€‚ return error; // è¿”å›é”™è¯¯ã€‚ if (IS_APPEND(dir)) // å¦‚æœdiræ˜¯åªè¿½åŠ çš„ã€‚ return -EPERM; // è¿”å›é”™è¯¯ã€‚ // æ£€æŸ¥æ˜¯å¦æ»¡è¶³åˆ é™¤çš„æ¡ä»¶ã€‚ if (check_sticky(idmap, dir, inode) || IS_APPEND(inode) || IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) || HAS_UNMAPPED_ID(idmap, inode)) return -EPERM; // è¿”å›é”™è¯¯ã€‚ if (isdir) &#123; // å¦‚æœæ˜¯ç›®å½•ã€‚ if (!d_is_dir(victim)) // å¦‚æœvictimä¸æ˜¯ç›®å½•ã€‚ return -ENOTDIR; // è¿”å›é”™è¯¯ã€‚ if (IS_ROOT(victim)) // å¦‚æœvictimæ˜¯æ ¹ç›®å½•ã€‚ return -EBUSY; // è¿”å›é”™è¯¯ã€‚ &#125; else if (d_is_dir(victim)) // å¦‚æœvictimæ˜¯ç›®å½•ã€‚ return -EISDIR; // è¿”å›é”™è¯¯ã€‚ if (IS_DEADDIR(dir)) // å¦‚æœdiræ˜¯æ­»ç›®å½•ã€‚ return -ENOENT; // è¿”å›é”™è¯¯ã€‚ if (victim-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) // å¦‚æœvictimæ˜¯NFSé‡å‘½åçš„æ–‡ä»¶ã€‚ return -EBUSY; // è¿”å›é”™è¯¯ã€‚ return 0; // è¿”å›æˆåŠŸã€‚&#125; 12345678910111213141516171819202122/* æ£€æŸ¥æˆ‘ä»¬æ˜¯å¦å¯ä»¥åœ¨ç›®å½•dirä¸­åˆ›å»ºä¸€ä¸ªå¸¦æœ‰dentryå­é¡¹çš„å¯¹è±¡ã€‚ * 1. å¦‚æœchildå·²ç»å­˜åœ¨ï¼Œæˆ‘ä»¬ä¸èƒ½åšè¿™ä¸ªï¼ˆopenå¯¹è¿™ç§æƒ…å†µæœ‰ç‰¹æ®Šå¤„ç†ï¼Œ * ä½†å› ä¸ºæˆ‘ä»¬æ˜¯å†…è”çš„ï¼Œæ‰€ä»¥æ²¡å…³ç³»ï¼‰ * 2. å¦‚æœdiræ˜¯åªè¯»çš„ï¼Œæˆ‘ä»¬ä¸èƒ½åšè¿™ä¸ªï¼ˆåœ¨permission()ä¸­å·²ç»å®Œæˆï¼‰ * 3. å¦‚æœæ–‡ä»¶ç³»ç»Ÿä¸èƒ½è¡¨ç¤ºfsuidæˆ–fsgidï¼Œæˆ‘ä»¬ä¸èƒ½åšè¿™ä¸ªã€‚ * 4. æˆ‘ä»¬åº”è¯¥å¯¹diræœ‰å†™å’Œæ‰§è¡Œæƒé™ * 5. å¦‚æœdiræ˜¯ä¸å¯æ”¹å˜çš„æˆ‘ä»¬ä¸èƒ½åšè¿™ä¸ªï¼ˆåœ¨permission()ä¸­å·²ç»å®Œæˆï¼‰ */static inline int may_create(struct mnt_idmap *idmap, struct inode *dir, struct dentry *child)&#123; audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE); // å®¡è®¡æ—¥å¿—ã€‚ if (child-&gt;d_inode) // å¦‚æœchildå·²ç»å­˜åœ¨ã€‚ return -EEXIST; // è¿”å›é”™è¯¯ã€‚ if (IS_DEADDIR(dir)) // å¦‚æœdiræ˜¯æ­»ç›®å½•ã€‚ return -ENOENT; // è¿”å›é”™è¯¯ã€‚ if (!fsuidgid_has_mapping(dir-&gt;i_sb, idmap)) // å¦‚æœæ–‡ä»¶ç³»ç»Ÿä¸èƒ½è¡¨ç¤ºfsuidæˆ–fsgidã€‚ return -EOVERFLOW; // è¿”å›é”™è¯¯ã€‚ // æ£€æŸ¥å¯¹dirçš„æƒé™ã€‚ return inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);&#125; 1234567891011121314151617181920212223242526272829303132333435363738/* * p1å’Œp2åº”å½“æ˜¯åŒä¸€æ–‡ä»¶ç³»ç»Ÿä¸Šçš„ç›®å½•ã€‚ */struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)&#123; struct dentry *p; // å¦‚æœp1å’Œp2æ˜¯åŒä¸€ä¸ªç›®å½•ï¼Œåªéœ€è¦é”å®šè¯¥ç›®å½•å³å¯ã€‚ if (p1 == p2) &#123; inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT); return NULL; &#125; // å¯¹æ–‡ä»¶ç³»ç»Ÿçš„é‡å‘½åæ“ä½œè¿›è¡Œäº’æ–¥é”ä¿æŠ¤ï¼Œé˜²æ­¢å¹¶å‘çš„é‡å‘½åæ“ä½œã€‚ mutex_lock(&amp;p1-&gt;d_sb-&gt;s_vfs_rename_mutex); // å¦‚æœp2æ˜¯p1çš„ç¥–å…ˆç›®å½•ï¼Œå…ˆé”å®šp2ï¼Œå†é”å®šp1ã€‚ p = d_ancestor(p2, p1); if (p) &#123; inode_lock_nested(p2-&gt;d_inode, I_MUTEX_PARENT); inode_lock_nested(p1-&gt;d_inode, I_MUTEX_CHILD); return p; &#125; // å¦‚æœp1æ˜¯p2çš„ç¥–å…ˆç›®å½•ï¼Œå…ˆé”å®šp1ï¼Œå†é”å®šp2ã€‚ p = d_ancestor(p1, p2); if (p) &#123; inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT); inode_lock_nested(p2-&gt;d_inode, I_MUTEX_CHILD); return p; &#125; // å¦‚æœp1å’Œp2éƒ½ä¸æ˜¯å¯¹æ–¹çš„ç¥–å…ˆç›®å½•ï¼Œåˆ†åˆ«é”å®šp1å’Œp2ã€‚ inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT); inode_lock_nested(p2-&gt;d_inode, I_MUTEX_PARENT2); return NULL;&#125;EXPORT_SYMBOL(lock_rename); 123456789101112// è§£é”é‡å‘½åæ“ä½œçš„å‡½æ•°ï¼Œä¸lock_renameé…å¯¹ä½¿ç”¨ã€‚void unlock_rename(struct dentry *p1, struct dentry *p2)&#123; // è§£é”p1çš„inode inode_unlock(p1-&gt;d_inode); // å¦‚æœp1å’Œp2ä¸æ˜¯åŒä¸€ä¸ªç›®å½•ï¼Œè§£é”p2çš„inodeï¼Œå¹¶è§£é”é‡å‘½åæ“ä½œçš„äº’æ–¥é”ã€‚ if (p1 != p2) &#123; inode_unlock(p2-&gt;d_inode); mutex_unlock(&amp;p1-&gt;d_sb-&gt;s_vfs_rename_mutex); &#125;&#125;EXPORT_SYMBOL(unlock_rename); 1234567891011121314151617/** * mode_strip_umask - å¤„ç†vfsä¸­çš„umaskå‰¥ç¦» * @dir: æ–°inodeçš„çˆ¶ç›®å½• * @mode: åœ¨@dirä¸­åˆ›å»ºçš„æ–°inodeçš„æ¨¡å¼ * * Umaskå‰¥ç¦»ä¾èµ–äºæ–‡ä»¶ç³»ç»Ÿæ˜¯å¦æ”¯æŒPOSIX ACLsã€‚å¦‚æœæ–‡ä»¶ç³»ç»Ÿä¸æ”¯æŒï¼Œumaskå‰¥ç¦»ç›´æ¥åœ¨è¿™é‡Œè¿›è¡Œã€‚ * å¦‚æœæ–‡ä»¶ç³»ç»Ÿæ”¯æŒPOSIX ACLsï¼Œumaskå‰¥ç¦»ä¼šæ¨è¿Ÿåˆ°æ–‡ä»¶ç³»ç»Ÿè°ƒç”¨posix_acl_create()æ—¶è¿›è¡Œã€‚ * * è¿”å›: mode */static inline umode_t mode_strip_umask(const struct inode *dir, umode_t mode)&#123; // å¦‚æœç›®å½•ä¸æ”¯æŒPOSIX ACLsï¼Œç›´æ¥å°†å½“å‰çš„umaskä¸modeè¿›è¡Œä½ä¸è¿ç®—ï¼Œè·å–å‰¥ç¦»umaskåçš„modeã€‚ if (!IS_POSIXACL(dir)) mode &amp;= ~current_umask(); return mode;&#125; 123456789101112131415161718192021222324252627282930313233/*- vfs_prepare_mode - å‡†å¤‡ç”¨äºæ–°ç´¢å¼•èŠ‚ç‚¹çš„æ¨¡å¼- @idmap: ç´¢å¼•èŠ‚ç‚¹æ‰€å±çš„æŒ‚è½½ç‚¹çš„idmap- @dir: æ–°ç´¢å¼•èŠ‚ç‚¹çš„çˆ¶ç›®å½•- @mode: æ–°ç´¢å¼•èŠ‚ç‚¹çš„æ¨¡å¼- @mask_perms: vfs å…è®¸çš„æƒé™æ©ç - @type: è¦åˆ›å»ºçš„æ–‡ä»¶ç±»å‹-- æ­¤è¾…åŠ©å‡½æ•°å¯¹å°†è¦åˆ›å»ºçš„æ–°å¯¹è±¡çš„ @mode è¿›è¡Œäº†æ•´åˆå¹¶å¼ºåˆ¶æ‰§è¡Œ vfs çš„é™åˆ¶ã€‚-- Umask çš„å‰¥ç¦»å–å†³äºæ–‡ä»¶ç³»ç»Ÿæ˜¯å¦æ”¯æŒ POSIX ACLï¼ˆå‚è§å†…æ ¸æ–‡æ¡£ä¸­çš„ mode_strip_umask()ï¼‰ã€‚- åœ¨ setgid å‰¥ç¦»ä¹‹åè¿›è¡Œ umask å‰¥ç¦»å…è®¸åœ¨é POSIX ACL å’Œæ”¯æŒ POSIX ACL çš„æ–‡ä»¶ç³»ç»Ÿä¸Šé‡‡ç”¨ç›¸åŒçš„é¡ºåºã€‚-- éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœåˆ›å»ºçš„æ˜¯ç›®å½•ï¼Œåˆ™ @type ç›®å‰å¯ä»¥ä¸º0ã€‚æ–‡ä»¶ç³»ç»Ÿå•ç‹¬å¼•å‘è¯¥æ ‡å¿—ï¼Œ- æˆ‘ä»¬éœ€è¦åœ¨å¼ºåˆ¶æ‰§è¡Œéé›¶ç±»å‹ä¹‹å‰æ£€æŸ¥æ¯ä¸ªæ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å¯ä»¥æ¥æ”¶æ¥è‡ª vfs çš„ S_IFDIRã€‚-- è¿”å›ï¼šå°†ä¼ é€’ç»™æ–‡ä»¶ç³»ç»Ÿçš„æ¨¡å¼*/ static inline umode_t vfs_prepare_mode(struct mnt_idmap idmap, const struct inode dir, umode_t mode, umode_t mask_perms, umode_t type) &#123; mode = mode_strip_sgid(idmap, dir, mode); // å‰¥ç¦» SGID ä½ mode = mode_strip_umask(dir, mode); // æ ¹æ® umask å‰¥ç¦»æƒé™ä½ /* - åœ¨è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿä¹‹å‰ï¼Œåº”ç”¨ vfs è§„å®šçš„å…è®¸çš„æƒé™æ©ç ï¼Œå¹¶è®¾ç½®è¦åˆ›å»ºçš„æ–‡ä»¶ç±»å‹ã€‚ */ mode &amp;= (mask_perms &amp; ~S_IFMT); mode |= (type &amp; S_IFMT); return mode; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/**vfs_create - åˆ›å»ºæ–°æ–‡ä»¶@idmap: æŒ‚è½½ç‚¹ä¸Šæ‰¾åˆ°çš„ç´¢å¼•èŠ‚ç‚¹çš„idmap@dir: @dentryçš„ç´¢å¼•èŠ‚ç‚¹@dentry: åŸºæœ¬ç›®å½•çš„dentryæŒ‡é’ˆ@mode: æ–°æ–‡ä»¶çš„æ¨¡å¼@want_excl: æ–‡ä»¶æ˜¯å¦å¿…é¡»ä¸å­˜åœ¨åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ã€‚å¦‚æœé€šè¿‡idæ˜ å°„çš„æŒ‚è½½ç‚¹æ‰¾åˆ°äº†ç´¢å¼•èŠ‚ç‚¹ï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚æ­¤å‡½æ•°å°†åœ¨æ£€æŸ¥æƒé™ä¹‹å‰æ ¹æ®@idmapæ˜ å°„ç´¢å¼•èŠ‚ç‚¹ã€‚å¦‚æœæ˜¯éidæ˜ å°„çš„æŒ‚è½½ç‚¹ï¼Œæˆ–è€…éœ€è¦å¯¹åŸå§‹ç´¢å¼•èŠ‚ç‚¹æ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’@nop_mnt_idmapã€‚*/int vfs_create(struct mnt_idmap *idmap, struct inode *dir,struct dentry *dentry, umode_t mode, bool want_excl)&#123;int error;// æ£€æŸ¥åˆ›å»ºæ–‡ä»¶çš„æƒé™error = may_create(idmap, dir, dentry);if (error)return error;if (!dir-&gt;i_op-&gt;create)return -EACCES; /* åº”è¯¥æ˜¯ENOSYSå—ï¼Ÿ */// å‡†å¤‡æ–‡ä»¶çš„æ¨¡å¼mode = vfs_prepare_mode(idmap, dir, mode, S_IALLUGO, S_IFREG);// è°ƒç”¨å®‰å…¨æ¨¡å—çš„inode_createå‡½æ•°è¿›è¡Œå®‰å…¨æ£€æŸ¥error = security_inode_create(dir, dentry, mode);if (error)return error;// è°ƒç”¨inodeæ“ä½œçš„createå‡½æ•°åˆ›å»ºæ–°æ–‡ä»¶error = dir-&gt;i_op-&gt;create(idmap, dir, dentry, mode, want_excl);if (!error)fsnotify_create(dir, dentry);return error;&#125;EXPORT_SYMBOL(vfs_create); 1234567891011121314151617181920212223242526272829303132333435/**vfs_mkobj - åˆ›å»ºæ–°å¯¹è±¡@dentry: dentryæŒ‡é’ˆ@mode: æ–°å¯¹è±¡çš„æ¨¡å¼@f: å›è°ƒå‡½æ•°æŒ‡é’ˆï¼Œç”¨äºåˆ›å»ºæ–°å¯¹è±¡@arg: å›è°ƒå‡½æ•°çš„å‚æ•°åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡ã€‚æ£€æŸ¥æƒé™å¹¶è°ƒç”¨å›è°ƒå‡½æ•°åˆ›å»ºæ–°å¯¹è±¡ã€‚*/int vfs_mkobj(struct dentry *dentry, umode_t mode,int (*f)(struct dentry *, umode_t, void *),void *arg)&#123;struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;int error = may_create(&amp;nop_mnt_idmap, dir, dentry);if (error)return error;mode &amp;= S_IALLUGO;mode |= S_IFREG;// è°ƒç”¨å®‰å…¨æ¨¡å—çš„inode_createå‡½æ•°è¿›è¡Œå®‰å…¨æ£€æŸ¥error = security_inode_create(dir, dentry, mode);if (error)return error;// è°ƒç”¨å›è°ƒå‡½æ•°åˆ›å»ºæ–°å¯¹è±¡error = f(dentry, mode, arg);if (!error)fsnotify_create(dir, dentry);return error;&#125;EXPORT_SYMBOL(vfs_mkobj); 1234567891011/*may_open_dev - æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰“å¼€è®¾å¤‡æ–‡ä»¶@path: æ–‡ä»¶è·¯å¾„æ£€æŸ¥è·¯å¾„æ˜¯å¦å…è®¸æ‰“å¼€è®¾å¤‡æ–‡ä»¶ã€‚è¿”å›å€¼ä¸ºtrueè¡¨ç¤ºå¯ä»¥æ‰“å¼€ï¼Œå¦åˆ™ä¸ºfalseã€‚*/bool may_open_dev(const struct path *path)&#123;return !(path-&gt;mnt-&gt;mnt_flags &amp; MNT_NODEV) &amp;&amp;!(path-&gt;mnt-&gt;mnt_sb-&gt;s_iflags &amp; SB_I_NODEV);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static int may_open(struct mnt_idmap \\*idmap, const struct path \\*path,int acc_mode, int flag)&#123;struct dentry \\*dentry = path-&gt;dentry;struct inode \\*inode = dentry-&gt;d_inode;int error;if (!inode) return -ENOENT;// æ£€æŸ¥ç´¢å¼•èŠ‚ç‚¹çš„ç±»å‹switch (inode-&gt;i_mode &amp; S_IFMT) &#123;case S_IFLNK: return -ELOOP; // ç¬¦å·é“¾æ¥æ–‡ä»¶æ— æ³•æ‰“å¼€case S_IFDIR: if (acc_mode &amp; MAY_WRITE) return -EISDIR; // ç›®å½•ä¸å¯å†™ if (acc_mode &amp; MAY_EXEC) return -EACCES; // ç›®å½•ä¸å¯æ‰§è¡Œ break;case S_IFBLK:case S_IFCHR: if (!may_open_dev(path)) return -EACCES; // æ— æƒé™æ‰“å¼€è®¾å¤‡æ–‡ä»¶ fallthrough;case S_IFIFO:case S_IFSOCK: if (acc_mode &amp; MAY_EXEC) return -EACCES; // æ–‡ä»¶ä¸å¯æ‰§è¡Œ flag &amp;= ~O_TRUNC; // æ¸…é™¤ O_TRUNC æ ‡å¿—ä½ break;case S_IFREG: if ((acc_mode &amp; MAY_EXEC) &amp;&amp; path_noexec(path)) return -EACCES; // æ–‡ä»¶ä¸å¯æ‰§è¡Œ break;&#125;// æ£€æŸ¥ç´¢å¼•èŠ‚ç‚¹çš„æƒé™error = inode_permission(idmap, inode, MAY_OPEN | acc_mode);if (error) return error;/*- An append-only file must be opened in append mode for writing.- é™„åŠ æ¨¡å¼åªèƒ½ç”¨äºå†™å…¥é™„åŠ æ¨¡å¼çš„æ–‡ä»¶ã€‚ */ if (IS_APPEND(inode)) &#123; if ((flag &amp; O_ACCMODE) != O_RDONLY &amp;&amp; !(flag &amp; O_APPEND)) return -EPERM; // æ— æƒé™æ‰“å¼€é™„åŠ æ¨¡å¼çš„æ–‡ä»¶ if (flag &amp; O_TRUNC) return -EPERM; // æ— æƒé™æˆªæ–­æ–‡ä»¶ &#125;/* O_NOATIME can only be set by the owner or superuser */if (flag &amp; O_NOATIME &amp;&amp; !inode_owner_or_capable(idmap, inode)) return -EPERM; // æ— æƒé™è®¾ç½® O_NOATIME æ ‡å¿—ä½return 0;&#125; 1234567891011121314151617181920212223static int handle_truncate(struct mnt_idmap *idmap, struct file *filp)&#123; // è·å–æ–‡ä»¶è·¯å¾„ const struct path *path = &amp;filp-&gt;f_path; // è·å–ç´¢å¼•èŠ‚ç‚¹ struct inode *inode = path-&gt;dentry-&gt;d_inode; // è·å–å†™å…¥è®¿é—®æƒé™ int error = get_write_access(inode); if (error) return error; // è°ƒç”¨å®‰å…¨æ¨¡å—çš„æ–‡ä»¶æˆªæ–­å‡½æ•°è¿›è¡Œå®‰å…¨æ£€æŸ¥ error = security_file_truncate(filp); if (!error) &#123; // æ‰§è¡Œæˆªæ–­æ“ä½œ error = do_truncate(idmap, path-&gt;dentry, 0, ATTR_MTIME|ATTR_CTIME|ATTR_OPEN, filp); &#125; // é‡Šæ”¾å†™å…¥è®¿é—®æƒé™ put_write_access(inode); return error;&#125; 1234567static inline int open_to_namei_flags(int flag)&#123; // å°† O_ACCMODE ä¸º 3 çš„æƒ…å†µè½¬æ¢ä¸º 2 if ((flag &amp; O_ACCMODE) == 3) flag--; return flag;&#125; 12345678910111213141516171819202122static int may_o_create(struct mnt_idmap *idmap, const struct path *dir, struct dentry *dentry, umode_t mode)&#123; // è°ƒç”¨å®‰å…¨æ¨¡å—çš„è·¯å¾„åˆ›å»ºèŠ‚ç‚¹å‡½æ•°è¿›è¡Œå®‰å…¨æ£€æŸ¥ int error = security_path_mknod(dir, dentry, mode, 0); if (error) return error; // æ£€æŸ¥ç›®å½•æ‰€åœ¨çš„è¶…çº§å—æ˜¯å¦å…·æœ‰ç”¨æˆ·å’Œç»„IDçš„æ˜ å°„ if (!fsuidgid_has_mapping(dir-&gt;dentry-&gt;d_sb, idmap)) return -EOVERFLOW; // æ£€æŸ¥ç›®å½•ç´¢å¼•èŠ‚ç‚¹çš„æƒé™ error = inode_permission(idmap, dir-&gt;dentry-&gt;d_inode, MAY_WRITE | MAY_EXEC); if (error) return error; // è°ƒç”¨å®‰å…¨æ¨¡å—çš„ç´¢å¼•èŠ‚ç‚¹åˆ›å»ºå‡½æ•°è¿›è¡Œå®‰å…¨æ£€æŸ¥ return security_inode_create(dir-&gt;dentry-&gt;d_inode, dentry, mode);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * å°è¯•åŸå­æ€§åœ°æŸ¥æ‰¾ã€åˆ›å»ºå¹¶æ‰“å¼€ä¸€ä¸ªè´Ÿçš„dentryï¼ˆç›®å½•é¡¹ï¼‰å¯¹åº”çš„æ–‡ä»¶ã€‚ * * å¦‚æœæˆåŠŸï¼Œè¿”å›0ã€‚æ–‡ä»¶å°†è¢«åˆ›å»ºå¹¶é€šè¿‡æ–‡ä»¶ç³»ç»Ÿçš„finish_open()å‡½æ•°é™„åŠ åˆ°@fileä¸Šã€‚ * * å¦‚æœåªæŸ¥æ‰¾äº†æ–‡ä»¶æˆ–è€…ä¸éœ€è¦åˆ›å»ºæ–‡ä»¶ï¼ŒFMODE_OPENEDæ ‡å¿—ä½å°†ä¸ä¼šè¢«è®¾ç½®ã€‚ * è°ƒç”¨è€…éœ€è¦è‡ªè¡Œæ‰§è¡Œæ‰“å¼€æ“ä½œã€‚@pathå°†ä¼šæ›´æ–°ä¸ºæŒ‡å‘æ–°çš„dentryï¼Œå¯èƒ½æ˜¯è´Ÿå€¼ã€‚ * * å¦åˆ™è¿”å›é”™è¯¯ä»£ç ã€‚ */static struct dentry *atomic_open(struct nameidata *nd, struct dentry *dentry, struct file *file, int open_flag, umode_t mode)&#123; struct dentry *const DENTRY_NOT_SET = (void *) -1UL; struct inode *dir = nd-&gt;path.dentry-&gt;d_inode; int error; // å¦‚æœæ ‡å¿—ä½ä¸­åŒ…å«LOOKUP_DIRECTORYï¼Œåˆ™å°†open_flagä¸­çš„O_DIRECTORYæ ‡å¿—ä½ç½®ä½ if (nd-&gt;flags &amp; LOOKUP_DIRECTORY) open_flag |= O_DIRECTORY; // è®¾ç½®æ–‡ä»¶çš„è·¯å¾„ä¿¡æ¯ä¸ºDENTRY_NOT_SET file-&gt;f_path.dentry = DENTRY_NOT_SET; file-&gt;f_path.mnt = nd-&gt;path.mnt; // è°ƒç”¨ç›®å½•ç´¢å¼•èŠ‚ç‚¹çš„åŸå­æ‰“å¼€å‡½æ•°è¿›è¡Œæ“ä½œ error = dir-&gt;i_op-&gt;atomic_open(dir, dentry, file, open_to_namei_flags(open_flag), mode); d_lookup_done(dentry); if (!error) &#123; if (file-&gt;f_mode &amp; FMODE_OPENED) &#123; // å¦‚æœæ–‡ä»¶å·²ç»æ‰“å¼€ä¸”dentryä¸fileä¸­çš„è·¯å¾„ä¸ä¸€è‡´ï¼Œåˆ™é‡Šæ”¾æ—§çš„dentryå¹¶è·å–æ–°çš„dentry if (unlikely(dentry != file-&gt;f_path.dentry)) &#123; dput(dentry); dentry = dget(file-&gt;f_path.dentry); &#125; &#125; else if (WARN_ON(file-&gt;f_path.dentry == DENTRY_NOT_SET)) &#123; error = -EIO; &#125; else &#123; // å¦‚æœæ–‡ä»¶æœªæ‰“å¼€ä¸”dentryå·²ç»è®¾ç½®ï¼Œåˆ™é‡Šæ”¾æ—§çš„dentryå¹¶è·å–æ–°çš„dentry if (file-&gt;f_path.dentry) &#123; dput(dentry); dentry = file-&gt;f_path.dentry; &#125; // å¦‚æœæ–°çš„dentryæ˜¯è´Ÿå€¼ï¼Œåˆ™è¡¨ç¤ºæ–‡ä»¶ä¸å­˜åœ¨ if (unlikely(d_is_negative(dentry))) error = -ENOENT; &#125; &#125; if (error) &#123; // å¦‚æœå‡ºç°é”™è¯¯ï¼Œåˆ™é‡Šæ”¾dentryå¹¶è¿”å›é”™è¯¯æŒ‡é’ˆ dput(dentry); dentry = ERR_PTR(error); &#125; return dentry;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/*- æŸ¥æ‰¾å¹¶å¯èƒ½åˆ›å»ºå¹¶æ‰“å¼€æœ€åä¸€ä¸ªç»„ä»¶ã€‚-- å¿…é¡»åœ¨çˆ¶ç›®å½•è¢«é”å®šçš„æƒ…å†µä¸‹è°ƒç”¨ï¼ˆåœ¨O_CREATæƒ…å†µä¸‹æ˜¯äº’æ–¥çš„ï¼‰ã€‚-- æˆåŠŸæ—¶è¿”å›0ï¼Œå³å¦‚æœæ–‡ä»¶æˆåŠŸåœ°åŸå­æ€§åœ°åˆ›å»ºï¼ˆå¦‚æœ‰å¿…è¦ï¼‰å¹¶æ‰“å¼€ï¼Œæˆ–è€…- æ–‡ä»¶æ­¤æ—¶å°šæœªå®Œå…¨æ‰“å¼€ï¼Œå°½ç®¡è¿›è¡Œäº†æŸ¥æ‰¾å’Œåˆ›å»ºã€‚- è¿™äº›æƒ…å†µé€šè¿‡file-&gt;f_modeä¸Šå­˜åœ¨FMODE_OPENEDæ¥åŒºåˆ†ã€‚- åœ¨åä¸€ç§æƒ…å†µä¸‹ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šO_CREATï¼Œåˆ™@pathä¸­çš„dentryå¯èƒ½ä¸ºè´Ÿã€‚-- å¤±è´¥æ—¶è¿”å›é”™è¯¯ä»£ç ã€‚*/ static struct dentry lookup_open(struct nameidata *nd, struct file *file, const struct open_flags *op, bool got_write) &#123; struct mnt_idmap *idmap; struct dentry *dir = nd-&gt;path.dentry; // è·å–ç›®å½•çš„dentry struct inode *dir_inode = dir-&gt;d_inode; // è·å–ç›®å½•çš„inode int open_flag = op-&gt;open_flag; // è·å–æ‰“å¼€æ ‡å¿— struct dentry *dentry; int error, create_error = 0; umode_t mode = op-&gt;mode; // è·å–æ¨¡å¼ DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // å£°æ˜å¹¶åˆå§‹åŒ–ç­‰å¾…é˜Ÿåˆ—å¤´ if (unlikely(IS_DEADDIR(dir_inode))) // å¦‚æœç›®å½•çš„inodeå·²ç»æ— æ•ˆ return ERR_PTR(-ENOENT); file-&gt;f_mode &amp;= ~FMODE_CREATED; // æ¸…é™¤FMODE_CREATEDæ ‡å¿— dentry = d_lookup(dir, &amp;nd-&gt;last); // åœ¨ç›®å½•ä¸­æŸ¥æ‰¾æœ€åä¸€ä¸ªç»„ä»¶çš„dentry for (;;) &#123; if (!dentry) &#123; dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq); // å¹¶è¡Œåˆ†é…dentry if (IS_ERR(dentry)) return dentry; &#125; if (d_in_lookup(dentry)) // å¦‚æœdentryå¤„äºæŸ¥æ‰¾çŠ¶æ€ break; error = d_revalidate(dentry, nd-&gt;flags); // é‡æ–°éªŒè¯dentry if (likely(error &gt; 0)) // å¦‚æœéªŒè¯æˆåŠŸ break; if (error) // å¦‚æœå‡ºç°é”™è¯¯ goto out_dput; d_invalidate(dentry); // ä½¿dentryæ— æ•ˆ dput(dentry); dentry = NULL; &#125; if (dentry-&gt;d_inode) &#123; /* ç¼“å­˜çš„æ­£å‘dentryï¼šå°†åœ¨f_op-&gt;openä¸­æ‰“å¼€ */ return dentry; &#125; /* - æ£€æŸ¥å†™æƒé™æ˜¯æ£˜æ‰‹çš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“æ˜¯å¦å®é™…éœ€è¦å®ƒï¼šåªè¦æ–‡ä»¶å­˜åœ¨ï¼ŒO_CREATæ‰“å¼€å°±å¯ä»¥å·¥ä½œã€‚ - ä½†æ˜¯æ£€æŸ¥å­˜åœ¨ä¼šç ´ååŸå­æ€§ã€‚æŠ€å·§æ˜¯æ£€æŸ¥è®¿é—®æƒé™ï¼Œå¦‚æœæœªæˆäºˆï¼Œåˆ™ä»æ ‡å¿—ä¸­æ¸…é™¤O_CREATã€‚ - - å¦ä¸€ä¸ªé—®é¢˜æ˜¯è¿”å›â€œæ­£ç¡®â€çš„é”™è¯¯å€¼ï¼ˆä¾‹å¦‚ï¼Œå¯¹äºO_EXCLæ‰“å¼€ï¼Œæˆ‘ä»¬å¸Œæœ›è¿”å›EEXISTè€Œä¸æ˜¯EROFSï¼‰ã€‚ */ if (unlikely(!got_write)) open_flag &amp;= ~O_TRUNC; idmap = mnt_idmap(nd-&gt;path.mnt); if (open_flag &amp; O_CREAT) &#123; if (open_flag &amp; O_EXCL) open_flag &amp;= ~O_TRUNC; mode = vfs_prepare_mode(idmap, dir-&gt;d_inode, mode, mode, mode); // å‡†å¤‡æ¨¡å¼ if (likely(got_write)) create_error = may_o_create(idmap, &amp;nd-&gt;path, dentry, mode); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºæ–‡ä»¶ else create_error = -EROFS; &#125; if (create_error) open_flag &amp;= ~O_CREAT; if (dir_inode-&gt;i_op-&gt;atomic_open) &#123; dentry = atomic_open(nd, dentry, file, open_flag, mode); // åŸå­æ‰“å¼€æ“ä½œ if (unlikely(create_error) &amp;&amp; dentry == ERR_PTR(-ENOENT)) dentry = ERR_PTR(create_error); return dentry; &#125; if (d_in_lookup(dentry)) &#123; struct dentry *res = dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry, nd-&gt;flags); // åœ¨ç›®å½•inodeä¸Šæ‰§è¡Œlookupæ“ä½œ d_lookup_done(dentry); if (unlikely(res)) &#123; if (IS_ERR(res)) &#123; error = PTR_ERR(res); goto out_dput; &#125; dput(dentry); dentry = res; &#125; &#125; /* è´Ÿå‘dentryï¼Œåªéœ€åˆ›å»ºæ–‡ä»¶ */ if (!dentry-&gt;d_inode &amp;&amp; (open_flag &amp; O_CREAT)) &#123; file-&gt;f_mode |= FMODE_CREATED; // è®¾ç½®FMODE_CREATEDæ ‡å¿— audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE); // å¯¹å­èŠ‚ç‚¹è¿›è¡Œå®¡è®¡ if (!dir_inode-&gt;i_op-&gt;create) &#123; error = -EACCES; goto out_dput; &#125; error = dir_inode-&gt;i_op-&gt;create(idmap, dir_inode, dentry, mode, open_flag &amp; O_EXCL); // åˆ›å»ºæ–‡ä»¶ if (error) goto out_dput; &#125; if (unlikely(create_error) &amp;&amp; !dentry-&gt;d_inode) &#123; error = create_error; goto out_dput; &#125; return dentry;out_dput:dput(dentry);return ERR_PTR(error);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* ç”¨äºæ‰“å¼€æœ€åä¸€ä¸ªç»„ä»¶çš„æŸ¥æ‰¾è¿‡ç¨‹ä»¥åŠç›¸å…³æ“ä½œçš„å‡½æ•° */static const char *open_last_lookups(struct nameidata *nd,struct file *file, const struct open_flags *op)&#123;struct dentry *dir = nd-&gt;path.dentry; // è·å–ç›®å½•çš„dentryint open_flag = op-&gt;open_flag; // è·å–æ‰“å¼€æ ‡å¿—bool got_write = false; // æ ‡è®°æ˜¯å¦è·å–äº†å†™æƒé™struct dentry *dentry; // ç”¨äºå­˜å‚¨æŸ¥æ‰¾åˆ°çš„dentryconst char *res; // ç”¨äºè¿”å›ç»“æœçš„æŒ‡é’ˆnd-&gt;flags |= op-&gt;intent; // è®¾ç½®ndçš„æ ‡å¿—ä½if (nd-&gt;last_type != LAST_NORM) &#123; // å¦‚æœæœ€åä¸€ä¸ªç»„ä»¶ä¸æ˜¯æ™®é€šç»„ä»¶ï¼ˆå¦‚.æˆ–..ï¼‰ if (nd-&gt;depth) put_link(nd); // æ¸…ç†é“¾æ¥ return handle_dots(nd, nd-&gt;last_type); // å¤„ç†.å’Œ..&#125;if (!(open_flag &amp; O_CREAT)) &#123; // å¦‚æœä¸æ˜¯åˆ›å»ºæ–‡ä»¶çš„æ“ä½œ if (nd-&gt;last.name[nd-&gt;last.len]) // å¦‚æœæœ€åä¸€ä¸ªç»„ä»¶åé¢è¿˜æœ‰å­—ç¬¦ï¼ˆå¯èƒ½æ˜¯æ–œæ ï¼‰ nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; // è®¾ç½®æ ‡å¿—ä½ /* æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œå¤„äºRCUæ¨¡å¼ */ dentry = lookup_fast(nd); // å¿«é€ŸæŸ¥æ‰¾dentry if (IS_ERR(dentry)) return ERR_CAST(dentry); // è¿”å›é”™è¯¯æŒ‡é’ˆ if (likely(dentry)) goto finish_lookup; // è·³è½¬åˆ°æŸ¥æ‰¾å®Œæˆçš„éƒ¨åˆ† BUG_ON(nd-&gt;flags &amp; LOOKUP_RCU); // å¦‚æœæ ‡å¿—ä½æœ‰LOOKUP_RCUæ ‡å¿—ï¼Œè§¦å‘BUG&#125; else &#123; /* åˆ›å»ºæ–‡ä»¶çš„æ“ä½œ */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯æŒ‡é’ˆ &#125; audit_inode(nd-&gt;name, dir, AUDIT_INODE_PARENT); // å¯¹çˆ¶èŠ‚ç‚¹è¿›è¡Œå®¡è®¡ /* æ˜¯å¦å­˜åœ¨å°¾éƒ¨æ–œæ ï¼Ÿ */ if (unlikely(nd-&gt;last.name[nd-&gt;last.len])) return ERR_PTR(-EISDIR); // è¿”å›é”™è¯¯æŒ‡é’ˆ&#125;if (open_flag &amp; (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) &#123; got_write = !mnt_want_write(nd-&gt;path.mnt); // è·å–å†™æƒé™ /* * æš‚æ—¶ä¸è¦å¤±è´¥ - æˆ‘ä»¬å¯èƒ½ä¸éœ€è¦å®ƒï¼Œæˆ–è€…ä»¥ä¸åŒçš„é”™è¯¯å¤±è´¥ï¼› * è®©lookup_open()å†³å®šï¼›æˆ‘ä»¬å°†å¾ˆå¿«ä¸¢å¼ƒè¿™ä¸€ä¸ªã€‚ */&#125;if (open_flag &amp; O_CREAT) inode_lock(dir-&gt;d_inode); // é”å®šç›®å½•çš„inodeelse inode_lock_shared(dir-&gt;d_inode); // å…±äº«é”å®šç›®å½•çš„inodedentry = lookup_open(nd, file, op, got_write); // æ‰§è¡ŒæŸ¥æ‰¾å’Œåˆ›å»ºæ“ä½œif (!IS_ERR(dentry) &amp;&amp; (file-&gt;f_mode &amp; FMODE_CREATED)) fsnotify_create(dir-&gt;d_inode, dentry); // å‘é€æ–‡ä»¶åˆ›å»ºäº‹ä»¶é€šçŸ¥if (open_flag &amp; O_CREAT) inode_unlock(dir-&gt;d_inode); // è§£é”ç›®å½•çš„inodeelse inode_unlock_shared(dir-&gt;d_inode); // è§£é”ç›®å½•çš„inodeif (got_write) mnt_drop_write(nd-&gt;path.mnt); // é‡Šæ”¾å†™æƒé™if (IS_ERR(dentry)) return ERR_CAST(dentry); // è¿”å›é”™è¯¯æŒ‡é’ˆif (file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED)) &#123; dput(nd-&gt;path.dentry); nd-&gt;path.dentry = dentry; // æ›´æ–°ndçš„dentry return NULL;&#125;finish_lookup:if (nd-&gt;depth)put_link(nd); // æ¸…ç†é“¾æ¥res = step_into(nd, WALK_TRAILING, dentry); // è¿›å…¥ä¸‹ä¸€æ­¥æŸ¥æ‰¾if (unlikely(res))nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);return res; // è¿”å›ç»“æœ&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * å¤„ç†open()çš„æœ€åä¸€æ­¥ */static int do_open(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct mnt_idmap *idmap; // IDæ˜ å°„ç»“æ„ä½“æŒ‡é’ˆ int open_flag = op-&gt;open_flag; // æ‰“å¼€æ ‡å¿— bool do_truncate; // æ˜¯å¦è¿›è¡Œæˆªæ–­æ“ä½œ int acc_mode; // è®¿é—®æ¨¡å¼ int error; // é”™è¯¯ç if (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123; error = complete_walk(nd); // å®Œæˆè·¯å¾„çš„éå† if (error) return error;&#125;if (!(file-&gt;f_mode &amp; FMODE_CREATED)) audit_inode(nd-&gt;name, nd-&gt;path.dentry, 0); // å¯¹ç›®å½•è¿›è¡Œå®¡è®¡idmap = mnt_idmap(nd-&gt;path.mnt); // è·å–IDæ˜ å°„ç»“æ„ä½“æŒ‡é’ˆif (open_flag &amp; O_CREAT) &#123; if ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED)) return -EEXIST; // å¦‚æœO_EXCLæ ‡å¿—è¢«è®¾ç½®ï¼Œå¹¶ä¸”æ–‡ä»¶æœªè¢«åˆ›å»ºï¼Œè¿”å›æ–‡ä»¶å·²å­˜åœ¨çš„é”™è¯¯ if (d_is_dir(nd-&gt;path.dentry)) return -EISDIR; // å¦‚æœæ˜¯ç›®å½•ï¼Œè¿”å›æ˜¯ç›®å½•çš„é”™è¯¯ error = may_create_in_sticky(idmap, nd, d_backing_inode(nd-&gt;path.dentry)); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åœ¨ç²˜æ»ä½ç›®å½•ä¸­åˆ›å»ºæ–‡ä»¶ if (unlikely(error)) return error;&#125;if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry)) return -ENOTDIR; // å¦‚æœæ ‡å¿—ä½æœ‰LOOKUP_DIRECTORYæ ‡å¿—ï¼Œå¹¶ä¸”æ— æ³•è¿›è¡ŒæŸ¥æ‰¾ï¼Œè¿”å›ä¸æ˜¯ç›®å½•çš„é”™è¯¯do_truncate = false; // åˆå§‹åŒ–æˆªæ–­æ ‡å¿—acc_mode = op-&gt;acc_mode; // è·å–è®¿é—®æ¨¡å¼if (file-&gt;f_mode &amp; FMODE_CREATED) &#123; /* ä¸æ£€æŸ¥å†™æƒé™ï¼Œä¸è¿›è¡Œæˆªæ–­ */ open_flag &amp;= ~O_TRUNC; // æ¸…é™¤O_TRUNCæ ‡å¿— acc_mode = 0; // è®¾ç½®è®¿é—®æ¨¡å¼ä¸º0&#125; else if (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123; error = mnt_want_write(nd-&gt;path.mnt); // è·å–å†™æƒé™ if (error) return error; do_truncate = true; // è®¾ç½®æˆªæ–­æ ‡å¿—ä¸ºtrue&#125;error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag); // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰“å¼€æ–‡ä»¶if (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED)) error = vfs_open(&amp;nd-&gt;path, file); // æ‰“å¼€æ–‡ä»¶if (!error) error = ima_file_check(file, op-&gt;acc_mode); // æ£€æŸ¥æ–‡ä»¶çš„å®Œæ•´æ€§å’Œå®‰å…¨æ€§if (!error &amp;&amp; do_truncate) error = handle_truncate(idmap, file); // å¤„ç†æˆªæ–­æ“ä½œif (unlikely(error &gt; 0)) &#123; WARN_ON(1); error = -EINVAL;&#125;if (do_truncate) mnt_drop_write(nd-&gt;path.mnt); // é‡Šæ”¾å†™æƒé™return error; // è¿”å›é”™è¯¯ç &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * vfs_tmpfile - åˆ›å»ºä¸´æ—¶æ–‡ä»¶ * @idmap: æŒ‚è½½ç‚¹çš„IDæ˜ å°„ * @dentry: åŸºç¡€ç›®å½•çš„dentryæŒ‡é’ˆ * @mode: æ–°ä¸´æ—¶æ–‡ä»¶çš„æ¨¡å¼ * @open_flag: æ ‡å¿— * * åˆ›å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶ã€‚ * * å¦‚æœé€šè¿‡IDæ˜ å°„çš„æŒ‚è½½ç‚¹æ‰¾åˆ°äº†inodeï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„IDæ˜ å°„ã€‚ * æ­¤å‡½æ•°å°†æ ¹æ®@idmapæ˜ å°„inodeï¼Œç„¶åæ£€æŸ¥æƒé™ã€‚ * åœ¨éIDæ˜ å°„çš„æŒ‚è½½ç‚¹ä¸Šï¼Œæˆ–è€…å¦‚æœè¦å¯¹åŸå§‹inodeæ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåˆ™åªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */static int vfs_tmpfile(struct mnt_idmap *idmap, const struct path *parentpath, struct file *file, umode_t mode)&#123; struct dentry *child; // å­ç›®å½•é¡¹ struct inode *dir = d_inode(parentpath-&gt;dentry); // çˆ¶ç›®å½•çš„inode struct inode *inode; int error; int open_flag = file-&gt;f_flags; // æ–‡ä»¶æ ‡å¿— /* æˆ‘ä»¬å¸Œæœ›ç›®å½•å¯å†™ */ error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC); // æ£€æŸ¥ç›®å½•çš„å†™å’Œæ‰§è¡Œæƒé™ if (error) return error; if (!dir-&gt;i_op-&gt;tmpfile) return -EOPNOTSUPP; // å¦‚æœç›®å½•ä¸æ”¯æŒtmpfileæ“ä½œï¼Œåˆ™è¿”å›ä¸æ”¯æŒçš„é”™è¯¯ child = d_alloc(parentpath-&gt;dentry, &amp;slash_name); // åˆ†é…å­ç›®å½•é¡¹ if (unlikely(!child)) return -ENOMEM; // å¦‚æœåˆ†é…å¤±è´¥ï¼Œåˆ™è¿”å›å†…å­˜ä¸è¶³çš„é”™è¯¯ file-&gt;f_path.mnt = parentpath-&gt;mnt; file-&gt;f_path.dentry = child; // è®¾ç½®æ–‡ä»¶çš„æŒ‚è½½ç‚¹å’Œç›®å½•é¡¹ mode = vfs_prepare_mode(idmap, dir, mode, mode, mode); // å‡†å¤‡æ–‡ä»¶çš„æ¨¡å¼ error = dir-&gt;i_op-&gt;tmpfile(idmap, dir, file, mode); // è°ƒç”¨ç›®å½•çš„tmpfileæ“ä½œ dput(child); if (error) return error; // å¦‚æœå‡ºé”™ï¼Œåˆ™è¿”å›é”™è¯¯ç  /* ä¸æ£€æŸ¥å…¶ä»–æƒé™ï¼Œå› ä¸ºåˆšåˆšåˆ›å»ºäº†inode */ error = may_open(idmap, &amp;file-&gt;f_path, 0, file-&gt;f_flags); // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰“å¼€æ–‡ä»¶ if (error) return error; // å¦‚æœå‡ºé”™ï¼Œåˆ™è¿”å›é”™è¯¯ç  inode = file_inode(file); if (!(open_flag &amp; O_EXCL)) &#123; spin_lock(&amp;inode-&gt;i_lock); inode-&gt;i_state |= I_LINKABLE; // è®¾ç½®inodeçš„çŠ¶æ€ä¸ºå¯é“¾æ¥ spin_unlock(&amp;inode-&gt;i_lock); &#125; ima_post_create_tmpfile(idmap, inode); // è¿›è¡Œä¸´æ—¶æ–‡ä»¶çš„å®Œæ•´æ€§å’Œå®‰å…¨æ€§æ£€æŸ¥ return 0; // è¿”å›æˆåŠŸ&#125; 1234567891011121314151617181920212223242526272829/** * vfs_tmpfile_open - ä¸ºå†…æ ¸å†…éƒ¨ä½¿ç”¨æ‰“å¼€ä¸€ä¸ªä¸´æ—¶æ–‡ä»¶ * @idmap: é€šè¿‡è¯¥æŒ‚è½½ç‚¹æ‰¾åˆ°çš„inodeçš„idmap * @parentpath: åŸºæœ¬ç›®å½•çš„è·¯å¾„ * @mode: æ–°ä¸´æ—¶æ–‡ä»¶çš„æ¨¡å¼ * @open_flag: æ ‡å¿— * @cred: æ‰“å¼€çš„å‡­è¯ * * åˆ›å»ºå¹¶æ‰“å¼€ä¸€ä¸ªä¸´æ—¶æ–‡ä»¶ã€‚è¯¥æ–‡ä»¶ä¸ä¼šè®¡å…¥nr_filesä¸­ï¼Œå› æ­¤åªé€‚ç”¨äºå†…æ ¸å†…éƒ¨ä½¿ç”¨ï¼Œ * ä¸å¾—å®‰è£…åˆ°æ–‡ä»¶è¡¨æˆ–å…¶ä»–åœ°æ–¹ã€‚ */struct file *vfs_tmpfile_open(struct mnt_idmap *idmap, const struct path *parentpath, umode_t mode, int open_flag, const struct cred *cred)&#123; struct file *file; // æ–‡ä»¶æŒ‡é’ˆ int error; // é”™è¯¯ç  file = alloc_empty_file_noaccount(open_flag, cred); // åˆ†é…ä¸€ä¸ªç©ºçš„æ–‡ä»¶ç»“æ„ï¼ˆä¸è®¡å…¥æ–‡ä»¶è®¡æ•°ï¼‰ if (!IS_ERR(file)) &#123; error = vfs_tmpfile(idmap, parentpath, file, mode); // åˆ›å»ºä¸´æ—¶æ–‡ä»¶ if (error) &#123; fput(file); // å¦‚æœå‡ºé”™ï¼Œé‡Šæ”¾æ–‡ä»¶ file = ERR_PTR(error); // è¿”å›é”™è¯¯æŒ‡é’ˆ &#125; &#125; return file; // è¿”å›æ–‡ä»¶æŒ‡é’ˆ&#125;EXPORT_SYMBOL(vfs_tmpfile_open); // å¯¼å‡ºç¬¦å·ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ 12345678910111213141516171819202122static int do_tmpfile(struct nameidata *nd, unsigned flags, const struct open_flags *op, struct file *file)&#123; struct path path; // è·¯å¾„ç»“æ„ int error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &amp;path); // æŸ¥æ‰¾ç›®å½•è·¯å¾„ if (unlikely(error)) return error; // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å›é”™è¯¯ç  error = mnt_want_write(path.mnt); // å¢åŠ æŒ‚è½½ç‚¹çš„å†™å¼•ç”¨è®¡æ•° if (unlikely(error)) goto out; // å¦‚æœå¢åŠ å¤±è´¥ï¼Œè·³è½¬åˆ°å‡ºé”™å¤„ç† error = vfs_tmpfile(mnt_idmap(path.mnt), &amp;path, file, op-&gt;mode); // åˆ›å»ºä¸´æ—¶æ–‡ä»¶ if (error) goto out2; // å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œè·³è½¬åˆ°å‡ºé”™å¤„ç† audit_inode(nd-&gt;name, file-&gt;f_path.dentry, 0); // å®¡è®¡æ–°åˆ›å»ºçš„ä¸´æ—¶æ–‡ä»¶out2: mnt_drop_write(path.mnt); // å‡å°‘æŒ‚è½½ç‚¹çš„å†™å¼•ç”¨è®¡æ•°out: path_put(&amp;path); // é‡Šæ”¾è·¯å¾„ç»“æ„ return error; // è¿”å›é”™è¯¯ç &#125; 123456789101112static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)&#123; struct path path; // è·¯å¾„ç»“æ„ int error = path_lookupat(nd, flags, &amp;path); // æŸ¥æ‰¾è·¯å¾„ if (!error) &#123; audit_inode(nd-&gt;name, path.dentry, 0); // å®¡è®¡æ‰¾åˆ°çš„ç›®å½•é¡¹ error = vfs_open(&amp;path, file); // æ‰“å¼€æ–‡ä»¶ path_put(&amp;path); // é‡Šæ”¾è·¯å¾„ç»“æ„ &#125; return error; // è¿”å›é”™è¯¯ç &#125; 1234567891011121314151617181920212223242526272829303132333435363738static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; struct file *file; // æ–‡ä»¶æŒ‡é’ˆ int error; file = alloc_empty_file(op-&gt;open_flag, current_cred()); // åˆ†é…ä¸€ä¸ªç©ºçš„æ–‡ä»¶ç»“æ„ if (IS_ERR(file)) return file; // å¦‚æœåˆ†é…å¤±è´¥ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123; error = do_tmpfile(nd, flags, op, file); // å¦‚æœæ˜¯ä¸´æ—¶æ–‡ä»¶ï¼Œè°ƒç”¨ä¸´æ—¶æ–‡ä»¶å¤„ç†å‡½æ•° &#125; else if (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123; error = do_o_path(nd, flags, file); // å¦‚æœæ˜¯O_PATHæ ‡å¿—ï¼Œè°ƒç”¨O_PATHå¤„ç†å‡½æ•° &#125; else &#123; const char *s = path_init(nd, flags); // åˆå§‹åŒ–è·¯å¾„ while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ; // éå†è·¯å¾„ä¸­çš„ç›®å½•é¡¹å¹¶æ‰“å¼€æ–‡ä»¶ if (!error) error = do_open(nd, file, op); // æ‰§è¡Œæ‰“å¼€æ–‡ä»¶æ“ä½œ terminate_walk(nd); // ç»ˆæ­¢è·¯å¾„éå† &#125; if (likely(!error)) &#123; if (likely(file-&gt;f_mode &amp; FMODE_OPENED)) return file; // å¦‚æœæ–‡ä»¶å·²æˆåŠŸæ‰“å¼€ï¼Œè¿”å›æ–‡ä»¶æŒ‡é’ˆ WARN_ON(1); // æ‰“å°è­¦å‘Šä¿¡æ¯ error = -EINVAL; // è®¾ç½®é”™è¯¯ç ä¸ºæ— æ•ˆå‚æ•° &#125; fput(file); // é‡Šæ”¾æ–‡ä»¶ if (error == -EOPENSTALE) &#123; if (flags &amp; LOOKUP_RCU) error = -ECHILD; // å¦‚æœæ˜¯RCUæŸ¥æ‰¾æ ‡å¿—ï¼Œè®¾ç½®é”™è¯¯ç ä¸ºå­è¿›ç¨‹ä¸å­˜åœ¨ else error = -ESTALE; // å¦åˆ™è®¾ç½®é”™è¯¯ç ä¸ºæ–‡ä»¶å·²è¿‡æœŸ &#125; return ERR_PTR(error); // è¿”å›é”™è¯¯æŒ‡é’ˆ&#125; 12345678910111213141516struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // åç§°æ•°æ®ç»“æ„ int flags = op-&gt;lookup_flags; // æŸ¥æ‰¾æ ‡å¿— struct file *filp; // æ–‡ä»¶æŒ‡é’ˆ set_nameidata(&amp;nd, dfd, pathname, NULL); // è®¾ç½®åç§°æ•°æ®ç»“æ„ filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // æ‰“å¼€è·¯å¾„å¯¹åº”çš„æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ECHILD))) // å¦‚æœæ‰“å¼€å¤±è´¥ä¸”é”™è¯¯ç ä¸ºECHILD filp = path_openat(&amp;nd, op, flags); // å†æ¬¡å°è¯•æ‰“å¼€æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ESTALE))) // å¦‚æœæ‰“å¼€å¤±è´¥ä¸”é”™è¯¯ç ä¸ºESTALE filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // å†æ¬¡å°è¯•æ‰“å¼€æ–‡ä»¶ï¼ˆé‡æ–°éªŒè¯ï¼‰ restore_nameidata(); // æ¢å¤åç§°æ•°æ®ç»“æ„ return filp; // è¿”å›æ–‡ä»¶æŒ‡é’ˆ&#125; 12345678910111213141516171819202122232425struct file *do_file_open_root(const struct path *root, const char *name, const struct open_flags *op)&#123; struct nameidata nd; // åç§°æ•°æ®ç»“æ„ struct file *file; // æ–‡ä»¶æŒ‡é’ˆ struct filename *filename; // æ–‡ä»¶å int flags = op-&gt;lookup_flags; // æŸ¥æ‰¾æ ‡å¿— if (d_is_symlink(root-&gt;dentry) &amp;&amp; op-&gt;intent &amp; LOOKUP_OPEN) return ERR_PTR(-ELOOP); // å¦‚æœæ ¹ç›®å½•æ˜¯ç¬¦å·é“¾æ¥ä¸”æ‰“å¼€æ ‡å¿—ä¸ºLOOKUP_OPENï¼Œè¿”å›ELOOPé”™è¯¯ filename = getname_kernel(name); // è·å–æ–‡ä»¶å if (IS_ERR(filename)) return ERR_CAST(filename); // å¦‚æœè·å–å¤±è´¥ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ set_nameidata(&amp;nd, -1, filename, root); // è®¾ç½®åç§°æ•°æ®ç»“æ„ file = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // æ‰“å¼€è·¯å¾„å¯¹åº”çš„æ–‡ä»¶ if (unlikely(file == ERR_PTR(-ECHILD))) // å¦‚æœæ‰“å¼€å¤±è´¥ä¸”é”™è¯¯ç ä¸ºECHILD file = path_openat(&amp;nd, op, flags); // å†æ¬¡å°è¯•æ‰“å¼€æ–‡ä»¶ if (unlikely(file == ERR_PTR(-ESTALE))) // å¦‚æœæ‰“å¼€å¤±è´¥ä¸”é”™è¯¯ç ä¸ºESTALE file = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // å†æ¬¡å°è¯•æ‰“å¼€æ–‡ä»¶ï¼ˆé‡æ–°éªŒè¯ï¼‰ restore_nameidata(); // æ¢å¤åç§°æ•°æ®ç»“æ„ putname(filename); // é‡Šæ”¾æ–‡ä»¶å return file; // è¿”å›æ–‡ä»¶æŒ‡é’ˆ&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static struct dentry *filename_create(int dfd, struct filename *name, struct path *path, unsigned int lookup_flags)&#123; struct dentry *dentry = ERR_PTR(-EEXIST); // ç›®å½•é¡¹æŒ‡é’ˆï¼Œé»˜è®¤ä¸ºå·²å­˜åœ¨çš„é”™è¯¯æŒ‡é’ˆ struct qstr last; // æœ€åä¸€ä¸ªç»„ä»¶çš„åç§° bool want_dir = lookup_flags &amp; LOOKUP_DIRECTORY; // æ˜¯å¦è¯·æ±‚ç›®å½• unsigned int reval_flag = lookup_flags &amp; LOOKUP_REVAL; // é‡æ–°éªŒè¯æ ‡å¿— unsigned int create_flags = LOOKUP_CREATE | LOOKUP_EXCL; // åˆ›å»ºæ ‡å¿— int type; int err2; int error; error = filename_parentat(dfd, name, reval_flag, path, &amp;last, &amp;type); // æŸ¥æ‰¾çˆ¶ç›®å½•è·¯å¾„å’Œæœ€åä¸€ä¸ªç»„ä»¶ if (error) return ERR_PTR(error); // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ /* * ç³Ÿç³•çš„æœ€åä¸€ä¸ªç»„ä»¶æˆ–æ ¹æœ¬æ²¡æœ‰æœ€åä¸€ä¸ªç»„ä»¶ï¼Ÿ * (foo/., foo/.., /////) */ if (unlikely(type != LAST_NORM)) goto out; // å¦‚æœæœ€åä¸€ä¸ªç»„ä»¶å¼‚å¸¸ï¼Œè·³è½¬åˆ°ç»“æŸå¤„ /* å¦‚æœæ˜¯åªè¯»çš„ï¼Œå…ˆä¸ç«‹å³å¤±è´¥ï¼Œè‡³å°‘å°è¯•æŠ¥å‘Šå…¶ä»–é”™è¯¯ */ err2 = mnt_want_write(path-&gt;mnt); /* * è¿›è¡Œæœ€ç»ˆçš„æŸ¥æ‰¾ã€‚å¦‚æœæœ‰å°¾éƒ¨&#x27;/&#x27;ï¼Œä¸”ä¸éœ€è¦ç›®å½•ï¼Œåˆ™ä¸è¿›è¡Œåˆ›å»ºã€‚ */ if (last.name[last.len] &amp;&amp; !want_dir) create_flags = 0; // å¦‚æœå°¾éƒ¨æœ‰&#x27;/&#x27;ä¸”ä¸éœ€è¦ç›®å½•ï¼Œä¸è¿›è¡Œåˆ›å»ºæ“ä½œ inode_lock_nested(path-&gt;dentry-&gt;d_inode, I_MUTEX_PARENT); // é”ä½çˆ¶ç›®å½•çš„inode dentry = __lookup_hash(&amp;last, path-&gt;dentry, reval_flag | create_flags); // æŸ¥æ‰¾ç›®å½•é¡¹ if (IS_ERR(dentry)) goto unlock; // å¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œè·³è½¬åˆ°è§£é”å¤„ error = -EEXIST; if (d_is_positive(dentry)) goto fail; // å¦‚æœç›®å½•é¡¹å·²å­˜åœ¨ï¼Œè·³è½¬åˆ°å¤±è´¥å¤„ /* * ç‰¹æ®Šæƒ…å†µ - æŸ¥æ‰¾è¿”å›è´Ÿå€¼ï¼Œä½†æ˜¯...æœ€åä¸€ä¸ªç»„ä»¶æ˜¯ foo/bar/ * ä» vfs_mknod() çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬åªæœ‰ä¸€ä¸ªè´Ÿçš„ç›®å½•é¡¹ - * ä¸€åˆ‡æ­£å¸¸ã€‚ä½†æ˜¯æˆ‘ä»¬å¯ä»¥é‡‡å–ä¸€äº›æ¶æ„è¡Œä¸º - ä½ åœ¨æœ«å°¾åŠ äº†&#x27;/&#x27;ï¼Œä½ è¦æ±‚çš„æ˜¯ï¼ˆä¸å­˜åœ¨çš„ï¼‰ç›®å½•ã€‚ç»™ä½ ä¸€ä¸ª -ENOENTã€‚ */ if (unlikely(!create_flags)) &#123; error = -ENOENT; goto fail; // å¦‚æœæ²¡æœ‰è¿›è¡Œåˆ›å»ºæ“ä½œï¼Œè·³è½¬åˆ°å¤±è´¥å¤„ &#125; if (unlikely(err2)) &#123; error = err2; goto fail; // å¦‚æœæœ‰å…¶ä»–é”™è¯¯ï¼Œè·³è½¬åˆ°å¤±è´¥å¤„ &#125; return dentry; // è¿”å›ç›®å½•é¡¹æŒ‡é’ˆfail: dput(dentry); // é‡Šæ”¾ç›®å½•é¡¹ dentry = ERR_PTR(error); // è®¾ç½®ä¸ºé”™è¯¯æŒ‡é’ˆunlock: inode_unlock(path-&gt;dentry-&gt;d_inode); // è§£é”çˆ¶ç›®å½•çš„inode if (!err2) mnt_drop_write(path-&gt;mnt); // æ”¾å¼ƒå†™é”out: path_put(path); // é‡Šæ”¾è·¯å¾„ return dentry; // è¿”å›ç›®å½•é¡¹æŒ‡é’ˆ&#125; 1234567891011// ä»å†…æ ¸ç©ºé—´åˆ›å»ºè·¯å¾„struct dentry *kern_path_create(int dfd, const char *pathname, struct path *path, unsigned int lookup_flags)&#123; struct filename *filename = getname_kernel(pathname); // è·å–å†…æ ¸ç©ºé—´çš„æ–‡ä»¶å struct dentry *res = filename_create(dfd, filename, path, lookup_flags); // åˆ›å»ºè·¯å¾„ putname(filename); // é‡Šæ”¾æ–‡ä»¶å return res; // è¿”å›ç›®å½•é¡¹æŒ‡é’ˆ&#125;EXPORT_SYMBOL(kern_path_create); // å¯¼å‡ºkern_path_createç¬¦å· 123456789// å®Œæˆè·¯å¾„åˆ›å»ºæ“ä½œvoid done_path_create(struct path *path, struct dentry *dentry)&#123; dput(dentry); // é‡Šæ”¾ç›®å½•é¡¹ inode_unlock(path-&gt;dentry-&gt;d_inode); // è§£é”çˆ¶ç›®å½•çš„inode mnt_drop_write(path-&gt;mnt); // æ”¾å¼ƒå†™é” path_put(path); // é‡Šæ”¾è·¯å¾„&#125;EXPORT_SYMBOL(done_path_create); // å¯¼å‡ºdone_path_createç¬¦å· 1234567891011// ä»ç”¨æˆ·ç©ºé—´åˆ›å»ºè·¯å¾„inline struct dentry *user_path_create(int dfd, const char __user *pathname, struct path *path, unsigned int lookup_flags)&#123; struct filename *filename = getname(pathname); // è·å–ç”¨æˆ·ç©ºé—´çš„æ–‡ä»¶å struct dentry *res = filename_create(dfd, filename, path, lookup_flags); // åˆ›å»ºè·¯å¾„ putname(filename); // é‡Šæ”¾æ–‡ä»¶å return res; // è¿”å›ç›®å½•é¡¹æŒ‡é’ˆ&#125;EXPORT_SYMBOL(user_path_create); // å¯¼å‡ºuser_path_createç¬¦å· 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * vfs_mknod - åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹æˆ–æ–‡ä»¶ * @idmap: æŒ‚è½½ç‚¹çš„idmap * @dir: ç›®å½•çš„inode * @dentry: æŒ‡å‘åŸºç¡€ç›®å½•çš„dentryæŒ‡é’ˆ * @mode: æ–°è®¾å¤‡èŠ‚ç‚¹æˆ–æ–‡ä»¶çš„æƒé™ * @dev: è¦åˆ›å»ºçš„è®¾å¤‡çš„è®¾å¤‡å· * * åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹æˆ–æ–‡ä»¶ã€‚ * * å¦‚æœé€šè¿‡idæ˜ å°„çš„æŒ‚è½½ç‚¹æ‰¾åˆ°äº†inodeï¼Œå¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚æ­¤å‡½æ•°å°†è´Ÿè´£æ ¹æ®@idmapæ˜ å°„inodeï¼Œç„¶åæ£€æŸ¥æƒé™ã€‚ * å¯¹äºéidæ˜ å°„çš„æŒ‚è½½ç‚¹ï¼Œæˆ–è€…å¦‚æœè¦å¯¹åŸå§‹inodeæ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåˆ™åªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */int vfs_mknod(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)&#123; bool is_whiteout = S_ISCHR(mode) &amp;&amp; dev == WHITEOUT_DEV; // æ˜¯å¦æ˜¯ç™½å‡ºèŠ‚ç‚¹ int error = may_create(idmap, dir, dentry); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»º if (error) return error; // å¦‚æœä¸å…è®¸åˆ›å»ºï¼Œè¿”å›é”™è¯¯ if ((S_ISCHR(mode) || S_ISBLK(mode)) &amp;&amp; !is_whiteout &amp;&amp; !capable(CAP_MKNOD)) return -EPERM; // å¦‚æœæ˜¯å­—ç¬¦è®¾å¤‡æˆ–å—è®¾å¤‡ä½†ä¸æ˜¯ç™½å‡ºèŠ‚ç‚¹ä¸”æ²¡æœ‰CAP_MKNODæƒé™ï¼Œè¿”å›EPERM if (!dir-&gt;i_op-&gt;mknod) return -EPERM; // å¦‚æœç›®å½•çš„i_opä¸­æ²¡æœ‰mknodæ“ä½œï¼Œè¿”å›EPERM mode = vfs_prepare_mode(idmap, dir, mode, mode, mode); // å‡†å¤‡æƒé™æ¨¡å¼ error = devcgroup_inode_mknod(mode, dev); // åœ¨devcgroupä¸­è¿›è¡Œinode_mknodæ“ä½œ if (error) return error; // å¦‚æœdevcgroup_inode_mknodæ“ä½œå¤±è´¥ï¼Œè¿”å›é”™è¯¯ error = security_inode_mknod(dir, dentry, mode, dev); // è¿›è¡Œå®‰å…¨æ€§æ£€æŸ¥ if (error) return error; // å¦‚æœå®‰å…¨æ€§æ£€æŸ¥å¤±è´¥ï¼Œè¿”å›é”™è¯¯ error = dir-&gt;i_op-&gt;mknod(idmap, dir, dentry, mode, dev); // è°ƒç”¨ç›®å½•çš„mknodæ“ä½œ if (!error) fsnotify_create(dir, dentry); // å‘é€æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥ï¼Œè¡¨ç¤ºåˆ›å»ºæˆåŠŸ return error; // è¿”å›é”™è¯¯ç &#125;EXPORT_SYMBOL(vfs_mknod); // å¯¼å‡ºvfs_mknodç¬¦å· 12345678910111213141516static int may_mknod(umode_t mode)&#123; switch (mode &amp; S_IFMT) &#123; case S_IFREG: case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK: case 0: /* é›¶æ¨¡å¼è½¬æ¢ä¸ºS_IFREG */ return 0; case S_IFDIR: return -EPERM; default: return -EINVAL; &#125;&#125; // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹æˆ–æ–‡ä»¶çš„è¾…åŠ©å‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static int do_mknodat(int dfd, struct filename *name, umode_t mode, unsigned int dev)&#123; struct mnt_idmap *idmap; // æŒ‚è½½ç‚¹idmapæŒ‡é’ˆ struct dentry *dentry; // ç›®å½•é¡¹æŒ‡é’ˆ struct path path; // è·¯å¾„ç»“æ„ä½“ int error; // é”™è¯¯ç  unsigned int lookup_flags = 0; // æŸ¥æ‰¾æ ‡å¿— error = may_mknod(mode); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹æˆ–æ–‡ä»¶ if (error) goto out1;retry: dentry = filename_create(dfd, name, &amp;path, lookup_flags); // åˆ›å»ºç›®å½•é¡¹ error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto out1; error = security_path_mknod(&amp;path, dentry, mode_strip_umask(path.dentry-&gt;d_inode, mode), dev); // è¿›è¡Œè·¯å¾„çš„å®‰å…¨æ€§æ£€æŸ¥ if (error) goto out2; idmap = mnt_idmap(path.mnt); // è·å–æŒ‚è½½ç‚¹çš„idmap switch (mode &amp; S_IFMT) &#123; case 0: case S_IFREG: error = vfs_create(idmap, path.dentry-&gt;d_inode, dentry, mode, true); // åˆ›å»ºæ™®é€šæ–‡ä»¶ if (!error) ima_post_path_mknod(idmap, dentry); // åœ¨IMAä¸­è®°å½•åˆ›å»ºè®¾å¤‡èŠ‚ç‚¹æˆ–æ–‡ä»¶çš„è·¯å¾„ break; case S_IFCHR: case S_IFBLK: error = vfs_mknod(idmap, path.dentry-&gt;d_inode, dentry, mode, new_decode_dev(dev)); // åˆ›å»ºå­—ç¬¦è®¾å¤‡æˆ–å—è®¾å¤‡èŠ‚ç‚¹ break; case S_IFIFO: case S_IFSOCK: error = vfs_mknod(idmap, path.dentry-&gt;d_inode, dentry, mode, 0); // åˆ›å»ºFIFOç®¡é“æˆ–å¥—æ¥å­—èŠ‚ç‚¹ break; &#125;out2: done_path_create(&amp;path, dentry); // å®Œæˆè·¯å¾„åˆ›å»ºæ“ä½œ if (retry_estale(error, lookup_flags)) &#123; // å¦‚æœé”™è¯¯ç æŒ‡ç¤ºéœ€è¦é‡è¯•ï¼ˆå¯èƒ½æ˜¯ç”±äºNFSå¯¼è‡´çš„é”™è¯¯ï¼‰ lookup_flags |= LOOKUP_REVAL; // è®¾ç½®é‡è¯•æ ‡å¿— goto retry; // é‡è¯• &#125;out1: putname(name); // é‡Šæ”¾æ–‡ä»¶å return error; // è¿”å›é”™è¯¯ç &#125; 12345678910SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned int, dev)&#123; return do_mknodat(dfd, getname(filename), mode, dev); // æ‰§è¡Œdo_mknodatç³»ç»Ÿè°ƒç”¨&#125;SYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)&#123; return do_mknodat(AT_FDCWD, getname(filename), mode, dev); // æ‰§è¡Œdo_mknodatç³»ç»Ÿè°ƒç”¨ï¼Œä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ä½œä¸ºdfd&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * vfs_mkdir - åˆ›å»ºç›®å½• * @idmap: æŒ‚è½½ç‚¹çš„idmap * @dir: ç›®å½•çš„inode * @dentry: åŸºç¡€ç›®å½•çš„dentryæŒ‡é’ˆ * @mode: æ–°ç›®å½•çš„æƒé™æ¨¡å¼ * * åˆ›å»ºä¸€ä¸ªç›®å½•ã€‚ * * å¦‚æœé€šè¿‡idæ˜ å°„çš„æŒ‚è½½ç‚¹æ‰¾åˆ°äº†inodeï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚ * æ­¤å‡½æ•°å°†æ ¹æ®@idmapæ˜ å°„inodeï¼Œå¹¶åœ¨æ£€æŸ¥æƒé™ä¹‹å‰å¤„ç†æ˜ å°„ã€‚ * å¦‚æœæ˜¯éidæ˜ å°„çš„æŒ‚è½½ç‚¹ï¼Œæˆ–è€…éœ€è¦åœ¨åŸå§‹inodeä¸Šæ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */int vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode)&#123; int error; unsigned max_links = dir-&gt;i_sb-&gt;s_max_links; // ç›®å½•çš„æœ€å¤§é“¾æ¥æ•° error = may_create(idmap, dir, dentry); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ›å»ºç›®å½• if (error) return error; if (!dir-&gt;i_op-&gt;mkdir) // æ£€æŸ¥æ˜¯å¦æ”¯æŒmkdiræ“ä½œ return -EPERM; mode = vfs_prepare_mode(idmap, dir, mode, S_IRWXUGO | S_ISVTX, 0); // å‡†å¤‡ç›®å½•çš„æƒé™æ¨¡å¼ error = security_inode_mkdir(dir, dentry, mode); // æ£€æŸ¥ç›®å½•çš„å®‰å…¨æ€§ if (error) return error; if (max_links &amp;&amp; dir-&gt;i_nlink &gt;= max_links) // æ£€æŸ¥ç›®å½•çš„é“¾æ¥æ•°æ˜¯å¦è¶…è¿‡æœ€å¤§é™åˆ¶ return -EMLINK; error = dir-&gt;i_op-&gt;mkdir(idmap, dir, dentry, mode); // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„mkdiræ“ä½œ if (!error) fsnotify_mkdir(dir, dentry); // å‘é€ç›®å½•åˆ›å»ºé€šçŸ¥ return error;&#125;EXPORT_SYMBOL(vfs_mkdir); 12345678910111213141516171819202122232425262728int do_mkdirat(int dfd, struct filename *name, umode_t mode)&#123; struct dentry *dentry; // ç›®å½•é¡¹æŒ‡é’ˆ struct path path; // è·¯å¾„ç»“æ„ä½“ int error; unsigned int lookup_flags = LOOKUP_DIRECTORY; // æŸ¥æ‰¾æ ‡å¿—ï¼ŒæŒ‡ç¤ºæŸ¥æ‰¾çš„æ˜¯ç›®å½•retry: dentry = filename_create(dfd, name, &amp;path, lookup_flags); // åˆ›å»ºç›®å½•é¡¹ error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto out_putname; error = security_path_mkdir(&amp;path, dentry, mode_strip_umask(path.dentry-&gt;d_inode, mode)); // æ£€æŸ¥è·¯å¾„çš„å®‰å…¨æ€§ if (!error) &#123; error = vfs_mkdir(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, mode); // è°ƒç”¨vfs_mkdiråˆ›å»ºç›®å½• &#125; done_path_create(&amp;path, dentry); // å®Œæˆè·¯å¾„åˆ›å»ºæ“ä½œ if (retry_estale(error, lookup_flags)) &#123; // å¦‚æœé”™è¯¯ç æŒ‡ç¤ºéœ€è¦é‡è¯•ï¼ˆå¯èƒ½æ˜¯ç”±äºNFSå¯¼è‡´çš„é”™è¯¯ï¼‰ lookup_flags |= LOOKUP_REVAL; // è®¾ç½®é‡è¯•æ ‡å¿— goto retry; // é‡è¯• &#125;out_putname: putname(name); // é‡Šæ”¾æ–‡ä»¶å return error; // è¿”å›é”™è¯¯ç &#125; 123456789SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)&#123; return do_mkdirat(dfd, getname(pathname), mode); // æ‰§è¡Œdo_mkdiratç³»ç»Ÿè°ƒç”¨&#125;SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)&#123; return do_mkdirat(AT_FDCWD, getname(pathname), mode); // æ‰§è¡Œdo_mkdiratç³»ç»Ÿè°ƒç”¨ï¼Œä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ä½œä¸ºdfd&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * vfs_rmdir - åˆ é™¤ç›®å½• * @idmap: æŒ‚è½½ç‚¹çš„idmap * @dir: ç›®å½•çš„inode * @dentry: åŸºç¡€ç›®å½•çš„dentryæŒ‡é’ˆ * * åˆ é™¤ä¸€ä¸ªç›®å½•ã€‚ * * å¦‚æœé€šè¿‡idæ˜ å°„çš„æŒ‚è½½ç‚¹æ‰¾åˆ°äº†inodeï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚ * æ­¤å‡½æ•°å°†æ ¹æ®@idmapæ˜ å°„inodeï¼Œå¹¶åœ¨æ£€æŸ¥æƒé™ä¹‹å‰å¤„ç†æ˜ å°„ã€‚ * å¦‚æœæ˜¯éidæ˜ å°„çš„æŒ‚è½½ç‚¹ï¼Œæˆ–è€…éœ€è¦åœ¨åŸå§‹inodeä¸Šæ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry)&#123; int error = may_delete(idmap, dir, dentry, 1); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ é™¤ç›®å½•ï¼ŒåŒæ—¶æ ‡è®°ä¸ºrmdiræ“ä½œ if (error) return error; if (!dir-&gt;i_op-&gt;rmdir) // æ£€æŸ¥æ˜¯å¦æ”¯æŒrmdiræ“ä½œ return -EPERM; dget(dentry); // è·å–dentryçš„å¼•ç”¨ inode_lock(dentry-&gt;d_inode); // é”å®šdentryçš„inode error = -EBUSY; if (is_local_mountpoint(dentry) || (dentry-&gt;d_inode-&gt;i_flags &amp; S_KERNEL_FILE)) goto out; error = security_inode_rmdir(dir, dentry); // æ£€æŸ¥ç›®å½•çš„å®‰å…¨æ€§ if (error) goto out; error = dir-&gt;i_op-&gt;rmdir(dir, dentry); // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„rmdiræ“ä½œ if (error) goto out; shrink_dcache_parent(dentry); // æ¸…ç†dentryçš„çˆ¶ç›®å½•çš„dentryç¼“å­˜ dentry-&gt;d_inode-&gt;i_flags |= S_DEAD; // æ ‡è®°ç›®å½•çš„inodeä¸ºå·²åˆ é™¤ dont_mount(dentry); // å–æ¶ˆæŒ‚è½½ detach_mounts(dentry); // åˆ†ç¦»æŒ‚è½½ç‚¹out: inode_unlock(dentry-&gt;d_inode); // è§£é”dentryçš„inode dput(dentry); // é‡Šæ”¾dentryçš„å¼•ç”¨ if (!error) d_delete_notify(dir, dentry); // å‘é€ç›®å½•åˆ é™¤é€šçŸ¥ return error;&#125;EXPORT_SYMBOL(vfs_rmdir); // å¯¼å‡ºvfs_rmdirç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * vfs_rmdir - åˆ é™¤ç›®å½• * @idmap: æŒ‚è½½ç‚¹çš„idmap * @dir: ç›®å½•çš„inode * @dentry: åŸºç¡€ç›®å½•çš„dentryæŒ‡é’ˆ * * åˆ é™¤ä¸€ä¸ªç›®å½•ã€‚ * * å¦‚æœé€šè¿‡idæ˜ å°„çš„æŒ‚è½½ç‚¹æ‰¾åˆ°äº†inodeï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚ * æ­¤å‡½æ•°å°†æ ¹æ®@idmapæ˜ å°„inodeï¼Œå¹¶åœ¨æ£€æŸ¥æƒé™ä¹‹å‰å¤„ç†æ˜ å°„ã€‚ * å¦‚æœæ˜¯éidæ˜ å°„çš„æŒ‚è½½ç‚¹ï¼Œæˆ–è€…éœ€è¦åœ¨åŸå§‹inodeä¸Šæ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry)&#123; int error = may_delete(idmap, dir, dentry, 1); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ é™¤ç›®å½•ï¼ŒåŒæ—¶æ ‡è®°ä¸ºrmdiræ“ä½œ if (error) return error; if (!dir-&gt;i_op-&gt;rmdir) // æ£€æŸ¥æ˜¯å¦æ”¯æŒrmdiræ“ä½œ return -EPERM; dget(dentry); // è·å–dentryçš„å¼•ç”¨ inode_lock(dentry-&gt;d_inode); // é”å®šdentryçš„inode error = -EBUSY; if (is_local_mountpoint(dentry) || (dentry-&gt;d_inode-&gt;i_flags &amp; S_KERNEL_FILE)) goto out; error = security_inode_rmdir(dir, dentry); // æ£€æŸ¥ç›®å½•çš„å®‰å…¨æ€§ if (error) goto out; error = dir-&gt;i_op-&gt;rmdir(dir, dentry); // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„rmdiræ“ä½œ if (error) goto out; shrink_dcache_parent(dentry); // æ¸…ç†dentryçš„çˆ¶ç›®å½•çš„dentryç¼“å­˜ dentry-&gt;d_inode-&gt;i_flags |= S_DEAD; // æ ‡è®°ç›®å½•çš„inodeä¸ºå·²åˆ é™¤ dont_mount(dentry); // å–æ¶ˆæŒ‚è½½ detach_mounts(dentry); // åˆ†ç¦»æŒ‚è½½ç‚¹out: inode_unlock(dentry-&gt;d_inode); // è§£é”dentryçš„inode dput(dentry); // é‡Šæ”¾dentryçš„å¼•ç”¨ if (!error) d_delete_notify(dir, dentry); // å‘é€ç›®å½•åˆ é™¤é€šçŸ¥ return error;&#125;EXPORT_SYMBOL(vfs_rmdir); // å¯¼å‡ºvfs_rmdirç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int do_rmdir(int dfd, struct filename *name)&#123; int error; struct dentry *dentry; // ç›®å½•é¡¹æŒ‡é’ˆ struct path path; // è·¯å¾„ç»“æ„ä½“ struct qstr last; // æœ€åä¸€ä¸ªç»„ä»¶çš„qstrç»“æ„ä½“ int type; // æœ€åä¸€ä¸ªç»„ä»¶çš„ç±»å‹ unsigned int lookup_flags = 0; // æŸ¥æ‰¾æ ‡å¿—retry: error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); // è·å–çˆ¶ç›®å½•çš„è·¯å¾„å’Œæœ€åä¸€ä¸ªç»„ä»¶ if (error) goto exit1; switch (type) &#123; case LAST_DOTDOT: // å¦‚æœæœ€åä¸€ä¸ªç»„ä»¶æ˜¯&quot;..&quot; error = -ENOTEMPTY; // ç›®å½•éç©ºï¼Œæ— æ³•åˆ é™¤ goto exit2; case LAST_DOT: // å¦‚æœæœ€åä¸€ä¸ªç»„ä»¶æ˜¯&quot;.&quot; error = -EINVAL; // æ— æ•ˆçš„å‚æ•° goto exit2; case LAST_ROOT: // å¦‚æœæœ€åä¸€ä¸ªç»„ä»¶æ˜¯æ ¹ç›®å½• error = -EBUSY; // æ ¹ç›®å½•æ— æ³•åˆ é™¤ goto exit2; &#125; error = mnt_want_write(path.mnt); // è·å–vfsmountçš„å†™è®¿é—®æƒé™ if (error) goto exit2; inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); // é”å®šçˆ¶ç›®å½•çš„inode dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); // æŸ¥æ‰¾ç›®å½•é¡¹ error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto exit3; if (!dentry-&gt;d_inode) &#123; error = -ENOENT; // ç›®å½•é¡¹ä¸å­˜åœ¨ goto exit4; &#125; error = security_path_rmdir(&amp;path, dentry); // æ£€æŸ¥è·¯å¾„çš„å®‰å…¨æ€§ if (error) goto exit4; error = vfs_rmdir(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry); // è°ƒç”¨vfs_rmdiråˆ é™¤ç›®å½•exit4: dput(dentry); // é‡Šæ”¾ç›®å½•é¡¹çš„å¼•ç”¨exit3: inode_unlock(path.dentry-&gt;d_inode); // è§£é”çˆ¶ç›®å½•çš„inode mnt_drop_write(path.mnt); // é‡Šæ”¾vfsmountçš„å†™è®¿é—®æƒé™exit2: path_put(&amp;path); // é‡Šæ”¾è·¯å¾„ if (retry_estale(error, lookup_flags)) &#123; // å¦‚æœé”™è¯¯ç æŒ‡ç¤ºéœ€è¦é‡è¯•ï¼ˆå¯èƒ½æ˜¯ç”±äºNFSå¯¼è‡´çš„é”™è¯¯ï¼‰ lookup_flags |= LOOKUP_REVAL; // è®¾ç½®é‡è¯•æ ‡å¿— goto retry; // é‡è¯• &#125;exit1: putname(name); // é‡Šæ”¾æ–‡ä»¶å return error; // è¿”å›é”™è¯¯ç &#125; 1234SYSCALL_DEFINE1(rmdir, const char __user *, pathname)&#123; return do_rmdir(AT_FDCWD, getname(pathname)); // æ‰§è¡Œdo_rmdirç³»ç»Ÿè°ƒç”¨ï¼Œä½¿ç”¨å½“å‰å·¥ä½œç›®å½•ä½œä¸ºdfd&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * vfs_unlink - è§£é™¤æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡çš„é“¾æ¥ * @idmap: æŒ‚è½½ç‚¹çš„idmap * @dir: çˆ¶ç›®å½•çš„inode * @dentry: ç›®æ ‡ç›®å½•é¡¹ * @delegated_inode: å¦‚æœinodeå·²å§”æ´¾ï¼Œåˆ™è¿”å›ç›®æ ‡inode * * è°ƒç”¨è€…å¿…é¡»æŒæœ‰dir-&gt;i_mutexã€‚ * * å¦‚æœvfs_unlinkå‘ç°äº†å§”æ´¾å…³ç³»ï¼Œåˆ™è¿”å›-EWOULDBLOCKï¼Œå¹¶åœ¨delegated_inodeä¸­è¿”å›å¯¹inodeçš„å¼•ç”¨ã€‚ * è°ƒç”¨è€…åº”è¯¥åœ¨æ­¤inodeä¸Šè§£é™¤å§”æ´¾å¹¶é‡è¯•ã€‚ç”±äºè§£é™¤å§”æ´¾å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œè°ƒç”¨è€…åº”åœ¨è¿™æ ·åšä¹‹å‰é‡Šæ”¾dir-&gt;i_mutexã€‚ * * æˆ–è€…ï¼Œè°ƒç”¨è€…å¯ä»¥å°†delegated_inodeä¼ é€’ä¸ºNULLã€‚è¿™å¯èƒ½é€‚ç”¨äºé¢„æœŸåº•å±‚æ–‡ä»¶ç³»ç»Ÿæœªå¯¼å‡ºä¸ºNFSçš„è°ƒç”¨è€…ã€‚ * * å¦‚æœé€šè¿‡idæ˜ å°„çš„æŒ‚è½½ç‚¹æ‰¾åˆ°äº†inodeï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚ * æ­¤å‡½æ•°å°†æ ¹æ®@idmapæ˜ å°„inodeï¼Œå¹¶åœ¨æ£€æŸ¥æƒé™ä¹‹å‰å¤„ç†æ˜ å°„ã€‚ * å¦‚æœæ˜¯éidæ˜ å°„çš„æŒ‚è½½ç‚¹ï¼Œæˆ–è€…éœ€è¦åœ¨åŸå§‹inodeä¸Šæ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)&#123; struct inode *target = dentry-&gt;d_inode; // ç›®æ ‡inode int error = may_delete(idmap, dir, dentry, 0); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ é™¤æ–‡ä»¶ï¼ŒåŒæ—¶æ ‡è®°ä¸ºunlinkæ“ä½œ if (error) return error; if (!dir-&gt;i_op-&gt;unlink) // æ£€æŸ¥æ˜¯å¦æ”¯æŒunlinkæ“ä½œ return -EPERM; inode_lock(target); // é”å®šç›®æ ‡inode if (IS_SWAPFILE(target)) error = -EPERM; else if (is_local_mountpoint(dentry)) error = -EBUSY; else &#123; error = security_inode_unlink(dir, dentry); // æ£€æŸ¥ç›®å½•é¡¹çš„å®‰å…¨æ€§ if (!error) &#123; error = try_break_deleg(target, delegated_inode); // å°è¯•è§£é™¤å§”æ´¾å…³ç³» if (error) goto out; error = dir-&gt;i_op-&gt;unlink(dir, dentry); // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„unlinkæ“ä½œ if (!error) &#123; dont_mount(dentry); // å–æ¶ˆæŒ‚è½½ detach_mounts(dentry); // åˆ†ç¦»æŒ‚è½½ç‚¹ &#125; &#125; &#125;out: inode_unlock(target); // è§£é”ç›®æ ‡inode /* We don&#x27;t d_delete() NFS sillyrenamed files--they still exist. */ if (!error &amp;&amp; dentry-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) &#123; fsnotify_unlink(dir, dentry); // å‘é€æ–‡ä»¶è§£é™¤é“¾æ¥é€šçŸ¥ &#125; else if (!error) &#123; fsnotify_link_count(target); // æ›´æ–°é“¾æ¥è®¡æ•°å™¨ d_delete_notify(dir, dentry); // å‘é€ç›®å½•é¡¹åˆ é™¤é€šçŸ¥ &#125; return error; // è¿”å›é”™è¯¯ç &#125;EXPORT_SYMBOL(vfs_unlink); // å¯¼å‡ºvfs_unlinkç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * ç¡®ä¿æ–‡ä»¶çš„å®é™…æˆªæ–­å‘ç”Ÿåœ¨å…¶ç›®å½•çš„i_mutexä¹‹å¤–ã€‚ * å¦‚æœæœ‰å¤§é‡çš„å†™å‡ºæ“ä½œï¼Œæˆªæ–­å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›åœ¨ç­‰å¾…I/Oæ—¶é˜»æ­¢å¯¹ç›®å½•çš„è®¿é—®ã€‚ */int do_unlinkat(int dfd, struct filename *name)&#123; int error; struct dentry *dentry; // ç›®æ ‡ç›®å½•é¡¹ struct path path; // ç›®æ ‡è·¯å¾„ struct qstr last; // ç›®æ ‡åç§° int type; // ç›®æ ‡ç±»å‹ struct inode *inode = NULL; // ç›®æ ‡inode struct inode *delegated_inode = NULL; // å§”æ´¾çš„inode unsigned int lookup_flags = 0;retry: error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); // è·å–ç›®æ ‡è·¯å¾„çš„çˆ¶ç›®å½•å’Œåç§° if (error) goto exit1; error = -EISDIR; if (type != LAST_NORM) // ç›®æ ‡ä¸æ˜¯æ­£å¸¸çš„ç›®å½•é¡¹ goto exit2; error = mnt_want_write(path.mnt); // è·å–æŒ‚è½½ç‚¹å†™å…¥æƒé™ if (error) goto exit2;retry_deleg: inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); // é”å®šç›®å½•çš„çˆ¶ç›®å½• dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); // æŸ¥æ‰¾ç›®æ ‡ç›®å½•é¡¹ error = PTR_ERR(dentry); if (!IS_ERR(dentry)) &#123; /* ä¸ºä»€ä¹ˆä¸åœ¨æ­¤ä¹‹å‰ï¼Ÿå› ä¸ºæˆ‘ä»¬å¸Œæœ›å¾—åˆ°æ­£ç¡®çš„é”™è¯¯å€¼ */ if (last.name[last.len]) goto slashes; inode = dentry-&gt;d_inode; // ç›®æ ‡inode if (d_is_negative(dentry)) goto slashes; ihold(inode); // å¢åŠ inodeçš„å¼•ç”¨è®¡æ•° error = security_path_unlink(&amp;path, dentry); // æ£€æŸ¥è·¯å¾„çš„å®‰å…¨æ€§ if (error) goto exit3; error = vfs_unlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, &amp;delegated_inode); // è°ƒç”¨vfs_unlinkè§£é™¤é“¾æ¥æ“ä½œexit3: dput(dentry); // é‡Šæ”¾ç›®æ ‡ç›®å½•é¡¹ &#125; inode_unlock(path.dentry-&gt;d_inode); // è§£é”ç›®å½•çš„çˆ¶ç›®å½• if (inode) iput(inode); /* åœ¨æ­¤å¤„æˆªæ–­inode */ inode = NULL; if (delegated_inode) &#123; error = break_deleg_wait(&amp;delegated_inode); // ç­‰å¾…è§£é™¤å§”æ´¾ if (!error) goto retry_deleg; &#125; mnt_drop_write(path.mnt); // é‡Šæ”¾æŒ‚è½½ç‚¹å†™å…¥æƒé™exit2: path_put(&amp;path); // é‡Šæ”¾è·¯å¾„ if (retry_estale(error, lookup_flags)) &#123; // æ£€æŸ¥é”™è¯¯ç æ˜¯å¦è¡¨ç¤ºéœ€è¦é‡æ–°éªŒè¯ lookup_flags |= LOOKUP_REVAL; inode = NULL; goto retry; &#125;exit1: putname(name); // é‡Šæ”¾æ–‡ä»¶å return error;slashes: if (d_is_negative(dentry)) error = -ENOENT; else if (d_is_dir(dentry)) error = -EISDIR; else error = -ENOTDIR; goto exit3;&#125; 1234567891011121314SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)&#123; if ((flag &amp; ~AT_REMOVEDIR) != 0) // æ£€æŸ¥æ ‡å¿—ä½æ˜¯å¦æœ‰æ•ˆ return -EINVAL; if (flag &amp; AT_REMOVEDIR) // å¦‚æœæ ‡å¿—ä½æŒ‡ç¤ºç§»é™¤ç›®å½• return do_rmdir(dfd, getname(pathname)); // è°ƒç”¨do_rmdirå‡½æ•°ç§»é™¤ç›®å½• return do_unlinkat(dfd, getname(pathname)); // å¦åˆ™è°ƒç”¨do_unlinkatå‡½æ•°è§£é™¤é“¾æ¥&#125;SYSCALL_DEFINE1(unlink, const char __user *, pathname)&#123; return do_unlinkat(AT_FDCWD, getname(pathname)); // è°ƒç”¨do_unlinkatå‡½æ•°è§£é™¤é“¾æ¥ï¼Œå¹¶ä½¿ç”¨AT_FDCWDä½œä¸ºdfdå‚æ•°&#125; 1234567891011121314151617181920212223242526272829303132333435/** * vfs_symlink - åˆ›å»ºç¬¦å·é“¾æ¥ * @idmap: æŒ‡å‘inodeæ‰€åœ¨æŒ‚è½½ç‚¹çš„idmap * @dir: ç›®å½•çš„inode * @dentry: åŸºç¡€ç›®å½•çš„dentryæŒ‡é’ˆ * @oldname: è¦é“¾æ¥çš„æ–‡ä»¶çš„åç§° * * åˆ›å»ºä¸€ä¸ªç¬¦å·é“¾æ¥ã€‚ * * å¦‚æœé€šè¿‡idmappedæŒ‚è½½ç‚¹æ‰¾åˆ°äº†inodeï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚ * æ­¤å‡½æ•°å°†è´Ÿè´£æ ¹æ®@idmapå°†inodeæ˜ å°„ï¼Œç„¶åæ£€æŸ¥æƒé™ã€‚ * å¦‚æœæ˜¯éidmappedæŒ‚è½½ç‚¹ï¼Œæˆ–è€…éœ€è¦å¯¹åŸå§‹inodeè¿›è¡Œæƒé™æ£€æŸ¥ï¼Œåˆ™åªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */int vfs_symlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, const char *oldname)&#123; int error; error = may_create(idmap, dir, dentry); // æ£€æŸ¥æ˜¯å¦å…è®¸åˆ›å»º if (error) return error; if (!dir-&gt;i_op-&gt;symlink) return -EPERM; error = security_inode_symlink(dir, dentry, oldname); // æ£€æŸ¥å®‰å…¨æ€§ if (error) return error; error = dir-&gt;i_op-&gt;symlink(idmap, dir, dentry, oldname); // è°ƒç”¨inodeçš„symlinkæ“ä½œ if (!error) fsnotify_create(dir, dentry); // å‘é€æ–‡ä»¶åˆ›å»ºé€šçŸ¥ return error;&#125;EXPORT_SYMBOL(vfs_symlink); 12345678910111213141516171819202122232425262728293031int do_symlinkat(struct filename *from, int newdfd, struct filename *to)&#123; int error; struct dentry *dentry; struct path path; unsigned int lookup_flags = 0; if (IS_ERR(from)) &#123; error = PTR_ERR(from); goto out_putnames; &#125;retry: dentry = filename_create(newdfd, to, &amp;path, lookup_flags); // åˆ›å»ºdentryå’Œpath error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto out_putnames; error = security_path_symlink(&amp;path, dentry, from-&gt;name); // æ£€æŸ¥è·¯å¾„çš„å®‰å…¨æ€§ if (!error) error = vfs_symlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, from-&gt;name); // è°ƒç”¨vfs_symlinkåˆ›å»ºç¬¦å·é“¾æ¥ done_path_create(&amp;path, dentry); // å®Œæˆè·¯å¾„å’Œdentryçš„åˆ›å»º if (retry_estale(error, lookup_flags)) &#123; lookup_flags |= LOOKUP_REVAL; goto retry; &#125;out_putnames: putname(to); // é‡Šæ”¾toçš„åç§° putname(from); // é‡Šæ”¾fromçš„åç§° return error;&#125; 123456SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,int, newdfd, const char __user *, newname)&#123;return do_symlinkat(getname(oldname), newdfd, getname(newname));&#125;//è¿™æ˜¯ä¸€ä¸ªåä¸ºsymlinkatçš„ç³»ç»Ÿè°ƒç”¨å‡½æ•°å®šä¹‰ã€‚å®ƒæ¥å—ä¸‰ä¸ªå‚æ•°ï¼šoldnameï¼ˆæŒ‡å‘æ—§æ–‡ä»¶åçš„ç”¨æˆ·ç©ºé—´æŒ‡é’ˆï¼‰ã€newdfdï¼ˆæ–°æ–‡ä»¶æè¿°ç¬¦ï¼‰å’Œnewnameï¼ˆæŒ‡å‘æ–°æ–‡ä»¶åçš„ç”¨æˆ·ç©ºé—´æŒ‡é’ˆï¼‰ã€‚è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯åœ¨æŒ‡å®šçš„ç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªç¬¦å·é“¾æ¥ã€‚ 12345SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)&#123;return do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));&#125;//è¿™æ˜¯ä¸€ä¸ªåä¸ºsymlinkçš„ç³»ç»Ÿè°ƒç”¨å‡½æ•°å®šä¹‰ã€‚å®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼šoldnameï¼ˆæŒ‡å‘æ—§æ–‡ä»¶åçš„ç”¨æˆ·ç©ºé—´æŒ‡é’ˆï¼‰å’Œnewnameï¼ˆæŒ‡å‘æ–°æ–‡ä»¶åçš„ç”¨æˆ·ç©ºé—´æŒ‡é’ˆï¼‰ã€‚è¯¥å‡½æ•°çš„ä½œç”¨æ˜¯åœ¨å½“å‰å·¥ä½œç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªç¬¦å·é“¾æ¥ã€‚å®ƒè°ƒç”¨äº†do_symlinkatå‡½æ•°ï¼Œå°†AT_FDCWDä½œä¸ºæ–°æ–‡ä»¶æè¿°ç¬¦ä¼ é€’ç»™å®ƒï¼Œè¡¨ç¤ºå½“å‰å·¥ä½œç›®å½•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * vfs_link - åˆ›å»ºä¸€ä¸ªæ–°çš„ç¡¬é“¾æ¥ * @old_dentry:è¦é“¾æ¥çš„å¯¹è±¡ * @idmap:æŒ‚è½½ç‚¹çš„idmap * @dir:æ–°çš„çˆ¶ç›®å½• * @new_dentry:æ–°é“¾æ¥çš„ä½ç½® * @delegated_inode: éœ€è¦ä¸­æ–­å§”æ‰˜çš„inode * * è°ƒç”¨è€…å¿…é¡»æŒæœ‰dir-&gt;i_mutex * * å¦‚æœvfs_linkå‘ç°éœ€è¦ä¸­æ–­çš„å¾…é“¾æ¥æ–‡ä»¶ä¸Šå­˜åœ¨å§”æ‰˜ï¼Œå®ƒå°†è¿”å›-EWOULDBLOCKï¼Œå¹¶è¿”å›å¯¹å§”æ‰˜inodeçš„å¼•ç”¨ã€‚ * è°ƒç”¨è€…åº”è¯¥åœ¨ä¸­æ–­å§”æ‰˜ä¹‹å‰é‡Šæ”¾i_mutexå¹¶é‡è¯•ã€‚å› ä¸ºä¸­æ–­å§”æ‰˜å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œæ‰€ä»¥è°ƒç”¨è€…åº”è¯¥åœ¨è¿™æ ·åšä¹‹å‰é‡Šæ”¾i_mutexã€‚ * * æˆ–è€…ï¼Œè°ƒç”¨è€…å¯ä»¥å°†delegated_inodeä¼ é€’ä¸ºNULLã€‚è¿™å¯¹äºé¢„æœŸåº•å±‚æ–‡ä»¶ç³»ç»Ÿä¸æ˜¯NFSå¯¼å‡ºçš„è°ƒç”¨è€…å¯èƒ½æ˜¯åˆé€‚çš„ã€‚ * * å¦‚æœé€šè¿‡idmappedæŒ‚è½½æ‰¾åˆ°äº†inodeï¼Œåˆ™å¿…é¡»é€šè¿‡@idmapä¼ é€’vfsmountçš„idmapã€‚æ­¤å‡½æ•°å°†è´Ÿè´£æ ¹æ®@idmapæ˜ å°„inodeï¼Œç„¶åæ£€æŸ¥æƒé™ã€‚ * å¯¹äºéidmappedæŒ‚è½½æˆ–è€…å¦‚æœè¦å¯¹åŸå§‹inodeæ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’@nop_mnt_idmapã€‚ */int vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)&#123;struct inode *inode = old_dentry-&gt;d_inode;unsigned max_links = dir-&gt;i_sb-&gt;s_max_links;int error;if (!inode)return -ENOENT;error = may_create(idmap, dir, new_dentry);if (error)return error;if (dir-&gt;i_sb != inode-&gt;i_sb)return -EXDEV;/* * ä¸èƒ½åˆ›å»ºæŒ‡å‘åªè¿½åŠ æˆ–åªè¯»çš„æ–‡ä»¶çš„é“¾æ¥ã€‚ */if (IS_APPEND(inode) || IS_IMMUTABLE(inode))return -EPERM;/* * å¦‚æœçœŸå®å€¼å¯¹äºvfsæœªçŸ¥ï¼Œæ›´æ–°é“¾æ¥è®¡æ•°å¯èƒ½ä¼šå¯¼è‡´i_uidå’Œi_gidè¢«é”™è¯¯åœ°å†™å›ã€‚ */if (HAS_UNMAPPED_ID(idmap, inode))return -EPERM;if (!dir-&gt;i_op-&gt;link)return -EPERM;if (S_ISDIR(inode-&gt;i_mode))return -EPERM;error = security_inode_link(old_dentry, dir, new_dentry);if (error)return error;inode_lock(inode);/* ç¡®ä¿æˆ‘ä»¬ä¸å…è®¸åˆ›å»ºæŒ‡å‘æœªé“¾æ¥æ–‡ä»¶çš„ç¡¬é“¾æ¥ */if (inode-&gt;i_nlink == 0 &amp;&amp; !(inode-&gt;i_state &amp; I_LINKABLE))error = -ENOENT;else if (max_links &amp;&amp; inode-&gt;i_nlink &gt;= max_links)error = -EMLINK;else &#123;error = try_break_deleg(inode, delegated_inode);if (!error)error = dir-&gt;i_op-&gt;link(old_dentry, dir, new_dentry);&#125;if (!error &amp;&amp; (inode-&gt;i_state &amp; I_LINKABLE)) &#123;spin_lock(&amp;inode-&gt;i_lock);inode-&gt;i_state &amp;= ~I_LINKABLE;spin_unlock(&amp;inode-&gt;i_lock);&#125;inode_unlock(inode);if (!error)fsnotify_link(dir, inode, new_dentry);return error;&#125;EXPORT_SYMBOL(vfs_link); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* * Hardlinks are often used in delicate situations. We avoid * security-related surprises by not following symlinks on the * newname. --KAB * * We don&#x27;t follow them on the oldname either to be compatible * with linux 2.0, and to avoid hard-linking to directories * and other special files. --ADM */int do_linkat(int olddfd, struct filename *old, int newdfd, struct filename *new, int flags)&#123;struct mnt_idmap *idmap; // æŒ‚è½½IDæ˜ å°„struct dentry *new_dentry; // æ–°æ–‡ä»¶çš„ç›®å½•é¡¹struct path old_path, new_path; // æ—§æ–‡ä»¶å’Œæ–°æ–‡ä»¶çš„è·¯å¾„struct inode *delegated_inode = NULL; // å§”æ´¾çš„inodeint how = 0; // æŸ¥æ‰¾æ ‡å¿—int error; // é”™è¯¯ç if ((flags &amp; ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) &#123;error = -EINVAL; // æ— æ•ˆçš„æ ‡å¿—goto out_putnames;&#125;/* * To use null names we require CAP_DAC_READ_SEARCH * This ensures that not everyone will be able to create * handlink using the passed filedescriptor. */if (flags &amp; AT_EMPTY_PATH &amp;&amp; !capable(CAP_DAC_READ_SEARCH)) &#123;error = -ENOENT; // æ— æ³•ä½¿ç”¨ç©ºåç§°åˆ›å»ºç¡¬é“¾æ¥goto out_putnames;&#125;if (flags &amp; AT_SYMLINK_FOLLOW)how |= LOOKUP_FOLLOW; // å¯ç”¨è·Ÿéšç¬¦å·é“¾æ¥retry:error = filename_lookup(olddfd, old, how, &amp;old_path, NULL); // æŸ¥æ‰¾æ—§æ–‡ä»¶if (error)goto out_putnames;new_dentry = filename_create(newdfd, new, &amp;new_path,(how &amp; LOOKUP_REVAL)); // åˆ›å»ºæ–°æ–‡ä»¶çš„ç›®å½•é¡¹error = PTR_ERR(new_dentry);if (IS_ERR(new_dentry))goto out_putpath;error = -EXDEV; // ä¸å…è®¸è·¨è®¾å¤‡ç¡¬é“¾æ¥if (old_path.mnt != new_path.mnt)goto out_dput;idmap = mnt_idmap(new_path.mnt); // è·å–æŒ‚è½½IDæ˜ å°„error = may_linkat(idmap, &amp;old_path); // æ£€æŸ¥æ˜¯å¦æœ‰æƒé™åˆ›å»ºç¡¬é“¾æ¥if (unlikely(error))goto out_dput;error = security_path_link(old_path.dentry, &amp;new_path, new_dentry); // å®‰å…¨æ£€æŸ¥if (error)goto out_dput;error = vfs_link(old_path.dentry, idmap, new_path.dentry-&gt;d_inode, new_dentry, &amp;delegated_inode); // åˆ›å»ºç¡¬é“¾æ¥out_dput:done_path_create(&amp;new_path, new_dentry); // é‡Šæ”¾æ–°æ–‡ä»¶çš„è·¯å¾„å’Œç›®å½•é¡¹if (delegated_inode) &#123;error = break_deleg_wait(&amp;delegated_inode); // ä¸­æ–­å§”æ´¾å¹¶é‡è¯•é“¾æ¥æ“ä½œif (!error) &#123;path_put(&amp;old_path);goto retry;&#125;&#125;if (retry_estale(error, how)) &#123;path_put(&amp;old_path);how |= LOOKUP_REVAL; // é‡æ–°éªŒè¯æ–‡ä»¶å¥æŸ„goto retry;&#125;out_putpath:path_put(&amp;old_path); // é‡Šæ”¾æ—§æ–‡ä»¶çš„è·¯å¾„out_putnames:putname(old); // é‡Šæ”¾æ—§æ–‡ä»¶çš„æ–‡ä»¶åputname(new); // é‡Šæ”¾æ–°æ–‡ä»¶çš„æ–‡ä»¶åreturn error; // è¿”å›é”™è¯¯ç &#125; 12345678910111213141516SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,int, newdfd, const char __user *, newname, int, flags)&#123;return do_linkat(olddfd, getname_uflags(oldname, flags),newdfd, getname(newname), flags);&#125;// å®šä¹‰ç³»ç»Ÿè°ƒç”¨å‡½æ•°linkatï¼Œæ¥å—äº”ä¸ªå‚æ•°ï¼šolddfdè¡¨ç¤ºæ—§ç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼Œoldnameè¡¨ç¤ºæ—§æ–‡ä»¶è·¯å¾„åï¼Œ// newdfdè¡¨ç¤ºæ–°ç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼Œnewnameè¡¨ç¤ºæ–°æ–‡ä»¶è·¯å¾„åï¼Œflagsè¡¨ç¤ºé“¾æ¥é€‰é¡¹SYSCALL_DEFINE2(link, const char __user \\*, oldname, const char __user *, newname)&#123;return do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);&#125;// å®šä¹‰ç³»ç»Ÿè°ƒç”¨å‡½æ•°linkï¼Œæ¥å—ä¸¤ä¸ªå‚æ•°ï¼šoldnameè¡¨ç¤ºæ—§æ–‡ä»¶è·¯å¾„åï¼Œnewnameè¡¨ç¤ºæ–°æ–‡ä»¶è·¯å¾„åã€‚// åœ¨å‡½æ•°å†…éƒ¨è°ƒç”¨linkatç³»ç»Ÿè°ƒç”¨å‡½æ•°ï¼Œä½¿ç”¨AT_FDCWDä½œä¸ºæ—§ç›®å½•æ–‡ä»¶æè¿°ç¬¦å’Œæ–°ç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼Œ// é€šè¿‡getnameå‡½æ•°è·å–æ—§æ–‡ä»¶è·¯å¾„åå’Œæ–°æ–‡ä»¶è·¯å¾„åï¼Œå¹¶å°†é“¾æ¥é€‰é¡¹è®¾ç½®ä¸º0ã€‚ 1234567891011121314151617181920212223242526272829303132333435/*** vfs_rename - é‡å‘½åä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿå¯¹è±¡ * @rd: æŒ‡å‘é‡å‘½åä¿¡æ¯çš„renamedataç»“æ„ä½“æŒ‡é’ˆ** è°ƒç”¨è€…å¿…é¡»æŒæœ‰å¤šä¸ªäº’æ–¥é” - å‚è§lock_rename()ã€‚* * å¦‚æœvfs_renameåœ¨æºç›®å½•æˆ–ç›®æ ‡ç›®å½•å‘ç°éœ€è¦ç ´åçš„å§”æ‰˜,* å®ƒå°†è¿”å›-EWOULDBLOCKå¹¶è¿”å›delegated_inodeä¸­çš„ä¸€ä¸ªinodeå¼•ç”¨ã€‚* è°ƒç”¨è€…åº”è¯¥æ–­å¼€å§”æ‰˜å¹¶é‡è¯•ã€‚ç”±äºæ–­å¼€å§”æ‰˜å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´,* è°ƒç”¨è€…åº”è¯¥åœ¨æ­¤ä¹‹å‰é‡Šæ”¾æ‰€æœ‰é”ã€‚** æˆ–è€…,è°ƒç”¨è€…å¯ä»¥ä¸ºdelegated_inodeä¼ å…¥NULLã€‚* è¿™å¯èƒ½é€‚åˆé¢„æœŸåº•å±‚æ–‡ä»¶ç³»ç»Ÿæ²¡æœ‰NFSå¯¼å‡ºçš„è°ƒç”¨è€…ã€‚** å‘½åç©ºé—´æ“ä½œä¸­æœ€ç³Ÿç³•çš„æ˜¯é‡å‘½åç›®å½•ã€‚â€œä¸æ­£å½“â€ç”šè‡³æ— æ³•å¼€å§‹æè¿°å®ƒã€‚* åŠ å·å¤§å­¦ä¼¯å…‹åˆ©åˆ†æ ¡çš„æŸäººtripäº†ä¸€åœº......é—®é¢˜:* * a) æˆ‘ä»¬å¯èƒ½è¿›å…¥å¾ªç¯åˆ›å»ºã€‚* b) ç«äº‰é£é™© - ä¸¤ä¸ªæ— è¾œçš„é‡å‘½åå¯ä»¥ä¸€èµ·åˆ›å»ºä¸€ä¸ªå¾ªç¯ã€‚* è¿™å°±æ˜¯4.4å‡ºé”™çš„åœ°æ–¹ã€‚ å½“å‰ä¿®å¤: åœ¨sb-&gt;s_vfs_rename_mutexä¸Šåºåˆ—åŒ–ã€‚* æˆ‘ä»¬å¯èƒ½ä¼šæ›´å‡†ç¡®,ä½†é‚£æ˜¯å¦ä¸€ä¸ªæ•…äº‹ã€‚* c) æˆ‘ä»¬å¿…é¡»é”å®šå››ä¸ªå¯¹è±¡ â€“ çˆ¶ç›®å½•å’Œå—å®³è€…(å¦‚æœå­˜åœ¨),* ä»¥åŠæº(å¦‚æœå®ƒä¸æ˜¯ä¸€ä¸ªç›®å½•)ã€‚* è€Œä¸” - åœ¨æˆ‘ä»¬å¯¹çˆ¶ç›®å½•è·å–-&gt;i_mutexä¹‹å(ç›´åˆ°ç„¶åæˆ‘ä»¬ä¸çŸ¥é“ç›®æ ‡æ˜¯å¦å­˜åœ¨)ã€‚* è§£å†³æ–¹æ¡ˆ: å°è¯•é€šè¿‡é”å®šé¡ºåºæ¥æ™ºèƒ½é”å®šèŠ‚ç‚¹ã€‚ æˆ‘ä»¬ä¾èµ–è¿™æ ·çš„äº‹å®:* ä»…åœ¨-&gt;s_vfs_rename_mutexä¸‹æ‰èƒ½æ”¹å˜æ ‘æ‹“æ‰‘,_and_ å¯¹è±¡çš„çˆ¶ç›®å½•æˆ‘ä»¬ç§»åŠ¨å°†è¢«é”å®šã€‚* è¿™æ ·,æˆ‘ä»¬å¯ä»¥é€šè¿‡æ ‘(å…ˆç¥–å…ˆ)å¯¹ç›®å½•è¿›è¡Œæ’å,å¹¶åœ¨å®ƒä»¬ä¹‹åæ’åæ‰€æœ‰éç›®å½•ã€‚* è¿™æœ‰æ•ˆ,å› ä¸ºé™¤äº†é‡å‘½åä¹‹å¤–çš„æ‰€æœ‰å¯¹è±¡éƒ½â€œé”å®šçˆ¶ç›®å½•,æŸ¥æ‰¾,é”å®šå­ç›®å½•â€,* è€Œé‡å‘½ååœ¨-&gt;s_vfs_rename_mutexä¸‹ã€‚* ç„¶è€Œ,å®ƒä¾èµ–äºè¿™æ ·çš„å‡è®¾:ä»»ä½•å…·æœ‰-&gt;lookup()çš„å¯¹è±¡éƒ½ä¸ä¼šæœ‰å¤šä¸ªdentryã€‚* å¦‚æœâ€œæ··åˆâ€å¯¹è±¡å‡ºç°,æˆ‘ä»¬æœ€å¥½ç¡®ä¿å®ƒä»¬æ²¡æœ‰é“¾æ¥(2)ã€‚* d) ä»fhandleè½¬æ¢ä¸ºdentryå¯èƒ½åœ¨é”™è¯¯çš„æ—¶åˆ»åˆ°æ¥ - å½“æˆ‘ä»¬åˆ é™¤ç›®æ ‡æ—¶ã€‚* è§£å†³æ–¹æ¡ˆ:æˆ‘ä»¬å°†ä¸å¾—ä¸åœ¨fhandle_to_dentryä»£ç ä¸­è·å–-&gt;i_mutexã€‚* [FIXME - å½“å‰çš„nfsfh.cä¾èµ–äºçˆ¶-&gt;i_mutex,è¿™æœ‰æ•ˆä½†å¯¼è‡´ä¸€äº›éå¸¸è¿‡åº¦çš„é”å®š]ã€‚*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194int vfs_rename(struct renamedata *rd)&#123; // å£°æ˜é”™è¯¯ç  int error; // å£°æ˜è€ç›®å½•å’Œæ–°ç›®å½•çš„inodeæŒ‡é’ˆ struct inode *old_dir = rd-&gt;old_dir, *new_dir = rd-&gt;new_dir; // å£°æ˜è€ç›®å½•é¡¹å’Œæ–°ç›®å½•é¡¹çš„dentryæŒ‡é’ˆ struct dentry *old_dentry = rd-&gt;old_dentry; struct dentry *new_dentry = rd-&gt;new_dentry; // å§”æ‰˜inodeæŒ‡é’ˆ struct inode **delegated_inode = rd-&gt;delegated_inode; // æ ‡å¿— unsigned int flags = rd-&gt;flags; // è€ç›®å½•é¡¹æ˜¯å¦æ˜¯ç›®å½• bool is_dir = d_is_dir(old_dentry); // è€ç›®å½•é¡¹å¯¹åº”çš„inode struct inode *source = old_dentry-&gt;d_inode; // æ–°ç›®å½•é¡¹å¯¹åº”çš„inode struct inode *target = new_dentry-&gt;d_inode; // æ–°ç›®å½•é¡¹æ˜¯å¦æ˜¯ç›®å½• bool new_is_dir = false; // æœ€å¤§é“¾æ¥æ•° unsigned max_links = new_dir-&gt;i_sb-&gt;s_max_links; // è€ç›®å½•é¡¹åç§°å¿«ç…§ struct name_snapshot old_name; // å¦‚æœæºå’Œç›®æ ‡æ˜¯åŒä¸€ä¸ªinode,è¿”å›0 if (source == target) return 0; // æ£€æŸ¥åˆ é™¤è€ç›®å½•é¡¹çš„æƒé™ error = may_delete(rd-&gt;old_mnt_idmap, old_dir, old_dentry, is_dir); if (error) return error; // å¦‚æœç›®æ ‡ç›®å½•é¡¹ä¸å­˜åœ¨,æ£€æŸ¥æ–°å»ºç›®å½•é¡¹çš„æƒé™ if (!target) &#123; error = may_create(rd-&gt;new_mnt_idmap, new_dir, new_dentry); &#125; else &#123; // ç›®æ ‡ç›®å½•é¡¹æ˜¯å¦æ˜¯ç›®å½• new_is_dir = d_is_dir(new_dentry); // å¦‚æœä¸æ˜¯äº¤æ¢é‡å‘½å,æ£€æŸ¥åˆ é™¤ç›®æ ‡ç›®å½•é¡¹çš„æƒé™ if (!(flags &amp; RENAME_EXCHANGE)) error = may_delete(rd-&gt;new_mnt_idmap, new_dir, new_dentry, is_dir); else // å¦‚æœæ˜¯äº¤æ¢é‡å‘½å,æ£€æŸ¥åˆ é™¤æ–°ç›®å½•é¡¹çš„æƒé™ error = may_delete(rd-&gt;new_mnt_idmap, new_dir, new_dentry, new_is_dir); &#125; if (error) return error; // æ£€æŸ¥è€ç›®å½•inodeæ˜¯å¦æ”¯æŒé‡å‘½åæ“ä½œ if (!old_dir-&gt;i_op-&gt;rename) return -EPERM; // å¦‚æœæ›´æ”¹çˆ¶ç›®å½•,æ£€æŸ¥å†™æƒé™,éœ€è¦ç¿»è½¬â€œ..â€ if (new_dir != old_dir) &#123; if (is_dir) &#123; // å¦‚æœæºæ˜¯ç›®å½•,æ£€æŸ¥å†™æƒé™ error = inode_permission(rd-&gt;old_mnt_idmap, source, MAY_WRITE); if (error) return error; &#125; if ((flags &amp; RENAME_EXCHANGE) &amp;&amp; new_is_dir) &#123; // å¦‚æœäº¤æ¢é‡å‘½åä¸”æ–°ç›®å½•é¡¹æ˜¯ç›®å½•,æ£€æŸ¥ç›®æ ‡å†™æƒé™ error = inode_permission(rd-&gt;new_mnt_idmap, target, MAY_WRITE); if (error) return error; &#125; &#125; // å®‰å…¨æ£€æŸ¥ error = security_inode_rename(...); if (error) return error; // è·å–è€ç›®å½•é¡¹åç§°å¿«ç…§ take_dentry_name_snapshot(&amp;old_name, old_dentry); // å¢åŠ æ–°ç›®å½•é¡¹å¼•ç”¨è®¡æ•° dget(new_dentry); // åŠ é” if (!is_dir || (flags &amp; RENAME_EXCHANGE)) lock_two_nondirectories(source, target); else if (target) inode_lock(target); // æƒé™æ£€æŸ¥ error = -EPERM; if (IS_SWAPFILE(source) || (target &amp;&amp; IS_SWAPFILE(target))) goto out; // æ£€æŸ¥æŒ‚è½½ç‚¹ error = -EBUSY; if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry)) goto out; // æ£€æŸ¥æœ€å¤§é“¾æ¥æ•° if (max_links &amp;&amp; new_dir != old_dir) &#123; error = -EMLINK; if (is_dir &amp;&amp; !new_is_dir &amp;&amp; new_dir-&gt;i_nlink &gt;= max_links) goto out; if ((flags &amp; RENAME_EXCHANGE) &amp;&amp; !is_dir &amp;&amp; new_is_dir &amp;&amp; old_dir-&gt;i_nlink &gt;= max_links) goto out; &#125; // å°è¯•ä¸­æ–­å§”æ‰˜ if (!is_dir) &#123; error = try_break_deleg(source, delegated_inode); if (error) goto out; &#125; if (target &amp;&amp; !new_is_dir) &#123; error = try_break_deleg(target, delegated_inode); if (error) goto out; &#125; // è°ƒç”¨ç›®å½•inodeçš„é‡å‘½åæ–¹æ³• error = old_dir-&gt;i_op-&gt;rename(rd-&gt;new_mnt_idmap, old_dir, old_dentry, new_dir, new_dentry, flags); if (error) goto out; // å¦‚æœä¸æ˜¯äº¤æ¢é‡å‘½åä¸”ç›®æ ‡ç›®å½•é¡¹å­˜åœ¨ if (!(flags &amp; RENAME_EXCHANGE) &amp;&amp; target) &#123; // å¦‚æœæºæ˜¯ç›®å½• if (is_dir) &#123; // ç¼©å°æ–°ç›®å½•é¡¹çš„dcache shrink_dcache_parent(new_dentry); // æ ‡è®°ç›®æ ‡inodeå·²æ­» target-&gt;i_flags |= S_DEAD; &#125; // ç¦æ­¢åœ¨æ–°ç›®å½•é¡¹æŒ‚è½½ dont_mount(new_dentry); // åˆ†ç¦»æ–°ç›®å½•é¡¹çš„æŒ‚è½½ detach_mounts(new_dentry);&#125;// å¦‚æœæ–‡ä»¶ç³»ç»Ÿä¸æ”¯æŒd_moveif (!(old_dir-&gt;i_sb-&gt;s_type-&gt;fs_flags &amp; FS_RENAME_DOES_D_MOVE)) &#123; // å¦‚æœä¸æ˜¯äº¤æ¢é‡å‘½å if (!(flags &amp; RENAME_EXCHANGE)) // ç§»åŠ¨è€ç›®å½•é¡¹åˆ°æ–°ç›®å½•é¡¹ d_move(old_dentry, new_dentry); else // äº¤æ¢ä¸¤ä¸ªç›®å½•é¡¹ d_exchange(old_dentry, new_dentry);&#125;// è§£é”out:if (!is_dir || (flags &amp; RENAME_EXCHANGE)) unlock_two_nondirectories(source, target);else if (target) inode_unlock(target);// å‡å°‘æ–°ç›®å½•é¡¹çš„å¼•ç”¨è®¡æ•° dput(new_dentry);if (!error) &#123; // å‘é€ç›®å½•é¡¹ç§»åŠ¨äº‹ä»¶é€šçŸ¥ fsnotify_move(old_dir, new_dir, &amp;old_name.name, is_dir, !(flags &amp; RENAME_EXCHANGE) ? target : NULL, old_dentry); if (flags &amp; RENAME_EXCHANGE) &#123; // å¦‚æœæ˜¯äº¤æ¢é‡å‘½å,äº¤æ¢äº‹ä»¶é€šçŸ¥å‚æ•° fsnotify_move(new_dir, old_dir, &amp;old_dentry-&gt;d_name, new_is_dir, NULL, new_dentry); &#125;&#125;// é‡Šæ”¾è€ç›®å½•é¡¹åç§°å¿«ç…§release_dentry_name_snapshot(&amp;old_name);// è¿”å›é”™è¯¯ç return error;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** do_renameat2 - å®ç°é‡å‘½åç³»ç»Ÿè°ƒç”¨renameat2* @olddfd: æºæ–‡ä»¶ç›®å½•æ–‡ä»¶æè¿°ç¬¦* @from: æºæ–‡ä»¶å* @newdfd: ç›®æ ‡æ–‡ä»¶ç›®å½•æ–‡ä»¶æè¿°ç¬¦ * @to: ç›®æ ‡æ–‡ä»¶å* @flags: æ ‡å¿—ä½** è¿”å›å€¼:* 0 - æˆåŠŸ* è´Ÿå€¼ - é”™è¯¯ç */int do_renameat2(int olddfd, struct filename *from, int newdfd, struct filename *to, unsigned int flags)&#123; // é‡å‘½åæ•°æ® struct renamedata rd; // æºç›®å½•é¡¹å’Œç›®æ ‡ç›®å½•é¡¹ struct dentry *old_dentry, *new_dentry; // é”å®šæ—¶ç”¨äºæ£€æµ‹ç¯çš„ä¸­é—´ç›®å½•é¡¹ struct dentry *trap; // æºè·¯å¾„å’Œç›®æ ‡è·¯å¾„ struct path old_path, new_path; // æºç›®å½•é¡¹å’Œç›®æ ‡ç›®å½•é¡¹æœ€åä¸€ä¸ªcomponent struct qstr old_last, new_last; // ç›®å½•é¡¹ç±»å‹ int old_type, new_type; // å§”æ‰˜çš„inode struct inode *delegated_inode = NULL; // æŸ¥æ‰¾æ ‡å¿— unsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET; // æ˜¯å¦éœ€è¦é‡è¯•æ ‡å¿— bool should_retry = false; int error = -EINVAL; // å‚æ•°æ£€æŸ¥ if (flags &amp; ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT)) goto put_names; if ((flags &amp; (RENAME_NOREPLACE | RENAME_WHITEOUT)) &amp;&amp; (flags &amp; RENAME_EXCHANGE)) goto put_names; if (flags &amp; RENAME_EXCHANGE) target_flags = 0;retry: // è·å–æºæ–‡ä»¶è·¯å¾„ error = filename_parentat(olddfd, from, lookup_flags, &amp;old_path, &amp;old_last, &amp;old_type); if (error) goto put_names; // è·å–ç›®æ ‡æ–‡ä»¶è·¯å¾„ error = filename_parentat(newdfd, to, lookup_flags, &amp;new_path, &amp;new_last, &amp;new_type); if (error) goto exit1; // ä¸åŒæ–‡ä»¶ç³»ç»Ÿ error = -EXDEV; if (old_path.mnt != new_path.mnt) goto exit2; // æºæ–‡ä»¶ç±»å‹é”™è¯¯ error = -EBUSY; if (old_type != LAST_NORM) goto exit2; // ç›®æ ‡å·²å­˜åœ¨,ä¸èƒ½è¦†ç›– if (flags &amp; RENAME_NOREPLACE) error = -EEXIST; if (new_type != LAST_NORM) goto exit2; // è·å–å†™æƒé™ error = mnt_want_write(old_path.mnt); if (error) goto exit2;retry_deleg: // åŠ é” trap = lock_rename(new_path.dentry, old_path.dentry); // æŸ¥æ‰¾æºç›®å½•é¡¹ old_dentry = __lookup_hash(&amp;old_last, old_path.dentry, lookup_flags); error = PTR_ERR(old_dentry); if (IS_ERR(old_dentry)) goto exit3; // æºç›®å½•é¡¹å¿…é¡»å­˜åœ¨ error = -ENOENT; if (d_is_negative(old_dentry)) goto exit4; // æŸ¥æ‰¾ç›®æ ‡ç›®å½•é¡¹ new_dentry = __lookup_hash(&amp;new_last, new_path.dentry, lookup_flags | target_flags); error = PTR_ERR(new_dentry); if (IS_ERR(new_dentry)) goto exit4; // ç›®æ ‡å·²å­˜åœ¨,ä¸èƒ½è¦†ç›– error = -EEXIST; if ((flags &amp; RENAME_NOREPLACE) &amp;&amp; d_is_positive(new_dentry)) goto exit5; // ç±»å‹æ£€æŸ¥ if (flags &amp; RENAME_EXCHANGE) &#123; error = -ENOENT; if (d_is_negative(new_dentry)) goto exit5; if (!d_is_dir(new_dentry)) &#123; error = -ENOTDIR; if (new_last.name[new_last.len]) goto exit5; &#125; &#125; // å®‰å…¨æ£€æŸ¥ error = security_path_rename(&amp;old_path, old_dentry, &amp;new_path, new_dentry, flags); if (error) goto exit5; // å‡†å¤‡é‡å‘½åæ•°æ® rd.old_dir = old_path.dentry-&gt;d_inode; rd.old_dentry = old_dentry; rd.old_mnt_idmap = mnt_idmap(old_path.mnt); rd.new_dir = new_path.dentry-&gt;d_inode; rd.new_dentry = new_dentry; rd.new_mnt_idmap = mnt_idmap(new_path.mnt); rd.delegated_inode = &amp;delegated_inode; rd.flags = flags; // æ‰§è¡Œé‡å‘½å error = vfs_rename(&amp;rd);exit5: // é‡Šæ”¾èµ„æºexit5: dput(new_dentry);exit4: dput(old_dentry);exit3: unlock_rename(new_path.dentry, old_path.dentry); if (delegated_inode) &#123; error = break_deleg_wait(&amp;delegated_inode); if (!error) goto retry_deleg; &#125; mnt_drop_write(old_path.mnt);exit2: if (retry_estale(error, lookup_flags)) should_retry = true; path_put(&amp;new_path);exit1: path_put(&amp;old_path); if (should_retry) &#123; should_retry = false; lookup_flags |= LOOKUP_REVAL; goto retry; &#125;put_names: putname(from); putname(to); return error;&#125; 12345678910111213141516171819202122232425262728293031323334// renameat2ç³»ç»Ÿè°ƒç”¨å®ç°SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, unsigned int, flags)&#123; // è°ƒç”¨do_renameat2å®ç°é‡å‘½åå¹¶è¿”å›ç»“æœ return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname), flags); &#125;// renameatç³»ç»Ÿè°ƒç”¨å®ç°SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname) &#123; // è°ƒç”¨do_renameat2å®ç°é‡å‘½å, flagsä¸º0 return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname), 0);&#125;// renameç³»ç»Ÿè°ƒç”¨å®ç°SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)&#123; // è°ƒç”¨do_renameat2å®ç°é‡å‘½å, dfdä¸ºé»˜è®¤ç›®å½•,flagsä¸º0 return do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0); &#125;renameat2/renameat/renameç³»ç»Ÿè°ƒç”¨éƒ½æ˜¯åˆ©ç”¨do_renameat2å‡½æ•°å®ç°æ–‡ä»¶é‡å‘½ååŠŸèƒ½,ä¸»è¦åŒºåˆ«åœ¨äº:- renameat2å¯ä»¥æŒ‡å®šæ ‡å¿—ä½æ¥æ§åˆ¶é‡å‘½åè¡Œä¸º- renameatå¯ä»¥æŒ‡å®šæºç›®å½•æ–‡ä»¶æè¿°ç¬¦å’Œç›®æ ‡ç›®å½•æ–‡ä»¶æè¿°ç¬¦- renameä½¿ç”¨å½“å‰å·¥ä½œç›®å½•å’Œé»˜è®¤æ ‡å¿—å®ƒä»¬æœ€ç»ˆéƒ½é€šè¿‡do_renameat2ç»Ÿä¸€å®ç°äº†é‡å‘½åæ–‡ä»¶çš„æ ¸å¿ƒé€»è¾‘ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/*** readlink_copy - å°†ç¬¦å·é“¾æ¥ç›®æ ‡å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ç¼“å†²åŒº* @buffer: ç”¨æˆ·ç©ºé—´ç¼“å†²åŒºæŒ‡é’ˆ* @buflen: ç¼“å†²åŒºå¤§å° * @link: ç¬¦å·é“¾æ¥ç›®æ ‡å­—ç¬¦ä¸²** è¿”å›å€¼:* &gt;0 - å¤åˆ¶çš„å­—èŠ‚æ•°* è´Ÿå€¼ - é”™è¯¯ç */int readlink_copy(char __user *buffer, int buflen, const char *link)&#123; // è·å–ç¬¦å·é“¾æ¥ç›®æ ‡å­—ç¬¦ä¸²é•¿åº¦ int len = PTR_ERR(link); if (IS_ERR(link)) goto out; // è®¡ç®—å­—ç¬¦ä¸²é•¿åº¦ len = strlen(link); if (len &gt; (unsigned) buflen) len = buflen; // å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ if (copy_to_user(buffer, link, len)) len = -EFAULT;out: // è¿”å›å¤åˆ¶çš„å­—èŠ‚æ•° return len;&#125;/*** vfs_readlink - å°†ç¬¦å·é“¾æ¥ç›®æ ‡å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ç¼“å†²åŒº* @dentry: ç¬¦å·é“¾æ¥dentry* @buffer: ç”¨æˆ·ç©ºé—´ç¼“å†²åŒºæŒ‡é’ˆ* @buflen: ç¼“å†²åŒºå¤§å°** ä¸æ›´æ–°è®¿é—®æ—¶é—´ã€‚è°ƒç”¨è€…å¦‚æœéœ€è¦çš„è¯å¯ä»¥æ›´æ–°ã€‚** ä¸è°ƒç”¨å®‰å…¨é’©å­ã€‚*/int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)&#123; // è·å–ç¬¦å·é“¾æ¥å¯¹åº”çš„inode struct inode *inode = d_inode(dentry); // å»¶è¿Ÿè°ƒç”¨ç»“æ„ä½“ DEFINE_DELAYED_CALL(done); // ç¬¦å·é“¾æ¥ç›®æ ‡å­—ç¬¦ä¸² const char *link; int res; // æ£€æŸ¥inodeæ“ä½œ if (unlikely(!(inode-&gt;i_opflags &amp; IOP_DEFAULT_READLINK))) &#123; // è‡ªå®šä¹‰readlinkå›è°ƒ if (unlikely(inode-&gt;i_op-&gt;readlink)) return inode-&gt;i_op-&gt;readlink(dentry, buffer, buflen); // ä¸æ˜¯ç¬¦å·é“¾æ¥ if (!d_is_symlink(dentry)) return -EINVAL; // è®¾ç½®é»˜è®¤readlinkæ ‡å¿— spin_lock(&amp;inode-&gt;i_lock); inode-&gt;i_opflags |= IOP_DEFAULT_READLINK; spin_unlock(&amp;inode-&gt;i_lock); &#125; // è·å–ç¬¦å·é“¾æ¥ç›®æ ‡å­—ç¬¦ä¸² link = READ_ONCE(inode-&gt;i_link); if (!link) &#123; link = inode-&gt;i_op-&gt;get_link(dentry, inode, &amp;done); if (IS_ERR(link)) return PTR_ERR(link); &#125; // å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ res = readlink_copy(buffer, buflen, link); // å»¶è¿Ÿè°ƒç”¨ do_delayed_call(&amp;done); return res;&#125;EXPORT_SYMBOL(vfs_readlink);/*** vfs_get_link - è·å–ç¬¦å·é“¾æ¥ç›®æ ‡å­—ç¬¦ä¸² * @dentry: ç¬¦å·é“¾æ¥dentry* @done: è°ƒç”¨è€…éœ€è¦ç”¨æ­¤é‡Šæ”¾è¿”å›çš„æ•°æ®** è°ƒç”¨å®‰å…¨é’©å­å’Œi_op-&gt;get_link()ã€‚** ä¸æ›´æ–°è®¿é—®æ—¶é—´ã€‚è°ƒç”¨è€…å¦‚æœéœ€è¦å¯ä»¥æ›´æ–°ã€‚** ä¸é€‚ç”¨äºç‰¹æ®Šç¬¦å·é“¾æ¥,å¦‚/proc/$$/fd/Nã€‚*/const char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)&#123; // é»˜è®¤ä¸ºé”™è¯¯ const char *res = ERR_PTR(-EINVAL); // è·å–ç¬¦å·é“¾æ¥å¯¹åº”inode struct inode *inode = d_inode(dentry); // å¦‚æœæ˜¯ç¬¦å·é“¾æ¥ if (d_is_symlink(dentry)) &#123; // è°ƒç”¨å®‰å…¨é’©å­ res = ERR_PTR(security_inode_readlink(dentry)); if (!res) // è°ƒç”¨get_linkå›è°ƒè·å–ç›®æ ‡å­—ç¬¦ä¸² res = inode-&gt;i_op-&gt;get_link(dentry, inode, done); &#125; return res;&#125;EXPORT_SYMBOL(vfs_get_link); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*** page_get_link - å°†ç¬¦å·é“¾æ¥å†…å®¹è¯»å…¥é¡µé¢ç¼“å­˜* @dentry: ç¬¦å·é“¾æ¥å¯¹åº”çš„dentry* @inode: ç¬¦å·é“¾æ¥å¯¹åº”çš„inode* @callback: å»¶è¿Ÿè°ƒç”¨å›è°ƒå‡½æ•°** è¿”å›å€¼: ç¬¦å·é“¾æ¥å†…å®¹çš„å†…æ ¸ç©ºé—´åœ°å€*/const char *page_get_link(struct dentry *dentry, struct inode *inode, struct delayed_call *callback)&#123; char *kaddr; struct page *page; struct address_space *mapping = inode-&gt;i_mapping; if (!dentry) &#123; // æ²¡æœ‰dentry,åˆ™åˆ†é…æ–°é¡µ page = find_get_page(mapping, 0); if (!page) return ERR_PTR(-ECHILD); if (!PageUptodate(page)) &#123; put_page(page); return ERR_PTR(-ECHILD); &#125; &#125; else &#123; // æœ‰dentry,åˆ™ç›´æ¥è¯»å–ç¬¬ä¸€é¡µ page = read_mapping_page(mapping, 0, NULL); if (IS_ERR(page)) return (char*)page; &#125; // è®¾ç½®é¡µé¢é‡Šæ”¾çš„å»¶è¿Ÿè°ƒç”¨ set_delayed_call(callback, page_put_link, page); BUG_ON(mapping_gfp_mask(mapping) &amp; __GFP_HIGHMEM); // è·å–é¡µé¢å¯¹åº”çš„å†…æ ¸è™šæ‹Ÿåœ°å€ kaddr = page_address(page); // å¤„ç†ç¬¦å·é“¾æ¥å†…å®¹ nd_terminate_link(kaddr, inode-&gt;i_size, PAGE_SIZE - 1); return kaddr;&#125;EXPORT_SYMBOL(page_get_link);/*** page_put_link - é‡Šæ”¾é¡µé¢* @arg: è¦é‡Šæ”¾çš„é¡µé¢*/void page_put_link(void *arg)&#123; put_page(arg);&#125;EXPORT_SYMBOL(page_put_link);/*** page_readlink - ä½¿ç”¨é¡µé¢ç¼“å­˜è¯»å–ç¬¦å·é“¾æ¥å†…å®¹* @dentry: ç¬¦å·é“¾æ¥å¯¹åº”çš„dentry* @buffer: ç”¨æˆ·ç©ºé—´ç¼“å†²åŒº* @buflen: ç¼“å†²åŒºé•¿åº¦** è¿”å›å€¼:å¤åˆ¶çš„å­—èŠ‚æ•°æˆ–é”™è¯¯ç */ int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)&#123; DEFINE_DELAYED_CALL(done); int res = readlink_copy(buffer, buflen, page_get_link(dentry, d_inode(dentry), &amp;done)); do_delayed_call(&amp;done); return res;&#125;EXPORT_SYMBOL(page_readlink);/*** page_symlink - ç”¨é¡µé¢ç¼“å­˜åˆ›å»ºç¬¦å·é“¾æ¥* @inode: ç¬¦å·é“¾æ¥å¯¹åº”çš„inode* @symname: ç¬¦å·é“¾æ¥å†…å®¹* @len: å†…å®¹é•¿åº¦** è¿”å›å€¼:0 æˆ– é”™è¯¯ç */int page_symlink(struct inode *inode, const char *symname, int len)&#123; // è·å¾—åœ°å€ç©ºé—´ // å†™å…¥ç¬¦å·é“¾æ¥å†…å®¹ // å†™å…¥ç»“æŸ // æ ‡è®°inodeå·²è„ mark_inode_dirty(inode); return 0;&#125;EXPORT_SYMBOL(page_symlink);/*** page_symlink_inode_operations - ä½¿ç”¨é¡µé¢ç¼“å­˜çš„ç¬¦å·é“¾æ¥inodeæ“ä½œ*/const struct inode_operations page_symlink_inode_operations = &#123; .get_link = page_get_link,&#125;;EXPORT_SYMBOL(page_symlink_inode_operations);","categories":[],"tags":[]},{"title":"å­¦ä¹  Linux Mnt Namespaceå®ç°","slug":"å­¦ä¹ -Linux-Mnt-Namespaceå®ç°","date":"2023-07-18T08:06:21.000Z","updated":"2023-07-19T01:41:26.981Z","comments":true,"path":"2023/07/18/å­¦ä¹ -Linux-Mnt-Namespaceå®ç°/","link":"","permalink":"http://example.com/2023/07/18/%E5%AD%A6%E4%B9%A0-Linux-Mnt-Namespace%E5%AE%9E%E7%8E%B0/","excerpt":"æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡åŒ–å¯¹ Linux ç³»ç»Ÿæ¥è¯´ä¸€åˆ‡çš†æ–‡ä»¶ï¼ŒLinux ä½¿ç”¨æ ‘å½¢çš„å±‚æ¬¡åŒ–ç»“æ„æ¥ç®¡ç†æ‰€æœ‰çš„æ–‡ä»¶å¯¹è±¡ã€‚ å®Œæ•´çš„ Linux æ–‡ä»¶ç³»ç»Ÿï¼Œæ˜¯ç”±å¤šç§è®¾å¤‡ã€å¤šç§æ–‡ä»¶ç³»ç»Ÿç»„æˆçš„ä¸€ä¸ªæ··åˆçš„æ ‘å½¢ç»“æ„ã€‚æˆ‘ä»¬é¦–å…ˆä»ä¸€ä¸ªå•ç‹¬çš„å—è®¾å¤‡æ¥åˆ†æå…¶æ ‘å½¢ç»“æ„çš„æ„é€ ã€‚","text":"æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡åŒ–å¯¹ Linux ç³»ç»Ÿæ¥è¯´ä¸€åˆ‡çš†æ–‡ä»¶ï¼ŒLinux ä½¿ç”¨æ ‘å½¢çš„å±‚æ¬¡åŒ–ç»“æ„æ¥ç®¡ç†æ‰€æœ‰çš„æ–‡ä»¶å¯¹è±¡ã€‚ å®Œæ•´çš„ Linux æ–‡ä»¶ç³»ç»Ÿï¼Œæ˜¯ç”±å¤šç§è®¾å¤‡ã€å¤šç§æ–‡ä»¶ç³»ç»Ÿç»„æˆçš„ä¸€ä¸ªæ··åˆçš„æ ‘å½¢ç»“æ„ã€‚æˆ‘ä»¬é¦–å…ˆä»ä¸€ä¸ªå•ç‹¬çš„å—è®¾å¤‡æ¥åˆ†æå…¶æ ‘å½¢ç»“æ„çš„æ„é€ ã€‚ å—è®¾å¤‡çš„å±‚æ¬¡åŒ–ï¼ˆsuperblock&#x2F;inode&#x2F;dentryï¼‰ åœ¨Linuxå†…æ ¸ä¸­ï¼Œstruct super_block æ˜¯ä¸€ä¸ªé‡è¦çš„æ•°æ®ç»“æ„ï¼Œç”¨äºä»£è¡¨æ–‡ä»¶ç³»ç»Ÿçš„è¶…çº§å—ã€‚è¶…çº§å—åŒ…å«äº†æ–‡ä»¶ç³»ç»Ÿçš„å…ƒæ•°æ®ï¼Œä¾‹å¦‚æ–‡ä»¶ç³»ç»Ÿç±»å‹ã€å—å¤§å°ã€ç©ºé—²å—å’Œinodeçš„æ•°é‡ç­‰ã€‚æ¯ä¸ªåœ¨å†…å­˜ä¸­æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿéƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ struct super_block å®ä¾‹ã€‚ struct block_device æ˜¯å¦ä¸€ä¸ªé‡è¦çš„æ•°æ®ç»“æ„ï¼Œç”¨äºè¡¨ç¤ºå—è®¾å¤‡ï¼Œå¦‚ç¡¬ç›˜ã€‚è¿™ä¸ªç»“æ„ä½“åŒ…å«äº†å…³äºå—è®¾å¤‡çš„ä¿¡æ¯ï¼Œå¦‚è®¾å¤‡çš„å¤§å°ã€è¯»å†™æ–¹æ³•ã€é©±åŠ¨ç¨‹åºå¼•ç”¨ç­‰ã€‚ struct super_block ä¸­æŒ‡å‘ struct block_device çš„æŒ‡é’ˆçš„å­˜åœ¨ï¼Œæ˜¯ä¸ºäº†å°†æ–‡ä»¶ç³»ç»Ÿä¸å…¶ä¸‹å±‚çš„å—è®¾å¤‡å…³è”èµ·æ¥ã€‚å½“æ–‡ä»¶ç³»ç»Ÿéœ€è¦è¯»å†™æ•°æ®æ—¶ï¼Œå®ƒä¼šé€šè¿‡è¿™ä¸ªæŒ‡é’ˆè®¿é—®ç›¸åº”çš„å—è®¾å¤‡ã€‚è¿™ä¸ªæŒ‡é’ˆä¹Ÿå…è®¸æ–‡ä»¶ç³»ç»ŸæŸ¥è¯¢å—è®¾å¤‡çš„çŠ¶æ€ï¼ˆå¦‚è®¾å¤‡æ˜¯å¦å¯ç”¨ï¼‰æˆ–è€…è¿›è¡Œç‰¹å®šçš„è®¾å¤‡æ“ä½œï¼ˆå¦‚æ•°æ®åŒæ­¥ï¼‰ã€‚ è¿™æ ·çš„è®¾è®¡å…è®¸å†…æ ¸ä»¥æŠ½è±¡çš„æ–¹å¼å¤„ç†æ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼Œæ— è®ºæ–‡ä»¶ç³»ç»Ÿä½äºå“ªç§ç±»å‹çš„å—è®¾å¤‡ä¸Šï¼ˆä¾‹å¦‚ï¼Œç¡¬ç›˜ã€SDå¡ã€ç½‘ç»œå—è®¾å¤‡ç­‰ï¼‰ã€‚è¿™ä¹Ÿä¸ºæ“ä½œç³»ç»Ÿæä¾›äº†ä¸€ç§å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€æ·»åŠ ã€åˆ é™¤æˆ–è€…ä¿®æ”¹æ–‡ä»¶ç³»ç»Ÿå’Œè®¾å¤‡çš„èƒ½åŠ›ï¼Œè¿™æ˜¯ç°ä»£æ“ä½œç³»ç»Ÿçš„ä¸€ä¸ªé‡è¦ç‰¹æ€§ã€‚ã€ æˆ‘ä»¬åœ¨è®¡ç®—æœºç³»ç»Ÿä¸­ä½¿ç”¨æ–‡ä»¶æ—¶ï¼Œæˆ‘ä»¬å¹¶ä¸ç›´æ¥ä¸ç¡¬ç›˜æˆ–å…¶ä»–å—è®¾å¤‡è¿›è¡Œäº¤äº’ã€‚è€Œæ˜¯é€šè¿‡æ–‡ä»¶ç³»ç»Ÿï¼Œè¿™æ˜¯ä¸€ç§ç»„ç»‡ã€å­˜å‚¨å’Œæ£€ç´¢æ•°æ®çš„æ–¹æ³•ã€‚æ–‡ä»¶ç³»ç»Ÿä½œä¸ºä¸€ç§æŠ½è±¡æœºåˆ¶ï¼Œå…è®¸æˆ‘ä»¬ä»¥æ–‡ä»¶å’Œç›®å½•çš„å½¢å¼è®¿é—®åº•å±‚çš„å—è®¾å¤‡ï¼Œè€Œä¸éœ€è¦å…³å¿ƒæ•°æ®åœ¨ç¡¬ç›˜ä¸Šå…·ä½“æ˜¯å¦‚ä½•å­˜å‚¨çš„ã€‚ è¿™å°±æ˜¯ struct super_block æ•°æ®ç»“æ„åœ¨Linuxå†…æ ¸ä¸­çš„è§’è‰²ã€‚å®ƒå°†å—è®¾å¤‡ï¼ˆblock_deviceï¼‰å’Œæ–‡ä»¶ç³»ç»Ÿç±»å‹ï¼ˆfile_system_typeï¼‰ä¸¤ä¸ªå…¨å±€å› ç´ è¿æ¥èµ·æ¥ï¼Œç”¨æ¥æ ‡è¯†ä¸€ä¸ªå—è®¾å¤‡ã€‚ä½ å¯ä»¥å°†å…¶è§†ä¸ºä¸€ä¸ªç¿»è¯‘å™¨æˆ–è€…è§£é‡Šå™¨ï¼Œå®ƒçŸ¥é“å¦‚ä½•å°†æˆ‘ä»¬å¯¹æ–‡ä»¶çš„æ“ä½œè½¬æ¢ä¸ºå¯¹ç¡¬ç›˜ä¸Šç‰¹å®šå—çš„è¯»å†™ã€‚ è®©æˆ‘ä»¬å…·ä½“çœ‹ä¸€ä¸‹è¿™ä¸¤ä¸ªå…¨å±€å› ç´ ï¼š å—è®¾å¤‡ (block_device)ï¼šè¿™æ˜¯ç¡¬ç›˜æˆ–å…¶ä»–å­˜å‚¨è®¾å¤‡çš„è¡¨ç¤ºã€‚å®ƒæä¾›äº†ä¸€ä¸ªæ¥å£ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ªæ¥å£è¯»å†™è®¾å¤‡ä¸Šçš„æ•°æ®å—ã€‚ æ–‡ä»¶ç³»ç»Ÿç±»å‹ (file_system_type)ï¼šè¿™æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„ç±»å‹ï¼Œä¾‹å¦‚ext4ã€NTFSæˆ–FAT32ç­‰ã€‚ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿç±»å‹æœ‰ä¸åŒçš„ç»„ç»‡ç»“æ„å’Œè§„åˆ™ï¼Œå®ƒä»¬å®šä¹‰äº†å¦‚ä½•åœ¨å—è®¾å¤‡ä¸Šå­˜å‚¨å’Œæ£€ç´¢æ•°æ®ã€‚ å½“æˆ‘ä»¬æŒ‚è½½ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿæ—¶ï¼ŒLinuxå†…æ ¸ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ struct super_block å®ä¾‹ã€‚è¿™ä¸ªå®ä¾‹åŒ…å«äº†ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„ä¿¡æ¯ï¼ˆé€šè¿‡ file_system_type æŒ‡å®šï¼‰ä»¥åŠå¯¹åº”çš„å—è®¾å¤‡ï¼ˆé€šè¿‡ block_device æŒ‡å®šï¼‰ã€‚å½“æˆ‘ä»¬é€šè¿‡æ–‡ä»¶ç³»ç»Ÿè®¿é—®æ•°æ®æ—¶ï¼Œå†…æ ¸å°±ä¼šä½¿ç”¨è¿™ä¸ª struct super_block å®ä¾‹æ¥ç¿»è¯‘æˆ‘ä»¬çš„è¯·æ±‚ï¼Œå°†å…¶è½¬æ¢ä¸ºå¯¹å—è®¾å¤‡ä¸Šç‰¹å®šå—çš„è¯»å†™ã€‚ å› æ­¤ï¼Œstruct super_block åœ¨æ„å»ºæ–‡ä»¶ç³»ç»Ÿæ ‘å½¢ç»“æ„æ—¶èµ·ç€æ ¸å¿ƒçš„ä½œç”¨ã€‚å®ƒæ˜¯æ–‡ä»¶ç³»ç»Ÿå’Œå—è®¾å¤‡ä¹‹é—´çš„è¿æ¥ï¼Œå…è®¸æˆ‘ä»¬ä»¥ä¸€ç§æŠ½è±¡çš„ã€å¯¹ç”¨æˆ·å‹å¥½çš„æ–¹å¼æ¥ä½¿ç”¨å­˜å‚¨è®¾å¤‡ã€‚ ç¡®å®šäº† super_block ä»¥åï¼Œå°±å¯ä»¥ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿæä¾›çš„æ–¹æ³•æ¥è§£æå—è®¾å¤‡çš„å†…å®¹ï¼Œå½¢æˆä¸€ä¸ªå—è®¾å¤‡å†…éƒ¨çš„æ ‘å½¢ç»“æ„ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ç†Ÿæ‚‰çš„æ–‡ä»¶å¤¹ã€æ–‡ä»¶çš„å±‚æ¬¡ç»“æ„ã€‚ åœ¨Linuxæ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œstruct inode æ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„æ•°æ®ç»“æ„ï¼Œå®ƒä»£è¡¨äº†æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡å¯ä»¥æ˜¯ä¸€ä¸ªæ–‡ä»¶æˆ–è€…ä¸€ä¸ªç›®å½•ã€‚æ¯ä¸ª inode éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„ç¼–å·ï¼Œè¢«ç§°ä¸º inode ç¼–å·ï¼Œè¿™ä¸ªç¼–å·åœ¨ struct inode çš„ i_ino æˆå‘˜ä¸­è®°å½•ã€‚ è¿™é‡Œçš„ â€œåç§»â€ æ˜¯æŒ‡ inode åœ¨å—è®¾å¤‡ä¸­çš„ä½ç½®ã€‚æ¯ä¸ª inode åœ¨å—è®¾å¤‡ä¸­éƒ½æœ‰ä¸€ä¸ªç‰¹å®šçš„ä½ç½®ï¼Œè¿™ä¸ªä½ç½®ç”± inode ç¼–å·å†³å®šã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ i_ino æˆå‘˜æ‰¾åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­ç›¸åº”çš„æ–‡ä»¶æˆ–ç›®å½•ã€‚ å½“æ–‡ä»¶ç³»ç»Ÿè¢«æŒ‚è½½å’Œ super_block è¢«ç¡®å®šåï¼Œæ–‡ä»¶ç³»ç»Ÿå°±å¯ä»¥å¼€å§‹è§£æå—è®¾å¤‡çš„å†…å®¹äº†ã€‚æ–‡ä»¶ç³»ç»Ÿå°†ä¼šè¯»å–å—è®¾å¤‡ä¸Šçš„æ•°æ®ï¼Œæ ¹æ® inode çš„ä¿¡æ¯æ„å»ºå‡ºæ–‡ä»¶å’Œç›®å½•çš„å±‚æ¬¡ç»“æ„ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬å¸¸è¯´çš„æ–‡ä»¶ç³»ç»Ÿæ ‘ã€‚ è¿™ä¸ªè¿‡ç¨‹å°±åƒæ˜¯è¯»å–ä¸€æœ¬ä¹¦çš„ç›®å½•ï¼Œç„¶åæ ¹æ®ç›®å½•çš„ä¿¡æ¯æ‰¾åˆ°æ¯ä¸€ç« çš„å¼€å§‹ä½ç½®ã€‚åœ¨è¿™ä¸ªæ¯”å–»ä¸­ï¼Œinode å°±åƒæ˜¯ç›®å½•ä¸­çš„æ¯ä¸€é¡¹ï¼Œi_ino æ˜¯æ¯ä¸€ç« çš„é¡µç ã€‚ æ€»çš„æ¥è¯´ï¼Œstruct inode å’Œå…¶ i_ino æˆå‘˜æ˜¯åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿæ ‘å½¢ç»“æ„çš„å…³é”®ã€‚é€šè¿‡å®ƒä»¬ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å—è®¾å¤‡ä¸Šæ‰¾åˆ°ä»»ä½•æ–‡ä»¶æˆ–ç›®å½•çš„ä½ç½®ï¼Œè¿›ä¸€æ­¥è¯»å–æˆ–ä¿®æ”¹å®ƒä»¬çš„å†…å®¹ã€‚ Linuxç³»ç»Ÿä¸­ï¼Œstruct dentryï¼ˆç›®å½•é¡¹ï¼‰æ˜¯å¦ä¸€ä¸ªéå¸¸é‡è¦çš„æ•°æ®ç»“æ„ï¼Œå®ƒç”¨æ¥è¾…åŠ©å’Œä¼˜åŒ–æ–‡ä»¶ç³»ç»Ÿçš„æ“ä½œã€‚struct dentry ä¸»è¦ç”¨äºç¼“å­˜æ–‡ä»¶çš„å…ƒæ•°æ®ï¼Œæ¯”å¦‚æ–‡ä»¶åå’Œæ–‡ä»¶çš„å±‚æ¬¡ç»“æ„ç­‰ä¿¡æ¯ã€‚è¿™äº›ä¿¡æ¯æ˜¯ä» struct inode ä¸­è·å–çš„ï¼Œä½†æ˜¯é€šè¿‡åœ¨ dentry ä¸­ç¼“å­˜è¿™äº›ä¿¡æ¯ï¼Œå¯ä»¥é¿å…é¢‘ç¹åœ°è®¿é—® inodeï¼Œä»è€Œæé«˜æ–‡ä»¶ç³»ç»Ÿçš„æ•ˆç‡ã€‚ é€šå¸¸æƒ…å†µä¸‹ï¼Œä¸€ä¸ª struct dentry å¯¹åº”ä¸€ä¸ª struct inodeï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸ªæ–‡ä»¶æˆ–ç›®å½•éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ dentryã€‚ä½†æ˜¯ï¼Œåœ¨æœ‰äº›æƒ…å†µä¸‹ï¼Œå¯èƒ½ä¼šæœ‰å¤šä¸ª dentry å¯¹åº”åŒä¸€ä¸ª inodeã€‚è¿™ç§æƒ…å†µé€šå¸¸å‘ç”Ÿåœ¨åˆ›å»ºç¡¬é“¾æ¥çš„æ—¶å€™ã€‚ç¡¬é“¾æ¥æ˜¯æŒ‡åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶åï¼Œä½†æ˜¯è¿™ä¸ªæ–°çš„æ–‡ä»¶åå®é™…ä¸ŠæŒ‡å‘çš„æ˜¯å·²ç»å­˜åœ¨çš„å¦ä¸€ä¸ªæ–‡ä»¶çš„ inodeã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé€šè¿‡ç¡¬é“¾æ¥ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸åŒçš„æ–‡ä»¶åæ¥è®¿é—®åŒä¸€ä¸ªæ–‡ä»¶ã€‚ åœ¨ struct dentry ä¸­ï¼Œd_parent æˆå‘˜æ˜¯ä¸€ä¸ªæŒ‡å‘çˆ¶ç›®å½•çš„ dentry çš„æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒæŒ‡å‘äº†è¯¥æ–‡ä»¶æˆ–ç›®å½•çš„ä¸Šä¸€çº§ç›®å½•ã€‚d_subdirs æ˜¯ä¸€ä¸ªé“¾æ¥åˆ—è¡¨ï¼Œå®ƒè¿æ¥äº†æ‰€æœ‰çš„å­ç›®å½•ã€‚è¿™ä¸¤ä¸ªæˆå‘˜ä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨æ–‡ä»¶ç³»ç»Ÿæ ‘ä¸­ä¸Šä¸‹ç§»åŠ¨ï¼Œæ‰¾åˆ°ä»»ä½•éœ€è¦çš„æ–‡ä»¶æˆ–ç›®å½•ã€‚ å¤šè®¾å¤‡çš„å±‚æ¬¡åŒ–ï¼ˆmount&#x2F;vfsmountï¼‰åœ¨Linuxç³»ç»Ÿä¸­ï¼Œä¸æ­¢å¯ä»¥æœ‰ä¸€ä¸ªå—è®¾å¤‡ï¼ˆå¦‚ç¡¬ç›˜æˆ–USBé©±åŠ¨å™¨ï¼‰å’Œç›¸åº”çš„æ–‡ä»¶ç³»ç»Ÿï¼Œæˆ‘ä»¬å¯ä»¥è¿æ¥å¹¶ä½¿ç”¨å¤šä¸ªè¿™æ ·çš„è®¾å¤‡ã€‚æ¯ä¸ªè®¾å¤‡éƒ½æœ‰è‡ªå·±çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿå¯ä»¥è¢«è§†ä¸ºä¸€æ£µæ ‘ï¼Œå®ƒçš„æ ¹æ˜¯è®¾å¤‡ä¸Šçš„æœ€é¡¶çº§ç›®å½•ã€‚ ç„¶è€Œï¼Œå¯¹äºç”¨æˆ·æ¥è¯´ï¼Œä»–ä»¬å¹¶ä¸ç›´æ¥çœ‹åˆ°è¿™äº›å•ç‹¬çš„è®¾å¤‡å’Œæ–‡ä»¶ç³»ç»Ÿã€‚ç›¸åï¼Œä»–ä»¬çœ‹åˆ°çš„æ˜¯ä¸€ä¸ªç»Ÿä¸€çš„ã€è¿ç»­çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè¿™å°±æ˜¯æ‰€è°“çš„æ–‡ä»¶ç³»ç»ŸæŒ‚è½½ã€‚ æŒ‚è½½æ˜¯å°†ä¸€ä¸ªè®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿæ ‘è¿æ¥åˆ°å¦ä¸€ä¸ªè®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿæ ‘çš„è¿‡ç¨‹ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œä¸€ä¸ªè®¾å¤‡ï¼ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºçˆ¶è®¾å¤‡ï¼‰çš„ä¸€ä¸ªç›®å½•ï¼ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºæŒ‚è½½ç‚¹ï¼‰è¢«é€‰ä¸­ï¼Œç„¶åå¦ä¸€ä¸ªè®¾å¤‡ï¼ˆæˆ‘ä»¬ç§°ä¹‹ä¸ºå­è®¾å¤‡ï¼‰çš„æ–‡ä»¶ç³»ç»Ÿæ ‘å°±ä¼šåœ¨é‚£ä¸ªæŒ‚è½½ç‚¹ä¸Šè¿æ¥ã€‚è¿™ä¸ªæŒ‚è½½ç‚¹å°±æˆä¸ºå­è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿæ ‘çš„æ ¹ç›®å½•ã€‚ è¿™æ ·ï¼Œå½“ç”¨æˆ·è®¿é—®æŒ‚è½½ç‚¹æ—¶ï¼Œä»–ä»¬å®é™…ä¸Šæ˜¯è®¿é—®äº†å­è®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªç¡¬ç›˜è®¾å¤‡ï¼Œå…¶æ–‡ä»¶ç³»ç»ŸåŒ…å«ä¸€ä¸ªåä¸º â€œ&#x2F;photosâ€ çš„ç›®å½•ï¼Œæˆ‘ä»¬å¯ä»¥å°†ä¸€ä¸ªUSBé©±åŠ¨å™¨æŒ‚è½½åˆ°è¿™ä¸ªç›®å½•ä¸Šã€‚ç„¶åï¼Œå½“æˆ‘ä»¬è®¿é—® â€œ&#x2F;photosâ€ ç›®å½•æ—¶ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯è®¿é—®äº†USBé©±åŠ¨å™¨çš„å†…å®¹ã€‚ åœ¨Linuxå†…æ ¸ä¸­ï¼ŒæŒ‚è½½ç‚¹æ˜¯ç”± struct dentry ç»“æ„è¡¨ç¤ºçš„ï¼Œè¿™ä¸ªç»“æ„ä»£è¡¨äº†çˆ¶è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç›®å½•ã€‚å½“æŒ‚è½½å‘ç”Ÿæ—¶ï¼Œè¿™ä¸ª dentry å°†ä¼šæŒ‡å‘å­è®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿæ ‘çš„æ ¹ã€‚ é€šè¿‡æŒ‚è½½ï¼Œæˆ‘ä»¬å¯ä»¥å°†å¤šä¸ªè®¾å¤‡å’Œæ–‡ä»¶ç³»ç»Ÿç»„ç»‡æˆä¸€ä¸ªå¤æ‚çš„ã€ç»Ÿä¸€çš„ã€è¿ç»­çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè¿™å¯¹ç”¨æˆ·æ¥è¯´æ˜¯é€æ˜çš„ï¼Œä½¿å¾—ä»–ä»¬å¯ä»¥è½»æ¾åœ°ç®¡ç†å’Œè®¿é—®æ–‡ä»¶ï¼Œè€Œä¸éœ€è¦å…³å¿ƒæ–‡ä»¶å®é™…ä¸Šå­˜å‚¨åœ¨å“ªä¸ªè®¾å¤‡ä¸Šã€‚ mount&#x2F;vfsmount åœ¨Linuxç³»ç»Ÿä¸­ï¼Œstruct mount ç»“æ„æ˜¯ç”¨æ¥è¡¨ç¤ºå’Œç®¡ç†æŒ‚è½½ç‚¹çš„ã€‚å½“ä½ å°†ä¸€ä¸ªè®¾å¤‡ï¼ˆæˆ‘ä»¬å¯ä»¥ç§°ä¹‹ä¸ºå­è®¾å¤‡ï¼‰çš„æ–‡ä»¶ç³»ç»ŸæŒ‚è½½åˆ°å¦ä¸€ä¸ªè®¾å¤‡ï¼ˆæˆ‘ä»¬å¯ä»¥ç§°ä¹‹ä¸ºçˆ¶è®¾å¤‡ï¼‰çš„ç‰¹å®šç›®å½•æ—¶ï¼Œç³»ç»Ÿä¼šåˆ›å»ºä¸€ä¸ª struct mount ç»“æ„æ¥è·Ÿè¸ªè¿™ä¸ªæŒ‚è½½æ“ä½œã€‚ struct mount ç»“æ„åŒ…å«äº†ç®¡ç†å’Œç»´æŠ¤æŒ‚è½½ç‚¹æ‰€éœ€çš„æ‰€æœ‰ä¿¡æ¯ã€‚ä¾‹å¦‚ï¼Œå®ƒå¯ä»¥å¸®åŠ©ç³»ç»ŸçŸ¥é“å½“è®¿é—®æŒ‚è½½ç‚¹æ—¶ï¼Œåº”å½“å°†æ–‡ä»¶æ“ä½œï¼ˆå¦‚æ‰“å¼€æ–‡ä»¶ã€è¯»å–æ–‡ä»¶ç­‰ï¼‰é‡å®šå‘åˆ°å­è®¾å¤‡çš„å“ªä¸ªæ–‡ä»¶æˆ–ç›®å½•ã€‚ åœ¨æ–‡ä»¶ç³»ç»Ÿæ ‘ä¸­ï¼Œstruct mount ç»“æ„å®é™…ä¸Šè¡¨ç°ä¸ºä¸€ä¸ªé“¾æ¥ï¼Œè¿æ¥äº†çˆ¶è®¾å¤‡çš„æŒ‚è½½ç‚¹å’Œå­è®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿæ ‘çš„æ ¹ã€‚å½“ä½ é€šè¿‡çˆ¶è®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿè·¯å¾„è®¿é—®å­è®¾å¤‡çš„æ–‡ä»¶æˆ–ç›®å½•æ—¶ï¼Œstruct mount ç»“æ„å°±ä¼šèµ·ä½œç”¨ï¼Œå®ƒä¼šå°†ä½ çš„è¯·æ±‚å¼•å¯¼åˆ°æ­£ç¡®çš„è®¾å¤‡å’Œæ–‡ä»¶ã€‚ mount tree åœ¨Linuxç³»ç»Ÿä¸­ï¼Œé€šè¿‡ä½¿ç”¨struct mountç»“æ„ï¼Œä¸€ä¸ªå­è®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿï¼ˆä¹Ÿå°±æ˜¯ä¸€æ£µå­è®¾å¤‡æ ‘ï¼‰å¯ä»¥è¢«æŒ‚è½½åˆ°çˆ¶è®¾å¤‡æ ‘çš„ä¸€ä¸ªç‰¹å®šdentryèŠ‚ç‚¹ä¸Šã€‚è¿™ä¸ªdentryèŠ‚ç‚¹ä»£è¡¨çˆ¶è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç›®å½•ï¼Œå®ƒå°†ä½œä¸ºæŒ‚è½½ç‚¹æ¥è®¿é—®å­è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿã€‚ å½“ä¸€ä¸ªdentryå˜æˆæŒ‚è½½ç‚¹æ—¶ï¼Œç³»ç»Ÿä¼šç»™å®ƒè®¾ç½®ä¸€ä¸ªæ ‡å¿—ï¼Œè¿™ä¸ªæ ‡å¿—å«åšDCACHE_MOUNTEDã€‚è¿™ä¸ªæ ‡å¿—å‘Šè¯‰ç³»ç»Ÿï¼Œå½“è®¿é—®è¿™ä¸ªdentryæ—¶ï¼Œå®é™…ä¸Šåº”è¯¥è®¿é—®å­è®¾å¤‡çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè€Œä¸æ˜¯åŸæœ¬åœ¨çˆ¶è®¾å¤‡ä¸Šçš„å†…å®¹ã€‚å› æ­¤ï¼Œä¸€æ—¦dentryæˆä¸ºæŒ‚è½½ç‚¹ï¼ŒåŸæœ¬åœ¨è¯¥ç›®å½•ä¸‹çš„å†…å®¹å°±ä¸èƒ½è¢«ç›´æ¥è®¿é—®äº†ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯å­è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿæ ¹èŠ‚ç‚¹ä¸‹çš„å†…å®¹ã€‚ struct mountç»“æ„æœ¬èº«ä¹Ÿå¯ä»¥å½¢æˆä¸€ä¸ªæ ‘çŠ¶ç»“æ„ï¼Œè¿™ä¸ªç»“æ„åæ˜ äº†æ‰€æœ‰æŒ‚è½½ç‚¹å’Œå­è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„å…³ç³»ã€‚ åœ¨Linuxç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬é€šå¸¸ä½¿ç”¨mount -t fstype devname pathnameå‘½ä»¤æ¥æŒ‚è½½å­è®¾å¤‡ã€‚åœ¨è¿™ä¸ªå‘½ä»¤ä¸­ï¼Œfstypeå‚æ•°æŒ‡å®šäº†æ–‡ä»¶ç³»ç»Ÿçš„ç±»å‹ï¼Œä¾‹å¦‚ext4æˆ–ntfsï¼›devnameå‚æ•°æŒ‡å®šäº†è®¾å¤‡çš„åå­—ï¼Œä¾‹å¦‚&#x2F;dev&#x2F;sdb1ï¼›pathnameå‚æ•°æŒ‡å®šäº†æŒ‚è½½ç‚¹çš„è·¯å¾„ï¼Œä¾‹å¦‚&#x2F;mnt&#x2F;usbã€‚ Linux æ‹¥æœ‰éå¸¸çµæ´»çš„æŒ‚è½½è§„åˆ™ï¼š ä¸€ä¸ªè®¾å¤‡å¯ä»¥è¢«æŒ‚è½½å¤šæ¬¡ï¼š å¯ä»¥çœ‹åˆ°åŒä¸€ä¸ªå­è®¾å¤‡æ ‘ï¼ŒåŒæ—¶è¢«ä¸¤ä¸ª struct mount ç»“æ„æ‰€å¼•ç”¨ï¼Œè¢«æŒ‚è½½åˆ°çˆ¶è®¾å¤‡æ ‘çš„ä¸¤å¤„ä¸åŒçš„ dentry å¤„ã€‚ ç‰¹åˆ«è¯´æ˜ï¼šè™½ç„¶å­è®¾å¤‡æ ‘è¢«æŒ‚è½½ä¸¤æ¬¡å¹¶ä¸”é€šè¿‡ä¸¤å¤„è·¯å¾„éƒ½èƒ½è®¿é—®ï¼Œä½†å­è®¾å¤‡çš„ dentry å’Œ inode åªä¿æŒä¸€ä»½ã€‚ ä¸€ä¸ªæŒ‚è½½ç‚¹å¯ä»¥æŒ‚è½½å¤šä¸ªè®¾å¤‡ï¼š è¿˜å¯ä»¥å¯¹çˆ¶è®¾å¤‡æ ‘çš„åŒä¸€ä¸ªæ–‡ä»¶å¤¹ dentry è¿›è¡Œå¤šæ¬¡æŒ‚è½½ï¼Œæœ€åè·¯å¾„æŸ¥æ‰¾æ—¶ç”Ÿæ•ˆçš„æ˜¯æœ€åä¸€æ¬¡æŒ‚è½½çš„å­è®¾å¤‡æ ‘ã€‚ path å› ä¸º Linux æä¾›çš„çµæ´»çš„æŒ‚è½½è§„åˆ™ï¼Œæ‰€ä»¥æˆ‘ä»¬å¦‚æœè¦æ ‡è¯†ä¸€ä¸ªè·¯å¾„ struct path çš„è¯éœ€è¦ä¸¤ä¸ªå…ƒç´ ï¼švfsmount å’Œ dentryã€‚ å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªè·¯å¾„ struct path æœ€åå¼•ç”¨åˆ°äº†åŒä¸€ inodeï¼Œä½†æ˜¯è·¯å¾„ path æ˜¯ä¸ä¸€æ ·çš„ï¼Œå› ä¸º path æŒ‡å‘çš„ vfsmount æ˜¯ä¸ä¸€æ ·çš„ã€‚ chroot Linux è¿˜æ”¯æŒæ¯ä¸ªè¿›ç¨‹æ‹¥æœ‰ä¸åŒçš„æ ¹ç›®å½•ï¼Œä½¿ç”¨ chroot() ç³»ç»Ÿè°ƒç”¨å¯ä»¥æŠŠå½“å‰è¿›ç¨‹çš„æ ¹ç›®å½•è®¾ç½®ä¸ºæ•´æ£µæ–‡ä»¶ç³»ç»Ÿæ ‘ä¸­çš„ä»»ä½• pathã€‚ å¤šåç©ºé—´çš„å±‚æ¬¡åŒ–ï¼ˆmnt_namespaceï¼‰Linux ç³»ç»Ÿä¸ºäº†æ”¯æŒ mnt_namespaceï¼Œå¿…é¡»å°†å•ä¸€çš„ mount æ ‘æ‰©å±•æˆå¤šæ£µ mount æ ‘ã€‚è®©æˆ‘ä»¬å…ˆè§£é‡Šä¸€ä¸‹ä»€ä¹ˆæ˜¯ namespace å’Œ mnt_namespaceã€‚ Namespace æ˜¯ Linux æä¾›çš„ä¸€ç§æœºåˆ¶ï¼Œå®ƒå¯ä»¥å°†ç³»ç»Ÿèµ„æºåˆ’åˆ†ä¸ºå¤šä¸ªç‹¬ç«‹çš„è§†å›¾æˆ–ç¯å¢ƒã€‚æ¯ä¸ª namespace éƒ½æœ‰è‡ªå·±çš„ä¸€ç»„èµ„æºï¼Œå¯¹èµ„æºçš„æ”¹å˜ä¸ä¼šå½±å“åˆ°å…¶ä»–çš„ namespaceã€‚è¿™ç§æœºåˆ¶åœ¨å®¹å™¨æŠ€æœ¯ä¸­å°¤å…¶é‡è¦ï¼Œå› ä¸ºå®ƒä½¿æ¯ä¸ªå®¹å™¨éƒ½å¯ä»¥æœ‰è‡ªå·±ç‹¬ç«‹çš„ç³»ç»Ÿè§†å›¾ï¼Œå°±åƒåœ¨è‡ªå·±çš„ç³»ç»Ÿä¸­ä¸€æ ·ã€‚ mnt_namespace æ˜¯ namespace çš„ä¸€ç§ï¼Œå®ƒæ˜¯ç”¨æ¥éš”ç¦»æ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹çš„ã€‚æ¯ä¸ª mnt_namespace éƒ½æœ‰è‡ªå·±çš„ mount æ ‘ï¼Œè¿™æ„å‘³ç€åœ¨ä¸€ä¸ª namespace ä¸­æŒ‚è½½æˆ–å¸è½½çš„æ–‡ä»¶ç³»ç»Ÿä¸ä¼šå½±å“åˆ°å…¶ä»–çš„ namespaceã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœä½ åœ¨ä¸€ä¸ª namespace ä¸­æŒ‚è½½äº†ä¸€ä¸ª USB é©±åŠ¨å™¨ï¼Œé‚£ä¹ˆè¿™ä¸ªé©±åŠ¨å™¨ä»…åœ¨è¯¥ namespace å†…å¯è§ã€‚åœ¨å…¶ä»– namespace ä¸­ï¼Œä½ å°†çœ‹ä¸åˆ°è¿™ä¸ªé©±åŠ¨å™¨ï¼Œé™¤éä½ åœ¨é‚£ä¸ª namespace ä¸­ä¹Ÿæ‰§è¡Œäº†æŒ‚è½½æ“ä½œã€‚ å› æ­¤ï¼Œé€šè¿‡æ¯ä¸ª mnt_namespace æ‹¥æœ‰ä¸€æ£µç‹¬ç«‹çš„ mount æ ‘ï¼ŒLinux ç³»ç»Ÿèƒ½ä¸ºæ¯ä¸ª namespace æä¾›ç‹¬ç«‹çš„æ–‡ä»¶ç³»ç»Ÿè§†å›¾ï¼Œä»è€Œå®ç°æ›´å¼ºå¤§ã€æ›´çµæ´»çš„èµ„æºéš”ç¦»åŠŸèƒ½ã€‚ å‚è€ƒèµ„æ–™ Mnt Namespace è¯¦è§£ - æ³°æ™“ç§‘æŠ€ (tinylab.org) GPT-4","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"å­¦ä¹  Linux VFSè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ[2] dentryè¯¦è§£å’Œdcacheå®ç°","slug":"å­¦ä¹ -Linux-VFSè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ[2] dentryè¯¦è§£å’Œdcacheå®ç°","date":"2023-07-18T07:15:54.000Z","updated":"2023-11-20T02:25:55.860Z","comments":true,"path":"2023/07/18/å­¦ä¹ -Linux-VFSè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ[2] dentryè¯¦è§£å’Œdcacheå®ç°/","link":"","permalink":"http://example.com/2023/07/18/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F[2]%20dentry%E8%AF%A6%E8%A7%A3%E5%92%8Cdcache%E5%AE%9E%E7%8E%B0/","excerpt":"ç®€ä»‹ä¸€ä¸ªdentryç»“æ„ä½“ä»£è¡¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç›®å½•æˆ–æ–‡ä»¶ï¼Œvfsä½¿ç”¨åŸºäºdentryæ„å»ºçš„dentryæ ‘æ¥ç®¡ç†æ•´ä¸ªç³»ç»Ÿçš„ç›®å½•æ ‘ç»“æ„ã€‚å½“ç„¶ï¼Œå¯¹äºå¤§å‹ç³»ç»Ÿä¸å¯èƒ½æŠŠæ•´ä¸ªç³»ç»Ÿçš„ç›®å½•æ ‘éƒ½å¡è¿›å†…å­˜ï¼Œdentry cacheå°±è´Ÿè´£ç»´æŠ¤ç³»ç»Ÿç›®å½•æ ‘ä¸­æœ€å¸¸ç”¨çš„é¡¹ç›®ï¼Œå¹¶é‡‡ç”¨lruçš„æ·˜æ±°ç­–ç•¥æ·˜æ±°æœ€è¿‘ä¸ä½¿ç”¨çš„é¡¹ç›®ï¼Œç»´æŒæ•´ä¸ªdentry cacheä¸­é¡¹ç›®æ•°é‡çš„ç¨³å®šã€‚ å¹¶ä¸”dentryç¼“å­˜åœ¨ä¸€å®šç¨‹åº¦ä¸Šæ§åˆ¶ç€inodeç¼“å­˜ã€‚","text":"ç®€ä»‹ä¸€ä¸ªdentryç»“æ„ä½“ä»£è¡¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç›®å½•æˆ–æ–‡ä»¶ï¼Œvfsä½¿ç”¨åŸºäºdentryæ„å»ºçš„dentryæ ‘æ¥ç®¡ç†æ•´ä¸ªç³»ç»Ÿçš„ç›®å½•æ ‘ç»“æ„ã€‚å½“ç„¶ï¼Œå¯¹äºå¤§å‹ç³»ç»Ÿä¸å¯èƒ½æŠŠæ•´ä¸ªç³»ç»Ÿçš„ç›®å½•æ ‘éƒ½å¡è¿›å†…å­˜ï¼Œdentry cacheå°±è´Ÿè´£ç»´æŠ¤ç³»ç»Ÿç›®å½•æ ‘ä¸­æœ€å¸¸ç”¨çš„é¡¹ç›®ï¼Œå¹¶é‡‡ç”¨lruçš„æ·˜æ±°ç­–ç•¥æ·˜æ±°æœ€è¿‘ä¸ä½¿ç”¨çš„é¡¹ç›®ï¼Œç»´æŒæ•´ä¸ªdentry cacheä¸­é¡¹ç›®æ•°é‡çš„ç¨³å®šã€‚ å¹¶ä¸”dentryç¼“å­˜åœ¨ä¸€å®šç¨‹åº¦ä¸Šæ§åˆ¶ç€inodeç¼“å­˜ã€‚ dentryçš„ä¸‰ç§çŠ¶æ€ æœªä½¿ç”¨ï¼ˆunusedï¼‰çŠ¶æ€ï¼šè¯¥dentryå¯¹è±¡çš„å¼•ç”¨è®¡æ•°d_countçš„å€¼ä¸º0ï¼Œä½†å…¶d_inodeæŒ‡é’ˆä»ç„¶æŒ‡å‘ç›¸å…³çš„çš„ç´¢å¼•èŠ‚ç‚¹ã€‚è¯¥ç›®å½•é¡¹ä»ç„¶åŒ…å«æœ‰æ•ˆçš„ä¿¡æ¯ï¼Œåªæ˜¯å½“å‰æ²¡æœ‰äººå¼•ç”¨ä»–ã€‚è¿™ç§dentryå¯¹è±¡åœ¨å›æ”¶å†…å­˜æ—¶å¯èƒ½ä¼šè¢«é‡Šæ”¾ã€‚ æ­£åœ¨ä½¿ç”¨ï¼ˆinuseï¼‰çŠ¶æ€ï¼šå¤„äºè¯¥çŠ¶æ€ä¸‹çš„dentryå¯¹è±¡çš„å¼•ç”¨è®¡æ•°d_countå¤§äº0ï¼Œä¸”å…¶d_inodeæŒ‡å‘ç›¸å…³çš„inodeå¯¹è±¡ã€‚è¿™ç§dentryå¯¹è±¡ä¸èƒ½è¢«é‡Šæ”¾ã€‚ è´Ÿï¼ˆnegativeï¼‰çŠ¶æ€ï¼šä¸ç›®å½•é¡¹ç›¸å…³çš„inodeå¯¹è±¡ä¸å¤å­˜åœ¨ï¼ˆç›¸åº”çš„ç£ç›˜ç´¢å¼•èŠ‚ç‚¹å¯èƒ½å·²ç»è¢«åˆ é™¤ï¼‰ï¼Œdentryå¯¹è±¡çš„d_inodeæŒ‡é’ˆä¸ºNULLã€‚ä½†è¿™ç§dentryå¯¹è±¡ä»ç„¶ä¿å­˜åœ¨dcacheä¸­ï¼Œä»¥ä¾¿åç»­å¯¹åŒä¸€æ–‡ä»¶åçš„æŸ¥æ‰¾èƒ½å¤Ÿå¿«é€Ÿå®Œæˆã€‚è¿™ç§dentryå¯¹è±¡åœ¨å›æ”¶å†…å­˜æ—¶å°†é¦–å…ˆè¢«é‡Šæ”¾ã€‚ dentry_hashtableæˆ‘ä»¬æ‰€è¯´çš„dcacheï¼ŒæŒ‡çš„æ˜¯ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜ï¼Œä¸»è¦æ˜¯ç”¨äºé«˜æ•ˆå¤„ç†è·¯å¾„è§£ææŸ¥æ‰¾ï¼Œå®ƒå®é™…ä¸Šç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šdentry_hashtableå“ˆå¸Œè¡¨å’Œdentry_unusedé“¾è¡¨ã€‚ dentry_hashtableå®šä¹‰å¦‚ä¸‹ dentry_hashtable identifier - Linux source code (v6.3.8) - Bootlin 1static struct hlist_bl_head *dentry_hashtable __read_mostly; __read_mostlyå®è¡¨ç¤ºæ­¤å¤„ä¼šç»å¸¸è¢«è¯»å–ï¼Œå†…æ ¸åŠ è½½æ—¶å°†å…¶å­˜æ”¾åœ¨cacheä¸­ã€‚ 1#define __read_mostly __section(&quot;.data..read_mostly&quot;) _read_mostlyä¿®é¥°çš„å˜é‡å‡æ”¾åœ¨.data..read_mostlyæ®µä¸­ã€‚ dcacheåˆå§‹åŒ–dentry cacheåœ¨å†…æ ¸å¯åŠ¨æ—¶å®Œæˆåˆå§‹åŒ–ã€‚å†…æ ¸çš„å¯åŠ¨å…¥å£å‡½æ•°æ˜¯init/main.cæ–‡ä»¶çš„start_kernelå‡½æ•°ï¼Œstart_kernelå‡½æ•°ä¼šè°ƒç”¨vfs_caches_initå‡½æ•°ï¼Œå¹¶è°ƒç”¨dcache_initå‡½æ•°æ¥å®Œæˆdentry cacheçš„åˆå§‹åŒ–ã€‚ main.c - init&#x2F;main.c - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212asmlinkage __visible void __init __no_sanitize_address start_kernel(void)&#123; char *command_line; char *after_dashes; set_task_stack_end_magic(&amp;init_task); smp_setup_processor_id(); debug_objects_early_init(); init_vmlinux_build_id(); cgroup_init_early(); local_irq_disable(); early_boot_irqs_disabled = true; /* * Interrupts are still disabled. Do necessary setups, then * enable them. */ boot_cpu_init(); page_address_init(); pr_notice(&quot;%s&quot;, linux_banner); early_security_init(); setup_arch(&amp;command_line); setup_boot_config(); setup_command_line(command_line); setup_nr_cpu_ids(); setup_per_cpu_areas(); smp_prepare_boot_cpu(); /* arch-specific boot-cpu hooks */ boot_cpu_hotplug_init(); build_all_zonelists(NULL); page_alloc_init(); pr_notice(&quot;Kernel command line: %s\\n&quot;, saved_command_line); /* parameters may set static keys */ jump_label_init(); parse_early_param(); after_dashes = parse_args(&quot;Booting kernel&quot;, static_command_line, __start___param, __stop___param - __start___param, -1, -1, NULL, &amp;unknown_bootoption); print_unknown_bootoptions(); if (!IS_ERR_OR_NULL(after_dashes)) parse_args(&quot;Setting init args&quot;, after_dashes, NULL, 0, -1, -1, NULL, set_init_arg); if (extra_init_args) parse_args(&quot;Setting extra init args&quot;, extra_init_args, NULL, 0, -1, -1, NULL, set_init_arg); /* Architectural and non-timekeeping rng init, before allocator init */ random_init_early(command_line); /* * These use large bootmem allocations and must precede * kmem_cache_init() */ setup_log_buf(0); vfs_caches_init_early(); sort_main_extable(); trap_init(); mm_init(); poking_init(); ftrace_init(); /* trace_printk can be enabled here */ early_trace_init(); /* * Set up the scheduler prior starting any interrupts (such as the * timer interrupt). Full topology setup happens at smp_init() * time - but meanwhile we still have a functioning scheduler. */ sched_init(); if (WARN(!irqs_disabled(), &quot;Interrupts were enabled *very* early, fixing it\\n&quot;)) local_irq_disable(); radix_tree_init(); maple_tree_init(); /* * Set up housekeeping before setting up workqueues to allow the unbound * workqueue to take non-housekeeping into account. */ housekeeping_init(); /* * Allow workqueue creation and work item queueing/cancelling * early. Work item execution depends on kthreads and starts after * workqueue_init(). */ workqueue_init_early(); rcu_init(); /* Trace events are available after this */ trace_init(); if (initcall_debug) initcall_debug_enable(); context_tracking_init(); /* init some links before init_ISA_irqs() */ early_irq_init(); init_IRQ(); tick_init(); rcu_init_nohz(); init_timers(); srcu_init(); hrtimers_init(); softirq_init(); timekeeping_init(); time_init(); /* This must be after timekeeping is initialized */ random_init(); /* These make use of the fully initialized rng */ kfence_init(); boot_init_stack_canary(); perf_event_init(); profile_init(); call_function_init(); WARN(!irqs_disabled(), &quot;Interrupts were enabled early\\n&quot;); early_boot_irqs_disabled = false; local_irq_enable(); kmem_cache_init_late(); /* * HACK ALERT! This is early. We&#x27;re enabling the console before * we&#x27;ve done PCI setups etc, and console_init() must be aware of * this. But we do want output early, in case something goes wrong. */ console_init(); if (panic_later) panic(&quot;Too many boot %s vars at `%s&#x27;&quot;, panic_later, panic_param); lockdep_init(); /* * Need to run this when irqs are enabled, because it wants * to self-test [hard/soft]-irqs on/off lock inversion bugs * too: */ locking_selftest(); /* * This needs to be called before any devices perform DMA * operations that might use the SWIOTLB bounce buffers. It will * mark the bounce buffers as decrypted so that their usage will * not cause &quot;plain-text&quot; data to be decrypted when accessed. */ mem_encrypt_init();#ifdef CONFIG_BLK_DEV_INITRD if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp; page_to_pfn(virt_to_page((void *)initrd_start)) &lt; min_low_pfn) &#123; pr_crit(&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\\n&quot;, page_to_pfn(virt_to_page((void *)initrd_start)), min_low_pfn); initrd_start = 0; &#125;#endif setup_per_cpu_pageset(); numa_policy_init(); acpi_early_init(); if (late_time_init) late_time_init(); sched_clock_init(); calibrate_delay(); pid_idr_init(); anon_vma_init();#ifdef CONFIG_X86 if (efi_enabled(EFI_RUNTIME_SERVICES)) efi_enter_virtual_mode();#endif thread_stack_cache_init(); cred_init(); fork_init(); proc_caches_init(); uts_ns_init(); key_init(); security_init(); dbg_late_init(); net_ns_init(); vfs_caches_init(); pagecache_init(); signals_init(); seq_file_init(); proc_root_init(); nsfs_init(); cpuset_init(); cgroup_init(); taskstats_init_early(); delayacct_init(); check_bugs(); acpi_subsystem_init(); arch_post_acpi_subsys_init(); kcsan_init(); /* Do the rest non-__init&#x27;ed, we&#x27;re now alive */ arch_call_rest_init(); prevent_tail_call_optimization();&#125; é€šè¿‡dcache_initåˆå§‹åŒ–å“ˆå¸Œè¡¨å­˜æ”¾dcacheï¼Œå°†dentryé€šè¿‡å“ˆå¸Œè¡¨ç»„ç»‡èµ·æ¥ dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233static void __init dcache_init(void)&#123; /* * å¯¹äºç¨³å®šçŠ¶æ€çš„åˆ—è¡¨ï¼Œå¯ä»¥æ·»åŠ ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œ * ä½†ç”±äºdcacheçš„ç¼“å­˜ç‰¹æ€§ï¼Œè¿™å¯èƒ½å¹¶ä¸å€¼å¾—ã€‚ */ // åˆ›å»ºä¸€ä¸ªdentry_cacheï¼Œå®ƒæ˜¯ä¸€ä¸ªå†…å­˜ç¼“å­˜ï¼Œç”¨äºå­˜å‚¨dentryç»“æ„ dentry_cache = KMEM_CACHE_USERCOPY(dentry, // è®¾ç½®å†…å­˜ç¼“å­˜çš„ä¸€äº›å±æ€§æ ‡å¿— SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT, d_iname); // å¦‚æœhashdistæ²¡æœ‰è®¾ç½®ï¼Œç›´æ¥è¿”å› /* Hash may have been set up in dcache_init_early */ if (!hashdist) return; // åˆ†é…ä¸€ä¸ªå¤§å‹ç³»ç»Ÿå“ˆå¸Œè¡¨ï¼Œç”¨äºå­˜å‚¨dentryç»“æ„çš„å“ˆå¸Œè¡¨ dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, // æ¯ä¸ªå“ˆå¸Œè¡¨èŠ‚ç‚¹çš„å¤§å° sizeof(struct hlist_bl_head), // å“ˆå¸Œè¡¨çš„é¢„åˆ†é…å¤§å° dhash_entries, 13, // è¿™æ˜¯ä¸€ä¸ªå›ºå®šå‚æ•°ï¼Œç”¨äºè®¡ç®—å“ˆå¸Œè¡¨çš„å¤§å° HASH_ZERO, // å“ˆå¸Œè¡¨çš„æ ‡å¿— &amp;d_hash_shift, // ç”¨äºè®¡ç®—å“ˆå¸Œå€¼çš„ç§»ä½å€¼ NULL, // æŒ‡å®šä¸€ä¸ªç”¨äºè®¡ç®—å“ˆå¸Œå€¼çš„å‡½æ•°ï¼Œè¿™é‡Œä½¿ç”¨é»˜è®¤å‡½æ•° 0, // åªåœ¨NUMAç³»ç»Ÿä¸­ä½¿ç”¨ï¼Œè¿™é‡Œè®¾ç½®ä¸º0 0); // åªåœ¨NUMAç³»ç»Ÿä¸­ä½¿ç”¨ï¼Œè¿™é‡Œè®¾ç½®ä¸º0 // è®¡ç®—å“ˆå¸Œå€¼çš„ç§»ä½å€¼ d_hash_shift = 32 - d_hash_shift;&#125; dcache_initå‡½æ•°ä¸»è¦å·¥ä½œå†…å®¹æ˜¯ä¸¤é¡¹ã€‚ ç¬¬ä¸€é¡¹æ˜¯åˆå§‹åŒ–dentry cacheæ¨¡å—çš„ç§æœ‰å˜é‡struct kmem_cache *dentry_cacheï¼Œè¿™æ˜¯ä¸€ä¸ªslabå†…å­˜åˆ†é…å™¨ã€‚slabå†…å­˜åˆ†é…æ˜¯å†…æ ¸å†…å­˜ç®¡ç†çš„å¸¸ç”¨æ‰‹æ®µï¼Œå…¶æ ¸å¿ƒæ€æƒ³éå¸¸ç®€å•ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå¯¹è±¡æ± ï¼Œä¸“é—¨åº”å¯¹åŒä¸€ç±»å‹ï¼Œä¹Ÿå°±æ˜¯ç­‰é•¿å†…å­˜çš„é¢‘ç¹åˆ†é…å’Œé‡Šæ”¾ã€‚dentry cacheæ¨¡å—çš„dentry_cacheå­—æ®µå°±æ˜¯ä¸“é—¨ç”¨æ¥åˆ†é…struct dentryæ•°æ®ç»“æ„æ‰€éœ€ä½¿ç”¨çš„å†…å­˜çš„ã€‚ ç¬¬äºŒé¡¹æ˜¯åˆå§‹åŒ–dentry cacheæ¨¡å—çš„å¦ä¸€ä¸ªç§æœ‰å˜é‡struct hlist_bl_head *dentry_hashtableï¼Œè¿™æ˜¯ä¸€ä¸ªå·¨å¤§çš„å“ˆå¸Œè¡¨ï¼Œä¹Ÿå°±æ˜¯dentry cacheçš„æŸ¥æ‰¾ç´¢å¼•ï¼Œå¯ä»¥dentryçš„nameç›´æ¥åœ¨è¿™ä¸ªå“ˆå¸Œè¡¨ä¸­è¿›è¡ŒæŸ¥æ‰¾ã€‚ç±»å‹struct hlist_bl_headæ˜¯ä¸€ä¸ªbit lock hash listçš„é“¾è¡¨å¤´ã€‚hash listç”¨äºå®ç°å“ˆå¸Œè¡¨çš„ä¸€ä¸ªslotï¼Œè¿™é‡Œçš„bit lock hash listæ˜¯ä¸€ä¸ªå†…æ ¸ä¸­çš„hash listå®ç°ç‰ˆæœ¬ï¼Œä¸éœ€è¦ä¸ºæ¯ä¸ªhash liståˆ†é…ä¸€æŠŠé”ï¼Œåªéœ€è¦ä½¿ç”¨é“¾è¡¨å¤´æŒ‡é’ˆçš„ä¸€ä¸ªbitæ¥è¿›è¡Œè®¿é—®å¹¶å‘æ§åˆ¶ï¼ŒèŠ‚çœå†…å­˜å¼€é”€ã€‚dentry_hashtableç”±ä¸€ä¸ªå®šé•¿çš„hlist_bl_headæ•°ç»„ç»„æˆï¼Œç›¸å½“äºæ˜¯ä¸€ä¸ªæ°¸ä¸æ‰©å®¹çš„å“ˆå¸Œè¡¨ï¼Œå¯ä»¥å‡å°‘å¹¶å‘æ§åˆ¶å¸¦æ¥çš„æ€§èƒ½å¼€é”€å’Œå®ç°å¤æ‚åº¦ã€‚ åœ¨dentryçš„æ•°æ®ç»“æ„ä¸­ï¼Œæ˜¯é€šè¿‡ç±»å‹ä¸ºqstrçš„nameæ¥å……å½“keyå€¼ï¼Œè¿›è€Œè®¡ç®—å‡ºhashè¡¨çš„ç´¢å¼•å³valueï¼Œä¾‹å¦‚ä¸‹é¢çš„ä»£ç  d_hash identifier - Linux source code (v6.3.8) - Bootlin 12345d_hash(dentry-&gt;d_name.hash)static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; return dentry_hashtable + (hash &gt;&gt; d_hash_shift);&#125; æ—¢ç„¶æ˜¯ä¾æ®nameæ¥åšhashï¼Œé‚£ç›¸åŒnameçš„ã€ä¸åŒnameçš„ï¼Œéƒ½å¯èƒ½åœ¨åŒä¸€hashé“¾è¡¨é‡Œï¼ˆç¢°æ’ï¼‰ã€‚ nameä¸åŒï¼Œå¯ä»¥é€šè¿‡å¯¹æ¯”å­—ç¬¦ä¸²ï¼Œè€Œnameç›¸åŒçš„ï¼Œå…¶parentè‚¯å®šä¸åŒï¼ˆåŒä¸€ç›®å½•ä¸‹ä¸å¯èƒ½æœ‰ä¸¤ç§åŒåçš„æ–‡ä»¶ï¼‰ï¼Œæ‰€ä»¥å…·æœ‰æ˜¯å…·æœ‰å”¯ä¸€æ€§çš„ã€‚ dentry identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* ç›®å½•é¡¹çš„æ ‡å¿—ä½ï¼Œå— d_lock ä¿æŠ¤ */ seqcount_spinlock_t d_seq; /* æ¯ä¸ªç›®å½•é¡¹çš„åºåˆ—é” */ struct hlist_bl_node d_hash; /* ç›®å½•é¡¹å½¢æˆçš„ç”¨äºæŸ¥æ‰¾çš„å“ˆå¸Œåˆ—è¡¨ */ struct dentry *d_parent; /* çˆ¶ç›®å½•çš„ç›®å½•é¡¹dentry */ struct qstr d_name; /* ç›®å½•é¡¹çš„åç§°ï¼ˆå¯ä»¥å¿«é€ŸæŸ¥æ‰¾ï¼‰ */ struct inode *d_inode; /* ä¸æ–‡ä»¶åç§°å…³è”çš„ï¼Œä¸ç›®å½•åå…³è”çš„ inode ç»“æ„æŒ‡é’ˆï¼ŒNULL è¡¨ç¤ºè´Ÿç›®å½•é¡¹ */ unsigned char d_iname[DNAME_INLINE_LEN]; /* çŸ­æ–‡ä»¶åç§° */ /* Ref lookup also touches following */ struct lockref d_lockref; /* æ¯ä¸ªç›®å½•é¡¹çš„é”å’Œå¼•ç”¨è®¡æ•° */ const struct dentry_operations *d_op; /* ç›®å½•é¡¹æ“ä½œå‡½æ•°é›† */ struct super_block *d_sb; /* ç›®å½•é¡¹æ ‘çš„æ ¹èŠ‚ç‚¹ï¼ˆå³æ–‡ä»¶çš„è¶…çº§å—ï¼‰ */ unsigned long d_time; /* ç”¨äº d_revalidate çš„æ—¶é—´æˆ³ */ void *d_fsdata; /* ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„æ•°æ® */ union &#123; struct list_head d_lru; /* LRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰åˆ—è¡¨ */ wait_queue_head_t *d_wait; /* ä»…ç”¨äºæŸ¥æ‰¾ä¸­çš„ç›®å½•é¡¹ */ &#125;; struct list_head d_child; /* çˆ¶ç›®å½•é¡¹çš„å­é¡¹åˆ—è¡¨ */ struct list_head d_subdirs; /* å­ç›®å½•é¡¹åˆ—è¡¨ */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; struct hlist_bl_node d_in_lookup_hash; /* ä»…ç”¨äºæŸ¥æ‰¾ä¸­çš„ç›®å½•é¡¹ */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; åªè¦åœ¨å†…å­˜ä¸­å»ºç«‹äº†ä¸€ä¸ªdentryï¼Œé‚£ä¹ˆå®ƒæŒ‡å‘çš„inodeä¹Ÿä¼šåœ¨å†…å­˜ä¸­è¢«â€cachedâ€ï¼Œè¿™å°±æ„æˆäº†inode cacheï¼ˆç®€ç§°icacheï¼‰ï¼Œicacheçš„æ¯ä¸€é¡¹å†…å®¹éƒ½æ˜¯ä¸€ä¸ªå·²æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿä¸­çš„æ–‡ä»¶inodeã€‚ å¦‚æœä¸€ä¸ªdentryçš„å¼•ç”¨è®¡æ•°ï¼ˆdentry-&gt;d_lockref.count)ä¸ä¸º0ï¼Œè¯´æ˜è¿˜æœ‰è¿›ç¨‹åœ¨å¼•ç”¨å®ƒï¼Œæ¯”å¦‚é€šè¿‡â€œopenâ€æ“ä½œï¼Œæ­¤æ—¶dentryå¤„äºâ€œin useâ€çŠ¶æ€ã€‚ è€Œå½“å…¶å¼•ç”¨è®¡æ•°å˜ä¸º0ï¼Œè¡¨æ˜ä¸å†è¢«ä½¿ç”¨ï¼ˆæ¯”å¦‚æ–‡ä»¶è¢«closeäº†ï¼‰ï¼Œåˆ™åˆ‡æ¢åˆ°â€œunusedâ€çš„çŠ¶æ€ï¼Œä½†æ­¤æ—¶å…¶æŒ‡å‘çš„å†…å­˜inodeä¾ç„¶æœ‰æ•ˆï¼Œå› ä¸ºè¿™äº›inodeå¯¹åº”çš„æ–‡ä»¶ä¹‹åå¯èƒ½è¢«ç”¨åˆ°ã€‚åˆ é™¤æŒ‡å‘ç›¸åº”æ–‡ä»¶çš„æœ€åä¸€ä¸ªç¡¬é“¾æ¥æ—¶ï¼Œin useçš„dentryå¯èƒ½ä¼šå˜ä¸ºnegativeï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œdentryå¯¹è±¡ä¼šç§»åŠ¨åˆ°unused dentryçš„LRUåˆ—è¡¨ä¸­ã€‚ å¯¹äºé‚£äº›æœªä½¿ç”¨çŠ¶æ€çš„dentryå¯¹è±¡æ¥è¯´ï¼Œå®ƒä»¬è¢«å†æ¬¡è®¿é—®çš„å¯èƒ½æ€§å¾ˆå¤§ï¼Œå› æ­¤ï¼Œä¸èƒ½å°†å®ƒä»¬ç«‹å³ä¸¢å¼ƒè€Œå¿…é¡»å°†å®ƒä»¬åœ¨dcacheä¿ç•™ä¸€æ®µæ—¶é—´ã€‚ä¸ºæ­¤ï¼ŒLinuxé€šè¿‡LRUé“¾è¡¨æ¥æœ‰æ•ˆåœ°ç®¡ç†è¿™äº›æœªä½¿ç”¨çš„dentryå¯¹è±¡ã€‚æ¯ä¸€ä¸ªå¤„äºunusedçŠ¶æ€ä¸‹çš„dentryé€šè¿‡å…¶d_lruæŒ‡é’ˆåŸŸé“¾å…¥ç³»ç»Ÿå…¨å±€çš„LRUé“¾è¡¨ï¼Œè¡¨å¤´åŒ…å«åœ¨super_block::s_dentry_lruä¸­ã€‚ å½“å†…å­˜ç´§å¼ æ—¶ï¼Œè¿™äº›unused dentryæ‰€å æ®çš„å†…å­˜æ˜¯å¯ä»¥è¢«å›æ”¶çš„ï¼Œæ ¹æ®å±€éƒ¨æ€§åŸç†ï¼Œæˆ‘ä»¬åº”å½“é€‰æ‹©æœ€è¿‘æœªè¢«ä½¿ç”¨çš„dentryä½œä¸ºå›æ”¶çš„å¯¹è±¡ã€‚åŒpage cacheç±»ä¼¼ï¼Œé€šè¿‡slab cacheåˆ†é…å¾—åˆ°çš„dentryåœ¨è¿›å…¥unusedçŠ¶æ€åï¼Œä¼šé€šè¿‡LRUé“¾è¡¨çš„å½¢å¼è¢«ç®¡ç†ï¼Œæœ€æ–°åŠ å…¥çš„unused dentryè¢«æ”¾åœ¨é“¾è¡¨çš„å¤´éƒ¨ï¼Œå¯åŠ¨å†…å­˜shrinkçš„æ“ä½œæ—¶ï¼Œé“¾è¡¨å°¾éƒ¨çš„dentryå°†è¢«ç‡å…ˆå›æ”¶ã€‚ d_lru_add identifier - Linux source code (v6.3.8) - Bootlin 123456789static void d_lru_add(struct dentry *dentry)&#123; D_FLAG_VERIFY(dentry, 0); dentry-&gt;d_flags |= DCACHE_LRU_LIST; this_cpu_inc(nr_dentry_unused); if (d_is_negative(dentry)) this_cpu_inc(nr_dentry_negative); WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125; å¦‚æœå°è¯•openä¸€ä¸ªè·¯å¾„ï¼Œä½†æœ€åå‘ç°æ­¤è·¯å¾„å¯¹åº”çš„æ–‡ä»¶åœ¨ç£ç›˜ä¸Šæ˜¯ä¸å­˜åœ¨çš„ï¼Œæ­¤æ—¶è·¯å¾„å¯¹åº”çš„çš„dentryä¹Ÿä¼šä»¥negative entryçš„å½¢å¼è®°å½•åœ¨dcacheé‡Œï¼Œè¿™æ ·ä¸‹æ¬¡åœ¨è¯•å›¾è®¿é—®è¿™ä¸ªä¸å­˜åœ¨çš„è·¯å¾„æ—¶ï¼Œå¯ä»¥ç«‹å³è¿”å›é”™è¯¯ï¼Œä¸ç”¨å†å»ç£ç›˜çæŠ˜è…¾ä¸€ç•ªï¼ˆå¤±è´¥çš„æ¡ˆä¾‹åŒæ ·æœ‰ä»·å€¼ï¼‰ã€‚ path lookupæœç´¢dcacheæµç¨‹è·¯å¾„æŸ¥æ‰¾é¦–å…ˆç”¨lookup_faståœ¨dcacheé‡Œæ‰¾ï¼Œä¸€å¼€å§‹æŸ¥æ‰¾çš„æ—¶å€™ä¼šè®¾ç½®LOOKUP_RCUæ ‡å¿—ï¼Œæ‰€ä»¥ä¼šè°ƒç”¨__d_lookup_rcuå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°é‡Œé€šè¿‡d_hashæ‰¾åˆ°è¦æ‰¾çš„dentryçš„å¯¹åº”çš„å“ˆå¸Œè¡¨ï¼Œé€šè¿‡hlist_bl_for_each_entry_rcuéå†è¿™ä¸ªå“ˆå¸Œè¡¨ï¼Œå¯¹æ¯”çˆ¶ç›®å½•ï¼Œåç§°ç­‰ç­‰æ˜¯å¦ç›¸åŒï¼Œç„¶ååœ¨è¿™ä¸ªå‡½æ•°é‡Œæ²¡æœ‰é”ä¹‹ç±»çš„ä¸œè¥¿ï¼Œå¦‚æœæ‰¾ä¸åˆ°ï¼Œä¼šé€šè¿‡try_to_unlazyå‡½æ•°å°†rcu-walkè½¬ä¸ºref-walkï¼Œç„¶åä¸€å±‚å±‚è¿”å›ä¸Šå»ï¼Œåˆ°do_filp_openå‡½æ•°ä¸­ï¼Œé‡æ–°è°ƒç”¨path_openatå‡½æ•°ï¼Œè¿™ä¸ªæ—¶å€™æ²¡æœ‰è®¾ç½®LOOKUP_RCUäº†ï¼Œæ‰€ä»¥å…ˆè¿›å…¥lookup_fastå°±ä¸ä¼šè°ƒç”¨__d_lookup_rcuï¼Œè€Œæ˜¯å»è°ƒç”¨__d_lookupï¼Œè¿™ä¸ªå‡½æ•°å’Œ__d_lookup_rcuåŸºæœ¬ç›¸åŒï¼Œä½†æ˜¯å¤šäº†å¾ˆå¤šé”ï¼Œå¦‚æœè¿™ä¸ªå‡½æ•°è¿˜æ˜¯æ‰¾ä¸åˆ°å¯¹åº”çš„dentryï¼Œå°±è¯´æ˜åœ¨dcacheä¸­æ²¡æœ‰ï¼Œå°±è¦è¿›å…¥lookup_slowè°ƒç”¨å…·ä½“æ–‡ä»¶ç³»ç»Ÿçš„lookupï¼Œå»ç£ç›˜é‡Œæ‰¾ã€‚ é¦–å…ˆçœ‹åˆ°do_filp_openå‡½æ•° 123456789101112131415161718192021222324// å®šä¹‰ä¸€ä¸ªåä¸º do_filp_open çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šdfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ï¼Œpathnameï¼ˆæ–‡ä»¶åç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“æŒ‡é’ˆï¼‰struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // ä» op ç»“æ„ä½“ä¸­è·å–æŸ¥æ‰¾æ ‡å¿— int flags = op-&gt;lookup_flags; struct file *filp; // ä½¿ç”¨ set_nameidata å‡½æ•°åˆå§‹åŒ– nd ç»“æ„ä½“ï¼Œä¼ å…¥ dfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ã€pathnameï¼ˆæ–‡ä»¶åç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ NULLï¼ˆç”¨äºåˆå§‹åŒ– nd-&gt;intentï¼‰ set_nameidata(&amp;nd, dfd, pathname, NULL); // ä½¿ç”¨ path_openat å‡½æ•°å°è¯•æ‰“å¼€æ–‡ä»¶ï¼Œä¼ å…¥ ndï¼ˆåå­—æ•°æ®ç»“æ„ä½“ï¼‰ã€opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“ï¼‰å’Œ flagsï¼ˆæŸ¥æ‰¾æ ‡å¿—ï¼‰ï¼›ä½¿ç”¨ LOOKUP_RCU æ ‡å¿—è¿›è¡Œ RCU ä¼˜åŒ– filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // å¦‚æœæ–‡ä»¶æ‰“å¼€å¤±è´¥å¹¶è¿”å› -ECHILD é”™è¯¯ç ï¼Œè¡¨æ˜ RCU ä¼˜åŒ–å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨é RCU ä¼˜åŒ–æ–¹å¼æ‰“å¼€æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // å¦‚æœæ–‡ä»¶æ‰“å¼€å¤±è´¥å¹¶è¿”å› -ESTALE é”™è¯¯ç ï¼Œè¡¨æ˜æ–‡ä»¶ç³»ç»ŸçŠ¶æ€é™ˆæ—§ï¼Œå°è¯•ä½¿ç”¨ LOOKUP_REVAL æ ‡å¿—é‡æ–°è¯„ä¼°æ–‡ä»¶ç³»ç»ŸçŠ¶æ€å¹¶æ‰“å¼€æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // é€šè¿‡è°ƒç”¨ restore_nameidata å‡½æ•°æ¢å¤åå­—æ•°æ®ç»“æ„ä½“ï¼ˆndï¼‰çš„çŠ¶æ€ restore_nameidata(); // è¿”å›æ–‡ä»¶ç»“æ„ä½“æŒ‡é’ˆ filp return filp;&#125; åœ¨è¿™é‡Œå±•ç¤ºäº†path walkçš„ä¸¤ç§ç­–ç•¥ï¼šrcu-walkå’Œref-walkã€‚åœ¨ rcu-walk æœŸé—´å°†ä¼šç¦æ­¢æŠ¢å ï¼Œä¹Ÿå†³ä¸èƒ½å‡ºç°è¿›ç¨‹é˜»å¡ï¼Œæ‰€ä»¥å…¶æ•ˆç‡å¾ˆé«˜ï¼›ref-walk ä¼šåœ¨ rcu-walk å¤±è´¥ã€è¿›ç¨‹éœ€è¦éšçœ æˆ–è€…éœ€è¦å–å¾—æŸç»“æ„çš„å¼•ç”¨è®¡æ•°ï¼ˆreference countï¼‰çš„æƒ…å†µä¸‹åˆ‡æ¢è¿›æ¥ï¼Œå¾ˆæ˜æ˜¾å®ƒçš„æ•ˆç‡å¤§å¤§ä½äº rcu-walkã€‚æœ€å REVALå…¶å®ä¹Ÿæ˜¯ ref-walkï¼Œåœ¨ä»¥åæˆ‘ä»¬ä¼šçœ‹åˆ°ï¼Œè¯¥æ¨¡å¼æ˜¯åœ¨å·²ç»å®Œæˆäº†è·¯å¾„æŸ¥æ‰¾ï¼Œæ‰“å¼€å…·ä½“æ–‡ä»¶æ—¶ï¼Œå¦‚æœè¯¥æ–‡ä»¶å·²ç»è¿‡æœŸï¼ˆstaleï¼‰æ‰å¯åŠ¨çš„ï¼Œæ‰€ä»¥ REVAL æ˜¯ç»™å…·ä½“æ–‡ä»¶ç³»ç»Ÿè‡ªå·±å»è§£é‡Šçš„ã€‚å…¶å® REVAL å‡ ä¹ä¸ä¼šç”¨åˆ°ï¼Œåœ¨å†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿä¸­åªæœ‰ nfs ç”¨åˆ°äº†è¿™ä¸ªæ¨¡å¼ã€‚ é¦–å…ˆçœ‹åˆ°filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);å°±æ˜¯ä½¿ç”¨rcu-walkå…ˆè¿›è¡Œè·¯å¾„æŸ¥æ‰¾ï¼Œå¦‚æœæŸ¥æ‰¾å¤±è´¥ï¼Œå›é€€åˆ°do_filp_openï¼Œè¿›è¡Œref-walkã€‚ è¿›å…¥åˆ°path_openatå‡½æ•°ä¸­ 123456789// å®šä¹‰ä¸€ä¸ªåä¸º path_openat çš„é™æ€å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šndï¼ˆåå­—æ•°æ®ç»“æ„ä½“æŒ‡é’ˆï¼‰ã€opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ flagsï¼ˆæ‰“å¼€æ ‡å¿—ï¼‰static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; ... while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ...&#125; link_path_walkåœ¨è¾¾åˆ°æœ€ç»ˆç›®æ ‡æ‰€åœ¨ç›®å½•çš„æ—¶å€™åœä¸‹æ¥ï¼Œæœ€ç»ˆç›®æ ‡äº¤ç»™å¦ä¸€ä¸ªå‡½æ•°open_last_lookupsã€‚ åœ¨link_path_walkä¸­æœ‰ä¸€ä¸ªå¤§å¾ªç¯ï¼Œå¾ªç¯å¤„ç†æ¯ä¸ªç»„ä»¶ï¼Œå…¶ä¸­ï¼Œé€šè¿‡walk_componentå‡½æ•°å¤„ç†ä¸­é—´ç»„ä»¶ï¼Œæ¥ä¸‹æ¥çœ‹åˆ°walk_componentå‡½æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637// å®šä¹‰ä¸€ä¸ªåä¸º walk_component çš„å‡½æ•°ï¼Œå‚æ•°åŒ…æ‹¬ä¸€ä¸ªæŒ‡å‘ nameidata ç»“æ„ä½“çš„æŒ‡é’ˆå’Œä¸€ä¸ªæ•´æ•° flagsstatic const char *walk_component(struct nameidata *nd, int flags)&#123; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘ dentry ç»“æ„ä½“çš„æŒ‡é’ˆ struct dentry *dentry; /* * &quot;.&quot; å’Œ &quot;..&quot; æ˜¯ç‰¹æ®Šçš„ - å°¤å…¶æ˜¯ &quot;..&quot;ï¼Œå› ä¸ºå®ƒå¿…é¡»çŸ¥é“å½“å‰æ ¹ç›®å½•å’Œ * çˆ¶ç›®å½•ä¹‹é—´çš„å…³ç³»ã€‚ */ // å¦‚æœ nd-&gt;last_type ä¸æ˜¯ LAST_NORMï¼Œåˆ™æ‰§è¡Œä»¥ä¸‹ä»£ç  if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // å¦‚æœ flags æ²¡æœ‰è®¾ç½® WALK_MORE ä¸” nd-&gt;depth ä¸ä¸º 0ï¼Œåˆ™è°ƒç”¨ put_link å‡½æ•° if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // è°ƒç”¨ handle_dots å‡½æ•°å¤„ç† &quot;.&quot; å’Œ &quot;..&quot; return handle_dots(nd, nd-&gt;last_type); &#125; // è°ƒç”¨ lookup_fast å‡½æ•°è¿›è¡Œå¿«é€ŸæŸ¥æ‰¾ dentry = lookup_fast(nd); // å¦‚æœ dentry æ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ if (IS_ERR(dentry)) return ERR_CAST(dentry); // å¦‚æœ dentry ä¸º NULLï¼Œåˆ™æ‰§è¡Œä»¥ä¸‹ä»£ç  if (unlikely(!dentry)) &#123; // è°ƒç”¨ lookup_slow å‡½æ•°è¿›è¡Œæ…¢é€ŸæŸ¥æ‰¾ dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // å¦‚æœ dentry æ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; // å¦‚æœ flags æ²¡æœ‰è®¾ç½® WALK_MORE ä¸” nd-&gt;depth ä¸ä¸º 0ï¼Œåˆ™è°ƒç”¨ put_link å‡½æ•° if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // è°ƒç”¨ step_into å‡½æ•°è¿›å…¥ä¸‹ä¸€ä¸ªç»„ä»¶ï¼ˆç›®å½•æˆ–æ–‡ä»¶ï¼‰ return step_into(nd, flags, dentry);&#125; å¯¹äºè¿™ä¸ªå­è·¯å¾„å¯ä»¥åˆ†æˆä¸‰ç§æƒ…å†µï¼Œç¬¬ä¸€ï¼Œå®ƒå¯èƒ½æ˜¯â€œ.â€æˆ–â€œ..â€ï¼›ç¬¬äºŒï¼Œè¿™å°±æ˜¯ä¸€ä¸ªæ™®é€šçš„ç›®å½•ï¼›ç¬¬ä¸‰ï¼Œå®ƒæ˜¯ä¸€ä¸ªç¬¦å·é“¾æ¥ã€‚ å¯¹äºæ™®é€šç»„ä»¶ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œé¦–å…ˆä¼šå°è¯•lookup_fastç„¶åï¼Œå¦‚æœå¤±è´¥äº†æ‰ä¼šå¯åŠ¨lookup_slowã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct dentry *lookup_fast(struct nameidata *nd)&#123; struct dentry *dentry, *parent = nd-&gt;path.dentry; // å®šä¹‰dentryæŒ‡é’ˆï¼Œå°†ndä¸­çš„pathçš„dentryèµ‹å€¼ç»™parent int status = 1; /* * Rename seqlock is not required here because in the off chance * of a false negative due to a concurrent rename, the caller is * going to fall back to non-racy lookup. */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœä½¿ç”¨RCUï¼ˆè¯»-æ‹·è´-æ›´æ–°ï¼‰æŸ¥æ‰¾ dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); // ç”¨RCUæ–¹å¼æŸ¥æ‰¾ç›®å½•é¡¹ if (unlikely(!dentry)) &#123; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°dentry if (!try_to_unlazy(nd)) // å°è¯•å°†rcué”å‡çº§ä¸ºércué” return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯ return NULL; // è¿”å›ç©ºæŒ‡é’ˆ &#125; /* * This sequence count validates that the parent had no * changes while we did the lookup of the dentry above. */ if (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) // éªŒè¯åœ¨æŸ¥æ‰¾dentryè¿‡ç¨‹ä¸­parentæ²¡æœ‰å‘ç”Ÿå˜åŒ– return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯ status = d_revalidate(dentry, nd-&gt;flags); // éªŒè¯dentryçš„æœ‰æ•ˆæ€§ if (likely(status &gt; 0)) // å¦‚æœéªŒè¯æˆåŠŸ return dentry; // è¿”å›dentry if (!try_to_unlazy_next(nd, dentry)) // å°è¯•å°†rcué”å‡çº§ä¸ºércué” return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯ if (status == -ECHILD) /* we&#x27;d been told to redo it in non-rcu mode */ status = d_revalidate(dentry, nd-&gt;flags); // åœ¨éRCUæ¨¡å¼ä¸‹é‡æ–°éªŒè¯dentryçš„æœ‰æ•ˆæ€§ &#125; else &#123; // å¦‚æœä½¿ç”¨éRCUæŸ¥æ‰¾ï¼ŒREFæŸ¥æ‰¾ dentry = __d_lookup(parent, &amp;nd-&gt;last); // æŸ¥æ‰¾ç›®å½•é¡¹ if (unlikely(!dentry)) // å¦‚æœæ²¡æœ‰æ‰¾åˆ°dentry return NULL; // è¿”å›ç©ºæŒ‡é’ˆ status = d_revalidate(dentry, nd-&gt;flags); // éªŒè¯dentryçš„æœ‰æ•ˆæ€§ &#125; if (unlikely(status &lt;= 0)) &#123; // å¦‚æœéªŒè¯å¤±è´¥ if (!status) // å¦‚æœstatusä¸º0 d_invalidate(dentry); // ä½¿dentryæ— æ•ˆ dput(dentry); // é‡Šæ”¾dentryå¼•ç”¨ return ERR_PTR(status); // è¿”å›é”™è¯¯ &#125; return dentry; // è¿”å›dentry&#125; é¦–å…ˆå°è¯•è¿›å…¥lookup_fastä¸­ï¼Œå°è¯•rcu-walkï¼Œå³è¿›å…¥__d_lookup_rcuå‡½æ•°ä¸­ï¼Œè¿›å…¥__d_lookup_rcuå‡½æ•°ä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct dentry *__d_lookup_rcu(const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // è®¡ç®—åç§°çš„å“ˆå¸Œé•¿åº¦ const unsigned char *str = name-&gt;name; // è·å–åç§°å­—ç¬¦ä¸² struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // è®¡ç®—å“ˆå¸Œå€¼å¹¶è·å–æ•£åˆ—è¡¨å¤´ struct hlist_bl_node *node; // å®šä¹‰å“ˆå¸Œè¡¨èŠ‚ç‚¹æŒ‡é’ˆ struct dentry *dentry; // å®šä¹‰ç›®å½•é¡¹æŒ‡é’ˆ /* * Note: There is significant duplication with __d_lookup_rcu which is * required to prevent single threaded performance regressions * especially on architectures where smp_rmb (in seqcounts) are costly. * Keep the two functions in sync. */ // æ£€æŸ¥çˆ¶ç›®å½•é¡¹æ˜¯å¦åŒ…å«è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œå¦‚æœæœ‰åˆ™è°ƒç”¨ç‰¹å®šçš„æŸ¥æ‰¾å‡½æ•° if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE)) return __d_lookup_rcu_op_compare(parent, name, seqp); /* * The hash list is protected using RCU. * * Carefully use d_seq when comparing a candidate dentry, to avoid * races with d_move(). * * It is possible that concurrent renames can mess up our list * walk here and result in missing our dentry, resulting in the * false-negative result. d_lookup() protects against concurrent * renames using rename_lock seqlock. * * See Documentation/filesystems/path-lookup.txt for more details. */ // ä½¿ç”¨ RCU ä¿æŠ¤çš„å“ˆå¸Œåˆ—è¡¨æ¥éå†ç›®å½•é¡¹ hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; unsigned seq; /* * The dentry sequence count protects us from concurrent * renames, and thus protects parent and name fields. * * The caller must perform a seqcount check in order * to do anything useful with the returned dentry. * * NOTE! We do a &quot;raw&quot; seqcount_begin here. That means that * we don&#x27;t wait for the sequence count to stabilize if it * is in the middle of a sequence change. If we do the slow * dentry compare, we will do seqretries until it is stable, * and if we end up with a successful lookup, we actually * want to exit RCU lookup anyway. * * Note that raw_seqcount_begin still *does* smp_rmb(), so * we are still guaranteed NUL-termination of -&gt;d_name.name. */ seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // è·å– dentry çš„åºåˆ—è®¡æ•° if (dentry-&gt;d_parent != parent) // æ£€æŸ¥ dentry çš„çˆ¶ç›®å½•é¡¹æ˜¯å¦ä¸ç»™å®šçš„çˆ¶ç›®å½•é¡¹ç›¸åŒ continue; if (d_unhashed(dentry)) // æ£€æŸ¥ dentry æ˜¯å¦å·²ä»æ•£åˆ—è¡¨ä¸­åˆ é™¤ continue; if (dentry-&gt;d_name.hash_len != hashlen) // æ£€æŸ¥ dentry çš„åç§°å“ˆå¸Œé•¿åº¦æ˜¯å¦ä¸ç»™å®šåç§°ç›¸åŒ continue; if (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0) // æ¯”è¾ƒ dentry çš„åç§°ä¸ç»™å®šåç§°æ˜¯å¦ç›¸åŒ continue; *seqp = seq; // å°†åºåˆ—è®¡æ•°èµ‹å€¼ç»™ seqp return dentry; // è¿”å›æ‰¾åˆ°çš„ dentry &#125; return NULL; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ dentryï¼Œåˆ™è¿”å›ç©ºæŒ‡é’ˆ&#125; é¦–å…ˆé€šè¿‡d_hashå¾—åˆ°å¯¹åº”çš„å“ˆå¸Œè¡¨ï¼Œç„¶åé€šè¿‡hlist_bl_for_each_entry_rcuéå†å“ˆå¸Œè¡¨ï¼Œåœ¨rcuæ¨¡å¼ä¸‹ï¼Œä¾æ¬¡æ¯”è¾ƒdentryçš„çˆ¶ç›®å½•ï¼Œå“ˆå¸Œé•¿åº¦ï¼Œåç§°æ˜¯å¦ç›¸ç­‰ã€‚ å¦‚æœæ²¡æœ‰æ‰¾åˆ°dentryï¼Œè¿”å›åˆ°ä¸Šå±‚çš„lookup_fastå‡½æ•°ï¼Œä¼šé€šè¿‡try_to_unlazyåˆ‡æ¢åˆ°ref-walkï¼Œç„¶åè¿”å›ERR_PTR(-ECHILD)ã€‚ æœ€ç»ˆä¼šè¿”å›åˆ°do_filp_openå‡½æ•°ä¸­ï¼Œé‡æ–°è¿›è¡Œè·¯å¾„æŸ¥æ‰¾ 123456789101112131415161718192021222324// å®šä¹‰ä¸€ä¸ªåä¸º do_filp_open çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šdfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ï¼Œpathnameï¼ˆæ–‡ä»¶åç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“æŒ‡é’ˆï¼‰struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // ä» op ç»“æ„ä½“ä¸­è·å–æŸ¥æ‰¾æ ‡å¿— int flags = op-&gt;lookup_flags; struct file *filp; // ä½¿ç”¨ set_nameidata å‡½æ•°åˆå§‹åŒ– nd ç»“æ„ä½“ï¼Œä¼ å…¥ dfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ã€pathnameï¼ˆæ–‡ä»¶åç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ NULLï¼ˆç”¨äºåˆå§‹åŒ– nd-&gt;intentï¼‰ set_nameidata(&amp;nd, dfd, pathname, NULL); // ä½¿ç”¨ path_openat å‡½æ•°å°è¯•æ‰“å¼€æ–‡ä»¶ï¼Œä¼ å…¥ ndï¼ˆåå­—æ•°æ®ç»“æ„ä½“ï¼‰ã€opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“ï¼‰å’Œ flagsï¼ˆæŸ¥æ‰¾æ ‡å¿—ï¼‰ï¼›ä½¿ç”¨ LOOKUP_RCU æ ‡å¿—è¿›è¡Œ RCU ä¼˜åŒ– filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // å¦‚æœæ–‡ä»¶æ‰“å¼€å¤±è´¥å¹¶è¿”å› -ECHILD é”™è¯¯ç ï¼Œè¡¨æ˜ RCU ä¼˜åŒ–å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨é RCU ä¼˜åŒ–æ–¹å¼æ‰“å¼€æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // å¦‚æœæ–‡ä»¶æ‰“å¼€å¤±è´¥å¹¶è¿”å› -ESTALE é”™è¯¯ç ï¼Œè¡¨æ˜æ–‡ä»¶ç³»ç»ŸçŠ¶æ€é™ˆæ—§ï¼Œå°è¯•ä½¿ç”¨ LOOKUP_REVAL æ ‡å¿—é‡æ–°è¯„ä¼°æ–‡ä»¶ç³»ç»ŸçŠ¶æ€å¹¶æ‰“å¼€æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // é€šè¿‡è°ƒç”¨ restore_nameidata å‡½æ•°æ¢å¤åå­—æ•°æ®ç»“æ„ä½“ï¼ˆndï¼‰çš„çŠ¶æ€ restore_nameidata(); // è¿”å›æ–‡ä»¶ç»“æ„ä½“æŒ‡é’ˆ filp return filp;&#125; è¿™æ¬¡æŸ¥æ‰¾ï¼Œè¿è¡Œåˆ°lookup_fastæ—¶ï¼Œä¸ä¼šè¿è¡Œ__d_lookup_rcu,è€Œæ˜¯è¿è¡Œ__d_lookupï¼Œè¿›å…¥è¿™ä¸ªå‡½æ•°ä¸­ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * __d_lookup - æœç´¢ä¸€ä¸ª dentry (å®¹æ˜“å‡ºç°ç«äº‰) * @parent: çˆ¶ dentry * @name: æˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°çš„åå­—çš„ qstr * è¿”å›: dentryï¼Œæˆ–è€… NULL * * __d_lookup ç±»ä¼¼äº d_lookupï¼Œä½†æ˜¯ç”±äºä¸é‡å‘½åæ— å…³çš„æ´»åŠ¨ï¼Œå®ƒå¯èƒ½ï¼ˆå¾ˆå°‘ï¼‰è¿”å› * ä¸€ä¸ªé”™è¯¯çš„è´Ÿé¢ç»“æœã€‚ * * __d_lookup é€šè¿‡é¿å…è¯»å– rename_lock seqlockï¼Œé€Ÿåº¦ç¨å¿«ï¼Œ * ä½†å¿…é¡»è°¨æ…ä½¿ç”¨ï¼Œä¾‹å¦‚åœ¨å¤±è´¥æ—¶ä½¿ç”¨åç»­çš„ d_lookupã€‚ * * __d_lookup è°ƒç”¨è€…å¿…é¡»åŠ æ³¨é‡Šã€‚ */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; // è®¡ç®— name çš„å“ˆå¸Œå€¼ struct hlist_bl_head *b = d_hash(hash); // è·å–å“ˆå¸Œå€¼å¯¹åº”çš„å“ˆå¸Œè¡¨å¤´ struct hlist_bl_node *node; // ç”¨äºéå†å“ˆå¸Œé“¾è¡¨çš„èŠ‚ç‚¹ struct dentry *found = NULL; // ç”¨äºå­˜å‚¨æ‰¾åˆ°çš„ dentry struct dentry *dentry; // ç”¨äºéå†å“ˆå¸Œé“¾è¡¨çš„ä¸´æ—¶ dentry /* * æ³¨æ„ï¼šè¿™é‡Œä¸ __d_lookup_rcu æœ‰å¾ˆå¤§çš„é‡å¤éƒ¨åˆ†ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢å•çº¿ç¨‹æ€§èƒ½ * å›å½’ï¼Œç‰¹åˆ«æ˜¯åœ¨ smp_rmbï¼ˆåœ¨ seqcounts ä¸­ï¼‰ä»£ä»·é«˜æ˜‚çš„æ¶æ„ä¸Šã€‚ * ä¿æŒè¿™ä¸¤ä¸ªå‡½æ•°åŒæ­¥æ›´æ–°ã€‚ */ /* * å“ˆå¸Œåˆ—è¡¨ä½¿ç”¨ RCU ä¿æŠ¤ã€‚ * * åœ¨æ¯”è¾ƒå€™é€‰ dentry æ—¶ï¼Œè·å– d_lock ä»¥é¿å…ä¸ d_move() çš„ç«äº‰ã€‚ * * æœ‰å¯èƒ½å¹¶å‘çš„é‡å‘½åæ“ä½œä¼šç ´åæˆ‘ä»¬è¿™é‡Œçš„åˆ—è¡¨éå†ï¼Œå¯¼è‡´æˆ‘ä»¬é”™è¿‡ dentryï¼Œ * ä»è€Œäº§ç”Ÿé”™è¯¯çš„è´Ÿé¢ç»“æœã€‚d_lookup() ä½¿ç”¨ rename_lock seqlock æ¥ä¿æŠ¤ * å¹¶å‘é‡å‘½åã€‚ * * æ›´å¤šç»†èŠ‚è¯·å‚é˜… Documentation/filesystems/path-lookup.txtã€‚ */ rcu_read_lock(); // è·å– RCU è¯»é” // éå†å“ˆå¸Œé“¾è¡¨ hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) // å“ˆå¸Œå€¼ä¸åŒ¹é…ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª continue; spin_lock(&amp;dentry-&gt;d_lock); // è·å– dentry çš„è‡ªæ—‹é” if (dentry-&gt;d_parent != parent) // çˆ¶ dentry ä¸åŒ¹é…ï¼Œè·³åˆ°ä¸‹ä¸€ä¸ª goto next; if (d_unhashed(dentry)) // æ£€æŸ¥ dentry æ˜¯å¦å·²ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤ï¼Œå¦‚æœæ˜¯åˆ™è·³åˆ°ä¸‹ä¸€ä¸ª goto next; if (!d_same_name(dentry, parent, name)) // åå­—ä¸åŒ¹é…ï¼Œè·³åˆ°ä¸‹ä¸€ä¸ª goto next; dentry-&gt;d_lockref.count++; // å¢åŠ  dentry çš„å¼•ç”¨è®¡æ•° found = dentry; // æ‰¾åˆ°åŒ¹é…çš„ dentryï¼Œèµ‹å€¼ç»™ found spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾ dentry çš„è‡ªæ—‹é” break; // ç»“æŸå¾ªç¯ next: spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾ dentry çš„è‡ªæ—‹é” &#125; rcu_read_unlock(); // é‡Šæ”¾ RCU è¯»é” return found; // è¿”å›æ‰¾åˆ°çš„ dentryï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°è¿”å› NULL&#125; å¯ä»¥çœ‹åˆ°è¿™ä¸ªå‡½æ•°å’Œä¸Šé¢çš„rcu-walkåŸºæœ¬ç›¸åŒï¼Œä½†æ˜¯å¤šäº†å¾ˆå¤šé”çš„å¤„ç†ï¼Œæ‰€ä»¥rcu-walkçš„é€Ÿåº¦æ¯”refçš„é€Ÿåº¦å¿«ã€‚ å¦‚æœref-walkè¿˜æ²¡æ‰¾åˆ°å¯¹åº”çš„dentryï¼Œå°±ä¼šè¿›å…¥åˆ°lookup_slowè°ƒç”¨å¯¹åº”çš„å…·ä½“æ–‡ä»¶ç³»ç»Ÿçš„lookupæ–¹æ³• å‚è€ƒèµ„æ–™ Linuxç³»ç»Ÿè°ƒç”¨openå‡½æ•°åˆ†æ___randomize_layout_shp1234çš„åšå®¢-CSDNåšå®¢ Linux path-lookup ç¿»è¯‘ - æ˜é‡‘ (juejin.cn) vfs dentry cache æ¨¡å—å®ç°åˆ†æ - çŸ¥ä¹ (zhihu.com)s Linuxçš„VFSå®ç° - ç•ªå¤–[ä¸€] - dcache - çŸ¥ä¹ (zhihu.com)","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"å­¦ä¹  Linux Dockerç¯å¢ƒæ­å»º","slug":"å­¦ä¹ -Linux-Dockerç¯å¢ƒæ­å»º","date":"2023-07-16T12:59:54.000Z","updated":"2023-07-18T08:12:47.624Z","comments":true,"path":"2023/07/16/å­¦ä¹ -Linux-Dockerç¯å¢ƒæ­å»º/","link":"","permalink":"http://example.com/2023/07/16/%E5%AD%A6%E4%B9%A0-Linux-Docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"åœ¨ Ubuntu 20.04 ä¸Šå®‰è£… Docker ä½¿ç”¨Docker repository æ¥å®‰è£… 12345678910111213141516171819202122232425262728# æ›´æ–°aptåŒ…ç´¢å¼•sudo apt-get update# ä¸ºæ”¯æŒhttpssudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common# æ·»åŠ Docker GPGç§˜é’¥# å›½å†…æºcurl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# æˆ–è€…å›½å¤–æº# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# æ·»åŠ å®‰è£…æº# æ¨èå›½å†…æºsudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# æˆ–è€…å›½å¤–æº# sudo add-apt-repository \\# &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable&quot;","text":"åœ¨ Ubuntu 20.04 ä¸Šå®‰è£… Docker ä½¿ç”¨Docker repository æ¥å®‰è£… 12345678910111213141516171819202122232425262728# æ›´æ–°aptåŒ…ç´¢å¼•sudo apt-get update# ä¸ºæ”¯æŒhttpssudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common# æ·»åŠ Docker GPGç§˜é’¥# å›½å†…æºcurl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# æˆ–è€…å›½å¤–æº# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# æ·»åŠ å®‰è£…æº# æ¨èå›½å†…æºsudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# æˆ–è€…å›½å¤–æº# sudo add-apt-repository \\# &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable&quot; å®‰è£…Docker 12345# æ›´æ–°aptåŒ…ç´¢å¼•sudo apt-get update# å®‰è£…dockersudo apt-get install docker-ce docker-ce-cli containerd.io å¼€å¯Docker 12sudo systemctl enable dockersudo systemctl start docker éªŒè¯æ˜¯å¦å®‰è£…æˆåŠŸ 1sudo docker run hello-world å¦‚æœå‡ºç°â€Hello from Docker.â€, åˆ™ä»£è¡¨è¿è¡ŒæˆåŠŸ å¦‚æœåœ¨æ¯æ¬¡è¿è¡Œdockerå‘½ä»¤æ˜¯, åœ¨å‰é¢ä¸æ·»åŠ sudo, å¯ä»¥æ‰§è¡Œå¦‚ä¸‹å‘½ä»¤: 1sudo usermod -aG docker $USER ç›¸å…³å‘½ä»¤ å¯åŠ¨ Docker Docker æœåŠ¡åœ¨å®‰è£…å®Œæˆåå¯èƒ½å¹¶æœªè‡ªåŠ¨å¯åŠ¨ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å¯åŠ¨ Docker æœåŠ¡ï¼š 1sudo systemctl start docker è®¾ç½® Docker å¼€æœºè‡ªå¯ å¦‚æœä½ å¸Œæœ› Docker åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶è‡ªåŠ¨è¿è¡Œï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å°†å…¶è®¾ç½®ä¸ºå¼€æœºè‡ªå¯ï¼š 1sudo systemctl enable docker åˆ›å»º Docker ç”¨æˆ·ç»„ é»˜è®¤æƒ…å†µä¸‹ï¼ŒDocker çš„å®ˆæŠ¤è¿›ç¨‹ä¼šä½¿ç”¨ Unix socket è¿è¡Œï¼Œè€Œåªæœ‰ root ç”¨æˆ·å’Œ docker ç»„çš„ç”¨æˆ·æ‰èƒ½è®¿é—®æ­¤ socketã€‚å¦‚æœæ‚¨çš„ç³»ç»Ÿä¸Šè¿˜æ²¡æœ‰ docker ç”¨æˆ·ç»„ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ›å»ºï¼š 1sudo groupadd docker å°†å½“å‰ç”¨æˆ·æ·»åŠ åˆ° Docker ç”¨æˆ·ç»„ ä¸ºäº†é¿å…æ¯æ¬¡è¿è¡Œ Docker å‘½ä»¤éƒ½éœ€è¦ä½¿ç”¨ sudoï¼Œæ‚¨å¯ä»¥å°†å½“å‰ç”¨æˆ·æ·»åŠ åˆ° docker ç”¨æˆ·ç»„ï¼š 1sudo usermod -aG docker $USER åº”ç”¨æ–°çš„ç”¨æˆ·ç»„è®¾ç½® ä¸ºäº†è®©æ–°çš„ç”¨æˆ·ç»„è®¾ç½®ç”Ÿæ•ˆï¼Œæ‚¨éœ€è¦æ³¨é”€å¹¶é‡æ–°ç™»å½•ï¼Œæˆ–è€…å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤åˆ‡æ¢åˆ°æ–°çš„ç”¨æˆ·ç»„ï¼š 1newgrp docker æµ‹è¯• Docker å®‰è£… ä¸ºäº†ç¡®è®¤ Docker å·²ç»æ­£ç¡®å®‰è£…å¹¶å¯ä»¥è¢«å½“å‰ç”¨æˆ·æ— éœ€ sudo å°±èƒ½æ­£ç¡®ä½¿ç”¨ï¼Œå¯ä»¥è¿è¡Œä¸€ä¸ªæµ‹è¯•å®¹å™¨ï¼Œä¾‹å¦‚ï¼š 1docker run hello-world","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"å­¦ä¹  Linux è‡ªå®šä¹‰å†…æ ¸æ¨¡å—","slug":"å­¦ä¹ -Linux-è‡ªå®šä¹‰å†…æ ¸æ¨¡å—","date":"2023-07-15T08:44:44.000Z","updated":"2023-07-18T08:12:34.398Z","comments":true,"path":"2023/07/15/å­¦ä¹ -Linux-è‡ªå®šä¹‰å†…æ ¸æ¨¡å—/","link":"","permalink":"http://example.com/2023/07/15/%E5%AD%A6%E4%B9%A0-Linux-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","excerpt":"ç¨‹åºä¸¾ä¾‹å¯ä»¥åœ¨ä»»æ„ç›®å½•ä¸‹ç¼–å†™è‡ªå®šä¹‰å†…æ ¸æ¨¡å—ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘å°†æ¨¡å—æ”¾åœ¨&#x2F;home&#x2F;hust&#x2F;modules_6.3.7ï¼Œä¾‹å¦‚ç¼–å†™ä¸€æ®µhello.cä»£ç  12345678910111213141516171819202122 // hello.c #include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;static int __init hello_init(void)&#123; printk(&quot;Hello World!\\n&quot;); return 0;&#125;static void __exit hello_exit(void)&#123; printk(&quot;Goodbye World!\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Your Name&quot;);MODULE_DESCRIPTION(&quot;A Simple Hello World module&quot;);","text":"ç¨‹åºä¸¾ä¾‹å¯ä»¥åœ¨ä»»æ„ç›®å½•ä¸‹ç¼–å†™è‡ªå®šä¹‰å†…æ ¸æ¨¡å—ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­æˆ‘å°†æ¨¡å—æ”¾åœ¨&#x2F;home&#x2F;hust&#x2F;modules_6.3.7ï¼Œä¾‹å¦‚ç¼–å†™ä¸€æ®µhello.cä»£ç  12345678910111213141516171819202122 // hello.c #include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;static int __init hello_init(void)&#123; printk(&quot;Hello World!\\n&quot;); return 0;&#125;static void __exit hello_exit(void)&#123; printk(&quot;Goodbye World!\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Your Name&quot;);MODULE_DESCRIPTION(&quot;A Simple Hello World module&quot;); è¯´æ˜ï¼šè™½ç„¶æ–‡ä»¶åç¼€ä¸º.cï¼Œä½†æ˜¯è¯­æ³•è·Ÿæ ‡å‡†cæœ‰å·®å¼‚ï¼Œæ¨¡å—ç¼–å†™æ˜¯åŸºäºå†…æ ¸ç¼–å†™çš„ ç¼–å†™Makefileåœ¨hello.cç›¸åŒç›®å½•ä¸‹æ–°å»ºMakefileæ–‡ä»¶ï¼Œå†…å®¹å¦‚ä¸‹ 12345678910obj-m := hello.o KDIR := /home/hust/linux-6.3.7MDIR := /home/hust/modules_6.3.7all: make -C $(KDIR) M=$(MDIR) modulesclean: make -C $(KDIR) M=$(MDIR) clean KDIRæ˜¯linuxå†…æ ¸çš„æºç æ–‡ä»¶å¤¹ï¼Œè¿™é‡Œlinux-6.3.7æ˜¯è‡ªå·±ç¼–è¯‘è¿è¡Œçš„å†…æ ¸ï¼Œæ‰€ä»¥ç›´æ¥å°±æ”¾çš„æ˜¯å†…æ ¸æºç æ–‡ä»¶å¤¹ï¼Œå¦‚æœæ˜¯Ubuntuçš„å†…æ ¸ï¼Œå°±åœ¨ &#x2F;usr&#x2F;srcæ–‡ä»¶å¤¹é‡Œæ‰¾åˆ°ç›¸åº”çš„å†…æ ¸ã€‚ MDIRæ˜¯hello.cæ‰€åœ¨çš„æ–‡ä»¶å¤¹ï¼Œå³è‡ªå®šä¹‰å†…æ ¸æ¨¡å—æ‰€åœ¨çš„æ–‡ä»¶å¤¹ã€‚ ç¼–è¯‘æ¨¡å—æ–‡ä»¶æ‰§è¡Œå‘½ä»¤ 1make å¾—åˆ°hello.koæ–‡ä»¶ï¼Œå³ä¸ºæ¨¡å—æ–‡ä»¶ å®‰è£…æ¨¡å—æ‰§è¡Œå‘½ä»¤ 1sudo insmod hello.ko éªŒè¯æ˜¯å¦æˆåŠŸæ‰§è¡Œå‘½ä»¤ 1sudo dmesg æŸ¥çœ‹è¾“å‡ºäº†æˆ‘ä»¬ä»£ç ä¸­æ‰“å°çš„Hello World! æ‰§è¡Œå‘½ä»¤ 1lsmod | grep hello å¯ä»¥çœ‹åˆ°æ¨¡å—å·²ç»å‡ºç°äº† å¸è½½æ¨¡å—æ‰§è¡Œ 1sudo rmmod hello éªŒè¯æ˜¯å¦æˆåŠŸæ‰§è¡Œå‘½ä»¤ 1sudo dmesg æŸ¥çœ‹è¾“å‡ºäº†æˆ‘ä»¬ä»£ç ä¸­æ‰“å°çš„Goodbye Worldï¼ æ‰§è¡Œ 1lsmod | grep hello å¯ä»¥çœ‹åˆ°æˆ‘ä»¬çš„æ¨¡å—å·²ç»ä¸å­˜åœ¨äº†","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"C++å­¦ä¹  ç½‘ç»œç¼–ç¨‹ libevent","slug":"C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-libevent","date":"2023-07-04T01:58:46.000Z","updated":"2023-07-26T10:02:32.873Z","comments":true,"path":"2023/07/04/C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-libevent/","link":"","permalink":"http://example.com/2023/07/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/","excerpt":"å­¦ä¹ ç›®æ ‡ æè¿°ä»€ä¹ˆæ˜¯libeventå¹¶æŒæ¡å¦‚ä½•å®‰è£… æŒæ¡event_baseçš„ä½œç”¨å’Œä½¿ç”¨æ–¹æ³• ç†Ÿç»ƒæŒæ¡libeventåº“ä¸­çš„äº‹ä»¶å¾ªç¯ æŒæ¡eventäº‹ä»¶çš„ä½¿ç”¨æ–¹æ³• æŒæ¡buffereventçš„å·¥ä½œæ–¹å¼ æŒæ¡ä½¿ç”¨libeventå®ç°TCPæœåŠ¡ç«¯æµç¨‹ æŒæ¡ä½¿ç”¨libeventå®ç°TCPå®¢æˆ·ç«¯æµç¨‹ libeventä»‹ç»","text":"å­¦ä¹ ç›®æ ‡ æè¿°ä»€ä¹ˆæ˜¯libeventå¹¶æŒæ¡å¦‚ä½•å®‰è£… æŒæ¡event_baseçš„ä½œç”¨å’Œä½¿ç”¨æ–¹æ³• ç†Ÿç»ƒæŒæ¡libeventåº“ä¸­çš„äº‹ä»¶å¾ªç¯ æŒæ¡eventäº‹ä»¶çš„ä½¿ç”¨æ–¹æ³• æŒæ¡buffereventçš„å·¥ä½œæ–¹å¼ æŒæ¡ä½¿ç”¨libeventå®ç°TCPæœåŠ¡ç«¯æµç¨‹ æŒæ¡ä½¿ç”¨libeventå®ç°TCPå®¢æˆ·ç«¯æµç¨‹ libeventä»‹ç» äº‹ä»¶é©±åŠ¨ã€é«˜æ€§èƒ½ã€è½»é‡çº§ã€ä¸“æ³¨äºç½‘ç»œ æºä»£ç ç²¾ç‚¼ã€æ˜“è¯» è·¨å¹³å° æ”¯æŒå¤šç§I&#x2F;Oå¤šè·¯å¤ç”¨æŠ€æœ¯ï¼Œå¦‚epollã€selectã€pollç­‰ æ”¯æŒI&#x2F;Oå’Œä¿¡å·ç­‰äº‹ä»¶ libeventçš„å®‰è£…libeventç™»å½•å®˜æ–¹ç½‘ç«™ï¼ŒæŸ¥çœ‹ç›¸å…³ä¿¡æ¯ libeventæºç ä¸‹è½½ä¸»è¦åˆ†2ä¸ªå¤§ç‰ˆæœ¬ï¼š 1.4.xç³»åˆ—ï¼Œè¾ƒä¸ºæ—©æœŸç‰ˆæœ¬ï¼Œé€‚åˆæºç å­¦ä¹  2.xç³»åˆ—ï¼Œè¾ƒæ–°çš„ç‰ˆæœ¬ï¼Œä»£ç é‡æ¯”1.4ç‰ˆæœ¬å¤šå¾ˆå¤šï¼ŒåŠŸèƒ½ä¹Ÿæ›´å®Œå–„ã€‚ libeventçš„æ ¸å¿ƒå®ç° åœ¨linuxä¸Šï¼Œå…¶å®è´¨å°±æ˜¯epollååº”å †ã€‚ libeventæ˜¯äº‹ä»¶é©±åŠ¨ï¼Œepollååº”å †ä¹Ÿæ˜¯äº‹ä»¶é©±åŠ¨ï¼Œå½“è¦æ£€æµ‹çš„äº‹ä»¶å‘ç”Ÿçš„æ—¶å€™ï¼Œå°±ä¼šè°ƒç”¨äº‹ä»¶å¯¹åº”çš„å›è°ƒå‡½æ•°ï¼Œæ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚ç‰¹åˆ«æé†’ï¼šäº‹ä»¶å›è°ƒå‡½æ•°æ˜¯ç”±ç”¨æˆ·å¼€å‘çš„ï¼Œä½†æ˜¯ä¸æ˜¯ç”±ç”¨æˆ·æ˜¾ç¤ºå»è°ƒç”¨çš„ï¼Œè€Œæ˜¯ç”±libeventå»è°ƒç”¨å¾—åˆ°ã€‚ ä»å®˜ç½‘ä¸‹è½½ä¸Šä¸‹è½½å®‰è£…æ–‡ä»¶ä¹‹åï¼Œå°†å®‰è£…æ–‡ä»¶ä¸Šä¼ åˆ°linuxç³»ç»Ÿä¸Šï¼›æºç åŒ…çš„å®‰è£…ï¼Œä»¥2.1.12ç‰ˆæœ¬ä¸ºä¾‹ï¼Œåœ¨å®˜ç½‘å¯ä»¥ä¸‹è½½åˆ°æºç åŒ…tar -zxvf libevent-2.1.12-stable.tar.gz,å®‰è£…æ­¥éª¤ä¸ç¬¬ä¸‰æ–¹åº“æºç åŒ…å®‰è£…æ–¹å¼åŸºæœ¬ä¸€è‡´ã€‚ è§£å‹libevent-2.1.12-stable.tar.gz è§£å‹ï¼štar -zxvf libevent-2.1.12-stable.tar.gz cdåˆ°libevent-2.1.12-stableç›®å½•ä¸‹ï¼ŒæŸ¥çœ‹READMEæ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶é‡Œæè¿°äº†å®‰è£…çš„è¯¦ç»†æ­¥éª¤ï¼Œå¯å‚ç…§è¿™ä¸ªæ–‡ä»¶è¿›è¡Œå®‰è£… 1234./configuremakemake verify # (optional)sudo make install è¿›å…¥æºç ç›®å½• æ‰§è¡Œé…ç½®.&#x2F;configureï¼Œæ£€æµ‹å®‰è£…ç¯å¢ƒã€‚ç”Ÿæˆmakefile æ‰§è¡Œ.&#x2F;configureçš„æ—¶å€™ä¹Ÿå¯ä»¥æŒ‡å®šè·¯å¾„ï¼Œ.&#x2F;configure â€“prefix&#x3D;&#x2F;usr&#x2F;xxxxx,è¿™æ ·å°±å¯ä»¥å®‰è£…åˆ°æŒ‡å®šçš„ç›®å½•ä¸‹ï¼Œä½†æ˜¯è¿™æ ·åœ¨è¿›è¡Œæºä»£ç ç¼–è¯‘çš„æ—¶å€™å°±å¯ä»¥å®‰è£…åˆ°æŒ‡å®šçš„ç›®å½•ä¸‹ï¼Œä½†æ˜¯è¿™æ ·åœ¨è¿›è¡Œæºä»£ç ç¼–è¯‘çš„æ—¶å€™éœ€è¦æŒ‡å®šç”¨-lå¤´æ–‡ä»¶çš„è·¯å¾„å’Œç”¨-Låº“æ–‡ä»¶çš„è·¯å¾„ã€‚è‹¥é»˜è®¤å®‰è£…ä¸æŒ‡å®šâ€“prefixï¼Œåˆ™ä¼šå®‰è£…åˆ°ç³»ç»Ÿé»˜è®¤çš„è·¯å¾„ä¸‹ï¼Œç¼–è¯‘çš„æ—¶å€™å¯ä»¥ä¸æŒ‡å®šå¤´æ–‡ä»¶å’Œåº“æ–‡ä»¶æ‰€åœ¨çš„è·¯å¾„ã€‚ æ‰§è¡Œmakeå‘½ä»¤ç¼–è¯‘æ•´ä¸ªé¡¹ç›®æ–‡ä»¶ é€šè¿‡æ‰§è¡Œmakeå‘½ä»¤ï¼Œä¼šç”Ÿæˆä¸€äº›åº“æ–‡ä»¶ï¼ˆåŠ¨æ€åº“å’Œé™æ€åº“ï¼‰å’Œå¯æ‰§è¡Œæ–‡ä»¶ æ‰§è¡Œsudo make installè¿›è¡Œå®‰è£… å®‰è£…éœ€è¦rootç”¨æˆ·æƒé™ï¼Œè¿™ä¸€æ­¥éœ€è¦è¾“å…¥å½“å‰ç”¨æˆ·çš„å¯†ç  æ‰§è¡Œè¿™ä¸€æ­¥ï¼Œå¯ä»¥å°†åˆšåˆšç¼–è¯‘æˆçš„åº“æ–‡ä»¶å’Œæ‰§è¡Œæ–‡ä»¶ä»¥åŠä¸€äº›å¤´æ–‡ä»¶æ‹·è´åˆ°&#x2F;usr&#x2F;localç›®å½•ä¸‹ï¼š å¤´æ–‡ä»¶æ‹·è´åˆ°äº†&#x2F;usr&#x2F;local&#x2F;includeç›®å½•ä¸‹ï¼› åº“æ–‡ä»¶æ‹·è´åˆ°äº†&#x2F;usr&#x2F;local&#x2F;libç›®å½•ä¸‹ libeventåº“çš„ä½¿ç”¨è¿›å…¥åˆ°libevent-2.1.12-stable&#x2F;sampleä¸‹ï¼Œå¯ä»¥æŸ¥çœ‹ä¸€äº›å®ä¾‹æºä»£ç æ–‡ä»¶ã€‚ä½¿ç”¨libeventåº“ç¼–å†™ä»£ç åœ¨ç¼–è¯‘ç¨‹åºçš„æ—¶å€™éœ€è¦æŒ‡å®šåº“åï¼š-leventï¼› å®‰è£…æ–‡ä»¶çš„libeventåº“æ–‡ä»¶æ‰€åœ¨è·¯å¾„ï¼šlibevent-2.1.12-stable&#x2F;.libs; ç¼–å†™ä»£ç çš„æ—¶å€™ç”¨åˆ°event.hå¤´æ–‡ä»¶ï¼Œæˆ–è€…ç›´æ¥å‚è€ƒsampleç›®å½•ä¸‹çš„æºä»£ç æ–‡ä»¶ä¹Ÿå¯ä»¥ã€‚ 1#include&lt;event2/event.h&gt; ç”±äºå®‰è£…çš„æ—¶å€™å·²ç»å°†å¤´æ–‡ä»¶å’Œåº“æ–‡ä»¶æ‹·è´åˆ°äº†ç³»ç»Ÿå¤´æ–‡ä»¶æ‰€åœ¨è·¯å¾„&#x2F;usr&#x2F;local&#x2F;includeå’Œç³»ç»Ÿåº“æ–‡ä»¶æ‰€åœ¨è·¯å¾„&#x2F;usr&#x2F;local&#x2F;libï¼Œæ‰€ä»¥è¿™é‡Œç¼–è¯‘çš„æ—¶å€™å¯ä»¥ä¸æŒ‡å®š-lå’Œ-L ç¼–è¯‘æºä»£ç æ–‡ä»¶ï¼ˆä»¥hello-world.cæ–‡ä»¶ä¸ºä¾‹ï¼‰ 1gcc hello-world.c -levent æµ‹è¯•ï¼Œç¼–è¯‘ä¹‹åï¼Œåœ¨æ–‡ä»¶å¤¹ä¸­è¿è¡Œhello-worldç¨‹åºï¼Œåœ¨å¦ä¸€ä¸ªä¸­æ®µçª—å£è¿›è¡Œæµ‹è¯•ï¼Œè¾“å…¥ï¼šnc 127.1 9995ï¼Œç„¶åå›è½¦ç«‹åˆ»æ˜¾ç¤ºHelloï¼ŒWorldï¼å­—ç¬¦ä¸²ã€‚ libeventçš„ä½¿ç”¨libeventçš„åœ°åŸºevent_baseä½¿ç”¨libeventå‡½æ•°ä¹‹å‰éœ€è¦åˆ†é…ä¸€ä¸ªæˆ–è€…å¤šä¸ªevent_baseç»“æ„ä½“ï¼Œæ¯ä¸ªevent_baseç»“æ„ä½“æŒæœ‰ä¸€ä¸ªäº‹ä»¶é›†åˆï¼Œå¯ä»¥æ£€æµ‹ä»¥ç¡®å®šå“ªä¸ªäº‹ä»¶æ˜¯æ¿€æ´»çš„ï¼Œevent_baseç»“æ„ç›¸å½“äºepollçº¢é»‘æ ‘çš„æ ‘æ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸ªevent_baseéƒ½æœ‰ä¸€ç§ç”¨äºæ£€æµ‹æŸç§äº‹ä»¶å·²ç»å°±ç»ªçš„â€æ–¹æ³•â€ï¼ˆå›è°ƒå‡½æ•°ï¼‰ é€šå¸¸æƒ…å†µä¸‹å¯ä»¥é€šè¿‡event_base_newå‡½æ•°è·å¾—event_baseç»“æ„ã€‚ ç›¸å…³å‡½æ•°è¯´æ˜ï¼š struct event_base* event_base_new(void) //å‡½æ•°è¯´æ˜ï¼šè·å¾—event_baseç»“æ„ //å‚æ•°è¯´æ˜ï¼šæ—  //è¿”å›å€¼ï¼š // - æˆåŠŸè¿”å›event_baseç»“æ„ä½“æŒ‡é’ˆ // - å¤±è´¥è¿”å›NULL 1234- ```cpp void event_base_free(struct event_base*) //å‡½æ•°è¯´æ˜ï¼šé‡Šæ”¾event_baseæŒ‡é’ˆ int event_reinit(struct event_base* base) //å‡½æ•°è¯´æ˜ï¼šå¦‚æœæœ‰å­è¿›ç¨‹ï¼Œä¸”å­è¿›ç¨‹ä¹Ÿè¦ä½¿ç”¨baseï¼Œåˆ™å­è¿›ç¨‹éœ€è¦å¯¹event_baseé‡æ–°åˆå§‹åŒ–ï¼Œæ­¤æ—¶éœ€è¦è°ƒç”¨event_baseé‡æ–°åˆå§‹åŒ–ï¼Œæ­¤æ—¶éœ€è¦è°ƒç”¨event_reinitå‡½æ•° //å‡½æ•°å‚æ•°ï¼šç”±event_base_newè¿”å›çš„æ‰§è¡Œevent_baseç»“æ„çš„æŒ‡é’ˆ //è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 12345678910å¯¹äºä¸åŒç³»ç»Ÿè€Œè¨€ï¼Œevent_baseå°±æ˜¯è°ƒç”¨ä¸åŒçš„å¤šè·¯IOæ¥å£å»åˆ¤æ–­äº‹ä»¶æ˜¯å¦å·²ç»è¢«æ¿€æ´»ï¼Œå¯¹äºlinuxç³»ç»Ÿè€Œè¨€ï¼Œæ ¸å¿ƒè°ƒç”¨çš„å°±æ˜¯epollï¼ŒåŒæ—¶æ”¯æŒpollå’Œselectã€‚æŸ¥çœ‹libeventæ”¯æŒçš„åç«¯çš„æ–¹æ³•æœ‰å“ªäº›ï¼š- ```cpp const char** event_get_supported_methods(void) //å‡½æ•°è¯´æ˜ï¼šè·å¾—å½“å‰ç³»ç»Ÿï¼ˆæˆ–è€…ç§°ä¸ºå¹³å°ï¼‰æ”¯æŒçš„æ–¹æ³•æœ‰å“ªäº› //å‚æ•°ï¼šæ—  //è¿”å›å€¼ï¼šè¿”å›äºŒç»´æ•°ç»„ï¼Œç±»ä¼¼ä¸mainå‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°**argv const char** event_base_get_method(const struct event_base* base) //å‡½æ•°è¯´æ˜ï¼šè·å¾—å½“å‰baseèŠ‚ç‚¹ä½¿ç”¨çš„å¤šè·¯ioæ–¹æ³• //å‡½æ•°å‚æ•°ï¼ševent_baseç»“æ„çš„baseæŒ‡é’ˆ //è¿”å›å€¼ï¼šè·å¾—å½“å‰baseèŠ‚ç‚¹ä½¿ç”¨çš„å¤šè·¯ioæ–¹æ³•çš„æŒ‡é’ˆ 1234567891011121314151617181920212223242526272829303132```cpp//æµ‹è¯•å½“å‰ç³»ç»Ÿæ”¯æŒçš„libeventæ–¹æ³•å’Œå½“å‰ä½¿ç”¨çš„æ–¹æ³•#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;event2/event.h&gt;int main()&#123; int i = 0; //è·å–å½“å‰ç³»ç»Ÿæ”¯æŒçš„æ–¹æ³• const char** p = event_get_supported_methods(); while (p[i] != NULL) &#123; printf(&quot;%s \\t&quot;, p[i++]); &#125; printf(&quot;\\n&quot;); //è·å–åœ°åŸºèŠ‚ç‚¹ struct event_base* base = event_base_new(); if (base == NULL) &#123; printf(&quot;event_base_new error\\n&quot;); return -1; &#125; //è¯»å–å½“å‰ç³»ç»Ÿä½¿ç”¨çš„æ–¹æ³• const char** pp = event_base_get_method(base); printf(&quot;%s\\n&quot;, pp); //é‡Šæ”¾åœ°åŸºèŠ‚ç‚¹ event_base_free(base); return 0;&#125; è¿è¡Œç»“æœä¸ºï¼š epoll poll selectepoll ç­‰å¾…äº‹ä»¶äº§ç”Ÿ-å¾ªç¯ç­‰å¾…event_looplibeventåœ¨åœ°åŸºæ‰“å¥½ä¹‹åï¼Œéœ€è¦ç­‰å¾…äº‹ä»¶çš„äº§ç”Ÿï¼Œä¹Ÿå°±æ˜¯ç­‰å¾…äº‹ä»¶è¢«æ¿€æ´»åï¼Œæ‰€ä»¥ç¨‹åºä¸èƒ½é€€å‡ºï¼Œå¯¹äºepollæ¥è¯´ï¼Œæˆ‘ä»¬éœ€è¦è‡ªå·±æ§åˆ¶å¾ªç¯ï¼Œè€Œåœ¨libeventä¸­ä¹Ÿç»™æˆ‘ä»¬æä¾›äº†APIæ¥å£ï¼Œç±»ä¼¼where(1)çš„åŠŸèƒ½ã€‚ å‡½æ•°å¦‚ä¸‹ï¼š 1234567891011int event_base_loop(struct event_base* ï¼Œint flag)//å‡½æ•°è¯´æ˜ï¼šè¿›å…¥å¾ªç¯ç­‰å¾…äº‹ä»¶//å‚æ•°è¯´æ˜// - baseï¼šç”±event_base_newå‡½æ•°è¿”å›çš„æŒ‡å‘event_baseç»“æ„çš„æŒ‡é’ˆ// - flagsçš„å–å€¼ï¼š// - #define EVLOOP_ONCE 0x01 åªè§¦å‘ä¸€æ¬¡ï¼Œå¦‚æœäº‹ä»¶æ²¡æœ‰è¢«è§¦å‘ï¼Œé˜»å¡ç­‰å¾…// - #define EVLOOP_NONBLOCK 0x02 éé˜»å¡æ–¹å¼æ£€æµ‹äº‹ä»¶æ˜¯å¦è¢«å¤„ç½šæ³•ï¼Œä¸ç®¡äº‹ä»¶è§¦å‘ä¸å¦ï¼Œéƒ½ä¼šç«‹å³è¿”å›// - baseï¼šç”±event_base_newå‡½æ•°è¿”å›çš„æŒ‡å‘event_baseç»“æ„çš„æŒ‡é’ˆ// - flagsçš„å–å€¼ï¼š// - #define EVLOOP_ONCE 0x01 åªè§¦å‘ä¸€æ¬¡ï¼Œå¦‚æœäº‹ä»¶æ²¡æœ‰è¢«è§¦å‘ï¼Œé˜»å¡ç­‰å¾…// - #define EVLOOP_NONBLOCK 0x02 éé˜»å¡æ–¹å¼æ£€æµ‹äº‹ä»¶æ˜¯å¦è¢«å¤„ç½šæ³•ï¼Œä¸ç®¡äº‹ä»¶è§¦å‘ä¸å¦ï¼Œéƒ½ä¼šç«‹å³è¿”å› è¿™ä¸ªå‡½æ•°ä¸€èˆ¬ä¸ç”¨ï¼Œè€Œå¤§å¤šæ•°éƒ½è°ƒç”¨libeventç»™æˆ‘ä»¬æä¾›çš„å¦å¤–ä¸€ä¸ªAPIï¼š 1234int event_base_dispath(struct event_base* base)//å‡½æ•°è¯´æ˜ï¼šè¿›å…¥å¾ªç¯ç­‰å¾…äº‹ä»¶//å‚æ•°è¯´æ˜ï¼šç”±event_base_newå‡½æ•°è¿”å›çš„æŒ‡å‘event_baseç»“æ„çš„æŒ‡é’ˆ//è°ƒç”¨è¯¥å‡½æ•°ï¼Œç›¸å½“äºæ²¡æœ‰è®¾ç½®æ ‡å¿—ä½çš„event_base_loopã€‚ç¨‹åºå°†ä¼šä¸€ç›´è¿è¡Œï¼ŒçŸ¥é“æ²¡æœ‰éœ€è¦æ£€æµ‹çš„äº‹ä»¶äº†ï¼Œæˆ–è€…ç»“æŸå¾ªç¯çš„APIç»ˆæ­¢ è°ƒç”¨è¯¥å‡½æ•°ï¼Œç›¸å½“äºæ²¡æœ‰è®¾ç½®æ ‡å¿—ä½çš„event_base_loopã€‚ç¨‹åºå°†ä¼šä¸€ç›´è¿è¡Œï¼Œç›´åˆ°æ²¡æœ‰éœ€è¦æ£€æµ‹çš„äº‹ä»¶äº†ï¼Œæˆ–è€…è¢«ç»“æŸå¾ªç¯çš„APIç»ˆæ­¢ã€‚ 1234567int event_base_loopexit(struct event_base* base, const struct timeval* tv)int event_base_loopbreak(struct event_base* base)struct timeval&#123; long tv_sec; long tv_usec;&#125; ä¸¤ä¸ªå‡½æ•°çš„åŒºåˆ«æ˜¯å¦‚æœæ­£åœ¨æ‰§è¡Œæ¿€æ´»äº‹ä»¶çš„å›è°ƒå‡½æ•°ï¼Œé‚£ä¹ˆevent_base_loopexitå°†åœ¨äº‹ä»¶å›è°ƒæ‰§è¡Œç»“æŸåç»ˆæ­¢å¾ªç¯ï¼ˆå¦‚æœtväº‹ä»¶éNULLï¼Œé‚£ä¹ˆå°†ç­‰å¾…tvè®¾ç½®çš„æ—¶é—´åç«‹å³ç»“æŸå¾ªç¯ï¼‰ï¼Œè€Œevent_base_loopbreakä¼šç«‹å³ç»ˆæ­¢å¾ªç¯ã€‚ ä½¿ç”¨libeventåº“çš„æ­¥éª¤ åˆ›å»ºæ ¹èŠ‚ç‚¹â€“event_base_new è®¾ç½®ç›‘å¬äº‹ä»¶å’Œæ•°æ®å¯è¯»å¯å†™çš„äº‹ä»¶çš„å›è°ƒå‡½æ•°ï¼Œè®¾ç½®äº†äº‹ä»¶å¯¹åº”çš„å›è°ƒå‡½æ•°ä»¥åï¼Œå½“äº‹ä»¶äº§ç”Ÿçš„æ—¶å€™ä¼šè‡ªåŠ¨è°ƒç”¨å›è°ƒå‡½æ•° äº‹ä»¶å¾ªç¯â€“event_base_dispatchï¼Œç›¸å½“äºwhile(1),åœ¨å¾ªç¯å†…éƒ¨ç­‰å¾…äº‹ä»¶çš„å‘ç”Ÿï¼Œè‹¥æœ‰äº‹ä»¶å‘ç”Ÿåˆ™ä¼šè§¦å‘äº‹ä»¶å¯¹åº”çš„å›è°ƒå‡½æ•°ã€‚ é‡Šæ”¾æ ¹èŠ‚ç‚¹â€“event_base_freeï¼Œé‡Šæ”¾ç”±event_base_newå’Œevent_newåˆ›å»ºçš„èµ„æºï¼Œåˆ†åˆ«è°ƒç”¨event_base_freeå’Œevent_freeå‡½æ•°ã€‚ äº‹ä»¶é©±åŠ¨-eventäº‹ä»¶é©±åŠ¨å®é™…ä¸Šlibeventçš„æ ¸å¿ƒæ€æƒ³ï¼Œä¸»è¦çš„çŠ¶æ€è½¬åŒ– ä¸»è¦çš„å‡ ä¸ªçŠ¶æ€ï¼š æ— æ•ˆçš„æŒ‡é’ˆï¼šæ­¤æ—¶ä»…ä»…æ˜¯å®šä¹‰äº†struct event *ptr éæœªå†³ï¼šç›¸å½“äºåˆ›å»ºäº†äº‹ä»¶ï¼Œä½†æ˜¯äº‹ä»¶è¿˜æ²¡æœ‰å¤„äºè¢«ç›‘å¬çŠ¶æ€ï¼Œç±»ä¼¼äºæˆ‘ä»¬ä½¿ç”¨epollçš„æ—¶å€™å®šä¹‰äº†struct epoll_event evå¹¶ä¸”å¯¹evçš„ä¸¤ä¸ªå­—æ®µè¿›è¡Œäº†èµ‹å€¼ï¼Œä½†æ˜¯æ­¤æ—¶å°šæœªè°ƒç”¨epoll_ctlå¯¹äº‹ä»¶ä¸Šè¿°ã€‚ æœªå†³ï¼šå°±æ˜¯å¯¹äº‹ä»¶å¼€å§‹ç›‘å¬ï¼Œæš‚æ—¶æœªæœ‰äº‹ä»¶äº§ç”Ÿã€‚ç›¸å½“äºè°ƒç”¨epoll_ctlå¯¹è¦ç›‘å¬çš„äº‹ä»¶ä¸Šæ ‘ï¼Œä½†æ˜¯æ²¡æœ‰äº‹ä»¶äº§ç”Ÿã€‚ æ¿€æ´»ï¼šä»£è¡¨ç›‘å¬çš„äº‹ä»¶å·²ç»äº§ç”Ÿï¼Œè¿™æ—¶éœ€è¦å¤„ç†ï¼Œç›¸å½“äºè°ƒç”¨epoll_waitå‡½æ•°æœ‰è¿”å›ï¼Œå½“äº‹ä»¶è¢«æ¿€æ´»ä»¥åï¼Œlibeventä¼šè°ƒç”¨è¯¥äº‹ä»¶å¯¹åº”çš„å›è°ƒå‡½æ•°ã€‚ libeventçš„äº‹ä»¶é©±åŠ¨å¯¹åº”çš„ç»“æ„ä½“ä¸ºstruct eventï¼Œå¯¹åº”çš„å‡½æ•°åœ¨å›¾ä¸Šä¹Ÿæ¯”è¾ƒæ¸…æ™°ã€‚ typedef void(*event_callback_fn)(evutil_socket_t fd, short events, event_callback_fn cb, void* arg) 123456789101112131415- ```cpp struct event* event_new(struct event_base* base, evutil_socket_t fd, short events, event_callback_fn cb, void* arg) //å‡½æ•°è¯´æ˜ï¼ševent_newè´Ÿè´£åˆ›å»ºeventç»“æ„æŒ‡é’ˆï¼ŒåŒæ—¶æŒ‡å®šå¯¹åº”çš„åœ°åŸºbaseï¼Œè¿˜æœ‰å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œäº‹ä»¶ï¼Œä»¥åŠå›è°ƒå‡½æ•°å’Œå›è°ƒå‡½æ•°çš„å‚æ•° //å‚æ•°è¯´æ˜ï¼š // - baseï¼šå¯¹åº”çš„æ ¹èŠ‚ç‚¹--åœ°åŸº // - fdï¼šè¦ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦ // - eventsï¼šè¦ç›‘å¬çš„äº‹ä»¶ // - #define EV_TIMEOUT 0x01 //è¶…æ—¶äº‹ä»¶ // - #define EV_READ 0x02 //è¯»äº‹ä»¶ // - #define EV_WRITE 0x04 //å†™äº‹ä»¶ // - #define EV_SIGNAL 0x08 //ä¿¡å·è§¦å‘ // - #define EV_PERSIST 0x10 //å‘¨æœŸæ€§è§¦å‘ // - #define EV_ET 0x20 //è¾¹ç¼˜è§¦å‘ï¼Œå¦‚æœåº•å±‚æ¨¡å‹æ”¯æŒè®¾ç½®åˆ™æœ‰æ•ˆï¼Œè‹¥ä¸æ”¯æŒåˆ™æ— æ•ˆ // - è‹¥è¦æƒ³è®¾ç½®æŒç»­çš„è¯»äº‹ä»¶åˆ™ï¼šEV_READ|EV_PERSIST cbå›è°ƒå‡½æ•°ï¼ŒåŸå‹å¦‚ä¸‹ï¼š typedef void(*event_callback_fn)(evutil_socket_t fd,short events,void *arg) 123456 æ³¨æ„ï¼šå›è°ƒå‡½æ•°çš„å‚æ•°å°±å¯¹åº”äºevent_newå‡½æ•°çš„fdï¼Œeventå’Œarg- ```cpp #define evsignal_new(b,x,cb,arg) event_new((b),(x),EV_SIGNAL|EV_PRESIST,(cb),(arg)) int event_add(struct event* ev, const struct timeval* timeout) //å‡½æ•°è¯´æ˜ï¼šå°†éæœªå†³æ€äº‹ä»¶è½¬ä¸ºæœªå†³æ€ï¼Œç›¸å½“äºè°ƒç”¨epoll_ctlå‡½æ•°ï¼ˆEPOLL_CTL_ADDï¼‰ï¼Œå¼€å§‹ç›‘å¬äº‹ä»¶æ˜¯å¦äº§ç”Ÿï¼Œç›¸å½“äºepollçš„ä¸Šæ ‘æ“ä½œ //å‚æ•°è¯´æ˜ï¼š // - evï¼šè°ƒç”¨event_newåˆ›å»ºçš„äº‹ä»¶ // - timeoutï¼šé™æ—¶ç­‰å¾…äº‹ä»¶çš„äº§ç”Ÿï¼Œä¹Ÿå¯ä»¥è®¾ç½®ä¸ºNULLï¼Œæ²¡æœ‰é™æ—¶ã€‚ 12345- ```cpp int event_del(struct event* ev) //å‡½æ•°è¯´æ˜ï¼šå°†äº‹ä»¶ä»æœªå†³æ€å˜ä¸ºéæœªå†³æ€ï¼Œç›¸å½“äºepollçš„ä¸‹æ ‘ï¼ˆepoll_ctlè°ƒç”¨EPOLL_CTL_DELæ“ä½œï¼‰æ“ä½œ //å‚æ•°è¯´æ˜ï¼ševæŒ‡çš„æ˜¯ç”±event_newåˆ›å»ºçš„äº‹ä»¶ void event_free(struct event* ev) //å‡½æ•°è¯´æ˜ï¼šé‡Šæ”¾ç”±event_newç”³è¯·çš„eventèŠ‚ç‚¹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143# ç¼–å†™ä¸€ä¸ªåŸºäºeventå®ç°çš„tcpæœåŠ¡å™¨æ€»ä½“æ­¥éª¤ï¼š1. æ­å»ºæœåŠ¡å™¨å›ºå®šä¸‰æ­¥ï¼Œæ ‡å‡ºçš„ä¸‰æ­¥ï¼š - &lt;mark&gt;åˆ›å»ºsocket---socket()&lt;/mark&gt; - è®¾ç½®ç«¯å£å¤ç”¨---setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(int)) - &lt;mark&gt;ç»‘å®šbind---bind()&lt;/mark&gt; - &lt;mark&gt;ç›‘å¬listen---listen()&lt;/mark&gt; - åˆ›å»ºåœ°åŸº---struct event_base *base = event_base_new()ï¼ˆä¸‹é¢çš„ç¬¬äºŒæ­¥ï¼‰ - åˆ›å»ºlfdå¯¹åº”çš„äº‹ä»¶èŠ‚ç‚¹---struct event *ev = event_new(base,lfdï¼ŒEV_READ|EV_PERSIST,conncb,NULL)(ä¸‹é¢çš„ç¬¬ä¸‰æ­¥) - ä¸Ševent_baseåœ°åŸº---event_add(ev,NULL) - è¿›å…¥äº‹ä»¶å¾ªç¯---event_base_dispatch(base)(ä¸‹é¢çš„ç¬¬å››æ­¥) - é‡Šæ”¾èµ„æº--event_base_free(base),event_free(ev) - 2. è°ƒç”¨event_base_newå‡½æ•°åˆ›å»ºevent_baseèŠ‚ç‚¹3. åˆ›å»ºè¦ç›‘å¬çš„äº‹ä»¶eventï¼Œä¸»è¦å°±æ˜¯ç›‘å¬äº‹ä»¶å’Œè¯»æ•°æ®çš„äº‹ä»¶ - è®¾ç½®å¥½ç›‘å¬äº‹ä»¶çš„å›è°ƒå‡½æ•°ï¼Œç„¶åevent_addä¸Šæ ‘ - æœ‰æ–°çš„è¿æ¥ï¼Œåˆ™è°ƒç”¨acceptæ¥å—æ–°çš„è¿æ¥ - å°†è¿™ä¸ªæ–°çš„è¿æ¥è®¾ç½®å¥½å›è°ƒå‡½æ•°ï¼ˆä¸€èˆ¬æ˜¯è®¾ç½®è¯»äº‹ä»¶ï¼‰ï¼Œç„¶åç»§ç»­event_addä¸Šè¿°ï¼Œè‹¥æœ‰å®¢æˆ·ç«¯å…³é—­è¿æ¥åˆ™ä»æ ‘ä¸Šæ‘˜é™¤è¯¥äº‹ä»¶èŠ‚ç‚¹4. è°ƒç”¨event_base_dispatchè¿›å…¥å¾ªç¯ç­‰å¾…äº‹ä»¶çš„å‘ç”Ÿ# libeventæœåŠ¡ç«¯ç¨‹åºçš„ä»£ç å®ç°```cpp#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;netinet/in.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;event2/event.h&gt;struct event* connev = NULL;void readcb(evutil_socket_t fd, short events, void* arg)&#123; int n; char buf[1024]; memset(buf, 0x00, sizeof(buf)); n = read(fd, buf, sizeof(buf)); if (n &lt;= 0) &#123; close(fd); //å°†é€šä¿¡æ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„äº‹ä»¶ä»baseåœ°åŸºä¸Šåˆ é™¤ event_del(connev); return; &#125; else &#123; write(fd, buf, n); &#125; write(fd, buf, n);&#125;void conncb(evutil_socket_t fd, short events, void* arg)&#123; struct event_base* base = (struct event_base*)arg; //æ¥å—æ–°çš„å®¢æˆ·ç«¯è¿æ¥ int cfd = accept(fd, NULL, NULL); if (cfd &gt; 0) &#123; //åˆ›å»ºé€šä¿¡æè¿°ç¬¦å¯¹åº”çš„äº‹ä»¶å¹¶è®¾ç½®å›è°ƒå‡½æ•°ä¸ºreadcb struct event* connev = event_new(base, cfd, EV_READ | EV_PERSIST, readcb, NULL); if (connev == NULL) &#123; //é€€å‡ºå¾ªç¯ event_base_loopexit(base, NULL); &#125; //å°†é€šä¿¡æ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„äº‹ä»¶ä¸Ševent_baseåœ°åŸº event_add(connev, NULL); &#125;&#125;int main()&#123; //åˆ›å»ºsocket int fd = socket(AF_INET, SOCK_STREAM, 0); //è®¾ç½®ç«¯å£å¤ç”¨ int opt = 1; setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); //ç»‘å®š struct sockaddr_in serv; bzero(&amp;serv, sizeof(serv)); serv.sin_addr.s_addr = htonl(INADDR_ANY); serv.sin_port = htons(8888); serv.sin_family = AF_INET; bind(fd, (struct sockaddr*)&amp;serv, sizeof(serv)); //ç›‘å¬ listen(fd, 120); //åˆ›å»ºåœ°åŸº struct event_base* base = event_base_new(); if (base == NULL) &#123; printf(&quot;event_base_new error\\n&quot;); return -1; &#125; //åˆ›å»ºç›‘å¬æ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„äº‹ä»¶ struct event* ev = event_new(base, fd, EV_READ | EV_PERSIST, conncb, base); if (ev == NULL) &#123; printf(&quot;event_new error\\n&quot;); return -1; &#125; //å°†æ–°çš„äº‹ä»¶èŠ‚ç‚¹ä¸Šbaseåœ°åŸº event_add(ev, NULL); //è¿›å…¥äº‹ä»¶å¾ªç¯ç­‰å¾… event_base_dispatch(base); //é‡Šæ”¾èµ„æº event_base_free(base); event_free(ev); close(fd); return 0; &#125; libeventæœåŠ¡ç«¯ç¨‹åºæµ‹è¯•å’Œé”™è¯¯åˆ†æä½¿ç”¨ä¸‹é¢å‘½ä»¤æ‰“å¼€å®¢æˆ·ç«¯ï¼š 1nc 127.1 8888 ä½¿ç”¨ä¸‹é¢å‘½ä»¤æŸ¥çœ‹å¯¹åº”çš„ç«¯å£çŠ¶æ€ï¼š 1netstat -anp | grep 8888 åˆ†æä¹‹åï¼Œæ ¹æ®ä¸Šè¿°ä»£ç ï¼Œåªè¦å…³é—­æœ€åä¸€ä¸ªå®¢æˆ·ç«¯æ—¶ï¼Œä¹Ÿä¼šå½±å“åˆ°åˆ«çš„å®¢æˆ·ç«¯ã€‚ è‡ªå¸¦bufferçš„äº‹ä»¶buffereventbuffereventå®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªeventï¼Œåªä¸è¿‡æ¯”æ™®é€šçš„eventé«˜çº§ä¸€äº›ï¼Œå®ƒçš„å†…éƒ¨æœ‰ä¸¤ä¸ªç¼“å†²åŒºï¼Œä»¥åŠä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼ˆç½‘ç»œå¥—æ¥å­—ï¼‰ã€‚ä¸€ä¸ªç½‘ç»œå¥—æ¥å­—æœ‰è¯»å’Œå†™ä¸¤ä¸ªç¼“å†²åŒºï¼ŒbuffereventåŒæ ·ä¹Ÿå¸¦æœ‰ä¸¤ä¸ªç¼“å†²åŒºï¼Œè¿˜æœ‰å°±æ˜¯libeventäº‹ä»¶é©±åŠ¨çš„æ ¸å¿ƒå›è°ƒå‡½æ•°ï¼Œé‚£ä¹ˆå››ä¸ªç¼“å†²åŒºä»¥åŠè§¦å‘å›è°ƒçš„å…³ç³»å¦‚ä¸‹ï¼š ä»å›¾ä¸­å¯ä»¥å¾—çŸ¥ï¼Œä¸€ä¸ªbuffereventå¯¹åº”ä¸¤ä¸ªç¼“å†²åŒºï¼Œä¸‰ä¸ªå›è°ƒå‡½æ•°ï¼Œåˆ†åˆ«æ˜¯å†™å›è°ƒï¼Œè¯»å›è°ƒå’Œäº‹ä»¶å›è°ƒã€‚ buffereventæœ‰ä¸‰ä¸ªå›è°ƒå‡½æ•°ï¼š è¯»å›è°ƒ - å½“buffereventå°†åº•å±‚è¯»ç¼“å†²åŒºçš„æ•°æ®è¯»åˆ°è‡ªèº«çš„è¯»ç¼“å†²åŒºæ—¶è§¦å‘è¯»äº‹ä»¶å›è°ƒ å†™å›è°ƒ - å½“buffereventå°†è‡ªèº«å†™ç¼“å†²çš„æ•°æ®å†™åˆ°åº•å±‚å†™ç¼“å†²åŒºçš„æ—¶å€™è§¦å‘å†™äº‹ä»¶å›è°ƒï¼Œç”±äºæ•°æ®æœ€ç»ˆæ˜¯å†™å…¥äº†å†…æ ¸çš„å†™ç¼“å†²åŒºä¸­ï¼Œåº”ç”¨ç¨‹åºä»¥åŠæ— æ³•æ§åˆ¶ï¼Œè¿™ä¸ªäº‹ä»¶å¯¹äºåº”ç”¨ç¨‹åºæ¥è¯´åŸºæœ¬æ²¡ä»€ä¹ˆç”¨ï¼Œåªæ˜¯é€šçŸ¥åŠŸèƒ½ã€‚ äº‹ä»¶å›è°ƒ - å½“buffereventç»‘å®šçš„socketè¿æ¥ï¼Œæ–­å¼€æˆ–è€…å¼‚å¸¸çš„æ—¶å€™è§¦å‘äº‹ä»¶å›è°ƒã€‚ buffereventçš„è¯»äº‹ä»¶è§¦å‘æ—¶æœº å½“æ•°æ®ç”±å†…æ ¸çš„è¯»ç¼“å†²åŒºåˆ° buffereventçš„è¯»ç¼“å†²åŒºçš„æ—¶å€™ï¼Œä¼šè§¦å‘buffereventè¯»äº‹ä»¶å›è°ƒ éœ€è¦æ³¨æ„çš„æ˜¯ï¼šæ•°æ®ç”±å†…æ ¸åˆ°buffereventçš„è¿‡ç¨‹ä¸æ˜¯ç”¨æˆ·ç¨‹åºåšçš„ï¼Œæ˜¯ç”±buffereventå†…éƒ¨æ“ä½œçš„ã€‚ buffereventçš„å†™äº‹ä»¶è§¦å‘æ—¶æœº å½“ç”¨æˆ·ç¨‹åºå°†æ•°æ®å†™åˆ°buffereventçš„å†™ç¼“å†²åŒºä¹‹åï¼Œbuffereventä¼šè‡ªåŠ¨å°†æ•°æ®å†™åˆ°å†…æ ¸çš„å†™ç¼“å†²åŒºï¼Œæœ€ç»ˆæœ‰å†…æ ¸ç¨‹åºå°†æ•°æ®å‘é€å‡ºå»ã€‚ äº‹ä»¶å›è°ƒï¼š å½“buffereventç»‘å®šçš„socketè¿æ¥ï¼Œæ–­å¼€æˆ–è€…å¼‚å¸¸çš„æ—¶å€™è§¦å‘äº‹ä»¶å›è°ƒã€‚ ä¸»è¦ä½¿ç”¨çš„å‡½æ•°å¦‚ä¸‹ï¼š 12345678struct bufferevent *bufferevent_socket_new(struct event_base *base,evutil_socket_t fd,int options);//å‡½æ•°è¯´æ˜ï¼šbufferevent_socket_newå¯¹å·²ç»å­˜åœ¨socketåˆ›å»ºbuffereventäº‹ä»¶ï¼Œå¯ç”¨äºåé¢è®²åˆ°çš„è¿æ¥ç›‘å¬å™¨çš„å›è°ƒå‡½æ•°ä¸­//å‚æ•°è¯´æ˜ï¼š// baseï¼šå¯¹åº”æ ¹èŠ‚ç‚¹// fdï¼šæ–‡ä»¶æè¿°ç¬¦// optionsï¼šbuffereventçš„é€‰é¡¹// BEV_OPT_CLOSE_ON_FREE --é‡Šæ”¾buffereventè‡ªåŠ¨å…³é—­åº•å±‚æ¥å£ï¼ˆå½“buffereventè¢«é‡Šæ”¾ä»¥åï¼Œæ–‡ä»¶æè¿°ç¬¦ä¹Ÿéšä¹‹è¢«close// BEV_OPT_THREADSAFE --ä½¿buffereventèƒ½å¤Ÿåœ¨å¤šçº¿ç¨‹ä¸‹æ˜¯å®‰å…¨çš„ 12345678int bufferevent_socket_connect(struct bufferevent *bev,struct sockaddr *serv,int socklen);//å‡½æ•°è¯´æ˜ï¼šè¯¥å‡½æ•°å°è£…äº†åº•å±‚çš„socketä¸connectæ¥å£ï¼Œé€šè¿‡è°ƒç”¨æ­¤å‡½æ•°ï¼Œå¯ä»¥å°†buffereventäº‹ä»¶ä¸é€šä¿¡çš„socketè¿›è¡Œç»‘å®š//å‚æ•°è¯´æ˜ï¼š// bev -- éœ€è¦æå‰åˆå§‹åŒ–çš„buffereventäº‹ä»¶// serv -- å¯¹ç«¯ï¼ˆä¸€èˆ¬æŒ‡æœåŠ¡ç«¯ï¼‰çš„ipåœ°å€ï¼Œç«¯å£ï¼Œåè®®çš„ç»“æ„æŒ‡é’ˆ// socklen -- æè¿°servçš„é•¿åº¦//è¯´æ˜ï¼šè°ƒç”¨æ­¤å‡½æ•°ä»¥åï¼Œé€šä¿¡çš„socketä¸buffereventç¼“å†²åŒºåšäº†ç»‘å®šï¼Œåé¢è°ƒç”¨äº†bufferevent_setcbå‡½æ•°ä»¥åï¼Œ//ä¼šå¯¹buffereventç¼“å†²åŒºçš„è¯»å†™æ“ä½œçš„äº‹ä»¶è®¾ç½®å›è°ƒå‡½æ•°ï¼Œå½“å¾€ç¼“å†²åŒºä¸­å†™æ•°æ®çš„æ—¶å€™ä¼šè§¦å‘å†™å›è°ƒå‡½æ•°ï¼Œå½“æ•°æ®ä»socketçš„å†…æ ¸ç¼“å†²åŒºè¯»åˆ°buffereventè¯»ç¼“å†²åŒºä¸­çš„æ—¶å€™ä¼šè§¦å‘è¯»å›è°ƒå‡½æ•° 12void bufferevent_free(struct bufferevent *bufev);//å‡½æ•°è¯´æ˜ ï¼šé‡Šæ”¾bufferevent 1234void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb,void *cbarg);//å‡½æ•°è¯´æ˜ï¼šbufferevent_setcbç”¨äºè®¾ç½®buffereventçš„å›è°ƒå‡½æ•°ï¼Œreadcb,writecb,eventcbåˆ†åˆ«å¯¹åº”äº†è¯»å›è°ƒï¼Œå†™å›è°ƒï¼Œäº‹ä»¶å›è°ƒï¼Œcbargä»£è¡¨å›è°ƒå‡½æ•°çš„å‚æ•°ã€‚ å›è°ƒå‡½æ•°å¦‚ä¸‹ï¼š 1typedef void (*bufferevent_data_cb)(struct bufferevent *bev ,void *ctx); 123456typedef void (*bufferevent_event_cb)(struct bufferevent *bev,short what,void *ctx);//Whatä»£è¡¨å¯¹åº”çš„äº‹ä»¶//BEV_EVENT_EOFé‡åˆ°æ–‡ä»¶ç»“æŸæç¤º//BEV_EVENT_ERRORå‘ç”Ÿé”™è¯¯//BEV_EVENT_TIMEOUTå‘ç”Ÿè¶…æ—¶//BEV_EVENT_CONNECTEDè¯·æ±‚çš„è¿‡ç¨‹ä¸­è¿æ¥å·²ç»å®Œæˆ 12int bufferevent_write(struct bufferevent *bufev,const void *data,size_t size);//bufferevent_writeæ˜¯å°†dataçš„æ•°æ®å†™åˆ°buffereventçš„å†™ç¼“å†²åŒº 12int bufferevnet_write_buffer(struct bufferevent *bufev,struct evbuffer *buf);//bufferevent_write_buffer æ˜¯å°†æ•°æ®å†™åˆ°ç¼“å†²åŒºå¦å¤–ä¸€ä¸ªå†™æ³•ï¼Œå®é™…ä¸Šbuffereventçš„å†…éƒ¨çš„ä¸¤ä¸ªç¼“å†²åŒºç»“æ„å°±æ˜¯struct evbuffer 12size_t bufferevent_read(struct bufferevent *bufev,void *data,size_t size);//bufferevent_readæ˜¯å°†buffereventçš„è¯»ç¼“å†²åŒºæ•°æ®è¯»åˆ°dataä¸­ï¼ŒåŒæ—¶å°†è¯»åˆ°çš„æ•°æ®ä»buffereventçš„è¯»ç¼“å†²æ¸…é™¤ã€‚ é“¾æ¥ç›‘å¬å™¨-evconnlisteneré“¾æ¥ç›‘å¬å™¨å°è£…äº†åº•å±‚çš„socketé€šä¿¡ç›¸å…³å‡½æ•°ï¼Œæ¯”å¦‚socketï¼Œbindï¼Œlistenï¼Œacceptè¿™å‡ ä¸ªå‡½æ•°ã€‚é“¾æ¥ç›‘å¬å™¨åˆ›å»ºåå®é™…ä¸Šç›¸å½“äºè°ƒç”¨äº†socketï¼Œbindï¼Œlistenï¼Œæ­¤æ—¶ç­‰å¾…æ–°çš„å®¢æˆ·ç«¯é“¾æ¥åˆ°æ¥ï¼Œå¦‚æœåˆæ–°çš„å®¢æˆ·ç«¯è¿æ¥ï¼Œé‚£ä¹ˆå†…éƒ¨å…ˆè¿›è¡Œè°ƒç”¨acceptå¤„ç†ï¼Œç„¶åè°ƒç”¨ç”¨æˆ·æŒ‡å®šçš„å›è°ƒå‡½æ•°ã€‚å¯ä»¥å…ˆçœ‹çœ‹å‡½æ•°åŸå‹ï¼Œäº†è§£ä¸€ä¸‹ä»–æ˜¯æ€ä¹ˆè¿ä½œçš„ï¼š å‡½æ•°å£°æ˜æ‰€åœ¨çš„å¤´æ–‡ä»¶ï¼ševent2&#x2F;listener.h 1234567891011121314struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb,void *ptr,unsigned flags,int backlog, const struct sockaddr *sa,int socklen);//å‡½æ•°è¯´æ˜ï¼š// æ˜¯åœ¨å½“å‰æ²¡æœ‰å¥—æ¥å­—çš„æƒ…å†µä¸‹å¯¹é“¾æ¥ç›‘å¬å™¨è¿›è¡Œåˆå§‹åŒ–ï¼Œçœ‹æœ€å2ä¸ªå‚æ•°å®é™…ä¸Š//å°±æ˜¯bindä½¿ç”¨çš„å…³é”®å‚æ•°ï¼Œbacklogæ˜¯listenå‡½æ•°çš„å…³é”®å‚æ•°ï¼ˆç•¥æœ‰ä¸åŒçš„æ˜¯ï¼Œå¦‚æœ//backlogæ˜¯-1ï¼Œé‚£ä¹ˆç›‘å¬å™¨ä¼šè‡ªåŠ¨é€‰æ‹©ä¸€ä¸ªåˆé€‚çš„å€¼ï¼Œå¦‚æœå¡«0ï¼Œé‚£ä¹ˆç›‘å¬å™¨ä¼šè®¤ä¸º//listenå‡½æ•°æ˜¯å·²ç»è¢«è°ƒç”¨è¿‡äº†ï¼‰ï¼Œptræ˜¯å›è°ƒå‡½æ•°çš„å‚æ•°ï¼Œcbæ˜¯æœ‰æ–°é“¾æ¥ä¹‹åçš„å›è°ƒ//å‡½æ•°ï¼Œä½†æ˜¯æ³¨æ„è¿™ä¸ªå›è°ƒå‡½æ•°è§¦å‘çš„æ—¶å€™ï¼Œé“¾æ¥å™¨å·²ç»å¤„ç†å¥½æ–°è¿æ¥äº†ï¼Œå¹¶å°†ä¸æ–°è¿æ¥//é€šä¿¡çš„æè¿°ç¬¦äº¤ç»™å›è°ƒå‡½æ•°ã€‚flagséœ€è¦å‚è€ƒå‡ ä¸ªå€¼ï¼š// LEV_OPT_LEAVE_SOCKETS_BLOCKING æ–‡ä»¶æè¿°ç¬¦ä¸ºé˜»å¡çš„// LEV_OPT_CLOSE_ON_FREE å…³é—­æ—¶è‡ªåŠ¨é‡Šæ”¾// LEV_OPT_REUSEABLE ç«¯å£å¤ç”¨// LEV_OPT_THREADSAFE åˆ†é…é”ï¼Œçº¿ç¨‹å®‰å…¨ 12345struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb,void *ptr,unsigned flags,int backlog, evutil_socket_t fd);//evconnlistener_newå‡½æ•°ä¸å‰ä¸€ä¸ªå‡½æ•°ä¸åŒçš„åœ°æ–¹åœ¨ä¸åä¸¤ä¸ªå‚æ•°ï¼Œä½¿ç”¨æœ¬å‡½æ•°æ—¶ï¼Œ//è®¤ä¸ºsocketå·²ç»åˆå§‹åŒ–å¥½ï¼Œå¹¶ä¸”bindå®Œæˆï¼Œç”šè‡³ä¹Ÿå¯ä»¥åšå®Œlistenï¼Œæ‰€ä»¥å¤§å¤šæ•°æ—¶å€™ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥ä½¿ç”¨ç¬¬ä¸€ä¸ªå‡½æ•° ä¸¤ä¸ªå‡½æ•°çš„å›è°ƒå‡½æ•°ï¼š 12typedef void (*evconnlistener_cb)(struct evconnlistener *evl,evutil_socket fd,struct sockaddr *cliaddr,int socklen,void *ptr);//å›è°ƒå‡½æ•°fdå‚æ•°æ˜¯ä¸å®¢æˆ·ç«¯é€šä¿¡çš„æè¿°ç¬¦ï¼Œå¹¶éæ˜¯ç­‰å¾…è¿æ¥çš„ç›‘å¬çš„é‚£ä¸ªæè¿°ç¬¦ï¼Œæ‰€ä»¥cliaddrå¯¹åº”çš„ä¹Ÿæ˜¯æ–°è¿æ¥çš„å¯¹ç«¯åœ°å€ä¿¡æ¯ï¼Œå·²ç»æ˜¯acceptå¤„ç†å¥½çš„ 12void evconnlistener_free(struct evconnlistener *lev);//å‡½æ•°è¯´æ˜ï¼šé‡Šæ”¾è¿æ¥ç›‘å¬ 12int evconnlistener_enable(struct evconnlistener *lev);//å‡½æ•°è¯´æ˜ï¼šä½¿é“¾æ¥ç›‘å¬å™¨ç”Ÿæ•ˆ 12int evconnlistener_disable(struct evconnlistener *lev);//å‡½æ•°è¯´æ˜ï¼šä½¿é“¾æ¥ç›‘å¬å™¨å¤±æ•ˆ å¦‚æœä¸Šè¿°å‡½æ•°éƒ½è¾ƒä¸ºäº†è§£äº†ï¼Œå¯ä»¥å°è¯•å»çœ‹æ‡‚hello-world.cçš„ä»£ç ï¼Œåœ¨å®‰è£…åŒ…sampleç›®å½•ä¸‹ï¼Œå…¶ä¸­æœ‰æ¶‰åŠåˆ°ä¿¡å·çš„å‡½æ•°ï¼Œçœ‹çœ‹è‡ªå·±èƒ½å¦æ‰¾åˆ°å‡½æ•°çš„åŸå‹åœ¨å“ªï¼Ÿå®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬ä¹‹å‰ä»‹ç»çš„event_newå‡½æ•°ï¼Œåªæ˜¯å¯¹åº”ä¸€ä¸ªä¿¡å·äº‹ä»¶è€Œå·²ï¼Œå¤„ç†æœºåˆ¶ç•¥æœ‰ä¸åŒã€‚ libeventä»£ç åˆ†æå’Œé˜…è¯»123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/* This example program provides a trivial server program that listens for TCP connections on port 9995. When they arrive, it writes a short message to each client connection, and closes each connection once it is flushed. Where possible, it exits cleanly in response to a SIGINT (ctrl-c).*/#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#ifndef _WIN32 //è¿™ä¸ªç¨‹åºä¹Ÿå¯ä»¥åœ¨win32è¿è¡Œ#include &lt;netinet/in.h&gt;# ifdef _XOPEN_SOURCE_EXTENDED# include &lt;arpa/inet.h&gt;# endif#include &lt;sys/socket.h&gt;#endif#include &lt;event2/bufferevent.h&gt;#include &lt;event2/buffer.h&gt;#include &lt;event2/listener.h&gt;#include &lt;event2/util.h&gt;#include &lt;event2/event.h&gt;static const char MESSAGE[] = &quot;Hello, World!\\n&quot;; //æ¶ˆæ¯static const int PORT = 9995;static void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);static void conn_writecb(struct bufferevent *, void *);static void conn_eventcb(struct bufferevent *, short, void *);static void signal_cb(evutil_socket_t, short, void *);intmain(int argc, char **argv)&#123; struct event_base *base; //åœ°åŸº struct evconnlistener *listener; //é“¾æ¥ç›‘å¬å™¨ struct event *signal_event; //ä¿¡å·äº‹ä»¶ struct sockaddr_in sin = &#123;0&#125;;#ifdef _WIN32 WSADATA wsa_data; WSAStartup(0x0201, &amp;wsa_data);#endif //åˆ›å»ºåœ°åŸº ç›¸å½“äºepollçš„æ ‘æ ¹(epoll_create) base = event_base_new(); if (!base) &#123; fprintf(stderr, &quot;Could not initialize libevent!\\n&quot;); return 1; &#125; sin.sin_family = AF_INET; sin.sin_port = htons(PORT); //åˆ›å»ºé“¾æ¥ç›‘å¬å™¨ socket-bind-listen-accept //listener_cb å›è°ƒå‡½æ•° //LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE è®¾ç½®ç«¯å£å¤ç”¨ï¼Œå½“é“¾æ¥ç›‘å¬å™¨é‡Šæ”¾çš„æ—¶å€™å…³é—­å¥—æ¥å­—(ç›‘å¬æ–‡ä»¶æè¿°ç¬¦) listener = evconnlistener_new_bind(base, listener_cb, (void*)base, LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); if (!listener) &#123; fprintf(stderr, &quot;Could not create a listener!\\n&quot;); return 1; &#125; //è®¾ç½®SIGINTä¿¡å·çš„äº‹ä»¶å›è°ƒ signal_event = evsignal_new(base, SIGINT, signal_cb, (void*)base); if (!signal_event || event_add(signal_event, NULL) &lt; 0) &#123; fprintf(stderr, &quot;Could not create/add a signal event!\\n&quot;); return 1; &#125; //è¿›å…¥ç­‰å¾…äº‹ä»¶å¾ªç¯ ç›¸å½“äºwhile(1) event_base_dispatch(base); //é‡Šæ”¾èµ„æº evconnlistener_free(listener); event_free(signal_event); event_base_free(base); printf(&quot;done\\n&quot;); return 0;&#125;//listener:é“¾æ¥ç›‘å¬å™¨//fd:é€šä¿¡æ–‡ä»¶æè¿°ç¬¦//saå’Œsocklen:å®¢æˆ·ç«¯IPåœ°å€ä¿¡æ¯//user_data:å‚æ•°static voidlistener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data)&#123; struct event_base *base = user_data; struct bufferevent *bev; //åˆ›å»ºbuffereventç¼“å†²åŒº //BEV_OPT_CLOSE_ON_FREE:buffereventé‡Šæ”¾çš„æ—¶å€™è‡ªåŠ¨å…³é—­é€šä¿¡æè¿°ç¬¦ bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; fprintf(stderr, &quot;Error constructing bufferevent!&quot;); event_base_loopbreak(base);//é€€å‡ºå¾ªç¯ï¼Œç¨‹åºç»“æŸ return; &#125; //è®¾ç½®å›è°ƒå‡½æ•°:è¯»å›è°ƒï¼Œå†™å›è°ƒï¼Œäº‹ä»¶å›è°ƒ bufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL); //ä½¿buffereventè®¾ç½®ç”Ÿæ•ˆ bufferevent_enable(bev, EV_WRITE); //ä½¿buffereventè®¾ç½®å¤±æ•ˆ bufferevent_disable(bev, EV_READ); bufferevent_write(bev, MESSAGE, strlen(MESSAGE));&#125;static voidconn_writecb(struct bufferevent *bev, void *user_data)&#123; struct evbuffer *output = bufferevent_get_output(bev); if (evbuffer_get_length(output) == 0) &#123; printf(&quot;flushed answer\\n&quot;); bufferevent_free(bev); &#125;&#125;static voidconn_eventcb(struct bufferevent *bev, short events, void *user_data)&#123; if (events &amp; BEV_EVENT_EOF) &#123; printf(&quot;Connection closed.\\n&quot;); &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; printf(&quot;Got an error on the connection: %s\\n&quot;, strerror(errno));/*XXX win32*/ &#125; /* None of the other events can happen here, since we haven&#x27;t enabled * timeouts */ bufferevent_free(bev);&#125;static voidsignal_cb(evutil_socket_t sig, short events, void *user_data)&#123; struct event_base *base = user_data; struct timeval delay = &#123; 2, 0 &#125;; printf(&quot;Caught an interrupt signal; exiting cleanly in two seconds.\\n&quot;); event_base_loopexit(base, &amp;delay);&#125; buffereventå’Œé“¾æ¥ç›‘å¬å™¨ä»£ç æµç¨‹å›¾","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"ç½‘ç»œç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/ç½‘ç»œç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++å­¦ä¹  å¼‚å¸¸","slug":"C++-å­¦ä¹ -å¼‚å¸¸","date":"2023-07-01T01:44:22.000Z","updated":"2023-07-03T03:28:46.636Z","comments":true,"path":"2023/07/01/C++-å­¦ä¹ -å¼‚å¸¸/","link":"","permalink":"http://example.com/2023/07/01/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%82%E5%B8%B8/","excerpt":"å¼‚å¸¸çš„åŸºæœ¬æ¦‚å¿µæä¾›å¼‚å¸¸çš„åŸºæœ¬ç›®çš„å°±æ˜¯ä¸ºäº†å¤„ç†ä¸Šé¢çš„é—®é¢˜ã€‚åŸºæœ¬æ€æƒ³æ˜¯ï¼šè®©ä¸€ä¸ªå‡½æ•°åœ¨å‘ç°äº†è‡ªå·±æ— æ³•å¤„ç†çš„é”™è¯¯æ—¶æŠ›å‡ºï¼ˆthrowï¼‰ä¸€ä¸ªå¼‚å¸¸ï¼Œç„¶åå®ƒçš„ï¼ˆç›´æ¥æˆ–è€…é—´æ¥ï¼‰è°ƒç”¨è€…èƒ½å¤Ÿå¤„ç†è¿™ä¸ªé—®é¢˜ã€‚å°†é—®é¢˜æ£€æµ‹å’Œé—®é¢˜å¤„ç†ç›¸åˆ†ç¦»ã€‚ ä¸€ç§æ€æƒ³ï¼šåœ¨æ‰€æœ‰æ”¯æŒå¼‚å¸¸å¤„ç†çš„ç¼–ç¨‹è¯­è¨€ä¸­ï¼ˆä¾‹å¦‚java)ï¼Œè¦è®¤è¯†åˆ°çš„ä¸€ä¸ªæ€æƒ³ï¼šåœ¨å¼‚å¸¸å¤„ç†è¿‡ç¨‹ä¸­ï¼Œç”±é—®é¢˜æ£€æµ‹ä»£ç å¯ä»¥æŠ›å‡ºä¸€ä¸ªå¯¹è±¡ç»™é—®é¢˜å¤„ç†ä»£ç ï¼Œé€šè¿‡è¿™ä¸ªå¯¹è±¡çš„ç±»å‹å’Œå†…å®¹ï¼Œå®é™…ä¸Šå®Œæˆäº†ä¸¤ä¸ªéƒ¨åˆ†çš„é€šä¿¡ï¼Œé€šä¿¡çš„å†…å®¹æ˜¯ï¼šå‡ºç°äº†ä¸Šé¢é”™è¯¯ã€‚å½“ç„¶ï¼Œå„ç§è¯­è¨€å¯¹å¼‚å¸¸çš„å…·ä½“å®ç°æœ‰ç€æˆ–å¤šæˆ–å°‘çš„åŒºåˆ«ï¼Œä½†æ˜¯è¿™ä¸ªé€šä¿¡çš„æ€æƒ³æ˜¯ä¸å˜çš„ã€‚","text":"å¼‚å¸¸çš„åŸºæœ¬æ¦‚å¿µæä¾›å¼‚å¸¸çš„åŸºæœ¬ç›®çš„å°±æ˜¯ä¸ºäº†å¤„ç†ä¸Šé¢çš„é—®é¢˜ã€‚åŸºæœ¬æ€æƒ³æ˜¯ï¼šè®©ä¸€ä¸ªå‡½æ•°åœ¨å‘ç°äº†è‡ªå·±æ— æ³•å¤„ç†çš„é”™è¯¯æ—¶æŠ›å‡ºï¼ˆthrowï¼‰ä¸€ä¸ªå¼‚å¸¸ï¼Œç„¶åå®ƒçš„ï¼ˆç›´æ¥æˆ–è€…é—´æ¥ï¼‰è°ƒç”¨è€…èƒ½å¤Ÿå¤„ç†è¿™ä¸ªé—®é¢˜ã€‚å°†é—®é¢˜æ£€æµ‹å’Œé—®é¢˜å¤„ç†ç›¸åˆ†ç¦»ã€‚ ä¸€ç§æ€æƒ³ï¼šåœ¨æ‰€æœ‰æ”¯æŒå¼‚å¸¸å¤„ç†çš„ç¼–ç¨‹è¯­è¨€ä¸­ï¼ˆä¾‹å¦‚java)ï¼Œè¦è®¤è¯†åˆ°çš„ä¸€ä¸ªæ€æƒ³ï¼šåœ¨å¼‚å¸¸å¤„ç†è¿‡ç¨‹ä¸­ï¼Œç”±é—®é¢˜æ£€æµ‹ä»£ç å¯ä»¥æŠ›å‡ºä¸€ä¸ªå¯¹è±¡ç»™é—®é¢˜å¤„ç†ä»£ç ï¼Œé€šè¿‡è¿™ä¸ªå¯¹è±¡çš„ç±»å‹å’Œå†…å®¹ï¼Œå®é™…ä¸Šå®Œæˆäº†ä¸¤ä¸ªéƒ¨åˆ†çš„é€šä¿¡ï¼Œé€šä¿¡çš„å†…å®¹æ˜¯ï¼šå‡ºç°äº†ä¸Šé¢é”™è¯¯ã€‚å½“ç„¶ï¼Œå„ç§è¯­è¨€å¯¹å¼‚å¸¸çš„å…·ä½“å®ç°æœ‰ç€æˆ–å¤šæˆ–å°‘çš„åŒºåˆ«ï¼Œä½†æ˜¯è¿™ä¸ªé€šä¿¡çš„æ€æƒ³æ˜¯ä¸å˜çš„ã€‚ ä¸€å¥è¯ï¼šå¼‚å¸¸å¤„ç†å°±æ˜¯å¤„ç†ç¨‹åºä¸­çš„é”™è¯¯ã€‚æ‰€è°“é”™è¯¯æ˜¯æŒ‡åœ¨ç¨‹åºè¿è¡Œçš„è¿‡ç¨‹ä¸­å‘ç”Ÿçš„ä¸€äº›å¼‚å¸¸äº‹ä»¶ï¼ˆå¦‚ï¼šé™¤0æº¢å‡ºï¼Œæ•°ç»„ä¸‹æ ‡è¶Šç•Œï¼Œæ‰€è¦è¯»å–çš„æ–‡ä»¶ä¸å­˜åœ¨ï¼Œç©ºæŒ‡é’ˆï¼Œå†…å­˜ä¸è¶³ç­‰ç­‰ï¼‰ã€‚ æˆ‘ä»¬ä»¥å‰ç¼–å†™çš„ç¨‹åºæ˜¯å¦‚ä½•å¤„ç†å¼‚å¸¸ï¼Ÿ åœ¨Cè¯­è¨€çš„ä¸–ç•Œä¸­ï¼Œå¯¹é”™è¯¯çš„å¤„ç†æ€»æ˜¯å›´ç»•ç€ä¸¤ç§æ–¹æ³•ï¼šä¸€æ˜¯ä½¿ç”¨æ•´å‹çš„è¿”å›å€¼æ ‡è¯†é”™è¯¯ï¼›äºŒæ˜¯ä½¿ç”¨emoå®ï¼ˆå¯ä»¥ç®€å•çš„ç†è§£ä¸ºä¸€ä¸ªå…¨å±€æ•´å‹å˜é‡ï¼‰å»è®°å½•é”™è¯¯ã€‚å½“ç„¶C++ä»ç„¶æ˜¯å¯ä»¥ç”¨ä¸¤ç§æ–¹æ³•çš„ã€‚è¿™ä¸¤ç§æ–¹æ³•æœ€å¤§çš„ç¼ºé™·å°±æ˜¯ä¼šå‡ºç°ä¸ä¸€è‡´çš„é—®é¢˜ã€‚ä¾‹å¦‚æœ‰äº›å‡½æ•°è¿”å›1è¡¨ç¤ºæˆåŠŸï¼Œè¿”å›0è¡¨ç¤ºå‡ºé”™ï¼›è€Œæœ‰äº›å‡½æ•°è¿”å›0è¡¨ç¤ºæˆåŠŸï¼Œè¿”å›é0è¡¨ç¤ºå‡ºé”™ã€‚ è¿˜æœ‰ä¸€ä¸ªç¼ºç‚¹å°±æ˜¯å‡½æ•°çš„è¿”å›å€¼åªæœ‰ä¸€ä¸ªï¼Œä½ é€šè¿‡å‡½æ•°çš„è¿”å›å€¼è¡¨ç¤ºé”™è¯¯ä»£ç ï¼Œé‚£ä¹ˆå‡½æ•°å°±ä¸èƒ½è¿”å›å…¶ä»–çš„å€¼ã€‚å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥é€šè¿‡æŒ‡é’ˆæˆ–è€…C++çš„å¼•ç”¨æ¥è¿”å›å¦å¤–çš„å€¼ï¼Œä½†æ˜¯è¿™æ ·å¯èƒ½ä¼šä»¤ä½ çš„ç¨‹åºç•¥å¾®æ™¦æ¶©éš¾æ‡‚ã€‚ C++å¼‚å¸¸æœºåˆ¶ç›¸æ¯”Cè¯­è¨€å¼‚å¸¸å¤„ç†çš„ä¼˜åŠ¿ï¼Ÿ å‡½æ•°çš„è¿”å›å€¼å¯ä»¥å¿½ç•¥ï¼Œä½†å¼‚å¸¸ä¸å¯å¿½ç•¥ã€‚å¦‚æœç¨‹åºå‡ºç°å¼‚å¸¸ï¼Œä½†æ˜¯æ²¡æœ‰è¢«æ•è·ï¼Œç¨‹åºå°±ä¼šç»ˆæ­¢ï¼Œè¿™å¤šå°‘ä¼šä¿ƒä½¿ç¨‹åºå‘˜å¼€å‘å‡ºæ¥çš„ç¨‹åºæ›´å¥å£®ä¸€ç‚¹ã€‚è€Œå¦‚æœä½¿ç”¨Cè¯­è¨€çš„errorå®æˆ–è€…å‡½æ•°è¿”å›å€¼ï¼Œè°ƒç”¨è€…éƒ½æœ‰å¯èƒ½å¿˜è®°æ£€æŸ¥ï¼Œä»è€Œæ²¡æœ‰å¯¹é”™è¯¯è¿›è¡Œå¤„ç†ï¼Œç»“æœé€ æˆç¨‹åºè«åå…¶å¦™çš„ç»ˆæ­¢æˆ–è€…å‡ºç°é”™è¯¯çš„ç»“æœã€‚ æ•´å‹è¿”å›å€¼æ²¡æœ‰ä»»ä½•å¯“æ„ä¿¡æ¯ã€‚è€Œå¼‚å¸¸ç¼ºåŒ…å«è¯­ä¹‰ä¿¡æ¯ï¼Œæœ‰æ—¶ä½ ä»ç±»åå°±èƒ½å¤Ÿä½“ç°å‡ºæ¥ã€‚ æ•´å‹è¿”å›å€¼ç¼ºä¹ç›¸å…³çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå¼‚å¸¸ä½œä¸ºä¸€ä¸ªç±»ï¼Œå¯ä»¥æ‹¥æœ‰è‡ªå·±çš„æˆå‘˜ï¼Œè¿™äº›æˆå‘˜å°±å¯ä»¥ä¼ é€’è¶³å¤Ÿçš„ä¿¡æ¯ã€‚ å¼‚å¸¸å¤„ç†å¯ä»¥åœ¨è°ƒç”¨è·³çº§ã€‚è¿™æ˜¯ä¸€ä¸ªä»£ç ç¼–å†™æ—¶çš„é—®é¢˜ï¼šå‡è®¾åœ¨æœ‰å¤šä¸ªå‡½æ•°çš„è°ƒç”¨æ ˆä¸­å‡ºç°äº†æŸä¸ªé”™è¯¯ï¼Œä½¿ç”¨æ•´å‹è¿”å›ç è¦æ±‚ä½ åœ¨æ¯ä¸€çº§å‡½æ•°ä¸­éƒ½è¦è¿›è¡Œå¤„ç†ã€‚è€Œä½¿ç”¨å¼‚å¸¸å¤„ç†çš„æ ˆå±•å¼€æœºåˆ¶ï¼Œåªéœ€è¦åœ¨ä¸€å¤„è¿›è¡Œå¤„ç†å°±å¯ä»¥äº†ï¼Œä¸éœ€è¦æ¯çº§å‡½æ•°éƒ½å¤„ç†ã€‚ C++çš„å¼‚å¸¸å¿…é¡»è¦æœ‰å‡½æ•°è¿›è¡Œå¤„ç†ï¼Œå¦‚æœæ²¡æœ‰ä»»ä½•å¤„ç†ï¼Œç¨‹åºä¼šä¸­æ–­ã€‚ 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int myDivision(int a,int b)&#123; if (b == 0) &#123; return -1; &#125; return a / b;&#125;void test01() &#123; int a = 10; int b = 0; //a=10,b=-1æ—¶ï¼Œè¿”å›ä¹Ÿä¸º-1ï¼Œä¹Ÿä¼šè¿›è¡Œå¼‚å¸¸å¤„ç† //Cè¯­è¨€å¤„ç†å¼‚å¸¸æœ‰ç¼ºé™·ï¼Œè¿”å›å€¼ä¸ç»Ÿä¸€ï¼Œæ— æ³•åŒºåˆ†æ—¶ç»“æœè¿˜æ˜¯å¼‚å¸¸ int ret = myDivision(a, b); if (ret == -1) &#123; cout &lt;&lt; &quot;å¼‚å¸¸&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;class MyException&#123;public: void printError() &#123; cout &lt;&lt; &quot;æˆ‘è‡ªå·±çš„å¼‚å¸¸&quot; &lt;&lt; endl; &#125;&#125;;int myDivision(int a,int b)&#123; if (b == 0) &#123; //throw &#x27;a&#x27;;//è¿”å›intç±»å‹çš„å¼‚å¸¸ throw MyException();//æŠ›å‡ºMyExceptionçš„åŒ¿åå¯¹è±¡ &#125; return a / b;&#125;void test01() &#123; int a = 10; int b = 0; try &#123; myDivision(a, b); &#125; catch (int) &#123; cout &lt;&lt; &quot;intç±»å‹å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125; catch (char) &#123; //æ•è·åˆ°äº†å¼‚å¸¸ï¼Œä½†æ˜¯ä¸æƒ³å¤„ç†ï¼Œç»§ç»­å‘ä¸ŠæŠ›å‡ºè¿™ä¸ªå¼‚å¸¸ //å¼‚å¸¸å¿…é¡»æœ‰å‡½æ•°è¿›è¡Œå¤„ç†ï¼Œå¦‚æœæ²¡æœ‰ä»»ä½•å¤„ç†ï¼Œç¨‹åºè‡ªåŠ¨è°ƒç”¨terminateå‡½æ•°ï¼Œè®©ç¨‹åºä¸­æ–­ throw; cout &lt;&lt; &quot;charç±»å‹å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125; catch (double) &#123; cout &lt;&lt; &quot;doubleç±»å‹å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125; catch (MyException e) &#123; e.printError(); &#125; catch (...) &#123; cout &lt;&lt; &quot;å…¶ä»–ç±»å‹å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; try &#123; test01(); &#125; catch (double) &#123; cout &lt;&lt; &quot;mainå‡½æ•°ä¸­doubleç±»å‹å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125; catch (char) &#123; cout &lt;&lt; &quot;mainå‡½æ•°ä¸­charç±»å‹å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125; catch (...) &#123; cout &lt;&lt; &quot;mainå‡½æ•°ä¸­å…¶ä»–ç±»å‹å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125;&#125; è¿è¡Œç»“æœä¸ºï¼š æˆ‘è‡ªå·±çš„å¼‚å¸¸ æ€»ç»“ è‹¥æœ‰å¼‚å¸¸åˆ™é€šè¿‡throwæ“ä½œåˆ›å»ºä¸€ä¸ªå¼‚å¸¸å¯¹è±¡å¹¶æŠ›å‡ºã€‚ å°†å¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„ç¨‹åºæ”¾åˆ°tryå—ä¹‹ä¸­ã€‚ å¦‚æœåœ¨tryæ®µæ‰§è¡ŒæœŸé—´æ²¡æœ‰å¼•èµ·å¼‚å¸¸ï¼Œé‚£ä¹ˆè·Ÿåœ¨tryåé¢çš„catchå­—å¥å°±ä¸ä¼šæ‰§è¡Œã€‚ catchå­å¥ä¼šæ ¹æ®å‡ºç°çš„å…ˆåé¡ºåºè¢«æ£€æŸ¥ï¼ŒåŒ¹é…çš„catchè¯­å¥æ•è·å¹¶å¤„ç†å¼‚å¸¸ï¼ˆæˆ–ç»§ç»­æŠ›å‡ºå¼‚å¸¸ï¼‰ã€‚ å¦‚æœåŒ¹é…çš„å¤„ç†æ¥æ‰¾åˆ°ï¼Œåˆ™è¿è¡Œå‡½æ•°terminateå°†è‡ªåŠ¨è¢«è°ƒç”¨ï¼Œå…¶ç¼ºçœåŠŸèƒ½è°ƒç”¨abortç»ˆæ­¢ç¨‹åºã€‚ å¤„ç†ä¸äº†çš„å¼‚å¸¸ï¼Œå¯ä»¥åœ¨catchçš„æœ€åä¸€ä¸ªåˆ†æ”¯ï¼Œä½¿ç”¨throwï¼Œå‘ä¸ŠæŠ›ã€‚ C++å¼‚å¸¸å¤„ç†ä½¿å¾—å¼‚å¸¸çš„å¼•å‘å’Œå¼‚å¸¸çš„å¤„ç†ä¸å¿…åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼Œè¿™æ ·åº•å±‚çš„å‡½æ•°å¯ä»¥ç€é‡è§£å†³é—®é¢˜ï¼Œè€Œä¸å¿…è¿‡å¤šçš„è€ƒè™‘å¼‚å¸¸çš„å¤„ç†ï¼Œä¸Šå±‚è°ƒç”¨è€…å¯ä»¥åœ¨é€‚å½“çš„ä½ç½®è®¾è®¡å¯¹ä¸åŒç±»å‹å¼‚å¸¸çš„å¤„ç†ã€‚ å¼‚å¸¸çš„åŸºæœ¬è¯­æ³• C++å¼‚å¸¸çš„å¤„ç†å…³é”®å­— try throw catch å¯ä»¥å‡ºç°å¼‚å¸¸çš„ä»£ç ï¼Œæ”¾åˆ°tryå— åˆ©ç”¨throwæŠ›å‡ºå¼‚å¸¸ åˆ©ç”¨catchæ•è·å¼‚å¸¸ catchï¼ˆç±»å‹ï¼‰ï¼Œå¦‚æœæƒ³æ•è·å…¶ä»–ç±»å‹ catchï¼ˆâ€¦) å¦‚æœæ•è·åˆ°çš„å¼‚å¸¸ä¸æƒ³å¤„ç†ï¼Œè€Œç»§ç»­å‘ä¸ŠæŠ›å‡ºï¼Œåˆ©ç”¨throw å¼‚å¸¸å¿…é¡»æœ‰å‡½æ•°è¿›è¡Œå¤„ç†ï¼Œå¦‚æœéƒ½ä¸å»å¤„ç†ï¼Œç¨‹åºè‡ªåŠ¨è°ƒç”¨terminateå‡½æ•°ï¼Œä¸­æ–­æ‰ å¼‚å¸¸å¯ä»¥æ˜¯è‡ªå®šä¹‰æ•°æ®ç±»å‹ å¼‚å¸¸æ˜¯ä¸¥æ ¼ç±»å‹åŒ¹é… æ ˆè§£æ—‹ ä»tryä»£ç å—å¼€å§‹ï¼Œåˆ°throwæŠ›å‡ºå¼‚å¸¸ä¹‹å‰ï¼Œæ‰€æœ‰æ ˆä¸Šçš„æ•°æ®éƒ½ä¼šè¢«é‡Šæ”¾æ‰ é‡Šæ”¾çš„é¡ºåºå’Œåˆ›å»ºçš„é¡ºåºç›¸åï¼Œè¿™ä¸ªè¿‡ç¨‹æˆ‘ä»¬ç§°ä¸ºæ ˆè§£æ—‹ å¼‚å¸¸æ¥å£å£°æ˜ ä¸ºäº†åŠ å¼ºç¨‹åºçš„å¯è¯»æ€§ï¼Œå¯ä»¥åœ¨å‡½æ•°å£°æ˜ä¸­åˆ—å‡ºå¯èƒ½æŠ›å‡ºå¼‚å¸¸çš„æ‰€æœ‰ç±»å‹ï¼Œä¾‹å¦‚ï¼švoid func() throw(A,B,C)ï¼›è¿™ä¸ªå‡½æ•°funcèƒ½å¤Ÿä¸”åªèƒ½å¤ŸæŠ›å‡ºç±»å‹Aï¼ŒBï¼ŒCåŠå…¶å­ç±»å‹çš„å¼‚å¸¸ å¦‚æœåœ¨å‡½æ•°å£°æ˜ä¸­æ²¡æœ‰åŒ…å«å¼‚å¸¸çš„æ¥å£å£°æ˜ï¼Œåˆ™æ­¤å‡½æ•°å¯ä»¥æŠ›ä»»ä½•ç±»å‹çš„å¼‚å¸¸ï¼Œä¾‹å¦‚ï¼švoid func() ä¸€ä¸ªä¸æŠ›ä»»ä½•å¼‚å¸¸çš„å‡½æ•°å¯å£°æ˜ä¸ºï¼švoid func throw() å¦‚æœä¸€ä¸ªå‡½æ•°æŠ›å‡ºäº†å®ƒçš„å¼‚å¸¸æ¥å£å£°æ˜æ‰€ä¸å…è®¸æŠ›å‡ºçš„å¼‚å¸¸ï¼Œunexceptedå‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œè¯¥å‡½æ•°é»˜è®¤è¡Œä¸ºè°ƒç”¨terminate å‡½æ•°ä¸­æ–­ç¨‹åº 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//å¯ä»¥æŠ›å‡ºæ‰€æœ‰ç±»å‹å¼‚å¸¸void TestFunction01()&#123; throw 10;&#125;//åªèƒ½æŠ›int char char*ç±»å‹å¼‚å¸¸void TestFunction02() throw(int, char, char)&#123; string exception = &quot;error!&quot;; throw exception;&#125;//ä¸èƒ½æŠ›å‡ºä»»ä½•ç±»å‹å¼‚å¸¸void TestFunction03()throw()&#123; throw 10;&#125;int main()&#123; try &#123; TestFunction01(); TestFunction02(); TestFunction03(); &#125; catch (...) &#123; cout &lt;&lt; &quot;æ•è·å¼‚å¸¸ï¼&quot; &lt;&lt; endl; &#125;&#125; å¼‚å¸¸å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class MyException&#123;public: MyException() &#123; cout &lt;&lt; &quot;MyExceptioné»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; MyException(const MyException &amp;e) &#123; cout &lt;&lt; &quot;MyExceptionæ‹·è´æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~MyException() &#123; cout &lt;&lt; &quot;MyExceptionææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125;&#125;;void doWork()&#123; throw MyException();&#125;void test01()&#123; try &#123; doWork(); &#125; //æŠ›å‡ºçš„æ˜¯throw MyException;catch(MyException e)è°ƒç”¨æ‹·è´æ„é€ å‡½æ•° æ•ˆç‡ä½ //æŠ›å‡ºçš„æ˜¯throw MyException();catch(MyException &amp;e)åªè°ƒç”¨é»˜è®¤æ„é€ å‡½æ•° æ•ˆç‡é«˜ //æŠ›å‡ºçš„æ˜¯throw &amp;MyException();catch(MyException *e)å¯¹è±¡ä¼šæå‰é‡Šæ”¾æ‰ï¼Œä¸èƒ½åœ¨éæ³•æ“ä½œ //æŠ›å‡ºçš„æ˜¯new MyException();catch(MyException *e)åªè°ƒç”¨é»˜è®¤æ„é€ å‡½æ•° è‡ªå·±è¦ç®¡ç†é‡Šæ”¾ catch (MyException &amp;e) &#123; cout &lt;&lt; &quot;è‡ªå®šä¹‰å¼‚å¸¸æ•è·&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; å¼‚å¸¸çš„å¤šæ€ä½¿ç”¨ æä¾›åŸºç±»å¼‚å¸¸ç±» class BaseException çº¯è™šå‡½æ•° virtual void printError() &#x3D; 0 å­ç±»ç©ºæŒ‡é’ˆå¼‚å¸¸å’Œè¶Šç•Œå¼‚å¸¸ç»§æ‰¿BaseException é‡å†™virtual void printError() æµ‹è¯•ï¼Œåˆ©ç”¨çˆ¶ç±»çš„å¼•ç”¨æŒ‡å‘å­ç±»å¯¹è±¡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;//å¼‚å¸¸çš„åŸºç±»class BaseException&#123;public: virtual void printError() = 0;&#125;;//ç©ºæŒ‡é’ˆå¼‚å¸¸class NULLPointerException:public BaseException&#123;public: virtual void printError() &#123; cout &lt;&lt; &quot;ç©ºæŒ‡é’ˆå¼‚å¸¸&quot; &lt;&lt; endl; &#125;&#125;;//è¶Šç•Œå¼‚å¸¸class OutofRangeException :public BaseException&#123;public: virtual void printError() &#123; cout &lt;&lt; &quot;è¶Šç•Œå¼‚å¸¸&quot; &lt;&lt; endl; &#125;&#125;;void doWork()&#123; //throw OutofRangeException(); throw NULLPointerException();&#125;void test01()&#123; try &#123; doWork(); &#125; catch (BaseException&amp; e) &#123; e.printError(); &#125;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š ç©ºæŒ‡é’ˆå¼‚å¸¸ C++æ ‡å‡†å¼‚å¸¸åº“æ ‡å‡†åº“ä»‹ç»æ ‡å‡†åº“ä¹Ÿæä¾›äº†å¾ˆå¤šçš„å¼‚å¸¸ç±»ï¼Œå®ƒä»¬æ˜¯é€šè¿‡ç±»ç»§æ‰¿ç»„ç»‡èµ·æ¥çš„ï¼Œå¼‚å¸¸ç±»ç»§æ‰¿å±‚çº§ç»“æ„å›¾å¦‚ä¸‹ï¼š æ¯ä¸ªç±»æ‰€åœ¨çš„å¤´æ–‡ä»¶åœ¨å›¾ä¸‹æ–¹æ ‡è¯†å‡ºæ¥ã€‚ æ ‡å‡†å¼‚å¸¸ç±»çš„æˆå‘˜ï¼š åœ¨ä¸Šè¿°ç»§æ‰¿ä½“ç³»ä¸­ï¼Œæ¯ä¸ªç±»éƒ½æœ‰æä¾›äº†æ„é€ å‡½æ•°ã€å¤åˆ¶æ„é€ å‡½æ•°å’Œå¤åˆ¶æ“ä½œç¬¦é‡è½½ã€‚ logic_errorç±»åŠå…¶å­ç±»ã€runtime_errorç±»ï¼ŒåŠå…¶å­ç±»ï¼Œå®ƒä»¬çš„æ„é€ å‡½æ•°æ—¶æ¥å—ä¸€ä¸ªstringç±»å‹çš„å½¢å¼å‚æ•°ï¼Œç”¨äºå¼‚å¸¸ä¿¡æ¯çš„æè¿°ã€‚ æ‰€æœ‰çš„å¼‚å¸¸ç±»éƒ½æœ‰ä¸€ä¸ªwhat()æ–¹æ³•ï¼Œè¿”å›const char*ç±»å‹ï¼ˆCé£æ ¼å­—ç¬¦ä¸²ï¼‰çš„å€¼ï¼Œæè¿°å¼‚å¸¸ä¿¡æ¯ã€‚ æ ‡å‡†å¼‚å¸¸ç±»çš„å…·ä½“æè¿°ï¼š å¼‚å¸¸åç§° æè¿° exception æ‰€æœ‰æ ‡å‡†å¼‚å¸¸ç±»çš„çˆ¶ç±» bad_alloc å½“operator new and operator new[]ï¼Œè¯·æ±‚åˆ†é…å†…å­˜å¤±è´¥æ—¶ bad_exception è¿™æ˜¯ä¸ªç‰¹æ®Šçš„å¼‚å¸¸ï¼Œå¦‚æœå‡½æ•°çš„å¼‚å¸¸æŠ›å‡ºåˆ—è¡¨é‡Œå£°æ˜äº†bad_exceptionå¼‚å¸¸ï¼Œå½“å‡½æ•°å†…éƒ¨æŠ›å‡ºäº†å¼‚å¸¸æŠ›å‡ºåˆ—è¡¨ä¸­æ²¡æœ‰çš„å¼‚å¸¸ï¼Œè¿™æ˜¯è°ƒç”¨çš„Unexceptedå‡½æ•°ä¸­è‹¥æŠ›å‡ºå¼‚å¸¸ï¼Œä¸è®ºä»€ä¹ˆç±»å‹ï¼Œéƒ½ä¼šè¢«æ›¿æ¢ä¸ºbad_exceptionç±»å‹ bad_typeid ä½¿ç”¨typeidæ“ä½œç¬¦ï¼Œæ“ä½œä¸€ä¸ªNULLæŒ‡é’ˆï¼Œè€Œè¯¥æŒ‡é’ˆæ˜¯å¸¦æœ‰è™šå‡½æ•°çš„ç±»ï¼Œè¿™æ—¶æŠ›å‡ºbad_typeidå¼‚å¸¸ bad_cast ä½¿ç”¨dynamic_castè½¬æ¢å¼•ç”¨å¤±è´¥çš„æ—¶å€™ ios_base::failure ioæ“ä½œè¿‡ç¨‹å‡ºç°é”™è¯¯ logic_error é€»è¾‘é”™è¯¯ï¼Œå¯ä»¥åœ¨è¿è¡Œå‰æ£€æµ‹çš„é”™è¯¯ runtime_error è¿è¡Œæ—¶é”™è¯¯ï¼Œä»…åœ¨è¿è¡Œæ—¶æ‰å¯ä»¥æ£€æµ‹çš„é”™è¯¯ logic_errorçš„å­ç±»ï¼š å¼‚å¸¸åç§° æè¿° length_error è¯•å›¾ç”Ÿæˆä¸€ä¸ªè¶…å‡ºè¯¥ç±»å‹æœ€å¤§é•¿åº¦çš„å¯¹è±¡æ—¶ï¼Œä¾‹å¦‚vectorçš„resizeæ“ä½œ domain_error å‚æ•°çš„å€¼åŸŸé”™è¯¯ï¼Œä¸»è¦ç”¨åœ¨æ•°å­¦å‡½æ•°ä¸­ã€‚ä¾‹å¦‚ä½¿ç”¨ä¸€ä¸ªè´Ÿå€¼è°ƒç”¨åªèƒ½æ“ä½œéè´Ÿæ•°çš„å‡½æ•° out_of_range è¶…å‡ºæœ‰æ•ˆèŒƒå›´ invalid_argument å‚æ•°ä¸åˆé€‚ã€‚åœ¨æ ‡å‡†åº“ä¸­ï¼Œå½“åˆ©ç”¨stringå¯¹è±¡æ„é€ bitsetæ—¶ï¼Œè€Œstringä¸­çš„å­—ç¬¦ä¸æ˜¯0æˆ–1çš„æ—¶å€™ï¼ŒæŠ›å‡ºè¯¥å¼‚å¸¸ runtime_errorçš„å­ç±»ï¼š å¼‚å¸¸åç§° æè¿° range_error è®¡ç®—ç»“æœè¶…è¿‡äº†æœ‰æ„ä¹‰çš„å€¼åŸŸèŒƒå›´ overflow_error ç®—æœ¯è®¡ç®—ä¸Šæº¢ underflow_error ç®—æœ¯è®¡ç®—ä¸‹æº¢ invalid_argument å‚æ•°ä¸åˆé€‚ã€‚åœ¨æ ‡å‡†åº“ä¸­ï¼Œå½“åˆ©ç”¨stringå¯¹è±¡æ„é€ bitsetï¼Œè€Œstringä¸­çš„å­—ç¬¦ä¸æ˜¯0æˆ–1çš„æ—¶å€™ï¼ŒæŠ›å‡ºè¯¥å¼‚å¸¸ 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;class Person&#123;public: Person(int age) &#123; if (age &lt; 0 || age&gt;150) &#123; throw out_of_range(&quot;å¹´é¾„å¿…é¡»åœ¨0-150ä¹‹é—´&quot;); &#125; this-&gt;m_Age = age; &#125; int m_Age;&#125;;void test01()&#123; try &#123; Person p(151); &#125; //catch (out_of_range&amp; e) catch(exception &amp;e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; å¼•å…¥å¤´æ–‡ä»¶ #include&lt;stdexcept&gt; æŠ›å‡ºè¶Šç•Œå¼‚å¸¸throw out_of_range(&quot;...&quot;) è·å–é”™è¯¯ä¿¡æ¯catch(exception &amp;e) e.what(); ç¼–å†™è‡ªå·±çš„å¼‚å¸¸ç±»1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;class MyOutOfRangeException :public exception&#123;public: MyOutOfRangeException(const char* str) &#123; //const char *å¯ä»¥éšå¼ç±»å‹è½¬æ¢ä¸ºstringï¼Œåä¹‹ä¸å¯ä»¥ this-&gt;m_errorInfo = str; &#125; MyOutOfRangeException(string str) &#123; this-&gt;m_errorInfo = str; &#125; virtual const char* what() const &#123; //å°†stringè½¬ä¸ºconst char* return m_errorInfo.c_str(); &#125; string m_errorInfo;&#125;;class Person&#123;public: Person(int age) &#123; if (age &lt; 0 || age&gt;150) &#123; throw MyOutOfRangeException(&quot;å¹´é¾„å¿…é¡»åœ¨0-150ä¹‹é—´&quot;); &#125; this-&gt;m_Age = age; &#125; int m_Age;&#125;;void test01()&#123; try &#123; Person p(151); &#125; catch (MyOutOfRangeException&amp; e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; ç¼–å†™MyOutOfRangeç»§æ‰¿Exception é‡å†™virtual const char * what() const å°†stringè½¬ä¸ºconst char *","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"C++å­¦ä¹  ç±»å‹è½¬æ¢","slug":"C++-å­¦ä¹ -ç±»å‹è½¬æ¢","date":"2023-06-30T10:04:47.000Z","updated":"2023-07-01T01:42:54.263Z","comments":true,"path":"2023/06/30/C++-å­¦ä¹ -ç±»å‹è½¬æ¢/","link":"","permalink":"http://example.com/2023/06/30/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"ç±»å‹è½¬æ¢(cast)æ˜¯ä¸€ç§æ•°æ®ç±»å‹è½¬æ¢æˆå¦ä¸€ç§æ•°æ®ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå°†ä¸€ä¸ªæ•´å‹å€¼èµ‹ç»™ä¸€ä¸ªæµ®ç‚¹ç±»å‹çš„å˜é‡ï¼Œç¼–è¯‘å™¨ä¼šæš—åœ°é‡Œå°†å…¶è½¬æ¢æˆæµ®ç‚¹ç±»å‹ã€‚ è½¬æ¢æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œä½†æ˜¯å®ƒä¹Ÿä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚åœ¨è½¬æ¢æŒ‡é’ˆæ—¶ï¼Œæˆ‘ä»¬å¾ˆå¯èƒ½å°†å…¶è½¬æ¢æˆä¸€ä¸ªæ¯”å®ƒæ›´å¤§çš„ç±»å‹ï¼Œä½†è¿™å¯èƒ½ä¼šç ´åå…¶ä»–çš„æ•°æ®ã€‚ åº”è¯¥å°å¿ƒç±»å‹è½¬æ¢ï¼Œå› ä¸ºè½¬æ¢ä¹Ÿå°±ç›¸å½“äºå¯¹ç¼–è¯‘å™¨è¯´ï¼šå¿˜è®°ç±»å‹æ£€æŸ¥ï¼ŒæŠŠä»–çœ‹ä½œå…¶ä»–çš„ç±»å‹ã€‚","text":"ç±»å‹è½¬æ¢(cast)æ˜¯ä¸€ç§æ•°æ®ç±»å‹è½¬æ¢æˆå¦ä¸€ç§æ•°æ®ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå°†ä¸€ä¸ªæ•´å‹å€¼èµ‹ç»™ä¸€ä¸ªæµ®ç‚¹ç±»å‹çš„å˜é‡ï¼Œç¼–è¯‘å™¨ä¼šæš—åœ°é‡Œå°†å…¶è½¬æ¢æˆæµ®ç‚¹ç±»å‹ã€‚ è½¬æ¢æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œä½†æ˜¯å®ƒä¹Ÿä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚åœ¨è½¬æ¢æŒ‡é’ˆæ—¶ï¼Œæˆ‘ä»¬å¾ˆå¯èƒ½å°†å…¶è½¬æ¢æˆä¸€ä¸ªæ¯”å®ƒæ›´å¤§çš„ç±»å‹ï¼Œä½†è¿™å¯èƒ½ä¼šç ´åå…¶ä»–çš„æ•°æ®ã€‚ åº”è¯¥å°å¿ƒç±»å‹è½¬æ¢ï¼Œå› ä¸ºè½¬æ¢ä¹Ÿå°±ç›¸å½“äºå¯¹ç¼–è¯‘å™¨è¯´ï¼šå¿˜è®°ç±»å‹æ£€æŸ¥ï¼ŒæŠŠä»–çœ‹ä½œå…¶ä»–çš„ç±»å‹ã€‚ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå°½é‡å°‘çš„å»ä½¿ç”¨ç±»å‹è½¬æ¢ï¼Œé™¤éç”¨æ¥è§£å†³éå¸¸ç‰¹æ®Šçš„é—®é¢˜ã€‚ æ— è®ºä»€ä¹ˆåŸå› ï¼Œä»»ä½•ä¸€ä¸ªç¨‹åºå¦‚æœä½¿ç”¨å¾ˆå¤šç±»å‹è½¬æ¢éƒ½å€¼å¾—æ€€ç–‘ã€‚ æ ‡å‡†C++æä¾›äº†ä¸€ä¸ªæ˜¾ç¤ºçš„è½¬æ¢çš„è¯­æ³•ï¼Œæ¥æ›¿ä»£æ—§çš„Cé£æ ¼çš„ç±»å‹è½¬æ¢ã€‚ ä½¿ç”¨Cé£æ ¼çš„å¼ºåˆ¶è½¬æ¢å¯ä»¥æŠŠæƒ³è¦çš„ä»»ä½•ä¸œè¥¿è½¬æ¢æˆæˆ‘ä»¬éœ€è¦çš„ç±»å‹ï¼Œé‚£ä¸ºä»€ä¹ˆè¿˜éœ€è¦ä¸€ä¸ªæ–°çš„C++ç±»å‹çš„å¼ºåˆ¶è½¬æ¢å‘¢ï¼Ÿ æ–°ç±»å‹çš„å¼ºåˆ¶è½¬æ¢å¯ä»¥æä¾›ç»™æ›´å¥½çš„æ§åˆ¶å¼ºåˆ¶è½¬æ¢è¿‡ç¨‹ï¼Œå…è®¸æ§åˆ¶å„ç§ä¸åŒç§ç±»çš„å¼ºåˆ¶è½¬æ¢ã€‚C++é£æ ¼çš„å¼ºåˆ¶è½¬æ¢å…¶ä»–çš„å¥½å¤„æ˜¯ï¼Œå®ƒä»¬èƒ½æ›´æ¸…æ™°çš„è¡¨æ˜å®ƒä»¬è¦å¹²ä»€ä¹ˆã€‚ç¨‹åºå‘˜åªè¦æ‰«ä¸€çœ¼è¿™æ ·çš„ä»£ç ï¼Œå°±èƒ½ç«‹å³çŸ¥é“ä¸€ä¸ªå¼ºåˆ¶è½¬æ¢çš„ç›®çš„ã€‚ é™æ€è½¬æ¢ï¼ˆstatic_castï¼‰ ç”¨äºç±»å±‚æ¬¡ç»“æ„ä¸­åŸºç±»ï¼ˆçˆ¶ç±»ï¼‰å’Œæ´¾ç”Ÿç±»ï¼ˆå­ç±»ï¼‰ä¹‹é—´æŒ‡é’ˆæˆ–å¼•ç”¨çš„è½¬æ¢ã€‚ è¿›è¡Œä¸Šè¡Œè½¬æ¢ï¼ˆæŠŠæ´¾ç”Ÿç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨è½¬æ¢æˆåŸºç±»è¡¨ç¤º)æ˜¯å®‰å…¨çš„ã€‚ è¿›è¡Œä¸‹è¡Œè½¬æ¢ï¼ˆæŠŠåŸºç±»æŒ‡é’ˆæˆ–å¼•ç”¨è½¬æ¢æˆæ´¾ç”Ÿç±»è¡¨ç¤ºï¼‰æ—¶ï¼Œç”±äºæ²¡æœ‰åŠ¨æ€ç±»å‹æ£€æŸ¥ï¼Œæ‰€ä»¥æ˜¯ä¸å®‰å…¨çš„ã€‚ ç”¨äºåŸºæœ¬æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢ï¼Œå¦‚æŠŠintè½¬æ¢æˆcharï¼ŒæŠŠcharè½¬æ¢æˆintã€‚è¿™ç§è½¬æ¢çš„å®‰å…¨æ€§ä¹Ÿè¦å¼€å‘äººå‘˜æ¥ä¿è¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;//1ã€é™æ€ç±»å‹è½¬æ¢ static_castvoid test01()&#123; //å…è®¸å†…ç½®çš„æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢ char a = &#x27;a&#x27;; double d = static_cast&lt;double&gt;(a); cout &lt;&lt; d &lt;&lt; endl;&#125;class Base &#123;&#125;;class Son : public Base&#123;&#125;;class Other&#123;&#125;;void test02()&#123; Base* base = NULL; Son* son = NULL; //è¯­æ³•ï¼š static_cast&lt;ç›®æ ‡ç±»å‹&gt;(åŸå¯¹è±¡) // //çˆ¶å­ä¹‹é—´çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨å¯ä»¥è½¬æ¢ //å°†baseè½¬ä¸ºSon* çˆ¶è½¬å­ å‘ä¸‹ç±»å‹è½¬æ¢ ä¸å®‰å…¨ Son* son2 = static_cast&lt;Son*&gt;(base); //sonè½¬ä¸ºBase* å­è½¬çˆ¶ å‘ä¸Šç±»å‹è½¬æ¢ å®‰å…¨ Base* base2 = static_cast&lt;Base*&gt;(son); //baseè½¬ä¸ºOther* //æ²¡æœ‰çˆ¶å­å…³ç³»ï¼Œè½¬æ¢æ— æ•ˆ Other* other = static_cast&lt;Other*&gt;(base);&#125;int main()&#123; test01(); test02();&#125; åŠ¨æ€è½¬æ¢(dynamic_cast) dynamic_castä¸»è¦ç”¨äºç±»å±‚æ¬¡çš„ä¸Šè¡Œè½¬æ¢å’Œä¸‹è¡Œè½¬æ¢ åœ¨ç±»å±‚æ¬¡é—´è¿›è¡Œä¸Šè¡Œè½¬æ¢æ—¶ï¼Œdynamic_castå’Œstatic_castçš„æ•ˆæœæ˜¯ä¸€æ ·çš„ åœ¨è¿›è¡Œä¸‹è¡Œè½¬æ¢æ—¶ï¼Œdynamic_castå…·æœ‰ç±»å‹æ£€æŸ¥çš„åŠŸèƒ½ï¼Œæ¯”static_castæ›´å®‰å…¨ ä¸å…è®¸å†…ç½®æ•°æ®ç±»å‹è½¬æ¢ å…è®¸çˆ¶å­ä¹‹é—´æŒ‡é’ˆæˆ–è€…å¼•ç”¨çš„è½¬æ¢ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;using namespace std;//1ã€é™æ€ç±»å‹è½¬æ¢ static_castvoid test01()&#123; //å…è®¸å†…ç½®çš„æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢ char a = &#x27;a&#x27;; double d = static_cast&lt;double&gt;(a); cout &lt;&lt; d &lt;&lt; endl;&#125;class Base &#123; virtual void func() &#123;&#125; &#125;;class Son : public Base &#123; virtual void func() &#123;&#125; &#125;;class Other&#123;&#125;;void test02()&#123; Base* base = NULL; Son* son = NULL; //è¯­æ³•ï¼š static_cast&lt;ç›®æ ‡ç±»å‹&gt;(åŸå¯¹è±¡) // //çˆ¶å­ä¹‹é—´çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨å¯ä»¥è½¬æ¢ //å°†baseè½¬ä¸ºSon* çˆ¶è½¬å­ å‘ä¸‹ç±»å‹è½¬æ¢ ä¸å®‰å…¨ Son* son2 = static_cast&lt;Son*&gt;(base); //sonè½¬ä¸ºBase* å­è½¬çˆ¶ å‘ä¸Šç±»å‹è½¬æ¢ å®‰å…¨ Base* base2 = static_cast&lt;Base*&gt;(son); //baseè½¬ä¸ºOther* //æ²¡æœ‰çˆ¶å­å…³ç³»ï¼Œè½¬æ¢æ— æ•ˆ //Other* other = static_cast&lt;Other*&gt;(base);&#125;//2ã€åŠ¨æ€ç±»å‹è½¬æ¢ dynamic_castvoid test03()&#123; //ä¸å…è®¸å†…ç½®æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢ //char c = &#x27;c&#x27;; //double d = dynamic_cast&lt;double&gt;(c);&#125;void test04()&#123; Base* base = new Son; Son* son = NULL; //å°†baseè½¬ä¸ºSon * çˆ¶è½¬å­ ä¸å®‰å…¨ è½¬æ¢æ— æ•ˆ å¦‚æœå‘ç”Ÿäº†å¤šæ€ï¼Œé‚£ä¹ˆè½¬æ¢æ€»æ˜¯å®‰å…¨çš„ Son* son2 = dynamic_cast&lt;Son*&gt;(base); //sonè½¬ä¸ºBase* å­è½¬çˆ¶ å®‰å…¨ Base* base2 = dynamic_cast&lt;Base*&gt;(son); //baseè½¬Other* è½¬æ¢æ— æ•ˆ //Other* other = dynamic_cast&lt;Other*&gt;(base);&#125;int main()&#123; test01(); test02(); test03(); test04();&#125; å¸¸é‡è½¬æ¢(const_cast)è¯¥è¿ç®—ç¬¦ç”¨æ¥ä¿®æ”¹ç±»å‹çš„constå±æ€§ å¸¸é‡æŒ‡é’ˆè¢«è½¬åŒ–æˆéå¸¸é‡æŒ‡é’ˆï¼Œå¹¶ä¸”ä»ç„¶æŒ‡å‘åŸæ¥çš„å¯¹è±¡ å¸¸é‡å¼•ç”¨è¢«è½¬æ¢æˆéå¸¸é‡å¼•ç”¨ï¼Œå¹¶ä¸”ä»ç„¶æŒ‡å‘åŸæ¥çš„å¯¹è±¡ ä¸èƒ½ç›´æ¥å¯¹éæŒ‡é’ˆå’Œéå¼•ç”¨çš„å˜é‡ä½¿ç”¨const_castæ“ä½œç¬¦å»ç›´æ¥ç§»é™¤å®ƒçš„cosnt 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;//å¸¸é‡è½¬æ¢void test()&#123; //ä¸å¯ä»¥å°†éæŒ‡é’ˆæˆ–è€…éå¼•ç”¨åšconst_castè½¬æ¢ const int* p = NULL; int *pp = const_cast&lt;int*&gt;(p); const int * ppp = const_cast&lt;const int*&gt;(pp); //const int a = 10; //int b = const_cast&lt;int&gt;(a); int num = 10; int&amp; numRef = num; const int&amp; num2 = const_cast&lt;const int&amp;&gt;(numRef);&#125;int main()&#123; test();&#125; é‡æ–°è§£é‡Šè½¬æ¢(reinterpret_cast)è¿™æ˜¯æœ€ä¸å®‰å…¨çš„ä¸€ç§è½¬æ¢æœºåˆ¶ï¼Œæœ€æœ‰å¯èƒ½å‡ºé—®é¢˜ã€‚ ä¸»è¦ç”¨äºå°†ä¸€ç§æ•°æ®ç±»å‹ä»ä¸€ç§ç±»å‹è½¬æ¢ä¸ºå¦ä¸€ç§ç±»å‹ã€‚å®ƒå¯ä»¥å°†ä¸€ä¸ªæŒ‡é’ˆè½¬æ¢æˆä¸€ä¸ªæ•´æ•°ï¼Œä¹Ÿå¯ä»¥å°†ä¸€ä¸ªæ•´æ•°è½¬æ¢æˆä¸€ä¸ªæŒ‡é’ˆã€‚ 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;class Base &#123; virtual void func() &#123;&#125; &#125;;class Son : public Base &#123; virtual void func() &#123;&#125; &#125;;class Other &#123;&#125;;//é‡æ–°è§£é‡Šè½¬æ¢ reinterpret_castæœ€ä¸å®‰å…¨çš„ä¸€ç§è½¬æ¢ï¼Œä¸å»ºè®®ä½¿ç”¨void test()&#123; int a = 10; int* p = reinterpret_cast&lt;int*&gt;(a); Base* base = NULL; //baseè½¬Other* Other* other = reinterpret_cast&lt;Other*&gt;(base);&#125;int main()&#123; test();&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"å­¦ä¹  Linux VFSè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ[1] ç®€ä»‹","slug":"å­¦ä¹ -Linux-VFSè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ[1] ç®€ä»‹","date":"2023-06-17T07:02:34.000Z","updated":"2023-11-20T02:25:20.547Z","comments":true,"path":"2023/06/17/å­¦ä¹ -Linux-VFSè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ[1] ç®€ä»‹/","link":"","permalink":"http://example.com/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F[1]%20%E7%AE%80%E4%BB%8B/","excerpt":"ç®€ä»‹è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ ï¼ˆVFSï¼‰ æˆ–è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿäº¤æ¢æœºæ˜¯æ›´å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿä¹‹ä¸Šçš„æŠ½è±¡å±‚ã€‚VFS çš„ç›®çš„æ˜¯å…è®¸å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºä»¥ç»Ÿä¸€çš„æ–¹å¼è®¿é—®ä¸åŒç±»å‹çš„å…·ä½“æ–‡ä»¶ç³»ç»Ÿã€‚ä¾‹å¦‚ï¼ŒVFS å¯ç”¨äºé€æ˜åœ°è®¿é—®æœ¬åœ°å’Œç½‘ç»œå­˜å‚¨è®¾å¤‡ï¼Œè€Œå®¢æˆ·ç«¯åº”ç”¨ç¨‹åºä¸ä¼šæ³¨æ„åˆ°å·®å¼‚ã€‚ å³å¯¹äºåº”ç”¨ç¨‹åºé€æ˜ã€‚å®ƒå¯ç”¨äºå¼¥Windowsï¼Œç»å…¸Mac OS &#x2F; macOSå’ŒUnixæ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„å·®å¼‚ï¼Œä»¥ä¾¿åº”ç”¨ç¨‹åºå¯ä»¥è®¿é—®è¿™äº›ç±»å‹çš„æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šçš„æ–‡ä»¶ï¼Œè€Œä¸å¿…çŸ¥é“å®ƒä»¬æ­£åœ¨è®¿é—®çš„æ–‡ä»¶ç³»ç»Ÿç±»å‹ã€‚ VFS æŒ‡å®šå†…æ ¸å’Œå…·ä½“æ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„æ¥å£ï¼ˆæˆ–â€œåå®šâ€ï¼‰ã€‚å› æ­¤ï¼Œåªéœ€å±¥è¡Œåå®šå³å¯è½»æ¾åœ°å‘å†…æ ¸æ·»åŠ å¯¹æ–°æ–‡ä»¶ç³»ç»Ÿç±»å‹çš„æ”¯æŒã€‚","text":"ç®€ä»‹è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ ï¼ˆVFSï¼‰ æˆ–è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿäº¤æ¢æœºæ˜¯æ›´å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿä¹‹ä¸Šçš„æŠ½è±¡å±‚ã€‚VFS çš„ç›®çš„æ˜¯å…è®¸å®¢æˆ·ç«¯åº”ç”¨ç¨‹åºä»¥ç»Ÿä¸€çš„æ–¹å¼è®¿é—®ä¸åŒç±»å‹çš„å…·ä½“æ–‡ä»¶ç³»ç»Ÿã€‚ä¾‹å¦‚ï¼ŒVFS å¯ç”¨äºé€æ˜åœ°è®¿é—®æœ¬åœ°å’Œç½‘ç»œå­˜å‚¨è®¾å¤‡ï¼Œè€Œå®¢æˆ·ç«¯åº”ç”¨ç¨‹åºä¸ä¼šæ³¨æ„åˆ°å·®å¼‚ã€‚ å³å¯¹äºåº”ç”¨ç¨‹åºé€æ˜ã€‚å®ƒå¯ç”¨äºå¼¥Windowsï¼Œç»å…¸Mac OS &#x2F; macOSå’ŒUnixæ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„å·®å¼‚ï¼Œä»¥ä¾¿åº”ç”¨ç¨‹åºå¯ä»¥è®¿é—®è¿™äº›ç±»å‹çš„æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šçš„æ–‡ä»¶ï¼Œè€Œä¸å¿…çŸ¥é“å®ƒä»¬æ­£åœ¨è®¿é—®çš„æ–‡ä»¶ç³»ç»Ÿç±»å‹ã€‚ VFS æŒ‡å®šå†…æ ¸å’Œå…·ä½“æ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„æ¥å£ï¼ˆæˆ–â€œåå®šâ€ï¼‰ã€‚å› æ­¤ï¼Œåªéœ€å±¥è¡Œåå®šå³å¯è½»æ¾åœ°å‘å†…æ ¸æ·»åŠ å¯¹æ–°æ–‡ä»¶ç³»ç»Ÿç±»å‹çš„æ”¯æŒã€‚ ä¸ºäº†è®©æ·»åŠ æ–°çš„æ–‡ä»¶ç³»ç»Ÿæ›´åŠ å®¹æ˜“ï¼Œå¹¶ä¸”æä¾›ä¸€ä¸ªé€šç”¨ï¼ˆgenericï¼‰çš„æ–‡ä»¶APIï¼ŒVFSï¼Œä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿå±‚è¢«åŠ åˆ°äº†linuxå†…æ ¸ä¸­ã€‚ è€Œå¯¹äºEXT2è¿™æ ·çš„çœŸå®ï¼ˆrealï¼‰æ–‡ä»¶ç³»ç»Ÿï¼Œæ˜¯å»è°ƒç”¨VFS APIçš„ã€‚æ–°çš„æ–‡ä»¶ç³»ç»Ÿå’Œæ–°ç±»å‹çš„å­˜å‚¨ä»‹è´¨éƒ½èƒ½æ‰¾åˆ°è¿›å…¥Linuxä¹‹è·¯ï¼Œç¨‹åºæ— éœ€é‡å†™ï¼Œç”šè‡³æ— éœ€é‡æ–°ç¼–è¯‘ã€‚ åœ¨åŒä¸€ä¸ªç›®å½•ç»“æ„ä¸­, å¯ä»¥æŒ‚è½½ç€è‹¥å¹²ç§ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿ. VFSéšè—äº†å®ƒä»¬çš„å®ç°ç»†èŠ‚, ä¸ºä½¿ç”¨è€…æä¾›ç»Ÿä¸€çš„æ¥å£; ç›®å½•ç»“æ„æœ¬èº«å¹¶ä¸æ˜¯ç»å¯¹çš„, æ¯ä¸ªè¿›ç¨‹å¯èƒ½ä¼šçœ‹åˆ°ä¸ä¸€æ ·çš„ç›®å½•ç»“æ„. ç›®å½•ç»“æ„æ˜¯ç”±â€åœ°å€ç©ºé—´(namespace)â€æ¥æè¿°çš„, ä¸åŒçš„è¿›ç¨‹å¯èƒ½æ‹¥æœ‰ä¸åŒçš„namespace, ä¸åŒçš„namespaceå¯èƒ½æœ‰ç€ä¸åŒçš„ç›®å½•ç»“æ„(å› ä¸ºå®ƒä»¬å¯èƒ½æŒ‚è½½äº†ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿ)ã€‚ VFSå±‚æ¬¡ç»“æ„æ“ä½œæ–‡ä»¶çš„æœ¬è´¨æ˜¯å°†ç£ç›˜æ–‡ä»¶æ•°æ®æ˜ å°„åˆ°è¿›ç¨‹ä¸­ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œæ¶‰åŠä»¥ä¸‹å‡ ä¸ªå…³é”®æ­¥éª¤ï¼š è¿›ç¨‹å‘å‡ºæ–‡ä»¶æ“ä½œå‘½ä»¤ï¼šå½“ä¸€ä¸ªè¿›ç¨‹éœ€è¦æ“ä½œæ–‡ä»¶æ—¶ï¼Œå®ƒä¼šé€šè¿‡ç³»ç»Ÿè°ƒç”¨ï¼ˆå¦‚sys_openï¼Œsys_readï¼Œsys_writeç­‰ï¼‰å°†è¯·æ±‚ä¼ é€’ç»™å†…æ ¸ã€‚ç³»ç»Ÿè°ƒç”¨æ˜¯ç”¨æˆ·æ€è¿›ç¨‹ä¸å†…æ ¸æ€ä»£ç ä¹‹é—´çš„æ¥å£ï¼Œç”¨æˆ·æ€è¿›ç¨‹ä¸èƒ½ç›´æ¥è®¿é—®å†…æ ¸æ€èµ„æºï¼Œå› æ­¤é€šè¿‡ç³»ç»Ÿè°ƒç”¨è¯·æ±‚å†…æ ¸å®Œæˆç›¸åº”çš„æ“ä½œã€‚ VFSç³»ç»Ÿè°ƒç”¨openï¼ˆ2)ã€statï¼ˆ2ï¼‰ã€readï¼ˆ2ï¼‰ã€writeï¼ˆ2ï¼‰ã€chmodï¼ˆ2ï¼‰ç­‰éƒ½æ˜¯ä»è¿›ç¨‹ä¸Šä¸‹æ–‡è°ƒç”¨çš„ã€‚ å†…æ ¸æ•°æ®ç»“æ„çš„åˆ›å»ºå’Œç»´æŠ¤ï¼šå½“å†…æ ¸æ”¶åˆ°è¿›ç¨‹çš„æ–‡ä»¶æ“ä½œè¯·æ±‚åï¼Œä¼šä¸ºè¿›ç¨‹æ‰“å¼€çš„æ–‡ä»¶å’Œç³»ç»Ÿæ–‡ä»¶åˆ›å»ºç›¸åº”çš„æ•°æ®ç»“æ„ã€‚ä¸»è¦çš„æ•°æ®ç»“æ„åŒ…æ‹¬ï¼š æ–‡ä»¶æè¿°ç¬¦ï¼ˆfile descriptorï¼‰ï¼šä¸€ä¸ªéè´Ÿæ•´æ•°ï¼Œç”¨äºå”¯ä¸€æ ‡è¯†è¿›ç¨‹ä¸­æ‰“å¼€çš„æ–‡ä»¶ã€‚ æ–‡ä»¶å¯¹è±¡ï¼ˆfile objectï¼‰ï¼šåœ¨å†…æ ¸ä¸­ï¼Œæ–‡ä»¶å¯¹è±¡ä¸æ–‡ä»¶æè¿°ç¬¦å…³è”ï¼Œå­˜å‚¨æ–‡ä»¶çš„å…ƒæ•°æ®ï¼ˆå¦‚æ–‡ä»¶ä½ç½®ã€è®¿é—®æƒé™ç­‰ï¼‰ã€‚ inodeï¼šè¡¨ç¤ºæ–‡ä»¶åœ¨ç£ç›˜ä¸Šçš„å…ƒæ•°æ®ï¼ŒåŒ…æ‹¬æ–‡ä»¶ç±»å‹ã€å¤§å°ã€æƒé™ã€æ—¶é—´æˆ³ç­‰ã€‚ dentryï¼šç¼“å­˜ç›®å½•é¡¹çš„æ•°æ®ç»“æ„ï¼Œç”¨äºå¿«é€ŸæŸ¥æ‰¾æ–‡ä»¶ç³»ç»Ÿä¸­çš„æ–‡ä»¶ã€‚ è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼ˆVFSï¼‰ï¼šè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸€ç§æ–‡ä»¶ç³»ç»ŸæŠ½è±¡å±‚ï¼Œç”¨äºç»Ÿä¸€ä¸åŒç±»å‹çš„æ–‡ä»¶ç³»ç»Ÿå’ŒI&#x2F;Oè®¾å¤‡ï¼ˆå¦‚ç£ç›˜ã€ç®¡é“ã€è¿›ç¨‹é—´é€šä¿¡ã€ç½‘ç»œç­‰ï¼‰çš„æ¥å£ã€‚é€šè¿‡VFSï¼Œå†…æ ¸å¯ä»¥åœ¨ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿå’Œè®¾å¤‡ä¹‹é—´æä¾›ç»Ÿä¸€çš„æ–‡ä»¶æ“ä½œæ¥å£ã€‚ å®ç°è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿå’Œå®é™…æ–‡ä»¶ç³»ç»Ÿçš„æŒ‚è½½ï¼šåœ¨VFSå±‚ä¹‹ä¸‹ï¼Œè¿˜æœ‰è¯¸å¦‚ext4ã€FAT32ç­‰å„ç§å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ã€‚è¿™äº›æ–‡ä»¶ç³»ç»Ÿé€šè¿‡å®ç°VFSå®šä¹‰çš„æ¥å£ä¸VFSå±‚è¿›è¡Œäº¤äº’ã€‚å½“ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿè¢«æŒ‚è½½åˆ°æ“ä½œç³»ç»Ÿæ—¶ï¼ŒVFSä¼šå°†æ–‡ä»¶ç³»ç»Ÿçš„ç›¸å…³æ“ä½œæ˜ å°„åˆ°å¯¹åº”çš„å®ç°ã€‚ è®¾å¤‡é©±åŠ¨æ¥å£å’Œç¼“å­˜ï¼šä¸ºäº†ä¸ä¸åŒç±»å‹çš„ç¡¬ä»¶è®¾å¤‡è¿›è¡Œäº¤äº’ï¼Œå†…æ ¸æä¾›äº†è®¾å¤‡é©±åŠ¨æ¥å£ã€‚è®¾å¤‡é©±åŠ¨ç¨‹åºè´Ÿè´£å°†æ–‡ä»¶ç³»ç»Ÿçš„æ“ä½œè½¬æ¢ä¸ºç‰¹å®šç¡¬ä»¶è®¾å¤‡å¯ä»¥è¯†åˆ«çš„æŒ‡ä»¤ã€‚æ­¤å¤–ï¼Œå†…æ ¸è¿˜é€šè¿‡ç¼“å­˜æŠ€æœ¯æ¥åŠ å¿«æ–‡ä»¶è¯»å†™çš„é€Ÿåº¦ã€‚å¸¸è§çš„ç¼“å­˜æ–¹å¼æœ‰é¡µç¼“å­˜ï¼ˆpage cacheï¼‰å’Œç¼“å†²åŒºç¼“å­˜ï¼ˆbuffer cacheï¼‰ã€‚ é€šç”¨æ–‡ä»¶æ¨¡å‹ç”±å¯¹è±¡ç»„æˆï¼šè¶…çº§å—å¯¹è±¡ã€ç´¢å¼•èŠ‚ç‚¹å¯¹è±¡ã€ç›®å½•é¡¹å¯¹è±¡ã€æ–‡ä»¶å¯¹è±¡ã€‚ VFSå®ç°VFSæ•°æ®ç»“æ„å›¾ç¤ºæ˜¯æ—§ç‰ˆæœ¬çš„VFSå®ç° ä¸‰ä¸ªä¸åŒè¿›ç¨‹å·²æ‰“å¼€åŒä¸€ä¸ªæ–‡ä»¶ï¼Œå…¶ä¸­ä¸¤ä¸ªè¿›ç¨‹ä½¿ç”¨åŒä¸€ä¸ªç¡¬é“¾æ¥ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½ä½¿ç”¨è‡ªå·±çš„æ–‡ä»¶å¯¹è±¡ï¼Œä½†åªéœ€è¦ä¸¤ä¸ªç›®å½•é¡¹å¯¹è±¡ï¼Œæ¯ä¸ªç¡¬é“¾æ¥å¯¹åº”ä¸€ä¸ªç›®å½•é¡¹å¯¹è±¡ã€‚è¿™ä¸¤ä¸ªç›®å½•é¡¹å¯¹è±¡æŒ‡å‘åŒä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹å¯¹è±¡ï¼Œè¿™ä¸ªç´¢å¼•èŠ‚ç‚¹å¯¹è±¡æ ‡è¯†çš„æ˜¯è¶…çº§å—å¯¹è±¡ä»¥åŠæ™®é€šç£ç›˜æ–‡ä»¶ã€‚ VFSé™¤äº†èƒ½ä¸ºæ‰€æœ‰æ–‡ä»¶ç³»ç»Ÿçš„å®ç°æä¾›ä¸€ä¸ªé€šç”¨æ¥å£å¤–ï¼Œå®ƒè¿˜å…·æœ‰å¦ä¸€ä¸ªé‡è¦çš„ä½œç”¨ï¼Œå³æé«˜ç³»ç»Ÿæ€§èƒ½ã€‚æœ€è¿‘æœ€å¸¸ä½¿ç”¨çš„ç›®å½•é¡¹å¯¹è±¡è¢«æ”¾åœ¨æ‰€è°“ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜ï¼ˆdentry cacheï¼‰çš„ç£ç›˜é«˜é€Ÿç¼“å­˜ä¸­ï¼Œä»¥åŠ é€Ÿä»æ–‡ä»¶è·¯å¾„ååˆ°æœ€åä¸€ä¸ªè·¯å¾„åˆ†é‡çš„ç´¢å¼•èŠ‚ç‚¹çš„è½¬æ¢è¿‡ç¨‹ã€‚ inodeæ˜¯å†…æ ¸é€‰æ‹©ç”¨äºè¡¨ç¤ºæ–‡ä»¶å†…å®¹å’Œç›¸å…³å…ƒæ•°æ®çš„æ–¹æ³•ã€‚ç†è®ºä¸Šï¼Œå®ç°è¿™ä¸ªæ¦‚å¿µåªéœ€è¦ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ˆå°½ç®¡å¾ˆé•¿ï¼‰ï¼Œå…¶ä¸­åŒ…å«äº†æ‰€æœ‰å¿…è¦çš„æ•°æ®ã€‚å®é™…ä¸Šï¼Œæ•°æ®åˆ†æ•£åˆ°ä¸€ç³»åˆ—è¾ƒå°çš„ã€å¸ƒå±€æ¸…æ™°çš„ç»“æ„ä¸­ã€‚ è¶…çº§å—super_blockå­˜æ”¾ç³»ç»Ÿå½“ä¸­å·²å®‰è£…æ–‡ä»¶ç³»ç»Ÿæœ‰å…³ä¿¡æ¯ã€‚å¯¹äºåŸºäºç£ç›˜çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè¿™ç±»å¯¹è±¡é€šå¸¸å¯¹åº”å­˜æ”¾åœ¨ç£ç›˜ä¸Šçš„æ–‡ä»¶ç³»ç»Ÿæ§åˆ¶å—ï¼ˆæ¯ä¸ªæ–‡ä»¶ç³»ç»Ÿéƒ½æœ‰ä¸€ä¸ªè¶…çº§å—å¯¹è±¡ï¼‰ã€‚ æ˜¯ä¸€ä¸ªå…¨å±€çš„æ•°æ®ç»“æ„ï¼Œä¸ç®¡æ˜¯ä»€ä¹ˆæ–‡ä»¶ç³»ç»Ÿéƒ½æœ‰è¶…çº§å—ã€‚VFSä¹Ÿæœ‰è¶…çº§å—ã€‚ fs.h - include&#x2F;linux&#x2F;fs.h - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134struct super_block &#123;//æ–‡ä»¶ç³»ç»Ÿçš„æ•´ä½“ä¿¡æ¯æˆå‘˜å¦‚ä¸‹ï¼š struct list_head s_list; /* Keep this first */ //ç”¨æ¥å°†æ‰€æœ‰è¶…çº§å—å®ä¾‹è¿æ¥åˆ°å…¨å±€é“¾è¡¨super_blocks,æŒ‡å‘è¶…çº§å¿«é“¾è¡¨çš„æŒ‡é’ˆ dev_t s_dev; /* search index; _not_ kdev_t */ //ä¿å­˜æ–‡ä»¶ç³»ç»Ÿæ‰€åœ¨çš„å—è®¾å¤‡ï¼Œs_devä¿å­˜è®¾å¤‡å…·ä½“æ–‡ä»¶ç³»ç»Ÿçš„å—è®¾å¤‡æ ‡è¯†ç¬¦ï¼š/dev/hda1ç­‰ unsigned char s_blocksize_bits; //å—å¤§å°çš„å€¼æ‰€å ç”¨çš„ä½æ•° unsigned long s_blocksize; //æ–‡ä»¶ç³»ç»Ÿä¸­æ•°æ®åº“çš„å¤§å°ï¼Œä»¥å­—èŠ‚ä¸ºå•ä½ loff_t s_maxbytes; /* Max file size */ //æ–‡ä»¶æœ€å¤§é•¿åº¦ struct file_system_type *s_type; //æŒ‡å‘æ–‡ä»¶ç³»ç»Ÿç±»å‹file_system_typeæ•°æ®ç»“æ„çš„æŒ‡é’ˆ const struct super_operations *s_op; //æŒ‡å‘ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿç”¨äºè¶…çº§å¿«çš„å‡½æ•°çš„é›†åˆ const struct dquot_operations *dq_op; //æŒ‡å‘ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿç”¨äºé™é¢æ“ä½œçš„å‡½æ•°é›†åˆ const struct quotactl_ops *s_qcop; const struct export_operations *s_export_op; unsigned long s_flags; unsigned long s_iflags; /* internal SB_I_* flags */ unsigned long s_magic; struct dentry *s_root; //æŒ‡å‘æ ¹ç›®å½•çš„ç»“æ„ä½“dentryï¼Œå°†è¶…çº§å—ä¸å…¨å±€æ ¹ç›®å½•çš„dentryé¡¹å…³è”èµ·æ¥ struct rw_semaphore s_umount; //å¯¹è¶…çº§å¿«è¯»å†™æ—¶è¿›è¡ŒåŒæ­¥ int s_count; //å¯¹è¶…çº§å¿«çš„ä½¿ç”¨è®¡æ•° atomic_t s_active;#ifdef CONFIG_SECURITY void *s_security;#endif const struct xattr_handler **s_xattr;#ifdef CONFIG_FS_ENCRYPTION const struct fscrypt_operations *s_cop; struct fscrypt_keyring *s_master_keys; /* master crypto keys in use */#endif#ifdef CONFIG_FS_VERITY const struct fsverity_operations *s_vop;#endif#if IS_ENABLED(CONFIG_UNICODE) struct unicode_map *s_encoding; __u16 s_encoding_flags;#endif struct hlist_bl_head s_roots; /* alternate root dentries for NFS */ struct list_head s_mounts; /* list of mounts; _not_ for fs use */ struct block_device *s_bdev; struct backing_dev_info *s_bdi; struct mtd_info *s_mtd; struct hlist_node s_instances; unsigned int s_quota_types; /* Bitmask of supported quota types */ struct quota_info s_dquot; /* Diskquota specific options */ struct sb_writers s_writers; /* * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and * s_fsnotify_marks together for cache efficiency. They are frequently * accessed and rarely modified. */ void *s_fs_info; /* Filesystem private info */ /* Granularity of c/m/atime in ns (cannot be worse than a second) */ u32 s_time_gran; /* Time limits for c/m/atime in seconds */ time64_t s_time_min; time64_t s_time_max;#ifdef CONFIG_FSNOTIFY __u32 s_fsnotify_mask; struct fsnotify_mark_connector __rcu *s_fsnotify_marks;#endif char s_id[32]; /* Informational name */ uuid_t s_uuid; /* UUID */ unsigned int s_max_links; fmode_t s_mode; /* * The next field is for VFS *only*. No filesystems have any business * even looking at it. You had been warned. */ struct mutex s_vfs_rename_mutex; /* Kludge */ /* * Filesystem subtype. If non-empty the filesystem type field * in /proc/mounts will be &quot;type.subtype&quot; */ const char *s_subtype; const struct dentry_operations *s_d_op; /* default d_op for dentries */ struct shrinker s_shrink; /* per-sb shrinker handle */ /* Number of inodes with nlink == 0 but still referenced */ atomic_long_t s_remove_count; /* * Number of inode/mount/sb objects that are being watched, note that * inodes objects are currently double-accounted. */ atomic_long_t s_fsnotify_connectors; /* Being remounted read-only */ int s_readonly_remount; /* per-sb errseq_t for reporting writeback errors via syncfs */ errseq_t s_wb_err; /* AIO completions deferred from interrupt context */ struct workqueue_struct *s_dio_done_wq; struct hlist_head s_pins; /* * Owning user namespace and default context in which to * interpret filesystem uids, gids, quotas, device nodes, * xattrs and security labels. */ struct user_namespace *s_user_ns; /* * The list_lru structure is essentially just a pointer to a table * of per-node lru lists, each of which has its own spinlock. * There is no need to put them into separate cachelines. */ struct list_lru s_dentry_lru; struct list_lru s_inode_lru; struct rcu_head rcu; struct work_struct destroy_work; struct mutex s_sync_lock; /* sync serialisation lock */ /* * Indicates how deep in a filesystem stack this SB is */ int s_stack_depth; /* s_inode_list_lock protects s_inodes */ spinlock_t s_inode_list_lock ____cacheline_aligned_in_smp; struct list_head s_inodes; /* all inodes */ spinlock_t s_inode_wblist_lock; struct list_head s_inodes_wb; /* writeback inodes */&#125; __randomize_layout; s_rootå°†è¶…çº§å—ä¸å…¨å±€æ ¹ç›®å½•çš„dentryé¡¹å…³è”èµ·æ¥ã€‚åªæœ‰é€šå¸¸å¯è§çš„æ–‡ä»¶ç³»ç»Ÿçš„è¶…çº§å—ï¼Œæ‰æŒ‡å‘&#x2F;ï¼ˆæ ¹ï¼‰ç›®å½•çš„dentryå®ä¾‹ã€‚å…·æœ‰ç‰¹æ®ŠåŠŸèƒ½ã€ä¸å‡ºç°åœ¨é€šå¸¸çš„ç›®å½•å±‚æ¬¡ç»“æ„ä¸­çš„æ–‡ä»¶ç³»ç»Ÿï¼ˆä¾‹å¦‚ï¼Œç®¡é“æˆ–å¥—æ¥å­—æ–‡ä»¶ç³»ç»Ÿï¼‰ï¼ŒæŒ‡å‘ä¸“é—¨çš„é¡¹ï¼Œä¸èƒ½é€šè¿‡æ™®é€šçš„æ–‡ä»¶å‘½ä»¤è®¿é—®ã€‚ å¤„ç†æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡çš„ä»£ç ç»å¸¸éœ€è¦æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å·²ç»è£…è½½ï¼Œè€Œs_rootå¯ç”¨äºè¯¥ç›®çš„ã€‚å¦‚æœå®ƒä¸ºNULLï¼Œåˆ™è¯¥æ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¼ªæ–‡ä»¶ç³»ç»Ÿï¼Œåªåœ¨å†…æ ¸å†…éƒ¨å¯è§ã€‚å¦åˆ™ï¼Œè¯¥æ–‡ä»¶ç³»ç»Ÿåœ¨ç”¨æˆ·ç©ºé—´ä¸­æ˜¯å¯è§çš„ã€‚ æ‰€æœ‰è¶…çº§å¿«å¯¹è±¡æ˜¯ä»¥åŒå‘ç¯å½¢é“¾è¡¨å½¢å¼è¿›è¡Œé“¾æ¥åœ¨ä¸€èµ·ã€‚é“¾è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ å’Œæœ€åä¸€ä¸ªå…ƒç´ çš„åœ°å€åˆ†åˆ«å­˜æ”¾åœ¨super_blockså˜é‡çš„s_list/next/prevåŸŸä¸­ ã€‚ types.h - include&#x2F;linux&#x2F;types.h - Linux source code (v6.3.8) - Bootlin 123struct list_head &#123; struct list_head *next, *prev;&#125;; å…·ä½“æ¶æ„å¦‚ä¸‹ï¼š å°½ç®¡æ¯ä¸ªæ–‡ä»¶ç³»ç»Ÿåœ¨file_system_typeä¸­åªå‡ºç°ä¸€æ¬¡ï¼Œä½†åœ¨æ‰€æœ‰è¶…çº§å—å®ä¾‹çš„é“¾è¡¨ä¸­ï¼Œå¯èƒ½æœ‰å‡ ä¸ªåŒä¸€æ–‡ä»¶ç³»ç»Ÿç±»å‹çš„è¶…çº§å—å®ä¾‹ï¼Œå› ä¸ºåœ¨å„ä¸ªå—è®¾å¤‡&#x2F;åˆ†åŒºä¸Šå¯èƒ½å­˜å‚¨äº†åŒä¸€ç±»å‹çš„å‡ ä¸ªæ–‡ä»¶ç³»ç»Ÿã€‚ä¾‹å¦‚ï¼Œå¤§å¤šæ•°ç³»ç»Ÿéƒ½æœ‰rootå’Œhomeåˆ†åŒºï¼ŒäºŒè€…å¯èƒ½åœ¨ä¸åŒçš„åˆ†åŒºä¸Šï¼Œä½†é€šå¸¸ä½¿ç”¨ç›¸åŒç±»å‹çš„æ–‡ä»¶ç³»ç»Ÿã€‚åœ¨file_system_typeä¸­ï¼ŒåŒä¸€æ–‡ä»¶ç³»ç»Ÿç±»å‹åªéœ€å®šä¹‰ä¸€æ¬¡ï¼Œä½†è¿™ä¸¤ä¸ªè£…è½½ç‚¹çš„è¶…çº§å—ä¸åŒï¼Œè™½ç„¶éƒ½ä½¿ç”¨äº†åŒæ ·çš„æ–‡ä»¶ç³»ç»Ÿã€‚ è¶…çº§å—ç»“æ„çš„ä¸€ä¸ªé‡è¦æˆå‘˜æ˜¯ä¸€ä¸ªåˆ—è¡¨ï¼ŒåŒ…æ‹¬ç›¸å…³æ–‡ä»¶ç³»ç»Ÿä¸­æ‰€æœ‰ä¿®æ”¹è¿‡çš„inodeï¼ˆå†…æ ¸ç›¸å½“ä¸æ•¬åœ°ç§°ä¹‹ä¸ºè„inodeï¼‰ã€‚æ ¹æ®è¯¥åˆ—è¡¨å¾ˆå®¹æ˜“æ ‡è¯†å·²ç»ä¿®æ”¹è¿‡çš„æ–‡ä»¶å’Œç›®å½•ï¼Œä»¥ä¾¿å°†å…¶å†™å›åˆ°å­˜å‚¨ä»‹è´¨ã€‚å›å†™å¿…é¡»ç»è¿‡åè°ƒï¼Œä¿è¯åœ¨ä¸€å®šç¨‹åº¦ä¸Šæœ€å°åŒ–å¼€é”€ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªéå¸¸è´¹æ—¶çš„æ“ä½œï¼ˆç¡¬ç›˜ã€è½¯ç›˜é©±åŠ¨å™¨åŠå…¶ä»–ä»‹è´¨ä¸ç³»ç»Ÿå…¶ä½™ç»„ä»¶ç›¸æ¯”ï¼Œé€Ÿåº¦å¾ˆæ…¢ï¼‰ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœå†™å›ä¿®æ”¹æ•°æ®çš„é—´éš”å¤ªé•¿ä¹Ÿå¯èƒ½æœ‰ä¸¥é‡åæœï¼Œå› ä¸ºç³»ç»Ÿå´©æºƒï¼ˆæˆ–è€…ï¼Œå°±Linuxçš„æƒ…å½¢è€Œè¨€ï¼Œæ›´å¯èƒ½çš„æ˜¯åœç”µï¼‰ä¼šå¯¼è‡´ä¸èƒ½æ¢å¤çš„æ•°æ®ä¸¢å¤±ã€‚å†…æ ¸ä¼šå‘¨æœŸæ€§æ‰«æè„å—çš„åˆ—è¡¨ï¼Œå¹¶å°†ä¿®æ”¹ä¼ è¾“åˆ°åº•å±‚ç¡¬ä»¶ã€‚ ç›¸å…³å‡½æ•° sget sget identifier - Linux source code (v6.3.8) - Bootlin æ„é€ å‡½æ•°ï¼Œå¦‚æœæ²¡æœ‰ä»å·²ç»æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿæ‰¾åˆ°éœ€è¦çš„super_block å°±ä¼šè°ƒç”¨alloc_superåˆ†é…ä¸€ä¸ª 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// å®šä¹‰ sget å‡½æ•°struct super_block *sget(struct file_system_type *type, int (*test)(struct super_block *,void *), int (*set)(struct super_block *,void *), int flags, void *data)&#123; struct user_namespace *user_ns = current_user_ns(); // è·å–å½“å‰ç”¨æˆ·å‘½åç©ºé—´ struct super_block *s = NULL; // åˆå§‹åŒ–è¶…çº§å—æŒ‡é’ˆä¸ºç©º struct super_block *old; // å®šä¹‰ä¸€ä¸ªç”¨äºå­˜å‚¨æ‰¾åˆ°çš„å·²å­˜åœ¨è¶…çº§å—çš„æŒ‡é’ˆ int err; // å®šä¹‰ä¸€ä¸ªé”™è¯¯å˜é‡ // æ£€æŸ¥æ˜¯å¦ä¸ºå­æŒ‚è½½ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å°†ç”¨æˆ·å‘½åç©ºé—´è®¾ç½®ä¸ºåˆå§‹ç”¨æˆ·å‘½åç©ºé—´ if (flags &amp; SB_SUBMOUNT) user_ns = &amp;init_user_ns;retry: // é‡è¯•æ ‡ç­¾ï¼Œç”¨äºåœ¨éœ€è¦æ—¶ä»æ­¤å¤„é‡æ–°å¼€å§‹æ‰§è¡Œ spin_lock(&amp;sb_lock); // è·å–è¶…çº§å—é”ï¼Œä»¥é˜²æ­¢å¹¶å‘é—®é¢˜ // å¦‚æœæœ‰ test å›è°ƒï¼Œé‚£ä¹ˆéå†æ–‡ä»¶ç³»ç»Ÿç±»å‹å¯¹åº”çš„è¶…çº§å—åˆ—è¡¨ if (test) &#123; hlist_for_each_entry(old, &amp;type-&gt;fs_supers, s_instances) &#123; // å¦‚æœ test è¿”å› 0ï¼Œç»§ç»­éå† if (!test(old, data)) continue; // å¦‚æœç”¨æˆ·å‘½åç©ºé—´ä¸åŒ¹é…ï¼Œè§£é”å¹¶é”€æ¯æ–°åˆ›å»ºçš„è¶…çº§å—ï¼Œè¿”å›é”™è¯¯ if (user_ns != old-&gt;s_user_ns) &#123; spin_unlock(&amp;sb_lock); destroy_unused_super(s); return ERR_PTR(-EBUSY); &#125; // å¦‚æœæˆåŠŸè·å–å·²å­˜åœ¨çš„è¶…çº§å—å¼•ç”¨ï¼Œè·³è½¬åˆ°é‡è¯•æ ‡ç­¾ if (!grab_super(old)) goto retry; // é”€æ¯æ–°åˆ›å»ºçš„è¶…çº§å—ï¼Œå¹¶è¿”å›æ‰¾åˆ°çš„å·²å­˜åœ¨è¶…çº§å— destroy_unused_super(s); return old; &#125; &#125; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„è¶…çº§å—ï¼Œåˆ†é…ä¸€ä¸ªæ–°çš„è¶…çº§å— if (!s) &#123; spin_unlock(&amp;sb_lock); s = alloc_super(type, (flags &amp; ~SB_SUBMOUNT), user_ns); if (!s) return ERR_PTR(-ENOMEM); goto retry; &#125; // ä½¿ç”¨ set å›è°ƒåˆå§‹åŒ–æ–°åˆ›å»ºçš„è¶…çº§å— err = set(s, data); if (err) &#123; spin_unlock(&amp;sb_lock); destroy_unused_super(s); return ERR_PTR(err); &#125; // è®¾ç½®è¶…çº§å—çš„æ–‡ä»¶ç³»ç»Ÿç±»å‹å’Œæ ‡è¯†ç¬¦ s-&gt;s_type = type; strlcpy(s-&gt;s_id, type-&gt;name, sizeof(s-&gt;s_id)); // å°†æ–°åˆ›å»ºçš„è¶…çº§å—æ·»åŠ åˆ°å…¨å±€è¶…çº§å—åˆ—è¡¨å’Œæ–‡ä»¶ç³»ç»Ÿç±»å‹çš„è¶…çº§å—åˆ—è¡¨ä¸­ list_add_tail(&amp;s-&gt;s_list, &amp;super_blocks); hlist_add_head(&amp;s-&gt;s_instances, &amp;type-&gt;fs_supers); spin_unlock(&amp;sb_lock); // é‡Šæ”¾è¶…çº§å—é” get_filesystem(type); // å¢åŠ æ–‡ä»¶ç³»ç»Ÿç±»å‹çš„å¼•ç”¨è®¡æ•° register_shrinker_prepared(&amp;s-&gt;s_shrink); // æ³¨å†Œè¶…çº§å—çš„ç¼©å‡å™¨ return s; // è¿”å›æ–°åˆ›å»ºçš„è¶…çº§å—&#125;EXPORT_SYMBOL(sget); put_super put_super identifier - Linux source code (v6.3.8) - Bootlin ææ„å‡½æ•°ï¼Œå½“å¼•ç”¨è®¡æ•°å‡å°‘åˆ°0æ—¶æ‰ä¼šè°ƒç”¨destroy_super çœŸæ­£é‡Šæ”¾ 1234567// å®šä¹‰ put_super å‡½æ•°void put_super(struct super_block *sb)&#123; spin_lock(&amp;sb_lock); // è·å–è¶…çº§å—é”ï¼Œä»¥é˜²æ­¢å¹¶å‘é—®é¢˜ __put_super(sb); // é‡Šæ”¾è¶…çº§å—çš„ä¸´æ—¶å¼•ç”¨ spin_unlock(&amp;sb_lock); // é‡Šæ”¾è¶…çº§å—é”&#125; super_operationsä¸»è¦åŒ…æ‹¬å¯¹inodeæ•°æ®ç»“æ„çš„æ“ä½œï¼Œæ³¨æ„ä¸æ˜¯å¯¹inodeçš„æ“ä½œï¼Œå¯¹inodeçš„æ“ä½œç”±inode_operationsæ¥å®Œæˆã€‚å¦‚ï¼šalloc_inodeã€destroy_inodeã€dirty_inodeç­‰ç­‰ã€‚ è¿˜åŒ…æ‹¬æ–‡ä»¶ç³»ç»ŸæŒ‚è½½å’Œå¸è½½ç­‰æ“ä½œï¼Œå¦‚ï¼šsync_fsã€statfsã€remount_fsç­‰ç­‰ã€‚ æ‰€æœ‰çš„å‡½æ•°ç”±VFSè°ƒç”¨ï¼Œéƒ½åœ¨è¿›ç¨‹ä¸Šä¸‹æ–‡è°ƒç”¨ï¼Œæ‰€æœ‰çš„å‡½æ•°éƒ½å¯èƒ½é˜»å¡ã€‚ super_operations identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233struct super_operations &#123; struct inode *(*alloc_inode)(struct super_block *sb); void (*destroy_inode)(struct inode *); void (*free_inode)(struct inode *); void (*dirty_inode) (struct inode *, int flags); int (*write_inode) (struct inode *, struct writeback_control *wbc); int (*drop_inode) (struct inode *); void (*evict_inode) (struct inode *); void (*put_super) (struct super_block *); int (*sync_fs)(struct super_block *sb, int wait); int (*freeze_super) (struct super_block *); int (*freeze_fs) (struct super_block *); int (*thaw_super) (struct super_block *); int (*unfreeze_fs) (struct super_block *); int (*statfs) (struct dentry *, struct kstatfs *); int (*remount_fs) (struct super_block *, int *, char *); void (*umount_begin) (struct super_block *); int (*show_options)(struct seq_file *, struct dentry *); int (*show_devname)(struct seq_file *, struct dentry *); int (*show_path)(struct seq_file *, struct dentry *); int (*show_stats)(struct seq_file *, struct dentry *);#ifdef CONFIG_QUOTA ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t); ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t); struct dquot **(*get_dquots)(struct inode *);#endif long (*nr_cached_objects)(struct super_block *, struct shrink_control *); long (*free_cached_objects)(struct super_block *, struct shrink_control *);&#125;; ç´¢å¼•èŠ‚ç‚¹inodeå­˜æ”¾å…³äºå…·ä½“æ–‡ä»¶çš„ä¸€äº›ä¿¡æ¯ã€‚å¯¹äºåŸºäºç£ç›˜çš„æ–‡ä»¶ç³»ç»Ÿï¼Œæ­¤ç±»å¯¹è±¡é€šå¸¸å¯¹åº”ç”¨äºå­˜æ”¾åœ¨ç£ç›˜ä¸Šçš„æ–‡ä»¶æ§åˆ¶å—ï¼ˆPCBï¼‰ã€‚æ¯ä¸€ä¸ªæ–‡ä»¶éƒ½æœ‰ä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹å¯¹è±¡ï¼Œæ¯ä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹å¯¹è±¡éƒ½æœ‰ä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹å·ï¼Œå”¯ä¸€æ ‡è¯†æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªæ–‡ä»¶ã€‚å•ä¸ª dentry é€šå¸¸æœ‰ä¸€ä¸ªæŒ‡å‘ inode çš„æŒ‡é’ˆã€‚ç´¢å¼•èŠ‚ç‚¹æ˜¯æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡ï¼Œä¾‹å¦‚å¸¸è§„æ–‡ä»¶ã€ç›®å½•ã€FIFO ã€‚å®ƒä»¬è¦ä¹ˆå­˜åœ¨äºå…‰ç›˜ä¸Šï¼ˆå¯¹äºå—è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿï¼‰ï¼Œè¦ä¹ˆå­˜åœ¨äºå†…å­˜ä¸­ï¼ˆå¯¹äºä¼ªæ–‡ä»¶ç³»ç»Ÿï¼‰ã€‚ å…·ä½“æ–‡ä»¶ç³»ç»Ÿçš„ç´¢å¼•èŠ‚ç‚¹æ˜¯å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼Œæ˜¯ä¸€ç§é™æ€ç»“æ„ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨å®ƒï¼Œå¿…é¡»è°ƒå…¥å†…å­˜ï¼Œå¡«å†™VFSçš„ç´¢å¼•èŠ‚ç‚¹ï¼ˆVFSç´¢å¼•èŠ‚ç‚¹æ˜¯åŠ¨æ€èŠ‚ç‚¹ï¼‰ã€‚éœ€è¦æ—¶ï¼Œå°†ä½äºå…‰ç›˜ä¸Šçš„ç´¢å¼•èŠ‚ç‚¹å¤åˆ¶åˆ°å†…å­˜ä¸­ï¼Œå¹¶å°†å¯¹ç´¢å¼•èŠ‚ç‚¹çš„æ›´æ”¹å†™å›ç£ç›˜ï¼Œå•ä¸ªinodeå¯ä»¥ç”±å¤šä¸ªdentryæŒ‡å‘ï¼ˆä¾‹å¦‚ï¼Œç¡¬é“¾æ¥ï¼‰ã€‚ è¦æŸ¥æ‰¾inodeï¼Œéœ€è¦VFSè°ƒç”¨çˆ¶ç›®å½•inodeçš„lookupï¼ˆï¼‰æ–¹æ³•ã€‚æ­¤æ–¹æ³•ç”±inodeæ‰€åœ¨çš„ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿå®ç°å®‰è£…ã€‚ VFSæ‹¥æœ‰æ‰€éœ€çš„dentryä»¥åŠinodeï¼Œå°±å¯ä»¥open(2)æ‰“å¼€æ–‡ä»¶ï¼Œæˆ–è€…stat(2)æŸ¥çœ‹inodeæ•°æ®ã€‚stat(2)çš„æ“ä½œç›¸å½“ç®€å•ï¼ŒVFSæœ‰äº†dentryï¼Œä»–å°±ä¼šæŸ¥çœ‹inodeæ•°æ®ï¼Œå¹¶å°†å…¶ä¸­çš„ä¸€äº›æ•°æ®ä¼ å›ç”¨æˆ·ç©ºé—´ã€‚ inode identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* * Keep mostly read-only and often accessed (especially for * the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning * of the &#x27;struct inode&#x27;*/struct inode &#123; umode_t i_mode; /* æ–‡ä»¶ç±»å‹å’Œè®¿é—®æƒé™ */ unsigned short i_opflags; /* inode æ“ä½œæ ‡å¿— */ kuid_t i_uid; /* æ–‡ä»¶æ‹¥æœ‰è€…çš„æ ‡è¯†å·ï¼Œç”¨æˆ· ID */ kgid_t i_gid; /* æ–‡ä»¶æ‹¥æœ‰è€…çš„æ‰€åœ¨ç»„çš„æ ‡è¯†å·ï¼Œç»„ ID */ unsigned int i_flags; /* æ–‡ä»¶æˆ–ç›®å½•çš„æ ‡å¿— */#ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; /* è®¿é—®æ§åˆ¶åˆ—è¡¨ (ACL) */ struct posix_acl *i_default_acl; /* é»˜è®¤è®¿é—®æ§åˆ¶åˆ—è¡¨ */#endif const struct inode_operations *i_op; /* inode æ“ä½œå‡½æ•°é›† */ struct super_block *i_sb; /* æŒ‡å‘æ­¤æ–‡ä»¶ç³»ç»Ÿè¶…çº§å—çš„æŒ‡é’ˆ */ struct address_space *i_mapping; /* æ–‡ä»¶å†…å®¹çš„å†…å­˜æ˜ å°„ */#ifdef CONFIG_SECURITY void *i_security; /* å®‰å…¨æ¨¡å—ä½¿ç”¨çš„ inode ä¿¡æ¯ */#endif /* Stat data, not accessed from path walking */ unsigned long i_ino; /* inode ç¼–å· */ union &#123;//ä¸è¯¥èŠ‚ç‚¹å»ºç«‹é“¾æ¥çš„æ–‡ä»¶æ•°é‡ const unsigned int i_nlink; /* ç¡¬é“¾æ¥è®¡æ•° */ unsigned int __i_nlink; &#125;; dev_t i_rdev; /* å®é™…è®¾å¤‡æ ‡è¯†å· */ loff_t i_size; /* æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ */ struct timespec64 i_atime; /* æœ€åè®¿é—®æ—¶é—´ */ struct timespec64 i_mtime; /* æœ€åä¿®æ”¹æ—¶é—´ */ struct timespec64 i_ctime; /* æœ€åå…ƒæ•°æ®æ›´æ”¹æ—¶é—´ */ spinlock_t i_lock; /* ä¿æŠ¤ i_blocks, i_bytes å’Œå¯èƒ½çš„ i_size çš„é” */ unsigned short i_bytes; /* æ–‡ä»¶æœ«å°¾æœªä½¿ç”¨çš„å­—èŠ‚æ•° */ u8 i_blkbits; /* æ–‡ä»¶ç³»ç»Ÿå—å¤§å°çš„ä»¥ 2 ä¸ºåº•çš„å¯¹æ•° */ u8 i_write_hint; /* å†™æ“ä½œçš„ä¼˜åŒ–æç¤º */ blkcnt_t i_blocks; /* æ–‡ä»¶å ç”¨çš„ç£ç›˜å—æ•°é‡ */#ifdef __NEED_I_SIZE_ORDERED seqcount_t i_size_seqcount; /* æœ‰åº i_size çš„åºåˆ—è®¡æ•°å™¨ */#endif /* Misc */ unsigned long i_state; /* inode çŠ¶æ€æ ‡å¿— */ struct rw_semaphore i_rwsem; /* è¯»å†™ä¿¡å·é‡ï¼Œç”¨äºä¿æŠ¤ inode ç»“æ„ */ unsigned long dirtied_when; /* ç¬¬ä¸€æ¬¡è¢«è„çš„æ—¶é—´ï¼Œä»¥ jiffies è®¡ */ unsigned long dirtied_time_when; /* ä¸Šæ¬¡è¢«è„çš„æ—¶é—´ï¼Œä»¥ jiffies è®¡ */ struct hlist_node i_hash; /* æ•£åˆ—é“¾è¡¨ä¸Šçš„èŠ‚ç‚¹ */ struct list_head i_io_list; /* åå¤‡è®¾å¤‡çš„ I/O åˆ—è¡¨ */#ifdef CONFIG_CGROUP_WRITEBACK struct bdi_writeback *i_wb; /* å…³è”çš„ cgroup å†™å›æ§åˆ¶å™¨ */ int i_wb_frn_winner; /* å¤–éƒ¨ inode æ£€æµ‹çš„èµ¢å®¶ */ u16 i_wb_frn_avg_time; /* å¤–éƒ¨ inode çš„å¹³å‡æ—¶é—´ */ u16 i_wb_frn_history; /* å¤–éƒ¨ inode çš„å†å²è®°å½• */#endif struct list_head i_lru; /* inode LRU åˆ—è¡¨ */ struct list_head i_sb_list; /* è¶…çº§å—åˆ—è¡¨ */ struct list_head i_wb_list; /* åå¤‡è®¾å¤‡å†™å›åˆ—è¡¨ */ union &#123; struct hlist_head i_dentry; /* ç›®å½•é¡¹åˆ—è¡¨ */ struct rcu_head i_rcu; &#125;; atomic64_t i_version; /* inode ç‰ˆæœ¬ */ atomic64_t i_sequence; /* ç”¨äº futex çš„åºåˆ—å€¼ */ atomic_t i_count; /* inode å¼•ç”¨è®¡æ•° */ atomic_t i_dio_count; /* ç›´æ¥ I/O è®¡æ•° */ atomic_t i_writecount; /* å†™è®¡æ•° */#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING) atomic_t i_readcount; /* åªè¯»æ‰“å¼€çš„æ–‡ä»¶è®¡æ•° */#endif union &#123; const struct file_operations *i_fop; /* ä»¥å‰çš„ -&gt;i_op-&gt;default_file_ops */ void (*free_inode)(struct inode *); &#125;; struct file_lock_context *i_flctx; /* æ–‡ä»¶é”ä¸Šä¸‹æ–‡ */ struct address_space i_data; /* inode çš„æ•°æ®ç¼“å†²åŒº */ struct list_head i_devices; /* è®¾å¤‡åˆ—è¡¨ */ union &#123; struct pipe_inode_info *i_pipe; /* ç®¡é“ inode ä¿¡æ¯ */ struct cdev *i_cdev; /* å­—ç¬¦è®¾å¤‡ */ char *i_link; /* ç¬¦å·é“¾æ¥çš„ç›®æ ‡è·¯å¾„ */ unsigned i_dir_seq; /* ç›®å½•åºåˆ—è®¡æ•°å™¨ */ &#125;; __u32 i_generation; /* inode ç”Ÿæˆè®¡æ•°å™¨ */#ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* inode å…³å¿ƒçš„æ‰€æœ‰äº‹ä»¶ */ struct fsnotify_mark_connector __rcu *i_fsnotify_marks; /* æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥æ ‡è®°è¿æ¥å™¨ */#endif#ifdef CONFIG_FS_ENCRYPTION struct fscrypt_info *i_crypt_info; /* æ–‡ä»¶ç³»ç»ŸåŠ å¯†ä¿¡æ¯ */#endif#ifdef CONFIG_FS_VERITY struct fsverity_info *i_verity_info; /* æ–‡ä»¶ç³»ç»Ÿå®Œæ•´æ€§ä¿¡æ¯ */#endif void *i_private; /* æ–‡ä»¶ç³»ç»Ÿæˆ–è®¾å¤‡çš„ç§æœ‰æŒ‡é’ˆ */&#125; __randomize_layout; æ¯ä¸€ä¸ªæ–‡ä»¶éƒ½æœ‰ä¸€ä¸ªinodeï¼Œæ¯ä¸ªinodeéƒ½æœ‰ä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹å·i_inoã€‚åœ¨åŒä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿæ—¶æ¯ä¸ªç´¢å¼•èŠ‚ç‚¹å·éƒ½æ˜¯å”¯ä¸€çš„ï¼Œå†…æ ¸æœ‰æ—¶å€™æ ¹æ®ç´¢å¼•èŠ‚ç‚¹å·çš„å“ˆå¸Œå€¼æŸ¥æ‰¾å…¶inodeç»“æ„ã€‚ ç›¸å…³å‡½æ•° new_inode æ„é€ å‡½æ•°ï¼Œè°ƒç”¨alloc_inodeä»inode_cachepåˆ†é…ç´¢å¼•èŠ‚ç‚¹ new_inode identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324/** * new_inode - obtain an inode * @sb: superblock * * Allocates a new inode for given superblock. The default gfp_mask * for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE. * If HIGHMEM pages are unsuitable or it is known that pages allocated * for the page cache are not reclaimable or migratable, * mapping_set_gfp_mask() must be called with suitable flags on the * newly created inode&#x27;s mapping * */struct inode *new_inode(struct super_block *sb)&#123; struct inode *inode; spin_lock_prefetch(&amp;sb-&gt;s_inode_list_lock); inode = new_inode_pseudo(sb); if (inode) inode_sb_list_add(inode); return inode;&#125;EXPORT_SYMBOL(new_inode); inode_operationsinode_operations identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct inode_operations &#123; struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *); int (*permission) (struct mnt_idmap *, struct inode *, int); struct posix_acl * (*get_inode_acl)(struct inode *, int, bool); int (*readlink) (struct dentry *, char __user *,int); int (*create) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t, bool); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct mnt_idmap *, struct inode *,struct dentry *, const char *); int (*mkdir) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t); int (*rmdir) (struct inode *,struct dentry *); int (*mknod) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t,dev_t); int (*rename) (struct mnt_idmap *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int); int (*setattr) (struct mnt_idmap *, struct dentry *, struct iattr *); int (*getattr) (struct mnt_idmap *, const struct path *, struct kstat *, u32, unsigned int); ssize_t (*listxattr) (struct dentry *, char *, size_t); int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start, u64 len); int (*update_time)(struct inode *, struct timespec64 *, int); int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned open_flag, umode_t create_mode); int (*tmpfile) (struct mnt_idmap *, struct inode *, struct file *, umode_t); struct posix_acl *(*get_acl)(struct mnt_idmap *, struct dentry *, int); int (*set_acl)(struct mnt_idmap *, struct dentry *, struct posix_acl *, int); int (*fileattr_set)(struct mnt_idmap *idmap, struct dentry *dentry, struct fileattr *fa); int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa);&#125; ____cacheline_aligned; ç›®å½•é¡¹dentryå­˜æ”¾ç›®å½•é¡¹ä¸å¯¹åº”æ–‡ä»¶è¿›è¡Œé“¾æ¥çš„ä¿¡æ¯ï¼ŒVFSæŠŠæ¯ä¸ªç›®å½•çœ‹ä½œä¸€ä¸ªç”±è‹¥å¹²ä¸ªå­ç›®å½•å’Œæ–‡ä»¶ç»„æˆçš„å¸¸è§„æ–‡ä»¶ã€‚ æ¯ä¸ªæ–‡ä»¶é™¤äº†æœ‰ä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹inodeæ•°æ®ç»“æ„ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªç›®å½•é¡¹dentryï¼ˆdirectory entryï¼‰æ•°æ®ç»“æ„ã€‚ ç›®æ ‡æ˜¯å°†ç”¨æˆ·æä¾›çš„è·¯å¾„åç¿»è¯‘æˆç›®å½•é¡¹ï¼Œä»è€Œè¯†åˆ«è·¯å¾„æŒ‡å®šçš„æ–‡ä»¶æˆ–ç›®å½•VFSå¯èƒ½éœ€è¦åœ¨è·¯å¾„çš„ä¸­é€”ä¸ºä¸­é—´ç›®å½•åˆ›å»ºç›®å½•é¡¹ï¼Œå› ä¸ºæ•´ä¸ªç›®å½•å±‚æ¬¡å¯èƒ½ä¸å®Œå…¨å­˜åœ¨äºå†…å­˜ä¸­ï¼Œå› æ­¤ç³»ç»Ÿå¯èƒ½éœ€è¦åŠ¨æ€åˆ›å»ºè¿™äº›ç»“æ„ã€‚ä¸€æ—¦ç›®å½•é¡¹å°±ç»ªï¼Œè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿéœ€è¦åŠ è½½ä¸è·¯å¾„åæŒ‡å®šçš„æœ€ç»ˆæ–‡ä»¶æˆ–ç›®å½•ç›¸å…³è”çš„ç´¢å¼•èŠ‚ç‚¹Inodeã€‚InodeåŒ…å«æœ‰å…³æ–‡ä»¶æˆ–ç›®å½•çš„è¯¦ç»†ä¿¡æ¯ï¼Œå¦‚æ‰€æœ‰æƒã€æƒé™ä»¥åŠæŒ‡å‘ç£ç›˜ä¸Šå®é™…æ•°æ®å—çš„æŒ‡é’ˆã€‚ dentry identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* ç›®å½•é¡¹çš„æ ‡å¿—ä½ï¼Œå— d_lock ä¿æŠ¤ */ seqcount_spinlock_t d_seq; /* æ¯ä¸ªç›®å½•é¡¹çš„åºåˆ—é” */ struct hlist_bl_node d_hash; /* ç›®å½•é¡¹å½¢æˆçš„ç”¨äºæŸ¥æ‰¾çš„å“ˆå¸Œåˆ—è¡¨ */ struct dentry *d_parent; /* çˆ¶ç›®å½•çš„ç›®å½•é¡¹dentry */ struct qstr d_name; /* ç›®å½•é¡¹çš„åç§°ï¼ˆå¯ä»¥å¿«é€ŸæŸ¥æ‰¾ï¼‰ */ struct inode *d_inode; /* ä¸æ–‡ä»¶åç§°å…³è”çš„ï¼Œä¸ç›®å½•åå…³è”çš„ inode ç»“æ„æŒ‡é’ˆï¼ŒNULL è¡¨ç¤ºè´Ÿç›®å½•é¡¹ */ unsigned char d_iname[DNAME_INLINE_LEN]; /* çŸ­æ–‡ä»¶åç§° */ /* Ref lookup also touches following */ struct lockref d_lockref; /* æ¯ä¸ªç›®å½•é¡¹çš„é”å’Œå¼•ç”¨è®¡æ•° */ const struct dentry_operations *d_op; /* ç›®å½•é¡¹æ“ä½œå‡½æ•°é›† */ struct super_block *d_sb; /* ç›®å½•é¡¹æ ‘çš„æ ¹èŠ‚ç‚¹ï¼ˆå³æ–‡ä»¶çš„è¶…çº§å—ï¼‰ */ unsigned long d_time; /* ç”¨äº d_revalidate çš„æ—¶é—´æˆ³ */ void *d_fsdata; /* ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„æ•°æ® */ union &#123; struct list_head d_lru; /* LRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰åˆ—è¡¨ */ wait_queue_head_t *d_wait; /* ä»…ç”¨äºæŸ¥æ‰¾ä¸­çš„ç›®å½•é¡¹ */ &#125;; struct list_head d_child; /* çˆ¶ç›®å½•é¡¹çš„å­é¡¹åˆ—è¡¨ */ struct list_head d_subdirs; /* å­ç›®å½•é¡¹åˆ—è¡¨ */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode åˆ«ååˆ—è¡¨ */ struct hlist_bl_node d_in_lookup_hash; /* ä»…ç”¨äºæŸ¥æ‰¾ä¸­çš„ç›®å½•é¡¹ */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; å„ä¸ªdentryå®ä¾‹ç»„æˆäº†ä¸€ä¸ªç½‘ç»œï¼Œä¸æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„å½¢æˆä¸€å®šçš„æ˜ å°„å…³ç³»ã€‚ä¸ç»™å®šç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å’Œå­ç›®å½•ç›¸å…³è”çš„dentryå®ä¾‹ï¼Œéƒ½å½’å…¥åˆ°d_subdirsé“¾è¡¨ï¼ˆåœ¨ç›®å½•å¯¹åº”çš„dentryå®ä¾‹ä¸­ï¼‰ã€‚å­ç»“ç‚¹çš„d_childæˆå‘˜å……å½“é“¾è¡¨å…ƒç´ ã€‚ dentryç»“æ„çš„ä¸»è¦ç”¨é€”æ˜¯å»ºç«‹æ–‡ä»¶åå’Œç›¸å…³çš„inodeä¹‹é—´çš„å…³è”ã€‚ç»“æ„ä¸­æœ‰3ä¸ªæˆå‘˜ç”¨äºè¯¥ç›®çš„ã€‚ d_inodeæ˜¯æŒ‡å‘ç›¸å…³çš„inodeå®ä¾‹çš„æŒ‡é’ˆã€‚ å¦‚æœdentryå¯¹è±¡æ˜¯ä¸ºä¸€ä¸ªä¸å­˜åœ¨çš„æ–‡ä»¶åå»ºç«‹çš„ï¼Œåˆ™d_inodeä¸ºNULLæŒ‡é’ˆã€‚è¿™æœ‰åŠ©äºåŠ é€ŸæŸ¥æ‰¾ä¸å­˜åœ¨çš„æ–‡ä»¶åï¼Œé€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™ä¸æŸ¥æ‰¾å®é™…å­˜åœ¨çš„æ–‡ä»¶ååŒæ ·è€—æ—¶ã€‚ d_nameæŒ‡å®šäº†æ–‡ä»¶çš„åç§°ã€‚qstræ˜¯ä¸€ä¸ªå†…æ ¸å­—ç¬¦ä¸²çš„åŒ…è£…å™¨ã€‚å®ƒå­˜å‚¨äº†å®é™…çš„char *å­—ç¬¦ä¸²ä»¥åŠå­—ç¬¦ä¸²é•¿åº¦å’Œæ•£åˆ—å€¼ï¼Œè¿™ä½¿å¾—æ›´å®¹æ˜“å¤„ç†æŸ¥æ‰¾å·¥ä½œã€‚ d_opæŒ‡å‘ä¸€ä¸ªç»“æ„ï¼Œå…¶ä¸­åŒ…å«äº†å„ç§å‡½æ•°æŒ‡é’ˆï¼Œæä¾›å¯¹dentryå¯¹è±¡çš„å„ç§æ“ä½œã€‚è¿™äº›æ“ä½œå¿…é¡»ç”±åº•å±‚æ–‡ä»¶ç³»ç»Ÿå®ç°ã€‚ s_sbæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘dentryå¯¹è±¡æ‰€å±æ–‡ä»¶ç³»ç»Ÿè¶…çº§å—çš„å®ä¾‹ã€‚è¯¥æŒ‡é’ˆä½¿å¾—å„ä¸ªdentryå®ä¾‹æ•£å¸ƒåˆ°å¯ç”¨çš„ï¼ˆå·²è£…è½½çš„ï¼‰æ–‡ä»¶ç³»ç»Ÿã€‚ç”±äºæ¯ä¸ªè¶…çº§å—ç»“æ„éƒ½åŒ…å«äº†ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘è¯¥æ–‡ä»¶ç³»ç»Ÿè£…è½½ç‚¹å¯¹åº”ç›®å½•çš„dentryå®ä¾‹ï¼Œå› æ­¤dentryç»„æˆçš„æ ‘å¯ä»¥åˆ’åˆ†ä¸ºå‡ ä¸ªå­æ ‘ã€‚ d_flagså¯ä»¥åŒ…å«å‡ ä¸ªæ ‡å¿—ï¼Œæ ‡å¿—åœ¨include&#x2F;linux&#x2F;dcache.hä¸­å®šä¹‰ã€‚ä½†å…¶ä¸­åªæœ‰ä¸¤ä¸ªä¸æˆ‘ä»¬çš„ç›®çš„ç›¸å…³ï¼šDCACHE_DISCONNECTEDæŒ‡å®šä¸€ä¸ªdentryå½“å‰æ²¡æœ‰è¿æ¥åˆ°è¶…çº§å—çš„dentryæ ‘ã€‚DCACHE_UNHASHEDè¡¨æ˜è¯¥dentryå®ä¾‹æ²¡æœ‰åŒ…å«åœ¨ä»»ä½•inodeçš„æ•£åˆ—è¡¨ä¸­ã€‚è¦æ³¨æ„ï¼Œè¿™ä¸¤ä¸ªæ ‡å¿—æ˜¯å½¼æ­¤å®Œå…¨ç‹¬ç«‹çš„ã€‚ d_parentæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘å½“å‰ç»“ç‚¹çˆ¶ç›®å½•çš„dentryå®ä¾‹ï¼Œå½“å‰çš„dentryå®ä¾‹å³ä½äºçˆ¶ç›®å½•çš„ã€‚ d_subdirsé“¾è¡¨ä¸­ã€‚å¯¹äºæ ¹ç›®å½•ï¼ˆæ²¡æœ‰çˆ¶ç›®å½•ï¼‰ï¼Œd_parentæŒ‡å‘å…¶è‡ªèº«çš„dentryå®ä¾‹ã€‚ d_aliasç”¨ä½œé“¾è¡¨å…ƒç´ ï¼Œä»¥è¿æ¥è¡¨ç¤ºç›¸åŒæ–‡ä»¶çš„å„ä¸ªdentryå¯¹è±¡ã€‚åœ¨åˆ©ç”¨ç¡¬é“¾æ¥ç”¨ä¸¤ä¸ªä¸åŒåç§°è¡¨ç¤ºåŒä¸€æ–‡ä»¶æ—¶ï¼Œä¼šå‘ç”Ÿè¿™ç§æƒ…å†µã€‚å¯¹åº”äºæ–‡ä»¶çš„inodeçš„i_dentryæˆå‘˜ç”¨ä½œè¯¥é“¾è¡¨çš„è¡¨å¤´ã€‚å„ä¸ªdentryå¯¹è±¡é€šè¿‡d_aliasè¿æ¥åˆ°è¯¥é“¾è¡¨ä¸­ã€‚ ä½†å…¶ä¸­å¹¶éå®Œå…¨æ˜ å°„æ–‡ä»¶ç³»ç»Ÿçš„æ‹“æ‰‘ç»“æ„ï¼Œå› ä¸ºdentryç¼“å­˜åªåŒ…å«æ–‡ä»¶ç³»ç»Ÿç»“æ„çš„ä¸€å°éƒ¨åˆ†ã€‚ æœ€å¸¸ç”¨æ–‡ä»¶å’Œç›®å½•å¯¹åº”çš„ç›®å½•é¡¹æ‰ä¿å­˜åœ¨å†…å­˜ä¸­ã€‚åŸåˆ™ä¸Šï¼Œå¯ä»¥ä¸ºæ‰€æœ‰æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡éƒ½ç”Ÿæˆdentryé¡¹ï¼Œä½†ç‰©ç†å†…å­˜ç©ºé—´å’Œæ€§èƒ½åŸå› éƒ½é™åˆ¶äº†è¿™æ ·åšã€‚ dentryæ•°æ®ç»“æ„ä»£è¡¨çš„æ˜¯é€»è¾‘æ„ä¹‰ä¸Šçš„æ–‡ä»¶ï¼Œæ‰€æè¿°çš„æ˜¯æ–‡ä»¶é€»è¾‘ä¸Šçš„å±æ€§ï¼Œç›®å½•é¡¹å¯¹è±¡åœ¨ç£ç›˜ä¸Šå¹¶æ²¡æœ‰å¯¹åº”çš„æ˜ åƒï¼Œè€Œinodeæ•°æ®ç»“æ„ä»£è¡¨çš„æ˜¯ç‰©ç†æ„ä¹‰ä¸Šçš„æ–‡ä»¶ï¼Œè®°å½•çš„æ˜¯ç‰©ç†ä¸Šçš„å±æ€§ï¼Œå¯¹äºä¸€ä¸ªå…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿï¼ˆex2&#x2F;3&#x2F;4ç­‰ï¼‰ï¼Œext3_inodeç»“æ„åœ¨ç£ç›˜ä¸Šå°±æœ‰å¯¹åº”çš„æ˜ åƒã€‚ä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹å¯¹è±¡å¯èƒ½å¯¹åº”å¤šä¸ªç›®å½•é¡¹å¯¹è±¡ã€‚ æ¯ä¸ªç›®å½•é¡¹å¯¹è±¡å±äºä¸€ä¸‹å››ç§çŠ¶æ€ä¹‹ä¸€ ç©ºé—²çŠ¶æ€ï¼ˆfreeï¼‰ å¤„äºè¯¥çŠ¶æ€çš„ç›®å½•é¡¹å¯¹è±¡ä¸åŒ…å«æœ‰æ•ˆçš„ä¿¡æ¯ï¼Œè¿˜æ²¡æœ‰è¢«VFSä½¿ç”¨ã€‚å®ƒå¯¹åº”çš„å†…å­˜åŒºç”±slabåˆ†é…å™¨è¿›è¡Œç®¡ç†ã€‚ æœªä½¿ç”¨çŠ¶æ€ï¼ˆunusedï¼‰ å¤„äºè¯¥çŠ¶æ€çš„ç›®å½•é¡¹å¯¹è±¡å½“å‰è¿˜æ²¡æœ‰è¢«å†…æ ¸ä½¿ç”¨ã€‚è¯¥å¯¹è±¡çš„å¼•ç”¨è®¡æ•°å™¨d_countçš„å€¼ä¸ºNULLã€‚ä½†å…¶d_inodeåŸŸä»ç„¶æŒ‡å‘ç›¸å…³çš„ç´¢å¼•èŠ‚ç‚¹ã€‚è¯¥ç›®å½•é¡¹å¯¹è±¡åŒ…å«æœ‰æ•ˆçš„ä¿¡æ¯ï¼Œä½†ä¸ºäº†åœ¨å¿…è¦æ—¶å›æ”¶å†…å­˜ï¼Œå®ƒçš„å†…å®¹å¯èƒ½è¢«ä¸¢å¼ƒã€‚ æ­£åœ¨ä½¿ç”¨çŠ¶æ€ï¼ˆinuseï¼‰ å¤„äºè¯¥çŠ¶æ€çš„ç›®å½•é¡¹å¯¹è±¡å½“å‰æ­£åœ¨è¢«å†…æ ¸ä½¿ç”¨ï¼Œè¯¥å¯¹è±¡çš„å¼•ç”¨è®¡æ•°å™¨d_countçš„å€¼ä¸ºæ­£æ•°ï¼Œè€Œå…¶d_inodeåŸŸæŒ‡å‘ç›¸å…³çš„ç´¢å¼•èŠ‚ç‚¹å¯¹è±¡ã€‚è¯¥ç›®å½•é¡¹å¯¹è±¡åŒ…å«æœ‰æ•ˆçš„ä¿¡æ¯ï¼Œå¹¶ä¸”ä¸èƒ½è¢«ä¸¢å¼ƒã€‚ è´ŸçŠ¶æ€ï¼ˆnegativeï¼‰ ä¸ç›®å½•é¡¹ç›¸å…³çš„ç´¢å¼•èŠ‚ç‚¹ä¸å¤å­˜åœ¨ï¼Œé‚£æ˜¯å› ä¸ºç›¸åº”çš„ç£ç›˜ç´¢å¼•èŠ‚ç‚¹å·²è¢«åˆ é™¤ã€‚è¯¥ç›®å½•é¡¹å¯¹è±¡çš„d_inodeåŸŸè¢«ç½®ä¸ºNULLï¼Œä½†è¯¥å¯¹è±¡ä»ç„¶è¢«ä¿å­˜åœ¨ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜ä¸­ï¼Œä»¥ä¾¿åç»­å¯¹åŒä¸€æ–‡ä»¶ç›®å½•åçš„æŸ¥æ‰¾æ“ä½œèƒ½å¤Ÿå¿«é€Ÿå®Œæˆã€‚ ç›¸å…³å‡½æ•° d_alloc æ„é€ å‡½æ•°ï¼Œä»dentry_cacheåˆ†é…ä¸€ä¸ªnegativeç›®å½•é¡¹ 123456789101112131415161718192021222324252627/** * d_alloc - allocate a dcache entry * @parent: parent of entry to allocate * @name: qstr of the name * * Allocates a dentry. It returns %NULL if there is insufficient memory * available. On a success the dentry is returned. The name passed in is * copied and the copy passed in may be reused after this call. */struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)&#123; struct dentry *dentry = __d_alloc(parent-&gt;d_sb, name); if (!dentry) return NULL; spin_lock(&amp;parent-&gt;d_lock); /* * don&#x27;t need child lock because it is not subject * to concurrency here */ __dget_dlock(parent); dentry-&gt;d_parent = parent; list_add(&amp;dentry-&gt;d_child, &amp;parent-&gt;d_subdirs); spin_unlock(&amp;parent-&gt;d_lock); return dentry;&#125;EXPORT_SYMBOL(d_alloc); dput æå¤Ÿå‡½æ•°ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º0æ—¶è°ƒç”¨dentry_killé‡Šæ”¾ç›®å½•é¡¹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * This is dput * * This is complicated by the fact that we do not want to put * dentries that are no longer on any hash chain on the unused * list: we&#x27;d much rather just get rid of them immediately. * * However, that implies that we have to traverse the dentry * tree upwards to the parents which might _also_ now be * scheduled for deletion (it may have been only waiting for * its last child to go away). * * This tail recursion is done by hand as we don&#x27;t want to depend * on the compiler to always get this right (gcc generally doesn&#x27;t). * Real recursion would eat up our stack space. *//* * dput - release a dentry * @dentry: dentry to release * * Release a dentry. This will drop the usage count and if appropriate * call the dentry unlink method as well as removing it from the queues and * releasing its resources. If the parent dentries were scheduled for release * they too may now get deleted. */void dput(struct dentry *dentry)&#123; while (dentry) &#123; // å½“ dentry éç©ºæ—¶ï¼Œè¿›å…¥å¾ªç¯ might_sleep(); // æ£€æŸ¥æ˜¯å¦å¯ä»¥å®‰å…¨åœ°ç¡çœ  rcu_read_lock(); // è·å– RCU è¯»é” if (likely(fast_dput(dentry))) &#123; // å¦‚æœ fast_dput è¿”å› trueï¼Œè¯´æ˜ dentry çš„å¼•ç”¨è®¡æ•°å·²å‡å°‘ rcu_read_unlock(); // é‡Šæ”¾ RCU è¯»é” return; // è¿”å›ï¼Œç»“æŸå‡½æ•° &#125; // slow case: ç°åœ¨æŒæœ‰ dentry é” rcu_read_unlock(); // é‡Šæ”¾ RCU è¯»é” if (likely(retain_dentry(dentry))) &#123; // å¦‚æœ retain_dentry è¿”å› trueï¼Œè¯´æ˜ dentry åº”ä¿ç•™ spin_unlock(&amp;dentry-&gt;d_lock); // è§£é” dentry return; // è¿”å›ï¼Œç»“æŸå‡½æ•° &#125; dentry = dentry_kill(dentry); // åˆ é™¤ dentryï¼Œè¿”å›å…¶çˆ¶ dentry &#125;&#125;EXPORT_SYMBOL(dput); dentry_operationsç”±äºdentryä¸»è¦ä¾›VFSä½¿ç”¨ï¼Œæ‰€ä»¥æ“ä½œé›†ä¸­çš„å‡½æ•°ä¸€èˆ¬æƒ…å†µä¸‹ä¹Ÿä¸éœ€è¦å…·ä½“æ–‡ä»¶ç³»ç»Ÿå»å®ç°ã€‚è¿™é‡Œçš„å‡½æ•°æ˜¯é’ˆå¯¹dentryçš„æ“ä½œï¼Œå¦‚d_revalidateã€d_hashã€d_compareã€d_deleteã€ d_releaseã€d_pruneç­‰ç­‰ã€‚ æ¯”è¾ƒå®¹æ˜“æ··æ·†çš„æ˜¯d_deleteå’Œd_pruneï¼Œå‰è€…åªæ˜¯åˆ¤æ–­æ˜¯å¦éœ€è¦deleteï¼Œå¦‚æœè¦deleteå°±ä¼šé‡Šæ”¾dentryï¼Œå¦åˆ™ä¼šå°†dentryåŠ å…¥åˆ°LRUï¼Œè€Œåè€…æ˜¯åœ¨unhashå‰çš„æœ€åä¸€æ­¥åŠ¨ä½œï¼Œå½“ç„¶ä¸€èˆ¬ä¹Ÿä¸éœ€è¦å®ç°ã€‚è€Œd_releaseåªä¼šåœ¨æœ€åè°ƒç”¨ï¼Œå®ƒè´Ÿè´£é‡Šæ”¾å†…å­˜ã€‚ dentry_operations identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213141516struct dentry_operations &#123; int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, struct qstr *); int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); int (*d_init)(struct dentry *); void (*d_release)(struct dentry *); void (*d_prune)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(const struct path *, bool); struct dentry *(*d_real)(struct dentry *, const struct inode *);&#125; ____cacheline_aligned; æ–‡ä»¶fileå­˜æ”¾æ‰“å¼€æ–‡ä»¶ä¸è¿›ç¨‹ä¹‹é—´äº¤äº’çš„æœ‰å…³ä¿¡æ¯ã€‚è¿™ç±»ä¿¡æ¯ä»…ä»…æ˜¯åœ¨è¿›ç¨‹è®¿é—®æ–‡ä»¶æœŸé—´å­˜åœ¨äºå†…å­˜çš„ã€‚æ–‡ä»¶å¯¹è±¡è¡¨ç¤ºè¿›ç¨‹å·²æ‰“å¼€çš„æ–‡ä»¶ï¼Œå¦‚æœæˆ‘ä»¬ç«™åœ¨ç”¨æˆ·è§’åº¦æ¥çœ‹å¾…VFSï¼Œæ–‡ä»¶å¯¹è±¡ä¼šé¦–å…ˆè¿›å…¥æˆ‘ä»¬çš„è§†é‡ã€‚è¿›ç¨‹ç›´æ¥å¤„ç†çš„æ˜¯æ–‡ä»¶ï¼Œè€Œä¸æ˜¯è¶…çº§å—ã€ç´¢å¼•èŠ‚ç‚¹æˆ–ç›®å½•é¡¹ã€‚æ–‡ä»¶å¯¹è±¡ç”±ç›¸åº”çš„openï¼ˆï¼‰ç³»ç»Ÿè°ƒç”¨åˆ›å»ºï¼Œç”±closeï¼ˆï¼‰ç³»ç»Ÿè°ƒç”¨æ’¤é”€ã€‚fileä¹Ÿæ˜¯files_structå®šä¹‰æ—¶ç”¨åˆ°çš„ä¸€ä¸ªç»“æ„ã€‚ æ‰“å¼€æ–‡ä»¶éœ€è¦åˆ†é…æ–‡ä»¶ç»“æ„ï¼ˆè¿™æ˜¯æ–‡ä»¶æè¿°ç¬¦çš„å†…æ ¸ç«¯å®ç°ï¼‰,æ–°åˆ†é…çš„æ–‡ä»¶ç»“æ„ä½¿ç”¨æŒ‡å‘dentryçš„æŒ‡é’ˆå’Œä¸€ç»„æ–‡ä»¶æ“ä½œæˆå‘˜å‡½æ•°è¿›è¡Œåˆå§‹åŒ–ã€‚è¿™äº›å–è‡ª inode æ•°æ®ã€‚ç„¶åè°ƒç”¨ openï¼ˆï¼‰ æ–‡ä»¶æ–¹æ³•ï¼Œä»¥ä¾¿ç‰¹å®šçš„æ–‡ä»¶ç³»ç»Ÿå®ç°å¯ä»¥å®Œæˆå…¶å·¥ä½œã€‚æ‚¨å¯ä»¥çœ‹åˆ°è¿™æ˜¯ VFS æ‰§è¡Œçš„å¦ä¸€ä¸ªå¼€å…³ã€‚æ–‡ä»¶ç»“æ„è¢«æ”¾ç½®åœ¨è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦è¡¨ä¸­ã€‚ è¯»å–ã€å†™å…¥å’Œå…³é—­æ–‡ä»¶ï¼ˆä»¥åŠå…¶ä»–å„ç§ VFS æ“ä½œï¼‰æ˜¯é€šè¿‡ä½¿ç”¨ç”¨æˆ·ç©ºé—´æ–‡ä»¶æè¿°ç¬¦è·å–é€‚å½“çš„æ–‡ä»¶ç»“æ„ï¼Œç„¶åè°ƒç”¨æ‰€éœ€çš„æ–‡ä»¶ç»“æ„æ–¹æ³•æ¥æ‰§è¡Œæ‰€éœ€çš„ä»»ä½•æ“ä½œæ¥å®Œæˆçš„ã€‚ åªè¦æ–‡ä»¶å¤„äºæ‰“å¼€çŠ¶æ€ï¼Œå®ƒå°±ä¼šä½¿ dentry ä¿æŒä½¿ç”¨çŠ¶æ€ï¼Œè¿™åè¿‡æ¥æ„å‘³ç€ VFS inode ä»åœ¨ä½¿ç”¨ä¸­ã€‚ file identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct file &#123; union &#123; struct llist_node f_llist; struct rcu_head f_rcuhead; unsigned int f_iocb_flags; &#125;; // å®šä¹‰ä¸€ä¸ªè”åˆä½“ï¼Œç”¨äºèŠ‚çœç©ºé—´ã€‚è”åˆä½“ä¸­åªæœ‰ä¸€ä¸ªæˆå‘˜ä¼šè¢«å®é™…ä½¿ç”¨ã€‚ struct path f_path; // æ–‡ä»¶è·¯å¾„ åŒ…å«ç›®å½•é¡¹ struct inode *f_inode; /* ç¼“å­˜çš„å€¼ */ const struct file_operations *f_op; // æ–‡ä»¶æ“ä½œå‡½æ•°æŒ‡é’ˆ /* * ä¿æŠ¤ f_ep å’Œ f_flags çš„è‡ªæ—‹é”ã€‚ * ä¸å¾—åœ¨ IRQ ä¸Šä¸‹æ–‡ä¸­ä½¿ç”¨ã€‚ */ spinlock_t f_lock; atomic_long_t f_count; // æ–‡ä»¶å¼•ç”¨è®¡æ•° unsigned int f_flags; // æ–‡ä»¶æ ‡å¿— fmode_t f_mode; // æ–‡ä»¶æ¨¡å¼ struct mutex f_pos_lock; // ç”¨äºä¿æŠ¤æ–‡ä»¶ä½ç½®çš„äº’æ–¥é” loff_t f_pos; // æ–‡ä»¶ä½ç½® struct fown_struct f_owner; // æ–‡ä»¶æ‰€æœ‰è€… const struct cred *f_cred; // æŒ‡å‘æ–‡ä»¶å‡­è¯çš„æŒ‡é’ˆ struct file_ra_state f_ra; // æ–‡ä»¶è¯»å–çŠ¶æ€ u64 f_version; // æ–‡ä»¶ç‰ˆæœ¬#ifdef CONFIG_SECURITY void *f_security; // æŒ‡å‘æ–‡ä»¶å®‰å…¨ç»“æ„çš„æŒ‡é’ˆ#endif /* éœ€è¦ç”¨äº tty é©±åŠ¨ç¨‹åºï¼Œä»¥åŠå…¶ä»–å¯èƒ½éœ€è¦çš„ç¨‹åº */ void *private_data; // ç§æœ‰æ•°æ®æŒ‡é’ˆ#ifdef CONFIG_EPOLL /* ç”± fs/eventpoll.c ä½¿ç”¨ï¼Œå°†æ‰€æœ‰é’©å­é“¾æ¥åˆ°æ­¤æ–‡ä»¶ */ struct hlist_head *f_ep;#endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; // æ–‡ä»¶æ˜ å°„åœ°å€ç©ºé—´ errseq_t f_wb_err; // å†™å›é”™è¯¯åºåˆ— errseq_t f_sb_err; // ç”¨äº syncfs çš„è¶…çº§å—é”™è¯¯åºåˆ—&#125; __randomize_layout __attribute__((aligned(4))); /* ä»¥é˜²æŸäº›å¥‡æ€ªçš„è®¾å¤‡è®¤ä¸º 2 æ˜¯åˆé€‚çš„å¯¹é½æ–¹å¼ */ f_pathå°è£…äº†ä¸‹é¢ä¸¤éƒ¨åˆ†ä¿¡æ¯ï¼š æ–‡ä»¶åå’Œinodeä¹‹é—´çš„å…³è”ï¼ˆdentryï¼‰ path identifier - Linux source code (v6.3.8) - Bootlin 1234struct path &#123; struct vfsmount *mnt; struct dentry *dentry;&#125; __randomize_layout; file_operations123456789101112131415161718192021222324252627282930313233343536373839404142434445struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *, unsigned int flags); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); unsigned long mmap_supported_flags; int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f);#ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *);#endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); int (*fadvise)(struct file *, loff_t, loff_t, int); int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags); int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int poll_flags);&#125; __randomize_layout; ç´¢å¼•èŠ‚ç‚¹&#x2F;ç›®å½•&#x2F;å—-é«˜é€Ÿç¼“å­˜ ç´¢å¼•èŠ‚ç‚¹inodeé«˜é€Ÿç¼“å­˜ åŠ å¿«æ–‡ä»¶ç³»ç»Ÿæ“ä½œé€Ÿåº¦çš„ç¼“å­˜æœºåˆ¶ï¼ˆå†…å­˜ç¼“å­˜ï¼Œä¿å­˜æ–‡ä»¶ç³»ç»Ÿä¸­æ‰€æœ‰çš„ç´¢å¼•èŠ‚ç‚¹ï¼ˆinodeï¼‰ï¼Œå¯ä»¥é¿å…é¢‘ç¹ä»ç£ç›˜è¯»å–ç´¢å¼•èŠ‚ç‚¹ä¿¡æ¯ï¼‰ ç›®å½•é¡¹dentryé«˜é€Ÿç¼“å­˜ åŠ å¿«æ–‡ä»¶ç³»ç»Ÿæ“ä½œé€Ÿåº¦çš„ç¼“å­˜æœºåˆ¶ï¼ˆå†…å­˜ç¼“å­˜ï¼Œä¿å­˜æ–‡ä»¶ç³»ç»Ÿä¸­æ‰€æœ‰å·²ç»æ‰“å¼€çš„ç›®å½•é¡¹ï¼Œå¯ä»¥é¿å…é¢‘ç¹åœ°ä»ç¡¬ç›˜ä¸­è¯»å–ç›®å½•é¡¹ä¿¡æ¯ï¼‰ã€‚ä¾‹å¦‚ã€‚æˆ‘ä»¬ç»å¸¸éœ€è¦ç¼–è¾‘æ–‡ä»¶ï¼Œéšåè¿›è¡Œç¼–è¯‘æˆ–ç¼–è¾‘ï¼Œç„¶åæ‰“å°æˆ–æ‹·è´ï¼Œå†è¿›è¡Œç¼–è¾‘ï¼Œè¯¸å¦‚æ­¤ç±»çš„æƒ…å†µä¸­ï¼ŒåŒä¸€ä¸ªæ–‡ä»¶éœ€è¦è¢«åå¤è®¿é—®ã€‚ ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜ç”±ä¸¤ç§ç±»å‹çš„æ•°æ®ç»“æ„ç»„æˆï¼š å¤„äºæ­£åœ¨ä½¿ç”¨ï¼Œæœªä½¿ç”¨æˆ–è´ŸçŠ¶æ€çš„ç›®å½•é¡¹å¯¹è±¡çš„é›†åˆã€‚ ä¸€ä¸ªæ•£åˆ—è¡¨ï¼Œä»ä¸­èƒ½å¤Ÿå¿«é€Ÿè·å–ä¸ç»™å®šæ–‡ä»¶åå’Œç›®å½•åå¯¹åº”çš„ç›®å½•é¡¹å¯¹è±¡ï¼Œå¦‚æœè®¿é—®çš„å¯¹è±¡ä¸åœ¨ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜ä¸­ï¼Œæ•£åˆ—å‡½æ•°è¿”å›ä¸€ä¸ªç©ºå€¼ã€‚ ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜çš„ä½œç”¨ä¹Ÿç›¸å½“äºç´¢å¼•èŠ‚ç‚¹é«˜é€Ÿç¼“å­˜ï¼ˆinode cacheï¼‰çš„æ§åˆ¶å™¨ã€‚å†…æ ¸å†…å­˜ä¸­ï¼Œä¸æœªä½¿ç”¨ç›®å½•é¡¹ç›¸å…³çš„ç´¢å¼•èŠ‚ç‚¹æœªè¢«ä¸¢å¼ƒï¼Œè¿™æ˜¯ç”±äºç›®å½•é¡¹é«˜é€Ÿç¼“å­˜ä»åœ¨ä½¿ç”¨ä»–ä»¬ï¼Œå› æ­¤ï¼Œå®ƒä»¬çš„i_countåŸŸä¸ä¸ºç©ºã€‚å› æ­¤ï¼Œè¿™äº›ç´¢å¼•èŠ‚ç‚¹å¯¹è±¡ä¿å­˜åœ¨RAMä¸­ï¼Œå¹¶èƒ½å¤Ÿå€ŸåŠ©ç›¸åº”çš„ç›®å½•é¡¹å¿«é€Ÿå¼•ç”¨ä»–ä»¬ã€‚ æ‰€æœ‰â€œæœªä½¿ç”¨unusedâ€çš„ç›®å½•é¡¹éƒ½å­˜æ”¾åœ¨ä¸€ä¸ªâ€œæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼ˆLRUï¼šLeast Recently Usedï¼‰â€çš„åŒå‘é“¾è¡¨ä¸­ï¼Œè¯¥é“¾è¡¨æŒ‰ç…§æ’å…¥çš„æ—¶é—´æ’åºã€‚æ¢å¥è¯è¯´ï¼Œæœ€åé‡Šæ”¾çš„ç›®å½•é¡¹å¯¹è±¡æ”¾åœ¨é“¾è¡¨çš„é¦–éƒ¨ï¼Œæ‰€ä»¥æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„ç›®å½•é¡¹æ€»æ˜¯é è¿‘é“¾è¡¨çš„å°¾éƒ¨ã€‚ä¸€æ—¦ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜çš„ç©ºé—´å¼€å§‹å˜å°ï¼Œå†…æ ¸å°±ä»é“¾è¡¨çš„å°¾éƒ¨åˆ é™¤å…ƒç´ ï¼Œä½¿å¾—å¤šæ•°æœ€è¿‘ç»å¸¸ä½¿ç”¨çš„å¯¹è±¡å¾—ä»¥ä¿ç•™ã€‚LRUé“¾è¡¨çš„é¦–å…ƒç´ å’Œå°¾å…ƒç´ çš„åœ°å€å­˜æ”¾åœ¨å˜é‡dentry_unusedä¸­çš„nextåŸŸå’ŒprevåŸŸã€‚ç›®å½•é¡¹å¯¹è±¡çš„d_lcuåŸŸåŒ…å«çš„æŒ‡é’ˆæŒ‡å‘è¯¥é“¾è¡¨ä¸­ç›¸é‚»ç›®å½•çš„å¯¹è±¡ã€‚ æ¯ä¸ªâ€œæ­£åœ¨ä½¿ç”¨inuseâ€çš„ç›®å½•é¡¹å¯¹è±¡éƒ½è¢«æ’å…¥ä¸€ä¸ªåŒå‘é“¾è¡¨ä¸­ï¼Œè¯¥é“¾è¡¨ç”±ç›¸åº”ç´¢å¼•èŠ‚ç‚¹å¯¹è±¡çš„i_dentryåŸŸæ‰€æŒ‡å‘ï¼ˆç”±äºæ¯ä¸ªç´¢å¼•èŠ‚ç‚¹å¯èƒ½ä¸è‹¥å¹²ç¡¬é“¾æ¥å…³è”ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªé“¾è¡¨ï¼‰ã€‚ç›®å½•é¡¹å¯¹è±¡çš„d_aliasåŸŸå­˜æ”¾é“¾è¡¨ä¸­ç›¸é‚»å…ƒç´ çš„åœ°å€ã€‚è¿™ä¸¤ä¸ªåŸŸçš„ç±»å‹éƒ½æ˜¯struct list_headã€‚ å½“æŒ‡å‘ç›¸åº”æ–‡ä»¶çš„æœ€åä¸€ä¸ªç¡¬é“¾æ¥è¢«åˆ é™¤åï¼Œä¸€ä¸ªâ€œæ­£åœ¨ä½¿ç”¨inuseâ€çš„ç›®å½•é¡¹å¯¹è±¡å¯èƒ½å˜æˆâ€œè´Ÿnegativeâ€çŠ¶æ€ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¯¥ç›®å½•é¡¹å¯¹è±¡è¢«ç§»åˆ°â€œæœªä½¿ç”¨unusedâ€ç›®å½•é¡¹å¯¹è±¡ç»„æˆçš„LRUé“¾è¡¨ä¸­ã€‚æ¯å½“å†…æ ¸ç¼©å‡ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜æ—¶ï¼Œâ€œè´Ÿnegativeâ€çŠ¶æ€ç›®å½•é¡¹å¯¹è±¡å°±æœç€LRUé“¾è¡¨çš„å°¾éƒ¨ç§»åŠ¨ã€‚è¿™æ ·ä¸€æ¥ï¼Œè¿™äº›å¯¹è±¡å°±é€æ¸è¢«é‡Šæ”¾ã€‚ æ•£åˆ—è¡¨æ˜¯ç”±dentry_hashtableæ•°ç»„å®ç°çš„ã€‚æ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆï¼Œè¿™ç§é“¾è¡¨å°±æ˜¯æŠŠå…·æœ‰ç›¸åŒæ•£åˆ—è¡¨å€¼å¾—ç›®å½•é¡¹è¿›è¡Œæ•£åˆ—è€Œå½¢æˆå¾—ã€‚è¯¥æ•°ç»„å¾—é•¿åº¦å–å†³äºç³»ç»Ÿå·²å®‰è£…RAMçš„æ•°é‡ã€‚ç›®å½•é¡¹å¯¹è±¡çš„d_hashåŸŸåŒ…å«æŒ‡å‘å…·æœ‰ç›¸åŒæ•£åˆ—å€¼çš„é“¾è¡¨ä¸­çš„ç›¸é‚»å…ƒç´ ã€‚æ•£åˆ—å‡½æ•°äº§ç”Ÿçš„å€¼æ˜¯ç”±ç›®å½•åŠæ–‡ä»¶åçš„ç›®å½•é¡¹å¯¹è±¡çš„åœ°å€è®¡ç®—å‡ºæ¥çš„ã€‚ å—é«˜é€Ÿç¼“å­˜ åŠ å¿«æ–‡ä»¶ç³»ç»Ÿæ“ä½œé€Ÿåº¦çš„ç¼“å­˜æœºåˆ¶ï¼ˆå†…å­˜ç¼“å­˜ï¼Œä¿å­˜æ–‡ä»¶ç³»ç»Ÿä¸­å·²ç»è¯»å–è¿‡çš„å—æ•°æ®blockï¼Œæœ‰æ•ˆé¿å…é¢‘ç¹ä»ç¡¬ç›˜è¯»å–æ•°æ®ï¼‰ã€‚å—é«˜é€Ÿç¼“å­˜åªé€‚ç”¨äºæ•°æ®è¿›è¡Œé¡ºåºè®¿é—®çš„æƒ…å†µï¼Œå¦‚æœå¯¹æ•°æ®è¿›è¡Œéšæœºè®¿é—®ï¼Œå¯¼è‡´å¤§é‡æ— æ•ˆçš„ç¼“å­˜å‘½ä¸­å’Œæœªå‘½ä¸­åè€Œé™ä½æ€§èƒ½ã€‚ Extæ ¼å¼å’Œç›®å½•å­˜å‚¨ä»¥åŠæ–‡ä»¶ç¼“å­˜ Extæ–‡ä»¶ç³»ç»Ÿï¼šåŸºäºç£ç›˜çš„æ–‡ä»¶ç³»ç»Ÿï¼Œæ”¯æŒå¤šä¸ªç£ç›˜åˆ†åŒºå’Œè¶…è¿‡2TBçš„å¤§å®¹é‡ç£ç›˜ï¼Œä¸»è¦ç‰ˆæœ¬ï¼šEx2&#x2F;Ex3&#x2F;Ex4 ç›®å½•å­˜å‚¨ï¼šæŒ‡åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­ç”¨äºç»„ç»‡å’Œå­˜å‚¨æ–‡ä»¶çš„ä¸€ç§å±‚æ¬¡ç»“æ„ã€‚åœ¨Linuxç³»ç»Ÿå½“ä¸­ï¼Œæ‰€æœ‰çš„æ–‡ä»¶éƒ½å­˜æ”¾åœ¨æ ¹ç›®å½•ï¼ˆ&#x2F;ï¼‰ä¸‹æˆ–å…¶å­ç›®å½•ä¸‹ ï¼Œè€Œè¿™äº›ç›®å½•åˆ™ä»¥ç‰¹å®šæ–¹å¼ç»„ç»‡èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªå±‚æ¬¡åŒ–çš„ç›®å½•ç»“æ„ï¼ŒLinuxæ–‡ä»¶ç³»ç»Ÿé‡‡ç”¨æ ‘å½¢ç»“æ„ç»„ç»‡æ–‡ä»¶å’Œç›®å½•ã€‚ 12345/bin å¯æ‰§è¡ŒäºŒè¿›åˆ¶æ–‡ä»¶/dev è®¾å¤‡æ–‡ä»¶/etc é…ç½®æ–‡ä»¶/lib åº“æ–‡ä»¶/tmp ä¸´æ—¶æ–‡ä»¶ æ–‡ä»¶ç¼“å­˜ï¼š ç³»ç»Ÿå°†ç¡¬ç›˜ä¸Šçš„æ–‡ä»¶æš‚æ—¶å­˜åœ¨å†…å­˜å½“ä¸­ä»¥æé«˜è®¿é—®æ•ˆç‡çš„ä¸€ç§æœºåˆ¶ã€‚ æ¯ä¸€ä¸ªinodeç»“æ„ä¸æ–‡ä»¶ç›¸å…³è”æ‰€æœ‰å…ƒæ•°æ®ä¿¡æ¯ï¼ˆåˆ›å»ºäº‹ä»¶ï¼Œæ–‡ä»¶å¤§å°ç­‰)ã€‚ æ¯”å¦‚åœ¨å®é™…åº”ç”¨ï¼šå†™æ“ä½œæ—¶ï¼Œä¹Ÿå¯ä»¥å°†éœ€è¦å†™å…¥ç¡¬ç›˜æ•°æ®æš‚å­˜åˆ°é¡µé«˜é€Ÿç¼“å­˜å½“ä¸­ï¼Œå¹¶å»¶è¿Ÿå®é™…å†™å…¥ç¡¬ç›˜çš„äº‹ä»¶ï¼ˆå»¶è¿Ÿå†™ï¼‰ï¼Œæå‡æ€§èƒ½å’Œå‡å°‘I&#x2F;Oè´Ÿè½½ï¼Œå½“éœ€è¦åˆ·æ–°ç¼“å­˜å¹¶å°†æ•°æ®åŒæ­¥å›åˆ°ç¡¬ç›˜æ—¶ï¼Œç›´æ¥è°ƒç”¨sync&#x2F;fsncå‡½æ•°æ¥å®Œæˆã€‚ mount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; // ç”¨äºæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨çš„é“¾è¡¨èŠ‚ç‚¹ struct mount *mnt_parent; // æŒ‡å‘çˆ¶æŒ‚è½½ç‚¹çš„æŒ‡é’ˆ struct dentry *mnt_mountpoint; // æŒ‡å‘æŒ‚è½½ç‚¹ä½ç½®çš„ç›®å½•å…¥å£ï¼ˆdentryï¼‰ struct vfsmount mnt; // åŒ…å«æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿç›¸å…³ä¿¡æ¯çš„vfsmountç»“æ„ä½“ union &#123; struct rcu_head mnt_rcu; // ç”¨äºRCUï¼ˆRead-Copy-Updateï¼‰åŒæ­¥çš„é“¾è¡¨å¤´ struct llist_node mnt_llist; // ç”¨äºå»¶è¿Ÿåˆ—è¡¨ï¼ˆllistï¼‰çš„é“¾è¡¨èŠ‚ç‚¹ &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp; // æŒ‡å‘æ¯ä¸ªCPUçš„mnt_pcpç»“æ„ä½“çš„æŒ‡é’ˆï¼ˆä»…åœ¨å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­ä½¿ç”¨ï¼‰#else int mnt_count; // æŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•° int mnt_writers; // å†™å…¥æ“ä½œçš„è®¡æ•°å™¨#endif struct list_head mnt_mounts; // å­æŒ‚è½½ç‚¹åˆ—è¡¨çš„é“¾è¡¨å¤´ struct list_head mnt_child; // ä¸mnt_mountsé“¾è¡¨ç›¸è¿çš„é“¾è¡¨èŠ‚ç‚¹ struct list_head mnt_instance; // è¶…çº§å—çš„s_mountsé“¾è¡¨ä¸Šçš„æŒ‚è½½å®ä¾‹åˆ—è¡¨èŠ‚ç‚¹ const char *mnt_devname; // è®¾å¤‡åç§°ï¼Œå¦‚ /dev/dsk/hda1 struct list_head mnt_list; // å…¨å±€æŒ‚è½½ç‚¹åˆ—è¡¨çš„é“¾è¡¨èŠ‚ç‚¹ struct list_head mnt_expire; // ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„è¿‡æœŸåˆ—è¡¨çš„é“¾è¡¨èŠ‚ç‚¹ struct list_head mnt_share; // å…±äº«æŒ‚è½½ç‚¹çš„å¾ªç¯åˆ—è¡¨é“¾è¡¨å¤´ struct list_head mnt_slave_list; // ä»å±æŒ‚è½½ç‚¹çš„é“¾è¡¨å¤´ struct list_head mnt_slave; // ä¸mnt_slave_listé“¾è¡¨ç›¸è¿çš„é“¾è¡¨èŠ‚ç‚¹ struct mount *mnt_master; // æŒ‡å‘ä¸»æŒ‚è½½ç‚¹çš„æŒ‡é’ˆï¼Œä»å±æŒ‚è½½ç‚¹ä½äºmaster-&gt;mnt_slave_list struct mnt_namespace *mnt_ns; // åŒ…å«æ­¤æŒ‚è½½ç‚¹çš„å‘½åç©ºé—´ struct mountpoint *mnt_mp; // æŒ‡å‘æŒ‚è½½ç‚¹ä½ç½®çš„mountpointç»“æ„ä½“ union &#123; struct hlist_node mnt_mp_list; // å…·æœ‰ç›¸åŒæŒ‚è½½ç‚¹çš„æŒ‚è½½åˆ—è¡¨é“¾è¡¨èŠ‚ç‚¹ struct hlist_node mnt_umount; // ç”¨äºå¸è½½æ“ä½œçš„é“¾è¡¨èŠ‚ç‚¹ &#125;; struct list_head mnt_umounting; // ç”¨äºå¸è½½ä¼ æ’­çš„é“¾è¡¨èŠ‚ç‚¹#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; // æŒ‡å‘æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥æ ‡è®°çš„æŒ‡é’ˆ __u32 mnt_fsnotify_mask; // æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥çš„æ©ç #endif int mnt_id; // æŒ‚è½½ç‚¹çš„å”¯ä¸€æ ‡è¯†ç¬¦ int mnt_group_id; // åŒçº§æŒ‚è½½ç»„çš„å”¯ä¸€æ ‡è¯†ç¬¦ int mnt_expiry_mark; // å¦‚æœå·²æ ‡è®°ä¸ºè¿‡æœŸï¼Œåˆ™ä¸ºtrue struct hlist_head mnt_pins; // ç”¨äºè®°å½•æŒ‚è½½ç‚¹å¼•è„šçš„é“¾è¡¨å¤´ struct hlist_head mnt_stuck_children; // è¢«å¡ä½çš„å­æŒ‚è½½ç‚¹åˆ—è¡¨çš„é“¾è¡¨å¤´&#125; __randomize_layout; // ä½¿ç”¨å†…æ ¸çš„åœ°å€ç©ºé—´å¸ƒå±€éšæœºåŒ–ï¼ˆKASLRï¼‰ç‰¹æ€§ï¼Œä»¥å¢åŠ å®‰å…¨æ€§ æ–‡ä»¶ç³»ç»Ÿæ•°æ®ç»“æ„file_system_typefile_system_type identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct file_system_type &#123; const char *name; // æ–‡ä»¶ç³»ç»Ÿçš„åç§°ï¼Œå¦‚â€œext2â€ã€â€œiso9660â€ã€â€œmsdosâ€ç­‰ int fs_flags; // æ–‡ä»¶ç³»ç»Ÿçš„æ ‡è¯†ä½ï¼Œå„ç§æ ‡å¿—ï¼ˆå³FS_REQUIRES_DEVã€FS_NO_DCACHEç­‰ï¼‰ // æ–‡ä»¶ç³»ç»Ÿæ ‡è¯†ä½çš„å®šä¹‰#define FS_REQUIRES_DEV 1 // æ–‡ä»¶ç³»ç»Ÿéœ€è¦ä¸€ä¸ªè®¾å¤‡#define FS_BINARY_MOUNTDATA 2 // æ–‡ä»¶ç³»ç»Ÿçš„æŒ‚è½½æ•°æ®æ˜¯äºŒè¿›åˆ¶æ ¼å¼#define FS_HAS_SUBTYPE 4 // æ–‡ä»¶ç³»ç»Ÿå…·æœ‰å­ç±»å‹#define FS_USERNS_MOUNT 8 // å¯ä»¥ç”±ç”¨æˆ·å‘½åç©ºé—´çš„æ ¹ç›®å½•æŒ‚è½½#define FS_DISALLOW_NOTIFY_PERM 16 // ç¦æ­¢ fanotify æƒé™äº‹ä»¶#define FS_ALLOW_IDMAP 32 // æ–‡ä»¶ç³»ç»Ÿå·²æ›´æ–°ä»¥å¤„ç† VFS ID æ˜ å°„#define FS_RENAME_DOES_D_MOVE 32768 // åœ¨ rename() æœŸé—´ï¼Œæ–‡ä»¶ç³»ç»Ÿå°†å†…éƒ¨å¤„ç† d_move() int (*init_fs_context)(struct fs_context *); // åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„å‡½æ•°æŒ‡é’ˆï¼Œä½¿ç”¨ç‰¹å®šäºæ–‡ä»¶ç³»ç»Ÿçš„æ•°æ®åˆå§‹åŒ–â€œstruct fs_contextâ€-&gt;ops å’Œ -&gt;fs_private å­—æ®µã€‚ const struct fs_parameter_spec *parameters; // æ–‡ä»¶ç³»ç»Ÿå‚æ•°çš„æŒ‡é’ˆï¼ŒæŒ‡å‘æ–‡ä»¶ç³»ç»Ÿå‚æ•°æè¿°ç¬¦â€œstruct fs_parameter_specâ€æ•°ç»„çš„æŒ‡é’ˆã€‚ // æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿçš„å‡½æ•°æŒ‡é’ˆ struct dentry *(*mount) (struct file_system_type *, int, const char *, void *);//æŒ‚è½½æ­¤æ–‡ä»¶ç³»ç»Ÿçš„æ–°å®ä¾‹æ—¶è°ƒç”¨çš„æ–¹æ³•// mountï¼ˆï¼‰ æ–¹æ³•å…·æœ‰ä»¥ä¸‹å‚æ•°ï¼š//struct file_system_type *fs_type//æè¿°æ–‡ä»¶ç³»ç»Ÿï¼Œéƒ¨åˆ†ç”±ç‰¹å®šçš„æ–‡ä»¶ç³»ç»Ÿä»£ç åˆå§‹åŒ–//int flags//æŒ‚è½½æ ‡å¿—//const char *dev_name//æˆ‘ä»¬æ­£åœ¨å®‰è£…çš„è®¾å¤‡åç§°ã€‚//void *data//ä»»æ„æŒ‚è½½é€‰é¡¹ï¼Œé€šå¸¸ä»¥ ASCII å­—ç¬¦ä¸²å½¢å¼æä¾›ï¼ˆè¯·å‚é˜…â€œæŒ‚è½½é€‰é¡¹â€éƒ¨åˆ†ï¼‰ void (*kill_sb) (struct super_block *); // é”€æ¯è¶…çº§å—çš„å‡½æ•°æŒ‡é’ˆ struct module *owner; // æŒ‡å‘æ–‡ä»¶ç³»ç»Ÿæ‰€å±æ¨¡å—çš„æŒ‡é’ˆ struct file_system_type * next; // æŒ‡å‘ä¸‹ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿç±»å‹çš„æŒ‡é’ˆ struct hlist_head fs_supers; // ç”¨äºå­˜æ”¾æ–‡ä»¶ç³»ç»Ÿè¶…çº§å—çš„å“ˆå¸Œé“¾è¡¨å¤´ // ä»¥ä¸‹ä¸ºå„ç§é”çš„å®šä¹‰ struct lock_class_key s_lock_key; // è¶…çº§å—é”çš„é”® struct lock_class_key s_umount_key; // å¸è½½é”çš„é”® struct lock_class_key s_vfs_rename_key; // VFS é‡å‘½åé”çš„é”® struct lock_class_key s_writers_key[SB_FREEZE_LEVELS]; // å†™å…¥è€…é”çš„é”®æ•°ç»„ struct lock_class_key i_lock_key; // inode é”çš„é”® struct lock_class_key i_mutex_key; // inode äº’æ–¥é‡çš„é”® struct lock_class_key invalidate_lock_key; // ä½¿ inode æ— æ•ˆçš„é”çš„é”® struct lock_class_key i_mutex_dir_key; // ç›®å½• inode äº’æ–¥é‡çš„é”®&#125;; mount()æ–¹æ³•å¿…é¡»è¿”å›è°ƒç”¨è€…è¯·æ±‚æ ‘çš„æ ¹ç›®å½•ï¼Œå¿…é¡»æŠ“å–å¯¹å…¶è¶…çº§å—çš„æ´»åŠ¨å¼•ç”¨ï¼Œå¹¶ä¸”å¿…é¡»é”å®šè¶…çº§å—ã€‚å¤±è´¥æ—¶ï¼Œå®ƒåº”è¿”å› ERR_PTRï¼ˆerrorï¼‰ã€‚ è¿™äº›å‚æ•°ä¸ mountï¼ˆ2ï¼‰ çš„å‚æ•°ç›¸åŒ¹é…ï¼Œå®ƒä»¬çš„è§£é‡Šå–å†³äºæ–‡ä»¶ç³»ç»Ÿç±»å‹ã€‚ä¾‹å¦‚,å¯¹äºå—æ–‡ä»¶ç³»ç»Ÿï¼Œdev_nameè¢«è§£é‡Šä¸ºå—è®¾å¤‡åç§°ï¼Œè¯¥è®¾å¤‡è¢«æ‰“å¼€ï¼Œå¦‚æœå®ƒåŒ…å«åˆé€‚çš„æ–‡ä»¶ç³»ç»Ÿæ˜ åƒï¼Œè¯¥æ–¹æ³•ä¼šç›¸åº”åœ°åˆ›å»ºå¹¶åˆå§‹åŒ–ç»“æ„super_blockï¼Œå°†å…¶æ ¹æ¡ç›®è¿”å›ç»™è°ƒç”¨æ–¹ã€‚ -&gt;mountï¼ˆï¼‰ å¯ä»¥é€‰æ‹©è¿”å›ç°æœ‰æ–‡ä»¶ç³»ç»Ÿçš„å­æ ‘ - å®ƒä¸å¿…åˆ›å»ºä¸€ä¸ªæ–°çš„å­æ ‘ã€‚ä»è°ƒç”¨è€…çš„è§’åº¦æ¥çœ‹ï¼Œä¸»è¦ç»“æœæ˜¯å¼•ç”¨è¦é™„åŠ çš„ï¼ˆå­ï¼‰æ ‘æ ¹çš„ dentry;åˆ›å»ºæ–°çš„è¶…çº§å—æ˜¯ä¸€ç§å¸¸è§çš„å‰¯ä½œç”¨ã€‚ mountï¼ˆï¼‰ æ–¹æ³•å¡«å……çš„è¶…å—ç»“æ„ä¸­æœ€æœ‰è¶£çš„æˆå‘˜æ˜¯ â€œs_opâ€ å­—æ®µã€‚è¿™æ˜¯ä¸€ä¸ªæŒ‡å‘â€œç»“æ„super_operationsâ€çš„æŒ‡é’ˆï¼Œå®ƒæè¿°äº†æ–‡ä»¶ç³»ç»Ÿå®ç°çš„ä¸‹ä¸€ä¸ªçº§åˆ«ã€‚ é€šå¸¸ï¼Œæ–‡ä»¶ç³»ç»Ÿä½¿ç”¨é€šç”¨ mountï¼ˆï¼‰ å®ç°ä¹‹ä¸€ï¼Œå¹¶æä¾› fill_superï¼ˆï¼‰ å›è°ƒã€‚é€šç”¨å˜ä½“æ˜¯ï¼š mount_bdev æŒ‚è½½é©»ç•™åœ¨å—è®¾å¤‡ä¸Šçš„æ–‡ä»¶ç³»ç»Ÿ mount_nodev æŒ‚è½½ä¸å—è®¾å¤‡æ”¯æŒçš„æ–‡ä»¶ç³»ç»Ÿ mount_single æŒ‚è½½ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Œè¯¥æ–‡ä»¶ç³»ç»Ÿåœ¨æ‰€æœ‰æŒ‚è½½ä¹‹é—´å…±äº«å®ä¾‹ fill_superï¼ˆï¼‰ å›è°ƒå®ç°å…·æœ‰ä»¥ä¸‹å‚æ•°ï¼š struct super_block *sb è¶…çº§å—ç»“æ„ï¼Œå›è°ƒå¿…é¡»æ­£ç¡®åˆå§‹åŒ–å®ƒã€‚ void *data ä»»æ„æŒ‚è½½é€‰é¡¹ï¼Œé€šå¸¸ä»¥ ASCII å­—ç¬¦ä¸²å½¢å¼æä¾› int silent æ˜¯å¦å¯¹é”™è¯¯ä¿æŒæ²‰é»˜ file_system_typeç”¨æ¥æè¿°å„ç§ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿç±»å‹ã€‚æ¯ç§æ–‡ä»¶ç³»ç»Ÿï¼Œä¸ç®¡æœ‰å¤šå°‘ä¸ªå®ä¾‹å®‰è£…åˆ°ç³»ç»Ÿä¸­ï¼Œè¿˜æ˜¯æ ¹æœ¬æ²¡æœ‰å®‰è£…åˆ°ç³»ç»Ÿä¸­ï¼Œéƒ½åªæœ‰ä¸€ä¸ªfile_systemç»“æ„ã€‚ nameä¿å­˜äº†æ–‡ä»¶ç³»ç»Ÿçš„åç§°ï¼Œæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆå› æ­¤åŒ…å«äº†ä¾‹å¦‚reiserfsã€ext3ç­‰ç±»ä¼¼çš„å€¼ï¼‰ã€‚fs_flagsæ˜¯ä½¿ç”¨çš„æ ‡å¿—ï¼Œä¾‹å¦‚æ ‡æ˜åªè¯»è£…è½½ã€ç¦æ­¢setuid&#x2F;setgidæ“ä½œæˆ–è¿›è¡Œå…¶ä»–çš„å¾®è°ƒã€‚owneræ˜¯ä¸€ä¸ªæŒ‡å‘moduleç»“æ„çš„æŒ‡é’ˆï¼Œä»…å½“æ–‡ä»¶ç³»ç»Ÿä»¥æ¨¡å—å½¢å¼åŠ è½½æ—¶ï¼Œowneræ‰åŒ…å«æœ‰æ„ä¹‰çš„å€¼ï¼ˆNULLæŒ‡é’ˆè¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿå·²ç»æŒä¹…ç¼–è¯‘åˆ°å†…æ ¸ä¸­ï¼‰ã€‚å„ä¸ªå¯ç”¨çš„æ–‡ä»¶ç³»ç»Ÿé€šè¿‡nextæˆå‘˜è¿æ¥èµ·æ¥ï¼Œè¿™é‡Œæ— æ³•åˆ©ç”¨æ ‡å‡†çš„é“¾è¡¨åŠŸèƒ½ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªå•é“¾è¡¨ã€‚ mountmount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; struct mount *mnt_parent; struct dentry *mnt_mountpoint; struct vfsmount mnt; union &#123; struct rcu_head mnt_rcu; struct llist_node mnt_llist; &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp;#else int mnt_count; int mnt_writers;#endif struct list_head mnt_mounts; /* list of children, anchored here */ struct list_head mnt_child; /* and going through their mnt_child */ struct list_head mnt_instance; /* mount instance on sb-&gt;s_mounts */ const char *mnt_devname; /* Name of device e.g. /dev/dsk/hda1 */ struct list_head mnt_list; struct list_head mnt_expire; /* link in fs-specific expiry list */ struct list_head mnt_share; /* circular list of shared mounts */ struct list_head mnt_slave_list;/* list of slave mounts */ struct list_head mnt_slave; /* slave list entry */ struct mount *mnt_master; /* slave is on master-&gt;mnt_slave_list */ struct mnt_namespace *mnt_ns; /* containing namespace */ struct mountpoint *mnt_mp; /* where is it mounted */ union &#123; struct hlist_node mnt_mp_list; /* list mounts with the same mountpoint */ struct hlist_node mnt_umount; &#125;; struct list_head mnt_umounting; /* list entry for umount propagation */#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; __u32 mnt_fsnotify_mask;#endif int mnt_id; /* mount identifier */ int mnt_group_id; /* peer group identifier */ int mnt_expiry_mark; /* true if marked for expiry */ struct hlist_head mnt_pins; struct hlist_head mnt_stuck_children;&#125; __randomize_layout; vfsmountvfsmount identifier - Linux source code (v6.3.8) - Bootlin 123456struct vfsmount &#123; struct dentry *mnt_root; // æŒ‡å‘å·²æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿæ ‘çš„æ ¹ç›®å½•å…¥å£ï¼ˆdentryç»“æ„ä½“ï¼‰ struct super_block *mnt_sb; // æŒ‡å‘ä¸å·²æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿå…³è”çš„è¶…çº§å—ï¼ˆsuper_blockç»“æ„ä½“ï¼‰ int mnt_flags; // æŒ‚è½½æ ‡å¿—ï¼Œè¡¨ç¤ºæŒ‚è½½æ—¶çš„é€‰é¡¹ï¼Œå¦‚åªè¯»ã€å¼‚æ­¥ç­‰ struct mnt_idmap *mnt_idmap; // æŒ‡å‘ä¸€ä¸ªmnt_idmapç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨ç”¨æˆ·å’Œç»„IDçš„æ˜ å°„å…³ç³»ï¼ˆä»…åœ¨æŸäº›æ–‡ä»¶ç³»ç»Ÿä¸­ä½¿ç”¨ï¼Œå¦‚NFSï¼‰&#125; __randomize_layout; // ä½¿ç”¨å†…æ ¸çš„åœ°å€ç©ºé—´å¸ƒå±€éšæœºåŒ–ï¼ˆKASLRï¼‰ç‰¹æ€§ï¼Œä»¥å¢åŠ å®‰å…¨æ€§ å½“æ–‡ä»¶ç³»ç»Ÿè¢«å®é™…å®‰è£…åˆ°ç³»ç»Ÿä¸­ï¼Œå°†æœ‰ä¸€ä¸ªvfsmountç»“æ„ä½“åœ¨å®‰è£…ç‚¹è¢«åˆ›å»ºï¼Œè¯¥ç»“æ„ä½“ç”¨æ¥ä»£è¡¨æ–‡ä»¶ç³»ç»Ÿçš„å®ä¾‹-æ¢å¥è¯è¯´ï¼Œä»£è¡¨ä¸€ä¸ªå®‰è£…ç‚¹ã€‚ç†æ¸…æ–‡ä»¶ç³»ç»Ÿå’Œæ‰€æœ‰å…¶ä»–å®‰è£…ç‚¹ä¹‹é—´çš„å…³ç³»ï¼Œæ˜¯ç»´æŠ¤æ‰€æœ‰å®‰è£…ç‚¹é“¾è¡¨ä¸­æœ€å¤æ‚çš„å·¥ä½œã€‚æ‰€ä»¥vfsmountç»“æ„ä½“ä¸­ç»´æŠ¤çš„å„ç§é“¾è¡¨å°±æ˜¯ä¸ºäº†èƒ½å¤Ÿè·Ÿè¸ªè¿™äº›å…³è”ä¿¡æ¯ã€‚æ–‡ä»¶ç³»ç»Ÿæœ¬èº«çš„ç›¸å¯¹æ ¹ç›®å½•æ‰€å¯¹åº”çš„dentryä¿å­˜åœ¨mnt_rootä¸­ã€‚mnt_sbæŒ‡é’ˆå»ºç«‹äº†ä¸ç›¸å…³çš„è¶…çº§å—ä¹‹é—´çš„å…³è”ï¼ˆå¯¹æ¯ä¸ªè£…è½½çš„æ–‡ä»¶ç³»ç»Ÿè€Œè¨€ï¼Œéƒ½æœ‰ä¸”åªæœ‰ä¸€ä¸ªè¶…çº§å—å®ä¾‹ï¼‰ã€‚åœ¨nmt_flagså¯ä»¥è®¾ç½®å„ç§ç‹¬ç«‹äºæ–‡ä»¶ç³»ç»Ÿçš„æ ‡å¿—ã€‚ mountpointmountpoint identifier - Linux source code (v6.3.8) - Bootlin 123456struct mountpoint &#123; struct hlist_node m_hash; struct dentry *m_dentry; struct hlist_head m_list; int m_count;&#125;; vfså‘½åç©ºé—´VFSå‘½åç©ºé—´æ˜¯æ‰€æœ‰å·²ç»è£…è½½ã€æ„æˆæŸä¸ªå®¹å™¨ç›®å½•æ ‘çš„æ–‡ä»¶ç³»ç»Ÿçš„é›†åˆã€‚ é€šå¸¸è°ƒç”¨forkæˆ–cloneå»ºç«‹çš„è¿›ç¨‹ä¼šç»§æ‰¿å…¶çˆ¶è¿›ç¨‹çš„å‘½åç©ºé—´ã€‚ä½†å¯ä»¥è®¾ç½®CLONE_NEWNSæ ‡å¿—ï¼Œä»¥å»ºç«‹ä¸€ä¸ªæ–°çš„VFSå‘½åç©ºé—´ï¼ˆåœ¨ä¸‹æ–‡ä¸­ï¼Œæˆ‘ä¸å†åŒºåˆ†VFSå‘½åç©ºé—´å’Œå‘½åç©ºé—´ï¼Œå½“ç„¶å†…æ ¸ä¹Ÿæä¾›äº†éVFSçš„å‘½åç©ºé—´ã€‚å¦‚æœä¿®æ”¹æ–°çš„å‘½åç©ºé—´ï¼Œæ”¹å˜ä¸ä¼šä¼ æ’­åˆ°å±äºä¸åŒå‘½åç©ºé—´çš„è¿›ç¨‹ã€‚å¯¹å…¶ä»–å‘½åç©ºé—´çš„æ”¹å˜ä¹Ÿä¸ä¼šå½±å“æ–°çš„å‘½åç©ºé—´ã€‚ struct task_structåŒ…å«çš„æˆå‘˜nsproxyï¼Œè¯¥æˆå‘˜è´Ÿè´£å‘½åç©ºé—´çš„å¤„ç†ã€‚ nsproxy identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627/* * ä¸€ä¸ªç»“æ„ä½“,åŒ…å«æŒ‡å‘æ¯ä¸ªè¿›ç¨‹å‘½åç©ºé—´çš„æŒ‡é’ˆ * - fs(æŒ‚è½½),uts,ç½‘ç»œ,sysvipc ç­‰ã€‚ * * pid å‘½åç©ºé—´æ˜¯ä¸€ä¸ªä¾‹å¤– - å®ƒé€šè¿‡ task_active_pid_ns è®¿é—®ã€‚ * è¿™é‡Œçš„ pid å‘½åç©ºé—´æ˜¯å­è¿›ç¨‹å°†ä½¿ç”¨çš„å‘½åç©ºé—´ã€‚ * * &#x27;count&#x27; æ˜¯æŒæœ‰å¼•ç”¨çš„ä»»åŠ¡æ•°ã€‚ * å› æ­¤,æ¯ä¸ªå‘½åç©ºé—´çš„è®¡æ•°å°†æ˜¯æŒ‡å‘å®ƒçš„ nsproxy æ•°,è€Œä¸æ˜¯ä»»åŠ¡æ•°ã€‚ * * nsproxy ç”±å…±äº«æ‰€æœ‰å‘½åç©ºé—´çš„ä»»åŠ¡å…±äº«ã€‚ * ä¸€æ—¦å•ä¸ªå‘½åç©ºé—´è¢«å…‹éš†æˆ–å–æ¶ˆå…±äº«,nsproxy å°±ä¼šè¢«å¤åˆ¶ã€‚ */ struct nsproxy &#123; atomic_t count; /*åŸå­è®¡æ•°å™¨*/ struct uts_namespace *uts_ns; /*UTSå‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/ struct ipc_namespace *ipc_ns; /*IPCå‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/ struct mnt_namespace *mnt_ns; /*æŒ‚è½½å‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/ struct pid_namespace *pid_ns_for_children; /*å­è¿›ç¨‹ä½¿ç”¨çš„PIDå‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/ struct net *net_ns; /*ç½‘ç»œå‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/ struct time_namespace *time_ns; /*æ—¶é—´å‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/ struct time_namespace *time_ns_for_children; /*å­è¿›ç¨‹ä½¿ç”¨çš„æ—¶é—´å‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/ struct cgroup_namespace *cgroup_ns; /*cgroupå‘½åç©ºé—´ç»“æ„ä½“æŒ‡é’ˆ*/&#125;;extern struct nsproxy init_nsproxy; /*å¤–éƒ¨å˜é‡:åˆå§‹çš„nsproxy*/ å®ç°VFSå‘½åç©ºé—´æ‰€éœ€ä¿¡æ¯çš„æ•°é‡ç›¸å¯¹å¾ˆå°‘ï¼š mnt_namespace identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718struct mnt_namespace &#123; struct ns_common ns; /*å‘½åç©ºé—´é€šç”¨ç»“æ„*/ struct mount * root; /*æ ¹æŒ‚è½½ç‚¹æŒ‡é’ˆ*/ /* * éå†å’Œä¿®æ”¹ .list æ˜¯é€šè¿‡ä¸¤ç§æ–¹å¼ä¿æŠ¤çš„: * - ä»¥å†™æ–¹å¼è·å–namespace_sem, æˆ–è€… * - ä»¥è¯»æ–¹å¼è·å–namespace_sem AND è·å– .ns_lock. */ struct list_head list; /*é“¾è¡¨å¤´*/ spinlock_t ns_lock; /*è‡ªæ—‹é”*/ struct user_namespace *user_ns; /*ç”¨æˆ·å‘½åç©ºé—´æŒ‡é’ˆ*/ struct ucounts *ucounts; /*å¼•ç”¨è®¡æ•°å™¨*/ u64 seq; /*åºåˆ—å·,ç”¨äºé˜²æ­¢å¾ªç¯*/ wait_queue_head_t poll; /*ç­‰å¾…é˜Ÿåˆ—å¤´*/ u64 event; unsigned int mounts; /*å‘½åç©ºé—´ä¸­çš„æŒ‚è½½æ•°*/ unsigned int pending_mounts; /*å¾…å®šæŒ‚è½½æ•°*/ &#125; __randomize_layout; /*éšæœºå¸ƒå±€*/ è¿›ç¨‹ç›¸å…³æ•°æ®ç»“æ„ç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„ä¸€ç»„æ‰“å¼€çš„æ–‡ä»¶ï¼Œåƒæ ¹æ–‡ä»¶ç³»ç»Ÿï¼Œå½“å‰å·¥ä½œç›®å½•ï¼Œå®‰è£…ç‚¹ç­‰ã€‚æœ‰ä¸‰ä¸ªæ•°æ®ç»“æ„å°†VFSå±‚å’Œç³»ç»Ÿçš„è¿›ç¨‹ç´§å¯†è”ç³»åœ¨ä¸€èµ·ï¼Œå®ƒä»¬åˆ†åˆ«æ˜¯ï¼šfiles_structã€fs_structã€namespaceç»“æ„ä½“ã€‚ æ–‡ä»¶æè¿°ç¬¦ï¼ˆå°±æ˜¯æ•´æ•°ï¼‰ç”¨äºåœ¨ä¸€ä¸ªè¿›ç¨‹å†…å”¯ä¸€åœ°æ ‡è¯†æ‰“å¼€çš„æ–‡ä»¶ã€‚è¿™å‡å®šäº†å†…æ ¸èƒ½å¤Ÿåœ¨ç”¨æˆ·è¿›ç¨‹ä¸­çš„æè¿°ç¬¦å’Œå†…æ ¸å†…éƒ¨ä½¿ç”¨çš„ç»“æ„ä¹‹é—´ï¼Œå»ºç«‹ä¸€ç§å…³è”ã€‚æ¯ä¸ªè¿›ç¨‹çš„task_structä¸­åŒ…å«äº†ç”¨äºå®Œæˆè¯¥å·¥ä½œçš„æˆå‘˜ã€‚ task_structtask_struct identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213struct task_struct &#123;.../* æ–‡ä»¶ç³»ç»Ÿä¿¡æ¯ */int link_count, total_link_count;.../* æ–‡ä»¶ç³»ç»Ÿä¿¡æ¯ */struct fs_struct *fs;/* æ‰“å¼€æ–‡ä»¶ä¿¡æ¯ */struct files_struct *files;/* å‘½åç©ºé—´ */struct nsproxy *nsproxy;...&#125; æ–‡ä»¶æè¿°ç¬¦ï¼ˆå°±æ˜¯æ•´æ•°ï¼‰ç”¨äºåœ¨ä¸€ä¸ªè¿›ç¨‹å†…å”¯ä¸€åœ°æ ‡è¯†æ‰“å¼€çš„æ–‡ä»¶ã€‚è¿™å‡å®šäº†å†…æ ¸èƒ½å¤Ÿåœ¨ç”¨æˆ·è¿›ç¨‹ä¸­çš„æè¿°ç¬¦å’Œå†…æ ¸å†…éƒ¨ä½¿ç”¨çš„ç»“æ„ä¹‹é—´ï¼Œå»ºç«‹ä¸€ç§å…³è”ã€‚æ¯ä¸ªè¿›ç¨‹çš„task_structä¸­åŒ…å«äº†ç”¨äºå®Œæˆè¯¥å·¥ä½œçš„æˆå‘˜ã€‚ è¿›ç¨‹çš„æ–‡ä»¶ç³»ç»Ÿç›¸å…³æ•°æ®ä¿å­˜åœ¨fsä¸­ã€‚è¿™äº›æ•°æ®åŒ…å«ï¼Œä¾‹å¦‚å½“å‰å·¥ä½œç›®å½•å’Œchrooté™åˆ¶æœ‰å…³çš„ä¿¡æ¯ã€‚æ•´æ•°æˆå‘˜link_countå’Œtotal_link_countç”¨äºåœ¨æŸ¥æ‰¾ç¯å½¢é“¾è¡¨æ—¶é˜²æ­¢æ— é™å¾ªç¯ã€‚ ç”±äºå†…æ ¸å…è®¸åŒæ—¶è¿è¡Œå¤šä¸ªæ¨¡ä»¿ç‹¬ç«‹ç³»ç»Ÿçš„å®¹å™¨ï¼Œä»å®¹å™¨è§’åº¦çœ‹ä¼¼â€œå…¨å±€â€çš„æ¯ä¸ªèµ„æºï¼Œéƒ½ç”±å†…æ ¸åŒ…è£…èµ·æ¥ï¼Œåˆ†åˆ«æ ¹æ®æ¯ä¸ªå®¹å™¨è¿›è¡Œç®¡ç†ã€‚è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿä¹Ÿå—åˆ°å½±å“ï¼Œå› ä¸ºå„ä¸ªå®¹å™¨å¯èƒ½å› è£…è½½ç‚¹çš„ä¸åŒå¯¼è‡´ä¸åŒçš„ç›®å½•å±‚æ¬¡ç»“æ„ã€‚å¯¹åº”çš„ä¿¡æ¯åŒ…å«åœ¨ns_proxy-&gt;mnt_namespaceä¸­ã€‚ files_structfiles_struct identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223/* * æ‰“å¼€çš„æ–‡ä»¶è¡¨ç»“æ„ */ struct files_struct &#123; /* * ä¸»è¦è¯»å–éƒ¨åˆ† */ atomic_t count; //åŸå­è®¡æ•°å™¨ï¼Œå…±äº«è¯¥è¡¨çš„è¿›ç¨‹æ•°ç›® bool resize_in_progress; //é‡æ–°è°ƒæ•´è¿›åº¦ wait_queue_head_t resize_wait; //ç­‰å¾…é‡æ–°è°ƒæ•´é˜Ÿåˆ— struct fdtable __rcu *fdt; //æ–‡ä»¶æè¿°ç¬¦è¡¨ struct fdtable fdtab; /* * SMPä¸Šå•ç‹¬çš„ç¼“å­˜çº¿ä¸­çš„å†™å…¥éƒ¨åˆ† */ spinlock_t file_lock ____cacheline_aligned_in_smp; //æ–‡ä»¶é” unsigned int next_fd; //ä¸‹ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ unsigned long close_on_exec_init[1]; //æ‰§è¡Œæ—¶å…³é—­çš„åˆå§‹åŒ– unsigned long open_fds_init[1]; //æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦åˆå§‹åŒ– unsigned long full_fds_bits_init[1]; //å®Œæ•´æ–‡ä»¶æè¿°ç¬¦ä½çš„åˆå§‹åŒ– struct file __rcu * fd_array[NR_OPEN_DEFAULT]; //æ–‡ä»¶æè¿°ç¬¦æ•°ç»„ &#125;; next_fdè¡¨ç¤ºä¸‹ä¸€æ¬¡æ‰“å¼€æ–°æ–‡ä»¶æ—¶ä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦ã€‚close_on_exec_initå’Œopen_fds_initæ˜¯ä½å›¾ã€‚å¯¹æ‰§è¡Œexecæ—¶å°†å…³é—­çš„æ‰€æœ‰æ–‡ä»¶æè¿°ç¬¦ï¼Œåœ¨close_on_execä¸­å¯¹åº”çš„æ¯”ç‰¹ä½éƒ½å°†ç½®ä½ã€‚open_fds_initæ˜¯æœ€åˆçš„æ–‡ä»¶æè¿°ç¬¦é›†åˆã€‚ fd_arrayçš„æ¯ä¸ªæ•°ç»„é¡¹éƒ½æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘æ¯ä¸ªæ‰“å¼€æ–‡ä»¶çš„struct fileå®ä¾‹ï¼Œç¨åæˆ‘ä¼šè®¨è®ºè¯¥ç»“æ„ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå†…æ ¸å…è®¸æ¯ä¸ªè¿›ç¨‹æ‰“å¼€NR_OPEN_DEFAULTä¸ªæ–‡ä»¶ã€‚è¯¥å€¼å®šä¹‰åœ¨NR_OPEN_DEFAULT identifier - Linux source code (v6.3.8) - Bootlinä¸­ï¼Œé»˜è®¤å€¼ä¸ºBITS_PER_LONGã€‚å› æ­¤åœ¨32ä½ç³»ç»Ÿä¸Šï¼Œå…è®¸æ‰“å¼€æ–‡ä»¶çš„åˆå§‹æ•°ç›®æ˜¯32ã€‚64ä½ç³»ç»Ÿå¯ä»¥åŒæ—¶å¤„ç†64ä¸ªæ–‡ä»¶ã€‚å¦‚æœä¸€ä¸ªè¿›ç¨‹è¯•å›¾åŒæ—¶æ‰“å¼€æ›´å¤šçš„æ–‡ä»¶ï¼Œå†…æ ¸å¿…é¡»å¯¹files_structä¸­ç”¨äºç®¡ç†ä¸è¿›ç¨‹ç›¸å…³çš„æ‰€æœ‰æ–‡ä»¶ä¿¡æ¯çš„å„ä¸ªæˆå‘˜ï¼Œåˆ†é…æ›´å¤šçš„å†…å­˜ç©ºé—´ã€‚æœ€é‡è¦çš„ä¿¡æ¯åŒ…å«åœ¨fdtabä¸­ã€‚å†…æ ¸ä¸ºæ­¤å®šä¹‰äº†å¦ä¸€ä¸ªæ•°æ®ç»“æ„fdtableã€‚ fdtablefdtable identifier - Linux source code (v6.3.8) - Bootlin 12345678struct fdtable &#123; unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu;&#125;; struct files_structä¸­åŒ…å«äº†è¯¥ç»“æ„çš„ä¸€ä¸ªå®ä¾‹å’ŒæŒ‡å‘ä¸€ä¸ªå®ä¾‹çš„æŒ‡é’ˆï¼Œå› ä¸ºè¿™é‡Œä½¿ç”¨äº†RCUæœºåˆ¶ä»¥ä¾¿åœ¨æ— éœ€é”å®šçš„æƒ…å†µä¸‹è¯»å–è¿™äº›æ•°æ®ç»“æ„ï¼Œè¿™å¯ä»¥åŠ é€Ÿå¤„ç†ã€‚åœ¨è®¨è®ºå…·ä½“çš„åšæ³•å‰ï¼Œæˆ‘ä»¬éœ€è¦ä»‹ç»å„ä¸ªæˆå‘˜çš„è¯­ä¹‰ã€‚ max_fdsæŒ‡å®šäº†è¿›ç¨‹å½“å‰å¯ä»¥å¤„ç†çš„æ–‡ä»¶å¯¹è±¡å’Œæ–‡ä»¶æè¿°ç¬¦çš„æœ€å¤§æ•°ç›®ã€‚è¿™é‡Œæ²¡æœ‰å›ºæœ‰çš„ä¸Šé™ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå€¼éƒ½å¯ä»¥åœ¨å¿…è¦æ—¶å¢åŠ ï¼ˆåªè¦æ²¡æœ‰è¶…å‡ºç”±RlimitæŒ‡å®šçš„å€¼ï¼Œä½†è¿™ä¸æ–‡ä»¶ç»“æ„æ— å…³ï¼‰ã€‚å°½ç®¡å†…æ ¸ä½¿ç”¨çš„æ–‡ä»¶å¯¹è±¡å’Œæ–‡ä»¶æè¿°ç¬¦çš„æ•°ç›®æ€»æ˜¯ç›¸åŒçš„ï¼Œä½†å¿…é¡»å®šä¹‰ä¸åŒçš„æœ€å¤§æ•°ç›®ã€‚è¿™å½’å› äºç®¡ç†ç›¸å…³æ•°æ®ç»“æ„çš„æ–¹æ³•ã€‚æˆ‘ä¼šåœ¨ä¸‹æ–‡è§£é‡Šè¿™ä¸€ç‚¹ï¼Œä½†é¦–å…ˆå¿…é¡»é˜æ˜è¯¥ç»“æ„å‰©ä½™æˆå‘˜çš„è¯­ä¹‰ã€‚ fdæ˜¯ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„é¡¹æŒ‡å‘ä¸€ä¸ªfileç»“æ„çš„å®ä¾‹ï¼Œç®¡ç†ä¸€ä¸ªæ‰“å¼€æ–‡ä»¶çš„æ‰€æœ‰ä¿¡æ¯ã€‚ç”¨æˆ·ç©ºé—´è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦å……å½“æ•°ç»„ç´¢å¼•ã€‚è¯¥æ•°ç»„å½“å‰çš„é•¿åº¦ç”±max_fdså®šä¹‰ã€‚ open_fdsæ˜¯ä¸€ä¸ªæŒ‡å‘ä½åŸŸçš„æŒ‡é’ˆï¼Œè¯¥ä½åŸŸç®¡ç†ç€å½“å‰æ‰€æœ‰æ‰“å¼€æ–‡ä»¶çš„æè¿°ç¬¦ã€‚æ¯ä¸ªå¯èƒ½çš„æ–‡ä»¶æè¿°ç¬¦éƒ½å¯¹åº”ç€ä¸€ä¸ªæ¯”ç‰¹ä½ã€‚å¦‚æœè¯¥æ¯”ç‰¹ä½ç½®ä½ï¼Œåˆ™å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦å¤„äºä½¿ç”¨ä¸­ï¼›å¦åˆ™è¯¥æè¿°ç¬¦æœªä½¿ç”¨ã€‚å½“å‰æ¯”ç‰¹ä½ç½®çš„æœ€å¤§æ•°ç›®ç”±max_fdsetæŒ‡å®šã€‚ close_on_execä¹Ÿæ˜¯ä¸€ä¸ªæŒ‡å‘ä½åŸŸçš„æŒ‡é’ˆï¼Œè¯¥ä½åŸŸä¿å­˜äº†æ‰€æœ‰åœ¨execç³»ç»Ÿè°ƒç”¨æ—¶å°†è¦å…³é—­çš„æ–‡ä»¶æè¿°ç¬¦çš„ä¿¡æ¯ã€‚ fs_structfs_struct identifier - Linux source code (v6.3.8) - Bootlin ä¸»è¦å°±æ˜¯ä¸€ä¸ªfileæŒ‡é’ˆæ•°ç»„ï¼Œæˆ‘ä»¬é€šå¸¸è¯´çš„æ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œè€Œè¿™ä¸ªæ•´æ•°æ­£å¥½å¯ä»¥ä½œä¸ºä¸‹æ ‡ï¼Œä»è€Œä»files_structä¸­è·å¾—fileç»“æ„ã€‚å…·ä½“æŸ¥æ‰¾æ˜¯é€šè¿‡fdt-&gt;fd[fd]æ¥æ‰¾åˆ°å¯¹åº”çš„fileã€‚ 12345678struct fs_struct &#123; int users; spinlock_t lock; seqcount_spinlock_t seq; int umask; int in_exec; struct path root, pwd;&#125; __randomize_layout; fdt é»˜è®¤æ˜¯æŒ‡å‘fdtabçš„ï¼Œå½“æ‰“å¼€çš„æ–‡ä»¶æ•°ç›®æ¯”è¾ƒå¤šçš„æ—¶å€™ï¼Œå°±éœ€è¦é‡æ–°åˆ†é…ä¸€ä¸ªfdtableï¼Œå¹¶å¢å¤§å…¶fdæ•°ç»„å’Œæ‰“å¼€ä½å›¾ï¼Œç„¶åå°†è¿™ä¸ªfdtæŒ‡å‘æ–°åˆ†é…çš„fdtableã€‚åŸæ¥fdtæ‰€æŒ‡å‘çš„å†…å­˜ä¼šå¤åˆ¶åˆ°æ–°çš„fdtableã€‚ è‡³äºå¦‚ä½•åˆ¤æ–­fdtæ˜¯å¦æŒ‡å‘åŠ¨æ€fdtableï¼Œä¹Ÿå°±æ˜¯æœ€åæ˜¯å¦éœ€è¦é‡Šæ”¾fdtæ‰€æŒ‡å‘çš„å†…å­˜ï¼Œå¯ä»¥é€šè¿‡åˆ¤æ–­fdtå’Œfdtabçš„åœ°å€æ˜¯å¦ç›¸ç­‰æ¥ç¡®å®šã€‚ file_lock ä¿æŠ¤å¯¹file_structçš„ä¿®æ”¹ã€‚ ä»æ–‡ä»¶æè¿°ç¬¦è½¬æ¢ä¸ºfileçš„å…³é”®æ•°æ®ç»“æ„å°±æ˜¯fdtableã€‚ fdtablefdtable identifier - Linux source code (v6.3.8) - Bootlin 12345678struct fdtable &#123; unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu;&#125;; fd å¦‚æœæ‰“å¼€çš„æ–‡ä»¶æ¯”è¾ƒå°‘ï¼Œé‚£ä¹ˆè¿™ä¸ªfdå°†æŒ‡å‘files_structçš„fd_arrayã€‚å¦‚æœæ‰“å¼€çš„æ–‡ä»¶æ¯”è¾ƒå¤šï¼Œfdtableæœ¬èº«å°±æ˜¯åŠ¨æ€åˆ†é…çš„ï¼Œfdä¹Ÿæ˜¯åŠ¨æ€åˆ†é…ã€‚æ‰€ä»¥æ˜¯å¦è¦é‡Šæ”¾fdæ‰€æŒ‡ç©ºé—´å¾ˆå¥½åˆ¤æ–­ï¼Œå¦‚æœè¦é‡Šæ”¾fdtableå°±ä¸€å®šä¼šé‡Šæ”¾fdã€‚å¯¹fdçš„åˆ†é…ä¼šå°è¯•kmalloc()å’Œvmalloc()ä¸¤ç§æ–¹æ³•ã€‚ å¦å¤–ï¼Œclose_on_execä¸open_fdsçš„è¡Œä¸ºåŒfdï¼Œå¦‚æœfdtableæ˜¯åŠ¨æ€åˆ†é…çš„ï¼Œé‚£ä¹ˆä»–ä»¬ä¹Ÿå¿…ç„¶æ˜¯åŠ¨æ€åˆ†é…çš„ã€‚ è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿæœºåˆ¶åŸç†Linuxå†…æ ¸å½“ä¸­è´Ÿè´£ç®¡ç†å’Œå­˜å‚¨æ–‡ä»¶çš„æ¨¡å—ï¼Œå³æ–‡ä»¶ç³»ç»Ÿæ¨¡å—ã€‚Linuxæ–‡ä»¶ç³»ç»Ÿçš„æ¶æ„è§†å›¾ï¼ˆç”¨æˆ·ç©ºé—´ã€å†…æ ¸ç©ºé—´ã€ç¡¬ä»¶å±‚é¢ï¼‰ æŒ‚è½½æ‰§è¡Œå‘½ä»¤ï¼šmount -t fstype device dir å¸è½½æ‰§è¡Œå‘½ä»¤ï¼šumount å½“æˆ‘ä»¬å†™æ–‡ä»¶æ—¶ï¼ŒLinuxå†…æ ¸ç³»ç»Ÿæ¨¡å—ä¼šæŠŠæ•°æ®ä¿å­˜åœ¨é¡µç¼“å­˜å½“ä¸­ï¼Œä¸ä¼šç«‹åˆ»å†™åˆ°å­˜å‚¨è®¾å¤‡ã€‚ä½¿ç”¨fsyncæŠŠæ–‡ä»¶ä¿®æ”¹è¿‡çš„å±æ€§å’Œæ•°æ®ç«‹å³å†™åˆ°å­˜å‚¨è®¾å¤‡ï¼Œä½¿ç”¨fsyncæŠŠæ–‡ä»¶ä¿®æ”¹è¿‡çš„å±æ€§å’Œæ•°æ®ç«‹å³å†™åˆ°å­˜å‚¨è®¾å¤‡ï¼Œæˆ–è€…ä½¿ç”¨fdatasyncæŠŠæ–‡ä»¶ä¿®æ”¹è¿‡çš„æ•°æ®ç†è§£å†™åˆ°å­˜å‚¨è®¾å¤‡ã€‚ æˆ‘ä»¬åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨glibcåº“å°è£…çš„I&#x2F;Oæ¥è®¿é—®æ–‡ä»¶ï¼ˆæä¾›ç¼“å†²åŒºï¼Œç›®çš„æ˜¯å°½å¯èƒ½å‡å°‘è°ƒç”¨read&#x2F;writeçš„æ¬¡æ•°ï¼Œæé«˜æ€§èƒ½ï¼‰ ç¡¬ä»¶å±‚é¢ï¼šå—è®¾å¤‡ï¼ˆæœºæ¢°ç¡¬ç›˜ï¼‰ã€é—ªå­˜ï¼ˆSSDï¼‰ã€NVDIMMè®¾å¤‡ã€‚NORé—ªå­˜é€‚åˆå­˜å‚¨ç¨‹åºï¼ˆä¸€èˆ¬æƒ…å†µä¸‹å­˜å‚¨å¼•å¯¼ç¨‹åºï¼ŒU-Bootç¨‹åºï¼‰ã€‚NANDé—ªå­˜é€‚åˆå­˜å‚¨æ•°æ®ã€‚ ä¸ºä»€ä¹ˆè¦é’ˆå¯¹é—ªå­˜ä¸“é—¨è®¾è®¡æ–‡ä»¶ç³»ç»Ÿï¼Ÿ NANDå­˜åœ¨åå—ï¼Œè½¯ä»¶éœ€è¦è¯†åˆ«ä¸”è·³è¿‡åå—ã€‚ éœ€è¦å®ç°æŸè€—å‡è¡¡ï¼ŒæŸè€—å‡è¡¡å°±æ˜¯ä½¿æ‰€æœ‰æ“¦é™¤å—çš„æ“¦é™¤æ¬¡æ•°å‡è¡¡ï¼Œé¿å…ä¸€éƒ¨åˆ†æ“¦é™¤å¿«å…ˆæŸåã€‚ NANDé—ªå­˜å’Œæœºæ¢°ç¡¬ç›˜çš„ä¸»è¦åŒºåˆ«ï¼š æœºæ¢°ç¡¬ç›˜æœ€å°è¯»å†™å•ä½ä¸ºæ‰‡åŒºï¼Œæ‰‡åŒºå¤§å°ä¸€èˆ¬ä¸º512å­—èŠ‚ï¼›NANDé—ªå­˜æœ€å°è¯»å†™å•ä½æ˜¯é¡µæˆ–å­é¡µã€‚ æœºæ¢°ç¡¬ç›˜å¯ä»¥ç›´æ¥å†™å…¥æ•°æ®ï¼›NANDåœ¨å†™å…¥æ•°æ®ä¹‹å‰éœ€è¦æ“¦é™¤ä¸€ä¸ªæ“¦é™¤å—ã€‚ æœºæ¢°ç¡¬ç›˜çš„ä½¿ç”¨å¯¿å‘½æ¯”NANDé—ªå­˜é•¿ï¼›æœºæ¢°ç¡¬ç›˜çš„æ‰‡åŒºçš„å†™å…¥æ¬¡æ•°æ²¡æœ‰é™åˆ¶ï¼›NANDé—ªå­˜æ“¦é™¤å¿«çš„æ“¦é™¤æ¬¡æ•°æœ‰é™ã€‚ æœºæ¢°ç¡¬ç›˜éšè—åçš„æ‰‡åŒºï¼Œè½¯ä»¶ä¸éœ€è¦å¤„ç†åçš„æ‰‡åŒºï¼›NANDé—ªå­˜çš„åå—å¯¹è½¯ä»¶å¯è§ï¼Œè½¯ä»¶éœ€è¦å¤„ç†åå—ã€‚ Linuxå†…æ ¸ç©ºé—´å±‚é¢ï¼šLinuxå†…æ ¸çš„ç›®å½•fsï¼ˆå†…æ ¸æ”¯æŒå¤šç§æ–‡ä»¶ç³»ç»Ÿç±»å‹ï¼‰ã€‚ä¸ºäº†ä¸åŒæ–‡ä»¶ç³»ç»Ÿå®ç°èƒ½å¤Ÿå…±å­˜ï¼Œå†…æ ¸å®ç°ä¸€ä¸ªæŠ½è±¡å±‚ï¼ˆç§°ä¸ºè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼‰ã€‚æ–‡ä»¶ç³»ç»Ÿåˆ†ç±»ï¼šå—è®¾å¤‡æ–‡ä»¶ç³»ç»Ÿï¼ˆext2&#x2F;3&#x2F;4ã€btrfsï¼‰ã€é—ªå­˜æ–‡ä»¶ç³»ç»Ÿï¼ˆJFFS2ã€UBIFSï¼‰ã€å†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼ˆtmpfsï¼‰ã€ä¼ªæ–‡ä»¶ç³»ç»Ÿï¼ˆsockfsã€procã€sysfsã€hugetlbfsã€cgroup)ã€‚ é¿å…æ¯æ¬¡è¯»å†™éƒ½éœ€è¦è®¿é—®å—è®¾å¤‡ï¼Œå†…æ ¸å®ç°å—ç¼“å­˜ï¼Œä¸ºæ¯ä¸ªå—è®¾å¤‡åœ¨å†…å­˜ä¸­åˆ›å»ºä¸€ä¸ªå—ç¼“å­˜ï¼Œç¼“å­˜å•ä½ä¸ºå—ï¼Œå—ç¼“å­˜åŸºäºé¡µç¼“å­˜å®ç°ã€‚I&#x2F;Oè°ƒåº¦å™¨ç”¨æ¥å†³å®šè¯»å†™è¯·æ±‚çš„æäº¤é¡ºåºï¼Œä¸åŒåœºæ™¯æä¾›å¤šç§è°ƒåº¦ç®—æ³•ï¼šNOOPï¼ˆé€‚åˆé—ªå­˜ç±»è®¾å¤‡ï¼‰ã€CFQï¼ŒDeadlineï¼ˆåä¸¤ä¸ªé€‚åˆæœºæ¢°ç¡¬ç›˜ï¼‰ã€‚ Linuxå†…æ ¸æŠŠé—ªå­˜ç§°ä¸ºå­˜å‚¨æŠ€æœ¯è®¾å¤‡ï¼ˆMTDï¼‰ è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼ˆVFSï¼‰æ•°æ®ç»“æ„ï¼šè¶…çº§å—(super_block)ã€ç´¢å¼•èŠ‚ç‚¹(inode)(æ¯ä¸ªæ–‡ä»¶å¯¹åº”ä¸€ä¸ªç´¢å¼•èŠ‚ç‚¹ï¼Œæ¯ä¸ªç´¢å¼•èŠ‚ç‚¹æœ‰ä¸€ä¸ªå”¯ä¸€çš„ç¼–å·ï¼‰ã€ç›®å½•é¡¹(dentry)ã€‚ å½“è¿›ç¨‹æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶æ—¶ï¼Œè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿå°±ä¼šåˆ›å»ºæ–‡ä»¶çš„ä¸€ä¸ªæ‰“å¼€å®ä¾‹ï¼ˆfileæ•°æ®ç»“æ„ï¼‰ã€‚æ–‡ä»¶ç³»ç»Ÿçš„ç¬¬ä¸€å—æ˜¯è¶…çº§å—ï¼ˆsuper_block) æŒ‚è½½æè¿°ç¬¦ï¼šä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Œåªæœ‰æŒ‚è½½åˆ°å†…å­˜å½“ä¸­ç›®å½•æ ‘çš„ ä¸€ä¸ªç›®å½•ä¸‹ï¼Œè¿›ç¨‹æ‰èƒ½å¤Ÿè®¿é—®è¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿã€‚æ¯æ¬¡æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿï¼Œè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿå°±ä¼šåˆ›å»ºä¸€ä¸ªæŒ‚è½½æè¿°ç¬¦ï¼šmountç»“æ„ä½“ã€‚æŒ‚è½½æè¿°ç¬¦ç”¨æ¥æè¿°æ–‡ä»¶ç³»ç»Ÿçš„ä¸€ä¸ªæŒ‚è½½å®ä¾‹ï¼ŒåŒä¸€ä¸ªå­˜å‚¨è®¾å¤‡ä¸Šçš„æ–‡ä»¶ç³»ç»Ÿå¯ä»¥å¤šæ¬¡æŒ‚è½½ï¼Œæ¯æ¬¡æŒ‚è½½åˆ°ä¸åŒçš„ç›®å½•ä¸‹ã€‚mountç»“æ„ä½“ã€‚ åŸºæœ¬æ“ä½œç´¢å¼•èŠ‚ç‚¹å“ˆå¸Œè¡¨å“ˆå¸Œè¡¨ç»“æ„ types.h - include&#x2F;linux&#x2F;types.h - Linux source code (v6.3.8) - Bootlin 123456struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;; å…³äºhashå€¼å¾—è®¡ç®—ä½¿ç”¨çš„æ˜¯å¦‚ä¸‹å‡½æ•°,å‚æ•°hashvalå®é™…å°±æ˜¯inodeçš„ç´¢å¼•å·ã€‚ inode.c - fs&#x2F;inode.c - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021// å®šä¹‰ä¸€ä¸ªåä¸ºhashçš„å‡½æ•°ï¼Œä¼ å…¥ä¸€ä¸ªæŒ‡å‘super_blockç»“æ„ä½“çš„æŒ‡é’ˆsbå’Œä¸€ä¸ªæ— ç¬¦å·é•¿æ•´å‹hashvalï¼Œè¿”å›ä¸€ä¸ªæ— ç¬¦å·é•¿æ•´å‹å€¼static unsigned long hash(struct super_block *sb, unsigned long hashval)&#123; // å®šä¹‰ä¸€ä¸ªæ— ç¬¦å·é•¿æ•´å‹å˜é‡tmpï¼Œç”¨äºå­˜å‚¨è®¡ç®—ç»“æœ unsigned long tmp; // è®¡ç®—tmpçš„å€¼ï¼Œå…¶ä¸­ï¼š // 1. å°†hashvalä¹˜ä»¥sbæŒ‡é’ˆçš„å€¼ï¼ˆå°†å…¶è§†ä¸ºæ— ç¬¦å·é•¿æ•´å‹ï¼‰ // 2. å¯¹ä¸Šè¿°ç»“æœè¿›è¡Œå¼‚æˆ–è¿ç®—ï¼Œä¸(GOLDEN_RATIO_PRIME + hashval) / L1_CACHE_BYTESçš„ç»“æœ tmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) / L1_CACHE_BYTES; // å¯¹tmpè¿›è¡Œä»¥ä¸‹è®¡ç®—ï¼š // 1. å°†tmpä¸GOLDEN_RATIO_PRIMEè¿›è¡Œå¼‚æˆ– // 2. å³ç§»i_hash_shiftä½ // 3. ä¸åŸtmpå€¼è¿›è¡Œå¼‚æˆ– tmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) &gt;&gt; i_hash_shift); // è¿”å›tmpä¸i_hash_maskè¿›è¡ŒæŒ‰ä½ä¸è¿ç®—çš„ç»“æœ return tmp &amp; i_hash_mask;&#125; insert_inode_hash å°†inodeæ’å…¥å“ˆå¸Œè¡¨ insert_inode_hash identifier - Linux source code (v6.3.8) - Bootlin 1234static inline void insert_inode_hash(struct inode *inode)&#123; __insert_inode_hash(inode, inode-&gt;i_ino);&#125; remove_inode_hash å°†inodeä»å“ˆå¸Œè¡¨åˆ é™¤ remove_inode_hash identifier - Linux source code (v6.3.8) - Bootlin 12345static inline void remove_inode_hash(struct inode *inode)&#123; if (!inode_unhashed(inode) &amp;&amp; !hlist_fake(&amp;inode-&gt;i_hash)) __remove_inode_hash(inode);&#125; ç›®å½•é¡¹å“ˆå¸Œè¡¨å“ˆå¸Œè¡¨ç»“æ„ list_bl.h - include&#x2F;linux&#x2F;list_bl.h - Linux source code (v6.3.8) - Bootlin 1234567struct hlist_bl_head &#123; struct hlist_bl_node *first;&#125;;struct hlist_bl_node &#123; struct hlist_bl_node *next, **pprev;&#125;; 12345678910111213141516171819/* * è¿™æ˜¯ä¸dcacheï¼ˆç›®å½•é¡¹ç¼“å­˜ï¼‰æœ€å…³é”®çš„æ•°æ®ç»“æ„ï¼šç”¨äºæŸ¥æ‰¾çš„å“ˆå¸Œè¡¨ã€‚ * æœ‰äººåº”è¯¥å°è¯•ä¼˜åŒ–è¿™ä¸ªæ•°æ®ç»“æ„ - æˆ‘åªæ˜¯è®©å®ƒèƒ½å¤Ÿå·¥ä½œã€‚ * * è¿™ä¸ªå“ˆå¸Œå‡½æ•°è¯•å›¾é¿å…ä¸¢å¤±å¤ªå¤šçš„å“ˆå¸Œä¿¡æ¯ï¼ŒåŒæ—¶é¿å…ä½¿ç”¨è´¨æ•°å¤§å°çš„å“ˆå¸Œè¡¨ç­‰ç±»ä¼¼è®¾è®¡ã€‚ */// å®šä¹‰ä¸€ä¸ªé™æ€æ— ç¬¦å·æ•´å‹å˜é‡d_hash_shiftï¼Œä½¿ç”¨__read_mostlyä¿®é¥°ï¼Œè¡¨ç¤ºè¯¥å˜é‡åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æ˜¯åªè¯»çš„static unsigned int d_hash_shift __read_mostly;// å®šä¹‰ä¸€ä¸ªæŒ‡å‘hlist_bl_headç»“æ„ä½“çš„æŒ‡é’ˆdentry_hashtableï¼Œä½¿ç”¨__read_mostlyä¿®é¥°ï¼Œè¡¨ç¤ºè¯¥æŒ‡é’ˆåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æ˜¯åªè¯»çš„static struct hlist_bl_head *dentry_hashtable __read_mostly;// å®šä¹‰ä¸€ä¸ªåä¸ºd_hashçš„å†…è”å‡½æ•°ï¼Œå‚æ•°ä¸ºæ— ç¬¦å·æ•´å‹hashï¼Œè¿”å›ä¸€ä¸ªæŒ‡å‘hlist_bl_headç»“æ„ä½“çš„æŒ‡é’ˆstatic inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; // è®¡ç®—å“ˆå¸Œå€¼ï¼šå°†è¾“å…¥çš„hashå³ç§»d_hash_shiftä½ï¼Œç„¶åä¸dentry_hashtableç›¸åŠ ï¼Œå¾—åˆ°å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„æŒ‡é’ˆ return dentry_hashtable + (hash &gt;&gt; d_hash_shift);&#125; dentry_hashtable åœ¨dcache_init()&#x2F;dcache_init_early()æ—¶ä¼šå¯¹å…¶åˆå§‹åŒ– 123456789101112131415161718192021222324252627static void __init dcache_init(void)&#123; /* * A constructor could be added for stable state like the lists, * but it is probably not worth it because of the cache nature * of the dcache. */ dentry_cache = KMEM_CACHE_USERCOPY(dentry, SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT, d_iname); /* Hash may have been set up in dcache_init_early */ if (!hashdist) return; dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; 1234567891011121314151617181920static void __init dcache_init_early(void)&#123; /* If hashes are distributed across NUMA nodes, defer * hash allocation until vmalloc space is available. */ if (hashdist) return; dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_EARLY | HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; d_hash_mask å®é™…é•¿åº¦ä½æ•°ï¼Œå³ilog2(dhash_entries) d_hash_shift æœ€å¤§ç´¢å¼•å€¼ï¼Œå³(1 &lt;&lt; d_hash_mask) - 1 å¯¹hashå€¼çš„è®¡ç®—é‡‡ç”¨çš„æ˜¯å¦‚ä¸‹å‡½æ•°ï¼Œæ³¨æ„d_hashçš„å‚æ•°hashæ˜¯å°†è·¯å¾„åè½¬æ¢å‡ºæ¥çš„ä¸€ä¸ªæ•°å­—ï¼Œå…·ä½“è½¬æ¢æ–¹æ³•æ¯”è¾ƒå¤æ‚ï¼Œè¯·å‚è€ƒfull_name_hashã€‚ 123456static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent, unsigned int hash)&#123; hash += (unsigned long) parent / L1_CACHE_BYTES; return in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);&#125; d_add å®ä¾‹åŒ–dentryå¹¶åŠ å…¥å“ˆå¸Œè¡¨ï¼Œæ‰€è°“å®ä¾‹åŒ–å°±æ˜¯å’Œå…·ä½“çš„inodeå…³è” 12345678910111213141516171819202122232425/** * d_add - å°†dentryæ·»åŠ åˆ°å“ˆå¸Œé˜Ÿåˆ—ä¸­ * @entry: è¦æ·»åŠ çš„dentry * @inode: è¦é™„åŠ åˆ°æ­¤dentryçš„inode * * å°†entryæ·»åŠ åˆ°å“ˆå¸Œé˜Ÿåˆ—ä¸­å¹¶åˆå§‹åŒ–@inodeã€‚ * å®é™…ä¸Šï¼Œåœ¨d_alloc()è¿‡ç¨‹ä¸­å·²ç»å¡«å……äº†entryã€‚ */// å®šä¹‰ä¸€ä¸ªåä¸ºd_addçš„å‡½æ•°ï¼Œå‚æ•°ä¸ºæŒ‡å‘dentryç»“æ„ä½“çš„æŒ‡é’ˆentryå’ŒæŒ‡å‘inodeç»“æ„ä½“çš„æŒ‡é’ˆinodevoid d_add(struct dentry *entry, struct inode *inode)&#123; // å¦‚æœinodeéç©º if (inode) &#123; // è°ƒç”¨security_d_instantiate()å‡½æ•°ï¼Œå°†entryä¸inodeå…³è” security_d_instantiate(entry, inode); // å¯¹inodeçš„i_lockæˆå‘˜è¿›è¡Œè‡ªæ—‹é”åŠ é”ï¼Œä»¥ä¿æŠ¤å…¶å…³è”çš„dentryé“¾è¡¨ spin_lock(&amp;inode-&gt;i_lock); &#125; // è°ƒç”¨__d_add()å‡½æ•°ï¼Œå°†entryæ·»åŠ åˆ°inodeçš„å…³è”dentryé“¾è¡¨ä¸­ __d_add(entry, inode);&#125;// å¯¼å‡ºd_addå‡½æ•°çš„ç¬¦å·ï¼Œä½¿å…¶å¯ä»¥è¢«å¤–éƒ¨æ¨¡å—ä½¿ç”¨EXPORT_SYMBOL(d_add); d_lookup æ ¹æ®è·¯å¾„åæŸ¥æ‰¾ç›®å½•é¡¹ï¼Œåœ¨__d_lookupåŸºç¡€ä¸ŠåŠ äº†ä¸€ä¸ªé¡ºåºé”æ ¡éªŒ 12345678910111213141516171819202122232425/** * d_lookup - search for a dentry * @parent: parent dentry * @name: qstr of name we wish to find * Returns: dentry, or NULL * * d_lookup searches the children of the parent dentry for the name in * question. If the dentry is found its reference count is incremented and the * dentry is returned. The caller must use dput to free the entry when it has * finished using it. %NULL is returned if the dentry does not exist. */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; do &#123; seq = read_seqbegin(&amp;rename_lock); dentry = __d_lookup(parent, name); if (dentry) break; &#125; while (read_seqretry(&amp;rename_lock, seq)); return dentry;&#125;EXPORT_SYMBOL(d_lookup); æ–‡ä»¶ç³»ç»Ÿå®‰è£…åœ¨ä½¿ç”¨ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿä¹‹å‰ï¼Œå¿…é¡»æ‰§è¡Œä¸¤ä¸ªæ“ä½œï¼šæ³¨å†Œå’Œå®‰è£…ã€‚ æˆ–è€…åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œæˆ–è€…åœ¨å®‰è£…æŸä¸ªæ–‡ä»¶ç³»ç»Ÿçš„æ¨¡å—æ—¶ï¼Œéƒ½éœ€è¦è¿›è¡Œæ³¨å†Œã€‚ä¸€æ—¦ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿå®Œæˆæ³¨å†Œï¼Œé‚£ä¹ˆå®ƒå…·ä½“çš„å‡½æ•°å¯¹å†…æ ¸å°±æ˜¯å¯ç”¨çš„äº†ï¼Œå› æ­¤ï¼Œè¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿå°±å¯ä»¥å®‰è£…åœ¨ç³»ç»Ÿçš„ç›®å½•æ ‘ä¸Šã€‚åœ¨æ–‡ä»¶ç³»ç»Ÿæ³¨å†Œåˆ°å†…æ ¸æ—¶ï¼Œæ–‡ä»¶ç³»ç»Ÿæ˜¯ç¼–è¯‘ä¸ºæ¨¡å—ï¼Œæˆ–è€…æŒä¹…ç¼–è¯‘åˆ°å†…æ ¸ä¸­ï¼Œéƒ½æ²¡æœ‰å·®åˆ«ã€‚å¦‚æœä¸è€ƒè™‘æ³¨å†Œçš„æ—¶é—´ï¼ˆæŒä¹…ç¼–è¯‘åˆ°å†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿåœ¨å¯åŠ¨æ—¶æ³¨å†Œï¼Œæ¨¡å—åŒ–æ–‡ä»¶ç³»ç»Ÿåœ¨ç›¸å…³æ¨¡å—è½½å…¥å†…æ ¸æ—¶æ³¨å†Œï¼‰ï¼Œåœ¨ä¸¤ç§æƒ…å†µä¸‹æ‰€ç”¨çš„æŠ€æœ¯æ–¹æ³•æ˜¯åŒæ ·çš„ã€‚ æ¯ä¸ªæ–‡ä»¶ç³»ç»Ÿéƒ½æœ‰å®ƒè‡ªå·±çš„æ ¹ç›®å½•ï¼Œå¦‚æœæŸæ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•æ—¶ç³»ç»Ÿç›®å½•æ ‘çš„æ ¹ï¼Œé‚£ä¹ˆè¯¥æ–‡ä»¶ç³»ç»Ÿç§°ä¸ºæ ¹æ–‡ä»¶ç³»ç»Ÿã€‚è€Œå…¶ä»–æ–‡ä»¶ç³»ç»Ÿå¯ä»¥å®‰è£…åˆ°ç³»ç»Ÿçš„ç›®å½•æ ‘ä¸Šï¼ŒæŠŠè¿™äº›æ–‡ä»¶ç³»ç»Ÿè¦æ’å…¥çš„é‚£äº›ç›®å½•å°±æˆä¸ºå®‰è£…ç‚¹ï¼ˆmount pointï¼‰ã€‚ æ³¨å†Œå’ŒæŒ‚è½½æ–‡ä»¶ç³»ç»Ÿè¦æ³¨å†Œå’Œæ³¨é”€æ–‡ä»¶ç³»ç»Ÿï¼Œè¦ä½¿ç”¨ä»¥ä¸‹APIå‡½æ•°ï¼š fs.h - include&#x2F;linux&#x2F;fs.h - Linux source code (v6.6) - Bootlin 1234#include &lt;linux/fs.h&gt;extern int register_filesystem(struct file_system_type *);extern int unregister_filesystem(struct file_system_type *); ä¼ é€’struct file_system_typeæè¿°äº†æ–‡ä»¶ç³»ç»Ÿã€‚å½“è¯·æ±‚å°†æ–‡ä»¶ç³»ç»ŸæŒ‚è½½åˆ°namespaceä¸­çš„ç›®å½•æ—¶ï¼ŒVFSå°†ä¸ºç‰¹å®šæ–‡ä»¶ç³»ç»Ÿè°ƒç”¨ç›¸åº”çš„mount()æ–¹æ³•ã€‚ å¼•ç”¨ -&gt;mountï¼ˆï¼‰ è¿”å›çš„æ ‘çš„æ–° vfsmount å°†é™„åŠ åˆ°æŒ‚è½½ç‚¹ï¼Œä»¥ä¾¿å½“è·¯å¾„åè§£æåˆ°è¾¾æŒ‚è½½ç‚¹æ—¶ï¼Œå®ƒå°†è·³è½¬åˆ°è¯¥ vfsmount çš„æ ¹ç›®å½•ã€‚ å¯ä»¥åœ¨æ–‡ä»¶ &#x2F;proc&#x2F;filesystems ä¸­çœ‹åˆ°æ³¨å†Œåˆ°å†…æ ¸çš„æ‰€æœ‰æ–‡ä»¶ç³»ç»Ÿã€‚ åœ¨ç³»ç»Ÿåˆå§‹åŒ–æœŸé—´ï¼ŒLinux v2.6è°ƒç”¨å‡½æ•°filesystem_setup()æ¥æ³¨å†Œç¼–è¯‘æ—¶æŒ‡å®šçš„æ–‡ä»¶ç³»ç»Ÿï¼Œè€Œåœ¨æœ€æ–°ç‰ˆæœ¬çš„Linuxä¸­è¿™ä¸ªå‡½æ•°ç”±å…¶ä»–å‡½æ•°æ›¿ä»£ã€‚é€šè¿‡module_init()å’Œç›¸åº”çš„init_xxx_fs()å‡½æ•°æ¥å®ç°æ–‡ä»¶ç³»ç»Ÿçš„æ³¨å†Œã€‚ å¯¹äºæ¯ä¸ªä¸åŒç±»å‹çš„æ–‡ä»¶ç³»ç»Ÿï¼Œä»¥æŒ‡å‘file_system_typeç±»å‹çš„æŸä¸ªå¯¹è±¡ä½œä¸ºå‚æ•°æ¥è°ƒç”¨register_filesystem()å‡½æ•°ï¼Œå› æ­¤ï¼Œè¯¥å¯¹è±¡å°±è¢«æ’å…¥åˆ°æ–‡ä»¶ç³»ç»Ÿç±»å‹çš„é“¾è¡¨ä¸­ã€‚ å½“æŸä¸ªæ–‡ä»¶ç³»ç»Ÿçš„æ¨¡å—è¢«è£…å…¥æ—¶ï¼Œä¹Ÿè¦è°ƒç”¨register_filesystem()å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå½“è¯¥æ¨¡å—è¢«å¸è½½æ—¶ï¼Œå¯¹åº”çš„æ–‡ä»¶ç³»ç»Ÿä¹Ÿå¯ä»¥è¢«æ³¨é”€ï¼ˆè°ƒç”¨unregister_filesystem()å‡½æ•°ï¼‰ã€‚ get_fs_type()å‡½æ•°ï¼ˆæ¥å—ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿåä½œä¸ºå®ƒçš„å‚æ•°ï¼‰æ‰«æå·²æ³¨å†Œçš„æ–‡ä»¶ç³»ç»Ÿé“¾è¡¨ï¼Œå¹¶è¿”å›æŒ‡å‘ç›¸åº”çš„file_system_typeå¯¹è±¡çš„æŒ‡é’ˆï¼ˆå¦‚æœå­˜åœ¨ï¼‰ã€‚ get_fs_type identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021struct file_system_type *get_fs_type(const char *name) &#123; //æ ¹æ®æ–‡ä»¶ç³»ç»Ÿåç§°è·å–æ–‡ä»¶ç³»ç»Ÿç±»å‹ struct file_system_type *fs; const char *dot = strchr(name, &#x27;.&#x27;); //æŸ¥æ‰¾ç‚¹å· int len = dot ? dot - name : strlen(name); //è·å–æ–‡ä»¶ç³»ç»Ÿç±»å‹åç§°çš„é•¿åº¦ fs = __get_fs_type(name, len); //æ ¹æ®åç§°å’Œé•¿åº¦è·å–æ–‡ä»¶ç³»ç»Ÿç±»å‹ if (!fs &amp;&amp; (request_module(&quot;fs-%.*s&quot;, len, name) == 0)) &#123; //å¦‚æœè·å–ä¸åˆ°,åŠ è½½æ–‡ä»¶ç³»ç»Ÿæ¨¡å— fs = __get_fs_type(name, len); //å†æ¬¡è·å–æ–‡ä»¶ç³»ç»Ÿç±»å‹ if (!fs) pr_warn_once(&quot;request_module fs-%.*s succeeded, but still no fs?\\n&quot;, //å¦‚æœè¿˜æ˜¯è·å–ä¸åˆ°,æ‰“å°è­¦å‘Šä¿¡æ¯ len, name); &#125; if (dot &amp;&amp; fs &amp;&amp; !(fs-&gt;fs_flags &amp; FS_HAS_SUBTYPE)) &#123; //å¦‚æœæ–‡ä»¶ç³»ç»Ÿåç§°åŒ…å«ç‚¹å·,ä¸”æ–‡ä»¶ç³»ç»Ÿç±»å‹ä¸æ”¯æŒå­ç±»å‹ put_filesystem(fs); //é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿç±»å‹ fs = NULL; //è®¾ç½®ä¸ºNULL &#125; return fs; //è¿”å›æ–‡ä»¶ç³»ç»Ÿç±»å‹&#125; åŠ è½½æ–‡ä»¶ç³»ç»Ÿæ¨¡å—ï¼ˆå¦‚ ext4ï¼‰ï¼Œå¹¶è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿçš„æ³¨å†Œå‡½æ•°ã€‚åœ¨æ³¨å†Œå‡½æ•°ä¸­ï¼Œéœ€è¦æä¾›ä¸€ä¸ªæŒ‡å‘ file_system_type ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œè¯¥ç»“æ„ä½“åŒ…å«æ–‡ä»¶ç³»ç»Ÿçš„åŸºæœ¬ä¿¡æ¯å’Œæ“ä½œæŒ‡é’ˆã€‚ æ–‡ä»¶ç³»ç»Ÿå¯ä»¥ä»¥ä¸¤ç§æ–¹å¼å­˜åœ¨äºæ“ä½œç³»ç»Ÿä¸­ï¼šå†…å»ºäºå†…æ ¸ä¸­æˆ–ä½œä¸ºå¯åŠ è½½æ¨¡å—ã€‚å†…å»ºæ–‡ä»¶ç³»ç»Ÿç›´æ¥ç¼–è¯‘è¿›å†…æ ¸ï¼Œè€Œä½œä¸ºæ¨¡å—çš„æ–‡ä»¶ç³»ç»Ÿå¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€åŠ è½½ã€‚è¿™ç§æ¨¡å—åŒ–è®¾è®¡å¯ä»¥èŠ‚çœå†…æ ¸ç©ºé—´å’Œæé«˜è¿è¡Œæ•ˆç‡ï¼Œå› ä¸ºåªæœ‰åœ¨éœ€è¦ä½¿ç”¨ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿæ—¶ï¼Œå¯¹åº”çš„æ¨¡å—æ‰ä¼šè¢«åŠ è½½ã€‚ å†…å»ºäºå†…æ ¸çš„æ–‡ä»¶ç³»ç»Ÿæ„å‘³ç€æ–‡ä»¶ç³»ç»Ÿçš„å®ç°ä»£ç ç›´æ¥ç¼–è¯‘è¿›å†…æ ¸äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œè€Œä¸æ˜¯ä½œä¸ºæ¨¡å—åŠ¨æ€åŠ è½½ã€‚å†…å»ºæ–‡ä»¶ç³»ç»Ÿåœ¨å†…æ ¸å¯åŠ¨æ—¶å°±å·²ç»å¯ç”¨ï¼Œä¸éœ€è¦é¢å¤–çš„åŠ è½½è¿‡ç¨‹ã€‚è¿™ç§æ–¹å¼é€‚ç”¨äºä¸€äº›åŸºæœ¬æˆ–å¸¸ç”¨çš„æ–‡ä»¶ç³»ç»Ÿï¼Œå¦‚ ext4ã€proc ã€tmpfsç­‰ã€‚ ä½¿ç”¨ register_filesystem() å‡½æ•°æ³¨å†Œæ–°çš„æ–‡ä»¶ç³»ç»Ÿï¼Œå°†å…¶æ·»åŠ åˆ° VFS æ”¯æŒçš„æ–‡ä»¶ç³»ç»Ÿåˆ—è¡¨ä¸­ã€‚ å½“éœ€è¦æŒ‚è½½è¯¥æ–‡ä»¶ç³»ç»Ÿæ—¶ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡ mount å‘½ä»¤ï¼‰ï¼ŒVFS å°†è°ƒç”¨ file_system_type ç»“æ„ä½“ä¸­çš„ mount å‡½æ•°æŒ‡é’ˆã€‚è¿™å°†è§¦å‘è¯»å–è®¾å¤‡çš„è¶…çº§å—æ•°æ®å¹¶åˆ›å»ºä¸€ä¸ªå¯¹åº”çš„ VFS super_block ç»“æ„ä½“å®ä¾‹ã€‚è¿™ä¸ªå®ä¾‹åŒ…å«äº†è¯¥æ–‡ä»¶ç³»ç»Ÿçš„ç±»å‹ã€çŠ¶æ€ã€æ“ä½œç­‰ä¿¡æ¯ã€‚ ä»¥tmpfsæ–‡ä»¶ç³»ç»Ÿä¸ºä¾‹ å½“å†…æ ¸å¯åŠ¨æ—¶ï¼Œä¼šæ‰§è¡Œshmem_initå‡½æ•°ï¼ˆå®šä¹‰åœ¨mm/shmem.cæ–‡ä»¶ä¸­ï¼‰ã€‚è¿™ä¸ªå‡½æ•°ä¼šè°ƒç”¨register_filesystemæ³¨å†Œtmpfsæ–‡ä»¶ç³»ç»Ÿã€‚ shmem_init identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __init shmem_init(void)&#123;// åˆå§‹åŒ– inode ç¼“å­˜shmem_init_inodecache();// æ³¨å†Œ tmpfs æ–‡ä»¶ç³»ç»Ÿint error = register_filesystem(&amp;shmem_fs_type);if (error) &#123; // è‹¥æ³¨å†Œå¤±è´¥ï¼Œæ‰“å°é”™è¯¯ä¿¡æ¯ pr_err(&quot;Could not register tmpfs\\n&quot;); // è·³è½¬åˆ° out2ï¼Œæ‰§è¡Œæ¸…ç†æ“ä½œ goto out2;&#125;// å°è¯•æŒ‚è½½ tmpfs æ–‡ä»¶ç³»ç»Ÿshm_mnt = kern_mount(&amp;shmem_fs_type);if (IS_ERR(shm_mnt)) &#123; // è‹¥æŒ‚è½½å¤±è´¥ï¼Œè·å–é”™è¯¯ä»£ç  error = PTR_ERR(shm_mnt); // æ‰“å°é”™è¯¯ä¿¡æ¯ pr_err(&quot;Could not kern_mount tmpfs\\n&quot;); // è·³è½¬åˆ° out1ï¼Œæ‰§è¡Œæ¸…ç†æ“ä½œ goto out1;&#125;#ifdef CONFIG_TRANSPARENT_HUGEPAGE// å¦‚æœæ”¯æŒé€æ˜å·¨é¡µï¼Œä¸”å·¨é¡µè®¾ç½®ä¸ä¸ºç¦ç”¨ï¼Œè®¾ç½®å·¨é¡µé€‰é¡¹if (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY) SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;else // å¦åˆ™ï¼Œå°†å·¨é¡µè®¾ç½®ä¸ºæ°¸ä¸ä½¿ç”¨ï¼Œä»¥é˜²ä¸‡ä¸€ shmem_huge = SHMEM_HUGE_NEVER;#endif// æˆåŠŸæ‰§è¡Œï¼Œå‡½æ•°è¿”å›return;out1:// æ¸…ç†æ“ä½œï¼šæ³¨é”€ tmpfs æ–‡ä»¶ç³»ç»Ÿunregister_filesystem(&amp;shmem_fs_type);out2:// æ¸…ç†æ“ä½œï¼šé”€æ¯ inode ç¼“å­˜shmem_destroy_inodecache();// è®¾ç½® shm_mnt ä¸ºé”™è¯¯æŒ‡é’ˆï¼Œè¡¨ç¤ºåˆå§‹åŒ–å¤±è´¥shm_mnt = ERR_PTR(error);&#125; shmem_fs_typeæ˜¯ä¸€ä¸ªfile_system_typeç»“æ„ä½“ï¼Œå®šä¹‰äº†tmpfsæ–‡ä»¶ç³»ç»Ÿçš„åŸºæœ¬ä¿¡æ¯ã€‚åœ¨è¿™ä¸ªç»“æ„ä½“ä¸­ï¼Œinit_fs_contextæˆå‘˜è¢«è®¾ç½®ä¸ºshmem_init_fs_contextã€‚ shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314static struct file_system_type shmem_fs_type = &#123;.owner = THIS_MODULE, // æŒ‡å®šæ–‡ä»¶ç³»ç»Ÿæ¨¡å—çš„æ‰€æœ‰è€….name = &quot;tmpfs&quot;, // æ–‡ä»¶ç³»ç»Ÿçš„åç§°.init_fs_context = shmem_init_fs_context, // åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„å›è°ƒå‡½æ•°#ifdef CONFIG_TMPFS.parameters = shmem_fs_parameters, // æŒ‡å®šæ–‡ä»¶ç³»ç»Ÿçš„æŒ‚è½½å‚æ•°è§£æå›è°ƒ#endif.kill_sb = kill_litter_super, // ç”¨äºé”€æ¯è¶…çº§å—çš„å›è°ƒå‡½æ•°#ifdef CONFIG_SHMEM.fs_flags = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, // æ–‡ä»¶ç³»ç»Ÿçš„æ ‡å¿—ï¼ˆæ”¯æŒç”¨æˆ·å‘½åç©ºé—´æŒ‚è½½å’ŒIDæ˜ å°„ï¼‰#else.fs_flags = FS_USERNS_MOUNT, // æ–‡ä»¶ç³»ç»Ÿçš„æ ‡å¿—ï¼ˆä»…æ”¯æŒç”¨æˆ·å‘½åç©ºé—´æŒ‚è½½ï¼‰#endif&#125;; å½“ä¸€ä¸ªæ–°çš„æ–‡ä»¶ç³»ç»Ÿéœ€è¦è¢«æ”¯æŒæ—¶ï¼Œå®ƒéœ€è¦ä½¿ç”¨ register_filesystem() å‡½æ•°å°†è‡ªå·±æ³¨å†Œåˆ° VFSã€‚è¿™æ ·ï¼ŒVFS å°±å¯ä»¥è¯†åˆ«å’Œå¤„ç†è¿™ä¸ªæ–°çš„æ–‡ä»¶ç³»ç»Ÿã€‚ register_filesystem identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * register_filesystem - æ³¨å†Œä¸€ä¸ªæ–°çš„æ–‡ä»¶ç³»ç»Ÿ * @fs: æ–‡ä»¶ç³»ç»Ÿç»“æ„ä½“ * * å°†ä¼ å…¥çš„æ–‡ä»¶ç³»ç»Ÿæ·»åŠ åˆ°å†…æ ¸å·²çŸ¥çš„æ–‡ä»¶ç³»ç»Ÿåˆ—è¡¨ä¸­ï¼Œä¾›æŒ‚è½½å’Œå…¶ä»–ç³»ç»Ÿè°ƒç”¨ä½¿ç”¨ã€‚ * æˆåŠŸæ—¶è¿”å›0ï¼Œå‡ºé”™æ—¶è¿”å›ä¸€ä¸ªè´Ÿçš„errnoé”™è¯¯ç ã€‚ * * ä¼ å…¥çš„ &amp;struct file_system_type ç»“æ„ä½“å°†é“¾æ¥åˆ°å†…æ ¸ç»“æ„ä¸­ï¼Œ * åœ¨æ–‡ä»¶ç³»ç»Ÿæœªæ³¨é”€ä¹‹å‰ï¼Œä¸åº”è¯¥è¢«é‡Šæ”¾ã€‚ */int register_filesystem(struct file_system_type * fs)&#123; int res = 0; // åˆå§‹åŒ–ç»“æœä¸º0ï¼Œè¡¨ç¤ºæˆåŠŸ struct file_system_type ** p; // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿå‚æ•°æ˜¯å¦æœ‰æ•ˆ if (fs-&gt;parameters &amp;&amp; !fs_validate_description(fs-&gt;name, fs-&gt;parameters)) return -EINVAL; // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿåç§°ä¸­æ˜¯å¦åŒ…å«éæ³•å­—ç¬¦ &#x27;.&#x27; BUG_ON(strchr(fs-&gt;name, &#x27;.&#x27;)); // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å·²ç»é“¾æ¥åˆ°å…¶ä»–æ–‡ä»¶ç³»ç»Ÿ if (fs-&gt;next) return -EBUSY; // è·å– file_systems_lock å†™é”ï¼Œä»¥ä¿æŠ¤ file_systems é“¾è¡¨ write_lock(&amp;file_systems_lock); // æŸ¥æ‰¾å…·æœ‰ç›¸åŒåç§°çš„æ–‡ä»¶ç³»ç»Ÿ p = find_filesystem(fs-&gt;name, strlen(fs-&gt;name)); // å¦‚æœæ‰¾åˆ°äº†å…·æœ‰ç›¸åŒåç§°çš„æ–‡ä»¶ç³»ç»Ÿï¼Œè¿”å› -EBUSY if (*p) res = -EBUSY; else // å¦åˆ™ï¼Œå°†æ–°çš„æ–‡ä»¶ç³»ç»Ÿé“¾æ¥åˆ° file_systems é“¾è¡¨ä¸­ *p = fs; // é‡Šæ”¾ file_systems_lock å†™é” write_unlock(&amp;file_systems_lock); // è¿”å›ç»“æœ return res;&#125;EXPORT_SYMBOL(register_filesystem); // å¯¼å‡º register_filesystem ç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨k); return res;&#125; æ ¹æ–‡ä»¶ç³»ç»Ÿæ³¨å†Œæ–‡ä»¶ç³»ç»Ÿç±»å‹ æ³¨å†Œrootfsæ˜¯åœ¨init_rootfsä¸­å®Œæˆçš„ init_rootfs identifier - Linux source code (v6.3.8) - Bootlin 123456void __init init_rootfs(void)&#123; if (IS_ENABLED(CONFIG_TMPFS) &amp;&amp; !saved_root_name[0] &amp;&amp; (!root_fs_names || strstr(root_fs_names, &quot;tmpfs&quot;))) is_tmpfs = true;&#125; ä¸»è¦å·¥ä½œå°±æ˜¯æ³¨å†Œrootfs_fs_type rootfs_fs_type identifier - Linux source code (v6.3.8) - Bootlin 12345struct file_system_type rootfs_fs_type = &#123; .name = &quot;rootfs&quot;, .init_fs_context = rootfs_init_fs_context, .kill_sb = kill_litter_super,&#125;; æŒ‚è½½æ ¹æ–‡ä»¶ç³»ç»Ÿ init_mount_tree è°ƒç”¨vfs_kern_mountï¼Œåˆ›å»ºåå­—ç©ºé—´ï¼Œè®¾ç½®è¿›ç¨‹pwd&#x2F;rootè·¯å¾„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static void __init init_mount_tree(void)&#123; // å£°æ˜ä¸€ä¸ªæŒ‡å‘ vfsmount ç»“æ„ä½“çš„æŒ‡é’ˆ mntï¼Œç”¨äºè¡¨ç¤ºæŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿ struct vfsmount *mnt; // å£°æ˜ä¸€ä¸ªæŒ‡å‘ mount ç»“æ„ä½“çš„æŒ‡é’ˆ mï¼Œç”¨äºè¡¨ç¤ºæŒ‚è½½ç‚¹ struct mount *m; // å£°æ˜ä¸€ä¸ªæŒ‡å‘ mnt_namespace ç»“æ„ä½“çš„æŒ‡é’ˆ nsï¼Œç”¨äºè¡¨ç¤ºæŒ‚è½½å‘½åç©ºé—´ struct mnt_namespace *ns; // å£°æ˜ä¸€ä¸ª path ç»“æ„ä½“å˜é‡ rootï¼Œç”¨äºè¡¨ç¤ºæ ¹è·¯å¾„ struct path root; // è°ƒç”¨ vfs_kern_mount å‡½æ•°æŒ‚è½½ root æ–‡ä»¶ç³»ç»Ÿï¼Œè¿”å›æŒ‚è½½å¯¹è±¡çš„æŒ‡é’ˆ mnt = vfs_kern_mount(&amp;rootfs_fs_type, 0, &quot;rootfs&quot;, NULL); // æ£€æŸ¥ mnt æ˜¯å¦åŒ…å«é”™è¯¯æŒ‡é’ˆ if (IS_ERR(mnt)) panic(&quot;Can&#x27;t create rootfs&quot;); // å¦‚æœå­˜åœ¨é”™è¯¯ï¼Œè¾“å‡ºé”™è¯¯ä¿¡æ¯å¹¶ç»ˆæ­¢å†…æ ¸ // ä¸ºæ–°çš„å‘½åç©ºé—´åˆ†é…å†…å­˜ ns = alloc_mnt_ns(&amp;init_user_ns, false); // æ£€æŸ¥ ns æ˜¯å¦åŒ…å«é”™è¯¯æŒ‡é’ˆ if (IS_ERR(ns)) panic(&quot;Can&#x27;t allocate initial namespace&quot;); // å¦‚æœå­˜åœ¨é”™è¯¯ï¼Œè¾“å‡ºé”™è¯¯ä¿¡æ¯å¹¶ç»ˆæ­¢å†…æ ¸ // è·å– mnt å¯¹åº”çš„çœŸå®æŒ‚è½½ç‚¹ m = real_mount(mnt); // å°†æ–°åˆ†é…çš„å‘½åç©ºé—´ ns èµ‹å€¼ç»™æŒ‚è½½ç‚¹ m çš„å‘½åç©ºé—´å­—æ®µ m-&gt;mnt_ns = ns; // å°†æŒ‚è½½ç‚¹ m è®¾ç½®ä¸ºå‘½åç©ºé—´çš„æ ¹æŒ‚è½½ç‚¹ ns-&gt;root = m; // åˆå§‹åŒ–å‘½åç©ºé—´çš„æŒ‚è½½è®¡æ•°ä¸º 1 ns-&gt;mounts = 1; // å°†æŒ‚è½½ç‚¹ m æ·»åŠ åˆ°å‘½åç©ºé—´çš„æŒ‚è½½åˆ—è¡¨ä¸­ list_add(&amp;m-&gt;mnt_list, &amp;ns-&gt;list); // å°†æ–°åˆ†é…çš„å‘½åç©ºé—´ ns è®¾ç½®ä¸ºåˆå§‹ä»»åŠ¡çš„å‘½åç©ºé—´ä»£ç† init_task.nsproxy-&gt;mnt_ns = ns; // å¢åŠ å‘½åç©ºé—´çš„å¼•ç”¨è®¡æ•° get_mnt_ns(ns); // è®¾ç½®æ ¹è·¯å¾„çš„æŒ‚è½½å¯¹è±¡ä¸º mnt root.mnt = mnt; // è®¾ç½®æ ¹è·¯å¾„çš„ç›®å½•é¡¹ä¸ºæŒ‚è½½å¯¹è±¡çš„æ ¹ç›®å½•é¡¹ root.dentry = mnt-&gt;mnt_root; // è®¾ç½®æŒ‚è½½å¯¹è±¡çš„æ ‡å¿—ä½ä¸ºå·²é”å®š mnt-&gt;mnt_flags |= MNT_LOCKED; // è®¾ç½®å½“å‰ä»»åŠ¡çš„æ–‡ä»¶ç³»ç»Ÿå·¥ä½œç›®å½•ä¸ºæ–°çš„æ ¹è·¯å¾„ set_fs_pwd(current-&gt;fs, &amp;root); // è®¾ç½®å½“å‰ä»»åŠ¡çš„æ–‡ä»¶ç³»ç»Ÿæ ¹ç›®å½•ä¸ºæ–°çš„æ ¹è·¯å¾„ set_fs_root(current-&gt;fs, &amp;root);&#125; vfs_kern_mount åˆ†é…mountï¼Œè°ƒç”¨mount_fsæ¥æ‰§è¡ŒæŒ‚è½½æ“ä½œï¼Œå»ºç«‹æŒ‚è½½ç‚¹å…³ç³» vfs_kern_mount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct vfsmount *vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)&#123; // å£°æ˜ä¸€ä¸ªæŒ‡å‘ fs_context ç»“æ„ä½“çš„æŒ‡é’ˆ fcï¼Œç”¨äºè¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ struct fs_context *fc; // å£°æ˜ä¸€ä¸ªæŒ‡å‘ vfsmount ç»“æ„ä½“çš„æŒ‡é’ˆ mntï¼Œç”¨äºè¡¨ç¤ºæŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿ struct vfsmount *mnt; // å£°æ˜ä¸€ä¸ªæ•´å‹å˜é‡ retï¼Œç”¨äºå­˜å‚¨è¿”å›å€¼ int ret = 0; // æ£€æŸ¥ä¼ å…¥çš„æ–‡ä»¶ç³»ç»Ÿç±»å‹æŒ‡é’ˆ type æ˜¯å¦ä¸ºç©º if (!type) return ERR_PTR(-EINVAL); // å¦‚æœä¸ºç©ºï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ // è°ƒç”¨ fs_context_for_mount å‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ fc = fs_context_for_mount(type, flags); // æ£€æŸ¥åˆ›å»ºçš„æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡æ˜¯å¦åŒ…å«é”™è¯¯æŒ‡é’ˆ if (IS_ERR(fc)) return ERR_CAST(fc); // å¦‚æœå­˜åœ¨é”™è¯¯ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ // æ£€æŸ¥ä¼ å…¥çš„åç§°å‚æ•° name æ˜¯å¦éç©º if (name) // è°ƒç”¨ vfs_parse_fs_string å‡½æ•°è§£ææ–‡ä»¶ç³»ç»Ÿåç§° ret = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // æ£€æŸ¥ ret æ˜¯å¦ä¸º 0ï¼ˆè¡¨ç¤ºæ— é”™è¯¯ï¼‰ if (!ret) // è°ƒç”¨ parse_monolithic_mount_data å‡½æ•°è§£æä¼ å…¥çš„æŒ‚è½½æ•°æ® ret = parse_monolithic_mount_data(fc, data); // æ£€æŸ¥ ret æ˜¯å¦ä¸º 0ï¼ˆè¡¨ç¤ºæ— é”™è¯¯ï¼‰ if (!ret) // è°ƒç”¨ fc_mount å‡½æ•°æ‰§è¡ŒæŒ‚è½½æ“ä½œï¼Œå¹¶å°†ç»“æœèµ‹å€¼ç»™ mnt mnt = fc_mount(fc); else // å¦‚æœå­˜åœ¨é”™è¯¯ï¼Œå°† ret è½¬æ¢ä¸ºé”™è¯¯æŒ‡é’ˆå¹¶èµ‹å€¼ç»™ mnt mnt = ERR_PTR(ret); // é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ put_fs_context(fc); // è¿”å›æŒ‚è½½çš„æ–‡ä»¶ç³»ç»ŸæŒ‡é’ˆ mnt return mnt;&#125;EXPORT_SYMBOL_GPL(vfs_kern_mount); fc_mount ç”¨äºæŒ‚è½½ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿ vfs_get_tree identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * vfs_get_tree - Get the mountable root * @fc: The superblock configuration context. * * The filesystem is invoked to get or create a superblock which can then later * be used for mounting. The filesystem places a pointer to the root to be * used for mounting in @fc-&gt;root. */int vfs_get_tree(struct fs_context *fc)&#123; // å£°æ˜ä¸€ä¸ªæŒ‡å‘ super_block ç»“æ„ä½“çš„æŒ‡é’ˆ sbï¼Œç”¨äºè¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿçš„è¶…çº§å— struct super_block *sb; // å£°æ˜ä¸€ä¸ªæ•´å‹å˜é‡ errorï¼Œç”¨äºå­˜å‚¨è¿”å›å€¼ int error; // æ£€æŸ¥ä¼ å…¥çš„æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ fc çš„ root æ˜¯å¦å·²ç»è®¾ç½® if (fc-&gt;root) return -EBUSY; // å¦‚æœå·²ç»è®¾ç½®ï¼Œè¿”å›é”™è¯¯ä»£ç  -EBUSY // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼ˆopsï¼‰ä¸­çš„ get_tree å‡½æ•°ï¼Œè·å–æˆ–åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿæ ‘ error = fc-&gt;ops-&gt;get_tree(fc); if (error &lt; 0) return error; // å¦‚æœæ“ä½œå¤±è´¥ï¼Œè¿”å›é”™è¯¯ä»£ç  // æ£€æŸ¥ fc-&gt;root æ˜¯å¦å·²ç»è®¾ç½® if (!fc-&gt;root) &#123; // å¦‚æœæ²¡æœ‰è®¾ç½®ï¼Œè¾“å‡ºé”™è¯¯ä¿¡æ¯ï¼Œå¹¶è§¦å‘ BUGï¼ˆå†…æ ¸è°ƒè¯•å®ï¼‰ pr_err(&quot;Filesystem %s get_tree() didn&#x27;t set fc-&gt;root\\n&quot;, fc-&gt;fs_type-&gt;name); BUG(); &#125; // è·å–è¶…çº§å—æŒ‡é’ˆ sb = fc-&gt;root-&gt;d_sb; // æ£€æŸ¥è¶…çº§å—çš„å—è®¾å¤‡æ˜ å°„ (s_bdi) æ˜¯å¦å·²ç»è®¾ç½® WARN_ON(!sb-&gt;s_bdi); // å°†å†™å†…å­˜å±éšœæ”¾åœ¨è®¾ç½® SB_BORN æ ‡å¿—ä½ä¹‹å‰ï¼Œä»¥ç¡®ä¿è¶…çº§å—ç»“æ„å·²ç»è®¾ç½®å®Œæˆ smp_wmb(); // ä¸ºè¶…çº§å—è®¾ç½® SB_BORN æ ‡å¿—ä½ï¼Œè¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿå·²ç»åˆ›å»º sb-&gt;s_flags |= SB_BORN; // è°ƒç”¨ security_sb_set_mnt_opts å‡½æ•°è®¾ç½®å®‰å…¨æ¨¡å—çš„æŒ‚è½½é€‰é¡¹ error = security_sb_set_mnt_opts(sb, fc-&gt;security, 0, NULL); if (unlikely(error)) &#123; // å¦‚æœè®¾ç½®å¤±è´¥ï¼Œé‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„å¼•ç”¨å¹¶è¿”å›é”™è¯¯ä»£ç  fc_drop_locked(fc); return error; &#125; // è¾“å‡ºè­¦å‘Šä¿¡æ¯ï¼Œå¦‚æœæ–‡ä»¶ç³»ç»Ÿè®¾ç½®çš„ s_maxbytes å€¼å°äº 0 WARN((sb-&gt;s_maxbytes &lt; 0), &quot;%s set sb-&gt;s_maxbytes to &quot; &quot;negative value (%lld)\\n&quot;, fc-&gt;fs_type-&gt;name, sb-&gt;s_maxbytes); // è¿”å›æ“ä½œæˆåŠŸï¼ˆé”™è¯¯ä»£ç ä¸º 0ï¼‰ return 0;&#125;EXPORT_SYMBOL(vfs_get_tree); å®‰è£…æ ¹æ–‡ä»¶ç³»ç»Ÿæ˜¯ç³»ç»Ÿåˆå§‹åŒ–çš„å…³é”®éƒ¨åˆ†ã€‚å½“ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œå°±è¦åœ¨å˜é‡ROOT_DEVä¸­å¯»æ‰¾åŒ…å«æ ¹æ–‡ä»¶ç³»ç»Ÿçš„ç£ç›˜ä¸»ç ã€‚å½“ç¼–è¯‘å†…æ ¸æˆ–å‘æœ€åˆçš„å¯åŠ¨è£…å…¥ç¨‹åºä¼ é€’ä¸€ä¸ªåˆé€‚çš„é€‰é¡¹æ—¶ï¼Œæ ¹æ–‡ä»¶ç³»ç»Ÿå¯ä»¥è¢«æŒ‡å®šä¸º&#x2F;devç›®å½•ä¸‹çš„ä¸€ä¸ªè®¾å¤‡æ–‡ä»¶ã€‚ç±»ä¼¼åœ°ï¼Œæ ¹æ–‡ä»¶ç³»ç»Ÿçš„å®‰è£…æ ‡å¿—å­˜æ”¾åœ¨root_mountflagså˜é‡ä¸­ã€‚ç”¨æˆ·å¯ä»¥æŒ‡å®šè¿™äº›æ ‡å¿—ï¼Œè¿™æ˜¯é€šè¿‡å¯¹å·²ç¼–è¯‘çš„å†…æ ¸æ˜ åƒä½¿ç”¨&#x2F;sbin&#x2F;rdevå¤–éƒ¨ç¨‹åºï¼Œæˆ–è€…å‘æœ€åˆçš„å¯åŠ¨è£…å…¥ç¨‹åºä¼ é€’ä¸€ä¸ªåˆé€‚çš„é€‰é¡¹æ¥è¾¾åˆ°çš„ã€‚ åœ¨ç³»ç»Ÿåˆå§‹åŒ–æœŸé—´ï¼Œmount_root()å®‰è£…æ ¹æ–‡ä»¶ç³»ç»Ÿã€‚ mount_root identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435void __init mount_root(void) &#123; #ifdef CONFIG_ROOT_NFS // å¦‚æœæ ¹æ–‡ä»¶ç³»ç»Ÿä½äº NFS ä¸Š,å°è¯•æŒ‚è½½ NFS æ ¹æ–‡ä»¶ç³»ç»Ÿ if (ROOT_DEV == Root_NFS) &#123; if (!mount_nfs_root()) printk(KERN_ERR &quot;VFS: Unable to mount root fs via NFS.\\n&quot;); return; &#125; #endif #ifdef CONFIG_CIFS_ROOT // å¦‚æœæ ¹æ–‡ä»¶ç³»ç»Ÿä½äº CIFS(SMB) ä¸Š,å°è¯•æŒ‚è½½ CIFS æ ¹æ–‡ä»¶ç³»ç»Ÿ if (ROOT_DEV == Root_CIFS) &#123; if (!mount_cifs_root()) printk(KERN_ERR &quot;VFS: Unable to mount root fs via SMB.\\n&quot;); return; &#125; #endif if (ROOT_DEV == 0 &amp;&amp; root_device_name &amp;&amp; root_fs_names) &#123; // å¦‚æœæ ¹è®¾å¤‡ä¸ºç©º(0),å¹¶ä¸”å‘½ä»¤è¡ŒæŒ‡å®šäº†æ ¹è®¾å¤‡åå’Œæ ¹æ–‡ä»¶ç³»ç»Ÿç±»å‹, // å°è¯•æŒ‚è½½ä¸€ä¸ªæ— å—è®¾å¤‡çš„æ ¹æ–‡ä»¶ç³»ç»Ÿ(å¦‚ initramfs)ã€‚ if (mount_nodev_root() == 0) return; &#125; #ifdef CONFIG_BLOCK &#123; // ä¸ºæ ¹å—è®¾å¤‡åˆ›å»ºä¸€ä¸ª /dev/root èŠ‚ç‚¹ int err = create_dev(&quot;/dev/root&quot;, ROOT_DEV); if (err &lt; 0) pr_emerg(&quot;Failed to create /dev/root: %d\\n&quot;, err); // ä½¿ç”¨ /dev/root å’ŒæŒ‡å®šçš„æŒ‚è½½æ ‡å¿—æ¥æŒ‚è½½å—è®¾å¤‡æ ¹æ–‡ä»¶ç³»ç»Ÿ mount_block_root(&quot;/dev/root&quot;, root_mountflags); &#125; #endif &#125; å®‰è£…ä¸€ä¸ªæ™®é€šçš„æ–‡ä»¶ç³»ç»Ÿä¸€æ—¦å®Œæˆå¯¹æ ¹æ–‡ä»¶ç³»ç»Ÿçš„åˆå§‹åŒ–ï¼Œå°±å¯ä»¥å®‰è£…å…¶ä»–çš„æ–‡ä»¶ç³»ç»Ÿã€‚å…¶ä¸­çš„æ¯ä¸€ä¸ªéƒ½æœ‰è‡ªå·±çš„å®‰è£…ç‚¹ï¼Œå®‰è£…ç‚¹ä»…ä»…æ˜¯ç³»ç»Ÿç›®å½•æ ‘ä¸­ç°æœ‰çš„ä¸€ä¸ªç›®å½•ã€‚ æ‰“å¼€æ–‡ä»¶æˆ–è€…åˆ›å»ºæ–‡ä»¶ ä¸€ä¸ªä¸»è¦æ“ä½œæ˜¯æ ¹æ®ç»™å®šçš„æ–‡ä»¶åæŸ¥æ‰¾inodeï¼Œè¿™ä½¿å¾—æˆ‘ä»¬é¦–å…ˆéœ€è¦äº†è§£æœ‰å…³æŸ¥æ‰¾è¯¥ä¿¡æ¯çš„æœºåˆ¶ã€‚ nameidataç»“æ„ä½“ç”¨æ¥æŸ¥æ‰¾å‡½æ•°ä¼ é€’å‚æ•°æ•°ï¼Œå¹¶ä¿å­˜æŸ¥æ‰¾ç»“æœã€‚ nameidata identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324#define EMBEDDED_LEVELS 2struct nameidata &#123; struct path path; // è·¯å¾„å¯¹è±¡ï¼Œè¡¨ç¤ºè·¯å¾„ struct qstr last; // æœ€åçš„è·¯å¾„ç»„ä»¶ struct path root; // æ–‡ä»¶ç³»ç»Ÿçš„æ ¹è·¯å¾„ struct inode *inode; // æŒ‡å‘è·¯å¾„ä¸­çš„ç›®å½•é¡¹çš„èŠ‚ç‚¹ (path.dentry.d_inode) unsigned int flags, state; // æ ‡å¿—ä½å’ŒçŠ¶æ€ unsigned seq, next_seq, m_seq, r_seq; // ç”¨äºåºåˆ—å·çš„å˜é‡ int last_type; // æœ€åè·¯å¾„ç»„ä»¶çš„ç±»å‹ unsigned depth; // é“¾æ¥æ·±åº¦ int total_link_count; // æ€»çš„é“¾æ¥æ•° struct saved &#123; // ä¿å­˜ç»“æ„ï¼Œç”¨äºé“¾æ¥è·Ÿè¸ª struct path link; // é“¾æ¥è·¯å¾„ struct delayed_call done; // å»¶è¿Ÿè°ƒç”¨ const char *name; // é“¾æ¥åç§° unsigned seq; // åºåˆ—å· &#125; *stack, internal[EMBEDDED_LEVELS]; // ä¿å­˜ç»“æ„çš„æ ˆå’Œå†…éƒ¨æ•°ç»„ struct filename *name; // æ–‡ä»¶åå¯¹è±¡ struct nameidata *saved; // æŒ‡å‘ä¿å­˜çš„nameidataç»“æ„ unsigned root_seq; // æ ¹è·¯å¾„åºåˆ—å· int dfd; // ç›®å½•æ–‡ä»¶æè¿°ç¬¦ vfsuid_t dir_vfsuid; // ç›®å½•çš„VFSç”¨æˆ·ID umode_t dir_mode; // ç›®å½•çš„æ¨¡å¼ (æƒé™)&#125; __randomize_layout; // éšæœºåŒ–å¸ƒå±€å±æ€§ åœ¨èµ°ä¸€æ¡è·¯çš„æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œå½“å‰çŠ¶æ€å­˜å‚¨åœ¨ä¸€ä¸ª struct nameidata ï¼Œâ€œnameiâ€æ˜¯å°†â€œåç§°â€è½¬æ¢ä¸ºâ€œinodeâ€çš„å‡½æ•°çš„ä¼ ç»Ÿåç§° - å¯ä»¥è¿½æº¯åˆ°ç¬¬ä¸€ç‰ˆUnixã€‚ struct nameidata åŒ…å«ï¼ˆé™¤å…¶ä»–å­—æ®µå¤–ï¼‰ï¼š pathåŒ…å«äº†æ‰¾åˆ°çš„æ–‡ä»¶ç³»ç»Ÿé¡¹çš„æ•°æ®ï¼Œpathç»“æ„åŒ…å«dentryå’Œmntã€‚ struct path path path identifier - Linux source code (v6.3.8) - Bootlin 1234struct path &#123; struct vfsmount *mnt; struct dentry *dentry;&#125; __randomize_layout; åŒ…å«struct vfsmountå’Œstruct dentryï¼Œè¿™äº›ä¸€èµ·è®°å½•äº†ç°åœ¨walkçš„çŠ¶æ€ï¼Œä»–ä»¬é¦–å…ˆã€‚å®ƒä»¬é¦–å…ˆå¼•ç”¨èµ·ç‚¹ï¼ˆå½“å‰å·¥ä½œç›®å½•ï¼Œæ ¹ç›®å½•æˆ–ç”±æ–‡ä»¶æè¿°ç¬¦æ ‡è¯†çš„å…¶ä»–ç›®å½•ï¼‰ï¼Œå¹¶åœ¨æ¯ä¸€æ­¥ä¸­æ›´æ–°ï¼Œå³åœ¨éå†è¿‡ç¨‹çš„æ¯ä¸€æ­¥ä¸­ï¼Œè¿™äº›ç»“æ„ä½“éƒ½ä¼šæ›´æ–°ã€‚é€šè¿‡d_lockrefå’Œmnt_countå§‹ç»ˆæŒæœ‰çš„å¼•ç”¨ã€‚ struct qstr last è¿™æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé•¿åº¦ï¼ˆå³æœª nul ç»ˆæ­¢ï¼‰æ˜¯è·¯å¾„åä¸­çš„â€œä¸‹ä¸€ä¸ªâ€ç»„ä»¶ã€‚ qstr identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213141516/* * &quot;quick string&quot; -- eases parameter passing, but more importantly * saves &quot;metadata&quot; about the string (ie length and the hash). * * hash comes first so it snuggles against d_parent in the * dentry. */struct qstr &#123; union &#123; struct &#123; HASH_LEN_DECLARE; &#125;; u64 hash_len; &#125;; const unsigned char *name;&#125;; int last_type è¿™æ˜¯LAST_NORM, LAST_ROOT, LAST_DOT æˆ–è€… LAST_DOTDOTå…¶ä¸­ä¸€ä¸ªã€‚ struct path root ç”¨äºåœ¨å†…æ ¸ä¸­è¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿçš„æœ‰æ•ˆæ ¹ç›®å½•ã€‚åœ¨è·¯å¾„æŸ¥æ‰¾è¿‡ç¨‹ä¸­ï¼Œå®ƒå¯ä»¥ç¡®ä¿å§‹ç»ˆæœ‰ä¸€ä¸ªæœ‰æ•ˆçš„æ ¹ç›®å½•å‚è€ƒã€‚è¿™ä¸ªç»“æ„ä½“åŒ…å«ä¸¤ä¸ªä¸»è¦æˆå‘˜ï¼šdentry å’Œ mntã€‚dentry æ˜¯ç›®å½•é¡¹ï¼Œç”¨äºè¡¨ç¤ºç›®å½•ç»“æ„ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚mnt æ˜¯ä¸€ä¸ª vfsmount ç»“æ„ï¼Œä»£è¡¨ä¸€ä¸ªæŒ‚è½½ç‚¹ï¼Œç”¨äºè¿æ¥ä¸åŒæ–‡ä»¶ç³»ç»Ÿã€‚ä¾‹å¦‚æŸ¥æ‰¾/home/path/test.txtæ—¶ï¼Œæ ¹ç›®å½•å°±æ˜¯/ï¼Œrootè¡¨ç¤ºçš„å°±æ˜¯&#x2F;çš„ä¿¡æ¯ã€‚ ä¿è¯è·¯å¾„æŸ¥æ‰¾ä¸ä¼šè¶…å‡ºç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„è¾¹ç•Œã€‚å½“ä½¿ç”¨åƒ chroot() è¿™æ ·çš„ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œstruct path root å¯ä»¥ç¡®ä¿è·¯å¾„æŸ¥æ‰¾ä»…é™äºæŒ‡å®šçš„æ–‡ä»¶ç³»ç»Ÿå­æ ‘ã€‚ åœ¨å¤„ç†åƒ NFSv4ã€Btrfs è¿™æ ·çš„åˆ†å¸ƒå¼æˆ–è€…å±‚æ¬¡åŒ–æ–‡ä»¶ç³»ç»Ÿæ—¶ï¼Œstruct path root å¯ä»¥ç¡®ä¿æ­£ç¡®å¤„ç†ä¸åŒå­æ ‘çš„æ ¹ç›®å½•ï¼Œé˜²æ­¢è·¯å¾„æŸ¥æ‰¾é”™è¯¯åœ°è·³è½¬åˆ°å…¶ä»–å­æ ‘æˆ–æ–‡ä»¶ç³»ç»Ÿã€‚ åœ¨å¤„ç†ç‰¹æ®Šçš„è·¯å¾„æ“ä½œï¼Œå¦‚ LOOKUP_IN_ROOT å’Œ LOOKUP_BENEATH æ—¶ï¼Œstruct path root å¯ä»¥ç¡®ä¿è·¯å¾„æŸ¥æ‰¾ä»¥ç‰¹å®šç›®å½•ä½œä¸ºæ ¹è·¯å¾„è¿›è¡Œã€‚ åœ¨å¤„ç†ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„æ—¶ï¼Œstruct path root å¯ä»¥ä½œä¸ºæŸ¥æ‰¾çš„åŸºå‡†ç‚¹ã€‚ä¾‹å¦‚ï¼Œå½“è·¯å¾„åä»¥ / å¼€å¤´ï¼Œæˆ–è€…å¤„ç† .. ç»„ä»¶æ—¶ï¼Œstruct path root æ˜¯å¿…éœ€çš„ã€‚ ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å¿½ç•¥ç¬¦å·é“¾æ¥çš„å¤„ç†ï¼Œæè¿° link_path_walk() å‡½æ•°ï¼Œè¯¥å‡½æ•°å¤„ç†é™¤æœ€åä¸€ä¸ªç»„ä»¶ä¹‹å¤–çš„æ‰€æœ‰å†…å®¹ï¼š ç»™å®šä¸€ä¸ªè·¯å¾„ï¼ˆnameï¼‰å’Œä¸€ä¸ª nameidata ç»“æ„ï¼ˆndï¼‰ï¼Œæ£€æŸ¥å½“å‰ç›®å½•æ˜¯å¦å…·æœ‰æ‰§è¡Œæƒé™ï¼Œç„¶åå°† name é€ä¸ªæ¨è¿›åˆ°ä¸€ä¸ªç»„ä»¶ï¼ŒåŒæ—¶æ›´æ–° last_type å’Œ lastã€‚å¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªç»„ä»¶ï¼Œåˆ™è¿”å›ï¼›å¦åˆ™è°ƒç”¨ walk_component() å¹¶ä»é¡¶éƒ¨é‡å¤ã€‚ walk_component() å‡½æ•°éå¸¸ç®€å•ã€‚å¦‚æœç»„ä»¶æ˜¯ LAST_DOTSï¼Œå®ƒä¼šè°ƒç”¨ handle_dots()ï¼Œè¯¥å‡½æ•°ä¼šæ‰§è¡Œå·²ç»æè¿°è¿‡çš„å¿…è¦é”å®šæ“ä½œã€‚å¦‚æœæ‰¾åˆ° LAST_NORM ç»„ä»¶ï¼Œå®ƒé¦–å…ˆè°ƒç”¨ lookup_fast()ï¼Œè¯¥å‡½æ•°ä»…åœ¨ç›®å½•ç¼“å­˜ä¸­æŸ¥æ‰¾ï¼Œä½†å¦‚æœæ˜¯éœ€è¦é‡æ–°éªŒè¯ç»“æœçš„æ–‡ä»¶ç³»ç»Ÿç±»å‹ï¼Œå®ƒä¼šè¦æ±‚æ–‡ä»¶ç³»ç»Ÿé‡æ–°éªŒè¯ç»“æœã€‚å¦‚æœæ²¡æœ‰å¾—åˆ°å¥½çš„ç»“æœï¼Œå®ƒä¼šè°ƒç”¨ lookup_slow()ï¼Œè¯¥å‡½æ•°ä¼šè·å– i_rwsemï¼Œé‡æ–°æ£€æŸ¥ç¼“å­˜ï¼Œç„¶åè¦æ±‚æ–‡ä»¶ç³»ç»Ÿæ‰¾åˆ°ç¡®åˆ‡çš„ç­”æ¡ˆã€‚ walk_component() çš„æœ€åä¸€æ­¥æ˜¯è°ƒç”¨ step_into() å‡½æ•°ï¼Œå®ƒå¯ä»¥ç›´æ¥ä» walk_component() æˆ–è€… handle_dots() è°ƒç”¨ã€‚å®ƒä¼šè°ƒç”¨ handle_mounts() å‡½æ•°æ¥æ£€æŸ¥å’Œå¤„ç†æŒ‚è½½ç‚¹ï¼Œè¿™æ—¶ä¼šåˆ›å»ºä¸€ä¸ªåŒ…å«å¯¹æ–° dentry çš„è®¡æ•°å¼•ç”¨å’Œå¯¹æ–° vfsmount çš„å¼•ç”¨çš„æ–° struct pathã€‚åªæœ‰åœ¨æ–° vfsmount ä¸ä¹‹å‰çš„ vfsmount ä¸åŒæ—¶ï¼Œæ–° vfsmount çš„å¼•ç”¨æ‰ä¼šè¢«è®¡æ•°ã€‚ç„¶åï¼Œå¦‚æœæœ‰ç¬¦å·é“¾æ¥ï¼Œstep_into() ä¼šè°ƒç”¨ pick_link() å‡½æ•°å¤„ç†å®ƒï¼Œå¦åˆ™å®ƒä¼šå°†æ–°çš„ struct path å®‰è£…åˆ° struct nameidata ä¸­ï¼Œå¹¶åˆ é™¤ä¸å†éœ€è¦çš„å¼•ç”¨ã€‚ link_path_walk() å‡½æ•°åªä¼šå¤„ç†è·¯å¾„ä¸­çš„æœ€åä¸€ä¸ªç»„ä»¶ï¼Œè®¾ç½® nd-&gt;last å’Œ nd-&gt;last_typeï¼Œä½†å®ƒä¸ä¼šè°ƒç”¨ walk_component() å‡½æ•°ã€‚å¤„ç†æœ€åçš„ç»„ä»¶ç•™ç»™äº†è°ƒç”¨è€…ï¼Œè¿™äº›è°ƒç”¨è€…åˆ†åˆ«æ˜¯ path_lookupat()ã€path_parentat() å’Œ path_openat()ï¼Œå®ƒä»¬åˆ†åˆ«å¤„ç†ä¸åŒç³»ç»Ÿè°ƒç”¨çš„éœ€æ±‚ã€‚ path_parentat()ï¼šè¿™ä¸ªå‡½æ•°ç›¸å¯¹ç®€å•ï¼Œå®ƒåœ¨ link_path_walk() å‘¨å›´æ·»åŠ äº†ä¸€äº›é¢å¤–çš„æ“ä½œï¼Œç„¶åå°†çˆ¶ç›®å½•å’Œæœ€åçš„ç»„ä»¶è¿”å›ç»™è°ƒç”¨è€…ã€‚è°ƒç”¨è€…å¯èƒ½ä¼šè¯•å›¾é€šè¿‡ filename_create() å‡½æ•°åˆ›å»ºä¸€ä¸ªåç§°ï¼Œæˆ–è€…ç§»é™¤æˆ–é‡å‘½åä¸€ä¸ªåç§°ï¼ˆè¿™ç§æƒ…å†µä¸‹ä¼šä½¿ç”¨ user_path_parent() å‡½æ•°ï¼‰ã€‚åœ¨æ‰§è¡Œæ“ä½œä¹‹å‰ï¼Œå®ƒä»¬ä¼šä½¿ç”¨ i_rwsem æ¥ç¡®ä¿æ²¡æœ‰å…¶ä»–æ›´æ”¹ã€‚ ä¾‹å¦‚ï¼Œå½“ç”¨æˆ·è°ƒç”¨ mkdir() å‡½æ•°æ—¶ï¼Œå®ƒä¼šè°ƒç”¨ path_parentat() å‡½æ•°æ¥æ‰¾åˆ°æ–°ç›®å½•çš„çˆ¶ç›®å½•ã€‚ç„¶åï¼Œå†…æ ¸å¯ä»¥æ ¹æ®è¿”å›çš„çˆ¶ç›®å½•åˆ›å»ºæ–°ç›®å½•ã€‚ path_lookupat()ï¼šè¿™ä¸ªå‡½æ•°ä¹Ÿç›¸å¯¹ç®€å•ï¼Œå®ƒç”¨äºæŸ¥æ‰¾ç°æœ‰å¯¹è±¡ï¼Œæ¯”å¦‚é€šè¿‡ stat() æˆ– chmod() å‡½æ•°ã€‚å®ƒå®é™…ä¸Šåªæ˜¯é€šè¿‡è°ƒç”¨ lookup_last() å‡½æ•°åœ¨æœ€åçš„ç»„ä»¶ä¸Šè°ƒç”¨ walk_component()ã€‚path_lookupat() åªè¿”å›æœ€åçš„ dentryã€‚ ä¾‹å¦‚ï¼Œå½“ç”¨æˆ·è°ƒç”¨ stat() å‡½æ•°æ—¶ï¼Œå®ƒä¼šè°ƒç”¨ path_lookupat() å‡½æ•°æ¥æ‰¾åˆ°æ–‡ä»¶æˆ–ç›®å½•çš„ dentryã€‚ç„¶åï¼Œå†…æ ¸å¯ä»¥æ ¹æ® dentry æä¾›æ–‡ä»¶æˆ–ç›®å½•çš„å…ƒæ•°æ®ã€‚ path_openat()ï¼šè¿™ä¸ªå‡½æ•°ç”¨äºå¤„ç† open() ç³»ç»Ÿè°ƒç”¨ã€‚é€šè¿‡æ”¯æŒå‡½æ•°ï¼ˆä»¥ â€œopen_last_lookups()â€ å¼€å¤´ï¼‰ï¼Œå®ƒåŒ…å«äº†å¤„ç† O_CREATï¼ˆæœ‰æˆ–æ—  O_EXCLï¼‰ã€æœ€åçš„ â€œ&#x2F;â€ å­—ç¬¦å’Œå°¾éƒ¨ç¬¦å·é“¾æ¥ç­‰ä¸åŒç»†å¾®å·®åˆ«æ‰€éœ€çš„æ‰€æœ‰å¤æ‚æ€§ã€‚è¿™ä¸ªå‡½æ•°åœ¨æŸäº›æƒ…å†µä¸‹ä¼šä½¿ç”¨ i_rwsemï¼Œå…·ä½“å–å†³äºå®ƒæ‰¾åˆ°çš„å†…å®¹ã€‚ ä¾‹å¦‚ï¼Œå½“ç”¨æˆ·è°ƒç”¨ open() å‡½æ•°æ—¶ï¼Œå®ƒä¼šè°ƒç”¨ path_openat() å‡½æ•°æ¥å¤„ç†å¯èƒ½çš„ä¸åŒæ“ä½œï¼Œæ¯”å¦‚åˆ›å»ºæ–°æ–‡ä»¶ã€æ‰“å¼€ç°æœ‰æ–‡ä»¶æˆ–å¤„ç†å°¾éƒ¨ç¬¦å·é“¾æ¥ã€‚ è¿™äº›å‡½æ•°æˆ–è°ƒç”¨å®ƒä»¬çš„å‡½æ•°éœ€è¦æ³¨æ„æœ€åä¸€ä¸ªç»„ä»¶æ˜¯å¦æ˜¯ LAST_NORMã€‚å¦‚æœæŸ¥æ‰¾çš„ç›®æ ‡æ˜¯åˆ›å»ºæŸä¸ªå¯¹è±¡ï¼Œé‚£ä¹ˆ last_type çš„ä»»ä½•å€¼ï¼ˆé™¤äº† LAST_NORMï¼‰éƒ½ä¼šå¯¼è‡´é”™è¯¯ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ path_parentat() æŠ¥å‘Š LAST_DOTDOTï¼Œé‚£ä¹ˆè°ƒç”¨è€…å°†ä¸ä¼šå°è¯•åˆ›å»ºè¯¥åç§°ã€‚å®ƒä»¬è¿˜ä¼šé€šè¿‡æµ‹è¯• last.name[last.len] æ¥æ£€æŸ¥å°¾éƒ¨æ–œæ ã€‚å¦‚æœåœ¨æœ€åä¸€ä¸ªç»„ä»¶ä¹‹åæœ‰ä»»ä½•å­—ç¬¦ï¼Œé‚£ä¹ˆè¿™ä¸€å®šæ˜¯ä¸€ä¸ªå°¾éƒ¨æ–œæ ã€‚ è°ƒç”¨é“¾ä¸‹é¢çœ‹åˆ°è¿™ä¸ªè°ƒç”¨é“¾ 12345678910111213141516171819202122232425262728293031323334open() â””â”€â”€ do_sys_open â””â”€â”€ do_sys_openat2 â”œâ”€â”€ get_unused_fd_flags(è·å–ä¸€ä¸ªæœªä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦) â”œâ”€â”€ do_filp_open(æ‰“å¼€file f) â”‚ â”œâ”€â”€ set_nameidata(åˆå§‹åŒ–nameidata ndå­˜æ”¾æŸ¥æ‰¾ç»“æœ) â”‚ â”‚ â””â”€â”€ __set_nameidata â”‚ â”œâ”€â”€ path_openat(æ‰“å¼€file) â”‚ â”‚ â”œâ”€â”€ alloc_empty_file(åˆå§‹åŒ–ä¸€ä¸ªç©ºçš„fileç»“æ„ä½“) â”‚ â”‚ â”œâ”€â”€ path_init(åˆå§‹åŒ–nameidataç»“æ„ä½“ndï¼Œä¸åŒç³»ç»Ÿè°ƒç”¨nd-&gt;pathä¸åŒ) â”‚ â”‚ â”œâ”€â”€ link_path_walk(å¤„ç†ç¬¦å·é“¾æ¥) â”‚ â”‚ â”‚ â”œâ”€â”€ lookup_fast â”‚ â”‚ â”‚ â”‚ â””â”€â”€ __d_lookup_rcu â”‚ â”‚ â”‚ â”‚ â””â”€â”€ hlist_bl_for_each_entry_rcu â”‚ â”‚ â”‚ â””â”€â”€ lookup_slow â”‚ â”‚ â”‚ â””â”€â”€ __lookup_slow â”‚ â”‚ â”‚ â””â”€â”€ å…·ä½“æ–‡ä»¶ç³»ç»Ÿçš„lookupå‡½æ•° â”‚ â”‚ â””â”€â”€ open_last_lookupsï¼ˆåˆ›å»ºæ–°æ–‡ä»¶ï¼‰ â”‚ â”‚ â”œâ”€â”€ handle_dots(å¤„ç†..å’Œ.) â”‚ â”‚ â”œâ”€â”€ lookup_fast â”‚ â”‚ â”‚ â””â”€â”€ __d_lookup_rcu â”‚ â”‚ â”‚ â””â”€â”€ hlist_bl_for_each_entry_rcu â”‚ â”‚ â”œâ”€â”€ lookup_open â”‚ â”‚ â”‚ â””â”€â”€ d_lookup â”‚ â”‚ â”‚ â””â”€â”€ __d_lookup â”‚ â”‚ â”œâ”€â”€ atomic_open(å¦‚æœæ”¯æŒåŸå­æ‰“å¼€æ“ä½œ) â”‚ â”‚ â”œâ”€â”€ å…·ä½“æ–‡ä»¶çš„lookup(å¦‚æœç›®å½•é¡¹ä»åœ¨æŸ¥æ‰¾ä¸­) â”‚ â”‚ â””â”€â”€ å…·ä½“æ–‡ä»¶çš„create(å¦‚æœç›®å½•é¡¹çš„inodeä¸ºç©ºå¹¶ä¸”éœ€è¦åˆ›å»ºæ–‡ä»¶) â”‚ â”‚ â”‚ â””â”€â”€ do_open â”‚ â””â”€â”€ vfs_open â”‚ â””â”€â”€ do_dentry_open â”‚ â””â”€â”€ å…·ä½“æ–‡ä»¶ç³»ç»Ÿçš„open â””â”€â”€ fd_install Pathname lookupä¸‹é¢æ˜¯æŸ¥æ‰¾&#x2F;home&#x2F;hust&#x2F;helloworld.txtæ—¶ï¼Œlink_path_walkä¸­çš„å¾ªç¯å¤„ç†æ¯ä¸ªç»„ä»¶ æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿåï¼Œå°±å¯ä»¥è®¿é—®è¯¥æ–‡ä»¶ç³»ç»Ÿä¸Šçš„æ–‡ä»¶ã€‚ä¸»è¦æœ‰ä¸¤ä¸ªæ­¥éª¤ï¼šæŸ¥æ‰¾åç§°ä»¥æŸ¥æ‰¾å®ƒæŒ‡å‘çš„inodeï¼Œç„¶åè®¿é—®inode è·¯å¾„å ä»¥æ–œæ å¼€å¤´çš„è·¯å¾„ç§°ä¸ºâ€œç»å¯¹è·¯å¾„â€ï¼Œå®ƒä»æ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•å¼€å§‹ã€‚ ä¾‹å¦‚ï¼š&#x2F;home&#x2F;user&#x2F;documents&#x2F;report.txt ä¸ä»¥æ–œæ å¼€å¤´çš„è·¯å¾„ç§°ä¸ºâ€œç›¸å¯¹è·¯å¾„â€ï¼Œå®ƒä»å½“å‰ç›®å½•æˆ–é€šè¿‡ç»™ â€œ*at()â€ ç³»ç»Ÿè°ƒç”¨ï¼ˆå¦‚ openat()ï¼‰æä¾›çš„æ–‡ä»¶æè¿°ç¬¦æŒ‡å®šçš„å…¶ä»–ä½ç½®å¼€å§‹ã€‚ ä¾‹å¦‚ï¼šdocuments&#x2F;report.txt åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè·¯å¾„åå¯èƒ½æ—¢æ²¡æœ‰æ–œæ ï¼ˆslashesï¼‰ä¹Ÿæ²¡æœ‰ç»„ä»¶ï¼ˆcomponentsï¼‰ï¼Œæ¢å¥è¯è¯´ï¼Œå®ƒå¯èƒ½æ˜¯ç©ºçš„ã€‚è™½ç„¶åœ¨ POSIX æ ‡å‡†ä¸­ï¼Œè¿™ç§æƒ…å†µé€šå¸¸æ˜¯ç¦æ­¢çš„ï¼Œä½†åœ¨ Linux ä¸­ï¼Œå½“ç»™å‡º AT_EMPTY_PATH æ ‡å¿—æ—¶ï¼ŒæŸäº› â€œ*at()â€ ç³»ç»Ÿè°ƒç”¨å…è®¸ç©ºè·¯å¾„åã€‚ ä¸¾ä¾‹æ¥è¯´ï¼Œå¦‚æœä½ æœ‰ä¸€ä¸ªæŒ‡å‘å¯æ‰§è¡Œæ–‡ä»¶çš„æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä½ å¯ä»¥é€šè¿‡è°ƒç”¨ execveat() å‡½æ•°ï¼Œä¼ é€’æ–‡ä»¶æè¿°ç¬¦ã€ç©ºè·¯å¾„å’Œ AT_EMPTY_PATH æ ‡å¿—æ¥æ‰§è¡Œè¯¥æ–‡ä»¶ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå³ä½¿è·¯å¾„åä¸ºç©ºï¼Œä¹Ÿå¯ä»¥å®Œæˆæ–‡ä»¶çš„æ‰§è¡Œæ“ä½œã€‚ æ³¨æ„ï¼š è·¯å¾„åå¯ä»¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼šæœ€åä¸€ä¸ªç»„ä»¶å’Œå…¶ä»–æ‰€æœ‰å†…å®¹ã€‚å…¶ä»–æ‰€æœ‰å†…å®¹é€šå¸¸æ˜¯å®¹æ˜“å¤„ç†çš„ï¼Œå¿…é¡»æ ‡è¯†ä¸€ä¸ªå·²å­˜åœ¨çš„ç›®å½•ï¼Œå¦åˆ™ä¼šæŠ¥å‘Šé”™è¯¯ã€‚æœ€åä¸€ä¸ªç»„ä»¶çš„å¤„ç†åˆ™æ›´å¤æ‚ã€‚ ä¸åŒçš„ç³»ç»Ÿè°ƒç”¨å¯èƒ½å¯¹æœ€åä¸€ä¸ªç»„ä»¶æœ‰ä¸åŒçš„è§£é‡Šï¼ˆå¦‚æ˜¯å¦åˆ›å»ºå®ƒï¼‰ï¼Œæœ‰æ—¶å®ƒç”šè‡³å¯èƒ½ä¸å­˜åœ¨ï¼ˆå¦‚ç©ºè·¯å¾„åæˆ–ä»…åŒ…å«æ–œæ çš„è·¯å¾„åï¼‰ã€‚ æœ€åä¸€ä¸ªç»„ä»¶å¯èƒ½æ˜¯ â€œ.â€ æˆ– â€œ..â€ï¼Œè¿™ä¸¤ä¸ªç»„ä»¶çš„å¤„ç†æ–¹å¼ä¸å…¶ä»–ç»„ä»¶ä¸åŒã€‚ å¦‚æœè·¯å¾„åä»¥æ–œæ ç»“å°¾ï¼Œå¦‚â€&#x2F;tmp&#x2F;foo&#x2F;â€œï¼Œå¯èƒ½ä¼šè®¤ä¸ºæœ€åä¸€ä¸ªç»„ä»¶ä¸ºç©ºã€‚åœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼Œè¿™ç§å¤„ç†æ–¹å¼å¯ä»¥å¾—åˆ°æ­£ç¡®çš„ç»“æœï¼Œä½†å¹¶éæ€»æ˜¯å¦‚æ­¤ã€‚ç‰¹åˆ«æ˜¯ï¼Œmkdir() å’Œ rmdir() å‡½æ•°ä¼šæ ¹æ®æœ€åä¸€ä¸ªç»„ä»¶åˆ›å»ºæˆ–åˆ é™¤ç›®å½•ï¼Œå®ƒä»¬è¦æ±‚å¤„ç†ä»¥æ–œæ ç»“å°¾çš„è·¯å¾„åã€‚ Linux è·¯å¾„åå¤„ç†ä»£ç ï¼ˆä¸»è¦åœ¨ fs/namei.cï¼‰å¤„ç†äº†æ‰€æœ‰è¿™äº›é—®é¢˜ã€‚å®ƒä¼šå°†è·¯å¾„åˆ†è§£ä¸ºç»„ä»¶ï¼Œå°†æœ€åä¸€ä¸ªç»„ä»¶ä¸å…¶ä»–æ‰€æœ‰å†…å®¹åˆ†å¼€å¤„ç†ï¼Œå¹¶æ£€æŸ¥å°¾éƒ¨æ–œæ æ˜¯å¦åœ¨ä¸å…è®¸çš„åœ°æ–¹ä½¿ç”¨ã€‚å®ƒè¿˜å¤„ç†äº†å¹¶å‘è®¿é—®çš„é—®é¢˜ã€‚ å½“ä¸€ä¸ªè¿›ç¨‹åœ¨æŸ¥æ‰¾è·¯å¾„åæ—¶ï¼Œå¦ä¸€ä¸ªè¿›ç¨‹å¯èƒ½ä¼šè¿›è¡Œå½±å“æŸ¥æ‰¾çš„æ›´æ”¹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹æ­£åœ¨æŸ¥æ‰¾ â€œa&#x2F;b&#x2F;..â€ï¼Œè€Œå¦ä¸€ä¸ªè¿›ç¨‹å°† â€œa&#x2F;bâ€ é‡å‘½åä¸º â€œa&#x2F;c&#x2F;bâ€ï¼Œç¬¬ä¸€ä¸ªè¿›ç¨‹å¯èƒ½ä¼šæˆåŠŸåœ°è§£æä¸º â€œa&#x2F;câ€ã€‚è¿™å°±æ˜¯æ‰€è°“çš„ç«æ€æ¡ä»¶ï¼Œè·¯å¾„åæŸ¥æ‰¾çš„ä»»åŠ¡å°±æ˜¯è¦é˜²æ­¢å®ƒä»¬äº§ç”Ÿç ´åæ€§å½±å“ã€‚ å¤§å¤šæ•°ç«æ€æ¡ä»¶æ›´åŠ å¾®å¦™ï¼Œå¾ˆå¤šå¯èƒ½çš„ç«æ€æ¡ä»¶å¯ä»¥åœ¨ â€œdcacheâ€ï¼ˆç›®å½•ç¼“å­˜ï¼‰çš„ä¸Šä¸‹æ–‡ä¸­æ›´æ¸…æ¥šåœ°çœ‹åˆ°ã€‚ç†è§£ â€œdcacheâ€ æ˜¯ç†è§£è·¯å¾„åæŸ¥æ‰¾çš„æ ¸å¿ƒã€‚ dcache dcache ç¼“å­˜äº†æ–‡ä»¶ç³»ç»Ÿä¸­åç§°çš„ä¿¡æ¯ï¼Œä»¥ä¾¿å¿«é€Ÿè¿›è¡ŒæŸ¥æ‰¾ã€‚æ¯ä¸ª dcache æ¡ç›®ï¼ˆdentryï¼‰åŒ…å«ä¸‰ä¸ªé‡è¦å­—æ®µï¼šç»„ä»¶åç§°ã€æŒ‡å‘çˆ¶æ¡ç›®çš„æŒ‡é’ˆå’ŒæŒ‡å‘ inode çš„æŒ‡é’ˆã€‚inode åŒ…å«æœ‰å…³å…·æœ‰ç»™å®šåç§°çš„çˆ¶é¡¹å¯¹è±¡çš„æ›´å¤šä¿¡æ¯ã€‚ dcache é™¤äº†åŠ é€ŸæŸ¥æ‰¾å¤–ï¼Œè¿˜æœ‰å…¶ä»–ç”¨é€”ã€‚ä¸€ä¸ªç‰¹åˆ«ç›¸å…³çš„ç”¨é€”æ˜¯å®ƒä¸æŒ‚è½½è¡¨ç´§å¯†é›†æˆã€‚æŒ‚è½½è¡¨è®°å½•äº†å“ªä¸ªæ–‡ä»¶ç³»ç»ŸæŒ‚è½½åœ¨å“ªä¸ªä½ç½®ï¼Œå®é™…ä¸Šå­˜å‚¨çš„æ˜¯å“ªä¸ª dentry å®‰è£…åœ¨å“ªä¸ªå…¶ä»– dentry ä¹‹ä¸Šã€‚ åœ¨å¤„ç† dcache æ—¶ï¼Œéœ€è¦è€ƒè™‘ä¸¤ç§ç±»å‹çš„æ–‡ä»¶ç³»ç»Ÿï¼š ä¸€ç±»æ–‡ä»¶ç³»ç»Ÿèƒ½ç¡®ä¿ dcache ä¸­çš„ä¿¡æ¯å§‹ç»ˆå®Œå…¨å‡†ç¡®ï¼ˆå°½ç®¡å¯èƒ½ä¸å®Œæ•´ï¼‰ã€‚è¿™å¯ä»¥è®© VFS åœ¨ä¸æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿçš„æƒ…å†µä¸‹ç¡®å®šç‰¹å®šæ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ŒåŒæ—¶ VFS å¯ä»¥ä¿æŠ¤æ–‡ä»¶ç³»ç»Ÿå…å—æŸäº›ç«äº‰å’Œå…¶ä»–é—®é¢˜çš„å½±å“ã€‚è¿™ç±»æ–‡ä»¶ç³»ç»Ÿé€šå¸¸æ˜¯æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼Œå¦‚ ext3ã€XFS å’Œ Btrfsã€‚ ä¾‹å¦‚ï¼Œå½“ä½ åœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼ˆå¦‚ ext3ï¼‰ä¸­åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶æ—¶ï¼ŒVFS å¯ä»¥ç›´æ¥é€šè¿‡ dcache æ¥æŸ¥æ‰¾æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œè€Œæ— éœ€ä¸åº•å±‚æ–‡ä»¶ç³»ç»Ÿè¿›è¡Œäº¤äº’ã€‚è¿™æ ·å¯ä»¥æé«˜æŸ¥æ‰¾é€Ÿåº¦ã€‚ å¦ä¸€ç±»æ–‡ä»¶ç³»ç»Ÿæ— æ³•æä¾›è¿™ç§ä¿è¯ï¼Œå› ä¸ºå®ƒä»¬ä¸èƒ½ã€‚è¿™äº›é€šå¸¸æ˜¯è·¨ç½‘ç»œå…±äº«çš„æ–‡ä»¶ç³»ç»Ÿï¼Œä¾‹å¦‚è¿œç¨‹æ–‡ä»¶ç³»ç»Ÿï¼ˆå¦‚ NFS å’Œ 9Pï¼‰æˆ–é›†ç¾¤æ–‡ä»¶ç³»ç»Ÿï¼ˆå¦‚ ocfs2 æˆ– cephfsï¼‰ã€‚è¿™äº›æ–‡ä»¶ç³»ç»Ÿå…è®¸ VFS é‡æ–°éªŒè¯ç¼“å­˜çš„ä¿¡æ¯ï¼Œå¹¶å¿…é¡»æä¾›è‡ªå·±çš„ä¿æŠ¤ï¼Œä»¥é˜²æ­¢ç«äº‰æ¡ä»¶ã€‚VFS å¯ä»¥é€šè¿‡åœ¨ dentry ä¸­è®¾ç½®çš„ DCACHE_OP_REVALIDATE æ ‡å¿—æ¥æ£€æµ‹è¿™äº›æ–‡ä»¶ç³»ç»Ÿã€‚ ä¾‹å¦‚ï¼Œå½“ä½ è®¿é—®ä¸€ä¸ªé€šè¿‡ NFS å…±äº«çš„æ–‡ä»¶ç³»ç»Ÿæ—¶ï¼Œè™½ç„¶ VFS å¯ä»¥é€šè¿‡ dcache åŠ é€ŸæŸ¥æ‰¾ï¼Œä½†æ˜¯è¯¥æ–‡ä»¶ç³»ç»Ÿæ— æ³•ä¿è¯ dcache ä¿¡æ¯å§‹ç»ˆå‡†ç¡®ï¼Œå› ä¸ºè¿œç¨‹æ–‡ä»¶å¯èƒ½è¢«å…¶ä»–èŠ‚ç‚¹æ›´æ”¹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒVFS éœ€è¦é‡æ–°éªŒè¯ç¼“å­˜çš„ä¿¡æ¯ï¼Œå¹¶ä¾èµ–åº•å±‚æ–‡ä»¶ç³»ç»Ÿæä¾›ä¿æŠ¤ï¼Œä»¥é˜²æ­¢ç«æ€æ¡ä»¶ã€‚ å‚è€ƒèµ„æ–™ A tour of the Linux VFS (tldp.org) The Virtual File System (VFS) â€” è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ ï¼ˆVFSï¼‰ (unitn.it) The Linux kernel: The Linux Virtual File System â€” Linux å†…æ ¸ï¼šLinux è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ (tue.nl) è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ_ç™¾åº¦ç™¾ç§‘ (baidu.com) Linuxæ“ä½œç³»ç»Ÿå­¦ä¹ ç¬”è®°ï¼ˆåäºŒï¼‰è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ | Ty-Chenâ€™s Home Virtual file system - Wikipedia â€” è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ - ç»´åŸºç™¾ç§‘ [é«˜çº§æ“ä½œç³»ç»Ÿ] VFSè¯¦è§£ï¼ˆè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼‰_å®‡å†…è™¹æ¸¸çš„åšå®¢-CSDNåšå®¢ File system - Wikipedia Yair Amir lectures (jhu.edu) linuxè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿæµ…æ - Linuxæ“ä½œç³»ç»Ÿï¼šUbuntu_Centos_Debian - çº¢é»‘è”ç›Ÿ (2cto.com) Filesystems in the Linux kernel â€” The Linux Kernel documentation â€” Linux å†…æ ¸ä¸­çš„æ–‡ä»¶ç³»ç»Ÿ â€” Linux å†…æ ¸æ–‡æ¡£ Overview of the Linux Virtual File System â€” The Linux Kernel documentation â€” Linux è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿæ¦‚è¿° â€” Linux å†…æ ¸æ–‡æ¡£","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"å­¦ä¹  Linux å†…æ ¸æ“ä½œ","slug":"å­¦ä¹ -Linux-å†…æ ¸æ“ä½œ","date":"2023-06-13T08:04:01.000Z","updated":"2023-07-26T02:30:54.058Z","comments":true,"path":"2023/06/13/å­¦ä¹ -Linux-å†…æ ¸æ“ä½œ/","link":"","permalink":"http://example.com/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/","excerpt":"å†…æ ¸åŸºæœ¬æ“ä½œ æŸ¥çœ‹ç³»ç»Ÿå­˜åœ¨çš„å†…æ ¸ 1dpkg --list | grep linux-image æ›´æ–°menu.list 1sudo update-grub æ˜¾ç¤ºå½“å‰çš„å†…æ ¸ å‡çº§å†…æ ¸ 1sudo apt-get dist-upgrade åˆ é™¤å†…æ ¸ å¸¦æœ‰imageçš„æ–‡ä»¶æ˜¯éœ€è¦åˆ é™¤çš„ï¼Œä¸€å®šè¦å†™å…¨ç‰ˆæœ¬ç­‰å­—ç¬¦ã€‚å…¶ä»–ç›¸å…³æ–‡ä»¶ä¼šè‡ªåŠ¨åˆ é™¤ã€‚ 1sudo apt-get remove --purge linux-headers-2.6.32-24-generic ç³»ç»Ÿåƒåœ¾æ¸…ç† æ¸…ç†æ—§ç‰ˆæœ¬çš„è½¯ä»¶ç¼“å­˜ 1sudo apt-get autoclean æ¸…ç†æ‰€æœ‰è½¯ä»¶ç¼“å­˜ 1sudo apt-get clean åˆ é™¤ç³»ç»Ÿä¸å†ä½¿ç”¨çš„å­¤ç«‹è½¯ä»¶ 1sudo apt-get autoremove ç¼–è¯‘å†…æ ¸","text":"å†…æ ¸åŸºæœ¬æ“ä½œ æŸ¥çœ‹ç³»ç»Ÿå­˜åœ¨çš„å†…æ ¸ 1dpkg --list | grep linux-image æ›´æ–°menu.list 1sudo update-grub æ˜¾ç¤ºå½“å‰çš„å†…æ ¸ å‡çº§å†…æ ¸ 1sudo apt-get dist-upgrade åˆ é™¤å†…æ ¸ å¸¦æœ‰imageçš„æ–‡ä»¶æ˜¯éœ€è¦åˆ é™¤çš„ï¼Œä¸€å®šè¦å†™å…¨ç‰ˆæœ¬ç­‰å­—ç¬¦ã€‚å…¶ä»–ç›¸å…³æ–‡ä»¶ä¼šè‡ªåŠ¨åˆ é™¤ã€‚ 1sudo apt-get remove --purge linux-headers-2.6.32-24-generic ç³»ç»Ÿåƒåœ¾æ¸…ç† æ¸…ç†æ—§ç‰ˆæœ¬çš„è½¯ä»¶ç¼“å­˜ 1sudo apt-get autoclean æ¸…ç†æ‰€æœ‰è½¯ä»¶ç¼“å­˜ 1sudo apt-get clean åˆ é™¤ç³»ç»Ÿä¸å†ä½¿ç”¨çš„å­¤ç«‹è½¯ä»¶ 1sudo apt-get autoremove ç¼–è¯‘å†…æ ¸ å®‰è£…å¿…å¤‡è½¯ä»¶ 123456sudo apt install makesudo apt install build-essentialsudo apt install libncurses5-devsudo apt install bisonsudo apt install flexsudo apt install libssl-dev ä»The Linux Kernel Archivesä¸Šä¸‹è½½æºç ï¼Œç„¶åè§£å‹ï¼Œå¹¶è¿›å…¥æ–‡ä»¶å¤¹ï¼Œè¿è¡Œå¦‚ä¸‹å‘½ä»¤ 123make mrpropermake cleanmake menuconfig æƒé™ä¸å¤Ÿå°±åœ¨å‘½ä»¤å‰é¢åŠ ä¸Šsudo åœ¨æ‰§è¡Œå®Œmake menuconfigåï¼Œä¼šäº§ç”Ÿå›¾å½¢ç•Œé¢ã€‚é€‰æ‹©ä¸‹æ–¹çš„saveï¼Œå°†å†…æ ¸é…ç½®ä¿å­˜åœ¨.configæ–‡ä»¶ä¸­ï¼Œç„¶åé€‰æ‹©exité€€å‡ºã€‚åœ¨ç¼–è¯‘å†…æ ¸ä¹‹å‰ï¼Œå¯ä»¥é€šè¿‡ä¿®æ”¹.configçš„å†…å®¹æ¥ä¿®æ”¹å†…æ ¸é…ç½®ã€‚ é…ç½®å®Œæˆåï¼Œç¼–è¯‘å†…æ ¸å¹¶å®‰è£…ã€‚ 1sudo make -j$(nproc) å¦‚æœä¸‹åˆ—é”™è¯¯ è¿è¡Œä¸‹åˆ—å‘½ä»¤ 1sudo apt-get install libelf-dev ç»§ç»­è¿›è¡Œç¼–è¯‘ï¼Œå¦‚æœé‡åˆ°å¦‚ä¸‹é”™è¯¯ 1make[2]: *** æ²¡æœ‰è§„åˆ™å¯åˆ¶ä½œç›®æ ‡â€œdebian/canonical-certs.pemâ€ï¼Œç”±â€œcerts/x509_certificate_listâ€ éœ€æ±‚ã€‚ åœæ­¢ã€‚ 1make[2]: *** æ²¡æœ‰è§„åˆ™å¯åˆ¶ä½œç›®æ ‡â€œdebian/canonical-revoked-certs.pemâ€ï¼Œç”±â€œcerts/x509_revocation_listâ€ éœ€æ±‚ã€‚ åœæ­¢ã€‚ é‚£ä¹ˆè¿è¡Œå¦‚ä¸‹å‘½ä»¤ 1scripts/config --disable SYSTEM_TRUSTED_KEYS 1scripts/config --disable SYSTEM_REVOCATION_KEYS ä¹‹åç»§ç»­ç¼–è¯‘è‡³å®Œæˆ,ç„¶åå®‰è£…å†…æ ¸ 12sudo make modules_installsudo make install åˆ‡æ¢è¿è¡Œå†…æ ¸ æŸ¥çœ‹å½“å‰å†…æ ¸çš„å¯åŠ¨é¡ºåº 1cat /boot/grub/grub.cfg |grep menuentry ä¿®æ”¹æ–‡ä»¶åœ¨å¯åŠ¨æ—¶é€‰æ‹©å†…æ ¸ 1sudo vim /etc/default/grub æ›´æ–°æ–‡ä»¶ 1sudo update-grub é‡å¯ç³»ç»Ÿ 1sudo reboot now é€‰æ‹©Advanced options for Ubuntu é€‰æ‹©è¦å¯åŠ¨çš„å†…æ ¸ æ·»åŠ è¾“å‡º12345if (strstr(current-&gt;comm, &quot;cat&quot;))//è¿‡æ»¤ printk(&quot;%p&quot;,f1);//è¾“å‡ºprintk(KERN_INFO &quot; %s\\n&quot;, ...); åˆ‡æ¢cgroupv1-&gt;cgroupv212345sudo vim /etc/default/grubsystemd.unified_cgroup_hierarchy=1GRUB_CMDLINE_LINUX_DEFAULT=&quot;systemd.unified_cgroup_hierarchy=1&quot;sudo update-grubsudo reboot now è°ƒè¯•æ—¶å‘½ä»¤1sudo stdbuf -o0 dmesg -w | tee -a dmesg.log 1sudo dmesg -w","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"å­¦ä¹  Linux æ–‡ä»¶ç³»ç»Ÿ tmpfs","slug":"å­¦ä¹ -Linux-æ–‡ä»¶ç³»ç»Ÿ tmpfs","date":"2023-06-10T12:58:52.000Z","updated":"2023-11-20T02:26:17.742Z","comments":true,"path":"2023/06/10/å­¦ä¹ -Linux-æ–‡ä»¶ç³»ç»Ÿ tmpfs/","link":"","permalink":"http://example.com/2023/06/10/%E5%AD%A6%E4%B9%A0-Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20tmpfs/","excerpt":"tmpfsç®€ä»‹tmpfsï¼ˆè‹±è¯­ï¼štemporary file systemï¼‰ æ˜¯ç±»Unixç³»ç»Ÿä¸Šæš‚å­˜æ¡£å­˜å‚¨ç©ºé—´çš„å¸¸è§åç§°ï¼Œé€šå¸¸ä»¥æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿæ–¹å¼å®ç°ï¼Œå¹¶å°†èµ„æ–™å­˜å‚¨åœ¨æ˜“å¤±æ€§å­˜å‚¨å™¨è€Œéæ°¸ä¹…å­˜å‚¨è®¾å¤‡ä¸­ã€‚å’ŒRAM diskçš„æ¦‚å¿µè¿‘ä¼¼ï¼Œä½†åè€…ä¼šå‘ˆç°å‡ºå…·æœ‰å®Œæ•´æ–‡ä»¶ç³»ç»Ÿçš„è™šæ‹Ÿç£ç›˜ã€‚ tmpfsçš„å·¥ä½œåŸç†æ˜¯ï¼Œå®ƒä½¿ç”¨è®¡ç®—æœºçš„å†…å­˜æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Œå°±åƒåœ¨ç¡¬ç›˜ä¸Šåˆ›å»ºäº†ä¸€ä¸ªè™šæ‹Ÿçš„æ–‡ä»¶æŸœã€‚å½“ä½ åœ¨tmpfsä¸Šåˆ›å»ºæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹æ—¶ï¼Œå®é™…ä¸Šå®ƒä»¬æ˜¯å­˜å‚¨åœ¨å†…å­˜ä¸­çš„ã€‚è¿™æ ·ï¼Œè®¿é—®è¿™äº›æ–‡ä»¶ä¼šéå¸¸å¿«ï¼Œå› ä¸ºå†…å­˜çš„é€Ÿåº¦æ¯”ç¡¬ç›˜å¿«å¾—å¤šã€‚ä½†æ˜¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“è®¡ç®—æœºå…³é—­æˆ–é‡å¯æ—¶ï¼Œå†…å­˜ä¸­çš„æ•°æ®ä¼šä¸¢å¤±ï¼Œæ‰€ä»¥å­˜å‚¨åœ¨tmpfsä¸Šçš„æ–‡ä»¶ä¹Ÿä¼šæ¶ˆå¤±ã€‚","text":"tmpfsç®€ä»‹tmpfsï¼ˆè‹±è¯­ï¼štemporary file systemï¼‰ æ˜¯ç±»Unixç³»ç»Ÿä¸Šæš‚å­˜æ¡£å­˜å‚¨ç©ºé—´çš„å¸¸è§åç§°ï¼Œé€šå¸¸ä»¥æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿæ–¹å¼å®ç°ï¼Œå¹¶å°†èµ„æ–™å­˜å‚¨åœ¨æ˜“å¤±æ€§å­˜å‚¨å™¨è€Œéæ°¸ä¹…å­˜å‚¨è®¾å¤‡ä¸­ã€‚å’ŒRAM diskçš„æ¦‚å¿µè¿‘ä¼¼ï¼Œä½†åè€…ä¼šå‘ˆç°å‡ºå…·æœ‰å®Œæ•´æ–‡ä»¶ç³»ç»Ÿçš„è™šæ‹Ÿç£ç›˜ã€‚ tmpfsçš„å·¥ä½œåŸç†æ˜¯ï¼Œå®ƒä½¿ç”¨è®¡ç®—æœºçš„å†…å­˜æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼Œå°±åƒåœ¨ç¡¬ç›˜ä¸Šåˆ›å»ºäº†ä¸€ä¸ªè™šæ‹Ÿçš„æ–‡ä»¶æŸœã€‚å½“ä½ åœ¨tmpfsä¸Šåˆ›å»ºæ–‡ä»¶æˆ–æ–‡ä»¶å¤¹æ—¶ï¼Œå®é™…ä¸Šå®ƒä»¬æ˜¯å­˜å‚¨åœ¨å†…å­˜ä¸­çš„ã€‚è¿™æ ·ï¼Œè®¿é—®è¿™äº›æ–‡ä»¶ä¼šéå¸¸å¿«ï¼Œå› ä¸ºå†…å­˜çš„é€Ÿåº¦æ¯”ç¡¬ç›˜å¿«å¾—å¤šã€‚ä½†æ˜¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå½“è®¡ç®—æœºå…³é—­æˆ–é‡å¯æ—¶ï¼Œå†…å­˜ä¸­çš„æ•°æ®ä¼šä¸¢å¤±ï¼Œæ‰€ä»¥å­˜å‚¨åœ¨tmpfsä¸Šçš„æ–‡ä»¶ä¹Ÿä¼šæ¶ˆå¤±ã€‚ tmpfsæ˜¯ä¸€ç§ç‰¹æ®Šçš„æ–‡ä»¶ç³»ç»Ÿï¼Œå®ƒå¯ä»¥è®©ä½ æŠŠè®¡ç®—æœºçš„å†…å­˜ï¼ˆRAMï¼‰å½“ä½œç¡¬ç›˜æ¥ä½¿ç”¨ã€‚è¿™æ ·åšçš„ä¼˜ç‚¹æ˜¯ï¼Œå› ä¸ºå†…å­˜çš„é€Ÿåº¦æ¯”ç¡¬ç›˜å¿«å¾—å¤šï¼Œæ‰€ä»¥è®¿é—®å­˜å‚¨åœ¨tmpfsä¸Šçš„æ–‡ä»¶ä¼šéå¸¸å¿«ã€‚tmpfsé€šå¸¸ç”¨äºå­˜æ”¾ä¸´æ—¶æ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶åœ¨è®¡ç®—æœºé‡å¯åä¼šè‡ªåŠ¨æ¶ˆå¤±ã€‚è¿™æ ·å¯ä»¥é¿å…ç¡¬ç›˜ä¸Šå †ç§¯å¾ˆå¤šä¸å¿…è¦çš„ä¸´æ—¶æ–‡ä»¶ï¼Œæé«˜ç¡¬ç›˜çš„ä½¿ç”¨æ•ˆç‡å’Œè®¡ç®—æœºçš„æ€§èƒ½ã€‚ tmpfsæ–‡ä»¶ç³»ç»Ÿä½¿ç”¨åˆ›å»ºå’ŒæŒ‚è½½tmpfsæ–‡ä»¶ç³»ç»Ÿé¦–å…ˆåˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹/home/plucky/path è¿è¡Œmountå‘½ä»¤ï¼ŒæŒ‚è½½tmpfsæ–‡ä»¶ç³»ç»Ÿ 1sudo mount -t tmpfs -o size=512M tmpfs æ–‡ä»¶å¤¹ï¼ˆ/home/plucky/path) -t tmpfsè¡¨ç¤ºæˆ‘ä»¬è¦æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿç±»å‹æ˜¯tmpfs -o size=512Mè¡¨ç¤ºtmpfsæ–‡ä»¶ç³»ç»Ÿçš„å¤§å°ä¸º512Må­—èŠ‚ tmpfsæ˜¯æ–‡ä»¶ç³»ç»Ÿçš„åç§° æ–‡ä»¶å¤¹æ˜¯æŒ‚è½½ç‚¹çš„æ–‡ä»¶å¤¹ ç°åœ¨ï¼Œä½ å·²ç»æˆåŠŸæŒ‚è½½äº†ä¸€ä¸ªtmpfsæ–‡ä»¶ç³»ç»Ÿã€‚æ‚¨å¯ä»¥åƒä½¿ç”¨æ™®é€šç›®å½•ä¸€æ ·ä½¿ç”¨å®ƒï¼Œä¾‹å¦‚åœ¨å…¶ä¸­åˆ›å»ºæ–‡ä»¶å’Œå­ç›®å½•ã€‚ä½†è¯·è®°ä½ï¼Œå­˜å‚¨åœ¨æ­¤tmpfsæ–‡ä»¶ç³»ç»Ÿä¸Šçš„æ–‡ä»¶å’Œç›®å½•å°†ä»…ä¿å­˜åœ¨å†…å­˜ä¸­ï¼Œè®¡ç®—æœºé‡å¯åå®ƒä»¬å°†æ¶ˆå¤±ã€‚ åœ¨å·²ç»æŒ‚è½½çš„tmpfsæ–‡ä»¶ç³»ç»Ÿä¸­åˆ›å»ºå¹¶å­˜å‚¨ä¸€ä¸ªæ–°æ–‡ä»¶1$ echo &quot;This is a test file.&quot; &gt; /home/plucky/tmpfs/testfile.txt å‡è®¾å·²ç»å°† tmpfs æ–‡ä»¶ç³»ç»ŸæŒ‚è½½åˆ°äº† /home/plucky/tmpfs ç›®å½•ä¸‹ã€‚è¿™ä¸ªå‘½ä»¤å°†åœ¨ /mnt/tmpfs æ–‡ä»¶å¤¹ä¸­åˆ›å»ºä¸€ä¸ªåä¸º testfile.txt çš„æ–°æ–‡ä»¶ï¼Œå¹¶å†™å…¥æ–‡æœ¬ â€œThis is a test file.â€ã€‚ å½“è¿™ä¸ªå‘½ä»¤æ‰§è¡Œæ—¶ï¼Œå°†å‘ç”Ÿä»¥ä¸‹äº‹æƒ…ï¼š é¦–å…ˆï¼Œshell è¿›ç¨‹é€šè¿‡ open æˆ– openat ç³»ç»Ÿè°ƒç”¨å°è¯•åˆ›å»ºæˆ–æ‰“å¼€æ–‡ä»¶ /home/plucky/tmpfs/testfile.txtã€‚ç³»ç»Ÿè°ƒç”¨çš„æ ‡å¿—å°†åŒ…æ‹¬ O_WRONLYï¼ˆåªå†™ï¼‰å’Œ O_CREATï¼ˆå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨åˆ™åˆ›å»ºï¼‰ã€‚ å†…æ ¸å°†è§£ææ–‡ä»¶è·¯å¾„ï¼Œå¹¶ç¡®è®¤ /home/plucky/tmpfs æ˜¯ä¸€ä¸ªå·²æŒ‚è½½çš„ tmpfs æ–‡ä»¶ç³»ç»Ÿã€‚ åœ¨ tmpfs æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå†…æ ¸å°†æ ¹æ®éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ inodeã€‚è¿™æ¶‰åŠåˆ†é…å†…å­˜æ¥å­˜å‚¨ inode æœ¬èº«ä»¥åŠæ–‡ä»¶çš„å…ƒæ•°æ®ï¼ˆå¦‚æƒé™ã€æ‰€æœ‰è€…ç­‰ï¼‰ã€‚ æ–‡ä»¶åˆ›å»ºæˆåŠŸåï¼Œshell è¿›ç¨‹å°†è·å¾—ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨äºå†™å…¥æ–‡ä»¶ã€‚ ç„¶åï¼Œshell è¿›ç¨‹é€šè¿‡ write ç³»ç»Ÿè°ƒç”¨å°†æ–‡æœ¬ â€œThis is a test file.â€ å†™å…¥æ–‡ä»¶ã€‚è¿™å°†å¯¼è‡´å†…æ ¸åœ¨ tmpfs æ–‡ä»¶ç³»ç»Ÿä¸­åˆ†é…å†…å­˜æ¥å­˜å‚¨æ–‡ä»¶æ•°æ®ã€‚ å½“æ–‡æœ¬è¢«å†™å…¥æ–‡ä»¶åï¼Œshell è¿›ç¨‹ä½¿ç”¨ close ç³»ç»Ÿè°ƒç”¨å…³é—­æ–‡ä»¶æè¿°ç¬¦ã€‚ åˆ é™¤tmpfsæ–‡ä»¶ç³»ç»Ÿçš„å‘½ä»¤1rm /home/plucky/path/mytmpfs/testfile.txt å½“è¿è¡Œæ­¤å‘½ä»¤æ—¶ï¼Œä¼šå‘ç”Ÿä»¥ä¸‹äº‹æƒ…ï¼š é¦–å…ˆï¼Œshell è¿›ç¨‹é€šè¿‡ unlink æˆ– unlinkat ç³»ç»Ÿè°ƒç”¨å°è¯•åˆ é™¤æ–‡ä»¶ /home/plucky/path/mytmpfs/testfile.txtã€‚ å†…æ ¸å°†è§£ææ–‡ä»¶è·¯å¾„ï¼Œå¹¶ç¡®è®¤ /mnt/tmpfs æ˜¯ä¸€ä¸ªå·²æŒ‚è½½çš„ tmpfs æ–‡ä»¶ç³»ç»Ÿã€‚ æ¥ä¸‹æ¥ï¼Œå†…æ ¸å°†é€šè¿‡ tmpfs æ–‡ä»¶ç³»ç»Ÿçš„ inode_operations ç»“æ„ä½“ä¸­çš„ unlink æ–¹æ³•æ¥æ‰§è¡Œåˆ é™¤æ“ä½œã€‚å…·ä½“æ¥è¯´ï¼Œå¯¹äº tmpfsï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯ shmem_unlinkã€‚ shmem_unlink å‡½æ•°å°†å¤„ç†æ–‡ä»¶çš„å†…å­˜é‡Šæ”¾ã€‚è¿™åŒ…æ‹¬é‡Šæ”¾æ–‡ä»¶æ•°æ®å ç”¨çš„å†…å­˜å’Œæ–‡ä»¶å…ƒæ•°æ®ï¼ˆå¦‚ inodeï¼‰å ç”¨çš„å†…å­˜ã€‚ æœ€åï¼Œæ–‡ä»¶ä»æ–‡ä»¶ç³»ç»Ÿä¸­åˆ é™¤ï¼Œä¸å†å¯è®¿é—®ã€‚ é‡å¯æœºå™¨ä¹‹åï¼Œtmpfsæ–‡ä»¶å¤¹tmpfsæ–‡ä»¶ç³»ç»Ÿä¸­çš„æ–‡ä»¶è¢«åˆ é™¤ï¼Œè€Œtmpfsæ–‡ä»¶ç³»ç»Ÿä¹Ÿè¢«å¸è½½ å¦‚æœè¦åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶è‡ªåŠ¨æŒ‚è½½tmpfså‘½ä»¤ï¼Œéœ€è¦å°†æŒ‚è½½ä¿¡æ¯æ·»åŠ åˆ°ç³»ç»Ÿçš„å¯åŠ¨é…ç½®æ–‡ä»¶ä¸­ã€‚è¿™æ ·æ¯æ¬¡ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œè¯¥æ–‡ä»¶ç³»ç»Ÿéƒ½ä¼šè‡ªåŠ¨æŒ‚è½½ã€‚ä¾‹å¦‚ï¼Œè¦å°†ä¸€ä¸ª tmpfs æ–‡ä»¶ç³»ç»ŸæŒ‚è½½åˆ° /home/plucky/mytmpfs ç›®å½•ï¼Œå¯ä»¥åœ¨ /etc/fstab æ–‡ä»¶ä¸­æ·»åŠ ä»¥ä¸‹è¡Œï¼š 1tmpfs /home/plucky/mytmpfs tmpfs defaults 0 0 å³è¿è¡Œä¸€ä¸‹å‘½ä»¤ 1sudo sh -c &#x27;echo &quot;tmpfs /home/plucky/path/mytmpfs tmpfs defaults 0 0&quot; &gt;&gt; /etc/fstab&#x27; sudo å‘½ä»¤ç”¨äºä»¥ç®¡ç†å‘˜æƒé™è¿è¡Œæ­¤å‘½ä»¤ï¼Œå› ä¸º /etc/fstab æ–‡ä»¶éœ€è¦ç®¡ç†å‘˜æƒé™æ‰èƒ½ä¿®æ”¹ã€‚ tmpfsçš„å®ç°å‡½æ•°è°ƒç”¨é“¾ï¼ˆLinux v6.3.6ï¼Œv6.3.7ä¸ºä¾‹ï¼‰ æŒ‚è½½tmpfsæ–‡ä»¶ç³»ç»Ÿï¼š 12345678910mount â””â”€â”€ do_mount â””â”€â”€ path_mount â””â”€â”€ do_new_mount â”œâ”€â”€ vfs_get_treeï¼ˆåŸºäºç»™å®šçš„ä¸Šä¸‹æ–‡åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„æ–‡ä»¶ç³»ç»Ÿå®ä¾‹ï¼‰ â”‚ â””â”€â”€ shmem_get_tree â”‚ â””â”€â”€ shmem_fill_super â”‚ â””â”€â”€ shmem_get_inode â””â”€â”€ do_new_mount_fs â””â”€â”€ do_add_mount å­˜å‚¨æ–‡ä»¶è¿›å…¥tmpfsæ–‡ä»¶ç³»ç»Ÿï¼š æ‰“å¼€æ–‡ä»¶æˆ–åˆ›å»ºæ–°æ–‡ä»¶ï¼š 1234567891011121314151617open() â””â”€â”€ do_sys_open â””â”€â”€ do_filp_open â”œâ”€â”€ path_openat â”‚ â”œâ”€â”€ link_path_walk â”‚ â”‚ â”œâ”€â”€ lookup_fast â”‚ â”‚ â”‚ â””â”€â”€ __d_lookup_rcu â”‚ â”‚ â”‚ â””â”€â”€ hlist_bl_for_each_entry_rcu â”‚ â”‚ â””â”€â”€ lookup_slow â”‚ â”‚ â””â”€â”€ __lookup_slow â”‚ â”‚ â””â”€â”€simple_lookup â”‚ â””â”€â”€ open_last_lookupsï¼ˆåˆ›å»ºæ–°æ–‡ä»¶ï¼‰ â”‚ â””â”€â”€shmem_create â”‚ â””â”€â”€ shmem_mknod â””â”€â”€ do_open â””â”€â”€ vfs_open â””â”€â”€ do_dentry_open è¯»æ–‡ä»¶ï¼š 123456read() â””â”€â”€ ksys_read â””â”€â”€ vfs_read â””â”€â”€ new_sync_read â””â”€â”€ call_read_iter â””â”€â”€ shmem_file_read_iter å†™æ–‡ä»¶ï¼š 123456789write() â””â”€â”€ ksys_write â””â”€â”€ vfs_write â””â”€â”€ new_sync_write â””â”€â”€ call_write_iter â””â”€â”€ generic_file_write_iter â””â”€â”€ __generic_file_write_iter â”œâ”€â”€ generic_file_direct_writeç›´å†™ â””â”€â”€ generic_perform_writeå›å†™ åˆ é™¤æ–‡ä»¶ï¼š 1234unlink() â””â”€â”€ do_unlinkat â””â”€â”€ vfs_unlink â””â”€â”€ shmem_unlink æŒ‚è½½tmpfsæ–‡ä»¶ç³»ç»Ÿæµç¨‹å½“ç”¨æˆ·è¿è¡Œmountå‘½ä»¤æ—¶ï¼Œé¦–å…ˆæ‰§è¡Œmountç³»ç»Ÿè°ƒç”¨ 1sudo mount -t tmpfs -o size=512M tmpfs æ–‡ä»¶å¤¹ mountç³»ç»Ÿè°ƒç”¨sys_mount identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344// ç³»ç»Ÿè°ƒç”¨çš„å®šä¹‰ï¼ŒåŒ…æ‹¬5ä¸ªå‚æ•°ï¼šdev_name, dir_name, type, flags, dataã€‚SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name, char __user *, type, unsigned long, flags, void __user *, data)&#123; int ret; // ç”¨äºå­˜å‚¨è¿”å›å€¼ char *kernel_type; // ä»ç”¨æˆ·ç©ºé—´æ‹·è´çš„æ–‡ä»¶ç³»ç»Ÿç±»å‹å­—ç¬¦ä¸² char *kernel_dev; // ä»ç”¨æˆ·ç©ºé—´æ‹·è´çš„è®¾å¤‡åæˆ–æºå­—ç¬¦ä¸² void *options; // ä»ç”¨æˆ·ç©ºé—´æ‹·è´çš„æŒ‚è½½é€‰é¡¹ // å°†æ–‡ä»¶ç³»ç»Ÿç±»å‹ä»ç”¨æˆ·ç©ºé—´æ‹·è´åˆ°å†…æ ¸ç©ºé—´ kernel_type = copy_mount_string(type); // æ£€æŸ¥æ‹·è´æ“ä½œæ˜¯å¦å‡ºé”™ ret = PTR_ERR(kernel_type); if (IS_ERR(kernel_type)) goto out_type; // å°†è®¾å¤‡åæˆ–æºä»ç”¨æˆ·ç©ºé—´æ‹·è´åˆ°å†…æ ¸ç©ºé—´ kernel_dev = copy_mount_string(dev_name); // æ£€æŸ¥æ‹·è´æ“ä½œæ˜¯å¦å‡ºé”™ ret = PTR_ERR(kernel_dev); if (IS_ERR(kernel_dev)) goto out_dev; // å°†æŒ‚è½½é€‰é¡¹ä»ç”¨æˆ·ç©ºé—´æ‹·è´åˆ°å†…æ ¸ç©ºé—´ options = copy_mount_options(data); // æ£€æŸ¥æ‹·è´æ“ä½œæ˜¯å¦å‡ºé”™ ret = PTR_ERR(options); if (IS_ERR(options)) goto out_data; // æ‰§è¡ŒæŒ‚è½½æ“ä½œ ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options); // é‡Šæ”¾æŒ‚è½½é€‰é¡¹å†…å­˜ kfree(options);out_data: // é‡Šæ”¾è®¾å¤‡åæˆ–æºå†…å­˜ kfree(kernel_dev);out_dev: // é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿç±»å‹å†…å­˜ kfree(kernel_type);out_type: return ret; // è¿”å›ç»“æœ&#125; é¦–å…ˆå°†dev_nameã€dir_nameã€typeå’Œdataè¿™äº›ä»ç”¨æˆ·ç©ºé—´ä¼ å…¥çš„å‚æ•°æ‹·è´åˆ°å†…æ ¸ç©ºé—´ã€‚ç„¶åï¼Œå®ƒè°ƒç”¨do_mountå‡½æ•°æ¥æ‰§è¡Œå®é™…çš„æŒ‚è½½æ“ä½œã€‚ do_mountå‡½æ•°do_mount identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819long do_mount(const char *dev_name, const char __user *dir_name, const char *type_page, unsigned long flags, void *data_page)&#123; struct path path; // ç”¨äºå­˜å‚¨æŒ‚è½½ç‚¹çš„è·¯å¾„ç»“æ„ int ret; // ç”¨äºå­˜å‚¨è¿”å›å€¼ // è·å–ç”¨æˆ·ç©ºé—´ä¼ å…¥çš„æŒ‚è½½ç‚¹è·¯å¾„ï¼Œå¹¶å°†å…¶è§£æä¸ºå†…æ ¸ç©ºé—´çš„è·¯å¾„ç»“æ„ ret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path); if (ret) // æ£€æŸ¥è·¯å¾„è§£ææ˜¯å¦æˆåŠŸ return ret; // æ‰§è¡Œå®é™…çš„æŒ‚è½½æ“ä½œ ret = path_mount(dev_name, &amp;path, type_page, flags, data_page); // é‡Šæ”¾è·¯å¾„ç»“æ„çš„å¼•ç”¨ path_put(&amp;path); return ret; // è¿”å›ç»“æœ&#125; é¦–å…ˆé€šè¿‡user_path_atå‡½æ•°å°†ç”¨æˆ·ç©ºé—´ä¼ å…¥çš„æŒ‚è½½ç‚¹è·¯å¾„è§£æä¸ºå†…æ ¸ç©ºé—´çš„pathç»“æ„ã€‚ç„¶åï¼Œè°ƒç”¨path_mountå‡½æ•°æ‰§è¡Œå®é™…çš„æŒ‚è½½æ“ä½œã€‚å®ŒæˆæŒ‚è½½æ“ä½œåï¼Œé‡Šæ”¾pathç»“æ„çš„å¼•ç”¨ã€‚ path_mountå‡½æ•°path_mount identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int path_mount(const char *dev_name, struct path *path, const char *type_page, unsigned long flags, void *data_page)&#123; unsigned int mnt_flags = 0, sb_flags; // å®šä¹‰æŒ‚è½½æ ‡å¿—å’Œè¶…çº§å—æ ‡å¿— int ret; // ç”¨äºå­˜å‚¨è¿”å›å€¼ // å»é™¤æŒ‚è½½æ ‡å¿—çš„å¹»æ•°ï¼ˆmagic numberï¼‰ if ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL) flags &amp;= ~MS_MGC_MSK; // åŸºæœ¬çš„å‚æ•°æ£€æŸ¥ if (data_page) ((char *)data_page)[PAGE_SIZE - 1] = 0; // æ£€æŸ¥ä¸å…è®¸ç”¨æˆ·æŒ‚è½½çš„æƒ…å†µ if (flags &amp; MS_NOUSER) return -EINVAL; // å®‰å…¨æ£€æŸ¥ ret = security_sb_mount(dev_name, path, type_page, flags, data_page); if (ret) return ret; if (!may_mount()) return -EPERM; if (flags &amp; SB_MANDLOCK) warn_mandlock(); // é»˜è®¤è®¾ç½®ä¸ºrelatimeï¼Œé™¤éæ˜¾å¼æŒ‡å®šnoatime if (!(flags &amp; MS_NOATIME)) mnt_flags |= MNT_RELATIME; // åˆ†ç¦»æ¯ä¸ªæŒ‚è½½ç‚¹çš„æ ‡å¿— if (flags &amp; MS_NOSUID) mnt_flags |= MNT_NOSUID; if (flags &amp; MS_NODEV) mnt_flags |= MNT_NODEV; if (flags &amp; MS_NOEXEC) mnt_flags |= MNT_NOEXEC; if (flags &amp; MS_NOATIME) mnt_flags |= MNT_NOATIME; if (flags &amp; MS_NODIRATIME) mnt_flags |= MNT_NODIRATIME; if (flags &amp; MS_STRICTATIME) mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME); if (flags &amp; MS_RDONLY) mnt_flags |= MNT_READONLY; if (flags &amp; MS_NOSYMFOLLOW) mnt_flags |= MNT_NOSYMFOLLOW; // ä¿ç•™atimeçš„é»˜è®¤å€¼ if ((flags &amp; MS_REMOUNT) &amp;&amp; ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME | MS_STRICTATIME)) == 0)) &#123; mnt_flags &amp;= ~MNT_ATIME_MASK; mnt_flags |= path-&gt;mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK; &#125; // è®¾ç½®è¶…çº§å—æ ‡å¿— sb_flags = flags &amp; (SB_RDONLY | SB_SYNCHRONOUS | SB_MANDLOCK | SB_DIRSYNC | SB_SILENT | SB_POSIXACL | SB_LAZYTIME | SB_I_VERSION); // é‡æ–°é…ç½®æŒ‚è½½ç‚¹ if ((flags &amp; (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND)) return do_reconfigure_mnt(path, mnt_flags); // é‡æ–°æŒ‚è½½ if (flags &amp; MS_REMOUNT) return do_remount(path, flags, sb_flags, mnt_flags, data_page); // ç»‘å®šæŒ‚è½½ if (flags &amp; MS_BIND) return do_loopback(path, dev_name, flags &amp; MS_REC); // æ›´æ”¹æŒ‚è½½ç±»å‹ if (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) return do_change_type(path, flags); // ç§»åŠ¨æŒ‚è½½ç‚¹ if (flags &amp; MS_MOVE) return do_move_mount_old(path, dev_name); // æ‰§è¡Œæ–°çš„æŒ‚è½½æ“ä½œ return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name, data_page);&#125; path_mountå‡½æ•°è´Ÿè´£å¤„ç†ä¸åŒç±»å‹çš„æŒ‚è½½è¯·æ±‚ï¼ŒåŒ…æ‹¬é‡æ–°æŒ‚è½½ã€ç»‘å®šæŒ‚è½½ã€æ›´æ”¹æŒ‚è½½ç±»å‹å’Œç§»åŠ¨æŒ‚è½½ç‚¹ã€‚é¦–å…ˆï¼Œå‡½æ•°æ‰§è¡ŒåŸºæœ¬çš„å‚æ•°æ£€æŸ¥ã€å®‰å…¨æ£€æŸ¥å’Œè®¾ç½®æŒ‚è½½æ ‡å¿—ã€‚æ¥ä¸‹æ¥ï¼Œæ ¹æ®ä¸åŒçš„æŒ‚è½½æ ‡å¿—ï¼Œè°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°ã€‚ do_new_mountå‡½æ•°do_new_mount identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static int do_new_mount(struct path *path, const char *fstype, int sb_flags, int mnt_flags, const char *name, void *data)&#123; struct file_system_type *type; // æ–‡ä»¶ç³»ç»Ÿç±»å‹ struct fs_context *fc; // æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ const char *subtype = NULL; // å­ç±»å‹ int err = 0; // é”™è¯¯ç  // éªŒè¯æ–‡ä»¶ç³»ç»Ÿç±»å‹æ˜¯å¦ä¸ºç©º if (!fstype) return -EINVAL; // è·å–æ–‡ä»¶ç³»ç»Ÿç±»å‹ type = get_fs_type(fstype); if (!type) return -ENODEV; // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦æœ‰å­ç±»å‹ï¼Œå¹¶è·å–å­ç±»å‹ if (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &#123; subtype = strchr(fstype, &#x27;.&#x27;); if (subtype) &#123; subtype++; if (!*subtype) &#123; put_filesystem(type); return -EINVAL; &#125; &#125; &#125; // åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ fc = fs_context_for_mount(type, sb_flags); put_filesystem(type); // å‡å°‘æ–‡ä»¶ç³»ç»Ÿç±»å‹çš„å¼•ç”¨è®¡æ•° if (IS_ERR(fc)) return PTR_ERR(fc); // è§£ææ–‡ä»¶ç³»ç»Ÿå­ç±»å‹ if (subtype) err = vfs_parse_fs_string(fc, &quot;subtype&quot;, subtype, strlen(subtype)); // è§£ææ–‡ä»¶ç³»ç»Ÿåç§° if (!err &amp;&amp; name) err = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // è§£ææŒ‚è½½æ•°æ® if (!err) err = parse_monolithic_mount_data(fc, data); // æ£€æŸ¥æŒ‚è½½æƒé™ if (!err &amp;&amp; !mount_capable(fc)) err = -EPERM; // è·å–æ–‡ä»¶ç³»ç»Ÿæ ‘ if (!err) err = vfs_get_tree(fc); // å®ŒæˆæŒ‚è½½æ“ä½œ if (!err) err = do_new_mount_fc(fc, path, mnt_flags); // é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ put_fs_context(fc); return err;&#125; vfs_get_treeå‡½æ•°vfs_get_tree identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int vfs_get_tree(struct fs_context *fc)&#123; struct super_block *sb; // è¶…çº§å— int error; // å¦‚æœæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ä¸­å·²ç»æœ‰ä¸€ä¸ªæ ¹ç›®å½•ï¼Œåˆ™è¿”å›é”™è¯¯ if (fc-&gt;root) return -EBUSY; // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿæ“ä½œç»“æ„ä¸­çš„get_treeå‡½æ•°æ¥è·å–æ–‡ä»¶ç³»ç»Ÿæ ‘ï¼Œå¹¶å°†æ ¹ç›®å½•æ”¾åœ¨fc-&gt;rootä¸­ // åŒæ—¶å¢åŠ æ ¹ç›®å½•å’Œè¶…çº§å—çš„å¼•ç”¨è®¡æ•° error = fc-&gt;ops-&gt;get_tree(fc); if (error &lt; 0) return error; // å¦‚æœget_treeæ²¡æœ‰è®¾ç½®fc-&gt;rootï¼Œåˆ™è¾“å‡ºé”™è¯¯ä¿¡æ¯å¹¶è§¦å‘BUG() if (!fc-&gt;root) &#123; pr_err(&quot;Filesystem %s get_tree() didn&#x27;t set fc-&gt;root\\n&quot;, fc-&gt;fs_type-&gt;name); BUG(); &#125; // è·å–è¶…çº§å— sb = fc-&gt;root-&gt;d_sb; // æ£€æŸ¥è¶…çº§å—çš„å—è®¾å¤‡ä¿¡æ¯æ˜¯å¦å­˜åœ¨ WARN_ON(!sb-&gt;s_bdi); // å†™å†…å­˜å±éšœï¼Œç¡®ä¿è¶…çº§å—ç»“æ„åœ¨è®¾ç½®SB_BORNæ ‡å¿—ä½ä¹‹å‰å®Œæˆ smp_wmb(); // è®¾ç½®è¶…çº§å—çš„SB_BORNæ ‡å¿—ä½ sb-&gt;s_flags |= SB_BORN; // è®¾ç½®å®‰å…¨æ¨¡å—çš„æŒ‚è½½é€‰é¡¹ error = security_sb_set_mnt_opts(sb, fc-&gt;security, 0, NULL); if (unlikely(error)) &#123; // å¦‚æœè®¾ç½®å¤±è´¥ï¼Œé‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡å¹¶è¿”å›é”™è¯¯ fc_drop_locked(fc); return error; &#125; // æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦è®¾ç½®äº†é”™è¯¯çš„s_maxbyteså€¼ WARN((sb-&gt;s_maxbytes &lt; 0), &quot;%s set sb-&gt;s_maxbytes to &quot; &quot;negative value (%lld)\\n&quot;, fc-&gt;fs_type-&gt;name, sb-&gt;s_maxbytes); return 0;&#125;EXPORT_SYMBOL(vfs_get_tree); get_treeå‡½æ•°æ˜¯å¦‚ä½•è¢«è®¾ç½®ä¸ºshmem_initå‡½æ•°çš„ å½“å†…æ ¸å¯åŠ¨æ—¶ï¼Œä¼šæ‰§è¡Œshmem_initå‡½æ•°ï¼ˆå®šä¹‰åœ¨mm/shmem.cæ–‡ä»¶ä¸­ï¼‰ã€‚è¿™ä¸ªå‡½æ•°ä¼šè°ƒç”¨register_filesystemæ³¨å†Œtmpfsæ–‡ä»¶ç³»ç»Ÿã€‚ shmem_init identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __init shmem_init(void)&#123;// åˆå§‹åŒ– inode ç¼“å­˜shmem_init_inodecache();// æ³¨å†Œ tmpfs æ–‡ä»¶ç³»ç»Ÿint error = register_filesystem(&amp;shmem_fs_type);if (error) &#123; // è‹¥æ³¨å†Œå¤±è´¥ï¼Œæ‰“å°é”™è¯¯ä¿¡æ¯ pr_err(&quot;Could not register tmpfs\\n&quot;); // è·³è½¬åˆ° out2ï¼Œæ‰§è¡Œæ¸…ç†æ“ä½œ goto out2;&#125;// å°è¯•æŒ‚è½½ tmpfs æ–‡ä»¶ç³»ç»Ÿshm_mnt = kern_mount(&amp;shmem_fs_type);if (IS_ERR(shm_mnt)) &#123; // è‹¥æŒ‚è½½å¤±è´¥ï¼Œè·å–é”™è¯¯ä»£ç  error = PTR_ERR(shm_mnt); // æ‰“å°é”™è¯¯ä¿¡æ¯ pr_err(&quot;Could not kern_mount tmpfs\\n&quot;); // è·³è½¬åˆ° out1ï¼Œæ‰§è¡Œæ¸…ç†æ“ä½œ goto out1;&#125;#ifdef CONFIG_TRANSPARENT_HUGEPAGE// å¦‚æœæ”¯æŒé€æ˜å·¨é¡µï¼Œä¸”å·¨é¡µè®¾ç½®ä¸ä¸ºç¦ç”¨ï¼Œè®¾ç½®å·¨é¡µé€‰é¡¹if (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY) SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;else // å¦åˆ™ï¼Œå°†å·¨é¡µè®¾ç½®ä¸ºæ°¸ä¸ä½¿ç”¨ï¼Œä»¥é˜²ä¸‡ä¸€ shmem_huge = SHMEM_HUGE_NEVER;#endif// æˆåŠŸæ‰§è¡Œï¼Œå‡½æ•°è¿”å›return;out1:// æ¸…ç†æ“ä½œï¼šæ³¨é”€ tmpfs æ–‡ä»¶ç³»ç»Ÿunregister_filesystem(&amp;shmem_fs_type);out2:// æ¸…ç†æ“ä½œï¼šé”€æ¯ inode ç¼“å­˜shmem_destroy_inodecache();// è®¾ç½® shm_mnt ä¸ºé”™è¯¯æŒ‡é’ˆï¼Œè¡¨ç¤ºåˆå§‹åŒ–å¤±è´¥shm_mnt = ERR_PTR(error);&#125; shmem_fs_typeæ˜¯ä¸€ä¸ªfile_system_typeç»“æ„ä½“ï¼Œå®šä¹‰äº†tmpfsæ–‡ä»¶ç³»ç»Ÿçš„åŸºæœ¬ä¿¡æ¯ã€‚åœ¨è¿™ä¸ªç»“æ„ä½“ä¸­ï¼Œinit_fs_contextæˆå‘˜è¢«è®¾ç½®ä¸ºshmem_init_fs_contextã€‚ shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314static struct file_system_type shmem_fs_type = &#123;.owner = THIS_MODULE, // æŒ‡å®šæ–‡ä»¶ç³»ç»Ÿæ¨¡å—çš„æ‰€æœ‰è€….name = &quot;tmpfs&quot;, // æ–‡ä»¶ç³»ç»Ÿçš„åç§°.init_fs_context = shmem_init_fs_context, // åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„å›è°ƒå‡½æ•°#ifdef CONFIG_TMPFS.parameters = shmem_fs_parameters, // æŒ‡å®šæ–‡ä»¶ç³»ç»Ÿçš„æŒ‚è½½å‚æ•°è§£æå›è°ƒ#endif.kill_sb = kill_litter_super, // ç”¨äºé”€æ¯è¶…çº§å—çš„å›è°ƒå‡½æ•°#ifdef CONFIG_SHMEM.fs_flags = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, // æ–‡ä»¶ç³»ç»Ÿçš„æ ‡å¿—ï¼ˆæ”¯æŒç”¨æˆ·å‘½åç©ºé—´æŒ‚è½½å’ŒIDæ˜ å°„ï¼‰#else.fs_flags = FS_USERNS_MOUNT, // æ–‡ä»¶ç³»ç»Ÿçš„æ ‡å¿—ï¼ˆä»…æ”¯æŒç”¨æˆ·å‘½åç©ºé—´æŒ‚è½½ï¼‰#endif&#125;; å½“ç”¨æˆ·å‘èµ·æŒ‚è½½tmpfsæ–‡ä»¶ç³»ç»Ÿçš„è¯·æ±‚æ—¶ï¼Œå†…æ ¸ä¼šæ ¹æ®shmem_fs_typeç»“æ„ä½“ä¸­çš„init_fs_contextæˆå‘˜è°ƒç”¨shmem_init_fs_contextå‡½æ•°ï¼Œä»¥åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ï¼ˆfs_contextç»“æ„ä½“ï¼‰ã€‚ åœ¨shmem_init_fs_contextå‡½æ•°ä¸­ï¼Œä¼šåˆ›å»ºä¸€ä¸ªshmem_fs_contextç»“æ„ä½“å®ä¾‹å¹¶å°†å…¶å­˜å‚¨åœ¨fc-&gt;fs_privateæˆå‘˜ä¸­ã€‚ç„¶åï¼Œå°†fs_contextç»“æ„ä½“çš„opsæˆå‘˜è®¾ç½®ä¸º&amp;shmem_fs_context_opsã€‚ shmem_init_fs_context identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223int shmem_init_fs_context(struct fs_context *fc)&#123;// å®šä¹‰ä¸€ä¸ªæŒ‡å‘ shmem_options ç»“æ„ä½“çš„æŒ‡é’ˆstruct shmem_options *ctx;// ä¸º shmem_options ç»“æ„ä½“åˆ†é…å†…å­˜ctx = kzalloc(sizeof(struct shmem_options), GFP_KERNEL);if (!ctx) // å¦‚æœå†…å­˜åˆ†é…å¤±è´¥ï¼Œè¿”å› ENOMEM é”™è¯¯ return -ENOMEM;// è®¾ç½®æ–‡ä»¶è®¿é—®æƒé™ä¸º 0777ï¼ˆç”¨æˆ·ã€ç»„å’Œå…¶ä»–å‡æœ‰è¯»ã€å†™å’Œæ‰§è¡Œæƒé™ï¼‰ï¼Œå¹¶å¯ç”¨ç²˜æ»ä½ctx-&gt;mode = 0777 | S_ISVTX;// è·å–å½“å‰è¿›ç¨‹çš„æ–‡ä»¶ç³»ç»Ÿç”¨æˆ· IDï¼Œå¹¶å°†å…¶è®¾ç½®ä¸ºæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„ç”¨æˆ· IDctx-&gt;uid = current_fsuid();// è·å–å½“å‰è¿›ç¨‹çš„æ–‡ä»¶ç³»ç»Ÿç»„ IDï¼Œå¹¶å°†å…¶è®¾ç½®ä¸ºæ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„ç»„ IDctx-&gt;gid = current_fsgid();// å°†åˆå§‹åŒ–åçš„ shmem_options ç»“æ„ä½“èµ‹ç»™ fs_context ç»“æ„ä½“çš„ fs_private æˆå‘˜fc-&gt;fs_private = ctx;// è®¾ç½® fs_context ç»“æ„ä½“çš„æ“ä½œå‡½æ•°é›†fc-&gt;ops = &amp;shmem_fs_context_ops;// è¿”å› 0ï¼Œè¡¨ç¤ºæˆåŠŸåˆå§‹åŒ–æ–‡ shmem_fs_context_opsæ˜¯ä¸€ä¸ªfs_context_operationsç»“æ„ä½“ï¼Œå…¶ä¸­çš„get_treeæˆå‘˜è¢«è®¾ç½®ä¸ºshmem_get_treeã€‚ shmem_fs_context_ops identifier - Linux source code (v6.3.6) - Bootlin 123456789static const struct fs_context_operations shmem_fs_context_ops = &#123;.free = shmem_free_fc,.get_tree = shmem_get_tree,#ifdef CONFIG_TMPFS.parse_monolithic = shmem_parse_options,.parse_param = shmem_parse_one,.reconfigure = shmem_reconfigure,#endif&#125;; å½“å†…æ ¸ç»§ç»­æ‰§è¡ŒæŒ‚è½½è¿‡ç¨‹ï¼Œè°ƒç”¨vfs_get_treeå‡½æ•°æ—¶ï¼Œä¼šæ ¹æ®fs_contextç»“æ„ä½“çš„opsæˆå‘˜ï¼ˆå³&amp;shmem_fs_context_opsï¼‰é—´æ¥è°ƒç”¨shmem_get_treeå‡½æ•°ã€‚ shmem_get_treeå‡½æ•°shmem_get_tree identifier - Linux source code (v6.3.6) - Bootlin 1234static int shmem_get_tree(struct fs_context *fc)&#123; return get_tree_nodev(fc, shmem_fill_super);&#125; shmem_fill_superå‡½æ•°shmem_fill_super identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128static int shmem_fill_super(struct super_block *sb, struct fs_context *fc)&#123; struct shmem_options *ctx = fc-&gt;fs_private;//ctxæŒ‡å‘ä¸€ä¸ªshmem_optionsç»“æ„ä½“ï¼ŒåŒ…å«äº†tmpfså®ä¾‹çš„é€‰é¡¹ï¼Œå¦‚æœ€å¤§å—æ•°ã€æœ€å¤§inodeæ•°ç­‰ã€‚è¿™äº›é€‰é¡¹é€šå¸¸åœ¨æŒ‚è½½tmpfsæ—¶ç”±ç”¨æˆ·æŒ‡å®šã€‚ struct inode *inode;//inodeæŒ‡å‘ä¸€ä¸ªinodeç»“æ„ä½“ï¼Œç”¨äºè¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿä¸­çš„ä¸€ä¸ªæ–‡ä»¶ã€‚è¿™é‡Œçš„inodeå°†ç”¨äºè¡¨ç¤ºtmpfså®ä¾‹çš„æ ¹ç›®å½•ã€‚ struct shmem_sb_info *sbinfo;//sbinfoæŒ‡å‘ä¸€ä¸ªshmem_sb_infoç»“æ„ä½“ï¼ŒåŒ…å«äº†tmpfså®ä¾‹çš„å…ƒæ•°æ®ï¼Œå¦‚æœ€å¤§å—æ•°ã€æœ€å¤§inodeæ•°ã€å·²ä½¿ç”¨çš„å—æ•°ç­‰ã€‚ /* Round up to L1_CACHE_BYTES to resist false sharing *//* ä¸ºshmem_sb_infoç»“æ„ä½“åˆ†é…å†…å­˜ï¼Œè€ƒè™‘ç¼“å­˜å¯¹é½ */ sbinfo = kzalloc(max((int)sizeof(struct shmem_sb_info), L1_CACHE_BYTES), GFP_KERNEL); /* åˆ†é…å†…å­˜å¤±è´¥æ—¶è¿”å›é”™è¯¯ */ if (!sbinfo) return -ENOMEM; /* å°†shmem_sb_infoç»“æ„ä½“æŒ‡é’ˆä¿å­˜åˆ°super_blockçš„s_fs_infoå­—æ®µ */ sb-&gt;s_fs_info = sbinfo;#ifdef CONFIG_TMPFS /* * Per default we only allow half of the physical ram per * tmpfs instance, limiting inodes to one per page of lowmem; * but the internal instance is left unlimited. *//**é»˜è®¤æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åªå…è®¸æ¯*tmpfså®ä¾‹ï¼Œå°†inodeé™åˆ¶ä¸ºæ¯é¡µlowmemä¸€ä¸ªï¼›*ä½†æ˜¯å†…éƒ¨å®ä¾‹æ˜¯ä¸å—é™åˆ¶çš„ã€‚*///å¯¹äºéå†…æ ¸æŒ‚è½½çš„tmpfså®ä¾‹ï¼Œè®¾ç½®é»˜è®¤çš„æœ€å¤§å—æ•°ã€æœ€å¤§inodeæ•°å’Œæ˜¯å¦ä½¿ç”¨64ä½inodeç¼–å·ã€‚å¯¹äºå†…æ ¸æŒ‚è½½çš„tmpfså®ä¾‹ï¼Œè®¾ç½®SB_N#ifdef CONFIG_TMPFS/* åˆ¤æ–­æ˜¯å¦ä¸ºå†…æ ¸æŒ‚è½½ */ if (!(sb-&gt;s_flags &amp; SB_KERNMOUNT)) &#123; /* è®¾ç½®é»˜è®¤çš„æœ€å¤§å—æ•°ï¼ˆå¦‚æœæœªæŒ‡å®šï¼‰ */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_BLOCKS)) ctx-&gt;blocks = shmem_default_max_blocks(); /* è®¾ç½®é»˜è®¤çš„æœ€å¤§inodeæ•°ï¼ˆå¦‚æœæœªæŒ‡å®šï¼‰ */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_INODES)) ctx-&gt;inodes = shmem_default_max_inodes(); /* è®¾ç½®æ˜¯å¦ä½¿ç”¨64ä½inodeç¼–å·ï¼ˆå¦‚æœæœªæŒ‡å®šï¼‰ */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_INUMS)) ctx-&gt;full_inums = IS_ENABLED(CONFIG_TMPFS_INODE64); &#125; else &#123; /* å†…æ ¸æŒ‚è½½çš„tmpfså®ä¾‹ï¼Œè®¾ç½®SB_NOUSERæ ‡å¿— */ sb-&gt;s_flags |= SB_NOUSER; &#125; /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿå¯¼å‡ºæ“ä½œ */ sb-&gt;s_export_op = &amp;shmem_export_ops; /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿæ ‡å¿— */ sb-&gt;s_flags |= SB_NOSEC | SB_I_VERSION;#else /* å¦‚æœä¸æ”¯æŒtmpfsï¼Œè®¾ç½®SB_NOUSERæ ‡å¿— */ sb-&gt;s_flags |= SB_NOUSER;#endif /* è®¾ç½®shmem_sb_infoçš„æœ€å¤§å—æ•°å­—æ®µ */ sbinfo-&gt;max_blocks = ctx-&gt;blocks; /* è®¾ç½®shmem_sb_infoçš„æœ€å¤§inodeæ•°é‡å’Œç©ºé—²inodeæ•°é‡ */ sbinfo-&gt;free_inodes = sbinfo-&gt;max_inodes = ctx-&gt;inodes; /* å¦‚æœæ˜¯å†…æ ¸æŒ‚è½½ï¼Œä¸ºæ¯ä¸ªCPUåˆ†é…ä¸€ä¸ªino_tç±»å‹çš„å†…å­˜ */ if (sb-&gt;s_flags &amp; SB_KERNMOUNT) &#123; sbinfo-&gt;ino_batch = alloc_percpu(ino_t); /* åˆ†é…å¤±è´¥æ—¶è·³è½¬åˆ°å¤±è´¥å¤„ç† */ if (!sbinfo-&gt;ino_batch) goto failed; &#125; /* è®¾ç½®uidå’Œgid */ sbinfo-&gt;uid = ctx-&gt;uid; sbinfo-&gt;gid = ctx-&gt;gid; /* è®¾ç½®æ˜¯å¦ä½¿ç”¨64ä½inodeç¼–å· */ sbinfo-&gt;full_inums = ctx-&gt;full_inums; /* è®¾ç½®æƒé™æ¨¡å¼ */ sbinfo-&gt;mode = ctx-&gt;mode; /* è®¾ç½®æ˜¯å¦ä½¿ç”¨å¤§é¡µé¢ */ sbinfo-&gt;huge = ctx-&gt;huge; /* è®¾ç½®å†…å­˜åˆ†é…ç­–ç•¥ */ sbinfo-&gt;mpol = ctx-&gt;mpol; /* æ¸…ç©ºctxçš„mpolæŒ‡é’ˆï¼Œé¿å…åç»­é‡Šæ”¾ */ ctx-&gt;mpol = NULL; /* åˆå§‹åŒ–stat_lockè‡ªæ—‹é” */ raw_spin_lock_init(&amp;sbinfo-&gt;stat_lock); /* åˆå§‹åŒ–used_blocks per-CPUè®¡æ•°å™¨ */ if (percpu_counter_init(&amp;sbinfo-&gt;used_blocks, 0, GFP_KERNEL)) /* åˆå§‹åŒ–å¤±è´¥æ—¶è·³è½¬åˆ°å¤±è´¥å¤„ç† */ goto failed; /* åˆå§‹åŒ–shrinklist_lockè‡ªæ—‹é” */ spin_lock_init(&amp;sbinfo-&gt;shrinklist_lock); /* åˆå§‹åŒ–shrinklisté“¾è¡¨å¤´ */ INIT_LIST_HEAD(&amp;sbinfo-&gt;shrinklist); /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿçš„æœ€å¤§æ–‡ä»¶å¤§å° */ sb-&gt;s_maxbytes = MAX_LFS_FILESIZE; /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿçš„å—å¤§å° */ sb-&gt;s_blocksize = PAGE_SIZE; /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿçš„å—å¤§å°ä½æ•° */ sb-&gt;s_blocksize_bits = PAGE_SHIFT; /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿçš„é­”æ•° */ sb-&gt;s_magic = TMPFS_MAGIC; /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿçš„æ“ä½œå‡½æ•°é›† */ sb-&gt;s_op = &amp;shmem_ops; /* è®¾ç½®æ–‡ä»¶ç³»ç»Ÿçš„æ—¶é—´ç²’åº¦ */ sb-&gt;s_time_gran = 1;gran = 1;#ifdef CONFIG_TMPFS_XATTR sb-&gt;s_xattr = shmem_xattr_handlers; // è®¾ç½®super_blockçš„æ‰©å±•å±æ€§å¤„ç†å™¨#endif#ifdef CONFIG_TMPFS_POSIX_ACL sb-&gt;s_flags |= SB_POSIXACL; // å¦‚æœæ”¯æŒPOSIX ACLï¼Œè®¾ç½®super_blockçš„POSIX ACLæ ‡å¿—#endif uuid_gen(&amp;sb-&gt;s_uuid); // ç”Ÿæˆä¸€ä¸ªæ–°çš„UUIDï¼Œå¹¶è®¾ç½®ç»™super_block // ä¸ºæ ¹ç›®å½•åˆ†é…ä¸€ä¸ªinodeï¼Œå¹¶è®¾ç½®å…¶å±æ€§ inode = shmem_get_inode(&amp;nop_mnt_idmap, sb, NULL, S_IFDIR | sbinfo-&gt;mode, 0, VM_NORESERVE); if (!inode) goto failed; // å¦‚æœinodeåˆ†é…å¤±è´¥ï¼Œè·³è½¬åˆ°failedæ ‡ç­¾ inode-&gt;i_uid = sbinfo-&gt;uid; // è®¾ç½®inodeçš„ç”¨æˆ·ID inode-&gt;i_gid = sbinfo-&gt;gid; // è®¾ç½®inodeçš„ç»„ID sb-&gt;s_root = d_make_root(inode); // ä¸ºæ ¹ç›®å½•åˆ†é…ä¸€ä¸ªç›®å½•é¡¹ if (!sb-&gt;s_root) goto failed; // å¦‚æœç›®å½•é¡¹åˆ†é…å¤±è´¥ï¼Œè·³è½¬åˆ°failedæ ‡ç­¾ return 0; // åˆå§‹åŒ–æˆåŠŸï¼Œè¿”å›0failed: // å‘ç”Ÿé”™è¯¯æ—¶ï¼Œæ‰§è¡Œæ¸…ç†æ“ä½œ shmem_put_super(sb); // è°ƒç”¨shmem_put_superè¿›è¡Œæ¸…ç† return -ENOMEM; // è¿”å›-ENOMEMé”™è¯¯ç &#125; shmem_get_inodeå‡½æ•°shmem_get_inode identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static struct inode *shmem_get_inode(struct mnt_idmap *idmap, struct super_block *sb, struct inode *dir, umode_t mode, dev_t dev, unsigned long flags)&#123; struct inode *inode; struct shmem_inode_info *info; struct shmem_sb_info *sbinfo = SHMEM_SB(sb); ino_t ino; // ä¸ºæ–°çš„inodeé¢„ç•™ä¸€ä¸ªç³»ç»Ÿå†…éƒ¨çš„ç¼–å· if (shmem_reserve_inode(sb, &amp;ino)) return NULL; // ä¸ºæ–°çš„inodeåˆ†é…å†…å­˜ inode = new_inode(sb); if (inode) &#123; // è®¾ç½®inodeçš„ç¼–å· inode-&gt;i_ino = ino; // åˆå§‹åŒ–inodeçš„æ‰€æœ‰è€…å’Œæƒé™æ¨¡å¼ inode_init_owner(idmap, inode, dir, mode); // è®¾ç½®inodeçš„ç£ç›˜å—æ•°ä¸º0 inode-&gt;i_blocks = 0; // è®¾ç½®inodeçš„è®¿é—®ã€ä¿®æ”¹å’Œåˆ›å»ºæ—¶é—´ inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode); // è®¾ç½®inodeçš„ç”Ÿæˆç¼–å·ï¼ˆç”¨äºNFSï¼‰ inode-&gt;i_generation = get_random_u32(); // è·å¾—shmem_inode_infoç»“æ„ï¼ˆtmpfsä¸“ç”¨ï¼‰ info = SHMEM_I(inode); // åˆå§‹åŒ–shmem_inode_infoç»“æ„ memset(info, 0, (char *)inode - (char *)info); spin_lock_init(&amp;info-&gt;lock); atomic_set(&amp;info-&gt;stop_eviction, 0); info-&gt;seals = F_SEAL_SEAL; info-&gt;flags = flags &amp; VM_NORESERVE; info-&gt;i_crtime = inode-&gt;i_mtime; info-&gt;fsflags = (dir == NULL) ? 0 : SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED; if (info-&gt;fsflags) shmem_set_inode_flags(inode, info-&gt;fsflags); INIT_LIST_HEAD(&amp;info-&gt;shrinklist); INIT_LIST_HEAD(&amp;info-&gt;swaplist); simple_xattrs_init(&amp;info-&gt;xattrs); cache_no_acl(inode); mapping_set_large_folios(inode-&gt;i_mapping); // æ ¹æ®ä¸åŒçš„æ–‡ä»¶ç±»å‹ï¼Œè®¾ç½®ç›¸åº”çš„æ“ä½œå‡½æ•° switch (mode &amp; S_IFMT) &#123; default: inode-&gt;i_op = &amp;shmem_special_inode_operations; init_special_inode(inode, mode, dev); break; case S_IFREG: inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops; inode-&gt;i_op = &amp;shmem_inode_operations; inode-&gt;i_fop = &amp;shmem_file_operations; mpol_shared_policy_init(&amp;info-&gt;policy, shmem_get_sbmpol(sbinfo)); break; case S_IFDIR: inc_nlink(inode); inode-&gt;i_size = 2 * BOGO_DIRENT_SIZE; inode-&gt;i_op = &amp;shmem_dir_inode_operations; inode-&gt;i_fop = &amp;simple_dir_operations; break; case S_IFLNK: mpol_shared_policy_init(&amp;info-&gt;policy, NULL); break; &#125; // ä¸ºé”ä¾èµ–åˆ†æç³»ç»Ÿè®¾ç½®inodeäº’æ–¥é”çš„æ ‡è®° lockdep_annotate_inode_mutex_key(inode); &#125; else // å¦‚æœinodeåˆ†é…å¤±è´¥ï¼Œåˆ™é‡Šæ”¾é¢„ç•™çš„ç¼–å· shmem_free_inode(sb); return inode;&#125; do_new_mount_fcå‡½æ•°namespace.c - fs&#x2F;namespace.c - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * ä½¿ç”¨è¶…çº§å—é…ç½®åˆ›å»ºä¸€ä¸ªæ–°çš„æŒ‚è½½ï¼Œå¹¶è¯·æ±‚å°†å…¶æ·»åŠ åˆ°å‘½åç©ºé—´æ ‘ã€‚ */static int do_new_mount_fc(struct fs_context *fc, struct path *mountpoint, unsigned int mnt_flags)&#123; struct vfsmount *mnt; struct mountpoint *mp; struct super_block *sb = fc-&gt;root-&gt;d_sb; int error; // å¯¹è¶…çº§å—è¿›è¡Œå®‰å…¨æ£€æŸ¥ error = security_sb_kern_mount(sb); if (!error &amp;&amp; mount_too_revealing(sb, &amp;mnt_flags)) error = -EPERM; // å¦‚æœå‡ºç°é”™è¯¯ï¼Œé‡Šæ”¾fs_contextå¹¶è¿”å›é”™è¯¯ if (unlikely(error)) &#123; fc_drop_locked(fc); return error; &#125; // é‡Šæ”¾è¶…çº§å—çš„umounté” up_write(&amp;sb-&gt;s_umount); // æ ¹æ®fs_contextåˆ›å»ºä¸€ä¸ªæ–°çš„struct mountç»“æ„ï¼Œæ¯ä¸ªæŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿéƒ½å¯¹åº”è¿™æ ·çš„ä¸€ä¸ªç»“æ„ mnt = vfs_create_mount(fc); if (IS_ERR(mnt)) return PTR_ERR(mnt); // å¯¹æŒ‚è½½çš„æ—¶é—´æˆ³è¿‡æœŸå‘å‡ºè­¦å‘Š mnt_warn_timestamp_expiry(mountpoint, mnt); // é”å®šæŒ‚è½½ç‚¹ mp = lock_mount(mountpoint); if (IS_ERR(mp)) &#123; mntput(mnt); return PTR_ERR(mp); &#125; // å°†æ–°æŒ‚è½½æ·»åŠ åˆ°æŒ‚è½½ç‚¹å¹¶åº”ç”¨æŒ‚è½½æ ‡å¿—ï¼Œdo_add_mountå®ŒæˆæŒ‚è½½æ“ä½œ error = do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags); unlock_mount(mp); if (error &lt; 0) mntput(mnt); return error;&#125; do_add_mountå‡½æ•°do_add_mount identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637/* * å°†æŒ‚è½½æ·»åŠ åˆ°å‘½åç©ºé—´çš„æŒ‚è½½æ ‘ä¸­ */static int do_add_mount(struct mount *newmnt, struct mountpoint *mp, const struct path *path, int mnt_flags)&#123; // è·å–å¾…æŒ‚è½½è·¯å¾„çš„çˆ¶æŒ‚è½½å®ä¾‹ struct mount *parent = real_mount(path-&gt;mnt); // æ¸…é™¤å†…éƒ¨æŒ‚è½½æ ‡å¿— mnt_flags &amp;= ~MNT_INTERNAL_FLAGS; // æ£€æŸ¥çˆ¶æŒ‚è½½å®ä¾‹æ˜¯å¦æœ‰æ•ˆ if (unlikely(!check_mnt(parent))) &#123; // è¿™åªå¯¹åœ¨ç§æœ‰å‘½åç©ºé—´ä¸­è¿›è¡Œçš„è‡ªåŠ¨æŒ‚è½½æ˜¯å¯æ¥å—çš„ if (!(mnt_flags &amp; MNT_SHRINKABLE)) return -EINVAL; // å¯¹äºè¿™äº›æƒ…å†µï¼Œæˆ‘ä»¬æœ€å¥½ç¡®ä¿æŒ‚è½½ç‚¹ä»ç„¶æœ‰æ•ˆ if (!parent-&gt;mnt_ns) return -EINVAL; &#125; // æ‹’ç»åœ¨ç›¸åŒæŒ‚è½½ç‚¹ä¸Šä½¿ç”¨ç›¸åŒçš„æ–‡ä»¶ç³»ç»Ÿ if (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp; path-&gt;mnt-&gt;mnt_root == path-&gt;dentry) return -EBUSY; // å¦‚æœæ–°æŒ‚è½½çš„æ ¹ç›®å½•æ˜¯ç¬¦å·é“¾æ¥ï¼Œåˆ™è¿”å›é”™è¯¯ if (d_is_symlink(newmnt-&gt;mnt.mnt_root)) return -EINVAL; // è®¾ç½®æ–°æŒ‚è½½çš„æŒ‚è½½æ ‡å¿— newmnt-&gt;mnt.mnt_flags = mnt_flags; // å°†æ–°æŒ‚è½½æ·»åŠ åˆ°çˆ¶æŒ‚è½½å’ŒæŒ‚è½½ç‚¹ return graft_tree(newmnt, parent, mp);&#125; ç›¸å…³ç»“æ„ä½“struct fs_contextfs_context identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324struct fs_context &#123; const struct fs_context_operations *ops; // æ–‡ä»¶ç³»ç»Ÿæ“ä½œæŒ‡é’ˆï¼Œç”¨äºè®¾ç½®ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„æ“ä½œ struct mutex uapi_mutex; // ç”¨æˆ·ç©ºé—´è®¿é—®äº’æ–¥é”ï¼Œç”¨äºä¿æŠ¤æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„å¹¶å‘è®¿é—® struct file_system_type *fs_type; // æ–‡ä»¶ç³»ç»Ÿç±»å‹ï¼ŒæŒ‡å‘ä¸€ä¸ªæè¿°æ–‡ä»¶ç³»ç»Ÿç‰¹æ€§çš„ç»“æ„ä½“ void *fs_private; // æ–‡ä»¶ç³»ç»Ÿç§æœ‰ä¸Šä¸‹æ–‡ï¼Œç”¨äºå­˜å‚¨ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿå®ç°çš„ç§æœ‰æ•°æ® void *sget_key; // ç”¨äºå”¯ä¸€æ ‡è¯†æ–‡ä»¶ç³»ç»Ÿå®ä¾‹çš„é”®ï¼Œç”¨äºå…±äº«è¶…çº§å—çš„æŸ¥æ‰¾è¿‡ç¨‹ struct dentry *root; // æ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•å…¥å£ï¼ŒæŒ‡å‘ä¸€ä¸ªdentryç»“æ„ä½“ struct user_namespace *user_ns; // ä¸æ­¤æŒ‚è½½å…³è”çš„ç”¨æˆ·å‘½åç©ºé—´ struct net *net_ns; // ä¸æ­¤æŒ‚è½½å…³è”çš„ç½‘ç»œå‘½åç©ºé—´ const struct cred *cred; // æŒ‚è½½è€…çš„å‡­æ®ï¼ŒåŒ…å«ç”¨æˆ·/ç»„IDç­‰æƒé™ä¿¡æ¯ struct p_log log; // æ—¥å¿—ç¼“å†²åŒºï¼Œç”¨äºè®°å½•æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„æ—¥å¿—ä¿¡æ¯ const char *source; // æºåç§°ï¼ˆä¾‹å¦‚è®¾å¤‡è·¯å¾„ï¼‰ï¼Œç”¨äºæ ‡è¯†æŒ‚è½½æ¥æº void *security; // ç”¨äºå­˜å‚¨Linuxå®‰å…¨æ¨¡å—ï¼ˆLSMï¼‰çš„é€‰é¡¹ void *s_fs_info; // æŒ‡å‘å»ºè®®çš„s_fs_infoæ•°æ®ï¼Œä¹‹åä¼šå­˜å‚¨åœ¨è¶…çº§å—çš„s_fs_infoå­—æ®µä¸­ unsigned int sb_flags; // å»ºè®®çš„è¶…çº§å—æ ‡å¿—ï¼ˆSB_*ï¼‰ï¼Œç”¨äºæŒ‚è½½é€‰é¡¹æ§åˆ¶ unsigned int sb_flags_mask; // æ”¹å˜çš„è¶…çº§å—æ ‡å¿—çš„æ©ç  unsigned int s_iflags; // ä¸è¶…çº§å—s_iflagså­—æ®µè¿›è¡ŒæŒ‰ä½æˆ–çš„æ ‡å¿— unsigned int lsm_flags; // ä»æ–‡ä»¶ç³»ç»Ÿåˆ°LSMçš„ä¿¡æ¯æ ‡å¿— enum fs_context_purpose purpose:8; // æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡çš„ç›®çš„ï¼ˆä¾‹å¦‚æŒ‚è½½ã€é‡æ–°æŒ‚è½½ã€ç§»åŠ¨æŒ‚è½½ç‚¹ç­‰ï¼‰ enum fs_context_phase phase:8; // æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡æ‰€å¤„çš„é˜¶æ®µ bool need_free:1; // æ ‡è®°æ˜¯å¦éœ€è¦è°ƒç”¨ops-&gt;free()é‡Šæ”¾æ–‡ä»¶ç³»ç»Ÿä¸Šä¸‹æ–‡ bool global:1; // å…¨å±€æ ‡å¿—ï¼Œè¡¨ç¤ºæ˜¯å¦è¿›å…¥&amp;init_user_nsçš„å…¨å±€å‘½åç©ºé—´ bool oldapi:1; // æ ‡è®°æ˜¯å¦æ¥è‡ªæ—§APIï¼ˆå³mount(2)ç³»ç»Ÿè°ƒç”¨ï¼‰&#125;; è¯¥ç»“æ„ä½“ç”¨äºä¿å­˜è¶…çº§å—çš„ä¿¡æ¯çš„rootï¼Œè€Œè¶…çº§å—æœ¬èº«åŒ…å«äº†è¯¥å®é™…æ–‡ä»¶ç³»ç»Ÿçš„ä¿¡æ¯ï¼Œå› æ­¤é€šè¿‡è¯¥ç»“æ„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿è¯¥æ–‡ä»¶ç³»ç»Ÿå’Œmountç»“æ„ä½“å»ºç«‹è”ç³»ã€‚åœ¨æ—§ç‰ˆçš„Linuxæºç ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨mount_fs()å‡½æ•°å»è·å–å¯¹åº”çš„rootï¼Œè€Œæ–°ç‰ˆåˆ™å¯ä»¥é€šè¿‡fs_contextç›´æ¥è·å–ã€‚ struct vfsmountvfsmount identifier - Linux source code (v6.3.6) - Bootlin 123456struct vfsmount &#123; struct dentry *mnt_root; // æŒ‡å‘å·²æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿæ ‘çš„æ ¹ç›®å½•å…¥å£ï¼ˆdentryç»“æ„ä½“ï¼‰ struct super_block *mnt_sb; // æŒ‡å‘ä¸å·²æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿå…³è”çš„è¶…çº§å—ï¼ˆsuper_blockç»“æ„ä½“ï¼‰ int mnt_flags; // æŒ‚è½½æ ‡å¿—ï¼Œè¡¨ç¤ºæŒ‚è½½æ—¶çš„é€‰é¡¹ï¼Œå¦‚åªè¯»ã€å¼‚æ­¥ç­‰ struct mnt_idmap *mnt_idmap; // æŒ‡å‘ä¸€ä¸ªmnt_idmapç»“æ„ä½“ï¼Œç”¨äºå­˜å‚¨ç”¨æˆ·å’Œç»„IDçš„æ˜ å°„å…³ç³»ï¼ˆä»…åœ¨æŸäº›æ–‡ä»¶ç³»ç»Ÿä¸­ä½¿ç”¨ï¼Œå¦‚NFSï¼‰&#125; __randomize_layout; // ä½¿ç”¨å†…æ ¸çš„åœ°å€ç©ºé—´å¸ƒå±€éšæœºåŒ–ï¼ˆKASLRï¼‰ç‰¹æ€§ï¼Œä»¥å¢åŠ å®‰å…¨æ€§ vfsmountç»“æ„ä½“ä¸­mnt_root æ˜¯å½“å‰æ–‡ä»¶ç³»ç»Ÿæ ¹ç›®å½•çš„ dentryï¼Œmnt_sb æ˜¯æŒ‡å‘è¶…çº§å—çš„æŒ‡é’ˆã€‚è¿™é‡Œä¹‹æ‰€ä»¥ä¼šæœ‰mnt_mountpointå’Œmnt_rootï¼Œæ˜¯å› ä¸ºåœ¨æŒ‚è½½æ—¶è¯¥æ–‡ä»¶ç³»ç»Ÿçš„æ ¹ç›®å½•åŒæ—¶æˆä¸ºäº†å…¶çˆ¶æ–‡ä»¶ç³»ç»Ÿçš„ä¸€ä¸ªå­ç›®å½•ï¼ˆæŒ‚è½½ç‚¹ï¼‰ã€‚ struct mountmount identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; // ç”¨äºæŒ‚è½½ç‚¹å“ˆå¸Œè¡¨çš„é“¾è¡¨èŠ‚ç‚¹ struct mount *mnt_parent; // æŒ‡å‘çˆ¶æŒ‚è½½ç‚¹çš„æŒ‡é’ˆ struct dentry *mnt_mountpoint; // æŒ‡å‘æŒ‚è½½ç‚¹ä½ç½®çš„ç›®å½•å…¥å£ï¼ˆdentryï¼‰ struct vfsmount mnt; // åŒ…å«æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿç›¸å…³ä¿¡æ¯çš„vfsmountç»“æ„ä½“ union &#123; struct rcu_head mnt_rcu; // ç”¨äºRCUï¼ˆRead-Copy-Updateï¼‰åŒæ­¥çš„é“¾è¡¨å¤´ struct llist_node mnt_llist; // ç”¨äºå»¶è¿Ÿåˆ—è¡¨ï¼ˆllistï¼‰çš„é“¾è¡¨èŠ‚ç‚¹ &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp; // æŒ‡å‘æ¯ä¸ªCPUçš„mnt_pcpç»“æ„ä½“çš„æŒ‡é’ˆï¼ˆä»…åœ¨å¤šå¤„ç†å™¨ç³»ç»Ÿä¸­ä½¿ç”¨ï¼‰#else int mnt_count; // æŒ‚è½½ç‚¹çš„å¼•ç”¨è®¡æ•° int mnt_writers; // å†™å…¥æ“ä½œçš„è®¡æ•°å™¨#endif struct list_head mnt_mounts; // å­æŒ‚è½½ç‚¹åˆ—è¡¨çš„é“¾è¡¨å¤´ struct list_head mnt_child; // ä¸mnt_mountsé“¾è¡¨ç›¸è¿çš„é“¾è¡¨èŠ‚ç‚¹ struct list_head mnt_instance; // è¶…çº§å—çš„s_mountsé“¾è¡¨ä¸Šçš„æŒ‚è½½å®ä¾‹åˆ—è¡¨èŠ‚ç‚¹ const char *mnt_devname; // è®¾å¤‡åç§°ï¼Œå¦‚ /dev/dsk/hda1 struct list_head mnt_list; // å…¨å±€æŒ‚è½½ç‚¹åˆ—è¡¨çš„é“¾è¡¨èŠ‚ç‚¹ struct list_head mnt_expire; // ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„è¿‡æœŸåˆ—è¡¨çš„é“¾è¡¨èŠ‚ç‚¹ struct list_head mnt_share; // å…±äº«æŒ‚è½½ç‚¹çš„å¾ªç¯åˆ—è¡¨é“¾è¡¨å¤´ struct list_head mnt_slave_list; // ä»å±æŒ‚è½½ç‚¹çš„é“¾è¡¨å¤´ struct list_head mnt_slave; // ä¸mnt_slave_listé“¾è¡¨ç›¸è¿çš„é“¾è¡¨èŠ‚ç‚¹ struct mount *mnt_master; // æŒ‡å‘ä¸»æŒ‚è½½ç‚¹çš„æŒ‡é’ˆï¼Œä»å±æŒ‚è½½ç‚¹ä½äºmaster-&gt;mnt_slave_list struct mnt_namespace *mnt_ns; // åŒ…å«æ­¤æŒ‚è½½ç‚¹çš„å‘½åç©ºé—´ struct mountpoint *mnt_mp; // æŒ‡å‘æŒ‚è½½ç‚¹ä½ç½®çš„mountpointç»“æ„ä½“ union &#123; struct hlist_node mnt_mp_list; // å…·æœ‰ç›¸åŒæŒ‚è½½ç‚¹çš„æŒ‚è½½åˆ—è¡¨é“¾è¡¨èŠ‚ç‚¹ struct hlist_node mnt_umount; // ç”¨äºå¸è½½æ“ä½œçš„é“¾è¡¨èŠ‚ç‚¹ &#125;; struct list_head mnt_umounting; // ç”¨äºå¸è½½ä¼ æ’­çš„é“¾è¡¨èŠ‚ç‚¹#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; // æŒ‡å‘æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥æ ‡è®°çš„æŒ‡é’ˆ __u32 mnt_fsnotify_mask; // æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥çš„æ©ç #endif int mnt_id; // æŒ‚è½½ç‚¹çš„å”¯ä¸€æ ‡è¯†ç¬¦ int mnt_group_id; // åŒçº§æŒ‚è½½ç»„çš„å”¯ä¸€æ ‡è¯†ç¬¦ int mnt_expiry_mark; // å¦‚æœå·²æ ‡è®°ä¸ºè¿‡æœŸï¼Œåˆ™ä¸ºtrue struct hlist_head mnt_pins; // ç”¨äºè®°å½•æŒ‚è½½ç‚¹å¼•è„šçš„é“¾è¡¨å¤´ struct hlist_head mnt_stuck_children; // è¢«å¡ä½çš„å­æŒ‚è½½ç‚¹åˆ—è¡¨çš„é“¾è¡¨å¤´&#125; __randomize_layout; // ä½¿ç”¨å†…æ ¸çš„åœ°å€ç©ºé—´å¸ƒå±€éšæœºåŒ–ï¼ˆKASLRï¼‰ç‰¹æ€§ï¼Œä»¥å¢åŠ å®‰å…¨æ€§ struct dentrydentry identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* ç›®å½•é¡¹çš„æ ‡å¿—ä½ï¼Œå— d_lock ä¿æŠ¤ */ seqcount_spinlock_t d_seq; /* æ¯ä¸ªç›®å½•é¡¹çš„åºåˆ—é” */ struct hlist_bl_node d_hash; /* ç”¨äºæŸ¥æ‰¾çš„å“ˆå¸Œåˆ—è¡¨ */ struct dentry *d_parent; /* çˆ¶ç›®å½• */ struct qstr d_name; /* ç›®å½•é¡¹çš„åç§° */ struct inode *d_inode; /* ä¸ç›®å½•åå…³è”çš„ inode ç»“æ„æŒ‡é’ˆï¼ŒNULL è¡¨ç¤ºè´Ÿç›®å½•é¡¹ */ unsigned char d_iname[DNAME_INLINE_LEN]; /* çŸ­åç§° */ /* Ref lookup also touches following */ struct lockref d_lockref; /* æ¯ä¸ªç›®å½•é¡¹çš„é”å’Œå¼•ç”¨è®¡æ•° */ const struct dentry_operations *d_op; /* ç›®å½•é¡¹æ“ä½œå‡½æ•°é›† */ struct super_block *d_sb; /* ç›®å½•é¡¹æ ‘çš„æ ¹èŠ‚ç‚¹ */ unsigned long d_time; /* ç”¨äº d_revalidate çš„æ—¶é—´æˆ³ */ void *d_fsdata; /* ç‰¹å®šæ–‡ä»¶ç³»ç»Ÿçš„æ•°æ® */ union &#123; struct list_head d_lru; /* LRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰åˆ—è¡¨ */ wait_queue_head_t *d_wait; /* ä»…ç”¨äºæŸ¥æ‰¾ä¸­çš„ç›®å½•é¡¹ */ &#125;; struct list_head d_child; /* çˆ¶ç›®å½•é¡¹çš„å­é¡¹åˆ—è¡¨ */ struct list_head d_subdirs; /* å­ç›®å½•é¡¹åˆ—è¡¨ */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode åˆ«ååˆ—è¡¨ */ struct hlist_bl_node d_in_lookup_hash; /* ä»…ç”¨äºæŸ¥æ‰¾ä¸­çš„ç›®å½•é¡¹ */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; struct inodeinode identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102struct inode &#123; umode_t i_mode; /* æ–‡ä»¶ç±»å‹å’Œè®¿é—®æƒé™ */ unsigned short i_opflags; /* inode æ“ä½œæ ‡å¿— */ kuid_t i_uid; /* æ–‡ä»¶æ‹¥æœ‰è€…çš„ç”¨æˆ· ID */ kgid_t i_gid; /* æ–‡ä»¶æ‹¥æœ‰è€…çš„ç»„ ID */ unsigned int i_flags; /* æ–‡ä»¶æˆ–ç›®å½•çš„æ ‡å¿— */#ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; /* è®¿é—®æ§åˆ¶åˆ—è¡¨ (ACL) */ struct posix_acl *i_default_acl; /* é»˜è®¤è®¿é—®æ§åˆ¶åˆ—è¡¨ */#endif const struct inode_operations *i_op; /* inode æ“ä½œå‡½æ•°é›† */ struct super_block *i_sb; /* ä¸ inode å…³è”çš„è¶…çº§å— */ struct address_space *i_mapping; /* æ–‡ä»¶å†…å®¹çš„å†…å­˜æ˜ å°„ */#ifdef CONFIG_SECURITY void *i_security; /* å®‰å…¨æ¨¡å—ä½¿ç”¨çš„ inode ä¿¡æ¯ */#endif /* Stat data, not accessed from path walking */ unsigned long i_ino; /* inode ç¼–å· */ union &#123; const unsigned int i_nlink; /* ç¡¬é“¾æ¥è®¡æ•° */ unsigned int __i_nlink; &#125;; dev_t i_rdev; /* ç‰¹æ®Šè®¾å¤‡çš„è®¾å¤‡å· */ loff_t i_size; /* æ–‡ä»¶å¤§å°ï¼ˆå­—èŠ‚ï¼‰ */ struct timespec64 i_atime; /* æœ€åè®¿é—®æ—¶é—´ */ struct timespec64 i_mtime; /* æœ€åä¿®æ”¹æ—¶é—´ */ struct timespec64 i_ctime; /* æœ€åå…ƒæ•°æ®æ›´æ”¹æ—¶é—´ */ spinlock_t i_lock; /* ä¿æŠ¤ i_blocks, i_bytes å’Œå¯èƒ½çš„ i_size çš„é” */ unsigned short i_bytes; /* æ–‡ä»¶æœ«å°¾æœªä½¿ç”¨çš„å­—èŠ‚æ•° */ u8 i_blkbits; /* æ–‡ä»¶ç³»ç»Ÿå—å¤§å°çš„ä»¥ 2 ä¸ºåº•çš„å¯¹æ•° */ u8 i_write_hint; /* å†™æ“ä½œçš„ä¼˜åŒ–æç¤º */ blkcnt_t i_blocks; /* æ–‡ä»¶å ç”¨çš„ç£ç›˜å—æ•°é‡ */#ifdef __NEED_I_SIZE_ORDERED seqcount_t i_size_seqcount; /* æœ‰åº i_size çš„åºåˆ—è®¡æ•°å™¨ */#endif /* Misc */ unsigned long i_state; /* inode çŠ¶æ€æ ‡å¿— */ struct rw_semaphore i_rwsem; /* è¯»å†™ä¿¡å·é‡ï¼Œç”¨äºä¿æŠ¤ inode ç»“æ„ */ unsigned long dirtied_when; /* ç¬¬ä¸€æ¬¡è¢«è„çš„æ—¶é—´ï¼Œä»¥ jiffies è®¡ */ unsigned long dirtied_time_when; /* ä¸Šæ¬¡è¢«è„çš„æ—¶é—´ï¼Œä»¥ jiffies è®¡ */ struct hlist_node i_hash; /* æ•£åˆ—é“¾è¡¨ä¸Šçš„èŠ‚ç‚¹ */ struct list_head i_io_list; /* åå¤‡è®¾å¤‡çš„ I/O åˆ—è¡¨ */#ifdef CONFIG_CGROUP_WRITEBACK struct bdi_writeback *i_wb; /* å…³è”çš„ cgroup å†™å›æ§åˆ¶å™¨ */ int i_wb_frn_winner; /* å¤–éƒ¨ inode æ£€æµ‹çš„èµ¢å®¶ */ u16 i_wb_frn_avg_time; /* å¤–éƒ¨ inode çš„å¹³å‡æ—¶é—´ */ u16 i_wb_frn_history; /* å¤–éƒ¨ inode çš„å†å²è®°å½• */#endif struct list_head i_lru; /* inode LRU åˆ—è¡¨ */ struct list_head i_sb_list; /* è¶…çº§å—åˆ—è¡¨ */ struct list_head i_wb_list; /* åå¤‡è®¾å¤‡å†™å›åˆ—è¡¨ */ union &#123; struct hlist_head i_dentry; /* ç›®å½•é¡¹åˆ—è¡¨ */ struct rcu_head i_rcu; &#125;; atomic64_t i_version; /* inode ç‰ˆæœ¬ */ atomic64_t i_sequence; /* ç”¨äº futex çš„åºåˆ—å€¼ */ atomic_t i_count; /* inode å¼•ç”¨è®¡æ•° */ atomic_t i_dio_count; /* ç›´æ¥ I/O è®¡æ•° */ atomic_t i_writecount; /* å†™è®¡æ•° */#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING) atomic_t i_readcount; /* åªè¯»æ‰“å¼€çš„æ–‡ä»¶è®¡æ•° */#endif union &#123; const struct file_operations *i_fop; /* ä»¥å‰çš„ -&gt;i_op-&gt;default_file_ops */ void (*free_inode)(struct inode *); &#125;; struct file_lock_context *i_flctx; /* æ–‡ä»¶é”ä¸Šä¸‹æ–‡ */ struct address_space i_data; /* inode çš„æ•°æ®ç¼“å†²åŒº */ struct list_head i_devices; /* è®¾å¤‡åˆ—è¡¨ */ union &#123; struct pipe_inode_info *i_pipe; /* ç®¡é“ inode ä¿¡æ¯ */ struct cdev *i_cdev; /* å­—ç¬¦è®¾å¤‡ */ char *i_link; /* ç¬¦å·é“¾æ¥çš„ç›®æ ‡è·¯å¾„ */ unsigned i_dir_seq; /* ç›®å½•åºåˆ—è®¡æ•°å™¨ */ &#125;; __u32 i_generation; /* inode ç”Ÿæˆè®¡æ•°å™¨ */#ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* inode å…³å¿ƒçš„æ‰€æœ‰äº‹ä»¶ */ struct fsnotify_mark_connector __rcu *i_fsnotify_marks; /* æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥æ ‡è®°è¿æ¥å™¨ */#endif#ifdef CONFIG_FS_ENCRYPTION struct fscrypt_info *i_crypt_info; /* æ–‡ä»¶ç³»ç»ŸåŠ å¯†ä¿¡æ¯ */#endif#ifdef CONFIG_FS_VERITY struct fsverity_info *i_verity_info; /* æ–‡ä»¶ç³»ç»Ÿå®Œæ•´æ€§ä¿¡æ¯ */#endif void *i_private; /* æ–‡ä»¶ç³»ç»Ÿæˆ–è®¾å¤‡çš„ç§æœ‰æŒ‡é’ˆ */&#125; __randomize_layout; æ‰“å¼€æˆ–è€…åˆ›å»ºæ–°æ–‡ä»¶openç³»ç»Ÿè°ƒç”¨sys_openat identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122// å®šä¹‰ä¸€ä¸ªåä¸º open çš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¯¥è°ƒç”¨æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šfilenameï¼ˆæ–‡ä»¶åï¼‰ï¼Œflagsï¼ˆæ ‡å¿—ï¼‰å’Œ modeï¼ˆæ¨¡å¼ï¼‰SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)&#123; // å¦‚æœéœ€è¦å¤„ç†å¤§æ–‡ä»¶ï¼Œå°† O_LARGEFILE æ ‡å¿—æ·»åŠ åˆ° flags ä¸­ if (force_o_largefile()) flags |= O_LARGEFILE; // è°ƒç”¨ do_sys_open å‡½æ•°ï¼Œä¼ å…¥å½“å‰å·¥ä½œç›®å½•çš„æ–‡ä»¶æè¿°ç¬¦ AT_FDCWDã€filenameã€flags å’Œ mode å‚æ•° return do_sys_open(AT_FDCWD, filename, flags, mode);&#125;// å®šä¹‰ä¸€ä¸ªåä¸º openat çš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¯¥è°ƒç”¨æ¥å—å››ä¸ªå‚æ•°ï¼šdfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ï¼Œfilenameï¼ˆæ–‡ä»¶åï¼‰ï¼Œflagsï¼ˆæ ‡å¿—ï¼‰å’Œ modeï¼ˆæ¨¡å¼ï¼‰SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)&#123; // å¦‚æœéœ€è¦å¤„ç†å¤§æ–‡ä»¶ï¼Œå°† O_LARGEFILE æ ‡å¿—æ·»åŠ åˆ° flags ä¸­ if (force_o_largefile()) flags |= O_LARGEFILE; // è°ƒç”¨ do_sys_open å‡½æ•°ï¼Œä¼ å…¥ dfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ã€filenameã€flags å’Œ mode å‚æ•° return do_sys_open(dfd, filename, flags, mode);&#125; open - è¿™æ˜¯ä¸€ä¸ªè¾ƒæ—©ç‰ˆæœ¬çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒæ¥å—ä¸‰ä¸ªå‚æ•°ï¼šfilenameï¼Œflags å’Œ modeã€‚filename å‚æ•°æ˜¯è¦æ‰“å¼€æˆ–åˆ›å»ºçš„æ–‡ä»¶åï¼›flags å‚æ•°ç”¨äºæŒ‡å®šæ–‡ä»¶çš„æ‰“å¼€æ–¹å¼ï¼Œä¾‹å¦‚åªè¯»ã€åªå†™æˆ–è¯»å†™ï¼Œä»¥åŠå…¶ä»–ä¸€äº›é€‰é¡¹ï¼Œå¦‚åˆ›å»ºæ–°æ–‡ä»¶æˆ–æˆªæ–­æ–‡ä»¶ï¼›mode å‚æ•°ç”¨äºæŒ‡å®šæ–°åˆ›å»ºæ–‡ä»¶çš„æƒé™ã€‚åœ¨å¤„ç†å¤§æ–‡ä»¶æ—¶ï¼Œå¦‚æœè®¾ç½®äº† O_LARGEFILE æ ‡å¿—ï¼Œopen ä¼šè‡ªåŠ¨å¤„ç†å¤§æ–‡ä»¶ã€‚ openat - ä¸ open ç±»ä¼¼ï¼Œä½†å¤šäº†ä¸€ä¸ªå‚æ•° dfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ã€‚è¿™ä¸ªç³»ç»Ÿè°ƒç”¨æ”¯æŒä»ä¸€ä¸ªç‰¹å®šçš„ç›®å½•å¼€å§‹è§£æç›¸å¯¹è·¯å¾„ã€‚å¦‚æœ dfd æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼Œé‚£ä¹ˆ filename å‚æ•°å°†è¢«è§£æä¸ºè¯¥ç›®å½•ä¸‹çš„ç›¸å¯¹è·¯å¾„ã€‚å¦‚æœ dfd æ˜¯ AT_FDCWDï¼Œåˆ™ filename ä¼šè¢«è§†ä¸ºå½“å‰å·¥ä½œç›®å½•ä¸‹çš„ç›¸å¯¹è·¯å¾„ã€‚è¿™ä¸ªç³»ç»Ÿè°ƒç”¨åœ¨å¤„ç†å¤šçº¿ç¨‹ç¨‹åºå’Œæ–‡ä»¶ç³»ç»Ÿå‘½åç©ºé—´æ—¶éå¸¸æœ‰ç”¨ã€‚ do_sys_openå‡½æ•°do_sys_open identifier - Linux source code (v6.3.7) - Bootlin 123456789// å®šä¹‰ä¸€ä¸ªåä¸º do_sys_open çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—å››ä¸ªå‚æ•°ï¼šdfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ï¼Œfilenameï¼ˆæ–‡ä»¶åï¼‰ï¼Œflagsï¼ˆæ ‡å¿—ï¼‰å’Œ modeï¼ˆæ¨¡å¼ï¼‰long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)&#123; // ä½¿ç”¨ build_open_how å‡½æ•°æ ¹æ® flags å’Œ mode å‚æ•°æ„é€ ä¸€ä¸ª open_how ç»“æ„ä½“ struct open_how how = build_open_how(flags, mode); // è°ƒç”¨ do_sys_openat2 å‡½æ•°ï¼Œä¼ å…¥ dfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ã€filename å’Œ how ç»“æ„ä½“çš„æŒ‡é’ˆ return do_sys_openat2(dfd, filename, &amp;how);&#125; do_sys_openat2å‡½æ•°do_sys_openat2 identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142// å®šä¹‰ä¸€ä¸ªåä¸º do_sys_openat2 çš„é™æ€å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šdfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ï¼Œfilenameï¼ˆæ–‡ä»¶åï¼‰å’Œ howï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“æŒ‡é’ˆï¼‰static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how)&#123; struct open_flags op; // ä½¿ç”¨ build_open_flags å‡½æ•°æ ¹æ® how ç»“æ„ä½“æ„é€ ä¸€ä¸ª open_flags ç»“æ„ä½“ï¼Œå°†ç»“æœå­˜å‚¨åœ¨ op å˜é‡ä¸­ int fd = build_open_flags(how, &amp;op); struct filename *tmp; // å¦‚æœ fd ä¸ä¸º 0ï¼ˆè¡¨ç¤ºå‡ºé”™ï¼‰ï¼Œåˆ™è¿”å› fd if (fd) return fd; // ä½¿ç”¨ getname å‡½æ•°è·å– filename å‚æ•°çš„å†…æ ¸ç©ºé—´å‰¯æœ¬ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ tmp å˜é‡ä¸­ tmp = getname(filename); // å¦‚æœè·å–æ–‡ä»¶åå‡ºé”™ï¼Œè¿”å›é”™è¯¯ç  if (IS_ERR(tmp)) return PTR_ERR(tmp); // æ ¹æ® how-&gt;flags è·å–æœªä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ fd å˜é‡ä¸­ fd = get_unused_fd_flags(how-&gt;flags); // å¦‚æœ fd å¤§äºç­‰äº 0ï¼ˆè¡¨ç¤ºæœªä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦å¯ç”¨ï¼‰ if (fd &gt;= 0) &#123; // ä½¿ç”¨ do_filp_open å‡½æ•°æ‰“å¼€æ–‡ä»¶ï¼Œä¼ å…¥ dfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ã€tmpï¼ˆæ–‡ä»¶åï¼‰å’Œ opï¼ˆæ‰“å¼€æ–¹å¼ï¼‰å‚æ•° struct file *f = do_filp_open(dfd, tmp, &amp;op); // å¦‚æœæ‰“å¼€æ–‡ä»¶å‡ºé”™ï¼Œé‡Šæ”¾æœªä½¿ç”¨çš„æ–‡ä»¶æè¿°ç¬¦å¹¶è¿”å›é”™è¯¯ç  if (IS_ERR(f)) &#123; put_unused_fd(fd); fd = PTR_ERR(f); &#125; else &#123; // å¦‚æœæ‰“å¼€æ–‡ä»¶æˆåŠŸï¼Œè°ƒç”¨ fsnotify_open å‡½æ•°é€šçŸ¥ç›¸å…³å­ç³»ç»Ÿ fsnotify_open(f); // è°ƒç”¨ fd_install å‡½æ•°å°†æ–‡ä»¶æè¿°ç¬¦ fd ä¸æ‰“å¼€çš„æ–‡ä»¶ç»“æ„ä½“ f å…³è”èµ·æ¥ fd_install(fd, f); &#125; &#125; // é‡Šæ”¾ tmp å˜é‡ï¼ˆå³ filename çš„å†…æ ¸ç©ºé—´å‰¯æœ¬ï¼‰ putname(tmp); // è¿”å›æ–‡ä»¶æè¿°ç¬¦ fd return fd;&#125; do_filp_openå‡½æ•°do_filp_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324// å®šä¹‰ä¸€ä¸ªåä¸º do_filp_open çš„å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šdfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ï¼Œpathnameï¼ˆæ–‡ä»¶åç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“æŒ‡é’ˆï¼‰struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // ä» op ç»“æ„ä½“ä¸­è·å–æŸ¥æ‰¾æ ‡å¿— int flags = op-&gt;lookup_flags; struct file *filp; // ä½¿ç”¨ set_nameidata å‡½æ•°åˆå§‹åŒ– nd ç»“æ„ä½“ï¼Œä¼ å…¥ dfdï¼ˆç›®å½•æ–‡ä»¶æè¿°ç¬¦ï¼‰ã€pathnameï¼ˆæ–‡ä»¶åç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ NULLï¼ˆç”¨äºåˆå§‹åŒ– nd-&gt;intentï¼‰ set_nameidata(&amp;nd, dfd, pathname, NULL); // ä½¿ç”¨ path_openat å‡½æ•°å°è¯•æ‰“å¼€æ–‡ä»¶ï¼Œä¼ å…¥ ndï¼ˆåå­—æ•°æ®ç»“æ„ä½“ï¼‰ã€opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“ï¼‰å’Œ flagsï¼ˆæŸ¥æ‰¾æ ‡å¿—ï¼‰ï¼›ä½¿ç”¨ LOOKUP_RCU æ ‡å¿—è¿›è¡Œ RCU ä¼˜åŒ– filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // å¦‚æœæ–‡ä»¶æ‰“å¼€å¤±è´¥å¹¶è¿”å› -ECHILD é”™è¯¯ç ï¼Œè¡¨æ˜ RCU ä¼˜åŒ–å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨é RCU ä¼˜åŒ–æ–¹å¼æ‰“å¼€æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // å¦‚æœæ–‡ä»¶æ‰“å¼€å¤±è´¥å¹¶è¿”å› -ESTALE é”™è¯¯ç ï¼Œè¡¨æ˜æ–‡ä»¶ç³»ç»ŸçŠ¶æ€é™ˆæ—§ï¼Œå°è¯•ä½¿ç”¨ LOOKUP_REVAL æ ‡å¿—é‡æ–°è¯„ä¼°æ–‡ä»¶ç³»ç»ŸçŠ¶æ€å¹¶æ‰“å¼€æ–‡ä»¶ if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // é€šè¿‡è°ƒç”¨ restore_nameidata å‡½æ•°æ¢å¤åå­—æ•°æ®ç»“æ„ä½“ï¼ˆndï¼‰çš„çŠ¶æ€ restore_nameidata(); // è¿”å›æ–‡ä»¶ç»“æ„ä½“æŒ‡é’ˆ filp return filp;&#125; 12345678910static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name, const struct path *root)&#123; __set_nameidata(p, dfd, name); p-&gt;state = 0; if (unlikely(root)) &#123; p-&gt;state = ND_ROOT_PRESET; p-&gt;root = *root; &#125;&#125; 12345678910111213static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)&#123; struct nameidata *old = current-&gt;nameidata; p-&gt;stack = p-&gt;internal; p-&gt;depth = 0; p-&gt;dfd = dfd; p-&gt;name = name; p-&gt;path.mnt = NULL; p-&gt;path.dentry = NULL; p-&gt;total_link_count = old ? old-&gt;total_link_count : 0; p-&gt;saved = old; current-&gt;nameidata = p;&#125; path_openatå‡½æ•°path_openat identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// å®šä¹‰ä¸€ä¸ªåä¸º path_openat çš„é™æ€å‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸‰ä¸ªå‚æ•°ï¼šndï¼ˆåå­—æ•°æ®ç»“æ„ä½“æŒ‡é’ˆï¼‰ã€opï¼ˆæ‰“å¼€æ–¹å¼ç»“æ„ä½“æŒ‡é’ˆï¼‰å’Œ flagsï¼ˆæ‰“å¼€æ ‡å¿—ï¼‰static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; struct file *file; int error; // ä½¿ç”¨ alloc_empty_file å‡½æ•°åˆ†é…ä¸€ä¸ªç©ºçš„æ–‡ä»¶ç»“æ„ä½“ï¼Œä¼ å…¥æ‰“å¼€æ ‡å¿—å’Œå½“å‰è¿›ç¨‹çš„è®¤è¯ä¿¡æ¯ file = alloc_empty_file(op-&gt;open_flag, current_cred()); // å¦‚æœåˆ†é…æ–‡ä»¶ç»“æ„ä½“å¤±è´¥ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ if (IS_ERR(file)) return file; // å¦‚æœæ–‡ä»¶æ‰“å¼€æ ‡å¿—åŒ…å« __O_TMPFILEï¼Œè°ƒç”¨ do_tmpfile å‡½æ•°å¤„ç†ä¸´æ—¶æ–‡ä»¶çš„æ‰“å¼€æ“ä½œ if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123; error = do_tmpfile(nd, flags, op, file); // å¦‚æœæ–‡ä»¶æ‰“å¼€æ ‡å¿—åŒ…å« O_PATHï¼Œè°ƒç”¨ do_o_path å‡½æ•°å¤„ç† O_PATH æ ‡å¿—çš„æ‰“å¼€æ“ä½œ &#125; else if (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123; error = do_o_path(nd, flags, file); // å¦åˆ™ï¼Œæ­£å¸¸å¤„ç†æ–‡ä»¶æ‰“å¼€æ“ä½œ &#125; else &#123; // ä½¿ç”¨ path_init å‡½æ•°åˆå§‹åŒ– nd ç»“æ„ä½“ï¼Œå¹¶è¿”å›è·¯å¾„åå­—ç¬¦ä¸² s const char *s = path_init(nd, flags); // å¾ªç¯è°ƒç”¨ link_path_walk å’Œ open_last_lookups å‡½æ•°ï¼Œç›´åˆ°è·¯å¾„åè§£æå®Œæˆ while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ; // è·¯å¾„åè§£æå®Œæˆåï¼Œè°ƒç”¨ do_open å‡½æ•°å¤„ç†æ–‡ä»¶æ‰“å¼€æ“ä½œ if (!error) error = do_open(nd, file, op); // è°ƒç”¨ terminate_walk å‡½æ•°ç»ˆæ­¢è·¯å¾„åè§£ææ“ä½œ terminate_walk(nd); &#125; // å¦‚æœæ²¡æœ‰é”™è¯¯å‘ç”Ÿï¼Œè¿”å›æ–‡ä»¶ç»“æ„ä½“æŒ‡é’ˆ if (likely(!error)) &#123; if (likely(file-&gt;f_mode &amp; FMODE_OPENED)) return file; WARN_ON(1); error = -EINVAL; &#125; // å¦‚æœæœ‰é”™è¯¯å‘ç”Ÿï¼Œé‡Šæ”¾æ–‡ä»¶ç»“æ„ä½“å¹¶è¿”å›é”™è¯¯æŒ‡é’ˆ fput(file); // å¦‚æœé”™è¯¯ç ä¸º -EOPENSTALEï¼Œæ ¹æ® flags å‚æ•°è®¾ç½®é”™è¯¯ç ä¸º -ECHILD æˆ– -ESTALE if (error == -EOPENSTALE) &#123; if (flags &amp; LOOKUP_RCU) error = -ECHILD; else error = -ESTALE; &#125; return ERR_PTR(error);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* å¿…é¡»å’Œ terminate_walk() é…å¯¹ä½¿ç”¨ */static const char *path_init(struct nameidata *nd, unsigned flags)&#123; int error; const char *s = nd-&gt;name-&gt;name; /* LOOKUP_CACHED éœ€è¦ RCUï¼Œè¦æ±‚è°ƒç”¨è€…é‡è¯• */ if ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED) return ERR_PTR(-EAGAIN); if (!*s) flags &amp;= ~LOOKUP_RCU; if (flags &amp; LOOKUP_RCU) rcu_read_lock(); // å¦‚æœä½¿ç”¨ RCUï¼Œåˆ™åŠ é” else nd-&gt;seq = nd-&gt;next_seq = 0; // å¦åˆ™ï¼Œå°†åºåˆ—å·è®¾ç½®ä¸º 0 nd-&gt;flags = flags; // è®¾ç½® nameidata ç»“æ„ä½“çš„ flags nd-&gt;state |= ND_JUMPED; // è®¾ç½® nameidata ç»“æ„ä½“çš„çŠ¶æ€ // è¯»å– mount_lock å’Œ rename_lock çš„åºåˆ—å· nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount); nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount); smp_rmb(); // æ£€æŸ¥æ˜¯å¦é¢„å…ˆè®¾ç½®äº†æ ¹è·¯å¾„ if (nd-&gt;state &amp; ND_ROOT_PRESET) &#123; struct dentry *root = nd-&gt;root.dentry; struct inode *inode = root-&gt;d_inode; if (*s &amp;&amp; unlikely(!d_can_lookup(root))) return ERR_PTR(-ENOTDIR); nd-&gt;path = nd-&gt;root; // å°†é¢„è®¾çš„æ ¹è·¯å¾„è®¾ç½®ä¸ºå½“å‰è·¯å¾„ nd-&gt;inode = inode; // è®¾ç½®è·¯å¾„çš„ inode if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;path); &#125; return s; &#125; nd-&gt;root.mnt = NULL; // ç»å¯¹è·¯å¾„ - è·å–æ ¹è·¯å¾„ï¼ˆLOOKUP_IN_ROOT ä½¿ç”¨ nd-&gt;dfdï¼‰ if (*s == &#x27;/&#x27; &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123; error = nd_jump_root(nd); // ä»æ ¹è·¯å¾„å¼€å§‹æŸ¥æ‰¾ if (unlikely(error)) return ERR_PTR(error); return s; &#125; // ç›¸å¯¹è·¯å¾„ - è·å–ç›¸å¯¹è·¯å¾„çš„èµ·å§‹ç‚¹ if (nd-&gt;dfd == AT_FDCWD) &#123; if (flags &amp; LOOKUP_RCU) &#123; struct fs_struct *fs = current-&gt;fs; unsigned seq; // æ ¹æ® fs_struct è·å– pwdï¼ˆå½“å‰å·¥ä½œç›®å½•ï¼‰ do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); nd-&gt;path = fs-&gt;pwd; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); &#125; else &#123; get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); // è·å–å½“å‰è¿›ç¨‹çš„å·¥ä½œç›®å½• nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; &#125; else &#123; // è°ƒç”¨è€…å¿…é¡»æ£€æŸ¥èµ·å§‹è·¯å¾„ç»„ä»¶çš„æ‰§è¡Œæƒé™ struct fd f = fdget_raw(nd-&gt;dfd); // æ ¹æ®æ–‡ä»¶æè¿°ç¬¦è·å– fd ç»“æ„ struct dentry *dentry; if (!f.file) return ERR_PTR(-EBADF); dentry = f.file-&gt;f_path.dentry; if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123; fdput(f); return ERR_PTR(-ENOTDIR); &#125; nd-&gt;path = f.file-&gt;f_path; // è®¾ç½®å½“å‰è·¯å¾„ if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; else &#123; path_get(&amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; fdput(f); // é‡Šæ”¾æ–‡ä»¶æè¿°ç¬¦ &#125; // å¯¹äºå—é™åˆ¶çš„æŸ¥æ‰¾ï¼Œæˆ‘ä»¬éœ€è¦å°† dirfd ä¹Ÿè®¾ç½®ä¸ºæ ¹è·¯å¾„ if (flags &amp; LOOKUP_IS_SCOPED) &#123; nd-&gt;root = nd-&gt;path; if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;root); nd-&gt;state |= ND_ROOT_GRABBED; &#125; &#125; return s;&#125; link_path_walkå‡½æ•°link_path_walk identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static int link_path_walk(const char *name, struct nameidata *nd)&#123; int depth = 0; // åˆå§‹åŒ–æ·±åº¦ä¸º 0ï¼Œç”¨äºè®°å½•ç¬¦å·é“¾æ¥çš„åµŒå¥—å±‚æ•° int err; // åˆå§‹åŒ– nd-&gt;last_type å’Œ nd-&gt;flags nd-&gt;last_type = LAST_ROOT; // è®¾ç½® nd-&gt;last_type ä¸º LAST_ROOT nd-&gt;flags |= LOOKUP_PARENT; // æ›´æ–° nd-&gt;flagsï¼Œæ·»åŠ  LOOKUP_PARENT æ ‡å¿— // å¦‚æœè·¯å¾„åæ˜¯é”™è¯¯çš„ï¼Œè¿”å›é”™è¯¯å€¼ if (IS_ERR(name)) // æ£€æŸ¥è·¯å¾„åæ˜¯å¦æœ‰æ•ˆï¼ˆä¸æ˜¯é”™è¯¯æŒ‡é’ˆï¼‰ return PTR_ERR(name); // å¦‚æœæ— æ•ˆï¼Œè¿”å›é”™è¯¯å€¼ // è·³è¿‡è·¯å¾„åå¼€å¤´çš„ &#x27;/&#x27; while (*name == &#x27;/&#x27;) // å½“è·¯å¾„åä»¥ &#x27;/&#x27; å¼€å¤´æ—¶ï¼Œè¿›å…¥å¾ªç¯ name++; // å°† name æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½ï¼Œè·³è¿‡ &#x27;/&#x27; // å¦‚æœè·¯å¾„åä¸ºç©ºï¼Œè¿”å› 0 if (!*name) &#123; // æ£€æŸ¥è·¯å¾„åæ˜¯å¦ä¸ºç©ºï¼ˆåœ¨è·³è¿‡å¼€å¤´çš„ &#x27;/&#x27; ä¹‹åï¼‰ nd-&gt;dir_mode = 0; // å°† nd-&gt;dir_mode è®¾ç½®ä¸º 0 return 0; // è¿”å› 0ï¼Œè¡¨ç¤ºè·¯å¾„æŸ¥æ‰¾ç»“æŸ &#125; // å¼€å§‹å¾ªç¯å¤„ç†è·¯å¾„åçš„æ¯ä¸ªç»„ä»¶ for (;;) &#123; // æ— é™å¾ªç¯ï¼Œç›´åˆ°è·¯å¾„åçš„æ‰€æœ‰ç»„ä»¶éƒ½è¢«å¤„ç† struct mnt_idmap *idmap; const char *link; u64 hash_len; int type; // è·å–æ–‡ä»¶ç³»ç»Ÿ ID æ˜ å°„,æ–‡ä»¶ç³»ç»Ÿ ID æ˜ å°„ç”¨äºå°† VFS ä¸­çš„ç”¨æˆ·å’Œç»„ ID è½¬æ¢ä¸ºåº•å±‚æ–‡ä»¶ç³»ç»Ÿä¸­çš„ç”¨æˆ·å’Œç»„ IDã€‚ idmap = mnt_idmap(nd-&gt;path.mnt); // è·å– nd-&gt;path.mnt å¯¹åº”çš„æ–‡ä»¶ç³»ç»Ÿ ID æ˜ å°„ // æ£€æŸ¥æ˜¯å¦æœ‰æƒé™æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œ err = may_lookup(idmap, nd); // æ£€æŸ¥å½“å‰ç”¨æˆ·æ˜¯å¦æœ‰æƒé™æŸ¥æ‰¾ if (err) // å¦‚æœæ²¡æœ‰æƒé™ return err; // è¿”å›é”™è¯¯å€¼ // è®¡ç®—å½“å‰è·¯å¾„ç»„ä»¶çš„å“ˆå¸Œå€¼å’Œé•¿åº¦,è¿™äº›å€¼å°†ç”¨äºåœ¨æ•£åˆ—æŸ¥æ‰¾ä¸­å¿«é€Ÿæ¯”è¾ƒè·¯å¾„åç»„ä»¶ã€‚ hash_len = hash_name(nd-&gt;path.dentry, name); // è®¡ç®—å“ˆå¸Œå€¼å’Œé•¿åº¦ // åˆ¤æ–­å½“å‰è·¯å¾„ç»„ä»¶çš„ç±»å‹ï¼ˆ&#x27;.&#x27;ã€&#x27;..&#x27; æˆ–æ™®é€šç»„ä»¶ï¼‰ type = LAST_NORM; // é»˜è®¤ä¸ºæ™®é€šç»„ä»¶ if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; // å¦‚æœç»„ä»¶ä»¥ &#x27;.&#x27; å¼€å¤´ï¼Œæ£€æŸ¥é•¿åº¦ case 2: if (name[1] == &#x27;.&#x27;) &#123; // å¦‚æœç»„ä»¶ä¸º &quot;..&quot; type = LAST_DOTDOT; // è®¾ç½®ç±»å‹ä¸º LAST_DOTDOT nd-&gt;state |= ND_JUMPED; // æ›´æ–° nd-&gt;stateï¼Œæ·»ã€‚è¿™ä¸ªæ ‡å¿—è¡¨ç¤ºæˆ‘ä»¬æ­£è·³è½¬åˆ°çˆ¶ç›®å½•ã€‚ &#125; break; case 1: type = LAST_DOT; // å¦‚æœç»„ä»¶ä¸º &quot;.&quot;ï¼Œè®¾ç½®ç±»å‹ä¸º LAST_DOT &#125; if (likely(type == LAST_NORM)) &#123; // å¦‚æœç»„ä»¶ç±»å‹ä¸ºæ™®é€šç»„ä»¶ struct dentry *parent = nd-&gt;path.dentry; // è·å–å½“å‰ç»„ä»¶çš„çˆ¶ç›®å½• nd-&gt;state &amp;= ~ND_JUMPED; // æ¸…é™¤ nd-&gt;state çš„ ND_JUMPED æ ‡å¿— // å¦‚æœéœ€è¦ï¼Œæ‰§è¡Œè‡ªå®šä¹‰å“ˆå¸Œæ“ä½œã€‚æŸäº›æ–‡ä»¶ç³»ç»Ÿå¯èƒ½éœ€è¦è‡ªå®šä¹‰å“ˆå¸Œæ“ä½œä»¥é€‚åº”å…¶ç‰¹å®šçš„æŸ¥æ‰¾æœºåˆ¶ã€‚ if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; // æ£€æŸ¥çˆ¶ç›®å½•æ˜¯å¦éœ€è¦è‡ªå®šä¹‰å“ˆå¸Œæ“ä½œ struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; // åˆå§‹åŒ– qstr ç»“æ„ä½“ err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); // æ‰§è¡Œè‡ªå®šä¹‰å“ˆå¸Œæ“ä½œ if (err &lt; 0) // å¦‚æœæ“ä½œå¤±è´¥ return err; // è¿”å›é”™è¯¯å€¼ hash_len = this.hash_len; // æ›´æ–°å“ˆå¸Œå€¼å’Œé•¿åº¦ name = this.name; // æ›´æ–° name æŒ‡é’ˆ &#125; &#125; //--------------------------------------------------------------------- // æ›´æ–° nd çš„ last å’Œ last_type æˆå‘˜ nd-&gt;last.hash_len = hash_len; // è®¾ç½® nd-&gt;last çš„å“ˆå¸Œå€¼å’Œé•¿åº¦ nd-&gt;last.name = name; // è®¾ç½® nd-&gt;last çš„åç§° nd-&gt;last_type = type; // è®¾ç½® nd-&gt;last_type ä¸ºå½“å‰ç»„ä»¶çš„ç±»å‹ // å°† name æŒ‡é’ˆå‘åç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªè·¯å¾„ç»„ä»¶ name += hashlen_len(hash_len); // å°† name æŒ‡é’ˆå‘åç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªè·¯å¾„ç»„ä»¶çš„èµ·å§‹ä½ç½® // å¦‚æœåˆ°è¾¾è·¯å¾„åçš„ç»“å°¾ï¼Œå¤„ç†ç»“æŸ if (!*name) // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾è·¯å¾„åçš„ç»“å°¾ goto OK; // è·³è½¬åˆ° OK æ ‡ç­¾ // è·³è¿‡è¿ç»­çš„ &#x27;/&#x27; do &#123; name++; // å°† name æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½ &#125; while (unlikely(*name == &#x27;/&#x27;)); // å½“é‡åˆ° &#x27;/&#x27; æ—¶ï¼Œç»§ç»­å¾ªç¯ // å¦‚æœåˆ°è¾¾è·¯å¾„åçš„ç»“å°¾ï¼Œå¤„ç†ç»“æŸ if (unlikely(!*name)) &#123; // å†æ¬¡æ£€æŸ¥æ˜¯å¦åˆ°è¾¾è·¯å¾„åçš„ç»“å°¾OK: // pathname or trailing symlink, done if (!depth) &#123; // å¦‚æœå½“å‰å¤„ç†çš„è·¯å¾„ç»„ä»¶ä¸æ˜¯ç¬¦å·é“¾æ¥çš„ä¸€éƒ¨åˆ† nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); // è®¾ç½® nd-&gt;dir_vfsuid nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; // è®¾ç½® nd-&gt;dir_mode nd-&gt;flags &amp;= ~LOOKUP_PARENT; // æ¸…é™¤ nd-&gt;flags çš„ LOOKUP_PARENT æ ‡å¿— return 0; // è¿”å› 0ï¼Œè¡¨ç¤ºè·¯å¾„æŸ¥æ‰¾ç»“æŸ &#125; // last component of nested symlink name = nd-&gt;stack[--depth].name; // è·å–ç¬¦å·é“¾æ¥æ ˆä¸­ä¸‹ä¸€ä¸ªç»„ä»¶çš„åç§° link = walk_component(nd, 0); // å¤„ç†å½“å‰ç»„ä»¶ &#125; else &#123; // not the last component link = walk_component(nd, WALK_MORE); // å¤„ç†å½“å‰ç»„ä»¶ï¼Œä¼ é€’ WALK_MORE æ ‡å¿— &#125; // å¦‚æœ link ä¸ä¸ºç©ºï¼Œè¡¨ç¤ºéœ€è¦å¤„ç†ç¬¦å·é“¾æ¥ if (unlikely(link)) &#123; // æ£€æŸ¥ link æ˜¯å¦ä¸ºç©º if (IS_ERR(link)) // å¦‚æœ link æ˜¯é”™è¯¯æŒ‡é’ˆ return PTR_ERR(link); // è¿”å›é”™è¯¯å€¼ // a symlink to follow nd-&gt;stack[depth++].name = name; // å°†å½“å‰ç»„ä»¶çš„åç§°å‹å…¥ç¬¦å·é“¾æ¥æ ˆ name = link; // å°† name æŒ‡é’ˆè®¾ç½®ä¸ºç¬¦å·é“¾æ¥çš„ç›®æ ‡è·¯å¾„ continue; // ç»§ç»­å¾ªç¯å¤„ç†ç¬¦å·é“¾æ¥çš„ç›®æ ‡è·¯å¾„ &#125; // æ£€æŸ¥ dentry æ˜¯å¦å¯ä»¥æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œ if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; // å¦‚æœä¸èƒ½æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœ nd-&gt;flags ä¸­åŒ…å« LOOKUP_RCU æ ‡å¿— if (!try_to_unlazy(nd)) // å°è¯•å–æ¶ˆå¯¹ nd çš„æ‡’åŠ è½½ return -ECHILD; // å¦‚æœå–æ¶ˆå¤±è´¥ï¼Œè¿”å› -ECHILD é”™è¯¯å€¼ &#125; return -ENOTDIR; // è¿”å› -ENOTDIR é”™è¯¯å€¼ï¼Œè¡¨ç¤ºä¸æ˜¯ç›®å½• &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/* * è®¡ç®—è·¯å¾„ç»„ä»¶çš„é•¿åº¦å’Œå“ˆå¸Œå€¼ï¼Œ * å¹¶å°† &quot;hash_len&quot; ä½œä¸ºç»“æœè¿”å›ã€‚ */static inline u64 hash_name(const void *salt, const char *name)&#123; unsigned long a = 0, b, x = 0, y = (unsigned long)salt; unsigned long adata, bdata, mask, len; const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS; // åˆå§‹åŒ–é•¿åº¦ä¸º 0 len = 0; goto inside; do &#123; // å¯¹ a, x, y è¿›è¡Œå“ˆå¸Œæ··åˆ HASH_MIX(x, y, a); // æ›´æ–°åç§°é•¿åº¦ len += sizeof(unsigned long);inside: // åœ¨ç»™å®šåç§»é‡çš„åç§°å­—ç¬¦ä¸²ä¸­åŠ è½½ä¸€ä¸ªæœªå¯¹é½çš„å€¼ a = load_unaligned_zeropad(name+len); // é€šè¿‡ XOR æ“ä½œæ‰¾åˆ°ä¸æ–œçº¿å­—ç¬¦ä¸åŒçš„éƒ¨åˆ†,å¾ªç¯æ‰¾åˆ° b = a ^ REPEAT_BYTE(&#x27;/&#x27;); // æ£€æŸ¥ a å’Œ b ä¸­æ˜¯å¦æœ‰é›¶å­—èŠ‚ &#125; while (!(has_zero(a, &amp;adata, &amp;constants) | has_zero(b, &amp;bdata, &amp;constants))); // ä¸º a å’Œ b å‡†å¤‡é›¶æ©ç  adata = prep_zero_mask(a, adata, &amp;constants); bdata = prep_zero_mask(b, bdata, &amp;constants); // é€šè¿‡ç»„åˆ a å’Œ b çš„é›¶æ©ç åˆ›å»ºæœ€ç»ˆçš„é›¶æ©ç  mask = create_zero_mask(adata | bdata); // å°† a çš„é›¶æ©ç åº”ç”¨äº x x ^= a &amp; zero_bytemask(mask); // æ ¹æ® x, y å’Œé›¶æ©ç åˆ›å»ºæœ€ç»ˆçš„å“ˆå¸Œé•¿åº¦å€¼ return hashlen_create(fold_hash(x, y), len + find_zero(mask));&#125; walk_componentå‡½æ•°walk_component identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536// å®šä¹‰ä¸€ä¸ªåä¸º walk_component çš„å‡½æ•°ï¼Œå‚æ•°åŒ…æ‹¬ä¸€ä¸ªæŒ‡å‘ nameidata ç»“æ„ä½“çš„æŒ‡é’ˆå’Œä¸€ä¸ªæ•´æ•° flagsstatic const char *walk_component(struct nameidata *nd, int flags)&#123; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘ dentry ç»“æ„ä½“çš„æŒ‡é’ˆ struct dentry *dentry; /* * &quot;.&quot; å’Œ &quot;..&quot; æ˜¯ç‰¹æ®Šçš„ - å°¤å…¶æ˜¯ &quot;..&quot;ï¼Œå› ä¸ºå®ƒå¿…é¡»çŸ¥é“å½“å‰æ ¹ç›®å½•å’Œ * çˆ¶ç›®å½•ä¹‹é—´çš„å…³ç³»ã€‚ */ // å¦‚æœ nd-&gt;last_type ä¸æ˜¯ LAST_NORMï¼Œåˆ™æ‰§è¡Œä»¥ä¸‹ä»£ç  if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // å¦‚æœ flags æ²¡æœ‰è®¾ç½® WALK_MORE ä¸” nd-&gt;depth ä¸ä¸º 0ï¼Œåˆ™è°ƒç”¨ put_link å‡½æ•° if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // è°ƒç”¨ handle_dots å‡½æ•°å¤„ç† &quot;.&quot; å’Œ &quot;..&quot; return handle_dots(nd, nd-&gt;last_type); &#125; // è°ƒç”¨ lookup_fast å‡½æ•°è¿›è¡Œå¿«é€ŸæŸ¥æ‰¾ dentry = lookup_fast(nd); // å¦‚æœ dentry æ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ if (IS_ERR(dentry)) return ERR_CAST(dentry); // å¦‚æœ dentry ä¸º NULLï¼Œåˆ™æ‰§è¡Œä»¥ä¸‹ä»£ç  if (unlikely(!dentry)) &#123; // è°ƒç”¨ lookup_slow å‡½æ•°è¿›è¡Œæ…¢é€ŸæŸ¥æ‰¾ dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // å¦‚æœ dentry æ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œåˆ™è¿”å›é”™è¯¯æŒ‡é’ˆ if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; // å¦‚æœ flags æ²¡æœ‰è®¾ç½® WALK_MORE ä¸” nd-&gt;depth ä¸ä¸º 0ï¼Œåˆ™è°ƒç”¨ put_link å‡½æ•° if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // è°ƒç”¨ step_into å‡½æ•°è¿›å…¥ä¸‹ä¸€ä¸ªç»„ä»¶ï¼ˆç›®å½•æˆ–æ–‡ä»¶ï¼‰ return step_into(nd, flags, dentry);&#125; 1234567static inline void put_link(struct nameidata *nd)&#123; struct saved *last = nd-&gt;stack + --nd-&gt;depth; do_delayed_call(&amp;last-&gt;done); if (!(nd-&gt;flags &amp; LOOKUP_RCU)) path_put(&amp;last-&gt;link);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// å®šä¹‰ä¸€ä¸ªå‡½æ•°handle_dotsï¼Œç”¨äºå¤„ç†è·¯å¾„åä¸­çš„ç‚¹ï¼ˆ.ï¼‰å’Œç‚¹ç‚¹ï¼ˆ..ï¼‰static const char *handle_dots(struct nameidata *nd, int type) &#123; // å¦‚æœå½“å‰è·¯å¾„ç»„ä»¶æ˜¯ä¸¤ä¸ªç‚¹ï¼ˆ..ï¼‰ if (type == LAST_DOTDOT) &#123; // å®šä¹‰é”™è¯¯æŒ‡é’ˆå¹¶åˆå§‹åŒ–ä¸ºNULL const char *error = NULL; // å®šä¹‰ä¸€ä¸ªdentryç»“æ„çš„çˆ¶ç›®å½•æŒ‡é’ˆ struct dentry *parent; // å¦‚æœndï¼ˆnameidataç»“æ„ï¼‰çš„rootæˆå‘˜ä¸ºç©º if (!nd-&gt;root.mnt) &#123; // è°ƒç”¨set_rootå‡½æ•°è®¾ç½®ndçš„æ ¹ç›®å½•ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦å‡ºç°é”™è¯¯ error = ERR_PTR(set_root(nd)); if (error) return error; &#125; // å¦‚æœndçš„flagsä¸­åŒ…å«LOOKUP_RCUæ ‡å¿— if (nd-&gt;flags &amp; LOOKUP_RCU) // è°ƒç”¨follow_dotdot_rcuå‡½æ•°ï¼Œä»¥RCUæ–¹å¼å¤„ç†ä¸¤ä¸ªç‚¹ï¼ˆ..ï¼‰ parent = follow_dotdot_rcu(nd); else // å¦åˆ™ï¼Œè°ƒç”¨follow_dotdotå‡½æ•°å¤„ç†ä¸¤ä¸ªç‚¹ï¼ˆ..ï¼‰ parent = follow_dotdot(nd); // å¦‚æœparentæ˜¯ä¸€ä¸ªé”™è¯¯æŒ‡é’ˆï¼Œè¿”å›é”™è¯¯ if (IS_ERR(parent)) return ERR_CAST(parent); // è°ƒç”¨step_intoå‡½æ•°è¿›å…¥parentç›®å½•ï¼Œä¸è·Ÿéšç¬¦å·é“¾æ¥ error = step_into(nd, WALK_NOFOLLOW, parent); // å¦‚æœå‡ºç°é”™è¯¯ï¼Œè¿”å›é”™è¯¯ if (unlikely(error)) return error; // å¦‚æœndçš„flagsä¸­åŒ…å«LOOKUP_IS_SCOPEDæ ‡å¿— if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123; /* * å¦‚æœæˆ‘ä»¬çš„è·¯å¾„åœ¨è¿›è¡Œé‡å‘½åæˆ–æŒ‚è½½æ“ä½œæœŸé—´å‘ç”Ÿç«äº‰ï¼Œ * é‚£ä¹ˆæˆ‘ä»¬æ— æ³•ç¡®å®š&quot;..&quot;æ˜¯å¦è·³è¿‡äº†nd-&gt;rootï¼ˆå› æ­¤ç”¨æˆ·ç©ºé—´åº”è¯¥é‡è¯•æˆ–ä½¿ç”¨ä¸€äº›å›é€€æ–¹æ³•ï¼‰ã€‚ */ // è¯»å–å†…å­˜å±éšœï¼Œç¡®ä¿æ­£ç¡®çš„å†…å­˜é¡ºåº smp_rmb(); // å¦‚æœmount_lockçš„åºåˆ—è®¡æ•°å™¨å‘ç”Ÿå˜åŒ–ï¼Œè¿”å›é”™è¯¯EAGAIN if (__read_seqcount_retry(&amp;mount_lock.seqcount, nd-&gt;m_seq)) return ERR_PTR(-EAGAIN); // å¦‚æœrename_lockçš„åºåˆ—è®¡æ•°å™¨å‘ç”Ÿå˜åŒ–ï¼Œè¿”å›é”™è¯¯EAGAIN if (__read_seqcount_retry(&amp;rename_lock.seqcount, nd-&gt;r_seq)) return ERR_PTR(-EAGAIN); &#125; &#125; // å¦‚æœä¸æ˜¯ä¸¤ä¸ªç‚¹ï¼ˆ..ï¼‰ï¼Œè¿”å›NULL return NULL;&#125; lookup_fastå‡½æ•°lookup_fast identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct dentry *lookup_fast(struct nameidata *nd)&#123; struct dentry *dentry, *parent = nd-&gt;path.dentry; // å®šä¹‰dentryæŒ‡é’ˆï¼Œå°†ndä¸­çš„pathçš„dentryèµ‹å€¼ç»™parent int status = 1; /* * Rename seqlock is not required here because in the off chance * of a false negative due to a concurrent rename, the caller is * going to fall back to non-racy lookup. */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // å¦‚æœä½¿ç”¨RCUï¼ˆè¯»-æ‹·è´-æ›´æ–°ï¼‰æŸ¥æ‰¾ dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); // ç”¨RCUæ–¹å¼æŸ¥æ‰¾ç›®å½•é¡¹ if (unlikely(!dentry)) &#123; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°dentry if (!try_to_unlazy(nd)) // å°è¯•å°†rcué”å‡çº§ä¸ºércué” return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯ return NULL; // è¿”å›ç©ºæŒ‡é’ˆ &#125; /* * This sequence count validates that the parent had no * changes while we did the lookup of the dentry above. */ if (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) // éªŒè¯åœ¨æŸ¥æ‰¾dentryè¿‡ç¨‹ä¸­parentæ²¡æœ‰å‘ç”Ÿå˜åŒ– return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯ status = d_revalidate(dentry, nd-&gt;flags); // éªŒè¯dentryçš„æœ‰æ•ˆæ€§ if (likely(status &gt; 0)) // å¦‚æœéªŒè¯æˆåŠŸ return dentry; // è¿”å›dentry if (!try_to_unlazy_next(nd, dentry)) // å°è¯•å°†rcué”å‡çº§ä¸ºércué” return ERR_PTR(-ECHILD); // è¿”å›é”™è¯¯ if (status == -ECHILD) /* we&#x27;d been told to redo it in non-rcu mode */ status = d_revalidate(dentry, nd-&gt;flags); // åœ¨éRCUæ¨¡å¼ä¸‹é‡æ–°éªŒè¯dentryçš„æœ‰æ•ˆæ€§ &#125; else &#123; // å¦‚æœä½¿ç”¨éRCUæŸ¥æ‰¾ dentry = __d_lookup(parent, &amp;nd-&gt;last); // æŸ¥æ‰¾ç›®å½•é¡¹ if (unlikely(!dentry)) // å¦‚æœæ²¡æœ‰æ‰¾åˆ°dentry return NULL; // è¿”å›ç©ºæŒ‡é’ˆ status = d_revalidate(dentry, nd-&gt;flags); // éªŒè¯dentryçš„æœ‰æ•ˆæ€§ &#125; if (unlikely(status &lt;= 0)) &#123; // å¦‚æœéªŒè¯å¤±è´¥ if (!status) // å¦‚æœstatusä¸º0 d_invalidate(dentry); // ä½¿dentryæ— æ•ˆ dput(dentry); // é‡Šæ”¾dentryå¼•ç”¨ return ERR_PTR(status); // è¿”å›é”™è¯¯ &#125; return dentry; // è¿”å›dentry&#125; Linux ä¸ºäº†æé«˜ç›®å½•é¡¹å¯¹è±¡çš„å¤„ç†æ•ˆç‡ï¼Œè®¾è®¡ä¸å®ç°äº†ç›®å½•é¡¹é«˜é€Ÿç¼“å­˜ dentry cacheï¼Œç®€ç§° dcacheï¼Œåœ¨ä¸ŠèŠ‚ä¸­å·²æœ‰è¯¦ç»†æè¿°ã€‚lookup_fast()ä¼šåœ¨dcacheä¸­å»è¯•å›¾æ‰¾åˆ°è¯¥å¯¹åº”çš„dentryï¼Œå®é™…æœ€ç»ˆä¼šè°ƒç”¨https://code.woboq.org/linux/linux/include/linux/rculist_bl.h.html#123è½®è¯¢åˆ—è¡¨è¿›è¡ŒæŸ¥æ‰¾ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * __d_lookup - æœç´¢ä¸€ä¸ª dentry (å®¹æ˜“å‡ºç°ç«äº‰) * @parent: çˆ¶ dentry * @name: æˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°çš„åå­—çš„ qstr * è¿”å›: dentryï¼Œæˆ–è€… NULL * * __d_lookup ç±»ä¼¼äº d_lookupï¼Œä½†æ˜¯ç”±äºä¸é‡å‘½åæ— å…³çš„æ´»åŠ¨ï¼Œå®ƒå¯èƒ½ï¼ˆå¾ˆå°‘ï¼‰è¿”å› * ä¸€ä¸ªé”™è¯¯çš„è´Ÿé¢ç»“æœã€‚ * * __d_lookup é€šè¿‡é¿å…è¯»å– rename_lock seqlockï¼Œé€Ÿåº¦ç¨å¿«ï¼Œ * ä½†å¿…é¡»è°¨æ…ä½¿ç”¨ï¼Œä¾‹å¦‚åœ¨å¤±è´¥æ—¶ä½¿ç”¨åç»­çš„ d_lookupã€‚ * * __d_lookup è°ƒç”¨è€…å¿…é¡»åŠ æ³¨é‡Šã€‚ */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; // è®¡ç®— name çš„å“ˆå¸Œå€¼ struct hlist_bl_head *b = d_hash(hash); // è·å–å“ˆå¸Œå€¼å¯¹åº”çš„å“ˆå¸Œè¡¨å¤´ struct hlist_bl_node *node; // ç”¨äºéå†å“ˆå¸Œé“¾è¡¨çš„èŠ‚ç‚¹ struct dentry *found = NULL; // ç”¨äºå­˜å‚¨æ‰¾åˆ°çš„ dentry struct dentry *dentry; // ç”¨äºéå†å“ˆå¸Œé“¾è¡¨çš„ä¸´æ—¶ dentry /* * æ³¨æ„ï¼šè¿™é‡Œä¸ __d_lookup_rcu æœ‰å¾ˆå¤§çš„é‡å¤éƒ¨åˆ†ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢å•çº¿ç¨‹æ€§èƒ½ * å›å½’ï¼Œç‰¹åˆ«æ˜¯åœ¨ smp_rmbï¼ˆåœ¨ seqcounts ä¸­ï¼‰ä»£ä»·é«˜æ˜‚çš„æ¶æ„ä¸Šã€‚ * ä¿æŒè¿™ä¸¤ä¸ªå‡½æ•°åŒæ­¥æ›´æ–°ã€‚ */ /* * å“ˆå¸Œåˆ—è¡¨ä½¿ç”¨ RCU ä¿æŠ¤ã€‚ * * åœ¨æ¯”è¾ƒå€™é€‰ dentry æ—¶ï¼Œè·å– d_lock ä»¥é¿å…ä¸ d_move() çš„ç«äº‰ã€‚ * * æœ‰å¯èƒ½å¹¶å‘çš„é‡å‘½åæ“ä½œä¼šç ´åæˆ‘ä»¬è¿™é‡Œçš„åˆ—è¡¨éå†ï¼Œå¯¼è‡´æˆ‘ä»¬é”™è¿‡ dentryï¼Œ * ä»è€Œäº§ç”Ÿé”™è¯¯çš„è´Ÿé¢ç»“æœã€‚d_lookup() ä½¿ç”¨ rename_lock seqlock æ¥ä¿æŠ¤ * å¹¶å‘é‡å‘½åã€‚ * * æ›´å¤šç»†èŠ‚è¯·å‚é˜… Documentation/filesystems/path-lookup.txtã€‚ */ rcu_read_lock(); // è·å– RCU è¯»é” // éå†å“ˆå¸Œé“¾è¡¨ hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) // å“ˆå¸Œå€¼ä¸åŒ¹é…ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª continue; spin_lock(&amp;dentry-&gt;d_lock); // è·å– dentry çš„è‡ªæ—‹é” if (dentry-&gt;d_parent != parent) // çˆ¶ dentry ä¸åŒ¹é…ï¼Œè·³åˆ°ä¸‹ä¸€ä¸ª goto next; if (d_unhashed(dentry)) // æ£€æŸ¥ dentry æ˜¯å¦å·²ä»å“ˆå¸Œè¡¨ä¸­ç§»é™¤ï¼Œå¦‚æœæ˜¯åˆ™è·³åˆ°ä¸‹ä¸€ä¸ª goto next; if (!d_same_name(dentry, parent, name)) // åå­—ä¸åŒ¹é…ï¼Œè·³åˆ°ä¸‹ä¸€ä¸ª goto next; dentry-&gt;d_lockref.count++; // å¢åŠ  dentry çš„å¼•ç”¨è®¡æ•° found = dentry; // æ‰¾åˆ°åŒ¹é…çš„ dentryï¼Œèµ‹å€¼ç»™ found spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾ dentry çš„è‡ªæ—‹é” break; // ç»“æŸå¾ªç¯ next: spin_unlock(&amp;dentry-&gt;d_lock); // é‡Šæ”¾ dentry çš„è‡ªæ—‹é” &#125; rcu_read_unlock(); // é‡Šæ”¾ RCU è¯»é” return found; // è¿”å›æ‰¾åˆ°çš„ dentryï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°è¿”å› NULL&#125; __d_lookup_rcuå‡½æ•°__d_lookup_rcu identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct dentry *__d_lookup_rcu(const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // è®¡ç®—åç§°çš„å“ˆå¸Œé•¿åº¦ const unsigned char *str = name-&gt;name; // è·å–åç§°å­—ç¬¦ä¸² struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // è®¡ç®—å“ˆå¸Œå€¼å¹¶è·å–æ•£åˆ—è¡¨å¤´ struct hlist_bl_node *node; // å®šä¹‰å“ˆå¸Œè¡¨èŠ‚ç‚¹æŒ‡é’ˆ struct dentry *dentry; // å®šä¹‰ç›®å½•é¡¹æŒ‡é’ˆ /* * Note: There is significant duplication with __d_lookup_rcu which is * required to prevent single threaded performance regressions * especially on architectures where smp_rmb (in seqcounts) are costly. * Keep the two functions in sync. */ // æ£€æŸ¥çˆ¶ç›®å½•é¡¹æ˜¯å¦åŒ…å«è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œå¦‚æœæœ‰åˆ™è°ƒç”¨ç‰¹å®šçš„æŸ¥æ‰¾å‡½æ•° if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE)) return __d_lookup_rcu_op_compare(parent, name, seqp); /* * The hash list is protected using RCU. * * Carefully use d_seq when comparing a candidate dentry, to avoid * races with d_move(). * * It is possible that concurrent renames can mess up our list * walk here and result in missing our dentry, resulting in the * false-negative result. d_lookup() protects against concurrent * renames using rename_lock seqlock. * * See Documentation/filesystems/path-lookup.txt for more details. */ // ä½¿ç”¨ RCU ä¿æŠ¤çš„å“ˆå¸Œåˆ—è¡¨æ¥éå†ç›®å½•é¡¹ hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; unsigned seq; /* * The dentry sequence count protects us from concurrent * renames, and thus protects parent and name fields. * * The caller must perform a seqcount check in order * to do anything useful with the returned dentry. * * NOTE! We do a &quot;raw&quot; seqcount_begin here. That means that * we don&#x27;t wait for the sequence count to stabilize if it * is in the middle of a sequence change. If we do the slow * dentry compare, we will do seqretries until it is stable, * and if we end up with a successful lookup, we actually * want to exit RCU lookup anyway. * * Note that raw_seqcount_begin still *does* smp_rmb(), so * we are still guaranteed NUL-termination of -&gt;d_name.name. */ seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // è·å– dentry çš„åºåˆ—è®¡æ•° if (dentry-&gt;d_parent != parent) // æ£€æŸ¥ dentry çš„çˆ¶ç›®å½•é¡¹æ˜¯å¦ä¸ç»™å®šçš„çˆ¶ç›®å½•é¡¹ç›¸åŒ continue; if (d_unhashed(dentry)) // æ£€æŸ¥ dentry æ˜¯å¦å·²ä»æ•£åˆ—è¡¨ä¸­åˆ é™¤ continue; if (dentry-&gt;d_name.hash_len != hashlen) // æ£€æŸ¥ dentry çš„åç§°å“ˆå¸Œé•¿åº¦æ˜¯å¦ä¸ç»™å®šåç§°ç›¸åŒ continue; if (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0) // æ¯”è¾ƒ dentry çš„åç§°ä¸ç»™å®šåç§°æ˜¯å¦ç›¸åŒ continue; *seqp = seq; // å°†åºåˆ—è®¡æ•°èµ‹å€¼ç»™ seqp return dentry; // è¿”å›æ‰¾åˆ°çš„ dentry &#125; return NULL; // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ dentryï¼Œåˆ™è¿”å›ç©ºæŒ‡é’ˆ&#125; __d_lookup_rcu å‡½æ•°åœ¨ç»™å®šçš„çˆ¶ç›®å½•é¡¹ä¸‹æŸ¥æ‰¾å…·æœ‰ç»™å®šåç§°çš„ç›®å½•é¡¹ï¼ˆdentryï¼‰ã€‚å®ƒä½¿ç”¨ RCUï¼ˆè¯»-æ‹·è´-æ›´æ–°ï¼‰æœºåˆ¶éå†æ•£åˆ—è¡¨ï¼Œä»¥ä¾¿åœ¨éå†è¿‡ç¨‹ä¸­ä¿æŠ¤æ•°æ®ç»“æ„ã€‚å¦‚æœæ‰¾åˆ°åŒ¹é…çš„ç›®å½•é¡¹ï¼Œå®ƒå°†è¿”å›æŒ‡å‘è¯¥ç›®å½•é¡¹çš„æŒ‡é’ˆï¼Œå¦åˆ™è¿”å› NULLã€‚ hlist_bl_for_each_entry_rcu1234567891011121314151617/** * hlist_bl_for_each_entry_rcu - iterate over rcu list of given type * @tpos: the type * to use as a loop cursor. * @pos: the &amp;struct hlist_bl_node to use as a loop cursor. * @head: the head for your list. * @member: the name of the hlist_bl_node within the struct. * */#define hlist_bl_for_each_entry_rcu(tpos, pos, head, member) \\ // åˆå§‹åŒ– pos ä¸ºåˆ—è¡¨å¤´çš„ç¬¬ä¸€ä¸ªå…ƒç´  for (pos = hlist_bl_first_rcu(head); \\ // å½“ pos ä¸ä¸º NULL æ—¶æ‰§è¡Œå¾ªç¯ä½“å†…çš„ä»£ç  pos &amp;&amp; \\ // ä½¿ç”¨å® hlist_bl_entry è·å–å½“å‰ pos å¯¹åº”çš„ç»“æ„ä½“ç±»å‹çš„æŒ‡é’ˆï¼Œå¹¶èµ‹å€¼ç»™ tpos (&#123; tpos = hlist_bl_entry(pos, typeof(*tpos), member); 1; &#125;); \\ // æ›´æ–° pos ä¸ºä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œä½¿ç”¨ rcu_dereference_raw è¿›è¡Œ RCU è§£å¼•ç”¨ pos = rcu_dereference_raw(pos-&gt;next)) è¿™ä¸ªå®å®šä¹‰äº†ä¸€ä¸ª for å¾ªç¯ï¼Œç”¨äºéå†é“¾è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚åœ¨å¾ªç¯ä½“å†…ï¼Œå®ƒä½¿ç”¨ hlist_bl_entry å®è·å–å½“å‰ pos å¯¹åº”çš„ç»“æ„ä½“ç±»å‹çš„æŒ‡é’ˆï¼Œå¹¶å°†å…¶èµ‹å€¼ç»™ tposã€‚å¾ªç¯å°†æŒç»­è¿›è¡Œï¼Œç›´åˆ°éå†å®Œé“¾è¡¨ã€‚åœ¨æ¯æ¬¡è¿­ä»£æ—¶ï¼Œå®ƒéƒ½ä¼šä½¿ç”¨ rcu_dereference_raw å‡½æ•°å¯¹ pos-&gt;next è¿›è¡Œ RCU è§£å¼•ç”¨ä»¥è·å–ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚ lookup_slowlookup_slow identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819static struct dentry *lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct inode *inode = dir-&gt;d_inode; // è·å–ç»™å®šç›®å½•é¡¹ï¼ˆdirï¼‰å¯¹åº”çš„ inode struct dentry *res; // å®šä¹‰ä¸€ä¸ªç›®å½•é¡¹æŒ‡é’ˆï¼Œç”¨äºå­˜å‚¨æŸ¥æ‰¾ç»“æœ // å¯¹ inode ä¸Šçš„å…±äº«é”è¿›è¡ŒåŠ é”ï¼Œä»¥ä¿æŠ¤æŸ¥æ‰¾è¿‡ç¨‹ä¸­çš„æ•°æ®ç»“æ„ inode_lock_shared(inode); // è°ƒç”¨ __lookup_slow å‡½æ•°åœ¨ç»™å®šç›®å½•é¡¹ï¼ˆdirï¼‰ä¸‹æŸ¥æ‰¾ä¸ç»™å®šåç§°ï¼ˆnameï¼‰åŒ¹é…çš„ç›®å½•é¡¹ res = __lookup_slow(name, dir, flags); // å¯¹ inode ä¸Šçš„å…±äº«é”è¿›è¡Œè§£é” inode_unlock_shared(inode); // è¿”å›æŸ¥æ‰¾åˆ°çš„ç›®å½•é¡¹ï¼ˆdentryï¼‰ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„é¡¹ï¼Œè¿”å› NULL return res;&#125; __lookup_slowå‡½æ•°__lookup_slow identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Fast lookup failed, do it the slow way */static struct dentry *__lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct dentry *dentry, *old; struct inode *inode = dir-&gt;d_inode; // è·å–ç»™å®šç›®å½•é¡¹ï¼ˆdirï¼‰å¯¹åº”çš„ inode DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // å®šä¹‰ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—å¤´å˜é‡ // å¦‚æœ inode å·²ç»æ˜¯æ­»äº¡çŠ¶æ€ï¼Œç›´æ¥è¿”å›é”™è¯¯ if (unlikely(IS_DEADDIR(inode))) return ERR_PTR(-ENOENT);again: // åˆ†é…ä¸€ä¸ªæ–°çš„ dentryï¼Œå¦‚æœéœ€è¦ç­‰å¾…ï¼Œåˆ™ä½¿ç”¨ wq ç­‰å¾… dentry = d_alloc_parallel(dir, name, &amp;wq); if (IS_ERR(dentry)) return dentry; // å¦‚æœ dentry ä¸å¤„äºæŸ¥æ‰¾çŠ¶æ€ if (unlikely(!d_in_lookup(dentry))) &#123; // é‡æ–°éªŒè¯ dentry int error = d_revalidate(dentry, flags); if (unlikely(error &lt;= 0)) &#123; // å¦‚æœéªŒè¯å¤±è´¥ï¼Œä½¿ dentry æ— æ•ˆï¼Œé‡Šæ”¾ dentryï¼Œå¹¶é‡æ–°å°è¯• if (!error) &#123; d_invalidate(dentry); dput(dentry); goto again; &#125; // é‡Šæ”¾ dentryï¼Œå¹¶è¿”å›é”™è¯¯ dput(dentry); dentry = ERR_PTR(error); &#125; &#125; else &#123; // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„ lookup å‡½æ•°æŸ¥æ‰¾ dentry old = inode-&gt;i_op-&gt;lookup(inode, dentry, flags); d_lookup_done(dentry); // å®ŒæˆæŸ¥æ‰¾æ“ä½œ if (unlikely(old)) &#123; // å¦‚æœæ‰¾åˆ°æ—§çš„ dentryï¼Œé‡Šæ”¾æ–°åˆ†é…çš„ dentryï¼Œå¹¶ä½¿ç”¨æ—§çš„ dentry dput(dentry); dentry = old; &#125; &#125; // è¿”å›æŸ¥æ‰¾åˆ°çš„ dentry æˆ–æ–°åˆ›å»ºçš„ dentry return dentry;&#125; __lookup_slow å‡½æ•°åœ¨ç»™å®šçš„ç›®å½•é¡¹ï¼ˆdirï¼‰ä¸‹æŸ¥æ‰¾å…·æœ‰ç»™å®šåç§°ï¼ˆnameï¼‰çš„ç›®å½•é¡¹ï¼ˆdentryï¼‰ã€‚æ­¤å‡½æ•°åœ¨å¿«é€ŸæŸ¥æ‰¾å¤±è´¥çš„æƒ…å†µä¸‹ä½¿ç”¨æ…¢é€ŸæŸ¥æ‰¾æ–¹æ³•ã€‚é¦–å…ˆï¼Œå®ƒè·å–ç»™å®šç›®å½•é¡¹ï¼ˆdirï¼‰å¯¹åº”çš„ inodeï¼Œç„¶ååˆ†é…ä¸€ä¸ªæ–°çš„ dentryã€‚æ¥ç€æ£€æŸ¥ dentry æ˜¯å¦å¤„äºæŸ¥æ‰¾çŠ¶æ€ï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™é‡æ–°éªŒè¯ dentryã€‚å¦‚æœéªŒè¯å¤±è´¥ï¼Œåˆ™ä½¿ dentry æ— æ•ˆå¹¶é‡Šæ”¾å®ƒï¼Œç„¶åé‡æ–°å°è¯•ã€‚å¦‚æœ dentry å¤„äºæŸ¥æ‰¾çŠ¶æ€ï¼Œåˆ™è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿç‰¹å®šçš„ lookup å‡½æ•°æŸ¥æ‰¾ dentryã€‚å®ŒæˆæŸ¥æ‰¾åï¼Œå¦‚æœæ‰¾åˆ°æ—§çš„ dentryï¼Œåˆ™é‡Šæ”¾æ–°åˆ†é…çš„ dentry å¹¶ä½¿ç”¨æ—§çš„ dentryã€‚æœ€åï¼Œè¿”å›æ‰¾åˆ°çš„æˆ–æ–°åˆ›å»ºçš„ dentryã€‚ å½“æŸ¥æ‰¾æˆåŠŸæ—¶ï¼Œ__lookup_slow å‡½æ•°è¿”å›æ‰¾åˆ°çš„ dentryã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ç›®å½•é¡¹ï¼Œinode-&gt;i_op-&gt;lookup å‡½æ•°å°†åˆ›å»ºä¸€ä¸ªæ–°çš„ç›®å½•é¡¹å¹¶è¿”å›å®ƒã€‚åˆ›å»ºæ–°ç›®å½•é¡¹çš„è¿‡ç¨‹ä¾èµ–äºå…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ï¼Œé€šå¸¸æ¶‰åŠåˆ†é…ä¸€ä¸ªæ–°çš„ dentry ç»“æ„ï¼Œå¹¶å°†å…¶ä¸ç»™å®šçš„ name å’Œçˆ¶ç›®å½•é¡¹å…³è”èµ·æ¥ã€‚ inode-&gt;i_op-&gt;lookupå‡½æ•°æŒ‡å‘ simple_lookup() å‡½æ•°é¦–å…ˆæˆ‘ä»¬å‚è€ƒä¸Šæ–‡ä¸­çš„get_treeå‡½æ•°æ˜¯å¦‚ä½•è¢«è®¾ç½®ä¸ºshmem_initå‡½æ•° å¯ä»¥äº†è§£åˆ°å†…æ ¸åœ¨å¯åŠ¨æ—¶ä¼šåˆå§‹åŒ–tmpfsæ–‡ä»¶ç³»ç»Ÿ æˆ‘ä»¬æ ¹æ®è°ƒç”¨é“¾shmem_get_tree - shmem_fill_super - shmem_get_inodeï¼Œç„¶åæŸ¥çœ‹shmem_get_inodeå‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static struct inode *shmem_get_inode(struct mnt_idmap *idmap, struct super_block *sb, struct inode *dir, umode_t mode, dev_t dev, unsigned long flags)&#123; struct inode *inode; struct shmem_inode_info *info; struct shmem_sb_info *sbinfo = SHMEM_SB(sb); ino_t ino; // ä¸ºæ–°çš„inodeé¢„ç•™ä¸€ä¸ªç³»ç»Ÿå†…éƒ¨çš„ç¼–å· if (shmem_reserve_inode(sb, &amp;ino)) return NULL; // ä¸ºæ–°çš„inodeåˆ†é…å†…å­˜ inode = new_inode(sb); if (inode) &#123; // è®¾ç½®inodeçš„ç¼–å· inode-&gt;i_ino = ino; // åˆå§‹åŒ–inodeçš„æ‰€æœ‰è€…å’Œæƒé™æ¨¡å¼ inode_init_owner(idmap, inode, dir, mode); // è®¾ç½®inodeçš„ç£ç›˜å—æ•°ä¸º0 inode-&gt;i_blocks = 0; // è®¾ç½®inodeçš„è®¿é—®ã€ä¿®æ”¹å’Œåˆ›å»ºæ—¶é—´ inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode); // è®¾ç½®inodeçš„ç”Ÿæˆç¼–å·ï¼ˆç”¨äºNFSï¼‰ inode-&gt;i_generation = get_random_u32(); // è·å¾—shmem_inode_infoç»“æ„ï¼ˆtmpfsä¸“ç”¨ï¼‰ info = SHMEM_I(inode); // åˆå§‹åŒ–shmem_inode_infoç»“æ„ memset(info, 0, (char *)inode - (char *)info); spin_lock_init(&amp;info-&gt;lock); atomic_set(&amp;info-&gt;stop_eviction, 0); info-&gt;seals = F_SEAL_SEAL; info-&gt;flags = flags &amp; VM_NORESERVE; info-&gt;i_crtime = inode-&gt;i_mtime; info-&gt;fsflags = (dir == NULL) ? 0 : SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED; if (info-&gt;fsflags) shmem_set_inode_flags(inode, info-&gt;fsflags); INIT_LIST_HEAD(&amp;info-&gt;shrinklist); INIT_LIST_HEAD(&amp;info-&gt;swaplist); simple_xattrs_init(&amp;info-&gt;xattrs); cache_no_acl(inode); mapping_set_large_folios(inode-&gt;i_mapping); // æ ¹æ®ä¸åŒçš„æ–‡ä»¶ç±»å‹ï¼Œè®¾ç½®ç›¸åº”çš„æ“ä½œå‡½æ•° switch (mode &amp; S_IFMT) &#123; default: inode-&gt;i_op = &amp;shmem_special_inode_operations; init_special_inode(inode, mode, dev); break; case S_IFREG: inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops; inode-&gt;i_op = &amp;shmem_inode_operations; inode-&gt;i_fop = &amp;shmem_file_operations; mpol_shared_policy_init(&amp;info-&gt;policy, shmem_get_sbmpol(sbinfo)); break; case S_IFDIR: inc_nlink(inode); inode-&gt;i_size = 2 * BOGO_DIRENT_SIZE; inode-&gt;i_op = &amp;shmem_dir_inode_operations; inode-&gt;i_fop = &amp;simple_dir_operations; break; case S_IFLNK: mpol_shared_policy_init(&amp;info-&gt;policy, NULL); break; &#125; // ä¸ºé”ä¾èµ–åˆ†æç³»ç»Ÿè®¾ç½®inodeäº’æ–¥é”çš„æ ‡è®° lockdep_annotate_inode_mutex_key(inode); &#125; else // å¦‚æœinodeåˆ†é…å¤±è´¥ï¼Œåˆ™é‡Šæ”¾é¢„ç•™çš„ç¼–å· shmem_free_inode(sb); return inode;&#125; è®¾ç½®æ–‡ä»¶ç±»å‹ä¸ºç›®å½•ç±»å‹ æ‰€ä»¥inode-&gt;i_op = &amp;shmem_dir_inode_operations; æŸ¥çœ‹è¿™ä¸ªå˜é‡çš„å®šä¹‰ shmem_dir_inode_operations identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create, .lookup = simple_lookup,//è¿™é‡Œå®šä¹‰äº†lookupå‡½æ•° .link = shmem_link, .unlink = shmem_unlink, .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;; lookupå‡½æ•°è¢«è®¾ç½®ä¸ºäº†simple_lookup simple_lookup identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829/* * æŸ¥æ‰¾æ•°æ®ã€‚è¿™å¾ˆç®€å• - å¦‚æœ dentry ä¸å­˜åœ¨ï¼Œ * æˆ‘ä»¬çŸ¥é“å®ƒæ˜¯è´Ÿçš„ã€‚è®¾ç½® d_op ä»¥åˆ é™¤è´Ÿ dentriesã€‚ */// å®šä¹‰ simple_lookup å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªæŒ‡å‘ inode çš„æŒ‡é’ˆï¼Œ// ä¸€ä¸ªæŒ‡å‘ dentry çš„æŒ‡é’ˆï¼Œä»¥åŠä¸€ä¸ªæ— ç¬¦å·æ•´æ•°ä½œä¸ºæ ‡å¿—ä½œä¸ºå‚æ•°ã€‚struct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)&#123; // æ£€æŸ¥ dentry åç§°çš„é•¿åº¦æ˜¯å¦å¤§äºå…è®¸çš„æœ€å¤§å€¼ï¼ˆNAME_MAXï¼‰ã€‚ // å¦‚æœæ˜¯ï¼Œåˆ™è¿”å›å¸¦æœ‰ -ENAMETOOLONG çš„é”™è¯¯æŒ‡é’ˆã€‚ if (dentry-&gt;d_name.len &gt; NAME_MAX) return ERR_PTR(-ENAMETOOLONG); // å¦‚æœ dentry çš„è¶…çº§å— d_op å­—æ®µä¸º NULLï¼Œ // å°†å…¶è®¾ç½®ä¸º simple_dentry_operationsã€‚ if (!dentry-&gt;d_sb-&gt;s_d_op) d_set_d_op(dentry, &amp;simple_dentry_operations); // å°† dentry æ·»åŠ åˆ° dcache ä¸­ï¼Œä½¿ç”¨ NULL inodeï¼Œ // è¡¨ç¤ºè´Ÿ dentryï¼ˆå³ï¼Œæ–‡ä»¶ä¸å­˜åœ¨ï¼‰ã€‚ d_add(dentry, NULL); // è¿”å› NULLï¼Œè¡¨ç¤ºæŸ¥æ‰¾å·²å®Œæˆã€‚ return NULL;&#125;// å¯¼å‡º simple_lookup ç¬¦å·ï¼Œä½¿å…¶å¯ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ã€‚EXPORT_SYMBOL(simple_lookup); å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶ï¼Œsimple_lookupä¼šè¿”å›NULLï¼Œå¹¶ä¸” 12if (!dentry-&gt;d_sb-&gt;s_d_op) d_set_d_op(dentry, &amp;simple_dentry_operations); è¿™æ®µä»£ç å°†d_opè®¾ç½®ä¸ºsimple_dentry_operations ç„¶åè°ƒç”¨d_addæ·»åŠ ä¸€ä¸ªè´Ÿdentry(NULL inode),è¡¨ç¤ºæ–‡ä»¶ä¸å­˜åœ¨ã€‚ open_last_lookupså‡½æ•°open_last_lookups identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586static const char *open_last_lookups(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct dentry *dir = nd-&gt;path.dentry; // è·å–è·¯å¾„å¯¹åº”çš„ dentry int open_flag = op-&gt;open_flag; // è·å–æ–‡ä»¶æ‰“å¼€æ ‡å¿— bool got_write = false; // æ ‡è®°æ˜¯å¦è·å–åˆ°å†™æƒé™ struct dentry *dentry; const char *res; nd-&gt;flags |= op-&gt;intent; // æ›´æ–° nd çš„æ ‡å¿—ï¼Œå°† op-&gt;intent åˆå¹¶åˆ° nd-&gt;flags ä¸­ // å¤„ç†ä¸æ˜¯æ™®é€šç±»å‹çš„è·¯å¾„åˆ†é‡ï¼ˆå¦‚ &#x27;..&#x27;, &#x27;.&#x27;ï¼‰ if (nd-&gt;last_type != LAST_NORM) &#123; if (nd-&gt;depth) put_link(nd); // å¦‚æœ nd-&gt;depth ä¸ä¸º 0ï¼Œé‡Šæ”¾ç¬¦å·é“¾æ¥ return handle_dots(nd, nd-&gt;last_type); // å¤„ç† &#x27;.&#x27; å’Œ &#x27;..&#x27; è·¯å¾„åˆ†é‡ &#125; // å¦‚æœæœªè®¾ç½® O_CREATï¼Œå°è¯•åœ¨ RCU æ¨¡å¼ä¸‹å¿«é€ŸæŸ¥æ‰¾ç›®å½•é¡¹ if (!(open_flag &amp; O_CREAT)) &#123; if (nd-&gt;last.name[nd-&gt;last.len]) nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; dentry = lookup_fast(nd); // å¿«é€ŸæŸ¥æ‰¾ç›®å½•é¡¹ if (IS_ERR(dentry)) return ERR_CAST(dentry); // å¦‚æœå‡ºé”™ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ if (likely(dentry)) goto finish_lookup; BUG_ON(nd-&gt;flags &amp; LOOKUP_RCU); &#125; else &#123; // å¯¹äº O_CREAT æ ‡å¿—çš„å¤„ç† // å¦‚æœå½“å‰å¤„äº RCU æ¨¡å¼ï¼Œåˆ™å°è¯•ä» RCU æ¨¡å¼åˆ‡æ¢åˆ°é RCU æ¨¡å¼ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return ERR_PTR(-ECHILD); &#125; audit_inode(nd-&gt;name, dir, AUDIT_INODE_PARENT); // å®¡è®¡ç›¸å…³æ“ä½œ // æ£€æŸ¥è·¯å¾„åæ˜¯å¦æœ‰å°¾éšçš„ &#x27;/&#x27; if (unlikely(nd-&gt;last.name[nd-&gt;last.len])) return ERR_PTR(-EISDIR); &#125; // æ£€æŸ¥æ˜¯å¦éœ€è¦è·å–å†™æƒé™ if (open_flag &amp; (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) &#123; got_write = !mnt_want_write(nd-&gt;path.mnt); &#125; // å¦‚æœè®¾ç½®äº† O_CREATï¼Œå¯¹ç›®å½• inode ä¸Šé”ï¼›å¦åˆ™ï¼Œå¯¹ç›®å½• inode åŠ å…±äº«é” if (open_flag &amp; O_CREAT) inode_lock(dir-&gt;d_inode); else inode_lock_shared(dir-&gt;d_inode); // è°ƒç”¨ lookup_open å‡½æ•°è¿›è¡Œæ‰“å¼€æˆ–åˆ›å»ºæ“ä½œ dentry = lookup_open(nd, file, op, got_write); // å¦‚æœæˆåŠŸåˆ›å»ºæ–°æ–‡ä»¶ï¼Œé€šçŸ¥ç›¸å…³å­ç³»ç»Ÿ if (!IS_ERR(dentry) &amp;&amp; (file-&gt;f_mode &amp; FMODE_CREATED)) fsnotify_create(dir-&gt;d_inode, dentry); // è§£é”ç›®å½• inode if (open_flag &amp; O_CREAT) inode_unlock(dir-&gt;d_inode); else inode_unlock_shared(dir-&gt;d_inode); // å¦‚æœå·²è·å–å†™æƒé™ï¼Œé‡Šæ”¾å¯¹æŒ‚è½½ç‚¹çš„å†™æƒé™ if (got_write) mnt_drop_write(nd-&gt;path.mnt); if (IS_ERR(dentry)) return ERR_CAST(dentry); // å¦‚æœå‡ºé”™ï¼Œè¿”å›é”™è¯¯æŒ‡é’ˆ // å¦‚æœæ–‡ä»¶å·²æ‰“å¼€æˆ–åˆ›å»ºï¼Œæ›´æ–° nd-&gt;path if (file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED)) &#123; dput(nd-&gt;path.dentry); nd-&gt;path.dentry = dentry; return NULL; &#125;finish_lookup: // ç»“æŸæŸ¥æ‰¾ï¼Œé‡Šæ”¾ç¬¦å·é“¾æ¥å¹¶è¿›å…¥ä¸‹ä¸€ä¸ªè·¯å¾„åˆ†é‡ if (nd-&gt;depth) put_link(nd); res = step_into(nd, WALK_TRAILING, dentry); if (unlikely(res)) nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL); return res;&#125; lookup_openå‡½æ•°lookup_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// å®šä¹‰ lookup_open å‡½æ•°ï¼Œå‚æ•°åŒ…æ‹¬ï¼šä¸€ä¸ªæŒ‡å‘ nameidata ç»“æ„ä½“çš„æŒ‡é’ˆã€ä¸€ä¸ªæŒ‡å‘ file ç»“æ„ä½“çš„æŒ‡é’ˆã€ä¸€ä¸ªæŒ‡å‘ open_flags ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œä»¥åŠä¸€ä¸ªè¡¨ç¤ºæ˜¯å¦è·å¾—å†™æƒé™çš„å¸ƒå°”å€¼static struct dentry *lookup_open(struct nameidata *nd, struct file *file, const struct open_flags *op, bool got_write)&#123; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘ mnt_idmap ç»“æ„ä½“çš„æŒ‡é’ˆ struct mnt_idmap *idmap; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘å½“å‰ç›®å½• dentry ç»“æ„ä½“çš„æŒ‡é’ˆ struct dentry *dir = nd-&gt;path.dentry; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘å½“å‰ç›®å½• inode ç»“æ„ä½“çš„æŒ‡é’ˆ struct inode *dir_inode = dir-&gt;d_inode; // å®šä¹‰ä¸€ä¸ªæ•´æ•°å˜é‡ï¼Œå­˜å‚¨æ‰“å¼€æ–‡ä»¶çš„æ ‡å¿— int open_flag = op-&gt;open_flag; // å®šä¹‰ä¸€ä¸ªæŒ‡å‘æœ€ç»ˆè¦æ‰“å¼€æˆ–åˆ›å»ºçš„ç›®å½•é¡¹çš„ dentry ç»“æ„ä½“çš„æŒ‡é’ˆ struct dentry *dentry; // å®šä¹‰ä¸¤ä¸ªæ•´æ•°å˜é‡ï¼Œåˆ†åˆ«ç”¨äºå­˜å‚¨é”™è¯¯ç å’Œåˆ›å»ºé”™è¯¯ç  int error, create_error = 0; // å®šä¹‰ä¸€ä¸ªæ— ç¬¦å·æ•´æ•°å˜é‡ï¼Œå­˜å‚¨æ–‡ä»¶æ¨¡å¼ umode_t mode = op-&gt;mode; // å£°æ˜ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—å¤´å¹¶åˆå§‹åŒ–ä¸ºæ ˆä¸Šå˜é‡ DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // å¦‚æœå½“å‰ç›®å½•å·²æ­»ï¼Œè¿”å› -ENOENT é”™è¯¯ if (unlikely(IS_DEADDIR(dir_inode))) return ERR_PTR(-ENOENT); // æ¸…é™¤æ–‡ä»¶ç»“æ„ä½“çš„åˆ›å»ºæ¨¡å¼æ ‡å¿— file-&gt;f_mode &amp;= ~FMODE_CREATED; // æŸ¥æ‰¾å½“å‰ç›®å½•æ˜¯å¦åŒ…å«è¦æ‰“å¼€æˆ–åˆ›å»ºçš„ç›®å½•é¡¹ dentry = d_lookup(dir, &amp;nd-&gt;last); // ä½¿ç”¨ä¸€ä¸ªå¾ªç¯æ¥å¤„ç†ç›®å½•é¡¹æŸ¥æ‰¾å’ŒéªŒè¯ for (;;) &#123; // å¦‚æœç›®å½•é¡¹ä¸ºç©ºï¼Œè¿›è¡Œå¹¶è¡Œåˆ†é… if (!dentry) &#123; dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq); // å¦‚æœåˆ†é…å¤±è´¥ï¼Œè¿”å›é”™è¯¯ if (IS_ERR(dentry)) return dentry; &#125; // å¦‚æœç›®å½•é¡¹è¿˜åœ¨æŸ¥æ‰¾ä¸­ï¼Œè·³å‡ºå¾ªç¯ if (d_in_lookup(dentry)) break; // éªŒè¯ç›®å½•é¡¹ error = d_revalidate(dentry, nd-&gt;flags); // å¦‚æœéªŒè¯æˆåŠŸï¼Œè·³å‡ºå¾ªç¯ if (likely(error &gt; 0)) break; // å¦‚æœéªŒè¯å¤±è´¥ï¼Œå¤„ç†é”™è¯¯ if (error) goto out_dput; // ä½¿ç›®å½•é¡¹å¤±æ•ˆ d_invalidate(dentry); // é‡Šæ”¾ç›®å½•é¡¹ dput(dentry); // å°†ç›®å½•é¡¹ç½®ä¸ºç©º dentry = NULL; &#125; // å¦‚æœç›®å½•é¡¹çš„ inode ä¸ä¸ºç©ºï¼Œè¡¨ç¤ºæ‰¾åˆ°äº†æ­£ dentryï¼Œå°†åœ¨ f_op-&gt;open ä¸­æ‰“å¼€ if (dentry-&gt;d_inode) &#123; return dentry; &#125; // æ£€æŸ¥å†™æƒé™ if (unlikely(!got_write)) open_flag &amp;= ~O_TRUNC; // è·å–æ–‡ä»¶ç³»ç»Ÿçš„ ID æ˜ å°„ idmap = mnt_idmap(nd-&gt;path.mnt); // å¦‚æœéœ€è¦åˆ›å»ºæ–‡ä»¶ if (open_flag &amp; O_CREAT) &#123; // ç¡®ä¿ O_EXCL å’Œ O_TRUNC ä¸åŒæ—¶è®¾ç½® if (open_flag &amp; O_EXCL) open_flag &amp;= ~O_TRUNC; // å‡†å¤‡æ–‡ä»¶æ¨¡å¼ mode = vfs_prepare_mode(idmap, dir-&gt;d_inode, mode, mode, mode); // æ£€æŸ¥æ˜¯å¦å…·æœ‰åˆ›å»ºæƒé™ if (likely(got_write)) create_error = may_o_create(idmap, &amp;nd-&gt;path, dentry, mode); else create_error = -EROFS; &#125; // å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œæ¸…é™¤ O_CREAT æ ‡å¿— if (create_error) open_flag &amp;= ~O_CREAT; // å¦‚æœæ”¯æŒåŸå­æ‰“å¼€æ“ä½œ if (dir_inode-&gt;i_op-&gt;atomic_open) &#123; // æ‰§è¡ŒåŸå­æ‰“å¼€æ“ä½œ dentry = atomic_open(nd, dentry, file, open_flag, mode); // å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œè¿”å›åˆ›å»ºé”™è¯¯ if (unlikely(create_error) &amp;&amp; dentry == ERR_PTR(-ENOENT)) dentry = ERR_PTR(create_error); return dentry; &#125; // å¦‚æœç›®å½•é¡¹ä»åœ¨æŸ¥æ‰¾ä¸­ if (d_in_lookup(dentry)) &#123; // æ‰§è¡ŒæŸ¥æ‰¾æ“ä½œ3 struct dentry *res = dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry, nd-&gt;flags); // æ ‡è®°æŸ¥æ‰¾å®Œæˆ d_lookup_done(dentry); // å¦‚æœæŸ¥æ‰¾ç»“æœä¸ä¸ºç©º if (unlikely(res)) &#123; // å¦‚æœæŸ¥æ‰¾ç»“æœä¸ºé”™è¯¯ï¼Œå¤„ç†é”™è¯¯ if (IS_ERR(res)) &#123; error = PTR_ERR(res); goto out_dput; &#125; // é‡Šæ”¾æ—§çš„ç›®å½•é¡¹ï¼Œå°†ç»“æœèµ‹ç»™ç›®å½•é¡¹ dput(dentry); dentry = res; &#125; &#125; // å¦‚æœç›®å½•é¡¹çš„ inode ä¸ºç©ºå¹¶ä¸”éœ€è¦åˆ›å»ºæ–‡ä»¶ if (!dentry-&gt;d_inode &amp;&amp; (open_flag &amp; O_CREAT)) &#123; // è®¾ç½®æ–‡ä»¶ç»“æ„ä½“çš„åˆ›å»ºæ¨¡å¼æ ‡å¿— file-&gt;f_mode |= FMODE_CREATED; // è®°å½•åˆ›å»ºå­èŠ‚ç‚¹çš„å®¡è®¡äº‹ä»¶ audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE); // å¦‚æœæ²¡æœ‰åˆ›å»ºæ“ä½œï¼Œè¿”å›é”™è¯¯ if (!dir_inode-&gt;i_op-&gt;create) &#123; error = -EACCES; goto out_dput; &#125; // åˆ›å»ºæ–°æ–‡ä»¶çš„å…³é”®ä»£ç  error = dir_inode-&gt;i_op-&gt;create(idmap, dir_inode, dentry, mode, open_flag &amp; O_EXCL); // å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œå¤„ç†é”™è¯¯ if (error) goto out_dput; &#125; // å¦‚æœåˆ›å»ºå¤±è´¥ä¸”ç›®å½•é¡¹çš„ inode ä»ä¸ºç©ºï¼Œè¿”å›é”™è¯¯ if (unlikely(create_error) &amp;&amp; !dentry-&gt;d_inode) &#123; error = create_error; goto out_dput; &#125; // è¿”å›ç›®å½•é¡¹ return dentry;// å¤„ç†é‡Šæ”¾ç›®å½•é¡¹çš„é”™è¯¯æƒ…å†µout_dput: dput(dentry); // è¿”å›é”™è¯¯æŒ‡é’ˆ return ERR_PTR(error);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// å®šä¹‰ d_alloc_parallel å‡½æ•°ï¼Œè¾“å…¥å‚æ•°åŒ…æ‹¬çˆ¶ç›®å½•é¡¹ parentã€ç›®å½•é¡¹åå­— name å’Œç­‰å¾…é˜Ÿåˆ—å¤´ wqstruct dentry *d_alloc_parallel(struct dentry *parent, const struct qstr *name, wait_queue_head_t *wq)&#123; // è®¡ç®—åå­—çš„å“ˆå¸Œå€¼ unsigned int hash = name-&gt;hash; // è®¡ç®—å“ˆå¸Œå€¼å¯¹åº”çš„å“ˆå¸Œé“¾è¡¨å¤´ struct hlist_bl_head *b = in_lookup_hash(parent, hash); // å£°æ˜å“ˆå¸Œé“¾è¡¨èŠ‚ç‚¹ struct hlist_bl_node *node; // åˆ†é…ä¸€ä¸ªæ–°çš„ç›®å½•é¡¹ struct dentry *new = d_alloc(parent, name); // å£°æ˜ä¸€ä¸ªç›®å½•é¡¹å˜é‡ struct dentry *dentry; // å£°æ˜åºåˆ—å·å˜é‡ unsigned seq, r_seq, d_seq; // å¦‚æœæ–°åˆ†é…çš„ç›®å½•é¡¹ä¸ºç©ºï¼Œè¿”å›é”™è¯¯ if (unlikely(!new)) return ERR_PTR(-ENOMEM); // ä½¿ç”¨ä¸€ä¸ªå¾ªç¯æ¥å¤„ç†ç›®å½•é¡¹æŸ¥æ‰¾å’ŒéªŒè¯ retry: // å¼€å¯ RCU è¯»é” rcu_read_lock(); // è·å–çˆ¶ç›®å½•é¡¹çš„åºåˆ—å· seq = smp_load_acquire(&amp;parent-&gt;d_inode-&gt;i_dir_seq); // è·å–é‡å‘½åé”çš„åºåˆ—å· r_seq = read_seqbegin(&amp;rename_lock); // åœ¨ RCU ä¿æŠ¤ä¸‹æŸ¥æ‰¾ç›®å½•é¡¹ dentry = __d_lookup_rcu(parent, name, &amp;d_seq); // å¦‚æœç›®å½•é¡¹å­˜åœ¨ if (unlikely(dentry)) &#123; // å°è¯•è·å–ç›®å½•é¡¹çš„å¼•ç”¨ï¼Œå¦‚æœå¤±è´¥åˆ™é‡è¯• if (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123; rcu_read_unlock(); goto retry; &#125; // æ£€æŸ¥ç›®å½•é¡¹çš„åºåˆ—å·æ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Œå¦‚æœå‘ç”Ÿå˜åŒ–åˆ™é‡Šæ”¾ç›®å½•é¡¹å¹¶é‡è¯• if (read_seqcount_retry(&amp;dentry-&gt;d_seq, d_seq)) &#123; rcu_read_unlock(); dput(dentry); goto retry; 123456789101112131415161718192021222324252627282930/** * d_lookup - æœç´¢ä¸€ä¸ªdentry * @parent: çˆ¶dentry * @name: æˆ‘ä»¬è¦æŸ¥æ‰¾çš„åå­—çš„qstr * è¿”å›: dentryï¼Œæˆ–è€…NULL * * d_lookupåœ¨çˆ¶dentryçš„å­é¡¹ä¸­æœç´¢æŒ‡å®šçš„åå­—ã€‚ * å¦‚æœæ‰¾åˆ°äº†dentryï¼Œå®ƒçš„å¼•ç”¨è®¡æ•°ä¼šé€’å¢ï¼Œå¹¶è¿”å›è¯¥dentryã€‚ * è°ƒç”¨è€…åœ¨ä½¿ç”¨å®Œæ¯•åå¿…é¡»ä½¿ç”¨dputæ¥é‡Šæ”¾è¯¥é¡¹ã€‚å¦‚æœdentryä¸å­˜åœ¨ï¼Œè¿”å›%NULLã€‚ */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; // ä½¿ç”¨å¾ªç¯ï¼ŒçŸ¥é“æ»¡è¶³æ¡ä»¶é€€å‡º do &#123; // è¯»å–é‡å‘½åé”çš„åºåˆ—å· seq = read_seqbegin(&amp;rename_lock); // åœ¨çˆ¶dentryçš„å­é¡¹ä¸­æŸ¥æ‰¾åå­— dentry = __d_lookup(parent, name); // å¦‚æœæ‰¾åˆ°äº†dentryï¼Œè·³å‡ºå¾ªç¯ if (dentry) break; // å¦‚æœé‡å‘½åé”çš„åºåˆ—å·å‘ç”Ÿå˜åŒ–ï¼Œé‡è¯• &#125; while (read_seqretry(&amp;rename_lock, seq)); // è¿”å›æ‰¾åˆ°çš„dentryï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›NULL return dentry;&#125;EXPORT_SYMBOL(d_lookup); // å¯¼å‡ºd_lookupç¬¦å·ï¼Œä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * __d_lookup - æœç´¢ä¸€ä¸ªdentryï¼ˆæœ‰ç«äº‰é£é™©ï¼‰ * @parent: çˆ¶dentry * @name: æˆ‘ä»¬è¦æŸ¥æ‰¾çš„åå­—çš„qstr * è¿”å›: dentryï¼Œæˆ–è€…NULL * * __d_lookupç±»ä¼¼äºd_lookupï¼Œç„¶è€Œç”±äºæ— å…³çš„é‡å‘½åæ´»åŠ¨ï¼Œå®ƒå¯èƒ½ï¼ˆè¾ƒå°‘æƒ…å†µä¸‹ï¼‰è¿”å›ä¸€ä¸ª * é”™è¯¯çš„è´Ÿé¢ç»“æœã€‚ * * __d_lookupé€šè¿‡é¿å…è¯»å–rename_lock seqlockè€Œç•¥å¾®æ›´å¿«ï¼Œä½†æ˜¯å¿…é¡»è°¨æ…ä½¿ç”¨ï¼Œä¾‹å¦‚åœ¨å¤±è´¥æ—¶ * ä½¿ç”¨åç»­çš„d_lookupã€‚ * * __d_lookupè°ƒç”¨è€…å¿…é¡»è¿›è¡Œæ³¨é‡Šã€‚ */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; struct hlist_bl_head *b = d_hash(hash); struct hlist_bl_node *node; struct dentry *found = NULL; struct dentry *dentry; /* * æ³¨æ„ï¼šä¸__d_lookup_rcuæœ‰å¾ˆå¤§çš„é‡å¤ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢å•çº¿ç¨‹æ€§èƒ½é€€åŒ– * å°¤å…¶æ˜¯åœ¨smp_rmbï¼ˆåœ¨seqcountsä¸­ï¼‰ä»£ä»·é«˜æ˜‚çš„ä½“ç³»ç»“æ„ä¸Šã€‚ * ä¿æŒä¸¤ä¸ªå‡½æ•°åŒæ­¥ã€‚ */ /* * å“ˆå¸Œåˆ—è¡¨ä½¿ç”¨RCUè¿›è¡Œä¿æŠ¤ã€‚ * * åœ¨æ¯”è¾ƒå€™é€‰dentryæ—¶è·å–d_lockï¼Œä»¥é¿å…ä¸d_move()çš„ç«äº‰ã€‚ * * å¯èƒ½çš„æ˜¯ï¼ŒåŒæ—¶å‘ç”Ÿçš„é‡å‘½åå¯èƒ½ä¼šç ´åæˆ‘ä»¬è¿™é‡Œçš„åˆ—è¡¨éå†ï¼Œ * å¹¶å¯¼è‡´æˆ‘ä»¬çš„dentryä¸¢å¤±ï¼Œä»è€Œå¯¼è‡´é”™è¯¯çš„è´Ÿé¢ç»“æœã€‚ * d_lookup()ä½¿ç”¨rename_lock seqlockä¿æŠ¤å…å—åŒæ—¶è¿›è¡Œçš„é‡å‘½åå½±å“ã€‚ * * æœ‰å…³è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…Documentation/filesystems/path-lookup.txtã€‚ */ rcu_read_lock(); // ä½¿ç”¨RCUéå†å“ˆå¸Œåˆ—è¡¨çš„æ¯ä¸ªæ¡ç›® hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) continue; // è·å–dentryçš„é”ï¼Œé¿å…ç«äº‰ spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_parent != parent) goto next; if (d_unhashed(dentry)) goto next; // æ£€æŸ¥dentryçš„åå­—æ˜¯å¦ä¸ç»™å®šçš„åå­—åŒ¹é… if (!d_same_name(dentry, parent, name)) goto next; // å¢åŠ dentryçš„å¼•ç”¨è®¡æ•° dentry-&gt;d_lockref.count++; found = dentry; // è§£é”dentryçš„é” spin_unlock(&amp;dentry-&gt;d_lock); break;next: spin_unlock(&amp;dentry-&gt;d_lock); &#125; rcu_read_unlock(); // è¿”å›æ‰¾åˆ°çš„dentryï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™è¿”å›NULL return found;&#125; dir_inode-&gt;i_op-&gt;createæŒ‡å‘shmem_createå‡½æ•°å‚è€ƒä¸Šæ–‡ä¸­çš„inode-&gt;i_op-&gt;lookupå‡½æ•°æŒ‡å‘simple_lookup() 12345678910111213141516171819202122232425static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create,//è¿™é‡Œå®šä¹‰äº†createå‡½æ•° .lookup = simple_lookup,//è¿™é‡Œå®šä¹‰äº†lookupå‡½æ•° .link = shmem_link, .unlink = shmem_unlink, .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;;_setattr,&#125;; å¯ä»¥çœ‹åˆ°è¿™ä¸ªç»“æ„ä½“ä¸­.create = shmem_createï¼Œæˆ‘ä»¬å†ç»†çœ‹shmem_createå‡½æ•° shmem_create identifier - Linux source code (v6.3.6) - Bootlin 12345static int shmem_create(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)&#123; return shmem_mknod(idmap, dir, dentry, mode | S_IFREG, 0);&#125; shmem_mknodå‡½æ•°shmem_mknod identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142static intshmem_mknod(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)&#123; struct inode *inode; // ç”¨äºå­˜å‚¨æ–°åˆ›å»ºçš„ inode int error = -ENOSPC; // åˆå§‹åŒ–é”™è¯¯ç ä¸º -ENOSPCï¼ˆæ²¡æœ‰ç©ºé—´å¯ç”¨ï¼‰ // ä»å…±äº«å†…å­˜æ–‡ä»¶ç³»ç»Ÿè·å–æ–°çš„ inode inode = shmem_get_inode(idmap, dir-&gt;i_sb, dir, mode, dev, VM_NORESERVE); if (inode) &#123; // å¦‚æœæˆåŠŸè·å– inode // åˆ›å»ºç®€å• ACLï¼ˆè®¿é—®æ§åˆ¶åˆ—è¡¨ï¼‰ error = simple_acl_create(dir, inode); if (error) // å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œè·³è½¬åˆ° out_iput æ ‡ç­¾ goto out_iput; // åˆå§‹åŒ– inode å®‰å…¨å±æ€§ error = security_inode_init_security(inode, dir, &amp;dentry-&gt;d_name, shmem_initxattrs, NULL); // å¦‚æœåˆå§‹åŒ–å¤±è´¥ä¸”é”™è¯¯ç ä¸æ˜¯ -EOPNOTSUPPï¼Œè·³è½¬åˆ° out_iput æ ‡ç­¾ if (error &amp;&amp; error != -EOPNOTSUPP) goto out_iput; // è‡³æ­¤ï¼Œæ–‡ä»¶åˆ›å»ºæˆåŠŸï¼Œå°†é”™è¯¯ç ç½®ä¸º 0 error = 0; // æ›´æ–°ç›®å½• inode å¤§å° dir-&gt;i_size += BOGO_DIRENT_SIZE; // æ›´æ–°ç›®å½• inode è®¿é—®å’Œä¿®æ”¹æ—¶é—´ dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(dir); // é€’å¢ç›®å½• inode çš„ i_version inode_inc_iversion(dir); // å°†æ–°åˆ›å»ºçš„ inode ä¸ dentry å…³è” d_instantiate(dentry, inode); // å¢åŠ  dentry å¼•ç”¨è®¡æ•° dget(dentry); /* Extra count - pin the dentry in core */ &#125; return error; // è¿”å›é”™è¯¯ç out_iput: // å¤„ç†åˆ›å»ºè¿‡ç¨‹ä¸­çš„é”™è¯¯ iput(inode); // é‡Šæ”¾ inode return error; // è¿”å›é”™è¯¯ç &#125; do_openå‡½æ•°do_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * å¤„ç† open() çš„æœ€åä¸€æ­¥ */static int do_open(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct mnt_idmap *idmap; int open_flag = op-&gt;open_flag; bool do_truncate; int acc_mode; int error; // å¦‚æœæ–‡ä»¶æœªè¢«æ‰“å¼€æˆ–åˆ›å»ºï¼Œå®Œæˆè·¯å¾„åè§£æ if (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123; error = complete_walk(nd); if (error) return error; &#125; // å¦‚æœæ–‡ä»¶æœªè¢«åˆ›å»ºï¼Œè¿›è¡Œå®¡è®¡å¤„ç† if (!(file-&gt;f_mode &amp; FMODE_CREATED)) audit_inode(nd-&gt;name, nd-&gt;path.dentry, 0); // è·å–æ–‡ä»¶ç³»ç»Ÿ ID æ˜ å°„ idmap = mnt_idmap(nd-&gt;path.mnt); // å¤„ç† O_CREAT æ ‡å¿— if (open_flag &amp; O_CREAT) &#123; // å¦‚æœè®¾ç½®äº† O_EXCL æ ‡å¿—ä¸”æ–‡ä»¶æœªè¢«åˆ›å»ºï¼Œè¿”å›é”™è¯¯ if ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED)) return -EEXIST; // å¦‚æœç›®æ ‡æ˜¯ç›®å½•ï¼Œè¿”å›é”™è¯¯ if (d_is_dir(nd-&gt;path.dentry)) return -EISDIR; // æ£€æŸ¥æ˜¯å¦æœ‰æƒé™åœ¨ç²˜æ»ä½ç›®å½•ä¸­åˆ›å»ºæ–‡ä»¶ error = may_create_in_sticky(idmap, nd, d_backing_inode(nd-&gt;path.dentry)); if (unlikely(error)) return error; &#125; // æ£€æŸ¥ç›®æ ‡æ˜¯å¦æ˜¯ç›®å½• if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry)) return -ENOTDIR; // åˆå§‹åŒ– do_truncate å’Œ acc_mode do_truncate = false; acc_mode = op-&gt;acc_mode; // å¦‚æœæ–‡ä»¶å·²è¢«åˆ›å»ºï¼Œè·³è¿‡å†™æƒé™æ£€æŸ¥å’Œæˆªæ–­æ“ä½œ if (file-&gt;f_mode &amp; FMODE_CREATED) &#123; open_flag &amp;= ~O_TRUNC; acc_mode = 0; &#125; else if (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123; // å¦‚æœç›®æ ‡æ˜¯æ™®é€šæ–‡ä»¶ä¸”è®¾ç½®äº† O_TRUNC æ ‡å¿—ï¼Œæ£€æŸ¥å†™æƒé™ error = mnt_want_write(nd-&gt;path.mnt); if (error) return error; do_truncate = true; &#125; // æ£€æŸ¥æ˜¯å¦æœ‰æƒé™æ‰“å¼€æ–‡ä»¶ error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag); // å¦‚æœæ²¡æœ‰é”™è¯¯ä¸”æ–‡ä»¶æœªè¢«æ‰“å¼€ï¼Œè°ƒç”¨ vfs_open æ‰“å¼€æ–‡ä»¶ if (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED)) error = vfs_open(&amp;nd-&gt;path, file); // å¯¹æ–‡ä»¶æ‰§è¡Œ IMA å®¡è®¡ if (!error) error = ima_file_check(file, op-&gt;acc_mode); // å¦‚æœéœ€è¦æˆªæ–­ï¼Œæ‰§è¡Œæˆªæ–­æ“ä½œ if (!error &amp;&amp; do_truncate) error = handle_truncate(idmap, file); // å¦‚æœé”™è¯¯ç å¤§äº 0ï¼Œè¾“å‡ºè­¦å‘Šå¹¶è®¾ç½®é”™è¯¯ç ä¸º -EINVAL if (unlikely(error &gt; 0)) &#123; WARN_ON(1); error = -EINVAL; &#125; // å¦‚æœè¿›è¡Œäº†æˆªæ–­æ“ä½œï¼Œé‡Šæ”¾å†™æƒé™ if (do_truncate) mnt_drop_write(nd-&gt;path.mnt); return error;&#125; vfs_openå‡½æ•°vfs_open identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314/** * vfs_open - æ‰“å¼€ç»™å®šè·¯å¾„çš„æ–‡ä»¶ * @path: è¦æ‰“å¼€çš„è·¯å¾„ * @file: æ–°åˆ†é…çš„æ–‡ä»¶ï¼Œå·²åˆå§‹åŒ– f_flag */int vfs_open(const struct path *path, struct file *file)&#123; // å°†æ–‡ä»¶çš„è·¯å¾„è®¾ç½®ä¸ºç»™å®šè·¯å¾„ file-&gt;f_path = *path; // è°ƒç”¨ do_dentry_open() å‡½æ•°æ‰“å¼€æ–‡ä»¶ // è¿™é‡Œä¼ é€’ NULL ä½œä¸º open() å‡½æ•°çš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œå› ä¸ºåœ¨ tmpfs ä¸­ï¼Œä¸éœ€è¦ç‰¹å®šçš„æ‰“å¼€æ“ä½œ return do_dentry_open(file, d_backing_inode(path-&gt;dentry), NULL);&#125; do_dentry_openå‡½æ•°do_dentry_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137static int do_dentry_open(struct file *f, struct inode *inode, int (*open)(struct inode *, struct file *))&#123; // å£°æ˜ä¸€ä¸ªç©ºçš„æ–‡ä»¶æ“ä½œç»“æ„ static const struct file_operations empty_fops = &#123;&#125;; int error; // å¢åŠ è·¯å¾„çš„å¼•ç”¨è®¡æ•° path_get(&amp;f-&gt;f_path); // è®¾ç½®æ–‡ä»¶çš„ inode f-&gt;f_inode = inode; // è®¾ç½®æ–‡ä»¶çš„åœ°å€ç©ºé—´ï¼ˆæ˜ å°„ï¼‰ f-&gt;f_mapping = inode-&gt;i_mapping; // ä»æ–‡ä»¶çš„åœ°å€ç©ºé—´ä¸­è·å–å†™å›é”™è¯¯æ ·æœ¬ f-&gt;f_wb_err = filemap_sample_wb_err(f-&gt;f_mapping); // ä»æ–‡ä»¶ä¸­è·å–è¶…çº§å—é”™è¯¯æ ·æœ¬ f-&gt;f_sb_err = file_sample_sb_err(f); // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä»¥ O_PATH æ ‡å¿—æ‰“å¼€ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è®¾ç½®æ–‡ä»¶æ¨¡å¼å’Œæ“ä½œ if (unlikely(f-&gt;f_flags &amp; O_PATH)) &#123; f-&gt;f_mode = FMODE_PATH | FMODE_OPENED; f-&gt;f_op = &amp;empty_fops; return 0; &#125; // å¦‚æœæ–‡ä»¶ä»¥è¯»æ¨¡å¼æ‰“å¼€ï¼Œå¢åŠ è¯»å–è®¡æ•° if ((f-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ) &#123; i_readcount_inc(inode); // å¦‚æœæ–‡ä»¶ä»¥å†™æ¨¡å¼æ‰“å¼€ä¸”ä¸æ˜¯ç‰¹æ®Šæ–‡ä»¶ï¼Œæˆäºˆå†™è®¿é—®æƒé™ &#125; else if (f-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !special_file(inode-&gt;i_mode)) &#123; error = get_write_access(inode); if (unlikely(error)) goto cleanup_file; error = __mnt_want_write(f-&gt;f_path.mnt); if (unlikely(error)) &#123; put_write_access(inode); goto cleanup_file; &#125; f-&gt;f_mode |= FMODE_WRITER; &#125; // ä¸ºå¸¸è§„æ–‡ä»¶å’Œç›®å½•å¯ç”¨åŸå­ä½ç½® if (S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)) f-&gt;f_mode |= FMODE_ATOMIC_POS; /* è®¾ç½®å…¶ä»–f_modeæ ‡å¿—,è·å–shmem_file_operationsä½œä¸ºf_op */ f-&gt;f_op = fops_get(inode-&gt;i_fop); if (WARN_ON(!f-&gt;f_op)) &#123; error = -ENODEV; goto cleanup_all; &#125; /* è°ƒç”¨security_file_open()å’Œbreak_lease() */ error = security_file_open(f); if (error) goto cleanup_all; // æ£€æŸ¥æ–‡ä»¶ä¸Šæ˜¯å¦å­˜åœ¨éœ€è¦ä¸­æ–­çš„æ´»åŠ¨ç§Ÿçº¦ error = break_lease(file_inode(f), f-&gt;f_flags); if (error) goto cleanup_all; // ä¸ºå¯»æ‰¾ã€pread å’Œ pwrite è®¾ç½®é»˜è®¤æ–‡ä»¶æ¨¡å¼æ ‡å¿— f-&gt;f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE; // ä½¿ç”¨æ–‡ä»¶æ“ä½œæä¾›çš„ open å‡½æ•°ï¼Œå¦‚æœæœªæä¾›ï¼Œåˆ™ä½¿ç”¨é»˜è®¤å€¼ if (!open) open = f-&gt;f_op-&gt;open; if (open) &#123; error = open(inode, f); if (error) goto cleanup_all; &#125; // è®¾ç½®æ–‡ä»¶æ¨¡å¼æ ‡å¿—ä»¥è¡¨ç¤ºæ–‡ä»¶å·²æ‰“å¼€ f-&gt;f_mode |= FMODE_OPENED; // æ ¹æ®ç›¸åº”æ“ä½œçš„å¯ç”¨æ€§è®¾ç½®è¯»å†™èƒ½åŠ› if ((f-&gt;f_mode &amp; FMODE_READ) &amp;&amp; likely(f-&gt;f_op-&gt;read || f-&gt;f_op-&gt;read_iter)) f-&gt;f_mode |= FMODE_CAN_READ; if ((f-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; likely(f-&gt;f_op-&gt;write || f-&gt;f_op-&gt;write_iter)) f-&gt;f_mode |= FMODE_CAN_WRITE; // å¦‚æœ llseek æ“ä½œä¸å¯ç”¨ï¼Œåˆ™ç¦ç”¨å¯»æ‰¾ if ((f-&gt;f_mode &amp; FMODE_LSEEK) &amp;&amp; !f-&gt;f_op-&gt;llseek) f-&gt;f_mode &amp;= ~FMODE_LSEEK; // å¦‚æœåœ°å€ç©ºé—´æ“ä½œæ”¯æŒï¼Œåˆ™å¯ç”¨ç›´æ¥ I/O if (f-&gt;f_mapping-&gt;a_ops &amp;&amp; f-&gt;f_mapping-&gt;a_ops-&gt;direct_IO) f-&gt;f_mode |= FMODE_CAN_ODIRECT; // æ¸…é™¤ä¸å¿…è¦çš„æ‰“å¼€æ ‡å¿— f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC); // ä¸ºæ–‡ä»¶è®¾ç½® iocb æ ‡å¿— f-&gt;f_iocb_flags = iocb_flags(f); // åˆå§‹åŒ–æ–‡ä»¶çš„é¢„è¯»çŠ¶æ€ file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping); // å¦‚æœè¯·æ±‚ O_DIRECT ä½†ä¸æ”¯æŒï¼Œåˆ™è¿”å›é”™è¯¯ if ((f-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !(f-&gt;f_mode &amp; FMODE_CAN_ODIRECT)) return -EINVAL; // å¦‚æœæ–‡ä»¶ä»¥å†™æ¨¡å¼æ‰“å¼€ï¼Œè¯·ç¡®ä¿ä¸ä½¿ç”¨å·¨å¤§çš„é¡µé¢ç¼“å­˜ if (f-&gt;f_mode &amp; FMODE_WRITE) &#123; smp_mb(); // ä¸ºåç»­æ“ä½œç¡®ä¿å†…å­˜æ’åº // æ£€æŸ¥é¡µé¢ç¼“å­˜ä¸­æ˜¯å¦æœ‰ä»»ä½•å·¨å¤§çš„é¡µé¢ if (filemap_nr_thps(inode-&gt;i_mapping)) &#123; struct address_space *mapping = inode-&gt;i_mapping; // é”å®šé¡µé¢ç¼“å­˜å¹¶ä½¿å…¶æ— æ•ˆ filemap_invalidate_lock(inode-&gt;i_mapping); // å–æ¶ˆæ˜ å°„æ–‡ä»¶çš„å†…å­˜èŒƒå›´ unmap_mapping_range(mapping, 0, 0, 0); // æˆªæ–­é¡µé¢ç¼“å­˜ä¸­çš„ inode é¡µé¢ truncate_inode_pages(mapping, 0); // è§£é”é¡µé¢ç¼“å­˜ filemap_invalidate_unlock(inode-&gt;i_mapping); &#125; &#125; return 0;cleanup_all: // æ£€æŸ¥æ— æ•ˆçš„æ­£é”™è¯¯ä»£ç å¹¶é‡ç½®ä¸º -EINVAL if (WARN_ON_ONCE(error &gt; 0)) error = -EINVAL; // é‡Šæ”¾æ–‡ä»¶æ“ä½œç»“æ„ fops_put(f-&gt;f_op); // é‡Šæ”¾æ–‡ä»¶è®¿é—® put_file_access(f);cleanup_file: // å‡å°‘è·¯å¾„çš„å¼•ç”¨è®¡æ•°å¹¶æ¸…é™¤æ–‡ä»¶çš„è·¯å¾„å’Œ inode path_put(&amp;f-&gt;f_path); f-&gt;f_path.mnt = NULL; f-&gt;f_path.dentry = NULL; f-&gt;f_inode = NULL; return error;&#125; open &#x3D; f-&gt;f_op-&gt;openè®¾ç½®ä¸ºgeneric_filp_openå‡½æ•°generic_file_open identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718// å®šä¹‰ä¸€ä¸ªé€šç”¨æ–‡ä»¶æ‰“å¼€å‡½æ•°ï¼Œå®ƒåœ¨ä¸€ä¸ªinodeå³å°†è¢«æ‰“å¼€æ—¶è°ƒç”¨ã€‚// ç”¨äºåœ¨32ä½ç³»ç»Ÿä¸­ç¦æ­¢æ‰“å¼€å¤§æ–‡ä»¶ï¼Œé™¤éè°ƒç”¨è€…æŒ‡å®šäº†O_LARGEFILEæ ‡å¿—ã€‚// åœ¨64ä½ç³»ç»Ÿä¸­ï¼Œsys_openå‡½æ•°ä¼šå¼ºåˆ¶ä½¿ç”¨è¿™ä¸ªæ ‡å¿—ã€‚int generic_file_open(struct inode *inode, struct file *filp)&#123; // æ£€æŸ¥filp-&gt;f_flagsæ˜¯å¦è®¾ç½®äº†O_LARGEFILEæ ‡å¿—ã€‚å¦‚æœæ²¡æœ‰è®¾ç½® // å¹¶ä¸”æ–‡ä»¶å¤§å°ï¼ˆé€šè¿‡i_size_readè·å–ï¼‰å¤§äºMAX_NON_LFSï¼ˆæ–‡ä»¶ç³»ç»Ÿçš„æœ€å¤§æ–‡ä»¶é™åˆ¶ï¼‰ï¼Œ // åˆ™ç¦æ­¢æ‰“å¼€è¯¥æ–‡ä»¶ã€‚ if (!(filp-&gt;f_flags &amp; O_LARGEFILE) &amp;&amp; i_size_read(inode) &gt; MAX_NON_LFS) // å¦‚æœæ¡ä»¶æ»¡è¶³ï¼Œè¿”å›-EOVERFLOWè¡¨ç¤ºæ–‡ä»¶å¤ªå¤§ï¼Œæ— æ³•æ‰“å¼€ã€‚ return -EOVERFLOW; // å¦‚æœæ–‡ä»¶å¤§å°åœ¨å…è®¸çš„èŒƒå›´å†…ï¼Œè¿”å›0è¡¨ç¤ºæˆåŠŸæ‰“å¼€æ–‡ä»¶ã€‚ return 0;&#125;// å°†generic_file_openå‡½æ•°å¯¼å‡ºä¸ºå¯ä¾›å…¶ä»–æ¨¡å—è°ƒç”¨çš„ç¬¦å·ã€‚EXPORT_SYMBOL(generic_file_open); é¦–å…ˆè¿™æ®µä»£ç f-&gt;f_op = fops_get(inode-&gt;i_fop);å°†f-&gt;f_opè®¾ç½®ä¸ºshmem_file_operations 123456789101112131415// å®šä¹‰shmemæ–‡ä»¶ç³»ç»Ÿçš„æ–‡ä»¶æ“ä½œç»“æ„ä½“static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // æ˜ å°„æ–‡ä»¶åˆ°å†…å­˜çš„æ“ä½œ .open = generic_file_open, // æ‰“å¼€æ–‡ä»¶çš„é€šç”¨æ“ä½œ .get_unmapped_area = shmem_get_unmapped_area, // è·å–æœªæ˜ å°„åŒºåŸŸçš„æ“ä½œ#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // é‡å®šä½æ–‡ä»¶è¯»å†™æŒ‡é’ˆçš„æ“ä½œ .read_iter = shmem_file_read_iter, // è¯»å–æ–‡ä»¶çš„æ“ä½œ .write_iter = generic_file_write_iter, // å†™å…¥æ–‡ä»¶çš„é€šç”¨æ“ä½œ .fsync = noop_fsync, // åŒæ­¥æ–‡ä»¶çš„ç©ºæ“ä½œï¼ˆå› ä¸ºshmemæ–‡ä»¶ç³»ç»Ÿä¸éœ€è¦åŒæ­¥ï¼‰ .splice_read = generic_file_splice_read, // ä»æ–‡ä»¶ä¸­è¯»å–å¹¶æ‹¼æ¥æ•°æ®çš„é€šç”¨æ“ä½œ .splice_write = iter_file_splice_write, // å‘æ–‡ä»¶ä¸­æ‹¼æ¥å¹¶å†™å…¥æ•°æ®çš„æ“ä½œ .fallocate = shmem_fallocate, // é¢„åˆ†é…æ–‡ä»¶ç©ºé—´çš„æ“ä½œ#endif&#125;; ä¸ºä»€ä¹ˆè®¾ç½®ä¸ºshmem_file_operationså‘¢ï¼Ÿæ ¹æ®ä¸Šæ–‡å¯¹shmem_get_inodeçš„è§£æï¼Œé‡Œé¢æœ‰è¿™ä¸€æ®µä»£ç inode-&gt;i_fop = &amp;shmem_file_operations; è¯»å†™æ–‡ä»¶è¯»æ–‡ä»¶readç³»ç»Ÿè°ƒç”¨sys_read identifier - Linux source code (v6.3.7) - Bootlin 1234SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)&#123; return ksys_read(fd, buf, count);&#125; ksys_readå‡½æ•°ksys_read identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132// å®šä¹‰ ksys_read å‡½æ•°ï¼Œå‚æ•°åŒ…æ‹¬ï¼šæ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰ï¼Œç”¨æˆ·ç¼“å†²åŒºï¼ˆbufï¼‰å’Œè¦è¯»å–çš„å­—èŠ‚æ•°ï¼ˆcountï¼‰ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)&#123; // ä»ç»™å®šçš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆfdï¼‰è·å–æ–‡ä»¶æè¿°ç¬¦å¯¹è±¡ï¼ˆfï¼‰ï¼Œå¹¶å°†è¿”å›å€¼ï¼ˆretï¼‰åˆå§‹åŒ–ä¸º -EBADFï¼ˆé”™è¯¯ï¼šé”™è¯¯çš„æ–‡ä»¶æè¿°ç¬¦ï¼‰ struct fd f = fdget_pos(fd); ssize_t ret = -EBADF; // å¦‚æœæ–‡ä»¶æè¿°ç¬¦å¯¹è±¡æœ‰æ•ˆï¼ˆä¸ä¸º NULLï¼‰ if (f.file) &#123; // å£°æ˜ä¸€ä¸ªå˜é‡ï¼ˆposï¼‰æ¥å­˜å‚¨æ–‡ä»¶ä¸­çš„å½“å‰ä½ç½®å’ŒæŒ‡å‘ä½ç½®çš„æŒ‡é’ˆï¼ˆpposï¼‰ loff_t pos, *ppos = file_ppos(f.file); // å¦‚æœä½ç½®æŒ‡é’ˆï¼ˆpposï¼‰ä¸ä¸º NULLï¼Œåˆ™å°†å½“å‰ä½ç½®å­˜å‚¨åœ¨å˜é‡ï¼ˆposï¼‰ä¸­ï¼Œå¹¶æ›´æ–°æŒ‡é’ˆä»¥æŒ‡å‘å®ƒ if (ppos) &#123; pos = *ppos; ppos = &amp;pos; &#125; // è°ƒç”¨ vfs_read å‡½æ•°ä»æ–‡ä»¶ä¸­è¯»å–æ•°æ®åˆ°ç”¨æˆ·ç¼“å†²åŒºï¼ˆbufï¼‰ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åœ¨è¿”å›å€¼ï¼ˆretï¼‰ä¸­ ret = vfs_read(f.file, buf, count, ppos); // å¦‚æœè¯»å–æ“ä½œæˆåŠŸï¼ˆret &gt;= 0ï¼‰ä¸”ä½ç½®æŒ‡é’ˆä¸ä¸º NULLï¼Œåˆ™æ›´æ–°æ–‡ä»¶æè¿°ç¬¦å¯¹è±¡ä¸­çš„æ–‡ä»¶ä½ç½® if (ret &gt;= 0 &amp;&amp; ppos) f.file-&gt;f_pos = pos; // é‡Šæ”¾æ–‡ä»¶æè¿°ç¬¦å¯¹è±¡å¹¶æ›´æ–°æ–‡ä»¶ä½ç½® fdput_pos(f); &#125; // è¿”å›è¯»å–æ“ä½œçš„ç»“æœï¼ˆå·²è¯»å–çš„å­—èŠ‚æ•°æˆ–é”™è¯¯ä»£ç ï¼‰ return ret;&#125; vfs_readå‡½æ•°vfs_read identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344// å®šä¹‰ vfs_read å‡½æ•°ï¼Œå‚æ•°åŒ…æ‹¬ï¼šæ–‡ä»¶æŒ‡é’ˆ (file)ï¼Œç”¨æˆ·ç¼“å†²åŒº (buf)ï¼Œè¦è¯»å–çš„å­—èŠ‚æ•° (count)ï¼Œæ–‡ä»¶ä½ç½®æŒ‡é’ˆ (pos)ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)&#123; ssize_t ret; // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯è¯»ï¼Œå¦‚æœä¸å¯è¯»åˆ™è¿”å› -EBADF é”™è¯¯ if (!(file-&gt;f_mode &amp; FMODE_READ)) return -EBADF; // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ”¯æŒè¯»æ“ä½œï¼Œå¦‚æœä¸æ”¯æŒåˆ™è¿”å› -EINVAL é”™è¯¯ if (!(file-&gt;f_mode &amp; FMODE_CAN_READ)) return -EINVAL; // æ£€æŸ¥ç”¨æˆ·ç¼“å†²åŒºæ˜¯å¦å¯ä»¥è¢«è®¿é—®ï¼Œå¦‚æœä¸å¯è®¿é—®åˆ™è¿”å› -EFAULT é”™è¯¯ if (unlikely(!access_ok(buf, count))) return -EFAULT; // éªŒè¯è¯»å–åŒºåŸŸæ˜¯å¦åˆæ³•ï¼Œå¦‚æœä¸åˆæ³•åˆ™è¿”å›é”™è¯¯ ret = rw_verify_area(READ, file, pos, count); if (ret) return ret; // å¦‚æœè¦è¯»å–çš„å­—èŠ‚æ•°è¶…è¿‡æœ€å¤§å€¼ï¼Œåˆ™å°† count è®¾ç½®ä¸ºæœ€å¤§å€¼ if (count &gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // å¦‚æœæ–‡ä»¶æ“ä½œç»“æ„ä¸­æœ‰ read å‡½æ•°ï¼Œåˆ™è°ƒç”¨å®ƒæ‰§è¡Œè¯»å–æ“ä½œ if (file-&gt;f_op-&gt;read) ret = file-&gt;f_op-&gt;read(file, buf, count, pos); // å¦‚æœæ–‡ä»¶æ“ä½œç»“æ„ä¸­æœ‰ read_iter å‡½æ•°ï¼Œåˆ™è°ƒç”¨ new_sync_read å‡½æ•°æ‰§è¡ŒåŒæ­¥è¯»å–æ“ä½œ else if (file-&gt;f_op-&gt;read_iter) ret = new_sync_read(file, buf, count, pos); // å¦‚æœæ²¡æœ‰é€‚å½“çš„è¯»å–å‡½æ•°ï¼Œåˆ™è¿”å› -EINVAL é”™è¯¯ else ret = -EINVAL; // å¦‚æœè¯»å–æˆåŠŸï¼Œæ‰§è¡Œæ–‡ä»¶è®¿é—®é€šçŸ¥å¹¶æ›´æ–°è¯»å–çš„å­—ç¬¦æ•° if (ret &gt; 0) &#123; fsnotify_access(file); add_rchar(current, ret); &#125; // å¢åŠ ç³»ç»Ÿè°ƒç”¨è®¡æ•° inc_syscr(current); // è¿”å›è¯»å–æ“ä½œçš„ç»“æœï¼ˆå·²è¯»å–çš„å­—èŠ‚æ•°æˆ–é”™è¯¯ä»£ç ï¼‰ return ret;&#125; file-&gt;f_op-&gt;read_iterè®¾ç½®ä¸ºshmem_file_read_iterå‚è€ƒä¸Šæ–‡open = f-&gt;f_op-&gt;openè®¾ç½®ä¸ºgeneric_filp_openå‡½æ•°ï¼ŒåŒç†ï¼Œread_iterè¢«è®¾ç½®ä¸ºshmem_file_read_iter 12345678910111213// å®šä¹‰shmemæ–‡ä»¶ç³»ç»Ÿçš„æ–‡ä»¶æ“ä½œç»“æ„ä½“static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // æ˜ å°„æ–‡ä»¶åˆ°å†…å­˜çš„æ“ä½œ .open = generic_file_open, // æ‰“å¼€æ–‡ä»¶çš„é€šç”¨æ“ä½œ .get_unmapped_area = shmem_get_unmapped_area, // è·å–æœªæ˜ å°„åŒºåŸŸçš„æ“ä½œ#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // é‡å®šä½æ–‡ä»¶è¯»å†™æŒ‡é’ˆçš„æ“ä½œ .read_iter = shmem_file_read_iter, // è¯»å–æ–‡ä»¶çš„æ“ä½œ .write_iter = generic_file_write_iter, // å†™å…¥æ–‡ä»¶çš„é€šç”¨æ“ä½œ .fsync = noop_fsync, // åŒæ­¥æ–‡ä»¶çš„ç©ºæ“ä½œï¼ˆå› ä¸ºshmemæ–‡ä»¶ç³»ç»Ÿä¸éœ€è¦åŒæ­¥ï¼‰ .splice_read = generic_file_splice_read, // ä»æ–‡ä»¶ä¸­è¯»å–å¹¶æ‹¼æ¥æ•°æ®çš„é€šç”¨æ“ä½œ .splice_write = iter_file_splice_write, // å‘æ–‡ä»¶ä¸­æ‹¼æ¥å¹¶å†™å…¥æ•°æ®çš„æ“ä½œ .fallocate = shmem_fallocate, // é¢„åˆ†é…æ–‡ä»¶ç©ºé—´çš„ ç”±äºshmem_fille_operationsæ²¡æœ‰å®šä¹‰read æ ¹æ®å¦‚ä¸‹vfs_readä»£ç  123456789 // å¦‚æœæ–‡ä»¶æ“ä½œç»“æ„ä¸­æœ‰ read å‡½æ•°ï¼Œåˆ™è°ƒç”¨å®ƒæ‰§è¡Œè¯»å–æ“ä½œif (file-&gt;f_op-&gt;read) ret = file-&gt;f_op-&gt;read(file, buf, count, pos);// å¦‚æœæ–‡ä»¶æ“ä½œç»“æ„ä¸­æœ‰ read_iter å‡½æ•°ï¼Œåˆ™è°ƒç”¨ new_sync_read å‡½æ•°æ‰§è¡ŒåŒæ­¥è¯»å–æ“ä½œelse if (file-&gt;f_op-&gt;read_iter) ret = new_sync_read(file, buf, count, pos);// å¦‚æœæ²¡æœ‰é€‚å½“çš„è¯»å–å‡½æ•°ï¼Œåˆ™è¿”å› -EINVAL é”™è¯¯else ret = -EINVAL; ä¸‹é¢ä¼šè°ƒç”¨new_sync_readå‡½æ•° new_sync_readå‡½æ•°new_sync_read identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122// å®šä¹‰ä¸€ä¸ªåŒæ­¥è¯»å–å‡½æ•°ï¼Œç”¨äºä»æ–‡ä»¶ä¸­è¯»å–æ•°æ®åˆ°ç”¨æˆ·ç¼“å†²åŒºstatic ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)&#123; struct kiocb kiocb; // å®šä¹‰ä¸€ä¸ªIOæ§åˆ¶å—ï¼ˆIOCBï¼‰ç»“æ„ä½“å®ä¾‹ struct iov_iter iter; // å®šä¹‰ä¸€ä¸ªIOå‘é‡è¿­ä»£å™¨ï¼ˆç”¨äºæè¿°ç”¨æˆ·ç¼“å†²åŒºï¼‰ ssize_t ret; // ç”¨äºå­˜å‚¨å‡½æ•°è¿”å›å€¼ï¼ˆè¯»å–çš„å­—èŠ‚æ•°ï¼‰ init_sync_kiocb(&amp;kiocb, filp); // ä½¿ç”¨æ–‡ä»¶æŒ‡é’ˆåˆå§‹åŒ–åŒæ­¥IOCB kiocb.ki_pos = (ppos ? *ppos : 0); // è®¾ç½®IOCBçš„æ–‡ä»¶ä½ç½®ï¼ˆå¦‚æœpposéç©ºï¼Œåˆ™ä½¿ç”¨*pposï¼Œå¦åˆ™ä½¿ç”¨0ï¼‰ // åˆå§‹åŒ–IOå‘é‡è¿­ä»£å™¨ï¼Œå°†å…¶ä¸ç”¨æˆ·ç¼“å†²åŒºå…³è” iov_iter_ubuf(&amp;iter, ITER_DEST, buf, len); // è°ƒç”¨æ–‡ä»¶ç³»ç»Ÿçš„read_iteræ–¹æ³•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ï¼Œå¹¶å°†ç»“æœå­˜å‚¨åˆ°retå˜é‡ä¸­ ret = call_read_iter(filp, &amp;kiocb, &amp;iter); BUG_ON(ret == -EIOCBQUEUED); // å¦‚æœè¿”å›å€¼ä¸º-EIOCBQUEUEDï¼Œè§¦å‘å†…æ ¸bugï¼ˆå› ä¸ºè¿™æ˜¯ä¸€ä¸ªåŒæ­¥æ“ä½œï¼‰ if (ppos) // å¦‚æœpposéç©º *ppos = kiocb.ki_pos; // å°†IOCBçš„æ–‡ä»¶ä½ç½®æ›´æ–°åˆ°pposå˜é‡ä¸­ return ret; // è¿”å›è¯»å–çš„å­—èŠ‚æ•°&#125; call_read_iterå‡½æ•°call_read_iter identifier - Linux source code (v6.3.7) - Bootlin 12345static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio, struct iov_iter *iter)&#123; return file-&gt;f_op-&gt;read_iter(kio, iter);&#125; shmem_file_read_iterå‡½æ•°ç”±ä¸Šæ–‡å¯çŸ¥ï¼Œfile-&gt;f_op-&gt;read_iterè®¾ç½®ä¸ºshmem_file_read_read shmem_file_read_iter identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// å®šä¹‰shmemæ–‡ä»¶ç³»ç»Ÿçš„æ–‡ä»¶è¯»å–å‡½æ•°static ssize_t shmem_file_read_iter(struct kiocb *iocb, struct iov_iter *to)&#123; // å®šä¹‰ä¸€äº›å±€éƒ¨å˜é‡ struct file *file = iocb-&gt;ki_filp; struct inode *inode = file_inode(file); struct address_space *mapping = inode-&gt;i_mapping; pgoff_t index; unsigned long offset; int error = 0; ssize_t retval = 0; loff_t *ppos = &amp;iocb-&gt;ki_pos; // è®¡ç®—è¦è¯»å–çš„é¡µç´¢å¼•å’Œé¡µå†…åç§»é‡ index = *ppos &gt;&gt; PAGE_SHIFT; offset = *ppos &amp; ~PAGE_MASK; // å¾ªç¯è¯»å–æ•°æ®ï¼Œç›´åˆ°è¯»å®Œæˆ–å‡ºé”™ for (;;) &#123; struct folio *folio = NULL; struct page *page = NULL; pgoff_t end_index; unsigned long nr, ret; loff_t i_size = i_size_read(inode); // è®¡ç®—æ–‡ä»¶çš„æœ€åä¸€ä¸ªé¡µç´¢å¼• end_index = i_size &gt;&gt; PAGE_SHIFT; if (index &gt; end_index) break; if (index == end_index) &#123; nr = i_size &amp; ~PAGE_MASK; if (nr &lt;= offset) break; &#125; // è·å–æ‰€éœ€é¡µçš„folio error = shmem_get_folio(inode, index, &amp;folio, SGP_READ); if (error) &#123; if (error == -EINVAL) error = 0; break; &#125; if (folio) &#123; folio_unlock(folio); // è·å–æ–‡ä»¶é¡µ page = folio_file_page(folio, index); if (PageHWPoison(page)) &#123; folio_put(folio); error = -EIO; break; &#125; &#125; // è®¡ç®—è¦è¯»å–çš„å­—èŠ‚æ•° nr = PAGE_SIZE; i_size = i_size_read(inode); end_index = i_size &gt;&gt; PAGE_SHIFT; if (index == end_index) &#123; nr = i_size &amp; ~PAGE_MASK; if (nr &lt;= offset) &#123; if (folio) folio_put(folio); break; &#125; &#125; nr -= offset; if (folio) &#123; // å¦‚æœæœ‰å†™å…¥æ˜ å°„ï¼Œåˆ·æ–°æ•°æ®ç¼“å­˜ if (mapping_writably_mapped(mapping)) flush_dcache_page(page); // å¦‚æœè¯»å–é¡µçš„å¼€å§‹ï¼Œæ ‡è®°é¡µä¸ºå·²è®¿é—® if (!offset) folio_mark_accessed(folio); // å°†é¡µçš„å†…å®¹å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ ret = copy_page_to_iter(page, offset, nr, to); folio_put(folio); &#125; else if (user_backed_iter(to)) &#123; // ç”¨é›¶é¡µä»£æ›¿æ¸…ç©ºç”¨æˆ·ç©ºé—´ï¼Œæé«˜æ•ˆç‡ ret = copy_page_to_iter(ZERO_PAGE(0), offset, nr, to); &#125; else &#123; // å¯¹äºç®¡é“ç­‰ï¼Œé¿å…è¿ç»­ä¸¤æ¬¡æäº¤ç›¸åŒçš„é¡µ ret = iov_iter_zero(nr, to); &#125; // æ›´æ–°è¯»å–è®¡æ•°å’Œåç§»é‡ retval += ret; offset += ret; index += offset &gt;&gt; PAGE_SHIFT; offset &amp;= ~PAGE_MASK; // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ•°æ®éœ€è¦è¯»å– if (!iov_iter_count(to)) break; if (ret &lt; nr) &#123; error = -EFAULT; break; &#125; cond_resched(); &#125; // æ›´æ–°æ–‡ä»¶ä½ç½® *ppos = ((loff_t) index &lt;&lt; PAGE_SHIFT) + offset; // æ ‡è®°æ–‡ä»¶è®¿é—® file_accessed(file); // è¿”å›è¯»å–çš„å­—èŠ‚æ•°æˆ–é”™è¯¯ç  return retval ? retval : error;&#125; å†™æ–‡ä»¶writeç³»ç»Ÿè°ƒç”¨sys_write identifier - Linux source code (v6.3.7) - Bootlin 12345SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)&#123; return ksys_write(fd, buf, count);&#125; ksys_writeå‡½æ•°ksys_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)&#123; // å‡½æ•°ç­¾åï¼Œæ¥å—ä¸‰ä¸ªå‚æ•°ï¼šæ–‡ä»¶æè¿°ç¬¦ fdã€ç”¨æˆ·ç©ºé—´ç¼“å†²åŒºçš„æŒ‡é’ˆ buf å’Œè¦å†™å…¥çš„å­—èŠ‚æ•° count struct fd f = fdget_pos(fd); // è·å–ä¸æ–‡ä»¶æè¿°ç¬¦ fd ç›¸å…³è”çš„ struct fd å¯¹è±¡ï¼ˆåŒæ—¶è·å–æ–‡ä»¶å¯¹è±¡å’Œä½ç½®ï¼‰ ssize_t ret = -EBADF; // åˆå§‹åŒ–è¿”å›å€¼ä¸º -EBADFï¼ˆè¡¨ç¤ºæ— æ•ˆçš„æ–‡ä»¶æè¿°ç¬¦ï¼‰ if (f.file) &#123; // å¦‚æœæ–‡ä»¶æè¿°ç¬¦æœ‰æ•ˆï¼ˆå³ f.file é NULLï¼‰ loff_t pos, *ppos = file_ppos(f.file); // è·å–æ–‡ä»¶çš„å½“å‰å†™å…¥ä½ç½® if (ppos) &#123; // å¦‚æœ ppos é NULL pos = *ppos; // ä¿å­˜æ–‡ä»¶çš„å½“å‰å†™å…¥ä½ç½®åˆ° pos ppos = &amp;pos; // ppos æŒ‡å‘ pos çš„åœ°å€ &#125; ret = vfs_write(f.file, buf, count, ppos); // è°ƒç”¨ vfs_write å‡½æ•°è¿›è¡Œå®é™…çš„å†™æ“ä½œï¼Œå¹¶å°†è¿”å›å€¼èµ‹ç»™ ret if (ret &gt;= 0 &amp;&amp; ppos) // å¦‚æœå†™æ“ä½œæˆåŠŸï¼ˆret &gt;= 0ï¼‰ä¸” ppos é NULL f.file-&gt;f_pos = pos; // æ›´æ–°æ–‡ä»¶å¯¹è±¡çš„å†™å…¥ä½ç½® fdput_pos(f); // é‡Šæ”¾ struct fd å¯¹è±¡ï¼ˆå‡å°‘å¼•ç”¨è®¡æ•°ï¼‰ &#125; return ret; // è¿”å›å†™æ“ä½œçš„ç»“æœï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›å†™å…¥çš„å­—èŠ‚æ•°ï¼Œå¦åˆ™è¿”å›ä¸€ä¸ªè´Ÿçš„é”™è¯¯ç &#125; vfs_writeå‡½æ•°vfs_write identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)&#123; // å‡½æ•°ç­¾åï¼Œæ¥å—å››ä¸ªå‚æ•°ï¼šæ–‡ä»¶å¯¹è±¡æŒ‡é’ˆ fileã€ç”¨æˆ·ç©ºé—´ç¼“å†²åŒºçš„æŒ‡é’ˆ bufã€è¦å†™å…¥çš„å­—èŠ‚æ•° count å’Œæ–‡ä»¶å†™å…¥ä½ç½® pos çš„æŒ‡é’ˆ ssize_t ret; // å®šä¹‰è¿”å›å€¼å˜é‡ if (!(file-&gt;f_mode &amp; FMODE_WRITE)) return -EBADF; // å¦‚æœæ–‡ä»¶ä¸å¯å†™ï¼Œè¿”å› -EBADFï¼ˆé”™è¯¯çš„æ–‡ä»¶æè¿°ç¬¦ï¼‰ if (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE)) return -EINVAL; // å¦‚æœæ–‡ä»¶æ¨¡å¼ä¸å…è®¸å†™å…¥ï¼Œè¿”å› -EINVALï¼ˆæ— æ•ˆå‚æ•°ï¼‰ if (unlikely(!access_ok(buf, count))) return -EFAULT; // å¦‚æœç”¨æˆ·ç©ºé—´ç¼“å†²åŒºä¸å¯è®¿é—®ï¼Œè¿”å› -EFAULTï¼ˆé”™è¯¯çš„åœ°å€ï¼‰ ret = rw_verify_area(WRITE, file, pos, count); // éªŒè¯å†™å…¥è¯·æ±‚æ˜¯å¦åˆæ³•ï¼Œå°†ç»“æœèµ‹ç»™ ret if (ret) return ret; // å¦‚æœéªŒè¯ç»“æœä¸ºéé›¶å€¼ï¼ˆé”™è¯¯ï¼‰ï¼Œåˆ™è¿”å›è¯¥å€¼ if (count &gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // å¦‚æœè¦å†™å…¥çš„å­—èŠ‚æ•°å¤§äºæœ€å¤§å…è®¸å€¼ï¼Œåˆ™é™åˆ¶å†™å…¥å­—èŠ‚æ•°ä¸ºæœ€å¤§å…è®¸å€¼ file_start_write(file); // å‡†å¤‡æ–‡ä»¶å¼€å§‹å†™å…¥ if (file-&gt;f_op-&gt;write) ret = file-&gt;f_op-&gt;write(file, buf, count, pos); // å¦‚æœå®šä¹‰äº† write å‡½æ•°ï¼Œè°ƒç”¨å®ƒè¿›è¡Œå®é™…çš„å†™æ“ä½œï¼Œå¹¶å°†è¿”å›å€¼èµ‹ç»™ ret else if (file-&gt;f_op-&gt;write_iter) ret = new_sync_write(file, buf, count, pos); // å¦åˆ™ï¼Œå¦‚æœå®šä¹‰äº† write_iter å‡½æ•°ï¼Œè°ƒç”¨ new_sync_write å‡½æ•°è¿›è¡Œå†™æ“ä½œï¼Œå¹¶å°†è¿”å›å€¼èµ‹ç»™ ret else ret = -EINVAL; // å¦‚æœæ²¡æœ‰å®šä¹‰ write æˆ– write_iter å‡½æ•°ï¼Œè¿”å› -EINVALï¼ˆæ— æ•ˆå‚æ•°ï¼‰ if (ret &gt; 0) &#123; // å¦‚æœå†™æ“ä½œæˆåŠŸï¼ˆret &gt; 0ï¼‰ fsnotify_modify(file); // é€šçŸ¥ç›¸å…³æ–‡ä»¶ç³»ç»Ÿäº‹ä»¶ add_wchar(current, ret); // æ›´æ–°å½“å‰è¿›ç¨‹çš„å†™å…¥å­—ç¬¦è®¡æ•°ï¼ˆå¢åŠ  ret ä¸ªå­—ç¬¦ï¼‰ &#125; inc_syscw(current); // å¢åŠ å½“å‰è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨è®¡æ•° file_end_write(file); // ç»“æŸæ–‡ä»¶å†™å…¥ return ret; // è¿”å›å†™æ“ä½œçš„ç»“æœï¼Œå¦‚æœæˆåŠŸåˆ™è¿”å›å†™å…¥çš„å­—èŠ‚æ•°ï¼Œå¦åˆ™è¿”å›ä¸€ä¸ªè´Ÿçš„é”™è¯¯ç &#125; file-&gt;f_op-&gt;write_iterè®¾ç½®ä¸ºgeneric_file_write_iterå‚è€ƒä¸Šæ–‡ä¸­çš„file-&gt;f_op-&gt;read_iterè®¾ç½®ä¸ºshmem_file_read_iter 12345678910111213// å®šä¹‰shmemæ–‡ä»¶ç³»ç»Ÿçš„æ–‡ä»¶æ“ä½œç»“æ„ä½“static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // æ˜ å°„æ–‡ä»¶åˆ°å†…å­˜çš„æ“ä½œ .open = generic_file_open, // æ‰“å¼€æ–‡ä»¶çš„é€šç”¨æ“ä½œ .get_unmapped_area = shmem_get_unmapped_area, // è·å–æœªæ˜ å°„åŒºåŸŸçš„æ“ä½œ#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // é‡å®šä½æ–‡ä»¶è¯»å†™æŒ‡é’ˆçš„æ“ä½œ .read_iter = shmem_file_read_iter, // è¯»å–æ–‡ä»¶çš„æ“ä½œ .write_iter = generic_file_write_iter, // å†™å…¥æ–‡ä»¶çš„é€šç”¨æ“ä½œ .fsync = noop_fsync, // åŒæ­¥æ–‡ä»¶çš„ç©ºæ“ä½œï¼ˆå› ä¸ºshmemæ–‡ä»¶ç³»ç»Ÿä¸éœ€è¦åŒæ­¥ï¼‰ .splice_read = generic_file_splice_read, // ä»æ–‡ä»¶ä¸­è¯»å–å¹¶æ‹¼æ¥æ•°æ®çš„é€šç”¨æ“ä½œ .splice_write = iter_file_splice_write, // å‘æ–‡ä»¶ä¸­æ‹¼æ¥å¹¶å†™å…¥æ•°æ®çš„æ“ä½œ .fallocate = shmem_fallocate, // é¢„åˆ†é…æ–‡ä»¶ç©ºé—´çš„ å¯ä»¥çœ‹åˆ°write_iterè®¾ç½®ä¸ºgeneric_file_write_iter æ ¹æ®ä¸‹é¢è¿™æ®µvfs_writeä»£ç  123456 if (file-&gt;f_op-&gt;write) ret = file-&gt;f_op-&gt;write(file, buf, count, pos); // å¦‚æœå®šä¹‰äº† write å‡½æ•°ï¼Œè°ƒç”¨å®ƒè¿›è¡Œå®é™…çš„å†™æ“ä½œï¼Œå¹¶å°†è¿”å›å€¼èµ‹ç»™ retelse if (file-&gt;f_op-&gt;write_iter) ret = new_sync_write(file, buf, count, pos); // å¦åˆ™ï¼Œå¦‚æœå®šä¹‰äº† write_iter å‡½æ•°ï¼Œè°ƒç”¨ new_sync_write å‡½æ•°è¿›è¡Œå†™æ“ä½œï¼Œå¹¶å°†è¿”å›å€¼èµ‹ç»™ retelse ret = -EINVAL; // å¦‚æœæ²¡æœ‰å®šä¹‰ write æˆ– write_i å› ä¸ºshmem_file_operationæ²¡æœ‰è®¾ç½®writeå‡½æ•°ï¼Œæ‰€ä»¥ä¸‹é¢è¿›å…¥new_sync_writeå‡½æ•° new_sync_writeå‡½æ•°new_sync_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)&#123; struct kiocb kiocb; struct iov_iter iter; ssize_t ret; init_sync_kiocb(&amp;kiocb, filp); kiocb.ki_pos = (ppos ? *ppos : 0); iov_iter_ubuf(&amp;iter, ITER_SOURCE, (void __user *)buf, len); ret = call_write_iter(filp, &amp;kiocb, &amp;iter); BUG_ON(ret == -EIOCBQUEUED); if (ret &gt; 0 &amp;&amp; ppos) *ppos = kiocb.ki_pos; return ret;&#125; call_write_iterå‡½æ•°call_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio, struct iov_iter *iter)&#123; return file-&gt;f_op-&gt;write_iter(kio, iter);&#125; generic_file_write_iterå‡½æ•° generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728/** * generic_file_write_iter - å°†æ•°æ®å†™å…¥æ–‡ä»¶ * @iocb: IO çŠ¶æ€ç»“æ„ * @from: å¸¦æœ‰è¦å†™å…¥æ•°æ®çš„ iov_iter * * è¿™æ˜¯ä¸€ä¸ªç”¨äºå¤§å¤šæ•°æ–‡ä»¶ç³»ç»Ÿçš„ __generic_file_write_iter() çš„å°è£…ã€‚ * å®ƒè´Ÿè´£åœ¨ O_SYNC æ–‡ä»¶æƒ…å†µä¸‹åŒæ­¥æ–‡ä»¶ï¼Œå¹¶æ ¹æ®éœ€è¦è·å– i_rwsemã€‚ * è¿”å›ï¼š * * å¦‚æœæ²¡æœ‰å†™å…¥ä»»ä½•æ•°æ®æˆ– vfs_fsync_range() åœ¨åŒæ­¥å†™å…¥æ—¶å¤±è´¥ï¼Œåˆ™è¿”å›è´Ÿé”™è¯¯ä»£ç  * * å†™å…¥çš„å­—èŠ‚æ•°ï¼Œå³ä½¿æ˜¯æˆªæ–­å†™å…¥ */ssize_t generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)&#123; struct file *file = iocb-&gt;ki_filp; // ä» kiocb è·å–æ–‡ä»¶æŒ‡é’ˆ struct inode *inode = file-&gt;f_mapping-&gt;host; // ä»æ–‡ä»¶çš„æ˜ å°„ä¸»æœºè·å– inode ssize_t ret; // å£°æ˜ç»“æœçš„è¿”å›å˜é‡ inode_lock(inode); // åœ¨å†™å…¥ä¹‹å‰é”å®š inode ret = generic_write_checks(iocb, from); // æ‰§è¡Œé€šç”¨å†™å…¥æ£€æŸ¥ if (ret &gt; 0) // å¦‚æœæ£€æŸ¥é€šè¿‡ä¸”å…è®¸å†™å…¥ ret = __generic_file_write_iter(iocb, from); // è°ƒç”¨å®é™…çš„æ–‡ä»¶å†™å…¥å‡½æ•° inode_unlock(inode); // å†™å…¥åè§£é” inode if (ret &gt; 0) // å¦‚æœå†™å…¥æˆåŠŸ ret = generic_write_sync(iocb, ret); // å¦‚æœéœ€è¦ï¼ˆä¾‹å¦‚ï¼Œè®¾ç½®äº† O_SYNC æ ‡å¿—ï¼‰ï¼ŒåŒæ­¥å†™å…¥çš„æ•°æ® return ret; // è¿”å›ç»“æœï¼ˆå†™å…¥çš„å­—èŠ‚æ•°æˆ–é”™è¯¯ä»£ç ï¼‰&#125;EXPORT_SYMBOL(generic_file_write_iter); __generic_file_write_iter__generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * __generic_file_write_iter - å°†æ•°æ®å†™å…¥æ–‡ä»¶ * @iocb: IO çŠ¶æ€ç»“æ„ï¼ˆæ–‡ä»¶ï¼Œåç§»ç­‰ï¼‰ * @from: å¸¦æœ‰è¦å†™å…¥æ•°æ®çš„ iov_iter * * æ­¤å‡½æ•°å®Œæˆå®é™…å°†æ•°æ®å†™å…¥æ–‡ä»¶æ‰€éœ€çš„æ‰€æœ‰å·¥ä½œã€‚å®ƒæ‰§è¡Œæ‰€æœ‰åŸºæœ¬æ£€æŸ¥ï¼Œä»æ–‡ä»¶ä¸­åˆ é™¤ SUIDï¼Œ * æ›´æ–°ä¿®æ”¹æ—¶é—´ï¼Œå¹¶æ ¹æ®æˆ‘ä»¬æ‰§è¡Œç›´æ¥ IO è¿˜æ˜¯æ ‡å‡†ç¼“å†²å†™å…¥æ¥è°ƒç”¨é€‚å½“çš„å­ç¨‹åºã€‚ * * é™¤éæˆ‘ä»¬åœ¨å—è®¾å¤‡æˆ–ç±»ä¼¼ä¸éœ€è¦é”å®šçš„å¯¹è±¡ä¸Šå·¥ä½œï¼Œå¦åˆ™æœŸæœ›å·²è·å¾— i_rwsemã€‚ * * æ­¤å‡½æ•°*ä¸*è´Ÿè´£åœ¨ O_SYNC å†™å…¥æ—¶åŒæ­¥æ•°æ®ã€‚è°ƒç”¨è€…å¿…é¡»å¤„ç†å®ƒã€‚è¿™ä¸»è¦æ˜¯å› ä¸ºæˆ‘ä»¬è¦ * é¿å…åœ¨ i_rwsem ä¸‹è¿›è¡ŒåŒæ­¥ã€‚ * * è¿”å›ï¼š * * å†™å…¥çš„å­—èŠ‚æ•°ï¼Œå³ä½¿æ˜¯æˆªæ–­çš„å†™å…¥ * * å¦‚æœæ²¡æœ‰å†™å…¥ä»»ä½•æ•°æ®ï¼Œåˆ™ä¸ºè´Ÿé”™è¯¯ä»£ç  */ssize_t __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)&#123; struct file *file = iocb-&gt;ki_filp; // è·å–æ–‡ä»¶æŒ‡é’ˆ struct address_space *mapping = file-&gt;f_mapping; // è·å–æ–‡ä»¶çš„åœ°å€ç©ºé—´æ˜ å°„ struct inode *inode = mapping-&gt;host; // è·å–æ˜ å°„ä¸»æœºçš„ inode ssize_t written = 0; // åˆå§‹åŒ–å·²å†™å­—èŠ‚æ•°ä¸º 0 ssize_t err; // é”™è¯¯å˜é‡ ssize_t status; // çŠ¶æ€å˜é‡ // æˆ‘ä»¬å¯ä»¥åœ¨é¡µé¢å›æ”¶ä¸­å†™å›æ­¤é˜Ÿåˆ— current-&gt;backing_dev_info = inode_to_bdi(inode); err = file_remove_privs(file); // ç§»é™¤æ–‡ä»¶çš„ç‰¹æƒ if (err) goto out; err = file_update_time(file); // æ›´æ–°æ–‡ä»¶æ—¶é—´ if (err) goto out; if (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123; // å¦‚æœä½¿ç”¨ç›´æ¥ IO loff_t pos, endbyte; written = generic_file_direct_write(iocb, from); // æ‰§è¡Œç›´å†™ /* * å¦‚æœå†™å…¥æœªå®Œæˆï¼Œå›é€€åˆ°ç¼“å†²å†™å…¥ã€‚ä¾‹å¦‚ï¼ŒæŸäº›æ–‡ä»¶ç³»ç»Ÿå¯¹æ´çš„å†™å…¥å°±æ˜¯è¿™æ ·ã€‚ * å¯¹äº DAX æ–‡ä»¶ï¼Œç¼“å†²å†™å…¥å°†æ— æ³•æˆåŠŸï¼ˆå³ä½¿æˆåŠŸï¼ŒDAX ä¹Ÿæ— æ³•æ­£ç¡®å¤„ç†è„çš„ * é¡µé¢ç¼“å­˜é¡µé¢ï¼‰ã€‚ */ if (written &lt; 0 || !iov_iter_count(from) || IS_DAX(inode)) goto out; pos = iocb-&gt;ki_pos; status = generic_perform_write(iocb, from); // æ‰§è¡Œå›å†™ /* * å¦‚æœ generic_perform_write() è¿”å›äº†åŒæ­¥é”™è¯¯ï¼Œåˆ™æˆ‘ä»¬å¸Œæœ›è¿”å›ç›´æ¥å†™å…¥ * çš„å­—èŠ‚æ•°ï¼Œæˆ–è€…å¦‚æœä¸ºé›¶ï¼Œåˆ™è¿”å›é”™è¯¯ä»£ç ã€‚è¯·æ³¨æ„ï¼Œè¿™ä¸æ­£å¸¸çš„ç›´æ¥ IO è¯­ä¹‰ * ä¸åŒï¼Œå³ä½¿å†™å…¥äº†ä¸€äº›å­—èŠ‚ï¼Œä¹Ÿä¼šè¿”å› -EFOOã€‚ */ if (unlikely(status &lt; 0)) &#123; err = status; goto out; &#125; /* * æˆ‘ä»¬éœ€è¦ç¡®ä¿é¡µé¢ç¼“å­˜é¡µé¢è¢«å†™å…¥ç£ç›˜å¹¶å¤±æ•ˆï¼Œä»¥ä¿ç•™é¢„æœŸçš„ O_DIRECT è¯­ä¹‰ã€‚ */ endbyte = pos + status - 1; err = filemap_write_and_wait_range(mapping, pos, endbyte); if (err == 0) &#123; iocb-&gt;ki_pos = endbyte + 1; written += status; invalidate_mapping_pages(mapping, pos &gt;&gt; PAGE_SHIFT, endbyte &gt;&gt; PAGE_SHIFT); &#125; else &#123; /* * æˆ‘ä»¬ä¸çŸ¥é“å†™äº†å¤šå°‘ï¼Œæ‰€ä»¥åªè¿”å›ç›´æ¥å†™å…¥çš„å­—èŠ‚æ•° */ &#125; &#125; else &#123; written = generic_perform_write(iocb, from); // æ‰§è¡Œå›å†™ if (likely(written &gt; 0)) iocb-&gt;ki_pos += written; &#125;out: current-&gt;backing_dev_info = NULL; return written ? written : err;&#125;EXPORT_SYMBOL(__generic_file_write_iter); generic_file_direct_writeå‡½æ•°generic_file_direct_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182ssize_t generic_file_direct_write(struct kiocb *iocb, struct iov_iter *from) &#123; struct file *file = iocb-&gt;ki_filp; //è·å–æ–‡ä»¶å¯¹è±¡ struct address_space *mapping = file-&gt;f_mapping; //è·å–åœ°å€ç©ºé—´ struct inode *inode = mapping-&gt;host; //è·å–ç´¢å¼•èŠ‚ç‚¹å¯¹è±¡ loff_t pos = iocb-&gt;ki_pos; //è·å–å†™å…¥ä½ç½® ssize_t written; size_t write_len; pgoff_t end; write_len = iov_iter_count(from); //è·å–è¦å†™å…¥çš„æ•°æ®é•¿åº¦ end = (pos + write_len - 1) &gt;&gt; PAGE_SHIFT; //è®¡ç®—ç»“æŸé¡µå· if (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123; //å¦‚æœæ˜¯éé˜»å¡IO /* å¦‚æœæœ‰è¦å†™å›çš„é¡µé¢,è¿”å› */ if (filemap_range_has_page(file-&gt;f_mapping, pos, //åˆ¤æ–­èŒƒå›´å†…æ˜¯å¦æœ‰é¡µé¢ pos + write_len - 1)) return -EAGAIN; &#125; else &#123; written = filemap_write_and_wait_range(mapping, pos, //åŒæ­¥æ–‡ä»¶èŒƒå›´å†…çš„é¡µé¢ pos + write_len - 1); if (written) goto out; &#125; /* * åœ¨å†™å…¥å,æˆ‘ä»¬å¸Œæœ›ç¼“å†²è¯»å–ç¡®å®å»ç£ç›˜è·å– * æ–°æ•°æ®ã€‚æˆ‘ä»¬å¤±æ•ˆè¦å†™å…¥åŒºåŸŸçš„å¹²å‡€ç¼“å­˜é¡µé¢ã€‚ * æˆ‘ä»¬åœ¨å†™å…¥ä¹‹å‰è¿™æ ·åš,*ä¹‹å‰*æˆ‘ä»¬å¯ä»¥ä¸ç ´å * -&gt;direct_IO()è¿”å›çš„-EIOCBQUEUEDã€‚ */ written = invalidate_inode_pages2_range(mapping, //å¤±æ•ˆé¡µé¢èŒƒå›´ pos &gt;&gt; PAGE_SHIFT, end); /* * å¦‚æœæ— æ³•ä½¿é¡µé¢æ— æ•ˆ,è¿”å›0ä»¥å›é€€ * åˆ°ç¼“å†²å†™å…¥ã€‚ */ if (written) &#123; if (written == -EBUSY) return 0; goto out; &#125; written = mapping-&gt;a_ops-&gt;direct_IO(iocb, from); //æ‰§è¡Œdirect IOå†™å…¥ /* * æœ€å,å†è¯•ä¸€æ¬¡ä½¿å¹²å‡€é¡µé¢æ— æ•ˆ,è¿™äº›é¡µé¢å¯èƒ½ * è¢«éç›´æ¥è¯»å‰è¯»å…¥é«˜é€Ÿç¼“å­˜,æˆ–è€…å¦‚æœå†™çš„æº * æ˜¯æ–‡ä»¶çš„æ˜ å°„åŒºåŸŸ,åˆ™å¯èƒ½ç”±get_user_pages()å¼•èµ·æ•…éšœã€‚ * å…¶ä¸­ä»»ä½•ä¸€ä¸ªéƒ½æ˜¯ç›¸å½“ç–¯ç‹‚çš„äº‹æƒ…è¦åš, * æ‰€ä»¥æˆ‘ä»¬ä¸å®Œå…¨æ”¯æŒå®ƒã€‚å¦‚æœæ­¤æ— æ•ˆåŒ– * å¤±è´¥,é‚£è¿˜è¡Œ,å†™å…¥ä»ç„¶æœ‰æ•ˆ... * * å¤§å¤šæ•°æ—¶å€™æˆ‘ä»¬ä¸éœ€è¦è¿™ä¹ˆåš,å› ä¸ºdio_complete() * ä¼šä¸ºæˆ‘ä»¬åšæ— æ•ˆåŒ–ã€‚ç„¶è€Œ,æœ‰ä¸€äº›æ–‡ä»¶ç³»ç»Ÿ * æœ€ç»ˆä¸ä¼šè°ƒç”¨dio_complete(),æ‰€ä»¥ä¸è¦é€šè¿‡ * å®Œå…¨åˆ é™¤å®ƒæ¥ç ´åå®ƒä»¬ã€‚ * * æ˜¾è‘—çš„ä¾‹å­æ˜¯blkdev_direct_IO()ã€‚ * * è·³è¿‡å¼‚æ­¥å†™å…¥çš„æ— æ•ˆåŒ–æˆ–å¦‚æœæ˜ å°„æ²¡æœ‰é¡µé¢ã€‚ */ if (written &gt; 0 &amp;&amp; mapping-&gt;nrpages &amp;&amp; invalidate_inode_pages2_range(mapping, pos &gt;&gt; PAGE_SHIFT, end)) dio_warn_stale_pagecache(file); if (written &gt; 0) &#123; pos += written; //æ›´æ–°å†™å…¥ä½ç½® write_len -= written; if (pos &gt; i_size_read(inode) &amp;&amp; !S_ISBLK(inode-&gt;i_mode)) &#123; //æ›´æ–°æ–‡ä»¶å¤§å° i_size_write(inode, pos); mark_inode_dirty(inode); &#125; iocb-&gt;ki_pos = pos; &#125; if (written != -EIOCBQUEUED) iov_iter_revert(from, write_len - iov_iter_count(from)); out: return written; &#125; EXPORT_SYMBOL(generic_file_direct_write); generic_perform_writeå‡½æ•°generic_perform_write identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475ssize_t generic_perform_write(struct kiocb *iocb, struct iov_iter *i)&#123; struct file *file = iocb-&gt;ki_filp; //è·å–æ–‡ä»¶å¯¹è±¡ loff_t pos = iocb-&gt;ki_pos; //è·å–å†™å…¥ä½ç½® struct address_space *mapping = file-&gt;f_mapping; //è·å–åœ°å€ç©ºé—´ const struct address_space_operations *a_ops = mapping-&gt;a_ops; //è·å–åœ°å€ç©ºé—´æ“ä½œ long status = 0; ssize_t written = 0; do &#123; struct page *page; unsigned long offset; /* Offset into pagecache page */ unsigned long bytes; /* Bytes to write to page */ size_t copied; /* Bytes copied from user */ void *fsdata = NULL; offset = (pos &amp; (PAGE_SIZE - 1)); bytes = min_t(unsigned long, PAGE_SIZE - offset, //è®¡ç®—æœ¬æ¬¡è¦å†™å…¥çš„å­—èŠ‚æ•° iov_iter_count(i));again: /* * é¦–å…ˆå¸¦å…¥ç”¨æˆ·é¡µé¢,æˆ‘ä»¬è¦ä»ä¸­å¤åˆ¶ã€‚ * å¦åˆ™,å¦‚æœæœªå°†å…¶æ ‡è®°ä¸ºæœ€æ–°,åˆ™ä¼šå‡ºç°ä» * åŒä¸€é¡µé¢å¤åˆ¶å’Œå†™å…¥çš„å¯æ€•æ­»é”ã€‚ */ if (unlikely(fault_in_iov_iter_readable(i, bytes) == bytes)) &#123; status = -EFAULT; break; &#125; if (fatal_signal_pending(current)) &#123; status = -EINTR; break; &#125; status = a_ops-&gt;write_begin(file, mapping, pos, bytes, //æ‰§è¡Œå†™å¼€å§‹ &amp;page, &amp;fsdata); if (unlikely(status &lt; 0)) break; if (mapping_writably_mapped(mapping)) //åˆ·æ–°é¡µé«˜é€Ÿç¼“å­˜ flush_dcache_page(page); copied = copy_page_from_iter_atomic(page, offset, bytes, i); //ä»è¿­ä»£å™¨å¤åˆ¶æ•°æ®åˆ°é¡µé¢ flush_dcache_page(page); status = a_ops-&gt;write_end(file, mapping, pos, bytes, copied, //æ‰§è¡Œå†™ç»“æŸ page, fsdata); if (unlikely(status != copied)) &#123; iov_iter_revert(i, copied - max(status, 0L)); if (unlikely(status &lt; 0)) break; &#125; cond_resched(); if (unlikely(status == 0)) &#123; /* * çŸ­å¤åˆ¶å¯¼è‡´-&gt;write_end()å®Œå…¨æ‹’ç» * è¯¥äº‹ç‰©ã€‚å¯èƒ½æ˜¯ä¸­é€”çš„å†…å­˜ä¸­æ¯’,å¯èƒ½ä¸munmapçš„ç«äº‰, * å¯èƒ½æ˜¯ä¸¥é‡çš„å†…å­˜å‹åŠ›ã€‚ */ if (copied) bytes = copied; goto again; &#125; pos += status; //æ›´æ–°å†™å…¥ä½ç½® written += status; balance_dirty_pages_ratelimited(mapping); &#125; while (iov_iter_count(i)); return written ? written : status; &#125; EXPORT_SYMBOL(generic_perform_write); åˆ é™¤æ–‡ä»¶unlinkç³»ç»Ÿè°ƒç”¨sys_unlink identifier - Linux source code (v6.3.7) - Bootlin 1234 SYSCALL_DEFINE1(unlink, const char __user *, pathname)&#123; return do_unlinkat(AT_FDCWD, getname(pathname));&#125; do_unlinkatå‡½æ•°do_unlinkat identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * ç¡®ä¿æ–‡ä»¶çš„å®é™…æˆªæ–­å‘ç”Ÿåœ¨å…¶ç›®å½•çš„ i_mutex å¤–éƒ¨ã€‚ * å¦‚æœå‘ç”Ÿå¤§é‡å†™å‡ºï¼Œæˆªæ–­å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œ * æˆ‘ä»¬ä¸å¸Œæœ›åœ¨ç­‰å¾… I/O æ—¶é˜»æ­¢å¯¹ç›®å½•çš„è®¿é—®ã€‚ */int do_unlinkat(int dfd, struct filename *name)&#123; int error; // é”™è¯¯ç  struct dentry *dentry; // ç›®å½•é¡¹æŒ‡é’ˆ struct path path; // è·¯å¾„ç»“æ„ä½“ struct qstr last; // æœ€åä¸€ä¸ªè·¯å¾„ç»„ä»¶çš„å­—ç¬¦ä¸² int type; // è·¯å¾„ç±»å‹ struct inode *inode = NULL; // æ–‡ä»¶ inode æŒ‡é’ˆ struct inode *delegated_inode = NULL; // å§”æ‰˜ inode æŒ‡é’ˆ unsigned int lookup_flags = 0; // æŸ¥æ‰¾æ ‡å¿—retry: // é‡è¯•æ ‡ç­¾ error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); // è·å–çˆ¶ç›®å½• if (error) goto exit1; // å¦‚æœå‡ºé”™ï¼Œè·³è½¬åˆ° exit1 error = -EISDIR; // è®¾ç½®é”™è¯¯ç ä¸º -EISDIRï¼ˆæ˜¯ä¸€ä¸ªç›®å½•ï¼‰ if (type != LAST_NORM) // å¦‚æœç±»å‹ä¸æ˜¯ LAST_NORM goto exit2; // è·³è½¬åˆ° exit2 error = mnt_want_write(path.mnt); // æ£€æŸ¥æ˜¯å¦å…è®¸å†™å…¥ if (error) goto exit2; // å¦‚æœå‡ºé”™ï¼Œè·³è½¬åˆ° exit2retry_deleg: // é‡è¯•å§”æ‰˜æ ‡ç­¾ inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); // å¯¹çˆ¶ç›®å½•è¿›è¡ŒåŠ é” dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); // æŸ¥æ‰¾ç›®å½•é¡¹ error = PTR_ERR(dentry); // è·å–é”™è¯¯ç  if (!IS_ERR(dentry)) &#123; // å¦‚æœæ²¡æœ‰é”™è¯¯ // ä¸ºä»€ä¹ˆè¦æ”¾åœ¨è¿™é‡Œï¼Ÿå› ä¸ºæˆ‘ä»¬éœ€è¦æ­£ç¡®çš„é”™è¯¯å€¼ if (last.name[last.len]) goto slashes; // å¦‚æœ last.name[last.len] ä¸ä¸º 0ï¼Œè·³è½¬åˆ° slashes inode = dentry-&gt;d_inode; // è·å–æ–‡ä»¶çš„ inode if (d_is_negative(dentry)) goto slashes; // å¦‚æœç›®å½•é¡¹æ˜¯è´Ÿçš„ï¼Œè·³è½¬åˆ° slashes ihold(inode); // å¢åŠ  inode å¼•ç”¨è®¡æ•° error = security_path_unlink(&amp;path, dentry); // æ£€æŸ¥å®‰å…¨ç­–ç•¥ if (error) goto exit3; // å¦‚æœå‡ºé”™ï¼Œè·³è½¬åˆ° exit3 error = vfs_unlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, &amp;delegated_inode); // åˆ é™¤æ–‡ä»¶é“¾æ¥exit3: dput(dentry); // é‡Šæ”¾ç›®å½•é¡¹ &#125; inode_unlock(path.dentry-&gt;d_inode); // è§£é”çˆ¶ç›®å½• if (inode) iput(inode); // å¦‚æœ inode å­˜åœ¨ï¼Œæˆªæ–­ inode inode = NULL; // å°† inode ç½®ä¸ºç©º if (delegated_inode) &#123; // å¦‚æœå§”æ‰˜ inode å­˜åœ¨ error = break_deleg_wait(&amp;delegated_inode); // ç­‰å¾…å§”æ‰˜ä¸­æ–­ if (!error) goto retry_deleg; // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œè·³è½¬åˆ° retry_deleg &#125; mnt_drop_write(path.mnt); // æ”¾å¼ƒå†™æƒé™exit2: path_put(&amp;path); // é‡Šæ”¾è·¯å¾„ if (retry_estale(error, lookup_flags)) &#123; // å¦‚æœéœ€è¦é‡è¯• lookup_flags |= LOOKUP_REVAL; // æ›´æ–°æŸ¥æ‰¾æ ‡å¿— inode = NULL; // å°† inode ç½®ä¸ºç©º goto retry; // è·³è½¬åˆ° retry &#125;exit1: putname(name); // é‡Šæ”¾æ–‡ä»¶å return error; // è¿”å›é”™è¯¯ç slashes: // slashes æ ‡ç­¾ if (d_is_negative(dentry)) // å¦‚æœç›®å½•é¡¹æ˜¯è´Ÿçš„ error = -ENOENT; // é”™è¯¯ç è®¾ç½®ä¸º -ENOENTï¼ˆæ–‡ä»¶ä¸å­˜åœ¨ï¼‰ else if (d_is_dir(dentry)) // å¦‚æœç›®å½•é¡¹æ˜¯ç›®å½• error = -EISDIR; // é”™è¯¯ç è®¾ç½®ä¸º -EISDIRï¼ˆæ˜¯ä¸€ä¸ªç›®å½•ï¼‰ else error = -ENOTDIR; // é”™è¯¯ç è®¾ç½®ä¸º -ENOTDIRï¼ˆä¸æ˜¯ä¸€ä¸ªç›®å½•ï¼‰ goto exit3; // è·³è½¬åˆ° exit3&#125; vfs_unlinkå‡½æ•°vfs_unlink identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * vfs_unlink - åˆ é™¤æ–‡ä»¶ç³»ç»Ÿå¯¹è±¡çš„é“¾æ¥ * @idmap: æŒ‚è½½ç‚¹çš„ idmap * @dir: çˆ¶ç›®å½• * @dentry: å—å®³è€… * @delegated_inode: å¦‚æœ inode è¢«å§”æ‰˜ï¼Œè¿”å›å—å®³è€… inodeã€‚ * * è°ƒç”¨è€…å¿…é¡»æŒæœ‰ dir-&gt;i_mutexã€‚ * * å¦‚æœ vfs_unlink å‘ç°ä¸€ä¸ªå§”æ‰˜ï¼Œå®ƒå°†è¿”å› -EWOULDBLOCKï¼Œå¹¶ * åœ¨ delegated_inode ä¸­è¿”å›å¯¹ inode çš„å¼•ç”¨ã€‚è°ƒç”¨è€… * åº”è¯¥åœ¨é‚£ä¸ª inode ä¸Šä¸­æ–­å§”æ‰˜å¹¶é‡è¯•ã€‚å› ä¸º * ä¸­æ–­å§”æ‰˜å¯èƒ½éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œè°ƒç”¨è€…åœ¨æ‰§è¡Œæ­¤æ“ä½œä¹‹å‰åº”æ”¾å¼ƒ * dir-&gt;i_mutexã€‚ * * æˆ–è€…ï¼Œè°ƒç”¨è€…å¯ä»¥ä¸º delegated_inode ä¼ é€’ NULLã€‚è¿™å¯èƒ½ * é€‚ç”¨äºæœŸæœ›åº•å±‚æ–‡ä»¶ç³»ç»Ÿä¸æ˜¯ NFS å¯¼å‡ºçš„è°ƒç”¨è€…ã€‚ * * å¦‚æœé€šè¿‡ idmapped æŒ‚è½½æ‰¾åˆ°äº† inodeï¼Œåˆ™å¿…é¡»é€šè¿‡ @idmap ä¼ é€’ vfsmount çš„ idmapã€‚ * è¯¥å‡½æ•°å°†åœ¨æ£€æŸ¥æƒé™ä¹‹å‰æ ¹æ® @idmap æ˜ å°„ inodeã€‚ * åœ¨é idmapped æŒ‚è½½ä¸Šæˆ–è€…å¯¹åŸå§‹ inode æ‰§è¡Œæƒé™æ£€æŸ¥ï¼Œåªéœ€ä¼ é€’ @nop_mnt_idmapã€‚ */int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)&#123; struct inode *target = dentry-&gt;d_inode; // ç›®æ ‡ inode int error = may_delete(idmap, dir, dentry, 0); // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ é™¤ if (error) // å¦‚æœæœ‰é”™è¯¯ return error; // è¿”å›é”™è¯¯ if (!dir-&gt;i_op-&gt;unlink) // å¦‚æœæ²¡æœ‰æä¾› unlink æ“ä½œ return -EPERM; // è¿”å› -EPERMï¼ˆä¸å…è®¸çš„æ“ä½œï¼‰ inode_lock(target); // é”å®šç›®æ ‡ inode if (IS_SWAPFILE(target)) // å¦‚æœç›®æ ‡æ˜¯äº¤æ¢æ–‡ä»¶ error = -EPERM; // è¿”å› -EPERMï¼ˆä¸å…è®¸çš„æ“ä½œï¼‰ else if (is_local_mountpoint(dentry)) // å¦‚æœ dentry æ˜¯æœ¬åœ°æŒ‚è½½ç‚¹ error = -EBUSY; // è¿”å› -EBUSYï¼ˆè®¾å¤‡æˆ–èµ„æºå¿™ï¼‰ else &#123; error = security_inode_unlink(dir, dentry); // æ£€æŸ¥å®‰å…¨ç­–ç•¥ if (!error) &#123; // å¦‚æœæ²¡æœ‰é”™è¯¯ error = try_break_deleg(target, delegated_inode); // å°è¯•ä¸­æ–­å§”æ‰˜ if (error) // å¦‚æœæœ‰é”™è¯¯ goto out; // è·³è½¬åˆ° out error = dir-&gt;i_op-&gt;unlink(dir, dentry); // æ‰§è¡Œ unlink æ“ä½œ if (!error) &#123; // å¦‚æœæ²¡æœ‰é”™è¯¯ dont_mount(dentry); // ä¸è¦æŒ‚è½½ dentry detach_mounts(dentry); // åˆ†ç¦»æŒ‚è½½ç‚¹ &#125; &#125; &#125;out: // out æ ‡ç­¾ inode_unlock(target); // è§£é”ç›®æ ‡ inode // æˆ‘ä»¬ä¸åˆ é™¤ NFS sillyrenamed æ–‡ä»¶çš„ d_delete() - å®ƒä»¬ä»ç„¶å­˜åœ¨ã€‚ if (!error &amp;&amp; dentry-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) &#123; fsnotify_unlink(dir, dentry); // å‘é€æ–‡ä»¶ç³»ç»Ÿé€šçŸ¥ &#125; else if (!error) &#123; fsnotify_link_count(target); // æ›´æ–°é“¾æ¥è®¡æ•° d_delete_notify(dir, dentry); // å‘é€åˆ é™¤é€šçŸ¥ &#125; return error; // è¿”å›é”™è¯¯&#125;EXPORT_SYMBOL(vfs_unlink); dir-&gt;i_op-&gt;unlinkè®¾ç½®ä¸ºshmem_unlinkå‡½æ•° å‚è€ƒä¸Šæ–‡ä¸­çš„inode-&gt;i_op-&gt;lookupå‡½æ•°æŒ‡å‘ simple_lookup() å‡½æ•° 123456789101112131415161718192021222324static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create, .lookup = simple_lookup,//è¿™é‡Œå®šä¹‰äº†lookupå‡½æ•° .link = shmem_link, .unlink = shmem_unlink,//è¿™é‡Œå®šä¹‰äº†unlinkå‡½æ•° .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;; shmem_unlink identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516static int shmem_unlink(struct inode *dir, struct dentry *dentry)&#123; struct inode *inode = d_inode(dentry); // è·å– dentry å¯¹åº”çš„ inode // å¦‚æœ inode çš„é“¾æ¥æ•°å¤§äº 1 ä¸” inode ä¸æ˜¯ç›®å½•ï¼Œåˆ™é‡Šæ”¾ inode if (inode-&gt;i_nlink &gt; 1 &amp;&amp; !S_ISDIR(inode-&gt;i_mode)) shmem_free_inode(inode-&gt;i_sb); dir-&gt;i_size -= BOGO_DIRENT_SIZE; // å‡å°çˆ¶ç›®å½•çš„å¤§å° // æ›´æ–° inode å’Œçˆ¶ç›®å½•çš„ ctime å’Œ mtime ä¸ºå½“å‰æ—¶é—´ inode-&gt;i_ctime = dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(inode); inode_inc_iversion(dir); // å¢åŠ çˆ¶ç›®å½•çš„ i_version drop_nlink(inode); // å‡å°‘ inode çš„é“¾æ¥æ•° dput(dentry); // æ’¤é”€ &quot;create&quot; æ“ä½œçš„è®¡æ•°ï¼Œå®Œæˆæ‰€æœ‰å·¥ä½œ return 0; // è¿”å› 0ï¼Œè¡¨ç¤ºæˆåŠŸ&#125; å‚è€ƒèµ„æ–™ Tmpfs â€” The Linux Kernel documentation â€” Tmpfs â€” Linux å†…æ ¸æ–‡æ¡£ tmpfs - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦ (wikipedia.org) tmpfs - ArchWiki (archlinux.org) GPT-4 Linuxæ“ä½œç³»ç»Ÿå­¦ä¹ ç¬”è®°ï¼ˆåäºŒï¼‰è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ | Ty-Chenâ€™s Home","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"è®ºæ–‡é˜…è¯» How to Get More Value From Your File System Directory Cache","slug":"è®ºæ–‡é˜…è¯»-How-to-Get-More-Value-From-Your-File-System-Directory-Cache","date":"2023-06-08T08:21:52.000Z","updated":"2023-06-11T14:34:56.714Z","comments":true,"path":"2023/06/08/è®ºæ–‡é˜…è¯»-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/","link":"","permalink":"http://example.com/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/","excerpt":"Abstract åº”ç”¨ç¨‹åºç»å¸¸è¯·æ±‚æ–‡ä»¶ç³»ç»Ÿæ“ä½œæ¥éå†æ–‡ä»¶ç³»ç»Ÿç›®å½•æ ‘,ä¾‹å¦‚æ‰“å¼€æ–‡ä»¶æˆ–è¯»å–æ–‡ä»¶å…ƒæ•°æ®ã€‚å› æ­¤,åœ¨å†…å­˜ä¸­ç¼“å­˜æ–‡ä»¶ç³»ç»Ÿç›®å½•ç»“æ„å’Œå…ƒæ•°æ®å¯¹æ“ä½œç³»ç»Ÿå†…æ ¸çš„æ€§èƒ½ä¼˜åŒ–éå¸¸é‡è¦ã€‚ æœ¬æ–‡ç¡®å®šäº†å‡ ä¸ªè®¾è®¡åŸåˆ™,å¯ä»¥åœ¨åº”ç”¨ç¨‹åºå’Œæ–‡ä»¶ç³»ç»Ÿé€æ˜çš„æƒ…å†µä¸‹æ˜¾è‘—æé«˜å‘½ä¸­ç‡å¹¶é™ä½å‘½ä¸­æˆæœ¬ã€‚å…·ä½“è€Œè¨€,æˆ‘ä»¬çš„ç›®å½•ç¼“å­˜è®¾è®¡å¯ä»¥åœ¨æ’å®šæ•°é‡çš„æ•£åˆ—è¡¨æ“ä½œä¸­æŸ¥æ‰¾ç›®å½•,å°†æŸ¥æ‰¾è·¯å¾„ä¸æƒé™æ£€æŸ¥åˆ†ç¦»,å¯¹è®¿é—®æ§åˆ¶æ£€æŸ¥çš„ç»“æœè¿›è¡Œè®°å¿†åŒ–,ä½¿ç”¨ç­¾ååŠ é€ŸæŸ¥æ‰¾,å¹¶é€šè¿‡ç¼“å­˜ç›®å½•å®Œæ•´æ€§é™ä½æœªå‘½ä¸­ç‡ã€‚","text":"Abstract åº”ç”¨ç¨‹åºç»å¸¸è¯·æ±‚æ–‡ä»¶ç³»ç»Ÿæ“ä½œæ¥éå†æ–‡ä»¶ç³»ç»Ÿç›®å½•æ ‘,ä¾‹å¦‚æ‰“å¼€æ–‡ä»¶æˆ–è¯»å–æ–‡ä»¶å…ƒæ•°æ®ã€‚å› æ­¤,åœ¨å†…å­˜ä¸­ç¼“å­˜æ–‡ä»¶ç³»ç»Ÿç›®å½•ç»“æ„å’Œå…ƒæ•°æ®å¯¹æ“ä½œç³»ç»Ÿå†…æ ¸çš„æ€§èƒ½ä¼˜åŒ–éå¸¸é‡è¦ã€‚ æœ¬æ–‡ç¡®å®šäº†å‡ ä¸ªè®¾è®¡åŸåˆ™,å¯ä»¥åœ¨åº”ç”¨ç¨‹åºå’Œæ–‡ä»¶ç³»ç»Ÿé€æ˜çš„æƒ…å†µä¸‹æ˜¾è‘—æé«˜å‘½ä¸­ç‡å¹¶é™ä½å‘½ä¸­æˆæœ¬ã€‚å…·ä½“è€Œè¨€,æˆ‘ä»¬çš„ç›®å½•ç¼“å­˜è®¾è®¡å¯ä»¥åœ¨æ’å®šæ•°é‡çš„æ•£åˆ—è¡¨æ“ä½œä¸­æŸ¥æ‰¾ç›®å½•,å°†æŸ¥æ‰¾è·¯å¾„ä¸æƒé™æ£€æŸ¥åˆ†ç¦»,å¯¹è®¿é—®æ§åˆ¶æ£€æŸ¥çš„ç»“æœè¿›è¡Œè®°å¿†åŒ–,ä½¿ç”¨ç­¾ååŠ é€ŸæŸ¥æ‰¾,å¹¶é€šè¿‡ç¼“å­˜ç›®å½•å®Œæ•´æ€§é™ä½æœªå‘½ä¸­ç‡ã€‚ è¯¥è®¾è®¡å¯ä»¥æ»¡è¶³POSIXã€Linuxå®‰å…¨æ¨¡å—ã€å‘½åç©ºé—´å’Œè£…å…¥åˆ«åç­‰å·®å¼‚æ€§è¦æ±‚çš„ä¸€ç³»åˆ—è¦æ±‚ã€‚è¿™äº›ä¼˜åŒ–å¯¹å®é™…åº”ç”¨ç¨‹åºæ˜¯ä¸€ä¸ªé‡è¦çš„å‡€æ”¹è¿›,ä¾‹å¦‚å¯ä»¥å°†Dovecot IMAPæœåŠ¡å™¨çš„ååé‡æé«˜12%,å¹¶å°†updatedbå®ç”¨ç¨‹åºçš„ååé‡æé«˜29%ã€‚ æ–‡ä»¶ç³»ç»Ÿç›®å½•ç¼“å­˜æ˜¯å°†æ–‡ä»¶ç³»ç»Ÿçš„ç›®å½•ç»“æ„å’Œå…ƒæ•°æ®ä¿¡æ¯ç¼“å­˜åœ¨å†…å­˜ä¸­çš„æŠ€æœ¯ã€‚å®ƒçš„ä¸»è¦ç›®çš„æ˜¯æé«˜æ–‡ä»¶ç³»ç»Ÿæ“ä½œçš„æ€§èƒ½ã€‚ æ–‡ä»¶ç³»ç»Ÿç›®å½•ç¼“å­˜çš„ä¸»è¦æ€æƒ³æ˜¯:åº”ç”¨ç¨‹åºåœ¨è®¿é—®æ–‡ä»¶ç³»ç»Ÿæ—¶,å¤§éƒ¨åˆ†æ“ä½œæ˜¯åœ¨å·²è®¿é—®è¿‡çš„ç›®å½•ä¸‹è¿›è¡Œçš„ã€‚å¦‚æœèƒ½å°†è¿™äº›ç›®å½•ä¿¡æ¯ç¼“å­˜åœ¨å†…å­˜ä¸­,é‚£ä¹ˆåº”ç”¨ç¨‹åºè®¿é—®è¿™äº›ç›®å½•æ—¶å°±ä¸éœ€è¦å†å»å®é™…çš„æ–‡ä»¶ç³»ç»Ÿä¸­åŠ è½½ç›®å½•ä¿¡æ¯,å¯ä»¥ç›´æ¥ä»ç¼“å­˜ä¸­è·å–,è¿™æ ·å¯ä»¥å¤§å¤§å‡å°‘å¯¹æ–‡ä»¶ç³»ç»Ÿçš„è®¿é—®,æé«˜æ€§èƒ½ã€‚ æ–‡ä»¶ç³»ç»Ÿç›®å½•ç¼“å­˜ä¼šç¼“å­˜è¯¸å¦‚: ç›®å½•ç»“æ„:å°†æ•´ä¸ªç›®å½•æ ‘ç¼“å­˜åœ¨å†…å­˜ä¸­,åŒ…æ‹¬å­ç›®å½•,æ–‡ä»¶ç­‰ä¿¡æ¯ã€‚ ç›®å½•å…ƒæ•°æ®:æ¯ä¸ªç›®å½•çš„å…ƒæ•°æ®,å¦‚inodeå·,å¤§å°,æƒé™,æ‰€æœ‰è€…ç­‰ä¿¡æ¯ã€‚ æ–‡ä»¶å…ƒæ•°æ®:æ¯ä¸ªæ–‡ä»¶çš„å…ƒæ•°æ®,å¦‚inodeå·,å¤§å°,æƒé™,æ‰€æœ‰è€…ç­‰ä¿¡æ¯ã€‚ æƒé™ä¿¡æ¯:å·²æ£€æŸ¥è¿‡çš„ç›®å½•å’Œæ–‡ä»¶çš„æƒé™ä¿¡æ¯,é¿å…é‡å¤æ£€æŸ¥ã€‚ ç­¾åä¿¡æ¯:ç›®å½•å’Œæ–‡ä»¶çš„ç­¾å,ç”¨äºåŠ é€ŸæŸ¥æ‰¾ã€‚ é€šè¿‡ç¼“å­˜è¿™äº›ä¿¡æ¯,åº”ç”¨ç¨‹åºå¯ä»¥é¿å…å¤§é‡çš„æ–‡ä»¶ç³»ç»Ÿè®¿é—®,ç›´æ¥ä»ç¼“å­˜ä¸­è·å–éœ€è¦çš„ä¿¡æ¯,ä»è€Œæé«˜æ€§èƒ½ã€‚è¿™å¯¹æ–‡ä»¶ç³»ç»Ÿçš„æ“ä½œå¯†é›†å‹åº”ç”¨ç¨‹åºæœ‰å¾ˆå¤§å¸®åŠ©,å¦‚é‚®ä»¶æœåŠ¡å™¨,æ•°æ®åº“ç­‰ã€‚ æ‰€ä»¥,æ–‡ä»¶ç³»ç»Ÿç›®å½•ç¼“å­˜çš„å…³é”®æ˜¯é€šè¿‡ç¼“å­˜æ¥å‡å°‘æ–‡ä»¶ç³»ç»Ÿè®¿é—®,åœ¨åº”ç”¨ç¨‹åºä¸æ–‡ä»¶ç³»ç»Ÿä¹‹é—´æ·»åŠ ä¸€å±‚ç¼“å­˜,æé«˜æ•´ä½“çš„ç›®å½•æ“ä½œæ€§èƒ½ã€‚è¿™æ˜¯æ“ä½œç³»ç»Ÿåœ¨ç®¡ç†æ–‡ä»¶ç³»ç»Ÿä¸æé«˜æ€§èƒ½æ–¹é¢å¸¸ç”¨çš„ä¸€ç§æŠ€æœ¯æ‰‹æ®µã€‚ åº”ç”¨ç¨‹åºç»å¸¸éœ€è¦éå†æ–‡ä»¶ç³»ç»Ÿç›®å½•æ ‘æ¥è¿›è¡Œæ–‡ä»¶ç³»ç»Ÿæ“ä½œ,å¦‚æ‰“å¼€æ–‡ä»¶æˆ–è¯»å–æ–‡ä»¶å…ƒæ•°æ®ã€‚è¿™éœ€è¦é¢‘ç¹è®¿é—®æ–‡ä»¶ç³»ç»Ÿ,å¯¹æ“ä½œç³»ç»Ÿå†…æ ¸çš„æ€§èƒ½æœ‰å¾ˆå¤§å½±å“ã€‚ å› æ­¤,åœ¨å†…å­˜ä¸­ç¼“å­˜æ–‡ä»¶ç³»ç»Ÿç›®å½•ç»“æ„å’Œå…ƒæ•°æ®ä¿¡æ¯å¯ä»¥æ˜¾è‘—ä¼˜åŒ–æ“ä½œç³»ç»Ÿå†…æ ¸çš„æ€§èƒ½ã€‚è¿™æ˜¯å› ä¸ºåº”ç”¨ç¨‹åºå¯ä»¥ç›´æ¥ä»ç¼“å­˜ä¸­è·å–ä¿¡æ¯,é¿å…è®¿é—®æ–‡ä»¶ç³»ç»Ÿã€‚ æœ¬æ–‡æå‡ºäº†ä¸€äº›ç›®å½•ç¼“å­˜çš„è®¾è®¡åŸåˆ™,å¯ä»¥åœ¨åº”ç”¨ç¨‹åºå’Œæ–‡ä»¶ç³»ç»Ÿä¹‹é—´transparentlyæé«˜å‘½ä¸­ç‡å’Œé™ä½æœªå‘½ä¸­æˆæœ¬ã€‚transparentlyæ„å‘³ç€åº”ç”¨ç¨‹åºä¸éœ€è¦æ”¹å˜ä»£ç ,ç¼“å­˜çš„ä½¿ç”¨å¯¹å…¶é€æ˜ã€‚ ç›®å½•ç¼“å­˜è®¾è®¡ä½¿ç”¨æ•£åˆ—è¡¨åœ¨æ’å®šæ¬¡æ•°çš„æ“ä½œä¸­æŸ¥æ‰¾ç›®å½•,å¯ä»¥åŠ é€Ÿç›®å½•æŸ¥æ‰¾ã€‚æ•£åˆ—è¡¨æ˜¯ä¸€ç§é«˜æ•ˆçš„æ•°æ®ç»“æ„,å¯ä»¥åœ¨å›ºå®šæ¬¡æ•°å†…æŸ¥æ‰¾åˆ°ä¿¡æ¯ã€‚ å°†æŸ¥æ‰¾è·¯å¾„å’Œæƒé™æ£€æŸ¥åˆ†ç¦»,æ„æ€æ˜¯é¦–å…ˆæŸ¥æ‰¾ç›®å½•,ç„¶åå†è¿›è¡Œæƒé™æ£€æŸ¥ã€‚è¿™é¿å…äº†åœ¨æƒé™æ£€æŸ¥æ—¶é‡å¤æŸ¥æ‰¾ç›®å½•,æé«˜æ€§èƒ½ã€‚ å¯¹è®¿é—®æ§åˆ¶æ£€æŸ¥çš„ç»“æœè¿›è¡Œè®°å¿†åŒ–,æ„æ€æ˜¯ç¼“å­˜æ–‡ä»¶æˆ–ç›®å½•çš„æƒé™ä¿¡æ¯,é¿å…ä¸‹æ¬¡å†æ£€æŸ¥,æé«˜æ€§èƒ½ã€‚ ä½¿ç”¨ç­¾ååŠ é€ŸæŸ¥æ‰¾,ä½¿ç”¨ç›®å½•æ–‡ä»¶ç­¾å(å¦‚CRCç )è¿›è¡ŒæŸ¥æ‰¾,é¿å…å­—ç¬¦ä¸²æ¯”å¯¹,åŠ é€ŸæŸ¥æ‰¾ã€‚ é€šè¿‡ç¼“å­˜ç›®å½•å®Œæ•´æ€§é™ä½æœªå‘½ä¸­ç‡,æ„æ€æ˜¯ç¼“å­˜æ•´ä¸ªç›®å½•æ ‘ä¿¡æ¯,ä½¿åº”ç”¨ç¨‹åºå¯ä»¥åœ¨ç¼“å­˜ä¸­å®Œæˆå¤§éƒ¨åˆ†æ“ä½œ,é¿å…è®¿é—®æ–‡ä»¶ç³»ç»Ÿ,å‡å°‘æœªå‘½ä¸­ã€‚ è¯¥è®¾è®¡å¯ä»¥ç¬¦åˆå„ç§è¦æ±‚,å¦‚POSIXã€Linuxå®‰å…¨æ¨¡å—ã€å‘½åç©ºé—´å’Œè£…å…¥åˆ«åç­‰,æ‰€ä»¥å¯ä»¥å¹¿æ³›ä½¿ç”¨ã€‚ è¯¥è®¾è®¡å¯¹å®é™…åº”ç”¨ç¨‹åºæœ‰æ˜æ˜¾æ”¹è¿›,å¯ä»¥æé«˜Dovecot IMAPæœåŠ¡å™¨12%çš„ååé‡,updatedbå·¥å…·29%çš„ååé‡,å±•ç¤ºäº†è¯¥æ–¹æ¡ˆçš„ä¼˜å¼‚æ€§èƒ½ã€‚ Introductionæ“ä½œç³»ç»Ÿå†…æ ¸é€šå¸¸åœ¨è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ(VFS)å±‚ä¸­ç¼“å­˜æ–‡ä»¶ç³»ç»Ÿæ•°æ®å’Œå…ƒæ•°æ®,è¯¥å±‚å°†åº•å±‚æ–‡ä»¶ç³»ç»ŸæŠ½è±¡ä¸ºå¸¸è§API(å¦‚POSIX)ã€‚ æŒ‡Linuxå†…æ ¸ã€‚VFSæ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€å±‚,å®ƒè™šæ‹ŸåŒ–äº†åº•å±‚çš„æ–‡ä»¶ç³»ç»Ÿ,å¦‚ext4ã€xfsç­‰ã€‚VFSå±‚ä¼šç¼“å­˜ä»è¿™äº›åº•å±‚æ–‡ä»¶ç³»ç»Ÿè¯»å–çš„æ•°æ®å’Œå…ƒæ•°æ®(å¦‚æ–‡ä»¶å±æ€§)ã€‚VFSå±‚å¯¹ä¸Šå±‚åº”ç”¨ç¨‹åºæ¥è¯´éšè—äº†åº•å±‚æ–‡ä»¶ç³»ç»Ÿçš„ç»†èŠ‚,å®ƒæä¾›äº†å¸¸ç”¨çš„æ–‡ä»¶ç³»ç»ŸAPI,å¦‚POSIXæ¥å£ã€‚è¿™ä½¿å¾—åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡VFSå±‚è®¿é—®åº•å±‚ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿ,è€Œä¸éœ€è¦å…³å¿ƒå®ƒä»¬çš„å·®å¼‚ã€‚ è®¡ç®—æœºåº•å±‚çš„æŒ‡ä»¤ç³»ç»Ÿæ˜¯ä¸åŒçš„,å¦‚x86å’ŒARMæ¶æ„çš„æŒ‡ä»¤ç³»ç»Ÿä¸åŒã€‚ä½†æˆ‘ä»¬ç¼–ç¨‹æ—¶ä½¿ç”¨çš„æŒ‡ä»¤æ˜¯ä¸€è‡´çš„,å¦‚åŠ æ³•æŒ‡ä»¤éƒ½æ˜¯+,è¿™æ˜¯å› ä¸ºç¼–ç¨‹è¯­è¨€å°†åº•å±‚ä¸åŒçš„æŒ‡ä»¤ç³»ç»Ÿè™šæ‹ŸåŒ–æˆä¸€è‡´çš„æŒ‡ä»¤æ¥å£ã€‚ç¨‹åºå‘˜ä½¿ç”¨è¿™ä¸€æ¥å£,ä¸éœ€è¦å…³å¿ƒåº•å±‚æŒ‡ä»¤çš„å·®å¼‚ã€‚ åŒæ ·,è™šæ‹Ÿæœºå°†ä¸åŒçš„ç‰©ç†è®¡ç®—æœºè™šæ‹ŸåŒ–æˆåŒä¸€é€»è¾‘è®¡ç®—æœº,ä»è€Œè¿è¡Œç›¸åŒçš„æ“ä½œç³»ç»Ÿå’Œåº”ç”¨ç¨‹åºã€‚è™šæ‹Ÿæœºå±è”½äº†åº•å±‚ä¸åŒçš„ç‰©ç†æœº,ä¸ºæœ€ç»ˆç”¨æˆ·æä¾›äº†ç»Ÿä¸€çš„è®¡ç®—æœºæ¥å£ã€‚ æ‰€ä»¥,æ€»ç»“æ¥è¯´,è™šæ‹ŸåŒ–é€šè¿‡æŠ½è±¡å’Œéšè—åº•å±‚çš„å·®å¼‚ä¸å®ç°ç»†èŠ‚,æä¾›äº†æ›´é«˜å±‚çš„ç»Ÿä¸€é€»è¾‘æ¥å£ã€‚è¿™ä½¿å¾—é«˜å±‚ç”¨æˆ·(å¦‚åº”ç”¨ç¨‹åºæˆ–æœ€ç»ˆç”¨æˆ·)æ— éœ€å…³å¿ƒåº•å±‚çš„å¼‚æ„ä¸å¤æ‚æ€§,å¯ä»¥æ›´ç®€å•åœ°ä½¿ç”¨æ¥å£æ‰€æä¾›çš„åŠŸèƒ½ã€‚ VFSå±‚è™šæ‹ŸåŒ–æ–‡ä»¶ç³»ç»Ÿ,å°±æ˜¯é‡‡å–è¿™æ ·çš„æ–¹å¼,å°†ä¸åŒçš„æ–‡ä»¶ç³»ç»ŸæŠ½è±¡æˆç»Ÿä¸€çš„æ–‡ä»¶ç³»ç»Ÿæ¥å£,å±è”½åº•å±‚æ–‡ä»¶ç³»ç»Ÿä¹‹é—´çš„å·®å¼‚,ä¸ºåº”ç”¨ç¨‹åºå’Œç”¨æˆ·æä¾›ç®€å•çš„æ–‡ä»¶ç³»ç»Ÿæ“ä½œæ–¹æ³•ã€‚è¿™æœ‰æ•ˆåœ°éš”ç¦»äº†ä¸Šå±‚çš„Linuxå†…æ ¸ä¸åº”ç”¨ç¨‹åºä¸åº•å±‚å…·ä½“çš„æ–‡ä»¶ç³»ç»Ÿå®ç°ã€‚ POSIXå®šä¹‰äº†ä¸€å¥—ç»Ÿä¸€çš„æ“ä½œç³»ç»Ÿæ¥å£æ ‡å‡†,åŒ…æ‹¬APIã€ç³»ç»Ÿè°ƒç”¨ã€å®ç”¨ç¨‹åºç­‰,ä½¿å¾—åº”ç”¨ç¨‹åºå¯ä»¥åœ¨ä¸åŒçš„æ“ä½œç³»ç»Ÿä¸Šç§»æ¤å’Œè¿è¡Œã€‚Linuxç­‰æ“ä½œç³»ç»Ÿéƒ½å®ç°äº†POSIXæ¥å£,ä½¿å¾—Linuxä¸‹çš„åº”ç”¨ç¨‹åºå¯ä»¥å¾ˆå®¹æ˜“åœ¨å…¶ä»–POSIXå…¼å®¹ç³»ç»Ÿä¸­ä½¿ç”¨ã€‚ VFSå±‚æä¾›çš„POSIXæ¥å£,å°±æ˜¯éµå¾ªPOSIXæ ‡å‡†,å®ç°äº†è¯¸å¦‚openã€readã€forkç­‰æ“ä½œç³»ç»Ÿè°ƒç”¨å’ŒAPI,ä»è€Œå±è”½äº†åº•å±‚æ–‡ä»¶çš„ç³»ç»Ÿå·®å¼‚,ä½¿åº”ç”¨ç¨‹åºå¯ä»¥ç›´æ¥ä½¿ç”¨POSIXæ¥å£è®¿é—®å„ç§æ–‡ä»¶ç³»ç»Ÿã€‚ ç¼“å­˜å±‚å·²ç»æˆä¸ºéšè—æŒä¹…å­˜å‚¨æŠ€æœ¯(å¦‚æœ¬åœ°ç£ç›˜)è®¿é—®å»¶è¿Ÿçš„æ™®éä¼˜åŒ–æ‰‹æ®µã€‚ç›®å½•ç¼“å­˜ä¸ä»…ä»…æ˜¯æ€§èƒ½ä¼˜åŒ–;å®ƒè¿˜ç®€åŒ–äº†å®‰è£…å¤šä¸ªæ–‡ä»¶ç³»ç»Ÿã€ä¸€è‡´çš„æ–‡ä»¶å¥æŸ„è¡Œä¸ºå’Œé«˜çº§å®‰å…¨æ¨¡å‹(å¦‚SELinux)çš„å®ç°ã€‚ ç¼“å­˜å±‚æŒ‡çš„æ˜¯åœ¨ç³»ç»Ÿè®¾è®¡ä¸­åŠ å…¥çš„ç¼“å­˜æœºåˆ¶,ç”¨äºæš‚å­˜æ•°æ®æˆ–è®¡ç®—ç»“æœ,ä»è€Œä¼˜åŒ–æ€§èƒ½ã€‚åœ¨è¿™é‡Œ,ç¼“å­˜å±‚ç‰¹æŒ‡æ“ä½œç³»ç»Ÿåœ¨è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿ(VFS)ä¸å…·ä½“æ–‡ä»¶ç³»ç»Ÿä¹‹é—´åŠ å…¥çš„ç›®å½•ç¼“å­˜æœºåˆ¶ã€‚ç›®å½•ç¼“å­˜ç¼“å­˜äº†æ–‡ä»¶ç³»ç»Ÿçš„ç›®å½•ç»“æ„ã€å…ƒæ•°æ®ä¸è®¿é—®ä¿¡æ¯,ä½¿VFSå±‚å¯ä»¥ç›´æ¥ä»ç¼“å­˜ä¸­è·å–è¿™äº›ä¿¡æ¯,å‡å°‘å¯¹åº•å±‚æ–‡ä»¶ç³»ç»Ÿçš„è®¿é—®,ä¼˜åŒ–æ•´ä½“çš„æ–‡ä»¶ç³»ç»Ÿæ€§èƒ½ã€‚ ç›®å½•ç¼“å­˜å¯ä»¥ç®€åŒ–åœ¨ä¸€ä¸ªç³»ç»Ÿä¸Šå®‰è£…å’Œä½¿ç”¨å¤šä¸ªæ–‡ä»¶ç³»ç»Ÿã€‚å› ä¸ºç›®å½•ç¼“å­˜æŠ½è±¡äº†åº•å±‚æ–‡ä»¶ç³»ç»Ÿçš„å·®å¼‚,ä½¿ä¸Šå±‚å¯ä»¥ä»¥åŒä¸€æ–¹å¼è®¿é—®ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿã€‚ æ–‡ä»¶å¥æŸ„æ˜¯åº”ç”¨ç¨‹åºè®¿é—®æ–‡ä»¶æ—¶ä½¿ç”¨çš„ä¸€ä¸ªæŠ½è±¡æ¥å£ã€‚é€šè¿‡ç›®å½•ç¼“å­˜,åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨ç›¸åŒçš„æ–‡ä»¶å¥æŸ„æ¥å£è®¿é—®ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿ,è€Œä¸éœ€è¦å…³å¿ƒåº•å±‚æ–‡ä»¶ç³»ç»Ÿçš„å·®å¼‚ä¸å®ç°ç»†èŠ‚ã€‚ æ–‡ä»¶å¥æŸ„æ˜¯åº”ç”¨ç¨‹åºè®¿é—®æ–‡ä»¶æ—¶ä½¿ç”¨çš„ä¸€ä¸ªæŠ½è±¡è¡¨ç¤ºã€‚åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡æ–‡ä»¶åæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶,è·å–ä»£è¡¨è¯¥æ–‡ä»¶çš„æ–‡ä»¶å¥æŸ„,ç„¶åä½¿ç”¨æ–‡ä»¶å¥æŸ„å¯¹æ–‡ä»¶è¿›è¡Œå„ç§æ“ä½œ,å¦‚è¯»å†™ç­‰,è€Œä¸å†æŒ‡å®šæ–‡ä»¶åã€‚ ä¸¾ä¸ªä¾‹å­,åœ¨Cè¯­è¨€ä¸­,åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡fopen()å‡½æ•°ä½¿ç”¨æ–‡ä»¶åæ‰“å¼€ä¸€ä¸ªæ–‡ä»¶,è·å–FILEç±»å‹çš„æ–‡ä»¶å¥æŸ„: 1FILE *fp = fopen(&quot;file.txt&quot;, &quot;r&quot;); ç„¶ååº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡æ–‡ä»¶å¥æŸ„fpå¯¹æ–‡ä»¶è¿›è¡Œæ“ä½œ: 123fread(buf, 1, 10, fp); // ä»æ–‡ä»¶è¯»å–10ä¸ªå­—èŠ‚fwrite(buf, 1, 10, fp); // å‘æ–‡ä»¶å†™å…¥10ä¸ªå­—èŠ‚fclose(fp); // å…³é—­æ–‡ä»¶ åœ¨è¿™é‡Œ,FILE *fpå°±æ˜¯æ–‡ä»¶file.txtçš„æ–‡ä»¶å¥æŸ„,åº”ç”¨ç¨‹åºé€šè¿‡å®ƒå¯¹æ–‡ä»¶è¿›è¡Œè®¿é—®,è€Œä¸å†æŒ‡å®šæ–‡ä»¶åã€‚ æ‰€ä»¥,æ–‡ä»¶å¥æŸ„çš„ä½œç”¨æ˜¯: å°†æ–‡ä»¶åœ¨åº”ç”¨ç¨‹åºä¸­çš„è¡¨ç¤ºæŠ½è±¡åŒ–,å±è”½äº†åº•å±‚æ–‡ä»¶çš„å®ç°ç»†èŠ‚ä¸å·®å¼‚ã€‚ ä½¿åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡ç»Ÿä¸€çš„æ–‡ä»¶å¥æŸ„æ¥å£è®¿é—®ä¸åŒçš„æ–‡ä»¶,è€Œä¸éœ€è¦å…³å¿ƒæ¯ç§æ–‡ä»¶å¯¹åº”çš„å®ç°æ–¹æ³•ã€‚ æ–¹ä¾¿åº”ç”¨ç¨‹åºé€šè¿‡æ–‡ä»¶å¥æŸ„å¿«é€Ÿè®¿é—®æ–‡ä»¶,è€Œä¸éœ€è¦åå¤æŒ‡å®šæ–‡ä»¶åã€‚ è¿”å›åˆ°è¿™å¥è¯,å®ƒè¡¨è¾¾çš„æ„æ€æ˜¯:é€šè¿‡ç›®å½•ç¼“å­˜,åº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨åŒæ ·çš„æ–‡ä»¶å¥æŸ„æ¥å£è®¿é—®ä¸åŒç§ç±»çš„æ–‡ä»¶ç³»ç»Ÿ,è€Œä¸éœ€è¦å…³å¿ƒåº•å±‚æ–‡ä»¶ç³»ç»Ÿçš„å·®å¼‚ã€‚è¿™æ˜¯å› ä¸ºç›®å½•ç¼“å­˜æŠ½è±¡äº†åº•å±‚æ–‡ä»¶ç³»ç»Ÿçš„ç»†èŠ‚,ä¸ºåº”ç”¨ç¨‹åºæä¾›äº†ç»Ÿä¸€çš„æ–‡ä»¶è®¿é—®æ¥å£ã€‚ ç›®å½•ç¼“å­˜å¯¹è‰¯å¥½çš„åº”ç”¨ç¨‹åºæ€§èƒ½è‡³å…³é‡è¦ã€‚è®¸å¤šå¸¸è§çš„ç³»ç»Ÿè°ƒç”¨å¿…é¡»å¯¹æ–‡ä»¶è·¯å¾„è¿›è¡Œæ“ä½œ,è¿™éœ€è¦ç›®å½•ç¼“å­˜æŸ¥æ‰¾ã€‚ä¾‹å¦‚,iBenchç³»ç»Ÿè°ƒç”¨è·Ÿè¸ªä¸­çš„10-20%çš„ç³»ç»Ÿè°ƒç”¨æ‰§è¡Œè·¯å¾„æŸ¥æ‰¾ã€‚ è®¸å¤šç³»ç»Ÿè°ƒç”¨ï¼Œå¦‚ï¼šopen\\stat\\unlinkç­‰éƒ½éœ€è¦ä½¿ç”¨æ–‡ä»¶çš„è·¯å¾„ä½œä¸ºå‚æ•°ã€‚è¿™äº›ç³»ç»Ÿè°ƒç”¨åœ¨æ‰§è¡Œæ—¶,éœ€è¦æŸ¥æ‰¾ç›®å½•ä»¥å®šä½æ–‡ä»¶,è¿™éœ€è¦ç›®å½•ç¼“å­˜çš„æ”¯æŒã€‚æœ‰10-20%çš„ç³»ç»Ÿè°ƒç”¨ä¼šæ‰§è¡Œè·¯å¾„æŸ¥æ‰¾ã€‚ å›¾1åˆ—å‡ºäº†å‡ ç§å¸¸è§çš„å‘½ä»¤è¡Œåº”ç”¨ç¨‹åºåœ¨æ‰§è¡ŒåŸºäºè·¯å¾„çš„ç³»ç»Ÿè°ƒç”¨æ—¶èŠ±è´¹çš„æ€»æ‰§è¡Œæ—¶é—´çš„ç™¾åˆ†æ¯”(æœ‰å…³è¿™äº›åº”ç”¨ç¨‹åºå’Œæµ‹è¯•æœºå™¨çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯,è¯·å‚é˜…Â§6)ã€‚æˆ‘ä»¬æ³¨æ„åˆ°,è¿™äº›ç³»ç»Ÿè°ƒç”¨åŒ…æ‹¬è·¯å¾„æŸ¥æ‰¾ä»¥å¤–çš„å·¥ä½œ,è¿™äº›æ•°å­—åŒ…æ‹¬ä¸€äº›æ£€æµ‹å¼€é”€;å°½ç®¡å¦‚æ­¤,é™¤rmå¤–,ç³»ç»Ÿè°ƒç”¨æ—¶é—´å’Œè®¡æ•°ä»¥statå’Œopenä¸ºä¸»,å…¶ä¸­è·¯å¾„æŸ¥æ‰¾æ˜¯æ‰§è¡Œæ—¶é—´çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚å¯¹äºè¿™äº›åº”ç”¨ç¨‹åº,åŸºäºè·¯å¾„çš„ç³»ç»Ÿè°ƒç”¨å æ€»æ‰§è¡Œæ—¶é—´çš„6-54%ã€‚è¿™æ„å‘³ç€é™ä½è·¯å¾„æŸ¥æ‰¾å»¶è¿Ÿæ˜¯å†…æ ¸æé«˜è¿™äº›åº”ç”¨ç¨‹åºæ‰§è¡Œæ—¶é—´çš„æœ€å¤§æœºä¼šä¹‹ä¸€ã€‚ ä¸å¹¸çš„æ˜¯,å³ä½¿ç›®å½•ç¼“å­˜å‘½ä¸­ä¹Ÿæ˜¯æ˜‚è´µçš„â€”â€”æˆ‘ä»¬çš„æµ‹è¯•Linuxç³»ç»Ÿä¸Šçš„statä¸º 0.3-1.1å¾®ç§’,ç›¸æ¯”ä¹‹ä¸‹getppidåªæœ‰0.04å¾®ç§’,4 KBé¢„è¯»åªæœ‰0.3å¾®ç§’ã€‚è¿™ä¸ªé—®é¢˜åœ¨Linuxå†…æ ¸ç¤¾åŒºå°¤å…¶å—åˆ°é‡è§†,è¯¥ç¤¾åŒºå¯¹å…¶ç›®å½•ç¼“å­˜è¿›è¡Œäº†é‡å¤§ä¿®è®¢å’Œè¶Šæ¥è¶Šå¤æ‚çš„ä¼˜åŒ–,ä»¥é™ä½å…¶å‘½ä¸­æˆæœ¬,ä¾‹å¦‚ä»è¯»å–è·¯å¾„ä¸­åˆ é™¤é”æˆ–åœ¨é‡è¯•å¾ªç¯ä¸­ç”¨æ­»é”é¿å…æ›¿æ¢é”å®šé¡ºåºã€‚å›¾2 plottingç›®å½•ç¼“å­˜å‘½ä¸­å»¶è¿Ÿä¸Linuxå‡ ä¸ªç‰ˆæœ¬ä¸­æ›´æ”¹çš„ç›®å½•ç¼“å­˜ä»£ç è¡Œæ•°,ä½¿ç”¨æµ‹è¯•ç³»ç»Ÿä¸Šçš„è·¯å¾„åˆ°inodeæŸ¥æ‰¾å¾®åŸºå‡†ã€‚è¿™äº›åŠªåŠ›å·²å°†å‘½ä¸­å»¶è¿Ÿä»2011å¹´åˆ°2013å¹´æé«˜äº†47%,ä½†åœ¨è¿‡å»ä¸‰å¹´ä¸­å·²åœæ»ä¸å‰ã€‚ é—®é¢˜çš„æ ¹æºä¼¼ä¹æ˜¯POSIXè·¯å¾„æƒé™è¯­ä¹‰è¦æ±‚ä¸è·¯å¾„ç»„ä»¶æ•°é‡çº¿æ€§ç›¸å…³çš„å·¥ä½œ,å¹¶ä¸¥é‡é™åˆ¶å†…æ ¸å¼€å‘äººå‘˜çš„å®ç°é€‰é¡¹ã€‚ä¾‹å¦‚,è¦æ‰“å¼€&#x2F;X&#x2F;Y&#x2F;Zæ–‡ä»¶,å¿…é¡»å¯¹çˆ¶ç›®å½•&#x2F;ã€&#x2F;Xå’Œ&#x2F;X&#x2F;Yæœ‰æœç´¢æƒé™,å¹¶ä¸”æœ‰æƒè®¿é—®æ–‡ä»¶Zã€‚Linuxå®ç°ç®€å•åœ°ä»ä¸Šè‡³ä¸‹éå†ç›®å½•æ ‘ä»¥æ£€æŸ¥æƒé™ã€‚ä¸å¹¸çš„æ˜¯,å½“å…³é”®è·¯å¾„ä»¥æŒ‡é’ˆä¸ºåŸºç¡€çš„æ•°æ®ç»“æ„(åœ¨æŸäº›ä½“ç³»ç»“æ„ä¸ŠåŒ…å«å¤šæ ¸ä¸€è‡´æ€§çš„å†…å­˜å±éšœ)ä¸»å¯¼æ—¶,ç°ä»£CPUæœ€ç»ˆç”±éš¾ä»¥é¢„å–åŠ è½½è€Œåœæ»ã€‚æ­¤å¤–,ç”±äºå¦‚æ­¤å¤šçš„LinuxåŠŸèƒ½æ˜¯å»ºç«‹åœ¨æ­¤è¡Œä¸ºä¹‹ä¸Šçš„,ä¾‹å¦‚Linux å®‰å…¨æ¨¡å—(LSM)ã€å‘½åç©ºé—´å’Œå®‰è£…åˆ«å,æ‰€ä»¥å¦‚æœä¸ç ´åä¸å…¶ä»–Linuxå†…æ ¸åŠŸèƒ½çš„åå‘å…¼å®¹æ€§,ä»»ä½•æ•°æ®ç»“æ„å¢å¼ºä¼¼ä¹éƒ½æ˜¯ä¸å¯èƒ½çš„ã€‚åœ¨ç†è®ºä¸Š,ä¸æ˜æ˜¾æ˜¯å¦æœ‰æ›´å¿«çš„æŸ¥æ‰¾ç®—æ³•(å¦‚å•ä¸€æ•£åˆ—è¡¨æŸ¥æ‰¾)å¯ä»¥æ»¡è¶³è¿™äº›APIè§„èŒƒå’Œå†…æ ¸å†…éƒ¨è¦æ±‚;æ®æˆ‘ä»¬æ‰€çŸ¥,ä»¥å‰æ²¡æœ‰äººå°è¯•è¿‡ã€‚ æœ¬æ–‡æå‡ºäº†ç›®å½•ç¼“å­˜çš„ä¸€ç§åˆ†è§£,å¯ä»¥ä½¿å¤§å¤šæ•°æŸ¥æ‰¾æ“ä½œç”¨å•ä¸ªæ•£åˆ—è¡¨æŸ¥æ‰¾æ‰§è¡Œ(Â§3),ä»¥åŠåŸºäºç¼“å­˜ä¸­å·²æœ‰ä½†æœªæœ‰æ•ˆåˆ©ç”¨çš„ä¿¡æ¯ä¼˜åŒ–ä»¥å‡å°‘æœªå‘½ä¸­ç‡çš„ä¼˜åŒ–(Â§5)ã€‚æˆ‘ä»¬çš„è®¾è®¡é€šè¿‡å‡ ä¸ªå…³é”®æ€§è§è§£ç»´æŒå…¼å®¹æ€§(Â§4),åŒ…æ‹¬å¦‚ä½•å°†è·¯å¾„ç´¢å¼•ä¸æ£€æŸ¥çˆ¶æƒé™åˆ†ç¦»,ä»¥åŠå¦‚ä½•æœ‰æ•ˆå’Œå®‰å…¨åœ°è®°å¿†è®¿é—®æ§åˆ¶æ£€æŸ¥çš„ç»“æœã€‚ ä¸€ç§å°†ç›®å½•ç¼“å­˜åˆ†è§£çš„æ–¹æ¡ˆ,èƒ½ä½¿ç”¨æ•£åˆ—è¡¨æé«˜å¤§å¤šæ•°æŸ¥æ‰¾çš„æ€§èƒ½ã€‚ åŸºäºç›®å½•ç¼“å­˜ä¸­æœªå……åˆ†åˆ©ç”¨çš„ä¿¡æ¯,æå‡ºçš„ä¸€äº›ä¼˜åŒ–æ–¹æ³•,ä»¥å‡å°‘æœªå‘½ä¸­ç‡ã€‚ é€šè¿‡ä¿æŒä¸Linuxå†…æ ¸å…¼å®¹æ€§çš„å‡ ä¸ªå…³é”®è®¾è®¡,å®ç°ä»¥ä¸Šæé«˜æ€§èƒ½å’Œå‡å°‘æœªå‘½ä¸­ç‡çš„æ–¹æ¡ˆã€‚è¿™äº›å…³é”®è®¾è®¡åŒ…æ‹¬åˆ†ç¦»è·¯å¾„ç´¢å¼•å’Œçˆ¶ç›®å½•æƒé™æ£€æŸ¥ã€å®‰å…¨æœ‰æ•ˆåœ°ç¼“å­˜è®¿é—®æ§åˆ¶æ£€æŸ¥ç»“æœç­‰ã€‚ ä½œè€…è®¤ä¸º,è¿™ç§è®¾è®¡å¯ä»¥å¤§å¹…æé«˜ç›®å½•ç¼“å­˜æ€§èƒ½,è§£å†³ç›®å‰Linuxå†…æ ¸ç›®å½•ç¼“å­˜çš„æ€§èƒ½é—®é¢˜ã€‚ æˆ‘ä»¬çš„ä¼˜åŒ–æé«˜äº†é¢‘ç¹æŸ¥æ‰¾æ“ä½œçš„æ€§èƒ½,ä½†å¼•å…¥äº†å‡ ä¸ªæˆæœ¬,è¯¦è§Â§3å’ŒÂ§6,æˆ‘ä»¬è®¤ä¸ºè¿™äº›æˆæœ¬æ˜¯å¯ä»¥æ¥å—çš„,å¹¶ä¸”å¯¹åº”ç”¨ç¨‹åºè€Œè¨€æ˜¯ä¸€ä¸ªå‡€æ”¹è¿›ã€‚ é¦–å…ˆ,è¿™äº›ä¼˜åŒ–ä¼šå‡æ…¢å¯¹ç›®å½•å±‚æ¬¡ç»“æ„çš„ä¸é¢‘ç¹ä¿®æ”¹,å¦‚ç›®å½•çš„é‡å‘½åã€chmodå’Œchownã€‚ç„¶è€Œ,è¿™äº›è¾ƒæ…¢çš„æ“ä½œåœ¨iBenchè·Ÿè¸ªä¸­å ç³»ç»Ÿè°ƒç”¨çš„ä¸åˆ°0.01%ã€‚ å…¶æ¬¡,dcacheçš„å†…å­˜å¼€é”€å¢åŠ ã€‚ ç¬¬ä¸‰,æŸ¥æ‰¾ç”±äºç­¾åå†²çªè€Œæœ‰é”™è¯¯çš„å¯èƒ½æ€§,å¯ä»¥è°ƒæ•´ä¸ºå¯ä»¥å¿½ç•¥ä¸è®¡ä¸”å¤„äºæ•°æ®é‡å¤æ•°æ®åˆ é™¤ç³»ç»Ÿå¹¿æ³›ä½¿ç”¨çš„å¯æ¥å—é˜ˆå€¼å†…ã€‚ åœ¨å›¾2çš„å¾®åŸºå‡†æµ‹è¯•ä¸­,æˆ‘ä»¬çš„ç›®å½•ç¼“å­˜ä¼˜åŒ–æé«˜äº†lookupå»¶è¿Ÿ26%,è¶…è¿‡æœªä¿®æ”¹çš„Linuxã€‚ æœ¬æ–‡è¯æ˜è¿™äº›æŠ€æœ¯å¯ä»¥æé«˜é¢‘ç¹ä½¿ç”¨ç›®å½•ç¼“å­˜çš„åº”ç”¨ç¨‹åºçš„æ€§èƒ½,è€Œå¯¹äºä¸å—ç›Šçš„åº”ç”¨ç¨‹åºçš„å±å®³åˆ™å¾ˆå°ã€‚è¿™äº›å˜åŒ–å°è£…åœ¨VFSä¸­â€”â€”å•ä¸ªæ–‡ä»¶ç³»ç»Ÿä¸å¿…æ›´æ”¹å…¶ä»£ç ã€‚æœ¬æ–‡æè¿°äº†åœ¨Linux 3.14ä¸­å®ç°è¿™äº›æ”¹è¿›çš„åŸå‹ã€‚ç¬¬2èŠ‚è§£é‡Šäº†Mac OS Xã€FreeBSDå’ŒSolarisçš„ç›®å½•ç¼“å­˜ç»“æ„ç›¸å½“ç›¸ä¼¼,è¿™äº›åŸç†åº”è¯¥å…·æœ‰æ™®éæ€§ã€‚ æœ¬æ–‡çš„è´¡çŒ®å¦‚ä¸‹: å¯¹è·¯å¾„æŸ¥æ‰¾æˆæœ¬å’Œæ”¹è¿›ç¼“å­˜å‘½ä¸­å»¶è¿Ÿæœºä¼šçš„æ€§èƒ½åˆ†æã€‚ ç›®å½•ç¼“å­˜è®¾è®¡,é€šè¿‡å¦‚ä¸‹æŠ€æœ¯æ”¹è¿›è·¯å¾„æŸ¥æ‰¾å»¶è¿Ÿ: æŒ‰å®Œæ•´è·¯å¾„ç´¢å¼•ç›®å½•ç¼“å­˜,å°†å¹³å‡æƒ…å†µä¸‹çš„æŸ¥æ‰¾ä»è·¯å¾„ç»„ä»¶æ•°é‡çš„çº¿æ€§å‡å°‘åˆ°å¸¸é‡ã€‚ å‰ç¼€æ£€æŸ¥ç¼“å­˜(PCC),å°†æƒé™æ£€æŸ¥ä¸è·¯å¾„ç¼“å­˜åˆ†ç¦»ã€‚PCCè®°å¿†æƒé™æ£€æŸ¥,ä¸LSMå…¼å®¹ã€‚ ä½¿ç”¨è·¯å¾„ç­¾åå‡å°‘æ£€æŸ¥æ•£åˆ—æ¡¶å†²çªçš„æˆæœ¬ã€‚ è¯†åˆ«åˆ©ç”¨å†…æ ¸å·²ç»æ‹¥æœ‰çš„å…ƒæ•°æ®å‡å°‘æœªå‘½ä¸­ç‡çš„æœºä¼š,å¦‚è·Ÿè¸ªç›®å½•æ˜¯å¦å®Œå…¨åœ¨ç¼“å­˜ä¸­ã€‚ ä»”ç»†å¤„ç†è®¸å¤šå¾®å¦™çš„è¾¹ç¼˜æƒ…å†µ,è¿™äº›æƒ…å†µä¼šé˜»ç¢è¿™äº›æŠ€æœ¯çš„æœºæ¢°åº”ç”¨,ä¾‹å¦‚ä¸ç¬¦å·é“¾æ¥å’ŒLinuxå‘½åç©ºé—´çš„é›†æˆã€‚ è¿™äº›ä¼˜åŒ–çš„å…¨é¢è¯„ä¼°ã€‚ä¾‹å¦‚,æˆ‘ä»¬çš„ä¼˜åŒ–æé«˜äº†Dovecot IMAPæœåŠ¡å™¨çš„ååé‡æœ€é«˜è¾¾12%,updatedbçš„å»¶è¿Ÿæœ€é«˜è¾¾29%ã€‚ Backgroundæœ¬èŠ‚é¦–å…ˆå›é¡¾ç›®å½•ç¼“å­˜å¿…é¡»æ”¯æŒçš„Unixç›®å½•è¯­ä¹‰;ç„¶åè§£é‡Šäº†ç›®å½•ç¼“å­˜æ˜¯å¦‚ä½•åœ¨ç°ä»£æ“ä½œç³»ç»Ÿä¸­å®ç°çš„ï¼ŒåŒ…æ‹¬Linuxã€FreeBSDã€Solarisã€Mac OS Xå’ŒWindowsã€‚ Unix Directory Hierarchy Semanticsç›®å½•ç¼“å­˜æ‰§è¡Œçš„æœ€å¸¸è§æ“ä½œæ˜¯æŸ¥æ‰¾ï¼Œå®ƒå°†è·¯å¾„å­—ç¬¦ä¸²æ˜ å°„åˆ°å†…å­˜ä¸­çš„ç´¢å¼•èŠ‚ç‚¹ç»“æ„ã€‚æŸ¥æ‰¾ç”±æ‰€æœ‰åŸºäºè·¯å¾„çš„ç³»ç»Ÿè°ƒç”¨è°ƒç”¨ï¼ŒåŒ…æ‹¬openã€statå’Œunlinkã€‚æŸ¥æ‰¾åŒ…æ‹¬æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰ä»è¿›ç¨‹çš„æ ¹ç›®å½•æˆ–å½“å‰å·¥ä½œç›®å½•åˆ°æ–‡ä»¶çš„é€‚å½“æœç´¢æƒé™ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºå‰ç¼€æ£€æŸ¥(prefix check)ã€‚ ä¾‹å¦‚ï¼Œä¸ºäº†è®©Aliceè¯»å–/home/ Alice / xï¼Œå¥¹å¿…é¡»å…·æœ‰ç›®å½•/ã€/homeå’Œ/home/ Aliceçš„æœç´¢æƒé™ï¼Œä»¥åŠæ–‡ä»¶xçš„è¯»æƒé™ã€‚ä¸ºäº†èŠ‚çº¦èµ·è§ï¼Œç›®å½•ä¸Šçš„æ‰§è¡Œæƒé™ä½ç¼–ç äº†æœç´¢æƒé™ã€‚**æœç´¢ä¸è¯»æƒé™çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œæœç´¢åªå…è®¸ç”¨æˆ·æŸ¥è¯¢æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œä½†ä¸èƒ½æšä¸¾æ–‡ä»¶çš„å†…å®¹(æš´åŠ›ç ´è§£é™¤å¤–)**ã€‚SELinuxå’Œå…¶ä»–ç»è¿‡å®‰å…¨åŠ å›ºçš„Linuxå˜ä½“å¯ä»¥æ ¹æ®æ‰§è¡Œä½ä¹‹å¤–çš„è®¸å¤šå› ç´ ç¡®å®šæœç´¢æƒé™ï¼Œä¾‹å¦‚è¿›ç¨‹çš„è§’è‰²æˆ–ç›®å½•çš„æ‰©å±•å±æ€§ã€‚ Linux Directory CacheLinuxç›®å½•ç¼“å­˜(dcache)ç¼“å­˜dentry(ç›®å½•æ¡ç›®)ç»“æ„ï¼Œå®ƒå°†è·¯å¾„æ˜ å°„åˆ°æ–‡ä»¶(æˆ–ç›®å½•ã€è®¾å¤‡ç­‰)çš„å†…å­˜inode(å…¶ä»–Unixç³»ç»Ÿå°†ç´¢å¼•èŠ‚ç‚¹çš„vfsçº§è¡¨ç¤ºç§°ä¸ºvnode)ã€‚inodeå­˜å‚¨ä¸æ–‡ä»¶ç›¸å…³çš„å…ƒæ•°æ®ï¼Œå¦‚å¤§å°ã€æƒé™å’Œæ‰€æœ‰æƒï¼Œä»¥åŠæŒ‡å‘ç´¢å¼•å†…å­˜æ–‡ä»¶å†…å®¹çš„åŸºæ•°æ ‘çš„æŒ‡é’ˆã€‚æ¯ä¸ªdentryè‡³å°‘ç”±å››ä¸ªä¸åŒçš„ç»“æ„è·Ÿè¸ª: åˆ†å±‚æ ‘ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªçˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªæœªæ’åºçš„ã€åŒé“¾çš„å­èŠ‚ç‚¹åˆ—è¡¨ã€‚ ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œä»¥çˆ¶èŠ‚ç‚¹è™šæ‹Ÿåœ°å€å’Œæ–‡ä»¶åä¸ºé”®ã€‚ åˆ«ååˆ—è¡¨ï¼Œè·Ÿè¸ªä¸ç»™å®šç´¢å¼•èŠ‚ç‚¹ç›¸å…³è”çš„ç¡¬é“¾æ¥ã€‚ LRUåˆ—è¡¨ï¼Œç”¨äºæ ¹æ®éœ€è¦å‹ç¼©ç¼“å­˜ã€‚ Linuxå°†å‰ç¼€æ£€æŸ¥ä¸æŸ¥æ‰¾æœ¬èº«é›†æˆåœ¨ä¸€èµ·ï¼Œä¸€æ¬¡æœç´¢ä¸€ä¸ªç»„ä»¶çš„è·¯å¾„å’Œæ£€æŸ¥æƒé™ã€‚lookupä¸æ˜¯ç›´æ¥ä½¿ç”¨æ ‘ç»“æ„ï¼Œè€Œæ˜¯ä½¿ç”¨æ•£åˆ—è¡¨æœç´¢æ¯ä¸ªç»„ä»¶ã€‚å¯¹äºè¾ƒå¤§çš„ç›®å½•ï¼Œå“ˆå¸Œè¡¨æŸ¥æ‰¾å°†æ¯”æœç´¢æœªæ’åºçš„å­åˆ—è¡¨å¿«ã€‚åˆ†å±‚æ ‘ç»“æ„çš„ä¸»è¦ç”¨é€”æ˜¯è‡ªåº•å‘ä¸Šé©±é€æ¡ç›®ï¼Œä»¥ç»´æŠ¤éšå¼ä¸å˜æ€§ï¼Œå³ä»»ä½•æ¡ç›®çš„æ‰€æœ‰çˆ¶æ¡ç›®ä¹Ÿå¿…é¡»åœ¨ç¼“å­˜ä¸­ã€‚å°½ç®¡æ‰€æœ‰dentryéƒ½å­˜å‚¨åœ¨æŒ‰è·¯å¾„é”®çš„å“ˆå¸Œè¡¨ä¸­ï¼Œä½†æƒé™æ£€æŸ¥å®ç°åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾æ¯ä¸ªè·¯å¾„ç»„ä»¶ã€‚ Linuxå­˜å‚¨è´Ÿdentry(negative dentries)ï¼Œå®ƒç¼“å­˜å·²çŸ¥æ–‡ä»¶ä¸å­˜åœ¨äºç£ç›˜ä¸Šçš„äº‹å®ã€‚è´Ÿdentriesçš„ä¸€ä¸ªå¸¸è§ç¤ºä¾‹æ˜¯åœ¨ç”±ç¯å¢ƒå˜é‡æŒ‡å®šçš„å¤šä¸ªè·¯å¾„ä¸Šæœç´¢æ–‡ä»¶ï¼Œä¾‹å¦‚LD LIBRARY PATHã€‚ Current dcache optimizations å›¾2æ‰€ç¤ºçš„å¤§éƒ¨åˆ†dcacheä¼˜åŒ–å·¥ä½œéƒ½æ”¹å–„äº†ç¼“å­˜å‘½ä¸­å»¶è¿Ÿï¼Œä¸»è¦æ˜¯é€šè¿‡å‡å°‘ä½¿ç”¨è¯»-å¤åˆ¶æ›´æ–°(RCU)çš„æŸ¥æ‰¾å‡½æ•°ä¸­çš„åŒæ­¥æˆæœ¬ã€‚ RCUæ¶ˆé™¤äº†è¯»æ“ä½œæ‰€éœ€è¦çš„åŸå­æŒ‡ä»¤ã€‚å…¶ä»–Unixç³»ç»Ÿå°†ç´¢å¼•èŠ‚ç‚¹çš„vfsçº§è¡¨ç¤ºç§°ä¸ºvnodeã€‚ é”å®šå’Œå¯¹å•ä¸ªdentryè¿›è¡Œå¼•ç”¨è®¡æ•°ï¼Œå°†ä¸€äº›é¢å¤–çš„å·¥ä½œæ¨åˆ°ä¸ç»å¸¸ä¿®æ”¹ç›®å½•ç»“æ„çš„ä»£ç ä¸Šï¼Œä¾‹å¦‚é‡å‘½åå’Œå–æ¶ˆé“¾æ¥ã€‚ æœ€æ–°çš„Linuxå†…æ ¸åœ¨æ£€æŸ¥è·¯å¾„æƒé™æ—¶ä¹Ÿä½¿ç”¨ä¹è§‚åŒæ­¥ï¼Œä½¿ç”¨åºåˆ—é”(æœ¬è´¨ä¸Šæ˜¯ç‰ˆæœ¬è®¡æ•°å™¨)æ¥æ£€æµ‹å­æ ‘ä½•æ—¶å¯èƒ½ä¸éå†åŒæ—¶å‘ç”Ÿæ›´æ”¹ã€‚å¦‚æœä¹è§‚å¿«é€Ÿè·¯å¾„ç”±äºå¹¶å‘ä¿®æ”¹è€Œå¤±è´¥ï¼Œå†…æ ¸å°†è¿”å›åˆ°ä½¿ç”¨çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹äº¤æ›¿é”å®šçš„æ…¢è·¯å¾„ã€‚ ç”±äºLinuxå¼€å‘äººå‘˜ç¤¾åŒºå·²ç»åœ¨ä¼˜åŒ–å…¶dcacheæ–¹é¢æŠ•å…¥äº†å¤§é‡ç²¾åŠ›ï¼Œå› æ­¤æˆ‘ä»¬åœ¨æœ¬æ–‡ä¸­ä½¿ç”¨Linuxä½œä¸ºæ¡ˆä¾‹ç ”ç©¶ã€‚æœ¬æ–‡ä¸­çš„ä¼˜åŒ–ä¸æ˜¯ç‰¹å®šäºlinuxçš„ï¼Œä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ„å»ºåœ¨å…¶ä»–å†…æ ¸å¯ä»¥é‡‡ç”¨çš„ä¼˜åŒ–ä¹‹ä¸Šã€‚ Other Operating SystemsFreeBSD, OS X, and Solaris.è¿™äº›Unixå˜ä½“éƒ½æœ‰ä¸€ä¸ªç›®å½•ç¼“å­˜ï¼Œå…¶ç»“æ„ç±»ä¼¼äºLinuxçš„[25,28,39]ã€‚æ¯ä¸ªç³»ç»Ÿéƒ½ä½¿ç”¨æ•£åˆ—è¡¨ç»„ç»‡å…¶ç›®å½•ç¼“å­˜ï¼Œæ¯æ¬¡æ£€æŸ¥ä¸€ä¸ªç»„ä»¶çš„è·¯å¾„ï¼Œå¹¶å­˜å‚¨è´Ÿæ¡ç›®ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨FreeBSDä½œä¸ºBSDå®¶æ—çš„ä¸€ä¸ªä»£è¡¨æ€§ä¾‹å­ï¼Œæ ¹æ®æœ€è¿‘çš„è°ƒæŸ¥ï¼Œå®ƒæ˜¯æœ€å—æ¬¢è¿çš„ã€‚OS Xå†…æ ¸é‡‡ç”¨äº†FreeBSDçš„æ–‡ä»¶ç³»ç»Ÿï¼Œå¹¶æ²¡æœ‰å®è´¨æ€§åœ°æ”¹å˜å®ƒä»¬åœ¨ç›®å½•å…ƒæ•°æ®ç¼“å­˜æ–¹é¢çš„è¡Œä¸ºã€‚ Linuxçš„ç‹¬ç‰¹ä¹‹å¤„åœ¨äºï¼Œhitè·¯å¾„é¿å…è°ƒç”¨ä½çº§æ–‡ä»¶ç³»ç»Ÿï¼Œè€Œå…¶ä»–Unixå˜ä½“æ€»æ˜¯è°ƒç”¨ä½çº§æ–‡ä»¶ç³»ç»Ÿã€‚ä½çº§æ–‡ä»¶ç³»ç»Ÿå¯ä»¥é€‰æ‹©é€€å‡ºé»˜è®¤ç»“æ„ï¼Œå¦‚æœå®ƒæœ‰æ›´ä¸“é—¨çš„ç»“æ„ï¼Œæ¯”å¦‚å¤§å‹ç›®å½•ï¼Œæˆ–è€…å®ƒå¯ä»¥ç›´æ¥å®ç°è‡ªå·±çš„æŸ¥æ‰¾å‡½æ•°ã€‚ç›´æ¥ç®¡ç†æ–‡ä»¶ç³»ç»Ÿçš„ç¼“å­˜éƒ¨åˆ†æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºå¯¹ä½çº§æ–‡ä»¶ç³»ç»Ÿä¸å¯è§æŒ‚è½½ç‚¹ã€‚ä¹‹å‰çš„ä¸€äº›ç ”ç©¶å‘ç°è¿™ç§é™åˆ¶å¾ˆéº»çƒ¦ï¼Œç‰¹åˆ«æ˜¯å¯¹äºç½‘ç»œæ–‡ä»¶ç³»ç»Ÿã€‚è¿™äº›Unixå˜ä½“ä¹Ÿæ²¡æœ‰åœ¨ç¼“å­˜ä¸­ä½¿ç”¨ä¹è§‚åŒæ­¥ï¼Œä½†è¿™ä¸æ˜¯åŸºæœ¬çš„ã€‚ Solaris dcacheï¼Œç§°ä¸ºç›´æ¥åç§°æŸ¥æ‰¾ç¼“å­˜(DNLC)ï¼Œå…·æœ‰å¤æ‚çš„ç¼“å­˜ç®¡ç†å¯å‘å¼ï¼Œä¾‹å¦‚åœ¨æ›¿æ¢å†³ç­–ä¸­æƒè¡¡ç›¸å…³æ€§å’Œæ—¶é—´å±€åŸŸæ€§Solarisä¹Ÿæœ‰ä¸€ä¸ªæ¯”FreeBSDæ›´ç®€å•çš„ç¼“å­˜è·¯å¾„å‚è€ƒç®¡ç†ç³»ç»Ÿ(æ›´ç±»ä¼¼äºLinux)ã€‚ WindowsWindowsä¸­çš„å‡ ä¹æ‰€æœ‰çš„æ“ä½œç³»ç»ŸAPIæŠ½è±¡éƒ½ç”±å¯¹è±¡ç®¡ç†å™¨è¡¨ç¤ºã€‚å¯¹è±¡ç®¡ç†å™¨æ˜¯æœ€æ¥è¿‘Unixç›®å½•ç¼“å­˜çš„ç±»æ¯”,å®ƒè·Ÿè¸ªå±‚æ¬¡è·¯å¾„å’Œæƒé™ã€‚ä¸å¹¸çš„æ˜¯,Windowså†…éƒ¨ç»“æ„çš„å…¬å¼€æ–‡æ¡£æœ‰é™,å°¤å…¶æ˜¯å¯¹äºæœªè¢«åŠ¨ç”¨çš„å…ƒæ•°æ®çš„å†…éƒ¨æ•°æ®ç»“æ„å’Œç¼“å­˜ç­–ç•¥,æ‰€ä»¥è¯¦ç»†æ¯”è¾ƒå›°éš¾ã€‚å°½ç®¡å¦‚æ­¤,æˆ‘ä»¬å¯ä»¥æ¯”è¾ƒä¸€äº›é«˜çº§è®¾è®¡é€‰æ‹©çš„å½±å“ã€‚ é¦–å…ˆ,Windowsåªæ”¯æŒä¸€ç§æ ¹æ–‡ä»¶ç³»ç»Ÿæ ¼å¼,å’Œéå¸¸æœ‰é™çš„å…¶ä»–æ–‡ä»¶ç³»ç»Ÿã€‚å› æ­¤,å¯¹æ–‡ä»¶ç³»ç»Ÿå…ƒæ•°æ®çš„ä¸€èˆ¬ç›®çš„çš„å†…å­˜ç»„ç»‡æ²¡æœ‰å¤ªå¤§ä»·å€¼,Windowsæ²¡æœ‰vnodes,dentriesæˆ–å…¶ä»–VFSå±‚é¢çš„æ¦‚æ‹¬ã€‚ç›¸å,ç¼“å­˜ä¸»è¦æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„è´£ä»»,ç£ç›˜å’Œå†…å­˜ç»“æ„å¸ƒå±€å¯èƒ½ç›¸åŒã€‚ ä¸Unixå˜ç§ä¸åŒ,å½“Windowsæ–‡ä»¶ç³»ç»Ÿè·¯å¾„æ²¡æœ‰ç¼“å­˜åœ¨å¯¹è±¡ç®¡ç†å™¨ä¸­æ—¶,åº•å±‚æ–‡ä»¶ç³»ç»Ÿè´Ÿè´£è§£æå®Œæ•´è·¯å¾„,è€Œä¸æ˜¯ä¸€æ¬¡è§£æä¸€ä¸ªç»„ä»¶ã€‚ä¸ºæ­¤,Windows NTä¹Ÿå°†çˆ¶ç›®å½•æƒé™ä¼ æ’­åˆ°æ¯ä¸ªå­ç›®å½•çš„ç£ç›˜å…ƒæ•°æ®,åœ¨åˆ›å»ºæˆ–ä¿®æ”¹æ—¶é—´ã€‚è¿™ç§æ–¹æ³•å¯ä»¥ç›´æ¥æŸ¥æ‰¾,ä½†ä¹Ÿä¼šäº§ç”Ÿä¸€ç‚¹æ˜“ç®¡ç†æ€§é—®é¢˜ã€‚å‡è®¾Aliceä½¿å¥¹çš„ä¸»ç›®å½•å¯¹æ‰€æœ‰äººå¯è¯»:è¿™ä¸ªæ›´æ”¹æ˜¯å¦åº”ä¼ æ’­åˆ°æ‰€æœ‰å­ç›®å½•?ä¸ºäº†å›ç­”è¿™ä¸ªé—®é¢˜,Windowsé‡‡ç”¨ä¸€ä¸ªé”™è¯¯æ˜“å‘ç”Ÿçš„å¯å‘æ³•,ä¸æ”¹å˜æ‰‹åŠ¨ä¿®æ”¹çš„å­æƒé™ã€‚æœ¬æ–‡å±•ç¤ºå¦‚ä½•åœ¨å†…å­˜ä¸­ä¿ç•™ç›´æ¥æŸ¥æ‰¾çš„æ€§èƒ½ä¼˜åŠ¿,è€Œä¸å­˜å‚¨ä¼ æ’­çš„åˆ†å±‚æƒé™åœ¨ç£ç›˜ä¸Šäº§ç”Ÿçš„ç®¡ç†æ€§é—®é¢˜ã€‚ Opportunities for Improvementå›¾3æ˜¾ç¤ºäº†Linuxä¸­è·¯å¾„æŸ¥æ‰¾çš„ä¸»è¦ç»„ä»¶æ‰€èŠ±è´¹çš„æ—¶é—´ï¼Œå…¶ä¸­å››ä¸ªè·¯å¾„çš„é•¿åº¦ä¸æ–­å¢åŠ ã€‚ å¯¹æŸ¥æ‰¾æ—¶é—´çš„ç¬¬ä¸€é˜¶å½±å“æ˜¯è·¯å¾„æœ¬èº«çš„é•¿åº¦ï¼Œå®ƒå†³å®šäº†å¯¹æ¯ä¸ªç»„ä»¶è¿›è¡Œå“ˆå¸Œã€åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾ä»¥åŠå¯¹æ¯ä¸ªç›®å½•çš„ç´¢å¼•èŠ‚ç‚¹æ‰§è¡Œæƒé™æ£€æŸ¥çš„æ¬¡æ•°ã€‚è¿™äº›æˆæœ¬åœ¨è·¯å¾„ç»„ä»¶çš„æ•°é‡ä¸Šæ˜¯çº¿æ€§çš„ã€‚ æœ¬æ–‡ä¸­æè¿°çš„å‘½ä¸­å»¶è¿Ÿä¼˜åŒ–ä½¿å¤§å¤šæ•°è¿™äº›æ“ä½œçš„æ—¶é—´ä¸å˜ï¼Œé™¤äº†æ•£åˆ—ï¼Œå®ƒä»ç„¶æ˜¯è·¯å¾„é•¿åº¦çš„å‡½æ•°ã€‚ Minimizing Hit Latencyæœ¬èŠ‚æè¿°dcacheå‘½ä¸­è·¯å¾„çš„ç®—æ³•æ”¹è¿›ã€‚åœ¨ç¼“å­˜å‘½ä¸­æƒ…å†µä¸‹,æœ€æ˜‚è´µçš„æ“ä½œä¹‹ä¸€æ˜¯æ£€æŸ¥è¿›ç¨‹çš„å‡­æ®æ˜¯å¦å…è®¸è¿›ç¨‹ä»ä¸Šåˆ°ä¸‹æœç´¢dentryè·¯å¾„(ç§°ä¸ºå‰ç¼€æ£€æŸ¥prefix check)ã€‚æœ¬èŠ‚å±•ç¤ºäº†å¦‚ä½•é€šè¿‡ç¼“å­˜å‰ç¼€æ£€æŸ¥ç»“æœæ˜¾ç€é™ä½å‘½ä¸­å»¶è¿Ÿã€‚æœ¬èŠ‚è§£é‡Šäº†ä¼˜åŒ–æ–¹æ¡ˆ,å¦‚ä½•å°†å…¶é›†æˆåˆ°ç°æœ‰çš„Linuxç›®å½•ç¼“å­˜æ¡†æ¶ä¸­,å¦‚ä½•ä½¿è¿™äº›ç¼“å­˜ç»“æœä¸å…¶ä»–æ–‡ä»¶ç³»ç»Ÿæ“ä½œä¿æŒä¸€è‡´,ä»¥åŠå¦‚ä½•ä½¿ç”¨è·¯å¾„ç­¾åè¿›ä¸€æ­¥åŠ é€ŸæŸ¥æ‰¾ã€‚ Caching Prefix Checksåƒè®¸å¤šUnixå˜ä½“ä¸€æ ·ï¼ŒLinuxåœ¨å“ˆå¸Œè¡¨ä¸­å­˜å‚¨ç¼“å­˜çš„è·¯å¾„åˆ°ç´¢å¼•èŠ‚ç‚¹æ˜ å°„(dentry)(Â§2.2)ã€‚è¿™ä¸ªæ•£åˆ—è¡¨ç”±çˆ¶æ¡ç›®çš„è™šæ‹Ÿåœ°å€å’Œä¸‹ä¸€ä¸ªè·¯å¾„ç»„ä»¶å­—ç¬¦ä¸²çš„ç»„åˆä½œä¸ºé”®å€¼ï¼Œå¦‚å›¾4æ‰€ç¤ºã€‚å†…æ ¸å¯¹è±¡çš„è™šæ‹Ÿåœ°å€ä¸ä¼šéšç€æ—¶é—´çš„æ¨ç§»è€Œæ”¹å˜ï¼Œå¹¶ä¸”åœ¨å„ä¸ªè¿›ç¨‹ä¹‹é—´æ˜¯ç›¸åŒçš„ã€‚ åœ¨å®è·µä¸­ï¼Œå‰ç¼€æ£€æŸ¥å…·æœ‰é«˜åº¦çš„ç©ºé—´å’Œæ—¶é—´å±€éƒ¨æ€§ï¼Œéå¸¸é€‚åˆç¼“å­˜ï¼Œå³ä½¿è¿™æ„å‘³ç€å°†ä¸€äº›é¢å¤–çš„å·¥ä½œæ¨åˆ°ä¸ç»å¸¸ä¿®æ”¹çš„ç›®å½•ç»“æ„ä¸Š(ä¾‹å¦‚ï¼Œé‡å‘½åç›®å½•)ã€‚RCUå·²ç»åšäº†è¿™ä¸ªæƒè¡¡(Â§2.2)ã€‚ ä¸ºäº†ç¼“å­˜å‰ç¼€æ£€æŸ¥ç»“æœï¼Œæˆ‘ä»¬å¿…é¡»é¦–å…ˆå°†æŸ¥æ‰¾dentryä¸å‰ç¼€æ£€æŸ¥è§£è€¦ã€‚æˆ‘ä»¬æ·»åŠ äº†ç¬¬äºŒä¸ªç³»ç»ŸèŒƒå›´çš„å“ˆå¸Œè¡¨ï¼Œä¸“é—¨ç”¨äºæŸ¥æ‰¾dentryï¼Œç§°ä¸ºç›´æ¥æŸ¥æ‰¾å“ˆå¸Œè¡¨(DLHT)ã€‚DLHTå­˜å‚¨æœ€è¿‘è®¿é—®çš„æŒ‰å®Œæ•´çš„ã€è§„èŒƒåŒ–çš„è·¯å¾„æ•£åˆ—çš„dentryã€‚dentryé€šå¸¸å­˜åœ¨äºä¸»å“ˆå¸Œè¡¨ä¸­ï¼Œä¹Ÿå¯èƒ½å­˜åœ¨äºDLHTä¸­ã€‚DLHTæ˜¯æƒ°æ€§å¡«å……çš„ï¼Œä¸ºäº†ä¸ç›®å½•æ ‘ä¿®æ”¹ä¿æŒä¸€è‡´ï¼Œæ¡ç›®å¯ä»¥è¢«åˆ é™¤(Â§3.2)ã€‚ æ¯ä¸ªè¿›ç¨‹åœ¨ä¸è¿›ç¨‹å‡­æ®(åœ¨4.1èŠ‚ä¸­è¿›ä¸€æ­¥è®¨è®º)å…³è”çš„å‰ç¼€æ£€æŸ¥ç¼“å­˜(PCC)ä¸­ç¼“å­˜ä»¥å‰å‰ç¼€æ£€æŸ¥çš„ç»“æœ,å¯ä»¥åœ¨å…·æœ‰ç›¸åŒæƒé™çš„è¿›ç¨‹ä¹‹é—´å…±äº«ã€‚PCCæ˜¯ä¸€ä¸ªæ•£åˆ—è¡¨,ç¼“å­˜dentryè™šæ‹Ÿåœ°å€å’Œç‰ˆæœ¬å·(åºåˆ—é”),ç”¨äºæ£€æµ‹é™ˆæ—§æ¡ç›®(3.2èŠ‚)ã€‚å½“å‰ç¼€æ£€æŸ¥é€šè¿‡æ—¶,è¡¨ç¤ºå‡­æ®è¢«å…è®¸è®¿é—®dentry,åˆ™å°†æ¡ç›®æ·»åŠ åˆ°PCC;æ ¹æ®LRUç­–ç•¥æ›¿æ¢æ¡ç›®ã€‚PCCä¸­çš„æœªå‘½ä¸­å¯ä»¥è¡¨ç¤ºæƒé™è¢«æ‹’ç»æˆ–æƒé™æ£€æŸ¥æœ€è¿‘æœªæ‰§è¡Œã€‚ å› æ­¤ï¼Œç»™å®šä»»ä½•è·¯å¾„ï¼Œå†…æ ¸éƒ½æœ‰ä¸€ä¸ªç›´æ¥æŸ¥æ‰¾DLHTä¸­çš„è·¯å¾„çš„å¿«é€Ÿè·¯å¾„ã€‚å¦‚æœå¿«é€Ÿè·¯å¾„åœ¨DLHTä¸­å‘½ä¸­ï¼Œåˆ™åœ¨è¿›ç¨‹çš„PCCä¸­æŸ¥æ‰¾è¯¥é½¿åˆ—ã€‚ å¦‚æœæ‰¾åˆ°PCCæ¡ç›®å¹¶ä¸”ç‰ˆæœ¬è®¡æ•°å™¨ä¸ç¼“å­˜çš„è®¡æ•°å™¨åŒ¹é…ï¼Œåˆ™ä½¿ç”¨ç¼“å­˜çš„å‰ç¼€æ£€æŸ¥ç»“æœã€‚ å¦‚æœDLHTæˆ–PCCä¸­çš„å¿«é€Ÿè·¯å¾„æŸ¥æ‰¾ä¸¢å¤±ï¼Œæˆ–è€…PCCæ¡ç›®ä¸­çš„ç‰ˆæœ¬è®¡æ•°å™¨æ¯”dentryæ›´è€ï¼Œåˆ™ä»£ç å°†è¿”å›åˆ°åŸå§‹çš„LinuxæŸ¥æ‰¾ç®—æ³•(æ…¢è·¯å¾„)ï¼Œåªä½¿ç”¨ä¸»å“ˆå¸Œè¡¨å¹¶ä¸€æ¬¡éå†ä¸€ä¸ªç»„ä»¶ã€‚ åœ¨ç›¸å¯¹è·¯å¾„çš„æƒ…å†µä¸‹ï¼Œä¾‹å¦‚ç›®å½•/home/aliceä¸‹çš„foo/barï¼Œæˆ‘ä»¬æœ‰æ•ˆåœ°å°†ç›¸å¯¹è·¯å¾„å’Œå½“å‰å·¥ä½œç›®å½•çš„è·¯å¾„è¿æ¥èµ·æ¥ã€‚ä¸ºäº†å®ç°ç›¸å¯¹è·¯å¾„ï¼ŒLinuxå·²ç»åœ¨æ¯ä¸ªè¿›ç¨‹æè¿°ç¬¦(ä»»åŠ¡ç»“æ„)ä¸­å­˜å‚¨äº†ä¸€ä¸ªæŒ‡å‘å½“å‰å·¥ä½œç›®å½•æ¡ç›®çš„æŒ‡é’ˆã€‚æˆ‘ä»¬æ²¡æœ‰å¯¹å­—ç¬¦ä¸²è¿›è¡Œè®°å¿†ï¼Œè€Œæ˜¯åœ¨æ¯ä¸ªæ¡ç›®ä¸­å­˜å‚¨å“ˆå¸Œå‡½æ•°çš„ä¸­é—´çŠ¶æ€ï¼Œä»¥ä¾¿å¯ä»¥ä»ä»»ä½•å‰ç¼€æ¢å¤å“ˆå¸Œã€‚ å½“å‰çš„è®¾è®¡åŒ…æ‹¬ä¸¤ç§éå¸¸ç½•è§çš„è¾¹ç¼˜æƒ…å†µã€‚é¦–å…ˆï¼Œå¯ä»¥é‡Šæ”¾dentryå¹¶ä½¿ç”¨é™ˆæ—§çš„PCCæ¡ç›®é‡æ–°åˆ†é…ã€‚æˆ‘ä»¬é€šè¿‡ä½¿ç”¨å•è°ƒé€’å¢çš„ç‰ˆæœ¬å·åˆå§‹åŒ–æ–°åˆ†é…çš„dentryæ¥æ£€æµ‹è¿™ç§æƒ…å†µï¼Œå…è®¸PCCæ¡ç›®åœ¨é‡æ–°åˆ†é…æ—¶æ£€æµ‹è¿‡æ—¶ã€‚é‡Šæ”¾ä¸€ä¸ªç‰™é½¿å°†å®ƒä»DLHTä¸­ç§»é™¤ã€‚å…¶æ¬¡ï¼Œç‰ˆæœ¬å·å¯ä»¥åœ¨æ–°æ¡ç›®æˆ–é‡å‘½åã€chmodæˆ–éç©ºç›®å½•çš„åŸé•‡çš„æ¯2^32æ¬¡åˆå§‹åŒ–ä¹‹åç¯ç»•;æˆ‘ä»¬çš„è®¾è®¡ç›®å‰é€šè¿‡ä½¿æ‰€æœ‰æ´»åŠ¨çš„pccæ— æ•ˆæ¥å¤„ç†å°è£…ã€‚ å›¾5è¯´æ˜äº†å¯¹Linux dentryç»“æ„çš„ä¿®æ”¹ã€‚å¿«é€Ÿdentryå­˜å‚¨ç­¾åã€æ ‡å¿—ã€åºåˆ—è®¡æ•°ã€æŒ‚è½½ç‚¹ã€ç”¨äºç®¡ç†æ·±åº¦ç›®å½•æ¡ç›®çš„åˆ—è¡¨(ç¬¬5.2èŠ‚)ï¼Œä»¥åŠç”¨äºå°†å¿«é€Ÿdentryæ·»åŠ åˆ°DLHT bucketçš„åˆ—è¡¨(å“ˆå¸Œé“¾)ã€‚PCCè¢«æ·»åŠ åˆ°å†…æ ¸å‡­æ®ç»“æ„(struct cred)ä¸­ï¼Œå¹¶å­˜å‚¨ä¸€ä¸ªå¯è°ƒæ•°é‡çš„ç”±æŒ‡é’ˆå’Œåºåˆ—å·ç»„æˆçš„å…ƒç»„;ç”¨64kbçš„PCCå¯¹ç³»ç»Ÿè¿›è¡Œè¯„ä¼°ã€‚ç”±äºæ¯ä¸ªdentryæŒ‡é’ˆçš„æœ€é«˜ä½å’Œæœ€ä½ä½æ˜¯ç›¸åŒçš„ï¼ŒPCCåªå­˜å‚¨å”¯ä¸€çš„æŒ‡é’ˆä½(x86 64 Linuxä¸­çš„8-39ä½)ä»¥èŠ‚çœç©ºé—´ã€‚ Coherence with Permission and Path Changeså½“ç›®å½•æˆ–ç›®å½•ç»“æ„çš„æƒé™è¢«æ›´æ”¹æ—¶(ä¾‹å¦‚ä½¿ç”¨chmodæˆ–rename)ï¼Œä»»ä½•åŒ…å«è¯¥ç›®å½•çš„ç¼“å­˜å‰ç¼€æ£€æŸ¥éƒ½å¿…é¡»æ— æ•ˆã€‚ æˆ‘ä»¬çš„è®¾è®¡é€šè¿‡åœ¨æ›´æ”¹å±‚æ¬¡ç»“æ„ä¹‹å‰ä½¿ç›¸å…³çš„PCCå’ŒDLHTæ¡ç›®å¤±æ•ˆï¼Œé˜²æ­¢è¿‡æ—¶çš„æ…¢è·¯å¾„æŸ¥æ‰¾è¢«é‡æ–°ç¼“å­˜ï¼Œå¹¶åˆ©ç”¨vfsçº§åŒæ­¥æ¥ç¡®ä¿æ­£ç¡®çš„æ…¢è·¯å¾„è¡Œä¸ºï¼Œä»è€Œç¡®ä¿å¹¶å‘æŸ¥æ‰¾å’Œæ›´æ”¹çš„å®‰å…¨æ€§ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬ç¡®ä¿åœ¨æ›´æ”¹ç›®å½•ç»“æ„åï¼Œå¿«é€Ÿè·¯å¾„æŸ¥æ‰¾ä¸èƒ½ä½¿ç”¨é™ˆæ—§çš„æ•°æ®å®Œæˆã€‚ åœ¨å‘ç”Ÿçªå˜(å¦‚é‡å‘½åæˆ–chmod)ä¹‹å‰ï¼Œæ“ä½œå¿…é¡»é€’å½’éå†dcacheä¸­çš„æ‰€æœ‰å­èŠ‚ç‚¹ï¼Œå¹¶å¢åŠ fast_dentryç‰ˆæœ¬è®¡æ•°å™¨(seq)ã€‚ æ¯ä¸ªè¿›ç¨‹çš„PCCä½¿ç”¨fast_dentryç‰ˆæœ¬è®¡æ•°å™¨æ¥æ£€æµ‹æŸ¥æ‰¾æ—¶ç¼“å­˜å‰ç¼€æ£€æŸ¥çš„å˜åŒ–;å¢åŠ æ­¤ç‰ˆæœ¬è®¡æ•°å™¨å°†ä½¿è¯¥æ¡ç›®çš„æ‰€æœ‰PCCé¡¹æ— æ•ˆï¼Œè€Œæ— éœ€ç›´æ¥ä¿®æ”¹æ¯ä¸ªPCCã€‚å¯¹ç›®å½•ç»“æ„çš„æ›´æ”¹(ä¾‹å¦‚ï¼Œmountå’Œrename)ä¹Ÿä¼šä»ç›´æ¥æŸ¥æ‰¾å“ˆå¸Œè¡¨(DLHT)ä¸­åˆ é™¤æ–°æ—§è·¯å¾„ä¸‹çš„dentryã€‚PCCå’ŒDLHTè¡¨é¡¹åœ¨æ…¢è·¯å¾„ä¸Šç¼“æ…¢åœ°é‡æ–°å¡«å……ã€‚ å…¶æ¬¡ï¼Œé€šè¿‡ä½¿ç”¨åŸå­çš„å…¨å±€åºåˆ—è®¡æ•°å™¨(invalidation)ï¼Œæˆ‘ä»¬ç¡®ä¿ä¸èƒ½å°†è¿‡æ—¶çš„æ…¢è·¯å¾„æŸ¥æ‰¾çš„ç»“æœé‡æ–°æ·»åŠ åˆ°DLHTæˆ–PCCä¸­ã€‚åœ¨æ…¢è·¯å¾„éå†ä¹‹å‰å’Œä¹‹åè¯»å–åºåˆ—è®¡æ•°å™¨;åªæœ‰å½“è®¡æ•°å™¨æ²¡æœ‰æ”¹å˜æ—¶ï¼Œç»“æœæ‰è¢«æ·»åŠ åˆ°DLHTå’ŒPCCä¸­ï¼Œè¿™æ„å‘³ç€æ²¡æœ‰å¹¶å‘å…³æœºã€‚ ç¬¬ä¸‰ï¼Œæˆ‘ä»¬ä½¿ç”¨vfsçº§åŒæ­¥æ¥ç¡®ä¿æ…¢è·¯å¾„ä¸çªå˜æ­£ç¡®åŒæ­¥ã€‚ä¾‹å¦‚ï¼Œrenameè·å–å…¨å±€é‡å‘½åé”åºåˆ—é”ï¼Œä»¥åŠæ–°æ—§çˆ¶ç›®å½•ä¸Šçš„æ¯ä¸ªæ¡ç›®é”ã€‚å½“ä½¿ç”¨é‡å‘½åé”è¿›è¡Œå†™æ“ä½œæ—¶ï¼Œæ…¢è·¯å¾„(å³å½“å‰Linuxä»£ç )ä¸Šçš„æ‰€æœ‰æŸ¥æ‰¾éƒ½å¿…é¡»ä»¥ä¸€ç§ä»æ ¹ç›®å½•(æˆ–å½“å‰å·¥ä½œç›®å½•ï¼Œå¯¹äºç›¸å¯¹è·¯å¾„)åˆ°ç›®æ ‡å­ç›®å½•çš„äº¤æ›¿æ–¹å¼é”å®šæ¯ä¸ªæ¡ç›®ã€‚åœ¨é‡å‘½åå®Œæˆä¹‹å‰ï¼Œç›®æ ‡æ¡ç›®ä¸Šçš„é”ä¼šé˜»æ­¢äº¤æ›¿éå†ã€‚æ— æ•ˆè®¡æ•°å™¨é˜²æ­¢ç¼“å­˜åœ¨è·å–dentryé”ä¹‹å‰å·²ç»é€šè¿‡æ­¤ç‚¹çš„æ…¢è·¯å¾„æŸ¥æ‰¾çš„ç»“æœã€‚æˆ‘ä»¬çš„å®ç°éµå¾ªVFSç°æœ‰çš„é”å®šåŸåˆ™æ¥é¿å…æ­»é”;å®ƒæ·»åŠ äº†ç‰ˆæœ¬è®¡æ•°å™¨æ¥æ£€æµ‹ä¸ä¸€è‡´æ€§ï¼Œå¹¶é€€å›åˆ°æ…¢è·¯å¾„ã€‚ å› æ­¤ï¼Œç›¸å…³çš„PCCå’ŒDLHTæ¡ç›®åœ¨é‡å‘½åå¼€å§‹ä¹‹å‰å°±å·²ç»å¤±æ•ˆäº†ï¼Œé˜»æ–­äº†å¿«é€Ÿè·¯å¾„ï¼› æ…¢é€Ÿè·¯å¾„çš„éå†å°†è¢«é˜»æ­¢ï¼Œç›´åˆ°é‡å‘½åå®Œæˆå’Œæ¯ä¸ªæ¡ç›®çš„é”è¢«é‡Šæ”¾ï¼›å¹¶ä¸”ä¸€ä¸ªåºåˆ—è®¡æ•°å™¨ åºåˆ—è®¡æ•°å™¨ç¡®ä¿åªæœ‰è§‚å¯Ÿåˆ°æ–°è·¯å¾„çš„æ…¢é€Ÿè·¯å¾„éå†å¯ä»¥é‡æ–°å¡«å……DLRçš„ è·¯å¾„å¯ä»¥é‡æ–°å¡«å……DLHTå’ŒPCCã€‚è¿™äº›é€’å½’çš„éå†å°†ç›®å½•æƒé™å’Œç»“æ„çš„å˜åŒ–ä»æ’å®šçš„æ—¶é—´è½¬å˜ä¸ºä¸å­æ ‘çš„å¤§å°æˆçº¿æ€§å…³ç³»ã€‚å­æ ‘çš„å¤§å°ã€‚ä½œä¸ºä¸€ä¸ªä¾‹å­ï¼Œé‡å‘½åæˆ–chmodä¸€ä¸ªæœ‰10,000ä¸ªå­ç›®å½•ï¼Œæœ€å¤šæ·±åº¦ä¸º4çš„ç›®å½•éœ€è¦å¤§çº¦éœ€è¦330å¾®ç§’æ¥å®Œæˆã€‚åœ¨æœ€åˆçš„Linuxå†…æ ¸ä¸­ï¼Œé‡å‘½åå’Œchmodå‡ ä¹æ˜¯æ’å®šæ—¶é—´æ“ä½œï¼Œåªéœ€è¦4.5å’Œ1.1å¾®ç§’ã€‚ä¸€äº›åº”ç”¨ç¨‹åºï¼Œå¦‚aptitudeæˆ–rsyncï¼Œä¾é renameæ¥åŸå­åŒ–åœ°æ›¿æ¢ä¸€ä¸ªç›®å½•ï¼Œä½†è¿™åªå å…¶æ€»å·¥ä½œçš„ä¸€å°éƒ¨åˆ†ï¼Œè€Œä¸”æ¯”æŸ¥æ‰¾çš„é¢‘ç‡ä½å‡ ä¸ªæ•°é‡çº§ï¼Œè¿™ä½¿å¾—æ€»ä½“ä¸Šæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æƒè¡¡ã€‚ Directory References Unixçš„è¯­ä¹‰å…è®¸äººä»¬cdè¿›å…¥ä¸€ä¸ªç›®å½•ï¼Œå¹¶åœ¨éšåçš„æƒé™æ”¹å˜åç»§ç»­åœ¨è¯¥ç›®å½•ä¸­å·¥ä½œï¼Œå¦åˆ™å°†ç¦æ­¢è¿›ä¸€æ­¥è®¿é—®ã€‚ä¾‹å¦‚ï¼Œå‡è®¾ä¸€ä¸ªè¿›ç¨‹åœ¨å·¥ä½œç›®å½•&#x2F;foo&#x2F;barä¸­ï¼Œfooçš„æƒé™å‘ç”Ÿäº†å˜åŒ–ï¼Œä½¿å¾—è¯¥è¿›ç¨‹åœ¨æœªæ¥ä¸èƒ½è¿›å…¥barã€‚åªè¦è¯¥è¿›ç¨‹ä¸ç¦»å¼€è¯¥ç›®å½•æˆ–é€€å‡ºï¼Œè¯¥è¿›ç¨‹å°±åº”è¯¥èƒ½å¤Ÿç»§ç»­æ‰“å¼€barä¸‹çš„æ–‡ä»¶ã€‚ç±»ä¼¼çš„è¯­ä¹‰ä¹Ÿé€‚ç”¨äºæ‰“å¼€çš„ç›®å½•æŸ„ã€‚åœ¨æˆ‘ä»¬çš„è®¾è®¡ä¸­ï¼Œè¿™æ ·çš„æƒé™å˜åŒ–æœ€ç»ˆä¼šå¯¼è‡´ä¸€ä¸ªè¢«å°é”çš„PCCæ¡ç›®ï¼Œè€Œå¿«é€Ÿè·¯å¾„æŸ¥è¯¢å°†è¿åé¢„æœŸè¡Œä¸ºã€‚æˆ‘ä»¬çš„è®¾è®¡é€šè¿‡æ£€æŸ¥ æ‰“å¼€çš„å¼•ç”¨åœ¨PCCä¸­æ˜¯å¦ä»ç„¶è¢«å…è®¸ã€‚å¦‚æœPCCæœ‰ä¸€ä¸ª æ›´å¤šçš„æ¡ç›®ï¼Œå°†é˜»æ­¢é‡æ–°æ‰“å¼€è¿™ä¸ªå¥æŸ„ã€æŸ¥è¯¢å°†è¢«å¼ºåˆ¶é‡‡ç”¨æ…¢é€Ÿè·¯å¾„ï¼Œå¹¶ä¸”è¿™ä¸ªé™ˆæ—§çš„ç»“æœä¸ä¼šè¢«æ·»åŠ åˆ°PCCä¸­ã€‚ç»“æœä¸ä¼šè¢«æ·»åŠ åˆ°PCCä¸­ã€‚ Accelerating Lookuos with Signaturesæˆ‘ä»¬ä¼˜åŒ–çš„æŸ¥æ‰¾ä½¿ç”¨240ä½ç­¾åæ¥æœ€å°åŒ–å¯†é’¥æ¯”è¾ƒçš„æˆæœ¬ã€‚Linuxé€šè¿‡é“¾æ¥åœ¨å“ˆå¸Œè¡¨ä¸­æŸ¥æ‰¾dentryã€‚å½“å“ˆå¸Œè¡¨é”®æ˜¯ä¸€ä¸ªç›¸å¯¹è¾ƒçŸ­çš„è·¯å¾„ç»„ä»¶æ—¶ï¼Œç®€å•åœ°æ¯”è¾ƒé”®çš„æˆæœ¬æ˜¯å¯ä»¥æ¥å—çš„ã€‚ä½†æ˜¯ï¼ŒLinuxä¸Šçš„å®Œæ•´è·¯å¾„æœ€å¤šå¯ä»¥æœ‰4,096ä¸ªå­—ç¬¦ï¼Œå³ä½¿æ¯”è¾ƒä¸­ç­‰é•¿åº¦çš„å­—ç¬¦ä¸²ä¹Ÿä¼šæŸå®³ç›´æ¥æŸ¥æ‰¾çš„ç®—æ³•ä¼˜åŠ¿ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ›å»ºè·¯å¾„çš„ç­¾åæ¥é¿å…è¿™ä¸ªå¼€é”€ï¼Œè¿™æ ·å¯ä»¥æœ€å°åŒ–é”®æ¯”è¾ƒçš„å¼€é”€ã€‚ ä½¿ç”¨ç­¾åä¼šå¸¦æ¥å†²çªçš„é£é™©ï¼Œè¿™å¯èƒ½å¯¼è‡´ç³»ç»Ÿå°†è·¯å¾„æ˜ å°„åˆ°é”™è¯¯çš„å…¥å£ã€‚ æˆ‘ä»¬é¦–å…ˆè§£é‡Šç­¾åç¢°æ’å¦‚ä½•åœ¨æˆ‘ä»¬çš„è®¾è®¡ä¸­å¯¼è‡´é—®é¢˜ï¼Œç„¶åè§£é‡Šæ‰€éœ€çš„æŠ—ç¢°æ’å±æ€§ï¼Œæœ€åè§£é‡Šæˆ‘ä»¬å¦‚ä½•é€‰æ‹©ç­¾åå¤§å°ä»¥ä½¿è¿™ç§é£é™©æœ€å°åŒ–ã€‚ Signature collisions å½“ç”¨æˆ·æŸ¥æ‰¾è·¯å¾„æ—¶ï¼Œæˆ‘ä»¬çš„è®¾è®¡é¦–å…ˆè®¡ç®—è§„èŒƒåŒ–è·¯å¾„çš„ç­¾åï¼Œåœ¨å…¨å±€DLHTä¸­æŸ¥æ‰¾æ•£åˆ—ï¼Œå¦‚æœDLHTä¸­æœ‰å‘½ä¸­ï¼Œåˆ™åœ¨æ¯ä¸ªå‡­æ®PCCä¸­æŸ¥æ‰¾dentryå’Œåºåˆ—å·ã€‚ å¦‚æœå…·æœ‰ç›¸åŒç­¾åçš„å¦ä¸€ä¸ªæ–‡ä»¶çš„dentryå·²ç»åœ¨DLHTä¸­ï¼Œå¹¶ä¸”è¯¥dentryåœ¨PCCä¸­ï¼Œåˆ™ç”¨æˆ·å¯èƒ½æ‰“å¼€é”™è¯¯çš„æ–‡ä»¶ã€‚ä¾‹å¦‚ï¼Œå¦‚æœAliceæ‰“å¼€äº†å¸¦æœ‰Xç­¾åçš„æ–‡ä»¶/home/alice/fooï¼Œç„¶åæ‰“å¼€äº†åŒæ ·å¸¦æœ‰Xç­¾åçš„æ–‡ä»¶/home/alice/barï¼Œå¥¹çš„ç¬¬äºŒæ¬¡æ‰“å¼€å®é™…ä¸Šä¼šåˆ›å»ºä¸€ä¸ªæ–‡ä»¶fooçš„å¥æŸ„ã€‚è¿™å°±äº§ç”Ÿäº†ä¸€ç§æ‹…å¿§ï¼Œå³ç”¨æˆ·å¯èƒ½ä¼šç”±äºè‡ªå·±çš„è¿‡é”™è€ŒæŸåè‡ªå·±çš„æ–‡ä»¶ã€‚å¯ä»¥æ ¹æ®ç­¾åå¤§å°å°†æ­¤é£é™©é…ç½®ä¸ºéå¸¸å°(ä¸‹é¢å°†è®¨è®º)ã€‚ ä»»ä½•ä¸æ­£ç¡®çš„æŸ¥æ‰¾ç»“æœå¿…é¡»æ˜¯è¿›ç¨‹(æˆ–å…·æœ‰ç›¸åŒå‡­æ®çš„å¦ä¸€ä¸ªè¿›ç¨‹)æœ‰æƒè®¿é—®çš„æ–‡ä»¶ã€‚è¦ä½¿å¿«é€Ÿè·¯å¾„æŸ¥æ‰¾è¿”å›ä»»ä½•å†…å®¹ï¼Œå¿…é¡»åœ¨ä»»åŠ¡çš„PCCä¸­æœ‰åŒ¹é…çš„dentryæŒ‡é’ˆï¼Œè¯¥PCCå¯¹äºå…·æœ‰ç›¸åŒå‡­æ®çš„ä»»åŠ¡æ˜¯ç§æœ‰çš„ã€‚å› æ­¤ï¼Œç¢°æ’ä¸ä¼šå¯¼è‡´Aliceæ„å¤–æ‰“å¼€å±äºBobçš„å®Œå…¨ä¸ç›¸å…³çš„æ–‡ä»¶ï¼Œå¦åˆ™å¥¹æ— æ³•è®¿é—®è¿™äº›æ–‡ä»¶ã€‚ æˆ‘ä»¬çš„è®¾è®¡æ­£ç¡®åœ°å¤„ç†äº†ä¸¤ä¸ªç”¨æˆ·ä½¿ç”¨ç›¸åŒç­¾åè®¿é—®ä¸åŒæ–‡ä»¶çš„æƒ…å†µï¼Œå› ä¸ºPCCä¸­çš„é”™è¯¯å°†å¯¼è‡´ä¸¤ä¸ªç”¨æˆ·éƒ½é€€å›åˆ°æ…¢è·¯å¾„ã€‚ å‡è®¾Bobå¼€äº†fooï¼Œå®ƒå’ŒAliceçš„é…’å§ç›¸æ’äº†ã€‚å½“Aliceæ‰“å¼€baræ—¶ï¼Œå®ƒçš„ç­¾åå°†åœ¨DLHTä¸­åŒ¹é…ï¼Œä½†åœ¨PCCä¸­ä¼šä¸¢å¤±ã€‚è¿™å°†å¯¼è‡´Aliceçš„æŸ¥æ‰¾ä»¥æ…¢è·¯å¾„é‡æ–°æ‰§è¡Œå‰ç¼€æ£€æŸ¥ï¼Œæœ€ç»ˆæ‰“å¼€æ­£ç¡®çš„æ–‡ä»¶å¹¶å°†æ­¤æ¡ç›®æ·»åŠ åˆ°å¥¹çš„PCCä¸­ã€‚ å› æ­¤ï¼Œå¦‚æœBobæ˜¯å¯¹æŠ—æ€§çš„ï¼Œä»–å°±ä¸èƒ½é€šè¿‡æ”¹å˜ç¼“å­˜å†…éƒ¨çŠ¶æ€å¯¼è‡´Aliceæ‰“å¼€é”™è¯¯çš„æ–‡ä»¶ã€‚ æˆ‘ä»¬åœ¨å¯åŠ¨æ—¶ä¸ºç­¾åå“ˆå¸Œå‡½æ•°é€‰æ‹©ä¸€ä¸ªéšæœºå¯†é’¥ï¼Œä»¥é™ä½ç¡®å®šæ€§é”™è¯¯æˆ–ç¦»çº¿å†²çªç”Ÿæˆçš„é£é™©ï¼Œå› ä¸ºäººä»¬å¯èƒ½ä¼šä½¿ç”¨è¿™äº›é”™è¯¯æ¥æ”»å‡»åŸºäºç”¨æˆ·è¾“å…¥æ‰“å¼€æ–‡ä»¶çš„åº”ç”¨ç¨‹åºï¼Œä¾‹å¦‚webæœåŠ¡å™¨ã€‚å› æ­¤ï¼Œç›¸åŒçš„è·¯å¾„ä¸ä¼šè·¨é‡å¯æˆ–ç›¸åŒå†…æ ¸çš„å®ä¾‹ç”Ÿæˆç›¸åŒçš„ç­¾åã€‚ å°½ç®¡é‡‡å–äº†æ‰€æœ‰è¿™äº›æªæ–½ï¼Œä½†å¯¹äºä»¥rootèº«ä»½è¿è¡Œçš„åº”ç”¨ç¨‹åºæ¥è¯´ï¼Œè¿™ç§é£é™©ä»ç„¶æ˜¯ä¸å¯æ¥å—çš„ï¼Œå› ä¸ºå®ƒå¯ä»¥æ‰“å¼€ä»»ä½•æ–‡ä»¶ï¼Œç‰¹åˆ«æ˜¯é‚£äº›æ¥å—æ¥è‡ªä¸å—ä¿¡ä»»ç”¨æˆ·çš„è¾“å…¥çš„æ–‡ä»¶ã€‚ ä¾‹å¦‚ï¼Œå‡è®¾æ¶æ„ç”¨æˆ·è¯†åˆ«äº†ä¸€ä¸ªä¸å¯†ç æ•°æ®åº“å…·æœ‰ç›¸åŒç­¾åçš„è·¯å¾„ã€‚è¯¥ç”¨æˆ·å¯ä»¥å°†æ­¤è·¯å¾„ä¼ é€’ç»™setuid-rootå®ç”¨ç¨‹åºï¼Œå¹¶æ¬ºéª—setuidå®ç”¨ç¨‹åºè¦†ç›–å¯†ç æ•°æ®åº“ã€‚é€šè¿‡ä¸å…è®¸å¯¹ç‰¹æƒäºŒè¿›åˆ¶æ–‡ä»¶æˆ–å¯¹å®‰å…¨æ•æ„Ÿçš„è·¯å¾„åè¿›è¡ŒåŸºäºç­¾åçš„æŸ¥æ‰¾åŠ é€Ÿï¼Œå¯ä»¥æ¶ˆé™¤è¿™ç§é£é™©ï¼Œå°½ç®¡è¿™åœ¨æˆ‘ä»¬çš„åŸå‹ä¸­æ²¡æœ‰å®ç°ã€‚ Collision Resistance Requirement æˆ‘ä»¬è®¾è®¡çš„å®‰å…¨æ€§å–å†³äºå¯¹æ‰‹åªèƒ½é€šè¿‡è›®åŠ›æ‰¾åˆ°ç¢°æ’ã€‚æˆ‘ä»¬çš„è®¾è®¡å¯ä»¥ä½¿ç”¨2é€šç”¨å“ˆå¸Œå‡½æ•°æˆ–ä¼ªéšæœºå‡½æ•°æ—(PRF)æ¥ç”Ÿæˆè·¯å¾„ç­¾åã€‚åœ¨æŠ—ç¢°æ’æ–¹é¢ï¼Œ2-universal hashæ•£åˆ—å’ŒPRFä¹‹é—´çš„åŒºåˆ«åœ¨äºï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡è§‚å¯Ÿ2-universal hashå‡½æ•°çš„è¾“å‡ºæ¥å­¦ä¹ å¯†é’¥ï¼Œä½†ä¸èƒ½ä»PRFçš„è¾“å‡ºä¸­å­¦ä¹ å¯†é’¥ã€‚å› ä¸ºæˆ‘ä»¬çš„dcacheè®¾è®¡ä¸å‘ç”¨æˆ·æ˜¾ç¤ºç­¾åï¼Œåªæ˜¾ç¤ºä¸¤æ¡è·¯å¾„æ˜¯å¦æœ‰ç­¾åå†²çªï¼Œæ‰€ä»¥ä»»ä½•ä¸€ä¸ªæ—çš„æ•£åˆ—å‡½æ•°éƒ½è¶³å¤Ÿäº†ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨åŒé€šç”¨å“ˆå¸Œå‡½æ•°æ—¶ï¼Œå¿…é¡»å°å¿ƒè®¡æ—¶å’Œå…¶ä»–ä¾§é€šé“ä¸ä¼šæ³„æ¼ç­¾åã€‚ä¾‹å¦‚ï¼Œä¸èƒ½åŒæ—¶ä½¿ç”¨ç­¾åä¸­çš„ä½æ¥ç´¢å¼•å“ˆå¸Œè¡¨ï¼Œå› ä¸ºå¯èƒ½ä¼šé€šè¿‡æµ‹é‡åœ¨ç»™å®šå“ˆå¸Œæ¡¶ä¸Šéå†é“¾çš„æ—¶é—´æ¥äº†è§£ç­¾åçš„ä½ã€‚åœ¨æˆ‘ä»¬é€‰æ‹©çš„å‡½æ•°ä¸­ï¼Œå¯ä»¥å®‰å…¨åœ°ä½¿ç”¨256ä½å“ˆå¸Œè¾“å‡ºä¸­çš„è¾ƒä½ä½ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬çš„ç‰¹å®šç®—æ³•ä¸­ï¼Œè¾ƒä½ä½ä¸å—è¾ƒé«˜ä½å€¼çš„å½±å“;å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨16ä½å“ˆå¸Œè¡¨ç´¢å¼•å’Œ240ä½ç­¾åã€‚ç›¸åï¼Œå½“ä½¿ç”¨PRFç”Ÿæˆç­¾åæ—¶ï¼Œå¯ä»¥é¿å…ä»ä¾§é€šé“å­¦ä¹ ç­¾åçš„é—®é¢˜ã€‚ æˆ‘ä»¬çš„è®¾è®¡ä½¿ç”¨äº†2-universal multilinear hashå‡½æ•°ã€‚æˆ‘ä»¬ä½¿ç”¨åŸºäºAES-NIç¡¬ä»¶çš„prfåšäº†å‡ ä¸ªå®éªŒï¼Œä½†æ²¡æœ‰æ‰¾åˆ°ä¸€ä¸ªè¶³å¤Ÿå¿«çš„å‡½æ•°æ¥æ”¹è¿›åŸºçº¿Linuxã€‚ä½¿ç”¨å½“å‰çš„128ä½AESç¡¬ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥æé«˜4ä¸ªæˆ–æ›´å¤šè·¯å¾„ç»„ä»¶çš„æ€§èƒ½ï¼Œä½†æ˜¯åˆ›å»º256ä½PRFéœ€è¦æ›´å¤æ‚çš„æ„é€ ï¼Œè¿™å¤ªæ˜‚è´µäº†ã€‚æ›´è°¨æ…çš„å®ç°å¯èƒ½æ›´å€¾å‘äºä½¿ç”¨PRFï¼Œä»¥é¿å…ä»»ä½•è¢«å¿½ç•¥çš„ä¾§é€šé“é£é™©ï¼Œç‰¹åˆ«æ˜¯å¦‚æœåœ¨æœªæ¥å‡ ä»£ç¡¬ä»¶ä¸­å¯ä»¥ä½¿ç”¨å¿«é€Ÿçš„256ä½PRFã€‚ Probability of a signature collision æˆ‘ä»¬é€‰æ‹©äº†ä¸€ä¸ª240ä½çš„ç­¾åï¼Œå®ƒä¸é‡å¤æ•°æ®åˆ é™¤ç³»ç»Ÿä¸­ä½¿ç”¨çš„ç­¾åå¤§å°ç›¸å½“ï¼ŒèŒƒå›´ä»128ä½åˆ°256ä½ã€‚ é‡å¤æ•°æ®åˆ é™¤è®¾è®¡é€šå¸¸é€‰æ‹©ä¸€ä¸ªç­¾åå¤§å°ï¼Œè¯¥ç­¾åå¤§å°å¼•å…¥çš„å†²çªé£é™©å¤§å¤§å°äºæœªæ£€æµ‹åˆ°çš„ECC RAMé”™è¯¯çš„é£é™©ã€‚ æˆ‘ä»¬å‡è®¾å¯¹æ‰‹æ­£åœ¨ç”¨è›®åŠ›å¯»æ‰¾ç¢°æ’ã€‚æ”»å‡»è€…å¿…é¡»æŸ¥æ‰¾ç³»ç»Ÿä¸Šçš„è·¯å¾„ï¼Œä¾‹å¦‚é€šè¿‡æ‰“å¼€æœ¬åœ°æ–‡ä»¶æˆ–æŸ¥è¯¢webæœåŠ¡å™¨ä¸Šçš„è·¯å¾„ã€‚å› ä¸ºæˆ‘ä»¬çš„å“ˆå¸Œå‡½æ•°æ˜¯ç”¨ä¸€ä¸ªéšæœºå€¼ä½œä¸ºé”®çš„ï¼Œå¹¶ä¸”è¾“å‡ºå¯¹ç”¨æˆ·æ˜¯éšè—çš„ï¼Œæ‰€ä»¥æ”»å‡»è€…åªèƒ½åœ¨ç›®æ ‡ç³»ç»Ÿä¸Šæœç´¢å†²çªã€‚å› æ­¤ï¼Œæ”»å‡»è€…å—åˆ°ç³»ç»Ÿä¸Šçš„æŸ¥æ‰¾é€Ÿç‡ä»¥åŠç›®æ ‡ç³»ç»Ÿåœ¨ç¼“å­˜ä¸­ä¿å­˜å¤šä¸ªç­¾åä»¥ä¾›æ¯”è¾ƒçš„èƒ½åŠ›çš„é™åˆ¶ã€‚ æˆ‘ä»¬è®¡ç®—ç¢°æ’é£é™©å˜å¾—ä¸å¯å¿½ç•¥(å³é«˜äº2^-128)çš„é¢„æœŸæ—¶é—´ï¼Œå¹¶å¯¹ç¢°æ’é£é™©å»ºæ¨¡å¦‚ä¸‹ã€‚é¦–å…ˆï¼Œ|H(X)| &#x3D; 2^240æ˜¯å¯èƒ½çš„ç­¾åæ•°ã€‚æˆ‘ä»¬å°†ç¼“å­˜é™åˆ¶ä¸ºn &#x3D; 2^35ä¸ªæ¡ç›®(å³ï¼Œå‡è®¾RAMä¸­çš„dcacheç©ºé—´ä¸º10TBï¼Œæ¯ä¸ªæ¡ç›®ä¸º320å­—èŠ‚)ï¼Œå¹¶é‡‡ç”¨LRUæ›¿æ¢ç­–ç•¥ã€‚æˆ‘ä»¬è®¡ç®—ç¢°æ’é£é™©å¤§äºP &#x3D; 2^âˆ’128çš„æŸ¥è¯¢æ¬¡æ•°(q)å¦‚ä¸‹: ä»¥æ¯ç§’1000äº¿æ¬¡çš„æŸ¥æ‰¾é€Ÿåº¦(ç›®å‰çš„æ ¸æ¯ç§’å¯ä»¥æŸ¥æ‰¾å¤§çº¦300ä¸‡æ¬¡)ï¼Œå¼ºåŠ›ç¢°æ’çš„æ¦‚ç‡è¶…è¿‡2^-128çš„é¢„æœŸæ—¶é—´æ˜¯4.8ä¸‡å¹´ Generalizing the Fast Pathåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»ä½¿ç”¨ç›¸å¯¹ç®€å•çš„è§„èŒƒè·¯å¾„åè§£é‡Šäº†å¿«é€Ÿè·¯å¾„ä¼˜åŒ–ã€‚ æœ¬èŠ‚è§£é‡Šå¦‚ä½•å°†è¿™äº›ä¼˜åŒ–ä¸Linuxçš„é«˜çº§å®‰å…¨æ¨¡å—é›†æˆï¼Œä»¥åŠå¦‚ä½•å¤„ç†Unixè·¯å¾„è¯­ä¹‰ä¸­çš„ä¸€äº›è¾¹ç¼˜æƒ…å†µï¼Œä¾‹å¦‚æŒ‚è½½é€‰é¡¹ã€æŒ‚è½½åˆ«åå’Œç¬¦å·é“¾æ¥ã€‚ Generalizing CredentialsLinuxåŒ…æ‹¬ä¸€ä¸ªå¯æ‰©å±•çš„å®‰å…¨æ¨¡å—æ¡†æ¶(LSMs)ï¼Œ SELinuxã€AppArmorç­‰éƒ½æ˜¯åœ¨æ­¤åŸºç¡€ä¸Šæ„å»ºçš„ã€‚LSMå¯ä»¥è¦†ç›–æœç´¢æƒé™æ£€æŸ¥çš„å®ç°ï¼Œæ£€æŸ¥ç›®å½•å±‚æ¬¡ç»“æ„æˆ–è¿›ç¨‹çš„è‡ªå®šä¹‰å±æ€§ã€‚å› æ­¤ï¼Œå³ä½¿LSMè¦†ç›–äº†é»˜è®¤çš„è®¿é—®æ§åˆ¶è§„åˆ™ï¼Œæˆ‘ä»¬çš„dcacheä¼˜åŒ–ä¹Ÿå¿…é¡»èƒ½å¤Ÿæ­£å¸¸å·¥ä½œã€‚ æˆ‘ä»¬çš„æ–¹æ³•åˆ©ç”¨äº†Linuxä¸­çš„creditç»“æ„ï¼Œè¯¥ç»“æ„æ—¨åœ¨å­˜å‚¨è¿›ç¨‹(ä»»åŠ¡ç»“æ„)çš„å‡­æ®ï¼Œå¹¶å…·æœ‰å‡ ä¸ªæœ‰ç”¨çš„å±æ€§ã€‚é¦–å…ˆï¼Œä¿¡ç”¨ç»“æ„æ˜¯å…¨é¢çš„ï¼ŒåŒ…æ‹¬å½±å“é»˜è®¤æƒé™çš„æ‰€æœ‰å˜é‡ï¼Œå¹¶åŒ…æ‹¬LSMå­˜å‚¨å…ƒæ•°æ®çš„ä¸é€æ˜å®‰å…¨æŒ‡é’ˆã€‚å…¶æ¬¡ï¼Œä¿¡ç”¨æ˜¯å†™æ—¶å¤åˆ¶(copy-on-write, COW)ï¼Œå› æ­¤å½“è¿›ç¨‹æ›´æ”¹å…¶å‡­æ®æ—¶ï¼Œä¾‹å¦‚é€šè¿‡æ‰§è¡ŒsetuidäºŒè¿›åˆ¶æ–‡ä»¶æˆ–æ›´æ”¹SELinuxä¸­çš„è§’è‰²ï¼Œä¿¡ç”¨å°†è¢«å¤åˆ¶ã€‚æˆ‘ä»¬æ‰‹åŠ¨æ£€æŸ¥äº†AppArmorå’ŒSELinuxå¯¹ç§æœ‰å…ƒæ•°æ®çš„æ›´æ”¹æ˜¯å¦éµå®ˆCOWçº¦å®šã€‚æ­¤å¤–ï¼Œåœ¨å¸¸è§æƒ…å†µä¸‹ï¼Œä¸€ä¸ªä¿¡ç”¨å¯ä»¥è¢«è¿›ç¨‹å…±äº«ï¼Œä¾‹å¦‚ä¸€ä¸ªshellè„šæœ¬åˆ†æ”¯å­è¿›ç¨‹å…·æœ‰ç›¸åŒçš„ä¿¡ç”¨ã€‚ å› æ­¤ï¼Œcredç»“æ„æ»¡è¶³äº†æˆ‘ä»¬çš„å¤§éƒ¨åˆ†éœ€æ±‚ï¼Œåªæœ‰ä¸€äº›å˜åŒ–ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹é¢è§£é‡Šã€‚ æˆ‘ä»¬åœ¨æ¯ä¸ªä¿¡ç”¨ç»“æ„ä¸­å­˜å‚¨ç¼“å­˜çš„å‰ç¼€æ£€æŸ¥(Â§3.1)ï¼Œå°†å‰ç¼€æ£€æŸ¥ç»“æœä¸ä¸å¯å˜å‡­è¯è€¦åˆåœ¨ä¸€èµ·ã€‚ä½¿ç”¨ç©ºPCCåˆå§‹åŒ–æ–°çš„ä¿¡ç”¨ç»“æ„ã€‚å½“æ›´å¤šè¿›ç¨‹å…±äº«PCCæ—¶ï¼Œå®ƒä»¬å¯ä»¥è¿›ä¸€æ­¥å‡å°‘æ…¢è·¯å¾„æŸ¥æ‰¾çš„æ•°é‡ã€‚ ä¸€ä¸ªæŒ‘æˆ˜æ˜¯ï¼Œå³ä½¿å‡­è¯æ²¡æœ‰æ›´æ”¹ï¼ŒLinuxä¹Ÿç»å¸¸åˆ†é…æ–°çš„ä¿¡ç”¨ç»“æ„ã€‚æ½œåœ¨çš„é—®é¢˜æ˜¯ï¼ŒCOWè¡Œä¸ºä¸æ˜¯åœ¨é¡µè¡¨ä¸­å®ç°çš„ï¼Œè€Œæ˜¯åœ¨å¯èƒ½ä¿®æ”¹ä¿¡ç”¨çš„ä»£ç ä¸­æŒ‰ç…§çº¦å®šå®ç°çš„ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œä¾‹å¦‚åœ¨execä¸­ï¼Œåªéœ€æå‰åˆ†é…å¦ä¸€ä¸ªä¿¡ç”¨ï¼Œè€Œä¸æ˜¯ç¡®å®šå‡­æ®æ˜¯å¦å°†è¢«æ›´æ”¹ï¼Œè¿™è¦ç®€å•å¾—å¤šã€‚è¿™ç§è‡ªç”±åˆ†é…æ–°å‡­æ®çš„æ–¹å¼é€ æˆäº†åœ¨å…·æœ‰ç›¸åŒå‡­æ®çš„å­è¿›ç¨‹ä¹‹é—´é‡ç”¨å‰ç¼€ç¼“å­˜é¡¹çš„é—®é¢˜ã€‚ä¸ºäº†ç¼“è§£è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ç­‰å¾…ï¼Œç›´åˆ°ä¸€ä¸ªæ–°çš„ä¿¡ç”¨è¢«åº”ç”¨åˆ°ä¸€ä¸ªè¿›ç¨‹(æäº¤ä¿¡ç”¨())ã€‚å¦‚æœä¿¡ç”¨çš„å†…å®¹æ²¡æœ‰æ”¹å˜ï¼Œæ—§çš„ä¿¡ç”¨å’ŒPCCè¢«é‡ç”¨å’Œå…±äº«ã€‚ æˆ‘ä»¬çš„ä¿¡ç”¨æ–¹æ³•è®°å¿†äº†ä¸åŒlsmçš„å¤æ‚å’Œå¯èƒ½ä»»æ„çš„æƒé™è¯„ä¼°å‡½æ•°ã€‚ Non-Canonical Paths and Symbolic Linksæˆ‘ä»¬çš„ä¼˜åŒ–å“ˆå¸Œè¡¨æ˜¯ä»¥å…¨è·¯å¾„ä¸ºé”®ã€‚ç„¶è€Œï¼Œç”¨æˆ·å¯ä»¥æŒ‡å®šä¸€ä¸ªè·¯å¾„çš„å˜ä½“ï¼Œä¾‹å¦‚/X/Y/./Zä»£è¡¨/X/Y/Zã€‚ç®€å•çš„å˜åŒ–åœ¨æ•£åˆ—è¿‡ç¨‹ä¸­å¾ˆå®¹æ˜“è¢«è§„èŒƒåŒ–ã€‚ä¸€ä¸ªæ›´å¤æ‚çš„æƒ…å†µæ˜¯ï¼Œå¦‚æœ&#x2F;X&#x2F;Læ˜¯ä¸€ä¸ªç¬¦å·é“¾æ¥ï¼Œè·¯å¾„/X/L/.../Yå¯ä»¥æ˜ å°„åˆ°&#x2F;X&#x2F;Yä»¥å¤–çš„è·¯å¾„ã€‚åŒæ ·ï¼Œå¦‚æœç”¨æˆ·æ²¡æœ‰æœç´¢/X/Zçš„æƒé™ï¼Œå³ä½¿ç”¨æˆ·æœ‰æœç´¢/X/Yçš„æƒé™ï¼Œå¯¹/X/Z/.../Yçš„æŸ¥è¯¢ä¹Ÿåº”è¯¥å¤±è´¥ã€‚ä¸ºäº†ä¿æŒä¸Linuxçš„bug-for-bugå…¼å®¹ï¼Œæˆ‘ä»¬çš„åŸå‹åœ¨æ¯ä¸ªç‚¹ä¸Šéƒ½ä¼šå‘å‡ºä¸€ä¸ªé¢å¤–çš„fastpathæŸ¥è¯¢æ¥æ£€æŸ¥æƒé™ã€‚ä¿æŒUnixçš„è¯­ä¹‰ä¼šç»™éç»å…¸çš„ è·¯å¾„çš„å¼€é”€ã€‚æˆ‘ä»¬å‘ç°ä½¿ç”¨Plan 9çš„è¯æ³•è·¯å¾„è¯­ä¹‰ã€‚Plan 9é€šè¿‡é¢„å¤„ç†ï¼Œå°†ç½‘ç»œæ–‡ä»¶ é€šè¿‡å¯¹/X/L/.../Yè¿™æ ·çš„è·¯å¾„è¿›è¡Œé¢„å¤„ç†ï¼Œå°†ç½‘ç»œæ–‡ä»¶ç³»ç»Ÿçš„æŸ¥è¯¢é™åˆ°æœ€ä½ã€‚åˆ°/X/Yã€‚æˆ‘ä»¬æ³¨æ„åˆ°ï¼ŒPlan 9åœ¨æ¯æ¬¡æŸ¥æ‰¾ç»„ä»¶æ—¶éƒ½ä¼šè¿›è¡Œ æŸ¥è¯¢ï¼Œä½†æ²¡æœ‰ç›®å½•ç¼“å­˜ã€‚ Symbollic Links æˆ‘ä»¬åœ¨æˆ‘ä»¬çš„æŸ¥è¯¢ä¸­è§£å†³ç¬¦å·é“¾æ¥ æˆ‘ä»¬é€šè¿‡ä¸ºç¬¦å·é“¾æ¥åˆ›å»ºdentry aliasesæ¥è§£å†³ç¬¦å·é“¾æ¥ã€‚ä¾‹å¦‚ ä¾‹å¦‚ï¼Œå¦‚æœè·¯å¾„/X/Læ˜¯/X/Yçš„åˆ«åï¼Œæˆ‘ä»¬çš„å†…æ ¸ä¼š åˆ›å»ºdentriesï¼Œå°†/X/L/Zé‡å®šå‘åˆ°/X/Y/Zã€‚æ¢å¥è¯è¯´ï¼Œç¬¦å·é“¾æ¥è¢«è§†ä¸ºä¸€ç§ç‰¹æ®Šçš„ç›®å½•ç±»å‹ã€ å¹¶å¯ä»¥åˆ›å»ºå­ç›®å½•ï¼Œå¯¹ç¿»è¯‘è¿›è¡Œç¼“å­˜ã€‚ ç¬¦å·é“¾æ¥dentrieså­˜å‚¨240ä½çš„ç­¾åï¼Œä»£è¡¨ç›®æ ‡è·¯å¾„ã€‚ä»£è¡¨ç›®æ ‡è·¯å¾„ã€‚PCCæ˜¯å•ç‹¬æ£€æŸ¥ ä¸ºç›®æ ‡ç›®å½•ã€‚å¦‚æœä¸€ä¸ªç¬¦å·é“¾æ¥å‘ç”Ÿå˜åŒ–ï¼Œæˆ‘ä»¬å¿…é¡» æ— æ•ˆæ‰€æœ‰çš„åç»§åˆ«åï¼Œç±»ä¼¼äºç›®å½•é‡å‘½åçš„æ— æ•ˆåŒ–ã€‚ç›®å½•é‡å‘½å(rename)ã€‚è¿™ç§é‡å®šå‘å¯ä»¥æ— ç¼åœ°å¤„ç† çš„æƒ…å†µï¼Œå³åœ¨ç¿»è¯‘çš„è·¯å¾„ä¸Šå‘ç”Ÿæƒé™å˜åŒ– è·¯å¾„ä¸Šçš„æƒé™å˜åŒ–ï¼Œæˆ–è€…è¢«å¼•ç”¨çš„ç›®å½•è¢«åˆ é™¤ä»¥å›æ”¶ç©ºé—´ã€‚ Mount Pointæˆ‘ä»¬çš„å¿«é€Ÿè·¯å¾„å¤„ç†ç”±æŒ‚è½½ç‚¹å¼•å…¥çš„å‡ ä¸ªå¾®å¦™çš„è¾¹ç¼˜æƒ…å†µã€‚ Mount options æŒ‚è½½é€‰é¡¹(å¦‚read-onlyæˆ–nosuid)ä¼šå½±å“æ–‡ä»¶è®¿é—®æƒé™æ£€æŸ¥ã€‚Linux dcacheé€šå¸¸å°†æŒ‚è½½ç‚¹ä½œä¸ºåˆ†å±‚æ–‡ä»¶ç³»ç»Ÿéå†çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶å†…è”æ£€æŸ¥ä¸æƒé™ç›¸å…³çš„æŒ‚è½½æ ‡å¿—ã€‚ä¸€æ—¦æ¶ˆé™¤äº†è¿™ç§è‡ªä¸Šè€Œä¸‹çš„è¡Œèµ°ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿè¯†åˆ«ä»»ä½•ç»™å®šç‰™é½¿çš„å½“å‰æŒ‚è½½ç‚¹ã€‚ç›®å‰æˆ‘ä»¬ä¸ºæ¯ä¸ªdentryæ·»åŠ äº†ä¸€ä¸ªæŒ‡é’ˆï¼Œå°½ç®¡å¯èƒ½æœ‰æ›´èŠ‚çœç©ºé—´çš„é€‰é¡¹ã€‚ Mount Aliases ä¸€äº›ä¼ªæ–‡ä»¶ç³»ç»Ÿï¼Œå¦‚procã€devå’Œsysfsï¼Œå¯ä»¥åœ¨å¤šä¸ªä½ç½®æŒ‚è½½ç›¸åŒçš„å®ä¾‹ã€‚chrootç¯å¢ƒä½¿ç”¨è¯¥ç‰¹æ€§ï¼Œå¹¶åœ¨å¼•å¯¼æœŸé—´ç§»åŠ¨è¿™äº›æ–‡ä»¶ç³»ç»Ÿã€‚ç»‘å®šæŒ‚è½½è¿˜å¯ä»¥åˆ›å»ºæŒ‚è½½åˆ«åã€‚ åœ¨æˆ‘ä»¬çš„ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªdentryåªå­˜å‚¨ä¸€ä¸ªç­¾åï¼Œå¹¶ä¸”ä¸€æ¬¡åªèƒ½é€šè¿‡ä¸€ä¸ªè·¯å¾„åœ¨ç›´æ¥æŸ¥æ‰¾å“ˆå¸Œè¡¨ä¸­ã€‚æˆ‘ä»¬ç›®å‰çš„è®¾è®¡åªæ˜¯é€‰æ‹©æœ€è¿‘çš„ä¼˜åŒ–ä½ç½®ã€‚å¦‚æœæ…¢è·¯å¾„éå†æ³¨æ„åˆ°åŒ¹é…çš„dentry(æŒ‰è·¯å¾„)æœ‰ä¸åŒçš„ç­¾åï¼Œåœ¨åˆ«åæŒ‚è½½ä¸‹ï¼Œå¹¶ä¸”å·²ç»åœ¨DLHTä¸­ï¼Œé‚£ä¹ˆæ…¢è·¯å¾„å°†æ›¿æ¢ç­¾åï¼Œå¢åŠ dentryç‰ˆæœ¬è®¡æ•°ï¼Œå¹¶æ›´æ–°æŒ‡å‘è¯¥dentryæŒ‚è½½ç‚¹çš„æŒ‡é’ˆã€‚ å¦‚æœåˆ«åè·¯å¾„æœ‰ä¸åŒçš„å‰ç¼€æ£€æŸ¥ç»“æœï¼Œåˆ™éœ€è¦å¢åŠ ç‰ˆæœ¬è®¡æ•°ã€‚è¿™ç§æ–¹æ³•ç¡®ä¿äº†æ‰€æœ‰æƒ…å†µä¸‹çš„æ­£ç¡®æ€§ï¼Œå¹¶ä¸”å¯¹äºä»»ä½•æŒ‚è½½åˆ«åçš„å…¥å£ï¼Œåœ¨æœ€è¿‘ä½¿ç”¨çš„è·¯å¾„ä¸Šéƒ½å…·æœ‰è‰¯å¥½çš„æ€§èƒ½ã€‚ Mount Namespaces Linuxä¸­çš„æŒ‚è½½namespaceå…è®¸è¿›ç¨‹åˆ›å»ºç§æœ‰æŒ‚è½½ç‚¹ï¼ŒåŒ…æ‹¬chrootç¯å¢ƒï¼Œè¿™äº›æŒ‚è½½ç‚¹ä»…å¯¹è¿›ç¨‹åŠå…¶åä»£å¯è§ã€‚å½“è¿›ç¨‹åˆ›å»ºä¸€ä¸ªæ–°çš„æŒ‚è½½namespaceæ—¶ï¼Œå®ƒè¿˜åˆ†é…ä¸€ä¸ªæ–°çš„ã€namespace-privateçš„ç›´æ¥æŸ¥æ‰¾å“ˆå¸Œè¡¨ã€‚slowpathæ€»æ˜¯åŒ…å«ä»»ä½•æŒ‚è½½é‡å®šå‘ï¼Œå¹¶ä¸”ä»»ä½•æ–°çš„ç­¾ååˆ°dentryæ˜ å°„åœ¨åç§°ç©ºé—´ä¸­éƒ½æ˜¯æ­£ç¡®çš„ã€‚å› æ­¤ï¼Œåç§°ç©ºé—´å†…éƒ¨çš„ç›¸åŒè·¯å¾„(å’Œç­¾å)å°†æ˜ å°„åˆ°ä¸åŒäºåç§°ç©ºé—´å¤–éƒ¨çš„dentryã€‚ç±»ä¼¼åœ°ï¼Œå‰ç¼€æ£€æŸ¥ç¼“å­˜(PCC)åœ¨åç§°ç©ºé—´ä¸­å§‹ç»ˆæ˜¯ç§æœ‰çš„ã€‚ ä¸æŒ‚è½½åˆ«å(Mount Aliases)ä¸€æ ·ï¼Œæˆ‘ä»¬ä¸€æ¬¡åªå…è®¸ä¸€ä¸ªdentryå­˜åœ¨äºä¸€ä¸ªç›´æ¥æŸ¥æ‰¾å“ˆå¸Œè¡¨ä¸Šã€‚è¿™æœ‰åˆ©äºå±€éƒ¨æ€§ï¼Œå¹¶ä¸”å½“é‡å‘½åçš„ç›®å½•è·¨å¤šä¸ªnamespaceå…±äº«æ—¶ï¼Œä½¿æ— æ•ˆä»»åŠ¡æ˜“äºå¤„ç†ã€‚ç”¨äºç›®å½•æ ‘ä¿®æ”¹çš„æ— æ•ˆä»£ç åªæ˜¯å°†æ¯ä¸ªå­æ¡ç›®ä»å½“å‰å­˜å‚¨çš„DLHTä¸­ç§»é™¤ Network File Systems æˆ‘ä»¬çš„åŸå‹ä¸æ”¯æŒåœ¨ç½‘ç»œæ–‡ä»¶ç³»ç»Ÿä¸Šç›´æ¥æŸ¥æ‰¾ï¼Œä¾‹å¦‚NFSç‰ˆæœ¬2å’Œ3ã€‚ä¸ºäº†åœ¨æ— çŠ¶æ€åè®®ä¸Šå®ç°ä»è¿‘åˆ°å¼€çš„ä¸€è‡´æ€§ï¼Œå®¢æˆ·ç«¯å¿…é¡»åœ¨æœåŠ¡å™¨ä¸Šé‡æ–°éªŒè¯æ‰€æœ‰è·¯å¾„ç»„ä»¶â€”â€”æœ‰æ•ˆåœ°å¼ºåˆ¶ç¼“å­˜ä¸¢å¤±ï¼Œå¹¶ä½¿å‘½ä¸­è·¯å¾„çš„ä»»ä½•å¥½å¤„æ— æ•ˆã€‚æˆ‘ä»¬æœŸæœ›è¿™äº›ä¼˜åŒ–å¯ä»¥ä½¿å…·æœ‰ç›®å½•ä¿®æ”¹å›è°ƒçš„æœ‰çŠ¶æ€åè®®å—ç›Šï¼Œä¾‹å¦‚AFSæˆ–NFS 4.1ã€‚ Summaryæœ¬èŠ‚æ¼”ç¤ºæˆ‘ä»¬çš„ç›®å½•ç¼“å­˜ä¼˜åŒ–å¦‚ä½•æ”¯æŒLinuxåœ¨ç›®å½•ç¼“å­˜ä¸Šæ„å»ºçš„å„ç§ç‰¹æ€§ï¼ŒåŒ…æ‹¬åç§°ç©ºé—´ã€å¢å¼ºçš„å®‰å…¨æ¨¡å—å’Œç¬¦å·é“¾æ¥ã€‚æˆ‘ä»¬çš„åŸå‹ä¸»è¦é›†ä¸­åœ¨Linuxä¸Šï¼Œå¯ä»¥è¯´Linuxçš„ç‰¹æ€§ä¸ç›®å½•ç¼“å­˜äº¤ç»‡åœ¨ä¸€èµ·ï¼Œä½†æ˜¯æˆ‘ä»¬ç›¸ä¿¡è¿™äº›ä¼˜åŒ–åœ¨å…¶ä»–ç³»ç»Ÿä¸Šä¹Ÿå¯ä»¥å·¥ä½œï¼Œåªéœ€è¦é€‚å½“çš„ç§»æ¤å·¥ä½œã€‚ æˆ‘ä»¬çš„è®¾è®¡æœ‰ä»¥ä¸‹è¦æ±‚ï¼Œæˆ‘ä»¬æœŸæœ›ä»»ä½•posixå…¼å®¹çš„ç›®å½•ç¼“å­˜éƒ½èƒ½æ»¡è¶³è¿™äº›è¦æ±‚ã€‚ é¦–å…ˆï¼ŒPOSIXæƒé™è¯­ä¹‰è¦æ±‚å¯¹ä»å½“å‰æ ¹ç›®å½•æˆ–å·¥ä½œç›®å½•åˆ°æ–‡ä»¶çš„è·¯å¾„è¿›è¡Œç›®å½•è®¿é—®æ£€æŸ¥(å³å‰ç¼€æ£€æŸ¥);æˆ‘ä»¬çš„å®ç°ç»§æ‰¿äº†Linuxçš„ä¸å˜é‡ï¼Œå³ä»»ä½•ç¼“å­˜ç›®å½•çš„çˆ¶ç›®å½•éƒ½åœ¨ç¼“å­˜ä¸­ï¼Œä½†æ˜¯ä»»ä½•å¯ä»¥å®ç°å‰ç¼€æ£€æŸ¥çš„è®¾è®¡éƒ½åº”è¯¥è¶³å¤Ÿäº†ã€‚å…¶æ¬¡ï¼Œæˆ‘ä»¬è¦æ±‚ï¼Œå¦‚æœä¸€ä¸ªç›®å½•çš„æƒé™æ”¹å˜ï¼Œæœ‰ä¸€ä¸ªç¨‹åºåŒ–çš„æ–¹å¼æ¥æ‰¾åˆ°æ‰€æœ‰çš„åä»£åœ¨ç¼“å­˜ä¸­(Â§3.2)ã€‚æˆ‘ä»¬çš„å®ç°é›†æˆäº†Linux dcacheä¸­çš„ä¹è§‚åŒæ­¥ï¼Œä»¥è·å¾—è‰¯å¥½çš„æ€§èƒ½å’Œä¸€è‡´æ€§ï¼Œä½†è¿™ç§è®¾è®¡å¯ä»¥é›†æˆä»»ä½•åˆç†çš„åŒæ­¥æ–¹æ¡ˆï¼Œä¾‹å¦‚FreeBSDçš„è¯»&#x2F;å†™é”ã€‚æœ€åï¼Œæˆ‘ä»¬åˆ©ç”¨Linuxå…·æœ‰ä¸å¯å˜å‡­è¯ç»“æ„çš„äº‹å®(Â§4.1);é€‚åº”å¯å˜çš„æˆ–ä¸å¤ªç»Ÿä¸€çš„å‡­è¯å°†éœ€è¦é¢å¤–çš„å·¥ä½œã€‚ Improving the Hit Rateå‰å‡ èŠ‚è§£é‡Šäº†dcacheç»“æ„çš„å˜åŒ–å¦‚ä½•é€šè¿‡ç®—æ³•æ”¹è¿›æ¥é™ä½å¹³å‡å‘½ä¸­å»¶è¿Ÿã€‚æœ¬èŠ‚å°†ä»‹ç»å‡ ä¸ªå¯ä»¥æé«˜å‘½ä¸­ç‡çš„ç®€å•æ›´æ”¹ã€‚åœ¨dcacheä¸¢å¤±çš„æƒ…å†µä¸‹ï¼Œä½çº§æ–‡ä»¶ç³»ç»Ÿè¢«è°ƒç”¨æ¥ä¸ºç³»ç»Ÿè°ƒç”¨æä¾›æœåŠ¡ã€‚åœ¨æœ€å¥½çš„æƒ…å†µä¸‹ï¼Œç£ç›˜ä¸Šçš„å…ƒæ•°æ®æ ¼å¼ä»åœ¨é¡µç¼“å­˜ä¸­ï¼Œä½†å¿…é¡»è½¬æ¢ä¸ºé€šç”¨æ ¼å¼;åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œè¯·æ±‚é˜»å¡åœ¨ç£ç›˜I&#x2F;Oä¸Šã€‚è™½ç„¶å¹¶ä¸æ˜¯æ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½ä»¥éå¸¸ä½çš„å‘½ä¸­ç‡å¤§é‡ä½¿ç”¨è¿™äº›æƒ…å†µï¼Œä½†è¯„ä¼°æ˜¾ç¤ºæœ‰å‡ ä¸ªå¹¿æ³›ä½¿ç”¨çš„åº”ç”¨ç¨‹åºä»è¿™äº›ä¼˜åŒ–ä¸­å—ç›ŠåŒªæµ…ã€‚ Caching Directory Completenesså°½ç®¡Linux dcacheè·Ÿè¸ªç›®å½•çš„å±‚æ¬¡ç»“æ„ï¼Œä½†å®ƒå¹¶ä¸çŸ¥é“ç›®å½•çš„å†…å®¹æ˜¯å…¨éƒ¨è¿˜æ˜¯éƒ¨åˆ†åœ¨ç¼“å­˜ä¸­ã€‚å‡è®¾Aliceåœ¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿä¸Šåˆ›å»ºäº†ä¸€ä¸ªæ–°ç›®å½•X;å¦‚æœå¥¹çš„ä¸‹ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨è¯•å›¾åˆ›å»ºæ–‡ä»¶X/Yï¼Œåˆ™dcacheå°†é”™è¿‡æ­¤æŸ¥æ‰¾ï¼Œå¹¶è¯¢é—®ä½çº§æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦å­˜åœ¨X/Yã€‚å¦‚æœVFSè·Ÿè¸ªæ‰€æœ‰ç›®å½•å†…å®¹éƒ½åœ¨ç¼“å­˜ä¸­ï¼Œåˆ™å¯ä»¥é¿å…è¿™ç§å¼€é”€ã€‚ ç¬¬äºŒä¸ªä¾‹å­æ˜¯readdirï¼Œå®ƒåˆ—å‡ºç›®å½•ä¸­çš„æ–‡ä»¶ï¼Œä»¥åŠå®ƒä»¬çš„inodeå·å’Œç±»å‹ï¼Œæ¯”å¦‚æ™®é€šæ–‡ä»¶ã€å­—ç¬¦è®¾å¤‡ã€ç›®å½•æˆ–ç¬¦å·é“¾æ¥ã€‚åœ¨å½“å‰çš„VFS readdiræ“ä½œä¸­ï¼Œæ€»æ˜¯è°ƒç”¨åº•å±‚æ–‡ä»¶ç³»ç»Ÿï¼Œå³ä½¿æ•´ä¸ªç›®å½•éƒ½åœ¨ç¼“å­˜ä¸­ã€‚å¯¹äºå¤§åˆ°æ— æ³•åœ¨ç”¨æˆ·æä¾›çš„ç¼“å†²åŒºä¸­åˆ—å‡ºçš„ç›®å½•ï¼Œå¯ä»¥å¤šæ¬¡è°ƒç”¨readdirï¼Œå°†åç§»é‡å­˜å‚¨åˆ°ç›®å½•ä¸­ã€‚ä¸ºäº†æ„é€ è¿™ä¸ªæ¸…å•ï¼Œåº•å±‚æ–‡ä»¶ç³»ç»Ÿå¿…é¡»é‡æ–°è§£æå’Œè½¬æ¢ç£ç›˜ä¸Šçš„æ ¼å¼ï¼Œå¹¶ä¸”å¯èƒ½éœ€è¦å°†å…ƒæ•°æ®å—ä»ç£ç›˜è¯»å…¥ç¼“å†²åŒºç¼“å­˜ã€‚å› æ­¤ï¼Œreaddiré€šå¸¸æ˜¯ä¸€ä¸ªæ˜‚è´µçš„æ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼Œç‰¹åˆ«æ˜¯å¯¹äºå¤§å‹ç›®å½•ã€‚ æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œé‡å¤åˆ—å‡ºç›®å½•æ˜¯æ–‡ä»¶ç³»ç»Ÿä¸­çš„å¸¸è§è¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·æˆ–shellè„šæœ¬å¯ä»¥åœ¨ä¸€ä¸ªç›®å½•ä¸­é‡å¤è¿è¡Œlså‘½ä»¤ã€‚ä¸€äº›åº”ç”¨ç¨‹åºé€šè¿‡ç›®å½•å†…å®¹åè°ƒçŠ¶æ€ï¼Œéœ€è¦é¢‘ç¹å’Œé‡å¤çš„ç›®å½•åˆ—è¡¨ã€‚ä¾‹å¦‚ï¼Œmaildiræ˜¯ä¸€ç§æµè¡Œçš„ç”µå­é‚®ä»¶åç«¯å­˜å‚¨æ ¼å¼ï¼Œå®ƒæ¯”æ—§çš„mboxæ ¼å¼äº§ç”Ÿæ›´å¥½çš„æ€§èƒ½å¯ä¼¸ç¼©æ€§ã€‚maildirå°†æ¯ä¸ªæ”¶ä»¶ç®±æˆ–å­æ–‡ä»¶å¤¹å­˜å‚¨ä¸ºä¸€ä¸ªç›®å½•ï¼Œæ¯ä¸ªå•ç‹¬çš„é‚®ä»¶éƒ½æ˜¯è¯¥ç›®å½•ä¸­çš„ä¸€ä¸ªæ–‡ä»¶ã€‚æ–‡ä»¶åç¼–ç å±æ€§ï¼ŒåŒ…æ‹¬æ ‡å¿—å’Œè¯»&#x2F;æœªè¯»çŠ¶æ€ã€‚å¦‚æœæ¶ˆæ¯æ”¹å˜äº†çŠ¶æ€ï¼Œä¾‹å¦‚é€šè¿‡åˆ é™¤æˆ–æ ‡è®°ä¸ºå·²è¯»ï¼ŒIMAPæœåŠ¡å™¨æœåŠ¡å™¨å°†é‡å‘½åæˆ–å–æ¶ˆè¯¥æ–‡ä»¶çš„é“¾æ¥ï¼Œå¹¶é‡æ–°è¯»å–ç›®å½•ä»¥åŒæ­¥é‚®ä»¶åˆ—è¡¨ã€‚ç±»ä¼¼åœ°ï¼Œä½œä¸ºå•ç‹¬è¿›ç¨‹è¿è¡Œçš„é‚®ä»¶ä¼ é€’ä»£ç†(MDA)å¯ä»¥å¹¶å‘åœ°å°†æ–°æ¶ˆæ¯å†™å…¥ç›®å½•ï¼Œè¿™è¦æ±‚IMAPæœåŠ¡å™¨ç›‘è§†ç›®å½•çš„æ›´æ”¹ï¼Œå¹¶å®šæœŸé‡æ–°è¯»å–ç›®å½•çš„å†…å®¹ã€‚ æˆ‘ä»¬çš„Linuxå˜ä½“å°†ä½çº§æ–‡ä»¶ç³»ç»Ÿè¿”å›çš„readdirç»“æœç¼“å­˜åœ¨ç›®å½•ç¼“å­˜ä¸­ã€‚å¦‚æœç›®å½•çš„æ‰€æœ‰å­ç›®å½•éƒ½åœ¨ç¼“å­˜ä¸­ï¼Œåˆ™ç”¨æ–°çš„DIR COMPLETEæ ‡å¿—æ ‡è®°dentryã€‚è¿™ä¸ªæ ‡å¿—æ˜¯åœ¨åˆ›å»ºæ–°ç›®å½•(mkdir)æ—¶è®¾ç½®çš„ï¼Œæˆ–è€…åœ¨ä¸€ç³»åˆ—readdirç³»ç»Ÿè°ƒç”¨å®Œæˆæ—¶ï¼Œæ²¡æœ‰åœ¨ç›®å½•å¥æŸ„ä¸Šæ‰§è¡Œlseek()æ“ä½œï¼Œä¹Ÿæ²¡æœ‰å¹¶å‘æ¸…é™¤ä»»ä½•å­ç›®å½•ä»¥å›æ”¶ç©ºé—´ã€‚æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå¹¶å‘æ–‡ä»¶çš„åˆ›å»ºæˆ–åˆ é™¤ä¸ä¸€ç³»åˆ—readdiräº¤ç»‡åœ¨ä¸€èµ·ï¼Œä»ç„¶ä¼šåœ¨ç¼“å­˜ä¸­ï¼Œå¹¶äº§ç”Ÿæ­£ç¡®çš„åˆ—è¡¨ç»“æœã€‚åœ¨è®¾ç½®äº†DIR COMPLETEæ ‡å¿—ä¹‹åï¼Œåç»­çš„è¯»DIRè¯·æ±‚å°†ç›´æ¥ä»dentryçš„å­åˆ—è¡¨ä¸­å¾—åˆ°æœåŠ¡ã€‚ä¸€æ—¦ç›®å½•è¿›å…¥å®Œæ•´çŠ¶æ€ï¼Œåªæœ‰åœ¨ä»ç¼“å­˜ä¸­åˆ é™¤å­æ¡ç›®ä»¥å›æ”¶ç©ºé—´æ—¶ï¼Œå®ƒæ‰ä¼šç¦»å¼€æ­¤çŠ¶æ€ã€‚ è¿™ç§æ–¹æ³•éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œreaddirè¿”å›é€šå¸¸ä¼šå‡ºç°åœ¨inodeä¸­çš„éƒ¨åˆ†ä¿¡æ¯ï¼Œä½†ä¸è¶³ä»¥åˆ›å»ºå®Œæ•´çš„inodeã€‚å¯¹äºè¿™äº›æ–‡ä»¶æˆ–å­ç›®å½•ï¼Œæˆ‘ä»¬æ·»åŠ ä¸å¸¦inodeçš„dentryä½œä¸ºç›®å½•çš„å­ç›®å½•ã€‚è¿™äº›dentryåœ¨æŸ¥æ‰¾æ—¶å¿…é¡»ä¸é˜´æ€§dentryåˆ†å¼€ï¼Œå¹¶ä¸é€‚å½“çš„ç´¢å¼•èŠ‚ç‚¹é“¾æ¥ã€‚è¿™ç§æ–¹æ³•å…è®¸å°†readdirç»“æœç”¨äºåç»­æŸ¥æ‰¾ï¼Œå¹²å‡€åœ°ä¸ç°æœ‰çš„dcacheæœºåˆ¶é›†æˆï¼Œå¹¶ä»æ¯ä¸ªç£ç›˜I&#x2F;Oä¸­è·å¾—æœ€å¤§å¯èƒ½çš„ç”¨é€”ï¼Œè€Œä¸ä¼šå¼•èµ·ä¸å¿…è¦çš„I&#x2F;Oã€‚ æˆ‘ä»¬æ³¨æ„åˆ°SolarisåŒ…å«ä¸€ä¸ªç±»ä¼¼çš„å®Œæ•´ç›®å½•ç¼“å­˜æ¨¡å¼[25]ï¼Œä½†å®ƒæ²¡æœ‰ä¸readdiræˆ–æŸ¥æ‰¾ä»¥å¤–çš„è°ƒç”¨é›†æˆï¼Œæ˜¯ä¸€ä¸ªå•ç‹¬çš„ç¼“å­˜(å› æ­¤ç›¸åŒçš„dentryå¯ä»¥å­˜å‚¨ä¸¤æ¬¡ï¼Œå¹¶ä¸”åœ¨ä¸¢å¤±ä¹‹å‰å¿…é¡»æ£€æŸ¥ä¸¤ä¸ªæ•£åˆ—è¡¨)ï¼Œå¹¶ä¸”æ³¨é‡Šè¡¨æ˜å®ƒä»…å¯¹å¤§å‹ç›®å½•å…·æœ‰æ€§èƒ½ä»·å€¼ã€‚æˆ‘ä»¬çš„ç»“æœè¡¨æ˜ï¼Œå½“é€‚å½“åœ°é›†æˆåˆ°ç›®å½•ç¼“å­˜ä¸­æ—¶ï¼Œè·Ÿè¸ªå®Œæ•´çš„ç›®å½•æ¯”ä»¥å‰è®¤ä¸ºçš„æ›´æœ‰ä»·å€¼ã€‚ File Creation ç›®å½•å®Œæ•´æ€§ç¼“å­˜è¿˜å¯ä»¥é¿å…æ–°æ–‡ä»¶åˆ›å»ºæ—¶çš„å¼ºåˆ¶é—æ¼ã€‚å°½ç®¡è´Ÿdentryç¼“å­˜å¯¹äºä¸å­˜åœ¨çš„ç‰¹å®šæ–‡ä»¶çš„é‡å¤æŸ¥è¯¢æ•ˆæœå¾ˆå¥½ï¼Œä½†æ˜¯å½“åº”ç”¨ç¨‹åºè¯·æ±‚ä¸å­˜åœ¨çš„ä¸åŒæ–‡ä»¶æ—¶ï¼Œè´Ÿdentryçš„æ•ˆæœå°±ä¸é‚£ä¹ˆå¥½äº†ã€‚ ä¸å¯é¢„æµ‹æŸ¥æ‰¾çš„ä¸€ä¸ªå¸¸è§ç¤ºä¾‹æ¥è‡ªå®‰å…¨ä¸´æ—¶æ–‡ä»¶åˆ›å»ºå®ç”¨ç¨‹åºã€‚åœ¨æˆ‘ä»¬çš„åŸå‹ä¸­ï¼Œå¸¦æœ‰DIR_COMPLETEDæ ‡å¿—çš„ç›®å½•ä¸‹çš„ç¼ºå¤±è¢«è§†ä¸ºå‘ç°äº†negative dentryï¼Œä»è€Œå¿½ç•¥äº†è¿™ç§å¼ºåˆ¶ç¼ºå¤±ã€‚åœ¨æˆ‘ä»¬å½“å‰çš„å®ç°ä¸­ï¼Œè¯¥æ ‡å¿—åªä¼šåœ¨å·²è¯»å–æˆ–æ–°åˆ›å»ºçš„ç›®å½•ä¸­è®¾ç½®ï¼Œä½†å…¶ä»–ç”¨äºæ£€æµ‹é¢‘ç¹çš„negative dentryç¼ºå¤±å’ŒåŠ è½½ç›®å½•çš„å¯å‘å¼æ–¹æ³•å¯èƒ½ä¹Ÿå¾ˆæœ‰ç”¨. Aggressive Negative Cachingnegative dentriesç¼“å­˜ç£ç›˜ä¸Šä¸å­˜åœ¨çš„è·¯å¾„ã€‚æœ¬å°èŠ‚ç¡®å®šäº†å‡ ä¸ªæ›´ç§¯æåœ°ä½¿ç”¨è´Ÿæ£€ç´¢çš„æœºä¼šï¼Œå…¶ä¸­ä¸€äº›ä¸ç›´æ¥æŸ¥æ‰¾ååŒå·¥ä½œ Renaming and Deletion å½“æ–‡ä»¶è¢«é‡å‘½åæˆ–è§£é™¤é“¾æ¥æ—¶ï¼Œå¯ä»¥å°†æ—§è·¯å¾„è½¬æ¢ä¸ºnegative dentryã€‚ è™½ç„¶Linuxä¼šåœ¨å–æ¶ˆé“¾æ¥æ—¶å°†ç¼“å­˜çš„ä½†æœªä½¿ç”¨çš„dentryè½¬æ¢ä¸ºnegative dentryï¼Œä½†å¯¹äºä»åœ¨ä½¿ç”¨çš„æ–‡ä»¶çš„é‡å‘½åå’Œå–æ¶ˆé“¾æ¥æ¥è¯´ï¼Œæƒ…å†µå¹¶éå¦‚æ­¤ã€‚æˆ‘ä»¬æ‰©å±•äº†è¿™äº›ä¾‹ç¨‹ï¼Œä»¥ä¾¿åœ¨åˆ é™¤æ–‡ä»¶åä¿ç•™è´Ÿè®°å½•ï¼Œä»¥ä¾¿ä»¥åé‡ç”¨è¯¥è·¯å¾„ï¼Œå°±åƒåˆ›å»ºé”æ–‡ä»¶æˆ–Emacsçš„å¤‡ä»½(â€œæ³¢æµªâ€)æ–‡ä»¶ä¸€æ · Pseudo File Systems ä¼ªæ–‡ä»¶ç³»ç»Ÿï¼Œå¦‚procã€syså’Œdevï¼Œä¸ä¼šä¸ºæœç´¢åˆ°çš„ä¸å­˜åœ¨çš„è·¯å¾„åˆ›å»ºnegative dentryã€‚è¿™æ˜¯ä¸€ç§åŸºäºä»¥ä¸‹è§‚å¯Ÿçš„ç®€åŒ–:ç£ç›˜I&#x2F;Oæ°¸è¿œä¸ä¼šæ¶‰åŠåˆ°é—æ¼ã€‚å› ä¸ºæˆ‘ä»¬çš„å¿«é€Ÿè·¯å¾„ä»ç„¶æ¯”é—æ¼å¿«å¾—å¤šï¼Œnegative dentryç”šè‡³å¯¹å†…å­˜ä¸­çš„æ–‡ä»¶ç³»ç»Ÿä¹Ÿæ˜¯æœ‰ç›Šçš„ï¼Œå¯ä»¥åŠ é€ŸæŸ¥æ‰¾ä¸å­˜åœ¨çš„é¢‘ç¹æœç´¢æ–‡ä»¶ã€‚ Deep Negative Dentries æœ€åï¼Œæˆ‘ä»¬æ‰©å±•äº†ç›´æ¥æŸ¥æ‰¾å¿«é€Ÿè·¯å¾„(Â§3)ï¼Œä½¿å…¶èƒ½å¤Ÿåˆ›å»ºâ€œæ·±åº¦â€è´Ÿè¾“å…¥ã€‚è€ƒè™‘è¿™æ ·ä¸€ç§æƒ…å†µ:ç”¨æˆ·è¯•å›¾æ‰“å¼€/X/Y/Z/Aï¼Œè€Œ/X/Y/Zä¸å­˜åœ¨ã€‚åœ¨æ…¢è·¯å¾„ä¸­ï¼ŒæŸ¥æ‰¾å°†åœ¨æ‰¾åˆ°ç¬¬ä¸€ä¸ªç¼ºå¤±çš„ç»„ä»¶æ—¶å¤±è´¥ï¼Œåªç¼“å­˜zçš„è´Ÿæ¡ç›®å°±è¶³å¤Ÿäº†ã€‚ç„¶è€Œï¼Œå¯¹è¯¥è·¯å¾„çš„é‡å¤æŸ¥æ‰¾å°†æ°¸è¿œä¸ä¼šæ‰¾åˆ°å¿«é€Ÿè·¯å¾„ï¼Œå› ä¸ºæ²¡æœ‰å®Œæ•´è·¯å¾„çš„æ¡ç›®ã€‚ ä¸ºäº†åœ¨è¿™ç§æƒ…å†µä¸‹ä½¿ç”¨å¿«é€Ÿè·¯å¾„ï¼Œæˆ‘ä»¬å…è®¸è´Ÿé¢dentriesåˆ›å»ºè´Ÿé¢å­èŠ‚ç‚¹ï¼Œä»¥åŠæ·±å±‚å­èŠ‚ç‚¹ã€‚ æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å…è®¸negative dentry /X/Y/Zåˆ›å»ºå­èŠ‚ç‚¹Aå’ŒA/Bï¼Œå®ƒä»¬å¯ä»¥æœåŠ¡äºå¯¹ä¸å­˜åœ¨çš„è·¯å¾„çš„é‡å¤è¯·æ±‚ã€‚å¦‚æœä¸ºç¼“å­˜ä¸ºè´Ÿçš„è·¯å¾„åˆ›å»ºæ–‡ä»¶ï¼Œå¹¶ä¸”è¯¥æ–‡ä»¶ä¸æ˜¯ç›®å½•ï¼Œåˆ™ä¼šä»ç¼“å­˜ä¸­æ¸…é™¤ä»»ä½•è´Ÿçš„å­æ–‡ä»¶ã€‚ æˆ‘ä»¬è¿˜åœ¨å¸¸è§„æ–‡ä»¶ä¸‹åˆ›å»ºæ·±åº¦negative dentryï¼Œä»¥æ•è·è¿”å›ENOTDIRè€Œä¸æ˜¯ENOENTçš„æŸ¥æ‰¾å¤±è´¥ã€‚å½“å°†æ–‡ä»¶åå½“ä½œç›®å½•ä½¿ç”¨æ—¶ï¼Œå°±ä¼šå‡ºç°è¿™ç§æŸ¥æ‰¾å¤±è´¥ï¼Œå¹¶ä¸”æœç´¢å…¶ä¸‹çš„è·¯å¾„ã€‚ä¾‹å¦‚ï¼Œå¦‚æœ/X/Y/Zæ˜¯ä¸€ä¸ªå¸¸è§„æ–‡ä»¶ï¼Œå¹¶ä¸”ç”¨æˆ·æœç´¢/X/Y/Z/A, Linuxå†…æ ¸å°†è¿”å›ENOTDIRï¼Œå¹¶ä¸”æ°¸è¿œä¸ä¼šåˆ›å»ºnegative dentryã€‚æˆ‘ä»¬ç”¨ä¸€ä¸ªdeep,ENOTDIRä¼˜åŒ–è¿™ä¸ªæ¡ˆä¾‹ã€‚ Evaluationæœ¬èŠ‚è¯„ä¼°æˆ‘ä»¬çš„ç›®å½•ç¼“å­˜ä¼˜åŒ–ï¼Œå¹¶è¯•å›¾å›ç­”ä»¥ä¸‹é—®é¢˜: æ¯ç§ä¼˜åŒ–(æŸ¥æ‰¾å¿«é€Ÿè·¯å¾„ã€å…¨ç›®å½•ç¼“å­˜å’Œæ›´æ¿€è¿›çš„negative dentries)å¯¹åº”ç”¨ç¨‹åºæ€§èƒ½çš„æ”¹å–„æœ‰å¤šå¤§? é‡‡ç”¨è¿™äº›æ›´æ”¹æœ‰å¤šå›°éš¾ï¼Œç‰¹åˆ«æ˜¯å¯¹äºå•ä¸ªæ–‡ä»¶ç³»ç»Ÿ? è¯„ä¼°åŒ…æ‹¬å¾®åŸºå‡†æµ‹è¯•ï¼Œç”¨äºæµ‹é‡åœ¨æœ€ä½³æƒ…å†µå’Œæœ€åæƒ…å†µä¸‹ä¸æ–‡ä»¶ç³»ç»Ÿç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨çš„å»¶è¿Ÿï¼Œä»¥åŠé€‰æ‹©å®é™…åº”ç”¨ç¨‹åºï¼Œä»¥æ˜¾ç¤ºæˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆåœ¨å®è·µä¸­å¯èƒ½æé«˜çš„æ€§èƒ½ã€‚ æ‰€æœ‰çš„å®éªŒç»“æœéƒ½æ”¶é›†åœ¨ä¸€å°Supermicroè¶…çº§æœåŠ¡å™¨ä¸Šï¼Œè¯¥æœåŠ¡å™¨é…å¤‡äº†12æ ¸2.40GHzçš„è‹±ç‰¹å°”Core Xeon CPUã€ 64GBå†…å­˜ï¼Œå’Œä¸€ä¸ª2TBï¼Œ7200 RPMçš„ATAç£ç›˜ï¼Œæ ¼å¼åŒ–ä¸ºæ—¥è®°å¼çš„ext4æ–‡ä»¶ç³»ç»Ÿï¼Œé…ç½®ä¸º4096 å­—èŠ‚å—å¤§å°ã€‚æ“ä½œç³»ç»Ÿæ˜¯Ubuntu 14.04æœåŠ¡å™¨ï¼ŒLinuxå†…æ ¸ 3.14. æ‰€æœ‰çš„æµ‹é‡ç»“æœéƒ½æ˜¯è‡³å°‘6æ¬¡è¿è¡Œçš„å¹³å‡å€¼ï¼ˆå¯¹äºè¿è¡Œæ—¶é—´è¾ƒé•¿çš„å®éªŒï¼‰ï¼›å¤§å¤šæ•°æµ‹é‡æ˜¯æ•°ç™¾æˆ–æ•°åƒæ¬¡çš„è¿è¡Œï¼Œä»¥ç¡®ä¿ä¸€è‡´çš„å¹³å‡æ•°ã€‚è¡¨æ ¼å’Œå›¾è¡¨è¡¨æ˜95%çš„ç½®ä¿¡åŒºé—´ ç”¨ â€œ+&#x2F;-â€œåˆ—æˆ–è¯¯å·®æ¡è¡¨ç¤ºã€‚ File Lookup OptimizationMicro-benchmarksæˆ‘ä»¬ä½¿ç”¨æ‰©å±•çš„LMBench 2.5 UNIXå¾®åŸºå‡†å¥—ä»¶æ¥è¯„ä¼°ç³»ç»Ÿè°ƒç”¨çº§åˆ«çš„è·¯å¾„æŸ¥æ‰¾å»¶è¿Ÿã€‚å›¾6æ˜¾ç¤ºäº†statå’Œopenå…·æœ‰å„ç§ç‰¹å¾çš„ç¤ºä¾‹è·¯å¾„çš„å»¶è¿Ÿï¼Œè¿™äº›ç‰¹å¾åŒ…æ‹¬ä¸åŒçš„é•¿åº¦ã€ç¬¦å·é“¾æ¥ã€çˆ¶ç›®å½•(dot dot)å’Œæœªæ‰¾åˆ°çš„æ–‡ä»¶ã€‚ æˆ‘ä»¬è§‚å¯Ÿåˆ°çš„ä¸»è¦è¶‹åŠ¿æ˜¯ï¼Œå½“è·¯å¾„æœ‰æ›´å¤šçš„ç»„ä»¶æ—¶ï¼Œæˆ‘ä»¬çš„ä¼˜åŒ–çš„ç›¸å¯¹å¢ç›Šå°±ä¼šå¢åŠ ã€‚ å¯¹äºå•ä¸ªç»„ä»¶æ–‡ä»¶ï¼Œstatè·å¾—3%çš„æ”¶ç›Šï¼Œè€Œopenä¸åŸºçº¿Linuxç›¸å½“ã€‚å¯¹äºæ›´é•¿çš„è·¯å¾„ï¼Œå¢ç›Šåˆ†åˆ«å¢åŠ åˆ°26%å’Œ12%ã€‚ ä¸ºäº†è¯„ä¼°æœ€åçš„æƒ…å†µï¼Œæˆ‘ä»¬åŒ…æ‹¬ä¸€ç»„æ ‡æœ‰ â€œfastpath miss + slowpath â€œçš„æ¡å½¢å›¾ï¼Œå®ƒè¡Œä½¿äº†å¿«é€Ÿè·¯å¾„ä»£ç ï¼Œä½†æ˜¯å†…æ ¸è¢«é…ç½®ä¸ºåœ¨PCCä¸­æ€»æ˜¯missã€‚è¿™æ¨¡æ‹Ÿäº†æ‰§è¡Œä¼˜åŒ–çš„å¿«é€Ÿè·¯å¾„ä¸æˆåŠŸï¼Œç„¶ååœ¨ç¼“å­˜ä¸­èµ°O(n)æ…¢é€Ÿè·¯å¾„çš„å…¨éƒ¨æˆæœ¬ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œä¸ä¼šä¸€ç›´é”™è¿‡åˆ°ä½çº§æ–‡ä»¶ç³»ç»Ÿã€‚å¼€é”€é€šå¸¸åœ¨12-93%ä¹‹é—´ï¼Œé™¤äº†è·¯å¾„neg-dã€‚åœ¨neg-dçš„æƒ…å†µä¸‹ï¼Œç¬¬ä¸€ä¸ªç»„ä»¶æ˜¯ç¼ºå¤±çš„ï¼Œä¸€ä¸ªç»„ä»¶ä¸€ä¸ªæ—¶é—´çš„è¡Œèµ°ä¼šæ¯”ç›´æ¥æŸ¥æ‰¾æ›´å¿«åœæ­¢ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œneg-dçš„æƒ…å†µä¼šé€šè¿‡deep negative dentriesæ¥ç¼“è§£ã€‚åœ¨å®è·µä¸­ï¼Œè¿™äº›å¼€é”€åªæœ‰åœ¨é«˜é€Ÿç¼“å­˜ä¸­çš„å¼ºåˆ¶ç¼ºå¤±æ—¶æ‰ä¼šè¢«è§‚å¯Ÿåˆ°ï¼Œæˆ–è€…ç”±ä¸€ä¸ªè¡¨ç°å‡ºæåº¦ç¼ºä¹å®šä½æ€§çš„åº”ç”¨æ¥è§‚å¯Ÿã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¯”è¾ƒé»˜è®¤Linuxçˆ¶çº§(â€œdot dotâ€)è¯­ä¹‰ä¸Plan 9çš„è¯æ³•è¯­ä¹‰çš„æˆæœ¬ã€‚å¯¹å¸¦æœ‰çˆ¶å¼•ç”¨çš„è·¯å¾„å¼ºåˆ¶æ‰§è¡ŒLinuxè¯­ä¹‰å¯¼è‡´æˆ‘ä»¬çš„ä¼˜åŒ–æ€§èƒ½æ¯”æœªä¿®æ”¹çš„Linuxå·®å¤§çº¦31%ï¼Œå› ä¸ºè¿™éœ€è¦å¯¹æ¯ä¸ªçˆ¶èŠ‚ç‚¹è¿›è¡Œé¢å¤–çš„æŸ¥æ‰¾ã€‚å¦ä¸€æ–¹é¢ï¼Œè¯æ³•è·¯å¾„è¯­ä¹‰å…è®¸æˆ‘ä»¬ç»§ç»­ä½¿ç”¨å•ä¸ªæŸ¥æ‰¾è¿›è¡Œä¼˜åŒ–ï¼Œä»è€Œå°†æ€§èƒ½æé«˜43-52%ã€‚è¯æ³•è·¯å¾„è¯­ä¹‰æœ‰ä¸€ä¸ªç‹¬ç«‹çš„å¥½å¤„ï¼Œå¯ä»¥å‡å°‘åœ¨æœªä¿®æ”¹çš„Linuxä¸­æŸ¥æ‰¾æ—¶éœ€è¦éå†çš„ç»„ä»¶æ•°é‡ã€‚å°½ç®¡è¿™ä¸ªå·®å¼‚å¾ˆå¤§ï¼Œä½†æ˜¯æˆ‘ä»¬çš„æµ‹è¯•åº”ç”¨ç¨‹åºå¹¶æ²¡æœ‰å¤§é‡ä½¿ç”¨çˆ¶ç›®å½•æŒ‡é’ˆï¼Œå¹¶ä¸”å¯¹è¿™ä¸ªå·®å¼‚å¹¶ä¸æ•æ„Ÿã€‚ ç¼“å­˜ç¬¦å·é“¾æ¥çš„åˆ†è¾¨ç‡å¯ä½¿è·¯å¾„link-få’Œlink-dçš„æ€§èƒ½åˆ†åˆ«æé«˜44%å’Œ48%ã€‚è¿™ç§æ”¹è¿›å¯¹é“¾æ¥å‘ç”Ÿåœ¨è·¯å¾„ä¸­çš„ä½ç½®ä¸æ•æ„Ÿï¼Œå› ä¸ºlink-få’Œlink-déƒ½éå†ç›¸åŒæ•°é‡çš„ç»„ä»¶(link-då°†â€œLLLâ€æ˜ å°„åˆ°â€œXXXâ€)ã€‚ å¯¹äºä¸å­˜åœ¨çš„æ–‡ä»¶(negative dentries)ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸ç°æœ‰è·¯å¾„ç±»ä¼¼çš„æ”¹è¿›ã€‚å”¯ä¸€çš„ä¾‹å¤–æ˜¯è·¯å¾„æ—©æœŸç›®å½•ä¸‹ä¸å­˜åœ¨çš„é•¿è·¯å¾„ã€‚æˆ‘ä»¬è®¤ä¸ºè¿™ç§æƒ…å†µå¾ˆå°‘è§ï¼Œå› ä¸ºåº”ç”¨ç¨‹åºé€šå¸¸æ˜¯è‡ªé¡¶å‘ä¸‹éå†ç›®å½•æ ‘ï¼Œè€Œä¸æ˜¯è·³åˆ°ä¸€ä¸ªä¸å­˜åœ¨çš„ç›®å½•ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹(path neg-d)ï¼ŒåŸºçº¿Linuxåœæ­¢å¤„ç†è·¯å¾„çš„é€Ÿåº¦æ¯”æˆ‘ä»¬çš„ä¼˜åŒ–æ•£åˆ—æ•´ä¸ªè·¯å¾„çš„é€Ÿåº¦è¦å¿«ï¼Œå³ä½¿ç¼“å­˜deep negative dentriesä¹Ÿæ˜¯å¦‚æ­¤ã€‚å°½ç®¡å¦‚æ­¤ï¼Œdeep negative dentriesæ˜¯ä¸€ä¸ªé‡è¦çš„ä¼˜åŒ–:æ²¡æœ‰å®ƒä»¬ï¼Œpath neg-dçš„çŠ¶æ€å°†æ¯”æœªä¿®æ”¹çš„Linuxå·®113%ï¼Œopenå°†å·®43%ï¼Œè€Œdeep negative dentriesåˆ™æ…¢38%å’Œ16%ã€‚ Linuxè¿˜åŒ…æ‹¬*at()ç³»ç»Ÿè°ƒç”¨å˜ä½“ï¼Œå®ƒä»¬åœ¨å·¥ä½œç›®å½•ä¸‹æ“ä½œâ€”é€šå¸¸åªä½¿ç”¨å•ä¸ªç»„ä»¶ã€‚ä¸ä¸Šé¢çš„ç»“æœç›¸å¯¹åº”ï¼Œå¯¹äºå•ä¸ªè·¯å¾„ç»„ä»¶ï¼Œfstatat()ä»æˆ‘ä»¬çš„ä¼˜åŒ–ä¸­è·ç›Š12%ï¼Œopenat()æ¯”æœªä¿®æ”¹çš„Linuxå¿«4%ã€‚ä¸€äº›åº”ç”¨ç¨‹åºå°†å¤šä¸ªç»„ä»¶åç§°ä¸*atè°ƒç”¨ç»“åˆä½¿ç”¨;åœ¨è¿™äº›æƒ…å†µä¸‹ï¼Œä¼˜åŒ–çš„å¥½å¤„ä¸è·¯å¾„é•¿åº¦æˆæ­£æ¯”ã€‚ ä¸ºäº†è¯„ä¼°æ›´æ–°ç›®å½•æƒé™å’Œæ”¹å˜ç›®å½•ç»“æ„çš„å¼€é”€ï¼Œæˆ‘ä»¬æµ‹é‡chmodå’Œé‡å‘½åçš„å»¶è¿Ÿã€‚åœ¨æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆä¸­ï¼Œå½±å“è¿™äº›å¼€é”€çš„ä¸»è¦å› ç´ æ˜¯ç¼“å­˜ä¸­çš„å­ç›®å½•æ•°é‡ï¼ˆç¼“å­˜å¤–çš„ç›®å½•å­ç›®å½•ä¸ä¼šå½±å“æ€§èƒ½ï¼‰ã€‚å›¾7æ˜¾ç¤ºäº†ä¸åŒæ·±åº¦å’Œç›®å½•å¤§å°çš„ç›®å½•ä¸Šçš„chmodå’Œé‡å‘½åçš„æ€§èƒ½ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œé‡å‘½åæˆ–chmodçš„æˆæœ¬éšç€å­ç›®å½•æ•°é‡çš„å¢åŠ è€Œæ€¥å‰§å¢åŠ ï¼Œè€ŒåŸºçº¿Linuxå’Œext4ä½¿è¿™äº›æ“ä½œçš„æ—¶é—´ä¸å˜ã€‚å³ä½¿æœ‰10,000ä¸ªå­ç›®å½•éƒ½åœ¨ç¼“å­˜ä¸­ï¼Œæœ€åçš„æƒ…å†µä¸‹çš„å»¶è¿Ÿä¹Ÿåœ¨330å¾®ç§’å·¦å³ã€‚ä½œä¸ºä¸€ä¸ªå‚è€ƒç‚¹ï¼ŒLinux 3.19æºæ ‘åŒ…æ‹¬51,562ä¸ªæ–‡ä»¶å’Œç›®å½•ã€‚å‡ ä¸ªLinuxæ–‡ä»¶ç³»ç»Ÿç»´æŠ¤è€…çš„åˆæ­¥åé¦ˆè¡¨æ˜ è¿™ç§äº¤æ˜“å¯¹äºæé«˜æŸ¥è¯¢æ€§èƒ½æ˜¯å¯ä»¥æ¥å—çš„ã€‚ Space Overhead æˆ‘ä»¬çš„åŸå‹å°†dentryçš„å¤§å°ä»192å­—èŠ‚å¢åŠ åˆ°280å­—èŠ‚ã€‚æˆ‘ä»¬çš„è®¾è®¡è¿˜å¼•å…¥äº†å¤§å°ä¸º64 KBçš„æ¯ä¸ªå‡­æ®çš„PCCå’Œç¬¬äºŒä¸ªå…¨å±€æ•£åˆ—è¡¨(DLHT)ï¼Œå…¶ä¸­åŒ…æ‹¬2^16ä¸ªbucketã€‚ç”±äºLinuxæ²¡æœ‰å¯¹dcacheå¤§å°æ–½åŠ ä»»ä½•ç¡¬é™åˆ¶(é™¤äº†åœ¨å†…å­˜å‹åŠ›ä¸‹çš„æç«¯æƒ…å†µ)ï¼Œå› æ­¤å¾ˆéš¾æ ‡å‡†åŒ–æ‰§è¡Œæ—¶é—´æ¥è€ƒè™‘ç©ºé—´æˆæœ¬ã€‚åœ¨ä¸€ä¸ªå…¸å‹çš„ç³»ç»Ÿä¸Šï¼Œdcacheæ˜¯å‡ ååˆ°å‡ ç™¾MB;å°†å…¶å¢åŠ 50%å¯èƒ½åœ¨ç³»ç»Ÿæ€»å†…å­˜çš„å¯æ¥å—èŒƒå›´å†…ã€‚æˆ–è€…ï¼Œå¦‚æœè¦é™åˆ¶æ€»dcacheå¤§å°ï¼Œåˆ™ä¼šåœ¨æ›´å¿«çš„å‘½ä¸­å’Œæ›´å°‘çš„å‘½ä¸­ä¹‹é—´è¿›è¡Œæƒè¡¡ã€‚æˆ‘ä»¬æŠŠè¿™äº›æƒè¡¡çš„æ¢ç´¢ç•™ç»™æœªæ¥çš„å·¥ä½œã€‚ Scalability å›¾8æ˜¾ç¤ºäº†å½“ç³»ç»Ÿä¸Šæ‰§è¡Œæ›´å¤šçº¿ç¨‹æ—¶ï¼Œåœ¨åŒä¸€è·¯å¾„ä¸Šæ‰§è¡Œstat/openæ“ä½œçš„å»¶è¿Ÿã€‚åœ¨Linuxä¸Šï¼ŒæŸ¥æ‰¾çš„è¯»ç«¯å·²ç»æ˜¯çº¿æ€§å¯ä¼¸ç¼©çš„ï¼Œæˆ‘ä»¬çš„ä¼˜åŒ–å¹¶æ²¡æœ‰ç ´åè¿™ä¸€è¶‹åŠ¿â€”â€”åªæ˜¯æé«˜äº†å»¶è¿Ÿã€‚renameç³»ç»Ÿè°ƒç”¨å¼•å…¥äº†æ˜¾è‘—çš„äº‰ç”¨ï¼Œå¹¶ä¸”åœ¨åŸºçº¿Linuxä¸­å¯ä¼¸ç¼©æ€§è¾ƒå·®ã€‚ä¾‹å¦‚ï¼Œåœ¨æˆ‘ä»¬ Caching Directory Completeness å›¾9æ˜¾ç¤ºäº†ä¸åŒç›®å½•å¤§å°çš„readdirå¾®åŸºå‡†æµ‹è¯•çš„å»¶è¿Ÿã€‚ç¼“å­˜readdirç»“æœçš„èƒ½åŠ›æé«˜äº†46-74%çš„æ€§èƒ½ã€‚éšç€ç›®å½•å˜å¤§ï¼Œç¼“å­˜çš„å¸®åŠ©è¶Šæ¥è¶Šå¤§ã€‚OpenSolarisçš„æ³¨é‡Šè¡¨æ˜ï¼Œè¿™ä¸ªæƒ³æ³•åªå¯¹UFSä¸­è‡³å°‘æœ‰1,024ä¸ªæ¡ç›®çš„ç›®å½•æœ‰åˆ©ã€‚æˆ‘ä»¬çš„ç»“æœè¡¨æ˜ï¼Œå³ä½¿åªæœ‰10ä¸ªå­ç›®å½•ä¹Ÿæœ‰å¥½å¤„ã€‚ å›¾9è¿˜æ˜¾ç¤ºäº†åœ¨ä¸åŒå¤§å°çš„ç›®å½•ä¸­åˆ›å»ºä¸€ä¸ªå®‰å…¨çš„ã€éšæœºå‘½åçš„æ–‡ä»¶çš„å»¶è¿Ÿã€‚æˆ‘ä»¬å¯¹mkstempåº“è¿›è¡Œäº†1-8%çš„æ”¹è¿›ã€‚å°½ç®¡å¤§å¤šæ•°åº”ç”¨ç¨‹åºçš„æ‰§è¡Œæ—¶é—´å¹¶ä¸è¢«å®‰å…¨æ–‡ä»¶çš„åˆ›å»ºæ‰€æ”¯é…ï¼Œä½†å®ƒæ˜¯è®¸å¤šåº”ç”¨ç¨‹åºçš„ä¸€é¡¹å¸¸è§ä»»åŠ¡ï¼Œè€Œä¸”è¾¹é™…æˆæœ¬ä½ã€‚ ApplicationsCommand-Line Applications å½“ç„¶ï¼Œåº”ç”¨ç¨‹åºä»æ›´å¿«çš„æŸ¥æ‰¾ä¸­è·å¾—çš„æ”¹è¿›ä¸å‘å‡ºåŸºäºè·¯å¾„çš„ç³»ç»Ÿè°ƒç”¨æ‰€èŠ±è´¹çš„è¿è¡Œæ—¶æ—¶é—´æ¯”ä¾‹ä»¥åŠåˆ—å‡ºç›®å½•çš„æ—¶é—´æ•°é‡æˆæ­£æ¯”ã€‚æˆ‘ä»¬æµ‹é‡ä¸€ç³»åˆ—å¸¸ç”¨åº”ç”¨ç¨‹åºçš„æ€§èƒ½ã€‚ åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™äº›åº”ç”¨ç¨‹åºä»è¿™äº›ä¼˜åŒ–ä¸­å—ç›ŠåŒªæµ…;åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œæ€§èƒ½æŸå®³æ˜¯æœ€å°çš„ã€‚æˆ‘ä»¬ç”¨äºåŸºå‡†æµ‹è¯•çš„åº”ç”¨ç¨‹åºåŒ…æ‹¬: find:åœ¨Linuxæºç›®å½•ä¸­æœç´¢æ–‡ä»¶åã€‚ tar xzf:è§£å‹å¹¶è§£åŒ…Linuxæºä»£ç ã€‚ rm -r:åˆ é™¤Linuxæºæ ‘ã€‚ makeå’Œmake -j12:ç¼–è¯‘Linuxå†…æ ¸ã€‚ du -s:åœ¨Linuxæºä»£ç ä¸­é€’å½’åˆ—å‡ºç›®å½•å¤§å°ã€‚ updatedb:ä»ä¸€ä¸ªå¹²å‡€çš„debootstrapä¸­é‡å»º&#x2F;usrä¸­å¸¸ç”¨æœç´¢æ–‡ä»¶åçš„è§„èŒƒè·¯å¾„æ•°æ®åº“ã€‚ git statuså’Œgit diff:æ˜¾ç¤ºå…‹éš†çš„Linuxå†…æ ¸gitåº“çš„çŠ¶æ€å’Œæœªåˆ†çº§çš„æ›´æ”¹ å¯¹äºæˆ‘ä»¬æµ‹è¯•çš„æ¯ä¸ªåº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬åœ¨çƒ­ç¼“å­˜(è¡¨1)å’Œå†·ç¼“å­˜(è¡¨2)ä¸¤ç§æƒ…å†µä¸‹è¯„ä¼°æ€§èƒ½ã€‚ä¸ºäº†çƒ­ç¼“å­˜ï¼Œæˆ‘ä»¬è¿è¡Œä¸€æ¬¡å®éªŒå¹¶æ”¾å¼ƒç¬¬ä¸€æ¬¡è¿è¡Œã€‚å¯¹äºçƒ­ç¼“å­˜æµ‹è¯•ï¼Œæˆ‘ä»¬è¿˜æä¾›äº†æ¯ä¸ªåº”ç”¨ç¨‹åºçš„è·¯å¾„ç‰¹å¾çš„ç»Ÿè®¡ä¿¡æ¯ã€‚ ä¹Ÿè®¸ä¸è¶³ä¸ºå¥‡çš„æ˜¯ï¼Œå…ƒæ•°æ®å¯†é›†å‹å·¥ä½œè´Ÿè½½ä»æˆ‘ä»¬çš„ä¼˜åŒ–ä¸­è·ç›Šæœ€å¤šï¼Œä¾‹å¦‚findå’Œupdatedbï¼Œé€Ÿåº¦å¯æé«˜29%ã€‚æ³¨æ„ï¼Œfindã€updatedbå’Œduåªä½¿ç”¨*at() apiï¼Œå¹¶ä¸”æ‰€æœ‰è·¯å¾„éƒ½æ˜¯å•ç»„ä»¶;è¿™äº›æ”¶ç›Šå¯å½’å› äºæŸ¥æ‰¾å’Œç›®å½•å®Œæ•´æ€§ç¼“å­˜çš„æ”¹è¿›ã€‚ æˆ‘ä»¬æ³¨æ„åˆ°ç›®å½•æœç´¢å·¥ä½œè´Ÿè½½çš„æ€§èƒ½å¯¹PCCçš„å¤§å°å¾ˆæ•æ„Ÿ;å½“æˆ‘ä»¬åœ¨ä¸€ä¸ªæ¯”PCCå¤§ä¸¤å€çš„ç›®å½•æ ‘ä¸Šè¿è¡Œupdatedbæ—¶ï¼Œå¢ç›Šä»29%ä¸‹é™åˆ°16.5%ã€‚è¿™æ˜¯å› ä¸ºåœ¨æ–°è®¿é—®çš„ç›®å½•ä¸­ï¼Œè¶Šæ¥è¶Šå¤šçš„ç¬¬ä¸€æ¬¡æŸ¥æ‰¾å°†ä¸å¾—ä¸é‡‡ç”¨æ…¢è·¯å¾„ã€‚ æˆ‘ä»¬çš„åŸå‹æœ‰ä¸€ä¸ªé™æ€è®¾ç½®çš„PCCå¤§å°ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªè¶³å¤Ÿå¤§çš„PCCè¿›è¡Œè¯„ä¼°ï¼Œä»¥ä¾¿åœ¨æ¸©æš–çš„ç¼“å­˜å®éªŒä¸­ç¼“å­˜å¤§å¤šæ•°ç›¸å…³çš„ç›®å½•ã€‚æˆ‘ä»¬å¸Œæœ›ä¸€ä¸ªç”Ÿäº§ç³»ç»Ÿèƒ½å¤ŸåŠ¨æ€åœ°è°ƒæ•´PCCçš„å¤§å°ï¼Œä½¿å…¶è¾¾åˆ°æœ€å¤§çš„å·¥ä½œé›†ï¼›æˆ‘ä»¬å°†ç ”ç©¶ä¸€ä¸ªé€‚å½“çš„ç­–ç•¥æ¥å†³å®šä½•æ—¶å¢åŠ PCCå’Œé©±é€æ¡ç›®çš„é—®é¢˜ç•™å¾…ä»Šåçš„å·¥ä½œä¸­è§£å†³ã€‚ æˆ‘ä»¬çš„å‘½ä¸­ä¼˜åŒ–ä¸»è¦æ”¹è¿›çš„åº”ç”¨ç¨‹åºæ˜¯gitï¼Œå®ƒæ˜¾ç¤ºäº†4-9.9%çš„å¢ç›Šã€‚ç”±å…¶ä»–è®¡ç®—ä¸»å¯¼çš„æƒ…å†µï¼Œä¾‹å¦‚Linuxç¼–è¯‘ï¼Œæ˜¾ç¤ºæœ€å°(â‰¤2.3%çš„å‡é€Ÿ)ã€‚åœ¨å†·ç¼“å­˜çš„æƒ…å†µä¸‹ï¼Œæ‰€æœ‰çš„å¢ç›Šæˆ–æŸå¤±éƒ½å¤§è‡´åœ¨å®éªŒå™ªå£°èŒƒå›´å†…ï¼Œè¿™è¡¨æ˜è¿™äº›ä¼˜åŒ–ä¸å¤ªå¯èƒ½å¯¹åœ¨å†·ç³»ç»Ÿä¸Šè¿è¡Œçš„åº”ç”¨ç¨‹åºé€ æˆæŸå®³ã€‚æ€»çš„æ¥è¯´ï¼Œè¿™äº›ç»“æœè‚¯å®šäº†æ™®é€šçš„Linuxåº”ç”¨ç¨‹åºä¸ä¼šå› ä¸ºæˆ‘ä»¬çš„ä¼˜åŒ–è€Œå—åˆ°æŸå®³ï¼Œè€Œä¸”å¯ä»¥ä»ä¸­è·å¾—å®è´¨æ€§çš„å¥½å¤„ã€‚ è¡¨1è¿˜æ˜¾ç¤ºäº†æœªä¿®æ”¹Linuxä¸Šè¿™äº›å·¥ä½œè´Ÿè½½çš„ç»Ÿè®¡ä¿¡æ¯ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæ¯ä¸ªè·¯å¾„ç»„ä»¶å¤§çº¦æœ‰8ä¸ªå­—ç¬¦ï¼ŒåŸºäº*atçš„åº”ç”¨ç¨‹åºé€šå¸¸æŸ¥æ‰¾å•ç»„ä»¶è·¯å¾„ï¼Œè€Œå…¶ä»–åº”ç”¨ç¨‹åºé€šå¸¸æŸ¥æ‰¾3-4ä¸ªç»„ä»¶ã€‚æˆ‘ä»¬çš„ç»Ÿè®¡æ•°æ®è¿˜è¡¨æ˜ï¼Œä½¿ç”¨çƒ­ç¼“å­˜æ—¶ï¼Œè¿™äº›åº”ç”¨ç¨‹åºåœ¨ç¼“å­˜ä¸­åº”è¯¥çœ‹åˆ°84 - 100%çš„å‘½ä¸­ç‡ï¼Œå› æ­¤ä¼˜åŒ–å‘½ä¸­è·¯å¾„å¯¹æ€§èƒ½è‡³å…³é‡è¦ã€‚æœ€åï¼Œmakeæ˜¯å”¯ä¸€å…·æœ‰æ˜¾è‘—è´Ÿdentriesæ¯”ä¾‹(å¤§çº¦20%)çš„åº”ç”¨ç¨‹åºï¼Œè¿™æ˜¯æ„æ–™ä¹‹ä¸­çš„ï¼Œå› ä¸ºå®ƒæ­£åœ¨åˆ›å»ºæ–°çš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ Server Applications ä¸€ä¸ªç»å¸¸ä½¿ç”¨readdirçš„è½¯ä»¶ç¤ºä¾‹æ˜¯ä½¿ç”¨MailDirå­˜å‚¨æ ¼å¼çš„IMAPé‚®ä»¶æœåŠ¡å™¨ã€‚æˆ‘ä»¬é€šè¿‡ä¸ºå®¢æˆ·æœºåˆ›å»º10ä¸ªé‚®ç®±æ¥æµ‹è¯•Dovecot IMAPæœåŠ¡å™¨ã€‚æˆ‘ä»¬ä½¿ç”¨å®¢æˆ·ç«¯è„šæœ¬éšæœºé€‰æ‹©ä¸åŒé‚®ç®±ä¸­çš„æ¶ˆæ¯ï¼Œå¹¶å°†å…¶æ ‡è®°ä¸ºå·²è¯»ã€å·²æ ‡è®°æˆ–æœªæ ‡è®°ã€‚åœ¨å†…éƒ¨ï¼Œæ ‡è®°é‚®ä»¶ä¼šå¯¼è‡´é‡å‘½åæ–‡ä»¶ï¼Œå¹¶é‡æ–°è¯»å–ç›®å½•ã€‚ä¸ºäº†æ¶ˆé™¤ç½‘ç»œå»¶è¿Ÿï¼Œæˆ‘ä»¬åœ¨æœ¬åœ°ä¸»æœºä¸Šè¿è¡Œç½‘ç»œæµ‹è¯•;åœ¨å®é™…éƒ¨ç½²ä¸­ï¼Œç½‘ç»œå»¶è¿Ÿå¯èƒ½ä¼šæ©ç›–å®¢æˆ·ç«¯çš„è¿™äº›æ”¹è¿›ï¼Œä½†æœåŠ¡å™¨çš„è´Ÿè½½ä»ç„¶ä¼šå‡å°‘ã€‚ å›¾10æ˜¾ç¤ºäº†Dovecoté‚®ä»¶æœåŠ¡å™¨åœ¨ä¸¤ä¸ªå†…æ ¸ä¸Šçš„ååé‡ã€‚åœ¨ä¸¤ä¸ªå†…æ ¸ä¸Šçš„ååé‡ï¼›æ”¹è¿›èŒƒå›´ä¸º7.8-12.2%ã€‚ä¸readdirå¾®åŸºå‡†ç›¸å‘¼åº”ï¼Œè¾ƒå¤§çš„ ç›®å½•é€šå¸¸ä¼šæœ‰æ›´å¤§çš„æ”¹å–„ï¼Œåœ¨10%çš„æ”¶ç›Šä¸­è¶‹äºå¹³ç¨³ã€‚æˆ‘ä»¬åŒæ ·ä½¿ç”¨ApacheåŸºå‡†æµ‹è¯•æ¥é”»ç‚¼Apacheç½‘ç»œæœåŠ¡å™¨ç”Ÿæˆæ–‡ä»¶åˆ—è¡¨çš„èƒ½åŠ›ï¼ˆè¡¨3ï¼‰ã€‚è¿™äº›é¡µé¢æ²¡æœ‰è¢«Apacheç¼“å­˜ï¼Œè€Œæ˜¯ä¸ºæ¯ä¸ªè¯·æ±‚åŠ¨æ€åœ°ç”Ÿæˆã€‚æ€»çš„æ¥è¯´ï¼Œè¿™äº›ç»“æœè¡¨æ˜ï¼Œreaddirç¼“å­˜ç­–ç•¥å¯ä»¥å‡å°‘æœåŠ¡å™¨çš„è´Ÿè½½æˆ–æé«˜æœåŠ¡å™¨çš„ååé‡ã€‚ Code Changesä¸ºäº†ä¼°è®¡é‡‡ç”¨çš„éš¾åº¦ï¼Œè¡¨4åˆ—å‡ºäº†LinuxåŸå‹ä¸­æ›´æ”¹çš„ä»£ç è¡Œã€‚æ‰€éœ€çš„ç»å¤§å¤šæ•°æ›´æ”¹(å¤§çº¦1,000ä¸ªLoC)æ˜¯æœ¬åœ°åŒ–åˆ°dcacheæœ¬èº«çš„é’©å­(dcache.cå’Œname .c);å¤§å¤šæ•°è¿™äº›ä¼˜åŒ–éƒ½åœ¨ä¸€ç»„å•ç‹¬çš„æ–‡ä»¶ä¸­ï¼Œæ€»è®¡çº¦2,400ä¸ªLoCã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬æµ‹è¯•çš„ä½çº§æ–‡ä»¶ç³»ç»Ÿä¸éœ€è¦ä»»ä½•æ›´æ”¹å°±å¯ä»¥ä½¿ç”¨ä¿®æ”¹åçš„ç›®å½•ç¼“å­˜ã€‚å¯¹å…¶ä»–å­ç³»ç»Ÿçš„ä¸»è¦å½±å“å®é™…ä¸Šæ˜¯å¯¹lsmçš„å½±å“ï¼Œè¿™éœ€è¦ä¸€äº›æ›´æ”¹æ¥æ­£ç¡®åœ°ç®¡ç†pccã€‚å› æ­¤ï¼Œé‡‡ç”¨å…¶ä»–å†…æ ¸å­ç³»ç»Ÿçš„è´Ÿæ‹…éå¸¸å°ã€‚ Discussion and Future Workå¦‚æœæ„¿æ„ç‰ºç‰²å®Œå…¨å‘åå…¼å®¹æ€§æ¥æœ€å¤§åŒ–æŸ¥æ‰¾æ€§èƒ½ï¼Œé‚£ä¹ˆæ”¹è¿›çš„ä¸»è¦æœºä¼šå®é™…ä¸Šå¯èƒ½æ˜¯ä¸ºåŸºäºè·¯å¾„çš„è°ƒç”¨è®¾è®¡ä¸€ä¸ªæ›´ç®€å•çš„æ¥å£ã€‚ æ­£å¦‚ä¸Šé¢çš„è¯„ä»·æ‰€ç¤ºï¼Œåœ¨è¿™ç§è®¾è®¡ä¸­ï¼Œæœ‰å‡ ä¸ªLinux&#x2F;POSIXç‰¹æ€§çš„æ”¯æŒæˆæœ¬è¿‡é«˜ã€‚ä¾‹å¦‚ï¼Œå®ç°Plan 9é£æ ¼çš„è¯æ³•è·¯å¾„è¯­ä¹‰å¯ä»¥æ˜¾è‘—æ”¹å–„æŸ¥æ‰¾å¸¦æœ‰â€œdot dotâ€çš„è·¯å¾„ã€‚ç±»ä¼¼åœ°ï¼Œå·¥ä½œç›®å½•è¯­ä¹‰è¦æ±‚æ…¢è·¯å¾„éå†ã€‚å¯ä»¥è¯´ï¼Œåœ¨è¿™äº›ç‚¹ä¸Šï¼Œç‰¹å®šçš„å®ç°é€‰æ‹©å·²ç»â€œæ³„éœ²â€åˆ°æ¥å£è§„èŒƒä¸­ï¼Œå¹¶ä¸”è¿™äº›ç‰¹æ€§é™åˆ¶äº†æ”¯æŒæ•°æ®ç»“æ„çš„é€‰æ‹©ã€‚æˆ‘ä»¬å»ºè®®ä½¿ç”¨å°½å¯èƒ½ç®€å•å’Œæ— çŠ¶æ€çš„æ¥å£;è¿™ä¸ªå»ºè®®ä¸å…¶ä»–å…³äºå¯ä¼¸ç¼©æ€§çš„å»ºè®®ä¸€è‡´ã€‚ Linuxé™æ€åœ°é€‰æ‹©å“ˆå¸Œè¡¨ä¸­çš„bucketsæ•°(é»˜è®¤æƒ…å†µä¸‹ä¸º262,144)ã€‚å¦‚æœæ²¡æœ‰å¾ˆå¥½åœ°é€‰æ‹©è¿™ä¸ªæ•°å­—ï¼Œæˆ–è€…éœ€æ±‚éšç€æ—¶é—´çš„æ¨ç§»è€Œå˜åŒ–ï¼Œåˆ™ä¼šæµªè´¹ç©ºé—´æˆ–bucketé“¾å˜é•¿ï¼Œä»è€ŒæŸå®³æŸ¥æ‰¾æ€§èƒ½ã€‚ åœ¨æˆ‘ä»¬çš„æµ‹è¯•ç³»ç»Ÿä¸­ï¼Œ58%çš„bucketæ˜¯ç©ºçš„ï¼Œ34%æœ‰ä¸€ä¸ªæ¡ç›®ï¼Œ7%æœ‰ä¸¤ä¸ªæ¡ç›®ï¼Œ1%æœ‰3-10ä¸ªæ¡ç›®ï¼Œè¿™è¡¨æ˜æœ‰æœºä¼šæ”¹è¿›æŸ¥æ‰¾æ—¶é—´å’Œç©ºé—´ä½¿ç”¨ã€‚è¿‘å¹´æ¥å¼€å‘äº†è®¸å¤šé«˜æ€§èƒ½å“ˆå¸Œè¡¨ï¼Œå®ƒä»¬å¯¹æœç´¢æ—¶é—´å’Œæµªè´¹çš„ç©ºé—´æ–½åŠ äº†æ’å®šçš„é™åˆ¶ã€‚ Related Workå¤§å¤šæ•°æé«˜ç›®å½•ç¼“å­˜æ•ˆç‡çš„ç›¸å…³å·¥ä½œéƒ½æ˜¯é’ˆå¯¹ä¸¤ä¸ªç›¸äº’æ­£äº¤çš„é—®é¢˜:å‡å°‘ä¸¢å¤±å»¶è¿Ÿå’Œé¢„å–æ¡ç›®ã€‚æœ€ç±»ä¼¼äºæˆ‘ä»¬è®°å¿†å‰ç¼€æ£€æŸ¥ç»“æœçš„ä¼˜åŒ–ï¼ŒSQL Serverç¼“å­˜å¯¹è±¡æœ€è¿‘è®¿é—®æ§åˆ¶æ£€æŸ¥çš„ç»“æœã€‚ Reducing Miss Latency å‡å°‘é—æ¼å»¶è¿Ÿçš„ä¸€ä¸ªç›¸å…³ç­–ç•¥æ˜¯å°†æ‰€æœ‰è¦æŸ¥æ‰¾çš„ç»„ä»¶ä¸€æ¬¡æ€§ä¼ é€’ç»™ä½çº§æ–‡ä»¶ç³»ç»Ÿï¼Œæœ¬è´¨ä¸Šæ˜¯åˆ›å»ºä¸€ä¸ªé¢„å–æç¤ºã€‚ä¸€äº›ç½‘ç»œæ–‡ä»¶ç³»ç»Ÿå·²ç»è§‚å¯Ÿåˆ°ï¼Œç»„ä»¶ä¸€æ¬¡æŸ¥æ‰¾ä¼šä¸ºæ¯ä¸ªç»„ä»¶ç”Ÿæˆä¸€æ¡å¾€è¿”æ¶ˆæ¯ï¼Œè€Œæ›´æœ‰æ•ˆçš„ç­–ç•¥æ˜¯å°†ä¸€ä¸ªæ¶ˆæ¯ä¸­çš„æŒ‚è½½ç‚¹ä¸‹çš„æ‰€æœ‰ç»„ä»¶ä¼ é€’ç»™æœåŠ¡å™¨è¿›è¡ŒæŸ¥æ‰¾ã€‚ç±»ä¼¼çš„è®ºç‚¹ä¹Ÿé€‚ç”¨äºæœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼Œé€šè¿‡çŸ¥é“å®Œæ•´çš„æŸ¥æ‰¾ç›®æ ‡ï¼Œå¯ä»¥æ›´æœ‰æ•ˆåœ°ä»ç£ç›˜è·å–å…ƒæ•°æ®ç´¢å¼•ã€‚å› æ­¤ï¼ŒWindows NTå’ŒSolarisé‡‡ç”¨äº†è¿™ç§åˆ†å·¥ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœä¸å°†å…¶ä½œä¸ºé¢„å–â€œæç¤ºâ€ï¼Œè¿™å¯èƒ½ä¼šå°†å¤§é‡VFSåŠŸèƒ½æ¨å…¥æ¯ä¸ªä½çº§æ–‡ä»¶ç³»ç»Ÿï¼Œä¾‹å¦‚å¤„ç†æŒ‚è½½ç‚¹çš„é‡å®šå‘ã€ç¬¦å·é“¾æ¥å’Œæƒé™æ£€æŸ¥ã€‚Chenç­‰äººæ³¨æ„åˆ°ï¼Œå°†æƒé™æ£€æŸ¥ä»VFSå±‚å‘ä¸‹æ¨åˆ°å•ä¸ªæ–‡ä»¶ç³»ç»Ÿæ˜¯Linuxä¸­éš¾ä»¥é˜²æ­¢çš„å†…æ ¸bugçš„ä¸€ä¸ªé‡è¦æ¥æºã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œè¿™ä¸ªé¡¹ç›®ç¼“å­˜å…ˆå‰çš„å‰ç¼€æ£€æŸ¥ç»“æœï¼Œä»¥å‡å°‘å†…å­˜ä¸­å·²ç»å­˜åœ¨çš„è·¯å¾„çš„å‘½ä¸­å»¶è¿Ÿï¼Œè€Œä¸æ˜¯ä½¿ç”¨å®Œæ•´è·¯å¾„ä½œä¸ºé¢„å–æç¤ºã€‚ å¦ä¸€ç§æ™®éå­˜åœ¨çš„å»¶è¿Ÿå‡å°‘ç­–ç•¥æ˜¯å°†å…ƒæ•°æ®æŒä¹…åœ°å­˜å‚¨åœ¨æ•£åˆ—è¡¨ä¸­ã€‚ä¸ºäº†å‡å°‘ç½‘ç»œæµé‡ï¼Œä¸€äº›åˆ†å¸ƒå¼æ–‡ä»¶ç³»ç»Ÿã€é›†ç¾¤ç¯å¢ƒå’ŒåŸºäºäº‘çš„åº”ç”¨ç¨‹åºå·²ç»ä½¿ç”¨å…ƒæ•°æ®æ•£åˆ—æ¥ç¡®å®šåœ°å°†å…ƒæ•°æ®æ˜ å°„åˆ°èŠ‚ç‚¹ï¼Œä»è€Œæ¶ˆé™¤äº†å¯¹ç›®å½•æœåŠ¡çš„éœ€æ±‚ã€‚ç›´æ¥æŸ¥æ‰¾æ–‡ä»¶ç³»ç»Ÿ(Direct Lookup File System, DLFS)æœ¬è´¨ä¸Šæ˜¯å°†æ•´ä¸ªç£ç›˜ç»„ç»‡æˆä¸€ä¸ªå“ˆå¸Œè¡¨ï¼ŒæŒ‰ç…§æ–‡ä»¶ç³»ç»Ÿå†…çš„è·¯å¾„è¿›è¡Œé”®æ§ï¼Œä»¥ä¾¿æŸ¥æ‰¾åªæœ‰ä¸€ä¸ªI&#x2F;Oçš„æ–‡ä»¶ã€‚å°†ç£ç›˜ç»„ç»‡ä¸ºæ•£åˆ—è¡¨ä¼šå¸¦æ¥ä¸€äº›æŒ‘æˆ˜ï¼Œä¾‹å¦‚å°†ç›®å½•é‡å‘½åè½¬æ¢ä¸ºæ•°æ®å’Œå…ƒæ•°æ®çš„æ·±åº¦é€’å½’å‰¯æœ¬ã€‚DLFSé€šè¿‡å°†çˆ¶æƒé™è¡¨ç¤ºä¸ºå°é—­å½¢å¼è¡¨è¾¾å¼æ¥è§£å†³å‰ç¼€æ£€æŸ¥é—®é¢˜;è¿™ç§æ–¹æ³•æœ¬è´¨ä¸Šæ˜¯ç¡¬ç¼–ç ä¼ ç»Ÿçš„Unixè‡ªç”±è®¿é—®æ§åˆ¶ï¼Œå¹¶ä¸”ä¸å®¹æ˜“æ‰©å±•åˆ°Linuxå®‰å…¨æ¨¡å—ã€‚æˆ‘ä»¬å·¥ä½œçš„ä¸€ä¸ªé‡è¦è§è§£æ˜¯ï¼Œå†…å­˜ä¸­çš„å…¨è·¯å¾„å“ˆå¸Œï¼Œè€Œä¸æ˜¯ç£ç›˜ä¸Šçš„ï¼Œå¯ä»¥å®ç°ç±»ä¼¼çš„æ€§èƒ½æå‡ï¼Œä½†æ²¡æœ‰è¿™äº›å¯ç”¨æ€§é—®é¢˜ï¼Œä¾‹å¦‚é‡å‘½åæ—¶çš„æ·±åº¦ç›®å½•å¤åˆ¶æˆ–æ›´æ–°å­ç›®å½•æƒé™æ—¶å®¹æ˜“å‡ºé”™çš„å¯å‘å¼æ–¹æ³•ã€‚ VFS Cache Profetching ä¸€äº›æ–‡ä»¶ç³»ç»Ÿä¼˜åŒ–äº†readdiråè·Ÿstatä»¥è®¿é—®å­ç›®å½•å…ƒæ•°æ®çš„æƒ…å†µï¼Œä¾‹å¦‚ä½¿ç”¨ls -lå‘½ä»¤ã€‚å½“è¯·æ±‚è¯»å–ç›®å½•æ—¶ï¼Œè¿™äº›ä½çº§æ–‡ä»¶ç³»ç»Ÿæ¨æµ‹æ€§åœ°å°†æ–‡ä»¶ç´¢å¼•èŠ‚ç‚¹(é€šå¸¸ä½äºç›¸å¯¹è¾ƒè¿‘çš„ç£ç›˜æ‰‡åŒº)è¯»å–åˆ°ç§æœ‰å†…å­˜ç¼“å­˜ä¸­ï¼Œéšåçš„æŸ¥æ‰¾æˆ–statè¯·æ±‚å°†ä»è¯¥ç¼“å­˜ä¸­å¾—åˆ°æœåŠ¡ã€‚ç±»ä¼¼åœ°ï¼ŒNFSç‰ˆæœ¬2åè®®åŒ…æ‹¬ä¸€ä¸ªREADDIRPLUSæ“ä½œï¼Œå®ƒåœ¨ä¸€æ¬¡æ¶ˆæ¯å¾€è¿”ä¸­è¯·æ±‚æ‰€æœ‰å­èŠ‚ç‚¹çš„ç›®å½•å†…å®¹å’Œå±æ€§ã€‚è¿™äº›æ–‡ä»¶ç³»ç»Ÿå¿…é¡»å®ç°å®ƒä»¬è‡ªå·±çš„å¯å‘å¼æ–¹æ³•æ¥ç®¡ç†è¿™ä¸ªç¼“å­˜ã€‚é¢„å–ä¸æˆ‘ä»¬çš„å·¥ä½œæ˜¯æ­£äº¤çš„ï¼Œå®ƒæ›´æœ‰æ•ˆåœ°ç¼“å­˜å·²ç»ä»ä½çº§æ–‡ä»¶ç³»ç»Ÿè¯·æ±‚çš„å†…å®¹ã€‚ Conclusionæœ¬æ–‡æå‡ºäº†ä¸€ç§ç›®å½•ç¼“å­˜è®¾è®¡ï¼Œå¯ä»¥æœ‰æ•ˆåœ°å°†æ–‡ä»¶è·¯å¾„æ˜ å°„åˆ°æ“ä½œç³»ç»Ÿå†…æ ¸ä¸­çš„å†…å­˜æ•°æ®ç»“æ„ã€‚æˆ‘ä»¬çš„è®¾è®¡å°†ç›®å½•ç¼“å­˜åˆ†è§£ä¸ºå•ç‹¬çš„ç¼“å­˜ï¼Œç”¨äºæƒé™æ£€æŸ¥å’Œè·¯å¾„ç´¢å¼•ï¼Œæ”¯æŒå•æ­¥è·¯å¾„æŸ¥æ‰¾ï¼Œå¹¶ä¿ƒè¿›åŸºäºç­¾åå’Œç¼“å­˜ç¬¦å·é“¾æ¥è§£æçš„æ–°ä¼˜åŒ–ã€‚å¯¹äºç»å¸¸ä¸æ–‡ä»¶ç³»ç»Ÿç›®å½•æ ‘äº¤äº’çš„åº”ç”¨ç¨‹åºï¼Œè¿™äº›ä¼˜åŒ–æœ€å¤šå¯ä»¥å°†æ€§èƒ½æé«˜29%ã€‚æˆ‘ä»¬çš„ä¼˜åŒ–ä¿æŒäº†ä¸ä¸€ç³»åˆ—åº”ç”¨ç¨‹åºå’Œå†…æ ¸æ‰©å±•çš„å…¼å®¹æ€§ï¼Œä½¿å®ƒä»¬é€‚åˆå®é™…éƒ¨ç½²ã€‚","categories":[{"name":"è®ºæ–‡ç²¾è¯»","slug":"è®ºæ–‡ç²¾è¯»","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"å†…æ ¸å®‰å…¨","slug":"è®ºæ–‡ç²¾è¯»/å†…æ ¸å®‰å…¨","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"æ–‡ä»¶ç³»ç»Ÿ","slug":"æ–‡ä»¶ç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++å­¦ä¹  é¡¹ç›®å®æˆ˜ webserver","slug":"C++-å­¦ä¹ -é¡¹ç›®å®æˆ˜-webserver","date":"2023-06-05T04:43:53.000Z","updated":"2023-07-28T09:36:40.372Z","comments":true,"path":"2023/06/05/C++-å­¦ä¹ -é¡¹ç›®å®æˆ˜-webserver/","link":"","permalink":"http://example.com/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/","excerpt":"é˜»å¡å’Œéé˜»å¡ã€åŒæ­¥å’Œå¼‚æ­¥ï¼ˆç½‘ç»œIOï¼‰å…¸å‹çš„ä¸€æ¬¡IOçš„ä¸¤ä¸ªé˜¶æ®µæ˜¯ä»€ä¹ˆï¼Ÿ æ•°æ®å°±ç»ªï¼šæ ¹æ®ç³»ç»ŸIOæ“ä½œçš„å°±ç»ª é˜»å¡ - è°ƒç”¨IOæ–¹æ³•çš„çº¿ç¨‹è¿›å…¥é˜»å¡çŠ¶æ€ 12ssize_t recv(int sockfd, void* buf, size_t len,int flags);interesting éé˜»å¡ - ä¸ä¼šæ”¹å˜è¿›ç¨‹çš„çŠ¶æ€ï¼Œé€šè¿‡è¿”å›å€¼åˆ¤æ–­ æ•°æ®è¯»å†™ï¼šæ ¹æ®åº”ç”¨ç¨‹åºå’Œå†…æ ¸çš„äº¤äº’æ–¹å¼ åŒæ­¥ å¼‚æ­¥","text":"é˜»å¡å’Œéé˜»å¡ã€åŒæ­¥å’Œå¼‚æ­¥ï¼ˆç½‘ç»œIOï¼‰å…¸å‹çš„ä¸€æ¬¡IOçš„ä¸¤ä¸ªé˜¶æ®µæ˜¯ä»€ä¹ˆï¼Ÿ æ•°æ®å°±ç»ªï¼šæ ¹æ®ç³»ç»ŸIOæ“ä½œçš„å°±ç»ª é˜»å¡ - è°ƒç”¨IOæ–¹æ³•çš„çº¿ç¨‹è¿›å…¥é˜»å¡çŠ¶æ€ 12ssize_t recv(int sockfd, void* buf, size_t len,int flags);interesting éé˜»å¡ - ä¸ä¼šæ”¹å˜è¿›ç¨‹çš„çŠ¶æ€ï¼Œé€šè¿‡è¿”å›å€¼åˆ¤æ–­ æ•°æ®è¯»å†™ï¼šæ ¹æ®åº”ç”¨ç¨‹åºå’Œå†…æ ¸çš„äº¤äº’æ–¹å¼ åŒæ­¥ å¼‚æ­¥ é˜»å¡å’Œéé˜»å¡éƒ½æ˜¯åŒæ­¥çš„IOï¼Œåªæœ‰ä½¿ç”¨äº†ç‰¹æ®Šçš„APIæ‰æ˜¯å¼‚æ­¥IO å¼‚æ­¥ä¸€èˆ¬ä¸éé˜»å¡ç»“åˆä½¿ç”¨ ä¸€ä¸ªå…¸å‹çš„ç½‘ç»œIOæ¥å£è°ƒç”¨ï¼Œåˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼Œåˆ†åˆ«æ˜¯â€œæ•°æ®å°±ç»ªâ€ å’Œ â€œæ•°æ®è¯»å†™â€ï¼Œæ•°æ®å°±ç»ªé˜¶æ®µåˆ†ä¸ºé˜»å¡å’Œéé˜»å¡ï¼Œè¡¨ç°å¾—ç»“æœå°±æ˜¯ï¼Œé˜»å¡å½“å‰çº¿ç¨‹æˆ–æ˜¯ç›´æ¥è¿”å›ã€‚åŒæ­¥è¡¨ç¤ºAå‘Bè¯·æ±‚è°ƒç”¨ä¸€ä¸ªç½‘ç»œIOæ¥å£æ—¶ï¼ˆæˆ–è€…è°ƒç”¨æŸä¸ªä¸šåŠ¡é€»è¾‘APIæ¥å£æ—¶ï¼‰ï¼Œæ•°æ®çš„è¯»å†™éƒ½æ˜¯ç”±è¯·æ±‚æ–¹Aè‡ªå·±æ¥å®Œæˆçš„ï¼ˆä¸ç®¡æ˜¯é˜»å¡è¿˜æ˜¯éé˜»å¡ï¼‰ï¼›å¼‚æ­¥è¡¨ç¤ºAå‘Bè¯·æ±‚è°ƒç”¨ä¸€ä¸ªç½‘ç»œIOæ¥å£æ—¶ï¼ˆæˆ–è€…è°ƒç”¨æŸä¸ªä¸šåŠ¡é€»è¾‘APIæ¥å£æ—¶ï¼‰ï¼Œå‘Bä¼ å…¥è¯·æ±‚çš„äº‹ä»¶ä»¥åŠäº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥çš„æ–¹å¼ï¼ŒAå°±å¯ä»¥å¤„ç†å…¶å®ƒé€»è¾‘äº†ï¼Œå½“Bç›‘å¬åˆ°äº‹ä»¶å¤„ç†å®Œæˆåï¼Œä¼šç”¨äº‹å…ˆçº¦å®šå¥½çš„é€šçŸ¥æ–¹å¼ï¼Œé€šçŸ¥Aå¤„ç†ç»“æœã€‚ Unixã€Linuxä¸Šçš„äº”ç§IOæ¨¡å‹é˜»å¡blockingè°ƒç”¨è€…è°ƒç”¨äº†æŸä¸ªå‡½æ•°ï¼Œç­‰å¾…è¿™ä¸ªå‡½æ•°è¿”å›ï¼ŒæœŸé—´ä»€ä¹ˆä¹Ÿä¸åšï¼Œä¸åœçš„å»æ£€æŸ¥è¿™ä¸ªå‡½æ•°æœ‰æ²¡æœ‰è¿”å›ï¼Œå¿…é¡»ç­‰è¿™ä¸ªå‡½æ•°è¿”å›æ‰èƒ½è¿›è¡Œä¸‹ä¸€æ­¥åŠ¨ä½œã€‚ éé˜»å¡non-blockingï¼ˆNIOï¼‰éé˜»å¡ç­‰å¾…ï¼Œæ¯éš”ä¸€æ®µæ—¶é—´å°±å»æ£€æµ‹IOäº‹ä»¶æ˜¯å¦å°±ç»ªã€‚æ²¡æœ‰å°±ç»ªå°±å¯ä»¥åšå…¶ä»–äº‹ã€‚éé˜»å¡I&#x2F;Oæ‰§è¡Œç³»ç»Ÿè°ƒç”¨æ€»æ˜¯ç«‹å³è¿”å›ï¼Œä¸ç®¡äº‹ä»¶æ˜¯å¦å·²ç»å‘ç”Ÿï¼Œè‹¥äº‹ä»¶æ²¡æœ‰å‘ç”Ÿï¼Œåˆ™è¿”å›-1ï¼Œæ­¤æ—¶å¯ä»¥æ ¹æ® errno åŒºåˆ†è¿™ä¸¤ç§æƒ…å†µï¼Œå¯¹äºacceptï¼Œrecv å’Œ sendï¼Œäº‹ä»¶æœªå‘ç”Ÿæ—¶ï¼Œerrno é€šå¸¸è¢«è®¾ç½®æˆ EAGAINã€‚ IOå¤ç”¨ï¼ˆIO multiplexingï¼‰Linux ç”¨ select&#x2F;poll&#x2F;epoll å‡½æ•°å®ç° IO å¤ç”¨æ¨¡å‹ï¼Œè¿™äº›å‡½æ•°ä¹Ÿä¼šä½¿è¿›ç¨‹é˜»å¡ï¼Œä½†æ˜¯å’Œé˜»å¡IOæ‰€ä¸åŒçš„æ˜¯è¿™äº›å‡½æ•°å¯ä»¥åŒæ—¶é˜»å¡å¤šä¸ªIOæ“ä½œã€‚è€Œä¸”å¯ä»¥åŒæ—¶å¯¹å¤šä¸ªè¯»æ“ä½œã€å†™æ“ä½œçš„IOå‡½æ•°è¿›è¡Œæ£€æµ‹ã€‚ç›´åˆ°æœ‰æ•°æ®å¯è¯»æˆ–å¯å†™æ—¶ï¼Œæ‰çœŸæ­£è°ƒç”¨IOæ“ä½œå‡½æ•° ä¿¡å·é©±åŠ¨ï¼ˆsignal-drivenï¼‰Linux ç”¨å¥—æ¥å£è¿›è¡Œä¿¡å·é©±åŠ¨ IOï¼Œå®‰è£…ä¸€ä¸ªä¿¡å·å¤„ç†å‡½æ•°ï¼Œè¿›ç¨‹ç»§ç»­è¿è¡Œå¹¶ä¸é˜»å¡ï¼Œå½“IOäº‹ä»¶å°±ç»ªï¼Œè¿›ç¨‹æ”¶åˆ°SIGIO ä¿¡å·ï¼Œç„¶åå¤„ç† IO äº‹ä»¶ã€‚ å†…æ ¸åœ¨ç¬¬ä¸€ä¸ªé˜¶æ®µæ˜¯å¼‚æ­¥ï¼Œåœ¨ç¬¬äºŒä¸ªé˜¶æ®µæ˜¯åŒæ­¥ï¼›ä¸éé˜»å¡IOçš„åŒºåˆ«åœ¨äºå®ƒæä¾›äº†æ¶ˆæ¯é€šçŸ¥æœºåˆ¶ï¼Œä¸éœ€è¦ç”¨æˆ·è¿›ç¨‹ä¸æ–­çš„è½®è¯¢æ£€æŸ¥ï¼Œå‡å°‘äº†ç³»ç»ŸAPIçš„è°ƒç”¨æ¬¡æ•°ï¼Œæé«˜äº†æ•ˆç‡ã€‚ å¼‚æ­¥ï¼ˆasynchronousï¼‰Linuxä¸­ï¼Œå¯ä»¥è°ƒç”¨ aio_read å‡½æ•°å‘Šè¯‰å†…æ ¸æè¿°å­—ç¼“å†²åŒºæŒ‡é’ˆå’Œç¼“å†²åŒºçš„å¤§å°ã€æ–‡ä»¶åç§»åŠé€šçŸ¥çš„æ–¹å¼ï¼Œç„¶åç«‹å³è¿”å›ï¼Œå½“å†…æ ¸å°†æ•°æ®æ‹·è´åˆ°ç¼“å†²åŒºåï¼Œå†é€šçŸ¥åº”ç”¨ç¨‹åº 1234567891011121314151617181920212223/* Asynchronous I/O control block. */struct aiocb&#123;int aio_fildes; /* File desriptor. */int aio_lio_opcode; /* Operation to be performed. */int aio_reqprio; /* Request priority offset. */volatile void *aio_buf; /* Location of buffer. */size_t aio_nbytes; /* Length of transfer. */struct sigevent aio_sigevent; /* Signal number and value. *//* Internal members. */struct aiocb *__next_prio;int __abs_prio;int __policy;int __error_code;__ssize_t __return_value;#ifndef __USE_FILE_OFFSET64__off_t aio_offset; /* File offset. */char __pad[sizeof (__off64_t) - sizeof (__off_t)];#else__off64_t aio_offset; /* File offset. */#endifchar __glibc_reserved[32];&#125;; Webserverç®€ä»‹å’ŒHTTPåè®®Webserverï¼ˆç½‘é¡µæœåŠ¡å™¨ï¼‰ä¸€ä¸ª Web Server å°±æ˜¯ä¸€ä¸ªæœåŠ¡å™¨è½¯ä»¶ï¼ˆç¨‹åºï¼‰ï¼Œæˆ–è€…æ˜¯è¿è¡Œè¿™ä¸ªæœåŠ¡å™¨è½¯ä»¶çš„ç¡¬ä»¶ï¼ˆè®¡ç®—æœºï¼‰ã€‚å…¶ä¸»è¦åŠŸèƒ½æ˜¯é€šè¿‡ HTTP åè®®ä¸å®¢æˆ·ç«¯ï¼ˆé€šå¸¸æ˜¯æµè§ˆå™¨ï¼ˆBrowserï¼‰ï¼‰è¿›è¡Œé€šä¿¡ï¼Œæ¥æ¥æ”¶ï¼Œå­˜å‚¨ï¼Œå¤„ç†æ¥è‡ªå®¢æˆ·ç«¯çš„ HTTP è¯·æ±‚ï¼Œå¹¶å¯¹å…¶è¯·æ±‚åšå‡º HTTP å“åº”ï¼Œè¿”å›ç»™å®¢æˆ·ç«¯å…¶è¯·æ±‚çš„å†…å®¹ï¼ˆæ–‡ä»¶ã€ç½‘é¡µç­‰ï¼‰æˆ–è¿”å›ä¸€ä¸ª Error ä¿¡æ¯ã€‚ é€šå¸¸ç”¨æˆ·ä½¿ç”¨ Web æµè§ˆå™¨ä¸ç›¸åº”æœåŠ¡å™¨è¿›è¡Œé€šä¿¡ã€‚åœ¨æµè§ˆå™¨ä¸­é”®å…¥â€œåŸŸåâ€æˆ–â€œIPåœ°å€:ç«¯å£å·â€ï¼Œæµè§ˆå™¨åˆ™å…ˆå°†ä½ çš„åŸŸåè§£ææˆç›¸åº”çš„ IP åœ°å€æˆ–è€…ç›´æ¥æ ¹æ®ä½ çš„IPåœ°å€å‘å¯¹åº”çš„ Web æœåŠ¡å™¨å‘é€ä¸€ä¸ª HTTP è¯·æ±‚ã€‚è¿™ä¸€è¿‡ç¨‹é¦–å…ˆè¦é€šè¿‡ TCP åè®®çš„ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹ä¸ç›®æ ‡ Web æœåŠ¡å™¨çš„è¿æ¥ï¼Œç„¶å HTTP åè®®ç”Ÿæˆé’ˆå¯¹ç›®æ ‡ Web æœåŠ¡å™¨çš„ HTTP è¯·æ±‚æŠ¥æ–‡ï¼Œé€šè¿‡ TCPã€IP ç­‰åè®®å‘é€åˆ°ç›®æ ‡ Web æœåŠ¡å™¨ä¸Šã€‚ HTTPåè®®ï¼ˆåº”ç”¨å±‚åè®®ï¼‰ç®€ä»‹è¶…æ–‡æœ¬ä¼ è¾“åè®®ï¼ˆHypertext Transfer Protocolï¼ŒHTTPï¼‰æ˜¯ä¸€ä¸ªç®€å•çš„è¯·æ±‚ - å“åº”åè®®ï¼Œå®ƒé€šå¸¸è¿è¡Œåœ¨TCP ä¹‹ä¸Šã€‚å®ƒæŒ‡å®šäº†å®¢æˆ·ç«¯å¯èƒ½å‘é€ç»™æœåŠ¡å™¨ä»€ä¹ˆæ ·çš„æ¶ˆæ¯ä»¥åŠå¾—åˆ°ä»€ä¹ˆæ ·çš„å“åº”ã€‚è¯·æ±‚å’Œå“åº”æ¶ˆæ¯çš„å¤´ä»¥ ASCII å½¢å¼ç»™å‡ºï¼›è€Œæ¶ˆæ¯å†…å®¹åˆ™å…·æœ‰ä¸€ä¸ªç±»ä¼¼ MIME çš„æ ¼å¼ã€‚HTTPæ˜¯ä¸‡ç»´ç½‘çš„æ•°æ®é€šä¿¡çš„åŸºç¡€ã€‚HTTPçš„å‘å±•æ˜¯ç”±è’‚å§†Â·ä¼¯çº³æ–¯-æäº1989å¹´åœ¨æ¬§æ´²æ ¸å­ç ”ç©¶ç»„ç»‡ï¼ˆCERNï¼‰æ‰€å‘èµ·ã€‚HTTPçš„æ ‡å‡†åˆ¶å®šç”±ä¸‡ç»´ç½‘åä¼šï¼ˆWorld Wide Web Consortiumï¼ŒW3Cï¼‰å’Œäº’è”ç½‘å·¥ç¨‹ä»»åŠ¡ï¼ˆInternet Engineering Task Forceï¼ŒIETFï¼‰è¿›è¡Œåè°ƒï¼Œæœ€ç»ˆå‘å¸ƒäº†ä¸€ç³»åˆ—çš„RFCï¼Œå…¶ä¸­æœ€è‘—åçš„1999å¹´6æœˆå…¬å¸ƒçš„ RFC 2616ï¼Œå®šä¹‰äº†HTTPåè®®ä¸­ç°ä»Šå¹¿æ³›ä½¿ç”¨çš„ä¸€ä¸ªç‰ˆæœ¬â€”â€”HTTP 1.1ã€‚ æ¦‚è¿°HTTP æ˜¯ä¸€ä¸ªå®¢æˆ·ç«¯ç»ˆç«¯ï¼ˆç”¨æˆ·ï¼‰å’ŒæœåŠ¡å™¨ç«¯ï¼ˆç½‘ç«™ï¼‰è¯·æ±‚å’Œåº”ç­”çš„æ ‡å‡†ï¼ˆTCPï¼‰ã€‚é€šè¿‡ä½¿ç”¨ç½‘é¡µæµè§ˆå™¨ã€ç½‘ç»œçˆ¬è™«æˆ–è€…å…¶å®ƒçš„å·¥å…·ï¼Œå®¢æˆ·ç«¯å‘èµ·ä¸€ä¸ªHTTPè¯·æ±‚åˆ°æœåŠ¡å™¨ä¸ŠæŒ‡å®šç«¯å£ï¼ˆé»˜è®¤ç«¯å£ä¸º80ï¼‰ã€‚æˆ‘ä»¬ç§°è¿™ä¸ªå®¢æˆ·ç«¯ä¸ºç”¨æˆ·ä»£ç†ç¨‹åºï¼ˆuser agentï¼‰ã€‚åº”ç­”çš„æœåŠ¡å™¨ä¸Šå­˜å‚¨ç€ä¸€äº›èµ„æºï¼Œæ¯”å¦‚ HTML æ–‡ä»¶å’Œå›¾åƒã€‚æˆ‘ä»¬ç§°è¿™ä¸ªåº”ç­”æœåŠ¡å™¨ä¸ºæºæœåŠ¡å™¨ï¼ˆorigin serverï¼‰ã€‚åœ¨ç”¨æˆ·ä»£ç†å’ŒæºæœåŠ¡å™¨ä¸­é—´å¯èƒ½å­˜åœ¨å¤šä¸ªâ€œä¸­é—´å±‚â€ï¼Œæ¯”å¦‚ä»£ç†æœåŠ¡å™¨ã€ç½‘å…³æˆ–è€…éš§é“ï¼ˆtunnelï¼‰ã€‚ å°½ç®¡ TCP&#x2F;IP åè®®æ˜¯äº’è”ç½‘ä¸Šæœ€æµè¡Œçš„åº”ç”¨ï¼ŒHTTP åè®®ä¸­ï¼Œå¹¶æ²¡æœ‰è§„å®šå¿…é¡»ä½¿ç”¨å®ƒæˆ–å®ƒæ”¯æŒçš„å±‚ã€‚äº‹å®ä¸Šï¼ŒHTTPå¯ä»¥åœ¨ä»»ä½•äº’è”ç½‘åè®®ä¸Šï¼Œæˆ–å…¶ä»–ç½‘ç»œä¸Šå®ç°ã€‚HTTP å‡å®šå…¶ä¸‹å±‚åè®®æä¾›å¯é çš„ä¼ è¾“ã€‚å› æ­¤ï¼Œä»»ä½•èƒ½å¤Ÿæä¾›è¿™ç§ä¿è¯çš„åè®®éƒ½å¯ä»¥è¢«å…¶ä½¿ç”¨ã€‚å› æ­¤ä¹Ÿå°±æ˜¯å…¶åœ¨ TCP&#x2F;IP åè®®æ—ä½¿ç”¨ TCP ä½œä¸ºå…¶ä¼ è¾“å±‚ã€‚é€šå¸¸ï¼Œç”±HTTPå®¢æˆ·ç«¯å‘èµ·ä¸€ä¸ªè¯·æ±‚ï¼Œåˆ›å»ºä¸€ä¸ªåˆ°æœåŠ¡å™¨æŒ‡å®šç«¯å£ï¼ˆé»˜è®¤æ˜¯80ç«¯å£ï¼‰çš„ TCP è¿æ¥ã€‚HTTPæœåŠ¡å™¨åˆ™åœ¨é‚£ä¸ªç«¯å£ç›‘å¬å®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚ä¸€æ—¦æ”¶åˆ°è¯·æ±‚ï¼ŒæœåŠ¡å™¨ä¼šå‘å®¢æˆ·ç«¯è¿”å›ä¸€ä¸ªçŠ¶æ€ï¼Œæ¯”å¦‚â€HTTP&#x2F;1.1 200 OKâ€ï¼Œä»¥åŠè¿”å›çš„å†…å®¹ï¼Œå¦‚è¯·æ±‚çš„æ–‡ä»¶ã€é”™è¯¯æ¶ˆæ¯ã€æˆ–è€…å…¶å®ƒä¿¡æ¯ã€‚ å·¥ä½œåŸç†HTTP åè®®å®šä¹‰ Web å®¢æˆ·ç«¯å¦‚ä½•ä» Web æœåŠ¡å™¨è¯·æ±‚ Web é¡µé¢ï¼Œä»¥åŠæœåŠ¡å™¨å¦‚ä½•æŠŠ Web é¡µé¢ä¼ é€ç»™å®¢æˆ·ç«¯ã€‚HTTP åè®®é‡‡ç”¨äº†è¯·æ±‚&#x2F;å“åº”æ¨¡å‹ã€‚å®¢æˆ·ç«¯å‘æœåŠ¡å™¨å‘é€ä¸€ä¸ªè¯·æ±‚æŠ¥æ–‡ï¼Œè¯·æ±‚æŠ¥æ–‡åŒ…å«è¯·æ±‚çš„æ–¹æ³•ã€URLã€åè®®ç‰ˆæœ¬ã€è¯·æ±‚å¤´éƒ¨å’Œè¯·æ±‚æ•°æ®ã€‚æœåŠ¡å™¨ä»¥ä¸€ä¸ªçŠ¶æ€è¡Œä½œä¸ºå“åº”ï¼Œå“åº”çš„å†…å®¹åŒ…æ‹¬åè®®çš„ç‰ˆæœ¬ã€æˆåŠŸæˆ–è€…é”™è¯¯ä»£ç ã€æœåŠ¡å™¨ä¿¡æ¯ã€å“åº”å¤´éƒ¨å’Œå“åº”æ•°æ®ã€‚ ä»¥ä¸‹æ˜¯ HTTP è¯·æ±‚&#x2F;å“åº”çš„æ­¥éª¤ï¼š å®¢æˆ·ç«¯è¿æ¥åˆ° Web æœåŠ¡å™¨ä¸€ä¸ªHTTPå®¢æˆ·ç«¯ï¼Œé€šå¸¸æ˜¯æµè§ˆå™¨ï¼Œä¸ Web æœåŠ¡å™¨çš„ HTTP ç«¯å£ï¼ˆé»˜è®¤ä¸º 80 ï¼‰å»ºç«‹ä¸€ä¸ª TCP å¥—æ¥å­—è¿æ¥ã€‚ä¾‹å¦‚ï¼Œhttp://www.baidu.comã€‚ï¼ˆURLï¼‰ å‘é€ HTTP è¯·æ±‚é€šè¿‡ TCP å¥—æ¥å­—ï¼Œå®¢æˆ·ç«¯å‘ Web æœåŠ¡å™¨å‘é€ä¸€ä¸ªæ–‡æœ¬çš„è¯·æ±‚æŠ¥æ–‡ï¼Œä¸€ä¸ªè¯·æ±‚æŠ¥æ–‡ç”±è¯·æ±‚è¡Œã€è¯·æ±‚å¤´éƒ¨ã€ç©ºè¡Œå’Œè¯·æ±‚æ•°æ® 4 éƒ¨åˆ†ç»„æˆã€‚ æœåŠ¡å™¨æ¥å—è¯·æ±‚å¹¶è¿”å› HTTP å“åº”Web æœåŠ¡å™¨è§£æè¯·æ±‚ï¼Œå®šä½è¯·æ±‚èµ„æºã€‚æœåŠ¡å™¨å°†èµ„æºå¤æœ¬å†™åˆ° TCP å¥—æ¥å­—ï¼Œç”±å®¢æˆ·ç«¯è¯»å–ã€‚ä¸€ä¸ªå“åº”ç”±çŠ¶æ€è¡Œã€å“åº”å¤´éƒ¨ã€ç©ºè¡Œå’Œå“åº”æ•°æ® 4 éƒ¨åˆ†ç»„æˆã€‚ é‡Šæ”¾è¿æ¥ TCP è¿æ¥è‹¥ connection æ¨¡å¼ä¸º closeï¼Œåˆ™æœåŠ¡å™¨ä¸»åŠ¨å…³é—­ TCPè¿æ¥ï¼Œå®¢æˆ·ç«¯è¢«åŠ¨å…³é—­è¿æ¥ï¼Œé‡Šæ”¾ TCP è¿æ¥ï¼›è‹¥connection æ¨¡å¼ä¸º keepaliveï¼Œåˆ™è¯¥è¿æ¥ä¼šä¿æŒä¸€æ®µæ—¶é—´ï¼Œåœ¨è¯¥æ—¶é—´å†…å¯ä»¥ç»§ç»­æ¥æ”¶è¯·æ±‚; å®¢æˆ·ç«¯æµè§ˆå™¨è§£æ HTML å†…å®¹å®¢æˆ·ç«¯æµè§ˆå™¨é¦–å…ˆè§£æçŠ¶æ€è¡Œï¼ŒæŸ¥çœ‹è¡¨æ˜è¯·æ±‚æ˜¯å¦æˆåŠŸçš„çŠ¶æ€ä»£ç ã€‚ç„¶åè§£ææ¯ä¸€ä¸ªå“åº”å¤´ï¼Œå“åº”å¤´å‘ŠçŸ¥ä»¥ä¸‹ä¸ºè‹¥å¹²å­—èŠ‚çš„ HTML æ–‡æ¡£å’Œæ–‡æ¡£çš„å­—ç¬¦é›†ã€‚å®¢æˆ·ç«¯æµè§ˆå™¨è¯»å–å“åº”æ•°æ® HTMLï¼Œæ ¹æ®HTML çš„è¯­æ³•å¯¹å…¶è¿›è¡Œæ ¼å¼åŒ–ï¼Œå¹¶åœ¨æµè§ˆå™¨çª—å£ä¸­æ˜¾ç¤ºã€‚ ä¾‹å¦‚ï¼šåœ¨æµè§ˆå™¨åœ°å€æ é”®å…¥URLï¼ŒæŒ‰ä¸‹å›è½¦ä¹‹åä¼šç»å†ä»¥ä¸‹æµç¨‹ï¼š æµè§ˆå™¨å‘ DNS æœåŠ¡å™¨è¯·æ±‚è§£æè¯¥ URL ä¸­çš„åŸŸåæ‰€å¯¹åº”çš„ IP åœ°å€; è§£æå‡º IP åœ°å€åï¼Œæ ¹æ®è¯¥ IP åœ°å€å’Œé»˜è®¤ç«¯å£ 80ï¼Œå’ŒæœåŠ¡å™¨å»ºç«‹ TCP è¿æ¥; æµè§ˆå™¨å‘å‡ºè¯»å–æ–‡ä»¶ï¼ˆ URL ä¸­åŸŸååé¢éƒ¨åˆ†å¯¹åº”çš„æ–‡ä»¶ï¼‰çš„ HTTP è¯·æ±‚ï¼Œè¯¥è¯·æ±‚æŠ¥æ–‡ä½œä¸º TCP ä¸‰æ¬¡æ¡æ‰‹çš„ç¬¬ä¸‰ä¸ªæŠ¥æ–‡çš„æ•°æ®å‘é€ç»™æœåŠ¡å™¨; æœåŠ¡å™¨å¯¹æµè§ˆå™¨è¯·æ±‚ä½œå‡ºå“åº”ï¼Œå¹¶æŠŠå¯¹åº”çš„ HTML æ–‡æœ¬å‘é€ç»™æµè§ˆå™¨; é‡Šæ”¾ TCP è¿æ¥; æµè§ˆå™¨å°†è¯¥ HTML æ–‡æœ¬å¹¶æ˜¾ç¤ºå†…å®¹ã€‚ HTTP åè®®æ˜¯åŸºäº TCP&#x2F;IP åè®®ä¹‹ä¸Šçš„åº”ç”¨å±‚åè®®ï¼ŒåŸºäº è¯·æ±‚-å“åº” çš„æ¨¡å¼ã€‚HTTP åè®®è§„å®šï¼Œè¯·æ±‚ä»å®¢æˆ·ç«¯å‘å‡ºï¼Œæœ€åæœåŠ¡å™¨ç«¯å“åº”è¯¥è¯·æ±‚å¹¶è¿”å›ã€‚æ¢å¥è¯è¯´ï¼Œè‚¯å®šæ˜¯å…ˆä»å®¢æˆ·ç«¯å¼€å§‹å»ºç«‹é€šä¿¡çš„ï¼ŒæœåŠ¡å™¨ç«¯åœ¨æ²¡æœ‰æ¥æ”¶åˆ°è¯·æ±‚ä¹‹å‰ä¸ä¼šå‘é€å“åº”ã€‚ HTTPè¯·æ±‚æŠ¥æ–‡ä¸å“åº”æŠ¥æ–‡æ ¼å¼ å¯ä»¥åœ¨æµè§ˆå™¨ç•Œé¢æŒ‰F12æŸ¥çœ‹HTTPæŠ¥æ–‡ HTTPè¯·æ±‚æ–¹æ³•HTTP&#x2F;1.1 åè®®ä¸­å…±å®šä¹‰äº†å…«ç§æ–¹æ³•ï¼ˆä¹Ÿå«â€œåŠ¨ä½œâ€ï¼‰æ¥ä»¥ä¸åŒæ–¹å¼æ“ä½œæŒ‡å®šçš„èµ„æºï¼š GETï¼šå‘æŒ‡å®šçš„èµ„æºå‘å‡ºâ€œæ˜¾ç¤ºâ€è¯·æ±‚ã€‚ä½¿ç”¨ GET æ–¹æ³•åº”è¯¥åªç”¨åœ¨è¯»å–æ•°æ®ï¼Œè€Œä¸åº”å½“è¢«ç”¨äºäº§ç”Ÿâ€œå‰¯ä½œç”¨â€çš„æ“ä½œä¸­ï¼Œä¾‹å¦‚åœ¨ Web Application ä¸­ã€‚å…¶ä¸­ä¸€ä¸ªåŸå› æ˜¯ GET å¯èƒ½ä¼šè¢«ç½‘ç»œèœ˜è››ç­‰éšæ„è®¿é—®ã€‚ HEADï¼šä¸ GET æ–¹æ³•ä¸€æ ·ï¼Œéƒ½æ˜¯å‘æœåŠ¡å™¨å‘å‡ºæŒ‡å®šèµ„æºçš„è¯·æ±‚ã€‚åªä¸è¿‡æœåŠ¡å™¨å°†ä¸ä¼ å›èµ„æºçš„æœ¬æ–‡éƒ¨åˆ†ã€‚å®ƒçš„å¥½å¤„åœ¨äºï¼Œä½¿ç”¨è¿™ä¸ªæ–¹æ³•å¯ä»¥åœ¨ä¸å¿…ä¼ è¾“å…¨éƒ¨å†…å®¹çš„æƒ…å†µä¸‹ï¼Œå°±å¯ä»¥è·å–å…¶ä¸­â€œå…³äºè¯¥èµ„æºçš„ä¿¡æ¯â€ï¼ˆå…ƒä¿¡æ¯æˆ–ç§°å…ƒæ•°æ®ï¼‰ã€‚ POSTï¼šå‘æŒ‡å®šèµ„æºæäº¤æ•°æ®ï¼Œè¯·æ±‚æœåŠ¡å™¨è¿›è¡Œå¤„ç†ï¼ˆä¾‹å¦‚æäº¤è¡¨å•æˆ–è€…ä¸Šä¼ æ–‡ä»¶ï¼‰ã€‚æ•°æ®è¢«åŒ…å«åœ¨è¯·æ±‚æœ¬æ–‡ä¸­ã€‚è¿™ä¸ªè¯·æ±‚å¯èƒ½ä¼šåˆ›å»ºæ–°çš„èµ„æºæˆ–ä¿®æ”¹ç°æœ‰èµ„æºï¼Œæˆ–äºŒè€…çš†æœ‰ã€‚ PUTï¼šå‘æŒ‡å®šèµ„æºä½ç½®ä¸Šä¼ å…¶æœ€æ–°å†…å®¹ã€‚ DELETEï¼šè¯·æ±‚æœåŠ¡å™¨åˆ é™¤ Request-URI æ‰€æ ‡è¯†çš„èµ„æºã€‚ TRACEï¼šå›æ˜¾æœåŠ¡å™¨æ”¶åˆ°çš„è¯·æ±‚ï¼Œä¸»è¦ç”¨äºæµ‹è¯•æˆ–è¯Šæ–­ã€‚ OPTIONSï¼šè¿™ä¸ªæ–¹æ³•å¯ä½¿æœåŠ¡å™¨ä¼ å›è¯¥èµ„æºæ‰€æ”¯æŒçš„æ‰€æœ‰ HTTP è¯·æ±‚æ–¹æ³•ã€‚ç”¨â€™*â€™æ¥ä»£æ›¿èµ„æºåç§°ï¼Œå‘ Web æœåŠ¡å™¨å‘é€ OPTIONS è¯·æ±‚ï¼Œå¯ä»¥æµ‹è¯•æœåŠ¡å™¨åŠŸèƒ½æ˜¯å¦æ­£å¸¸è¿ä½œã€‚ CONNECTï¼šHTTP&#x2F;1.1 åè®®ä¸­é¢„ç•™ç»™èƒ½å¤Ÿå°†è¿æ¥æ”¹ä¸ºç®¡é“æ–¹å¼çš„ä»£ç†æœåŠ¡å™¨ã€‚é€šå¸¸ç”¨äºSSLåŠ å¯†æœåŠ¡å™¨çš„é“¾æ¥ï¼ˆç»ç”±éåŠ å¯†çš„ HTTP ä»£ç†æœåŠ¡å™¨ï¼‰ã€‚ HTTPçŠ¶æ€ç æ‰€æœ‰HTTPå“åº”çš„ç¬¬ä¸€è¡Œéƒ½æ˜¯çŠ¶æ€è¡Œï¼Œä¾æ¬¡æ˜¯å½“å‰HTTPç‰ˆæœ¬å·ï¼Œ3ä½æ•°å­—ç»„æˆçš„çŠ¶æ€ä»£ç ï¼Œä»¥åŠæè¿°çŠ¶æ€çš„çŸ­è¯­ï¼Œå½¼æ­¤ç”±ç©ºæ ¼åˆ†éš”ã€‚çŠ¶æ€ä»£ç çš„ç¬¬ä¸€ä¸ªæ•°å­—ä»£è¡¨å½“å‰å“åº”çš„ç±»å‹ï¼š 1xxæ¶ˆæ¯â€”â€”è¯·æ±‚å·²è¢«æœåŠ¡å™¨æ¥æ”¶ï¼Œç»§ç»­å¤„ç† 2xxæˆåŠŸâ€”â€”è¯·æ±‚å·²æˆåŠŸè¢«æœåŠ¡å™¨æ¥æ”¶ã€ç†è§£ã€å¹¶æ¥å— 3xxé‡å®šå‘â€”â€”éœ€è¦åç»­æ“ä½œæ‰èƒ½å®Œæˆè¿™ä¸€è¯·æ±‚ 4xxè¯·æ±‚é”™è¯¯â€”â€”è¯·æ±‚å«æœ‰è¯æ³•é”™è¯¯æˆ–è€…æ— æ³•è¢«æ‰§è¡Œ 5xxæœåŠ¡å™¨é”™è¯¯â€”â€”æœåŠ¡å™¨åœ¨å¤„ç†æŸä¸ªæ­£ç¡®è¯·æ±‚æ—¶å‘ç”Ÿé”™è¯¯ è™½ç„¶ RFC 2616 ä¸­å·²ç»æ¨èäº†æè¿°çŠ¶æ€çš„çŸ­è¯­ï¼Œä¾‹å¦‚â€200 OKâ€ï¼Œâ€404 Not Foundâ€ï¼Œä½†æ˜¯WEBå¼€å‘è€…ä»ç„¶èƒ½å¤Ÿè‡ªè¡Œå†³å®šé‡‡ç”¨ä½•ç§çŸ­è¯­ï¼Œç”¨ä»¥æ˜¾ç¤ºæœ¬åœ°åŒ–çš„çŠ¶æ€æè¿°æˆ–è€…è‡ªå®šä¹‰ä¿¡æ¯ã€‚ ç±»åˆ« åŸå› çŸ­è¯­ 1XX Informationalï¼ˆä¿¡æ¯æ€§çŠ¶æ€ç ï¼‰ æ¥æ”¶çš„è¯·æ±‚æ­£åœ¨å¤„ç† 2XX Successï¼ˆæˆåŠŸçŠ¶æ€ç ï¼‰ è¯·æ±‚æ­£å¸¸å¤„ç†å®Œæ¯• 3XX Redirectionï¼ˆé‡å®šå‘çŠ¶æ€ç ï¼‰ éœ€è¦è¿›è¡Œé™„åŠ æ“ä½œä»¥å®Œæˆè¯·æ±‚ 4XX Client Errorï¼ˆå®¢æˆ·ç«¯é”™è¯¯çŠ¶æ€ç ï¼‰ æœåŠ¡å™¨æ— æ³•å¤„ç†è¯·æ±‚ 5XX Server Errorï¼ˆæœåŠ¡å™¨é”™è¯¯çŠ¶æ€ç ï¼‰ æœåŠ¡å™¨å¤„ç†è¯·æ±‚å‡ºé”™ æœåŠ¡å™¨ç¼–ç¨‹åŸºæœ¬æ¡†æ¶è™½ç„¶æœåŠ¡å™¨ç¨‹åºç§ç±»ç¹å¤šï¼Œä½†å…¶åŸºæœ¬æ¡†æ¶éƒ½ä¸€æ ·ï¼Œä¸åŒä¹‹å¤„åœ¨äºé€»è¾‘å¤„ç†ã€‚ æ¨¡å— åŠŸèƒ½ I&#x2F;Oå¤„ç†å•å…ƒ å¤„ç†å®¢æˆ·è¿æ¥ï¼Œè¯»å†™ç½‘ç»œæ•°æ® é€»è¾‘å•å…ƒ ä¸šåŠ¡è¿›ç¨‹æˆ–çº¿ç¨‹ ç½‘ç»œå­˜å‚¨å•å…ƒ æ•°æ®åº“ã€æ–‡ä»¶æˆ–ç¼“å­˜ è¯·æ±‚é˜Ÿåˆ— å„å•å…ƒä¹‹é—´çš„é€šä¿¡æ–¹å¼ I&#x2F;O å¤„ç†å•å…ƒæ˜¯æœåŠ¡å™¨ç®¡ç†å®¢æˆ·è¿æ¥çš„æ¨¡å—ã€‚å®ƒé€šå¸¸è¦å®Œæˆä»¥ä¸‹å·¥ä½œï¼šç­‰å¾…å¹¶æ¥å—æ–°çš„å®¢æˆ·è¿æ¥ï¼Œæ¥æ”¶å®¢æˆ·æ•°æ®ï¼Œå°†æœåŠ¡å™¨å“åº”æ•°æ®è¿”å›ç»™å®¢æˆ·ç«¯ã€‚ä½†æ˜¯æ•°æ®çš„æ”¶å‘ä¸ä¸€å®šåœ¨ I&#x2F;O å¤„ç†å•å…ƒä¸­æ‰§è¡Œï¼Œä¹Ÿå¯èƒ½åœ¨é€»è¾‘å•å…ƒä¸­æ‰§è¡Œï¼Œå…·ä½“åœ¨ä½•å¤„æ‰§è¡Œå–å†³äºäº‹ä»¶å¤„ç†æ¨¡å¼ã€‚ä¸€ä¸ªé€»è¾‘å•å…ƒé€šå¸¸æ˜¯ä¸€ä¸ªè¿›ç¨‹æˆ–çº¿ç¨‹ã€‚å®ƒåˆ†æå¹¶å¤„ç†å®¢æˆ·æ•°æ®ï¼Œç„¶åå°†ç»“æœä¼ é€’ç»™ I&#x2F;O å¤„ç†å•å…ƒæˆ–è€…ç›´æ¥å‘é€ç»™å®¢æˆ·ç«¯ï¼ˆå…·ä½“ä½¿ç”¨å“ªç§æ–¹å¼å–å†³äºäº‹ä»¶å¤„ç†æ¨¡å¼ï¼‰ã€‚æœåŠ¡å™¨é€šå¸¸æ‹¥æœ‰å¤šä¸ªé€»è¾‘å•å…ƒï¼Œä»¥å®ç°å¯¹å¤šä¸ªå®¢æˆ·ä»»åŠ¡çš„å¹¶å‘å¤„ç†ã€‚ç½‘ç»œå­˜å‚¨å•å…ƒå¯ä»¥æ˜¯æ•°æ®åº“ã€ç¼“å­˜å’Œæ–‡ä»¶ï¼Œä½†ä¸æ˜¯å¿…é¡»çš„ã€‚è¯·æ±‚é˜Ÿåˆ—æ˜¯å„å•å…ƒä¹‹é—´çš„é€šä¿¡æ–¹å¼çš„æŠ½è±¡ã€‚I&#x2F;O å¤„ç†å•å…ƒæ¥æ”¶åˆ°å®¢æˆ·è¯·æ±‚æ—¶ï¼Œéœ€è¦ä»¥æŸç§æ–¹å¼é€šçŸ¥ä¸€ä¸ªé€»è¾‘å•å…ƒæ¥å¤„ç†è¯¥è¯·æ±‚ã€‚åŒæ ·ï¼Œå¤šä¸ªé€»è¾‘å•å…ƒåŒæ—¶è®¿é—®ä¸€ä¸ªå­˜å‚¨å•å…ƒæ—¶ï¼Œä¹Ÿéœ€è¦é‡‡ç”¨æŸç§æœºåˆ¶æ¥åè°ƒå¤„ç†ç«æ€æ¡ä»¶ã€‚è¯·æ±‚é˜Ÿåˆ—é€šå¸¸è¢«å®ç°ä¸ºæ± çš„ä¸€éƒ¨åˆ†ã€‚ ä¸¤ç§é«˜æ•ˆçš„äº‹ä»¶å¤„ç†æ¨¡å¼æœåŠ¡å™¨ç¨‹åºé€šå¸¸éœ€è¦å¤„ç†ä¸‰ç±»äº‹ä»¶ï¼šI&#x2F;O äº‹ä»¶ã€ä¿¡å·åŠå®šæ—¶äº‹ä»¶ã€‚æœ‰ä¸¤ç§é«˜æ•ˆçš„äº‹ä»¶å¤„ç†æ¨¡å¼ï¼šReactor å’Œ Proactorï¼ŒåŒæ­¥ I&#x2F;O æ¨¡å‹é€šå¸¸ç”¨äºå®ç° Reactor æ¨¡å¼ï¼Œå¼‚æ­¥ I&#x2F;O æ¨¡å‹é€šå¸¸ç”¨äºå®ç° Proactor æ¨¡å¼ã€‚ Reactoræ¨¡å¼ä½¿ç”¨åŒæ­¥ I&#x2F;Oï¼ˆä»¥ epoll_wait ä¸ºä¾‹ï¼‰å®ç°çš„ Reactor æ¨¡å¼çš„å·¥ä½œæµç¨‹æ˜¯ï¼š ä¸»çº¿ç¨‹å¾€ epoll å†…æ ¸äº‹ä»¶è¡¨ä¸­æ³¨å†Œ socket ä¸Šçš„è¯»å°±ç»ªäº‹ä»¶ã€‚ ä¸»çº¿ç¨‹è°ƒç”¨ epoll_wait ç­‰å¾… socket ä¸Šæœ‰æ•°æ®å¯è¯»ã€‚ å½“ socket ä¸Šæœ‰æ•°æ®å¯è¯»æ—¶ï¼Œ epoll_wait é€šçŸ¥ä¸»çº¿ç¨‹ã€‚ä¸»çº¿ç¨‹åˆ™å°† socket å¯è¯»äº‹ä»¶æ”¾å…¥è¯·æ±‚é˜Ÿåˆ—ã€‚ ç¡çœ åœ¨è¯·æ±‚é˜Ÿåˆ—ä¸Šçš„æŸä¸ªå·¥ä½œçº¿ç¨‹è¢«å”¤é†’ï¼Œå®ƒä» socket è¯»å–æ•°æ®ï¼Œå¹¶å¤„ç†å®¢æˆ·è¯·æ±‚ï¼Œç„¶åå¾€ epollå†…æ ¸äº‹ä»¶è¡¨ä¸­æ³¨å†Œè¯¥ socket ä¸Šçš„å†™å°±ç»ªäº‹ä»¶ã€‚ å½“ä¸»çº¿ç¨‹è°ƒç”¨ epoll_wait ç­‰å¾… socket å¯å†™ã€‚ å½“ socket å¯å†™æ—¶ï¼Œepoll_wait é€šçŸ¥ä¸»çº¿ç¨‹ã€‚ä¸»çº¿ç¨‹å°† socket å¯å†™äº‹ä»¶æ”¾å…¥è¯·æ±‚é˜Ÿåˆ—ã€‚ ç¡çœ åœ¨è¯·æ±‚é˜Ÿåˆ—ä¸Šçš„æŸä¸ªå·¥ä½œçº¿ç¨‹è¢«å”¤é†’ï¼Œå®ƒå¾€ socket ä¸Šå†™å…¥æœåŠ¡å™¨å¤„ç†å®¢æˆ·è¯·æ±‚çš„ç»“æœã€‚ Reactor æ¨¡å¼çš„å·¥ä½œæµç¨‹ï¼š Proactoræ¨¡å¼Proactor æ¨¡å¼å°†æ‰€æœ‰ I&#x2F;O æ“ä½œéƒ½äº¤ç»™ä¸»çº¿ç¨‹å’Œå†…æ ¸æ¥å¤„ç†ï¼ˆè¿›è¡Œè¯»ã€å†™ï¼‰ï¼Œå·¥ä½œçº¿ç¨‹ä»…ä»…è´Ÿè´£ä¸šåŠ¡é€»è¾‘ã€‚ä½¿ç”¨å¼‚æ­¥ I&#x2F;O æ¨¡å‹ï¼ˆä»¥ aio_read å’Œ aio_write ä¸ºä¾‹ï¼‰å®ç°çš„ Proactor æ¨¡å¼çš„å·¥ä½œæµç¨‹æ˜¯ï¼š ä¸»çº¿ç¨‹è°ƒç”¨ aio_read å‡½æ•°å‘å†…æ ¸æ³¨å†Œ socket ä¸Šçš„è¯»å®Œæˆäº‹ä»¶ï¼Œå¹¶å‘Šè¯‰å†…æ ¸ç”¨æˆ·è¯»ç¼“å†²åŒºçš„ä½ç½®ï¼Œä»¥åŠè¯»æ“ä½œå®Œæˆæ—¶å¦‚ä½•é€šçŸ¥åº”ç”¨ç¨‹åºï¼ˆè¿™é‡Œä»¥ä¿¡å·ä¸ºä¾‹ï¼‰ã€‚ ä¸»çº¿ç¨‹ç»§ç»­å¤„ç†å…¶ä»–é€»è¾‘ã€‚ å½“ socket ä¸Šçš„æ•°æ®è¢«è¯»å…¥ç”¨æˆ·ç¼“å†²åŒºåï¼Œå†…æ ¸å°†å‘åº”ç”¨ç¨‹åºå‘é€ä¸€ä¸ªä¿¡å·ï¼Œä»¥é€šçŸ¥åº”ç”¨ç¨‹åºæ•°æ®å·²ç»å¯ç”¨ã€‚ åº”ç”¨ç¨‹åºé¢„å…ˆå®šä¹‰å¥½çš„ä¿¡å·å¤„ç†å‡½æ•°é€‰æ‹©ä¸€ä¸ªå·¥ä½œçº¿ç¨‹æ¥å¤„ç†å®¢æˆ·è¯·æ±‚ã€‚å·¥ä½œçº¿ç¨‹å¤„ç†å®Œå®¢æˆ·è¯·æ±‚åï¼Œè°ƒç”¨ aio_write å‡½æ•°å‘å†…æ ¸æ³¨å†Œ socket ä¸Šçš„å†™å®Œæˆäº‹ä»¶ï¼Œå¹¶å‘Šè¯‰å†…æ ¸ç”¨æˆ·å†™ç¼“å†²åŒºçš„ä½ç½®ï¼Œä»¥åŠå†™æ“ä½œå®Œæˆæ—¶å¦‚ä½•é€šçŸ¥åº”ç”¨ç¨‹åºã€‚ ä¸»çº¿ç¨‹ç»§ç»­å¤„ç†å…¶ä»–é€»è¾‘ã€‚ å½“ç”¨æˆ·ç¼“å†²åŒºçš„æ•°æ®è¢«å†™å…¥ socket ä¹‹åï¼Œå†…æ ¸å°†å‘åº”ç”¨ç¨‹åºå‘é€ä¸€ä¸ªä¿¡å·ï¼Œä»¥é€šçŸ¥åº”ç”¨ç¨‹åºæ•°æ®å·²ç»å‘é€å®Œæ¯•ã€‚ åº”ç”¨ç¨‹åºé¢„å…ˆå®šä¹‰å¥½çš„ä¿¡å·å¤„ç†å‡½æ•°é€‰æ‹©ä¸€ä¸ªå·¥ä½œçº¿ç¨‹æ¥åšå–„åå¤„ç†ï¼Œæ¯”å¦‚å†³å®šæ˜¯å¦å…³é—­ socketã€‚ Proactor æ¨¡å¼çš„å·¥ä½œæµç¨‹ï¼š æ¨¡æ‹ŸProactoræ¨¡å¼ä½¿ç”¨åŒæ­¥ I&#x2F;O æ–¹å¼æ¨¡æ‹Ÿå‡º Proactor æ¨¡å¼ã€‚åŸç†æ˜¯ï¼šä¸»çº¿ç¨‹æ‰§è¡Œæ•°æ®è¯»å†™æ“ä½œï¼Œè¯»å†™å®Œæˆä¹‹åï¼Œä¸»çº¿ç¨‹å‘å·¥ä½œçº¿ç¨‹é€šçŸ¥è¿™ä¸€â€å®Œæˆäº‹ä»¶â€œã€‚é‚£ä¹ˆä»å·¥ä½œçº¿ç¨‹çš„è§’åº¦æ¥çœ‹ï¼Œå®ƒä»¬å°±ç›´æ¥è·å¾—äº†æ•°æ®è¯»å†™çš„ç»“æœï¼Œæ¥ä¸‹æ¥è¦åšçš„åªæ˜¯å¯¹è¯»å†™çš„ç»“æœè¿›è¡Œé€»è¾‘å¤„ç†ã€‚ä½¿ç”¨åŒæ­¥ I&#x2F;O æ¨¡å‹ï¼ˆä»¥ epoll_waitä¸ºä¾‹ï¼‰æ¨¡æ‹Ÿå‡ºçš„ Proactor æ¨¡å¼çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š ä¸»çº¿ç¨‹å¾€ epoll å†…æ ¸äº‹ä»¶è¡¨ä¸­æ³¨å†Œ socket ä¸Šçš„è¯»å°±ç»ªäº‹ä»¶ã€‚ ä¸»çº¿ç¨‹è°ƒç”¨ epoll_wait ç­‰å¾… socket ä¸Šæœ‰æ•°æ®å¯è¯»ã€‚ å½“ socket ä¸Šæœ‰æ•°æ®å¯è¯»æ—¶ï¼Œepoll_wait é€šçŸ¥ä¸»çº¿ç¨‹ã€‚ä¸»çº¿ç¨‹ä» socket å¾ªç¯è¯»å–æ•°æ®ï¼Œç›´åˆ°æ²¡æœ‰æ›´å¤šæ•°æ®å¯è¯»ï¼Œç„¶åå°†è¯»å–åˆ°çš„æ•°æ®å°è£…æˆä¸€ä¸ªè¯·æ±‚å¯¹è±¡å¹¶æ’å…¥è¯·æ±‚é˜Ÿåˆ—ã€‚ ç¡çœ åœ¨è¯·æ±‚é˜Ÿåˆ—ä¸Šçš„æŸä¸ªå·¥ä½œçº¿ç¨‹è¢«å”¤é†’ï¼Œå®ƒè·å¾—è¯·æ±‚å¯¹è±¡å¹¶å¤„ç†å®¢æˆ·è¯·æ±‚ï¼Œç„¶åå¾€ epoll å†…æ ¸äº‹ä»¶è¡¨ä¸­æ³¨å†Œ socket ä¸Šçš„å†™å°±ç»ªäº‹ä»¶ã€‚ ä¸»çº¿ç¨‹è°ƒç”¨ epoll_wait ç­‰å¾… socket å¯å†™ã€‚ å½“ socket å¯å†™æ—¶ï¼Œepoll_wait é€šçŸ¥ä¸»çº¿ç¨‹ã€‚ä¸»çº¿ç¨‹å¾€ socket ä¸Šå†™å…¥æœåŠ¡å™¨å¤„ç†å®¢æˆ·è¯·æ±‚çš„ç»“æœã€‚ åŒæ­¥ I&#x2F;O æ¨¡æ‹Ÿ Proactor æ¨¡å¼çš„å·¥ä½œæµç¨‹ï¼š çº¿ç¨‹åŒæ­¥æœºåˆ¶ç±»å°è£…åŠçº¿ç¨‹æ± å®ç°çº¿ç¨‹æ± æ˜¯ç”±æœåŠ¡å™¨é¢„å…ˆåˆ›å»ºçš„ä¸€ç»„å­çº¿ç¨‹ï¼Œçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡åº”è¯¥å’Œ CPU æ•°é‡å·®ä¸å¤šã€‚çº¿ç¨‹æ± ä¸­çš„æ‰€æœ‰å­çº¿ç¨‹éƒ½è¿è¡Œç€ç›¸åŒçš„ä»£ç ã€‚å½“æœ‰æ–°çš„ä»»åŠ¡åˆ°æ¥æ—¶ï¼Œä¸»çº¿ç¨‹å°†é€šè¿‡æŸç§æ–¹å¼é€‰æ‹©çº¿ç¨‹æ± ä¸­çš„æŸä¸€ä¸ªå­çº¿ç¨‹æ¥ä¸ºä¹‹æœåŠ¡ã€‚ç›¸æ¯”ä¸åŠ¨æ€çš„åˆ›å»ºå­çº¿ç¨‹ï¼Œé€‰æ‹©ä¸€ä¸ªå·²ç»å­˜åœ¨çš„å­çº¿ç¨‹çš„ä»£ä»·æ˜¾ç„¶è¦å°å¾—å¤šã€‚è‡³äºä¸»çº¿ç¨‹é€‰æ‹©å“ªä¸ªå­çº¿ç¨‹æ¥ä¸ºæ–°ä»»åŠ¡æœåŠ¡ï¼Œåˆ™æœ‰å¤šç§æ–¹å¼ï¼š ä¸»çº¿ç¨‹ä½¿ç”¨æŸç§ç®—æ³•æ¥ä¸»åŠ¨é€‰æ‹©å­çº¿ç¨‹ã€‚æœ€ç®€å•ã€æœ€å¸¸ç”¨çš„ç®—æ³•æ˜¯éšæœºç®—æ³•å’Œ Round Robinï¼ˆè½®æµé€‰å–ï¼‰ç®—æ³•ï¼Œä½†æ›´ä¼˜ç§€ã€æ›´æ™ºèƒ½çš„ç®—æ³•å°†ä½¿ä»»åŠ¡åœ¨å„ä¸ªå·¥ä½œçº¿ç¨‹ä¸­æ›´å‡åŒ€åœ°åˆ†é…ï¼Œä»è€Œå‡è½»æœåŠ¡å™¨çš„æ•´ä½“å‹åŠ›ã€‚ ä¸»çº¿ç¨‹å’Œæ‰€æœ‰å­çº¿ç¨‹é€šè¿‡ä¸€ä¸ªå…±äº«çš„å·¥ä½œé˜Ÿåˆ—æ¥åŒæ­¥ï¼Œå­çº¿ç¨‹éƒ½ç¡çœ åœ¨è¯¥å·¥ä½œé˜Ÿåˆ—ä¸Šã€‚å½“æœ‰æ–°çš„ä»»åŠ¡åˆ°æ¥æ—¶ï¼Œä¸»çº¿ç¨‹å°†ä»»åŠ¡æ·»åŠ åˆ°å·¥ä½œé˜Ÿåˆ—ä¸­ã€‚è¿™å°†å”¤é†’æ­£åœ¨ç­‰å¾…ä»»åŠ¡çš„å­çº¿ç¨‹ï¼Œä¸è¿‡åªæœ‰ä¸€ä¸ªå­çº¿ç¨‹å°†è·å¾—æ–°ä»»åŠ¡çš„â€æ¥ç®¡æƒâ€œï¼Œå®ƒå¯ä»¥ä»å·¥ä½œé˜Ÿåˆ—ä¸­å–å‡ºä»»åŠ¡å¹¶æ‰§è¡Œä¹‹ï¼Œè€Œå…¶ä»–å­çº¿ç¨‹å°†ç»§ç»­ç¡çœ åœ¨å·¥ä½œé˜Ÿåˆ—ä¸Šã€‚ çº¿ç¨‹æ± çš„ä¸€èˆ¬æ¨¡å‹ä¸ºï¼š çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡æœ€ç›´æ¥çš„é™åˆ¶å› ç´ æ˜¯ä¸­å¤®å¤„ç†å™¨(CPU)çš„å¤„ç†å™¨(processors&#x2F;cores)çš„æ•°é‡N ï¼šå¦‚æœä½ çš„CPUæ˜¯4-coresçš„ï¼Œå¯¹äºCPUå¯†é›†å‹çš„ä»»åŠ¡(å¦‚è§†é¢‘å‰ªè¾‘ç­‰æ¶ˆè€—CPUè®¡ç®—èµ„æºçš„ä»»åŠ¡)æ¥è¯´ï¼Œé‚£çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡æœ€å¥½ä¹Ÿè®¾ç½®ä¸º4ï¼ˆæˆ–è€…+1é˜²æ­¢å…¶ä»–å› ç´ é€ æˆçš„çº¿ç¨‹å¡ï¼‰ï¼›å¯¹äºIOå¯†é›†å‹çš„ä»»åŠ¡ï¼Œä¸€èˆ¬è¦å¤šäºCPUçš„æ ¸æ•°ï¼Œå› ä¸ºçº¿ç¨‹é—´ç«äº‰çš„ä¸æ˜¯CPUçš„è®¡ç®—èµ„æºè€Œæ˜¯IOï¼ŒIOçš„å¤„ç†ä¸€èˆ¬è¾ƒæ…¢ï¼Œå¤šäºcoresæ•°çš„çº¿ç¨‹å°†ä¸ºCPUäº‰å–æ›´å¤šçš„ä»»åŠ¡ï¼Œä¸è‡³åœ¨çº¿ç¨‹å¤„ç†IOçš„è¿‡ç¨‹é€ æˆCPUç©ºé—²å¯¼è‡´èµ„æºæµªè´¹ã€‚ ç©ºé—´æ¢æ—¶é—´ï¼Œæµªè´¹æœåŠ¡å™¨çš„ç¡¬ä»¶èµ„æºï¼Œæ¢å–è¿è¡Œæ•ˆç‡ã€‚ æ± æ˜¯ä¸€ç»„èµ„æºçš„é›†åˆï¼Œè¿™ç»„èµ„æºåœ¨æœåŠ¡å™¨å¯åŠ¨ä¹‹åˆå°±è¢«å®Œå…¨åˆ›å»ºå¥½å¹¶åˆå§‹åŒ–ï¼Œè¿™ç§°ä¸ºé™æ€èµ„æºã€‚ å½“æœåŠ¡å™¨è¿›å…¥æ­£å¼è¿è¡Œé˜¶æ®µï¼Œå¼€å§‹å¤„ç†å®¢æˆ·è¯·æ±‚çš„æ—¶å€™ï¼Œå¦‚æœå®ƒéœ€è¦ç›¸å…³çš„èµ„æºï¼Œå¯ä»¥ç›´æ¥ä»æ± ä¸­è·å–ï¼Œæ— éœ€åŠ¨æ€åˆ†é…ã€‚ å½“æœåŠ¡å™¨å¤„ç†å®Œä¸€ä¸ªå®¢æˆ·è¿æ¥åï¼Œå¯ä»¥æŠŠç›¸å…³çš„èµ„æºæ”¾å›æ± ä¸­ï¼Œæ— éœ€æ‰§è¡Œç³»ç»Ÿè°ƒç”¨é‡Šæ”¾èµ„æºã€‚ EPOLLONESHOTäº‹ä»¶å³ä½¿å¯ä»¥ä½¿ç”¨ ET æ¨¡å¼ï¼Œä¸€ä¸ªsocket ä¸Šçš„æŸä¸ªäº‹ä»¶è¿˜æ˜¯å¯èƒ½è¢«è§¦å‘å¤šæ¬¡ã€‚è¿™åœ¨å¹¶å‘ç¨‹åºä¸­å°±ä¼šå¼•èµ·ä¸€ä¸ªé—®é¢˜ã€‚æ¯”å¦‚ä¸€ä¸ªçº¿ç¨‹åœ¨è¯»å–å®ŒæŸä¸ª socket ä¸Šçš„æ•°æ®åå¼€å§‹å¤„ç†è¿™äº›æ•°æ®ï¼Œè€Œåœ¨æ•°æ®çš„å¤„ç†è¿‡ç¨‹ä¸­è¯¥socket ä¸Šåˆæœ‰æ–°æ•°æ®å¯è¯»ï¼ˆEPOLLIN å†æ¬¡è¢«è§¦å‘ï¼‰ï¼Œæ­¤æ—¶å¦å¤–ä¸€ä¸ªçº¿ç¨‹è¢«å”¤é†’æ¥è¯»å–è¿™äº›æ–°çš„æ•°æ®ã€‚äºæ˜¯å°±å‡ºç°äº†ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶æ“ä½œä¸€ä¸ª socket çš„å±€é¢ã€‚ä¸€ä¸ªsocketè¿æ¥åœ¨ä»»ä¸€æ—¶åˆ»éƒ½åªè¢«ä¸€ä¸ªçº¿ç¨‹å¤„ç†ï¼Œå¯ä»¥ä½¿ç”¨ epoll çš„ EPOLLONESHOT äº‹ä»¶å®ç°ã€‚å¯¹äºæ³¨å†Œäº† EPOLLONESHOT äº‹ä»¶çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œæ“ä½œç³»ç»Ÿæœ€å¤šè§¦å‘å…¶ä¸Šæ³¨å†Œçš„ä¸€ä¸ªå¯è¯»ã€å¯å†™æˆ–è€…å¼‚å¸¸äº‹ä»¶ï¼Œä¸”åªè§¦å‘ä¸€æ¬¡ï¼Œé™¤éæˆ‘ä»¬ä½¿ç”¨ epoll_ctl å‡½æ•°é‡ç½®è¯¥æ–‡ä»¶æè¿°ç¬¦ä¸Šæ³¨å†Œçš„ EPOLLONESHOT äº‹ä»¶ã€‚è¿™æ ·ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹åœ¨å¤„ç†æŸä¸ª socket æ—¶ï¼Œå…¶ä»–çº¿ç¨‹æ˜¯ä¸å¯èƒ½æœ‰æœºä¼šæ“ä½œè¯¥ socket çš„ã€‚ä½†åè¿‡æ¥æ€è€ƒï¼Œæ³¨å†Œäº† EPOLLONESHOT äº‹ä»¶çš„ socket ä¸€æ—¦è¢«æŸä¸ªçº¿ç¨‹å¤„ç†å®Œæ¯•ï¼Œ è¯¥çº¿ç¨‹å°±åº”è¯¥ç«‹å³é‡ç½®è¿™ä¸ªsocket ä¸Šçš„ EPOLLONESHOT äº‹ä»¶ï¼Œä»¥ç¡®ä¿è¿™ä¸ª socket ä¸‹ä¸€æ¬¡å¯è¯»æ—¶ï¼Œå…¶ EPOLLIN äº‹ä»¶èƒ½è¢«è§¦å‘ï¼Œè¿›è€Œè®©å…¶ä»–å·¥ä½œçº¿ç¨‹æœ‰æœºä¼šç»§ç»­å¤„ç†è¿™ä¸ª socketã€‚ æœ‰é™çŠ¶æ€æœºé€»è¾‘å•å…ƒå†…éƒ¨çš„ä¸€ç§é«˜æ•ˆç¼–ç¨‹æ–¹æ³•ï¼šæœ‰é™çŠ¶æ€æœºï¼ˆfinite state machineï¼‰ã€‚æœ‰çš„åº”ç”¨å±‚åè®®å¤´éƒ¨åŒ…å«æ•°æ®åŒ…ç±»å‹å­—æ®µï¼Œæ¯ç§ç±»å‹å¯ä»¥æ˜ å°„ä¸ºé€»è¾‘å•å…ƒçš„ä¸€ç§æ‰§è¡ŒçŠ¶æ€ï¼ŒæœåŠ¡å™¨å¯ä»¥æ ¹æ®å®ƒæ¥ç¼–å†™ç›¸åº”çš„å¤„ç†é€»è¾‘ã€‚å¦‚ä¸‹æ˜¯ä¸€ç§çŠ¶æ€ç‹¬ç«‹çš„æœ‰é™çŠ¶æ€æœºï¼š 12345678910111213STATE_MACHINE( Package _pack )&#123; PackageType _type = _pack.GetType(); switch( _type ) &#123; case type_A: process_package_A( _pack ); break; case type_B: process_package_B( _pack ); break; &#125;&#125; è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æœ‰é™çŠ¶æ€æœºï¼Œåªä¸è¿‡è¯¥çŠ¶æ€æœºçš„æ¯ä¸ªçŠ¶æ€éƒ½æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œå³çŠ¶æ€ä¹‹é—´æ²¡æœ‰ç›¸äº’è½¬ç§»ã€‚çŠ¶æ€ä¹‹é—´çš„è½¬ç§»æ˜¯éœ€è¦çŠ¶æ€æœºå†…éƒ¨é©±åŠ¨ï¼Œå¦‚ä¸‹ä»£ç ï¼š 12345678910111213141516171819STATE_MACHINE()&#123; State cur_State = type_A; while( cur_State != type_C ) &#123; Package _pack = getNewPackage(); switch( cur_State ) &#123; case type_A: process_package_state_A( _pack ); cur_State = type_B; break; case type_B: process_package_state_B( _pack ); cur_State = type_C; break; &#125; &#125;&#125; è¯¥çŠ¶æ€æœºåŒ…å«ä¸‰ç§çŠ¶æ€ï¼štype_Aã€type_B å’Œ type_Cï¼Œå…¶ä¸­ type_A æ˜¯çŠ¶æ€æœºçš„å¼€å§‹çŠ¶æ€ï¼Œtype_C æ˜¯çŠ¶æ€æœºçš„ç»“æŸçŠ¶æ€ã€‚çŠ¶æ€æœºçš„å½“å‰çŠ¶æ€è®°å½•åœ¨ cur_State å˜é‡ä¸­ã€‚åœ¨ä¸€è¶Ÿå¾ªç¯è¿‡ç¨‹ä¸­ï¼ŒçŠ¶æ€æœºå…ˆé€šè¿‡getNewPackage æ–¹æ³•è·å¾—ä¸€ä¸ªæ–°çš„æ•°æ®åŒ…ï¼Œç„¶åæ ¹æ® cur_State å˜é‡çš„å€¼åˆ¤æ–­å¦‚ä½•å¤„ç†è¯¥æ•°æ®åŒ…ã€‚æ•°æ®åŒ…å¤„ç†å®Œä¹‹åï¼ŒçŠ¶æ€æœºé€šè¿‡ç»™ cur_State å˜é‡ä¼ é€’ç›®æ ‡çŠ¶æ€å€¼æ¥å®ç°çŠ¶æ€è½¬ç§»ã€‚é‚£ä¹ˆå½“çŠ¶æ€æœºè¿›å…¥ä¸‹ä¸€è¶Ÿå¾ªç¯æ—¶ï¼Œå®ƒå°†æ‰§è¡Œæ–°çš„çŠ¶æ€å¯¹åº”çš„é€»è¾‘ã€‚ Htmlè¯­è¨€åŸºç¡€Htmlç®€ä»‹Htmlæ˜¯è¶…æ–‡æœ¬æ ‡è®°è¯­è¨€ï¼Œåœ¨è®¡ç®—æœºé’Ÿä»¥.htmlæˆ–è€….htmä½œä¸ºæ‹“å±•åï¼Œå¯ä»¥è¢«æµè§ˆå™¨è¯†åˆ«ï¼Œå°±æ˜¯ç»å¸¸è§åˆ°çš„ç½‘é¡µã€‚ Htmlçš„è¯­æ³•éå¸¸ç®€æ´ï¼Œæ¯”è¾ƒæ¾æ•£ï¼Œä»¥ç›¸åº”çš„è‹±è¯­å•è¯å…³é”®è¯è¿›è¡Œç»„åˆï¼Œhtmlæ ‡ç­¾ä¸åŒºåˆ†å¤§å°å†™ï¼Œæ ‡ç­¾å¤§å¤šæ•°æˆå¯¹å‡ºç°ï¼Œæœ‰å¼€å§‹ï¼Œæœ‰ç»“æŸï¼Œä¾‹å¦‚&lt;html&gt;``&lt;/html&gt;,ä½†æ˜¯å¹¶æ²¡æœ‰è¦æ±‚å¿…é¡»æˆå¯¹å‡ºç°ã€‚åŒæ—¶ä¹Ÿæœ‰å›ºå®šçš„çŸ­æ ‡ç­¾ï¼Œä¾‹å¦‚&lt;br/&gt;,&lt;hr/&gt;ã€‚ å­¦ä¹ htmlåŸºæœ¬å°±å¯ä»¥è®¤ä¸ºæ˜¯å­¦ä¹ å„ç§æ ‡ç­¾ï¼Œæ ‡ç­¾ä¹Ÿå¯ä»¥è®¾ç½®å±æ€§ï¼Œä¾‹å¦‚&lt;font color=&quot;red&quot;&gt;hello,world&lt;/font&gt;ï¼Œç¤ºä¾‹ä¸­colorä»£è¡¨æ ‡ç­¾çš„é¢œè‰²å±æ€§ï¼Œredä»£è¡¨æ ‡ç­¾æ˜¯çº¢è‰²å­—ä½“ï¼Œhelloï¼Œworldä¸ºå®é™…æ˜¾ç¤ºçš„å†…å®¹ï¼Œå¯ä»¥æ–°å»ºä¸€ä¸ªæ–‡æœ¬æ–‡æ¡£ï¼Œç„¶åå°†åç¼€åä¿®æ”¹.htmlæ–‡ä»¶ï¼Œç”¨ä»£ç ç¼–è¾‘å™¨æ‰“å¼€è¯¥htmlæ–‡ä»¶å¯ä»¥ç¼–è¾‘æ–‡ä»¶ï¼Œå°†ä¸Šè¿°å†…å®¹ä¿å­˜åˆ°æ–‡ä»¶ä¸­ï¼ŒåŒå‡»è¯¥æ–‡ä»¶å¯ä»¥çœ‹åˆ°å¦‚ä¸‹æ•ˆæœï¼š Htmlçš„ç»„æˆå¯ä»¥åˆ†ä¸ºå¦‚ä¸‹éƒ¨åˆ†ï¼š &lt;!doctype.html&gt;å£°æ˜æ–‡æ¡£ç±»å‹ï¼Œå¯ä»¥ä¸å†™ &lt;html&gt;å¼€å§‹å’Œ&lt;/html&gt;ç»“æŸï¼Œå±äºhtmlçš„æ ¹æ ‡ç­¾ &lt;head&gt;``&lt;/head&gt;å¤´éƒ¨æ ‡ç­¾ï¼Œå¤´éƒ¨æ ‡ç­¾å†…ä¸€èˆ¬æœ‰&lt;title&gt;``&lt;/title&gt; &lt;body&gt;``&lt;/body&gt;ä¸»é¢˜æ ‡ç­¾ï¼Œä¸€èˆ¬ç”¨äºæ˜¾ç¤ºå†…å®¹ ä¾‹å¦‚ï¼š 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;è¿™æ˜¯ä¸€ä¸ªæ ‡é¢˜&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;font color = &quot;red&quot; size = &quot;5&quot;&gt;hello,world&lt;/font&gt; &lt;body&gt;&lt;/html&gt; å¦‚æœæƒ³è¦æ·»åŠ æ³¨é‡Šï¼Œå¯ä»¥ä½¿ç”¨&lt;!-æˆ‘æ˜¯æ³¨é‡Šâ€“&gt;çš„æ–¹å¼ Htmlæ ‡ç­¾ä»‹ç»é¢˜ç›®æ ‡ç­¾å…±æœ‰å…­ç§ï¼Œ,â€¦â€¦ï¼Œå…¶ä¸­æœ€å¤§,æœ€å°ã€‚ æ–‡æœ¬æ ‡ç­¾æ ‡ç­¾ï¼Œå¯ä»¥è®¾ç½®é¢œè‰²å’Œå­—ä½“å¤§å°å±æ€§ é¢œè‰²è¡¨ç¤ºæ–¹æ³• è‹±æ–‡å•è¯ red green blue â€¦ ä½¿ç”¨16è¿›åˆ¶çš„å½¢å¼è¡¨ç¤ºé¢œè‰²:#ffffff ä½¿ç”¨rgb(255,255,0) å­—ä½“å¤§å°å¯ä»¥ä½¿ç”¨sizeå±æ€§ï¼Œå¤§å°èŒƒå›´ä¸º1-7ï¼Œå…¶ä¸­7æœ€å¤§ï¼Œ1æœ€å° æœ‰æ—¶å€™éœ€è¦ä½¿ç”¨æ¢è¡Œæ ‡ç­¾ï¼Œè¿™æ˜¯ä¸€ä¸ªçŸ­æ ‡ç­¾ ä¸ä¹‹å¯¹åº”å¦å¤–è¿˜æœ‰ä¸€ä¸ªæ°´å¹³çº¿ä¹Ÿæ˜¯çŸ­æ ‡ç­¾ï¼Œï¼Œæ°´å¹³çº¿ä¹Ÿå¯ä»¥è®¾ç½®é¢œè‰²å’Œå¤§å° åˆ—è¡¨æ ‡ç­¾åˆ—è¡¨æ ‡ç­¾åˆ†æ— åºåˆ—è¡¨å’Œæœ‰åºåˆ—è¡¨ï¼Œåˆ†åˆ«å¯¹åº”å’Œ æ— åºåˆ—è¡¨çš„æ ¼å¼å¦‚ä¸‹ï¼š 12345&lt;ul&gt; &lt;li&gt;åˆ—è¡¨å†…å®¹1&lt;/li&gt; &lt;li&gt;åˆ—è¡¨å†…å®¹2&lt;/li&gt; ...&lt;/ul&gt; æ— åºåˆ—è¡¨å¯ä»¥è®¾ç½®typeå±æ€§ï¼š å®å¿ƒåœ†åœˆï¼štype&#x3D;disc ç©ºå¿ƒåœ†åœˆï¼štype&#x3D;circle å°æ–¹å—ï¼štype&#x3D;square æœ‰åºåˆ—è¡¨çš„æ ¼å¼å¦‚ä¸‹ï¼š 12345&lt;ol&gt; &lt;li&gt;åˆ—è¡¨å†…å®¹1&lt;/li&gt; &lt;li&gt;åˆ—è¡¨å†…å®¹2&lt;/li&gt; ...&lt;/ol&gt; æœ‰åºåˆ—è¡¨åŒæ ·å¯ä»¥è®¾ç½®typeå±æ€§ æ•°å­—ï¼štype&#x3D;1ï¼Œä¹Ÿæ˜¯é»˜è®¤æ–¹å¼ è‹±æ–‡æ•°å­—ï¼štype&#x3D;aæˆ–type&#x3D;A ç½—é©¬æ•°å­—ï¼štype&#x3D;iæˆ–type&#x3D;I å›¾ç‰‡æ ‡ç­¾å›¾ç‰‡æ ‡ç­¾ä½¿ç”¨&lt;img&gt;,å†…éƒ¨éœ€è¦è®¾ç½®è‹¥å¹²å±æ€§ï¼Œå¯ä»¥ä¸å¿…å†™ç»“æŸæ ‡ç­¾ src&#x3D;â€3.gifâ€å›¾ç‰‡æ¥æºï¼Œå¿…å†™ alt&#x3D;â€â€¦â€ï¼Œå›¾ç‰‡ä¸æ˜¾ç¤ºæ—¶ï¼Œæ˜¾ç¤ºçš„å†…å®¹ title&#x3D;â€œâ€¦â€,é¼ æ ‡ç§»åŠ¨åˆ°å›¾ç‰‡ä¸Šæ—¶æ˜¾ç¤ºçš„æ–‡å­— width&#x3D;â€600â€ï¼Œå›¾ç‰‡æ˜¾ç¤ºçš„å®½åº¦ height&#x3D;â€400â€ï¼Œå›¾ç‰‡æ˜¾ç¤ºçš„é«˜åº¦ è¶…é“¾æ¥æ ‡ç­¾è¶…é“¾æ¥æ ‡ç­¾ä½¿ç”¨ï¼ŒåŒæ ·éœ€è¦è®¾ç½®å±æ€§è¡¨æ˜è¦é“¾æ¥åˆ°å“ªé‡Œ å±æ€§ï¼š href=&quot;...&quot;ï¼Œå‰å¾€åœ°å€ï¼Œå¿…å¡«ï¼Œè¦å†™http:&#x2F;&#x2F; title=&quot;...&quot;,é¼ æ ‡ç§»åŠ¨åˆ°é“¾æ¥ä¸Šæ—¶æ˜¾ç¤ºçš„æ–‡å­— target=&quot;_self&quot;ï¼Œæˆ–è€…&quot;_blank&quot;ï¼Œ_selfæ—¶é»˜è®¤å€¼ï¼Œåœ¨è‡ªèº«é¡µé¢æ‰“å¼€ï¼Œ_blankæ˜¯æ–°å¼€é¡µé¢å‰å¾€è¿æ¥åœ°å€ ç¤ºä¾‹ï¼š &lt;a href = &quot;...&quot; title = &quot;...&quot; target = &quot;_self&quot;&gt; ... &lt;/a&gt;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"é¡¹ç›®å®æˆ˜","slug":"ç¼–ç¨‹è¯­è¨€/C/é¡¹ç›®å®æˆ˜","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[]},{"title":"C++å­¦ä¹  ç½‘ç»œç¼–ç¨‹ UDPé€šä¿¡","slug":"C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-UDPé€šä¿¡","date":"2023-06-04T01:46:56.000Z","updated":"2023-06-04T08:43:31.772Z","comments":true,"path":"2023/06/04/C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-UDPé€šä¿¡/","link":"","permalink":"http://example.com/2023/06/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP%E9%80%9A%E4%BF%A1/","excerpt":"UDP 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);- å‚æ•°ï¼š - sockfd : é€šä¿¡çš„fd - buf : è¦å‘é€çš„æ•°æ® - len : å‘é€æ•°æ®çš„é•¿åº¦ - flags : 0 - dest_addr : é€šä¿¡çš„å¦å¤–ä¸€ç«¯çš„åœ°å€ä¿¡æ¯ - addrlen : åœ°å€çš„å†…å­˜å¤§å°ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);- å‚æ•°ï¼š - sockfd : é€šä¿¡çš„fd - buf : æ¥æ”¶æ•°æ®çš„æ•°ç»„ - len : æ•°ç»„çš„å¤§å°","text":"UDP 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);- å‚æ•°ï¼š - sockfd : é€šä¿¡çš„fd - buf : è¦å‘é€çš„æ•°æ® - len : å‘é€æ•°æ®çš„é•¿åº¦ - flags : 0 - dest_addr : é€šä¿¡çš„å¦å¤–ä¸€ç«¯çš„åœ°å€ä¿¡æ¯ - addrlen : åœ°å€çš„å†…å­˜å¤§å°ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);- å‚æ•°ï¼š - sockfd : é€šä¿¡çš„fd - buf : æ¥æ”¶æ•°æ®çš„æ•°ç»„ - len : æ•°ç»„çš„å¤§å° æ¡ˆä¾‹ server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.åˆ›å»ºä¸€ä¸ªé€šä¿¡çš„socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; // 2.ç»‘å®š int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.é€šä¿¡ while (1) &#123; char recvbuf[128]; char ipbuf[16]; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // æ¥æ”¶æ•°æ® int num = recvfrom(fd, recvbuf, sizeof(recvbuf), 0, (struct sockaddr*)&amp;cliaddr, &amp;len); printf(&quot;client IP : %s, Port : %d\\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, sizeof(ipbuf)), ntohs(cliaddr.sin_port)); printf(&quot;client say : %s\\n&quot;, recvbuf); // å‘é€æ•°æ® sendto(fd, recvbuf, strlen(recvbuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); &#125; close(fd); return 0;&#125; client 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.åˆ›å»ºä¸€ä¸ªé€šä¿¡çš„socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // æœåŠ¡å™¨çš„åœ°å€ä¿¡æ¯ struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;saddr.sin_addr.s_addr); int num = 0; // 3.é€šä¿¡ while (1) &#123; // å‘é€æ•°æ® char sendBuf[128]; sprintf(sendBuf, &quot;hello , i am client %d \\n&quot;, num++); sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // æ¥æ”¶æ•°æ® int num = recvfrom(fd, sendBuf, sizeof(sendBuf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; å¹¿æ’­å‘å­ç½‘ä¸­å¤šå°è®¡ç®—æœºå‘é€æ¶ˆæ¯ï¼Œå¹¶ä¸”å­ç½‘ä¸­æ‰€æœ‰çš„è®¡ç®—æœºéƒ½å¯ä»¥æ¥æ”¶åˆ°å‘é€æ–¹å‘é€çš„æ¶ˆæ¯ï¼Œæ¯ä¸ªå¹¿æ’­æ¶ˆæ¯éƒ½åŒ…å«ä¸€ä¸ªç‰¹æ®Šçš„IPåœ°å€ï¼Œè¿™ä¸ªIPä¸­å­ç½‘å†…ä¸»æœºæ ‡å¿—éƒ¨åˆ†çš„äºŒè¿›åˆ¶å…¨éƒ¨ä¸º1ã€‚ åªèƒ½åœ¨å±€åŸŸç½‘ä¸­ä½¿ç”¨ã€‚ å®¢æˆ·ç«¯éœ€è¦ç»‘å®šæœåŠ¡å™¨å¹¿æ’­ä½¿ç”¨çš„ç«¯å£ï¼Œæ‰å¯ä»¥æ¥æ”¶åˆ°å¹¿æ’­æ¶ˆæ¯ã€‚ 123456789// è®¾ç½®å¹¿æ’­å±æ€§çš„å‡½æ•°int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_toptlen);- sockfd : æ–‡ä»¶æè¿°ç¬¦- level : SOL_SOCKET- optname : SO_BROADCAST- optval : intç±»å‹çš„å€¼ï¼Œä¸º1è¡¨ç¤ºå…è®¸å¹¿æ’­- optlen : optvalçš„å¤§å° æ¡ˆä¾‹ server 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.åˆ›å»ºä¸€ä¸ªé€šä¿¡çš„socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; //2.è®¾ç½®å¹¿æ’­å±æ€§ int op = 1; setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, sizeof(op)); //3.åˆ›å»ºå¹¿æ’­åœ°å€ struct sockaddr_in cliaddr; cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;192.168.194.255&quot;, &amp;cliaddr.sin_addr.s_addr); // 4.é€šä¿¡ int num = 0; while (1) &#123; char sendBuf[128]; sprintf(sendBuf, &quot;hello , client......%d\\n&quot;, num++); // å‘é€æ•°æ® sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); printf(&quot;å¹¿æ’­çš„æ•°æ®ï¼š %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.åˆ›å»ºä¸€ä¸ªé€šä¿¡çš„socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.å®¢æˆ·ç«¯ç»‘å®šæœ¬åœ°çš„IPå’Œç«¯å£ struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.é€šä¿¡ while (1) &#123; char buf[128]; // æ¥æ”¶æ•°æ® int num = recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; ç»„æ’­ï¼ˆå¤šæ’­ï¼‰å•æ’­åœ°å€æ ‡è¯†å•ä¸ª IP æ¥å£ï¼Œå¹¿æ’­åœ°å€æ ‡è¯†æŸä¸ªå­ç½‘çš„æ‰€æœ‰ IP æ¥å£ï¼Œå¤šæ’­åœ°å€æ ‡è¯†ä¸€ç»„ IP æ¥å£ã€‚å•æ’­å’Œå¹¿æ’­æ˜¯å¯»å€æ–¹æ¡ˆçš„ä¸¤ä¸ªæç«¯ï¼ˆè¦ä¹ˆå•ä¸ªè¦ä¹ˆå…¨éƒ¨ï¼‰ï¼Œå¤šæ’­åˆ™æ„åœ¨ä¸¤è€…ä¹‹é—´æä¾›ä¸€ç§æŠ˜ä¸­æ–¹æ¡ˆã€‚å¤šæ’­æ•°æ®æŠ¥åªåº”è¯¥ç”±å¯¹å®ƒæ„Ÿå…´è¶£çš„æ¥å£æ¥æ”¶ï¼Œä¹Ÿå°±æ˜¯è¯´ç”±è¿è¡Œç›¸åº”å¤šæ’­ä¼šè¯åº”ç”¨ç³»ç»Ÿçš„ä¸»æœºä¸Šçš„æ¥å£æ¥æ”¶ã€‚å¦å¤–ï¼Œå¹¿æ’­ä¸€èˆ¬å±€é™äºå±€åŸŸç½‘å†…ä½¿ç”¨ï¼Œè€Œå¤šæ’­åˆ™æ—¢å¯ä»¥ç”¨äºå±€åŸŸç½‘ï¼Œä¹Ÿå¯ä»¥è·¨å¹¿åŸŸç½‘ä½¿ç”¨ã€‚ ç»„æ’­æ—¢å¯ä»¥ç”¨äºå±€åŸŸç½‘ï¼Œä¹Ÿå¯ä»¥ç”¨äºå¹¿åŸŸç½‘ å®¢æˆ·ç«¯éœ€è¦åŠ å…¥å¤šæ’­ç»„ï¼Œæ‰èƒ½æ¥æ”¶åˆ°å¤šæ’­çš„æ•°æ® ç»„æ’­åœ°å€ IPåœ°å€ è¯´æ˜ 224.0.0.0~224.0.0.255 å±€éƒ¨é“¾æ¥å¤šæ’­åœ°å€ï¼šæ˜¯ä¸ºè·¯ç”±åè®®å’Œå…¶å®ƒç”¨é€”ä¿ç•™çš„åœ°å€ï¼Œè·¯ç”±å™¨å¹¶ä¸è½¬å‘å±äºæ­¤èŒƒå›´çš„IPåŒ… 224.0.1.0~224.0.1.255 é¢„ç•™å¤šæ’­åœ°å€ï¼šå…¬ç”¨ç»„æ’­åœ°å€ï¼Œå¯ç”¨äºInternetï¼›ä½¿ç”¨å‰éœ€è¦ç”³è¯· 224.0.2.0~238.255.255.255 é¢„ç•™å¤šæ’­åœ°å€ï¼šç”¨æˆ·å¯ç”¨ç»„æ’­åœ°å€(ä¸´æ—¶ç»„åœ°å€)ï¼Œå…¨ç½‘èŒƒå›´å†…æœ‰æ•ˆ 239.0.0.0~239.255.255.255 æœ¬åœ°ç®¡ç†ç»„æ’­åœ°å€ï¼Œå¯ä¾›ç»„ç»‡å†…éƒ¨ä½¿ç”¨ï¼Œç±»ä¼¼äºç§æœ‰ IP åœ°å€ï¼Œä¸ èƒ½ç”¨äº Internetï¼Œå¯é™åˆ¶å¤šæ’­èŒƒå›´ è®¾ç½®ç»„æ’­ 1234567891011121314151617181920212223int setsockopt(int sockfd, int level, int optname,const void *optval,socklen_t optlen);// æœåŠ¡å™¨è®¾ç½®å¤šæ’­çš„ä¿¡æ¯ï¼Œå¤–å‡ºæ¥å£- level : IPPROTO_IP- optname : IP_MULTICAST_IF- optval : struct in_addr// å®¢æˆ·ç«¯åŠ å…¥åˆ°å¤šæ’­ç»„ï¼š- level : IPPROTO_IP- optname : IP_ADD_MEMBERSHIP- optval : struct ip_mreqstruct ip_mreq&#123;/* IP multicast address of group. */struct in_addr imr_multiaddr; // ç»„æ’­çš„IPåœ°å€/* Local IP address of interface. */struct in_addr imr_interface; // æœ¬åœ°çš„IPåœ°å€&#125;;typedef uint32_t in_addr_t;struct in_addr&#123;in_addr_t s_addr;&#125;; æ¡ˆä¾‹ server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.åˆ›å»ºä¸€ä¸ªé€šä¿¡çš„socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; //2.è®¾ç½®å¤šæ’­å±æ€§ï¼Œè®¾ç½®å¤–å‡ºæ¥å£ struct in_addr imr_multiaddr; //åˆå§‹åŒ–å¤šæ’­åœ°å€ inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;imr_multiaddr.s_addr); setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, sizeof(imr_multiaddr)); //3.åˆå§‹åŒ–å®¢æˆ·ç«¯åœ°å€ä¿¡æ¯ struct sockaddr_in cliaddr; cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;cliaddr.sin_addr.s_addr); // 4.é€šä¿¡ int num = 0; while (1) &#123; char sendBuf[128]; sprintf(sendBuf, &quot;hello , client......%d\\n&quot;, num++); // å‘é€æ•°æ® sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); printf(&quot;ç»„æ’­çš„æ•°æ®ï¼š %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.åˆ›å»ºä¸€ä¸ªé€šä¿¡çš„socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.å®¢æˆ·ç«¯ç»‘å®šæœ¬åœ°çš„IPå’Œç«¯å£ struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; struct ip_mreq op; inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;op.imr_multiaddr.s_addr); op.imr_interface.s_addr = INADDR_ANY; //åŠ å…¥åˆ°å¤šæ’­ç»„ setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, sizeof(op)); // 3.é€šä¿¡ while (1) &#123; char buf[128]; // æ¥æ”¶æ•°æ® int num = recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; æœ¬åœ°å¥—æ¥å­—é€šä¿¡æœ¬åœ°å¥—æ¥å­—çš„ä½œç”¨ï¼šæœ¬åœ°çš„è¿›ç¨‹é—´é€šä¿¡ æœ‰å…³ç³»çš„è¿›ç¨‹é—´çš„é€šä¿¡ï¼ˆçˆ¶å­è¿›ç¨‹ï¼‰ æ²¡æœ‰å…³ç³»çš„è¿›ç¨‹é—´çš„é€šä¿¡ æœ¬åœ°å¥—æ¥å­—å®ç°æµç¨‹å’Œç½‘ç»œå¥—æ¥å­—ç±»ä¼¼ï¼Œä¸€èˆ¬å‘¢é‡‡ç”¨TCPçš„é€šä¿¡æµç¨‹ã€‚ 123456789101112131415161718192021222324252627282930313233// æœ¬åœ°å¥—æ¥å­—é€šä¿¡çš„æµç¨‹ - tcp// æœåŠ¡å™¨ç«¯1. åˆ›å»ºç›‘å¬çš„å¥—æ¥å­—int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);2. ç›‘å¬çš„å¥—æ¥å­—ç»‘å®šæœ¬åœ°çš„å¥—æ¥å­—æ–‡ä»¶ -&gt; serverç«¯struct sockaddr_un addr;// ç»‘å®šæˆåŠŸä¹‹åï¼ŒæŒ‡å®šçš„sun_pathä¸­çš„å¥—æ¥å­—æ–‡ä»¶ä¼šè‡ªåŠ¨ç”Ÿæˆã€‚bind(lfd, addr, len);3. ç›‘å¬listen(lfd, 100);4. ç­‰å¾…å¹¶æ¥å—è¿æ¥è¯·æ±‚struct sockaddr_un cliaddr;int cfd = accept(lfd, &amp;cliaddr, len);5. é€šä¿¡æ¥æ”¶æ•°æ®ï¼šread/recvå‘é€æ•°æ®ï¼šwrite/send6. å…³é—­è¿æ¥close();// å®¢æˆ·ç«¯çš„æµç¨‹1. åˆ›å»ºé€šä¿¡çš„å¥—æ¥å­—int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);2. ç›‘å¬çš„å¥—æ¥å­—ç»‘å®šæœ¬åœ°çš„IP ç«¯å£struct sockaddr_un addr;// ç»‘å®šæˆåŠŸä¹‹åï¼ŒæŒ‡å®šçš„sun_pathä¸­çš„å¥—æ¥å­—æ–‡ä»¶ä¼šè‡ªåŠ¨ç”Ÿæˆã€‚bind(lfd, addr, len);3. è¿æ¥æœåŠ¡å™¨struct sockaddr_un serveraddr;connect(fd, &amp;serveraddr, sizeof(serveraddr));4. é€šä¿¡æ¥æ”¶æ•°æ®ï¼šread/recvå‘é€æ•°æ®ï¼šwrite/send5. å…³é—­è¿æ¥close(); æ¡ˆä¾‹ server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/un.h&gt;int main() &#123; unlink(&quot;server.sock&quot;); // 1.åˆ›å»ºç›‘å¬çš„å¥—æ¥å­— int lfd = socket(AF_LOCAL, SOCK_STREAM, 0); if(lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.ç»‘å®šæœ¬åœ°å¥—æ¥å­—æ–‡ä»¶ struct sockaddr_un addr; addr.sun_family = AF_LOCAL; strcpy(addr.sun_path, &quot;server.sock&quot;); int ret = bind(lfd, (struct sockaddr *)&amp;addr, sizeof(addr)); if(ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.ç›‘å¬ ret = listen(lfd, 100); if(ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥ struct sockaddr_un cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len); if(cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; printf(&quot;client socket filename: %s\\n&quot;, cliaddr.sun_path); // 5.é€šä¿¡ while(1) &#123; char buf[128]; int len = recv(cfd, buf, sizeof(buf), 0); if(len == -1) &#123; perror(&quot;recv&quot;); exit(-1); &#125; else if(len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; else if(len &gt; 0) &#123; printf(&quot;client say : %s\\n&quot;, buf); send(cfd, buf, len, 0); &#125; &#125; close(cfd); close(lfd); return 0;&#125; client 1","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"ç½‘ç»œç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/ç½‘ç»œç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ å­¦ä¹  ç½‘ç»œç¼–ç¨‹ IOå¤šè·¯å¤ç”¨","slug":"C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-IOå¤šè·¯å¤ç”¨","date":"2023-05-25T05:54:32.000Z","updated":"2023-06-03T08:53:51.285Z","comments":true,"path":"2023/05/25/C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-IOå¤šè·¯å¤ç”¨/","link":"","permalink":"http://example.com/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"I&#x2F;Oå¤šè·¯å¤ç”¨ï¼ˆI&#x2F;Oå¤šè·¯è½¬æ¥ï¼‰","text":"I&#x2F;Oå¤šè·¯å¤ç”¨ï¼ˆI&#x2F;Oå¤šè·¯è½¬æ¥ï¼‰ I&#x2F;O å¤šè·¯å¤ç”¨ä½¿å¾—ç¨‹åºèƒ½åŒæ—¶ç›‘å¬å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œèƒ½å¤Ÿæé«˜ç¨‹åºçš„æ€§èƒ½ï¼ŒLinux ä¸‹å®ç° I&#x2F;O å¤šè·¯å¤ç”¨çš„ç³»ç»Ÿè°ƒç”¨ä¸»è¦æœ‰ selectã€poll å’Œ epollã€‚ selectä¸»æ—¨æ€æƒ³ é¦–å…ˆè¦æ„é€ ä¸€ä¸ªå…³äºæ–‡ä»¶æè¿°ç¬¦çš„åˆ—è¡¨ï¼Œå°†è¦ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦æ·»åŠ åˆ°è¯¥åˆ—è¡¨ä¸­ã€‚ è°ƒç”¨ä¸€ä¸ªç³»ç»Ÿå‡½æ•°ï¼Œç›‘å¬è¯¥åˆ—è¡¨ä¸­çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œç›´åˆ°è¿™äº›æè¿°ç¬¦ä¸­çš„ä¸€ä¸ªæˆ–è€…å¤šä¸ªè¿›è¡Œäº†I&#x2F;Oæ“ä½œæ—¶ï¼Œè¯¥å‡½æ•°æ‰è¿”å›ã€‚ è¿™ä¸ªå‡½æ•°æ˜¯é˜»å¡ å‡½æ•°å¯¹æ–‡ä»¶æè¿°ç¬¦çš„æ£€æµ‹çš„æ“ä½œæ˜¯ç”±å†…æ ¸å®Œæˆçš„ åœ¨è¿”å›æ—¶ï¼Œå®ƒä¼šå‘Šè¯‰è¿›ç¨‹æœ‰å¤šå°‘æè¿°ç¬¦è¦è¿›è¡ŒI&#x2F;Oæ“ä½œã€‚ 123456789101112131415161718192021222324252627282930313233343536// sizeof(fd_set) = 128 1024#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);- å‚æ•°ï¼š- nfds : å§”æ‰˜å†…æ ¸æ£€æµ‹çš„æœ€å¤§æ–‡ä»¶æè¿°ç¬¦çš„å€¼ + 1- readfds : è¦æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦çš„è¯»çš„é›†åˆï¼Œå§”æ‰˜å†…æ ¸æ£€æµ‹å“ªäº›æ–‡ä»¶æè¿°ç¬¦çš„è¯»çš„å±æ€§- ä¸€èˆ¬æ£€æµ‹è¯»æ“ä½œ- å¯¹åº”çš„æ˜¯å¯¹æ–¹å‘é€è¿‡æ¥çš„æ•°æ®ï¼Œå› ä¸ºè¯»æ˜¯è¢«åŠ¨çš„æ¥æ”¶æ•°æ®ï¼Œæ£€æµ‹çš„å°±æ˜¯è¯»ç¼“å†²åŒº- æ˜¯ä¸€ä¸ªä¼ å…¥ä¼ å‡ºå‚æ•°- writefds : è¦æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦çš„å†™çš„é›†åˆï¼Œå§”æ‰˜å†…æ ¸æ£€æµ‹å“ªäº›æ–‡ä»¶æè¿°ç¬¦çš„å†™çš„å±æ€§- å§”æ‰˜å†…æ ¸æ£€æµ‹å†™ç¼“å†²åŒºæ˜¯ä¸æ˜¯è¿˜å¯ä»¥å†™æ•°æ®ï¼ˆä¸æ»¡çš„å°±å¯ä»¥å†™ï¼‰- exceptfds : æ£€æµ‹å‘ç”Ÿå¼‚å¸¸çš„æ–‡ä»¶æè¿°ç¬¦çš„é›†åˆ- timeout : è®¾ç½®çš„è¶…æ—¶æ—¶é—´struct timeval &#123;long tv_sec; /* seconds */long tv_usec; /* microseconds */&#125;;- NULL : æ°¸ä¹…é˜»å¡ï¼Œç›´åˆ°æ£€æµ‹åˆ°äº†æ–‡ä»¶æè¿°ç¬¦æœ‰å˜åŒ–- tv_sec = 0 tv_usec = 0ï¼Œ ä¸é˜»å¡- tv_sec &gt; 0 tv_usec &gt; 0ï¼Œ é˜»å¡å¯¹åº”çš„æ—¶é—´- è¿”å›å€¼ :- -1 : å¤±è´¥- &gt;0(n) : æ£€æµ‹çš„é›†åˆä¸­æœ‰nä¸ªæ–‡ä»¶æè¿°ç¬¦å‘ç”Ÿäº†å˜åŒ–// å°†å‚æ•°æ–‡ä»¶æè¿°ç¬¦fdå¯¹åº”çš„æ ‡å¿—ä½è®¾ç½®ä¸º0void FD_CLR(int fd, fd_set *set);// åˆ¤æ–­fdå¯¹åº”çš„æ ‡å¿—ä½æ˜¯0è¿˜æ˜¯1ï¼Œ è¿”å›å€¼ ï¼š fdå¯¹åº”çš„æ ‡å¿—ä½çš„å€¼ï¼Œ0ï¼Œè¿”å›0ï¼Œ 1ï¼Œè¿”å›1int FD_ISSET(int fd, fd_set *set);// å°†å‚æ•°æ–‡ä»¶æè¿°ç¬¦fd å¯¹åº”çš„æ ‡å¿—ä½ï¼Œè®¾ç½®ä¸º1void FD_SET(int fd, fd_set *set);// fd_setä¸€å…±æœ‰1024 bit, å…¨éƒ¨åˆå§‹åŒ–ä¸º0void FD_ZERO(fd_set *set); å·¥ä½œè¿‡ç¨‹åˆ†æ selectä»£ç ç¼–å†™server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;int main() &#123; // åˆ›å»ºsocket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // ç»‘å®š bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // ç›‘å¬ listen(lfd, 8); // åˆ›å»ºä¸€ä¸ªfd_setçš„é›†åˆï¼Œå­˜æ”¾çš„æ˜¯éœ€è¦æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦ fd_set rdset, tmp; FD_ZERO(&amp;rdset); FD_SET(lfd, &amp;rdset); int maxfd = lfd; while (1) &#123; tmp = rdset; // è°ƒç”¨selectç³»ç»Ÿå‡½æ•°ï¼Œè®©å†…æ ¸å¸®æ£€æµ‹å“ªäº›æ–‡ä»¶æè¿°ç¬¦æœ‰æ•°æ® int ret = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); if (ret == -1) &#123; perror(&quot;select&quot;); exit(-1); &#125; else if (ret == 0) &#123; continue; &#125; else if (ret &gt; 0) &#123; // è¯´æ˜æ£€æµ‹åˆ°äº†æœ‰æ–‡ä»¶æè¿°ç¬¦çš„å¯¹åº”çš„ç¼“å†²åŒºçš„æ•°æ®å‘ç”Ÿäº†æ”¹å˜ if (FD_ISSET(lfd, &amp;tmp)) &#123; // è¡¨ç¤ºæœ‰æ–°çš„å®¢æˆ·ç«¯è¿æ¥è¿›æ¥äº† struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); // å°†æ–°çš„æ–‡ä»¶æè¿°ç¬¦åŠ å…¥åˆ°é›†åˆä¸­ FD_SET(cfd, &amp;rdset); // æ›´æ–°æœ€å¤§çš„æ–‡ä»¶æè¿°ç¬¦ maxfd = maxfd &gt; cfd ? maxfd : cfd; &#125; for (int i = lfd + 1; i &lt;= maxfd; i++) &#123; if (FD_ISSET(i, &amp;tmp)) &#123; // è¯´æ˜è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„å®¢æˆ·ç«¯å‘æ¥äº†æ•°æ® char buf[1024] = &#123; 0 &#125;; int len = read(i, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(i); FD_CLR(i, &amp;rdset); &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(i, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // åˆ›å»ºsocket int fd = socket(PF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in seraddr; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;seraddr.sin_addr.s_addr); seraddr.sin_family = AF_INET; seraddr.sin_port = htons(9999); // è¿æ¥æœåŠ¡å™¨ int ret = connect(fd, (struct sockaddr*)&amp;seraddr, sizeof(seraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); return -1; &#125; int num = 0; while (1) &#123; char sendBuf[1024] = &#123; 0 &#125;; sprintf(sendBuf, &quot;send data %d&quot;, num++); write(fd, sendBuf, strlen(sendBuf) + 1); // æ¥æ”¶ int len = read(fd, sendBuf, sizeof(sendBuf)); if (len == -1) &#123; perror(&quot;read&quot;); return -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, sendBuf); &#125; else &#123; printf(&quot;æœåŠ¡å™¨å·²ç»æ–­å¼€è¿æ¥...\\n&quot;); break; &#125; // sleep(1); usleep(1000); &#125; close(fd); return 0;&#125; pollselectçš„ç¼ºç‚¹ poll12345678910111213141516171819202122#include &lt;poll.h&gt;struct pollfd &#123; int fd; /* å§”æ‰˜å†…æ ¸æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦ */ short events; /* å§”æ‰˜å†…æ ¸æ£€æµ‹æ–‡ä»¶æè¿°ç¬¦çš„ä»€ä¹ˆäº‹ä»¶ */ short revents; /* æ–‡ä»¶æè¿°ç¬¦å®é™…å‘ç”Ÿçš„äº‹ä»¶ */&#125;;struct pollfd myfd;myfd.fd = 5;myfd.events = POLLIN | POLLOUT;//æ—¢è¦è¯»ä¹Ÿè¦å†™int poll(struct pollfd* fds, nfds_t nfds, int timeout);// -å‚æ•°ï¼š// - fds : æ˜¯ä¸€ä¸ªstruct pollfd ç»“æ„ä½“æ•°ç»„ï¼Œè¿™æ˜¯ä¸€ä¸ªéœ€è¦æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦çš„é›†åˆ// - nfds : è¿™ä¸ªæ˜¯ç¬¬ä¸€ä¸ªå‚æ•°æ•°ç»„ä¸­æœ€åä¸€ä¸ªæœ‰æ•ˆå…ƒç´ çš„ä¸‹æ ‡ + 1// - timeout : é˜»å¡æ—¶é•¿// 0 : ä¸é˜»å¡// - 1 : é˜»å¡ï¼Œå½“æ£€æµ‹åˆ°éœ€è¦æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦æœ‰å˜åŒ–ï¼Œè§£é™¤é˜»å¡// &gt; 0 : é˜»å¡çš„æ—¶é•¿// - è¿”å›å€¼ï¼š// - 1 : å¤±è´¥// &gt; 0ï¼ˆnï¼‰ : æˆåŠŸ, nè¡¨ç¤ºæ£€æµ‹åˆ°é›†åˆä¸­æœ‰nä¸ªæ–‡ä»¶æè¿°ç¬¦å‘ç”Ÿå˜åŒ– æ¡ˆä¾‹server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;#include &lt;poll.h&gt;int main() &#123; // åˆ›å»ºsocket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // ç»‘å®š bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // ç›‘å¬ listen(lfd, 8); //åˆå§‹åŒ–æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦æ•°ç»„ struct pollfd fds[1024]; for (int i = 0;i &lt; 1024;i++) &#123; fds[i].fd = -1; fds[i].events = POLLIN; &#125; fds[0].fd = lfd; int nfds = 0; while (1) &#123; // è°ƒç”¨pollç³»ç»Ÿå‡½æ•°ï¼Œè®©å†…æ ¸å¸®æ£€æµ‹å“ªäº›æ–‡ä»¶æè¿°ç¬¦æœ‰æ•°æ® int ret = poll(fds, nfds + 1, -1); if (ret == -1) &#123; perror(&quot;poll&quot;); exit(-1); &#125; else if (ret == 0) &#123; continue; &#125; else if (ret &gt; 0) &#123; // è¯´æ˜æ£€æµ‹åˆ°äº†æœ‰æ–‡ä»¶æè¿°ç¬¦çš„å¯¹åº”çš„ç¼“å†²åŒºçš„æ•°æ®å‘ç”Ÿäº†æ”¹å˜ if (fds[0].revents &amp; POLLIN) &#123; // è¡¨ç¤ºæœ‰æ–°çš„å®¢æˆ·ç«¯è¿æ¥è¿›æ¥äº† struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); // å°†æ–°çš„æ–‡ä»¶æè¿°ç¬¦åŠ å…¥åˆ°é›†åˆä¸­ for (int i = 1;i &lt; 1024;i++) &#123; if (fds[i].fd == -1) &#123; fds[i].fd = cfd; fds[i].events = POLLIN; break; &#125; &#125; // æ›´æ–°æœ€å¤§çš„æ–‡ä»¶æè¿°ç¬¦ nfds = nfds &gt; cfd ? nfds : cfd; &#125; for (int i = 1; i &lt;= nfds; i++) &#123; if (fds[i].revents &amp; POLLIN) &#123; // è¯´æ˜è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„å®¢æˆ·ç«¯å‘æ¥äº†æ•°æ® char buf[1024] = &#123; 0 &#125;; int len = read(fds[i].fd, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(i); fds[i].fd = -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(fds[i].fd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; epollepoll()å¤šè·¯å¤ç”¨ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;sys/epoll.h&gt;// åˆ›å»ºä¸€ä¸ªæ–°çš„epollå®ä¾‹ã€‚åœ¨å†…æ ¸ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ•°æ®ï¼Œè¿™ä¸ªæ•°æ®ä¸­æœ‰ä¸¤ä¸ªæ¯”è¾ƒé‡è¦çš„æ•°æ®ï¼Œä¸€ä¸ªæ˜¯éœ€è¦æ£€// æµ‹çš„æ–‡ä»¶æè¿°ç¬¦çš„ä¿¡æ¯ï¼ˆçº¢é»‘æ ‘ï¼‰ï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯å°±ç»ªåˆ—è¡¨ï¼Œå­˜æ”¾æ£€æµ‹åˆ°æ•°æ®å‘é€æ”¹å˜çš„æ–‡ä»¶æè¿°ç¬¦ä¿¡æ¯ï¼ˆåŒå‘// é“¾è¡¨ï¼‰ã€‚int epoll_create(int size);// -å‚æ•°ï¼š// size : ç›®å‰æ²¡æœ‰æ„ä¹‰äº†ã€‚éšä¾¿å†™ä¸€ä¸ªæ•°ï¼Œå¿…é¡»å¤§äº0// - è¿”å›å€¼ï¼š// - 1 : å¤±è´¥// &gt; 0 : æ–‡ä»¶æè¿°ç¬¦ï¼Œæ“ä½œepollå®ä¾‹çš„typedef union epoll_data &#123; void* ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;;// å¸¸è§çš„Epollæ£€æµ‹äº‹ä»¶ï¼š// - EPOLLIN// - EPOLLOUT// - EPOLLERR// å¯¹epollå®ä¾‹è¿›è¡Œç®¡ç†ï¼šæ·»åŠ æ–‡ä»¶æè¿°ç¬¦ä¿¡æ¯ï¼Œåˆ é™¤ä¿¡æ¯ï¼Œä¿®æ”¹ä¿¡æ¯int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);// -å‚æ•°ï¼š// - epfd : epollå®ä¾‹å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦// - op : è¦è¿›è¡Œä»€ä¹ˆæ“ä½œ// EPOLL_CTL_ADD : æ·»åŠ // EPOLL_CTL_MOD : ä¿®æ”¹// EPOLL_CTL_DEL : åˆ é™¤// - fd : è¦æ£€æµ‹çš„æ–‡ä»¶æè¿°ç¬¦// - event : æ£€æµ‹æ–‡ä»¶æè¿°ç¬¦ä»€ä¹ˆäº‹æƒ…// æ£€æµ‹å‡½æ•°int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);// -å‚æ•°ï¼š// - epfd : epollå®ä¾‹å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦// - events : ä¼ å‡ºå‚æ•°ï¼Œä¿å­˜äº†å‘é€äº†å˜åŒ–çš„æ–‡ä»¶æè¿°ç¬¦çš„ä¿¡æ¯// - maxevents : ç¬¬äºŒä¸ªå‚æ•°ç»“æ„ä½“æ•°ç»„çš„å¤§å°// - timeout : é˜»å¡æ—¶é—´// - 0 : ä¸é˜»å¡// - -1 : é˜»å¡ï¼Œç›´åˆ°æ£€æµ‹åˆ°fdæ•°æ®å‘ç”Ÿå˜åŒ–ï¼Œè§£é™¤é˜»å¡// - &gt; 0 : é˜»å¡çš„æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰// - è¿”å›å€¼ï¼š// - æˆåŠŸï¼Œè¿”å›å‘é€å˜åŒ–çš„æ–‡ä»¶æè¿°ç¬¦çš„ä¸ªæ•° &gt; 0// - å¤±è´¥ - 1 æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;int main() &#123; // åˆ›å»ºsocket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // ç»‘å®š bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // ç›‘å¬ listen(lfd, 8); // è°ƒç”¨epoll_create()åˆ›å»ºä¸€ä¸ªepollå®ä¾‹ int epfd = epoll_create(100); // å°†ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦ç›¸å…³çš„æ£€æµ‹ä¿¡æ¯æ·»åŠ åˆ°epollå®ä¾‹ä¸­ struct epoll_event epev; epev.events = EPOLLIN; epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); struct epoll_event epevs[1024]; while (1) &#123; int ret = epoll_wait(epfd, epevs, 1024, -1); if (ret == -1) &#123; perror(&quot;epoll_wait&quot;); exit(-1); &#125; printf(&quot;ret = %d\\n&quot;, ret); for (int i = 0; i &lt; ret; i++) &#123; int curfd = epevs[i].data.fd; if (curfd == lfd) &#123; // ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦æœ‰æ•°æ®è¾¾åˆ°ï¼Œæœ‰å®¢æˆ·ç«¯è¿æ¥ struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); &#125; else &#123; if (epevs[i].events &amp; EPOLLOUT) &#123; continue; &#125; // æœ‰æ•°æ®åˆ°è¾¾ï¼Œéœ€è¦é€šä¿¡ char buf[1024] = &#123; 0 &#125;; int len = read(curfd, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(curfd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; close(lfd); close(epfd); return 0;&#125; epollçš„ä¸¤ç§å·¥ä½œæ¨¡å¼LTæ¨¡å¼ï¼ˆæ°´å¹³è§¦å‘ï¼‰åœ¨æ°´å¹³è§¦å‘æ¨¡å¼ä¸‹ï¼Œå½“æ–‡ä»¶æè¿°ç¬¦ï¼ˆä¾‹å¦‚ï¼Œsocketï¼‰çš„ç¼“å†²åŒºæœ‰æ•°æ®å¯è¯»æ—¶ï¼ŒEpoll ä¼šé€šçŸ¥ç”¨æˆ·ã€‚å¦‚æœç”¨æˆ·ä¸å¤„ç†è¿™äº›æ•°æ®ï¼ˆä¸è¯»å–ï¼‰ï¼ŒEpoll ä¼šæŒç»­é€šçŸ¥ç”¨æˆ·ã€‚ç”¨æˆ·å¯ä»¥é€‰æ‹©è¯»å–å…¨éƒ¨æ•°æ®ï¼Œéƒ¨åˆ†æ•°æ®ï¼Œæˆ–è€…ä¸è¯»å–æ•°æ®ï¼Œä½†æ˜¯åªè¦ç¼“å†²åŒºä¸­è¿˜æœ‰æ•°æ®ï¼ŒEpoll å°±ä¼šä¸€ç›´é€šçŸ¥ç”¨æˆ·ã€‚ LTï¼ˆlevel - triggeredï¼‰æ˜¯ç¼ºçœçš„å·¥ä½œæ–¹å¼ï¼Œå¹¶ä¸”åŒæ—¶æ”¯æŒ block å’Œ no-block socketã€‚åœ¨è¿™ç§åšæ³•ä¸­ï¼Œå†…æ ¸å‘Šè¯‰ä½ ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦æ˜¯å¦å°±ç»ªäº†ï¼Œç„¶åä½ å¯ä»¥å¯¹è¿™ä¸ªå°±ç»ªçš„ fd è¿›è¡Œ IO æ“ä½œã€‚å¦‚æœä½ ä¸ä½œä»»ä½•æ“ä½œï¼Œå†…æ ¸è¿˜æ˜¯ä¼šç»§ç»­é€šçŸ¥ä½ çš„ã€‚ ETæ¨¡å¼ï¼ˆè¾¹æ²¿è§¦å‘ï¼‰è¾¹æ²¿è§¦å‘æ¨¡å¼ä¸æ°´å¹³è§¦å‘æ¨¡å¼çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼ŒEpoll ä»…åœ¨äº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥ç”¨æˆ·ä¸€æ¬¡ã€‚ä¾‹å¦‚ï¼Œå½“æ–‡ä»¶æè¿°ç¬¦çš„ç¼“å†²åŒºæœ‰æ•°æ®å¯è¯»æ—¶ï¼ŒEpoll ä¼šé€šçŸ¥ç”¨æˆ·ã€‚å¦‚æœç”¨æˆ·ä¸è¯»å–æ•°æ®ï¼Œé‚£ä¹ˆä¸‹æ¬¡ Epoll æ£€æµ‹åˆ°è¿˜æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œå°±ä¸ä¼šå†é€šçŸ¥ç”¨æˆ·ã€‚ç”¨æˆ·éœ€è¦åœ¨æ”¶åˆ°é€šçŸ¥åå°½å¯èƒ½åœ°è¯»å–ç¼“å†²åŒºä¸­çš„å…¨éƒ¨æ•°æ®ï¼Œå¦åˆ™å¯èƒ½é”™è¿‡æŸäº›äº‹ä»¶ã€‚ ç®€å•æ¥è¯´ï¼Œè¾¹æ²¿è§¦å‘æ¨¡å¼æ˜¯å½“æ¡ä»¶ç”±ä¸æ»¡è¶³å˜ä¸ºæ»¡è¶³æ—¶ï¼ˆä¾‹å¦‚ï¼Œä»æ— æ•°æ®å¯è¯»å˜ä¸ºæœ‰æ•°æ®å¯è¯»ï¼‰ï¼ŒEpoll ä»…é€šçŸ¥ç”¨æˆ·ä¸€æ¬¡ã€‚ç”¨æˆ·éœ€è¦åœ¨æ”¶åˆ°é€šçŸ¥åå°½å¿«å¤„ç†äº‹ä»¶ï¼Œå¦åˆ™å¯èƒ½é”™è¿‡åç»­çš„é€šçŸ¥ã€‚è¿™ç§æ¨¡å¼é€šå¸¸é€‚ç”¨äºéé˜»å¡çš„ socketã€‚ æ€»ç»“ä¸€ä¸‹ï¼Œæ°´å¹³è§¦å‘æ¨¡å¼ï¼ˆLTï¼‰ä¼šåœ¨äº‹ä»¶æ»¡è¶³æ¡ä»¶æ—¶æŒç»­é€šçŸ¥ç”¨æˆ·ï¼Œè€Œè¾¹æ²¿è§¦å‘æ¨¡å¼ï¼ˆETï¼‰ä»…åœ¨äº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥ç”¨æˆ·ä¸€æ¬¡ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œæ ¹æ®ä¸åŒçš„ä½¿ç”¨åœºæ™¯å’Œéœ€æ±‚ï¼Œå¯ä»¥çµæ´»é€‰æ‹©è¿™ä¸¤ç§æ¨¡å¼ã€‚ ETï¼ˆedge - triggeredï¼‰æ˜¯é«˜é€Ÿå·¥ä½œæ–¹å¼ï¼Œåªæ”¯æŒ no-block socketã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œå½“æè¿°ç¬¦ä»æœªå°±ç»ªå˜ä¸ºå°±ç»ªæ—¶ï¼Œå†…æ ¸é€šè¿‡epollå‘Šè¯‰ä½ ã€‚ç„¶åå®ƒä¼šå‡è®¾ä½ çŸ¥é“æ–‡ä»¶æè¿°ç¬¦å·²ç»å°±ç»ªï¼Œå¹¶ä¸”ä¸ä¼šå†ä¸ºé‚£ä¸ªæ–‡ä»¶æè¿°ç¬¦å‘é€æ›´å¤šçš„å°±ç»ªé€šçŸ¥ï¼Œç›´åˆ°ä½ åšäº†æŸäº›æ“ä½œå¯¼è‡´é‚£ä¸ªæ–‡ä»¶æè¿°ç¬¦ä¸å†ä¸ºå°±ç»ªçŠ¶æ€äº†ã€‚ä½†æ˜¯è¯·æ³¨æ„ï¼Œå¦‚æœä¸€ç›´ä¸å¯¹è¿™ä¸ª fd ä½œ IO æ“ä½œï¼ˆä»è€Œå¯¼è‡´å®ƒå†æ¬¡å˜æˆæœªå°±ç»ªï¼‰ï¼Œå†…æ ¸ä¸ä¼šå‘é€æ›´å¤šçš„é€šçŸ¥ï¼ˆonly onceï¼‰ã€‚ET æ¨¡å¼åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šå‡å°‘äº† epoll äº‹ä»¶è¢«é‡å¤è§¦å‘çš„æ¬¡æ•°ï¼Œå› æ­¤æ•ˆç‡è¦æ¯” LT æ¨¡å¼é«˜ã€‚epollå·¥ä½œåœ¨ ET æ¨¡å¼çš„æ—¶å€™ï¼Œå¿…é¡»ä½¿ç”¨éé˜»å¡å¥—æ¥å£ï¼Œä»¥é¿å…ç”±äºä¸€ä¸ªæ–‡ä»¶å¥æŸ„çš„é˜»å¡è¯»&#x2F;é˜»å¡å†™æ“ä½œæŠŠå¤„ç†å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦çš„ä»»åŠ¡é¥¿æ­»ã€‚ 1","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"ç½‘ç»œç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/ç½‘ç»œç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++å­¦ä¹  ç½‘ç»œç¼–ç¨‹ socketé€šä¿¡åŸºç¡€","slug":"C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-socketé€šä¿¡åŸºç¡€","date":"2023-05-20T07:04:08.000Z","updated":"2023-05-23T14:13:15.220Z","comments":true,"path":"2023/05/20/C++-å­¦ä¹ -ç½‘ç»œç¼–ç¨‹-socketé€šä¿¡åŸºç¡€/","link":"","permalink":"http://example.com/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/","excerpt":"socketä»‹ç» æ‰€è°“ socketï¼ˆå¥—æ¥å­—ï¼‰ï¼Œå°±æ˜¯å¯¹ç½‘ç»œä¸­ä¸åŒä¸»æœºä¸Šçš„åº”ç”¨è¿›ç¨‹ä¹‹é—´è¿›è¡ŒåŒå‘é€šä¿¡çš„ç«¯ç‚¹çš„æŠ½è±¡ã€‚ä¸€ä¸ªå¥—æ¥å­—å°±æ˜¯ç½‘ç»œä¸Šè¿›ç¨‹é€šä¿¡çš„ä¸€ç«¯ï¼Œæä¾›äº†åº”ç”¨å±‚è¿›ç¨‹åˆ©ç”¨ç½‘ç»œåè®®äº¤æ¢æ•°æ®çš„æœºåˆ¶ã€‚ä»æ‰€å¤„çš„åœ°ä½æ¥è®²ï¼Œå¥—æ¥å­—ä¸Šè”åº”ç”¨è¿›ç¨‹ï¼Œä¸‹è”ç½‘ç»œåè®®æ ˆï¼Œæ˜¯åº”ç”¨ç¨‹åºé€šè¿‡ç½‘ç»œåè®®è¿›è¡Œé€šä¿¡çš„æ¥å£ï¼Œæ˜¯åº”ç”¨ç¨‹åºä¸ç½‘ç»œåè®®æ ¹è¿›è¡Œäº¤äº’çš„æ¥å£ã€‚ socket å¯ä»¥çœ‹æˆæ˜¯ä¸¤ä¸ªç½‘ç»œåº”ç”¨ç¨‹åºè¿›è¡Œé€šä¿¡æ—¶ï¼Œå„è‡ªé€šä¿¡è¿æ¥ä¸­çš„ç«¯ç‚¹ï¼Œè¿™æ˜¯ä¸€ä¸ªé€»è¾‘ä¸Šçš„æ¦‚å¿µã€‚å®ƒæ˜¯ç½‘ç»œç¯å¢ƒä¸­è¿›ç¨‹é—´é€šä¿¡çš„ APIï¼Œä¹Ÿæ˜¯å¯ä»¥è¢«å‘½åå’Œå¯»å€çš„é€šä¿¡ç«¯ç‚¹ï¼Œä½¿ç”¨ä¸­çš„æ¯ä¸€ä¸ªå¥—æ¥å­—éƒ½æœ‰å…¶ç±»å‹å’Œä¸€ä¸ªä¸ä¹‹ç›¸è¿è¿›ç¨‹ã€‚é€šä¿¡æ—¶å…¶ä¸­ä¸€ä¸ªç½‘ç»œåº”ç”¨ç¨‹åºå°†è¦ä¼ è¾“çš„ä¸€æ®µä¿¡æ¯å†™å…¥å®ƒæ‰€åœ¨ä¸»æœºçš„ socket ä¸­ï¼Œè¯¥ socket é€šè¿‡ä¸ç½‘ç»œæ¥å£å¡ï¼ˆNICï¼‰ç›¸è¿çš„ä¼ è¾“ä»‹è´¨å°†è¿™æ®µä¿¡æ¯é€åˆ°å¦å¤–ä¸€å°ä¸»æœºçš„ socket ä¸­ï¼Œä½¿å¯¹æ–¹èƒ½å¤Ÿæ¥æ”¶åˆ°è¿™æ®µä¿¡æ¯ã€‚socket æ˜¯ç”± IP åœ°å€å’Œç«¯å£ç»“åˆçš„ï¼Œæä¾›å‘åº”ç”¨å±‚è¿›ç¨‹ä¼ é€æ•°æ®åŒ…çš„æœºåˆ¶ã€‚ socket æœ¬èº«æœ‰â€œæ’åº§â€çš„æ„æ€ï¼Œåœ¨ Linux ç¯å¢ƒä¸‹ï¼Œç”¨äºè¡¨ç¤ºè¿›ç¨‹é—´ç½‘ç»œé€šä¿¡çš„ç‰¹æ®Šæ–‡ä»¶ç±»å‹ã€‚æœ¬è´¨ä¸ºå†…æ ¸å€ŸåŠ©ç¼“å†²åŒºå½¢æˆçš„ä¼ªæ–‡ä»¶ã€‚æ—¢ç„¶æ˜¯æ–‡ä»¶ï¼Œé‚£ä¹ˆç†æ‰€å½“ç„¶çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦å¼•ç”¨å¥—æ¥å­—ã€‚ä¸ç®¡é“ç±»ä¼¼çš„ï¼ŒLinux ç³»ç»Ÿå°†å…¶å°è£…æˆæ–‡ä»¶çš„ç›®çš„æ˜¯ä¸ºäº†ç»Ÿä¸€æ¥å£ï¼Œä½¿å¾—è¯»å†™å¥—æ¥å­—å’Œè¯»å†™æ–‡ä»¶çš„æ“ä½œä¸€è‡´ã€‚åŒºåˆ«æ˜¯ç®¡é“ä¸»è¦åº”ç”¨äºæœ¬åœ°è¿›ç¨‹é—´é€šä¿¡ï¼Œè€Œå¥—æ¥å­—å¤šåº”ç”¨äºç½‘ç»œè¿›ç¨‹é—´æ•°æ®çš„ä¼ é€’ã€‚ å¥—æ¥å­—é€šä¿¡åˆ†ä¸ºä¸¤éƒ¨åˆ†","text":"socketä»‹ç» æ‰€è°“ socketï¼ˆå¥—æ¥å­—ï¼‰ï¼Œå°±æ˜¯å¯¹ç½‘ç»œä¸­ä¸åŒä¸»æœºä¸Šçš„åº”ç”¨è¿›ç¨‹ä¹‹é—´è¿›è¡ŒåŒå‘é€šä¿¡çš„ç«¯ç‚¹çš„æŠ½è±¡ã€‚ä¸€ä¸ªå¥—æ¥å­—å°±æ˜¯ç½‘ç»œä¸Šè¿›ç¨‹é€šä¿¡çš„ä¸€ç«¯ï¼Œæä¾›äº†åº”ç”¨å±‚è¿›ç¨‹åˆ©ç”¨ç½‘ç»œåè®®äº¤æ¢æ•°æ®çš„æœºåˆ¶ã€‚ä»æ‰€å¤„çš„åœ°ä½æ¥è®²ï¼Œå¥—æ¥å­—ä¸Šè”åº”ç”¨è¿›ç¨‹ï¼Œä¸‹è”ç½‘ç»œåè®®æ ˆï¼Œæ˜¯åº”ç”¨ç¨‹åºé€šè¿‡ç½‘ç»œåè®®è¿›è¡Œé€šä¿¡çš„æ¥å£ï¼Œæ˜¯åº”ç”¨ç¨‹åºä¸ç½‘ç»œåè®®æ ¹è¿›è¡Œäº¤äº’çš„æ¥å£ã€‚ socket å¯ä»¥çœ‹æˆæ˜¯ä¸¤ä¸ªç½‘ç»œåº”ç”¨ç¨‹åºè¿›è¡Œé€šä¿¡æ—¶ï¼Œå„è‡ªé€šä¿¡è¿æ¥ä¸­çš„ç«¯ç‚¹ï¼Œè¿™æ˜¯ä¸€ä¸ªé€»è¾‘ä¸Šçš„æ¦‚å¿µã€‚å®ƒæ˜¯ç½‘ç»œç¯å¢ƒä¸­è¿›ç¨‹é—´é€šä¿¡çš„ APIï¼Œä¹Ÿæ˜¯å¯ä»¥è¢«å‘½åå’Œå¯»å€çš„é€šä¿¡ç«¯ç‚¹ï¼Œä½¿ç”¨ä¸­çš„æ¯ä¸€ä¸ªå¥—æ¥å­—éƒ½æœ‰å…¶ç±»å‹å’Œä¸€ä¸ªä¸ä¹‹ç›¸è¿è¿›ç¨‹ã€‚é€šä¿¡æ—¶å…¶ä¸­ä¸€ä¸ªç½‘ç»œåº”ç”¨ç¨‹åºå°†è¦ä¼ è¾“çš„ä¸€æ®µä¿¡æ¯å†™å…¥å®ƒæ‰€åœ¨ä¸»æœºçš„ socket ä¸­ï¼Œè¯¥ socket é€šè¿‡ä¸ç½‘ç»œæ¥å£å¡ï¼ˆNICï¼‰ç›¸è¿çš„ä¼ è¾“ä»‹è´¨å°†è¿™æ®µä¿¡æ¯é€åˆ°å¦å¤–ä¸€å°ä¸»æœºçš„ socket ä¸­ï¼Œä½¿å¯¹æ–¹èƒ½å¤Ÿæ¥æ”¶åˆ°è¿™æ®µä¿¡æ¯ã€‚socket æ˜¯ç”± IP åœ°å€å’Œç«¯å£ç»“åˆçš„ï¼Œæä¾›å‘åº”ç”¨å±‚è¿›ç¨‹ä¼ é€æ•°æ®åŒ…çš„æœºåˆ¶ã€‚ socket æœ¬èº«æœ‰â€œæ’åº§â€çš„æ„æ€ï¼Œåœ¨ Linux ç¯å¢ƒä¸‹ï¼Œç”¨äºè¡¨ç¤ºè¿›ç¨‹é—´ç½‘ç»œé€šä¿¡çš„ç‰¹æ®Šæ–‡ä»¶ç±»å‹ã€‚æœ¬è´¨ä¸ºå†…æ ¸å€ŸåŠ©ç¼“å†²åŒºå½¢æˆçš„ä¼ªæ–‡ä»¶ã€‚æ—¢ç„¶æ˜¯æ–‡ä»¶ï¼Œé‚£ä¹ˆç†æ‰€å½“ç„¶çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦å¼•ç”¨å¥—æ¥å­—ã€‚ä¸ç®¡é“ç±»ä¼¼çš„ï¼ŒLinux ç³»ç»Ÿå°†å…¶å°è£…æˆæ–‡ä»¶çš„ç›®çš„æ˜¯ä¸ºäº†ç»Ÿä¸€æ¥å£ï¼Œä½¿å¾—è¯»å†™å¥—æ¥å­—å’Œè¯»å†™æ–‡ä»¶çš„æ“ä½œä¸€è‡´ã€‚åŒºåˆ«æ˜¯ç®¡é“ä¸»è¦åº”ç”¨äºæœ¬åœ°è¿›ç¨‹é—´é€šä¿¡ï¼Œè€Œå¥—æ¥å­—å¤šåº”ç”¨äºç½‘ç»œè¿›ç¨‹é—´æ•°æ®çš„ä¼ é€’ã€‚ å¥—æ¥å­—é€šä¿¡åˆ†ä¸ºä¸¤éƒ¨åˆ† æœåŠ¡å™¨ç«¯ï¼šè¢«åŠ¨æ¥å—è¿æ¥ï¼Œä¸€èˆ¬ä¸ä¼šä¸»åŠ¨å‘èµ·è¿æ¥ å®¢æˆ·ç«¯ï¼šä¸»åŠ¨å‘æœåŠ¡å™¨å‘èµ·è¿æ¥ socketæ˜¯ä¸€å¥—é€šä¿¡çš„æ¥å£ï¼ŒLinux å’Œ Windows éƒ½æœ‰ï¼Œä½†æ˜¯æœ‰ä¸€äº›ç»†å¾®çš„å·®åˆ« å­—èŠ‚åºç®€ä»‹ ç°ä»£ CPU çš„ç´¯åŠ å™¨ä¸€æ¬¡éƒ½èƒ½è£…è½½ï¼ˆè‡³å°‘ï¼‰4 å­—èŠ‚ï¼ˆè¿™é‡Œè€ƒè™‘ 32 ä½æœºï¼‰ï¼Œå³ä¸€ä¸ªæ•´æ•°ã€‚é‚£ä¹ˆè¿™ 4å­—èŠ‚åœ¨å†…å­˜ä¸­æ’åˆ—çš„é¡ºåºå°†å½±å“å®ƒè¢«ç´¯åŠ å™¨è£…è½½æˆçš„æ•´æ•°çš„å€¼ï¼Œè¿™å°±æ˜¯å­—èŠ‚åºé—®é¢˜ã€‚åœ¨å„ç§è®¡ç®—æœºä½“ç³»ç»“æ„ä¸­ï¼Œå¯¹äºå­—èŠ‚ã€å­—ç­‰çš„å­˜å‚¨æœºåˆ¶æœ‰æ‰€ä¸åŒï¼Œå› è€Œå¼•å‘äº†è®¡ç®—æœºé€šä¿¡é¢†åŸŸä¸­ä¸€ä¸ªå¾ˆé‡è¦çš„é—®é¢˜ï¼Œå³é€šä¿¡åŒæ–¹äº¤æµçš„ä¿¡æ¯å•å…ƒï¼ˆæ¯”ç‰¹ã€å­—èŠ‚ã€å­—ã€åŒå­—ç­‰ç­‰ï¼‰åº”è¯¥ä»¥ä»€ä¹ˆæ ·çš„é¡ºåºè¿›è¡Œä¼ é€ã€‚å¦‚æœä¸è¾¾æˆä¸€è‡´çš„è§„åˆ™ï¼Œé€šä¿¡åŒæ–¹å°†æ— æ³•è¿›è¡Œæ­£ç¡®çš„ç¼–ç &#x2F;è¯‘ç ä»è€Œå¯¼è‡´é€šä¿¡å¤±è´¥ã€‚ å­—èŠ‚åºï¼Œé¡¾åæ€ä¹‰å­—èŠ‚çš„é¡ºåºï¼Œå°±æ˜¯å¤§äºä¸€ä¸ªå­—èŠ‚ç±»å‹çš„æ•°æ®åœ¨å†…å­˜ä¸­çš„å­˜æ”¾é¡ºåº(ä¸€ä¸ªå­—èŠ‚çš„æ•°æ®å½“ç„¶å°±æ— éœ€è°ˆé¡ºåºçš„é—®é¢˜äº†)ã€‚ å­—èŠ‚åºåˆ†ä¸ºå¤§ç«¯å­—èŠ‚åºï¼ˆBig-Endianï¼‰ å’Œå°ç«¯å­—èŠ‚åºï¼ˆLittle-Endianï¼‰ã€‚å¤§ç«¯å­—èŠ‚åºæ˜¯æŒ‡ä¸€ä¸ªæ•´æ•°çš„æœ€é«˜ä½å­—èŠ‚ï¼ˆ23 ~ 31 bitï¼‰å­˜å‚¨åœ¨å†…å­˜çš„ä½åœ°å€å¤„ï¼Œä½ä½å­—èŠ‚ï¼ˆ0 ~ 7 bitï¼‰å­˜å‚¨åœ¨å†…å­˜çš„é«˜åœ°å€å¤„ï¼›å°ç«¯å­—èŠ‚åºåˆ™æ˜¯æŒ‡æ•´æ•°çš„é«˜ä½å­—èŠ‚å­˜å‚¨åœ¨å†…å­˜çš„é«˜åœ°å€å¤„ï¼Œè€Œä½ä½å­—èŠ‚åˆ™å­˜å‚¨åœ¨å†…å­˜çš„ä½åœ°å€å¤„ã€‚ å­—èŠ‚åºä¸¾ä¾‹ å­—èŠ‚(ä»é«˜åˆ°ä½)ï¼š0x 01 02 03 04 12 34 56 78 å°ç«¯å­—èŠ‚åºï¼Œå¢é•¿æ–¹å‘ç”±ä½åˆ°é«˜ å¤§ç«¯å­—èŠ‚åºï¼Œå¢é•¿æ–¹å‘ç”±ä½åˆ°é«˜ æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930//å­—èŠ‚åºï¼šå­—èŠ‚åœ¨å†…å­˜ä¸­å­˜å‚¨çš„é¡ºåº//å°ç«¯å­—èŠ‚åºï¼šæ•°æ®çš„é«˜ä½å­—èŠ‚å­˜å‚¨åœ¨å†…å­˜çš„é«˜ä½åœ°å€ï¼Œä½ä½å­—èŠ‚å­˜å‚¨åœ¨å†…å­˜çš„ä½ä½åœ°å€//å¤§ç«¯å­—èŠ‚åºï¼šæ•°æ®çš„ä½ä½å­—èŠ‚å­˜å‚¨åœ¨å†…å­˜çš„é«˜ä½åœ°å€ï¼Œé«˜ä½å­—èŠ‚å­˜å‚¨åœ¨å†…å­˜çš„ä½ä½åœ°å€//é€šè¿‡ä»£ç æ£€æµ‹å½“å‰ä¸»æœºçš„å­—èŠ‚åº#include&lt;stdio.h&gt;int main()&#123; union &#123; short value; char bytes[sizeof(short)]; // char[2] &#125;test; test.value = 0x0102; if ((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) &#123; printf(&quot;å¤§ç«¯å­—èŠ‚åº\\n&quot;); &#125; else if ((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1)) &#123; printf(&quot;å°ç«¯å­—èŠ‚åº\\n&quot;); &#125; else &#123; printf(&quot;æœªçŸ¥\\n&quot;); &#125;&#125; ç¼–è¯‘è¿è¡Œç»“æœä¸ºå°æ®µå­—èŠ‚åº å­—èŠ‚åºè½¬æ¢ å½“æ ¼å¼åŒ–çš„æ•°æ®åœ¨ä¸¤å°ä½¿ç”¨ä¸åŒå­—èŠ‚åºçš„ä¸»æœºä¹‹é—´ç›´æ¥ä¼ é€’æ—¶ï¼Œæ¥æ”¶ç«¯å¿…ç„¶é”™è¯¯çš„è§£é‡Šä¹‹ã€‚è§£å†³é—®é¢˜çš„æ–¹æ³•æ˜¯ï¼šå‘é€ç«¯æ€»æ˜¯æŠŠè¦å‘é€çš„æ•°æ®è½¬æ¢æˆå¤§ç«¯å­—èŠ‚åºæ•°æ®åå†å‘é€ï¼Œè€Œæ¥æ”¶ç«¯çŸ¥é“å¯¹æ–¹ä¼ é€è¿‡æ¥çš„æ•°æ®æ€»æ˜¯é‡‡ç”¨å¤§ç«¯å­—èŠ‚åºï¼Œæ‰€ä»¥æ¥æ”¶ç«¯å¯ä»¥æ ¹æ®è‡ªèº«é‡‡ç”¨çš„å­—èŠ‚åºå†³å®šæ˜¯å¦å¯¹æ¥æ”¶åˆ°çš„æ•°æ®è¿›è¡Œè½¬æ¢ï¼ˆå°ç«¯æœºè½¬æ¢ï¼Œå¤§ç«¯æœºä¸è½¬æ¢ï¼‰ã€‚ ç½‘ç»œå­—èŠ‚é¡ºåºæ˜¯ TCP&#x2F;IP ä¸­è§„å®šå¥½çš„ä¸€ç§æ•°æ®è¡¨ç¤ºæ ¼å¼ï¼Œå®ƒä¸å…·ä½“çš„ CPU ç±»å‹ã€æ“ä½œç³»ç»Ÿç­‰æ— å…³ï¼Œä»è€Œå¯ä»¥ä¿è¯æ•°æ®åœ¨ä¸åŒä¸»æœºä¹‹é—´ä¼ è¾“æ—¶èƒ½å¤Ÿè¢«æ­£ç¡®è§£é‡Šï¼Œç½‘ç»œå­—èŠ‚é¡ºåºé‡‡ç”¨å¤§ç«¯æ’åºæ–¹å¼ã€‚ BSD Socketæä¾›äº†å°è£…å¥½çš„è½¬æ¢æ¥å£ï¼Œæ–¹ä¾¿ç¨‹åºå‘˜ä½¿ç”¨ã€‚åŒ…æ‹¬ä»ä¸»æœºå­—èŠ‚åºåˆ°ç½‘ç»œå­—èŠ‚åºçš„è½¬æ¢å‡½æ•°ï¼šhtonsã€htonlï¼›ä»ç½‘ç»œå­—èŠ‚åºåˆ°ä¸»æœºå­—èŠ‚åºçš„è½¬æ¢å‡½æ•°ï¼šntohsã€ntohlã€‚ 12345h - host ä¸»æœºï¼Œä¸»æœºå­—èŠ‚åºto - è½¬æ¢æˆä»€ä¹ˆn - network ç½‘ç»œå­—èŠ‚åºs - short unsigned shortl - long unsigned int 123456789#include &lt;arpa/inet.h&gt;//ç½‘ç»œé€šä¿¡æ—¶ï¼Œéœ€è¦å°†ä¸»æœºå­—èŠ‚åºè½¬æ¢æˆç½‘ç»œå­—èŠ‚åºï¼ˆå¤§ç«¯ï¼‰//å¦å¤–ä¸€æ®µè·å–åˆ°æ•°æ®ä»¥åæ ¹æ®æƒ…å†µå°†ç½‘ç»œå­—èŠ‚åºè½¬æ¢æˆä¸»æœºå­—èŠ‚åº// è½¬æ¢ç«¯å£uint16_t htons(uint16_t hostshort); // ä¸»æœºå­—èŠ‚åº - ç½‘ç»œå­—èŠ‚åºuint16_t ntohs(uint16_t netshort); // ä¸»æœºå­—èŠ‚åº - ç½‘ç»œå­—èŠ‚åº// è½¬IPuint32_t htonl(uint32_t hostlong); // ä¸»æœºå­—èŠ‚åº - ç½‘ç»œå­—èŠ‚åºuint32_t ntohl(uint32_t netlong); // ä¸»æœºå­—èŠ‚åº - ç½‘ç»œå­—èŠ‚åº æ¡ˆä¾‹ 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;arpa/inet.h&gt;int main()&#123; //htons è½¬æ¢ç«¯å£ unsigned short a = 0x0102; printf(&quot;%x\\n&quot;, a); unsigned short b = htons(a); printf(&quot;%x\\n&quot;, b); printf(&quot;-------------------------------\\n&quot;); //htonl è½¬æ¢IP char buf[4] = &#123; 192,168,1,100 &#125;; int num = *(int*)buf; int sum = htonl(num); unsigned char* p = (char*)âˆ‘ printf(&quot;%d %d %d %d\\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); printf(&quot;-------------------------------\\n&quot;); //ntohl è½¬æ¢IP unsigned char buf1[4] = &#123; 1,1,168,192 &#125;; int num1 = *(int*)buf1; int sum1 = ntohl(num1); unsigned char* p1 = (unsigned char*)&amp;sum1; printf(&quot;%d %d %d %d\\n&quot;, *p1, *(p1 + 1), *(p1 + 2), *(p1 + 3)); //ntohs } ç¼–è¯‘è¿è¡Œ socketåœ°å€ socketåœ°å€å…¶å®æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œå°è£…ç«¯å£å·å’ŒIPç­‰ä¿¡æ¯ã€‚åé¢çš„socketç›¸å…³çš„apiä¸­éœ€è¦ä½¿ç”¨åˆ°è¿™ä¸ªsocketåœ°å€ã€‚ å®¢æˆ·ç«¯ -&gt; æœåŠ¡å™¨ï¼ˆIP, Portï¼‰ é€šç”¨socketåœ°å€socket ç½‘ç»œç¼–ç¨‹æ¥å£ä¸­è¡¨ç¤º socket åœ°å€çš„æ˜¯ç»“æ„ä½“ sockaddrï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š 123456#include &lt;bits/socket.h&gt;struct sockaddr &#123;sa_family_t sa_family;char sa_data[14];&#125;;typedef unsigned short int sa_family_t sa_family æˆå‘˜æ˜¯åœ°å€æ—ç±»å‹ï¼ˆsa_family_tï¼‰çš„å˜é‡ã€‚åœ°å€æ—ç±»å‹é€šå¸¸ä¸åè®®æ—ç±»å‹å¯¹åº”ã€‚å¸¸è§çš„åè®®æ—ï¼ˆprotocol familyï¼Œä¹Ÿç§° domainï¼‰å’Œå¯¹åº”çš„åœ°å€æ—å…¥ä¸‹æ‰€ç¤ºï¼š åè®®æ— åœ°å€æ— æè¿° PF_UNIX AF_UNIX UNIXæœ¬åœ°åŸŸåè®®æ— PF_INET AF_INET TCP&#x2F;IPv4åè®®æ— PF_INET6 AF_INET6 TCP&#x2F;IPv6åè®®æ— å® PF_* å’Œ AF_* éƒ½å®šä¹‰åœ¨ bits&#x2F;socket.h å¤´æ–‡ä»¶ä¸­ï¼Œä¸”åè€…ä¸å‰è€…æœ‰å®Œå…¨ç›¸åŒçš„å€¼ï¼Œæ‰€ä»¥äºŒè€…é€šå¸¸æ··ç”¨ã€‚ sa_data æˆå‘˜ç”¨äºå­˜æ”¾ socket åœ°å€å€¼ã€‚ä½†æ˜¯ï¼Œä¸åŒçš„åè®®æ—çš„åœ°å€å€¼å…·æœ‰ä¸åŒçš„å«ä¹‰å’Œé•¿åº¦ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š åè®®æ— åœ°å€å€¼å«ä¹‰å’Œé•¿åº¦ PF_UNIX æ–‡ä»¶çš„è·¯å¾„åï¼Œé•¿åº¦å¯è¾¾åˆ°108å­—èŠ‚ PF_INET 16bitç«¯å£å·å’Œ32bit IPv4åœ°å€ï¼Œå…±6å­—èŠ‚ PF_INET6 16bitç«¯å£å·ï¼Œ32bitæµæ ‡è¯†ï¼Œ128bit IPv6åœ°å€ï¼Œ32bit èŒƒå›´IDï¼Œå…±26å­—èŠ‚ ç”±ä¸Šè¡¨å¯çŸ¥ï¼Œ14 å­—èŠ‚çš„ sa_data æ ¹æœ¬æ— æ³•å®¹çº³å¤šæ•°åè®®æ—çš„åœ°å€å€¼ã€‚å› æ­¤ï¼ŒLinux å®šä¹‰äº†ä¸‹é¢è¿™ä¸ªæ–°çš„é€šç”¨çš„ socket åœ°å€ç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä½“ä¸ä»…æä¾›äº†è¶³å¤Ÿå¤§çš„ç©ºé—´ç”¨äºå­˜æ”¾åœ°å€å€¼ï¼Œè€Œä¸”æ˜¯å†…å­˜å¯¹é½çš„ã€‚ 12345678#include &lt;bits/socket.h&gt;struct sockaddr_storage&#123;sa_family_t sa_family;unsigned long int __ss_align;char __ss_padding[ 128 - sizeof(__ss_align) ];&#125;;typedef unsigned short int sa_family_t; ä¸“ç”¨socketåœ°å€å¾ˆå¤šç½‘ç»œç¼–ç¨‹å‡½æ•°è¯ç”Ÿæ—©äº IPv4 åè®®ï¼Œé‚£æ—¶å€™éƒ½ä½¿ç”¨çš„æ˜¯ struct sockaddr ç»“æ„ä½“ï¼Œä¸ºäº†å‘å‰å…¼å®¹ï¼Œç°åœ¨sockaddr é€€åŒ–æˆäº†ï¼ˆvoid *ï¼‰çš„ä½œç”¨ï¼Œä¼ é€’ä¸€ä¸ªåœ°å€ç»™å‡½æ•°ï¼Œè‡³äºè¿™ä¸ªå‡½æ•°æ˜¯ sockaddr_in è¿˜æ˜¯sockaddr_in6ï¼Œç”±åœ°å€æ—ç¡®å®šï¼Œç„¶åå‡½æ•°å†…éƒ¨å†å¼ºåˆ¶ç±»å‹è½¬åŒ–ä¸ºæ‰€éœ€çš„åœ°å€ç±»å‹ã€‚ UNIX æœ¬åœ°åŸŸåè®®æ—ä½¿ç”¨å¦‚ä¸‹ä¸“ç”¨çš„ socket åœ°å€ç»“æ„ä½“ï¼š 123456#include &lt;sys/un.h&gt;struct sockaddr_un&#123;sa_family_t sin_family;char sun_path[108];&#125;; TCP&#x2F;IP åè®®æ—æœ‰ sockaddr_in å’Œ sockaddr_in6 ä¸¤ä¸ªä¸“ç”¨çš„ socket åœ°å€ç»“æ„ä½“ï¼Œå®ƒä»¬åˆ†åˆ«ç”¨äº IPv4 å’ŒIPv6ï¼š 123456789101112131415161718192021222324252627#include &lt;netinet/in.h&gt;struct sockaddr_in&#123;sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) *///åœ°å€æ—ç±»å‹in_port_t sin_port; /* Port number. *///ç«¯å£å·struct in_addr sin_addr; /* Internet address. *///IPåœ°å€/* Pad to size of `struct sockaddr&#x27;. *///å¡«å……éƒ¨åˆ†unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -sizeof (in_port_t) - sizeof (struct in_addr)];&#125;;struct in_addr&#123;in_addr_t s_addr;&#125;;struct sockaddr_in6&#123;sa_family_t sin6_family;in_port_t sin6_port; /* Transport layer port # */uint32_t sin6_flowinfo; /* IPv6 flow information */struct in6_addr sin6_addr; /* IPv6 address */uint32_t sin6_scope_id; /* IPv6 scope-id */&#125;;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef uint16_t in_port_t;typedef uint32_t in_addr_t;#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int) æ‰€æœ‰ä¸“ç”¨ socket åœ°å€ï¼ˆä»¥åŠ sockaddr_storageï¼‰ç±»å‹çš„å˜é‡åœ¨å®é™…ä½¿ç”¨æ—¶éƒ½éœ€è¦è½¬åŒ–ä¸ºé€šç”¨ socket åœ°å€ç±»å‹ sockaddrï¼ˆå¼ºåˆ¶è½¬åŒ–å³å¯ï¼‰ï¼Œå› ä¸ºæ‰€æœ‰ socket ç¼–ç¨‹æ¥å£ä½¿ç”¨çš„åœ°å€å‚æ•°ç±»å‹éƒ½æ˜¯ sockaddrã€‚ IPåœ°å€è½¬æ¢ï¼ˆå­—ç¬¦ä¸²IPè½¬æ¢æˆæ•´æ•°ã€ä¸»æœºç½‘ç»œå­—èŠ‚åºçš„è½¬æ¢ï¼‰é€šå¸¸ï¼Œäººä»¬ä¹ æƒ¯ç”¨å¯è¯»æ€§å¥½çš„å­—ç¬¦ä¸²æ¥è¡¨ç¤º IP åœ°å€ï¼Œæ¯”å¦‚ç”¨ç‚¹åˆ†åè¿›åˆ¶å­—ç¬¦ä¸²è¡¨ç¤º IPv4 åœ°å€ï¼Œä»¥åŠç”¨åå…­è¿›åˆ¶å­—ç¬¦ä¸²è¡¨ç¤º IPv6 åœ°å€ã€‚ä½†ç¼–ç¨‹ä¸­æˆ‘ä»¬éœ€è¦å…ˆæŠŠå®ƒä»¬è½¬åŒ–ä¸ºæ•´æ•°ï¼ˆäºŒè¿›åˆ¶æ•°ï¼‰æ–¹èƒ½ä½¿ç”¨ã€‚è€Œè®°å½•æ—¥å¿—æ—¶åˆ™ç›¸åï¼Œæˆ‘ä»¬è¦æŠŠæ•´æ•°è¡¨ç¤ºçš„ IP åœ°å€è½¬åŒ–ä¸ºå¯è¯»çš„å­—ç¬¦ä¸²ã€‚ä¸‹é¢ 3 ä¸ªå‡½æ•°å¯ç”¨äºç”¨ç‚¹åˆ†åè¿›åˆ¶å­—ç¬¦ä¸²è¡¨ç¤ºçš„ IPv4 åœ°å€å’Œç”¨ç½‘ç»œå­—èŠ‚åºæ•´æ•°è¡¨ç¤ºçš„ IPv4 åœ°å€ä¹‹é—´çš„è½¬æ¢ï¼š 1234#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *cp);int inet_aton(const char *cp, struct in_addr *inp);char *inet_ntoa(struct in_addr in); ä¸‹é¢è¿™å¯¹æ›´æ–°çš„å‡½æ•°ä¹Ÿèƒ½å®Œæˆå‰é¢ 3 ä¸ªå‡½æ•°åŒæ ·çš„åŠŸèƒ½ï¼Œå¹¶ä¸”å®ƒä»¬åŒæ—¶é€‚ç”¨ IPv4 åœ°å€å’Œ IPv6 åœ°å€ï¼š 12345678910111213#include &lt;arpa/inet.h&gt;// p:ç‚¹åˆ†åè¿›åˆ¶çš„IPå­—ç¬¦ä¸²ï¼Œn:è¡¨ç¤ºnetworkï¼Œç½‘ç»œå­—èŠ‚åºçš„æ•´æ•°int inet_pton(int af, const char *src, void *dst);//af:åœ°å€æ—ï¼š AF_INET AF_INET6//src:éœ€è¦è½¬æ¢çš„ç‚¹åˆ†åè¿›åˆ¶çš„IPå­—ç¬¦ä¸²//dst:è½¬æ¢åçš„ç»“æœä¿å­˜åœ¨è¿™ä¸ªé‡Œé¢// å°†ç½‘ç»œå­—èŠ‚åºçš„æ•´æ•°ï¼Œè½¬æ¢æˆç‚¹åˆ†åè¿›åˆ¶çš„IPåœ°å€å­—ç¬¦ä¸²const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);//af:åœ°å€æ—ï¼š AF_INET AF_INET6//src: è¦è½¬æ¢çš„ipçš„æ•´æ•°çš„åœ°å€//dst: è½¬æ¢æˆIPåœ°å€å­—ç¬¦ä¸²ä¿å­˜çš„åœ°æ–¹//sizeï¼šç¬¬ä¸‰ä¸ªå‚æ•°çš„å¤§å°ï¼ˆæ•°ç»„çš„å¤§å°ï¼‰//è¿”å›å€¼ï¼šè¿”å›è½¬æ¢åçš„æ•°æ®çš„åœ°å€ï¼ˆå­—ç¬¦ä¸²ï¼‰ï¼Œå’Œ dst æ˜¯ä¸€æ ·çš„ æ¡ˆä¾‹ 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;arpa/inet.h&gt;int main()&#123; //åˆ›å»ºä¸€ä¸ªIPå­—ç¬¦ä¸²ï¼Œç‚¹åˆ†åè¿›åˆ¶çš„IPåœ°å€å­—ç¬¦ä¸² char buf[] = &quot;192.168.1.4&quot;; unsigned int num = 0; inet_pton(AF_INET, buf, &amp;num); unsigned char* p = (unsigned char*)&amp;num; printf(&quot;%d %d %d %d\\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); //å°†ç½‘ç»œå­—èŠ‚åºçš„IPæ•´æ•°è½¬æ¢æˆç‚¹åˆ†åè¿›åˆ¶çš„IPå­—ç¬¦ä¸² char ip[16] = &quot;&quot;; const char* str = inet_ntop(AF_INET, &amp;num, ip, 16); printf(&quot;%s\\n&quot;, str); printf(&quot;%d\\n&quot;, ip == str);&#125; ç¼–è¯‘è¿è¡Œç»“æœå¦‚ä¸‹ï¼š TCPé€šä¿¡æµç¨‹ UDP TCP æ˜¯å¦åˆ›å»ºè¿æ¥ æ— è¿æ¥ é¢å‘è¿æ¥ æ˜¯å¦å¯é  ä¸å¯é  å¯é  è¿æ¥çš„å¯¹è±¡ä¸ªæ•° ä¸€å¯¹ä¸€ã€ä¸€å¯¹å¤šã€å¤šå¯¹ä¸€ã€å¤šå¯¹å¤š æ”¯æŒä¸€å¯¹ä¸€ ä¼ è¾“çš„æ–¹å¼ é¢å‘æ•°æ®æŠ¥ é¢å‘å­—èŠ‚æµ é¦–éƒ¨å¼€é”€ 8ä¸ªå­—èŠ‚ æœ€å°‘20ä¸ªå­—èŠ‚ é€‚ç”¨åœºæ™¯ å®æ—¶åº”ç”¨ï¼ˆè§†é¢‘ä¼šè®®ï¼Œç›´æ’­ï¼‰ å¯é æ€§é«˜çš„åº”ç”¨ï¼ˆæ–‡ä»¶ä¼ è¾“ï¼‰ TCPé€šä¿¡çš„æµç¨‹æœåŠ¡å™¨ç«¯ åˆ›å»ºä¸€ä¸ªç”¨äºç›‘å¬çš„å¥—æ¥å­— ç›‘å¬ï¼šç›‘å¬æœ‰å®¢æˆ·ç«¯çš„è¿æ¥ å¥—æ¥å­—ï¼šè¿™ä¸ªå¥—æ¥å­—å…¶å®å°±æ˜¯ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ å°†è¿™ä¸ªç›‘å¬æ–‡ä»¶æè¿°ç¬¦å’Œæœ¬åœ°çš„IPå’Œç«¯å£ç»‘å®šï¼ˆIPå’Œç«¯å£å°±æ˜¯æœåŠ¡å™¨çš„åœ°å€ä¿¡æ¯ï¼‰ å®¢æˆ·ç«¯è¿æ¥æœåŠ¡å™¨çš„æ—¶å€™ä½¿ç”¨çš„å°±æ˜¯è¿™ä¸ªIPå’Œç«¯å£ è®¾ç½®ç›‘å¬ï¼Œç›‘å¬çš„fdå¼€å§‹å·¥ä½œ é˜»å¡ç­‰å¾…ï¼Œå½“æœ‰å®¢æˆ·ç«¯å‘èµ·è¿æ¥ï¼Œè§£é™¤é˜»å¡ï¼Œæ¥å—å®¢æˆ·ç«¯çš„è¿æ¥ï¼Œä¼šå¾—åˆ°ä¸€ä¸ªå’Œå®¢æˆ·ç«¯é€šä¿¡çš„å¥—æ¥å­—ï¼ˆfdï¼‰ é€šä¿¡ æ¥æ”¶æ•°æ® å‘é€æ•°æ® é€šä¿¡ç»“æŸï¼Œæ–­å¼€è¿æ¥ å®¢æˆ·ç«¯ åˆ›å»ºä¸€ä¸ªç”¨äºé€šä¿¡çš„å¥—æ¥å­—ï¼ˆfdï¼‰ è¿æ¥æœåŠ¡å™¨ï¼Œéœ€è¦æŒ‡å®šè¿æ¥çš„æœåŠ¡å™¨çš„ IP å’Œ ç«¯å£ è¿æ¥æˆåŠŸäº†ï¼Œå®¢æˆ·ç«¯å¯ä»¥ç›´æ¥å’ŒæœåŠ¡å™¨é€šä¿¡ æ¥æ”¶æ•°æ® å‘é€æ•°æ® é€šä¿¡ç»“æŸï¼Œæ–­å¼€è¿æ¥ å¥—æ¥å­—å‡½æ•°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt; // åŒ…å«äº†è¿™ä¸ªå¤´æ–‡ä»¶ï¼Œä¸Šé¢ä¸¤ä¸ªå°±å¯ä»¥çœç•¥int socket(int domain, int type, int protocol);- åŠŸèƒ½ï¼šåˆ›å»ºä¸€ä¸ªå¥—æ¥å­—- å‚æ•°ï¼š- domain: åè®®æ—AF_INET : ipv4AF_INET6 : ipv6AF_UNIX, AF_LOCAL : æœ¬åœ°å¥—æ¥å­—é€šä¿¡ï¼ˆè¿›ç¨‹é—´é€šä¿¡ï¼‰- type: é€šä¿¡è¿‡ç¨‹ä¸­ä½¿ç”¨çš„åè®®ç±»å‹SOCK_STREAM : æµå¼åè®®SOCK_DGRAM : æŠ¥å¼åè®®- protocol : å…·ä½“çš„ä¸€ä¸ªåè®®ã€‚ä¸€èˆ¬å†™0- SOCK_STREAM : æµå¼åè®®é»˜è®¤ä½¿ç”¨ TCP- SOCK_DGRAM : æŠ¥å¼åè®®é»˜è®¤ä½¿ç”¨ UDP- è¿”å›å€¼ï¼š- æˆåŠŸï¼šè¿”å›æ–‡ä»¶æè¿°ç¬¦ï¼Œæ“ä½œçš„å°±æ˜¯å†…æ ¸ç¼“å†²åŒºã€‚- å¤±è´¥ï¼š-1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socketå‘½å- åŠŸèƒ½ï¼šç»‘å®šï¼Œå°†fd å’Œæœ¬åœ°çš„IP + ç«¯å£è¿›è¡Œç»‘å®š- å‚æ•°ï¼š- sockfd : é€šè¿‡socketå‡½æ•°å¾—åˆ°çš„æ–‡ä»¶æè¿°ç¬¦- addr : éœ€è¦ç»‘å®šçš„socketåœ°å€ï¼Œè¿™ä¸ªåœ°å€å°è£…äº†ipå’Œç«¯å£å·çš„ä¿¡æ¯- addrlen : ç¬¬äºŒä¸ªå‚æ•°ç»“æ„ä½“å çš„å†…å­˜å¤§å°int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn- åŠŸèƒ½ï¼šç›‘å¬è¿™ä¸ªsocketä¸Šçš„è¿æ¥- å‚æ•°ï¼š- sockfd : é€šè¿‡socket()å‡½æ•°å¾—åˆ°çš„æ–‡ä»¶æè¿°ç¬¦- backlog : æœªè¿æ¥çš„å’Œå·²ç»è¿æ¥çš„å’Œçš„æœ€å¤§å€¼ï¼Œ 5int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);- åŠŸèƒ½ï¼šæ¥æ”¶å®¢æˆ·ç«¯è¿æ¥ï¼Œé»˜è®¤æ˜¯ä¸€ä¸ªé˜»å¡çš„å‡½æ•°ï¼Œé˜»å¡ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥- å‚æ•°ï¼š- sockfd : ç”¨äºç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦- addr : ä¼ å‡ºå‚æ•°ï¼Œè®°å½•äº†è¿æ¥æˆåŠŸåå®¢æˆ·ç«¯çš„åœ°å€ä¿¡æ¯ï¼ˆipï¼Œportï¼‰- addrlen : æŒ‡å®šç¬¬äºŒä¸ªå‚æ•°çš„å¯¹åº”çš„å†…å­˜å¤§å°- è¿”å›å€¼ï¼š- æˆåŠŸ ï¼šç”¨äºé€šä¿¡çš„æ–‡ä»¶æè¿°ç¬¦- -1 ï¼š å¤±è´¥int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);- åŠŸèƒ½ï¼š å®¢æˆ·ç«¯è¿æ¥æœåŠ¡å™¨- å‚æ•°ï¼š- sockfd : ç”¨äºé€šä¿¡çš„æ–‡ä»¶æè¿°ç¬¦- addr : å®¢æˆ·ç«¯è¦è¿æ¥çš„æœåŠ¡å™¨çš„åœ°å€ä¿¡æ¯- addrlen : ç¬¬äºŒä¸ªå‚æ•°çš„å†…å­˜å¤§å°- è¿”å›å€¼ï¼šæˆåŠŸ 0ï¼Œ å¤±è´¥ -1ssize_t write(int fd, const void *buf, size_t count); // å†™æ•°æ®ssize_t read(int fd, void *buf, size_t count); // è¯»æ•°æ® TCPé€šä¿¡å®ç°æœåŠ¡ç«¯å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// TCP é€šä¿¡çš„æœåŠ¡å™¨ç«¯#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.åˆ›å»ºsocket(ç”¨äºç›‘å¬çš„å¥—æ¥å­—) int lfd = socket(AF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.ç»‘å®š struct sockaddr_in saddr; saddr.sin_family = AF_INET; // inet_pton(AF_INET, &quot;192.168.194.129&quot;, saddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; // 0.0.0.0 saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.ç›‘å¬ ret = listen(lfd, 8); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥ struct sockaddr_in clientaddr; int len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;clientaddr, &amp;len); if (cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; // è¾“å‡ºå®¢æˆ·ç«¯çš„ä¿¡æ¯ char clientIP[16]; inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(&quot;client ip is %s, port is %d\\n&quot;, clientIP, clientPort); // 5.é€šä¿¡ char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; // è·å–å®¢æˆ·ç«¯çš„æ•°æ® int num = read(cfd, recvBuf, sizeof(recvBuf)); if (num == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (num &gt; 0) &#123; printf(&quot;recv client data : %s\\n&quot;, recvBuf); &#125; else if (num == 0) &#123; // è¡¨ç¤ºå®¢æˆ·ç«¯æ–­å¼€è¿æ¥ printf(&quot;clinet closed...&quot;); break; &#125; char* data = &quot;hello,i am server&quot;; // ç»™å®¢æˆ·ç«¯å‘é€æ•°æ® write(cfd, data, strlen(data)); &#125; // å…³é—­æ–‡ä»¶æè¿°ç¬¦ close(cfd); close(lfd); return 0;&#125; å®¢æˆ·ç«¯å®ç°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// TCPé€šä¿¡çš„å®¢æˆ·ç«¯#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.åˆ›å»ºå¥—æ¥å­— int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.è¿æ¥æœåŠ¡å™¨ç«¯ struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.194.129&quot;, &amp;serveraddr.sin_addr.s_addr); serveraddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 3. é€šä¿¡ char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; char* data = &quot;hello,i am client&quot;; // ç»™å®¢æˆ·ç«¯å‘é€æ•°æ® write(fd, data, strlen(data)); sleep(1); int len = read(fd, recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv server data : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; // è¡¨ç¤ºæœåŠ¡å™¨ç«¯æ–­å¼€è¿æ¥ printf(&quot;server closed...&quot;); break; &#125; &#125; // å…³é—­è¿æ¥ close(fd); return 0;&#125; ç¼–è¯‘è¿è¡Œå¦‚ä¸‹ TCPä¸‰æ¬¡æ¡æ‰‹TCP æ˜¯ä¸€ç§é¢å‘è¿æ¥çš„å•æ’­åè®®ï¼Œåœ¨å‘é€æ•°æ®å‰ï¼Œé€šä¿¡åŒæ–¹å¿…é¡»åœ¨å½¼æ­¤é—´å»ºç«‹ä¸€æ¡è¿æ¥ã€‚æ‰€è°“çš„â€œè¿æ¥â€ï¼Œå…¶å®æ˜¯å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨çš„å†…å­˜é‡Œä¿å­˜çš„ä¸€ä»½å…³äºå¯¹æ–¹çš„ä¿¡æ¯ï¼Œå¦‚ IP åœ°å€ã€ç«¯å£å·ç­‰ã€‚TCP å¯ä»¥çœ‹æˆæ˜¯ä¸€ç§å­—èŠ‚æµï¼Œå®ƒä¼šå¤„ç† IP å±‚æˆ–ä»¥ä¸‹çš„å±‚çš„ä¸¢åŒ…ã€é‡å¤ä»¥åŠé”™è¯¯é—®é¢˜ã€‚åœ¨è¿æ¥çš„å»ºç«‹è¿‡ç¨‹ä¸­ï¼ŒåŒæ–¹éœ€è¦äº¤æ¢ä¸€äº›è¿æ¥çš„å‚æ•°ã€‚è¿™äº›å‚æ•°å¯ä»¥æ”¾åœ¨ TCP å¤´éƒ¨ã€‚TCP æä¾›äº†ä¸€ç§å¯é ã€é¢å‘è¿æ¥ã€å­—èŠ‚æµã€ä¼ è¾“å±‚çš„æœåŠ¡ï¼Œé‡‡ç”¨ä¸‰æ¬¡æ¡æ‰‹å»ºç«‹ä¸€ä¸ªè¿æ¥ã€‚é‡‡ç”¨ å››æ¬¡æŒ¥æ‰‹æ¥å…³é—­ä¸€ä¸ªè¿æ¥ã€‚ ä¸‰æ¬¡æ¡æ‰‹çš„ç›®çš„æ˜¯ä¿è¯åŒæ–¹äº’ç›¸ä¹‹é—´å»ºç«‹äº†è¿æ¥ ä¸‰æ¬¡æ¡æ‰‹å‘ç”Ÿåœ¨å®¢æˆ·ç«¯è¿æ¥çš„æ—¶å€™ï¼Œå½“è°ƒç”¨connect()ï¼Œåº•å±‚ä¼šé€šè¿‡TCPåè®®è¿›è¡Œä¸‰æ¬¡æ¡æ‰‹ã€‚ 16 ä½ç«¯å£å·ï¼ˆport numberï¼‰ï¼šå‘ŠçŸ¥ä¸»æœºæŠ¥æ–‡æ®µæ˜¯æ¥è‡ªå“ªé‡Œï¼ˆæºç«¯å£ï¼‰ä»¥åŠä¼ ç»™å“ªä¸ªä¸Šå±‚åè®®æˆ–åº”ç”¨ç¨‹åºï¼ˆç›®çš„ç«¯å£ï¼‰çš„ã€‚è¿›è¡Œ TCP é€šä¿¡æ—¶ï¼Œå®¢æˆ·ç«¯é€šå¸¸ä½¿ç”¨ç³»ç»Ÿè‡ªåŠ¨é€‰æ‹©çš„ä¸´æ—¶ç«¯å£å·ã€‚ 32 ä½åºå·ï¼ˆsequence numberï¼‰ï¼šä¸€æ¬¡ TCP é€šä¿¡ï¼ˆä» TCP è¿æ¥å»ºç«‹åˆ°æ–­å¼€ï¼‰è¿‡ç¨‹ä¸­æŸä¸€ä¸ªä¼ è¾“æ–¹å‘ä¸Šçš„å­—èŠ‚æµçš„æ¯ä¸ªå­—èŠ‚çš„ç¼–å·ã€‚å‡è®¾ä¸»æœº A å’Œä¸»æœº B è¿›è¡Œ TCP é€šä¿¡ï¼ŒA å‘é€ç»™ B çš„ç¬¬ä¸€ä¸ªTCP æŠ¥æ–‡æ®µä¸­ï¼Œåºå·å€¼è¢«ç³»ç»Ÿåˆå§‹åŒ–ä¸ºæŸä¸ªéšæœºå€¼ ISNï¼ˆInitial Sequence Numberï¼Œåˆå§‹åºå·å€¼ï¼‰ã€‚é‚£ä¹ˆåœ¨è¯¥ä¼ è¾“æ–¹å‘ä¸Šï¼ˆä» A åˆ° Bï¼‰ï¼Œåç»­çš„ TCP æŠ¥æ–‡æ®µä¸­åºå·å€¼å°†è¢«ç³»ç»Ÿè®¾ç½®æˆ ISN åŠ ä¸Šè¯¥æŠ¥æ–‡æ®µæ‰€æºå¸¦æ•°æ®çš„ç¬¬ä¸€ä¸ªå­—èŠ‚åœ¨æ•´ä¸ªå­—èŠ‚æµä¸­çš„åç§»ã€‚ä¾‹å¦‚ï¼ŒæŸä¸ª TCP æŠ¥æ–‡æ®µä¼ é€çš„æ•°æ®æ˜¯å­—èŠ‚æµä¸­çš„ç¬¬ 1025 ~ 2048 å­—èŠ‚ï¼Œé‚£ä¹ˆè¯¥æŠ¥æ–‡æ®µçš„åºå·å€¼å°±æ˜¯ ISN + 1025ã€‚å¦å¤–ä¸€ä¸ªä¼ è¾“æ–¹å‘ï¼ˆä»B åˆ° Aï¼‰çš„ TCP æŠ¥æ–‡æ®µçš„åºå·å€¼ä¹Ÿå…·æœ‰ç›¸åŒçš„å«ä¹‰ã€‚ 32 ä½ç¡®è®¤å·ï¼ˆacknowledgement numberï¼‰ï¼šç”¨ä½œå¯¹å¦ä¸€æ–¹å‘é€æ¥çš„ TCP æŠ¥æ–‡æ®µçš„å“åº”ã€‚å…¶å€¼æ˜¯æ”¶åˆ°çš„ TCP æŠ¥æ–‡æ®µçš„åºå·å€¼ + æ ‡å¿—ä½é•¿åº¦ï¼ˆSYNï¼ŒFINï¼‰ + æ•°æ®é•¿åº¦ ã€‚å‡è®¾ä¸»æœº A å’Œä¸»æœº B è¿›è¡ŒTCP é€šä¿¡ï¼Œé‚£ä¹ˆ A å‘é€å‡ºçš„ TCP æŠ¥æ–‡æ®µä¸ä»…æºå¸¦è‡ªå·±çš„åºå·ï¼Œè€Œä¸”åŒ…å«å¯¹ B å‘é€æ¥çš„ TCP æŠ¥æ–‡æ®µçš„ç¡®è®¤å·ã€‚åä¹‹ï¼ŒB å‘é€å‡ºçš„ TCP æŠ¥æ–‡æ®µä¹ŸåŒæ ·æºå¸¦è‡ªå·±çš„åºå·å’Œå¯¹ A å‘é€æ¥çš„æŠ¥æ–‡æ®µçš„ç¡®è®¤åºå·ã€‚ 4 ä½å¤´éƒ¨é•¿åº¦ï¼ˆhead lengthï¼‰ï¼šæ ‡è¯†è¯¥ TCP å¤´éƒ¨æœ‰å¤šå°‘ä¸ª 32 bit(4 å­—èŠ‚)ã€‚å› ä¸º 4 ä½æœ€å¤§èƒ½è¡¨ç¤º15ï¼Œæ‰€ä»¥ TCP å¤´éƒ¨æœ€é•¿æ˜¯60 å­—èŠ‚ã€‚ 6 ä½æ ‡å¿—ä½åŒ…å«å¦‚ä¸‹å‡ é¡¹ï¼š URG æ ‡å¿—ï¼Œè¡¨ç¤ºç´§æ€¥æŒ‡é’ˆï¼ˆurgent pointerï¼‰æ˜¯å¦æœ‰æ•ˆã€‚ ACK æ ‡å¿—ï¼Œè¡¨ç¤ºç¡®è®¤å·æ˜¯å¦æœ‰æ•ˆã€‚æˆ‘ä»¬ç§°æºå¸¦ ACK æ ‡å¿—çš„ TCP æŠ¥æ–‡æ®µä¸ºç¡®è®¤æŠ¥æ–‡æ®µã€‚ PSH æ ‡å¿—ï¼Œæç¤ºæ¥æ”¶ç«¯åº”ç”¨ç¨‹åºåº”è¯¥ç«‹å³ä» TCP æ¥æ”¶ç¼“å†²åŒºä¸­è¯»èµ°æ•°æ®ï¼Œä¸ºæ¥æ”¶åç»­æ•°æ®è…¾å‡ºç©ºé—´ï¼ˆå¦‚æœåº”ç”¨ç¨‹åºä¸å°†æ¥æ”¶åˆ°çš„æ•°æ®è¯»èµ°ï¼Œå®ƒä»¬å°±ä¼šä¸€ç›´åœç•™åœ¨ TCP æ¥æ”¶ç¼“å†²åŒºä¸­ï¼‰ã€‚ RST æ ‡å¿—ï¼Œè¡¨ç¤ºè¦æ±‚å¯¹æ–¹é‡æ–°å»ºç«‹è¿æ¥ã€‚æˆ‘ä»¬ç§°æºå¸¦ RST æ ‡å¿—çš„ TCP æŠ¥æ–‡æ®µä¸ºå¤ä½æŠ¥æ–‡æ®µã€‚ SYN æ ‡å¿—ï¼Œè¡¨ç¤ºè¯·æ±‚å»ºç«‹ä¸€ä¸ªè¿æ¥ã€‚æˆ‘ä»¬ç§°æºå¸¦ SYN æ ‡å¿—çš„ TCP æŠ¥æ–‡æ®µä¸ºåŒæ­¥æŠ¥æ–‡æ®µã€‚ FIN æ ‡å¿—ï¼Œè¡¨ç¤ºé€šçŸ¥å¯¹æ–¹æœ¬ç«¯è¦å…³é—­è¿æ¥äº†ã€‚æˆ‘ä»¬ç§°æºå¸¦ FIN æ ‡å¿—çš„ TCP æŠ¥æ–‡æ®µä¸ºç»“æŸæŠ¥æ–‡æ®µã€‚ 16 ä½çª—å£å¤§å°ï¼ˆwindow sizeï¼‰ï¼šæ˜¯ TCP æµé‡æ§åˆ¶çš„ä¸€ä¸ªæ‰‹æ®µã€‚è¿™é‡Œè¯´çš„çª—å£ï¼ŒæŒ‡çš„æ˜¯æ¥æ”¶é€šå‘Šçª—å£ï¼ˆReceiver Windowï¼ŒRWNDï¼‰ã€‚å®ƒå‘Šè¯‰å¯¹æ–¹æœ¬ç«¯çš„ TCP æ¥æ”¶ç¼“å†²åŒºè¿˜èƒ½å®¹çº³å¤šå°‘å­—èŠ‚çš„æ•°æ®ï¼Œè¿™æ ·å¯¹æ–¹å°±å¯ä»¥æ§åˆ¶å‘é€æ•°æ®çš„é€Ÿåº¦ã€‚ 16 ä½æ ¡éªŒå’Œï¼ˆTCP checksumï¼‰ï¼šç”±å‘é€ç«¯å¡«å……ï¼Œæ¥æ”¶ç«¯å¯¹ TCP æŠ¥æ–‡æ®µæ‰§è¡Œ CRC ç®—æ³•ä»¥æ ¡éªŒTCP æŠ¥æ–‡æ®µåœ¨ä¼ è¾“è¿‡ç¨‹ä¸­æ˜¯å¦æŸåã€‚æ³¨æ„ï¼Œè¿™ä¸ªæ ¡éªŒä¸ä»…åŒ…æ‹¬ TCP å¤´éƒ¨ï¼Œä¹ŸåŒ…æ‹¬æ•°æ®éƒ¨åˆ†ã€‚è¿™ä¹Ÿæ˜¯ TCP å¯é ä¼ è¾“çš„ä¸€ä¸ªé‡è¦ä¿éšœã€‚ 16 ä½ç´§æ€¥æŒ‡é’ˆï¼ˆurgent pointerï¼‰ï¼šæ˜¯ä¸€ä¸ªæ­£çš„åç§»é‡ã€‚å®ƒå’Œåºå·å­—æ®µçš„å€¼ç›¸åŠ è¡¨ç¤ºæœ€åä¸€ä¸ªç´§æ€¥æ•°æ®çš„ä¸‹ä¸€ä¸ªå­—èŠ‚çš„åºå·ã€‚å› æ­¤ï¼Œç¡®åˆ‡åœ°è¯´ï¼Œè¿™ä¸ªå­—æ®µæ˜¯ç´§æ€¥æŒ‡é’ˆç›¸å¯¹å½“å‰åºå·çš„åç§»ï¼Œä¸å¦¨ç§°ä¹‹ä¸ºç´§æ€¥åç§»ã€‚TCP çš„ç´§æ€¥æŒ‡é’ˆæ˜¯å‘é€ç«¯å‘æ¥æ”¶ç«¯å‘é€ç´§æ€¥æ•°æ®çš„æ–¹æ³•ã€‚ ç¬¬ä¸€æ¬¡æ¡æ‰‹ï¼š å®¢æˆ·ç«¯å°†SYNæ ‡å¿—ä½ç½®ä¸º1 ç”Ÿæˆä¸€ä¸ªéšæœºçš„32ä½çš„åºå·ï¼Œè¿™ä¸ªåºå·åè¾¹æ˜¯å¯ä»¥æºå¸¦æ•°æ®ï¼ˆæ•°æ®çš„å¤§å° ç¬¬äºŒæ¬¡æ¡æ‰‹ï¼š æœåŠ¡å™¨ç«¯æ¥å—å®¢æˆ·ç«¯çš„è¿æ¥ï¼šACK &#x3D; 1 æœåŠ¡å™¨ç«¯ä¼šå›å‘ä¸€ä¸ªç¡®è®¤åºå·ï¼šack &#x3D; å®¢æˆ·ç«¯çš„åºå·+æ•°æ®ç«¯çš„é•¿åº¦+FIN&#x2F;SYNï¼ˆæŒ‰ä¸€ä¸ªå­—èŠ‚ç®—ï¼‰ æœåŠ¡å™¨ç«¯ä¼šåƒå‘å®¢æˆ·ç«¯å‘èµ·è¿æ¥è¯·æ±‚ï¼š SYN &#x3D; 1 æœåŠ¡å™¨ä¼šç”Ÿæˆä¸€ä¸ªéšæœºåºå·ï¼š seq &#x3D; K ç¬¬ä¸‰æ¬¡æ¡æ‰‹ï¼š å®¢æˆ·ç«¯åº”ç­”æœåŠ¡å™¨çš„è¿æ¥è¯·æ±‚ï¼š ACK &#x3D; 1 å®¢æˆ·ç«¯å›å¤æ”¶åˆ°äº†æœåŠ¡å™¨ç«¯çš„æ•°æ®ï¼š ack &#x3D; æœåŠ¡ç«¯çš„åºå· + æ•°æ®é•¿åº¦ + SYN&#x2F;FINï¼ˆæŒ‰ä¸€ä¸ªå­—èŠ‚ç®—ï¼‰ TCPæ»‘åŠ¨çª—å£æ»‘åŠ¨çª—å£ï¼ˆSliding windowï¼‰æ˜¯ä¸€ç§æµé‡æ§åˆ¶æŠ€æœ¯ã€‚æ—©æœŸçš„ç½‘ç»œé€šä¿¡ä¸­ï¼Œé€šä¿¡åŒæ–¹ä¸ä¼šè€ƒè™‘ç½‘ç»œçš„æ‹¥æŒ¤æƒ…å†µç›´æ¥å‘é€æ•°æ®ã€‚ç”±äºå¤§å®¶ä¸çŸ¥é“ç½‘ç»œæ‹¥å¡çŠ¶å†µï¼ŒåŒæ—¶å‘é€æ•°æ®ï¼Œå¯¼è‡´ä¸­é—´èŠ‚ç‚¹é˜»å¡æ‰åŒ…ï¼Œè°ä¹Ÿå‘ä¸äº†æ•°æ®ï¼Œæ‰€ä»¥å°±æœ‰äº†æ»‘åŠ¨çª—å£æœºåˆ¶æ¥è§£å†³æ­¤é—®é¢˜ã€‚æ»‘åŠ¨çª—å£åè®®æ˜¯ç”¨æ¥æ”¹å–„ååé‡çš„ä¸€ç§æŠ€æœ¯ï¼Œå³å®¹è®¸å‘é€æ–¹åœ¨æ¥æ”¶ä»»ä½•åº”ç­”ä¹‹å‰ä¼ é€é™„åŠ çš„åŒ…ã€‚æ¥æ”¶æ–¹å‘Šè¯‰å‘é€æ–¹åœ¨æŸä¸€æ—¶åˆ»èƒ½é€å¤šå°‘åŒ…ï¼ˆç§°çª—å£å°ºå¯¸ï¼‰ã€‚TCP ä¸­é‡‡ç”¨æ»‘åŠ¨çª—å£æ¥è¿›è¡Œä¼ è¾“æ§åˆ¶ï¼Œæ»‘åŠ¨çª—å£çš„å¤§å°æ„å‘³ç€æ¥æ”¶æ–¹è¿˜æœ‰å¤šå¤§çš„ç¼“å†²åŒºå¯ä»¥ç”¨äºæ¥æ”¶æ•°æ®ã€‚å‘é€æ–¹å¯ä»¥é€šè¿‡æ»‘åŠ¨çª—å£çš„å¤§å°æ¥ç¡®å®šåº”è¯¥å‘é€å¤šå°‘å­—èŠ‚çš„æ•°æ®ã€‚å½“æ»‘åŠ¨çª—å£ä¸º 0æ—¶ï¼Œå‘é€æ–¹ä¸€èˆ¬ä¸èƒ½å†å‘é€æ•°æ®æŠ¥ã€‚ æ»‘åŠ¨çª—å£æ˜¯ TCP ä¸­å®ç°è¯¸å¦‚ ACK ç¡®è®¤ã€æµé‡æ§åˆ¶ã€æ‹¥å¡æ§åˆ¶çš„æ‰¿è½½ç»“æ„ã€‚ TCPï¼ˆä¼ è¾“æ§åˆ¶åè®®ï¼‰æ»‘åŠ¨çª—å£æœºåˆ¶æ˜¯ä¸€ç§æµé‡æ§åˆ¶å’Œæ‹¥å¡æ§åˆ¶ç­–ç•¥ï¼Œç”¨äºä¿è¯æ•°æ®åŒ…åœ¨ä¸å¯é çš„ç½‘ç»œç¯å¢ƒä¸­å¯é åœ°ä¼ è¾“ã€‚æ»‘åŠ¨çª—å£æœºåˆ¶å…è®¸å‘é€æ–¹åœ¨æ²¡æœ‰æ”¶åˆ°æ¥æ”¶æ–¹ç¡®è®¤ï¼ˆACKï¼‰çš„æƒ…å†µä¸‹è¿ç»­å‘é€å¤šä¸ªæ•°æ®åŒ…ã€‚åŒæ—¶ï¼Œæ¥æ”¶æ–¹å¯ä»¥é€šè¿‡è°ƒæ•´çª—å£å¤§å°æ¥æ§åˆ¶å‘é€æ–¹çš„å‘é€é€Ÿç‡ã€‚ æ»‘åŠ¨çª—å£çš„ä¸»è¦ç»„æˆéƒ¨åˆ†åŒ…æ‹¬ï¼š **å‘é€çª—å£ (Send Window)**ï¼šå‘é€æ–¹ç»´æŠ¤çš„ä¸€ä¸ªç¼“å†²åŒºï¼Œç”¨äºå­˜å‚¨å°šæœªè¢«ç¡®è®¤çš„æ•°æ®åŒ…ã€‚å‘é€çª—å£çš„å¤§å°å†³å®šäº†å‘é€æ–¹åœ¨ç­‰å¾…ç¡®è®¤ä¹‹å‰å¯ä»¥å‘é€å¤šå°‘æ•°æ®åŒ…ã€‚ **æ¥æ”¶çª—å£ (Receive Window)**ï¼šæ¥æ”¶æ–¹ç»´æŠ¤çš„ä¸€ä¸ªç¼“å†²åŒºï¼Œç”¨äºå­˜å‚¨å°šæœªè¢«å¤„ç†çš„æ•°æ®åŒ…ã€‚æ¥æ”¶çª—å£çš„å¤§å°å†³å®šäº†æ¥æ”¶æ–¹å¯ä»¥ä¸€æ¬¡æ¥æ”¶å¤šå°‘æ•°æ®åŒ…ã€‚ æ»‘åŠ¨çª—å£æœºåˆ¶çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š å‘é€æ–¹å°†æ•°æ®åˆ’åˆ†ä¸ºä¸€ä¸ªä¸ªæ•°æ®åŒ…ï¼Œå°†è¿™äº›æ•°æ®åŒ…ä¾æ¬¡å­˜å‚¨åœ¨å‘é€çª—å£ä¸­ã€‚ å‘é€æ–¹å°†å‘é€çª—å£ä¸­çš„æ•°æ®åŒ…å‘é€ç»™æ¥æ”¶æ–¹ã€‚å‘é€çª—å£çš„å¤§å°å†³å®šäº†åœ¨ç­‰å¾…ç¡®è®¤ä¹‹å‰å¯ä»¥å‘é€å¤šå°‘æ•°æ®åŒ…ã€‚ æ¥æ”¶æ–¹æ”¶åˆ°æ•°æ®åŒ…åï¼Œå°†æ•°æ®åŒ…å­˜å‚¨åœ¨æ¥æ”¶çª—å£ä¸­ï¼Œå¹¶å‘å‘é€æ–¹å‘é€ç¡®è®¤ï¼ˆACKï¼‰ã€‚ å‘é€æ–¹æ”¶åˆ°æ¥æ”¶æ–¹çš„ç¡®è®¤åï¼Œå°†ç¡®è®¤è¿‡çš„æ•°æ®åŒ…ä»å‘é€çª—å£ä¸­ç§»é™¤ï¼Œå¹¶å‘å‰æ»‘åŠ¨çª—å£ï¼Œä»¥ä¾¿ç»§ç»­å‘é€æ›´å¤šæ•°æ®åŒ…ã€‚ å¦‚æœå‘é€æ–¹åœ¨æŒ‡å®šçš„è¶…æ—¶æ—¶é—´å†…æ²¡æœ‰æ”¶åˆ°ç¡®è®¤ï¼Œå°†ä¼šé‡æ–°å‘é€æœªè¢«ç¡®è®¤çš„æ•°æ®åŒ…ã€‚ æ¥æ”¶æ–¹å¯ä»¥é€šè¿‡è°ƒæ•´æ¥æ”¶çª—å£çš„å¤§å°æ¥æ§åˆ¶å‘é€æ–¹çš„å‘é€é€Ÿç‡ã€‚ä¾‹å¦‚ï¼Œå½“æ¥æ”¶æ–¹çš„å¤„ç†é€Ÿåº¦è¾ƒæ…¢æ—¶ï¼Œæ¥æ”¶æ–¹å¯ä»¥å‡å°æ¥æ”¶çª—å£çš„å¤§å°ï¼Œä»è€Œé™ä½å‘é€æ–¹çš„å‘é€é€Ÿç‡ã€‚ æ»‘åŠ¨çª—å£æœºåˆ¶çš„ä¼˜ç‚¹ï¼š å¯ä»¥å®ç°æµé‡æ§åˆ¶ï¼Œé˜²æ­¢æ¥æ”¶æ–¹è¢«å‘é€æ–¹çš„æ•°æ®åŒ…æ·¹æ²¡ã€‚ å¯ä»¥æé«˜ç½‘ç»œä¼ è¾“çš„æ•ˆç‡ï¼Œå› ä¸ºå‘é€æ–¹å¯ä»¥åœ¨ä¸ç­‰å¾…ç¡®è®¤çš„æƒ…å†µä¸‹è¿ç»­å‘é€å¤šä¸ªæ•°æ®åŒ…ã€‚ å¯ä»¥å®ç°æ‹¥å¡æ§åˆ¶ï¼Œå½“ç½‘ç»œå‡ºç°æ‹¥å¡æ—¶ï¼Œå‘é€æ–¹å¯ä»¥å‡å°å‘é€çª—å£çš„å¤§å°ï¼Œé™ä½å‘é€é€Ÿç‡ã€‚ TCPå››æ¬¡æŒ¥æ‰‹å››æ¬¡æŒ¥æ‰‹ï¼Œåœ¨ç¨‹åºä¸­è°ƒç”¨äº†close()ä¼šä½¿ç”¨TCPåè®®è¿›è¡Œå››æ¬¡æŒ¥æ‰‹ å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯éƒ½å¯ä»¥ä¸»åŠ¨å‘èµ·æ–­å¼€è¿æ¥ï¼Œè°å…ˆè°ƒç”¨close()è°å°±æ˜¯å…ˆå‘èµ·ã€‚ å› ä¸ºåœ¨TCPè¿æ¥çš„æ—¶å€™ï¼Œé‡‡ç”¨ä¸‰æ¬¡æ¡æ‰‹çš„å»ºç«‹æ˜¯åŒå‘çš„ï¼Œåœ¨æ–­å¼€çš„æ—¶å€™ä¹Ÿéœ€è¦åŒå‘æ–­å¼€ã€‚ TCPå››æ¬¡æŒ¥æ‰‹æ˜¯æŒ‡åœ¨TCPè¿æ¥æ–­å¼€è¿‡ç¨‹ä¸­ï¼Œä¸¤ä¸ªé€šä¿¡èŠ‚ç‚¹ä¹‹é—´è¿›è¡Œå››æ¬¡æŠ¥æ–‡äº¤äº’çš„è¿‡ç¨‹ã€‚ å››æ¬¡æŒ¥æ‰‹çš„è¿‡ç¨‹å¦‚ä¸‹ï¼š ç¬¬ä¸€æ¬¡æŒ¥æ‰‹ï¼ˆFIN_WAIT_1ï¼‰ï¼šå½“ä¸»åŠ¨å…³é—­è¿æ¥çš„ä¸€æ–¹ï¼ˆé€šå¸¸ç§°ä¸ºå®¢æˆ·ç«¯ï¼‰è®¤ä¸ºä¸å†éœ€è¦å‘é€æ•°æ®æ—¶ï¼Œå®ƒä¼šè®¾ç½®FINæ ‡å¿—å¹¶å°†æ­¤æŠ¥æ–‡å‘é€ç»™å¦ä¸€æ–¹ï¼ˆé€šå¸¸ç§°ä¸ºæœåŠ¡å™¨ç«¯ï¼‰ã€‚è¿™è¡¨ç¤ºå®¢æˆ·ç«¯å·²ç»å®Œæˆäº†æ•°æ®ä¼ è¾“ã€‚ ç¬¬äºŒæ¬¡æŒ¥æ‰‹ï¼ˆCLOSE_WAITï¼‰ï¼šå½“æœåŠ¡å™¨ç«¯æ”¶åˆ°å¸¦æœ‰FINæ ‡å¿—çš„æŠ¥æ–‡æ—¶ï¼Œå®ƒä¼šå‘é€ä¸€ä¸ªç¡®è®¤æŠ¥æ–‡ï¼ˆACKï¼‰ç»™å®¢æˆ·ç«¯ã€‚ç¡®è®¤æŠ¥æ–‡çš„ACKåºå·ç­‰äºæ¥æ”¶åˆ°çš„FINæŠ¥æ–‡åºå·åŠ 1ã€‚æ­¤æ—¶ï¼ŒæœåŠ¡å™¨ç«¯è¿›å…¥CLOSE_WAITçŠ¶æ€ï¼Œè¡¨ç¤ºå®ƒå·²ç»çŸ¥é“å®¢æˆ·ç«¯ä¸å†å‘é€æ•°æ®ã€‚ æ³¨æ„ï¼Œæ­¤æ—¶TCPè¿æ¥ä»ç„¶æ˜¯åŠå¼€æ”¾çš„ï¼Œå› ä¸ºæœåŠ¡å™¨ç«¯ä»ç„¶å¯ä»¥å‘å®¢æˆ·ç«¯å‘é€æ•°æ®ã€‚ ç¬¬ä¸‰æ¬¡æŒ¥æ‰‹ï¼ˆFIN_WAIT_2ï¼‰ï¼šå½“å®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡å™¨ç«¯çš„ç¡®è®¤æŠ¥æ–‡åï¼Œå®ƒä¼šè¿›å…¥FIN_WAIT_2çŠ¶æ€ã€‚æ­¤æ—¶ï¼Œå®¢æˆ·ç«¯å·²ç»å…³é—­äº†å‘é€é€šé“ï¼Œä½†æ˜¯ä»ç„¶å¯ä»¥æ¥æ”¶æœåŠ¡å™¨ç«¯çš„æ•°æ®ã€‚ ç¬¬å››æ¬¡æŒ¥æ‰‹ï¼ˆTIME_WAITï¼‰ï¼šå½“æœåŠ¡å™¨ç«¯å®Œæˆæ•°æ®å‘é€åï¼Œå®ƒä¹Ÿä¼šè®¾ç½®FINæ ‡å¿—å¹¶å‘é€ç»™å®¢æˆ·ç«¯ã€‚å½“å®¢æˆ·ç«¯æ”¶åˆ°å¸¦æœ‰FINæ ‡å¿—çš„æŠ¥æ–‡æ—¶ï¼Œå®ƒä¼šå‘é€ä¸€ä¸ªç¡®è®¤æŠ¥æ–‡ï¼ˆACKï¼‰ç»™æœåŠ¡å™¨ç«¯ã€‚ç¡®è®¤æŠ¥æ–‡çš„ACKåºå·ç­‰äºæ¥æ”¶åˆ°çš„FINæŠ¥æ–‡åºå·åŠ 1ã€‚æ­¤æ—¶ï¼Œå®¢æˆ·ç«¯è¿›å…¥TIME_WAITçŠ¶æ€ï¼Œå¹¶ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼ˆé€šå¸¸ä¸º2å€çš„æœ€å¤§æŠ¥æ–‡ç”Ÿå‘½å‘¨æœŸï¼‰ä»¥ç¡®ä¿æœåŠ¡å™¨ç«¯æ”¶åˆ°ç¡®è®¤æŠ¥æ–‡ã€‚åœ¨ç­‰å¾…æœŸé—´ï¼Œå¦‚æœå®¢æˆ·ç«¯æ”¶åˆ°æœåŠ¡å™¨ç«¯çš„FINé‡ä¼ ï¼Œå®ƒä¼šé‡æ–°å‘é€ç¡®è®¤æŠ¥æ–‡ã€‚ å½“æœåŠ¡å™¨ç«¯æ”¶åˆ°å®¢æˆ·ç«¯çš„ç¡®è®¤æŠ¥æ–‡åï¼Œå®ƒä¼šç«‹å³å…³é—­è¿æ¥ã€‚å½“å®¢æˆ·ç«¯ç­‰å¾…æ—¶é—´ç»“æŸåï¼Œå®ƒä¹Ÿä¼šå…³é—­è¿æ¥ã€‚ æ€»ä¹‹ï¼ŒTCPå››æ¬¡æŒ¥æ‰‹è¿‡ç¨‹æ˜¯ä¸€ä¸ªæœ‰åºçš„è¿æ¥å…³é—­è¿‡ç¨‹ã€‚è¿™ä¸ªè¿‡ç¨‹å¯ä»¥ç¡®ä¿åŒæ–¹éƒ½å®Œæˆäº†æ•°æ®ä¼ è¾“ï¼Œé¿å…äº†æ•°æ®ä¸¢å¤±å’Œè¿æ¥åŠå¼€æ”¾çš„é—®é¢˜ã€‚ TCPé€šä¿¡å¹¶å‘è¦å®ç°TCPé€šä¿¡æœåŠ¡å™¨å¤„ç†å¹¶å‘çš„ä»»åŠ¡ï¼Œä½¿ç”¨å¤šçº¿ç¨‹æˆ–å¤šçº¿ç¨‹æ¥è§£å†³ æ€è·¯ï¼š ä¸€ä¸ªçˆ¶è¿›ç¨‹ï¼Œå¤šä¸ªå­è¿›ç¨‹ çˆ¶è¿›ç¨‹è´Ÿè´£ç­‰å¾…å¹¶æ¥å—å®¢æˆ·ç«¯çš„è¿æ¥ å­è¿›ç¨‹ï¼šå®Œæˆé€šä¿¡ï¼Œæ¥å—ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥ï¼Œå°±åˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹ç”¨äºé€šä¿¡ å¤šè¿›ç¨‹å®ç°æœåŠ¡ç«¯å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;wait.h&gt;#include &lt;errno.h&gt;void recyleChild(int arg) &#123; while (1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if (ret == -1) &#123; // æ‰€æœ‰çš„å­è¿›ç¨‹éƒ½å›æ”¶äº† break; &#125; else if (ret == 0) &#123; // è¿˜æœ‰å­è¿›ç¨‹æ´»ç€ break; &#125; else if (ret &gt; 0) &#123; // è¢«å›æ”¶äº† printf(&quot;å­è¿›ç¨‹ %d è¢«å›æ”¶äº†\\n&quot;, ret); &#125; &#125;&#125;int main() &#123; struct sigaction act; act.sa_flags = 0; sigemptyset(&amp;act.sa_mask); act.sa_handler = recyleChild; // æ³¨å†Œä¿¡å·æ•æ‰ sigaction(SIGCHLD, &amp;act, NULL); // åˆ›å»ºsocket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); saddr.sin_addr.s_addr = INADDR_ANY; // ç»‘å®š int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // ç›‘å¬ ret = listen(lfd, 128); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // ä¸æ–­å¾ªç¯ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥ while (1) &#123; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // æ¥å—è¿æ¥ int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); if (cfd == -1) &#123; if (errno == EINTR) &#123; continue; &#125; perror(&quot;accept&quot;); exit(-1); &#125; // æ¯ä¸€ä¸ªè¿æ¥è¿›æ¥ï¼Œåˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹è·Ÿå®¢æˆ·ç«¯é€šä¿¡ pid_t pid = fork(); if (pid == 0) &#123; // å­è¿›ç¨‹ // è·å–å®¢æˆ·ç«¯çš„ä¿¡æ¯ char cliIp[16]; inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(cliaddr.sin_port); printf(&quot;client ip is : %s, prot is %d\\n&quot;, cliIp, cliPort); // æ¥æ”¶å®¢æˆ·ç«¯å‘æ¥çš„æ•°æ® char recvBuf[1024]; while (1) &#123; int len = read(cfd, &amp;recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv client : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; write(cfd, recvBuf, strlen(recvBuf) + 1); &#125; close(cfd); exit(0); // é€€å‡ºå½“å‰å­è¿›ç¨‹ &#125; &#125; close(lfd); return 0;&#125; å®¢æˆ·ç«¯å®ç° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// TCPé€šä¿¡çš„å®¢æˆ·ç«¯#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.åˆ›å»ºå¥—æ¥å­— int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.è¿æ¥æœåŠ¡å™¨ç«¯ struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.194.129&quot;, &amp;serveraddr.sin_addr.s_addr); serveraddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 3. é€šä¿¡ char recvBuf[1024]; int i = 0; while (1) &#123; sprintf(recvBuf, &quot;data : %d\\n&quot;, i++); // ç»™æœåŠ¡å™¨ç«¯å‘é€æ•°æ® write(fd, recvBuf, strlen(recvBuf) + 1); int len = read(fd, recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv server : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; // è¡¨ç¤ºæœåŠ¡å™¨ç«¯æ–­å¼€è¿æ¥ printf(&quot;server closed...&quot;); break; &#125; sleep(1); &#125; // å…³é—­è¿æ¥ close(fd); return 0;&#125; ç¼–è¯‘è¿è¡Œ å¤šçº¿ç¨‹å®ç°åªæœ‰æœåŠ¡ç«¯çš„ä»£ç éœ€è¦ä¿®æ”¹ä¸ºå¤šçº¿ç¨‹çš„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;struct sockInfo &#123; int fd; // é€šä¿¡çš„æ–‡ä»¶æè¿°ç¬¦ struct sockaddr_in addr; pthread_t tid; // çº¿ç¨‹å·&#125;;struct sockInfo sockinfos[128];void* working(void* arg) &#123; // å­çº¿ç¨‹å’Œå®¢æˆ·ç«¯é€šä¿¡ cfd å®¢æˆ·ç«¯çš„ä¿¡æ¯ çº¿ç¨‹å· // è·å–å®¢æˆ·ç«¯çš„ä¿¡æ¯ struct sockInfo* pinfo = (struct sockInfo*)arg; char cliIp[16]; inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(pinfo-&gt;addr.sin_port); printf(&quot;client ip is : %s, prot is %d\\n&quot;, cliIp, cliPort); // æ¥æ”¶å®¢æˆ·ç«¯å‘æ¥çš„æ•°æ® char recvBuf[1024]; while (1) &#123; int len = read(pinfo-&gt;fd, &amp;recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv client : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; write(pinfo-&gt;fd, recvBuf, strlen(recvBuf) + 1); &#125; close(pinfo-&gt;fd); return NULL;&#125;int main() &#123; // åˆ›å»ºsocket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); saddr.sin_addr.s_addr = INADDR_ANY; // ç»‘å®š int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // ç›‘å¬ ret = listen(lfd, 128); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // åˆå§‹åŒ–æ•°æ® int max = sizeof(sockinfos) / sizeof(sockinfos[0]); for (int i = 0; i &lt; max; i++) &#123; bzero(&amp;sockinfos[i], sizeof(sockinfos[i])); sockinfos[i].fd = -1; sockinfos[i].tid = -1; &#125; // å¾ªç¯ç­‰å¾…å®¢æˆ·ç«¯è¿æ¥ï¼Œä¸€æ—¦ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥è¿›æ¥ï¼Œå°±åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹è¿›è¡Œé€šä¿¡ while (1) &#123; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // æ¥å—è¿æ¥ int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); struct sockInfo* pinfo; for (int i = 0; i &lt; max; i++) &#123; // ä»è¿™ä¸ªæ•°ç»„ä¸­æ‰¾åˆ°ä¸€ä¸ªå¯ä»¥ç”¨çš„sockInfoå…ƒç´  if (sockinfos[i].fd == -1) &#123; pinfo = &amp;sockinfos[i]; break; &#125; if (i == max - 1) &#123; sleep(1); i--; &#125; &#125; pinfo-&gt;fd = cfd; memcpy(&amp;pinfo-&gt;addr, &amp;cliaddr, len); // åˆ›å»ºå­çº¿ç¨‹ pthread_create(&amp;pinfo-&gt;tid, NULL, working, pinfo); pthread_detach(pinfo-&gt;tid); &#125; close(lfd); return 0;&#125; ç¼–è¯‘è¿è¡Œ TCPçŠ¶æ€è½¬æ¢ 2MSLï¼ˆMaximum Segment Lifetimeï¼‰ä¸»åŠ¨æ–­å¼€è¿æ¥çš„ä¸€æ–¹, æœ€åè¿›å‡ºå…¥ä¸€ä¸ª TIME_WAITçŠ¶æ€, è¿™ä¸ªçŠ¶æ€ä¼šæŒç»­: 2msl msl: å®˜æ–¹å»ºè®®: 2åˆ†é’Ÿ, å®é™…æ˜¯30så½“ TCP è¿æ¥ä¸»åŠ¨å…³é—­æ–¹æ¥æ”¶åˆ°è¢«åŠ¨å…³é—­æ–¹å‘é€çš„ FIN å’Œæœ€ç»ˆçš„ ACK åï¼Œè¿æ¥çš„ä¸»åŠ¨å…³é—­æ–¹å¿…é¡»å¤„äºTIME_WAIT çŠ¶æ€å¹¶æŒç»­ 2MSL æ—¶é—´ã€‚è¿™æ ·å°±èƒ½å¤Ÿè®© TCP è¿æ¥çš„ä¸»åŠ¨å…³é—­æ–¹åœ¨å®ƒå‘é€çš„ ACK ä¸¢å¤±çš„æƒ…å†µä¸‹é‡æ–°å‘é€æœ€ç»ˆçš„ ACKã€‚ä¸»åŠ¨å…³é—­æ–¹é‡æ–°å‘é€çš„æœ€ç»ˆ ACK å¹¶ä¸æ˜¯å› ä¸ºè¢«åŠ¨å…³é—­æ–¹é‡ä¼ äº† ACKï¼ˆå®ƒä»¬å¹¶ä¸æ¶ˆè€—åºåˆ—å·ï¼Œè¢«åŠ¨å…³é—­æ–¹ä¹Ÿä¸ä¼šé‡ä¼ ï¼‰ï¼Œè€Œæ˜¯å› ä¸ºè¢«åŠ¨å…³é—­æ–¹é‡ä¼ äº†å®ƒçš„ FINã€‚äº‹å®ä¸Šï¼Œè¢«åŠ¨å…³é—­æ–¹æ€»æ˜¯é‡ä¼  FIN ç›´åˆ°å®ƒæ”¶åˆ°ä¸€ä¸ªæœ€ç»ˆçš„ ACKã€‚ åŠå…³é—­ å½“ TCP é“¾æ¥ä¸­ A å‘ B å‘é€ FIN è¯·æ±‚å…³é—­ï¼Œå¦ä¸€ç«¯ B å›åº” ACK ä¹‹åï¼ˆA ç«¯è¿›å…¥ FIN_WAIT_2çŠ¶æ€ï¼‰ï¼Œå¹¶æ²¡æœ‰ç«‹å³å‘é€ FIN ç»™ Aï¼ŒA æ–¹å¤„äºåŠè¿æ¥çŠ¶æ€ï¼ˆåŠå¼€å…³ï¼‰ï¼Œæ­¤æ—¶ A å¯ä»¥æ¥æ”¶ B å‘é€çš„æ•°æ®ï¼Œä½†æ˜¯ A å·²ç»ä¸èƒ½å†å‘ B å‘é€æ•°æ®ã€‚ ä»ç¨‹åºçš„è§’åº¦ï¼Œå¯ä»¥ä½¿ç”¨APIæ¥æ§åˆ¶å®ç°åŠè¿æ¥çŠ¶æ€ï¼š 12345678#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how);//sockfd: éœ€è¦å…³é—­çš„socketçš„æè¿°ç¬¦//how: å…è®¸ä¸ºshutdownæ“ä½œé€‰æ‹©ä»¥ä¸‹å‡ ç§æ–¹å¼://SHUT_RD(0)ï¼š å…³é—­sockfdä¸Šçš„è¯»åŠŸèƒ½ï¼Œæ­¤é€‰é¡¹å°†ä¸å…è®¸sockfdè¿›è¡Œè¯»æ“ä½œã€‚//è¯¥å¥—æ¥å­—ä¸å†æ¥æ”¶æ•°æ®ï¼Œä»»ä½•å½“å‰åœ¨å¥—æ¥å­—æ¥å—ç¼“å†²åŒºçš„æ•°æ®å°†è¢«æ— å£°çš„ä¸¢å¼ƒæ‰ã€‚//SHUT_WR(1): å…³é—­sockfdçš„å†™åŠŸèƒ½ï¼Œæ­¤é€‰é¡¹å°†ä¸å…è®¸sockfdè¿›è¡Œå†™æ“ä½œã€‚è¿›ç¨‹ä¸èƒ½åœ¨å¯¹æ­¤å¥—æ¥å­—å‘å‡ºå†™æ“ä½œã€‚//SHUT_RDWR(2):å…³é—­sockfdçš„è¯»å†™åŠŸèƒ½ã€‚ç›¸å½“äºè°ƒç”¨shutdownä¸¤æ¬¡ï¼šé¦–å…ˆæ˜¯ä»¥SHUT_RD,ç„¶åä»¥SHUT_WRã€‚ ä½¿ç”¨ close ä¸­æ­¢ä¸€ä¸ªè¿æ¥ï¼Œä½†å®ƒåªæ˜¯å‡å°‘æè¿°ç¬¦çš„å¼•ç”¨è®¡æ•°ï¼Œå¹¶ä¸ç›´æ¥å…³é—­è¿æ¥ï¼Œåªæœ‰å½“æè¿°ç¬¦çš„å¼•ç”¨è®¡æ•°ä¸º 0 æ—¶æ‰å…³é—­è¿æ¥ã€‚shutdown ä¸è€ƒè™‘æè¿°ç¬¦çš„å¼•ç”¨è®¡æ•°ï¼Œç›´æ¥å…³é—­æè¿°ç¬¦ã€‚ä¹Ÿå¯é€‰æ‹©ä¸­æ­¢ä¸€ä¸ªæ–¹å‘çš„è¿æ¥ï¼Œåªä¸­æ­¢è¯»æˆ–åªä¸­æ­¢å†™ã€‚æ³¨æ„: å¦‚æœæœ‰å¤šä¸ªè¿›ç¨‹å…±äº«ä¸€ä¸ªå¥—æ¥å­—ï¼Œclose æ¯è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œè®¡æ•°å‡ 1 ï¼Œç›´åˆ°è®¡æ•°ä¸º 0 æ—¶ï¼Œä¹Ÿå°±æ˜¯æ‰€ç”¨è¿›ç¨‹éƒ½è°ƒç”¨äº† closeï¼Œå¥—æ¥å­—å°†è¢«é‡Šæ”¾ã€‚ åœ¨å¤šè¿›ç¨‹ä¸­å¦‚æœä¸€ä¸ªè¿›ç¨‹è°ƒç”¨äº† shutdown(sfd, SHUT_RDWR) åï¼Œå…¶å®ƒçš„è¿›ç¨‹å°†æ— æ³•è¿›è¡Œé€šä¿¡ã€‚ä½†å¦‚æœä¸€ä¸ªè¿›ç¨‹ close(sfd) å°†ä¸ä¼šå½±å“åˆ°å…¶å®ƒè¿›ç¨‹ã€‚ ç«¯å£å¤ç”¨æŸ¥çœ‹ç½‘ç»œç›¸å…³ä¿¡æ¯çš„å‘½ä»¤ 1netstat å‚æ•°ï¼š -a æ‰€æœ‰çš„socket -pæ˜¾ç¤ºæ­£åœ¨ä½¿ç”¨socketçš„ç¨‹åºçš„åç§° -nç›´æ¥ä½¿ç”¨IPåœ°å€ï¼Œè€Œä¸é€šè¿‡åŸŸåæœåŠ¡å™¨ æ¡ˆä¾‹ æœåŠ¡ç«¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123; // åˆ›å»ºsocket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons(9999); //ç«¯å£å¤ç”¨ //int optval = 1; //setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)); int optval = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, sizeof(optval)); // ç»‘å®š int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); return -1; &#125; // ç›‘å¬ ret = listen(lfd, 8); if (ret == -1) &#123; perror(&quot;listen&quot;); return -1; &#125; // æ¥æ”¶å®¢æˆ·ç«¯è¿æ¥ struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); if (cfd == -1) &#123; perror(&quot;accpet&quot;); return -1; &#125; // è·å–å®¢æˆ·ç«¯ä¿¡æ¯ char cliIp[16]; inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(cliaddr.sin_port); // è¾“å‡ºå®¢æˆ·ç«¯çš„ä¿¡æ¯ printf(&quot;client&#x27;s ip is %s, and port is %d\\n&quot;, cliIp, cliPort); // æ¥æ”¶å®¢æˆ·ç«¯å‘æ¥çš„æ•°æ® char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; int len = recv(cfd, recvBuf, sizeof(recvBuf), 0); if (len == -1) &#123; perror(&quot;recv&quot;); return -1; &#125; else if (len == 0) &#123; printf(&quot;å®¢æˆ·ç«¯å·²ç»æ–­å¼€è¿æ¥...\\n&quot;); break; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, recvBuf); &#125; // å°å†™è½¬å¤§å†™ for (int i = 0; i &lt; len; ++i) &#123; recvBuf[i] = toupper(recvBuf[i]); &#125; printf(&quot;after buf = %s\\n&quot;, recvBuf); // å¤§å†™å­—ç¬¦ä¸²å‘ç»™å®¢æˆ·ç«¯ ret = send(cfd, recvBuf, strlen(recvBuf) + 1, 0); if (ret == -1) &#123; perror(&quot;send&quot;); return -1; &#125; &#125; close(cfd); close(lfd); return 0;&#125; å®¢æˆ·ç«¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // åˆ›å»ºsocket int fd = socket(PF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in seraddr; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;seraddr.sin_addr.s_addr); seraddr.sin_family = AF_INET; seraddr.sin_port = htons(9999); // è¿æ¥æœåŠ¡å™¨ int ret = connect(fd, (struct sockaddr*)&amp;seraddr, sizeof(seraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); return -1; &#125; while (1) &#123; char sendBuf[1024] = &#123; 0 &#125;; fgets(sendBuf, sizeof(sendBuf), stdin); write(fd, sendBuf, strlen(sendBuf) + 1); // æ¥æ”¶ int len = read(fd, sendBuf, sizeof(sendBuf)); if (len == -1) &#123; perror(&quot;read&quot;); return -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, sendBuf); &#125; else &#123; printf(&quot;æœåŠ¡å™¨å·²ç»æ–­å¼€è¿æ¥...\\n&quot;); break; &#125; &#125; close(fd); return 0;&#125; é¦–å…ˆè¿è¡Œserverï¼Œç„¶åè¿è¡Œå‘½ä»¤ 1netstat -anp | grep 9999 ç„¶åè¿è¡Œclientï¼Œå†æ¬¡è¿è¡Œnetstatå‘½ä»¤ ä¹‹åæ–­å¼€serverï¼Œå†æ¬¡è¿è¡Œnetstatå‘½ä»¤ è¿‡ä¸€æ®µæ—¶é—´ä¹‹åå†æ¬¡è¿è¡Œnetstatå‘½ä»¤ å¦‚æœæˆ‘ä»¬ç»“æŸserverä¹‹åç«‹å³æ–­å¼€clientï¼Œå†æ¬¡è¿è¡Œnetstatå‘½ä»¤ æˆ‘ä»¬åœ¨æ–­å¼€serverä¹‹åçš„ä¸€åˆ†é’Ÿä¹‹å†…ä¸èƒ½å†æ¬¡å¯åŠ¨serverï¼Œå› ä¸ºç«¯å£å·²ç»è¢«å ç”¨äº† æ‰€ä»¥è¿™ä¸ªæ—¶å€™éœ€è¦ä½¿ç”¨ç«¯å£å¤ç”¨ ç«¯å£å¤ç”¨æœ€å¸¸ç”¨çš„ç”¨é€”æ˜¯: é˜²æ­¢æœåŠ¡å™¨é‡å¯æ—¶ä¹‹å‰ç»‘å®šçš„ç«¯å£è¿˜æœªé‡Šæ”¾ ç¨‹åºçªç„¶é€€å‡ºè€Œç³»ç»Ÿæ²¡æœ‰é‡Šæ”¾ç«¯å£ é€šè¿‡ä¸€ä¸ªç³»ç»Ÿçš„APIå®ç° 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);//è®¾ç½®å¥—æ¥å­—çš„å±æ€§ï¼ˆä¸ä»…ä»…èƒ½è®¾ç½®ç«¯å£å¤ç”¨ï¼‰//å‚æ•°ï¼š//- sockfdï¼šè¦æ“ä½œçš„æ–‡ä»¶æè¿°ç¬¦//- levelï¼šçº§åˆ« - SOLSOCKET(ç«¯å£å¤ç”¨çš„çº§åˆ«)//- optnameï¼šé€‰é¡¹çš„åç§°// - SO_REUSEADDR// - SO_REUSEPORT//- optvalï¼šç«¯å£å¤ç”¨çš„å€¼ï¼ˆæ•´å½¢ï¼‰// - 1ï¼šå¯ä»¥å¤ç”¨// - 0ï¼šä¸å¯ä»¥å¤ç”¨//- optlenï¼šoptvalå‚æ•°çš„å¤§å°//ç«¯å£å¤ç”¨ï¼Œè®¾ç½®çš„æ—¶æœºæ˜¯åœ¨æœåŠ¡å™¨ç»‘å®šç«¯å£ä¹‹å‰//setsockopt();//bind(); åœ¨å¼€å¯ç«¯å£å¤ç”¨ä¹‹åï¼Œæ–­å¼€serverï¼Œåœ¨TIME_WAITçŠ¶æ€å¯ä»¥å†æ¬¡æ‰“å¼€ä¸€ä¸ªserver","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"ç½‘ç»œç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/ç½‘ç»œç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ çº¿ç¨‹","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-çº¿ç¨‹","date":"2023-05-15T05:40:29.000Z","updated":"2023-05-19T13:00:07.188Z","comments":true,"path":"2023/05/15/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-çº¿ç¨‹/","link":"","permalink":"http://example.com/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/","excerpt":"çº¿ç¨‹æ¦‚è¿°çº¿ç¨‹ ä¸è¿›ç¨‹ï¼ˆprocessï¼‰ç±»ä¼¼ï¼Œçº¿ç¨‹ï¼ˆthreadï¼‰æ˜¯å…è®¸åº”ç”¨ç¨‹åºå¹¶å‘æ‰§è¡Œå¤šä¸ªä»»åŠ¡çš„ä¸€ç§æœºåˆ¶ã€‚ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åŒ…å«å¤šä¸ªçº¿ç¨‹ã€‚åŒä¸€ä¸ªç¨‹åºä¸­çš„æ‰€æœ‰çº¿ç¨‹å‡ä¼šç‹¬ç«‹æ‰§è¡Œç›¸åŒç¨‹åºï¼Œä¸”å…±äº«åŒä¸€ä»½å…¨å±€å†…å­˜åŒºåŸŸï¼Œå…¶ä¸­åŒ…æ‹¬åˆå§‹åŒ–æ•°æ®æ®µã€æœªåˆå§‹åŒ–æ•°æ®æ®µï¼Œä»¥åŠå †å†…å­˜æ®µã€‚ï¼ˆä¼ ç»Ÿæ„ä¹‰ä¸Šçš„ UNIX è¿›ç¨‹åªæ˜¯å¤šçº¿ç¨‹ç¨‹åºçš„ä¸€ä¸ªç‰¹ä¾‹ï¼Œè¯¥è¿›ç¨‹åªåŒ…å«ä¸€ä¸ªçº¿ç¨‹ï¼‰ è¿›ç¨‹æ˜¯ CPU åˆ†é…èµ„æºçš„æœ€å°å•ä½ï¼Œçº¿ç¨‹æ˜¯æ“ä½œç³»ç»Ÿè°ƒåº¦æ‰§è¡Œçš„æœ€å°å•ä½ã€‚ çº¿ç¨‹æ˜¯è½»é‡çº§çš„è¿›ç¨‹ï¼ˆLWPï¼šLight Weight Processï¼‰ï¼Œåœ¨ Linux ç¯å¢ƒä¸‹çº¿ç¨‹çš„æœ¬è´¨ä»æ˜¯è¿›ç¨‹ã€‚ æŸ¥çœ‹æŒ‡å®šè¿›ç¨‹çš„ LWP ï¼ˆçº¿ç¨‹ï¼‰å·ï¼šps â€“Lf pid","text":"çº¿ç¨‹æ¦‚è¿°çº¿ç¨‹ ä¸è¿›ç¨‹ï¼ˆprocessï¼‰ç±»ä¼¼ï¼Œçº¿ç¨‹ï¼ˆthreadï¼‰æ˜¯å…è®¸åº”ç”¨ç¨‹åºå¹¶å‘æ‰§è¡Œå¤šä¸ªä»»åŠ¡çš„ä¸€ç§æœºåˆ¶ã€‚ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åŒ…å«å¤šä¸ªçº¿ç¨‹ã€‚åŒä¸€ä¸ªç¨‹åºä¸­çš„æ‰€æœ‰çº¿ç¨‹å‡ä¼šç‹¬ç«‹æ‰§è¡Œç›¸åŒç¨‹åºï¼Œä¸”å…±äº«åŒä¸€ä»½å…¨å±€å†…å­˜åŒºåŸŸï¼Œå…¶ä¸­åŒ…æ‹¬åˆå§‹åŒ–æ•°æ®æ®µã€æœªåˆå§‹åŒ–æ•°æ®æ®µï¼Œä»¥åŠå †å†…å­˜æ®µã€‚ï¼ˆä¼ ç»Ÿæ„ä¹‰ä¸Šçš„ UNIX è¿›ç¨‹åªæ˜¯å¤šçº¿ç¨‹ç¨‹åºçš„ä¸€ä¸ªç‰¹ä¾‹ï¼Œè¯¥è¿›ç¨‹åªåŒ…å«ä¸€ä¸ªçº¿ç¨‹ï¼‰ è¿›ç¨‹æ˜¯ CPU åˆ†é…èµ„æºçš„æœ€å°å•ä½ï¼Œçº¿ç¨‹æ˜¯æ“ä½œç³»ç»Ÿè°ƒåº¦æ‰§è¡Œçš„æœ€å°å•ä½ã€‚ çº¿ç¨‹æ˜¯è½»é‡çº§çš„è¿›ç¨‹ï¼ˆLWPï¼šLight Weight Processï¼‰ï¼Œåœ¨ Linux ç¯å¢ƒä¸‹çº¿ç¨‹çš„æœ¬è´¨ä»æ˜¯è¿›ç¨‹ã€‚ æŸ¥çœ‹æŒ‡å®šè¿›ç¨‹çš„ LWP ï¼ˆçº¿ç¨‹ï¼‰å·ï¼šps â€“Lf pid è¿›ç¨‹å’Œçº¿ç¨‹åŒºåˆ« è¿›ç¨‹é—´çš„ä¿¡æ¯éš¾ä»¥å…±äº«ã€‚ç”±äºé™¤å»åªè¯»ä»£ç æ®µå¤–ï¼Œçˆ¶å­è¿›ç¨‹å¹¶æœªå…±äº«å†…å­˜ï¼Œå› æ­¤å¿…é¡»é‡‡ç”¨ä¸€äº›è¿›ç¨‹é—´é€šä¿¡æ–¹å¼ï¼Œåœ¨è¿›ç¨‹é—´è¿›è¡Œä¿¡æ¯äº¤æ¢ã€‚ è°ƒç”¨ fork() æ¥åˆ›å»ºè¿›ç¨‹çš„ä»£ä»·ç›¸å¯¹è¾ƒé«˜ï¼Œå³ä¾¿åˆ©ç”¨å†™æ—¶å¤åˆ¶æŠ€æœ¯ï¼Œä»ç„¶éœ€è¦å¤åˆ¶è¯¸å¦‚å†…å­˜é¡µè¡¨å’Œæ–‡ä»¶æè¿°ç¬¦è¡¨ä¹‹ç±»çš„å¤šç§è¿›ç¨‹å±æ€§ï¼Œè¿™æ„å‘³ç€ fork() è°ƒç”¨åœ¨æ—¶é—´ä¸Šçš„å¼€é”€ä¾ç„¶ä¸è²ã€‚ çº¿ç¨‹ä¹‹é—´èƒ½å¤Ÿæ–¹ä¾¿ã€å¿«é€Ÿåœ°å…±äº«ä¿¡æ¯ã€‚åªéœ€å°†æ•°æ®å¤åˆ¶åˆ°å…±äº«ï¼ˆå…¨å±€æˆ–å †ï¼‰å˜é‡ä¸­å³å¯ã€‚ åˆ›å»ºçº¿ç¨‹æ¯”åˆ›å»ºè¿›ç¨‹é€šå¸¸è¦å¿« 10 å€ç”šè‡³æ›´å¤šã€‚çº¿ç¨‹é—´æ˜¯å…±äº«è™šæ‹Ÿåœ°å€ç©ºé—´çš„ï¼Œæ— éœ€é‡‡ç”¨å†™æ—¶å¤åˆ¶æ¥å¤åˆ¶å†…å­˜ï¼Œä¹Ÿæ— éœ€å¤åˆ¶é¡µè¡¨ çº¿ç¨‹ä¹‹é—´å…±äº«å’Œéå…±äº«èµ„æº å…±äº«èµ„æº è¿›ç¨‹ ID å’Œçˆ¶è¿›ç¨‹ ID è¿›ç¨‹ç»„ ID å’Œä¼šè¯ ID ç”¨æˆ· ID å’Œ ç”¨æˆ·ç»„ ID æ–‡ä»¶æè¿°ç¬¦è¡¨ ä¿¡å·å¤„ç½® æ–‡ä»¶ç³»ç»Ÿçš„ç›¸å…³ä¿¡æ¯ï¼šæ–‡ä»¶æƒé™æ©ç ï¼ˆumaskï¼‰ã€å½“å‰å·¥ä½œç›®å½• è™šæ‹Ÿåœ°å€ç©ºé—´ï¼ˆé™¤æ ˆã€.textï¼‰ éå…±äº«èµ„æº çº¿ç¨‹ ID ä¿¡å·æ©ç  çº¿ç¨‹ç‰¹æœ‰æ•°æ® error å˜é‡ å®æ—¶è°ƒåº¦ç­–ç•¥å’Œä¼˜å…ˆçº§ æ ˆï¼Œæœ¬åœ°å˜é‡å’Œå‡½æ•°çš„è°ƒç”¨é“¾æ¥ä¿¡æ¯ NPTL å½“ Linux æœ€åˆå¼€å‘æ—¶ï¼Œåœ¨å†…æ ¸ä¸­å¹¶ä¸èƒ½çœŸæ­£æ”¯æŒçº¿ç¨‹ã€‚ä½†æ˜¯å®ƒçš„ç¡®å¯ä»¥é€šè¿‡ clone() ç³»ç»Ÿè°ƒç”¨å°†è¿›ç¨‹ä½œä¸ºå¯è°ƒåº¦çš„å®ä½“ã€‚è¿™ä¸ªè°ƒç”¨åˆ›å»ºäº†è°ƒç”¨è¿›ç¨‹ï¼ˆcalling processï¼‰çš„ä¸€ä¸ªæ‹·è´ï¼Œè¿™ä¸ªæ‹·è´ä¸è°ƒç”¨è¿›ç¨‹å…±äº«ç›¸åŒçš„åœ°å€ç©ºé—´ã€‚LinuxThreads é¡¹ç›®ä½¿ç”¨è¿™ä¸ªè°ƒç”¨æ¥å®Œæˆåœ¨ç”¨æˆ·ç©ºé—´æ¨¡æ‹Ÿå¯¹çº¿ç¨‹çš„æ”¯æŒã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™ç§æ–¹æ³•æœ‰ä¸€äº›ç¼ºç‚¹ï¼Œå°¤å…¶æ˜¯åœ¨ä¿¡å·å¤„ç†ã€è°ƒåº¦å’Œè¿›ç¨‹é—´åŒæ­¥ç­‰æ–¹é¢éƒ½å­˜åœ¨é—®é¢˜ã€‚å¦å¤–ï¼Œè¿™ä¸ªçº¿ç¨‹æ¨¡å‹ä¹Ÿä¸ç¬¦åˆ POSIX çš„è¦æ±‚ã€‚ è¦æ”¹è¿› LinuxThreadsï¼Œéœ€è¦å†…æ ¸çš„æ”¯æŒï¼Œå¹¶ä¸”é‡å†™çº¿ç¨‹åº“ã€‚æœ‰ä¸¤ä¸ªç›¸äº’ç«äº‰çš„é¡¹ç›®å¼€å§‹æ¥æ»¡è¶³è¿™äº›è¦æ±‚ã€‚ä¸€ä¸ªåŒ…æ‹¬ IBM çš„å¼€å‘äººå‘˜çš„å›¢é˜Ÿå¼€å±•äº† NGPTï¼ˆNext-Generation POSIX Threadsï¼‰é¡¹ç›®ã€‚åŒæ—¶ï¼ŒRed Hat çš„ä¸€äº›å¼€å‘äººå‘˜å¼€å±•äº† NPTL é¡¹ç›®ã€‚NGPT åœ¨ 2003 å¹´ä¸­æœŸè¢«æ”¾å¼ƒäº†ï¼ŒæŠŠè¿™ä¸ªé¢†åŸŸå®Œå…¨ç•™ç»™äº† NPTLã€‚ NPTLï¼Œæˆ–ç§°ä¸º Native POSIX Thread Libraryï¼Œæ˜¯ Linux çº¿ç¨‹çš„ä¸€ä¸ªæ–°å®ç°ï¼Œå®ƒå…‹æœäº† LinuxThreads çš„ç¼ºç‚¹ï¼ŒåŒæ—¶ä¹Ÿç¬¦åˆ POSIX çš„éœ€æ±‚ã€‚ä¸ LinuxThreads ç›¸æ¯”ï¼Œå®ƒåœ¨æ€§èƒ½å’Œç¨³å®šæ€§æ–¹é¢éƒ½æä¾›äº†é‡å¤§çš„æ”¹è¿›ã€‚ æŸ¥çœ‹å½“å‰ pthread åº“ç‰ˆæœ¬ï¼šgetconf GNU_LIBPTHREAD_VERSION çº¿ç¨‹æ“ä½œè¿›ç¨‹åˆ›å»º12345678910111213141516171819// ä¸€èˆ¬æƒ…å†µä¸‹, mainå‡½æ•°æ‰€åœ¨çš„çº¿ç¨‹æˆ‘ä»¬ç§°ä¹‹ä¸ºä¸»çº¿ç¨‹ï¼ˆmainçº¿ç¨‹ï¼‰ï¼Œå…¶ä½™åˆ›å»ºçš„çº¿ç¨‹// ç§°ä¹‹ä¸ºå­çº¿ç¨‹ã€‚// ç¨‹åºä¸­é»˜è®¤åªæœ‰ä¸€ä¸ªè¿›ç¨‹ï¼Œfork()å‡½æ•°è°ƒç”¨ï¼Œ2è¿›è¡Œ// ç¨‹åºä¸­é»˜è®¤åªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼Œpthread_create()å‡½æ•°è°ƒç”¨ï¼Œ2ä¸ªçº¿ç¨‹ã€‚#include &lt;pthread.h&gt;int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine) (void*), void* arg);// -åŠŸèƒ½ï¼šåˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹// - å‚æ•°ï¼š// - threadï¼šä¼ å‡ºå‚æ•°ï¼Œçº¿ç¨‹åˆ›å»ºæˆåŠŸåï¼Œå­çº¿ç¨‹çš„çº¿ç¨‹IDè¢«å†™åˆ°è¯¥å˜é‡ä¸­ã€‚// - attr : è®¾ç½®çº¿ç¨‹çš„å±æ€§ï¼Œä¸€èˆ¬ä½¿ç”¨é»˜è®¤å€¼ï¼ŒNULL// - start_routine : å‡½æ•°æŒ‡é’ˆï¼Œè¿™ä¸ªå‡½æ•°æ˜¯å­çº¿ç¨‹éœ€è¦å¤„ç†çš„é€»è¾‘ä»£ç // - arg : ç»™ç¬¬ä¸‰ä¸ªå‚æ•°ä½¿ç”¨ï¼Œä¼ å‚// - è¿”å›å€¼ï¼š// æˆåŠŸï¼š0// å¤±è´¥ï¼šè¿”å›é”™è¯¯å·ã€‚è¿™ä¸ªé”™è¯¯å·å’Œä¹‹å‰errnoä¸å¤ªä¸€æ ·ã€‚// è·å–é”™è¯¯å·çš„ä¿¡æ¯ï¼š char* strerror(int errnum); pthread_createä¸æ˜¯æ ‡å‡†åº“å®šä¹‰çš„è°ƒç”¨ï¼Œæ‰€ä»¥åœ¨ç¼–è¯‘æ—¶éœ€è¦è¿æ¥ç¬¬ä¸‰æ–¹çš„åº“ -pthread æ¡ˆä¾‹ 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread . . .\\n&quot;); printf(&quot;arg value = %d\\n&quot;, *(int*)arg);&#125;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹ pthread_t tid; int num = 10; int ret = pthread_create(&amp;tid, NULL, callback, (void*)&amp;num); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; sleep(1);&#125; ç¼–è¯‘è¿è¡Œç»“æœä¸ºï¼š ç»ˆæ­¢çº¿ç¨‹1234567891011121314#include &lt;pthread.h&gt;void pthread_exit(void* retval);// åŠŸèƒ½ï¼šç»ˆæ­¢ä¸€ä¸ªçº¿ç¨‹ï¼Œåœ¨å“ªä¸ªçº¿ç¨‹ä¸­è°ƒç”¨ï¼Œå°±è¡¨ç¤ºç»ˆæ­¢å“ªä¸ªçº¿ç¨‹// å‚æ•°ï¼š// retval : éœ€è¦ä¼ é€’ä¸€ä¸ªæŒ‡é’ˆï¼Œä½œä¸ºä¸€ä¸ªè¿”å›å€¼ï¼Œå¯ä»¥åœ¨pthread_join()ä¸­è·å–åˆ°ã€‚pthread_t pthread_self(void);// åŠŸèƒ½ï¼šè·å–å½“å‰çš„çº¿ç¨‹çš„çº¿ç¨‹IDint pthread_equal(pthread_t t1, pthread_t t2);// åŠŸèƒ½ï¼šæ¯”è¾ƒä¸¤ä¸ªçº¿ç¨‹IDæ˜¯å¦ç›¸ç­‰// ä¸åŒçš„æ“ä½œç³»ç»Ÿï¼Œpthread_tç±»å‹çš„å®ç°ä¸ä¸€æ ·ï¼Œæœ‰çš„æ˜¯æ— ç¬¦å·çš„é•¿æ•´å‹ï¼Œæœ‰çš„// æ˜¯ä½¿ç”¨ç»“æ„ä½“å»å®ç°çš„ã€‚//ä¸€èˆ¬è·¨å¹³å°ç­‰ç­‰å¿…é¡»è¦ä½¿ç”¨ æ¡ˆä¾‹ 12345678910111213141516171819202122232425262728293031#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹ pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; //ä¸»çº¿ç¨‹ for (int i = 0;i &lt; 50;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //è®©ä¸»çº¿ç¨‹é€€å‡º,å½“ä¸»çº¿ç¨‹é€€å‡ºæ—¶ï¼Œä¸ä¼šå½±å“å…¶ä»– pthread_exit(NULL);&#125; è¿æ¥å·²ç»ˆæ­¢çš„è¿›ç¨‹123456789101112#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval); // - åŠŸèƒ½ï¼šå’Œä¸€ä¸ªå·²ç»ç»ˆæ­¢çš„çº¿ç¨‹è¿›è¡Œè¿æ¥ // å›æ”¶å­çº¿ç¨‹çš„èµ„æº // è¿™ä¸ªå‡½æ•°æ˜¯é˜»å¡å‡½æ•°ï¼Œè°ƒç”¨ä¸€æ¬¡åªèƒ½å›æ”¶ä¸€ä¸ªå­çº¿ç¨‹ // ä¸€èˆ¬åœ¨ä¸»çº¿ç¨‹ä¸­ä½¿ç”¨ // - å‚æ•°ï¼š // - threadï¼šéœ€è¦å›æ”¶çš„å­çº¿ç¨‹çš„ID // - retval: æ¥æ”¶å­çº¿ç¨‹é€€å‡ºæ—¶çš„è¿”å›å€¼ // - è¿”å›å€¼ï¼š // 0 : æˆåŠŸ // é0 : å¤±è´¥ï¼Œè¿”å›çš„é”™è¯¯å· æ¡ˆä¾‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int value = 10;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); sleep(3); pthread_exit((void*)&amp;value);//return (void *)&amp;value;&#125;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹ pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; //ä¸»çº¿ç¨‹ for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //ä¸»çº¿ç¨‹è°ƒç”¨pthread_join()å›æ”¶å­çº¿ç¨‹çš„èµ„æº int* thread_retval; ret = pthread_join(tid, (void**)&amp;thread_retval); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; printf(&quot;exit data : %d\\n&quot;, *thread_retval); printf(&quot;å›æ”¶å­çº¿ç¨‹èµ„æºæˆåŠŸ\\n&quot;); //è®©ä¸»çº¿ç¨‹é€€å‡º,å½“ä¸»çº¿ç¨‹é€€å‡ºæ—¶ï¼Œä¸ä¼šå½±å“å…¶ä»– pthread_exit(NULL);&#125; ç¼–è¯‘è¿è¡Œ çº¿ç¨‹çš„åˆ†ç¦»123456789#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread); // - åŠŸèƒ½ï¼šåˆ†ç¦»ä¸€ä¸ªçº¿ç¨‹ã€‚è¢«åˆ†ç¦»çš„çº¿ç¨‹åœ¨ç»ˆæ­¢çš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾èµ„æºè¿”å›ç»™ç³»ç»Ÿã€‚ // 1.ä¸èƒ½å¤šæ¬¡åˆ†ç¦»ï¼Œä¼šäº§ç”Ÿä¸å¯é¢„æ–™çš„è¡Œä¸ºã€‚ // 2.ä¸èƒ½å»è¿æ¥ä¸€ä¸ªå·²ç»åˆ†ç¦»çš„çº¿ç¨‹ï¼Œä¼šæŠ¥é”™ã€‚ // - å‚æ•°ï¼šéœ€è¦åˆ†ç¦»çš„çº¿ç¨‹çš„ID // - è¿”å›å€¼ï¼š // æˆåŠŸï¼š0 // å¤±è´¥ï¼šè¿”å›é”™è¯¯å· æ¡ˆä¾‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹ pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //è¾“å‡ºä¸»çº¿ç¨‹å’Œå­çº¿ç¨‹çš„ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //è®¾ç½®å­çº¿ç¨‹åˆ†ç¦»,å­çº¿ç¨‹åˆ†ç¦»åï¼Œå­çº¿ç¨‹ç»“æŸæ—¶å¯¹åº”çš„èµ„æºå°±ä¸éœ€è¦ä¸»çº¿ç¨‹é‡Šæ”¾ ret = pthread_detach(tid); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error2 : %s\\n&quot;, errstr); &#125; //è®¾ç½®åˆ†ç¦»ä»¥åï¼Œå¯¹åˆ†ç¦»çš„å­çº¿ç¨‹è¿›è¡Œè¿æ¥ pthread_join() ret = pthread_join(tid, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error3 : %s\\n&quot;, errstr); &#125; pthread_exit(NULL);&#125; ç¼–è¯‘è¿è¡Œ çº¿ç¨‹å–æ¶ˆ123456#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread); // - åŠŸèƒ½ï¼šå–æ¶ˆçº¿ç¨‹ï¼ˆè®©çº¿ç¨‹ç»ˆæ­¢ï¼‰ // å–æ¶ˆæŸä¸ªçº¿ç¨‹ï¼Œå¯ä»¥ç»ˆæ­¢æŸä¸ªçº¿ç¨‹çš„è¿è¡Œï¼Œ // ä½†æ˜¯å¹¶ä¸æ˜¯ç«‹é©¬ç»ˆæ­¢ï¼Œè€Œæ˜¯å½“å­çº¿ç¨‹æ‰§è¡Œåˆ°ä¸€ä¸ªå–æ¶ˆç‚¹ï¼Œçº¿ç¨‹æ‰ä¼šç»ˆæ­¢ã€‚ // å–æ¶ˆç‚¹ï¼šç³»ç»Ÿè§„å®šå¥½çš„ä¸€äº›ç³»ç»Ÿè°ƒç”¨ï¼Œæˆ‘ä»¬å¯ä»¥ç²—ç•¥çš„ç†è§£ä¸ºä»ç”¨æˆ·åŒºåˆ°å†…æ ¸åŒºçš„åˆ‡æ¢ï¼Œè¿™ä¸ªä½ç½®ç§°ä¹‹ä¸ºå–æ¶ˆç‚¹ã€‚ æ¡ˆä¾‹ 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;child : %d\\n&quot;, i); &#125; return NULL;&#125;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹ pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //å–æ¶ˆçº¿ç¨‹ pthread_cancel(tid); for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; //è¾“å‡ºä¸»çº¿ç¨‹å’Œå­çº¿ç¨‹çš„ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); pthread_exit(NULL);&#125; ç¼–è¯‘è¿è¡Œ çº¿ç¨‹å±æ€§1234567891011int pthread_attr_init(pthread_attr_t *attr); //- åˆå§‹åŒ–çº¿ç¨‹å±æ€§å˜é‡int pthread_attr_destroy(pthread_attr_t *attr); //- é‡Šæ”¾çº¿ç¨‹å±æ€§çš„èµ„æºint pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); //- è·å–çº¿ç¨‹åˆ†ç¦»çš„çŠ¶æ€å±æ€§int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); //- è®¾ç½®çº¿ç¨‹åˆ†ç¦»çš„çŠ¶æ€å±æ€§ æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //åˆ›å»ºä¸€ä¸ªçº¿ç¨‹å±æ€§å˜é‡ pthread_attr_t attr; //åˆå§‹åŒ–å±æ€§å˜é‡ pthread_attr_init(&amp;attr); //è®¾ç½®å±æ€§ pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); //åˆ›å»ºä¸€ä¸ªå­çº¿ç¨‹ pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //è¾“å‡ºä¸»çº¿ç¨‹å’Œå­çº¿ç¨‹çš„ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //è·å–çº¿ç¨‹çš„æ ˆçš„å¤§å° size_t size; pthread_attr_getstacksize(&amp;attr, &amp;size); printf(&quot;thread stack size : %ld\\n&quot;, size); //é‡Šæ”¾çº¿ç¨‹å±æ€§èµ„æº pthread_attr_destroy(&amp;attr); pthread_exit(NULL);&#125; ç¼–è¯‘è¿è¡Œ çº¿ç¨‹åŒæ­¥ çº¿ç¨‹çš„ä¸»è¦ä¼˜åŠ¿åœ¨äºï¼Œèƒ½å¤Ÿé€šè¿‡å…¨å±€å˜é‡æ¥å…±äº«ä¿¡æ¯ã€‚ä¸è¿‡ï¼Œè¿™ç§ä¾¿æ·çš„å…±äº«æ˜¯æœ‰ä»£ä»·çš„ï¼šå¿…é¡»ç¡®ä¿å¤šä¸ªçº¿ç¨‹ä¸ä¼šåŒæ—¶ä¿®æ”¹åŒä¸€å˜é‡ï¼Œæˆ–è€…æŸä¸€çº¿ç¨‹ä¸ä¼šè¯»å–æ­£åœ¨ç”±å…¶ä»–çº¿ç¨‹ä¿®æ”¹çš„å˜é‡ã€‚ ä¸´ç•ŒåŒºæ˜¯æŒ‡è®¿é—®æŸä¸€å…±äº«èµ„æºçš„ä»£ç ç‰‡æ®µï¼Œå¹¶ä¸”è¿™æ®µä»£ç çš„æ‰§è¡Œåº”ä¸ºåŸå­æ“ä½œï¼Œä¹Ÿå°±æ˜¯åŒæ—¶è®¿é—®åŒä¸€å…±äº«èµ„æºçš„å…¶ä»–çº¿ç¨‹ä¸åº”ç»ˆç«¯è¯¥ç‰‡æ®µçš„æ‰§è¡Œã€‚ çº¿ç¨‹åŒæ­¥ï¼šå³å½“æœ‰ä¸€ä¸ªçº¿ç¨‹åœ¨å¯¹å†…å­˜è¿›è¡Œæ“ä½œæ—¶ï¼Œå…¶ä»–çº¿ç¨‹éƒ½ä¸å¯ä»¥å¯¹è¿™ä¸ªå†…å­˜åœ°å€è¿›è¡Œæ“ä½œï¼Œç›´åˆ°è¯¥çº¿ç¨‹å®Œæˆæ“ä½œï¼Œå…¶ä»–çº¿ç¨‹æ‰èƒ½å¯¹è¯¥å†…å­˜åœ°å€è¿›è¡Œæ“ä½œï¼Œè€Œå…¶ä»–çº¿ç¨‹åˆ™å¤„äºç­‰å¾…çŠ¶æ€ã€‚ äº’æ–¥é‡ ä¸ºé¿å…çº¿ç¨‹æ›´æ–°å…±äº«å˜é‡æ—¶å‡ºç°é—®é¢˜ï¼Œå¯ä»¥ä½¿ç”¨äº’æ–¥é‡ï¼ˆmutex æ˜¯ mutual exclusionçš„ç¼©å†™ï¼‰æ¥ç¡®ä¿åŒæ—¶ä»…æœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è®¿é—®æŸé¡¹å…±äº«èµ„æºã€‚å¯ä»¥ä½¿ç”¨äº’æ–¥é‡æ¥ä¿è¯å¯¹ä»»æ„å…±äº«èµ„æºçš„åŸå­è®¿é—®ã€‚ äº’æ–¥é‡æœ‰ä¸¤ç§çŠ¶æ€ï¼šå·²é”å®šï¼ˆlockedï¼‰å’Œæœªé”å®šï¼ˆunlockedï¼‰ã€‚ä»»ä½•æ—¶å€™ï¼Œè‡³å¤šåªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥é”å®šè¯¥äº’æ–¥é‡ã€‚è¯•å›¾å¯¹å·²ç»é”å®šçš„æŸä¸€äº’æ–¥é‡å†æ¬¡åŠ é”ï¼Œå°†å¯èƒ½é˜»å¡çº¿ç¨‹æˆ–è€…æŠ¥é”™å¤±è´¥ï¼Œå…·ä½“å–å†³äºåŠ é”æ—¶ä½¿ç”¨çš„æ–¹æ³•ã€‚ ä¸€æ—¦çº¿ç¨‹é”å®šäº’æ–¥é‡ï¼Œéšå³æˆä¸ºè¯¥äº’æ–¥é‡çš„æ‰€æœ‰è€…ï¼Œåªæœ‰æ‰€æœ‰è€…æ‰èƒ½ç»™äº’æ–¥é‡è§£é”ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯¹æ¯ä¸€å…±äº«èµ„æºï¼ˆå¯èƒ½ç”±å¤šä¸ªç›¸å…³å˜é‡ç»„æˆï¼‰ä¼šä½¿ç”¨ä¸åŒçš„äº’æ–¥é‡ï¼Œæ¯ä¸€çº¿ç¨‹åœ¨è®¿é—®åŒä¸€èµ„æºæ—¶å°†é‡‡ç”¨å¦‚ä¸‹åè®®ï¼š é’ˆå¯¹å…±äº«èµ„æºé”å®šäº’æ–¥é‡ è®¿é—®å…±äº«èµ„æº å¯¹äº’æ–¥é‡è§£é” å¦‚æœå¤šä¸ªçº¿ç¨‹è¯•å›¾æ‰§è¡Œè¿™ä¸€å—ä»£ç ï¼ˆä¸€ä¸ªä¸´ç•ŒåŒºï¼‰ï¼Œäº‹å®ä¸Šåªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤ŸæŒæœ‰è¯¥äº’æ–¥é‡ï¼ˆå…¶ä»–çº¿ç¨‹å°†é­åˆ°é˜»å¡ï¼‰ï¼Œå³åŒæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿè¿›å…¥è¿™æ®µä»£ç åŒºåŸŸï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//ä½¿ç”¨å¤šçº¿ç¨‹å®ç°å–ç¥¨æ¡ˆä¾‹//æœ‰3ä¸ªçª—å£ï¼Œä¸€å…±æ˜¯100å¼ ç¥¨#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;int tickets = 100;//å…¨å±€å˜é‡ï¼Œæ‰€æœ‰çº¿ç¨‹éƒ½å…±äº«è¿™ä¸€ä»½èµ„æº//åˆ›å»ºä¸€ä¸ªäº’æ–¥é‡pthread_mutex_t mutex;void* sellticket(void* arg)&#123; //å–ç¥¨ while (1) &#123; //åŠ é” pthread_mutex_lock(&amp;mutex); if (tickets &gt; 0) &#123; printf(&quot;%ld æ­£åœ¨å–ç¬¬ %d å¼ é—¨ç¥¨\\n&quot;, pthread_self(), tickets); tickets--; &#125; else &#123; //è§£é” pthread_mutex_unlock(&amp;mutex); break; &#125; //è§£é” pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125;int main()&#123; //åˆå§‹åŒ–äº’æ–¥é‡ pthread_mutex_init(&amp;mutex, NULL); //åˆ›å»ºä¸‰ä¸ªå­çº¿ç¨‹ pthread_t tid1, tid2, tid3; pthread_create(&amp;tid1, NULL, sellticket, NULL); pthread_create(&amp;tid2, NULL, sellticket, NULL); pthread_create(&amp;tid3, NULL, sellticket, NULL); //å›æ”¶å­çº¿ç¨‹çš„èµ„æº,é˜»å¡çš„å‡½æ•° pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); //è®¾ç½®çº¿ç¨‹åˆ†ç¦» pthread_detach(tid1); pthread_detach(tid2); pthread_detach(tid3); pthread_exit(NULL);//é€€å‡ºä¸»çº¿ç¨‹ //é‡Šæ”¾äº’æ–¥é‡èµ„æº pthread_mutex_destroy(&amp;mutex);&#125; æ­»é” æœ‰æ—¶ï¼Œä¸€ä¸ªçº¿ç¨‹éœ€è¦åŒæ—¶è®¿é—®ä¸¤ä¸ªæˆ–æ›´å¤šä¸åŒçš„å…±äº«èµ„æºï¼Œè€Œæ¯ä¸ªèµ„æºåˆéƒ½ç”±ä¸åŒçš„äº’æ–¥é‡ç®¡ç†ã€‚å½“è¶…è¿‡ä¸€ä¸ªçº¿ç¨‹åŠ é”åŒä¸€ç»„äº’æ–¥é‡æ—¶ï¼Œå°±æœ‰å¯èƒ½å‘ç”Ÿæ­»é”ã€‚ ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„è¿›ç¨‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå› äº‰å¤ºå…±äº«èµ„æºè€Œé€ æˆçš„ä¸€ç§äº’ç›¸ç­‰å¾…çš„ç°è±¡ï¼Œè‹¥æ— å¤–åŠ›ä½œç”¨ï¼Œå®ƒä»¬éƒ½å°†æ— æ³•æ¨è¿›ä¸‹å»ã€‚æ­¤æ—¶ç§°ç³»ç»Ÿå¤„äºæ­»é”çŠ¶æ€æˆ–ç³»ç»Ÿäº§ç”Ÿäº†æ­»é”ã€‚ æ­»é”çš„å‡ ç§åœºæ™¯ï¼š å¿˜è®°é‡Šæ”¾é” é‡å¤åŠ é” å¤šçº¿ç¨‹å¤šé”ï¼ŒæŠ¢å é”èµ„æº è¯»å†™é” å½“æœ‰ä¸€ä¸ªçº¿ç¨‹å·²ç»æŒæœ‰äº’æ–¥é”æ—¶ï¼Œäº’æ–¥é”å°†æ‰€æœ‰è¯•å›¾è¿›å…¥ä¸´ç•ŒåŒºçš„çº¿ç¨‹éƒ½é˜»å¡ä½ã€‚ä½†æ˜¯è€ƒè™‘ä¸€ç§æƒ…å½¢ï¼Œå½“å‰æŒæœ‰äº’æ–¥é”çš„çº¿ç¨‹åªæ˜¯è¦è¯»è®¿é—®å…±äº«èµ„æºï¼Œè€ŒåŒæ—¶æœ‰å…¶å®ƒå‡ ä¸ªçº¿ç¨‹ä¹Ÿæƒ³è¯»å–è¿™ä¸ªå…±äº«èµ„æºï¼Œä½†æ˜¯ç”±äºäº’æ–¥é”çš„æ’å®ƒæ€§ï¼Œæ‰€æœ‰å…¶å®ƒçº¿ç¨‹éƒ½æ— æ³•è·å–é”ï¼Œä¹Ÿå°±æ— æ³•è¯»è®¿é—®å…±äº«èµ„æºäº†ï¼Œä½†æ˜¯å®é™…ä¸Šå¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»è®¿é—®å…±äº«èµ„æºå¹¶ä¸ä¼šå¯¼è‡´é—®é¢˜ã€‚ åœ¨å¯¹æ•°æ®çš„è¯»å†™æ“ä½œä¸­ï¼Œæ›´å¤šçš„æ˜¯è¯»æ“ä½œï¼Œå†™æ“ä½œè¾ƒå°‘ï¼Œä¾‹å¦‚å¯¹æ•°æ®åº“æ•°æ®çš„è¯»å†™åº”ç”¨ã€‚ä¸ºäº†æ»¡è¶³å½“å‰èƒ½å¤Ÿå…è®¸å¤šä¸ªè¯»å‡ºï¼Œä½†åªå…è®¸ä¸€ä¸ªå†™å…¥çš„éœ€æ±‚ï¼Œçº¿ç¨‹æä¾›äº†è¯»å†™é”æ¥å®ç°ã€‚ è¯»å†™é”çš„ç‰¹ç‚¹ï¼š å¦‚æœæœ‰å…¶å®ƒçº¿ç¨‹è¯»æ•°æ®ï¼Œåˆ™å…è®¸å…¶å®ƒçº¿ç¨‹æ‰§è¡Œè¯»æ“ä½œï¼Œä½†ä¸å…è®¸å†™æ“ä½œã€‚ å¦‚æœæœ‰å…¶å®ƒçº¿ç¨‹å†™æ•°æ®ï¼Œåˆ™å…¶å®ƒçº¿ç¨‹éƒ½ä¸å…è®¸è¯»ã€å†™æ“ä½œã€‚ å†™æ˜¯ç‹¬å çš„ï¼Œå†™çš„ä¼˜å…ˆçº§é«˜ 12345678// è¯»å†™é”çš„ç±»å‹ pthread_rwlock_tint pthread_rwlock_init(pthread_rwlock_t *rstrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); æ¡ˆä¾‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//æ¡ˆä¾‹ï¼š8ä¸ªçº¿ç¨‹æ“ä½œåŒä¸€ä¸ªå…¨å±€å˜é‡//3ä¸ªçº¿ç¨‹ä¸å®šæ—¶å†™è¿™ä¸ªå…¨å±€å˜é‡ï¼Œ5ä¸ªçº¿ç¨‹ä¸å®šæ—¶çš„è¯»è¿™ä¸ªå…¨å±€å˜é‡#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;//åˆ›å»ºä¸€ä¸ªå…±äº«æ•°æ®int num = 1;pthread_mutex_t mutex;pthread_rwlock_t rwlock;void* writeNum(void* arg)&#123; while (1) &#123; pthread_rwlock_wrlock(&amp;rwlock); num++; printf(&quot;++write, tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); usleep(100); &#125; return NULL;&#125;void* readNum(void* arg)&#123; while (1) &#123; pthread_rwlock_rdlock(&amp;rwlock); printf(&quot;===read,tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); usleep(100); &#125; return NULL;&#125;int main()&#123; pthread_rwlock_init(&amp;rwlock, NULL); pthread_t wtids[3], rtids[5];//åˆ›å»º3ä¸ªå†™çº¿ç¨‹ï¼Œ5ä¸ªè¯»çº¿ç¨‹ for (int i = 0;i &lt; 3;i++) &#123; pthread_create(&amp;wtids[i], NULL, writeNum, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;rtids[i], NULL, readNum, NULL); &#125; //è®¾ç½®çº¿ç¨‹åˆ†ç¦» for (int i = 0;i &lt; 3;i++) &#123; pthread_detach(wtids[i]); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(rtids[i]); &#125; pthread_exit(NULL); pthread_rwlock_destroy(&amp;rwlock);&#125; ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹(ç®€å•ç‰ˆ)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;pthread_mutex_t mutex;struct Node&#123; int num; struct Node* next; &#125;//å¤´ç»“ç‚¹struct Node* head = NULL;void* producer(void* arg)&#123; //ä¸æ–­çš„åˆ›å»ºæ–°çš„èŠ‚ç‚¹ï¼Œæ·»åŠ åˆ°é“¾è¡¨ä¸­ while (1) &#123; pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); //ä¿å­˜å¤´èŠ‚ç‚¹çš„æŒ‡é’ˆ struct Node* tmp = head; //åˆ¤æ–­æ˜¯å¦æœ‰æ•°æ® if (head != NULL) &#123; // æœ‰æ•°æ® head = head-&gt;next; printf(&quot;delete node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; //æ²¡æœ‰æ•°æ® pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex); //åˆ›å»º5ä¸ªç”Ÿäº§è€…çº¿ç¨‹å’Œ5ä¸ªæ¶ˆè´¹è€…çº¿ç¨‹ pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, custmer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL);&#125; è¿™æ®µä»£ç æ²¡æœ‰å¤„ç†å¥½ä¸€ä¸ªé—®é¢˜ï¼Œå½“æœ‰æ¶ˆè´¹è€…æƒ³è¦æ¶ˆè´¹ä½†æ˜¯ç¼“å†²åŒºå·²ç»æ²¡æœ‰æ•°æ®çš„æ—¶å€™ï¼Œæ¶ˆè´¹è€…ä¼šç›´æ¥é€€å‡ºï¼Œå½“ç¼“å†²åŒºæœ‰æ•°æ®çš„æ—¶å€™å´ä¸ä¼šå†é€šçŸ¥è¿™ä¸ªæ¶ˆè´¹è€…ï¼Œæˆ‘ä»¬éœ€è¦é€šè¿‡ä¸€å®šæ‰‹æ®µè§£å†³è¿™ä¸ªé—®é¢˜ æ¡ä»¶å˜é‡1234567891011// æ¡ä»¶å˜é‡çš„ç±»å‹ pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); // - ç­‰å¾…ï¼Œè°ƒç”¨äº†è¯¥å‡½æ•°ï¼Œçº¿ç¨‹ä¼šé˜»å¡ã€‚ int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); // - ç­‰å¾…å¤šé•¿æ—¶é—´ï¼Œè°ƒç”¨äº†è¿™ä¸ªå‡½æ•°ï¼Œçº¿ç¨‹ä¼šé˜»å¡ï¼Œç›´åˆ°æŒ‡å®šçš„æ—¶é—´ç»“æŸã€‚ int pthread_cond_signal(pthread_cond_t *cond); // - å”¤é†’ä¸€ä¸ªæˆ–è€…å¤šä¸ªç­‰å¾…çš„çº¿ç¨‹ int pthread_cond_broadcast(pthread_cond_t *cond); // - å”¤é†’æ‰€æœ‰çš„ç­‰å¾…çš„çº¿ç¨‹ æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹(ç®€å•ç‰ˆ)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;pthread_mutex_t mutex;//åˆ›å»ºæ¡ä»¶å˜é‡pthread_cond_t cond;struct Node&#123; int num; struct Node* next;&#125;;//å¤´ç»“ç‚¹struct Node* head = NULL;void* producer(void* arg)&#123; //ä¸æ–­çš„åˆ›å»ºæ–°çš„èŠ‚ç‚¹ï¼Œæ·»åŠ åˆ°é“¾è¡¨ä¸­ while (1) &#123; pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); //åªè¦ç”Ÿäº§äº†ä¸€ä¸ªå°±é€šçŸ¥æ¶ˆè´¹è€…æ¶ˆè´¹ pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); //ä¿å­˜å¤´èŠ‚ç‚¹çš„æŒ‡é’ˆ struct Node* tmp = head; //åˆ¤æ–­æ˜¯å¦æœ‰æ•°æ® if (head != NULL) &#123; // æœ‰æ•°æ® head = head-&gt;next; printf(&quot;del node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; //æ²¡æœ‰æ•°æ® éœ€è¦ç­‰å¾… //å½“è¿™ä¸ªå‡½æ•°è°ƒç”¨é˜»å¡çš„æ—¶å€™ï¼Œä¼šå¯¹äº’æ–¥é”è¿›è¡Œè§£é”ï¼Œå½“ä¸é˜»å¡æ—¶ï¼Œç»§ç»­å‘ä¸‹æ‰§è¡Œï¼Œä¼šé‡æ–°åŠ é”ã€‚ pthread_cond_wait(&amp;cond, &amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond, NULL); //åˆ›å»º5ä¸ªç”Ÿäº§è€…çº¿ç¨‹å’Œ5ä¸ªæ¶ˆè´¹è€…çº¿ç¨‹ pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); pthread_exit(NULL);&#125; ä½¿ç”¨æ¡ä»¶å˜é‡è§£å†³ä¸Šè¿°ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„é—®é¢˜ã€‚ ä¿¡å·é‡123456789101112131415161718192021222324252627282930313233343536// ä¿¡å·é‡çš„ç±»å‹ sem_tint sem_init(sem_t *sem, int pshared, unsigned int value); // - åˆå§‹åŒ–ä¿¡å·é‡ // - å‚æ•°ï¼š // - sem : ä¿¡å·é‡å˜é‡çš„åœ°å€ // - pshared : 0 ç”¨åœ¨çº¿ç¨‹é—´ ï¼Œé0 ç”¨åœ¨è¿›ç¨‹é—´ // - value : ä¿¡å·é‡ä¸­çš„å€¼int sem_destroy(sem_t *sem); // - é‡Šæ”¾èµ„æºint sem_wait(sem_t *sem); // - å¯¹ä¿¡å·é‡åŠ é”ï¼Œè°ƒç”¨ä¸€æ¬¡å¯¹ä¿¡å·é‡çš„å€¼-1ï¼Œå¦‚æœå€¼ä¸º0ï¼Œå°±é˜»å¡int sem_trywait(sem_t *sem);int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);int sem_post(sem_t *sem); // - å¯¹ä¿¡å·é‡è§£é”ï¼Œè°ƒç”¨ä¸€æ¬¡å¯¹ä¿¡å·é‡çš„å€¼+1int sem_getvalue(sem_t *sem, int *sval);// sem_t psem;// sem_t csem;// init(psem, 0, 8);// init(csem, 0, 0);// producer() &#123;// sem_wait(&amp;psem);// sem_post(&amp;csem)// &#125;// customer() &#123;// sem_wait(&amp;csem);// sem_post(&amp;psem)// &#125; æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹(ç®€å•ç‰ˆ)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;pthread_mutex_t mutex;//åˆ›å»ºä¸¤ä¸ªä¿¡å·é‡sem_t psem;sem_t csem;struct Node&#123; int num; struct Node* next;&#125;;//å¤´ç»“ç‚¹struct Node* head = NULL;void* producer(void* arg)&#123; //ä¸æ–­çš„åˆ›å»ºæ–°çš„èŠ‚ç‚¹ï¼Œæ·»åŠ åˆ°é“¾è¡¨ä¸­ while (1) &#123; sem_wait(&amp;psem); pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;csem); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; sem_wait(&amp;csem); pthread_mutex_lock(&amp;mutex); //ä¿å­˜å¤´èŠ‚ç‚¹çš„æŒ‡é’ˆ struct Node* tmp = head; // æœ‰æ•°æ® head = head-&gt;next; printf(&quot;del node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;psem); &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex, NULL); sem_init(&amp;psem, 0, 8); sem_init(&amp;csem, 0, 0); //åˆ›å»º5ä¸ªç”Ÿäº§è€…çº¿ç¨‹å’Œ5ä¸ªæ¶ˆè´¹è€…çº¿ç¨‹ pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL);&#125; ä¿¡å·é‡åŒæ ·è§£å†³äº†ä¸Šè¿°ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„é—®é¢˜","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"çº¿ç¨‹","slug":"çº¿ç¨‹","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"C++å­¦ä¹  æ•°æ®åº“ç¼–ç¨‹","slug":"C++-å­¦ä¹ -æ•°æ®åº“ç¼–ç¨‹","date":"2023-05-11T06:10:20.000Z","updated":"2023-05-11T10:33:21.034Z","comments":true,"path":"2023/05/11/C++-å­¦ä¹ -æ•°æ®åº“ç¼–ç¨‹/","link":"","permalink":"http://example.com/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Oracle Oracleå®‰è£…è¿æ¥ï¼šDatabase Software Downloads | Oracle","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"æ•°æ®åº“","slug":"ç¼–ç¨‹è¯­è¨€/C/æ•°æ®åº“","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"æ•°æ®åº“","slug":"æ•°æ®åº“","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"C++å­¦ä¹  QTç®€ä»‹","slug":"C++-å­¦ä¹ -QTç®€ä»‹","date":"2023-05-11T05:39:45.000Z","updated":"2023-05-14T13:37:03.146Z","comments":true,"path":"2023/05/11/C++-å­¦ä¹ -QTç®€ä»‹/","link":"","permalink":"http://example.com/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/","excerpt":"QTçš„ä¸‹è½½å’Œå®‰è£…Index of &#x2F; (qt.io) Index of &#x2F;qt&#x2F; | æ¸…åå¤§å­¦å¼€æºè½¯ä»¶é•œåƒç«™ | Tsinghua Open Source Mirror","text":"QTçš„ä¸‹è½½å’Œå®‰è£…Index of &#x2F; (qt.io) Index of &#x2F;qt&#x2F; | æ¸…åå¤§å­¦å¼€æºè½¯ä»¶é•œåƒç«™ | Tsinghua Open Source Mirror ä¸‹è½½åœ¨çº¿å®‰è£…åŒ…ä¹‹å 1.\\qt-unified-windows-x64-4.5.2-online.exe --mirror https://mirror.nju.edu.cn/qt è¿è¡Œè¿™é“å‘½ä»¤å°†æºæ¢æˆå›½å†…çš„é•œåƒä¹‹åè¿›è¡Œå®‰è£… Qtåˆ›å»ºé¡¹ç›®ä»¥åŠmainå’Œproæ–‡ä»¶çš„ç”ŸæˆQtåˆ›å»ºé¡¹ç›® åˆ›å»ºé¡¹ç›® åˆ›å»ºæ­¥éª¤ è¿™é‡Œæˆ‘ä»¬é€‰æ‹©qmakeä¸ºä¾‹å­å­¦ä¹ ï¼Œä¸ç„¶æ²¡æœ‰proæ–‡ä»¶ï¼ŒCMakeæ˜¯ä¸€ä¸ªtxtæ–‡ä»¶ æˆ‘ä»¬ä»¥QWidgetä¸ºä¾‹ æ­¤æ—¶QTé¡¹ç›®å·²ç»åˆ›å»ºå®Œæˆ mainæ–‡ä»¶å’Œproæ–‡ä»¶è§£æmainæ–‡ä»¶ 123456789101112131415#include &quot;mywidget.h&quot;#include &lt;QApplication&gt;//åº”ç”¨ç¨‹åºç±»//ç¨‹åºå…¥å£ argv å‘½ä»¤è¡Œå˜é‡æ•°é‡ å‘½ä»¤è¡Œå˜é‡æ•°ç»„int main(int argc, char *argv[])&#123; //a åº”ç”¨ç¨‹åºå¯¹è±¡ï¼Œåœ¨Qtä¸­åº”ç”¨ç¨‹åºå¯¹è±¡æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª QApplication a(argc, argv); //é€šè¿‡çª—å£ç±»å®ä¾‹åŒ–å¯¹è±¡ w MyWidget w; //çª—å£æ˜¯ä¸ä¼šé»˜è®¤å¼¹å‡ºçš„ï¼Œéœ€è¦è°ƒç”¨showæ–¹æ³•è¿›è¡Œæ˜¾ç¤º w.show(); //a.exec();è¿›å…¥æ¶ˆæ¯å¾ªç¯æœºåˆ¶ é˜»å¡åŠŸèƒ½ return a.exec();&#125; proæ–‡ä»¶ 123456789101112131415161718192021QT += core gui //QtåŒ…å«çš„æ¨¡å—greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //å¤§äº4ç‰ˆæœ¬ åŠ å…¥widgetæ¨¡å—CONFIG += c++17# You can make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0SOURCES += \\ main.cpp \\ mywidget.cpp //æºæ–‡ä»¶HEADERS += \\ mywidget.h //å¤´æ–‡ä»¶# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target Qt6åŒ…å«æ¨¡å— æ¨¡å— æè¿° Qt Core ä¸‹é¢å…¶ä»–æ¨¡å—ä½¿ç”¨çš„æ ¸å¿ƒåŸºç¡€ç±»ï¼ˆQt Coreæ˜¯éå›¾å½¢æ¨¡å—ï¼‰ Qt D-Bus ç”¨äºé€šè¿‡ D-Bus åè®®è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡çš„ç±» Qt GUI å›¾å½¢ç”¨æˆ·ç•Œé¢ ï¼ˆGUIï¼‰ ç»„ä»¶çš„åŸºç±» Qt Network ä½¿ç½‘ç»œç¼–ç¨‹æ›´è½»æ¾ã€æ›´æ˜“ç§»æ¤çš„ç±» Qt QML QML å’Œ JavaScript è¯­è¨€çš„ç±» Qt Quick ä¸€ä¸ªå£°æ˜æ€§æ¡†æ¶ï¼Œç”¨äºæ„å»ºå…·æœ‰è‡ªå®šä¹‰ç”¨æˆ·ç•Œé¢çš„é«˜åº¦åŠ¨æ€çš„åº”ç”¨ç¨‹åºã€‚ Qt Quick Controls æä¾›è½»é‡çº§ QML ç±»ï¼Œç”¨äºä¸ºæ¡Œé¢ã€åµŒå…¥å¼å’Œç§»åŠ¨è®¾å¤‡åˆ›å»ºé«˜æ€§èƒ½ç”¨æˆ·ç•Œé¢ã€‚è¿™äº›ç±»å‹é‡‡ç”¨ç®€å•çš„æ ·å¼ä½“ç³»ç»“æ„ï¼Œå¹¶ä¸”éå¸¸é«˜æ•ˆã€‚ Qt Quick Dialogs ç”¨äºä» Qt å¿«é€Ÿåº”ç”¨ç¨‹åºåˆ›å»ºç³»ç»Ÿå¯¹è¯æ¡†å¹¶ä¸ä¹‹äº¤äº’çš„ç±»ã€‚ Qt Quick Layouts å¸ƒå±€æ˜¯ç”¨äºåœ¨ç”¨æˆ·ç•Œé¢ä¸­æ’åˆ—åŸºäº Qt Quick 2 çš„é¡¹ç›®çš„é¡¹ã€‚ Qt Quick Test QML åº”ç”¨ç¨‹åºçš„å•å…ƒæµ‹è¯•æ¡†æ¶ï¼Œå…¶ä¸­æµ‹è¯•ç”¨ä¾‹ç¼–å†™ä¸º JavaScript å‡½æ•°ã€‚Note: äºŒè¿›åˆ¶å…¼å®¹æ€§ä¿è¯ä¸é€‚ç”¨äºQtå¿«é€Ÿæµ‹è¯•ã€‚ä½†æ˜¯ï¼Œå®ƒå°†ä¿æŒæºå…¼å®¹ã€‚ Qt Test ç”¨äºå•å…ƒæµ‹è¯• Qt åº”ç”¨ç¨‹åºå’Œåº“çš„ç±»ã€‚Note: äºŒè¿›åˆ¶å…¼å®¹æ€§ä¿è¯ä¸é€‚ç”¨äº Qt æµ‹è¯•ã€‚ä½†æ˜¯ï¼Œå®ƒå°†ä¿æŒæºå…¼å®¹ã€‚ Qt Widgets ä½¿ç”¨C++ widgetæ‰©å±•Qt GUIçš„ç±»ã€‚ å‘½åè§„èŒƒå’Œå¿«æ·é”®","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"QT","slug":"ç¼–ç¨‹è¯­è¨€/C/QT","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/QT/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"}]},{"title":"C++å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ è¿›ç¨‹é€šä¿¡","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-è¿›ç¨‹é€šä¿¡","date":"2023-05-08T06:24:26.000Z","updated":"2023-05-14T10:58:16.060Z","comments":true,"path":"2023/05/08/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-è¿›ç¨‹é€šä¿¡/","link":"","permalink":"http://example.com/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"è¿›ç¨‹é—´é€šä¿¡ç®€ä»‹è¿›ç¨‹é—´é€šè®¯çš„æ¦‚å¿µ è¿›ç¨‹æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„èµ„æºåˆ†é…å•å…ƒï¼Œä¸åŒè¿›ç¨‹ï¼ˆè¿™é‡Œæ‰€è¯´çš„è¿›ç¨‹é€šå¸¸æŒ‡çš„æ˜¯ç”¨æˆ·è¿›ç¨‹ï¼‰ä¹‹é—´çš„èµ„æºæ˜¯ç‹¬ç«‹çš„ï¼Œæ²¡æœ‰å…³è”ï¼Œä¸èƒ½åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ç›´æ¥è®¿é—®å¦ä¸€ä¸ªè¿›ç¨‹çš„èµ„æºã€‚ ä½†æ˜¯ï¼Œè¿›ç¨‹ä¸æ˜¯å­¤ç«‹çš„ï¼Œä¸åŒçš„è¿›ç¨‹éœ€è¦è¿›è¡Œä¿¡æ¯çš„äº¤äº’å’ŒçŠ¶æ€çš„ä¼ é€’ç­‰ï¼Œå› æ­¤éœ€è¦è¿›ç¨‹é—´é€šä¿¡( IPCï¼šInter Processes Communication )ã€‚ è¿›ç¨‹é—´é€šä¿¡çš„ç›®çš„ï¼š æ•°æ®ä¼ è¾“ï¼šä¸€ä¸ªè¿›ç¨‹éœ€è¦å°†å®ƒçš„æ•°æ®å‘é€ç»™å¦ä¸€ä¸ªè¿›ç¨‹ã€‚ é€šçŸ¥äº‹ä»¶ï¼šä¸€ä¸ªè¿›ç¨‹éœ€è¦å‘å¦ä¸€ä¸ªæˆ–ä¸€ç»„è¿›ç¨‹å‘é€æ¶ˆæ¯ï¼Œé€šçŸ¥å®ƒï¼ˆå®ƒä»¬ï¼‰å‘ç”Ÿäº†æŸç§äº‹ä»¶ï¼ˆå¦‚è¿›ç¨‹ç»ˆæ­¢æ—¶è¦é€šçŸ¥çˆ¶è¿›ç¨‹ï¼‰ã€‚ èµ„æºå…±äº«ï¼šå¤šä¸ªè¿›ç¨‹ä¹‹é—´å…±äº«åŒæ ·çš„èµ„æºã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œéœ€è¦å†…æ ¸æä¾›äº’æ–¥å’ŒåŒæ­¥æœºåˆ¶ã€‚ è¿›ç¨‹æ§åˆ¶ï¼šæœ‰äº›è¿›ç¨‹å¸Œæœ›å®Œå…¨æ§åˆ¶å¦ä¸€ä¸ªè¿›ç¨‹çš„æ‰§è¡Œï¼ˆå¦‚ Debug è¿›ç¨‹ï¼‰ï¼Œæ­¤æ—¶æ§åˆ¶è¿›ç¨‹å¸Œæœ›èƒ½å¤Ÿæ‹¦æˆªå¦ä¸€ä¸ªè¿›ç¨‹çš„æ‰€æœ‰é™·å…¥å’Œå¼‚å¸¸ï¼Œå¹¶èƒ½å¤ŸåŠæ—¶çŸ¥é“å®ƒçš„çŠ¶æ€æ”¹å˜ã€‚","text":"è¿›ç¨‹é—´é€šä¿¡ç®€ä»‹è¿›ç¨‹é—´é€šè®¯çš„æ¦‚å¿µ è¿›ç¨‹æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„èµ„æºåˆ†é…å•å…ƒï¼Œä¸åŒè¿›ç¨‹ï¼ˆè¿™é‡Œæ‰€è¯´çš„è¿›ç¨‹é€šå¸¸æŒ‡çš„æ˜¯ç”¨æˆ·è¿›ç¨‹ï¼‰ä¹‹é—´çš„èµ„æºæ˜¯ç‹¬ç«‹çš„ï¼Œæ²¡æœ‰å…³è”ï¼Œä¸èƒ½åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ç›´æ¥è®¿é—®å¦ä¸€ä¸ªè¿›ç¨‹çš„èµ„æºã€‚ ä½†æ˜¯ï¼Œè¿›ç¨‹ä¸æ˜¯å­¤ç«‹çš„ï¼Œä¸åŒçš„è¿›ç¨‹éœ€è¦è¿›è¡Œä¿¡æ¯çš„äº¤äº’å’ŒçŠ¶æ€çš„ä¼ é€’ç­‰ï¼Œå› æ­¤éœ€è¦è¿›ç¨‹é—´é€šä¿¡( IPCï¼šInter Processes Communication )ã€‚ è¿›ç¨‹é—´é€šä¿¡çš„ç›®çš„ï¼š æ•°æ®ä¼ è¾“ï¼šä¸€ä¸ªè¿›ç¨‹éœ€è¦å°†å®ƒçš„æ•°æ®å‘é€ç»™å¦ä¸€ä¸ªè¿›ç¨‹ã€‚ é€šçŸ¥äº‹ä»¶ï¼šä¸€ä¸ªè¿›ç¨‹éœ€è¦å‘å¦ä¸€ä¸ªæˆ–ä¸€ç»„è¿›ç¨‹å‘é€æ¶ˆæ¯ï¼Œé€šçŸ¥å®ƒï¼ˆå®ƒä»¬ï¼‰å‘ç”Ÿäº†æŸç§äº‹ä»¶ï¼ˆå¦‚è¿›ç¨‹ç»ˆæ­¢æ—¶è¦é€šçŸ¥çˆ¶è¿›ç¨‹ï¼‰ã€‚ èµ„æºå…±äº«ï¼šå¤šä¸ªè¿›ç¨‹ä¹‹é—´å…±äº«åŒæ ·çš„èµ„æºã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼Œéœ€è¦å†…æ ¸æä¾›äº’æ–¥å’ŒåŒæ­¥æœºåˆ¶ã€‚ è¿›ç¨‹æ§åˆ¶ï¼šæœ‰äº›è¿›ç¨‹å¸Œæœ›å®Œå…¨æ§åˆ¶å¦ä¸€ä¸ªè¿›ç¨‹çš„æ‰§è¡Œï¼ˆå¦‚ Debug è¿›ç¨‹ï¼‰ï¼Œæ­¤æ—¶æ§åˆ¶è¿›ç¨‹å¸Œæœ›èƒ½å¤Ÿæ‹¦æˆªå¦ä¸€ä¸ªè¿›ç¨‹çš„æ‰€æœ‰é™·å…¥å’Œå¼‚å¸¸ï¼Œå¹¶èƒ½å¤ŸåŠæ—¶çŸ¥é“å®ƒçš„çŠ¶æ€æ”¹å˜ã€‚ Linuxè¿›ç¨‹é—´é€šä¿¡æ–¹å¼ åŒ¿åç®¡é“æ¦‚è¿° ç®¡é“ä¹Ÿå«æ— åï¼ˆåŒ¿åï¼‰ç®¡é“ï¼Œå®ƒæ˜¯æ˜¯ UNIX ç³»ç»Ÿ IPCï¼ˆè¿›ç¨‹é—´é€šä¿¡ï¼‰çš„æœ€å¤è€å½¢å¼ï¼Œæ‰€æœ‰çš„ UNIX ç³»ç»Ÿéƒ½æ”¯æŒè¿™ç§é€šä¿¡æœºåˆ¶ã€‚ ç»Ÿè®¡ä¸€ä¸ªç›®å½•ä¸­æ–‡ä»¶çš„æ•°ç›®å‘½ä»¤ï¼šls | wc â€“lï¼Œä¸ºäº†æ‰§è¡Œè¯¥å‘½ä»¤ï¼Œshell åˆ›å»ºäº†ä¸¤ä¸ªè¿›ç¨‹æ¥åˆ†åˆ«æ‰§è¡Œ lså’Œ wcã€‚ ç®¡é“çš„ç‰¹ç‚¹ ç®¡é“å…¶å®æ˜¯ä¸€ä¸ªåœ¨å†…æ ¸å†…å­˜ä¸­ç»´æŠ¤çš„ç¼“å†²å™¨ï¼Œè¿™ä¸ªç¼“å†²å™¨çš„å­˜å‚¨èƒ½åŠ›æ˜¯æœ‰é™çš„ï¼Œä¸åŒçš„æ“ä½œç³»ç»Ÿå¤§å°ä¸ä¸€å®šç›¸åŒã€‚ ç®¡é“æ‹¥æœ‰æ–‡ä»¶çš„ç‰¹è´¨ï¼šè¯»æ“ä½œã€å†™æ“ä½œï¼ŒåŒ¿åç®¡é“æ²¡æœ‰æ–‡ä»¶å®ä½“ï¼Œæœ‰åç®¡é“æœ‰æ–‡ä»¶å®ä½“ï¼Œä½†ä¸å­˜å‚¨æ•°æ®ã€‚å¯ä»¥æŒ‰ç…§æ“ä½œæ–‡ä»¶çš„æ–¹å¼å¯¹ç®¡é“è¿›è¡Œæ“ä½œã€‚ ä¸€ä¸ªç®¡é“æ˜¯ä¸€ä¸ªå­—èŠ‚æµï¼Œä½¿ç”¨ç®¡é“æ—¶ä¸å­˜åœ¨æ¶ˆæ¯æˆ–è€…æ¶ˆæ¯è¾¹ç•Œçš„æ¦‚å¿µï¼Œä»ç®¡é“è¯»å–æ•°æ®çš„è¿›ç¨‹å¯ä»¥è¯»å–ä»»æ„å¤§å°çš„æ•°æ®å—ï¼Œè€Œä¸ç®¡å†™å…¥è¿›ç¨‹å†™å…¥ç®¡é“çš„æ•°æ®å—çš„å¤§å°æ˜¯å¤šå°‘ã€‚ é€šè¿‡ç®¡é“ä¼ é€’çš„æ•°æ®æ˜¯é¡ºåºçš„ï¼Œä»ç®¡é“ä¸­è¯»å–å‡ºæ¥çš„å­—èŠ‚çš„é¡ºåºå’Œå®ƒä»¬è¢«å†™å…¥ç®¡é“çš„é¡ºåºæ˜¯å®Œå…¨ä¸€æ ·çš„ã€‚ åœ¨ç®¡é“ä¸­çš„æ•°æ®çš„ä¼ é€’æ–¹å‘æ˜¯å•å‘çš„ï¼Œä¸€ç«¯ç”¨äºå†™å…¥ï¼Œä¸€ç«¯ç”¨äºè¯»å–ï¼Œç®¡é“æ˜¯åŠåŒå·¥çš„ã€‚ ä»ç®¡é“è¯»æ•°æ®æ˜¯ä¸€æ¬¡æ€§æ“ä½œï¼Œæ•°æ®ä¸€æ—¦è¢«è¯»èµ°ï¼Œå®ƒå°±ä»ç®¡é“ä¸­è¢«æŠ›å¼ƒï¼Œé‡Šæ”¾ç©ºé—´ä»¥ä¾¿å†™æ›´å¤šçš„æ•°æ®ï¼Œåœ¨ç®¡é“ä¸­æ— æ³•ä½¿ç”¨ lseek() æ¥éšæœºçš„è®¿é—®æ•°æ®ã€‚ åŒ¿åç®¡é“åªèƒ½åœ¨å…·æœ‰å…¬å…±ç¥–å…ˆçš„è¿›ç¨‹ï¼ˆçˆ¶è¿›ç¨‹ä¸å­è¿›ç¨‹ï¼Œæˆ–è€…ä¸¤ä¸ªå…„å¼Ÿè¿›ç¨‹ï¼Œå…·æœ‰äº²ç¼˜å…³ç³»ï¼‰ä¹‹é—´ä½¿ç”¨ã€‚ ä¸ºä»€ä¹ˆå¯ä»¥ä½¿ç”¨ç®¡é“è¿›è¡Œé€šä¿¡ ç®¡é“çš„æ•°æ®ç»“æ„ pipeå‡½æ•°12345678910#include&lt;unistd.h&gt;int pipe(int pipefd[2]);//åŠŸèƒ½ï¼šåˆ›å»ºä¸€ä¸ªåŒ¿åç®¡é“ï¼Œç”¨æ¥è¿›ç¨‹é—´é€šä¿¡//å‚æ•°ï¼š//int pipefd[2]è¿™ä¸ªæ•°ç»„æ˜¯ä¸€ä¸ªä¼ å‡ºå‚æ•°//pipefd[0]å¯¹åº”çš„æ˜¯ç®¡é“çš„è¯»ç«¯ï¼Œpipefd[1]å¯¹åº”çš„æ˜¯ç®¡é“çš„å†™ç«¯//è¿”å›å€¼ï¼š //æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1//æ³¨æ„ï¼šåŒ¿åç®¡é“åªèƒ½ç”¨äºå…·æœ‰å…³ç³»çš„è¿›ç¨‹ä¹‹é—´çš„é€šä¿¡ï¼ˆçˆ¶å­è¿›ç¨‹ï¼Œå…„å¼Ÿè¿›ç¨‹ï¼‰//ç®¡é“æ˜¯é»˜è®¤é˜»å¡çš„ï¼Œå¦‚æœç®¡é“ä¸­æ²¡æœ‰æ•°æ®ï¼Œreadé˜»å¡ï¼Œå¦‚æœç®¡é“æ»¡äº†ï¼Œwriteé˜»å¡ æ¡ˆä¾‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; // åœ¨forkä¹‹å‰åˆ›å»ºç®¡é“ int pipefd[2]; int ret = pipe(pipefd); if (ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // åˆ›å»ºå­è¿›ç¨‹ pid_t pid = fork(); if (pid &gt; 0) &#123; // çˆ¶è¿›ç¨‹ printf(&quot;i am prent process, pid : %d\\n&quot;, getpid()); // å…³é—­å†™ç«¯ close(pipefd[1]); // ä»ç®¡é“çš„è¯»å–ç«¯è¯»å–æ•°æ® char buf[1024] = &#123; 0 &#125;; while (1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent recv : %s, pid : %d\\n&quot;, buf, getpid()); // å‘ç®¡é“ä¸­å†™å…¥æ•°æ® char * str = &quot;hello,i am parent&quot;; write(pipefd[1], str, strlen(str)); sleep(1); &#125; &#125; else if (pid == 0) &#123; // å­è¿›ç¨‹ printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); // å…³é—­è¯»ç«¯ close(pipefd[0]); char buf[1024] = &#123; 0 &#125;; while (1) &#123; // å‘ç®¡é“ä¸­å†™å…¥æ•°æ® char* str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(1); int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;child recv : %s, pid : %d\\n&quot;, buf, getpid()); // bzero(buf, 1024); &#125; &#125; return 0;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š åŒ¿åç®¡é“çš„ä½¿ç”¨ åˆ›å»ºåŒ¿åç®¡é“ 12#include&lt;unistd.h&gt;int pipe(int pipefd[2]); æŸ¥çœ‹ç®¡é“ç¼“å†²å¤§å°å‘½ä»¤ 1ulimit -a æŸ¥çœ‹ç®¡é“ç¼“å†²å¤§å°å‡½æ•° 12#include&lt;unistd.h&gt;long fpathconf(int fd, int name); 123456789101112131415#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; int pipefd[2]; int ret = pipe(pipefd); long size = fpathconf(pipefd[0], _PC_PIPE_BUF);//è·å–ç®¡é“çš„å¤§å° printf(&quot;pipe size : %ld\\n&quot;, size); return 0;&#125; ç¼–è¯‘è¿è¡Œï¼Œç»“æœä¸ºï¼š ä¸€ä¸ªæ¡ˆä¾‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* å®ç°ps aux | grep xxx çˆ¶å­è¿›ç¨‹ä¹‹é—´é€šä¿¡ å­è¿›ç¨‹ï¼šps auxï¼Œå­è¿›ç¨‹ç»“æŸä»¥åï¼Œå°†æ•°æ®å‘é€ç»™çˆ¶è¿›ç¨‹ çˆ¶è¿›ç¨‹ï¼šè·å–åˆ°æ•°æ®ï¼Œè¿‡æ»¤ pipe() execlp() å­è¿›ç¨‹å°†æ ‡å‡†è¾“å‡ºstdout_filenoé‡å®šå‘åˆ°ç®¡é“å†™ç«¯ã€‚dup2 æ²¡æœ‰å®ç°è¿‡æ»¤åŠŸèƒ½*/#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;wait.h&gt;int main()&#123; //åˆ›å»ºä¸€ä¸ªç®¡é“ int fd[2]; int ret = pipe(fd); if (ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; //åˆ›å»ºå­è¿›ç¨‹ pid_t pid = fork(); if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ //å…³é—­å†™ç«¯ close(fd[1]); //ä»ç®¡é“ä¸­è¯»å– char buf[1024] = &#123; 0 &#125;; int len = -1; //è¿‡æ»¤æ•°æ®è¾“å‡º while ((len = read(fd[0], buf, sizeof(buf) - 1)) &gt; 0) &#123; printf(&quot;%s&quot;, buf); memset(buf, 0, 1024); &#125; wait(NULL); &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ //å…³é—­è¯»ç«¯ close(fd[0]); //æ–‡ä»¶æè¿°ç¬¦çš„é‡å®šå‘ stdout_fileno -&gt; fd[1] dup2(fd[1], STDOUT_FILENO); //æ‰§è¡Œ ps aux execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); perror(&quot;execlp&quot;); exit(0); &#125; else &#123; perror(&quot;fork&quot;); exit(0); &#125; } è¿è¡Œç»“æœä¸ºï¼š å› ä¸ºç®¡é“åªæœ‰4096bytesï¼Œæ‰€ä»¥è¿è¡Œè¿™ä¸ªç¨‹åºåªä¼šæ˜¾ç¤º4096bytesï¼Œå¦‚æœè¦æ˜¾ç¤ºæ‰€æœ‰çš„ä¿¡æ¯éœ€è¦å¾ªç¯å¾€ç®¡é“ä¸­å†™æ•°æ® ç®¡é“çš„è¯»å†™ç‰¹ç‚¹å’Œç®¡é“è®¾ç½®ä¸ºéé˜»å¡ç®¡é“çš„è¯»å†™ç‰¹ç‚¹ï¼š ä½¿ç”¨ç®¡é“æ—¶ï¼Œéœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ç§ç‰¹æ®Šçš„æƒ…å†µï¼ˆå‡è®¾éƒ½æ˜¯é˜»å¡çš„I&#x2F;Oæ“ä½œï¼‰ æ‰€æœ‰çš„æŒ‡å‘ç®¡é“å†™ç«¯çš„æ–‡ä»¶æè¿°ç¬¦éƒ½å…³é—­äº†ï¼ˆç®¡é“å†™ç«¯å¼•ç”¨è®¡æ•°ä¸º0ï¼‰ï¼Œæœ‰è¿›ç¨‹ä»ç®¡é“çš„è¯»ç«¯è¯»æ•°æ®ï¼Œé‚£ä¹ˆç®¡é“ä¸­å‰©ä½™çš„æ•°æ®è¢«è¯»å–ä»¥åï¼Œå†æ¬¡readä¼šè¿”å›0ï¼Œå°±åƒè¯»åˆ°æ–‡ä»¶æœ«å°¾ä¸€æ ·ã€‚ å¦‚æœæœ‰æŒ‡å‘ç®¡é“å†™ç«¯çš„æ–‡ä»¶æè¿°ç¬¦æ²¡æœ‰å…³é—­ï¼ˆç®¡é“çš„å†™ç«¯å¼•ç”¨è®¡æ•°å¤§äº0ï¼‰ï¼Œè€ŒæŒæœ‰ç®¡é“å†™ç«¯çš„è¿›ç¨‹ä¹Ÿæ²¡æœ‰å¾€ç®¡é“ä¸­å†™æ•°æ®ï¼Œè¿™ä¸ªæ—¶å€™æœ‰è¿›ç¨‹ä»ç®¡é“ä¸­è¯»å–æ•°æ®ï¼Œé‚£ä¹ˆç®¡é“ä¸­å‰©ä½™çš„æ•°æ®è¢«è¯»å–åï¼Œå†æ¬¡readä¼šé˜»å¡ï¼Œç›´åˆ°ç®¡é“ä¸­æœ‰æ•°æ®å¯ä»¥è¯»äº†ï¼Œæ‰è¯»å–æ•°æ®å¹¶è¿”å›ã€‚ å¦‚æœæ‰€æœ‰æŒ‡å‘ç®¡é“è¯»ç«¯çš„æ–‡ä»¶æè¿°ç¬¦éƒ½å…³é—­ï¼ˆç®¡é“çš„è¯»ç«¯å¼•ç”¨è®¡æ•°å¤§äº0ï¼‰ï¼Œè¿™ä¸ªæ—¶å€™æœ‰è¿›ç¨‹å‘ç®¡é“ä¸­å†™æ•°æ®ï¼Œé‚£ä¹ˆè¯¥è¿›ç¨‹ä¼šæ”¶åˆ°ä¸€ä¸ªä¿¡å·SIGPIPEï¼Œé€šå¸¸ä¼šå¯¼è‡´è¿›ç¨‹å¼‚å¸¸ç»ˆæ­¢ã€‚ å¦‚æœæœ‰æŒ‡å‘ç®¡é“è¯»ç«¯çš„æ–‡ä»¶æè¿°ç¬¦æ²¡æœ‰å…³é—­ï¼ˆç®¡é“çš„è¯»ç«¯å¼•ç”¨è®¡æ•°å¤§äº0ï¼‰ï¼Œè€ŒæŒæœ‰ç®¡é“è¯»ç«¯çš„è¿›ç¨‹ä¹Ÿæ²¡æœ‰ä»ç®¡é“ä¸­è¯»æ•°æ®ï¼Œè¿™æ—¶æœ‰è¿›ç¨‹å‘ç®¡é“ä¸­å†™æ•°æ®ï¼Œé‚£ä¹ˆåœ¨ç®¡é“åœ¨å†™æ»¡æ—¶å†æ¬¡writeä¼šé˜»å¡ï¼Œç›´åˆ°ç®¡é“ä¸­æœ‰ç©ºä½ç½®æ‰èƒ½å†™å…¥æ•°æ®å¹¶è¿”å›ã€‚ æ€»ç»“ï¼š è¯»ç®¡é“ ç®¡é“ä¸­æœ‰æ•°æ®ï¼Œreadè¿”å›å®é™…è¯»åˆ°çš„å­—èŠ‚æ•° ç®¡é“ä¸­æ— æ•°æ®ï¼š å†™ç«¯è¢«å…¨éƒ¨å…³é—­ï¼Œreadè¿”å›0ï¼Œç›¸å½“äºè¯»åˆ°æ–‡ä»¶çš„æœ«å°¾ å†™ç«¯æ²¡æœ‰å®Œå…¨å…³é—­ï¼Œreadé˜»å¡ç­‰å¾… å†™ç®¡é“ï¼š ç®¡é“è¯»ç«¯å…¨éƒ¨å…³é—­ï¼Œè¿›ç¨‹å¼‚å¸¸ç»ˆæ­¢ï¼ˆè¿›ç¨‹æ”¶åˆ°SIGPIPEä¿¡å·ï¼‰ ç®¡é“è¯»ç«¯æ²¡æœ‰å…¨éƒ¨å…³é—­ï¼š ç®¡é“å·²æ»¡ï¼šwriteé˜»å¡ ç®¡é“æœªæ»¡ï¼šwriteå°†æ•°æ®å†™å…¥ï¼Œå¹¶è¿”å›å®é™…å†™å…¥çš„å­—èŠ‚æ•° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;/* è®¾ç½®ç®¡é“éé˜»å¡ int flags = fcntl(fd[0], F_GETFL); // è·å–åŸæ¥çš„flag flags |= O_NONBLOCK; // ä¿®æ”¹flagçš„å€¼ fcntl(fd[0], F_SETFL, flags); // è®¾ç½®æ–°çš„flag*/int main() &#123; // åœ¨forkä¹‹å‰åˆ›å»ºç®¡é“ int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // åˆ›å»ºå­è¿›ç¨‹ pid_t pid = fork(); if(pid &gt; 0) &#123; // çˆ¶è¿›ç¨‹ printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); // å…³é—­å†™ç«¯ close(pipefd[1]); // ä»ç®¡é“çš„è¯»å–ç«¯è¯»å–æ•°æ® char buf[1024] = &#123;0&#125;; int flags = fcntl(pipefd[0], F_GETFL); // è·å–åŸæ¥çš„flag flags |= O_NONBLOCK; // ä¿®æ”¹flagçš„å€¼ fcntl(pipefd[0], F_SETFL, flags); // è®¾ç½®æ–°çš„flag while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;len : %d\\n&quot;, len); printf(&quot;parent recv : %s, pid : %d\\n&quot;, buf, getpid()); memset(buf, 0, 1024); sleep(1); &#125; &#125; else if(pid == 0)&#123; // å­è¿›ç¨‹ printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); // å…³é—­è¯»ç«¯ close(pipefd[0]); char buf[1024] = &#123;0&#125;; while(1) &#123; // å‘ç®¡é“ä¸­å†™å…¥æ•°æ® char * str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(5); &#125; &#125; return 0;&#125; è¿è¡Œç»“æœä¸ºï¼š åŒ¿åç®¡é“ï¼Œç”±äºæ²¡æœ‰åå­—ï¼Œåªèƒ½ç”¨äºäº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´é€šä¿¡ã€‚ä¸ºäº†å…‹æœè¿™ä¸ªç¼ºç‚¹ï¼Œæå‡ºäº†æœ‰åç®¡é“ï¼ˆFIFOï¼‰ï¼Œä¹Ÿå«å‘½åç®¡é“ã€FIFOæ–‡ä»¶ã€‚ æœ‰åç®¡é“ï¼ˆFIFOï¼‰ä¸åŒäºåŒ¿åç®¡é“ä¹‹å¤„åœ¨äºå®ƒæä¾›äº†ä¸€ä¸ªè·¯å¾„åä¸ä¹‹å…³è”ï¼Œä»¥ FIFO çš„æ–‡ä»¶å½¢å¼å­˜åœ¨äºæ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå¹¶ä¸”å…¶æ‰“å¼€æ–¹å¼ä¸æ‰“å¼€ä¸€ä¸ªæ™®é€šæ–‡ä»¶æ˜¯ä¸€æ ·çš„ï¼Œè¿™æ ·å³ä½¿ä¸ FIFO çš„åˆ›å»ºè¿›ç¨‹ä¸å­˜åœ¨äº²ç¼˜å…³ç³»çš„è¿›ç¨‹ï¼Œåªè¦å¯ä»¥è®¿é—®è¯¥è·¯å¾„ï¼Œå°±èƒ½å¤Ÿå½¼æ­¤é€šè¿‡ FIFO ç›¸äº’é€šä¿¡ï¼Œå› æ­¤ï¼Œé€šè¿‡ FIFO ä¸ç›¸å…³çš„è¿›ç¨‹ä¹Ÿèƒ½äº¤æ¢æ•°æ®ã€‚ ä¸€æ—¦æ‰“å¼€äº† FIFOï¼Œå°±èƒ½åœ¨å®ƒä¸Šé¢ä½¿ç”¨ä¸æ“ä½œåŒ¿åç®¡é“å’Œå…¶ä»–æ–‡ä»¶çš„ç³»ç»Ÿè°ƒç”¨ä¸€æ ·çš„I&#x2F;Oç³»ç»Ÿè°ƒç”¨äº†ï¼ˆå¦‚read()ã€write()å’Œclose()ï¼‰ã€‚ä¸ç®¡é“ä¸€æ ·ï¼ŒFIFO ä¹Ÿæœ‰ä¸€ä¸ªå†™å…¥ç«¯å’Œè¯»å–ç«¯ï¼Œå¹¶ä¸”ä»ç®¡é“ä¸­è¯»å–æ•°æ®çš„é¡ºåºä¸å†™å…¥çš„é¡ºåºæ˜¯ä¸€æ ·çš„ã€‚FIFO çš„åç§°ä¹Ÿç”±æ­¤è€Œæ¥ï¼šå…ˆå…¥å…ˆå‡ºã€‚ æœ‰åç®¡é“ï¼ˆFIFO)å’ŒåŒ¿åç®¡é“ï¼ˆpipeï¼‰æœ‰ä¸€äº›ç‰¹ç‚¹æ˜¯ç›¸åŒçš„ï¼Œä¸ä¸€æ ·çš„åœ°æ–¹åœ¨äºï¼š FIFO åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­ä½œä¸ºä¸€ä¸ªç‰¹æ®Šæ–‡ä»¶å­˜åœ¨ï¼Œä½† FIFO ä¸­çš„å†…å®¹å´å­˜æ”¾åœ¨å†…å­˜ä¸­ã€‚ å½“ä½¿ç”¨ FIFO çš„è¿›ç¨‹é€€å‡ºåï¼ŒFIFO æ–‡ä»¶å°†ç»§ç»­ä¿å­˜åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­ä»¥ä¾¿ä»¥åä½¿ç”¨ã€‚ FIFO æœ‰åå­—ï¼Œä¸ç›¸å…³çš„è¿›ç¨‹å¯ä»¥é€šè¿‡æ‰“å¼€æœ‰åç®¡é“è¿›è¡Œé€šä¿¡ã€‚ æœ‰åç®¡é“çš„ä½¿ç”¨ é€šè¿‡å‘½ä»¤åˆ›å»ºæœ‰åç®¡é“ 1mkfifo åå­— é€šè¿‡å‡½æ•°åˆ›å»ºæœ‰åç®¡é“ 123#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); ä¸€æ—¦ä½¿ç”¨mkfifoåˆ›å»ºäº†ä¸€ä¸ªFIFOï¼Œå°±å¯ä»¥ä½¿ç”¨openæ‰“å¼€å®ƒï¼Œå¸¸è§çš„æ–‡ä»¶I&#x2F;Oå‡½æ•°éƒ½å¯ç”¨äºfifoã€‚å¦‚ï¼šcloseã€readã€writeã€unlinkç­‰ã€‚ FIFOä¸¥æ ¼éµå¾ªå…ˆè¿›å…ˆå‡ºï¼Œå¯¹ç®¡é“åŠFIFOçš„è¯»æ€»æ˜¯ä»å¼€å§‹å¤„è¿”å›æ•°æ®ï¼Œå¯¹å®ƒä»¬çš„å†™åˆ™æ˜¯æŠŠæ•°æ®æ·»åŠ åˆ°æœ«å°¾ã€‚å®ƒä»¬ä¸æ”¯æŒè¯¸å¦‚lseek()ç­‰æ–‡ä»¶å®šä½æ“ä½œã€‚ mkfifoå‘½ä»¤ mkfifoå‡½æ•°12345678#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode);//å‚æ•°ï¼š//- pathnameï¼šç®¡é“åç§°è·¯å¾„//- modeï¼šæ–‡ä»¶çš„æƒé™ï¼Œå’Œopençš„æƒé™æ˜¯ä¸€æ ·çš„//è¿”å›å€¼//æˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1ï¼Œå¹¶è®¾ç½®é”™è¯¯å· 1234567891011121314#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125;&#125; æœ‰åç®¡é“é€šä¿¡æ¡ˆä¾‹write.cå¾€ç®¡é“ä¸­å†™å…¥æ•°æ® 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//å‘ç®¡é“ä¸­å†™æ•°æ®#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;int main()&#123; //1ã€åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨ int ret = access(&quot;test&quot;, F_OK); if (ret == -1) &#123; printf(&quot;ç®¡é“ä¸å­˜åœ¨ï¼Œåˆ›å»ºç®¡é“\\n&quot;); //2ã€åˆ›å»ºç®¡é“æ–‡ä»¶ ret = mkfifo(&quot;test&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; //3ã€ä»¥åªå†™çš„æ–¹å¼æ‰“å¼€ç®¡é“ int fd = open(&quot;test&quot;, O_WRONLY); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //å†™æ•°æ® for (int i = 0;i &lt; 100;i++) &#123; char buf[1024]; sprintf(buf, &quot;hello , %d\\n&quot;, i); printf(&quot;write data : %s\\n&quot;, buf); write(fd, buf, strlen(buf)); sleep(1); &#125; close(fd);&#125; read.cå¾€ç®¡é“ä¸­è¯»æ•°æ® 123456789101112131415161718192021222324252627282930//å‘ç®¡é“ä¸­è¯»æ•°æ®#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //1ã€æ‰“å¼€ç®¡é“æ–‡ä»¶ int fd = open(&quot;test&quot;,O_RDONLY); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //è¯»æ•°æ® while (1) &#123; char buf[1024] = &#123; 0 &#125;; int len = read(fd, buf, sizeof(buf)); if (len == 0) &#123; printf(&quot;å†™ç«¯æ–­å¼€è¿æ¥äº†....\\n&quot;); &#125; printf(&quot;recv buf : %s\\n&quot;, buf); &#125; close(fd);&#125; è¿è¡Œç»“æœä¸ºï¼š æœ‰åç®¡é“æ³¨æ„äº‹é¡¹ ä¸€ä¸ªä¸ºåªè¯»è€Œæ‰“å¼€çš„ä¸€ä¸ªç®¡é“çš„è¿›ç¨‹ä¼šé˜»å¡ï¼Œç›´åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ä¸ºå†™æ‰“å¼€ç®¡é“ ä¸€ä¸ªä¸ºåªå†™è€Œæ‰“å¼€ä¸€ä¸ªç®¡é“çš„è¿›ç¨‹ä¼šé˜»å¡ï¼Œç›´åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ä¸ºåªè¯»æ‰“å¼€ç®¡é“ è¯»ç®¡é“ï¼š ç®¡é“ä¸­æœ‰æ•°æ®ï¼Œreadè¿”å›å®é™…è¯»åˆ°çš„å­—èŠ‚æ•° ç®¡é“ä¸­æ— æ•°æ® ç®¡é“å†™ç«¯è¢«å…¨éƒ¨å…³é—­ï¼Œreadè¿”å›0ï¼Œï¼ˆç›¸å½“äºè¯»åˆ°æ–‡ä»¶æœ«å°¾ï¼‰ å†™ç«¯æ²¡æœ‰è¢«å…¨éƒ¨å…³é—­ï¼Œreadä¼šé˜»å¡ç­‰å¾… å†™ç®¡é“ï¼š ç®¡é“è¯»ç«¯è¢«å…¨éƒ¨å…³é—­ï¼Œè¿›ç¨‹ä¼šå¼‚å¸¸ç»ˆæ­¢ï¼ˆæ”¶åˆ°ä¸€ä¸ªSIGPIPEä¿¡å·ï¼‰ ç®¡é“è¯»ç«¯æ²¡æœ‰å…¨éƒ¨å…³é—­ ç®¡é“å·²ç»æ»¡äº†ï¼Œwriteä¼šé˜»å¡ ç®¡é“æ²¡æœ‰æ»¡ï¼Œwriteå°†æ•°æ®å†™å…¥ï¼Œå¹¶è¿”å›å®é™…å†™å…¥çš„å­—èŠ‚æ•° æœ‰åç®¡é“å®ç°ç®€å•ç‰ˆèŠå¤©åŠŸèƒ½ä½¿ç”¨æœ‰åç®¡é“å®ŒæˆèŠå¤©çš„åŠŸèƒ½ è¿›ç¨‹A ä»¥åªå†™çš„æ–¹å¼æ‰“å¼€ç®¡é“1 ä»¥åªè¯»çš„æ–¹å¼æ‰“å¼€ç®¡é“2 å¾ªç¯çš„å†™è¯»æ•°æ® while(1) { è·å–é”®ç›˜å½•å…¥fgets å†™ç®¡é“1 è¯»ç®¡é“2} è¿›ç¨‹A ä»¥åªå†™çš„æ–¹å¼æ‰“å¼€ç®¡é“1 ä»¥åªè¯»çš„æ–¹å¼æ‰“å¼€ç®¡é“2 å¾ªç¯çš„å†™è¯»æ•°æ® while(1) { è¯»ç®¡é“1 è·å–é”®ç›˜å½•å…¥fgets} chatA.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.åˆ¤æ–­æœ‰åç®¡é“æ–‡ä»¶æ˜¯å¦å­˜åœ¨ int ret = access(&quot;fifo1&quot;, F_OK); if (ret == -1) &#123; // æ–‡ä»¶ä¸å­˜åœ¨ printf(&quot;ç®¡é“ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¯¹åº”çš„æœ‰åç®¡é“\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if (ret == -1) &#123; // æ–‡ä»¶ä¸å­˜åœ¨ printf(&quot;ç®¡é“ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¯¹åº”çš„æœ‰åç®¡é“\\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 2.ä»¥åªå†™çš„æ–¹å¼æ‰“å¼€ç®¡é“fifo1 int fdw = open(&quot;fifo1&quot;, O_WRONLY); if (fdw == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;æ‰“å¼€ç®¡é“fifo1æˆåŠŸï¼Œç­‰å¾…å†™å…¥...\\n&quot;); // 3.ä»¥åªè¯»çš„æ–¹å¼æ‰“å¼€ç®¡é“fifo2 int fdr = open(&quot;fifo2&quot;, O_RDONLY); if (fdr == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;æ‰“å¼€ç®¡é“fifo2æˆåŠŸï¼Œç­‰å¾…è¯»å–...\\n&quot;); char buf[128]; // 4.å¾ªç¯çš„å†™è¯»æ•°æ® while (1) &#123; memset(buf, 0, 128); // è·å–æ ‡å‡†è¾“å…¥çš„æ•°æ® fgets(buf, 128, stdin); // å†™æ•°æ® ret = write(fdw, buf, strlen(buf)); if (ret == -1) &#123; perror(&quot;write&quot;); exit(0); &#125; // 5.è¯»ç®¡é“æ•°æ® memset(buf, 0, 128); ret = read(fdr, buf, 128); if (ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot;buf: %s\\n&quot;, buf); &#125; // 6.å…³é—­æ–‡ä»¶æè¿°ç¬¦ close(fdr); close(fdw); return 0;&#125; chatB.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.åˆ¤æ–­æœ‰åç®¡é“æ–‡ä»¶æ˜¯å¦å­˜åœ¨ int ret = access(&quot;fifo1&quot;, F_OK); if (ret == -1) &#123; // æ–‡ä»¶ä¸å­˜åœ¨ printf(&quot;ç®¡é“ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¯¹åº”çš„æœ‰åç®¡é“\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if (ret == -1) &#123; // æ–‡ä»¶ä¸å­˜åœ¨ printf(&quot;ç®¡é“ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¯¹åº”çš„æœ‰åç®¡é“\\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 2.ä»¥åªè¯»çš„æ–¹å¼æ‰“å¼€ç®¡é“fifo1 int fdr = open(&quot;fifo1&quot;, O_RDONLY); if (fdr == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;æ‰“å¼€ç®¡é“fifo1æˆåŠŸï¼Œç­‰å¾…è¯»å–...\\n&quot;); // 3.ä»¥åªå†™çš„æ–¹å¼æ‰“å¼€ç®¡é“fifo2 int fdw = open(&quot;fifo2&quot;, O_WRONLY); if (fdw == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;æ‰“å¼€ç®¡é“fifo2æˆåŠŸï¼Œç­‰å¾…å†™å…¥...\\n&quot;); char buf[128]; // 4.å¾ªç¯çš„è¯»å†™æ•°æ® while (1) &#123; // 5.è¯»ç®¡é“æ•°æ® memset(buf, 0, 128); ret = read(fdr, buf, 128); if (ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot;buf: %s\\n&quot;, buf); memset(buf, 0, 128); // è·å–æ ‡å‡†è¾“å…¥çš„æ•°æ® fgets(buf, 128, stdin); // å†™æ•°æ® ret = write(fdw, buf, strlen(buf)); if (ret == -1) &#123; perror(&quot;write&quot;); exit(0); &#125; &#125; // 6.å…³é—­æ–‡ä»¶æè¿°ç¬¦ close(fdr); close(fdw); return 0;&#125; è¿è¡Œç»“æœä¸ºï¼š å†…å­˜æ˜ å°„ å†…å­˜æ˜ å°„ç›¸å…³ç³»ç»Ÿè°ƒç”¨1234567891011121314151617181920212223242526272829#include&lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);//åŠŸèƒ½ï¼š//æ˜ å°„æˆ–è§£é™¤æ˜ å°„ä¸€ä¸ªè®¾å¤‡åˆ°å†…å­˜ä¸­//å‚æ•°ï¼š//- void *addrï¼šNULLï¼Œç”±å†…æ ¸æŒ‡å®š//- lengthï¼šè¦æ˜ å°„çš„æ•°æ®çš„é•¿åº¦ï¼Œä¸èƒ½ä¸º0ï¼Œå»ºè®®ä½¿ç”¨æ–‡ä»¶çš„é•¿åº¦//- int protï¼šå¯¹ç”³è¯·çš„å†…å­˜æ˜ å°„åŒºçš„æ“ä½œæƒé™// PROT_EXECï¼šå¯æ‰§è¡Œçš„æƒé™// PROT_WRITEï¼šè¯»æƒé™// PROT_WRITEï¼šå†™æƒé™// PROT_NONEï¼šæ²¡æœ‰æƒé™// è¦æ“ä½œæ˜ å°„åŒºå†…å­˜ï¼Œå¿…é¡»è¦æœ‰è¯»æƒé™//- flagsï¼š// MAP_SHEAREDï¼šæ˜ å°„åŒºæ•°æ®ä¼šè‡ªåŠ¨å’Œç£ç›˜æ–‡ä»¶åŒæ­¥ï¼Œè¿›ç¨‹é—´é€šä¿¡å¿…é¡»è¦è®¾ç½®è¿™ä¸ªé€‰é¡¹// MAP_PRIVATEï¼šä¸åŒæ­¥ï¼Œå†…å­˜æ˜ å°„åŒºçš„æ•°æ®å˜äº†ï¼Œå¯¹åŸæ¥çš„æ•°æ®ä¸ä¼šä¿®æ”¹ï¼Œä¼šé‡æ–°åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ã€‚ï¼ˆcopy on writeï¼‰//- fdï¼šéœ€è¦æ˜ å°„çš„é‚£ä¸ªæ–‡ä»¶çš„æ–‡ä»¶æè¿°ç¬¦// é€šè¿‡openå¾—åˆ°ï¼Œopençš„æ˜¯ä¸€ä¸ªç£ç›˜æ–‡ä»¶// æ³¨æ„æ–‡ä»¶å¤§å°ä¸èƒ½ä¸º0ï¼ŒopenæŒ‡å®šçš„æƒé™ä¸èƒ½å’Œprotå‚æ•°æœ‰å†²çª// openï¼šåªè¯»/è¯»å†™ protï¼šPROT_READ// openï¼šè¯»å†™ prot:PROT_READ | PROT_WRITE//- offsetï¼šåç§»é‡ï¼Œä¸€èˆ¬ä¸ç”¨ï¼Œå¿…é¡»æŒ‡å®šä¸º4Kçš„æ•´æ•°å€ï¼Œ0è¡¨ç¤ºä¸åç§»//- è¿”å›å€¼ï¼šè¿”å›åˆ›å»ºçš„å†…å­˜é¦–åœ°å€ï¼Œå¤±è´¥è¿”å›MAP_FAILED:(void*)-1 -1int munmap(void *addr, size_t length); int munmap(void *addr, size_t length);//åŠŸèƒ½ï¼šé‡Šæ”¾å†…å­˜æ˜ å°„//å‚æ•°ï¼š//- addrï¼šè¦é‡Šæ”¾çš„å†…å­˜é¦–åœ°å€//- lengthï¼šè¦é‡Šæ”¾çš„å†…å­˜å¤§å°ï¼Œè¦å’Œmmapå‡½æ•°ä¸­çš„lengthå‚æ•°çš„å€¼ä¸€æ · æ¡ˆä¾‹ï¼šçˆ¶å­è¿›ç¨‹ä½¿ç”¨å†…å­˜æ˜ å°„é€šä¿¡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//ä½¿ç”¨å†…å­˜æ˜ å°„å®ç°è¿›ç¨‹é—´é€šä¿¡//1ã€çˆ¶å­è¿›ç¨‹// - è¿˜æ²¡æœ‰å­è¿›ç¨‹çš„æ—¶å€™// - é€šè¿‡å”¯ä¸€çš„çˆ¶è¿›ç¨‹åˆ›å»ºå†…å­˜æ˜ å°„åŒº// - æœ‰äº†å†…å­˜æ˜ å°„åŒºä»¥åå†åˆ›å»ºå­è¿›ç¨‹// - çˆ¶å­è¿›ç¨‹ä¹‹é—´å…±äº«åˆ›å»ºçš„å†…å­˜æ˜ å°„åŒº//2ã€æ²¡æœ‰å…³ç³»çš„è¿›ç¨‹é—´é€šä¿¡// - å‡†å¤‡ä¸€ä¸ªå¤§å°ä¸ä¸º0çš„ç£ç›˜æ–‡ä»¶ // - è¿›ç¨‹1é€šè¿‡ç£ç›˜æ–‡ä»¶åˆ›å»ºå†…å­˜æ˜ å°„åŒº// - å¾—åˆ°ä¸€ä¸ªæ“ä½œè¿™å—å†…å­˜çš„æŒ‡é’ˆ// - è¿›ç¨‹2é€šè¿‡ç£ç›˜æ–‡ä»¶åˆ›å»ºå†…å­˜æ˜ å°„åŒº// - å¾—åˆ°ä¸€ä¸ªæ“ä½œè¿™å—å†…å­˜çš„æŒ‡é’ˆ// - ä½¿ç”¨å†…å­˜æ˜ å°„åŒºè¿›è¡Œé€šä¿¡//æ³¨æ„å†…å­˜æ˜ å°„åŒºé€šä¿¡ä¸ä¼šé˜»å¡#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;wait.h&gt;int main()&#123; //1ã€æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ int fd = open(&quot;test.txt&quot;, O_RDWR); int size = lseek(fd, 0, SEEK_END);//è·å–æ–‡ä»¶çš„å¤§å° //2ã€åˆ›å»ºå†…å­˜æ˜ å°„åŒº void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //3ã€åˆ›å»ºå­è¿›ç¨‹ pid_t pid = fork(); if (pid &gt; 0) &#123; wait(NULL); //çˆ¶è¿›ç¨‹ strcpy((char*)ptr, &quot;hello,child&quot;); &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ char buf[64]; strcpy(buf, (char*)ptr); printf(&quot;read data : %s\\n&quot;, buf); &#125; //å…³é—­å†…å­˜æ˜ å°„åŒº munmap(ptr, size);&#125; è¿è¡Œç»“æœä¸ºï¼š æ€è€ƒé—®é¢˜ å¦‚æœå¯¹mmapçš„è¿”å›å€¼(ptr)åš++æ“ä½œ(ptr++), munmapæ˜¯å¦èƒ½å¤ŸæˆåŠŸ? void* ptr &#x3D; mmap(â€¦); ptr++; å¯ä»¥å¯¹å…¶è¿›è¡Œ++æ“ä½œ munmap(ptr,len); é”™è¯¯ å¦‚æœopenæ—¶O_RDONLY, mmapæ—¶protå‚æ•°æŒ‡å®šPROT_READ | PROT_WRITEä¼šæ€æ ·? é”™è¯¯ï¼Œä¼šè¿”å›MAP_FAILED open()å‡½æ•°ä¸­çš„æƒé™å»ºè®®protå‚æ•°çš„æƒé™ä¿æŒä¸€è‡´ å¦‚æœæ–‡ä»¶åç§»é‡ä¸º1000ä¼šæ€æ ·? åç§»é‡å¿…é¡»æ˜¯4Kçš„æ•´æ•°å€ï¼Œä¸€èˆ¬ä¼šè¿”å›MAP_FAILED mmapä»€ä¹ˆæƒ…å†µä¸‹ä¼šè°ƒç”¨å¤±è´¥? ç¬¬äºŒä¸ªå‚æ•°ï¼šlength &#x3D; 0 ç¬¬ä¸‰ä¸ªå‚æ•°ï¼š prot - åªæŒ‡å®šäº†å†™æƒé™ - prot PROT_READ | PROT_WRITE ç¬¬äº”ä¸ªå‚æ•°fdé€šè¿‡openå‡½æ•°æ—¶æŒ‡å®šçš„O_RDONLY &#x2F; O_WRONLY å¯ä»¥opençš„æ—¶å€™O_CREATä¸€ä¸ªæ–°æ–‡ä»¶æ¥åˆ›å»ºæ˜ å°„åŒºå—ï¼Ÿ å¯ä»¥ï¼Œä½†æ˜¯å¦‚æœåˆ›å»ºçš„æ–‡ä»¶çš„å¤§å°ä¸èƒ½ä¸º0 å¯ä»¥å¯¹æ–°çš„æ–‡ä»¶è¿›è¡Œæ‹“å±• - lseek() - truncate() mmapåå…³é—­æ–‡ä»¶æè¿°ç¬¦ï¼Œå¯¹mmapæ˜ å°„æœ‰æ²¡æœ‰å½±å“ï¼Ÿ int fd &#x3D; open(â€œXXXâ€); mmap(,,,,fd,0); close(fd); æ˜ å°„åŒºè¿˜æ˜¯å­˜åœ¨çš„ï¼Œåˆ›å»ºæ˜ å°„åŒºçš„fdè¢«å…³é—­ï¼Œæ²¡æœ‰ä»»ä½•å½±å“ å¯¹ptrè¶Šç•Œæ“ä½œä¼šæ€æ ·ï¼Ÿ void* ptr &#x3D; mmap(NULL,100,,,); 4K è¶Šç•Œæ“ä½œï¼Œæ“ä½œçš„æ˜¯éæ³•å†…å­˜-&gt;æ®µé”™è¯¯ æ¡ˆä¾‹ï¼šä½¿ç”¨å†…å­˜æ˜ å°„è¿›è¡Œæ–‡ä»¶æ‹·è´1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//ä½¿ç”¨å†…å­˜æ˜ å°„å®ç°æ–‡ä»¶æ‹·è´åŠŸèƒ½//1ã€å¯¹åŸå§‹æ–‡ä»¶è¿›è¡Œå†…å­˜æ˜ å°„//2ã€åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ï¼ˆæ‹“å±•è¯¥æ–‡ä»¶ï¼‰//3ã€æŠŠæ–°æ–‡ä»¶çš„æ•°æ®æ˜ å°„åˆ°å†…å­˜ä¸­//4ã€é€šè¿‡å†…å­˜æ‹·è´å°†ç¬¬ä¸€ä¸ªæ–‡ä»¶çš„å†…å­˜æ•°æ®æ‹·è´åˆ°æ–°çš„æ–‡ä»¶å†…å­˜ä¸­//5ã€é‡Šæ”¾èµ„æº#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main()&#123; //1ã€å¯¹åŸå§‹æ–‡ä»¶è¿›è¡Œå†…å­˜æ˜ å°„ int fd = open(&quot;english.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //è·å–åŸå§‹æ–‡ä»¶çš„å¤§å° int len = lseek(fd, 0, SEEK_END); //2ã€åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ ï¼ˆæ‹“å±•è¯¥æ–‡ä»¶ï¼‰ int fd1 = open(&quot;cpy.txt&quot;, O_RDWR | O_CREAT,0664); if (fd1 == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //å¯¹æ–°åˆ›å»ºçš„æ–‡ä»¶è¿›è¡Œæ‹“å±• truncate(&quot;cpy.txt&quot;, len); write(fd1, &quot; &quot;, 1); //3ã€åˆ†åˆ«åšå†…å­˜æ˜ å°„ void* ptr1 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); void* ptr2 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0); if (ptr1 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; if (ptr2 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //å†…å­˜æ‹·è´ memcpy(ptr2, ptr1, len); //é‡Šæ”¾èµ„æº munmap(ptr1, len); munmap(ptr2, len); close(fd); close(fd1);&#125; æ¡ˆä¾‹ï¼šçˆ¶å­è¿›ç¨‹ä½¿ç”¨åŒ¿åæ˜ å°„é€šä¿¡123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//åŒ¿åæ˜ å°„ï¼šä¸éœ€è¦æ–‡ä»¶å®ä½“#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;wait.h&gt;int main()&#123; //1ã€åˆ›å»ºåŒ¿åå†…å­˜æ˜ å°„åŒº int len = 4096; void* ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //çˆ¶å­é—´è¿›ç¨‹é€šä¿¡ pid_t pid = fork(); if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ strcpy((char*)ptr, &quot;hello,world&quot;); wait(NULL); &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ sleep(1); printf(&quot;%s\\n&quot;, (char*)ptr); &#125; //é‡Šæ”¾å†…å­˜æ˜ å°„åŒº int ret = munmap(ptr, len); if (ret == -1) &#123; perror(&quot;munmap&quot;); exit(0); &#125;&#125; ä¿¡å·æ¦‚è¿°ä¿¡å·çš„æ¦‚å¿µ ä¿¡å·æ˜¯ Linux è¿›ç¨‹é—´é€šä¿¡çš„æœ€å¤è€çš„æ–¹å¼ä¹‹ä¸€ï¼Œæ˜¯äº‹ä»¶å‘ç”Ÿæ—¶å¯¹è¿›ç¨‹çš„é€šçŸ¥æœºåˆ¶ï¼Œæœ‰æ—¶ä¹Ÿç§°ä¹‹ä¸ºè½¯ä»¶ä¸­æ–­ï¼Œå®ƒæ˜¯åœ¨è½¯ä»¶å±‚æ¬¡ä¸Šå¯¹ä¸­æ–­æœºåˆ¶çš„ä¸€ç§æ¨¡æ‹Ÿï¼Œæ˜¯ä¸€ç§å¼‚æ­¥é€šä¿¡çš„æ–¹å¼ã€‚ä¿¡å·å¯ä»¥å¯¼è‡´ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„è¿›ç¨‹è¢«å¦ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„å¼‚æ­¥è¿›ç¨‹ä¸­æ–­ï¼Œè½¬è€Œå¤„ç†æŸä¸€ä¸ªçªå‘äº‹ä»¶ã€‚ å‘å¾€è¿›ç¨‹çš„è¯¸å¤šä¿¡å·ï¼Œé€šå¸¸éƒ½æ˜¯æºäºå†…æ ¸ã€‚å¼•å‘å†…æ ¸ä¸ºè¿›ç¨‹äº§ç”Ÿä¿¡å·çš„å„ç±»äº‹ä»¶å¦‚ä¸‹ï¼š å¯¹äºå‰å°è¿›ç¨‹ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡è¾“å…¥ç‰¹æ®Šçš„ç»ˆç«¯å­—ç¬¦æ¥ç»™å®ƒå‘é€ä¿¡å·ã€‚æ¯”å¦‚è¾“å…¥Ctrl+Cé€šå¸¸ä¼šç»™è¿›ç¨‹å‘é€ä¸€ä¸ªä¸­æ–­ä¿¡å·ã€‚ ç¡¬ä»¶å‘ç”Ÿå¼‚å¸¸ï¼Œå³ç¡¬ä»¶æ£€æµ‹åˆ°ä¸€ä¸ªé”™è¯¯æ¡ä»¶å¹¶é€šçŸ¥å†…æ ¸ï¼Œéšå³å†ç”±å†…æ ¸å‘é€ç›¸åº”ä¿¡å·ç»™ç›¸å…³è¿›ç¨‹ã€‚æ¯”å¦‚æ‰§è¡Œä¸€æ¡å¼‚å¸¸çš„æœºå™¨è¯­è¨€æŒ‡ä»¤ï¼Œè¯¸å¦‚è¢« 0 é™¤ï¼Œæˆ–è€…å¼•ç”¨äº†æ— æ³•è®¿é—®çš„å†…å­˜åŒºåŸŸã€‚ ç³»ç»ŸçŠ¶æ€å˜åŒ–ï¼Œæ¯”å¦‚ alarm å®šæ—¶å™¨åˆ°æœŸå°†å¼•èµ· SIGALRM ä¿¡å·ï¼Œè¿›ç¨‹æ‰§è¡Œçš„ CPUæ—¶é—´è¶…é™ï¼Œæˆ–è€…è¯¥è¿›ç¨‹çš„æŸä¸ªå­è¿›ç¨‹é€€å‡ºã€‚ è¿è¡Œ kill å‘½ä»¤æˆ–è°ƒç”¨ kill å‡½æ•°ã€‚ ä½¿ç”¨ä¿¡å·çš„ä¸¤ä¸ªä¸»è¦ç›®çš„æ˜¯ï¼š è®©è¿›ç¨‹çŸ¥é“å·²ç»å‘ç”Ÿäº†ä¸€ä¸ªç‰¹å®šçš„äº‹æƒ…ã€‚ å¼ºè¿«è¿›ç¨‹æ‰§è¡Œå®ƒè‡ªå·±ä»£ç ä¸­çš„ä¿¡å·å¤„ç†ç¨‹åºã€‚ ä¿¡å·çš„ç‰¹ç‚¹ï¼š ç®€å• ä¸èƒ½æºå¸¦å¤§é‡ä¿¡æ¯ æ»¡è¶³æŸä¸ªç‰¹å®šæ¡ä»¶æ‰å‘é€ ä¼˜å…ˆçº§æ¯”è¾ƒé«˜ æŸ¥çœ‹ç³»ç»Ÿå®šä¹‰çš„ä¿¡å·åˆ—è¡¨ï¼škill -l å‰ 31 ä¸ªä¿¡å·ä¸ºå¸¸è§„ä¿¡å·ï¼Œå…¶ä½™ä¸ºå®æ—¶ä¿¡å· é‡ç‚¹ä¿¡å· ç¼–å· ä¿¡å·åç§° å¯¹åº”äº‹ä»¶ é»˜è®¤åŠ¨ä½œ 2 SIGINT å½“ç”¨æˆ·æŒ‰ä¸‹äº†&lt;Ctrl+C&gt;ç»„åˆé”®æ—¶ï¼Œç”¨æˆ·ç»ˆç«¯å‘æ­£ åœ¨è¿è¡Œä¸­çš„ç”±è¯¥ç»ˆç«¯å¯åŠ¨çš„ç¨‹åºå‘å‡ºæ­¤ä¿¡å· ç»ˆæ­¢è¿›ç¨‹ 3 SIGQUIT ç”¨æˆ·æŒ‰ä¸‹&lt;Ctrl+&gt;ç»„åˆé”®æ—¶äº§ç”Ÿè¯¥ä¿¡å·ï¼Œç”¨æˆ·ç»ˆ ç«¯å‘æ­£åœ¨è¿è¡Œä¸­çš„ç”±è¯¥ç»ˆç«¯å¯åŠ¨çš„ç¨‹åºå‘å‡ºäº›ä¿¡å· ç»ˆæ­¢è¿›ç¨‹ 9 SIGKILL æ— æ¡ä»¶ç»ˆæ­¢è¿›ç¨‹ã€‚è¯¥ä¿¡å·ä¸èƒ½è¢«å¿½ç•¥ï¼Œå¤„ç†å’Œé˜»å¡ ç»ˆæ­¢è¿›ç¨‹ï¼Œå¯ä»¥æ€æ­»ä»»ä½•è¿›ç¨‹ 11 SIGSEGV æŒ‡ç¤ºè¿›ç¨‹è¿›è¡Œäº†æ— æ•ˆå†…å­˜è®¿é—®(æ®µé”™è¯¯) ç»ˆæ­¢è¿›ç¨‹å¹¶äº§ç”Ÿcoreæ–‡ä»¶ 13 SIGPIPE Broken pipeå‘ä¸€ä¸ªæ²¡æœ‰è¯»ç«¯çš„ç®¡é“å†™æ•°æ® ç»ˆæ­¢è¿›ç¨‹ 17 SIGCHLD å­è¿›ç¨‹ç»“æŸæ—¶ï¼Œçˆ¶è¿›ç¨‹ä¼šæ”¶åˆ°è¿™ä¸ªä¿¡å· å¿½ç•¥è¿™ä¸ªä¿¡å· 18 SIGCONT å¦‚æœè¿›ç¨‹å·²åœæ­¢ï¼Œåˆ™ä½¿å…¶ç»§ç»­è¿è¡Œ ç»§ç»­&#x2F;å¿½ç•¥ 19 SIGSTOP åœæ­¢è¿›ç¨‹çš„æ‰§è¡Œã€‚ä¿¡å·ä¸èƒ½è¢«å¿½ç•¥ï¼Œå¤„ç†å’Œé˜»å¡ ä¸ºç»ˆæ­¢è¿›ç¨‹ ä¿¡å·çš„5ç§é»˜è®¤å¤„ç†åŠ¨ä½œ æŸ¥çœ‹ä¿¡å·çš„è¯¦ç»†ä¿¡æ¯ï¼šman 7 signal ä¿¡å·çš„5ç§é»˜è®¤å¤„ç†åŠ¨ä½œ Term ç»ˆæ­¢è¿›ç¨‹ Ign å½“å‰è¿›ç¨‹å¿½ç•¥æ‰è¿™ä¸ªä¿¡å· Core ç»ˆæ­¢è¿›ç¨‹ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªCoreæ–‡ä»¶ Stop æš‚åœå½“å‰è¿›ç¨‹ Cont ç»§ç»­æ‰§è¡Œå½“å‰è¢«æš‚åœçš„è¿›ç¨‹ ä¿¡å·çš„å‡ ç§çŠ¶æ€ï¼šäº§ç”Ÿã€æœªå†³ã€é€’è¾¾ SIGKILLå’ŒSIGSTOPä¿¡å·ä¸èƒ½è¢«æ•æ‰ã€é˜»å¡æˆ–è€…é˜»å¡ï¼Œåªèƒ½æ‰§è¡Œé»˜è®¤åŠ¨ä½œ CoreåŠ¨ä½œ123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* buf; strcpy(buf, &quot;hello&quot;);&#125; æˆ‘ä»¬å»ºç«‹ä¸€ä¸ªcore.cæ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶è‚¯å®šæ˜¯ä¼šè¿è¡Œé”™è¯¯çš„ï¼Œchar* bufæ˜¯ä¸€ä¸ªé‡å†…å­˜ï¼Œæˆ‘ä»¬è®¿é—®è¿™ä¸ªå†…å­˜æ˜¯è¿›è¡Œäº†ä¸€ä¸ªéæ³•æ“ä½œ æˆ‘ä»¬è¿è¡Œ 1ulimit -a æŸ¥çœ‹coreæ–‡ä»¶å¤§å°çš„é™åˆ¶ å¤§å°é™åˆ¶ä¸º0è¡¨ç¤ºä¸ä¼šç”Ÿæˆcoreæ–‡ä»¶ è¿è¡Œ 1ulimit -c 1024 ä¿®æ”¹coreæ–‡ä»¶é™åˆ¶ï¼Œæ­¤æ—¶æˆ‘ä»¬ç¼–è¯‘è¿è¡Œcore.cæ–‡ä»¶ å‘ç°é”™è¯¯ï¼Œå¹¶ä¸”ç”Ÿæˆäº†ä¸€ä¸ªcoreæ–‡ä»¶ï¼Œå¦‚æœæ²¡æœ‰ç”Ÿæˆcoreæ–‡ä»¶ï¼Œå¯èƒ½æ˜¯ç”±äºubuntué¢„è£…äº†apporté”™è¯¯æ”¶é›†ç³»ç»Ÿï¼Œè¿è¡Œå‘½ä»¤ 1sudo service apport stop å†æ¬¡è¿è¡Œï¼Œå‘ç°ç”Ÿæˆäº†ä¸€ä¸ªcoreæ–‡ä»¶ è°ƒè¯•ä¸€ä¸‹a.outç¨‹åº å¯ä»¥çœ‹åˆ°coreæ–‡ä»¶ä¸­çš„é”™è¯¯ä¿¡æ¯ ä¿¡å·ç›¸å…³å‡½æ•°killå‡½æ•°12345678910111213#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;int kill(pid_t pid,int sig);//åŠŸèƒ½ï¼šç»™ä»»ä½•è¿›ç¨‹æˆ–è¿›ç¨‹ç»„ï¼Œå‘é€ä»»ä½•ä¿¡å·sig//å‚æ•°ï¼š// - pidï¼šéœ€è¦å‘é€ç»™çš„è¿›ç¨‹çš„pid// &gt;0ï¼šå°†ä¿¡å·å‘é€ç»™æŒ‡å®šçš„è¿›ç¨‹// =0ï¼šå°†ä¿¡å·å‘é€ç»™å½“å‰çš„è¿›ç¨‹ç»„// =-1ï¼šå°†ä¿¡å·å‘é€ç»™æ¯ä¸€ä¸ªæœ‰æƒé™æ¥å—è¿™ä¸ªä¿¡å·çš„è¿›ç¨‹// &lt;-1ï¼šè¿™ä¸ªpid=æŸä¸ªè¿›ç¨‹ç»„çš„idå–å// - sigï¼šéœ€è¦å‘é€çš„ä¿¡å·æˆ–è€…å®å€¼ï¼Œ0è¡¨ç¤ºä¸å‘é€ä»»ä½•ä¿¡å·kil(getppid(),9);//ç»™çˆ¶è¿›ç¨‹å‘é€ä¸€ä¸ª9å·ä¿¡å·kil(getpid(),9);//ç»™è‡ªå·±å‘é€ä¸€ä¸ª9å·ä¿¡å· raiseå‡½æ•°1234567int raise(int sig);//åŠŸèƒ½ï¼šç»™å½“å‰çš„è¿›ç¨‹å‘é€ä¿¡å·//å‚æ•°ï¼š// - sigï¼šè¦å‘é€çš„ä¿¡å·//è¿”å›å€¼// - æˆåŠŸè¿”å›0// - å¤±è´¥è¿”å› abortå‡½æ•°123void abort(void);//åŠŸèƒ½ï¼šå‘é€SIGABRTä¿¡å·ç»™å½“å‰çš„è¿›ç¨‹ï¼Œæ€æ­»å½“å‰è¿›ç¨‹kill(getpid,SIGABRT); æ¡ˆä¾‹123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;int main()&#123; pid_t pid = fork(); if (pid == 0) &#123; //å­è¿›ç¨‹ int i = 0; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;chile process\\n&quot;); sleep(1); &#125; &#125; else if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); kill(pid, SIGINT); &#125;&#125; ç¼–è¯‘è¿è¡Œ 12345678910#include&lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);//åŠŸèƒ½ï¼šè®¾ç½®å®šæ—¶å™¨ï¼ˆé—¹é’Ÿï¼‰ï¼Œå‡½æ•°è°ƒç”¨å¼€å§‹å€’è®¡æ—¶ï¼Œå½“å€’è®¡æ—¶ä¸º0çš„æ—¶å€™ï¼Œå‡½æ•°ä¼šç»™å½“å‰çš„è¿›ç¨‹å‘é€ä¸€ä¸ªä¿¡å·ï¼šSIGALARM//å‚æ•°ï¼š// - secondsï¼šå€’è®¡æ—¶çš„æ—¶é•¿ï¼Œå•ä½ï¼šç§’ã€‚å¦‚æœå‚æ•°ä¸º0ï¼Œå®šæ—¶å™¨æ— æ•ˆï¼ˆä¸è¿›è¡Œå€’è®¡æ—¶ï¼Œä¸å‘é€ä¿¡å·ï¼‰// å–æ¶ˆä¸€ä¸ªå®šæ—¶å™¨ï¼Œé€šè¿‡alarm(0);//è¿”å›å€¼ï¼š// - ä¹‹å‰æ²¡æœ‰å®šæ—¶å™¨ï¼Œè¿”å›0// - ä¹‹å‰æœ‰å®šæ—¶å™¨ï¼Œè¿”å›ä¹‹å‰çš„å®šæ—¶å™¨å‰©ä½™çš„æ—¶é—´//- SIGALARMï¼šé»˜è®¤ç»ˆæ­¢å½“å‰çš„è¿›ç¨‹ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸”åªæœ‰å”¯ä¸€çš„ä¸€ä¸ªå®šæ—¶å™¨ æ¡ˆä¾‹1 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;int main()&#123; pid_t pid = fork(); if (pid == 0) &#123; //å­è¿›ç¨‹ int i = 0; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;chile process\\n&quot;); sleep(1); &#125; &#125; else if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); kill(pid, SIGINT); &#125;&#125; è¿è¡Œç»“æœä¸ºï¼š æ¡ˆä¾‹2 è®¡ç®—ä¸€ç§’é’Ÿç”µè„‘èƒ½æ•°å¤šå°‘ä¸ªæ•° 123456789101112#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; alarm(1); int i = 0; while (1) &#123; printf(&quot;%d\\n&quot;, i++); &#125;&#125; è¿è¡Œç»“æœä¸ºï¼š å¯ä»¥è¿è¡Œå‘½ä»¤ 1./alarm1 &gt;&gt;a.txt å°†æ­¤æ–‡ä»¶çš„è¾“å‡ºç»“æœæ”¾åˆ°a.txtä¸­ å®é™…æ—¶é—´ &#x3D; å†…æ ¸æ—¶é—´ + ç”¨æˆ·æ—¶é—´ +æ¶ˆè€—çš„æ—¶é—´ è¿›è¡Œæ–‡ä»¶IOæ“ä½œæ¯”è¾ƒæµªè´¹æ—¶é—´ å®šæ—¶å™¨ä¸è¿›ç¨‹çš„çŠ¶æ€æ— å…³ï¼ˆè‡ªç„¶å®šæ—¶æ³•ï¼‰ã€‚æ— è®ºè¿›ç¨‹å¤„äºä»€ä¹ˆçŠ¶æ€ï¼Œalarméƒ½ä¼šè®¡æ—¶ setitimerå®šæ—¶å™¨å‡½æ•°12345678910111213141516171819202122232425#include&lt;sys/time.h&gt;int setitimer(int which, const struct itimerval* new_value, struct itimerval* old_value);//åŠŸèƒ½ï¼šè®¾ç½®å®šæ—¶å™¨ï¼ˆé—¹é’Ÿï¼‰ã€‚å¯ä»¥æ›¿ä»£alarmå‡½æ•°ã€‚ç²¾åº¦å¾®å¦™usï¼Œå®ç°å‘¨æœŸæ€§å®šæ—¶//å‚æ•°// - which:å®šæ—¶å™¨ä»¥ä»€ä¹ˆæ—¶é—´è®¡æ—¶// ITIMER_REALï¼šçœŸå®æ—¶é—´ï¼Œæ—¶é—´åˆ°è¾¾ï¼Œå‘é€SIGALARMä¿¡å·ï¼Œå¸¸ç”¨// ITIMER_VIRTUALï¼šç”¨æˆ·æ—¶é—´ï¼Œæ—¶é—´åˆ°è¾¾ï¼Œå‘é€SIGVTALRMä¿¡å·// ITIMER_PROFï¼šä»¥è¯¥è¿›ç¨‹åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¸‹æ‰€æ¶ˆè€—çš„æ—¶é—´æ¥è®¡ç®—ï¼Œæ—¶é—´åˆ°è¾¾å‘é€SIGPROFä¿¡å·// - new_calue:è®¾ç½®å®šæ—¶å™¨çš„å±æ€§// struct itimerval &#123; //å®šæ—¶å™¨ç»“æ„ä½“// struct timeval it_interval; /* Interval for periodic timer */ //æ¯ä¸ªé—´æ–­çš„æ—¶é—´// struct timeval it_value; /* Time until next expiration */ //å»¶è¿Ÿå¤šé•¿æ—¶é—´æ‰§è¡Œå®šæ—¶å™¨// &#125;;// struct timeval &#123; //æ—¶é—´çš„ç»“æ„ä½“// time_t tv_sec; /* seconds */ //ç§’æ•°// suseconds_t tv_usec; /* microseconds */ //å¾®ç§’// &#125;;// è¿‡10ç§’åæ¯ä¸ªä¸¤ç§’å®šæ—¶ä¸€æ¬¡// - old_valueï¼šè®°å½•ä¸Šä¸€æ¬¡çš„å®šæ—¶çš„æ—¶é—´å‚æ•°ï¼ŒæŒ‡å®šNULL//è¿”å›å€¼ï¼š// - æˆåŠŸè¿”å›0// - é”™è¯¯è¿”å›-1å¹¶è®¾ç½®é”™è¯¯å· æ¡ˆä¾‹ 123456789101112131415161718192021222324#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//è¿‡ä¸‰ç§’ä»¥åæ¯ä¸ªä¸¤ç§’å®šæ—¶ä¸€æ¬¡int main()&#123; struct itimerval new_value; //è®¾ç½®é—´éš”æ—¶é—´å€¼ new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //è®¾ç½®å»¶è¿Ÿçš„æ—¶é—´ new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL);//éé˜»å¡çš„ printf(&quot;å®šæ—¶å™¨å¼€å§‹äº†.....\\n&quot;); if (ret == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; ç¼–è¯‘è¿è¡Œ signalä¿¡å·æ•æ‰å‡½æ•°123456789101112131415161718#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);//ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆsighandler_t signal(int signum, sighandler_t handler);//åŠŸèƒ½ï¼šè®¾ç½®æŸä¸ªä¿¡å·çš„æ•æ‰è¡Œä¸º//å‚æ•°ï¼š// - signumï¼šè¦æ•æ‰çš„ä¿¡å·// - handlerï¼šæ•æ‰åˆ°ä¿¡å·è¦å¦‚ä½•å¤„ç†// - SIG_IGNï¼šå¿½ç•¥ä¿¡å·// - SIG_DFLï¼šä½¿ç”¨ä¿¡å·é»˜è®¤è¡Œä¸º// - å›è°ƒå‡½æ•°ï¼šè¿™ä¸ªå‡½æ•°æ˜¯å†…æ ¸è°ƒç”¨ï¼Œç¨‹åºå‘˜åªè´Ÿè´£å†™ï¼Œæ•æ‰åˆ°ä¿¡å·åå¦‚ä½•å¤„ç†ä¿¡å·// - å›è°ƒå‡½æ•°éœ€è¦ç¨‹åºå‘˜å®ç°å¹¶ä¸”æå‰å‡†å¤‡å¥½ï¼Œå‡½æ•°çš„ç±»å‹æ ¹æ®å®é™…éœ€æ±‚ï¼Œä¸€èˆ¬çœ‹å‡½æ•°æŒ‡é’ˆçš„å®šä¹‰// - ä¸æ˜¯ç¨‹åºå‘˜è°ƒç”¨ï¼Œè€Œæ˜¯å½“ä¿¡å·äº§ç”Ÿï¼Œå†…æ ¸è°ƒç”¨// - å‡½æ•°æŒ‡é’ˆæ˜¯å®ç°å›è°ƒçš„æ‰‹æ®µï¼Œå‡½æ•°å®ç°ä¹‹åï¼Œå°†å‡½æ•°åæ”¾åˆ°å‡½æ•°æŒ‡é’ˆçš„ä½ç½®//è¿”å›å€¼ï¼š// - æˆåŠŸï¼šè¿”å›ä¸Šä¸€æ¬¡æ³¨å†Œçš„ä¿¡å·å¤„ç†å‡½æ•°çš„åœ°å€ï¼Œç¬¬ä¸€æ¬¡è°ƒç”¨è¿”å›NULL// - å¤±è´¥ï¼šè¿”å›SIG_ERRï¼Œè®¾ç½®é”™è¯¯å·//SIGKILLå’ŒSIGSTOPä¸èƒ½è¢«æ•æ‰ä¸èƒ½è¢«å¿½ç•¥ æ¡ˆä¾‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;//è¿‡ä¸‰ç§’ä»¥åæ¯ä¸ªä¸¤ç§’å®šæ—¶ä¸€æ¬¡void myalarm(int num)&#123; printf(&quot;æ•æ‰åˆ°çš„ä¿¡å·çš„ç¼–å·æ˜¯%d\\n&quot;, num); printf(&quot;---------------------------\\n&quot;);&#125;int main()&#123; //æ³¨å†Œä¿¡å·æ•æ‰ //signal(SIGALRM,SIG_DFL) //signal(SIGALRM, SIG_DFL); __sighandler_t ret = signal(SIGALRM, myalarm); if (ret == SIG_ERR) &#123; perror(&quot;signal&quot;); exit(0); &#125; struct itimerval new_value; //è®¾ç½®é—´éš”æ—¶é—´å€¼ new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //è®¾ç½®å»¶è¿Ÿçš„æ—¶é—´ new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret1 = setitimer(ITIMER_REAL, &amp;new_value, NULL);//éé˜»å¡çš„ printf(&quot;å®šæ—¶å™¨å¼€å§‹äº†.....\\n&quot;); if (ret1 == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; ç¼–è¯‘è¿è¡Œ ä¿¡å·é›†åŠå…¶ç›¸å…³å‡½æ•° è®¸å¤šä¿¡å·ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨éƒ½éœ€è¦èƒ½è¡¨ç¤ºä¸€ç»„ä¸åŒçš„ä¿¡å·ï¼Œå¤šä¸ªä¿¡å·å¯ä½¿ç”¨ä¸€ä¸ªç§°ä¹‹ä¸ºä¿¡å·é›†çš„æ•°æ®ç»“æ„æ¥è¡¨ç¤ºï¼Œå…¶ç³»ç»Ÿæ•°æ®ç±»å‹ä¸º sigset_tã€‚ åœ¨ PCB ä¸­æœ‰ä¸¤ä¸ªéå¸¸é‡è¦çš„ä¿¡å·é›†ã€‚ä¸€ä¸ªç§°ä¹‹ä¸º â€œé˜»å¡ä¿¡å·é›†â€ ï¼Œå¦ä¸€ä¸ªç§°ä¹‹ä¸ºâ€œæœªå†³ä¿¡å·é›†â€ ã€‚è¿™ä¸¤ä¸ªä¿¡å·é›†éƒ½æ˜¯å†…æ ¸ä½¿ç”¨ä½å›¾æœºåˆ¶æ¥å®ç°çš„ã€‚ä½†æ“ä½œç³»ç»Ÿä¸å…è®¸æˆ‘ä»¬ç›´æ¥å¯¹è¿™ä¸¤ä¸ªä¿¡å·é›†è¿›è¡Œä½æ“ä½œã€‚è€Œéœ€è‡ªå®šä¹‰å¦å¤–ä¸€ä¸ªé›†åˆï¼Œå€ŸåŠ©ä¿¡å·é›†æ“ä½œå‡½æ•°æ¥å¯¹ PCB ä¸­çš„è¿™ä¸¤ä¸ªä¿¡å·é›†è¿›è¡Œä¿®æ”¹ã€‚ ä¿¡å·çš„ â€œæœªå†³â€ æ˜¯ä¸€ç§çŠ¶æ€ï¼ŒæŒ‡çš„æ˜¯ä»ä¿¡å·çš„äº§ç”Ÿåˆ°ä¿¡å·è¢«å¤„ç†å‰çš„è¿™ä¸€æ®µæ—¶é—´ã€‚ ä¿¡å·çš„ â€œé˜»å¡â€ æ˜¯ä¸€ä¸ªå¼€å…³åŠ¨ä½œï¼ŒæŒ‡çš„æ˜¯é˜»æ­¢ä¿¡å·è¢«å¤„ç†ï¼Œä½†ä¸æ˜¯é˜»æ­¢ä¿¡å·äº§ç”Ÿã€‚ ä¿¡å·çš„é˜»å¡å°±æ˜¯è®©ç³»ç»Ÿæš‚æ—¶ä¿ç•™ä¿¡å·ç•™å¾…ä»¥åå‘é€ã€‚ç”±äºå¦å¤–æœ‰åŠæ³•è®©ç³»ç»Ÿå¿½ç•¥ä¿¡å·ï¼Œæ‰€ä»¥ä¸€èˆ¬æƒ…å†µä¸‹ä¿¡å·çš„é˜»å¡åªæ˜¯æš‚æ—¶çš„ï¼Œåªæ˜¯ä¸ºäº†é˜²æ­¢ä¿¡å·æ‰“æ–­æ•æ„Ÿçš„æ“ä½œã€‚ é˜»å¡ä¿¡å·é›†å’Œæœªå†³ä¿¡å·é›† 1.ç”¨æˆ·é€šè¿‡é”®ç›˜ Ctrl + C, äº§ç”Ÿ2å·ä¿¡å·SIGINT (ä¿¡å·è¢«åˆ›å»º) 2.ä¿¡å·äº§ç”Ÿä½†æ˜¯æ²¡æœ‰è¢«å¤„ç† ï¼ˆæœªå†³ï¼‰ - åœ¨å†…æ ¸ä¸­å°†æ‰€æœ‰çš„æ²¡æœ‰è¢«å¤„ç†çš„ä¿¡å·å­˜å‚¨åœ¨ä¸€ä¸ªé›†åˆä¸­ ï¼ˆæœªå†³ä¿¡å·é›†ï¼‰ - SIGINTä¿¡å·çŠ¶æ€è¢«å­˜å‚¨åœ¨ç¬¬äºŒä¸ªæ ‡å¿—ä½ä¸Š - è¿™ä¸ªæ ‡å¿—ä½çš„å€¼ä¸º0ï¼Œ è¯´æ˜ä¿¡å·ä¸æ˜¯æœªå†³çŠ¶æ€ - è¿™ä¸ªæ ‡å¿—ä½çš„å€¼ä¸º1ï¼Œ è¯´æ˜ä¿¡å·å¤„äºæœªå†³çŠ¶æ€ 3.è¿™ä¸ªæœªå†³çŠ¶æ€çš„ä¿¡å·ï¼Œéœ€è¦è¢«å¤„ç†ï¼Œå¤„ç†ä¹‹å‰éœ€è¦å’Œå¦ä¸€ä¸ªä¿¡å·é›†ï¼ˆé˜»å¡ä¿¡å·é›†ï¼‰ï¼Œè¿›è¡Œæ¯”è¾ƒ - é˜»å¡ä¿¡å·é›†é»˜è®¤ä¸é˜»å¡ä»»ä½•çš„ä¿¡å· - å¦‚æœæƒ³è¦é˜»å¡æŸäº›ä¿¡å·éœ€è¦ç”¨æˆ·è°ƒç”¨ç³»ç»Ÿçš„API 4.åœ¨å¤„ç†çš„æ—¶å€™å’Œé˜»å¡ä¿¡å·é›†ä¸­çš„æ ‡å¿—ä½è¿›è¡ŒæŸ¥è¯¢ï¼Œçœ‹æ˜¯ä¸æ˜¯å¯¹è¯¥ä¿¡å·è®¾ç½®é˜»å¡äº† - å¦‚æœæ²¡æœ‰é˜»å¡ï¼Œè¿™ä¸ªä¿¡å·å°±è¢«å¤„ç† - å¦‚æœé˜»å¡äº†ï¼Œè¿™ä¸ªä¿¡å·å°±ç»§ç»­å¤„äºæœªå†³çŠ¶æ€ï¼Œç›´åˆ°é˜»å¡è§£é™¤ï¼Œè¿™ä¸ªä¿¡å·å°±è¢«å¤„ç† ä¿¡å·é›†å‡½æ•°è‡ªå®šä¹‰ä¿¡å·é›†å‡½æ•°123456789101112131415161718192021222324252627282930313233int sigemptyset(sigset_t *set);// - åŠŸèƒ½ï¼šæ¸…ç©ºä¿¡å·é›†ä¸­çš„æ•°æ®,å°†ä¿¡å·é›†ä¸­çš„æ‰€æœ‰çš„æ ‡å¿—ä½ç½®ä¸º0// - å‚æ•°ï¼šset,ä¼ å‡ºå‚æ•°ï¼Œéœ€è¦æ“ä½œçš„ä¿¡å·é›†// - è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œ å¤±è´¥è¿”å›-1int sigfillset(sigset_t *set);// - åŠŸèƒ½ï¼šå°†ä¿¡å·é›†ä¸­çš„æ‰€æœ‰çš„æ ‡å¿—ä½ç½®ä¸º1// - å‚æ•°ï¼šset,ä¼ å‡ºå‚æ•°ï¼Œéœ€è¦æ“ä½œçš„ä¿¡å·é›†// - è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œ å¤±è´¥è¿”å›-1int sigaddset(sigset_t *set, int signum);// - åŠŸèƒ½ï¼šè®¾ç½®ä¿¡å·é›†ä¸­çš„æŸä¸€ä¸ªä¿¡å·å¯¹åº”çš„æ ‡å¿—ä½ä¸º1ï¼Œè¡¨ç¤ºé˜»å¡è¿™ä¸ªä¿¡å·// - å‚æ•°ï¼š// - setï¼šä¼ å‡ºå‚æ•°ï¼Œéœ€è¦æ“ä½œçš„ä¿¡å·é›†// - signumï¼šéœ€è¦è®¾ç½®é˜»å¡çš„é‚£ä¸ªä¿¡å·// - è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œ å¤±è´¥è¿”å›-1int sigdelset(sigset_t *set, int signum);// - åŠŸèƒ½ï¼šè®¾ç½®ä¿¡å·é›†ä¸­çš„æŸä¸€ä¸ªä¿¡å·å¯¹åº”çš„æ ‡å¿—ä½ä¸º0ï¼Œè¡¨ç¤ºä¸é˜»å¡è¿™ä¸ªä¿¡å·// - å‚æ•°ï¼š// - setï¼šä¼ å‡ºå‚æ•°ï¼Œéœ€è¦æ“ä½œçš„ä¿¡å·é›†// - signumï¼šéœ€è¦è®¾ç½®ä¸é˜»å¡çš„é‚£ä¸ªä¿¡å·// - è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œ å¤±è´¥è¿”å›-1int sigismember(const sigset_t *set, int signum);// - åŠŸèƒ½ï¼šåˆ¤æ–­æŸä¸ªä¿¡å·æ˜¯å¦é˜»å¡// - å‚æ•°ï¼š// - setï¼šéœ€è¦æ“ä½œçš„ä¿¡å·é›†// - signumï¼šéœ€è¦åˆ¤æ–­çš„é‚£ä¸ªä¿¡å·// - è¿”å›å€¼ï¼š// 1 ï¼š signumè¢«é˜»å¡// 0 ï¼š signumä¸é˜»å¡// -1 ï¼š å¤±è´¥ æ¡ˆä¾‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;signal.h&gt;#include&lt;stdio.h&gt;int main()&#123; //åˆ›å»ºä¸€ä¸ªä¿¡å·é›† sigset_t set; //æ¸…ç©ºä¿¡å·é›†çš„å†…å®¹ sigemptyset(&amp;set); //åˆ¤æ–­SIGINTæ˜¯å¦åœ¨seté‡Œé¢ int ret = sigismember(&amp;set, SIGINT); if (ret == 0) &#123; printf(&quot;SIGINTä¸é˜»å¡\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGINTé˜»å¡\\n&quot;); &#125; //æ·»åŠ å‡ ä¸ªä¿¡å·åˆ°ä¿¡å·é›†ä¸­ sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); //åˆ¤æ–­SIGINTæ˜¯å¦åœ¨ä¿¡å·é›†ä¸­ ret = sigismember(&amp;set, SIGINT); if (ret == 0) &#123; printf(&quot;SIGINTä¸é˜»å¡\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGINTé˜»å¡\\n&quot;); &#125; //åˆ¤æ–­SIGQUITæ˜¯å¦åœ¨ä¿¡å·é›†ä¸­ ret = sigismember(&amp;set, SIGQUIT); if (ret == 0) &#123; printf(&quot;SIGQUITä¸é˜»å¡\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGQUITé˜»å¡\\n&quot;); &#125; //ä»ä¿¡å·é›†ä¸­åˆ é™¤ä¸€ä¸ªä¿¡å· sigdelset(&amp;set, SIGQUIT); //åˆ¤æ–­SIGQUITæ˜¯å¦åœ¨ä¿¡å·é›†ä¸­ ret = sigismember(&amp;set, SIGQUIT); if (ret == 0) &#123; printf(&quot;SIGQUITä¸é˜»å¡\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGQUITé˜»å¡\\n&quot;); &#125;&#125; ç¼–è¯‘è¿è¡Œ ç³»ç»Ÿä¿¡å·é›†å‡½æ•°1234567891011121314151617181920int sigprocmask(int how, const sigset_t* set, sigset_t* oldset);// -åŠŸèƒ½ï¼šå°†è‡ªå®šä¹‰ä¿¡å·é›†ä¸­çš„æ•°æ®è®¾ç½®åˆ°å†…æ ¸ä¸­ï¼ˆè®¾ç½®é˜»å¡ï¼Œè§£é™¤é˜»å¡ï¼Œæ›¿æ¢ï¼‰// - å‚æ•°ï¼š// - how : å¦‚ä½•å¯¹å†…æ ¸é˜»å¡ä¿¡å·é›†è¿›è¡Œå¤„ç†// SIG_BLOCK : å°†ç”¨æˆ·è®¾ç½®çš„é˜»å¡ä¿¡å·é›†æ·»åŠ åˆ°å†…æ ¸ä¸­ï¼Œå†…æ ¸ä¸­åŸæ¥çš„æ•°æ®ä¸å˜// å‡è®¾å†…æ ¸ä¸­é»˜è®¤çš„é˜»å¡ä¿¡å·é›†æ˜¯maskï¼Œ mask | set// SIG_UNBLOCK : æ ¹æ®ç”¨æˆ·è®¾ç½®çš„æ•°æ®ï¼Œå¯¹å†…æ ¸ä¸­çš„æ•°æ®è¿›è¡Œè§£é™¤é˜»å¡// mask &amp;= ~set// SIG_SETMASK : è¦†ç›–å†…æ ¸ä¸­åŸæ¥çš„å€¼// - set ï¼šå·²ç»åˆå§‹åŒ–å¥½çš„ç”¨æˆ·è‡ªå®šä¹‰çš„ä¿¡å·é›†// - oldset : ä¿å­˜è®¾ç½®ä¹‹å‰çš„å†…æ ¸ä¸­çš„é˜»å¡ä¿¡å·é›†çš„çŠ¶æ€ï¼Œå¯ä»¥æ˜¯ NULL// - è¿”å›å€¼ï¼š// æˆåŠŸï¼š0// å¤±è´¥ï¼š - 1// è®¾ç½®é”™è¯¯å·ï¼šEFAULTã€EINVALint sigpending(sigset_t * set);// - åŠŸèƒ½ï¼šè·å–å†…æ ¸ä¸­çš„æœªå†³ä¿¡å·é›†// - å‚æ•°ï¼šset, ä¼ å‡ºå‚æ•°ï¼Œä¿å­˜çš„æ˜¯å†…æ ¸ä¸­çš„æœªå†³ä¿¡å·é›†ä¸­çš„ä¿¡æ¯ã€‚ æ¡ˆä¾‹ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//ç¼–å†™ä¸€ä¸ªç¨‹åºï¼ŒæŠŠæ‰€æœ‰çš„å¸¸è§„ä¿¡å·ï¼ˆ1 - 31ï¼‰çš„æœªå†³çŠ¶æ€æ‰“å°åˆ°å±å¹•//è®¾ç½®æŸäº›ä¿¡å·æ˜¯é˜»å¡çš„ï¼Œé€šè¿‡é”®ç›˜äº§ç”Ÿè¿™äº›ä¿¡å·#include&lt;stdio.h&gt;#include&lt;signal.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main()&#123; //è®¾ç½®2ã€3å·ä¿¡å·é˜»å¡ sigset_t set; sigemptyset(&amp;set); //å°†2å·å’Œ3å·ä¿¡å·æ·»åŠ åˆ°ä¿¡å·é›†ä¸­ sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); //ä¿®æ”¹å†…æ ¸ä¸­çš„é˜»å¡ä¿¡å·é›† sigprocmask(SIG_BLOCK, &amp;set, NULL); while (1) &#123; //è·å–å½“å‰çš„æœªå†³ä¿¡å·é›†çš„æ•°æ® sigset_t pendingset; sigemptyset(&amp;pendingset); sigpending(&amp;pendingset); //éå†å‰32ä½ for (int i = 1;i &lt;= 32;i++) &#123; if (sigismember(&amp;pendingset, i) == 1) &#123; printf(&quot;1&quot;); &#125; else if (sigismember(&amp;pendingset, i) == 0) &#123; printf(&quot;0&quot;); &#125; else &#123; perror(&quot;sigismember&quot;); exit(0); &#125; &#125; printf(&quot;\\n&quot;); sleep(1); &#125;&#125; ç¼–è¯‘è¿è¡Œ sigactionä¿¡å·æ•æ‰å‡½æ•°1234567891011121314151617181920212223242526#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction* act, struct sigaction* oldact);// -åŠŸèƒ½ï¼šæ£€æŸ¥æˆ–è€…æ”¹å˜ä¿¡å·çš„å¤„ç†ã€‚ä¿¡å·æ•æ‰// - å‚æ•°ï¼š// - signum : éœ€è¦æ•æ‰çš„ä¿¡å·çš„ç¼–å·æˆ–è€…å®å€¼ï¼ˆä¿¡å·çš„åç§°ï¼‰// - act ï¼šæ•æ‰åˆ°ä¿¡å·ä¹‹åçš„å¤„ç†åŠ¨ä½œ// - oldact : ä¸Šä¸€æ¬¡å¯¹ä¿¡å·æ•æ‰ç›¸å…³çš„è®¾ç½®ï¼Œä¸€èˆ¬ä¸ä½¿ç”¨ï¼Œä¼ é€’NULL// - è¿”å›å€¼ï¼š// æˆåŠŸ 0// å¤±è´¥ - 1struct sigaction &#123; // å‡½æ•°æŒ‡é’ˆï¼ŒæŒ‡å‘çš„å‡½æ•°å°±æ˜¯ä¿¡å·æ•æ‰åˆ°ä¹‹åçš„å¤„ç†å‡½æ•° void (*sa_handler)(int); // ä¸å¸¸ç”¨ void (*sa_sigaction)(int, siginfo_t*, void*); // ä¸´æ—¶é˜»å¡ä¿¡å·é›†ï¼Œåœ¨ä¿¡å·æ•æ‰å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œä¸´æ—¶é˜»å¡æŸäº›ä¿¡å·ã€‚ sigset_t sa_mask; // ä½¿ç”¨å“ªä¸€ä¸ªä¿¡å·å¤„ç†å¯¹æ•æ‰åˆ°çš„ä¿¡å·è¿›è¡Œå¤„ç† // è¿™ä¸ªå€¼å¯ä»¥æ˜¯0ï¼Œè¡¨ç¤ºä½¿ç”¨sa_handler,ä¹Ÿå¯ä»¥æ˜¯SA_SIGINFOè¡¨ç¤ºä½¿ç”¨sa_sigaction int sa_flags; // è¢«åºŸå¼ƒæ‰äº† void (*sa_restorer)(void);&#125;; æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;//è¿‡ä¸‰ç§’ä»¥åæ¯ä¸ªä¸¤ç§’å®šæ—¶ä¸€æ¬¡void myalarm(int num)&#123; printf(&quot;æ•æ‰åˆ°çš„ä¿¡å·çš„ç¼–å·æ˜¯%d\\n&quot;, num); printf(&quot;---------------------------\\n&quot;);&#125;int main()&#123; struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; sigemptyset(&amp;act.sa_mask);//æ¸…ç©ºä¸´æ—¶é˜»å¡ä¿¡å·é›† sigaction(SIGALRM, &amp;act, NULL); struct itimerval new_value; //è®¾ç½®é—´éš”æ—¶é—´å€¼ new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //è®¾ç½®å»¶è¿Ÿçš„æ—¶é—´ new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret1 = setitimer(ITIMER_REAL, &amp;new_value, NULL);//éé˜»å¡çš„ printf(&quot;å®šæ—¶å™¨å¼€å§‹äº†.....\\n&quot;); if (ret1 == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; ç¼–è¯‘è¿è¡Œï¼š å†…æ ¸ä¿¡å·è¢«æ•æ‰çš„è¿‡ç¨‹ SIGCHIDä¿¡å· SIGCHLDä¿¡å·äº§ç”Ÿçš„æ¡ä»¶ï° å­è¿›ç¨‹ç»ˆæ­¢æ—¶ï° å­è¿›ç¨‹æ¥æ”¶åˆ° SIGSTOP ä¿¡å·åœæ­¢æ—¶ï° å­è¿›ç¨‹å¤„åœ¨åœæ­¢æ€ï¼Œæ¥å—åˆ°SIGCONTåå”¤é†’æ—¶ ä»¥ä¸Šä¸‰ç§æ¡ä»¶éƒ½ä¼šç»™çˆ¶è¿›ç¨‹å‘é€ SIGCHLD ä¿¡å·ï¼Œçˆ¶è¿›ç¨‹é»˜è®¤ä¼šå¿½ç•¥è¯¥ä¿¡å· æ¡ˆä¾‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;signal.h&gt;#include&lt;wait.h&gt;void myFun(int num)&#123; printf(&quot;æ•æ‰åˆ°çš„ä¿¡å·:%d\\n&quot;, num); //å›æ”¶å­è¿›ç¨‹PCBçš„èµ„æº while (1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if (ret &gt; 0) &#123; printf(&quot;child die , pid = %d \\n&quot;, ret); &#125; else if (ret == 0) &#123; //è¯´æ˜è¿˜æœ‰å­è¿›ç¨‹æ´»ç€ break; &#125; &#125;&#125;int main()&#123; //æå‰è®¾ç½®å¥½é˜»å¡ä¿¡å·é›†ï¼Œé˜»å¡SIGCHLDï¼Œå› ä¸ºå¯èƒ½å­è¿›ç¨‹å¾ˆå¿«ç»“æŸï¼Œçˆ¶è¿›ç¨‹è¿˜æ²¡æœ‰æ³¨å†Œå®Œä¿¡å·æ•æ‰ sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;set, NULL); pid_t pid; for (int i = 0;i &lt; 20;i++) &#123; pid = fork(); if (pid == 0) &#123; break; &#125; &#125; if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ //æ•æ‰å­è¿›ç¨‹æ­»äº¡æ—¶å‘é€çš„SIGCHLDä¿¡å· struct sigaction act; act.sa_flags = 0; act.sa_handler = myFun; sigemptyset(&amp;act.sa_mask); sigaction(SIGCHLD, &amp;act, NULL); //æ³¨å†Œå®Œä¿¡å·æ•æ‰ä»¥åï¼Œè§£é™¤é˜»å¡ sigprocmask(SIG_UNBLOCK, &amp;set, NULL); while (1) &#123; printf(&quot;parent process pid : %d\\n&quot;, getpid()); sleep(2); &#125; &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ printf(&quot;child process pid : %d\\n&quot;, getpid()); &#125;&#125; ç¼–è¯‘è¿è¡Œ å…±äº«å†…å­˜ å…±äº«å†…å­˜å…è®¸ä¸¤ä¸ªæˆ–è€…å¤šä¸ªè¿›ç¨‹å…±äº«ç‰©ç†å†…å­˜çš„åŒä¸€å—åŒºåŸŸï¼ˆé€šå¸¸è¢«ç§°ä¸ºæ®µï¼‰ã€‚ç”±äºä¸€ä¸ªå…±äº«å†…å­˜æ®µä¼šç§°ä¸ºä¸€ä¸ªè¿›ç¨‹ç”¨æˆ·ç©ºé—´çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤è¿™ç§ IPC æœºåˆ¶æ— éœ€å†…æ ¸ä»‹å…¥ã€‚æ‰€æœ‰éœ€è¦åšçš„å°±æ˜¯è®©ä¸€ä¸ªè¿›ç¨‹å°†æ•°æ®å¤åˆ¶è¿›å…±äº«å†…å­˜ä¸­ï¼Œå¹¶ä¸”è¿™éƒ¨åˆ†æ•°æ®ä¼šå¯¹å…¶ä»–æ‰€æœ‰å…±äº«åŒä¸€ä¸ªæ®µçš„è¿›ç¨‹å¯ç”¨ã€‚ ä¸ç®¡é“ç­‰è¦æ±‚å‘é€è¿›ç¨‹å°†æ•°æ®ä»ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºå¤åˆ¶è¿›å†…æ ¸å†…å­˜å’Œæ¥æ”¶è¿›ç¨‹å°†æ•°æ®ä»å†…æ ¸å†…å­˜å¤åˆ¶è¿›ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºçš„åšæ³•ç›¸æ¯”ï¼Œè¿™ç§ IPC æŠ€æœ¯çš„é€Ÿåº¦æ›´å¿«ã€‚ å…±äº«å†…å­˜ä½¿ç”¨æ­¥éª¤ è°ƒç”¨ shmget() åˆ›å»ºä¸€ä¸ªæ–°å…±äº«å†…å­˜æ®µæˆ–å–å¾—ä¸€ä¸ªæ—¢æœ‰å…±äº«å†…å­˜æ®µçš„æ ‡è¯†ç¬¦ï¼ˆå³ç”±å…¶ä»–è¿›ç¨‹åˆ›å»ºçš„å…±äº«å†…å­˜æ®µï¼‰ã€‚è¿™ä¸ªè°ƒç”¨å°†è¿”å›åç»­è°ƒç”¨ä¸­éœ€è¦ç”¨åˆ°çš„å…±äº«å†…å­˜æ ‡è¯†ç¬¦ã€‚ ä½¿ç”¨ shmat() æ¥é™„ä¸Šå…±äº«å†…å­˜æ®µï¼Œå³ä½¿è¯¥æ®µæˆä¸ºè°ƒç”¨è¿›ç¨‹çš„è™šæ‹Ÿå†…å­˜çš„ä¸€éƒ¨åˆ†ã€‚ æ­¤åˆ»åœ¨ç¨‹åºä¸­å¯ä»¥åƒå¯¹å¾…å…¶ä»–å¯ç”¨å†…å­˜é‚£æ ·å¯¹å¾…è¿™ä¸ªå…±äº«å†…å­˜æ®µã€‚ä¸ºå¼•ç”¨è¿™å—å…±äº«å†…å­˜ï¼Œç¨‹åºéœ€è¦ä½¿ç”¨ç”± shmat() è°ƒç”¨è¿”å›çš„ addr å€¼ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­è¯¥å…±äº«å†…å­˜æ®µçš„èµ·ç‚¹çš„æŒ‡é’ˆã€‚ è°ƒç”¨ shmdt() æ¥åˆ†ç¦»å…±äº«å†…å­˜æ®µã€‚åœ¨è¿™ä¸ªè°ƒç”¨ä¹‹åï¼Œè¿›ç¨‹å°±æ— æ³•å†å¼•ç”¨è¿™å—å…±äº«å†…å­˜äº†ã€‚è¿™ä¸€æ­¥æ˜¯å¯é€‰çš„ï¼Œå¹¶ä¸”åœ¨è¿›ç¨‹ç»ˆæ­¢æ—¶ä¼šè‡ªåŠ¨å®Œæˆè¿™ä¸€æ­¥ã€‚ è°ƒç”¨ shmctl() æ¥åˆ é™¤å…±äº«å†…å­˜æ®µã€‚åªæœ‰å½“å½“å‰æ‰€æœ‰é™„åŠ å†…å­˜æ®µçš„è¿›ç¨‹éƒ½ä¸ä¹‹åˆ†ç¦»ä¹‹åå†…å­˜æ®µæ‰ä¼šé”€æ¯ã€‚åªæœ‰ä¸€ä¸ªè¿›ç¨‹éœ€è¦æ‰§è¡Œè¿™ä¸€æ­¥ã€‚ å…±äº«å†…å­˜ç›¸å…³çš„å‡½æ•°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//å…±äº«å†…å­˜ç›¸å…³çš„å‡½æ•°#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg); // - åŠŸèƒ½ï¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å…±äº«å†…å­˜æ®µï¼Œæˆ–è€…è·å–ä¸€ä¸ªæ—¢æœ‰çš„å…±äº«å†…å­˜æ®µçš„æ ‡è¯†ã€‚ // æ–°åˆ›å»ºçš„å†…å­˜æ®µä¸­çš„æ•°æ®éƒ½ä¼šè¢«åˆå§‹åŒ–ä¸º0 // - å‚æ•°ï¼š // - key : key_tç±»å‹æ˜¯ä¸€ä¸ªæ•´å½¢ï¼Œé€šè¿‡è¿™ä¸ªæ‰¾åˆ°æˆ–è€…åˆ›å»ºä¸€ä¸ªå…±äº«å†…å­˜ã€‚ // ä¸€èˆ¬ä½¿ç”¨16è¿›åˆ¶è¡¨ç¤ºï¼Œé0å€¼ // - size: å…±äº«å†…å­˜çš„å¤§å° // - shmflg: å±æ€§ // - è®¿é—®æƒé™ // - é™„åŠ å±æ€§ï¼šåˆ›å»º/åˆ¤æ–­å…±äº«å†…å­˜æ˜¯ä¸æ˜¯å­˜åœ¨ // - åˆ›å»ºï¼šIPC_CREAT // - åˆ¤æ–­å…±äº«å†…å­˜æ˜¯å¦å­˜åœ¨ï¼š IPC_EXCL , éœ€è¦å’ŒIPC_CREATä¸€èµ·ä½¿ç”¨ // IPC_CREAT | IPC_EXCL | 0664 // - è¿”å›å€¼ï¼š // å¤±è´¥ï¼š-1 å¹¶è®¾ç½®é”™è¯¯å· // æˆåŠŸï¼š&gt;0 è¿”å›å…±äº«å†…å­˜çš„å¼•ç”¨çš„IDï¼Œåé¢æ“ä½œå…±äº«å†…å­˜éƒ½æ˜¯é€šè¿‡è¿™ä¸ªå€¼ã€‚void *shmat(int shmid, const void *shmaddr, int shmflg); // - åŠŸèƒ½ï¼šå’Œå½“å‰çš„è¿›ç¨‹è¿›è¡Œå…³è” // - å‚æ•°ï¼š // - shmid : å…±äº«å†…å­˜çš„æ ‡è¯†ï¼ˆIDï¼‰,ç”±shmgetè¿”å›å€¼è·å– // - shmaddr: ç”³è¯·çš„å…±äº«å†…å­˜çš„èµ·å§‹åœ°å€ï¼ŒæŒ‡å®šNULLï¼Œå†…æ ¸æŒ‡å®š // - shmflg : å¯¹å…±äº«å†…å­˜çš„æ“ä½œ // - è¯» ï¼š SHM_RDONLY, å¿…é¡»è¦æœ‰è¯»æƒé™ // - è¯»å†™ï¼š 0 // - è¿”å›å€¼ï¼š // æˆåŠŸï¼šè¿”å›å…±äº«å†…å­˜çš„é¦–ï¼ˆèµ·å§‹ï¼‰åœ°å€ã€‚ å¤±è´¥(void *) -1int shmdt(const void *shmaddr); // - åŠŸèƒ½ï¼šè§£é™¤å½“å‰è¿›ç¨‹å’Œå…±äº«å†…å­˜çš„å…³è” // - å‚æ•°ï¼š // shmaddrï¼šå…±äº«å†…å­˜çš„é¦–åœ°å€ // - è¿”å›å€¼ï¼šæˆåŠŸ 0ï¼Œ å¤±è´¥ -1int shmctl(int shmid, int cmd, struct shmid_ds *buf); // - åŠŸèƒ½ï¼šå¯¹å…±äº«å†…å­˜è¿›è¡Œæ“ä½œã€‚åˆ é™¤å…±äº«å†…å­˜ï¼Œå…±äº«å†…å­˜è¦åˆ é™¤æ‰ä¼šæ¶ˆå¤±ï¼Œåˆ›å»ºå…±äº«å†…å­˜çš„è¿›è¡Œè¢«é”€æ¯äº†å¯¹å…±äº«å†…å­˜æ˜¯æ²¡æœ‰ä»»ä½•å½±å“ã€‚ // - å‚æ•°ï¼š // - shmid: å…±äº«å†…å­˜çš„ID // - cmd : è¦åšçš„æ“ä½œ // - IPC_STAT : è·å–å…±äº«å†…å­˜çš„å½“å‰çš„çŠ¶æ€ // - IPC_SET : è®¾ç½®å…±äº«å†…å­˜çš„çŠ¶æ€ // - IPC_RMID: æ ‡è®°å…±äº«å†…å­˜è¢«é”€æ¯ // - bufï¼šéœ€è¦è®¾ç½®æˆ–è€…è·å–çš„å…±äº«å†…å­˜çš„å±æ€§ä¿¡æ¯ // - IPC_STAT : bufå­˜å‚¨æ•°æ® // - IPC_SET : bufä¸­éœ€è¦åˆå§‹åŒ–æ•°æ®ï¼Œè®¾ç½®åˆ°å†…æ ¸ä¸­ // - IPC_RMID : æ²¡æœ‰ç”¨ï¼ŒNULLkey_t ftok(const char *pathname, int proj_id); // - åŠŸèƒ½ï¼šæ ¹æ®æŒ‡å®šçš„è·¯å¾„åï¼Œå’Œintå€¼ï¼Œç”Ÿæˆä¸€ä¸ªå…±äº«å†…å­˜çš„key // - å‚æ•°ï¼š // - pathname:æŒ‡å®šä¸€ä¸ªå­˜åœ¨çš„è·¯å¾„ // - proj_id: intç±»å‹çš„å€¼ï¼Œä½†æ˜¯è¿™ç³»ç»Ÿè°ƒç”¨åªä¼šä½¿ç”¨å…¶ä¸­çš„1ä¸ªå­—èŠ‚ // èŒƒå›´ ï¼š 0-255 ä¸€èˆ¬æŒ‡å®šä¸€ä¸ªå­—ç¬¦ &#x27;a&#x27; æ¡ˆä¾‹ï¼šä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œé€šä¿¡write.c 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;string.h&gt;int main()&#123; //1ã€åˆ›å»ºä¸€ä¸ªå…±äº«å†…å­˜ int shmid = shmget(100, 4096, IPC_CREAT | 0664); printf(&quot;shmid : %d\\n&quot;, shmid); //2ã€å’Œå½“å‰è¿›ç¨‹è¿›è¡Œå…³è” void* ptr = shmat(shmid, NULL, 0); char* str = &quot;hello world&quot;; //3ã€å†™æ•°æ® memcpy(ptr, str, strlen(str) + 1); printf(&quot;æŒ‰ä»»æ„é”®ç»§ç»­\\n&quot;); getchar(); //4ã€è§£é™¤å…³è” shmdt(ptr); //5ã€åˆ é™¤å…±äº«å†…å­˜ shmctl(shmid, IPC_RMID, NULL);&#125; read.c 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;string.h&gt;int main()&#123; //1ã€è·å–ä¸€ä¸ªå…±äº«å†…å­˜ int shmid = shmget(100, 0, IPC_CREAT); printf(&quot;shmid : %d\\n&quot;, shmid); //2ã€å’Œå½“å‰è¿›ç¨‹è¿›è¡Œå…³è” void* ptr = shmat(shmid, NULL, 0); //3ã€è¯»æ•°æ® printf(&quot;%s\\n&quot;, (char*)ptr); printf(&quot;æŒ‰ä»»æ„é”®ç»§ç»­\\n&quot;); getchar(); //4ã€è§£é™¤å…³è” shmdt(ptr); //5ã€åˆ é™¤å…±äº«å†…å­˜ shmctl(shmid, IPC_RMID, NULL);&#125; åˆ†åˆ«ç¼–è¯‘è¿è¡Œ æ€è€ƒé—®é¢˜ é—®é¢˜1ï¼šæ“ä½œç³»ç»Ÿå¦‚ä½•çŸ¥é“ä¸€å—å…±äº«å†…å­˜è¢«å¤šå°‘ä¸ªè¿›ç¨‹å…³è”ï¼Ÿ - å…±äº«å†…å­˜ç»´æŠ¤äº†ä¸€ä¸ªç»“æ„ä½“struct shmid_ds è¿™ä¸ªç»“æ„ä½“ä¸­æœ‰ä¸€ä¸ªæˆå‘˜ shm_nattch - shm_nattach è®°å½•äº†å…³è”çš„è¿›ç¨‹ä¸ªæ•° é—®é¢˜2ï¼šå¯ä¸å¯ä»¥å¯¹å…±äº«å†…å­˜è¿›è¡Œå¤šæ¬¡åˆ é™¤ shmctl - å¯ä»¥çš„ - å› ä¸ºshmctl æ ‡è®°åˆ é™¤å…±äº«å†…å­˜ï¼Œä¸æ˜¯ç›´æ¥åˆ é™¤ - ä»€ä¹ˆæ—¶å€™çœŸæ­£åˆ é™¤å‘¢? å½“å’Œå…±äº«å†…å­˜å…³è”çš„è¿›ç¨‹æ•°ä¸º0çš„æ—¶å€™ï¼Œå°±çœŸæ­£è¢«åˆ é™¤ - å½“å…±äº«å†…å­˜çš„keyä¸º0çš„æ—¶å€™ï¼Œè¡¨ç¤ºå…±äº«å†…å­˜è¢«æ ‡è®°åˆ é™¤äº† å¦‚æœä¸€ä¸ªè¿›ç¨‹å’Œå…±äº«å†…å­˜å–æ¶ˆå…³è”ï¼Œé‚£ä¹ˆè¿™ä¸ªè¿›ç¨‹å°±ä¸èƒ½ç»§ç»­æ“ä½œè¿™ä¸ªå…±äº«å†…å­˜ã€‚ä¹Ÿä¸èƒ½è¿›è¡Œå…³è”ã€‚ å…±äº«å†…å­˜å’Œå†…å­˜æ˜ å°„çš„åŒºåˆ« 1.å…±äº«å†…å­˜å¯ä»¥ç›´æ¥åˆ›å»ºï¼Œå†…å­˜æ˜ å°„éœ€è¦ç£ç›˜æ–‡ä»¶ï¼ˆåŒ¿åæ˜ å°„é™¤å¤–ï¼‰ 2.å…±äº«å†…å­˜æ•ˆæœæ›´é«˜ 3.å†…å­˜ æ‰€æœ‰çš„è¿›ç¨‹æ“ä½œçš„æ˜¯åŒä¸€å—å…±äº«å†…å­˜ã€‚ å†…å­˜æ˜ å°„ï¼Œæ¯ä¸ªè¿›ç¨‹åœ¨è‡ªå·±çš„è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­æœ‰ä¸€ä¸ªç‹¬ç«‹çš„å†…å­˜ã€‚ 4.æ•°æ®å®‰å…¨ - è¿›ç¨‹çªç„¶é€€å‡º å…±äº«å†…å­˜è¿˜å­˜åœ¨ å†…å­˜æ˜ å°„åŒºæ¶ˆå¤± - è¿è¡Œè¿›ç¨‹çš„ç”µè„‘æ­»æœºï¼Œå®•æœºäº† æ•°æ®å­˜åœ¨åœ¨å…±äº«å†…å­˜ä¸­ï¼Œæ²¡æœ‰äº† å†…å­˜æ˜ å°„åŒºçš„æ•°æ® ï¼Œç”±äºç£ç›˜æ–‡ä»¶ä¸­çš„æ•°æ®è¿˜åœ¨ï¼Œæ‰€ä»¥å†…å­˜æ˜ å°„åŒºçš„æ•°æ®è¿˜å­˜åœ¨ã€‚ 5.ç”Ÿå‘½å‘¨æœŸ - å†…å­˜æ˜ å°„åŒºï¼šè¿›ç¨‹é€€å‡ºï¼Œå†…å­˜æ˜ å°„åŒºé”€æ¯ - å…±äº«å†…å­˜ï¼šè¿›ç¨‹é€€å‡ºï¼Œå…±äº«å†…å­˜è¿˜åœ¨ï¼Œæ ‡è®°åˆ é™¤ï¼ˆæ‰€æœ‰çš„å…³è”çš„è¿›ç¨‹æ•°ä¸º0ï¼‰ï¼Œæˆ–è€…å…³æœº å¦‚æœä¸€ä¸ªè¿›ç¨‹é€€å‡ºï¼Œä¼šè‡ªåŠ¨å’Œå…±äº«å†…å­˜è¿›è¡Œå–æ¶ˆå…³è”ã€‚ å…±äº«å†…å­˜æ“ä½œå‘½ä»¤ ipcs ç”¨æ³• ipcs -a &#x2F;&#x2F; æ‰“å°å½“å‰ç³»ç»Ÿä¸­æ‰€æœ‰çš„è¿›ç¨‹é—´é€šä¿¡æ–¹å¼çš„ä¿¡æ¯ ipcs -m &#x2F;&#x2F; æ‰“å°å‡ºä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡çš„ä¿¡æ¯ ipcs -q &#x2F;&#x2F; æ‰“å°å‡ºä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡çš„ä¿¡æ¯ ipcs -s &#x2F;&#x2F; æ‰“å°å‡ºä½¿ç”¨ä¿¡å·è¿›è¡Œè¿›ç¨‹é—´é€šä¿¡çš„ä¿¡æ¯ ipcrm ç”¨æ³• ipcrm -M shmkey &#x2F;&#x2F; ç§»é™¤ç”¨shmkeyåˆ›å»ºçš„å…±äº«å†…å­˜æ®µ ipcrm -m shmid &#x2F;&#x2F; ç§»é™¤ç”¨shmidæ ‡è¯†çš„å…±äº«å†…å­˜æ®µ ipcrm -Q msgkey &#x2F;&#x2F; ç§»é™¤ç”¨msqkeyåˆ›å»ºçš„æ¶ˆæ¯é˜Ÿåˆ— ipcrm -q msqid &#x2F;&#x2F; ç§»é™¤ç”¨msqidæ ‡è¯†çš„æ¶ˆæ¯é˜Ÿåˆ— ipcrm -S semkey &#x2F;&#x2F; ç§»é™¤ç”¨semkeyåˆ›å»ºçš„ä¿¡å· ipcrm -s semid &#x2F;&#x2F; ç§»é™¤ç”¨semidæ ‡è¯†çš„ä¿¡å· å®ˆæŠ¤è¿›ç¨‹ç»ˆç«¯ åœ¨ UNIX ç³»ç»Ÿä¸­ï¼Œç”¨æˆ·é€šè¿‡ç»ˆç«¯ç™»å½•ç³»ç»Ÿåå¾—åˆ°ä¸€ä¸ª shell è¿›ç¨‹ï¼Œè¿™ä¸ªç»ˆç«¯æˆä¸º shell è¿›ç¨‹çš„æ§åˆ¶ç»ˆç«¯ï¼ˆControlling Terminalï¼‰ï¼Œè¿›ç¨‹ä¸­ï¼Œæ§åˆ¶ç»ˆç«¯æ˜¯ä¿å­˜åœ¨ PCB ä¸­çš„ä¿¡æ¯ï¼Œè€Œ fork() ä¼šå¤åˆ¶ PCB ä¸­çš„ä¿¡æ¯ï¼Œå› æ­¤ç”± shell è¿›ç¨‹å¯åŠ¨çš„å…¶å®ƒè¿›ç¨‹çš„æ§åˆ¶ç»ˆç«¯ä¹Ÿæ˜¯è¿™ä¸ªç»ˆç«¯ã€‚ å¯ä»¥é€šè¿‡å‘½ä»¤ 1echo $$ æŸ¥çœ‹å½“å‰shellçš„è¿›ç¨‹å· é»˜è®¤æƒ…å†µä¸‹ï¼ˆæ²¡æœ‰é‡å®šå‘ï¼‰ï¼Œæ¯ä¸ªè¿›ç¨‹çš„æ ‡å‡†è¾“å…¥ã€æ ‡å‡†è¾“å‡ºå’Œæ ‡å‡†é”™è¯¯è¾“å‡ºéƒ½æŒ‡å‘æ§åˆ¶ç»ˆç«¯ï¼Œè¿›ç¨‹ä»æ ‡å‡†è¾“å…¥è¯»ä¹Ÿå°±æ˜¯è¯»ç”¨æˆ·çš„é”®ç›˜è¾“å…¥ï¼Œè¿›ç¨‹å¾€æ ‡å‡†è¾“å‡ºæˆ–æ ‡å‡†é”™è¯¯è¾“å‡ºå†™ä¹Ÿå°±æ˜¯è¾“å‡ºåˆ°æ˜¾ç¤ºå™¨ä¸Šã€‚ åœ¨æ§åˆ¶ç»ˆç«¯è¾“å…¥ä¸€äº›ç‰¹æ®Šçš„æ§åˆ¶é”®å¯ä»¥ç»™å‰å°è¿›ç¨‹å‘ä¿¡å·ï¼Œä¾‹å¦‚ Ctrl + C ä¼šäº§ç”Ÿ SIGINT ä¿¡å·ï¼ŒCtrl + \\ ä¼šäº§ç”Ÿ SIGQUIT ä¿¡å· è¿›ç¨‹ç»„ è¿›ç¨‹ç»„å’Œä¼šè¯åœ¨è¿›ç¨‹ä¹‹é—´å½¢æˆäº†ä¸€ç§ä¸¤çº§å±‚æ¬¡å…³ç³»ï¼šè¿›ç¨‹ç»„æ˜¯ä¸€ç»„ç›¸å…³è¿›ç¨‹çš„é›†åˆï¼Œä¼šè¯æ˜¯ä¸€ç»„ç›¸å…³è¿›ç¨‹ç»„çš„é›†åˆã€‚è¿›ç¨‹ç»„å’Œä¼šè¯æ˜¯ä¸ºæ”¯æŒ shell ä½œä¸šæ§åˆ¶è€Œå®šä¹‰çš„æŠ½è±¡æ¦‚å¿µï¼Œç”¨æˆ·é€šè¿‡ shell èƒ½å¤Ÿäº¤äº’å¼åœ°åœ¨å‰å°æˆ–åå°è¿è¡Œå‘½ä»¤ã€‚ è¿›è¡Œç»„ç”±ä¸€ä¸ªæˆ–å¤šä¸ªå…±äº«åŒä¸€è¿›ç¨‹ç»„æ ‡è¯†ç¬¦ï¼ˆPGIDï¼‰çš„è¿›ç¨‹ç»„æˆã€‚ä¸€ä¸ªè¿›ç¨‹ç»„æ‹¥æœ‰ä¸€ä¸ªè¿›ç¨‹ç»„é¦–è¿›ç¨‹ï¼Œè¯¥è¿›ç¨‹æ˜¯åˆ›å»ºè¯¥ç»„çš„è¿›ç¨‹ï¼Œå…¶è¿›ç¨‹ ID ä¸ºè¯¥è¿›ç¨‹ç»„çš„ IDï¼Œæ–°è¿›ç¨‹ä¼šç»§æ‰¿å…¶çˆ¶è¿›ç¨‹æ‰€å±çš„è¿›ç¨‹ç»„ IDã€‚ è¿›ç¨‹ç»„æ‹¥æœ‰ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œå…¶å¼€å§‹æ—¶é—´ä¸ºé¦–è¿›ç¨‹åˆ›å»ºç»„çš„æ—¶åˆ»ï¼Œç»“æŸæ—¶é—´ä¸ºæœ€åä¸€ä¸ªæˆå‘˜è¿›ç¨‹é€€å‡ºç»„çš„æ—¶åˆ»ã€‚ä¸€ä¸ªè¿›ç¨‹å¯èƒ½ä¼šå› ä¸ºç»ˆæ­¢è€Œé€€å‡ºè¿›ç¨‹ç»„ï¼Œä¹Ÿå¯èƒ½ä¼šå› ä¸ºåŠ å…¥äº†å¦å¤–ä¸€ä¸ªè¿›ç¨‹ç»„è€Œé€€å‡ºè¿›ç¨‹ç»„ã€‚è¿›ç¨‹ç»„é¦–è¿›ç¨‹æ— éœ€æ˜¯æœ€åä¸€ä¸ªç¦»å¼€è¿›ç¨‹ç»„çš„æˆå‘˜ã€‚ ä¼šè¯ ä¼šè¯æ˜¯ä¸€ç»„è¿›ç¨‹ç»„çš„é›†åˆã€‚ä¼šè¯é¦–è¿›ç¨‹æ˜¯åˆ›å»ºè¯¥æ–°ä¼šè¯çš„è¿›ç¨‹ï¼Œå…¶è¿›ç¨‹ ID ä¼šæˆä¸ºä¼šè¯ IDã€‚æ–°è¿›ç¨‹ä¼šç»§æ‰¿å…¶çˆ¶è¿›ç¨‹çš„ä¼šè¯ IDã€‚ ä¸€ä¸ªä¼šè¯ä¸­çš„æ‰€æœ‰è¿›ç¨‹å…±äº«å•ä¸ªæ§åˆ¶ç»ˆç«¯ã€‚æ§åˆ¶ç»ˆç«¯ä¼šåœ¨ä¼šè¯é¦–è¿›ç¨‹é¦–æ¬¡æ‰“å¼€ä¸€ä¸ªç»ˆç«¯è®¾å¤‡æ—¶è¢«å»ºç«‹ã€‚ä¸€ä¸ªç»ˆç«¯æœ€å¤šå¯èƒ½ä¼šæˆä¸ºä¸€ä¸ªä¼šè¯çš„æ§åˆ¶ç»ˆç«¯ã€‚ åœ¨ä»»ä¸€æ—¶åˆ»ï¼Œä¼šè¯ä¸­çš„å…¶ä¸­ä¸€ä¸ªè¿›ç¨‹ç»„ä¼šæˆä¸ºç»ˆç«¯çš„å‰å°è¿›ç¨‹ç»„ï¼Œå…¶ä»–è¿›ç¨‹ç»„ä¼šæˆä¸ºåå°è¿›ç¨‹ç»„ã€‚åªæœ‰å‰å°è¿›ç¨‹ç»„ä¸­çš„è¿›ç¨‹æ‰èƒ½ä»æ§åˆ¶ç»ˆç«¯ä¸­è¯»å–è¾“å…¥ã€‚å½“ç”¨æˆ·åœ¨æ§åˆ¶ç»ˆç«¯ä¸­è¾“å…¥ç»ˆç«¯å­—ç¬¦ç”Ÿæˆä¿¡å·åï¼Œè¯¥ä¿¡å·ä¼šè¢«å‘é€åˆ°å‰å°è¿›ç¨‹ç»„ä¸­çš„æ‰€æœ‰æˆå‘˜ã€‚ å½“æ§åˆ¶ç»ˆç«¯çš„è¿æ¥å»ºç«‹èµ·æ¥ä¹‹åï¼Œä¼šè¯é¦–è¿›ç¨‹ä¼šæˆä¸ºè¯¥ç»ˆç«¯çš„æ§åˆ¶è¿›ç¨‹ã€‚ è¿›ç¨‹ç»„ã€ä¼šè¯ã€æ§åˆ¶ç»ˆç«¯ä¹‹é—´çš„å…³ç³» è¿è¡Œçš„å‘½ä»¤ä¸ºï¼š find / 2 &gt; /dev/null | wc -l &amp; sort &lt; longlist | uniq -c è¿›ç¨‹ç»„ã€ä¼šè¯æ“ä½œå‡½æ•°12345pid_t getpgrp(void); //è·å–å½“å‰è¿›ç¨‹çš„è¿›ç¨‹ç»„IDpid_t getpgid(pid_t pid); //è·å–æŒ‡å®šè¿›ç¨‹çš„è¿›ç¨‹ç»„IDint setpgid(pid_t pid, pid_t pgid); //è®¾ç½®è¿›ç¨‹ç»„çš„IDpid_t getsid(pid_t pid); //è·å–æŒ‡å®šè¿›ç¨‹çš„ä¼šè¯çš„IDpid_t setsid(void); //è®¾ç½®è¿›ç¨‹çš„ä¼šè¯ID å®ˆæŠ¤è¿›ç¨‹ å®ˆæŠ¤è¿›ç¨‹ï¼ˆDaemon Processï¼‰ï¼Œä¹Ÿå°±æ˜¯é€šå¸¸è¯´çš„ Daemon è¿›ç¨‹ï¼ˆç²¾çµè¿›ç¨‹ï¼‰ï¼ŒLinux ä¸­çš„åå°æœåŠ¡è¿›ç¨‹ã€‚å®ƒæ˜¯ä¸€ä¸ªç”Ÿå­˜æœŸè¾ƒé•¿çš„è¿›ç¨‹ï¼Œé€šå¸¸ç‹¬ç«‹äºæ§åˆ¶ç»ˆç«¯å¹¶ä¸”å‘¨æœŸæ€§åœ°æ‰§è¡ŒæŸç§ä»»åŠ¡æˆ–ç­‰å¾…å¤„ç†æŸäº›å‘ç”Ÿçš„äº‹ä»¶ã€‚ä¸€èˆ¬é‡‡ç”¨ä»¥ d ç»“å°¾çš„åå­—ã€‚ å®ˆæŠ¤è¿›ç¨‹å…·å¤‡ä¸‹åˆ—ç‰¹å¾ï¼š ç”Ÿå‘½å‘¨æœŸå¾ˆé•¿ï¼Œå®ˆæŠ¤è¿›ç¨‹ä¼šåœ¨ç³»ç»Ÿå¯åŠ¨çš„æ—¶å€™è¢«åˆ›å»ºå¹¶ä¸€ç›´è¿è¡Œç›´è‡³ç³»ç»Ÿè¢«å…³é—­ã€‚ å®ƒåœ¨åå°è¿è¡Œå¹¶ä¸”ä¸æ‹¥æœ‰æ§åˆ¶ç»ˆç«¯ã€‚æ²¡æœ‰æ§åˆ¶ç»ˆç«¯ç¡®ä¿äº†å†…æ ¸æ°¸è¿œä¸ä¼šä¸ºå®ˆæŠ¤è¿›ç¨‹è‡ªåŠ¨ç”Ÿæˆä»»ä½•æ§åˆ¶ä¿¡å·ä»¥åŠç»ˆç«¯ç›¸å…³çš„ä¿¡å·ï¼ˆå¦‚ SIGINTã€SIGQUITï¼‰ã€‚ Linux çš„å¤§å¤šæ•°æœåŠ¡å™¨å°±æ˜¯ç”¨å®ˆæŠ¤è¿›ç¨‹å®ç°çš„ã€‚æ¯”å¦‚ï¼ŒInternet æœåŠ¡å™¨ inetdï¼ŒWeb æœåŠ¡å™¨ httpd ç­‰ å®ˆæŠ¤è¿›ç¨‹åˆ›å»ºæ­¥éª¤ æ‰§è¡Œä¸€ä¸ª fork()ï¼Œä¹‹åçˆ¶è¿›ç¨‹é€€å‡ºï¼Œå­è¿›ç¨‹ç»§ç»­æ‰§è¡Œã€‚ å­è¿›ç¨‹è°ƒç”¨ setsid() å¼€å¯ä¸€ä¸ªæ–°ä¼šè¯ã€‚ æ¸…é™¤è¿›ç¨‹çš„ umask ä»¥ç¡®ä¿å½“å®ˆæŠ¤è¿›ç¨‹åˆ›å»ºæ–‡ä»¶å’Œç›®å½•æ—¶æ‹¥æœ‰æ‰€éœ€çš„æƒé™ã€‚ ä¿®æ”¹è¿›ç¨‹çš„å½“å‰å·¥ä½œç›®å½•ï¼Œé€šå¸¸ä¼šæ”¹ä¸ºæ ¹ç›®å½•ï¼ˆ&#x2F;ï¼‰ã€‚ å…³é—­å®ˆæŠ¤è¿›ç¨‹ä»å…¶çˆ¶è¿›ç¨‹ç»§æ‰¿è€Œæ¥çš„æ‰€æœ‰æ‰“å¼€ç€çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ åœ¨å…³é—­äº†æ–‡ä»¶æè¿°ç¬¦0ã€1ã€2ä¹‹åï¼Œå®ˆæŠ¤è¿›ç¨‹é€šå¸¸ä¼šæ‰“å¼€&#x2F;dev&#x2F;null å¹¶ä½¿ç”¨dup2() ä½¿æ‰€æœ‰è¿™äº›æè¿°ç¬¦æŒ‡å‘è¿™ä¸ªè®¾å¤‡ã€‚ æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ æ¡ˆä¾‹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* å†™ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹ï¼Œæ¯éš”2sè·å–ä¸€ä¸‹ç³»ç»Ÿæ—¶é—´ï¼Œå°†è¿™ä¸ªæ—¶é—´å†™å…¥åˆ°ç£ç›˜æ–‡ä»¶ä¸­ã€‚*/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/time.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void work(int num) &#123; // æ•æ‰åˆ°ä¿¡å·ä¹‹åï¼Œè·å–ç³»ç»Ÿæ—¶é—´ï¼Œå†™å…¥ç£ç›˜æ–‡ä»¶ time_t tm = time(NULL); struct tm* loc = localtime(&amp;tm); // char buf[1024]; // sprintf(buf, &quot;%d-%d-%d %d:%d:%d\\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon // ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec); // printf(&quot;%s\\n&quot;, buf); char* str = asctime(loc); int fd = open(&quot;time.txt&quot;, O_RDWR | O_CREAT | O_APPEND, 0664); write(fd, str, strlen(str)); close(fd);&#125;int main() &#123; // 1.åˆ›å»ºå­è¿›ç¨‹ï¼Œé€€å‡ºçˆ¶è¿›ç¨‹ pid_t pid = fork(); if (pid &gt; 0) &#123; exit(0); &#125; // 2.å°†å­è¿›ç¨‹é‡æ–°åˆ›å»ºä¸€ä¸ªä¼šè¯ setsid(); // 3.è®¾ç½®æ©ç  umask(022); // 4.æ›´æ”¹å·¥ä½œç›®å½• chdir(&quot;/home/plucky/Linux/lecture27&quot;); // 5. å…³é—­ã€é‡å®šå‘æ–‡ä»¶æè¿°ç¬¦ int fd = open(&quot;/dev/null&quot;, O_RDWR); dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); // 6.ä¸šåŠ¡é€»è¾‘ // æ•æ‰å®šæ—¶ä¿¡å· struct sigaction act; act.sa_flags = 0; act.sa_handler = work; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); struct itimerval val; val.it_value.tv_sec = 2; val.it_value.tv_usec = 0; val.it_interval.tv_sec = 2; val.it_interval.tv_usec = 0; // åˆ›å»ºå®šæ—¶å™¨ setitimer(ITIMER_REAL, &amp;val, NULL); // ä¸è®©è¿›ç¨‹ç»“æŸ while (1) &#123; sleep(10); &#125; return 0;&#125; ç¼–è¯‘è¿è¡Œ å› ä¸ºæ˜¯å®ˆæŠ¤è¿›ç¨‹ï¼Œæ‰€ä»¥ä¼šæ–°å»ºä¸€ä¸ªä¼šè¯ï¼Œæˆ‘ä»¬ä»æ§åˆ¶ç»ˆç«¯ä¸Šè¿›è¡Œçš„æ“ä½œä¸ä¼šå½±å“åˆ°å®ˆæŠ¤è¿›ç¨‹çš„æ‰§è¡Œï¼Œåªèƒ½é€šè¿‡killå‘½ä»¤æ€æ­»å®ˆæŠ¤è¿›ç¨‹","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"è¿›ç¨‹","slug":"è¿›ç¨‹","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"C++å­¦ä¹  æ¨¡æ¿","slug":"C++-å­¦ä¹ -æ¨¡æ¿","date":"2023-05-07T11:42:34.000Z","updated":"2023-05-09T11:17:37.233Z","comments":true,"path":"2023/05/07/C++-å­¦ä¹ -æ¨¡æ¿/","link":"","permalink":"http://example.com/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/","excerpt":"æ¨¡æ¿çš„æ¦‚å¿µæ¨¡æ¿å°±æ˜¯å»ºç«‹ä¸€ä¸ªé€šç”¨çš„æ¨¡å…·ï¼Œå¤§å¤§æé«˜å¤ç”¨æ€§ æ¨¡æ¿çš„ç‰¹ç‚¹ï¼š","text":"æ¨¡æ¿çš„æ¦‚å¿µæ¨¡æ¿å°±æ˜¯å»ºç«‹ä¸€ä¸ªé€šç”¨çš„æ¨¡å…·ï¼Œå¤§å¤§æé«˜å¤ç”¨æ€§ æ¨¡æ¿çš„ç‰¹ç‚¹ï¼š ä¸èƒ½ç›´æ¥ä½¿ç”¨ï¼Œä»–åªæ˜¯ä¸€ä¸ªæ¡†æ¶ æ¨¡æ¿çš„é€šç”¨å¹¶ä¸æ˜¯ä¸‡èƒ½çš„ å‡½æ•°æ¨¡æ¿ C++å¦ä¸€ç§ç¼–ç¨‹æ€æƒ³ç§°ä¸ºæ³›å‹ç¼–ç¨‹ï¼Œä¸»è¦åˆ©ç”¨çš„æŠ€æœ¯å°±æ˜¯æ¨¡æ¿ C++æä¾›ä¸¤ç§æ¨¡æ¿æœºåˆ¶ï¼šå‡½æ•°æ¨¡æ¿å’Œç±»æ¨¡æ¿ å‡½æ•°æ¨¡æ¿è¯­æ³•å‡½æ•°æ¨¡æ¿ä½œç”¨ï¼š å»ºç«‹ä¸€ä¸ªé€šç”¨å‡½æ•°ï¼Œå…¶å‡½æ•°è¿”å›å€¼ç±»å‹å’Œå½¢å‚ç±»å‹å¯ä»¥ä¸å…·ä½“æŒ‡å®šç”¨ä¸€ä¸ªè™šæ‹Ÿçš„ç±»å‹æ¥ä»£è¡¨ è¯­æ³• 12template&lt;typename T&gt;å‡½æ•°å£°æ˜æˆ–å®šä¹‰ è§£é‡Š template â€” å£°æ˜åˆ›å»ºæ¨¡æ¿ typename â€” è¡¨æ˜å…¶åé¢çš„ç¬¦å·æ˜¯ä¸€ç§ç¬¦å·ç±»å‹ï¼Œå¯ä»¥ç”¨classä»£æ›¿ T â€” é€šç”¨çš„æ•°æ®ç±»å‹ï¼Œåç§°å¯ä»¥æ›¿æ¢ï¼Œé€šå¸¸ä¸ºå¤§å†™å­—æ¯ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//å‡½æ•°æ¨¡æ¿//ä¸¤ä¸ªæ•´å½¢äº¤æ¢å‡½æ•°void swapInt(int&amp; a, int&amp; b)&#123; int temp = a; a = b; b = temp;&#125;//äº¤æ¢ä¸¤ä¸ªæµ®ç‚¹å‹å‡½æ•°void swapDouble(double&amp; a, double&amp; b)&#123; double temp = a; a = b; b = temp;&#125;//å‡½æ•°æ¨¡æ¿template&lt;typename T&gt;//å£°æ˜ä¸€ä¸ªæ¨¡æ¿ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨åé¢ä»£ç ä¸­ç´§è·Ÿç€çš„Tä¸è¦æŠ¥é”™ï¼ŒTæ˜¯ä¸€ä¸ªé€šç”¨æ•°æ®ç±»å‹void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test01()&#123; int a = 10; int b = 20; swapInt(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //åˆ©ç”¨å‡½æ•°æ¨¡æ¿ï¼Œä¸¤ç§æ–¹å¼ä½¿ç”¨ //1ã€è‡ªåŠ¨ç±»å‹æ¨å¯¼ mySwap(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //æ˜¾å¼æŒ‡å®šç±»å‹ mySwap&lt;int&gt;(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; double c = 1.1; double d = 2.2; swapDouble(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; mySwap(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; //æ˜¾å¼æŒ‡å®šç±»å‹ mySwap&lt;double&gt;(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl;&#125;int main()&#123; test01();&#125; æ€»ç»“ å‡½æ•°æ¨¡æ¿åˆ©ç”¨å…³é”®å­—template ä½¿ç”¨å‡½æ•°æ¨¡æ¿æœ‰ä¸¤ç§æ–¹å¼ï¼šè‡ªåŠ¨ç±»å‹æ¨å¯¼ï¼Œæ˜¾ç¤ºæŒ‡å®šç±»å‹ æ¨¡æ¿çš„ç›®çš„æ˜¯ä¸ºäº†æé«˜å¤ç”¨æ€§ï¼Œå°†ç±»å‹å‚æ•°åŒ– å‡½æ•°æ¨¡æ¿æ³¨æ„äº‹é¡¹æ³¨æ„äº‹é¡¹ï¼š è‡ªåŠ¨ç±»å‹æ¨å¯¼ï¼Œå¿…é¡»æ¨å¯¼å‡ºä¸€è‡´çš„æ•°æ®ç±»å‹Tæ‰å¯ä»¥ä½¿ç”¨ æ¨¡æ¿å¿…é¡»è¦ç¡®å®šå‡ºTçš„æ•°æ®ç±»å‹ï¼Œæ‰å¯ä»¥ä½¿ç”¨ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//å‡½æ•°æ¨¡æ¿æ³¨æ„äº‹é¡¹template&lt;typename T&gt;//typenameå¯ä»¥æ›¿æ¢æˆclassvoid mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;//1ã€è‡ªåŠ¨ç±»å‹æ¨å¯¼ï¼Œå¿…é¡»æ¨å¯¼å‡ºä¸€è‡´çš„æ•°æ®ç±»å‹Tæ‰å¯ä»¥ä½¿ç”¨void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b);//æ­£ç¡®ï¼› cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; mySwap(a, c);//é”™è¯¯&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//å‡½æ•°æ¨¡æ¿æ³¨æ„äº‹é¡¹template&lt;typename T&gt;//typenameå¯ä»¥æ›¿æ¢æˆclassvoid mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;//1ã€è‡ªåŠ¨ç±»å‹æ¨å¯¼ï¼Œå¿…é¡»æ¨å¯¼å‡ºä¸€è‡´çš„æ•°æ®ç±»å‹Tæ‰å¯ä»¥ä½¿ç”¨void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b);//æ­£ç¡®ï¼› cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;//2ã€æ¨¡æ¿å¿…é¡»è¦ç¡®å®šå‡ºTçš„æ•°æ®ç±»å‹ï¼Œæ‰å¯ä»¥ä½¿ç”¨ template&lt;typename T&gt;void func()&#123; cout &lt;&lt; &quot;funcè°ƒç”¨&quot; &lt;&lt; endl;&#125;void test02()&#123; func();&#125;int main()&#123; test01(); test02();&#125; å‡½æ•°æ¨¡æ¿æ¡ˆä¾‹æ¡ˆä¾‹æè¿° åˆ©ç”¨å‡½æ•°æ¨¡æ¿å°è£…ä¸€ä¸ªæ’åºçš„å‡½æ•°ï¼Œå¯ä»¥å¯¹ä¸åŒæ•°æ®ç±»å‹çš„æ•°ç»„è¿›è¡Œæ’åº æ’åºè§„åˆ™ä»å¤§åˆ°å°ï¼Œæ’åºç®—æ³•ä¸ºé€‰æ‹©æ’åº åˆ†åˆ«åˆ©ç”¨charæ•°ç»„å’Œintæ•°ç»„è¿›è¡Œæµ‹è¯• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;class T&gt;void mySort(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; int max = i; for (int j = i + 1; j &lt; len; j++) &#123; if (arr[max] &lt; arr[j]) &#123; max = j; &#125; &#125; if (max != i) &#123; mySwap(arr[max], arr[i]); &#125; &#125;&#125;template&lt;class T&gt;void printArray(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; char charArr[] = &quot;badcfe&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);&#125;void test02()&#123; int intArr[] = &#123; 7,5,1,9,2,4,6,8 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š f e d c b a9 8 7 6 5 4 2 1 æ™®é€šå‡½æ•°å’Œå‡½æ•°æ¨¡æ¿çš„åŒºåˆ« æ™®é€šå‡½æ•°è°ƒç”¨æ—¶å¯ä»¥å‘ç”Ÿè‡ªåŠ¨ç±»å‹è½¬æ¢ï¼ˆéšå¼ç±»å‹è½¬æ¢ï¼‰ å‡½æ•°æ¨¡æ¿è°ƒç”¨æ—¶ï¼Œå¦‚æœåˆ©ç”¨è‡ªåŠ¨ç±»å‹æ¨å¯¼ï¼Œä¸ä¼šå‘ç”Ÿéšå¼ç±»å‹è½¬æ¢ å¦‚æœåˆ©ç”¨æ˜¾ç¤ºæŒ‡å®šç±»å‹çš„æ–¹å¼ï¼Œå¯ä»¥å‘ç”Ÿéšå¼ç±»å‹è½¬æ¢ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//æ™®é€šå‡½æ•°ä¸å‡½æ•°æ¨¡æ¿åŒºåˆ«//1ã€æ™®é€šå‡½æ•°è°ƒç”¨å¯ä»¥å‘ç”Ÿéšå¼ç±»å‹è½¬æ¢//2ã€å‡½æ•°æ¨¡æ¿ç”¨è‡ªåŠ¨ç±»å‹æ¨å¯¼ï¼Œä¸å¯ä»¥å‘ç”Ÿéšå¼ç±»å‹è½¬æ¢//3ã€å‡½æ•°æ¨¡æ¿ç”¨æ˜¾ç¤ºæŒ‡å®šç±»å‹ï¼Œå¯ä»¥å‘ç”Ÿéšå¼ç±»å‹è½¬æ¢//æ™®é€šå‡½æ•°int myAdd01(int a, int b)&#123; return a + b;&#125;//å‡½æ•°æ¨¡æ¿template&lt;class T&gt;T myAdd02(T a, T b)&#123; return a + b;&#125;void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //è‡ªåŠ¨ç±»å‹æ¨å¯¼ ä¸ä¼šå‘ç”Ÿéšå¼ç±»å‹è½¬æ¢ //cout &lt;&lt; myAdd02(a, c) &lt;&lt; endl; //æ˜¾ç¤ºæŒ‡å®šç±»å‹ ä¼šå‘ç”Ÿéšå¼ç±»å‹è½¬æ¢ cout &lt;&lt; myAdd02&lt;int&gt;(a, c) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š 109109 æ™®é€šå‡½æ•°ä¸å‡½æ•°æ¨¡æ¿çš„è°ƒç”¨è§„åˆ™è°ƒç”¨è§„åˆ™å¦‚ä¸‹ï¼š å¦‚æœå‡½æ•°æ¨¡æ¿å’Œæ™®é€šå‡½æ•°éƒ½å¯ä»¥å®ç°ï¼Œä¼˜å…ˆè°ƒç”¨æ™®é€šå‡½æ•° å¯ä»¥é€šè¿‡ç©ºæ¨¡æ¿å‚æ•°åˆ—è¡¨æ¥å¼ºåˆ¶è°ƒç”¨å‡½æ•°æ¨¡æ¿ å‡½æ•°æ¨¡æ¿ä¹Ÿå¯ä»¥å‘ç”Ÿé‡è½½ å¦‚æœå‡½æ•°æ¨¡æ¿å¯ä»¥æ›´å¥½çš„åŒ¹é…ï¼Œæœ‰é™è°ƒç”¨å‡½æ•°æ¨¡æ¿ 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//æ™®é€šå‡½æ•°ä¸å‡½æ•°æ¨¡æ¿çš„è°ƒç”¨è§„åˆ™//1ã€å¦‚æœå‡½æ•°æ¨¡æ¿å’Œæ™®é€šå‡½æ•°éƒ½å¯ä»¥è°ƒç”¨ï¼Œä¼˜å…ˆè°ƒç”¨æ™®é€šå‡½æ•°//2ã€å¯ä»¥é€šè¿‡ç©ºæ¨¡æ¿å‚æ•°åˆ—è¡¨å¼ºåˆ¶è°ƒç”¨å‡½æ•°æ¨¡æ¿//3ã€å‡½æ•°æ¨¡æ¿å¯ä»¥å‘ç”Ÿå‡½æ•°é‡è½½//4ã€å¦‚æœå‡½æ•°æ¨¡æ¿å¯ä»¥æ›´å¥½çš„åŒ¹é…ï¼Œä¼˜å…ˆè°ƒç”¨å‡½æ•°æ¨¡æ¿void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„æ™®é€šå‡½æ•°&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„æ¨¡æ¿&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; myPrint(a, b);&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š è°ƒç”¨çš„æ™®é€šå‡½æ•° 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//æ™®é€šå‡½æ•°ä¸å‡½æ•°æ¨¡æ¿çš„è°ƒç”¨è§„åˆ™//1ã€å¦‚æœå‡½æ•°æ¨¡æ¿å’Œæ™®é€šå‡½æ•°éƒ½å¯ä»¥è°ƒç”¨ï¼Œä¼˜å…ˆè°ƒç”¨æ™®é€šå‡½æ•°//2ã€å¯ä»¥é€šè¿‡ç©ºæ¨¡æ¿å‚æ•°åˆ—è¡¨å¼ºåˆ¶è°ƒç”¨å‡½æ•°æ¨¡æ¿//3ã€å‡½æ•°æ¨¡æ¿å¯ä»¥å‘ç”Ÿå‡½æ•°é‡è½½//4ã€å¦‚æœå‡½æ•°æ¨¡æ¿å¯ä»¥æ›´å¥½çš„åŒ¹é…ï¼Œä¼˜å…ˆè°ƒç”¨å‡½æ•°æ¨¡æ¿void myPrint(int a, int b);template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„æ¨¡æ¿&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; //é€šè¿‡ç©ºæ¨¡æ¿å‚æ•°åˆ—è¡¨ï¼Œå¼ºåˆ¶è°ƒç”¨å‡½æ•°æ¨¡æ¿ myPrint&lt;&gt;(a, b);&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š è°ƒç”¨çš„æ¨¡æ¿ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//æ™®é€šå‡½æ•°ä¸å‡½æ•°æ¨¡æ¿çš„è°ƒç”¨è§„åˆ™//1ã€å¦‚æœå‡½æ•°æ¨¡æ¿å’Œæ™®é€šå‡½æ•°éƒ½å¯ä»¥è°ƒç”¨ï¼Œä¼˜å…ˆè°ƒç”¨æ™®é€šå‡½æ•°//2ã€å¯ä»¥é€šè¿‡ç©ºæ¨¡æ¿å‚æ•°åˆ—è¡¨å¼ºåˆ¶è°ƒç”¨å‡½æ•°æ¨¡æ¿//3ã€å‡½æ•°æ¨¡æ¿å¯ä»¥å‘ç”Ÿå‡½æ•°é‡è½½//4ã€å¦‚æœå‡½æ•°æ¨¡æ¿å¯ä»¥æ›´å¥½çš„åŒ¹é…ï¼Œä¼˜å…ˆè°ƒç”¨å‡½æ•°æ¨¡æ¿void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„æ™®é€šå‡½æ•°&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„æ¨¡æ¿&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b, T c)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„é‡è½½æ¨¡æ¿&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; myPrint(a, b, 100);&#125;int main()&#123; test01();&#125; è¿è¡Œçš„ç»“æœä¸ºï¼š è°ƒç”¨çš„é‡è½½æ¨¡æ¿ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//æ™®é€šå‡½æ•°ä¸å‡½æ•°æ¨¡æ¿çš„è°ƒç”¨è§„åˆ™//1ã€å¦‚æœå‡½æ•°æ¨¡æ¿å’Œæ™®é€šå‡½æ•°éƒ½å¯ä»¥è°ƒç”¨ï¼Œä¼˜å…ˆè°ƒç”¨æ™®é€šå‡½æ•°//2ã€å¯ä»¥é€šè¿‡ç©ºæ¨¡æ¿å‚æ•°åˆ—è¡¨å¼ºåˆ¶è°ƒç”¨å‡½æ•°æ¨¡æ¿//3ã€å‡½æ•°æ¨¡æ¿å¯ä»¥å‘ç”Ÿå‡½æ•°é‡è½½//4ã€å¦‚æœå‡½æ•°æ¨¡æ¿å¯ä»¥æ›´å¥½çš„åŒ¹é…ï¼Œä¼˜å…ˆè°ƒç”¨å‡½æ•°æ¨¡æ¿void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„æ™®é€šå‡½æ•°&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„æ¨¡æ¿&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b, T c)&#123; cout &lt;&lt; &quot;è°ƒç”¨çš„é‡è½½æ¨¡æ¿&quot; &lt;&lt; endl;&#125;void test01()&#123; //å¦‚æœå‡½æ•°æ¨¡æ¿äº§ç”Ÿæ›´å¥½çš„åŒ¹é…ï¼Œä¼˜å…ˆè°ƒç”¨å‡½æ•°æ¨¡æ¿ char c1 = &#x27;a&#x27;; char c2 = &#x27;b&#x27;; myPrint(c1, c2);&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š è°ƒç”¨çš„æ¨¡æ¿ æ¨¡æ¿çš„å±€é™æ€§æ¨¡æ¿å¹¶ä¸æ˜¯ä¸‡èƒ½çš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//æ¨¡æ¿çš„å±€é™æ€§//æ¨¡æ¿å¹¶ä¸æ˜¯ä¸‡èƒ½çš„ï¼Œæœ‰äº›ç‰¹å®šæ•°æ®ï¼Œéœ€è¦å…·ä½“åŒ–æ–¹å¼åšç‰¹æ®Šå®ç°class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;//å¯¹æ¯”ä¸¤ä¸ªæ•°æ®æ˜¯å¦ç›¸ç­‰å‡½æ•°template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//åˆ©ç”¨å…·ä½“åŒ–Personçš„ç‰ˆæœ¬å®ç°ä»£ç ï¼Œå…·ä½“åŒ–ä¼˜å…ˆè°ƒç”¨template&lt;&gt; bool myCompare(Person&amp; a, Person&amp; b)&#123; if (a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name) return true; else return false;&#125;void test01()&#123; int a = 10; int b = 20; bool ret = myCompare(a, b); if (ret) &#123; cout &lt;&lt; &quot;a == b&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a != b&quot; &lt;&lt; endl; &#125;&#125;void test02()&#123; Person p1(&quot;Tom&quot;, 10); Person p2(&quot;Tom&quot;, 10); bool ret = myCompare(p1, p2); if (ret) &#123; cout &lt;&lt; &quot;p1 == p2&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1 != p2&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š a !&#x3D; bp1 &#x3D;&#x3D; p2 æ€»ç»“ï¼š åˆ©ç”¨å…·ä½“åŒ–çš„æ¨¡æ¿ï¼Œå¯ä»¥è§£å†³è‡ªå®šä¹‰ç±»å‹çš„é€šç”¨åŒ– å­¦ä¹ æ¨¡æ¿ä¸æ˜¯ä¸ºäº†å†™æ¨¡æ¿ï¼Œè€Œæ˜¯åœ¨STLèƒ½å¤Ÿè¿ç”¨ç³»ç»Ÿæä¾›çš„æ¨¡æ¿ ç±»æ¨¡æ¿ç±»æ¨¡æ¿è¯­æ³•ç±»æ¨¡æ¿ä½œç”¨ï¼š å»ºç«‹ä¸€ä¸ªé€šç”¨ç±»ï¼Œç±»ä¸­çš„æˆå‘˜æ•°æ®ç±»å‹å¯ä»¥ä¸å…·ä½“åˆ¶å®šï¼Œç”¨ä¸€ä¸ªè™šæ‹Ÿçš„ç±»å‹æ¥ä»£è¡¨ 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//ç±»æ¨¡æ¿template&lt;class NameType,class AgeType&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; NameType m_Name; AgeType m_Age;&#125;;void test01()&#123; Person&lt;string, int&gt; p1(&quot;å­™æ‚Ÿç©º&quot;, 999); p1.showPerson();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š name: å­™æ‚Ÿç©º age: 999 ç±»æ¨¡æ¿å’Œå‡½æ•°æ¨¡æ¿çš„åŒºåˆ«ç±»æ¨¡æ¿ä¸å‡½æ•°æ¨¡æ¿åŒºåˆ«ä¸»è¦æœ‰ä¸¤ç‚¹ ç±»æ¨¡æ¿æ²¡æœ‰è‡ªåŠ¨ç±»å‹æ¨å¯¼çš„ä½¿ç”¨æ–¹å¼ ç±»æ¨¡æ¿åœ¨æ¨¡æ¿å‚æ•°åˆ—è¡¨ä¸­å¯ä»¥æœ‰é»˜è®¤å‚æ•° 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//ç±»æ¨¡æ¿template&lt;class NameType,class AgeType = int&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; NameType m_Name; AgeType m_Age;&#125;;//1ã€ç±»æ¨¡æ¿æ²¡æœ‰è‡ªåŠ¨ç±»å‹æ¨å¯¼ä½¿ç”¨æ–¹å¼void test01()&#123; Person&lt;string&gt;p(&quot;å­™æ‚Ÿç©º&quot;, 999); p.showPerson();&#125;int main()&#123; test01();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š name: å­™æ‚Ÿç©º age: 999 ç±»æ¨¡æ¿ä¸­æˆå‘˜å‡½æ•°åˆ›å»ºæ—¶æœºç±»æ¨¡æ¿ä¸­æˆå‘˜å‡½æ•°å’Œæ™®é€šç±»ä¸­æˆå‘˜å‡½æ•°åˆ›å»ºæ—¶æœºæ˜¯æœ‰åŒºåˆ«çš„ï¼š æ™®é€šç±»ä¸­çš„æˆå‘˜ä¸€å¼€å§‹å°±å¯ä»¥åˆ›å»º ç±»æ¨¡æ¿ä¸­çš„æˆå‘˜å‡½æ•°åœ¨è°ƒç”¨æ—¶æ‰åˆ›å»º 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person1&#123;public: void showPerson1() &#123; cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl; &#125;&#125;;class Person2&#123;public: void showPerson2() &#123; cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl; &#125;&#125;;template&lt;class T&gt;class Myclass&#123;public: T obj; //ç±»æ¨¡æ¿ä¸­çš„æˆå‘˜å‡½æ•° void func1() &#123; obj.showPerson1(); &#125; void func2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123; Myclass&lt;Person1&gt;m; m.func1(); //m.func2();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Person1 show ç±»æ¨¡æ¿å¯¹è±¡åšå‡½æ•°å‚æ•°ç±»æ¨¡æ¿å®ä¾‹åŒ–å‡ºçš„å¯¹è±¡ï¼Œåƒå‡½æ•°ä¼ å‚çš„æ–¹å¼ ä¸€å…±æœ‰ä¸‰ç§ä¼ å…¥æ–¹å¼ï¼š æŒ‡å®šä¼ å…¥çš„ç±»å‹ â€“ ç›´æ¥æ˜¾ç¤ºå¯¹è±¡çš„æ•°æ®ç±»å‹ï¼ˆæœ€å¸¸ç”¨ï¼‰ å‚æ•°æ¨¡æ¿åŒ– â€“ å°†å¯¹è±¡ä¸­çš„å‚æ•°å˜ä¸ºæ¨¡æ¿è¿›è¡Œä¼ é€’ æ•´ä¸ªç±»æ¨¡æ¿åŒ– â€“ å°†è¿™ä¸ªå¯¹è±¡ç±»å‹æ¨¡æ¿åŒ–è¿›è¡Œä¼ é€’ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//ç±»æ¨¡æ¿å¯¹è±¡åšå‡½æ•°å‚æ•°template&lt;class T1,class T2&gt;class Person&#123;public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; T1 m_Name; T2 m_Age;&#125;;//1ã€æŒ‡å®šä¼ å…¥ç±»å‹void printPerson1(Person&lt;string,int&gt;&amp;p)&#123; p.showPerson();&#125;void test01()&#123; Person &lt;string, int&gt;p(&quot;å­™æ‚Ÿç©º&quot;, 999); printPerson1(p);&#125;//2ã€å‚æ•°æ¨¡æ¿åŒ–template&lt;class T1,class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; &quot;T1çš„ç±»å‹ä¸ºï¼š &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2çš„ç±»å‹ä¸ºï¼š &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123; Person&lt;string, int&gt;p(&quot;çŒªå…«æˆ’&quot;, 888); printPerson2(p);&#125;//3ã€æ•´ä¸ªç±»æ¨¡æ¿åŒ–template&lt;class T&gt;void printPerson3(T&amp; p)&#123; p.showPerson(); cout &lt;&lt; &quot;Tçš„ç±»å‹ä¸ºï¼š &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;&#125;void test03()&#123; Person&lt;string, int&gt;p(&quot;å”åƒ§&quot;, 30); printPerson3(p);&#125;int main()&#123; test01(); test02(); test03();&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åï¼š å­™æ‚Ÿç©º å¹´é¾„ï¼š 999å§“åï¼š çŒªå…«æˆ’ å¹´é¾„ï¼š 888T1çš„ç±»å‹ä¸ºï¼š class std::basic_string&lt;char,struct std::char_traits,class std::allocator &gt;T2çš„ç±»å‹ä¸ºï¼š intå§“åï¼š å”åƒ§ å¹´é¾„ï¼š 30Tçš„ç±»å‹ä¸ºï¼š class Person&lt;class std::basic_string&lt;char,struct std::char_traits,class std::allocator &gt;,int&gt; ç±»æ¨¡æ¿ä¸ç»§æ‰¿å½“ç±»æ¨¡æ¿ç¢°åˆ°ç»§æ‰¿æ—¶ï¼Œéœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š å½“å­ç±»ç»§æ‰¿çš„çˆ¶ç±»æ˜¯ä¸€ä¸ªç±»æ¨¡æ¿æ—¶ï¼Œå­ç±»åœ¨å£°æ˜çš„æ—¶å€™ï¼Œè¦æŒ‡å®šå‡ºçˆ¶ç±»ä¸­Tçš„ç±»å‹ å¦‚æœä¸æŒ‡å®šï¼Œç¼–è¯‘å™¨æ— æ³•ç»™å­ç±»åˆ†é…å†…å­˜ å¦‚æœæƒ³çµæ´»æŒ‡å®šå‡ºçˆ¶ç±»ä¸­Tçš„ç±»å‹ï¼Œå­ç±»ä¹Ÿéœ€å˜ä¸ºç±»æ¨¡æ¿ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//ç±»æ¨¡æ¿ä¸ç»§æ‰¿template&lt;class T&gt;class Base&#123; T m;&#125;;class Son :public Base&lt;int&gt;//å¿…é¡»è¦æŒ‡å¯¼çˆ¶ç±»ä¸­çš„ç±»å‹ï¼Œæ‰èƒ½ç»§æ‰¿ç»™å­ç±»&#123;&#125;;void test01()&#123; Son s1;&#125;//å¦‚æœæƒ³çµæ´»æŒ‡å®šçˆ¶ç±»ä¸­Tçš„ç±»å‹ï¼Œå­ç±»ä¹Ÿéœ€è¦å˜ä¸ºç±»æ¨¡æ¿template&lt;class T1,class T2&gt;class Son2 :public Base&lt;T2&gt;&#123; public: Son2() &#123; cout &lt;&lt; &quot;T1çš„ç±»å‹ä¸ºï¼š &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2çš„ç±»å‹ä¸ºï¼š &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125; T1 obj;&#125;;void test02()&#123; Son2&lt;int, char&gt;s2;&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š T1çš„ç±»å‹ä¸ºï¼š intT2çš„ç±»å‹ä¸ºï¼š char ç±»æ¨¡æ¿æˆå‘˜å‡½æ•°ç±»å¤–å®ç°å­¦ä¹ ç›®æ ‡ï¼šèƒ½å¤ŸæŒæ¡ç±»æ¨¡æ¿ä¸­çš„æˆå‘˜å‡½æ•°çš„ç±»å¤–å®ç° 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//ç±»æ¨¡æ¿æˆå‘˜å‡½æ•°ç±»å¤–å®ç°template&lt;class T1,class T2&gt;class Person&#123;public: Person(T1 name, T2 age); void showPerson(); T1 m_Name; T2 m_Age;&#125;;//æ„é€ å‡½æ•°çš„ç±»å¤–å®ç°template&lt;class T1,class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//æˆå‘˜å‡½æ•°çš„ç±»å¤–å®ç°template&lt;class T1,class T2&gt;void Person&lt;T1, T2&gt;::showPerson()&#123; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123; Person&lt;string, int&gt; P(&quot;Tom&quot;, 20); P.showPerson();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åï¼š Tom å¹´é¾„ï¼š 20 ç±»æ¨¡æ¿åˆ†æ–‡ä»¶ç¼–å†™æŒæ¡ç±»æ¨¡æ¿æˆå‘˜å‡½æ•°åˆ†æ–‡ä»¶ç¼–å†™äº§ç”Ÿçš„é—®é¢˜ä»¥åŠè§£å†³æ–¹å¼ é—®é¢˜ï¼š ç±»æ¨¡æ¿ä¸­æˆå‘˜å‡½æ•°åˆ›å»ºæ—¶æœºæ˜¯åœ¨è°ƒç”¨é˜¶æ®µï¼Œå¯¼è‡´åˆ†æ–‡ä»¶ç¼–å†™æ—¶é“¾æ¥ä¸åˆ° è§£å†³ï¼š è§£å†³æ–¹å¼1ï¼šç›´æ¥åŒ…å«.cppæºæ–‡ä»¶ è§£å†³æ–¹å¼2ï¼šå°†å£°æ˜å’Œå®ç°å†™åˆ°åŒä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œå¹¶æ›´æ”¹åç¼€åä¸º.hppï¼Œhppæ˜¯çº¦å®šçš„åç§°ï¼Œå¹¶ä¸æ˜¯å¼ºåˆ¶ person.h 123456789101112#pragma once#include&lt;iostream&gt;using namespace std;template&lt;class T1, class T2&gt;class Person&#123;public: Person(T1 name, T2 age); void showPerson(); T1 m_Name; T2 m_Age;&#125;; test.cpp 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include&lt;string&gt;//ç¬¬ä¸€ç§è§£å†³æ–¹å¼ï¼Œç›´æ¥åŒ…å«æºæ–‡ä»¶#include&quot;person.cpp&quot;//ç¬¬äºŒç§è§£å†³æ–¹å¼ï¼Œå°†.hå’Œ.cppä¸­çš„å†…å®¹å†™åˆ°ä¸€èµ·ï¼Œå°†æ–‡ä»¶å‘½åä¸º.hppæ–‡ä»¶using namespace std;//ç±»æ¨¡æ¿ä»½åˆ†æ–‡ä»¶ç¼–å†™é—®é¢˜ä»¥åŠè§£å†³//template&lt;class T1,class T2&gt;//class Person//&#123;//public:// Person(T1 name, T2 age);// void showPerson();// T1 m_Name;// T2 m_Age;//&#125;;//template&lt;class T1,class T2&gt;//Person&lt;T1, T2&gt;::Person(T1 name, T2 age)//&#123;// this-&gt;m_Name = name;// this-&gt;m_Age = age;//&#125;//template&lt;class T1,class T2&gt;//void Person&lt;T1,T2&gt;::showPerson()//&#123;// cout &lt;&lt; &quot;å§“åï¼š&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; å¹´é¾„ï¼š&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//&#125;void test01()&#123; Person&lt;string, int&gt; p(&quot;Jerry&quot;, 18); p.showPerson();&#125;int main()&#123; test01();&#125; person.cpp 123456789101112131415#include&lt;iostream&gt;#include&quot;person.h&quot;template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson()&#123; cout &lt;&lt; &quot;å§“åï¼š&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; å¹´é¾„ï¼š&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125; ç±»æ¨¡æ¿å’Œå‹å…ƒæŒæ¡ç±»æ¨¡æ¿é…åˆå‹å…ƒå‡½æ•°çš„ç±»å†…å’Œç±»å¤–å®ç° å…¨å±€å‡½æ•°ç±»å†…å®ç° - ç›´æ¥åœ¨ç±»å†…å£°æ˜å‹å…ƒå³å¯ å…¨å±€å‡½æ•°ç±»å¤–å®ç° - éœ€è¦æå‰è®©ç¼–è¯‘å™¨çŸ¥é“å…¨å±€å‡½æ•°çš„å­˜åœ¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//é€šè¿‡å…¨å±€å‡½æ•° æ‰“å°Personä¿¡æ¯//æå‰è®©ç¼–è¯‘å™¨çŸ¥é“Personç±»å­˜åœ¨template&lt;class T1, class T2&gt;class Person;//ç±»å¤–å®ç°template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;p)&#123; cout &lt;&lt; &quot;ç±»å¤–å®ç° -- å§“åï¼š &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1,class T2&gt;class Person&#123; //å…¨å±€å‡½æ•° ç±»å†…å®ç° friend void printPerson1(Person&lt;T1, T2&gt; p) &#123; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //å…¨å±€å‡½æ•° ç±»å¤–å®ç° //åŠ ç©ºæ¨¡æ¿å‚æ•°åˆ—è¡¨ //å¦‚æœå…¨å±€å‡½æ•°æ˜¯ç±»å¤–å®ç°ï¼Œéœ€è¦è®©ç¼–è¯‘å™¨æå‰çŸ¥é“è¿™ä¸ªå‡½æ•°çš„å­˜åœ¨ friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; p);public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;private: T1 m_Name; T2 m_Age;&#125;;//1ã€å…¨å±€å‡½æ•°åœ¨ç±»å†…å®ç°void test01()&#123; Person&lt;string, int&gt;p(&quot;Tom&quot;, 20); printPerson1(p);&#125;//2ã€å…¨å±€å‡½æ•°åœ¨ç±»å¤–å®ç°void test02()&#123; Person&lt;string, int&gt;p(&quot;Tom&quot;, 20); printPerson2(p);&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åï¼š Tom å¹´é¾„ï¼š 20ç±»å¤–å®ç° â€“ å§“åï¼š Tom å¹´é¾„ï¼š 20 ç±»æ¨¡æ¿æ¡ˆä¾‹å®ç°ä¸€ä¸ªé€šç”¨çš„æ•°ç»„ç±»ï¼Œè¦æ±‚å¦‚ä¸‹ï¼š å¯ä»¥å¯¹å†…ç½®çš„æ•°æ®ç±»å‹ä»¥åŠè‡ªå®šä¹‰æ•°æ®ç±»å‹çš„æ•°æ®è¿›è¡Œå­˜å‚¨ å°†æ•°ç»„ä¸­çš„æ•°æ®å­˜å‚¨åˆ°å †åŒº æ„é€ å‡½æ•°ä¸­å¯ä»¥ä¼ å…¥æ•°ç»„çš„å®¹é‡ æä¾›å¯¹åº”çš„æ‹·è´æ„é€ å‡½æ•°ä»¥åŠoperator&#x3D;é˜²æ­¢æµ…æ‹·è´é—®é¢˜ æä¾›å°¾æ’æ³•å’Œå°¾åˆ æ³•å¯¹æ•°ç»„ä¸­çš„æ•°æ®è¿›è¡Œå¢åŠ å’Œåˆ é™¤ å¯ä»¥é€šè¿‡ä¸‹æ ‡çš„æ–¹å¼è®¿é—®æ•°ç»„ä¸­çš„å…ƒç´  å¯ä»¥è·å–æ•°ç»„ä¸­å½“å‰å…ƒç´ ä¸ªæ•°å’Œæ•°ç»„çš„å®¹é‡ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include&lt;string&gt;#include &quot;MyArray.hpp&quot;using namespace std;void printIntArray(MyArray&lt;int&gt;&amp;arr)&#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;//æµ‹è¯•è‡ªå®šä¹‰æ•°æ®ç±»å‹class Person&#123;public: Person() &#123;&#125;; Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; arr)&#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; arr[i].m_Name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; arr[i].m_Age &lt;&lt; endl; &#125;&#125;void test01()&#123; MyArray&lt;int&gt;arr1(5); for (int i = 0; i &lt; 5; i++) &#123; arr1.push_back(i); &#125; cout &lt;&lt; &quot;arr1çš„æ‰“å°è¾“å‡ºä¸ºï¼š &quot; &lt;&lt; endl; printIntArray(arr1); cout &lt;&lt; &quot;arr1çš„å®¹é‡ä¸ºï¼š &quot; &lt;&lt; arr1.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;arr1çš„å¤§å°ä¸ºï¼š &quot; &lt;&lt; arr1.getSize() &lt;&lt; endl; MyArray&lt;int&gt;arr2(arr1); cout &lt;&lt; &quot;arr2çš„æ‰“å°è¾“å‡ºä¸ºï¼š &quot; &lt;&lt; endl; printIntArray(arr2); //å°¾åˆ  arr2.pop_back(); cout &lt;&lt; &quot;arr2å°¾åˆ åçš„æ‰“å°è¾“å‡ºä¸ºï¼š &quot; &lt;&lt; endl; printIntArray(arr2); MyArray&lt;int&gt;arr3(100); arr3 = arr1;&#125;void test02()&#123; MyArray&lt;Person&gt;arr(10); Person p1(&quot;åˆ˜å¤‡&quot;, 999); Person p2(&quot;å…³ç¾½&quot;, 800); Person p3(&quot;å¼ é£&quot;, 700); Person p4(&quot;èµµäº‘&quot;, 800); Person p5(&quot;è¯¸è‘›äº®&quot;, 800); //å°†æ•°æ®æ’å…¥åˆ°æ•°ç»„ä¸­ arr.push_back(p1); arr.push_back(p2); arr.push_back(p3); arr.push_back(p4); arr.push_back(p5); cout &lt;&lt; &quot;arrçš„æ‰“å°è¾“å‡ºä¸ºï¼š&quot; &lt;&lt; endl; printPersonArray(arr); cout &lt;&lt; &quot;arrçš„å®¹é‡ä¸ºï¼š &quot; &lt;&lt; arr.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;arrçš„å¤§å°ä¸ºï¼š &quot; &lt;&lt; arr.getSize() &lt;&lt; endl; arr.pop_back(); cout &lt;&lt; &quot;arrå°¾åˆ åçš„æ‰“å°è¾“å‡ºä¸ºï¼š &quot; &lt;&lt; endl; printPersonArray(arr);&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š MyArrayçš„æœ‰å‚æ„é€ è°ƒç”¨arr1çš„æ‰“å°è¾“å‡ºä¸ºï¼š01234arr1çš„å®¹é‡ä¸ºï¼š 5arr1çš„å¤§å°ä¸ºï¼š 5MyArrayçš„æ‹·è´æ„é€ è°ƒç”¨arr2çš„æ‰“å°è¾“å‡ºä¸ºï¼š01234arr2å°¾åˆ åçš„æ‰“å°è¾“å‡ºä¸ºï¼š0123MyArrayçš„æœ‰å‚æ„é€ è°ƒç”¨MyArrayçš„operator&#x3D;è°ƒç”¨MyArrayçš„ææ„å‡½æ•°è°ƒç”¨MyArrayçš„ææ„å‡½æ•°è°ƒç”¨MyArrayçš„ææ„å‡½æ•°è°ƒç”¨MyArrayçš„æœ‰å‚æ„é€ è°ƒç”¨arrçš„æ‰“å°è¾“å‡ºä¸ºï¼šå§“åï¼š åˆ˜å¤‡ å¹´é¾„ï¼š 999å§“åï¼š å…³ç¾½ å¹´é¾„ï¼š 800å§“åï¼š å¼ é£ å¹´é¾„ï¼š 700å§“åï¼š èµµäº‘ å¹´é¾„ï¼š 800å§“åï¼š è¯¸è‘›äº® å¹´é¾„ï¼š 800arrçš„å®¹é‡ä¸ºï¼š 10arrçš„å¤§å°ä¸ºï¼š 5arrå°¾åˆ åçš„æ‰“å°è¾“å‡ºä¸ºï¼šå§“åï¼š åˆ˜å¤‡ å¹´é¾„ï¼š 999å§“åï¼š å…³ç¾½ å¹´é¾„ï¼š 800å§“åï¼š å¼ é£ å¹´é¾„ï¼š 700å§“åï¼š èµµäº‘ å¹´é¾„ï¼š 800MyArrayçš„ææ„å‡½æ•°è°ƒç”¨","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  æ–‡ä»¶æ“ä½œ","slug":"C++-å­¦ä¹ -æ–‡ä»¶æ“ä½œ","date":"2023-05-05T11:24:25.000Z","updated":"2023-05-09T08:11:31.953Z","comments":true,"path":"2023/05/05/C++-å­¦ä¹ -æ–‡ä»¶æ“ä½œ/","link":"","permalink":"http://example.com/2023/05/05/C++-%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"ç¨‹åºè¿è¡Œæ—¶äº§ç”Ÿçš„æ•°æ®éƒ½å±äºä¸´æ—¶æ•°æ®ï¼Œç¨‹åºä¸€æ—¦è¿è¡Œç»“æŸéƒ½ä¼šè¢«é‡Šæ”¾ é€šè¿‡æ–‡ä»¶å¯ä»¥å°†æ•°æ®æŒä¹…åŒ– C++ä¸­å¯¹æ–‡ä»¶æ“ä½œéœ€è¦åŒ…å«å¤´æ–‡ä»¶","text":"ç¨‹åºè¿è¡Œæ—¶äº§ç”Ÿçš„æ•°æ®éƒ½å±äºä¸´æ—¶æ•°æ®ï¼Œç¨‹åºä¸€æ—¦è¿è¡Œç»“æŸéƒ½ä¼šè¢«é‡Šæ”¾ é€šè¿‡æ–‡ä»¶å¯ä»¥å°†æ•°æ®æŒä¹…åŒ– C++ä¸­å¯¹æ–‡ä»¶æ“ä½œéœ€è¦åŒ…å«å¤´æ–‡ä»¶ æ–‡ä»¶ç±»å‹åˆ†ç±»ä¸¤ç§ï¼š æ–‡æœ¬æ–‡ä»¶ - æ–‡ä»¶ä»¥æ–‡æœ¬çš„ASCIIç å½¢å¼å­˜å‚¨åœ¨è®¡ç®—æœºä¸­ äºŒè¿›åˆ¶æ–‡ä»¶ - æ–‡ä»¶ä»¥æ–‡æœ¬çš„äºŒè¿›åˆ¶å½¢å¼å­˜å‚¨åœ¨è®¡ç®—æœºä¸­ï¼Œç”¨æˆ·ä¸€èˆ¬ä¸èƒ½ç›´æ¥è¯»æ‡‚å®ƒä»¬ æ“ä½œæ–‡ä»¶çš„ä¸‰å¤§ç±»ï¼š ofstream - å†™æ“ä½œ ifstream - è¯»æ“ä½œ fstream - è¯»å†™æ“ä½œ æ–‡æœ¬æ–‡ä»¶å†™æ–‡ä»¶å†™æ–‡ä»¶æ­¥éª¤ åŒ…å«å¤´æ–‡ä»¶ 1#include&lt;fstream&gt; åˆ›å»ºæµå¯¹è±¡ 1ofstream ofs; æ‰“å¼€æ–‡ä»¶ 1ofs.open(&quot;æ–‡ä»¶è·¯å¾„&quot;,æ‰“å¼€æ–¹å¼); å†™æ•°æ® 1ofs&lt;&lt;&quot;å†™å…¥çš„æ•°æ®&quot;; å…³é—­æ–‡ä»¶ 1ofs.close(); æ–‡ä»¶æ‰“å¼€æ–¹å¼ æ‰“å¼€æ–¹å¼ è§£é‡Š ios::in ä¸ºè¯»æ–‡ä»¶è€Œæ‰“å¼€æ–‡ä»¶ ios::out ä¸ºå†™æ–‡ä»¶æ‰“å¼€æ–‡ä»¶ ios::ate åˆå§‹ä½ç½®ï¼šæ–‡ä»¶å°¾ ios::app è¿½åŠ æ–¹å¼å†™æ–‡ä»¶ ios::trunc å¦‚æœæ–‡ä»¶å­˜åœ¨å…ˆåˆ é™¤ï¼Œå†åˆ›å»º ios::binary äºŒè¿›åˆ¶æ–¹å¼ æ³¨æ„ï¼šæ–‡ä»¶æ‰“å¼€æ–¹å¼å¯ä»¥é…åˆä½¿ç”¨ï¼Œåˆ©ç”¨|æ“ä½œç¬¦ ä¾‹å¦‚ï¼šç”¨äºŒè¿›åˆ¶æ–¹å¼å†™æ–‡ä»¶ ios::binary | ios::out æ¡ˆä¾‹12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;fstream&gt;using namespace std;//æ–‡æœ¬æ–‡ä»¶ å†™æ–‡ä»¶void test01()&#123; //1ã€åŒ…å«å¤´æ–‡ä»¶fstream //2ã€åˆ›å»ºæµå¯¹è±¡ ofstream ofs; //3ã€æŒ‡å®šæ‰“å¼€æ–¹å¼ ofs.open(&quot;text.txt&quot;, ios::out); //4ã€å†™å†…å®¹ ofs &lt;&lt; &quot;å§“åï¼šå¼ ä¸‰&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;æ€§åˆ«ï¼šç”·&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;å¹´é¾„ï¼š18&quot; &lt;&lt; endl; //5ã€å…³é—­æ–‡ä»¶ ofs.close();&#125;int main()&#123; test01();&#125; æ–‡ä»¶æ“ä½œå¿…é¡»åŒ…å«å¤´æ–‡ä»¶fstream è¯»æ–‡ä»¶å¯ä»¥åˆ©ç”¨ofstreamï¼Œæˆ–è€…fstreamç±» æ‰“å¼€æ–‡ä»¶æ—¶éœ€è¦æŒ‡å®šæ“ä½œæ–‡ä»¶çš„è·¯å¾„ï¼Œä»¥åŠæ‰“å¼€æ–¹å¼ åˆ©ç”¨&lt;&lt;å¯ä»¥å‘æ–‡ä»¶ä¸­å†™æ•°æ® æ“ä½œå®Œæ¯•ï¼Œè¦å…³é—­æ–‡ä»¶ è¯»æ–‡ä»¶è¯»æ–‡ä»¶æ­¥éª¤ åŒ…å«å¤´æ–‡ä»¶ 1#include&lt;fstream&gt; åˆ›å»ºæµå¯¹è±¡ 1ifstream ifs; æ‰“å¼€æ–‡ä»¶å¹¶åˆ¤æ–­æ–‡ä»¶æ˜¯å¦æ‰“å¼€æˆåŠŸ 1ifs.open(&quot;æ–‡ä»¶è·¯å¾„&quot;,æ‰“å¼€æ–¹å¼); è¯»æ•°æ® å››ç§æ–¹å¼è¯»å– å…³é—­æ–‡ä»¶ 1ifs.close(); æ¡ˆä¾‹12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//æ–‡æœ¬æ–‡ä»¶ è¯»æ–‡ä»¶void test01()&#123; //1ã€åŒ…å«å¤´æ–‡ä»¶fstream //2ã€åˆ›å»ºæµå¯¹è±¡ ifstream ifs; //3ã€æ‰“å¼€æ–‡ä»¶ å¹¶ä¸”åˆ¤æ–­æ˜¯å¦æ‰“å¼€æˆåŠŸ ifs.open(&quot;text.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;æ–‡ä»¶æ‰“å¼€å¤±è´¥&quot; &lt;&lt; endl; return; &#125; //4ã€è¯»æ•°æ® cout &lt;&lt; &quot;ç¬¬ä¸€ç§è¯»æ•°æ®--------------&quot; &lt;&lt; endl; char buf[1024] = &#123; 0 &#125;; while (ifs &gt;&gt; buf) &#123; cout &lt;&lt; buf &lt;&lt; endl; &#125; cout &lt;&lt; &quot;ç¬¬äºŒç§è¯»æ•°æ®--------------&quot; &lt;&lt; endl; char buf1[1024] = &#123; 0 &#125;; while (ifs.getline(buf1, sizeof(buf1))) &#123; cout&lt;&lt;buf1&lt;&lt;endl; &#125; cout &lt;&lt; &quot;ç¬¬ä¸‰ç§è¯»æ•°æ®--------------&quot; &lt;&lt; endl; string buf2; while (getline(ifs, buf2)) &#123; cout &lt;&lt; buf2 &lt;&lt; endl; &#125; cout &lt;&lt; &quot;ç¬¬å››ç§è¯»æ•°æ®--------------&quot; &lt;&lt; endl; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; //5ã€å…³é—­æ–‡ä»¶ ifs.close();&#125;int main()&#123; test01();&#125; è¯»æ–‡ä»¶å¯ä»¥åˆ©ç”¨ifstreamï¼Œæˆ–è€…fstreamç±» åˆ©ç”¨is_openå‡½æ•°å¯ä»¥åˆ¤æ–­æ–‡ä»¶æ˜¯å¦æ‰“å¼€æˆåŠŸ closeå…³é—­æ–‡ä»¶ äºŒè¿›åˆ¶æ–‡ä»¶ä»¥äºŒè¿›åˆ¶çš„æ–¹å¼å¯¹æ–‡ä»¶è¿›è¡Œè¯»å†™æ“ä½œ æ‰“å¼€æ–¹å¼è¦æŒ‡å®šä¸ºios::bianary å†™æ–‡ä»¶äºŒè¿›åˆ¶æ–¹å¼å†™æ–‡ä»¶ä¸»è¦åˆ©ç”¨æµå¯¹è±¡è°ƒç”¨æˆå‘˜å‡½æ•°write å‡½æ•°åŸå‹ï¼šostream&amp; write(const char* buffer,int len); å‚æ•°è§£é‡Šï¼šå­—ç¬¦æŒ‡é’ˆbufferæŒ‡å‘å†…å­˜ä¸­ä¸€æ®µå­˜å‚¨ç©ºé—´ã€‚lenæ˜¯è¯»å†™çš„å­—èŠ‚æ•° 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//äºŒè¿›åˆ¶æ–‡ä»¶ å†™æ–‡ä»¶class Person&#123;public: char m_Name[64];//å§“å int m_Age;//å¹´é¾„&#125;;void test01()&#123; //1ã€åŒ…å«å¤´æ–‡ä»¶ //2ã€åˆ›å»ºæµå¯¹è±¡ ofstream ofs; //3ã€æ‰“å¼€æ–‡ä»¶ ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); //4ã€å†™æ–‡ä»¶ Person p = &#123; &quot;å¼ ä¸‰&quot;,18 &#125;; ofs.write((const char*)&amp;p, sizeof(Person)); //5ã€å…³é—­æ–‡ä»¶ ofs.close();&#125;int main()&#123; test01();&#125; æ–‡ä»¶è¾“å‡ºæµå¯¹è±¡å¯ä»¥é€šè¿‡writeå‡½æ•°ï¼Œä»¥äºŒè¿›åˆ¶æ–¹å¼å†™å‡½æ•° è¯»æ–‡ä»¶äºŒè¿›åˆ¶æ–¹å¼è¯»æ–‡ä»¶ä¸»è¦åˆ©ç”¨æµå¯¹è±¡è°ƒç”¨æˆå‘˜å‡½æ•°read å‡½æ•°åŸå‹ï¼šistream&amp; read(char* buffer,int len); å‚æ•°è§£é‡Šï¼šå­—ç¬¦æŒ‡é’ˆbufferæŒ‡å‘å†…å­˜ä¸­ä¸€æ®µå­˜å‚¨ç©ºé—´ï¼Œlenæ˜¯è¯»å†™çš„å­—èŠ‚æ•° 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//äºŒè¿›åˆ¶æ–‡ä»¶ è¯»æ–‡ä»¶class Person&#123;public: char m_Name[64];//å§“å int m_Age;//å¹´é¾„&#125;;void test01()&#123; //1ã€åŒ…å«å¤´æ–‡ä»¶ //2ã€åˆ›å»ºæµå¯¹è±¡ ifstream ifs; //3ã€æ‰“å¼€æ–‡ä»¶ åˆ¤æ–­æ–‡ä»¶æ˜¯å¦æ‰“å¼€æˆåŠŸ ifs.open(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;æ–‡ä»¶æ‰“å¼€å¤±è´¥&quot; &lt;&lt; endl; return; &#125; //4ã€è¯»æ–‡ä»¶ Person p; ifs.read((char*)&amp;p, sizeof(Person)); cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; p.m_Age &lt;&lt; endl; //5ã€å…³é—­æ–‡ä»¶ ifs.close();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åï¼š å¼ ä¸‰ å¹´é¾„ï¼š 18","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ è¿›ç¨‹ä½¿ç”¨","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-è¿›ç¨‹ä½¿ç”¨","date":"2023-05-04T08:37:55.000Z","updated":"2023-05-14T07:18:27.521Z","comments":true,"path":"2023/05/04/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-è¿›ç¨‹ä½¿ç”¨/","link":"","permalink":"http://example.com/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/","excerpt":"è¿›ç¨‹æ¦‚è¿°ç¨‹åºå’Œè¿›ç¨‹ç¨‹åº","text":"è¿›ç¨‹æ¦‚è¿°ç¨‹åºå’Œè¿›ç¨‹ç¨‹åºç¨‹åºæ˜¯åŒ…å«ä¸€ç³»åˆ—ä¿¡æ¯çš„æ–‡ä»¶ï¼Œè¿™äº›ä¿¡æ¯æè¿°äº†å¦‚ä½•åœ¨è¿è¡Œæ—¶åˆ›å»ºä¸€ä¸ªè¿›ç¨‹ï¼š äºŒè¿›åˆ¶æ ¼å¼æ ‡è¯†ï¼šæ¯ä¸ªç¨‹åºæ–‡ä»¶éƒ½åŒ…å«ç”¨äºæè¿°å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼çš„å…ƒä¿¡æ¯ã€‚å†…æ ¸åˆ©ç”¨æ­¤ä¿¡æ¯æ¥è§£é‡Šæ–‡ä»¶ä¸­çš„å…¶ä»–ä¿¡æ¯ã€‚ï¼ˆELFå¯æ‰§è¡Œè¿æ¥æ ¼å¼ï¼‰ æœºå™¨è¯­è¨€æŒ‡ä»¤ï¼šå¯¹ç¨‹åºç®—æ³•è¿›è¡Œç¼–ç ã€‚ ç¨‹åºå…¥å£åœ°å€ï¼šæ ‡è¯†ç¨‹åºå¼€å§‹æ‰§è¡Œæ—¶çš„èµ·å§‹æŒ‡ä»¤ä½ç½®ã€‚ æ•°æ®ï¼šç¨‹åºæ–‡ä»¶åŒ…å«çš„å˜é‡åˆå§‹å€¼å’Œç¨‹åºä½¿ç”¨çš„å­—é¢é‡å€¼ï¼ˆæ¯”å¦‚å­—ç¬¦ä¸²ï¼‰ã€‚ ç¬¦å·è¡¨åŠé‡å®šä½è¡¨ï¼šæè¿°ç¨‹åºä¸­å‡½æ•°å’Œå˜é‡çš„ä½ç½®åŠåç§°ã€‚è¿™äº›è¡¨æ ¼æœ‰å¤šé‡ç”¨é€”ï¼Œå…¶ä¸­åŒ…æ‹¬è°ƒè¯•å’Œè¿è¡Œæ—¶çš„ç¬¦å·è§£æï¼ˆåŠ¨æ€é“¾æ¥ï¼‰ã€‚ å…±äº«åº“å’ŒåŠ¨æ€é“¾æ¥ä¿¡æ¯ï¼šç¨‹åºæ–‡ä»¶æ‰€åŒ…å«çš„ä¸€äº›å­—æ®µï¼Œåˆ—å‡ºäº†ç¨‹åºè¿è¡Œæ—¶éœ€è¦ä½¿ç”¨çš„å…±äº«åº“ï¼Œä»¥åŠåŠ è½½å…±äº«åº“çš„åŠ¨æ€è¿æ¥å™¨çš„è·¯å¾„åã€‚ å…¶ä»–ä¿¡æ¯ï¼šç¨‹åºæ–‡ä»¶è¿˜åŒ…å«è®¸å¤šå…¶ä»–ä¿¡æ¯ï¼Œç”¨ä»¥æè¿°å¦‚ä½•åˆ›å»ºè¿›ç¨‹ è¿›ç¨‹è¿›ç¨‹æ˜¯æ­£åœ¨è¿è¡Œçš„ç¨‹åºçš„å®ä¾‹ã€‚æ˜¯ä¸€ä¸ªå…·æœ‰ä¸€å®šç‹¬ç«‹åŠŸèƒ½çš„ç¨‹åºå…³äºæŸä¸ªæ•°æ®é›†åˆçš„ä¸€æ¬¡è¿è¡Œæ´»åŠ¨ã€‚å®ƒæ˜¯æ“ä½œç³»ç»ŸåŠ¨æ€æ‰§è¡Œçš„åŸºæœ¬å•å…ƒï¼Œåœ¨ä¼ ç»Ÿçš„æ“ä½œç³»ç»Ÿä¸­ï¼Œè¿›ç¨‹æ—¢æ˜¯åŸºæœ¬çš„åˆ†é…å•å…ƒï¼Œä¹Ÿæ˜¯åŸºæœ¬çš„æ‰§è¡Œå•å…ƒã€‚ ç¨‹åºå’Œè¿›ç¨‹çš„å…³ç³»å¯ä»¥ç”¨ä¸€ä¸ªç¨‹åºæ¥åˆ›å»ºå¤šä¸ªè¿›ç¨‹ï¼Œè¿›ç¨‹æ˜¯ç”±å†…æ ¸å®šä¹‰çš„æŠ½è±¡å®ä½“ï¼Œå¹¶ä¸ºè¯¥å®ä½“åˆ†é…ç”¨ä»¥æ‰§è¡Œç¨‹åºçš„å„é¡¹ç³»ç»Ÿèµ„æºã€‚ä»å†…æ ¸çš„è§’åº¦çœ‹ï¼Œè¿›ç¨‹ç”±ç”¨æˆ·å†…å­˜ç©ºé—´å’Œä¸€ç³»åˆ—å†…æ ¸æ•°æ®ç»“æ„ç»„æˆï¼Œå…¶ä¸­ç”¨æˆ·å†…å­˜ç©ºé—´åŒ…å«äº†ç¨‹åºä»£ç åŠä»£ç æ‰€ä½¿ç”¨çš„å˜é‡ï¼Œè€Œå†…æ ¸æ•°æ®ç»“æ„åˆ™ç”¨äºç»´æŠ¤è¿›ç¨‹çŠ¶æ€ä¿¡æ¯ã€‚è®°å½•åœ¨å†…æ ¸æ•°æ®ç»“æ„ä¸­çš„ä¿¡æ¯åŒ…æ‹¬è®¸å¤šä¸è¿›ç¨‹ç›¸å…³çš„æ ‡è¯†å·ï¼ˆIDsï¼‰ã€è™šæ‹Ÿå†…å­˜è¡¨ã€æ‰“å¼€æ–‡ä»¶çš„æè¿°ç¬¦è¡¨ã€ä¿¡å·ä¼ é€’åŠå¤„ç†çš„æœ‰å…³ä¿¡æ¯ã€è¿›ç¨‹èµ„æºä½¿ç”¨åŠé™åˆ¶ã€å½“å‰å·¥ä½œç›®å½•å’Œå¤§é‡çš„å…¶ä»–ä¿¡æ¯ å•é“ã€å¤šé“ç¨‹åºè®¾è®¡ å•é“ç¨‹åºï¼Œå³åœ¨è®¡ç®—æœºå†…å­˜ä¸­åªå…è®¸ä¸€ä¸ªçš„ç¨‹åºè¿è¡Œã€‚ å¤šé“ç¨‹åºè®¾è®¡æŠ€æœ¯æ˜¯åœ¨è®¡ç®—æœºå†…å­˜ä¸­åŒæ—¶å­˜æ”¾å‡ é“ç›¸äº’ç‹¬ç«‹çš„ç¨‹åºï¼Œä½¿å®ƒä»¬åœ¨ç®¡ç†ç¨‹åºæ§åˆ¶ä¸‹ï¼Œç›¸äº’ç©¿æ’è¿è¡Œï¼Œä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šç¨‹åºåœ¨è®¡ç®—æœºç³»ç»Ÿä¸­åŒå¤„äºå¼€å§‹åˆ°ç»“æŸä¹‹é—´çš„çŠ¶æ€, è¿™äº›ç¨‹åºå…±äº«è®¡ç®—æœºç³»ç»Ÿèµ„æºã€‚å¼•å…¥å¤šé“ç¨‹åºè®¾è®¡æŠ€æœ¯çš„æ ¹æœ¬ç›®çš„æ˜¯ä¸ºäº†æé«˜ CPU çš„åˆ©ç”¨ç‡ã€‚ å¯¹äºä¸€ä¸ªå• CPU ç³»ç»Ÿæ¥è¯´ï¼Œç¨‹åºåŒæ—¶å¤„äºè¿è¡ŒçŠ¶æ€åªæ˜¯ä¸€ç§å®è§‚ä¸Šçš„æ¦‚å¿µï¼Œä»–ä»¬è™½ç„¶éƒ½å·²ç»å¼€å§‹è¿è¡Œï¼Œä½†å°±å¾®è§‚è€Œè¨€ï¼Œä»»æ„æ—¶åˆ»ï¼ŒCPU ä¸Šè¿è¡Œçš„ç¨‹åºåªæœ‰ä¸€ä¸ªã€‚ åœ¨å¤šé“ç¨‹åºè®¾è®¡æ¨¡å‹ä¸­ï¼Œå¤šä¸ªè¿›ç¨‹è½®æµä½¿ç”¨ CPUã€‚è€Œå½“ä¸‹å¸¸è§ CPU ä¸ºçº³ç§’çº§ï¼Œ1ç§’å¯ä»¥æ‰§è¡Œå¤§çº¦ 10 äº¿æ¡æŒ‡ä»¤ã€‚ç”±äºäººçœ¼çš„ååº”é€Ÿåº¦æ˜¯æ¯«ç§’çº§ï¼Œæ‰€ä»¥çœ‹ä¼¼åŒæ—¶åœ¨è¿è¡Œã€‚ æ—¶é—´ç‰‡ æ—¶é—´ç‰‡ï¼ˆtimesliceï¼‰åˆç§°ä¸ºâ€œé‡å­ï¼ˆquantumï¼‰â€æˆ–â€œå¤„ç†å™¨ç‰‡ï¼ˆprocessor sliceï¼‰â€æ˜¯æ“ä½œç³»ç»Ÿåˆ†é…ç»™æ¯ä¸ªæ­£åœ¨è¿è¡Œçš„è¿›ç¨‹å¾®è§‚ä¸Šçš„ä¸€æ®µ CPU æ—¶é—´ã€‚äº‹å®ä¸Šï¼Œè™½ç„¶ä¸€å°è®¡ç®—æœºé€šå¸¸å¯èƒ½æœ‰å¤šä¸ª CPUï¼Œä½†æ˜¯åŒä¸€ä¸ª CPU æ°¸è¿œä¸å¯èƒ½çœŸæ­£åœ°åŒæ—¶è¿è¡Œå¤šä¸ªä»»åŠ¡ã€‚åœ¨åªè€ƒè™‘ä¸€ä¸ª CPU çš„æƒ…å†µä¸‹ï¼Œè¿™äº›è¿›ç¨‹â€œçœ‹èµ·æ¥åƒâ€åŒæ—¶è¿è¡Œçš„ï¼Œå®åˆ™æ˜¯è½®ç•ªç©¿æ’åœ°è¿è¡Œï¼Œç”±äºæ—¶é—´ç‰‡é€šå¸¸å¾ˆçŸ­ï¼ˆåœ¨ Linux ä¸Šä¸º 5msï¼800msï¼‰ï¼Œç”¨æˆ·ä¸ä¼šæ„Ÿè§‰åˆ°ã€‚ æ—¶é—´ç‰‡ç”±æ“ä½œç³»ç»Ÿå†…æ ¸çš„è°ƒåº¦ç¨‹åºåˆ†é…ç»™æ¯ä¸ªè¿›ç¨‹ã€‚é¦–å…ˆï¼Œå†…æ ¸ä¼šç»™æ¯ä¸ªè¿›ç¨‹åˆ†é…ç›¸ç­‰çš„åˆå§‹æ—¶é—´ç‰‡ï¼Œç„¶åæ¯ä¸ªè¿›ç¨‹è½®ç•ªåœ°æ‰§è¡Œç›¸åº”çš„æ—¶é—´ï¼Œå½“æ‰€æœ‰è¿›ç¨‹éƒ½å¤„äºæ—¶é—´ç‰‡è€—å°½çš„çŠ¶æ€æ—¶ï¼Œå†…æ ¸ä¼šé‡æ–°ä¸ºæ¯ä¸ªè¿›ç¨‹è®¡ç®—å¹¶åˆ†é…æ—¶é—´ç‰‡ï¼Œå¦‚æ­¤å¾€å¤ å¹¶è¡Œå’Œå¹¶å‘ å¹¶è¡Œ(parallel)ï¼šæŒ‡åœ¨åŒä¸€æ—¶åˆ»ï¼Œæœ‰å¤šæ¡æŒ‡ä»¤åœ¨å¤šä¸ªå¤„ç†å™¨ä¸ŠåŒæ—¶æ‰§è¡Œã€‚ å¹¶å‘(concurrency)ï¼šæŒ‡åœ¨åŒä¸€æ—¶åˆ»åªèƒ½æœ‰ä¸€æ¡æŒ‡ä»¤æ‰§è¡Œï¼Œä½†å¤šä¸ªè¿›ç¨‹æŒ‡ä»¤è¢«å¿«é€Ÿçš„è½®æ¢æ‰§è¡Œï¼Œä½¿å¾—åœ¨å®è§‚ä¸Šå…·æœ‰å¤šä¸ªè¿›ç¨‹åŒæ—¶æ‰§è¡Œçš„æ•ˆæœï¼Œä½†åœ¨å¾®è§‚ä¸Šå¹¶ä¸æ˜¯åŒæ—¶æ‰§è¡Œçš„ï¼Œåªæ˜¯æŠŠæ—¶é—´åˆ†æˆè‹¥å¹²æ®µï¼Œä½¿å¤šä¸ªè¿›ç¨‹å¿«é€Ÿäº¤æ›¿çš„æ‰§è¡Œ è¿›ç¨‹æ§åˆ¶å—PCB ä¸ºäº†ç®¡ç†è¿›ç¨‹ï¼Œå†…æ ¸å¿…é¡»å¯¹æ¯ä¸ªè¿›ç¨‹æ‰€åšçš„äº‹æƒ…è¿›è¡Œæ¸…æ¥šçš„æè¿°ã€‚å†…æ ¸ä¸ºæ¯ä¸ªè¿›ç¨‹åˆ†é…ä¸€ä¸ª PCB(Processing Control Block)è¿›ç¨‹æ§åˆ¶å—ï¼Œç»´æŠ¤è¿›ç¨‹ç›¸å…³çš„ä¿¡æ¯ï¼ŒLinux å†…æ ¸çš„è¿›ç¨‹æ§åˆ¶å—æ˜¯ task_struct ç»“æ„ä½“ã€‚ åœ¨ &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h æ–‡ä»¶ä¸­å¯ä»¥æŸ¥çœ‹ struct task_struct ç»“æ„ä½“å®šä¹‰ã€‚å…¶å†…éƒ¨æˆå‘˜æœ‰å¾ˆå¤šï¼Œæˆ‘ä»¬åªéœ€è¦æŒæ¡ä»¥ä¸‹éƒ¨åˆ†å³å¯ï¼š è¿›ç¨‹idï¼šç³»ç»Ÿä¸­æ¯ä¸ªè¿›ç¨‹æœ‰å”¯ä¸€çš„ idï¼Œç”¨ pid_t ç±»å‹è¡¨ç¤ºï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªéè´Ÿæ•´æ•° è¿›ç¨‹çš„çŠ¶æ€ï¼šæœ‰å°±ç»ªã€è¿è¡Œã€æŒ‚èµ·ã€åœæ­¢ç­‰çŠ¶æ€ è¿›ç¨‹åˆ‡æ¢æ—¶éœ€è¦ä¿å­˜å’Œæ¢å¤çš„ä¸€äº›CPUå¯„å­˜å™¨ æè¿°è™šæ‹Ÿåœ°å€ç©ºé—´çš„ä¿¡æ¯ æè¿°æ§åˆ¶ç»ˆç«¯çš„ä¿¡æ¯å½“å‰å·¥ä½œç›®å½•ï¼ˆCurrent Working Directoryï¼‰ umask æ©ç  æ–‡ä»¶æè¿°ç¬¦è¡¨ï¼ŒåŒ…å«å¾ˆå¤šæŒ‡å‘ file ç»“æ„ä½“çš„æŒ‡é’ˆ å’Œä¿¡å·ç›¸å…³çš„ä¿¡æ¯ ç”¨æˆ· id å’Œç»„ id ä¼šè¯ï¼ˆSessionï¼‰å’Œè¿›ç¨‹ç»„ è¿›ç¨‹å¯ä»¥ä½¿ç”¨çš„èµ„æºä¸Šé™ï¼ˆResource Limitï¼‰è¿è¡Œ 1ulimit -a è¿›ç¨‹çŠ¶æ€è½¬æ¢è¿›ç¨‹çš„çŠ¶æ€è¿›ç¨‹çŠ¶æ€åæ˜ è¿›ç¨‹æ‰§è¡Œè¿‡ç¨‹çš„å˜åŒ–ã€‚è¿™äº›çŠ¶æ€éšç€è¿›ç¨‹çš„æ‰§è¡Œå’Œå¤–ç•Œæ¡ä»¶çš„å˜åŒ–è€Œè½¬æ¢ã€‚åœ¨ä¸‰æ€æ¨¡å‹ä¸­ï¼Œè¿›ç¨‹çŠ¶æ€åˆ†ä¸ºä¸‰ä¸ªåŸºæœ¬çŠ¶æ€ï¼Œå³å°±ç»ªæ€ï¼Œè¿è¡Œæ€ï¼Œé˜»å¡æ€ã€‚åœ¨äº”æ€æ¨¡å‹ä¸­ï¼Œè¿›ç¨‹åˆ†ä¸ºæ–°å»ºæ€ã€å°±ç»ªæ€ï¼Œè¿è¡Œæ€ï¼Œé˜»å¡æ€ï¼Œç»ˆæ­¢æ€ã€‚ è¿è¡Œæ€ï¼šè¿›ç¨‹å æœ‰å¤„ç†å™¨æ­£åœ¨è¿è¡Œ å°±ç»ªæ€ï¼šè¿›ç¨‹å…·å¤‡è¿è¡Œæ¡ä»¶ï¼Œç­‰å¾…ç³»ç»Ÿåˆ†é…å¤„ç†å™¨ä»¥ä¾¿è¿è¡Œã€‚å½“è¿›ç¨‹å·²åˆ†é…åˆ°é™¤CPUä»¥å¤–çš„æ‰€æœ‰å¿…è¦èµ„æºåï¼Œåªè¦å†è·å¾—CPUï¼Œä¾¿å¯ç«‹å³æ‰§è¡Œã€‚åœ¨ä¸€ä¸ªç³»ç»Ÿä¸­å¤„äºå°±ç»ªçŠ¶æ€çš„è¿›ç¨‹å¯èƒ½æœ‰å¤šä¸ªï¼Œé€šå¸¸å°†å®ƒä»¬æ’æˆä¸€ä¸ªé˜Ÿåˆ—ï¼Œç§°ä¸ºå°±ç»ªé˜Ÿåˆ— é˜»å¡æ€ï¼šåˆç§°ä¸ºç­‰å¾…(wait)æ€æˆ–ç¡çœ (sleep)æ€ï¼ŒæŒ‡è¿›ç¨‹ä¸å…·å¤‡è¿è¡Œæ¡ä»¶ï¼Œæ­£åœ¨ç­‰å¾…æŸä¸ªäº‹ä»¶çš„å®Œæˆ æ–°å»ºæ€ï¼šè¿›ç¨‹åˆšè¢«åˆ›å»ºæ—¶çš„çŠ¶æ€ï¼Œå°šæœªè¿›å…¥å°±ç»ªé˜Ÿåˆ— ç»ˆæ­¢æ€ï¼šè¿›ç¨‹å®Œæˆä»»åŠ¡åˆ°è¾¾æ­£å¸¸ç»“æŸç‚¹ï¼Œæˆ–å‡ºç°æ— æ³•å…‹æœçš„é”™è¯¯è€Œå¼‚å¸¸ç»ˆæ­¢ï¼Œæˆ–è¢«æ“ä½œç³»ç»ŸåŠæœ‰ç»ˆæ­¢æƒçš„è¿›ç¨‹æ‰€ç»ˆæ­¢æ—¶æ‰€å¤„çš„çŠ¶æ€ã€‚è¿›å…¥ç»ˆæ­¢æ€çš„è¿›ç¨‹ä»¥åä¸å†æ‰§è¡Œï¼Œä½†ä¾ç„¶ä¿ç•™åœ¨æ“ä½œç³»ç»Ÿä¸­ç­‰å¾…å–„åã€‚ä¸€æ—¦å…¶ä»–è¿›ç¨‹å®Œæˆäº†å¯¹ç»ˆæ­¢æ€è¿›ç¨‹çš„ä¿¡æ¯æŠ½å–ä¹‹åï¼Œæ“ä½œç³»ç»Ÿå°†åˆ é™¤è¯¥è¿›ç¨‹ è¿›ç¨‹ç›¸å…³å‘½ä»¤ æŸ¥çœ‹è¿›ç¨‹ 1ps aux 1ps ajx aï¼šæ˜¾ç¤ºç»ˆç«¯ä¸Šçš„æ‰€æœ‰è¿›ç¨‹ï¼ŒåŒ…æ‹¬å…¶ä»–ç”¨æˆ·çš„è¿›ç¨‹ uï¼šæ˜¾ç¤ºè¿›ç¨‹çš„è¯¦ç»†ä¿¡æ¯ xï¼šæ˜¾ç¤ºæ²¡æœ‰æ§åˆ¶ç»ˆç«¯çš„è¿›ç¨‹ jï¼šåˆ—å‡ºä¸ä½œä¸šç›¸å…³çš„æ§åˆ¶è¿›ç¨‹ è¿˜æœ‰å…¶ä»–çš„å‘½ä»¤æˆ‘ä»¬å¯ä»¥è¿è¡Œå‘½ä»¤ 1man ps STATå‚æ•°çš„æ„ä¹‰ å‚æ•° æ„ä¹‰ D ä¸å¯ä¸­æ–­ Uninterruptibleï¼ˆusually IOï¼‰ R æ­£åœ¨è¿è¡Œï¼Œæˆ–åœ¨é˜Ÿåˆ—ä¸­çš„è¿›ç¨‹ S å¤„äºä¼‘çœ çŠ¶æ€ T åœæ­¢æˆ–è¢«è¿½è¸ª Z åƒµå°¸è¿›ç¨‹ W è¿›å…¥å†…å­˜äº¤æ¢ï¼ˆä»å†…æ ¸2.6å¼€å§‹æ— æ•ˆï¼‰ X æ­»æ‰çš„è¿›ç¨‹ &lt; é«˜ä¼˜å…ˆçº§ N ä½ä¼˜å…ˆçº§ S åŒ…å«å­è¿›ç¨‹ + ä½äºå‰å°çš„è¿›ç¨‹ç»„ å®æ—¶æ˜¾ç¤ºè¿›ç¨‹åŠ¨æ€ 1top å¯ä»¥åœ¨ä½¿ç”¨topå‘½ä»¤æ—¶åŠ ä¸Š -dæ¥æŒ‡å®šæ˜¾ç¤ºä¿¡æ¯æ›´æ–°çš„æ—¶é—´é—´éš”ï¼Œåœ¨topå‘½ä»¤æ‰§è¡Œåï¼Œå¯ä»¥æŒ‰ä»¥ä¸‹æŒ‰é”®å¯¹æ˜¾ç¤ºç»“æœè¿›è¡Œæ’åº M æ ¹æ®å†…å­˜ä½¿ç”¨é‡æ’åº P æ ¹æ®CPUå æœ‰ç‡æ’åº T æ ¹æ®è¿›ç¨‹è¿è¡Œæ—¶é—´é•¿çŸ­æ’åº U æ ¹æ®ç”¨æˆ·åæ¥ç­›é€‰è¿›ç¨‹ K è¾“å…¥æŒ‡å®šçš„PIDæ€æ­»è¿›ç¨‹ æ€æ­»è¿›ç¨‹ klil [-signal] pid kill -l åˆ—å‡ºæ‰€æœ‰ä¿¡å· kill -SIGKILL è¿›ç¨‹ID kill -9 è¿›ç¨‹ID killall name æ ¹æ®è¿›ç¨‹åæ€æ­»è¿›ç¨‹ è¿›ç¨‹å·å’Œç›¸å…³å‡½æ•° æ¯ä¸ªè¿›ç¨‹éƒ½ç”±è¿›ç¨‹å·æ¥æ ‡è¯†ï¼Œå…¶ç±»å‹ä¸º pid_tï¼ˆæ•´å‹ï¼‰ï¼Œè¿›ç¨‹å·çš„èŒƒå›´ï¼š0ï½32767ã€‚è¿›ç¨‹å·æ€»æ˜¯å”¯ä¸€çš„ï¼Œä½†å¯ä»¥é‡ç”¨ã€‚å½“ä¸€ä¸ªè¿›ç¨‹ç»ˆæ­¢åï¼Œå…¶è¿›ç¨‹å·å°±å¯ä»¥å†æ¬¡ä½¿ç”¨ã€‚ ä»»ä½•è¿›ç¨‹ï¼ˆé™¤ init è¿›ç¨‹ï¼‰éƒ½æ˜¯ç”±å¦ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºï¼Œè¯¥è¿›ç¨‹ç§°ä¸ºè¢«åˆ›å»ºè¿›ç¨‹çš„çˆ¶è¿›ç¨‹ï¼Œå¯¹åº”çš„è¿›ç¨‹å·ç§°ä¸ºçˆ¶è¿›ç¨‹å·ï¼ˆPPIDï¼‰ã€‚ è¿›ç¨‹ç»„æ˜¯ä¸€ä¸ªæˆ–å¤šä¸ªè¿›ç¨‹çš„é›†åˆã€‚ä»–ä»¬ä¹‹é—´ç›¸äº’å…³è”ï¼Œè¿›ç¨‹ç»„å¯ä»¥æ¥æ”¶åŒä¸€ç»ˆç«¯çš„å„ç§ä¿¡å·ï¼Œå…³è”çš„è¿›ç¨‹æœ‰ä¸€ä¸ªè¿›ç¨‹ç»„å·ï¼ˆPGIDï¼‰ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“å‰çš„è¿›ç¨‹å·ä¼šå½“åšå½“å‰çš„è¿›ç¨‹ç»„å·ã€‚ è¿›ç¨‹å·å’Œè¿›ç¨‹ç›¸å…³å‡½æ•° pid_t getpid(void); pid_t getppid(void); pid_t getpgid(pid_t pid); è¿›ç¨‹åˆ›å»ºforkå‡½æ•°ç³»ç»Ÿå…è®¸ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºæ–°è¿›ç¨‹ï¼Œæ–°è¿›ç¨‹å³ä¸ºå­è¿›ç¨‹ï¼Œå­è¿›ç¨‹è¿˜å¯ä»¥åˆ›å»ºæ–°çš„å­è¿›ç¨‹ï¼Œå½¢æˆè¿›ç¨‹æ ‘ç»“æ„æ¨¡å‹ã€‚ 123456789#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t fork(void);//è¿”å›å€¼ï¼š//æˆåŠŸï¼šå­è¿›ç¨‹ä¸­è¿”å›0ï¼Œçˆ¶è¿›ç¨‹ä¸­è¿”å›å­è¿›ç¨‹ID//å¤±è´¥ï¼šè¿”å›-1//å¤±è´¥çš„ä¸¤ä¸ªä¸»è¦åŸå› //1ã€å½“å‰ç³»ç»Ÿçš„è¿›ç¨‹æ•°å·²ç»è¾¾åˆ°äº†ç³»ç»Ÿè§„å®šçš„ä¸Šé™ï¼Œè¿™æ—¶errnoçš„å€¼è¢«è®¾ç½®ä¸ºEAGAIN//2ã€ç³»ç»Ÿå†…å­˜ä¸è¶³ï¼Œè¿™æ˜¯errnoçš„å€¼è¢«è®¾ç½®ä¸ºENOMEM ä¾‹å­ï¼š 123456789101112131415161718192021222324252627#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //åˆ›å»ºå­è¿›ç¨‹ pid_t pid = fork(); //åˆ¤æ–­æ˜¯çˆ¶è¿›ç¨‹è¿˜æ˜¯å­è¿›ç¨‹ if (pid &gt; 0) &#123; printf(&quot;pid: %d\\n&quot;, pid); //å¦‚æœå¤§äº0ï¼Œè¿”å›çš„æ˜¯åˆ›å»ºçš„å­è¿›ç¨‹çš„è¿›ç¨‹å· printf(&quot;I am parent process,pid: %d, ppid: %d\\n&quot;, getpid(), getppid()); &#125; else if (pid == 0) &#123; //å½“å‰æ˜¯å­è¿›ç¨‹ printf(&quot;I am child process,pid: %d, ppid: %d\\n&quot;, getpid(), getppid()); &#125; //forå¾ªç¯ for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;i: %d pid: %d\\n&quot;, i,getpid()); sleep(2); &#125;&#125; è¿è¡Œç»“æœä¸ºï¼š ç¬¬ä¸€ä¸ªpidï¼š107838æ˜¯å­è¿›ç¨‹çš„IDï¼Œçˆ¶è¿›ç¨‹IDä¸º107837ï¼Œçˆ¶è¿›ç¨‹çš„çˆ¶è¿›ç¨‹çš„IDï¼š107575 çˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹æ˜¯äº¤æ›¿è¿è¡Œçš„ çˆ¶å­è¿›ç¨‹ä¹‹é—´çš„å…³ç³»ï¼š åŒºåˆ«ï¼š fork()å‡½æ•°çš„è¿”å›å€¼ä¸åŒ çˆ¶è¿›ç¨‹ä¸­ï¼š&gt;0 è¿”å›å­è¿›ç¨‹çš„ID å­è¿›ç¨‹ä¸­ &#x3D; 0 PCBä¸­çš„ä¸€äº›æ•°æ®æœ‰åŒºåˆ« å½“å‰è¿›ç¨‹çš„idï¼Œpid å½“å‰è¿›ç¨‹çš„çˆ¶è¿›ç¨‹idï¼Œppid ä¿¡å·é›† å…±åŒç‚¹ï¼š æŸäº›çŠ¶æ€ä¸‹ï¼šå­è¿›ç¨‹åˆšåˆ›å»ºå‡ºæ¥ï¼Œè¿˜æ²¡æœ‰æ‰§è¡Œä»»ä½•çš„å†™æ•°æ®çš„æ“ä½œ ç”¨æˆ·åŒºçš„æ•°æ® æ–‡ä»¶æè¿°ç¬¦è¡¨ çˆ¶å­è¿›ç¨‹å¯¹å˜é‡æ˜¯ä¸æ˜¯å…±äº«çš„ï¼Ÿ åˆšå¼€å§‹çš„æ—¶å€™æ˜¯ä¸€æ ·çš„ï¼Œæ˜¯å…±äº«çš„ï¼Œå¦‚æœä¿®æ”¹äº†æ•°æ®å°±ä¸å…±äº«äº† è¯»æ—¶å…±äº«ï¼ˆå­è¿›ç¨‹è¢«åˆ›å»ºï¼Œä¸¤ä¸ªè¿›ç¨‹æ²¡æœ‰åšä»»ä½•å†™çš„æ“ä½œï¼‰ï¼Œå†™æ—¶æ‹·è´ çˆ¶å­è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´æƒ…å†µå®é™…ä¸Šï¼Œæ›´å‡†ç¡®æ¥è¯´ï¼ŒLinuxçš„fork()ä½¿ç”¨æ˜¯é€šè¿‡å†™æ—¶æ‹·è´ï¼ˆcopy - on - writeï¼‰å®ç°çš„ã€‚ å†™æ—¶æ‹·è´æ˜¯ä¸€ç§å¯ä»¥æ¨è¿Ÿç”šè‡³é¿å…æ‹·è´æ•°æ®çš„æŠ€æœ¯ã€‚ å†…æ ¸æ­¤æ—¶å¹¶ä¸å¤åˆ¶æ•´ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´ï¼Œè€Œæ˜¯è®©çˆ¶å­è¿›ç¨‹å…±äº«åŒä¸€ä¸ªåœ°å€ç©ºé—´ã€‚åªç”¨åœ¨éœ€è¦å†™å…¥çš„æ—¶å€™æ‰ä¼šå¤åˆ¶åœ°å€ç©ºé—´ï¼Œä»è€Œä½¿å„ä¸ªè¿›ç¨‹æ‹¥æœ‰å„è‡ªçš„åœ°å€ç©ºé—´ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œèµ„æºçš„å¤åˆ¶æ˜¯åœ¨éœ€è¦å†™å…¥çš„æ—¶å€™æ‰ä¼šè¿è¡Œï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œåªæœ‰ä»¥åªè¯»æ–¹å¼å…±äº«ã€‚ æ³¨æ„ï¼šforkä¹‹åçˆ¶å­è¿›ç¨‹å…±äº«æ–‡ä»¶ã€‚forkäº§ç”Ÿçš„å­è¿›ç¨‹ä¸çˆ¶è¿›ç¨‹ç›¸åŒçš„æ–‡ä»¶ï¼Œæ–‡ä»¶æè¿°ç¬¦æŒ‡å‘ç›¸åŒçš„æ–‡ä»¶è¡¨ï¼Œå¼•ç”¨è®¡æ•°å¢åŠ ï¼Œå…±äº«æ–‡åç§»æŒ‡é’ˆã€‚ GDBå¤šè¿›ç¨‹è°ƒè¯•ä½¿ç”¨ GDB è°ƒè¯•çš„æ—¶å€™ï¼ŒGDB é»˜è®¤åªèƒ½è·Ÿè¸ªä¸€ä¸ªè¿›ç¨‹ï¼Œå¯ä»¥åœ¨ fork å‡½æ•°è°ƒç”¨ä¹‹å‰ï¼Œé€šè¿‡æŒ‡ä»¤è®¾ç½® GDB è°ƒè¯•å·¥å…·è·Ÿè¸ªçˆ¶è¿›ç¨‹æˆ–è€…æ˜¯è·Ÿè¸ªå­è¿›ç¨‹ï¼Œé»˜è®¤è·Ÿè¸ªçˆ¶è¿›ç¨‹ã€‚ è®¾ç½®è°ƒè¯•çˆ¶è¿›ç¨‹æˆ–è€…å­è¿›ç¨‹ï¼šset follow-fork-mode [parentï¼ˆé»˜è®¤ï¼‰| child] è®¾ç½®è°ƒè¯•æ¨¡å¼ï¼šset detach-on-fork [on | off]é»˜è®¤ä¸º onï¼Œè¡¨ç¤ºè°ƒè¯•å½“å‰è¿›ç¨‹çš„æ—¶å€™ï¼Œå…¶å®ƒçš„è¿›ç¨‹ç»§ç»­è¿è¡Œï¼Œå¦‚æœä¸º offï¼Œè°ƒè¯•å½“å‰è¿›ç¨‹çš„æ—¶å€™ï¼Œå…¶å®ƒè¿›ç¨‹è¢« GDB æŒ‚èµ·ã€‚ æŸ¥çœ‹è°ƒè¯•çš„è¿›ç¨‹ï¼šinfo inferiors åˆ‡æ¢å½“å‰è°ƒè¯•çš„è¿›ç¨‹ï¼šinferior id ä½¿è¿›ç¨‹è„±ç¦» GDB è°ƒè¯•ï¼šdetach inferiors id æˆ‘ä»¬å¯¹å¦‚ä¸‹ç¨‹åºè¿›è¡ŒGDBå¤šè¿›ç¨‹è°ƒè¯•ï¼š 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; printf(&quot;begin\\n&quot;); if(fork() &gt; 0) &#123; printf(&quot;æˆ‘æ˜¯çˆ¶è¿›ç¨‹: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); int i; for(i = 0; i &lt; 10; i++) &#123; printf(&quot;i = %d\\n&quot;, i); sleep(1); &#125; &#125; else &#123; printf(&quot;æˆ‘æ˜¯å­è¿›ç¨‹: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); int j; for(j = 0; j &lt; 10; j++) &#123; printf(&quot;j = %d\\n&quot;, j); sleep(1); &#125; &#125; return 0;&#125; å¯¹ä¸Šè¿°ç¨‹åºè¿›è¡Œè°ƒè¯•ï¼šGDBé»˜è®¤è°ƒè¯•çš„æ˜¯çˆ¶è¿›ç¨‹ æˆ‘ä»¬å¯ä»¥é€šè¿‡æŒ‡ä»¤,ä¿®æ”¹é»˜è®¤è·Ÿè¸ªçš„è¿›ç¨‹ 1set follow-fork-mode child ä¿®æ”¹ä¹‹åæˆ‘ä»¬é»˜è®¤è°ƒè¯•çš„æ˜¯å­è¿›ç¨‹ ä½¿ç”¨å‘½ä»¤ï¼Œæ›´æ”¹è°ƒè¯•æ¨¡å¼offå°†å­è¿›ç¨‹æŒ‚èµ· 1set detach-on-fork off æˆ‘ä»¬é‡æ–°è°ƒè¯•ç¨‹åº é€šè¿‡è¿è¡Œå‘½ä»¤æŸ¥çœ‹å½“å‰è°ƒè¯•çš„è¿›ç¨‹ 1info inferiors æˆ‘ä»¬è¿è¡Œå‘½ä»¤åˆ‡æ¢åˆ°å­è¿›ç¨‹ç»§ç»­è°ƒè¯• 1inferior 2 æˆ‘ä»¬å†æ¬¡åˆ‡æ¢åˆ°çˆ¶è¿›ç¨‹è°ƒè¯•ï¼Œå¹¶ä¸”å°†çˆ¶è¿›ç¨‹è¿è¡Œç»“æŸ æ­¤æ—¶æˆ‘ä»¬æŸ¥çœ‹è¿›ç¨‹ æˆ‘ä»¬åˆ‡æ¢åˆ°å­è¿›ç¨‹ç»§ç»­è°ƒè¯•å¹¶ä¸”è¿è¡Œç»“æŸ æˆ‘ä»¬è¿è¡Œå‘½ä»¤ï¼Œä½¿çˆ¶è¿›ç¨‹è„±ç¦»è°ƒè¯• 1detach inferiors 1 execå‡½æ•°æ—execå‡½æ•°æ—ä»‹ç» exec å‡½æ•°æ—çš„ä½œç”¨æ˜¯æ ¹æ®æŒ‡å®šçš„æ–‡ä»¶åæ‰¾åˆ°å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¹¶ç”¨å®ƒæ¥å–ä»£è°ƒç”¨è¿›ç¨‹çš„å†…å®¹ï¼Œæ¢å¥è¯è¯´ï¼Œå°±æ˜¯åœ¨è°ƒç”¨è¿›ç¨‹å†…éƒ¨æ‰§è¡Œä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ã€‚ exec å‡½æ•°æ—çš„å‡½æ•°æ‰§è¡ŒæˆåŠŸåä¸ä¼šè¿”å›ï¼Œå› ä¸ºè°ƒç”¨è¿›ç¨‹çš„å®ä½“ï¼ŒåŒ…æ‹¬ä»£ç æ®µï¼Œæ•°æ®æ®µå’Œå †æ ˆç­‰éƒ½å·²ç»è¢«æ–°çš„å†…å®¹å–ä»£ï¼Œåªç•™ä¸‹è¿›ç¨‹ ID ç­‰ä¸€äº›è¡¨é¢ä¸Šçš„ä¿¡æ¯ä»ä¿æŒåŸæ ·ï¼Œé¢‡æœ‰äº›ç¥ä¼¼â€œä¸‰åå…­è®¡â€ä¸­çš„â€œé‡‘è‰è„±å£³â€ã€‚çœ‹ä¸Šå»è¿˜æ˜¯æ—§çš„èº¯å£³ï¼Œå´å·²ç»æ³¨å…¥äº†æ–°çš„çµé­‚ã€‚åªæœ‰è°ƒç”¨å¤±è´¥äº†ï¼Œå®ƒä»¬æ‰ä¼šè¿”å› -1ï¼Œä»åŸç¨‹åºçš„è°ƒç”¨ç‚¹æ¥ç€å¾€ä¸‹æ‰§è¡Œã€‚ 123456789int execl(const char *path, const char *arg, .../* (char *) NULL */);int execlp(const char *file, const char *arg, ... /* (char *) NULL */);int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);int execv(const char *path, char *const argv[])int execvp(const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]);//å‰å…­ä¸ªæ˜¯æ ‡å‡†Cåº“å‡½æ•°ï¼Œæœ€åä¸€ä¸ªæ˜¯Linuxç³»ç»Ÿå‡½æ•°int execve(const char *filename, char *const argv[], char *const envp[]); execlå‡½æ•°1234567891011#include&lt;unistd.h&gt;int execl(const char* path, const char* arg, .../* (char *) NULL */);//å‚æ•°//- pathï¼šéœ€è¦åˆ¶å®šæ‰§è¡Œçš„æ–‡ä»¶çš„è·¯å¾„æˆ–è€…åç§°//- argï¼šæ˜¯æ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶æ‰€éœ€è¦çš„å‚æ•°åˆ—è¡¨// ç¬¬ä¸€ä¸ªå‚æ•°ä¸€èˆ¬æ²¡æœ‰ä»€ä¹ˆä½œç”¨ï¼Œä¸€èˆ¬å†™çš„æ˜¯æ‰§è¡Œçš„ç¨‹åºçš„åç§°// ä»ç¬¬äºŒä¸ªå‚æ•°å¼€å§‹å¾€åï¼Œå°±æ˜¯ç¨‹åºæ‰§è¡Œæ‰€éœ€è¦çš„å‚æ•°åˆ—è¡¨// å‚æ•°æœ€åéœ€è¦ä»¥NULLç»“æŸï¼ˆå“¨å…µï¼‰//è¿”å›å€¼//åªæœ‰å½“è°ƒç”¨å¤±è´¥æ‰ä¼šæœ‰è¿”å›å€¼ï¼Œå¹¶ä¸”è¿”å›-1ï¼Œå¹¶ä¸”è®¾ç½®errno//å¦‚æœè°ƒç”¨æˆåŠŸï¼Œæ²¡æœ‰è¿”å›å€¼ ä¾‹å­ï¼š 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œåœ¨å­è¿›ç¨‹ä¸­æ‰§è¡Œexecå‡½æ•°æ—ä¸­çš„ç¨‹åº __pid_t pid = fork(); if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ execl(&quot;hello&quot;, &quot;hello&quot;, &quot;NULL&quot;); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; helloæ–‡ä»¶æ˜¯ä¸€æ®µè¾“å‡ºhello worldçš„ä»£ç  ä»£ç è¿è¡Œç»“æœå¦‚ä¸‹ï¼š 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œåœ¨å­è¿›ç¨‹ä¸­æ‰§è¡Œexecå‡½æ•°æ—ä¸­çš„ç¨‹åº __pid_t pid = fork(); if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; è¿™æ®µä»£ç ä¼šå°†å­è¿›ç¨‹æ›¿ä»£ä¸ºè¿è¡ŒLinuxç³»ç»Ÿç¨‹åºps execlpå‡½æ•°12345#include&lt;unistd.h&gt;int execlp(const char* file, const char* arg, ... /* (char *) NULL */);//å‚æ•°//- ä¼šåˆ°ç¯å¢ƒå˜é‡ä¸­å¯»æ‰¾å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¦‚æœæ‰¾åˆ°åˆ™æ‰§è¡Œï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™æ‰§è¡Œå¤±è´¥//- fileï¼šéœ€è¦å¯æ‰§è¡Œæ–‡ä»¶çš„æ–‡ä»¶å ä¾‹å­: 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //åˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹ï¼Œåœ¨å­è¿›ç¨‹ä¸­æ‰§è¡Œexecå‡½æ•°æ—ä¸­çš„ç¨‹åº __pid_t pid = fork(); if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; ä¸execlä¸åŒï¼Œexeclpä¸ç”¨å†™å…¥ç»å¯¹è·¯å¾„å°±å¯ä»¥æ‰§è¡Œpså‘½ä»¤ è¿›ç¨‹æ§åˆ¶è¿›ç¨‹é€€å‡º 1234567#include&lt;stdlib.h&gt;void exit(int status);#include&lt;unistd.h&gt;void _exit(int status);//statusæ˜¯è¿›ç¨‹é€€å‡ºæ—¶çš„ä¸€ä¸ªçŠ¶æ€ä¿¡æ¯ã€‚çˆ¶è¿›ç¨‹å›æ”¶å­è¿›ç¨‹èµ„æºæ—¶å¯ä»¥è·å–åˆ° ä¾‹å­ï¼š 12345678910#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); exit(0);&#125; 12345678910#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); _exit(0);&#125; å¦‚æœä½¿ç”¨_exit(0)åˆ™åªä¼šæ‰“å°helloä¸ä¼šæ‰“å°world å­¤å„¿è¿›ç¨‹ çˆ¶è¿›ç¨‹è¿è¡Œç»“æŸï¼Œä½†å­è¿›ç¨‹è¿˜åœ¨è¿è¡Œï¼ˆæœªè¿è¡Œç»“æŸï¼‰ï¼Œè¿™æ ·çš„å­è¿›ç¨‹å°±ç§°ä¸ºå­¤å„¿è¿›ç¨‹ï¼ˆOrphan Processï¼‰ã€‚ æ¯å½“å‡ºç°ä¸€ä¸ªå­¤å„¿è¿›ç¨‹çš„æ—¶å€™ï¼Œå†…æ ¸å°±æŠŠå­¤å„¿è¿›ç¨‹çš„çˆ¶è¿›ç¨‹è®¾ç½®ä¸º init ï¼Œè€Œ init è¿›ç¨‹ä¼šå¾ªç¯åœ° wait() å®ƒçš„å·²ç»é€€å‡ºçš„å­è¿›ç¨‹ã€‚è¿™æ ·ï¼Œå½“ä¸€ä¸ªå­¤å„¿è¿›ç¨‹å‡„å‡‰åœ°ç»“æŸäº†å…¶ç”Ÿå‘½å‘¨æœŸçš„æ—¶å€™ï¼Œinit è¿›ç¨‹å°±ä¼šä»£è¡¨å…šå’Œæ”¿åºœå‡ºé¢å¤„ç†å®ƒçš„ä¸€åˆ‡å–„åå·¥ä½œã€‚ å› æ­¤å­¤å„¿è¿›ç¨‹å¹¶ä¸ä¼šæœ‰ä»€ä¹ˆå±å®³ åƒµå°¸è¿›ç¨‹ æ¯ä¸ªè¿›ç¨‹ç»“æŸä¹‹å, éƒ½ä¼šé‡Šæ”¾è‡ªå·±åœ°å€ç©ºé—´ä¸­çš„ç”¨æˆ·åŒºæ•°æ®ï¼Œå†…æ ¸åŒºçš„ PCB æ²¡æœ‰åŠæ³•è‡ªå·±é‡Šæ”¾æ‰ï¼Œéœ€è¦çˆ¶è¿›ç¨‹å»é‡Šæ”¾ã€‚ è¿›ç¨‹ç»ˆæ­¢æ—¶ï¼Œçˆ¶è¿›ç¨‹å°šæœªå›æ”¶ï¼Œå­è¿›ç¨‹æ®‹ç•™èµ„æºï¼ˆPCBï¼‰å­˜æ”¾äºå†…æ ¸ä¸­ï¼Œå˜æˆåƒµå°¸ï¼ˆZombieï¼‰è¿›ç¨‹ã€‚ åƒµå°¸è¿›ç¨‹ä¸èƒ½è¢« kill -9 æ€æ­»ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœçˆ¶è¿›ç¨‹ä¸è°ƒç”¨ wait() æˆ– waitpid() çš„è¯ï¼Œé‚£ä¹ˆä¿ç•™çš„é‚£æ®µä¿¡æ¯å°±ä¸ä¼šé‡Šæ”¾ï¼Œå…¶è¿›ç¨‹å·å°±ä¼šä¸€ç›´è¢«å ç”¨ï¼Œä½†æ˜¯ç³»ç»Ÿæ‰€èƒ½ä½¿ç”¨çš„è¿›ç¨‹å·æ˜¯æœ‰é™çš„ï¼Œå¦‚æœå¤§é‡çš„äº§ç”Ÿåƒµå°¸è¿›ç¨‹ï¼Œå°†å› ä¸ºæ²¡æœ‰å¯ç”¨çš„è¿›ç¨‹å·è€Œå¯¼è‡´ç³»ç»Ÿä¸èƒ½äº§ç”Ÿæ–°çš„è¿›ç¨‹ï¼Œæ­¤å³ä¸ºåƒµå°¸è¿›ç¨‹çš„å±å®³ï¼Œåº”å½“é¿å… è¿›ç¨‹å›æ”¶ åœ¨æ¯ä¸ªè¿›ç¨‹é€€å‡ºçš„æ—¶å€™ï¼Œå†…æ ¸é‡Šæ”¾è¯¥è¿›ç¨‹æ‰€æœ‰çš„èµ„æºã€åŒ…æ‹¬æ‰“å¼€çš„æ–‡ä»¶ã€å ç”¨çš„å†…å­˜ç­‰ã€‚ä½†æ˜¯ä»ç„¶ä¸ºå…¶ä¿ç•™ä¸€å®šçš„ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯ä¸»è¦ä¸»è¦æŒ‡è¿›ç¨‹æ§åˆ¶å—PCBçš„ä¿¡æ¯ï¼ˆåŒ…æ‹¬è¿›ç¨‹å·ã€é€€å‡ºçŠ¶æ€ã€è¿è¡Œæ—¶é—´ç­‰ï¼‰ã€‚ çˆ¶è¿›ç¨‹å¯ä»¥é€šè¿‡è°ƒç”¨waitæˆ–waitpidå¾—åˆ°å®ƒçš„é€€å‡ºçŠ¶æ€åŒæ—¶å½»åº•æ¸…é™¤æ‰è¿™ä¸ªè¿›ç¨‹ã€‚ wait() å’Œ waitpid() å‡½æ•°çš„åŠŸèƒ½ä¸€æ ·ï¼ŒåŒºåˆ«åœ¨äºï¼Œwait() å‡½æ•°ä¼šé˜»å¡ï¼Œwaitpid() å¯ä»¥è®¾ç½®ä¸é˜»å¡ï¼Œwaitpid() è¿˜å¯ä»¥æŒ‡å®šç­‰å¾…å“ªä¸ªå­è¿›ç¨‹ç»“æŸã€‚ æ³¨æ„ï¼šä¸€æ¬¡waitæˆ–waitpidè°ƒç”¨åªèƒ½æ¸…ç†ä¸€ä¸ªå­è¿›ç¨‹ï¼Œæ¸…ç†å¤šä¸ªå­è¿›ç¨‹åº”ä½¿ç”¨å¾ªç¯ã€‚ wait()å‡½æ•°1234567891011#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t wait(int* wstatus);//åŠŸèƒ½ï¼šç­‰å¾…ä»»æ„ä¸€ä¸ªå­è¿›ç¨‹ç»“æŸï¼Œå¦‚æœä»»æ„ä¸€ä¸ªå­è¿›ç¨‹ç»“æŸäº†ï¼Œæ­¤å‡½æ•°ä¼šå›æ”¶//å‚æ•°ï¼š//è¿›ç¨‹é€€å‡ºæ—¶çš„çŠ¶æ€ä¿¡æ¯ï¼Œä¼ å…¥çš„æ˜¯ä¸€ä¸ªintç±»å‹çš„åœ°å€ï¼Œä¼ å‡ºå‚æ•°//è¿”å›å€¼ï¼š//- æˆåŠŸï¼šè¿”å›è¢«å›æ”¶çš„å­è¿›ç¨‹çš„ID//- å¤±è´¥ï¼šè¿”å›-1(æ‰€æœ‰å­è¿›ç¨‹éƒ½ç»“æŸ//è°ƒç”¨waitå‡½æ•°çš„è¿›ç¨‹ä¼šè¢«æŒ‚èµ·(é˜»å¡)ï¼Œç›´åˆ°å®ƒçš„ä¸€ä¸ªå­è¿›ç¨‹é€€å‡ºæˆ–è€…æ”¶åˆ°ä¸€ä¸ªä¸èƒ½å¿½ç•¥çš„ä¿¡å·ï¼ˆç»§ç»­è¢«æ‰§è¡Œ)//å¦‚æœæ²¡æœ‰å­è¿›ç¨‹ï¼Œå‡½æ•°ä¼šç«‹åˆ»è¿”å›-1ï¼›å¦‚æœå­è¿›ç¨‹éƒ½å·²ç»ç»“æŸäº†ï¼Œä¹Ÿä¼šç«‹å³è¿”å›-1ï¼Œå¹¶ä¸”ä¼šå›æ”¶å­è¿›ç¨‹çš„èµ„æº æ¡ˆä¾‹wait.cç¨‹åºï¼š 1234567891011121314151617181920212223242526272829#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; //æœ‰ä¸€ä¸ªçˆ¶è¿›ç¨‹åˆ›å»ºäº”ä¸ªå­è¿›ç¨‹ pid_t pid; //åˆ›å»ºäº”ä¸ªå­è¿›ç¨‹ for (int i = 0;i &lt; 5;i++) &#123; pid = fork(); if (pid == 0) break; &#125; if (pid &gt; 0) &#123; //çˆ¶è¿›ç¨‹ while (1) &#123; printf(&quot;parent,pid = %d\\n&quot;, getpid()); &#125; &#125; else if (pid == 0) &#123; //å­è¿›ç¨‹ printf(&quot;child,pid = %d\\n&quot;, getpid()); &#125;&#125; æˆ‘ä»¬ç¼–è¯‘è¿è¡Œè¿™æ®µç¨‹åº è¿è¡Œå‘½ä»¤ 1ps aux æˆ‘ä»¬å‘ç°waitç¨‹åºç”Ÿæˆçš„äº”ä¸ªå­è¿›ç¨‹å˜ä¸ºäº†åƒµå°¸è¿›ç¨‹ æˆ‘ä»¬é‡æ–°å†™ä¸€æ®µwait.cç¨‹åºï¼Œé€šè¿‡killå°†å­ç¨‹åºæ€æ­» 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // æœ‰ä¸€ä¸ªçˆ¶è¿›ç¨‹ï¼Œåˆ›å»º5ä¸ªå­è¿›ç¨‹ï¼ˆå…„å¼Ÿï¼‰ pid_t pid; // åˆ›å»º5ä¸ªå­è¿›ç¨‹ for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; break; &#125; &#125; if(pid &gt; 0) &#123; // çˆ¶è¿›ç¨‹ while(1) &#123; printf(&quot;parent, pid = %d\\n&quot;, getpid()); // int ret = wait(NULL); int st; int ret = wait(&amp;st); if(ret == -1) &#123; break; &#125; if(WIFEXITED(st)) &#123; // æ˜¯ä¸æ˜¯æ­£å¸¸é€€å‡º printf(&quot;é€€å‡ºçš„çŠ¶æ€ç ï¼š%d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // æ˜¯ä¸æ˜¯å¼‚å¸¸ç»ˆæ­¢ printf(&quot;è¢«å“ªä¸ªä¿¡å·å¹²æ‰äº†ï¼š%d\\n&quot;, WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if (pid == 0)&#123; // å­è¿›ç¨‹ while(1) &#123; printf(&quot;child, pid = %d\\n&quot;,getpid()); sleep(1); &#125; exit(0); &#125; return 0; // exit(0)&#125;&quot;, getpid()); &#125; &#125;&#125; ä½¿ç”¨killå‘½ä»¤æ€æ­»å­è¿›ç¨‹ killä¹‹åçš„è¿è¡Œç»“æœä¸ºï¼š é€€å‡ºä¿¡æ¯ç›¸å…³å®å‡½æ•°1234567WIFEXITED(status) //é0ï¼Œè¿›ç¨‹æ­£å¸¸é€€å‡ºWEXITSTATUS(status) //å¦‚æœä¸Šå®ä¸ºçœŸï¼Œè·å–è¿›ç¨‹é€€å‡ºçš„çŠ¶æ€ï¼ˆexitçš„å‚æ•°ï¼‰WIFSIGNALED(status) //é0ï¼Œè¿›ç¨‹å¼‚å¸¸ç»ˆæ­¢WTERMSIG(status) //å¦‚æœä¸Šå®ä¸ºçœŸï¼Œè·å–ä½¿è¿›ç¨‹ç»ˆæ­¢çš„ä¿¡å·ç¼–å·WIFSTOPPED(status) //é0ï¼Œè¿›ç¨‹å¤„äºæš‚åœçŠ¶æ€WSTOPSIG(status) //å¦‚æœä¸Šå®ä¸ºçœŸï¼Œè·å–ä½¿è¿›ç¨‹æš‚åœçš„ä¿¡å·çš„ç¼–å·WIFCONTINUED(status) //é0ï¼Œè¿›ç¨‹æš‚åœåå·²ç»ç»§ç»­è¿è¡Œ waitpid()å‡½æ•°123456789101112131415#include &lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int* wstatus, int options);//åŠŸèƒ½ï¼šå›æ”¶æŒ‡å®šè¿›ç¨‹å·çš„è¿›ç¨‹ï¼Œå¯è®¾ç½®æ˜¯å¦é˜»å¡//å‚æ•°ï¼š//- pid// pid&gt;0ï¼šæŸä¸ªå­è¿›ç¨‹çš„pid// pid=0ï¼šå›æ”¶å½“å‰è¿›ç¨‹ç»„çš„æ‰€æœ‰å­è¿›ç¨‹// pid=-1ï¼šè¡¨ç¤ºå›æ”¶æ‰€æœ‰çš„å­è¿›ç¨‹ï¼Œç›¸å½“äºwait() æœ€å¸¸ç”¨// pid&lt;-1ï¼šæŸä¸ªè¿›ç¨‹ç»„çš„ç»„idçš„ç»å¯¹å€¼ï¼Œå›æ”¶æŒ‡å®šè¿›ç¨‹ç»„ä¸­çš„å­è¿›ç¨‹//- optionsï¼šè®¾ç½®é˜»å¡æˆ–è€…éé˜»å¡ï¼Œ0è¡¨ç¤ºé˜»å¡ï¼ŒWNOHANGè¡¨ç¤ºéé˜»å¡//- è¿”å›å€¼// &gt;0ï¼šè¿”å›å­è¿›ç¨‹ID// =0ï¼šoptions=WNOHANGï¼Œè¡¨ç¤ºè¿˜æœ‰å­è¿›ç¨‹// =-1ï¼šé”™è¯¯ï¼Œæˆ–è€…æ²¡æœ‰å­è¿›ç¨‹","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"è¿›ç¨‹","slug":"è¿›ç¨‹","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"C++å­¦ä¹  å¤šæ€","slug":"C++-å­¦ä¹ -å¤šæ€","date":"2023-05-04T01:11:10.000Z","updated":"2023-05-09T08:10:41.368Z","comments":true,"path":"2023/05/04/C++-å­¦ä¹ -å¤šæ€/","link":"","permalink":"http://example.com/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/","excerpt":"å¤šæ€çš„åŸºæœ¬æ¦‚å¿µå¤šæ€æ˜¯C++é¢å‘å¯¹è±¡ä¸‰å¤§ç‰¹æ€§ä¹‹ä¸€ å¤šæ€åˆ†ä¸ºä¸¤ç±»ï¼š","text":"å¤šæ€çš„åŸºæœ¬æ¦‚å¿µå¤šæ€æ˜¯C++é¢å‘å¯¹è±¡ä¸‰å¤§ç‰¹æ€§ä¹‹ä¸€ å¤šæ€åˆ†ä¸ºä¸¤ç±»ï¼š é™æ€å¤šæ€ï¼šå‡½æ•°é‡è½½å’Œè¿ç®—ç¬¦é‡è½½å±äºé™æ€å¤šæ€ï¼Œå¤ç”¨å‡½æ•°å åŠ¨æ€å¤šæ€ï¼šæ´¾ç”Ÿç±»å’Œè™šå‡½æ•°å®ç°è¿è¡Œæ—¶å¤šæ€ é™æ€å¤šæ€å’ŒåŠ¨æ€å¤šæ€åŒºåˆ« é™æ€å¤šæ€çš„å‡½æ•°åœ°å€æ—©ç»‘å®š-ç¼–è¯‘é˜¶æ®µç¡®å®šå‡½æ•°åœ°å€ åŠ¨æ€å¤šæ€çš„å‡½æ•°åœ°å€æ™šç»‘å®š-è¿è¡Œé˜¶æ®µç¡®å®šå‡½æ•°åœ°å€ 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å¤šæ€//åŠ¨ç‰©ç±»class Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;åŠ¨ç‰©åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125; &#125;;//çŒ«ç±»class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;å°çŒ«åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125;&#125;;//æ‰§è¡Œè¯´è¯çš„å‡½æ•°//åœ°å€æ—©ç»‘å®š åœ¨ç¼–è¯‘é˜¶æ®µç¡®å®šå‡½æ•°åœ°å€ //å¦‚æœæƒ³æ‰§è¡Œè®©çŒ«è¯´è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°åœ°å€å°±ä¸èƒ½æå‰ç»‘å®šï¼Œéœ€è¦åœ¨è¿è¡Œé˜¶æ®µè¿›è¡Œç»‘å®šï¼Œåœ°å€æ™šç»‘å®švoid doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat);&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š åŠ¨ç‰©åœ¨è¯´è¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å¤šæ€//åŠ¨ç‰©ç±»class Animal&#123;public: virtual void speak() &#123; cout &lt;&lt; &quot;åŠ¨ç‰©åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125; &#125;;//åŠ¨æ€å¤šæ€æ»¡è¶³æ¡ä»¶// 1ã€å…·æœ‰ç»§æ‰¿å…³ç³»// 2ã€å­ç±»è¦é‡å†™çˆ¶ç±»çš„è™šå‡½æ•°// // åŠ¨æ€å¤šæ€çš„ä½¿ç”¨// çˆ¶ç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨æŒ‡å‘å­ç±»çš„åº”ç”¨// //çŒ«ç±»class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;å°çŒ«åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;å°ç‹—åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125;&#125;;//æ‰§è¡Œè¯´è¯çš„å‡½æ•°//åœ°å€æ—©ç»‘å®š åœ¨ç¼–è¯‘é˜¶æ®µç¡®å®šå‡½æ•°åœ°å€ //å¦‚æœæƒ³æ‰§è¡Œè®©çŒ«è¯´è¯ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°åœ°å€å°±ä¸èƒ½æå‰ç»‘å®šï¼Œéœ€è¦åœ¨è¿è¡Œé˜¶æ®µè¿›è¡Œç»‘å®šï¼Œåœ°å€æ™šç»‘å®švoid doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat); Dog dog; doSpeak(dog);&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š å°çŒ«åœ¨è¯´è¯å°ç‹—åœ¨è¯´è¯ åŠ¨æ€å¤šæ€æ»¡è¶³æ¡ä»¶ å…·æœ‰ç»§æ‰¿å…³ç³» å­ç±»è¦é‡å†™çˆ¶ç±»çš„è™šå‡½æ•° åŠ¨æ€å¤šæ€çš„ä½¿ç”¨ çˆ¶ç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨æŒ‡å‘å­ç±»å¯¹è±¡ å¤šæ€çš„åŸç†å‰–ææˆ‘ä»¬è§‚å¯Ÿä¸Šè¿°ä»£ç çš„Animalç±»ç»“æ„,vfptræŒ‡å‘vftable æˆ‘ä»¬è§‚å¯ŸCatç±»çš„ç»“æ„å¦‚ä¸‹ï¼š å½“çˆ¶ç±»æŒ‡é’ˆæˆ–è€…å¼•ç”¨æŒ‡å‘å­ç±»å¯¹è±¡çš„æ—¶å€™å‘ç”Ÿå¤šæ€ï¼Œå³ Animal&amp; animal = cat animal.speak() å½“ä¼ å…¥çš„å¯¹è±¡æ˜¯caté‚£ä¹ˆå°±æ˜¯ä»catçš„è™šå‡½æ•°è¡¨é‡Œè°ƒç”¨è™šå‡½æ•° å¤šæ€æ¡ˆä¾‹ä¸€ è®¡ç®—å™¨ç±»æ¡ˆä¾‹æè¿°ï¼šåˆ†åˆ«åˆ©ç”¨æ™®é€šå†™æ³•å’Œå¤šæ€æŠ€æœ¯ï¼Œè®¾è®¡ä¸¤ä¸ªæ“ä½œæ•°è¿›è¡Œè¿ç®—çš„è®¡ç®—å™¨ç±» å¤šæ€çš„ä¼˜ç‚¹ï¼š ä»£ç ç»„ç»‡ç»“æ„æ¸…æ™° å¯è¯»æ€§å¼º åˆ©äºå‰æœŸå’ŒåæœŸçš„æ‹“å±•ä»¥åŠç»´æŠ¤ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//åˆ†åˆ«åˆ©ç”¨æ™®é€šå†™æ³•å’Œå¤šæ€å†™æ³•å®ç°è®¡ç®—å™¨//æ™®é€šå†™æ³•class Calculator&#123;public: int getResult(string oper) &#123; if (oper == &quot;+&quot;)return m_Num1 + m_Num2; else if(oper == &quot;-&quot;)return m_Num1 - m_Num2; else if (oper == &quot;*&quot;)return m_Num1 * m_Num2; else if (oper == &quot;/&quot;)return m_Num1 / m_Num2; &#125; //å¦‚æœè¦æ‹“å±•æ–°çš„åŠŸèƒ½ï¼Œéœ€è¦æ‹“å±•æºç  //åœ¨çœŸå®çš„å¼€å‘ä¸­æå€¡å¼€é—­åŸåˆ™ //å¯¹æ‹“å±•è¿›è¡Œå¼€å‘ï¼Œå¯¹ä¿®æ”¹è¿›è¡Œå…³é—­ int m_Num1;//æ“ä½œæ•°1 int m_Num2;//æ“ä½œæ•°2&#125;;void test01()&#123; Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; / &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;/&quot;) &lt;&lt; endl;&#125;//åˆ©ç”¨å¤šæ€å®ç°è®¡ç®—å™¨//å®ç°è®¡ç®—æœºæŠ½è±¡ç±»class AbstractCalculator&#123;public: virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2;&#125;;//åŠ æ³•è®¡ç®—å™¨ç±»class AddCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//å‡æ³•è®¡ç®—å™¨ç±»class SubCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//ä¹˜æ³•è®¡ç®—å™¨ç±»class MulCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 * m_Num2; &#125;&#125;;//åŠ æ³•è®¡ç®—å™¨ç±»class DivCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 / m_Num2; &#125;&#125;;void test02()&#123; //å¤šæ€ä½¿ç”¨æ¡ä»¶ //çˆ¶ç±»æŒ‡é’ˆæˆ–è€…å¼•ç”¨æŒ‡å‘å­ç±»å¯¹è±¡ //åŠ æ³•è¿ç®— AbstractCalculator* abc = new AddCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //ç”¨å®Œåè®°å¾—é”€æ¯ delete abc; //å‡æ³•è¿ç®— abc = new SubCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //ä¹˜æ³•è¿ç®— abc = new MulCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //é™¤æ³•è¿ç®— abc = new DivCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; / &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;&#125;int main()&#123; test01(); test02(); &#125; è¿è¡Œç»“æœä¸ºï¼š 10 + 10 &#x3D; 2010 - 10 &#x3D; 010 * 10 &#x3D; 10010 &#x2F; 10 &#x3D; 1100 + 100 &#x3D; 200100 - 100 &#x3D; 200100 * 100 &#x3D; 10000100 &#x2F; 100 &#x3D; 1 çº¯è™šå‡½æ•°å’ŒæŠ½è±¡ç±»åœ¨å¤šæ€ä¸­ï¼Œé€šå¸¸çˆ¶ç±»ä¸­è™šå‡½æ•°çš„å®ç°æ˜¯æ¯«æ— æ„ä¹‰çš„ï¼Œä¸»è¦éƒ½æ˜¯è°ƒç”¨å­ç±»é‡å†™çš„å†…å®¹ å› æ­¤å¯ä»¥å°†è™šå‡½æ•°æ”¹ä¸ºçº¯è™šå‡½æ•° çº¯è™šå‡½æ•°è¯­æ³•ï¼švirtual è¿”å›å€¼ç±»å‹ å‡½æ•°å (å‚æ•°åˆ—è¡¨) = 0; å½“ç±»ä¸­æœ‰äº†çº¯è™šå‡½æ•°ï¼Œè¿™ä¸ªç±»ä¹Ÿæˆä¸ºæŠ½è±¡ç±» æŠ½è±¡ç±»ç‰¹ç‚¹ï¼š æ— æ³•å®ä¾‹åŒ–å¯¹è±¡ å­ç±»å¿…é¡»é‡å†™æŠ½è±¡ç±»ä¸­çš„çº¯è™šå‡½æ•°ï¼Œå¦åˆ™ä¹Ÿå±äºæŠ½è±¡ç±» 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//çº¯è™šå‡½æ•°å’ŒæŠ½è±¡ç±»class Base&#123;public: //çº¯è™šå‡½æ•° //åªè¦æœ‰ä¸€ä¸ªçº¯è™šå‡½æ•°ï¼Œè¿™ä¸ªç±»ç§°ä¸ºæŠ½è±¡ç±» //æŠ½è±¡ç±»ç‰¹ç‚¹ï¼š //æ— æ³•å®ä¾‹åŒ–å¯¹è±¡ virtual void func() = 0;&#125;;void test01()&#123; Base b;&#125;int main()&#123; test01();&#125; 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//çº¯è™šå‡½æ•°å’ŒæŠ½è±¡ç±»class Base&#123;public: //çº¯è™šå‡½æ•° //åªè¦æœ‰ä¸€ä¸ªçº¯è™šå‡½æ•°ï¼Œè¿™ä¸ªç±»ç§°ä¸ºæŠ½è±¡ç±» //æŠ½è±¡ç±»ç‰¹ç‚¹ï¼š //1ã€æ— æ³•å®ä¾‹åŒ–å¯¹è±¡ //2ã€æŠ½è±¡ç±»çš„å­ç±»ï¼Œå¿…é¡»è¦é‡å†™çˆ¶ç±»ä¸­çš„çº¯è™šå‡½æ•°ï¼Œå¦åˆ™ä¹Ÿå±äºæŠ½è±¡ç±» virtual void func() = 0;&#125;;class Son :public Base&#123;&#125;;void test01()&#123; Son s;&#125;int main()&#123; test01();&#125; 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//çº¯è™šå‡½æ•°å’ŒæŠ½è±¡ç±»class Base&#123;public: //çº¯è™šå‡½æ•° //åªè¦æœ‰ä¸€ä¸ªçº¯è™šå‡½æ•°ï¼Œè¿™ä¸ªç±»ç§°ä¸ºæŠ½è±¡ç±» //æŠ½è±¡ç±»ç‰¹ç‚¹ï¼š //1ã€æ— æ³•å®ä¾‹åŒ–å¯¹è±¡ //2ã€æŠ½è±¡ç±»çš„å­ç±»ï¼Œå¿…é¡»è¦é‡å†™çˆ¶ç±»ä¸­çš„çº¯è™šå‡½æ•°ï¼Œå¦åˆ™ä¹Ÿå±äºæŠ½è±¡ç±» virtual void func() = 0;&#125;;class Son :public Base&#123; virtual void func() &#123; cout &lt;&lt; &quot;funcå‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125;;&#125;;void test01()&#123; Son s;//å­ç±»å¿…é¡»é‡å†™çˆ¶ç±»ä¸­çš„çº¯è™šå‡½æ•°ï¼Œå¦åˆ™ä¸èƒ½å®ä¾‹åŒ–å¯¹è±¡ Base* base = new Son; base-&gt;func();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š funcå‡½æ•°è°ƒç”¨ å¤šæ€æ¡ˆä¾‹äºŒ åˆ¶ä½œé¥®å“æ¡ˆä¾‹æè¿°ï¼šåˆ¶ä½œé¥®å“çš„å¤§è‡´æµç¨‹ä¸ºï¼šç…®æ°´-å†²æ³¡-å€’å…¥æ¯ä¸­-åŠ å…¥è¾…æ–™ åˆ©ç”¨å¤šæ€æŠ€æœ¯å®ç°æœ¬æ¡ˆä¾‹ï¼Œæä¾›æŠ½è±¡åˆ¶ä½œé¥®å“åŸºç±»ï¼Œæä¾›å­ç±»åˆ¶ä½œå’–å•¡å’ŒèŒ¶å¶ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å¤šæ€æ¡ˆä¾‹2 åˆ¶ä½œé¥®å“class AbstractDrinking&#123;public: //ç…®æ°´ virtual void Boil() = 0; //å†²æ³¡ virtual void Brew() = 0; //å€’å…¥æ¯ä¸­ virtual void PourInCup() = 0; //åŠ å…¥è¾…æ–™ virtual void PutSomething() = 0; //åˆ¶ä½œé¥®å“ void makeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125;&#125;;//åˆ¶ä½œå’–å•¡class Coffee :public AbstractDrinking&#123;public: //ç…®æ°´ virtual void Boil() &#123; cout &lt;&lt; &quot;ç…®å†œå¤«å±±æ³‰&quot; &lt;&lt; endl; &#125; //å†²æ³¡ virtual void Brew() &#123; cout &lt;&lt; &quot;å†²æ³¡å’–å•¡&quot; &lt;&lt; endl; &#125; //å€’å…¥æ¯ä¸­ virtual void PourInCup() &#123; cout &lt;&lt; &quot;å€’å…¥æ¯ä¸­&quot; &lt;&lt; endl; &#125; //åŠ å…¥è¾…æ–™ virtual void PutSomething() &#123; cout &lt;&lt; &quot;åŠ å…¥ç³–å’Œç‰›å¥¶&quot; &lt;&lt; endl; &#125;&#125;;//åˆ¶ä½œèŒ¶class Tea :public AbstractDrinking&#123;public: //ç…®æ°´ virtual void Boil() &#123; cout &lt;&lt; &quot;ç…®çŸ¿æ³‰æ°´&quot; &lt;&lt; endl; &#125; //å†²æ³¡ virtual void Brew() &#123; cout &lt;&lt; &quot;å†²æ³¡èŒ¶å¶&quot; &lt;&lt; endl; &#125; //å€’å…¥æ¯ä¸­ virtual void PourInCup() &#123; cout &lt;&lt; &quot;å€’å…¥æ¯ä¸­&quot; &lt;&lt; endl; &#125; //åŠ å…¥è¾…æ–™ virtual void PutSomething() &#123; cout &lt;&lt; &quot;åŠ å…¥æ¸æ&quot; &lt;&lt; endl; &#125;&#125;;//åˆ¶ä½œå‡½æ•°void doWork(AbstractDrinking* abs)&#123; abs-&gt;makeDrink(); delete abs;//é‡Šæ”¾&#125;void test01()&#123; //åˆ¶ä½œå’–å•¡ doWork(new Coffee); cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; //åˆ¶ä½œèŒ¶å¶ doWork(new Tea);&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š ç…®å†œå¤«å±±æ³‰å†²æ³¡å’–å•¡å€’å…¥æ¯ä¸­åŠ å…¥ç³–å’Œç‰›å¥¶ ç…®çŸ¿æ³‰æ°´å†²æ³¡èŒ¶å¶å€’å…¥æ¯ä¸­åŠ å…¥æ¸æ è™šææ„å’Œçº¯è™šææ„å¤šæ€ä½¿ç”¨æ—¶ï¼Œå¦‚æœå­ç±»ä¸­æœ‰å±æ€§å¼€è¾Ÿåˆ°å †åŒºï¼Œé‚£ä¹ˆçˆ¶ç±»æŒ‡é’ˆåœ¨é‡Šæ”¾æ—¶æ— æ³•è°ƒç”¨åˆ°å­ç±»çš„ææ„ä»£ç  è§£å†³æ–¹å¼ï¼šå°†çˆ¶ç±»ä¸­çš„ææ„å‡½æ•°æ”¹ä¸ºè™šææ„æˆ–è€…çº¯è™šææ„ è™šææ„å’Œçº¯è™šææ„å…±æ€§ï¼š å¯ä»¥è§£å†³çˆ¶ç±»æŒ‡é’ˆé‡Šæ”¾å­ç±»å¯¹è±¡ éƒ½éœ€è¦æœ‰å…·ä½“çš„å‡½æ•°å®ç° è™šææ„å’Œçº¯è™šææ„åŒºåˆ« å¦‚æœæ˜¯çº¯è™šææ„ï¼Œè¯¥ç±»å±äºæŠ½è±¡ç±»ï¼Œæ— æ³•å®ä¾‹åŒ–å¯¹è±¡ è™šææ„è¯­æ³•ï¼š virtual ~ç±»å()&#123;&#125; çº¯è™šææ„è¯­æ³•ï¼š virtual ~ç±»å() = 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//è™šææ„å‡½æ•°å’Œçº¯è™šææ„å‡½æ•°class Animal&#123;public: //çº¯è™šå‡½æ•° Animal() &#123; cout &lt;&lt; &quot;Animalçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~Animal() &#123; cout &lt;&lt; &quot;Animalçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; virtual void speak() = 0;&#125;;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Catçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;å°çŒ«åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Catçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //çˆ¶ç±»æŒ‡é’ˆåœ¨ææ„æ—¶ï¼Œä¸ä¼šè°ƒç”¨å­ç±»ä¸­çš„ææ„å‡½æ•°ï¼Œå¯¼è‡´å¦‚æœå­ç±»æœ‰å †åŒºå±æ€§ï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼ delete animal;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Animalçš„æ„é€ å‡½æ•°è°ƒç”¨Catçš„æ„é€ å‡½æ•°è°ƒç”¨Tomå°çŒ«åœ¨è¯´è¯Animalçš„ææ„å‡½æ•°è°ƒç”¨ çˆ¶ç±»æŒ‡é’ˆåœ¨ææ„æ—¶ï¼Œä¸ä¼šè°ƒç”¨å­ç±»ä¸­çš„ææ„å‡½æ•°ï¼Œå¯¼è‡´å¦‚æœå­ç±»æœ‰å †åŒºå±æ€§ï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼ æˆ‘ä»¬ä½¿ç”¨è™šææ„è§£å†³è¿™ä¸ªé—®é¢˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//è™šææ„å‡½æ•°å’Œçº¯è™šææ„å‡½æ•°class Animal&#123;public: //çº¯è™šå‡½æ•° Animal() &#123; cout &lt;&lt; &quot;Animalçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; //å¯ä»¥åˆ©ç”¨è™šææ„è§£å†³çˆ¶ç±»æŒ‡é’ˆé‡Šæ”¾å­ç±»å¯¹è±¡æ—¶ä¸å¹²å‡€çš„é—®é¢˜ virtual ~Animal() &#123; cout &lt;&lt; &quot;Animalçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; virtual void speak() = 0;&#125;;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Catçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;å°çŒ«åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Catçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //çˆ¶ç±»æŒ‡é’ˆåœ¨ææ„æ—¶ï¼Œä¸ä¼šè°ƒç”¨å­ç±»ä¸­çš„ææ„å‡½æ•°ï¼Œå¯¼è‡´å¦‚æœå­ç±»æœ‰å †åŒºå±æ€§ï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼ delete animal;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Animalçš„æ„é€ å‡½æ•°è°ƒç”¨Catçš„æ„é€ å‡½æ•°è°ƒç”¨Tomå°çŒ«åœ¨è¯´è¯Catçš„ææ„å‡½æ•°è°ƒç”¨Animalçš„ææ„å‡½æ•°è°ƒç”¨ æˆ‘ä»¬ä½¿ç”¨çº¯è™šææ„è§£å†³è¿™ä¸ªé—®é¢˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//è™šææ„å‡½æ•°å’Œçº¯è™šææ„å‡½æ•°class Animal&#123;public: //çº¯è™šå‡½æ•° Animal() &#123; cout &lt;&lt; &quot;Animalçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; //å¯ä»¥åˆ©ç”¨çº¯è™šææ„è§£å†³çˆ¶ç±»æŒ‡é’ˆé‡Šæ”¾å­ç±»å¯¹è±¡æ—¶ä¸å¹²å‡€çš„é—®é¢˜ //æœ‰äº†çº¯è™šææ„ä¹‹åï¼Œè¿™ä¸ªç±»ä¹Ÿå±äºæŠ½è±¡ç±»ï¼Œæ— æ³•å®ä¾‹åŒ–å¯¹è±¡ virtual ~Animal() = 0; virtual void speak() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animalçš„çº¯è™šææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl;&#125;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Catçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;å°çŒ«åœ¨è¯´è¯&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Catçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //çˆ¶ç±»æŒ‡é’ˆåœ¨ææ„æ—¶ï¼Œä¸ä¼šè°ƒç”¨å­ç±»ä¸­çš„ææ„å‡½æ•°ï¼Œå¯¼è‡´å¦‚æœå­ç±»æœ‰å †åŒºå±æ€§ï¼Œä¼šå¯¼è‡´å†…å­˜æ³„æ¼ delete animal;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Animalçš„æ„é€ å‡½æ•°è°ƒç”¨Catçš„æ„é€ å‡½æ•°è°ƒç”¨Tomå°çŒ«åœ¨è¯´è¯Catçš„ææ„å‡½æ•°è°ƒç”¨Animalçš„çº¯è™šææ„å‡½æ•°è°ƒç”¨ å¤šæ€æ¡ˆä¾‹ä¸‰ ç”µè„‘ç»„è£…æ¡ˆä¾‹æè¿°ï¼š ç”µè„‘ä¸»è¦ç»„æˆéƒ¨ä»¶ä¸ºCPUï¼ˆç”¨äºè®¡ç®—ï¼‰ï¼Œæ˜¾å¡ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰ï¼Œå†…å­˜æ¡ï¼ˆç”¨äºå­˜å‚¨ï¼‰ å°†æ¯ä¸ªé›¶ä»¶å°è£…å‡ºæŠ½è±¡åŸºç±»ï¼Œå¹¶ä¸”æä¾›ä¸åŒçš„å‚å•†ç”Ÿäº§ä¸åŒçš„é›¶ä»¶ï¼Œä¾‹å¦‚Intelå‚å•†å–Lenovoå‚å•† åˆ›å»ºç”µè„‘ç±»æä¾›è®©ç”µè„‘å·¥ä½œçš„å‡½æ•°ï¼Œå¹¶ä¸”è°ƒç”¨æ¯ä¸ªé›¶ä»¶å·¥ä½œçš„æ¥å£ æµ‹è¯•æ—¶ç»„è£…ä¸‰å°ä¸åŒçš„ç”µè„‘è¿›è¡Œå·¥ä½œ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æŠ½è±¡ä¸åŒçš„ç±»//æŠ½è±¡CPUç±»class CPU&#123;public: //æŠ½è±¡çš„è®¡ç®—å‡½æ•° virtual void calculate() = 0;&#125;;//æŠ½è±¡å†…å­˜ç±»class Memory&#123;public: //æŠ½è±¡çš„å­˜å‚¨å‡½æ•° virtual void storage() = 0;&#125;;//æŠ½è±¡æ˜¾å¡ç±»class VideoCard&#123;public: virtual void display() = 0;&#125;;//æŠ½è±¡ç”µè„‘ç±»class Computer&#123;public: Computer(CPU* cpu, VideoCard* vc, Memory* mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //æä¾›å·¥ä½œçš„å‡½æ•° void work() &#123; //è®©é›¶ä»¶å·¥ä½œèµ·æ¥ï¼Œè°ƒç”¨æ¥å£ m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //æä¾›ææ„å‡½æ•° é‡Šæ”¾ä¸‰ä¸ªç”µè„‘é›¶ä»¶ ~Computer() &#123; if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU* m_cpu;//CPUçš„é›¶ä»¶æŒ‡é’ˆ VideoCard* m_vc;//æ˜¾å¡çš„é›¶ä»¶æŒ‡é’ˆ Memory* m_mem;//å†…å­˜çš„é›¶ä»¶æŒ‡é’ˆ&#125;;//å…·ä½“å‚å•†//Intelå‚å•†class IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intelçš„CPUå¼€å§‹è®¡ç®—äº†ï¼&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Intelçš„æ˜¾å¡å¼€å§‹æ˜¾ç¤ºäº†ï¼&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Intelçš„å†…å­˜æ¡å¼€å§‹å­˜å‚¨äº†ï¼&quot; &lt;&lt; endl; &#125;&#125;;//AMDå‚å•†class AMDCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;AMDçš„CPUå¼€å§‹è®¡ç®—äº†ï¼&quot; &lt;&lt; endl; &#125;&#125;;class AMDVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;AMDçš„æ˜¾å¡å¼€å§‹æ˜¾ç¤ºäº†ï¼&quot; &lt;&lt; endl; &#125;&#125;;class AMDMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;AMDçš„å†…å­˜æ¡å¼€å§‹å­˜å‚¨äº†ï¼&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //ç¬¬ä¸€å°ç”µè„‘é›¶ä»¶ CPU* intelCpu = new IntelCPU; VideoCard* intelCard = new IntelVideoCard; Memory* intelMem = new IntelMemory; //åˆ›å»ºç¬¬ä¸€å°ç”µè„‘ cout &lt;&lt; &quot;ç¬¬ä¸€å°ç”µè„‘å¼€å§‹å·¥ä½œ&quot; &lt;&lt; endl; Computer* computer1 = new Computer(intelCpu,intelCard,intelMem); computer1-&gt;work(); delete computer1; //åˆ›å»ºç¬¬äºŒå°ç”µè„‘ cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;ç¬¬äºŒå°ç”µè„‘å¼€å§‹å·¥ä½œï¼š&quot; &lt;&lt; endl; Computer* computer2 = new Computer(new AMDCPU, new AMDVideoCard, new AMDMemory); computer2-&gt;work(); delete computer2; //åˆ›å»ºç¬¬ä¸‰å°ç”µè„‘ cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;ç¬¬ä¸‰å°ç”µè„‘å¼€å§‹å·¥ä½œï¼š&quot; &lt;&lt; endl; Computer* computer3 = new Computer(new IntelCPU, new AMDVideoCard, new IntelMemory); computer3-&gt;work(); delete computer3;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š ç¬¬ä¸€å°ç”µè„‘å¼€å§‹å·¥ä½œIntelçš„CPUå¼€å§‹è®¡ç®—äº†ï¼Intelçš„æ˜¾å¡å¼€å§‹æ˜¾ç¤ºäº†ï¼Intelçš„å†…å­˜æ¡å¼€å§‹å­˜å‚¨äº†ï¼ ç¬¬äºŒå°ç”µè„‘å¼€å§‹å·¥ä½œï¼šAMDçš„CPUå¼€å§‹è®¡ç®—äº†ï¼AMDçš„æ˜¾å¡å¼€å§‹æ˜¾ç¤ºäº†ï¼AMDçš„å†…å­˜æ¡å¼€å§‹å­˜å‚¨äº†ï¼ ç¬¬ä¸‰å°ç”µè„‘å¼€å§‹å·¥ä½œï¼šIntelçš„CPUå¼€å§‹è®¡ç®—äº†ï¼AMDçš„æ˜¾å¡å¼€å§‹æ˜¾ç¤ºäº†ï¼Intelçš„å†…å­˜æ¡å¼€å§‹å­˜å‚¨äº†ï¼","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  ç»§æ‰¿","slug":"C++-å­¦ä¹ -ç»§æ‰¿","date":"2023-05-02T01:22:05.000Z","updated":"2023-05-09T08:11:01.440Z","comments":true,"path":"2023/05/02/C++-å­¦ä¹ -ç»§æ‰¿/","link":"","permalink":"http://example.com/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/","excerpt":"ç»§æ‰¿æ˜¯é¢å‘å¯¹è±¡ä¸‰å¤§ç‰¹æ€§ä¹‹ä¸€ æœ‰äº›ç±»ä¸ç±»ä¹‹é—´å­˜åœ¨ç‰¹æ®Šçš„å…³ç³»ï¼Œå®šä¹‰è¿™äº›ç±»æ—¶ï¼Œä¸‹çº§åˆ«çš„æˆå‘˜é™¤äº†æ‹¥æœ‰ä¸Šä¸€çº§çš„å…±æ€§è¿˜æœ‰è‡ªå·±çš„ç‰¹æ€§ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥è€ƒè™‘åˆ©ç”¨ç»§æ‰¿çš„æŠ€æœ¯å‡å°‘é‡å¤ä»£ç ã€‚ ç»§æ‰¿çš„åŸºæœ¬è¯­æ³•","text":"ç»§æ‰¿æ˜¯é¢å‘å¯¹è±¡ä¸‰å¤§ç‰¹æ€§ä¹‹ä¸€ æœ‰äº›ç±»ä¸ç±»ä¹‹é—´å­˜åœ¨ç‰¹æ®Šçš„å…³ç³»ï¼Œå®šä¹‰è¿™äº›ç±»æ—¶ï¼Œä¸‹çº§åˆ«çš„æˆå‘˜é™¤äº†æ‹¥æœ‰ä¸Šä¸€çº§çš„å…±æ€§è¿˜æœ‰è‡ªå·±çš„ç‰¹æ€§ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å¯ä»¥è€ƒè™‘åˆ©ç”¨ç»§æ‰¿çš„æŠ€æœ¯å‡å°‘é‡å¤ä»£ç ã€‚ ç»§æ‰¿çš„åŸºæœ¬è¯­æ³•è¯­æ³•ï¼š class å­ç±»ï¼šç»§æ‰¿æ–¹å¼ çˆ¶ç±» å­ç±»ä¹Ÿæˆä¸ºæ´¾ç”Ÿç±»ï¼Œçˆ¶ç±»ä¹Ÿæˆä¸ºåŸºç±» ä¾‹å¦‚æˆ‘ä»¬çœ‹åˆ°å¾ˆå¤šç½‘ç«™ä¸­ï¼Œéƒ½æœ‰å…¬å…±çš„å¤´éƒ¨ï¼Œå…¬å…±çš„åº•éƒ¨ï¼Œç”šè‡³å…¬å…±çš„å·¦ä¾§åˆ—è¡¨ï¼Œåªæœ‰ä¸­å¿ƒå†…å®¹ä¸åŒï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†åˆ«åˆ©ç”¨æ™®é€šå†™æ³•å’Œç»§æ‰¿çš„å†™æ³•æ¥å®ç°ç½‘é¡µä¸­çš„å†…å®¹ï¼Œçœ‹ä¸€ä¸‹ç»§æ‰¿å­˜åœ¨çš„æ„ä¹‰ä»¥åŠå¥½å¤„ æ™®é€šå®ç°å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æ™®é€šå®ç°é¡µé¢//Javaé¡µé¢class Java&#123;public: void header() &#123; cout &lt;&lt; &quot;é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œ...ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾...ï¼ˆå…¬å…±åº•éƒ¨)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Javaã€Pythonã€C++...ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Javaå­¦ç§‘è§†é¢‘&quot; &lt;&lt; endl; &#125;&#125;;//Pythoné¡µé¢class Python&#123;public: void header() &#123; cout &lt;&lt; &quot;é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œ...ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾...ï¼ˆå…¬å…±åº•éƒ¨)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Javaã€Pythonã€C++...ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Pythonå­¦ç§‘è§†é¢‘&quot; &lt;&lt; endl; &#125;&#125;;//C++é¡µé¢class Cpp&#123;public: void header() &#123; cout &lt;&lt; &quot;é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œ...ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾...ï¼ˆå…¬å…±åº•éƒ¨)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Javaã€Pythonã€C++...ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;C++å­¦ç§‘è§†é¢‘&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; cout &lt;&lt; &quot;Javaé¡µé¢å¦‚ä¸‹&quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Pythoné¡µé¢å¦‚ä¸‹&quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;C++é¡µé¢å¦‚ä¸‹&quot; &lt;&lt; endl; Cpp cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Javaé¡µé¢å¦‚ä¸‹é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œâ€¦ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾â€¦ï¼ˆå…¬å…±åº•éƒ¨)Javaã€Pythonã€C++â€¦ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨Javaå­¦ç§‘è§†é¢‘ Pythoné¡µé¢å¦‚ä¸‹é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œâ€¦ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾â€¦ï¼ˆå…¬å…±åº•éƒ¨)Javaã€Pythonã€C++â€¦ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨Pythonå­¦ç§‘è§†é¢‘ C++é¡µé¢å¦‚ä¸‹é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œâ€¦ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾â€¦ï¼ˆå…¬å…±åº•éƒ¨)Javaã€Pythonã€C++â€¦ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨C++å­¦ç§‘è§†é¢‘ ç»§æ‰¿å®ç°å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç»§æ‰¿å®ç°é¡µé¢//å…¬å…±é¡µé¢ç±»class Basepage&#123;public: void header() &#123; cout &lt;&lt; &quot;é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œ...ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾...ï¼ˆå…¬å…±åº•éƒ¨)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Javaã€Pythonã€C++...ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨&quot; &lt;&lt; endl; &#125;&#125;;//Javaé¡µé¢class Java : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;Javaå­¦ç§‘è§†é¢‘&quot; &lt;&lt; endl; &#125;&#125;;//Pythoné¡µé¢class Python : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;Pythonå­¦ç§‘è§†é¢‘&quot; &lt;&lt; endl; &#125;&#125;;//C++é¡µé¢class Cpp : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;C++å­¦ç§‘è§†é¢‘&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; cout &lt;&lt; &quot;Javaé¡µé¢å¦‚ä¸‹&quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Pythoné¡µé¢å¦‚ä¸‹&quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;C++é¡µé¢å¦‚ä¸‹&quot; &lt;&lt; endl; Cpp cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Javaé¡µé¢å¦‚ä¸‹é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œâ€¦ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾â€¦ï¼ˆå…¬å…±åº•éƒ¨)Javaã€Pythonã€C++â€¦ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨Javaå­¦ç§‘è§†é¢‘ Pythoné¡µé¢å¦‚ä¸‹é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œâ€¦ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾â€¦ï¼ˆå…¬å…±åº•éƒ¨)Javaã€Pythonã€C++â€¦ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨Pythonå­¦ç§‘è§†é¢‘ C++é¡µé¢å¦‚ä¸‹é¦–é¡µã€å…¬å¼€è¯¾ã€ç™»å½•ã€æ³¨å†Œâ€¦ï¼ˆå…¬å…±å¤´éƒ¨ï¼‰å¸®åŠ©ä¸­å¿ƒã€äº¤æµåˆä½œã€ç«™å†…åœ°å›¾â€¦ï¼ˆå…¬å…±åº•éƒ¨)Javaã€Pythonã€C++â€¦ï¼ˆå…¬å…±åˆ†ç±»åˆ—è¡¨C++å­¦ç§‘è§†é¢‘ ç»§æ‰¿æ–¹å¼ç»§æ‰¿çš„æ–¹å¼ä¸€å…±æœ‰ä¸‰ç§ å…¬å…±ç»§æ‰¿ ä¿æŠ¤ç»§æ‰¿ ç§æœ‰ç»§æ‰¿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç»§æ‰¿æ–¹å¼class Base&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son1 :public Base&#123;public: void func() &#123; m_A = 10;//çˆ¶ç±»ä¸­çš„å…¬å…±æƒé™æˆå‘˜åˆ°å­ç±»ä¸­ä¾ç„¶æ˜¯å…¬å…±æƒé™ m_B = 10;//çˆ¶ç±»ä¸­çš„ä¿æŠ¤æƒé™æˆå‘˜åˆ°å­ç±»ä¸­ä¾ç„¶æ˜¯ä¿æŠ¤æƒé™ //m_C = 10;//çˆ¶ç±»ä¸­çš„ç§æœ‰æƒé™æˆå‘˜å­ç±»è®¿é—®ä¸åˆ° &#125;&#125;;void test01()&#123; Son1 s1; s1.m_A = 100; //s1.m_B = 100;//åˆ°Son1ä¸­m_Bæ˜¯ä¿æŠ¤æƒé™ï¼Œç±»å¤–è®¿é—®ä¸åˆ°&#125;//ä¿æŠ¤ç»§æ‰¿class Son2 :protected Base&#123;public: void func() &#123; m_A = 100;//çˆ¶ç±»ä¸­çš„å…¬å…±æƒé™æˆå‘˜åˆ°å­ç±»ä¸­å˜ä¸ºä¿æŠ¤æƒé™ m_B = 100;//çˆ¶ç±»ä¸­çš„ä¿æŠ¤æƒé™æˆå‘˜åˆ°å­ç±»ä¸­ä¾ç„¶æ˜¯ä¿æŠ¤æƒé™ //m_C = 100;//çˆ¶ç±»ä¸­ç§æœ‰æƒé™æˆå‘˜å­ç±»è®¿é—®ä¸åˆ° &#125;&#125;;void test02()&#123; Son2 s1; //s1.m_A = 10;//åœ¨Son2ä¸­ m_Aå˜ä¸ºä¿æŠ¤æƒé™ï¼Œå› æ­¤ç±»å¤–è®¿é—®ä¸åˆ° //s1.m_B = 10;//åœ¨Son2ä¸­ m_Bå˜ä¸ºä¿æŠ¤æƒé™ï¼Œä¸å¯ä»¥è®¿é—®&#125;class Son3 :private Base&#123;public: void func() &#123; m_A = 100;//çˆ¶ç±»ä¸­çš„å…¬å…±æƒé™æˆå‘˜åˆ°å­ç±»ä¸­å˜ä¸ºä¿æŠ¤æƒé™ m_B = 100;//çˆ¶ç±»ä¸­çš„ä¿æŠ¤æƒé™æˆå‘˜åˆ°å­ç±»ä¸­å˜ä¸ºç§æœ‰æƒé™ //m_C = 100;//çˆ¶ç±»ä¸­çš„ç§æœ‰æˆå‘˜å­ç±»è®¿é—®ä¸åˆ° &#125;&#125;;void test03()&#123; Son3 s1; //s1.m_A = 10;//åˆ°Son3ä¸­å˜ä¸ºç§æœ‰æˆå‘˜ï¼Œç±»å¤–è®¿é—®ä¸äº† //s1.m_B = 10;//åˆ°Son3ä¸­å˜ä¸ºç§æœ‰æˆå‘˜ï¼Œç±»å¤–è®¿é—®ä¸äº†&#125;int main()&#123; test01(); test02(); test03();&#125; ç»§æ‰¿ä¸­çš„å¯¹è±¡æ¨¡å‹é—®é¢˜ï¼šä»çˆ¶ç±»ç»§æ‰¿è¿‡æ¥çš„æˆå‘˜ï¼Œå“ªäº›å±äºå­ç±»å¯¹è±¡ä¸­ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç»§æ‰¿ä¸­çš„å¯¹è±¡æ¨¡å‹class Base&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son :public Base&#123;public: int m_D;&#125;;void test01()&#123; cout &lt;&lt; &quot;size of Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š size of Son &#x3D; 16 çˆ¶ç±»ä¸­æ‰€æœ‰éé™æ€æˆå‘˜å±æ€§éƒ½ä¼šè¢«å­ç±»ç»§æ‰¿ä¸‹å» çˆ¶ç±»ä¸­ç§æœ‰æˆå‘˜å±æ€§æ˜¯è¢«ç¼–è¯‘å™¨ç»™éšè—äº†ï¼Œå› æ­¤æ˜¯è®¿é—®ä¸åˆ°ï¼Œä½†æ˜¯ç¡®å®æ˜¯è¢«ç»§æ‰¿ä¸‹å»äº† å¼€å‘äººå‘˜å‘½ä»¤æç¤ºå·¥å…·æŸ¥çœ‹å¯¹è±¡æ¨¡å‹æ‰“å¼€vså¼€å‘äººå‘˜å‘½ä»¤æç¤ºå·¥å…· è½¬åˆ°æ–‡ä»¶å¯¹åº”çš„è·¯å¾„ è¾“å…¥å‘½ä»¤æŸ¥çœ‹ç±» 1cl /d1 reportSingleClassLayoutç±»å æ–‡ä»¶å ç»§æ‰¿ä¸­æ„é€ å’Œææ„é¡ºåºå­ç±»ç»§æ‰¿çˆ¶ç±»åï¼Œå½“åˆ›å»ºå­ç±»å¯¹è±¡ï¼Œä¹Ÿä¼šè°ƒç”¨çˆ¶ç±»çš„æ„é€ å‡½æ•° 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç»§æ‰¿ä¸­çš„æ„é€ å’Œææ„é¡ºåºclass Base&#123;public: Base() &#123; cout &lt;&lt; &quot;Baseçš„æ„é€ å‡½æ•°ï¼&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Baseçš„ææ„å‡½æ•°ï¼&quot; &lt;&lt; endl; &#125;&#125;;class Son :public Base&#123;public: Son() &#123; cout &lt;&lt; &quot;Sonçš„æ„é€ å‡½æ•°ï¼&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;Sonçš„ææ„å‡½æ•°ï¼&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; Son s;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Baseçš„æ„é€ å‡½æ•°ï¼Sonçš„æ„é€ å‡½æ•°ï¼Sonçš„ææ„å‡½æ•°ï¼Baseçš„ææ„å‡½æ•°ï¼ å…ˆæ„é€ çˆ¶ç±»å†æ„é€ å­ç±»ï¼Œææ„ç›¸å ç»§æ‰¿åŒåæˆå‘˜å¤„ç†æ–¹å¼è®¿é—®å­ç±»åŒåæˆå‘˜ï¼Œç›´æ¥è®¿é—®å³å¯ è®¿é—®çˆ¶ç±»åŒåæˆå‘˜ï¼Œéœ€è¦åŠ ä½œç”¨åŸŸ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Base&#123;public: Base() &#123; m_A = 100; &#125; void func() &#123; cout &lt;&lt; &quot;Base - func()è°ƒç”¨&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;Base - func(int a)è°ƒç”¨&quot; &lt;&lt; endl; &#125; int m_A;&#125;;class Son :public Base&#123;public: Son() &#123; m_A = 200; &#125; void func() &#123; cout &lt;&lt; &quot;Son - func()è°ƒç”¨&quot; &lt;&lt; endl; &#125; int m_A;&#125;;//åŒåæˆå‘˜å±æ€§void test01()&#123; Son s; cout &lt;&lt; &quot;Sonä¸‹çš„m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; //å¦‚æœé€šè¿‡å­ç±»å¯¹è±¡ï¼Œè®¿é—®åˆ°çˆ¶ç±»ä¸­çš„åŒåæˆå‘˜ï¼Œéœ€è¦åŠ ä½œç”¨åŸŸ cout &lt;&lt; &quot;Baseä¸‹çš„m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;&#125;//åŒåæˆå‘˜å‡½æ•°å¤„ç†void test02()&#123; Son s; s.func();//ç›´æ¥è°ƒç”¨çš„æ˜¯å­ç±»ä¸­çš„åŒåæˆå‘˜ s.Base::func(); //å¦‚æœå­ç±»ä¸­å‡ºç°å’Œçˆ¶ç±»åŒåçš„æˆå‘˜å‡½æ•°ï¼Œå­ç±»çš„åŒåæˆå‘˜ä¼šéšè—æ‰çˆ¶ç±»ä¸­æ‰€æœ‰çš„åŒåæˆå‘˜å‡½æ•° s.Base::func(100);&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š Sonä¸‹çš„m_A &#x3D; 200Baseä¸‹çš„m_A &#x3D; 100Son - func()è°ƒç”¨Base - func()è°ƒç”¨Base - func(int a)è°ƒç”¨ ç»§æ‰¿åŒåé™æ€æˆå‘˜å¤„ç†æ–¹å¼é™æ€æˆå‘˜å’Œéé™æ€æˆå‘˜åŒåï¼Œå¤„ç†æ–¹å¼ä¸€è‡´ è®¿é—®å­ç±»åŒåæˆå‘˜ï¼Œç›´æ¥è®¿é—®å³å¯ è®¿é—®çˆ¶ç±»åŒåæˆå‘˜ï¼Œéœ€è¦åŠ ä½œç”¨åŸŸ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç»§æ‰¿ä¸­çš„åŒåé™æ€æˆå‘˜çš„å¤„ç†æ–¹å¼class Base&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; &quot;Base - static void func()è°ƒç”¨&quot; &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; &quot;Base - static void func(int a)è°ƒç”¨&quot; &lt;&lt; endl; &#125;&#125;;int Base::m_A = 100;class Son :public Base&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; &quot;Son - static void func()è°ƒç”¨&quot; &lt;&lt; endl; &#125;&#125;;int Son::m_A = 200;//åŒåé™æ€æˆå‘˜å±æ€§void test01()&#123; //1ã€é€šè¿‡å¯¹è±¡è®¿é—® cout &lt;&lt; &quot;é€šè¿‡å¯¹è±¡è®¿é—®ï¼š&quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Sonä¸‹çš„m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Baseä¸‹çš„m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //2ã€é€šè¿‡ç±»åè®¿é—® cout &lt;&lt; &quot;é€šè¿‡ç±»åè®¿é—®ï¼š&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Sonä¸‹çš„m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Baseä¸‹çš„m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;//ç¬¬ä¸€ä¸ª::ä»£è¡¨é€šè¿‡ç±»åæ–¹å¼è®¿é—®ï¼Œç¬¬äºŒä¸ª::ä»£è¡¨è®¿é—®çˆ¶ç±»ä½œç”¨åŸŸ&#125;//åŒåé™æ€æˆå‘˜å‡½æ•°void test02()&#123; //1ã€é€šè¿‡å¯¹è±¡è®¿é—® cout &lt;&lt; &quot;é€šè¿‡å¯¹è±¡è®¿é—®ï¼š&quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); //2ã€é€šè¿‡ç±»åè®¿é—® cout &lt;&lt; &quot;é€šè¿‡ç±»åè®¿é—®ï¼š&quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //å­ç±»å‡ºç°å’Œçˆ¶ç±»åŒåé™æ€æˆå‘˜å‡½æ•°ï¼Œä¹Ÿä¼šéšè—çˆ¶ç±»ä¸­æ‰€æœ‰çš„åŒåæˆå‘˜å‡½æ•° //å¦‚æœæƒ³è®¿é—®çˆ¶ç±»ä¸­è¢«éšè—åŒåæˆå‘˜ï¼Œéœ€è¦åŠ ä½œç”¨åŸŸ Son::Base::func(100);&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š é€šè¿‡å¯¹è±¡è®¿é—®ï¼šSonä¸‹çš„m_A &#x3D; 200Baseä¸‹çš„m_A &#x3D; 100é€šè¿‡ç±»åè®¿é—®ï¼šSonä¸‹çš„m_A &#x3D; 200Baseä¸‹çš„m_A &#x3D; 100é€šè¿‡å¯¹è±¡è®¿é—®ï¼šSon - static void func()è°ƒç”¨Base - static void func()è°ƒç”¨é€šè¿‡ç±»åè®¿é—®ï¼šSon - static void func()è°ƒç”¨Base - static void func()è°ƒç”¨Base - static void func(int a)è°ƒç”¨ å¤šç»§æ‰¿è¯­æ³•C++å…è®¸ä¸€ä¸ªç±»ç»§æ‰¿å¤šä¸ªç±» è¯­æ³•ï¼šclass å­ç±»ï¼šç»§æ‰¿æ–¹å¼ çˆ¶ç±»1ï¼Œç»§æ‰¿æ–¹å¼ çˆ¶ç±»2 ... å¤šç»§æ‰¿å¯èƒ½ä¼šå¼•å‘çˆ¶ç±»ä¸­æœ‰åŒåæˆå‘˜å‡ºç°ï¼Œéœ€è¦åŠ ä½œç”¨åŸŸåŒºåˆ† C++å®é™…å¼€å‘ä¸­ä¸å»ºè®®ä½¿ç”¨å¤šç»§æ‰¿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å¤šç»§æ‰¿è¯­æ³•class Base1&#123;public: Base1() &#123; m_A = 100; &#125; int m_A;&#125;;class Base2&#123;public: Base2() &#123; m_A = 200; &#125; int m_A;&#125;;class Son :public Base1, public Base2&#123;public: Son() &#123; m_C = 300; m_D = 400; &#125; int m_C; int m_D;&#125;;void test01()&#123; Son s; cout &lt;&lt; &quot;size of Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; &quot;Base1::m_A = &quot; &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base2::m_A = &quot; &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š size of Son &#x3D; 16Base1::m_A &#x3D; 100Base2::m_A &#x3D; 200 è±å½¢ç»§æ‰¿è±å½¢ç»§æ‰¿æ¦‚å¿µï¼š ä¸¤ä¸ªæ´¾ç”Ÿç±»ç»§æ‰¿åŒä¸€ä¸ªåŸºç±» åˆæœ‰æŸä¸ªç±»åŒæ—¶ç»§æ‰¿ä¸¤ä¸ªæ´¾ç”Ÿç±» è¿™ç§ç»§æ‰¿è¢«ç§°ä¸ºè±å½¢ç»§æ‰¿æˆ–é’»çŸ³ç»§æ‰¿ ä¸ä½¿ç”¨è™šç»§æ‰¿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//åŠ¨ç‰©ç±»class Animal&#123;public: int m_Age;&#125;;//åˆ©ç”¨è™šç»§æ‰¿è§£å†³è±å½¢ç»§æ‰¿çš„é—®é¢˜//ç»§æ‰¿ä¹‹å‰åŠ ä¸Šå…³é”®å­—virtualå˜ä¸ºè™šç»§æ‰¿//Animalç±»ç§°ä¸ºè™šåŸºç±» //ç¾Šç±»class Sheep :virtual public Animal &#123;&#125;;//é©¼ç±»class Tuo :virtual public Animal&#123;&#125;;//ç¾Šé©¼ç±»class SheepTuo :public Sheep, public Tuo&#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 18; st.Tuo::m_Age = 28; //å½“è±å½¢ç»§æ‰¿ï¼Œä¸¤ä¸ªçˆ¶ç±»æ‹¥æœ‰ç›¸åŒæ•°æ®ï¼Œéœ€è¦åŠ ä»¥ä½œç”¨åŸŸåŒºåˆ† cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; //è¿™ä»½æ•°æ®æˆ‘ä»¬çŸ¥é“ åªè¦æœ‰ä¸€ä»½å°±å¯ä»¥ï¼Œè±å½¢ç»§æ‰¿å¯¼è‡´æ•°æ®æœ‰ä¸¤ä»½ï¼Œèµ„æºæµªè´¹&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š st.Sheep::m_Age &#x3D; 28st.Tuo::m_Age &#x3D; 28","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  è¿ç®—ç¬¦é‡è½½","slug":"C++-å­¦ä¹ -è¿ç®—ç¬¦é‡è½½","date":"2023-04-30T07:57:41.000Z","updated":"2023-05-14T06:33:48.634Z","comments":true,"path":"2023/04/30/C++-å­¦ä¹ -è¿ç®—ç¬¦é‡è½½/","link":"","permalink":"http://example.com/2023/04/30/C++-%E5%AD%A6%E4%B9%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"è¿ç®—ç¬¦é‡è½½æ¦‚å¿µï¼šå¯¹å·²æœ‰çš„è¿ç®—ç¬¦é‡æ–°è¿›è¡Œå®šä¹‰ï¼Œèµ‹äºˆå…¶å¦ä¸€ç§åŠŸèƒ½ï¼Œä»¥é€‚åº”ä¸åŒçš„æ•°æ®ç±»å‹ åŠ å·è¿ç®—ç¬¦é‡è½½ä½œç”¨ï¼šå®ç°ä¸¤ä¸ªè‡ªå®šä¹‰æ•°æ®ç±»å‹ç›¸åŠ çš„è¿ç®—","text":"è¿ç®—ç¬¦é‡è½½æ¦‚å¿µï¼šå¯¹å·²æœ‰çš„è¿ç®—ç¬¦é‡æ–°è¿›è¡Œå®šä¹‰ï¼Œèµ‹äºˆå…¶å¦ä¸€ç§åŠŸèƒ½ï¼Œä»¥é€‚åº”ä¸åŒçš„æ•°æ®ç±»å‹ åŠ å·è¿ç®—ç¬¦é‡è½½ä½œç”¨ï¼šå®ç°ä¸¤ä¸ªè‡ªå®šä¹‰æ•°æ®ç±»å‹ç›¸åŠ çš„è¿ç®— æˆå‘˜å‡½æ•°é‡è½½123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;//åŠ å·è¿ç®—ç¬¦é‡è½½using namespace std;class Person&#123;public: Person operator+ (Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125; int m_A; int m_B;&#125;;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 20; p2.m_B = 20; Person p3 = p1 + p2; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š p3.m_A &#x3D; 30p3.m_B &#x3D; 30 æˆå‘˜å‡½æ•°é‡è½½æœ¬è´¨è°ƒç”¨ 1Person p3 = p1.operator+(p2); 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å…¨å±€å‡½æ•°é‡è½½class Person&#123;public: int m_A; int m_B;&#125;;Person operator+ (Person&amp; p1, Person&amp; p2)&#123; Person temp; temp.m_A = p1.m_A + p2.m_A; temp.m_B = p1.m_B + p2.m_B; return temp;&#125;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 20; p2.m_B = 20; Person p3 = p1 + p2; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š p3.m_A &#x3D; 30p3.m_B &#x3D; 30 å…¨å±€å‡½æ•°é‡è½½æœ¬è´¨è°ƒç”¨ 1Person p3 = operator+(p1,p2); è¿ç®—ç¬¦é‡è½½ä¹Ÿå¯ä»¥å‡½æ•°é‡è½½12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å…¨å±€å‡½æ•°é‡è½½class Person&#123;public: int m_A; int m_B;&#125;;Person operator+ (Person&amp; p1,int num)&#123; Person temp; temp.m_A = p1.m_A + num; temp.m_B = p1.m_B + num; return temp;&#125;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p3 = p1 + 10; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š p3.m_A &#x3D; 20p3.m_B &#x3D; 20 å·¦ç§»è¿ç®—ç¬¦é‡è½½ä½œç”¨ï¼šå¯ä»¥è¾“å‡ºè‡ªå®šä¹‰çš„æ•°æ®ç±»å‹ 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å·¦ç§»è¿ç®—ç¬¦é‡è½½class Person&#123;public: //åˆ©ç”¨æˆå‘˜å‡½æ•°é‡è½½å·¦ç§»è¿ç®—ç¬¦&lt;&lt; //é€šå¸¸ä¸ä¼šåˆ©ç”¨æˆå‘˜å‡½æ•°é‡è½½&lt;&lt;ï¼Œå› ä¸ºä¸èƒ½å®ç°coutåœ¨å·¦ä¾§ int m_A; int m_B;&#125;;ostream &amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p)&#123; cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; &quot; m_B = &quot; &lt;&lt; p.m_B; return cout;&#125;void test01()&#123; Person p; p.m_A = 10; p.m_B = 10; cout &lt;&lt; p &lt;&lt;endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š m_A &#x3D; 10 m_B &#x3D; 10 é€’å¢è¿ç®—ç¬¦é‡è½½ä½œç”¨ï¼šé€šè¿‡é‡è½½é€’å¢è¿ç®—ç¬¦ï¼Œå®ç°è‡ªå·±çš„æ•´å‹æ•°æ® 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//é‡è½½é€’å¢è¿ç®—ç¬¦//è‡ªå®šä¹‰æ•´å‹class MyInteger&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint);public: MyInteger() &#123; m_Num = 0; &#125; //é‡è½½å‰ç½®++è¿ç®—ç¬¦ è¿”å›å¼•ç”¨æ˜¯ä¸ºäº†ä¸€ç›´å¯¹ä¸€ä¸ªæ•°æ®æ“ä½œ MyInteger&amp; operator++() &#123; //å…ˆåš++è¿ç®— m_Num++; //å†è¿”å›è‡ªèº« return *this; &#125; //é‡è½½åç½®++è¿ç®—ç¬¦ intä»£è¡¨å ä½å‚æ•°ï¼Œå¯ä»¥ç”¨äºåŒºåˆ†å‰ç½®å’Œåç½®é€’å¢ MyInteger operator++(int) &#123; //å…ˆè®°å½•ç»“æœ MyInteger temp = *this; //åé€’å¢ m_Num++; //è¿”å›è®°å½•çš„ç»“æœ return temp; &#125;private: int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)&#123; cout &lt;&lt; myint.m_Num; return cout;&#125;void test01()&#123; MyInteger myint; cout &lt;&lt; ++myint &lt;&lt; endl;&#125;void test02()&#123; MyInteger myint; cout &lt;&lt; myint++ &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š 1 0 èµ‹å€¼è¿ç®—ç¬¦é‡è½½C++ç¼–è¯‘å™¨è‡³å°‘ç»™ä¸€ä¸ªç±»æ·»åŠ å››ä¸ªå‡½æ•° 1ã€é»˜è®¤æ„é€ å‡½æ•°ï¼ˆæ— å‚ï¼Œå‡½æ•°ä½“ä¸ºç©ºï¼‰ 2ã€é»˜è®¤ææ„å‡½æ•°ï¼ˆæ— å‚ï¼Œå‡½æ•°ä½“ä¸ºç©ºï¼‰ 3ã€é»˜è®¤æ‹·è´æ„é€ å‡½æ•°ï¼Œå¯¹å±æ€§è¿›è¡Œå€¼æ‹·è´ 4ã€èµ‹å€¼è¿ç®—ç¬¦operator&#x3D;å¯¹å±æ€§è¿›è¡Œå€¼æ‹·è´ å¦‚æœç±»ä¸­æœ‰å±æ€§æŒ‡å‘å †åŒºï¼Œåšèµ‹å€¼æ“ä½œæ—¶ä¹Ÿä¼šå‡ºç°æ·±æµ…æ‹·è´é—®é¢˜ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//èµ‹å€¼è¿ç®—ç¬¦é‡è½½class Person&#123;public: Person(int age) &#123; m_Age = new int(age); &#125; int* m_Age; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; Person&amp; operator=(Person&amp; p) &#123; //ç¼–è¯‘å™¨æä¾›æµ…æ‹·è´ //åº”è¯¥å…ˆåˆ¤æ–­æ˜¯å¦æœ‰å±æ€§åœ¨å †åŒºï¼Œå¦‚æœæœ‰ï¼Œå…ˆé‡Šæ”¾å¹²å‡€ï¼Œç„¶åå†æ·±æ‹·è´ if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //æ·±æ‹·è´ m_Age = new int(*p.m_Age); //è¿”å›å¯¹è±¡æœ¬èº« return *this; &#125;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; cout &lt;&lt; &quot;p1çš„å¹´é¾„ä¸ºï¼š &quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2çš„å¹´é¾„ä¸ºï¼š &quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3çš„å¹´é¾„ä¸ºï¼š &quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š p1çš„å¹´é¾„ä¸ºï¼š 18p2çš„å¹´é¾„ä¸ºï¼š 18p3çš„å¹´é¾„ä¸ºï¼š 18 å…³ç³»è¿ç®—ç¬¦é‡è½½ä½œç”¨ï¼šé‡è½½å…³ç³»è¿ç®—ç¬¦ï¼Œå¯ä»¥è®©ä¸¤ä¸ªè‡ªå®šä¹‰ç±»å‹å¯¹è±¡è¿›è¡Œå¯¹æ¯”æ“ä½œ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//é‡è½½å…³ç³»è¿ç®—ç¬¦class Person&#123;public: Person(string name, int age) &#123; m_Name = name; m_Age = age; &#125; string m_Name; int m_Age; bool operator==(Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false; &#125; bool operator!=(Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; return true; &#125;&#125;;void test01()&#123; Person p1(&quot;Tom&quot;, 18); Person p2(&quot;Tom&quot;, 18); if (p1 == p2) &#123; cout &lt;&lt; &quot;p1å’Œp2æ˜¯ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1å’Œp2æ˜¯ä¸ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125; if (p1 != p2) &#123; cout &lt;&lt; &quot;p1å’Œp2æ˜¯ä¸ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1å’Œp2æ˜¯ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š p1å’Œp2æ˜¯ç›¸ç­‰çš„p1å’Œp2æ˜¯ç›¸ç­‰çš„ å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦é‡è½½å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦ï¼ˆï¼‰ä¹Ÿå¯ä»¥é‡è½½ ç”±äºé‡è½½åä½¿ç”¨çš„æ–¹å¼éå¸¸åƒå‡½æ•°çš„è°ƒç”¨ï¼Œå› æ­¤ç§°ä¸ºä»¿å‡½æ•° ä»¿å‡½æ•°æ²¡æœ‰å›ºå®šå†™æ³•ï¼Œéå¸¸çµæ´» 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦é‡è½½class MyPrint&#123;public: //é‡è½½å‡½æ•°è°ƒç”¨è¿ç®—ç¬¦ void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; &#125;&#125;;void test01()&#123; MyPrint myPrint; myPrint(&quot;hello world&quot;);&#125;//ä»¿å‡½æ•°éå¸¸çµæ´»ï¼Œæ²¡æœ‰å›ºå®šçš„å†™æ³•//åŠ æ³•ç±»class MyAdd&#123;public: int operator()(int num1, int num2) &#123; return num1 + num2; &#125;&#125;;void test02()&#123; MyAdd myadd; int ret = myadd(100, 100); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //åŒ¿åå‡½æ•°å¯¹è±¡ cout &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š hello worldret &#x3D; 200200","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  å‹å…ƒ","slug":"C++-å­¦ä¹ -å‹å…ƒ","date":"2023-04-29T10:03:06.000Z","updated":"2023-05-09T08:11:48.455Z","comments":true,"path":"2023/04/29/C++-å­¦ä¹ -å‹å…ƒ/","link":"","permalink":"http://example.com/2023/04/29/C++-%E5%AD%A6%E4%B9%A0-%E5%8F%8B%E5%85%83/","excerpt":"ç”Ÿæ´»ä¸­ä½ çš„å®¶æœ‰å®¢å…ï¼ˆpublicï¼‰ï¼Œæœ‰ä½ çš„å§å®¤ï¼ˆprivateï¼‰ å®¢å…æ‰€æœ‰æ¥çš„å®¢äººéƒ½å¯ä»¥è¿›å»ï¼Œä½†æ˜¯ä½ çš„å§å®¤æ˜¯ç§æœ‰çš„ï¼Œä¹Ÿå°±æ˜¯è¯´åªæœ‰ä½ èƒ½è¿›å» ä½†æ˜¯å‘¢ï¼Œä½ ä¹Ÿå¯ä»¥å…è®¸ä½ çš„å¥½é—ºèœœåŸºå‹è¿›å»","text":"ç”Ÿæ´»ä¸­ä½ çš„å®¶æœ‰å®¢å…ï¼ˆpublicï¼‰ï¼Œæœ‰ä½ çš„å§å®¤ï¼ˆprivateï¼‰ å®¢å…æ‰€æœ‰æ¥çš„å®¢äººéƒ½å¯ä»¥è¿›å»ï¼Œä½†æ˜¯ä½ çš„å§å®¤æ˜¯ç§æœ‰çš„ï¼Œä¹Ÿå°±æ˜¯è¯´åªæœ‰ä½ èƒ½è¿›å» ä½†æ˜¯å‘¢ï¼Œä½ ä¹Ÿå¯ä»¥å…è®¸ä½ çš„å¥½é—ºèœœåŸºå‹è¿›å» åœ¨ç¨‹åºé‡Œï¼Œæœ‰äº›ç§æœ‰å±æ€§ä¹Ÿæƒ³è®©ç±»å¤–ç‰¹æ®Šçš„ä¸€äº›å‡½æ•°æˆ–è€…ç±»è¿›è¡Œè®¿é—®ï¼Œå°±éœ€è¦ç”¨åˆ°å‹å…ƒçš„æŠ€æœ¯ å‹å…ƒçš„ç›®çš„å°±æ˜¯è®©ä¸€ä¸ªå‡½æ•°æˆ–è€…ç±»è®¿é—®å¦ä¸€ä¸ªç±»ä¸­çš„ç§æœ‰æˆå‘˜ å‹å…ƒçš„å…³é”®å­—ä¸ºfriend å‹å…ƒçš„ä¸‰ç§å®ç° å…¨å±€å‡½æ•°åšå‹å…ƒ ç±»åšå‹å…ƒ æˆå‘˜å‡½æ•°åšå‹å…ƒ å…¨å±€å‡½æ•°åšå‹å…ƒ123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å»ºç­‘ç‰©ç±»class Building&#123; //goodGuyå…¨å±€å‡½æ•°æ˜¯Buildingçš„å¥½æœ‹å‹ï¼Œå¯ä»¥è®¿é—®Buildingä¸­ç§æœ‰æˆå‘˜ friend void goodGuy(Building* building);public: Building() &#123; m_SittingRoom = &quot;å®¢å…&quot;; m_BedRoom = &quot;å§å®¤&quot;; &#125;public: string m_SittingRoom;//å®¢å…private: string m_BedRoom;//å§å®¤&#125;;//å…¨å±€å‡½æ•°void goodGuy(Building *building)&#123; cout &lt;&lt; &quot;å¥½åŸºå‹çš„å…¨å±€å‡½æ•° æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;å¥½åŸºå‹çš„å…¨å±€å‡½æ•° æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_BedRoom&lt;&lt; endl;&#125;void test01()&#123; Building building; goodGuy(&amp;building);&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š å¥½åŸºå‹çš„å…¨å±€å‡½æ•° æ­£åœ¨è®¿é—®ï¼šå®¢å…å¥½åŸºå‹çš„å…¨å±€å‡½æ•° æ­£åœ¨è®¿é—®ï¼šå§å®¤ ç±»åšå‹å…ƒ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å»ºç­‘ç‰©ç±»class Building;class GoodGuy&#123;public: GoodGuy(); void visit();//å‚è§‚å‡½æ•° è®¿é—®Buildingä¸­çš„å±æ€§ Building* building;&#125;;class Building&#123; //GoodGuyç±»æ˜¯æœ¬ç±»çš„å¥½æœ‹å‹ï¼Œå¯ä»¥è®¿é—®æœ¬ç±»ä¸­çš„ç§æœ‰æˆå‘˜ friend class GoodGuy;public: Building();public: string m_SittingRoom;//å®¢å…private: string m_BedRoom;//å§å®¤&#125;;//ç±»å¤–å†™æˆå‘˜å‡½æ•°Building::Building()&#123; m_SittingRoom = &quot;å®¢å…&quot;; m_BedRoom = &quot;å§å®¤&quot;;&#125;GoodGuy::GoodGuy()&#123; //åˆ›å»ºå»ºç­‘ç‰©å¯¹è±¡ building = new Building;&#125;void GoodGuy::visit()&#123; cout &lt;&lt; &quot;å¥½åŸºå‹ç±»æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;å¥½åŸºå‹ç±»æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; GoodGuy gg; gg.visit();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š å¥½åŸºå‹ç±»æ­£åœ¨è®¿é—®ï¼šå®¢å…å¥½åŸºå‹ç±»æ­£åœ¨è®¿é—®ï¼šå§å®¤ æˆå‘˜å‡½æ•°åšå‹å…ƒ12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Building;class GoodGuy&#123;public: GoodGuy(); void visit();//è®©visitå‡½æ•°å¯ä»¥è®¿é—®Buildingä¸­çš„ç§æœ‰æˆå‘˜ void visit2();//è®©visit2å‡½æ•°ä¸å¯ä»¥è®¿é—®Buildingä¸­ç§æœ‰æˆå‘˜ Building* building;&#125;;class Building&#123; //å‘Šè¯‰ç¼–è¯‘å™¨ GoodGuyç±»ä¸‹çš„visitæˆå‘˜å‡½æ•° friend void GoodGuy::visit();public: Building();public: string m_SittingRoom;//å®¢å…private: string m_BedRoom;//å§å®¤&#125;;Building::Building()&#123; m_SittingRoom = &quot;å®¢å…&quot;; m_BedRoom = &quot;å§å®¤&quot;;&#125;GoodGuy::GoodGuy()&#123; building = new Building;&#125;void GoodGuy::visit()&#123; cout &lt;&lt; &quot;visitå‡½æ•°æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;visitå‡½æ•°æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void GoodGuy::visit2()&#123; cout &lt;&lt; &quot;visit2å‡½æ•°æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;visitå‡½æ•°æ­£åœ¨è®¿é—®ï¼š&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;è®¿é—®ä¸äº†&#125;void test01()&#123; GoodGuy gg; gg.visit(); gg.visit2();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š visitå‡½æ•°æ­£åœ¨è®¿é—®ï¼šå®¢å…visitå‡½æ•°æ­£åœ¨è®¿é—®ï¼šå§å®¤visit2å‡½æ•°æ­£åœ¨è®¿é—®ï¼šå®¢å…","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Linux cgroupå…¥é—¨","slug":"å­¦ä¹ -Linux-cgroupå…¥é—¨","date":"2023-04-26T11:46:46.000Z","updated":"2023-07-18T08:09:52.254Z","comments":true,"path":"2023/04/26/å­¦ä¹ -Linux-cgroupå…¥é—¨/","link":"","permalink":"http://example.com/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/","excerpt":"cgroupï¼ˆæ§åˆ¶ç»„ï¼‰æ˜¯ Linux å†…æ ¸ä¸­çš„ä¸€ä¸ªç‰¹æ€§ï¼Œç”¨äºé™åˆ¶ã€éš”ç¦»å’Œç®¡ç†è¿›ç¨‹å’Œç³»ç»Ÿèµ„æºçš„ä½¿ç”¨ã€‚å®ƒæ˜¯ä¸€ä¸ªå±‚æ¬¡åŒ–çš„ç»„ç»‡ç»“æ„ï¼Œå…è®¸å¯¹è¿›ç¨‹è¿›è¡Œåˆ†ç»„ï¼Œå¹¶ä¸ºè¿™äº›ç»„åˆ†é…ç³»ç»Ÿèµ„æºï¼Œå¦‚ CPUã€å†…å­˜ã€ç£ç›˜ I&#x2F;O å’Œç½‘ç»œå¸¦å®½ã€‚cgroup ä¸»è¦ç”¨äºæ“ä½œç³»ç»Ÿçš„èµ„æºç®¡ç†å’Œå®¹å™¨æŠ€æœ¯ï¼Œå¦‚ Docker å’Œ Kubernetes ç­‰ã€‚ cgroup çš„ç‰¹ç‚¹å’ŒåŠŸèƒ½åŒ…æ‹¬ï¼š èµ„æºé™åˆ¶ï¼šæ‚¨å¯ä»¥ä¸ºæ¯ä¸ª cgroup åˆ†é…ç‰¹å®šçš„ç³»ç»Ÿèµ„æºï¼Œå¦‚ CPU ä½¿ç”¨ç‡ã€å†…å­˜é™åˆ¶ç­‰ã€‚è¿™æœ‰åŠ©äºé˜²æ­¢æŸä¸ªè¿›ç¨‹æˆ–ç»„æ¶ˆè€—è¿‡å¤šèµ„æºï¼Œå½±å“å…¶ä»–è¿›ç¨‹çš„è¿è¡Œã€‚ èµ„æºéš”ç¦»ï¼šcgroup å¯ä»¥å°†ä¸åŒç»„çš„è¿›ç¨‹éš”ç¦»ï¼Œè¿™æ ·å®ƒä»¬ä¸ä¼šäº’ç›¸å½±å“ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªå®¹å™¨ä¸­è¿è¡Œçš„è¿›ç¨‹å¯ä»¥è¢«é™åˆ¶åœ¨å…¶æ‰€åˆ†é…çš„èµ„æºèŒƒå›´å†…ï¼Œä¸ä¼šå½±å“åˆ°å…¶ä»–å®¹å™¨æˆ–ç³»ç»Ÿè¿›ç¨‹ã€‚ èµ„æºç›‘æ§ï¼šé€šè¿‡ cgroupï¼Œæ‚¨å¯ä»¥ç›‘æ§æ¯ä¸ªç»„çš„èµ„æºä½¿ç”¨æƒ…å†µï¼Œä»è€Œæ›´å¥½åœ°äº†è§£ç³»ç»Ÿçš„è¿è¡ŒçŠ¶æ€ã€‚è¿™æœ‰åŠ©äºå‘ç°æ€§èƒ½ç“¶é¢ˆã€ä¼˜åŒ–èµ„æºåˆ†é…ç­‰ã€‚ ä¼˜å…ˆçº§æ§åˆ¶ï¼šcgroup å…è®¸æ‚¨ä¸ºè¿›ç¨‹ç»„åˆ†é…ä¸åŒçš„ä¼˜å…ˆçº§ï¼Œä»¥ç¡®ä¿å…³é”®ä»»åŠ¡å§‹ç»ˆä¼˜å…ˆè·å¾—èµ„æºã€‚","text":"cgroupï¼ˆæ§åˆ¶ç»„ï¼‰æ˜¯ Linux å†…æ ¸ä¸­çš„ä¸€ä¸ªç‰¹æ€§ï¼Œç”¨äºé™åˆ¶ã€éš”ç¦»å’Œç®¡ç†è¿›ç¨‹å’Œç³»ç»Ÿèµ„æºçš„ä½¿ç”¨ã€‚å®ƒæ˜¯ä¸€ä¸ªå±‚æ¬¡åŒ–çš„ç»„ç»‡ç»“æ„ï¼Œå…è®¸å¯¹è¿›ç¨‹è¿›è¡Œåˆ†ç»„ï¼Œå¹¶ä¸ºè¿™äº›ç»„åˆ†é…ç³»ç»Ÿèµ„æºï¼Œå¦‚ CPUã€å†…å­˜ã€ç£ç›˜ I&#x2F;O å’Œç½‘ç»œå¸¦å®½ã€‚cgroup ä¸»è¦ç”¨äºæ“ä½œç³»ç»Ÿçš„èµ„æºç®¡ç†å’Œå®¹å™¨æŠ€æœ¯ï¼Œå¦‚ Docker å’Œ Kubernetes ç­‰ã€‚ cgroup çš„ç‰¹ç‚¹å’ŒåŠŸèƒ½åŒ…æ‹¬ï¼š èµ„æºé™åˆ¶ï¼šæ‚¨å¯ä»¥ä¸ºæ¯ä¸ª cgroup åˆ†é…ç‰¹å®šçš„ç³»ç»Ÿèµ„æºï¼Œå¦‚ CPU ä½¿ç”¨ç‡ã€å†…å­˜é™åˆ¶ç­‰ã€‚è¿™æœ‰åŠ©äºé˜²æ­¢æŸä¸ªè¿›ç¨‹æˆ–ç»„æ¶ˆè€—è¿‡å¤šèµ„æºï¼Œå½±å“å…¶ä»–è¿›ç¨‹çš„è¿è¡Œã€‚ èµ„æºéš”ç¦»ï¼šcgroup å¯ä»¥å°†ä¸åŒç»„çš„è¿›ç¨‹éš”ç¦»ï¼Œè¿™æ ·å®ƒä»¬ä¸ä¼šäº’ç›¸å½±å“ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªå®¹å™¨ä¸­è¿è¡Œçš„è¿›ç¨‹å¯ä»¥è¢«é™åˆ¶åœ¨å…¶æ‰€åˆ†é…çš„èµ„æºèŒƒå›´å†…ï¼Œä¸ä¼šå½±å“åˆ°å…¶ä»–å®¹å™¨æˆ–ç³»ç»Ÿè¿›ç¨‹ã€‚ èµ„æºç›‘æ§ï¼šé€šè¿‡ cgroupï¼Œæ‚¨å¯ä»¥ç›‘æ§æ¯ä¸ªç»„çš„èµ„æºä½¿ç”¨æƒ…å†µï¼Œä»è€Œæ›´å¥½åœ°äº†è§£ç³»ç»Ÿçš„è¿è¡ŒçŠ¶æ€ã€‚è¿™æœ‰åŠ©äºå‘ç°æ€§èƒ½ç“¶é¢ˆã€ä¼˜åŒ–èµ„æºåˆ†é…ç­‰ã€‚ ä¼˜å…ˆçº§æ§åˆ¶ï¼šcgroup å…è®¸æ‚¨ä¸ºè¿›ç¨‹ç»„åˆ†é…ä¸åŒçš„ä¼˜å…ˆçº§ï¼Œä»¥ç¡®ä¿å…³é”®ä»»åŠ¡å§‹ç»ˆä¼˜å…ˆè·å¾—èµ„æºã€‚ cgroup åˆ† v1 å’Œ v2 ä¸¤ä¸ªç‰ˆæœ¬ï¼Œv1 å®ç°è¾ƒæ—©ï¼ŒåŠŸèƒ½æ¯”è¾ƒå¤šï¼Œä½†æ˜¯ç”±äºå®ƒé‡Œé¢çš„åŠŸèƒ½éƒ½æ˜¯é›¶é›¶æ•£æ•£çš„å®ç°çš„ï¼Œæ‰€ä»¥è§„åˆ’çš„ä¸æ˜¯å¾ˆå¥½ï¼Œå¯¼è‡´äº†ä¸€äº›ä½¿ç”¨å’Œç»´æŠ¤ä¸Šçš„ä¸ä¾¿ï¼Œv2 çš„å‡ºç°å°±æ˜¯ä¸ºäº†è§£å†³ v1 ä¸­è¿™æ–¹é¢çš„é—®é¢˜ï¼Œåœ¨ 4.5 å†…æ ¸ä¸­ï¼Œcgroup v2 å£°ç§°å·²ç»å¯ä»¥ç”¨äºç”Ÿäº§ç¯å¢ƒäº†ï¼Œä½†å®ƒæ‰€æ”¯æŒçš„åŠŸèƒ½è¿˜å¾ˆæœ‰é™ï¼Œéšç€ v2 ä¸€èµ·å¼•å…¥å†…æ ¸çš„è¿˜æœ‰ cgroup namespaceã€‚v1 å’Œ v2 å¯ä»¥æ··åˆä½¿ç”¨ï¼Œä½†æ˜¯è¿™æ ·ä¼šæ›´å¤æ‚ï¼Œæ‰€ä»¥ä¸€èˆ¬æ²¡äººä¼šè¿™æ ·ç”¨ã€‚ ä¸ºä»€ä¹ˆéœ€è¦cgroupåœ¨ Linux é‡Œï¼Œä¸€ç›´ä»¥æ¥å°±æœ‰å¯¹è¿›ç¨‹è¿›è¡Œåˆ†ç»„çš„æ¦‚å¿µå’Œéœ€æ±‚ï¼Œæ¯”å¦‚ session groupï¼Œ progress group ç­‰ï¼Œåæ¥éšç€äººä»¬å¯¹è¿™æ–¹é¢çš„éœ€æ±‚è¶Šæ¥è¶Šå¤šï¼Œæ¯”å¦‚éœ€è¦è¿½è¸ªä¸€ç»„è¿›ç¨‹çš„å†…å­˜å’Œ IO ä½¿ç”¨æƒ…å†µç­‰ï¼Œäºæ˜¯å‡ºç°äº† cgroupï¼Œç”¨æ¥ç»Ÿä¸€å°†è¿›ç¨‹è¿›è¡Œåˆ†ç»„ï¼Œå¹¶åœ¨åˆ†ç»„çš„åŸºç¡€ä¸Šå¯¹è¿›ç¨‹è¿›è¡Œç›‘æ§å’Œèµ„æºæ§åˆ¶ç®¡ç†ç­‰ã€‚ ä»€ä¹ˆæ˜¯cgroupæœ¯è¯­ cgroup åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­ä»£è¡¨ä¸åŒçš„æ„æ€ï¼Œå¯ä»¥æŒ‡æ•´ä¸ª Linux çš„ cgroup æŠ€æœ¯ï¼Œä¹Ÿå¯ä»¥æŒ‡ä¸€ä¸ªå…·ä½“è¿›ç¨‹ç»„ã€‚ cgroup æ˜¯ Linux ä¸‹çš„ä¸€ç§å°†è¿›ç¨‹æŒ‰ç»„è¿›è¡Œç®¡ç†çš„æœºåˆ¶ï¼Œåœ¨ç”¨æˆ·å±‚çœ‹æ¥ï¼Œcgroup æŠ€æœ¯å°±æ˜¯æŠŠç³»ç»Ÿä¸­çš„æ‰€æœ‰è¿›ç¨‹ç»„ç»‡æˆä¸€é¢—ä¸€é¢—ç‹¬ç«‹çš„æ ‘ï¼Œæ¯æ£µæ ‘éƒ½åŒ…å«ç³»ç»Ÿçš„æ‰€æœ‰è¿›ç¨‹ï¼Œæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹æ˜¯ä¸€ä¸ªè¿›ç¨‹ç»„ï¼Œè€Œæ¯é¢—æ ‘åˆå’Œä¸€ä¸ªæˆ–è€…å¤šä¸ª subsystem å…³è”ï¼Œæ ‘çš„ä½œç”¨æ˜¯å°†è¿›ç¨‹åˆ†ç»„ï¼Œè€Œ subsystem çš„ä½œç”¨å°±æ˜¯å¯¹è¿™äº›ç»„è¿›è¡Œæ“ä½œã€‚cgroup ä¸»è¦åŒ…æ‹¬ä¸‹é¢ä¸¤éƒ¨åˆ†ï¼š subsystem : ä¸€ä¸ª subsystem å°±æ˜¯ä¸€ä¸ªå†…æ ¸æ¨¡å—ï¼Œä»–è¢«å…³è”åˆ°ä¸€é¢— cgroup æ ‘ä¹‹åï¼Œå°±ä¼šåœ¨æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ˆè¿›ç¨‹ç»„ï¼‰ä¸Šåšå…·ä½“çš„æ“ä½œã€‚subsystem ç»å¸¸è¢«ç§°ä½œ resource controllerï¼Œå› ä¸ºå®ƒä¸»è¦è¢«ç”¨æ¥è°ƒåº¦æˆ–è€…é™åˆ¶æ¯ä¸ªè¿›ç¨‹ç»„çš„èµ„æºï¼Œä½†æ˜¯è¿™ä¸ªè¯´æ³•ä¸å®Œå…¨å‡†ç¡®ï¼Œå› ä¸ºæœ‰æ—¶æˆ‘ä»¬å°†è¿›ç¨‹åˆ†ç»„åªæ˜¯ä¸ºäº†åšä¸€äº›ç›‘æ§ï¼Œè§‚å¯Ÿä¸€ä¸‹ä»–ä»¬çš„çŠ¶æ€ï¼Œæ¯”å¦‚ perf_event subsystemã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼ŒLinux æ”¯æŒ 12 ç§ subsystemï¼Œæ¯”å¦‚é™åˆ¶ CPU çš„ä½¿ç”¨æ—¶é—´ï¼Œé™åˆ¶ä½¿ç”¨çš„å†…å­˜ï¼Œç»Ÿè®¡ CPU çš„ä½¿ç”¨æƒ…å†µï¼Œå†»ç»“å’Œæ¢å¤ä¸€ç»„è¿›ç¨‹ç­‰ hierarchy : ä¸€ä¸ª hierarchy å¯ä»¥ç†è§£ä¸ºä¸€æ£µ cgroup æ ‘ï¼Œæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹å°±æ˜¯ä¸€ä¸ªè¿›ç¨‹ç»„ï¼Œæ¯æ£µæ ‘éƒ½ä¼šä¸é›¶åˆ°å¤šä¸ª subsystem å…³è”ã€‚åœ¨ä¸€é¢—æ ‘é‡Œé¢ï¼Œä¼šåŒ…å« Linux ç³»ç»Ÿä¸­çš„æ‰€æœ‰è¿›ç¨‹ï¼Œä½†æ¯ä¸ªè¿›ç¨‹åªèƒ½å±äºä¸€ä¸ªèŠ‚ç‚¹ï¼ˆè¿›ç¨‹ç»„ï¼‰ã€‚ç³»ç»Ÿä¸­å¯ä»¥æœ‰å¾ˆå¤šé¢— cgroup æ ‘ï¼Œæ¯æ£µæ ‘éƒ½å’Œä¸åŒçš„ subsystem å…³è”ï¼Œä¸€ä¸ªè¿›ç¨‹å¯ä»¥å±äºå¤šé¢—æ ‘ï¼Œå³ä¸€ä¸ªè¿›ç¨‹å¯ä»¥å±äºå¤šä¸ªè¿›ç¨‹ç»„ï¼Œåªæ˜¯è¿™äº›è¿›ç¨‹ç»„å’Œä¸åŒçš„ subsystem å…³è”ã€‚ç›®å‰ Linux æ”¯æŒ 12 ç§ subsystemï¼Œå¦‚æœä¸è€ƒè™‘ä¸ä¸ä»»ä½• subsystem å…³è”çš„æƒ…å†µï¼ˆsystemd å°±å±äºè¿™ç§æƒ…å†µï¼‰ï¼ŒLinux é‡Œé¢æœ€å¤šå¯ä»¥å»º 12 é¢— cgroup æ ‘ï¼Œæ¯æ£µæ ‘å…³è”ä¸€ä¸ª subsystemï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åªå»ºä¸€æ£µæ ‘ï¼Œç„¶åè®©è¿™æ£µæ ‘å…³è”æ‰€æœ‰çš„ subsystemã€‚å½“ä¸€é¢— cgroup æ ‘ä¸å’Œä»»ä½• subsystem å…³è”çš„æ—¶å€™ï¼Œæ„å‘³ç€è¿™æ£µæ ‘åªæ˜¯å°†è¿›ç¨‹è¿›è¡Œåˆ†ç»„ï¼Œè‡³äºè¦åœ¨åˆ†ç»„çš„åŸºç¡€ä¸Šåšäº›ä»€ä¹ˆï¼Œå°†ç”±åº”ç”¨ç¨‹åºè‡ªå·±å†³å®šï¼Œsystemd å°±æ˜¯ä¸€ä¸ªè¿™æ ·çš„ä¾‹å­ã€‚ æŸ¥çœ‹å½“å‰ç³»ç»Ÿæ”¯æŒå“ªäº›subsystemå¯ä»¥é€šè¿‡æŸ¥çœ‹&#x2F;proc&#x2F;cgroupsï¼ˆLinux v5.19.0-38-genericï¼‰ï¼ŒçŸ¥é“å½“å‰ç³»ç»Ÿæ”¯æŒå“ªäº›subsystem 123456789101112131415#subsys_name hierarchy num_cgroups enabledcpuset 0 149 1cpu 0 149 1cpuacct 0 149 1blkio 0 149 1memory 0 149 1devices 0 149 1freezer 0 149 1net_cls 0 149 1perf_event 0 149 1net_prio 0 149 1hugetlb 0 149 1pids 0 149 1rdma 0 149 1misc 0 149 1 ä»å·¦åˆ°å³ï¼Œå­—æ®µçš„å«ä¹‰åˆ†åˆ«æ˜¯ï¼š subsystemçš„åå­— subsystemæ‰€å…³è”åˆ°çš„cgroupæ ‘çš„IDï¼Œå¦‚æœå¤šä¸ªsubsystemå…³è”åˆ°åŒä¸€é¢—cgroupæ ‘ï¼Œé‚£ä¹ˆä»–ä»¬çš„è¿™ä¸ªå­—æ®µå°†ä¸€æ ·ï¼Œæ¯”å¦‚è¿™é‡Œçš„cpuå’Œcpuacctå°±ä¸€æ ·ï¼Œè¡¨ç¤ºä»–ä»¬ç»‘å®šåˆ°äº†åŒä¸€é¢—æ ‘ã€‚å¦‚æœå‡ºç°ä¸‹é¢çš„æƒ…å†µï¼Œè¿™ä¸ªå­—æ®µå°†ä¸º0ï¼š å½“å‰subsystemæ²¡æœ‰å’Œä»»ä½•cgroupæ ‘ç»‘å®š å½“å‰subsystemå·²ç»å’Œcgroup v2çš„æ ‘ç»‘å®š å½“å‰subsystemæ²¡æœ‰è¢«å†…æ ¸å¼€å¯ subsystemæ‰€å…³è”çš„cgroupæ ‘ä¸­è¿›ç¨‹ç»„çš„ä¸ªæ•°ï¼Œä¹Ÿå³æ ‘ä¸ŠèŠ‚ç‚¹çš„ä¸ªæ•° 1è¡¨ç¤ºå¼€å¯ï¼Œ0è¡¨ç¤ºæ²¡æœ‰è¢«å¼€å¯(å¯ä»¥é€šè¿‡è®¾ç½®å†…æ ¸çš„å¯åŠ¨å‚æ•°â€œcgroup_disableâ€æ¥æ§åˆ¶subsystemçš„å¼€å¯). systemdsystemd æ˜¯ä¸€ä¸ª Linux ç³»ç»Ÿå’ŒæœåŠ¡ç®¡ç†å™¨ï¼Œå®ƒæˆä¸ºè®¸å¤šä¸»æµ Linux å‘è¡Œç‰ˆï¼ˆå¦‚ Debianã€Ubuntuã€Fedoraã€RHEL å’Œ CentOS ç­‰ï¼‰çš„é»˜è®¤åˆå§‹åŒ–ç³»ç»Ÿï¼ˆinit systemï¼‰ã€‚systemd è´Ÿè´£åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶å¼•å¯¼å’Œç®¡ç†åå°è¿›ç¨‹ï¼ˆç§°ä¸ºæœåŠ¡æˆ–å®ˆæŠ¤è¿›ç¨‹ï¼‰ï¼Œå¹¶åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å¯¹è¿™äº›æœåŠ¡è¿›è¡Œç›‘æ§å’Œç®¡ç†ã€‚ systemd çš„ä¸»è¦ç‰¹ç‚¹å’Œä¼˜ç‚¹åŒ…æ‹¬ï¼š å¹¶è¡Œå¯åŠ¨æœåŠ¡ï¼šsystemd èƒ½å¤Ÿå¹¶è¡Œå¯åŠ¨æœåŠ¡ï¼Œä»è€ŒåŠ å¿«ç³»ç»Ÿå¯åŠ¨é€Ÿåº¦ã€‚ æŒ‰éœ€å¯åŠ¨æœåŠ¡ï¼šsystemd æ”¯æŒ socket æ¿€æ´»å’Œ D-Bus æ¿€æ´»ï¼Œå¯ä»¥æ ¹æ®éœ€è¦æŒ‰éœ€å¯åŠ¨æœåŠ¡ã€‚ æœåŠ¡ç®¡ç†å’Œç›‘æ§ï¼šsystemd æä¾›äº†åœ¨è¿è¡Œæ—¶ç®¡ç†å’Œç›‘æ§æœåŠ¡çš„åŠŸèƒ½ï¼Œå¦‚è‡ªåŠ¨é‡å¯å¤±è´¥çš„æœåŠ¡ã€è®°å½•æœåŠ¡çŠ¶æ€å’Œæ—¥å¿—ç­‰ã€‚ ç³»ç»Ÿç®¡ç†åŠŸèƒ½ï¼šé™¤äº†ç®¡ç†æœåŠ¡ï¼Œsystemd è¿˜æä¾›äº†ä¸€äº›ç³»ç»Ÿç®¡ç†åŠŸèƒ½ï¼Œå¦‚æ§åˆ¶ç”µæºã€ç®¡ç†ç”¨æˆ·ä¼šè¯å’Œè®¾å¤‡ç­‰ã€‚ systemd ä½¿ç”¨åä¸º unit çš„é…ç½®æ–‡ä»¶æ¥ç®¡ç†æœåŠ¡å’Œèµ„æºã€‚è¿™äº›é…ç½®æ–‡ä»¶å®šä¹‰äº†æœåŠ¡çš„å¯åŠ¨é¡ºåºã€ä¾èµ–å…³ç³»ã€è¿è¡Œå‚æ•°ç­‰ä¿¡æ¯ã€‚Unit å¯ä»¥æ˜¯ä»¥ä¸‹ç±»å‹ä¹‹ä¸€ï¼š æœåŠ¡ï¼ˆServiceï¼‰ï¼šåå°è¿›ç¨‹ï¼ˆå®ˆæŠ¤è¿›ç¨‹ï¼‰ã€‚ å¥—æ¥å­—ï¼ˆSocketï¼‰ï¼šIPC å’Œç½‘ç»œå¥—æ¥å­—ï¼Œç”¨äºæŒ‰éœ€å¯åŠ¨æœåŠ¡ã€‚ è®¾å¤‡ï¼ˆDeviceï¼‰ï¼šè®¾å¤‡èŠ‚ç‚¹ã€‚ æŒ‚è½½ç‚¹ï¼ˆMountï¼‰ï¼šæ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹ã€‚ è‡ªåŠ¨æŒ‚è½½ç‚¹ï¼ˆAutomountï¼‰ï¼šè‡ªåŠ¨æŒ‚è½½æ–‡ä»¶ç³»ç»Ÿã€‚ ç›®æ ‡ï¼ˆTargetï¼‰ï¼šç”¨äºç»„ç»‡å…¶ä»– Unit çš„é€»è¾‘åˆ†ç»„ã€‚ è·¯å¾„ï¼ˆPathï¼‰ï¼šæ–‡ä»¶ç³»ç»Ÿè·¯å¾„ï¼Œç”¨äºç›‘è§†æ–‡ä»¶ç³»ç»Ÿäº‹ä»¶ã€‚ æ—¶é—´å™¨ï¼ˆTimerï¼‰ï¼šå®šæ—¶å™¨ï¼Œç”¨äºå®šæ—¶å¯åŠ¨å…¶ä»– Unitã€‚ å¿«ç…§ï¼ˆSnapshotï¼‰ï¼šä¿å­˜å½“å‰ç³»ç»ŸçŠ¶æ€çš„å¿«ç…§ã€‚ åˆ‡ç‰‡ï¼ˆSliceï¼‰ï¼šç”¨äºç»„ç»‡å’Œç®¡ç†ç³»ç»Ÿèµ„æºçš„å±‚æ¬¡ç»“æ„ã€‚ systemd æä¾›äº†ä¸€äº›å‘½ä»¤è¡Œå·¥å…·ï¼Œå¦‚ systemctlã€journalctl ç­‰ï¼Œç”¨äºç®¡ç†å’ŒæŸ¥è¯¢ç³»ç»Ÿå’ŒæœåŠ¡çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ä½¿ç”¨ systemctl startã€systemctl stopã€systemctl restart ç­‰å‘½ä»¤æ¥æ§åˆ¶æœåŠ¡ã€‚ æ‰€æœ‰çš„subsystemsç›®å‰Linuxæ”¯æŒä¸‹é¢12ç§subsystem cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)ç”¨æ¥é™åˆ¶cgroupçš„CPUä½¿ç”¨ç‡ã€‚ cpuacct (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)ç»Ÿè®¡cgroupçš„CPUçš„ä½¿ç”¨ç‡ã€‚ cpuset (since Linux 2.6.24; CONFIG_CPUSETS)ç»‘å®šcgroupåˆ°æŒ‡å®šCPUså’ŒNUMAèŠ‚ç‚¹ã€‚ memory (since Linux 2.6.25; CONFIG_MEMCG)ç»Ÿè®¡å’Œé™åˆ¶cgroupçš„å†…å­˜çš„ä½¿ç”¨ç‡ï¼ŒåŒ…æ‹¬process memory, kernel memory, å’Œswapã€‚ devices (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)é™åˆ¶cgroupåˆ›å»º(mknod)å’Œè®¿é—®è®¾å¤‡çš„æƒé™ã€‚ freezer (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)suspendå’Œrestoreä¸€ä¸ªcgroupä¸­çš„æ‰€æœ‰è¿›ç¨‹ã€‚ net_cls (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)å°†ä¸€ä¸ªcgroupä¸­è¿›ç¨‹åˆ›å»ºçš„æ‰€æœ‰ç½‘ç»œåŒ…åŠ ä¸Šä¸€ä¸ªclassidæ ‡è®°ï¼Œç”¨äºtcå’Œiptablesã€‚ åªå¯¹å‘å‡ºå»çš„ç½‘ç»œåŒ…ç”Ÿæ•ˆï¼Œå¯¹æ”¶åˆ°çš„ç½‘ç»œåŒ…ä¸èµ·ä½œç”¨ã€‚ blkio (since Linux 2.6.33; CONFIG_BLK_CGROUP)é™åˆ¶cgroupè®¿é—®å—è®¾å¤‡çš„IOé€Ÿåº¦ã€‚ perf_event (since Linux 2.6.39; CONFIG_CGROUP_PERF)å¯¹cgroupè¿›è¡Œæ€§èƒ½ç›‘æ§ net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)é’ˆå¯¹æ¯ä¸ªç½‘ç»œæ¥å£è®¾ç½®cgroupçš„è®¿é—®ä¼˜å…ˆçº§ã€‚ hugetlb (since Linux 3.5; CONFIG_CGROUP_HUGETLB)é™åˆ¶cgroupçš„huge pagesçš„ä½¿ç”¨é‡ã€‚ pids (since Linux 4.3; CONFIG_CGROUP_PIDS)é™åˆ¶ä¸€ä¸ªcgroupåŠå…¶å­å­™cgroupä¸­çš„æ€»è¿›ç¨‹æ•°ã€‚ ä¸Šé¢è¿™äº›subsystemï¼Œæœ‰äº›éœ€è¦åšèµ„æºç»Ÿè®¡ï¼Œæœ‰äº›éœ€è¦åšèµ„æºæ§åˆ¶ï¼Œæœ‰äº›å³ä¸ç»Ÿè®¡ä¹Ÿä¸æ§åˆ¶ã€‚å¯¹äºcgroupæ ‘æ¥è¯´ï¼Œæœ‰äº›subsystemä¸¥é‡ä¾èµ–ç»§æ‰¿å…³ç³»ï¼Œæœ‰äº›subsystemå®Œå…¨ç”¨ä¸åˆ°ç»§æ‰¿å…³ç³»ï¼Œè€Œæœ‰äº›å¯¹ç»§æ‰¿å…³ç³»æ²¡æœ‰ä¸¥æ ¼è¦æ±‚ã€‚ ä¸åŒsubsystemçš„å·¥ä½œæ–¹å¼å¯èƒ½å·®åˆ«è¾ƒå¤§ï¼Œå¯¹ç³»ç»Ÿæ€§èƒ½çš„å½±å“ä¹Ÿä¸ä¸€æ ·ï¼Œæœ¬äººä¸æ˜¯è¿™æ–¹é¢çš„ä¸“å®¶ï¼Œåç»­æ–‡ç« ä¸­åªä¼šä»åŠŸèƒ½çš„è§’åº¦æ¥ä»‹ç»ä¸åŒçš„subsystemï¼Œä¸ä¼šæ¶‰åŠåˆ°ä»–ä»¬å†…éƒ¨çš„å®ç°ã€‚ å¦‚ä½•ä½¿ç”¨cgroupcgroupç›¸å…³çš„æ‰€æœ‰æ“ä½œéƒ½æ˜¯åŸºäºå†…æ ¸ä¸­çš„cgroup virtual filesystemï¼Œä½¿ç”¨cgroupå¾ˆç®€å•ï¼ŒæŒ‚è½½è¿™ä¸ªæ–‡ä»¶ç³»ç»Ÿå°±å¯ä»¥äº†ã€‚ä¸€èˆ¬æƒ…å†µä¸‹éƒ½æ˜¯æŒ‚è½½åˆ°&#x2F;sys&#x2F;fs&#x2F;cgroupç›®å½•ä¸‹ï¼Œå½“ç„¶æŒ‚è½½åˆ°å…¶å®ƒä»»ä½•ç›®å½•éƒ½æ²¡å…³ç³»ã€‚ è¿™é‡Œå‡è®¾ç›®å½•&#x2F;sys&#x2F;fs&#x2F;cgroupå·²ç»å­˜åœ¨ï¼Œä¸‹é¢ç”¨åˆ°çš„xxxä¸ºä»»æ„å­—ç¬¦ä¸²ï¼Œå–ä¸€ä¸ªæœ‰æ„ä¹‰çš„åå­—å°±å¯ä»¥äº†ï¼Œå½“ç”¨mountå‘½ä»¤æŸ¥çœ‹çš„æ—¶å€™ï¼Œxxxä¼šæ˜¾ç¤ºåœ¨ç¬¬ä¸€åˆ—ã€‚ æŒ‚è½½ä¸€é¢—å’Œæ‰€æœ‰subsystemå…³è”çš„cgroupæ ‘åˆ°&#x2F;sys&#x2F;fs&#x2F;cgroup 1mount -t cgroup xxx /sys/fs/cgroup æŒ‚è½½ä¸€é¢—å’Œcpuset subsystemå…³è”çš„cgroupæ ‘åˆ°&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset 12mkdir /sys/fs/cgroup/cpusetmount -t cgroup -o cpuset æŒ‚è½½ä¸€é¢—ä¸cpuå’Œcpuacct subsystemå…³è”çš„cgroupæ ‘åˆ°&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct 12mkdir /sys/fs/cgroup/cpu,cpuacctmount -t cgroup -o cpu,cpuacct xxx /sys/fs/cgroup/cpu,cpuacct æŒ‚è½½ä¸€æ£µcgroupæ ‘ï¼Œä½†ä¸å…³è”ä»»ä½•subsystemï¼Œä¸‹é¢å°±æ˜¯systemdæ‰€ç”¨åˆ°çš„æ–¹å¼ 12mkdir /sys/fs/cgroup/systemdmount -t cgroup -o none,name=systemd xxx /sys/fs/cgroup/systemd åˆ é™¤ä¸€ä¸ªæŒ‚è½½ 1sudo umount .... åœ¨å¾ˆå¤šä½¿ç”¨systemdçš„ç³»ç»Ÿä¸­ï¼Œæ¯”å¦‚ubuntu 16.04ï¼Œsystemdå·²ç»å¸®æˆ‘ä»¬å°†å„ä¸ªsubsystemå’Œcgroupæ ‘å…³è”å¹¶æŒ‚è½½å¥½äº† è¿è¡Œå‘½ä»¤æŸ¥çœ‹ï¼š 1mount|grep cgroup ä½¿ç”¨cgroupé™åˆ¶ä¸€ä¸ªè¿›ç¨‹çš„CPUä½¿ç”¨ç‡(cgroup v2)é¦–å…ˆå®‰è£…cgroupå·¥å…· 1sudo apt-get install cgroup-tools ç¡®è®¤ç³»ç»Ÿæ­£åœ¨ä½¿ç”¨cgroup v2 1cat /proc/self/cgroup å¦‚æœè¾“å‡ºçš„ç¬¬ä¸€è¡Œä»¥0::å¼€å¤´ï¼Œé‚£ä¹ˆæ‚¨çš„ç³»ç»Ÿæ­£åœ¨ä½¿ç”¨cgroup v2ã€‚ ç°åœ¨ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªåä¸ºmy_cgroupçš„cgroupï¼Œå¹¶é™åˆ¶å…¶CPUä½¿ç”¨ç‡ä¸º50%ã€‚é¦–å…ˆåˆ›å»ºä¸€ä¸ªcgroupç›®å½•ï¼š 1sudo mkdir /sys/fs/cgroup/my_cgroup æ¥ä¸‹æ¥ï¼Œä¸ºè¿™ä¸ªcgroupè®¾ç½®CPUæƒé‡ã€‚cgroup v2ä½¿ç”¨æƒé‡å€¼æ¥è°ƒæ•´CPUä½¿ç”¨ç‡ï¼ŒèŒƒå›´æ˜¯1-10000ã€‚é»˜è®¤å€¼ä¸º100ã€‚è¦å°†CPUä½¿ç”¨ç‡é™åˆ¶ä¸º50%ï¼Œæˆ‘ä»¬å°†æƒé‡è®¾ç½®ä¸º50ï¼š 1echo 50 | sudo tee /sys/fs/cgroup/my_cgroup/cpu.weight ç°åœ¨ï¼Œæˆ‘ä»¬å°†ä¸€ä¸ªè¿›ç¨‹æ·»åŠ åˆ°my_cgroupã€‚ä¾‹å¦‚ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªåä¸ºmy_processçš„è¿›ç¨‹ï¼Œå…¶è¿›ç¨‹IDä¸ºxxxxxã€‚è¦å°†æ­¤è¿›ç¨‹æ·»åŠ åˆ°my_cgroupï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤ï¼š 1echo xxxxx | sudo tee -a /sys/fs/cgroup/my_cgroup/cgroup.procs ç°åœ¨ï¼Œmy_processè¿›ç¨‹çš„CPUä½¿ç”¨ç‡å°†å—åˆ°my_cgroupä¸­çš„é™åˆ¶ã€‚ è¦æŸ¥çœ‹cgroupçš„ä¿¡æ¯ï¼Œå¯ä»¥è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼š 12cat /proc/xxxxx/cgroupcat /sys/fs/cgroup/my_cgroup/cpu.weight è¦åˆ é™¤ä¸€ä¸ªcgroupï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š 1sudo rmdir /sys/fs/cgroup/my_cgroup åœ¨åˆ é™¤cgroupç›®å½•ä¹‹å‰ï¼Œéœ€è¦å°†æ‰€æœ‰è¿›ç¨‹ç§»å‡ºè¿™ä¸ªcgroupã€‚ æŸ¥æ‰¾å±äºcgroupçš„è¿›ç¨‹ã€‚é€šå¸¸ï¼Œè¿›ç¨‹IDå­˜å‚¨åœ¨cgroup.procsæ–‡ä»¶ä¸­ã€‚ 1cat /sys/fs/cgroup/my_cgroup/cgroup.procs å°†è¿›ç¨‹ç§»å‡ºcgroupã€‚æˆ–è€…å°†è¿›ç¨‹ç§»åˆ°å…¶ä»–cgroup 1echo xxxxx | sudo tee /sys/fs/cgroup/cgroup.procs ç¡®è®¤my_cgroupä¸­ä¸å†æœ‰è¿›ç¨‹ã€‚å†æ¬¡æŸ¥çœ‹cgroup.procsæ–‡ä»¶ï¼Œç¡®ä¿å…¶ä¸­æ²¡æœ‰è¿›ç¨‹IDï¼š 1cat /sys/fs/cgroup/my_cgroup/cgroup.procs å†æ¬¡åˆ é™¤cgroup 1sudo rmdir /sys/fs/cgroup/my_cgroup å‚è€ƒèµ„æ–™Linux Cgroup å…¥é—¨æ•™ç¨‹ï¼šåŸºæœ¬æ¦‚å¿µ â€“ äº‘åŸç”Ÿå®éªŒå®¤ - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|äº‘åŸç”Ÿ (icloudnative.io) Linux Cgroupç³»åˆ—ï¼ˆ01ï¼‰ï¼šCgroupæ¦‚è¿° - Linuxç¨‹åºå‘˜ - SegmentFault æ€å¦","categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"cgroup","slug":"cgroup","permalink":"http://example.com/tags/cgroup/"}]},{"title":"C++ å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ æ–‡ä»¶IO","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-æ–‡ä»¶IO","date":"2023-04-26T08:01:56.000Z","updated":"2023-05-14T07:19:51.804Z","comments":true,"path":"2023/04/26/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-æ–‡ä»¶IO/","link":"","permalink":"http://example.com/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/","excerpt":"æ ‡å‡†Cåº“IOå‡½æ•°å’ŒLinuxç³»ç»ŸIOå‡½æ•°å¯¹æ¯”æ ‡å‡†Cåº“IOå‡½æ•°","text":"æ ‡å‡†Cåº“IOå‡½æ•°å’ŒLinuxç³»ç»ŸIOå‡½æ•°å¯¹æ¯”æ ‡å‡†Cåº“IOå‡½æ•° æ ‡å‡†Cåº“IOå‡½æ•°æ˜¯è·¨å¹³å°çš„ï¼Œç¬¬ä¸‰æ–¹åº“ æ ‡å‡†Cåº“å‡½æ•°å’ŒLinuxç³»ç»Ÿå‡½æ•°æ˜¯è°ƒç”¨å’Œè¢«è°ƒç”¨çš„å…³ç³» Linuxå‡½æ•°æ›´åŠ ä½çº§æ›´åº•å±‚ä¸€äº›ï¼Œæ•ˆç‡æ›´é«˜ Cå‡½æ•°æ›´é«˜çº§ä¸€äº› æ ‡å‡†Cåº“IOå‡½æ•°å’ŒLinuxç³»ç»ŸIOçš„å…³ç³» è™šæ‹Ÿåœ°å€ç©ºé—´ æ–‡ä»¶æè¿°ç¬¦ openå‡½æ•°å‘½ä»¤manå¯ä»¥æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯ 12man 2 (Linuxç³»ç»ŸIOå‡½æ•°)man 3 (Cæ ‡å‡†åº“å‡½æ•°) å…·ä½“å‘½ä»¤å¦‚ä¸‹ï¼š 12345678910111213141516171819#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;//1ã€ç¬¬ä¸€ä¸ªopenå‡½æ•°ï¼šæ‰“å¼€ä¸€ä¸ªå·²ç»å­˜åœ¨çš„æ–‡ä»¶int open(const char* pathname, int flags);//ä¸æ˜¯å‡½æ•°é‡è½½ï¼Œæ˜¯é€šè¿‡å¯å˜å‚æ•°å®ç°è¿™ç§æ•ˆæœ//å‚æ•°ï¼š//-pathnameï¼šè¦æ‰“å¼€çš„æ–‡ä»¶è·¯å¾„//- flagsï¼šå¯¹æ–‡ä»¶æ“ä½œæƒé™è®¾ç½®è¿˜æœ‰å…¶ä»–è®¾ç½®(O_RDONLY,O_WRONLY,O_RDWRè¿™ä¸‰ä¸ªè®¾ç½®æ˜¯äº’æ–¥çš„)//è¿”å›å€¼ï¼šè¿”å›ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå¦‚æœè°ƒç”¨å¤±è´¥è¿”å›-1//errnoï¼šå±äºLinuxç³»ç»Ÿå‡½æ•°åº“ï¼Œåº“é‡Œé¢çš„ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œè®°å½•çš„æ˜¯æœ€è¿‘çš„é”™è¯¯å·void perror(const char* s);//å‚æ•°sï¼šç”¨æˆ·æè¿°ï¼Œæ¯”å¦‚helloï¼Œæœ€ç»ˆè¾“å‡ºçš„å†…å®¹æ˜¯ helloï¼šxxx// ä½œç”¨ï¼šæ‰“å°erroroå¯¹åº”çš„é”™è¯¯æè¿°//2ã€ç¬¬äºŒä¸ªopenå‡½æ•°ï¼šåˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶int open(const char* pathname, int flags, mode_t mode); ä¸¾ä¾‹ï¼š 1234567891011121314151617#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; int fd = open(&quot;a.txt&quot;, O_RDONLY); if (fd == -1) &#123; perror(&quot;open&quot;); &#125; //å…³é—­ close(fd); return 0;&#125; è¿è¡Œç»“æœä¸ºï¼š openåˆ›å»ºæ–°æ–‡ä»¶12345678910int open(const char *pathname,int flags,mode_t mode);//å‚æ•°ï¼š//- pathnameï¼šè¦åˆ›å»ºæ–‡ä»¶çš„è·¯å¾„//- flagsï¼šå¯¹æ–‡ä»¶çš„æ“ä½œæƒé™å’Œå…¶ä»–çš„è®¾ç½®// å¿…é€‰é¡¹ï¼š O_RDONLY,O_WRONLY,O_RDWRè¿™ä¸‰ä¸ªä¹‹é—´æ˜¯äº’æ–¥çš„// å¯é€‰é¡¹ï¼šO_CREAT æ–‡ä»¶ä¸å­˜åœ¨åˆ›å»ºæ–°æ–‡ä»¶//- modeï¼šå…«è¿›åˆ¶çš„æ•°ï¼Œè¡¨ç¤ºåˆ›å»ºå‡ºçš„æ–°çš„æ–‡ä»¶çš„æ“ä½œæƒé™ï¼Œæ¯”å¦‚ï¼š0775// æœ€ç»ˆçš„æƒé™æ˜¯ï¼šmode &amp; ~umaskï¼ˆumaskçš„ä½œç”¨æ˜¯æŠ¹å»æŸäº›æƒé™ï¼‰// flagså‚æ•°æ˜¯ä¸€ä¸ªintç±»å‹çš„æ•°æ®ï¼Œå å››ä¸ªå­—èŠ‚ï¼Œ32ä½// flags 32ä½ï¼Œæ¯ä¸€ä½å°±æ˜¯ä¸€ä¸ªæ ‡å¿—ä½ 12345678910111213141516#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; //åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ int fd = open(&quot;create.txt&quot;, O_RDWR | O_CREAT, 0777); if (fd == -1) &#123; perror(&quot;open&quot;); &#125; //å…³é—­æ–‡ä»¶æè¿°ç¬¦ close(fd);&#125; ç¼–è¯‘è¿è¡Œè¿™æ®µä»£ç ä¹‹åï¼Œæˆ‘ä»¬çš„æ–‡ä»¶å¤¹ä¸­ä¼šåˆ›å»ºä¸€ä¸ªcreate.txtæ–‡ä»¶ readã€writeå‡½æ•°12345678910111213141516171819#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t count);//å‚æ•°ï¼š//-fdï¼šæ–‡ä»¶æè¿°ç¬¦ï¼Œopenå¾—åˆ°çš„ï¼Œé€šè¿‡è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦æ“ä½œæŸä¸ªæ–‡ä»¶//- bufï¼šéœ€è¦è¯»å–æ•°æ®å­˜æ”¾çš„åœ°æ–¹ï¼Œæ•°ç»„çš„åœ°å€ï¼ˆä¼ å‡ºå‚æ•°ï¼‰//- countï¼šæŒ‡å®šçš„æ•°ç»„çš„å¤§å°//è¿”å›å€¼//- æˆåŠŸï¼š// - å¤§äº0ï¼šè¿”å›å®é™…è¯»å–åˆ°çš„å­—èŠ‚æ•°// - ç­‰äº0ï¼šæ–‡ä»¶å·²ç»è¯»å–å®Œäº†//- å¤±è´¥ï¼š-1ï¼Œå¹¶ä¸”è®¾ç½®errnossize_t write(int fd,const void *buf,size_t count)//å‚æ•°//- fdï¼šæ–‡ä»¶æè¿°ç¬¦ï¼Œopenå¾—åˆ°çš„ï¼Œé€šè¿‡è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦æ“ä½œæŸä¸ªæ–‡ä»¶//- bufï¼šè¦å¾€ç£ç›˜//- countï¼šè¦å†™å…¥çš„æ•°æ®çš„å®é™…çš„å¤§å°//è¿”å›å€¼//- æˆåŠŸï¼šå®é™…å†™å…¥çš„å­—èŠ‚æ•°//- å¤±è´¥ï¼šè¿”å›-1ï¼Œå¹¶å†™å…¥errno ä¾‹å­ï¼Œcopyfile.cå‡½æ•°æˆ‘ä»¬è¿è¡Œå¦‚ä¸‹å‡½æ•°ï¼Œå°†english.txtå¤åˆ¶ä¸€ä»½ 123456789101112131415161718192021222324252627282930313233343536#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;int main()&#123; //1.é€šè¿‡openæ‰“å¼€english.txtæ–‡ä»¶ int srcfd = open(&quot;english.txt&quot;, O_RDONLY); if (srcfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //2.åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ï¼ˆæ‹·è´æ–‡ä»¶ï¼‰ int destfd = open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664); if (destfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //3.é¢‘ç¹çš„è¯»å†™æ“ä½œ char buf[1024] = &#123; 0 &#125;; int len = 0; while ((len = read(srcfd, buf, sizeof(buf))) &gt; 0) &#123; write(destfd, buf, len); &#125; len = read(srcfd, buf, sizeof(buf)); //4.å…³é—­æ–‡ä»¶ close(destfd); close(srcfd);&#125; lseekå‡½æ•°1234567891011121314151617181920//æ ‡å‡†Cåº“å‡½æ•°#include&lt;stdio.h&gt;int fseek(FILE* stream, long offset, int whence);//Linuxç³»ç»Ÿå‡½æ•°#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);//å‚æ•°//- fdï¼šæ–‡ä»¶æè¿°ç¬¦ï¼Œé€šè¿‡openå¾—åˆ°çš„ï¼Œé€šè¿‡è¿™ä¸ªfdæ“ä½œæŸä¸ªæ–‡ä»¶//- offsetï¼šåç§»é‡//- whenceï¼š// SEEK_SET:è®¾ç½®æ–‡ä»¶æŒ‡é’ˆçš„åç§»é‡// SEEK_CUR:è®¾ç½®åç§»é‡ï¼Œä»å½“å‰ä½ç½®åŠ ä¸Šå½“å‰å‚æ•°offsetçš„å€¼// SEEK_END:è®¾ç½®åç§»é‡ï¼Œæ–‡ä»¶çš„å¤§å°åŠ ç¬¬äºŒä¸ªå‚æ•°offsetçš„å€¼//è¿”å›å€¼ï¼šè¿”å›æ–‡ä»¶æŒ‡é’ˆæ‰€åœ¨çš„ä½ç½®//ä½œç”¨ï¼š//1ã€ç§»åŠ¨æ–‡ä»¶æŒ‡é’ˆåˆ°æ–‡ä»¶å¤´ lseek(fd,0,SEEK_SET);//2ã€è·å–å½“å‰æ–‡ä»¶æŒ‡é’ˆçš„ä½ç½® lseek(fd,0,SEEK_CUR);//3ã€è·å–æ–‡ä»¶é•¿åº¦ lseek(fd,0,SEEK_END);//4ã€æ‹“å±•æ–‡ä»¶é•¿åº¦ï¼Œå½“å‰æ–‡ä»¶10bï¼Œæ‹“å±•åˆ°110b lseek(fd,100,SEEK_END); éœ€è¦å†™ä¸€æ¬¡æ•°æ® ä¾‹å­ï¼šæ‹“å±•hello.txtçš„æ–‡ä»¶é•¿åº¦12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int main()&#123; int fd = open(&quot;hello.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //æ‰©å±•æ–‡ä»¶çš„é•¿åº¦ int ret = lseek(fd, 100, SEEK_END); if (ret == -1) &#123; perror(&quot;lseek&quot;); return -1; &#125; //å†™å…¥ç©ºæ•°æ® write(fd, &quot; &quot;, 1); //å…³é—­æ–‡ä»¶ close(fd);&#125; è¿è¡Œç»“æœä¸ºï¼š statã€lstatå‡½æ•°statç»“æ„ä½“123456789101112131415struct stat&#123; dev_t st_dev;//æ–‡ä»¶çš„è®¾å¤‡ç¼–å· ino_t st_ino;//èŠ‚ç‚¹ mode_t st_mode;//æ–‡ä»¶çš„ç±»å‹å’Œå­˜å–çš„æƒé™ nlink_t st_nlink;//è¿æ¥è¯¥æ–‡ä»¶çš„ç¡¬é“¾æ¥æ•°ç›® uid_t st_uid;//ç”¨æˆ·ID gid_t st_gid;//ç»„ID dev_t st_rev;//è®¾å¤‡æ–‡ä»¶çš„è®¾å¤‡ç¼–å· off_t st_size;//æ–‡ä»¶å­—èŠ‚æ•°ï¼Œæ–‡ä»¶å¤§å° blksize_t st_blksize;//å—å¤§å° blkcnt_t t_blocks;//å—æ•° time_t st_atime;//æœ€åä¸€æ¬¡è®¿é—®æ—¶é—´ time_t st_mtime;//æœ€åä¸€æ¬¡ä¿®æ”¹æ—¶é—´ time_t st_ctime;//æœ€åä¸€æ¬¡æ”¹å˜äº‹ä»¶ï¼Œå±æ€§&#125; st_mode statå‡½æ•°123456789101112#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;int stat(const char* pathname, struct stat* statbuf);//ä½œç”¨ï¼šè·å–ä¸€ä¸ªæ–‡ä»¶ç›¸å…³çš„ä¿¡æ¯//å‚æ•°ï¼š//- pathnameï¼šæ“ä½œæ–‡ä»¶çš„è·¯å¾„//- statbufï¼šç»“æ„ä½“å˜é‡ï¼Œä¼ å‡ºå‚æ•°ï¼Œç”¨äºä¿å­˜è·å–åˆ°çš„æ–‡ä»¶ä¿¡æ¯//è¿”å›å€¼//- æˆåŠŸï¼šè¿”å›0//- å¤±è´¥ï¼šè¿”å›-1ï¼Œè®¾ç½®errnoint lstat(const char* pathname, struct stat* statbuf);//è·å–è½¯è¿æ¥ä¿¡æ¯ ä¾‹å­ï¼šè·å–æ–‡ä»¶a.txtçš„é•¿åº¦12345678910111213141516#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; struct stat statbuf; int ret = stat(&quot;a.txt&quot;, &amp;statbuf); if (ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; printf(&quot;size: %ld\\n&quot;, statbuf.st_size);&#125; è¿è¡Œç»“æœä¸ºï¼š æ¨¡æ‹Ÿå®ç°ls-lå‘½ä»¤ls -lä¼šåˆ—å‡ºå½“å‰æ–‡ä»¶çš„ä¿¡æ¯ æˆ‘ä»¬å®ç°ä¸€ä¸ªls-l.cæ¨¡æ‹Ÿå®ç°ls -lå‘½ä»¤ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;pwd.h&gt;#include&lt;grp.h&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;int main(int argc, char* argv[])&#123; // if (argc &lt; 2) &#123; printf(&quot;%s filename\\n&quot;, argv[0]); return -1; &#125; //é€šè¿‡statå‡½æ•°è·å–ç”¨æˆ·ä¼ å…¥çš„æ–‡ä»¶çš„ä¿¡æ¯ struct stat st; int ret = stat(argv[1], &amp;st); if (ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; //è·å–æ–‡ä»¶ç±»å‹å’Œæ–‡ä»¶æƒé™ char perms[11] = &#123; 0 &#125;;//ç”¨äºä¿å­˜æ–‡ä»¶ç±»å‹å’Œæ–‡ä»¶æƒé™çš„å­—ç¬¦ä¸² switch (st.st_mode&amp;__S_IFMT) &#123; case __S_IFLNK: perms[0] = &#x27;1&#x27;; break; case __S_IFDIR: perms[0] = &#x27;d&#x27;; break; case __S_IFREG: perms[0] = &#x27;-&#x27;; break; case __S_IFBLK: perms[0] = &#x27;b&#x27;; break; case __S_IFCHR: perms[0] = &#x27;c&#x27;; break; case __S_IFSOCK: perms[0] = &#x27;s&#x27;; break; case __S_IFIFO: perms[0] = &#x27;p&#x27;; break; default: perms[0] = &#x27;?&#x27;; break; &#125; //åˆ¤æ–­æ–‡ä»¶çš„è®¿é—®æƒé™ //æ–‡ä»¶æ‰€æœ‰è€… perms[1] = (st.st_mode &amp; S_IRUSR) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[2] = (st.st_mode &amp; S_IWUSR) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[3] = (st.st_mode &amp; S_IXUSR) ? &#x27;x&#x27; : &#x27;-&#x27;; //æ–‡ä»¶æ‰€åœ¨ç»„ perms[4] = (st.st_mode &amp; S_IRGRP) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[5] = (st.st_mode &amp; S_IWGRP) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[6] = (st.st_mode &amp; S_IXGRP) ? &#x27;x&#x27; : &#x27;-&#x27;; //å…¶ä»–äºº perms[7] = (st.st_mode &amp; S_IROTH) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[8] = (st.st_mode &amp; S_IWOTH) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[9] = (st.st_mode &amp; S_IXOTH) ? &#x27;x&#x27; : &#x27;-&#x27;; //ç¡¬é“¾æ¥æ•° int LinkNum = st.st_nlink; //æ–‡ä»¶æ‰€æœ‰è€… char* fileuser = getpwuid(st.st_uid)-&gt;pw_name; //æ–‡ä»¶æ‰€åœ¨ç»„ char* filegrp = getgrgid(st.st_gid)-&gt;gr_name; //æ–‡ä»¶å¤§å° long int filesize = st.st_size; //è·å–ä¿®æ”¹çš„æ—¶é—´ char* time = ctime(&amp;st.st_mtime); char mtime[512] = &#123; 0 &#125;; strncpy(mtime, time, strlen(time) - 1); char buf[1024]; sprintf(buf, &quot;%s %d %s %s %ld %s %s&quot;, perms, LinkNum, fileuser, filegrp, filesize, mtime, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125;Num, fileuser, filegrp, filesize, time, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š æ–‡ä»¶å±æ€§æ“ä½œå‡½æ•°accesså‡½æ•°1234567#include&lt;unistd.h&gt;int access(const char* pathname, int mode);//ä½œç”¨ï¼šåˆ¤æ–­æŸä¸ªæ–‡ä»¶æ˜¯å¦æœ‰æŸä¸ªæƒé™ï¼Œæˆ–è€…åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨//å‚æ•°//- pathnameï¼šåˆ¤æ–­æ–‡ä»¶è·¯å¾„//- modeï¼šR_OKæ˜¯å¦æœ‰è¯»æƒé™ï¼ŒW_OKæ˜¯å¦æœ‰å†™æƒé™ï¼ŒX_OKæ˜¯å¦æœ‰æ‰§è¡Œæƒé™ï¼ŒF_OKåˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨//è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 ä¾‹å­ï¼šåˆ¤æ–­æ–‡ä»¶æƒé™123456789101112#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = access(&quot;a.txt&quot;, F_OK); if (ret == -1) &#123; perror(&quot;access&quot;); &#125; printf(&quot;æ–‡ä»¶å­˜åœ¨\\n&quot;);&#125; è¿è¡Œç»“æœä¸ºï¼š chmodå‡½æ•°1234567#include&lt;sys/stat.h&gt;int chmod(const char* pathname, mode_t mode);//ä¿®æ”¹æ–‡ä»¶çš„æƒé™//å‚æ•°//- pathnameï¼šéœ€è¦ä¿®æ”¹çš„æ–‡ä»¶çš„è·¯å¾„//- modeï¼šéœ€è¦ä¿®æ”¹çš„æƒé™å€¼ï¼Œå…«è¿›åˆ¶æ•°//è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 ä¾‹å­ï¼šä¿®æ”¹æ–‡ä»¶æƒé™123456789101112#include&lt;sys/stat.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = chmod(&quot;a.txt&quot;, 0775); if (ret == -1) &#123; perror(&quot;chmod&quot;); return -1; &#125; return 0;&#125; chownå‡½æ•°1int chown(const char *pathname, uid_t owner, gid_t group); truncateå‡½æ•°12345678#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;int truncate(const char* path, off_t length);//ä½œç”¨ï¼šç¼©å‡æˆ–æ‰©å±•æ–‡ä»¶çš„å°ºå¯¸è‡³æŒ‡å®šçš„å¤§å°//å‚æ•°ï¼š//- pathï¼šéœ€è¦ä¿®æ”¹çš„æ–‡ä»¶è·¯å¾„//- lengthï¼šéœ€è¦æœ€ç»ˆæ–‡ä»¶å˜æˆçš„å¤§å°//è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼Œå¤±è´¥è¿”å›-1 ä¾‹å­12345678910111213#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = truncate(&quot;a.txt&quot;, 20); if (ret == -1) &#123; perror(&quot;truncate&quot;); return -1; &#125; return 0;&#125; ç›®å½•æ“ä½œå‡½æ•°mkdirå‡½æ•°12345678#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;int mkdir(const char* pathname, mode_t mode);//ä½œç”¨ï¼šåˆ›å»ºä¸€ä¸ªç›®å½•//å‚æ•°//- pathnameï¼šåˆ›å»ºçš„ç›®å½•çš„è·¯å¾„//- modeï¼šæƒé™ï¼Œå…«è¿›åˆ¶çš„æ•°//è¿”å›å€¼ï¼šå¤±è´¥è¿”å›-1ï¼ŒæˆåŠŸè¿”å›0 ä¾‹å­ï¼šåˆ›å»ºä¸€ä¸ªåä¸ºaaaçš„ç›®å½• 12345678910111213#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = mkdir(&quot;aaa&quot;, 0777); if (ret == -1) &#123; perror(&quot;mkdir&quot;); return -1; &#125; return 0;&#125; rmdirå‡½æ•°1int rmdir(const char* pathname); renameå‡½æ•°1int rename(const char* oldpath,const char* newpath); ä¾‹å­ï¼šä¿®æ”¹ç›®å½•aaaä¸ºbbb 1234567891011#include&lt;stdio.h&gt;int main()&#123; int ret = rename(&quot;aaa&quot;, &quot;bbb&quot;); if (ret == -1) &#123; perror(&quot;rename&quot;); return -1; &#125; return 0;&#125; chdirå‡½æ•°ï¼Œgetcwdå‡½æ•°1234567891011#include&lt;unistd.h&gt;int chdir(const char* path);//ä½œç”¨ï¼šä¿®æ”¹è¿›ç¨‹çš„å·¥ä½œç›®å½•//å‚æ•°ï¼š//- pathï¼šéœ€è¦ä¿®æ”¹çš„å·¥ä½œç›®å½•char* getcwd(char* buf, size_t size);//ä½œç”¨ï¼šè·å–å½“å‰å·¥ä½œç›®å½•//å‚æ•°ï¼š//- bufï¼šå­˜å‚¨çš„è·¯å¾„ï¼ŒæŒ‡å‘çš„æ˜¯ä¸€ä¸ªæ•°ç»„//- sizeï¼šæ•°ç»„çš„å¤§å°//è¿”å›å€¼ï¼šè¿”å›æŒ‡å‘çš„ä¸€å—å†…å­˜ï¼Œè¿™ä¸ªæ•°æ®å°±æ˜¯ç¬¬ä¸€ä¸ªå‚æ•° ä¾‹å­ï¼šä¿®æ”¹å½“å‰å·¥ä½œç›®å½• 12345678910111213141516171819202122232425262728293031323334#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //è·å–å½“å‰çš„å·¥ä½œç›®å½• char buf[128]; getcwd(buf, sizeof(buf)); printf(&quot;å½“å‰çš„å·¥ä½œç›®å½•æ˜¯ï¼š%s\\n&quot;, buf); //ä¿®æ”¹å·¥ä½œç›®å½• int ret = chdir(&quot;/home/plucky/Linux/lecture14/bbb&quot;); if (ret == -1) &#123; perror(&quot;chdir&quot;); return -1; &#125; //åˆ›å»ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ int fd = open(&quot;chdir.txt&quot;, O_CREAT | O_RDWR, 0664); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; close(fd); //è·å–å½“å‰çš„å·¥ä½œç›®å½• char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(&quot;å½“å‰çš„å·¥ä½œç›®å½•æ˜¯ï¼š%s\\n&quot;, buf1); return 0;&#125; ç›®å½•éå†å‡½æ•°1234567891011121314#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;DIR* opendir(const char* name);//åŠŸèƒ½ï¼šæ‰“å¼€ä¸€ä¸ªç›®å½•//å‚æ•°ï¼š//- nameï¼šéœ€è¦æ‰“å¼€çš„ç›®å½•çš„åç§°//è¿”å›å€¼ï¼šDIR* ç±»å‹ï¼Œç†è§£ä¸ºç›®å½•æµï¼Œé”™è¯¯è¿”å›NULLstruct dirent* readdir(DIR* dirp);//åŠŸèƒ½ï¼šè¯»å–ç›®å½•ä¸­çš„æ•°æ®//å‚æ•°ï¼š//- dirpï¼šopendirè¿”å›çš„ç»“æœ//è¿”å›å€¼ï¼šstruct dirent*ï¼Œä»£è¡¨è¯»å–åˆ°çš„æ–‡ä»¶çš„ä¿¡æ¯ã€‚è¯»å–åˆ°äº†æ–‡ä»¶æœ«å°¾æˆ–è€…å¤±è´¥äº†è¿”å›NULLint closedir(DIR* dirp);//åŠŸèƒ½ï¼šå…³é—­ç›®å½• ä¾‹å­ï¼šè®¡ç®—æ–‡ä»¶å¤¹ä¸­æ™®é€šæ–‡ä»¶çš„ä¸ªæ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int getFileNum(const char* path);//è¯»å–æŸä¸ªç›®å½•ä¸‹æ‰€æœ‰æ™®é€šæ–‡ä»¶çš„ä¸ªæ•°int main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; printf(&quot;%s path\\n&quot;, argv[0]); return -1; &#125; int num = getFileNum(argv[1]); printf(&quot;æ™®é€šæ–‡ä»¶çš„ä¸ªæ•°ä¸ºï¼š%d\\n&quot;, num); return 0;&#125;//ç”¨äºè¯»å–ç›®å½•ä¸‹æ‰€æœ‰æ™®é€šæ–‡ä»¶çš„ä¸ªæ•°int getFileNum(const char* path)&#123; //1ã€æ‰“å¼€ç›®å½• DIR* dir = opendir(path); if (dir == NULL) &#123; perror(&quot;opendir&quot;); exit(0); &#125; //è®°å½•æ™®é€šæ–‡ä»¶çš„ä¸ªæ•° int total = 0; struct dirent* ptr; while ((ptr = readdir(dir)) != NULL) &#123; //è·å–åç§° char* dname = ptr-&gt;d_name; //å¿½ç•¥æ‰. å’Œ.. if (strcmp(dname, &quot;.&quot;) == 0 || strcmp(dname, &quot;..&quot;) == 0) &#123; continue; &#125; //åˆ¤æ–­æ˜¯å¦æ˜¯æ™®é€šæ–‡ä»¶è¿˜æ˜¯ç›®å½• if (ptr-&gt;d_type == DT_DIR) &#123; //ç›®å½•ï¼Œéœ€è¦ç»§ç»­è¯»å–è¿™ä¸ªç›®å½• char newpath[256]; sprintf(newpath, &quot;%s/%s&quot;, path, dname); total += getFileNum(newpath); &#125; if (ptr-&gt;d_type == DT_REG) &#123; //æ™®é€šæ–‡ä»¶ total++; &#125; &#125; //å…³é—­ç›®å½• closedir(dir); return total;&#125; è¿è¡Œç»“æœä¸ºï¼š dupã€dup2å‡½æ•°dupå‡½æ•°12345#include&lt;unistd.h&gt;int dup(int oldfd);//ä½œç”¨ï¼šå¤åˆ¶ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦//fd=3ï¼Œint fd1=dupï¼ˆfdï¼‰ï¼Œä¸¤ä¸ªæ–‡ä»¶æè¿°ç¬¦æŒ‡å‘åŒä¸€ä¸ªæ–‡ä»¶//ä»ç©ºé—²çš„æ–‡ä»¶æè¿°ç¬¦ä¸­æ‰¾ä¸€ä¸ªæœ€å°çš„ï¼Œä½œä¸ºæ–°çš„æ‹·è´çš„æ–‡ä»¶æè¿°ç¬¦ ä¾‹å­ï¼šåˆ›å»ºæ–‡ä»¶a.txtå¹¶ä¸”ç”¨dupå¤åˆ¶çš„æ–‡ä»¶æè¿°ç¬¦ä¿®æ”¹a.txt 123456789101112131415161718192021222324252627#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;string.h&gt;int main()&#123; int fd = open(&quot;a.txt&quot;, O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if (fd1 == -1) &#123; perror(&quot;dup&quot;); return -1; &#125; printf(&quot;fd : %d , fd1 : %d\\n&quot;, fd, fd1); close(fd); char* str = &quot;hello,world&quot;; int ret = write(fd1, str, strlen(str)); if (ret == -1) &#123; perror(&quot;write&quot;); return -1; &#125; close(fd1); return 0;&#125; dup2å‡½æ•°1234567#include&lt;unistd.h&gt;int dup2(int oldfd, int newfd);//ä½œç”¨ï¼šé‡å®šå‘æ–‡ä»¶æè¿°ç¬¦//oldfdæŒ‡å‘a.txt,newfdæŒ‡å‘b.txt//è°ƒç”¨å‡½æ•°æˆåŠŸåï¼šnewfdå’Œb.txtåšcloseï¼ŒnewfdæŒ‡å‘äº†a.txt//oldfdå¿…é¡»æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ–‡ä»¶æè¿°ç¬¦//oldfdå’Œnewfdå€¼ç›¸åŒç›¸å½“äºä»€ä¹ˆéƒ½æ²¡æœ‰åš ä¾‹å­ï¼š 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd = open(&quot;1.txt&quot;, O_RDWR | O_CREAT, 0664); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; int fd1 = open(&quot;2.txt&quot;, O_RDWR | O_CREAT, 0664); if (fd1 == -1) &#123; perror(&quot;open&quot;); return -1; &#125; printf(&quot;fd: %d,fd1: fd1: %d\\n&quot;, fd, fd1); int fd2 = dup2(fd, fd1); if (fd2 == -1) &#123; perror(&quot;dup2&quot;); return -1; &#125; //é€šè¿‡fd1å»å†™æ•°æ®ï¼Œå®é™…æ“ä½œçš„æ˜¯1.txtï¼Œè€Œä¸æ˜¯2.txt char* str = &quot;Hello,dup2&quot;; int len = write(fd1, str, strlen(str)); if (len == -1) &#123; perror(&quot;write&quot;); return -1; &#125; printf(&quot;fd: %d,fd1: %d,fd2: %d\\n&quot;, fd, fd1, fd2);&#125; fcntlå‡½æ•°123456789101112131415161718#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /*argv*/);//å‚æ•°//- fdï¼šè¡¨ç¤ºéœ€è¦æ“ä½œçš„æ–‡ä»¶æè¿°ç¬¦//- cmdï¼šè¡¨ç¤ºå¯¹æ–‡ä»¶æè¿°ç¬¦è¿›è¡Œå¦‚ä½•æ“ä½œ// F_DUPFDå¤åˆ¶æ–‡ä»¶æè¿°ç¬¦ï¼Œå¤åˆ¶çš„æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°fdï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦// int ret = fcntl(fd,F_DUPFD);//// F_GETFLè·å–æŒ‡å®šçš„æ–‡ä»¶æè¿°ç¬¦æ–‡ä»¶çŠ¶æ€flag// è·å–çš„flagå’Œæˆ‘ä»¬é€šè¿‡openå‡½æ•°ä¼ é€’çš„flagæ˜¯ä¸€ä¸ªä¸œè¥¿//// F_SETFLï¼šè®¾ç½®æ–‡ä»¶æè¿°ç¬¦æ–‡ä»¶çŠ¶æ€flag// å¿…é€‰é¡¹ï¼šO_RDONLY,O_WRONLY,O_RDWRä¸å¯ä»¥è¢«ä¿®æ”¹// å¯é€‰é¡¹ï¼šO_APPEND,NONBLOCK// O_APPENDè¡¨ç¤ºè¿½åŠ æ•°æ®// NONBLOCKè®¾ç½®æˆéé˜»å¡// é˜»å¡å’Œéé˜»å¡ï¼šæè¿°çš„æ˜¯å‡½æ•°è°ƒç”¨çš„è¡Œä¸ºã€‚ ä¾‹å­ï¼š 12345678910111213141516171819202122232425262728#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; // å¤åˆ¶æ–‡ä»¶æè¿°ç¬¦ // int fd = open(&quot;1.txt&quot;, O_RDONLY); // int ret = fcntl(fd, F_DUPFD); //ä¿®æ”¹æˆ–è€…è·å–æ–‡ä»¶çŠ¶æ€flag int fd = open(&quot;1.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //è·å–æ–‡ä»¶æè¿°ç¬¦çš„çŠ¶æ€flag int flag = fcntl(fd, F_GETFL); flag |= O_APPEND; //ä¿®æ”¹æ–‡ä»¶æè¿°ç¬¦çŠ¶æ€çš„flagï¼Œç»™flagåŠ å…¥O_APPENDæ ‡è®° int ret = fcntl(fd, F_SETFL, flag); char* str = &quot;hi&quot;; write(fd, str, strlen(str)); close(fd);&#125;","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++ å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ GDBè°ƒè¯•","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-GDBè°ƒè¯•","date":"2023-04-25T00:02:33.000Z","updated":"2023-05-14T07:16:09.632Z","comments":true,"path":"2023/04/25/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-GDBè°ƒè¯•/","link":"","permalink":"http://example.com/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/","excerpt":"ä»€ä¹ˆæ˜¯GDBGDBæ˜¯ç”±GUNè½¯ä»¶ç³»ç»Ÿç¤¾åŒºæä¾›çš„è°ƒè¯•å·¥å…·ï¼ŒåŒGCCé…å¥—ç»„æˆäº†ä¸€å¥—å®Œæ•´çš„å¼€å‘ç¯å¢ƒï¼ŒGDBæ˜¯Linuxå’Œè®¸å¤šç±»Unixç³»ç»Ÿä¸­çš„æ ‡å‡†å¼€å‘ç¯å¢ƒ ä¸€èˆ¬æ¥è¯´ï¼ŒGDBä¸»è¦å¸®åŠ©ä½ å®Œæˆä¸‹é¢å››ä¸ªæ–¹é¢çš„åŠŸèƒ½ï¼š","text":"ä»€ä¹ˆæ˜¯GDBGDBæ˜¯ç”±GUNè½¯ä»¶ç³»ç»Ÿç¤¾åŒºæä¾›çš„è°ƒè¯•å·¥å…·ï¼ŒåŒGCCé…å¥—ç»„æˆäº†ä¸€å¥—å®Œæ•´çš„å¼€å‘ç¯å¢ƒï¼ŒGDBæ˜¯Linuxå’Œè®¸å¤šç±»Unixç³»ç»Ÿä¸­çš„æ ‡å‡†å¼€å‘ç¯å¢ƒ ä¸€èˆ¬æ¥è¯´ï¼ŒGDBä¸»è¦å¸®åŠ©ä½ å®Œæˆä¸‹é¢å››ä¸ªæ–¹é¢çš„åŠŸèƒ½ï¼š 1ã€å¯åŠ¨ç¨‹åºï¼Œå¯ä»¥æŒ‰ç…§è‡ªå®šä¹‰çš„è¦æ±‚éšå¿ƒæ‰€æ¬²çš„è¿è¡Œç¨‹åº 2ã€å¯è®©è¢«è°ƒè¯•çš„ç¨‹åºåœ¨æ‰€æŒ‡å®šçš„è°ƒç½®çš„æ–­ç‚¹å¤„åœä½ï¼ˆæ–­ç‚¹å¯ä»¥æ˜¯æ¡ä»¶è¡¨è¾¾å¼ï¼‰ 3ã€å½“ç¨‹åºè¢«åœä½æ—¶ï¼Œå¯ä»¥æ£€æŸ¥æ­¤æ—¶ç¨‹åºä¸­æ‰€å‘ç”Ÿçš„äº‹ 4ã€å¯ä»¥æ”¹å˜ç¨‹åºï¼Œå°†ä¸€ä¸ªBUGäº§ç”Ÿçš„å½±å“ä¿®æ­£ä»è€Œæµ‹è¯•å…¶ä»–çš„BUG å‡†å¤‡å·¥ä½œé€šå¸¸åœ¨ä¸ºè°ƒè¯•è€Œç¼–è¯‘æ—¶ï¼Œæˆ‘ä»¬ä¼šå…³æ‰ç¼–è¯‘å™¨çš„ä¼˜åŒ–é€‰é¡¹ï¼ˆ-oï¼‰ï¼Œå¹¶æ‰“å¼€è°ƒè¯•é€‰é¡¹ï¼ˆ-gï¼‰ã€‚å¦å¤–ï¼Œ-Wallåœ¨å°½é‡ä¸å½±å“ç¨‹åºçš„æƒ…å†µä¸‹é€‰é¡¹æ‰“å¼€æ‰€æœ‰warningï¼Œä¹Ÿå¯ä»¥å‘ç°è®¸å¤šé—®é¢˜ï¼Œé¿å…ä¸€äº›ä¸å¿…è¦çš„BUGã€‚ 1gcc -g -Wall program.c -o program -gé€‰é¡¹çš„ä½œç”¨æ˜¯åœ¨å¯æ‰§è¡Œæ–‡ä»¶ä¸­åŠ å…¥æºä»£ç çš„ä¿¡æ¯ï¼Œæ¯”å¦‚å¯æ‰§è¡Œæ–‡ä»¶ä¸­ç¬¬å‡ æ¡æœºå™¨æŒ‡ä»¤å¯¹åº”æºä»£ç çš„ç¬¬å‡ è¡Œï¼Œä½†å¹¶ä¸æ˜¯æŠŠæ•´ä¸ªæºæ–‡ä»¶åµŒå…¥åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼Œæ‰€ä»¥åœ¨è°ƒè¯•æ—¶å¿…é¡»ä¿è¯gdbèƒ½æ‰¾åˆ°æºæ–‡ä»¶ã€‚ GDBå‘½ä»¤ 1gcc test.c -o test -g ä¹‹åè¿è¡Œå¦‚ä¸‹å‘½ä»¤ 1gdb test å‘½ä»¤ å¯åŠ¨å’Œé€€å‡º 1gdb 1quit ç»™ç¨‹åºè®¾ç½®å‚æ•°&#x2F;è·å–è®¾ç½®å‚æ•° 1set args 10 20 1show args GDBä½¿ç”¨å¸®åŠ© 1help æŸ¥çœ‹å½“å‰æ–‡ä»¶ä»£ç  ä»é»˜è®¤ä½ç½®æ˜¾ç¤º ä»æŒ‡å®šçš„è¡Œæ˜¾ç¤º ä»æŒ‡å®šå‡½æ•°æ˜¾ç¤º 123list/llist/l è¡Œå·list/l å‡½æ•°å æŸ¥çœ‹éå½“å‰æ–‡ä»¶ä»£ç  12list/l æ–‡ä»¶åï¼šè¡Œå·list/l æ–‡ä»¶åï¼šå‡½æ•°å è®¾ç½®æ˜¾ç¤ºçš„è¡Œæ•° 12show list/listsizeset list/listsize è¡Œæ•° è®¾ç½®æ–­ç‚¹ 1234b/break è¡Œå·b/break å‡½æ•°åb/break æ–‡ä»¶åï¼šè¡Œå·b/break æ–‡ä»¶åï¼šå‡½æ•° æŸ¥çœ‹æ–­ç‚¹ 1info/i break/b åˆ é™¤æ–­ç‚¹ 1d/del/delte æ–­ç‚¹ç¼–å· è®¾ç½®æ–­ç‚¹æ— æ•ˆ 1dis/disable æ–­ç‚¹ç¼–å· è®¾ç½®æ–­ç‚¹ç”Ÿæ•ˆ 1ena/enable æ–­ç‚¹ç¼–å· è®¾ç½®æ–­ç‚¹æ¡ä»¶ï¼ˆä¸€èˆ¬ç”¨åœ¨å¾ªç¯çš„ä½ç½®ï¼‰ 1b/break 10 if i==5 GDBå‘½ä»¤-è°ƒè¯•å‘½ä»¤ è¿è¡ŒGDBç¨‹åº 12start(ç¨‹åºåœåœ¨ç¬¬ä¸€è¡Œ)run(é‡åˆ°æ–­ç‚¹æ‰åœ) ç»§ç»­è¿è¡Œï¼Œåˆ°ä¸‹ä¸€ä¸ªæ–­ç‚¹åœ 1c/continue å‘ä¸‹æ‰§è¡Œä¸€è¡Œä»£ç  1n/next å˜é‡æ“ä½œ 12p/print å˜é‡å(æ‰“å°å˜é‡å€¼)ptype å˜é‡å(æ‰“å°å˜é‡ç±»å‹) å‘ä¸‹å•æ­¥è°ƒè¯•ï¼ˆé‡åˆ°å‡½æ•°è¿›å…¥å‡½æ•°ä½“ï¼‰ 12s/stepfinish(è·³å‡ºå‡½æ•°ä½“) è‡ªåŠ¨å˜é‡æ“ä½œ 123display num(è‡ªåŠ¨æ‰“å°æŒ‡å®šå˜é‡çš„å€¼)i/info displayundisplay ç¼–å· å…¶ä»–æ“ä½œ 12set var å˜é‡å = å˜é‡å€¼until (è·³å‡ºå¾ªç¯) nextå’Œstepçš„åŒºåˆ« nextæ˜¯ä¸€æ­¥æ­¥å¾€ä¸‹è¿è¡Œä»£ç ï¼Œä¸ä¼šè¿›å…¥å‡½æ•°ä½“ä¸­ä¸­ è‡ªåŠ¨è®¾ç½®å˜é‡ä¾‹å­","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"C++ å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ Makefile","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-Makefile","date":"2023-04-24T05:30:29.000Z","updated":"2023-05-14T07:19:20.386Z","comments":true,"path":"2023/04/24/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-Makefile/","link":"","permalink":"http://example.com/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/","excerpt":"ä»€ä¹ˆæ˜¯Makefileä¸€ä¸ªå·¥ç¨‹ä¸­æºæ–‡ä»¶ä¸è®¡å…¶æ•°ï¼Œå…¶æŒ‰ç±»å‹ã€åŠŸèƒ½ã€æ¨¡å—åˆ†åˆ«æ”¾åœ¨è‹¥å¹²ä¸ªç›®å½•ä¸­ï¼ŒMakefileæ–‡ä»¶å®šä¹‰äº†ä¸€ç³»åˆ—çš„è§„åˆ™æ¥æŒ‡å®šå“ªäº›æ–‡ä»¶éœ€è¦å…ˆç¼–è¯‘ï¼Œå“ªäº›æ–‡ä»¶éœ€è¦åç¼–è¯‘ï¼Œå“ªäº›æ–‡ä»¶éœ€è¦é‡æ–°ç¼–è¯‘ï¼Œç”šè‡³äºè¿›è¡Œæ›´å¤æ‚çš„åŠŸèƒ½æ“ä½œï¼Œå› ä¸ºMakefileæ–‡ä»¶å°±åƒä¸€ä¸ªShellè„šæœ¬ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥æ‰§è¡Œæ“ä½œç³»ç»Ÿçš„å‘½ä»¤ã€‚ Makefileå¸¦æ¥çš„å¥½å¤„å°±æ˜¯â€œè‡ªåŠ¨åŒ–ç¼–è¯‘â€ï¼Œä¸€æ—¦å†™å¥½ï¼Œåªéœ€è¦ä¸€ä¸ªmakeå‘½ä»¤ï¼Œæ•´ä¸ªå·¥ç¨‹å®Œå…¨è‡ªåŠ¨ç¼–è¯‘ï¼Œæå¤§çš„æé«˜äº†è½¯ä»¶å¼€å‘æ•ˆç‡ã€‚makeæ˜¯ä¸€ä¸ªå‘½ä»¤å·¥å…·ï¼Œæ˜¯ä¸€ä¸ªå·¥ç¨‹å®Œå…¨ç¼–è¯‘ï¼Œæå¤§çš„æé«˜äº†è½¯ä»¶å¼€å‘çš„æ•ˆç‡ã€‚makeæ˜¯ä¸€ä¸ªå‘½ä»¤å·¥å…·ï¼Œæ˜¯ä¸€ä¸ªè§£é‡ŠMakefileæ–‡ä»¶ä¸­æŒ‡ä»¤çš„å‘½ä»¤å·¥å…·ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œå¤§å¤šæ•°çš„IDEéƒ½æœ‰è¿™ä¸ªå‘½ä»¤ï¼Œæ¯”å¦‚Delphiçš„makeï¼ŒVisual C++çš„makeï¼ŒLinuxä¸‹GUNçš„make","text":"ä»€ä¹ˆæ˜¯Makefileä¸€ä¸ªå·¥ç¨‹ä¸­æºæ–‡ä»¶ä¸è®¡å…¶æ•°ï¼Œå…¶æŒ‰ç±»å‹ã€åŠŸèƒ½ã€æ¨¡å—åˆ†åˆ«æ”¾åœ¨è‹¥å¹²ä¸ªç›®å½•ä¸­ï¼ŒMakefileæ–‡ä»¶å®šä¹‰äº†ä¸€ç³»åˆ—çš„è§„åˆ™æ¥æŒ‡å®šå“ªäº›æ–‡ä»¶éœ€è¦å…ˆç¼–è¯‘ï¼Œå“ªäº›æ–‡ä»¶éœ€è¦åç¼–è¯‘ï¼Œå“ªäº›æ–‡ä»¶éœ€è¦é‡æ–°ç¼–è¯‘ï¼Œç”šè‡³äºè¿›è¡Œæ›´å¤æ‚çš„åŠŸèƒ½æ“ä½œï¼Œå› ä¸ºMakefileæ–‡ä»¶å°±åƒä¸€ä¸ªShellè„šæœ¬ä¸€æ ·ï¼Œä¹Ÿå¯ä»¥æ‰§è¡Œæ“ä½œç³»ç»Ÿçš„å‘½ä»¤ã€‚ Makefileå¸¦æ¥çš„å¥½å¤„å°±æ˜¯â€œè‡ªåŠ¨åŒ–ç¼–è¯‘â€ï¼Œä¸€æ—¦å†™å¥½ï¼Œåªéœ€è¦ä¸€ä¸ªmakeå‘½ä»¤ï¼Œæ•´ä¸ªå·¥ç¨‹å®Œå…¨è‡ªåŠ¨ç¼–è¯‘ï¼Œæå¤§çš„æé«˜äº†è½¯ä»¶å¼€å‘æ•ˆç‡ã€‚makeæ˜¯ä¸€ä¸ªå‘½ä»¤å·¥å…·ï¼Œæ˜¯ä¸€ä¸ªå·¥ç¨‹å®Œå…¨ç¼–è¯‘ï¼Œæå¤§çš„æé«˜äº†è½¯ä»¶å¼€å‘çš„æ•ˆç‡ã€‚makeæ˜¯ä¸€ä¸ªå‘½ä»¤å·¥å…·ï¼Œæ˜¯ä¸€ä¸ªè§£é‡ŠMakefileæ–‡ä»¶ä¸­æŒ‡ä»¤çš„å‘½ä»¤å·¥å…·ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œå¤§å¤šæ•°çš„IDEéƒ½æœ‰è¿™ä¸ªå‘½ä»¤ï¼Œæ¯”å¦‚Delphiçš„makeï¼ŒVisual C++çš„makeï¼ŒLinuxä¸‹GUNçš„make Makefileæ–‡ä»¶å‘½åå’Œè§„åˆ™ æ–‡ä»¶å‘½å makefileæˆ–è€…Makefile Makefileè§„åˆ™ ä¸€ä¸ªMakefileæ–‡ä»¶ä¸­å¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªè§„åˆ™ ç›®æ ‡ â€¦: ä¾èµ– â€¦ å‘½ä»¤ï¼ˆshellå‘½ä»¤ï¼‰ â€¦ ç›®æ ‡ï¼šæœ€ç»ˆè¦ç”Ÿæˆçš„æ–‡ä»¶ï¼ˆä¼ªç›®æ ‡é™¤å¤–ï¼‰ ä¾èµ–ï¼šç”Ÿæˆç›®æ ‡æ–‡ä»¶æ‰€éœ€è¦çš„æ–‡ä»¶æˆ–æ˜¯ç›®æ ‡ å‘½ä»¤ï¼šé€šè¿‡æ‰§è¡Œå‘½ä»¤å¯¹ä¾èµ–æ“ä½œç”Ÿæˆç›®æ ‡ï¼ˆå‘½ä»¤å‰å¿…é¡»Tabç¼©è¿›ï¼‰ ä¾‹å­æˆ‘ä»¬ç°åœ¨æœ‰æ–‡ä»¶ï¼š ç¼–è¾‘Makefileæ–‡ä»¶ 12app:sub.c add.c mult.c div.c main.c gcc sub.c add.c mult.c div.c main.c -o app è¿è¡Œç»“æœå¦‚ä¸‹ï¼š Makefileçš„å·¥ä½œåŸç† å‘½ä»¤åœ¨æ‰§è¡Œä¹‹å‰ï¼Œéœ€è¦å…ˆæ£€æŸ¥è§„åˆ™ä¸­çš„ä¾èµ–æ˜¯å¦å­˜åœ¨ å¦‚æœå­˜åœ¨ï¼Œæ‰§è¡Œå‘½ä»¤ å¦‚æœä¸å­˜åœ¨ï¼Œå‘ä¸‹æ£€æŸ¥å…¶å®ƒçš„è§„åˆ™ï¼Œæ£€æŸ¥æœ‰æ²¡æœ‰ä¸€ä¸ªè§„åˆ™æ˜¯ç”¨æ¥ç”Ÿæˆè¿™ä¸ªä¾èµ–çš„ï¼Œå¦‚æœæ‰¾åˆ°äº†ï¼Œåˆ™æ‰§è¡Œè¯¥è§„åˆ™ä¸­çš„å‘½ä»¤ æ£€æµ‹æ›´æ–°ï¼Œåœ¨æ‰§è¡Œè§„åˆ™ä¸­çš„å‘½ä»¤æ—¶ï¼Œä¼šæ¯”è¾ƒç›®æ ‡å’Œä¾èµ–æ–‡ä»¶çš„æ—¶é—´ å¦‚æœä¾èµ–çš„æ—¶é—´æ¯”ç›®æ ‡çš„æ—¶é—´æ™šï¼Œéœ€è¦é‡æ–°ç”Ÿæˆç›®æ ‡ å¦‚æœä¾èµ–çš„æ—¶é—´æ¯”ç›®æ ‡çš„æ—¶é—´æ—©ï¼Œç›®æ ‡ä¸éœ€è¦æ›´æ–°ï¼Œå¯¹åº”è§„åˆ™ä¸­çš„å‘½ä»¤ä¸éœ€è¦è¢«æ‰§è¡Œ æˆ‘ä»¬ä¿®æ”¹Makefileæ–‡ä»¶å†…å®¹ä¸ºï¼š 1234567891011121314app:sub.o add.o mult.o div.o main.o gcc sub.o add.o mult.o div.o main.o -o appsub.o:sub.c gcc -c sub.c -o sub.oadd.o:add.c gcc -c add.c -o add.odiv.o:div.c gcc -c div.c -o div.omain.o:main.c gcc -c main.c -o main.o æˆ‘ä»¬è¾“å…¥å‘½ä»¤make å˜é‡ è‡ªå®šä¹‰å˜é‡ å˜é‡å &#x3D; å˜é‡å€¼ var &#x3D; hello é¢„å®šä¹‰å˜é‡ ARï¼šå½’æ¡£ç»´æŠ¤ç¨‹åºçš„åç§°ï¼Œé»˜è®¤å€¼ä¸ºar CCï¼šCç¼–è¯‘å™¨çš„åç§°ï¼Œé»˜è®¤å€¼ä¸ºcc CXXï¼šC++ç¼–è¯‘å™¨çš„åç§°ï¼Œé»˜è®¤å€¼ä¸ºg++ $@ï¼šç›®æ ‡çš„å®Œæ•´åç§° $&lt;ï¼šç¬¬ä¸€ä¸ªä¾èµ–æ–‡ä»¶çš„åç§° $^ï¼šæ‰€æœ‰çš„ä¾èµ–æ–‡ä»¶ è·å–å˜é‡çš„å€¼ $(å˜é‡å) 12app:main.c a.c b.c gcc -c main.c a.c b.c 12app:main.c a.c b.c $(CC) -c $^ -o $@ ä¸Šä¸¤æ®µä»£ç ç­‰ä»· 1%.o:%.o % ä¸ºé€šé…ç¬¦ï¼ŒåŒ¹é…ä¸€ä¸ªå­—ç¬¦ä¸² ä¸¤ä¸ª%åŒ¹é…çš„æ˜¯åŒä¸€ä¸ªå­—ç¬¦ä¸² æˆ‘ä»¬ä¸Šè¿°çš„Makefileæ–‡ä»¶ä¹Ÿå¯æ”¹ä¸º 1234567src = sub.o add.o mult.o div.o main.otarget = app$(target):$(src) $(CC) &amp;(src) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ å‡½æ•°$(wildcard PATTERN â€¦) åŠŸèƒ½ï¼šè·å–æŒ‡å®šç›®å½•ä¸‹æŒ‡å®šç±»å‹çš„æ–‡ä»¶åˆ—è¡¨ å‚æ•°ï¼šPATTERNæŒ‡çš„æ˜¯æŸä¸ªæˆ–å¤šä¸ªç›®å½•ä¸‹çš„å¯¹åº”çš„æŸç§ç±»å‹çš„æ–‡ä»¶ï¼Œå¦‚æœæœ‰å¤šä¸ªç›®å½•ï¼Œä¸€èˆ¬ä½¿ç”¨ç©ºæ ¼é—´éš” è¿”å›ï¼šå¾—åˆ°çš„è‹¥å¹²ä¸ªæ–‡ä»¶çš„æ–‡ä»¶åˆ—è¡¨ï¼Œæ–‡ä»¶åä¹‹é—´ä½¿ç”¨ç©ºæ ¼é—´éš” ç¤ºä¾‹ï¼š 1$(wildcard *.c ./sub/*c) è¿”å›å€¼æ ¼å¼ï¼ša.c b.c c.c d.c e.c f.c $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) åŠŸèƒ½ï¼šæŸ¥æ‰¾ä¸­çš„å•è¯ï¼ˆå•è¯ä»¥â€œç©ºæ ¼â€ã€â€œTabâ€æˆ–â€œå›è½¦â€â€œæ¢è¡Œâ€åˆ†éš”ï¼‰æ˜¯å¦ç¬¦åˆæ¨¡å¼,å¦‚æœåŒ¹é…çš„è¯ï¼Œåˆ™ä»¥æ›¿æ¢ã€‚ å¯ä»¥åŒ…æ‹¬é€šé…ç¬¦%,è¡¨ç¤ºä»»æ„é•¿åº¦çš„å­—ç¬¦ä¸²ã€‚å¦‚æœä¸­ä¹ŸåŒ…å«%ï¼Œé‚£ä¹ˆï¼Œä¸­çš„è¿™ä¸ª%å°†æ˜¯ä¸­çš„é‚£ä¸ª%æ‰€ä»£è¡¨çš„å­—ç¬¦ä¸²ã€‚ï¼ˆå¯ä»¥ç”¨\\æ¥è½¬ä¹‰ï¼Œä»¥\\%æ¥è¡¨ç¤ºçœŸå®å«ä¹‰çš„%å­—ç¬¦ï¼‰ è¿”å›ï¼šå‡½æ•°è¿”å›è¢«æ›¿æ¢è¿‡åçš„å­—ç¬¦ä¸² ç¤ºä¾‹ 1$(patsubst %.c, %.o, x.c bar.c) è¿”å›å€¼æ ¼å¼ï¼šx.o bar.o 1234567891011src=$(wildcard ./*.c)objs=$(patsubst %.c, %.o, $(src))target=app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@clean: rm $(objs) -f ä¹‹åè¿è¡Œ 1make clean å°±ä¼šè‡ªåŠ¨åˆ é™¤rmæŒ‡ä»¤","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"è®ºæ–‡é˜…è¯» Making Memory Account Accountableï¼šAnalyzing and Detecting Memory Missing account bugs for Container Platforms","slug":"è®ºæ–‡é˜…è¯»-Making-Memory-Account-Accountableï¼šAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms","date":"2023-04-23T11:09:13.000Z","updated":"2023-05-03T10:12:16.789Z","comments":true,"path":"2023/04/23/è®ºæ–‡é˜…è¯»-Making-Memory-Account-Accountableï¼šAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/","link":"","permalink":"http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/","excerpt":"æ‘˜è¦ Linuxå†…æ ¸å¼•å…¥äº†memory control group(memcg)ï¼Œç”¨äºåœ¨è¿›ç¨‹çº§å¯¹å†…å­˜çš„ä½¿ç”¨è¿›è¡Œè®°å½•å’Œé™åˆ¶ã€‚memcgç”±äºå…¶çµæ´»æ€§å’Œé«˜æ•ˆæ€§ï¼Œè¢«å®¹å™¨å¹³å°å¹¿æ³›é‡‡ç”¨ï¼Œæˆä¸ºä¸€ç§åŸºç¡€æŠ€æœ¯ã€‚è™½ç„¶å†…å­˜è®°å¸å¾ˆé‡è¦ï¼Œä½†ç”±äºå†…å­˜è®°å¸æ¥å£çš„å¤šæ ·æ€§å’Œå¤§é‡çš„åˆ†é…&#x2F;ç©ºé—²è·¯å¾„ï¼Œå®ƒå¾ˆå®¹æ˜“å‡ºç°è®°è´¦çš„é”™è¯¯ã€‚æ®æˆ‘ä»¬æ‰€çŸ¥ï¼Œç›®å‰è¿˜æ²¡æœ‰é’ˆå¯¹å†…å­˜å¸æˆ·ä¸¢å¤±é—®é¢˜çš„ç³»ç»Ÿåˆ†æï¼ŒåŒ…æ‹¬å…¶å®‰å…¨å½±å“ã€æ£€æµ‹ç­‰ã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬é¦–æ¬¡ç³»ç»Ÿåœ°ç ”ç©¶äº†å†…å­˜è®°è´¦ç¼ºå¤±é—®é¢˜ã€‚æˆ‘ä»¬é¦–å…ˆå¯¹å…¶åœ¨å®¹å™¨å¹³å°ä¸Šçš„å¯åˆ©ç”¨æ€§å’Œå®‰å…¨æ€§å½±å“è¿›è¡Œäº†æ·±å…¥åˆ†æã€‚ç„¶åæˆ‘ä»¬å¼€å‘äº†ä¸€ä¸ªåä¸ºMANTA(Memory Accounting Analyzer)çš„å·¥å…·ï¼Œå®ƒç»“åˆäº†é™æ€å’ŒåŠ¨æ€åˆ†ææŠ€æœ¯æ¥è‡ªåŠ¨æ£€æµ‹å’ŒéªŒè¯å†…å­˜ä¸¢å¤±å¸æˆ·é”™è¯¯ã€‚","text":"æ‘˜è¦ Linuxå†…æ ¸å¼•å…¥äº†memory control group(memcg)ï¼Œç”¨äºåœ¨è¿›ç¨‹çº§å¯¹å†…å­˜çš„ä½¿ç”¨è¿›è¡Œè®°å½•å’Œé™åˆ¶ã€‚memcgç”±äºå…¶çµæ´»æ€§å’Œé«˜æ•ˆæ€§ï¼Œè¢«å®¹å™¨å¹³å°å¹¿æ³›é‡‡ç”¨ï¼Œæˆä¸ºä¸€ç§åŸºç¡€æŠ€æœ¯ã€‚è™½ç„¶å†…å­˜è®°å¸å¾ˆé‡è¦ï¼Œä½†ç”±äºå†…å­˜è®°å¸æ¥å£çš„å¤šæ ·æ€§å’Œå¤§é‡çš„åˆ†é…&#x2F;ç©ºé—²è·¯å¾„ï¼Œå®ƒå¾ˆå®¹æ˜“å‡ºç°è®°è´¦çš„é”™è¯¯ã€‚æ®æˆ‘ä»¬æ‰€çŸ¥ï¼Œç›®å‰è¿˜æ²¡æœ‰é’ˆå¯¹å†…å­˜å¸æˆ·ä¸¢å¤±é—®é¢˜çš„ç³»ç»Ÿåˆ†æï¼ŒåŒ…æ‹¬å…¶å®‰å…¨å½±å“ã€æ£€æµ‹ç­‰ã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬é¦–æ¬¡ç³»ç»Ÿåœ°ç ”ç©¶äº†å†…å­˜è®°è´¦ç¼ºå¤±é—®é¢˜ã€‚æˆ‘ä»¬é¦–å…ˆå¯¹å…¶åœ¨å®¹å™¨å¹³å°ä¸Šçš„å¯åˆ©ç”¨æ€§å’Œå®‰å…¨æ€§å½±å“è¿›è¡Œäº†æ·±å…¥åˆ†æã€‚ç„¶åæˆ‘ä»¬å¼€å‘äº†ä¸€ä¸ªåä¸ºMANTA(Memory Accounting Analyzer)çš„å·¥å…·ï¼Œå®ƒç»“åˆäº†é™æ€å’ŒåŠ¨æ€åˆ†ææŠ€æœ¯æ¥è‡ªåŠ¨æ£€æµ‹å’ŒéªŒè¯å†…å­˜ä¸¢å¤±å¸æˆ·é”™è¯¯ã€‚ æˆ‘ä»¬çš„åˆ†æè¡¨æ˜ï¼Œæ‰€æœ‰çš„å®¹å™¨è¿è¡Œæ—¶ï¼ŒåŒ…æ‹¬runCå’ŒKataå®¹å™¨ï¼Œéƒ½å®¹æ˜“å—åˆ°åŸºäºå†…å­˜è®°è´¦ç¼ºå¤±çš„æ”»å‡»ã€‚æ­¤å¤–ï¼Œå†…å­˜è®°è´¦ç¼ºå¤±å¯ä»¥è¢«åˆ©ç”¨æ¥æ”»å‡»Dockerã€CaaSå’ŒFaaSå¹³å°ï¼Œå¯¼è‡´å†…å­˜è€—å°½ï¼Œä»è€Œä½¿å•ä¸ªèŠ‚ç‚¹ç”šè‡³æ•´ä¸ªé›†ç¾¤å´©æºƒã€‚æˆ‘ä»¬çš„å·¥å…·æŠ¥å‘Šäº†53ä¸ªå¯åˆ©ç”¨çš„å†…å­˜è®°è´¦ç¼ºå¤±æ¼æ´ï¼Œå…¶ä¸­37ä¸ªè¢«å†…æ ¸å¼€å‘è€…ç¡®è®¤ï¼Œå¹¶æäº¤äº†ç›¸åº”çš„è¡¥ä¸ï¼Œè¿˜æœ‰ä¸¤ä¸ªæ–°çš„CVEè¢«åˆ†é…ã€‚é€šè¿‡æ·±å…¥åˆ†æã€è‡ªåŠ¨æ£€æµ‹ã€æŠ¥å‘Šçš„é”™è¯¯å’Œæäº¤çš„è¡¥ä¸ï¼Œæˆ‘ä»¬ç›¸ä¿¡æˆ‘ä»¬çš„ç ”ç©¶æé«˜äº†å®¹å™¨å¹³å°å†…å­˜æ ¸ç®—çš„æ­£ç¡®æ€§å’Œå®‰å…¨æ€§ã€‚ CCS CONCEPTS Security and privacy â†’ Operating systems security; Virtualization and security KEYWORDS Cloud infrastructure, Linux kernel, memory accounting, missingaccount, DoS attack INTRODUCTIONè®¡ç®—å’Œé™åˆ¶å†…å­˜ä½¿ç”¨æ˜¯æ¯ä¸ªæ“ä½œç³»ç»Ÿå†…æ ¸çš„æ ¸å¿ƒåŠŸèƒ½ã€‚ç‰¹åˆ«æ˜¯ï¼ŒLinuxå†…æ ¸å¼•å…¥äº†å†…å­˜æ§åˆ¶ç»„(memcg)ï¼Œå®ƒå¯ä»¥åœ¨è¿›ç¨‹çº§åˆ«è§£é‡Šå’Œé™åˆ¶å†…å­˜ä½¿ç”¨ã€‚å› æ­¤ï¼Œä¸åŸºäºè™šæ‹Ÿæœº(VM)çš„å†…å­˜åˆ†åŒºæŠ€æœ¯ç›¸æ¯”ï¼Œmemcgå…·æœ‰æ›´ç»†ç²’åº¦å’Œè½»é‡çº§çš„ç‰¹ç‚¹ã€‚ ç”±äºå…¶çµæ´»æ€§å’Œé«˜æ•ˆæ€§ï¼Œmemcgå·²ç»è¢«å®¹å™¨å¹³å°å¹¿æ³›é‡‡ç”¨ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œå®¹å™¨å¹³å°ä¸¥é‡ä¾èµ–èµ„æºå…±äº«æ¥æé«˜ç¡¬ä»¶èµ„æºçš„åˆ©ç”¨ç‡ã€‚è€Œmemcgä¸ºå®¹å™¨åœ¨è¿›ç¨‹çº§åˆ«æä¾›äº†å”¯ä¸€çš„å†…å­˜ä½¿ç”¨è®°å½•å’Œé™åˆ¶æ–¹æ³•ã€‚å› æ­¤ï¼Œè¯¸å¦‚Docker ã€å®¹å™¨å³æœåŠ¡å¹³å°ï¼ˆä¾‹å¦‚ï¼ŒOpenShiftï¼‰å’Œå‡½æ•°å³æœåŠ¡å¹³å°ï¼ˆä¾‹å¦‚ï¼ŒOpenWhiskï¼‰ç­‰æµè¡Œçš„å®¹å™¨å¹³å°ï¼Œéƒ½é‡‡ç”¨memcgæ¥æ§åˆ¶å…¶å®¹å™¨çš„å†…å­˜ä½¿ç”¨ã€‚æ­¤å¤–ï¼ŒåŸºäºè™šæ‹Ÿæœºçš„å®¹å™¨è¿è¡Œæ—¶â€”â€”Kataå®¹å™¨ ä¹Ÿä½¿ç”¨memcgæ¥é™åˆ¶ä¸»æœºä¸Šçš„å®¹å™¨çº¿ç¨‹å’Œå…¶ä»–æœåŠ¡çº¿ç¨‹çš„å†…å­˜ã€‚æ­¤å¤–ï¼Œå¼€æ”¾å®¹å™¨å€¡è®®ï¼ˆOCIï¼‰è®¤è¯è¦æ±‚å®¹å™¨è¿è¡Œæ—¶å¿…é¡»ä½¿ç”¨memcgæ‰èƒ½è·å¾—è®¤è¯ ã€‚å› æ­¤ï¼Œmemcgå·²ç»æˆä¸ºå®¹å™¨å¹³å°å’Œäº‘è®¡ç®—çš„åŸºç¡€æŠ€æœ¯ã€‚ ä¸å¹¸çš„æ˜¯ï¼Œå°½ç®¡memcgè¢«å¹¿æ³›ä½¿ç”¨ï¼Œä½†ç”±äºå…¶å¤æ‚æ€§ï¼Œå®ƒå®¹æ˜“å‡ºé”™ã€‚å…·ä½“æ¥è¯´ï¼ŒLinuxå†…æ ¸é€‰æ‹©å°†å†…å­˜è®°è´¦æ¥å£æ’å…¥åˆ°å†…å­˜åˆ†é…&#x2F;é‡Šæ”¾è·¯å¾„ä¸­ä»¥å®ç°è®°è´¦ï¼Œè¿™å¯èƒ½ç”±äºé«˜åº¦å¤æ‚çš„å†…å­˜ä½¿ç”¨å’Œå¤§é‡ä¸å†…å­˜ä½¿ç”¨ç›¸å…³çš„æ¥å£å’Œä»£ç è·¯å¾„ï¼Œå®¹æ˜“å¼•å…¥å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ï¼ˆåˆ†é…çš„å†…å­˜æœªè®¡å…¥è´¦æˆ·ï¼‰ã€‚æ­¤å¤–ï¼Œå³ä½¿è®°è´¦æ¥å£ä½ç½®æ­£ç¡®ï¼Œå®ƒä»¬çš„è®°è´¦è¡Œä¸ºä¹Ÿæ˜¯æœ‰æ¡ä»¶çš„ï¼Œå¹¶å—åˆ°è®°è´¦æ ‡å¿—çš„æ§åˆ¶ï¼Œæˆ‘ä»¬å‘ç°è¿™äº›æ ‡å¿—ç»å¸¸ç¼ºå¤±ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å‘ç°å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯å¾ˆå¸¸è§ã€‚ ç„¶è€Œï¼Œå³ä½¿memcgå·²ç»è¢«å¹¿æ³›ä½¿ç”¨ï¼Œå…¶å†…å­˜è®°è´¦ä¸¢å¤±æ¼æ´ä»æœªå¾—åˆ°ç³»ç»Ÿåˆ†æã€‚ memcgçš„ç°çŠ¶æ˜¯ç”±ä¸¤ä¸ªåŸå› é€ æˆçš„ã€‚é¦–å…ˆï¼Œä»æ¥æ²¡æœ‰æ¸…æ¥šåœ°çŸ¥é“å†…å­˜è®°è´¦ä¸¢å¤±æ¼æ´ä¼šäº§ç”Ÿä»€ä¹ˆå®‰å…¨å½±å“æˆ–è€…å®ƒä»¬æ˜¯å¦å¯åˆ©ç”¨ã€‚ç»“æœï¼Œè®°è´¦ä¸¢å¤±é”™è¯¯è¢«å†…æ ¸å¼€å‘äººå‘˜å¿½ç•¥ï¼Œå¹¶ä¸”æ²¡æœ‰ç‰¹åˆ«åŠªåŠ›æ¶ˆé™¤è¿™äº›é—®é¢˜ã€‚å…¶æ¬¡ï¼Œæ²¡æœ‰è‡ªåŠ¨æ£€æµ‹å†…å­˜è®°è´¦ä¸¢å¤±æ¼æ´ã€‚æ­£å¦‚ä¹‹å‰è®¨è®ºçš„é‚£æ ·ï¼Œå†…å­˜è®°å¸è®¾è®¡å’Œå®ç°éå¸¸å¤æ‚ï¼Œå¹¶æ·±åº¦é›†æˆåˆ°Linux kernelçš„å¤æ‚å†…å­˜ç®¡ç†å­ç³»ç»Ÿä¸­ã€‚å› æ­¤ï¼Œå³ä½¿å¯¹äºæœ‰ç»éªŒçš„ç”¨æˆ·æ¥è¯´ä¹Ÿå¾ˆéš¾æ­£ç¡®ç†è§£è®°å¸è®¾è®¡å’Œç­–ç•¥ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å‘ç°Dockerå®˜æ–¹ç½‘ç«™é”™è¯¯åœ°å£°ç§°â€œé¡µé¢é«˜é€Ÿç¼“å­˜çš„è®°å¿†è´¹ç”¨åœ¨æ§åˆ¶ç»„ä¹‹é—´åˆ†é…â€ï¼Œå¹¶ä¸”â€œå½“ä¸€ä¸ªcgroupç»ˆæ­¢æ—¶ï¼Œå®ƒå¯èƒ½ä¼šå¢åŠ å¦ä¸€ä¸ªcgroup çš„å†…å­˜ä½¿ç”¨é‡â€œã€‚å› æ­¤ï¼Œåœ¨æ²¡æœ‰è‡ªåŠ¨æ£€æµ‹çš„æƒ…å†µä¸‹æ‰‹åŠ¨æ¨æ–­è®°å¸æ­£ç¡®æ€§å‡ ä¹æ˜¯ä¸å¯èƒ½çš„æ›´ç³Ÿç³•çš„æ˜¯, å†…å­˜è®°è´¦ä¸¢å¤±æ˜¯å¦å¯æ£€æµ‹ä»¥åŠå¦‚ä½•è¿›è¡Œæ£€æµ‹ä»ç„¶æ˜¯å¼€æ”¾æ€§é—®é¢˜ã€‚ æœ¬æ–‡é¦–æ¬¡å¯¹Linuxå†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯è¿›è¡Œäº†ç³»ç»Ÿåˆ†æå’Œæ£€æµ‹ã€‚æˆ‘ä»¬é¦–å…ˆè¿›è¡Œäº†æ·±å…¥åˆ†æï¼Œä»¥äº†è§£å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯åœ¨å®¹å™¨å¹³å°ä¸Šçš„å¯åˆ©ç”¨æ€§å’Œå®‰å…¨å½±å“ã€‚ç„¶åæˆ‘ä»¬å¼€å‘äº†ä¸€ä¸ªåä¸ºMANTAï¼ˆMemory AccouNTing Analyzerçš„ç®€ç§°ï¼‰çš„å·¥å…·ï¼Œå®ƒç»“åˆäº†é™æ€å’ŒåŠ¨æ€åˆ†ææŠ€æœ¯æ¥è‡ªåŠ¨æ£€æµ‹å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ã€‚æˆ‘ä»¬çš„åˆ†ææ˜¾ç¤ºï¼Œä¸ä»…æ™®é€šå®¹å™¨è¿è¡Œæ—¶ï¼ˆå¦‚runCï¼‰ï¼Œè€Œä¸”å®‰å…¨å®¹å™¨è¿è¡Œæ—¶ï¼ˆå¦‚Kataå®¹å™¨ï¼‰éƒ½å®¹æ˜“å—åˆ°ç”±å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯å¼•èµ·çš„å†…å­˜è€—å°½æ”»å‡»ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œå†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯å¯ä»¥è¢«åˆ©ç”¨æ¥æ”»å‡»Dockerã€CaaSå’ŒFaaSå¹³å°ï¼Œå¯¼è‡´å®¹å™¨èŠ‚ç‚¹ç”šè‡³æ•´ä¸ªé›†ç¾¤å´©æºƒã€‚ ç”±äºmemcgçš„å¤æ‚æ€§ï¼Œå†…å­˜è®°è´¦ä¸¢å¤±æ£€æµ‹é¢ä¸´ä¸¤ä¸ªæŒ‘æˆ˜ã€‚é¦–å…ˆï¼Œæ²¡æœ‰æ–‡æ¡£æˆ–ç°æœ‰ç ”ç©¶å®šä¹‰äº†memcgä½¿ç”¨çš„å†…å­˜è®°è´¦æ¥å£ã€‚ç°æœ‰çš„å·¥ä½œé‡‡ç”¨è‡ªç„¶è¯­è¨€å¤„ç†æˆ–åŒ…è£…å‡½æ•°åˆ†ææ¥è¯†åˆ«å†…å­˜åˆ†é…æ¥å£ã€‚ç„¶è€Œï¼Œç”±äºä¸åŒ¹é…çš„å¯å‘å¼è§„åˆ™ï¼Œè¿™äº›æŠ€æœ¯æ— æ³•ç›´æ¥åº”ç”¨äºè®°è´¦æ¥å£ã€‚ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒMANTAæå‡ºäº†åŸºäºè®¡æ•°å™¨çš„æ¥å£è¯†åˆ«æ–¹æ³•ï¼Œè‡ªåŠ¨æ£€æµ‹æ‰€æœ‰ä¸å†…å­˜è®°è´¦ç›¸å…³çš„æ¥å£ã€‚å…³é”®çš„è§‚å¯Ÿæ˜¯ï¼Œæ‰€æœ‰å†…å­˜è®°è´¦æ¥å£æœ€ç»ˆéƒ½ä¼šåœ¨å®ç°ä¸­å¢åŠ &#x2F;å‡å°‘ç›¸åº”çš„é¡µé¢è®¡æ•°å™¨ã€‚è¯†åˆ«ä»é¡µé¢è®¡æ•°å™¨ä¿®æ”¹å¼€å§‹ï¼Œè¿­ä»£æ•´ä¸ªè°ƒç”¨å›¾ä»¥ç²¾ç¡®è¯†åˆ«è®°è´¦æ¥å£ã€‚ å…¶æ¬¡ï¼Œåˆ†æå†…å­˜åˆ†é…å’Œå†…å­˜è®°è´¦ä¹‹é—´çš„æ˜ å°„å…·æœ‰æŒ‘æˆ˜æ€§ã€‚è¿™ç§åˆ†æç”±äºä»å†…å­˜åˆ†é…ä½ç½®åˆ°å†…å­˜è®°è´¦ä½ç½®çš„æ·±å±‚å’ŒåµŒå¥—æ‰§è¡Œè·¯å¾„è€Œå˜å¾—å¤æ‚ã€‚å®ƒè¿˜éœ€è¦è·Ÿè¸ªåˆ†é…çš„é¡µé¢å’Œè®¡å…¥è´¦æˆ·çš„é¡µé¢ä¹‹é—´çš„æ•°æ®æµï¼Œä»¥è·å¾—æ­£ç¡®çš„åˆ«åé›†ã€‚æ­¤å¤–ï¼Œç”±äºæ¡ä»¶æ ‡å¿—çš„æ§åˆ¶ï¼Œè®°è´¦å¯èƒ½æ˜¯æœ‰æ¡ä»¶çš„ã€‚å› æ­¤ï¼ŒMANTAæå‡ºäº†åˆ†é…-æ¶ˆè€—æ˜ å°„åˆ†æå’Œè®°è´¦æ ‡å¿—åˆ†ææ¥è§£å†³è¿™ä¸ªæŒ‘æˆ˜ã€‚æ­¤å¤–ï¼Œä¸ºäº†éªŒè¯æ£€æµ‹åˆ°çš„å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ï¼ŒMANTAè¿›ä¸€æ­¥ä½¿ç”¨Linuxæµ‹è¯•é¡¹ç›®æ¥æ£€æŸ¥å®ƒä»¬çš„å¯è§¦å‘æ€§å’Œå½±å“ã€‚ é€šè¿‡MANTAï¼Œæˆ‘ä»¬æ£€æµ‹å¹¶æŠ¥å‘Šäº†memcgä¸­çš„53ä¸ªå¯åˆ©ç”¨é”™è¯¯ï¼Œå…¶ä¸­37ä¸ªå·²ç»è¢«å†…æ ¸å¼€å‘äººå‘˜ç¡®è®¤å¹¶æœ‰å·²åˆå¹¶æˆ–å¾…åˆå¹¶çš„è¡¥ä¸ã€‚æŠ¥å‘Šçš„é”™è¯¯è·å¾—äº†ä¸¤ä¸ªæ–°çš„CVEï¼ˆä¸€ä¸ªæ­£åœ¨ç­‰å¾…ï¼‰ã€‚æ€»ä¹‹ï¼Œè¿™é¡¹å·¥ä½œè¿›è¡Œäº†æ·±å…¥è°ƒæŸ¥ï¼Œä¸ä»…åˆ†æäº†å¯åˆ©ç”¨æ€§å’Œå½±å“ï¼Œè¿˜ç³»ç»Ÿåœ°æ£€æµ‹äº†å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ã€‚æˆ‘ä»¬ç›¸ä¿¡ï¼Œè¿™äº›å‘ç°å°†æœ‰åŠ©äºå†…æ ¸memcgå¼€å‘äººå‘˜åœ¨æœªæ¥æ”¹è¿›å†…å­˜è®°è´¦ã€‚æœ¬æ–‡åšå‡ºäº†ä»¥ä¸‹è´¡çŒ®ã€‚ In-depth analysis of exploitability and impacts æˆ‘ä»¬è®¾è®¡äº†æ–°çš„æ”»å‡»æ¥åˆ©ç”¨å®¹å™¨å¹³å°ä¸Šçš„å†…å­˜è®°è´¦é—®é¢˜ã€‚æˆ‘ä»¬çš„æ”»å‡»è¡¨æ˜ï¼Œå†…å­˜è®°è´¦ä¸¢å¤±æ¼æ´å¯ä»¥å¾ˆå®¹æ˜“åœ°è¢«åˆ©ç”¨æ¥æ”»å‡»æ­£å¸¸å’Œå®‰å…¨çš„å®¹å™¨è¿è¡Œæ—¶(å³runCå’ŒKataå®¹å™¨)å’Œæµè¡Œçš„å®¹å™¨å¹³å°(å³Docker, OpenShiftå’ŒOpenWhisk)ï¼Œå¯¼è‡´å®¹å™¨èŠ‚ç‚¹ç”šè‡³æ•´ä¸ªé›†ç¾¤å´©æºƒã€‚ Automated detection with new techniques æˆ‘ä»¬æå‡ºäº†å¤šç§åˆ†ææŠ€æœ¯æ¥æœ‰æ•ˆåœ°æ£€æµ‹å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ï¼Œé›†æˆäº†é™æ€åˆ†æå’ŒåŠ¨æ€éªŒè¯ã€‚æˆ‘ä»¬å®ç°äº†åŸºäºLLVMçš„æ£€æµ‹ï¼Œå¹¶ä½¿ç”¨Linuxå†…å­˜è®°è´¦å¯¹å…¶è¿›è¡Œè¯„ä¼°ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥ä½¿ç”¨Linux Test Project (LTP)æ¥éªŒè¯æ£€æµ‹åˆ°çš„é”™è¯¯çš„å¯è§¦å‘æ€§ã€‚ Community impact æˆ‘ä»¬åœ¨Linux v5.10ä¸­æ£€æµ‹å¹¶æŠ¥å‘Šäº†53ä¸ªå¯åˆ©ç”¨çš„å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ï¼Œå…¶ä¸­37ä¸ªå·²è¢«å†…æ ¸å¼€å‘äººå‘˜ç¡®è®¤ã€‚åˆ†é…äº†ä¸¤ä¸ªæ–°çš„cve(ä¸€ä¸ªæ­£åœ¨ç­‰å¾…)ã€‚æˆ‘ä»¬çš„å‘ç°æé«˜äº†å†…æ ¸ç¤¾åŒºå¯¹è®°è´¦ä¸¢å¤±çš„å½±å“çš„è®¤è¯†ï¼Œä»–ä»¬è¿˜é‚€è¯·æˆ‘ä»¬æµ‹è¯•ä»–ä»¬çš„ä¸‹æ¸¸å†…æ ¸ã€‚æˆ‘ä»¬è®¡åˆ’å¼€æºæˆ‘ä»¬çš„æ£€æµ‹å·¥å…·ï¼Œä»¥è¿›ä¸€æ­¥å¸®åŠ©ç¤¾åŒºæé«˜å†…å­˜è®¡è´¹çš„æ­£ç¡®æ€§å’Œå®‰å…¨æ€§ã€‚ é“å¾·è€ƒè™‘ï¼šæœ¬æ–‡ä¸­çš„æ‰€æœ‰å®éªŒå’Œæ”»å‡»éƒ½æ˜¯åœ¨ä¸€å°ä¸“ç”¨çš„ç‰©ç†æœºå™¨ä¸Šè¿›è¡Œçš„ï¼Œè¿™å°æœºå™¨ä»…ç”±æˆ‘ä»¬ä½¿ç”¨ã€‚æˆ‘ä»¬è´Ÿè´£ä»»åœ°å‘Linuxå†…æ ¸å¼€å‘äººå‘˜æŠ«éœ²äº†æ‰€æœ‰æ£€æµ‹åˆ°çš„é”™è¯¯ï¼Œå¹¶ä¸ºæ‰€æœ‰ç»ç¡®è®¤çš„é”™è¯¯æäº¤äº†è¡¥ä¸ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å‘Dockerå›¢é˜ŸæŠ¥å‘Šäº†å…³äºå†…å­˜è®°è´¦çš„é”™è¯¯å£°æ˜ã€‚ BACKGROUDLinux Memory Accountingå†…å­˜è®°å¸æ˜¯æ¯ä¸ªç°ä»£æ“ä½œç³»ç»Ÿå†…æ ¸çš„æ ¸å¿ƒåŠŸèƒ½ã€‚ç›®å‰Linuxå†…æ ¸é‡‡ç”¨å†…å­˜æ§åˆ¶ç»„(memory control group, memcg)æ¥å®ç°å†…å­˜è®¡è´¹ã€‚MemcgåŒ…å«4ç§ç±»å‹çš„å†…å­˜:userã€kernelã€swapï¼Œand socketã€‚ user è®°å½•æ‰€æœ‰ç”¨æˆ·ç©ºé—´å†…å­˜é¡µ kernel è®°å½•å†…æ ¸ç©ºé—´å†…å­˜é¡µå’Œå¯¹è±¡ swap è®°å½•äº¤æ¢åŒºé¡µé¢ socket è®°å½•socketå†…å­˜ Memcgä»…å¯¹ç”¨æˆ·ç©ºé—´è¿›ç¨‹çš„å†…å­˜è¿›è¡Œè®°è´¦ï¼Œå¹¶è·³è¿‡å¯¹å†…æ ¸å®ˆæŠ¤ç¨‹åºæˆ–å†…éƒ¨å†…å­˜ä½¿ç”¨çš„è®°è´¦ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒLinuxå†…æ ¸v5.9å¼•å…¥äº†å¯¹è±¡cgroupï¼Œå®ƒä¼šå¯¹å­é¡µé¢å†…æ ¸å†…å­˜ä½¿ç”¨ï¼ˆå¦‚å†…æ ¸å¯¹è±¡ï¼‰è¿›è¡Œè®°è´¦ã€‚å¯¹è±¡cgroupå¯ä»¥å°†å¯¹è±¡åˆ†é…åˆ°ä¸åŒçš„cgroupsä¸­ï¼Œä»è€Œæ¶ˆé™¤æ¯ä¸ªmemcgçš„slabï¼ˆå†…å­˜åˆ†é…æ± ï¼‰ï¼ŒèŠ‚çœå¤§é‡çš„slabå†…å­˜ã€‚ Accountingï¼šLinuxå†…æ ¸é’ˆå¯¹ä¸åŒç±»å‹çš„å†…å­˜ä½¿ç”¨ä¸åŒçš„è®°è´¦æ¥å£ã€‚å…·ä½“æ¥è¯´ï¼ŒLinuxå†…æ ¸ä½¿ç”¨mem_cgroup_chargeå¯¹ç”¨æˆ·å’Œäº¤æ¢å†…å­˜è¿›è¡Œè®°è´¦ï¼Œä½¿ç”¨__memcg_kmem_chargeå¯¹å†…æ ¸å†…å­˜è¿›è¡Œè®°è´¦ã€‚å¯¹äºå†…æ ¸å†…å­˜ï¼ŒLinuxå†…æ ¸è¿˜è¦æ±‚åœ¨å†…å­˜åˆ†é…è¿‡ç¨‹ä¸­è®¾ç½®__GFP_ACCOUNTæ ‡å¿—ä»¥å¯¹å†…æ ¸é¡µé¢è¿›è¡Œè®°è´¦ã€‚ç”¨æˆ·å¯ä»¥é€šè¿‡æ–‡ä»¶æ¥å£ä¸memcgè¿›è¡Œäº¤äº’ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·å¯ä»¥ä»memory.usage_in_bytesæ£€æŸ¥æ€»å†…å­˜ä½¿ç”¨æƒ…å†µã€‚ ä¸€ä¸ªmemcgå®ä¾‹å¯èƒ½åŒ…å«å¤šä¸ªå†…å­˜ä½¿ç”¨æƒ…å†µåœ¨å…¶ä¸­è¿›è¡Œè®°è´¦çš„è¿›ç¨‹ã€‚memcgä»¥æ ‘å½¢å±‚æ¬¡ç»“æ„ç»„ç»‡ï¼Œå› æ­¤çˆ¶èŠ‚ç‚¹ä¸Šçš„å†…å­˜é™åˆ¶ä¹Ÿä¼šå½±å“æ‰€æœ‰å­èŠ‚ç‚¹ã€‚memcgæœ‰ä¸¤ä¸ªç‰ˆæœ¬ï¼šv1å’Œv2ã€‚å®ƒä»¬çš„ä¸»è¦åŒºåˆ«åœ¨äºå±‚æ¬¡ç»“æ„å’Œç”¨æˆ·æ¥å£ï¼Œè€Œåœ¨è®°è´¦æ–¹é¢çš„å®ç°å¤§è‡´ç›¸åŒã€‚ç›®å‰ä¸¤è€…éƒ½åœ¨ä½¿ç”¨ã€‚æœ¬æ–‡æåˆ°çš„æ˜¯cgroups v1ï¼Œå¤§å¤šæ•°ç»“è®ºä¹Ÿé€‚ç”¨äºcgroups v2ã€‚ æ•°æ®ç»“æ„ï¼šmemcgçš„æ ¸å¿ƒæ•°æ®ç»“æ„æ˜¯mem_cgroupï¼Œå®ƒä»£è¡¨ä¸€ä¸ªmemcgå®ä¾‹ã€‚memcgåŒ…å«4ä¸ªé¡µé¢è®¡æ•°å™¨ï¼Œå¯¹åº”äºä¹‹å‰è®¨è®ºçš„4ç§ç±»å‹çš„å·²è®°è´¦å†…å­˜ã€‚æ¯ä¸ªé¡µé¢è®¡æ•°å™¨ä½¿ç”¨usageï¼ˆç¬¬14è¡Œï¼‰æ¥è®¡ç®—åˆ†é…çš„é¡µé¢æ•°é‡ã€‚åŒæ—¶ï¼Œæ€»å†…å­˜é™åˆ¶ï¼ˆä»¥é¡µé¢ä¸ºå•ä½ï¼‰è®¾ç½®åœ¨maxï¼ˆç¬¬16è¡Œï¼‰ã€‚åœ¨å†…å­˜å……ç”µæ—¶ï¼ŒLinuxå†…æ ¸è°ƒç”¨æ¶ˆè€—æ¥å£ï¼Œä¾æ¬¡è°ƒç”¨page_counter_try_chargeï¼Œè¿™æ˜¯ä¸€ä¸ªè®¡ç®—æ€»ä½¿ç”¨é‡ï¼ˆç¬¬24è¡Œï¼‰å¹¶å°†å…¶ä¸æœ€å¤§é™åˆ¶ï¼ˆç¬¬25è¡Œï¼‰è¿›è¡Œæ£€æŸ¥çš„å‡½æ•°ã€‚ Accounting challengesï¼šç”±äºLinuxå†…æ ¸ä¸­ä¼—å¤šçš„å†…å­˜åˆ†é…æ¥å£å’Œåºå¤§çš„åˆ†é…è·¯å¾„ï¼Œæ­£ç¡®åœ°å¯¹Linuxå†…æ ¸ä¸­çš„å†…å­˜ä½¿ç”¨æƒ…å†µè¿›è¡Œè®°è´¦éå¸¸å…·æœ‰æŒ‘æˆ˜æ€§ã€‚å¾ˆéš¾è°ƒè§£æ‰€æœ‰å†…å­˜åˆ†é…è·¯å¾„ï¼Œå› æ­¤å½“å‰çš„è®°è´¦æœºåˆ¶å®¹æ˜“å‡ºé”™ã€‚ 12345678910111213141516171819202122232425262728293031struct mem_cgroup&#123; ... struct page_counter memory;/*Both v1 &amp; v2*/ union&#123; struct page_counter swap;/*v2 only */ struct page_counter memsw;/*v1 only*/ &#125;; /*Legacy consumer-oriented counters*/ struct page_counter kmem;/*v1 only*/ struct page_counter tcpmem;/*v1 only*/ ...&#125;struct page_counter&#123; atomic_long_t usage; ... unsigned long max; ...&#125;bool page_counter_try_charge(struct page_counter *counter,unsigned long nr pages,...)&#123; struct page_counter *c; ... new = atomic_long_add_return(nr_pages, &amp;c-&gt;usage);if(new&gt;c-&gt;max)&#123; ... goto failed;&#125;&#125; Container Runtimes and PlatformsMemcgå¯ä»¥è®°å½•å’Œé™åˆ¶æ¯ä¸ªè¿›ç¨‹çº§åˆ«çš„å†…å­˜ä½¿ç”¨æƒ…å†µã€‚ä¸åŸºäºè™šæ‹Ÿæœº(VM)çš„å†…å­˜æ§åˆ¶æŠ€æœ¯ç›¸æ¯”ï¼Œmemcgç²’åº¦æ›´ç»†ã€æ›´è½»ã€æ›´çµæ´»ã€‚å› æ­¤ï¼Œmemcgå·²ç»è¢«Dockerã€CaaS (container -as- service)å’ŒFaaS (function -as- service)å¹³å°å¹¿æ³›é‡‡ç”¨ã€‚å…·ä½“æ¥è¯´ï¼ŒCaaSå¹³å°ä¸ºç”¨æˆ·æä¾›äº†å·²é…ç½®çš„å®¹å™¨å®ä¾‹ã€‚CaaSå¹³å°ä¸Šçš„ç”¨æˆ·å¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰çš„å®¹å™¨æ˜ åƒåˆ›å»º&#x2F;å¯åŠ¨&#x2F;åœæ­¢&#x2F;åˆ é™¤å®¹å™¨ã€‚å¦ä¸€æ–¹é¢ï¼ŒFaaSå¹³å°ä¸å‘ç”¨æˆ·æä¾›å®¹å™¨å®ä¾‹ï¼Œè€Œæ˜¯å…è®¸ç”¨æˆ·è¾“å…¥å‡½æ•°å’Œè§¦å‘è§„åˆ™ï¼Œå¹¶è‡ªåŠ¨åˆ›å»ºå®¹å™¨å®ä¾‹æ¥æ‰§è¡Œè¾“å…¥å‡½æ•°ã€‚ Dockerå’ŒCaaS&#x2F;FaaSå¹³å°é€šå¸¸ä¸ºå®¹å™¨å®ä¾‹ä½¿ç”¨æœ¬åœ°å®¹å™¨è¿è¡Œæ—¶(å³runC)ã€‚ä¸ºäº†æé«˜å®¹å™¨ä¹‹é—´çš„éš”ç¦»æ€§ï¼Œäººä»¬æå‡ºäº†å®‰å…¨å®¹å™¨è¿è¡Œæ—¶ï¼Œå¦‚gVisorå’ŒKataå®¹å™¨ã€‚gVisoræ˜¯è°·æ­Œå¼€å‘çš„æ²™ç›’å®¹å™¨è¿è¡Œæ—¶ã€‚å®ƒåœ¨ä¸€ä¸ªåä¸ºSentryçš„ç”¨æˆ·ç©ºé—´å†…æ ¸ä¸Šè¿è¡Œæ¯ä¸ªå®¹å™¨ã€‚Sentryæ‹¦æˆªå¹¶å¤„ç†æ¥è‡ªå®¹å™¨çš„å¤§å¤šæ•°ç³»ç»Ÿè°ƒç”¨ã€‚å› æ­¤ï¼ŒSentryå‡å°‘äº†ä»å®¹å™¨åœ¨ä¸»æœºå†…æ ¸ä¸Šè°ƒç”¨çš„ç³»ç»Ÿè°ƒç”¨ã€‚é™¤äº†æ²™ç›’è¿è¡Œæ—¶ï¼Œå®¹å™¨ç¤¾åŒºè¿˜å»ºè®®ä½¿ç”¨è™šæ‹ŸåŒ–æ¥éš”ç¦»å®¹å™¨å®ä¾‹ã€‚å…¶ä¸­ä¸€ä¸ªè¿™æ ·çš„è™šæ‹ŸåŒ–å®¹å™¨è¿è¡Œæ—¶æ˜¯Kataå®¹å™¨ï¼Œå…¶ä¸­æ¯ä¸ªå®¹å™¨å®ä¾‹éƒ½åœ¨å¾®å‹è™šæ‹Ÿæœºä¸­è¿è¡Œï¼Œä»¥å®ç°å¼ºéš”ç¦»ã€‚ æˆ‘ä»¬çš„å®éªŒè¡¨æ˜ï¼Œæ­£å¸¸å’Œå®‰å…¨çš„å®¹å™¨è¿è¡Œæ—¶(åŒ…æ‹¬runCå’ŒKataå®¹å™¨)éƒ½å®¹æ˜“å—åˆ°ç”±è®°è´¦ä¸¢å¤±é”™è¯¯å¼•èµ·çš„å†…å­˜è€—å°½æ”»å‡»ã€‚æ­¤å¤–ï¼Œå†…å­˜è®°è´¦ä¸¢å¤±æ¼æ´å¯ä»¥è¢«åˆ©ç”¨æ¥æ”»å‡»Dockerã€CaaSå’ŒFaaSå¹³å°ï¼Œå¯¼è‡´å†…å­˜è€—å°½ï¼Œä»è€Œå¯¼è‡´å•ä¸ªèŠ‚ç‚¹ç”šè‡³æ•´ä¸ªé›†ç¾¤å´©æºƒã€‚ A STUDY OF EXPLOITABLITY AND IMPACTç”Ÿäº§ç¯å¢ƒä¸­å†…å­˜æœªè®°å½•é”™è¯¯çš„å½±å“ä»æœªè¢«ç³»ç»Ÿåœ°ç ”ç©¶è¿‡ã€‚å®ƒä»¬é€šå¸¸è¢«è§†ä¸ºä¸€ä¸ªè¾ƒå°çš„æ­£ç¡®æ€§é—®é¢˜ï¼Œè€Œä¸æ˜¯å®‰å…¨é—®é¢˜ã€‚åœ¨è¿™ä¸€éƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å†…å­˜æœªè®°å½•é”™è¯¯å¯ä»¥è¢«åˆ©ç”¨æ¥å¯¼è‡´å®¹å™¨ä¸»æœºç”šè‡³æ•´ä¸ªäº‘å¹³å°çš„å†…å­˜è€—å°½ã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬åˆ†æäº†å†…å­˜è®°è´¦é—®é¢˜çš„å¯åˆ©ç”¨æ€§ï¼Œä»¥äº†è§£å…¶å¯¹å®¹å™¨å¹³å°çš„å®é™…å½±å“ã€‚æˆ‘ä»¬è®¾è®¡äº†æ–°çš„æ”»å‡»æ–¹æ³•æ¥åˆ©ç”¨æœªè®°å½•é”™è¯¯ã€‚è¿™äº›æ”»å‡»è¡¨æ˜ï¼Œè¿™äº›é”™è¯¯å¯ç”¨äºæ”»å‡»æ™®é€šå’Œå®‰å…¨çš„å®¹å™¨è¿è¡Œæ—¶ã€‚å› æ­¤ï¼Œå®ƒä»¬å¯è¢«åˆ©ç”¨åœ¨çƒ­é—¨çš„CaaSå’ŒFaaSå®¹å™¨å¹³å°ä¸Šé€ æˆDoSï¼ˆä¸»æœºæœºå™¨å´©æºƒï¼‰å’Œè´¢åŠ¡è´¹ç”¨é—®é¢˜ã€‚åœ¨ä»¥ä¸‹å†…å®¹ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆè®¨è®ºå¨èƒæ¨¡å‹å’Œå‡è®¾ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¯¦ç»†ä»‹ç»å¦‚ä½•åˆ©ç”¨å†…å­˜æœªè®°å½•é—®é¢˜ã€‚ Threat Model and Assumptionsåœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæˆ‘ä»¬ç ”ç©¶äº†ä¸‰ä¸ªå®¹å™¨å¹³å° - Dockerã€å®¹å™¨å³æœåŠ¡ï¼ˆCaaSï¼‰å¹³å°å’Œå‡½æ•°å³æœåŠ¡ï¼ˆFaaSï¼‰å¹³å°ã€‚æˆ‘ä»¬ä½¿ç”¨å¹¿æ³›éƒ¨ç½²çš„CaaSå¹³å° - OpenShiftä½œä¸ºæˆ‘ä»¬çš„CaaSå¹³å°ï¼Œä»¥åŠæµè¡Œçš„OpenWhiskä½œä¸ºæˆ‘ä»¬çš„FaaSå¹³å°ã€‚è¿™ä¸‰ä¸ªå¹³å°ä½¿ç”¨æœ¬åœ°è¿è¡Œæ—¶ï¼ˆå³runCï¼‰ä½œä¸ºå®ƒä»¬çš„å®¹å™¨è¿è¡Œæ—¶ã€‚è¿™ä¸‰ä¸ªå¹³å°ä¸Šçš„æ‰€æœ‰å®¹å™¨éƒ½ä»¥éç‰¹æƒæ–¹å¼è®¾ç½®ä¸ºå…·æœ‰é»˜è®¤åŠŸèƒ½å’Œseccompé…ç½®ã€‚å¯¹äºDockerå’ŒCaaSå¹³å°ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡äº‘æä¾›çš„æ¥å£åˆ›å»ºå’Œå¯åŠ¨å¸¦æœ‰è‡ªå®šä¹‰æ˜ åƒçš„å®¹å™¨ã€‚è¿™æ˜¯åˆç†çš„ï¼Œå› ä¸ºåŒ…æ‹¬AWSã€Google Cloudå’ŒAzureåœ¨å†…çš„æ‰€æœ‰äº‘ä¾›åº”å•†éƒ½ä¸ºç”¨æˆ·æä¾›äº†ä¸€ä¸ªæ§åˆ¶å°æ¥ç®¡ç†å®¹å™¨å®ä¾‹ã€‚å¯¹äºFaaSå¹³å°ï¼Œç”¨æˆ·å¯ä»¥å®šä¹‰ã€éƒ¨ç½²å’Œè§¦å‘å‡½æ•°ï¼Œå…¶ä¸­æ¯ä¸ªå‡½æ•°å®ä¾‹éƒ½åœ¨ä¸€ä¸ªå®¹å™¨ä¸­è¿è¡Œã€‚ æ”»å‡»è€…æ˜¯ä½¿ç”¨Dockerã€CaaSå’ŒFaaSå¹³å°çš„æ¶æ„ç”¨æˆ·ã€‚ä»–&#x2F;å¥¹å¯ä»¥åœ¨éç‰¹æƒå®¹å™¨å†…æ‰§è¡Œä»»æ„ä»£ç ã€‚ç„¶è€Œï¼Œå®¹å™¨çš„åŠŸèƒ½å—åˆ°é»˜è®¤åŠŸèƒ½çš„é™åˆ¶ã€‚ä¸ºäº†è¿›ä¸€æ­¥é™åˆ¶æ”»å‡»è€…ï¼Œæˆ‘ä»¬å‡è®¾æ”»å‡»è€…æ— æ³•ä»å®¹å™¨ä¸­é€ƒé€¸ï¼Œä¹Ÿæ— æ³•æå‡ä»–ä»¬çš„æƒé™ã€‚æ”»å‡»è€…çš„ç›®æ ‡æ˜¯ç ´åå†…å­˜è®¡ç®—çš„é™åˆ¶ï¼Œå¹¶è€—å°½ä¸»æœºä¸Šçš„æ‰€æœ‰å†…å­˜ï¼Œä»¥ä½¿å…¶ä»–å®¹å™¨ã€å‡½æ•°æˆ–ä¸»æœºå´©æºƒã€‚ å¯¹äºæ”»å‡»ç¯å¢ƒï¼Œæˆ‘ä»¬åœ¨æœ¬åœ°æœºå™¨ä¸Šè®¾ç½®Dockerï¼ŒåŒæ—¶åœ¨Google Cloudä¸Šè®¾ç½®OpenShiftå’ŒOpenWhiské›†ç¾¤ã€‚å‡ºäºé“å¾·è€ƒè™‘ï¼Œè¯¥é›†ç¾¤æ„å»ºåœ¨ä¸€ä¸ªç”±Google Cloudæä¾›çš„ä¸“ç”¨è£¸é‡‘å±æœåŠ¡å™¨ä¸Šï¼Œä»…ä¾›æˆ‘ä»¬ä½¿ç”¨ï¼Œå› æ­¤ä¸ä¼šå½±å“å…¶ä»–ç”¨æˆ·ã€‚ Exploit Missing-Account Problemåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†è®¾è®¡æ–°çš„æ”»å‡»æ¥åˆ©ç”¨å†…å­˜è®°å¸ä¸­çš„è®°è´¦é—®é¢˜ï¼Œä»¥äº†è§£å…¶å½±å“ã€‚å¦‚å‰æ‰€è¿°ï¼ŒLinuxå†…æ ¸ä¸­çš„å½“å‰å†…å­˜è®°å¸å°†å†…å­˜è®°å¸æ¥å£æ”¾åœ¨å†…å­˜åˆ†é…è·¯å¾„ä¸Šï¼Œå°†å†…å­˜å–æ¶ˆè®°å¸æ¥å£æ”¾åœ¨å†…å­˜ç©ºé—²è·¯å¾„ä¸Šã€‚ç„¶è€Œï¼ŒLinuxå†…å­˜ç®¡ç†æ˜¯å¤æ‚çš„ï¼ŒåŒ…å«æ•°åƒä¸ªå†…å­˜åˆ†é…å’Œè‡ªç”±è·¯å¾„ã€‚å¾ˆéš¾ç”¨æ­£ç¡®çš„æ¥å£æ¥è°ƒè§£æ‰€æœ‰è¿™äº›é—®é¢˜ã€‚ç‰¹åˆ«æ˜¯ï¼Œå¾ˆå®¹æ˜“é—æ¼ä¸€ä¸ªå†…å­˜åˆ†é…è·¯å¾„ï¼Œä»è€Œå¯¼è‡´ä¸¢å¤±å¸æˆ·é—®é¢˜ã€‚ æ˜¾ç¤ºäº†å†…æ ¸ä¸­ä¿¡å·é‡å¯¹è±¡å’Œä¿¡å·é‡æ•°ç»„ä¸Šçš„è®°è´¦ä¸¢å¤±é”™è¯¯ï¼Œç”±MANTAæ£€æµ‹å¹¶ç”±Linuxå¼€å‘äººå‘˜ç¡®è®¤ã€‚å‡½æ•°sem_allocåˆ†é…ä¸€ç»„ä¿¡å·é‡ï¼Œå¹¶ä½¿ç”¨sem_arrayå¯¹å®ƒä»¬è¿›è¡Œç´¢å¼•ã€‚ç¬¬8è¡Œçš„åˆ†é…ç«™ç‚¹è°ƒç”¨kvzallocä¸ºsem_arrayå’Œä¿¡å·é‡åˆ†é…å†…å­˜ã€‚å½“åœ¨kvzallocçš„ç¬¬ä¸‰ä¸ªå‚æ•°ä¸­è®¾ç½®äº†__GFP_ACCOUNTæ ‡å¿—æ—¶ï¼Œå†…æ ¸åªä¼šè€ƒè™‘åˆ†é…çš„å†…å­˜ã€‚ç„¶è€Œï¼Œåœ¨ç¬¬8è¡Œå¯¹kvzallocçš„è°ƒç”¨æ²¡æœ‰æŒ‡å®š__GFP_ACCOUNTæ ‡å¿—ï¼Œå¯¼è‡´åœ¨åˆ†é…çš„ä¿¡å·é‡å’Œsem_arrayä¸Šä¸¢å¤±å¸æˆ·ã€‚æ­¤å¤–ï¼Œsem_allocç”±semgetç³»ç»Ÿè°ƒç”¨è°ƒç”¨æ¥åˆ†é…ä¿¡å·é‡ã€‚å› æ­¤ï¼Œè¿™ä¸ªè®°è´¦ä¸¢å¤±çš„é”™è¯¯å¾ˆå®¹æ˜“ä»ç”¨æˆ·ç©ºé—´è§¦å‘ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥è®¾è®¡äº†æ–°çš„æ”»å‡»ï¼Œä»¥è¡¨æ˜ä¸Šè¿°æ¼æ´å¯ä»¥è¢«åˆ©ç”¨æ¥æ‰“ç ´å®¹å™¨å†…å­˜é™åˆ¶å¹¶è€—å°½æ‰€æœ‰ä¸»æœºå†…å­˜ã€‚ 12345678910111213static struct sem_array *sem_alloc(size_t nsems)&#123; struct sem_array *sma; if(nsems &gt; (INT_MAX - sizeof(*sma)) / sizeof(sma-&gt;sems[0])) return NULL; sma = kvzalloc(struct_size(sma, sems, nsems),GFP_KERNEL); if(unlikerly(!sma)) return NULL; return sma;&#125; Attacking Dockeræˆ‘ä»¬ç”¨é»˜è®¤çš„åŠŸèƒ½å’Œseccompé…ç½®æ¥è®¾ç½®Dockerã€‚semgetç³»ç»Ÿè°ƒç”¨ä¸éœ€è¦ä»»ä½•åŠŸèƒ½ï¼Œä¹Ÿä¸ä¼šè¢«å®¹å™¨seccompé…ç½®æ–‡ä»¶é˜»å¡ã€‚å› æ­¤ï¼Œåœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæ”»å‡»ç¨‹åºåœ¨éç‰¹æƒå®¹å™¨ä¸­å¯ä»¥åå¤è§¦å‘semgetç³»ç»Ÿè°ƒç”¨ï¼Œä»è€Œæ‰“ç ´å†…å­˜è®°å¸é™åˆ¶ï¼Œè€—å°½æ‰€æœ‰ä¸»æœºå†…å­˜ã€‚ä¸»æœºç”šè‡³ä¼šå› ä¸ºå†…å­˜ä¸è¶³é”™è¯¯è€Œå´©æºƒã€‚æˆ‘ä»¬å‘Linuxç¤¾åŒºæŠ¥å‘Šäº†ä¸Šè¿°é”™è¯¯å¹¶æäº¤äº†è¡¥ä¸ã€‚è¡¥ä¸å·²ç»è¢«åˆå¹¶åˆ°Linuxä¸»çº¿ä¸Šï¼Œä¸€ä¸ªæ–°çš„CVEå·²ç»åˆ†é…ç»™æˆ‘ä»¬äº†ã€‚ Attacking the CaaS Platformæˆ‘ä»¬åœ¨Google Cloudä¸Šæ­å»ºäº†ä¸€ä¸ªè‡ªç®¡ç†çš„OpenShifté›†ç¾¤ï¼Œè¿è¡Œæ‰€æœ‰çš„GCPè™šæ‹Ÿæœºå®ä¾‹ã€‚è¯¥é›†ç¾¤å…è®¸ç”¨æˆ·åœ¨ä¸€ä¸ªå…·æœ‰15GBå†…å­˜å’ŒLinuxå†…æ ¸v5.14.14çš„èŠ‚ç‚¹ä¸Šåˆ›å»ºå®¹å™¨ã€‚æˆ‘ä»¬å°†å®¹å™¨çš„å†…å­˜é™åˆ¶è®¾ç½®ä¸º128MBï¼Œè¿™æ˜¯å…¬å…±äº‘ä¸­å¸¸ç”¨çš„å†…å­˜å¤§å°ã€‚ ä¸ºäº†å‘èµ·æ”»å‡»ï¼Œæ¶æ„ç”¨æˆ·ä»¥æ™®é€šç”¨æˆ·æƒé™åˆ›å»ºä¸€ä¸ªå®¹å™¨ï¼Œå¹¶åœ¨å®¹å™¨å†…åˆ†é…å¤§é‡ä¿¡å·é‡ã€‚æ¶æ„å®¹å™¨çš„å†…å­˜ä½¿ç”¨é‡è¿…é€Ÿå¢åŠ ï¼Œå¤§çº¦åœ¨20ç§’å†…è¾¾åˆ°èŠ‚ç‚¹çš„æé™ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæ”»å‡»è€…çš„è®¡è´¹å†…å­˜ä½¿ç”¨é‡éå¸¸ä½ï¼Œä¸åˆ°1.4MBã€‚ç»“æœï¼Œæ¶æ„å®¹å™¨æ‰“ç ´äº†128MBçš„å†…å­˜é™åˆ¶ï¼Œæ¶ˆè€—äº†ä¸»æœºä¸Šçš„å…¨éƒ¨15GBå†…å­˜ã€‚åŒä¸€èŠ‚ç‚¹ä¸Šçš„å—å®³è€…å®¹å™¨ç”±äºå†…å­˜ä¸è¶³æ— æ³•æ‰§è¡Œä»»ä½•æ“ä½œã€‚ Attacking the FaaS Platformæˆ‘ä»¬è¯„ä¼°äº†å¯¹OpenWhiskçš„æ”»å‡»ï¼ŒOpenWhiskæ˜¯ä¸€ä¸ªæµè¡Œçš„å¼€æºFaaSå¹³å°ï¼Œä½œä¸ºIBM Cloud Functionsçš„åŸºç¡€è®¾æ–½ã€‚é›†ç¾¤èŠ‚ç‚¹å†…å­˜ä¸º15GBï¼Œè¿è¡ŒLinuxå†…æ ¸v5.11.0-1021-gcpã€‚æ¯ä¸ªåŠŸèƒ½çš„å†…å­˜é™åˆ¶è®¾ç½®ä¸º128MBã€‚ ä¸ºäº†å‘èµ·æ”»å‡»ï¼Œæ¶æ„ç”¨æˆ·åˆ›å»ºäº†ä¸€ä¸ªåå¤æ¶ˆè€—ä¿¡å·é‡çš„å‡½æ•°ã€‚ç„¶åï¼Œæ¶æ„ç”¨æˆ·åå¤è§¦å‘æ¶æ„åŠŸèƒ½ã€‚å¯¼è‡´èŠ‚ç‚¹ä¸Šçš„å†…å­˜å¾ˆå¿«è€—å°½ã€‚æ³¨æ„ï¼Œå½“ä¸€ä¸ªèŠ‚ç‚¹çš„å†…å­˜è€—å°½æ—¶ï¼Œè¿ç»­çš„æ¶æ„å‡½æ•°å°†è¢«åˆ†æ´¾åˆ°å…¶ä»–èŠ‚ç‚¹ã€‚å¯¼è‡´é›†ç¾¤å†…æ‰€æœ‰èŠ‚ç‚¹çš„å†…å­˜è¢«æ¶æ„ç”¨æˆ·è€—å°½ï¼Œå¯¼è‡´é›†ç¾¤çº§DoSã€‚ Attacking the Secure Runtimeæˆ‘ä»¬è¿›ä¸€æ­¥è®¾è®¡æ–°çš„æ”»å‡»æ¥è¯„ä¼°å†…å­˜è®°è´¦ä¸¢å¤±å¯¹å®‰å…¨è¿è¡Œæ—¶- Kataå®¹å™¨çš„å½±å“ã€‚æˆ‘ä»¬çš„å®éªŒè¡¨æ˜ï¼Œå†…å­˜è®°è´¦ä¸¢å¤±æ¼æ´å…è®¸æ”»å‡»è€…æ‰“ç ´Kataå®¹å™¨çš„éš”ç¦»å¹¶æ”»å‡»ä¸»æœºå’Œå…¶ä»–å®¹å™¨å®ä¾‹ã€‚ Kataå®¹å™¨æ˜¯ä¸€ç§è™šæ‹Ÿå®¹å™¨è¿è¡Œæ—¶ï¼Œå…¶ä¸­æ¯ä¸ªå®¹å™¨å®ä¾‹åœ¨å¾®è™šæ‹Ÿæœºä¸­è¿è¡Œï¼Œä»¥å®ç°å¼ºéš”ç¦»ã€‚ä½†æ˜¯ï¼ŒKata micro-VMå°†æ–‡ä»¶æ“ä½œè½¬å‘ç»™ä¸»æœºï¼Œè¿™ä½¿å¾—å®ƒå®¹æ˜“å—åˆ°åŸºäºå†…å­˜è®°è´¦ä¸¢å¤±çš„æ”»å‡»ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œé€šè¿‡åˆ©ç”¨å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ï¼Œæ”»å‡»è€…å¯ä»¥è€—å°½å¾®å‹è™šæ‹Ÿæœºä¸­Kataå®¹å™¨çš„ä¸»æœºå†…å­˜ã€‚å¦‚å›¾æ‰€ç¤ºï¼Œæ¶æ„ç”¨æˆ·æ˜¯å®¹å™¨ä¸­çš„æ™®é€šç”¨æˆ·ï¼Œå¹¶å‘å‡ºfcntlç³»ç»Ÿè°ƒç”¨ï¼Œä¸ºä¸€ç»„æ–‡ä»¶åˆ†é…å¤§é‡POSIXé”ã€‚ä½†æ˜¯ï¼Œå®¢æˆ·æœºå†…æ ¸å°†è¯·æ±‚è½¬å‘ç»™è¿è¡Œåœ¨ä¸»æœºä¸Šçš„virtio-fsdå®ˆæŠ¤è¿›ç¨‹ã€‚ å› æ­¤ï¼Œå®ˆæŠ¤è¿›ç¨‹åœ¨ä¸»æœºå†…æ ¸ä¸­åˆ†é…äº† POSIX é”ã€‚å°½ç®¡ virtio-fsd å®ˆæŠ¤è¿›ç¨‹çš„å†…å­˜ä½¿ç”¨å—åˆ° memcgï¼ˆå†…å­˜æ§åˆ¶ç»„ï¼‰çš„é™åˆ¶ï¼Œä½†é”å¯¹è±¡æ‰€ä½¿ç”¨çš„å†…å­˜æ²¡æœ‰è¢«çº³å…¥ç»Ÿè®¡ã€‚å› æ­¤ï¼Œæ¶æ„å®¹å™¨å¯ä»¥è€—å°½ä¸»æœºä¸Šçš„æ‰€æœ‰ç‰©ç†å†…å­˜ã€‚æˆ‘ä»¬å‘ Kata å®¹å™¨ç¤¾åŒºæŠ¥å‘Šäº†è¿™ç§æ”»å‡»ã€‚ä»–ä»¬ç¡®è®¤äº†è¿™ä¸ªé—®é¢˜ï¼Œå¹¶ä¸ºæˆ‘ä»¬ç”³è¯·äº†ä¸€ä¸ªæ–°çš„ CVEï¼ˆå…¬å¼€æŠ«éœ²çš„è®¡ç®—æœºå®‰å…¨æ¼æ´å’Œæ¼æ´ï¼‰ã€‚ ç”¨é€šä¿—çš„è¯­è¨€æ¥è¯´ï¼Œè¿™æ®µè¯æè¿°äº†ä¸€ä¸ªå®‰å…¨é—®é¢˜ï¼Œå…¶ä¸­ï¼Œè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿç®¡ç†çš„å®ˆæŠ¤ç¨‹åºåœ¨ä¸»æœºæ“ä½œç³»ç»Ÿä¸Šåˆ†é…äº†ä¸€ç§åä¸º POSIX é”çš„èµ„æºã€‚è™½ç„¶è¿™ä¸ªå®ˆæŠ¤ç¨‹åºçš„å†…å­˜ä½¿ç”¨å—åˆ°é™åˆ¶ï¼Œä½†é”å¯¹è±¡å ç”¨çš„å†…å­˜æ²¡æœ‰è¢«è®¡ç®—åœ¨å†…ã€‚è¿™æ„å‘³ç€ä¸€ä¸ªæ¶æ„çš„å®¹å™¨ï¼ˆä¸€ç§è½»é‡çº§çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼‰å¯ä»¥åˆ©ç”¨è¿™ä¸ªé—®é¢˜è€—å°½ä¸»æœºçš„ç‰©ç†å†…å­˜ã€‚ä½œè€…æŠ¥å‘Šäº†è¿™ä¸ªé—®é¢˜ï¼Œå¹¶ä¸” Kata å®¹å™¨ç¤¾åŒºå·²ç»ç¡®è®¤è¯¥é—®é¢˜ï¼Œå¹¶æ­£ç”³è¯·ä¸€ä¸ªæ–°çš„å®‰å…¨æ¼æ´ç¼–å·ï¼ˆCVEï¼‰ã€‚ Discussionæ­£å¦‚ä¸Šè¿°æ”»å‡»æ‰€è¯æ˜çš„é‚£æ ·ï¼Œå¯ä»¥åˆ©ç”¨è®°è´¦ä¸¢å¤±æ¼æ´æ”»å‡»æ­£å¸¸å’Œå®‰å…¨çš„å®¹å™¨è¿è¡Œæ—¶ã€Dockerå’ŒCaaS&#x2F;FaaSå¹³å°ã€‚æ”»å‡»è€…å¯ä»¥åˆ©ç”¨è¿™äº›æ¼æ´è€—å°½æ‰€æœ‰å†…å­˜ï¼Œä½¿å®¹å™¨èŠ‚ç‚¹ç”šè‡³æ•´ä¸ªé›†ç¾¤å´©æºƒã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œæ”»å‡»åªéœ€è¦æ™®é€šç”¨æˆ·æƒé™ï¼Œå› æ­¤å¾ˆå®¹æ˜“å¯åŠ¨ã€‚è™½ç„¶å†…å­˜ä¸¢å¤±å¸æˆ·æ¼æ´å¯ä»¥è¢«åˆ©ç”¨æ¥æ”»å‡»å®¹å™¨å¹³å°ï¼Œä½†ç›®å‰è¿˜æ²¡æœ‰ç³»ç»Ÿçš„ç ”ç©¶æ¥æ£€æµ‹å’Œæ¶ˆé™¤è¿™äº›æ¼æ´ã€‚å› æ­¤ï¼Œæœ¬æ–‡æå‡ºäº†ç¬¬ä¸€ä¸ªå†…å­˜è®°è´¦åˆ†æå·¥å…·MANTAï¼Œæ¥ç³»ç»Ÿåœ°æ£€æµ‹è¿™äº›é—®é¢˜ã€‚ MISSING-ACCOUNT BUG DETECTIONè€ƒè™‘åˆ°å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯çš„ä¸¥é‡æ€§ï¼Œåœ¨æ“ä½œç³»ç»Ÿå†…æ ¸å®é™…åœ¨ç”Ÿäº§åœºæ™¯ä¸­è¿è¡Œä¹‹å‰çš„æ—©æœŸé˜¶æ®µæ£€æµ‹è¿™äº›é—®é¢˜éå¸¸é‡è¦ã€‚ä¸å¹¸çš„æ˜¯ï¼Œæ²¡æœ‰ä¸€ç§å·¥å…·å¯ä»¥åŒæ—¶æ£€æµ‹é«˜ä»£ç è¦†ç›–ç‡å’Œé«˜ç²¾åº¦çš„é—æ¼å¸æˆ·é”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æå‡ºäº†MANTA(Memory AccouNTing Analyzerçš„ç¼©å†™)æ¥è‡ªåŠ¨æ£€æµ‹å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ã€‚ Design goals MANTAæ—¨åœ¨é€šè¿‡åˆ†æè®°å¸æ¥å£æ”¾ç½®çš„æ­£ç¡®æ€§æ¥è‡ªåŠ¨ã€ç³»ç»Ÿåœ°æ£€æµ‹å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ã€‚å…·ä½“æ¥è¯´ï¼ŒMANTAéœ€è¦æ£€æµ‹å…·æœ‰é«˜ä»£ç è¦†ç›–ç‡çš„å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ã€‚ ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼ŒMANTAåˆ©ç”¨é™æ€åˆ†ææ¥éå†Linuxå†…æ ¸ä¸­çš„æ‰€æœ‰å†…å­˜åˆ†é…&#x2F;è‡ªç”±è·¯å¾„ã€‚æ­¤å¤–ï¼ŒMANTAéœ€è¦é«˜ç²¾åº¦åœ°æ£€æµ‹æ¼æ´ã€‚å› æ­¤ï¼ŒMANTAä½¿ç”¨åŠ¨æ€éªŒè¯æ¥æµ‹è¯•æ£€æµ‹åˆ°çš„é”™è¯¯çš„åŠ¨æ€è§¦å‘æ€§ã€‚ Challenges ä¸ºäº†å®ç°è¿™ä¸¤ä¸ªç›®æ ‡ï¼ŒMANTAéœ€è¦å…‹æœä»¥ä¸‹æŒ‘æˆ˜ã€‚ C1. MANTAéœ€è¦è¯†åˆ«å†…å­˜è®°å¸æ¥å£ï¼Œè¿™äº›æ¥å£åœ¨å†…æ ¸æ–‡æ¡£ä¸­æ²¡æœ‰æè¿°ï¼Œä»¥å‰çš„å·¥ä½œä¹Ÿæ²¡æœ‰ç ”ç©¶è¿‡ã€‚ç°æœ‰çš„ç”¨äºå†…å­˜åˆ†é…çš„æ¥å£è¯†åˆ«æ–¹æ³•ä¸èƒ½åº”ç”¨ï¼Œå› ä¸ºå®ƒä»¬çš„å¯å‘å¼æ–¹æ³•ä¸é€‚ç”¨äºå†…å­˜è®¡è´¹æ¥å£ C2. MANTAéœ€è¦å†³å®šæ¯ä¸ªå†…å­˜åˆ†é…æ˜¯å¦è¢«è€ƒè™‘å¹¶ä¸”åªè€ƒè™‘ä¸€æ¬¡ã€‚ç„¶è€Œï¼Œåœ¨Linuxå†…æ ¸ä¸­ï¼Œä»å†…å­˜åˆ†é…ç«™ç‚¹åˆ°å†…å­˜è®°å¸ç«™ç‚¹çš„æ‰§è¡Œè·¯å¾„å¾€å¾€æ˜¯æ·±çš„ã€åµŒå¥—çš„å’Œäº¤é”™çš„ã€‚æ­¤å¤–ï¼Œå³ä½¿å­˜åœ¨è¿™æ ·çš„è·¯å¾„ï¼Œè®°å¸ä¹Ÿå¯èƒ½å—åˆ°æ¡ä»¶æ ‡å¿—çš„å½±å“ï¼Œå› ä¸ºè®°å¸åŒæ—¶éœ€è¦è®°å¸æ¥å£å’Œè®°å¸æ ‡å¿—Â§2 Analysis techniques and workflow MANTAçš„ä½“ç³»ç»“æ„å¦‚å›¾æ‰€ç¤ºã€‚ä»¥æ•´ä¸ªå†…æ ¸IRä½œä¸ºè¾“å…¥ï¼ŒMANTAé¦–å…ˆç”Ÿæˆå†…æ ¸è°ƒç”¨å›¾ã€‚ç„¶åï¼Œå®ƒä½¿ç”¨åŸºäºé¡µé¢è®¡æ•°å™¨çš„æ–¹æ³•æ¥è¯†åˆ«æ‰€æœ‰ä¼šè®¡æ¥å£ä»¥åœ°å€C1(Â§4.1)ã€‚åŸºäºè®°å¸æ¥å£ï¼ŒMANTAå»ºç«‹äº†å†…å­˜åˆ†é…&#x2F;é‡Šæ”¾å’Œå†…å­˜è®°å¸ä¹‹é—´çš„æ˜ å°„(Â§4.2)ã€‚ ä¹‹åï¼ŒMANTAä½¿ç”¨è®°å¸æ ‡å¿—åˆ†ææ¥è¿›ä¸€æ­¥åˆ†æå†…æ ¸å†…å­˜è®°å¸(Â§4.3)ã€‚è¿™ä¸¤ç§æŠ€æœ¯å¤„ç†C2ã€‚éšç€æ£€æµ‹åˆ°çš„å†…å­˜è®°è´¦é”™è¯¯ï¼ŒMANTAè¿›ä¸€æ­¥è¯„ä¼°æ¯ä¸ªé”™è¯¯ä¸æˆ‘ä»¬çš„åŠ¨æ€è§¦å‘æ€§åˆ†æåŸºäºæ•°åƒä¸ªæµ‹è¯•ç”¨ä¾‹ä»Linuxæµ‹è¯•é¡¹ç›®(Â§4.4)ã€‚MANTAç›®å‰æ˜¯ä¸ºLinuxå†…å­˜è®°è´¦å®ç°çš„ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬å°†è¯¦ç»†ä»‹ç»æ¯ç§åˆ†ææŠ€æœ¯ã€‚ Counter-based Interface IdentificationMANTAé¦–å…ˆéœ€è¦è¯†åˆ«å†…å­˜è®°è´¦æ¥å£ã€‚ è¿™äº›æ¥å£æ˜¯å¤šç§å¤šæ ·çš„ï¼Œå¹¶ä¸”å¯ä»¥è‡ªå®šä¹‰ã€‚ä½¿ç”¨è‡ªç„¶è¯­è¨€å¤„ç†(NLP)æˆ–åŒ…è£…å‡½æ•°åˆ†æçš„ç°æœ‰æŠ€æœ¯å­˜åœ¨ç²¾åº¦é—®é¢˜ã€‚æˆ‘ä»¬æ³¨æ„åˆ°å†…å­˜è®°å¸å¿…é¡»ç»´æŠ¤å†…å­˜ä½¿ç”¨è®¡æ•°å™¨(å³page_counter)ï¼Œè¿™äº›è®¡æ•°å™¨æ˜¯é€šè¿‡ç‰¹å®šçš„åŸå­å‡½æ•°æ“ä½œçš„ã€‚ä½¿ç”¨ç±»å‹åŒ¹é…å¯ä»¥å¾ˆå®¹æ˜“åœ°æ‰¾åˆ°å†…å­˜ä½¿ç”¨è®¡æ•°å™¨ã€‚å› æ­¤ï¼Œé€šè¿‡è¯†åˆ«ç”¨äºå¢åŠ &#x2F;å‡å°‘è¿™äº›è®¡æ•°å™¨çš„åŸºæœ¬å‡½æ•°ï¼ŒMANTAå¯ä»¥è‡ªåŠ¨æ‰¾å‡ºå¯¹ä¼šè®¡è®¡æ•°å™¨æ‰§è¡Œå¢åŠ &#x2F;å‡å°‘æ“ä½œçš„æ‰€æœ‰å‡½æ•°ã€‚ å…·ä½“æ¥è¯´ï¼ŒMANTAéå†æ¯ä¸ªå†…æ ¸IRæŒ‡ä»¤å¹¶æ£€æŸ¥å®ƒæ˜¯å¦å¢åŠ &#x2F;å‡å°‘page_counterã€‚å¦‚æœæ˜¯è¿™æ ·ï¼Œåˆ™MANTAå°†ç›´æ¥åŒ…å«è¯¥æŒ‡ä»¤çš„å‡½æ•°æ ‡è®°ä¸ºåŸºæœ¬ä¼šè®¡å‡½æ•°ã€‚ç”±äºåœ¨Linuxå†…æ ¸ä¸­ï¼Œpage_counterä»…ç”±memcgä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬çš„æ–¹æ³•å¯ä»¥è¾¾åˆ°è¾ƒé«˜çš„ç²¾åº¦ã€‚ ç„¶åï¼ŒMANTAæ ¹æ®åŸºæœ¬çš„è®°è´¦åŠŸèƒ½è¯†åˆ«ä¼šè®¡æ¥å£ã€‚MANTAä½¿ç”¨DFSä»åŸºæœ¬è®°è´¦å‡½æ•°å‘åéå†ï¼Œå¹¶åœ¨å†…æ ¸è°ƒç”¨å›¾ä¸Šæ ‡è®°æ‰€æœ‰è®¿é—®è¿‡çš„å‡½æ•°ã€‚æ¯å½“å®ƒåˆ°è¾¾memcgå­ç³»ç»Ÿä¹‹å¤–çš„å‡½æ•°æ—¶ï¼ŒMANTAå°±ä¼šåœæ­¢éå†ï¼Œå› ä¸ºå®ƒä¸èƒ½æ˜¯memcgæ¥å£ã€‚åœ¨è¿™äº›è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µçš„æ ‡è®°å‡½æ•°ä¸­ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°æ˜¯ä»memcgå­ç³»ç»Ÿå¤–éƒ¨è°ƒç”¨çš„ï¼Œå³ï¼Œå®šä¹‰memcgåŠŸèƒ½çš„æºæ–‡ä»¶ï¼ŒMANTAå°†å…¶æ ‡è®°ä¸ºä¸€ä¸ªè®°å½•æ¥å£ã€‚è¿™æ ·ï¼ŒMANTAå°±å¯ä»¥è¯†åˆ«æ‰€æœ‰çš„è®¡è´¹æ¥å£ã€‚ è®©æˆ‘ä»¬ä½¿ç”¨å›¾ä¸­çš„ç¤ºä¾‹æ¥è¯´æ˜åŸºäºè®¡æ•°å™¨çš„æ¥å£æ ‡è¯†ä¸­çš„æ­¥éª¤ã€‚é¦–å…ˆï¼ŒMANTAéå†æ‰€æœ‰æ ¸å‡½æ•°çš„æ‰€æœ‰åŸºæœ¬å—ã€‚åœ¨__memcg_kmem_chargeä¸­ï¼Œå®ƒæ ‡è¯†page_counterå‡½æ•°(ç¬¬6è¡Œ)å¹¶åŒé‡ç¡®è®¤ç¬¬ä¸€ä¸ªå‚æ•°æ¥è‡ªmemcgã€‚ä¹‹åï¼ŒMANTAè¿›å…¥page_counter_try_chargeï¼Œå‘ç°å®ƒå¢åŠ äº†page_counterçš„ä¸€ä¸ªå­—æ®µã€‚ç”±äº__memcg_kmem_chargeç›´æ¥è°ƒç”¨page_counterå‡½æ•°å¹¶å¢åŠ page_counterçš„å€¼ï¼Œå› æ­¤MANTAè®¤ä¸º__memcg_kmem_chargeæ˜¯ä¸€ä¸ªåŸºæœ¬çš„è®¡è´¹æ¥å£ã€‚ ç±»ä¼¼åœ°ï¼Œå¯¹äºå‡å°‘page_counterå€¼çš„æ¥å£ï¼ŒMANTAå°†å…¶æ ‡è®°ä¸ºæœªæ”¶è´¹æ¥å£ã€‚æ­¤å¤–ï¼ŒMANTAå¯ä»¥åŒºåˆ†ä¸åŒå†…å­˜ç±»å‹çš„æ¥å£ï¼Œå› ä¸ºmemcgå¯¹æ¯ç§å†…å­˜ç±»å‹ä½¿ç”¨ä¸åŒçš„page_counters(Â§2)ã€‚åœ¨ç¬¬6è¡Œï¼Œpage_counter_try_chargeä½¿ç”¨äº†&amp;memcg-&gt; kmemmï¼Œå› æ­¤MANTAçŸ¥é“__memcg_kmem_chargeç”¨äºå†…æ ¸å†…å­˜è®°å¸ã€‚ ä»åŸºæœ¬çš„æ”¶è´¹æ¥å£å¼€å§‹ï¼ŒMANTAç„¶åæ²¿ç€è°ƒç”¨é“¾é€æ­¥è¯†åˆ«æ‰€æœ‰çš„æ”¶è´¹æ¥å£åŒ…è£…å™¨ã€‚å¦‚æœä¸€ä¸ªå‡½æ•°è°ƒç”¨åŸºæœ¬çš„è®¡è´¹æ¥å£ï¼Œå¹¶ä¸”è®¡è´¹é‡æ¥è‡ªäºå®ƒçš„å‚æ•°ï¼ŒMANTAå°†æŠŠå®ƒæ ‡è®°ä¸ºä¸€ä¸ªè®¡è´¹æ¥å£åŒ…è£…å™¨ã€‚ä½¿ç”¨å›¾ä¸­çš„ç›¸åŒç¤ºä¾‹ï¼Œ__memcg_kmem_charge_pageè°ƒç”¨åŸºæœ¬æ”¶è´¹æ¥å£__memcg_kmem_charge(ç¬¬29è¡Œ)ï¼Œè€Œæ”¶è´¹é‡‘é¢1&lt;&lt;orderç”±__memcg_kmem_charge_pageçš„å‚æ•°æ§åˆ¶ã€‚ å› æ­¤ï¼ŒMANTAè®¤ä¸º__memcg_kmem_charge_pageæ˜¯ä¸€ä¸ªæ”¶è´¹åŒ…è£…å™¨ï¼Œå› ä¸ºå®ƒåªæ˜¯å°†æ”¶è´¹æ•°é‡ä¼ é€’ç»™åŸºæœ¬æ”¶è´¹æ¥å£ï¼Œå¹¶ä¸”å¯¹æ”¶è´¹æ•°é‡æ²¡æœ‰æ§åˆ¶ã€‚ MANTAä½¿ç”¨ç›¸åŒçš„æ–¹æ³•æ¥æ£€æµ‹æœªå……ç”µçš„åŒ…è£…å™¨ã€‚ å¯¹äºcharge&#x2F;unchargeæ¥å£ï¼ŒMANTAè¿˜éœ€è¦è¯†åˆ«å†…å­˜åˆ†é…&#x2F;ç©ºé—²æ¥å£ã€‚MANTAé‡‡ç”¨ç°æœ‰æŠ€æœ¯æ¥äº§ç”Ÿåˆæ­¥ç»“æœã€‚æ­¤å¤–ï¼Œé€šè¿‡è§‚å¯Ÿå†…å­˜åˆ†é…&#x2F;é‡Šæ”¾æ¥å£å¢åŠ &#x2F;å‡å°‘struct free_areaçš„nr_freeè®¡æ•°å™¨ï¼ŒMANTAä½¿ç”¨ç±»ä¼¼çš„åŸºäºè®¡æ•°å™¨çš„æ–¹æ³•æ¥æé«˜ç»“æœçš„ç²¾åº¦ã€‚ 123456789101112131415161718192021222324252627282930313233343536int __memcg_kmem_charge(struct mem_cgroup *memcg, gfp_t gfp,unsigned int nr_pages)&#123; struct page_counter *counter; ... if(!cgroup_subsys_on_dfl(memory_cgrp_subsys)&amp;&amp;!page_counter_try_charge(&amp;memcg-&gt;kmem,nr_pages,&amp;counter)) &#123;...&#125; ...&#125;bool page_counter_try_charge(struct page_counter *counter,unsigned long nr_pages,struct page_counter **fail)&#123; struct page_counter *c; for(c = counter; c;c = c-&gt;parent)&#123; long new; new = atomic_long_add_return(nr_pages,&amp;c-&gt;usage); ... &#125; ...&#125;int __memcg_kmem_charge_page(struct page *page, gtp_t gtp,int order)&#123; struct mem_cgroup *memcg; int ret = 0; memcg = get_mem_cgroup_from_current(); ... ret = __memcg_kmem_charge(memcg,gfp,1&lt;&lt;order); if(!ret)&#123; page-&gt;mem_cgroup = memcg; ... &#125; ...&#125; Alloc-Charging Mapping Analysisç›´è§‚åœ°è¯´ï¼Œæ¯ä¸ªåˆ†é…çš„å¯¹è±¡åº”è¯¥åªè¢«è®¡ç®—ä¸€æ¬¡ã€‚å¦åˆ™ï¼Œå¯¹è±¡å¯èƒ½ä¼šè¢«æ¼è®°ã€‚å› æ­¤ï¼ŒMANTA çš„ä¸‹ä¸€æ­¥æ˜¯å»ºç«‹å†…å­˜åˆ†é…&#x2F;é‡Šæ”¾å’Œè®¡è´¹&#x2F;å–æ¶ˆè®¡è´¹ä¹‹é—´çš„å…³ç³»ã€‚åŸºäºè¿™ç§å…³ç³»ï¼ŒMANTA å¯ä»¥è¯†åˆ«æ¯”åˆ†é…&#x2F;é‡Šæ”¾çš„å†…å­˜å°‘æ”¶è´¹æˆ–å¤šé€€è´¹çš„æƒ…å†µï¼Œå°†å…¶è§†ä¸ºæ¼è®°é”™è¯¯ã€‚ç®€æ´èµ·è§ï¼Œæˆ‘ä»¬å…³æ³¨åˆ†é…å’Œè®¡è´¹ã€‚åŒæ ·çš„æŠ€æœ¯å¯ä»¥åº”ç”¨äºåˆ†æfree-unchargingæ˜ å°„ã€‚ ç”±äºæ·±å±‚æ¬¡çš„è°ƒç”¨å…³ç³»å’Œå¤æ‚çš„å†…å­˜æŒ‡é’ˆä¼ æ’­ï¼Œä»æºä»£ç åˆ†æåˆ†é…å’Œè®¡è´¹ä¹‹é—´çš„æ˜ å°„å¹¶éæ˜“äº‹ã€‚ä¸ºäº†è§£å†³è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬å¼€å‘äº†åˆ†é…è®¡è´¹(allocation and charging)æ˜ å°„åˆ†æã€‚åŸºæœ¬æ€è·¯æ˜¯é¦–å…ˆå°†å‡½æ•°å†…çš„å†…å­˜åˆ†é…å’Œè®¡è´¹æ€»ç»“ä¸ºå‡½æ•°æ‘˜è¦(function summary)ï¼Œç„¶ååŸºäºå‡½æ•°æ‘˜è¦æ„å»ºå†…å­˜åˆ†é…-è®¡è´¹æ˜ å°„ï¼Œä»¥æ£€æµ‹æ¼è®°é”™è¯¯ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œæˆ‘ä»¬ä½¿ç”¨åŸºäºè®¿é—®è·¯å¾„çš„åˆ†ææ¥ç”Ÿæˆæ¯ä¸ªå‡½æ•°çš„æ‘˜è¦ã€‚è®¿é—®è·¯å¾„çš„æ¦‚å¿µé¦–æ¬¡ç”¨äº SATURN æ¡†æ¶ï¼Œç”¨äºè¡¨ç¤ºè½¬ä¹‰å¯¹è±¡çš„æ¯ä¸ªå‡½æ•°æ‘˜è¦ï¼ˆå³å¯¹è±¡æŒ‡é’ˆæ³„æ¼åˆ°å½“å‰å‡½æ•°ä¹‹å¤–ï¼‰ã€‚ å¦‚å›¾å·¦ä¾§ç®—æ³•æ‰€ç¤ºï¼ŒMANTA é¦–å…ˆä¸ºæ‰€æœ‰å‡½æ•°ç”Ÿæˆå‡½æ•°æ‘˜è¦ï¼ˆç¬¬ 2 è¡Œï¼‰ã€‚æ¥ä¸‹æ¥ï¼Œå¯¹äºä¸€ä¸ªå‡½æ•°ğ‘“ï¼Œé€šè¿‡æ”¶é›†å…¶è¢«è°ƒç”¨è€…çš„å‡½æ•°æ‘˜è¦å¹¶åˆ†æå†…å­˜åˆ†é…ä½ç½®ï¼ˆIsAllocï¼‰ï¼ŒMANTA å¯ä»¥æ„å»º ğ‘“ å†…æ‰€æœ‰éè½¬ä¹‰å¯¹è±¡çš„åˆ†é…-è®¡è´¹æ˜ å°„ï¼ˆç¬¬ 4-9 è¡Œï¼‰ã€‚å…·ä½“è€Œè¨€ï¼ŒMANTA ç”¨ä¼ é€’ç»™è¢«è°ƒç”¨è€…çš„å‚æ•°æ›¿æ¢è¢«è°ƒç”¨è€…æ‘˜è¦ä¸­çš„å˜é‡ï¼Œä»¥è®¡ç®— ğ‘“ ä¸­åˆ†é…çš„é¡µé¢ï¼Œè¿™è¢«ç§°ä¸ºæºæ•æ„Ÿè·Ÿè¸ªã€‚ç„¶åï¼ŒMANTA é€šè¿‡è°ƒç”¨ CheckPage æ¥åˆ†æ ğ‘“ å†…çš„åˆ†é…-è®¡è´¹æ˜ å°„ã€‚åœ¨ CheckPage ä¸­ï¼ŒMANTA èƒ½å¤ŸæŠ¥å‘Šéè½¬ä¹‰å¯¹è±¡çš„æ¼è®°é”™è¯¯ï¼ˆç¬¬ 19 è¡Œï¼‰ã€‚å¯¹äºä» ğ‘“ è½¬ä¹‰çš„å¯¹è±¡ï¼ˆç¬¬ 14-18 è¡Œï¼‰ï¼Œå®ƒä»¬æœ€ç»ˆå°†åœ¨ä¸€ä¸ªå‡½æ•°ä¸­ï¼ˆä¾‹å¦‚ ğ‘“ çš„è°ƒç”¨è€…ï¼‰å¤„ç†ï¼Œå› ä¸ºå†…æ ¸ä¸­çš„æ‰€æœ‰å‡½æ•°éƒ½è¢«éå†ï¼ˆç¬¬ 3-10 è¡Œï¼‰ã€‚æ­¤å¤–ï¼ŒIsChargedï¼ˆç¬¬ 13 è¡Œï¼‰å’Œ IsDupCharged å‡½æ•°ï¼ˆç¬¬ 21 è¡Œï¼‰éƒ½è¿›è¡Œæ•°æ®æµåˆ†æï¼Œå°†å±€éƒ¨å¯¹è±¡è¿æ¥åˆ°è¢«è°ƒç”¨å‡½æ•°çš„è¿”å›å€¼æˆ–å‚æ•°ã€‚è¿™æ ·ï¼Œä»–ä»¬å¯ä»¥ä½¿ç”¨è¢«è°ƒç”¨è€…çš„å‡½æ•°æ‘˜è¦è·Ÿè¸ªå†…æ ¸å¯¹è±¡çš„è®¡è´¹çŠ¶æ€ã€‚ æˆ‘ä»¬ä½¿ç”¨å›¾å³ä¾§çš„å…·ä½“ç¤ºä¾‹æ¥æ¼”ç¤ºç®—æ³•ã€‚MANTAé¦–å…ˆä¸ºåº•å±‚å†…å­˜åˆ†é…å‡½æ•°__alloc_pages_nodemaskç”Ÿæˆæ‘˜è¦ã€‚ MANTAè¯†åˆ«åˆ°é¡µé¢ç”±è¾ƒä½çº§åˆ«çš„å‡½æ•°get_page_from_freelistè¿”å›ã€å……ç”µï¼Œå¹¶è¿”å›ã€‚å› æ­¤ï¼Œé¡µé¢æ—¢é€¸å‡ºåˆå……ç”µï¼Œå‡½æ•°æ‘˜è¦åº”ä¸ºï¼ˆ__alloc_pages_nodemaskï¼Œretvalï¼Œretvalï¼‰ã€‚å½“MANTAåˆ†ædo_anonymous_pageæ—¶ï¼Œå®ƒä¼šè·å–alloc_zeroed_user_highpage_movableçš„å‡½æ•°æ‘˜è¦ï¼Œè¯¥å‡½æ•°æ˜¯__alloc_pages_nodemaskçš„åŒ…è£…å™¨ï¼Œå…·æœ‰ç›¸åŒçš„æ‘˜è¦ã€‚æ ¹æ®å‡½æ•°æ‘˜è¦ï¼ŒMANTAç¡®å®šdo_anonymous_pageä¸­çš„é¡µé¢å·²ç»å……ç”µã€‚åœ¨åˆ†ædo_anonymous_pageå†…éƒ¨çš„åˆ†é…-è®¡è´¹æ˜ å°„æ—¶ï¼ŒMANTAå‘ç°å†…å­˜æ ¸ç®—ä½äºç¬¬18è¡Œå¯ä»ç¬¬14è¡Œåˆ°è¾¾ï¼Œé¡µé¢å¯èƒ½åœ¨ç¬¬18è¡Œå†æ¬¡è¢«è®¡è´¹ã€‚å› æ­¤ï¼ŒMANTAåœ¨è¿™ç§æƒ…å†µä¸‹æŠ¥å‘Šäº†ä¸€ä¸ªå†—ä½™å¸æˆ·è­¦å‘Šã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æœå½“å‰å‡½æ•°ä¸­çš„é¡µé¢æœªè¢«è®¡è´¹ä¸”ä¸ä¼šé€¸å‡ºï¼ŒMANTAä¼šæŠ¥å‘Šä¸€ä¸ªæœªè®°å½•é”™è¯¯ã€‚ 12345678910111213141516171819struct page * __alloc_pages_nodemask(...)&#123; ... page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac); ... if(memcg_kmem_enabled()&amp;&amp;(gtp_mask&amp;__GFP_ACCOUNT)&amp;&amp;page&amp;&amp;unlikely(__memcg_kmem_charge_page(page,gfp_mask,order)!=0)) &#123;...&#125; ... return page;&#125;static vm_fault_t do_anonymous_page(struct vm_fault *vmf)&#123; page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address); if(!page) goto oom; if(mem_cgroup_charge(page, vma-&gt;vm_mm, GFP_KERNEL) ...&#125; Accounting Flag Analysiså‘ç°ä»…ä¾é åˆ†é…å’Œè®°è´¦ç«™ç‚¹çš„æ˜ å°„æ¥æ£€æµ‹è®°è´¦ä¸¢å¤±é”™è¯¯æ˜¯ä¸å¤Ÿçš„ï¼Œå› ä¸ºå†…å­˜è®°è´¦é€šå¸¸æ˜¯æœ‰æ¡ä»¶çš„ã€‚ç‰¹åˆ«æ˜¯åœ¨ Linux å†…æ ¸ä¸­ï¼Œåªæœ‰å½“å°† __GFP_ACCOUNTæ ‡å¿—ä¼ é€’ç»™è®°è´¦æ¥å£æ—¶ï¼Œæ‰ä¼šå¯¹å†…æ ¸å¯¹è±¡å†…å­˜è¿›è¡Œè®°è´¦ã€‚å› æ­¤ï¼Œå¦‚æœæ²¡æœ‰æä¾› __GFP_ACCOUNT æ ‡å¿—ï¼Œè®°è´¦æ¥å£ä»ç„¶ä¸ä¼šå¯¹å†…å­˜è¿›è¡Œè®°è´¦ã€‚å› æ­¤ï¼Œåˆ†æè®°è´¦æ ‡å¿—çš„å€¼å¯¹äºæ£€æµ‹è®°è´¦ä¸¢å¤±è‡³å…³é‡è¦ã€‚å› æ­¤ï¼ŒMANTA å¯¹è®°è´¦æ ‡å¿—è¿›è¡Œåˆ†æï¼Œä»¥ç¡®å®šæ˜¯å¦å°†è®°è´¦æ ‡å¿— __GFP_ACCOUNT ä¼ é€’ç»™è®°è´¦æ¥å£ã€‚ Bit-wise and inter-procedural analysis MANTAé‡‡ç”¨ç¨‹åºé—´é€ä½æ•°æ®æµè·Ÿè¸ªæ–¹æ³•æ¥å®ç°ä¼šè®¡æ ‡å¿—åˆ†æã€‚é¦–å…ˆï¼Œåœ¨è®¡è´¹ç‚¹ï¼ŒMANTAæ£€æŸ¥GFPæ ‡å¿—æœ¬èº«æ˜¯å¦ä¸ºå¸¸æ•°ã€‚å¦‚æœæ˜¯ï¼ŒMANTAç›´æ¥æ£€æŸ¥__GFP_ACCOUNTçš„ä½ã€‚å¦åˆ™ï¼ŒMANTAå°†é€’å½’åœ°è·Ÿè¸ªæ ‡å¿—çš„use-def chainï¼Œç›´åˆ°ç¡®è®¤å…¶è®°å¸æ ‡å¿—ä½ã€‚è™½ç„¶LLVMæä¾›äº†ä¸€ä¸ªå¯ä»¥è·Ÿè¸ªä½å€¼ä¼ æ’­çš„å€¼è·Ÿè¸ªåˆ†æé€šé“ï¼Œä½†è¯¥åˆ†æä»…é™äºè¿‡ç¨‹å†…ã€‚ä¸ºäº†è·Ÿè¸ªç¨‹åºé—´è®°å¸ä½ï¼ŒMANTAç”¨ä¸¤ä¸ªåˆ†æè§„åˆ™æ‰©å±•äº†é€šé“ã€‚å…·ä½“æ¥è¯´ï¼Œå½“MANTAè·Ÿè¸ªå‡½æ•°çš„å‚æ•°æ—¶ï¼Œå®ƒè·Ÿè¸ªæ‰€æœ‰è°ƒç”¨å‡½æ•°ä»¥è·Ÿè¸ªä¼ é€’ç»™å‚æ•°çš„å€¼;å½“MANTAè·Ÿè¸ªè°ƒç”¨ç«™ç‚¹çš„è¿”å›å€¼æ—¶ï¼Œå®ƒä¹Ÿè·Ÿè¸ªè¢«è°ƒç”¨å‡½æ•°å¹¶è·Ÿè¸ªæ‰€æœ‰å¯èƒ½çš„è¿”å›å€¼ã€‚å¦‚æœè®¾ç½®äº†__GFP_ACCOUNT, MANTAå°†å†…æ ¸å†…å­˜æ ‡è®°ä¸ºåœ¨åˆ†é…ç‚¹è¢«å ç”¨ã€‚å¦åˆ™ï¼Œå³ä½¿æœ‰chargingæ¥å£ï¼ŒMANTAä¹Ÿä¼šå°†å†…å­˜è§†ä¸ºnot-chargedã€‚ å¯¹kmem_cacheåˆ†é…çš„åˆ†æç•¥æœ‰ä¸åŒï¼Œå› ä¸ºåˆ†é…ä¹Ÿå—åˆ°kmem_cacheçš„åˆ›å»ºæ ‡å¿—çš„å½±å“ã€‚ å¦‚æœkmem_cacheæ˜¯ç”¨SLAB_ACCOUNTæ ‡å¿—åˆ›å»ºçš„ï¼Œé‚£ä¹ˆæ¥è‡ªkmem_cacheçš„æ‰€æœ‰åˆ†é…éƒ½ä¼šè¢«è®¡ç®—åœ¨å†…ã€‚å› æ­¤ï¼Œå¯¹äºä¸kmem_cacheç›¸å…³çš„åˆ†é…ï¼ŒMANTAä¹Ÿä¼šæ‰¾åˆ°kmem_cacheçš„åˆå§‹åŒ–ä½ç½®ï¼Œå¹¶é‡‡ç”¨ç›¸åŒçš„è®°å¸æ ‡å¿—åˆ†ææŠ€æœ¯æ¥è®¡ç®—SLAB_ACCOUNTæ ‡å¿—ã€‚ Dynamic Validationé™æ€åˆ†æå¯èƒ½æœ‰è¯¯æŠ¥ã€‚MANTAæ£€æŸ¥æ¯ä¸ªè®°è´¦ä¸¢å¤±åˆ†é…çš„ç³»ç»Ÿè°ƒç”¨çš„é™æ€å¯è¾¾æ€§ï¼Œå¹¶è¿‡æ»¤æ‰ä¸å¯è¾¾çš„ã€‚ç„¶è€Œï¼Œé™æ€å¯è¾¾çš„bugä¸ä¸€å®šåœ¨è¿è¡Œæ—¶è§¦å‘ã€‚å› æ­¤ï¼ŒMANTAé€šè¿‡åŠ¨æ€éªŒè¯è¿›ä¸€æ­¥åˆ†æé™æ€æ£€æµ‹é”™è¯¯çš„è§¦å‘æ€§ã€‚è§‚å¯Ÿåˆ°Linuxæµ‹è¯•é¡¹ç›®(LTP)åŒ…å«æ‰€æœ‰300ä¸ªç³»ç»Ÿè°ƒç”¨çš„æµ‹è¯•ç”¨ä¾‹ï¼Œæˆ‘ä»¬åˆ©ç”¨è¿™äº›æµ‹è¯•ç”¨ä¾‹æ¥æ£€æŸ¥æ£€æµ‹åˆ°çš„é”™è¯¯çš„åŠ¨æ€è§¦å‘æ€§ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œæˆ‘ä»¬é¦–å…ˆæ£€æµ‹ä»£ç ä»¥æ‹¦æˆªæ¯ä¸ªä¸¢å¤±çš„è®°è´¦åˆ†é…ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç¡®è®¤æ˜¯å¦ç¡®å®è¾¾åˆ°äº†å®ƒã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¿è¡ŒLTPçš„ç³»ç»Ÿè°ƒç”¨å’Œå®¹å™¨æµ‹è¯•å¥—ä»¶(åŒ…å«1,469ä¸ªæµ‹è¯•ç”¨ä¾‹)ï¼Œä»¥æ£€æŸ¥æ˜¯å¦è§¦å‘äº†é”™è¯¯ã€‚ æ­¤å¤–ï¼Œæˆ‘ä»¬æ‰‹åŠ¨è¿è¡Œç°æœ‰çš„å·¥å…·æˆ–å¼€å‘æ–°çš„æµ‹è¯•ç”¨ä¾‹æ¥è§¦å‘LTPæ— æ³•è§¦å‘çš„é”™è¯¯ã€‚å…¶ä¸­ä¸€äº›bugä¸ç‰¹å®šçš„å†…æ ¸ç‰¹æ€§å¯†åˆ‡ç›¸å…³ï¼Œä¸èƒ½è¢«ä¸€èˆ¬çš„LTPæµ‹è¯•ç”¨ä¾‹(ä¾‹å¦‚keexecå’Œselinux)è§¦å‘ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬æ‰‹åŠ¨è¿è¡Œç›¸å…³çš„ç”¨æˆ·ç©ºé—´å·¥å…·æ¥è§¦å‘å®ƒä»¬ã€‚ å…¶ä»–åŸå› æ˜¯ç”±äºLTPå‘ç°çš„ç‰¹å®šç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼Œæˆ‘ä»¬æ‰‹åŠ¨å¼€å‘æµ‹è¯•ç”¨ä¾‹æ¥ä¼ é€’è¿™äº›å‚æ•°ã€‚ å¯¹äºå¯ä»¥åŠ¨æ€è§¦å‘çš„è®°è´¦ä¸¢å¤±é”™è¯¯ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥å¼€å‘äº†å†…å­˜è€—å°½æ¦‚å¿µéªŒè¯(PoC)æ¥è¯„ä¼°å®ƒä»¬çš„å®‰å…¨é£é™©ã€‚æˆ‘ä»¬åŸºäºè§¦å‘è®°è´¦ä¸¢å¤±é”™è¯¯çš„æµ‹è¯•ç”¨ä¾‹å¼€å‘PoCsã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬åå¤è°ƒç”¨å¯èƒ½è§¦å‘PoCsä¸­è®°è´¦ä¸¢å¤±é”™è¯¯çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå¹¶è®°å½•è®°è´¦ä¸¢å¤±çš„å†…å­˜é‡ã€‚æ­¤å¤–ï¼Œä¸€äº›è®°è´¦ä¸¢å¤±çš„åˆ†é…å—åˆ°æŸäº›çº¦æŸï¼Œä¾‹å¦‚ulimitå’Œsysctlå˜é‡ã€‚åœ¨ä¸æŸå¤±é€šç”¨æ€§çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯¹Amazon Fargateç­‰äº‘æœåŠ¡é‡‡ç”¨äº†ç›¸åŒçš„çº¦æŸè®¾ç½®ã€‚è¿™äº›PoCsçš„ç»†èŠ‚å°†åœ¨Â§5.2ä¸­ä»‹ç»ã€‚ Implementationæˆ‘ä»¬ç”¨4Kè¡Œçš„c++ä»£ç å°†MANTAä½œä¸ºLLVM12çš„ä¸€ä¸ªé€šé“æ¥å®ç°ã€‚æ‰€åˆ†æçš„Linuxå†…æ ¸æ˜¯v5.10ï¼Œå…·æœ‰x86-64çš„é»˜è®¤é…ç½®ã€‚MANTAä½¿ç”¨wllvmå’ŒClangåœ¨é»˜è®¤é…ç½®ä¸‹ä¸ºæ•´ä¸ªå†…æ ¸ç”ŸæˆIRä½ç ã€‚ vmlinuxçš„ä½ç å¤§å°ä¸º481MBã€‚MANTAä½¿ç”¨PeXæ–¹æ³•æ¥è§£æé—´æ¥è°ƒç”¨å¹¶ç”Ÿæˆè°ƒç”¨å›¾ã€‚ ä½¿ç”¨å»ºè®®çš„æŠ€æœ¯ï¼ŒMANTAèƒ½å¤Ÿåœ¨å¤§çº¦ä¸‰åˆ†é’Ÿå†…å®Œæˆåˆ†æï¼Œä½¿å…¶å…·æœ‰è¶³å¤Ÿçš„å¯æ‰©å±•æ€§ï¼Œå¯ä»¥åº”ç”¨äºæ¯ä¸ªLinuxä¸»è¦ç‰ˆæœ¬ã€‚ MANTA RESULTåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆç»™å‡ºäº†MANTAçš„åˆ†æç»“æœã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¯„ä¼°äº†MANTAçš„æŸ¥å‡†ç‡å’ŒæŸ¥å…¨ç‡ã€‚ä¹‹åï¼Œæˆ‘ä»¬å°†ä»‹ç»å½±å“åˆ†æä»¥åŠLinuxå†…æ ¸ç¤¾åŒºæŠ¥å‘Šå’Œä¿®å¤çš„é”™è¯¯ã€‚æœ€åï¼Œæˆ‘ä»¬è®¨è®ºäº†MANTAçš„å±€é™æ€§ã€‚ Result OverviewMANTAæ£€æµ‹åˆ°242ä¸ªè®°è´¦ä¸¢å¤±çš„é”™è¯¯ï¼Œè¿™äº›é”™è¯¯å¯ä»¥é€šè¿‡60590ä¸ªä¸åŒçš„è·¯å¾„ä»273ä¸ªç³»ç»Ÿè°ƒç”¨ä¸­é™æ€åœ°åˆ°è¾¾ã€‚å…·ä½“æ¥è¯´ï¼Œç”¨æˆ·ç©ºé—´å¯è§¦å‘çš„bugæ•°é‡ä¸º162ä¸ªï¼Œå…¶ä¸­LTPè§¦å‘çš„bugæœ‰134ä¸ªï¼Œç°æœ‰å·¥å…·è§¦å‘çš„bugæœ‰23ä¸ªï¼Œæ‰‹å·¥å¼€å‘çš„æµ‹è¯•ç”¨ä¾‹è§¦å‘çš„bugæœ‰5ä¸ªã€‚ å‰©ä¸‹çš„80ä¸ªbugä¸èƒ½è¢«è§¦å‘ï¼Œè§¦å‘å¤±è´¥çš„åŸå› ä¸»è¦æ˜¯æ·±åº¦è°ƒç”¨è·¯å¾„ï¼ˆ80ä¸ªæ¡ˆä¾‹ä¸­çš„72ä¸ªï¼‰ã€‚å…¶ä½™çš„8ä¸ªåˆ†é…åœ¨å†…æ ¸æ–‡æ¡£ä¸­è¢«æ˜ç¡®æ ‡è®°ä¸ºè±å…ï¼Œæˆ–è€…ç”¨äºå†…æ ¸å†…éƒ¨ä½¿ç”¨ã€‚è¯·æ³¨æ„ï¼Œè¿™72ä¸ªæ²¡æœ‰è§¦å‘çš„bugå¹¶ä¸éƒ½æ˜¯å‡é˜³æ€§ï¼Œå› ä¸ºæˆ‘ä»¬çš„æµ‹è¯•æ¡ˆä¾‹åªè¦†ç›–äº†ä¸€éƒ¨åˆ†æ‰§è¡Œè·¯å¾„ã€‚ä¿å®ˆåœ°è¯´ï¼ŒMANTAçš„ç²¾åº¦å¤§äº66.9%ï¼ˆ162&#x2F;242ï¼‰ã€‚ æˆ‘ä»¬è¿˜é€šè¿‡æ‰‹åŠ¨åˆ é™¤ä¼šè®¡æ ‡å¿—æ¥è¯„ä¼°MANTAçš„å¬å›ç‡ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡åˆ é™¤kernel&#x2F;å­ç›®å½•ä¸‹ç°æœ‰çš„ä¼šè®¡æ ‡å¿—æ¥ç”Ÿæˆä¸€ä¸ªè¯„ä¼°é›†ã€‚æ‰€æœ‰å—å½±å“çš„åˆ†é…ç‚¹éƒ½è¢«æ”¶é›†åœ¨è¯„ä¼°é›†ä¸­ã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬åˆ é™¤äº†11ä¸ªSLAB_ACCOUNTæ ‡å¿—ï¼Œç”¨GFP_KERNELæ›¿æ¢äº†5ä¸ªGFP_KERNEL_ACCOUNTï¼Œæ€»å…±å½±å“äº†19ä¸ªå†…å­˜åˆ†é…ï¼Œå¦‚è¡¨æ‰€ç¤ºã€‚ç„¶åæˆ‘ä»¬åœ¨ä¿®æ”¹åçš„å†…æ ¸ä»£ç ä¸Šè¿è¡ŒMANTAï¼Œè¯„ä¼°ç»“æœæ˜¾ç¤ºï¼ŒMANTAå¯ä»¥æ£€æµ‹åˆ°æ‰€æœ‰19ä¸ªç¼ºå¤±çš„ç«™ç‚¹ã€‚è™½ç„¶è¯„ä¼°çš„ç«™ç‚¹æœ‰é™ï¼Œä½†ä»è¡¨æ˜MANTAæœ‰å¾ˆé«˜çš„å¬å›ç‡ã€‚ æ­¤å¤–ï¼ŒMANTAæ²¡æœ‰å‘ç°ä»»ä½•å¤šä½™çš„è´¦æˆ·æ¼æ´ã€‚ Impact Analysiså¦‚å‰æ‰€è¿°ï¼Œä¸ºäº†ç†è§£æ£€æµ‹åˆ°çš„é”™è¯¯çš„å½±å“ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥å¼€å‘åŸºäºLTPæµ‹è¯•ç”¨ä¾‹çš„æ¦‚å¿µéªŒè¯(PoCs)ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œæˆ‘ä»¬å·²ç»å¼€å‘äº†17ä¸ªPoCsï¼Œå®ƒä»¬æ¶µç›–äº†47ä¸ªå¯ä»¥ä»ç”¨æˆ·ç©ºé—´é‡å¤è§¦å‘çš„é”™è¯¯ï¼Œå¦‚è¡¨æ‰€ç¤ºã€‚æˆ‘ä»¬åœ¨å…·æœ‰16GB RAMçš„QEMU x86_64æœºå™¨ä¸Šå¼€å‘å’Œæµ‹è¯•PoCsã€‚Linuxå‘è¡Œç‰ˆæ˜¯å¸¦æœ‰Linuxå†…æ ¸v5.10çš„Debian Busterã€‚æ‰€æœ‰pocéƒ½è¿è¡Œåœ¨å—memgé™åˆ¶çš„ç¯å¢ƒä¸­ï¼Œå¹¶å…·æœ‰Dockerè¿è¡Œæ—¶åº”ç”¨çš„é»˜è®¤åŠŸèƒ½é›†ã€‚ é™¤äº†PoCsè¦†ç›–çš„bugä¹‹å¤–ï¼Œç”±äºæ—¶é—´å’Œé¢†åŸŸçŸ¥è¯†çš„é™åˆ¶ï¼Œæˆ‘ä»¬æ²¡æœ‰ä¸ºå…¶ä»–å¯è§¦å‘çš„bugå¼€å‘PoCsã€‚ ç„¶è€Œï¼Œè¿™äº›æ¼æ´ä¹Ÿå¯èƒ½è¢«å…·æœ‰ç›¸åº”é¢†åŸŸçŸ¥è¯†çš„æ”»å‡»è€…åå¤å¯é åœ°è§¦å‘ã€‚ Reporting to Linux Communityæˆ‘ä»¬å·²ç»å‘Linuxå†…æ ¸ç¤¾åŒºæŠ¥å‘Šäº†53ä¸ªbugï¼ŒåŒ…æ‹¬æ‰€æœ‰47ä¸ªå¯ä»¥ç”±17ä¸ªç”¨æˆ·ç©ºé—´pocè§¦å‘çš„bugå’Œ6ä¸ªå¯ä»¥ç”±å†…æ ¸æ“ä½œåå¤è§¦å‘çš„bugã€‚è¿™äº›bugçš„å®Œæ•´åˆ—è¡¨åˆ—åœ¨é™„å½•Açš„è¡¨ä¸­ã€‚ åœ¨æ‰€æœ‰æŠ¥å‘Šçš„bugä¸­ï¼Œæœ‰37ä¸ªå·²ç»è¢«å†…æ ¸å¼€å‘äººå‘˜ç¡®è®¤ã€‚æ‰€æœ‰è¿™37ä¸ªbugçš„è¡¥ä¸éƒ½æäº¤äº†ï¼Œå…¶ä¸­18ä¸ªå·²ç»åˆå¹¶ï¼Œ19ä¸ªå¾…åˆå¹¶ã€‚ ç”±äºmemcgå­ç³»ç»Ÿç›®å‰æ²¡æœ‰ç»´æŠ¤å®ƒçš„gitå­æ ‘ï¼Œæ‰€ä»¥ä¿®è¡¥è¿‡ç¨‹å¾ˆæ…¢ã€‚å› æ­¤ï¼Œmemcgç»´æŠ¤è€…ä¸è·Ÿè¸ªæäº¤çš„è¡¥ä¸ï¼Œå¹¶æœŸæœ›è¡¥ä¸ä½œè€…å°†é€šè¿‡å…¶ä»–å­ç³»ç»Ÿç»´æŠ¤è€…å‘ä¸Šæ¸¸æ¨é€è¡¥ä¸ã€‚è¿™å¼•å…¥äº†è®¸å¤šé¢å¤–çš„è®¨è®ºå’Œå®¡æŸ¥ï¼Œä»è€Œæ˜¾è‘—åœ°å‡ç¼“äº†åˆå¹¶è¿‡ç¨‹ã€‚ åœ¨ä¸å†…æ ¸å¼€å‘è€…çš„äº¤æµä¸­ï¼Œæˆ‘ä»¬å‘ç°å†…æ ¸ç¤¾åŒºå¯¹è¿™äº›bugéå¸¸å…³æ³¨ã€‚ä¸€ä½å†…æ ¸å¼€å‘äººå‘˜å¼ºè°ƒï¼Œmemcgâ€œä¸ä»…ä»…æ˜¯ç²—ç•¥çš„è®°è´¦ä¼°è®¡â€ï¼Œè€Œä¸”â€œåº”è¯¥è€ƒè™‘ç”±ç”¨æˆ·ç©ºé—´è§¦å‘çš„æœªç»‘å®šåˆ†é…â€ã€‚æ­¤å¤–ï¼Œå†…æ ¸å¼€å‘äººå‘˜å¯¹MANTAéå¸¸æ„Ÿå…´è¶£ï¼Œå¹¶é‚€è¯·æˆ‘ä»¬ä½¿ç”¨æˆ‘ä»¬çš„å·¥å…·å’Œå®éªŒæ¥æµ‹è¯•ä»–ä»¬çš„å†…æ ¸ã€‚ LimitationsMANTAç›®å‰æœ‰ä»¥ä¸‹é™åˆ¶ã€‚ Static analysis is not sound ç”±äºè·¯å¾„ä¸æ•æ„Ÿçš„å‡½æ•°æ‘˜è¦ï¼ŒMANTAçš„åˆ†æå¯èƒ½ä¼šé”™è¿‡è®°è´¦ä¸¢å¤±çš„é”™è¯¯ã€‚å½“å‡½æ•°åœ¨å¦ä¸€æ¡æ‰§è¡Œè·¯å¾„ä¸Šå¯¹å·²åˆ†é…çš„é¡µè¿›è¡Œæ”¶è´¹æ—¶ï¼Œå®ƒå¯èƒ½ä¸ä¼šåœ¨å…¶ä¸­ä¸€æ¡æ‰§è¡Œè·¯å¾„ä¸Šå¯¹è¯¥é¡µæ”¶è´¹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒMANTAä»ç„¶å°†åŠŸèƒ½æ€»ç»“ä¸ºæ”¶è´¹ï¼Œå¹¶åœ¨ä»¥åçš„åˆ†æä¸­å¿½ç•¥ä¸¢å¤±å¸æˆ·çš„é”™è¯¯ã€‚ç›¸åï¼Œå¦‚æœMANTAå°†åŠŸèƒ½æ€»ç»“ä¸ºä¸æ”¶è´¹ï¼Œåˆ™ä¼šå¿½ç•¥å†—ä½™å¸æˆ·é”™è¯¯ã€‚åœ¨æœªæ¥ï¼Œæˆ‘ä»¬è®¡åˆ’é‡‡ç”¨åƒSATURNæ¡†æ¶è¿™æ ·çš„è·¯å¾„æ•æ„Ÿæ‘˜è¦æ¥æé«˜ç¨³å¥æ€§ã€‚ Dynamic triggerable test is not complete ç›®å‰ï¼ŒMANTAä½¿ç”¨LTPæµ‹è¯•ç”¨ä¾‹æ¥æµ‹è¯•æ˜¯å¦å¯ä»¥è§¦å‘é™æ€æ£€æµ‹é”™è¯¯ã€‚LTPæµ‹è¯•ç”¨ä¾‹æ˜¯æœ‰é™çš„ã€‚è¿™äº›æµ‹è¯•ç”¨ä¾‹ä¸å¯èƒ½æ¶µç›–å†…æ ¸ä¸­æ‰€æœ‰å¯èƒ½çš„æ‰§è¡Œè·¯å¾„ã€‚ å› æ­¤ï¼Œç”±äºä¸å®Œæ•´çš„ä»£ç è¦†ç›–ï¼ŒMANTAå¯èƒ½ä¼šé”™è¿‡ä¸€äº›å¯è§¦å‘çš„é”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æœªæ¥çš„å·¥ä½œä¹‹ä¸€æ˜¯å¼€å‘æ›´å¤šçš„æµ‹è¯•ç”¨ä¾‹ï¼Œå¹¶é‡‡ç”¨æ¨¡ç³Šæµ‹è¯•æŠ€æœ¯æ¥å¢åŠ ä»£ç è¦†ç›–ç‡ã€‚ RELATED WORKMemory AccountingJResä¸ºJVMå®ç°å†…å­˜è®¡è´¹æ¥å£ã€‚å†…å­˜è®°å¸æ¥å£åœ¨å¯¹è±¡åˆ†é…æœŸé—´æ”¶å–å†…å­˜ä½¿ç”¨è´¹ç”¨ï¼Œåœ¨åƒåœ¾æ”¶é›†æœŸé—´æ”¶å–è´¹ç”¨ã€‚ä½†æ˜¯ï¼ŒJResæ²¡æœ‰ä¸ºå…±äº«å¯¹è±¡å®ç°å……ç”µæœºåˆ¶ã€‚ Priceç­‰å’ŒMzSchemä¸ºç”¨æˆ·ç©ºé—´è¿è¡Œæ—¶ç¯å¢ƒæå‡ºäº†åŸºäºæ¶ˆè´¹è€…çš„å†…å­˜è®¡è´¹æ–¹æ¡ˆï¼Œä»¥è®¡ç®—å­ä»»åŠ¡çš„å†…å­˜ä½¿ç”¨æƒ…å†µã€‚å®ƒä»¬é€‰æ‹©å‘å®é™…ç”¨æˆ·æ”¶å–å†…å­˜ä½¿ç”¨è´¹ç”¨ï¼Œè€Œä¸æ˜¯å‘å†…å­˜åˆ†é…å™¨æ”¶å–ã€‚å®ƒä»¬ä¿®æ”¹è¿è¡Œæ—¶åƒåœ¾æ”¶é›†å™¨ï¼Œä»¥ä¾¿å®ƒå¯ä»¥åœ¨é‡Šæ”¾å¯¹è±¡ä¹‹å‰é‡Šæ”¾å¯¹è±¡ï¼Œå¹¶å°†å…¶é‡æ–°å……å€¼åˆ°ä¿å­˜å…¶å¼•ç”¨çš„å®ä½“ä¸­ã€‚ç„¶è€Œï¼Œç”±äºåœ¨å†…æ ¸ä¸­å®ç°è¶³å¤Ÿé«˜æ•ˆçš„åƒåœ¾æ”¶é›†ä»ç„¶æ˜¯ä¸€ä¸ªæŒ‘æˆ˜ï¼Œå› æ­¤å¾ˆéš¾åœ¨å†…æ ¸ä¸­ç›´æ¥é‡‡ç”¨å®ƒä»¬ã€‚åŸºäºvmçš„å·¥ä½œæä¾›äº†æ›´å¥½çš„å†…å­˜éš”ç¦»ï¼Œå¹¶ä¸”å¯ä»¥è§£å†³å•ç‰‡å†…æ ¸ä¸­çš„æ¯ä¸ªè¿›ç¨‹è®°å¸é—®é¢˜ã€‚ç„¶è€Œï¼Œä¼ ç»Ÿçš„åŸºäºvmçš„æ–¹æ¡ˆè¿‡äºé‡é‡çº§ï¼Œå¹¶ä¸”å¼•å…¥äº†å¾ˆé«˜çš„æ€§èƒ½å¼€é”€ã€‚ä¸åŸºäºå®¹å™¨çš„æ–¹æ¡ˆç›¸æ¯”ï¼ŒåŸºäºunikernelçš„æ–¹æ³•å®ç°äº†æ›´ä½çš„å¯åŠ¨å»¶è¿Ÿå’Œæ›´é«˜çš„ååé‡ï¼Œä½†ç¼ºä¹å…¼å®¹æ€§ã€‚ MANTAçš„åˆ†é…-å……ç”µæ˜ å°„åˆ†æç±»ä¼¼äºå†…å­˜æ³„æ¼æ£€æµ‹ä¸­ä½¿ç”¨çš„åˆ†é…-è‡ªç”±æ˜ å°„åˆ†æã€‚æ³„æ¼æ£€æŸ¥å™¨ä½¿ç”¨ä¸Šä¸‹æ–‡å’Œè·¯å¾„æ•æ„Ÿçš„åˆ†ææ–¹æ³•æ¥æ£€æµ‹å†…å­˜æ³„æ¼ã€‚Saberå’ŒFaskCheckä½¿ç”¨æŒ‰éœ€ç¨€ç–ä»·å€¼æµåˆ†ææ¥æ£€æµ‹å†…å­˜æ³„æ¼ã€‚LeakFixé¦–å…ˆå°è¯•å®šä½å¯¼è‡´æ³„æ¼çš„ç©ºé—²å†…å­˜å¹¶ä¿®å¤å®ƒã€‚AutoFixé€šè¿‡ç»“åˆé™æ€åˆ†æå’Œè¿è¡Œæ—¶æ£€æŸ¥æ¥æ£€æµ‹å’Œä¿®å¤å†…å­˜æ³„æ¼ã€‚PCAä½¿ç”¨é€‰æ‹©æ€§æµæ•æ„Ÿç®—æ³•è¿›ä¸€æ­¥åŠ å¿«ç¨‹åºé—´æ•°æ®æµåˆ†æçš„å†…å­˜æ³„æ¼æ£€æµ‹ã€‚ç„¶è€Œï¼Œè¿™äº›å·¥ä½œä¾èµ–äºæ‰‹åŠ¨è¾“å…¥æˆ–ç‰¹å®šçš„å¯å‘å¼æ¥å†³å®šåˆ†é…&#x2F;é‡Šæ”¾æ¥å£ï¼Œè¿™ä¸èƒ½åº”ç”¨äºè¯†åˆ«å†…å­˜è®¡è´¹æ¥å£ã€‚ Resource AccountingHoudiniçš„escapeåˆ©ç”¨å†…æ ¸ä¸‹åŠéƒ¨åˆ†çš„å·¥ä½œçº¿ç¨‹ã€æœåŠ¡è¿›ç¨‹å’Œä¸­æ–­æ¥ç»•è¿‡æ§åˆ¶ç»„çš„é™åˆ¶ã€‚ç„¶è€Œï¼Œå®ƒæ²¡æœ‰å…³æ³¨memcgï¼Œä¹Ÿæ²¡æœ‰åˆ†æå¯¹ç…§ç»„çš„å®æ–½æƒ…å†µã€‚å¯¹æ¯”èƒ¡è¿ªå°¼çš„è¶Šç‹±ï¼Œæˆ‘ä»¬ç³»ç»Ÿåœ°å®šä¹‰äº†memcgä¸­å¯èƒ½å­˜åœ¨çš„é—®é¢˜ï¼Œè¯†åˆ«å¹¶æŠ¥å‘Šäº†memcgä¸­çš„53ä¸ªbugã€‚Yangç­‰æå‡ºäº†æŠ½è±¡èµ„æºçš„æ¦‚å¿µï¼Œå¹¶å‘ç°åœ¨å®¹å™¨å†…è€—å°½è¿™äº›èµ„æºä¼šå¯¼è‡´å¯¹ä¸»æœºçš„DoSæ”»å‡»ã€‚èµ„æºå®¹å™¨æå‡ºäº†ä¸€ä¸ªæ“ä½œç³»ç»Ÿçº§åˆ«çš„æŠ½è±¡æ¥è€ƒè™‘æ•´ä¸ªç³»ç»Ÿçš„èµ„æºä½¿ç”¨æƒ…å†µã€‚å®ƒæ˜¯æè¿°åœ¨æ¯ä¸ªçº¿ç¨‹çº§åˆ«è®¡ç®—ä¸€èˆ¬èµ„æºçš„æ–¹æ³•çš„ç¬¬ä¸€æœ¬ä¹¦ã€‚ä¸ä»¥å‰çš„å·¥ä½œç›¸æ¯”ï¼Œèµ„æºå®¹å™¨å·¥ä½œåœ¨ç³»ç»Ÿå†…æ ¸ä¸Šï¼Œå¯ä»¥è§£å†³ç”±ç”¨æˆ·çº¿ç¨‹å¼•èµ·çš„å†…æ ¸èµ„æºæ¶ˆè€—ã€‚Zhangç­‰æå‡ºå°†å†…æ ¸ä¸‹åŠè¿›ç¨‹çš„cpuæ—¶é—´ä½¿ç”¨æ”¶è´¹ç»™å—å½±å“çš„ç”¨æˆ·è¿›ç¨‹ï¼Œä»¥æé«˜å…¬å¹³æ€§ã€‚ Perezç­‰äººè§‚å¯Ÿåˆ°EVMçš„æ°”ä½“è®¡é‡ä¸å·¥ä½œèŠ‚ç‚¹ä¸Šçš„å®é™…èµ„æºæ¶ˆè€—ï¼Œç‰¹åˆ«æ˜¯CPUå‘¨æœŸä¸ä¸€è‡´ã€‚å®ƒè¡¨æ˜ï¼Œå½“é¡µé¢ç¼“å­˜å·¥ä½œä¸ä½³æ—¶ï¼Œå®é™…çš„ä¸ä¸€è‡´æ€§ä¼šè¿›ä¸€æ­¥å¢åŠ ï¼Œè€Œæ”¯ä»˜è€…åˆ™è¦ä¸ºç›¸åŒæ•°é‡çš„gasä»˜è´¹ã€‚æœ¬æ–‡è¿˜æå‡ºäº†ä¸€ç§èƒ½å¤Ÿå……åˆ†åˆ©ç”¨ä¸ä¸€è‡´æ€§çš„è‡ªåŠ¨åˆæˆæœ‰æ•ˆè½½è·çš„æ–¹æ³•ã€‚Liuå‘ç°CPUæ—¶é—´è®¡é‡åœ¨å„ç§çœŸå®çš„äº‘å¹³å°ä¸Šéƒ½å¾ˆè„†å¼±ã€‚ä»–ä»¬æå‡ºäº†6ç§å¯ä»¥åˆ©ç”¨è¿›ç¨‹å¯åŠ¨æ—¶æˆ–è¿è¡Œæ—¶çš„CPUè®¡é‡çš„æ”»å‡»ã€‚ CONCLUSION AND FUTURE WORKæœ¬æ–‡é¦–æ¬¡ç³»ç»Ÿåœ°åˆ†æå’Œæ£€æµ‹äº†Linuxç³»ç»Ÿä¸­å­˜åœ¨çš„å†…å­˜è®°è´¦ç¼ºå¤±é—®é¢˜ã€‚æˆ‘ä»¬è¿›è¡Œäº†æ·±å…¥çš„åˆ†æï¼Œä»¥äº†è§£å®¹å™¨å¹³å°ä¸Šå†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯çš„å¯åˆ©ç”¨æ€§å’Œå®‰å…¨å½±å“ã€‚ æˆ‘ä»¬çš„åˆ†æè¡¨æ˜ï¼Œæ‰€æœ‰å®¹å™¨è¿è¡Œæ—¶(åŒ…æ‹¬æ­£å¸¸è¿è¡Œæ—¶å’Œå®‰å…¨è¿è¡Œæ—¶)éƒ½å®¹æ˜“å—åˆ°ç”±è®°è´¦ä¸¢å¤±é”™è¯¯å¯¼è‡´çš„å†…å­˜è€—å°½æ”»å‡»ã€‚æ­¤å¤–ï¼Œå†…å­˜è®°è´¦ä¸¢å¤±æ¼æ´å¯ä»¥è¢«åˆ©ç”¨æ¥æ”»å‡»Dockerã€CaaSå’ŒFaaSå¹³å°ï¼Œå¯¼è‡´å†…å­˜è€—å°½ï¼Œä»è€Œå¯¼è‡´èŠ‚ç‚¹ç”šè‡³æ•´ä¸ªé›†ç¾¤å´©æºƒã€‚ ç„¶åï¼Œæˆ‘ä»¬æå‡ºäº†MANTAï¼Œå®ƒç»“åˆäº†é™æ€å’ŒåŠ¨æ€åˆ†ææŠ€æœ¯ï¼Œä»¥é«˜ä»£ç è¦†ç›–ç‡å’Œç²¾åº¦è‡ªåŠ¨æ£€æµ‹å†…å­˜è®°è´¦ä¸¢å¤±é”™è¯¯ã€‚æˆ‘ä»¬çš„æ£€æµ‹å·¥å…·æŠ¥å‘Šäº†53ä¸ªå¯åˆ©ç”¨çš„å†…å­˜ä¸¢å¤±å¸æˆ·é”™è¯¯ï¼Œå…¶ä¸­37ä¸ªå·²è¢«å†…æ ¸å¼€å‘äººå‘˜ç¡®è®¤ï¼Œåˆ†é…äº†ä¸¤ä¸ªæ–°çš„cveã€‚ç»“æœè¡¨æ˜ï¼ŒMANTAå¯ä»¥æœ‰æ•ˆåœ°ç¼“è§£å†…å­˜è®°å¸ç³»ç»Ÿä¸­çš„è®°è´¦ä¸¢å¤±é—®é¢˜ã€‚ æˆ‘ä»¬æœªæ¥çš„å·¥ä½œæ˜¯ç ”ç©¶å¦‚ä½•åœ¨ä¸è°ƒè§£æ‰€æœ‰å†…å­˜åˆ†é…&#x2F;è‡ªç”±è·¯å¾„çš„æƒ…å†µä¸‹å‡†ç¡®åœ°è®¡ç®—å†…å­˜ä½¿ç”¨æƒ…å†µã€‚","categories":[{"name":"è®ºæ–‡ç²¾è¯»","slug":"è®ºæ–‡ç²¾è¯»","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"å†…æ ¸å®‰å…¨","slug":"è®ºæ–‡ç²¾è¯»/å†…æ ¸å®‰å…¨","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"C++ å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ åº“","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-åº“","date":"2023-04-22T02:39:33.000Z","updated":"2023-05-14T07:19:46.476Z","comments":true,"path":"2023/04/22/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-åº“/","link":"","permalink":"http://example.com/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/","excerpt":"ä»€ä¹ˆæ˜¯åº“ åº“æ–‡ä»¶æ˜¯è®¡ç®—æœºä¸Šçš„ä¸€ç±»æ–‡ä»¶ï¼Œå¯ä»¥ç®€å•çš„æŠŠåº“æ–‡ä»¶çœ‹æˆä¸€ç§ä»£ç ä»“åº“ï¼Œå®ƒæä¾›ç»™ä½¿ç”¨è€…ä¸€äº›å¯ä»¥ç›´æ¥æ‹¿æ¥ç”¨çš„å˜é‡ã€‚ åº“æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç¨‹åºï¼Œç¼–å†™åº“çš„ç¨‹åºå’Œç¼–å†™ä¸€èˆ¬çš„ç¨‹åºåŒºåˆ«ä¸å¤§ï¼Œåªæ˜¯åº“ä¸èƒ½å•ç‹¬è¿è¡Œã€‚ åº“æ–‡ä»¶æœ‰ä¸¤ç§ï¼šé™æ€åº“å’ŒåŠ¨æ€åº“ï¼ˆå…±äº«åº“ï¼‰ï¼ŒåŒºåˆ«æ˜¯ï¼šé™æ€åº“åœ¨ç¨‹åºçš„è¿æ¥é˜¶æ®µè¢«å¤åˆ¶åˆ°äº†ç¨‹åºä¸­ï¼›åŠ¨æ€åº“åœ¨è¿æ¥é˜¶æ®µæ²¡æœ‰è¢«å¤åˆ¶åˆ°ç¨‹åºï¼Œè€Œæ˜¯ç¨‹åºåœ¨è¿è¡Œæ—¶ç”±ç³»ç»ŸåŠ¨æ€åŠ è½½åˆ°å†…å­˜ä¸­ä¾›ç¨‹åºè°ƒç”¨ åº“çš„å¥½å¤„ï¼š1ã€ä»£ç ä¿å¯† 2ã€æ–¹ä¾¿éƒ¨ç½²å’Œåˆ†å‘ å‘½åè§„åˆ™ Linux:libXXX.a lib:å‰ç¼€ï¼ˆå›ºå®šï¼‰ XXXï¼šåº“çš„åå­—ï¼Œè‡ªå·±èµ· .aï¼šåç¼€ï¼ˆå›ºå®šï¼‰ Windowsï¼šlibXXX.lib é™æ€åº“çš„åˆ¶ä½œ gccè·å¾—.oæ–‡ä»¶ å°†.oæ–‡ä»¶æ‰“åŒ…ï¼Œä½¿ç”¨arå·¥å…·ï¼ˆarchiveï¼‰ 1ar rcs libxxx.a xxx.o xxx.o","text":"ä»€ä¹ˆæ˜¯åº“ åº“æ–‡ä»¶æ˜¯è®¡ç®—æœºä¸Šçš„ä¸€ç±»æ–‡ä»¶ï¼Œå¯ä»¥ç®€å•çš„æŠŠåº“æ–‡ä»¶çœ‹æˆä¸€ç§ä»£ç ä»“åº“ï¼Œå®ƒæä¾›ç»™ä½¿ç”¨è€…ä¸€äº›å¯ä»¥ç›´æ¥æ‹¿æ¥ç”¨çš„å˜é‡ã€‚ åº“æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç¨‹åºï¼Œç¼–å†™åº“çš„ç¨‹åºå’Œç¼–å†™ä¸€èˆ¬çš„ç¨‹åºåŒºåˆ«ä¸å¤§ï¼Œåªæ˜¯åº“ä¸èƒ½å•ç‹¬è¿è¡Œã€‚ åº“æ–‡ä»¶æœ‰ä¸¤ç§ï¼šé™æ€åº“å’ŒåŠ¨æ€åº“ï¼ˆå…±äº«åº“ï¼‰ï¼ŒåŒºåˆ«æ˜¯ï¼šé™æ€åº“åœ¨ç¨‹åºçš„è¿æ¥é˜¶æ®µè¢«å¤åˆ¶åˆ°äº†ç¨‹åºä¸­ï¼›åŠ¨æ€åº“åœ¨è¿æ¥é˜¶æ®µæ²¡æœ‰è¢«å¤åˆ¶åˆ°ç¨‹åºï¼Œè€Œæ˜¯ç¨‹åºåœ¨è¿è¡Œæ—¶ç”±ç³»ç»ŸåŠ¨æ€åŠ è½½åˆ°å†…å­˜ä¸­ä¾›ç¨‹åºè°ƒç”¨ åº“çš„å¥½å¤„ï¼š1ã€ä»£ç ä¿å¯† 2ã€æ–¹ä¾¿éƒ¨ç½²å’Œåˆ†å‘ å‘½åè§„åˆ™ Linux:libXXX.a lib:å‰ç¼€ï¼ˆå›ºå®šï¼‰ XXXï¼šåº“çš„åå­—ï¼Œè‡ªå·±èµ· .aï¼šåç¼€ï¼ˆå›ºå®šï¼‰ Windowsï¼šlibXXX.lib é™æ€åº“çš„åˆ¶ä½œ gccè·å¾—.oæ–‡ä»¶ å°†.oæ–‡ä»¶æ‰“åŒ…ï¼Œä½¿ç”¨arå·¥å…·ï¼ˆarchiveï¼‰ 1ar rcs libxxx.a xxx.o xxx.o r å°†æ–‡ä»¶æ’å…¥å¤‡å­˜æ–‡ä»¶ä¸­ c å»ºç«‹å¤‡å­˜æ–‡ä»¶ s ç´¢å¼• é™æ€åº“çš„åˆ¶ä½œæˆ‘ä»¬ç°åœ¨æœ‰å¦‚ä¸‹æ–‡ä»¶ï¼š é¦–å…ˆæˆ‘ä»¬å°†å…¶ç¼–è¯‘ä¸º.oæ–‡ä»¶ï¼Œè¿è¡Œå¦‚ä¸‹å‘½ä»¤ï¼š 1gcc -c add.c div.c mult.c sub.c ç»“æœå¦‚ä¸‹ï¼š è¾“å…¥å‘½ä»¤åˆ¶ä½œé™æ€åº“ï¼š 1ar rcs libcalc.a add.o sub.o mult.o div.o æˆ‘ä»¬ç”Ÿæˆé™æ€åº“æ–‡ä»¶å¦‚ä¸‹ï¼š é™æ€åº“çš„ä½¿ç”¨å¦‚å›¾æ‰€ç¤ºï¼Œåœ¨æ–‡ä»¶å¤¹é‡Œæˆ‘ä»¬æœ‰å¦‚ä¸‹æ–‡ä»¶ï¼š æˆ‘ä»¬ä»å¤´ç¼–è¯‘é™æ€åº“æ–‡ä»¶ æˆ‘ä»¬åœ¨.&#x2F;libraryæ–‡ä»¶å¤¹ä¸‹ä¾æ¬¡è¿è¡Œå¦‚ä¸‹å‘½ä»¤ 1cd src 1gcc -c add.c div.c mult.c sub.c -I ../include/ 1ar rcs libcalc.a add.o div.o mult.o sub.o 1mv libcalc.a ../lib/ 1cd .. 1gcc main,c -o app -I ./include/ -L ./lib/ -l calc æ‰§è¡Œå®Œä¸Šè¿°æ‰€æœ‰æŒ‡ä»¤åæˆ‘ä»¬è¿è¡Œï¼š 1tree å¦‚å›¾æ‰€ç¤ºï¼š æˆ‘ä»¬è¿è¡Œä¸‹åˆ—å‘½ä»¤ï¼Œè¿è¡Œappæ–‡ä»¶ï¼š 1./app åŠ¨æ€åº“çš„åˆ¶ä½œä¸ä½¿ç”¨å‘½åè§„åˆ™ï¼š Linuxï¼šlibxxx.so lib: å‰ç¼€ï¼ˆå›ºå®šï¼‰ xxxï¼šåº“çš„åå­—ï¼Œè‡ªå·±èµ· .soï¼šåç¼€ï¼ˆå›ºå®šï¼‰ åœ¨Linuxä¸‹æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ Windowsï¼šlibxxx.dll åŠ¨æ€åº“çš„åˆ¶ä½œï¼š gccå¾—åˆ°.oæ–‡ä»¶ï¼Œå¾—åˆ°å’Œä½ç½®æ— å…³çš„ä»£ç  1gcc -c -fpic/-fPIC a.c b.c gccå¾—åˆ°åŠ¨æ€åº“ 1gcc -shared a.o b.o -o libcalc.so åˆ¶ä½œå¦‚å›¾æ‰€ç¤ºæˆ‘ä»¬æœ‰å¦‚ä¸‹æ–‡ä»¶ï¼Œæˆ‘ä»¬æŒ‰å¦‚ä¸‹å‘½ä»¤ä¾æ¬¡ç¼–è¯‘ï¼Œå¹¶ç”ŸæˆåŠ¨æ€åº“æ–‡ä»¶ï¼Œå°†åº“æ–‡ä»¶å¤åˆ¶åˆ°libæ–‡ä»¶å¤¹å†…ã€‚ 1gcc -c -fpic add.c div.c mult.c sub.c 1gcc -shared *.o -o libcalc.so å°†libcalc.soæ–‡ä»¶å¤åˆ¶åˆ°libæ–‡ä»¶å¤¹ä¸­ï¼Œæˆ‘ä»¬æœ‰å¦‚ä¸‹æ–‡ä»¶ï¼š åŠ¨æ€åº“çš„ä½¿ç”¨æˆ‘ä»¬ç¼–è¯‘main.cæ–‡ä»¶ 1gcc main.c -o main -I include/ -L lib/ -l calc è¿è¡Œmainæ–‡ä»¶ 1./main æŠ¥é”™ï¼ŒæŠ¥é”™ä¿¡æ¯å¦‚ä¸‹ï¼š åº“å·¥ä½œåŸç†é™æ€åº“ï¼šGCCè¿›è¡Œè¿æ¥æ—¶ï¼Œä¼šæŠŠé™æ€åº“ä¸­ä»£ç æ‰“åŒ…åˆ°å¯æ‰§è¡Œç¨‹åºä¸­ åŠ¨æ€åº“ï¼šGCCè¿›è¡Œè¿æ¥æ—¶ï¼ŒåŠ¨æ€åº“çš„ä»£ç ä¸ä¼šè¢«æ‰“åŒ…åˆ°å¯æ‰§è¡Œç¨‹åºä¸­ ç¨‹åºå¯åŠ¨ä¹‹åï¼ŒåŠ¨æ€åº“ä¼šè¢«åŠ¨æ€åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œé€šè¿‡lddï¼ˆlist dynamic dependenciesï¼‰å‘½ä»¤æ£€æŸ¥åŠ¨æ€åº“ä¾èµ–å…³ç³» å½“ç³»ç»ŸåŠ è½½å¯æ‰§è¡Œä»£ç æ—¶ï¼Œèƒ½å¤ŸçŸ¥é“å…¶æ‰€ä¾èµ–çš„åº“çš„åå­—ï¼Œä½†æ˜¯è¿˜éœ€è¦çŸ¥é“ç»å¯¹è·¯å¾„ã€‚æ­¤æ—¶å°±éœ€è¦ç³»ç»Ÿçš„åŠ¨æ€è½½å…¥å™¨æ¥è·å–è¯¥ç»å¯¹è·¯å¾„ã€‚å¯¹äºelfæ ¼å¼çš„å¯æ‰§è¡Œç¨‹åºï¼Œæ˜¯ç”±ld-linux.soæ¥å®Œæˆçš„ï¼Œå®ƒå…ˆåæœç´¢elfæ–‡ä»¶çš„DT_RPATHæ®µ-&gt;ç¯å¢ƒå˜é‡LD _LIBARAY_PATH-&gt;&#x2F;etc&#x2F;ld.so.cacheæ–‡ä»¶åˆ—è¡¨-&gt;&#x2F;lib&#x2F;,&#x2F;usr&#x2F;libç›®å½•æ‰¾åˆ°åº“æ–‡ä»¶åå°†å…¶è½½å…¥å†…å­˜ã€‚ åŠ¨æ€åº“åŠ è½½å¤±è´¥çš„åŸå› å’Œè§£å†³æ–¹æ³•æˆ‘ä»¬è¿è¡Œå‘½ä»¤ 1ldd main å‘ç°æˆ‘ä»¬è‡ªå·±å†™çš„libcalc.soåŠ¨æ€åº“æ‰¾ä¸åˆ° æ·»åŠ ç¯å¢ƒå˜é‡ï¼Œè¾“å…¥å‘½ä»¤ï¼š 1export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib æˆ‘ä»¬å†è¿è¡Œå‘½ä»¤ï¼š 1ldd main æˆ‘ä»¬æ‰‹åŠ¨è®¾ç½®äº†åŠ¨æ€åº“çš„è·¯å¾„ï¼Œä½†æ˜¯è¿™åªæ˜¯ä¸´æ—¶çš„ï¼Œå…³é—­ä¹‹åå†æ¬¡æ‰“å¼€å°±ä¼šå¤±æ•ˆ æˆ‘ä»¬è¿›å…¥åˆ°&#x2F;homeç›®å½•ä¸‹è¿è¡Œå‘½ä»¤ 1vim .bashrc ä¿®æ”¹.bashrcæ–‡ä»¶ï¼Œåœ¨æœ€åä¸€è¡Œæ’å…¥ 1LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib ä¿å­˜ä¹‹åé€€å‡ºï¼Œè¿è¡Œ 1source .bashrc åªè¦æ‰‹åŠ¨è®¾ç½®äº†åŠ¨æ€åº“çš„è·¯å¾„ï¼Œå°±å¯ä»¥è¿è¡Œ.&#x2F;main è¿˜å¯ä»¥é€šè¿‡ä¿®æ”¹&#x2F;etc&#x2F;ld.so.cacheæ–‡ä»¶ï¼Œå°†åŠ¨æ€åº“æ–‡ä»¶æ”¾å…¥&#x2F;lib&#x2F;ï¼Œ&#x2F;usr&#x2F;lib&#x2F; é™æ€åº“å’ŒåŠ¨æ€åº“çš„å¯¹æ¯”é™æ€åº“çš„ä¼˜ç¼ºç‚¹ä¼˜ç‚¹ é™æ€åº“è¢«æ‰“åŒ…åˆ°åº”ç”¨ç¨‹åºä¸­ï¼ŒåŠ è½½é€Ÿåº¦å¿« å‘å¸ƒç¨‹åºæ— é¡»æä¾›é™æ€åº“ï¼Œç§»æ¤æ–¹ä¾¿ ç¼ºç‚¹ æµªè´¹ç³»ç»Ÿèµ„æºï¼Œæµªè´¹å†…å­˜ æ›´æ–°ã€éƒ¨ç½²ã€å‘å¸ƒéº»çƒ¦ åŠ¨æ€åº“çš„ä¼˜ç¼ºç‚¹ä¼˜ç‚¹ å¯ä»¥å®ç°è¿›ç¨‹é—´èµ„æºå…±äº«ï¼ˆå…±äº«åº“ï¼‰ æ›´æ–°ã€éƒ¨ç½²ã€å‘å¸ƒç®€å• å¯ä»¥æ§åˆ¶ä½•æ—¶åŠ è½½åŠ¨æ€åº“ ç¼ºç‚¹ åŠ è½½é€Ÿåº¦æ¯”é™æ€åº“æ…¢ å‘å¸ƒç¨‹åºæ—¶éœ€è¦ä¾èµ–çš„åŠ¨æ€åº“","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"C++ å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ å¼€å‘ç¯å¢ƒæ­å»º","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-å¼€å‘ç¯å¢ƒæ­å»º","date":"2023-04-20T08:02:55.000Z","updated":"2023-05-14T07:16:41.987Z","comments":true,"path":"2023/04/20/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-å¼€å‘ç¯å¢ƒæ­å»º/","link":"","permalink":"http://example.com/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"å®‰è£…ç›¸å…³å·¥å…· Windows è™šæ‹Ÿæœº | Workstation Pro | VMware | CN Visual Studio Code Xshellå’ŒXftp æ¸…åå¤§å­¦Ubuntué•œåƒ é…ç½®è¿‡ç¨‹","text":"å®‰è£…ç›¸å…³å·¥å…· Windows è™šæ‹Ÿæœº | Workstation Pro | VMware | CN Visual Studio Code Xshellå’ŒXftp æ¸…åå¤§å­¦Ubuntué•œåƒ é…ç½®è¿‡ç¨‹é¦–å…ˆæ‰“å¼€ubuntuï¼Œå®‰è£…sshæœåŠ¡ç«¯ï¼Œè¾“å…¥æŒ‡ä»¤ 1sudo apt install openssh-server ä¹‹åæ‰“å¼€Xshell ç‚¹å‡»æ–°å»ºï¼Œå¦‚ä¸‹å›¾: åœ¨åç§°å¤„å¡«å†™è¿æ¥çš„åç§°ï¼Œåœ¨ä¸»æœºå¤„å¡«å†™Ubuntuçš„ipåœ°å€æ‰“å¼€Ubuntuï¼Œè¾“å…¥å‘½ä»¤ 1ifconfig å¾—åˆ°ipåœ°å€ä¸º192.168.194.129 ä¹‹åæˆ‘ä»¬ä½¿ç”¨Xshellè¿æ¥ï¼Œæ­¤æ—¶ä¼šè®©æˆ‘ä»¬å¡«å†™ç”¨æˆ·åå’Œå¯†ç ï¼Œæˆ‘ä»¬å¡«å†™Ubuntuçš„ç”¨æˆ·åå’Œå®ƒçš„å¯†ç å³å¯ ç„¶åæˆ‘ä»¬æ‰“å¼€VScodeï¼Œå®‰è£…æ‹“å±• ä¹‹åä¼šå‘ç°vscodeå¤šå‡ºä¸€ä¸ªè¿œç¨‹èµ„æºç®¡ç†å™¨ï¼Œæˆ‘ä»¬ç‚¹å‡»è¿œç¨‹èµ„æºç®¡ç†å™¨ï¼Œç„¶åæ‰“å¼€SSHï¼Œé…ç½®æ–‡ä»¶ï¼ŒC:\\Users\\zc\\ssh\\config 1234# Read more about SSH config files: https://linux.die.net/man/5/ssh_configHost Ubuntu-plucky å¡«å†™ä¸»æœºåï¼Œéšä¾¿èµ· HostName 192.168.194.129 Ubuntuçš„IPåœ°å€ User plucky Ubuntuçš„ç”¨æˆ·å ä¹‹åå°±å¯ä»¥è¿æ¥ä¸»æœºå’Œæ‰“å¼€æ–‡ä»¶å¤¹ é…ç½®SSHå…¬ç§é’¥å…å¯†ç™»å½•é¦–å…ˆåœ¨windowsä¸»æœºè¾“å…¥å‘½ä»¤ 1ssh-keygen -t rsa éšåæ‰€æœ‰è®¾ç½®éƒ½æŒ‰å›è½¦ æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç”¨æˆ·ç›®å½•ä¸‹ id_rsaä¸ºç§é’¥ï¼Œid_rsa.pubä¸ºå…¬é’¥ ä¹‹åæˆ‘ä»¬æ‰“å¼€Ubuntuï¼Œè¾“å…¥å‘½ä»¤ 1ssh-keygen -t rsa éšåæ‰€æœ‰è®¾ç½®éƒ½æŒ‰å›è½¦ ä¹‹å 1cd ./ssh 1vim authorized_keys å°†windowsä¸­çš„id_rsa.pubå¤åˆ¶è¿›authorized_keysä¸­ã€‚ ä¹‹åå°±å¯ä»¥å®ç°æ— å¯†ç™»å½•äº†","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture06 Isolation and system call entry/exit","slug":"MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit","date":"2023-04-20T06:13:04.000Z","updated":"2023-04-20T06:47:00.073Z","comments":true,"path":"2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/","link":"","permalink":"http://example.com/2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/","excerpt":"Trapæœºåˆ¶ç¨‹åºå®Œæˆç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´åˆ‡æ¢çš„æ—¶æœº ç¨‹åºæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ ç¨‹åºå‡ºç°äº†ç±»ä¼¼page faultï¼Œè¿ç®—æ—¶é™¤ä»¥0çš„é”™è¯¯ ä¸€ä¸ªè®¾å¤‡è§¦å‘äº†ä¸­æ–­ä½¿å¾—å½“å‰ç¨‹åºè¿è¡Œéœ€è¦ç›¸åº”å†…æ ¸è®¾å¤‡é©±åŠ¨","text":"Trapæœºåˆ¶ç¨‹åºå®Œæˆç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´åˆ‡æ¢çš„æ—¶æœº ç¨‹åºæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ ç¨‹åºå‡ºç°äº†ç±»ä¼¼page faultï¼Œè¿ç®—æ—¶é™¤ä»¥0çš„é”™è¯¯ ä¸€ä¸ªè®¾å¤‡è§¦å‘äº†ä¸­æ–­ä½¿å¾—å½“å‰ç¨‹åºè¿è¡Œéœ€è¦ç›¸åº”å†…æ ¸è®¾å¤‡é©±åŠ¨ Trapç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„åˆ‡æ¢é€šå¸¸è¢«ç§°ä¸ºtrap trapæ¶‰åŠäº†è®¸å¤šå°å¿ƒçš„è®¾è®¡å’Œé‡è¦çš„ç»†èŠ‚ï¼Œè¿™äº›ç»†èŠ‚å¯¹äºå®ç°å®‰å…¨éš”ç¦»å’Œæ€§èƒ½æ¥è¯´éå¸¸é‡è¦ã€‚å› ä¸ºå¾ˆå¤šåº”ç”¨ç¨‹åºï¼Œè¦ä¹ˆå› ä¸ºç³»ç»Ÿè°ƒç”¨ï¼Œè¦ä¹ˆå› ä¸ºpage faultï¼Œéƒ½ä¼šé¢‘ç¹çš„åˆ‡æ¢åˆ°å†…æ ¸ä¸­ã€‚æ‰€ä»¥ï¼Œtrapæœºåˆ¶è¦å°½å¯èƒ½çš„ç®€å•ï¼Œè¿™ä¸€ç‚¹éå¸¸é‡è¦ã€‚ æˆ‘ä»¬æœ‰ä¸€äº›ç”¨æˆ·åº”ç”¨ç¨‹åºï¼Œä¾‹å¦‚Shellï¼Œå®ƒè¿è¡Œåœ¨ç”¨æˆ·ç©ºé—´ï¼ŒåŒæ—¶æˆ‘ä»¬è¿˜æœ‰å†…æ ¸ç©ºé—´ã€‚Shellå¯èƒ½ä¼šæ‰§è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œå°†ç¨‹åºè¿è¡Œåˆ‡æ¢åˆ°å†…æ ¸ã€‚æ¯”å¦‚XV6å¯åŠ¨ä¹‹åShellè¾“å‡ºçš„ä¸€äº›æç¤ºä¿¡æ¯ï¼Œå°±æ˜¯é€šè¿‡æ‰§è¡Œwriteç³»ç»Ÿè°ƒç”¨æ¥è¾“å‡ºçš„ã€‚ å¯„å­˜å™¨æˆ‘ä»¬éœ€è¦æ¸…æ¥šå¦‚ä½•è®©ç¨‹åºçš„è¿è¡Œï¼Œä»åªæ‹¥æœ‰useræƒé™å¹¶ä¸”ä½äºç”¨æˆ·ç©ºé—´çš„Shellï¼Œåˆ‡æ¢åˆ°æ‹¥æœ‰supervisoræƒé™çš„å†…æ ¸ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œç¡¬ä»¶çš„çŠ¶æ€å°†ä¼šéå¸¸é‡è¦ï¼Œå› ä¸ºæˆ‘ä»¬å¾ˆå¤šçš„å·¥ä½œéƒ½æ˜¯å°†ç¡¬ä»¶ä»é€‚åˆè¿è¡Œç”¨æˆ·åº”ç”¨ç¨‹åºçš„çŠ¶æ€ï¼Œæ”¹å˜åˆ°é€‚åˆè¿è¡Œå†…æ ¸ä»£ç çš„çŠ¶æ€ã€‚ æ¯ä¸ª RISC-V CPUéƒ½æœ‰ä¸€ç»„æ§åˆ¶å¯„å­˜å™¨ï¼Œå†…æ ¸ä¼šå†™å…¥è¿™äº›å¯„å­˜å™¨ä»¥å‘Šè¯‰ CPU å¦‚ä½•å¤„ç†trapï¼Œå¹¶ä¸”å†…æ ¸å¯ä»¥è¯»å–è¿™äº›å¯„å­˜å™¨ä»¥äº†è§£å‘ç”Ÿçš„é™·é˜±ã€‚RISC-V æ–‡æ¡£åŒ…å«å®Œæ•´çš„ä¿¡æ¯ã€‚riscv.hï¼ˆkernel&#x2F;riscv.h:1ï¼‰åŒ…å« xv6 ä½¿ç”¨çš„å®šä¹‰ã€‚ä»¥ä¸‹æ˜¯æœ€é‡è¦çš„å‡ ä¸ªå¯„å­˜å™¨æ¦‚è¿°ï¼š Program Counter Register:ç¨‹åºè®¡æ•°å™¨ è¡¨æ˜å½“å‰modeçš„æ ‡å¿—ä½ï¼šè¿™ä¸ªæ ‡å¿—ä½è¡¨æ˜äº†å½“å‰æ˜¯supervisor modeè¿˜æ˜¯user modeã€‚å½“æˆ‘ä»¬åœ¨è¿è¡Œshellçš„æ—¶å€™ï¼Œè‡ªç„¶æ˜¯åœ¨user modeã€‚ SATPï¼ˆSupervisor Address Translation and Protectionï¼‰ï¼šåŒ…å«äº†æŒ‡å‘page tableçš„ç‰©ç†åœ°å€ STVECï¼ˆSupervisor Trap Vector Base Address Registerï¼‰ï¼šæŒ‡å‘å†…æ ¸ä¸­å¤„ç†trapæŒ‡ä»¤çš„èµ·å§‹åœ°å€ SEPCï¼ˆSupervisor Exception Program Counterï¼‰ï¼Œåœ¨trapçš„è¿‡ç¨‹ä¸­ä¿å­˜ç¨‹åºè®¡æ•°å™¨çš„å€¼ SSRATCHï¼ˆSupervisor Scratch Registerï¼‰å†…æ ¸åœ¨æ­¤å¤„æ”¾ç½®ä¸€ä¸ªå€¼ï¼Œåœ¨å¤„ç†ç¨‹åºå¼€å§‹æ—¶éå¸¸æ–¹ä¾¿ trapå¤„ç†è¿‡ç¨‹ä¸­çš„ä¸€äº›æ“ä½œåœ¨trapçš„æœ€å¼€å§‹ï¼ŒCPUçš„æ‰€æœ‰çŠ¶æ€éƒ½è®¾ç½®æˆè¿è¡Œç”¨æˆ·ä»£ç è€Œä¸æ˜¯å†…æ ¸ä»£ç ã€‚åœ¨trapå¤„ç†çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å®é™…ä¸Šéœ€è¦æ›´æ”¹ä¸€äº›è¿™é‡Œçš„çŠ¶æ€ï¼Œæˆ–è€…å¯¹çŠ¶æ€åšä¸€äº›æ“ä½œã€‚è¿™æ ·æˆ‘ä»¬æ‰å¯ä»¥è¿è¡Œç³»ç»Ÿå†…æ ¸ä¸­æ™®é€šçš„Cç¨‹åºã€‚æ¥ä¸‹æ¥æˆ‘ä»¬å…ˆæ¥é¢„è§ˆä¸€ä¸‹éœ€è¦åšçš„æ“ä½œï¼š é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä¿å­˜32ä¸ªç”¨æˆ·å¯„å­˜å™¨ã€‚å› ä¸ºå¾ˆæ˜¾ç„¶æˆ‘ä»¬éœ€è¦æ¢å¤ç”¨æˆ·åº”ç”¨ç¨‹åºçš„æ‰§è¡Œï¼Œå°¤å…¶æ˜¯å½“ç”¨æˆ·ç¨‹åºéšæœºçš„è¢«è®¾å¤‡ä¸­æ–­æ‰€æ‰“æ–­æ—¶ã€‚æˆ‘ä»¬å¸Œæœ›å†…æ ¸èƒ½å¤Ÿå“åº”ä¸­æ–­ï¼Œä¹‹ååœ¨ç”¨æˆ·ç¨‹åºå®Œå…¨æ— æ„ŸçŸ¥çš„æƒ…å†µä¸‹å†æ¢å¤ç”¨æˆ·ä»£ç çš„æ‰§è¡Œã€‚æ‰€ä»¥è¿™æ„å‘³ç€32ä¸ªç”¨æˆ·å¯„å­˜å™¨ä¸èƒ½è¢«å†…æ ¸å¼„ä¹±ã€‚ä½†æ˜¯è¿™äº›å¯„å­˜å™¨åˆè¦è¢«å†…æ ¸ä»£ç æ‰€ä½¿ç”¨ï¼Œæ‰€ä»¥åœ¨trapä¹‹å‰ï¼Œä½ å¿…é¡»å…ˆåœ¨æŸå¤„ä¿å­˜è¿™32ä¸ªç”¨æˆ·å¯„å­˜å™¨ã€‚ PC(ç¨‹åºè®¡æ•°å™¨)ä¹Ÿéœ€è¦åœ¨æŸä¸ªåœ°æ–¹ä¿å­˜ï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤Ÿåœ¨ç”¨æˆ·ç¨‹åºè¿è¡Œä¸­æ–­çš„ä½ç½®ç»§ç»­æ‰§è¡Œç”¨æˆ·ç¨‹åº æˆ‘ä»¬éœ€è¦å°†modeæ”¹ä¸ºsupervisor modeï¼Œå› ä¸ºæˆ‘ä»¬æƒ³è¦ä½¿ç”¨å†…æ ¸ä¸­å„ç§å„æ ·çš„æŒ‡ä»¤ SATPå¯„å­˜å™¨ç°åœ¨æ­£æŒ‡å‘user page tableï¼Œè€Œuser page tableåªåŒ…å«äº†ç”¨æˆ·ç¨‹åºæ‰€éœ€è¦çš„å†…å­˜æ˜ å°„å’Œä¸€ä¸¤ä¸ªå…¶ä»–çš„æ˜ å°„ï¼Œå®ƒå¹¶æ²¡æœ‰åŒ…å«æ•´ä¸ªå†…æ ¸æ•°æ®çš„å†…å­˜æ˜ å°„ï¼Œæ‰€ä»¥åœ¨è¿è¡Œå†…æ ¸ä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å°†SATPæŒ‡å‘kernel page tableã€‚ æˆ‘ä»¬éœ€è¦å°†å †æ ˆå¯„å­˜å™¨æŒ‡å‘ä½äºå†…æ ¸çš„ä¸€ä¸ªåœ°å€ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå †æ ˆæ¥è°ƒç”¨å†…æ ¸çš„Cå‡½æ•° ä¸€æ—¦æˆ‘ä»¬éƒ½è®¾ç½®å¥½äº†ï¼Œå¹¶ä¸”æ‰€æœ‰çš„ç¡¬ä»¶çŠ¶æ€éƒ½é€‚åˆåœ¨å†…æ ¸ä¸­ä½¿ç”¨ï¼Œæˆ‘ä»¬éœ€è¦è·³å…¥å†…æ ¸çš„Cä»£ç ","categories":[{"name":"è¯¾ç¨‹å­¦ä¹ ","slug":"è¯¾ç¨‹å­¦ä¹ ","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"è¯¾ç¨‹å­¦ä¹ /MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++å­¦ä¹  ç±»ä¸å¯¹è±¡","slug":"C++-å­¦ä¹ -ç±»ä¸å¯¹è±¡","date":"2023-04-16T12:31:16.000Z","updated":"2023-05-09T08:11:27.363Z","comments":true,"path":"2023/04/16/C++-å­¦ä¹ -ç±»ä¸å¯¹è±¡/","link":"","permalink":"http://example.com/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"C++é¢å‘å¯¹è±¡ä¸‰å¤§ç‰¹æ€§ï¼šå°è£…ã€ç»§æ‰¿ã€å¤šæ€ C++è®¤ä¸ºä¸‡äº‹ä¸‡ç‰©éƒ½çš†ä¸ºå¯¹è±¡ï¼Œå¯¹è±¡ä¸Šæœ‰å…¶å±æ€§å’Œè¡Œä¸º ä¾‹å¦‚ï¼š","text":"C++é¢å‘å¯¹è±¡ä¸‰å¤§ç‰¹æ€§ï¼šå°è£…ã€ç»§æ‰¿ã€å¤šæ€ C++è®¤ä¸ºä¸‡äº‹ä¸‡ç‰©éƒ½çš†ä¸ºå¯¹è±¡ï¼Œå¯¹è±¡ä¸Šæœ‰å…¶å±æ€§å’Œè¡Œä¸º ä¾‹å¦‚ï¼š äººå¯ä»¥ä½œä¸ºå¯¹è±¡ï¼Œå±æ€§æœ‰å§“åã€å¹´é¾„ã€èº«é«˜ã€ä½“é‡â€¦..ï¼Œè¡Œä¸ºæœ‰èµ°ã€è·‘ã€è·³â€¦â€¦ å…·æœ‰ç›¸åŒæ€§è´¨çš„å¯¹è±¡ï¼Œæˆ‘ä»¬å¯ä»¥æŠ½è±¡ç§°ä¸ºç±»ï¼Œäººå±äºäººç±»ï¼Œè½¦å±äºè½¦ç±» å°è£…å°è£…çš„æ„ä¹‰å°è£…æ˜¯C++é¢å‘å¯¹è±¡ä¸‰å¤§ç‰¹æ€§ä¹‹ä¸€ å°è£…çš„æ„ä¹‰ï¼š å°†å±æ€§å’Œè¡Œä¸ºä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼Œè¡¨ç°ç”Ÿæ´»ä¸­çš„äº‹ç‰© å°†å±æ€§å’Œè¡Œä¸ºåŠ ä»¥æƒé™æ§åˆ¶ å°è£…çš„æ„ä¹‰ä¸€åœ¨è®¾è®¡ç±»çš„æ—¶å€™ï¼Œå±æ€§å’Œè¡Œä¸ºå†™åœ¨ä¸€èµ·ï¼Œè¡¨ç°äº‹ç‰© è¯­æ³•ï¼šclass ç±»å &#123; è®¿é—®æƒé™ : å±æ€§ / è¡Œä¸º &#125;; ç¤ºä¾‹ä¸€ï¼š 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const double PI = 3.14;//è®¾è®¡ä¸€ä¸ªåœ†ç±»ï¼Œæ±‚åœ†çš„å‘¨é•¿//åœ†æ±‚å‘¨é•¿çš„å…¬å¼ï¼š2*PI*åŠå¾„//classä»£è¡¨è®¾è®¡ä¸€ä¸ªç±»ï¼Œç±»åé¢ç´§è·Ÿç€çš„å°±æ˜¯ç±»åç§°class Circle&#123; //è®¿é—®æƒé™ //å…¬å…±æƒé™public: //å±æ€§ //åŠå¾„ int m_r; //è¡Œä¸º //è·å–åœ†çš„å‘¨é•¿ double calculateZC() &#123; return 2 * PI * m_r; &#125;&#125;;int main()&#123; //é€šè¿‡åœ†ç±» åˆ›å»ºå…·ä½“çš„åœ† ï¼ˆå¯¹è±¡ï¼‰ Circle c1; //ç»™åœ†å¯¹è±¡çš„å±æ€§è¿›è¡Œèµ‹å€¼ c1.m_r = 10; cout &lt;&lt; &quot;åœ†çš„å‘¨é•¿ä¸ºï¼š&quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š åœ†çš„å‘¨é•¿ä¸ºï¼š62.8 ç¤ºä¾‹äºŒï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const double PI = 3.14;//è®¾è®¡ä¸€ä¸ªå­¦ç”Ÿç±»ï¼Œå±æ€§å…·æœ‰å§“åå’Œå­¦å·//å¯ä»¥ç»™å§“åå’Œå­¦å·èµ‹å€¼ï¼Œå¯ä»¥æ˜¾ç¤ºå­¦ç”Ÿçš„å§“åå’Œå­¦å·//è®¾è®¡å­¦ç”Ÿç±»class Student&#123; //è®¿é—®æƒé™ //å…¬å…±æƒé™public: //å±æ€§ //å§“åå’Œå­¦å· string m_Name;//å§“å int m_id;//å­¦å· //è¡Œä¸º //æ˜¾ç¤ºå§“åå’Œå­¦å· void showStudent() &#123; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; m_Name &lt;&lt; &quot; å­¦å·ï¼š&quot; &lt;&lt; m_id &lt;&lt; endl; &#125; //ç»™å§“åèµ‹å€¼ void setName(string name) &#123; m_Name = name; &#125; void setId(int id) &#123; m_id = id; &#125;&#125;;int main()&#123; //åˆ›å»ºä¸€ä¸ªå…·ä½“å­¦ç”Ÿ å®ä¾‹åŒ–å¯¹è±¡ Student s1; Student s2; //ç»™S1å¯¹è±¡ è¿›è¡Œå±æ€§å¤åˆ¶æ“ä½œ s1.setName(&quot;å¼ ä¸‰&quot;); s1.setId(1); s2.m_Name = &quot;æå››&quot;; s2.m_id = 2; s1.showStudent(); s2.showStudent();&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åï¼š å¼ ä¸‰ å­¦å·ï¼š1å§“åï¼š æå›› å­¦å·ï¼š2 å°è£…çš„æ„ä¹‰äºŒç±»åœ¨è®¾è®¡æ—¶ï¼Œå¯ä»¥æŠŠå±æ€§å’Œè¡Œä¸ºæ”¾åœ¨ä¸åŒçš„æƒé™ä¸‹ï¼ŒåŠ ä»¥æ§åˆ¶ è®¿é—®æƒé™æœ‰ä¸‰ç§ï¼š public å…¬å…±æƒé™ protected ä¿æŠ¤æƒé™ private ç§æœ‰æƒé™ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//è®¿é—®æƒé™//ä¸‰ç§//å…¬å…±æƒé™ public æˆå‘˜ ç±»å†…å¯ä»¥è®¿é—® ç±»å¤–å¯ä»¥è®¿é—® //ä¿æŠ¤æƒé™ protected æˆå‘˜ ç±»å†…å¯ä»¥è®¿é—® ç±»å¤–ä¸å¯ä»¥è®¿é—® å„¿å­ä¹Ÿå¯ä»¥è®¿é—®çˆ¶äº²ä¸­çš„ä¿æŠ¤å†…å®¹//ç§æœ‰æƒé™ private æˆå‘˜ ç±»å†…å¯ä»¥è®¿é—® ç±»å¤–ä¸å¯ä»¥è®¿é—® å„¿å­ä¸å¯ä»¥è®¿é—®çˆ¶äº²ä¸­çš„ç§æœ‰å†…å®¹class Person&#123; //å…¬å…±æƒé™public: string m_Name;//å§“åprotected: //ä¿æŠ¤æƒé™ string m_Car;//æ±½è½¦private: //ç§æœ‰æƒé™ int m_Password;//é“¶è¡Œå¡å¯†ç public: void func() &#123; m_Name = &quot;å¼ ä¸‰&quot;; m_Car = &quot;æ‹–æ‹‰æœº&quot;; m_Password = 123456; &#125;&#125;;int main()&#123; //å®ä¾‹åŒ–å…·ä½“å¯¹è±¡ Person p1; p1.m_Name = &quot;æå››&quot;; p1.m_Car = &quot;å¥”é©°&quot;; p1.m_Password = 654321;&#125; structå’Œclassçš„åŒºåˆ«åœ¨C++ä¸­structå’Œclasså”¯ä¸€çš„åŒºåˆ«å°±åœ¨äºé»˜è®¤çš„è®¿é—®æƒé™ä¸åŒ åŒºåˆ«ï¼š structæƒé™é»˜è®¤ä¸ºå…¬å…± classæƒé™é»˜è®¤ä¸ºç§æœ‰ 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class C1&#123; int m_A;&#125;;struct C2&#123; int m_A;&#125;;int main()&#123; C1 c1; c1.m_A = 100; C2 c2; c2.m_A = 100;&#125; æˆå‘˜å±æ€§è®¾ç½®ä¸ºç§æœ‰ä¼˜ç‚¹1ï¼šå°†æ‰€æœ‰æˆå‘˜å±æ€§è®¾ç½®ä¸ºç§æœ‰ï¼Œå¯ä»¥è‡ªå·±æ§åˆ¶è¯»å†™æƒé™ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æˆå‘˜å±æ€§è®¾ç½®ä¸ºç§æœ‰//1ã€å¯ä»¥è‡ªå·±æ§åˆ¶è¯»å†™æƒé™//2ã€å¯¹äºå†™å¯ä»¥æ£€æµ‹æ•°æ®çš„æœ‰æ•ˆæ€§//è®¾è®¡äººç±»class Person&#123;public: //è®¾ç½®å§“å void setName(string name) &#123; m_Name = name; &#125; //è·å–å§“å string getName() &#123; return m_Name; &#125; //è·å–å¹´é¾„ åªè¯» int getAge() &#123; m_Age = 0; return m_Age; &#125; //è®¾ç½®æƒ…äºº åªå†™ void setLover(string lover) &#123; m_Lover = lover; &#125;private: //å§“å å¯è¯»å¯å†™ string m_Name; //å¹´é¾„ åªè¯» int m_Age; //æƒ…äºº åªå†™ string m_Lover;&#125;;int main() &#123; Person p; p.setName(&quot;å¼ ä¸‰&quot;); cout &lt;&lt; &quot;å§“åä¸ºï¼š &quot; &lt;&lt; p.getName() &lt;&lt; endl; cout &lt;&lt; &quot;å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p.getAge() &lt;&lt; endl; p.setLover(&quot;æå››&quot;); //æ— æ³•è®¿é—®&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åä¸ºï¼š å¼ ä¸‰å¹´é¾„ä¸ºï¼š0 ä¼˜ç‚¹2ï¼šå¯¹äºå†™æƒé™ï¼Œæˆ‘ä»¬å¯ä»¥æ£€æµ‹æ•°æ®çš„æœ‰æ•ˆæ€§ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æˆå‘˜å±æ€§è®¾ç½®ä¸ºç§æœ‰//1ã€å¯ä»¥è‡ªå·±æ§åˆ¶è¯»å†™æƒé™//2ã€å¯¹äºå†™å¯ä»¥æ£€æµ‹æ•°æ®çš„æœ‰æ•ˆæ€§//è®¾è®¡äººç±»class Person&#123;public: //è®¾ç½®å§“å void setName(string name) &#123; m_Name = name; &#125; //è·å–å§“å string getName() &#123; return m_Name; &#125; //è·å–å¹´é¾„ å¯è¯»å¯å†™ å¦‚æœæƒ³ä¿®æ”¹ï¼ˆå¹´é¾„çš„èŒƒå›´å¿…é¡»æ˜¯0~150ä¹‹é—´ï¼‰ int getAge() &#123; return m_Age; &#125; //è®¾ç½®åå­— void setAge(int age) &#123; if (age &lt; 0 || age &gt;150) &#123; cout &lt;&lt; &quot;å¹´é¾„é”™è¯¯&quot; &lt;&lt; endl; return; &#125; m_Age = age; &#125; //è®¾ç½®æƒ…äºº åªå†™ void setLover(string lover) &#123; m_Lover = lover; &#125;private: //å§“å å¯è¯»å¯å†™ string m_Name; //å¹´é¾„ åªè¯» int m_Age; //æƒ…äºº åªå†™ string m_Lover;&#125;;int main() &#123; Person p; p.setName(&quot;å¼ ä¸‰&quot;); cout &lt;&lt; &quot;å§“åä¸ºï¼š &quot; &lt;&lt; p.getName() &lt;&lt; endl; p.setAge(1000); cout &lt;&lt; &quot;å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p.getAge() &lt;&lt; endl; p.setLover(&quot;æå››&quot;); //æ— æ³•è®¿é—®&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åä¸ºï¼š å¼ ä¸‰å¹´é¾„é”™è¯¯å¹´é¾„ä¸ºï¼š-858993460 ç»ƒä¹ æ¡ˆä¾‹ä¸€è®¾è®¡ç«‹æ–¹ä½“ç±»ï¼ˆCubeï¼‰ æ±‚å‡ºç«‹æ–¹ä½“çš„é¢ç§¯å’Œä½“ç§¯ åˆ†åˆ«ç”¨å…¨å±€å‡½æ•°å’Œæˆå‘˜å‡½æ•°åˆ¤æ–­ä¸¤ä¸ªç«‹æ–¹ä½“æ˜¯å¦ç›¸ç­‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç«‹æ–¹ä½“ç±»è®¾è®¡//1ã€åˆ›å»ºç«‹æ–¹ä½“ç±»//2ã€åˆ›å»ºå±æ€§//3ã€è®¾è®¡è¡Œä¸º è·å–ç«‹æ–¹ä½“é¢ç§¯å’Œä½“ç§¯//4ã€åˆ†åˆ«åˆ©ç”¨å…¨å±€å‡½æ•°å’Œæˆå‘˜å‡½æ•° åˆ¤æ–­ä¸¤ä¸ªç«‹æ–¹ä½“æ˜¯å¦ç›¸ç­‰class Cube&#123;public: //è¡Œä¸º //è®¾ç½®è·å–é•¿å®½é«˜ // è®¾ç½®é•¿ void setL(int l) &#123; m_L = l; &#125; // è·å–é•¿ int getL() &#123; return m_L; &#125; // è®¾ç½®å®½ void setW(int w) &#123; m_W = w; &#125; // è·å–å®½ int getW() &#123; return m_W; &#125; // è®¾ç½®é«˜ void setH(int H) &#123; m_H = H; &#125; // è·å–é«˜ int getH() &#123; return m_H; &#125; // è·å–ç«‹æ–¹ä½“é¢ç§¯ int calculateS() &#123; return 2 * m_L * m_W + 2 * m_L * m_H + 2 * m_W * m_H; &#125; // è·å–ç«‹æ–¹ä½“ä½“ç§¯ int calculateV() &#123; return m_L * m_H * m_W; &#125; //åˆ©ç”¨æˆå‘˜å‡½æ•°åˆ¤æ–­ä¸¤ä¸ªç«‹æ–¹ä½“æ˜¯å¦ç›¸ç­‰ bool isSameByClass(Cube&amp; c) &#123; if (getL() == c.getL() &amp;&amp; getW() == c.getW() &amp;&amp; getH() == c.getH()) &#123; return true; &#125; else &#123; return false; &#125; &#125; //å±æ€§private: int m_L;//é•¿ int m_W;//å®½ int m_H;//é«˜&#125;;//åˆ©ç”¨å…¨å±€å‡½æ•°åˆ¤æ–­ ä¸¤ä¸ªç«‹æ–¹ä½“æ˜¯å¦ç›¸ç­‰bool isSame(Cube&amp; c1, Cube&amp; c2)&#123; if (c1.getL() == c2.getL() &amp;&amp; c1.getW() == c2.getW() &amp;&amp; c1.getH() == c2.getH()) return true; return false;&#125;int main()&#123; //åˆ›å»ºç«‹æ–¹ä½“å¯¹è±¡ Cube c1; c1.setL(10); c1.setW(10); c1.setH(10); cout &lt;&lt; &quot;c1çš„é¢ç§¯ä¸ºï¼š&quot; &lt;&lt; c1.calculateS() &lt;&lt; endl; cout &lt;&lt; &quot;c1çš„ä½“ç§¯ä¸ºï¼š&quot; &lt;&lt; c1.calculateV() &lt;&lt; endl; //åˆ›å»ºç¬¬äºŒä¸ªç«‹æ–¹ä½“å¯¹è±¡ Cube c2; c2.setL(10); c2.setW(10); c2.setH(10); cout &lt;&lt; &quot;c2çš„é¢ç§¯ä¸ºï¼š&quot; &lt;&lt; c2.calculateS() &lt;&lt; endl; cout &lt;&lt; &quot;c2çš„ä½“ç§¯ä¸ºï¼š&quot; &lt;&lt; c2.calculateV() &lt;&lt; endl; //åˆ©ç”¨å…¨å±€å‡½æ•°åˆ¤æ–­ bool ret = isSame(c1, c2); if (ret) &#123; cout &lt;&lt; &quot;c1å’Œc2æ˜¯ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;c1å’Œc2æ˜¯ä¸ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125; //åˆ©ç”¨æˆåŸå‡½æ•°åˆ¤æ–­ ret = c1.isSameByClass(c2); if (ret) &#123; cout &lt;&lt; &quot;c1å’Œc2æ˜¯ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;c1å’Œc2æ˜¯ä¸ç›¸ç­‰çš„&quot; &lt;&lt; endl; &#125;&#125; è¿è¡Œç»“æœä¸ºï¼š c1çš„é¢ç§¯ä¸ºï¼š600c1çš„ä½“ç§¯ä¸ºï¼š1000c2çš„é¢ç§¯ä¸ºï¼š600c2çš„ä½“ç§¯ä¸ºï¼š1000c1å’Œc2æ˜¯ç›¸ç­‰çš„c1å’Œc2æ˜¯ç›¸ç­‰çš„ ç»ƒä¹ æ¡ˆä¾‹äºŒè®¾è®¡ä¸€ä¸ªåœ†å½¢ç±»ï¼ˆCircleï¼‰ï¼Œå’Œä¸€ä¸ªç‚¹ç±»ï¼ˆPointï¼‰ï¼Œè®¡ç®—ç‚¹å’Œåœ†çš„å…³ç³» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç‚¹ä¸åœ†çš„å…³ç³»æ¡ˆä¾‹// ç‚¹ç±»class Point &#123;public: //è®¾ç½®x void setX(int x) &#123; m_X = x; &#125; //è·å–x int getX() &#123; return m_X; &#125; //è®¾ç½®y void setY(int y) &#123; m_Y = y; &#125; //è·å–y int getY() &#123; return m_Y; &#125;private: int m_X; int m_Y;&#125;;//åœ†ç±»class Circle&#123;public: //è®¾ç½®åŠå¾„ void setR(int r) &#123; m_R = r; &#125; //è·å–åŠå¾„ int getR() &#123; return m_R; &#125; //è®¾ç½®åœ†å¿ƒ void setCenter(Point center) &#123; m_Center = center; &#125; Point getCenter() &#123; return m_Center; &#125;private: int m_R;//åŠå¾„ Point m_Center;//åœ†å¿ƒ&#125;;//åˆ¤æ–­ç‚¹å’Œåœ†çš„å…³ç³»void isInCircle(Circle&amp; c, Point&amp; p) &#123; //è®¡ç®—ä¸¤ç‚¹ä¹‹é—´è·ç¦»çš„å¹³æ–¹ int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) + (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY()); //è®¡ç®—åŠå¾„çš„å¹³æ–¹ int rDistance = c.getR() * c.getR(); //åˆ¤æ–­å…³ç³» if (distance == rDistance) &#123; cout &lt;&lt; &quot;ç‚¹åœ¨åœ†ä¸Š&quot; &lt;&lt; endl; &#125; else if (distance &gt; rDistance) &#123; cout &lt;&lt; &quot;ç‚¹åœ¨åœ†å¤–&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;ç‚¹åœ¨åœ†å†…&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; //åˆ›å»ºåœ† Circle c; c.setR(10); Point center; center.setX(10); center.setY(0); c.setCenter(center); //åˆ›å»ºç‚¹ Point p; p.setX(10); p.setY(10); //åˆ¤æ–­å…³ç³» isInCircle(c, p);&#125; è¿è¡Œç»“æœä¸ºï¼š ç‚¹åœ¨åœ†ä¸Š å¯¹è±¡çš„åˆå§‹åŒ–å’Œæ¸…ç† ç”Ÿæ´»ä¸­æˆ‘ä»¬ä¹°çš„ç”µå­äº§å“åŸºæœ¬éƒ½ä¼šæœ‰å‡ºå‚è®¾ç½®ï¼Œåœ¨æŸä¸€å¤©æˆ‘ä»¬ä¸ç”¨çš„æ—¶å€™ä¹Ÿä¼šåˆ é™¤ä¸€äº›è‡ªå·±çš„ä¿¡æ¯æ•°æ®ä¿è¯å®‰å…¨ C++ä¸­çš„é¢å‘å¯¹è±¡æ¥è‡ªäºç”Ÿæ´»ï¼Œæ¯ä¸ªå¯¹è±¡ä¹Ÿéƒ½ä¼šæœ‰åˆå§‹è®¾ç½®ä»¥åŠå¯¹è±¡é”€æ¯å‰çš„æ¸…ç†æ•°æ®çš„è®¾ç½® æ„é€ å‡½æ•°å’Œææ„å‡½æ•°å¯¹è±¡çš„åˆå§‹åŒ–å’Œæ¸…ç†ä¹Ÿæ˜¯ä¸¤ä¸ªéå¸¸é‡è¦çš„å®‰å…¨é—®é¢˜ ä¸€ä¸ªå¯¹è±¡æˆ–è€…å˜é‡æ²¡æœ‰åˆå§‹çŠ¶æ€ï¼Œå¯¹å…¶ä½¿ç”¨åæœæ˜¯æœªçŸ¥ åŒæ ·çš„ä½¿ç”¨å®Œä¸€ä¸ªå¯¹è±¡æˆ–å˜é‡ï¼Œæ²¡æœ‰åŠæ—¶æ¸…ç†ï¼Œä¹Ÿä¼šé€ æˆä¸€å®šçš„é—®é¢˜ C++åˆ©ç”¨äº†æ„é€ å‡½æ•°å’Œææ„å‡½æ•°è§£å†³ä¸Šè¿°é—®é¢˜ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°å°†ä¼šè¢«ç¼–è¯‘å™¨è‡ªåŠ¨è°ƒç”¨ï¼Œå®Œæˆå¯¹è±¡åˆå§‹åŒ–å’Œæ¸…ç†å·¥ä½œã€‚ å¯¹è±¡çš„åˆå§‹åŒ–å’Œæ¸…ç†å·¥ä½œæ˜¯ç¼–è¯‘å™¨å¼ºåˆ¶è¦æˆ‘ä»¬åšçš„äº‹æƒ…ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬ä¸æä¾›æ„é€ å’Œææ„ï¼Œç¼–è¯‘å™¨ä¼šæä¾›ç¼–è¯‘å™¨æä¾›çš„æ„é€ å‡½æ•°å’Œææ„å‡½æ•°æ˜¯ç©ºå®ç° æ„é€ å‡½æ•°ï¼šä¸»è¦ä½œç”¨åœ¨äºåˆ›å»ºå¯¹è±¡æ—¶ä¸ºå¯¹è±¡çš„æˆå‘˜å±æ€§èµ‹å€¼ï¼Œæ„é€ å‡½æ•°ç”±ç¼–è¯‘å™¨è‡ªåŠ¨è°ƒç”¨ï¼Œæ— é¡»æ‰‹åŠ¨è°ƒç”¨ã€‚ ææ„å‡½æ•°ï¼šä¸»è¦ä½œç”¨åœ¨äºå¯¹è±¡é”€æ¯å‰ç³»ç»Ÿè‡ªåŠ¨è°ƒç”¨ï¼Œæ‰§è¡Œä¸€äº›æ¸…ç†å·¥ä½œ æ„é€ å‡½æ•°è¯­æ³•ï¼šç±»åï¼ˆï¼‰&#123;&#125; 1ã€æ„é€ å‡½æ•°ï¼šæ²¡æœ‰è¿”å›å€¼ä¹Ÿä¸å†™void 2ã€å‡½æ•°åç§°ä¸ç±»åç›¸åŒ 3ã€æ„é€ å‡½æ•°å¯ä»¥æœ‰å‚æ•°ï¼Œå› æ­¤å¯ä»¥å‘ç”Ÿé‡è½½ 4ã€ç¨‹åºåœ¨è°ƒç”¨å¯¹è±¡æ—¶ä¼šè‡ªåŠ¨è°ƒç”¨æ„é€ ï¼Œæ— é¡»æ‰‹åŠ¨è°ƒç”¨ï¼Œè€Œä¸”åªä¼šè°ƒç”¨ä¸€æ¬¡ ææ„å‡½æ•°è¯­æ³•ï¼š~ç±»åï¼ˆï¼‰&#123;&#125; 1ã€ææ„å‡½æ•°ï¼šæ²¡æœ‰è¿”å›å€¼ä¹Ÿä¸å†™void 2ã€å‡½æ•°åç§°ä¸ç±»åç›¸åŒï¼Œåœ¨åç§°å‰åŠ ä¸Šç¬¦å·~ 3ã€ææ„å‡½æ•°ä¸å¯ä»¥æœ‰å‚æ•°ï¼Œå› æ­¤ä¸å¯ä»¥å‘ç”Ÿé‡è½½ 4ã€ç¨‹åºåœ¨å¯¹è±¡é”€æ¯å‰ä¼šè‡ªåŠ¨è°ƒç”¨ææ„ï¼Œæ— é¡»æ‰‹åŠ¨è°ƒç”¨ï¼Œè€Œä¸”åªä¼šè°ƒç”¨ä¸€æ¬¡ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//å¯¹è±¡çš„åˆå§‹åŒ–å’Œæ¸…ç†class Person&#123; //1 æ„é€ å‡½æ•° //æ²¡æœ‰è¿”å›å€¼ ä¸ç”¨å†™void //å‡½æ•°åä¸ç±»åç›¸åŒ //æ„é€ å‡½æ•°å¯ä»¥æœ‰å‚æ•°å¯ä»¥å‘ç”Ÿé‡è½½ //åˆ›å»ºå¯¹è±¡çš„æ—¶å€™ï¼Œæ„é€ å‡½æ•°ä¼šè‡ªåŠ¨è°ƒç”¨ï¼Œè€Œä¸”åªè°ƒç”¨ä¸€æ¬¡public: Person() &#123; cout &lt;&lt; &quot;Personæ„é€ å‡½æ•°çš„è°ƒç”¨&quot; &lt;&lt; endl; &#125; //2 ææ„å‡½æ•° //æ²¡æœ‰è¿”å›å€¼ ä¸å†™void //å‡½æ•°åå’Œç±»åç›¸åŒ åœ¨åç§°å‰åŠ ~ //ææ„å‡½æ•°ä¸å¯ä»¥æœ‰å‚æ•°ï¼Œä¸å¯ä»¥å‘ç”Ÿé‡è½½ //å¯¹è±¡åœ¨é”€æ¯å‰ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•° ~Person() &#123; cout &lt;&lt; &quot;Personææ„å‡½æ•°çš„è°ƒç”¨&quot; &lt;&lt; endl; &#125;&#125;;//æ„é€ å’Œææ„éƒ½æ˜¯å¿…é¡»æœ‰çš„å®ç°ï¼Œå¦‚æœæˆ‘ä»¬è‡ªå·±ä¸æä¾›ï¼Œç¼–è¯‘å™¨ä¼šæä¾›ä¸€ä¸ªç©ºå®ç°çš„æ„é€ å’Œææ„void test01()&#123; Person p;//åœ¨æ ˆä¸Šçš„æ•°æ®ï¼Œtest01æ‰§è¡Œå®Œæ¯•ä¹‹åï¼Œé‡Šæ”¾è¿™ä¸ªå¯¹è±¡&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Personæ„é€ å‡½æ•°çš„è°ƒç”¨Personææ„å‡½æ•°çš„è°ƒç”¨ æ„é€ å‡½æ•°çš„åˆ†ç±»åŠè°ƒç”¨ä¸¤ç§åˆ†ç±»æ–¹å¼ï¼š æŒ‰å‚æ•°åˆ†ä¸ºï¼šæœ‰å‚æ•°æ„é€ å’Œæ— å‚æ•°æ„é€  æŒ‰ç±»å‹åˆ†ä¸ºï¼šæ™®é€šæ„é€ å’Œæ‹·è´æ„é€  ä¸‰ç§è°ƒç”¨æ–¹å¼ï¼š æ‹¬å·æ³• æ˜¾å¼æ³• éšå¼è½¬æ¢æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//åˆ†ç±»class Person&#123;public: //æ„é€ å‡½æ•° Person() &#123; cout &lt;&lt; &quot;Personçš„æ— å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; //æ‹·è´æ„é€ å‡½æ•° Person(const Person&amp; p) &#123; //å°†ä¼ å…¥çš„äººçš„èº«ä¸Šçš„æ‰€æœ‰å±æ€§ï¼Œæ‹·è´åˆ°æˆ‘èº«ä¸Š age = p.age; cout &lt;&lt; &quot;Personçš„æ‹·è´å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; int age;&#125;;//è°ƒç”¨void test01()&#123; //1ã€æ‹¬å·æ³• Person p1 ;//é»˜è®¤æ„é€ å‡½æ•°çš„è°ƒç”¨ Person p2(10);//æœ‰å‚æ„é€ å‡½æ•° //æ‹·è´æ„é€ å‡½æ•°è°ƒç”¨ Person p3(p2); //æ³¨æ„äº‹é¡¹ //è°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°çš„æ—¶å€™ï¼Œä¸è¦åŠ ï¼ˆï¼‰ cout &lt;&lt; &quot;p2çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p2.age &lt;&lt; endl; cout &lt;&lt; &quot;p3çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p3.age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Personçš„æ— å‚æ„é€ å‡½æ•°è°ƒç”¨Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨Personçš„æ‹·è´å‡½æ•°è°ƒç”¨p2çš„å¹´é¾„ä¸ºï¼š10p3çš„å¹´é¾„ä¸ºï¼š10Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//åˆ†ç±»class Person&#123;public: //æ„é€ å‡½æ•° Person() &#123; cout &lt;&lt; &quot;Personçš„æ— å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; //æ‹·è´æ„é€ å‡½æ•° Person(const Person&amp; p) &#123; //å°†ä¼ å…¥çš„äººçš„èº«ä¸Šçš„æ‰€æœ‰å±æ€§ï¼Œæ‹·è´åˆ°æˆ‘èº«ä¸Š age = p.age; cout &lt;&lt; &quot;Personçš„æ‹·è´å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; int age;&#125;;//è°ƒç”¨void test01()&#123; //2ã€æ˜¾ç¤ºæ³• Person p1; Person p2 = Person(10);//æœ‰å‚æ„é€  Person p3 = Person(p2);//æ‹·è´æ„é€  Person(10);//åŒ¿åå¯¹è±¡ ç‰¹ç‚¹ï¼šå½“å‰è¡Œæ‰§è¡Œç»“æŸåï¼Œç³»ç»Ÿä¼šç«‹å³å›æ”¶æ‰åŒ¿åå¯¹è±¡//æ³¨æ„äº‹é¡¹ï¼šä¸è¦åˆ©ç”¨æ‹·è´æ„é€ å‡½æ•° åˆå§‹åŒ–åŒ¿åå¯¹è±¡ ç¼–è¯‘å™¨ä¼šè®¤ä¸ºæ˜¯å¯¹è±¡å£°æ˜&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Personçš„æ— å‚æ„é€ å‡½æ•°è°ƒç”¨Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨Personçš„æ‹·è´å‡½æ•°è°ƒç”¨Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//åˆ†ç±»class Person&#123;public: //æ„é€ å‡½æ•° Person() &#123; cout &lt;&lt; &quot;Personçš„æ— å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; //æ‹·è´æ„é€ å‡½æ•° Person(const Person&amp; p) &#123; //å°†ä¼ å…¥çš„äººçš„èº«ä¸Šçš„æ‰€æœ‰å±æ€§ï¼Œæ‹·è´åˆ°æˆ‘èº«ä¸Š age = p.age; cout &lt;&lt; &quot;Personçš„æ‹·è´å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; int age;&#125;;//è°ƒç”¨void test01()&#123; //3ã€éšå¼è½¬æ¢æ³• Person p4 = 10; Person p5 = p4;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨Personçš„æ‹·è´å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨ æ‹·è´æ„é€ å‡½æ•°çš„è°ƒç”¨æ—¶æœºC++ä¸­æ‹·è´æ„é€ å‡½æ•°è°ƒç”¨æ—¶æœºé€šå¸¸æœ‰ä¸‰ç§æƒ…å†µ ä½¿ç”¨ä¸€ä¸ªä»¥åŠåˆ›å»ºå®Œæ¯•çš„å¯¹è±¡æ¥åˆå§‹åŒ–ä¸€ä¸ªæ–°å¯¹è±¡ å€¼ä¼ é€’çš„æ–¹å¼ç»™å‡½æ•°å‚æ•°ä¼ å€¼ ä»¥å€¼æ–¹å¼è¿”å›å±€éƒ¨å¯¹è±¡ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æ‹·è´æ„é€ å‡½æ•°è°ƒç”¨æ—¶æœº//1ã€ä½¿ç”¨ä¸€ä¸ªå·²ç»åˆ›å»ºå®Œæ¯•çš„å¯¹è±¡æ¥åˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡//2ã€å€¼ä¼ é€’çš„æ–¹å¼ç»™å‡½æ•°å‚æ•°ä¼ å€¼//3ã€å€¼æ–¹å¼è¿”å›å±€éƒ¨å¯¹è±¡class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Personé»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(int age) &#123; cout &lt;&lt; &quot;Personæœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; m_Age = age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Personæ‹·è´æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; m_Age = p.m_Age; &#125; ~Person() &#123; cout &lt;&lt; &quot;Personææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; int m_Age;&#125;;//1ã€ä½¿ç”¨ä¸€ä¸ªå·²ç»åˆ›å»ºå®Œæ¯•çš„å¯¹è±¡æ¥åˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡void test01()&#123; Person p1(20); Person p2(p1); cout &lt;&lt; &quot;p2çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p2.m_Age &lt;&lt; endl;&#125;//2ã€å€¼ä¼ é€’çš„æ–¹å¼ç»™å‡½æ•°å‚æ•°ä¼ å€¼void doWork1(Person p)&#123;&#125;void test02()&#123; Person p; doWork1(p);&#125;//3ã€å€¼æ–¹å¼è¿”å›å±€éƒ¨å¯¹è±¡Person doWork2()&#123; Person p1; return p1;&#125;void test03()&#123; Person p = doWork2();&#125;int main()&#123; cout &lt;&lt; &quot;test01()&quot; &lt;&lt; endl; test01(); cout &lt;&lt; &quot;test02()&quot; &lt;&lt; endl; test02(); cout &lt;&lt; &quot;test03()&quot; &lt;&lt; endl; test03();&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š test01()Personæœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨Personæ‹·è´æ„é€ å‡½æ•°è°ƒç”¨p2çš„å¹´é¾„ä¸ºï¼š20Personææ„å‡½æ•°è°ƒç”¨Personææ„å‡½æ•°è°ƒç”¨test02()Personé»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨Personæ‹·è´æ„é€ å‡½æ•°è°ƒç”¨Personææ„å‡½æ•°è°ƒç”¨Personææ„å‡½æ•°è°ƒç”¨test03()Personé»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨Personæ‹·è´æ„é€ å‡½æ•°è°ƒç”¨Personææ„å‡½æ•°è°ƒç”¨Personææ„å‡½æ•°è°ƒç”¨ æ„é€ å‡½æ•°çš„è°ƒç”¨è§„åˆ™ é»˜è®¤æƒ…å†µä¸‹ï¼ŒC++ç¼–è¯‘å™¨è‡³å°‘ç»™ä¸€ä¸ªç±»æ·»åŠ 3ä¸ªå‡½æ•° 1ã€é»˜è®¤æ„é€ å‡½æ•°ï¼ˆæ— å‚ï¼Œå‡½æ•°ä½“ä¸ºç©ºï¼‰ 2ã€é»˜è®¤ææ„å‡½æ•°ï¼ˆæ— å‚ï¼Œå‡½æ•°ä½“ä¸ºç©ºï¼‰ 3ã€é»˜è®¤æ‹·è´å‡½æ•°ï¼Œå¯¹å±æ€§è¿›è¡Œå€¼æ‹·è´ æ„é€ å‡½æ•°è°ƒç”¨è§„åˆ™å¦‚ä¸‹ï¼š å¦‚æœç”¨æˆ·å®šä¹‰æœ‰å‚æ„é€ å‡½æ•°ï¼ŒC++ä¸åœ¨æä¾›é»˜è®¤æ— å‚æ„é€ ï¼Œä½†ä¼šæä¾›é»˜è®¤æ‹·è´æ„é€  å¦‚æœç”¨æˆ·å®šä¹‰æ‹·è´æ„é€ å‡½æ•°ï¼ŒC++ä¸ä¼šåœ¨æä¾›å…¶ä»–æ„é€ å‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æ„é€ å‡½æ•°è°ƒç”¨è§„åˆ™//1ã€åˆ›å»ºä¸€ä¸ªç±»ï¼ŒC++ç¼–è¯‘å™¨ä¼šç»™æ¯ä¸ªç±»éƒ½æ·»åŠ è‡³å°‘3ä¸ªå‡½æ•°//é»˜è®¤æ„é€ ï¼ˆç©ºå®ç°ï¼‰//ææ„å‡½æ•°ï¼ˆç©ºå®ç°ï¼‰//æ‹·è´æ„é€ ï¼ˆå€¼æ‹·è´ï¼‰class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Personçš„é»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(int age) &#123; cout &lt;&lt; &quot;Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; /*Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Personçš„æ‹·è´æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; m_Age = p.m_Age; &#125;*/ ~Person() &#123; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person p; p.m_Age = 18; Person p2(p); cout &lt;&lt; &quot;p2çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p2.m_Age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š Personçš„é»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨p2çš„å¹´é¾„ä¸ºï¼š18Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨ æ·±æ‹·è´ä¸æµ…æ‹·è´æµ…æ‹·è´ï¼šç®€å•çš„èµ‹å€¼æ‹·è´æ“ä½œ æ·±æ‹·è´ï¼šåœ¨å †åŒºé‡æ–°ç”³è¯·ç©ºé—´ï¼Œè¿›è¡Œæ‹·è´æ“ä½œ å¦‚æœåˆ©ç”¨ç¼–è¯‘å™¨æä¾›çš„æ‹·è´æ„é€ å‡½æ•°ï¼Œä¼šåšæµ…æ‹·è´æ“ä½œ 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æ·±æ‹·è´ä¸æµ…æ‹·è´class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Personçš„é»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(int age, int height) &#123; m_Age = age; m_Height = new int(height); cout &lt;&lt; &quot;Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~Person() &#123; //ææ„ä»£ç ï¼Œå°†å †åŒºå¼€è¾Ÿçš„æ•°æ®åšé‡Šæ”¾æ“ä½œ if (m_Height != NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; int m_Age; int* m_Height;&#125;;void test01()&#123; Person p1(18 , 160); cout &lt;&lt; &quot;p1çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p1.m_Age &lt;&lt; &quot; èº«é«˜ä¸ºï¼š&quot; &lt;&lt; *p1.m_Height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p2.m_Age &lt;&lt; &quot; èº«é«˜ä¸ºï¼š&quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œå‘ç”Ÿé”™è¯¯ æµ…æ‹·è´ä¼šå¸¦æ¥å †åŒºçš„å†…å­˜é‡å¤é‡Šæ”¾ è¦è‡ªå·±å®ç°æ‹·è´æ„é€ å‡½æ•°ï¼Œè§£å†³æµ…æ‹·è´å¸¦æ¥çš„é—®é¢˜ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æ·±æ‹·è´ä¸æµ…æ‹·è´class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Personçš„é»˜è®¤æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(int age, int height) &#123; m_Age = age; m_Height = new int(height); cout &lt;&lt; &quot;Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Personçš„æ‹·è´æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; m_Age = p.m_Age; //ç¼–è¯‘å™¨é»˜è®¤å®ç°m_Height = p.m_Height; //æ·±æ‹·è´æ“ä½œ m_Height = new int(*p.m_Height); &#125; ~Person() &#123; //ææ„ä»£ç ï¼Œå°†å †åŒºå¼€è¾Ÿçš„æ•°æ®åšé‡Šæ”¾æ“ä½œ if (m_Height != NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; int m_Age; int* m_Height;&#125;;void test01()&#123; Person p1(18 , 160); cout &lt;&lt; &quot;p1çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p1.m_Age &lt;&lt; &quot; èº«é«˜ä¸ºï¼š&quot; &lt;&lt; *p1.m_Height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2çš„å¹´é¾„ä¸ºï¼š&quot; &lt;&lt; p2.m_Age &lt;&lt; &quot; èº«é«˜ä¸ºï¼š&quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š Personçš„æœ‰å‚æ„é€ å‡½æ•°è°ƒç”¨p1çš„å¹´é¾„ä¸ºï¼š18 èº«é«˜ä¸ºï¼š160Personçš„æ‹·è´æ„é€ å‡½æ•°è°ƒç”¨p2çš„å¹´é¾„ä¸ºï¼š18 èº«é«˜ä¸ºï¼š160Personçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨ åˆå§‹åŒ–åˆ—è¡¨ä½œç”¨ï¼šC++æä¾›äº†åˆå§‹åŒ–åˆ—è¡¨è¯­æ³•ï¼Œç”¨æ¥åˆå§‹åŒ–å±æ€§ è¯­æ³•ï¼šæ„é€ å‡½æ•°ï¼ˆï¼‰ï¼šå±æ€§1ï¼ˆå€¼1ï¼‰ï¼Œå±æ€§2ï¼ˆå€¼2ï¼‰â€¦{} 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//åˆå§‹åŒ–åˆ—è¡¨class Person&#123;public: ////ä¼ ç»Ÿåˆå§‹åŒ–æ“ä½œ //Person(int a, int b, int c) //&#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //åˆå§‹åŒ–åˆ—è¡¨åˆå§‹åŒ–å±æ€§ Person(int a, int b, int c) :m_A(a), m_B(a), m_C(c) &#123; &#125; int m_A; int m_B; int m_C;&#125;;void test01()&#123; Person p(10, 20, 30); cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; endl; cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; p.m_B &lt;&lt; endl; cout &lt;&lt; &quot;m_C = &quot; &lt;&lt; p.m_C &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š m_A &#x3D; 10m_B &#x3D; 10m_C &#x3D; 30 ç±»å¯¹è±¡ä½œä¸ºç±»æˆå‘˜C++ç±»ä¸­çš„æˆå‘˜å¯ä»¥æ˜¯å¦ä¸€ä¸ªç±»çš„å¯¹è±¡ï¼Œæˆ‘ä»¬ç§°è¯¥æˆå‘˜ä¸ºå¯¹è±¡æˆå‘˜ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç±»å¯¹è±¡ä½œä¸ºç±»æˆå‘˜//æ‰‹æœºç±»class Phone&#123;public: Phone(string pName) &#123; m_PName = pName; cout &lt;&lt; &quot;Phoneçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; string m_PName;&#125;;//äººç±»class Person&#123;public: Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; &quot;Personçš„æ„é€ å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Personçš„ææ„å‡½æ•°è°ƒç”¨&quot; &lt;&lt; endl; &#125; //å§“å string m_Name; //æ‰‹æœº Phone m_Phone;&#125;;//å½“å…¶ä»–ç±»å¯¹è±¡ä½œä¸ºæœ¬ç±»æˆå‘˜ï¼Œæ„é€ äº‹å…ˆæ„é€ ç±»å¯¹è±¡ï¼Œå†æ„é€ è‡ªèº«,ææ„é¡ºåºä¸æ„é€ ç›¸åvoid test01()&#123; Person p(&quot;å¼ ä¸‰&quot;, &quot;iphone&quot;); cout &lt;&lt; p.m_Name &lt;&lt; &quot;çš„æ‰‹æœºæ˜¯&quot; &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;&#125;int main()&#123; test01();&#125;endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š Phoneçš„æ„é€ å‡½æ•°è°ƒç”¨Personçš„æ„é€ å‡½æ•°è°ƒç”¨å¼ ä¸‰çš„æ‰‹æœºæ˜¯iphonePersonçš„ææ„å‡½æ•°è°ƒç”¨Personçš„ææ„å‡½æ•°è°ƒç”¨ é™æ€æˆå‘˜é™æ€æˆå‘˜å°±æ˜¯åœ¨æˆå‘˜å˜é‡å’Œæˆå‘˜å‡½æ•°å‰åŠ ä¸Šå…³é”®å­—staticï¼Œç§°ä¸ºé™æ€æˆå‘˜ é™æ€æˆå‘˜åˆ†ä¸ºï¼š é™æ€æˆå‘˜å˜é‡ æ‰€æœ‰å¯¹è±¡å…±äº«åŒä¸€ä»½æ•°æ® åœ¨ç¼–è¯‘é˜¶æ®µåˆ†é…å†…å­˜ ç±»å†…å£°æ˜ï¼Œç±»å¤–åˆå§‹åŒ– 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person&#123;public: //1ã€æ‰€æœ‰å¯¹è±¡éƒ½å…±äº«åŒä¸€ä»½æ•°æ® //2ã€ç¼–è¯‘é˜¶æ®µå°±åˆ†é…å†…å­˜ //3ã€ç±»å†…å£°æ˜ï¼Œç±»å¤–åˆå§‹åŒ–æ“ä½œ //4ã€ç§æœ‰é™æ€æˆå‘˜å˜é‡åœ¨ç±»å¤–è®¿é—®ä¸äº† static int m_A;private: static int m_B;&#125;;int Person::m_A = 100;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; Person p1; p1.m_A = 200; cout &lt;&lt; p1.m_A &lt;&lt; endl;&#125;void test02()&#123; //é™æ€æˆå‘˜å˜é‡ ä¸å±äºæŸä¸ªå¯¹è±¡ä¸Šï¼Œæ‰€æœ‰å¯¹è±¡éƒ½å…±äº«åŒä¸€ä»½æ•°æ® //å› æ­¤é™æ€æˆå‘˜å˜é‡æœ‰ä¸¤ç§è®¿é—®æ–¹å¼ //1ã€é€šè¿‡å¯¹è±¡è¿›è¡Œè®¿é—® Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; //2ã€é€šè¿‡ç±»åè¿›è¡Œè®¿é—® cout &lt;&lt; Person::m_A &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœå¦‚ä¸‹ 100200200200 é™æ€æˆå‘˜å‡½æ•° æ‰€æœ‰å¯¹è±¡å…±äº«åŒä¸€ä¸ªå‡½æ•° é™æ€æˆå‘˜å‡½æ•°åªèƒ½è®¿é—®é™æ€æˆå‘˜å˜é‡ 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//é™æ€æˆå‘˜å‡½æ•°//æ‰€æœ‰å¯¹è±¡å…±äº«åŒä¸€ä¸ªå‡½æ•°//é™æ€æˆå‘˜å‡½æ•°åªèƒ½è®¿é—®é™æ€æˆå‘˜å˜é‡class Person&#123;public: //é™æ€æˆå‘˜å‡½æ•° static void func() &#123; m_A = 100; cout &lt;&lt; &quot;static void funcè°ƒç”¨&quot; &lt;&lt; endl; &#125; static int m_A;//é™æ€æˆå‘˜å˜é‡ int m_B;//éé™æ€æˆå‘˜å˜é‡private: static void func2()//ç±»å¤–è®¿é—®ä¸åˆ°ç§æœ‰é™æ€æˆå‘˜å‡½æ•° &#123; &#125;&#125;;int Person::m_A = 100;//æœ‰ä¸¤ç§è®¿é—®æ–¹å¼void test01()&#123; //1ã€é€šè¿‡å¯¹è±¡è®¿é—® Person p; p.func(); //2ã€é€šè¿‡ç±»åè®¿é—® Person::func();&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š static void funcè°ƒç”¨static void funcè°ƒç”¨ C++å¯¹è±¡æ¨¡å‹å’ŒthisæŒ‡é’ˆæˆå‘˜å˜é‡å’Œæˆå‘˜å‡½æ•°åˆ†å¼€å­˜å‚¨åœ¨C++ä¸­ï¼Œç±»å†…çš„æˆå‘˜å˜é‡å’Œæˆå‘˜å‡½æ•°åˆ†å¼€å­˜å‚¨ åªæœ‰éé™æ€æˆå‘˜å˜é‡æ‰å±äºç±»çš„å¯¹è±¡ä¸Š 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æˆå‘˜å˜é‡ å’Œ æˆå‘˜å‡½æ•° åˆ†å¼€å­˜å‚¨çš„class Person&#123;&#125;;void test01()&#123; Person p; //ç©ºå¯¹è±¡å ç”¨å†…å­˜ç©ºé—´ä¸ºï¼š 1 //C++ç¼–è¯‘å™¨ä¼šç»™æ¯ä¸ªç©ºå¯¹è±¡ä¹Ÿåˆ†é…ä¸€ä¸ªå­—èŠ‚ç©ºé—´ï¼Œæ˜¯ä¸ºäº†åŒºåˆ†ç©ºå¯¹è±¡å å†…å­˜çš„ä½ç½® //æ¯ä¸ªç©ºå¯¹è±¡ä¹Ÿåº”è¯¥æœ‰ä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„å†…å­˜åœ°å€ cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š size of p &#x3D; 1 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æˆå‘˜å˜é‡ å’Œ æˆå‘˜å‡½æ•° åˆ†å¼€å­˜å‚¨çš„class Person&#123; int m_A;//éé™æ€æˆå‘˜å˜é‡&#125;;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š size of p &#x3D; 4 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æˆå‘˜å˜é‡ å’Œ æˆå‘˜å‡½æ•° åˆ†å¼€å­˜å‚¨çš„class Person&#123; int m_A;//éé™æ€æˆå‘˜å˜é‡ å±äºç±»çš„å¯¹è±¡ä¸Š static int m_B;//é™æ€æˆå‘˜å˜é‡&#125;;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š size of p &#x3D; 4 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//æˆå‘˜å˜é‡ å’Œ æˆå‘˜å‡½æ•° åˆ†å¼€å­˜å‚¨çš„class Person&#123; int m_A;//éé™æ€æˆå‘˜å˜é‡ å±äºç±»çš„å¯¹è±¡ä¸Š static int m_B;//é™æ€æˆå‘˜å˜é‡ ä¸å±äºç±»çš„å¯¹è±¡ä¸Š void func()&#123;&#125;//éé™æ€æˆå‘˜å‡½æ•° ä¸å±äºç±»çš„å¯¹è±¡ä¸Š&#125;;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š size of p &#x3D; 4 thisæŒ‡é’ˆæ¦‚å¿µé€šè¿‡ä¸Šè¿°ä»£ç æˆ‘ä»¬çŸ¥é“åœ¨C++ä¸­æˆå‘˜å˜é‡å–æˆå‘˜å‡½æ•°æ˜¯åˆ†å¼€å­˜å‚¨çš„ æ¯ä¸€ä¸ªéé™æ€æˆå‘˜å‡½æ•°åªä¼šè¯ç”Ÿä¸€ä»½å‡½æ•°å®ä¾‹ï¼Œä¹Ÿå°±æ˜¯è¯´å¤šä¸ªåŒç±»å‹çš„å¯¹è±¡ä¼šå…±ç”¨ä¸€å—ä»£ç  é‚£ä¹ˆé—®é¢˜æ˜¯ï¼šè¿™ä¸€å—ä»£ç æ˜¯å¦‚ä½•åŒºåˆ†é‚£ä¸ªå¯¹è±¡è°ƒç”¨è‡ªå·±çš„å‘¢? C++é€šè¿‡æä¾›ç‰¹æ®Šçš„å¯¹è±¡æŒ‡é’ˆï¼ŒthisæŒ‡é’ˆï¼Œè§£å†³ä¸Šè¿°é—®é¢˜ã€‚thisæŒ‡é’ˆæŒ‡å‘è¢«è°ƒç”¨çš„æˆå‘˜å‡½æ•°æ‰€å±çš„å¯¹è±¡ thisæŒ‡é’ˆæ˜¯éšå«æ¯ä¸€ä¸ªéé™æ€æˆå‘˜å‡½æ•°å†…çš„ä¸€ç§æŒ‡é’ˆ thisæŒ‡é’ˆä¸éœ€è¦å®šä¹‰ï¼Œç›´æ¥ä½¿ç”¨å³å¯ thisæŒ‡é’ˆçš„ç”¨é€”ï¼š å½“å½¢å‚å’Œæˆå‘˜å˜é‡åŒåæ—¶ï¼Œå¯ç”¨thisæŒ‡é’ˆæ¥åŒºåˆ† åœ¨ç±»çš„éé™æ€æˆå‘˜å‡½æ•°ä¸­è¿”å›å¯¹è±¡æœ¬èº«ï¼Œå¯ä½¿ç”¨return *this 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; age = age; &#125; int age;&#125;;//1 è§£å†³åç§°å†²çªvoid test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1çš„å¹´é¾„ä¸º&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125;//2 è¿”å›å¯¹è±¡æœ¬èº«ç”¨*thisint main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š p1çš„å¹´é¾„ä¸º-858993460 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; this-&gt;age = age; &#125; int age;&#125;;//1 è§£å†³åç§°å†²çªvoid test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1çš„å¹´é¾„ä¸º&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125; //2 è¿”å›å¯¹è±¡æœ¬èº«ç”¨*thisint main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š p1çš„å¹´é¾„ä¸º18 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; this-&gt;age = age; &#125; Person&amp; PersonAddAge(Person&amp; p) &#123; this-&gt;age += p.age; return *this; &#125; int age;&#125;;//1 è§£å†³åç§°å†²çªvoid test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1çš„å¹´é¾„ä¸º&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125; //2 è¿”å›å¯¹è±¡æœ¬èº«ç”¨*thisvoid test02()&#123; Person p1(10); Person p2(20); //é“¾å¼ç¼–ç¨‹ p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1); cout &lt;&lt; &quot;p2çš„å¹´é¾„ä¸ºï¼š &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; è¿è¡Œç»“æœä¸ºï¼š p1çš„å¹´é¾„ä¸º18p2çš„å¹´é¾„ä¸ºï¼š 50 ç©ºæŒ‡é’ˆè®¿é—®æˆå‘˜å‡½æ•°C++ä¸­ç©ºæŒ‡é’ˆä¹Ÿæ˜¯å¯ä»¥è°ƒç”¨æˆå‘˜å‡½æ•°çš„ï¼Œä½†æ˜¯ä¹Ÿè¦æ³¨æ„æœ‰æ²¡æœ‰ç”¨åˆ°thisæŒ‡é’ˆ å¦‚æœç”¨åˆ°thisæŒ‡é’ˆï¼Œéœ€è¦åŠ ä»¥åˆ¤æ–­ä¿è¯ä»£ç çš„å¥å£®æ€§ 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç©ºæŒ‡é’ˆè°ƒç”¨æˆå‘˜å‡½æ•°class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; //p-&gt;showClassName(); p-&gt;showPersonAge();&#125; è¿™æ®µä»£ç ä¼šè¿è¡Œé”™è¯¯ï¼ŒæŠ¥é”™åŸå› æ˜¯å› ä¸ºä¼ å…¥çš„æŒ‡é’ˆæ˜¯NULL è€Œä¸‹è¿°ä»£ç ä¸ä¼šæŠ¥é”™ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç©ºæŒ‡é’ˆè°ƒç”¨æˆå‘˜å‡½æ•°class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; p-&gt;showClassName(); //p-&gt;showPersonAge();&#125;int main()&#123; test01();&#125; æˆ‘ä»¬å°†ä»£ç ä¿®æ”¹ä¸ºï¼š 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//ç©ºæŒ‡é’ˆè°ƒç”¨æˆå‘˜å‡½æ•°class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; if (this == NULL) return; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; p-&gt;showClassName(); p-&gt;showPersonAge();&#125;int main()&#123; test01();&#125; ä»£ç ä¹Ÿä¸ä¼šæŠ¥é”™ constä¿®é¥°æˆå‘˜å‡½æ•° å¸¸å‡½æ•°ï¼š æˆå‘˜å‡½æ•°ååŠ conståæˆ‘ä»¬ç§°è¿™ä¸ªå‡½æ•°ä¸ºå¸¸å‡½æ•° å¸¸å‡½æ•°å†…ä¸å¯ä»¥ä¿®æ”¹æˆå‘˜å±æ€§ æˆå‘˜å±æ€§å£°æ˜æ—¶åŠ å…³é”®å­—mutableåï¼Œåœ¨å¸¸å‡½æ•°ä¸­ä¾ç„¶å¯ä»¥ä¿®æ”¹ å¸¸å¯¹è±¡ï¼š å£°æ˜å¯¹è±¡å‰åŠ constç§°è¯¥å¯¹è±¡ä¸ºå¸¸å¯¹è±¡ å¸¸å¯¹è±¡åªèƒ½è°ƒç”¨å¸¸å‡½æ•°","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ å­¦ä¹  Linuxç³»ç»Ÿç¼–ç¨‹ GCC","slug":"C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-GCC","date":"2023-04-16T07:56:51.000Z","updated":"2023-06-16T08:04:49.777Z","comments":true,"path":"2023/04/16/C++-å­¦ä¹ -Linuxç³»ç»Ÿç¼–ç¨‹-GCC/","link":"","permalink":"http://example.com/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GCC/","excerpt":"ä»€ä¹ˆæ˜¯GCC GCC åŸåä¸º GNU Cè¯­è¨€ç¼–è¯‘å™¨ï¼ˆGNU C Compilerï¼‰ GCCï¼ˆGNU Compiler Collectionï¼ŒGNUç¼–è¯‘å™¨å¥—ä»¶ï¼‰æ˜¯ç”± GNU å¼€å‘çš„ç¼–ç¨‹è¯­è¨€è¯‘å™¨ã€‚GNU ç¼–è¯‘å™¨å¥—ä»¶åŒ…æ‹¬ Cã€C++ã€Objective-Cã€Javaã€Ada å’Œ Go è¯­è¨€å‰ç«¯ï¼Œä¹ŸåŒ…æ‹¬äº†è¿™äº›è¯­è¨€çš„åº“ï¼ˆå¦‚ libstdc++ï¼Œlibgcjç­‰ï¼‰ GCC ä¸ä»…æ”¯æŒ C çš„è®¸å¤šâ€œæ–¹è¨€â€ï¼Œä¹Ÿå¯ä»¥åŒºåˆ«ä¸åŒçš„ C è¯­è¨€æ ‡å‡†ï¼›å¯ä»¥ä½¿ç”¨å‘½ä»¤è¡Œé€‰é¡¹æ¥æ§åˆ¶ç¼–è¯‘å™¨åœ¨ç¿»è¯‘æºä»£ç æ—¶åº”è¯¥éµå¾ªå“ªä¸ª C æ ‡å‡†ã€‚ä¾‹å¦‚ï¼Œå½“ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°-std=c99 å¯åŠ¨ GCC æ—¶ï¼Œç¼–è¯‘å™¨æ”¯æŒ C99 æ ‡å‡†ã€‚ å®‰è£…å‘½ä»¤ sudo apt install gcc g++ ï¼ˆç‰ˆæœ¬ &gt; 4.8.5ï¼‰ æŸ¥çœ‹ç‰ˆæœ¬ gcc/g++ -v/--version GCCå·¥ä½œæµç¨‹","text":"ä»€ä¹ˆæ˜¯GCC GCC åŸåä¸º GNU Cè¯­è¨€ç¼–è¯‘å™¨ï¼ˆGNU C Compilerï¼‰ GCCï¼ˆGNU Compiler Collectionï¼ŒGNUç¼–è¯‘å™¨å¥—ä»¶ï¼‰æ˜¯ç”± GNU å¼€å‘çš„ç¼–ç¨‹è¯­è¨€è¯‘å™¨ã€‚GNU ç¼–è¯‘å™¨å¥—ä»¶åŒ…æ‹¬ Cã€C++ã€Objective-Cã€Javaã€Ada å’Œ Go è¯­è¨€å‰ç«¯ï¼Œä¹ŸåŒ…æ‹¬äº†è¿™äº›è¯­è¨€çš„åº“ï¼ˆå¦‚ libstdc++ï¼Œlibgcjç­‰ï¼‰ GCC ä¸ä»…æ”¯æŒ C çš„è®¸å¤šâ€œæ–¹è¨€â€ï¼Œä¹Ÿå¯ä»¥åŒºåˆ«ä¸åŒçš„ C è¯­è¨€æ ‡å‡†ï¼›å¯ä»¥ä½¿ç”¨å‘½ä»¤è¡Œé€‰é¡¹æ¥æ§åˆ¶ç¼–è¯‘å™¨åœ¨ç¿»è¯‘æºä»£ç æ—¶åº”è¯¥éµå¾ªå“ªä¸ª C æ ‡å‡†ã€‚ä¾‹å¦‚ï¼Œå½“ä½¿ç”¨å‘½ä»¤è¡Œå‚æ•°-std=c99 å¯åŠ¨ GCC æ—¶ï¼Œç¼–è¯‘å™¨æ”¯æŒ C99 æ ‡å‡†ã€‚ å®‰è£…å‘½ä»¤ sudo apt install gcc g++ ï¼ˆç‰ˆæœ¬ &gt; 4.8.5ï¼‰ æŸ¥çœ‹ç‰ˆæœ¬ gcc/g++ -v/--version GCCå·¥ä½œæµç¨‹ GCCå’ŒG++çš„åŒºåˆ« gcc å’Œ g++éƒ½æ˜¯GNU(ç»„ç»‡)çš„ä¸€ä¸ªç¼–è¯‘å™¨ã€‚ è¯¯åŒºä¸€ï¼šgcc åªèƒ½ç¼–è¯‘ c ä»£ç ï¼Œg++ åªèƒ½ç¼–è¯‘ c++ ä»£ç ã€‚ä¸¤è€…éƒ½å¯ä»¥ï¼Œè¯·æ³¨æ„ï¼š åç¼€ä¸º .c çš„ï¼Œgcc æŠŠå®ƒå½“ä½œæ˜¯ C ç¨‹åºï¼Œè€Œ g++ å½“ä½œæ˜¯ c++ ç¨‹åº åç¼€ä¸º .cpp çš„ï¼Œä¸¤è€…éƒ½ä¼šè®¤ä¸ºæ˜¯ C++ ç¨‹åºï¼ŒC++ çš„è¯­æ³•è§„åˆ™æ›´åŠ ä¸¥è°¨ä¸€äº› ç¼–è¯‘é˜¶æ®µï¼Œg++ ä¼šè°ƒç”¨ gccï¼Œå¯¹äº C++ ä»£ç ï¼Œä¸¤è€…æ˜¯ç­‰ä»·çš„ï¼Œä½†æ˜¯å› ä¸º gccå‘½ä»¤ä¸èƒ½è‡ªåŠ¨å’Œ C++ ç¨‹åºä½¿ç”¨çš„åº“è”æ¥ï¼Œæ‰€ä»¥é€šå¸¸ç”¨ g++ æ¥å®Œæˆé“¾æ¥ï¼Œä¸ºäº†ç»Ÿä¸€èµ·è§ï¼Œå¹²è„†ç¼–è¯‘&#x2F;é“¾æ¥ç»Ÿç»Ÿç”¨ g++ äº†ï¼Œè¿™å°±ç»™äººä¸€ç§é”™è§‰ï¼Œå¥½åƒ cpp ç¨‹åºåªèƒ½ç”¨ g++ ä¼¼çš„ è¯¯åŒºäºŒï¼šgcc ä¸ä¼šå®šä¹‰ __cplusplus å®ï¼Œè€Œ g++ ä¼š å®é™…ä¸Šï¼Œè¿™ä¸ªå®åªæ˜¯æ ‡å¿—ç€ç¼–è¯‘å™¨å°†ä¼šæŠŠä»£ç æŒ‰ C è¿˜æ˜¯ C++ è¯­æ³•æ¥è§£é‡Š å¦‚ä¸Šæ‰€è¿°ï¼Œå¦‚æœåç¼€ä¸º .cï¼Œå¹¶ä¸”é‡‡ç”¨ gcc ç¼–è¯‘å™¨ï¼Œåˆ™è¯¥å®å°±æ˜¯æœªå®šä¹‰çš„ï¼Œå¦åˆ™ï¼Œå°±æ˜¯å·²å®šä¹‰ è¯¯åŒºä¸‰ï¼šç¼–è¯‘åªèƒ½ç”¨ gccï¼Œé“¾æ¥åªèƒ½ç”¨ g++ ä¸¥æ ¼æ¥è¯´ï¼Œè¿™å¥è¯ä¸ç®—é”™è¯¯ï¼Œä½†æ˜¯å®ƒæ··æ·†äº†æ¦‚å¿µï¼Œåº”è¯¥è¿™æ ·è¯´ï¼šç¼–è¯‘å¯ä»¥gcc&#x2F;g++ï¼Œè€Œé“¾æ¥å¯ä»¥ç”¨ g++ æˆ–è€… gcc -lstdc++ã€‚ gcc å‘½ä»¤ä¸èƒ½è‡ªåŠ¨å’ŒC++ç¨‹åºä½¿ç”¨çš„åº“è”æ¥ï¼Œæ‰€ä»¥é€šå¸¸ä½¿ç”¨ g++ æ¥å®Œæˆè”æ¥ã€‚ä½†åœ¨ç¼–è¯‘é˜¶æ®µï¼Œg++ ä¼šè‡ªåŠ¨è°ƒç”¨ gccï¼ŒäºŒè€…ç­‰ä»·","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"è®ºæ–‡é˜…è¯» Houdiniâ€™s Escape: Breaking the Resource Rein of Linux Control Groups","slug":"è®ºæ–‡é˜…è¯»-Houdiniâ€™s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups","date":"2023-04-15T05:08:53.000Z","updated":"2023-04-22T11:50:35.932Z","comments":true,"path":"2023/04/15/è®ºæ–‡é˜…è¯»-Houdiniâ€™s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/","link":"","permalink":"http://example.com/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/","excerpt":"æ‘˜è¦ Linux Control Groupsï¼Œå³cgroupsï¼Œæ˜¯å¯ç”¨æ“ä½œç³»ç»Ÿçº§å®¹å™¨åŒ–çš„å…³é”®æ„å»ºå—ã€‚cgroupsæœºåˆ¶å°†è¿›ç¨‹åˆ’åˆ†ä¸ºåˆ†å±‚çš„ç»„ï¼Œå¹¶åº”ç”¨ä¸åŒçš„æ§åˆ¶å™¨æ¥ç®¡ç†ç³»ç»Ÿèµ„æºï¼ŒåŒ…æ‹¬CPUã€å†…å­˜ã€å—I&#x2F;Oç­‰ã€‚æ–°ç”Ÿæˆçš„å­è¿›ç¨‹è‡ªåŠ¨ä»çˆ¶è¿›ç¨‹ä¸­å¤åˆ¶cgroupså±æ€§ä»¥åŠ å¼ºèµ„æºæ§åˆ¶ã€‚ä¸å¹¸çš„æ˜¯ï¼Œé€šè¿‡è¿›ç¨‹åˆ›å»ºç»§æ‰¿çš„cgroupsé™åˆ¶å¹¶ä¸æ€»æ˜¯ä¿è¯ä¸€è‡´å’Œå…¬å¹³çš„èµ„æºæ ¸ç®—ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€å¥—åˆ©ç”¨ç­–ç•¥ï¼Œé€šè¿‡å°†è¿›ç¨‹ä¸åŸå§‹è¿›ç¨‹ç»„è§£å…³è”æ¥ç”Ÿæˆout-of-bandå·¥ä½œè´Ÿè½½ã€‚è¿™æ ·çš„å·¥ä½œè´Ÿè½½æ‰€æ¶ˆè€—çš„ç³»ç»Ÿèµ„æºä¸ä¼šè¢«è®¡ç®—åˆ°é€‚å½“çš„cgroupä¸­ã€‚ ä¸ºäº†è¿›ä¸€æ­¥è¯æ˜å¯è¡Œæ€§ï¼Œæˆ‘ä»¬æä¾›äº†Dockerå®¹å™¨ä¸­çš„äº”ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œä»¥æ¼”ç¤ºå¦‚ä½•åœ¨ç°å®åœºæ™¯ä¸­æ‰“ç ´cgroupçš„èµ„æºé™åˆ¶ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œé€šè¿‡åˆ©ç”¨è¿™äº›cgroupsåœ¨å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒä¸­çš„ä¸è¶³ï¼Œæ”»å‡»å®¹å™¨èƒ½å¤Ÿæå¤§åœ°æ‰©å¤§æ‰€æ¶ˆè€—çš„èµ„æºæ•°é‡ï¼Œæ˜¾è‘—é™ä½åŒä¸€ä¸»æœºä¸Šçš„å…¶ä»–å®¹å™¨çš„é€Ÿåº¦ï¼Œå¹¶åœ¨ç³»ç»Ÿèµ„æºä¸Šè·å¾—é¢å¤–çš„ä¸å…¬å¹³ä¼˜åŠ¿ã€‚æˆ‘ä»¬åœ¨æœ¬åœ°æµ‹è¯•å¹³å°å’ŒAmazon EC2äº‘ä¸“ç”¨æœåŠ¡å™¨ä¸Šè¿›è¡Œäº†å¤§é‡çš„å®éªŒã€‚å®éªŒç»“æœè¡¨æ˜ï¼Œä¸€ä¸ªå®¹å™¨å¯ä»¥æ¶ˆè€—ç³»ç»Ÿèµ„æº(ä¾‹å¦‚CPU)é«˜è¾¾å…¶æé™çš„200å€ï¼Œå¹¶ä½¿å…¶ä»–å…±å­˜å®¹å™¨ä¸­ç‰¹å®šå·¥ä½œè´Ÿè½½çš„è®¡ç®—å’ŒI&#x2F;Oæ€§èƒ½é™ä½95%ã€‚","text":"æ‘˜è¦ Linux Control Groupsï¼Œå³cgroupsï¼Œæ˜¯å¯ç”¨æ“ä½œç³»ç»Ÿçº§å®¹å™¨åŒ–çš„å…³é”®æ„å»ºå—ã€‚cgroupsæœºåˆ¶å°†è¿›ç¨‹åˆ’åˆ†ä¸ºåˆ†å±‚çš„ç»„ï¼Œå¹¶åº”ç”¨ä¸åŒçš„æ§åˆ¶å™¨æ¥ç®¡ç†ç³»ç»Ÿèµ„æºï¼ŒåŒ…æ‹¬CPUã€å†…å­˜ã€å—I&#x2F;Oç­‰ã€‚æ–°ç”Ÿæˆçš„å­è¿›ç¨‹è‡ªåŠ¨ä»çˆ¶è¿›ç¨‹ä¸­å¤åˆ¶cgroupså±æ€§ä»¥åŠ å¼ºèµ„æºæ§åˆ¶ã€‚ä¸å¹¸çš„æ˜¯ï¼Œé€šè¿‡è¿›ç¨‹åˆ›å»ºç»§æ‰¿çš„cgroupsé™åˆ¶å¹¶ä¸æ€»æ˜¯ä¿è¯ä¸€è‡´å’Œå…¬å¹³çš„èµ„æºæ ¸ç®—ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€å¥—åˆ©ç”¨ç­–ç•¥ï¼Œé€šè¿‡å°†è¿›ç¨‹ä¸åŸå§‹è¿›ç¨‹ç»„è§£å…³è”æ¥ç”Ÿæˆout-of-bandå·¥ä½œè´Ÿè½½ã€‚è¿™æ ·çš„å·¥ä½œè´Ÿè½½æ‰€æ¶ˆè€—çš„ç³»ç»Ÿèµ„æºä¸ä¼šè¢«è®¡ç®—åˆ°é€‚å½“çš„cgroupä¸­ã€‚ ä¸ºäº†è¿›ä¸€æ­¥è¯æ˜å¯è¡Œæ€§ï¼Œæˆ‘ä»¬æä¾›äº†Dockerå®¹å™¨ä¸­çš„äº”ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œä»¥æ¼”ç¤ºå¦‚ä½•åœ¨ç°å®åœºæ™¯ä¸­æ‰“ç ´cgroupçš„èµ„æºé™åˆ¶ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œé€šè¿‡åˆ©ç”¨è¿™äº›cgroupsåœ¨å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒä¸­çš„ä¸è¶³ï¼Œæ”»å‡»å®¹å™¨èƒ½å¤Ÿæå¤§åœ°æ‰©å¤§æ‰€æ¶ˆè€—çš„èµ„æºæ•°é‡ï¼Œæ˜¾è‘—é™ä½åŒä¸€ä¸»æœºä¸Šçš„å…¶ä»–å®¹å™¨çš„é€Ÿåº¦ï¼Œå¹¶åœ¨ç³»ç»Ÿèµ„æºä¸Šè·å¾—é¢å¤–çš„ä¸å…¬å¹³ä¼˜åŠ¿ã€‚æˆ‘ä»¬åœ¨æœ¬åœ°æµ‹è¯•å¹³å°å’ŒAmazon EC2äº‘ä¸“ç”¨æœåŠ¡å™¨ä¸Šè¿›è¡Œäº†å¤§é‡çš„å®éªŒã€‚å®éªŒç»“æœè¡¨æ˜ï¼Œä¸€ä¸ªå®¹å™¨å¯ä»¥æ¶ˆè€—ç³»ç»Ÿèµ„æº(ä¾‹å¦‚CPU)é«˜è¾¾å…¶æé™çš„200å€ï¼Œå¹¶ä½¿å…¶ä»–å…±å­˜å®¹å™¨ä¸­ç‰¹å®šå·¥ä½œè´Ÿè½½çš„è®¡ç®—å’ŒI&#x2F;Oæ€§èƒ½é™ä½95%ã€‚ CCS CONCEPT Security and privacy â†’ Virtualization and security KEYWORDS Containerï¼›Control Groupï¼›Docker INTRODUCTIONå®¹å™¨æŠ€æœ¯å·²å¹¿æ³›åº”ç”¨äºå„ç§è®¡ç®—åœºæ™¯ï¼ŒåŒ…æ‹¬è¾¹ç¼˜è®¡ç®—ã€å¾®æœåŠ¡æ¶æ„ã€æ— æœåŠ¡å™¨è®¡ç®—å’Œå•†ä¸šäº‘ä¾›åº”å•†ã€‚ä¸è™šæ‹Ÿæœºç›¸æ¯”ï¼Œæ¶ˆé™¤é¢å¤–çš„æŠ½è±¡å±‚å¯ä»¥æ›´å¥½åœ°åˆ©ç”¨èµ„æºå¹¶æé«˜æ•ˆç‡ã€‚å› æ­¤ï¼Œå®¹å™¨å¯ä»¥å®ç°æ¥è¿‘æœ¬æœºçš„æ€§èƒ½ã€‚ å°½ç®¡å®¹å™¨æŠ€æœ¯å…·æœ‰æ€§èƒ½ä¼˜åŠ¿ï¼Œä½†æœ€è¿‘ä¹Ÿå¼•èµ·äº†ä¸€äº›å®‰å…¨å’Œéšç§é—®é¢˜ï¼Œç‰¹åˆ«æ˜¯èµ„æºéš”ç¦»ã€ç‰¹æƒå‡çº§ã€æ··æ·†ä»£ç†æ”»å‡»å’Œéšè”½é€šé“ã€‚ åœ¨Linuxå†…æ ¸ä¸­ï¼Œå¯ç”¨å®¹å™¨èµ„æºéš”ç¦»å’Œç®¡ç†çš„ä¸¤ä¸ªå…³é”®æ„å»ºå—æ˜¯Linuxå‘½åç©ºé—´(å³namespaces)å’ŒLinuxæ§åˆ¶ç»„(å³cgroups)ã€‚æ­¤å¤–ï¼Œè¿˜é‡‡ç”¨æˆ–å»ºè®®äº†ä¸€ç»„å®‰å…¨æœºåˆ¶(ä¾‹å¦‚ï¼ŒCapabilitiesã€SELinuxã€AppArmorã€seccompå’Œå®‰å…¨å‘½åç©ºé—´)æ¥è¿›ä¸€æ­¥å¢å¼ºéƒ¨ç½²ä¸­çš„å®¹å™¨å®‰å…¨æ€§ã€‚ å®¹å™¨ä¾èµ–äºcgroupè¿›è¡Œèµ„æºç®¡ç†å’Œæ§åˆ¶ï¼Œä»¥é˜²æ­¢ä¸€ä¸ªå®¹å™¨è€—å°½ä¸»æœºçš„ç³»ç»Ÿèµ„æºã€‚cgroupsæœºåˆ¶å°†ä¸€ç»„è¿›ç¨‹åŠå…¶å­è¿›ç¨‹åˆ’åˆ†ä¸ºåˆ†å±‚çš„ç»„ï¼Œå¹¶åº”ç”¨ä¸åŒçš„æ§åˆ¶å™¨æ¥ç®¡ç†å’Œé™åˆ¶å„ç§ç³»ç»Ÿèµ„æºï¼Œä¾‹å¦‚CPUæ—¶é—´ã€è®¡ç®—æœºå†…å­˜ã€å—I&#x2F;Oç­‰ã€‚é€šè¿‡åˆç†çš„é™åˆ¶ç­–ç•¥ï¼Œcgroupså¯ä»¥ç¼“è§£è®¸å¤šå·²çŸ¥çš„æ‹’ç»æœåŠ¡æ¼æ´ã€‚ å®¹å™¨æŠ€æœ¯å·²å¹¿æ³›åº”ç”¨äºå„ç§è®¡ç®—åœºæ™¯ï¼ŒåŒ…æ‹¬è¾¹ç¼˜è®¡ç®—ã€å¾®æœåŠ¡æ¶æ„ã€æ— æœåŠ¡å™¨è®¡ç®—å’Œå•†ä¸šäº‘ä¾›åº”å•†ã€‚ä¸è™šæ‹Ÿæœºç›¸æ¯”ï¼Œæ¶ˆé™¤é¢å¤–çš„æŠ½è±¡å±‚å¯ä»¥æ›´å¥½åœ°åˆ©ç”¨èµ„æºå¹¶æé«˜æ•ˆç‡ã€‚å› æ­¤ï¼Œå®¹å™¨å¯ä»¥å®ç°æ¥è¿‘æœ¬æœºçš„æ€§èƒ½ã€‚ å°½ç®¡å®¹å™¨æŠ€æœ¯å…·æœ‰æ€§èƒ½ä¼˜åŠ¿ï¼Œä½†æœ€è¿‘ä¹Ÿå¼•èµ·äº†ä¸€äº›å®‰å…¨å’Œéšç§é—®é¢˜ï¼Œç‰¹åˆ«æ˜¯èµ„æºéš”ç¦»ã€ç‰¹æƒå‡çº§ã€æ··æ·†ä»£ç†æ”»å‡»å’Œéšè”½é€šé“ã€‚ åœ¨Linuxå†…æ ¸ä¸­ï¼Œå¯ç”¨å®¹å™¨èµ„æºéš”ç¦»å’Œç®¡ç†çš„ä¸¤ä¸ªå…³é”®æ„å»ºå—æ˜¯Linuxå‘½åç©ºé—´(å³å‘½åç©ºé—´)å’ŒLinuxæ§åˆ¶ç»„(å³cgroups1)ã€‚æ­¤å¤–ï¼Œè¿˜é‡‡ç”¨æˆ–å»ºè®®äº†ä¸€ç»„å®‰å…¨æœºåˆ¶(ä¾‹å¦‚ï¼ŒCapabilitiesã€SELinuxã€AppArmorã€seccompå’Œå®‰å…¨å‘½åç©ºé—´)æ¥è¿›ä¸€æ­¥å¢å¼ºéƒ¨ç½²ä¸­çš„å®¹å™¨å®‰å…¨æ€§ã€‚ å®¹å™¨ä¾èµ–äºcgroupè¿›è¡Œèµ„æºç®¡ç†å’Œæ§åˆ¶ï¼Œä»¥é˜²æ­¢ä¸€ä¸ªå®¹å™¨è€—å°½ä¸»æœºçš„ç³»ç»Ÿèµ„æºã€‚cgroupsæœºåˆ¶å°†ä¸€ç»„è¿›ç¨‹åŠå…¶å­è¿›ç¨‹åˆ’åˆ†ä¸ºåˆ†å±‚çš„ç»„ï¼Œå¹¶åº”ç”¨ä¸åŒçš„æ§åˆ¶å™¨æ¥ç®¡ç†å’Œé™åˆ¶å„ç§ç³»ç»Ÿèµ„æºï¼Œä¾‹å¦‚CPUæ—¶é—´ã€è®¡ç®—æœºå†…å­˜ã€å—I&#x2F;Oç­‰ã€‚é€šè¿‡åˆç†çš„é™åˆ¶ç­–ç•¥ï¼Œcgroupså¯ä»¥ç¼“è§£è®¸å¤šå·²çŸ¥çš„æ‹’ç»æœåŠ¡æ¼æ´ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ‰“ç®—ç³»ç»Ÿåœ°æ¢è®¨ä¸€ä¸‹æ¥æ‘†è„±ç°æœ‰çš„cgroupsæœºåˆ¶çš„èµ„æºæ§åˆ¶ã€å¹¶äº†è§£å…¶å¯¹å®¹å™¨çš„å®‰å…¨å½±å“ã€‚æ–°åˆ›å»ºçš„å­è¿›ç¨‹ä¼šè‡ªåŠ¨ç»§æ‰¿å…¶çˆ¶è¿›ç¨‹çš„cgroupså±æ€§ã€‚è¿™ç§æœºåˆ¶ä¿è¯äº†å®ƒä»¬å°†è¢«é™åˆ¶åœ¨ç›¸åŒçš„cgroupsç­–ç•¥ä¸‹ã€‚ä¸ºäº†æ‰“ç ´cgroupsçš„èµ„æºçº¦æŸï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€å¥—åˆ©ç”¨ç­–ç•¥ï¼Œé€šè¿‡å°†è¿›ç¨‹ä¸å…¶åŸå§‹cgroupsåˆ†ç¦»ï¼Œç”Ÿæˆäº†ä¸€äº›å¸¦å¤–å·¥ä½œè´Ÿè½½ã€‚è¿™æ„å‘³ç€è¿™äº›è¿›ç¨‹ä¸å†å—åˆ°åŸå§‹cgroupsçš„èµ„æºé™åˆ¶ï¼Œä»è€Œå¯èƒ½ç»•è¿‡åŸæœ¬çš„èµ„æºç®¡ç†ç­–ç•¥ã€‚è¿™äº›è¿›ç¨‹å¯ä»¥ä»å¤´å¼€å§‹åˆ›å»ºï¼Œä»¥å¤„ç†åœ¨ä¸€ä¸ªcgroupå†…å‘èµ·çš„ç³»ç»Ÿäº‹ä»¶ã€‚åœ¨å…¶ä»–æƒ…å†µä¸‹ï¼Œè¿™äº›è¿›ç¨‹å¯ä»¥æ˜¯ä¼‘çœ çš„å†…æ ¸çº¿ç¨‹æˆ–ç³»ç»ŸæœåŠ¡è¿›ç¨‹ã€‚åœ¨æ•´ä¸ªç³»ç»Ÿä¸­å…±äº«ï¼Œå¹¶å°†åœ¨éœ€è¦æ—¶è¢«æ¿€æ´»ã€‚å› æ­¤ï¼Œç›¸åº”çš„æ¶ˆè€—çš„èµ„æºå°†è¢«æ”¶å–åˆ°å…¶ä»– â€œå—å®³è€… â€œcgroupsä¸­ã€‚ ä¸ºäº†è¿›ä¸€æ­¥æ­ç¤ºç°æœ‰cgroupæœºåˆ¶ä¸è¶³çš„å®‰å…¨é£é™©ï¼Œæˆ‘ä»¬ä½¿ç”¨Dockerå®¹å™¨è¿›è¡Œäº†äº”ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œå±•ç¤ºäº†åœ¨ç°å®ç³»ç»Ÿè®¾ç½®ä¸­é€ƒè„±cgroupèµ„æºæ§åˆ¶çš„æ­¥éª¤ã€‚åœ¨è¿™äº›æ¡ˆä¾‹ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«åˆ©ç”¨äº†å¼‚å¸¸ã€æ–‡ä»¶ç³»ç»Ÿå’ŒI&#x2F;Oè®¾å¤‡ã€Linuxæ—¥å¿—ç³»ç»Ÿã€å®¹å™¨å¼•æ“å’Œsoftirqså¤„ç†çš„å†…æ ¸å¤„ç†æœºåˆ¶ã€‚æˆ‘ä»¬åœ¨äºšé©¬é€ŠEC2äº‘ä¸­çš„æœ¬åœ°æµ‹è¯•å¹³å°å’Œä¸“ç”¨æœåŠ¡å™¨ä¸Šè¿›è¡Œå®éªŒã€‚æˆ‘ä»¬çš„å®éªŒè¡¨æ˜ï¼Œå³ä½¿æ‰§è¡Œäº†å¤šä¸ªcgroupæ§åˆ¶å™¨ï¼Œä¸€ä¸ªå¯¹æŠ—æ€§å»ç‰¹æƒå®¹å™¨ä»ç„¶å¯ä»¥æ˜¾è‘—è€—å°½CPUèµ„æºæˆ–äº§ç”Ÿå¤§é‡çš„I&#x2F;Oæ´»åŠ¨ï¼Œè€Œä¸éœ€è¦ä»»ä½•cgroupæ§åˆ¶å™¨ã€‚ æ›´ç³Ÿç³•çš„æ˜¯ï¼Œé€šè¿‡åœ¨å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒä¸­åˆ©ç”¨è¿™äº›æœºåˆ¶ï¼Œå¯¹æŠ—æ€§å®¹å™¨èƒ½å¤Ÿæå¤§åœ°æ‰©å¤§æ‰€æ¶ˆè€—çš„èµ„æºé‡ã€‚ç”±äºå¯¹æŠ—å®¹å™¨ä¼šå‘åŠ¨å¤šç§æ”»å‡»(å¦‚æ‹’ç»æœåŠ¡æ”»å‡»å’Œèµ„æºé‡Šæ”¾æ”»å‡»)ï¼Œå¯ä»¥æ˜¾è‘—é™ä½åŒä¸€ä¸»æœºä¸Šçš„å…¶ä»–å®¹å™¨çš„é€Ÿåº¦ï¼Œå¹¶åœ¨ç³»ç»Ÿèµ„æºä¸Šè·å¾—é¢å¤–çš„ä¸å…¬å¹³ä¼˜åŠ¿ã€‚æˆ‘ä»¬çš„å®éªŒè¯æ˜ï¼Œå¯¹æ‰‹ä»…é€šè¿‡æ§åˆ¶å°‘é‡èµ„æºå°±èƒ½æ˜¾è‘—å½±å“å…±å­˜å®¹å™¨çš„æ€§èƒ½ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå®¹å™¨å¯èƒ½ä¼šæ¶ˆè€—ç³»ç»Ÿèµ„æº(ä¾‹å¦‚CPU)ï¼Œè¶…è¿‡å…¶æé™200å€ï¼Œå¹¶ä½¿å…¶ä»–å®¹å™¨çš„ç‰¹å®šåŸºå‡†çš„è®¡ç®—å’ŒI&#x2F;Oæ€§èƒ½é™ä½95%ã€‚æ€»ä½“è€Œè¨€ï¼Œæœ¬å·¥ä½œçš„ä¸»è¦è´¡çŒ®æ€»ç»“å¦‚ä¸‹: æˆ‘ä»¬æå‡ºäº†å››ç§å¯èƒ½å¯¼è‡´ç³»ç»Ÿèµ„æºé”™è¯¯è®¡ç®—çš„å¼€å‘ç­–ç•¥ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é€ƒé¿cgroupæ§åˆ¶å™¨å¼ºåˆ¶æ‰§è¡Œçš„èµ„æºçº¦æŸã€‚ æˆ‘ä»¬åœ¨Dockerå®¹å™¨ç¯å¢ƒä¸­è¿›è¡Œäº†äº”ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œå¹¶è¯æ˜äº†åœ¨ç°å®åœºæ™¯ä¸­æ‰“ç ´cgroupé™åˆ¶å¹¶æ¶ˆè€—å¤§é‡èµ„æºæ˜¯å¯èƒ½çš„ã€‚ æˆ‘ä»¬åœ¨ä¸¤ä¸ªå…·æœ‰ä¸åŒé…ç½®çš„è¯•éªŒå°ä¸Šè¯„ä¼°äº†æ‰€æå‡ºçš„æ–¹æ³•çš„å½±å“ã€‚å®éªŒç»“æœè¡¨æ˜äº†å®‰å…¨å½±å“çš„ä¸¥é‡æ€§ã€‚ æœ¬æ–‡çš„å…¶ä½™éƒ¨åˆ†ç»„ç»‡å¦‚ä¸‹ã€‚ç¬¬äºŒèŠ‚ä»‹ç»äº†cgroupçš„èƒŒæ™¯ã€‚ç¬¬3èŠ‚ä»‹ç»äº†é€ƒè„±cgroupsæœºåˆ¶æ§åˆ¶çš„ç­–ç•¥ï¼Œå¹¶ä»å†…æ ¸çš„è§’åº¦åˆ†æäº†å…¶æ ¹æœ¬åŸå› ã€‚ç¬¬4èŠ‚è¯¦ç»†ä»‹ç»äº†å®¹å™¨çš„å‡ ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼ŒåŒ…æ‹¬å¨èƒæ¨¡å‹ã€æ”»å‡»å‘é‡ä»¥åŠå¯¹å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒçš„å„ç§æ”»å‡»çš„æœ‰æ•ˆæ€§ã€‚ç¬¬5èŠ‚ä»ä¸åŒæ–¹é¢è®¨è®ºäº†æ½œåœ¨çš„ç¼“è§£æªæ–½ã€‚ç¬¬6èŠ‚å¯¹ç›¸å…³å·¥ä½œè¿›è¡Œè€ƒå¯Ÿï¼Œå¹¶åœ¨ç¬¬7èŠ‚ä¸­è¿›è¡Œæ€»ç»“ã€‚ BACKGROUNDåœ¨Linuxå†…æ ¸ä¸­ï¼Œcgroupsæ˜¯ç”¨äºç®¡ç†ä¸€ç»„ä»»åŠ¡åŠå…¶æ‰€æœ‰å­ä»»åŠ¡çš„ç³»ç»Ÿèµ„æº(ä¾‹å¦‚CPUã€å†…å­˜ã€ç£ç›˜I&#x2F;Oã€ç½‘ç»œç­‰)çš„å…³é”®ç‰¹æ€§ã€‚å®ƒæ˜¯å®ç°é›†è£…ç®±åŒ–çš„æ„å»ºå—ä¹‹ä¸€ã€‚cgroupæœºåˆ¶å°†è¿›ç¨‹ç»„åˆ’åˆ†ä¸ºå…·æœ‰æ§åˆ¶è¡Œä¸ºçš„åˆ†å±‚ç»„ã€‚æ‰€æœ‰çš„å­è¿›ç¨‹ä¹Ÿä»å®ƒä»¬çš„çˆ¶è¿›ç¨‹ç»§æ‰¿æŸäº›å±æ€§(ä¾‹å¦‚ï¼Œlimits)ï¼Œå¹¶ç”±è¯¥æœºåˆ¶æ§åˆ¶ã€‚cgroupsä¾èµ–äºä¸åŒçš„èµ„æºæ§åˆ¶å™¨(æˆ–å­ç³»ç»Ÿ)æ¥é™åˆ¶ã€è§£é‡Šå’Œéš”ç¦»å„ç§ç±»å‹çš„ç³»ç»Ÿèµ„æºï¼ŒåŒ…æ‹¬CPUæ—¶é—´ã€ç³»ç»Ÿå†…å­˜ã€å—I&#x2F;Oã€ç½‘ç»œå¸¦å®½ç­‰ã€‚Linuxå®¹å™¨åˆ©ç”¨æ§åˆ¶ç»„å¯¹æ¯ä¸ªå®¹å™¨å®ä¾‹åº”ç”¨èµ„æºé™åˆ¶ï¼Œå¹¶é˜²æ­¢å•ä¸ªå®¹å™¨è€—å°½ä¸»æœºèµ„æºã€‚å¯¹äºäº‘è®¡ç®—ä¸­çš„è®¡è´¹æ¨¡å‹ï¼Œè¿˜å¯ä»¥ä½¿ç”¨cgroupsä¸ºæ¯ä¸ªå®¹å™¨åˆ†é…ç›¸åº”çš„èµ„æºå¹¶æµ‹é‡å®ƒä»¬çš„ä½¿ç”¨æƒ…å†µã€‚ä¸‹é¢æˆ‘ä»¬ç®€è¦ä»‹ç»cgroupå±‚æ¬¡ç»“æ„çš„èƒŒæ™¯çŸ¥è¯†ï¼Œç°æœ‰å®¹å™¨ç¯å¢ƒä¸­é€šå¸¸åº”ç”¨çš„å››ç§å…¸å‹çš„cgroupæ§åˆ¶å™¨ï¼Œä»¥åŠæ–°ç”Ÿæˆè¿›ç¨‹çš„cgroupç»§æ‰¿è¿‡ç¨‹ã€‚ cgroups Hierarchy and Controllersåœ¨Linuxä¸­ï¼Œcgroupæ˜¯æŒ‰å±‚æ¬¡ç»“æ„ç»„ç»‡çš„ï¼Œå…¶ä¸­ä¸€ç»„cgroupè¢«æ’åˆ—åœ¨æ ‘ä¸­ã€‚æ¯ä¸ªä»»åŠ¡(ä¾‹å¦‚ï¼Œä¸€ä¸ªçº¿ç¨‹)åªèƒ½ä¸ä¸€ä¸ªå±‚æ¬¡ç»“æ„ä¸­çš„ä¸€ä¸ªcgroupç›¸å…³è”ï¼Œä½†å¯ä»¥æ˜¯ä¸åŒå±‚æ¬¡ç»“æ„ä¸­çš„å¤šä¸ªcgroupçš„æˆå‘˜ã€‚ç„¶åï¼Œæ¯ä¸ªå±‚æ¬¡ç»“æ„éƒ½æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªé™„åŠ å­ç³»ç»Ÿï¼Œä»¥ä¾¿èµ„æºæ§åˆ¶å™¨å¯ä»¥å¯¹ç‰¹å®šçš„ç³»ç»Ÿèµ„æºåº”ç”¨æ¯ä¸ªcgroupé™åˆ¶ã€‚é€šè¿‡åˆ†å±‚ç»“æ„ï¼Œcgroupsæœºåˆ¶èƒ½å¤Ÿé™åˆ¶ä¸€ç»„è¿›ç¨‹(ä¾‹å¦‚å®¹å™¨)çš„èµ„æºæ€»é‡ã€‚ The cpu controllercpu controlleré€šè¿‡åˆ©ç”¨CFS(å®Œå…¨å…¬å¹³çš„è°ƒåº¦å™¨ï¼Œåœ¨Linux 2.6.23ä¸­å¼•å…¥)è°ƒåº¦cpuï¼Œä»¥ä¸¤ç§æ–¹å¼ä½¿cpuæˆä¸ºå¯ç®¡ç†çš„èµ„æºã€‚ ç¬¬ä¸€ç§æ–¹æ³•æ˜¯ä¿è¯æœ€å°‘æ•°é‡çš„CPUå…±äº«:æ¯ä¸ªç»„éƒ½æä¾›ç›¸åº”çš„å…±äº«ï¼Œä»¥å®šä¹‰ç›¸å¯¹æƒé‡ã€‚è¯¥ç­–ç•¥åœ¨CPUç©ºé—²æ—¶ä¸é™åˆ¶cgroupçš„CPUä½¿ç”¨ç‡ï¼Œå½“å¤šä¸ªcgroupç«äº‰ç›¸åŒçš„CPUèµ„æºæ—¶ï¼ŒæŒ‰ç…§æƒé‡çš„æ¯”ä¾‹åˆ†é…å¸¦å®½ã€‚ä¾‹å¦‚ï¼Œå¦‚æœå…±äº«ä¸º512çš„ä¸€ä¸ªå®¹å™¨ä¸å…±äº«ä¸º1024çš„å¦ä¸€ä¸ªå®¹å™¨è¿è¡Œåœ¨åŒä¸€ä¸ªæ ¸å¿ƒä¸Šã€‚ç„¶åï¼Œç¬¬ä¸€ä¸ªå®¹å™¨çš„CPUä½¿ç”¨ç‡å¤§è‡´ä¸º33.3%ï¼Œè€Œå¦ä¸€ä¸ªå®¹å™¨çš„CPUä½¿ç”¨ç‡ä¸º66.7%ã€‚åœ¨Linux 3.2ä¸­è¿›ä¸€æ­¥æ‰©å±•äº†cpuæ§åˆ¶å™¨ï¼Œé€šè¿‡æŒ‡å®šé…é¢å’Œå‘¨æœŸæ¥æä¾›é¢å¤–çš„cpuå¸¦å®½æ§åˆ¶ã€‚ æ¯ä¸ªç»„åªèƒ½åœ¨æ¯ä¸ªç»™å®šçš„â€œæ—¶é—´æ®µâ€(ä»¥å¾®ç§’ä¸ºå•ä½)å†…æ¶ˆè€—â€œé…é¢â€å¾®ç§’ã€‚å¦‚æœä¸€ä¸ªç»„çš„CPUå¸¦å®½æ¶ˆè€—(ç”±è¿è¡Œæ—¶å˜é‡è·Ÿè¸ª)è¶…è¿‡äº†é™åˆ¶ï¼Œæ§åˆ¶å™¨å°†é™åˆ¶è¯¥ä»»åŠ¡ï¼Œç›´åˆ°ä¸‹ä¸€ä¸ªæ—¶é—´æ®µï¼Œæ­¤æ—¶å®¹å™¨çš„è¿è¡Œæ—¶è¢«é‡æ–°å……ç”µåˆ°å…¶é…é¢ã€‚cpuæ§åˆ¶å™¨è¢«å¹¿æ³›åº”ç”¨äºå¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒï¼Œä»¥é™åˆ¶ä¸€ä¸ªå®¹å™¨çš„cpuä½¿ç”¨ã€‚å¦‚æœå®¹å™¨è®¾ç½®çš„é…é¢ä¸º50,000ï¼Œå‘¨æœŸä¸º100,000ï¼Œåˆ™è¯¥å®¹å™¨æœ€å¤šå¯ä»¥æ¶ˆè€—ä¸€ä¸ªCPUæ ¸å¿ƒæ€»CPUå‘¨æœŸçš„ä¸€åŠã€‚ The cpusets controllercpusetsæ§åˆ¶å™¨æä¾›äº†ä¸€ç§æœºåˆ¶ï¼Œç”¨äºå°†ä¸€ç»„ä»»åŠ¡çº¦æŸåˆ°ç‰¹å®šçš„cpuå’Œå†…å­˜èŠ‚ç‚¹ã€‚åœ¨å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒä¸­ï¼Œåˆ©ç”¨cpusetsæ§åˆ¶å™¨æ¥é™åˆ¶ç‰¹å®šæ ¸å¿ƒä¸Šå®¹å™¨çš„å·¥ä½œè´Ÿè½½ã€‚å®¹å™¨çš„æ¯ä¸ªä»»åŠ¡éƒ½é™„åŠ åˆ°ä¸€ä¸ªcpusetï¼Œå…¶ä¸­åŒ…å«ä¸€ç»„å…è®¸ä½¿ç”¨çš„cpuå’Œå†…å­˜èŠ‚ç‚¹ã€‚å¯¹äºCPUè°ƒåº¦ï¼Œä»»åŠ¡çš„è°ƒåº¦(é€šè¿‡ç³»ç»Ÿè°ƒç”¨sched_setaffinity)è¢«è¿‡æ»¤åˆ°ä»»åŠ¡çš„cpussetå…è®¸çš„é‚£äº›CPUã€‚ä»»åŠ¡çš„ä»»ä½•è¿›ä¸€æ­¥çš„åŠ¨æ€è¿ç§»ä¹Ÿä»…é™äºå…è®¸çš„cpusetã€‚å› æ­¤ï¼Œcpusetsæ§åˆ¶å™¨è¿˜å¯ä»¥ç”¨äºå°†ä¸€ä¸ªè¿›ç¨‹å›ºå®šåœ¨ç‰¹å®šçš„æ ¸å¿ƒä¸Šã€‚å®¹å™¨ç”¨æˆ·è¿˜å¯ä»¥åˆ©ç”¨ç”¨æˆ·ç©ºé—´åº”ç”¨ç¨‹åº(ä¾‹å¦‚ï¼Œtaskset)åœ¨cpusetçš„é™åˆ¶èŒƒå›´å†…è¿›ä¸€æ­¥è®¾ç½®äº²å’Œæ€§ã€‚ The blkio controllerblkio cgroupé€šè¿‡åº”ç”¨I&#x2F;Oæ§åˆ¶æ¥æ§åˆ¶å’Œé™åˆ¶å¯¹æŒ‡å®šå—è®¾å¤‡çš„è®¿é—®ã€‚å†…æ ¸çº§æœ‰ä¸¤ä¸ªç­–ç•¥å¯ç”¨ã€‚ç¬¬ä¸€ä¸ªæ˜¯åŸºäºæ¯”ä¾‹æƒé‡çš„åŸºäºæ—¶é—´çš„ç£ç›˜ç­–ç•¥åˆ’åˆ†ã€‚æ¯ä¸ªcgroupéƒ½è¢«åˆ†é…äº†ä¸€ä¸ªblkioã€‚æƒé‡å€¼ï¼Œè¡¨ç¤ºè¯¥ç»„å ç”¨ç£ç›˜æ—¶é—´çš„æ¯”ä¾‹ã€‚ç¬¬äºŒä¸ªæ˜¯èŠ‚æµç­–ç•¥ï¼Œå®ƒæŒ‡å®šI&#x2F;Oè®¾å¤‡ä¸Šçš„ä¸Šé™ã€‚ The pid controllerpid cgroupå­ç³»ç»Ÿç”¨äºå¯¹å®¹å™¨çš„ä»»åŠ¡æ•°é‡è®¾ç½®ä¸€å®šçš„é™åˆ¶ã€‚è¿™å¯ä»¥é€šè¿‡åœ¨pid.maxä¸­è®¾ç½®æœ€å¤§ä»»åŠ¡æ•°æ¥å®ç°ã€‚å½“å‰ä»»åŠ¡æ•°ä¿å­˜åœ¨pid .currentä¸­ã€‚pid cgroupå­ç³»ç»Ÿå°†åœ¨è¾¾åˆ°é™åˆ¶(ä¾‹å¦‚ï¼Œpid.current&gt; pid .max)åœæ­¢forkingæˆ–å…‹éš†ä¸€ä¸ªæ–°ä»»åŠ¡(ä¾‹å¦‚ï¼Œè¿”å›é”™è¯¯ä¿¡æ¯)ã€‚å› æ­¤ï¼Œpidæ§åˆ¶å™¨å¯ä»¥æœ‰æ•ˆé˜²å¾¡å¤šç§è€—å°½æ”»å‡»ï¼Œå¦‚fork bombã€‚ cgroups Inheritancecgroupsçš„ä¸€ä¸ªé‡è¦ç‰¹æ€§æ˜¯å­è¿›ç¨‹ä»çˆ¶è¿›ç¨‹ç»§æ‰¿cgroupså±æ€§ã€‚æ¯å½“ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºä¸€ä¸ªå­è¿›ç¨‹(ä¾‹å¦‚ï¼Œforkæˆ–clone)æ—¶ï¼Œå®ƒéƒ½ä¼šè§¦å‘å†…æ ¸ä¸­çš„forkå‡½æ•°æ¥å¤åˆ¶åˆå§‹åŒ–è¿›ç¨‹ã€‚å½“æ–°æ´¾ç”Ÿçš„è¿›ç¨‹åœ¨å¼€å§‹æ—¶é™„åŠ åˆ°æ ¹cgroupæ—¶ï¼Œåœ¨å¤åˆ¶å¯„å­˜å™¨å’Œè¿›ç¨‹ç¯å¢ƒçš„å…¶ä»–é€‚å½“éƒ¨åˆ†(ä¾‹å¦‚ï¼Œå‘½åç©ºé—´)åï¼Œè°ƒç”¨cgroupå¤åˆ¶å‡½æ•°æ¥å¤åˆ¶çˆ¶è¿›ç¨‹çš„cgroupã€‚ç‰¹åˆ«æ˜¯ï¼Œè¯¥å‡½æ•°é€šè¿‡é€’å½’éå†æ‰€æœ‰cgroupå­ç³»ç»Ÿï¼Œå°†ä»»åŠ¡é™„åŠ åˆ°å…¶çˆ¶cgroupã€‚å› æ­¤ï¼Œåœ¨å¤åˆ¶è¿‡ç¨‹ä¹‹åï¼Œå­ä»»åŠ¡å°†ç»§æ‰¿ä¸å…¶çˆ¶ä»»åŠ¡å®Œå…¨ç›¸åŒçš„cgroupsæˆå‘˜ã€‚ ä¾‹å¦‚ï¼Œå¦‚æœcpusetsèµ„æºæ§åˆ¶å™¨å°†çˆ¶è¿›ç¨‹çš„the CPU affinityè®¾ç½®ä¸ºç¬¬äºŒä¸ªæ ¸å¿ƒï¼Œé‚£ä¹ˆæ–°æ´¾ç”Ÿçš„å­è¿›ç¨‹ä¹Ÿå°†è¢«å›ºå®šåœ¨ç¬¬äºŒä¸ªæ ¸å¿ƒä¸Šã€‚åŒæ—¶ï¼Œå¦‚æœcpuå­ç³»ç»Ÿå°†çˆ¶cgroupä¸Šçš„cpué…é¢é™åˆ¶ä¸º50,000ï¼Œå‘¨æœŸä¸º100,000ï¼Œé‚£ä¹ˆåœ¨ç¬¬äºŒä¸ªæ ¸ä¸Šï¼Œcgroupçš„æ€»cpuåˆ©ç”¨ç‡(åŒ…æ‹¬æ–°åˆ†å‰çš„è¿›ç¨‹å’Œå®ƒçš„çˆ¶è¿›ç¨‹)ä¸èƒ½è¶…è¿‡50%ã€‚ EXPLOITING STRATEGIESåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†æè¿°å››ç§é€ƒé¿cgroupsæœºåˆ¶çš„èµ„æºæ§åˆ¶çš„ç­–ç•¥ï¼Œå¹¶è§£é‡Šç°æœ‰cgroupæ— æ³•è·Ÿè¸ªæ‰€æ¶ˆè€—èµ„æºçš„æ ¹æœ¬åŸå› ã€‚å¦‚ä¸Šæ‰€è¿°ï¼Œä½¿ç”¨å±‚æ¬¡ç»“æ„ï¼Œcgroupsæœºåˆ¶å¯ä»¥é™åˆ¶ä¸€ç»„è¿›ç¨‹(ä¾‹å¦‚å®¹å™¨)çš„èµ„æºæ€»é‡ã€‚è¿™æ˜¯é€šè¿‡é™„åŠ èµ„æºæ§åˆ¶å™¨å¯¹ç‰¹å®šçš„ç³»ç»Ÿèµ„æºåº”ç”¨æ¯cgroupé™åˆ¶æ¥å®ç°çš„ã€‚æ­¤å¤–ï¼Œcgroupä¸­çš„ç»§æ‰¿æœºåˆ¶ç¡®ä¿äº†åŒä¸€ä¸ªcgroupä¸­çš„æ‰€æœ‰è¿›ç¨‹åŠå…¶å­è¿›ç¨‹éƒ½å¯ä»¥è¢«cgroupå­ç³»ç»Ÿæ§åˆ¶ï¼Œè€Œä¸æ¶ˆè€—é¢å¤–çš„ç³»ç»Ÿèµ„æºã€‚ ç„¶è€Œï¼Œç”±äºLinuxå†…æ ¸çš„å¤æ‚æ€§å’Œå®ç°cgroupsçš„éš¾åº¦ï¼Œæˆ‘ä»¬å‘ç°æœ‰å‡ ä¸ªæœºåˆ¶æ²¡æœ‰è€ƒè™‘åˆ°ï¼Œå› æ­¤å¯ä»¥åˆ©ç”¨å®ƒä»¬æ¥é€ƒé¿ç°æœ‰cgroupsçš„çº¦æŸã€‚å…³é”®æ€æƒ³æ˜¯ç”Ÿæˆå·¥ä½œè´Ÿè½½ï¼Œè¿è¡Œåœ¨æ²¡æœ‰ç›´æ¥ä»åˆå§‹åŒ–cgroupæ´¾ç”Ÿå‡ºæ¥çš„è¿›ç¨‹ä¸Šï¼Œè¿™å¯¼è‡´äº†cgroupçš„å»å…³è”ã€‚ç‰¹åˆ«æ˜¯ï¼Œå¦‚å›¾æ‰€ç¤ºï¼Œç”¨æˆ·ç©ºé—´ä¸­æ²¡æœ‰æ ¹æƒé™çš„æ™®é€šè¿›ç¨‹å¯ä»¥åˆ©ç”¨å››ç§ç­–ç•¥é€ƒè„±cgroupsçš„æ§åˆ¶ã€‚ Exploiting Upcalls from Kernelåœ¨cgroupsæœºåˆ¶ä¸­ï¼Œæ‰€æœ‰å†…æ ¸çº¿ç¨‹éƒ½é™„åŠ åˆ°æ ¹cgroupï¼Œå› ä¸ºå†…æ ¸çº¿ç¨‹æ˜¯ç”±å†…æ ¸åˆ›å»ºçš„ã€‚å› æ­¤ï¼Œå†…æ ¸çº¿ç¨‹é€šè¿‡forkæˆ–cloneåˆ›å»ºçš„æ‰€æœ‰è¿›ç¨‹ä¹Ÿéƒ½é™„åŠ åˆ°ä¸å…¶çˆ¶è¿›ç¨‹ç›¸åŒçš„cgroup(æ ¹cgroup)ä¸­ã€‚ å› æ­¤ï¼Œä¸€ä¸ªcgroupä¸­çš„è¿›ç¨‹å¯ä»¥åˆ©ç”¨å†…æ ¸çº¿ç¨‹ä½œä¸ºä»£ç†æ¥äº§ç”Ÿæ–°çš„è¿›ç¨‹ï¼Œä»è€Œé€ƒè„±cgroupçš„æ§åˆ¶ã€‚ç‰¹åˆ«åœ°ï¼Œå¦‚å›¾â¶æ‰€ç¤ºï¼Œä¸€ä¸ªè¿›ç¨‹å¯ä»¥å…ˆè§¦å‘å†…æ ¸æ¥åˆå§‹åŒ–ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ã€‚ è¿™ä¸ªå†…æ ¸çº¿ç¨‹å……å½“ä»£ç†ï¼Œè¿›ä¸€æ­¥åˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ã€‚ ç”±äºå†…æ ¸çº¿ç¨‹é™„åŠ åˆ°æ ¹cgroupï¼Œå› æ­¤æ–°åˆ›å»ºçš„è¿›ç¨‹ä¹Ÿé™„åŠ åˆ°æ ¹cgroupã€‚åœ¨æ–°åˆ›å»ºçš„è¿›ç¨‹ä¸Šè¿è¡Œçš„æ‰€æœ‰å·¥ä½œè´Ÿè½½å°†ä¸å—cgroupå­ç³»ç»Ÿçš„é™åˆ¶ï¼Œä»è€Œæ‰“ç ´èµ„æºæ§åˆ¶ã€‚ ä½†æ˜¯ï¼Œè¿™ç§æœºåˆ¶è¦æ±‚ç”¨æˆ·ç©ºé—´è¿›ç¨‹é¦–å…ˆè°ƒç”¨å†…æ ¸ç©ºé—´ä¸­çš„å†…æ ¸å‡½æ•°ï¼Œç„¶åä»å†…æ ¸ç©ºé—´å‘ä¸Šè°ƒç”¨ç”¨æˆ·ç©ºé—´è¿›ç¨‹ã€‚è™½ç„¶ä»ç”¨æˆ·ç©ºé—´è°ƒç”¨ç‰¹å®šçš„å†…æ ¸å‡½æ•°(ä¾‹å¦‚ç³»ç»Ÿè°ƒç”¨)æ˜¯å¾ˆè‡ªç„¶çš„ï¼Œä½†ç›¸åçš„æ–¹å‘å¹¶ä¸å¸¸è§ã€‚ä¸€ç§å¯è¡Œçš„æ–¹æ³•æ˜¯é€šè¿‡usermode helper APIï¼Œè¯¥APIé€šè¿‡æä¾›å¯æ‰§è¡Œå˜é‡å’Œç¯å¢ƒå˜é‡çš„åç§°ï¼Œä¸ºåœ¨ç”¨æˆ·ç©ºé—´ä¸­åˆ›å»ºæµç¨‹æä¾›äº†ä¸€ä¸ªç®€å•çš„æ¥å£ã€‚è¿™ä¸ªå‡½æ•°é¦–å…ˆè°ƒç”¨ä¸€ä¸ªè¿è¡Œåœ¨å†…æ ¸çº¿ç¨‹ä¸­çš„å·¥ä½œé˜Ÿåˆ—(ä¾‹å¦‚ï¼Œkworker)ã€‚å·¥ä½œé˜Ÿåˆ—çš„å¤„ç†å‡½æ•°è¿›ä¸€æ­¥åˆ›å»ºä¸€ä¸ªå†…æ ¸çº¿ç¨‹æ¥å¯åŠ¨ç”¨æˆ·è¿›ç¨‹ã€‚æœ€åä¸€æ­¥è°ƒç”¨å†…æ ¸ä¸­çš„forkå‡½æ•°ï¼Œå°†åˆ›å»ºçš„ç”¨æˆ·è¿›ç¨‹é™„åŠ åˆ°å†…æ ¸çº¿ç¨‹çš„cgroupsã€‚ ç”¨æˆ·æ¨¡å¼åŠ©æ‰‹APIå¯ç”¨äºå¤šç§åœºæ™¯ï¼Œå¦‚åŠ è½½æ¨¡å—ã€é‡æ–°å¯åŠ¨è®¡ç®—æœºã€ç”Ÿæˆå®‰å…¨å¯†é’¥å’Œä¼ é€’å†…æ ¸äº‹ä»¶ã€‚è™½ç„¶åœ¨ç”¨æˆ·ç©ºé—´ä¸­è§¦å‘è¿™äº›æ´»åŠ¨é€šå¸¸éœ€è¦rootæƒé™ï¼Œä½†ä»ç„¶å¯ä»¥åœ¨ç”¨æˆ·ç©ºé—´ä¸­è°ƒç”¨APIï¼Œè¿™å°†åœ¨4.1èŠ‚ä¸­è®¨è®ºã€‚ Delegating Workloads to Kernel Threadså¦ä¸€ç§åˆ©ç”¨å†…æ ¸çº¿ç¨‹æ¥æ‰“ç ´cgroupçº¦æŸçš„æ–¹æ³•æ˜¯å°†å·¥ä½œè´Ÿè½½å§”æ‰˜ç»™å®ƒä»¬ï¼Œå¦‚å›¾â·æ‰€ç¤ºã€‚åŒæ ·ï¼Œç”±äºæ‰€æœ‰å†…æ ¸çº¿ç¨‹éƒ½é™„åŠ åˆ°æ ¹cgroupï¼Œå› æ­¤è¿™äº›å·¥ä½œè´Ÿè½½æ‰€æ¶ˆè€—çš„èµ„æºé‡å°†è®¡å…¥ç›®æ ‡å†…æ ¸çº¿ç¨‹ï¼Œè€Œä¸æ˜¯åˆå§‹åŒ–ç”¨æˆ·ç©ºé—´è¿›ç¨‹ã€‚ Linuxå†…æ ¸è¿è¡Œå¤šä¸ªå†…æ ¸çº¿ç¨‹ï¼Œå¤„ç†å„ç§å†…æ ¸å‡½æ•°å¹¶åœ¨è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­è¿è¡Œå†…æ ¸ä»£ç ã€‚ä¾‹å¦‚ï¼Œkthreadæ˜¯å†…æ ¸çº¿ç¨‹å®ˆæŠ¤è¿›ç¨‹ï¼Œç”¨äºåˆ›å»ºå…¶ä»–å†…æ ¸çº¿ç¨‹;å¼•å…¥Kworkeræ¥å¤„ç†å·¥ä½œé˜Ÿåˆ—ä»»åŠ¡;KsoftirqdæœåŠ¡äºsoftirqs;è¿ç§»æ‰§è¡Œè¿ç§»ä½œä¸šï¼Œå°†ä»»åŠ¡ä»ä¸€ä¸ªæ ¸å¿ƒç§»åŠ¨åˆ°å¦ä¸€ä¸ªæ ¸å¿ƒ;kswapdç®¡ç†äº¤æ¢ç©ºé—´ã€‚å¯¹äºè¿™äº›å†…æ ¸çº¿ç¨‹ï¼Œæ ¹æ®å®ƒä»¬çš„åŠŸèƒ½ï¼Œå†…æ ¸å¯èƒ½åªåœ¨ç³»ç»Ÿä¸­è¿è¡Œä¸€ä¸ªçº¿ç¨‹(ä¾‹å¦‚kthread)ï¼Œæˆ–è€…æ¯ä¸ªå†…æ ¸è¿è¡Œä¸€ä¸ªçº¿ç¨‹(ä¾‹å¦‚ksoftirqd)ï¼Œæˆ–è€…æ¯ä¸ªå†…æ ¸è¿è¡Œå¤šä¸ªçº¿ç¨‹(ä¾‹å¦‚kworker)ã€‚ä¸€ç›´æœ‰æŠ¥é“ç§°ï¼Œç”±äºå„ç§bugå’Œé—®é¢˜ï¼Œå†…æ ¸çº¿ç¨‹ä¼šæ¶ˆè€—å¤§é‡çš„èµ„æºã€‚å› æ­¤ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹å¯ä»¥å¼ºåˆ¶å†…æ ¸çº¿ç¨‹è¿è¡Œå§”æ‰˜çš„å·¥ä½œè´Ÿè½½ï¼Œç›¸åº”æ¶ˆè€—çš„èµ„æºå°†ä¸å—cgroupçš„é™åˆ¶ã€‚ Exploiting Service Processesé™¤äº†ç”±å†…æ ¸ç»´æŠ¤çš„å†…æ ¸çº¿ç¨‹å¤–ï¼ŒLinuxæœåŠ¡å™¨è¿˜è¿è¡Œå¤šä¸ªç³»ç»Ÿè¿›ç¨‹(ä¾‹å¦‚systemd)ï¼Œç”¨äºä¸åŒçš„ç›®çš„ï¼Œå¦‚è¿›ç¨‹ç®¡ç†ã€ç³»ç»Ÿä¿¡æ¯æ—¥å¿—è®°å½•ã€è°ƒè¯•ç­‰ã€‚è¿™äº›æµç¨‹ç›‘è§†å…¶ä»–æµç¨‹ï¼Œå¹¶åœ¨è§¦å‘ç‰¹å®šæ´»åŠ¨æ—¶ç”Ÿæˆå·¥ä½œè´Ÿè½½ã€‚åŒæ—¶ï¼Œè®¸å¤šç”¨æˆ·ç©ºé—´è¿›ç¨‹ä½œä¸ºå…¶ä»–è¿›ç¨‹çš„ä¾èµ–å…³ç³»ï¼ŒåŒæ—¶è¿è¡Œä»¥æ”¯æŒå…¶ä»–è¿›ç¨‹çš„æ­£å¸¸åŠŸèƒ½ã€‚å¦‚æœä¸€ä¸ªç”¨æˆ·è¿›ç¨‹èƒ½å¤Ÿåœ¨è¿™äº›è¿›ç¨‹ä¸Šç”Ÿæˆå†…æ ¸å·¥ä½œè´Ÿè½½(å›¾ä¸­çš„ç­–ç•¥â¸ )ï¼Œæ‰€æ¶ˆè€—çš„èµ„æºå°±ä¸ä¼šè¢«åˆ†é…ç»™åˆå§‹åŒ–è¿›ç¨‹ï¼Œä»è€Œå¯ä»¥é€ƒè„±cgroupsæœºåˆ¶ã€‚ Exploiting Interrupt Contextæœ€åä¸€ç§ç­–ç•¥æ˜¯åˆ©ç”¨ä¸­æ–­ä¸Šä¸‹æ–‡ä¸­æ‰€æ¶ˆè€—çš„èµ„æºã€‚cgroupæœºåˆ¶åªè®¡ç®—åœ¨è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­æ¶ˆè€—çš„èµ„æºã€‚ä¸€æ—¦å†…æ ¸è¿è¡Œåœ¨å…¶ä»–ä¸Šä¸‹æ–‡(å¦‚ä¸­æ–­ä¸Šä¸‹æ–‡,å¦‚å›¾æ‰€ç¤ºçš„ç­–ç•¥â¹),æ‰€æœ‰æ¶ˆè€—çš„èµ„æºéƒ½ä¸ä¼šè¢«è®¡å…¥ä»»ä½•cgroup ç‰¹åˆ«åœ°ï¼ŒLinuxå†…æ ¸æœåŠ¡ä¸­æ–­åˆ†ä¸ºä¸¤éƒ¨åˆ†:ä¸ŠåŠéƒ¨åˆ†(å³ç¡¬ä»¶ä¸­æ–­)å’Œä¸‹åŠéƒ¨åˆ†(å³è½¯ä»¶ä¸­æ–­)ã€‚ç”±äºç¡¬ä»¶ä¸­æ–­å¯èƒ½éšæ—¶è¢«å¼•å‘ï¼Œå› æ­¤ä¸ŠåŠéƒ¨åˆ†ä»…é€šè¿‡å“åº”ç¡¬ä»¶ä¸­æ–­æ¥æ‰§è¡Œè½»é‡çº§æ“ä½œï¼Œç„¶åå®‰æ’(å»¶è¿Ÿ)ä¸‹åŠéƒ¨åˆ†çš„æ‰§è¡Œã€‚å½“åœ¨ä¸‹åŠéƒ¨åˆ†æ‰§è¡Œä¸­æ–­å¤„ç†ç¨‹åºæ—¶ï¼Œå†…æ ¸è¿è¡Œåœ¨è½¯ä»¶ä¸­æ–­ä¸Šä¸‹æ–‡ä¸­ï¼Œå› æ­¤å®ƒä¸ä¼šä¸ºç³»ç»Ÿèµ„æº(ä¾‹å¦‚CPU)æ”¶å–ä»»ä½•è¿›ç¨‹çš„è´¹ç”¨ã€‚ ä»å†…æ ¸3.6å¼€å§‹ï¼Œsoftirqçš„å¤„ç†(ç¡¬ä»¶ä¸­æ–­å¼•å‘çš„é™¤å¤–)ä¸ç”Ÿæˆå®ƒä»¬çš„è¿›ç¨‹ç»‘å®šã€‚ è¿™æ„å‘³ç€åœ¨softirqä¸Šä¸‹æ–‡ä¸­æ‰€æ¶ˆè€—çš„æ‰€æœ‰èµ„æºéƒ½ä¸ä¼šæ¶ˆè€—æ‰€å¼•å‘è¿›ç¨‹çš„ä»»ä½•é…é¢ã€‚æ­¤å¤–ï¼Œsoftirqsçš„æ‰§è¡Œå°†æŠ¢å å½“å‰è¿›ç¨‹ä¸Šçš„ä»»ä½•å·¥ä½œè´Ÿè½½ï¼Œæ‰€æœ‰è¿›ç¨‹å°†è¢«å»¶è¿Ÿã€‚ æ­¤å¤–ï¼Œå¦‚æœå¤„ç†softirqsçš„å·¥ä½œè´Ÿè½½è¿‡é‡ï¼Œå†…æ ¸å°†æŠŠå®ƒä»¬å¸è½½åˆ°å†…æ ¸çº¿ç¨‹ksoftirqdï¼Œè¿™æ˜¯ä¸€ä¸ªæ¯ä¸ªCPU(å³æ¯ä¸ªCPUä¸€ä¸ªçº¿ç¨‹)çš„å†…æ ¸çº¿ç¨‹ï¼Œå¹¶ä»¥é»˜è®¤çš„è¿›ç¨‹ä¼˜å…ˆçº§è¿è¡Œã€‚ä¸€æ—¦å¸è½½ï¼Œå¯¹softirqsçš„å¤„ç†å°†åœ¨ksoftirqdçš„è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­è¿è¡Œï¼Œå› æ­¤ä»»ä½•èµ„æºæ¶ˆè€—éƒ½å°†åœ¨çº¿ç¨‹ksoftirqdä¸Šè®¡ç®—ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒå±äºå†…æ ¸çº¿ç¨‹ç­–ç•¥(å¦‚å›¾æ‰€ç¤ºçš„ç­–ç•¥â· )ã€‚æ€»ä¹‹ï¼Œå¦‚æœä¸€ä¸ªè¿›ç¨‹(ç§°ä¸ºè¿›ç¨‹A)èƒ½å¤Ÿå¼•å‘å¤§é‡çš„è½¯ä»¶ä¸­æ–­ï¼Œå†…æ ¸å°†ä¸å¾—ä¸åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡æˆ–ksoftirqdçš„è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­èŠ±è´¹èµ„æºæ¥å¤„ç†è½¯ä¸­æ–­ï¼Œè€Œä¸å‘è¿›ç¨‹Aæ”¯ä»˜è´¹ç”¨ã€‚ CASE STUDIES ON CONTAINERSåœ¨å‰ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å‡ ç§å¯èƒ½çš„ç­–ç•¥æ¥é€ƒé¿cgroupsçš„èµ„æºæ§åˆ¶ã€‚ç„¶è€Œï¼Œåœ¨ç°å®çš„å®¹å™¨ç¯å¢ƒä¸­ï¼Œç”±äºå­˜åœ¨å…¶ä»–åˆä½œå®‰å…¨ç­–ç•¥ï¼Œå¼€å‘æ›´å…·æŒ‘æˆ˜æ€§ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»åœ¨Dockerå®¹å™¨ç¯å¢ƒä¸­è¿›è¡Œçš„äº”ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œä»¥æ¼”ç¤ºåˆ©ç”¨cgroupså¼±ç‚¹çš„è¯¦ç»†æ­¥éª¤ã€‚ Threat model æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªå¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒï¼Œå…¶ä¸­å±äºä¸åŒç§Ÿæˆ·çš„å¤šä¸ªDockerå®¹å™¨å…±äº«åŒä¸€å°ç‰©ç†æœºå™¨ã€‚ç›®å‰ï¼Œè¾¹ç¼˜å’Œäº‘å¹³å°éƒ½å¹¿æ³›é‡‡ç”¨äº†å¤šç§Ÿæˆ·ç¯å¢ƒã€‚ç³»ç»Ÿç®¡ç†å‘˜ä½¿ç”¨cgroupsä¸ºæ¯ä¸ªå®¹å™¨è®¾ç½®èµ„æºé™åˆ¶ã€‚æ¯ä¸ªå®¹å™¨éƒ½æ˜¯å»ç‰¹æƒçš„ï¼Œè®¾ç½®æœ‰æœ‰é™çš„CPUæ—¶é—´ã€ç³»ç»Ÿå†…å­˜ã€å—I&#x2F;Oå¸¦å®½ï¼Œå¹¶å›ºå®šåˆ°ç‰¹å®šçš„æ ¸å¿ƒã€‚æˆ‘ä»¬å‡è®¾æ”»å‡»è€…æ§åˆ¶äº†ä¸€ä¸ªå®¹å™¨å®ä¾‹ï¼Œå¹¶è¯•å›¾åˆ©ç”¨cgroupsä¸­çš„ä¸è¶³(1)é™ä½å…¶ä»–å®¹å™¨çš„æ€§èƒ½ï¼Œ(2)è·å¾—ä¸å…¬å¹³çš„ä¼˜åŠ¿ã€‚ Configuration æˆ‘ä»¬ä½¿ç”¨Dockerå®¹å™¨é€šè¿‡æä¾›çš„æ¥å£æ¥è®¾ç½®cgroupsçš„é…ç½®ã€‚æ­¤å¤–ï¼ŒDockerè¿˜é»˜è®¤ç¡®ä¿å®¹å™¨é€šè¿‡namespaceéš”ç¦»ã€‚ç‰¹åˆ«æ˜¯ï¼Œå¯ç”¨USER namespaceåï¼Œå®¹å™¨ä¸­çš„æ ¹ç”¨æˆ·å°†æ˜ å°„åˆ°ä¸»æœºä¸Šçš„éç‰¹æƒç”¨æˆ·ã€‚ å› æ­¤ï¼Œå®¹å™¨ä¸­çš„ç‰¹æƒæ“ä½œä¸ä¼šå½±å“ä¸»æœºå†…æ ¸ã€‚æˆ‘ä»¬çš„æ¡ˆä¾‹ç ”ç©¶å°±æ˜¯åœ¨è¿™æ ·ä¸€ä¸ªæ²¡æœ‰ç‰¹æƒçš„å®¹å™¨ä¸­è¿›è¡Œçš„ã€‚ ä¸ºäº†æ¼”ç¤ºæ¯ç§åˆ©ç”¨çš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬é€šè¿‡åœ¨ç©ºé—²æœåŠ¡å™¨ä¸Šè®¾ç½®å¤šä¸ªcgroupé…ç½®æ¥åˆå§‹åŒ–å®¹å™¨ï¼Œå¹¶æµ‹é‡ä¸»æœºä¸Šç³»ç»Ÿèµ„æºçš„åˆ©ç”¨ç‡ã€‚ä¸ºäº†æ¨¡æ‹Ÿè¾¹ç¼˜å’Œäº‘ç¯å¢ƒï¼Œæˆ‘ä»¬é€‰æ‹©äº†ä¸¤ä¸ªæµ‹è¯•å¹³å°æ¥è¿›è¡Œå®éªŒ:(1)æˆ‘ä»¬å®éªŒå®¤çš„æœ¬åœ°æœºå™¨;(2) Amazon EC2ä¸­çš„ä¸“ç”¨ä¸»æœºã€‚ç‰¹åˆ«æ˜¯ï¼Œè™½ç„¶æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å°é…å¤‡äº†7200 rpmçš„SATAç¡¬ç›˜é©±åŠ¨å™¨ï¼Œä½†æˆ‘ä»¬åœ¨EC2æœåŠ¡å™¨ä¸Šé€‰æ‹©äº†æ›´å¥½çš„I&#x2F;Oé…ç½®ã€‚ä¸“ç”¨è¯•éªŒå°çš„å­˜å‚¨é…ç½®äº†1000iopsçš„SSD(é»˜è®¤ä¸º400)ï¼Œååé‡æ¯”æˆ‘ä»¬æœ¬åœ°è¯•éªŒå°æé«˜20å€å·¦å³ã€‚å› æ­¤ï¼Œæœ¬åœ°æµ‹è¯•å¹³å°è¡¨ç¤ºå¯èƒ½éƒ¨ç½²åœ¨è¾¹ç¼˜ç¯å¢ƒä¸­çš„æ€§èƒ½è¾ƒä½çš„èŠ‚ç‚¹ï¼Œè€Œå¼ºå¤§çš„ä¸“ç”¨æœåŠ¡å™¨å¯ä»¥æ¨¡æ‹Ÿå¤šç§Ÿæˆ·å®¹å™¨äº‘ç¯å¢ƒã€‚ Ethical hacking concerns ä½¿ç”¨cgroupå°†ä¸å¯é¿å…åœ°äº§ç”Ÿä¸»æœºçº§çš„å½±å“ï¼Œè¿™å¯èƒ½ä¼šå½±å“ä¸»æœºæœåŠ¡å™¨ä¸Šæ‰€æœ‰å®¹å™¨çš„æ€§èƒ½ã€‚å› æ­¤ï¼Œå¯¹äºæˆ‘ä»¬åœ¨Amazon EC2ä¸Šçš„å®éªŒï¼Œæˆ‘ä»¬é€‰æ‹©ä½¿ç”¨ä¸“ç”¨æœåŠ¡å™¨ï¼Œè¯¥æœåŠ¡å™¨ä»…ä¾›æˆ‘ä»¬ä½¿ç”¨ï¼Œä¸ä¸å…¶ä»–ç§Ÿæˆ·å…±äº«ã€‚ æ­¤å¤–ï¼Œå®ƒè¿˜å…è®¸æˆ‘ä»¬æ¨¡æ‹Ÿå¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒå¹¶åº¦é‡ç³»ç»ŸèŒƒå›´çš„å½±å“ã€‚ Result summary è¡¨ç»™å‡ºäº†æ‰€æœ‰æ¡ˆä¾‹ç ”ç©¶çš„æ€»ä½“æ€»ç»“ã€ç›¸åº”çš„å¼€å‘ç­–ç•¥å’Œå½±å“ã€‚ç¬¬ä¸€ä¸ªæ¡ˆä¾‹ç ”ç©¶æ˜¯åˆ©ç”¨å†…æ ¸ä¸­çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ï¼Œè¿™æ¶‰åŠåˆ°ç­–ç•¥â¶ã€‚æˆ‘ä»¬å‘ç°å®¹å™¨ä¸­å¼•å‘çš„å¼‚å¸¸å¯ä»¥è°ƒç”¨ç”¨æˆ·ç©ºé—´è¿›ç¨‹ï¼Œå…¶åæœæ˜¯å®¹å™¨å¯ä»¥æ¶ˆè€—æ¯”cgroupsé™åˆ¶å¤š200å€çš„CPUèµ„æºã€‚ç¬¬äºŒç§æƒ…å†µæ˜¯åˆ©ç”¨å›å†™æœºåˆ¶è¿›è¡Œç£ç›˜æ•°æ®åŒæ­¥ï¼Œè¿™æ¶‰åŠåˆ°ç­–ç•¥â·ã€‚å®¹å™¨å¯ä»¥ä¸æ–­è°ƒç”¨å…¨å±€æ•°æ®åŒæ­¥ï¼Œä»¥é™ä½ä¸»æœºä¸Šç‰¹å®šI&#x2F;Oå·¥ä½œè´Ÿè½½çš„é€Ÿåº¦ï¼Œæœ€é«˜å¯è¾¾95%ã€‚ç¬¬ä¸‰ç§æƒ…å†µæ˜¯åˆ©ç”¨ç³»ç»ŸæœåŠ¡æ—¥å¿—(é€šè¿‡ç­–ç•¥â¸)ï¼Œäº§ç”Ÿæ¶ˆè€—CPUå’Œå—è®¾å¤‡å¸¦å®½çš„å·¥ä½œè´Ÿè½½ã€‚ç¬¬å››ç§æƒ…å†µæ˜¯åˆ©ç”¨å®¹å™¨å¼•æ“åœ¨å®¹å™¨å¼•æ“è¿›ç¨‹(ç­–ç•¥â¸)å’Œå†…æ ¸çº¿ç¨‹(ç­–ç•¥ â·)ä¸Šäº§ç”Ÿé¢å¤–çš„æœªè®¡ç®—çš„å·¥ä½œè´Ÿè½½(å¤§çº¦3å€)ã€‚æœ€åä¸€ç§æƒ…å†µæ˜¯åˆ©ç”¨softirqå¤„ç†æœºåˆ¶åœ¨å†…æ ¸çº¿ç¨‹(ç­–ç•¥ â·)å’Œä¸­æ–­ä¸Šä¸‹æ–‡(ç­–ç•¥â¹)ä¸Šæ¶ˆè€—CPUå‘¨æœŸã€‚ Case 1:Exception Handlingç¬¬ä¸€ç§æƒ…å†µæ˜¯åˆ©ç”¨å†…æ ¸ä¸­çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ã€‚æˆ‘ä»¬å‘ç°å¯ä»¥è°ƒç”¨ç”¨æˆ·æ¨¡å¼åŠ©æ‰‹APIï¼Œå¹¶é€šè¿‡å¼‚å¸¸è¿›ä¸€æ­¥è§¦å‘ç”¨æˆ·ç©ºé—´æµç¨‹(ä½œä¸ºç­–ç•¥â¶)ã€‚é€šè¿‡åå¤äº§ç”Ÿå¼‚å¸¸ï¼Œä¸€ä¸ªå®¹å™¨æ¶ˆè€—çš„CPUèµ„æºæ¯”é™åˆ¶å¤šçº¦200å€ï¼Œä»è€Œä½¿åŒä¸€ä¸»æœº(ä¸é™äºä¸€ä¸ªæ ¸)ä¸Šå…¶ä»–å®¹å™¨çš„æ€§èƒ½æ˜¾è‘—é™ä½85% ~ 95%ã€‚ Detailed analysis Linuxå†…æ ¸ä¸ºå„ç§å¼‚å¸¸æä¾›äº†ä¸“ç”¨çš„å¼‚å¸¸å¤„ç†ç¨‹åºï¼ŒåŒ…æ‹¬é”™è¯¯(ä¾‹å¦‚ï¼Œåˆ†å‰²é”™è¯¯)å’Œé™·é˜±(ä¾‹å¦‚ï¼Œæº¢å‡º)ã€‚å†…æ ¸ç»´æŠ¤ä¸€ä¸ªä¸­æ–­æè¿°ç¬¦è¡¨(IDT)ï¼Œå…¶ä¸­åŒ…å«æ¯ä¸ªä¸­æ–­æˆ–å¼‚å¸¸å¤„ç†ç¨‹åºçš„åœ°å€ã€‚å¦‚æœCPUåœ¨ç”¨æˆ·æ¨¡å¼ä¸‹å¼•å‘å¼‚å¸¸ï¼Œç›¸åº”çš„å¤„ç†ç¨‹åºå°†åœ¨å†…æ ¸æ¨¡å¼ä¸‹è°ƒç”¨ã€‚å¤„ç†å™¨é¦–å…ˆåœ¨å†…æ ¸å †æ ˆä¸­ä¿å­˜å¯„å­˜å™¨ï¼Œç„¶åç›¸åº”åœ°å¤„ç†å¼‚å¸¸ï¼Œæœ€åè¿”å›åˆ°ç”¨æˆ·æ¨¡å¼ã€‚æ•´ä¸ªè¿‡ç¨‹åœ¨å†…æ ¸ç©ºé—´å’Œè§¦å‘å¼‚å¸¸çš„è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­è¿è¡Œã€‚å› æ­¤ï¼Œå®ƒå°†è¢«å……ç”µåˆ°æ­£ç¡®çš„ç›¸åº”çš„cgroupsã€‚ ç„¶è€Œï¼Œè¿™äº›å¼‚å¸¸å°†å¯¼è‡´åˆå§‹è¿›ç¨‹çš„ç»ˆæ­¢å¹¶å¼•å‘ä¿¡å·ã€‚è¿™äº›ä¿¡å·å°†è¿›ä¸€æ­¥è§¦å‘å†…æ ¸è½¬å‚¨åŠŸèƒ½ï¼Œç”Ÿæˆä¸€ä¸ªç”¨äºè°ƒè¯•çš„å†…æ ¸è½¬å‚¨æ–‡ä»¶ã€‚å†…æ ¸ä¸­çš„æ ¸å¿ƒè½¬å‚¨ä»£ç é€šè¿‡usermodeè¾…åŠ©APIä»å†…æ ¸ä¸­è°ƒç”¨ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºã€‚åœ¨Ubuntuä¸­ï¼Œé»˜è®¤çš„ç”¨æˆ·ç©ºé—´æ ¸å¿ƒè½¬å‚¨ç¨‹åºæ˜¯Apportï¼Œå®ƒå°†åœ¨æ¯ä¸ªå¼‚å¸¸æƒ…å†µä¸‹è¢«è§¦å‘ã€‚æ­£å¦‚ä¸Šä¸€èŠ‚æ‰€æåˆ°çš„ï¼ŒApportæ‰€æ¶ˆè€—çš„ç³»ç»Ÿèµ„æºå°†ä¸ä¼šç”±å®¹å™¨æ‰¿æ‹…ï¼Œå› ä¸ºè¯¥è¿›ç¨‹æ˜¯ç”±å†…æ ¸çº¿ç¨‹åˆ†å‰çš„ï¼Œè€Œä¸æ˜¯ç”±å®¹å™¨åŒ–çš„è¿›ç¨‹ã€‚ æ–°äº§ç”Ÿçš„Apportå®ä¾‹å°†è¢«å†…æ ¸å®‰æ’åˆ°æ‰€æœ‰çš„CPUæ ¸å¿ƒï¼Œä»¥è¾¾åˆ°è´Ÿè½½å¹³è¡¡çš„ç›®çš„ï¼Œå› æ­¤æ‰“ç ´äº†cpusetsçš„cgroupã€‚åŒæ—¶ï¼Œç”±äºApportè¿›ç¨‹çš„è¿è¡Œæ¯”è½»é‡çº§çš„å¼‚å¸¸å¤„ç†ï¼ˆå³å†…æ ¸æ§åˆ¶è·¯å¾„ï¼‰æ¶ˆè€—æ›´å¤šçš„èµ„æºï¼Œå¦‚æœå®¹å™¨ä¸æ–­å¼•å‘å¼‚å¸¸ï¼Œæ•´ä¸ªCPUå°†è¢«Apportè¿›ç¨‹å®Œå…¨å æ®ã€‚cpu cgroupçš„é€ƒé€¸å¯¼è‡´åˆ†é…ç»™å®¹å™¨çš„ç³»ç»Ÿèµ„æºçš„å·¨å¤§æ”¾å¤§ã€‚ Workloads amplification ä¸ºäº†ç ”ç©¶è¿™ç§å½±å“ï¼Œæˆ‘ä»¬åœ¨ä¸€ä¸ªæ ¸å¿ƒä¸Šå¯åŠ¨å¹¶å›ºå®šä¸€ä¸ªå®¹å™¨ã€‚æˆ‘ä»¬é€šè¿‡è°ƒæ•´å‘¨æœŸå’Œé…é¢æ¥ä¸ºå®¹å™¨è®¾ç½®ä¸åŒçš„CPUèµ„æºé™åˆ¶ã€‚ å®¹å™¨è¿›å…¥å¾ªç¯ï¼Œä¸æ–­å¼•å‘å¼‚å¸¸ã€‚æˆ‘ä»¬å®ç°äº†å‡ ç§ç”¨æˆ·ç©ºé—´ç¨‹åºå¯ç”¨çš„å¼‚å¸¸ç±»å‹ã€‚ç”±äºä¸åŒç±»å‹çš„å¼‚å¸¸çš„ç»“æœæ˜¯ç›¸ä¼¼çš„ï¼Œæˆ‘ä»¬ä½¿ç”¨div 0å¼‚å¸¸ä½œä¸ºä¾‹å­ã€‚å®¹å™¨æ˜¯å”¯ä¸€åœ¨æˆ‘ä»¬çš„æµ‹è¯•å¹³å°ä¸­è¿è¡Œçš„æ´»åŠ¨ç¨‹åºã€‚æˆ‘ä»¬é€šè¿‡topå‘½ä»¤æµ‹é‡æµ‹è¯•å¹³å°çš„CPUä½¿ç”¨ç‡ï¼Œé€šè¿‡Dockerçš„ç»Ÿè®¡å·¥å…·æµ‹é‡å®¹å™¨çš„CPUä½¿ç”¨ç‡ã€‚å¯¹äºä¸»æœºçº§åˆ«çš„ä½¿ç”¨æƒ…å†µï¼Œæˆ‘ä»¬å°†æ‰€æœ‰å†…æ ¸çš„CPUä½¿ç”¨é‡æ±‡æ€»åœ¨ä¸€èµ·ï¼ˆå› æ­¤12ä¸ªå†…æ ¸çš„æœ€å¤§ä½¿ç”¨é‡ä¸º1200%ï¼‰ã€‚æˆ‘ä»¬å°†æ”¾å¤§ç³»æ•°å®šä¹‰ä¸ºä¸»æœºçš„CPUåˆ©ç”¨ç‡ä¸å®¹å™¨çš„CPUåˆ©ç”¨ç‡çš„æ¯”ç‡ã€‚ å›¾æ¼”ç¤ºäº†ç”¨æˆ·æ¨¡å¼åŠ©æ‰‹APIå¯ä»¥è§¦å‘ç”¨æˆ·ç©ºé—´ç¨‹åºï¼Œä»è€Œæ˜¾è‘—æé«˜å®¹å™¨çš„CPUä½¿ç”¨ç‡ã€‚åœ¨æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°ä¸Šï¼Œå®¹å™¨ä½¿ç”¨çš„ä¸€ä¸ªå†…æ ¸ä¸Šçš„CPUåˆ©ç”¨ç‡åªæœ‰7.4%ï¼Œæ•´ä¸ª12ä¸ªå†…æ ¸éƒ½è¢«å ç”¨äº†ã€‚å½“æˆ‘ä»¬å°†åˆ†é…ç»™å®¹å™¨çš„CPUèµ„æºå‡å°‘åˆ°ä»…10%å†…æ ¸(é€šè¿‡è®¾ç½®periodä¸º200,000,quotaä¸º20,000)åï¼Œè¿™ä¸ªé—®é¢˜æ— æ³•ç¼“è§£ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥å°†å®¹å™¨çš„CPUé™åˆ¶é™ä½åˆ°20%æ ¸å¿ƒï¼Œå¹¶æœ€ç»ˆå°†12ä¸ªæ ¸å¿ƒçš„æ€»åˆ©ç”¨ç‡é™åˆ¶åˆ°1,065%ï¼Œæ”¾å¤§å› å­ä¸º207Ã—ã€‚åŒæ—¶ï¼Œç³»ç»Ÿå†…å­˜ä½¿ç”¨å¢åŠ äº†çº¦1GBï¼Œè€ŒDockeræµ‹é‡çš„å®¹å™¨å†…å­˜ä½¿ç”¨ä»…ä¸º15.58MBã€‚ æˆ‘ä»¬ä»EC2æœåŠ¡å™¨ä¸Šè·å¾—äº†ç±»ä¼¼çš„ç»“æœ:å®¹å™¨çš„22.5%çš„åˆ©ç”¨ç‡å°±å¯ä»¥è€—å°½36ä¸ªå†…æ ¸ã€‚ç”±äºCPUé¢‘ç‡ä¸å¦‚æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°å¼ºå¤§ï¼Œä¸€æ—¦æˆ‘ä»¬å°†å®¹å™¨çš„CPUèµ„æºé™åˆ¶ä¸º1&#x2F;10å†…æ ¸ï¼Œå®ƒå¯ä»¥åœ¨æ‰€æœ‰36ä¸ªå†…æ ¸ä¸Šäº§ç”Ÿ1907%çš„åˆ©ç”¨ç‡ã€‚æ”¾å¤§ç³»æ•°çº¦ä¸º192Ã—ã€‚ The pid controller è™½ç„¶æ”¾å¤§è¦æ±‚å®¹å™¨ä¸æ–­æŠ›å‡ºå¼‚å¸¸ï¼Œä½†æˆ‘ä»¬è¿›ä¸€æ­¥ä½¿ç”¨pid cgroupå­ç³»ç»Ÿå¯¹å®¹å™¨çš„ä»»åŠ¡æ•°é‡è®¾ç½®ä¸€å®šçš„é™åˆ¶ã€‚åŒæ ·ï¼Œå¦‚å›¾æ‰€ç¤ºï¼Œå³ä½¿æ´»åŠ¨è¿›ç¨‹çš„æ•°é‡è¢«é™åˆ¶åœ¨50ä¸ªï¼Œpidæ§åˆ¶å™¨ä¹Ÿä¸èƒ½é™ä½æ”¾å¤§ç»“æœï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸å°çš„æ•°å­—ï¼Œå¯èƒ½ä¼šå¯¹å®¹å™¨ç”¨æˆ·é€ æˆå·¨å¤§çš„å¯ç”¨æ€§å½±å“ã€‚åœ¨å•æ ¸CPUè®¡ç®—èƒ½åŠ›åªæœ‰20%çš„æƒ…å†µä¸‹ï¼Œå°†pidé™åˆ¶ä¸º50ï¼Œæ”¾å¤§ç³»æ•°å¯ä»¥é™ä½åˆ°98Ã—ã€‚åœ¨EC2æœåŠ¡å™¨ä¸Šï¼Œåœ¨å•æ ¸10% CPUè®¡ç®—èƒ½åŠ›çš„å®¹å™¨ä¸Šï¼Œé€šè¿‡å°†pidæ•°é‡é™åˆ¶åœ¨50ä¸ªï¼Œæ”¾å¤§ç³»æ•°åœ¨144Ã—å·¦å³. Denial-of-service(DoS) attacks å½“å¤šä¸ªå®¹å™¨åœ¨åŒä¸€ä¸ªæ ¸å¿ƒä¸Šè¿è¡Œæ—¶ï¼Œå®ƒä»¬å°†å…±äº«å’Œç«äº‰CPUèµ„æºã€‚Linuxçš„CFSç³»ç»Ÿæ ¹æ®æ¯ä¸ªå®¹å™¨çš„ä»½é¢æ¥åˆ†é…CPUå‘¨æœŸã€‚CFSç³»ç»Ÿç¡®ä¿äº†å®Œå…¨çš„å…¬å¹³æ€§ï¼Œå³å®¹å™¨å¯ä»¥å®Œå…¨åˆ©ç”¨å…¶æ’æ§½ä¸­çš„æ‰€æœ‰èµ„æºã€‚ç„¶è€Œ,å¦‚æœä¸€ä¸ªæ¶æ„çš„å®¹å™¨å¯ä»¥åœ¨å®ƒè‡ªå·±çš„cgroupä¹‹å¤–äº§ç”Ÿæ–°çš„å·¥ä½œè´Ÿè½½ï¼ŒCFSç³»ç»Ÿä¹Ÿä¼šå°†CPUå‘¨æœŸåˆ†é…ç»™è¿™äº›è¿›ç¨‹ï¼Œä»è€Œå‡å°‘å…¶ä»–co-residenceå®¹å™¨çš„ä½¿ç”¨ã€‚åŒæ—¶ï¼ŒCPUä½¿ç”¨ç‡çš„ä¸‹é™ä¹Ÿå¯èƒ½å½±å“å…¶ä»–çš„æ€§èƒ½ï¼Œå¦‚å†…å­˜å’ŒI&#x2F;Oååé‡ã€‚ åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæˆ‘ä»¬é€šè¿‡åˆ©ç”¨æ¶æ„å®¹å™¨ä¸­çš„å¼‚å¸¸å¤„ç†æœºåˆ¶æ¥è¡¡é‡DoSæ”»å‡»çš„å½±å“ã€‚æˆ‘ä»¬è¿è¡Œä¸¤ä¸ªå®¹å™¨:ä¸€ä¸ªæ¶æ„å®¹å™¨å’Œä¸€ä¸ªå—å®³è€…ã€‚æˆ‘ä»¬å°†æ”»å‡»çš„æ€§èƒ½ä¸æ¶æ„å®¹å™¨è¿è¡Œæ­£å¸¸å·¥ä½œè´Ÿè½½(å³åŸºçº¿)çš„æƒ…å†µè¿›è¡Œæ¯”è¾ƒã€‚å—å®³å®¹å™¨è¿è¡Œä¸åŒçš„sysbenchå·¥ä½œè´Ÿè½½æ¥åº¦é‡æ€§èƒ½ã€‚ è¿™ä¸¤ä¸ªæœåŠ¡å™¨ä¸Šçš„ç»“æœå¦‚è¡¨æ‰€ç¤ºã€‚æˆ‘ä»¬é¦–å…ˆå°†ä¸¤ä¸ªå®¹å™¨è®¾ç½®åœ¨ç›¸åŒçš„å†…æ ¸ä¸Šï¼Œä½¿ç”¨å®Œå…¨ç›¸åŒçš„CPUå…±äº«å’Œé…é¢ã€‚æˆ‘ä»¬å‘ç°ï¼Œåœ¨æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°ä¸Šï¼ŒæŠ›å‡ºå¼‚å¸¸(å¯¼è‡´å†…æ ¸è½¬å‚¨)å¯ä»¥æ˜¾è‘—é™ä½95%çš„CPUå’Œå†…å­˜æ€§èƒ½ï¼Œå¹¶é™ä½17%å·¦å³çš„I&#x2F;Oæ€§èƒ½ã€‚åœ¨EC2æœåŠ¡å™¨ä¸Šï¼Œå¤§çº¦85%ç”¨äºCPUå’Œå†…å­˜æ€§èƒ½ï¼Œ82%ç”¨äºI&#x2F;Oæ€§èƒ½ã€‚è¿™æ˜¯åˆç†çš„ï¼Œå› ä¸ºå¼•å‘å¼‚å¸¸ä¼šå¯¼è‡´å¤§é‡ç”¨æˆ·ç©ºé—´æ ¸å¿ƒè½¬å‚¨åº”ç”¨ç¨‹åºä¸å—å®³å®¹å™¨ç«äº‰CPUå‘¨æœŸã€‚ é€šè¿‡å°†å®¹å™¨å›ºå®šåœ¨ä¸åŒçš„æ ¸å¿ƒä¸Šï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥æ”¹å˜äº†æ¶æ„å®¹å™¨çš„æ ¸å¿ƒäº²ç¼˜æ€§ã€‚å°½ç®¡æ¶æ„å®¹å™¨ä¸å†ä¸å—å®³è€…ç«äº‰åŒä¸€å†…æ ¸ä¸Šçš„CPUèµ„æºï¼Œä½†å®ƒåœ¨å—å®³è€…çš„æ€§èƒ½ä¸Šä»ç„¶æ˜¾ç¤ºå‡ºç±»ä¼¼çš„ç»“æœã€‚è¿™æ˜¯å› ä¸ºCPUèµ„æºçš„ä¸»è¦ç«äº‰å¯¹æ‰‹ä¸æ˜¯æ¶æ„å®¹å™¨ï¼Œè€Œæ˜¯é‚£äº›è§¦å‘å†…æ ¸è½¬å‚¨çš„åº”ç”¨ç¨‹åºã€‚ è¿™ä¸€ç»“æœè¡¨æ˜ï¼Œæ¶æ„ç§Ÿæˆ·å¯ä»¥å¾ˆå®¹æ˜“åœ°åˆ©ç”¨å®¹å™¨æ¥æ˜¾è‘—é™ä½åŒä¸€ä¸»æœºä¸Šæ‰€æœ‰å…¶ä»–å®¹å™¨çš„æ€§èƒ½ï¼Œå¹¶é™ä½æœåŠ¡ä¾›åº”å•†çš„æœåŠ¡è´¨é‡ï¼Œä»è€Œå¯èƒ½å¯¼è‡´å·¨å¤§çš„ç»æµæŸå¤±ï¼Œè€Œæˆæœ¬å¾ˆå°‘ã€‚ Case 2:Data Synchronizationæˆ‘ä»¬çš„ç¬¬äºŒä¸ªæ¡ˆä¾‹æ˜¯åˆ©ç”¨ç£ç›˜æ•°æ®åŒæ­¥çš„å›å†™æœºåˆ¶ï¼Œå‡ºäºæ€§èƒ½è€ƒè™‘ï¼Œè¯¥æœºåˆ¶è¢«å¹¿æ³›é‡‡ç”¨ã€‚CPUåªä¼šå°†æ›´æ–°åçš„æ•°æ®å†™å…¥ç¼“å­˜ï¼Œå½“ç¼“å­˜è¢«æ¸…é™¤æ—¶ï¼Œæ•°æ®æ‰ä¼šå†™å…¥ç£ç›˜ã€‚ ç”±äºæ‡’æƒ°çš„ç£ç›˜å›å†™æœºåˆ¶å°†å¯åŠ¨I&#x2F;Oçš„è¿›ç¨‹ä¸åŒæ­¥ç£ç›˜å†™å…¥çš„è¿›ç¨‹è§£è€¦ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„åˆ©ç”¨å¯ä»¥é€ƒé¿cgroupsã€‚æœ‰å¤šç§æ–¹æ³•å¯ä»¥è§¦å‘æ•°æ®åŒæ­¥ï¼ŒåŒ…æ‹¬å®šæœŸå›å†™å’Œå†…å­˜ä¸è¶³ã€‚å®ƒä¹Ÿå¯ä»¥ç”±ç”¨æˆ·è¿›ç¨‹é€šè¿‡ç³»ç»Ÿè°ƒç”¨æ•…æ„è°ƒç”¨ï¼Œå¦‚syncï¼ˆå°†ç¼“å­˜æ–‡ä»¶æ•°æ®çš„æ‰€æœ‰æœªå†³ä¿®æ”¹å†™å›ç»™åº•å±‚æ–‡ä»¶ç³»ç»Ÿï¼‰ã€syncfsï¼ˆåŒæ­¥å¼€æ”¾æ–‡ä»¶æ‰€æŒ‡çš„æ–‡ä»¶ç³»ç»Ÿï¼‰å’Œfsyncï¼ˆå°†æ–‡ä»¶çš„æ‰€æœ‰ä¿®æ”¹æ•°æ®ä¼ è¾“åˆ°å…¶å¸¸é©»ç£ç›˜è®¾å¤‡ï¼‰ã€‚è¿™äº›ç³»ç»Ÿè°ƒç”¨å¯¹Linuxå®¹å™¨æ˜¯å¯ç”¨çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬å‘ç°ï¼ŒåŒæ­¥å¯ä»¥è¢«åˆ©ç”¨æ¥å‡æ…¢æ•´ä¸ªç³»ç»Ÿçš„I&#x2F;Oæ€§èƒ½ï¼ˆä¾‹å¦‚ï¼Œåœ¨åºåˆ—å†™å…¥ä¸Šæœ‰è¶…è¿‡87%çš„é™çº§ï¼‰ï¼Œå‘èµ·æ— èµ„æºæ”»å‡»ï¼Œå¹¶å»ºç«‹ç§˜å¯†é€šé“ã€‚ Detailed analysis on sync åŒæ­¥çš„ç¬¬ä¸€æ­¥æ˜¯å¯åŠ¨ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ï¼Œå®ƒå°†é¡µç¼“å­˜ä¸­åŒ…å«çš„æ‰€æœ‰è„é¡µåˆ·æ–°åˆ°ç£ç›˜ã€‚å®ƒé€šè¿‡æ‰«ææ‰€æœ‰å½“å‰æŒ‚è½½çš„æ–‡ä»¶ç³»ç»Ÿæ¥æŸ¥æ‰¾è¦åˆ·æ–°çš„æ‰€æœ‰è„ç´¢å¼•èŠ‚ç‚¹ï¼Œå¹¶åˆ·æ–°ç›¸åº”çš„è„é¡µã€‚ç”±äºåŒæ­¥å…è®¸è¿›ç¨‹å°†æ‰€æœ‰è„ç¼“å†²åŒºå†™å›ç£ç›˜ï¼Œä»»ä½•I&#x2F;Oæ“ä½œéƒ½å¿…é¡»ç­‰å¾…åˆ·æ–°ã€‚ æ›´ç³Ÿç³•çš„æ˜¯ï¼Œç”±å…¶ä»–è¿›ç¨‹(å¯èƒ½å±äºå¦ä¸€ä¸ªå®¹å™¨)ç”Ÿæˆçš„è„ç¼“å†²åŒºä¹Ÿå°†è¢«è¿«å†™å›ç£ç›˜ã€‚ å®¹å™¨ä¸­çš„è¿›ç¨‹å¯ä»¥åœ¨ä¸æ‰§è¡ŒI&#x2F;Oæ“ä½œçš„æƒ…å†µä¸‹ï¼Œä»¥å°‘é‡çš„å·¥ä½œè´Ÿè½½é‡å¤è°ƒç”¨syncã€‚ä½†æ˜¯ï¼Œä¸æ­¤åŒæ—¶ï¼Œå¦‚æœåœ¨å…¶ä»–å…±é©»ç•™å®¹å™¨ä¸Šæœ‰I&#x2F;Oæ“ä½œï¼ŒåŒæ­¥å°†å›å†™æ‰€æœ‰è„é¡µã€‚åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæˆ‘ä»¬è¿è¡Œäº†ä¸€ä¸ªä¸æ–­è°ƒç”¨syncçš„å®¹å™¨ã€‚å®ƒä¸ä¼šå¯¼è‡´è¶…å‡ºå®¹å™¨é™åˆ¶çš„ä»»ä½•é¢å¤–åˆ©ç”¨ç‡ã€‚ç„¶è€Œï¼Œä¸€æ—¦æˆ‘ä»¬è¿è¡Œå¦ä¸€ä¸ªå®¹å™¨ï¼Œè¿›è¡Œä¸€äº›ç®€å•çš„å†™æ“ä½œï¼ŒåŒæ­¥æ“ä½œå°±ä¼šå¯¼è‡´å¤§é‡çš„CPUç­‰å¾…æ—¶é—´ï¼Œè¿™æ˜¯åŒæ­¥å’Œå†™æ“ä½œçš„ç»„åˆæ‰€äº§ç”Ÿçš„ã€‚CPUç­‰å¾…æ—¶é—´ç”¨äºæŒ‡ç¤ºI&#x2F;Oç­‰å¾…æ‰€æ¶ˆè€—çš„æ—¶é—´ï¼Œå…¶ä»–å·¥ä½œè´Ÿè½½ä»ç„¶å¯ä»¥ä½¿ç”¨å®ƒã€‚ ä½†æ˜¯ï¼Œåœ¨å…¶ä»–å®¹å™¨ä¸Šè¿è¡Œçš„ç‰¹å®šå·¥ä½œè´Ÿè½½çš„æ€§èƒ½ä¼šå—åˆ°æ˜¾è‘—å½±å“ã€‚ blkio cgroup æ­£å¦‚2.1èŠ‚ä¸­æåˆ°çš„ï¼Œblkio cgroupå­ç³»ç»Ÿå¯ä»¥å¯¹å—è®¾å¤‡åº”ç”¨I&#x2F;Oæ§åˆ¶ã€‚è™½ç„¶Dockeråªæ”¯æŒé€šè¿‡æƒé‡æ¥é™åˆ¶ç›¸å¯¹I&#x2F;Oååé‡ï¼Œä½†å†…æ ¸å®é™…ä¸Šå¯ä»¥ä¸ºcgroupsè®¾ç½®ä¸€ä¸ªä¸Šé™ã€‚æˆ‘ä»¬ä½¿ç”¨blkioå¯¹è¿è¡ŒåŒæ­¥çš„å®¹å™¨åº”ç”¨I&#x2F;Oæ§åˆ¶ã€‚ä¸å¹¸çš„æ˜¯ï¼ŒåŸºäºDockerçš„ç»Ÿè®¡å·¥å…·ï¼Œå®¹å™¨çš„I&#x2F;Oååé‡ä¸ºé›¶ã€‚å› æ­¤ï¼Œblkioæ§åˆ¶å™¨ä¸èƒ½å‡å°‘åŒæ­¥çš„å½±å“ã€‚åŸå› æ˜¯ç”±syncè§¦å‘çš„æ‰€æœ‰å›å†™å·¥ä½œè´Ÿè½½éƒ½åœ¨å†…æ ¸çº¿ç¨‹ä¸­å¤„ç†ï¼Œè°ƒç”¨syncçš„å®¹å™¨æ²¡æœ‰I&#x2F;Oå·¥ä½œè´Ÿè½½ã€‚ I&#x2F;O-based DoS attacks ä¸ç®¡å‘å‡ºI&#x2F;Oæ“ä½œçš„è¿›ç¨‹æ˜¯å¦åœ¨å®¹å™¨å†…ï¼Œåœ¨å®¹å™¨å†…è°ƒç”¨ç³»ç»Ÿè°ƒç”¨åŒæ­¥å°†ç»§ç»­è°ƒç”¨ç³»ç»ŸèŒƒå›´çš„å›å†™ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå›å†™ä¼šé™ä½ç³»ç»Ÿæ€§èƒ½ï¼Œå› ä¸ºç‰¹å®šçš„å·¥ä½œè´Ÿè½½éœ€è¦ç­‰å¾…å›å†™å®Œæˆã€‚ä¸ºäº†æµ‹è¯•æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬è¿è¡Œä¸¤ä¸ªå›ºå®šåœ¨ä¸¤ä¸ªä¸åŒæ ¸å¿ƒä¸Šçš„å®¹å™¨ã€‚æ¶æ„å®¹å™¨æ‰€åšçš„å”¯ä¸€ä»»åŠ¡æ˜¯è°ƒç”¨ç³»ç»Ÿè°ƒç”¨syncï¼Œå› æ­¤æœ¬èº«ä¸ä¼šæ‹›è‡´I&#x2F;Oæ“ä½œã€‚ ä¸ºäº†æµ‹é‡å—å®³å®¹å™¨çš„æ€§èƒ½ï¼Œæˆ‘ä»¬åœ¨å—å®³å®¹å™¨å†…è¿è¡ŒFIOåŸºå‡†æµ‹è¯•æ¥æµ‹é‡I&#x2F;Oæ€§èƒ½ã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬è¿›è¡Œäº†å››ç§ä¸åŒçš„FIOå·¥ä½œè´Ÿè½½ï¼ŒåŒ…æ‹¬åºåˆ—&#x2F;éšæœºå†™å’Œåºåˆ—&#x2F;éšæœºè¯»ã€‚æˆ‘ä»¬è¿˜è¿è¡ŒUnixBenchmarkæ¥æµ‹è¯•é™¤I&#x2F;Oä»¥å¤–å¯¹æ€§èƒ½çš„å½±å“ã€‚æˆ‘ä»¬é€šè¿‡å°†ç»“æœé™¤ä»¥æ¶æ„å®¹å™¨ä¸­è¿è¡Œç©ºé—²å¾ªç¯çš„åŸºçº¿æƒ…å†µæ¥è®¡ç®—æ€§èƒ½ä¸‹é™ã€‚ç»“æœå¦‚å›¾æ‰€ç¤ºã€‚å¯¹äºUnixBenchmarkï¼Œæˆ‘ä»¬åˆ—å‡ºäº†æ€§èƒ½æ˜¾è‘—ä¸‹é™çš„å·¥ä½œè´Ÿè½½ã€‚æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨å—å®³è€…ä¸­è¿è¡Œçš„FIOåŸºå‡†æµ‹è¯•çš„æ€§èƒ½å—åˆ°äº†å¾ˆå¤§çš„å½±å“ã€‚é€šè¿‡åœ¨æ¶æ„å®¹å™¨ä¸­ä¸æ–­è°ƒç”¨syncï¼Œæ‰€æœ‰å››ç§ç±»å‹I&#x2F;Oæ“ä½œçš„æ€§èƒ½éƒ½ä¼šå—åˆ°æ˜¾è‘—å½±å“ã€‚å¯¹äºé¡ºåºå†™å…¥ï¼Œåœ¨æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•åºŠä¸Šæ€§èƒ½ä¸‹é™åˆ°2%ï¼Œåœ¨EC2æœåŠ¡å™¨ä¸Šä¸‹é™åˆ°13%ã€‚ å¯¹äºUnixBenchmarkï¼Œè¿è¡Œshellè„šæœ¬çš„æ€§èƒ½ä¹Ÿä¸¥é‡é™ä½åˆ°ä¸åˆ°ä¸€åŠã€‚å¯¹äºå…¶ä»–åŸºå‡†æµ‹è¯•ï¼Œé€€åŒ–çº¦ä¸º5%åˆ°10%ã€‚ Resource-Freeing Attack(RFA) RFAæ”»å‡»çš„ç›®æ ‡æ˜¯é€šè¿‡äº‰å¤ºå—å®³è€…çš„ç“¶é¢ˆèµ„æºæ¥ä¸ºæ”»å‡»è€…çš„å®ä¾‹é‡Šæ”¾ç‰¹å®šçš„èµ„æºã€‚åœ¨å®¹å™¨ç¯å¢ƒçš„æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªå®¹å™¨åœ¨äº‰å¤ºç³»ç»Ÿèµ„æºï¼Œå¦‚CPUã€‚æ¶æ„å®¹å™¨è¯•å›¾æé«˜å…¶å·¥ä½œè´Ÿè½½çš„æ€§èƒ½ï¼ˆè¢«ç§°ä¸ºbeneficiaryï¼‰ï¼Œä»¥è·å¾—æ›´å¤šçš„ç³»ç»Ÿèµ„æºã€‚å› æ­¤ï¼Œæ¶æ„å®¹å™¨è¿è¡Œå¦ä¸€ä¸ªè½»é‡çº§ç¨‹åºï¼ˆè¢«ç§°ä¸ºhelperï¼‰æ¥é‡Šæ”¾å—å®³è€…å®¹å™¨ä½¿ç”¨çš„èµ„æºï¼Œä»¥ä¾¿å—ç›Šè€…èƒ½å¤Ÿè·å¾—æ›´å¤šçš„èµ„æºã€‚å¸®åŠ©è€…åªæ¶ˆè€—å¾ˆå°‘çš„ç³»ç»Ÿèµ„æºï¼ˆå› æ­¤å®ƒå¯¹beneficiaryå‡ ä¹æ²¡æœ‰å½±å“ï¼‰ï¼Œä½†å¯ä»¥æ˜¾è‘—å½±å“åœ¨å—å®³è€…å®¹å™¨å†…è¿è¡Œçš„å·¥ä½œè´Ÿè½½ã€‚ä¾‹å¦‚ï¼Œåœ¨æ¶æ„å®¹å™¨ä¸­ï¼Œå—ç›Šè€…ç¨‹åºå¯ä»¥è¿è¡ŒCPUå¯†é›†å‹çš„å·¥ä½œè´Ÿè½½ï¼Œå¹¶ä¸å—å®³è€…å®¹å™¨åœ¨åŒä¸€CPUæ ¸å¿ƒä¸Šç«äº‰CPUèµ„æºã€‚å—å®³è€…å®¹å™¨è¿è¡ŒI&#x2F;Oå¯†é›†å‹çš„å·¥ä½œè´Ÿè½½ï¼Œå› æ­¤CPUæ´»åŠ¨ä¸I&#x2F;Oæ“ä½œçš„é¢‘ç‡ç›¸è”ç³»ï¼šæ›´å¤šçš„I&#x2F;Oæ“ä½œä½¿å—å®³è€…å®¹å™¨æ¶ˆè€—æ›´å¤šçš„CPUå‘¨æœŸæ¥å¤„ç†è¿™äº›è¯·æ±‚ã€‚ç„¶åï¼Œæ¶æ„è€…è¿è¡Œä¸€ä¸ªè¾…åŠ©ç¨‹åºï¼Œå®šæœŸè°ƒç”¨syncï¼Œè§¦å‘å›å†™ï¼Œå¹¶å‡å°‘å—å®³è€…çš„I&#x2F;Oæ´»åŠ¨ã€‚è¿™æ ·å¯ä»¥é™ä½å—å®³è€…å®¹å™¨çš„CPUä½¿ç”¨ç‡ï¼Œæ¶æ„å®¹å™¨å¯ä»¥è·å¾—æ›´å¤šçš„CPUèµ„æºã€‚æˆ‘ä»¬é€šè¿‡åœ¨åŒä¸€ä¸ªæ ¸ä¸Šè¿è¡Œä¸¤ä¸ªå®¹å™¨æ¥æ¨¡æ‹Ÿå®éªŒã€‚åœ¨å—å®³å®¹å™¨ä¸­ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿäº†ä¸€ä¸ªç½‘ç»œçˆ¬è™«çš„æƒ…å†µï¼Œå…¶ä¸­å®¹å™¨ä¸æ–­åœ°å°†ä¸€ä¸ªç½‘é¡µå†™å…¥ä¸€ä¸ªæ–°æ–‡ä»¶ã€‚ æˆ‘ä»¬ä½¿ç”¨sysbenchæ¥æµ‹é‡æ¶æ„å®¹å™¨çš„CPUå’Œå†…å­˜æ€§èƒ½ï¼Œå…¶ä¸­å€¼è¶Šé«˜è¡¨ç¤ºæ€§èƒ½è¶Šå¥½ã€‚æ¶æ„å®¹å™¨è¿˜ä¼šå®šæœŸè°ƒç”¨syncæ¥è§¦å‘å…¨å±€å›å†™ã€‚å¯¹äºåŸºçº¿æƒ…å†µï¼Œåªæœ‰æ”»å‡»è€…çš„å®¹å™¨æ˜¯æ´»åŠ¨çš„ï¼Œå› æ­¤ä¸å­˜åœ¨å¯¹æ‰€æœ‰ç³»ç»Ÿèµ„æºçš„ç«äº‰ã€‚ç„¶åï¼Œæˆ‘ä»¬è¿è¡Œè¿™ä¸¤ä¸ªå®¹å™¨ï¼Œå¹¶å°†æ”»å‡»è€…å®¹å™¨çš„æ€§èƒ½ä¸åŸºçº¿æƒ…å†µè¿›è¡Œæ¯”è¾ƒã€‚å¦‚å›¾ï¼Œåœ¨æ²¡æœ‰RFAæ”»å‡»çš„æƒ…å†µä¸‹ï¼Œç”±äºä¸¤ä¸ªå®¹å™¨äº‰å¤ºåŒä¸€æ ¸ä¸Šçš„CPUèµ„æºï¼ŒCPUæ€§èƒ½(å³ç™½æ¡)çº¦ä¸ºæ— ç«äº‰æƒ…å†µ(å³é»‘æ¡)çš„ä¸€åŠï¼Œå†…å­˜æ€§èƒ½çº¦ä¸ºæ— ç«äº‰æƒ…å†µçš„1&#x2F;3ã€‚ç„¶è€Œï¼Œé€šè¿‡å‘èµ·RFAæ”»å‡»(å³ç°è‰²æ¡)ï¼Œæ¶æ„å®¹å™¨å†…çš„å—ç›Šäººå¯ä»¥åœ¨ä¸¤ä¸ªæµ‹è¯•å¹³å°ä¸Šè·å¾—æ›´å¥½çš„æ€§èƒ½ã€‚ç‰¹åˆ«æ˜¯ï¼Œåœ¨æˆ‘ä»¬çš„æœ¬åœ°æœåŠ¡å™¨ä¸Šï¼Œæ€§èƒ½å‡ ä¹ä¸æ²¡æœ‰ç«äº‰çš„æƒ…å†µç›¸åŒã€‚ Covert Channels æœ€åï¼Œæˆ‘ä»¬è¯æ˜äº†cgroupsä¸­çš„ä¸è¶³ä¹Ÿå¯èƒ½è¢«æ¶æ„æ”»å‡»è€…åˆ©ç”¨ï¼Œåœ¨ä¸åŒçš„æ ¸å¿ƒä¹‹é—´æ„å»ºåŸºäºæ—¶é—´çš„éšè”½é€šé“ã€‚å…¶æ€æƒ³æ˜¯åˆ©ç”¨ç”±ç£ç›˜æ•°æ®åŒæ­¥å¼•èµ·çš„æ€§èƒ½å·®å¼‚ã€‚æˆ‘ä»¬æµ‹é‡åœ¨ä¸€ä¸ªå®¹å™¨ä¸­å†™å…¥10ä¸ªæ–‡ä»¶çš„æ—¶é—´ï¼ŒåŒæ—¶åœ¨å¦ä¸€ä¸ªå†…æ ¸çš„å¦ä¸€ä¸ªå®¹å™¨ä¸­è¿è¡Œsyncã€‚ æˆ‘ä»¬é‡å¤å®éªŒ100æ¬¡ï¼Œæ‰€éœ€è¦çš„æ—¶é—´åˆ†å¸ƒå¦‚å›¾æ‰€ç¤ºã€‚æˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°è¿è¡ŒåŒæ­¥å’Œä¸è¿è¡ŒåŒæ­¥ä¹‹é—´æ‰“å¼€æ–‡ä»¶çš„æ˜æ˜¾æ—¶é—´å·®å¼‚ã€‚æˆ‘ä»¬é€šè¿‡åˆ©ç”¨æ€§èƒ½å·®å¼‚æ„å»ºäº†ä¸€ä¸ªæ¦‚å¿µéªŒè¯é€šé“ï¼Œèƒ½å¤Ÿä»¥2bits&#x2F;sçš„é€Ÿç‡ä¼ è¾“æ•°æ®ï¼Œé”™è¯¯ç‡ä¸º2%ã€‚ Case 3:System Process - Journaldæˆ‘ä»¬çš„ç¬¬ä¸‰ä¸ªæ¡ˆä¾‹æ˜¯åˆ©ç”¨system - JournalæœåŠ¡ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªç³»ç»ŸæœåŠ¡æ¥æ”¶é›†ç³»ç»Ÿæ—¥å¿—æ•°æ®ï¼ŒåŒ…æ‹¬å†…æ ¸æ—¥å¿—æ¶ˆæ¯ã€ç³»ç»Ÿæ—¥å¿—æ¶ˆæ¯(ä¾‹å¦‚ï¼Œsyslogè°ƒç”¨æˆ–Journal API)ï¼Œä»¥åŠé€šè¿‡å®¡è®¡å­ç³»ç»Ÿçš„å®¡è®¡è®°å½•ã€‚æ‰€æœ‰ç›¸å…³çš„æ´»åŠ¨éƒ½ç”±ç³»ç»Ÿè¿›ç¨‹æ—¥å¿—è®°å½•ã€‚åœ¨æˆ‘ä»¬çš„æ¡ˆä¾‹ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬å‘ç°å®¹å™¨ä¸­çš„ä¸‰ç±»æ“ä½œå¯ä»¥è¿«ä½¿æ—¥å¿—è¿›ç¨‹è®°å½•æ—¥å¿—ï¼Œå¯¼è‡´5%åˆ°20%çš„é¢å¤–CPUåˆ©ç”¨ç‡å’Œå¹³å‡2MB&#x2F;sçš„I&#x2F;Oååé‡ï¼Œç„¶åå¯ä»¥åˆ©ç”¨è¿™äº›å½±å“å…¶ä»–å®¹å™¨çš„æ€§èƒ½ã€‚ Detailed analysis ä¸»æœºçš„ç³»ç»Ÿè¿›ç¨‹è¢«é™„åŠ åˆ°ä¸åŒäºå®¹å™¨ä¸­çš„è¿›ç¨‹çš„cgroupä¸­ï¼Œå› ä¸ºå®ƒä»¬æ˜¯ç”±æ“ä½œç³»ç»Ÿç»´æŠ¤çš„ï¼Œä»¥æä¾›å…¨ç³»ç»Ÿçš„åŠŸèƒ½ã€‚å› æ­¤ï¼Œå¦‚æœå®¹å™¨å†…çš„å·¥ä½œè´Ÿè½½å¯ä»¥è§¦å‘è¿™äº›ç³»ç»Ÿè¿›ç¨‹çš„æ´»åŠ¨ï¼Œé‚£ä¹ˆè¿™äº›æ´»åŠ¨æ‰€æ¶ˆè€—çš„èµ„æºå°†ä¸ä¼šè¢«è®¡å…¥å®¹å™¨çš„cgroupï¼Œä»è€Œé€ƒé¿èµ„æºæ§åˆ¶æœºåˆ¶ã€‚ä½†æ˜¯ï¼Œè¿è¡Œåœ¨ä¸»æœºä¸Šçš„ç³»ç»Ÿè¿›ç¨‹ä¼šå¿½ç•¥å®¹å™¨å†…çš„å¤§éƒ¨åˆ†æ“ä½œã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸»æœºä¸Šè¿è¡Œçš„ç”¨æˆ·ç©ºé—´è¿›ç¨‹çš„è®¸å¤šæ´»åŠ¨å°†ç”±æ—¥å¿—è®°å½•ã€‚ä½†æ˜¯å¦‚æœæµç¨‹åœ¨å®¹å™¨å†…è¿è¡Œï¼Œé‚£ä¹ˆè¿™äº›æ´»åŠ¨å°†è¢«å¿½ç•¥ã€‚ä¸ºäº†è®°å½•å®¹å™¨å†…çš„äº‹ä»¶ï¼Œä¸»æœºä¸Šçš„ç³»ç»Ÿç®¡ç†å‘˜éœ€è¦æ›´æ”¹system -journalæœåŠ¡çš„é…ç½®ã€‚ ç‰¹åˆ«æ˜¯ï¼ŒDockeræä¾›äº†ä¸€ä¸ªé€‰é¡¹æ¥å¯ç”¨æ—¥å¿—è®°å½•ã€‚ ç„¶è€Œï¼Œæˆ‘ä»¬å‘ç°ï¼Œå³ä½¿æ²¡æœ‰å¯ç”¨æ—¥å¿—è®°å½•é€‰é¡¹ï¼Œåœ¨æŸäº›ç‰¹å®šçš„æƒ…å†µä¸‹ï¼Œå®¹å™¨ä»ç„¶èƒ½å¤Ÿåœ¨æ—¥å¿—ç³»ç»Ÿè¿›ç¨‹ä¸Šç”Ÿæˆä¸å¯å¿½ç•¥çš„å·¥ä½œè´Ÿè½½ã€‚ ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬ä»‹ç»äº†å¯¼è‡´ç³»ç»Ÿè¿›ç¨‹è´Ÿè½½çš„ä¸‰ç§ç±»å‹çš„æ“ä½œï¼Œä»è€Œé€ƒè„±äº†cgroupçš„æ§åˆ¶ã€‚ Switch user (su) command suå‘½ä»¤æä¾›äº†ä¸€ç§å°†ç™»å½•ä¼šè¯çš„æ‰€æœ‰æƒåˆ‡æ¢åˆ°rootç”¨æˆ·çš„æ–¹æ³•ã€‚ åˆ‡æ¢åˆ°rootç”¨æˆ·çš„æ“ä½œå°†è¢«è®°å½•åœ¨æ—¥å¿—ç³»ç»Ÿè¿›ç¨‹ä¸­ã€‚æ—¥å¿—åŒ…å«è¿›ç¨‹ã€ç”¨æˆ·å¸æˆ·å’Œç¯å¢ƒåˆ‡æ¢çš„ä¿¡æ¯ã€‚æ—¥å¿—æœåŠ¡ä¹Ÿä¼šè®°å½•ç”¨æˆ·çš„é€€å‡ºã€‚ä½¿ç”¨USER namespaceï¼Œå®¹å™¨å†…çš„æ ¹ç”¨æˆ·æ˜ å°„åˆ°ä¸»æœºä¸Šçš„æ— ç‰¹æƒç”¨æˆ·ã€‚å› æ­¤ï¼Œå®¹å™¨ä¸­çš„è¿›ç¨‹å¯èƒ½åœ¨USERåç§°ç©ºé—´ä¸­æ‹¥æœ‰å®Œå…¨çš„ç‰¹æƒï¼Œä½†å®é™…ä¸Šåœ¨ä¸»æœºä¸Šè¢«å‰¥å¤ºäº†ç‰¹æƒã€‚ä½œä¸ºå®¹å™¨ä¸­çš„æ ¹ç”¨æˆ·ï¼Œsuå‘½ä»¤å¯ä»¥è¿›å…¥å¦ä¸€ä¸ªç”¨æˆ·ã€‚ä¸å¹¸çš„æ˜¯ï¼Œåœ¨å®¹å™¨å†…åˆ‡æ¢å¸æˆ·æ‰€å¼•èµ·çš„æ´»åŠ¨å°†è§¦å‘system -journalæœåŠ¡æ¥è®°å½•ç›¸å…³ä¿¡æ¯ã€‚ Add user&#x2F;group åœ¨USER namespaceä¸­ï¼Œå®¹å™¨ç”¨æˆ·å¯ä»¥æ·»åŠ æ–°ç»„æˆ–åœ¨ç°æœ‰ç»„ä¸­æ·»åŠ æ–°å¸æˆ·ã€‚è¿™äº›æ´»åŠ¨ä¹Ÿå°†ç”±ä¸»æœºä¸Šçš„æ—¥å¿—ç³»ç»Ÿè¿›ç¨‹è®°å½•ã€‚ Exception æœ€åï¼Œå¦‚å‰æ‰€è¿°ï¼Œå†…æ ¸æ— æ³•åŒºåˆ†æ‰€å¼•å‘å¼‚å¸¸çš„ä¸Šä¸‹æ–‡(åœ¨å®¹å™¨å†…éƒ¨æˆ–å¤–éƒ¨)ã€‚å› æ­¤ï¼Œå®¹å™¨å†…å¼‚å¸¸å¼•èµ·çš„å´©æºƒä¿¡æ¯ä¹Ÿä¼šè§¦å‘ä¸»æœºä¸Šç³»ç»Ÿè¿›ç¨‹çš„æ—¥å¿—è®°å½•æ´»åŠ¨ã€‚ æ‰€æœ‰ä¸Šè¿°å·¥ä½œè´Ÿè½½éƒ½å°†åœ¨æ—¥å¿—ä¸­è§¦å‘å¤§é‡äº‹ä»¶æ—¥å¿—è®°å½•ã€‚åŒæ ·ï¼Œæˆ‘ä»¬å°†ä¸€ä¸ªå®¹å™¨è®¾ç½®ä¸ºå…·æœ‰ä¸€ä¸ªCPUæ ¸å¿ƒè®¡ç®—èƒ½åŠ›ï¼Œä»¥ç»§ç»­è°ƒç”¨ä¸Šè¿°å‘½ä»¤ã€‚åœ¨æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•åºŠä¸Šï¼Œæˆ‘ä»¬è§‚å¯Ÿåˆ°journaldä¸Šçš„CPUä½¿ç”¨ç‡æ’å®šä¸º3.5%ï¼Œauditdä¸Šçš„CPUä½¿ç”¨ç‡æ’å®šä¸º2.5%ï¼Œkauditdä¸Šçš„CPUä½¿ç”¨ç‡æ’å®šä¸º1%ã€‚åœ¨EC2æœåŠ¡å™¨ä¸­ï¼Œç”±äºå…¶æ›´å¥½çš„I&#x2F;Oæ€§èƒ½ï¼Œè¿™ä¸ªæ•°å­—è¦å¤§å¾—å¤š:æˆ‘ä»¬è§‚å¯Ÿåˆ°å¹³å‡CPUåˆ©ç”¨ç‡çº¦ä¸º20%ã€‚æˆ‘ä»¬è¿˜å‘ç°ï¼Œjournaldè¿›ç¨‹çš„å¹³å‡I&#x2F;Oååé‡çº¦ä¸º2MB&#x2F;sï¼Œè€Œå®¹å™¨çš„I&#x2F;Oååé‡ä¸ºé›¶ã€‚å¦‚æœæˆ‘ä»¬ä¸ºå®¹å™¨åˆ†é…æ›´å¤šçš„è®¡ç®—èµ„æºï¼Œè¿™ä¸ªæ•°å­—å°†ä¼šå¢åŠ ã€‚ DoS attacks æ—¥å¿—journaldæ´»åŠ¨å°†äº§ç”Ÿä¸å¯å¿½ç•¥çš„I&#x2F;Oæ“ä½œï¼Œè¿™å°†å¯¼è‡´ä¸å…¶ä»–å®¹å™¨çš„èµ„æºç«äº‰ã€‚ä¸ºäº†è¡¡é‡ç»“æœï¼Œæˆ‘ä»¬åœ¨ä¸»æœºçš„ä¸åŒå†…æ ¸ä¸Šè¿è¡Œä¸¤ä¸ªå®¹å™¨ã€‚åœ¨æ¶æ„å®¹å™¨ä¸­ï¼Œæˆ‘ä»¬ä¸æ–­åˆ‡æ¢ç”¨æˆ·(å³su)å¹¶é€€å‡ºå½“å‰ç”¨æˆ·(å³exit)ã€‚åœ¨å—å®³å®¹å™¨ä¸­ï¼Œè¿è¡Œä¸case 2ä¸­æè¿°çš„ç›¸åŒçš„åŸºå‡†æµ‹è¯•ã€‚ å›¾æ˜¾ç¤ºäº†ç»“æœã€‚æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬çœ‹åˆ°æ•´ä¸ªç³»ç»Ÿçš„æ€§èƒ½ä¸‹é™ã€‚åœ¨I&#x2F;Oæ€§èƒ½è¾ƒå·®çš„æœåŠ¡å™¨(ä¾‹å¦‚ï¼Œæˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°)ä¸­ï¼Œæ»¥ç”¨journaldçš„æ”»å‡»å°†æ›´åŠ æœ‰æ•ˆã€‚å¦‚å‰æ‰€è¿°ï¼Œå®ƒåœ¨æ—¥å¿—è¿›ç¨‹ä¸­å¯èƒ½å¯¼è‡´è¶…è¿‡2MB&#x2F;sçš„I&#x2F;Oååé‡ã€‚æˆ‘ä»¬è§‚å¯Ÿåˆ°å®ƒä»ç„¶å¯ä»¥ä½¿EC2ä¸“ç”¨æœåŠ¡å™¨ä¸Šçš„å…¶ä»–å®¹å™¨åœ¨1000iops(ååé‡çº¦ä¸º15MB&#x2F;s)æ—¶å˜æ…¢ã€‚åœ¨ä¸€ä¸ªå…·æœ‰é»˜è®¤é…ç½®çš„ä¸“ç”¨æœåŠ¡å™¨ä¸­(ä¾‹å¦‚ï¼Œ400 IOPSï¼Œååé‡çº¦ä¸º6MB&#x2F;s)ï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°æ›´æ˜æ˜¾çš„ç»“æœã€‚ Residual effect åœ¨I&#x2F;Oæ€§èƒ½è¾ƒå·®çš„æœåŠ¡å™¨ä¸Šï¼Œç³»ç»Ÿè¿›ç¨‹çš„å†™å·¥ä½œè´Ÿè½½å¯èƒ½è¶…è¿‡æœåŠ¡å™¨çš„I&#x2F;Oèƒ½åŠ›ã€‚ç»“æœï¼Œå¤§é‡çš„æ—¥å¿—äº‹ä»¶è¢«æ’é˜Ÿï¼Œç­‰å¾…ç¨åè¢«è®°å½•ã€‚è¿™å°†å¯¼è‡´ä¸€ä¸ªæ®‹ç•™æ•ˆåº”:å³ä½¿å®¹å™¨åœæ­¢äº†å®ƒçš„å·¥ä½œè´Ÿè½½(ä¾‹å¦‚su)ï¼Œç³»ç»Ÿä»å°†ç»§ç»­åœ¨journaldä¸­å†™å…¥ï¼Œç›´åˆ°é˜Ÿåˆ—ä¸­çš„å·¥ä½œè´Ÿè½½å®Œæˆã€‚æ®‹ç•™æ•ˆåº”åœ¨æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°ä¸Šå¾ˆæ˜æ˜¾ï¼Œå¹¶ä¸”æŒç»­çš„æ—¶é—´æ¯”å·¥ä½œè´Ÿè½½çš„è¿è¡Œæ—¶é—´é•¿å¾—å¤šã€‚å³ä½¿å®¹å™¨å®Œå…¨ç©ºé—²ï¼ŒCPUå’ŒI&#x2F;Oèµ„æºä¹Ÿä¼šè¢«æ¶ˆè€—ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œè¿™äº›å†™å…¥æ“ä½œå°†æ˜¾è‘—å½±å“å…¶ä»–å®¹å™¨å’Œä¸»æœºçš„I&#x2F;Oæ€§èƒ½ã€‚ Case 4:Container Engineå®¹å™¨çš„ç¬¬å››ç§æƒ…å†µæ˜¯é€šè¿‡åœ¨å†…æ ¸çº¿ç¨‹(ä¾‹å¦‚kworker)å’Œå®¹å™¨å¼•æ“ä¸Šè§¦å‘é¢å¤–çš„å·¥ä½œè´Ÿè½½æ¥åˆ©ç”¨å®¹å™¨å¼•æ“ï¼Œå®¹å™¨å¼•æ“éœ€è¦åœ¨ä¸»æœºä¸Šè¿è¡Œä»¥æ”¯æŒå’Œç®¡ç†å®¹å™¨å®ä¾‹ã€‚ç‰¹åˆ«æ˜¯ï¼Œå®¹å™¨å¼•æ“ä½œä¸ºç³»ç»Ÿä¸Šçš„ç‰¹æƒå®ˆæŠ¤è¿›ç¨‹è¿è¡Œï¼Œå› æ­¤å®ƒä½œä¸ºå®¹å™¨å®ä¾‹é™„åŠ åˆ°ä¸åŒçš„cgroupä¸Šã€‚å®¹å™¨å®ä¾‹ä¸Šçš„cgroupé™åˆ¶å°†ä¸èƒ½æ§åˆ¶å¼•æ“ä¸Šæ¶ˆè€—çš„èµ„æºã€‚æ€»çš„æ¥è¯´ï¼Œé€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å‘ç°ä¸€ä¸ªå®¹å™¨å¯ä»¥å°†èµ„æºæ¶ˆè€—å¢åŠ åˆ°å¤§çº¦3å€ã€‚ Detailed analysis æˆ‘ä»¬é¦–å…ˆç®€è¦ä»‹ç»Dockerå®¹å™¨å¼•æ“åŠå…¶cgroupå±‚æ¬¡ç»“æ„ã€‚Dockeråˆ›å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰å®¹å™¨å®ä¾‹çš„Docker cgroupã€‚æ¯ä¸ªå®¹å™¨ç”±å…¶IDæ ‡è¯†ï¼Œå¹¶ä¿å­˜ç”±forkåˆ›å»ºçš„æ‰€æœ‰è¿›ç¨‹ã€‚ä»ç†è®ºä¸Šè®²ï¼Œå®¹å™¨å†…è¿è¡Œçš„æ‰€æœ‰å·¥ä½œè´Ÿè½½éƒ½å°†è¢«è®¡å…¥å®¹å™¨cgroupã€‚ æ­¤å¤–ï¼ŒDockeræ„å»ºåœ¨Dockerå¼•æ“ä¹‹ä¸Šï¼Œå…¶ä¸­ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹(å³dockerd)åœ¨åå°è¿è¡Œï¼Œå¤„ç†Dockeræ˜ åƒçš„ç®¡ç†ã€‚Dockerå¼•æ“ç„¶åä¸containd(ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹)é€šä¿¡ï¼Œä»¥è¿›ä¸€æ­¥ä½¿ç”¨runCæ¥è¿è¡Œå®¹å™¨ã€‚dockerdè¿›ç¨‹å¯¹äºæ¯ä¸ªå®¹å™¨å®ä¾‹éƒ½æœ‰å¤šä¸ªå­è¿›ç¨‹ã€‚è¿™äº›è¿›ç¨‹è¢«é™„åŠ åˆ°æ‰€æœ‰ç³»ç»ŸæœåŠ¡çš„é»˜è®¤cgroupä¸­ã€‚ æ­¤å¤–ï¼Œç”¨æˆ·ä¸»è¦é€šè¿‡å‘½ä»¤è¡Œæ¥å£(CLI)å®¢æˆ·ç«¯(å³Dockerè¿›ç¨‹)æ§åˆ¶å’Œç®¡ç†Docker, Dockerè¿›ç¨‹é€šè¿‡Docker REST APIä¸Dockerå®ˆæŠ¤è¿›ç¨‹äº¤äº’ã€‚Docker CLIä¸ºç”¨æˆ·æä¾›äº†åˆ›å»ºæˆ–æ‰§è¡Œå®¹å™¨çš„æ¥å£ã€‚å®ƒè¿˜æä¾›äº†å¤šä¸ªå‘½ä»¤æ¥è®¾ç½®ä¸åº•å±‚æ§åˆ¶ç»„ç›¸å…³çš„èµ„æºé™åˆ¶çš„é…ç½®ã€‚ä¸Dockerå¼•æ“è¿›ç¨‹ç±»ä¼¼ï¼ŒDocker CLIä¹Ÿä¸å±äºå®¹å™¨çš„cgroupã€‚ åˆ©ç”¨å®¹å™¨å¼•æ“æ¥æ‰“ç ´cgroupsçš„æ§åˆ¶æ˜¯ç›¸å½“å®¹æ˜“çš„ã€‚ä¸€ç§ç®€å•çš„æ–¹æ³•æ˜¯åˆ©ç”¨ç»ˆç«¯å­ç³»ç»Ÿã€‚å½“å®¹å™¨ç”¨æˆ·ä¸ttyè®¾å¤‡äº¤äº’æ—¶ï¼Œæ•°æ®é¦–å…ˆç»è¿‡CLIè¿›ç¨‹å’Œå®¹å™¨å®ˆæŠ¤è¿›ç¨‹ï¼Œç„¶ååˆ°è¾¾ttyé©±åŠ¨ç¨‹åºè¿›è¡Œè¿›ä¸€æ­¥å¤„ç†ã€‚å…·ä½“æ¥è¯´ï¼Œæ•°æ®è¢«å‘é€åˆ°LDISC, LDISCè¿æ¥é«˜çº§é€šç”¨æ¥å£(ä¾‹å¦‚ï¼Œè¯»ã€å†™ã€ioctl)å’Œç»ˆç«¯ç³»ç»Ÿä¸­çš„ä½çº§è®¾å¤‡é©±åŠ¨ç¨‹åºã€‚é€šè¿‡åœ¨kworkerå†…æ ¸çº¿ç¨‹ä¸­æ‰§è¡Œå·¥ä½œé˜Ÿåˆ—å°†æ•°æ®åˆ·æ–°åˆ°LDISCã€‚å› æ­¤ï¼Œå†…æ ¸çº¿ç¨‹ä¸Šçš„æ‰€æœ‰å·¥ä½œè´Ÿè½½å’Œæ‰€æœ‰å®¹å™¨å¼•æ“è¿›ç¨‹éƒ½ä¸ä¼šè¢«è®¡ç®—åˆ°å®¹å™¨å®ä¾‹ä¸­ã€‚ æˆ‘ä»¬é€šè¿‡åœ¨ç»ˆç«¯ä¸­åå¤æ˜¾ç¤ºä¸»æœºä¸­æ‰€æœ‰åŠ è½½çš„æ¨¡å—æ¥æµ‹é‡å®¹å™¨å¼•æ“ä¸­ç”Ÿæˆçš„å·¥ä½œè´Ÿè½½ï¼Œå¹¶å°†ç»“æœè¯´æ˜åœ¨å›¾ä¸­ã€‚åŒæ ·ï¼Œå®¹å™¨çš„ä½¿ç”¨ä»…é™äºä¸€ä¸ªæ ¸å¿ƒ(å¦‚å›¾ä¸­çš„container)ã€‚ æ€»çš„æ¥è¯´ï¼Œä½¿ç”¨ä¸€ä¸ªæ ¸å¿ƒçš„è®¡ç®—èƒ½åŠ›(100%çš„åˆ©ç”¨ç‡)ï¼Œå®¹å™¨å¯ä»¥é€šè¿‡æ»¥ç”¨dockerå¼•æ“è¿›ç¨‹åœ¨ä¸»æœºä¸Šé€ æˆå¤§çº¦300%çš„å·¥ä½œè´Ÿè½½ã€‚ ä¸ºäº†ç»†åˆ†ä½¿ç”¨æƒ…å†µï¼Œdockerè¿›ç¨‹å±äºä¸»æœºçš„ç”¨æˆ·cgroupï¼›å…¶ä»–dockerè¿›ç¨‹å±äºä¸€ä¸ªç³»ç»Ÿcgroupï¼šdocker.serviceã€‚å…¶ä½™çš„ï¼ˆå¤§éƒ¨åˆ†æ˜¯å†…æ ¸çº¿ç¨‹kworkerï¼Œç”±äºæµåª’ä½“å·¥ä½œè´Ÿè½½ï¼Œå¦‚ç¬¬3.2èŠ‚æ‰€è§£é‡Šï¼‰å±äºæ ¹cgroupã€‚æˆ‘ä»¬è¿˜åœ¨case 1ä¸­è¿›è¡Œäº†ä¸è¡¨ç±»ä¼¼çš„å®éªŒã€‚é€šè¿‡åˆ©ç”¨Dockerå®¹å™¨å¼•æ“ï¼Œæ”»å‡»è€…èƒ½å¤Ÿé™ä½CPUå’Œå†…å­˜çš„æ€§èƒ½å¤§çº¦15%ã€‚ Case 5:Softirq Handlingæœ€åä¸€ç§æƒ…å†µæ˜¯åˆ©ç”¨Linuxå†…æ ¸ä¸­çš„softirqå¤„ç†æœºåˆ¶ã€‚å½“å‰å†…æ ¸å®šä¹‰äº†11ç§ç±»å‹çš„softirqã€‚ç‰¹åˆ«æ˜¯ï¼Œç¡¬ä»¶ä¸­æ–­å¤„ç†ç¨‹åºé€šå¸¸ä¼šå¼•å‘è½¯ä¸­æ–­ã€‚ è™½ç„¶å¤§å¤šæ•°ç¡¬ä»¶ä¸­æ–­å¯èƒ½ä¸æ˜¯ç”±å®¹å™¨ç›´æ¥å¼•å‘çš„ï¼Œä½†å®¹å™¨ç”¨æˆ·èƒ½å¤Ÿæ“ä½œç½‘ç»œæ¥å£ä¸Šçš„å·¥ä½œè´Ÿè½½ç”ŸæˆNET softirqï¼Œæˆ–å—è®¾å¤‡ç”Ÿæˆblock softirqã€‚å¤„ç†è¿™äº›softirqä¼šæ¶ˆè€—å†…æ ¸çº¿ç¨‹è¿›ç¨‹ä¸Šä¸‹æ–‡(ä¾‹å¦‚ksoftirqd)æˆ–ä¸­æ–­ä¸Šä¸‹æ–‡ä¸Šçš„CPUèµ„æºã€‚ NET softtirq ä¸€æ—¦NICå®Œæˆæ•°æ®åŒ…ä¼ è¾“ï¼Œå°±ä¼šå¼•å‘ä¸­æ–­ï¼Œè€Œsoftirqè´Ÿè´£åœ¨é©±åŠ¨ç¨‹åºç¼“å†²åŒºå’Œç½‘ç»œå †æ ˆä¹‹é—´ç§»åŠ¨æ•°æ®åŒ…ã€‚ä½†æ˜¯ï¼Œåœ¨æµé‡å¸¦å®½æœ‰é™çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨softirqså¸¦æ¥çš„å¼€é”€å¯ä»¥å¿½ç•¥ä¸è®¡:åœ¨ä¹‹å‰çš„å·¥ä½œä¸­ï¼Œå½“ç½‘ç»œæµé‡è¶…è¿‡1gbpsæ—¶ï¼Œå¼€é”€ä¸º1%ã€‚ æˆ‘ä»¬å‘ç°ï¼Œç”±äºç½‘ç»œæµé‡å¼•èµ·çš„å¼€é”€ä¼šè¢«æœåŠ¡å™¨ä¸Šçš„é˜²ç«å¢™ç³»ç»Ÿ(å¦‚iptables)å¤§å¤§æ”¾å¤§ã€‚iptableså»ºç«‹åœ¨netfilterçš„åŸºç¡€ä¸Šï¼Œæä¾›äº†ä¸€ä¸ªç®¡ç†å±‚ï¼Œç”¨äºåŒ…è¿‡æ»¤è§„åˆ™çš„æ·»åŠ å’Œåˆ é™¤ã€‚netfilterå°†æ•°æ®åŒ…æŒ‚åœ¨ç½‘ç»œé©±åŠ¨ç¨‹åºå’Œç½‘ç»œå †æ ˆä¹‹é—´ã€‚æ‰€æœ‰çš„ç½‘ç»œæ•°æ®åŒ…é¦–å…ˆé€šè¿‡è¿‡æ»¤è§„åˆ™è¿›è¡Œæ£€æŸ¥ï¼Œç„¶åè¿›è¡Œè¿›ä¸€æ­¥çš„æ“ä½œ(ä¾‹å¦‚ï¼Œè½¬å‘ã€ä¸¢å¼ƒã€ç”±ç½‘ç»œå †æ ˆå¤„ç†)ã€‚å› æ­¤ï¼Œiptablesä¸‹çš„ç½‘ç»œæµé‡å¤„ç†æ˜¯åœ¨softirqä¸Šä¸‹æ–‡ä¸­å¤„ç†çš„ï¼Œå› æ­¤ä¸ä¼šå‘ç”Ÿæˆæˆ–æ¥æ”¶æµé‡çš„å®¹å™¨æ”¶è´¹ã€‚ åœ¨Linuxä¸Šï¼ŒDockerä¾èµ–äºé…ç½®iptablesè§„åˆ™æ¥ä¸ºå®¹å™¨æä¾›ç½‘ç»œéš”ç¦»ã€‚ç‰¹åˆ«æ˜¯ï¼Œå®ƒå¯èƒ½ä¸ºæä¾›webæˆ–ç½‘ç»œæœåŠ¡çš„å®¹å™¨è®¾ç½®å¤šä¸ªè§„åˆ™ã€‚å³ä½¿å®¹å™¨åœæ­¢ï¼Œè§„åˆ™ä¹Ÿå­˜åœ¨ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¦‚æœç›¸å…³æ ‡å¿—è®¾ç½®ä¸ºtrueï¼Œå®¹å™¨å¯ä»¥å¯¹ç³»ç»Ÿiptablesè§„åˆ™è¿›è¡Œæ›´æ”¹ã€‚ä¸€æ—¦æœ‰ç›¸å½“æ•°é‡çš„è§„åˆ™ï¼Œå¼€é”€å°†æ˜¯ä¸å¯å¿½ç•¥çš„ã€‚ æˆ‘ä»¬æµ‹é‡äº†softirqåœ¨ä¸åŒæ•°é‡çš„iptablesè§„åˆ™ä¸‹å¤„ç†ç½‘ç»œæµé‡æ‰€å¸¦æ¥çš„å¼€é”€ï¼Œå¦‚å›¾æ‰€ç¤ºã€‚ç‰¹åˆ«æ˜¯ï¼Œæˆ‘ä»¬æµ‹é‡äº†æ‰€æœ‰ksoftirqdå†…æ ¸çº¿ç¨‹çš„CPUä½¿ç”¨æƒ…å†µï¼Œä»¥åŠèŠ±åœ¨ä¸­æ–­ä¸Šä¸‹æ–‡ä¸Šçš„æ—¶é—´(æ¥è‡ªtopå‘½ä»¤çš„hiå’Œsi)ã€‚åœ¨æˆ‘ä»¬æœ¬åœ°çš„æµ‹è¯•å°ä¸Šï¼Œç½‘å¡çš„å®¹é‡ä¸º100mbit &#x2F;sï¼Œç½‘ç»œæµé‡çº¦ä¸º20 ~ 30mbit &#x2F;sï¼Œæ˜æ˜¾å°äºä¸­çš„Gbpsçº§åˆ«ã€‚æˆ‘ä»¬å¯ä»¥æ¸…æ¥šåœ°çœ‹åˆ°ï¼Œå¤„ç†ç½‘ç»œæµé‡ä¼šäº§ç”Ÿå·¨å¤§çš„å¼€é”€ï¼Œå¹¶ä¸”ä¸è§„åˆ™æ•°é‡å¯†åˆ‡ç›¸å…³ã€‚å½“è§„åˆ™æ•°é‡è¾¾åˆ°5000æ¡æ—¶ï¼ŒCPUå°†æµªè´¹å¤§é‡çš„æ—¶é—´(çº¦16%)å¤„ç†è½¯tirqï¼Œå¹¶ä¸”ä¸ä¼šå‘å‘èµ·ç½‘ç»œæµé‡çš„å®¹å™¨æ”¶è´¹ã€‚ä¸€æ—¦æœåŠ¡å™¨ä¸­æœ‰10,000æ¡è§„åˆ™ï¼Œå¼€é”€çº¦ä¸º40%ï¼Œå…¶ä¸­å¤§å¤šæ•°é›†ä¸­åœ¨ä¸€ä¸ªæ ¸å¿ƒä¸Šã€‚ EC2æœåŠ¡å™¨æœ‰ä¸€ä¸ªéå¸¸å¼ºå¤§çš„ç½‘å¡ï¼Œå…·æœ‰10,000 Mbit&#x2F;sçš„å®¹é‡ï¼Œä¸æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°ç›¸æ¯”å¸¦å®½æ›´é«˜ã€‚å› æ­¤ï¼Œä¸æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°ç›¸æ¯”ï¼Œå¼€é”€ç•¥å°ã€‚åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œå½“ç½‘ç»œæµé‡çº¦ä¸º300mbit &#x2F;sæ—¶ï¼Œæµé‡ä»ç„¶ä¼šæµªè´¹ä¸å¯å¿½ç•¥çš„CPUå‘¨æœŸã€‚å¦‚3.4èŠ‚æ‰€è¿°ï¼Œè½¯ä»¶ä¸­æ–­çš„å¤„ç†è¦ä¹ˆæŠ¢å å½“å‰å·¥ä½œï¼Œè¦ä¹ˆåœ¨å†…æ ¸çº¿ç¨‹ä¸­æ¶ˆè€—CPUå‘¨æœŸã€‚å› æ­¤ï¼ŒåŒä¸€æ ¸å¿ƒä¸Šçš„æ‰€æœ‰å…¶ä»–å·¥ä½œè´Ÿè½½å°†è¢«å»¶è¿Ÿã€‚ BLOCK softirq å¤„ç†softirqæ—¶å¢åŠ å·¥ä½œè´Ÿè½½çš„å¦ä¸€ä¸ªä¾‹å­æ˜¯å—è®¾å¤‡ä¸Šçš„I&#x2F;Oæ“ä½œã€‚Linuxå†…æ ¸ä½¿ç”¨é˜Ÿåˆ—å­˜å‚¨å—è¯·æ±‚I&#x2F;Oï¼Œå¹¶å°†æ–°çš„è¯·æ±‚æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ã€‚ä¸€æ—¦è¯·æ±‚å¤„ç†å®Œæˆï¼Œå®ƒå°†å¼•å‘åœ¨softirqä¸Šä¸‹æ–‡ä¸­å¤„ç†çš„softirqï¼Œä»¥è¿›ä¸€æ­¥å¤„ç†é˜Ÿåˆ—ã€‚ç„¶åï¼Œåˆ©ç”¨BLOCK softirqè½¬ä¹‰cgroupsçš„åŸºæœ¬æ€æƒ³ç±»ä¼¼äºåˆ©ç”¨NET softirqã€‚ åœ¨å®¹å™¨ä¸Šä¸‹æ–‡ä¸­ï¼Œå¯ä»¥é€šè¿‡æŒç»­æŸ¥è¯¢å®Œæˆé˜Ÿåˆ—ä¸­çš„äº‹ä»¶å¹¶æäº¤å†™æˆ–è¯»æ“ä½œæ¥ç”Ÿæˆè¿™æ ·çš„å·¥ä½œè´Ÿè½½ã€‚å¯¹äºI&#x2F;Oæ€§èƒ½è¾ƒå·®çš„è®¾å¤‡ï¼Œè¿™ç§å½±å“å°¤å…¶æ˜æ˜¾ã€‚ä¸ºäº†è¿›ä¸€æ­¥å®šé‡åº¦é‡å½±å“ï¼Œæˆ‘ä»¬ä½¿ç”¨å›ºå®šåœ¨ä¸€ä¸ªå†…æ ¸ä¸Šçš„å®¹å™¨ï¼Œè¿è¡Œfioæ¨èæ¥æ‰§è¡Œé¡ºåºè¯»å†™ã€‚æˆ‘ä»¬é€‰æ‹©å°å—ç”¨äºå†™å…¥ï¼Œå¤§å—ç”¨äºè¯»å–ã€‚æˆ‘ä»¬æµ‹é‡å¤šä¸ªå†…æ ¸çº¿ç¨‹(å¦‚kworker)çš„CPUåˆ©ç”¨ç‡ã€‚å®¹å™¨ä¸­çš„å·¥ä½œè´Ÿè½½èƒ½å¤Ÿåœ¨æˆ‘ä»¬çš„æœ¬åœ°æµ‹è¯•å¹³å°ä¸Šçš„å†…æ ¸ä¸Šç”Ÿæˆä¸å¯å¿½ç•¥çš„å·¥ä½œé‡ï¼ŒåŒ…æ‹¬ç›¸åŒå†…æ ¸çš„kworkerä¸Š16.7%çš„å·¥ä½œè´Ÿè½½ã€‚æ­¤å¤–ï¼Œå¯¹äºåºåˆ—I&#x2F;Oè¯»å–ï¼Œæ–‡ä»¶åˆ†é…è¿‡ç¨‹åœ¨jpd2å’Œkswapdä¸Šåˆ†åˆ«äº§ç”Ÿäº†3.9%å’Œ3.8%çš„é¢å¤–åˆ©ç”¨ç‡ã€‚æœ€åï¼Œæˆ‘ä»¬è¿˜åˆ©ç”¨kworkeræ¥æµ‹é‡é€€åŒ–ã€‚æˆ‘ä»¬åœ¨åŒä¸€ä¸ªå†…æ ¸ä¸Šçš„å†…æ ¸çº¿ç¨‹kworkerä¸Šåˆ›å»ºå·¥ä½œè´Ÿè½½ï¼Œæ”»å‡»è€…èƒ½å¤Ÿå¯¹å—å®³è€…é€ æˆå¤§çº¦10%çš„æ€§èƒ½æŸå¤±(æ ¹æ®sysbenchåŸºå‡†æµ‹è¯•æµ‹é‡)ã€‚ MITIGATION DISCUSSIONåœ¨è¿™ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä»‹ç»æˆ‘ä»¬åœ¨ä»¥ä¸‹æ–¹é¢çš„åˆæ­¥åŠªåŠ›åº”å¯¹ç°æœ‰cgroupsæœºåˆ¶çš„ä¸è¶³æ‰€å¸¦æ¥çš„å®‰å…¨é—®é¢˜ã€‚ç”±äºå¤§å¤šæ•°é—®é¢˜æ¶‰åŠå¤šä¸ªå†…æ ¸å­ç³»ç»Ÿï¼Œå› æ­¤å¾ˆéš¾éƒ¨ç½²ä¸€ä¸ªå•ä¸€çš„è§£å†³æ–¹æ¡ˆæ¥å…¨é¢å½»åº•åœ°è§£å†³æ‰€æœ‰é—®é¢˜ã€‚å¦å¤–ï¼Œè§£å†³ä¸€äº›é—®é¢˜å¯èƒ½éœ€è¦é‡æ–°è®¾è®¡å½“å‰çš„èµ„æºæ ¸ç®—ç³»ç»Ÿã€‚åœ¨ä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†ä»ä¸åŒè§’åº¦è®¨è®ºæ½œåœ¨çš„ç¼“è§£æ–¹æ³•ã€‚ ç›´è§‚åœ°è¯´ï¼Œé€šè¿‡è€ƒè™‘ç”±ä¸€ç»„è¿›ç¨‹(æˆ–å®¹å™¨)ç›´æ¥æˆ–é—´æ¥ç”Ÿæˆçš„æ‰€æœ‰å·¥ä½œè´Ÿè½½ï¼Œcgroupsåº”è¯¥å…·æœ‰ç»†ç²’åº¦çš„è®¡ç®—æœºåˆ¶ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªå®¹å™¨é€šè¿‡å†…æ ¸çº¿ç¨‹è°ƒç”¨å¦ä¸€ä¸ªç”¨æˆ·ç©ºé—´è¿›ç¨‹ï¼Œå®¹å™¨çš„cgroupåº”è¯¥ç”±å†…æ ¸çº¿ç¨‹ä¼ é€’ï¼Œè¿™æ ·å®ƒä¹Ÿä¼šè¢«å¤åˆ¶åˆ°æ–°çš„ç”¨æˆ·ç©ºé—´è¿›ç¨‹ã€‚å› æ­¤ï¼Œæ–°è°ƒç”¨çš„è¿›ç¨‹ä¸å®¹å™¨å±äºåŒä¸€ä¸ªcgroupï¼Œè€Œä¸æ˜¯ä¸å†…æ ¸çº¿ç¨‹å±äºæ ¹cgroupã€‚è™½ç„¶è¿™ç§æ–¹æ³•å¯ä»¥åº”ç”¨äºæ–°ç”Ÿæˆçš„è¿›ç¨‹ï¼Œä½†å¾ˆéš¾å¤„ç†ç³»ç»Ÿä¸­å·²ç»å­˜åœ¨çš„è¿›ç¨‹ã€‚å†…æ ¸çº¿ç¨‹(å¦‚kworkerã€ksoftirqd)æ˜¯ç”±å†…æ ¸åˆ›å»ºçš„ï¼Œç”¨äºå¤„ç†ç‰¹å®šçš„å†…æ ¸å·¥ä½œè´Ÿè½½ï¼Œè¿™äº›å·¥ä½œè´Ÿè½½å¯èƒ½ç”±é™„åŠ åˆ°ä¸åŒcgroupçš„ä¸åŒè¿›ç¨‹è§¦å‘ã€‚journaldç³»ç»Ÿè¿›ç¨‹çš„æƒ…å†µä¹Ÿç±»ä¼¼:å®ƒè®°å½•æ‰€æœ‰è¿›ç¨‹å¼•å‘çš„æ‰€æœ‰ç›¸å…³äº‹ä»¶ï¼Œå› æ­¤å°†æ•´ä¸ªæ—¥å¿—è¿›ç¨‹é™„åŠ åˆ°ç‰¹å®šçš„cgroupæ˜¯ä¸åˆç†çš„ã€‚å› æ­¤ï¼Œç»¼åˆæœºåˆ¶ä¸åº”è¯¥æ”¹å˜è¿™äº›çº¿ç¨‹çš„cgroupï¼Œè€Œæ˜¯åº”è¯¥è·Ÿè¸ªç‰¹å®šå·¥ä½œé‡çš„ç³»ç»Ÿèµ„æºï¼Œå¹¶å°†å…¶æ”¶è´¹ç»™åˆå§‹è¿›ç¨‹ã€‚ä¾‹å¦‚ï¼ŒIronè·Ÿè¸ªå¤„ç†æ¯ä¸ªç½‘ç»œæ•°æ®åŒ…çš„CPUå‘¨æœŸï¼Œå¹¶å‘ç›¸å…³è¿›ç¨‹æ”¶è´¹ã€‚ç„¶è€Œï¼Œè¿™æ ·çš„æ–¹æ³•æ— ç–‘éœ€è¦å¤§é‡çš„å†…æ ¸å¼€å‘å·¥ä½œï¼Œå¹¶ä¸”ç”±äºå°†å¤šä¸ªå†…æ ¸å‡½æ•°ç”¨äºç»†ç²’åº¦èµ„æºè·Ÿè¸ªè€Œå¸¦æ¥å¤§é‡çš„è¿è¡Œæ—¶å¼€é”€ã€‚ å¯¹äºæŸäº›å·¥ä½œè´Ÿè½½ï¼Œå¦ä¸€ä¸ªæœ‰äº‰è®®çš„é—®é¢˜æ˜¯cgroupæ˜¯å¦åº”è¯¥å‘å®¹å™¨æ”¶å–è¿™äº›ç³»ç»Ÿèµ„æºã€‚ä»éšç§çš„è§’åº¦è€ƒè™‘ï¼Œä¸»æœºæœåŠ¡å™¨ä¸åº”è¯¥è®°å½•å®¹å™¨å®ä¾‹ä¸­è¿è¡Œçš„ä»»ä½•æ•æ„Ÿä¿¡æ¯ã€‚journaldæä¾›äº†ç‰¹å®šçš„é€‰é¡¹æ¥å¯ç”¨å®¹å™¨å†…çš„æ—¥å¿—æ´»åŠ¨ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å±•ç¤ºäº†ï¼Œå³ä½¿æ²¡æœ‰å¯ç”¨æ—¥å¿—è®°å½•é€‰é¡¹ï¼Œä¸»æœºä»ç„¶ä¸ºå®¹å™¨è®°å½•å¤šä¸ªäº‹ä»¶ã€‚æ—¥å¿—è®°å½•æ˜¯ç”±ä¸»æœºæ‰§è¡Œçš„ï¼Œå› æ­¤ä¸åº”è¯¥å‘å®¹å™¨æ”¶è´¹ã€‚æ­¤å¤–ï¼Œå®¹å™¨ç”¨æˆ·æ— æ³•è·å¾—å®¹å™¨å†…å¼•å‘çš„å¼‚å¸¸çš„æ ¸å¿ƒè½¬å‚¨ä¿¡æ¯ã€‚å› æ­¤ï¼Œä¸€ç§å¯èƒ½çš„æ–¹æ³•æ˜¯é€šè¿‡åŒºåˆ†å®¹å™¨ä¸Šä¸‹æ–‡ç¦ç”¨æ‰€æœ‰æ½œåœ¨çš„æ—¥å¿—è®°å½•æˆ–è®°å½•æ´»åŠ¨ã€‚å®Œå…¨è§£å†³è¿™ä¸ªé—®é¢˜çš„å¦ä¸€ç§æ–¹æ³•æ˜¯æ„å»ºä¸€ä¸ªé¢å¤–çš„cgroupå­ç³»ç»Ÿï¼Œä¸“é—¨ç”¨äºæ—¥å¿—è®°å½•ã€‚æ‰€æœ‰æ—¥å¿—è®°å½•æ´»åŠ¨éƒ½å°†ç”±æ–°çš„æ—¥å¿—è®°å½•cgroupå­ç³»ç»Ÿè¿›è¡Œè®°å½•ã€‚ æœ€åï¼Œæœ‰äº›é—®é¢˜å³ä½¿ä½¿ç”¨ç»†ç²’åº¦çš„ä¼šè®¡æœºåˆ¶ä¹Ÿæ— æ³•è§£å†³ã€‚ä¾‹å¦‚ï¼Œè™½ç„¶å½“å‰çš„cgroupsæœºåˆ¶æ¸…æ¥šåœ°æåˆ°å›å†™å·¥ä½œè´Ÿè½½ä¸è¢«è®¡ç®—åœ¨å†…ï¼Œä½†Linuxå†…æ ¸ç»´æŠ¤è€…å·²ç»å¼€å§‹å¼€å‘æ–°çš„cgroupæœºåˆ¶(å³cgroup v2)ï¼Œå®ƒåˆ©ç”¨å†…å­˜å’Œblkioå­ç³»ç»Ÿæ¥è·Ÿè¸ªå›å†™å¹¶ä¸ºè„é¡µçš„å®¹å™¨æ”¶è´¹ã€‚ç„¶è€Œï¼Œæ¶æ„å®¹å™¨å¯ä»¥åœ¨ä¸ç”Ÿæˆä»»ä½•I&#x2F;Oå·¥ä½œè´Ÿè½½çš„æƒ…å†µä¸‹ç»§ç»­è°ƒç”¨syncã€‚å›å†™å·¥ä½œè´Ÿè½½ç”±å…·æœ‰I&#x2F;Oæ“ä½œçš„å®¹å™¨æ‰¿æ‹…ï¼Œè€Œä¸æ˜¯ç”±æ¶æ„å®¹å™¨æ‰¿æ‹…ã€‚åŒæ—¶ï¼Œå‘è°ƒç”¨æ•°æ®åŒæ­¥çš„å®¹å™¨æ”¶å–æ‰€æœ‰è´¹ç”¨æ˜¯ä¸å…¬å¹³çš„ã€‚ç”±äºç®€å•åœ°ç¦ç”¨æ‰€æœ‰è¿™äº›åŠŸèƒ½å°†ä¸å¯é¿å…åœ°å½±å“å¯ç”¨æ€§ï¼Œä¸€ä¸ªæ½œåœ¨å¯è¡Œçš„è§£å†³æ–¹æ¡ˆæ˜¯å¯¹è¿™äº›æ•æ„Ÿæ“ä½œæ–½åŠ é€Ÿç‡é™åˆ¶ã€‚ RELATED WORKåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬è°ƒæŸ¥äº†ä¸€äº›å¯å‘æˆ‘ä»¬å·¥ä½œçš„ç ”ç©¶å·¥ä½œï¼Œå¹¶å¼ºè°ƒäº†æˆ‘ä»¬çš„å·¥ä½œä¸ä»¥å¾€ç ”ç©¶ä¹‹é—´çš„å·®å¼‚ã€‚æˆ‘ä»¬ä¸»è¦è®¨è®ºä»¥ä¸‹ä¸¤ä¸ªæ–¹é¢çš„ç ”ç©¶å·¥ä½œ: Virtual Machine and Containerè™½ç„¶VMå·²ç»è¿æ¥äº†äº‘è®¡ç®—æ—¶ä»£ï¼Œä½†å°½ç®¡è¿›è¡Œäº†å¤§é‡çš„ç ”ç©¶å·¥ä½œï¼Œå…¶æ€§èƒ½ä»ç„¶ä¸èƒ½ä»¤äººæ»¡æ„ã€‚å®¹å™¨æ­£å˜å¾—è¶Šæ¥è¶Šæµè¡Œï¼Œå› ä¸ºå®ƒæä¾›äº†ä¸€ç§å¯ç”¨è½»é‡çº§è™šæ‹ŸåŒ–çš„æ›¿ä»£æ–¹å¼ï¼Œå¹¶å…è®¸åœ¨å®¹å™¨ä¸­è¿è¡Œçš„åº”ç”¨ç¨‹åºå®Œå…¨å…¼å®¹ã€‚å› æ­¤ï¼Œç ”ç©¶äººå‘˜å¯¹ç¡¬ä»¶è™šæ‹ŸåŒ–å’Œå®¹å™¨ä¹‹é—´çš„æ€§èƒ½æ¯”è¾ƒå¾ˆå¥½å¥‡ã€‚Felterç­‰äººè¡¨æ˜ï¼Œé€šè¿‡ä½¿ç”¨ä¸€ç»„æ¶µç›–CPUã€å†…å­˜ã€å­˜å‚¨å’Œç½‘ç»œèµ„æºçš„åŸºå‡†æµ‹è¯•ï¼ŒDockeråœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½å¯ä»¥å®ç°æ¯”KVMæ›´é«˜çš„æ€§èƒ½ã€‚ Spoialaç­‰è¿˜è¯æ˜äº†Dockerä¼˜äºKVMï¼Œå¹¶ä¸”å¯ä»¥ä½¿ç”¨Kurento Media Serveræ¥æµ‹è¯•WebRTCæœåŠ¡å™¨çš„æ€§èƒ½ï¼Œä»è€Œæ”¯æŒå®æ—¶åº”ç”¨ç¨‹åºã€‚Morabito et alè¿›ä¸€æ­¥æ¯”è¾ƒäº†ä¼ ç»Ÿhypervisor(ä¾‹å¦‚KVM)å’Œosçº§è™šæ‹ŸåŒ–(åŒ…æ‹¬Dockerå’ŒLXC)åœ¨è®¡ç®—ã€å­˜å‚¨ã€å†…å­˜å’Œç½‘ç»œæ–¹é¢çš„æ€§èƒ½ï¼Œå¹¶è§‚å¯Ÿåˆ°ç£ç›˜I&#x2F;Oä»ç„¶æ˜¯KVM hypervisorçš„ç“¶é¢ˆã€‚æ‰€æœ‰è¿™äº›å·¥ä½œéƒ½è¡¨æ˜ï¼ŒåŸºäºå®¹å™¨çš„æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ˜¯æ¯”ä¼ ç»Ÿçš„åŸºäºvmçš„ç¡¬ä»¶è™šæ‹ŸåŒ–æ›´æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆã€‚è™½ç„¶ä»¥å‰çš„å¤§å¤šæ•°ç ”ç©¶å·¥ä½œéƒ½é›†ä¸­åœ¨ç†è§£å®¹å™¨çš„æ€§èƒ½ä¸Šï¼Œä½†å¾ˆå°‘æœ‰äººè¯•å›¾è°ƒæŸ¥åº•å±‚å†…æ ¸æœºåˆ¶çš„èµ„æºå…±äº«çš„æœ‰æ•ˆæ€§ã€‚æˆ‘ä»¬æ˜¯ç¬¬ä¸€æ‰¹ç³»ç»Ÿåœ°ç ”ç©¶ç”±Cgroupä¸è¶³å¼•èµ·çš„å®¹å™¨çš„æ€§èƒ½å’Œèµ„æºæ ¸ç®—é—®é¢˜çš„äººã€‚ Container securityé™¤äº†æ€§èƒ½ï¼Œå®¹å™¨çš„å®‰å…¨æ€§ä¹Ÿå—åˆ°äº†å­¦æœ¯ç•Œå’Œä¸šç•Œçš„å¹¿æ³›å…³æ³¨ã€‚Guptaé¦–å…ˆç®€è¦ä»‹ç»äº†Dockerå®‰å…¨æ€§ã€‚Buiä»éš”ç¦»å’Œç›¸åº”çš„å†…æ ¸å®‰å…¨æœºåˆ¶æ–¹é¢å¯¹Dockerå®¹å™¨è¿›è¡Œäº†åˆ†æã€‚è™½ç„¶ä¹‹å‰çš„å·¥ä½œå£°ç§°Dockerå®¹å™¨åœ¨é»˜è®¤é…ç½®ä¸‹æ˜¯ç›¸å½“å®‰å…¨çš„ï¼Œä½†Linç­‰äººå‘ç°ï¼Œå¤§å¤šæ•°ç°æœ‰çš„æ¼æ´éƒ½å¯ä»¥é€šè¿‡é»˜è®¤é…ç½®æˆåŠŸåœ°ä»å®¹å™¨å†…éƒ¨å‘èµ·æ”»å‡»ã€‚Grattafioriç­‰äººæ€»ç»“äº†å®¹å™¨çš„å„ç§æ½œåœ¨æ¼æ´ï¼ŒåŒ…æ‹¬åŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿä¸­çš„é—®é¢˜ã€‚Gaoç­‰äººè¿›ä¸€æ­¥å¯¹åŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿç”±äºnamespaceé—®é¢˜è€Œäº§ç”Ÿçš„æ½œåœ¨å®‰å…¨å½±å“è¿›è¡Œäº†ç³»ç»Ÿç ”ç©¶ã€‚Leiç­‰äººæå‡ºäº†ä¸€ç§åä¸ºSPEAKERçš„å®¹å™¨å®‰å…¨æœºåˆ¶ï¼Œä»¥å‡å°‘å¯¹åº”ç”¨ç¨‹åºçš„å¯ç”¨ç³»ç»Ÿè°ƒç”¨æ•°é‡ã€‚Sunç­‰äººå¼€å‘äº†ä¸¤ä¸ªå®‰å…¨å‘½åç©ºé—´ï¼Œä¸ºå®¹å™¨å®ç°è‡ªä¸»å®‰å…¨æ§åˆ¶ï¼ŒArnautovç­‰äººæå‡ºä½¿ç”¨Intel SGXä¿æŠ¤Linuxå®¹å™¨ã€‚ é”™è¯¯é…ç½®çš„èƒ½åŠ›ä¹Ÿå¯ä»¥è¢«åˆ©ç”¨æ¥å»ºç«‹å®¹å™¨ä¸­çš„ç§˜å¯†é€šé“ã€‚æˆ‘ä»¬åœ¨cgroupæ–¹é¢çš„å·¥ä½œè¿›ä¸€æ­¥è¡¥å……äº†ä»¥å‰çš„çš„ç ”ç©¶å·¥ä½œã€‚ Cloud SecurityCo-residenceå¤§é‡çš„ç ”ç©¶å·¥ä½œä¹Ÿè‡´åŠ›äºç†è§£äº‘çš„å®‰å…¨é—®é¢˜ï¼Œç‰¹åˆ«æ˜¯ä¸åŒç§Ÿæˆ·å…±äº«ç›¸åŒè®¡ç®—åŸºç¡€è®¾æ–½çš„å¤šç§Ÿæˆ·äº‘ã€‚åœ¨å¤šç§Ÿæˆ·äº‘ç¯å¢ƒä¸­ï¼Œæ”»å‡»è€…å¯ä»¥å°†æ¶æ„è™šæ‹Ÿæœºä¸ç›®æ ‡è™šæ‹Ÿæœºå…±åŒé©»ç•™åœ¨åŒä¸€å°æœåŠ¡å™¨ä¸Šï¼Œç„¶åå‘èµ·åŒ…æ‹¬ä¾§é€šé“å’Œéšè”½é€šé“æ”»å‡»åœ¨å†…çš„å„ç§æ”»å‡»ã€‚åŒæ—¶ï¼Œä¾§é¢æ”»å‡»å’Œéšè”½é€šé“æ”»å‡»æ˜¯éªŒè¯åŒä¸€ç‰©ç†æœåŠ¡å™¨ä¸Šå…±å­˜çš„å¸¸ç”¨æ–¹æ³•ã€‚ä¾‹å¦‚ï¼ŒåŸºäºç¼“å­˜çš„éšè”½é€šé“è¢«å¹¿æ³›é‡‡ç”¨ï¼Œå› ä¸ºå¤šä¸ªå®ä¾‹å…±äº«åŒä¸€ä¸ªåŒ…ä¸Šçš„æœ€åä¸€çº§ç¼“å­˜ã€‚Zhangç­‰äººè¿›ä¸€æ­¥è®ºè¯äº†åœ¨äº‘ä¸Šå‘èµ·çœŸå®ä¾§é€šé“æ”»å‡»çš„å¯è¡Œæ€§ã€‚é™¤äº†åŸºäºç¼“å­˜çš„é€šé“ï¼Œå…¶ä»–æ–¹æ³•å¦‚å†…å­˜æ€»çº¿ã€å†…å­˜é‡å¤æ•°æ®åˆ é™¤ã€æ ¸å¿ƒæ¸©åº¦ä¹Ÿå¯ä»¥æœ‰æ•ˆåœ°æ„å»ºéšè”½é€šé“ã€‚ è™½ç„¶ä¹Ÿæå‡ºäº†å¤šç§é˜²å¾¡æœºåˆ¶ï¼Œä½†ä¹‹å‰çš„ä¸¤é¡¹å·¥ä½œè¡¨æ˜ï¼Œåœ¨ç°æœ‰çš„ä¸»æµäº‘æœåŠ¡ä¸­å®ç°åˆä½ä»ç„¶æ˜¯å¯è¡Œçš„(è€Œä¸”æˆæœ¬ä½å»‰)ã€‚Wangç­‰äººå¯¹ä¸‰ç§æ— æœåŠ¡å™¨è®¡ç®—æœåŠ¡è¿›è¡Œäº†å¤§è§„æ¨¡çš„æµ‹é‡ç ”ç©¶ï¼Œå‘ç°äº†å‡ ä¸ªèµ„æºæ ¸ç®—é—®é¢˜ï¼Œç§Ÿæˆ·å¯èƒ½ä¼šæ»¥ç”¨è¿™äº›é—®é¢˜æ¥è¿è¡Œé¢å¤–çš„å·¥ä½œè´Ÿè½½ã€‚ Denial-of-Service attacksç”±äºåº•å±‚è®¡ç®—èµ„æºåœ¨ä¸åŒçš„ç§Ÿæˆ·ä¹‹é—´å…±äº«ï¼Œå› æ­¤äº‰ç”¨æ˜¯ä¸å¯é¿å…çš„ã€‚Varadarajanç­‰äººæå‡ºäº†èµ„æºé‡Šæ”¾æ”»å‡»æ¥é‡Šæ”¾å—å®³è€…ä½¿ç”¨çš„èµ„æºï¼Œè¿™æ ·æ”»å‡»è€…çš„å®ä¾‹å°±å¯ä»¥è·å¾—é¢å¤–çš„åˆ©ç”¨ã€‚Zhangç­‰äººè°ƒæŸ¥äº†å†…å­˜DoSæ”»å‡»çš„å½±å“ï¼Œå¹¶è¡¨æ˜æ¶æ„äº‘å®¢æˆ·å¯ä»¥å¯¹ç”µå­å•†åŠ¡ç½‘ç«™é€ æˆ38å€çš„å»¶è¿Ÿã€‚å¯¹äºé’ˆå¯¹I&#x2F;Oæ€§èƒ½çš„DoSæ”»å‡»ï¼ŒHuangç­‰æå‡ºäº†çº§è”æ€§èƒ½æ”»å‡»ï¼Œä»¥è€—å°½hypervisorçš„I&#x2F;Oå¤„ç†èƒ½åŠ›ã€‚æ­¤å¤–ï¼Œå¤šç§æ”»å‡»è¯•å›¾è€—å°½å…±äº«çš„åŸºç¡€è®¾æ–½èµ„æºï¼Œå¦‚ç”µåŠ›è®¾æ–½ï¼Œä»è€Œè¿«ä½¿æ•°æ®ä¸­å¿ƒçš„æœåŠ¡å™¨å…³é—­ã€‚ä¸ä¹‹å‰çš„å·¥ä½œä¸åŒï¼Œæˆ‘ä»¬çš„å·¥ä½œè¡¨æ˜ï¼Œcgroupsä¸­çš„ä¸è¶³ä¹Ÿå¯ä»¥è¢«åˆ©ç”¨æ¥åœ¨å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒä¸­å‘èµ·å¤šæ¬¡æ”»å‡»ã€‚ CONCLUSIONåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å¼€å‘äº†ä¸€å¥—ç­–ç•¥æ¥æ‰“ç ´Linuxæ§åˆ¶ç»„çš„èµ„æºæ§åˆ¶ã€‚æˆ‘ä»¬è¯æ˜äº†é€šè¿‡è¿›ç¨‹åˆ›å»ºç»§æ‰¿çš„cgroupsé™åˆ¶å¹¶ä¸æ€»æ˜¯ä¿è¯ä¸€è‡´å’Œå…¬å¹³çš„èµ„æºæ ¸ç®—ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸åŸå§‹cgroupè§£å…³è”çš„è¿›ç¨‹æ¥ç”Ÿæˆå¸¦å¤–å·¥ä½œè´Ÿè½½ã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥æå‡ºäº†äº”ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œè¡¨æ˜åœ¨Dockerå®¹å™¨ç¯å¢ƒä¸­å®ç°è¿™äº›æ”»å‡»æ˜¯å¯è¡Œçš„ã€‚æ¶æ„å®¹å™¨åˆ©ç”¨å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒä¸­cgroupsçš„è¿™äº›ä¸è¶³ï¼Œå¯ä»¥æå¤§åœ°è€—å°½ä¸»æœºçš„èµ„æºï¼Œå¹¶å‘èµ·å¤šç§æ”»å‡»ï¼ŒåŒ…æ‹¬æ‹’ç»æœåŠ¡æ”»å‡»ã€èµ„æºé‡Šæ”¾æ”»å‡»å’Œç§˜å¯†é€šé“æ”»å‡»ã€‚æˆ‘ä»¬åœ¨äºšé©¬é€ŠEC2äº‘ä¸­çš„æœ¬åœ°æµ‹è¯•å¹³å°å’Œä¸“ç”¨æœåŠ¡å™¨ä¸Šè¿›è¡Œäº†å®éªŒï¼Œå¹¶è¯æ˜äº†ä¸€ä¸ªå®¹å™¨å¯ä»¥å°†å…¶å·¥ä½œè´Ÿè½½æ”¾å¤§200å€ä»¥ä¸Šï¼Œå¹¶å°†å…¶ä»–å®¹å™¨çš„æ€§èƒ½é™ä½95%ã€‚ MyCase 1Linux å†…æ ¸ä¸ºå„ç§å¼‚å¸¸æä¾›äº†ä¸“ç”¨çš„å¼‚å¸¸å¤„ç†ç¨‹åºã€‚è¿™äº›å¼‚å¸¸å¤„ç†ç¨‹åºåˆ†ä¸ºä¸¤ç±»ï¼šé”™è¯¯å’Œé™·é˜±ã€‚é”™è¯¯æ˜¯æŒ‡ç¨‹åºåœ¨è¿è¡Œè¿‡ç¨‹ä¸­é‡åˆ°çš„é—®é¢˜ï¼Œå¦‚åˆ†æ®µé”™è¯¯ã€‚é™·é˜±æ˜¯æŒ‡ç¨‹åºä¸»åŠ¨è§¦å‘çš„äº‹ä»¶ï¼Œå¦‚æº¢å‡ºæ£€æµ‹ã€‚ åœ¨å¤„ç†è¿™äº›å¼‚å¸¸æ—¶ï¼Œå†…æ ¸ç»´æŠ¤äº†ä¸€ä¸ªåä¸ºä¸­æ–­æè¿°ç¬¦è¡¨ï¼ˆIDTï¼‰çš„æ•°æ®ç»“æ„ã€‚IDT åŒ…å«æ¯ä¸ªå¼‚å¸¸å¤„ç†ç¨‹åºçš„åœ°å€ã€‚å½“ CPU åœ¨ç”¨æˆ·æ¨¡å¼ä¸‹å¼•å‘å¼‚å¸¸æ—¶ï¼Œç›¸åº”çš„å¤„ç†ç¨‹åºå°†åœ¨å†…æ ¸æ¨¡å¼ä¸‹è¿è¡Œã€‚ å¯„å­˜å™¨ä¿å­˜å’Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼šå½“å¼‚å¸¸å‘ç”Ÿæ—¶ï¼Œå¤„ç†å™¨é¦–å…ˆå°†å½“å‰çš„å¯„å­˜å™¨çŠ¶æ€ä¿å­˜åˆ°å†…æ ¸å †æ ˆä¸­ã€‚è¿™æ ·ï¼Œåœ¨å¼‚å¸¸å¤„ç†å®Œæˆåï¼Œå¤„ç†å™¨å¯ä»¥æ¢å¤åŸå§‹çŠ¶æ€å¹¶è¿”å›åˆ°ç”¨æˆ·æ¨¡å¼ã€‚ å¼‚å¸¸å¤„ç†ï¼šåœ¨å†…æ ¸æ¨¡å¼ä¸‹ï¼Œå¤„ç†å™¨ä¼šæ ¹æ®å¼‚å¸¸ç±»å‹è°ƒç”¨ç›¸åº”çš„å¤„ç†ç¨‹åºã€‚å¼‚å¸¸å¤„ç†ç¨‹åºé€šå¸¸ä¼šæ‰§è¡Œä¸€äº›ç‰¹å®šçš„æ“ä½œï¼Œå¦‚æ¸…ç†èµ„æºã€è®°å½•é”™è¯¯ä¿¡æ¯ç­‰ã€‚åœ¨å¤„ç†å¼‚å¸¸æ—¶ï¼Œæ•´ä¸ªè¿‡ç¨‹å°†åœ¨å†…æ ¸ç©ºé—´å’Œè§¦å‘å¼‚å¸¸çš„è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­è¿è¡Œã€‚å› æ­¤ï¼Œå¼‚å¸¸å¤„ç†æœŸé—´æ¶ˆè€—çš„èµ„æºå°†è¢«è®¡å…¥ç›¸åº”çš„ cgroupsã€‚ ä¿¡å·å¤„ç†å’Œå†…æ ¸è½¬å‚¨ï¼šå¼‚å¸¸å¤„ç†ç¨‹åºå¯èƒ½ä¼šç»ˆæ­¢åˆå§‹è¿›ç¨‹ï¼Œå¹¶å‘å…¶å‘é€ä¸€ä¸ªä¿¡å·ã€‚è¿™äº›ä¿¡å·ä¼šè§¦å‘å†…æ ¸è½¬å‚¨åŠŸèƒ½ï¼Œç”Ÿæˆä¸€ä¸ªç”¨äºè°ƒè¯•çš„å†…æ ¸è½¬å‚¨æ–‡ä»¶ã€‚åœ¨ Linux å†…æ ¸ä¸­ï¼Œæ ¸å¿ƒè½¬å‚¨ä»£ç é€šè¿‡ usermode è¾…åŠ© API è°ƒç”¨ä¸€ä¸ªç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºæ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ã€‚ ç”¨æˆ·ç©ºé—´æ ¸å¿ƒè½¬å‚¨ç¨‹åºï¼šåœ¨ Ubuntu ä¸­ï¼Œé»˜è®¤çš„ç”¨æˆ·ç©ºé—´æ ¸å¿ƒè½¬å‚¨ç¨‹åºæ˜¯ Apportï¼Œå®ƒä¼šåœ¨æ¯ä¸ªå¼‚å¸¸æƒ…å†µä¸‹è¢«è§¦å‘ã€‚Apport çš„èµ„æºæ¶ˆè€—ä¸ä¼šç”±å®¹å™¨æ‰¿æ‹…ï¼Œå› ä¸ºå®ƒæ˜¯ç”±å†…æ ¸çº¿ç¨‹åˆ›å»ºçš„ï¼Œè€Œä¸æ˜¯ç”±å®¹å™¨åŒ–çš„è¿›ç¨‹åˆ›å»ºçš„ã€‚ è´Ÿè½½å¹³è¡¡å’Œèµ„æºæ”¾å¤§ï¼šå†…æ ¸ä¼šå°†æ–°ç”Ÿæˆçš„ Apport å®ä¾‹è°ƒåº¦åˆ°æ‰€æœ‰å¯ç”¨çš„ CPU æ ¸å¿ƒä¸Šï¼Œä»¥å®ç°è´Ÿè½½å¹³è¡¡ã€‚è¿™ä¼šå¯¼è‡´æ‰“ç ´ cpusets cgroup çš„çº¦æŸã€‚åŒæ—¶ï¼Œç”±äº Apport è¿›ç¨‹æ¯”è½»é‡çº§çš„å¼‚å¸¸å¤„ç†ï¼ˆå³å†…æ ¸æ§åˆ¶è·¯å¾„ï¼‰æ¶ˆè€—æ›´å¤šèµ„æºï¼Œå¦‚æœå®¹å™¨ä¸æ–­è§¦å‘å¼‚å¸¸ï¼Œæ•´ä¸ª CPU å¯èƒ½ä¼šè¢« Apport è¿›ç¨‹å æ»¡ã€‚è¿™ç§æƒ…å†µå¯¼è‡´äº†åˆ†é…ç»™å®¹å™¨çš„ç³»ç»Ÿèµ„æºçš„æ”¾å¤§ã€‚ æ€»ç»“ä¸€ä¸‹ï¼Œå½“ç”¨æˆ·ç¨‹åºè§¦å‘å¼‚å¸¸æ—¶ï¼ŒLinux å†…æ ¸ä¼šé€šè¿‡ IDT æ‰¾åˆ°ç›¸åº”çš„å¤„ç†ç¨‹åºï¼Œå¹¶åœ¨å†…æ ¸æ¨¡å¼ä¸‹è¿è¡Œã€‚å¤„ç†ç¨‹åºå¯èƒ½ä¼šç»ˆæ­¢è¿›ç¨‹å¹¶è§¦å‘å†…æ ¸è½¬å‚¨åŠŸèƒ½ã€‚åœ¨ Ubuntu ä¸­ï¼Œè¿™ä¼šè°ƒç”¨ç”¨æˆ·ç©ºé—´çš„ Apport ç¨‹åºæ¥ç”Ÿæˆå†…æ ¸è½¬å‚¨æ–‡ä»¶ã€‚Apport çš„èµ„æºæ¶ˆè€—ä¸ä¼šç”±å®¹å™¨æ‰¿æ‹…ï¼Œä½†å¯èƒ½å¯¼è‡´èµ„æºæ”¾å¤§å’Œ cpusets cgroup çš„çº¦æŸè¢«æ‰“ç ´ã€‚ å½“ä½ åœ¨ä½¿ç”¨ç”µè„‘æ—¶ï¼Œæœ‰æ—¶ä¼šé‡åˆ°ä¸€äº›é—®é¢˜ï¼Œæ¯”å¦‚ç¨‹åºå‡ºé”™æˆ–è€…æ„å¤–åœæ­¢è¿è¡Œã€‚è¿™äº›é—®é¢˜é€šå¸¸æ˜¯ç”±äºç¨‹åºä¸­çš„å¼‚å¸¸å¼•èµ·çš„ã€‚åœ¨ Linux ç³»ç»Ÿä¸­ï¼Œæœ‰ä¸€å¥—ä¸“é—¨å¤„ç†è¿™äº›å¼‚å¸¸çš„æœºåˆ¶ã€‚ æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ç¨‹åºé‡åˆ°å¼‚å¸¸æ—¶ï¼Œå°±åƒä¸€ä¸ªçƒå‘˜åœ¨æ¯”èµ›ä¸­å—ä¼¤äº†ã€‚è¿™æ—¶ï¼Œæ•™ç»ƒï¼ˆå†…æ ¸ï¼‰ä¼šæ´¾ä¸Šå¦ä¸€ä¸ªçƒå‘˜ï¼ˆå¼‚å¸¸å¤„ç†ç¨‹åºï¼‰æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚è¿™ä¸ªè¿‡ç¨‹å‘ç”Ÿåœ¨çƒåœºå†…ï¼ˆå†…æ ¸ç©ºé—´ï¼‰ï¼Œå¹¶ä¸”ä¼šè®°å½•ä¸‹è¿™ä¸ªé—®é¢˜å‘ç”Ÿçš„åŸå› ã€‚ åœ¨å¤„ç†å¼‚å¸¸æ—¶ï¼Œæ•™ç»ƒéœ€è¦ç¡®ä¿å…¶ä»–çƒå‘˜ä¸å—å½±å“ã€‚å› æ­¤ï¼Œæ•™ç»ƒä¼šå°†å—ä¼¤çƒå‘˜çš„çŠ¶æ€ä¿å­˜èµ·æ¥ï¼Œç­‰é—®é¢˜å¤„ç†å®Œåå†æ¢å¤ã€‚è¿™ä¸ªè¿‡ç¨‹å°±åƒæ˜¯åœ¨ç°åœºç»™å—ä¼¤çƒå‘˜åšç´§æ€¥å¤„ç†ã€‚ æœ‰æ—¶ï¼Œè¿™ä¸ªé—®é¢˜ä¸¥é‡åˆ°éœ€è¦å‘ŠçŸ¥å…¶ä»–äººï¼ˆå‘é€ä¿¡å·ï¼‰ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ•™ç»ƒä¼šé€šçŸ¥åŒ»ç–—å›¢é˜Ÿï¼ˆApport ç¨‹åºï¼‰æ¥å¤„ç†ã€‚åŒ»ç–—å›¢é˜Ÿä¼šæŠŠå—ä¼¤çƒå‘˜çš„æƒ…å†µè®°å½•ä¸‹æ¥ï¼ˆç”Ÿæˆå†…æ ¸è½¬å‚¨æ–‡ä»¶ï¼‰ï¼Œä»¥ä¾¿åœ¨ä¹‹ååˆ†æå’Œå¤„ç†ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒåŒ»ç–—å›¢é˜Ÿï¼ˆApportï¼‰å¤„ç†é—®é¢˜æ—¶æ‰€æ¶ˆè€—çš„èµ„æºä¸ä¼šå½±å“çƒé˜Ÿï¼ˆå®¹å™¨ï¼‰ï¼Œä½†æœ‰æ—¶ä»–ä»¬çš„å¤„ç†å¯èƒ½ä¼šè®©æ•´ä¸ªæ¯”èµ›ï¼ˆç³»ç»Ÿèµ„æºï¼‰å—åˆ°å½±å“ï¼Œå¯¼è‡´å…¶ä»–çƒå‘˜çš„è¡¨ç°å—åˆ°ä¸€å®šç¨‹åº¦çš„å½±å“ã€‚ æ€»ä¹‹ï¼Œå½“ç”µè„‘é‡åˆ°é—®é¢˜æ—¶ï¼ŒLinux ç³»ç»Ÿä¼šé€šè¿‡ä¸€å¥—å†…æ ¸æœºåˆ¶æ¥å¤„ç†è¿™äº›å¼‚å¸¸ã€‚åœ¨å¤„ç†è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šæ¶‰åŠåˆ°ä¸€äº›é¢å¤–çš„ç¨‹åºï¼Œå¦‚ Apportï¼Œåœ¨ç¡®ä¿ä¸å½±å“å…¶ä»–ç¨‹åºè¿è¡Œçš„å‰æä¸‹ï¼Œè®°å½•å’Œå¤„ç†å¼‚å¸¸ã€‚ Case 2 ç£ç›˜æ•°æ®åŒæ­¥å›å†™æœºåˆ¶ï¼šè¿™æ˜¯ä¸€ç§æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œä½¿CPUåªå°†æ›´æ–°åçš„æ•°æ®å†™å…¥ç¼“å­˜ï¼Œè€Œä¸æ˜¯ç›´æ¥å†™å…¥ç£ç›˜ã€‚å½“ç¼“å­˜è¢«æ¸…é™¤æ—¶ï¼Œæ•°æ®æ‰ä¼šå†™å…¥ç£ç›˜ã€‚è¿™ç§æœºåˆ¶é€šè¿‡å°†å¯åŠ¨I&#x2F;Oè¿›ç¨‹ä¸åŒæ­¥ç£ç›˜å†™å…¥è¿›ç¨‹è§£è€¦æ¥æé«˜æ€§èƒ½ã€‚ åŒæ­¥ï¼šåŒæ­¥æ˜¯å°†ç¼“å­˜ä¸­çš„æ•°æ®å†™å›ç£ç›˜çš„è¿‡ç¨‹ã€‚è¿™å¯ä»¥é€šè¿‡å¤šç§æ–¹æ³•è§¦å‘ï¼Œä¾‹å¦‚å®šæœŸå›å†™ã€å†…å­˜ä¸è¶³ï¼Œæˆ–è€…é€šè¿‡ç”¨æˆ·è¿›ç¨‹æ•…æ„è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼ˆå¦‚syncã€syncfså’Œfsyncï¼‰ã€‚è¿™äº›ç³»ç»Ÿè°ƒç”¨å¯¹Linuxå®¹å™¨æ˜¯å¯ç”¨çš„ã€‚ åˆ©ç”¨åŒæ­¥çš„æ”»å‡»ï¼šç”±äºåŒæ­¥å…è®¸è¿›ç¨‹å°†æ‰€æœ‰è„ç¼“å†²åŒºå†™å›ç£ç›˜ï¼Œå› æ­¤åœ¨åŒæ­¥æœŸé—´ï¼Œä»»ä½•I&#x2F;Oæ“ä½œéƒ½å¿…é¡»ç­‰å¾…ã€‚è¿™å¯ä»¥è¢«æ¶æ„è¿›ç¨‹åˆ©ç”¨ï¼Œé€šè¿‡é‡å¤è°ƒç”¨syncï¼Œä»¥å‡æ…¢æ•´ä¸ªç³»ç»Ÿçš„I&#x2F;Oæ€§èƒ½ã€å‘èµ·æ— èµ„æºæ”»å‡»ï¼Œç”šè‡³å»ºç«‹ç§˜å¯†é€šé“ã€‚ ç»•è¿‡cgroupï¼šcgroupæ˜¯ä¸€ç§ç”¨äºé™åˆ¶èµ„æºä½¿ç”¨çš„æœºåˆ¶ï¼Œä½†ç”±äºåŒæ­¥æ“ä½œæ˜¯åœ¨å†…æ ¸çº¿ç¨‹ä¸­è¿›è¡Œçš„ï¼Œå¹¶ä¸”è°ƒç”¨syncçš„å®¹å™¨æ²¡æœ‰I&#x2F;Oå·¥ä½œè´Ÿè½½ï¼Œå› æ­¤cgroupæ— æ³•é™åˆ¶åŒæ­¥æ“ä½œã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå³ä½¿ä½¿ç”¨blkio cgroupå­ç³»ç»Ÿå¯¹è¿è¡ŒåŒæ­¥çš„å®¹å™¨åº”ç”¨I&#x2F;Oæ§åˆ¶ï¼Œä»ç„¶æ— æ³•å‡å°‘åŒæ­¥çš„å½±å“ã€‚è¿™æ˜¯å› ä¸ºblkioæ§åˆ¶å™¨ä»…é™åˆ¶ç›¸å¯¹I&#x2F;Oååé‡ï¼Œè€Œä¸æ˜¯ç»å¯¹å€¼ã€‚æ­¤å¤–ï¼ŒDockerçš„ç»Ÿè®¡å·¥å…·æ˜¾ç¤ºï¼Œè°ƒç”¨syncçš„å®¹å™¨çš„I&#x2F;Oååé‡ä¸ºé›¶ï¼Œè¿™æ„å‘³ç€blkioé™åˆ¶ä¸èµ·ä½œç”¨ã€‚ è¿™ä¸ªæ¡ˆä¾‹è®²è¿°äº†ä¸€ä¸ªå…³äºç£ç›˜æ•°æ®åŒæ­¥çš„æŠ€æœ¯ï¼Œå®ƒå«åšæ‡’æƒ°å›å†™ï¼ˆlazy write-backï¼‰ã€‚è¿™ç§æŠ€æœ¯çš„ä¸»è¦ä¼˜ç‚¹æ˜¯æé«˜ç”µè„‘çš„æ€§èƒ½ã€‚å½“æˆ‘ä»¬åœ¨ç”µè„‘ä¸Šåšä¸€äº›æ”¹åŠ¨æ—¶ï¼Œè¿™äº›æ”¹åŠ¨é¦–å…ˆä¼šè¢«ä¿å­˜åœ¨ç¼“å­˜ä¸­ï¼Œè€Œä¸æ˜¯ç›´æ¥å†™å…¥ç£ç›˜ã€‚åªæœ‰å½“ç¼“å­˜è¢«æ¸…ç©ºæ—¶ï¼Œæ”¹åŠ¨æ‰ä¼šçœŸæ­£åœ°è¢«ä¿å­˜åˆ°ç£ç›˜é‡Œã€‚è¿™æ ·çš„æ“ä½œå¯ä»¥èŠ‚çœæ—¶é—´ï¼Œå› ä¸ºå†™å…¥ç£ç›˜çš„é€Ÿåº¦å¾€å¾€æ¯”å†™å…¥ç¼“å­˜æ…¢ã€‚ è¿™ç§æŠ€æœ¯å¯ä»¥è®©ä¸€ä¸ªæ”»å‡»è€…ç»•è¿‡cgroupsçš„é™åˆ¶ã€‚cgroupsæ˜¯ä¸€ç§ç”¨äºé™åˆ¶ç¨‹åºåœ¨ç”µè„‘ä¸Šä½¿ç”¨çš„èµ„æºçš„æŠ€æœ¯ã€‚ç®€å•æ¥è¯´ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡è§¦å‘æ•°æ®åŒæ­¥ï¼Œè®©ç”µè„‘çš„æ•´ä½“æ€§èƒ½ä¸‹é™ã€‚è¿™å°±åƒæ˜¯åœ¨å…¬è·¯ä¸Šå¼€è½¦ï¼Œçªç„¶æœ‰äººæ‰“å¼€äº†æ‰€æœ‰çš„çº¢ç»¿ç¯ï¼Œå¯¼è‡´æ‰€æœ‰çš„è½¦è¾†éƒ½å¿…é¡»åœä¸‹æ¥ç­‰å¾…ã€‚ æ‡’æƒ°å›å†™çš„å…³é”®åœ¨äºåŒæ­¥ï¼ˆsyncï¼‰ã€‚åŒæ­¥æ˜¯ä¸€ä¸ªè¿‡ç¨‹ï¼Œå®ƒä¼šæŠŠç¼“å­˜é‡Œçš„æ•°æ®å†™å…¥ç£ç›˜ã€‚å½“ä¸€ä¸ªç¨‹åºè°ƒç”¨åŒæ­¥æ—¶ï¼Œå®ƒä¼šè®©ç”µè„‘æš‚åœå…¶ä»–æ“ä½œï¼Œç­‰å¾…æ•°æ®å†™å…¥ç£ç›˜ã€‚å¦‚æœä¸€ä¸ªæ”»å‡»è€…ä¸æ–­åœ°è°ƒç”¨åŒæ­¥ï¼Œé‚£ä¹ˆç”µè„‘çš„æ€§èƒ½å°±ä¼šå—åˆ°å½±å“ï¼Œå› ä¸ºå…¶ä»–ç¨‹åºéœ€è¦ä¸æ–­åœ°ç­‰å¾…åŒæ­¥å®Œæˆã€‚ ç°åœ¨æˆ‘ä»¬æ¥è°ˆè°ˆcgroupsã€‚cgroupsæ˜¯ä¸€ç§æŠ€æœ¯ï¼Œå¯ä»¥ç”¨æ¥é™åˆ¶ç¨‹åºä½¿ç”¨ç”µè„‘ä¸Šçš„èµ„æºï¼Œæ¯”å¦‚CPUã€å†…å­˜å’Œç£ç›˜ç­‰ã€‚ä½†æ˜¯ï¼Œåœ¨è¿™ä¸ªæ¡ˆä¾‹ä¸­ï¼Œæ”»å‡»è€…åˆ©ç”¨åŒæ­¥ç»•è¿‡äº†cgroupsçš„é™åˆ¶ã€‚åŸå› æ˜¯ï¼Œæ”»å‡»è€…è°ƒç”¨åŒæ­¥æ—¶ï¼Œå¹¶æ²¡æœ‰ç›´æ¥è¿›è¡Œç£ç›˜è¯»å†™æ“ä½œï¼Œè€Œæ˜¯è®©å†…æ ¸ï¼ˆç”µè„‘çš„æ ¸å¿ƒéƒ¨åˆ†ï¼‰è¿›è¡Œäº†è¿™äº›æ“ä½œã€‚å› æ­¤ï¼Œcgroupsæ— æ³•æ£€æµ‹åˆ°æ”»å‡»è€…çš„è¡Œä¸ºï¼Œä¹Ÿå°±æ— æ³•é™åˆ¶å®ƒã€‚ æ€»ä¹‹ï¼Œè¿™ä¸ªæ¡ˆä¾‹å‘æˆ‘ä»¬å±•ç¤ºäº†ä¸€ä¸ªæ”»å‡»è€…å¯ä»¥åˆ©ç”¨æ‡’æƒ°å›å†™çš„åŒæ­¥æœºåˆ¶æ¥ç»•è¿‡cgroupsçš„é™åˆ¶ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´ç”µè„‘çš„æ•´ä½“æ€§èƒ½ä¸‹é™ï¼Œç»™å…¶ä»–ç”¨æˆ·å¸¦æ¥éº»çƒ¦ã€‚","categories":[{"name":"è®ºæ–‡ç²¾è¯»","slug":"è®ºæ–‡ç²¾è¯»","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"å†…æ ¸å®‰å…¨","slug":"è®ºæ–‡ç²¾è¯»/å†…æ ¸å®‰å…¨","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"å†…æ ¸å®‰å…¨","slug":"å†…æ ¸å®‰å…¨","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}]},{"title":"C++å­¦ä¹  å‡½æ•°é«˜çº§","slug":"C++-å­¦ä¹ -å‡½æ•°é«˜çº§","date":"2023-04-15T00:36:52.000Z","updated":"2023-05-09T08:10:51.058Z","comments":true,"path":"2023/04/15/C++-å­¦ä¹ -å‡½æ•°é«˜çº§/","link":"","permalink":"http://example.com/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/","excerpt":"å‡½æ•°é»˜è®¤å‚æ•°åœ¨C++ä¸­ï¼Œå‡½æ•°å½¢å‚åˆ—è¡¨ä¸­çš„å½¢å‚æ˜¯å¯ä»¥æœ‰é»˜è®¤å€¼çš„ è¯­æ³•ï¼šè¿”å›å€¼ç±»å‹ å‡½æ•°å ï¼ˆå‚æ•° = é»˜è®¤å€¼ï¼‰","text":"å‡½æ•°é»˜è®¤å‚æ•°åœ¨C++ä¸­ï¼Œå‡½æ•°å½¢å‚åˆ—è¡¨ä¸­çš„å½¢å‚æ˜¯å¯ä»¥æœ‰é»˜è®¤å€¼çš„ è¯­æ³•ï¼šè¿”å›å€¼ç±»å‹ å‡½æ•°å ï¼ˆå‚æ•° = é»˜è®¤å€¼ï¼‰ 1234567891011#include &lt;iostream&gt;using namespace std;int func(int a, int b = 20, int c = 3)&#123; return a + b + c;&#125;int main()&#123; cout &lt;&lt; func(10) &lt;&lt; endl; cout &lt;&lt; func(10, 30) &lt;&lt; endl;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š 60 70 æ³¨æ„äº‹é¡¹ å¦‚æœæŸä¸ªä½ç½®å·²ç»æœ‰äº†é»˜è®¤å‚æ•°ï¼Œé‚£ä¹ˆä»è¿™ä¸ªä½ç½®å¾€åï¼Œä»å·¦åˆ°å³éƒ½å¿…é¡»æœ‰é»˜è®¤å€¼ å£°æ˜å’Œå®ç°åªèƒ½æœ‰ä¸€ä¸ªæœ‰é»˜è®¤å‚æ•° 12345678910#include &lt;iostream&gt;using namespace std;int func(int a = 10, int b = 10);int func(int a = 10, int b = 10) &#123; return a + b;&#125;int main()&#123; cout &lt;&lt; func() &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š å‡½æ•°å ä½å‚æ•°C++ä¸­å‡½æ•°çš„å½¢å‚åˆ—è¡¨é‡Œå¯ä»¥æœ‰å ä½å‚æ•°ï¼Œç”¨æ¥åšå ä½ï¼Œè°ƒç”¨å‚æ•°æ—¶å¿…é¡»å¡«è¡¥è¯¥ä½ç½® è¯­æ³•ï¼šè¿”å›å€¼ç±»å‹ å‡½æ•°å (æ•°æ®ç±»å‹)&#123;&#125; 1234567891011#include &lt;iostream&gt;using namespace std;void func(int a, int)&#123; cout &lt;&lt; 1 &lt;&lt; endl; return;&#125;int main()&#123; func(10, 10);&#125; æˆ–è€… 1234567891011#include &lt;iostream&gt;using namespace std;void func(int a, int = 10)&#123; cout &lt;&lt; 1 &lt;&lt; endl; return;&#125;int main()&#123; func(10);&#125; å‡½æ•°é‡è½½å‡½æ•°é‡è½½æ¦‚è¿°ä½œç”¨ï¼šå‡½æ•°åå¯ä»¥ç›¸åŒï¼Œæé«˜å¤ç”¨æ€§ å‡½æ•°é‡è½½æ»¡è¶³æ¡ä»¶ï¼š åŒä¸€ä¸ªä½œç”¨åŸŸä¸‹ å‡½æ•°åç§°ç›¸åŒ å‡½æ•°å‚æ•°ç±»å‹ä¸åŒæˆ–è€…ä¸ªæ•°ä¸åŒæˆ–è€…é¡ºåºä¸åŒ æ³¨æ„ï¼šå‡½æ•°çš„è¿”å›å€¼ä¸å¯ä»¥ä½œä¸ºå‡½æ•°é‡è½½çš„æ¡ä»¶ 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;void func()&#123; cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl; return;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl; return;&#125;void func(int a,int b)&#123; cout &lt;&lt; &quot;func(int a,int b)&quot; &lt;&lt; endl; return;&#125;void func(int a,double b)&#123; cout &lt;&lt; &quot;func(int a,double b)&quot; &lt;&lt; endl; return;&#125;void func(double a,int b)&#123; cout &lt;&lt; &quot;func(double a,int b)&quot; &lt;&lt; endl; return;&#125;int main()&#123; func(); func(1); func(1, 2); func(1, 3.1); func(3.1, 1);&#125; è¿è¡Œç»“æœä¸ºï¼š func()func(int a)func(int a,int b)func(int a,double b)func(double a,int b) å‡½æ•°é‡è½½æ³¨æ„äº‹é¡¹ å¼•ç”¨ä½œä¸ºå‡½æ•°é‡è½½æ¡ä»¶ 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void func(int &amp;a)&#123; cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl; return;&#125;void func(const int &amp;a)&#123; cout &lt;&lt; &quot;func(const int &amp;a)&quot; &lt;&lt; endl; return;&#125;int main()&#123; int a = 10; func(a); func(10);&#125; è¿è¡Œç»“æœä¸ºï¼š func(int &amp;a)func(const int &amp;a) å‡½æ•°é‡è½½ç¢°åˆ°é»˜è®¤å‚æ•° 12345678910111213141516#include &lt;iostream&gt;using namespace std;void func(int a, int b = 10)&#123; cout &lt;&lt; &quot;func(int a, int b = 10)&quot; &lt;&lt; endl;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl;&#125;int main()&#123; func(10);&#125; è¿è¡Œç»“æœä¸ºï¼š","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture05 Calling conventions and stack frames RISC-V(TA)","slug":"MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA","date":"2023-04-14T07:14:27.000Z","updated":"2023-04-20T06:13:23.446Z","comments":true,"path":"2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/","link":"","permalink":"http://example.com/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/","excerpt":"Cç¨‹åºåˆ°æ±‡ç¼–ç¨‹åºçš„è½¬æ¢å½“æˆ‘ä»¬è¯´åˆ°ä¸€ä¸ªRISC-Vå¤„ç†å™¨æ—¶ï¼Œæ„å‘³ç€è¿™ä¸ªå¤„ç†å™¨èƒ½å¤Ÿç†è§£RISC-Vçš„æŒ‡ä»¤é›†ã€‚æ‰€ä»¥ï¼Œä»»ä½•ä¸€ä¸ªå¤„ç†å™¨éƒ½æœ‰ä¸€ä¸ªå…³è”çš„ISAï¼ˆInstruction Sets Architectureï¼‰ï¼ŒISAå°±æ˜¯å¤„ç†å™¨èƒ½å¤Ÿç†è§£çš„æŒ‡ä»¤é›†ã€‚æ¯ä¸€æ¡æŒ‡ä»¤éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„äºŒè¿›åˆ¶ç¼–ç æˆ–è€…ä¸€ä¸ªOpcodeã€‚å½“å¤„ç†å™¨åœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœçœ‹è§äº†è¿™äº›ç¼–ç ï¼Œé‚£ä¹ˆå¤„ç†å™¨å°±çŸ¥é“è¯¥åšä»€ä¹ˆæ ·çš„æ“ä½œã€‚ æ‰€ä»¥é€šå¸¸æ¥è¯´ï¼Œè¦è®©Cè¯­è¨€èƒ½å¤Ÿè¿è¡Œåœ¨ä½ çš„å¤„ç†å™¨ä¹‹ä¸Šã€‚æˆ‘ä»¬é¦–å…ˆè¦å†™å‡ºCç¨‹åºï¼Œä¹‹åè¿™ä¸ªCç¨‹åºéœ€è¦è¢«ç¼–è¯‘æˆæ±‡ç¼–è¯­è¨€ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸­æœ‰ä¸€äº›é“¾æ¥å’Œå…¶ä»–çš„æ­¥éª¤ï¼Œä½†æ˜¯å› ä¸ºè¿™é—¨è¯¾ä¸æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨çš„è¯¾ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿½ç•¥è¿™äº›æ­¥éª¤ã€‚ä¹‹åæ±‡ç¼–è¯­è¨€ä¼šè¢«ç¿»è¯‘æˆäºŒè¿›åˆ¶æ–‡ä»¶ä¹Ÿå°±æ˜¯.objæˆ–è€….oæ–‡ä»¶ã€‚","text":"Cç¨‹åºåˆ°æ±‡ç¼–ç¨‹åºçš„è½¬æ¢å½“æˆ‘ä»¬è¯´åˆ°ä¸€ä¸ªRISC-Vå¤„ç†å™¨æ—¶ï¼Œæ„å‘³ç€è¿™ä¸ªå¤„ç†å™¨èƒ½å¤Ÿç†è§£RISC-Vçš„æŒ‡ä»¤é›†ã€‚æ‰€ä»¥ï¼Œä»»ä½•ä¸€ä¸ªå¤„ç†å™¨éƒ½æœ‰ä¸€ä¸ªå…³è”çš„ISAï¼ˆInstruction Sets Architectureï¼‰ï¼ŒISAå°±æ˜¯å¤„ç†å™¨èƒ½å¤Ÿç†è§£çš„æŒ‡ä»¤é›†ã€‚æ¯ä¸€æ¡æŒ‡ä»¤éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„äºŒè¿›åˆ¶ç¼–ç æˆ–è€…ä¸€ä¸ªOpcodeã€‚å½“å¤„ç†å™¨åœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœçœ‹è§äº†è¿™äº›ç¼–ç ï¼Œé‚£ä¹ˆå¤„ç†å™¨å°±çŸ¥é“è¯¥åšä»€ä¹ˆæ ·çš„æ“ä½œã€‚ æ‰€ä»¥é€šå¸¸æ¥è¯´ï¼Œè¦è®©Cè¯­è¨€èƒ½å¤Ÿè¿è¡Œåœ¨ä½ çš„å¤„ç†å™¨ä¹‹ä¸Šã€‚æˆ‘ä»¬é¦–å…ˆè¦å†™å‡ºCç¨‹åºï¼Œä¹‹åè¿™ä¸ªCç¨‹åºéœ€è¦è¢«ç¼–è¯‘æˆæ±‡ç¼–è¯­è¨€ã€‚è¿™ä¸ªè¿‡ç¨‹ä¸­æœ‰ä¸€äº›é“¾æ¥å’Œå…¶ä»–çš„æ­¥éª¤ï¼Œä½†æ˜¯å› ä¸ºè¿™é—¨è¯¾ä¸æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨çš„è¯¾ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¿½ç•¥è¿™äº›æ­¥éª¤ã€‚ä¹‹åæ±‡ç¼–è¯­è¨€ä¼šè¢«ç¿»è¯‘æˆäºŒè¿›åˆ¶æ–‡ä»¶ä¹Ÿå°±æ˜¯.objæˆ–è€….oæ–‡ä»¶ã€‚ å¦‚æœä½ ä»¬æ›¾ç»æ³¨æ„è¿‡ä½ ä»¬çš„labç›®å½•ï¼Œåœ¨è¿è¡Œå®Œmake qemuä¹‹åä½ ä¼šçœ‹åˆ°ä¸€äº›.oæ–‡ä»¶ï¼Œè¿™äº›å°±æ˜¯å¤„ç†å™¨èƒ½å¤Ÿç†è§£çš„æ–‡ä»¶ã€‚è™½ç„¶ä½ è¿˜æ²¡æœ‰å†™ä»»ä½•æ±‡ç¼–ç¨‹åºï¼Œä½ ä»¬ä¹Ÿå¯ä»¥åœ¨ç›®å½•ä¸­çœ‹åˆ°ä¸€äº›.asmæ–‡ä»¶ï¼Œè¿™æ˜¯ç”±Cè¯­è¨€ç¼–è¯‘ç”Ÿæˆçš„ã€‚ æ±‡ç¼–è¯­è¨€ä¸å…·å¤‡Cè¯­è¨€çš„ç»„ç»‡ç»“æ„ï¼Œåœ¨æ±‡ç¼–è¯­è¨€ä¸­ä½ åªèƒ½çœ‹åˆ°ä¸€è¡Œè¡Œçš„æŒ‡ä»¤ï¼Œæ¯”å¦‚addï¼Œmultç­‰ç­‰ã€‚æ±‡ç¼–è¯­è¨€ä¸­æ²¡æœ‰å¾ˆå¥½çš„æ§åˆ¶æµç¨‹ï¼Œæ²¡æœ‰å¾ªç¯ï¼ˆæ³¨ï¼Œä½†æ˜¯æœ‰åŸºäºlableçš„è·³è½¬ï¼‰ï¼Œè™½ç„¶æœ‰å‡½æ•°ä½†æ˜¯ä¸ä½ ä»¬çŸ¥é“çš„Cè¯­è¨€å‡½æ•°ä¸å¤ªä¸€æ ·ï¼Œæ±‡ç¼–è¯­è¨€ä¸­çš„å‡½æ•°æ˜¯ä»¥labelçš„å½¢å¼å­˜åœ¨è€Œä¸æ˜¯çœŸæ­£çš„å‡½æ•°å®šä¹‰ã€‚æ±‡ç¼–è¯­è¨€æ˜¯ä¸€é—¨éå¸¸åº•å±‚çš„è¯­è¨€ï¼Œè®¸å¤šå…¶ä»–è¯­è¨€ï¼Œæ¯”å¦‚C++ï¼Œéƒ½ä¼šç¼–è¯‘æˆæ±‡ç¼–è¯­è¨€ã€‚è¿è¡Œä»»ä½•ç¼–è¯‘å‹è¯­è¨€ä¹‹å‰éƒ½éœ€è¦å…ˆç”Ÿæˆæ±‡ç¼–è¯­è¨€ã€‚ ä»¥ä¸Šå°±æ˜¯è®©è®¡ç®—æœºèƒ½å¤Ÿç†è§£æˆ‘ä»¬çš„Cä»£ç çš„åŸºæœ¬æµç¨‹ã€‚ RISC-V vs X86RISC-Vå’Œx86å¹¶æ²¡æœ‰å®ƒä»¬ç¬¬ä¸€çœ¼çœ‹èµ·æ¥é‚£ä¹ˆç›¸ä¼¼ã€‚RISC-Vä¸­çš„RISCæ˜¯ç²¾ç®€æŒ‡ä»¤é›†ï¼ˆReduced Instruction Set Computerï¼‰çš„æ„æ€ï¼Œè€Œx86é€šå¸¸è¢«ç§°ä¸ºCISCï¼Œå¤æ‚æŒ‡ä»¤é›†ï¼ˆComplex Instruction Set Computerï¼‰ã€‚è¿™ä¸¤è€…ä¹‹é—´æœ‰ä¸€äº›å…³é”®çš„åŒºåˆ«ï¼š é¦–å…ˆæ˜¯æŒ‡ä»¤çš„æ•°é‡ã€‚å®é™…ä¸Šï¼Œåˆ›é€ RISC-Vçš„ä¸€ä¸ªéå¸¸å¤§çš„åˆè¡·å°±æ˜¯å› ä¸ºIntelæ‰‹å†Œä¸­æŒ‡ä»¤æ•°é‡å¤ªå¤šäº†ã€‚x86-64æŒ‡ä»¤ä»‹ç»ç”±3ä¸ªæ–‡æ¡£ç»„æˆï¼Œå¹¶ä¸”æ–°çš„æŒ‡ä»¤ä»¥æ¯ä¸ªæœˆ3æ¡çš„é€Ÿåº¦åœ¨å¢åŠ ã€‚å› ä¸ºx86-64æ˜¯åœ¨1970å¹´ä»£å‘å¸ƒçš„ï¼Œæ‰€ä»¥æˆ‘è®¤ä¸ºç°åœ¨æœ‰å¤šäº15000æ¡æŒ‡ä»¤ã€‚RISC-VæŒ‡ä»¤ä»‹ç»ç”±ä¸¤ä¸ªæ–‡æ¡£ç»„æˆã€‚åœ¨è¿™èŠ‚è¯¾ä¸­ï¼Œä¸éœ€è¦ä½ ä»¬è®°ä½æ¯ä¸€ä¸ªRISC-VæŒ‡ä»¤ï¼Œä½†æ˜¯å¦‚æœä½ æ„Ÿå…´è¶£æˆ–è€…ä½ å‘ç°ä½ ä¸èƒ½ç†è§£æŸä¸ªå…·ä½“çš„æŒ‡ä»¤çš„è¯ï¼Œåœ¨è¯¾ç¨‹ç½‘ç«™çš„å‚è€ƒé¡µé¢æœ‰RISC-VæŒ‡ä»¤çš„ä¸¤ä¸ªæ–‡æ¡£é“¾æ¥ã€‚è¿™ä¸¤ä¸ªæ–‡æ¡£åŒ…å«äº†RISC-Vçš„æŒ‡ä»¤é›†çš„æ‰€æœ‰ä¿¡æ¯ï¼Œåˆ†åˆ«æ˜¯240é¡µå’Œ135é¡µï¼Œç›¸æ¯”x86çš„æŒ‡ä»¤é›†æ–‡æ¡£è¦å°å¾—å¤šçš„å¤šã€‚è¿™æ˜¯æœ‰å…³RISC-Væ¯”è¾ƒå¥½çš„ä¸€ä¸ªæ–¹é¢ã€‚æ‰€ä»¥åœ¨RISC-Vä¸­ï¼Œæˆ‘ä»¬æœ‰æ›´å°‘çš„æŒ‡ä»¤æ•°é‡ã€‚ é™¤æ­¤ä¹‹å¤–ï¼ŒRISC-VæŒ‡ä»¤ä¹Ÿæ›´åŠ ç®€å•ã€‚åœ¨x86-64ä¸­ï¼Œå¾ˆå¤šæŒ‡ä»¤éƒ½åšäº†ä¸æ­¢ä¸€ä»¶äº‹æƒ…ã€‚è¿™äº›æŒ‡ä»¤ä¸­çš„æ¯ä¸€æ¡éƒ½æ‰§è¡Œäº†ä¸€ç³»åˆ—å¤æ‚çš„æ“ä½œå¹¶è¿”å›ç»“æœã€‚ä½†æ˜¯RISC-Vä¸ä¼šè¿™æ ·åšï¼ŒRISC-Vçš„æŒ‡ä»¤è¶‹å‘äºå®Œæˆæ›´ç®€å•çš„å·¥ä½œï¼Œç›¸åº”çš„ä¹Ÿæ¶ˆè€—æ›´å°‘çš„CPUæ‰§è¡Œæ—¶é—´ã€‚è¿™å…¶å®æ˜¯è®¾è®¡äººå‘˜çš„åœ¨åº•å±‚è®¾è®¡æ—¶çš„å–èˆã€‚å¹¶æ²¡æœ‰ä¸€äº›éå¸¸ç¡®å®šçš„åŸå› è¯´RISCæ¯”CISCæ›´å¥½ã€‚å®ƒä»¬å„è‡ªæœ‰å„è‡ªçš„ä½¿ç”¨åœºæ™¯ã€‚ ç›¸æ¯”x86æ¥è¯´ï¼ŒRISCå¦ä¸€ä»¶æœ‰æ„æ€çš„äº‹æƒ…æ˜¯å®ƒæ˜¯å¼€æºçš„ã€‚è¿™æ˜¯å¸‚åœºä¸Šå”¯ä¸€çš„ä¸€æ¬¾å¼€æºæŒ‡ä»¤é›†ï¼Œè¿™æ„å‘³ç€ä»»ä½•äººéƒ½å¯ä»¥ä¸ºRISC-Vå¼€å‘ä¸»æ¿ã€‚RISC-Væ˜¯æ¥è‡ªäºUC-Berklyçš„ä¸€ä¸ªç ”ç©¶é¡¹ç›®ï¼Œä¹‹åè¢«å¤§é‡çš„å…¬å¸é€‰ä¸­å¹¶åšäº†æ”¯æŒï¼Œç½‘ä¸Šæœ‰è¿™äº›å…¬å¸çš„åå•ï¼Œè®¸å¤šå¤§å…¬å¸å¯¹äºæ”¯æŒä¸€ä¸ªå¼€æºæŒ‡ä»¤é›†éƒ½æ„Ÿå…´è¶£ã€‚ æ¯”å¦‚è¯´ARMä¹Ÿæ˜¯ä¸€ä¸ªç²¾ç®€æŒ‡ä»¤é›†ï¼Œé«˜é€šçš„Snapdragonå¤„ç†å™¨å°±æ˜¯åŸºäºARMã€‚å¦‚æœä½ ä½¿ç”¨ä¸€ä¸ªAndroidæ‰‹æœºï¼Œé‚£ä¹ˆå¤§æ¦‚ç‡ä½ çš„æ‰‹æœºè¿è¡Œåœ¨ç²¾ç®€æŒ‡ä»¤é›†ä¸Šã€‚å¦‚æœä½ ä½¿ç”¨IOSï¼Œè‹¹æœå…¬å¸ä¹Ÿå®ç°æŸç§ç‰ˆæœ¬çš„ARMå¤„ç†å™¨ï¼Œè¿™äº›å¤„ç†å™¨è¿è¡Œåœ¨iPadï¼ŒiPhoneå’Œå¤§å¤šæ•°è‹¹æœç§»åŠ¨è®¾å¤‡ä¸Šï¼Œç”šè‡³å¯¹äºMacï¼Œè‹¹æœå…¬å¸ä¹Ÿåœ¨å°è¯•å‘ARMåšè¿ç§»ï¼ˆæ³¨ï¼Œåˆšåˆšå‘å¸ƒçš„Macbookï¼‰ã€‚æ‰€ä»¥ç²¾ç®€æŒ‡ä»¤é›†å‡ºç°åœ¨å„ç§å„æ ·çš„åœ°æ–¹ã€‚å¦‚æœä½ æƒ³åœ¨ç°å®ä¸–ç•Œä¸­æ‰¾åˆ°RISC-Vå¤„ç†å™¨ï¼Œä½ å¯ä»¥åœ¨ä¸€äº›åµŒå…¥å¼è®¾å¤‡ä¸­æ‰¾åˆ°ã€‚æ‰€ä»¥RISC-Vä¹Ÿæ˜¯æœ‰åº”ç”¨çš„ï¼Œå½“ç„¶å®ƒå¯èƒ½æ²¡æœ‰x86é‚£ä¹ˆæµè¡Œã€‚ åœ¨æœ€è¿‘å‡ å¹´ï¼Œç”±äºIntelçš„æŒ‡ä»¤é›†æ˜¯åœ¨æ˜¯å¤ªå¤§äº†ï¼Œç²¾ç®€æŒ‡ä»¤é›†çš„ä½¿ç”¨è¶Šæ¥è¶Šå¤šã€‚Intelçš„æŒ‡ä»¤é›†ä¹‹æ‰€ä»¥è¿™ä¹ˆå¤§ï¼Œæ˜¯å› ä¸ºIntelå¯¹äºå‘åå…¼å®¹éå¸¸çœ‹é‡ã€‚æ‰€ä»¥ä¸€ä¸ªç°ä»£çš„Intelå¤„ç†å™¨è¿˜å¯ä»¥è¿è¡Œ30&#x2F;40å¹´å‰çš„æŒ‡ä»¤ã€‚Intelå¹¶æ²¡æœ‰ä¸‹çº¿ä»»ä½•æŒ‡ä»¤ã€‚è€ŒRISC-Væå‡ºçš„æ›´æ™šï¼Œæ‰€ä»¥ä¸å­˜åœ¨å†å²åŒ…è¢±çš„é—®é¢˜ã€‚æˆ‘ä»¬éœ€è¦è®¸å¤šæŒ‡ä»¤æ¥å®ç°å‘åå…¼å®¹ï¼Œå‘åå…¼å®¹æ˜¯å¦é‡è¦å› äººè€Œå¼‚ã€‚å¦ä¸€æ–¹é¢ï¼Œæˆ‘è®¤ä¸ºè¿™é‡Œè®¸å¤šæŒ‡ä»¤éƒ½æ˜¯cmdæŒ‡ä»¤ï¼Œç”¨æ¥å®Œæˆä¸€äº›ç‰¹æ®Šçš„æ“ä½œã€‚æˆ‘ä»æ¥æ²¡æœ‰è§è¿‡ä¸€ä¸ªIntelçš„æ±‡ç¼–ä»£ç ä½¿ç”¨äº†æ‰€æœ‰çš„15000ä¸ªæŒ‡ä»¤ã€‚å¤§å¤šæ•°è¿™äº›æŒ‡ä»¤éƒ½æ˜¯ä¸ºäº†å‘åå…¼å®¹å’Œcmdçš„éœ€æ±‚åˆ›å»ºã€‚ å¦‚æœæŸ¥çœ‹RISC-Vçš„æ–‡æ¡£ï¼Œå¯ä»¥å‘ç°RISC-Vçš„ç‰¹æ®Šä¹‹å¤„åœ¨äºï¼šå®ƒåŒºåˆ†äº†Base Integer Instruction Setå’ŒStandard Extension Instruction Setã€‚Base Integer Instruction SetåŒ…å«äº†æ‰€æœ‰çš„å¸¸ç”¨æŒ‡ä»¤ï¼Œæ¯”å¦‚addï¼Œmultã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå¤„ç†å™¨è¿˜å¯ä»¥é€‰æ‹©æ€§çš„æ”¯æŒStandard Extension Instruction Setã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªå¤„ç†å™¨å¯ä»¥é€‰æ‹©æ”¯æŒStandard Extension for Single-Precision Float-Pointã€‚è¿™ç§æ¨¡å¼ä½¿å¾—RISC-Væ›´å®¹æ˜“æ”¯æŒå‘åå…¼å®¹ã€‚ æ¯ä¸€ä¸ªRISC-Vå¤„ç†å™¨å¯ä»¥å£°æ˜æ”¯æŒäº†å“ªäº›æ‰©å±•æŒ‡ä»¤é›†ï¼Œç„¶åç¼–è¯‘å™¨å¯ä»¥æ ¹æ®æ”¯æŒçš„æŒ‡ä»¤é›†æ¥ç¼–è¯‘ä»£ç ã€‚ gdbå’Œæ±‡ç¼–ä»£ç æ‰§è¡Œè¿™éƒ¨åˆ†è¿˜ä¸å¤ªä¼šæ“ä½œ RISC-Vå¯„å­˜å™¨ è¿™ä¸ªè¡¨é‡Œé¢æ˜¯RISC-Vå¯„å­˜å™¨ã€‚å¯„å­˜å™¨æ˜¯CPUæˆ–è€…å¤„ç†å™¨ä¸Šï¼Œé¢„å…ˆå®šä¹‰çš„å¯ä»¥ç”¨æ¥å­˜å‚¨æ•°æ®çš„ä½ç½®ã€‚å¯„å­˜å™¨ä¹‹æ‰€ä»¥é‡è¦æ˜¯å› ä¸ºæ±‡ç¼–ä»£ç å¹¶ä¸æ˜¯åœ¨å†…å­˜ä¸Šæ‰§è¡Œï¼Œè€Œæ˜¯åœ¨å¯„å­˜å™¨ä¸Šæ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“æˆ‘ä»¬åœ¨åšaddï¼Œsubæ—¶ï¼Œæˆ‘ä»¬æ˜¯å¯¹å¯„å­˜å™¨è¿›è¡Œæ“ä½œã€‚æ‰€ä»¥æˆ‘ä»¬é€šå¸¸çœ‹åˆ°çš„æ±‡ç¼–ä»£ç ä¸­çš„æ¨¡å¼æ˜¯ï¼Œæˆ‘ä»¬é€šè¿‡loadå°†æ•°æ®å­˜æ”¾åœ¨å¯„å­˜å™¨ä¸­ï¼Œè¿™é‡Œçš„æ•°æ®æºå¯ä»¥æ˜¯æ¥è‡ªå†…å­˜ï¼Œä¹Ÿå¯ä»¥æ¥è‡ªå¦ä¸€ä¸ªå¯„å­˜å™¨ã€‚ä¹‹åæˆ‘ä»¬åœ¨å¯„å­˜å™¨ä¸Šæ‰§è¡Œä¸€äº›æ“ä½œã€‚å¦‚æœæˆ‘ä»¬å¯¹æ“ä½œçš„ç»“æœå…³å¿ƒçš„è¯ï¼Œæˆ‘ä»¬ä¼šå°†æ“ä½œçš„ç»“æœstoreåœ¨æŸä¸ªåœ°æ–¹ã€‚è¿™é‡Œçš„ç›®çš„åœ°å¯èƒ½æ˜¯å†…å­˜ä¸­çš„æŸä¸ªåœ°å€ï¼Œä¹Ÿå¯èƒ½æ˜¯å¦ä¸€ä¸ªå¯„å­˜å™¨ã€‚è¿™å°±æ˜¯é€šå¸¸ä½¿ç”¨å¯„å­˜å™¨çš„æ–¹æ³•ã€‚ å¯„å­˜å™¨è¿›è¡Œä»»ä½•è¿ç®—å’Œæ•°æ®è¯»å–çš„æœ€å¿«çš„æ–¹å¼ã€‚å½“è°ƒç”¨å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬è°ƒç”¨å‡½æ•°æ—¶ï¼Œæˆ‘ä»¬ä¼šç”¨ABIåå­—ã€‚ a0åˆ°a7å¯„å­˜å™¨æ˜¯ç”¨æ¥ä½œä¸ºå‡½æ•°çš„å‚æ•°ã€‚å¦‚æœä¸€ä¸ªå‡½æ•°æœ‰è¶…è¿‡8ä¸ªå‚æ•°ï¼Œæˆ‘ä»¬å°±éœ€è¦ç”¨å†…å­˜äº†ã€‚ä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œå½“å¯ä»¥ä½¿ç”¨å¯„å­˜å™¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸ä¼šä½¿ç”¨å†…å­˜ï¼Œæˆ‘ä»¬åªåœ¨ä¸å¾—ä¸ä½¿ç”¨å†…å­˜çš„åœºæ™¯æ‰ä½¿ç”¨å®ƒã€‚ è¡¨å•ä¸­çš„ç¬¬4åˆ—ï¼ŒSaveråˆ—ï¼Œå½“æˆ‘ä»¬åœ¨è®¨è®ºå¯„å­˜å™¨çš„æ—¶å€™ä¹Ÿéå¸¸é‡è¦ã€‚å®ƒæœ‰ä¸¤ä¸ªå¯èƒ½çš„å€¼Callerï¼ŒCalleeã€‚ Caller Savedå¯„å­˜å™¨åœ¨å‡½æ•°è°ƒç”¨çš„æ—¶å€™ä¸ä¼šä¿å­˜ Callee Savedå¯„å­˜å™¨åœ¨å‡½æ•°è°ƒç”¨çš„æ—¶å€™ä¼šä¿å­˜ è¿™é‡Œçš„æ„æ€æ˜¯ï¼Œä¸€ä¸ªCaller Savedå¯„å­˜å™¨å¯èƒ½è¢«å…¶ä»–å‡½æ•°é‡å†™ã€‚å‡è®¾æˆ‘ä»¬åœ¨å‡½æ•°aä¸­è°ƒç”¨å‡½æ•°bï¼Œä»»ä½•è¢«å‡½æ•°aä½¿ç”¨çš„å¹¶ä¸”æ˜¯Caller Savedå¯„å­˜å™¨ï¼Œè°ƒç”¨å‡½æ•°bå¯èƒ½é‡å†™è¿™äº›å¯„å­˜å™¨ã€‚æˆ‘è®¤ä¸ºä¸€ä¸ªæ¯”è¾ƒå¥½çš„ä¾‹å­å°±æ˜¯Return addresså¯„å­˜å™¨ï¼ˆæ³¨ï¼Œä¿å­˜çš„æ˜¯å‡½æ•°è¿”å›çš„åœ°å€ï¼‰ï¼Œä½ å¯ä»¥çœ‹åˆ°raå¯„å­˜å™¨æ˜¯Caller Savedï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ï¼Œå®ƒå¯¼è‡´äº†å½“å‡½æ•°aè°ƒç”¨å‡½æ•°bçš„æ—¶ä¾¯ï¼Œbä¼šé‡å†™Return addressã€‚æ‰€ä»¥åŸºæœ¬ä¸Šæ¥è¯´ï¼Œä»»ä½•ä¸€ä¸ªCaller Savedå¯„å­˜å™¨ï¼Œä½œä¸ºè°ƒç”¨æ–¹çš„å‡½æ•°è¦å°å¿ƒå¯èƒ½çš„æ•°æ®å¯èƒ½çš„å˜åŒ–ï¼›ä»»ä½•ä¸€ä¸ªCallee Savedå¯„å­˜å™¨ï¼Œä½œä¸ºè¢«è°ƒç”¨æ–¹çš„å‡½æ•°è¦å°å¿ƒå¯„å­˜å™¨çš„å€¼ä¸ä¼šç›¸åº”çš„å˜åŒ–ã€‚ Stackæ¯ä¸€æ¬¡æˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°éƒ½ä¼šä¸ºè‡ªå·±åˆ›å»ºä¸€ä¸ªStack Frameï¼Œå¹¶ä¸”åªç»™è‡ªå·±ç”¨ã€‚å‡½æ•°é€šè¿‡ç§»åŠ¨Stack Pointeræ¥å®ŒæˆStack Frameçš„ç©ºé—´åˆ†é…ã€‚ å¯¹äºStackæ¥è¯´ï¼Œæ˜¯ä»é«˜åœ°å€å¼€å§‹å‘ä½åœ°å€ä½¿ç”¨ã€‚æ‰€ä»¥æ ˆæ€»æ˜¯å‘ä¸‹å¢é•¿ã€‚å½“æˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°çš„Stack Frameçš„æ—¶å€™ï¼Œæ€»æ˜¯å¯¹å½“å‰çš„Stack Pointeråšå‡æ³•ã€‚ä¸€ä¸ªå‡½æ•°çš„Stack FrameåŒ…å«äº†ä¿å­˜çš„å¯„å­˜å™¨ï¼Œæœ¬åœ°å˜é‡ï¼Œå¹¶ä¸”ï¼Œå¦‚æœå‡½æ•°çš„å‚æ•°å¤šäº8ä¸ªï¼Œé¢å¤–çš„å‚æ•°ä¼šå‡ºç°åœ¨Stackä¸­ã€‚æ‰€ä»¥Stack Frameå¤§å°å¹¶ä¸æ€»æ˜¯ä¸€æ ·ï¼Œå³ä½¿åœ¨è¿™ä¸ªå›¾é‡Œé¢çœ‹èµ·æ¥æ˜¯ä¸€æ ·å¤§çš„ã€‚ä¸åŒçš„å‡½æ•°æœ‰ä¸åŒæ•°é‡çš„æœ¬åœ°å˜é‡ï¼Œä¸åŒçš„å¯„å­˜å™¨ï¼Œæ‰€ä»¥Stack Frameçš„å¤§å°æ˜¯ä¸ä¸€æ ·çš„ã€‚ä½†æ˜¯æœ‰å…³Stack Frameæœ‰ä¸¤ä»¶äº‹æƒ…æ˜¯ç¡®å®šçš„ï¼š Return addressæ€»æ˜¯ä¼šå‡ºç°åœ¨Stack Frameçš„ç¬¬ä¸€ä½ æŒ‡å‘å‰ä¸€ä¸ªStack Frameçš„æŒ‡é’ˆä¹Ÿä¼šå‡ºç°åœ¨æ ˆä¸­çš„å›ºå®šä½ç½® æœ‰å…³Stack Frameä¸­æœ‰ä¸¤ä¸ªé‡è¦çš„å¯„å­˜å™¨ï¼Œç¬¬ä¸€ä¸ªæ˜¯SPï¼ˆStack Pointerï¼‰ï¼Œå®ƒæŒ‡å‘Stackçš„åº•éƒ¨å¹¶ä»£è¡¨äº†å½“å‰Stack Frameçš„ä½ç½®ã€‚ç¬¬äºŒä¸ªæ˜¯FPï¼ˆFrame Pointerï¼‰ï¼Œå®ƒæŒ‡å‘å½“å‰Stack Frameçš„é¡¶éƒ¨ã€‚å› ä¸ºReturn addresså’ŒæŒ‡å‘å‰ä¸€ä¸ªStack Frameçš„çš„æŒ‡é’ˆéƒ½åœ¨å½“å‰Stack Frameçš„å›ºå®šä½ç½®ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡å½“å‰çš„FPå¯„å­˜å™¨å¯»å€åˆ°è¿™ä¸¤ä¸ªæ•°æ®ã€‚ æˆ‘ä»¬ä¿å­˜å‰ä¸€ä¸ªStack Frameçš„æŒ‡é’ˆçš„åŸå› æ˜¯ä¸ºäº†è®©æˆ‘ä»¬èƒ½è·³è½¬å›å»ã€‚æ‰€ä»¥å½“å‰å‡½æ•°è¿”å›æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å°†å‰ä¸€ä¸ªFrame Pointerå­˜å‚¨åˆ°FPå¯„å­˜å™¨ä¸­ã€‚æ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨Frame Pointeræ¥æ“çºµæˆ‘ä»¬çš„Stack Framesï¼Œå¹¶ç¡®ä¿æˆ‘ä»¬æ€»æ˜¯æŒ‡å‘æ­£ç¡®çš„å‡½æ•°ã€‚ Stack Frameå¿…é¡»è¦è¢«æ±‡ç¼–ä»£ç åˆ›å»ºï¼Œæ‰€ä»¥æ˜¯ç¼–è¯‘å™¨ç”Ÿæˆäº†æ±‡ç¼–ä»£ç ï¼Œè¿›è€Œåˆ›å»ºäº†Stack Frameã€‚æ‰€ä»¥é€šå¸¸ï¼Œåœ¨æ±‡ç¼–ä»£ç ä¸­ï¼Œå‡½æ•°çš„æœ€å¼€å§‹ä½ ä»¬å¯ä»¥çœ‹åˆ°Function prologueï¼Œä¹‹åæ˜¯å‡½æ•°çš„æœ¬ä½“ï¼Œæœ€åæ˜¯Epollgueã€‚ structåŸºæœ¬ä¸Šæ¥è¯´ï¼Œstructåœ¨å†…å­˜ä¸­æ˜¯ä¸€æ®µè¿ç»­çš„åœ°å€ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªstructï¼Œå¹¶ä¸”æœ‰f1ï¼Œf2ï¼Œf3ä¸‰ä¸ªå­—æ®µã€‚å½“æˆ‘ä»¬åˆ›å»ºè¿™æ ·ä¸€ä¸ªstructæ—¶ï¼Œå†…å­˜ä¸­ç›¸åº”çš„å­—æ®µä¼šå½¼æ­¤ç›¸é‚»ã€‚ä½ å¯ä»¥è®¤ä¸ºstructåƒæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œä½†æ˜¯é‡Œé¢çš„ä¸åŒå­—æ®µçš„ç±»å‹å¯ä»¥ä¸ä¸€æ ·ã€‚","categories":[{"name":"è¯¾ç¨‹å­¦ä¹ ","slug":"è¯¾ç¨‹å­¦ä¹ ","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"è¯¾ç¨‹å­¦ä¹ /MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++å­¦ä¹  å¼•ç”¨","slug":"C++-å­¦ä¹ -å¼•ç”¨","date":"2023-04-14T01:25:57.000Z","updated":"2023-05-09T08:11:40.399Z","comments":true,"path":"2023/04/14/C++-å­¦ä¹ -å¼•ç”¨/","link":"","permalink":"http://example.com/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/","excerpt":"å¼•ç”¨çš„åŸºæœ¬ä½¿ç”¨ä½œç”¨ï¼šç»™å˜é‡èµ·åˆ«å è¯­æ³•ï¼šæ•°æ®ç±»å‹ &amp;åˆ«å &#x3D; åŸå","text":"å¼•ç”¨çš„åŸºæœ¬ä½¿ç”¨ä½œç”¨ï¼šç»™å˜é‡èµ·åˆ«å è¯­æ³•ï¼šæ•°æ®ç±»å‹ &amp;åˆ«å &#x3D; åŸå 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int&amp; b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š a &#x3D; 10b &#x3D; 10a &#x3D; 100b &#x3D; 100 å¼•ç”¨çš„æ³¨æ„äº‹é¡¹ å¼•ç”¨å¿…é¡»åˆå§‹åŒ– å¼•ç”¨åœ¨åˆå§‹åŒ–åï¼Œä¸å¯ä»¥æ”¹å˜ 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int&amp; b = a; int c = 20; b = c; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š a &#x3D; 20b &#x3D; 20c &#x3D; 20 å¼•ç”¨åšå‡½æ•°å‚æ•°ä½œç”¨ï¼šå‡½æ•°ä¼ å‚æ—¶ï¼Œå¯ä»¥åˆ©ç”¨å¼•ç”¨çš„æŠ€æœ¯è®©å½¢å‚ä¿®é¥°å®å‚ ä¼˜ç‚¹ï¼šå¯ä»¥ç®€åŒ–æŒ‡é’ˆä¿®æ”¹å®å‚ 123456789101112131415161718#include &lt;iostream&gt;using namespace std;void swap(int&amp; a, int&amp; b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; &quot;swap a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š swap a &#x3D; 20swap b &#x3D; 10a &#x3D; 20b &#x3D; 10 å¼•ç”¨ä¼ é€’ï¼Œå½¢å‚ä¼šä¿®é¥°å®å‚ åœ°å€ä¼ é€’ï¼Œå½¢å‚ä¼šä¿®é¥°å®å‚ å€¼ä¼ é€’ï¼Œå½¢å‚ä¸ä¼šä¿®é¥°å®å‚ å¼•ç”¨åšå‡½æ•°è¿”å›å€¼ä½œç”¨ï¼šå¼•ç”¨æ˜¯å¯ä»¥ä½œä¸ºå‡½æ•°çš„è¿”å›å€¼å­˜åœ¨çš„ æ³¨æ„ï¼šä¸è¦è¿”å›å±€éƒ¨å˜é‡å¼•ç”¨ ç”¨æ³•ï¼šå‡½æ•°è°ƒç”¨ä½œä¸ºå·¦å€¼ 1234567891011121314#include &lt;iostream&gt;using namespace std;int&amp; test()&#123; static int a = 10; return a;&#125;int main()&#123; int&amp; ref = test(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; test() = 1000; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š ref &#x3D; 10ref &#x3D; 1000 å¼•ç”¨çš„æœ¬è´¨æœ¬è´¨ï¼šå¼•ç”¨çš„æœ¬è´¨æ˜¯åœ¨C++å†…éƒ¨å®ç°ä¸€ä¸ªæŒ‡é’ˆå¸¸é‡ int&amp; ref = a;ç­‰ä»·äºint* const ref = a; ref = 20å½“ç¼–è¯‘å™¨å‘ç°refæ˜¯å¼•ç”¨ï¼Œä¼šè‡ªåŠ¨å¸®æˆ‘ä»¬è§£å¼•ç”¨è½¬æ¢ä¸º*ref = 20 å¸¸é‡å¼•ç”¨ä½œç”¨ï¼šå¸¸é‡å¼•ç”¨ä¸»è¦ç”¨æ¥ä¿®é¥°å½¢å‚ï¼Œé˜²æ­¢è¯¯æ“ä½œã€‚ åœ¨å‡½æ•°å½¢å‚åˆ—è¡¨ä¸­ï¼Œå¯ä»¥åŠ const ä¿®é¥°å½¢å‚ï¼Œé˜²æ­¢å½¢å‚æ”¹å˜å®å‚","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"ã€Šåº„å­ ç§‹æ°´ã€‹ é˜…è¯»","slug":"ã€Šåº„å­-ç§‹æ°´ã€‹-é˜…è¯»","date":"2023-04-12T11:43:59.000Z","updated":"2023-04-12T14:23:41.820Z","comments":true,"path":"2023/04/12/ã€Šåº„å­-ç§‹æ°´ã€‹-é˜…è¯»/","link":"","permalink":"http://example.com/2023/04/12/%E3%80%8A%E5%BA%84%E5%AD%90-%E7%A7%8B%E6%B0%B4%E3%80%8B-%E9%98%85%E8%AF%BB/","excerpt":"ç§‹æ°´æ—¶è‡³ï¼Œç™¾å·çŒæ²³ã€‚æ³¾æµä¹‹å¤§ï¼Œä¸¤æ¶˜æ¸šå´–ä¹‹é—´ï¼Œä¸è¾©ç‰›é©¬ã€‚äºæ˜¯ç„‰æ²³ä¼¯æ¬£ç„¶è‡ªå–œï¼Œä»¥å¤©ä¸‹ä¹‹ç¾ä¸ºå°½åœ¨å·±ã€‚é¡ºæµè€Œä¸œè¡Œï¼Œè‡³äºåŒ—æµ·ï¼Œä¸œé¢è€Œè§†ï¼Œä¸è§æ°´ç«¯ã€‚äºæ˜¯ç„‰æ²³ä¼¯å§‹æ—‹å…¶é¢ç›®ï¼Œæœ›æ´‹å‘è‹¥è€Œå¹æ›°ï¼šâ€œé‡è¯­æœ‰ä¹‹æ›°ï¼šâ€˜é—»é“ç™¾ï¼Œä»¥ä¸ºè«å·±è‹¥è€…ã€‚â€™æˆ‘ä¹‹è°“ä¹Ÿã€‚ä¸”å¤«æˆ‘å°é—»å°‘ä»²å°¼ä¹‹é—»è€Œè½»ä¼¯å¤·ä¹‹ä¹‰è€…ï¼Œå§‹å¾å¼—ä¿¡ã€‚ä»Šæˆ‘ç¹å­ä¹‹éš¾ç©·ä¹Ÿï¼Œå¾éè‡³äºå­ä¹‹é—¨åˆ™æ®†çŸ£ï¼Œå¾é•¿è§ç¬‘äºå¤§æ–¹ä¹‹å®¶ã€‚â€åŒ—æµ·è‹¥æ›°ï¼šâ€œäº•è›™ä¸å¯ä»¥è¯­äºæµ·è€…ï¼Œæ‹˜äºè™šä¹Ÿï¼›å¤è™«ä¸å¯ä»¥è¯­äºå†°è€…ï¼Œç¬ƒäºæ—¶ä¹Ÿï¼›æ›²å£«ä¸å¯ä»¥è¯­äºé“è€…ï¼ŒæŸäºæ•™ä¹Ÿã€‚ä»Šå°”å‡ºäºå´–æ¶˜ï¼Œè§‚äºå¤§æµ·ï¼Œä¹ƒçŸ¥å°”ä¸‘ï¼Œå°”å°†å¯ä¸è¯­å¤§ç†çŸ£ã€‚å¤©ä¸‹ä¹‹æ°´ï¼Œè«å¤§äºæµ·ï¼šä¸‡å·å½’ä¹‹ï¼Œä¸çŸ¥ä½•æ—¶æ­¢è€Œä¸ç›ˆï¼›å°¾é—¾æ³„ä¹‹ï¼Œä¸çŸ¥ä½•æ—¶å·²è€Œä¸è™šï¼›æ˜¥ç§‹ä¸å˜ï¼Œæ°´æ—±ä¸çŸ¥ã€‚æ­¤å…¶è¿‡æ±Ÿæ²³ä¹‹æµï¼Œ ä¸å¯ä¸ºé‡æ•°ã€‚è€Œå¾æœªå°ä»¥æ­¤è‡ªå¤šè€…ï¼Œè‡ªä»¥æ¯”å½¢äºå¤©åœ°ï¼Œè€Œå—æ°”äºé˜´é˜³ï¼Œ å¾åœ¨äºå¤©åœ°ä¹‹é—´ï¼ŒçŠ¹å°çŸ³å°æœ¨ä¹‹åœ¨å¤§å±±ä¹Ÿã€‚æ–¹å­˜ä¹è§å°‘ï¼Œåˆå¥šä»¥è‡ªå¤šï¼ è®¡å››æµ·ä¹‹åœ¨å¤©åœ°ä¹‹é—´ä¹Ÿï¼Œä¸ä¼¼ç¤¨ç©ºä¹‹åœ¨å¤§æ³½ä¹ï¼Ÿè®¡ä¸­å›½ä¹‹åœ¨æµ·å†…ä¸ä¼¼ç¨Šç±³ä¹‹åœ¨å¤ªä»“ä¹ï¼Ÿå·ç‰©ä¹‹æ•°è°“ä¹‹ä¸‡ï¼Œäººå¤„ä¸€ç„‰ï¼›äººå’ä¹å·ï¼Œè°·é£Ÿä¹‹æ‰€ç”Ÿï¼ŒèˆŸè½¦ä¹‹æ‰€é€šï¼Œäººå¤„ä¸€ç„‰ã€‚æ­¤å…¶æ¯”ä¸‡ç‰©ä¹Ÿï¼Œä¸ä¼¼è±ªæœ«ä¹‹åœ¨äºé©¬ä½“ä¹ï¼Ÿ äº”å¸ä¹‹æ‰€è¿ï¼Œä¸‰ç‹ä¹‹æ‰€äº‰ï¼Œä»äººä¹‹æ‰€å¿§ï¼Œä»»å£«ä¹‹æ‰€åŠ³ï¼Œå°½æ­¤çŸ£ï¼ä¼¯å¤·è¾ä¹‹ä»¥ä¸ºåï¼Œä»²å°¼è¯­ä¹‹ä»¥ä¸ºåšã€‚æ­¤å…¶è‡ªå¤šä¹Ÿï¼Œä¸ä¼¼å°”å‘ä¹‹è‡ªå¤šäºæ°´ä¹ï¼Ÿâ€ ç§‹æ±›æ—¶èŠ‚ï¼Œå¤§å¤§å°å°çš„æ²³æµéƒ½çŒå…¥é»„æ²³ä¹‹ä¸­ï¼Œæ²³æµæ°´åŠ¿æµ©å¤§ï¼Œä¸¤å²¸ä¹‹é—´ä¸€ç‰‡è‹èŒ«ï¼Œåˆ†ä¸æ¸…æ˜¯ç‰›æ˜¯é©¬åœ¨é‚£é‡Œæ´»åŠ¨ã€‚äºæ˜¯æ²³ä¼¯æ²¾æ²¾è‡ªå–œï¼Œè®¤ä¸ºå¤©ä¸‹ç¾æ™¯éƒ½æŒæ¡åœ¨è‡ªå·±æ‰‹ä¸­ã€‚ä½†æ²³ä¼¯é¡ºç€æ°´æµå¾€ä¸œèµ°ï¼Œåˆ°è¾¾äº†åŒ—æµ·ï¼Œé¢æœå¤§æµ·ï¼Œæœ›ç€æ— è¾¹æ— é™…çš„æµ·é¢ï¼Œä»–æ”¶èµ·äº†å¾—æ„çš„ç¥æƒ…ï¼Œä»–ä»°ç€å¤´å‘åŒ—æµ·è‹¥æ„Ÿå¹é“ï¼šå¬é—»è®¸å¤šé“ç†ï¼Œè®¤ä¸ºè°éƒ½ä¸å¦‚è‡ªå·±ï¼Œè¯´çš„å°±æ˜¯æˆ‘è¿™ç§äººã€‚è€Œä¸”æˆ‘æ›¾å¬è¯´æœ‰äººå°çœ‹ä»²å°¼çš„è§è¯†ï¼Œè½»è§†ä¼¯å¤·çš„ä¹‰æ°”ï¼Œå¦‚ä»Šæˆ‘ç»ˆäºæ˜¯ç›¸ä¿¡äº†ï¼Œä»Šå¤©æˆ‘çœ‹åˆ°è¿™æ— è¾¹æ— é™…çš„å¤§æµ·ï¼Œå¦‚æœæ²¡æœ‰åˆ°æ‚¨è¿™æ¥ï¼Œæˆ‘å¤§æ¦‚è¦æ°¸è¿œè´»ç¬‘å¤§æ–¹äº†ã€‚åŒ—æµ·è‹¥è¯´ï¼šäº•åº•ä¹‹è›™ä¸å¯ä»¥è·Ÿä»–è°ˆè®ºå¤§æµ·ï¼Œå› ä¸ºä»–å—ç©ºé—´çš„é™åˆ¶ï¼›å¤å¤©çš„è™«ä¸å¯ä»¥è·Ÿä»–è°ˆè®ºå†°é›ªï¼Œå› ä¸ºä»–å—æ—¶é—´çš„é™åˆ¶ï¼›æµ…é™‹çš„ä¹¦ç”Ÿä¸å¯ä»¥è·Ÿä»–è°ˆè®ºå¤§é“ï¼Œä»¥ä¸ºä»–å—ç¤¼æ•™çš„é™åˆ¶ã€‚å¦‚ä»Šä½ ä»æ²³è¾¹æ¥åˆ°å¤§æµ·ï¼Œè§è¯†åˆ°äº†å¤§æµ·çš„æ— è¾¹æ— é™…ï¼Œæ˜ç™½äº†è‡ªå·±çš„æµ…é™‹ï¼Œé‚£æˆ‘å°±å¯ä»¥è·Ÿä½ è®²è®²å¤§é“ç†äº†ã€‚å¤©ä¸‹çš„æ°´åŸŸï¼Œæ²¡æœ‰æ¯”æµ·æ´‹æ›´è¾½é˜”çš„äº†ï¼Œåƒä¸‡æ¡æ±Ÿæ²³ä¸åœçš„æ±‡èšåˆ°æµ·æ´‹ï¼Œä½†æ˜¯æµ·æ´‹æ°¸è¿œä¸ä¼šæ»¡ï¼Œæµ·æ´‹ä»å°¾é—¾æ³„æ°´ï¼Œä½†æ˜¯ä¸çŸ¥é“ä½•æ—¶æ‰èƒ½å¤Ÿæµå°½ï¼Œä¸è®ºæ˜¯æ˜¥å¤©è¿˜æ˜¯ç§‹å¤©ï¼Œå¹²æ—±è¿˜æ˜¯æ´ªæ¶ï¼Œæµ·æ´‹éƒ½ä¸æ¯«ä¸å—å½±å“ã€‚æµ·æ´‹çš„å®¹é‡ï¼Œæ¯”æ±Ÿæ²³ä¸çŸ¥é“å¤§äº†å¤šå°‘ï¼Œä½†æ˜¯æˆ‘ä»æ¥ä¸è®¤ä¸ºè‡ªå·±äº†ä¸èµ·ã€‚æˆ‘ä»å¤©åœ°é‚£é‡Œè·å¾—äº†å½¢ä½“ï¼Œä»é˜´é˜³é‚£é‡Œè·å¾—äº†ç”Ÿæ°”ï¼Œæˆ‘åœ¨å¤©åœ°é—´ï¼Œå°±åƒä¸€é¢—å°çŸ³å¤´åœ¨æ³°å±±ä¹‹ä¸Šï¼Œåªä¼šè‡ªä»¥ä¸ºå°ï¼Œåˆæ€ä¹ˆä¼šè‡ªæ»¡å‘¢ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå››æµ·åœ¨å¤©åœ°ä¹‹é—´ï¼Œä¸å°±åƒä¸€ä¸ªèšç©´åœ¨å¤§æ³½ä¹‹ä¸­å—ï¼Ÿä¸€ä¸ªå›½å®¶åœ¨å››æµ·ä¹‹é—´ï¼Œä¸å°±åƒä¸€ç²’ç±³åœ¨ç²®ä»“ä¸­å—ï¼Ÿä¸–é—´ç‰©ç§åƒåƒä¸‡ä¸‡ï¼Œäººåªæ˜¯å…¶ä¸­ä¸€ç§ã€‚äººèšé›†åœ¨ä¹å·ä¹‹å†…ï¼Œæ’­ç§è°·ç‰©ç²®é£Ÿï¼ŒèˆŸè½¦å››é€šå…«è¾¾ï¼Œä¸€ä¸ªäººåªä¸è¿‡æ˜¯å…¶ä¸€å°éƒ¨åˆ†è€Œå·²ã€‚æ‹¿äººå’Œä¸‡ç‰©ç›¸æ¯”ï¼Œä¸å°±åƒæ‹¿é©¬èº«ä¸Šçš„ä¸€æ ¹æ¯«æ¯›å’Œé©¬ç›¸æ¯”å—ï¼Ÿäº”å¸æ‰€ç»§æ‰¿çš„ï¼Œä¸‰ç‹æ‰€äº‰å¤ºçš„ï¼Œä»äººæ‰€å¿§è™‘çš„ï¼Œä»¥å¤©ä¸‹ä¸ºå·±ä»»çš„äººæ‰€æ“åŠ³çš„ï¼Œå…¶å®ä¸è¿‡å¦‚æ­¤ã€‚ä¼¯å¤·è¾è®©ç‹ä½æ¥è·å¾—åå£°ï¼Œä»²å°¼è°ˆè®ºå¤©ä¸‹å¤§äº‹ä»¥æ˜¾ç¤ºçŸ¥è¯†æ¸Šåšï¼Œä»–ä»¬è‡ªä»¥ä¸ºäº†ä¸èµ·ï¼Œä¸å°±åƒä½ ä¸€æ ·å—ï¼Ÿ æ²³ä¼¯æ›°ï¼šâ€œç„¶åˆ™å¾å¤§å¤©åœ°è€Œå°è±ªæœ«ï¼Œå¯ä¹ï¼Ÿâ€åŒ—æµ·è‹¥æ›°ï¼šâ€œå¦ã€‚å¤«ç‰©ï¼Œé‡æ— ç©·ï¼Œæ—¶æ— æ­¢ï¼Œåˆ†æ— å¸¸ï¼Œç»ˆå§‹æ— æ•…ã€‚æ˜¯æ•…å¤§çŸ¥è§‚äºè¿œè¿‘ï¼Œæ•…å°è€Œä¸å¯¡ï¼Œå¤§è€Œä¸å¤šï¼šçŸ¥é‡æ— ç©·ã€‚è¯å‘ä»Šæ•…ï¼Œæ•…é¥è€Œä¸é—·ï¼Œæ‡è€Œä¸è·‚ï¼š çŸ¥æ—¶æ— æ­¢ã€‚å¯Ÿä¹ç›ˆè™šï¼Œæ•…å¾—è€Œä¸å–œï¼Œå¤±è€Œä¸å¿§ï¼šçŸ¥åˆ†ä¹‹æ— å¸¸ä¹Ÿã€‚æ˜ä¹å¦æ¶‚ï¼Œæ•…ç”Ÿè€Œä¸è¯´ï¼Œæ­»è€Œä¸ç¥¸ï¼šçŸ¥ç»ˆå§‹ä¹‹ä¸å¯æ•…ä¹Ÿã€‚è®¡äººä¹‹æ‰€çŸ¥ï¼Œä¸è‹¥å…¶æ‰€ä¸çŸ¥ï¼›å…¶ç”Ÿä¹‹æ—¶ï¼Œä¸è‹¥æœªç”Ÿä¹‹æ—¶ï¼›ä»¥å…¶è‡³å°ï¼Œæ±‚ç©·å…¶è‡³å¤§ä¹‹åŸŸï¼Œ æ˜¯æ•…è¿·ä¹±è€Œä¸èƒ½è‡ªå¾—ä¹Ÿã€‚ç”±æ­¤è§‚ä¹‹ï¼Œåˆä½•ä»¥çŸ¥æ¯«æœ«ä¹‹è¶³ä»¥å®šè‡³ç»†ä¹‹å€ªï¼Œ åˆä½•ä»¥çŸ¥å¤©åœ°ä¹‹è¶³ä»¥ç©·è‡³å¤§ä¹‹åŸŸï¼â€","text":"ç§‹æ°´æ—¶è‡³ï¼Œç™¾å·çŒæ²³ã€‚æ³¾æµä¹‹å¤§ï¼Œä¸¤æ¶˜æ¸šå´–ä¹‹é—´ï¼Œä¸è¾©ç‰›é©¬ã€‚äºæ˜¯ç„‰æ²³ä¼¯æ¬£ç„¶è‡ªå–œï¼Œä»¥å¤©ä¸‹ä¹‹ç¾ä¸ºå°½åœ¨å·±ã€‚é¡ºæµè€Œä¸œè¡Œï¼Œè‡³äºåŒ—æµ·ï¼Œä¸œé¢è€Œè§†ï¼Œä¸è§æ°´ç«¯ã€‚äºæ˜¯ç„‰æ²³ä¼¯å§‹æ—‹å…¶é¢ç›®ï¼Œæœ›æ´‹å‘è‹¥è€Œå¹æ›°ï¼šâ€œé‡è¯­æœ‰ä¹‹æ›°ï¼šâ€˜é—»é“ç™¾ï¼Œä»¥ä¸ºè«å·±è‹¥è€…ã€‚â€™æˆ‘ä¹‹è°“ä¹Ÿã€‚ä¸”å¤«æˆ‘å°é—»å°‘ä»²å°¼ä¹‹é—»è€Œè½»ä¼¯å¤·ä¹‹ä¹‰è€…ï¼Œå§‹å¾å¼—ä¿¡ã€‚ä»Šæˆ‘ç¹å­ä¹‹éš¾ç©·ä¹Ÿï¼Œå¾éè‡³äºå­ä¹‹é—¨åˆ™æ®†çŸ£ï¼Œå¾é•¿è§ç¬‘äºå¤§æ–¹ä¹‹å®¶ã€‚â€åŒ—æµ·è‹¥æ›°ï¼šâ€œäº•è›™ä¸å¯ä»¥è¯­äºæµ·è€…ï¼Œæ‹˜äºè™šä¹Ÿï¼›å¤è™«ä¸å¯ä»¥è¯­äºå†°è€…ï¼Œç¬ƒäºæ—¶ä¹Ÿï¼›æ›²å£«ä¸å¯ä»¥è¯­äºé“è€…ï¼ŒæŸäºæ•™ä¹Ÿã€‚ä»Šå°”å‡ºäºå´–æ¶˜ï¼Œè§‚äºå¤§æµ·ï¼Œä¹ƒçŸ¥å°”ä¸‘ï¼Œå°”å°†å¯ä¸è¯­å¤§ç†çŸ£ã€‚å¤©ä¸‹ä¹‹æ°´ï¼Œè«å¤§äºæµ·ï¼šä¸‡å·å½’ä¹‹ï¼Œä¸çŸ¥ä½•æ—¶æ­¢è€Œä¸ç›ˆï¼›å°¾é—¾æ³„ä¹‹ï¼Œä¸çŸ¥ä½•æ—¶å·²è€Œä¸è™šï¼›æ˜¥ç§‹ä¸å˜ï¼Œæ°´æ—±ä¸çŸ¥ã€‚æ­¤å…¶è¿‡æ±Ÿæ²³ä¹‹æµï¼Œ ä¸å¯ä¸ºé‡æ•°ã€‚è€Œå¾æœªå°ä»¥æ­¤è‡ªå¤šè€…ï¼Œè‡ªä»¥æ¯”å½¢äºå¤©åœ°ï¼Œè€Œå—æ°”äºé˜´é˜³ï¼Œ å¾åœ¨äºå¤©åœ°ä¹‹é—´ï¼ŒçŠ¹å°çŸ³å°æœ¨ä¹‹åœ¨å¤§å±±ä¹Ÿã€‚æ–¹å­˜ä¹è§å°‘ï¼Œåˆå¥šä»¥è‡ªå¤šï¼ è®¡å››æµ·ä¹‹åœ¨å¤©åœ°ä¹‹é—´ä¹Ÿï¼Œä¸ä¼¼ç¤¨ç©ºä¹‹åœ¨å¤§æ³½ä¹ï¼Ÿè®¡ä¸­å›½ä¹‹åœ¨æµ·å†…ä¸ä¼¼ç¨Šç±³ä¹‹åœ¨å¤ªä»“ä¹ï¼Ÿå·ç‰©ä¹‹æ•°è°“ä¹‹ä¸‡ï¼Œäººå¤„ä¸€ç„‰ï¼›äººå’ä¹å·ï¼Œè°·é£Ÿä¹‹æ‰€ç”Ÿï¼ŒèˆŸè½¦ä¹‹æ‰€é€šï¼Œäººå¤„ä¸€ç„‰ã€‚æ­¤å…¶æ¯”ä¸‡ç‰©ä¹Ÿï¼Œä¸ä¼¼è±ªæœ«ä¹‹åœ¨äºé©¬ä½“ä¹ï¼Ÿ äº”å¸ä¹‹æ‰€è¿ï¼Œä¸‰ç‹ä¹‹æ‰€äº‰ï¼Œä»äººä¹‹æ‰€å¿§ï¼Œä»»å£«ä¹‹æ‰€åŠ³ï¼Œå°½æ­¤çŸ£ï¼ä¼¯å¤·è¾ä¹‹ä»¥ä¸ºåï¼Œä»²å°¼è¯­ä¹‹ä»¥ä¸ºåšã€‚æ­¤å…¶è‡ªå¤šä¹Ÿï¼Œä¸ä¼¼å°”å‘ä¹‹è‡ªå¤šäºæ°´ä¹ï¼Ÿâ€ ç§‹æ±›æ—¶èŠ‚ï¼Œå¤§å¤§å°å°çš„æ²³æµéƒ½çŒå…¥é»„æ²³ä¹‹ä¸­ï¼Œæ²³æµæ°´åŠ¿æµ©å¤§ï¼Œä¸¤å²¸ä¹‹é—´ä¸€ç‰‡è‹èŒ«ï¼Œåˆ†ä¸æ¸…æ˜¯ç‰›æ˜¯é©¬åœ¨é‚£é‡Œæ´»åŠ¨ã€‚äºæ˜¯æ²³ä¼¯æ²¾æ²¾è‡ªå–œï¼Œè®¤ä¸ºå¤©ä¸‹ç¾æ™¯éƒ½æŒæ¡åœ¨è‡ªå·±æ‰‹ä¸­ã€‚ä½†æ²³ä¼¯é¡ºç€æ°´æµå¾€ä¸œèµ°ï¼Œåˆ°è¾¾äº†åŒ—æµ·ï¼Œé¢æœå¤§æµ·ï¼Œæœ›ç€æ— è¾¹æ— é™…çš„æµ·é¢ï¼Œä»–æ”¶èµ·äº†å¾—æ„çš„ç¥æƒ…ï¼Œä»–ä»°ç€å¤´å‘åŒ—æµ·è‹¥æ„Ÿå¹é“ï¼šå¬é—»è®¸å¤šé“ç†ï¼Œè®¤ä¸ºè°éƒ½ä¸å¦‚è‡ªå·±ï¼Œè¯´çš„å°±æ˜¯æˆ‘è¿™ç§äººã€‚è€Œä¸”æˆ‘æ›¾å¬è¯´æœ‰äººå°çœ‹ä»²å°¼çš„è§è¯†ï¼Œè½»è§†ä¼¯å¤·çš„ä¹‰æ°”ï¼Œå¦‚ä»Šæˆ‘ç»ˆäºæ˜¯ç›¸ä¿¡äº†ï¼Œä»Šå¤©æˆ‘çœ‹åˆ°è¿™æ— è¾¹æ— é™…çš„å¤§æµ·ï¼Œå¦‚æœæ²¡æœ‰åˆ°æ‚¨è¿™æ¥ï¼Œæˆ‘å¤§æ¦‚è¦æ°¸è¿œè´»ç¬‘å¤§æ–¹äº†ã€‚åŒ—æµ·è‹¥è¯´ï¼šäº•åº•ä¹‹è›™ä¸å¯ä»¥è·Ÿä»–è°ˆè®ºå¤§æµ·ï¼Œå› ä¸ºä»–å—ç©ºé—´çš„é™åˆ¶ï¼›å¤å¤©çš„è™«ä¸å¯ä»¥è·Ÿä»–è°ˆè®ºå†°é›ªï¼Œå› ä¸ºä»–å—æ—¶é—´çš„é™åˆ¶ï¼›æµ…é™‹çš„ä¹¦ç”Ÿä¸å¯ä»¥è·Ÿä»–è°ˆè®ºå¤§é“ï¼Œä»¥ä¸ºä»–å—ç¤¼æ•™çš„é™åˆ¶ã€‚å¦‚ä»Šä½ ä»æ²³è¾¹æ¥åˆ°å¤§æµ·ï¼Œè§è¯†åˆ°äº†å¤§æµ·çš„æ— è¾¹æ— é™…ï¼Œæ˜ç™½äº†è‡ªå·±çš„æµ…é™‹ï¼Œé‚£æˆ‘å°±å¯ä»¥è·Ÿä½ è®²è®²å¤§é“ç†äº†ã€‚å¤©ä¸‹çš„æ°´åŸŸï¼Œæ²¡æœ‰æ¯”æµ·æ´‹æ›´è¾½é˜”çš„äº†ï¼Œåƒä¸‡æ¡æ±Ÿæ²³ä¸åœçš„æ±‡èšåˆ°æµ·æ´‹ï¼Œä½†æ˜¯æµ·æ´‹æ°¸è¿œä¸ä¼šæ»¡ï¼Œæµ·æ´‹ä»å°¾é—¾æ³„æ°´ï¼Œä½†æ˜¯ä¸çŸ¥é“ä½•æ—¶æ‰èƒ½å¤Ÿæµå°½ï¼Œä¸è®ºæ˜¯æ˜¥å¤©è¿˜æ˜¯ç§‹å¤©ï¼Œå¹²æ—±è¿˜æ˜¯æ´ªæ¶ï¼Œæµ·æ´‹éƒ½ä¸æ¯«ä¸å—å½±å“ã€‚æµ·æ´‹çš„å®¹é‡ï¼Œæ¯”æ±Ÿæ²³ä¸çŸ¥é“å¤§äº†å¤šå°‘ï¼Œä½†æ˜¯æˆ‘ä»æ¥ä¸è®¤ä¸ºè‡ªå·±äº†ä¸èµ·ã€‚æˆ‘ä»å¤©åœ°é‚£é‡Œè·å¾—äº†å½¢ä½“ï¼Œä»é˜´é˜³é‚£é‡Œè·å¾—äº†ç”Ÿæ°”ï¼Œæˆ‘åœ¨å¤©åœ°é—´ï¼Œå°±åƒä¸€é¢—å°çŸ³å¤´åœ¨æ³°å±±ä¹‹ä¸Šï¼Œåªä¼šè‡ªä»¥ä¸ºå°ï¼Œåˆæ€ä¹ˆä¼šè‡ªæ»¡å‘¢ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå››æµ·åœ¨å¤©åœ°ä¹‹é—´ï¼Œä¸å°±åƒä¸€ä¸ªèšç©´åœ¨å¤§æ³½ä¹‹ä¸­å—ï¼Ÿä¸€ä¸ªå›½å®¶åœ¨å››æµ·ä¹‹é—´ï¼Œä¸å°±åƒä¸€ç²’ç±³åœ¨ç²®ä»“ä¸­å—ï¼Ÿä¸–é—´ç‰©ç§åƒåƒä¸‡ä¸‡ï¼Œäººåªæ˜¯å…¶ä¸­ä¸€ç§ã€‚äººèšé›†åœ¨ä¹å·ä¹‹å†…ï¼Œæ’­ç§è°·ç‰©ç²®é£Ÿï¼ŒèˆŸè½¦å››é€šå…«è¾¾ï¼Œä¸€ä¸ªäººåªä¸è¿‡æ˜¯å…¶ä¸€å°éƒ¨åˆ†è€Œå·²ã€‚æ‹¿äººå’Œä¸‡ç‰©ç›¸æ¯”ï¼Œä¸å°±åƒæ‹¿é©¬èº«ä¸Šçš„ä¸€æ ¹æ¯«æ¯›å’Œé©¬ç›¸æ¯”å—ï¼Ÿäº”å¸æ‰€ç»§æ‰¿çš„ï¼Œä¸‰ç‹æ‰€äº‰å¤ºçš„ï¼Œä»äººæ‰€å¿§è™‘çš„ï¼Œä»¥å¤©ä¸‹ä¸ºå·±ä»»çš„äººæ‰€æ“åŠ³çš„ï¼Œå…¶å®ä¸è¿‡å¦‚æ­¤ã€‚ä¼¯å¤·è¾è®©ç‹ä½æ¥è·å¾—åå£°ï¼Œä»²å°¼è°ˆè®ºå¤©ä¸‹å¤§äº‹ä»¥æ˜¾ç¤ºçŸ¥è¯†æ¸Šåšï¼Œä»–ä»¬è‡ªä»¥ä¸ºäº†ä¸èµ·ï¼Œä¸å°±åƒä½ ä¸€æ ·å—ï¼Ÿ æ²³ä¼¯æ›°ï¼šâ€œç„¶åˆ™å¾å¤§å¤©åœ°è€Œå°è±ªæœ«ï¼Œå¯ä¹ï¼Ÿâ€åŒ—æµ·è‹¥æ›°ï¼šâ€œå¦ã€‚å¤«ç‰©ï¼Œé‡æ— ç©·ï¼Œæ—¶æ— æ­¢ï¼Œåˆ†æ— å¸¸ï¼Œç»ˆå§‹æ— æ•…ã€‚æ˜¯æ•…å¤§çŸ¥è§‚äºè¿œè¿‘ï¼Œæ•…å°è€Œä¸å¯¡ï¼Œå¤§è€Œä¸å¤šï¼šçŸ¥é‡æ— ç©·ã€‚è¯å‘ä»Šæ•…ï¼Œæ•…é¥è€Œä¸é—·ï¼Œæ‡è€Œä¸è·‚ï¼š çŸ¥æ—¶æ— æ­¢ã€‚å¯Ÿä¹ç›ˆè™šï¼Œæ•…å¾—è€Œä¸å–œï¼Œå¤±è€Œä¸å¿§ï¼šçŸ¥åˆ†ä¹‹æ— å¸¸ä¹Ÿã€‚æ˜ä¹å¦æ¶‚ï¼Œæ•…ç”Ÿè€Œä¸è¯´ï¼Œæ­»è€Œä¸ç¥¸ï¼šçŸ¥ç»ˆå§‹ä¹‹ä¸å¯æ•…ä¹Ÿã€‚è®¡äººä¹‹æ‰€çŸ¥ï¼Œä¸è‹¥å…¶æ‰€ä¸çŸ¥ï¼›å…¶ç”Ÿä¹‹æ—¶ï¼Œä¸è‹¥æœªç”Ÿä¹‹æ—¶ï¼›ä»¥å…¶è‡³å°ï¼Œæ±‚ç©·å…¶è‡³å¤§ä¹‹åŸŸï¼Œ æ˜¯æ•…è¿·ä¹±è€Œä¸èƒ½è‡ªå¾—ä¹Ÿã€‚ç”±æ­¤è§‚ä¹‹ï¼Œåˆä½•ä»¥çŸ¥æ¯«æœ«ä¹‹è¶³ä»¥å®šè‡³ç»†ä¹‹å€ªï¼Œ åˆä½•ä»¥çŸ¥å¤©åœ°ä¹‹è¶³ä»¥ç©·è‡³å¤§ä¹‹åŸŸï¼â€ æ²³ä¼¯è¯´ï¼šé‚£ä¹ˆæˆ‘ä»¥å¤©åœ°ä¸ºå¤§ï¼Œä»¥æ¯«æ¯›ä¸ºå°ï¼Œè¿™ä¹Ÿå¯ä»¥å—ï¼ŸåŒ—æµ·è‹¥è¯´ï¼šä¸è¡Œï¼Œä¸–é—´ä¸‡ç‰©ï¼Œåœ¨ç©ºé—´ä¸Šæ˜¯æ— æ³•ç©·å°½çš„ï¼Œåœ¨æ—¶é—´ä¸Šæ˜¯æ²¡æœ‰æ­¢å¢ƒçš„ï¼Œä¸å­˜åœ¨å›ºå®šçš„åŒºåˆ†ï¼Œä¹Ÿä¸å­˜åœ¨çœŸæ­£æ„ä¹‰ä¸Šçš„å¼€å§‹å’Œç»“æŸã€‚æ‰€ä»¥ï¼Œ æ‹¥æœ‰å¤§æ™ºæ…§çš„äººï¼Œä¸ä»¥å°ä¸ºå°ï¼Œä¸ä»¥å¤§ä¸ºå¤§ï¼Œå¯¹äºé¥è¿œçš„è¿‡å»å’Œå°†æ¥ï¼Œä¸ä¼šæ„Ÿåˆ°è‹¦é—·ï¼Œå¯¹äºåˆ‡èº«ä½“ä¼šçš„å½“ä¸‹ä¹Ÿä¸ä¼šåˆ»æ„å¼ºæ±‚ï¼Œæœ‰æ‰€å¾—åˆ°ä¹Ÿä¸ä¼šæ¬£å–œï¼Œæœ‰æ‰€å¤±å»ä¹Ÿä¸ä¼šæ„Ÿåˆ°å¿§æ„ï¼Œå› ä¸ºå˜åŒ–æ˜¯æ— å¸¸çš„ã€‚ä¸ä¼šå› ä¸ºæˆ–è€…è€Œé›€è·ƒï¼Œä¹Ÿä¸ä¼šå› ä¸ºæ­»äº¡è€Œæ‚²æï¼Œå› ä¸ºç”Ÿæ­»æ˜¯æ— æ³•è§£é‡Šçš„ã€‚ä¸€ä¸ªäººæ‰€çŸ¥é“çš„ä¸œè¥¿ï¼Œè¿œè¿œæ¯”ä¸ä¸Šä¸çŸ¥é“çš„ä¸œè¥¿ã€‚ä¸€ä¸ªäººå­˜æ´»çš„æ—¶é—´ï¼Œè¿œè¿œæ¯”ä¸ä¸Šæœªå­˜æ´»çš„æ—¶é—´ã€‚ç”±è¯•å›¾ç”¨æå°çš„äº‹ç‰©æ¥æ¢ç©¶æå¤§çš„èŒƒå›´ï¼Œäººä»¬ä¼šå˜å¾—è¿·æƒ‘ä¸è§£ï¼Œæ— æ³•æ‰¾åˆ°è‡ªå·±ã€‚ä»è¿™ä¸ªè§’åº¦æ¥çœ‹ï¼Œæˆ‘ä»¬æ€ä¹ˆèƒ½çŸ¥é“ä¸€ç²’ç»†å¾®çš„å°˜åŸƒè¶³ä»¥å†³å®šæœ€å¾®å¦™çš„å·®åˆ«ï¼Œåˆæ€ä¹ˆèƒ½çŸ¥é“å¤©åœ°è¶³ä»¥ç©·å°½æœ€å¤§çš„èŒƒå›´å‘¢ï¼Ÿâ€ æ²³ä¼¯æ›°ï¼šâ€œä¸–ä¹‹è®®è€…çš†æ›°ï¼šâ€˜è‡³ç²¾æ— å½¢ï¼Œè‡³å¤§ä¸å¯å›´ã€‚â€™æ˜¯ä¿¡æƒ…ä¹ ï¼Ÿâ€åŒ—æµ·è‹¥æ›°ï¼šâ€œå¤«è‡ªç»†è§†å¤§è€…ä¸å°½ï¼Œè‡ªå¤§è§†ç»†è€…ä¸æ˜ã€‚å¤«ç²¾ï¼Œå°ä¹‹å¾®ä¹Ÿï¼›éƒ›ï¼Œå¤§ä¹‹æ®·ä¹Ÿï¼šæ•…å¼‚ä¾¿ã€‚æ­¤åŠ¿ä¹‹æœ‰ä¹Ÿã€‚å¤«ç²¾ç²—è€…ï¼ŒæœŸäºæœ‰å½¢è€…ä¹Ÿï¼›æ— å½¢è€…ï¼Œæ•°ä¹‹æ‰€ä¸èƒ½åˆ†ä¹Ÿï¼›ä¸å¯å›´è€…ï¼Œæ•°ä¹‹æ‰€ä¸èƒ½ç©·ä¹Ÿã€‚å¯ä»¥è¨€è®ºè€…ï¼Œç‰©ä¹‹ç²—ä¹Ÿï¼›å¯ä»¥æ„è‡´è€…ï¼Œç‰©ä¹‹ç²¾ä¹Ÿï¼›è¨€ä¹‹æ‰€ä¸èƒ½è®ºï¼Œæ„ä¹‹æ‰€ä¸èƒ½å¯Ÿè‡´è€…ï¼Œä¸æœŸç²¾ç²—ç„‰ã€‚æ˜¯æ•…å¤§äººä¹‹è¡Œï¼šä¸å‡ºä¹å®³äººï¼Œä¸å¤šä»æ©ï¼›åŠ¨ä¸ä¸ºåˆ©ï¼Œä¸è´±é—¨éš¶ï¼›è´§è´¢å¼—äº‰ï¼Œä¸å¤šè¾è®©ï¼›äº‹ç„‰ä¸å€Ÿäººï¼Œä¸å¤šé£Ÿä¹åŠ› ï¼Œä¸è´±è´ªæ±¡ï¼›è¡Œæ®Šä¹ä¿—ï¼Œä¸å¤šè¾Ÿå¼‚ï¼›ä¸ºåœ¨ä»ä¼—ï¼Œä¸è´±ä½è°„ï¼›ä¸–ä¹‹çˆµç¦„ ä¸è¶³ä»¥ä¸ºåŠï¼Œæˆ®è€»ä¸è¶³ä»¥ä¸ºè¾±ï¼›çŸ¥æ˜¯éä¹‹ä¸å¯ä¸ºåˆ†ï¼Œç»†å¤§ä¹‹ä¸å¯ä¸ºå€ª ã€‚é—»æ›°ï¼šâ€˜é“äººä¸é—»ï¼Œè‡³å¾·ä¸å¾—ï¼Œå¤§äººæ— å·±ã€‚â€™çº¦åˆ†ä¹‹è‡³ä¹Ÿã€‚â€ æ²³ä¼¯é—®ï¼šä¸–ä¸Šçš„äººéƒ½è¯´ï¼Œæœ€ç²¾ç»†çš„ä¸œè¥¿æ²¡æœ‰å½¢ä½“ï¼Œæœ€å®å¤§çš„ä¸œè¥¿æ²¡æœ‰å¤–å›´ï¼Œè¿™æ˜¯çœŸçš„å—ï¼ŸåŒ—æµ·è‹¥è¯´ï¼šä»¥å°çš„è§†è§’å»çœ‹å¤§çš„ä¸œè¥¿æ˜¯çœ‹ä¸å…¨é¢çš„ï¼Œä»¥å¤§çš„è§†è§’å»çœ‹å°çš„ä¸œè¥¿æ˜¯çœ‹ä¸æ¸…æ¥šçš„ï¼Œæ‰€ä»¥å„æœ‰æ‰€åï¼Œç²¾æ˜¯æŒ‡å°è€Œå¾®å¦™çš„äº‹ç‰©ï¼›éƒ›æ˜¯æŒ‡å¤§è€Œæ·±è¿œçš„äº‹ç‰©ï¼šæ‰€ä»¥å®ƒä»¬æ˜¯ä¸åŒçš„ã€‚è¿™æ˜¯å› ä¸ºäº‹ç‰©çš„è§„æ¨¡å’Œå½¢æ€æ˜¯æœ‰å·®å¼‚çš„ã€‚æ‰€è°“ç²¾å’Œç²—æ˜¯å¯¹äºæœ‰å½¢çš„ä¸œè¥¿æ¥è¯´çš„ï¼Œæ— å½¢çš„ä¸œè¥¿å°±æ˜¯å°åˆ°æ— æ³•åˆ†è¾¨äº†ï¼Œæ²¡æœ‰å¤–å›´çš„ä¸œè¥¿å°±æ˜¯å¤§åˆ°æ— æ³•è®¡ç®—äº†ã€‚å¯ä»¥ç”¨è¯­è¨€è¡¨è¾¾çš„æ˜¯ç²—å¤§çš„äº‹ç‰©ï¼Œå¯ä»¥æƒ³è±¡çš„æ˜¯ç²¾å¾®çš„é£Ÿç‰©ã€‚æ— æ³•ç”¨è¯­è¨€è¡¨è¾¾ä¹Ÿä¸èƒ½æƒ³è±¡çš„ï¼Œåˆ™æ ¹æœ¬ä¸é€‚ç”¨äºç²¾ç²—çš„æ¦‚å¿µã€‚å› æ­¤ï¼Œå¤§äººçš„è¡Œä¸ºï¼šä¸ä¼¤å®³ä»–äººï¼Œä¸è¿‡åˆ†æ–½æ©ï¼›è¡ŒåŠ¨ä¸æ˜¯ä¸ºäº†åˆ©ç›Šï¼Œä¸è½»è§†é—¨ä¸‹ä¹‹äººï¼›ä¸äº‰å¤ºè´¢ç‰©ï¼Œä¸è¿‡åˆ†è¨€è¾è°¦è®©ï¼›åšäº‹ä¸ä¾èµ–ä»–äººï¼Œä¸è¿‡åˆ†ä¾èµ–è‡ªå·±çš„åŠ›é‡ï¼Œä¸è½»è§†è´ªæ±¡ï¼›è¡Œä¸ºä¸åŒäºä¿—äººï¼Œä¸è¿‡åˆ†è¿½æ±‚ä¸ä¼—ä¸åŒï¼›å¤„åœ¨å¤§ä¼—ä¹‹ä¸­ï¼Œä¸è½»è§†å¥‰æ‰¿è°„åªšï¼›ä¸–ä¿—çš„è£èª‰å’Œåœ°ä½ä¸è¶³ä»¥æ¿€å‘ä»–çš„å…´è¶£ï¼Œå±ˆè¾±å’Œè€»è¾±ä¸è¶³ä»¥ä½¿ä»–æ„Ÿåˆ°ç¾è€»ï¼›æ‡‚å¾—æ˜¯éæ— æ³•æ˜ç¡®åŒºåˆ†ï¼Œå¤§å°æ— æ³•ç¡®å®šè¾¹ç•Œã€‚æœ‰å¥è¯è¯´ï¼šâ€˜é“ä¹‹äººä¸å¯é—»ï¼Œè‡³å¾·ä¸å¯å¾—ï¼Œå¤§äººæ— å·±ã€‚â€™è¿™å°±æ˜¯å¯¹äº‹ç‰©æé™çš„äº†è§£ã€‚â€ æ²³ä¼¯æ›°ï¼šâ€œè‹¥ç‰©ä¹‹å¤–ï¼Œè‹¥ç‰©ä¹‹å†…ï¼Œæ¶è‡³è€Œå€ªè´µè´±ï¼Ÿæ¶è‡³è€Œå€ªå°å¤§ï¼Ÿ â€åŒ—æµ·è‹¥æ›°ï¼šâ€œä»¥é“è§‚ä¹‹ï¼Œç‰©æ— è´µè´±ï¼›ä»¥ç‰©è§‚ä¹‹ï¼Œè‡ªè´µè€Œç›¸è´±ï¼›ä»¥ä¿—è§‚ä¹‹ï¼Œè´µè´±ä¸åœ¨å·±ã€‚ä»¥å·®è§‚ä¹‹ï¼Œå› å…¶æ‰€å¤§è€Œå¤§ä¹‹ï¼Œåˆ™ä¸‡ç‰©è«ä¸å¤§ï¼›å› å…¶æ‰€å°è€Œå°ä¹‹ï¼Œåˆ™ä¸‡ç‰©è«ä¸å°ã€‚çŸ¥å¤©åœ°ä¹‹ä¸ºç¨Šç±³ä¹Ÿï¼ŒçŸ¥æ¯«æœ«ä¹‹ä¸ºä¸˜å±±ä¹Ÿï¼Œåˆ™å·®æ•°ç¹çŸ£ã€‚ä»¥åŠŸè§‚ä¹‹ï¼Œå› å…¶æ‰€æœ‰è€Œæœ‰ä¹‹ï¼Œåˆ™ä¸‡ç‰©è«ä¸æœ‰ï¼› å› å…¶æ‰€æ— è€Œæ— ä¹‹ï¼Œåˆ™ä¸‡ç‰©è«ä¸æ— ã€‚çŸ¥ä¸œè¥¿ä¹‹ç›¸åè€Œä¸å¯ä»¥ç›¸æ— ï¼Œåˆ™åŠŸåˆ†å®šçŸ£ã€‚ä»¥è¶£è§‚ä¹‹ï¼Œå› å…¶æ‰€ç„¶è€Œç„¶ä¹‹ï¼Œåˆ™ä¸‡ç‰©è«ä¸ç„¶ï¼›å› å…¶æ‰€éè€Œé ä¹‹ï¼Œåˆ™ä¸‡ç‰©è«ä¸éã€‚çŸ¥å°§ã€æ¡€ä¹‹è‡ªç„¶è€Œç›¸éï¼Œåˆ™è¶£æ“ç¹çŸ£ã€‚æ˜”è€…å°§ã€ èˆœè®©è€Œå¸ï¼Œä¹‹ã€å“™è®©è€Œç»ï¼›æ±¤ã€æ­¦äº‰è€Œç‹ï¼Œç™½å…¬äº‰è€Œç­ã€‚ç”±æ­¤è§‚ä¹‹ï¼Œ äº‰è®©ä¹‹ç¤¼ï¼Œå°§ã€æ¡€ä¹‹è¡Œï¼Œè´µè´±æœ‰æ—¶ï¼Œæœªå¯ä»¥ä¸ºå¸¸ä¹Ÿã€‚æ¢ä¸½å¯ä»¥å†²åŸè€Œä¸å¯ä»¥çª’ç©´ï¼Œè¨€æ®Šå™¨ä¹Ÿï¼›éªéª¥éª…éªä¸€æ—¥è€Œé©°åƒé‡Œï¼Œæ•é¼ ä¸å¦‚ç‹¸ç‹Œï¼Œè¨€æ®ŠæŠ€ä¹Ÿï¼›é¸±é¸ºå¤œæ’®èš¤ï¼Œå¯Ÿæ¯«æœ«ï¼Œæ˜¼å‡ºç‹ç›®è€Œä¸è§ä¸˜å±±ï¼Œè¨€æ®Šæ€§ä¹Ÿã€‚æ•…æ›°ï¼šç›–å¸ˆæ˜¯è€Œæ— éï¼Œå¸ˆæ²»è€Œæ— ä¹±ä¹ï¼Ÿæ˜¯æœªæ˜å¤©åœ°ä¹‹ç†ï¼Œä¸‡ç‰©ä¹‹æƒ…ä¹Ÿã€‚ æ˜¯çŠ¹å¸ˆå¤©è€Œæ— åœ°ï¼Œå¸ˆé˜´è€Œæ— é˜³ï¼Œå…¶ä¸å¯è¡Œæ˜çŸ£ï¼ç„¶ä¸”è¯­è€Œä¸èˆï¼Œéæ„šåˆ™è¯¬ä¹Ÿï¼å¸ç‹æ®Šç¦…ï¼Œä¸‰ä»£æ®Šç»§ã€‚å·®å…¶æ—¶ï¼Œé€†å…¶ä¿—è€…ï¼Œè°“ä¹‹ç¯¡å¤«ï¼›å½“å…¶æ—¶ï¼Œé¡ºå…¶ä¿—è€…ï¼Œè°“ä¹‹ä¹‰ä¹‹å¾’ã€‚é»˜é»˜ä¹æ²³ä¼¯ï¼Œå¥³æ¶çŸ¥è´µè´±ä¹‹é—¨ï¼Œå°å¤§ä¹‹å®¶ï¼â€ æ²³ä¼¯é—®ï¼šåœ¨ä¸‡ç‰©ä¹‹å¤–å’Œä¸‡ç‰©ä¹‹å†…ï¼Œå¦‚ä½•åˆ¤æ–­ä¸€ä»¶äº‹ç‰©çš„è´µè´±å’Œå¤§å°å‘¢ï¼ŸåŒ—æµ·è‹¥è¯´ï¼šä»å¤§é“çš„è§’åº¦çœ‹ï¼Œä¸‡ç‰©æœ¬æ— è´µè´±ï¼Œä»ä»–ç‰©çš„è§’åº¦çœ‹ï¼Œéƒ½æ˜¯è‡ªä»¥ä¸ºè´µè€Œä»¥ä»–ç‰©ä¸ºè´±ï¼Œä»¥ä¸–ä¿—çš„è§’åº¦çœ‹ï¼Œè´µè´±ä¸åœ¨è‡ªå·±ï¼Œè€Œåœ¨ä»–äººçœ¼ä¸­ï¼Œä»¥å·®åˆ«çš„è§’åº¦çœ‹ï¼Œé¡ºç€å¤§çš„ä¸€é¢æ¥åˆ¤æ–­ï¼Œåˆ™ä¸‡ç‰©éƒ½æ˜¯å¤§çš„ï¼Œé¡ºç€å°çš„ä¸€é¢æ¥åˆ¤æ–­ï¼Œåˆ™ä¸‡ç‰©éƒ½æ˜¯å°çš„ã€‚å¤©åœ°å¯ä»¥åƒä¸€ç²’ç±³ä¸€æ ·å°ï¼Œæ¯«æ¯›ä¹Ÿå¯ä»¥åƒä¸€åº§å±±é‚£ä¹ˆå¤§ã€‚å¦‚æœä»ä¸‡ç‰©çš„åŠŸèƒ½çš„è§’åº¦çœ‹ï¼Œå¦‚æœä»¥å®ƒä»¬å…·æœ‰çš„åŠŸèƒ½æ¥è¡¡é‡ï¼Œé‚£ä¹ˆä¸‡ç‰©éƒ½æœ‰ç”¨ï¼Œå¦‚æœä»¥å®ƒä»¬æ²¡æœ‰çš„åŠŸèƒ½æ¥è¡¡é‡ï¼Œé‚£ä¹ˆä¸‡ç‰©éƒ½æ²¡æœ‰ç”¨ã€‚æ²¡æœ‰ä¸œå°±æ²¡æœ‰è¥¿ï¼Œæœ‰å’Œæ— ç›¸åç›¸æˆï¼ŒçŸ¥é“è¿™ä¸€ç‚¹ï¼ŒåŠŸèƒ½çš„åŒºåˆ†ä¹Ÿå°±æ˜ç™½äº†ã€‚å¦‚æœä»å–å‘çš„ä¸€é¢å»åˆ¤æ–­ï¼Œå¦‚æœé¡ºç€å¯¹çš„ä¸€é¢å»åˆ¤æ–­ï¼Œé‚£ä¹ˆä¸‡ç‰©éƒ½æ˜¯å¯¹çš„ï¼Œå¦‚æœé¡ºç€é”™çš„ä¸€é¢å»åˆ¤æ–­ï¼Œé‚£ä¹ˆä¸‡ç‰©éƒ½æ˜¯é”™çš„ã€‚å°±åƒå°§ã€å¤æ¡€éƒ½è®¤ä¸ºè‡ªå·±æ˜¯å¯¹çš„ã€‚å°§ã€èˆœçš„ç¦…è®©æˆä¸ºå¸ç‹ï¼Œè€Œç‡•ç‹å§¬å“™å’Œç‡•ç›¸å­ä¹‹å´å› ä¸ºç¦…è®©é­åˆ°ç­é¡¶ä¹‹ç¾ã€‚å•†æ±¤å’Œå‘¨æ­¦ç‹å› ä¸ºäº‰å¤ºè€Œç§°ç‹ï¼Œç™½å…¬èƒœå´å› ä¸ºäº‰æ–—è€Œç­äº¡ã€‚ä»è¿™äº›ä¾‹å­æ¥çœ‹ï¼Œäº‰æ–—ä¸ç¦…è®©ï¼Œå°§å’Œå¤æ¡€çš„è¡Œä¸ºï¼Œä¸èƒ½ä½œä¸ºæ°¸æ’çš„æ ‡å‡†æ¥è¡¡é‡è´µè´±ã€‚æ”»åŸçš„åˆ©å™¨ä¸é€‚ç”¨äºå µå¡å°æ´ï¼Œè¿™æ˜¯å› ä¸ºå™¨ç”¨ä¸åŒã€‚åƒé‡Œé©¬å¯ä»¥ä¸€æ—¥åƒé‡Œï¼Œä½†æ‰è€é¼ ä¸å¦‚ç‹¸ç‹Œï¼Œè¿™æ˜¯å› ä¸ºæŠ€èƒ½ä¸åŒã€‚çŒ«å¤´é¹°è™½ç„¶èƒ½åœ¨å¤œé—´æ•æ‰è·³èš¤ï¼Œçœ‹è§ç§‹æ¯«ä¹‹æœ«ï¼Œä½†æ˜¯ä¸€åˆ°ç™½å¤©å°±ä¼šçœ¼çï¼Œè¿å±±å²³éƒ½çœ‹ä¸åˆ°ï¼Œè¿™æ˜¯å› ä¸ºç§‰æ€§ä¸åŒã€‚äººä»¬æ€»æ˜¯è¯´ä¸ºä»€ä¹ˆä¸å­¦ä¹ å¯¹çš„è€ŒæŠ›å¼ƒé”™çš„ï¼Œæ•ˆæ³•æ²»ä¸–è€ŒæŠ›å¼ƒä¹±ä¸–å‘¢ï¼Ÿè¿™æ˜¯ä¸æ˜ç™½å¤©åœ°çš„é“ç†ã€ä¸‡ç‰©çš„å®æƒ…æ‰ä¼šè¯´å‡ºçš„è¯ã€‚å°±åƒåªæ¥å—å¤©è€Œä¸æ¥å—åœ°ï¼Œåªæ¥å—é˜´è€Œä¸æ¥å—é˜³ï¼Œè¿™æ˜¾ç„¶æ˜¯è¡Œä¸é€šçš„ã€‚å¸ç‹ç¦…è®©è¿˜æ˜¯ç»§æ‰¿ï¼Œè¿™æ˜¯å› æ—¶äº‹è€Œå¼‚ã€‚é¡ºåº”æ—¶äº‹å’Œä¸–ä¿—ï¼Œä¼šè¢«ç§°ä¸ºä»äººä¹‰å£«ï¼Œè¿èƒŒæ—¶äº‹å’Œä¸–ä¿—ï¼Œä¼šè¢«ç§°ä¸ºå¤§é€†ä¸é“ã€‚æ²‰é»˜å§æ²³ä¼¯ï¼Œä½ å“ªçŸ¥é“æ€ä¹ˆåŒºåˆ†è´µè´±å’Œå¤§å°ã€‚ æ²³ä¼¯æ›°ï¼šâ€œç„¶åˆ™æˆ‘ä½•ä¸ºä¹ï¼Ÿä½•ä¸ä¸ºä¹ï¼Ÿå¾è¾å—è¶£èˆï¼Œå¾ç»ˆå¥ˆä½•ï¼Ÿâ€ åŒ—æµ·è‹¥æ›°ï¼šâ€œä»¥é“è§‚ä¹‹ï¼Œä½•è´µä½•è´±ï¼Œæ˜¯è°“åè¡ï¼›æ— æ‹˜è€Œå¿—ï¼Œä¸é“å¤§è¹‡ ã€‚ä½•å°‘ä½•å¤šï¼Œæ˜¯è°“è°¢æ–½ï¼›æ— ä¸€è€Œè¡Œï¼Œä¸é“å‚å·®ã€‚ä¸¥ä¹è‹¥å›½ä¹‹æœ‰å›ï¼Œå…¶æ— ç§å¾·ï¼›ç¹‡ç¹‡ä¹è‹¥ç¥­ä¹‹æœ‰ç¤¾ï¼Œå…¶æ— ç§ç¦ï¼›æ³›æ³›ä¹å…¶è‹¥å››æ–¹ä¹‹æ— ç©·ï¼Œå…¶æ— æ‰€ç•›åŸŸã€‚å…¼æ€€ä¸‡ç‰©ï¼Œå…¶å­°æ‰¿ç¿¼ï¼Ÿæ˜¯è°“æ— æ–¹ã€‚ä¸‡ç‰©ä¸€é½ï¼Œå­°çŸ­å­°é•¿ï¼Ÿ é“æ— ç»ˆå§‹ï¼Œç‰©æœ‰æ­»ç”Ÿï¼Œä¸æƒå…¶æˆã€‚ä¸€è™šä¸€æ»¡ï¼Œä¸ä½ä¹å…¶å½¢ã€‚å¹´ä¸å¯ä¸¾ ï¼Œæ—¶ä¸å¯æ­¢ã€‚æ¶ˆæ¯ç›ˆè™šï¼Œç»ˆåˆ™æœ‰å§‹ã€‚æ˜¯æ‰€ä»¥è¯­å¤§ä¹‰ä¹‹æ–¹ï¼Œè®ºä¸‡ç‰©ä¹‹ç†ä¹Ÿã€‚ç‰©ä¹‹ç”Ÿä¹Ÿï¼Œè‹¥éª¤è‹¥é©°ã€‚æ— åŠ¨è€Œä¸å˜ï¼Œæ— æ—¶è€Œä¸ç§»ã€‚ä½•ä¸ºä¹ï¼Œä½•ä¸ä¸ºä¹ï¼Ÿå¤«å›ºå°†è‡ªåŒ–ã€‚â€ æ²³ä¼¯è¯´ï¼šé‚£ä¹ˆæˆ‘åº”è¯¥åšä»€ä¹ˆï¼Œä¸åº”è¯¥åšä»€ä¹ˆå‘¢ï¼Ÿæˆ‘åº”è¯¥æ¥å—ä»€ä¹ˆï¼Œä¸åº”è¯¥æ¥å—ä»€ä¹ˆå‘¢ï¼ŸåŒ—æµ·è‹¥è¯´ï¼šä»é“çš„è§’åº¦çœ‹ï¼Œæ²¡æœ‰è´µè´±ä¹‹åˆ†ï¼Œè¦å›å½’é“çš„æœ¬æºã€‚è¦åšåˆ°æ— æ‹˜æ— æŸï¼Œå¿ƒæ€€å¤§é“ï¼Œé¡ºåº”å¤§é“ã€‚ä¸è¦è®¡è¾ƒç‰©è´¨çš„å¤šå°‘ï¼Œå­¦ä¼šèˆå¼ƒå¾—å¤±ã€‚è¦åšåˆ°æ— ç§ï¼Œæ— æ‰€è°“é•¿çŸ­ï¼Œä¸é“åŒåœ¨ã€‚è¦åƒå›½å®¶æœ‰å›ç‹ä¸€æ ·ä¸¥è‚ƒï¼Œä½†è¦æ— ç§åœ°è¡Œå¾·ã€‚è¦åƒç¥­ç¥€æœ‰ç¤¾ç¨·ä¸€æ ·åº„é‡ï¼Œä½†è¦è¿½æ±‚æ— ç§çš„ç¦æŠ¥ã€‚è¦åƒå››æ–¹ä¸€æ ·æ— è¾¹æ— é™…ï¼Œæ²¡æœ‰ç•Œé™ã€‚è¦åŒ…å®¹ä¸‡ç‰©ï¼Œæ²¡æœ‰å›ºå®šçš„æ–¹å‘ï¼Œè¿™å°±æ˜¯æ— æ–¹ã€‚ä¸è¦è®¡è¾ƒä¸‡ç‰©çš„çŸ­é•¿ï¼Œé“æ˜¯æ— å§‹æ— ç»ˆçš„ï¼Œä¸‡ç‰©åˆ™æœ‰ç”Ÿæœ‰æ­»ï¼Œä¸ä¾èµ–äºæˆå°±ã€‚ä¸€åˆ‡çš„è™šå®ã€ç›ˆè™šéƒ½ä¸å—å½¢æ€æ‰€é™ã€‚æ—¶é—´ä¸å¯æŒ½ç•™ï¼Œæ­¤è™šå½¼èµ¢ï¼Œæ­¤æ¶ˆå½¼é•¿ï¼Œè¿™é‡Œç»“æŸé‚£é‡Œå°±å¼€å§‹ï¼Œäº‹ç‰©äº§ç”Ÿåï¼Œå¦‚å¿«é©¬å¥”é©°èˆ¬æ€¥é€Ÿå˜åŒ–ï¼Œä¸€åˆ»ä¹Ÿä¸ä¼šåœæ­¢ã€‚æ‰€ä»¥åº”è¯¥åšä»€ä¹ˆä¸åº”è¯¥åšä»€ä¹ˆï¼Ÿäº‹ç‰©æœ¬èº«å°±åœ¨ä¸æ–­å˜åŒ–ç€å•Šã€‚ æ²³ä¼¯æ›°ï¼šâ€œç„¶åˆ™ä½•è´µäºé“é‚ªï¼Ÿâ€åŒ—æµ·è‹¥æ›°ï¼šâ€œçŸ¥é“è€…å¿…è¾¾äºç†ï¼Œè¾¾ äºç†è€…å¿…æ˜äºæƒï¼Œæ˜äºæƒè€…ä¸ä»¥ç‰©å®³å·±ã€‚è‡³å¾·è€…ï¼Œç«å¼—èƒ½çƒ­ï¼Œæ°´å¼—èƒ½æººï¼Œå¯’æš‘å¼—èƒ½å®³ï¼Œç¦½å…½å¼—èƒ½è´¼ã€‚éè°“å…¶è–„ä¹‹ä¹Ÿï¼Œè¨€å¯Ÿä¹å®‰å±ï¼Œå®äºç¥¸ç¦ï¼Œè°¨äºå»å°±ï¼Œè«ä¹‹èƒ½å®³ä¹Ÿã€‚æ•…æ›°ï¼šâ€˜å¤©åœ¨å†…ï¼Œäººåœ¨å¤–ï¼Œå¾·åœ¨ä¹å¤©ã€‚ â€™çŸ¥å¤©äººä¹‹è¡Œï¼Œæœ¬ä¹å¤©ï¼Œä½ä¹å¾—ï¼Œè¸¯èº…è€Œå±ˆä¼¸ï¼Œåè¦è€Œè¯­æã€‚â€æ›°ï¼š â€œä½•è°“å¤©ï¼Ÿä½•è°“äººï¼Ÿâ€åŒ—æµ·è‹¥æ›°ï¼šâ€œç‰›é©¬å››è¶³ï¼Œæ˜¯è°“å¤©ï¼›è½é©¬é¦–ï¼Œç©¿ç‰›é¼»ï¼Œæ˜¯è°“äººã€‚æ•…æ›°ï¼šâ€˜æ— ä»¥äººç­å¤©ï¼Œæ— ä»¥æ•…ç­å‘½ï¼Œæ— ä»¥å¾—æ®‰åã€‚è°¨å®ˆè€Œå‹¿å¤±ï¼Œæ˜¯è°“åå…¶çœŸã€‚â€˜â€œ æ²³ä¼¯è¯´ï¼šé‚£ä¹ˆå¤§é“æœ‰ä»€ä¹ˆç”¨å‘¢ï¼ŸåŒ—æµ·è‹¥è¯´ï¼šçŸ¥æ™“å¤§é“ï¼Œå°±èƒ½é€šè¾¾äº‹ç‰©çš„é“ç†ï¼Œé€šè¾¾äº‹ç‰©çš„é“ç†ï¼Œå°±èƒ½æ‡‚å¾—éšæœºåº”å˜ï¼Œæ‡‚å¾—éšæœºåº”å˜ï¼Œä¹Ÿå°±ä¸ä¼šè®©å¤–ç‰©ä¾µå®³è‡ªå·±ã€‚å¾—åˆ°ä¹‹äººï¼Œç«ä¸èƒ½çƒ§ï¼Œæ°´ä¸èƒ½æ·¹ï¼Œå¯’æš‘ä¸èƒ½ä¾µæ‰°ï¼Œç¦½å…½ä¸èƒ½ä¼¤å®³ã€‚å¹¶ä¸æ˜¯è¯´ä»–èƒ½å¤Ÿå¯¹æŠ—è¿™äº›ä¸œè¥¿ï¼Œè€Œæ˜¯è¯´ä»–æ‡‚å¾—è§‚å¯Ÿå®‰æ…°ï¼Œå¹¶èƒ½åœ¨ç¦ç¥¸ä¹‹ä¸­ä¿æŒå®‰ç¨³çš„å¿ƒæ€ï¼Œèƒ½å¤Ÿè°¨æ…çš„è¿›é€€ï¼Œä¹Ÿå°±æ²¡æœ‰ä»€ä¹ˆèƒ½å¤Ÿä¼¤å®³ä»–ä»¬äº†ã€‚æ‰€ä»¥è¯´ï¼šå¤©é“æ˜¯å†…åœ¨çš„æ ¹æºï¼Œäººä¸ºæ˜¯å¤–åœ¨çš„è¡¨è±¡ï¼ŒçœŸæ­£çš„å¾·åœ¨äºéµå¾ªå¤©é“ï¼Œæ˜ç™½ä¸€åˆ‡äººäº‹ï¼Œæœ¬æºæ˜¯å¤©é“ã€‚äº†è§£å¤©ä¸äººçš„è§„å¾‹ï¼Œè¦éµå¾ªè‡ªç„¶æ³•åˆ™ï¼Œæ‰¾åˆ°æ°å½“çš„ä½ç½®ï¼Œçµæ´»é€‚åº”å„ç§æƒ…å†µï¼Œå›å½’æ ¹æœ¬ï¼Œæ¢ç©¶æè‡´ã€‚æ²³ä¼¯é—®ï¼šä»€ä¹ˆæ˜¯å¤©ï¼Ÿä»€ä¹ˆæ˜¯äººï¼ŸåŒ—æµ·è‹¥è¯´ï¼šç‰›å’Œé©¬é•¿äº†å››æ¡è…¿ï¼Œè¿™å°±æ˜¯å¤©é“ï¼ŒæŠŠè¾”å¤´è£…åœ¨é©¬å¤´ï¼ŒæŠŠç‰›é¼»å­ç©¿å­”ï¼Œè¿™å°±æ˜¯è®¤ä¸ºã€‚æ‰€ä»¥è¯´ï¼šä¸èƒ½è®©äººä¸ºç ´åè‡ªç„¶æ³•åˆ™ï¼Œä¸èƒ½è®©é€ ä½œæ¯ç­æ€§å‘½ï¼Œä¸ä»¥è´ªæ¬²è¿½æ±‚è™šåï¼Œå®ˆä½è‡ªç„¶çš„å¤©æ€§ï¼Œè¿™å°±å«åšè¿”å›æœ€åˆçš„æœ¬çœŸã€‚ å¤”æ€œèš¿ï¼Œèš¿æ€œè›‡ï¼Œè›‡æ€œé£ï¼Œé£æ€œç›®ï¼Œç›®æ€œå¿ƒã€‚å¤”è°“èš¿æ›°ï¼šâ€œå¾ä»¥ä¸€ è¶³è¶»è¸”è€Œä¸è¡Œï¼Œäºˆæ— å¦‚çŸ£ã€‚ä»Šå­ä¹‹ä½¿ä¸‡è¶³ï¼Œç‹¬å¥ˆä½•ï¼Ÿâ€èš¿æ›°ï¼šâ€œä¸ç„¶ã€‚ å­ä¸è§å¤«å”¾è€…ä¹ï¼Ÿå–·åˆ™å¤§è€…å¦‚ç ï¼Œå°è€…å¦‚é›¾ï¼Œæ‚è€Œä¸‹è€…ä¸å¯èƒœæ•°ä¹Ÿã€‚ ä»ŠäºˆåŠ¨å¾å¤©æœºï¼Œè€Œä¸çŸ¥å…¶æ‰€ä»¥ç„¶ã€‚â€èš¿è°“è›‡æ›°ï¼šâ€œå¾ä»¥ä¼—è¶³è¡Œï¼Œè€Œä¸åŠå­ä¹‹æ— è¶³ï¼Œä½•ä¹Ÿï¼Ÿâ€è›‡æ›°ï¼šâ€œå¤«å¤©æœºä¹‹æ‰€åŠ¨ï¼Œä½•å¯æ˜“é‚ªï¼Ÿå¾å®‰ç”¨è¶³ å“‰ï¼â€è›‡è°“é£æ›°ï¼šâ€œäºˆåŠ¨å¾è„Šèƒè€Œè¡Œï¼Œåˆ™æœ‰ä¼¼ä¹Ÿã€‚ä»Šå­è“¬è“¬ç„¶èµ·äºåŒ—æµ·ï¼Œè“¬è“¬ç„¶å…¥äºå—æµ·ï¼Œè€Œä¼¼æ— æœ‰ï¼Œä½•ä¹Ÿï¼Ÿâ€é£æ›°ï¼šâ€œç„¶ï¼Œäºˆè“¬è“¬ç„¶èµ·äºåŒ—æµ·è€Œå…¥äºå—æµ·ä¹Ÿï¼Œç„¶è€ŒæŒ‡æˆ‘åˆ™èƒœæˆ‘ï¼Œé°Œæˆ‘äº¦èƒœæˆ‘ã€‚è™½ç„¶ï¼Œå¤«æŠ˜å¤§æœ¨ï¼Œèœšå¤§å±‹è€…ï¼Œå”¯æˆ‘èƒ½ä¹Ÿã€‚â€æ•…ä»¥ä¼—å°ä¸èƒœä¸ºå¤§èƒœä¹Ÿã€‚ä¸ºå¤§èƒœè€…ï¼Œå”¯åœ£äººèƒ½ä¹‹ã€‚ ç‹¬è„šå…½ç¾¡æ…•å¤šè¶³è™«ï¼Œå¤šè¶³è™«ç¾¡æ…•è›‡ï¼Œè›‡ç¾¡æ…•é£ï¼Œé£ç¾¡æ…•çœ¼ï¼Œçœ¼ç¾¡æ…•å¿ƒã€‚ç‹¬è„šå…½è·Ÿå¤šè¶³è™«è¯´ï¼šæˆ‘ç”¨ä¸€æ¡è…¿èµ°è·¯éƒ½å›°éš¾ï¼Œä½ æ˜¯æ€ä¹ˆç”¨é‚£ä¹ˆå¤šæ¡è…¿èµ°è·¯çš„å‘¢ï¼Ÿå¤šè¶³è™«è¯´ï¼šæˆ‘ä¹Ÿæ˜¯è‡ªç„¶è¡Œèµ°ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆè¿™æ ·ã€‚å¤šè¶³è™«é—®è›‡ï¼šæˆ‘ç”¨è¿™ä¹ˆå¤šæ¡è…¿èµ°è·¯ç»“æœè¿˜ä¸å¦‚ä½ ä¸ç”¨è…¿èµ°è·¯èµ°å¾—å¿«ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿè›‡è¯´ï¼šè¿™æ˜¯å¤©ç„¶çš„æœºåˆ¶ï¼Œæ”¹å˜ä¸äº†çš„ï¼Œæˆ‘å“ªç”¨å¾—ç€è„šå‘¢ï¼Ÿè›‡å¯¹é£è¯´ï¼šæˆ‘ç”¨èº«ä½“èµ°è·¯è¿˜æœ‰å½¢è¿¹ï¼Œä½ å‘¼å‘¼ä»åŒ—æµ·å¹åˆ°å—æµ·ï¼Œä¸€ç‚¹å½¢è¿¹ä¹Ÿæ²¡æœ‰ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿé£è¯´ï¼šæ˜¯çš„ï¼Œæˆ‘èƒ½å‘¼å‘¼çš„ä»åŒ—æµ·å¹åˆ°å—æµ·ï¼Œä½†æ˜¯æ‰‹æŒ‡è„šè¸¢æˆ‘åšä¸åˆ°å•Šã€‚ä½†æ˜¯ï¼Œå¹æ–­å¤§æ ‘ï¼Œå¹ç¿»æˆ¿å­åªæœ‰æˆ‘èƒ½åšåˆ°ã€‚æ‰€ä»¥ï¼Œä»¥åšä¸æˆä¼—å¤šå°äº‹ä¸ºä»£ä»·ï¼Œæˆå°±å¤§äº‹ï¼Œåªæœ‰åœ£äººèƒ½åšåˆ°ã€‚ å­”å­æ¸¸äºåŒ¡ï¼Œå®‹äººå›´ä¹‹æ•°å¸ï¼Œè€Œå¼¦æ­Œä¸æƒ™ã€‚å­è·¯å…¥è§ï¼Œæ›°ï¼šâ€œä½•å¤«å­ä¹‹å¨±ä¹Ÿï¼Ÿâ€å­”å­æ›°ï¼šâ€œæ¥ï¼Œå¾è¯­å¥³ï¼æˆ‘è®³ç©·ä¹…çŸ£ï¼Œè€Œä¸å…ï¼Œå‘½ä¹Ÿï¼›æ±‚é€šä¹…çŸ£ï¼Œè€Œä¸å¾—ï¼Œæ—¶ä¹Ÿã€‚å½“å°§ã€èˆœè€Œå¤©ä¸‹æ— ç©·äººï¼ŒéçŸ¥å¾—ä¹Ÿï¼›å½“æ¡€ã€çº£è€Œå¤©ä¸‹æ— é€šäººï¼ŒéçŸ¥å¤±ä¹Ÿã€‚æ—¶åŠ¿é€‚ç„¶ã€‚å¤«æ°´è¡Œä¸é¿è›Ÿé¾™è€…ï¼Œæ¸”äººä¹‹å‹‡ä¹Ÿã€‚é™†è¡Œä¸é¿å…•è™è€…ï¼ŒçŒå¤«ä¹‹å‹‡ä¹Ÿã€‚ç™½åˆƒäº¤äºå‰ï¼Œè§†æ­»è‹¥ç”Ÿè€…ï¼Œçƒˆå£«ä¹‹å‹‡ä¹Ÿã€‚çŸ¥ç©·ä¹‹æœ‰å‘½ï¼ŒçŸ¥é€šä¹‹æœ‰æ—¶ï¼Œä¸´å¤§éš¾è€Œä¸æƒ§è€…ï¼Œåœ£äººä¹‹å‹‡ä¹Ÿã€‚ç”±ï¼Œå¤„çŸ£ï¼å¾å‘½æœ‰æ‰€åˆ¶çŸ£ï¼â€ æ— å‡ ä½•ï¼Œå°†ç”²è€…è¿›ï¼Œè¾æ›°ï¼šâ€œä»¥ä¸ºé˜³è™ä¹Ÿï¼Œæ•…å›´ä¹‹ï¼›ä»Šéä¹Ÿï¼Œè¯·è¾è€Œé€€ã€‚â€ å­”å­å‘¨æ¸¸åˆ°åŒ¡åœ°ï¼Œå«å›½äººä¸€å±‚åˆä¸€å±‚åœ°åŒ…å›´äº†ä»–ï¼Œå¯æ˜¯å­”å­ä»åœ¨ä¸åœåœ°å¼¹ç´è¯µè¯»ã€‚å­è·¯è¿›å»è§å­”å­è¯´ï¼šâ€œå…ˆç”Ÿå¦‚æ­¤å¿«ä¹æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿâ€å­”å­è¯´ï¼šâ€œæ¥ï¼Œæˆ‘å‘Šè¯‰ä½ ï¼æˆ‘ä¸æƒ³è®©è‡ªå·±å›°è‹¦å·²ç»å¾ˆä¹…å¾ˆä¹…äº†ï¼Œå¯æ˜¯å§‹ç»ˆä¸èƒ½å…é™¤ï¼Œè¿™æ˜¯å‘½è¿å•Šã€‚æˆ‘å¯»æ±‚é€šè¾¾ä¹Ÿå·²ç»å¾ˆä¹…å¾ˆä¹…äº†ï¼Œå¯æ˜¯å§‹ç»ˆæœªèƒ½è¾¾åˆ°ï¼Œè¿™æ˜¯æ—¶è¿å•Šã€‚å½“å°§ã€èˆœçš„æ—¶ä»£ï¼Œå¤©ä¸‹æ²¡æœ‰ä¸€ä¸ªå›°é¡¿æ½¦å€’çš„äººï¼Œå¹¶éå› ä¸ºä»–ä»¬éƒ½æ‰æ™ºè¶…äººï¼›å½“æ¡€ã€çº£çš„æ—¶ä»£ï¼Œå¤©ä¸‹æ²¡æœ‰ä¸€ä¸ªé€šè¾¾çš„äººï¼Œå¹¶éå› ä¸ºä»–ä»¬éƒ½æ‰æ™ºä½ä¸‹ã€‚è¿™éƒ½æ˜¯æ—¶è¿æ‰€é€ æˆçš„ã€‚åœ¨æ°´é‡Œæ´»åŠ¨è€Œä¸èº²é¿è›Ÿé¾™çš„ï¼Œä¹ƒæ˜¯æ¸”å¤«çš„å‹‡æ•¢ï¼›åœ¨é™†ä¸Šæ´»åŠ¨è€Œä¸èº²é¿çŠ€ç‰›è€è™çš„ï¼Œä¹ƒæ˜¯çŒäººçš„å‹‡æ•¢ï¼›åˆ€å‰‘äº¤é”™åœ°æ¨ªäºçœ¼å‰ï¼Œçœ‹å¾…æ­»äº¡çŠ¹å¦‚ç”Ÿè¿˜çš„ï¼Œä¹ƒæ˜¯å£®çƒˆä¹‹å£«çš„å‹‡æ•¢ã€‚æ‡‚å¾—å›°å„æ½¦å€’ä¹ƒæ˜¯å‘½ä¸­æ³¨å®šï¼ŒçŸ¥é“é¡ºåˆ©é€šè¾¾ä¹ƒæ˜¯æ—¶è¿é€ æˆï¼Œé¢ä¸´å¤§éš¾è€Œä¸ç•æƒ§çš„ï¼Œè¿™å°±æ˜¯åœ£äººçš„å‹‡æ•¢ã€‚ä»²ç”±å•Šï¼Œä½ è¿˜æ˜¯ä¼‘æ¯å»å§ï¼æˆ‘è¿™æ˜¯å‘½ä¸­æ³¨å®šï¼â€ å…¬å­™é¾™é—®äºé­ç‰Ÿæ›°ï¼šâ€œé¾™å°‘å­¦å…ˆç‹ä¹‹é“ï¼Œé•¿è€Œæ˜ä»ä¹‰ä¹‹è¡Œï¼›åˆåŒå¼‚ ï¼Œç¦»åšç™½ï¼›ç„¶ä¸ç„¶ï¼Œå¯ä¸å¯ï¼›å›°ç™¾å®¶ä¹‹çŸ¥ï¼Œç©·ä¼—å£ä¹‹è¾©ï¼šå¾è‡ªä»¥ä¸ºè‡³ è¾¾å·²ã€‚ä»Šå¾é—»åº„å­ä¹‹è¨€ï¼ŒèŒ«ç„¶å¼‚ä¹‹ã€‚ä¸çŸ¥è®ºä¹‹ä¸åŠä¸ï¼ŸçŸ¥ä¹‹å¼—è‹¥ä¸ï¼Ÿ ä»Šå¾æ— æ‰€å¼€å¾å–™ï¼Œæ•¢é—®å…¶æ–¹ã€‚â€å…¬å­ç‰Ÿéšæœºå¤§æ¯ï¼Œä»°å¤©è€Œç¬‘æ›°ï¼šâ€œå­ ç‹¬ä¸é—»å¤«åŸ³äº•ä¹‹è›™ä¹ï¼Ÿè°“ä¸œæµ·ä¹‹é³–æ›°ï¼šâ€˜å¾ä¹ä¸ï¼å‡ºè·³æ¢ä¹äº•å¹²ä¹‹ä¸Šï¼Œ å…¥ä¼‘ä¹ç¼ºç”ƒä¹‹å´–ã€‚èµ´æ°´åˆ™æ¥è…‹æŒé¢ï¼Œè¹¶æ³¥åˆ™æ²¡è¶³ç­è·—ã€‚è¿˜è™·èŸ¹ä¸ç§‘æ–—ï¼Œ è«å¾èƒ½è‹¥ä¹Ÿã€‚ä¸”å¤«æ“…ä¸€å£‘ä¹‹æ°´ï¼Œè€Œè·¨è·±åŸ³äº•ä¹‹ä¹ï¼Œæ­¤äº¦è‡³çŸ£ã€‚å¤«å­å¥šä¸æ—¶æ¥å…¥è§‚ä¹ï¼Ÿâ€™ä¸œæµ·ä¹‹é³–å·¦è¶³æœªå…¥ï¼Œè€Œå³è†å·²çµ·çŸ£ã€‚äºæ˜¯é€¡å·¡è€Œå´ï¼Œ å‘Šä¹‹æµ·æ›°ï¼šâ€˜å¤«åƒé‡Œä¹‹è¿œï¼Œä¸è¶³ä»¥ä¸¾å…¶å¤§ï¼›åƒä»ä¹‹é«˜ï¼Œä¸è¶³ä»¥æå…¶æ·±ã€‚ ç¦¹ä¹‹æ—¶ï¼Œåå¹´ä¹æ½¦ï¼Œè€Œæ°´å¼—ä¸ºåŠ ç›Šï¼›æ±¤ä¹‹æ—¶ï¼Œå…«å¹´ä¸ƒæ—±ï¼Œè€Œå´–ä¸ä¸ºåŠ æŸã€‚å¤«ä¸ä¸ºé¡·ä¹…æ¨ç§»ï¼Œä¸ä»¥å¤šå°‘è¿›é€€è€…ï¼Œæ­¤äº¦ä¸œæµ·ä¹‹å¤§ä¹ä¹Ÿã€‚â€™äºæ˜¯ åŸ³äº•ä¹‹è›™é—»ä¹‹ï¼Œé€‚é€‚ç„¶æƒŠï¼Œè§„è§„ç„¶è‡ªå¤±ä¹Ÿã€‚ä¸”å¤«çŸ¥ä¸çŸ¥æ˜¯éä¹‹ç«Ÿï¼Œè€Œ çŠ¹æ¬²è§‚äºåº„å­ä¹‹è¨€ï¼Œæ˜¯çŠ¹ä½¿èšŠè´Ÿå±±ï¼Œå•†èš·é©°æ²³ä¹Ÿï¼Œå¿…ä¸èƒœä»»çŸ£ã€‚ä¸”å¤« çŸ¥ä¸çŸ¥è®ºæå¦™ä¹‹è¨€ï¼Œè€Œè‡ªé€‚ä¸€æ—¶ä¹‹åˆ©è€…ï¼Œæ˜¯éåŸ³äº•ä¹‹è›™ä¸ï¼Ÿä¸”å½¼æ–¹è· é»„æ³‰è€Œç™»å¤§çš‡ï¼Œæ— å—æ— åŒ—ï¼Œçˆ½ç„¶å››è§£ï¼Œæ²¦äºä¸æµ‹ï¼›æ— ä¸œæ— è¥¿ï¼Œå§‹äºç„å†¥ï¼Œåäºå¤§é€šã€‚å­ä¹ƒè§„è§„ç„¶è€Œæ±‚ä¹‹ä»¥å¯Ÿï¼Œç´¢ä¹‹ä»¥è¾©ï¼Œæ˜¯ç›´ç”¨ç®¡çª¥å¤©ï¼Œ ç”¨é”¥æŒ‡åœ°ä¹Ÿï¼Œä¸äº¦å°ä¹ï¼Ÿå­å¾€çŸ£ï¼ä¸”å­ç‹¬ä¸é—»å¤«å¯¿é™µä½™å­ä¹‹å­¦äºé‚¯éƒ¸ ä¸ï¼Ÿæœªå¾—å›½èƒ½ï¼Œåˆå¤±å…¶æ•…è¡ŒçŸ£ï¼Œç›´åŒåŒè€Œå½’è€³ã€‚ä»Šå­ä¸å»ï¼Œå°†å¿˜å­ä¹‹æ•…ï¼Œå¤±å­ä¹‹ä¸šã€‚â€å…¬å­™é¾™å£å‘¿è€Œä¸åˆï¼ŒèˆŒä¸¾è€Œä¸ä¸‹ï¼Œä¹ƒé€¸è€Œèµ°ã€‚ å…¬å­™é¾™å‘é­ç‰Ÿé—®é“ï¼šâ€œæˆ‘å¹´å°‘çš„æ—¶å€™å­¦ä¹ å¤ä»£åœ£ç‹çš„ä¸»å¼ ï¼Œé•¿å¤§ä»¥åæ‡‚å¾—äº†ä»ä¹‰çš„è¡Œä¸ºï¼›èƒ½å¤ŸæŠŠäº‹ç‰©çš„ä¸åŒä¸ç›¸åŒåˆè€Œä¸ºä¸€ï¼ŒæŠŠä¸€ä¸ªç‰©ä½“çš„è´¨åœ°åšç¡¬ä¸é¢œè‰²æ´ç™½åˆ†ç¦»å¼€æ¥ï¼›èƒ½å¤ŸæŠŠä¸å¯¹çš„è¯´æˆæ˜¯å¯¹çš„ï¼ŒæŠŠä¸åº”è®¤å¯çš„çœ‹ä½œæ˜¯åˆå®œçš„ï¼›èƒ½å¤Ÿä½¿ç™¾å®¶æ™ºå£«å›°æƒ‘ä¸è§£ï¼Œèƒ½å¤Ÿä½¿ä¼—å¤šå–„è¾©ä¹‹å£ç†å±ˆè¾ç©·ï¼šæˆ‘è‡ªä»¥ä¸ºæ˜¯æœ€ä¸ºé€šè¾¾çš„äº†ã€‚å¦‚ä»Šæˆ‘å¬äº†åº„å­çš„è¨€è°ˆï¼Œæ„Ÿåˆ°ååˆ†èŒ«ç„¶ã€‚ä¸çŸ¥æ˜¯æˆ‘çš„è®ºè¾©æ¯”ä¸ä¸Šä»–å‘¢ï¼Œè¿˜æ˜¯æˆ‘çš„çŸ¥è¯†ä¸å¦‚ä»–å‘¢ï¼Ÿç°åœ¨æˆ‘å·²ç»æ²¡æœ‰åŠæ³•å†å¼€å£äº†ï¼Œå†’æ˜§åœ°å‘ä½ è¯·æ•™å…¶ä¸­çš„é“ç†ã€‚â€ é­ç‰Ÿé ç€å‡ æ¡ˆæ·±æ·±åœ°å¹äº†å£æ°”ï¼Œç„¶ååˆä»°å¤´æœå¤©ç¬‘ç€è¯´ï¼šâ€œä½ ä¸æ›¾å¬è¯´è¿‡é‚£æµ…äº•é‡Œçš„é’è›™å—ï¼Ÿäº•è›™å¯¹ä¸œæµ·é‡Œçš„é³–è¯´ï¼šâ€˜æˆ‘å®åœ¨å¿«ä¹å•Šï¼æˆ‘è·³è·ƒç©è€äºäº•å£æ æ†ä¹‹ä¸Šï¼Œè¿›åˆ°äº•é‡Œä¾¿åœ¨äº•å£ç –å—ç ´æŸä¹‹å¤„ä¼‘æ¯ã€‚è·³å…¥æ°´ä¸­äº•æ°´æ¼«å…¥è…‹ä¸‹å¹¶ä¸”æ‰˜èµ·æˆ‘çš„ä¸‹å·´ï¼Œè¸å…¥æ³¥é‡Œæ³¥æ°´å°±ç›–ä½äº†æˆ‘çš„è„šèƒŒï¼Œå›è¿‡å¤´æ¥çœ‹çœ‹æ°´ä¸­çš„é‚£äº›èµ¤è™«ã€å°èŸ¹å’ŒèŒèšªï¼Œæ²¡æœ‰è°èƒ½åƒæˆ‘è¿™æ ·çš„å¿«ä¹ï¼å†è¯´æˆ‘ç‹¬å ä¸€å‘ä¹‹æ°´ã€ç›˜è¸ä¸€å£æµ…äº•çš„å¿«ä¹ï¼Œè¿™ä¹Ÿæ˜¯æå…¶ç§°å¿ƒå¦‚æ„çš„äº†ã€‚ä½ æ€ä¹ˆä¸éšæ—¶æ¥äº•é‡Œçœ‹çœ‹å‘¢ï¼Ÿâ€™ä¸œæµ·ä¹‹é³–å·¦è„šè¿˜æœªèƒ½è·¨å…¥æµ…äº•ï¼Œå³è†å°±å·²ç»è¢«ç»Šä½ã€‚äºæ˜¯è¿Ÿç–‘äº†ä¸€é˜µå­ä¹‹ååˆæŠŠè„šé€€äº†å‡ºæ¥ï¼ŒæŠŠå¤§æµ·çš„æƒ…å†µå‘Šè¯‰ç»™æµ…äº•çš„é’è›™ï¼Œè¯´ï¼šâ€˜åƒé‡Œçš„é¥è¿œï¼Œä¸è¶³ä»¥ç§°è¿°å®ƒçš„å¤§ï¼›åƒä»çš„é«˜æ—·ï¼Œä¸è¶³äºæ¢ç©¶å®ƒçš„æ·±ã€‚å¤ç¦¹æ—¶ä»£åå¹´é‡Œæœ‰ä¹å¹´æ°´æ¶ï¼Œè€Œæµ·æ°´ä¸ä¼šå› æ­¤å¢å¤šï¼›å•†æ±¤çš„æ—¶ä»£å…«å¹´é‡Œæœ‰ä¸ƒå¹´å¤§æ—±ï¼Œè€Œå²¸è¾¹çš„æ°´ä½ä¸ä¼šå› æ­¤ä¸‹é™ã€‚ä¸å› ä¸ºæ—¶é—´çš„çŸ­æš‚ä¸é•¿ä¹…è€Œæœ‰æ‰€æ”¹å˜ï¼Œä¸å› ä¸ºé›¨é‡çš„å¤šå°‘è€Œæœ‰æ‰€å¢å‡ï¼Œè¿™å°±æ˜¯ä¸œæµ·æœ€å¤§çš„å¿«ä¹ã€‚â€™æµ…äº•ä¹‹è›™å¬äº†è¿™ä¸€å¸­è¯ï¼ŒæƒŠæƒ¶ä¸å®‰ï¼ŒèŒ«ç„¶ä¸çŸ¥æ‰€æªã€‚å†è¯´ä½ å…¬å­™é¾™çš„æ‰æ™ºè¿˜ä¸è¶³ä»¥çŸ¥æ™“æ˜¯ä¸éçš„å¢ƒç•Œï¼Œå´è¿˜æƒ³å»å¯Ÿæ‚‰åº„å­çš„è¨€è°ˆï¼Œè¿™å°±åƒé©±ä½¿èšŠè™«å»èƒŒè´Ÿå¤§å±±ï¼Œé©±ä½¿é©¬èš¿è™«åˆ°æ²³æ°´é‡Œå»å¥”è·‘ï¼Œå¿…å®šæ˜¯ä¸èƒ½èƒœä»»çš„ã€‚è€Œä½ çš„æ‰æ™ºä¸è¶³ä»¥é€šæ™“æå…¶ç„å¦™çš„è¨€è®ºï¼Œç«Ÿè‡ªå»è¿åˆé‚£äº›ä¸€æ—¶çš„èƒœåˆ©ï¼Œè¿™ä¸å°±åƒæ˜¯æµ…äº•é‡Œçš„é’è›™å—ï¼Ÿå†µä¸”åº„å­çš„æ€æƒ³ä¸»å¼ æ­£ä¿¯æé»„æ³‰ç™»ä¸´è‹å¤©ï¼Œä¸è®ºå—åŒ—ï¼Œé‡Šç„¶å››æ•£é€šè¾¾æ— é˜»ï¼Œæ·±å¹½æ²‰å¯‚ä¸å¯æ¢æµ‹ï¼›ä¸è®ºä¸œè¥¿ï¼Œèµ·äºå¹½æ·±ç„å¦™ä¹‹å¢ƒï¼Œè¿”å½’å¹¿é˜”é€šè¾¾ä¹‹åŸŸã€‚ä½ ç«Ÿæ‹˜æ³¥æµ…é™‹åœ°ç”¨å¯Ÿè§†çš„åŠæ³•å»æ¢å¯»å®ƒçš„å¥¥å¦™ï¼Œç”¨è®ºè¾©çš„è¨€è¾å»ç´¢æ±‚å®ƒçš„çœŸè°›ï¼Œè¿™åªä¸è¿‡æ˜¯ç”¨ç«¹ç®¡å»çª¥è§†é«˜è¿œçš„è‹å¤©ï¼Œç”¨é”¥å­å»æµ‹é‡æµ‘åšçš„å¤§åœ°ï¼Œä¸æ˜¯å¤ªæ¸ºå°äº†å—ï¼ä½ è¿˜æ˜¯èµ°å§ï¼è€Œä¸”ä½ å°±ä¸æ›¾å¬è¯´è¿‡é‚£ç‡•å›½å¯¿é™µçš„å°å­åˆ°èµµå›½çš„é‚¯éƒ¸å»å­¦ä¹ èµ°æ­¥ä¹‹äº‹å—ï¼Ÿæœªèƒ½å­¦ä¼šèµµå›½çš„æœ¬äº‹ï¼Œåˆä¸¢æ‰äº†ä»–åŸæ¥çš„æœ¬é¢†ï¼Œæœ€ååªå¾—çˆ¬ç€å›å»äº†ã€‚ç°åœ¨ä½ è¿˜ä¸å°½å¿«ç¦»å¼€æˆ‘è¿™é‡Œï¼Œå¿…å°†å¿˜æ‰ä½ åŸæœ‰çš„æœ¬é¢†ï¼Œè€Œä¸”ä¹Ÿå¿…å°†å¤±å»ä½ åŸæœ‰çš„å­¦ä¸šã€‚â€ å…¬å­™é¾™å¬äº†è¿™ä¸€ç•ªè¯å¼ å¤§ç€å£è€Œä¸èƒ½åˆæ‹¢ï¼ŒèˆŒå¤´é«˜é«˜æŠ¬èµ·è€Œä¸èƒ½æ”¾ä¸‹ï¼Œäºæ˜¯å¿«é€Ÿåœ°é€ƒèµ°äº†ã€‚ åº„å­é’“äºæ¿®æ°´ã€‚æ¥šç‹ä½¿å¤§å¤«äºŒäººå¾€å…ˆç„‰ï¼Œæ›°ï¼šâ€œæ„¿ä»¥å¢ƒå†…ç´¯çŸ£ï¼â€ åº„å­æŒç«¿ä¸é¡¾ï¼Œæ›°ï¼šâ€œå¾é—»æ¥šæœ‰ç¥é¾Ÿï¼Œæ­»å·²ä¸‰åƒå²çŸ£ã€‚ç‹å·¾ç¬¥è€Œè—ä¹‹åº™å ‚ä¹‹ä¸Šã€‚æ­¤é¾Ÿè€…ï¼Œå®å…¶æ­»ä¸ºç•™éª¨è€Œè´µä¹ï¼Ÿå®å…¶ç”Ÿè€Œæ›³å°¾äºæ¶‚ä¸­ä¹ï¼Ÿ â€äºŒå¤§å¤«æ›°ï¼šâ€œå®ç”Ÿè€Œæ›³å°¾æ¶‚ä¸­ã€‚â€åº„å­æ›°ï¼šâ€œå¾€çŸ£ï¼å¾å°†æ›³å°¾äºæ¶‚ä¸­ã€‚â€ æƒ å­ç›¸æ¢ï¼Œåº„å­å¾€è§ä¹‹ã€‚æˆ–è°“æƒ å­æ›°ï¼šâ€œåº„å­æ¥ï¼Œæ¬²ä»£å­ç›¸ã€‚â€äº æ˜¯æƒ å­æï¼Œæœäºå›½ä¸­ä¸‰æ—¥ä¸‰å¤œã€‚åº„å­å¾€è§ä¹‹ï¼Œæ›°ï¼šâ€œå—æ–¹æœ‰é¸Ÿï¼Œå…¶å ä¸ºé¹“é¹ï¼Œå­çŸ¥ä¹‹ä¹ï¼Ÿå¤«é¹“é¹å‘äºå—æµ·è€Œé£äºåŒ—æµ·ï¼Œéæ¢§æ¡ä¸æ­¢ï¼Œéç»ƒ å®ä¸é£Ÿï¼Œéé†´æ³‰ä¸é¥®ã€‚äºæ˜¯é¸±å¾—è…é¼ ï¼Œé¹“é¹è¿‡ä¹‹ï¼Œä»°è€Œè§†ä¹‹æ›°ï¼šâ€˜å“ï¼â€™ ä»Šå­æ¬²ä»¥å­ä¹‹æ¢å›½è€Œå“æˆ‘é‚ªï¼Ÿâ€ åº„å­ä¸æƒ å­æ¸¸äºæ¿ æ¢ä¹‹ä¸Šã€‚åº„å­æ›°ï¼šâ€œå„µé±¼å‡ºæ¸¸ä»å®¹ï¼Œæ˜¯é±¼ä¹‹ä¹ä¹Ÿã€‚â€ æƒ å­æ›°âˆ¶â€œå­éé±¼ï¼Œå®‰çŸ¥é±¼ä¹‹ä¹ï¼Ÿâ€åº„å­æ›°ï¼šâ€œå­éæˆ‘ï¼Œå®‰çŸ¥æˆ‘ä¸çŸ¥ é±¼ä¹‹ä¹ï¼Ÿâ€æƒ å­æ›°â€œæˆ‘éå­ï¼Œå›ºä¸çŸ¥å­çŸ£ï¼›å­å›ºéé±¼ä¹Ÿï¼Œå­ä¹‹ä¸çŸ¥é±¼ ä¹‹ä¹ï¼Œå…¨çŸ£ï¼â€åº„å­æ›°ï¼šâ€œè¯·å¾ªå…¶æœ¬ã€‚å­æ›°â€˜æ±å®‰çŸ¥é±¼ä¹â€™äº‘è€…ï¼Œæ—¢ å·²çŸ¥å¾çŸ¥ä¹‹è€Œé—®æˆ‘ã€‚æˆ‘çŸ¥ä¹‹æ¿ ä¸Šä¹Ÿã€‚â€ åº„å­åœ¨æ¿®æ°´è¾¹å‚é’“ï¼Œæ¥šç‹æ´¾é£ä¸¤ä½å¤§è‡£å…ˆè¡Œå‰å¾€è‡´æ„ï¼Œè¯´ï¼šâ€œæ¥šç‹æ„¿å°†å›½å†…æ”¿äº‹å§”æ‰˜ç»™ä½ è€ŒåŠ³ç´¯ä½ äº†ã€‚â€ åº„å­æ‰‹æŠŠé’“ç«¿å¤´ä¹Ÿä¸å›åœ°è¯´ï¼šâ€œæˆ‘å¬è¯´æ¥šå›½æœ‰ä¸€ç¥é¾Ÿï¼Œå·²ç»æ­»äº†ä¸‰åƒå¹´äº†ï¼Œæ¥šç‹ç”¨ç«¹ç®±è£…ç€å®ƒï¼Œç”¨å·¾é¥°è¦†ç›–ç€å®ƒï¼Œçè—åœ¨å®—åº™é‡Œã€‚è¿™åªç¥é¾Ÿï¼Œæ˜¯å®æ„¿æ­»å»ä¸ºäº†ç•™ä¸‹éª¨éª¸è€Œæ˜¾ç¤ºå°Šè´µå‘¢ï¼Œè¿˜æ˜¯å®æ„¿æ´»ç€åœ¨æ³¥æ°´é‡Œæ‹–ç€å°¾å·´å‘¢ï¼Ÿâ€ä¸¤ä½å¤§è‡£è¯´ï¼šâ€œå®æ„¿æ‹–ç€å°¾å·´æ´»åœ¨æ³¥æ°´é‡Œã€‚â€åº„å­è¯´ï¼šâ€œä½ ä»¬èµ°å§ï¼æˆ‘ä»å°†æ‹–ç€å°¾å·´ç”Ÿæ´»åœ¨æ³¥æ°´é‡Œã€‚â€ æƒ å­åœ¨æ¢å›½åšå®°ç›¸ï¼Œåº„å­å‰å¾€çœ‹æœ›ä»–ã€‚æœ‰äººå¯¹æƒ å­è¯´ï¼šâ€œåº„å­æ¥æ¢å›½ï¼Œæ˜¯æƒ³å–ä»£ä½ åšå®°ç›¸ã€‚â€äºæ˜¯æƒ å­ææ…Œèµ·æ¥ï¼Œåœ¨éƒ½åŸå†…æœå¯»åº„å­ï¼Œæ•´æ•´ä¸‰å¤©ä¸‰å¤œã€‚ åº„å­å‰å¾€çœ‹æœ›æƒ å­ï¼Œè¯´ï¼šâ€œå—æ–¹æœ‰ä¸€ç§é¸Ÿï¼Œå®ƒçš„åå­—å«é¹“î€¬ï¼Œä½ çŸ¥é“å—ï¼Ÿé¹“ä»å—æµ·å‡ºå‘é£åˆ°åŒ—æµ·ï¼Œä¸æ˜¯æ¢§æ¡æ ‘å®ƒä¸ä¼šåœæ¯ï¼Œä¸æ˜¯ç«¹å­çš„æœå®å®ƒä¸ä¼šè¿›é£Ÿï¼Œä¸æ˜¯ç”˜ç¾çš„æ³‰æ°´å®ƒä¸ä¼šé¥®ç”¨ã€‚æ­£åœ¨è¿™æ—¶ä¸€åªé¹é¹°å¯»è§…åˆ°ä¸€åªè…çƒ‚äº†çš„è€é¼ ï¼Œé¹“åˆšå·§ä»ç©ºä¸­é£è¿‡ï¼Œé¹é¹°æŠ¬å¤´çœ‹ç€é¹“ï¼Œå‘å‡ºä¸€å£°æ€’æ°”ï¼šâ€˜åš‡â€™ï¼å¦‚ä»Šä½ ä¹Ÿæƒ³ç”¨ä½ çš„æ¢å›½æ¥æ€’å±æˆ‘å—ï¼Ÿâ€ åº„å­å’Œæƒ å­ä¸€é“åœ¨æ¿ æ°´çš„æ¡¥ä¸Šæ¸¸ç©ã€‚åº„å­è¯´ï¼šâ€œå„µé±¼æ¸¸å¾—å¤šä¹ˆæ‚ é—²è‡ªåœ¨ï¼Œè¿™å°±æ˜¯é±¼å„¿çš„å¿«ä¹ã€‚â€æƒ å­è¯´ï¼šâ€œä½ ä¸æ˜¯é±¼ï¼Œæ€ä¹ˆçŸ¥é“é±¼çš„å¿«ä¹ï¼Ÿâ€åº„å­è¯´ï¼šâ€œä½ ä¸æ˜¯æˆ‘ï¼Œæ€ä¹ˆçŸ¥é“æˆ‘ä¸çŸ¥é“é±¼å„¿çš„å¿«ä¹ï¼Ÿâ€æƒ å­è¯´ï¼šâ€œæˆ‘ä¸æ˜¯ä½ ï¼Œå›ºç„¶ä¸çŸ¥é“ä½ ï¼›ä½ ä¹Ÿä¸æ˜¯é±¼ï¼Œä½ ä¸çŸ¥é“é±¼çš„å¿«ä¹ï¼Œä¹Ÿæ˜¯å®Œå…¨å¯ä»¥è‚¯å®šçš„ã€‚â€åº„å­è¯´ï¼šâ€œè¿˜æ˜¯è®©æˆ‘ä»¬é¡ºç€å…ˆå‰çš„è¯æ¥è¯´ã€‚ä½ åˆšæ‰æ‰€è¯´çš„â€˜ä½ æ€ä¹ˆçŸ¥é“é±¼çš„å¿«ä¹â€™çš„è¯ï¼Œå°±æ˜¯å·²ç»çŸ¥é“äº†æˆ‘çŸ¥é“é±¼å„¿çš„å¿«ä¹è€Œé—®æˆ‘ï¼Œè€Œæˆ‘åˆ™æ˜¯åœ¨æ¿ æ°´çš„æ¡¥ä¸ŠçŸ¥é“é±¼å„¿å¿«ä¹çš„ã€‚â€","categories":[{"name":"è¯»ä¹¦ç¬”è®°","slug":"è¯»ä¹¦ç¬”è®°","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"å“²å­¦","slug":"è¯»ä¹¦ç¬”è®°/å“²å­¦","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%93%B2%E5%AD%A6/"}],"tags":[{"name":"å“²å­¦","slug":"å“²å­¦","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6/"},{"name":"åº„å­","slug":"åº„å­","permalink":"http://example.com/tags/%E5%BA%84%E5%AD%90/"},{"name":"é“å®¶","slug":"é“å®¶","permalink":"http://example.com/tags/%E9%81%93%E5%AE%B6/"}]},{"title":"C++å­¦ä¹  ç¨‹åºçš„å†…å­˜æ¨¡å‹","slug":"C++-å­¦ä¹ -ç¨‹åºçš„å†…å­˜æ¨¡å‹","date":"2023-04-11T06:42:45.000Z","updated":"2023-05-09T08:10:31.000Z","comments":true,"path":"2023/04/11/C++-å­¦ä¹ -ç¨‹åºçš„å†…å­˜æ¨¡å‹/","link":"","permalink":"http://example.com/2023/04/11/C++-%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"å†…å­˜åˆ†åŒºæ¨¡å‹C++ç¨‹åºåœ¨æ‰§è¡Œæ—¶ï¼Œå°†å†…å­˜å¤§æ–¹å‘åˆ’åˆ†ä¸ºå››ä¸ªåŒºåŸŸ ä»£ç åŒºï¼šå­˜æ”¾å‡½æ•°ä½“çš„äºŒè¿›åˆ¶ä»£ç ï¼Œç”±æ“ä½œç³»ç»Ÿè¿›è¡Œç®¡ç† å…¨å±€åŒºï¼šå­˜æ”¾å…¨å±€å˜é‡å’Œé™æ€å˜é‡ä»¥åŠå¸¸é‡ æ ˆåŒºï¼šç”±ç¼–è¯‘å™¨è‡ªåŠ¨åˆ†é…é‡Šæ”¾ï¼Œå­˜æ”¾å‡½æ•°çš„å‚æ•°å€¼ï¼Œå±€éƒ¨å˜é‡ç­‰ å †åŒºï¼šç”±ç¨‹åºå‘˜åˆ†é…å’Œé‡Šæ”¾ï¼Œè‹¥ç¨‹åºå‘˜ä¸é‡Šæ”¾ï¼Œç¨‹åºç»“æŸæ—¶ç”±æ“ä½œç³»ç»Ÿå›æ”¶","text":"å†…å­˜åˆ†åŒºæ¨¡å‹C++ç¨‹åºåœ¨æ‰§è¡Œæ—¶ï¼Œå°†å†…å­˜å¤§æ–¹å‘åˆ’åˆ†ä¸ºå››ä¸ªåŒºåŸŸ ä»£ç åŒºï¼šå­˜æ”¾å‡½æ•°ä½“çš„äºŒè¿›åˆ¶ä»£ç ï¼Œç”±æ“ä½œç³»ç»Ÿè¿›è¡Œç®¡ç† å…¨å±€åŒºï¼šå­˜æ”¾å…¨å±€å˜é‡å’Œé™æ€å˜é‡ä»¥åŠå¸¸é‡ æ ˆåŒºï¼šç”±ç¼–è¯‘å™¨è‡ªåŠ¨åˆ†é…é‡Šæ”¾ï¼Œå­˜æ”¾å‡½æ•°çš„å‚æ•°å€¼ï¼Œå±€éƒ¨å˜é‡ç­‰ å †åŒºï¼šç”±ç¨‹åºå‘˜åˆ†é…å’Œé‡Šæ”¾ï¼Œè‹¥ç¨‹åºå‘˜ä¸é‡Šæ”¾ï¼Œç¨‹åºç»“æŸæ—¶ç”±æ“ä½œç³»ç»Ÿå›æ”¶ å†…å­˜å››åŒºçš„æ„ä¹‰ï¼š ä¸åŒåŒºåŸŸå­˜æ”¾çš„æ•°æ®ï¼Œèµ‹äºˆä¸åŒçš„ç”Ÿå‘½å‘¨æœŸï¼Œç»™æˆ‘ä»¬æ›´å¤§çš„çµæ´»ç¼–ç¨‹ ç¨‹åºè¿è¡Œå‰åœ¨ç¨‹åºç¼–è¯‘åï¼Œç”Ÿæˆäº†exeå¯æ‰§è¡Œç¨‹åºï¼Œæœªæ‰§è¡Œè¯¥ç¨‹åºå‰åˆ†ä¸ºä¸¤ä¸ªåŒºåŸŸ ä»£ç åŒºï¼š å­˜æ”¾CPUæ‰§è¡Œçš„æœºå™¨æŒ‡ä»¤ ä»£ç åŒºæ˜¯å…±äº«çš„ï¼Œå…±äº«çš„ç›®çš„æ˜¯å¯¹äºé¢‘ç¹æ‰§è¡Œçš„ç¨‹åºï¼Œåªè¦åœ¨å†…å­˜ä¸­æœ‰ä¸€ä»½ä»£ç å³å¯ ä»£ç åŒºæ˜¯åªè¯»çš„ï¼Œä½¿å…¶åªè¯»çš„åŸå› æ˜¯é˜²æ­¢ç¨‹åºæ„å¤–çš„ä¿®æ”¹äº†å®ƒçš„æŒ‡ä»¤ å…¨å±€åŒºï¼š å…¨å±€å˜é‡å’Œé™æ€å˜é‡å­˜æ”¾åœ¨æ­¤ è¯¥åŒºåŸŸçš„æ•°æ®åœ¨ç¨‹åºç»“æŸåç”±æ“ä½œç³»ç»Ÿé‡Šæ”¾ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int g_a = 10;int g_b = 10;const int c_g_a = 10;const int c_g_b = 10;int main()&#123; int a = 10; int b = 10; static int s_a = 10; static int s_b = 10; const int c_a = 10; const int c_b = 10; cout &lt;&lt; &quot;å±€éƒ¨å˜é‡açš„åœ°å€&quot; &lt;&lt; (long long int)&amp;a&lt;&lt;endl; cout &lt;&lt; &quot;å±€éƒ¨å˜é‡bçš„åœ°å€&quot; &lt;&lt; (long long int)&amp;b&lt;&lt;endl; cout &lt;&lt; &quot;å…¨å±€å˜é‡g_açš„åœ°å€&quot; &lt;&lt; (long long int)&amp;g_a&lt;&lt;endl; cout &lt;&lt; &quot;å…¨å±€å˜é‡g_bçš„åœ°å€&quot; &lt;&lt; (long long int)&amp;g_b&lt;&lt;endl; cout &lt;&lt; &quot;é™æ€å˜é‡s_açš„åœ°å€&quot; &lt;&lt; (long long int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;é™æ€å˜é‡s_bçš„åœ°å€&quot; &lt;&lt; (long long int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;å­—ç¬¦ä¸²å¸¸é‡Hello Worldçš„åœ°å€&quot; &lt;&lt; (long long int)&amp;&quot;Hello World&quot; &lt;&lt; endl; cout &lt;&lt; &quot;å…¨å±€å¸¸é‡c_g_açš„åœ°å€&quot; &lt;&lt; (long long int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;å…¨å±€å¸¸é‡c_g_bçš„åœ°å€&quot; &lt;&lt; (long long int)&amp;c_g_b &lt;&lt; endl; cout &lt;&lt; &quot;å±€éƒ¨å¸¸é‡c_açš„åœ°å€&quot; &lt;&lt; (long long int) &amp; c_a &lt;&lt; endl; cout &lt;&lt; &quot;å±€éƒ¨å¸¸é‡c_bçš„åœ°å€&quot; &lt;&lt; (long long int) &amp; c_b &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š å±€éƒ¨å˜é‡açš„åœ°å€145921079908å±€éƒ¨å˜é‡bçš„åœ°å€145921079940å…¨å±€å˜é‡g_açš„åœ°å€140702441787392å…¨å±€å˜é‡g_bçš„åœ°å€140702441787396é™æ€å˜é‡s_açš„åœ°å€140702441787400é™æ€å˜é‡s_bçš„åœ°å€140702441787404å­—ç¬¦ä¸²å¸¸é‡Hello Worldçš„åœ°å€140702441778224å…¨å±€å¸¸é‡c_g_açš„åœ°å€140702441778272å…¨å±€å¸¸é‡c_g_bçš„åœ°å€140702441778276å±€éƒ¨å¸¸é‡c_açš„åœ°å€145921079972å±€éƒ¨å¸¸é‡c_bçš„åœ°å€145921080004 ç¨‹åºè¿è¡Œå æ ˆåŒº ç”±ç¼–è¯‘å™¨è‡ªåŠ¨åˆ†é…é‡Šæ”¾å­˜æ”¾å‡½æ•°çš„å‚æ•°å€¼ï¼ˆå½¢å‚ï¼‰ï¼Œå±€éƒ¨å˜é‡ç­‰ æ³¨æ„äº‹é¡¹ï¼šä¸è¦è¿”å›å±€éƒ¨å˜é‡çš„åœ°å€ï¼Œæ ˆåŒºå¼€è¾Ÿçš„æ•°æ®ç”±ç¼–è¯‘å™¨è‡ªåŠ¨é‡Šæ”¾ 12345678910111213#include &lt;iostream&gt;using namespace std;int* func(int a)&#123; a = 10; return &amp;a;&#125;int main()&#123; int* p = func(1); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š 10-226279312 å †åŒº ç”±ç¨‹åºå‘˜åˆ†é…é‡Šæ”¾ï¼Œè‹¥ç¨‹åºå‘˜ä¸é‡Šæ”¾ï¼Œç¨‹åºç»“æŸæ—¶ç”±æ“ä½œç³»ç»Ÿå›æ”¶ åœ¨C++ä¸­ä¸»è¦åˆ©ç”¨newåœ¨å †åŒºå¼€è¾Ÿå†…å­˜ 12345678910111213#include &lt;iostream&gt;using namespace std;int* func(int a)&#123; int* p = new int(10); return p;&#125;int main()&#123; int* p = func(1); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š 1010 newæ“ä½œç¬¦C++ä¸­åˆ©ç”¨newæ“ä½œç¬¦åœ¨å †åŒºå¼€è¾Ÿæ•°æ® å †åŒºå¼€è¾Ÿçš„æ•°æ®ï¼Œç”±ç¨‹åºå‘˜æ‰‹åŠ¨é‡Šæ”¾ï¼Œé‡Šæ”¾åˆ©ç”¨æ“ä½œç¬¦delete è¯­æ³•ï¼šnew æ•°æ®ç±»å‹ åˆ©ç”¨newåˆ›å»ºçš„æ•°æ®ï¼Œä¼šè¿”å›è¯¥æ•°æ®å¯¹åº”çš„ç±»å‹çš„æŒ‡é’ˆ 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int* func()&#123; int* p = new int (10); return p;&#125;void test01()&#123; int* p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; delete(p); cout &lt;&lt; *p &lt;&lt; endl;&#125;int main()&#123; test01();&#125; è¿è¡Œç»“æœä¸ºï¼š 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void test02()&#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; delete[] arr;&#125;int main()&#123; test02();&#125; è¿è¡Œç»“æœä¸ºï¼š 100101102103104105106107108109 deleteä¹‹åï¼Œä¸èƒ½è®¿é—®arræŒ‡é’ˆæŒ‡å‘çš„å†…å­˜ï¼Œå¦åˆ™ä¼šå‘ç”Ÿè·Ÿä¸Šå›¾ä¸€æ ·çš„æƒ…å†µ","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  ç»“æ„ä½“","slug":"C++-å­¦ä¹ -ç»“æ„ä½“","date":"2023-04-10T07:42:49.000Z","updated":"2023-05-09T08:11:09.376Z","comments":true,"path":"2023/04/10/C++-å­¦ä¹ -ç»“æ„ä½“/","link":"","permalink":"http://example.com/2023/04/10/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"ç»“æ„ä½“çš„åŸºæœ¬æ¦‚å¿µç»“æ„ä½“å±äºç”¨æˆ·è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œå…è®¸ç”¨æˆ·å­˜å‚¨ä¸åŒçš„æ•°æ®ç±»å‹ ç»“æ„ä½“çš„å®šä¹‰å’Œä½¿ç”¨","text":"ç»“æ„ä½“çš„åŸºæœ¬æ¦‚å¿µç»“æ„ä½“å±äºç”¨æˆ·è‡ªå®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œå…è®¸ç”¨æˆ·å­˜å‚¨ä¸åŒçš„æ•°æ®ç±»å‹ ç»“æ„ä½“çš„å®šä¹‰å’Œä½¿ç”¨è¯­æ³•ï¼š struct ç»“æ„ä½“åï¼ˆç»“æ„ä½“æˆå‘˜åˆ—è¡¨ï¼‰ï¼› é€šè¿‡ç»“æ„ä½“åˆ›å»ºå˜é‡çš„æ–¹å¼æœ‰ä¸‰ç§ï¼š struct ç»“æ„ä½“å å˜é‡å struct ç»“æ„ä½“å å˜é‡å &#x3D; {æˆå‘˜1å€¼ ï¼Œ æˆå‘˜2å€¼â€¦} å®šä¹‰ç»“æ„ä½“æ—¶é¡ºä¾¿åˆ›å»ºå˜é‡ 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;s3;int main()&#123; struct student s1; s1.name = &quot;å¼ ä¸‰&quot;; s1.age = 15; s1.score = 100; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; s1.name &lt;&lt; &quot;å¹´é¾„ï¼š &quot; &lt;&lt; s1.age &lt;&lt; &quot;æˆç»©ï¼š &quot; &lt;&lt; s1.score &lt;&lt; endl; struct student s2 = &#123; &quot;æå››&quot; , 16 , 90 &#125;; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; s2.name &lt;&lt; &quot;å¹´é¾„ï¼š &quot; &lt;&lt; s2.age &lt;&lt; &quot;æˆç»©ï¼š &quot; &lt;&lt; s2.score &lt;&lt; endl; s3.name = &quot;ç‹äº”&quot;; s3.age = 17; s3.score = 85; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; s3.name &lt;&lt; &quot;å¹´é¾„ï¼š &quot; &lt;&lt; s3.age &lt;&lt; &quot;æˆç»©ï¼š &quot; &lt;&lt; s3.score &lt;&lt; endl;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š å§“åï¼š å¼ ä¸‰å¹´é¾„ï¼š 15æˆç»©ï¼š 100å§“åï¼š æå››å¹´é¾„ï¼š 16æˆç»©ï¼š 90å§“åï¼š ç‹äº”å¹´é¾„ï¼š 17æˆç»©ï¼š 85 ç»“æ„ä½“æ•°ç»„ä½œç”¨ï¼šå°†è‡ªå®šä¹‰çš„ç»“æ„ä½“æ”¾å…¥åˆ°æ•°ç»„ä¸­æ–¹ä¾¿ç»´æŠ¤ è¯­æ³•ï¼šstruct ç»“æ„ä½“ æ•°ç»„å[å…ƒç´ ä¸ªæ•°] &#x3D; { {} ï¼Œ {} ï¼Œâ€¦ ï¼Œ{} } 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;int main()&#123; struct student stuArray[3] = &#123; &#123;&quot;å¼ ä¸‰&quot;,18,100&#125;, &#123;&quot;æå››&quot;, 19, 90&#125;, &#123;&quot;ç‹äº”&quot;, 20, 85&#125; &#125;; stuArray[2].name = &quot;èµµå…­&quot;; stuArray[2].age = 15; stuArray[2].score = 95; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; stuArray[i].name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; stuArray[i].age &lt;&lt; &quot; åˆ†æ•°ï¼š &quot; &lt;&lt; stuArray[i].score &lt;&lt; endl; &#125;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š å§“åï¼š å¼ ä¸‰ å¹´é¾„ï¼š 18 åˆ†æ•°ï¼š 100å§“åï¼š æå›› å¹´é¾„ï¼š 19 åˆ†æ•°ï¼š 90å§“åï¼š èµµå…­ å¹´é¾„ï¼š 15 åˆ†æ•°ï¼š 95 ç»“æ„ä½“æŒ‡é’ˆä½œç”¨ï¼šé€šè¿‡æŒ‡é’ˆè®¿é—®ç»“æ„ä½“ä¸­çš„æˆå‘˜ åˆ©ç”¨æ“ä½œç¬¦ -&gt;å¯ä»¥é€šè¿‡ç»“æ„ä½“æŒ‡é’ˆè®¿é—®ç»“æ„ä½“å±æ€§ 1234567891011121314#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;int main()&#123; struct student s = &#123; &quot;å¼ ä¸‰&quot; , 16 , 98 &#125;; struct student * p = &amp;s; cout &lt;&lt; &quot;å§“åï¼š &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; å¹´é¾„ï¼š &quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; åˆ†æ•°ï¼š &quot; &lt;&lt; p-&gt;score &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š å§“åï¼š å¼ ä¸‰ å¹´é¾„ï¼š 16 åˆ†æ•°ï¼š 98 ç»“æ„ä½“åµŒå¥—ç»“æ„ä½“ä½œç”¨ï¼šç»“æ„ä½“ä¸­çš„æˆå‘˜å¯ä»¥æ˜¯å¦ä¸€ä¸ªç»“æ„ä½“ ä¾‹å¦‚ï¼šæ¯ä¸ªè€å¸ˆè¾…å¯¼ä¸€ä¸ªå­¦å‘˜ï¼Œä¸€ä¸ªè€å¸ˆçš„ç»“æ„ä½“ä¸­ï¼Œè®°å½•ä¸€ä¸ªå­¦ç”Ÿçš„ç»“æ„ä½“ 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;struct teacher&#123; string name; int id; int age; struct student stu;&#125;;int main()&#123; struct teacher t; t.name = &quot;å¼ ä¸‰&quot;; t.id = 100; t.age = 45; t.stu.name = &quot;æå››&quot;; t.stu.age = 16; t.stu.score = 100; cout &lt;&lt; &quot;è€å¸ˆçš„å§“åï¼š&quot; &lt;&lt; t.name &lt;&lt; &quot; è€å¸ˆçš„idï¼š&quot; &lt;&lt; t.id &lt;&lt; &quot; è€å¸ˆçš„å¹´é¾„ï¼š&quot; &lt;&lt; t.age &lt;&lt; endl; cout &lt;&lt; &quot;è€å¸ˆæŒ‡å¯¼çš„å­¦ç”Ÿçš„å§“åï¼š&quot; &lt;&lt; t.stu.name &lt;&lt; &quot; å­¦ç”Ÿçš„å¹´é¾„ï¼š &quot; &lt;&lt; t.stu.age &lt;&lt; &quot; å­¦ç”Ÿçš„æˆç»©ï¼š&quot; &lt;&lt; t.stu.score &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š è€å¸ˆçš„å§“åï¼šå¼ ä¸‰ è€å¸ˆçš„idï¼š100 è€å¸ˆçš„å¹´é¾„ï¼š45è€å¸ˆæŒ‡å¯¼çš„å­¦ç”Ÿçš„å§“åï¼šæå›› å­¦ç”Ÿçš„å¹´é¾„ï¼š 16 å­¦ç”Ÿçš„æˆç»©ï¼š100 ç»“æ„ä½“åšå‡½æ•°å‚æ•°ä½œç”¨ï¼šå°†ç»“æ„ä½“ä½œä¸ºå‚æ•°å‘å‡½æ•°ä¸­ä¼ é€’ ä¼ é€’æ–¹å¼æœ‰ä¸¤ç§ï¼š å€¼ä¼ é€’ åœ°å€ä¼ é€’ 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;void PrintStu1(struct student s)&#123; s.name = &quot;æå››&quot;; s.age = 19; s.score = 90; cout &lt;&lt; &quot;å­å‡½æ•°1ä¸­å­¦ç”Ÿå§“åï¼š&quot; &lt;&lt; s.name &lt;&lt; &quot; å¹´é¾„ï¼š&quot; &lt;&lt; s.age &lt;&lt; &quot; åˆ†æ•°ï¼š&quot; &lt;&lt; s.score &lt;&lt; endl;&#125;void PrintStu2(struct student* p)&#123; p-&gt;name = &quot;æå››&quot;; p-&gt;age = 19; p-&gt;score = 90; cout &lt;&lt; &quot;å­å‡½æ•°2ä¸­å­¦ç”Ÿå§“åï¼š&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; å¹´é¾„ï¼š&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; åˆ†æ•°ï¼š&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;&#125;int main()&#123; struct student s = &#123; &quot;å¼ ä¸‰&quot; , 16 , 100 &#125;; cout &lt;&lt; &quot;mainå‡½æ•°ä¸­å­¦ç”Ÿå§“åï¼š&quot; &lt;&lt; s.name &lt;&lt; &quot; å¹´é¾„ï¼š&quot; &lt;&lt; s.age &lt;&lt; &quot; åˆ†æ•°ï¼š&quot; &lt;&lt; s.score &lt;&lt; endl; PrintStu1(s); cout &lt;&lt; &quot;mainå‡½æ•°ä¸­å­¦ç”Ÿå§“åï¼š&quot; &lt;&lt; s.name &lt;&lt; &quot; å¹´é¾„ï¼š&quot; &lt;&lt; s.age &lt;&lt; &quot; åˆ†æ•°ï¼š&quot; &lt;&lt; s.score &lt;&lt; endl; PrintStu2(&amp;s); cout &lt;&lt; &quot;mainå‡½æ•°ä¸­å­¦ç”Ÿå§“åï¼š&quot; &lt;&lt; s.name &lt;&lt; &quot; å¹´é¾„ï¼š&quot; &lt;&lt; s.age &lt;&lt; &quot; åˆ†æ•°ï¼š&quot; &lt;&lt; s.score &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š mainå‡½æ•°ä¸­å­¦ç”Ÿå§“åï¼šå¼ ä¸‰ å¹´é¾„ï¼š16 åˆ†æ•°ï¼š100å­å‡½æ•°1ä¸­å­¦ç”Ÿå§“åï¼šæå›› å¹´é¾„ï¼š19 åˆ†æ•°ï¼š90mainå‡½æ•°ä¸­å­¦ç”Ÿå§“åï¼šå¼ ä¸‰ å¹´é¾„ï¼š16 åˆ†æ•°ï¼š100å­å‡½æ•°2ä¸­å­¦ç”Ÿå§“åï¼šæå›› å¹´é¾„ï¼š19 åˆ†æ•°ï¼š90mainå‡½æ•°ä¸­å­¦ç”Ÿå§“åï¼šæå›› å¹´é¾„ï¼š19 åˆ†æ•°ï¼š90 ç»“æ„ä½“ä¸­constçš„ä½¿ç”¨åœºæ™¯ä½œç”¨ï¼šç”¨constæ¥é˜²æ­¢è¯¯æ“ä½œ 12345678910111213141516171819#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;void PrintStu(const struct student * s)&#123; s-&gt;name = &quot;æå››&quot;;&#125;int main()&#123; struct student s = &#123; &quot;å¼ ä¸‰&quot; , 16 , 100 &#125;; PrintStu(&amp;s);&#125; ç»“æœå¦‚ä¸‹ï¼š ç¨‹åºæŠ¥é”™ï¼Œä¸èƒ½ä¿®æ”¹ ç»“æ„ä½“æ¡ˆä¾‹ä¸€æ¡ˆä¾‹æè¿°ï¼šå­¦æ ¡æ­£åœ¨åšæ¯•è®¾é¡¹ç›®ï¼Œæ¯åè€å¸ˆå¸¦é¢†äº”ä¸ªå­¦ç”Ÿï¼Œæ€»å…±æœ‰ä¸‰åè€å¸ˆï¼Œéœ€æ±‚å¦‚ä¸‹ è®¾è®¡å­¦ç”Ÿå’Œè€å¸ˆçš„ç»“æ„ä½“ï¼Œå…¶ä¸­åœ¨è€å¸ˆçš„ç»“æ„ä½“ä¸­ï¼Œæœ‰è€å¸ˆå§“åå’Œä¸€ä¸ªå­˜æ”¾äº”åå­¦ç”Ÿçš„æ•°ç»„ä½œä¸ºæˆå‘˜ å­¦ç”Ÿçš„æˆå‘˜æœ‰å§“åã€è€ƒè¯•åˆ†æ•°ï¼Œåˆ›å»ºæ•°ç»„å­˜æ”¾ä¸‰åè€å¸ˆï¼Œé€šè¿‡å‡½æ•°ç»™æ¯ä¸ªè€å¸ˆåŠæ‰€å¸¦å­¦ç”Ÿçš„å­¦ç”Ÿæ•°èµ‹å€¼ æœ€ç»ˆæ‰“å°å‡ºè€å¸ˆæ•°æ®ä»¥åŠè€å¸ˆæ‰€å¸¦å­¦ç”Ÿçš„æ•°æ® 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string sname; int score;&#125;;struct teacher&#123; string tname; struct student stuArray[5];&#125;;void inAll(struct teacher * s)&#123; printf(&quot;è¯·è¾“å…¥è€å¸ˆçš„å§“åï¼š&quot;); cin &gt;&gt; s-&gt;tname; for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;\\nè¯·è¾“å…¥ç¬¬%dä½åŒå­¦çš„å§“åå’Œæˆç»©&quot;,i+1); cin&gt;&gt;s-&gt;stuArray[i].sname&gt;&gt;s-&gt;stuArray[i].score; &#125;&#125;void outAll(struct teacher t)&#123; cout &lt;&lt; &quot;è€å¸ˆçš„å§“å&quot; &lt;&lt; t.tname &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; &quot;å­¦ç”Ÿ&quot; &lt;&lt;i+1&lt;&lt;&quot;å§“åä¸ºï¼š&quot;&lt;&lt; t.stuArray[i].sname &lt;&lt; &quot; æˆç»©ä¸ºï¼š&quot; &lt;&lt; t.stuArray[i].score &lt;&lt; endl; &#125;&#125;int main()&#123; struct teacher tArray[3]; for (int i = 0; i &lt; 3; i++) &#123; inAll(&amp;tArray[i]); &#125; for (int i = 0; i &lt; 3; i++) &#123; outAll(tArray[i]); &#125;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š è¯·è¾“å…¥è€å¸ˆçš„å§“åï¼šè€å¸ˆ1 è¯·è¾“å…¥ç¬¬1ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ11 90 è¯·è¾“å…¥ç¬¬2ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ12 90 è¯·è¾“å…¥ç¬¬3ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ13 80 è¯·è¾“å…¥ç¬¬4ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ14 79 è¯·è¾“å…¥ç¬¬5ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ15 98è¯·è¾“å…¥è€å¸ˆçš„å§“åï¼šè€å¸ˆ2 è¯·è¾“å…¥ç¬¬1ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ21 80 è¯·è¾“å…¥ç¬¬2ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ22 79 è¯·è¾“å…¥ç¬¬3ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ23 80 è¯·è¾“å…¥ç¬¬4ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ24 79 è¯·è¾“å…¥ç¬¬5ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ25 90è¯·è¾“å…¥è€å¸ˆçš„å§“åï¼šè€å¸ˆ3 è¯·è¾“å…¥ç¬¬1ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ31 90 è¯·è¾“å…¥ç¬¬2ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ32 89 è¯·è¾“å…¥ç¬¬3ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ33 79 è¯·è¾“å…¥ç¬¬4ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ34 80 è¯·è¾“å…¥ç¬¬5ä½åŒå­¦çš„å§“åå’Œæˆç»©å­¦ç”Ÿ35 98è€å¸ˆçš„å§“åè€å¸ˆ1å­¦ç”Ÿ1å§“åä¸ºï¼šå­¦ç”Ÿ11 æˆç»©ä¸ºï¼š90å­¦ç”Ÿ2å§“åä¸ºï¼šå­¦ç”Ÿ12 æˆç»©ä¸ºï¼š90å­¦ç”Ÿ3å§“åä¸ºï¼šå­¦ç”Ÿ13 æˆç»©ä¸ºï¼š80å­¦ç”Ÿ4å§“åä¸ºï¼šå­¦ç”Ÿ14 æˆç»©ä¸ºï¼š79å­¦ç”Ÿ5å§“åä¸ºï¼šå­¦ç”Ÿ15 æˆç»©ä¸ºï¼š98è€å¸ˆçš„å§“åè€å¸ˆ2å­¦ç”Ÿ1å§“åä¸ºï¼šå­¦ç”Ÿ21 æˆç»©ä¸ºï¼š80å­¦ç”Ÿ2å§“åä¸ºï¼šå­¦ç”Ÿ22 æˆç»©ä¸ºï¼š79å­¦ç”Ÿ3å§“åä¸ºï¼šå­¦ç”Ÿ23 æˆç»©ä¸ºï¼š80å­¦ç”Ÿ4å§“åä¸ºï¼šå­¦ç”Ÿ24 æˆç»©ä¸ºï¼š79å­¦ç”Ÿ5å§“åä¸ºï¼šå­¦ç”Ÿ25 æˆç»©ä¸ºï¼š90è€å¸ˆçš„å§“åè€å¸ˆ3å­¦ç”Ÿ1å§“åä¸ºï¼šå­¦ç”Ÿ31 æˆç»©ä¸ºï¼š90å­¦ç”Ÿ2å§“åä¸ºï¼šå­¦ç”Ÿ32 æˆç»©ä¸ºï¼š89å­¦ç”Ÿ3å§“åä¸ºï¼šå­¦ç”Ÿ33 æˆç»©ä¸ºï¼š79å­¦ç”Ÿ4å§“åä¸ºï¼šå­¦ç”Ÿ34 æˆç»©ä¸ºï¼š80å­¦ç”Ÿ5å§“åä¸ºï¼šå­¦ç”Ÿ35 æˆç»©ä¸ºï¼š98 ç»“æ„ä½“æ¡ˆä¾‹äºŒæ¡ˆä¾‹æè¿°ï¼š è®¾è®¡ä¸€ä¸ªè‹±é›„çš„ç»“æ„ä½“ï¼ŒåŒ…æ‹¬æˆå‘˜å§“åï¼Œå¹´é¾„ï¼Œæ€§åˆ«ï¼šåˆ›å»ºç»“æ„ä½“æ•°ç»„ï¼Œæ•°ç»„ä¸­å­˜æ”¾äº”åè‹±é›„ã€‚ é€šè¿‡å†’æ³¡æ’åºçš„ç®—æ³•ï¼Œå°†æ•°ç»„ä¸­çš„è‹±é›„æŒ‰ç…§å¹´é¾„è¿›è¡Œå‡åºæ’åºï¼Œæœ€ç»ˆæ‰“å°æ’åºåçš„ç»“æœã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct Hero&#123; string name; int age; string sex;&#125;;int main()&#123; struct Hero heroArray[5] = &#123; &#123;&quot;åˆ˜å¤‡&quot;, 21, &quot;ç”·&quot;&#125;, &#123; &quot;å…³ç¾½&quot;,19,&quot;ç”·&quot; &#125;, &#123; &quot;å¼ é£&quot;,23,&quot;ç”·&quot; &#125;, &#123; &quot;èµµäº‘&quot;,20,&quot;ç”·&quot; &#125;, &#123; &quot;é»„å¿ &quot;,18,&quot;ç”·&quot; &#125; &#125;; int len = sizeof(heroArray) / sizeof(heroArray[0]); for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; if (heroArray[j+1].age &gt; heroArray[j].age) &#123; struct Hero temp = heroArray[j]; heroArray[j] = heroArray[j+1]; heroArray[j+1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; heroArray[i].name &lt;&lt; heroArray[i].age &lt;&lt; heroArray[i].sex &lt;&lt; endl; &#125;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š å¼ é£23ç”·åˆ˜å¤‡21ç”·èµµäº‘20ç”·å…³ç¾½19ç”·é»„å¿ 18ç”·","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++å­¦ä¹  æŒ‡é’ˆ","slug":"C++-å­¦ä¹ -æŒ‡é’ˆ","date":"2023-04-09T05:57:28.000Z","updated":"2023-05-09T08:11:56.207Z","comments":true,"path":"2023/04/09/C++-å­¦ä¹ -æŒ‡é’ˆ/","link":"","permalink":"http://example.com/2023/04/09/C++-%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/","excerpt":"æŒ‡é’ˆåŸºæœ¬æ¦‚å¿µæŒ‡é’ˆçš„ä½œç”¨ï¼š å¯ä»¥é€šè¿‡æŒ‡é’ˆé—´æ¥è®¿é—®å†…å­˜ å†…å­˜ç¼–å·æ˜¯ä»0å¼€å§‹è®°å½•çš„ï¼Œä¸€èˆ¬ç”¨åå…­è¿›åˆ¶æ•°å­—è¡¨ç¤º å¯ä»¥åˆ©ç”¨æŒ‡é’ˆå˜é‡ä¿å­˜åœ°å€","text":"æŒ‡é’ˆåŸºæœ¬æ¦‚å¿µæŒ‡é’ˆçš„ä½œç”¨ï¼š å¯ä»¥é€šè¿‡æŒ‡é’ˆé—´æ¥è®¿é—®å†…å­˜ å†…å­˜ç¼–å·æ˜¯ä»0å¼€å§‹è®°å½•çš„ï¼Œä¸€èˆ¬ç”¨åå…­è¿›åˆ¶æ•°å­—è¡¨ç¤º å¯ä»¥åˆ©ç”¨æŒ‡é’ˆå˜é‡ä¿å­˜åœ°å€ å¯ä»¥é€šè¿‡ä¸€ä¸ªæŒ‡é’ˆæ¥ä¿å­˜ä¸€ä¸ªåœ°å€ æŒ‡é’ˆçš„å®šä¹‰å’Œä½¿ç”¨å®šä¹‰æŒ‡é’ˆæŒ‡é’ˆå®šä¹‰çš„è¯­æ³•ï¼š æ•°æ®ç±»å‹ \\* æŒ‡é’ˆå˜é‡å 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p; p = &amp;a; cout &lt;&lt; &quot;açš„åœ°å€ä¸º&quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;æŒ‡é’ˆpä¸º&quot; &lt;&lt; p &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š açš„åœ°å€ä¸º00000087472FFC84æŒ‡é’ˆpä¸º00000087472FFC84 æˆ‘ä»¬å¯ä»¥å¾—åˆ°æŒ‡é’ˆå°±æ˜¯åœ°å€ ä½¿ç”¨æŒ‡é’ˆå¯ä»¥é€šè¿‡è§£å¼•ç”¨çš„æ–¹å¼æ¥æ‰¾åˆ°æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜ æŒ‡é’ˆå‰åŠ  *ä»£è¡¨è§£å¼•ç”¨ 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p; p = &amp;a; cout &lt;&lt; &quot;açš„åœ°å€ä¸º&quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;æŒ‡é’ˆpä¸º&quot; &lt;&lt; p &lt;&lt; endl; *p = 1000; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;endl; cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š açš„åœ°å€ä¸º0000003F9953F7C4æŒ‡é’ˆpä¸º0000003F9953F7C4a &#x3D; 1000*p &#x3D; 1000 é€šè¿‡pæ‰¾åˆ°açš„å†…å­˜ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡*pä¿®æ”¹å†…å­˜ æŒ‡é’ˆæ‰€å å†…å­˜ç©ºé—´æŒ‡é’ˆä¹Ÿæ˜¯ä¸€ç§æ•°æ®ç±»å‹ï¼Œé‚£ä¹ˆè¿™ç§æ•°æ®ç±»å‹å ç”¨å¤šå°‘å†…å­˜ç©ºé—´å‘¢ï¼Ÿ åœ¨32ä½æ“ä½œç³»ç»Ÿä¸‹ï¼šå ç”¨4ä¸ªå­—èŠ‚ç©ºé—´ åœ¨64ä½æ“ä½œç³»ç»Ÿä¸‹ï¼šå ç”¨8ä¸ªå­—èŠ‚ç©ºé—´ 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p = &amp;a; cout &lt;&lt; &quot;sizeof (p) = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (int *) = &quot; &lt;&lt; sizeof(int *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (char *) = &quot; &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (float *) = &quot; &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (double *) = &quot; &lt;&lt; sizeof(double *) &lt;&lt; endl;&#125; è¿è¡Œç»“æœä¸ºï¼š sizeof (p) &#x3D; 8sizeof (int *) &#x3D; 8sizeof (char *) &#x3D; 8sizeof (float *) &#x3D; 8sizeof (double *) &#x3D; 8 å› ä¸ºæŒ‡é’ˆæ˜¯å†…å­˜ï¼Œæ‰€ä»¥ä¸ç®¡æ˜¯ä»€ä¹ˆæ•°æ®ç±»å‹ä¸‹ï¼Œ64ä½æ“ä½œç³»ç»Ÿï¼ŒæŒ‡é’ˆéƒ½æ˜¯å ç”¨8ä¸ªå­—èŠ‚ç©ºé—´å¤§å° ç©ºæŒ‡é’ˆå’Œé‡æŒ‡é’ˆç©ºæŒ‡é’ˆç©ºæŒ‡é’ˆï¼šæŒ‡é’ˆå˜é‡æŒ‡å‘å†…å­˜ä¸­ä¸º0çš„ç©ºé—´ ç”¨é€”ï¼šåˆå§‹åŒ–æŒ‡é’ˆå˜é‡ æ³¨æ„ï¼šç©ºæŒ‡é’ˆçš„å†…å­˜æ˜¯ä¸å¯ä»¥è®¿é—®çš„ 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; int* p = NULL; *p = 100;&#125; ç¨‹åºè¿è¡Œé”™è¯¯ 0~255ä¹‹é—´çš„å†…å­˜ç¼–å·æ˜¯ç³»ç»Ÿå ç”¨çš„ï¼Œå› æ­¤ä¸å¯ä»¥è®¿é—® é‡æŒ‡é’ˆé‡æŒ‡é’ˆï¼šæŒ‡é’ˆå˜é‡æŒ‡å‘ä¸€æ®µéæ³•çš„å†…å­˜ç©ºé—´ 1234567#include &lt;iostream&gt;using namespace std;int main()&#123; int* p = (int *)0x1100; cout &lt;&lt; *p &lt;&lt; endl;&#125; ç¨‹åºè¿è¡Œé”™è¯¯ åœ¨ç¨‹åºä¸­å°½é‡é¿å…é‡æŒ‡é’ˆ constä¿®é¥°æŒ‡é’ˆconstä¿®é¥°æŒ‡é’ˆæœ‰ä¸‰ç§æƒ…å†µ constä¿®é¥°æŒ‡é’ˆ - å¸¸é‡æŒ‡é’ˆæŒ‡é’ˆçš„æŒ‡å‘å¯ä»¥ä¿®æ”¹ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„å€¼ä¸èƒ½ä¿®æ”¹ 1const int * p; constä¿®é¥°å¸¸é‡ - æŒ‡é’ˆå¸¸é‡æŒ‡é’ˆçš„æŒ‡å‘ä¸å¯ä»¥æ”¹ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„å€¼å¯ä»¥æ”¹ 1int * const p; constæ—¢ä¿®é¥°æŒ‡é’ˆï¼Œåˆä¿®é¥°å¸¸é‡æŒ‡é’ˆçš„æŒ‡å‘ä¸å¯ä»¥æ”¹ï¼ŒæŒ‡é’ˆæŒ‡å‘çš„å€¼ä¹Ÿä¸å¯ä»¥æ”¹ 1const int * const p; 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int b = 10; //1ã€const ä¿®é¥°æŒ‡é’ˆ å¸¸é‡æŒ‡é’ˆ const int * p1 = &amp;a; //*p1 = 20 é”™è¯¯ p1 = &amp;b;//æ­£ç¡® //2ã€const ä¿®é¥°å¸¸é‡ æŒ‡é’ˆå¸¸é‡ int* const p2 = &amp;a; *p2 = 100;//æ­£ç¡® //p2 = &amp;b; é”™è¯¯ //3ã€const æ—¢ä¿®é¥°å¸¸é‡åˆä¿®é¥°æŒ‡é’ˆ const int * const p3 = &amp;a; //*p3 = 100 é”™è¯¯ //p3 = &amp;b é”™è¯¯&#125; æŒ‡é’ˆå’Œæ•°ç»„åˆ©ç”¨æŒ‡é’ˆè®¿é—®æ•°ç»„ä¸­çš„æ•°æ®å…ƒç´  1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 ,10 &#125;; int* p = arr; cout &lt;&lt; &quot;ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºï¼š&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;æŒ‡é’ˆè®¿é—®ç¬¬ä¸€ä¸ªå…ƒç´ ï¼š&quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; *p &lt;&lt; endl; p++; &#125;&#125; è¿è¡Œç»“æœä¸ºï¼š ç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºï¼š1æŒ‡é’ˆè®¿é—®ç¬¬ä¸€ä¸ªå…ƒç´ ï¼š112345678910 æŒ‡é’ˆå’Œå‡½æ•°åˆ©ç”¨æŒ‡é’ˆä½œä¸ºå‡½æ•°å‚æ•°ï¼Œå¯ä»¥ä¿®æ”¹å®å‚çš„å€¼ 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;void swap01(int a, int b)&#123; int temp = a; a = b; b = temp; return ;&#125;void swap02(int* p1, int* p2)&#123; int temp = *p1; *p1 = *p2; *p2 = temp;&#125;int main()&#123; int a = 10; int b = 20; //1ã€å€¼ä¼ é€’ swap01(a, b); cout &lt;&lt; &quot;swap01åaçš„å€¼ä¸º&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap01åbçš„å€¼ä¸º&quot; &lt;&lt; b &lt;&lt; endl; //2ã€åœ°å€ä¼ é€’ swap02(&amp;a, &amp;b); cout &lt;&lt; &quot;swap02åaçš„å€¼ä¸º&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap02åbçš„å€¼ä¸º&quot; &lt;&lt; b &lt;&lt; endl;&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š swap01åaçš„å€¼ä¸º10swap01åbçš„å€¼ä¸º20swap02åaçš„å€¼ä¸º20swap02åbçš„å€¼ä¸º10 æŒ‡é’ˆã€æ•°ç»„ã€å‡½æ•°æ¡ˆä¾‹æè¿°ï¼šå°è£…ä¸€ä¸ªå‡½æ•°ï¼Œåˆ©ç”¨å†’æ³¡æ’åºï¼Œå®ç°å¯¹æ•´å‹æ•°ç»„çš„å‡åºæ’åº 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;//å†’æ³¡æ’åºå‡½æ•°void bubbleSort(int * arr, int len)&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; //å¦‚æœj&gt;j+1,äº¤æ¢æ•°å­— if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//æ‰“å°æ•°ç»„void printArray(int* arr, int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;int main()&#123; //1ã€åˆ›å»ºæ•°ç»„ int arr[10] = &#123;4 , 3 , 6 , 9 , 1 , 2 , 10 , 8 , 7 , 5&#125;; //æ•°ç»„é•¿åº¦ int len = sizeof(arr) / sizeof(arr[0]); //2ã€åˆ›å»ºå‡½æ•°ï¼Œå®ç°å†’æ³¡æ’åº bubbleSort(arr, len); //3ã€æ‰“å°æ’åºåçš„æ•°ç»„ printArray(arr, len);&#125; è¿è¡Œç»“æœå¦‚ä¸‹ï¼š 12345678910","categories":[{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"æŒ‡é’ˆ","slug":"æŒ‡é’ˆ","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"}]},{"title":"å­¦ä¹ è·¯å¾„","slug":"å­¦ä¹ è·¯å¾„","date":"2023-04-08T12:15:26.000Z","updated":"2023-04-29T12:22:35.643Z","comments":true,"path":"2023/04/08/å­¦ä¹ è·¯å¾„/","link":"","permalink":"http://example.com/2023/04/08/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/","excerpt":"Rustå­¦ä¹ Rustçš„è¿‡ç¨‹æ¶‰åŠå¤šä¸ªé˜¶æ®µã€‚è¿™é‡Œæä¾›äº†ä¸€ä¸ªè¯¦ç»†çš„Rustå­¦ä¹ è®¡åˆ’ï¼Œå¸®åŠ©æ‚¨é€æ­¥æŒæ¡è¿™é—¨è¯­è¨€ï¼š 1. åŸºç¡€é˜¶æ®µ","text":"Rustå­¦ä¹ Rustçš„è¿‡ç¨‹æ¶‰åŠå¤šä¸ªé˜¶æ®µã€‚è¿™é‡Œæä¾›äº†ä¸€ä¸ªè¯¦ç»†çš„Rustå­¦ä¹ è®¡åˆ’ï¼Œå¸®åŠ©æ‚¨é€æ­¥æŒæ¡è¿™é—¨è¯­è¨€ï¼š 1. åŸºç¡€é˜¶æ®µ é˜…è¯»ã€ŠRustç¼–ç¨‹è¯­è¨€ã€‹ï¼ˆThe Rust Programming Languageï¼Œåˆç§°â€The Bookâ€ï¼‰ï¼šè¿™æ˜¯å­¦ä¹ Rustçš„å®˜æ–¹æ•™æï¼Œä¸ºåˆå­¦è€…æä¾›äº†å…¨é¢çš„å…¥é—¨çŸ¥è¯†ã€‚åœ¨çº¿ç‰ˆæœ¬å¯å…è´¹è®¿é—®ï¼šThe Rust Programming Language - The Rust Programming Language å­¦ä¹ Rustçš„åŸºæœ¬è¯­æ³•ã€æ•°æ®ç±»å‹ã€æ§åˆ¶ç»“æ„ã€é”™è¯¯å¤„ç†ç­‰æ¦‚å¿µã€‚ å®Œæˆã€ŠThe Bookã€‹ä¸­çš„ç¤ºä¾‹å’Œç»ƒä¹ ï¼Œä»¥å·©å›ºæ‰€å­¦çŸ¥è¯†ã€‚ å‚åŠ Rustç¤¾åŒºæ´»åŠ¨ï¼Œå¦‚é˜…è¯»è®ºå›å¸–å­ã€åŠ å…¥èŠå¤©å®¤å’Œé‚®ä»¶åˆ—è¡¨ï¼Œä»¥äº†è§£æœ€æ–°åŠ¨æ€å’Œè·å¾—å¸®åŠ©ã€‚ 2. å®è·µé˜¶æ®µ å°è¯•è§£å†³ä¸€äº›ç®€å•çš„ç¼–ç¨‹é—®é¢˜ï¼Œä¾‹å¦‚LeetCodeä¸Šçš„é¢˜ç›®ï¼Œä»¥ç†Ÿæ‚‰Rustçš„ç¼–ç¨‹èŒƒå¼ã€‚ é˜…è¯»Rustç¼–å†™çš„å¼€æºé¡¹ç›®ä»£ç ï¼Œå­¦ä¹ ä»–äººå¦‚ä½•ä½¿ç”¨Rustè§£å†³å®é™…é—®é¢˜ã€‚ å‚ä¸å¼€æºé¡¹ç›®ï¼Œä¸ºRustç”Ÿæ€åšè´¡çŒ®ã€‚è¿™å¯ä»¥å¸®åŠ©æ‚¨ç†Ÿæ‚‰å®é™…é¡¹ç›®ä¸­çš„ç¼–ç¨‹å®è·µã€ä»£ç å®¡æŸ¥å’Œåä½œæµç¨‹ã€‚ å¼€å§‹å®ç°è‡ªå·±çš„é¡¹ç›®ï¼Œå°†å­¦åˆ°çš„çŸ¥è¯†åº”ç”¨äºå®è·µã€‚å¯ä»¥ä»ä¸€ä¸ªç®€å•çš„å‘½ä»¤è¡Œå·¥å…·æˆ–WebæœåŠ¡å¼€å§‹ã€‚ 3. è¿›é˜¶é˜¶æ®µ æ·±å…¥äº†è§£Rustçš„æ‰€æœ‰æƒï¼ˆOwnershipï¼‰ã€å€Ÿç”¨ï¼ˆBorrowingï¼‰å’Œç”Ÿå‘½å‘¨æœŸï¼ˆLifetimeï¼‰ç³»ç»Ÿã€‚è¿™æ˜¯ç†è§£Rustå†…å­˜å®‰å…¨çš„å…³é”®ã€‚ å­¦ä¹ Rustçš„å¹¶å‘å’Œå¼‚æ­¥ç¼–ç¨‹ã€‚æŒæ¡å¦‚ä½•ä½¿ç”¨çº¿ç¨‹ã€é€šé“ã€å¼‚æ­¥I&#x2F;Oå’Œasync/awaitç¼–å†™é«˜æ€§èƒ½ã€å¯æ‰©å±•çš„Rustä»£ç ã€‚ é˜…è¯»Rustçš„å®˜æ–¹æ–‡æ¡£ï¼Œä¾‹å¦‚ã€ŠRustå¼‚æ­¥ç¼–ç¨‹ã€‹ï¼ˆAsynchronous Programming in Rustï¼‰å’Œã€ŠRustæ ‡å‡†åº“æ–‡æ¡£ã€‹ï¼ˆThe Rust Standard Library Documentationï¼‰ï¼Œä»¥æ·±å…¥äº†è§£å„ç§æ¦‚å¿µå’ŒAPIã€‚ å­¦ä¹ Rustçš„å®ï¼ˆMacrosï¼‰ç³»ç»Ÿï¼Œäº†è§£å¦‚ä½•ç¼–å†™DRYï¼ˆDonâ€™t Repeat Yourselfï¼‰ä»£ç å’Œå…ƒç¼–ç¨‹ã€‚ 4. ä¸“ä¸šé˜¶æ®µ æ¢ç´¢Ruståœ¨ä¸åŒé¢†åŸŸçš„åº”ç”¨ï¼Œä¾‹å¦‚Webå¼€å‘ã€åµŒå…¥å¼ç³»ç»Ÿã€æ¸¸æˆå¼€å‘ã€åŒºå—é“¾ç­‰ã€‚ é˜…è¯»æœ‰å…³Rustæ€§èƒ½ä¼˜åŒ–ã€å®‰å…¨æ€§å’Œæœ€ä½³å®è·µçš„æ–‡ç« å’Œæ•™ç¨‹ã€‚ å‚åŠ Rustä¼šè®®å’Œç ”è®¨ä¼šï¼Œä¸å…¶ä»–Rustå¼€å‘è€…äº¤æµç»éªŒå’ŒæŠ€å·§ã€‚ è€ƒè™‘æŠ•å…¥åˆ°Rustç”Ÿæ€ç³»ç»Ÿçš„å¼€å‘ä¸­ï¼Œä¾‹å¦‚ç¼–å†™åº“ã€å·¥å…·å’Œæ¡†æ¶ï¼Œä¸ºç¤¾åŒºæä¾›è´¡çŒ®ã€‚ C++C++æ˜¯ä¸€é—¨åŠŸèƒ½å¼ºå¤§çš„ç¼–ç¨‹è¯­è¨€ï¼Œå­¦ä¹ è¿‡ç¨‹å¯ä»¥åˆ†ä¸ºå¤šä¸ªé˜¶æ®µã€‚ä»¥ä¸‹æ˜¯ä¸€ä»½è¯¦ç»†çš„C++å­¦ä¹ è®¡åˆ’ï¼Œå¸®åŠ©æ‚¨é€æ­¥æŒæ¡C++ï¼š 1. åŸºç¡€é˜¶æ®µ é˜…è¯»C++çš„ç»å…¸æ•™æï¼Œå¦‚ã€ŠC++ Primerã€‹(by Stanley B. Lippman, JosÃ©e Lajoie, and Barbara E. Moo) æˆ–ã€ŠC++ç¨‹åºè®¾è®¡åŸç†ä¸å®è·µã€‹ï¼ˆProgramming: Principles and Practice Using C++, by Bjarne Stroustrupï¼‰ã€‚ å­¦ä¹ C++çš„åŸºæœ¬è¯­æ³•ã€æ•°æ®ç±»å‹ã€æ§åˆ¶ç»“æ„ã€å‡½æ•°ã€ç±»å’Œå¯¹è±¡ç­‰æ¦‚å¿µã€‚ ç»ƒä¹ ç¼–å†™ç®€å•çš„C++ç¨‹åºï¼Œå·©å›ºæ‰€å­¦çŸ¥è¯†ã€‚ å‚åŠ åœ¨çº¿C++ç¤¾åŒºæ´»åŠ¨ï¼Œå¦‚Stack Overflowå’ŒC++ subredditï¼Œäº†è§£æœ€æ–°åŠ¨æ€å’Œè·å¾—å¸®åŠ©ã€‚ 2. å®è·µé˜¶æ®µ å­¦ä¹ ä½¿ç”¨C++æ ‡å‡†åº“ï¼ˆSTLï¼‰ï¼ŒæŒæ¡å®¹å™¨ã€ç®—æ³•å’Œè¿­ä»£å™¨ç­‰é‡è¦æ¦‚å¿µã€‚ å°è¯•è§£å†³ä¸€äº›å®é™…ç¼–ç¨‹é—®é¢˜ï¼Œä¾‹å¦‚LeetCodeä¸Šçš„é¢˜ç›®ï¼Œä»¥ç†Ÿæ‚‰C++ç¼–ç¨‹èŒƒå¼ã€‚ é˜…è¯»å¼€æºC++é¡¹ç›®çš„ä»£ç ï¼Œå­¦ä¹ ä»–äººå¦‚ä½•ä½¿ç”¨C++è§£å†³å®é™…é—®é¢˜ã€‚ å‚ä¸å¼€æºé¡¹ç›®ï¼Œä¸ºC++ç”Ÿæ€åšè´¡çŒ®ã€‚è¿™å¯ä»¥å¸®åŠ©æ‚¨ç†Ÿæ‚‰å®é™…é¡¹ç›®ä¸­çš„ç¼–ç¨‹å®è·µã€ä»£ç å®¡æŸ¥å’Œåä½œæµç¨‹ã€‚ å¼€å§‹å®ç°è‡ªå·±çš„é¡¹ç›®ï¼Œå°†å­¦åˆ°çš„çŸ¥è¯†åº”ç”¨äºå®è·µã€‚å¯ä»¥ä»ä¸€ä¸ªç®€å•çš„å‘½ä»¤è¡Œå·¥å…·æˆ–å›¾å½¢ç•Œé¢åº”ç”¨å¼€å§‹ã€‚ 3. è¿›é˜¶é˜¶æ®µ æ·±å…¥å­¦ä¹ C++çš„é«˜çº§ç‰¹æ€§ï¼Œå¦‚æ¨¡æ¿ã€å¼‚å¸¸å¤„ç†ã€æ™ºèƒ½æŒ‡é’ˆã€å¤šæ€ç­‰ã€‚ å­¦ä¹ C++çš„å¹¶å‘å’Œå¤šçº¿ç¨‹ç¼–ç¨‹ï¼ŒæŒæ¡çº¿ç¨‹ã€äº’æ–¥é‡ã€æ¡ä»¶å˜é‡ç­‰æ¦‚å¿µã€‚ é˜…è¯»æœ‰å…³C++æ€§èƒ½ä¼˜åŒ–ã€å†…å­˜ç®¡ç†å’Œæœ€ä½³å®è·µçš„æ–‡ç« å’Œæ•™ç¨‹ã€‚ å­¦ä¹ C++11ã€C++14ã€C++17ã€C++20ç­‰æ–°æ ‡å‡†ä¸­çš„æ–°ç‰¹æ€§ï¼Œä»¥ä¾¿ç¼–å†™ç°ä»£ã€é«˜æ•ˆçš„C++ä»£ç ã€‚ 4. ä¸“ä¸šé˜¶æ®µ æ¢ç´¢C++åœ¨ä¸åŒé¢†åŸŸçš„åº”ç”¨ï¼Œä¾‹å¦‚æ¸¸æˆå¼€å‘ã€é«˜æ€§èƒ½è®¡ç®—ã€åµŒå…¥å¼ç³»ç»Ÿç­‰ã€‚ å­¦ä¹ ä½¿ç”¨C++ç¼–å†™è·¨å¹³å°åº”ç”¨ç¨‹åºï¼Œä½¿ç”¨è¯¸å¦‚Qtç­‰æ¡†æ¶ã€‚ å‚åŠ C++ä¼šè®®å’Œç ”è®¨ä¼šï¼Œä¸å…¶ä»–C++å¼€å‘è€…äº¤æµç»éªŒå’ŒæŠ€å·§ã€‚ è€ƒè™‘æŠ•å…¥åˆ°C++ç”Ÿæ€ç³»ç»Ÿçš„å¼€å‘ä¸­ï¼Œä¾‹å¦‚ç¼–å†™åº“ã€å·¥å…·å’Œæ¡†æ¶ï¼Œä¸ºç¤¾åŒºæä¾›è´¡çŒ®ã€‚ äº‘ç³»ç»Ÿå†…æ ¸å®‰å…¨äº‘ç³»ç»Ÿå†…æ ¸å®‰å…¨æ˜¯ä¸€ä¸ªé«˜åº¦ä¸“ä¸šåŒ–çš„é¢†åŸŸï¼Œæ¶‰åŠæ“ä½œç³»ç»Ÿã€è™šæ‹ŸåŒ–æŠ€æœ¯ã€ç¡¬ä»¶å®‰å…¨ç­‰å¤šæ–¹é¢çŸ¥è¯†ã€‚ä»¥ä¸‹æ˜¯ä¸€ä»½è¯¦ç»†çš„äº‘ç³»ç»Ÿå†…æ ¸å®‰å…¨å­¦ä¹ è®¡åˆ’ï¼Œå¸®åŠ©æ‚¨é€æ­¥æŒæ¡ç›¸å…³çŸ¥è¯†ï¼š 1. åŸºç¡€é˜¶æ®µ å­¦ä¹ è®¡ç®—æœºç»„æˆåŸç†å’Œè®¡ç®—æœºä½“ç³»ç»“æ„ï¼Œäº†è§£CPUã€å†…å­˜ã€IOè®¾å¤‡ç­‰åŸºæœ¬æ¦‚å¿µã€‚ å­¦ä¹ æ“ä½œç³»ç»ŸåŸºç¡€çŸ¥è¯†ï¼Œå¦‚è¿›ç¨‹ã€çº¿ç¨‹ã€å†…å­˜ç®¡ç†ã€æ–‡ä»¶ç³»ç»Ÿã€è®¾å¤‡é©±åŠ¨ç­‰ã€‚ å­¦ä¹ ç½‘ç»œåŸºç¡€çŸ¥è¯†ï¼ŒæŒæ¡TCP&#x2F;IPåè®®æ ˆã€ç½‘ç»œè®¾å¤‡ã€ç½‘ç»œå®‰å…¨ç­‰æ¦‚å¿µã€‚ 2. è™šæ‹ŸåŒ–æŠ€æœ¯é˜¶æ®µ å­¦ä¹ è™šæ‹ŸåŒ–æŠ€æœ¯çš„åŸºæœ¬åŸç†ï¼Œäº†è§£å…¨è™šæ‹ŸåŒ–å’ŒåŠè™šæ‹ŸåŒ–çš„åŒºåˆ«ã€‚ å­¦ä¹ å¸¸è§çš„è™šæ‹ŸåŒ–å¹³å°ï¼Œå¦‚VMwareã€KVMã€Xenã€Hyper-Vç­‰ï¼Œäº†è§£å®ƒä»¬çš„æ¶æ„å’Œç‰¹ç‚¹ã€‚ å­¦ä¹ å®¹å™¨æŠ€æœ¯ï¼Œå¦‚Dockerå’ŒKubernetesï¼Œäº†è§£ä¸è™šæ‹Ÿæœºç›¸æ¯”çš„ä¼˜åŠ¿å’Œå±€é™ã€‚ 3. äº‘å®‰å…¨é˜¶æ®µ å­¦ä¹ äº‘è®¡ç®—çš„åŸºæœ¬æ¦‚å¿µï¼Œäº†è§£IaaSã€PaaSã€SaaSç­‰æœåŠ¡æ¨¡å‹ã€‚ å­¦ä¹ ä¸»æµäº‘æœåŠ¡æä¾›å•†ï¼ˆå¦‚AWSã€Azureã€Google Cloudã€é˜¿é‡Œäº‘ç­‰ï¼‰çš„å®‰å…¨æœåŠ¡å’Œæœ€ä½³å®è·µã€‚ äº†è§£äº‘å®‰å…¨çš„å…±äº«è´£ä»»æ¨¡å‹ï¼Œå­¦ä¼šåœ¨äº‘ç¯å¢ƒä¸­ä¿æŠ¤æ•°æ®ã€ç½‘ç»œã€åº”ç”¨å’Œç”¨æˆ·çš„å®‰å…¨ã€‚ 4. å†…æ ¸å®‰å…¨é˜¶æ®µ æ·±å…¥å­¦ä¹ æ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œäº†è§£å†…æ ¸æ€å’Œç”¨æˆ·æ€çš„åŒºåˆ«ï¼Œå­¦ä¹ å†…æ ¸ç¼–ç¨‹ã€‚ å­¦ä¹ å†…æ ¸æ¼æ´çš„ç±»å‹å’ŒåŸç†ï¼Œä¾‹å¦‚ç¼“å†²åŒºæº¢å‡ºã€ç«äº‰æ¡ä»¶ã€ææƒæ¼æ´ç­‰ã€‚ å­¦ä¹ å†…æ ¸æ¼æ´çš„åˆ©ç”¨æŠ€æœ¯ï¼Œå¦‚ROPã€å †å–·å°„ã€å†…æ ¸åœ°å€æ³„éœ²ç­‰ã€‚ å­¦ä¹ å†…æ ¸å®‰å…¨é˜²æŠ¤æŠ€æœ¯ï¼Œå¦‚å†…æ ¸åœ°å€éšæœºåŒ–ï¼ˆKASLRï¼‰ã€å†…æ ¸ä»£ç åªè¯»ï¼ˆROï¼‰ã€å†…å­˜ä¿æŠ¤æ‰©å±•ï¼ˆMPXï¼‰ç­‰ã€‚ 5. äº‘ç³»ç»Ÿå†…æ ¸å®‰å…¨é˜¶æ®µ å­¦ä¹ è™šæ‹ŸåŒ–ç¯å¢ƒä¸‹çš„å†…æ ¸å®‰å…¨æŒ‘æˆ˜ï¼Œå¦‚è™šæ‹Ÿæœºé€ƒé€¸ã€å…±äº«èµ„æºæ”»å‡»ç­‰ã€‚ å­¦ä¹ å®¹å™¨ç¯å¢ƒä¸‹çš„å†…æ ¸å®‰å…¨æŒ‘æˆ˜ï¼Œå¦‚å®¹å™¨é€ƒé€¸ã€èµ„æºéš”ç¦»ä¸è¶³ç­‰ã€‚ å­¦ä¹ ç¡¬ä»¶å®‰å…¨æŠ€æœ¯ï¼Œå¦‚å®‰å…¨å¼•å¯¼ï¼ˆSecure Bootï¼‰ã€å¯ä¿¡è®¡ç®—ï¼ˆTPMï¼‰ã€è‹±ç‰¹å°”SGXç­‰ã€‚ å­¦ä¹ äº‘ç¯å¢ƒä¸‹çš„å†…æ ¸å®‰å…¨åŠ å›ºæªæ–½ï¼Œå¦‚å®‰å…¨åŸºçº¿ã€ç›‘æ§ã€è‡ªåŠ¨åŒ–è¡¥ä¸ç­‰ã€‚ 6. å®è·µé˜¶æ®µ å‚ä¸å¼€æºå†…æ ¸å®‰å…¨é¡¹ç›®ï¼Œä¸ºç¤¾åŒºæä¾›è´¡çŒ®ã€‚ é˜…è¯»å†…æ ¸å®‰å…¨ç›¸å…³çš„ç ”ç©¶è®ºæ–‡å’ŒæŠ€æœ¯æŠ¥å‘Šï¼Œäº†è§£æœ€æ–°çš„ç ”ç©¶åŠ¨æ€ã€‚ å‚åŠ å†…æ ¸å®‰å…¨å’Œäº‘å®‰å…¨çš„ä¼šè®®å’Œç ”è®¨ä¼šï¼Œä¸åŒè¡Œäº¤æµç»éªŒå’ŒæŠ€å·§ã€‚ pwnå­¦ä¹ ç½‘ç»œå®‰å…¨å’Œ â€œpwnâ€ æŠ€èƒ½éœ€è¦æ—¶é—´å’ŒåŠªåŠ›ï¼Œä½†é€šè¿‡åˆ¶å®šä¸€ä¸ªåˆç†çš„è®¡åˆ’ï¼Œä½ å¯ä»¥é€æ­¥æŒæ¡æ‰€éœ€çš„çŸ¥è¯†å’ŒæŠ€èƒ½ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªå»ºè®®çš„å­¦ä¹ è®¡åˆ’ï¼š å­¦ä¹ åŸºç¡€çŸ¥è¯†ï¼š è®¡ç®—æœºç§‘å­¦åŸºç¡€ï¼šäº†è§£è®¡ç®—æœºç³»ç»Ÿçš„åŸºæœ¬åŸç†ï¼Œå­¦ä¹ ç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚ Python, C, Java æˆ– JavaScriptï¼‰ã€‚ è®¡ç®—æœºç½‘ç»œï¼šå­¦ä¹ ç½‘ç»œåŸºæœ¬åŸç†ï¼Œå¦‚ OSI æ¨¡å‹ã€TCP&#x2F;IP åè®®ã€è·¯ç”±å’Œäº¤æ¢ç­‰ã€‚ æ“ä½œç³»ç»Ÿï¼šç†Ÿæ‚‰ Windowsã€Linux å’Œ macOS ç­‰æ“ä½œç³»ç»Ÿçš„åŸç†å’Œä½¿ç”¨ã€‚ å­¦ä¹ ç½‘ç»œå®‰å…¨åŸºç¡€ï¼š åŠ å¯†ä¸è§£å¯†ï¼šå­¦ä¹ åŸºæœ¬çš„å¯†ç å­¦åŸç†ï¼Œå¦‚å¯¹ç§°åŠ å¯†ã€éå¯¹ç§°åŠ å¯†ã€å“ˆå¸Œå‡½æ•°ç­‰ã€‚ ç³»ç»Ÿå®‰å…¨ï¼šäº†è§£å¸¸è§çš„ç³»ç»Ÿæ¼æ´ï¼Œå¦‚ç¼“å†²åŒºæº¢å‡ºã€SQL æ³¨å…¥ã€è·¨ç«™è„šæœ¬ç­‰ã€‚ å®‰å…¨å·¥å…·ï¼šç†Ÿæ‚‰å¸¸ç”¨çš„å®‰å…¨å·¥å…·ï¼Œå¦‚ Wiresharkã€Nmapã€Metasploit ç­‰ã€‚ æŒæ¡ Pwn æŠ€èƒ½ï¼š é™æ€åˆ†æï¼šå­¦ä¹ ä½¿ç”¨åæ±‡ç¼–å’Œè°ƒè¯•å·¥å…·ï¼ˆå¦‚ IDA Proã€Ghidraã€OllyDbg ç­‰ï¼‰åˆ†æç¨‹åºã€‚ åŠ¨æ€åˆ†æï¼šå­¦ä¹ ä½¿ç”¨è°ƒè¯•å™¨ï¼ˆå¦‚ GDBã€x64dbg ç­‰ï¼‰è°ƒè¯•ç¨‹åºï¼Œäº†è§£ç¨‹åºè¿è¡Œæ—¶çš„çŠ¶æ€ã€‚ æ¼æ´æŒ–æ˜ï¼šå­¦ä¹ å¦‚ä½•å‘ç°æ½œåœ¨æ¼æ´ï¼Œå¦‚å†…å­˜æ³„æ¼ã€æ•´æ•°æº¢å‡ºã€æ ¼å¼åŒ–å­—ç¬¦ä¸²ç­‰ã€‚ æ¼æ´åˆ©ç”¨ï¼šå­¦ä¹ ç¼–å†™åˆ©ç”¨ä»£ç ï¼Œå¦‚åˆ©ç”¨ ROP æŠ€æœ¯ç»•è¿‡ DEPã€ä½¿ç”¨å †å–·å°„ç»•è¿‡ ASLR ç­‰ã€‚ å®è·µä¸è¿›é˜¶ï¼š å‚åŠ  CTF æ¯”èµ›ï¼šå‚åŠ  Capture The Flagï¼ˆCTFï¼‰æ¯”èµ›ï¼Œæé«˜å®æˆ˜èƒ½åŠ›ã€‚ ç ”ç©¶æ¼æ´æ¡ˆä¾‹ï¼šåˆ†æå·²çŸ¥çš„æ¼æ´æ¡ˆä¾‹ï¼Œäº†è§£æ¼æ´å‘ç°å’Œåˆ©ç”¨çš„å…·ä½“è¿‡ç¨‹ã€‚ å­¦ä¹ å®‰å…¨ç ”ç©¶è®ºæ–‡ï¼šé˜…è¯»ç½‘ç»œå®‰å…¨é¢†åŸŸçš„å­¦æœ¯è®ºæ–‡ï¼Œè·Ÿè¸ªæœ€æ–°æŠ€æœ¯å’Œç ”ç©¶æˆæœã€‚ å‚ä¸å¼€æºé¡¹ç›®ï¼šå‚ä¸ç½‘ç»œå®‰å…¨ç›¸å…³çš„å¼€æºé¡¹ç›®ï¼Œå¦‚æ¼æ´æ‰«æå™¨ã€å®‰å…¨æ¡†æ¶ç­‰ã€‚ æŒç»­å­¦ä¹ ï¼š å…³æ³¨å®‰å…¨é¢†åŸŸçš„æ–°é—»å’ŒåŠ¨æ€ï¼šå…³æ³¨ç½‘ç»œå®‰å…¨é¢†åŸŸçš„æ–°é—»ã€åšå®¢ã€æ¼æ´æŠ¥å‘Šç­‰ã€‚ å‚åŠ å®‰å…¨ä¼šè®®ï¼šå‚åŠ ç½‘ç»œå®‰å…¨ä¼šè®®ï¼ˆå¦‚ DEFCONã€Black Hat ç­‰ï¼‰ï¼Œäº†è§£æœ€æ–°çš„å®‰å…¨è¶‹åŠ¿å’ŒæŠ€æœ¯ã€‚ å»ºç«‹ä¸ªäººç½‘ç»œï¼šåŠ å…¥ç½‘ç»œå®‰å…¨ç¤¾åŒºï¼Œä¸åŒè¡Œäº¤æµï¼Œåˆ†äº«ç»éªŒå’ŒæŠ€å·§ã€‚","categories":[{"name":"å­¦ä¹ è·¯å¾„","slug":"å­¦ä¹ è·¯å¾„","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"}],"tags":[]},{"title":"Ubuntuæºç  /proc/meminfo","slug":"å­¦ä¹  Ubuntuæºç -proc-meminfo","date":"2023-04-06T06:56:58.000Z","updated":"2023-04-06T07:26:56.266Z","comments":true,"path":"2023/04/06/å­¦ä¹  Ubuntuæºç -proc-meminfo/","link":"","permalink":"http://example.com/2023/04/06/%E5%AD%A6%E4%B9%A0%20Ubuntu%E6%BA%90%E7%A0%81-proc-meminfo/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253MemTotal: 3982192 kB ç³»ç»Ÿæ€»å†…å­˜å¤§å°MemFree: 333280 kB ç³»ç»Ÿä¸­æœªä½¿ç”¨çš„å†…å­˜å¤§å°MemAvailable: 2062852 kB ç³»ç»Ÿä¸­å¯ä¾›åˆ†é…çš„å†…å­˜å¤§å°ï¼ŒåŒ…æ‹¬ç¼“å­˜å’Œç¼“å†²åŒºBuffers: 149848 kB ç”¨äºæ–‡ä»¶I/Oçš„ä¸´æ—¶å­˜å‚¨åŒºåŸŸçš„å¤§å°Cached: 1762576 kB è¢«æ“ä½œç³»ç»Ÿç¼“å­˜çš„æ–‡ä»¶å¤§å°SwapCached: 356 kB å·²è¢«äº¤æ¢ä¸”åœ¨å†…å­˜ä¸­çš„æ•°æ®å¤§å°Active: 1183472 kB æ­£åœ¨ä½¿ç”¨æˆ–æœ€è¿‘è¢«ä½¿ç”¨è¿‡çš„å†…å­˜å¤§å°Inactive: 1406216 kB æœ€è¿‘æ²¡æœ‰è¢«ä½¿ç”¨çš„å†…å­˜å¤§å°Active(anon): 2988 kB æ´»åŠ¨åŒ¿åå†…å­˜å¤§å°ï¼Œä¸åŒ…æ‹¬æ–‡ä»¶Inactive(anon): 723692 kB éæ´»åŠ¨åŒ¿åå†…å­˜å¤§å°ï¼Œä¸åŒ…æ‹¬æ–‡ä»¶Active(file): 1180484 kB æ´»åŠ¨æ–‡ä»¶å†…å­˜å¤§å°Inactive(file): 682524 kB éæ´»åŠ¨æ–‡ä»¶å†…å­˜å¤§å°Unevictable: 0 kB æ— æ³•é©±é€çš„å†…å­˜å¤§å°Mlocked: 0 kB é”å®šåœ¨å†…å­˜ä¸­çš„å†…å­˜å¤§å°SwapTotal: 3991548 kB ç³»ç»Ÿæ€»äº¤æ¢ç©ºé—´å¤§å°SwapFree: 3987928 kB ç³»ç»Ÿäº¤æ¢ç©ºé—´ç©ºé—²å†…å­˜Zswap: 0 kB ä½¿ç”¨ zswap çš„å‹ç¼©äº¤æ¢ç¼“å­˜å¤§å°Zswapped: 0 kB ä½¿ç”¨ zswap çš„å‹ç¼©äº¤æ¢ç¼“å­˜å¤§å°Dirty: 180 kB ç­‰å¾…å†™å›ç£ç›˜çš„å†…å­˜å¤§å°Writeback: 0 kB æ­£åœ¨å†™å›ç£ç›˜çš„å†…å­˜å¤§å°AnonPages: 676928 kB æœªæ˜ å°„åˆ°æ–‡ä»¶çš„åŒ¿åå†…å­˜å¤§å°Mapped: 339472 kB æ˜ å°„åˆ°æ–‡ä»¶çš„å†…å­˜å¤§å°Shmem: 55032 kB å…±äº«å†…å­˜å¤§å°KReclaimable: 142032 kB å¯å›æ”¶çš„å†…æ ¸å†…å­˜å¤§å°Slab: 417952 kB å†…æ ¸æ•°æ®ç»“æ„ç¼“å­˜çš„å¤§å°SReclaimable: 142032 kB å¯å›æ”¶çš„ Slab å†…å­˜å¤§å°SUnreclaim: 275920 kB ä¸å¯å›æ”¶çš„ Slab å†…å­˜å¤§å°KernelStack: 11180 kB å†…æ ¸æ ˆä½¿ç”¨çš„å†…å­˜å¤§å°PageTables: 16944 kB é¡µè¡¨ä½¿ç”¨çš„å†…å­˜å¤§å°NFS_Unstable: 0 kB NFS ä¸ç¨³å®šé¡µç¼“å­˜çš„å¤§å°Bounce: 0 kB ç”¨äºå—è®¾å¤‡ I/O çš„è·³è·ƒç¼“å†²åŒºå¤§å°WritebackTmp: 0 kB ä¸´æ—¶å†™å›å†…å­˜å¤§å°CommitLimit: 5982644 kB åŸºäºå†…å­˜å’Œäº¤æ¢ç©ºé—´çš„æäº¤é™åˆ¶Committed_AS: 4906744 kB å·²æäº¤çš„å†…å­˜å¤§å°ï¼ŒåŒ…æ‹¬å†…å­˜å’Œäº¤æ¢ç©ºé—´VmallocTotal: 34359738367kB è™šæ‹Ÿå†…å­˜åˆ†é…çš„æ€»é‡ï¼Œè¿™æ˜¯ç³»ç»Ÿå¯ä»¥ä½¿ç”¨çš„è™šæ‹Ÿå†…å­˜æ€»é‡VmallocUsed: 251220 kB å·²ä½¿ç”¨çš„è™šæ‹Ÿå†…å­˜é‡VmallocChunk: 0 kB æœ€å¤§è¿ç»­è™šæ‹Ÿå†…å­˜ç©ºé—²åŒºåŸŸçš„å¤§å°Percpu: 134656 kB æ¯ä¸ª CPU çš„å†…å­˜ä½¿ç”¨é‡ï¼Œè¿™ä¸ªå€¼æ˜¯æ¯ä¸ª CPU çš„ per-CPU åŒºåŸŸçš„å¤§å°ä¹‹å’ŒHardwareCorrupted: 0 kB ç”±ç¡¬ä»¶é”™è¯¯å¯¼è‡´çš„æŸåå†…å­˜é‡AnonHugePages: 4096 kB ç”¨äºåŒ¿åæ˜ å°„çš„å¤§å†…å­˜é¡µçš„æ€»é‡ï¼Œè¿™äº›æ˜ å°„ä¸ä¼šå…³è”åˆ°ä»»ä½•æ–‡ä»¶ShmemHugePages: 0 kB ç”¨äºå…±äº«å†…å­˜ï¼ˆshmemï¼‰çš„å¤§å†…å­˜é¡µçš„æ€»é‡ShmemPmdMapped: 0 kB å·²æ˜ å°„åˆ°å…±äº«å†…å­˜çš„PMDå¤§å°ï¼ŒPMD æ˜¯é¡µä¸­é—´ç›®å½•çš„ç¼©å†™FileHugePages: 0 kB ç”¨äºæ–‡ä»¶æ˜ å°„çš„å¤§å†…å­˜é¡µçš„æ€»é‡FilePmdMapped: 0 kB å·²æ˜ å°„åˆ°æ–‡ä»¶çš„ PMD å¤§å°HugePages_Total: 0 ç³»ç»Ÿé…ç½®çš„å¤§å†…å­˜é¡µçš„æ€»æ•°HugePages_Free: 0 å½“å‰å¯ç”¨çš„å¤§å†…å­˜é¡µçš„æ•°é‡HugePages_Rsvd: 0 å·²é¢„ç•™ï¼ˆä¿ç•™ï¼‰ä½†å°šæœªä½¿ç”¨çš„å¤§å†…å­˜é¡µçš„æ•°é‡HugePages_Surp: 0 è¶…å‡ºç³»ç»Ÿéœ€æ±‚çš„å¤§å†…å­˜é¡µçš„æ•°é‡ï¼Œè¿™äº›é¡µå¯ä»¥åœ¨éœ€è¦æ—¶ç«‹å³åˆ†é…ç»™åº”ç”¨ç¨‹åºHugepagesize: 2048 kB ç³»ç»Ÿé…ç½®çš„å¤§å†…å­˜é¡µçš„å¤§å°Hugetlb: 0 kB å½“å‰ä½¿ç”¨çš„ hugetlb å†…å­˜æ± çš„æ€»å¤§å°ï¼Œhugetlb æ˜¯å¤§å†…å­˜é¡µçš„ç¼©å†™DirectMap4k: 202624 kB ä½¿ç”¨ 4KB å¤§å°çš„é¡µæ˜ å°„çš„ç‰©ç†å†…å­˜å¤§å°DirectMap2M: 3991552 kB ä½¿ç”¨ 2MB å¤§å°çš„é¡µæ˜ å°„çš„ç‰©ç†å†…å­˜å¤§å°DirectMap1G: 2097152 kB ä½¿ç”¨ 1GB å¤§å°çš„é¡µæ˜ å°„çš„ç‰©ç†å†…å­˜å¤§å°","categories":[{"name":"Ubuntuæºç ","slug":"Ubuntuæºç ","permalink":"http://example.com/categories/Ubuntu%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/tags/Ubuntu/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture04 Page Tables","slug":"MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables","date":"2023-04-05T09:03:11.000Z","updated":"2023-04-14T11:30:30.108Z","comments":true,"path":"2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/","link":"","permalink":"http://example.com/2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/","excerpt":"Topic Address Spaces æ”¯æŒè™šæ‹Ÿå†…å­˜çš„ç¡¬ä»¶ XVä¸­çš„è™šæ‹Ÿå†…å­˜ä»£ç  Address Spaces","text":"Topic Address Spaces æ”¯æŒè™šæ‹Ÿå†…å­˜çš„ç¡¬ä»¶ XVä¸­çš„è™šæ‹Ÿå†…å­˜ä»£ç  Address Spacesä¸ºä»€ä¹ˆéœ€è¦éš”ç¦»æ€§åˆ›é€ è™šæ‹Ÿå†…å­˜çš„ä¸€ä¸ªå‡ºå‘ç‚¹æ˜¯ä½ å¯ä»¥é€šè¿‡å®ƒå®ç°éš”ç¦»æ€§ã€‚å¦‚æœä½ æ­£ç¡®çš„è®¾ç½®äº†page tableï¼Œå¹¶ä¸”é€šè¿‡ä»£ç å¯¹å®ƒè¿›è¡Œæ­£ç¡®çš„ç®¡ç†ï¼Œé‚£ä¹ˆåŸåˆ™ä¸Šä½ å¯ä»¥å®ç°å¼ºéš”ç¦»ã€‚ æˆ‘ä»¬æœŸæœ›çš„æ˜¯ï¼Œæ¯ä¸ªç”¨æˆ·ç¨‹åºéƒ½è¢«è£…è¿›ä¸€ä¸ªç›’å­é‡Œï¼Œè¿™æ ·å®ƒä»¬å°±ä¸ä¼šå½¼æ­¤å½±å“äº†ã€‚ç±»ä¼¼çš„ï¼Œæˆ‘ä»¬ä¹Ÿæƒ³è®©å®ƒä»¬ä¸å†…æ ¸æ“ä½œç³»ç»Ÿç›¸äº’ç‹¬ç«‹ï¼Œè¿™æ ·å¦‚æœæŸä¸ªåº”ç”¨ç¨‹åºæ— æ„æˆ–è€…æ•…æ„åšäº†ä¸€äº›åäº‹ï¼Œä¹Ÿä¸ä¼šå½±å“åˆ°æ“ä½œç³»ç»Ÿã€‚ å¦‚æœæˆ‘ä»¬ä¸åšä»»ä½•å·¥ä½œï¼Œé»˜è®¤æƒ…å†µä¸‹æˆ‘ä»¬æ˜¯æ²¡æœ‰å†…å­˜éš”ç¦»æ€§çš„ã€‚ RISC-Vä¸»æ¿ä¸Šï¼Œå†…å­˜æ˜¯ç”±ä¸€äº›DRAMèŠ¯ç‰‡ç»„æˆã€‚åœ¨è¿™äº›DRAMèŠ¯ç‰‡ä¸­ä¿å­˜äº†ç¨‹åºçš„æ•°æ®å’Œä»£ç ã€‚ä¾‹å¦‚å†…å­˜ä¸­çš„æŸä¸€ä¸ªéƒ¨åˆ†æ˜¯å†…æ ¸ï¼ŒåŒ…æ‹¬äº†æ–‡æœ¬ï¼Œæ•°æ®ï¼Œæ ˆç­‰ç­‰ï¼›å¦‚æœè¿è¡Œäº†Shellï¼Œå†…å­˜ä¸­çš„æŸä¸ªéƒ¨åˆ†å°±æ˜¯Shellï¼›å¦‚æœè¿è¡Œäº†catç¨‹åºï¼Œå†…å­˜ä¸­çš„æŸä¸ªéƒ¨åˆ†æ˜¯catç¨‹åºã€‚è¿™é‡Œè¯´çš„éƒ½æ˜¯ç‰©ç†å†…å­˜ï¼Œå®ƒçš„åœ°å€ä»0å¼€å§‹åˆ°æŸä¸ªå¤§çš„åœ°å€ç»“æŸã€‚ç»“æŸåœ°å€å–å†³äºæˆ‘ä»¬çš„æœºå™¨ç°åœ¨ç©¶ç«Ÿæœ‰å¤šå°‘ç‰©ç†å†…å­˜ã€‚æ‰€æœ‰ç¨‹åºéƒ½å¿…é¡»å­˜åœ¨äºç‰©ç†å†…å­˜ä¸­ï¼Œå¦åˆ™å¤„ç†å™¨ç”šè‡³éƒ½ä¸èƒ½å¤„ç†ç¨‹åºçš„æŒ‡ä»¤ã€‚ è¿™é‡Œçš„é£é™©å¾ˆæ˜æ˜¾ã€‚æˆ‘ä»¬ç®€å•åŒ–ä¸€ä¸‹åœºæ™¯ï¼Œå‡è®¾Shellå­˜åœ¨äºå†…å­˜åœ°å€1000-2000ä¹‹é—´ã€‚ å¦‚æœcatå‡ºç°äº†ç¨‹åºé”™è¯¯ï¼Œå°†å†…å­˜åœ°å€1000ï¼Œä¹Ÿå°±æ˜¯Shellçš„èµ·å§‹åœ°å€åŠ è½½åˆ°å¯„å­˜å™¨a0ä¸­ã€‚ä¹‹åæ‰§è¡Œsd $7, (a0)ï¼Œè¿™é‡Œç­‰æ•ˆäºå°†7å†™å…¥å†…å­˜åœ°å€1000ã€‚ ç°åœ¨catç¨‹åºå¼„ä¹±äº†Shellç¨‹åºçš„å†…å­˜é•œåƒï¼Œæ‰€ä»¥éš”ç¦»æ€§è¢«ç ´åäº†ï¼Œè¿™æ˜¯æˆ‘ä»¬ä¸æƒ³çœ‹åˆ°çš„ç°è±¡ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬æƒ³è¦æŸç§æœºåˆ¶ï¼Œèƒ½å¤Ÿå°†ä¸åŒç¨‹åºä¹‹é—´çš„å†…å­˜éš”ç¦»å¼€æ¥ï¼Œè¿™æ ·ç±»ä¼¼çš„äº‹æƒ…å°±ä¸ä¼šå‘ç”Ÿã€‚ä¸€ç§å®ç°æ–¹å¼æ˜¯åœ°å€ç©ºé—´ï¼ˆAddress Spacesï¼‰ã€‚ åŸºæœ¬æ¦‚å¿µè¿™é‡Œçš„åŸºæœ¬æ¦‚å¿µä¹Ÿå¾ˆç®€å•ç›´è§‚ï¼Œæˆ‘ä»¬ç»™åŒ…æ‹¬å†…æ ¸åœ¨å†…çš„æ‰€æœ‰ç¨‹åºä¸“å±çš„åœ°å€ç©ºé—´ã€‚æ‰€ä»¥ï¼Œå½“æˆ‘ä»¬è¿è¡Œcatæ—¶ï¼Œå®ƒçš„åœ°å€ç©ºé—´ä»0åˆ°æŸä¸ªåœ°å€ç»“æŸã€‚å½“æˆ‘ä»¬è¿è¡ŒShellæ—¶ï¼Œå®ƒçš„åœ°å€ä¹Ÿä»0å¼€å§‹åˆ°æŸä¸ªåœ°å€ç»“æŸã€‚å†…æ ¸çš„åœ°å€ç©ºé—´ä¹Ÿä»0å¼€å§‹åˆ°æŸä¸ªåœ°å€ç»“æŸã€‚ å¦‚æœcatç¨‹åºæƒ³è¦å‘åœ°å€1000å†™å…¥æ•°æ®ï¼Œé‚£ä¹ˆcatåªä¼šå‘å®ƒè‡ªå·±çš„åœ°å€1000ï¼Œè€Œä¸æ˜¯Shellçš„åœ°å€1000å†™å…¥æ•°æ®ã€‚æ‰€ä»¥ï¼ŒåŸºæœ¬ä¸Šæ¥è¯´ï¼Œæ¯ä¸ªç¨‹åºéƒ½è¿è¡Œåœ¨è‡ªå·±çš„åœ°å€ç©ºé—´ï¼Œå¹¶ä¸”è¿™äº›åœ°å€ç©ºé—´å½¼æ­¤ä¹‹é—´ç›¸äº’ç‹¬ç«‹ã€‚åœ¨è¿™ç§ä¸åŒåœ°å€ç©ºé—´çš„æ¦‚å¿µä¸­ï¼Œcatç¨‹åºç”šè‡³éƒ½ä¸å…·å¤‡å¼•ç”¨å±äºShellçš„å†…å­˜åœ°å€çš„èƒ½åŠ›ã€‚è¿™æ˜¯æˆ‘ä»¬æƒ³è¦è¾¾æˆçš„ç»ˆæç›®æ ‡ï¼Œå› ä¸ºè¿™ç§æ–¹å¼ä¸ºæˆ‘ä»¬æä¾›äº†å¼ºéš”ç¦»æ€§ï¼Œcatç°åœ¨ä¸èƒ½å¼•ç”¨ä»»ä½•ä¸å±äºè‡ªå·±çš„å†…å­˜ã€‚ æ‰€ä»¥ç°åœ¨æˆ‘ä»¬çš„é—®é¢˜æ˜¯å¦‚ä½•åœ¨ä¸€ä¸ªç‰©ç†å†…å­˜ä¸Šï¼Œåˆ›å»ºä¸åŒçš„åœ°å€ç©ºé—´ï¼Œå› ä¸ºå½’æ ¹åˆ°åº•ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„è¿˜æ˜¯ä¸€å †å­˜æ”¾äº†å†…å­˜ä¿¡æ¯çš„DRAMèŠ¯ç‰‡ã€‚ è™šæ‹Ÿå†…å­˜å¯ä»¥æ¯”ç‰©ç†å†…å­˜æ›´å¤§ï¼Œç‰©ç†å†…å­˜ä¹Ÿå¯ä»¥æ¯”è™šæ‹Ÿå†…å­˜æ›´å¤§ å¦‚æœå¤ªå¤šçš„è¿›ç¨‹ä½¿ç”¨äº†è™šæ‹Ÿå†…å­˜ï¼Œæœ‰å¯èƒ½ä½¿ç‰©ç†å†…å­˜è€—å°½ kallocä¿å­˜äº†ç©ºä½™çš„pageçš„åˆ—è¡¨ï¼Œå¦‚æœè¿™ä¸ªåˆ—è¡¨ä¸ºç©ºæˆ–è€…è€—å°½äº†ï¼Œé‚£ä¹ˆkallocä¼šè¿”å›ä¸€ä¸ªç©ºæŒ‡é’ˆï¼Œå†…æ ¸ä¼šå¦¥å–„å¤„ç†å¹¶å°†ç»“æœè¿”å›ç»™ç”¨æˆ·åº”ç”¨ç¨‹åºã€‚å¹¶å‘Šè¯‰ç”¨æˆ·åº”ç”¨ç¨‹åºï¼Œè¦ä¹ˆæ˜¯å¯¹è¿™ä¸ªåº”ç”¨ç¨‹åºæ²¡æœ‰é¢å¤–çš„å†…å­˜äº†ï¼Œè¦ä¹ˆæ•´ä¸ªæœºå™¨éƒ½æ²¡æœ‰å†…å­˜äº†ã€‚ Pageé¡µè¡¨æµç¨‹é¡µè¡¨æ˜¯åœ¨ç¡¬ä»¶ä¸­é€šè¿‡å¤„ç†å™¨å’Œå†…å­˜ç®¡ç†å•å…ƒï¼ˆMemory Management Unitï¼‰å®ç°ã€‚ CPUæ­£åœ¨æ‰§è¡ŒæŒ‡ä»¤ï¼Œä¾‹å¦‚sd $7, (a0)ã€‚ å¯¹äºä»»ä½•ä¸€æ¡å¸¦æœ‰åœ°å€çš„æŒ‡ä»¤ï¼Œå…¶ä¸­çš„åœ°å€åº”è¯¥è®¤ä¸ºæ˜¯è™šæ‹Ÿå†…å­˜åœ°å€è€Œä¸æ˜¯ç‰©ç†åœ°å€ã€‚å‡è®¾å¯„å­˜å™¨a0ä¸­æ˜¯åœ°å€0x1000ï¼Œé‚£ä¹ˆè¿™æ˜¯ä¸€ä¸ªè™šæ‹Ÿå†…å­˜åœ°å€ã€‚è™šæ‹Ÿå†…å­˜åœ°å€ä¼šè¢«è½¬åˆ°å†…å­˜ç®¡ç†å•å…ƒï¼ˆMMUï¼ŒMemory Management Unitï¼‰ å†…å­˜ç®¡ç†å•å…ƒä¼šå°†è™šæ‹Ÿåœ°å€ç¿»è¯‘æˆç‰©ç†åœ°å€ã€‚ä¹‹åè¿™ä¸ªç‰©ç†åœ°å€ä¼šè¢«ç”¨æ¥ç´¢å¼•ç‰©ç†å†…å­˜ï¼Œå¹¶ä»ç‰©ç†å†…å­˜åŠ è½½ï¼Œæˆ–è€…å‘ç‰©ç†å†…å­˜å­˜å‚¨æ•°æ®ã€‚ ä»CPUçš„è§’åº¦æ¥è¯´ï¼Œä¸€æ—¦MMUæ‰“å¼€äº†ï¼Œå®ƒæ‰§è¡Œçš„æ¯æ¡æŒ‡ä»¤ä¸­çš„åœ°å€éƒ½æ˜¯è™šæ‹Ÿå†…å­˜åœ°å€ã€‚ ä¸ºäº†èƒ½å¤Ÿå®Œæˆè™šæ‹Ÿå†…å­˜åœ°å€åˆ°ç‰©ç†å†…å­˜åœ°å€çš„ç¿»è¯‘ï¼ŒMMUä¼šæœ‰ä¸€ä¸ªè¡¨å•ï¼Œè¡¨å•ä¸­ï¼Œä¸€è¾¹æ˜¯è™šæ‹Ÿå†…å­˜åœ°å€ï¼Œå¦ä¸€è¾¹æ˜¯ç‰©ç†å†…å­˜åœ°å€ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œè™šæ‹Ÿå†…å­˜åœ°å€0x1000å¯¹åº”äº†ä¸€ä¸ªæˆ‘éšå£è¯´çš„ç‰©ç†å†…å­˜åœ°å€0xFFF0ã€‚è¿™æ ·çš„è¡¨å•å¯ä»¥éå¸¸çµæ´»ã€‚ é€šå¸¸æ¥è¯´ï¼Œå†…å­˜åœ°å€å¯¹åº”å…³ç³»çš„è¡¨å•ä¹Ÿä¿å­˜åœ¨å†…å­˜ä¸­ã€‚æ‰€ä»¥CPUä¸­éœ€è¦æœ‰ä¸€äº›å¯„å­˜å™¨ç”¨æ¥å­˜æ”¾è¡¨å•åœ¨ç‰©ç†å†…å­˜ä¸­çš„åœ°å€ã€‚ç°åœ¨ï¼Œåœ¨å†…å­˜çš„æŸä¸ªä½ç½®ä¿å­˜äº†åœ°å€å…³ç³»è¡¨å•ï¼Œæˆ‘ä»¬å‡è®¾è¿™ä¸ªä½ç½®çš„ç‰©ç†å†…å­˜åœ°å€æ˜¯0x10ã€‚é‚£ä¹ˆåœ¨RISC-Vä¸Šä¸€ä¸ªå«åšSATPçš„å¯„å­˜å™¨ä¼šä¿å­˜åœ°å€0x10ã€‚ è¿™æ ·ï¼ŒCPUå°±å¯ä»¥å‘Šè¯‰MMUï¼Œå¯ä»¥ä»å“ªæ‰¾åˆ°å°†è™šæ‹Ÿå†…å­˜åœ°å€ç¿»è¯‘æˆç‰©ç†å†…å­˜åœ°å€çš„è¡¨å•ã€‚ page tableå­˜å‚¨åœ¨å†…å­˜ä¸­ï¼ŒMMUåªæ˜¯ä¼šå»æŸ¥çœ‹page tableã€‚ æ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„è¡¨å•ï¼Œå¹¶ä¸”è¿™ä¸ªè¡¨å•å®šä¹‰äº†åº”ç”¨ç¨‹åºçš„åœ°å€ç©ºé—´ã€‚æ‰€ä»¥å½“æ“ä½œç³»ç»Ÿå°†CPUä»ä¸€ä¸ªåº”ç”¨ç¨‹åºåˆ‡æ¢åˆ°å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºæ—¶ï¼ŒåŒæ—¶ä¹Ÿéœ€è¦åˆ‡æ¢SATPå¯„å­˜å™¨ä¸­çš„å†…å®¹ï¼Œä»è€ŒæŒ‡å‘æ–°çš„è¿›ç¨‹ä¿å­˜åœ¨ç‰©ç†å†…å­˜ä¸­çš„åœ°å€å¯¹åº”è¡¨å•ã€‚è¿™æ ·çš„è¯ï¼Œcatç¨‹åºå’ŒShellç¨‹åºä¸­ç›¸åŒçš„è™šæ‹Ÿå†…å­˜åœ°å€ï¼Œå°±å¯ä»¥ç¿»è¯‘åˆ°ä¸åŒçš„ç‰©ç†å†…å­˜åœ°å€ï¼Œå› ä¸ºæ¯ä¸ªåº”ç”¨ç¨‹åºéƒ½æœ‰å±äºè‡ªå·±çš„ä¸åŒçš„åœ°å€å¯¹åº”è¡¨å•ã€‚ å†…æ ¸ä¼šå†™SATPå¯„å­˜å™¨ï¼Œå†™SATPå¯„å­˜å™¨æ˜¯ä¸€æ¡ç‰¹æ®Šæƒé™æŒ‡ä»¤ã€‚æ‰€ä»¥ï¼Œç”¨æˆ·åº”ç”¨ç¨‹åºä¸èƒ½é€šè¿‡æ›´æ–°è¿™ä¸ªå¯„å­˜å™¨æ¥æ›´æ¢ä¸€ä¸ªåœ°å€å¯¹åº”è¡¨å•ï¼Œå¦åˆ™çš„è¯å°±ä¼šç ´åéš”ç¦»æ€§ã€‚æ‰€ä»¥ï¼Œåªæœ‰è¿è¡Œåœ¨kernel modeçš„ä»£ç å¯ä»¥æ›´æ–°è¿™ä¸ªå¯„å­˜å™¨ã€‚ è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€ è™šæ‹Ÿå†…å­˜åœ°å€åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ† indexï¼šç”¨æ¥æŸ¥æ‰¾page offsetï¼šå¯¹åº”ä¸€ä¸ªpageä¸­çš„å­—èŠ‚ å½“MMUåœ¨åšåœ°å€ç¿»è¯‘çš„æ—¶å€™ï¼Œé€šè¿‡è¯»å–è™šæ‹Ÿå†…å­˜åœ°å€ä¸­çš„indexå¯ä»¥çŸ¥é“ç‰©ç†å†…å­˜ä¸­çš„pageå·ï¼Œè¿™ä¸ªpageå·å¯¹åº”äº†ç‰©ç†å†…å­˜ä¸­çš„4096ä¸ªå­—èŠ‚ã€‚ä¹‹åè™šæ‹Ÿå†…å­˜åœ°å€ä¸­çš„offsetæŒ‡å‘äº†pageä¸­çš„4096ä¸ªå­—èŠ‚ä¸­çš„æŸä¸€ä¸ªï¼Œå‡è®¾offsetæ˜¯12ï¼Œé‚£ä¹ˆpageä¸­çš„ç¬¬12ä¸ªå­—èŠ‚è¢«ä½¿ç”¨äº†ã€‚å°†offsetåŠ ä¸Špageçš„èµ·å§‹åœ°å€ï¼Œå°±å¯ä»¥å¾—åˆ°ç‰©ç†å†…å­˜åœ°å€ã€‚ RSIC-Vå¤„ç†å™¨RISC-Vçš„å¯„å­˜å™¨æ˜¯64bitï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰çš„64bitéƒ½è¢«ä½¿ç”¨äº†ï¼Œé«˜25bitæœªè¢«ä½¿ç”¨ã€‚ è¿™æ ·çš„ç»“æœæ˜¯é™åˆ¶äº†è™šæ‹Ÿå†…å­˜åœ°å€çš„æ•°é‡ï¼Œè™šæ‹Ÿå†…å­˜åœ°å€çš„æ•°é‡ç°åœ¨åªæœ‰2^39ä¸ªï¼Œå¤§æ¦‚æ˜¯512GBã€‚ å½“ç„¶å¦‚æœæœ‰å¿…è¦çš„è¯ï¼Œæœ€æ–°çš„å¤„ç†å™¨æˆ–è®¸å¯ä»¥æ”¯æŒæ›´å¤§çš„åœ°å€ç©ºé—´ï¼Œåªéœ€è¦å°†æœªä½¿ç”¨çš„25bitæ‹¿å‡ºæ¥ä½œä¸ºè™šæ‹Ÿå†…å­˜åœ°å€çš„ä¸€éƒ¨åˆ†å³å¯ã€‚ åœ¨å‰©ä¸‹çš„39bitä¸­ï¼Œæœ‰27bitè¢«ç”¨æ¥å½“ä½œindexï¼Œ12bitè¢«ç”¨æ¥å½“ä½œoffsetã€‚offsetå¿…é¡»æ˜¯12bitï¼Œå› ä¸ºå¯¹åº”äº†ä¸€ä¸ªpageçš„4096ä¸ªå­—èŠ‚ã€‚ åœ¨RISC-Vä¸­ï¼Œç‰©ç†å†…å­˜åœ°å€æ˜¯56bitã€‚æ‰€ä»¥ç‰©ç†å†…å­˜åœ°å€å¯ä»¥å¤§äºå•ä¸ªå†…å­˜åœ°å€ç©ºé—´ï¼Œä½†æ˜¯ä¹Ÿæœ€å¤šåˆ°2^56ã€‚å¤§å¤šæ•°ä¸»æ¿è¿˜ä¸æ”¯æŒ2^56è¿™ä¹ˆå¤§çš„ç‰©ç†å†…å­˜ï¼Œä½†æ˜¯åŸåˆ™ä¸Šï¼Œå¦‚æœä½ èƒ½é€ å‡ºè¿™æ ·çš„ä¸»æ¿ï¼Œé‚£ä¹ˆæœ€å¤šå¯ä»¥æ”¯æŒ2^56å­—èŠ‚çš„ç‰©ç†å†…å­˜ã€‚ ç‰©ç†å†…å­˜åœ°å€æ˜¯56bitï¼Œå…¶ä¸­44bitæ˜¯ç‰©ç†pageå·ï¼ˆPPN,Physical Page Number)ï¼Œå‰©ä¸‹çš„12bitæ˜¯offsetå®Œå…¨ç»§æ‰¿è‡ªè™šæ‹Ÿå†…å­˜åœ°å€ï¼ˆä¹Ÿå°±æ˜¯åœ°å€è½¬æ¢æ—¶ï¼Œåªéœ€è¦å°†è™šæ‹Ÿå†…å­˜ä¸­çš„27bitç¿»è¯‘æˆç‰©ç†å†…å­˜ä¸­çš„44bitçš„pageå·ï¼Œå‰©ä¸‹çš„12bitoffsetç›´æ¥æ‹·è´è¿‡æ¥å³å¯ã€‚ å¤šçº§page table æˆ‘ä»¬ä¹‹å‰æåˆ°çš„è™šæ‹Ÿå†…å­˜åœ°å€ä¸­çš„27bitçš„indexï¼Œå®é™…ä¸Šæ˜¯ç”±3ä¸ª9bitçš„æ•°å­—ç»„æˆï¼ˆL2ï¼ŒL1ï¼ŒL0ï¼‰ã€‚å‰9ä¸ªbitè¢«ç”¨æ¥ç´¢å¼•æœ€é«˜çº§çš„page directoryï¼ˆæ³¨ï¼šé€šå¸¸page directoryæ˜¯ç”¨æ¥ç´¢å¼•page tableæˆ–è€…å…¶ä»–page directoryç‰©ç†åœ°å€çš„è¡¨å•) ä¸€ä¸ªdirectoryæ˜¯4096Bytesï¼Œå°±è·Ÿpageçš„å¤§å°æ˜¯ä¸€æ ·çš„ã€‚Directoryä¸­çš„ä¸€ä¸ªæ¡ç›®è¢«ç§°ä¸ºPTEï¼ˆPage Table Entryï¼‰æ˜¯64bitsï¼Œå°±åƒå¯„å­˜å™¨çš„å¤§å°ä¸€æ ·ï¼Œä¹Ÿå°±æ˜¯8Bytesã€‚æ‰€ä»¥ä¸€ä¸ªDirectory pageæœ‰512ä¸ªæ¡ç›®ã€‚ æ‰€ä»¥å®é™…ä¸Šï¼ŒSATPå¯„å­˜å™¨ä¼šæŒ‡å‘æœ€é«˜ä¸€çº§çš„page directoryçš„ç‰©ç†å†…å­˜åœ°å€ï¼Œä¹‹åæˆ‘ä»¬ç”¨è™šæ‹Ÿå†…å­˜ä¸­indexçš„é«˜9bitç”¨æ¥ç´¢å¼•æœ€é«˜ä¸€çº§çš„page directoryï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½å¾—åˆ°ä¸€ä¸ªPPNï¼Œä¹Ÿå°±æ˜¯ç‰©ç†pageå·ã€‚è¿™ä¸ªPPNæŒ‡å‘äº†ä¸­é—´çº§çš„page directoryã€‚ å½“æˆ‘ä»¬åœ¨ä½¿ç”¨ä¸­é—´çº§çš„page directoryæ—¶ï¼Œæˆ‘ä»¬é€šè¿‡è™šæ‹Ÿå†…å­˜åœ°å€ä¸­çš„L1éƒ¨åˆ†å®Œæˆç´¢å¼•ã€‚æ¥ä¸‹æ¥ä¼šèµ°åˆ°æœ€ä½çº§çš„page directoryï¼Œæˆ‘ä»¬é€šè¿‡è™šæ‹Ÿå†…å­˜åœ°å€ä¸­çš„L0éƒ¨åˆ†å®Œæˆç´¢å¼•ã€‚åœ¨æœ€ä½çº§çš„page directoryä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°å¯¹åº”äºè™šæ‹Ÿå†…å­˜åœ°å€çš„ç‰©ç†å†…å­˜åœ°å€ã€‚ ä¼˜ç‚¹å¦‚æœåœ°å€ç©ºé—´ä¸­å¤§éƒ¨åˆ†åœ°å€éƒ½æ²¡æœ‰ä½¿ç”¨ï¼Œä½ ä¸å¿…ä¸ºæ¯ä¸€ä¸ªindexå‡†å¤‡ä¸€ä¸ªæ¡ç›®ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœä½ çš„åœ°å€ç©ºé—´åªä½¿ç”¨äº†ä¸€ä¸ªpageï¼Œ4096Bytesã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä½ æ²¡æœ‰ä½¿ç”¨ä»»ä½•å…¶ä»–çš„åœ°å€ã€‚ç°åœ¨ï¼Œä½ éœ€è¦å¤šå°‘ä¸ªpage table entryï¼Œæˆ–è€…page table directoryæ¥æ˜ å°„è¿™ä¸€ä¸ªpageï¼Ÿ åœ¨æœ€é«˜çº§ï¼Œä½ éœ€è¦ä¸€ä¸ªpage directoryã€‚åœ¨è¿™ä¸ªpage directoryä¸­ï¼Œä½ éœ€è¦ä¸€ä¸ªæ•°å­—æ˜¯0çš„PTEï¼ŒæŒ‡å‘ä¸­é—´çº§page directoryã€‚æ‰€ä»¥åœ¨ä¸­é—´çº§ï¼Œä½ ä¹Ÿéœ€è¦ä¸€ä¸ªpage directoryï¼Œé‡Œé¢ä¹Ÿæ˜¯ä¸€ä¸ªæ•°å­—0çš„PTEï¼ŒæŒ‡å‘æœ€ä½çº§page directoryã€‚æ‰€ä»¥è¿™é‡Œæ€»å…±éœ€è¦3ä¸ªpage directoryï¼ˆä¹Ÿå°±æ˜¯3 * 512ä¸ªæ¡ç›®ï¼‰ã€‚ è€Œåœ¨å•çº§page tableä¸­ï¼Œè™½ç„¶æˆ‘ä»¬åªä½¿ç”¨äº†ä¸€ä¸ªpageï¼Œè¿˜æ˜¯éœ€è¦2^27ä¸ªPTEã€‚è¿™ä¸ªæ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦3 * 512ä¸ªPTEã€‚æ‰€éœ€çš„ç©ºé—´å¤§å¤§å‡å°‘äº†ã€‚è¿™æ˜¯å®é™…ä¸Šç¡¬ä»¶é‡‡ç”¨è¿™ç§å±‚æ¬¡åŒ–çš„3çº§page directoryç»“æ„çš„ä¸»è¦åŸå› ã€‚ PTE ç‰©ç†é¡µå·ï¼ˆPhysical Page Numberï¼ŒPPNï¼‰: ä¸ç‰©ç†åœ°å€å­—æ®µç±»ä¼¼ï¼ŒPPNå­˜å‚¨ä¸è™šæ‹Ÿåœ°å€å…³è”çš„ç‰©ç†å†…å­˜åœ°å€ã€‚åœ¨RISC-Vä¸­ï¼ŒPTEçš„é«˜ä½éƒ¨åˆ†å­˜å‚¨PPNã€‚ æœ‰æ•ˆä½ï¼ˆValidï¼ŒVï¼‰: æœ‰æ•ˆä½è¡¨ç¤ºæ­¤PTEä¸­å­˜å‚¨çš„æ˜ å°„æ˜¯å¦æœ‰æ•ˆã€‚å¦‚æœæœ‰æ•ˆä½è®¾ç½®ä¸º1ï¼Œè¡¨ç¤ºæ­¤PTEçš„è™šæ‹Ÿåœ°å€å·²æ˜ å°„åˆ°ç‰©ç†å†…å­˜ä¸­ã€‚å¦‚æœè®¾ç½®ä¸º0ï¼Œåˆ™è¡¨ç¤ºè¯¥è™šæ‹Ÿåœ°å€å°šæœªæ˜ å°„ã€‚ è¯»ï¼ˆReadï¼ŒRï¼‰: è¯»æƒé™ä½è¡¨ç¤ºå…è®¸å¯¹è¯¥é¡µé¢è¿›è¡Œè¯»è®¿é—®ã€‚ å†™ï¼ˆWriteï¼ŒWï¼‰: å†™æƒé™ä½è¡¨ç¤ºå…è®¸å¯¹è¯¥é¡µé¢è¿›è¡Œå†™è®¿é—®ã€‚ æ‰§è¡Œï¼ˆExecuteï¼ŒXï¼‰: æ‰§è¡Œæƒé™ä½è¡¨ç¤ºå…è®¸å¯¹è¯¥é¡µé¢è¿›è¡Œæ‰§è¡Œè®¿é—®ã€‚ ç”¨æˆ·ï¼ˆUserï¼ŒUï¼‰: ç”¨æˆ·æƒé™ä½è¡¨ç¤ºè¯¥é¡µé¢æ˜¯å¦å…è®¸åœ¨ç”¨æˆ·æ¨¡å¼ä¸‹è®¿é—®ã€‚å¦‚æœè®¾ç½®ä¸º1ï¼Œåˆ™å…è®¸ç”¨æˆ·æ¨¡å¼è®¿é—®ï¼›å¦‚æœè®¾ç½®ä¸º0ï¼Œåˆ™ä»…å…è®¸ç‰¹æƒæ¨¡å¼è®¿é—®ã€‚ å…¨å±€ï¼ˆGlobalï¼ŒGï¼‰: å…¨å±€ä½è¡¨ç¤ºè¯¥é¡µé¢æ˜¯å¦å¯¹æ‰€æœ‰åœ°å€ç©ºé—´å¯è§ã€‚å¦‚æœè®¾ç½®ä¸º1ï¼Œåˆ™è¡¨ç¤ºè¯¥é¡µé¢åœ¨åœ°å€ç©ºé—´åˆ‡æ¢æ—¶ä¸ä¼šä»è½¬æ¢æŸ¥æ‰¾ç¼“å†²å™¨ï¼ˆTranslation Lookaside Bufferï¼ŒTLBï¼‰ä¸­æ¸…é™¤ã€‚è¿™å¯¹äºæ“ä½œç³»ç»Ÿå†…æ ¸å’Œå…±äº«åº“ç­‰å…¨å±€æ•°æ®ç»“æ„ç‰¹åˆ«æœ‰ç”¨ã€‚ è®¿é—®ï¼ˆAccessedï¼ŒAï¼‰: è®¿é—®ä½è¡¨ç¤ºè‡ªä¸Šæ¬¡æ¸…é›¶ä»¥æ¥è¯¥é¡µé¢æ˜¯å¦è¢«è®¿é—®è¿‡ã€‚å½“å‘ç”Ÿå†…å­˜è®¿é—®æ—¶ï¼Œç¡¬ä»¶ä¼šè‡ªåŠ¨è®¾ç½®è®¿é—®ä½ã€‚ è„ï¼ˆDirtyï¼ŒDï¼‰: è„ä½è¡¨ç¤ºè‡ªä¸Šæ¬¡æ¸…é›¶ä»¥æ¥è¯¥é¡µé¢æ˜¯å¦è¢«ä¿®æ”¹è¿‡ã€‚å½“æŸä¸ªé¡µé¢çš„å†…å®¹è¢«ä¿®æ”¹æ—¶ï¼Œç¡¬ä»¶ä¼šè‡ªåŠ¨è®¾ç½®è„ä½ã€‚ è½¯ä»¶å¯ç”¨ä½ï¼ˆSoftware Useï¼ŒSWï¼‰: è¿™äº›ä½æ˜¯ä¸ºæ“ä½œç³»ç»Ÿè½¯ä»¶ä¿ç•™çš„ï¼Œå¯ä»¥åœ¨é¡µè¡¨éå†è¿‡ç¨‹ä¸­ç”¨äºè‡ªå®šä¹‰ç”¨é€”ã€‚ é¡µè¡¨ç¼“å­˜ï¼ˆTranslation Lookaside Bufferï¼‰è§‚å¯Ÿpage tableçš„ç»“æ„ï¼Œå¯ä»¥å‘ç°ï¼Œå½“å¤„ç†å™¨ä»å†…å­˜åŠ è½½æˆ–è€…å­˜å‚¨æ•°æ®æ—¶ï¼ŒåŸºæœ¬ä¸Šéƒ½è¦åš3æ¬¡å†…å­˜æŸ¥æ‰¾ï¼Œç¬¬ä¸€æ¬¡åœ¨æœ€é«˜çº§çš„page directoryï¼Œç¬¬äºŒæ¬¡åœ¨ä¸­é—´çº§çš„page directoryï¼Œæœ€åä¸€æ¬¡åœ¨æœ€ä½çº§çš„page directoryã€‚æ‰€ä»¥å¯¹äºä¸€ä¸ªè™šæ‹Ÿå†…å­˜åœ°å€çš„å¯»å€ï¼Œéœ€è¦è¯»ä¸‰æ¬¡å†…å­˜ï¼Œè¿™é‡Œä»£ä»·æœ‰ç‚¹é«˜ã€‚æ‰€ä»¥å®é™…ä¸­ï¼Œå‡ ä¹æ‰€æœ‰çš„å¤„ç†å™¨éƒ½ä¼šå¯¹äºæœ€è¿‘ä½¿ç”¨è¿‡çš„è™šæ‹Ÿåœ°å€çš„ç¿»è¯‘ç»“æœæœ‰ç¼“å­˜ã€‚è¿™ä¸ªç¼“å­˜è¢«ç§°ä¸ºï¼šTranslation Lookside Bufferï¼ˆé€šå¸¸ç¿»è¯‘æˆé¡µè¡¨ç¼“å­˜ï¼‰ã€‚ä½ ä¼šç»å¸¸çœ‹åˆ°å®ƒçš„ç¼©å†™TLBã€‚åŸºæœ¬ä¸Šæ¥è¯´ï¼Œè¿™å°±æ˜¯Page Table Entryçš„ç¼“å­˜ï¼Œä¹Ÿå°±æ˜¯PTEçš„ç¼“å­˜ã€‚ å½“å¤„ç†å™¨ç¬¬ä¸€æ¬¡æŸ¥æ‰¾ä¸€ä¸ªè™šæ‹Ÿåœ°å€æ—¶ï¼Œç¡¬ä»¶é€šè¿‡3çº§page tableå¾—åˆ°æœ€ç»ˆçš„PPNï¼ŒTLBä¼šä¿å­˜è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„æ˜ å°„å…³ç³»ã€‚è¿™æ ·ä¸‹ä¸€æ¬¡å½“ä½ è®¿é—®åŒä¸€ä¸ªè™šæ‹Ÿåœ°å€æ—¶ï¼Œå¤„ç†å™¨å¯ä»¥æŸ¥çœ‹TLBï¼ŒTLBä¼šç›´æ¥è¿”å›ç‰©ç†åœ°å€ï¼Œè€Œä¸éœ€è¦é€šè¿‡page tableå¾—åˆ°ç»“æœã€‚ TLBå®ç°çš„å…·ä½“ç»†èŠ‚ä¸æ˜¯æˆ‘ä»¬è¦æ·±å…¥è®¨è®ºçš„å†…å®¹ã€‚è¿™æ˜¯å¤„ç†å™¨ä¸­çš„ä¸€äº›é€»è¾‘ï¼Œå¯¹äºæ“ä½œç³»ç»Ÿæ¥è¯´æ˜¯ä¸å¯è§çš„ï¼Œæ“ä½œç³»ç»Ÿä¹Ÿä¸éœ€è¦çŸ¥é“TLBæ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ä½ ä»¬éœ€è¦çŸ¥é“TLBå­˜åœ¨çš„å”¯ä¸€åŸå› æ˜¯ï¼Œå¦‚æœä½ åˆ‡æ¢äº†page tableï¼Œæ“ä½œç³»ç»Ÿéœ€è¦å‘Šè¯‰å¤„ç†å™¨å½“å‰æ­£åœ¨åˆ‡æ¢page tableï¼Œå¤„ç†å™¨ä¼šæ¸…ç©ºTLBã€‚å› ä¸ºæœ¬è´¨ä¸Šæ¥è¯´ï¼Œå¦‚æœä½ åˆ‡æ¢äº†page tableï¼ŒTLBä¸­çš„ç¼“å­˜å°†ä¸å†æœ‰ç”¨ï¼Œå®ƒä»¬éœ€è¦è¢«æ¸…ç©ºï¼Œå¦åˆ™åœ°å€ç¿»è¯‘å¯èƒ½ä¼šå‡ºé”™ã€‚æ‰€ä»¥æ“ä½œç³»ç»ŸçŸ¥é“TLBæ˜¯å­˜åœ¨çš„ï¼Œä½†åªä¼šæ—¶ä¸æ—¶çš„å‘Šè¯‰æ“ä½œç³»ç»Ÿï¼Œç°åœ¨çš„TLBä¸èƒ½ç”¨äº†ï¼Œå› ä¸ºè¦åˆ‡æ¢page tableäº†ã€‚åœ¨RISC-Vä¸­ï¼Œæ¸…ç©ºTLBçš„æŒ‡ä»¤æ˜¯sfence_vmaã€‚ æ•´ä¸ªCPUå’ŒMMUéƒ½åœ¨å¤„ç†å™¨èŠ¯ç‰‡ä¸­ï¼Œæ‰€ä»¥åœ¨ä¸€ä¸ªRISC-VèŠ¯ç‰‡ä¸­ï¼Œæœ‰å¤šä¸ªCPUæ ¸ï¼ŒMMUå’ŒTLBå­˜åœ¨äºæ¯ä¸€ä¸ªCPUæ ¸é‡Œé¢ã€‚RISC-Vå¤„ç†å™¨æœ‰L1 cacheï¼ŒL2 Cacheï¼Œæœ‰äº›cacheæ˜¯æ ¹æ®ç‰©ç†åœ°å€ç´¢å¼•çš„ï¼Œæœ‰äº›cacheæ˜¯æ ¹æ®è™šæ‹Ÿåœ°å€ç´¢å¼•çš„ï¼Œç”±è™šæ‹Ÿåœ°å€ç´¢å¼•çš„cacheä½äºMMUä¹‹å‰ï¼Œç”±ç‰©ç†åœ°å€ç´¢å¼•çš„cacheä½äºMMUä¹‹åã€‚ Kernel Page Table åœ¨XV6ä¸­ï¼Œpage tableæ˜¯å¦‚ä½•å·¥ä½œçš„? å½“æ“ä½œç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œä¼šä»åœ°å€0x80000000å¼€å§‹è¿è¡Œï¼Œè¿™ä¸ªåœ°å€å…¶å®ä¹Ÿæ˜¯ç”±ç¡¬ä»¶è®¾è®¡è€…å†³å®šçš„ã€‚ ä¸»æ¿çš„è®¾è®¡äººå‘˜å†³å®šäº†ï¼Œåœ¨å®Œæˆäº†è™šæ‹Ÿåˆ°ç‰©ç†åœ°å€çš„ç¿»è¯‘ä¹‹åï¼Œå¦‚æœå¾—åˆ°çš„ç‰©ç†åœ°å€å¤§äº0x80000000ä¼šèµ°å‘DRAMèŠ¯ç‰‡ï¼Œå¦‚æœå¾—åˆ°çš„ç‰©ç†åœ°å€ä½äº0x80000000ä¼šèµ°å‘ä¸åŒçš„I&#x2F;Oè®¾å¤‡ã€‚è¿™æ˜¯ç”±è¿™ä¸ªä¸»æ¿çš„è®¾è®¡äººå‘˜å†³å®šçš„ç‰©ç†ç»“æ„ã€‚ é¦–å…ˆï¼Œåœ°å€0æ˜¯ä¿ç•™çš„ï¼Œåœ°å€0x10090000å¯¹åº”ä»¥å¤ªç½‘ï¼Œåœ°å€0x80000000å¯¹åº”DDRå†…å­˜ï¼Œå¤„ç†å™¨å¤–çš„æ˜“å¤±å­˜å‚¨ï¼ˆOff-Chip Volatile Memoryï¼‰ï¼Œä¹Ÿå°±æ˜¯ä¸»æ¿ä¸Šçš„DRAMèŠ¯ç‰‡ã€‚ æ‰€æœ‰çš„äº‹æƒ…éƒ½æ˜¯ç”±ç¡¬ä»¶ï¼Œå³ä¸»æ¿å†³å®šçš„ï¼ŒCPUåªæ˜¯ä¸»æ¿çš„ä¸€å°éƒ¨åˆ†ï¼ŒDRAMèŠ¯ç‰‡ä½äºå¤„ç†å™¨ä¹‹å¤–ã€‚æ˜¯ä¸»æ¿è®¾è®¡è€…å°†å¤„ç†å™¨ï¼ŒDRAMå’Œè®¸å¤šI&#x2F;Oè®¾å¤‡æ±‡æ€»åœ¨ä¸€èµ·ã€‚å¯¹äºä¸€ä¸ªæ“ä½œç³»ç»Ÿæ¥è¯´ï¼ŒCPUåªæ˜¯ä¸€ä¸ªéƒ¨åˆ†ï¼ŒI&#x2F;Oè®¾å¤‡åŒæ ·ä¹Ÿå¾ˆé‡è¦ã€‚æ‰€ä»¥å½“ä½ åœ¨å†™ä¸€ä¸ªæ“ä½œç³»ç»Ÿæ—¶ï¼Œä½ éœ€è¦åŒæ—¶å¤„ç†CPUå’ŒI&#x2F;Oè®¾å¤‡ï¼Œæ¯”å¦‚ä½ éœ€è¦å‘äº’è”ç½‘å‘é€ä¸€ä¸ªæŠ¥æ–‡ï¼Œæ“ä½œç³»ç»Ÿéœ€è¦è°ƒç”¨ç½‘å¡é©±åŠ¨å’Œç½‘å¡æ¥å®é™…å®Œæˆè¿™ä¸ªå·¥ä½œã€‚ åœ°å€0x1000æ˜¯boot ROMçš„ç‰©ç†åœ°å€ï¼Œå½“ä½ å¯¹ä¸»æ¿ä¸Šç”µï¼Œä¸»æ¿åšçš„ç¬¬ä¸€ä»¶äº‹æƒ…å°±æ˜¯è¿è¡Œå­˜å‚¨åœ¨boot ROMä¸­çš„ä»£ç ï¼Œå½“bootå®Œæˆä¹‹åï¼Œä¼šè·³è½¬åˆ°åœ°å€0x80000000ï¼Œæ“ä½œç³»ç»Ÿéœ€è¦ç¡®ä¿é‚£ä¸ªåœ°å€æœ‰ä¸€äº›æ•°æ®èƒ½å¤Ÿæ¥ç€å¯åŠ¨æ“ä½œç³»ç»Ÿã€‚ ç‰©ç†åœ°å€è¿˜æœ‰ä¸€äº›å…¶ä»–çš„I&#x2F;Oè®¾å¤‡ PLICæ˜¯ä¸­æ–­æ§åˆ¶å™¨ï¼ˆPlatform-Level Interrupt Controllerï¼‰ CLINTï¼ˆCore Local Interruptorï¼‰ä¹Ÿæ˜¯ä¸­æ–­çš„ä¸€éƒ¨åˆ†ã€‚æ‰€ä»¥å¤šä¸ªè®¾å¤‡éƒ½èƒ½äº§ç”Ÿä¸­æ–­ï¼Œéœ€è¦ä¸­æ–­æ§åˆ¶å™¨æ¥å°†è¿™äº›ä¸­æ–­è·¯ç”±åˆ°åˆé€‚çš„å¤„ç†å‡½æ•°ã€‚ UART0ï¼ˆUniversal Asynchronous Receiver&#x2F;Transmitterï¼‰è´Ÿè´£ä¸Consoleå’Œæ˜¾ç¤ºå™¨äº¤äº’ã€‚ VIRTIO diskï¼Œä¸ç£ç›˜è¿›è¡Œäº¤äº’ã€‚ é«˜äº0x80000000çš„ç‰©ç†åœ°å€å¯¹åº”DRAMèŠ¯ç‰‡ï¼Œä½†æ˜¯å¯¹äºä¾‹å¦‚ä»¥å¤ªç½‘æ¥å£ï¼Œä¹Ÿæœ‰ä¸€ä¸ªç‰¹å®šçš„ä½äº0x80000000çš„ç‰©ç†åœ°å€ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹è¿™ä¸ªå«åšå†…å­˜æ˜ å°„I&#x2F;Oï¼ˆMemory-mapped I&#x2F;Oï¼‰çš„åœ°å€æ‰§è¡Œè¯»å†™æŒ‡ä»¤ï¼Œæ¥å®Œæˆè®¾å¤‡çš„æ“ä½œã€‚ åœ°å€0x02000000å¯¹åº”CLINTï¼Œå½“ä½ å‘è¿™ä¸ªåœ°å€æ‰§è¡Œè¯»å†™æŒ‡ä»¤ï¼Œä½ æ˜¯å‘å®ç°äº†CLINTçš„èŠ¯ç‰‡æ‰§è¡Œè¯»å†™ã€‚è¿™é‡Œä½ å¯ä»¥è®¤ä¸ºä½ ç›´æ¥åœ¨ä¸è®¾å¤‡äº¤äº’ï¼Œè€Œä¸æ˜¯è¯»å†™ç‰©ç†å†…å­˜ã€‚ ç‰©ç†åœ°å€æ€»å…±æœ‰2^56é‚£ä¹ˆå¤šï¼Œä½†æ˜¯ä½ ä¸ç”¨åœ¨ä¸»æ¿ä¸Šæ¥å…¥é‚£ä¹ˆå¤šçš„å†…å­˜ã€‚æ‰€ä»¥ä¸è®ºä¸»æ¿ä¸Šæœ‰å¤šå°‘DRAMèŠ¯ç‰‡ï¼Œæ€»æ˜¯ä¼šæœ‰ä¸€éƒ¨åˆ†ç‰©ç†åœ°å€æ²¡æœ‰è¢«ç”¨åˆ°ã€‚å®é™…ä¸Šåœ¨XV6ä¸­ï¼Œæˆ‘ä»¬é™åˆ¶äº†å†…å­˜çš„å¤§å°æ˜¯128MBã€‚ åœ¨RISC-Vä¸­æœ‰ä¸€ä¸ªå¤šè·¯è¾“å‡ºé€‰æ‹©å™¨ï¼ˆdemultiplexerï¼‰å¯ä»¥å¸®åŠ©CPUå°†æŒ‡ä»¤é€åˆ°æ­£ç¡®çš„I&#x2F;Oè®¾å¤‡ã€‚ ä¸¤ä»¶é‡è¦çš„äº‹æƒ…ï¼š æœ‰ä¸€äº›pageåœ¨è™šæ‹Ÿå†…å­˜ä¸­çš„åœ°å€å¾ˆé åï¼Œæ¯”å¦‚kernel stackåœ¨è™šæ‹Ÿå†…å­˜ä¸­çš„åœ°å€å°±å¾ˆé åã€‚è¿™æ˜¯å› ä¸ºåœ¨å®ƒä¹‹ä¸‹æœ‰ä¸€ä¸ªæœªè¢«æ˜ å°„çš„Guard pageï¼Œè¿™ä¸ªGuard pageå¯¹åº”çš„PTEçš„Valid æ ‡å¿—ä½æ²¡æœ‰è®¾ç½®ï¼Œè¿™æ ·ï¼Œå¦‚æœkernel stackè€—å°½äº†ï¼Œå®ƒä¼šæº¢å‡ºåˆ°Guard pageï¼Œä½†æ˜¯å› ä¸ºGuard pageçš„PTEä¸­Validæ ‡å¿—ä½æœªè®¾ç½®ï¼Œä¼šå¯¼è‡´ç«‹å³è§¦å‘page faultï¼Œè¿™æ ·çš„ç»“æœå¥½è¿‡å†…å­˜è¶Šç•Œä¹‹åé€ æˆçš„æ•°æ®æ··ä¹±ã€‚ç«‹å³è§¦å‘ä¸€ä¸ªpanicï¼ˆä¹Ÿå°±æ˜¯page faultï¼‰ï¼Œä½ å°±çŸ¥é“kernel stackå‡ºé”™äº†ã€‚åŒæ—¶æˆ‘ä»¬ä¹Ÿåˆä¸æƒ³æµªè´¹ç‰©ç†å†…å­˜ç»™Guard pageï¼Œæ‰€ä»¥Guard pageä¸ä¼šæ˜ å°„åˆ°ä»»ä½•ç‰©ç†å†…å­˜ï¼Œå®ƒåªæ˜¯å æ®äº†è™šæ‹Ÿåœ°å€ç©ºé—´çš„ä¸€æ®µé åçš„åœ°å€ã€‚&#96; åŒæ—¶ï¼Œkernel stackè¢«æ˜ å°„äº†ä¸¤æ¬¡ï¼Œåœ¨é åçš„è™šæ‹Ÿåœ°å€æ˜ å°„äº†ä¸€æ¬¡ï¼Œåœ¨PHYSTOPä¸‹çš„Kernel dataä¸­åˆæ˜ å°„äº†ä¸€æ¬¡ï¼Œä½†æ˜¯å®é™…ä½¿ç”¨çš„æ—¶å€™ç”¨çš„æ˜¯ä¸Šé¢çš„éƒ¨åˆ†ï¼Œå› ä¸ºæœ‰Guard pageä¼šæ›´åŠ å®‰å…¨ã€‚ æƒé™ï¼šä¾‹å¦‚Kernel text pageè¢«æ ‡ä½R-Xï¼Œæ„å‘³ç€ä½ å¯ä»¥è¯»å®ƒï¼Œä¹Ÿå¯ä»¥åœ¨è¿™ä¸ªåœ°å€æ®µæ‰§è¡ŒæŒ‡ä»¤ï¼Œä½†æ˜¯ä½ ä¸èƒ½å‘Kernel textå†™æ•°æ®ã€‚é€šè¿‡è®¾ç½®æƒé™æˆ‘ä»¬å¯ä»¥å°½æ—©çš„å‘ç°Bugä»è€Œé¿å…Bugã€‚å¯¹äºKernel dataéœ€è¦èƒ½è¢«å†™å…¥ï¼Œæ‰€ä»¥å®ƒçš„æ ‡å¿—ä½æ˜¯RW-ï¼Œä½†æ˜¯ä½ ä¸èƒ½åœ¨è¿™ä¸ªåœ°å€æ®µè¿è¡ŒæŒ‡ä»¤ï¼Œæ‰€ä»¥å®ƒçš„Xæ ‡å¿—ä½æœªè¢«è®¾ç½®ã€‚ï¼ˆæ³¨ï¼Œæ‰€ä»¥ï¼Œkernel textç”¨æ¥å­˜ä»£ç ï¼Œä»£ç å¯ä»¥è¯»ï¼Œå¯ä»¥è¿è¡Œï¼Œä½†æ˜¯ä¸èƒ½ç¯¡æ”¹ï¼Œkernel dataç”¨æ¥å­˜æ•°æ®ï¼Œæ•°æ®å¯ä»¥è¯»å†™ï¼Œä½†æ˜¯ä¸èƒ½é€šè¿‡æ•°æ®ä¼ªè£…ä»£ç åœ¨kernelä¸­è¿è¡Œï¼‰ æ¯ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„kernel stackã€‚ åœ¨kernel page tableä¸­ï¼Œæœ‰ä¸€æ®µFree Memoryï¼Œå®ƒå¯¹åº”äº†ç‰©ç†å†…å­˜ä¸­çš„ä¸€æ®µåœ°å€ã€‚XV6ä½¿ç”¨è¿™æ®µfree memoryæ¥å­˜æ”¾ç”¨æˆ·è¿›ç¨‹çš„page tableï¼Œtextå’Œdataã€‚å¦‚æœæˆ‘ä»¬è¿è¡Œäº†éå¸¸å¤šçš„ç”¨æˆ·è¿›ç¨‹ï¼ŒæŸä¸ªæ—¶é—´ç‚¹æˆ‘ä»¬ä¼šè€—å°½è¿™æ®µå†…å­˜ï¼Œè¿™ä¸ªæ—¶å€™forkæˆ–è€…execä¼šè¿”å›é”™è¯¯ã€‚ å½“kernelåˆ›å»ºäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œé’ˆå¯¹è¿™ä¸ªè¿›ç¨‹çš„page tableä¹Ÿä¼šä»Free memoryä¸­åˆ†é…å‡ºæ¥ã€‚å†…æ ¸ä¼šä¸ºç”¨æˆ·è¿›ç¨‹çš„page tableåˆ†é…å‡ ä¸ªpageï¼Œå¹¶å¡«å…¥PTEã€‚åœ¨æŸä¸ªæ—¶é—´ç‚¹ï¼Œå½“å†…æ ¸è¿è¡Œäº†è¿™ä¸ªè¿›ç¨‹ï¼Œå†…æ ¸ä¼šå°†è¿›ç¨‹çš„æ ¹page tableçš„åœ°å€åŠ è½½åˆ°SATPä¸­ã€‚ä»é‚£ä¸ªæ—¶é—´ç‚¹å¼€å§‹ï¼Œå¤„ç†å™¨ä¼šä½¿ç”¨å†…æ ¸ä¸ºé‚£ä¸ªè¿›ç¨‹æ„å»ºçš„è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚ Code:Creating an address spaceå¤§éƒ¨åˆ†ç”¨äºæ“ä½œåœ°å€ç©ºé—´å’Œé¡µè¡¨çš„xv6ä»£ç ä½äºvm.cï¼ˆkernel&#x2F;vm.cï¼‰ä¸­ã€‚ä¸»è¦æ•°æ®ç»“æ„æ˜¯pagetable_tï¼Œå®ƒå®é™…ä¸Šæ˜¯æŒ‡å‘RISC-V 35æ ¹é¡µè¡¨é¡µé¢çš„æŒ‡é’ˆï¼›pagetable_tå¯ä»¥æ˜¯å†…æ ¸é¡µè¡¨ï¼Œä¹Ÿå¯ä»¥æ˜¯æ¯ä¸ªè¿›ç¨‹çš„é¡µè¡¨ä¹‹ä¸€ã€‚ä¸»è¦å‡½æ•°ä¸ºwalkï¼Œè¯¥å‡½æ•°æŸ¥æ‰¾è™šæ‹Ÿåœ°å€çš„PTEï¼Œå¹¶ä¸”mappageså®‰è£…æ–°æ˜ å°„çš„PTEã€‚ä»¥kvmå¼€å¤´çš„å‡½æ•°æ“ä½œå†…æ ¸é¡µè¡¨ï¼›ä»¥uvmå¼€å¤´çš„å‡½æ•°æ“ä½œç”¨æˆ·é¡µè¡¨ï¼›å…¶ä»–åŠŸèƒ½åŒæ—¶ç”¨äºä¸¤è€…ã€‚copyoutå’Œcopyinå°†æ•°æ®å¤åˆ¶å’Œä»ä½œä¸ºç³»ç»Ÿè°ƒç”¨å‚æ•°æä¾›çš„ç”¨æˆ·è™šæ‹Ÿåœ°å€å¤åˆ¶å‡ºæ¥ï¼›å®ƒä»¬åœ¨vm.cä¸­å› ä¸ºéœ€è¦æ˜ç¡®ç¿»è¯‘è¿™äº›åœ°å€æ‰èƒ½æ‰¾åˆ°ç›¸åº”ç‰©ç†å­˜å‚¨å™¨ã€‚ åœ¨å¼•å¯¼åºåˆ—æ—©æœŸï¼Œmainè°ƒç”¨kvminitï¼ˆkernel&#x2F;vm.c:54ï¼‰ä½¿ç”¨kvmmakeï¼ˆkernel&#x2F;vm.c:20ï¼‰åˆ›å»ºå†…æ ¸é¡µé¢è¡¨æ ¼ã€‚ 12345voidkvminit(void)&#123; kernel_pagetable = kvmmake();&#125; 1234567891011121314151617181920212223242526272829303132pagetable_tkvmmake(void)&#123; pagetable_t kpgtbl; kpgtbl = (pagetable_t) kalloc(); memset(kpgtbl, 0, PGSIZE); // uart registers kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // PLIC kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we&#x27;ll make use of. kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); // allocate and map a kernel stack for each process. proc_mapstacks(kpgtbl); return kpgtbl;&#125; æ­¤è°ƒç”¨å‘ç”Ÿåœ¨xv6å¯åŠ¨RISC-Våˆ†é¡µä¹‹å‰ï¼Œå› æ­¤åœ°å€ç›´æ¥å¼•ç”¨ç‰©ç†å­˜å‚¨å™¨ã€‚kvmmakeé¦–å…ˆåˆ†é…ä¸€ä¸ªç‰©ç†å­˜å‚¨å™¨é¡µé¢æ¥ä¿å­˜æ ¹é¡µé¢- è¡¨ç¤ºé¡µé¢; ç„¶åå®ƒè°ƒç”¨kvmmapæ¥å®‰è£…å†…æ ¸æ‰€éœ€çš„è½¬æ¢ã€‚è¿™äº›è½¬æ¢åŒ…æ‹¬å†…æ ¸æŒ‡ä»¤å’Œæ•°æ®ã€PHYSTOPä»¥ä¸‹ çš„ç‰©ç†å­˜å‚¨å™¨ä»¥åŠå®é™…ä¸Šæ˜¯è®¾å¤‡çš„å†…å­˜èŒƒå›´ã€‚ proc_mapstacksï¼ˆkernel&#x2F;proc.c:33ï¼‰ä¸ºæ¯ä¸ªè¿›ç¨‹åˆ†é…ä¸€ä¸ªå†…æ ¸å †æ ˆã€‚å®ƒè°ƒç”¨kvmmapå°†æ¯ä¸ªå †æ ˆæ˜ å°„åˆ°ç”±KSTACKç”Ÿæˆçš„è™šæ‹Ÿåœ°å€ï¼Œè¿™æ ·å¯ä»¥ç•™å‡ºæ— æ•ˆçš„å †æ ˆä¿æŠ¤é¡µã€‚ 12345678910111213141516// Allocate a page for each process&#x27;s kernel stack.// Map it high in memory, followed by an invalid// guard page.voidproc_mapstacks(pagetable_t kpgtbl)&#123; struct proc *p; for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; char *pa = kalloc(); if(pa == 0) panic(&quot;kalloc&quot;); uint64 va = KSTACK((int) (p - proc)); kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); &#125;&#125; kvmmapï¼ˆkernel&#x2F;vm.c:127ï¼‰è°ƒç”¨mappagesï¼ˆkernel&#x2F;vm.c:138ï¼‰ï¼Œè¯¥å‡½æ•°ä¸ºä¸€ç³»åˆ—è™šæ‹Ÿåœ°å€èŒƒå›´å®‰è£…æ˜ å°„åˆ°ç›¸åº”ç‰©ç†åœ°å€çš„é¡µé¢è¡¨æ ¼ä¸­ã€‚ 123456789// add a mapping to the kernel page table.// only used when booting.// does not flush TLB or enable paging.voidkvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)&#123; if(mappages(kpgtbl, va, sz, pa, perm) != 0) panic(&quot;kvmmap&quot;);&#125; 12345678910111213141516171819202122232425262728// Create PTEs for virtual addresses starting at va that refer to// physical addresses starting at pa. va and size might not// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t// allocate a needed page-table page.intmappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)&#123; uint64 a, last; pte_t *pte; if(size == 0) panic(&quot;mappages: size&quot;); a = PGROUNDDOWN(va); last = PGROUNDDOWN(va + size - 1); for(;;)&#123; if((pte = walk(pagetable, a, 1)) == 0) return -1; if(*pte &amp; PTE_V) panic(&quot;mappages: remap&quot;); *pte = PA2PTE(pa) | perm | PTE_V; if(a == last) break; a += PGSIZE; pa += PGSIZE; &#125; return 0;&#125; å®ƒå¯¹äºèŒƒå›´ä¸­çš„æ¯ä¸ªè™šæ‹Ÿåœ°å€å•ç‹¬æ‰§è¡Œæ­¤æ“ä½œï¼Œåœ¨é¡µé¢é—´éš”å¤„æ‰§è¡Œæ­¤æ“ä½œã€‚å¯¹äºè¦æ˜ å°„çš„æ¯ä¸ªè™šæ‹Ÿåœ°å€ï¼Œmappageséƒ½ä¼šè°ƒç”¨walkæ¥æŸ¥æ‰¾è¯¥åœ°å€PTEçš„ä½ç½®ã€‚ç„¶åï¼Œå®ƒåˆå§‹åŒ–PTEä»¥ä¿å­˜ç›¸å…³ç‰©ç†é¡µå·ã€æ‰€éœ€æƒé™ï¼ˆPTE_Wã€PTE_Xå’Œ&#x2F;æˆ– PTE_Rï¼‰å’Œæ ‡è®°PTE_Vä½œä¸ºæœ‰æ•ˆ(kernel&#x2F;vm.c:153)ã€‚ 12345678910111213141516171819202122232425262728// Create PTEs for virtual addresses starting at va that refer to// physical addresses starting at pa. va and size might not// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t// allocate a needed page-table page.intmappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)&#123; uint64 a, last; pte_t *pte; if(size == 0) panic(&quot;mappages: size&quot;); a = PGROUNDDOWN(va); last = PGROUNDDOWN(va + size - 1); for(;;)&#123; if((pte = walk(pagetable, a, 1)) == 0) return -1; if(*pte &amp; PTE_V) panic(&quot;mappages: remap&quot;); *pte = PA2PTE(pa) | perm | PTE_V; if(a == last) break; a += PGSIZE; pa += PGSIZE; &#125; return 0;&#125; walkï¼ˆkernel&#x2F;vm.c:81ï¼‰æ¨¡ä»¿RISC-Våˆ†é¡µç¡¬ä»¶ï¼ŒæŸ¥æ‰¾è™šæ‹Ÿåœ°å€çš„PTEã€‚walkæ¯æ¬¡ä¸‹é™3çº§é¡µé¢è¡¨9ä½ã€‚å®ƒä½¿ç”¨æ¯ä¸ªçº§åˆ«çš„9ä½è™šæ‹Ÿåœ°å€æ¥æŸ¥æ‰¾ä¸‹ä¸€çº§é¡µé¢è¡¨æˆ–æœ€ç»ˆé¡µé¢çš„PTEï¼ˆkernel&#x2F;vm.c:87ï¼‰ã€‚å¦‚æœPTEæ— æ•ˆï¼Œåˆ™å°šæœªåˆ†é…æ‰€éœ€é¡µé¢ï¼›å¦‚æœè®¾ç½®äº†allocå‚æ•°ï¼Œåˆ™walkå°†åˆ†é…æ–°çš„é¡µè¡¨é¡µå¹¶å°†å…¶ç‰©ç†åœ°å€æ”¾å…¥PTEä¸­ã€‚ 12345678910111213141516171819202122232425262728293031// Return the address of the PTE in page table pagetable// that corresponds to virtual address va. If alloc!=0,// create any required page-table pages.//// The risc-v Sv39 scheme has three levels of page-table// pages. A page-table page contains 512 64-bit PTEs.// A 64-bit virtual address is split into five fields:// 39..63 -- must be zero.// 30..38 -- 9 bits of level-2 index.// 21..29 -- 9 bits of level-1 index.// 12..20 -- 9 bits of level-0 index.// 0..11 -- 12 bits of byte offset within the page.pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)&#123; if(va &gt;= MAXVA) panic(&quot;walk&quot;); for(int level = 2; level &gt; 0; level--) &#123; pte_t *pte = &amp;pagetable[PX(level, va)]; if(*pte &amp; PTE_V) &#123; pagetable = (pagetable_t)PTE2PA(*pte); &#125; else &#123; if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; &#125; &#125; return &amp;pagetable[PX(0, va)];&#125; å®ƒè¿”å›æ ‘ä¸­æœ€ä½å±‚çš„PTEåœ°å€ã€‚ä»¥ä¸Šä»£ç ä¾èµ–äºç‰©ç†å†…å­˜è¢«ç›´æ¥æ˜ å°„åˆ°å†…æ ¸è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ã€‚ä¾‹å¦‚ï¼Œå½“walkä¸‹é™é¡µé¢è¡¨çº§åˆ«æ—¶ï¼Œå®ƒä»PTEè·å–ä¸‹ä¸€ä¸ªå‘ä¸‹çº§åˆ«é¡µé¢è¡¨(ç‰©ç†)åœ°å€ï¼Œå¹¶ä½¿ç”¨è¯¥åœ°å€ä½œä¸ºè™šæ‹Ÿåœ°å€è·å–ä¸‹ä¸€ä¸ªå‘ä¸‹çº§åˆ«çš„ PTE ã€‚ 12345678910111213/ Switch h/w page table register to the kernel&#x27;s page table,// and enable paging.voidkvminithart()&#123; // wait for any previous writes to the page table memory to finish. sfence_vma(); w_satp(MAKE_SATP(kernel_pagetable)); // flush stale entries from the TLB. sfence_vma();&#125; ä¸»å‡½æ•°è°ƒç”¨kvminithart(kernel &#x2F; vm.cï¼š62)å®‰è£…å†…æ ¸é¡µè¡¨ã€‚ å®ƒå°†æ ¹é¡µè¡¨é¡µçš„ç‰©ç†åœ°å€å†™å…¥satpå¯„å­˜å™¨ã€‚ä¹‹åCPUå°†ä½¿ç”¨å†…æ ¸é¡µè¡¨ç¿»è¯‘åœ°å€ã€‚ç”±äºå†…æ ¸ä½¿ç”¨èº«ä»½æ˜ å°„ï¼Œç°åœ¨æŒ‡ä»¤é›†åˆä¸Šä¸€æ¡æŒ‡ä»¤å¯¹åº”æ­£ç¡®çš„ç‰©ç†å†…å­˜ä½ç½®ã€‚ æ¯ä¸ªRISC-V CPUéƒ½ä¼šåœ¨è½¬æ¢å‰ç¼“å­˜TLBä¸­ç›¸åº”ä¿¡æ¯ï¼Œåœ¨xv6æ›´æ”¹æŸä¸€é¡µæ—¶å¿…é¡»å‘Šè¯‰CPUä½¿ç›¸åº”çš„ç¼“å­˜TLBæ¡ç›®å¤±æ•ˆã€‚å¦‚æœæ²¡æœ‰è¿™æ ·åšï¼Œé‚£ä¹ˆåœ¨ä»¥åçš„æŸä¸ªæ—¶å€™ï¼ŒTLBå¯èƒ½ä¼šä½¿ç”¨æ—§çš„ç¼“å­˜æ˜ å°„ï¼ŒæŒ‡å‘æ­¤æ—¶å·²åˆ†é…ç»™å¦ä¸€ä¸ªè¿›ç¨‹çš„ç‰©ç†é¡µé¢ï¼Œå¹¶ä¸”ç»“æœæ˜¯è¿›ç¨‹å¯èƒ½èƒ½å¤Ÿæ¶‚å†™å…¶ä»–è¿›ç¨‹çš„å†…å­˜ã€‚RISC-Væœ‰ä¸€ç§æŒ‡ä»¤sfence.vmaå¯ä»¥åˆ·æ–°å½“å‰CPUçš„TLBã€‚Xv6åœ¨é‡æ–°åŠ è½½satpå¯„å­˜å™¨ä¹‹åï¼Œåœ¨kvminithartä¸­æ‰§è¡Œsfence.vmaï¼Œå¹¶åœ¨è·³æ¿ä»£ç (kernel&#x2F;trampoline.S:79)ä¸­åˆ‡æ¢åˆ°36ç”¨æˆ·é¡µè¡¨å¹¶è¿”å›ç”¨æˆ·ç©ºé—´å‰æ‰§è¡Œã€‚ ä¸ºäº†é¿å…åˆ·æ–°å®Œæ•´çš„TLBï¼ŒRISC-V CPUå¯ä»¥æ”¯æŒåœ°å€ç©ºé—´æ ‡è¯†ç¬¦ï¼ˆASIDsï¼‰ã€‚ç„¶åå†…æ ¸åªéœ€æ¸…é™¤ç‰¹å®šåœ°å€ç©ºé—´çš„TLBæ¡ç›®å³å¯","categories":[{"name":"è¯¾ç¨‹å­¦ä¹ ","slug":"è¯¾ç¨‹å­¦ä¹ ","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"è¯¾ç¨‹å­¦ä¹ /MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture03 OS Organization and System Call","slug":"MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call","date":"2023-04-02T06:44:05.000Z","updated":"2023-04-06T08:24:13.187Z","comments":true,"path":"2023/04/02/MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call/","link":"","permalink":"http://example.com/2023/04/02/MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call/","excerpt":"Topic Isolation:Isolationæ˜¯è®¾è®¡æ“ä½œç³»ç»Ÿç»„ç»‡ç»“æ„çš„é©±åŠ¨åŠ› System Call:System callæ˜¯ä½ çš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿè½¬æ¢åˆ°å†…æ ¸æ‰§è¡Œçš„åŸºæœ¬æ–¹æ³• Kernel mode&#x2F;user mode Isolation","text":"Topic Isolation:Isolationæ˜¯è®¾è®¡æ“ä½œç³»ç»Ÿç»„ç»‡ç»“æ„çš„é©±åŠ¨åŠ› System Call:System callæ˜¯ä½ çš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿè½¬æ¢åˆ°å†…æ ¸æ‰§è¡Œçš„åŸºæœ¬æ–¹æ³• Kernel mode&#x2F;user mode Isolationåº”ç”¨ç¨‹åºä¹‹é—´æœ‰éš”ç¦»æ€§æˆ‘ä»¬åœ¨ç”¨æˆ·ç©ºé—´æœ‰å¤šä¸ªåº”ç”¨ç¨‹åºï¼Œä¾‹å¦‚Shellã€echoã€findç­‰ç­‰ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ é€šè¿‡Shellè¿è¡Œä½ ä»¬çš„Primeä»£ç ï¼ˆlab1ä¸­çš„ä¸€ä¸ªéƒ¨åˆ†ï¼‰æ—¶ï¼Œå‡è®¾ä½ ä»¬çš„ä»£ç å‡ºç°äº†é—®é¢˜ï¼ŒShellä¸åº”è¯¥ä¼šå½±å“åˆ°å…¶ä»–çš„åº”ç”¨ç¨‹åºã€‚ä¸¾ä¸ªåä¾‹ï¼Œå¦‚æœShellå‡ºç°é—®é¢˜æ—¶ï¼Œæ€æ‰äº†å…¶ä»–çš„è¿›ç¨‹ï¼Œè¿™å°†ä¼šéå¸¸ç³Ÿç³•ã€‚æ‰€ä»¥ä½ éœ€è¦åœ¨ä¸åŒçš„åº”ç”¨ç¨‹åºä¹‹é—´æœ‰å¼ºéš”ç¦»æ€§ã€‚ åº”ç”¨ç¨‹åºä¸æ“ä½œç³»ç»Ÿä¹‹é—´æœ‰éš”ç¦»æ€§æ“ä½œç³»ç»ŸæŸç§ç¨‹åº¦ä¸Šä¸ºæ‰€æœ‰çš„åº”ç”¨ç¨‹åºæœåŠ¡ã€‚å½“ä½ çš„åº”ç”¨ç¨‹åºå‡ºç°é—®é¢˜æ—¶ï¼Œä½ ä¼šå¸Œæœ›æ“ä½œç³»ç»Ÿä¸ä¼šå› æ­¤è€Œå´©æºƒã€‚æ¯”å¦‚è¯´ä½ å‘æ“ä½œç³»ç»Ÿä¼ é€’äº†ä¸€äº›å¥‡æ€ªçš„å‚æ•°ï¼Œä½ ä¼šå¸Œæœ›æ“ä½œç³»ç»Ÿä»ç„¶èƒ½å¤Ÿå¾ˆå¥½çš„å¤„ç†å®ƒä»¬ï¼ˆèƒ½è¾ƒå¥½çš„å¤„ç†å¼‚å¸¸æƒ…å†µï¼‰ã€‚æ‰€ä»¥ï¼Œä½ ä¹Ÿéœ€è¦åœ¨åº”ç”¨ç¨‹åºå’Œæ“ä½œç³»ç»Ÿä¹‹é—´æœ‰å¼ºéš”ç¦»æ€§ã€‚ å¦‚æœæ²¡æœ‰æ“ä½œç³»ç»Ÿå¦‚æœæ²¡æœ‰æ“ä½œç³»ç»Ÿï¼Œæˆ–è€…æ“ä½œç³»ç»Ÿåªæ˜¯ä¸€äº›åº“æ–‡ä»¶ï¼Œæ¯”å¦‚è¯´ä½ åœ¨ä½¿ç”¨Pythonï¼Œé€šè¿‡import osä½ å°±å¯ä»¥å°†æ•´ä¸ªæ“ä½œç³»ç»ŸåŠ è½½åˆ°ä½ çš„åº”ç”¨ç¨‹åºä¸­ã€‚é‚£ä¹ˆç°åœ¨ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªShellï¼Œå¹¶ä¸”æˆ‘ä»¬å¼•ç”¨äº†ä»£è¡¨æ“ä½œç³»ç»Ÿçš„åº“ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬æœ‰ä¸€äº›å…¶ä»–çš„åº”ç”¨ç¨‹åºï¼Œä¾‹å¦‚echoã€‚ é€šå¸¸æ¥è¯´ï¼Œå¦‚æœæ²¡æœ‰æ“ä½œç³»ç»Ÿï¼Œåº”ç”¨ç¨‹åºä¼šç›´æ¥ä¸ç¡¬ä»¶äº¤äº’ã€‚æ¯”å¦‚ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥ç›´æ¥çœ‹åˆ°CPUçš„å¤šä¸ªæ ¸ï¼Œçœ‹åˆ°ç£ç›˜ï¼Œå†…å­˜ã€‚æ‰€ä»¥ç°åœ¨åº”ç”¨ç¨‹åºå’Œç¡¬ä»¶èµ„æºä¹‹é—´æ²¡æœ‰ä¸€ä¸ªé¢å¤–çš„æŠ½è±¡å±‚ã€‚ è°ƒåº¦åŠå¤ç”¨éš”ç¦»é—®é¢˜ä½¿ç”¨æ“ä½œç³»ç»Ÿçš„ä¸€ä¸ªç›®çš„æ˜¯ä¸ºäº†åŒæ—¶è¿è¡Œå¤šä¸ªåº”ç”¨ç¨‹åºï¼Œæ‰€ä»¥æ—¶ä¸æ—¶çš„ï¼ŒCPUä¼šä»ä¸€ä¸ªåº”ç”¨ç¨‹åºåˆ‡æ¢åˆ°å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºã€‚æˆ‘ä»¬å‡è®¾ç¡¬ä»¶èµ„æºé‡Œåªæœ‰ä¸€ä¸ªCPUæ ¸ï¼Œå¹¶ä¸”æˆ‘ä»¬ç°åœ¨åœ¨è¿™ä¸ªCPUæ ¸ä¸Šè¿è¡ŒShellã€‚ä½†æ˜¯æ—¶ä¸æ—¶çš„ï¼Œä¹Ÿéœ€è¦è®©å…¶ä»–çš„åº”ç”¨ç¨‹åºä¹Ÿå¯ä»¥è¿è¡Œã€‚ç°åœ¨æˆ‘ä»¬æ²¡æœ‰æ“ä½œç³»ç»Ÿæ¥å¸®æˆ‘ä»¬å®Œæˆåˆ‡æ¢ï¼Œæ‰€ä»¥Shellå°±éœ€è¦æ—¶ä¸æ—¶çš„é‡Šæ”¾CPUèµ„æºã€‚ ä¸ºäº†ä¸å˜æˆä¸€ä¸ªæ¶æ„ç¨‹åºï¼ŒShellåœ¨å‘ç°è‡ªå·±è¿è¡Œäº†ä¸€æ®µæ—¶é—´ä¹‹åï¼Œéœ€è¦è®©åˆ«çš„ç¨‹åºä¹Ÿæœ‰æœºä¼šèƒ½è¿è¡Œã€‚è¿™ç§æœºåˆ¶æœ‰æ—¶å€™ç§°ä¸ºååŒè°ƒåº¦ï¼ˆCooperative Schedulingï¼‰ã€‚ä½†æ˜¯è¿™é‡Œçš„åœºæ™¯å¹¶æ²¡æœ‰å¾ˆå¥½çš„éš”ç¦»æ€§ï¼Œæ¯”å¦‚è¯´Shellä¸­çš„æŸä¸ªå‡½æ•°æœ‰ä¸€ä¸ªæ­»å¾ªç¯ï¼Œé‚£ä¹ˆShellæ°¸è¿œä¹Ÿä¸ä¼šé‡Šæ”¾CPUï¼Œè¿›è€Œå…¶ä»–çš„åº”ç”¨ç¨‹åºä¹Ÿä¸èƒ½å¤Ÿè¿è¡Œï¼Œç”šè‡³éƒ½ä¸èƒ½è¿è¡Œä¸€ä¸ªç¬¬ä¸‰æ–¹çš„ç¨‹åºæ¥åœæ­¢æˆ–è€…æ€æ­»Shellç¨‹åºã€‚æ‰€ä»¥è¿™ç§åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬åŸºæœ¬ä¸Šå¾—ä¸åˆ°çœŸæ­£çš„multiplexingï¼ˆCPUåœ¨å¤šè¿›ç¨‹åŒåˆ†æ—¶å¤ç”¨ï¼‰ã€‚è€Œè¿™ä¸ªç‰¹æ€§æ˜¯éå¸¸æœ‰ç”¨çš„ï¼Œä¸è®ºåº”ç”¨ç¨‹åºåœ¨æ‰§è¡Œä»€ä¹ˆæ“ä½œï¼Œmultiplexingéƒ½ä¼šè¿«ä½¿åº”ç”¨ç¨‹åºæ—¶ä¸æ—¶çš„é‡Šæ”¾CPUï¼Œè¿™æ ·å…¶ä»–çš„åº”ç”¨ç¨‹åºæ‰èƒ½è¿è¡Œã€‚ å†…å­˜éš”ç¦»é—®é¢˜å‡è®¾ç°åœ¨ç‰©ç†å†…å­˜ä¸­çš„ä¸€éƒ¨åˆ†è¢«Shellä½¿ç”¨ï¼Œå¦ä¸€éƒ¨åˆ†è¢«echoä½¿ç”¨ã€‚å› ä¸ºä¸¤ä¸ªåº”ç”¨ç¨‹åºçš„å†…å­˜ä¹‹é—´æ²¡æœ‰è¾¹ç•Œï¼Œå¦‚æœechoç¨‹åºå°†æ•°æ®å­˜å‚¨åœ¨å±äºShellçš„ä¸€ä¸ªå†…å­˜åœ°å€ä¸­ï¼Œé‚£ä¹ˆå°±echoå°±ä¼šè¦†ç›–Shellç¨‹åºå†…å­˜ä¸­çš„å†…å®¹ã€‚ ä½¿ç”¨æ“ä½œç³»ç»Ÿçš„ä¸€ä¸ªåŸå› ï¼Œç”šè‡³å¯ä»¥è¯´æ˜¯ä¸»è¦åŸå› å°±æ˜¯ä¸ºäº†å®ç°multiplexingå’Œå†…å­˜éš”ç¦»ã€‚å¦‚æœä½ ä¸ä½¿ç”¨æ“ä½œç³»ç»Ÿï¼Œå¹¶ä¸”åº”ç”¨ç¨‹åºç›´æ¥ä¸ç¡¬ä»¶äº¤äº’ï¼Œå°±å¾ˆéš¾å®ç°è¿™ä¸¤ç‚¹ã€‚æ‰€ä»¥ï¼Œå°†æ“ä½œç³»ç»Ÿè®¾è®¡æˆä¸€ä¸ªåº“ï¼Œå¹¶ä¸æ˜¯ä¸€ç§å¸¸è§çš„è®¾è®¡ã€‚ä½ æˆ–è®¸å¯ä»¥åœ¨ä¸€äº›å®æ—¶æ“ä½œç³»ç»Ÿä¸­çœ‹åˆ°è¿™æ ·çš„è®¾è®¡ï¼Œå› ä¸ºåœ¨è¿™äº›å®æ—¶æ“ä½œç³»ç»Ÿä¸­ï¼Œåº”ç”¨ç¨‹åºä¹‹é—´å½¼æ­¤ç›¸äº’ä¿¡ä»»ã€‚ä½†æ˜¯åœ¨å¤§éƒ¨åˆ†çš„å…¶ä»–æ“ä½œç³»ç»Ÿä¸­ï¼Œéƒ½ä¼šå¼ºåˆ¶å®ç°ç¡¬ä»¶èµ„æºçš„éš”ç¦»ã€‚ ä»éš”ç¦»çš„è§’åº¦æ¥çœ‹Unixæ¥å£å¦‚æœæˆ‘ä»¬ä»éš”ç¦»çš„è§’åº¦æ¥ç¨å¾®çœ‹çœ‹Unixæ¥å£ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œæ¥å£è¢«ç²¾å¿ƒè®¾è®¡ä»¥å®ç°èµ„æºçš„å¼ºéš”ç¦»ï¼Œä¹Ÿå°±æ˜¯multiplexingå’Œç‰©ç†å†…å­˜çš„éš”ç¦»ã€‚æ¥å£é€šè¿‡æŠ½è±¡ç¡¬ä»¶èµ„æºï¼Œä»è€Œä½¿å¾—æä¾›å¼ºéš”ç¦»æ€§æˆä¸ºå¯èƒ½ã€‚ Example 1ä¹‹å‰é€šè¿‡forkåˆ›å»ºäº†è¿›ç¨‹ã€‚è¿›ç¨‹æœ¬èº«ä¸æ˜¯CPUï¼Œä½†æ˜¯å®ƒä»¬å¯¹åº”äº†CPUï¼Œå®ƒä»¬ä½¿å¾—ä½ å¯ä»¥åœ¨CPUä¸Šè¿è¡Œè®¡ç®—ä»»åŠ¡ã€‚æ‰€ä»¥ä½ æ‡‚çš„ï¼Œåº”ç”¨ç¨‹åºä¸èƒ½ç›´æ¥ä¸CPUäº¤äº’ï¼Œåªèƒ½ä¸è¿›ç¨‹äº¤äº’ã€‚æ“ä½œç³»ç»Ÿå†…æ ¸ä¼šå®Œæˆä¸åŒè¿›ç¨‹åœ¨CPUä¸Šçš„åˆ‡æ¢ã€‚æ‰€ä»¥ï¼Œæ“ä½œç³»ç»Ÿä¸æ˜¯ç›´æ¥å°†CPUæä¾›ç»™åº”ç”¨ç¨‹åºï¼Œè€Œæ˜¯å‘åº”ç”¨ç¨‹åºæä¾›â€œè¿›ç¨‹â€ï¼Œè¿›ç¨‹æŠ½è±¡äº†CPUï¼Œè¿™æ ·æ“ä½œç³»ç»Ÿæ‰èƒ½åœ¨å¤šä¸ªåº”ç”¨ç¨‹åºä¹‹é—´å¤ç”¨ä¸€ä¸ªæˆ–è€…å¤šä¸ªCPUã€‚ æˆ‘ä»¬åœ¨å®éªŒä¸­ä½¿ç”¨çš„RISC-Vå¤„ç†å™¨å®é™…ä¸Šæ˜¯æœ‰4ä¸ªæ ¸ã€‚æ‰€ä»¥ä½ å¯ä»¥åŒæ—¶è¿è¡Œ4ä¸ªè¿›ç¨‹ï¼Œä¸€ä¸ªè¿›ç¨‹å ç”¨ä¸€ä¸ªæ ¸ã€‚ä½†æ˜¯å‡è®¾ä½ æœ‰8ä¸ªåº”ç”¨ç¨‹åºï¼Œæ“ä½œç³»ç»Ÿä¼šåˆ†æ—¶å¤ç”¨è¿™äº›CPUæ ¸ï¼Œæ¯”å¦‚è¯´å¯¹äºä¸€ä¸ªè¿›ç¨‹è¿è¡Œ100æ¯«ç§’ï¼Œä¹‹åå†…æ ¸ä¼šåœæ­¢è¿è¡Œå¹¶å°†é‚£ä¸ªè¿›ç¨‹ä»CPUä¸­å¸è½½ï¼Œå†åŠ è½½å¦ä¸€ä¸ªåº”ç”¨ç¨‹åºå¹¶å†è¿è¡Œ100æ¯«ç§’ã€‚é€šè¿‡è¿™ç§æ–¹å¼ä½¿å¾—æ¯ä¸€ä¸ªåº”ç”¨ç¨‹åºéƒ½ä¸ä¼šè¿ç»­è¿è¡Œè¶…è¿‡100æ¯«ç§’ã€‚è¿™é‡Œåªæ˜¯ä¸€äº›åŸºæœ¬æ¦‚å¿µï¼Œæˆ‘ä»¬åœ¨æ¥ä¸‹æ¥çš„å‡ èŠ‚è¯¾ä¸­ä¼šå…·ä½“çš„çœ‹è¿™é‡Œæ˜¯å¦‚ä½•å®ç°çš„ã€‚ æˆ‘ä»¬å¯ä»¥è®¤ä¸ºexecæŠ½è±¡äº†å†…å­˜ã€‚å½“æˆ‘ä»¬åœ¨æ‰§è¡Œexecç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šä¼ å…¥ä¸€ä¸ªæ–‡ä»¶åï¼Œè€Œè¿™ä¸ªæ–‡ä»¶åå¯¹åº”äº†ä¸€ä¸ªåº”ç”¨ç¨‹åºçš„å†…å­˜é•œåƒã€‚å†…å­˜é•œåƒé‡Œé¢åŒ…æ‹¬äº†ç¨‹åºå¯¹åº”çš„æŒ‡ä»¤ï¼Œå…¨å±€çš„æ•°æ®ã€‚åº”ç”¨ç¨‹åºå¯ä»¥é€æ¸æ‰©å±•è‡ªå·±çš„å†…å­˜ï¼Œä½†æ˜¯åº”ç”¨ç¨‹åºå¹¶æ²¡æœ‰ç›´æ¥è®¿é—®ç‰©ç†å†…å­˜çš„æƒé™ï¼Œä¾‹å¦‚åº”ç”¨ç¨‹åºä¸èƒ½ç›´æ¥è®¿é—®ç‰©ç†å†…å­˜çš„1000-2000è¿™æ®µåœ°å€ã€‚ä¸èƒ½ç›´æ¥è®¿é—®çš„åŸå› æ˜¯ï¼Œæ“ä½œç³»ç»Ÿä¼šæä¾›å†…å­˜éš”ç¦»å¹¶æ§åˆ¶å†…å­˜ï¼Œæ“ä½œç³»ç»Ÿä¼šåœ¨åº”ç”¨ç¨‹åºå’Œç¡¬ä»¶èµ„æºä¹‹é—´æä¾›ä¸€ä¸ªä¸­é—´å±‚ã€‚execæ˜¯è¿™æ ·ä¸€ç§ç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒè¡¨æ˜äº†åº”ç”¨ç¨‹åºä¸èƒ½ç›´æ¥è®¿é—®ç‰©ç†å†…å­˜ã€‚ Example 2filesåŸºæœ¬ä¸Šæ¥è¯´æŠ½è±¡äº†ç£ç›˜ã€‚åº”ç”¨ç¨‹åºä¸ä¼šç›´æ¥è¯»å†™æŒ‚åœ¨è®¡ç®—æœºä¸Šçš„ç£ç›˜æœ¬èº«ï¼Œå¹¶ä¸”åœ¨Unixä¸­è¿™ä¹Ÿæ˜¯ä¸è¢«å…è®¸çš„ã€‚åœ¨Unixä¸­ï¼Œä¸å­˜å‚¨ç³»ç»Ÿäº¤äº’çš„å”¯ä¸€æ–¹å¼å°±æ˜¯é€šè¿‡filesã€‚Filesæä¾›äº†éå¸¸æ–¹ä¾¿çš„ç£ç›˜æŠ½è±¡ï¼Œä½ å¯ä»¥å¯¹æ–‡ä»¶å‘½åï¼Œè¯»å†™æ–‡ä»¶ç­‰ç­‰ã€‚ä¹‹åï¼Œæ“ä½œç³»ç»Ÿä¼šå†³å®šå¦‚ä½•å°†æ–‡ä»¶ä¸ç£ç›˜ä¸­çš„å—å¯¹åº”ï¼Œç¡®ä¿ä¸€ä¸ªç£ç›˜å—åªå‡ºç°åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œå¹¶ä¸”ç¡®ä¿ç”¨æˆ·Aä¸èƒ½æ“ä½œç”¨æˆ·Bçš„æ–‡ä»¶ã€‚é€šè¿‡filesçš„æŠ½è±¡ï¼Œå¯ä»¥å®ç°ä¸åŒç”¨æˆ·ä¹‹é—´å’ŒåŒä¸€ä¸ªç”¨æˆ·çš„ä¸åŒè¿›ç¨‹ä¹‹é—´çš„æ–‡ä»¶å¼ºéš”ç¦»ã€‚ Defensive é˜²å¾¡æ€§ï¼šå½“ä½ åœ¨åšå†…æ ¸å¼€å‘æ—¶ï¼Œè¿™æ˜¯ä¸€ç§ä½ éœ€è¦ç†Ÿæ‚‰çš„é‡è¦æ€æƒ³ã€‚æ“ä½œç³»ç»Ÿéœ€è¦ç¡®ä¿æ‰€æœ‰çš„ç»„ä»¶éƒ½èƒ½å·¥ä½œï¼Œæ‰€ä»¥å®ƒéœ€è¦åšå¥½å‡†å¤‡æŠµå¾¡æ¥è‡ªåº”ç”¨ç¨‹åºçš„æ”»å‡»ã€‚å¦‚æœè¯´åº”ç”¨ç¨‹åºæ— æ„æˆ–è€…æ¶æ„çš„å‘ç³»ç»Ÿè°ƒç”¨ä¼ å…¥ä¸€äº›é”™è¯¯çš„å‚æ•°å°±ä¼šå¯¼è‡´æ“ä½œç³»ç»Ÿå´©æºƒï¼Œé‚£å°±å¤ªç³Ÿç³•äº†ã€‚åœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œæ“ä½œç³»ç»Ÿå› ä¸ºå´©æºƒäº†ä¼šæ‹’ç»ä¸ºå…¶ä»–æ‰€æœ‰çš„åº”ç”¨ç¨‹åºæä¾›æœåŠ¡ã€‚æ‰€ä»¥æ“ä½œç³»ç»Ÿéœ€è¦ä»¥è¿™æ ·ä¸€ç§æ–¹å¼æ¥å®Œæˆï¼šæ“ä½œç³»ç»Ÿéœ€è¦èƒ½å¤Ÿåº”å¯¹æ¶æ„çš„åº”ç”¨ç¨‹åºã€‚ éš”ç¦»æ€§ï¼šå¦ä¸€ä¸ªéœ€è¦è€ƒè™‘çš„æ˜¯ï¼Œåº”ç”¨ç¨‹åºä¸èƒ½å¤Ÿæ‰“ç ´å¯¹å®ƒçš„éš”ç¦»ã€‚åº”ç”¨ç¨‹åºéå¸¸æœ‰å¯èƒ½æ˜¯æ¶æ„çš„ï¼Œå®ƒæˆ–è®¸æ˜¯ç”±æ”»å‡»è€…å†™å‡ºæ¥çš„ï¼Œæ”»å‡»è€…æˆ–è®¸æƒ³è¦æ‰“ç ´å¯¹åº”ç”¨ç¨‹åºçš„éš”ç¦»ï¼Œè¿›è€Œæ§åˆ¶å†…æ ¸ã€‚ä¸€æ—¦æœ‰äº†å¯¹äºå†…æ ¸çš„æ§åˆ¶èƒ½åŠ›ï¼Œä½ å¯ä»¥åšä»»ä½•äº‹æƒ…ï¼Œå› ä¸ºå†…æ ¸æ§åˆ¶äº†æ‰€æœ‰çš„ç¡¬ä»¶èµ„æºã€‚ æ‰€ä»¥æ“ä½œç³»ç»Ÿæˆ–è€…è¯´å†…æ ¸éœ€è¦å…·å¤‡é˜²å¾¡æ€§æ¥é¿å…ç±»ä¼¼çš„äº‹æƒ…å‘ç”Ÿã€‚å®é™…ä¸­ï¼Œè¦æ»¡è¶³è¿™äº›è¦æ±‚è¿˜æœ‰ç‚¹æ£˜æ‰‹ã€‚åœ¨Linuxä¸­ï¼Œæ—¶ä¸æ—¶çš„æœ‰ä¸€äº›å†…æ ¸çš„bugä½¿å¾—åº”ç”¨ç¨‹åºå¯ä»¥æ‰“ç ´å®ƒçš„éš”ç¦»åŸŸå¹¶æ§åˆ¶å†…æ ¸ã€‚è¿™é‡Œéœ€è¦æŒç»­çš„å…³æ³¨ï¼Œå¹¶å°½å¯èƒ½çš„æä¾›æœ€å¥½çš„é˜²å¾¡æ€§ã€‚å½“ä½ åœ¨å¼€å‘å†…æ ¸æ—¶ï¼Œé˜²å¾¡æ€§æ˜¯ä½ å¿…é¡»æŒæ¡çš„ä¸€ä¸ªæ€æƒ³ã€‚å®é™…ä¸­çš„åº”ç”¨ç¨‹åºæˆ–è®¸å°±æ˜¯æ¶æ„çš„ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦åœ¨åº”ç”¨ç¨‹åºå’Œæ“ä½œç³»ç»Ÿä¹‹é—´æä¾›å¼ºéš”ç¦»æ€§ã€‚å¦‚æœæ“ä½œç³»ç»Ÿéœ€è¦å…·å¤‡é˜²å¾¡æ€§ï¼Œé‚£ä¹ˆåœ¨åº”ç”¨ç¨‹åºå’Œæ“ä½œç³»ç»Ÿä¹‹é—´éœ€è¦æœ‰ä¸€å µåšå¢™ï¼Œå¹¶ä¸”æ“ä½œç³»ç»Ÿå¯ä»¥åœ¨è¿™å µå¢™ä¸Šæ‰§è¡Œä»»ä½•å®ƒæƒ³æ‰§è¡Œçš„ç­–ç•¥ã€‚ é€šå¸¸æ¥è¯´ï¼Œéœ€è¦é€šè¿‡ç¡¬ä»¶æ¥å®ç°å¼ºéš”ç¦»æ€§ã€‚è¿™é‡Œçš„ç¡¬ä»¶ä¸»è¦åŒ…æ‹¬ä¸¤éƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯user&#x2F;kernel modeï¼Œkernel modeåœ¨RISC-Vä¸­è¢«ç§°ä¸ºSupervisor modeä½†æ˜¯å…¶å®æ˜¯åŒä¸€ç§ä¸œè¥¿ï¼›ç¬¬äºŒéƒ¨åˆ†æ˜¯page tableæˆ–è€…è™šæ‹Ÿå†…å­˜ï¼ˆVirtual Memoryï¼‰ æ‰€ä»¥ï¼Œæ‰€æœ‰çš„å¤„ç†å™¨ï¼Œå¦‚æœéœ€è¦è¿è¡Œèƒ½å¤Ÿæ”¯æŒå¤šä¸ªåº”ç”¨ç¨‹åºçš„æ“ä½œç³»ç»Ÿï¼Œéœ€è¦åŒæ—¶æ”¯æŒuser&#x2F;kernle modeå’Œè™šæ‹Ÿå†…å­˜ã€‚å…·ä½“çš„å®ç°æˆ–è®¸ä¼šæœ‰ç»†å¾®çš„å·®åˆ«ï¼Œä½†æ˜¯åŸºæœ¬ä¸Šæ¥è¯´æ‰€æœ‰çš„å¤„ç†å™¨éœ€è¦èƒ½æ”¯æŒè¿™äº›ã€‚ ç¡¬ä»¶å¯¹äºå¼ºéš”ç¦»çš„æ”¯æŒuser&#x2F;kernel modeä¸ºäº†æ”¯æŒuser&#x2F;kernel modeï¼Œå¤„ç†å™¨ä¼šæœ‰ä¸¤ç§æ“ä½œæ¨¡å¼ï¼Œç¬¬ä¸€ç§æ˜¯user modeï¼Œç¬¬äºŒç§æ˜¯kernel modeã€‚å½“è¿è¡Œåœ¨kernel modeæ—¶ï¼ŒCPUå¯ä»¥è¿è¡Œç‰¹å®šæƒé™çš„æŒ‡ä»¤ï¼ˆprivileged instructionsï¼‰ï¼›å½“è¿è¡Œåœ¨user modeæ—¶ï¼ŒCPUåªèƒ½è¿è¡Œæ™®é€šæƒé™çš„æŒ‡ä»¤ï¼ˆunprivileged instructionsï¼‰ã€‚ æ™®é€šæƒé™çš„æŒ‡ä»¤éƒ½æ˜¯ä¸€äº›ä½ ä»¬ç†Ÿæ‚‰çš„æŒ‡ä»¤ï¼Œä¾‹å¦‚å°†ä¸¤ä¸ªå¯„å­˜å™¨ç›¸åŠ çš„æŒ‡ä»¤ADDã€å°†ä¸¤ä¸ªå¯„å­˜å™¨ç›¸å‡çš„æŒ‡ä»¤SUBã€è·³è½¬æŒ‡ä»¤JRCã€BRANCHæŒ‡ä»¤ç­‰ç­‰ã€‚è¿™äº›éƒ½æ˜¯æ™®é€šæƒé™æŒ‡ä»¤ï¼Œæ‰€æœ‰çš„åº”ç”¨ç¨‹åºéƒ½å…è®¸æ‰§è¡Œè¿™äº›æŒ‡ä»¤ã€‚ ç‰¹æ®Šæƒé™æŒ‡ä»¤ä¸»è¦æ˜¯ä¸€äº›ç›´æ¥æ“çºµç¡¬ä»¶çš„æŒ‡ä»¤å’Œè®¾ç½®ä¿æŠ¤çš„æŒ‡ä»¤ï¼Œä¾‹å¦‚è®¾ç½®page tableå¯„å­˜å™¨ã€å…³é—­æ—¶é’Ÿä¸­æ–­ã€‚åœ¨å¤„ç†å™¨ä¸Šæœ‰å„ç§å„æ ·çš„çŠ¶æ€ï¼Œæ“ä½œç³»ç»Ÿä¼šä½¿ç”¨è¿™äº›çŠ¶æ€ï¼Œä½†æ˜¯åªèƒ½é€šè¿‡ç‰¹æ®Šæƒé™æŒ‡ä»¤æ¥å˜æ›´è¿™äº›çŠ¶æ€ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œå½“ä¸€ä¸ªåº”ç”¨ç¨‹åºå°è¯•æ‰§è¡Œä¸€æ¡ç‰¹æ®Šæƒé™æŒ‡ä»¤ï¼Œå› ä¸ºä¸å…è®¸åœ¨user modeæ‰§è¡Œç‰¹æ®Šæƒé™æŒ‡ä»¤ï¼Œå¤„ç†å™¨ä¼šæ‹’ç»æ‰§è¡Œè¿™æ¡æŒ‡ä»¤ã€‚é€šå¸¸æ¥è¯´ï¼Œè¿™æ—¶ä¼šå°†æ§åˆ¶æƒé™ä»user modeåˆ‡æ¢åˆ°kernel modeï¼Œå½“æ“ä½œç³»ç»Ÿæ‹¿åˆ°æ§åˆ¶æƒä¹‹åï¼Œæˆ–è®¸ä¼šæ€æ‰è¿›ç¨‹ï¼Œå› ä¸ºåº”ç”¨ç¨‹åºæ‰§è¡Œäº†ä¸è¯¥æ‰§è¡Œçš„æŒ‡ä»¤ã€‚ åœ¨å¤„ç†å™¨é‡Œé¢æœ‰ä¸€ä¸ªflagã€‚åœ¨å¤„ç†å™¨çš„ä¸€ä¸ªbitï¼Œå½“å®ƒä¸º1çš„æ—¶å€™æ˜¯user modeï¼Œå½“å®ƒä¸º0æ—¶æ˜¯kernel modeã€‚å½“å¤„ç†å™¨åœ¨è§£ææŒ‡ä»¤æ—¶ï¼Œå¦‚æœæŒ‡ä»¤æ˜¯ç‰¹æ®Šæƒé™æŒ‡ä»¤ï¼Œå¹¶ä¸”è¯¥bitè¢«è®¾ç½®ä¸º1ï¼Œå¤„ç†å™¨ä¼šæ‹’ç»æ‰§è¡Œè¿™æ¡æŒ‡ä»¤ï¼Œå°±åƒåœ¨è¿ç®—æ—¶ä¸èƒ½é™¤ä»¥0ä¸€æ ·ã€‚è®¾ç½®é‚£ä¸ªbitä½çš„æŒ‡ä»¤å¿…é¡»æ˜¯ç‰¹æ®Šæƒé™æŒ‡ä»¤ï¼Œå› ä¸ºåº”ç”¨ç¨‹åºä¸åº”è¯¥èƒ½å¤Ÿè®¾ç½®é‚£ä¸ªbitåˆ°kernel modeï¼Œå¦åˆ™çš„è¯åº”ç”¨ç¨‹åºå°±å¯ä»¥è¿è¡Œå„ç§ç‰¹æ®Šæƒé™æŒ‡ä»¤äº†ã€‚æ‰€ä»¥é‚£ä¸ªbitæ˜¯è¢«ä¿æŠ¤çš„ã€‚ RISC-Vè¿˜æœ‰ç¬¬ä¸‰ç§æ¨¡å¼ç§°ä¸ºmachine modeã€‚åœ¨å¤§å¤šæ•°åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬ä¼šå¿½ç•¥è¿™ç§æ¨¡å¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å®é™…ä¸Šæœ‰ä¸‰çº§æƒé™user&#x2F;kernel&#x2F;machineã€‚ page tableæ¯ä¸€ä¸ªè¿›ç¨‹éƒ½ä¼šæœ‰è‡ªå·±ç‹¬ç«‹çš„page tableï¼Œè¿™æ ·çš„è¯ï¼Œæ¯ä¸€ä¸ªè¿›ç¨‹åªèƒ½è®¿é—®å‡ºç°åœ¨è‡ªå·±page tableä¸­çš„ç‰©ç†å†…å­˜ã€‚æ“ä½œç³»ç»Ÿä¼šè®¾ç½®page tableï¼Œä½¿å¾—æ¯ä¸€ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸é‡åˆçš„ç‰©ç†å†…å­˜ï¼Œè¿™æ ·ä¸€ä¸ªè¿›ç¨‹å°±ä¸èƒ½è®¿é—®å…¶ä»–è¿›ç¨‹çš„ç‰©ç†å†…å­˜ï¼Œå› ä¸ºå…¶ä»–è¿›ç¨‹çš„ç‰©ç†å†…å­˜éƒ½ä¸åœ¨å®ƒçš„page tableä¸­ã€‚ä¸€ä¸ªè¿›ç¨‹ç”šè‡³éƒ½ä¸èƒ½éšæ„ç¼–é€ ä¸€ä¸ªå†…å­˜åœ°å€ï¼Œç„¶åé€šè¿‡è¿™ä¸ªå†…å­˜åœ°å€æ¥è®¿é—®å…¶ä»–è¿›ç¨‹çš„ç‰©ç†å†…å­˜ã€‚è¿™æ ·å°±ç»™äº†æˆ‘ä»¬å†…å­˜çš„å¼ºéš”ç¦»æ€§ã€‚ åŸºæœ¬ä¸Šæ¥è¯´ï¼Œpage tableå®šä¹‰äº†å¯¹äºå†…å­˜çš„è§†å›¾ï¼Œè€Œæ¯ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹éƒ½æœ‰è‡ªå·±å¯¹äºå†…å­˜çš„ç‹¬ç«‹è§†å›¾ã€‚è¿™ç»™äº†æˆ‘ä»¬éå¸¸å¼ºçš„å†…å­˜éš”ç¦»æ€§ã€‚ User&#x2F;Kernel modeåˆ‡æ¢æˆ‘ä»¬å¯ä»¥è®¤ä¸ºuser&#x2F;kernel modeæ˜¯åˆ†éš”ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„è¾¹ç•Œï¼Œç”¨æˆ·ç©ºé—´è¿è¡Œçš„ç¨‹åºè¿è¡Œåœ¨user modeï¼Œå†…æ ¸ç©ºé—´çš„ç¨‹åºè¿è¡Œåœ¨kernel modeã€‚æ“ä½œç³»ç»Ÿä½äºå†…æ ¸ç©ºé—´ã€‚ å½“lsç¨‹åºè¿è¡Œçš„æ—¶å€™ï¼Œä¼šè°ƒç”¨read&#x2F;writeç³»ç»Ÿè°ƒç”¨ï¼›Shellç¨‹åºä¼šè°ƒç”¨forkæˆ–è€…execç³»ç»Ÿè°ƒç”¨ï¼Œæ‰€ä»¥å¿…é¡»è¦æœ‰ä¸€ç§æ–¹å¼å¯ä»¥ä½¿å¾—ç”¨æˆ·çš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿå°†æ§åˆ¶æƒä»¥ä¸€ç§ååŒå·¥ä½œçš„æ–¹å¼è½¬ç§»åˆ°å†…æ ¸ï¼Œè¿™æ ·å†…æ ¸æ‰èƒ½æä¾›ç›¸åº”çš„æœåŠ¡ã€‚ Ecallåœ¨RISC-Vä¸­ï¼Œæœ‰ä¸€ä¸ªä¸“é—¨çš„æŒ‡ä»¤ç”¨æ¥å®ç°æ§åˆ¶æƒçš„è½¬æ¢åŠŸèƒ½ï¼Œå«åšECALLã€‚ECALLæ¥æ”¶ä¸€ä¸ªæ•°å­—å‚æ•°ï¼Œå½“ä¸€ä¸ªç”¨æˆ·ç¨‹åºæƒ³è¦å°†ç¨‹åºæ‰§è¡Œçš„æ§åˆ¶æƒè½¬ç§»åˆ°å†…æ ¸ï¼Œå®ƒåªéœ€è¦æ‰§è¡ŒECALLæŒ‡ä»¤ï¼Œå¹¶ä¼ å…¥ä¸€ä¸ªæ•°å­—ã€‚è¿™é‡Œçš„æ•°å­—å‚æ•°ä»£è¡¨äº†åº”ç”¨ç¨‹åºæƒ³è¦è°ƒç”¨çš„System Callã€‚ ECALLä¼šè·³è½¬åˆ°å†…æ ¸ä¸­ä¸€ä¸ªç‰¹å®šï¼Œç”±å†…æ ¸æ§åˆ¶çš„ä½ç½®ã€‚åœ¨XV6ä¸­å­˜åœ¨ä¸€ä¸ªå”¯ä¸€çš„ç³»ç»Ÿè°ƒç”¨æ¥å…¥ç‚¹ï¼Œæ¯ä¸€æ¬¡åº”ç”¨ç¨‹åºæ‰§è¡ŒECALLæŒ‡ä»¤ï¼Œåº”ç”¨ç¨‹åºéƒ½ä¼šé€šè¿‡è¿™ä¸ªæ¥å…¥ç‚¹è¿›å…¥åˆ°å†…æ ¸ä¸­ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä¸è®ºæ˜¯Shellè¿˜æ˜¯å…¶ä»–çš„åº”ç”¨ç¨‹åºï¼Œå½“å®ƒåœ¨ç”¨æˆ·ç©ºé—´æ‰§è¡Œforkæ—¶ï¼Œå®ƒå¹¶ä¸æ˜¯ç›´æ¥è°ƒç”¨æ“ä½œç³»ç»Ÿä¸­å¯¹åº”çš„å‡½æ•°ï¼Œè€Œæ˜¯è°ƒç”¨ECALLæŒ‡ä»¤ï¼Œå¹¶å°†forkå¯¹åº”çš„æ•°å­—ä½œä¸ºå‚æ•°ä¼ ç»™ECALLã€‚ä¹‹åå†é€šè¿‡ECALLè·³è½¬åˆ°å†…æ ¸ã€‚ åœ¨å†…æ ¸ä¾§ï¼Œæœ‰ä¸€ä¸ªä½äºsyscall.cçš„å‡½æ•°syscallï¼Œæ¯ä¸€ä¸ªä»åº”ç”¨ç¨‹åºå‘èµ·çš„ç³»ç»Ÿè°ƒç”¨éƒ½ä¼šè°ƒç”¨åˆ°è¿™ä¸ªsyscallå‡½æ•°ï¼Œsyscallå‡½æ•°ä¼šæ£€æŸ¥ECALLçš„å‚æ•°ï¼Œé€šè¿‡è¿™ä¸ªå‚æ•°å†…æ ¸å¯ä»¥çŸ¥é“éœ€è¦è°ƒç”¨çš„æ˜¯forkã€‚ ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„ç•Œé™æ˜¯ä¸€ä¸ªç¡¬æ€§çš„ç•Œé™ï¼Œç”¨æˆ·ä¸èƒ½ç›´æ¥è°ƒç”¨forkï¼Œç”¨æˆ·çš„åº”ç”¨ç¨‹åºæ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„å”¯ä¸€æ–¹æ³•å°±æ˜¯é€šè¿‡è¿™é‡Œçš„ECALLæŒ‡ä»¤ã€‚ å‡è®¾æˆ‘ç°åœ¨è¦æ‰§è¡Œå¦ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨writeï¼Œç›¸åº”çš„æµç¨‹æ˜¯ç±»ä¼¼çš„ï¼Œwriteç³»ç»Ÿè°ƒç”¨ä¸èƒ½ç›´æ¥è°ƒç”¨å†…æ ¸ä¸­çš„writeä»£ç ï¼Œè€Œæ˜¯ç”±å°è£…å¥½çš„ç³»ç»Ÿè°ƒç”¨å‡½æ•°æ‰§è¡ŒECALLæŒ‡ä»¤ã€‚æ‰€ä»¥writeå‡½æ•°å®é™…ä¸Šè°ƒç”¨çš„æ˜¯ECALLæŒ‡ä»¤ï¼ŒæŒ‡ä»¤çš„å‚æ•°æ˜¯ä»£è¡¨äº†writeç³»ç»Ÿè°ƒç”¨çš„æ•°å­—ã€‚ä¹‹åæ§åˆ¶æƒåˆ°äº†syscallå‡½æ•°ï¼Œsyscallä¼šå®é™…è°ƒç”¨writeç³»ç»Ÿè°ƒç”¨ã€‚ å®å†…æ ¸å’Œå¾®å†…æ ¸ï¼ˆMonolithic Kernel and Micro Kernelï¼‰ç°åœ¨ï¼Œæˆ‘ä»¬æœ‰äº†ä¸€ç§æ–¹æ³•ï¼Œå¯ä»¥é€šè¿‡ç³»ç»Ÿè°ƒç”¨æˆ–è€…è¯´ECALLæŒ‡ä»¤ï¼Œå°†æ§åˆ¶æƒä»åº”ç”¨ç¨‹åºè½¬åˆ°æ“ä½œç³»ç»Ÿä¸­ã€‚ä¹‹åå†…æ ¸è´Ÿè´£å®ç°å…·ä½“çš„åŠŸèƒ½å¹¶æ£€æŸ¥å‚æ•°ä»¥ç¡®ä¿ä¸ä¼šè¢«ä¸€äº›åçš„å‚æ•°æ‰€æ¬ºéª—ã€‚æ‰€ä»¥å†…æ ¸æœ‰æ—¶å€™ä¹Ÿè¢«ç§°ä¸ºå¯è¢«ä¿¡ä»»çš„è®¡ç®—ç©ºé—´ï¼ˆTrusted Computing Baseï¼‰ï¼Œåœ¨ä¸€äº›å®‰å…¨çš„æœ¯è¯­ä¸­ä¹Ÿè¢«ç§°ä¸ºTCBã€‚ åŸºæœ¬ä¸Šæ¥è¯´ï¼Œè¦è¢«ç§°ä¸ºTCBï¼Œå†…æ ¸é¦–å…ˆè¦æ˜¯æ­£ç¡®ä¸”æ²¡æœ‰Bugçš„ã€‚å‡è®¾å†…æ ¸ä¸­æœ‰Bugï¼Œæ”»å‡»è€…å¯èƒ½ä¼šåˆ©ç”¨é‚£ä¸ªBugï¼Œå¹¶å°†è¿™ä¸ªBugè½¬å˜æˆæ¼æ´ï¼Œè¿™ä¸ªæ¼æ´ä½¿å¾—æ”»å‡»è€…å¯ä»¥æ‰“ç ´æ“ä½œç³»ç»Ÿçš„éš”ç¦»æ€§å¹¶æ¥ç®¡å†…æ ¸ã€‚æ‰€ä»¥å†…æ ¸çœŸçš„æ˜¯éœ€è¦è¶Šå°‘çš„Bugè¶Šå¥½ã€‚ å¦ä¸€æ–¹é¢ï¼Œå†…æ ¸å¿…é¡»è¦å°†ç”¨æˆ·åº”ç”¨ç¨‹åºæˆ–è€…è¿›ç¨‹å½“åšæ˜¯æ¶æ„çš„ã€‚å†…æ ¸çš„è®¾è®¡äººå‘˜åœ¨ç¼–å†™å’Œå®ç°å†…æ ¸ä»£ç æ—¶ï¼Œå¿…é¡»è¦æœ‰å®‰å…¨çš„æ€æƒ³ã€‚è¿™ä¸ªç›®æ ‡å¾ˆéš¾å®ç°ï¼Œå› ä¸ºå½“ä½ çš„æ“ä½œç³»ç»Ÿå˜å¾—è¶³å¤Ÿå¤§çš„æ—¶å€™ï¼Œå¾ˆå¤šäº‹æƒ…å°±ä¸æ˜¯é‚£ä¹ˆç›´è§‚äº†ã€‚å‡ ä¹æ¯ä¸€ä¸ªä½ ç”¨è¿‡çš„æˆ–è€…è¢«å¹¿æ³›ä½¿ç”¨çš„æ“ä½œç³»ç»Ÿï¼Œæ—¶ä¸æ—¶çš„éƒ½æœ‰ä¸€ä¸ªå®‰å…¨æ¼æ´ã€‚å°±ç®—è¢«ä¿®å¤äº†ï¼Œä½†æ˜¯è¿‡äº†ä¸€æ®µæ—¶é—´ï¼Œåˆä¼šå‡ºç°ä¸€ä¸ªæ–°çš„æ¼æ´ã€‚æˆ‘ä»¬ä¹‹åä¼šä»‹ç»ä¸ºä»€ä¹ˆå¾ˆéš¾è®©æ‰€æœ‰éƒ¨åˆ†éƒ½æ­£ç¡®å·¥ä½œï¼Œä½†æ˜¯ä½ è¦çŸ¥é“æ˜¯å†…æ ¸éœ€è¦åšä¸€äº›trickyçš„å·¥ä½œï¼Œéœ€è¦æ“çºµç¡¬ä»¶ï¼Œéœ€è¦éå¸¸å°å¿ƒåšæ£€æŸ¥ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“å°±å‡ºç°ä¸€äº›å°çš„ç–æ¼ï¼Œè¿›è€Œè§¦å‘ä¸€ä¸ªBugã€‚è¿™ä¹Ÿæ˜¯å¯ä»¥ç†è§£çš„ã€‚ å®å†…æ ¸ï¼ˆMonolithic Kernelï¼‰è®©æ•´ä¸ªæ“ä½œç³»ç»Ÿä»£ç éƒ½è¿è¡Œåœ¨kernel modeã€‚å¤§å¤šæ•°çš„Unixæ“ä½œç³»ç»Ÿå®ç°éƒ½è¿è¡Œåœ¨kernel modeã€‚æ¯”å¦‚ï¼ŒXV6ä¸­ï¼Œæ‰€æœ‰çš„æ“ä½œç³»ç»ŸæœåŠ¡éƒ½åœ¨kernel modeä¸­ï¼Œè¿™ç§å½¢å¼è¢«ç§°ä¸ºMonolithic Kernel Designã€‚ åœ¨ä¸€ä¸ªå®å†…æ ¸ä¸­ï¼Œä»»ä½•ä¸€ä¸ªæ“ä½œç³»ç»Ÿçš„Bugéƒ½æœ‰å¯èƒ½æˆä¸ºæ¼æ´ã€‚å› ä¸ºæˆ‘ä»¬ç°åœ¨åœ¨å†…æ ¸ä¸­è¿è¡Œäº†ä¸€ä¸ªå·¨å¤§çš„æ“ä½œç³»ç»Ÿï¼Œå‡ºç°Bugçš„å¯èƒ½æ€§æ›´å¤§äº†ã€‚ä½ ä»¬å¯ä»¥å»æŸ¥ä¸€äº›ç»Ÿè®¡ä¿¡æ¯ï¼Œå¹³å‡æ¯3000è¡Œä»£ç éƒ½ä¼šæœ‰å‡ ä¸ªBugï¼Œæ‰€ä»¥å¦‚æœæœ‰è®¸å¤šè¡Œä»£ç è¿è¡Œåœ¨å†…æ ¸ä¸­ï¼Œé‚£ä¹ˆå‡ºç°ä¸¥é‡Bugçš„å¯èƒ½æ€§ä¹Ÿå˜å¾—æ›´å¤§ã€‚æ‰€ä»¥ä»å®‰å…¨çš„è§’åº¦æ¥è¯´ï¼Œåœ¨å†…æ ¸ä¸­æœ‰å¤§é‡çš„ä»£ç æ˜¯å®å†…æ ¸çš„ç¼ºç‚¹ã€‚ å¦‚æœä½ å»çœ‹ä¸€ä¸ªæ“ä½œç³»ç»Ÿï¼Œå®ƒåŒ…å«äº†å„ç§å„æ ·çš„ç»„æˆéƒ¨åˆ†ï¼Œæ¯”å¦‚è¯´æ–‡ä»¶ç³»ç»Ÿï¼Œè™šæ‹Ÿå†…å­˜ï¼Œè¿›ç¨‹ç®¡ç†ï¼Œè¿™äº›éƒ½æ˜¯æ“ä½œç³»ç»Ÿå†…å®ç°äº†ç‰¹å®šåŠŸèƒ½çš„å­æ¨¡å—ã€‚å®å†…æ ¸çš„ä¼˜åŠ¿åœ¨äºï¼Œå› ä¸ºè¿™äº›å­æ¨¡å—ç°åœ¨éƒ½ä½äºåŒä¸€ä¸ªç¨‹åºä¸­ï¼Œå®ƒä»¬å¯ä»¥ç´§å¯†çš„é›†æˆåœ¨ä¸€èµ·ï¼Œè¿™æ ·çš„é›†æˆæä¾›å¾ˆå¥½çš„æ€§èƒ½ã€‚ä¾‹å¦‚Linuxï¼Œå®ƒå°±æœ‰å¾ˆä¸é”™çš„æ€§èƒ½ã€‚ å¾®å†…æ ¸ï¼ˆMicro Kernelï¼‰åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œå¸Œæœ›åœ¨kernel modeä¸­è¿è¡Œå°½å¯èƒ½å°‘çš„ä»£ç ã€‚æ‰€ä»¥è¿™ç§è®¾è®¡ä¸‹è¿˜æ˜¯æœ‰å†…æ ¸ï¼Œä½†æ˜¯å†…æ ¸åªæœ‰éå¸¸å°‘çš„å‡ ä¸ªæ¨¡å—ï¼Œä¾‹å¦‚ï¼Œå†…æ ¸é€šå¸¸ä¼šæœ‰ä¸€äº›IPCçš„å®ç°æˆ–è€…æ˜¯Message passingï¼›éå¸¸å°‘çš„è™šæ‹Ÿå†…å­˜çš„æ”¯æŒï¼Œå¯èƒ½åªæ”¯æŒäº†page tableï¼›ä»¥åŠåˆ†æ—¶å¤ç”¨CPUçš„ä¸€äº›æ”¯æŒã€‚ å¾®å†…æ ¸çš„ç›®çš„åœ¨äºå°†å¤§éƒ¨åˆ†çš„æ“ä½œç³»ç»Ÿè¿è¡Œåœ¨å†…æ ¸ä¹‹å¤–ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä¼šæœ‰user modeä»¥åŠuser&#x2F;kernel modeçš„è¾¹ç•Œã€‚ä½†æ˜¯æˆ‘ä»¬ç°åœ¨ä¼šå°†åŸæ¥åœ¨å†…æ ¸ä¸­çš„å…¶ä»–éƒ¨åˆ†ï¼Œä½œä¸ºæ™®é€šçš„ç”¨æˆ·ç¨‹åºæ¥è¿è¡Œã€‚æ¯”å¦‚æ–‡ä»¶ç³»ç»Ÿå¯èƒ½å°±æ˜¯ä¸ªå¸¸è§„çš„ç”¨æˆ·ç©ºé—´ç¨‹åºã€‚ æŸç§ç¨‹åº¦ä¸Šæ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§å¥½çš„è®¾è®¡ã€‚å› ä¸ºåœ¨å†…æ ¸ä¸­çš„ä»£ç çš„æ•°é‡è¾ƒå°ï¼Œæ›´å°‘çš„ä»£ç æ„å‘³ç€æ›´å°‘çš„Bugã€‚ ä½†æ˜¯è¿™ç§è®¾è®¡ä¹Ÿæœ‰ç›¸åº”çš„é—®é¢˜ã€‚å‡è®¾æˆ‘ä»¬éœ€è¦è®©Shellèƒ½ä¸æ–‡ä»¶ç³»ç»Ÿäº¤äº’ï¼Œæ¯”å¦‚Shellè°ƒç”¨äº†execï¼Œå¿…é¡»æœ‰ç§æ–¹å¼å¯ä»¥æ¥å…¥åˆ°æ–‡ä»¶ç³»ç»Ÿä¸­ã€‚é€šå¸¸æ¥è¯´ï¼Œè¿™é‡Œå·¥ä½œçš„æ–¹å¼æ˜¯ï¼ŒShellä¼šé€šè¿‡å†…æ ¸ä¸­çš„IPCç³»ç»Ÿå‘é€ä¸€æ¡æ¶ˆæ¯ï¼Œå†…æ ¸ä¼šæŸ¥çœ‹è¿™æ¡æ¶ˆæ¯å¹¶å‘ç°è¿™æ˜¯ç»™æ–‡ä»¶ç³»ç»Ÿçš„æ¶ˆæ¯ï¼Œä¹‹åå†…æ ¸ä¼šæŠŠæ¶ˆæ¯å‘é€ç»™æ–‡ä»¶ç³»ç»Ÿã€‚ æ–‡ä»¶ç³»ç»Ÿä¼šå®Œæˆå®ƒçš„å·¥ä½œä¹‹åä¼šå‘IPCç³»ç»Ÿå‘é€å›ä¸€æ¡æ¶ˆæ¯è¯´ï¼Œè¿™æ˜¯ä½ çš„execç³»ç»Ÿè°ƒç”¨çš„ç»“æœï¼Œä¹‹åIPCç³»ç»Ÿå†å°†è¿™æ¡æ¶ˆæ¯å‘é€ç»™Shellã€‚ æ‰€ä»¥ï¼Œè¿™é‡Œæ˜¯å…¸å‹çš„é€šè¿‡æ¶ˆæ¯æ¥å®ç°ä¼ ç»Ÿçš„ç³»ç»Ÿè°ƒç”¨ã€‚ç°åœ¨ï¼Œå¯¹äºä»»ä½•æ–‡ä»¶ç³»ç»Ÿçš„äº¤äº’ï¼Œéƒ½éœ€è¦åˆ†åˆ«å®Œæˆ2æ¬¡ç”¨æˆ·ç©ºé—´&lt;-&gt;å†…æ ¸ç©ºé—´çš„è·³è½¬ã€‚ä¸å®å†…æ ¸å¯¹æ¯”ï¼Œåœ¨å®å†…æ ¸ä¸­å¦‚æœä¸€ä¸ªåº”ç”¨ç¨‹åºéœ€è¦ä¸æ–‡ä»¶ç³»ç»Ÿäº¤äº’ï¼Œåªéœ€è¦å®Œæˆ1æ¬¡ç”¨æˆ·ç©ºé—´&lt;-&gt;å†…æ ¸ç©ºé—´çš„è·³è½¬ï¼Œæ‰€ä»¥å¾®å†…æ ¸çš„çš„è·³è½¬æ˜¯å®å†…æ ¸çš„ä¸¤å€ã€‚é€šå¸¸å¾®å†…æ ¸çš„æŒ‘æˆ˜åœ¨äºæ€§èƒ½æ›´å·®ï¼Œè¿™é‡Œæœ‰ä¸¤ä¸ªæ–¹é¢éœ€è¦è€ƒè™‘ï¼š åœ¨user&#x2F;kernel modeåå¤è·³è½¬å¸¦æ¥çš„æ€§èƒ½æŸè€—ã€‚ åœ¨ä¸€ä¸ªç±»ä¼¼å®å†…æ ¸çš„ç´§è€¦åˆç³»ç»Ÿï¼Œå„ä¸ªç»„æˆéƒ¨åˆ†ï¼Œä¾‹å¦‚æ–‡ä»¶ç³»ç»Ÿå’Œè™šæ‹Ÿå†…å­˜ç³»ç»Ÿï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„å…±äº«page cacheã€‚è€Œåœ¨å¾®å†…æ ¸ä¸­ï¼Œæ¯ä¸ªéƒ¨åˆ†ä¹‹é—´éƒ½å¾ˆå¥½çš„éš”ç¦»å¼€äº†ï¼Œè¿™ç§å…±äº«æ›´éš¾å®ç°ã€‚è¿›è€Œå¯¼è‡´æ›´éš¾åœ¨å¾®å†…æ ¸ä¸­å¾—åˆ°æ›´é«˜çš„æ€§èƒ½ã€‚ åœ¨å®é™…ä¸­ï¼Œä¸¤ç§å†…æ ¸è®¾è®¡éƒ½ä¼šå‡ºç°ï¼Œå‡ºäºå†å²åŸå› å¤§éƒ¨åˆ†çš„æ¡Œé¢æ“ä½œç³»ç»Ÿæ˜¯å®å†…æ ¸ï¼Œå¦‚æœä½ è¿è¡Œéœ€è¦å¤§é‡å†…æ ¸è®¡ç®—çš„åº”ç”¨ç¨‹åºï¼Œä¾‹å¦‚åœ¨æ•°æ®ä¸­å¿ƒæœåŠ¡å™¨ä¸Šçš„æ“ä½œç³»ç»Ÿï¼Œé€šå¸¸ä¹Ÿæ˜¯ä½¿ç”¨çš„å®å†…æ ¸ï¼Œä¸»è¦çš„åŸå› æ˜¯Linuxæä¾›äº†å¾ˆå¥½çš„æ€§èƒ½ã€‚ä½†æ˜¯å¾ˆå¤šåµŒå…¥å¼ç³»ç»Ÿï¼Œä¾‹å¦‚Minixï¼ŒCellï¼Œè¿™äº›éƒ½æ˜¯å¾®å†…æ ¸è®¾è®¡ã€‚è¿™ä¸¤ç§è®¾è®¡éƒ½å¾ˆæµè¡Œï¼Œå¦‚æœä½ ä»å¤´å¼€å§‹å†™ä¸€ä¸ªæ“ä½œç³»ç»Ÿï¼Œä½ å¯èƒ½ä¼šä»ä¸€ä¸ªå¾®å†…æ ¸è®¾è®¡å¼€å§‹ã€‚ä½†æ˜¯ä¸€æ—¦ä½ æœ‰äº†ç±»ä¼¼äºLinuxè¿™æ ·çš„å®å†…æ ¸è®¾è®¡ï¼Œå°†å®ƒé‡å†™åˆ°ä¸€ä¸ªå¾®å†…æ ¸è®¾è®¡å°†ä¼šæ˜¯å·¨å¤§çš„å·¥ä½œã€‚å¹¶ä¸”è¿™æ ·é‡æ„çš„åŠ¨æœºä¹Ÿä¸è¶³ï¼Œå› ä¸ºäººä»¬æ€»æ˜¯æƒ³æŠŠæ—¶é—´èŠ±åœ¨å®ç°æ–°åŠŸèƒ½ä¸Šï¼Œè€Œä¸æ˜¯é‡æ„ä»–ä»¬çš„å†…æ ¸ã€‚ ç¼–è¯‘è¿è¡ŒKernelä»£ç ç»“æ„ kernelï¼šé‡Œé¢åŒ…å«äº†åŸºæœ¬ä¸Šæ‰€æœ‰çš„å†…æ ¸æ–‡ä»¶ã€‚å› ä¸ºXV6æ˜¯ä¸€ä¸ªå®å†…æ ¸ç»“æ„ï¼Œè¿™é‡Œæ‰€æœ‰çš„æ–‡ä»¶ä¼šè¢«ç¼–è¯‘æˆä¸€ä¸ªå«åškernelçš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç„¶åè¿™ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ä¼šè¢«è¿è¡Œåœ¨kernle modeä¸­ã€‚ userï¼šè¿™åŸºæœ¬ä¸Šæ˜¯è¿è¡Œåœ¨user modeçš„ç¨‹åºã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä¸€ä¸ªç›®å½•ç§°ä¸ºkernelï¼Œå¦ä¸€ä¸ªç›®å½•ç§°ä¸ºuserçš„åŸå› ã€‚ mkfsï¼šå®ƒä¼šåˆ›å»ºä¸€ä¸ªç©ºçš„æ–‡ä»¶é•œåƒï¼Œæˆ‘ä»¬ä¼šå°†è¿™ä¸ªé•œåƒå­˜åœ¨ç£ç›˜ä¸Šï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æ¥ä½¿ç”¨ä¸€ä¸ªç©ºçš„æ–‡ä»¶ç³»ç»Ÿã€‚ ç¼–è¯‘è¿‡ç¨‹ Makefileï¼ˆXV6ç›®å½•ä¸‹çš„æ–‡ä»¶ï¼‰ä¼šè¯»å–ä¸€ä¸ªCæ–‡ä»¶ï¼Œä¾‹å¦‚proc.cï¼›ä¹‹åè°ƒç”¨gccç¼–è¯‘å™¨ï¼Œç”Ÿæˆä¸€ä¸ªæ–‡ä»¶å«åšproc.sï¼Œè¿™æ˜¯RISC-V æ±‡ç¼–è¯­è¨€æ–‡ä»¶ï¼›ä¹‹åå†èµ°åˆ°æ±‡ç¼–è§£é‡Šå™¨ï¼Œç”Ÿæˆproc.oï¼Œè¿™æ˜¯æ±‡ç¼–è¯­è¨€çš„äºŒè¿›åˆ¶æ ¼å¼ã€‚ Makefileä¼šä¸ºæ‰€æœ‰å†…æ ¸æ–‡ä»¶åšç›¸åŒçš„æ“ä½œï¼Œæ¯”å¦‚è¯´pipe.cï¼Œä¼šæŒ‰ç…§åŒæ ·çš„å¥—è·¯ï¼Œå…ˆç»è¿‡gccç¼–è¯‘æˆpipe.sï¼Œå†é€šè¿‡æ±‡ç¼–è§£é‡Šå™¨ç”Ÿæˆpipe.oã€‚ ä¹‹åï¼Œç³»ç»ŸåŠ è½½å™¨ï¼ˆLoaderï¼‰ä¼šæ”¶é›†æ‰€æœ‰çš„.oæ–‡ä»¶ï¼Œå°†å®ƒä»¬é“¾æ¥åœ¨ä¸€èµ·ï¼Œå¹¶ç”Ÿæˆå†…æ ¸æ–‡ä»¶ã€‚ è¿™é‡Œç”Ÿæˆçš„å†…æ ¸æ–‡ä»¶å°±æ˜¯æˆ‘ä»¬å°†ä¼šåœ¨QEMUä¸­è¿è¡Œçš„æ–‡ä»¶ã€‚åŒæ—¶ï¼Œä¸ºäº†ä½ ä»¬çš„æ–¹ä¾¿ï¼ŒMakefileè¿˜ä¼šåˆ›å»ºkernel.asmï¼Œè¿™é‡ŒåŒ…å«äº†å†…æ ¸çš„å®Œæ•´æ±‡ç¼–è¯­è¨€ï¼Œä½ ä»¬å¯ä»¥é€šè¿‡æŸ¥çœ‹å®ƒæ¥å®šä½ç©¶ç«Ÿæ˜¯å“ªä¸ªæŒ‡ä»¤å¯¼è‡´äº†Bugã€‚ ä¼ ç»™QEMUçš„å‡ ä¸ªå‚æ•° kernel ï¼šè¿™é‡Œä¼ é€’çš„æ˜¯å†…æ ¸æ–‡ä»¶ï¼ˆkernelç›®å½•ä¸‹çš„kernelæ–‡ä»¶ï¼‰ï¼Œè¿™æ˜¯å°†åœ¨QEMUä¸­è¿è¡Œçš„ç¨‹åºæ–‡ä»¶ã€‚ -m ï¼šè¿™é‡Œä¼ é€’çš„æ˜¯RISC-Vè™šæ‹Ÿæœºå°†ä¼šä½¿ç”¨çš„å†…å­˜æ•°é‡ã€‚ smpï¼šè¿™é‡Œä¼ é€’çš„æ˜¯è™šæ‹Ÿæœºå¯ä»¥ä½¿ç”¨çš„CPUæ ¸æ•° -driveï¼šä¼ é€’çš„æ˜¯è™šæ‹Ÿæœºä½¿ç”¨çš„ç£ç›˜é©±åŠ¨ï¼Œè¿™é‡Œä¼ å…¥çš„æ˜¯fs.imgæ–‡ä»¶ QEMUç›´è§‚æ¥çœ‹ï¼ŒQEMUæ˜¯ä¸€ä¸ªå¤§å‹çš„å¼€æºCç¨‹åºï¼Œä½ å¯ä»¥ä¸‹è½½æˆ–è€…git cloneå®ƒã€‚ä½†æ˜¯åœ¨å†…éƒ¨ï¼Œåœ¨QEMUçš„ä¸»å¾ªç¯ä¸­ï¼Œåªåœ¨åšä¸€ä»¶äº‹æƒ…ï¼š è¯»å–4å­—èŠ‚æˆ–è€…8å­—èŠ‚çš„RISC-VæŒ‡ä»¤ã€‚ è§£æRISC-VæŒ‡ä»¤ï¼Œå¹¶æ‰¾å‡ºå¯¹åº”çš„æ“ä½œç ï¼ˆop codeï¼‰ã€‚æˆ‘ä»¬ä¹‹å‰åœ¨çœ‹kernel.asmçš„æ—¶å€™ï¼Œçœ‹è¿‡ä¸€äº›æ“ä½œç çš„äºŒè¿›åˆ¶ç‰ˆæœ¬ã€‚é€šè¿‡è§£æï¼Œæˆ–è®¸å¯ä»¥çŸ¥é“è¿™æ˜¯ä¸€ä¸ªADDæŒ‡ä»¤ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªSUBæŒ‡ä»¤ã€‚ ä¹‹åï¼Œåœ¨è½¯ä»¶ä¸­æ‰§è¡Œç›¸åº”çš„æŒ‡ä»¤ã€‚ è¿™åŸºæœ¬ä¸Šå°±æ˜¯QEMUçš„å…¨éƒ¨å·¥ä½œäº†ï¼Œå¯¹äºæ¯ä¸ªCPUæ ¸ï¼ŒQEMUéƒ½ä¼šè¿è¡Œè¿™ä¹ˆä¸€ä¸ªå¾ªç¯ã€‚ XV6çš„å¯åŠ¨è¿‡ç¨‹QEMU æ˜¯ä¸€ä¸ªé€šç”¨çš„å¼€æºå¤„ç†å™¨æ¨¡æ‹Ÿå™¨å’Œè™šæ‹ŸåŒ–ç¨‹åºï¼Œå¯ä»¥ç”¨äºåœ¨ç‰©ç†è®¡ç®—æœºä¸Šæ¨¡æ‹Ÿè®¾å¤‡ï¼Œå¹¶è¿è¡Œå„ç§æ“ä½œç³»ç»Ÿï¼Œå¦‚ xv6ã€‚ä»¥ä¸‹æ˜¯ç»“åˆ QEMU æºä»£ç å’Œ xv6 æºä»£ç è¯´æ˜å¯åŠ¨è¿‡ç¨‹çš„æ¦‚è¿°ï¼š å¯åŠ¨ QEMUï¼šä»å‘½ä»¤è¡Œå¯åŠ¨ QEMUï¼Œå¹¶æŒ‡å®šè¦åŠ è½½çš„æ“ä½œç³»ç»Ÿæ˜ åƒï¼ˆåœ¨è¿™ç§æƒ…å†µä¸‹ä¸º xv6 æ“ä½œç³»ç»Ÿï¼‰ã€‚å‘½ä»¤å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š 1qemu-system-i386 -nographic -serial mon:stdio -hdb fs.img xv6.img -s -S åœ¨è¿™é‡Œï¼Œqemu-system-i386 æ˜¯é’ˆå¯¹ x86ï¼ˆ32 ä½ï¼‰ç³»ç»Ÿçš„ QEMU æ¨¡æ‹Ÿå™¨ï¼Œ-nographic å‚æ•°è¡¨ç¤ºä¸ä½¿ç”¨å›¾å½¢ç•Œé¢ï¼Œ-serial mon:stdio è¡¨ç¤ºå°†ç›‘è§†å™¨ï¼ˆQEMU æ§åˆ¶å°ï¼‰è¿æ¥åˆ°æ ‡å‡†è¾“å…¥&#x2F;è¾“å‡ºï¼Œ-hdb fs.img æŒ‡å®šè¦åŠ è½½çš„ xv6 æ–‡ä»¶ç³»ç»Ÿæ˜ åƒï¼Œxv6.img æ˜¯ xv6 æ“ä½œç³»ç»Ÿæ˜ åƒï¼Œ-s å’Œ -S å‚æ•°ç”¨äºè°ƒè¯•ã€‚ QEMU åˆå§‹åŒ–è™šæ‹Ÿç¡¬ä»¶ï¼šQEMU å°†æ ¹æ®æ‰€æŒ‡å®šçš„å‚æ•°å’Œé…ç½®ï¼Œåˆå§‹åŒ–è™šæ‹Ÿå¤„ç†å™¨ã€å†…å­˜ã€ç¡¬ç›˜å’Œå…¶ä»–ç¡¬ä»¶è®¾å¤‡ã€‚ åŠ è½½å¼•å¯¼ç¨‹åºï¼šQEMU æ¨¡æ‹Ÿ BIOS è¡Œä¸ºï¼Œå°† xv6.img æ˜ åƒä¸­çš„å¯åŠ¨æ‰‡åŒºåŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¹¶å°†æ§åˆ¶æƒäº¤ç»™è¿™æ®µä»£ç ã€‚åœ¨ xv6 çš„æƒ…å†µä¸‹ï¼Œå¼•å¯¼ç¨‹åºä½äº bootasm.Sï¼ˆæ±‡ç¼–ä»£ç ï¼‰å’Œ bootmain.cï¼ˆC ä»£ç ï¼‰ä¸­ã€‚ å¼•å¯¼ç¨‹åºè¿è¡Œï¼šæ¥ä¸‹æ¥çš„æ­¥éª¤ä¸å®é™…ç¡¬ä»¶ä¸Šçš„å¯åŠ¨è¿‡ç¨‹ç›¸åŒã€‚å¼•å¯¼ç¨‹åºé¦–å…ˆåˆ‡æ¢åˆ°ä¿æŠ¤æ¨¡å¼ï¼Œç„¶ååŠ è½½ ELF æ ¼å¼çš„ xv6 å†…æ ¸æ˜ åƒåˆ°å†…å­˜ä¸­ã€‚ è¿›å…¥ xv6 å†…æ ¸ï¼šå¼•å¯¼ç¨‹åºæ‰¾åˆ° xv6 å†…æ ¸çš„å…¥å£ç‚¹ï¼ˆåœ¨ kernel/entry.S ä¸­ï¼‰ï¼Œå¹¶å°†æ§åˆ¶æƒäº¤ç»™å†…æ ¸ã€‚å†…æ ¸ç°åœ¨å¼€å§‹è¿è¡Œå¹¶æ‰§è¡Œåˆå§‹åŒ–ä»»åŠ¡ã€‚ å†…æ ¸åˆå§‹åŒ–ï¼šåœ¨ main.c ä¸­çš„ main() å‡½æ•°ä¸­ï¼Œxv6 å†…æ ¸æ‰§è¡Œè¯¸å¦‚è®¾ç½®åˆ†é¡µã€åˆå§‹åŒ–ä¸­æ–­æ§åˆ¶å™¨ã€åˆå§‹åŒ–è¿›ç¨‹è°ƒåº¦å™¨ç­‰åˆå§‹åŒ–ä»»åŠ¡ã€‚ åˆ›å»ºåˆå§‹è¿›ç¨‹ï¼šxv6 åˆ›å»ºç¬¬ä¸€ä¸ªå†…æ ¸è¿›ç¨‹ï¼ˆinitcode.Sï¼‰ï¼Œå®ƒæ˜¯ä¸€ä¸ªç”¨æˆ·ç¨‹åºï¼Œè´Ÿè´£å¯åŠ¨å…¶ä»–ç”¨æˆ·è¿›ç¨‹ã€‚å†…æ ¸é€šè¿‡ fork() ç³»ç»Ÿè°ƒç”¨åˆ›å»ºæ–°è¿›ç¨‹ï¼Œå¹¶é€šè¿‡ exec() ç³»ç»Ÿè°ƒç”¨åŠ è½½å¹¶æ‰§è¡Œ initcode.Sã€‚ è¿è¡Œ init è¿›ç¨‹ï¼šinitcode.S è°ƒç”¨ init ç¨‹åºï¼ˆåœ¨ init.c ä¸­ï¼‰ï¼Œinit æ˜¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´ç¨‹åºï¼Œè´Ÿè´£å¯åŠ¨ç³»ç»Ÿçš„ç¬¬ä¸€ä¸ªæ­£å¸¸ç”¨æˆ·è¿›ç¨‹ï¼Œé€šå¸¸æ˜¯ä¸€ä¸ª shell ç¨‹åºã€‚åœ¨ xv6 ä¸­ï¼Œè¿™ä¸ªç¨‹åºæ˜¯ sh.cã€‚ è¿è¡Œ shell ç¨‹åºï¼šinit è¿›ç¨‹é€šè¿‡ fork() å’Œ exec() åˆ›å»ºå¹¶è¿è¡Œ shell ç¨‹åºã€‚è¿™æ—¶ï¼Œç”¨æˆ·å¯ä»¥åœ¨ shell ä¸­è¾“å…¥å‘½ä»¤å¹¶ä¸æ“ä½œç³»ç»Ÿè¿›è¡Œäº¤äº’ã€‚","categories":[{"name":"è¯¾ç¨‹å­¦ä¹ ","slug":"è¯¾ç¨‹å­¦ä¹ ","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"è¯¾ç¨‹å­¦ä¹ /MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT6.S081 Operating System Engineering Lecture01 Intrduction and Examples","slug":"MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples","date":"2023-03-31T06:19:09.000Z","updated":"2023-04-06T07:00:08.730Z","comments":true,"path":"2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/","link":"","permalink":"http://example.com/2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/","excerpt":"ç®€ä»‹è¯¾ç¨‹ç›®æ ‡ ç†è§£æ“ä½œç³»ç»Ÿçš„è®¾è®¡å’Œå®ç°ã€‚ç†è§£æ•´ä½“ç»“æ„å’Œå…·ä½“ä»£ç ã€‚ é€šè¿‡XV6æ“ä½œç³»ç»Ÿè·å¾—å®é™…åŠ¨æ‰‹ç»éªŒã€‚æ‰©å±•æ“ä½œç³»ç»Ÿï¼Œä¿®æ”¹å¹¶æå‡æ“ä½œç³»ç»Ÿçš„ç›¸å…³ç»éªŒï¼Œå¹¶ä¸”èƒ½å¤Ÿé€šè¿‡æ“ä½œç³»ç»Ÿæ¥å£ï¼Œç¼–å†™ç³»ç»Ÿè½¯ä»¶","text":"ç®€ä»‹è¯¾ç¨‹ç›®æ ‡ ç†è§£æ“ä½œç³»ç»Ÿçš„è®¾è®¡å’Œå®ç°ã€‚ç†è§£æ•´ä½“ç»“æ„å’Œå…·ä½“ä»£ç ã€‚ é€šè¿‡XV6æ“ä½œç³»ç»Ÿè·å¾—å®é™…åŠ¨æ‰‹ç»éªŒã€‚æ‰©å±•æ“ä½œç³»ç»Ÿï¼Œä¿®æ”¹å¹¶æå‡æ“ä½œç³»ç»Ÿçš„ç›¸å…³ç»éªŒï¼Œå¹¶ä¸”èƒ½å¤Ÿé€šè¿‡æ“ä½œç³»ç»Ÿæ¥å£ï¼Œç¼–å†™ç³»ç»Ÿè½¯ä»¶ OSçš„ç›®æ ‡ Abstract Hardware Multiplex Isolation Sharing Preformance Access Control&#x2F;Security Range Of Users OSçš„ç»“æ„åˆ†å±‚æ€æƒ³ Userspaceåœ¨æ¶æ„çš„æœ€ä¸Šå±‚ï¼Œè¿è¡Œå„ç§å„æ ·çš„åº”ç”¨ç¨‹åºä¾‹å¦‚æ–‡æœ¬ç¼–è¾‘å™¨ï¼ˆVIï¼‰ï¼ŒCç¼–è¾‘å™¨ï¼ˆCCï¼‰ï¼Œä½œä¸ºCLIå­˜åœ¨çš„shellã€‚ KernelåŒºåˆ«äºuserspaceï¼Œæœ‰ä¸€ä¸ªç‰¹æ®Šçš„ç¨‹åºæ€»æ˜¯ä¼šåœ¨è¿è¡Œã€‚Kernelæ˜¯è®¡ç®—æœºèµ„æºçš„å®ˆæŠ¤è€…ï¼Œå½“æ‰“å¼€è®¡ç®—æœºæ—¶ï¼ŒKernelæ€»æ˜¯ç¬¬ä¸€ä¸ªè¢«å¯åŠ¨ã€‚Kernelç¨‹åºåªæœ‰ä¸€ä¸ªï¼Œç»´æŠ¤æ•°æ®æ¥ç®¡ç†æ¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´è¿›ç¨‹ã€‚KernelåŒæ—¶è¿˜ç»´æŠ¤äº†å¤§é‡æ•°æ®ç»“æ„æ¥å¸®åŠ©å®ƒç®¡ç†å„ç§å„æ ·çš„ç¡¬ä»¶èµ„æºï¼Œä»¥ä¾›ç”¨æˆ·ç©ºé—´çš„ç¨‹åºä½¿ç”¨ã€‚KernelåŒæ—¶è¿˜ä¼šæœ‰å¤§é‡å†…ç½®çš„æœåŠ¡ã€‚ä¾‹å¦‚ï¼ŒKernelé€šå¸¸ä¼šæœ‰æ–‡ä»¶ç³»ç»Ÿå®ç°ç±»ä¼¼æ–‡ä»¶åï¼Œæ–‡ä»¶å†…å®¹ï¼Œç›®å½•çš„ä¸œè¥¿ï¼Œå¹¶ç†è§£å¦‚ä½•å°†æ–‡ä»¶å­˜å‚¨åœ¨ç£ç›˜ä¸­ã€‚æ‰€ä»¥ç”¨æˆ·ç©ºé—´çš„ç¨‹åºä¼šä¸Kernelä¸­çš„æ–‡ä»¶ç³»ç»Ÿäº¤äº’ï¼Œæ–‡ä»¶ç³»ç»Ÿå†ä¸ç£ç›˜äº¤äº’ã€‚ æˆ‘ä»¬ä¸»è¦å…³æ³¨åœ¨Kernelã€è¿æ¥Kernalå’Œç”¨æˆ·ç©ºé—´ç¨‹åºçš„æ¥å£ã€Kernelå†…è½¯ä»¶çš„æ¶æ„ ã€‚æ‰€ä»¥æˆ‘ä»¬ä¼šå…³å¿ƒKernelå†…çš„æœåŠ¡ã€‚å…¶ä¸­ä¸€ä¸ªæ˜¯æ–‡ä»¶ç³»ç»Ÿï¼Œå¦ä¸€ä¸ªå°±æ˜¯è¿›ç¨‹ç®¡ç†ç³»ç»Ÿã€‚ Manage Processï¼šæ¯ä¸€ä¸ªç”¨æˆ·ç©ºé—´ç¨‹åºéƒ½è¢«ç§°ä¸ºä¸€ä¸ªè¿›ç¨‹ï¼Œå®ƒä»¬æœ‰è‡ªå·±çš„å†…å­˜å’Œå…±äº«çš„CPUæ—¶é—´ã€‚ Allocate Memoryï¼šKernelä¼šç®¡ç†å†…å­˜çš„åˆ†é…ï¼Œä¸åŒçš„è¿›ç¨‹éœ€è¦ä¸åŒæ•°é‡çš„å†…å­˜ï¼ŒKernelä¼šå¤ç”¨å†…å­˜ã€åˆ’åˆ†å†…å­˜ï¼Œå¹¶ä¸ºæ‰€æœ‰çš„è¿›ç¨‹åˆ†é…å†…å­˜ã€‚ File Systemï¼šæ–‡ä»¶ç³»ç»Ÿé€šå¸¸æœ‰ä¸€äº›é€»è¾‘åˆ†åŒºã€‚ç›®å‰è€Œè¨€ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ–‡ä»¶ç³»ç»Ÿçš„ä½œç”¨æ˜¯ç®¡ç†æ–‡ä»¶å†…å®¹å¹¶æ‰¾å‡ºæ–‡ä»¶å…·ä½“åœ¨ç£ç›˜ä¸­çš„å“ªä¸ªä½ç½®ã€‚æ–‡ä»¶ç³»ç»Ÿè¿˜ç»´æŠ¤äº†ä¸€ä¸ªç‹¬ç«‹çš„å‘½åç©ºé—´ï¼Œå…¶ä¸­æ¯ä¸ªæ–‡ä»¶éƒ½æœ‰æ–‡ä»¶åï¼Œå¹¶ä¸”å‘½åç©ºé—´ä¸­æœ‰ä¸€ä¸ªå±‚çº§çš„ç›®å½•ï¼Œæ¯ä¸ªç›®å½•åŒ…å«äº†ä¸€äº›æ–‡ä»¶ã€‚æ‰€æœ‰è¿™äº›éƒ½è¢«æ–‡ä»¶ç³»ç»Ÿæ‰€ç®¡ç†ã€‚ Security&#x2F;Access Control: å½“ä¸€ä¸ªè¿›ç¨‹æƒ³è¦ä½¿ç”¨æŸäº›èµ„æºæ—¶ï¼Œæ¯”å¦‚è¯»å–ç£ç›˜ä¸­çš„æ•°æ®ï¼Œä½¿ç”¨æŸäº›å†…å­˜ï¼ŒKernelä¸­çš„Access Controlæœºåˆ¶ä¼šå†³å®šæ˜¯å¦å…è®¸è¿™æ ·çš„æ“ä½œã€‚å¯¹äºä¸€ä¸ªåˆ†æ—¶å…±äº«çš„è®¡ç®—æœºï¼Œä¾‹å¦‚Athenaç³»ç»Ÿï¼Œè¿™é‡Œå¯èƒ½ä¼šå˜å¾—å¾ˆå¤æ‚ã€‚å› ä¸ºåœ¨Athenaç³»ç»Ÿä¸­ï¼Œæ¯ä¸€ä¸ªè¿›ç¨‹å¯èƒ½å±äºä¸åŒçš„ç”¨æˆ·ï¼Œå› æ­¤ä¼šæœ‰ä¸åŒAccessè§„åˆ™æ¥çº¦å®šå“ªäº›èµ„æºå¯ä»¥è¢«è®¿é—®ã€‚ åœ¨ä¸€ä¸ªçœŸå®çš„å®Œå¤‡çš„æ“ä½œç³»ç»Ÿä¸­ï¼Œä¼šæœ‰å¾ˆå¤šå¾ˆå¤šå…¶ä»–çš„æœåŠ¡ï¼Œæ¯”å¦‚åœ¨ä¸åŒè¿›ç¨‹ä¹‹é—´é€šä¿¡çš„è¿›ç¨‹é—´é€šä¿¡æœåŠ¡ï¼Œæ¯”å¦‚ä¸€å¤§ç¥¨ä¸ç½‘ç»œå…³è”çš„è½¯ä»¶ï¼ˆTCP&#x2F;IPåè®®æ ˆï¼‰ï¼Œæ¯”å¦‚æ”¯æŒå£°å¡çš„è½¯ä»¶ï¼Œæ¯”å¦‚æ”¯æŒæ•°ç™¾ç§ä¸åŒç£ç›˜ï¼Œä¸åŒç½‘å¡çš„é©±åŠ¨ã€‚æ‰€ä»¥åœ¨ä¸€ä¸ªå®Œå¤‡çš„ç³»ç»Ÿä¸­ï¼ŒKernelä¼šåŒ…å«å¤§é‡çš„å†…å®¹ï¼Œæ•°ç™¾ä¸‡è¡Œä»£ç ã€‚ Kernel APIKernel APIå†³å®šäº†åº”ç”¨ç¨‹åºå¦‚ä½•è®¿é—®Kernelã€‚é€šå¸¸æ¥è¯´ï¼Œè¿™é‡Œé€šè¿‡ç³»ç»Ÿè°ƒç”¨System Callæ¥å®Œæˆã€‚ç³»ç»Ÿè°ƒç”¨ä¸ç¨‹åºä¸­çš„å‡½æ•°è°ƒç”¨çœ‹èµ·æ¥æ˜¯ä¸€æ ·çš„ï¼Œä½†åŒºåˆ«æ˜¯ç³»ç»Ÿè°ƒç”¨ä¼šå®é™…è¿è¡Œåˆ°ç³»ç»Ÿå†…æ ¸ä¸­ï¼Œå¹¶æ‰§è¡Œå†…æ ¸ä¸­å¯¹äºç³»ç»Ÿè°ƒç”¨çš„å®ç°ã€‚ Kernelçš„ä»£ç æ€»æ˜¯æœ‰ç‰¹æ®Šçš„æƒé™ã€‚å½“æœºå™¨å¯åŠ¨Kernelæ—¶ï¼ŒKernelä¼šæœ‰ç‰¹æ®Šçš„æƒé™èƒ½ç›´æ¥è®¿é—®å„ç§å„æ ·çš„ç¡¬ä»¶ï¼Œä¾‹å¦‚ç£ç›˜ã€‚è€Œæ™®é€šçš„ç”¨æˆ·ç¨‹åºæ˜¯æ²¡æœ‰åŠæ³•ç›´æ¥è®¿é—®è¿™äº›ç¡¬ä»¶çš„ã€‚æ‰€ä»¥ï¼Œå½“ä½ æ‰§è¡Œä¸€ä¸ªæ™®é€šçš„å‡½æ•°è°ƒç”¨æ—¶ï¼Œä½ æ‰€è°ƒç”¨çš„å‡½æ•°å¹¶æ²¡æœ‰å¯¹äºç¡¬ä»¶çš„ç‰¹æ®Šæƒé™ã€‚ç„¶è€Œï¼Œå¦‚æœä½ è§¦å‘ç³»ç»Ÿè°ƒç”¨åˆ°å†…æ ¸ä¸­ï¼Œå†…æ ¸ä¸­çš„å…·ä½“å®ç°ä¼šå…·æœ‰è¿™äº›ç‰¹æ®Šçš„æƒé™ï¼Œè¿™æ ·å°±èƒ½ä¿®æ”¹æ•æ„Ÿçš„å’Œè¢«ä¿æŠ¤çš„ç¡¬ä»¶èµ„æºï¼Œæ¯”å¦‚è®¿é—®ç¡¬ä»¶ç£ç›˜ã€‚ Example 112fd = open(&quot;out&quot;,1);write(fd,&quot;hello\\n&quot;,6); ç¬¬ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨openï¼Œå®ƒä¼šè·³åˆ°Kernelï¼ŒKernelä¼šè·å–åˆ°opençš„å‚æ•°ï¼Œæ‰§è¡Œä¸€äº›å®ç°äº†opençš„Kernelä»£ç ï¼Œæˆ–è®¸ä¼šä¸ç£ç›˜æœ‰ä¸€äº›äº¤äº’ï¼Œæœ€åè¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦å¯¹è±¡ã€‚ä¸Šå›¾ä¸­çš„fdå…¨ç§°å°±æ˜¯file descriptorã€‚ä¹‹ååº”ç”¨ç¨‹åºå¯ä»¥ä½¿ç”¨è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦ä½œä¸ºhandleï¼Œæ¥è¡¨ç¤ºç›¸åº”æ‰“å¼€çš„æ–‡ä»¶ã€‚ ç¬¬äºŒä¸ªç³»ç»Ÿè°ƒç”¨writeï¼Œä½ éœ€è¦å‘writeä¼ é€’ä¸€ä¸ªç”±openè¿”å›çš„æ–‡ä»¶æè¿°ç¬¦ä½œä¸ºå‚æ•°ã€‚ä½ è¿˜éœ€è¦å‘writeä¼ é€’ä¸€ä¸ªæŒ‡å‘è¦å†™å…¥æ•°æ®çš„æŒ‡é’ˆï¼ˆæ•°æ®é€šå¸¸æ˜¯charå‹åºåˆ—ï¼‰ï¼Œåœ¨Cè¯­è¨€ä¸­ï¼Œå¯ä»¥ç®€å•ä¼ é€’ä¸€ä¸ªåŒå¼•å·è¡¨ç¤ºçš„å­—ç¬¦ä¸²ã€‚ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ä½ æƒ³è¦å†™å…¥å­—ç¬¦çš„æ•°é‡ã€‚ç¬¬äºŒä¸ªå‚æ•°çš„æŒ‡é’ˆï¼Œå®é™…ä¸Šæ˜¯å†…å­˜ä¸­çš„åœ°å€ã€‚æ‰€ä»¥è¿™é‡Œå®é™…ä¸Šå‘Šè¯‰å†…æ ¸ï¼Œå°†å†…å­˜ä¸­è¿™ä¸ªåœ°å€èµ·å§‹çš„6ä¸ªå­—èŠ‚æ•°æ®å†™å…¥åˆ°fdå¯¹åº”çš„æ–‡ä»¶ä¸­ã€‚ Example 21pid = fork(); forkæ˜¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªä¸è°ƒç”¨è¿›ç¨‹ä¸€æ¨¡ä¸€æ ·çš„æ–°çš„è¿›ç¨‹ï¼Œå¹¶è¿”å›æ–°è¿›ç¨‹çš„Process ID/PIDã€‚ è¿™äº›ç³»ç»Ÿè°ƒç”¨çœ‹èµ·æ¥è·Ÿæ™®é€šçš„å‡½æ•°è°ƒç”¨ä¸€æ ·ï¼Œä½†æ˜¯å®ƒæœ€ç»ˆä¼šè·³åˆ°ç³»ç»Ÿå†…æ ¸ä¸­ã€‚ æ“ä½œç³»ç»Ÿçš„éš¾ç‚¹ å†…æ ¸çš„ç¼–ç¨‹ç¯å¢ƒæ¯”è¾ƒå›°éš¾ã€‚å½“ä½ åœ¨ç¼–å†™ã€ä¿®æ”¹ï¼Œæ‰©å±•å†…æ ¸ï¼Œæˆ–è€…å†™ä¸€ä¸ªæ–°çš„æ“ä½œç³»ç»Ÿå†…æ ¸æ—¶ï¼Œä½ å®é™…ä¸Šåœ¨æä¾›ä¸€ä¸ªåŸºç¡€è®¾æ–½è®©åˆ«äººæ¥è¿è¡Œä»–ä»¬çš„ç¨‹åºã€‚å½“ç¨‹åºå‘˜åœ¨å†™æ™®é€šçš„åº”ç”¨ç¨‹åºæ—¶ï¼Œåº”ç”¨ç¨‹åºä¸‹é¢éƒ½æ˜¯æ“ä½œç³»ç»Ÿã€‚è€Œå½“æˆ‘ä»¬åœ¨æ„å»ºæ“ä½œç³»ç»Ÿæ—¶ï¼Œåœ¨æ“ä½œç³»ç»Ÿä¸‹é¢å°±æ˜¯ç¡¬ä»¶äº†ï¼Œè¿™äº›ç¡¬ä»¶é€šå¸¸ä¼šæ›´éš¾å¤„ç†ã€‚ å½“ä½ åœ¨è®¾è®¡ä¸€ä¸ªæ“ä½œç³»ç»Ÿæ—¶ï¼Œä½ éœ€è¦æ»¡è¶³ä¸€äº›åˆ—çŸ›ç›¾çš„éœ€æ±‚ã€‚ ä½ æƒ³è¦ä½ çš„æ“ä½œç³»ç»Ÿæ—¢é«˜æ•ˆåˆæ˜“ç”¨ã€‚é«˜æ•ˆé€šå¸¸æ„å‘³ç€æ“ä½œç³»ç»Ÿéœ€è¦åœ¨ç¦»ç¡¬ä»¶è¿‘çš„low-levelè¿›è¡Œæ“ä½œï¼Œè€Œæ˜“ç”¨åˆ™è¦æ±‚æ“ä½œç³»ç»Ÿä¸ºåº”ç”¨ç¨‹åºæä¾›æŠ½è±¡çš„high-levelå¯ç§»æ¤æ¥å£ã€‚æ‰€ä»¥ï¼Œæä¾›ä¸€ä¸ªç®€å•å¯ç§»æ¤ï¼ŒåŒæ—¶åˆé«˜æ•ˆçš„æŠ½è±¡æ¥å£éœ€è¦ä¸€å®šçš„æŠ€å·§ã€‚ æˆ‘ä»¬æƒ³è¦æä¾›ä¸€ä¸ªéå¸¸å¼ºå¤§çš„æ“ä½œç³»ç»ŸæœåŠ¡ï¼Œè¿™æ ·æ“ä½œç³»ç»Ÿæ‰èƒ½åˆ†æ‹…è¿è¡Œåº”ç”¨ç¨‹åºçš„è´Ÿæ‹…ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿæƒ³è¦æœ‰ç®€å•çš„æ¥å£ã€‚æˆ‘ä»¬ä¸æƒ³ç¨‹åºå‘˜çœ‹åˆ°æ•°é‡å·¨å¤šï¼Œå¤æ‚ä¸”éš¾ä»¥ç†è§£çš„çš„å†…æ ¸æ¥å£ã€‚å› ä¸ºï¼Œå¦‚æœä»–ä»¬ä¸ç†è§£è¿™äº›æ¥å£ï¼Œä»–ä»¬å°±ä¼šå¾ˆéš¾ä½¿ç”¨è¿™äº›æ¥å£ã€‚ ä½ å¸Œæœ›ç»™ä¸åº”ç”¨ç¨‹åºå°½å¯èƒ½å¤šçš„çµæ´»æ€§ï¼Œä½ ä¸ä¼šæƒ³è¦é™åˆ¶åº”ç”¨ç¨‹åºï¼Œæ‰€ä»¥ä½ éœ€è¦å†…æ ¸å…·å¤‡çµæ´»çš„æ¥å£ã€‚ä½†æ˜¯å¦ä¸€æ–¹é¢ï¼Œä½ çš„ç¡®éœ€è¦åœ¨æŸç§ç¨‹åº¦ä¸Šé™åˆ¶åº”ç”¨ç¨‹åºï¼Œå› ä¸ºä½ ä¼šæƒ³è¦å®‰å…¨æ€§ã€‚æˆ‘ä»¬å¸Œæœ›ç»™ç¨‹åºå‘˜å®Œå…¨çš„è‡ªç”±ï¼Œä½†æ˜¯å®é™…ä¸Šåˆä¸èƒ½æ˜¯çœŸæ­£çš„å®Œå…¨è‡ªç”±ï¼Œå› ä¸ºæˆ‘ä»¬ä¸æƒ³è¦ç¨‹åºå‘˜èƒ½ç›´æ¥è®¿é—®åˆ°ç¡¬ä»¶ï¼Œå¹²æ‰°åˆ°å…¶ä»–çš„åº”ç”¨ç¨‹åºï¼Œæˆ–è€…å¹²æ‰°æ“ä½œç³»ç»Ÿçš„è¡Œä¸ºã€‚ readï¼Œwriteï¼Œexitç³»ç»Ÿè°ƒç”¨12345678910111213#inclued &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main()&#123; char buf[64]; while(1)&#123; int n = read(0,buf,sizeof(buf)); if(n &lt;= 0) break; write(1,buf,n); &#125; exit(0);&#125; readç³»ç»Ÿè°ƒç”¨ ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ–‡ä»¶æè¿°ç¬¦ï¼Œå®é™…ä¸Šæ˜¯å¯¹ä»¥å‰æ‰“å¼€æ–‡ä»¶çš„å¼•ç”¨ã€‚Shellä¼šç¡®ä¿é»˜è®¤æƒ…å†µä¸‹ï¼Œå½“ä¸€ä¸ªç¨‹åºå¯åŠ¨æ—¶ï¼Œæ–‡ä»¶æè¿°ç¬¦0ä¸ºè¿æ¥åˆ°consoleçš„è¾“å…¥ï¼Œæ–‡ä»¶æè¿°ç¬¦1ä¸ºè¿æ¥åˆ°äº†consoleçš„è¾“å‡ºã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡è¿™ä¸ªç¨‹åºçœ‹åˆ°consoleæ‰“å°æˆ‘çš„è¾“å…¥ã€‚å½“ç„¶ï¼Œè¿™é‡Œçš„ç¨‹åºä¼šé¢„æœŸæ–‡ä»¶æè¿°ç¬¦å·²ç»è¢«Shellæ‰“å¼€å¹¶è®¾ç½®å¥½ã€‚ ç¬¬äºŒä¸ªå‚æ•°æ˜¯åªæƒ³æŸæ®µå†…å­˜çš„æŒ‡é’ˆï¼Œç¨‹åºå¯ä»¥é€šè¿‡æŒ‡é’ˆå¯¹åº”çš„åœ°å€è¯»å–å†…å­˜ä¸­çš„æ•°æ®ï¼Œè¿™é‡Œçš„æŒ‡é’ˆå°±æ˜¯ä»£ç ä¸­çš„bufå‚æ•°ã€‚char buf[64]åœ¨æ ˆä¸­ç”³è¯·äº†64å­—èŠ‚çš„å†…å­˜ï¼Œå¹¶å°†æŒ‡é’ˆä¿å­˜åœ¨bufä¸­ï¼Œè¿™æ ·readå¯ä»¥å°†æ•°æ®ä¿å­˜åœ¨è¿™64å­—èŠ‚ä¸­ã€‚ ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ä»£ç æƒ³è¯»å–çš„æœ€å¤§é•¿åº¦ã€‚sizeof(buf)è¡¨ç¤ºï¼Œæœ€å¤šè¯»å–64å­—èŠ‚çš„æ•°æ®ï¼Œæ‰€ä»¥è¿™é‡Œçš„readæœ€å¤šåªèƒ½ä»è¿æ¥åˆ°æ–‡ä»¶æè¿°ç¬¦0çš„è®¾å¤‡ï¼Œä¹Ÿå°±æ˜¯consoleä¸­ï¼Œè¯»å–64å­—èŠ‚çš„æ•°æ®ã€‚ å¦‚æœç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯65å­—èŠ‚ï¼Œæ“ä½œç³»ç»Ÿä¼šæ‹·è´65ä¸ªå­—èŠ‚åˆ°ä½ æä¾›çš„å†…å­˜ä¸­ï¼ˆç¬¬äºŒä¸ªå‚æ•°ï¼‰ã€‚ä½†æ˜¯å¦‚æœæ ˆä¸­çš„ç¬¬65ä¸ªå­—èŠ‚æœ‰ä¸€äº›å…¶ä»–æ•°æ®ï¼Œé‚£ä¹ˆè¿™äº›æ•°æ®ä¼šè¢«è¦†ç›–ï¼Œè¿™é‡Œæ˜¯ä¸ªbugï¼Œæˆ–è®¸ä¼šå¯¼è‡´ä½ çš„ä»£ç å´©æºƒï¼Œæˆ–è€…ä¸€äº›å¼‚å¸¸çš„è¡Œä¸ºã€‚ readçš„è¿”å›å€¼ å¯èƒ½æ˜¯è¯»åˆ°çš„å­—èŠ‚æ•° å¦‚æœä»ä¸€ä¸ªæ–‡ä»¶è¯»æ•°æ®ï¼Œå¦‚æœåˆ°è¾¾äº†æ–‡ä»¶çš„ç»“å°¾æ²¡æœ‰æ›´å¤šçš„å†…å®¹äº†ï¼Œreadä¼šè¿”å›0ã€‚ å¦‚æœå‡ºç°äº†ä¸€äº›é”™è¯¯ï¼Œæ¯”å¦‚æ–‡ä»¶æè¿°ç¬¦ä¸å­˜åœ¨ï¼Œreadæˆ–è®¸ä¼šè¿”å›-1 ã€‚ writeç³»ç»Ÿè°ƒç”¨ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæ–‡ä»¶æè¿°ç¬¦ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯æ•°æ®çš„æŒ‡é’ˆï¼Œç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯è¦å†™å…¥çš„å­—èŠ‚æ•° æ•°æ®è¢«å†™å…¥åˆ°äº†æ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„æ–‡ä»¶ä¸­ openç³»ç»Ÿè°ƒç”¨12345678#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fcntl.h&quot;int main()&#123; int fd = open(&quot;output.txt&quot;,O_WRONLY | O_CREATE); write(fd, &quot;ooo\\n&quot;,4); exit(0);&#125; è¿™ä¸ªç¨‹åºä¼šåˆ›å»ºä¸€ä¸ªå«åšoutput.txtçš„æ–°æ–‡ä»¶ï¼Œå¹¶å‘å®ƒå†™å…¥ä¸€äº›æ•°æ®ï¼Œæœ€åé€€å‡ºã€‚æˆ‘ä»¬çœ‹ä¸åˆ°ä»»ä½•è¾“å‡ºï¼Œå› ä¸ºå®ƒåªæ˜¯å‘æ‰“å¼€çš„æ–‡ä»¶ä¸­å†™å…¥æ•°æ®ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥æŸ¥çœ‹output.txtçš„å†…å®¹ï¼Œå¹¶çœ‹åˆ°openç¨‹åºå†™å…¥çš„â€œoooâ€ã€‚ æ‰€ä»¥æ‰§è¡Œopenç³»ç»Ÿè°ƒç”¨ï¼Œå°†out.txtä½œä¸ºå‚æ•°ä¼ å…¥ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€äº›æ ‡å¿—ä½ï¼Œç”¨æ¥å‘Šè¯‰openç³»ç»Ÿè°ƒç”¨åœ¨å†…æ ¸ä¸­çš„å®ç°ï¼Œç”¨æ¥å‘Šè¯‰openç³»ç»Ÿè°ƒç”¨åœ¨å†…æ ¸ä¸­çš„å®ç°ï¼šæˆ‘ä»¬å°†è¦åˆ›å»ºå¹¶å†™å…¥ä¸€ä¸ªæ–‡ä»¶ã€‚openç³»ç»Ÿè°ƒç”¨ä¼šè¿”å›ä¸€ä¸ªæ–°åˆ†é…çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œè¿™é‡Œçš„æ–‡ä»¶æè¿°ç¬¦æ˜¯ä¸€ä¸ªå°çš„æ•°å­—ï¼Œå¯èƒ½æ˜¯2ï¼Œ3ï¼Œ4æˆ–è€…å…¶ä»–çš„æ•°å­—ã€‚ç„¶åå°†æ–‡ä»¶æè¿°ç¬¦ä¼ å…¥writeä¸­ã€‚ æ–‡ä»¶æè¿°ç¬¦æœ¬è´¨ä¸Šå¯¹åº”äº†å†…æ ¸ä¸­çš„ä¸€ä¸ªè¡¨å•æ•°æ®ã€‚å†…æ ¸ç»´æŠ¤äº†æ¯ä¸ªè¿è¡Œè¿›ç¨‹çš„çŠ¶æ€ï¼Œå†…æ ¸ä¼šä¸ºæ¯ä¸€ä¸ªè¿è¡Œè¿›ç¨‹ä¿å­˜ä¸€ä¸ªè¡¨å•ï¼Œè¡¨å•çš„keyæ˜¯æ–‡ä»¶æè¿°ç¬¦ã€‚è¿™ä¸ªè¡¨å•è®©å†…æ ¸çŸ¥é“ï¼Œæ¯ä¸ªæ–‡ä»¶æè¿°ç¬¦å¯¹åº”çš„å®é™…å†…å®¹æ˜¯ä»€ä¹ˆã€‚è¿™é‡Œæ¯”è¾ƒå…³é”®çš„ç‚¹æ˜¯ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„æ–‡ä»¶æè¿°ç¬¦ç©ºé—´ï¼Œæ‰€ä»¥å¦‚æœè¿è¡Œäº†ä¸¤ä¸ªä¸åŒçš„ç¨‹åºï¼Œå¯¹åº”ä¸¤ä¸ªä¸åŒçš„è¿›ç¨‹ï¼Œå¦‚æœå®ƒä»¬éƒ½æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œå®ƒä»¬æˆ–è®¸å¯ä»¥å¾—åˆ°ç›¸åŒæ•°å­—çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä½†æ˜¯å› ä¸ºå†…æ ¸ä¸ºæ¯ä¸ªè¿›ç¨‹éƒ½ç»´æŠ¤äº†ä¸€ä¸ªç‹¬ç«‹çš„æ–‡ä»¶æè¿°ç¬¦ç©ºé—´ï¼Œè¿™é‡Œç›¸åŒæ•°å­—çš„æ–‡ä»¶æè¿°ç¬¦å¯èƒ½ä¼šå¯¹åº”åˆ°ä¸åŒçš„æ–‡ä»¶ã€‚ Cè¯­è¨€ä¸Pythonåœ¨æ–‡ä»¶æè¿°ç¬¦ä¸­çš„åŒºåˆ«ï¼šPythonæä¾›äº†å¯¹ä¸openè°ƒç”¨çš„è¾ƒå¥½çš„å°è£…ï¼Œé€šå¸¸æ¥è¯´ï¼ŒPythonæä¾›çš„æ˜¯æ›´é«˜çº§çš„å‡½æ•°ï¼Œæ¯”å¦‚è¯´Pythonä¸ä¼šä½¿ç”¨æŒ‡å‘å†…å­˜çš„æŒ‡é’ˆï¼Œå¹¶ä¸”Pythonä¼šä¸ºä½ åšæ›´å¤šçš„é”™è¯¯æ£€æŸ¥ã€‚å½“æˆ‘ä»¬åœ¨Pythonä¸­æ‰“å¼€æ–‡ä»¶æˆ–è€…å†™å…¥æ–‡ä»¶æ—¶ï¼Œä½ åœ¨Pythonä¸­çš„è°ƒç”¨æœ€ç»ˆä¼šèµ°åˆ°è·Ÿæˆ‘ä»¬ä¾‹å­ä¸­ä¸€æ ·çš„ç³»ç»Ÿè°ƒç”¨ã€‚ ShellShellé€šå¸¸ä¹Ÿæ˜¯äººä»¬è¯´çš„å‘½ä»¤è¡Œæ¥å£ã€‚å¦‚æœä½ è¿˜æ²¡æœ‰ç”¨è¿‡Shellï¼ŒShellæ˜¯ä¸€ç§å¯¹äºUnixç³»ç»Ÿç®¡ç†æ¥è¯´éå¸¸æœ‰ç”¨çš„æ¥å£ï¼Œå®ƒæä¾›äº†å¾ˆå¤šå·¥å…·æ¥ç®¡ç†æ–‡ä»¶ï¼Œç¼–å†™ç¨‹åºï¼Œç¼–å†™è„šæœ¬ã€‚å½“ä½ è¾“å…¥å†…å®¹æ—¶ï¼Œä½ æ˜¯åœ¨å‘Šè¯‰Shellè¿è¡Œç›¸åº”çš„ç¨‹åºã€‚ 1ls lsçš„å®é™…å·¥ä½œå°±æ˜¯è¾“å‡ºå½“å‰ç›®å½•çš„æ–‡ä»¶åˆ—è¡¨ 1ls &gt; out Shellå…è®¸é‡å®šå‘IOï¼Œè¿™é‡Œçš„å®é™…æ„ä¹‰æ˜¯è¦æ±‚Shellå…è®¸lså‘½ä»¤ï¼Œä½†æ˜¯å°†è¾“å‡ºé‡å®šå‘åˆ°ä¸€ä¸ªå«åšoutçš„æ–‡ä»¶ä¸­ã€‚è¿™é‡Œæ‰§è¡Œå®Œæˆä¹‹åæˆ‘ä»¬çœ‹ä¸åˆ°ä»»ä½•çš„è¾“å‡ºï¼Œå› ä¸ºè¾“å‡ºéƒ½é€åˆ°äº†outæ–‡ä»¶ã€‚ 1cat out æˆ‘ä»¬å¯ä»¥é€šè¿‡catæŒ‡ä»¤æ¥è¯»å–ä¸€ä¸ªæ–‡ä»¶ï¼Œå¹¶æ˜¾ç¤ºæ–‡ä»¶çš„å†…å®¹ï¼Œä¹‹åæˆ‘ä»¬å¯ä»¥çœ‹åˆ°lsæŒ‡ä»¤ç›¸åŒçš„è¾“å‡ºã€‚ 1grep x ä½ ä¹Ÿå¯ä»¥è¿è¡Œä¸€ä¸ªåä¸ºgrepçš„æŒ‡ä»¤ï¼Œå¹¶å°†xä½œä¸ºå‚æ•°ä¼ ç»™grepã€‚ 1grep x &lt; out grep xä¼šæœç´¢è¾“å…¥ä¸­åŒ…å«xçš„è¡Œï¼Œæˆ‘å¯ä»¥å‘Šè¯‰shellå°†è¾“å…¥é‡å®šå‘åˆ°æ–‡ä»¶outï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æŸ¥çœ‹outä¸­çš„xã€‚å› ä¸ºoutæ–‡ä»¶åŒ…å«äº†lsçš„è¾“å‡ºï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæœ‰3ä¸ªæ–‡ä»¶ååŒ…å«äº†xã€‚ ç¼–è¯‘å™¨å¦‚ä½•å¤„ç†ç³»ç»Ÿè°ƒç”¨ï¼Ÿç”Ÿæˆçš„æ±‡ç¼–è¯­è¨€æ˜¯ä¸æ˜¯ä¼šè°ƒç”¨ä¸€äº›ç”±æ“ä½œç³»ç»Ÿå®šä¹‰çš„ä»£ç æ®µï¼Ÿ æœ‰ä¸€ä¸ªç‰¹æ®Šçš„RISC-VæŒ‡ä»¤ï¼Œç¨‹åºå¯ä»¥è°ƒç”¨è¿™ä¸ªæŒ‡ä»¤ï¼Œå¹¶å°†æ§åˆ¶æƒäº¤ç»™å†…æ ¸ã€‚æ‰€ä»¥ï¼Œå®é™…ä¸Šå½“ä½ è¿è¡ŒCè¯­è¨€å¹¶æ‰§è¡Œä¾‹å¦‚openæˆ–è€…writeçš„ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œä»æŠ€æœ¯ä¸Šæ¥è¯´ï¼Œopenæ˜¯ä¸€ä¸ªCå‡½æ•°ï¼Œä½†æ˜¯è¿™ä¸ªå‡½æ•°å†…çš„æŒ‡ä»¤å®é™…ä¸Šæ˜¯æœºå™¨æŒ‡ä»¤ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬è°ƒç”¨çš„openå‡½æ•°å¹¶ä¸æ˜¯ä¸€ä¸ªCè¯­è¨€å‡½æ•°ï¼Œå®ƒæ˜¯ç”±æ±‡ç¼–è¯­è¨€å®ç°ï¼Œç»„æˆè¿™ä¸ªç³»ç»Ÿè°ƒç”¨çš„æ±‡ç¼–è¯­è¨€å®é™…ä¸Šåœ¨RISC-Vä¸­è¢«ç§°ä¸ºecallã€‚è¿™ä¸ªç‰¹æ®Šçš„æŒ‡ä»¤å°†æ§åˆ¶æƒè½¬ç»™å†…æ ¸ã€‚ä¹‹åå†…æ ¸æ£€æŸ¥è¿›ç¨‹çš„å†…å­˜å’Œå¯„å­˜å™¨ï¼Œå¹¶ç¡®å®šç›¸åº”çš„å‚æ•°ã€‚ forkç³»ç»Ÿè°ƒç”¨123456789101112#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main()&#123; int pid; pid = fork(); printf(&quot;fork() returned %d\\n&quot;,pid); if(pid == 0)&#123; printf(&quot;child\\n&quot;); &#125; else &#123; printf(&quot;parent\\n&quot;); &#125;&#125; forkä¼šæ‹·è´å½“å‰è¿›ç¨‹çš„å†…å­˜ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œè¿™é‡Œçš„å†…å­˜åŒ…å«äº†è¿›ç¨‹çš„æŒ‡ä»¤å’Œæ•°æ®ã€‚ä¹‹åæˆ‘ä»¬å°±æœ‰äº†ä¸¤ä¸ªå®Œå…¨ä¸€æ ·çš„å†…å­˜çš„è¿›ç¨‹ã€‚forkç³»ç»Ÿè°ƒç”¨åœ¨ä¸¤ä¸ªè¿›ç¨‹ä¸­éƒ½ä¼šè¿”å›ï¼Œåœ¨åŸå§‹çš„è¿›ç¨‹ä¸­ï¼Œforkä¼šè¿”å›å¤§äº0çš„æ•´æ•°ï¼Œè¿™ä¸ªæ˜¯æ–°åˆ›å»ºè¿›ç¨‹çš„IDã€‚è€Œåœ¨æ–°åˆ›å»ºçš„è¿›ç¨‹ä¸­ï¼Œforkç³»ç»Ÿè°ƒç”¨ä¼šè¿”å›0ã€‚æ‰€ä»¥å³ä½¿ä¸¤ä¸ªè¿›ç¨‹çš„å†…å­˜æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œæˆ‘ä»¬è¿˜æ˜¯å¯ä»¥é€šè¿‡forkçš„è¿”å›å€¼åŒºåˆ†æ—§è¿›ç¨‹å’Œæ–°è¿›ç¨‹ã€‚ è¿”å› ffoorrkk(()) rreettuuttnende d 0 lc9h ilpda rent ifï¼ˆpid == 0ï¼‰ï¼Œä½ å¯ä»¥çœ‹åˆ°ä»£ç æ£€æŸ¥pidã€‚å¦‚æœpid &#x3D; 0ï¼Œè¿™å¿…ç„¶æ˜¯å­è¿›ç¨‹ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè°ƒç”¨è¿›ç¨‹é€šå¸¸ç§°ä¸ºçˆ¶è¿›ç¨‹ï¼Œçˆ¶è¿›ç¨‹çœ‹åˆ°çš„pidå¿…ç„¶å¤§äº0.æ‰€ä»¥çˆ¶è¿›ç¨‹ä¼šæ‰“å°â€œparentâ€,å­è¿›ç¨‹ä¼šæ‰“å°â€childâ€ã€‚ä¹‹åä¸¤ä¸ªè¿›ç¨‹éƒ½ä¼šé€€å‡ºã€‚ è¾“å‡ºç»“æœï¼Œå®é™…å‘ç”ŸäºŒç‚¹æ˜¯ï¼Œforkç³»ç»Ÿè°ƒç”¨ä¹‹åï¼Œä¸¤ä¸ªè¿›ç¨‹éƒ½åœ¨åŒæ—¶è¿è¡Œã€‚å®ƒä»¬ä¼šåŒæ—¶ä¸€ä¸ªå­—èŠ‚ä¸€ä¸ªå­—èŠ‚çš„è¾“å‡ºï¼Œä¸¤ä¸ªè¿›ç¨‹çš„è¾“å‡ºäº¤ç»‡åœ¨ä¸€èµ·ï¼Œæ‰€ä»¥ä½ å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªfï¼Œä¸¤ä¸ªoç­‰ç­‰ã€‚åœ¨ç¬¬ä¸€è¡Œæœ€åï¼Œä½ å¯ä»¥çœ‹åˆ°0ï¼Œè¿™æ˜¯å­è¿›ç¨‹çš„è¾“å‡ºã€‚ æˆ‘çŒœçˆ¶è¿›ç¨‹è¿”å›äº†19ï¼Œä½œä¸ºå­è¿›ç¨‹çš„è¿›ç¨‹IDã€‚é€šå¸¸æ¥è¯´ï¼Œè¿™æ„å‘³ç€è¿™æ˜¯æ“ä½œç³»ç»Ÿå¯åŠ¨ä¹‹åçš„ç¬¬19ä¸ªè¿›ç¨‹ã€‚ä¹‹åä¸€ä¸ªè¿›ç¨‹è¾“å‡ºäº†childï¼Œä¸€ä¸ªè¿›ç¨‹è¾“å‡ºäº†parentï¼Œè¿™ä¸¤ä¸ªè¾“å‡ºäº¤ç»‡åœ¨ä¸€èµ·ã€‚è™½ç„¶è¿™åªæ˜¯å¯¹äºforkçš„ä¸€ä¸ªç®€å•åº”ç”¨ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥æ¸…æ™°çš„ä»è¾“å‡ºçœ‹åˆ°è¿™é‡Œåˆ›å»ºäº†ä¸¤ä¸ªè¿è¡Œçš„è¿›ç¨‹ï¼Œå…¶ä¸­ä¸€ä¸ªè¿›ç¨‹æ‰“å°äº†childï¼Œå¦ä¸€ä¸ªæ‰“å°äº†parentã€‚æ‰€ä»¥ï¼Œforkï¼ˆåœ¨å­çˆ¶è¿›ç¨‹ä¸­ï¼‰è¿”å›ä¸åŒçš„å€¼æ˜¯æ¯”è¾ƒé‡è¦çš„ã€‚ çˆ¶è¿›ç¨‹ä¸å­è¿›ç¨‹é™¤äº†forkçš„è¿”å›å€¼ï¼Œä¸¤ä¸ªè¿›ç¨‹æ˜¯ä¸€æ ·çš„ã€‚ä¸¤ä¸ªè¿›ç¨‹çš„æŒ‡ä»¤æ˜¯ä¸€æ ·çš„ï¼Œæ•°æ®æ˜¯ä¸€æ ·çš„ï¼Œæ ˆæ˜¯ä¸€æ ·çš„ï¼ŒåŒæ—¶ï¼Œä¸¤ä¸ªè¿›ç¨‹åˆæœ‰å„è‡ªç‹¬ç«‹çš„åœ°å€ç©ºé—´ï¼Œå®ƒä»¬éƒ½è®¤ä¸ºè‡ªå·±çš„å†…å­˜ä»0å¼€å§‹å¢é•¿ï¼Œä½†è¿™é‡Œæ˜¯ä¸åŒçš„å†…å­˜ã€‚ åœ¨ä¸€ä¸ªæ›´åŠ å¤æ‚çš„æ“ä½œç³»ç»Ÿï¼Œæœ‰ä¸€äº›ç»†èŠ‚ï¼Œæˆ‘ä»¬ç°åœ¨å¹¶ä¸å…³å¿ƒï¼Œè¿™äº›ç»†èŠ‚å¶å°”ä¼šå¯¼è‡´çˆ¶å­è¿›ç¨‹ä¸ä¸€è‡´ï¼Œä½†æ˜¯åœ¨XV6ä¸­ï¼Œçˆ¶å­è¿›ç¨‹é™¤äº†forkçš„è¿”å›å€¼ï¼Œå…¶ä»–éƒ½æ˜¯ä¸€æ ·çš„ã€‚ é™¤äº†å†…å­˜æ˜¯ä¸€æ ·çš„ä»¥å¤–ï¼Œæ–‡ä»¶æè¿°ç¬¦çš„è¡¨å•ä¹Ÿä»çˆ¶è¿›ç¨‹æ‹·è´åˆ°å­è¿›ç¨‹ã€‚æ‰€ä»¥å¦‚æœçˆ¶è¿›ç¨‹æ‰“å¼€äº†ä¸€ä¸ªæ–‡ä»¶ï¼Œå­è¿›ç¨‹å¯ä»¥çœ‹åˆ°åŒä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œå°½ç®¡å­è¿›ç¨‹çœ‹åˆ°çš„æ˜¯ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦çš„è¡¨å•çš„æ‹·è´ã€‚é™¤äº†æ‹·è´å†…å­˜ä»¥å¤–ï¼Œforkè¿˜ä¼šæ‹·è´æ–‡ä»¶æè¿°ç¬¦è¡¨å•ã€‚ execï¼Œwaitç³»ç»Ÿè°ƒç”¨forkåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„è¿›ç¨‹ã€‚å½“æˆ‘ä»¬åœ¨shellä¸­è¿è¡Œä¸œè¥¿çš„æ—¶å€™ï¼Œshellå®é™…ä¸Šä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹æ¥è¿è¡Œä½ è¾“å…¥çš„æ¯ä¸€ä¸ªæŒ‡ä»¤ã€‚æ‰€ä»¥ï¼Œå½“æˆ‘è¾“å…¥lsæ—¶ï¼Œæˆ‘ä»¬éœ€è¦shellé€šè¿‡forkåˆ›å»ºä¸€ä¸ªè¿›ç¨‹æ¥è¿è¡Œlsï¼Œè¿™é‡Œéœ€è¦æŸç§æ–¹å¼æ¥è®©è¿™ä¸ªæ–°çš„è¿›ç¨‹æ¥è¿è¡Œlsç¨‹åºä¸­çš„æŒ‡ä»¤ï¼ŒåŠ è½½åä¸ºlsçš„æ–‡ä»¶ä¸­çš„æŒ‡ä»¤ï¼Œä¹Ÿå°±æ˜¯execç³»ç»Ÿè°ƒç”¨ã€‚ 12345678910// exec.c:replace a process with an executable file#include &quot;kernel.types.h&quot;#include &quot;user/user.h&quot;int main()&#123; char *argv[] = &#123; &quot;echo&quot;, &quot;this&quot;, &quot;is&quot;, &quot;echo&quot;, 0 &#125;; exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(0);&#125; ä»£ç ä¼šæ‰§è¡Œexecç³»ç»Ÿè°ƒç”¨ï¼Œè¿™ä¸ªç³»ç»Ÿè°ƒç”¨ä¼šä»æŒ‡å®šçš„æ–‡ä»¶ä¸­è¯»å–å¹¶åŠ è½½æŒ‡ä»¤ï¼Œå¹¶æ›¿ä»£å½“å‰è°ƒç”¨è¿›ç¨‹çš„æŒ‡ä»¤ã€‚ä»æŸç§ç¨‹åº¦ä¸Šæ¥è¯´ï¼Œè¿™æ ·ç›¸å½“äºä¸¢å¼ƒäº†è°ƒç”¨è¿›ç¨‹çš„å†…å­˜ï¼Œå¹¶å¼€å§‹æ‰§è¡Œæ–°åŠ è½½çš„æŒ‡ä»¤ã€‚æ‰€ä»¥ç³»ç»Ÿè°ƒç”¨execä¼šæœ‰è¿™æ ·çš„æ•ˆæœï¼šæ“ä½œç³»ç»Ÿä»åä¸ºechoçš„æ–‡ä»¶ä¸­åŠ è½½æŒ‡ä»¤åˆ°å½“å‰çš„è¿›ç¨‹ä¸­ï¼Œå¹¶æ›¿æ¢äº†å½“å‰è¿›ç¨‹çš„å†…å­˜ï¼Œä¹‹åå¼€å§‹æ‰§è¡Œè¿™äº›æ–°åŠ è½½çš„æŒ‡ä»¤ã€‚åŒæ—¶ï¼Œä½ å¯ä»¥ä¼ å…¥å‘½ä»¤è¡Œå‚æ•°ï¼Œexecå…è®¸ä½ ä¼ å…¥ä¸€ä¸ªå‘½ä»¤è¡Œå‚æ•°çš„æ•°ç»„ï¼Œè¿™é‡Œå°±æ˜¯ä¸€ä¸ªCè¯­è¨€ä¸­çš„æŒ‡é’ˆæ•°ç»„ï¼Œåœ¨ä¸Šé¢ä»£ç è®¾ç½®å¥½äº†ä¸€ä¸ªå­—ç¬¦æŒ‡é’ˆçš„æ•°ç»„ï¼Œè¿™é‡Œçš„å­—ç¬¦æŒ‡é’ˆæœ¬è´¨å°±æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆstringï¼‰ echo ç¨‹åºæ˜¯ä¸€ä¸ªå¸¸è§çš„å‘½ä»¤è¡Œå®ç”¨ç¨‹åºï¼Œç”¨äºåœ¨ Unixã€Linux å’Œç±» Unix ç³»ç»Ÿï¼ˆå¦‚ macOSï¼‰ä¸Šæ˜¾ç¤ºæ–‡æœ¬ã€‚å®ƒå°†ä¼ é€’ç»™å®ƒçš„å‘½ä»¤è¡Œå‚æ•°ï¼ˆå­—ç¬¦ä¸²ï¼‰è¾“å‡ºåˆ°æ ‡å‡†è¾“å‡ºï¼ˆé€šå¸¸æ˜¯ç»ˆç«¯æˆ–æ§åˆ¶å°ï¼‰ã€‚echo å‘½ä»¤é€šå¸¸ç”¨äºç¼–å†™è„šæœ¬æˆ–åœ¨æ§åˆ¶å°æ˜¾ç¤ºæ¶ˆæ¯ã€‚ é€šè¿‡ exec(&quot;echo&quot;, argv); ç³»ç»Ÿè°ƒç”¨æ‰§è¡Œã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œargv æ•°ç»„åŒ…å«ä»¥ä¸‹å‚æ•°ï¼š 12345argv[0] = &quot;echo&quot;argv[1] = &quot;this&quot;argv[2] = &quot;is&quot;argv[3] = &quot;echo&quot;argv[4] = NULL (ç©ºæŒ‡é’ˆ) é€šå¸¸ï¼Œargv[0] æ˜¯ç¨‹åºåç§°ï¼ˆåœ¨è¿™é‡Œæ˜¯ â€œechoâ€ï¼‰ï¼Œåé¢æ˜¯å®é™…è¦ä¼ é€’çš„å‘½ä»¤è¡Œå‚æ•°ï¼ˆåœ¨è¿™é‡Œæ˜¯ â€œthisâ€, â€œisâ€, â€œechoâ€ï¼‰ã€‚argv æ•°ç»„ä»¥ç©ºæŒ‡é’ˆï¼ˆNULLï¼‰ç»“å°¾ï¼Œè¡¨ç¤ºå‚æ•°åˆ—è¡¨çš„ç»“æŸã€‚ å½“ echo ç¨‹åºæ‰§è¡Œæ—¶ï¼Œå®ƒä¼šè¾“å‡º &quot;this is echo&quot;ã€‚ execç³»ç»Ÿè°ƒç”¨ä¼šä¿ç•™å½“å‰çš„æ–‡ä»¶æè¿°ç¬¦è¡¨å•ã€‚æ‰€ä»¥ä»»ä½•åœ¨execç³»ç»Ÿè°ƒç”¨ä¹‹å‰çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä¾‹å¦‚0ï¼Œ1ï¼Œ2ç­‰ã€‚å®ƒä»¬åœ¨æ–°çš„ç¨‹åºä¸­è¡¨ç¤ºç›¸åŒçš„ä¸œè¥¿ã€‚ é€šå¸¸æ¥è¯´execç³»ç»Ÿè°ƒç”¨ä¸ä¼šè¿”å›ï¼Œå› ä¸ºexecä¼šå®Œå…¨æ›¿æ¢å½“å‰è¿›ç¨‹çš„å†…å­˜ï¼Œç›¸å½“äºå½“å‰è¿›ç¨‹ä¸å¤å­˜åœ¨äº†ï¼Œæ‰€ä»¥execç³»ç»Ÿè°ƒç”¨å·²ç»æ²¡æœ‰åœ°æ–¹èƒ½è¿”å›äº†,åœ¨å®ä¾‹ä»£ç ä¸­ï¼Œæ‰§è¡Œé”™è¯¯æ‰ä¼šè¿”å›ã€‚ è¿™å°±æ˜¯ä¸€ä¸ªç¨‹åºå¦‚ä½•ç”¨æ–‡ä»¶ä¸­çš„å¦ä¸€ä¸ªç¨‹åºæ¥æ›¿ä»£è‡ªå·±ã€‚å®é™…ä¸Šï¼Œå½“æˆ‘ä»¬åœ¨Shellä¸­è¿è¡Œç±»ä¼¼äºâ€œecho a b câ€çš„æŒ‡ä»¤ï¼Œæˆ–è€…lsï¼Œæˆ–è€…ä»»ä½•å‘½ä»¤ï¼Œæˆ‘ä»¬ä¸ä¼šæƒ³è¦ä»£æ›¿Shellè¿›ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šå¸Œæœ›Shellæ‰§è¡Œexecç³»ç»Ÿè°ƒç”¨ã€‚å¦‚æœæˆ‘ä»¬è¿™ä¹ˆåšäº†ï¼Œè¿™é‡Œä¼šç”¨echoæŒ‡ä»¤æ¥æ›¿ä»£Shellè¿›ç¨‹ï¼Œå½“echoé€€å‡ºäº†ï¼Œä¸€åˆ‡å°±ç»“æŸäº†ã€‚æ‰€ä»¥æˆ‘ä»¬ä¸æƒ³è¦echoæ›¿ä»£Shellã€‚å®é™…ä¸Šï¼ŒShellä¼šæ‰§è¡Œforkï¼Œä¹‹åforkå‡ºçš„å­è¿›ç¨‹å†è°ƒç”¨execç³»ç»Ÿè°ƒç”¨ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸å¸¸è§çš„Unixç¨‹åºè°ƒç”¨é£æ ¼ã€‚å¯¹äºé‚£äº›æƒ³è¦è¿è¡Œç¨‹åºï¼Œä½†æ˜¯è¿˜å¸Œæœ›èƒ½æ‹¿å›æ§åˆ¶æƒçš„åœºæ™¯ï¼Œå¯ä»¥å…ˆæ‰§è¡Œforkç³»ç»Ÿè°ƒç”¨ï¼Œç„¶ååœ¨å­è¿›ç¨‹ä¸­è°ƒç”¨execã€‚ 1234567891011121314151617181920// forkexec.c: fork then exec#include &quot;user/user.h&quot;int main()&#123; int pid, status; pid = fork(); if(pid == 0) &#123; char *argv[] = &#123;&quot;echo&quot; ,&quot;THIS&quot; ,&quot;IS&quot; ,&quot;ECHO&quot;, 0 &#125;; exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(1); &#125;else &#123; printf(&quot;parent waiting\\n&quot;); wait(&amp;status); printf(&quot;the child exited with status %d\\n&quot;,status); &#125; exit(0);&#125; forkç³»ç»Ÿè°ƒç”¨ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å­è¿›ç¨‹ï¼Œæ˜¯å½“å‰è¿›ç¨‹çš„ä¸€ä¸ªå‰¯æœ¬ã€‚ å¦‚æœpid == 0ï¼Œå³è¿›ç¨‹æ˜¯å­è¿›ç¨‹ï¼Œåˆ™ä¼šè°ƒç”¨echoç¨‹åºï¼Œè¾“å‡º&quot;THIS IS ECHO&quot;ï¼Œå¦‚æœé”™è¯¯åˆ™è¿”å›1ã€‚å¹¶ä¸”å­è¿›ç¨‹åœ¨echoç¨‹åºæ‰§è¡Œç»“æŸä¹‹åå°±ä¼šé€€å‡ºã€‚ï¼Œä¹‹åç»§ç»­è¿›è¡Œçˆ¶è¿›ç¨‹ã€‚ çˆ¶è¿›ç¨‹ä¼šå…ˆè¾“å‡ºâ€œparent waiting\\nâ€ï¼Œä¹‹åä½¿ç”¨waitç³»ç»Ÿè°ƒç”¨ï¼Œç­‰å¾…å­è¿›ç¨‹è¿”å›ï¼Œå°†å­è¿›ç¨‹è¿”å›çš„çŠ¶æ€ä¼ å…¥statusï¼Œ&amp;statusï¼Œæ˜¯å°†statuså¯¹åº”çš„åœ°å€ä¼ é€’ç»™å†…æ ¸ï¼Œå†…æ ¸ä¼šå‘è¿™ä¸ªåœ°å€å†™å…¥å­è¿›ç¨‹å‘exitä¼ å…¥çš„å‚æ•°ã€‚ å¦‚æœä¸€ä¸ªå­è¿›ç¨‹é€€å‡ºæˆåŠŸäº†ï¼Œé‚£ä¹ˆexitçš„å‚æ•°ä¼šæ˜¯0ï¼Œå¦‚æœå‡ºç°äº†é”™è¯¯ï¼Œä¼šå‘exitä¼ å…¥1ã€‚æ‰€ä»¥çˆ¶è¿›ç¨‹è¯»å–çš„waitçš„å‚æ•°å–å†³äºå­è¿›ç¨‹æ˜¯å¦æˆåŠŸçš„å®Œæˆäº†ã€‚ I&#x2F;O Redirect1echo hello &gt; out Shellä¼šå°†echoçš„è¾“å‡ºé€åˆ°æ–‡ä»¶out 1cat &lt; out ä¹‹åå¯ä»¥è¿è¡ŒcatæŒ‡ä»¤ï¼Œå¹¶å°†outæŒ‡ä»¤ä½œä¸ºè¾“å…¥ï¼Œä¹‹åä¿å­˜åœ¨outæ–‡ä»¶ä¸­çš„å†…å®¹å°±æ˜¯echoæŒ‡ä»¤çš„è¾“å‡º Shellé¦–å…ˆä¼šå…ˆforkç„¶ååœ¨å­è¿›ç¨‹ä¸­ï¼ŒShellæ”¹å˜äº†æ–‡ä»¶æè¿°ç¬¦ã€‚æ–‡ä»¶æè¿°ç¬¦1ç”¨æ¥consoleè¾“å‡ºï¼ŒShellä¼šå°†æ–‡ä»¶æè¿°ç¬¦1æ”¹ä¸ºoutputæ–‡ä»¶ï¼Œä¹‹åå†è¿è¡Œä½ çš„æŒ‡ä»¤ã€‚åŒæ—¶ï¼Œçˆ¶è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦1å¹¶æ²¡æœ‰æ”¹å˜ã€‚æ‰€ä»¥è¿™é‡Œå…ˆforkå†æ”¹å˜å­è¿›ç¨‹çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ 123456789101112131415161718//redirect.c: run a command with output redirectedint main()&#123; int pid; pid = fork(); if(pid == 0) &#123; close(1); open(&quot;output.txt, O_WRONLY|O_CREATE&quot;); char *argv[] = &#123;&quot;echo&quot;, &quot;this&quot; ,&quot;is&quot; ,&quot;redirect&quot;, &quot;echo&quot;, 0 &#125;; exec(&quot;echo&quot;,argv); printf(&quot;exec failed!\\n&quot;) &#125; else &#123; wait((int *) 0); &#125;&#125; åœ¨if(pid == 0)ä¸­ï¼Œå…ˆæ£€æŸ¥pidçš„å€¼ï¼Œå¦‚æœpidä¸º0ï¼ˆåœ¨å­è¿›ç¨‹ä¸­ï¼‰ï¼Œåˆ™é¦–å…ˆclose(1),close(1)çš„æ„ä¹‰æ˜¯ï¼Œæˆ‘ä»¬å¸Œæœ›æ–‡ä»¶æè¿°ç¬¦1æŒ‡å‘ä¸€ä¸ªå…¶ä»–çš„ä½ç½®ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨å­è¿›ç¨‹ä¸­æˆ‘ä»¬ä¸æƒ³ä½¿ç”¨åŸæœ¬æŒ‡å‘consoleè¾“å‡ºçš„æ–‡ä»¶æè¿°ç¬¦1ï¼Œå³å…³é—­æ ‡å‡†è¾“å‡ºã€‚ ä½¿ç”¨ open(&quot;output.txt&quot;, O_WRONLY | O_CREAT, 0666); æ‰“å¼€æˆ–åˆ›å»ºåä¸º â€œoutput.txtâ€ çš„æ–‡ä»¶ï¼Œä»¥åªå†™æ¨¡å¼ï¼ˆO_WRONLYï¼‰æ‰“å¼€ï¼Œå¹¶è®¾ç½®åˆ›å»ºæ¨¡å¼ï¼ˆ0666ï¼Œè¡¨ç¤ºæ‰€æœ‰ç”¨æˆ·éƒ½å¯ä»¥è¯»å†™æ­¤æ–‡ä»¶ï¼‰ã€‚è¿™å°†ä½¿å¾—æ–°æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦æˆä¸ºå­è¿›ç¨‹çš„æ ‡å‡†è¾“å‡ºã€‚ ä½¿ç”¨ exec(&quot;echo&quot;, argv); ç³»ç»Ÿè°ƒç”¨ï¼Œæ›¿æ¢å­è¿›ç¨‹çš„æ˜ åƒä¸º echo ç¨‹åºï¼Œå¹¶ä¼ é€’ argv å‚æ•°åˆ—è¡¨ã€‚ å¦‚æœ exec è°ƒç”¨å¤±è´¥ï¼Œè¾“å‡º â€œexec failed!â€ã€‚ åœ¨çˆ¶è¿›ç¨‹ä¸­ï¼Œè°ƒç”¨ wait((int *)0); å‡½æ•°ï¼Œç­‰å¾…å­è¿›ç¨‹ç»“æŸã€‚ å½“è¿è¡Œæ­¤ç¨‹åºæ—¶ï¼Œå®ƒå°†æ‰§è¡Œ echo å‘½ä»¤ï¼Œå¹¶å°†è¾“å‡º â€œthis is redirect echoâ€ é‡å®šå‘åˆ° â€œoutput.txtâ€ æ–‡ä»¶ã€‚å¦‚æœæ–‡ä»¶å·²å­˜åœ¨ï¼Œå®ƒå°†è¦†ç›–ç°æœ‰å†…å®¹ï¼›å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œå®ƒå°†åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ã€‚","categories":[{"name":"è¯¾ç¨‹å­¦ä¹ ","slug":"è¯¾ç¨‹å­¦ä¹ ","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"è¯¾ç¨‹å­¦ä¹ /MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"è®ºæ–‡é˜…è¯» A Study on the Security Implications of Information Leakages in Container Clouds","slug":"è®ºæ–‡é˜…è¯» A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds","date":"2023-03-30T14:40:21.000Z","updated":"2023-04-15T05:07:00.036Z","comments":true,"path":"2023/03/30/è®ºæ–‡é˜…è¯» A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/","link":"","permalink":"http://example.com/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/","excerpt":"æ‘˜è¦Container technologyæä¾›äº†ä¸€ä¸ªè½»é‡çº§çš„æ“ä½œç³»ç»Ÿè™šæ‹Ÿä¸»æœºç¯å¢ƒã€‚Container technologyçš„å‡ºç°æ·±åˆ»çš„æ”¹å˜äº†å¤šå±‚åˆ†å¸ƒå¼åº”ç”¨çš„å¼€å‘å’Œéƒ¨ç½²èŒƒå¼ï¼ˆparadigms of multi-tier distributed applicationsï¼‰ã€‚ç„¶è€Œï¼Œç”±äºLinuxç³»ç»Ÿå†…æ ¸ä¸­çš„ç³»ç»Ÿèµ„æºéš”ç¦»æœºåˆ¶æ²¡æœ‰å®Œå…¨å®ç°ï¼ˆsystem resource isolation mechanismsï¼‰ï¼Œåœ¨ä¸€ä¸ªåŸºäºcontainerçš„å¤šç§Ÿæˆ·äº‘æœåŠ¡ï¼ˆmulti-tenancy container-based cloud serviceï¼‰ä¸­ï¼Œä¸€äº›å®‰å…¨é—®é¢˜ä»ç„¶å­˜åœ¨ã€‚åœ¨æœ¬æ–‡ï¼Œæˆ‘ä»¬é¦–å…ˆä»‹ç»äº†å¯ä»¥åœ¨containerså†…è®¿é—®çš„ä¿¡æ¯æ³„éœ²æ¸ é“ã€‚è¿™äº›æ¸ é“æš´éœ²äº†ä¸€ç³»åˆ—çš„ç³»ç»ŸèŒƒå›´çš„ä¸»æœºä¿¡æ¯ç»™æ²¡æœ‰é€‚å½“èµ„æºåˆ†åŒºçš„containersã€‚é€šè¿‡åˆ©ç”¨æ³„éœ²çš„ä¸»æœºä¿¡æ¯ï¼Œä½œä¸ºç§Ÿæˆ·åœ¨container cloudä¸­çš„æ¶æ„çš„æ”»å‡»è€…å°±ä¼šæ›´å®¹æ˜“çš„å‘èµ·å¯èƒ½å½±å“äº‘æœåŠ¡çš„å¯é æ€§çš„å®‰å…¨æ”»å‡»ã€‚æˆ‘ä»¬è¯æ˜äº†ä¿¡æ¯æ³„éœ²æ¸ é“å°†ä¼šè¢«åˆ©ç”¨äºæ¨æ–­éšç§æ•°æ®ï¼Œæ£€æµ‹å’ŒéªŒè¯co-residenceï¼Œå»ºç«‹éšè”½é€šé“ï¼Œå‘åŠ¨æ›´é«˜çº§çš„åŸºäºäº‘çš„æ”»å‡»ã€‚æˆ‘ä»¬è®¨è®ºäº†containerä¸­çš„ä¿¡æ¯æ³„éœ²çš„æ ¹æœ¬åŸå› ï¼Œå¹¶æå‡ºäº†ä¸€ä¸ªä¸¤é˜¶æ®µçš„é˜²å¾¡æ–¹æ³•ã€‚æ­£å¦‚è¯„ä¼°ä¸­æ‰€è¯æ˜çš„ï¼Œæˆ‘ä»¬çš„é˜²å¾¡æ˜¯æœ‰æ•ˆçš„ï¼Œå¹¶ä¸”æ€§èƒ½å¼€é”€éå¸¸å°ã€‚ Introduction","text":"æ‘˜è¦Container technologyæä¾›äº†ä¸€ä¸ªè½»é‡çº§çš„æ“ä½œç³»ç»Ÿè™šæ‹Ÿä¸»æœºç¯å¢ƒã€‚Container technologyçš„å‡ºç°æ·±åˆ»çš„æ”¹å˜äº†å¤šå±‚åˆ†å¸ƒå¼åº”ç”¨çš„å¼€å‘å’Œéƒ¨ç½²èŒƒå¼ï¼ˆparadigms of multi-tier distributed applicationsï¼‰ã€‚ç„¶è€Œï¼Œç”±äºLinuxç³»ç»Ÿå†…æ ¸ä¸­çš„ç³»ç»Ÿèµ„æºéš”ç¦»æœºåˆ¶æ²¡æœ‰å®Œå…¨å®ç°ï¼ˆsystem resource isolation mechanismsï¼‰ï¼Œåœ¨ä¸€ä¸ªåŸºäºcontainerçš„å¤šç§Ÿæˆ·äº‘æœåŠ¡ï¼ˆmulti-tenancy container-based cloud serviceï¼‰ä¸­ï¼Œä¸€äº›å®‰å…¨é—®é¢˜ä»ç„¶å­˜åœ¨ã€‚åœ¨æœ¬æ–‡ï¼Œæˆ‘ä»¬é¦–å…ˆä»‹ç»äº†å¯ä»¥åœ¨containerså†…è®¿é—®çš„ä¿¡æ¯æ³„éœ²æ¸ é“ã€‚è¿™äº›æ¸ é“æš´éœ²äº†ä¸€ç³»åˆ—çš„ç³»ç»ŸèŒƒå›´çš„ä¸»æœºä¿¡æ¯ç»™æ²¡æœ‰é€‚å½“èµ„æºåˆ†åŒºçš„containersã€‚é€šè¿‡åˆ©ç”¨æ³„éœ²çš„ä¸»æœºä¿¡æ¯ï¼Œä½œä¸ºç§Ÿæˆ·åœ¨container cloudä¸­çš„æ¶æ„çš„æ”»å‡»è€…å°±ä¼šæ›´å®¹æ˜“çš„å‘èµ·å¯èƒ½å½±å“äº‘æœåŠ¡çš„å¯é æ€§çš„å®‰å…¨æ”»å‡»ã€‚æˆ‘ä»¬è¯æ˜äº†ä¿¡æ¯æ³„éœ²æ¸ é“å°†ä¼šè¢«åˆ©ç”¨äºæ¨æ–­éšç§æ•°æ®ï¼Œæ£€æµ‹å’ŒéªŒè¯co-residenceï¼Œå»ºç«‹éšè”½é€šé“ï¼Œå‘åŠ¨æ›´é«˜çº§çš„åŸºäºäº‘çš„æ”»å‡»ã€‚æˆ‘ä»¬è®¨è®ºäº†containerä¸­çš„ä¿¡æ¯æ³„éœ²çš„æ ¹æœ¬åŸå› ï¼Œå¹¶æå‡ºäº†ä¸€ä¸ªä¸¤é˜¶æ®µçš„é˜²å¾¡æ–¹æ³•ã€‚æ­£å¦‚è¯„ä¼°ä¸­æ‰€è¯æ˜çš„ï¼Œæˆ‘ä»¬çš„é˜²å¾¡æ˜¯æœ‰æ•ˆçš„ï¼Œå¹¶ä¸”æ€§èƒ½å¼€é”€éå¸¸å°ã€‚ Introductionäº‘è®¡ç®—å·²ç»å¹¿æ³›çš„è¿ç”¨äºæ•´åˆè®¡ç®—æœºèµ„æºã€‚å¤šç§Ÿæˆ·æ˜¯äº‘è®¡ç®—çš„æœ‰åˆ©ç‰¹å¾ï¼Œå…è®¸æ¥è‡ªä¸åŒç§Ÿæˆ·çš„è®¡ç®—å®ä¾‹åœ¨åŒä¸€ç‰©ç†æœåŠ¡å™¨ä¸Šè¿è¡Œã€‚åœ¨ä¸åŒç±»å‹çš„äº‘æœåŠ¡ä¸­ï¼Œå¤šç§Ÿæˆ·å®¹å™¨äº‘æœ€è¿‘ä½œä¸ºä¼ ç»Ÿçš„ä»¥äº‘åŸºç¡€è®¾æ–½ä¸ºåŸºç¡€çš„è™šæ‹ŸæœºVMçš„è½»é‡çº§æ›¿ä»£å“å‡ºç°ã€‚å®¹å™¨æ˜¯ä¸€ç§OSçº§çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œåœ¨Linuxå†…æ ¸ä¸­æœ‰å¤šä¸ªbuilding blocksï¼ŒåŒ…æ‹¬èµ„æºéš”ç¦»&#x2F;æ§åˆ¶æŠ€æœ¯ï¼ˆå¦‚namespaceå’Œcgroupï¼‰å’Œå®‰å…¨æœºåˆ¶ï¼ˆå¦‚Capabilitiesï¼ŒSELinuxï¼ŒAppArmorå’Œseccompï¼‰ã€‚é€šè¿‡é¿å…additional abstraction layersçš„å¼€é”€ï¼Œå®¹å™¨èƒ½å¤Ÿå®ç°æ¥è¿‘åŸç”Ÿçš„æ€§èƒ½ï¼Œå¹¶ä¸”åœ¨å‡ ä¹æ‰€æœ‰æ–¹é¢éƒ½è¶…è¿‡äº†åŸºäºè™šæ‹Ÿæœºçš„ç³»ç»Ÿã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå®¹å™¨ç®¡ç†å’Œorchestrationç³»ç»Ÿçš„å‡ºç°ï¼Œå¦‚Dockerå’ŒKubernetesï¼Œæ·±åˆ»çš„æ”¹å˜äº†åœ¨äº‘ä¸Šæ„å»ºã€è¿è¾“å’Œéƒ¨ç½²å¤šå±‚åˆ†å¸ƒå¼åº”ç”¨çš„ç”Ÿæ€ç³»ç»Ÿã€‚ å°½ç®¡å®¹å™¨æœåŠ¡å¾ˆæˆåŠŸï¼Œä½†æ˜¯åœ¨åŒä¸€ä¸ªæ“ä½œç³»ç»Ÿå†…æ ¸ä¸Šè¿è¡Œå¤šä¸ªå¯èƒ½å±äºä¸åŒç§Ÿæˆ·çš„å®¹å™¨ï¼Œå§‹ç»ˆå­˜åœ¨å®‰å…¨å’Œéšç§é—®é¢˜ã€‚ä¸ºäº†æ”¯æŒå®¹å™¨äº‘ä¸Šçš„å¤šç§Ÿæˆ·ï¼ŒLinuxå†…æ ¸æ­£åœ¨è¿›è¡Œè·¨å®¹å™¨éš”ç¦»å’Œå–æ¶ˆç‰¹æƒç”¨æˆ·çº§åˆ«å®¹å™¨çš„åŠªåŠ›ã€‚ç°æœ‰çš„å®¹å™¨å¯ç”¨å†…æ ¸åŠŸèƒ½å¤§å¤§ç¼©å°äº†æš´éœ²ç»™å®¹å™¨ç§Ÿæˆ·çš„æ”»å‡»é¢ï¼Œå¹¶ä¸”å¯ä»¥é™åˆ¶å¤§å¤šæ•°ç°æœ‰çš„æ¶æ„æ”»å‡»ã€‚ç„¶è€Œï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰çš„Linuxå†…æ ¸çš„å­ç³»ç»Ÿéƒ½èƒ½å¤ŸåŒºåˆ†å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œå› æ­¤å®ƒä»¬å¯èƒ½ä¼šå‘å®¹å™¨åŒ–åº”ç”¨ç¨‹åºå…¬å¼€ç³»ç»ŸèŒƒå›´çš„ä¿¡æ¯ã€‚ä¸€äº›å­ç³»ç»Ÿè¢«è®¤ä¸ºå¯¹å®¹å™¨é€‚åº”æ€§çš„ä¼˜å…ˆçº§è¾ƒä½ã€‚å…¶ä½™çš„å­ç³»ç»Ÿé¢ä¸´ç€å°†ä»£ç åº“è½¬æ¢æˆå®¹å™¨å½¢å¼çš„å®ç°å›°éš¾ï¼Œå¹¶ä¸”å®ƒä»¬çš„ç»´æŠ¤è€…ä¸æ„¿æ„æ¥å—æ¿€çƒˆçš„å˜åŒ–ã€‚ä¸ºäº†å…³é—­è¿™äº›æ¼æ´ï¼Œå½“å‰å®¹å™¨è¿è¡Œæ—¶è½¯ä»¶å’Œå®¹å™¨äº‘æä¾›å•†é€šå¸¸åˆ©ç”¨è®¿é—®æ§åˆ¶ç­–ç•¥æ¥éšè—è¿™äº›ä¸å®¹å™¨æ— å…³çš„å­ç³»ç»Ÿç”¨æˆ·å†…æ ¸æ¥å£ã€‚ç„¶è€Œï¼Œè¿™ç§æ‰‹åŠ¨å’Œä¸´æ—¶ä¿®å¤åªèƒ½è¦†ç›–ä¸€å°éƒ¨åˆ†æš´éœ²å‡ºæ¥çš„æ”»å‡»é¢ã€‚ åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬ç³»ç»Ÿåœ°æ¢ç´¢å’Œè¯†åˆ«å¯èƒ½æ„å¤–æš´éœ²ä¸»æœºæ“ä½œç³»ç»Ÿå’Œco-residenceå®¹å™¨ä¿¡æ¯çš„å®¹å™¨å†…æ³„æ¼é€šé“ã€‚è¿™äº›ä¿¡æ¯æ³„æ¼åŒ…æ‹¬ä¸»æœºç³»ç»ŸçŠ¶æ€ä¿¡æ¯ï¼ˆä¾‹å¦‚åŠŸè€—ã€æ€§èƒ½æ•°æ®ã€å…¨å±€å†…æ ¸æ•°æ®å’Œå¼‚æ­¥å†…æ ¸äº‹ä»¶ï¼‰ä»¥åŠå•ä¸ªè¿›ç¨‹æ‰§è¡Œä¿¡æ¯ï¼ˆä¾‹å¦‚è¿›ç¨‹è°ƒåº¦ã€cgroups å’Œè¿›ç¨‹è¿è¡ŒçŠ¶æ€ï¼‰ã€‚åœ¨ç‰¹å®šæ—¶é—´ç‚¹æš´éœ²çš„åŒºåˆ†ç‰¹å¾ä¿¡æ¯å¯ä»¥å¸®åŠ©å”¯ä¸€åœ°è¯†åˆ«ç‰©ç†æœºå™¨ã€‚æ­¤å¤–ï¼Œæ¶æ„ç§Ÿæˆ·å¯ä»¥é€šè¿‡æå‰è·å–ç³»ç»ŸèŒƒå›´çš„çŸ¥è¯†æ¥ä¼˜åŒ–æ”»å‡»ç­–ç•¥å¹¶æœ€å¤§åŒ–æ”»å‡»æ•ˆæœã€‚æˆ‘ä»¬åœ¨ Docker å’Œ LinuX å®¹å™¨ (LXC) ä¸Šçš„æœ¬åœ°æµ‹è¯•å¹³å°ä¸Šå‘ç°äº†è¿™äº›æ³„æ¼é€šé“ï¼Œå¹¶éªŒè¯äº†å®ƒä»¬åœ¨äº”ä¸ªå…¬å…±å•†ä¸šå¤šç§Ÿæˆ·å®¹å™¨äº‘æœåŠ¡ä¸Šï¼ˆéƒ¨åˆ†ï¼‰å­˜åœ¨ã€‚ æˆ‘ä»¬è¯æ˜äº†é‚£äº›ä¿¡æ¯æ³„éœ²æ¸ é“å­˜åœ¨å¤šä¸ªå®‰å…¨éšæ‚£ã€‚æ€»çš„æ¥è¯´ï¼Œå°½ç®¡è¢«æŒ‚è½½ä¸ºåªè¯»ï¼Œè¿™äº›é€šé“ä»ç„¶ä¼šè¢«æ¶æ„çš„å®¹å™¨ç§Ÿæˆ·åˆ©ç”¨æ¥æ¨æ–­åŒä¸€ç‰©ç†æœºä¸Šå…¶ä»–å®¹å™¨çš„ç§æœ‰æ•°æ®ï¼Œæ£€æµ‹å’ŒéªŒè¯å…±å­˜å…³ç³»ï¼Œå¹¶å»ºç«‹éšè”½é€šé“ä»¥å·å·åœ°ä¼ è¾“ä¿¡æ¯ã€‚æˆ‘ä»¬æå‡ºäº†å‡ ç§æŠ€æœ¯ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡åˆ©ç”¨é‚£äº›ä¿¡æ¯æ³„éœ²æ¸ é“æ¥æ¨æ–­co-residenceã€‚ä¸åŸºäºç¼“å­˜çš„éšè”½ä¿¡é“ç­‰ä¼ ç»Ÿæ–¹æ³•ç›¸æ¯”ï¼Œæˆ‘ä»¬çš„æ–¹æ³•å¯¹äº‘ç¯å¢ƒä¸­çš„å™ªå£°æ›´å…·éŸ§æ€§ã€‚æˆ‘ä»¬æ ¹æ®å®ƒä»¬çš„é£é™©ç­‰çº§å¯¹è¿™äº›é€šé“è¿›è¡Œæ’åã€‚æˆ‘ä»¬å‘ç°åœ¨å®¹å™¨å®ä¾‹ä¸­çš„æ´»åŠ¨ä¼šå½±å“å¤šä¸ªé€šé“çš„ç³»ç»ŸèŒƒå›´çš„å†…çš„valuesã€‚é€šè¿‡å¯¹è¿è¡Œåœ¨å®¹å™¨ä¸­çš„å·¥ä½œè´Ÿè½½è¿›è¡Œä¸“é—¨æ“ä½œï¼Œæ”»å‡»è€…å¯ä»¥å®ç°å¯é å’Œé«˜é€Ÿçš„éšè”½é€šé“ï¼Œä»¥çªç ´äº‘éƒ¨ç½²ä¸­é‡‡ç”¨çš„éš”ç¦»æœºåˆ¶ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡æ•…æ„è·å–å’Œé‡Šæ”¾é”è€Œä¸äº§ç”Ÿç½‘ç»œæ´»åŠ¨ï¼Œä»è€Œæ”»å‡»è€…å¯ä»¥åœ¨å®¹å™¨ä¹‹é—´éšè”½çš„ä¼ è¾“æ¯”ç‰¹ã€‚è¿™äº›æ³„éœ²çš„ä¿¡æ¯å¯ä»¥è¢«åŒä¸€ç‰©ç†æœºä¸Šçš„æ‰€æœ‰å®¹å™¨è§‚å¯Ÿåˆ°ã€‚ä¸ºäº†æ­ç¤ºè¿™äº›æ³„æ¼é€šé“çš„å®‰å…¨é£é™©ï¼Œæˆ‘ä»¬é‡‡ç”¨ä¸åŒæŠ€æœ¯æ„å»ºäº†ä¸¤ä¸ªéšè”½é€šé“ï¼Œå¹¶åœ¨çœŸå®çš„å¤šç§Ÿæˆ·äº‘ç¯å¢ƒä¸­æµ‹è¯•å®ƒä»¬çš„å¸¦å®½ã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥è®¾è®¡å‡ºäº†ä¸€ç§å…ˆè¿›çš„æ”»å‡»ï¼Œç§°ä¸ºsynergistic power attackï¼Œæ¥åˆ©ç”¨é€šè¿‡è¿™äº›é€šé“çš„çœ‹ä¼¼æ— å®³çš„ä¿¡æ¯ã€‚æˆ‘ä»¬è¯æ˜è¿™æ ·çš„ä¿¡æ¯æš´éœ²å¯ä»¥æå¤§åœ°æ”¾å¤§æ”»å‡»æ•ˆæœï¼Œé™ä½æ”»å‡»æˆæœ¬ï¼Œç®€åŒ–æ”»å‡»ç¼–æ’ã€‚power attackså·²è¢«è¯æ˜å¯¹ç°æœ‰çš„æ•°æ®ä¸­å¿ƒæœ‰äº‹å®çš„å¨èƒã€‚å¦‚æœæ²¡æœ‰åŸºç¡€äº‘æ¶æ„è¿è¡ŒçŠ¶æ€çš„ä¿¡æ¯ï¼Œç°æœ‰çš„power attackåªèƒ½ç›²ç›®çš„å¯åŠ¨power-intensive workloadsï¼Œå¸Œæœ›é«˜å³°èƒ½å¤Ÿè§¦å‘branch circuit breakersæ¥å¯¼è‡´power outagesã€‚è¿™æ ·çš„æ”»å‡»å¯èƒ½costlyå¹¶ä¸”ineffectiveã€‚ ç„¶è€Œï¼Œé€šè¿‡å­¦ä¹ ç³»ç»ŸèŒƒå›´å†…çš„çŠ¶æ€ä¿¡æ¯ï¼Œæ”»å‡»è€…å¯ä»¥é€‰æ‹© é€‰æ‹©æœ€ä½³æ—¶æœºå‘åŠ¨æ”»å‡»ï¼Œä¹Ÿå°±æ˜¯ï¼Œåœ¨ç°æœ‰çš„powerå³°å€¼ä¸‹ï¼Œç”±benign workloadsè§¦å‘ï¼Œé€šè¿‡å¢åŠ power-intensive workloadæ¥è¿›è¡Œæ”»å‡»ã€‚ é€šè¿‡æ£€æµ‹è¢«æ§åˆ¶çš„å®¹å™¨çš„proximity-residenceï¼ŒåŒæ­¥å¯¹åŒä¸€ç‰©ç†æœº&#x2F;æœºæ¶çš„å¤šæ¬¡power attacksã€‚æˆ‘ä»¬åœ¨ä¸€ä¸ªçœŸå®çš„å®¹å™¨äº‘æœåŠ¡ä¸Šè¿›è¡Œäº†proof-of-conceptå®éªŒ ï¼Œå¹¶å®šé‡è¯æ˜äº†æˆ‘ä»¬çš„æ”»å‡»èƒ½å¤Ÿä»¥æ›´ä½çš„æˆæœ¬äº§ç”Ÿæ›´é«˜çš„powerå³°å€¼ã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥æ·±å…¥åˆ†æäº†è¿™äº›æ³„æ¼æ¸ é“çš„æ ¹æœ¬åŸå› ï¼Œå¹¶å‘ç°æ˜¯Linuxå†…æ ¸ä¸­å®¹å™¨implementationçš„incomplete coverageæ‰€è‡´ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªä¸¤é˜¶æ®µçš„é˜²å«æœºåˆ¶æ¥è§£å†³è¿™ä¸ªåœ¨å®¹å™¨äº‘ä¸Šçš„é—®é¢˜ã€‚ç‰¹åˆ«æ˜¯ï¼Œä¸ºäº†é˜²å«synergistic power attacksï¼Œæˆ‘ä»¬è®¾è®¡å¹¶å®ç°äº†ä¸€ä¸ªpower-based namespaceï¼Œåœ¨Linuxå†…æ ¸ä¸­å¯¹powerè¿›è¡Œæ›´ç»†ç²’åº¦ï¼ˆå®¹å™¨ï¼‰çº§åˆ«çš„åˆ’åˆ†ã€‚æˆ‘ä»¬å’Œå‡†ç¡®æ€§ï¼Œå®‰å…¨æ€§å’Œæ€§èƒ½å¼€é”€çš„è§’åº¦è¯„ä¼°äº†æˆ‘ä»¬çš„power-based namespaceã€‚æˆ‘ä»¬çš„å®éªŒç»“æœè¡¨æ˜ï¼Œæˆ‘ä»¬çš„ç³»ç»Ÿå¯ä»¥åœ¨å¾ˆå°çš„ç³»ç»Ÿå¼€é”€ä¸‹æŠµå¾¡container-based power attackã€‚ BackgroundLinux Kernel Support for Container Technologyå®¹å™¨ä¾èµ–äºå¤šä¸ªç‹¬ç«‹çš„Linuxå†…æ ¸ç»„ä»¶æ¥å®ç°ç”¨æˆ·ç©ºé—´å®ä¾‹ä¹‹é—´çš„éš”ç¦»ã€‚ä¸åŸºäºè™šæ‹Ÿæœºçš„è™šæ‹ŸåŒ–æ–¹æ³•ç›¸æ¯”ï¼Œå¤šä¸ªå®¹å™¨å…±äº«åŒä¸€ä¸ªæ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œä»è€Œæ¶ˆé™¤äº†å¯åŠ¨å’Œç»´æŠ¤è™šæ‹Ÿæœºæ‰€éœ€çš„é¢å¤–æ€§èƒ½å¼€é”€ã€‚å®¹å™¨åœ¨ä¸šç•Œå—åˆ°äº†å¹¿æ³›å…³æ³¨ï¼Œå¹¶åœ¨è¿‘å¹´æ¥è¿…é€Ÿå‘å±•ï¼Œä»¥æé«˜åº”ç”¨ç¨‹åºæ€§èƒ½ã€å¢å¼ºå¼€å‘äººå‘˜æ•ˆç‡å’Œä¿ƒè¿›æœåŠ¡éƒ¨ç½²ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬ä»‹ç»ä¸¤ç§å…³é”®æŠ€æœ¯namespaceå’Œcgroupï¼Œå®ƒä»¬ä½¿å¾—Linuxä¸Šçš„å®¹å™¨åŒ–æˆä¸ºå¯èƒ½ã€‚ Namespaceç¬¬ä¸€ä¸ªnamespaceåœ¨Linuxå†…æ ¸2.4.19ä¸­è¢«å¼•å…¥ã€‚namespaceçš„å…³é”®æ€æƒ³æ˜¯ä¸ºä¸€ç»„è¿›ç¨‹éš”ç¦»å’Œè™šæ‹ŸåŒ–ç³»ç»Ÿèµ„æºï¼Œè¿™äº›å½¢æˆä¸€ä¸ªå®¹å™¨ã€‚æ¯ä¸ªè¿›ç¨‹å¯ä»¥ä¸å¤šä¸ªä¸åŒç±»å‹çš„namespaceè”ç³»ã€‚å†…æ ¸ä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›äº†ä¸€ä¸ªåŸºäºnamespaceç±»å‹çš„å®šåˆ¶åŒ–ç³»ç»Ÿèµ„æºè§†å›¾ã€‚å¯¹ä»»ä½•namespaceç³»ç»Ÿèµ„æºçš„ä¿®æ”¹éƒ½ä¼šè¢«é™åˆ¶åœ¨ç›¸å…³è”çš„namespaceé‡Œé¢ï¼Œå› æ­¤ä¸ä¼šé€ æˆæ•´ä¸ªç³»ç»ŸèŒƒå›´å†…çš„ä¿®æ”¹ã€‚ ç°æœ‰çš„å†…æ ¸æœ‰ä¸ƒç§ä¸åŒçš„namespaceï¼šmountï¼ˆMNTï¼‰namespaceï¼ŒUNIX timesharing system ï¼ˆUTSï¼‰namespaceï¼ŒPIDnamespaceï¼Œ networkï¼ˆNETï¼‰ namespaceï¼Œinterprocess communicationsï¼ˆIPCï¼‰namespaceï¼ŒUSER namespaceï¼Œand CGOUP namespace MNT namespaceï¼šéš”ç¦»ä¸€ç»„æ–‡ä»¶ç³»ç»Ÿmount pointã€‚åœ¨ä¸åŒçš„MNT namespaceä¸­ï¼Œè¿›ç¨‹å¯¹æ–‡ä»¶ç³»ç»Ÿå±‚æ¬¡ç»“æ„æœ‰ä¸åŒçš„è§†å›¾ã€‚ UTS namespaceï¼šæ¯ä¸ªå®¹å™¨éƒ½æœ‰è‡ªå·±çš„ä¸»æœºåå’ŒåŸŸåï¼Œå› æ­¤ä¸€ä¸ªå®¹å™¨å¯ä»¥è¢«è§†ä¸ºç‹¬ç«‹èŠ‚ç‚¹ã€‚ PID namespaceï¼šè™šæ‹ŸåŒ–è¿›ç¨‹æ ‡è¯†ç¬¦ï¼ˆpidsï¼‰ï¼Œæ¯ä¸ªè¿›ç¨‹æœ‰ä¸¤ä¸ªpidï¼šåœ¨å…¶namespaceä¸­æœ‰ä¸€ä¸ªpidï¼Œåœ¨ä¸»æœºä¸Šæœ‰ä¸€ä¸ªï¼ˆå…¨å±€å”¯ä¸€ï¼‰pidã€‚ NET namespaceï¼šåŒ…å«ç‹¬ç«‹çš„è™šæ‹Ÿç½‘ç»œè®¾å¤‡ã€IPåœ°å€ã€ç«¯å£å’ŒIPè·¯ç”±è¡¨ã€‚IPCå‘½åç©ºé—´éš”ç¦»äº†è¿›ç¨‹é—´é€šä¿¡èµ„æºï¼ŒåŒ…æ‹¬ä¿¡å·ã€ç®¡é“å’Œå…±äº«å†…å­˜ã€‚ IPC namespaceï¼šéš”ç¦»è¿›ç¨‹é—´é€šä¿¡èµ„æºï¼ŒåŒ…æ‹¬ä¿¡å·ã€ç®¡é“å’Œå…±äº«å†…å­˜ã€‚ USER namespaceï¼šå¼•å…¥äº†ç”¨æˆ·å’Œç»„IDå·ç©ºé—´çš„éš”ç¦»ã€‚å®ƒåœ¨å®¹å™¨å†…åˆ›å»ºä¸€ä¸ªæ ¹ç”¨æˆ·åˆ°ä¸»æœºä¸Šéç‰¹æƒç”¨æˆ·ä¹‹é—´çš„æ˜ å°„å…³ç³»ã€‚å› æ­¤ï¼Œè¿›ç¨‹å¯ä»¥åœ¨ç”¨æˆ·å‘½åç©ºé—´å†…æ‹¥æœ‰å®Œå…¨æƒé™ï¼Œä½†åœ¨ä¸»æœºä¸Šåˆ™è¢«å‰Šå¼±äº†æƒé™ã€‚ CGROUP namespaceï¼šè™šæ‹ŸåŒ–cgroupèµ„æºï¼Œæ¯ä¸ªè¿›ç¨‹åªèƒ½é€šè¿‡cgroupfsæŒ‚è½½å’Œ/proc/self/cgroupæ–‡ä»¶è·å¾—å®¹å™¨åŒ–çš„cgroupè§†å›¾ã€‚ Cgroupåœ¨Linuxå†…æ ¸ä¸­ï¼Œcgroupï¼ˆcontrol groupï¼‰æä¾›äº†ä¸€ç§æœºåˆ¶ï¼Œå°†è¿›ç¨‹å’Œæ‰€æœ‰å®ƒä»¬çš„å­è¿›ç¨‹çš„groupåˆ†å±‚ä¸ºå…·æœ‰å¯æ§è¡Œä¸ºçš„åˆ†å±‚groupã€‚å®¹å™¨åˆ©ç”¨cgroupåŠŸèƒ½ï¼Œå¯¹æ¯ä¸ªå®¹å™¨å®ä¾‹åº”ç”¨æ¯ä¸ªcgroupèµ„æºé™åˆ¶ï¼Œä»è€Œé˜²æ­¢å•ä¸ªå®¹å™¨è€—å°½ä¸»æœºèµ„æºã€‚è¿™äº›å—æ§èµ„æºåŒ…æ‹¬CPUã€å†…å­˜ã€å—IOã€ç½‘ç»œç­‰ã€‚åœ¨äº‘è®¡ç®—çš„è®¡è´¹æ¨¡å‹ä¸­ï¼Œcgroupä¹Ÿå¯ä»¥ç”¨äºä¸ºæ¯ä¸ªå®¹å™¨åˆ†é…ç›¸åº”çš„èµ„æºå¹¶è®°å½•å®ƒä»¬çš„ä½¿ç”¨æƒ…å†µã€‚æ¯ä¸ªcgroupå­ç³»ç»Ÿæä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„sysfsæ¥å£ï¼Œä»¥ç®€åŒ–ç”¨æˆ·ç©ºé—´ä¸­çš„cgroupæ“ä½œã€‚ Container Cloudæœ‰äº†è¿™äº›å¯ç”¨äºèµ„æºéš”ç¦»å’Œç®¡ç†çš„å†…æ ¸åŠŸèƒ½ï¼ŒLinux å†…æ ¸å¯ä»¥åœ¨æ“ä½œç³»ç»Ÿçº§åˆ«æä¾›è½»é‡çº§è™šæ‹ŸåŒ–åŠŸèƒ½ã€‚æœªæ¥é¢„è®¡ä¼šå°†æ›´å¤šçš„namespaceå’Œ cgroup å­ç³»ç»Ÿåˆå¹¶åˆ°upstream Linux å†…æ ¸ä¸­ï¼Œä»¥å¢å¼ºå®¹å™¨å®‰å…¨æ€§ã€‚è¿‘å¹´æ¥ï¼Œéšç€å®¹å™¨è¿è¡Œæ—¶è½¯ä»¶çš„æˆç†Ÿï¼Œå®¹å™¨åŒ–å·²æˆä¸ºè™šæ‹Ÿæ‰˜ç®¡çš„æµè¡Œé€‰æ‹©ã€‚LXC æ˜¯ç¬¬ä¸€ä¸ªå®Œæ•´å®ç°äº 2008 å¹´æ„å»ºçš„ Linux å®¹å™¨ç®¡ç†å™¨ã€‚Docker å»ºç«‹åœ¨ LXCï¼ˆç°åœ¨ä½¿ç”¨ libcontainerï¼‰ä¹‹ä¸Šï¼Œåœ¨æœ€è¿‘å‡ å¹´å·²æˆä¸ºæœ€å—æ¬¢è¿çš„å®¹å™¨ç®¡ç†å·¥å…·ã€‚Docker å¯ä»¥å°†åº”ç”¨ç¨‹åºåŠå…¶ä¾èµ–é¡¹ï¼ˆä¾‹å¦‚ä»£ç ã€è¿è¡Œæ—¶ã€ç³»ç»Ÿå·¥å…·å’Œç³»ç»Ÿåº“ï¼‰æ‰“åŒ…åˆ°é•œåƒä¸­ï¼Œä»è€Œä¿è¯åº”ç”¨ç¨‹åºåœ¨ä¸åŒå¹³å°ä¸Šè¡¨ç°ä¸€è‡´ã€‚è®¸å¤šäº‘æœåŠ¡æä¾›å•†å·²ç»æä¾›äº†å®¹å™¨äº‘æœåŠ¡ï¼Œå…¶ä¸­åŒ…æ‹¬ Amazon ECSã€IBM Bluemixã€Microsoft Azure å’Œ Google Compute Engine ç­‰ç­‰ã€‚å¯¹äºå¤šç§Ÿæˆ·å®¹å™¨äº‘æœåŠ¡æ¥è¯´ï¼Œå®¹å™¨å¯ä»¥è¿è¡Œåœ¨è£¸æœºç‰©ç†æœºæˆ–è™šæ‹Ÿæœºä¸Šã€‚æ— è®ºæ˜¯å“ªç§æƒ…å†µä¸‹ï¼Œä¸åŒç§Ÿæˆ·çš„å®¹å™¨éƒ½ä¸ä¸»æœºæ“ä½œç³»ç»Ÿå…±äº«ç›¸åŒçš„ Linux å†…æ ¸ã€‚ Covert Channelséšè”½é€šé“åˆ©ç”¨å…±äº«èµ„æºæ¥æ‰“ç ´éš”ç¦»æœºåˆ¶ï¼Œä»è€Œä½¿å­¤ç«‹çš„å®ä½“ä¹‹é—´èƒ½å¤Ÿè¿›è¡Œé€šä¿¡ã€‚å…·æœ‰éšç§˜æ€§çš„éšè”½é€šé“å¯ç”¨äºæ£€ç´¢æ•æ„Ÿä¿¡æ¯å¹¶ç»•è¿‡æ ‡å‡†é€šé“ä¸Šçš„è®¿é—®æ§åˆ¶ã€‚å¹¿æ³›è®¤ä¸ºï¼Œå³ä½¿åœ¨è™šæ‹Ÿæœºå’Œå®¹å™¨å¼ºåˆ¶æ‰§è¡Œéš”ç¦»æŠ€æœ¯çš„æƒ…å†µä¸‹ï¼Œä»Šå¤©çš„äº‘ç¯å¢ƒä¹Ÿå®¹æ˜“å—åˆ°éšè”½é€šé“æ”»å‡»ã€‚å·²ç»æå‡ºäº†å„ç§æŠ€æœ¯æ¥å»ºç«‹å¤šç§Ÿæˆ·äº‘ç¯å¢ƒä¸­çš„éšè”½é€šé“ã€‚Ristenpartç­‰äººæŠ¥å‘Šäº†åœ¨å…¬å…±äº‘ä¸­åˆ©ç”¨å…±äº«L2æ•°æ®ç¼“å­˜è¾¾åˆ°0.2bps çš„æ¯”ç‰¹ç‡ã€‚Xuç­‰äººä½¿ç”¨VMä¹‹é—´çš„æœ€åä¸€çº§ç¼“å­˜ï¼Œåœ¨Amazon EC2 ç¯å¢ƒä¸­æ„å»ºå¸¦å®½ä¸º3.2bps çš„éšè—ä¿¡é“ã€‚Wuç­‰äººé€šè¿‡åˆ©ç”¨å†…å­˜æ€»çº¿ä¸Šå‘ç”Ÿç«äº‰å®ç°110 bps å’Œè¯¯ç ç‡ä¸º0.75% çš„éšè—ä¿¡é“ã€‚Mastiç­‰äººæˆåŠŸåœ°é€šè¿‡è·å–èŠ¯ç‰‡ä¼ æ„Ÿå™¨è¯»æ•°æ¥æ„å»ºéšè—ä¿¡é“ï¼Œå¹¶ä»¥12.5bps çš„æ¯”ç‰¹ç‡è¿›è¡Œä¼ è¾“ï¼›Bartoliniç­‰äººå°†åŸºäºæ¸©åº¦çš„éšè—ä¿¡é“æ”¹è¿›è‡³ç›¸é‚»æ ¸å¿ƒ50bps ã€‚åœ¨äº‘ç¯å¢ƒä¸­ï¼Œé™¤äº†æ³„éœ²æ•æ„Ÿæ•°æ®çš„å¨èƒå¤–ï¼Œéšè”½é€šé“è¿˜å¯ä»¥è¿›ä¸€æ­¥è¢«æ»¥ç”¨æ¥æ£€æµ‹å’ŒéªŒè¯å…±å­˜æ€§ï¼Œè¿™æ˜¯å¤§å¤šæ•°åŸºäºäº‘çš„æ”»å‡»çš„å‰ææ¡ä»¶ã€‚é€šè¿‡æˆåŠŸåœ°é€šè¿‡éšè”½é€šé“ä¼ è¾“ä¿¡æ¯ï¼Œæ”»å‡»è€…å¯ä»¥ç¡®è®¤ä¸¤ä¸ªå®ä¾‹æ˜¯å¦åœ¨åŒä¸€ä¸»æœºæœåŠ¡å™¨ä¸Šco-residenceã€‚å› æ­¤ï¼Œä¸ºäº†é€šè¿‡æ„å»ºå¼ºå¤§çš„é˜²å¾¡æœºåˆ¶æ¥ä¿æŠ¤äº‘ç«¯å®‰å…¨ï¼Œå‘ç°æ–°æŠ€æœ¯ä»¥æ„å»ºéšè”½é€šé“æ˜¯ä¸€ä¸ªé‡è¦æ­¥éª¤ï¼Œå¹¶å·²ç»å¾—åˆ°å…ˆå‰ç ”ç©¶çš„å¯†åˆ‡å…³æ³¨ã€‚ Power Attacks on Data Centerspower attackså·²ç»è¢«è¯æ˜å¯¹ç°æœ‰çš„äº‘åŸºç¡€è®¾æ–½æœ‰äº‹å®çš„å¨èƒã€‚è€ƒè™‘åˆ°å‡çº§powerè®¾æ–½çš„æˆæœ¬ï¼Œå½“å‰æ•°æ®ä¸­å¿ƒæ™®éé‡‡ç”¨power oversubscriptionæ¥åœ¨ç°æœ‰ç”µåŠ›ä¾›åº”èƒ½åŠ›èŒƒå›´å†…æ‰˜ç®¡å°½å¯èƒ½å¤šçš„æœåŠ¡å™¨ã€‚å®‰å…¨ä¿éšœæ˜¯åŸºäºè¿™æ ·ä¸€ä¸ªå‡è®¾ï¼šç›¸é‚»çš„å¤šä¸ªæœåŠ¡å™¨åŒæ—¶è¾¾åˆ°å³°å€¼åŠŸè€—çš„æ¦‚ç‡å¾ˆä½ã€‚è™½ç„¶åŠŸç‡è¶…é¢è®¢é˜…å…è®¸éƒ¨ç½²æ›´å¤šæœåŠ¡å™¨è€Œä¸å¢åŠ ç”µæºå®¹é‡ï¼Œä½†é™ä½äº†ç”µæºå†—ä½™æ€§ï¼Œå¢åŠ äº†åœç”µå¯èƒ½æ€§ï¼Œè¿™å¯èƒ½å¯¼è‡´åŒä¸€æœºæ¶æˆ–åŒä¸€é…ç”µå•å…ƒï¼ˆPDUï¼‰ä¸Šçš„æœåŠ¡å™¨è¢«è¿«å…³é—­ã€‚å³ä½¿æ­£å¸¸å·¥ä½œè´Ÿè½½ä¹Ÿå¯èƒ½äº§ç”Ÿå¼•èµ·åœç”µçš„åŠŸç‡å³°å€¼ã€‚Facebookæœ€è¿‘æŠ¥å‘Šç§°ï¼Œåœ¨2016å¹´çš„å…­ä¸ªæœˆå†…é¢„é˜²äº†18æ¬¡æ½œåœ¨åœç”µäº‹ä»¶ã€‚å¦‚æœæ¶æ„å¯¹æ‰‹æ•…æ„æŠ•æ”¾â€œèƒ½é‡ç—…æ¯’â€å‘åŠ¨æ”»å‡»ï¼Œåˆ™æƒ…å†µå°†æ›´ä¸ºä¸¥é‡ã€‚åœç”µå¸¦æ¥çš„åæœå¯èƒ½æ˜¯ç¾éš¾æ€§çš„ï¼Œä¾‹å¦‚Delta Airlinesåœ¨2016å¹´8æœˆé­é‡æ•°æ®ä¸­å¿ƒæ–­ç”µäº‹ä»¶ï¼Œå¯¼è‡´å¤§è§„æ¨¡èˆªç­å»¶è¯¯å’Œå–æ¶ˆã€‚æœ€è¿‘ç ”ç©¶è¡¨æ˜ï¼Œæ— è®ºæ˜¯ä¼ ç»Ÿè¿˜æ˜¯å¤‡ç”¨å¼æ•°æ®ä¸­å¿ƒéƒ½å¯ä»¥è¿›è¡Œ power æ”»å‡»ã€‚ å‘èµ·ä¸€ä¸ªæˆåŠŸçš„power attack éœ€è¦ä¸‰ä¸ªå…³é”®å› ç´ ï¼š é€šè¿‡åˆæ³•è®¢é˜…æœåŠ¡å¾—åˆ°ç›®æ ‡æ•°æ®ä¸­å¿ƒçš„æœåŠ¡å™¨è®¿é—®æƒé™ ç¨³å®šçš„è¿è¡Œé€‚åº¦çš„å·¥ä½œè´Ÿè½½ï¼Œä»¥å¢åŠ æœåŠ¡å™¨åŠŸè€—è‡³å…¶ä¸Šé™ã€‚ çªç„¶åˆ‡æ¢åˆ°è€—ç”µé‡å¤§çš„å·¥ä½œè´Ÿè½½ä»¥è§¦å‘åŠŸç‡å³°å€¼ã€‚é€šè¿‡åœ¨çŸ­æ—¶é—´çª—å£å†…å¼•èµ·åŠŸç‡å³°å€¼ï¼Œæ–­è·¯å™¨å¯ä»¥è¢«è·³é—¸ä»¥ä¿æŠ¤æœåŠ¡å™¨å…å—è¿‡æµæˆ–è¿‡è½½é€ æˆçš„ç‰©ç†æŸå®³ã€‚ æ–­è·¯å™¨çš„è·³é—¸æ¡ä»¶å–å†³äºpowerå³°å€¼çš„å¼ºåº¦å’ŒæŒç»­æ—¶é—´ã€‚ä¸ºäº†æœ€å¤§åŒ–æ”»å‡»æ•ˆæœï¼Œæ”»å‡»è€…éœ€è¦åœ¨åŒä¸€æœºæ¶æˆ–è€…PDUæ‰€å±çš„ä¸€ç»„æœåŠ¡å™¨ä¸Šè¿è¡Œæ¶æ„å·¥ä½œè´Ÿè½½ã€‚æ­¤å¤–ï¼Œå‘åŠ¨æ”»å‡»çš„æ—¶æœºä¹Ÿè‡³å…³é‡è¦ã€‚å¦‚æœæ•°æ®ä¸­å¿ƒçš„ç‰¹å®šçš„ä¸€ç»„æœåŠ¡å™¨ï¼ˆä¾‹å¦‚ï¼Œä½äºåŒä¸€æœºæ¶ä¸Šï¼‰å·²ç»è¿è¡Œåœ¨å…¶å³°å€¼åŠŸç‡çŠ¶æ€ä¸‹ï¼Œåˆ™å‘åŠ¨æˆåŠŸçš„power attackçš„å¯èƒ½æ€§æ›´é«˜ã€‚ power é™åˆ¶æŠ€æœ¯æ—¨åœ¨é˜²å¾¡power attackã€‚åœ¨æœºæ¶å’ŒPDUçº§åˆ«ä¸Šï¼Œé€šè¿‡ç›‘æ§poweræ¶ˆè€—ï¼Œæ•°æ®ä¸­å¿ƒå¯ä»¥é€šè¿‡åŸºäºåŠŸç‡çš„åé¦ˆç¯è·¯é™åˆ¶æœåŠ¡å™¨çš„åŠŸè€—ã€‚åœ¨ä¸»æœºçº§åˆ«ä¸Šï¼ŒRunning Average Power Limit(RAPL)æ˜¯ä¸€ç§ç”¨äºç›‘è§†å’Œé™åˆ¶å•ä¸ªæœåŠ¡å™¨åŠŸè€—çš„æŠ€æœ¯ã€‚è‡ªSandy Bridgeå¾®ä½“ç³»ç»“æ„ä»¥æ¥ï¼ŒIntelå¼•å…¥äº†RAPLã€‚å®ƒæä¾›å¾®ç§’çº§ç»†ç²’åº¦CPUçº§èƒ½æºè®¡é‡ï¼Œå¹¶å¯ç”¨äºé™åˆ¶ä¸€ä¸ªåŒ…çš„åŠŸè€—ã€‚ poweré™åˆ¶æœºåˆ¶æ˜¾è‘—ç¼©å°äº†åŠŸç‡æ”»å‡»é¢ï¼Œä½†å®ƒæ— æ³•è§£å†³power oversubscriptionçš„é—®é¢˜ï¼Œè¿™æ˜¯æ•°æ®ä¸­å¿ƒåœç”µçš„æ ¹æœ¬åŸå› ã€‚è™½ç„¶å•ä¸ªæœåŠ¡å™¨çš„ä¸»æœºçº§åŠŸç‡é™åˆ¶å¯ä»¥ç«‹å³å“åº”power surfaceï¼Œä½†æœºæ¶æˆ–PDUçº§åˆ«çš„åŠŸç‡é™åˆ¶æœºåˆ¶ä»ä¼šé­å—åˆ†é’Ÿçº§å»¶è¿Ÿã€‚å‡è®¾æ”»å‡»è€…å¯ä»¥å°†ç”µæºç—…æ¯’éƒ¨ç½²åˆ°ç‰©ç†ç›¸é‚»çš„æœåŠ¡å™¨ä¸­ï¼Œå³ä½¿æ¯ä¸ªæœåŠ¡å™¨æ¶ˆè€—çš„ç”µåŠ›ä½äºå…¶åŠŸç‡ä¸Šé™ï¼Œæ‰€æ§åˆ¶æœåŠ¡å™¨æ€»ä½“èšåˆåçš„èƒ½é‡æ¶ˆè€—ä»å¯èƒ½è¶…è¿‡ä¾›ç”µå®¹é‡å¹¶è§¦å‘æ–­è·¯å™¨ã€‚æˆ‘ä»¬åœ¨ä»¥ä¸‹ç« èŠ‚ä¸­è¯æ˜æ¶æ„å®¹å™¨ç§Ÿæˆ·å¯ä»¥é€šè¿‡æ§åˆ¶å…¶é«˜èƒ½è€—å·¥ä½œè´Ÿè½½çš„éƒ¨ç½²å’Œåˆ©ç”¨èƒŒæ™¯ä¸‹è‰¯æ€§å·¥ä½œè´Ÿè½½æ¥æ”¾å¤§ä»–ä»¬çš„power attackã€‚ Information Leakages In Container CloudsLinuxå†…æ ¸ä¸ºå®¹å™¨æŠ½è±¡æä¾›äº†å¤§é‡æ”¯æŒä»¥å®ç°èµ„æºéš”ç¦»å’Œæ§åˆ¶ã€‚è¿™äº›å†…æ ¸æœºåˆ¶æ˜¯åœ¨å¤šç§Ÿæˆ·äº‘ä¸Šè¿è¡Œå®¹å™¨çš„å¯ç”¨æŠ€æœ¯ã€‚ç”±äºä¼˜å…ˆçº§å’Œå›°éš¾ç¨‹åº¦ï¼ŒLinuxå†…æ ¸çš„æŸäº›ç»„ä»¶å°šæœªè½¬åŒ–ä¸ºæ”¯æŒå®¹å™¨åŒ–ã€‚æˆ‘ä»¬æ‰“ç®—ç³»ç»Ÿåœ°æ¢ç´¢å“ªäº›éƒ¨åˆ†çš„å†…æ ¸æ²¡æœ‰è¦†ç›–ï¼Œæ ¹æœ¬åŸå› æ˜¯ä»€ä¹ˆä»¥åŠæ½œåœ¨å¯¹æ‰‹å¦‚ä½•åˆ©ç”¨å®ƒä»¬ã€‚ Container Information Leakagesæˆ‘ä»¬é¦–å…ˆåœ¨æœ¬åœ°å®‰è£…äº†Dockerå’ŒLXCå®¹å™¨ï¼Œå¹¶åœ¨Linuxæœºå™¨ä¸Šè¿›è¡Œå®éªŒã€‚ç³»ç»Ÿè®¾ç½®ä¸ºé»˜è®¤é…ç½®ï¼Œæ‰€æœ‰å®¹å™¨éƒ½ä»¥ç”¨æˆ·ç‰¹æƒå¯åŠ¨ï¼Œä¸å•†ä¸šå®¹å™¨äº‘ç±»ä¼¼ã€‚Linuxæä¾›äº†ä¸¤ç§ä»ç”¨æˆ·ç©ºé—´è¿›ç¨‹åˆ°å†…æ ¸çš„å—æ§æ¥å£ï¼šç³»ç»Ÿè°ƒç”¨å’ŒåŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿã€‚ç³»ç»Ÿè°ƒç”¨ä¸»è¦è®¾è®¡ç”¨äºç”¨æˆ·è¿›ç¨‹è¯·æ±‚å†…æ ¸æœåŠ¡ã€‚è¿™äº›ç³»ç»Ÿè°ƒç”¨å…·æœ‰ä¸¥æ ¼çš„å…¬å…±æ¥å£å®šä¹‰ï¼Œå¹¶é€šå¸¸å‘åå…¼å®¹ã€‚ç„¶è€Œï¼ŒåŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿæ›´çµæ´»ï¼Œå¯æ‰©å±•å†…æ ¸åŠŸèƒ½ï¼ˆä¾‹å¦‚ioctlï¼‰ï¼Œè®¿é—®å†…æ ¸æ•°æ®ï¼ˆä¾‹å¦‚procfsï¼‰å¹¶è°ƒæ•´å†…æ ¸å‚æ•°ï¼ˆä¾‹å¦‚sysctlï¼‰ã€‚æ­¤å¤–ï¼Œè¿™æ ·çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿä½¿å¾—é€šè¿‡æ­£å¸¸æ–‡ä»¶I&#x2F;Oæ“ä½œæ“çºµå†…æ ¸æ•°æ®æˆä¸ºå¯èƒ½ã€‚Linuxæœ‰è®¸å¤šåŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿï¼ˆä¾‹å¦‚ï¼Œprocfsã€sysfsã€devfsã€securityfsã€debugfsç­‰ï¼‰ï¼Œè¿™äº›æ–‡ä»¶ç³»ç»ŸæœåŠ¡äºä¸åŒçš„å†…æ ¸æ“ä½œç›®çš„ã€‚æˆ‘ä»¬æ›´æ„Ÿå…´è¶£çš„æ˜¯procfså’Œsysfsï¼Œé»˜è®¤æƒ…å†µä¸‹ç”±å®¹å™¨è¿è¡Œæ—¶è½¯ä»¶æŒ‚è½½ã€‚ å¦‚å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªäº¤å‰éªŒè¯å·¥å…·ï¼Œè‡ªåŠ¨å‘ç°è¿™äº›å°†ä¸»æœºä¿¡æ¯æš´éœ²ç»™å®¹å™¨çš„åŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ã€‚å…³é”®æ€æƒ³æ˜¯åœ¨ä¸¤ä¸ªæ‰§è¡Œä¸Šä¸‹æ–‡ä¸­é€’å½’æ¢ç´¢procfså’Œsysfsä¸‹æ‰€æœ‰ä¼ªæ–‡ä»¶ï¼Œåœ¨ä¸€ä¸ªæœªç»ç‰¹æƒå¤„ç†çš„å®¹å™¨ä¸­è¿è¡Œï¼Œå¹¶åœ¨ä¸»æœºä¸Šè¿è¡Œå¦ä¸€ä¸ªã€‚æˆ‘ä»¬æ ¹æ®å®ƒä»¬çš„è·¯å¾„å¯¹é½å¹¶é‡æ–°æ’åºè¿™äº›æ–‡ä»¶ï¼Œç„¶åå¯¹ç›¸åŒå†…å®¹ä¹‹é—´è¿›è¡Œæˆå¯¹å·®åˆ†åˆ†æã€‚å¦‚æœä»ç‰¹å®šè™šæ‹Ÿæ–‡ä»¶è®¿é—®åˆ°çš„ç³»ç»Ÿèµ„æºæ²¡æœ‰è¢«Linuxå†…æ ¸namespaceåŒ–ï¼Œåˆ™ä¸»æœºå’Œå®¹å™¨ä¼šè¾¾åˆ°ç›¸åŒç‰‡æ®µï¼ˆå¦‚å›¾ä¸­â·çš„æƒ…å†µï¼‰ã€‚å¦åˆ™ï¼Œå¦‚æœæ­£ç¡®namespaceåŒ–ï¼Œåˆ™å®¹å™¨å¯ä»¥æ£€ç´¢åˆ°è‡ªå·±çš„ç§æœ‰å’Œå®šåˆ¶å†…æ ¸æ•°æ®ï¼ˆå¦‚å›¾ä¸­â¶çš„æƒ…å†µï¼‰ã€‚ä½¿ç”¨è¿™ä¸ªäº¤å‰éªŒè¯å·¥å…·ï¼Œæˆ‘ä»¬å¯ä»¥å¿«é€Ÿè¯†åˆ«å¯èƒ½å°†ç³»ç»ŸèŒƒå›´ä¸»æœºä¿¡æ¯æš´éœ²ç»™å®¹å™¨çš„ä¼ªæ–‡ä»¶ï¼ˆåŠå…¶å†…éƒ¨å†…æ ¸æ•°æ®ç»“æ„ï¼‰ã€‚ Leakage Channel Analysisæˆ‘ä»¬åœ¨è¡¨ä¸­åˆ—å‡ºäº†å¯èƒ½æ³„éœ²ä¸»æœºä¿¡æ¯çš„æ‰€æœ‰ä¼ªæ–‡ä»¶ã€‚è¿™äº›æ³„æ¼æ¸ é“åŒ…å«ä¸»æœºä¿¡æ¯çš„ä¸åŒæ–¹é¢ã€‚å®¹å™¨ç”¨æˆ·å¯ä»¥æ£€ç´¢å†…æ ¸æ•°æ®ç»“æ„ï¼ˆä¾‹å¦‚ï¼Œ/proc/modulesæ˜¾ç¤ºåŠ è½½æ¨¡å—åˆ—è¡¨ï¼‰ï¼Œå†…æ ¸äº‹ä»¶ï¼ˆä¾‹å¦‚ï¼Œ/proc/interruptsæ˜¾ç¤ºæ¯ä¸ªIRQçš„ä¸­æ–­æ•°ï¼‰å’Œç¡¬ä»¶ä¿¡æ¯ï¼ˆä¾‹å¦‚ï¼Œ/proc/cpuinfoå’Œ/proc/meminfoåˆ†åˆ«æ˜¾ç¤ºCPUå’Œå†…å­˜è§„æ ¼ï¼‰ã€‚æ­¤å¤–ï¼Œå®¹å™¨ç”¨æˆ·è¿˜å¯ä»¥é€šè¿‡æŸäº›é€šé“è·å–æ€§èƒ½ç»Ÿè®¡æ•°æ®ã€‚ä¾‹å¦‚ï¼Œå®¹å™¨å¯ä»¥é€šè¿‡RAPL sysfsæ¥å£è·å¾—ç¡¬ä»¶ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆå¦‚æœè¿™äº›ä¼ æ„Ÿå™¨åœ¨ç‰©ç†æœºä¸Šå¯ç”¨ï¼‰ï¼Œå¦‚æ¯ä¸ªpackageã€æ ¸å¿ƒå’ŒDRAMçš„åŠŸè€—ï¼Œå¹¶é€šè¿‡æ•°å­—æ¸©åº¦ä¼ æ„Ÿå™¨(DTS)sysfsæ¥å£è·å¾—æ¯ä¸ªæ ¸å¿ƒçš„æ¸©åº¦ã€‚æ­¤å¤–ï¼Œå¤„ç†å™¨ã€å†…å­˜å’Œç£ç›˜I&#x2F;Oçš„ä½¿ç”¨æƒ…å†µä¹Ÿæš´éœ²ç»™å®¹å™¨ã€‚è™½ç„¶ä¹ä¸€çœ‹æ³„éœ²è¿™æ ·çš„ä¿¡æ¯ä¼¼ä¹æ— å®³ï¼Œä½†æ¶æ„å¯¹æ‰‹å¯èƒ½åˆ©ç”¨å®ƒæ¥å‘åŠ¨æ”»å‡»ã€‚ æˆ‘ä»¬é€šè¿‡æ£€æŸ¥å†…æ ¸ä»£ç ï¼ˆåœ¨Linuxå†…æ ¸ç‰ˆæœ¬4.7ä¸­ï¼‰è¿›ä¸€æ­¥è°ƒæŸ¥äº†è¿™äº›ä¿¡æ¯æ³„æ¼çš„æ ¹æœ¬åŸå› ã€‚é€šå¸¸ï¼Œæ³„æ¼é—®é¢˜æ˜¯ç”±äºå†…æ ¸ä¸­namespaceå®ç°ä¸å®Œæ•´å¼•èµ·çš„ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œæˆ‘ä»¬æ€»ç»“äº†ä¸¤ä¸ªä¸»è¦åŸå› å¦‚ä¸‹ï¼šï¼ˆ1ï¼‰å¯¹äºç°æœ‰namespaceç¼ºå°‘context checkï¼Œä»¥åŠï¼ˆ2ï¼‰æŸäº›Linuxå­ç³»ç»Ÿæ²¡æœ‰ï¼ˆå®Œå…¨ï¼‰è¿›è¡Œnamespaceéš”ç¦»ã€‚æˆ‘ä»¬æä¾›äº†ä¸¤ä¸ªæ¡ˆä¾‹ç ”ç©¶ï¼Œåˆ†åˆ«æ˜¯å®¹å™¨ä¸­çš„net prio.ifpriomapå’ŒRAPLï¼Œä»¥æ­ç¤ºæ³„æ¼æºå¤´ã€‚ Case study 1 - net_prio.ifpriomapä¼ªæ–‡ä»¶net prio.ifpriomapï¼ˆä½äº/sys/fs/cgroup/net prioä¸‹ï¼‰åŒ…å«äº†ä¸€ä¸ªæ˜ å°„ï¼Œè¯¥æ˜ å°„å°†ä»cgroupä¸­çš„è¿›ç¨‹å¼€å§‹å¹¶ç¦»å¼€ç³»ç»Ÿçš„æµé‡åˆ†é…ç»™ä¸åŒæ¥å£ã€‚æ•°æ®æ ¼å¼ä¸º[ifname priority]ã€‚æˆ‘ä»¬å‘ç°ï¼Œåœ¨net prio.ifpriomapä¸ŠæŒ‚é’©çš„å†…æ ¸å¤„ç†ç¨‹åºå‡½æ•°ä¸çŸ¥é“NETå‘½åç©ºé—´ï¼Œå› æ­¤å®ƒå‘å®¹å™¨åŒ–åº”ç”¨ç¨‹åºæŠ«éœ²ç‰©ç†æœºå™¨ä¸Šæ‰€æœ‰ç½‘ç»œæ¥å£ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œnet prio.ifpriomapçš„è¯»æ“ä½œç”±read_priomapå‡½æ•°å¤„ç†ã€‚ä»è¿™ä¸ªå‡½æ•°è·Ÿè¸ªï¼Œæˆ‘ä»¬å‘ç°å®ƒè°ƒç”¨for_each_netdev_rcuï¼Œå¹¶å°†ç¬¬ä¸€ä¸ªå‚æ•°è®¾ç½®ä¸ºinit_netåœ°å€ã€‚å®ƒè¿­ä»£ä¸»æœºçš„æ‰€æœ‰ç½‘ç»œè®¾å¤‡ï¼Œè€Œä¸è€ƒè™‘NETå‘½åç©ºé—´ã€‚å› æ­¤ï¼Œåœ¨å®¹å™¨è§†å›¾ä¸­ï¼Œå¯ä»¥è¯»å–ä¸»æœºæ‰€æœ‰ç½‘ç»œè®¾å¤‡åç§°ã€‚ Case study 2 - RAPL in containersRAPLæ˜¯è‹±ç‰¹å°”æœ€è¿‘æ¨å‡ºçš„ç”¨äºè®¾ç½®å•ä¸ªæœåŠ¡å™¨å¤„ç†å™¨åŒ…å’ŒDRAMåŠŸç‡é™åˆ¶çš„æŠ€æœ¯ï¼Œå¯ä»¥åœ¨æ¯«ç§’çº§åˆ«å“åº”ã€‚åœ¨å®¹å™¨äº‘ä¸­ï¼ŒRAPL sysfsæ¥å£ä½äº/sys/class/powercap/intel-raplï¼Œå®¹å™¨å¯ä»¥è®¿é—®è¯¥æ¥å£ã€‚å› æ­¤ï¼Œå®¹å™¨ç§Ÿæˆ·å¯ä»¥é€šè¿‡è¿™ä¸ªsysfsæ¥å£è·å–ä¸»æœºçš„ç³»ç»ŸèŒƒå›´å†…ç”µæºçŠ¶æ€ï¼ŒåŒ…æ‹¬æ ¸å¿ƒã€DRAMå’Œpackageç­‰ã€‚ä¾‹å¦‚ï¼Œå®¹å™¨ç”¨æˆ·å¯ä»¥ä»ä¼ªæ–‡ä»¶energy ujä¸­è¯»å–å½“å‰å¾®ç„¦è€³èƒ½é‡è®¡æ•°å™¨å€¼ã€‚Intel RAPL Linuxé©±åŠ¨ç¨‹åºä¸­energy ujçš„å‡½æ•°å¤„ç†ç¨‹åºæ˜¯get_energy_counterã€‚è¯¥å‡½æ•°ä»RAPL MSRæ£€ç´¢åŸå§‹èƒ½é‡æ•°æ®ã€‚ç”±äºå°šæœªå®ç°åŠŸç‡æ•°æ®åç§°ç©ºé—´ï¼Œåˆ™energy_rawæŒ‡é’ˆå¼•ç”¨ä¸»æœºçš„èƒ½é‡æ¶ˆè€—æ•°æ®ã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥è°ƒæŸ¥äº†é‡‡ç”¨Docker&#x2F;LXCå®¹å™¨å¼•æ“çš„å®¹å™¨äº‘æœåŠ¡ä¸­å­˜åœ¨çš„ä¿¡æ¯æ³„æ¼é—®é¢˜ã€‚æˆ‘ä»¬é€‰æ‹©äº†äº”ä¸ªå•†ä¸šå…¬å…±å¤šç§Ÿæˆ·å®¹å™¨äº‘æœåŠ¡è¿›è¡Œæ³„æ¼æ£€æµ‹ï¼Œå¹¶åœ¨è¡¨ä¸­å‘ˆç°ç»“æœã€‚åœ¨äº‘æä¾›å•†ä¿®è¡¥é€šé“ä¹‹å‰ï¼Œæˆ‘ä»¬å¯¹è¿™äº›å®¹å™¨äº‘æœåŠ¡çš„åç§°ï¼ˆCCiä»£è¡¨ç¬¬iä¸ªContainer Cloudï¼‰è¿›è¡ŒåŒ¿ååŒ–å¤„ç†ã€‚å¦‚æœç»“æœä¸æˆ‘ä»¬çš„å®¹å™¨å®ä¾‹é…ç½®ä¸ä¸€è‡´ï¼Œåˆ™ç¡®è®¤æ³„éœ²å­˜åœ¨ã€‚é»‘ç‚¹è¡¨ç¤ºé€šé“ä¸å­˜åœ¨äºè¯¥äº‘ä¸­ï¼Œè€Œç™½ç‚¹è¡¨ç¤ºé€šé“å­˜åœ¨äºè¯¥äº‘ä¸­ã€‚æˆ‘ä»¬å‘ç°å¤§å¤šæ•°æœ¬åœ°æœºå™¨ä¸Šçš„æ³„éœ²æ¸ é“ä¹Ÿå¯ä»¥åœ¨å®¹å™¨äº‘æœåŠ¡ä¸Šä½¿ç”¨ã€‚å…¶ä¸­ä¸€äº›ç”±äºç¼ºä¹ç‰¹å®šç¡¬ä»¶æ”¯æŒè€Œæ— æ³•ä½¿ç”¨ï¼ˆä¾‹å¦‚Sandy Bridgeä¹‹å‰çš„è‹±ç‰¹å°”å¤„ç†å™¨æˆ–ä¸æ”¯æŒRAPLæŠ€æœ¯çš„AMDå¤„ç†å™¨ï¼‰ã€‚å¯¹äºCC5ï¼Œæˆ‘ä»¬å‘ç°æŸäº›é€šé“ä¿¡æ¯ä¸æœ¬åœ°æµ‹è¯•å¹³å°ä¸åŒï¼Œè¿™æ„å‘³ç€äº‘ä¾›åº”å•†å·²ç»å®šåˆ¶äº†ä¸€äº›é¢å¤–é™åˆ¶æ¡ä»¶ã€‚ä¾‹å¦‚ï¼Œåªæœ‰å±äºç§Ÿæˆ·æ ¸å¿ƒå’Œå†…å­˜ç›¸å…³ä¿¡æ¯æ˜¯å¯ç”¨çš„ã€‚ç„¶è€Œï¼Œè¿™äº›æ¸ é“éƒ¨åˆ†æ³„éœ²ä¸»æœºä¿¡æ¯ä»å¯èƒ½è¢«é«˜çº§æ”»å‡»è€…åˆ©ç”¨, æˆ‘ä»¬å°†å®ƒä»¬æ ‡è®°ä¸ºé»‘ç™½ç‚¹ã€‚ Inference of Co-resident Containeræˆ‘ä»¬è¿›ä¸€æ­¥æ·±å…¥ç ”ç©¶ç‰¹å®šæ¡ˆä¾‹ï¼Œä»¥æŸ¥çœ‹å®ƒä»¬æ˜¯å¦å¯ä»¥è¢«åˆ©ç”¨æ¥æ£€æµ‹å…±å­˜å®¹å™¨ Co-residence problems in cloud settingsCo-residenceæ˜¯äº‘å®‰å…¨ä¸­ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„ç ”ç©¶é—®é¢˜ã€‚ä¸ºäº†æå–å—å®³è€…çš„ä¿¡æ¯ï¼Œæ”»å‡»è€…å€¾å‘äºå°†æ¶æ„å®ä¾‹ç§»åŠ¨åˆ°ä¸å—å®³è€…ç›¸åŒçš„ç‰©ç†ä¸»æœºä¸Šã€‚Zhangç­‰äººå·²ç»è¯æ˜ï¼Œæ”»å‡»è€…å¯ä»¥ä½¿ç”¨å…±å­˜å®ä¾‹åŠ«æŒç”¨æˆ·å¸æˆ·å¹¶æå–ç§é’¥ã€‚ æ­¤å¤–ï¼Œå®ç°Co-residenceçš„æˆæœ¬ç›¸å½“ä½ã€‚ç”±äºæ„å›¾æ•´åˆæœåŠ¡å™¨èµ„æºå’Œé™ä½æˆæœ¬ï¼ŒCo-residenceä»ç„¶æ˜¯ç°æœ‰äº‘ä¸­å­˜åœ¨çš„é—®é¢˜ã€‚éªŒè¯Co-residenceçš„ä¼ ç»Ÿæ–¹æ³•åŸºäºç¼“å­˜æˆ–åŸºäºå†…å­˜æ³„æ¼é€šé“ã€‚è¿™äº›æ–¹æ³•çš„å‡†ç¡®æ€§å¯èƒ½ä¼šå› äº‘ç¯å¢ƒä¸­é«˜å™ªå£°è€Œä¸‹é™ã€‚ Approaches and results of checking co-resident containersç”±äºå®¹å™¨å¯ä»¥é€šè¿‡æˆ‘ä»¬å‘ç°çš„æ³„æ¼é€šé“è¯»å–ä¸»æœºä¿¡æ¯ï¼Œå› æ­¤æˆ‘ä»¬å€¾å‘äºæµ‹é‡æŸäº›é€šé“æ˜¯å¦å¯ç”¨äºæ£€æŸ¥å®¹å™¨å…±å­˜ã€‚æˆ‘ä»¬å®šä¹‰äº†ä¸‰ä¸ªæŒ‡æ ‡ï¼Œå³å”¯ä¸€æ€§ï¼ˆUï¼‰ã€å˜åŒ–æ€§ï¼ˆVï¼‰å’Œæ“ä½œæ€§ï¼ˆMï¼‰ï¼Œä»¥å®šé‡è¯„ä¼°æ¯ä¸ªé€šé“æ¨æ–­å…±å­˜çš„èƒ½åŠ›ã€‚æŒ‡æ ‡ U è¡¨ç¤ºè¯¥é€šé“æ˜¯å¦èµ‹äºˆç‰¹å¾æ•°æ®ï¼Œå¯ä»¥å”¯ä¸€åœ°è¯†åˆ«ä¸»æœºã€‚è¿™æ˜¯ç¡®å®šä¸¤ä¸ªå®¹å™¨æ˜¯å¦ä½äºåŒä¸€ä¸»æœºæœ€é‡è¦å’Œå‡†ç¡®çš„å› ç´ ã€‚æˆ‘ä»¬å·²ç»å‘ç°äº† 17 ä¸ªæ³„æ¼é€šé“ï¼Œæ»¡è¶³è¿™ç§åº¦é‡æ ‡å‡†ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å°†è¿™äº›æ¸ é“åˆ†ç±»ä¸ºä¸‰ç»„ï¼š åŒ…å«å”¯ä¸€é™æ€æ ‡è¯†ç¬¦çš„æ¸ é“ã€‚ä¾‹å¦‚ï¼Œåœ¨/proc/sys/kernel/random ä¸‹çš„å¼•å¯¼ ID æ˜¯åœ¨å¯åŠ¨æ—¶ç”Ÿæˆçš„éšæœºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”å¯¹äºæ¯ä¸ªè¿è¡Œå†…æ ¸éƒ½æ˜¯å”¯ä¸€çš„ã€‚å¦‚æœä¸¤ä¸ªå®¹å™¨å¯ä»¥è¯»å–ç›¸åŒçš„å¼•å¯¼ IDï¼Œåˆ™æ˜æ˜¾è¡¨ç¤ºå®ƒä»¬æ­£åœ¨è¿è¡Œåœ¨åŒä¸€ä¸ªä¸»æœºå†…æ ¸ä¸Šã€‚æ­¤ç»„ä¸­æ¸ é“æ•°æ®æ—¢æ˜¯é™æ€åˆæ˜¯ç‹¬ç‰¹çš„ã€‚ å®¹å™¨ç§Ÿæˆ·å¯ä»¥åŠ¨æ€æ¤å…¥ç‹¬ç‰¹ç­¾ååˆ°å…¶ä¸­çš„æ¸ é“ ã€‚ä¾‹å¦‚ï¼Œåœ¨/proc/sched debugä¸­ ï¼Œå®¹å™¨ç”¨æˆ·å¯ä»¥é€šè¿‡æ­¤æ¥å£æ£€ç´¢æ‰€æœ‰æ´»åŠ¨è¿›ç¨‹ä¿¡æ¯çš„ä¸»æœº ã€‚ç§Ÿæˆ·å¯ä»¥åœ¨å®¹å™¨å†…éƒ¨å¯åŠ¨ä¸€ä¸ªå¸¦æœ‰ç‹¬ç‰¹åˆ¶ä½œçš„ä»»åŠ¡åç§°çš„è¿›ç¨‹ã€‚ä»å…¶ä»–å®¹å™¨ä¸­ï¼Œä»–ä»¬å¯ä»¥é€šè¿‡åœ¨è‡ªå·±çš„ sched debug ä¸­æœç´¢æ­¤ä»»åŠ¡åç§°æ¥éªŒè¯å…±å­˜ã€‚ç±»ä¼¼æƒ…å†µé€‚ç”¨äºè®¡æ—¶å™¨åˆ—è¡¨å’Œé”ã€‚ åŒ…å«å”¯ä¸€åŠ¨æ€æ ‡è¯†ç¬¦çš„æ¸ é“ã€‚ä¾‹å¦‚ï¼Œåœ¨/proc/uptimeä¸­æœ‰ä¸¤ä¸ªæ•°æ®å­—æ®µï¼šç³»ç»Ÿè¿è¡Œæ—¶é—´å’Œè‡ªå¼•å¯¼ä»¥æ¥çš„ç³»ç»Ÿç©ºé—²æ—¶é—´ï¼ˆä»¥ç§’ä¸ºå•ä½ï¼‰ã€‚å®ƒä»¬æ˜¯ç´¯ç§¯å€¼ï¼Œå¹¶ä¸”å¯¹äºæ¯å°ä¸»æœºéƒ½æ˜¯å”¯ä¸€çš„ã€‚åŒæ ·ï¼ŒRAPL sysfs æ¥å£ä¸­çš„èƒ½é‡ uj æ˜¯å¾®ç„¦è€³ä¸­ç´¯ç§¯èƒ½é‡è®¡æ•°å™¨ ã€‚ä»è¯¥ç»„é€šé“è¯»å–åˆ° çš„ æ•°æ® åœ¨å®æ—¶æ›´æ”¹ ï¼Œä½†ä»ç„¶æ˜¯ç‹¬ç‰¹çš„ä»£è¡¨ä¸»æœº ã€‚æˆ‘ä»¬æ ¹æ®å…¶å¢é•¿ç‡å¯¹è¯¥ç»„é€šé“è¿›è¡Œæ’åã€‚è¾ƒå¿«çš„å¢é•¿é€Ÿåº¦è¡¨ç¤ºé‡å¤å‡ ç‡è¾ƒä½ã€‚ åº¦é‡Vå¯ä»¥å±•ç¤ºæ•°æ®æ˜¯å¦éšæ—¶é—´å˜åŒ–ã€‚æœ‰äº†è¿™ä¸ªç‰¹æ€§ï¼Œä¸¤ä¸ªå®¹å™¨å¯ä»¥åŒæ—¶å®šæœŸåœ°å¯¹è¯¥ä¼ªæ–‡ä»¶è¿›è¡Œå¿«ç…§ã€‚ç„¶åï¼Œå®ƒä»¬å¯ä»¥é€šè¿‡æ£€æŸ¥ä¸¤ä¸ªæ•°æ®å¿«ç…§è·Ÿè¸ªæ˜¯å¦ç›¸äº’åŒ¹é…æ¥ç¡®å®šco-residenceå…³ç³»ã€‚ä¾‹å¦‚ï¼Œä»åŒä¸€æ—¶åˆ»å¼€å§‹ï¼Œåœ¨ä¸€åˆ†é’Ÿå†…æ¯ç§’é’Ÿè®°å½•/proc/meminfoä¸­çš„MemFreeåœ¨ä¸¤ä¸ªå®¹å™¨ä¸­ã€‚å¦‚æœè¿™ä¸¤ä¸ª60ç‚¹æ•°æ®è·Ÿè¸ªå½¼æ­¤åŒ¹é…ï¼Œåˆ™æˆ‘ä»¬æœ‰ä¿¡å¿ƒè®¤ä¸ºè¿™ä¸¤ä¸ªå®¹å™¨è¿è¡Œåœ¨åŒä¸€ä¸ªä¸»æœºä¸Šã€‚æ¯ä¸ªé€šé“åŒ…å«ä¸åŒçš„ä¿¡æ¯æ¨æ–­å…±å­˜çš„èƒ½åŠ›ï¼Œå¯ä»¥é€šè¿‡è”åˆé¦™å†œç†µè‡ªç„¶åœ°æµ‹é‡ã€‚æˆ‘ä»¬ç”¨å…¬å¼ï¼ˆ1ï¼‰å®šä¹‰ç†µHã€‚ æ¯ä¸ªå¤šé‡ç‹¬ç«‹æ•°æ®å­—æ®µXiï¼Œnè¡¨ç¤ºç‹¬ç«‹æ•°æ®å­—æ®µçš„æ•°é‡ã€‚æ¯ä¸ªXiéƒ½æœ‰å¯èƒ½çš„å€¼{xi1ï¼ŒÂ· Â· Â· ï¼Œxim}ã€‚æˆ‘ä»¬æ ¹æ®è¡¨ä¸­çš„ç†µç»“æœå¯¹èƒ½å¤Ÿæ­ç¤ºco-residenceèƒ½åŠ›çš„ä¹ä¸ªé€šé“ï¼ˆå…¶ä¸­U&#x3D;Falseä¸”V&#x3D;Trueï¼‰è¿›è¡Œæ’åã€‚ æŒ‡æ ‡Mè¡¨ç¤ºå®¹å™¨ç§Ÿæˆ·æ˜¯å¦å¯ä»¥æ“ä½œæ•°æ®ã€‚å¦‚æœç§Ÿæˆ·å¯ä»¥ç›´æ¥å°†ç‰¹åˆ¶çš„æ•°æ®åµŒå…¥é€šé“ä¸­ï¼Œæˆ‘ä»¬ä¼šå¯¹å…¶è¿›è¡Œæ ‡è®°ä¸ºé»‘è‰²ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®¹å™¨å†…åˆ›å»ºä¸€ä¸ªå¸¦æœ‰ç‰¹æ®Šä»»åŠ¡åç§°çš„è®¡æ—¶å™¨ç¨‹åºã€‚è¯¥ä»»åŠ¡åç§°åŠå…¶å…³è”çš„è®¡æ—¶å™¨å°†å‡ºç°åœ¨/proc/timeråˆ—è¡¨ä¸­ã€‚å¦ä¸€ä¸ªå®¹å™¨å¯ä»¥æœç´¢è®¡æ—¶å™¨åˆ—è¡¨ä¸­çš„æ­¤ç‰¹æ®Šä»»åŠ¡åç§°ä»¥éªŒè¯å…±å­˜æ€§ã€‚å¦‚æœç§Ÿæˆ·åªèƒ½é—´æ¥å½±å“æ­¤é€šé“ä¸­çš„æ•°æ®ï¼Œåˆ™æˆ‘ä»¬ä¼šæ ‡è®°ä¸ºé»‘ç™½è‰²ã€‚ä¾‹å¦‚ï¼Œæ”»å‡»è€…å¯ä»¥ä½¿ç”¨tasksetå‘½ä»¤å°†è®¡ç®—å¯†é›†å‹å·¥ä½œè´Ÿè½½ç»‘å®šåˆ°ç‰¹å®šæ ¸å¿ƒï¼Œå¹¶ä»å¦ä¸€ä¸ªå®¹å™¨æ£€æŸ¥CPUåˆ©ç”¨ç‡ã€åŠŸè€—æˆ–æ¸©åº¦ç­‰ä¿¡æ¯ã€‚è¿™äº›æ¡ç›®å¯èƒ½è¢«é«˜çº§æ”»å‡»è€…åˆ©ç”¨ä½œä¸ºéšè”½ä¿¡é“æ¥ä¼ è¾“ä¿¡å·ã€‚ å¯¹äºé‚£äº›æ²¡æœ‰è¿™äº› U V M å±æ€§çš„é€šé“ï¼Œæˆ‘ä»¬è®¤ä¸ºå®ƒä»¬å¾ˆéš¾è¢«åˆ©ç”¨ã€‚ä¾‹å¦‚ï¼Œåœ¨äº‘æ•°æ®ä¸­å¿ƒä¸­ï¼Œå¤§å¤šæ•°æœåŠ¡å™¨å¯èƒ½å®‰è£…äº†ç›¸åŒçš„æ“ä½œç³»ç»Ÿåˆ†å‘ç‰ˆå’Œç›¸åŒçš„æ¨¡å—åˆ—è¡¨ã€‚è™½ç„¶ /proc/modulesæ³„æ¼äº†ä¸»æœºä¸ŠåŠ è½½æ¨¡å—çš„ä¿¡æ¯ï¼Œä½†æ˜¯ä½¿ç”¨æ­¤é€šé“æ¨æ–­co-residentå®¹å™¨æ˜¯å›°éš¾çš„ã€‚ Constructing Covert ChannelsåŒ…å«manipulationï¼ˆMï¼‰çš„é€šé“å¯ä»¥è¿›ä¸€æ­¥åˆ©ç”¨ï¼Œä»¥åœ¨ä¸¤ä¸ªå®¹å™¨ä¹‹é—´å»ºç«‹éšè”½é€šé“ã€‚æˆ‘ä»¬è¯æ˜äº†è¿™äº›ä¿¡æ¯æ³„æ¼é€šé“ä¸­çš„åŠ¨æ€æ ‡è¯†ç¬¦å’Œæ€§èƒ½æ•°æ®éƒ½å¯ä»¥è¢«æ»¥ç”¨æ¥ä¼ è¾“ä¿¡æ¯ã€‚ç‰¹åˆ«åœ°ï¼Œæˆ‘ä»¬å®ç°äº†ä¸¤ä¸ªé€šé“å¹¶æµ‹è¯•å®ƒä»¬çš„ååé‡å’Œé”™è¯¯ç‡ã€‚ Covert channel based on unique dynamic identifiersæˆ‘ä»¬ä»¥/proc/locksä¸ºä¾‹æ¥æ¼”ç¤ºéšè”½é€šé“å¯ä»¥æ„å»ºåœ¨å”¯ä¸€åŠ¨æ€æ ‡è¯†ç¬¦ä¹‹ä¸Šã€‚é€šé“/proc/locksæ˜¾ç¤ºäº†æ“ä½œç³»ç»Ÿä¸­æ‰€æœ‰é”ä¿¡æ¯çš„æ¦‚è¿°ï¼ŒåŒ…æ‹¬é”ç±»å‹ã€ç›¸åº”çš„è¿›ç¨‹ä»¥åŠinodeå·ã€‚ è¿™ç§æ³„æ¼ä¹Ÿç ´åäº† pidå‘½åç©ºé—´ï¼Œå› ä¸ºæ‰€æœ‰é”çš„å…¨å±€pidéƒ½è¢«æ³„éœ²äº†ã€‚Linuxå†…æ ¸çš„ç»´æŠ¤è€…åœ¨4.9ç‰ˆæœ¬ä¸­éƒ¨åˆ†ä¿®å¤äº†/proc/locksã€‚å†…æ ¸4.9ç‰ˆæœ¬ä¸­éƒ¨åˆ†ä¿®å¤äº†/proc/locksï¼Œå°†å½“å‰pidå‘½åç©ºé—´ä¸­çš„æ‰€æœ‰pidå±è”½ä¸ºé›¶ã€‚ç„¶è€Œï¼Œå…¶ä»–ä¿¡æ¯ï¼Œå¦‚é”çš„æ•°é‡å’ŒèŠ‚ç‚¹ä¿¡æ¯ä»ç„¶åœ¨å®¹å™¨ã€‚ æˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªåŸºäº/proc/locksçš„éšè”½é€šé“ã€‚å…·ä½“æ¥è¯´ï¼Œå‘é€æ–¹å¯ä»¥lockä¸€ä¸ªæ–‡ä»¶æ¥è¡¨ç¤º1ï¼Œå¹¶é‡Šæ”¾lockæ¥è¡¨ç¤º0ã€‚è™½ç„¶lockå’Œæ–‡ä»¶ä¸åœ¨å®¹å™¨ä¹‹é—´å…±äº«ï¼Œä½†æ¥æ”¶å™¨å¯ä»¥åœ¨/proc/locksä¸­æ£€æŸ¥lockçš„å­˜åœ¨ã€‚é€šè¿‡ä¸æ–­æ£€æŸ¥ç‰¹å®šlockçš„çŠ¶æ€ï¼Œå¯ä»¥ä¼ è¾“ä¿¡æ¯ã€‚æ­¤å¤–ï¼Œå¯ä»¥åŒæ—¶è®¾ç½®å¤šä¸ªlockä»¥ä¼ è¾“å¤šä¸ªæ¯”ç‰¹ã€‚ä¸ºäº†å»ºç«‹å¯é çš„é«˜å¸¦å®½éšè”½ä¿¡é“ï¼Œæ”»å‡»è€…éœ€è¦è€ƒè™‘å‡ ä¸ªå› ç´ ã€‚æˆ‘ä»¬åœ¨ç®—æ³•1ä¸­è¯¦ç»†ä»‹ç»äº†æ„å»ºåŸºäºé”çš„éšè”½ä¿¡é“çš„è¿‡ç¨‹ã€‚ é€šé“/proc/locksåŒ…å«å†…éƒ¨å†…æ ¸æ•°æ®ï¼Œå› æ­¤å®ƒä¸€ç›´åœ¨æ›´æ”¹ã€‚å°¤å…¶æ˜¯åœ¨å­˜åœ¨å™ªå£°çš„äº‘ç¯å¢ƒä¸­ï¼Œå†…å®¹å¯èƒ½ä¼šå‘ç”Ÿå·¨å¤§çš„æ³¢åŠ¨ã€‚ å¯é ä¼ è¾“æ•°æ®å—çš„ç¬¬ä¸€æ­¥æ˜¯æ¡æ‰‹ï¼šæ¥æ”¶æ–¹éœ€è¦æ‰¾å‡ºå‘é€æ–¹ä½¿ç”¨çš„æ‰€æœ‰lockã€‚ç‰¹åˆ«åœ°ï¼Œæ¡æ‰‹è¿‡ç¨‹è´Ÿè´£ï¼š è®¾ç½®æ•°æ®ä¼ è¾“çš„èµ·ç‚¹. é”šå®šé”ï¼Œç”¨äºåŒæ—¶ä¼ é€ä¸€ä¸ªblock of bits. åŒæ­¥å‘é€å™¨å’Œæ¥æ”¶å™¨ã€‚ æˆ‘ä»¬é€šè¿‡ä¸ºæ¯ä¸ªæ•°æ®é”åˆ›å»ºä¸€ä¸ªç‰¹å®šçš„æ¨¡å¼æ¥å®ç°æ¡æ‰‹ã€‚å¯¹äºä¸€ä¸ªç®€åŒ–çš„æƒ…å†µï¼Œå‘é€æ–¹åœ¨çŸ­æ—¶é—´å†…ä¸æ–­è·å–å’Œé‡Šæ”¾é”ã€‚ç„¶åï¼Œæ¥æ”¶å™¨æ£€æŸ¥æ¯ä¸ªæ•°æ®é”çš„åˆ‡æ¢æ¬¡æ•°ï¼ˆé”å®šæˆ–è§£é”æ–‡ä»¶ï¼‰ã€‚å¦‚æœåˆ‡æ¢æ¬¡æ•°è¶…è¿‡ç‰¹å®šé˜ˆå€¼ï¼Œåˆ™æ¥æ”¶å™¨é€šè¿‡è·Ÿè¸ªç´¢å¼•èŠ‚ç‚¹ç¼–å·æ¥è®°å½•è¯¥lockï¼Œè¯¥ç´¢å¼•èŠ‚ç‚¹ç¼–å·å¯¹äºç‰¹å®šæ–‡ä»¶ä¸Šçš„ç›¸åŒé”å®šæ˜¯ä¸å˜çš„ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé¢å¤–çš„é”æ¥è¡¨ç¤ºä¼ è¾“ä¿¡å·ï¼Œç”¨äºé€šçŸ¥æ¥æ”¶å™¨æ¯ä¸€è½®ä¼ è¾“çš„å¼€å§‹ã€‚ åœ¨åˆ›å»ºç‰¹å®šæ¨¡å¼ä¹‹åï¼Œç†è®ºä¸Šå‘é€æ–¹å¯ä»¥ç«‹å³å¼€å§‹ä¼ è¾“ã€‚ç„¶è€Œï¼Œæ¥æ”¶æ–¹çš„å¤„ç†è¿‡ç¨‹çš„æ—¶é—´æ˜¯æœªçŸ¥çš„å’Œä¸ç¡®å®šçš„ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤šç§Ÿæˆ·äº‘ç¯å¢ƒä¸­å­˜åœ¨å¤§é‡é”çš„æƒ…å†µä¸‹ã€‚å¦‚æœå‘é€æ–¹ä¼ è¾“æ•°æ®è¿‡å¿«ï¼Œåˆ™å¯èƒ½ä¼šä¸¢å¤±ä¸€ä¸ªæ¯”ç‰¹å—ã€‚è™½ç„¶å‘é€æ–¹å¯ä»¥åœ¨å‘é€ä¸‹ä¸€ä¸ªæ•°æ®å—ä¹‹å‰ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œä½†è¿™ç§æ–¹æ³•å°†æå¤§åœ°å½±å“ä¼ è¾“é€Ÿåº¦ã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥æ·»åŠ äº†ä¸€ä¸ªACKé”ï¼Œç”¨äºåŒæ­¥å‘é€æ–¹å’Œæ¥æ”¶æ–¹ã€‚åœ¨è·å¾—æ‰€æœ‰æ•°æ®é”å®šä¹‹åï¼Œæ¥æ”¶å™¨é€šè¿‡è®¾ç½®ACKé”å®šæ¥è¿›è¡Œç¡®è®¤ã€‚å‘é€å™¨ä¾§çš„ACKé”çš„æ£€æµ‹ç±»ä¼¼äºæ¥æ”¶å™¨ä¾§çš„å…¶ä»–æ•°æ®é”çš„æ£€æµ‹æ–¹æ³•ã€‚æ¥æ”¶å™¨åœ¨ç”¨ACKé”å®šè¿›è¡Œåº”ç­”ä¹‹åè¿›å…¥å‡†å¤‡çŠ¶æ€ï¼Œå¹¶ç­‰å¾…æ•°æ®ä¼ è¾“ã€‚ å¯¹äºæ•°æ®ä¼ è¾“ï¼Œå‘é€æ–¹é€šè¿‡è·å–æˆ–é‡Šæ”¾æ•°æ®é”ï¼Œåœ¨æ¯ä¸€è½®ä¸­å‘é€ä¸€ä¸ªæ•°æ®å—ã€‚ä¾‹å¦‚ï¼Œå…«ä¸ªé”å¯ä»¥è¡¨ç¤ºä¸€ä¸ªå­—èŠ‚ã€‚æ¥æ”¶å™¨é€šè¿‡æ£€æŸ¥æ•°æ®é”çš„çŠ¶æ€æ¥è§£ç æ•°æ®ã€‚ä¸€æ—¦æ¥æ”¶åˆ°ACKé”å®šï¼Œå‘é€å™¨å°±å¼€å§‹ä¸‹ä¸€è½®æ•°æ®ä¼ è¾“ã€‚ Covert channel based on performance data variationé€šè¿‡è¿™äº›ä¿¡æ¯çš„æ³„éœ²ï¼Œå®¹å™¨ç”¨æˆ·å¯ä»¥æ£€ç´¢åˆ°ä¸»æœºæœåŠ¡å™¨çš„å…¨ç³»ç»Ÿæ€§èƒ½ç»Ÿè®¡æ•°æ®ã€‚ä¾‹å¦‚ï¼Œå®¹å™¨å¯ä»¥é€šè¿‡/proc/statè·å–æ¯ä¸ªæ ¸å¿ƒçš„CPUä½¿ç”¨ç‡ï¼Œé€šè¿‡/proc/meminfoæˆ–/proc/vmstatè·å–å†…å­˜ä½¿ç”¨ç‡ã€‚æ€§èƒ½æ•°æ®çš„å–å€¼å—å®¹å™¨è¿è¡ŒçŠ¶æ€çš„å½±å“ã€‚å°½ç®¡åœ¨äº‘ç¯å¢ƒä¸­ï¼Œä¸€ä¸ªå®¹å™¨åªèƒ½å®¹çº³æœ‰é™çš„è®¡ç®—èµ„æºï¼Œä½†å®¹å™¨ä¸­çš„æ¶æ„ç”¨æˆ·å¯ä»¥ä»”ç»†é€‰æ‹©åœ¨å®¹å™¨ä¸­è¿è¡Œçš„å·¥ä½œè´Ÿè½½ã€‚é€šè¿‡åœ¨æ€§èƒ½é€šé“ä¸­ç”Ÿæˆç‹¬ç‰¹çš„æ¨¡å¼ï¼Œå®¹å™¨å¯ä»¥æ„å»ºéšè”½é€šé“æ¥ä¼ è¾“ä¿¡æ¯ã€‚æˆ‘ä»¬å»ºç«‹äº†ä¸€ä¸ªéšè”½é€šé“ï¼Œé€šè¿‡æ»¥ç”¨/proc/meminfoä¸­çš„å†…å­˜ä½¿ç”¨ä¿¡æ¯ã€‚ /proc/meminfoæŠ¥å‘Šå¤§é‡å…³äºç³»ç»Ÿå†…å­˜ä½¿ç”¨æƒ…å†µçš„æœ‰ä»·å€¼çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬å¯ç”¨å†…å­˜æ€»é‡ã€ç³»ç»Ÿæœªä½¿ç”¨çš„ç‰©ç†RAMæ€»é‡å’Œè„å†…å­˜æ€»é‡ã€‚ è¿™é‡Œæˆ‘ä»¬åˆ©ç”¨äº†ç³»ç»Ÿä¸­æœªä½¿ç”¨çš„å†…å­˜é‡ã€‚ åœ¨äº‘ç¯å¢ƒä¸­ï¼Œè¿™ä¸ªå€¼å¯èƒ½æœ‰å¾ˆå¤§å·®å¼‚ï¼Œå› ä¸ºæ¯ä¸ªå®¹å™¨ç”¨æˆ·éƒ½å¯èƒ½å½±å“å®ƒã€‚å¯¹äºå»ºç«‹å¯é çš„éšè”½æ•°æ®ä¼ è¾“æ¥è¯´ï¼Œè¿™ç§æ˜¾è‘—çš„å˜åŒ–æ˜¯ä¸å¯å–çš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœä¸è¿è¡Œå†…å­˜å¯†é›†å‹å·¥ä½œè´Ÿè½½ï¼Œä½¿ç”¨æƒ…å†µå¯èƒ½åœ¨å¯æ¥å—çš„èŒƒå›´å†…æ³¢åŠ¨ã€‚æˆ‘ä»¬é¦–å…ˆåœ¨æœåŠ¡å™¨ä¸Šè®°å½•ä¸€æ®µæ—¶é—´çš„æœªä½¿ç”¨å†…å­˜ï¼Œä»¥è·å¾—åŸºçº¿å€¼ã€‚å¦‚æœè¯¥å€¼å˜åŒ–ä¸è¿…é€Ÿä¸”ä¸æ˜¾è‘—ï¼Œåˆ™è¡¨ç¤ºå¯ä»¥å»ºç«‹éšè”½é€šé“ã€‚ç„¶åï¼Œå‘é€æ–¹å®¹å™¨å¯ä»¥åˆ†é…ä¸åŒæ•°é‡çš„å†…å­˜æ¥è¡¨ç¤ºä½1å’Œä½0(ä¾‹å¦‚ï¼Œä½1ä¸º100MBï¼Œä½0ä¸º50MB)ï¼Œè¿™å°†å¯¼è‡´/proc/meminfoä¸­çš„MemFreeå­—æ®µdorp immediatelyã€‚æ¥æ”¶ç«¯å¯ä»¥é€šè¿‡ç›‘è§†ç©ºé—²å†…å­˜çš„å˜åŒ–æ¥ç®€å•åœ°è½¬æ¢æ•°æ®ã€‚MemFreeåˆ†ä¸ºä¸‰ä¸ªçº§åˆ«:åŸºçº¿æƒ…å†µã€ä½1å’Œä½0ã€‚å‘é€æ–¹åœ¨å‘é€1æˆ–0åé‡Šæ”¾æ‰€æœ‰åˆ†é…çš„å†…å­˜ï¼Œä»¥ä¾¿æ¥æ”¶æ–¹å¯ä»¥çŸ¥é“ä¸Šæ¬¡ä¼ è¾“çš„ç»“æŸå¹¶ä¸ºä¸‹ä¸€ä¸ªæ¯”ç‰¹åšå‡†å¤‡ã€‚ ä¸ºäº†ç¡®ä¿å¯é çš„ä¼ è¾“ï¼Œæ¡æ‰‹æ˜¯å‘é€æ–¹å’Œæ¥æ”¶æ–¹ä¹‹é—´çš„ç¬¬ä¸€ä¸ªå¿…è¦æ­¥éª¤ã€‚ å‘é€æ–¹å¯ä»¥é€‰æ‹©å‘é€ä¸€ä¸ªå›ºå®šçš„æ¨¡å¼ï¼Œæ¯”å¦‚8ä½ç›´æ¯”ç‰¹1ï¼Œæ¥å‘èµ·ä¸€æ¬¡ä¼ è¾“ã€‚æ¥æ”¶ç«¯è·å¾—æ¡æ‰‹æ¨¡å¼åï¼Œå°†è¿›å…¥æ•°æ®æ¥æ”¶æ¨¡å¼ã€‚å…·ä½“ç®—æ³•è§ç®—æ³•2ã€‚ä¸ºäº†å‡å°‘å…¶ä»–å®¹å™¨å†…å­˜æ¶ˆè€—æ‰€äº§ç”Ÿçš„å™ªå£°çš„å½±å“ï¼Œä¸€æ—¦MemFreeè½åœ¨é¢„å®šä¹‰çš„èŒƒå›´å†…ï¼Œæ¥æ”¶ç«¯å°†æ ‡è®°æ•°æ®ä¼ è¾“ã€‚åŒæ—¶ï¼Œå¢åŠ å†…å­˜åˆ†é…é‡å¯ä»¥å‡å°‘å™ªå£°çš„å½±å“ã€‚ä½†æ˜¯ï¼Œç”±äºåˆ†é…å’Œé‡Šæ”¾å†…å­˜éœ€è¦æ¶ˆè€—æ—¶é—´ï¼Œå› æ­¤ä¼šå½±å“ä¼ è¾“å¸¦å®½ã€‚ä¸ºäº†å‡å°‘æ¥è‡ªç¯å¢ƒçš„å¹²æ‰°ï¼Œç”¨æˆ·å¯ä»¥è¿›ä¸€æ­¥è®¾è®¡æ›´é«˜çº§åˆ«çš„å¯é åè®®ï¼Œä¾‹å¦‚ä½¿ç”¨æ ¡éªŒå’Œï¼Œä»¥ç¡®ä¿ä¼ è¾“æ•°æ®çš„å®Œæ•´æ€§ã€‚ Experiments on a Multi-tenancy Container Cloudä¸ºäº†æµ‹é‡åœ¨æœ‰çœŸå®å™ªå£°çš„ç¯å¢ƒä¸‹çš„æ€§èƒ½ï¼Œæˆ‘ä»¬é€‰æ‹©äº†ä¸€ä¸ªå•†ä¸šå¤šç§Ÿæˆ·å®¹å™¨äº‘æ¥æµ‹è¯•æˆ‘ä»¬çš„éšè”½é€šé“ã€‚æˆ‘ä»¬åå¤å¯åŠ¨å®¹å™¨ï¼Œå¹¶é€šè¿‡æ£€æŸ¥æƒŸä¸€çš„é™æ€æ ‡è¯†ç¬¦æ¥éªŒè¯å…±å­˜ã€‚æˆ‘ä»¬åœ¨åŒä¸€ç‰©ç†æœºå™¨ä¸Šåˆ›å»ºä¸¤ä¸ªå®¹å™¨ã€‚ Lock-based covert channel: æˆ‘ä»¬åœ¨ä¸‰ç§ä¸åŒå¤§å°çš„æ•°æ®(5,000å­—èŠ‚ã€10,000å­—èŠ‚å’Œ20,000å­—èŠ‚)ä¸‹æµ‹è¯•äº†åŸºäºé”çš„éšè”½é€šé“çš„å¸¦å®½å’Œé”™è¯¯ç‡ã€‚æˆ‘ä»¬è¿˜é€‰æ‹©äº†å››ç§ä¸åŒæ•°é‡çš„é”(å³8ã€16ã€24ã€32)æ¥è¡¡é‡æ€§èƒ½ã€‚æˆ‘ä»¬æ ¹æ®ç»éªŒä¸ºåˆ‡æ¢æ¬¡æ•°é€‰æ‹©ä¸€ä¸ªé˜ˆå€¼ï¼Œä»¥ç¡®ä¿æ‰€æœ‰é”éƒ½èƒ½è¢«æ­£ç¡®è¯†åˆ«ã€‚æ¡æ‰‹è¿‡ç¨‹çš„èŠ±è´¹ä»¥ç§’ä¸ºå•ä½ã€‚ç„¶åï¼Œæ‰€æœ‰ä¼ è¾“æ•°æ®éƒ½æ˜¯éšæœºç”Ÿæˆçš„ã€‚æˆ‘ä»¬æ¢å¤æ¥æ”¶ç«¯çš„æ‰€æœ‰æ•°æ®ï¼Œå¹¶ä¸åŸå§‹æ•°æ®è¿›è¡Œæ¯”è¾ƒã€‚ å…·æœ‰8ä¸ªé”çš„åŸºäºé”çš„éšè”½é€šé“çš„å¸¦å®½çº¦ä¸º5150 bpsã€‚æ˜¾ç„¶ï¼Œä½¿ç”¨çš„é”è¶Šå¤šï¼Œå¸¦å®½å°±è¶Šé«˜ã€‚åœ¨é€šé“ä¸­ä½¿ç”¨32ä¸ªæ•°æ®é”(æ¯è½®ä¼ è¾“4ä¸ªå­—èŠ‚)ï¼Œå¸¦å®½è¾¾åˆ°22186 bpsã€‚ æ­¤å¤–ï¼Œæ‰€æœ‰æ¡ˆä¾‹çš„é”™è¯¯ç‡éƒ½åœ¨2%ä»¥ä¸‹ã€‚ç»“æœè¡¨æ˜ï¼ŒåŸºäºé”çš„éšè”½ä¿¡é“å…·æœ‰è¾ƒé«˜çš„å¯é æ€§ã€‚ Memory-based covert channel: å¯¹äºæ„å»ºåœ¨/proc/meminfoä¸Šçš„éšè”½é€šé“ï¼Œæˆ‘ä»¬é¦–å…ˆå°†ä½1å’Œä½0çš„å†…å­˜åˆ†é…åˆ†åˆ«è®¾ç½®ä¸º100,000KBå’Œ50,000KBã€‚æˆ‘ä»¬å‘é€1000ä½æ¥æµ‹è¯•æ€§èƒ½ã€‚ç„¶åæˆ‘ä»¬é€æ¸å‡å°‘å†…å­˜åˆ†é…ï¼Œç›´åˆ°æ„å»ºæ¡æ‰‹å¤±è´¥ã€‚å¸¦å®½å’Œé”™è¯¯ç‡çš„ç»“æœå¦‚è¡¨3æ‰€ç¤ºã€‚å¸¦å®½ä¸å†…å­˜åˆ†é…å¤§å°æˆåæ¯”ã€‚ä½†æ˜¯ï¼Œå¦‚æœåˆ†é…çš„å†…å­˜å¤ªå°ï¼Œæ¡æ‰‹è¿‡ç¨‹å°±ä¼šå¤±è´¥ï¼Œä»è€Œå¯¼è‡´ä¼ è¾“ä¸­å‡ºç°å¤§é‡é”™è¯¯ã€‚æœ€åï¼Œé€šè¿‡å°†65,000KBåˆ†é…ç»™bit 1, 35,000KBåˆ†é…ç»™bit 0ï¼Œæˆ‘ä»¬èƒ½å¤Ÿåœ¨çœŸå®çš„äº‘ç¯å¢ƒä¸­å®ç°13.6 bpsçš„å¸¦å®½ã€‚ åŸºäºé”çš„éšè”½é€šé“æä¾›äº†éå¸¸é«˜çš„æ•°æ®ä¼ è¾“é€Ÿç‡ï¼ŒåŒæ—¶ä»ç„¶ä¿æŒä½é”™è¯¯ç‡ã€‚è™½ç„¶åŸºäºå†…å­˜çš„éšè”½ä¿¡é“é€Ÿåº¦æœ‰é™ï¼Œä½†ä»èƒ½å¯é åœ°ä¼ è¾“æ•°æ®ã€‚åœ¨åŸºäºå†…å­˜çš„éšè”½ä¿¡é“ä¸­å¯ä»¥æ·»åŠ æ›´å¤šçš„ä¼˜åŒ–æ–¹æ³•ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ›´å¤šçš„çº§åˆ«æ¥æ¯æ¬¡ä¼ è¾“å¤šä¸ªæ¯”ç‰¹ã€‚æˆ‘ä»¬æŠŠå®ƒä½œä¸ºæˆ‘ä»¬ä»Šåçš„å·¥ä½œã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œä¸€æ—¦ä¸¤ä¸ªå®¹å™¨å…±å­˜äºåŒä¸€ç‰©ç†æœåŠ¡å™¨ä¸Šï¼Œæ— è®ºä½¿ç”¨ç›¸åŒçš„CPUåŒ…æˆ–æ ¸å¿ƒï¼Œæ„å»ºåœ¨ä¿¡æ¯æ³„æ¼é€šé“ä¸Šçš„éšè”½é€šé“å°±å¯ä»¥å·¥ä½œã€‚ç›¸åï¼Œåªæœ‰å½“ä¸¤ä¸ªå®ä¾‹å…±äº«ç›¸åŒçš„CPUåŒ…æ—¶ï¼ŒåŸºäºæœ€åä¸€çº§ç¼“å­˜çš„é€šé“æ‰æœ‰æ•ˆã€‚å¦æ®æŠ¥é“ï¼Œåœ¨çœŸå®çš„äº‘ç¯å¢ƒä¸­ï¼ŒåŸºäºå†…å­˜æ€»çº¿çš„æ–¹æ³•åªèƒ½é€‚ç”¨äºè¿‘20%çš„co-residenceæƒ…å†µã€‚çƒ­éšè”½é€šé“åªèƒ½åœ¨ä¸¤ä¸ªæ ¸å½¼æ­¤é è¿‘æ—¶èµ·ä½œç”¨ã€‚ Synergistic Power Attackç”±äºprocfså’Œsysfsåœ¨å®¹å™¨ä¸­éƒ½æ˜¯åªè¯»æŒ‚è½½çš„ï¼Œå› æ­¤æ¶æ„ç§Ÿæˆ·åªèƒ½è¯»å–è¿™äº›ä¿¡æ¯ï¼Œä½†ä¸å…è®¸ä¿®æ”¹ã€‚æˆ‘ä»¬è®¤ä¸ºï¼Œé€šè¿‡åˆ©ç”¨æ³„æ¼é€šé“ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡å­¦ä¹ ä¸»æœºçš„è¿è¡Œæ—¶çŠ¶æ€æ¥åšå‡ºæ›´å¥½çš„å†³ç­–ã€‚ æˆ‘ä»¬å°†ä»‹ç»æ½œåœ¨çš„Synergistic Power Attackï¼Œå¯èƒ½å½±å“æ•°æ®ä¸­å¿ƒçš„å¯é æ€§ï¼Œåœ¨power outage threatsçš„èŒƒå›´å†…ã€‚æˆ‘ä»¬è¯æ˜ï¼Œå¯¹æ‰‹å¯ä»¥åˆ©ç”¨æˆ‘ä»¬å‘ç°çš„è¿™äº›ä¿¡æ¯æ³„æ¼æ¥æ”¾å¤§æ”»å‡»æ•ˆæœï¼Œé™ä½æ”»å‡»æˆæœ¬ï¼Œå¹¶ä¿ƒè¿›æ”»å‡»ç¼–æ’ã€‚æ‰€æœ‰å®éªŒéƒ½æ˜¯åœ¨çœŸå®çš„å®¹å™¨äº‘ä¸­è¿›è¡Œçš„ã€‚ Attack Amplificationå‘åŠ¨æˆåŠŸçš„power attackçš„å…³é”®æ˜¯äº§ç”ŸçŸ­æ—¶é—´çš„é«˜powerå³°å€¼ï¼Œå¯ä»¥è¶…è¿‡ç”µåŠ›è®¾æ–½çš„ä¾›åº”èƒ½åŠ›ã€‚æ­£å¦‚æˆ‘ä»¬åœ¨2.4èŠ‚ä¸­æåˆ°çš„ï¼Œç”µæºæ”»å‡»çš„æ ¹æœ¬åŸå› æ˜¯å¹¿æ³›é‡‡ç”¨ç”µæºoversubscriptionï¼Œè¿™ä½¿å¾—ç”µæºå³°å€¼è¶…è¿‡å®‰å…¨é˜ˆå€¼æˆä¸ºå¯èƒ½ã€‚æ­¤å¤–ï¼Œæœºæ¶çº§åŠŸç‡å°é¡¶æœºåˆ¶åªèƒ½åœ¨åˆ†é’Ÿçº§æ—¶é—´ç²’åº¦å†…ååº”ï¼Œä¸ºçŸ­æ—¶é—´é«˜åŠŸç‡å³°å€¼çš„å‘ç”Ÿç•™ä¸‹äº†ç©ºé—´ã€‚åœ¨æœ€ä¸¥é‡çš„æƒ…å†µä¸‹ï¼Œè¿‡åº¦å……ç”µå¯èƒ½ä¼šè·³é—¸åˆ†æ”¯æ–­è·¯å™¨ï¼Œå¯¼è‡´åœç”µï¼Œæœ€ç»ˆå¯¼è‡´æœåŠ¡å™¨ç˜«ç—ªã€‚èƒ½é‡å³°å€¼çš„é«˜åº¦ä¸»è¦ç”±æ”»å‡»è€…æ§åˆ¶çš„èµ„æºå†³å®šã€‚ç°æœ‰çš„ç”µæºæ”»å‡»é€šè¿‡è‡ªå®šä¹‰ç”µæºå¯†é›†å‹å·¥ä½œè´Ÿè½½ customizing powerintensive workloads(ç§°ä¸ºç”µæºç—…æ¯’)æ¥æœ€å¤§é™åº¦åœ°æé«˜åŠŸè€—ã€‚Ganesanç­‰äººï¼Œåˆ©ç”¨é—ä¼ ç®—æ³•è‡ªåŠ¨ç”Ÿæˆæ¯”æ­£å¸¸stressåŸºå‡†æ¶ˆè€—æ›´å¤šçš„powerçš„power virusesã€‚ æ ¹æ®Barrosoç­‰çš„æŠ¥å‘Šï¼Œåœ¨çœŸå®çš„æ•°æ®ä¸­å¿ƒä¸­ï¼Œå¹³å‡åˆ©ç”¨ç‡çº¦ä¸º20%è‡³30%ã€‚åœ¨å¦‚æ­¤ä½çš„åˆ©ç”¨ç‡ä¸‹ï¼Œä¸åŠ åŒºåˆ†åœ°å‘èµ·power attackè€Œè·³é—¸æ–­è·¯å™¨çš„å‡ ç‡æä½ã€‚ ç„¶è€Œï¼Œè™½ç„¶å¹³å‡åˆ©ç”¨ç‡è¾ƒä½ï¼Œä½†åœ¨å³°å€¼éœ€æ±‚ä¸‹ï¼Œæ•°æ®ä¸­å¿ƒä»ç„¶é¢ä¸´æ–­ç”µå¨èƒã€‚è¿™è¯´æ˜ç‰©ç†æœåŠ¡å™¨çš„åŠŸè€—éšç€å·¥ä½œè´Ÿè½½çš„å˜åŒ–ä¼šæœ‰å¾ˆå¤§çš„æ³¢åŠ¨ã€‚ ä¸ºäº†ç¡®è®¤è¿™ä¸€å‡è®¾ï¼Œæˆ‘ä»¬è¿›è¡Œäº†ä¸€ä¸ªå®éªŒï¼Œç›‘æµ‹å®¹å™¨äº‘ä¸­8ä¸ªç‰©ç†æœåŠ¡å™¨çš„æ•´ä¸ªç³»ç»ŸåŠŸè€—(é€šè¿‡ç¬¬3èŠ‚æ¡ˆä¾‹ç ”ç©¶IIä¸­çš„RAPLæ³„æ¼é€šé“)ï¼ŒæŒç»­ä¸€å‘¨ã€‚æˆ‘ä»¬å°†ç»“æœæ˜¾ç¤ºåœ¨å›¾ä¸­ã€‚æˆ‘ä»¬é¦–å…ˆä»¥30ç§’ä¸ºé—´éš”å¯¹åŠŸç‡æ•°æ®è¿›è¡Œå¹³å‡ï¼Œå¹¶åœ¨ç¬¬2å¤©å’Œç¬¬5å¤©è§‚å¯ŸåŠŸç‡çš„å‰§çƒˆå˜åŒ–ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åœ¨ç¬¬2å¤©é€‰æ‹©ä¸€ä¸ªé«˜åŠŸè€—åŒºåŸŸï¼Œå¹¶ä»¥ä¸€ç§’(è¿™æ˜¯äº§ç”ŸåŠŸç‡å³°å€¼çš„å…¸å‹æ—¶é—´çª—å£)ä¸ºé—´éš”å¯¹æ•°æ®è¿›è¡Œå¹³å‡ã€‚å³°å€¼åŠŸè€—è¾¾åˆ°1199ç“¦(W)ï¼Œåœ¨ä¸€å‘¨çš„æ—¶é—´å†…ï¼Œæ€»åŠŸè€—ç›¸å·®34.72% (899W ~ 1199w)ã€‚ æˆ‘ä»¬é¢„è®¡ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¯¹å…¶è¿›è¡Œæ›´é•¿æ—¶é—´çš„ç›‘æ§ï¼Œæ¯”å¦‚åœ¨é»‘è‰²æ˜ŸæœŸäº”è¿™æ ·çš„å‡æ—¥ï¼Œå½“æ‰˜ç®¡åœ¨äº‘ä¸Šçš„åœ¨çº¿è´­ç‰©ç½‘ç«™å¯èƒ½ä¼šäº§ç”Ÿå·¨å¤§çš„ç”µåŠ›æ¿€å¢æ—¶ï¼ŒåŠŸè€—å·®å¼‚å°†ä¼šæ›´å¤§ã€‚ å¯¹äºå®¹å™¨äº‘ä¸­çš„synergistic power attackï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡RAPLé€šé“ç›‘æ§æ•´ä¸ªç³»ç»Ÿçš„åŠŸè€—ï¼Œå®æ—¶äº†è§£åŠŸè€—æ¨¡å¼çš„æ³¢å³°å’Œæ³¢è°·ï¼Œè€Œä¸æ˜¯ä¸åŠ åŒºåˆ†åœ°å¯åŠ¨åŠŸè€—å¯†é›†å‹å·¥ä½œè´Ÿè½½ã€‚å› æ­¤ï¼Œä»–ä»¬å¯ä»¥åˆ©ç”¨åå°åŠŸè€—(ç”±åŒä¸€ä¸»æœºä¸Šå…¶ä»–ç§Ÿæˆ·çš„è‰¯æ€§å·¥ä½œè´Ÿè½½äº§ç”Ÿ)ï¼Œå¹¶åœ¨æœåŠ¡å™¨å¤„äºå³°å€¼è¿è¡Œæ—¶é—´æ—¶å åŠ ä»–ä»¬çš„ç”µæºæ”»å‡»ã€‚ è¿™ä¸é‡‘èå¸‚åœºçš„å†…å¹•äº¤æ˜“ç°è±¡ç±»ä¼¼â€”â€”æŒæ¡æ›´å¤šå†…å¹•ä¿¡æ¯çš„äººæ€»æ˜¯èƒ½åœ¨åˆé€‚çš„æ—¶é—´äº¤æ˜“ã€‚å¯¹æ‰‹å¯ä»¥é€šè¿‡é€šè¿‡RAPLé€šé“æ³„éœ²çš„â€œå†…éƒ¨â€åŠŸè€—ä¿¡æ¯ï¼Œåœ¨å·²ç»å¾ˆé«˜çš„åŠŸè€—åŸºç¡€ä¸Šå†å¢åŠ ä¸€ä¸ªæ›´é«˜çš„åŠŸè€—å³°å€¼ã€‚ Reduction of Attack Costsä»æ”»å‡»è€…çš„è§’åº¦æ¥çœ‹ï¼Œä»–ä»¬æ€»æ˜¯å¸Œæœ›ä»¥æœ€ä½çš„ä»£ä»·è·å¾—æœ€å¤§çš„æ”»å‡»ç»“æœã€‚æŒç»­è¿è¡ŒåŠŸè€—é«˜çš„å·¥ä½œè´Ÿè½½ç»å¯¹å¯ä»¥æ•è·æ‰€æœ‰è‰¯æ€§åŠŸè€—çš„å³°å€¼ã€‚ä½†æ˜¯ï¼Œç”±äºå‡ ä¸ªåŸå› ï¼Œå®ƒå¯¹äºçœŸå®ä¸–ç•Œçš„æ”»å‡»å¯èƒ½å¹¶ä¸å®ç”¨ã€‚é¦–å…ˆï¼Œå®ƒä¸æ˜¯éšå½¢çš„ã€‚è¦å‘èµ·ç”µæºæ”»å‡»ï¼Œæ”»å‡»è€…éœ€è¦è¿è¡Œç”µæºå¯†é›†å‹å·¥ä½œè´Ÿè½½ã€‚è¿™ç§è¡Œä¸ºå…·æœ‰æ˜æ˜¾çš„æ¨¡å¼ï¼Œå¾ˆå®¹æ˜“è¢«äº‘æä¾›å•†æ£€æµ‹åˆ°ã€‚ å…¶æ¬¡ï¼ŒåŸºäºåˆ©ç”¨ç‡çš„è®¡è´¹æ¨¡å¼ç°åœ¨å˜å¾—è¶Šæ¥è¶Šæµè¡Œã€‚æ›´å¤šçš„äº‘æœåŠ¡æ ¹æ®CPU&#x2F;å†…å­˜åˆ©ç”¨ç‡å’Œç½‘ç»œæµé‡æä¾›æ›´ç»†ç²’åº¦çš„ä»·æ ¼ã€‚ä¾‹å¦‚ï¼ŒElastic Containerä¸ºå®¢æˆ·æä¾›äº†åŸºäºCPUè®¡é‡è®¡è´¹çš„å®¹å™¨ã€‚ IBM Cloudä¸ºäº‘ä¸­çš„è®¡ç®—èµ„æºæä¾›è®¡è´¹æŒ‡æ ‡ã€‚Amazon EC2æä¾›äº†Burstableæ€§èƒ½å®ä¾‹ï¼Œè¯¥å®ä¾‹å¶å°”ä¼šå´©æºƒï¼Œä½†å¤§å¤šæ•°æ—¶é—´ä¸ä¼šå®Œå…¨è¿è¡Œã€‚VMwareæŒ‰éœ€å®šä»·è®¡ç®—å™¨ç”šè‡³ç»™å‡ºäº†ä¸åŒåˆ©ç”¨ç‡æ°´å¹³çš„ä¼°è®¡å€¼ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ªæ‹¥æœ‰16ä¸ªvcpuä¸”å¹³å‡åˆ©ç”¨ç‡ä¸º1%çš„å®ä¾‹ï¼Œå®ƒæ¯æœˆæ”¶è´¹2.87ç¾å…ƒï¼Œå¯¹äºç›¸åŒçš„æœåŠ¡å™¨ä¸”åˆ©ç”¨ç‡ä¸º100%çš„å®ä¾‹ï¼Œæ¯æœˆæ”¶è´¹167.25ç¾å…ƒã€‚åœ¨è¿™äº›äº‘è®¡è´¹æ¨¡å¼ä¸‹ï¼ŒæŒç»­çš„power attackå¯èƒ½æœ€ç»ˆå¯¼è‡´æ˜‚è´µçš„è´¦å•ã€‚ å¯¹äºsynergistic power attackï¼Œé€šè¿‡RAPLç›‘è§†åŠŸè€—å‡ ä¹æ²¡æœ‰CPUå ç”¨ã€‚ ä¸ºäº†è¾¾åˆ°ç›¸åŒçš„æ•ˆæœ(åŠŸç‡å³°å€¼çš„é«˜åº¦)ï¼Œä¸è¿ç»­å’Œå‘¨æœŸæ€§æ”»å‡»ç›¸æ¯”ï¼ŒååŒåŠŸç‡æ”»å‡»å¯ä»¥æ˜¾è‘—é™ä½æ”»å‡»æˆæœ¬ã€‚æˆ‘ä»¬æ¯”è¾ƒäº†synergistic power attackå’Œå‘¨æœŸæ€§æ”»å‡»(æ¯300ç§’å‘èµ·ä¸€æ¬¡synergistic power attack)çš„æ”»å‡»æ•ˆæœã€‚ååŒæ”»å‡»åœ¨3000ç§’å†…åªè¿›è¡Œä¸¤æ¬¡è¯•éªŒï¼Œå°±å¯ä»¥è¾¾åˆ°1359ç“¦çš„åŠŸç‡å³°å€¼ï¼Œè€Œå‘¨æœŸæ€§æ”»å‡»åˆ™è¿›è¡Œäº†9æ¬¡è¯•éªŒï¼Œæœ€å¤šåªèƒ½è¾¾åˆ°1280ç“¦ã€‚ Attack Orchestrationä¸ä¼ ç»Ÿçš„power attackä¸åŒï¼Œsynergistic power attackçš„å¦ä¸€ä¸ªç‹¬ç‰¹ç‰¹å¾æ˜¯å®ƒçš„æ”»å‡»ç¼–æ’ã€‚å‡è®¾æ”»å‡»è€…å·²ç»æ§åˆ¶äº†ä¸€äº›å®¹å™¨å®ä¾‹ã€‚å¦‚æœè¿™äº›å®¹å™¨åˆ†æ•£åœ¨æ•°æ®ä¸­å¿ƒçš„ä¸åŒä½ç½®ï¼Œé‚£ä¹ˆå®ƒä»¬åœ¨å¤šä¸ªç‰©ç†æœåŠ¡å™¨ä¸Šå¢åŠ çš„powerä¸ä¼šå¯¹ç”µåŠ›è®¾æ–½é€ æˆå‹åŠ›ã€‚ç°æœ‰çš„åŠŸç‡å°é¡¶æœºåˆ¶å¯ä»¥æ¯«æ— å›°éš¾åœ°å®¹å¿æ¥è‡ªä¸åŒä½ç½®çš„å¤šä¸ªå°power surgesã€‚å‘åŠ¨å®é™…ç”µåŠ›æ”»å‡»çš„å”¯ä¸€æ–¹æ³•æ˜¯å°†æ‰€æœ‰â€œå¼¹è¯â€èšé›†åˆ°ç›¸é‚»ä½ç½®ï¼ŒåŒæ—¶æ”»å‡»å•ä¸ªç”µæºã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ·±å…¥è®¨è®ºæ”»å‡»å®¹å™¨å®ä¾‹çš„ç¼–æ’ã€‚ æ­£å¦‚æˆ‘ä»¬åœ¨ç¬¬3èŠ‚ä¸­æåˆ°çš„ï¼Œé€šè¿‡åˆ©ç”¨å¤šä¸ªæ³„æ¼é€šé“ï¼Œæ”»å‡»è€…å¯ä»¥å°†å¤šä¸ªå®¹å™¨å®ä¾‹èšåˆåˆ°ä¸€ä¸ªç‰©ç†æœåŠ¡å™¨ä¸­ã€‚å…·ä½“æ¥è¯´ï¼Œåœ¨CC1ä¸Šçš„å®éªŒä¸­ï¼Œæˆ‘ä»¬é€‰æ‹©ä½¿ç”¨è®¡æ—¶å™¨åˆ—è¡¨æ¥éªŒè¯å¤šä¸ªå®¹å™¨çš„å…±å­˜ã€‚å…·ä½“éªŒè¯æ–¹æ³•è¯·å‚è§3.3èŠ‚ã€‚æˆ‘ä»¬åå¤åˆ›å»ºä¸åœ¨åŒä¸€ç‰©ç†æœåŠ¡å™¨ä¸Šçš„å®¹å™¨å®ä¾‹å’Œç»ˆæ­¢å®ä¾‹ã€‚é€šè¿‡è¿™æ ·åšï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°åœ¨åŒä¸€å°æœåŠ¡å™¨ä¸Šéƒ¨ç½²ä¸‰ä¸ªå®¹å™¨ã€‚æˆ‘ä»¬åœ¨æ¯ä¸ªå®¹å™¨ä¸­è¿è¡Œå››ä¸ªPrimeåŸºå‡†æµ‹è¯•å‰¯æœ¬ï¼Œä»¥å……åˆ†åˆ©ç”¨å››ä¸ªåˆ†é…çš„æ ¸å¿ƒã€‚æ¯ä¸ªå®¹å™¨å¯ä»¥è´¡çŒ®å¤§çº¦40Wçš„åŠŸç‡ã€‚ä½¿ç”¨ä¸‰ä¸ªå®¹å™¨ï¼Œæ”»å‡»è€…å¯ä»¥è½»æ¾åœ°å°†åŠŸè€—æé«˜åˆ°è¿‘230Wï¼Œè¿™æ¯”å•ä¸ªæœåŠ¡å™¨çš„å¹³å‡åŠŸè€—é«˜å‡ºçº¦100Wã€‚ æˆ‘ä»¬è¿˜å‘ç°/proc/uptimeæ˜¯å¦ä¸€ä¸ªæœ‰è¶£çš„æ³„æ¼é€šé“ã€‚æ­£å¸¸è¿è¡Œæ—¶é—´åŒ…æ‹¬ä¸¤ä¸ªæ•°æ®é¡¹ï¼Œç‰©ç†æœåŠ¡å™¨çš„å¯åŠ¨æ—¶é—´å’Œæ‰€æœ‰æ ¸å¿ƒçš„ç©ºé—²æ—¶é—´ã€‚ åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæˆ‘ä»¬å‘ç°ä¸€äº›æœåŠ¡å™¨çš„å¯åŠ¨æ—¶é—´ç›¸ä¼¼ï¼Œä½†ç©ºé—²æ—¶é—´ä¸åŒã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œæ•°æ®ä¸­å¿ƒçš„æœåŠ¡å™¨åœ¨å®‰è£…å’Œæ‰“å¼€åä¸ä¼šé‡æ–°å¯åŠ¨ã€‚ä¸åŒçš„ç©ºé—²æ—¶é—´è¡¨æ˜å®ƒä»¬ä¸æ˜¯ç›¸åŒçš„ç‰©ç†æœåŠ¡å™¨ï¼Œè€Œç›¸ä¼¼çš„å¼•å¯¼æ—¶é—´è¡¨æ˜å®ƒä»¬å¾ˆå¯èƒ½åœ¨åŒä¸€æ—¶é—´æ®µè¢«å®‰è£…å’Œæ‰“å¼€ã€‚è¿™æ˜¯å¼ºæœ‰åŠ›çš„è¯æ®ï¼Œè¡¨æ˜å®ƒä»¬å¯èƒ½ç¦»å¾—å¾ˆè¿‘ï¼Œå…±ç”¨åŒä¸€ä¸ªæ–­è·¯å™¨ã€‚æ”»å‡»è€…å¯ä»¥åˆ©ç”¨æ­¤é€šé“å°†å…¶æ”»å‡»å®¹å™¨å®ä¾‹èšåˆåˆ°ç›¸é‚»çš„ç‰©ç†æœåŠ¡å™¨ä¸­ã€‚è¿™å¤§å¤§å¢åŠ äº†ä»–ä»¬è·³é—¸å¯¼è‡´åœç”µçš„æœºä¼šã€‚ Defense AproachA Two-Stage Defense Mechanismç›´è§‚åœ°è¯´ï¼Œè§£å†³æ–¹æ¡ˆåº”è¯¥æ¶ˆé™¤æ‰€æœ‰æ³„æ¼ï¼Œè¿™æ ·å°±ä¸ä¼šé€šè¿‡è¿™äº›æ¸ é“æ£€ç´¢æ³„æ¼çš„ä¿¡æ¯ã€‚æˆ‘ä»¬å°†é˜²å¾¡æœºåˆ¶åˆ’åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µ:(1)å±è”½é€šé“å’Œ(2)å¢å¼ºå®¹å™¨çš„èµ„æºéš”ç¦»æ¨¡å‹ã€‚ åœ¨ç¬¬ä¸€é˜¶æ®µï¼Œç³»ç»Ÿç®¡ç†å‘˜å¯ä»¥æ˜¾å¼åœ°æ‹’ç»å¯¹å®¹å™¨å†…é€šé“çš„è¯»è®¿é—®ï¼Œä¾‹å¦‚ï¼Œé€šè¿‡AppArmorä¸­çš„å®‰å…¨ç­–ç•¥æˆ–æŒ‚è½½ä¼ªæ–‡ä»¶â€œä¸å¯è¯»â€ã€‚è¿™ä¸éœ€è¦å¯¹å†…æ ¸ä»£ç è¿›è¡Œä»»ä½•æ›´æ”¹(åˆå¹¶åˆ°ä¸Šæ¸¸Linuxå†…æ ¸å¯èƒ½éœ€è¦ä¸€äº›æ—¶é—´)ï¼Œå¹¶ä¸”å¯ä»¥ç«‹å³æ¶ˆé™¤ä¿¡æ¯æ³„æ¼ã€‚æ­¤è§£å†³æ–¹æ¡ˆå–å†³äºå®¹å™¨ä¸­è¿è¡Œçš„åˆæ³•åº”ç”¨ç¨‹åºæ˜¯å¦ä½¿ç”¨è¿™äº›é€šé“ã€‚å¦‚æœè¿™äº›ä¿¡æ¯ä¸å®¹å™¨åŒ–çš„åº”ç”¨ç¨‹åºæ­£äº¤ï¼Œåˆ™å±è”½å®ƒä¸ä¼šå¯¹å®¹å™¨ç§Ÿæˆ·äº§ç”Ÿè´Ÿé¢å½±å“ã€‚æˆ‘ä»¬å·²ç»å‘Dockerå’Œè¡¨ä¸­åˆ—å‡ºçš„æ‰€æœ‰äº‘ä¾›åº”å•†æŠ¥å‘Šäº†æˆ‘ä»¬çš„ç»“æœï¼Œå¹¶æ”¶åˆ°äº†ç§¯æçš„å›åº”ã€‚ æˆ‘ä»¬ä¸å®¹å™¨äº‘ä¾›åº”å•†åˆä½œè§£å†³æ­¤ä¿¡æ¯æ³„æ¼é—®é¢˜ï¼Œå¹¶å°†å¯¹å®¹å™¨ä¸­æ‰˜ç®¡çš„åº”ç”¨ç¨‹åºçš„å½±å“é™è‡³æœ€ä½ã€‚è¿™ç§å±è”½æ–¹æ³•å¯ä»¥å¿«é€Ÿä¿®å¤åŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿä¸­çš„æ‰€æœ‰æ³„æ¼ï¼Œä½†å®ƒå¯èƒ½ä¼šå¯¹å®¹å™¨åŒ–åº”ç”¨ç¨‹åºçš„åŠŸèƒ½å¢åŠ é™åˆ¶ï¼Œè¿™ä¸å®¹å™¨æä¾›é€šç”¨è®¡ç®—å¹³å°çš„æ¦‚å¿µç›¸çŸ›ç›¾ã€‚ åœ¨ç¬¬äºŒé˜¶æ®µï¼Œé˜²å¾¡æ–¹æ³•æ¶‰åŠä¿®å¤ä¸¢å¤±çš„namespaceä¸Šä¸‹æ–‡æ£€æŸ¥å’Œè™šæ‹ŸåŒ–æ›´å¤šçš„ç³»ç»Ÿèµ„æº(å³ï¼Œå®ç°æ–°çš„namespace)ä»¥å¢å¼ºå®¹å™¨çš„éš”ç¦»æ¨¡å‹ã€‚ æˆ‘ä»¬é¦–å…ˆå‘Linuxå†…æ ¸ç»´æŠ¤è€…æŠ¥å‘Šäº†ä¸ç°æœ‰namespaceç›¸å…³çš„ä¿¡æ¯æŠ«éœ²é”™è¯¯ï¼Œä»–ä»¬å¾ˆå¿«å‘å¸ƒäº†é’ˆå¯¹å…¶ä¸­ä¸€ä¸ªé—®é¢˜çš„æ–°è¡¥ä¸([CVE2017-5967])ã€‚å¯¹äºæ²¡æœ‰namespaceéš”ç¦»ä¿æŠ¤çš„å…¶ä»–é€šé“ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ”¹å†…æ ¸ä»£ç ï¼Œä»¥å¼ºåˆ¶ä½¿ç”¨æ›´ç»†ç²’åº¦çš„ç³»ç»Ÿèµ„æºåˆ†åŒºã€‚ç”±äºæ¯ä¸ªé€šé“éƒ½éœ€è¦å•ç‹¬ä¿®å¤ï¼Œå› æ­¤è¿™ç§æ–¹æ³•å¯èƒ½æ¶‰åŠå¤§é‡å·¥ä½œã€‚è™šæ‹ŸåŒ–ä¸€ä¸ªç‰¹å®šçš„å†…æ ¸ç»„ä»¶å¯èƒ½ä¼šå½±å“å¤šä¸ªå†…æ ¸å­ç³»ç»Ÿã€‚å¦å¤–ï¼Œæœ‰äº›ç³»ç»Ÿèµ„æºä¸å®¹æ˜“ç²¾ç¡®åœ°åˆ’åˆ†åˆ°æ¯ä¸ªå®¹å™¨ä¸­ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™æ˜¯è§£å†³é—®é¢˜çš„æ ¹æœ¬åŠæ³•ã€‚ç‰¹åˆ«æ˜¯ï¼Œä¸ºäº†é˜²å¾¡synergistic power attackï¼Œæˆ‘ä»¬åœ¨Linuxå†…æ ¸ä¸­è®¾è®¡å¹¶å®ç°äº†ä¸€ä¸ªproof-of-concept power-based namespaceï¼Œä»¥å‘æ¯ä¸ªå®¹å™¨æ˜¾ç¤ºåˆ†åŒºçš„ç”µæºä½¿ç”¨æƒ…å†µã€‚ Power-based Namespaceæˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªpower-based namespaceï¼Œé€šè¿‡æœªæ›´æ”¹çš„RAPLæ¥å£å‘æ¯ä¸ªå®¹å™¨æ˜¾ç¤ºæ¯ä¸ªå®¹å™¨çš„powerä½¿ç”¨æƒ…å†µã€‚åœ¨ä¸æ³„æ¼æ•´ä¸ªç³»ç»ŸåŠŸè€—ä¿¡æ¯çš„æƒ…å†µä¸‹ï¼Œæ”»å‡»è€…æ— æ³•æ¨æ–­ä¸»æœºçš„ç”µæºçŠ¶æ€ï¼Œä»è€Œæ¶ˆé™¤äº†åœ¨è‰¯æ€§ç”µæºå³°å€¼ä¸Šå åŠ åŠŸè€—å¯†é›†å‹å·¥ä½œè´Ÿè½½çš„æœºä¼šã€‚æ­¤å¤–ï¼Œæœ‰äº†æ¯ä¸ªå®¹å™¨çš„åŠŸç‡ä½¿ç”¨ç»Ÿè®¡æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥åŠ¨æ€åœ°é™åˆ¶è¶…è¿‡é¢„å®šä¹‰åŠŸç‡é˜ˆå€¼çš„å®¹å™¨çš„è®¡ç®—èƒ½åŠ›(æˆ–å¢åŠ ä½¿ç”¨è´¹ç”¨)ã€‚å®¹å™¨äº‘ç®¡ç†å‘˜å¯ä»¥åŸºäºæ­¤åŸºäºåŠŸèƒ½çš„namespaceè®¾è®¡ç²’åº¦æ›´ç»†çš„è®¡è´¹æ¨¡å‹ã€‚ æˆ‘ä»¬çš„è®¾è®¡æœ‰ä¸‰ä¸ªç›®æ ‡ã€‚ å‡†ç¡®æ€§:ç”±äºæ²¡æœ‰ç¡¬ä»¶æ”¯æŒæ¯ä¸ªå®¹å™¨çš„åŠŸç‡åˆ†åŒºï¼Œæˆ‘ä»¬åŸºäºè½¯ä»¶çš„åŠŸç‡å»ºæ¨¡éœ€è¦å‡†ç¡®åæ˜ æ¯ä¸ªå®¹å™¨çš„åŠŸç‡ä½¿ç”¨æƒ…å†µã€‚ é€æ˜æ€§:å®¹å™¨å†…çš„åº”ç”¨ç¨‹åºä¸çŸ¥é“è¯¥å‘½åç©ºé—´å¤–çš„åŠŸç‡å˜åŒ–ï¼ŒåŠŸç‡å­ç³»ç»Ÿçš„æ¥å£ä¿æŒä¸å˜ã€‚ æ•ˆç‡:åŠŸç‡åˆ†åŒºä¸åº”åœ¨å®¹å™¨å†…æˆ–å®¹å™¨å¤–å¼•èµ·é‡è¦çš„æ€§èƒ½å¼€é”€ã€‚ æˆ‘ä»¬åœ¨å›¾ä¸­è¯´æ˜äº†ç³»ç»Ÿçš„å·¥ä½œæµç¨‹ã€‚æˆ‘ä»¬åŸºäºåŠŸç‡çš„å‘½åç©ºé—´ç”±ä¸‰ä¸ªä¸»è¦ç»„ä»¶ç»„æˆ:æ•°æ®æ”¶é›†ã€åŠŸç‡å»ºæ¨¡å’ŒåŠ¨æ€æ ¡å‡†ã€‚æˆ‘ä»¬åœ¨å®¹å™¨ä¸­ä¿æŒç›¸åŒçš„Intel RAPLæ¥å£ï¼Œä½†æ˜¯æ”¹å˜äº†å¤„ç†èƒ½æºä½¿ç”¨çš„è¯»å–æ“ä½œçš„å®ç°ã€‚ä¸€æ—¦æ£€æµ‹åˆ°èƒ½æºä½¿ç”¨çš„è¯»å–æ“ä½œï¼Œä¿®æ”¹åçš„RAPLé©±åŠ¨ç¨‹åºæ£€ç´¢æ¯ä¸ªå®¹å™¨çš„æ€§èƒ½æ•°æ®(æ•°æ®æ”¶é›†)ï¼Œä½¿ç”¨æ£€ç´¢åˆ°çš„æ•°æ®æ¥å»ºæ¨¡èƒ½æºä½¿ç”¨(åŠŸç‡å»ºæ¨¡)ï¼Œæœ€åæ ¡å‡†å»ºæ¨¡çš„èƒ½æºä½¿ç”¨(åŠ¨æ€æ ¡å‡†)ã€‚ æˆ‘ä»¬å°†åœ¨ä¸‹é¢è¯¦ç»†è®¨è®ºæ¯ä¸ªç»„ä»¶ã€‚ Data collectionä¸ºäº†å¯¹æ¯ä¸ªå®¹å™¨çš„åŠŸè€—è¿›è¡Œå»ºæ¨¡ï¼Œæˆ‘ä»¬éœ€è¦è·å¾—æ¯ä¸ªå®¹å™¨çš„ fine-grained performance dataã€‚æ¯ä¸ªå®¹å™¨éƒ½ä¸ä¸€ä¸ªcpuacct cgroupç›¸å…³è”ã€‚cpuacct cgroupè¡¨ç¤ºå®¹å™¨çš„å¤„ç†å™¨æ ¸å¿ƒä¸Šçš„CPUå‘¨æœŸã€‚CPUå‘¨æœŸç´¯è®¡ã€‚æˆ‘ä»¬åªä½¿ç”¨CPUå‘¨æœŸæ¥è®¡ç®—åé¢çš„ç¼“å­˜ä¸¢å¤±ç‡å’Œåˆ†æ”¯ä¸¢å¤±ç‡ã€‚Linuxå†…æ ¸è¿˜æœ‰ä¸€ä¸ªperf_eventå­ç³»ç»Ÿï¼Œå®ƒæ”¯æŒè®¡ç®—ä¸åŒç±»å‹çš„æ€§èƒ½äº‹ä»¶ã€‚The granularity ofperformance accounting å¯ä»¥æ˜¯å•ä¸ªè¿›ç¨‹æˆ–ä¸€ç»„è¿›ç¨‹(è§†ä¸ºä¸€ä¸ªper_event cgroup)ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªä¸ºæ¯ä¸ªperf_event cgroupæ£€ç´¢é€€å½¹æŒ‡ä»¤ã€ç¼“å­˜ç¼ºå¤±å’Œåˆ†æ”¯ç¼ºå¤±(åœ¨ä¸‹ä¸€ä¸ªç”µæºå»ºæ¨¡ç»„ä»¶ä¸­éœ€è¦)çš„æ•°æ®ã€‚æˆ‘ä»¬å½“å‰çš„å®ç°æ˜¯å¯æ‰©å±•çš„ï¼Œå¯ä»¥æ”¶é›†ä¸æœªæ¥ç”µæºå»ºæ¨¡çš„å˜åŒ–ç›¸å¯¹åº”çš„æ›´å¤šæ€§èƒ½äº‹ä»¶ç±»å‹ã€‚ æˆ‘ä»¬ä»power-based namespaceçš„åˆå§‹åŒ–ç›‘è§†æ€§èƒ½äº‹ä»¶ï¼Œå¹¶åˆ›å»ºå¤šä¸ªperf_eventsï¼Œæ¯ä¸ªäº‹ä»¶éƒ½ä¸ç‰¹å®šçš„æ€§èƒ½äº‹ä»¶ç±»å‹å’Œç‰¹å®šçš„CPUæ ¸å¿ƒç›¸å…³è”ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†è¯¥å®¹å™¨çš„perf_cgroupä¸è¿™äº›perf_eventè¿æ¥èµ·æ¥ï¼Œå¼€å§‹è®¡ç®—ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬éœ€è¦å°†æ‰€æœ‰åˆ›å»ºçš„perf_eventçš„æ‰€æœ‰è€…è®¾ç½®ä¸ºTASK TOMBSTONEï¼Œè¿™è¡¨æ˜è¿™æ ·çš„æ€§èƒ½æ ¸ç®—ä¸ä»»ä½•ç”¨æˆ·è¿›ç¨‹éƒ½æ˜¯åˆ†ç¦»çš„ã€‚ Power modelingè¦å®ç°power-based namespaceï¼Œæˆ‘ä»¬éœ€è¦å°†åŠŸç‡æ¶ˆè€—å½’å› äºæ¯ä¸ªå®¹å™¨ã€‚RAPLä¸æ˜¯æä¾›ç¬æ€åŠŸè€—ï¼Œè€Œæ˜¯åˆ†åˆ«ä¸ºpackageã€æ ¸å¿ƒå’ŒDRAMæä¾›ç´¯è®¡èƒ½è€—ã€‚poweræ¶ˆè€—å¯ä»¥é€šè¿‡æµ‹é‡æ—¶é—´å•ä½çª—å£å†…çš„èƒ½æºæ¶ˆè€—æ¥è®¡ç®—ã€‚ æˆ‘ä»¬power-based namespaceè¿˜ä»¥ä¸åŸå§‹RAPLæ¥å£ç›¸åŒçš„æ ¼å¼æä¾›äº†æ¯ä¸ªå®¹å™¨çš„ç´¯è®¡èƒ½é‡æ•°æ®ã€‚ æˆ‘ä»¬é¦–å…ˆå°†æ ¸å¿ƒçš„åŠŸè€—å½’ä¸ºå±æ€§ã€‚ ä¼ ç»Ÿçš„ç”µæºå»ºæ¨¡åˆ©ç”¨CPUåˆ©ç”¨ç‡æ¥ç¡®å®šæ ¸å¿ƒçš„åŠŸè€—ã€‚ç„¶è€Œï¼ŒXuç­‰è¯æ˜ï¼Œåœ¨ç›¸åŒçš„CPUåˆ©ç”¨ç‡ä¸‹ï¼Œpoweræ¶ˆè€—å¯èƒ½ä¼šæœ‰å¾ˆå¤§å·®å¼‚ã€‚åº•å±‚ç®¡é“å’Œæ•°æ®ä¾èµ–å¯èƒ½å¯¼è‡´CPUå¤±é€Ÿå’ŒåŠŸèƒ½å•å…ƒç©ºè½¬ã€‚åœ¨ç›¸åŒçš„CPUåˆ©ç”¨ç‡ä¸‹ï¼Œå®é™…é€€å‡ºæŒ‡ä»¤çš„æ•°é‡æ˜¯ä¸åŒçš„ã€‚ å›¾æ˜¾ç¤ºäº†é€€å½¹æŒ‡ä»¤å’Œèƒ½é‡ä¹‹é—´çš„å…³ç³»ã€‚æˆ‘ä»¬åœ¨å››ä¸ªä¸åŒçš„åŸºå‡†ä¸Šè¿›è¡Œæµ‹è¯•:ç”¨Cç¼–å†™çš„ç©ºé—²å¾ªç¯ï¼Œprime, 462.SPECCPU2006ä¸­çš„libquantumï¼Œä»¥åŠä¸åŒå†…å­˜é…ç½®çš„strssã€‚æˆ‘ä»¬åœ¨ä¸»æœºä¸Šè¿è¡ŒåŸºå‡†æµ‹è¯•ï¼Œå¹¶ä½¿ç”¨Perfæ¥æ”¶é›†æ€§èƒ½ç»Ÿè®¡æ•°æ®ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå¯¹äºæ¯ä¸ªåŸºå‡†æµ‹è¯•ï¼Œèƒ½é‡æ¶ˆè€—å‡ ä¹ä¸¥æ ¼åœ°ä¸é€€å½¹æŒ‡ä»¤çš„æ•°é‡æˆçº¿æ€§ã€‚ä½†æ˜¯ï¼Œéšç€åº”ç”¨ç±»å‹çš„ä¸åŒï¼Œæ‹Ÿåˆçº¿çš„æ¢¯åº¦ä¹Ÿç›¸åº”å˜åŒ–ã€‚ä¸ºäº†ä½¿æˆ‘ä»¬çš„æ¨¡å‹æ›´åŠ å‡†ç¡®ï¼Œæˆ‘ä»¬è¿›ä¸€æ­¥åŠ å…¥cache miss rateå’Œbranch miss rateï¼Œå»ºç«‹ä¸€ä¸ªå¤šæ¬¡å¤šé¡¹å¼æ¨¡å‹æ¥æ‹Ÿåˆæ–œç‡ã€‚ å¯¹äºDRAMï¼Œæˆ‘ä»¬ä½¿ç”¨packageå¤±è´¥çš„æ•°é‡æ¥åˆ†æpowerã€‚å›¾æ˜¾ç¤ºäº†æ ¸å¿ƒå®éªŒä¸­ç›¸åŒåŸºå‡†æµ‹è¯•å’Œç›¸åŒé…ç½®çš„èƒ½è€—ã€‚å®ƒæ¸…æ¥šåœ°è¡¨æ˜cache missçš„æ•°é‡ä¸DRAMèƒ½é‡è¿‘ä¼¼çº¿æ€§ã€‚ åœ¨æ­¤åŸºç¡€ä¸Šï¼Œæˆ‘ä»¬åˆ©ç”¨çš„çº¿æ€§å›å½’å¯¹DRAMèƒ½é‡è¿›è¡Œå»ºæ¨¡ã€‚ å¯¹äºpackageçš„åŠŸè€—ï¼Œæˆ‘ä»¬å°†æ ¸å¿ƒã€DRAMå’Œä¸€ä¸ªé¢å¤–å¸¸æ•°çš„å€¼ç›¸åŠ ã€‚å…·ä½“æ¨¡å‹å¦‚å¼æ‰€ç¤ºï¼Œå…¶ä¸­Mä¸ºå»ºæ¨¡èƒ½é‡;CMã€BMã€Cåˆ†åˆ«è¡¨ç¤ºcache missæ¬¡æ•°ã€branch missæ¬¡æ•°å’ŒCPUå‘¨æœŸ;Fä¸ºé€šè¿‡å¤šæ¬¡çº¿æ€§å›å½’æ‹Ÿåˆæ–œç‡å¾—åˆ°çš„å‡½æ•°ã€‚Iæ˜¯é€€å½¹æŒ‡ä»¤çš„æ•°é‡ã€‚Î±ï¼Œ Î²ï¼Œ Î³ï¼Œ Î»æ˜¯ç”±å›¾å®éªŒæ•°æ®å¾—å‡ºçš„å¸¸æ•°ã€‚ è¿™é‡Œæˆ‘ä»¬è®¨è®ºæµ®ç‚¹æŒ‡ä»¤å¯¹åŠŸç‡å»ºæ¨¡çš„å½±å“ã€‚ç‹¬ç«‹çš„æµ®ç‚¹æŒ‡ä»¤å¯èƒ½æ¯”æ•´æ•°æ“ä½œæ¶ˆè€—æ›´å¤šçš„èƒ½é‡ã€‚å…·æœ‰é«˜æµ®ç‚¹æŒ‡ä»¤æ¯”ä¾‹çš„å·¥ä½œè´Ÿè½½å®é™…ä¸Šå¯èƒ½å¯¼è‡´æ•´ä½“åŠŸè€—è¾ƒä½ï¼Œå› ä¸ºåŠŸèƒ½å•å…ƒå¯èƒ½è¢«è¿«åœ¨ç®¡é“çš„ä¸åŒé˜¶æ®µå¤„äºç©ºé—²çŠ¶æ€ã€‚ä¸ºäº†å»ºç«‹ä¸€ä¸ªæ›´ç²¾ç»†çš„æ¨¡å‹ï¼Œæœ‰å¿…è¦è€ƒè™‘å¾®æ¶æ„ã€‚æˆ‘ä»¬è®¡åˆ’åœ¨ä»Šåçš„å·¥ä½œä¸­æœç€è¿™ä¸ªæ–¹å‘åŠªåŠ›ã€‚æ­¤å¤–ï¼ŒÎ±ã€Î²ã€Î³å‚æ•°çš„é€‰æ‹©ä¹Ÿå—ç»“æ„çš„å½±å“ã€‚è¿™æ ·çš„é—®é¢˜å¯ä»¥åœ¨æ¥ä¸‹æ¥çš„æ ¡å‡†æ­¥éª¤ä¸­å¾—åˆ°ç¼“è§£ã€‚ On-the-fly calibrationæˆ‘ä»¬çš„ç³»ç»Ÿè¿˜ä¸ºä¸»æœºçš„èƒ½é‡æ•°æ®å»ºæ¨¡ï¼Œå¹¶ä¸é€šè¿‡RAPLè·å¾—çš„å®é™…èƒ½é‡æ•°æ®è¿›è¡Œäº¤å‰éªŒè¯ã€‚ä¸ºäº†å°½é‡å‡å°å»ºæ¨¡æ•°æ®çš„è¯¯å·®ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸‹å¼å¯¹æ¯ä¸ªå®¹å™¨çš„å»ºæ¨¡èƒ½é‡æ•°æ®è¿›è¡Œæ ¡å‡†ã€‚Econtainerè¡¨ç¤ºè¿”å›ç»™æ¯ä¸ªå®¹å™¨çš„èƒ½é‡å€¼ã€‚è¿™ç§å®æ—¶æ ¡å‡†æ˜¯å¯¹RAPLæ¥å£çš„æ¯ä¸ªè¯»å–æ“ä½œè¿›è¡Œçš„ï¼Œå¯ä»¥æœ‰æ•ˆåœ°å‡å°‘å‰ä¸€æ­¥çš„é”™è¯¯æ•°é‡ã€‚ Defense Ecaluationæˆ‘ä»¬ä»ä¸‰ä¸ªæ–¹é¢è¯„ä¼°æœ¬åœ°æœºå™¨ä¸ŠåŸºäºåŠŸèƒ½çš„åç§°ç©ºé—´:å‡†ç¡®æ€§ã€å®‰å…¨æ€§å’Œæ€§èƒ½ã€‚æˆ‘ä»¬çš„æµ‹è¯•å¹³å°é…å¤‡äº†Intel i7-6700 3.40GHz 8æ ¸CPU, 16GB RAMï¼Œè¿è¡ŒUbuntu Linux 16.04ï¼Œå†…æ ¸ç‰ˆæœ¬ä¸º4.7.0ã€‚ Accuracyæˆ‘ä»¬ä½¿ç”¨SPECCPU2006åŸºå‡†æ¥æµ‹é‡powerå»ºæ¨¡çš„å‡†ç¡®æ€§ã€‚æˆ‘ä»¬å°†å»ºæ¨¡çš„powerä½¿ç”¨æƒ…å†µä¸é€šè¿‡RAPLè·å¾—çš„ground truthè¿›è¡Œæ¯”è¾ƒã€‚ åŠŸè€—ç­‰äºæ¯ç§’çš„èƒ½é‡æ¶ˆè€—ã€‚ç”±äºDockerå®¹å™¨çš„å®‰å…¨ç­–ç•¥çš„é™åˆ¶ï¼Œæˆ‘ä»¬é€‰æ‹©äº†SPECCPU2006åŸºå‡†æµ‹è¯•çš„ä¸€ä¸ªå­é›†ï¼Œè¿™äº›åŸºå‡†æµ‹è¯•å¯ä»¥åœ¨å®¹å™¨å†…è¿è¡Œï¼Œå¹¶ä¸”ä¸ç”¨äºåŠŸç‡å»ºæ¨¡çš„åŸºå‡†æµ‹è¯•æ²¡æœ‰é‡å ã€‚è¯¯å·®Î¾å®šä¹‰å¦‚ä¸‹: å…¶ä¸­ERAPLæ˜¯ä»ä¸»æœºä¸Šçš„RAPLè¯»å–çš„åŠŸè€—ï¼Œè€ŒMcontaineræ˜¯åœ¨å®¹å™¨ä¸­è¯»å–çš„ç›¸åŒå·¥ä½œè´Ÿè½½çš„å»ºæ¨¡åŠŸè€—ã€‚æ³¨æ„ï¼Œä¸»æœºå’Œå®¹å™¨éƒ½åœ¨ç©ºé—²çŠ¶æ€ä¸‹æ¶ˆè€—ç”µåŠ›ï¼Œå·®åˆ«å¾ˆå°ã€‚æˆ‘ä»¬ä½¿ç”¨å¸¸æ•°âˆ†diffä½œä¸ºä¿®é¥°ç¬¦ï¼Œåæ˜ ä¸»æœºå’Œå®¹å™¨åœ¨ç©ºé—²çŠ¶æ€ä¸‹çš„åŠŸè€—å·®å¼‚ã€‚ç»“æœå¦‚å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬çš„poweræ¨¡å‹æ˜¯å‡†ç¡®çš„ï¼Œå› ä¸ºæ‰€æœ‰æµ‹è¯•åŸºå‡†çš„è¯¯å·®å€¼éƒ½ä½äº0.05ã€‚ Securityæˆ‘ä»¬ä¹Ÿä»å®‰å…¨çš„è§’åº¦æ¥è¯„ä¼°æˆ‘ä»¬çš„ç³»ç»Ÿã€‚ å¯ç”¨äº†power-based namespaceåï¼Œå®¹å™¨åº”è¯¥åªæ£€ç´¢å®¹å™¨å†…æ¶ˆè€—çš„åŠŸç‡ï¼Œè€Œä¸çŸ¥é“ä¸»æœºçš„ç”µæºçŠ¶æ€ã€‚æˆ‘ä»¬åœ¨æµ‹è¯•å¹³å°ä¸­å¯åŠ¨ä¸¤ä¸ªå®¹å™¨è¿›è¡Œæ¯”è¾ƒã€‚æˆ‘ä»¬åœ¨ä¸€ä¸ªå®¹å™¨ä¸­è¿è¡ŒSPECCPU2006åŸºå‡†æµ‹è¯•ï¼Œå¹¶å°†å¦ä¸€ä¸ªå®¹å™¨é—²ç½®ã€‚æˆ‘ä»¬è®°å½•å®¹å™¨å’Œä¸»æœºçš„æ¯ç§’ç”¨ç”µé‡ã€‚å¦‚å›¾æ‰€ç¤º401.bzip2çš„ç»“æœã€‚æ‰€æœ‰å…¶ä»–åŸºå‡†æµ‹è¯•éƒ½è¡¨ç°å‡ºç±»ä¼¼çš„æ¨¡å¼ã€‚ å½“ä¸¤ä¸ªå®¹å™¨éƒ½æ²¡æœ‰å·¥ä½œè´Ÿè½½æ—¶ï¼Œå®ƒä»¬çš„åŠŸè€—ä¸ä¸»æœºçš„åŠŸè€—åŸºæœ¬ç›¸åŒï¼Œä»0åˆ°10sã€‚ä¸€æ—¦å®¹å™¨1åœ¨10så¯åŠ¨å·¥ä½œè´Ÿè½½ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°å®¹å™¨1å’Œä¸»æœºçš„åŠŸè€—åŒæ—¶æ¿€å¢ã€‚ä»10såˆ°60sï¼Œå®¹å™¨1å’Œä¸»æœºçš„åŠŸè€—åŸºæœ¬ä¸€è‡´ï¼Œè€Œå®¹å™¨2ä»ç„¶å¤„äºè¾ƒä½çš„åŠŸè€—æ°´å¹³ã€‚å®¹å™¨2ä¸çŸ¥é“æ•´ä¸ªç³»ç»Ÿçš„åŠŸç‡æ³¢åŠ¨ï¼Œå› ä¸ºåŸºäºpower-based namespaceå¼ºåˆ¶éš”ç¦»ã€‚è¿™è¡¨æ˜æˆ‘ä»¬çš„ç³»ç»Ÿèƒ½å¤Ÿæœ‰æ•ˆåœ°éš”ç¦»å’Œåˆ’åˆ†å¤šä¸ªå®¹å™¨çš„åŠŸè€—ã€‚å¦‚æœæ²¡æœ‰ç”µæºç›¸å…³çš„ä¿¡æ¯ï¼Œæ”»å‡»è€…å°†æ— æ³•å‘èµ·synergistic power attackã€‚ Performanceæˆ‘ä»¬ä½¿ç”¨UnixBenchæ¥æ¯”è¾ƒå¯ç”¨ç³»ç»Ÿå‰åçš„æ€§èƒ½å¼€é”€ã€‚è¡¨åˆ—å‡ºäº†æ‰€æœ‰ç»“æœã€‚ æ­£å¦‚ç»“æœæ‰€ç¤ºï¼Œè¯¸å¦‚Dhrystone(æµ‹è¯•æ•´æ•°å’Œå­—ç¬¦ä¸²æ“ä½œ)å’ŒWhetstone(æµ‹è¯•æµ®ç‚¹ç®—æœ¯æ€§èƒ½)è¿™æ ·çš„CPUåŸºå‡†æµ‹è¯•æ‰€äº§ç”Ÿçš„å¼€é”€å¯ä»¥å¿½ç•¥ä¸è®¡ã€‚ å…¶ä»–åŸºå‡†æµ‹è¯•ï¼Œå¦‚shellè„šæœ¬ã€ç®¡é“ååé‡å’Œç³»ç»Ÿè°ƒç”¨ï¼Œä¹Ÿä¼šè§¦å‘å¾ˆå°‘çš„å¼€é”€ã€‚ åœ¨ä¸€ä¸ªå¹¶è¡Œå‰¯æœ¬çš„æƒ…å†µä¸‹ï¼ŒåŸºäºç®¡é“çš„ä¸Šä¸‹æ–‡åˆ‡æ¢(pip-based context swtiching)ç¡®å®ä¼šäº§ç”Ÿ61.53%çš„å¼€é”€ï¼Œä½†åœ¨8ä¸ªå¹¶è¡Œå‰¯æœ¬æ—¶ï¼Œå®ƒä¼šå‡å°‘åˆ°1.63%ã€‚æˆ‘ä»¬é¢„è®¡inter-cgroup context switchingæ¶‰åŠå¯ç”¨&#x2F;ç¦ç”¨æ€§èƒ½äº‹ä»¶ç›‘è§†å™¨ï¼Œè€Œintra-cgroup context switchingä¸æ¶‰åŠä»»ä½•æ­¤ç±»å¼€é”€ã€‚ è¿™è§£é‡Šä¸ºä»€ä¹ˆåœ¨ç¦ç”¨power-based namespaceæƒ…å†µä¸‹ï¼Œ8ä¸ªå¹¶è¡Œå‰¯æœ¬å¯ä»¥ä¿æŒç›¸ä¼¼çš„æ€§èƒ½æ°´å¹³ã€‚æ­¤å¤–ï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢åªå æ•´ä¸ªç³»ç»Ÿæ€§èƒ½å¼€é”€çš„å¾ˆå°ä¸€éƒ¨åˆ†ï¼Œå› æ­¤å¯¹æ­£å¸¸ä½¿ç”¨çš„å½±å“å¾ˆå°ã€‚ åœ¨æˆ‘ä»¬çš„ç³»ç»Ÿä¸­ï¼Œå¯¹äºæ¯ä¸ªæ–°åˆ›å»ºçš„å®¹å™¨ï¼Œå†…æ ¸å°†åœ¨æ¯ä¸ªå†…æ ¸ä¸Šåˆ›å»ºå¤šä¸ªperf_eventsï¼Œä»¥æ”¶é›†ä¸æ€§èƒ½ç›¸å…³çš„æ•°æ®ã€‚æ­¤æµ‹é‡è¿‡ç¨‹ä»…å¯¹å®¹å™¨è¿‡ç¨‹è¿›è¡Œã€‚å› æ­¤ï¼Œæµ‹é‡å¼€é”€å°†éšç€å®¹å™¨æ•°é‡çš„å¢åŠ è€Œçº¿æ€§å¢åŠ ã€‚ä½†æ˜¯ï¼Œå®¹å™¨æ•°é‡çš„å¢åŠ å¯¹ç³»ç»Ÿçš„å½±å“å¾ˆå°ã€‚ä½¿ç”¨è¿™ç§æœºåˆ¶ï¼Œåœ¨åˆ›å»ºæ‰€æœ‰è¿›ç¨‹æ—¶ï¼Œå†…æ ¸ä¼šæ£€æŸ¥è¯¥è¿›ç¨‹æ˜¯å¦æ˜¯å®¹å™¨è¿›ç¨‹ã€‚è¿™ä¸ªæ£€æŸ¥è¿›ç¨‹æ˜¯UnixåŸºå‡†æµ‹è¯•ä¸­è¿›ç¨‹åˆ›å»ºå¼€é”€çš„ä¸»è¦åŸå› ã€‚ å¦‚è¡¨çš„æœ€åä¸€è¡Œæ‰€ç¤ºï¼ŒUnixBenchçš„æ€»ä½“æ€§èƒ½å¼€é”€å¯¹äºä¸€ä¸ªå¹¶è¡Œå‰¯æœ¬æ˜¯9.66%ï¼Œå¯¹äº8ä¸ªå¹¶è¡Œå‰¯æœ¬æ˜¯7.03%ã€‚ æˆ‘ä»¬çš„ç³»ç»Ÿæ€§èƒ½åœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šä¾èµ–äºperf_event cgroupçš„å®ç°ï¼Œå¹¶ä¸”å¯ä»¥éšç€æ€§èƒ½ç›‘è§†å­ç³»ç»Ÿçš„æ”¹è¿›è€Œæé«˜ã€‚ DiscussionSynnergistic Power Attack without the RAPL Channelæˆ‘ä»¬è¿˜æ³¨æ„åˆ°ï¼Œä¸€äº›å®¹å™¨äº‘ä¸­çš„æœåŠ¡å™¨æ²¡æœ‰é…å¤‡RAPLæˆ–å…¶ä»–ç±»ä¼¼çš„åµŒå…¥å¼power metersã€‚è¿™äº›æœåŠ¡å™¨ä»å¯èƒ½é¢ä¸´power attackã€‚å¦‚æœæ²¡æœ‰åƒRAPLè¿™æ ·çš„power-cappingå·¥å…·ï¼Œè¿™äº›æœåŠ¡å™¨åœ¨ä¸€å°æœºå™¨ä¸Šå¯èƒ½å®¹æ˜“å—åˆ°host-level power attacksã€‚ æ­¤å¤–ï¼Œå¦‚æœpower dataä¸èƒ½ç›´æ¥è·å¾—ï¼Œé«˜çº§æ”»å‡»è€…ä¼šå°è¯•æ ¹æ®èµ„æºåˆ©ç”¨ä¿¡æ¯(å¦‚CPUå’Œå†…å­˜åˆ©ç”¨ç‡)æ¥è¿‘ä¼¼ç”µæºçŠ¶æ€ï¼Œè¿™äº›ä¿¡æ¯åœ¨å·²è¯†åˆ«çš„ä¿¡æ¯æ³„æ¼ä¸­ä»ç„¶å¯ç”¨ã€‚æœ€å¥½è®©å®¹å™¨ç§Ÿæˆ·æ— æ³•ä½¿ç”¨ç³»ç»ŸèŒƒå›´çš„æ€§èƒ½ç»Ÿè®¡æ•°æ®ã€‚ Complete Container Implementationé€ æˆä¿¡æ¯æ³„æ¼å’Œsynergistic power attackçš„æ ¹æœ¬åŸå› æ˜¯Linuxå†…æ ¸ä¸­éš”ç¦»æœºåˆ¶çš„ä¸å®Œæ•´å®ç°ã€‚æœ€å¥½å¼•å…¥æ›´å¤šçš„å®‰å…¨ç‰¹æ€§ï¼Œæ¯”å¦‚å®ç°æ›´å¤šçš„namespaceå’Œcgroupã€‚ä½†æ˜¯ï¼Œä¸€äº›ç³»ç»Ÿèµ„æºä»ç„¶éš¾ä»¥åˆ†åŒºï¼Œå¦‚ä¸­æ–­ã€è°ƒåº¦ä¿¡æ¯ã€æ¸©åº¦ç­‰ã€‚äººä»¬è¿˜è®¤ä¸ºï¼Œå®Œæ•´çš„å®¹å™¨å®ç°ä¸è™šæ‹Ÿæœºæ²¡æœ‰ä»€ä¹ˆä¸åŒï¼Œå¹¶ä¸”å¤±å»äº†å®¹å™¨çš„æ‰€æœ‰ä¼˜ç‚¹ã€‚è¿™æ˜¯å®¹å™¨ä¹‹é—´çš„æƒè¡¡ã€‚å¦‚ä½•åœ¨å®¹å™¨äº‘ä¸­å¹³è¡¡å®‰å…¨æ€§ã€æ€§èƒ½å’Œå¯ç”¨æ€§çš„é—®é¢˜éœ€è¦è¿›ä¸€æ­¥ç ”ç©¶ã€‚ Related Workç”±äºå®¹å™¨æœ€è¿‘å˜å¾—æµè¡Œï¼Œç ”ç©¶äººå‘˜å¯¹å®¹å™¨å’Œç¡¬ä»¶è™šæ‹ŸåŒ–ä¹‹é—´çš„æ€§èƒ½æ¯”è¾ƒæ„Ÿåˆ°å¥½å¥‡ã€‚Felterç­‰äººé€šè¿‡ä½¿ç”¨ä¸€å¥—æ¶µç›–CPUã€å†…å­˜ã€å­˜å‚¨å’Œç½‘ç»œèµ„æºçš„åŸºå‡†æµ‹è¯•æ¥æ¯”è¾ƒDockerå’ŒKVMçš„æ€§èƒ½ã€‚ä»–ä»¬çš„ç»“æœæ˜¾ç¤ºï¼ŒDockeråœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½èƒ½è¾¾åˆ°ä¸KVMç›¸åŒæˆ–æ›´å¥½çš„æ€§èƒ½ã€‚Spoialaç­‰äººä½¿ç”¨Kurentoåª’ä½“æœåŠ¡å™¨æ¥æ¯”è¾ƒDockerå’ŒKVMä¸Šçš„WebRTCæœåŠ¡å™¨çš„æ€§èƒ½ã€‚ä»–ä»¬è¿˜è¯æ˜äº†Dockerçš„æ€§èƒ½ä¼˜äºKVMï¼Œå¯ä»¥æ”¯æŒå®æ—¶åº”ç”¨ã€‚Morabitoç­‰äººæ¯”è¾ƒäº†ä¼ ç»Ÿç®¡ç†ç¨‹åºå’Œæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–åœ¨è®¡ç®—ã€å­˜å‚¨ã€å†…å­˜å’Œç½‘ç»œæ–¹é¢çš„æ€§èƒ½ã€‚ä»–ä»¬å¯¹Dockerã€LXCå’ŒKVMè¿›è¡Œäº†å®éªŒï¼Œè§‚å¯Ÿåˆ°ç£ç›˜I&#x2F;Oä»ç„¶æ˜¯KVMç®¡ç†ç¨‹åºçš„ç“¶é¢ˆã€‚æ‰€æœ‰è¿™äº›å·¥ä½œéƒ½è¡¨æ˜ï¼ŒåŸºäºå®¹å™¨çš„æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–å¯ä»¥å®ç°æ¯”ç¡¬ä»¶è™šæ‹ŸåŒ–æ›´é«˜çš„æ€§èƒ½ã€‚é™¤äº†æ€§èƒ½ï¼Œå®¹å™¨äº‘çš„å®‰å…¨æ€§å§‹ç»ˆæ˜¯ä¸€ä¸ªé‡è¦çš„ç ”ç©¶é¢†åŸŸã€‚Guptaç®€è¦ä»‹ç»äº†Dockerçš„å®‰å…¨æ€§ã€‚Buiä¹Ÿå¯¹Dockerå®¹å™¨è¿›è¡Œäº†åˆ†æï¼ŒåŒ…æ‹¬éš”ç¦»é—®é¢˜å’Œç›¸åº”çš„å†…æ ¸å®‰å…¨æœºåˆ¶ã€‚ä»–ä»¬å£°ç§°ï¼ŒDockerå®¹å™¨åœ¨é»˜è®¤é…ç½®ä¸‹æ˜¯ç›¸å½“å®‰å…¨çš„ã€‚Grattafioriç­‰äººæ€»ç»“äº†å®¹å™¨çš„å„ç§æ½œåœ¨æ¼æ´ã€‚ä»–ä»¬è¿˜æåˆ°äº†åŸºäºå†…å­˜çš„ä¼ªæ–‡ä»¶ç³»ç»Ÿä¸­çš„å‡ ä¸ªé€šé“ã€‚Luoç­‰äººè¯æ˜äº†é”™è¯¯é…ç½®çš„èƒ½åŠ›å¯ä»¥è¢«åˆ©ç”¨æ¥åœ¨Dockerä¸­å»ºç«‹éšè”½çš„é€šé“ã€‚ä¹‹å‰å…³äºå®¹å™¨çš„æ€§èƒ½å’Œå®‰å…¨æ€§çš„ç ”ç©¶å·¥ä½œé¼“åŠ±æˆ‘ä»¬æ›´å¤šåœ°ç ”ç©¶å®¹å™¨å¦‚ä½•èƒ½å¤Ÿå®ç°ä¸ç¡¬ä»¶è™šæ‹ŸåŒ–ç›¸åŒçš„å®‰å…¨ä¿è¯ï¼Œä½†åœ¨æ€§èƒ½æ–¹é¢çš„æŠ˜è¡·å´å¾®ä¸è¶³é“ã€‚æˆ‘ä»¬æ˜¯ç¬¬ä¸€æ‰¹ç³»ç»Ÿåœ°è¯†åˆ«å®¹å™¨ä¸­çš„ä¿¡æ¯æ³„éœ²é—®é¢˜ï¼Œå¹¶ç ”ç©¶å»ºç«‹åœ¨è¿™äº›æ³„æ¼æ¸ é“çš„åŸºäºå®¹å™¨çš„æ½œåœ¨çš„power attcakã€‚ Cloud Security and Side&#x2F;Covert Channel Attacksäº‘å®‰å…¨å·²ç»å—åˆ°å­¦æœ¯ç•Œå’Œä¸šç•Œçš„å¹¿æ³›å…³æ³¨ã€‚äº‘ç¯å¢ƒä¸‹çš„co-residenceæ£€æµ‹æ˜¯ä¸æˆ‘ä»¬å·¥ä½œæœ€å¯†åˆ‡ç›¸å…³çš„ç ”ç©¶è¯¾é¢˜ã€‚co-residenceæ£€æµ‹æœ€æ—©ç”±Ristenpartç­‰äººæå‡ºã€‚ä»–ä»¬è¯æ˜ï¼Œæ”»å‡»è€…å¯ä»¥å°†æ¶æ„VMä¸ç›®æ ‡VM co-residence åœ¨åŒä¸€æœåŠ¡å™¨ä¸Šï¼Œç„¶åå‘èµ·ä¾§é€šé“å’Œéšè”½é€šé“æ”»å‡»ã€‚åœ¨ç°æœ‰ä¸»æµäº‘æœåŠ¡ä¸­å®ç°co-residenceä»ç„¶æ˜¯å¯è¡Œçš„ã€‚ä¸ºäº†éªŒè¯åœ¨åŒä¸€ç‰©ç†æœåŠ¡å™¨ä¸Šçš„co-residenceï¼Œæ”»å‡»è€…é€šå¸¸åˆ©ç”¨ä¾§é€šé“æˆ–éšè”½é€šé“ï¼Œä¾‹å¦‚ï¼Œä¸€ç§å¹¿æ³›é‡‡ç”¨çš„æ–¹æ³•æ˜¯ä½¿ç”¨cahe-based channelã€‚ä½äºåŒä¸€ä¸ªåŒ…ä¸Šçš„å¤šä¸ªå®ä¾‹å…±äº«æœ€åä¸€çº§ç¼“å­˜ã€‚é€šè¿‡ä½¿ç”¨ä¸€äº›ä¸“ç”¨çš„æ“ä½œ(å¦‚cflush)ï¼Œæ”»å‡»è€…å¯ä»¥é€šè¿‡æµ‹é‡ç¼“å­˜è®¿é—®æ—¶é—´æ¥æ£€æµ‹å…±é©»ç•™ã€‚Liuç­‰è¯æ˜äº†l3ç¼“å­˜ä¾§é€šé“æ”»å‡»å¯¹äºè·¨æ ¸å’Œè·¨vmæ”»å‡»æ˜¯å¯è¡Œçš„ã€‚Zhangç­‰äººå¯¹äº‘è¿›è¡Œäº†çœŸå®çš„ä¾§é€šé“æ”»å‡»ï¼Œå¹¶æå‡ºäº†å‡ ç§é˜²å¾¡æœºåˆ¶æ¥ç¼“è§£è¿™äº›æ”»å‡»ã€‚ç‰¹åˆ«æ˜¯ï¼Œä»–ä»¬è¯æ˜äº†è·¨ç§Ÿæˆ·ä¾§é€šé“æ”»å‡»å¯ä»¥æˆåŠŸåœ°åœ¨PaaSä¸­ä½¿ç”¨å…±å­˜æœåŠ¡å™¨è¿›è¡Œã€‚é™¤äº†åŸºäºç¼“å­˜çš„é€šé“å¤–ï¼Œå†…å­˜æ€»çº¿å’Œå†…å­˜é‡å¤æ•°æ®åˆ é™¤ä¹Ÿå·²è¢«è¯æ˜æ˜¯æ„é€ éšè”½é€šé“çš„æœ‰æ•ˆæ–¹æ³•ã€‚ä¸ç°æœ‰çš„ä¾§&#x2F;éšè”½é€šé“ç ”ç©¶å·¥ä½œä¸åŒï¼Œæˆ‘ä»¬åœ¨å®¹å™¨äº‘è®¾ç½®ä¸­å‘ç°äº†ç³»ç»ŸèŒƒå›´çš„ä¿¡æ¯æ³„æ¼ï¼Œå¹¶è®¾è®¡äº†ä¸€ç§æ–°çš„æ–¹æ³•æ¥å®šé‡è¯„ä¼°æ³„æ¼é€šé“çš„å®¹é‡ï¼Œä»¥ç”¨äºå…±å±…æ£€æµ‹ã€‚å¦å¤–ï¼Œä¸æœ€å°åŒ–è™šæ‹Ÿæœºçš„å†…æ ¸æ”»å‡»é¢ç ”ç©¶ç›¸æ¯”ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ç§ä¸¤çº§é˜²å¾¡æœºåˆ¶ï¼Œä»¥æœ€å°åŒ–å®¹å™¨äº‘ä¸Šçš„ä¿¡æ¯æ³„æ¼å’Œç”µæºæ”»å‡»ç©ºé—´ã€‚ ç³»ç»ŸçŠ¶æ€ä¿¡æ¯ï¼Œå¦‚æ ¸å¿ƒæ¸©åº¦å’Œç³»ç»ŸåŠŸè€—ï¼Œä¹Ÿè¢«ç”¨äºæ„å»ºä¾§&#x2F;éšè”½é€šé“ã€‚Thieleç­‰æå‡ºäº†ä¸€ç§åŸºäºæ¯ä¸ªæ ¸å¿ƒæ¸©åº¦çš„çƒ­éšè”½é€šé“ï¼Œå¹¶åœ¨å±€éƒ¨è¯•éªŒå°æµ‹è¯•äº†å®¹é‡ã€‚åŠŸè€—ä¹Ÿå¯èƒ½è¢«æ»¥ç”¨æ¥ç ´åAESã€‚åœ¨å·¥ä½œä¸­ï¼Œæˆ‘ä»¬ä¸ä½¿ç”¨åŠŸè€—æ•°æ®ä½œä¸ºä¼ é€’ä¿¡æ¯çš„éšè”½é€šé“ã€‚ç›¸åï¼Œæˆ‘ä»¬è¯æ˜äº†å¯¹æ‰‹å¯ä»¥åˆ©ç”¨ä¸»æœºåŠŸè€—æ³„æ¼æ¥å‘èµ·æ›´é«˜çº§çš„power attackã€‚ Power Modelingåœ¨æ²¡æœ‰hardware-based power meterçš„æƒ…å†µä¸‹ï¼Œpower modelingæ˜¯é€¼è¿‘åŠŸè€—çš„ä¸€ç§æ–¹æ³•ã€‚ Russellç­‰å’ŒChakrabartiç­‰æå‡ºäº†æŒ‡ä»¤çº§åŠŸç‡å»ºæ¨¡ã€‚ä»–ä»¬çš„å·¥ä½œè¡¨æ˜ï¼Œåˆ†æ”¯çš„æ•°é‡å½±å“åŠŸè€—ã€‚å¯¹è™šæ‹ŸæœºåŠŸè€—çš„è¿‘ä¼¼ç ”ç©¶æœ‰å‡ ç§ã€‚æœ‰å·¥ä½œè¯æ˜äº†VMçº§çš„åŠŸè€—å¯ä»¥é€šè¿‡CPUåˆ©ç”¨ç‡å’Œæœ€åä¸€çº§ç¼“å­˜å¤±è¯¯ç‡æ¥ä¼°è®¡ã€‚Mobiusç­‰å°†VMçš„åŠŸè€—åˆ†ä¸ºCPUã€ç¼“å­˜ã€å†…å­˜å’Œç£ç›˜ã€‚BITWATTSåœ¨ç»†ç²’åº¦æµç¨‹çº§åˆ«ä¸Šå¯¹åŠŸè€—è¿›è¡Œäº†å»ºæ¨¡ã€‚Shenç­‰æå‡ºäº†ä¸€ç§powerå®¹å™¨æ¥è®¡ç®—å¤šæ ¸ç³»ç»Ÿä¸­è¯·æ±‚çš„èƒ½é‡æ¶ˆè€—ã€‚æˆ‘ä»¬å¯¹synergisticçš„é˜²å¾¡ä¸»è¦æ˜¯å—åˆ°power modeling approach for VMsçš„å¯å‘ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°çš„poweråˆ†åŒºæŠ€æœ¯æ¥è¿‘ä¼¼æ¯ä¸ªå®¹å™¨çš„åŠŸè€—å¹¶é‡ç”¨RAPLæ¥å£ï¼Œä»è€Œè§£å†³äº†å®¹å™¨è®¾ç½®ä¸­çš„RAPLæ•°æ®æ³„æ¼é—®é¢˜ã€‚ Conlusionå®¹å™¨äº‘æœåŠ¡å› æä¾›è½»é‡çº§æ“ä½œç³»ç»Ÿçº§è™šæ‹Ÿä¸»æœºç¯å¢ƒè€Œå˜å¾—æµè¡Œèµ·æ¥ã€‚å®¹å™¨æŠ€æœ¯çš„å‡ºç°æ·±åˆ»åœ°æ”¹å˜äº†åœ¨äº‘ä¸­å¼€å‘å’Œéƒ¨ç½²åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºçš„ç”Ÿæ€ç³»ç»Ÿã€‚ä½†æ˜¯ï¼Œç”±äºLinuxå†…æ ¸ä¸­ç³»ç»Ÿèµ„æºåˆ†åŒºæœºåˆ¶çš„ä¸å®Œå…¨å®ç°ï¼Œå¯¹äºå…±äº«åŒä¸€ä¸ªå†…æ ¸çš„å¤šä¸ªå®¹å™¨ç§Ÿæˆ·ä»ç„¶å­˜åœ¨ä¸€äº›å®‰å…¨é—®é¢˜ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆæå‡ºäº†ä¸€ç§ç³»ç»Ÿçš„æ–¹æ³•æ¥å‘ç°å¯èƒ½å°†ä¸»æœºä¿¡æ¯æš´éœ²ç»™å®¹å™¨çš„ä¿¡æ¯æ³„æ¼é€šé“ã€‚é€šè¿‡åˆ©ç”¨è¿™äº›æ³„éœ²çš„ä¸»æœºä¿¡æ¯ï¼Œæ¶æ„å®¹å™¨ç§Ÿæˆ·å¯ä»¥å‘èµ·ä¸€ç§æ–°å‹çš„power attackï¼Œè¿™å¯èƒ½ä¼šå±åŠæ•°æ®ä¸­å¿ƒç”µæºç³»ç»Ÿçš„å¯é æ€§ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è®¨è®ºäº†è¿™äº›ä¿¡æ¯æ³„æ¼çš„æ ¹æœ¬åŸå› ï¼Œå¹¶æå‡ºäº†ä¸€ä¸ªä¸¤é˜¶æ®µçš„é˜²å¾¡æœºåˆ¶ã€‚æˆ‘ä»¬çš„è¯„ä¼°è¡¨æ˜ï¼Œæ‰€æå‡ºçš„è§£å†³æ–¹æ¡ˆæ˜¯æœ‰æ•ˆçš„ï¼Œå¹¶å¼•èµ·å¾®ä¸è¶³é“çš„æ€§èƒ½å¼€é”€ã€‚ MyLinuxçš„incomplete coverageLinuxå†…æ ¸æä¾›äº†å¯¹å„ç§å®¹å™¨åŒ–æŠ€æœ¯çš„æ”¯æŒï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿåœ¨å•ä¸ªä¸»æœºä¸Šè¿è¡Œå¤šä¸ªéš”ç¦»ç¯å¢ƒã€‚Linuxå†…æ ¸ä¸­çš„å®¹å™¨å®ç°ä¸»è¦åˆ©ç”¨ä¸€ç»„ç‰¹æ€§ï¼Œå¦‚namespaceã€cgroupå’Œseccompã€‚ç„¶è€Œï¼Œåœ¨Linuxå†…æ ¸ä¸­ï¼Œå®¹å™¨å®ç°çš„æŸäº›æ–¹é¢å¯èƒ½æ˜¯ä¸å®Œæ•´æˆ–æœ‰é™åˆ¶çš„ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›æ½œåœ¨çš„incomplete coverageèŒƒå›´ï¼š namespaceï¼šé€šè¿‡åˆ›å»ºç³»ç»Ÿèµ„æºçš„åˆ†ç¦»è§†å›¾æ¥ä¸ºå®¹å™¨æä¾›éš”ç¦»ã€‚è™½ç„¶Linuxå†…æ ¸æ”¯æŒå‡ ç§å‘½åç©ºé—´ï¼ˆmoutã€PIDã€NETã€IPCã€UTSå’Œuserï¼‰ï¼Œä½†æŸäº›èµ„æºç±»å‹å¯èƒ½æ²¡æœ‰ç›¸åº”çš„å‘½åç©ºé—´æˆ–å…·æœ‰æœ‰é™çš„æ”¯æŒï¼Œè¿™å¯èƒ½å¯¼è‡´ä¸å®Œå…¨éš”ç¦»ã€‚ control groupsï¼ˆcgroupsï¼‰ï¼šCgroupsç”¨äºé™åˆ¶ã€è®°å½•å’Œéš”ç¦»è¿›ç¨‹ç»„ä½¿ç”¨èµ„æºï¼ˆCPUã€å†…å­˜ã€I&#x2F;Oç­‰ï¼‰ã€‚è™½ç„¶å­˜åœ¨cgroups v1å’Œv2ï¼Œä½†æŸäº›åŠŸèƒ½å¯èƒ½æ— æ³•åœ¨ä¸¤ä¸ªç‰ˆæœ¬ä¹‹é—´å¾—åˆ°å……åˆ†æ”¯æŒæˆ–å…·æœ‰å±€é™æ€§ã€‚è¿™ä¼šå¯¼è‡´å®¹å™¨èµ„æºç®¡ç†ä¸å®Œæ•´æˆ–ä¸ä¸€è‡´ã€‚ å®‰å…¨æ€§ï¼šLinuxå†…æ ¸æä¾›äº†è¯¸å¦‚seccompã€AppArmorå’ŒSELinuxä¹‹ç±»çš„å®‰å…¨æœºåˆ¶æ¥å¼ºåˆ¶è®¿é—®æ§ä»¶å¹¶é™åˆ¶å®¹å™¨å¯ä»¥è¿›è¡Œå“ªäº›ç³»ç»Ÿè°ƒç”¨ã€‚ä½†æ˜¯ï¼Œè¿™äº›æœºåˆ¶å¯èƒ½å­˜åœ¨æ¼æ´æˆ–é™åˆ¶ï¼Œå¯èƒ½ä¼šæš´éœ²æ½œåœ¨çš„å®‰å…¨é£é™©ã€‚ å…¼å®¹æ€§ï¼šå®¹å™¨å®ç°çš„æŸäº›åŠŸèƒ½ï¼ˆå¦‚æ–‡ä»¶ç³»ç»Ÿå¿«ç…§æˆ–æ£€æŸ¥ç‚¹&#x2F;æ¢å¤ï¼‰å¯èƒ½å–å†³äºç‰¹å®šçš„å†…æ ¸ç‰ˆæœ¬ã€å­˜å‚¨é©±åŠ¨ç¨‹åºæˆ–æ–‡ä»¶ç³»ç»Ÿã€‚è¿™å¯èƒ½å¯¼è‡´åœ¨æŸäº›é…ç½®ä¸Šå‡ºç°å…¼å®¹æ€§é—®é¢˜å’Œé™åˆ¶ã€‚ æ€§èƒ½ï¼šè™½ç„¶Linuxå†…æ ¸ä¸ºå®¹å™¨å·¥ä½œè´Ÿè½½æä¾›äº†å„ç§ä¼˜åŒ–ï¼Œä½†ä»æœ‰ä¸€äº›é¢†åŸŸå¯ä»¥æ”¹è¿›ï¼Œä¾‹å¦‚å­˜å‚¨I&#x2F;Oæˆ–ç½‘ç»œååé‡ã€‚ å†…æ ¸æ›´æ–°ï¼šéšç€æ–°åŠŸèƒ½å’Œæ”¹è¿›è¢«æ·»åŠ åˆ°Linuxå†…æ ¸ä¸­ï¼Œå®¹å™¨å®ç°å¯èƒ½éœ€è¦æ›´æ–°ä»¥åˆ©ç”¨è¿™äº›å¢å¼ºåŠŸèƒ½ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´å®¹å™¨æ”¯æŒæ–¹é¢å­˜åœ¨å·®è·ï¼Œç›´åˆ°å®ƒä»¬ä¸æ–°çš„å†…æ ¸ç‰¹æ€§å®Œå…¨é›†æˆå¹¶è¿›è¡Œæµ‹è¯•ã€‚ å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒLinuxå†…æ ¸æ­£åœ¨ç§¯æå¼€å‘ä¸­ï¼Œå¹¶ä¸”å¯¹äºå®¹å™¨æ”¯æŒçš„æ”¹è¿›ä¸æ–­è¢«æå‡ºå’Œå®æ–½ã€‚æ­¤å¤–ï¼ŒåƒDockerã€Kuberneteså’ŒLXCä¹‹ç±»çš„å®¹å™¨åŒ–è§£å†³æ–¹æ¡ˆå»ºç«‹åœ¨è¿™äº›å†…æ ¸ç‰¹æ€§ä¹‹ä¸Šï¼Œå¹¶æä¾›æ›´å®Œæ•´ã€æ— ç¼çš„ç”¨æˆ·ä½“éªŒã€‚ æ•°æ®ä¸­å¿ƒçš„oversubscriptionç”µåŠ›è¶…é¢è®¢é˜…æ˜¯æ•°æ®ä¸­å¿ƒä½¿ç”¨çš„ä¸€ç§ç­–ç•¥ï¼Œå…¶ä¸­åˆ†é…ç»™æœåŠ¡å™¨ã€å­˜å‚¨ç³»ç»Ÿå’Œç½‘ç»œè®¾å¤‡çš„æ€»ç”µæºä¾›åº”è¶…è¿‡å®é™…å¯ç”¨ç”µæºä¾›åº”ã€‚è¿™ç§æ–¹æ³•åŸºäºä¸€ä¸ªè§‚å¯Ÿç»“æœï¼šå¹¶éæ‰€æœ‰è®¾å¤‡åŒæ—¶æ¶ˆè€—å…¶æœ€å¤§é¢å®šåŠŸç‡ã€‚é€šè¿‡åˆ©ç”¨è¿™ä¸€ç‚¹ï¼Œæ•°æ®ä¸­å¿ƒå¯ä»¥æ‰˜ç®¡æ¯”å…¶ç”µåŠ›åŸºç¡€è®¾æ–½å…è®¸æ›´å¤šçš„æœåŠ¡å™¨å’Œè®¾å¤‡ã€‚ Linuxå­ç³»ç»ŸLinuxå­ç³»ç»Ÿæ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œè´Ÿè´£å¤„ç†ç‰¹å®šåŠŸèƒ½æˆ–è®¾å¤‡ã€‚ä¾‹å¦‚ï¼Œæ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œåè®®æ ˆã€è¿›ç¨‹è°ƒåº¦ç­‰éƒ½å¯ä»¥è¢«è®¤ä¸ºæ˜¯Linuxå­ç³»ç»Ÿã€‚å®ƒä»¬é€šå¸¸ä»¥æ¨¡å—çš„å½¢å¼å®ç°ï¼Œå¹¶åœ¨è¿è¡Œæ—¶åŠ è½½åˆ°å†…æ ¸ä¸­ã€‚è¿™äº›å­ç³»ç»Ÿå…è®¸Linuxå†…æ ¸ä¸ç¡¬ä»¶å’Œå¤–éƒ¨èµ„æºè¿›è¡Œäº¤äº’ï¼Œä»¥ä¾¿ä¸ºä¸Šå±‚åº”ç”¨ç¨‹åºæä¾›æ‰€éœ€çš„åŠŸèƒ½ã€‚ æ‰§è¡Œä¸Šä¸‹æ–‡æ‰§è¡Œä¸Šä¸‹æ–‡æ˜¯æ“ä½œç³»ç»Ÿåœ¨è¿è¡ŒæŸä¸ªä»»åŠ¡æ—¶çš„ç¯å¢ƒï¼Œå®ƒåŒ…æ‹¬ä¸€ä¸ªä»»åŠ¡æ‰€éœ€çš„æ‰€æœ‰çŠ¶æ€ä¿¡æ¯ã€‚è¿™åŒ…æ‹¬ç¨‹åºè®¡æ•°å™¨ã€å †æ ˆæŒ‡é’ˆã€å¯„å­˜å™¨å€¼ã€å†…å­˜åˆ†é…ä¿¡æ¯ç­‰ã€‚æ‰§è¡Œä¸Šä¸‹æ–‡ä½¿å¾—æ“ä½œç³»ç»Ÿèƒ½å¤Ÿåœ¨å¤šä¸ªä»»åŠ¡ä¹‹é—´è¿›è¡Œåˆ‡æ¢ï¼Œä»¥å®ç°å¤šä»»åŠ¡å¹¶å‘æ‰§è¡Œã€‚ Linuxå­ç³»ç»Ÿä¸èƒ½åŒºåˆ†å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œå¯èƒ½æ³„éœ²ç³»ç»Ÿä¿¡æ¯å®¹å™¨æ˜¯ä¸€ç§è½»é‡çº§çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œå…è®¸åœ¨åŒä¸€ä¸»æœºä¸Šè¿è¡Œå¤šä¸ªéš”ç¦»çš„åº”ç”¨ç¨‹åºã€‚å®¹å™¨ä¸ä¸»æœºå…±äº«ç›¸åŒçš„å†…æ ¸ï¼Œä½†æ¯ä¸ªå®¹å™¨éƒ½æœ‰å…¶ç‹¬ç«‹çš„æ–‡ä»¶ç³»ç»Ÿã€è¿›ç¨‹ç©ºé—´ã€ç½‘ç»œæ¥å£ç­‰ã€‚å®¹å™¨æŠ€æœ¯çš„ä¸€ä¸ªå…³é”®ä¼˜åŠ¿æ˜¯èµ„æºéš”ç¦»ï¼Œè¿™æ„å‘³ç€æ¯ä¸ªå®¹å™¨åªèƒ½è®¿é—®åˆ†é…ç»™å®ƒçš„èµ„æºï¼Œè€Œä¸èƒ½è®¿é—®å…¶ä»–å®¹å™¨æˆ–ä¸»æœºçš„èµ„æºã€‚ ç„¶è€Œï¼ŒæŸäº›Linuxå­ç³»ç»Ÿå¯èƒ½æ— æ³•åŒºåˆ†å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚è¿™æ„å‘³ç€å½“å®¹å™¨åŒ–åº”ç”¨ç¨‹åºè®¿é—®è¿™äº›å­ç³»ç»Ÿæ—¶ï¼Œå®ƒä»¬å¯èƒ½èƒ½å¤Ÿè®¿é—®ä¸åº”æš´éœ²ç»™å®ƒä»¬çš„ç³»ç»ŸèŒƒå›´ä¿¡æ¯ã€‚è¿™å¯èƒ½å¯¼è‡´å®‰å…¨å’Œéšç§é—®é¢˜ï¼Œå› ä¸ºå®¹å™¨ä¹‹é—´å’Œå®¹å™¨ä¸ä¸»æœºä¹‹é—´çš„éš”ç¦»å¯èƒ½è¢«ç ´åã€‚ ä¾‹å¦‚ï¼Œå¦‚æœæŸä¸ªLinuxå­ç³»ç»Ÿè´Ÿè´£å¤„ç†ç³»ç»ŸèŒƒå›´çš„ç»Ÿè®¡ä¿¡æ¯ï¼ˆå¦‚CPUä½¿ç”¨ç‡ã€å†…å­˜ä½¿ç”¨æƒ…å†µç­‰ï¼‰ï¼Œé‚£ä¹ˆå®¹å™¨å†…çš„åº”ç”¨ç¨‹åºå¯èƒ½èƒ½å¤Ÿè®¿é—®è¿™äº›ä¿¡æ¯ï¼Œä»è€Œè·å–å…¶ä»–å®¹å™¨æˆ–ä¸»æœºçš„èµ„æºä½¿ç”¨æƒ…å†µã€‚è¿™å¯èƒ½å¯¼è‡´å®¹å™¨ä¹‹é—´çš„ä¿¡æ¯æ³„éœ²ï¼Œç ´åäº†å®ƒä»¬ä¹‹é—´çš„éš”ç¦»ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå®¹å™¨è¿è¡Œæ—¶å’Œå†…æ ¸å¼€å‘äººå‘˜éœ€è¦ç¡®ä¿æ‰€æœ‰Linuxå­ç³»ç»Ÿéƒ½èƒ½å¤Ÿæ­£ç¡®åœ°åŒºåˆ†å®¹å™¨å’Œä¸»æœºä¹‹é—´çš„æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œä»¥å®ç°æ›´å¼ºå¤§çš„éš”ç¦»å’Œå®‰å…¨æ€§ã€‚è¿™å¯èƒ½åŒ…æ‹¬ä¿®æ”¹å­ç³»ç»Ÿçš„å®ç°ï¼Œä»¥ä¾¿å®ƒä»¬èƒ½å¤Ÿè¯†åˆ«å’Œå¤„ç†æ¥è‡ªå®¹å™¨çš„è¯·æ±‚ï¼Œä»¥åŠé™åˆ¶å®¹å™¨è®¿é—®ç³»ç»ŸèŒƒå›´ä¿¡æ¯çš„èƒ½åŠ›ã€‚ Namespaceå’Œcgroupä»¥åŠå…·ä½“å®ç°Linuxä¸­çš„Namespaceå’ŒCgroupæ˜¯ä¸¤ç§æ“ä½œç³»ç»Ÿçº§åˆ«çš„èµ„æºç®¡ç†å’Œéš”ç¦»æŠ€æœ¯ã€‚å®ƒä»¬åœ¨å®¹å™¨æŠ€æœ¯ï¼ˆå¦‚Dockerï¼‰ä¸­è¢«å¹¿æ³›åº”ç”¨ï¼Œç”¨äºå®ç°è½»é‡çº§è™šæ‹ŸåŒ–ã€‚ Namespaceï¼ˆå‘½åç©ºé—´ï¼‰ æ˜¯Linuxå†…æ ¸æä¾›çš„ä¸€ç§éš”ç¦»æŠ€æœ¯ï¼Œå…è®¸åˆ›å»ºå¤šä¸ªç‹¬ç«‹çš„ç©ºé—´ï¼Œæ¯ä¸ªç©ºé—´å†…å¯ä»¥æœ‰è‡ªå·±çš„è¿›ç¨‹ã€æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œç­‰èµ„æºã€‚Namespaceæœ‰ä»¥ä¸‹å‡ ç§ç±»å‹ï¼š Mount Namespaceï¼šéš”ç¦»ä¸åŒå‘½åç©ºé—´çš„æ–‡ä»¶ç³»ç»ŸæŒ‚è½½ç‚¹ã€‚ PID Namespaceï¼šéš”ç¦»è¿›ç¨‹IDç©ºé—´ï¼Œä½¿æ¯ä¸ªå‘½åç©ºé—´æœ‰ç‹¬ç«‹çš„PIDã€‚ Network Namespaceï¼šéš”ç¦»ç½‘ç»œæ¥å£å’Œè·¯ç”±è¡¨ï¼Œä½¿æ¯ä¸ªå‘½åç©ºé—´æœ‰ç‹¬ç«‹çš„ç½‘ç»œç¯å¢ƒã€‚ IPC Namespaceï¼šéš”ç¦»System V IPCå¯¹è±¡å’ŒPOSIXæ¶ˆæ¯é˜Ÿåˆ—ã€‚ UTS Namespaceï¼šéš”ç¦»ä¸»æœºåå’ŒåŸŸåã€‚ User Namespaceï¼šéš”ç¦»ç”¨æˆ·å’Œç»„IDã€‚ Cgroupï¼ˆæ§åˆ¶ç»„ï¼‰ æ˜¯Linuxå†…æ ¸æä¾›çš„ä¸€ç§èµ„æºç®¡ç†æŠ€æœ¯ï¼Œå…è®¸å¯¹ä¸€ç»„è¿›ç¨‹è¿›è¡Œèµ„æºé™åˆ¶ã€ä¼˜å…ˆçº§è°ƒæ•´ç­‰æ“ä½œã€‚Cgroupé€šè¿‡å°†è¿›ç¨‹ç»„ç»‡åˆ°å±‚æ¬¡ç»“æ„çš„æ§åˆ¶ç»„ä¸­æ¥å®ç°èµ„æºç®¡ç†ã€‚ä¸»è¦æœ‰ä»¥ä¸‹å‡ ç±»èµ„æºæ§åˆ¶ï¼š CPUï¼šé™åˆ¶è¿›ç¨‹çš„CPUä½¿ç”¨ç‡ã€‚ Memoryï¼šé™åˆ¶è¿›ç¨‹çš„å†…å­˜ä½¿ç”¨ã€‚ Block I&#x2F;Oï¼šé™åˆ¶è¿›ç¨‹çš„ç£ç›˜I&#x2F;Oã€‚ Networkï¼šé™åˆ¶è¿›ç¨‹çš„ç½‘ç»œå¸¦å®½ã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„Namespaceå’ŒCgroupçš„ä½¿ç”¨ç¤ºä¾‹ï¼š å®‰è£…ç›¸å…³å·¥å…·ï¼š 1sudo apt-get install cgroup-tools åˆ›å»ºä¸€ä¸ªæ–°çš„Namespaceï¼ˆä½¿ç”¨unshareå‘½ä»¤ï¼‰ï¼š 1sudo unshare --uts --pid --mount-proc --fork /bin/bash è¿™ä¸ªå‘½ä»¤åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„Namespaceï¼Œå¹¶åœ¨å…¶ä¸­å¯åŠ¨äº†ä¸€ä¸ªæ–°çš„bashè¿›ç¨‹ã€‚è¿™ä¸ªæ–°çš„Namespaceå…·æœ‰ç‹¬ç«‹çš„UTSã€PIDå’ŒæŒ‚è½½çš„&#x2F;procæ–‡ä»¶ç³»ç»Ÿã€‚ åˆ›å»ºä¸€ä¸ªæ–°çš„Cgroupï¼ˆä½¿ç”¨cgcreateå‘½ä»¤ï¼‰ï¼š 1sudo cgcreate -g cpu,memory:/my_cgroup è¿™ä¸ªå‘½ä»¤åˆ›å»ºäº†ä¸€ä¸ªåä¸ºmy_cgroupçš„æ–°Cgroupï¼Œç”¨äºç®¡ç†CPUå’Œå†…å­˜èµ„æºã€‚ ä¸ºCgroupåˆ†é…èµ„æºé™åˆ¶ï¼ˆä½¿ç”¨cgsetå‘½ä»¤ï¼‰ï¼š 12sudo cgset -r cpu.shares=512 my_cgroupsudo cgset -r memory.limit_in_bytes=100M my_cgroup è¿™ä¸ªå‘½ä»¤ä¸ºmy_cgroupè®¾ç½®äº†CPUä»½é¢ä¸º512ï¼ˆç›¸å¯¹æƒé‡ï¼‰å’Œå†…å­˜é™åˆ¶ä¸º100MBã€‚ å°†è¿›ç¨‹æ·»åŠ åˆ°Cgroupï¼ˆä½¿ç”¨cgclassifyå‘½ä»¤ï¼‰ï¼š 1sudo cgclassify -g cpu,memory:my_cgroup &lt;PID&gt; å°†æŒ‡å®šçš„è¿›ç¨‹PIDæ·»åŠ åˆ°my_cgroupä¸­ï¼Œä½¿å…¶å—åˆ°Cgroupèµ„æºé™åˆ¶çš„çº¦æŸã€‚ ä»¥ä¸Šç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨Namespaceå’ŒCgroupè¿›è¡Œèµ„æºéš”ç¦»å’Œç®¡ç†ã€‚åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™äº›æŠ€æœ¯é€šå¸¸ä¸å®¹å™¨è¿è¡Œæ—¶ï¼ˆå¦‚Dockerï¼‰ç»“åˆä½¿ç”¨ï¼Œä»¥æä¾›æ›´é«˜çº§åˆ«çš„æŠ½è±¡å’Œç®¡ç†å·¥å…·ã€‚ Namespaceå’ŒCgroupçš„å…·ä½“ä½¿ç”¨Namespace å’Œ cgroup æ˜¯ Linux å†…æ ¸æä¾›çš„ä¸¤ä¸ªå…³é”®ç‰¹æ€§ï¼Œå®ƒä»¬åœ¨å®¹å™¨æŠ€æœ¯ï¼ˆå¦‚ Dockerï¼‰ä¸­å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚Namespace è´Ÿè´£ä¸ºå®¹å™¨æä¾›ç‹¬ç«‹çš„è§†å›¾ï¼Œä½¿å¾—å®¹å™¨åœ¨ç½‘ç»œã€è¿›ç¨‹ã€æ–‡ä»¶ç³»ç»Ÿç­‰æ–¹é¢ä¸ä¸»æœºå’Œå…¶ä»–å®¹å™¨éš”ç¦»ã€‚è€Œ cgroupï¼ˆæ§åˆ¶ç»„ï¼‰åˆ™è´Ÿè´£é™åˆ¶å’Œç®¡ç†å®¹å™¨çš„èµ„æºä½¿ç”¨ï¼ˆå¦‚ CPUã€å†…å­˜ã€ç£ç›˜ I&#x2F;O ç­‰ï¼‰ã€‚ Namespace ä¾‹å­ï¼š å‡è®¾æˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ç½‘ç»œ Namespaceï¼Œä½¿å®¹å™¨å…·æœ‰ç‹¬ç«‹çš„ç½‘ç»œæ ˆã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ ip å‘½ä»¤æ¥å®ç°è¿™ä¸€ç›®æ ‡ï¼š 123456789101112131415# åˆ›å»ºä¸€ä¸ªæ–°çš„ç½‘ç»œ Namespacesudo ip netns add my_namespace# å°†ç½‘ç»œè®¾å¤‡ veth0ï¼ˆå®¹å™¨ç«¯ï¼‰å’Œ veth1ï¼ˆä¸»æœºç«¯ï¼‰æ·»åŠ åˆ°æ–°çš„ Namespacesudo ip link add veth0 type veth peer name veth1sudo ip link set veth0 netns my_namespace# é…ç½®å®¹å™¨ç«¯ç½‘ç»œè®¾å¤‡sudo ip netns exec my_namespace ip addr add 192.168.1.2/24 dev veth0sudo ip netns exec my_namespace ip link set veth0 upsudo ip netns exec my_namespace ip route add default via 192.168.1.1# é…ç½®ä¸»æœºç«¯ç½‘ç»œè®¾å¤‡sudo ip addr add 192.168.1.1/24 dev veth1sudo ip link set veth1 up åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ç½‘ç»œ Namespaceï¼Œå¹¶é…ç½®äº†ä¸€å¯¹è™šæ‹Ÿä»¥å¤ªç½‘è®¾å¤‡ï¼ˆveth0 å’Œ veth1ï¼‰ï¼Œå°†å®¹å™¨çš„ç½‘ç»œä¸ä¸»æœºç½‘ç»œè¿æ¥èµ·æ¥ã€‚è¿™ä½¿å¾—å®¹å™¨å¯ä»¥æ‹¥æœ‰ç‹¬ç«‹çš„ç½‘ç»œæ ˆï¼Œä¸ä¸»æœºå’Œå…¶ä»–å®¹å™¨éš”ç¦»ã€‚ cgroup ä¾‹å­ï¼š å‡è®¾æˆ‘ä»¬æƒ³è¦é™åˆ¶å®¹å™¨çš„ CPU å’Œå†…å­˜èµ„æºã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ cgroup æ¥å®ç°è¿™ä¸€ç›®æ ‡ï¼š 123456789101112131415# åˆ›å»ºä¸€ä¸ªæ–°çš„ cgroupsudo mkdir -p /sys/fs/cgroup/cpu/my_cgroupsudo mkdir -p /sys/fs/cgroup/memory/my_cgroup# é™åˆ¶å®¹å™¨çš„ CPU ä½¿ç”¨ç‡ä¸º 50%echo 50000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_usecho 100000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_period_us# é™åˆ¶å®¹å™¨çš„å†…å­˜ä½¿ç”¨ä¸º 100MBecho 100000000 &gt; /sys/fs/cgroup/memory/my_cgroup/memory.limit_in_bytes# å¯åŠ¨ä¸€ä¸ªæ–°çš„å®¹å™¨ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„ cgroupdocker run -itd --name=my_container ubuntu:18.04echo $(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; my_container) &gt; /sys/fs/cgroup/cpu/my_cgroup/cgroup.procsecho $(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; my_container) &gt; /sys/fs/cgroup/memory/my_cgroup/cgroup.procs åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ CPU å’Œå†…å­˜ cgroupï¼Œå¹¶é™åˆ¶äº†å®¹å™¨çš„ CPU ä½¿ç”¨ç‡å’Œå†…å­˜ä½¿ç”¨ã€‚ç„¶åæˆ‘ä»¬å¯åŠ¨äº†ä¸€ä¸ªæ–°çš„å®¹å™¨ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°æˆ‘ä»¬ä¹‹å‰åˆ›å»ºçš„ cgroup ä¸­ï¼Œè¿™æ ·å®¹å™¨çš„èµ„æºä½¿ç”¨å°±å—åˆ°äº†é™åˆ¶ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼ŒNamespace å’Œ cgroup åœ¨å®¹å™¨æŠ€æœ¯ä¸­å‘æŒ¥ç€é‡è¦ä½œç”¨ï¼Œä½¿å¾—å®¹å™¨å¯ä»¥åœ¨èµ„æºä½¿ç”¨å’Œéš”ç¦»æ–¹é¢å®ç°æ›´ç²¾ç»†çš„æ§åˆ¶ã€‚ Linuxä¸­çš„pseudo fileåœ¨ Linux ç³»ç»Ÿä¸­ï¼Œä¼ªæ–‡ä»¶ï¼ˆpseudo fileï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹çš„æ–‡ä»¶ï¼Œå®ƒä»¬æä¾›äº†ä¸ç³»ç»Ÿå†…æ ¸å’Œè®¾å¤‡é©±åŠ¨ç¨‹åºäº¤äº’çš„é€”å¾„ã€‚ä¼ªæ–‡ä»¶å¹¶ä¸åŒ…å«å®é™…çš„æ–‡ä»¶æ•°æ®ï¼Œè€Œæ˜¯åœ¨ç”¨æˆ·å’Œå†…æ ¸ç©ºé—´ä¹‹é—´æä¾›äº†ä¸€ä¸ªé€šä¿¡æ¥å£ã€‚è¿™äº›æ–‡ä»¶é€šå¸¸ä½äº /proc å’Œ /sys æ–‡ä»¶ç³»ç»Ÿä¸­ã€‚ /proc æ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼ŒåŒ…å«äº†è®¸å¤šä¼ªæ–‡ä»¶ï¼Œè¿™äº›ä¼ªæ–‡ä»¶å¯ä»¥ç”¨æ¥ç›‘æ§å’Œè°ƒæ•´ç³»ç»Ÿå†…æ ¸çš„è¿è¡ŒçŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œ/proc/cpuinfo æä¾›äº†æœ‰å…³å¤„ç†å™¨çš„è¯¦ç»†ä¿¡æ¯ï¼Œ/proc/meminfo æä¾›äº†å…³äºç³»ç»Ÿå†…å­˜ä½¿ç”¨æƒ…å†µçš„æ•°æ®ã€‚è¿™äº›ä¼ªæ–‡ä»¶å¯ä»¥åƒæ™®é€šæ–‡ä»¶ä¸€æ ·ä½¿ç”¨å‘½ä»¤è¡Œå·¥å…·ï¼ˆå¦‚ catã€grep ç­‰ï¼‰è¿›è¡ŒæŸ¥çœ‹å’Œæ“ä½œã€‚ /sys æ–‡ä»¶ç³»ç»Ÿæ˜¯å¦ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼Œç”¨äº Linux å†…æ ¸çš„è®¾å¤‡ç®¡ç†ã€‚å®ƒåŒ…å«äº†è®¸å¤šä¼ªæ–‡ä»¶ï¼Œè¿™äº›ä¼ªæ–‡ä»¶æä¾›äº†å¯¹ç³»ç»Ÿè®¾å¤‡çš„é…ç½®å’ŒçŠ¶æ€ä¿¡æ¯çš„è®¿é—®ã€‚/sys æ–‡ä»¶ç³»ç»Ÿçš„ç»“æ„æ›´åŠ è§„èŒƒåŒ–ï¼ŒæŒ‰ç…§è®¾å¤‡ã€æ€»çº¿å’Œé©±åŠ¨ç¨‹åºçš„å±‚æ¬¡å…³ç³»è¿›è¡Œç»„ç»‡ã€‚ æ€»ä¹‹ï¼Œä¼ªæ–‡ä»¶åœ¨ Linux ç³»ç»Ÿä¸­æä¾›äº†ä¸€ç§ç®€å•ã€ç»Ÿä¸€çš„æ–¹æ³•ï¼Œä½¿ç”¨æˆ·èƒ½å¤Ÿæ–¹ä¾¿åœ°è®¿é—®å’Œä¿®æ”¹ç³»ç»Ÿå†…æ ¸å’Œè®¾å¤‡é©±åŠ¨ç¨‹åºçš„çŠ¶æ€ä¿¡æ¯ã€‚ pseudo fileå’ŒçœŸå®æ–‡ä»¶çš„åŒºåˆ«ä¼ªæ–‡ä»¶ï¼ˆpseudo fileï¼‰å’ŒçœŸå®æ–‡ä»¶åœ¨ Linux ç³»ç»Ÿä¸­å…·æœ‰ä¸åŒçš„ç‰¹ç‚¹å’Œç”¨é€”ã€‚ä»¥ä¸‹æ˜¯å®ƒä»¬ä¹‹é—´çš„ä¸»è¦åŒºåˆ«ï¼š æ•°æ®å­˜å‚¨ï¼šçœŸå®æ–‡ä»¶å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼ŒåŒ…å«å®é™…çš„æ–‡ä»¶æ•°æ®ã€‚è€Œä¼ªæ–‡ä»¶å¹¶ä¸åŒ…å«å®é™…çš„æ–‡ä»¶æ•°æ®ï¼Œå®ƒä»¬é€šå¸¸ä¸å­˜åœ¨äºç£ç›˜ä¸Šï¼Œè€Œæ˜¯ç”±å†…æ ¸åŠ¨æ€ç”Ÿæˆï¼Œç”¨äºåœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´ä¹‹é—´æä¾›é€šä¿¡æ¥å£ã€‚ ç”¨é€”ï¼šçœŸå®æ–‡ä»¶ç”¨äºå­˜å‚¨å’Œè¯»å–æ•°æ®ï¼Œä¾‹å¦‚æ–‡æ¡£ã€å›¾åƒæˆ–ç¨‹åºã€‚ä¼ªæ–‡ä»¶ä¸»è¦ç”¨äºæä¾›ç³»ç»Ÿä¿¡æ¯ã€ç›‘æ§å’Œè°ƒæ•´å†…æ ¸å‚æ•°æˆ–è®¾å¤‡é©±åŠ¨ç¨‹åºçš„çŠ¶æ€ã€‚å®ƒä»¬å¯ä»¥è®©ç”¨æˆ·é€šè¿‡æ–‡ä»¶ç³»ç»Ÿæ¥å£ä¸å†…æ ¸äº¤äº’ï¼Œè€Œæ— éœ€ä½¿ç”¨ç‰¹æ®Šçš„ç³»ç»Ÿè°ƒç”¨ã€‚ ä½ç½®ï¼šçœŸå®æ–‡ä»¶é€šå¸¸åˆ†å¸ƒåœ¨æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œæ ¹æ®ç›®å½•ç»“æ„è¿›è¡Œç»„ç»‡ã€‚ä¼ªæ–‡ä»¶ä¸»è¦ä½äºç‰¹å®šçš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œä¾‹å¦‚ /procï¼ˆç”¨äºå†…æ ¸å‚æ•°å’Œè¿›ç¨‹ä¿¡æ¯ï¼‰å’Œ /sysï¼ˆç”¨äºè®¾å¤‡ç®¡ç†ï¼‰ã€‚ è®¿é—®æ–¹å¼ï¼šä¼ªæ–‡ä»¶å’ŒçœŸå®æ–‡ä»¶éƒ½å¯ä»¥ä½¿ç”¨ç±»ä¼¼çš„å‘½ä»¤è¡Œå·¥å…·ï¼ˆå¦‚ catã€grep ç­‰ï¼‰è¿›è¡ŒæŸ¥çœ‹å’Œæ“ä½œã€‚ç„¶è€Œï¼Œä¼ªæ–‡ä»¶é€šå¸¸æ˜¯åªè¯»çš„æˆ–ä»…æ”¯æŒç‰¹å®šæ“ä½œï¼Œå®ƒä»¬çš„å†…å®¹å¯èƒ½ä¼šéšç€ç³»ç»ŸçŠ¶æ€çš„å˜åŒ–è€ŒåŠ¨æ€æ”¹å˜ã€‚ æ€»ä¹‹ï¼Œä¼ªæ–‡ä»¶å’ŒçœŸå®æ–‡ä»¶åœ¨æ•°æ®å­˜å‚¨ã€ç”¨é€”ã€ä½ç½®å’Œè®¿é—®æ–¹å¼ä¸Šå­˜åœ¨æ˜¾è‘—å·®å¼‚ã€‚ä¼ªæ–‡ä»¶ä¸»è¦ç”¨äºæä¾›ä¸å†…æ ¸å’Œè®¾å¤‡é©±åŠ¨ç¨‹åºçš„äº¤äº’é€”å¾„ï¼Œè€ŒçœŸå®æ–‡ä»¶ç”¨äºå­˜å‚¨å’Œè¯»å–å®é™…æ•°æ®ã€‚ ä¼ªæ–‡ä»¶ä¾‹å­/proc/loadavg ä¼ªæ–‡ä»¶æ˜¯ç”±å†…æ ¸åŠ¨æ€ç”Ÿæˆçš„ï¼Œä¸åœ¨ç£ç›˜ä¸Šå­˜åœ¨ã€‚å®ƒå…è®¸ç”¨æˆ·å’Œç¨‹åºé€šè¿‡ç†Ÿæ‚‰çš„æ–‡ä»¶ç³»ç»Ÿæ¥å£è®¿é—®è´Ÿè½½å¹³å‡å€¼ä¿¡æ¯ï¼Œè€Œæ— éœ€ä½¿ç”¨ç‰¹æ®Šçš„ç³»ç»Ÿè°ƒç”¨ã€‚ è¦ä½¿ç”¨ /proc/loadavgï¼Œæ‚¨å¯ä»¥åƒè¯»å–å¸¸è§„æ–‡ä»¶ä¸€æ ·ç®€å•åœ°è¯»å–å…¶å†…å®¹ã€‚ä¾‹å¦‚ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨ cat å‘½ä»¤åœ¨ç»ˆç«¯ä¸­æ˜¾ç¤ºå…¶å†…å®¹ï¼š 1cat /proc/loadavg è¾“å‡ºå¯èƒ½ç±»ä¼¼äºä»¥ä¸‹å†…å®¹ï¼š 10.51 0.38 0.35 1/1234 5678 è¿™äº›æ•°å­—åˆ†åˆ«è¡¨ç¤º 1 åˆ†é’Ÿã€5 åˆ†é’Ÿå’Œ 15 åˆ†é’Ÿçš„è´Ÿè½½å¹³å‡å€¼ï¼Œåé¢çš„æ•°å­—è¡¨ç¤ºå½“å‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹æ•°&#x2F;ç³»ç»Ÿæ€»è¿›ç¨‹æ•°ï¼Œä»¥åŠæœ€è¿‘åˆ†é…çš„è¿›ç¨‹ IDã€‚ æ€»ä¹‹ï¼Œ/proc/loadavg æ˜¯ä¸€ä¸ªä¼ªæ–‡ä»¶çš„ç¤ºä¾‹ï¼Œå®ƒä¸ºè®¿é—® Linux ç³»ç»Ÿä¸­çš„è´Ÿè½½å¹³å‡å€¼ä¿¡æ¯æä¾›äº†ä¸€ä¸ªæ¥å£ï¼Œæ— éœ€ä½¿ç”¨ç‰¹æ®Šçš„ç³»ç»Ÿè°ƒç”¨ã€‚","categories":[{"name":"è®ºæ–‡ç²¾è¯»","slug":"è®ºæ–‡ç²¾è¯»","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"å†…æ ¸å®‰å…¨","slug":"è®ºæ–‡ç²¾è¯»/å†…æ ¸å®‰å…¨","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"äº‘å®‰å…¨","slug":"äº‘å®‰å…¨","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"è®ºæ–‡é˜…è¯» Demons in the Shared Kernel: Abstract Resource Attacks Against","slug":"è®ºæ–‡é˜…è¯» Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against","date":"2023-03-30T14:06:58.000Z","updated":"2023-04-16T12:31:41.581Z","comments":true,"path":"2023/03/30/è®ºæ–‡é˜…è¯» Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/","link":"","permalink":"http://example.com/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/","excerpt":"æ‘˜è¦ ç”±äºå…¶æ›´å¿«çš„å¯åŠ¨é€Ÿåº¦å’Œæ›´å¥½çš„èµ„æºåˆ©ç”¨æ•ˆç‡ï¼ŒOS-levelçš„è™šæ‹ŸåŒ–ï¼ˆvirtualizationï¼‰å·²è¢«å¹¿æ³›é‡‡ç”¨ï¼Œå¹¶æˆä¸ºäº‘è®¡ç®—çš„ä¸€é¡¹åŸºæœ¬æŠ€æœ¯ã€‚ä¸ç¡¬ä»¶è™šæ‹ŸåŒ–ç›¸æ¯”ï¼ŒOS-levelçš„è™šæ‹ŸåŒ–åˆ©ç”¨å…±äº«å†…æ ¸ï¼ˆshared-kernelï¼‰è®¾è®¡æ¥å®ç°é«˜æ•ˆç‡ï¼Œå¹¶åœ¨å…±äº«å†…æ ¸ä¸Šè¿è¡Œå¤šä¸ªç”¨æˆ·ç©ºé—´å®ä¾‹ï¼ˆåˆç§°å®¹å™¨ï¼‰ ç„¶è€Œï¼Œåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ­ç¤ºäº†ä¸€ç§æ–°çš„æ”»å‡»é¢ï¼Œå®ƒæ˜¯æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ‰€å›ºæœ‰çš„ï¼Œä¼šå½±å“Linuxã€FreeBSDå’ŒFuchsiaã€‚æ ¹æœ¬åŸå› æ˜¯æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–ä¸­çš„å…±äº«å†…æ ¸è®¾è®¡å¯¼è‡´å®¹å™¨ç›´æ¥æˆ–é—´æ¥åœ°å…±äº«æˆåƒä¸Šä¸‡çš„å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„ã€‚åœ¨ä¸åˆ©ç”¨ä»»ä½•å†…æ ¸æ¼æ´çš„æƒ…å†µä¸‹ï¼Œéç‰¹æƒå®¹å™¨å¯ä»¥è½»æ¾è€—å°½å…±äº«çš„å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„å®ä¾‹ï¼Œä»è€Œå¯¹å…¶ä»–å®¹å™¨å‘èµ·DoSæ”»å‡»ã€‚ä¸ç‰©ç†èµ„æºç›¸æ¯”ï¼Œè¿™äº›å†…æ ¸å˜é‡æˆ–æ•°æ®ç»“æ„å®ä¾‹(ç§°ä¸ºæŠ½è±¡èµ„æº)æ›´æ™®éï¼Œä½†ä¿æŠ¤ä¸è¶³ã€‚","text":"æ‘˜è¦ ç”±äºå…¶æ›´å¿«çš„å¯åŠ¨é€Ÿåº¦å’Œæ›´å¥½çš„èµ„æºåˆ©ç”¨æ•ˆç‡ï¼ŒOS-levelçš„è™šæ‹ŸåŒ–ï¼ˆvirtualizationï¼‰å·²è¢«å¹¿æ³›é‡‡ç”¨ï¼Œå¹¶æˆä¸ºäº‘è®¡ç®—çš„ä¸€é¡¹åŸºæœ¬æŠ€æœ¯ã€‚ä¸ç¡¬ä»¶è™šæ‹ŸåŒ–ç›¸æ¯”ï¼ŒOS-levelçš„è™šæ‹ŸåŒ–åˆ©ç”¨å…±äº«å†…æ ¸ï¼ˆshared-kernelï¼‰è®¾è®¡æ¥å®ç°é«˜æ•ˆç‡ï¼Œå¹¶åœ¨å…±äº«å†…æ ¸ä¸Šè¿è¡Œå¤šä¸ªç”¨æˆ·ç©ºé—´å®ä¾‹ï¼ˆåˆç§°å®¹å™¨ï¼‰ ç„¶è€Œï¼Œåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ­ç¤ºäº†ä¸€ç§æ–°çš„æ”»å‡»é¢ï¼Œå®ƒæ˜¯æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ‰€å›ºæœ‰çš„ï¼Œä¼šå½±å“Linuxã€FreeBSDå’ŒFuchsiaã€‚æ ¹æœ¬åŸå› æ˜¯æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–ä¸­çš„å…±äº«å†…æ ¸è®¾è®¡å¯¼è‡´å®¹å™¨ç›´æ¥æˆ–é—´æ¥åœ°å…±äº«æˆåƒä¸Šä¸‡çš„å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„ã€‚åœ¨ä¸åˆ©ç”¨ä»»ä½•å†…æ ¸æ¼æ´çš„æƒ…å†µä¸‹ï¼Œéç‰¹æƒå®¹å™¨å¯ä»¥è½»æ¾è€—å°½å…±äº«çš„å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„å®ä¾‹ï¼Œä»è€Œå¯¹å…¶ä»–å®¹å™¨å‘èµ·DoSæ”»å‡»ã€‚ä¸ç‰©ç†èµ„æºç›¸æ¯”ï¼Œè¿™äº›å†…æ ¸å˜é‡æˆ–æ•°æ®ç»“æ„å®ä¾‹(ç§°ä¸ºæŠ½è±¡èµ„æº)æ›´æ™®éï¼Œä½†ä¿æŠ¤ä¸è¶³ã€‚ ä¸ºäº†è¯´æ˜é™åˆ¶æŠ½è±¡èµ„æºçš„é‡è¦æ€§ï¼Œæˆ‘ä»¬é’ˆå¯¹æ“ä½œç³»ç»Ÿå†…æ ¸çš„ä¸åŒæ–¹é¢è¿›è¡Œäº†æŠ½è±¡èµ„æºæ”»å‡»ã€‚ç»“æœè¡¨æ˜ï¼Œæ”»å‡»æŠ½è±¡çš„èµ„æºæ˜¯éå¸¸å®ç”¨å’Œå…³é”®çš„ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥è¿›è¡Œäº†ç³»ç»Ÿåˆ†æï¼Œè¯†åˆ«å‡ºLinuxå†…æ ¸ä¸­è„†å¼±çš„æŠ½è±¡èµ„æºï¼ŒæˆåŠŸæ£€æµ‹åˆ°1010ä¸ªæŠ½è±¡èµ„æºï¼Œå…¶ä¸­501ä¸ªå¯ä»¥åŠ¨æ€é‡å¤ä½¿ç”¨ã€‚æˆ‘ä»¬è¿˜åœ¨å‰å››å®¶äº‘ä¾›åº”å•†çš„è‡ªéƒ¨ç½²å…±äº«å†…æ ¸å®¹å™¨ç¯å¢ƒä¸­è¿›è¡Œäº†æ”»å‡»å®éªŒã€‚ç»“æœè¡¨æ˜ï¼Œæ‰€æœ‰ç¯å¢ƒéƒ½å®¹æ˜“å—åˆ°æŠ½è±¡èµ„æºæ”»å‡»ã€‚æˆ‘ä»¬å¾—å‡ºç»“è®ºï¼ŒcontainingæŠ½è±¡èµ„æºæ˜¯å›°éš¾çš„ï¼Œå¹¶ç»™å‡ºäº†å¤šç§ç­–ç•¥æ¥é™ä½é£é™© CCS CONCEPTS Security and privacy -&gt; Virtualization and security KEYWORDS OS-level Virtualizationï¼›Shared Kernelï¼›Abstract Resource Attack IntroductionOS-levelè™šæ‹ŸåŒ–å…è®¸å¤šä¸ªåŒ…å«ä¸”éš”ç¦»çš„ç”¨æˆ·ç©ºé—´ç¯å¢ƒåœ¨åŒä¸€ä¸ªå†…æ ¸ä¸Šè¿è¡Œã€‚ä¸ç¡¬ä»¶è™šæ‹ŸåŒ–ç›¸æ¯”ï¼ˆè™šæ‹Ÿæœºï¼‰ï¼ŒOS-levelè™šæ‹ŸåŒ–æ¶ˆé™¤äº†ä¸ºæ¯ä¸ªç”¨æˆ·ç©ºé—´å®ä¾‹ç»´æŠ¤æ“ä½œç³»ç»Ÿå†…æ ¸çš„è´Ÿæ‹…ï¼Œå› æ­¤å…·æœ‰æ›´å¿«çš„å¯åŠ¨é€Ÿåº¦å’Œæ›´å¥½çš„èµ„æºåˆ©ç”¨æ•ˆç‡ã€‚å› æ­¤ï¼ŒOS-levelè™šæ‹ŸåŒ–åœ¨è¿‘å¹´æ¥å¾—åˆ°äº†å¹¿æ³›çš„åº”ç”¨ï¼Œå¹¶æˆä¸ºäº‘è®¡ç®—çš„åŸºç¡€æŠ€æœ¯ã€‚OS-levelè™šæ‹ŸåŒ–ä¸­çš„ç©ºé—´å®ä¾‹åœ¨FreeBSDä¸­å‘½åä¸ºjailsï¼Œåœ¨Solariså‘½åä¸ºZonesï¼Œåœ¨Linuxä¸­å‘½åä¸ºcontainersã€‚ å°½ç®¡OS-levelçš„è™šæ‹ŸåŒ–æ•ˆç‡å¾ˆé«˜ï¼Œä½†å®ƒä¹Ÿå¸¦æ¥äº†å¤šç§å®‰å…¨é—®é¢˜ã€‚é¦–å…ˆï¼Œç”±äºå…±äº«å†…æ ¸ï¼Œæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–å®¹æ˜“å—åˆ°å†…æ ¸æ¼æ´çš„æ”»å‡»ã€‚å› æ­¤ï¼Œå®ƒä¸èƒ½éš”ç¦»å†…æ ¸é”™è¯¯ã€‚ä¸€æ—¦å…±äº«å†…æ ¸å—åˆ°å¨èƒï¼Œæ‰€æœ‰ç”¨æˆ·ç©ºé—´å®ä¾‹(ç§°ä¸ºå®¹å™¨)éƒ½å°†å¤±å»éš”ç¦»å’Œä¿æŠ¤ã€‚æ­¤å¤–ï¼Œç ”ç©¶äººå‘˜æœ€è¿‘å¯¹å®¹å™¨æŠ€æœ¯çš„éš”ç¦»æå‡ºäº†è´¨ç–‘ï¼Œä¾‹å¦‚ä¿¡æ¯æ³„æ¼ã€éšè”½é€šé“å’Œout-of-band workloads æ‰“ç ´äº†cgroupã€‚ ç„¶è€Œï¼Œåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ­ç¤ºäº†OS-levelè™šæ‹ŸåŒ–æ‰€å›ºæœ‰çš„ä¸€ç§æ–°çš„æ”»å‡»é¢ï¼ˆattack surfaceï¼‰ã€‚ä¸ç¡¬ä»¶è™šæ‹ŸåŒ–ç›¸æ¯”ï¼ŒOS-levelè™šæ‹ŸåŒ–åˆ©ç”¨å…±äº«å†…æ ¸è®¾è®¡æ¥å®ç°é«˜æ•ˆç‡ã€‚åœ¨å…¸å‹çš„OS-levelè™šæ‹ŸåŒ–ç¯å¢ƒä¸­ï¼Œå®¹å™¨è¿è¡Œåœ¨ç›¸åŒçš„æ“ä½œç³»ç»Ÿå†…æ ¸ä¸Šï¼Œå¹¶é€šè¿‡300å¤šä¸ªç³»ç»Ÿè°ƒç”¨è¯·æ±‚å„ç§æœåŠ¡ã€‚è¯·æ³¨æ„ï¼Œåº•å±‚OSå†…æ ¸åŒ…å«æ•°åä¸‡ä¸ªå˜é‡å’Œæ•°æ®ç»“æ„å®ä¾‹ï¼Œç”¨äºä¸ºå®¹å™¨æä¾›æœåŠ¡ã€‚å› æ­¤ï¼Œè¿™äº›å®¹å™¨ç›´æ¥æˆ–é—´æ¥åœ°å…±äº«è¿™äº›å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„å®ä¾‹ã€‚ ä¸å¹¸çš„æ˜¯ï¼Œè¿™äº›å…±äº«çš„å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„å®ä¾‹æ˜¯OS-levelä¸­çš„æ–°æ”»å‡»é¢ã€‚åœ¨ä¸åˆ©ç”¨ä»»ä½•æ¼æ´çš„æƒ…å†µä¸‹ï¼Œéç‰¹æƒå®¹å™¨å¯ä»¥è½»æ¾è€—å°½æŸäº›å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„å®ä¾‹ï¼Œä»è€Œåœ¨OS-levelè™šæ‹ŸåŒ–ç¯å¢ƒä¸­å¼•èµ·DoSæ”»å‡»ã€‚å› æ­¤ï¼Œå³ä½¿å…¶ä»–å®¹å™¨æ‹¥æœ‰è¶³å¤Ÿçš„ç‰©ç†èµ„æºï¼Œä½†éšç€å†…æ ¸å…³é”®å˜é‡æˆ–æ•°æ®ç»“æ„å®ä¾‹çš„è€—å°½ï¼Œå®ƒä»¬ä»ç„¶ä¸èƒ½æ‰§è¡Œä»»ä½•æœ‰æ„ä¹‰çš„ä»»åŠ¡ã€‚ä¸çœŸå®ç¡¬ä»¶æ‰€æ”¯æŒçš„ç‰©ç†èµ„æºç›¸æ¯”ï¼Œæˆ‘ä»¬å°†è¿™äº›å†…æ ¸å˜é‡æˆ–æ•°æ®ç»“æ„å®ä¾‹è§†ä¸ºæŠ½è±¡èµ„æºï¼Œå°†å¯¹è¿™äº›èµ„æºçš„ç”¨å°½æ”»å‡»è§†ä¸ºæŠ½è±¡èµ„æºæ”»å‡»ï¼ˆabstract resource attackï¼‰ã€‚ å°½ç®¡æŠ½è±¡èµ„æºå¯ä»¥è¢«ç”¨äºDoSæ”»å‡»ï¼Œä½†å®ƒä»¬å¾€å¾€å¾—ä¸åˆ°å……åˆ†ä¿æŠ¤ã€‚å†…æ ¸å’Œå®¹å™¨å¼€å‘äººå‘˜æ›´å…³æ³¨ä¿æŠ¤ç‰©ç†èµ„æºï¼Œè€Œä¸æ˜¯æŠ½è±¡èµ„æºã€‚ä¾‹å¦‚ï¼ŒLinuxå†…æ ¸æä¾›äº†cgroupæ¥é™åˆ¶æ¯ä¸ªå®¹å™¨å®ä¾‹çš„èµ„æºä½¿ç”¨ã€‚ä½†åœ¨13ä¸ªcgroupä¸­ï¼Œæœ‰12ä¸ªæ˜¯ç‰©ç†èµ„æºcgroupï¼Œé™åˆ¶CPUã€å†…å­˜ã€å­˜å‚¨ã€IOç­‰èµ„æºçš„ä½¿ç”¨ã€‚åªæœ‰pid cgroupæ˜¯ä¸ºé™åˆ¶æŠ½è±¡èµ„æºpidè€Œè®¾è®¡çš„ã€‚å› æ­¤ï¼Œæ•°ç™¾ç§å®¹å™¨å…±äº«çš„æŠ½è±¡èµ„æºæ²¡æœ‰ä»»ä½•é™åˆ¶ï¼Œä¾‹å¦‚global dirty ratioã€open-file structså’Œpseudo-terminal structsï¼Œè¿™ä½¿å®ƒä»¬å®¹æ˜“å—åˆ°DoSæ”»å‡»ã€‚ ä¸ºäº†å±•ç¤ºåœ¨OS-levelä¸Šé™åˆ¶æŠ½è±¡èµ„æºçš„é‡è¦æ€§ï¼Œæˆ‘ä»¬åœ¨Linuxå†…æ ¸ä¸Šä½¿ç”¨Dockerå®¹å™¨è¿›è¡Œæ”»å‡»ï¼Œé’ˆå¯¹æ“ä½œç³»ç»ŸæœåŠ¡çš„ä¸åŒæ–¹é¢çš„æŠ½è±¡èµ„æºï¼ŒåŒ…æ‹¬è¿›ç¨‹ç®¡ç†ã€å†…å­˜ç®¡ç†ã€å­˜å‚¨ç®¡ç†å’ŒIOç®¡ç†ã€‚ æˆ‘ä»¬çš„å®éªŒè¯æ˜æ”»å‡»æŠ½è±¡èµ„æºæ˜¯éå¸¸å®ç”¨å’Œå…³é”®çš„-å®ƒå¾ˆå®¹æ˜“åœ°ç¦ç”¨æ–°ç¨‹åºçš„æ‰§è¡Œï¼Œé™ä½å†…å­˜å†™å…¥é€Ÿåº¦97.3%ï¼Œä½¿æ‰€æœ‰æ–‡ä»¶æ‰“å¼€ç›¸å…³åœ°æ“ä½œå´©æºƒï¼Œå¹¶æ‹’ç»æ‰€æœ‰æ–°çš„SSHè¿æ¥ã€‚æ›´ç³Ÿç³•åœ°æ˜¯ï¼Œå®ƒä¼šå½±å“æ“ä½œç³»ç»ŸæœåŠ¡çš„æ‰€æœ‰æ–¹é¢ã€‚æ­¤å¤–ï¼Œå®éªŒè¿˜è¡¨æ˜ï¼Œé™¤äº†Linux FreeBSDå’ŒFuchsiaä¹Ÿå®¹æ˜“å—åˆ°æŠ½è±¡èµ„æºæ”»å‡»ã€‚ é—æ†¾çš„æ˜¯ï¼Œå°½ç®¡æŠ½è±¡èµ„æºå¾ˆé‡è¦ï¼Œä½†ç”±äºå‡ ä¸ªåŸºæœ¬åŸå› ï¼Œå®ƒä»¬æœ¬èº«å°±å¾ˆéš¾containã€‚é¦–å…ˆï¼Œåœ¨æ“ä½œç³»ç»Ÿå†…æ ¸ä¸­åˆ—ä¸¾æ‰€æœ‰å¯èƒ½çš„æŠ½è±¡èµ„æºæ˜¯ä¸åˆ‡å®é™…çš„ã€‚ä¸å¾ˆå°‘çš„ç‰©ç†èµ„æºç±»å‹ä¸åŒï¼Œå†…æ ¸ä¸­çš„æŠ½è±¡èµ„æºç±»å‹æ˜¯å¤šç§å¤šæ ·çš„ã€‚ç¬¬äºŒï¼Œå¾ˆå®¹æ˜“å½¢æˆå¯¼è‡´æŠ½è±¡èµ„æºæ¯ç«­çš„æ¡ä»¶ã€‚åœ¨å†…æ ¸ä¸­å®ç°æ–°ç‰¹æ€§æ—¶ï¼Œå¼€å‘äººå‘˜ç»å¸¸å…³æ³¨ç‰©ç†èµ„æºçš„æ¶ˆè€—ï¼Œè€Œå¾ˆå°‘å…³æ³¨æŠ½è±¡èµ„æºçš„æ¶ˆè€—ã€‚æ­¤å¤–ï¼ŒOSå†…æ ¸å…·æœ‰å¤æ‚çš„æ•°æ®å’Œè·¯å¾„ä¾èµ–å…³ç³»ï¼Œå¯¼è‡´å†…æ ¸ä¸­çš„æŠ½è±¡èµ„æºä»¥å„ç§æ–¹å¼è€—å°½ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªåŸºäºLLVMçš„å·¥å…·ï¼Œç³»ç»Ÿåœ°è¯†åˆ«Linuxå†…æ ¸ä¸­è„†å¼±çš„æŠ½è±¡èµ„æºã€‚æˆ‘ä»¬æå‡ºäº†è¯†åˆ«å¯å…±äº«æŠ½è±¡èµ„æºå¹¶åˆ†æå…¶å®¹å™¨å¯æ§æ€§çš„æ–°æŠ€æœ¯ã€‚æˆ‘ä»¬å°†æˆ‘ä»¬çš„å·¥å…·åº”ç”¨äºæ–°çš„Linuxå†…æ ¸ï¼Œå¹¶æ£€æµ‹1010ä¸ªæŠ½è±¡èµ„æºã€‚å…¶ä¸­501ä¸ªå¯ä»¥åŠ¨æ€åœ°é‡å¤ä½¿ç”¨ï¼Œä»æ£€æµ‹åˆ°çš„æŠ½è±¡èµ„æºä¸­ï¼Œæˆ‘ä»¬æ ¹æ®æˆ‘ä»¬çš„ç†Ÿæ‚‰åº¦æŒ‘é€‰äº†7ä¸ªå½±å“æ“ä½œç³»ç»Ÿå„ä¸ªæ–¹é¢çš„èµ„æºï¼ˆå³ï¼Œæˆ‘ä»¬çŸ¥é“è€—å°½è¯¥èµ„æºçš„å½±å“ï¼‰ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥å¯¹éƒ¨ç½²åœ¨å››å¤§äº‘ä¾›åº”å•†ï¼ˆåŒ…æ‹¬AWSã€MS Azureã€è°·æ­Œcloudå’Œé˜¿é‡Œäº‘ï¼‰ä¸Šçš„å…±äº«å†…æ ¸å®¹å™¨ç¯å¢ƒä¸­çš„è¿™äº›é€‰å®šèµ„æºè¿›è¡Œæ”»å‡»å®éªŒã€‚è¯•éªŒç»“æœè¡¨æ˜ï¼Œæ‰€æœ‰ç¯å¢ƒéƒ½å®¹æ˜“å—åˆ°æˆ‘ä»¬çš„æ”»å‡»ã€‚æœ€åç»™å‡ºäº†å¤šç§é™ä½æŠ½è±¡èµ„æºæ”»å‡»é£é™©çš„ç­–ç•¥ã€‚ æœ¬æ–‡çš„è´¡çŒ®å¦‚ä¸‹ï¼š New Attack Surfaceï¼šæˆ‘ä»¬æ­ç¤ºäº†æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ‰€å›ºæœ‰çš„æ–°çš„æ”»å‡»é¢ã€‚æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ–°çš„æ”»å‡»æ–¹æ³•ï¼Œç§°ä¸ºæŠ½è±¡èµ„æºæ”»å‡»ã€‚æˆ‘ä»¬è¯æ˜äº†æŠ½è±¡èµ„æºæ”»å‡»æ˜¯éå¸¸å®ç”¨çš„ï¼Œå¹¶ä¸”æ˜¯å½±å“Linuxã€FreeBSDå’ŒFuchsiaçš„å¹¿æ³›æ”»å‡»ç±»åˆ«ã€‚ Systematic Analysisï¼šæˆ‘ä»¬è®¾è®¡å¹¶å®ç°äº†ä¸€ä¸ªåŸºäºLLVMçš„é™æ€åˆ†æå·¥å…·æ¥è¯†åˆ«Linuxå†…æ ¸ä¸­è„†å¼±çš„æŠ½è±¡èµ„æºï¼ŒåŒ…æ‹¬åŸºäºé…ç½®çš„åˆ†æå’Œå®¹å™¨å¯æ§æ€§åˆ†æã€‚æˆ‘ä»¬çš„å·¥å…·æ£€æµ‹501ä¸ªå¯ä»¥åœ¨Linuxå†…æ ¸ä¸­åŠ¨æ€é‡å¤è§¦å‘çš„æŠ½è±¡èµ„æºã€‚ Practical Evaluationï¼šæˆ‘ä»¬è¯„ä¼°äº†AWSã€MS Azureã€è°·æ­ŒCloudå’Œé˜¿é‡Œäº‘ä¸Šself-deployedå…±äº«å†…æ ¸å®¹å™¨ç¯å¢ƒä¸­çš„7ç§æŠ½è±¡èµ„æºæ”»å‡»ã€‚ï¼ˆç›®å‰çš„å…¬å…±äº‘ä¾›åº”å•†æ²¡æœ‰ç›´æ¥å‘ä¸åŒçš„ç”¨æˆ·æä¾›å…±äº«å†…æ ¸å®¹å™¨ã€‚å…¬å…±äº‘ä¸­çš„å®¹å™¨é€šå¸¸ç”±è™šæ‹Ÿæœºéš”ç¦»ã€‚ï¼‰æ‰€æœ‰ç¯å¢ƒéƒ½å®¹æ˜“æ”¶åˆ°æŠ½è±¡èµ„æºæ”»å‡»ã€‚å…¶ä¸­æœ‰ä¸¤ä¸ªç¯å¢ƒæ˜“å—6 attacksï¼Œä¸€ä¸ªç¯å¢ƒæ˜“å— 5 attacksï¼Œå¦ä¸€ä¸ªç¯å¢ƒæ˜“å— 4 attacksã€‚æˆ‘ä»¬è´Ÿè´£åœ°å‘æ‰€æœ‰äº‘ä¾›åº”å•†æŠ«éœ²äº†æˆ‘ä»¬çš„è°ƒæŸ¥ç»“æœã€‚æ‰€æœ‰è¿™äº›éƒ½è¯å®äº†æ‰€ç¡®å®šçš„é—®é¢˜ã€‚ Community Impactï¼šæˆ‘ä»¬è®¡åˆ’åœ¨GitHub - ZJU-SEC&#x2F;AbstractResourceAttack: This repository is used to analysis the shared resources of different containersä¸­å¼€æºæˆ‘ä»¬çš„å·¥å…·å’Œè¯†åˆ«å‡ºçš„æŠ½è±¡èµ„æºï¼Œè¿™æ ·å®ƒä»¬å°±å¯ä»¥å¸®åŠ©Linuxå†…æ ¸communityå’Œå®¹å™¨communityè¯†åˆ«å‡ºOS-levelè™šæ‹ŸåŒ–ä¸­èµ„æºéš”ç¦»çš„å¼±ç‚¹ã€‚ BackgroundOS-levelè™šæ‹ŸåŒ–ä¾èµ–äºåº•å±‚æ“ä½œç³»ç»Ÿå†…æ ¸è¿›è¡Œèµ„æºéš”ç¦»å’Œcontainmentã€‚æ›´å…·ä½“åœ°è¯´ï¼ŒLinuxå†…æ ¸ä¸ºèµ„æºéš”ç¦»æä¾›äº†namespaceï¼Œä¸ºèµ„æºcontainmentæä¾›äº†cgroupã€‚ Linux NamespacesLinux namespaceæä¾›è¿›ç¨‹çº§èµ„æºéš”ç¦»ã€‚ç›®å‰ï¼ŒLinux namespaceåˆ†ä¸º8ç§ç±»å‹ã€‚æ ¹æ®å®ƒä»¬çš„å‘å¸ƒæ—¶é—´ï¼Œå¦‚ä¸‹ï¼š Mountï¼šç”¨äºæ–‡ä»¶ç³»ç»Ÿéš”ç¦» UTSï¼šç”¨äºä¸»æœºåå’ŒåŸŸåéš”ç¦» IPCï¼šç”¨äºæ¶ˆæ¯é˜Ÿåˆ—éš”ç¦» PIDï¼šç”¨äºè¿›ç¨‹IDéš”ç¦» Networkï¼šç”¨äºç½‘ç»œèµ„æºéš”ç¦» Userï¼šç”¨äºUID&#x2F;GIDéš”ç¦» Cgroupï¼šç”¨äºcgroupéš”ç¦» Timeï¼šç”¨äºæ—¶é’Ÿæ—¶é—´éš”ç¦» ä¸€ä¸ªè¿›ç¨‹å¯ä»¥è¢«åˆ†é…ç»™ä¸åŒç±»å‹çš„ä¸åŒnamespaceã€‚ä½†æ˜¯å¯¹äºæ¯ç§ç±»å‹ï¼Œå®ƒåªèƒ½å±äºä¸€ä¸ªnamespaceã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œè¿›ç¨‹ä¸å…¶çˆ¶è¿›ç¨‹åœ¨ç›¸åŒçš„namespaceä¸­ã€‚å®ƒå¯ä»¥åœ¨è¿›ç¨‹åˆ›å»ºæœŸé—´é€šè¿‡pass specific flagsæ·»åŠ åˆ°æ–°çš„namespaceï¼Œæˆ–è€…åœ¨è¿›ç¨‹è¿è¡ŒæœŸé—´é€šè¿‡è°ƒç”¨setnsç³»ç»Ÿè°ƒç”¨æ·»åŠ åˆ°æ–°çš„namespaceã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œåªæœ‰åŒä¸€namespaceä¸­çš„è¿›ç¨‹å¯ä»¥å…±äº«namespaceéš”ç¦»çš„èµ„æºã€‚å› æ­¤ï¼Œèµ„æºæ˜¯è·¨namespaceéš”ç¦»çš„ã€‚å› æ­¤ï¼Œä¸€ä¸ªnamespaceä¸­çš„éš”ç¦»èµ„æºè€—å°½ä¸ä¼šå½±å“å…¶ä»–namespaceä¸­çš„è¿›ç¨‹ã€‚è¿™æ ·çš„è®¾è®¡æœ¬è´¨ä¸Šè¦æ±‚namespaceæœºåˆ¶æ­£ç¡®ä¸”å½»åº•åœ°containèµ„æºã€‚ ç„¶è€Œï¼Œä»ç„¶æœ‰æ•°ç™¾ç§æŠ½è±¡èµ„æºç±»å‹æ²¡æœ‰åŒ…å«åœ¨namespaceä¸­ã€‚å³ä½¿æœ‰namespaceçš„ä¿æŠ¤ï¼Œå¤§å‹æ”»å‡»é¢ä»ç„¶å­˜åœ¨ã€‚æœ‰äººå¯èƒ½ä¼šä¸»å¼ ä½¿ç”¨namespaceéš”ç¦»æ‰€æœ‰æŠ½è±¡èµ„æºã€‚ç„¶è€Œï¼Œè¿™æ˜¯ä¸åˆ‡å®é™…çš„:æŠ½è±¡èµ„æºçš„å·¨å¤§æ•°é‡å’Œçµæ´»æ€§ä½¿å¾—è§£å†³æ–¹æ¡ˆç”±äºå·¨å¤§çš„ä»£ç æ›´æ”¹å’Œé«˜æ€§èƒ½å¼€é”€è€Œæ— æ³•æ¥å—ã€‚ Linux Control Groupså¦ä¸€æ–¹é¢ï¼ŒLinux cgroupç”¨äºé™åˆ¶é™åˆ¶èµ„æºçš„å®ç”¨ã€‚cgroupè´Ÿè´£æ§åˆ¶ç»„å†…æ‰€æœ‰è¿›ç¨‹ä½¿ç”¨çš„èµ„æºã€‚cgroupè¢«ç»„ç»‡æˆæ ‘çŠ¶ç»“æ„ï¼Œå…¶ä¸­childrençš„èµ„æºä¹ŸåŒ…æ‹¬parentçš„èµ„æºã€‚å¯¹èµ„æºä½¿ç”¨çš„é™åˆ¶ä¹Ÿåœ¨æ ‘ä¸Šé€’å½’åœ°å¼ºåˆ¶æ‰§è¡Œï¼Œä»¥ä¾¿cgroupä¸­çš„èµ„æºä½¿ç”¨ä¸åº”è¶…è¿‡å…¶æ‰€æœ‰ç¥–å…ˆçš„é™åˆ¶ã€‚ cgroupä¸»è¦ç®¡ç†ç¡¬ä»¶èµ„æºï¼Œå¦‚CPUã€å†…å­˜ã€å­˜å‚¨ã€IOç­‰ã€‚æœ‰ä¸¤ä¸ªç‰ˆæœ¬çš„cgroupï¼Œv1å’Œv2ï¼Œä¸»è¦çš„åŒºåˆ«æ˜¯ï¼Œcgroup v1å¯¹äºæ¯ç§ç±»å‹çš„èµ„æºå¯ä»¥æœ‰ä¸€ä¸ªæ ‘çŠ¶å±‚æ¬¡ç»“æ„ï¼Œè€Œæ§åˆ¶ç»„v2åªæœ‰ä¸€ä¸ªå±‚æ¬¡ç»“æ„ã€‚resource accountå’Œresource usage limitçš„å®ç°åœ¨v1å’Œv2ä¹‹é—´å·®åˆ«ä¸å¤§ã€‚ç›®å‰é»˜è®¤ä½¿ç”¨cgroup v1ï¼Œå› ä¸ºå®ƒæ›´ç¨³å®šï¼Œå¹¶æä¾›æ›´å¤šå¯¹èµ„æºçš„æ§åˆ¶ã€‚å®ƒç®¡ç†13ç§èµ„æºç±»å‹ï¼Œè€Œv2ç›®å‰åªæ”¯æŒ9ç§èµ„æºç±»å‹ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œåœ¨è¿™13ç§èµ„æºä¸­ï¼Œæœ‰5ç§ç”¨äºCPU accoutingï¼ŒåŒ…æ‹¬cpuã€cpuacctã€cpusetã€freezeã€pref_eventï¼›å…¶ä¸­3ä¸ªæ˜¯ç”¨äºå†…å­˜ï¼ŒåŒ…æ‹¬memoryã€hugetlbã€rdmaï¼›blkioç”¨äºstorageï¼›è¿˜æœ‰3ä¸ªç”¨äºIOï¼ŒåŒ…æ‹¬devicesã€net_clsã€net_prioã€‚åªæœ‰PIDs cgroupä¸ºPIDçš„æŠ½è±¡èµ„æºã€‚ è™½ç„¶é™åˆ¶å®¹å™¨è¿›ç¨‹ä¸­å…±äº«æŠ½è±¡èµ„æºçš„ä½¿ç”¨å¯ä»¥å‡è½»DoSæ”»å‡»ï¼Œä½†å°†cgroupæ‰©å±•åˆ°åŒ…æ‹¬æ‰€æœ‰æŠ½è±¡èµ„æºä¹Ÿæ˜¯ä¸åˆ‡å®é™…çš„ã€‚è®¡ç®—èµ„æºå¹¶å¯¹å¦‚æ­¤å¤šç±»å‹çš„èµ„æºå®æ–½é™åˆ¶å°†å¼•å…¥ä¸å¯æ¥å—çš„å¼€é”€ã€‚ Abstract Resource Attacks Threat model and assumptionsï¼šåœ¨æœ¬æ–‡ä¸­ï¼Œç”±äºæˆ‘ä»¬çš„ç›®æ ‡æ˜¯OS-levelè™šæ‹ŸåŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬å‡è®¾å®¹å™¨è¿è¡Œåœ¨ç›¸åŒçš„å…±äº«å†…æ ¸ä¸Šã€‚å®¹å™¨æ‰§è¡Œæœ€å…ˆè¿›çš„ä¿æŠ¤ï¼Œå¹¶åœ¨éƒ¨ç½²ä¸­éµå¾ªæœ€å®‰å…¨çš„å®è·µã€‚æ›´å…·ä½“åœ°è¯´ï¼Œå®¹å™¨ä»¥ä¸åŒçš„éæ ¹ç”¨æˆ·è¿è¡Œï¼Œåˆ é™¤äº†æ‰€æœ‰åŠŸèƒ½ã€‚è€Œå†…æ ¸åˆ™ä¸ºå®¹å™¨å¼ºåˆ¶ä½¿ç”¨å°½å¯èƒ½å¤šçš„namespaceå’Œcgroupã€‚æ­¤å¤–ï¼Œå†…æ ¸è¿˜ä½¿ç”¨seccompæ¥é˜»æ­¢æ•æ„Ÿçš„ç³»ç»Ÿè°ƒç”¨ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥å‡è®¾å†…æ ¸æ²¡æœ‰bugï¼Œæ‰€æœ‰å®‰å…¨æœºåˆ¶éƒ½æ­£å¸¸å·¥ä½œã€‚ å¦ä¸€æ–¹é¢ï¼Œæ”»å‡»è€…æ§åˆ¶ä¸€ä¸ªå®¹å™¨ï¼Œå¹¶è¯•å›¾ç ´ååœ¨åŒä¸€å†…æ ¸ä¸Šè¿è¡Œçš„å…¶ä»–å®¹å™¨ã€‚æ”»å‡»è€…å¯ä»¥åœ¨å®¹å™¨å†…è¿è¡Œä»»ä½•ä»£ç å¹¶è°ƒç”¨seccompå…è®¸çš„ç³»ç»Ÿè°ƒç”¨ã€‚ä½†æ˜¯ï¼Œä»–&#x2F;å¥¹ä¸å…è®¸åˆ©ç”¨å†…æ ¸æ¼æ´ã€‚æ­¤å¤–ï¼Œæ”»å‡»è€…ä½œä¸ºéæ ¹ç”¨æˆ·å¤„äºéç‰¹æƒå®¹å™¨ä¸­ï¼Œæ ¹æœ¬æ²¡æœ‰ä»»ä½•åŠŸèƒ½ã€‚æœ€åï¼Œæ”»å‡»è€…ä¸å…è®¸å‡çº§ç‰¹æƒæˆ–é‡æ–°è·å¾—ä»»ä½•åŠŸèƒ½ã€‚åœ¨ä¸‹é¢çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†ç”±äºå†…æ ¸ä¸­çš„å…±äº«æŠ½è±¡èµ„æºï¼Œå³ä½¿è¿™æ ·çš„æ”»å‡»è€…ä»ç„¶å¯ä»¥å¯¹å…¶ä»–å®¹å™¨å‘èµ·DoSæ”»å‡»ã€‚ Weaknesses in OS-level Virtualizationåœ¨OS-levelè™šæ‹ŸåŒ–ä¸­ï¼Œå®¹å™¨ç›´æ¥æˆ–é—´æ¥åœ°å…±äº«æˆåƒä¸Šä¸‡çš„å†…æ ¸æŠ½è±¡èµ„æºï¼Œè¿™ä½¿å®ƒä»¬å®¹æ˜“å—åˆ°èµ„æºè€—å°½æ”»å‡»ã€‚æˆ‘ä»¬åˆ©ç”¨Linuxå†…æ ¸ä¸­çš„ä¸€ä¸ªç¤ºä¾‹æ¥è¯´æ˜ç»†èŠ‚ã€‚ 12345678910111213141516171819202122232425static struct percpu_counter nr_files __cacheline_aligner_in_smp;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, const struct cred *cred)&#123; static long old_max; struct file *f; if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN) &#123; ... goto over; &#125; f = __alloc_file(flags, cred); if (!IS_ERR(f)) percpu_counter_inc(&amp;nr_files); ...over: ... return ERR_PTR(-ENFILE);&#125; å®ƒå®šä¹‰äº†ä¸€ä¸ªæ¯ä¸ªCPUè®¡æ•°å™¨nr_filesï¼Œä¸€ä¸ªå‡½æ•°get_nr_files()å’Œä¸€ä¸ªå‡½æ•°alloc_empty_file()ã€‚ nr_filesï¼šè¿™æ˜¯ä¸€ä¸ªæ¯ä¸ªCPUè®¡æ•°å™¨ï¼Œç”¨äºè·Ÿè¸ªæ¯ä¸ªCPUä¸Šåˆ†é…çš„æ–‡ä»¶ç»“æ„çš„æ•°é‡ã€‚ get_nr_files()ï¼šæ­¤å‡½æ•°é€šè¿‡è¯»å–nr_filesè®¡æ•°å™¨çš„æ­£å€¼ï¼Œè¿”å›æ‰€æœ‰CPUä¸Šåˆ†é…çš„æ–‡ä»¶ç»“æ„çš„æ€»æ•°ã€‚ alloc_empty_file()ï¼šæ­¤å‡½æ•°æ¥å—ä¸¤ä¸ªå‚æ•°ï¼Œflagså’Œcredï¼Œå¹¶å°è¯•åˆ†é…ä¸€ä¸ªç©ºçš„æ–‡ä»¶ç»“æ„ã€‚ å¦‚æœåˆ†é…çš„æ–‡ä»¶ç»“æ„çš„æ•°é‡ï¼ˆget_nr_files()ï¼‰å¤§äºæˆ–ç­‰äºå…è®¸çš„æœ€å¤§å€¼ï¼ˆfiles_stat.max_filesï¼‰ï¼Œå¹¶ä¸”å½“å‰è¿›ç¨‹æ²¡æœ‰CAP_SYS_ADMINèƒ½åŠ›ï¼Œå®ƒå°†è·³è¿‡æ–‡ä»¶åˆ†é…å¹¶è·³è½¬åˆ°overæ ‡ç­¾ã€‚ å¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œå®ƒå°†è°ƒç”¨__alloc_file()å‡½æ•°æ¥åˆ†é…ä¸€ä¸ªæ–°çš„æ–‡ä»¶ç»“æ„ã€‚ å¦‚æœåˆ†é…æˆåŠŸï¼ˆå³è¿”å›çš„æŒ‡é’ˆä¸æ˜¯é”™è¯¯ï¼‰ï¼Œå®ƒä¼šå¢åŠ nr_filesè®¡æ•°å™¨ã€‚ å¦‚æœåˆ†é…å¤±è´¥æˆ–è¾¾åˆ°æœ€å¤§æ–‡ä»¶æ•°ä¸”æ²¡æœ‰æ‰€éœ€çš„æƒé™ï¼Œè¯¥å‡½æ•°å°†è¿”å›ä¸€ä¸ªå¸¦æœ‰-ENFILEé”™è¯¯ä»£ç çš„é”™è¯¯æŒ‡é’ˆã€‚ ä»£ç æ˜¾ç¤ºäº†Linuxå†…æ ¸ä¸­çš„å…¨å±€å˜é‡nr_fileså’Œå‡½æ•°alloc_empty_fileã€‚alloc_empty_fileåˆ†é…structæ–‡ä»¶(f = __alloc_file(flags, cred);)ã€‚å¯¹äºæ¯ä¸ªåˆ†é…çš„ç»“æ„æ–‡ä»¶ï¼Œnr_filesé€šè¿‡å¢åŠ è®¡æ•°å™¨æ¥è®¡ç®—(ercpu_counter_inc(&amp;nr_files);)ã€‚åœ¨ä¸»æœºLinuxå†…æ ¸ä¸­ï¼Œstructæ–‡ä»¶çš„æ€»æ•°å—files_statçš„é™åˆ¶ã€‚Max_files(if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN))ã€‚å¦‚æœè¾¾åˆ°é™åˆ¶ï¼Œalloc_empty_fileè¿”å›ä¸€ä¸ªé”™è¯¯(return ERR_PTR(-ENFILE);)ã€‚ ç„¶è€Œï¼ŒLinuxå†…æ ¸å¹¶æ²¡æœ‰æä¾›ä»»ä½•namespaceæˆ–cgroupæ¥éš”ç¦»æˆ–é™åˆ¶nr_filesã€‚å› æ­¤ï¼Œnr_filesæ˜¯å¯ä»¥ç›´æ¥æ§åˆ¶æ‰€æœ‰å®¹å™¨çš„â€“ä»»ä½•å®¹å™¨å¯¹ç»“æ„æ–‡ä»¶çš„åˆ†é…éƒ½ä¼šå¢åŠ ç›¸åŒçš„å…±äº«å…¨å±€å˜é‡nr_filesã€‚ è¿™æ ·çš„nr_fileså…±äº«ä¼šå¯¼è‡´æ–°çš„æ”»å‡»ã€‚åœ¨Linuxä¸­ï¼Œæ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯ä¸€ä¸ªæ–‡ä»¶ã€‚å¦‚æ­¤å¤šçš„æ“ä½œï¼Œå¦‚æ–‡ä»¶æ‰“å¼€ã€è¿›ç¨‹åˆ›å»ºã€ç®¡é“åˆ›å»ºã€æ–°çš„ç½‘ç»œè¿æ¥åˆ›å»ºï¼Œç”šè‡³è®¡æ—¶å™¨åˆ›å»º(timerfd_create)å’Œäº‹ä»¶ç”Ÿæˆ(eventfd)ï¼Œéƒ½å¢åŠ äº†nr_filesã€‚æ¶æ„å®¹å™¨å¯ä»¥å¾ˆå®¹æ˜“åœ°å°†nr_fileså¼¹å‡ºåˆ°å…¶ä¸Šé™ã€‚å®é™…ä¸Šï¼Œåœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œnr_filesçš„é…é¢å¯ä»¥åœ¨å‡ ç§’é’Ÿå†…å¿«é€Ÿè€—å°½ã€‚å› æ­¤ï¼Œæ‰€æœ‰ä½¿ç”¨structæ–‡ä»¶çš„æ“ä½œéƒ½å°†å¤±è´¥ã€‚ å½±å“æ˜¯ä¸¥é‡çš„:å—å®³è€…å®¹å™¨ç”šè‡³ä¸èƒ½è¿è¡Œå‘½ä»¤(å› ä¸ºå®ƒéœ€è¦æ‰“å¼€å‘½ä»¤æ–‡ä»¶)æˆ–æ‰§è¡Œæ–°çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå¯¼è‡´ç¨‹åºå´©æºƒã€‚ä»ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å‘ç°å³ä½¿å®¹å™¨æœ‰è¶³å¤Ÿçš„ç‰©ç†èµ„æºï¼Œæ¯”å¦‚CPUæˆ–å†…å­˜ï¼Œå¦‚æœæ²¡æœ‰nr_filesä¸­çš„é…é¢ï¼Œå®ƒä»ç„¶ä¸èƒ½è¿è¡Œä»»ä½•æ–°çš„ç¨‹åºã€‚ ä¸ºäº†è¯æ˜æŠ½è±¡èµ„æºæ”»å‡»ä¼šå½±å“æ‰€æœ‰å†…æ ¸åŠŸèƒ½ï¼Œæˆ‘ä»¬é’ˆå¯¹Linuxå†…æ ¸åŠŸèƒ½çš„æ¯ä¸ªæ–¹é¢(åŒ…æ‹¬è¿›ç¨‹ã€å†…å­˜ã€å­˜å‚¨å’ŒIOç®¡ç†)æå‡ºäº†ä¸€ä¸ªæŠ½è±¡èµ„æºæ”»å‡»ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å±•ç¤ºæœ¬åœ°æµ‹è¯•ç¯å¢ƒä¸Šçš„æ”»å‡»ç»“æœ.ã€‚ å¯¹äºæœ¬åœ°æµ‹è¯•ç¯å¢ƒè®¾ç½®ï¼Œæµ‹è¯•æœºå™¨å…·æœ‰Intel Core i5 CPU, 8 GBå†…å­˜å’Œ500 GB HDDï¼Œè¿è¡ŒUbuntu 18.04å’ŒLinuxå†…æ ¸v5.3.1ã€‚æˆ‘ä»¬å°†å…¶ç§°ä¸ºä¸»æœºã€‚åœ¨ä¸»æœºä¸Šï¼Œæˆ‘ä»¬ä½¿ç”¨docker 18.06.0-ceå»ºç«‹äº†ä¸¤ä¸ªdockerå®¹å™¨ï¼Œåˆ†åˆ«ä½œä¸ºæ”»å‡»è€…å®¹å™¨å’Œå—å®³è€…å®¹å™¨ä½¿ç”¨ã€‚æˆ‘ä»¬æŒ‰ç…§dockerå®‰å…¨æœ€ä½³å®è·µè®¾ç½®äº†è¿™ä¸¤ä¸ªå®¹å™¨ï¼Œå³åœ¨ä¸åŒçš„éæ ¹ç”¨æˆ·ä¸­è¿è¡Œå®ƒä»¬ï¼Œåˆ é™¤æ‰€æœ‰åŠŸèƒ½ï¼Œå¯ç”¨namespaceå’Œcgroupï¼Œå¹¶åº”ç”¨seccompç³»ç»Ÿè°ƒç”¨é˜»å¡ï¼Œå¦‚threat modelä¸­æ‰€è®¨è®ºçš„é‚£æ ·ã€‚ Attacks on Process Managementä¸ºäº†å®ç°è¿›ç¨‹ç®¡ç†ï¼ŒLinuxå†…æ ¸å¼•å…¥äº†ä¸€ç³»åˆ—çš„æŠ½è±¡èµ„æºï¼Œå¦‚è¿›ç¨‹æ§åˆ¶å—struct task_structã€pidã€stateå’Œå„ç§æ•°æ®ç»“æ„æ¥æ”¯æŒæ´¾ç”Ÿå®ä½“,å¦‚ç”¨äºçº¿ç¨‹çš„struct thread_infoã€struct rq runqueuesç”¨äºè°ƒåº¦,struct shm_infoå’Œstruct semaphoreç”¨äºè¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰ï¼Œstruct spinlockå’Œstruct semaphoresæ¥å®ç°åŒæ­¥ã€‚äº‹å®ä¸Šï¼ŒLinuxä¸­çš„è¿›ç¨‹ç®¡ç†å¼•å…¥äº†æˆåƒä¸Šä¸‡çš„æŠ½è±¡èµ„æºã€‚åœ¨ä¸‹é¢ï¼Œæˆ‘ä»¬ä»‹ç»é’ˆå¯¹ç»“æ„idrçš„æ”»å‡»ï¼Œä½œä¸ºä¸€ä¸ªçš„ä¾‹å­ã€‚ Attacking idr of PIDLinuxå†…æ ¸å¼•å…¥äº†ç”¨äºæ•´æ•°IDç®¡ç†çš„struct idrã€‚è¿›ç¨‹ç®¡ç†ä¹Ÿä½¿ç”¨idrè¿›è¡Œpidåˆ†é…ã€‚ä»£ç æ˜¾ç¤ºäº†alloc_pidå‡½æ•°ï¼Œè¯¥å‡½æ•°è°ƒç”¨idr_alloc_cyclicæ¥è·å¾—ä¸€ä¸ªæ–°çš„pidã€‚Idr_alloc_cyclicåœ¨idråˆ†é…æœŸé—´æ£€æŸ¥pid_maxï¼Œå¦‚æœidrå¢é•¿è¶…è¿‡pid_maxï¼Œåˆ™è¿”å›ä¸€ä¸ªè´Ÿé”™è¯¯ä»£ç ã€‚ç¨åæˆ‘ä»¬å°†å±•ç¤ºï¼Œå³ä½¿å¯ç”¨äº†PID namespaceå’ŒPID cgroupï¼Œidrä»ç„¶å¯ä»¥è¢«è§†ä¸ºæ‰€æœ‰è¿›ç¨‹çš„å…¨å±€å…±äº«èµ„æºã€‚ç±»ä¼¼äºforkç‚¸å¼¹ï¼Œæ¶æ„å®¹å™¨è¿›ç¨‹å¯ä»¥é‡å¤forkè€—å°½æ‰€æœ‰idrã€‚å› æ­¤ï¼Œå…±äº«å†…æ ¸ä¸Šçš„æ‰€æœ‰å®¹å™¨éƒ½ä¸èƒ½åˆ›å»ºä»»ä½•æ–°çš„è¿›ç¨‹æˆ–çº¿ç¨‹ã€‚ åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæ”»å‡»è€…-å®¹å™¨é€šè¿‡è°ƒç”¨forkç³»ç»Ÿè°ƒç”¨åå¤ç”Ÿæˆè¿›ç¨‹ã€‚ç»“æœï¼Œåœ¨å—å®³å®¹å™¨ä¸­ï¼Œæ‰€æœ‰ä¸åˆ›å»ºæ–°è¿›ç¨‹ç›¸å…³çš„æ“ä½œéƒ½å¤±è´¥ï¼Œå¹¶æŠ¥é”™â€œèµ„æºä¸´æ—¶ä¸å¯ç”¨â€ã€‚å³ä½¿æ˜¯ä¸»æœºä¸Šçš„æ ¹ç”¨æˆ·ä¹Ÿä¼šé‡åˆ°åŒæ ·çš„æ•…éšœã€‚ 12345678910111213struct pid *alloc_pid(struct pid_namespace *ns,pid_t *set_tid, size_t set_tid_size)&#123; ... nr = idr_alloc_cyclic(&amp;tmp-&gt;idr, NULL, pid_min, pid_max, GFP_ATOMIC); ... if(nr &lt; 0) &#123; retval = (nr == ENOSPC) ? -EAGAIN : nr; goto out_free; &#125; pid-&gt;numbers[i].nr = nr; ...&#125; è¿™æ®µCä»£ç ç‰‡æ®µæ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œæ¶‰åŠåˆ°è¿›ç¨‹IDï¼ˆPIDï¼‰çš„åˆ†é…ã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ªåä¸ºalloc_pidçš„å‡½æ•°ï¼Œç”¨äºåœ¨ç»™å®šçš„namespace nsä¸­åˆ†é…ä¸€ä¸ªæ–°çš„PIDã€‚ alloc_pidå‡½æ•°æ¥å—ä»¥ä¸‹å‚æ•°ï¼š struct pid_namespace *nsï¼šè¿›ç¨‹IDçš„å‘½åç©ºé—´ï¼Œç”¨äºå°†PIDé™åˆ¶åœ¨ç‰¹å®šçš„namespaceèŒƒå›´å†…ã€‚ pid_t *set_tidï¼šæŒ‡å‘ä¸€ä¸ªåŒ…å«çº¿ç¨‹IDçš„æ•°ç»„ï¼Œè¿™äº›çº¿ç¨‹IDä¸æ–°åˆ†é…çš„PIDå…³è”ã€‚é€šå¸¸ç”¨äºcloneç³»ç»Ÿè°ƒç”¨ã€‚ size_t set_tid_sizeï¼šset_tidæ•°ç»„çš„å¤§å°ã€‚ åœ¨å‡½æ•°çš„ä¸»ä½“ä¸­ï¼š idr_alloc_cyclic()å‡½æ•°è¢«è°ƒç”¨ä»¥åœ¨tmp-&gt;idrä¸­åˆ†é…ä¸€ä¸ªæ–°çš„IDï¼ŒèŒƒå›´åœ¨pid_minå’Œpid_maxä¹‹é—´ã€‚GFP_ATOMICæ ‡å¿—è¡¨ç¤ºå†…å­˜åˆ†é…åº”è¯¥æ˜¯åŸå­æ€§çš„ï¼Œå³åœ¨ä¸é‡Šæ”¾å†…æ ¸é”çš„æƒ…å†µä¸‹è¿›è¡Œåˆ†é…ã€‚ å¦‚æœnrå°äº0ï¼Œè¯´æ˜åˆ†é…å¤±è´¥ã€‚æ ¹æ®å¤±è´¥çš„åŸå› ï¼Œretvalè¢«è®¾ç½®ä¸º-EAGAINï¼ˆå½“nrç­‰äºENOSPCï¼‰æˆ–nrã€‚ç„¶åè·³è½¬åˆ°out_freeæ ‡ç­¾ã€‚ å¦‚æœåˆ†é…æˆåŠŸï¼Œpid-&gt;numbers[i].nrè¢«è®¾ç½®ä¸ºæ–°åˆ†é…çš„IDã€‚ è¿™æ®µä»£ç è´Ÿè´£åœ¨ç»™å®šnamespaceä¸­åˆ†é…å’Œç®¡ç†è¿›ç¨‹IDã€‚ The effectiveness of the PID namespaceLinux v2.6.24å¼•å…¥äº†PID namespaceï¼Œå®ƒä¸ºè¿›ç¨‹æä¾›äº†ä¸€ç»„ç‹¬ç«‹çš„PIDï¼Œè¿™äº›PIDæ¥è‡ªå…¶ä»–PID namespaceã€‚ä½†æ˜¯ï¼Œåœ¨PID namespaceå®ç°ä¸­ï¼ŒLinuxå†…æ ¸ä¼šåœ¨æ ¹PID namespaceä¸­ä¸ºå…¶ä»–PID namespaceä¸­åˆ†é…çš„ä»»ä½•PIDåˆ†é…ä¸€ä¸ªé¢å¤–çš„PIDï¼Œè¿™æ ·å…¶ä»–PID namespaceä¸­çš„æ‰€æœ‰PIDéƒ½å¯ä»¥æ˜ å°„åˆ°æ ¹PID namespaceã€‚æ¢å¥è¯è¯´ï¼Œæ ¹PID namespaceä»ç„¶æ˜¯å…¨å±€å…±äº«çš„ã€‚å› æ­¤ï¼Œå³ä½¿æ”»å‡»è€…-å®¹å™¨å¤„äºåˆ†ç¦»çš„PID namespaceä¸­ï¼Œå…¶PIDåˆ†é…ä»ç„¶ä¼šè€—å°½æ ¹PID namespaceä¸­çš„PIDï¼Œä»è€Œå¯¼è‡´victim-containerå’Œä¸»æœºä¸Šçš„new-process-createå¤±è´¥ã€‚å› æ­¤ï¼Œå³ä½¿å¯ç”¨äº†PID namespaceï¼Œå®¹å™¨ä»ç„¶å®¹æ˜“å—åˆ°ä¸Šè¿°idrè€—å°½æ”»å‡»çš„æ”»å‡»ã€‚ The effectiveness of the PIDs control groupæœ€è¿‘åœ¨Linux v4.3ä¸­ä¹Ÿå¼•å…¥äº†PIDs cgroupã€‚å®ƒçš„ä½œç”¨æ˜¯ç”¨æ¥é™åˆ¶åˆ†é…åœ¨ä¸€ä¸ªæ§åˆ¶ç»„ä¸­çš„PIDsçš„æ€»æ•°ã€‚æ›´å…·ä½“åœ°è¯´ï¼ŒPIDsæ§åˆ¶ç»„åœ¨è¿›ç¨‹åˆ†å‰è¿‡ç¨‹ä¸­æ£€æŸ¥è¿›ç¨‹çš„é™åˆ¶ï¼Œå¦‚æœPIDsæ§åˆ¶ç»„ä¸­çš„æ€»è¿›ç¨‹æ•°ï¼ˆpids_cgroup-&gt;counterï¼‰è¾¾åˆ°ä¸Šé™ï¼ˆpids_cgroup -&gt;limitï¼‰ï¼Œåˆ™è¿”å›é”™è¯¯å¹¶ä¸­æ­¢åˆ†å‰ã€‚PIDsæ§åˆ¶ç»„åœ¨é˜²å¾¡ç›´æ¥åˆ†å‰æ–¹é¢æ˜¯æœ‰æ•ˆçš„ã€‚ç„¶è€Œï¼Œå®ƒåªå‘å½“å‰è¿›ç¨‹æ”¶å–pidå·ã€‚attacker-containerå¯ä»¥æ¬ºéª—å†…æ ¸æ¥åˆ†å‰å¤§é‡çš„å†…æ ¸çº¿ç¨‹ï¼Œæ¯”å¦‚é¢‘ç¹ä¸­æ­¢å¯¼è‡´å†…æ ¸äº§ç”Ÿä¸­æ–­å¤„ç†çº¿ç¨‹ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œidrè¢«å†…æ ¸çº¿ç¨‹è€—å°½ï¼Œè¿™å°±ç»•è¿‡äº†ç”± PIDs cgroupã€‚ Attacks on Memory ManagementLinuxå†…æ ¸å¼•å…¥äº†å„ç§å†…æ ¸æ•°æ®ç»“æ„ï¼Œä¾‹å¦‚mm_structç”¨äºä¿å­˜è¿›ç¨‹çš„æ‰€æœ‰å†…å­˜ç›¸å…³ä¿¡æ¯ï¼Œvm_area_structç”¨äºè¡¨ç¤ºè™šæ‹Ÿå†…å­˜åŒºåŸŸã€‚æ­¤å¤–ï¼Œä¸ºäº†æé«˜è¯»å†™æ•ˆç‡ï¼ŒLinuxå†…æ ¸è¿˜ä½¿ç”¨å†…å­˜ä½œä¸ºç¼“å†²åŒºæ¥ç¼“å­˜æŸäº›æ•°æ®ã€‚æ­¤å¤–ï¼Œè¿˜ä»‹ç»äº†å›å†™æ–¹æ¡ˆï¼Œå³åªå¯¹å†…å­˜è¿›è¡Œå†™æ“ä½œã€‚è„å†…å­˜é¡µç¨åå°†ç”±å†…æ ¸çº¿ç¨‹å†™å…¥ç£ç›˜ã€‚ä½¿ç”¨write-backæ–¹æ¡ˆï¼Œè°ƒç”¨æ–¹åªéœ€è¦å†™å…¥å†…å­˜ï¼Œè€Œä¸éœ€è¦ç­‰å¾…è€—æ—¶çš„ç£ç›˜ioæ“ä½œå®Œæˆ(å³wirtr-through)ï¼Œè¿™å¤§å¤§æé«˜äº†å†™æ€§èƒ½ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å‘ç°å†…æ ¸å¹¶æ²¡æœ‰éš”ç¦»æˆ–é™åˆ¶è„å†…å­˜åŒºåŸŸçš„ä½¿ç”¨ï¼Œè¿™ç»™äº†æ”»å‡»è€…è€—å°½æ‰€æœ‰è„å†…å­˜çš„æœºä¼šï¼Œè¿™å¤§å¤§å‡æ…¢äº†å…¶ä»–å®¹å™¨çš„é€Ÿåº¦ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è®¨è®ºå¯¹è„å†…å­˜çš„æ”»å‡»ã€‚ Attacking dirty_throttle_control memory dirty ratioLinuxå†…æ ¸ä¸ºè„åŒºæ§åˆ¶å¼•å…¥äº†dirty_throttle_controlç»“æ„ä½“ï¼Œå®ƒä½¿ç”¨dirtyå­—æ®µè¡¨ç¤ºæ•´ä¸ªå†…æ ¸ç©ºé—´çš„dirty ratioã€‚åªè¦dirtyå€¼å¤ªé«˜ï¼Œå†…æ ¸å°±ä¼šå”¤é†’åå°çº¿ç¨‹ï¼Œå°†è„å†…å­˜åŒæ­¥åˆ°ç£ç›˜ã€‚ä½†åŒæ—¶ç”±äºdirtyæ¯”è¿‡é«˜ï¼Œå†…æ ¸ä¼šé˜»å¡write_backï¼Œå°†æ‰€æœ‰å†™éƒ½è½¬æ¢ä¸ºwrite_throughï¼Œå†™æ€§èƒ½å¤§å¤§é™ä½ã€‚ ä¸å¹¸çš„æ˜¯ï¼Œå†…æ ¸æ²¡æœ‰ä¸ºå†…å­˜dirty ratioæä¾›ä»»ä½•éš”ç¦»ã€‚ä»»ä½•è¿›ç¨‹éƒ½å¯èƒ½å½±å“å…¨å±€å†…å­˜dirty ratioã€‚åœ¨æˆ‘ä»¬çš„æ”»å‡»ä¸­ï¼Œæ”»å‡»è€…-å®¹å™¨ä½¿ç”¨ddå‘½ä»¤ç”Ÿæˆæ–‡ä»¶ï¼Œå¿«é€Ÿå ç”¨æ‰€æœ‰è„å†…å­˜ï¼Œè¾¾åˆ°å†…å­˜dirty ratioé™åˆ¶ã€‚ç»“æœï¼Œæ¥è‡ªä¸»æœºæˆ–å—å®³è€…å®¹å™¨çš„æ‰€æœ‰å†™æ“ä½œéƒ½è¢«è½¬æ¢ä¸ºwrite_throughï¼Œè¿™æå¤§åœ°é™ä½äº†æ€§èƒ½ã€‚åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œç”±äºæ”»å‡»ï¼Œå—å®³è€…å®¹å™¨ä¸Šçš„å‘½ä»¤dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;mnt&#x2F;test bs&#x3D;1M count&#x3D;1024çš„æ€§èƒ½ä»1.2 GB&#x2F;sä¸‹é™åˆ°32.6 MB&#x2F;sï¼Œå¯¼è‡´97.3%çš„å‡é€Ÿã€‚ æ­¤å¤–ï¼Œå³ä½¿æ˜¯ä¸»æœºä¸Šçš„ç‰¹æƒæ ¹ç”¨æˆ·ä¹Ÿæœ‰96.1%çš„æ€§èƒ½ä¸‹é™ã€‚ è¯·æ³¨æ„ï¼Œå½“å‰Linuxå†…æ ¸æ²¡æœ‰ä¸å†…å­˜ç®¡ç†ç›¸å…³çš„namespaceï¼Œå†…å­˜cgroupç”¨äºé™åˆ¶å†…å­˜ä½¿ç”¨ï¼Œè€Œä¸æ˜¯é™åˆ¶å†…å­˜dirty ratioã€‚å› æ­¤ï¼Œæ— æ³•é˜²å¾¡é’ˆå¯¹å†…å­˜dirty ratioçš„æ”»å‡»ã€‚ Attacks on Storage Managementæ“ä½œç³»ç»Ÿå†…æ ¸å°†ç£ç›˜æˆ–å…¶ä»–è¾…åŠ©å­˜å‚¨æŠ½è±¡ä¸ºæ–‡ä»¶ï¼Œå¹¶å¼•å…¥å„ç§ä¸æ–‡ä»¶ç›¸å…³çš„æŠ½è±¡èµ„æºã€‚å®é™…ä¸Šï¼ŒLinuxå†…æ ¸ä¸­çš„å­˜å‚¨ç®¡ç†æ˜¯å¤æ‚çš„ï¼Œå®ƒæ¶‰åŠæ•°åƒä¸ªå‡½æ•°å’Œæ•°æ®ç»“æ„ã€‚åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæˆ‘ä»¬å‘ç°æœ‰133ä¸ªä¸å­˜å‚¨ç›¸å…³çš„æŠ½è±¡èµ„æºå¯ä»¥ä»å®¹å™¨è¿›ç¨‹ä¸­è®¿é—®ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå†…æ ¸æ²¡æœ‰æä¾›ä»»ä½•namespaceæˆ–cgroupæ¥éš”ç¦»æˆ–é™åˆ¶è¿™äº›æŠ½è±¡èµ„æºçš„ä½¿ç”¨ã€‚å› æ­¤ï¼Œæ”»å‡»è€…å®¹å™¨å¯ä»¥è€—å°½è¿™äº›æŠ½è±¡èµ„æºï¼Œå¯¹å…±äº«å†…æ ¸ä¸Šçš„å…¶ä»–å®¹å™¨å‘èµ·DoSæ”»å‡»ã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¯´æ˜æ¶æ„å®¹å™¨å¦‚ä½•åˆ©ç”¨æ–‡ä»¶é™åˆ¶å˜é‡nr_filesè¿›è¡ŒDoSæ”»å‡»ã€‚ Attacking nr_filesnr_filesæ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå®ƒè®¡ç®—å†…æ ¸ä¸­æ‰“å¼€çš„æ–‡ä»¶æ€»æ•°ã€‚æ›´å…·ä½“åœ°è¯´ï¼Œå¯¹äºæ¯ä¸ªåˆ†é…çš„ç»“æ„æ–‡ä»¶ï¼Œå†…æ ¸å°†nr_filesåŠ 1ã€‚ä¸å¹¸çš„æ˜¯ï¼Œnr_filesæ˜¯æ‰€æœ‰è¿›ç¨‹å…±äº«çš„ã€‚å®ƒæ—¢ä¸å—namespaceçš„éš”ç¦»ï¼Œä¹Ÿä¸å—ä»»ä½•cgroupçš„é™åˆ¶ã€‚å› æ­¤ï¼Œæ”»å‡»å®¹å™¨å¯ä»¥å¾ˆå®¹æ˜“åœ°è€—å°½nr_filesæ¥å®ç°DoSæ”»å‡»ã€‚ ä¸ºäº†éªŒè¯è¿™ç§æ”»å‡»çš„å¯è¡Œæ€§ï¼Œæˆ‘ä»¬çš„æ”»å‡»å®¹å™¨ç”Ÿæˆäº†æ•°ç™¾ä¸ªè¿›ç¨‹ï¼Œæ¯ä¸ªè¿›ç¨‹æ‰“å¼€1024ä¸ªæ–‡ä»¶ã€‚å› æ­¤ï¼Œnr_filesè¾¾åˆ°å…¶æé™ã€‚ç»“æœï¼Œåœ¨ä¸»æœºå’Œå—å®³è€…å®¹å™¨ä¸Šï¼Œæ‰€æœ‰æ–‡ä»¶æ‰“å¼€æ“ä½œéƒ½å¤±è´¥ï¼Œå†…æ ¸å‘å‡ºâ€œç³»ç»Ÿä¸­æ‰“å¼€çš„æ–‡ä»¶å¤ªå¤šâ€çš„è­¦å‘Šã€‚æˆ‘ä»¬çš„æ”»å‡»è¯å®ï¼Œå³ä½¿åªæœ‰å‡ ç™¾ä¸ªè¿›ç¨‹ï¼Œæ”»å‡»è€…ä¹Ÿèƒ½å¤Ÿè€—å°½nr_filesã€‚è€Œä¸ºäº†å¯ç”¨æ€§ï¼Œpid cgroupé€šå¸¸å…è®¸æ•°åƒä¸ªè¿›ç¨‹ã€‚å› æ­¤ï¼Œå³ä½¿å¯ç”¨äº†pid cgroupï¼Œæ”»å‡»è€…-å®¹å™¨ä»ç„¶å¯ä»¥æˆåŠŸåœ°å¯¹nr_filesè¿›è¡Œdosæ”»å‡»ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œnr_filesåœ¨æ‰€æœ‰è¿›ç¨‹(åŒ…æ‹¬æ ¹è¿›ç¨‹å’Œéæ ¹è¿›ç¨‹)ä¹‹é—´å…±äº«ã€‚ å› æ­¤ï¼Œä¸ä»…éç‰¹æƒå®¹å™¨è¿›ç¨‹å—åˆ°å½±å“ï¼Œä¸»æœºä¸Šçš„æ ¹è¿›ç¨‹ä¹Ÿä¸èƒ½æ‰§è¡Œä»»ä½•æ–‡ä»¶æ‰“å¼€æ“ä½œã€‚ 12345678910111213141516171819202122232425static struct percpu_counter nr_files __cacheline_aligner_in_smp;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, const struct cred *cred)&#123; static long old_max; struct file *f; if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN)) &#123; ... goto over; &#125; f = __alloc_file(flags, cred); if (!IS_ERR(f)) percpu_counter_inc(&amp;nr_files); ...over: ... return ERR_PTR(-ENFILE);&#125; Attacks on IO ManagementIOç®¡ç†æ˜¯æ“ä½œç³»ç»Ÿçš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚ä¸ºäº†ä¾¿äºç®¡ç†ï¼ŒLinuxå†…æ ¸å°†IOè®¾å¤‡æŠ½è±¡åˆ°/devæ–‡ä»¶ä¸­ï¼Œå¹¶å¼•å…¥æŠ½è±¡èµ„æº(å¦‚tty_struct)æ¥å®ç°IOè®¾å¤‡ç®¡ç†ã€‚ä¸å‰é¢çš„æƒ…å†µç±»ä¼¼ï¼Œè¿™äº›æŠ½è±¡èµ„æºä¸å—ä»»ä½•namespaceæˆ–æ§cgroupçš„éš”ç¦»æˆ–é™åˆ¶ï¼Œå› æ­¤ä¼šå¯¼è‡´æ–°çš„æ”»å‡»ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬å°†ä»‹ç»é’ˆå¯¹pty_countçš„æ”»å‡»ï¼Œå®ƒä¼šå¯¼è‡´SSHè¿æ¥å‡ºç°DoSã€‚ Attacking pty_countLinuxå†…æ ¸å°†ä¼ªç»ˆç«¯pseudo-terminal(ç¼©å†™ä¸ºpty)æŠ½è±¡ä¸º/dev/ptmxå’Œ/dev/ptsã€‚ä¸æ­¤åŒæ—¶ï¼Œå†…æ ¸è¿˜ä½¿ç”¨ä¸€ä¸ªåä¸ºpty_countçš„å…¨å±€å˜é‡æ¥è®¡ç®—æ‰“å¼€çš„pseudo-terminalçš„æ€»æ•°ï¼Œæ¯æ‰“å¼€ä¸€æ¬¡/dev/ptmxï¼Œpseudo-terminalçš„æ€»æ•°å°±å¢åŠ 1ï¼Œå¦‚ä»£ç ã€‚ä½†æ˜¯ï¼Œå†…æ ¸æ²¡æœ‰æä¾›ä»»ä½•namespaceæˆ–cgroupæ¥éš”ç¦»æˆ–é™åˆ¶pty_countçš„ä½¿ç”¨ã€‚å› æ­¤ï¼Œæ”»å‡»è€…å¯ä»¥å¾ˆå®¹æ˜“åœ°è€—å°½pty_countã€‚ 123456789101112131415161718static atomic_t pty_count = ATOMIC_INIT(0);int devpts_new_index(struct pts_fs_info *fsi)&#123; int index = -ENOSPC; if (atomic_inc_return(&amp;pty_count) &gt;= (pty_limit - (fsi-&gt;mount_ops.reserve ? 0 : pty_reserve))) goto out; return index;&#125;static int ptmx_open(struct inode *inode, struct file *flip)&#123; ... index = devpts_new_index(fsi); ...&#125; è¿™æ®µCä»£ç ç‰‡æ®µæ˜¯Linuxå†…æ ¸ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œæ¶‰åŠåˆ°ä¼ªç»ˆç«¯ï¼ˆPTYï¼‰çš„åˆ†é…å’Œç®¡ç†ã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ªåä¸ºdevpts_new_indexçš„å‡½æ•°ï¼Œç”¨äºåœ¨ç»™å®šçš„æ–‡ä»¶ç³»ç»Ÿä¿¡æ¯fsiä¸­åˆ†é…ä¸€ä¸ªæ–°çš„ä¼ªç»ˆç«¯ç´¢å¼•ã€‚æ­¤å¤–ï¼Œè¿˜å±•ç¤ºäº†ä¸€ä¸ªåä¸ºptmx_opençš„å‡½æ•°ï¼Œå®ƒåœ¨æ‰“å¼€ä¼ªç»ˆç«¯ä¸»è®¾å¤‡ï¼ˆPTMXï¼‰æ—¶è°ƒç”¨devpts_new_indexã€‚ ä¸€ä¸ªåä¸ºpty_countçš„åŸå­å˜é‡è¢«åˆå§‹åŒ–ä¸º0ã€‚å®ƒè¡¨ç¤ºå½“å‰åˆ†é…çš„ä¼ªç»ˆç«¯çš„æ•°é‡ã€‚ devpts_new_indexå‡½æ•°æ¥å—ä¸€ä¸ªå‚æ•°ï¼š struct pts_fs_info *fsiï¼šä¸€ä¸ªæŒ‡å‘ä¼ªç»ˆç«¯æ–‡ä»¶ç³»ç»Ÿä¿¡æ¯çš„æŒ‡é’ˆã€‚ åœ¨devpts_new_indexå‡½æ•°ä¸­ï¼š åˆå§‹åŒ–indexä¸º-ENOSPCï¼Œè¡¨ç¤ºæ²¡æœ‰è¶³å¤Ÿçš„ç©ºé—´åˆ†é…æ–°çš„ç´¢å¼•ã€‚ å¢åŠ pty_countçš„å€¼ã€‚å¦‚æœå¢åŠ åçš„å€¼å¤§äºç­‰äºpty_limit - (fsi-&gt;mount_ops.reserve ? 0 : pty_reserve)ï¼Œåˆ™è·³è½¬åˆ°outæ ‡ç­¾ã€‚ è¿”å›indexã€‚ ptmx_openå‡½æ•°æ˜¯åœ¨æ‰“å¼€ä¼ªç»ˆç«¯ä¸»è®¾å¤‡ï¼ˆPTMXï¼‰æ—¶è°ƒç”¨çš„ã€‚å®ƒæ¥å—ä¸¤ä¸ªå‚æ•°ï¼š struct inode *inodeï¼šè¡¨ç¤ºä¼ªç»ˆç«¯ä¸»è®¾å¤‡ï¼ˆPTMXï¼‰çš„inodeç»“æ„ã€‚ struct file *flipï¼šè¡¨ç¤ºä¼ªç»ˆç«¯ä¸»è®¾å¤‡ï¼ˆPTMXï¼‰çš„fileç»“æ„ã€‚ åœ¨ptmx_openå‡½æ•°ä¸­ï¼Œè°ƒç”¨devpts_new_index(fsi)ä»¥è·å–ä¸€ä¸ªæ–°çš„ä¼ªç»ˆç«¯ç´¢å¼•ã€‚ è¿™æ®µä»£ç è´Ÿè´£åœ¨ç»™å®šçš„ä¼ªç»ˆç«¯æ–‡ä»¶ç³»ç»Ÿä¿¡æ¯ä¸­åˆ†é…å’Œç®¡ç†ä¼ªç»ˆç«¯ç´¢å¼•ã€‚å½“æ‰“å¼€ä¼ªç»ˆç«¯ä¸»è®¾å¤‡ï¼ˆPTMXï¼‰æ—¶ï¼Œä¼šè°ƒç”¨devpts_new_indexå‡½æ•°ä»¥è·å–æ–°çš„ä¼ªç»ˆç«¯ç´¢å¼•ã€‚ åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œæ”»å‡»è€…ä¸æ–­æ‰“å¼€/dev/ptmxåœ¨è§¦å‘ptmx_openï¼Œå®ƒè°ƒç”¨devpts_new_indexå¹¶å¢åŠ pty_countã€‚åœ¨å‡ ç§’é’Ÿå†…ï¼Œpty_countè¾¾åˆ°æé™ï¼Œæ‰€æœ‰æ¥ä¸‹æ¥çš„ptmx_openæ“ä½œéƒ½ä¼šå¤±è´¥ã€‚å…¶åæœå¾ˆä¸¥é‡ï¼Œå› ä¸ºptyè®¾å¤‡è¢«å„ç§åº”ç”¨å¹¿æ³›ä½¿ç”¨ï¼Œå¦‚SSHè¿æ¥ã€‚ç»“æœæ˜¯ï¼Œç”±äºä¼ªç»ˆç«¯æ‰“å¼€å¤±è´¥ï¼Œæ‰€æœ‰å¯¹ä»»ä½•å…¶ä»–å®¹å™¨çš„SSHè¿æ¥å°è¯•éƒ½ä¼šå¤±è´¥ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œä¸»æœºæ— æ³•å¯åŠ¨ä»»ä½•æ–°çš„å®¹å™¨ï¼Œå› ä¸ºæ–°å®¹å™¨çš„è¿æ¥ç”±äºåŒæ ·çš„é”™è¯¯è€Œè¢«æ‹’ç»ã€‚ Attacking FreeBSD and Fuchsia KernelsæŠ½è±¡èµ„æºæ”»å‡»çš„æ ¹æœ¬åŸå› æ˜¯å…±äº«çš„å†…æ ¸æ•°æ®(å³æŠ½è±¡èµ„æº)ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æ¼”ç¤ºå…±äº«å†…æ ¸æ•°æ®è¿˜ä½¿FreeBSDå’ŒFuchsiaå®¹æ˜“å—åˆ°æŠ½è±¡èµ„æºæ”»å‡»ã€‚ Attacking FreeBSD åœ¨FreeBSDå†…æ ¸ä¸­ï¼Œåœ¨Linuxå†…æ ¸ä¸­ç±»ä¼¼çš„èµ„æºä¹‹åï¼Œæˆ‘ä»¬æ‰‹åŠ¨è¯†åˆ«äº†5ä¸ªå…±äº«çš„å…¨å±€æŠ½è±¡èµ„æºï¼Œåˆ†åˆ«æ˜¯dp_dirty_totalã€numvnodesã€openfilesã€pidå’Œptyã€‚æˆ‘ä»¬çš„å®éªŒè¿›ä¸€æ­¥è¯å®äº†å‰ä¸¤ä¸ªå¯ä»¥è¢«DoSæ”»å‡»ï¼Œè€Œåä¸‰ä¸ªåˆ™å—åˆ°rctl per-jailçš„é™åˆ¶ã€‚ å®éªŒæ˜¯åœ¨FreeBSD 13.0-RELEASEå’ŒEzjail-admin v3.4.2ä¸Šè¿›è¡Œçš„ï¼Œè¿è¡Œåœ¨å…·æœ‰Intelé…·ç¿i5å¤„ç†å™¨ã€8GBå†…å­˜å’Œ40GBç¡¬ç›˜çš„è™šæ‹Ÿæœºä¸Šã€‚Ezjailæ˜¯ä¸€ä¸ªjailç®¡ç†æ¡†æ¶ã€‚ezjailå‘½ä»¤æä¾›äº†ä¸€ç§ä½¿ç”¨FreeBSDçš„jailç³»ç»Ÿåˆ›å»ºå¤šä¸ªjailçš„ç®€å•æ–¹æ³•ã€‚è¿™é‡Œçš„jailç±»ä¼¼äºLinuxä¸Šçš„å®¹å™¨ã€‚æˆ‘ä»¬æ ¹æ®FreeBSDæ‰‹å†Œå»ºç«‹äº†ä¸¤ä¸ªjailï¼Œå¹¶ä½¿ç”¨rctlæ¥é™åˆ¶æ¯ä¸ªjailçš„èµ„æºã€‚æˆ‘ä»¬ä½¿ç”¨è¿™ä¸¤ä¸ªjailsä½œä¸ºattacker-jailå’Œvictim-jailï¼Œè¿™ç±»ä¼¼äºÂ§3.1ä¸­çš„å®¹å™¨è®¾ç½®ã€‚ å¯¹äºè„è®¡æ•°å™¨dp_dirty_total, FreeBSDä¸­çš„ZFSå¼•å…¥äº†dsl_poolç»“æ„ä½“æ¥è®°å½•æ¯ä¸ªZFSæ± çš„æ•°æ®ã€‚dsl_poolç»“æ„ä½“ä½¿ç”¨dp_dirty_totalå­—æ®µè¡¨ç¤ºæ•´ä¸ªZFSæ± è„æ•°æ®ã€‚å½“dp_dirty_totalè¾¾åˆ°zfs_dirty_data_maxçš„é™åˆ¶æ—¶ï¼ŒZFSå°†å»¶è¿Ÿå³å°†è¿›è¡Œçš„å†™æ“ä½œï¼Œå¹¶ç­‰å¾…è„æ•°æ®åŒæ­¥åˆ°ç£ç›˜ã€‚ä¸å¹¸çš„æ˜¯ï¼ŒFreeBSDæ²¡æœ‰ä¸ºdp_dirty_totalæä¾›ä»»ä½•éš”ç¦»ã€‚åœ¨attacker-jailä¸­ï¼Œæˆ‘ä»¬è¿è¡Œå‘½ä»¤dd if=/dev/zero of=/mnt/test bs=1M count=1024(ä¸Â§3.3ä¸­çš„ç›¸åŒ)æ¥è€—å°½dp_dirty_totalã€‚å› æ­¤ï¼Œvictim-jailçš„IOæ€§èƒ½ä¸‹é™äº†46%ã€‚ å¯¹äºnumvnodes, FreeBSDä½¿ç”¨vnodeç»“æ„ä½“æ¥è¡¨ç¤ºæ–‡ä»¶ç³»ç»Ÿå®ä½“ï¼Œä¾‹å¦‚æ–‡ä»¶æˆ–ç›®å½•ã€‚FreeBSDè¿˜ä¿ç•™äº†ä¸€ä¸ªå…¨å±€å˜é‡numvnodesæ¥è®°å½•æ•´ä¸ªå†…æ ¸ä¸­vnodeçš„æ€»æ•°ã€‚æé™åœ¨maxvnodesã€‚åœ¨å®éªŒä¸­ï¼Œé€šè¿‡åœ¨attacker-victimä¸­é‡å¤åˆ›å»ºç›®å½•ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°è€—å°½ä¸»æœºçš„numvnodeså¹¶è¾¾åˆ°maxvnodesçš„é™åˆ¶ã€‚ Attacking Fushsia Fuchsiaä½¿ç”¨Zirconå†…æ ¸ï¼Œä»–å¼•å…¥äº†handleçš„æ¦‚å¿µï¼Œå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºå¼•ç”¨å†…æ ¸å¯¹è±¡ã€‚Zirconç»´æŠ¤äº†ä¸€ä¸ªåä¸ºgHandleTableArenaçš„å…¨å±€æ•°æ®ç»“æ„ï¼Œç”¨äºåˆ†é…æ‰€æœ‰å¥æŸ„ã€‚å†…æ ¸ä¸­handleçš„é™åˆ¶æ˜¯kMaxHandleCountã€‚handleåœ¨Zirconä¸­ä½¿ç”¨éå¸¸é¢‘ç¹ã€‚ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œæˆ‘ä»¬å‘ç°handleçš„åˆ›å»ºä¸å—é™åˆ¶ã€‚æˆ‘ä»¬åœ¨Fuchsiaæ¨¡æ‹Ÿå™¨ä¸Šè¿›ä¸€æ­¥ç¡®è®¤äº†è¿™ä¸ªé—®é¢˜ã€‚å…·æœ‰åŸºæœ¬æƒé™(ç±»ä¼¼äºLinuxä¸­çš„åŠŸèƒ½)çš„ç”¨æˆ·å¯ä»¥é‡å¤åˆ›å»ºhandleï¼Œè€—å°½æ‰€æœ‰handleï¼Œä»è€Œå¯¼è‡´æ•´ä¸ªç³»ç»Ÿå´©æºƒã€‚æˆ‘ä»¬å‘Fuchsiaå¼€å‘äººå‘˜æŠ¥å‘Šäº†è¿™ä¸ªé—®é¢˜ã€‚ä»–ä»¬å·²ç»ç¡®è®¤äº†è¿™ä¸ªé—®é¢˜ï¼Œå¹¶è®¡åˆ’åœ¨ç¡®å®šæ›´å¤šçš„æ”»å‡»è½½ä½“åˆ°æœ¬åœ°DoSåä¿®å¤è¿™ä¸ªé—®é¢˜ã€‚ Summaryä»ä¸Šé¢çš„è®¨è®ºä¸­ï¼Œå¾ˆå®¹æ˜“çœ‹å‡ºæŠ½è±¡çš„èµ„æºæ”»å‡»æ˜¯éå¸¸å®ç”¨çš„ï¼Œåæœæ˜¯ä¸¥é‡çš„ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼ŒæŠ½è±¡èµ„æºåœ¨Linuxå†…æ ¸ä¸­éå¸¸å¸¸è§ï¼Œå½±å“LinuxåŠŸèƒ½çš„å„ä¸ªæ–¹é¢ã€‚æ­¤å¤–ï¼ŒæŠ½è±¡èµ„æºæ”»å‡»æ˜¯æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ‰€å›ºæœ‰çš„ã€‚å®ƒä¹Ÿé€‚ç”¨äºFreeBSDå’ŒFuchsiaå†…æ ¸ã€‚ Static Analysis Of Container-Exhaustible Abstract Resourceså¦‚å‰æ‰€è¿°ï¼ŒæŠ½è±¡èµ„æºå¯¹å®¹å™¨è‡³å…³é‡è¦ã€‚ å¦ä¸€æ–¹é¢ï¼Œæœ‰æˆåƒä¸Šä¸‡çš„æŠ½è±¡èµ„æºï¼Œè¿™ä½¿å¾—å‡ ä¹ä¸å¯èƒ½åˆ—ä¸¾æ‰€æœ‰è¿™äº›èµ„æºã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬è¿ˆå‡ºäº†è¯†åˆ«å®¹å™¨å…±äº«çš„å¯è€—å°½æŠ½è±¡èµ„æºçš„ç¬¬ä¸€æ­¥ã€‚ Challenges é¦–å…ˆï¼Œå¾ˆéš¾è¯†åˆ«æœ‰æ„ä¹‰çš„æŠ½è±¡èµ„æºï¼Œå°¤å…¶æ˜¯é‚£äº›åœ¨å†…æ ¸ä¸­å…±äº«çš„èµ„æºã€‚Linuxå†…æ ¸ä¸­çš„æŠ½è±¡èµ„æºå¯ä»¥æ˜¯å˜é‡æˆ–æ•°æ®ç»“æ„å®ä¾‹ã€‚ç„¶è€Œï¼Œå¹¶éæ‰€æœ‰å˜é‡æˆ–æ•°æ®ç»“æ„å®ä¾‹éƒ½æ˜¯æœ‰æ„ä¹‰çš„æŠ½è±¡èµ„æºã€‚æˆ‘ä»¬éœ€è¦æ‰¾åˆ°å¯¹æ“ä½œç³»ç»ŸåŠŸèƒ½è‡³å…³é‡è¦çš„æŠ½è±¡èµ„æºã€‚æ­¤å¤–ï¼Œæ‰€è¯†åˆ«çš„æŠ½è±¡èµ„æºéœ€è¦åœ¨å®¹å™¨ä¹‹é—´å…±äº«ï¼Œä»¥ä¾¿ä¸€ä¸ªå®¹å™¨å¯ä»¥è€—å°½è¿™äº›èµ„æºæ¥æ”»å‡»å…¶ä»–å®¹å™¨ã€‚ä¸å¹¸çš„æ˜¯ï¼Œæ²¡æœ‰å…³äºå¯å…±äº«æŠ½è±¡èµ„æºçš„æ–‡æ¡£ã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨åŸºäºé…ç½®çš„åˆ†æconfiguration-based analysiså’ŒåŸºäºè®¿é—®çš„åˆ†æaccess-based analysisæ¥è¯†åˆ«Linuxå†…æ ¸ä¸­çš„å„ç§å…±äº«æŠ½è±¡èµ„æºã€‚ å…¶æ¬¡ï¼Œå†³å®šå®¹å™¨æ˜¯å¦å¯ä»¥ç”¨å°½ç‰¹å®šçš„æŠ½è±¡èµ„æºæ˜¯ä¸€ä¸ªæŒ‘æˆ˜ã€‚ä¸æ™®é€šçš„ç”¨æˆ·ç©ºé—´ç¨‹åºä¸åŒï¼Œä»å®¹å™¨ä¸­è®¿é—®èµ„æºé¢ä¸´æ›´å¤šçš„é™åˆ¶ï¼Œå¦‚namespaceã€cgroupå’Œseccompã€‚æ­¤å¤–ï¼Œç”±äºæ¯ä¸ªå®¹å™¨åœ¨ä¸€ä¸ªå•ç‹¬çš„ç”¨æˆ·ä¸­è¿è¡Œï¼Œå…¶èµ„æºæ¶ˆè€—ä¹Ÿå—åˆ°æ¯ä¸ªç”¨æˆ·çš„é™åˆ¶ã€‚å› æ­¤ï¼Œå¯¹èµ„æºæ¶ˆè€—ç‚¹çš„ç®€å•å¯è¾¾æ€§åˆ†æä¸èƒ½è¯´æ˜å®¹å™¨å¯¹æŠ½è±¡èµ„æºçš„å¯æ§æ€§ã€‚ä¾‹å¦‚ã€å¯¹äºè¢«namespaceéš”ç¦»çš„æŠ½è±¡èµ„æºï¼Œå³ä½¿å®¹å™¨å¯ä»¥æ¶ˆè´¹è¿™äº›æŠ½è±¡èµ„æºï¼Œç”±äºnamespaceçš„éš”ç¦»ï¼Œå®ƒä»ç„¶å¯èƒ½ä¸ä¼šå½±å“å…¶ä»–å®¹å™¨ã€‚å› æ­¤ï¼Œä¸ºäº†å…‹æœè¿™ä¸€æŒ‘æˆ˜ï¼Œæˆ‘ä»¬æå‡ºäº†å®¹å™¨å¯æ§æ€§åˆ†æï¼ŒåŒ…æ‹¬seccompé™åˆ¶åˆ†æã€per-useré™åˆ¶åˆ†æå’Œnamespaceéš”ç¦»åˆ†æï¼Œä»¥è¿›ä¸€æ­¥è¿‡æ»¤å®¹å™¨å¯è€—è´¹çš„èµ„æºã€‚ å›¾æ˜¾ç¤ºäº†æˆ‘ä»¬çš„å·¥å…·çš„ä½“ç³»ç»“æ„ï¼Œå®ƒè‡ªåŠ¨è¯†åˆ«å‡ºå®¹å™¨å¯è€—å°½çš„æŠ½è±¡èµ„æºã€‚åˆ†æå·¥å…·ä»¥å†…æ ¸æºIRä½œä¸ºè¾“å…¥ã€‚å®ƒé¦–å…ˆä½¿ç”¨Â§4.1ä¸­åŸºäºé…ç½®çš„åˆ†æå’ŒåŸºäºè®¿é—®çš„åˆ†ææ¥è¯†åˆ«æ‰€æœ‰å†…æ ¸å¯å…±äº«çš„æŠ½è±¡èµ„æºã€‚ç„¶åè¿›è¡ŒÂ§4.2ä¸­çš„ç³»ç»Ÿè°ƒç”¨å¯è¾¾æ€§åˆ†æå’Œå®¹å™¨é™åˆ¶åˆ†æï¼ŒåŒ…æ‹¬seccompã€per-userå’Œnamespaceé™åˆ¶åˆ†æï¼Œåˆ†æè¿™äº›æŠ½è±¡èµ„æºä¸Šçš„å®¹å™¨å¯æ§æ€§ã€‚ æ­¤å¤–ï¼Œæˆ‘ä»¬åœ¨Â§4.3ç»™å‡ºäº†åˆ†æç»“æœã€‚ Identification of Kernel Shareable Abstract Resourceså¦‚å‰æ‰€è¿°ï¼Œä»æˆåƒä¸Šä¸‡çš„å†…æ ¸å˜é‡å’Œæ•°æ®ç»“æ„å®ä¾‹ä¸­è¯†åˆ«æœ‰æ„ä¹‰çš„æŠ½è±¡èµ„æºå…·æœ‰æŒ‘æˆ˜æ€§ã€‚æ›´å›°éš¾çš„æ˜¯ï¼Œä¸ºäº†ç¡®ä¿è¿™äº›æŠ½è±¡èµ„æºåœ¨å®¹å™¨ä¹‹é—´ç›´æ¥æˆ–é—´æ¥åœ°å…±äº«ï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒä»¬ç¼©å°åˆ°å¯å…±äº«çš„å†…æ ¸æŠ½è±¡èµ„æºã€‚ ä¸ºäº†å…‹æœè¿™ä¸€æŒ‘æˆ˜ï¼Œæˆ‘ä»¬åˆ©ç”¨å†…æ ¸ç¼–ç¨‹èŒƒä¾‹å¹¶æå‡ºåŸºäºé…ç½®çš„åˆ†æå’ŒåŸºäºè®¿é—®çš„åˆ†ææ¥è¯†åˆ«å†…æ ¸å¯å…±äº«èµ„æºã€‚ Configuration-based AnalysisLinuxå†…æ ¸åœ¨/proc/sysä¸‹æä¾›sysctlæ¥å£ï¼Œå…è®¸ç”¨æˆ·ç©ºé—´ç¨‹åºé…ç½®å†…æ ¸å‚æ•°ã€‚æˆ‘ä»¬çš„ä¸»è¦è§‚å¯Ÿç»“æœæ˜¯ï¼Œè¿™äº›sysctlé…ç½®ä¸­çš„å¤§å¤šæ•°ç”¨äºæŠ½è±¡çš„èµ„æºé™åˆ¶ï¼Œä¾‹å¦‚é™åˆ¶æ–‡ä»¶æ•°fs.file-nræˆ–å†…å­˜å¤§é¡µvm.nr_hugepagesã€‚å› æ­¤ï¼Œæ‰€æœ‰å®¹å™¨éƒ½å…±äº«ç”±sysctlé…ç½®æŒ‡å®šçš„ç›¸åŒå…¨å±€é™åˆ¶ã€‚è¿™æ ·çš„sysctlé…ç½®æä¾›äº†å…³äºå®¹å™¨ä¹‹é—´å¯å…±äº«çš„æŠ½è±¡èµ„æºçš„é‡è¦çº¿ç´¢ã€‚ åŸºäºä¸Šè¿°è§‚å¯Ÿï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨sysctlé…ç½®æ¥è¯†åˆ«å¯å…±äº«çš„å†…æ ¸æŠ½è±¡èµ„æºï¼Œç§°ä¸ºåŸºäºé…ç½®çš„åˆ†æï¼Œå®ƒåŒ…æ‹¬ä¸‰ä¸ªåŸºæœ¬æ­¥éª¤ã€‚ é¦–å…ˆï¼Œå®ƒä½¿ç”¨ç‰¹å®šçš„sysctlæ•°æ®ç±»å‹æ¥è¯†åˆ«æ‰€æœ‰çš„sysctlç›¸å…³æ•°æ®ç»“æ„ã€‚è¿™äº›æ•°æ®ç»“æ„åŒ…å«å¯é…ç½®çš„sysctlå†…æ ¸å‚æ•°ã€‚ å…¶æ¬¡ï¼Œsysctlæ•°æ®ç»“æ„é€šå¸¸åŒ…å«åœ¨/proc/sys/æ–‡ä»¶å¤¹ä¸­æ˜¾ç¤ºsysctlå€¼çš„å‡½æ•°ã€‚å› æ­¤ï¼Œé€šè¿‡åˆ†æè¯¥å‡½æ•°ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå‡†ç¡®åœ°æ‰¾å‡ºè¯¥å†…æ ¸å‚æ•°çš„å˜é‡ã€‚ æœ€åï¼Œå¦‚æœä¸€ä¸ªå†…æ ¸å‚æ•°è¢«ç”¨äºé™åˆ¶èµ„æºæ¶ˆè€—ï¼Œå®ƒçš„ç›¸åº”å˜é‡åº”è¯¥å‡ºç°åœ¨æ¯”è¾ƒæŒ‡ä»¤ä¸­ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æŒ‰ç…§ä½¿ç”¨-å®šä¹‰é“¾æ¥æ£€æŸ¥æ‰€ç¡®å®šçš„å˜é‡çš„ä½¿ç”¨æƒ…å†µï¼Œå¦‚æœå®ƒåœ¨æ¯”è¾ƒæŒ‡ä»¤ä¸­è¢«ä½¿ç”¨ï¼Œå°±æŠŠå®ƒæ ‡è®°ä¸ºæŠ½è±¡èµ„æºã€‚ æˆ‘ä»¬åœ¨LLVMä¸­è®¾è®¡å¹¶å®ç°äº†ä¸€ä¸ªè¿‡ç¨‹é—´åˆ†æé€šé“ã€‚æˆ‘ä»¬åœ¨ä»£ç ä¸­ä½¿ç”¨ä¸€ä¸ªç¤ºä¾‹æ¥è¯´æ˜ç»†èŠ‚ã€‚å…·ä½“æ¥è¯´ï¼ŒLinuxå†…æ ¸ä½¿ç”¨ç±»å‹struct ctl_tableæ¥é…ç½®sysctlå†…æ ¸å‚æ•°ï¼Œä¾‹å¦‚ä»£ç ä¸­çš„ç¬¬1è¡Œæ‰€ç¤ºçš„fs_tableä¸­çš„æ–‡ä»¶ç³»ç»Ÿé…ç½®ã€‚ å› æ­¤ï¼Œè¯¥é€šé“é¦–å…ˆéå†æ‰€æœ‰çš„å†…æ ¸å…¨å±€å˜é‡ï¼Œæ”¶é›†æ‰€æœ‰çš„ç»“æ„ctl_tableå˜é‡ï¼Œå¦‚ä»£ç ä¸­çš„fs_tableã€‚å…¶æ¬¡ï¼Œfs_tableä½¿ç”¨proc_handlerä¸­çš„å‡½æ•°æŒ‡é’ˆæ¥æ˜¾ç¤º/proc/sys/æ–‡ä»¶ç³»ç»Ÿä¸­çš„å‚æ•°ã€‚å› æ­¤ï¼Œä»éå†æ‰€æœ‰çš„å†…æ ¸å…¨å±€å˜é‡æ¥æ”¶é›†æ‰€æœ‰çš„ç»“æ„ctl_tableå˜é‡ï¼Œå¦‚ä»£ç ä¸­çš„fs_tableã€‚ ç¬¬äºŒï¼Œfs_tableä½¿ç”¨proc_handlerä¸­çš„å‡½æ•°æŒ‡é’ˆæ¥æ˜¾ç¤º/proc/sys/æ–‡ä»¶ç³»ç»Ÿä¸­çš„å‚æ•°ã€‚å› æ­¤ï¼Œä»proc_handlerå­—æ®µä¸­ï¼Œé€šè¯éµå¾ªå…¶æŒ‡å‘ï¼Œå¯åŠ¨ç¨‹åºé—´åˆ†æä»¥è·å¾—ç¡®åˆ‡çš„å˜é‡ï¼Œå…¶å€¼æ˜¾ç¤ºåœ¨sysctlé…ç½®ç•Œé¢ä¸­ã€‚å¦‚ä»£ç ç¬¬19è¡Œæ‰€ç¤ºï¼Œæˆ‘ä»¬çš„ä¼ é€’å°†nr_filesæ ‡è®°ä¸ºå…³é”®å˜é‡ã€‚ ç¬¬ä¸‰ï¼Œæˆ‘ä»¬çš„ä¼ é€’æ£€æŸ¥æ‰€æœ‰å·²è¯†åˆ«çš„å…³é”®å˜é‡çš„ä½¿ç”¨æƒ…å†µã€‚å¦‚æœä¸€ä¸ªå…³é”®å˜é‡åœ¨æ¯”è¾ƒæŒ‡ä»¤ä¸­è¢«ä½¿ç”¨ï¼ˆå³LLVM IRä¸­çš„icmpï¼‰ï¼Œæˆ‘ä»¬çš„ä¼ é€’å°±ä¼šè®°å½•è¿™äº›ä½ç½®å¹¶å°†è¿™ä¸ªå˜é‡æ ‡è®°ä¸ºæŠ½è±¡èµ„æºã€‚ä¾‹å¦‚ï¼Œåœ¨ä»£ç çš„ç¬¬25è¡Œï¼Œnr_filesè¢«ç”¨äºæ¯”è¾ƒã€‚æˆ‘ä»¬çš„ä¼ é€’è¿›ä¸€æ­¥æ£€æµ‹åˆ°ï¼Œå¦‚æœæ¯”è¾ƒå¤±è´¥ï¼Œåœ¨ç¬¬25è¡Œå’Œç¬¬27è¡Œä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„ä¼ é€’å°†nr_filesæ ‡è®°ä¸ºä¸€ä¸ªæŠ½è±¡èµ„æºã€‚é€šè¿‡åˆ†ææ‰€æœ‰çš„struct ctl_tableï¼Œæˆ‘ä»¬çš„ä¼ é€’å¾—åˆ°ä¸€ä¸ªæŠ½è±¡èµ„æºçš„é›†åˆã€‚ 12345678910111213141516171819202122232425262728293031static struct ctl_table fs_table[] = &#123; ... &#123; .procname = &quot;file-nr&quot;, .data = &amp;files_stat, .proc_handler =proc_nr_files, &#125;, ...&#125;int proc_nr_files(...)&#123; files_stat.nr_files = get_nr_files(); ...&#125;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, ...)&#123; ... if(get_nr_files() &gt;= files_stat.max_files &amp;&amp; !capable(CAP_SYS_ADMIN)) &#123; ... goto over; &#125; ...&#125; è¿™ä¸ªä»£ç ç‰‡æ®µæ˜¯ä¸€ä¸ªCä»£ç ï¼Œç”¨äºç®¡ç†Linuxå†…æ ¸æ¨¡å—ä¸­çš„æ–‡ä»¶èµ„æºã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ªåä¸ºfs_tableçš„ctl_tableç»“æ„æ•°ç»„ã€ä¸€ä¸ªç”¨äºè®¾ç½®å½“å‰æ‰“å¼€æ–‡ä»¶æ•°é‡çš„proc_nr_fileså‡½æ•°ã€ä¸€ä¸ªè¿”å›æ‰“å¼€æ–‡ä»¶æ•°é‡çš„get_nr_fileså‡½æ•°ï¼Œä»¥åŠä¸€ä¸ªåœ¨æ‰“å¼€æ–‡ä»¶æ•°é‡æœªè¶…è¿‡å…è®¸çš„æœ€å¤§å€¼æ—¶åˆ†é…æ–°æ–‡ä»¶ç»“æ„çš„alloc_empty_fileå‡½æ•°ã€‚ ä»¥ä¸‹æ˜¯å„ä¸ªç»„ä»¶çš„è¯¦ç»†è§£é‡Šï¼š fs_tableæ˜¯ä¸€ä¸ªctl_tableç»“æ„æ•°ç»„ï¼Œç”¨äºå®šä¹‰/proc/sys/fs/ç›®å½•ä¸­çš„sysctlæ¡ç›®ã€‚å…·æœ‰procnameä¸ºâ€file-nrâ€çš„æ¡ç›®ä¸å½“å‰æ‰“å¼€æ–‡ä»¶çš„æ•°é‡ç›¸å…³è”ã€‚ proc_nr_filesæ˜¯ä¸€ä¸ªè®¾ç½®å½“å‰æ‰“å¼€æ–‡ä»¶æ•°é‡çš„å‡½æ•°ã€‚å½“è°ƒç”¨è¯¥å‡½æ•°æ—¶ï¼Œå®ƒä¼šä½¿ç”¨get_nr_files()å‡½æ•°è¿”å›çš„å€¼æ›´æ–°files_stat.nr_filesã€‚ get_nr_filesæ˜¯ä¸€ä¸ªè¿”å›å½“å‰æ‰“å¼€æ–‡ä»¶æ•°é‡çš„å‡½æ•°ã€‚å®ƒé€šè¿‡ä»åä¸ºnr_filesçš„percpu_counterç»“æ„ä¸­è¯»å–ä¸€ä¸ªå€¼æ¥å®ç°è¿™ä¸€ç‚¹ã€‚è¯¥ç»“æ„ç”¨äºä»¥é€‚ç”¨äºå¤šæ ¸ç³»ç»Ÿçš„é«˜æ•ˆæ–¹å¼å­˜å‚¨æ–‡ä»¶æ•°é‡ã€‚ alloc_empty_fileæ˜¯ä¸€ä¸ªå°è¯•åˆ†é…ç©ºæ–‡ä»¶ç»“æ„çš„å‡½æ•°ã€‚å®ƒæ£€æŸ¥å½“å‰æ‰“å¼€æ–‡ä»¶çš„æ•°é‡ï¼ˆç”±get_nr_files()è¿”å›ï¼‰æ˜¯å¦å¤§äºæˆ–ç­‰äºæœ€å¤§å…è®¸çš„æ–‡ä»¶æ•°é‡ï¼ˆå­˜å‚¨åœ¨files_stat.max_filesä¸­ï¼‰ã€‚å¦‚æœæ»¡è¶³æ­¤æ¡ä»¶ä¸”è°ƒç”¨è€…æ²¡æœ‰CAP_SYS_ADMINèƒ½åŠ›ï¼Œåˆ™è·³è½¬åˆ°æ ‡ç­¾overï¼Œè¿™ä¸ªæ ‡ç­¾å¯èƒ½å¤„ç†æ–‡ä»¶æ•°é‡è¶…è¿‡æœ€å¤§å€¼çš„æƒ…å†µã€‚ è¿™ä¸ªä»£ç ç‰‡æ®µæ˜¯Linuxå†…æ ¸å¦‚ä½•ç®¡ç†æ–‡ä»¶èµ„æºå¹¶å¯¹åŒæ—¶æ‰“å¼€çš„æ–‡ä»¶æ•°é‡æ–½åŠ é™åˆ¶çš„ä¸€ä¸ªä¾‹å­ã€‚ Access_based Analysisé™¤äº†sysctlé…ç½®å¤–ï¼ŒLinuxå†…æ ¸è¿˜ä½¿ç”¨é”æˆ–åŸå­æœºåˆ¶æ¥ä¿æŠ¤å¹¶å‘è®¿é—®çš„èµ„æºã€‚å› æ­¤ï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨å¹¶å‘è®¿é—®ä½œä¸ºæ ‡è¯†æ¥æ ‡è¯†ä¸€ç»„å¯å…±äº«çš„æŠ½è±¡èµ„æºã€‚ ç”±äºï¼ˆrace conditionï¼‰ç«æ€æ¡ä»¶å’Œå¹¶å‘æ€§åˆ†ææ˜¯ä¸€ä¸ªè€è¯é¢˜ï¼Œæˆ‘ä»¬é‡‡ç”¨ç°æœ‰çš„locksetæ£€æµ‹æ–¹æ³•ã€‚å¦‚æœé”åœ¨æ•°æ®ç»“æ„çš„æŸä¸ªå­—æ®µä¸Šï¼Œæˆ‘ä»¬å°†è¯¥æ•°æ®ç»“æ„æ ‡è®°ä¸ºæŠ½è±¡èµ„æºï¼Œå¹¶å°†è¯¥å‡½æ•°æ·»åŠ åˆ°æ•æ„Ÿå‡½æ•°é›†ä¸­ã€‚å…·ä½“æ¥è¯´ï¼Œå¦‚æœåœ¨æŸä¸ªæ•°æ®ç»“æ„çš„å­—æ®µä¸Šä½¿ç”¨äº†é”ï¼Œé‚£ä¹ˆå¯ä»¥å°†æ­¤æ•°æ®ç»“æ„æ ‡è®°ä¸ºæŠ½è±¡èµ„æºï¼Œå¹¶å°†æ¶‰åŠè¯¥å­—æ®µçš„å‡½æ•°æ·»åŠ åˆ°æ•æ„Ÿå‡½æ•°é›†åˆä¸­ã€‚è¿™æ„å‘³ç€è¿™äº›å‡½æ•°å¯èƒ½éœ€è¦ç‰¹åˆ«å…³æ³¨ï¼Œå› ä¸ºå®ƒä»¬å¯èƒ½ä¼šå—åˆ°å¹¶å‘è®¿é—®çš„å½±å“ã€‚æ­¤å¤–ï¼Œå¦‚æœä¸€ä¸ªå˜é‡åœ¨lockå’Œunlockå‡½æ•°ä¹‹é—´è¢«å®šé‡åœ°ä¿®æ”¹ï¼Œæˆ‘ä»¬ä¹Ÿå°†å…¶æ ‡è®°ä¸ºæŠ½è±¡èµ„æºã€‚ä¾‹å¦‚ï¼Œå¤šä¸ªçº¿ç¨‹åœ¨æ²¡æœ‰é”ä¿æŠ¤çš„æƒ…å†µä¸‹è®¿é—®åŒä¸€æ•°æ®ç»“æ„ï¼Œé‚£ä¹ˆå¯ä»¥å°†è¿™ç»„èµ„æºæ ‡è®°ä¸ºæŠ½è±¡èµ„æºã€‚å¦‚æœæŸä¸ªå˜é‡åœ¨ lock å’Œ unlock å‡½æ•°ä¹‹é—´è¢«å®šé‡åœ°ä¿®æ”¹ï¼ˆå³ï¼Œåœ¨é”ä¿æŠ¤ä¸‹å‘ç”Ÿäº†ä¿®æ”¹ï¼‰ï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥å°†å…¶æ ‡è®°ä¸ºæŠ½è±¡èµ„æºã€‚è¿™æœ‰åŠ©äºè¿›ä¸€æ­¥ç¡®å®šå¯èƒ½å—åˆ°å¹¶å‘å½±å“çš„èµ„æºã€‚ é™¤äº†é”å®š&#x2F;è§£é”ï¼Œæˆ‘ä»¬è¿˜è§‚å¯Ÿåˆ°åŸå­è®¡æ•°å™¨å’Œpercpuè®¡æ•°å™¨è¿˜ç”¨äºä¿æŠ¤å¹¶å‘è®¿é—®çš„æ•°æ®ï¼Œä¾‹å¦‚percpu_counter_incå’Œatomic_inc_returnã€‚å› æ­¤ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªpassæ¥åˆ†ææ‰€æœ‰åŸå­è®¡æ•°å™¨å’Œpercpuè®¡æ•°å™¨çš„ä½¿ç”¨æƒ…å†µã€‚æˆ‘ä»¬çš„ä¼ é€’é¦–å…ˆåˆ†æå‡½æ•°å‚æ•°ï¼Œå¹¶å°†æ‰€æœ‰å…·æœ‰struct atomic_tã€struct atomic64_tå’Œstruct percpu_counterå‚æ•°çš„å‡½æ•°æ·»åŠ åˆ°åŸå­/percpuå‡½æ•°é›†ä¸­ã€‚å…¶æ¬¡ï¼Œéå†æ‰€æœ‰å†…æ ¸å‡½æ•°ä¸­çš„æ‰€æœ‰è¯­å¥ï¼Œä»¥æ£€æŸ¥åŸå­/percpuå‡½æ•°çš„æ‰€æœ‰ä½¿ç”¨æƒ…å†µã€‚å¦‚æœä¸€ä¸ªå˜é‡è¢«ä¼ é€’ç»™ä¸€ä¸ªåŸå­/percpuå‡½æ•°ï¼Œæˆ‘ä»¬å°†å®ƒæ ‡è®°ä¸ºä¸€ä¸ªæŠ½è±¡èµ„æºã€‚ è¯†åˆ«å…·æœ‰åŸå­/percpuè®¡æ•°å™¨å‚æ•°çš„å‡½æ•°. éå†å†…æ ¸å‡½æ•°ä¸­çš„è¯­å¥ï¼Œæ£€æŸ¥åŸå­/percpuå‡½æ•°çš„ä½¿ç”¨æƒ…å†µã€‚ åœ¨å®ç°è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬å‘ç°LLVMé“¾æ¥å™¨åˆå¹¶äº†å…·æœ‰ç›¸åŒå†…å­˜å¸ƒå±€çš„ç»“æ„ç±»å‹ï¼Œä¾‹å¦‚typedef struct &#123;int counter;&#125; atomic_tå’Œtypedef struct &#123;uid_t val;&#125; kuid_tã€‚åŸå› æ˜¯uid_tçš„ç±»å‹æ˜¯unsigned intï¼Œå®ƒçš„å¤§å°ä¸intç›¸åŒã€‚å› æ­¤ï¼ŒLLVMé“¾æ¥å™¨å°†å®ƒä»¬åˆå¹¶ï¼Œå¹¶é”™è¯¯åœ°ä½¿ç”¨kuid_tä»£æ›¿atomic_tã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬è·Ÿè¸ªLLVMé“¾æ¥å™¨ï¼Œå¹¶å‘ç°lib/ linker / irmove .cppä¸­çš„getæ–¹æ³•å°†æ–°ç±»å‹ä¸ç°æœ‰ç±»å‹è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå†…å­˜å¸ƒå±€ç›¸åŒï¼Œåˆ™åˆå¹¶å®ƒä»¬ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€šè¿‡æ³¨é‡Šæ‰æ¯”è¾ƒå’Œåˆå¹¶ä»£ç æ¥ç¦ç”¨åˆå¹¶ã€‚ Container-Contorllability Analysisé€šè¿‡è¯†åˆ«æŠ½è±¡èµ„æºï¼Œæˆ‘ä»¬æå‡ºäº†å®¹å™¨å¯æ§æ€§åˆ†æï¼Œä»¥ç¡®ä¿å®¹å™¨å®é™…ä¸Šå¯ä»¥æ¶ˆè€—è¿™äº›æŠ½è±¡èµ„æºã€‚æˆ‘ä»¬å¯¹å®¹å™¨å¯æ§æ€§åˆ†æçš„æƒ³æ³•æ˜¯ï¼ˆtwo-foldï¼‰åŒé‡çš„ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿å®¹å™¨è¿›ç¨‹å¯ä»¥åˆ°è¾¾Â§4.1ä¸­çš„æŠ½è±¡èµ„æºæ¶ˆè€—ç‚¹ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬åŸºäºå†…æ ¸æ§åˆ¶æµå›¾æ‰§è¡Œä¼ ç»Ÿçš„åå‘æ§åˆ¶æµåˆ†æï¼Œå…¶ä¸­åŸºäºç»“æ„ç±»å‹è§£æé—´æ¥è°ƒç”¨ã€‚å¦‚æœæ²¡æœ‰ä»ç³»ç»Ÿè°ƒç”¨é¡¹åˆ°æŠ½è±¡èµ„æºæ¶ˆè€—ç‚¹çš„è·¯å¾„ï¼Œæˆ‘ä»¬å°†è¯¥æŠ½è±¡èµ„æºæ ‡è®°ä¸ºå®¹å™¨ä¸å¯è®¿é—®çš„ã€‚ å…¶æ¬¡ï¼Œæ³¨æ„ï¼Œå•é å¯è¾¾æ€§åˆ†ææ˜¯ä¸å¤Ÿçš„ï¼Œæˆ‘ä»¬éœ€è¦è¿›ä¸€æ­¥ç¡®ä¿è·¯å¾„ä¸Šæ²¡æœ‰é¢å¤–çš„ç‰¹å®šäºå®¹å™¨çš„é™åˆ¶ã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬éœ€è¦æ£€æŸ¥è·¯å¾„ä¸Šæ˜¯å¦å­˜åœ¨ä»»ä½•é™åˆ¶æ£€æŸ¥ï¼Œä»¥ç¡®ä¿å®¹å™¨å¯ä»¥è€—å°½è¿™äº›æŠ½è±¡èµ„æºã€‚å¦‚å‰æ‰€è¿°ï¼Œä¸ç”¨æˆ·ç©ºé—´ç¨‹åºä¸åŒï¼Œå®¹å™¨é¢ä¸´æ›´å¤šé™åˆ¶ï¼Œå¦‚seccompã€namespaceã€cgroupä»¥åŠæ¯ä¸ªç”¨æˆ·çš„èµ„æºé™åˆ¶ã€‚ç”±äºæˆ‘ä»¬çš„å¯è¾¾æ€§åˆ†ææ˜¯æ ‡å‡†çš„ï¼Œåœ¨æ¥ä¸‹æ¥çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†é‡ç‚¹å…³æ³¨é™åˆ¶åˆ†æã€‚ Seccomp Restriction AnalysisSeccompæ˜¯ä¸€ç§ç”¨äºç³»ç»Ÿè°ƒç”¨è¿‡æ»¤çš„æœºåˆ¶ã€‚æˆ‘ä»¬å¯¹seccompçš„é™åˆ¶åˆ†æå¦‚ä¸‹ã€‚åœ¨æˆ‘ä»¬çš„å®ç°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨Dockeré»˜è®¤çš„seccompé…ç½®æ–‡ä»¶ï¼Œå®ƒå¯ä»¥é˜»æ­¢è¶…è¿‡50ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚åœ¨ä»ç³»ç»Ÿè°ƒç”¨æ¡ç›®åˆ°èµ„æºæ¶ˆè€—ç«™ç‚¹çš„æ‰€æœ‰è·¯å¾„ä¸­ï¼Œæˆ‘ä»¬è¿‡æ»¤æ‰æ¥è‡ªä»»ä½•é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨çš„è·¯å¾„ã€‚ Per-User Restriction Analysisåœ¨å®é™…éƒ¨ç½²ä¸­ï¼Œå®¹å™¨é€šå¸¸ä»¥ä¸åŒçš„ç”¨æˆ·è¿è¡Œã€‚å› æ­¤ï¼Œæ¯ä¸ªå®¹å™¨çš„èµ„æºæ¶ˆè€—ä¹Ÿå—åˆ°peruserèµ„æºé…é¢çš„é™åˆ¶ã€‚ä¾‹å¦‚ï¼ŒLinuxæä¾›äº†user-limitså‘½ä»¤ulimitï¼Œç”¨äºé™åˆ¶ç”¨æˆ·çš„èµ„æºæ¶ˆè€—ã€‚è€Œulimitçš„åº•å±‚å®ç°æ˜¯ä½¿ç”¨rlimitæ¥è®¾ç½®å¤šä¸ªæ¯ä¸ªç”¨æˆ·çš„èµ„æºé…é¢ã€‚ é™¤äº†ulimit, Linuxè¿˜æä¾›äº†å…è®¸ç”¨æˆ·åˆ©ç”¨PAM (Pluggable Authentication Module)éƒ¨ç½²æ¯ä¸ªç”¨æˆ·é…é¢çš„æ¥å£ã€‚PAMä½¿ç”¨setup_limitså‡½æ•°æ¥è®¾ç½®æ¯ä¸ªç”¨æˆ·çš„èµ„æºé…é¢ï¼Œè¯¥å‡½æ•°è°ƒç”¨setrlimitæ¥é…ç½®å¤šä¸ªrlimitçº¦æŸã€‚å¯¹äºulimitã€rlimitå’ŒPAMæ‰€é™åˆ¶çš„èµ„æºï¼Œæ”»å‡»è€…å®¹å™¨ä¸èƒ½æ¶ˆè€—è¶…è¿‡æ¯ä¸ªç”¨æˆ·é…é¢çš„èµ„æºã€‚å› æ­¤ï¼Œå®ƒæ— æ³•å®Œå…¨æ§åˆ¶è¿™äº›æŠ½è±¡èµ„æºæ¥å‘èµ·DoSæ”»å‡»ã€‚ç”±äºulimitå’ŒPAMéƒ½ä½¿ç”¨rlimitæ¥è®¾ç½®æ¯ä¸ªç”¨æˆ·çš„èµ„æºé…é¢ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åˆ†ærlimitå¹¶è¿‡æ»¤å‡ºå—å…¶é™åˆ¶çš„æŠ½è±¡èµ„æºã€‚ å¯¹äºrlimitåˆ†æï¼Œæˆ‘ä»¬çš„å…³é”®è§‚å¯Ÿæ˜¯rlimitå€¼é€šå¸¸åœ¨struct rlimitæˆ–struct rlimit64ä¸­æŒ‡å®šã€‚å› æ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆéå†å†…æ ¸IRï¼Œä»¥è¯†åˆ«ä»struct rlimitæˆ–struct rlimit64åŠ è½½çš„æ‰€æœ‰å˜é‡ã€‚ç„¶åï¼Œæˆ‘ä»¬æ‰§è¡Œæ•°æ®æµåˆ†æï¼Œä»¥è·Ÿè¸ªè¿™äº›å˜é‡çš„æ‰€æœ‰ä¼ æ’­å’Œä½¿ç”¨ï¼Œå¹¶åœ¨ä»»ä½•æ¯”è¾ƒæŒ‡ä»¤ä¸­ä½¿ç”¨è¿™äº›å‡½æ•°æ—¶æ ‡è®°å®ƒä»¬ã€‚åœ¨è¿™äº›å‡½æ•°ä¸­ï¼Œæ£€æŸ¥rlimitä»¥é™åˆ¶æŸäº›èµ„æºã€‚æˆ‘ä»¬è®¤ä¸ºè¿™äº›èµ„æºæ˜¯æ”»å‡»å®¹å™¨ä¸å¯è€—å°½çš„ï¼Œå› æ­¤æˆ‘ä»¬æ ¹æ®è¿™äº›å‡½æ•°æ¥è¿‡æ»¤è·¯å¾„ã€‚æˆ‘ä»¬çš„å·¥å…·ç¡®å®šäº†40ä¸ªæ£€æŸ¥rlimitçš„å‡½æ•°ã€‚ Namespace Isolation Analysiså¦‚å‰æ‰€è¿°ï¼ŒLinuxå†…æ ¸ä¸ºèµ„æºéš”ç¦»å¼•å…¥äº†namespaceã€‚å¯¹äºnamespaceéš”ç¦»çš„èµ„æºï¼ŒLinuxå†…æ ¸åœ¨æ¯ä¸ªnamespaceä¸‹ä¸ºå…¶åˆ›å»ºä¸€ä¸ªâ€œcopyâ€ï¼Œä»¥ä¾¿ä¸€ä¸ªnamespaceä¸­çš„ä¿®æ”¹ä¸ä¼šå½±å“å…¶ä»–namespaceã€‚å› æ­¤ï¼Œä¸ºäº†ç¡®è®¤å®¹å™¨çš„å¯æ§æ€§ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿é‚£äº›æŠ½è±¡èµ„æºä¸å—namespaceçš„ä¿æŠ¤ã€‚è¿™é‡Œçš„æŒ‘æˆ˜æ˜¯ï¼Œå°½ç®¡Linuxæœ‰å…³äºnamespaceçš„æ–‡æ¡£ï¼Œä½†æ²¡æœ‰å…³äºå“ªäº›æŠ½è±¡èµ„æºç”±namespaceéš”ç¦»çš„è§„èŒƒã€‚ å› æ­¤ï¼Œæˆ‘ä»¬æå‡ºäº†namespaceéš”ç¦»åˆ†ææ¥ç³»ç»Ÿåœ°è¯†åˆ«å—namespaceä¿æŠ¤çš„æŠ½è±¡èµ„æºã€‚ æˆ‘ä»¬çš„ä¸»è¦è§‚å¯Ÿç»“æœæ˜¯ï¼Œå¯¹äºnamespaceéš”ç¦»çš„èµ„æºï¼Œå¯¹åº”çš„æ•°æ®ç»“æ„æœ‰ä¸€ä¸ªæŒ‡é’ˆå­—æ®µï¼ŒæŒ‡å‘å®ƒæ‰€å±çš„namespaceã€‚å› æ­¤ï¼Œæˆ‘ä»¬çš„å·¥å…·é¦–å…ˆéå†å†…æ ¸ä¸­æ¯ç§æ•°æ®ç»“æ„ç±»å‹çš„æ‰€æœ‰å­—æ®µã€‚å¦‚æœè¯¥ç±»å‹å…·æœ‰åç§°ç©ºé—´æŒ‡é’ˆï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºéš”ç¦»èµ„æºã€‚å…¶æ¬¡ï¼Œå¯¹äºå·²è¯†åˆ«çš„éš”ç¦»èµ„æºï¼Œæˆ‘ä»¬çš„å·¥å…·ä½¿ç”¨å®ƒæ¥è¿‡æ»¤Â§4.1ä¸­è¯†åˆ«çš„å…±äº«æŠ½è±¡èµ„æºã€‚ è¯·æ³¨æ„ï¼Œç”±äºä¸åŒnamesapceä¹‹é—´çš„æ˜ å°„ï¼Œä¸€äº›namespaceéš”ç¦»çš„èµ„æºä»ç„¶å®¹æ˜“å—åˆ°æŠ½è±¡èµ„æºæ”»å‡»ã€‚å¦‚Â§3.2.2æ‰€è¿°ï¼Œidrç”±pid_namespace-&gt;idréš”ç¦»ã€‚ä½†æ˜¯ï¼Œåœ¨éæ ¹PID namespaceä¸­åˆ†é…çš„æ¯ä¸ªidréƒ½æ˜ å°„åˆ°æ ¹PID namespaceä¸­çš„ä¸€ä¸ªæ–°çš„idrï¼Œä»¥ä¾¿æ ¹namespaceå¯ä»¥ç®¡ç†å®ƒã€‚å› æ­¤ï¼Œæ ¹PID namespaceè¢«æ‰€æœ‰PID namespaceä¸­çš„æ‰€æœ‰å®¹å™¨å…¨å±€å…±äº«ã€‚å› æ­¤ï¼Œå®ƒä»ç„¶å®¹æ˜“å—åˆ°idrè€—å°½æ”»å‡»ã€‚ åœ¨æˆ‘ä»¬çš„åˆ†æä¸­ï¼Œæˆ‘ä»¬æ‰‹åŠ¨è¿‡æ»¤æ‰è¿™äº›èµ„æºã€‚ Analysis Resultsæˆ‘ä»¬åœ¨LLVM 12.0ä¸­ä½¿ç”¨å¤§çº¦2500è¡Œc++ä»£ç å®ç°äº†æˆ‘ä»¬çš„åˆ†æå·¥å…·ã€‚Linuxå†…æ ¸IRæ˜¯åŸºäºæœ€æ–°çš„Linuxç¨³å®šç‰ˆæœ¬v5.10å’Œdefconfigç”Ÿæˆçš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œé€šè¿‡åº”ç”¨åŸºäºé…ç½®çš„åˆ†æå’ŒåŸºäºè®¿é—®çš„åˆ†æï¼Œä»¥åŠæ¥è‡ªç³»ç»Ÿè°ƒç”¨çš„å¯è¾¾æ€§åˆ†æå’Œseccompé™åˆ¶åˆ†æï¼Œæˆ‘ä»¬çš„å·¥å…·ç¡®å®šäº†1844ä¸ªå®¹å™¨å¯è¾¾çš„å…±äº«æŠ½è±¡èµ„æºã€‚ Resource Filtering é€šè¿‡æ¯ä¸ªç”¨æˆ·é…é¢é™åˆ¶å’Œnamespaceéš”ç¦»åˆ†æï¼Œæˆ‘ä»¬çš„å·¥å…·å¯ä»¥æ‰¾åˆ°342ä¸ªå—rlimité™åˆ¶æˆ–å…·æœ‰æŒ‡å‘namespaceç»“æ„çš„æŒ‡é’ˆçš„èµ„æºã€‚è¿™äº›èµ„æºè¦ä¹ˆå¯¹è·¯å¾„è¿›è¡Œé™åˆ¶æ£€æŸ¥ï¼Œè¦ä¹ˆå¯¹å…¶è¿›è¡Œnamespaceã€‚ æˆ‘ä»¬è¿›ä¸€æ­¥è¿›è¡Œæ‰‹å·¥åˆ†æã€‚å…·ä½“æ¥è¯´ï¼Œå¯¹äºå·²è¯†åˆ«çš„æŠ½è±¡èµ„æºä¸­çš„æ¯ä¸ªèµ„æºğ‘…ï¼Œæˆ‘ä»¬å°†éå†æ‰€æœ‰æ£€æµ‹åˆ°çš„ğ‘…æˆ–ğ‘…å­—æ®µçš„ä¿®æ”¹ã€‚å¦‚æœä¿®æ”¹ä¸æ˜¯å®šé‡çš„ï¼Œæ¯”å¦‚è¢«èµ‹å€¼ä¸ºå¸ƒå°”ç±»å‹ã€æšä¸¾ç±»å‹æˆ–å­—ç¬¦ä¸²ç±»å‹ï¼Œåˆ™å°†æ­¤ä¿®æ”¹æ ‡è®°ä¸ºéå®šé‡çš„ã€‚å¦‚æœå¯¹ğ‘…å’Œğ‘…å­—æ®µçš„æ‰€æœ‰ä¿®æ”¹éƒ½æ˜¯éå®šé‡çš„ï¼Œæˆ‘ä»¬å°†ğ‘…æ ‡è®°ä¸ºä¸å¯è€—å°½çš„ã€‚æˆ‘ä»¬çš„æ‰‹å·¥åˆ†æç¡®å®šäº†492ç§ä¸å¯è€—å°½çš„æŠ½è±¡èµ„æºï¼Œç»è¿‡äººå·¥åˆ†æï¼Œä»ç„¶æœ‰1010ä¸ªæŠ½è±¡èµ„æºã€‚ Dynamic Validation ä¸ºäº†è¿›ä¸€æ­¥éªŒè¯è¿™1010ä¸ªèµ„æºçš„åŠ¨æ€è€—å°½ï¼Œæˆ‘ä»¬å¼€å‘äº†ä¸€ä¸ªèµ„æºæ¶ˆè€—çš„åŠ¨æ€éªŒè¯æ–¹æ³•ã€‚å¯¹äºæ¯ä¸ªèµ„æºï¼Œæˆ‘ä»¬é¦–å…ˆä»å¯æ§æ€§åˆ†æä¸­è·å¾—å…¶æ¶ˆè€—ç‚¹å’Œè§¦å‘çš„ç³»ç»Ÿè°ƒç”¨ã€‚åœ¨æ­¤ä¹‹åï¼Œæˆ‘ä»¬å¯¹è¿™äº›æ¶ˆè€—ç«™ç‚¹è¿›è¡Œæµ‹é‡ï¼Œä»¥ç›‘æ§å®é™…çš„èµ„æºæ¶ˆè€—ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ‰§è¡Œç›¸åº”è§¦å‘ç³»ç»Ÿè°ƒç”¨çš„æµ‹è¯•ç”¨ä¾‹ï¼Œä»¥é‡å¤è§¦å‘æ¶ˆè´¹å¹¶è®°å½•ç»“æœã€‚æˆ‘ä»¬åˆ©ç”¨æ¥è‡ªLinuxæµ‹è¯•é¡¹ç›®çš„1156ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå¹¶å¼€å‘177ä¸ªæ–°çš„ç”¨ä¾‹æ¥è¦†ç›–æ›´å¤šçš„ç”¨ä¾‹ã€‚æˆ‘ä»¬è¿˜å¼€å‘è„šæœ¬æ¥è‡ªåŠ¨åŒ–ä¸Šè¿°æ­¥éª¤ã€‚ æˆ‘ä»¬åº”ç”¨åŠ¨æ€éªŒè¯æ–¹æ³•æ¥æµ‹è¯•æ‰€æœ‰1010ä¸ªèµ„æºçš„æ¶ˆè€—ã€‚ å¯¹äº1010ä¸ªæ£€æµ‹åˆ°çš„èµ„æºï¼Œå…¶ä¸­700ä¸ªä¸åœ¨é©±åŠ¨ç¨‹åºæ–‡ä»¶å¤¹ä¸­ï¼Œè€Œå…¶ä»–310ä¸ªèµ„æºåœ¨é©±åŠ¨ç¨‹åºæ–‡ä»¶å¤¹ä¸­ï¼Œåœ¨700ä¸ªéé©±åŠ¨èµ„æºä¸­ï¼Œæœ‰389ä¸ªèµ„æºå¯ä»¥åŠ¨æ€é‡å¤è§¦å‘ï¼ŒçœŸé˜³æ€§ç‡ä¸º55.6%ã€‚é©±åŠ¨ç¨‹åºæ–‡ä»¶å¤¹ä¸­çš„èµ„æºéœ€è¦ç‰¹åˆ«å¤„ç†ï¼ŒåŸå› æœ‰ä¸¤ä¸ªã€‚é¦–å…ˆï¼Œé©±åŠ¨ç¨‹åºæ˜¯ç‰¹å®šäºç¡¬ä»¶çš„ã€‚å¦‚æœæ²¡æœ‰ç›¸åº”çš„ç¡¬ä»¶ï¼Œå°±æ— æ³•åŠ¨æ€è§¦å‘é©±åŠ¨ç¨‹åºä»£ç ã€‚æˆ‘ä»¬çš„ä¸»è¦è§‚å¯Ÿç»“æœæ˜¯ï¼Œå¤§å¤šæ•°ç¡¬ä»¶æ”¯æŒçš„é©±åŠ¨ç¨‹åºåœ¨/devæˆ–/sys/classæ–‡ä»¶å¤¹ä¸‹å…¬å¼€ç‰¹å®šçš„æ¥å£ã€‚åŸºäºè¿™ç§è§‚å¯Ÿï¼Œæˆ‘ä»¬åˆ é™¤äº†ç¡¬ä»¶ä¸æ”¯æŒçš„é©±åŠ¨ç¨‹åºä¸­çš„92ä¸ªèµ„æºã€‚ç¬¬äºŒï¼ŒLTPæä¾›çš„æµ‹è¯•ç”¨ä¾‹å¯èƒ½ä¸è¦†ç›–ç‰¹å®šçš„é©±åŠ¨ç¨‹åºã€‚ ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¿®æ”¹LTPæµ‹è¯•ç”¨ä¾‹å¹¶ä¸ºé©±åŠ¨ç¨‹åºå¼€å‘æ–°çš„æµ‹è¯•ç”¨ä¾‹ã€‚218ä¸ªé©±åŠ¨èµ„æºä¸­ï¼Œæœ‰112ä¸ªé©±åŠ¨èµ„æºå¯ä»¥é‡å¤è§¦å‘ï¼ŒçœŸé˜³æ€§ç‡ä¸º51.4%ã€‚ è¯†åˆ«å®¹å™¨å¯è€—å°½æŠ½è±¡èµ„æºæ˜¯ä¸€é¡¹éå¸¸å…·æœ‰æŒ‘æˆ˜æ€§çš„ä»»åŠ¡ï¼Œå› ä¸ºå®ƒéœ€è¦é¢†åŸŸçŸ¥è¯†æ¥è§¦å‘æŠ½è±¡èµ„æºçš„è€—å°½ï¼Œå¹¶ä¸”éœ€è¦è¯„ä¼°è¿™äº›èµ„æºè€—å°½æ—¶çš„å½±å“ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬è¿›è¡Œäº†åˆæ­¥åˆ†æã€‚è¯·æ³¨æ„ï¼Œå½»åº•çš„åˆ†æå’Œé£é™©è¯„ä¼°éœ€è¦æ¥è‡ªLinuxå†…æ ¸å’Œå®¹å™¨ç¤¾åŒºçš„å¸®åŠ©ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®¡åˆ’å¼€æºæˆ‘ä»¬çš„å·¥å…·å’Œæ£€æµ‹åˆ°çš„æŠ½è±¡èµ„æºã€‚æˆ‘ä»¬è®¤ä¸ºè¿™å°†æœ‰åŠ©äºLinuxå†…æ ¸å’Œå®¹å™¨ç¤¾åŒºè¯†åˆ«èµ„æºéš”ç¦»çš„å¼±ç‚¹ï¼Œå¹¶å¼€å‘å¥å£®çš„èµ„æºéåˆ¶æ–¹æ¡ˆã€‚ Abstract Resource Attacks On Cloud Platformsåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†è¿›ä¸€æ­¥è¯„ä¼°é’ˆå¯¹å…¬å…±äº‘ä¾›åº”å•†å®¹å™¨ç¯å¢ƒçš„æŠ½è±¡èµ„æºæ”»å‡»ã€‚æˆ‘ä»¬é¦–å…ˆä»‹ç»ç¯å¢ƒè®¾ç½®ï¼Œç„¶åç»™å‡ºç»“æœã€‚ Environment Setup and Ethical Considerationsä¸ºäº†è¯„ä¼°æŠ½è±¡èµ„æºæ”»å‡»çš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬åœ¨æœ¬åœ°å’Œäº‘å¹³å°ä¸Šå»ºç«‹äº†å®¹å™¨ç¯å¢ƒã€‚ æœ¬åœ°æµ‹è¯•ç¯å¢ƒå·²åœ¨Â§3.1ä¸­ç»™å‡ºã€‚ Ethical Considerations å¯¹äºäº‘å¹³å°ï¼Œæˆ‘ä»¬æ‰“ç®—å°½å¯èƒ½å‡å°‘æˆ‘ä»¬çš„æ”»å‡»å¯¹å…¶ä»–äº‘ç”¨æˆ·çš„å½±å“ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸“ç”¨çš„è™šæ‹ŸæœåŠ¡å™¨ï¼Œå¦‚AWS EC2ã€Azure VMã€è°·æ­ŒGCEã€é˜¿é‡Œå·´å·´ECSæ¥è¿›è¡Œå®éªŒã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬ç¡®ä¿æˆ‘ä»¬æ˜¯è¯¥æœåŠ¡å™¨çš„å”¯ä¸€ç”¨æˆ·ã€‚ æ­¤å¤–ï¼Œå¤§å¤šæ•°å®¹å™¨ç”¨æˆ·åˆ©ç”¨å®¹å™¨ç¼–æ’ç³»ç»Ÿæ¥éƒ¨ç½²å’Œç®¡ç†å®¹å™¨ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é€‰æ‹©äº†æœ€æµè¡Œçš„Kubernetesï¼Œå¹¶åˆ©ç”¨äº‘ä¾›åº”å•†çš„KubernetesæœåŠ¡åœ¨è™šæ‹ŸæœåŠ¡å™¨ä¸Šéƒ¨ç½²ä¸¤ä¸ªdockerå®¹å™¨(å³æ”»å‡»è€…å®¹å™¨å’Œå—å®³è€…å®¹å™¨)ã€‚ä¸ºäº†å®ç°å¼ºéš”ç¦»ï¼Œæˆ‘ä»¬ä¸ºattacker-containerå’Œvictim-containeråº”ç”¨äº†ä¸åŒçš„Kubernetes namespaceã€‚å¦‚Â§4.2æ‰€è¿°ï¼Œå®¹å™¨ä¹Ÿå—åˆ°æ¯ä¸ªç”¨æˆ·é…é¢çš„é™åˆ¶ã€‚ä¸ºäº†åœ¨æˆ‘ä»¬çš„å®éªŒä¸­å¼ºåˆ¶æ‰§è¡Œæ¯ä¸ªç”¨æˆ·çš„é…é¢ï¼Œæˆ‘ä»¬åœ¨ä¸åŒçš„ç”¨æˆ·ä¸­è¿è¡Œæ”»attacker-containerå’Œvictim-containerï¼Œå¹¶å¼ºåˆ¶æ‰§è¡Œæ¯ä¸ªç”¨æˆ·çš„é…é¢ã€‚æˆ‘ä»¬è¿˜åœ¨Â§6ä¸­è®¨è®ºäº†PAMå¯ä»¥éƒ¨ç½²çš„é™åˆ¶ã€‚ Amazon AWS å¯¹äºå®¹å™¨æœåŠ¡ï¼Œæˆ‘ä»¬ä½¿ç”¨Elastic Kubernetes Service (EKS)åœ¨EC2å®ä¾‹ä¸Šéƒ¨ç½²ä¸¤ä¸ªå®¹å™¨å®ä¾‹ã€‚EC2å®ä¾‹åŒ…å«4ä¸ªcpuã€8gbå†…å­˜å’Œ20gb SSDç£ç›˜ã€‚åœ¨å®¹å™¨éƒ¨ç½²æœŸé—´ï¼Œæˆ‘ä»¬æƒŠå¥‡åœ°å‘ç°â€œAmazon EKSé»˜è®¤podå®‰å…¨ç­–ç•¥â€ä½¿ç”¨äº†EKSã€‚ç‰¹æƒä¸ºé»˜è®¤podå®‰å…¨ç­–ç•¥ã€‚è¯·æ³¨æ„ï¼Œæ­¤ç­–ç•¥å…è®¸å®¹å™¨ä½œä¸ºç‰¹æƒç”¨æˆ·è¿è¡Œï¼Œè¿˜å…è®¸ç‰¹æƒå‡çº§ä»¥åŠä¸»æœºç½‘ç»œè®¿é—®ã€‚ ä¸ºäº†æ›´å¥½åœ°æ¼”ç¤ºæˆ‘ä»¬æå‡ºçš„æ”»å‡»çš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬ä»æœ¬åœ°æµ‹è¯•ç¯å¢ƒé‡‡ç”¨äº†æ›´å¼ºçš„å®‰å…¨ç­–ç•¥ï¼Œä»EKSå®¹å™¨è¿è¡Œåœ¨éæ ¹ç”¨æˆ·ä¸­ï¼Œåˆ é™¤æ‰€æœ‰ç‰¹æƒï¼Œå¯ç”¨æ‰€æœ‰namespaceå’Œcgroupï¼Œå¹¶ä½¿ç”¨docker seccompé…ç½®æ–‡ä»¶æ¥é˜»æ­¢50å¤šä¸ªæ•æ„Ÿç³»ç»Ÿè°ƒç”¨ï¼ŒåŒ…æ‹¬ptraceã€pivot_rootç­‰ã€‚æˆ‘ä»¬å¯¹attacker-containerå’Œvictim-containeråº”ç”¨ç›¸åŒçš„å®‰å…¨ç­–ç•¥ã€‚ MS Azureæˆ‘ä»¬ä½¿ç”¨Azure KubernetesæœåŠ¡ï¼ˆAKSï¼‰ï¼Œåœ¨Azureè™šæ‹Ÿæœºä¸Šéƒ¨ç½²äº†ä¸¤ä¸ªå®¹å™¨å®ä¾‹ã€‚Azureè™šæ‹ŸæœºåŒ…å«2ä¸ªCPUã€8GBå†…å­˜å’Œ120GBç£ç›˜ã€‚ä¸ºäº†æé«˜éƒ¨ç½²çš„å®¹å™¨çš„å®‰å…¨æ€§ï¼ŒAzureåœ¨AKSä¸­æä¾›äº†podå®‰å…¨ç­–ç•¥çš„æœ€ä½³å®è·µï¼Œé€šè¿‡åœ¨yamlæ–‡ä»¶ä¸­è®¾ç½®runAsUser:1000ï¼Œä»¥érootç”¨æˆ·çš„èº«ä»½è¿è¡Œå®¹å™¨ï¼Œå¹¶é€šè¿‡è®¾ç½®allowPrivilegeEscalation: falseï¼Œæ‹’ç»ç‰¹æƒå‡çº§ã€‚ç„¶è€Œï¼Œå®ƒä»ç„¶å¢åŠ äº†ä¸¤ç§èƒ½åŠ›ï¼Œå³CAP_NET_ADMINå’ŒCAP_SYS_TIMEï¼Œå¹¶ä¸”æ²¡æœ‰å¼ºåˆ¶æ‰§è¡Œseccompã€‚ä¸AWSçš„è®¾ç½®ä¸€æ ·ï¼Œæˆ‘ä»¬å¯¹AKSä¸Šçš„å®¹å™¨é‡‡å–äº†æ›´ä¸¥æ ¼çš„å®‰å…¨ç­–ç•¥ã€‚é™¤äº†æœ€ä½³å®è·µå»ºè®®ï¼ˆå³érootç”¨æˆ·å’Œä¸å…è®¸ç‰¹æƒå‡çº§ï¼‰ï¼Œæˆ‘ä»¬ä»¥érootç”¨æˆ·è¿è¡ŒAKSå®¹å™¨ï¼Œæ”¾å¼ƒæ‰€æœ‰åŠŸèƒ½ï¼Œå¯ç”¨æ‰€æœ‰çš„namespaceå’Œcgroupï¼Œå¹¶ä½¿ç”¨docker seccompé…ç½®æ–‡ä»¶ã€‚æ¥é˜»æ­¢50å¤šä¸ªæ•æ„Ÿçš„ç³»ç»Ÿè°ƒç”¨ã€‚æˆ‘ä»¬å¯¹attacker-containerå’Œvictim-containeråº”ç”¨ç›¸åŒçš„å®‰å…¨ç­–ç•¥ã€‚ Google Cloud å¯¹äºå®¹å™¨æœåŠ¡ï¼Œæˆ‘ä»¬é€‰æ‹©Kuberneteså¹¶ä½¿ç”¨è°·æ­ŒKubernetes Engine (GKE)åœ¨è°·æ­Œè®¡ç®—å¼•æ“å®ä¾‹ä¸Šéƒ¨ç½²ä¸¤ä¸ªå®¹å™¨å®ä¾‹ã€‚æˆ‘ä»¬ä½¿ç”¨çš„è°·æ­Œè®¡ç®—å¼•æ“(GCE)å®ä¾‹åŒ…å«4ä¸ªcpuã€16gbå†…å­˜å’Œ100gb SSDã€‚æ›´å…·ä½“åœ°è¯´ï¼Œæˆ‘ä»¬åº”ç”¨ä¸€ä¸ªGCEå®ä¾‹ï¼Œå¹¶åŸºäºè¯¥GCEå®ä¾‹ä¸Šçš„å¸¸è§„è¿è¡Œæ—¶éƒ¨ç½²ä¸¤ä¸ªå®¹å™¨(å³attacker-containerå’Œvictim-container)ã€‚ å¯¹äºå®¹å™¨éƒ¨ç½²ï¼Œæˆ‘ä»¬éµå¾ªGKSå®¹å™¨è®¾ç½®å‘å¯¼ã€‚è°·æ­ŒCloudæä¾›äº†æ“ä½œå®¹å™¨çš„æœ€ä½³å®è·µï¼Œå»ºè®®é¿å…ä½¿ç”¨ç‰¹æƒå®¹å™¨ã€‚å› æ­¤ï¼Œåœ¨yamlé…ç½®æ–‡ä»¶çš„securityContextä¸­ï¼Œæˆ‘ä»¬ä¸å…è®¸ç‰¹æƒå‡çº§ï¼Œä»¥éç‰¹æƒç”¨æˆ·è¿è¡Œå®¹å™¨ï¼Œå¹¶åˆ é™¤æ‰€æœ‰åŠŸèƒ½ã€‚GKSè®¾ç½®å‘å¯¼é»˜è®¤å¯ç”¨6ä¸ªnamespaceå’Œ13ä¸ªcgroupã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åº”ç”¨dockeré»˜è®¤çš„seccompé…ç½®æ–‡ä»¶æ¥è¿‡æ»¤æ•æ„Ÿçš„ç³»ç»Ÿè°ƒç”¨ã€‚ æ­¤å¤–ï¼ŒGKEè¿˜æä¾›äº†è°·æ­Œçš„å®‰å…¨å®¹å™¨è¿è¡Œæ—¶- gvisorï¼Œå®ƒåˆ©ç”¨åä¸ºSentryçš„ç”¨æˆ·ç©ºé—´å†…æ ¸ä¸ºæ¥è‡ªåº”ç”¨ç¨‹åºçš„ç³»ç»Ÿè°ƒç”¨æä¾›æœåŠ¡ã€‚å“¨å…µè°ƒç”¨å¤§çº¦50ä¸ªä¸»æœºç³»ç»Ÿè°ƒç”¨ï¼Œæ ¹æ®éœ€è¦æä¾›æœåŠ¡ã€‚gVisorè¢«è®¤ä¸ºæ˜¯å®¹å™¨çš„å®‰å…¨æ²™ç›’è¿è¡Œæ—¶ã€‚å¯¹äºåŸºäºgVisorçš„å®¹å™¨éƒ¨ç½²ï¼Œå…¶æ‰€æœ‰å®‰å…¨è®¾ç½®(åŒ…æ‹¬éç‰¹æƒç”¨æˆ·ã€åˆ é™¤åŠŸèƒ½)éƒ½ä¸GKE dockerè¿è¡Œæ—¶è®¾ç½®ç›¸åŒã€‚ Alibaba Cloud åœ¨å®¹å™¨æœåŠ¡æ–¹é¢ï¼Œé˜¿é‡Œäº‘æä¾›äº†å¼¹æ€§å®¹å™¨å®ä¾‹ã€Kuberneteså®¹å™¨æœåŠ¡ã€å®¹å™¨æ³¨å†Œå’Œé˜¿é‡Œäº‘æœåŠ¡Meshã€‚æˆ‘ä»¬ä½¿ç”¨Kubernetesçš„å®¹å™¨æœåŠ¡åœ¨ä¸€ä¸ªå¼¹æ€§è®¡ç®—æœåŠ¡(ECS)å®ä¾‹ä¸Šéƒ¨ç½²ä¸¤ä¸ªå®¹å™¨å®ä¾‹ã€‚ECSå®ä¾‹åŒ…å«4ä¸ªcpuã€16gbå†…å­˜å’Œ120gb SSDç›˜ã€‚å¯¹äºå®¹å™¨å®‰å…¨æ€§ï¼Œæˆ‘ä»¬éµå¾ªå®¹å™¨æœåŠ¡éƒ¨ç½²çš„å®˜æ–¹æŒ‡å—ï¼Œè¯¥æŒ‡å—é€šè¿‡å°†runAsUserè®¾ç½®ä¸º1000æ¥ä½¿ç”¨éæ ¹ç”¨æˆ·è¿è¡Œå®¹å™¨ã€‚ä½†æ˜¯ï¼Œå®ƒå¹¶ä¸ç¦æ­¢ç‰¹æƒå‡çº§ï¼Œä¹Ÿä¸å¼ºåˆ¶æ‰§è¡Œseccompå’ŒSELinuxã€‚ æˆ‘ä»¬é‡‡å–äº†ä¸ä»¥å¾€ç›¸åŒçš„æ›´å¼ºæœ‰åŠ›çš„å®‰å…¨æ”¿ç­–ã€‚æˆ‘ä»¬åœ¨éæ ¹ç”¨æˆ·ä¸­è¿è¡Œå®¹å™¨ï¼Œåˆ é™¤æ‰€æœ‰åŠŸèƒ½ï¼Œå¯ç”¨æ‰€æœ‰namespaceå’Œcgroupï¼Œå¹¶ä½¿ç”¨docker seccompé…ç½®æ–‡ä»¶æ¥é˜»æ­¢æ•æ„Ÿçš„ç³»ç»Ÿè°ƒç”¨ã€‚æˆ‘ä»¬å¯¹attacker-containerå’Œvictim-containeråº”ç”¨ç›¸åŒçš„å®‰å…¨ç­–ç•¥ã€‚ Selection of Abstract Resourcesä¸ºäº†è¿›è¡Œæ”»å‡»ï¼Œæˆ‘ä»¬éœ€è¦é€‰æ‹©æœ‰æ„ä¹‰çš„æŠ½è±¡èµ„æºã€‚ä¸ºäº†æ¼”ç¤ºæŠ½è±¡èµ„æºæ”»å‡»çš„æœ‰æ•ˆæ€§ï¼Œæˆ‘ä»¬å¸Œæœ›é€‰æ‹©å½±å“æ“ä½œç³»ç»ŸæœåŠ¡å„ä¸ªæ–¹é¢çš„æŠ½è±¡èµ„æºï¼ŒåŒ…æ‹¬è¿›ç¨‹ç®¡ç†ã€å†…å­˜ç®¡ç†ã€å­˜å‚¨ç®¡ç†å’ŒIOç®¡ç†ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆæ ¹æ®å®ƒä»¬çš„å£°æ˜ä½ç½®å°†æ‰€æœ‰æ ‡è¯†çš„èµ„æºåˆ†ä¸ºè¿™å››ç±»ï¼Œå³ç”¨äºè¿›ç¨‹ã€å†…å­˜ã€å­˜å‚¨å’ŒIOç®¡ç†çš„èµ„æºã€‚ç„¶åï¼Œæˆ‘ä»¬æ ¹æ®æˆ‘ä»¬çš„é¢†åŸŸçŸ¥è¯†ä»æ¯ä¸ªç±»åˆ«ä¸­é€‰æ‹©è‡³å°‘ä¸€ä¸ªèµ„æºï¼Œå³æˆ‘ä»¬çŸ¥é“èµ„æºè€—å°½çš„å½±å“ã€‚ æœ€ç»ˆï¼Œæˆ‘ä»¬é€‰æ‹©äº†æ¶µç›–æ‰€æœ‰å››ä¸ªæ–¹é¢çš„7ä¸ªæŠ½è±¡èµ„æºï¼Œã€‚èµ„æºåç§°åˆ—åœ¨è¡¨çš„ç¬¬äºŒåˆ—ä¸­ã€‚åœ¨æ‰€é€‰çš„æŠ½è±¡èµ„æºä¸­ï¼ŒåŸºäºè®¿é—®åˆ†æè¯†åˆ«å‡ºPID idrã€dirty ratioã€inodeã€netns_ct-&gt;countã€random entropyä¸ªï¼ŒåŸºäºé…ç½®åˆ†æè¯†åˆ«å‡ºnr_filesã€pty_count 2ä¸ªï¼Œå¦‚è¡¨ç¬¬ä¸‰åˆ—æ‰€ç¤ºã€‚æˆ‘ä»¬è¿˜åœ¨è¡¨çš„ç¬¬å››åˆ—ä¸­åˆ—å‡ºäº†èµ„æºæ¶ˆè€—å‡½æ•°ï¼Œåœ¨è¡¨çš„æœ€åä¸€åˆ—ä¸­åˆ—å‡ºäº†ç”¨äºè§¦å‘æ”»å‡»çš„ç³»ç»Ÿè°ƒç”¨ã€‚ Attacking Results on Cloud Platformså¦‚å‰ä¸€èŠ‚æ‰€è¿°ï¼Œæˆ‘ä»¬ä¸ºæˆ‘ä»¬æå‡ºçš„æ”»å‡»è®¾ç½®äº†5ä¸ªæµ‹è¯•ç¯å¢ƒï¼ŒåŒ…æ‹¬æœ¬åœ°ã€AWSã€Azureã€è°·æ­Œäº‘å’Œé˜¿é‡Œäº‘ã€‚å¯¹äºæ¯ä¸ªæµ‹è¯•ç¯å¢ƒï¼Œæˆ‘ä»¬è®¾ç½®äº†ä¸¤ä¸ªå…·æœ‰ä¸¥æ ¼å®‰å…¨ç­–ç•¥çš„å®¹å™¨ï¼Œä½œä¸ºattacker-containerå’Œvictim-containerã€‚attacker-containeré’ˆå¯¹æŸäº›æŠ½è±¡èµ„æºå‘èµ·æ”»å‡»ã€‚æˆ‘ä»¬ä½¿ç”¨ä¸Šè¿°7ä¸ªé€‰å®šçš„æŠ½è±¡èµ„æºæ¥å‘èµ·æ”»å‡»ã€‚åœ¨victim-containerå’Œä¸»æœºä¸Šéƒ½è¿è¡Œä¸€ä¸ªåŸºå‡†æµ‹è¯•ï¼Œä»¥æµ‹é‡å®ƒä»¬åœ¨æŠ½è±¡èµ„æºæ”»å‡»ä¸‹çš„æ€§èƒ½ä¸‹é™ã€‚ç»“æœå¦‚è¡¨æ‰€ç¤ºã€‚ PID idræ”»å‡»ã€‚PID idræ”»å‡»åŠå…¶æ ¹æºå·²åœ¨Â§3.2.1ä¸­è¯¦ç»†ä»‹ç»ã€‚é’ˆå¯¹å‚å•†çš„PIDæ”»å‡»ï¼Œæ‰€æœ‰å—å®³å®¹å™¨ï¼Œç”šè‡³åœ¨Localã€AWSã€Azureå’Œè°·æ­Œæµ‹è¯•ç¯å¢ƒä¸­çš„ä¸»æœºéƒ½ä¸èƒ½forkæ–°çš„è¿›ç¨‹ã€‚victim-containerç”šè‡³ä¼šè¢«é©±é€ã€‚é˜¿é‡Œäº‘ä¸å®¹æ˜“å—åˆ°PIDæ”»å‡»ã€‚ dirty ratioæ”»å‡»ã€‚dirty ratioæ”»å‡»å·²ç»åœ¨Â§3.3.1ä¸­è®¨è®ºè¿‡ã€‚å¦‚æœæ²¡æœ‰æ”»å‡»ï¼Œåˆ™è®¤ä¸ºIOæ€§èƒ½ä¸º100%ã€‚åœ¨dirty ratioæ”»å‡»ä¸‹ï¼Œå—å®³å®¹å™¨åœ¨AWSã€Azureå’Œé˜¿é‡Œäº‘ä¸Šçš„IOæ€§èƒ½åˆ†åˆ«ä¸‹é™åˆ°6.3%ã€1.2%å’Œ6.7%ã€‚æ›´ç³Ÿç³•çš„æ˜¯ï¼Œä¸»æœºä¹Ÿå®¹æ˜“å—åˆ°è¿™ç§æ”»å‡»ï¼Œå…¶IOæ€§èƒ½åœ¨AWSä¸Šä¸‹é™åˆ°8.3%ï¼Œåœ¨é˜¿é‡Œäº‘ä¸Šä¸‹é™åˆ°8.6%ã€‚è¿™é‡ŒMS Azureä¸æä¾›å¯¹ä¸»æœºçš„ä»»ä½•è®¿é—®ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•è·å¾—Azureä¸»æœºIOæ€§èƒ½ã€‚è°·æ­Œäº‘ä¸å®¹æ˜“å—åˆ°dirty ratioæ”»å‡»ã€‚ inodeæ”»å‡»ã€‚åœ¨inodeæ”»å‡»ä¸­ï¼Œå—å®³è€…å®¹å™¨ä¸æ–­åˆ†é…inodeç»“æ„ã€‚ä¸å¹¸çš„æ˜¯ï¼Œmount namespaceæ²¡æœ‰éš”ç¦»inodeã€‚Linuxå†…æ ¸éƒ½ä¸æä¾›ä»»ä½•ä¸inodeç›¸å…³çš„cgroupã€‚ç»“æœï¼Œè¯¥åˆ†åŒºä¸Šçš„æ‰€æœ‰inodeéƒ½è¢«è€—å°½ã€‚æ‰€æœ‰æ¶ˆè€—inodeçš„æ“ä½œéƒ½ä¼šå¤±è´¥ï¼ŒåŒ…æ‹¬æ¥è‡ªvictim-containeræˆ–ä¸»æœºçš„æ“ä½œã€‚åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œé˜¿é‡Œäº‘å¾ˆå®¹æ˜“å—åˆ°inodeæ”»å‡»ã€‚victim-containerç”šè‡³ä¼šè¢«é©±é€ã€‚æ­¤å¤–ï¼Œä¸»æœºä¹Ÿä¸èƒ½åˆ›å»ºä»»ä½•æ–°æ–‡ä»¶ã€‚ nr_filesæ”»å‡»ã€‚nr_filesæ”»å‡»å·²ç»åœ¨Â§3.4.1ä¸­è®¨è®ºè¿‡ã€‚nr_filesç”±æ‰€æœ‰å®¹å™¨å…¨å±€å…±äº«ã€‚æ²¡æœ‰namespaceæˆ–cgroupæ¥é™åˆ¶å®ƒçš„ä½¿ç”¨ã€‚å½“nr_filesé…é¢è€—å°½æ—¶ï¼Œå„ç§æ“ä½œéƒ½ä¼šå¤±è´¥ï¼ŒåŒ…æ‹¬æ‰“å¼€æ–‡ä»¶ã€æ‰§è¡Œæ–°ç¨‹åºã€åˆ›å»ºç®¡é“ã€åˆ›å»ºå¥—æ¥å­—å’Œåˆ›å»ºè®¡æ—¶å™¨ï¼Œå› ä¸ºLinuxä¸­çš„æ‰€æœ‰ä¸œè¥¿éƒ½æ˜¯æ–‡ä»¶ã€‚æˆ‘ä»¬çš„å®éªŒè¡¨æ˜ï¼Œæ‰€æœ‰æ’åå‰4çš„ä¾›åº”å•†éƒ½å®¹æ˜“å—åˆ°nr_filesæ”»å‡»ã€‚ pty_countæ”»å‡»ã€‚pty_countæ”»å‡»å·²ç»åœ¨Â§3.5.1ä¸­è®¨è®ºè¿‡ï¼Œå®ƒä¼šè€—å°½æ‰€æœ‰å¼€æ”¾çš„ä¼ªç»ˆç«¯é…é¢ã€‚è¿™å°†å¯¼è‡´æ‰€æœ‰éœ€è¦æ‰“å¼€æ–°çš„ä¼ªç»ˆç«¯çš„æ“ä½œå¤±è´¥ï¼Œå¦‚SSHè¿æ¥ç­‰ã€‚ä¸å¹¸çš„æ˜¯ï¼Œæ‰€æœ‰å‰4ä¸ªä¾›åº”å•†éƒ½å®¹æ˜“å—åˆ°pty_countæ”»å‡»ã€‚ netns_ct-&gt;countæ”»å‡»ã€‚Linuxå†…æ ¸ä¸­çš„Netfilteræä¾›äº†è¿æ¥è·Ÿè¸ªåŠŸèƒ½ï¼Œå¯ä»¥è·Ÿè¸ªæ‰€æœ‰çš„é€»è¾‘ç½‘ç»œè¿æ¥ã€‚è€Œæ€»è¿æ¥æ•°æ˜¯æœ‰é™åˆ¶çš„ï¼Œç”±struct netns_ct-&gt;countæ¥è®¡æ•°ã€‚ä¸»æœºå’Œå®¹å™¨éƒ½éœ€è¦ç»´æŠ¤è¿æ¥ã€‚å°½ç®¡å®¹å™¨ä½äºä¸åŒçš„net namespaceä¸­ï¼Œä½†å®ƒä»¬çš„æ‰€æœ‰è¿æ¥éƒ½éœ€è¦ä½¿ç”¨init_net.ctã€‚ä¸»æœºçš„init net namespaceçš„è®¡æ•°ã€‚å› æ­¤ï¼Œå¦‚æœåœ¨çŸ­æ—¶é—´å†…äº§ç”Ÿå¤§é‡çš„TCPè¿æ¥ï¼Œå°±ä¼šæ¶ˆè€—æ‰init_net.ctçš„æ‰€æœ‰é…é¢ã€‚è®¡æ•°ï¼Œå¯¼è‡´Netfilteræ•…éšœã€‚åœ¨æˆ‘ä»¬çš„å®éªŒä¸­ï¼Œattacker-containerå¯ä»¥è€—å°½init_net.ctã€‚æ•°ç§’å†…è®¡æ•°ï¼Œå¯¼è‡´éšæœºä¸¢åŒ…ã€‚åŒæ ·ï¼Œå‰4ä¸ªä¾›åº”å•†çš„æ‰€æœ‰ç¯å¢ƒéƒ½å®¹æ˜“å—åˆ°ç»“æ„ä½“netns_ct-&gt;countæ”»å‡»ã€‚ random entropyæ”»å‡»ã€‚åœ¨Linuxå†…æ ¸ä¸­ï¼Œæ¯æ¬¡è¯»å–/dev/randoméƒ½ä¼šæ¶ˆè€—random entropyã€‚æ¯å½“random entropyä¸‹é™åˆ°é˜ˆå€¼ä»¥ä¸‹æ—¶ï¼ŒLinuxå†…æ ¸å°±ä¼šé˜»å¡å¯¹/dev/randomçš„è¯»å–æ“ä½œï¼Œå¹¶ç­‰å¾…entropyå¢åŠ ã€‚ ç”±äºæ²¡æœ‰namespaceæˆ–cgroupæ¥éš”ç¦»random entropyï¼Œattacker-containerå¾ˆå®¹æ˜“é€šè¿‡åå¤è¯»å–/dev/randomæ¥æ¶ˆè€—æ‰€æœ‰çš„random entropyï¼Œä»è€Œå¯¼è‡´è‰¯æ€§çš„è¯»å–é˜»å¡ã€‚æœ€æ–°çš„Linuxå†…æ ¸v5.10é€šè¿‡å°†/dev/randomè¯»é‡å®šå‘åˆ°/dev/urandomä¿®å¤äº†è¿™ä¸ªé—®é¢˜ã€‚ç„¶è€Œï¼ŒAzureå’Œé˜¿é‡Œäº‘éƒ½å®¹æ˜“å—åˆ°è¿™ç§æ”»å‡»ã€‚ Attacking gVisoræˆ‘ä»¬è¿˜å¯¹gVisorè¿›è¡Œäº†7ç§èµ„æºæ”»å‡»ã€‚ä¸ºäº†å»ºç«‹gVisorç¯å¢ƒï¼Œæˆ‘ä»¬åœ¨è°·æ­ŒKubernetes Engine (GKE)ä¸­é€‰æ‹©runscè€Œä¸æ˜¯runcä½œä¸ºå®¹å™¨è¿è¡Œæ—¶ï¼Œå¦‚Â§5.1æ‰€è¿°ã€‚å…¶ä¸­nr_filesæ”»å‡»å’Œnetns_ct-&gt;countæ”»å‡»ä¸¤ç§æ”»å‡»åœ¨gVisorç¯å¢ƒä¸‹ä»ç„¶æœ‰æ•ˆã€‚åœ¨æ¥ä¸‹æ¥çš„æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å°†åˆ†æä¸ºä»€ä¹ˆè¿™ä¸¤ç§æ”»å‡»å¯ä»¥åœ¨gVisorä¸Šå·¥ä½œã€‚ å¯¹äºnr_files, gVisorä½¿ç”¨Sentryä¸ºç³»ç»Ÿè°ƒç”¨æœåŠ¡ï¼Œè€ŒGoferä¸ºSentryå¤„ç†ä¸åŒç±»å‹çš„IOã€‚Sentryæ‹¦æˆªæ¥è‡ªå®¹å™¨çš„open syscallå¹¶å°†è¯·æ±‚å‘é€ç»™Goferã€‚åœ¨å¦ä¸€è¾¹ï¼ŒGoferé€šè¿‡è°ƒç”¨ä¸»æœºæ“ä½œç³»ç»Ÿçš„openatç³»ç»Ÿè°ƒç”¨æ¥å¤„ç†è¯¥è¯·æ±‚ã€‚æœ€ç»ˆï¼Œä¸»æœºæ“ä½œç³»ç»Ÿä¸Šçš„openatç³»ç»Ÿè°ƒç”¨è§¦å‘äº†alloc_empty_fileå‡½æ•°ï¼Œå®ƒæ¶ˆè€—äº†nr_filesã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼ŒgVisorçš„æ”»å‡»è€…èƒ½å¤Ÿè€—å°½ä¸»æœºçš„nr_filesã€‚å¯¹äºnetns_ct-&gt;countï¼ŒSentryæ‹¦æˆªè¿æ¥ç³»ç»Ÿè°ƒç”¨ï¼Œå¹¶ä½¿ç”¨è‡ªå·±çš„ç½‘ç»œå †æ ˆå°†æ•°æ®åŒ…è½¬å‘åˆ°ä¸»æœºä¸­åˆ›å»ºçš„veth-peerç½‘å¡ã€‚vth -peerè¿æ¥åˆ°ä¸»æœºä¸­çš„è™šæ‹Ÿç½‘æ¡¥ã€‚å½“ç½‘ç»œå¸§é€šè¿‡è™šæ‹Ÿç½‘æ¡¥è½¬å‘æ—¶ï¼Œä¸»æœºä¸Šçš„netfilterè¢«è§¦å‘è°ƒç”¨nf_conntrack_allocå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¶ˆè€—netns_ct-&gt;countã€‚å› æ­¤ï¼ŒgVisorä¸­çš„æ”»å‡»è€…ä»ç„¶å¯ä»¥è€—å°½ä¸»æœºçš„netns_ct-&gt;countã€‚ Summaryå¯¹äºè‡ªéƒ¨ç½²çš„å…±äº«å†…æ ¸å®¹å™¨ç¯å¢ƒï¼Œå…¶ä¸­ä¸¤ä¸ªæ˜“å—6æ¬¡æ”»å‡»ï¼Œä¸€ä¸ªæ˜“å—5æ”»å‡»ï¼Œå¦ä¸€ä¸ªæ˜“å—4æ”»å‡»ã€‚ä»¤äººæƒŠè®¶çš„æ˜¯ï¼ŒgVisorè¿è¡Œæ—¶ä¹Ÿå®¹æ˜“å—åˆ°ä¸¤ç§æ”»å‡»â€”â€”nr_filesæ”»å‡»å’Œnetns_ct-&gt;countæ”»å‡»ã€‚æˆ‘ä»¬å·²ç»å‘æ‰€æœ‰å››ä¸ªä¾›åº”å•†æŠ¥å‘Šäº†è¿™äº›æ”»å‡»ã€‚ä»–ä»¬éƒ½ç¡®è®¤äº†é—®é¢˜å­˜åœ¨äºä»–ä»¬çš„å…±äº«å†…æ ¸å®¹å™¨ç¯å¢ƒä¸­ã€‚ å°½ç®¡é¡¶çº§ä¾›åº”å•†ä½¿ç”¨è™šæ‹Ÿæœºæ¥éš”ç¦»ä¸åŒç§Ÿæˆ·çš„å®¹å™¨ï¼Œä½†ç”±äºå‡ ä¸ªåŸå› ï¼ŒæŠ½è±¡èµ„æºæ”»å‡»ä»ç„¶æ˜¯å¯è¡Œçš„ã€‚é¦–å…ˆï¼Œæ­£å¦‚åœ¨Linuxã€FreeBSDå’ŒFuchsiaä¸Šæ‰€æ¼”ç¤ºçš„ï¼ŒæŠ½è±¡èµ„æºæ”»å‡»æ˜¯æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ‰€å›ºæœ‰çš„ï¼Œå› æ­¤æ˜¯ä¸€ç§å¹¿æ³›çš„æ”»å‡»ç±»å‹ã€‚å…¶æ¬¡ï¼Œæ²¡æœ‰ç»éªŒçš„ç”¨æˆ·å¯èƒ½ä¸äº†è§£å…±äº«å†…æ ¸çš„é£é™©ï¼Œå¯èƒ½ä¼šä½¿ç”¨å®¹å™¨è¿›è¡Œsand-boxingã€‚æˆ‘ä»¬çš„è®ºæ–‡å°†æœ‰åŠ©äºæé«˜å¯¹é£é™©çš„è®¤è¯†ã€‚ç¬¬ä¸‰ï¼Œå³ä½¿åœ¨åŒä¸€ä¸ªç§Ÿæˆ·ä¸­ï¼Œç«äº‰çš„å›¢é˜Ÿä¹Ÿå¯èƒ½é€šè¿‡åˆ©ç”¨æŠ½è±¡èµ„æºæ¥æ”»å‡»å¯¹æ–¹ã€‚å› æ­¤ï¼Œç›‘æ§å’Œå‡è½»æ­¤ç±»æ”»å‡»ä»ç„¶æ˜¯å¿…è¦çš„ã€‚ Mitigation Discussionsåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ­ç¤ºäº†é™¤äº†ç‰©ç†èµ„æºï¼Œå®¹å™¨è¿˜å…±äº«åº•å±‚è¿è¡Œå†…æ ¸çš„æŠ½è±¡èµ„æºã€‚è¿™äº›æŠ½è±¡èµ„æºå¾ˆå®¹æ˜“è¢«æ”»å‡»ï¼Œåæœå¾ˆä¸¥é‡ã€‚åœ¨ä¸‹é¢ï¼Œæˆ‘ä»¬ç»™å‡ºäº†å¤šç§ç­–ç•¥æ¥é™ä½æŠ½è±¡èµ„æºå¸¦æ¥çš„é£é™©ã€‚ Using PAM for per-user quota restrictions æ­£å¦‚æ­£å¦‚ç¬¬4.2èŠ‚ä¸­æåˆ°çš„ï¼ŒLinuxå†…æ ¸æä¾›äº†å…è®¸ç”¨æˆ·åŠ è½½ç”¨æˆ·å®šåˆ¶çš„PAMçš„æ¥å£ã€‚PAMèƒ½å¤Ÿé™åˆ¶18ç§èµ„æºï¼Œå…¶ä¸­5ç§ä¸ºæŠ½è±¡èµ„æºï¼ŒåŒ…æ‹¬maxlogin/maxsysloginsã€nofileã€nprocå’Œsigpendingã€‚ä»æˆ‘ä»¬ä¸äº‘è®¡ç®—ä¾›åº”å•†çš„æ²Ÿé€šä¸­ï¼Œæˆ‘ä»¬ä¸çŸ¥é“æœ‰ä»»ä½•äº‘è®¡ç®—ä¾›åº”å•†é‡‡ç”¨PAMã€‚å› æ­¤ï¼Œæˆ‘ä»¬å»ºè®®å¯¹æŸäº›æŠ½è±¡èµ„æºçš„é™åˆ¶ä½¿ç”¨PAMã€‚Â§4.2èŠ‚æåˆ°çš„ï¼ŒLinuxå†…æ ¸æä¾›äº†å…è®¸ç”¨æˆ·åŠ è½½ç”¨æˆ·å®šåˆ¶çš„PAMçš„æ¥å£ã€‚PAMèƒ½å¤Ÿé™åˆ¶18ç§èµ„æºï¼Œå…¶ä¸­5ç§ä¸ºæŠ½è±¡èµ„æºï¼ŒåŒ…æ‹¬maxlogin/maxsysloginsã€nofileã€nprocå’Œsigpendingã€‚ä»æˆ‘ä»¬ä¸äº‘è®¡ç®—ä¾›åº”å•†çš„æ²Ÿé€šä¸­ï¼Œæˆ‘ä»¬ä¸çŸ¥é“æœ‰ä»»ä½•äº‘è®¡ç®—ä¾›åº”å•†é‡‡ç”¨PAMã€‚å› æ­¤ï¼Œæˆ‘ä»¬å»ºè®®å¯¹æŸäº›æŠ½è±¡èµ„æºçš„é™åˆ¶ä½¿ç”¨PAMã€‚ Using VM for strong isolation å¯¹äºå®‰å…¨å…³é”®å‹åº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬å»ºè®®ä¸è¦ä½¿ç”¨å¤šç§Ÿæˆ·å®¹å™¨ç¯å¢ƒã€‚æ›´å¼ºçš„éš”ç¦»æ–¹æ¡ˆï¼Œä¾‹å¦‚åŸºäºè™šæ‹Ÿæœºçš„è™šæ‹ŸåŒ–ï¼Œæ˜¯æ›´å¯å–çš„ã€‚ Using Monitoring Tools æˆ‘ä»¬å»ºè®®ä½¿ç”¨Kubernetesé›†ç¾¤çš„ç›‘æ§å·¥å…·ï¼Œå¦‚Falcoï¼Œæ¥ç›‘æ§å®¹å™¨çš„èµ„æºæ¶ˆè€—ã€‚å¯¹äºæ•æ„Ÿçš„æŠ½è±¡èµ„æº(å¦‚nr_fileså’Œinode)ï¼Œç”¨æˆ·åº”è¯¥è‡ªå®šä¹‰è‡ªå·±çš„è§„åˆ™æ¥ç›‘è§†ç³»ç»Ÿä¸­ç‰¹å®šçš„èµ„æºæ¶ˆè€—ã€‚ Improving current isolation design å¯¹äºç°æœ‰çš„namespaceï¼Œå¦‚PID namespaceï¼Œç”±äºæ˜ å°„åˆ°æ ¹namespaceçš„è®¾è®¡ï¼Œæ— æ³•é˜²å¾¡èµ„æºè€—å°½æ”»å‡»ã€‚å¦‚Â§3.2.2æ‰€è¿°ï¼ŒLinuxå†…æ ¸åœ¨æ ¹PID namespaceä¸­ä¸ºåœ¨å…¶ä»–PID namespaceä¸­åˆ†é…çš„ä»»ä½•idråˆ†é…ä¸€ä¸ªé¢å¤–çš„idrã€‚å› æ­¤ï¼Œæ ¹PID namespaceä»ç„¶æ˜¯å…¨å±€å…±äº«çš„ã€‚æ”»å‡»è€…ä»ç„¶å¯ä»¥å¾ˆå®¹æ˜“åœ°è€—å°½æ ¹PID namespaceä¸­çš„PIDï¼Œä»è€Œå¯¼è‡´DoSæ”»å‡»ã€‚å‡ºäºç±»ä¼¼çš„åŸå› ï¼Œå³ä½¿è¢«NET namespaceéš”ç¦»ï¼Œnf-conntrack æ•° netns_ct-&gt;countä¹Ÿå¯èƒ½è¢«æ”»å‡»ã€‚å› æ­¤ï¼ŒLinuxç¤¾åŒºéœ€è¦é‡æ–°å®¡è§†namespaceçš„è®¾è®¡ï¼Œæ¶ˆé™¤namespaceä¾èµ–å…³ç³»ä»¥æé«˜éš”ç¦»æ€§ã€‚ New kernel containment mechanisms Linuxå†…æ ¸ç¤¾åŒºå’Œå®¹å™¨ç¤¾åŒºéœ€è¦æŠ•å…¥æ›´å¤šç²¾åŠ›æ¥ä¿æŠ¤æŠ½è±¡èµ„æºã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å·²ç»å‘Dockerå®‰å…¨å›¢é˜ŸæŠ¥å‘Šäº†è¿™ä¸ªé—®é¢˜ã€‚åé¦ˆæ˜¯â€œLinuxå®¹å™¨åªèƒ½ä½¿ç”¨å¯ç”¨çš„å†…æ ¸éš”ç¦»æœºåˆ¶ã€‚å¦‚æœæ²¡æœ‰å†…æ ¸æœºåˆ¶æ¥æ§åˆ¶é™åˆ¶ï¼Œå®¹å™¨å°±ä¸èƒ½åšä»»ä½•äº‹æƒ…æ¥é™åˆ¶å®ƒâ€ã€‚å› æ­¤ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦å¯¹æ‰€æœ‰å®¹å™¨å…±äº«çš„æŠ½è±¡èµ„æºè¿›è¡Œå½»åº•çš„åˆ†æï¼Œä»¥ä¾¿æˆ‘ä»¬èƒ½å¤Ÿç†è§£ï¼Œæ›´é‡è¦çš„æ˜¯ï¼Œæ¸…é™¤å®ƒä»¬çš„æ•°æ®ä¾èµ–å…³ç³»ã€‚è¿™éœ€è¦å…¨é¢çš„å†…æ ¸é¢†åŸŸçŸ¥è¯†å’Œå¤§é‡çš„å†…æ ¸ä»£ç æ›´æ”¹ã€‚è€Œä¸”ï¼ŒLinuxå†…æ ¸æœ€åˆå¹¶ä¸æ˜¯ä¸ºæ”¯æŒæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–è€Œè®¾è®¡çš„ã€‚å®ƒçš„èµ„æºéš”ç¦»å’Œéåˆ¶æ˜¯ä¸å®Œæ•´çš„ã€‚å› æ­¤ï¼Œéœ€è¦æ–°çš„namespaceå’Œcgroupã€‚ More restrictive system call blocking ä»å®¹å™¨æ–¹é¢æ¥çœ‹ï¼Œç›®å‰ï¼Œå³ä½¿æ‰§è¡Œäº†seccompï¼Œå®¹å™¨ä¸­çš„åº”ç”¨ç¨‹åºä»ç„¶å¯ä»¥è®¿é—®å¤§çº¦250ä¸ªç³»ç»Ÿè°ƒç”¨ã€‚åœ¨æˆ‘ä»¬äº†è§£è¿™äº›ç³»ç»Ÿè°ƒç”¨çš„æ•°æ®ä¾èµ–æ€§ä¹‹å‰ï¼Œå»ºè®®æ‰§è¡Œæ›´ä¸¥æ ¼çš„seccompé…ç½®æ–‡ä»¶æ¥é˜»æ­¢æ›´å¤šä¸å¿…è¦çš„ç³»ç»Ÿè°ƒç”¨ã€‚å®¹å™¨ç”¨æˆ·å¯ä»¥ä½¿ç”¨æŠ€æœ¯æ¥è·å¾—æ›´ä¸¥æ ¼çš„seccompé…ç½®æ–‡ä»¶ï¼Œä»¥å‡å°‘æ½œåœ¨çš„æŠ½è±¡èµ„æºæ”»å‡»çš„å¯èƒ½æ€§ Related WorkVirtualization Techniquesåœ¨äº‘ç¯å¢ƒä¸­æœ‰ä¸¤ç§ä¸»æµçš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼ŒåŸºäºvmçš„è™šæ‹ŸåŒ–å’ŒOS-levelè™šæ‹ŸåŒ–ã€‚ä¸åŸºäºvmçš„è™šæ‹ŸåŒ–ç›¸æ¯”ï¼ŒOS-levelè™šæ‹ŸåŒ–è¶Šæ¥è¶Šæµè¡Œï¼Œå› ä¸ºå®ƒå¯ä»¥é€šè¿‡è½»é‡çº§è™šæ‹ŸåŒ–å®ç°å®Œæ•´çš„åº”ç”¨ç¨‹åºåŠŸèƒ½ã€‚ä¸ºäº†å……åˆ†äº†è§£æ€§èƒ½ä¼˜åŠ¿ï¼Œç ”ç©¶äººå‘˜è¿›è¡Œäº†ä¸€ç³»åˆ—ç ”ç©¶ã€‚Felterç­‰äººè¡¨æ˜ï¼Œé€šè¿‡ä½¿ç”¨ä¸€ç»„æ¶µç›–å¤šä¸ªèµ„æºçš„åŸºå‡†æµ‹è¯•ï¼ŒDockeråœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½å¯ä»¥è·å¾—æ¯”KVMæ›´å¥½çš„æ€§èƒ½ã€‚Joyç­‰äººåœ¨æ€§èƒ½å’Œå¯ä¼¸ç¼©æ€§æ–¹é¢å¯¹Linuxå®¹å™¨å’Œè™šæ‹Ÿæœºè¿›è¡Œäº†æ¯”è¾ƒã€‚Zhangç­‰äººçš„ç ”ç©¶è¡¨æ˜ï¼Œå®¹å™¨åœ¨å¤§æ•°æ®ç¯å¢ƒä¸­å…·æœ‰æ¯”è™šæ‹Ÿæœºæ›´å¥½çš„æ€§èƒ½ã€‚ æ‰€æœ‰è¿™äº›å·¥ä½œéƒ½è¡¨æ˜ï¼Œæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ¯”ä¼ ç»Ÿçš„åŸºäºè™šæ‹Ÿæœºçš„è™šæ‹ŸåŒ–å…·æœ‰æ›´å¥½çš„æ€§èƒ½ã€‚ç„¶è€Œï¼Œä»–ä»¬éƒ½æ²¡æœ‰æ³¨æ„åˆ°åº•å±‚å†…æ ¸æŠ½è±¡èµ„æºçš„æ½œåœ¨å½±å“ã€‚æœ¬æ–‡æ­ç¤ºäº†æŠ½è±¡èµ„æºå¼•å…¥çš„æ–°çš„æ”»å‡»é¢ã€‚ Resource IsolationLinuxä½¿ç”¨åŠŸèƒ½æ¥ç¦æ­¢æ²¡æœ‰ç‰¹å®šåŠŸèƒ½çš„è¿›ç¨‹è®¿é—®ç›¸åº”ç±»å‹çš„èµ„æºå®ä¾‹ã€‚ ç ”ç©¶äººå‘˜æå‡ºäº†åŸºäºLinuxåŠŸèƒ½çš„æ–¹æ³•ï¼Œå¦‚Wedge ï¼Œ Capsicumå’ŒACESã€‚è¿™äº›å·¥ä½œæ‰§è¡Œæ›´ç»†ç²’åº¦çš„èƒ½åŠ›æ§åˆ¶ï¼Œä»¥å‡è½»å†…å­˜æŸåæ”»å‡»ã€‚ç„¶è€Œï¼Œä»–ä»¬ä¸èƒ½é˜²å¾¡æˆ‘ä»¬çš„DoSæ”»å‡»ï¼Œè€—å°½å¯è®¿é—®çš„å…±äº«èµ„æºã€‚ å†…å­˜åœ°å€ç©ºé—´éš”ç¦»æ˜¯ä¸€ç§å…¸å‹çš„èµ„æºç©ºé—´éš”ç¦»æ–¹æ¡ˆï¼Œé¿å…å†…å­˜åœ°å€èµ„æºè€—å°½ã€‚Linuxå‘½åç©ºé—´éš”ç¦»äº†Â§2.1ä¸­åˆ—å‡ºçš„8ç§èµ„æºã€‚è¿™äº›æ–¹æ¡ˆåªèƒ½éš”ç¦»æœ‰é™ç±»å‹çš„èµ„æºã€‚èµ„æºå®¹å™¨å»ºè®®æ‰©å±•å•ç‰‡å†…æ ¸ï¼Œéš”ç¦»ç³»ç»Ÿèµ„æºï¼Œåœ¨çº¿ç¨‹çº§å¯¹èµ„æºè¿›è¡Œåˆ’åˆ†ï¼Œç±»ä¼¼äºæ§åˆ¶ç»„ã€‚ç”±äºæ€§èƒ½å¼€é”€å¾ˆå¤§ï¼Œä½¿ç”¨èµ„æºå®¹å™¨æ¥ä¿æŠ¤æ‰€æœ‰æŠ½è±¡èµ„æºæ˜¯ä¸åˆ‡å®é™…çš„ã€‚EdgeOSä¸ºè¾¹ç¼˜äº‘éƒ¨ç½²äº†å¼ºéš”ç¦»çš„æ“ä½œç³»ç»Ÿã€‚ç„¶è€Œï¼Œé‡‡ç”¨æ²¡æœ‰ç¡¬ä»¶æ”¯æŒçš„å¾®å†…æ ¸ä¼šæ¯”å•ç‰‡å†…æ ¸å¼•å…¥æ›´å¤šçš„å¼€é”€ã€‚Faasmä½¿ç”¨è½¯ä»¶æ•…éšœéš”ç¦»(SFI)è¿›è¡Œå†…å­˜éš”ç¦»ï¼Œè€Œåœ¨æ— æœåŠ¡å™¨è®¡ç®—ä¸­ä½¿ç”¨åç§°ç©ºé—´éš”ç¦»ç½‘ç»œèµ„æºç©ºé—´ã€‚ç„¶è€Œï¼Œå¤§å¤šæ•°å…±äº«èµ„æºä»ç„¶æš´éœ²åœ¨DoSæ”»å‡»çš„å¨èƒä¹‹ä¸‹ã€‚ Container Securityé™¤äº†èµ„æºéš”ç¦»ä¹‹å¤–ï¼Œè¿˜æœ‰å¯¹å®¹å™¨å®‰å…¨æ€§çš„ç ”ç©¶ã€‚Gaoç­‰äººå‘ç°ï¼Œå¯ä»¥åˆ©ç”¨&#x2F;procæˆ–&#x2F;sysçš„ä¿¡æ¯æ³„éœ²ï¼Œå‘åŠ¨ç”µæºæ”»å‡»ã€‚è€ŒåŒä¸€ç ”ç©¶å°ç»„è¿˜è¿›è¡Œäº†5æ¬¡æ”»å‡»ï¼Œäº§ç”Ÿå¸¦å¤–å·¥ä½œè´Ÿè½½ï¼Œä»¥æ‰“ç ´Linuxæ§åˆ¶ç»„çš„èµ„æºçº¦æŸã€‚ä½†å®ƒä»¬ä¸»è¦é’ˆå¯¹ä¿¡æ¯æ³„éœ²é—®é¢˜æˆ–æ”»å‡»CPUã€IOç­‰ç‰©ç†èµ„æºï¼Œè€Œä¸æ˜¯æŠ½è±¡èµ„æºã€‚ Linç­‰äººè¡¨æ˜å®¹å™¨ä¸èƒ½éš”ç¦»å†…æ ¸æ¼æ´ã€‚å¦ä¸€é¡¹å·¥ä½œä½¿ç”¨é™æ€åˆ†ææ¥åˆ†æDockerçš„ä»£ç ï¼Œä»¥æ‰¾åˆ°æ¼æ´å’Œä¿®è¡¥ä»£ç ä¹‹é—´çš„å·®å¼‚ã€‚ç„¶è€Œï¼Œè¿™äº›å·¥ä½œä¸»è¦é’ˆå¯¹ç°æœ‰çš„æ¼æ´å’Œåˆ©ç”¨ã€‚ç›¸åï¼Œæˆ‘ä»¬çš„å·¥ä½œå¼•å…¥äº†é’ˆå¯¹å…±äº«æŠ½è±¡èµ„æºçš„æ–°æ”»å‡»ã€‚ æ­¤å¤–ï¼Œè¿˜æœ‰åŠ å›ºé›†è£…ç®±çš„å·¥ä½œã€‚Leiç­‰äººæå‡ºäº†ä¸€ç§åä¸ºSPEAKERçš„å®¹å™¨å®‰å…¨æœºåˆ¶ï¼Œä»¥å‡å°‘åº”ç”¨ç¨‹åºåœ¨å®¹å™¨ä¸­å¯ç”¨çš„ç³»ç»Ÿè°ƒç”¨ã€‚Sunç­‰äººå¼€å‘äº†ä¸ºæ¯ä¸ªå®¹å™¨æä¾›å®‰å…¨ç­–ç•¥éš”ç¦»çš„å®‰å…¨namespaceã€‚å¦ä¸€é¡¹å·¥ä½œä½¿ç”¨Intel SGXä¿æŠ¤å®¹å™¨ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªä½æ€§èƒ½å¼€é”€çš„å°å‹å¯ä¿¡è®¡ç®—åŸºç¡€ã€‚Bradyç­‰äººå®ç°äº†å®¹å™¨å›¾åƒçš„å®‰å…¨è¯„ä¼°ç³»ç»Ÿã€‚ç„¶è€Œï¼Œæ‰€æœ‰è¿™äº›ä½œå“ä¸­çš„å®¹å™¨ä»ç„¶ä¾èµ–äºå†…æ ¸æä¾›å„ç§æœåŠ¡ï¼Œå› æ­¤ä»ç„¶å®¹æ˜“å—åˆ°æŠ½è±¡èµ„æºæ”»å‡»ã€‚ Conclusionåœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ­ç¤ºäº†å…±äº«å†…æ ¸åœ¨æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–ä¸­å¼•å…¥çš„ä¸€ç§æ–°çš„æ”»å‡»é¢ã€‚è¿™äº›å®¹å™¨ç›´æ¥æˆ–é—´æ¥åœ°å…±äº«æˆåƒä¸Šä¸‡çš„æŠ½è±¡èµ„æºï¼Œè¿™äº›èµ„æºå¾ˆå®¹æ˜“è¢«è€—å°½ï¼Œä»è€Œå¯¼è‡´å¯¹å…¶ä»–å®¹å™¨çš„DoSæ”»å‡»ã€‚ ä¸ºäº†æ˜¾ç¤ºé™åˆ¶æŠ½è±¡èµ„æºçš„é‡è¦æ€§ï¼Œæˆ‘ä»¬è¿›è¡Œäº†æŠ½è±¡èµ„æºæ”»å‡»ï¼Œé’ˆå¯¹æ“ä½œç³»ç»Ÿå†…æ ¸çš„ä¸åŒæ–¹é¢çš„æŠ½è±¡èµ„æºã€‚ç»“æœè¡¨æ˜ï¼Œæ”»å‡»æŠ½è±¡èµ„æºå…·æœ‰å¾ˆå¼ºçš„å®ç”¨æ€§å’Œå…³é”®æ€§ã€‚ æŠ½è±¡èµ„æºæœ¬èº«å°±éš¾ä»¥åŒ…å«ã€‚ä¸ºäº†äº†è§£è¿™äº›æ”»å‡»é¢ï¼Œæˆ‘ä»¬é¦–å…ˆè¿›è¡Œäº†ä¸€æ¬¡ç³»ç»Ÿåˆ†æï¼Œä»¥è¯†åˆ«Linuxå†…æ ¸ä¸­æ˜“å—æ”»å‡»çš„æŠ½è±¡èµ„æºã€‚æˆ‘ä»¬çš„å·¥å…·æˆåŠŸæ£€æµ‹äº†501ä¸ªåŠ¨æ€è§¦å‘çš„æŠ½è±¡èµ„æºï¼Œä»ä¸­é€‰å–äº†7ä¸ªï¼Œå¹¶åœ¨æ’åå‰4çš„äº‘ä¾›åº”å•†çš„è‡ªéƒ¨ç½²å…±äº«å†…æ ¸å®¹å™¨ç¯å¢ƒä¸­è¿›è¡Œäº†æ”»å‡»å®éªŒã€‚ç»“æœè¡¨æ˜ï¼Œæ‰€æœ‰ç¯å¢ƒéƒ½å®¹æ˜“å—åˆ°æˆ‘ä»¬çš„æ”»å‡»ã€‚ä¸ºäº†é™ä½é£é™©ï¼Œæˆ‘ä»¬ä¸ºå®¹å™¨ç”¨æˆ·å’Œå¼€å‘äººå‘˜æä¾›äº†ä¸€äº›å»ºè®®ã€‚ Myç¡¬ä»¶è™šæ‹ŸåŒ–å’ŒOS-levelè™šæ‹ŸåŒ–è™šæ‹ŸåŒ–æŠ€æœ¯é€šå¸¸å¯ä»¥åˆ†ä¸ºä¸¤å¤§ç±»ï¼šæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–ï¼ˆOS-level virtualizationï¼‰å’Œç¡¬ä»¶è™šæ‹ŸåŒ–ï¼ˆhardware virtualizationï¼‰ã€‚è¿™ä¸¤è€…çš„ä¸»è¦åŒºåˆ«åœ¨äºè™šæ‹ŸåŒ–å±‚çš„ä½ç½®ä»¥åŠèµ„æºåˆ†é…æ–¹å¼ã€‚ æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–ï¼ˆOS-level virtualization)æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ˜¯ä¸€ç§è½»é‡çº§è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œå®ƒå…è®¸åœ¨å•ä¸ªæ“ä½œç³»ç»Ÿå†…è¿è¡Œå¤šä¸ªç‹¬ç«‹çš„ã€éš”ç¦»çš„åº”ç”¨ç¨‹åºæˆ–æœåŠ¡ã€‚åœ¨è¿™ç§æ–¹å¼ä¸‹ï¼Œæ‰€æœ‰è™šæ‹Ÿå®ä¾‹å…±äº«ç›¸åŒçš„æ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œä½†æ¯ä¸ªå®ä¾‹æ‹¥æœ‰è‡ªå·±çš„æ–‡ä»¶ç³»ç»Ÿã€è¿›ç¨‹ã€ç½‘ç»œç­‰èµ„æºã€‚ è¯¦ç»†è¯´æ˜ï¼š èµ„æºåˆ†é…ï¼šæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–ä½¿ç”¨å®¹å™¨ï¼ˆContainerï¼‰æŠ€æœ¯å°†ç³»ç»Ÿèµ„æºï¼ˆå¦‚CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œç­‰ï¼‰åˆ’åˆ†ç»™å„ä¸ªè™šæ‹Ÿå®ä¾‹ã€‚å®¹å™¨ä¹‹é—´ç›¸äº’éš”ç¦»ï¼Œäº’ä¸å¹²æ‰°ã€‚ æ€§èƒ½ï¼šæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–å…·æœ‰è¾ƒä½çš„æ€§èƒ½å¼€é”€ï¼Œå› ä¸ºæ‰€æœ‰è™šæ‹Ÿå®ä¾‹å…±äº«ç›¸åŒçš„æ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œé¿å…äº†å¤šä¸ªæ“ä½œç³»ç»Ÿä¹‹é—´çš„èµ„æºç«äº‰ã€‚ çµæ´»æ€§ï¼šæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–æ”¯æŒçš„æ“ä½œç³»ç»Ÿç±»å‹å—é™äºå®¿ä¸»æœºæ“ä½œç³»ç»Ÿï¼Œå› æ­¤åœ¨è·¨å¹³å°æ–¹é¢çš„çµæ´»æ€§è¾ƒå·®ã€‚ å®ç°æ–¹å¼ï¼š Linuxï¼šLXCï¼ˆLinux Containersï¼‰ã€Docker FreeBSDï¼šJails Solarisï¼šZones&#x2F;Containers ç¡¬ä»¶è™šæ‹ŸåŒ–ï¼ˆHardware virtualizationï¼‰ç¡¬ä»¶è™šæ‹ŸåŒ–æ˜¯ä¸€ç§å…¨é¢çš„è™šæ‹ŸåŒ–æŠ€æœ¯ï¼Œå®ƒå…è®¸åœ¨å•ä¸ªç‰©ç†æœºå™¨ä¸Šè¿è¡Œå¤šä¸ªç‹¬ç«‹çš„ã€å®Œå…¨éš”ç¦»çš„æ“ä½œç³»ç»Ÿå®ä¾‹ã€‚åœ¨è¿™ç§æ–¹å¼ä¸‹ï¼Œè™šæ‹ŸåŒ–å±‚ä½äºæ“ä½œç³»ç»Ÿå’Œç¡¬ä»¶ä¹‹é—´ï¼Œä¸ºæ¯ä¸ªè™šæ‹Ÿæœºæä¾›ä¸€ä¸ªè™šæ‹Ÿç¡¬ä»¶ç¯å¢ƒã€‚ è¯¦ç»†è¯´æ˜ï¼š èµ„æºåˆ†é…ï¼šç¡¬ä»¶è™šæ‹ŸåŒ–ä½¿ç”¨è™šæ‹Ÿæœºï¼ˆVirtual Machineï¼‰æŠ€æœ¯å°†ç³»ç»Ÿèµ„æºï¼ˆå¦‚CPUã€å†…å­˜ã€ç£ç›˜ã€ç½‘ç»œç­‰ï¼‰åˆ’åˆ†ç»™å„ä¸ªè™šæ‹Ÿå®ä¾‹ã€‚è™šæ‹Ÿæœºä¹‹é—´ç›¸äº’éš”ç¦»ï¼Œäº’ä¸å¹²æ‰°ã€‚ æ€§èƒ½ï¼šç¡¬ä»¶è™šæ‹ŸåŒ–å…·æœ‰è¾ƒé«˜çš„æ€§èƒ½å¼€é”€ï¼Œå› ä¸ºæ¯ä¸ªè™šæ‹Ÿæœºéœ€è¦è¿è¡Œç‹¬ç«‹çš„æ“ä½œç³»ç»Ÿå†…æ ¸ï¼Œå¯¼è‡´èµ„æºç«äº‰å’Œè™šæ‹ŸåŒ–å¼€é”€ã€‚ çµæ´»æ€§ï¼šç¡¬ä»¶è™šæ‹ŸåŒ–æ”¯æŒè¿è¡Œä¸åŒç±»å‹çš„æ“ä½œç³»ç»Ÿï¼Œå…·æœ‰è¾ƒå¼ºçš„è·¨å¹³å°çµæ´»æ€§ã€‚ å®ç°æ–¹å¼ï¼š åŸºäºè½¯ä»¶çš„è™šæ‹ŸåŒ–ï¼šVMware Workstationã€VirtualBox åŸºäºç¡¬ä»¶çš„è™šæ‹ŸåŒ–ï¼šIntel VT-xã€AMD-V è™šæ‹ŸåŒ–ç®¡ç†å™¨ï¼ˆHypervisorï¼‰ï¼šVMware ESXiã€KVMï¼ˆKernel-based Virtual Machineï¼‰ã€Microsoft Hyper-Vã€Xen æ€»ç»“èµ·æ¥ï¼Œæ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–å’Œç¡¬ä»¶è™šæ‹ŸåŒ–çš„ä¸»è¦åŒºåˆ«åœ¨äºè™šæ‹ŸåŒ–å±‚çš„ä½ç½®ä»¥åŠèµ„æºåˆ†é…æ–¹å¼ã€‚æ“ä½œç³»ç»Ÿçº§è™šæ‹ŸåŒ–é€šè¿‡å…±äº«ç›¸åŒçš„æ“ä½œç³»ç»Ÿå†…æ ¸å®ç°è¾ƒä½çš„æ€§èƒ½å¼€é”€ï¼Œä½†è·¨å¹³å°çµæ´»æ€§è¾ƒå·®ï¼›ç¡¬ä»¶è™šæ‹ŸåŒ–å…è®¸è¿è¡Œå¤šä¸ªç‹¬ç«‹çš„æ“ä½œç³»ç»Ÿå®ä¾‹ï¼Œå…·æœ‰è¾ƒå¼ºçš„è·¨å¹³å°çµæ´»æ€§ï¼Œä½†æ€§èƒ½å¼€é”€è¾ƒé«˜ã€‚ LLVMLLVMï¼ˆLow Level Virtual Machineï¼‰æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨åŸºç¡€è®¾æ–½é¡¹ç›®ï¼Œå®ƒæä¾›äº†ä¸€ç³»åˆ—æ¨¡å—åŒ–å’Œå¯é‡ç”¨çš„ç¼–è¯‘å™¨ç»„ä»¶å’Œå·¥å…·é“¾ã€‚LLVMçš„è®¾è®¡ç›®æ ‡æ˜¯ä¸ºå„ç§ç¼–ç¨‹è¯­è¨€æä¾›ä¸€ä¸ªé€šç”¨çš„ä¸­é—´è¡¨ç¤ºï¼ˆIntermediate Representationï¼ŒIRï¼‰ï¼Œä»¥åŠä¸€å¥—ç”¨äºä¼˜åŒ–ã€åˆ†æå’Œç”Ÿæˆæœºå™¨ä»£ç çš„ç¼–è¯‘å™¨åç«¯ã€‚LLVMé¡¹ç›®åŒ…æ‹¬ä¸€äº›å­é¡¹ç›®ï¼Œå¦‚Clangï¼ˆCã€C++å’ŒObjective-Cçš„ç¼–è¯‘å™¨å‰ç«¯ï¼‰å’ŒLLDBï¼ˆä¸€ä¸ªè°ƒè¯•å™¨ï¼‰ã€‚ LLVMçš„æ ¸å¿ƒç»„ä»¶åŒ…æ‹¬ï¼š LLVM IRï¼šLLVMä¸­é—´è¡¨ç¤ºæ˜¯ä¸€ç§ä½çº§åˆ«ã€ç±»å‹åŒ–ã€å¹³å°æ— å…³çš„ç¼–ç¨‹è¯­è¨€ï¼Œç”¨äºè¡¨ç¤ºç¨‹åºçš„ç»“æ„å’Œè¡Œä¸ºã€‚LLVM IRæ—¢å¯ä»¥è¡¨ç¤ºä¸ºäººç±»å¯è¯»çš„æ–‡æœ¬ï¼Œä¹Ÿå¯ä»¥è¡¨ç¤ºä¸ºäºŒè¿›åˆ¶æ ¼å¼ã€‚ ç¼–è¯‘å™¨å‰ç«¯ï¼šç¼–è¯‘å™¨å‰ç«¯å°†æºä»£ç ï¼ˆå¦‚Cã€C++ã€Rustç­‰ï¼‰è§£ææˆLLVM IRã€‚Clangæ˜¯LLVMæœ€è‘—åçš„ç¼–è¯‘å™¨å‰ç«¯ï¼Œç”¨äºå¤„ç†Cã€C++å’ŒObjective-Cè¯­è¨€ã€‚å…¶ä»–è¯­è¨€ä¹Ÿæœ‰é’ˆå¯¹LLVMçš„ç¼–è¯‘å™¨å‰ç«¯ã€‚ ä¼˜åŒ–å™¨ï¼šLLVMæä¾›äº†ä¸€ç³»åˆ—é€šç”¨çš„ä»£ç ä¼˜åŒ–å’Œè½¬æ¢é€šé“ï¼Œè¿™äº›é€šé“å¯ä»¥åœ¨LLVM IRä¸Šè¿›è¡Œæ“ä½œï¼Œä¾‹å¦‚ï¼šå¸¸é‡æŠ˜å ã€æ­»ä»£ç æ¶ˆé™¤ã€å¾ªç¯ä¸å˜å¼ä»£ç ç§»åŠ¨ç­‰ã€‚ä¼˜åŒ–å™¨å¯ä»¥æ ¹æ®éœ€è¦é…ç½®å’Œç»„åˆï¼Œä»¥ç”Ÿæˆé«˜åº¦ä¼˜åŒ–çš„ä»£ç ã€‚ ç¼–è¯‘å™¨åç«¯ï¼šç¼–è¯‘å™¨åç«¯å°†ä¼˜åŒ–åçš„LLVM IRè½¬æ¢ä¸ºç‰¹å®šæ¶æ„çš„æœºå™¨ä»£ç ã€‚LLVMæ”¯æŒå¤šç§ç›®æ ‡å¹³å°ï¼ŒåŒ…æ‹¬x86ã€ARMã€MIPSã€WebAssemblyç­‰ã€‚ç¼–è¯‘å™¨åç«¯è¿˜è´Ÿè´£å¤„ç†è°ƒç”¨çº¦å®šã€å¯„å­˜å™¨åˆ†é…å’ŒæŒ‡ä»¤è°ƒåº¦ç­‰åº•å±‚ç»†èŠ‚ã€‚ LLVMçš„ä¼˜åŠ¿åœ¨äºå…¶æ¨¡å—åŒ–ã€å¯æ‰©å±•å’Œå¯é‡ç”¨çš„è®¾è®¡ã€‚è¿™ä½¿å¾—LLVMå¯ä»¥å¾ˆå®¹æ˜“åœ°æ”¯æŒæ–°çš„ç¼–ç¨‹è¯­è¨€å’Œç¡¬ä»¶æ¶æ„ï¼Œè€Œä¸éœ€è¦é‡æ–°å®ç°æ•´ä¸ªç¼–è¯‘å™¨ã€‚è¿™ä¹Ÿä½¿å¾—LLVMæˆä¸ºäº†è®¸å¤šç¼–ç¨‹è¯­è¨€ï¼ˆå¦‚Rustã€Swiftå’ŒJuliaï¼‰å’Œå¹³å°ï¼ˆå¦‚WebAssemblyã€GPUså’ŒFPGAsï¼‰çš„ç¼–è¯‘å™¨åŸºç¡€è®¾æ–½çš„é¦–é€‰ã€‚ Linux cgroupçš„ç»„ç»‡å’Œç»“æ„cgroup æ˜¯ä¸€ç§ç”¨äºé™åˆ¶å’Œæ§åˆ¶è¿›ç¨‹èµ„æºä½¿ç”¨çš„å®ç”¨å·¥å…·ï¼š é™åˆ¶èµ„æºï¼šLinux cgroup çš„ä¸»è¦ç›®çš„æ˜¯é™åˆ¶è¿›ç¨‹ä½¿ç”¨çš„èµ„æºï¼Œå¦‚ CPU ä½¿ç”¨ç‡ã€å†…å­˜ã€ç£ç›˜ I&#x2F;O ç­‰ã€‚è¿™æœ‰åŠ©äºç¡®ä¿ç³»ç»Ÿä¸Šçš„å„ä¸ªè¿›ç¨‹ä¸ä¼šè¿‡åº¦æ¶ˆè€—èµ„æºï¼Œä»è€Œå½±å“å…¶ä»–è¿›ç¨‹æˆ–æ•´ä¸ªç³»ç»Ÿçš„æ€§èƒ½ã€‚ æ§åˆ¶ç»„å†…è¿›ç¨‹ï¼šcgroup è´Ÿè´£ç®¡ç†å’Œæ§åˆ¶ç»„å†…æ‰€æœ‰è¿›ç¨‹çš„èµ„æºä½¿ç”¨ã€‚è¿™æ„å‘³ç€ä½ å¯ä»¥å°†ä¸€ç»„è¿›ç¨‹ç»„ç»‡åœ¨ä¸€ä¸ª cgroup ä¸­ï¼Œå¹¶å¯¹æ•´ä¸ªç»„æ–½åŠ èµ„æºé™åˆ¶ï¼Œè€Œä¸æ˜¯å•ç‹¬è®¾ç½®æ¯ä¸ªè¿›ç¨‹çš„é™åˆ¶ã€‚ æ ‘çŠ¶ç»“æ„ï¼šcgroup çš„ç»„ç»‡æ–¹å¼æ˜¯æ ‘çŠ¶ç»“æ„ï¼Œå…¶ä¸­æ¯ä¸ªèŠ‚ç‚¹ï¼ˆcgroupï¼‰å¯ä»¥åŒ…å«è‹¥å¹²å­èŠ‚ç‚¹ï¼ˆå­ cgroupï¼‰ã€‚è¿™ç§ç»“æ„å…è®¸ä½ å¯¹èµ„æºä½¿ç”¨è¿›è¡Œåˆ†å±‚ç®¡ç†ï¼Œé€šè¿‡åœ¨ä¸åŒå±‚æ¬¡æ–½åŠ ä¸åŒçš„é™åˆ¶ï¼Œå¯ä»¥æ›´çµæ´»åœ°æ§åˆ¶è¿›ç¨‹èµ„æºä½¿ç”¨ã€‚ å­èŠ‚ç‚¹å’Œçˆ¶èŠ‚ç‚¹çš„èµ„æºå…³ç³»ï¼šåœ¨ cgroup æ ‘çŠ¶ç»“æ„ä¸­ï¼Œå­ cgroup çš„èµ„æºé™åˆ¶åŒ…æ‹¬å…¶çˆ¶ cgroup çš„èµ„æºé™åˆ¶ã€‚è¿™æ„å‘³ç€å­ cgroup ä¸èƒ½å•ç‹¬è®¾ç½®è¶…å‡ºå…¶çˆ¶ cgroup é™åˆ¶çš„èµ„æºä½¿ç”¨ã€‚è¿™æœ‰åŠ©äºç»´æŠ¤æ•´ä½“èµ„æºé™åˆ¶çš„ä¸€è‡´æ€§ï¼Œå¹¶ç¡®ä¿å­ cgroup ä¸ä¼šå› è¿‡åº¦æ¶ˆè€—èµ„æºè€Œå½±å“å…¶çˆ¶ cgroup æˆ–æ•´ä¸ªç³»ç»Ÿã€‚ é€’å½’å¼ºåˆ¶æ‰§è¡Œï¼šcgroup æ ‘ç»“æ„ä¸­çš„èµ„æºé™åˆ¶æ˜¯é€’å½’å¼ºåˆ¶æ‰§è¡Œçš„ã€‚è¿™æ„å‘³ç€ä¸€ä¸ª cgroup çš„èµ„æºä½¿ç”¨é™åˆ¶å°†å—åˆ°å…¶æ‰€æœ‰ç¥–å…ˆï¼ˆçˆ¶ã€ç¥–çˆ¶ç­‰ï¼‰cgroup é™åˆ¶çš„çº¦æŸã€‚è¿™å¯ä»¥ç¡®ä¿åœ¨æ•´ä¸ª cgroup æ ‘ç»“æ„ä¸­ï¼Œèµ„æºé™åˆ¶å¾—åˆ°æ°å½“çš„æ‰§è¡Œå’Œéµå®ˆã€‚ æ€»ä¹‹ï¼ŒLinux cgroup æ˜¯ä¸€ç§ç”¨äºé™åˆ¶å’Œç®¡ç†è¿›ç¨‹èµ„æºä½¿ç”¨çš„å®ç”¨å·¥å…·ã€‚å®ƒé‡‡ç”¨æ ‘çŠ¶ç»“æ„æ¥ç»„ç»‡è¿›ç¨‹ï¼Œå…è®¸åˆ†å±‚ç®¡ç†èµ„æºï¼Œå¹¶é€šè¿‡é€’å½’å¼ºåˆ¶æ‰§è¡Œæ¥ç¡®ä¿èµ„æºé™åˆ¶å¾—åˆ°éµå®ˆã€‚ forkç‚¸å¼¹å’Œidrforkç‚¸å¼¹Fork ç‚¸å¼¹æ˜¯ä¸€ç§æ‹’ç»æœåŠ¡æ”»å‡»ï¼ˆDoSæ”»å‡»ï¼‰ï¼Œå…¶ç›®çš„æ˜¯é€šè¿‡åˆ›å»ºå¤§é‡å­è¿›ç¨‹è€—å°½ç³»ç»Ÿèµ„æºï¼Œä»è€Œå¯¼è‡´ç³»ç»Ÿå´©æºƒæˆ–æ— æ³•å“åº”ã€‚æ”»å‡»è€…å¯ä»¥ç¼–å†™ä¸€ä¸ªç®€å•çš„ç¨‹åºï¼Œä½¿å…¶åå¤è°ƒç”¨ fork() ç³»ç»Ÿè°ƒç”¨ï¼Œæ¯æ¬¡è°ƒç”¨éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å­è¿›ç¨‹ã€‚è¿™äº›å­è¿›ç¨‹å¯èƒ½ä¼šç»§ç»­åˆ›å»ºæ›´å¤šå­è¿›ç¨‹ï¼Œä»è€Œå¯¼è‡´è¿›ç¨‹æ•°é‡è¿…é€Ÿå¢åŠ ã€‚è¿™ç§æ”»å‡»æ–¹æ³•ä¹Ÿè¢«ç§°ä¸ºâ€œé€»è¾‘ç‚¸å¼¹â€æˆ–â€œè •è™«ç‚¸å¼¹â€ã€‚ åœ¨ Linux ç³»ç»Ÿä¸­ï¼Œfork() ç³»ç»Ÿè°ƒç”¨ç”¨äºåˆ›å»ºä¸€ä¸ªæ–°è¿›ç¨‹ï¼Œå®ƒæ˜¯å½“å‰è¿›ç¨‹çš„ä¸€ä¸ªå‰¯æœ¬ã€‚æ–°è¿›ç¨‹ï¼ˆå­è¿›ç¨‹ï¼‰ç»§æ‰¿äº†çˆ¶è¿›ç¨‹çš„èµ„æºï¼ˆå¦‚æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ã€å†…å­˜æ˜ å°„ç­‰ï¼‰ï¼Œå¹¶ä»çˆ¶è¿›ç¨‹çš„å½“å‰æ‰§è¡Œç‚¹å¼€å§‹æ‰§è¡Œã€‚å­è¿›ç¨‹æ‹¥æœ‰è‡ªå·±çš„ç‹¬ç«‹åœ°å€ç©ºé—´å’Œèµ„æºï¼Œå¹¶åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„è¿›ç¨‹ IDã€‚ idråœ¨ Linux å†…æ ¸ä¸­ï¼ŒIDRï¼ˆID Radix Treeï¼‰æ˜¯ä¸€ç§ç”¨äºç®¡ç†å’ŒæŸ¥æ‰¾æ•´æ•°ç±»å‹å¯¹è±¡æ ‡è¯†ç¬¦ï¼ˆå¦‚è¿›ç¨‹ IDã€æ–‡ä»¶æè¿°ç¬¦ç­‰ï¼‰çš„æ•°æ®ç»“æ„ã€‚IDR æ˜¯ä¸€ç§åŸºäºåŸºæ•°æ ‘ï¼ˆradix treeï¼‰çš„é«˜æ•ˆæ•°æ®ç»“æ„ï¼Œå¯ä»¥å¿«é€ŸæŸ¥æ‰¾ã€æ·»åŠ å’Œåˆ é™¤ IDã€‚IDR ç”¨äºåˆ†é…å”¯ä¸€çš„ ID ç»™å†…æ ¸å¯¹è±¡ï¼Œå¦‚è¿›ç¨‹ã€çº¿ç¨‹ã€æ–‡ä»¶ç­‰ï¼Œä»¥ä¾¿åœ¨å†…æ ¸ä¸­è¿›è¡Œè·Ÿè¸ªå’Œç®¡ç†ã€‚ fork ç‚¸å¼¹ä¼šé€šè¿‡åˆ›å»ºå¤§é‡å­è¿›ç¨‹æ¥è€—å°½æ‰€æœ‰å¯ç”¨çš„è¿›ç¨‹ IDï¼Œä»è€Œå¯¼è‡´ç³»ç»Ÿæ— æ³•åˆ›å»ºæ–°çš„è¿›ç¨‹ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´ç³»ç»Ÿæ€§èƒ½ä¸‹é™ã€å“åº”ç¼“æ…¢ç”šè‡³å´©æºƒã€‚ä¸ºäº†é˜²æ­¢è¿™ç±»æ”»å‡»ï¼Œç³»ç»Ÿç®¡ç†å‘˜å¯ä»¥é€šè¿‡è®¾ç½®è¿›ç¨‹æ•°èµ„æºé™åˆ¶ï¼ˆå¦‚ä½¿ç”¨ ulimit å‘½ä»¤ï¼‰æˆ–åœ¨å®¹å™¨ä¸­ä½¿ç”¨cgroup é™åˆ¶è¿›ç¨‹æ•°æ¥ä¿æŠ¤ç³»ç»Ÿã€‚ cloneç³»ç»Ÿè°ƒç”¨clone() ç³»ç»Ÿè°ƒç”¨æ˜¯ Linux ä¸­ç”¨äºåˆ›å»ºè¿›ç¨‹å’Œçº¿ç¨‹çš„ä¸€ä¸ªåº•å±‚å‡½æ•°ã€‚ä¸ fork() ç›¸æ¯”ï¼Œclone() æä¾›äº†æ›´å¤šçš„é€‰é¡¹å’Œçµæ´»æ€§ï¼Œå› ä¸ºå®ƒå…è®¸ç¨‹åºå‘˜æŒ‡å®šå“ªäº›èµ„æºåº”è¯¥åœ¨çˆ¶è¿›ç¨‹å’Œæ–°åˆ›å»ºçš„å­è¿›ç¨‹ä¹‹é—´å…±äº«ã€‚è¿™ä½¿å¾— clone() é€‚ç”¨äºåˆ›å»ºè½»é‡çº§çš„çº¿ç¨‹ä»¥åŠæ–°çš„ç‹¬ç«‹è¿›ç¨‹ã€‚ clone() ç³»ç»Ÿè°ƒç”¨çš„åŸå‹å¦‚ä¸‹ï¼š 1int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...); å‚æ•°è¯´æ˜ï¼š fnï¼šä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼ŒæŒ‡å‘å­è¿›ç¨‹æˆ–çº¿ç¨‹å¼€å§‹æ‰§è¡Œçš„å‡½æ•°ã€‚å­è¿›ç¨‹æˆ–çº¿ç¨‹è¿è¡Œç»“æŸåï¼Œè¿™ä¸ªå‡½æ•°åº”è¯¥è¿”å›ä¸€ä¸ªæ•´æ•°å€¼ï¼Œç”¨äºè¡¨ç¤ºé€€å‡ºçŠ¶æ€ã€‚ child_stackï¼šæŒ‡å‘å­è¿›ç¨‹æˆ–çº¿ç¨‹çš„æ ˆç©ºé—´çš„æŒ‡é’ˆã€‚å­è¿›ç¨‹æˆ–çº¿ç¨‹åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­å°†ä½¿ç”¨è¿™ä¸ªæ ˆç©ºé—´ã€‚ flagsï¼šç”¨äºæŒ‡å®šå­è¿›ç¨‹æˆ–çº¿ç¨‹çš„è¡Œä¸ºå’Œèµ„æºå…±äº«çš„ä½æ©ç ã€‚è¿™äº›æ ‡å¿—åŒ…æ‹¬ CLONE_VMï¼ˆå…±äº«å†…å­˜ç©ºé—´ï¼‰ã€CLONE_FSï¼ˆå…±äº«æ–‡ä»¶ç³»ç»Ÿä¿¡æ¯ï¼‰ã€CLONE_FILESï¼ˆå…±äº«æ–‡ä»¶æè¿°ç¬¦è¡¨ï¼‰ç­‰ã€‚é€šè¿‡ç»„åˆè¿™äº›æ ‡å¿—ï¼Œç¨‹åºå‘˜å¯ä»¥ç²¾ç»†æ§åˆ¶å­è¿›ç¨‹æˆ–çº¿ç¨‹çš„è¡Œä¸ºã€‚ argï¼šä¼ é€’ç»™ fn å‡½æ•°çš„å‚æ•°ã€‚é€šå¸¸ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡å‘æŸç§ç»“æ„æˆ–æ•°æ®çš„æŒ‡é’ˆã€‚ clone() ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼åœ¨çˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹ä¸­æœ‰æ‰€ä¸åŒã€‚åœ¨çˆ¶è¿›ç¨‹ä¸­ï¼Œclone() è¿”å›æ–°åˆ›å»ºçš„å­è¿›ç¨‹æˆ–çº¿ç¨‹çš„è¿›ç¨‹ IDï¼ˆPIDï¼‰ã€‚åœ¨å­è¿›ç¨‹ä¸­ï¼Œclone() è¿”å› 0ã€‚å¦‚æœåˆ›å»ºå¤±è´¥ï¼Œclone() è¿”å› -1ï¼Œå¹¶è®¾ç½®ç›¸åº”çš„é”™è¯¯ç ã€‚ clone() ç³»ç»Ÿè°ƒç”¨çš„ä½¿ç”¨ç›¸å¯¹å¤æ‚ï¼Œé€šå¸¸ä¸ç›´æ¥åœ¨åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨ã€‚åœ¨å®è·µä¸­ï¼Œç¨‹åºå‘˜æ›´å€¾å‘äºä½¿ç”¨æ›´é«˜çº§åˆ«çš„åº“å‡½æ•°ï¼Œå¦‚ pthread_create()ï¼ˆç”¨äºåˆ›å»ºçº¿ç¨‹ï¼‰æˆ– fork()ï¼ˆç”¨äºåˆ›å»ºè¿›ç¨‹ï¼‰ã€‚è¿™äº›åº“å‡½æ•°åœ¨å†…éƒ¨ä½¿ç”¨ clone() ç³»ç»Ÿè°ƒç”¨æ¥å®Œæˆè¿›ç¨‹å’Œçº¿ç¨‹çš„åˆ›å»ºã€‚ è„å†…å­˜è„å†…å­˜ï¼ˆDirty Memoryï¼‰æ˜¯è®¡ç®—æœºå†…å­˜ç®¡ç†ä¸­çš„ä¸€ä¸ªæ¦‚å¿µï¼ŒæŒ‡çš„æ˜¯å·²ç»è¢«ä¿®æ”¹è¿‡ä½†å°šæœªå†™å›åˆ°æŒä¹…å­˜å‚¨ï¼ˆå¦‚ç¡¬ç›˜ï¼‰çš„å†…å­˜æ•°æ®ã€‚åœ¨æ“ä½œç³»ç»Ÿå’Œåº”ç”¨ç¨‹åºä¸­ï¼Œå†…å­˜ï¼ˆRAMï¼‰è¢«ç”¨ä½œç¼“å­˜ï¼Œä»¥åŠ é€Ÿå¯¹æ•°æ®çš„è®¿é—®ã€‚ä¸ç£ç›˜ç›¸æ¯”ï¼Œå†…å­˜è®¿é—®é€Ÿåº¦è¦å¿«å¾—å¤šï¼Œå› æ­¤å°†æ•°æ®ç¼“å­˜åœ¨å†…å­˜ä¸­å¯ä»¥æé«˜ç³»ç»Ÿæ€§èƒ½ã€‚ å½“ä¸€ä¸ªç¨‹åºæˆ–æ“ä½œç³»ç»Ÿä¿®æ”¹äº†å†…å­˜ä¸­çš„æ•°æ®ï¼Œä¸ç£ç›˜ä¸Šçš„åŸå§‹æ•°æ®ä¸å†ä¸€è‡´æ—¶ï¼Œè¿™éƒ¨åˆ†å†…å­˜å°±è¢«ç§°ä¸º â€œè„å†…å­˜â€ã€‚è„å†…å­˜ä¸­çš„æ•°æ®æœ€ç»ˆéœ€è¦å†™å›åˆ°ç£ç›˜ï¼Œä»¥ç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§å’ŒæŒä¹…æ€§ã€‚ä»¥ä¸‹æ˜¯è„å†…å­˜äº§ç”Ÿçš„ä¸€äº›å¸¸è§åœºæ™¯ï¼š æ–‡ä»¶ç³»ç»Ÿç¼“å­˜ï¼šæ“ä½œç³»ç»Ÿé€šå¸¸ä¼šå°†ç£ç›˜ä¸Šçš„æ–‡ä»¶æ•°æ®ç¼“å­˜åœ¨å†…å­˜ä¸­ï¼Œä»¥æé«˜æ–‡ä»¶è®¿é—®é€Ÿåº¦ã€‚å½“ä¸€ä¸ªç¨‹åºä¿®æ”¹äº†æ–‡ä»¶å†…å®¹æ—¶ï¼Œå†…å­˜ä¸­çš„ç¼“å­˜æ•°æ®å˜ä¸ºè„å†…å­˜ã€‚è¿™äº›è„å†…å­˜æ•°æ®æœ€ç»ˆéœ€è¦åŒæ­¥å›ç£ç›˜ï¼Œä»¥ç¡®ä¿æ–‡ä»¶åœ¨ç£ç›˜ä¸Šçš„å†…å®¹ä¸å†…å­˜ä¸­çš„å†…å®¹ä¸€è‡´ã€‚ æ•°æ®åº“ç¼“å­˜ï¼šæ•°æ®åº“ç³»ç»Ÿç»å¸¸ä½¿ç”¨å†…å­˜æ¥ç¼“å­˜æ•°æ®åº“è¡¨å’Œç´¢å¼•ä¸­çš„æ•°æ®ã€‚å½“æ•°æ®åº“äº‹åŠ¡ä¿®æ”¹äº†è¡¨ä¸­çš„æ•°æ®æ—¶ï¼Œç›¸åº”çš„å†…å­˜ç¼“å­˜æ•°æ®ä¹Ÿä¼šå˜ä¸ºè„å†…å­˜ã€‚è¿™äº›è„å†…å­˜æ•°æ®éœ€è¦åœ¨é€‚å½“çš„æ—¶æœºå†™å›åˆ°ç£ç›˜ï¼Œä»¥ç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§å’ŒæŒä¹…æ€§ã€‚ è™šæ‹Ÿå†…å­˜ç®¡ç†ï¼šåœ¨è™šæ‹Ÿå†…å­˜ç®¡ç†ä¸­ï¼Œæ“ä½œç³»ç»Ÿé€šè¿‡å°†å†…å­˜ä¸­çš„æ•°æ®ä¸ç£ç›˜ä¸Šçš„äº¤æ¢ç©ºé—´ï¼ˆæˆ–é¡µé¢æ–‡ä»¶ï¼‰è¿›è¡Œäº¤æ¢ï¼Œæ¥æ¨¡æ‹Ÿæ›´å¤§çš„å†…å­˜ç©ºé—´ã€‚å½“æ“ä½œç³»ç»Ÿéœ€è¦å°†å†…å­˜ä¸­çš„æ•°æ®äº¤æ¢å‡ºå»æ—¶ï¼Œå¦‚æœè¿™éƒ¨åˆ†æ•°æ®æ˜¯è„å†…å­˜ï¼Œæ“ä½œç³»ç»Ÿéœ€è¦å…ˆå°†å…¶å†™å›åˆ°ç£ç›˜ï¼Œç„¶åæ‰èƒ½å°†å…¶äº¤æ¢å‡ºå»ã€‚ æ“ä½œç³»ç»Ÿé€šå¸¸ä¼šä½¿ç”¨ä¸€äº›ç­–ç•¥æ¥å¹³è¡¡è„å†…å­˜çš„å¤„ç†å’Œç³»ç»Ÿæ€§èƒ½ã€‚ä¾‹å¦‚ï¼ŒLinux å†…æ ¸é€šè¿‡ç›‘æ§è„å†…å­˜å æ¯”ï¼ˆdirty ratioï¼‰ï¼Œåœ¨å¿…è¦æ—¶è§¦å‘åå°çº¿ç¨‹å°†è„å†…å­˜åŒæ­¥åˆ°ç£ç›˜ã€‚è¿™æ ·å¯ä»¥åœ¨æé«˜ç³»ç»Ÿæ€§èƒ½çš„åŒæ—¶ï¼Œç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§å’ŒæŒä¹…æ€§ã€‚ Linuxå¤„ç†è„å†…å­˜ Linux å†…æ ¸å¦‚ä½•å¤„ç†è„å†…å­˜ï¼ˆå³å·²ä¿®æ”¹ä½†å°šæœªåŒæ­¥åˆ°ç£ç›˜çš„å†…å­˜ï¼‰çš„è¿‡ç¨‹ã€‚åœ¨ Linux å†…æ ¸ä¸­ï¼Œdirty_throttle_control ç»“æ„ä½“ç”¨äºç®¡ç†å’Œæ§åˆ¶è„å†…å­˜ã€‚ç»“æ„ä½“ä¸­çš„ dirty å­—æ®µè¡¨ç¤ºæ•´ä¸ªå†…æ ¸ç©ºé—´çš„è„å†…å­˜å æ¯”ï¼ˆdirty ratioï¼‰ã€‚ å½“ dirty å€¼è¿‡é«˜æ—¶ï¼Œå†…æ ¸ä¼šå”¤é†’åå°çº¿ç¨‹ï¼ˆä¾‹å¦‚ pdflushã€flusher æˆ– kswapdï¼‰ï¼Œå°†è„å†…å­˜åŒæ­¥åˆ°ç£ç›˜ã€‚è¿™æœ‰åŠ©äºç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§å’ŒæŒä¹…æ€§ï¼Œé˜²æ­¢æ„å¤–ä¸¢å¤±ã€‚ ç„¶è€Œï¼Œå¦‚æœ dirty å€¼å¤ªé«˜ï¼Œå†…æ ¸ä¼šé˜»å¡ write_back æ“ä½œã€‚è¿™æ„å‘³ç€å†…æ ¸å°†æ‰€æœ‰å†™æ“ä½œéƒ½è½¬æ¢ä¸º write_through æ“ä½œï¼Œä»è€Œé™ä½å†™æ€§èƒ½ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è§£é‡Š write_back å’Œ write_through ä¹‹é—´çš„åŒºåˆ«ï¼š write_backï¼šåœ¨ write_back æ“ä½œä¸­ï¼Œæ•°æ®é¦–å…ˆå†™å…¥ç¼“å­˜ï¼ˆä¾‹å¦‚ CPU ç¼“å­˜æˆ–æ–‡ä»¶ç³»ç»Ÿç¼“å­˜ï¼‰ã€‚ä¸€æ—¦æ•°æ®è¢«å†™å…¥ç¼“å­˜ï¼Œæ“ä½œå°±è¢«è®¤ä¸ºæ˜¯å®Œæˆçš„ï¼Œå³ä½¿æ•°æ®å°šæœªåŒæ­¥åˆ°ç£ç›˜ã€‚åœ¨åå°ï¼Œè„æ•°æ®ä¼šåœ¨é€‚å½“çš„æ—¶æœºè¢«åˆ·æ–°åˆ°ç£ç›˜ã€‚write_back çš„ä¼˜åŠ¿åœ¨äºå®ƒå¯ä»¥æä¾›è¾ƒé«˜çš„å†™æ€§èƒ½ï¼Œå› ä¸ºå†™æ“ä½œå¯ä»¥ç«‹å³è¿”å›ï¼Œè€Œä¸éœ€è¦ç­‰å¾…ç£ç›˜åŒæ­¥ã€‚ write_throughï¼šåœ¨ write_through æ“ä½œä¸­ï¼Œæ•°æ®åŒæ—¶å†™å…¥ç¼“å­˜å’Œç£ç›˜ã€‚å†™æ“ä½œåœ¨æ•°æ®è¢«å†™å…¥ç£ç›˜ä¹‹å‰ä¸ä¼šè¢«è®¤ä¸ºå·²å®Œæˆã€‚è™½ç„¶è¿™å¯ä»¥ç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§å’ŒæŒä¹…æ€§ï¼Œä½† write_through çš„æ€§èƒ½é€šå¸¸ä½äº write_backï¼Œå› ä¸ºå®ƒéœ€è¦ç­‰å¾…ç£ç›˜åŒæ­¥ã€‚ æ€»ä¹‹ï¼Œè¿™æ®µè¯æè¿°äº† Linux å†…æ ¸å¦‚ä½•åœ¨å¤„ç†è„å†…å­˜æ—¶åœ¨æ€§èƒ½å’Œæ•°æ®ä¸€è‡´æ€§ä¹‹é—´å¯»æ±‚å¹³è¡¡ã€‚å½“è„å†…å­˜å æ¯”è¿‡é«˜æ—¶ï¼Œå†…æ ¸ä¼šé‡‡å–æªæ–½é™ä½å†™æ€§èƒ½ï¼Œä»¥ç¡®ä¿æ•°æ®çš„ä¸€è‡´æ€§å’ŒæŒä¹…æ€§ã€‚ Linuxä¼ªç»ˆç«¯Linux å†…æ ¸ä½¿ç”¨ /dev/ptmxï¼ˆä¸»è®¾å¤‡ï¼‰å’Œ /dev/ptsï¼ˆä»è®¾å¤‡ï¼‰æ¥å®ç°ä¼ªç»ˆç«¯ï¼ˆpseudo-terminalï¼Œç®€ç§° ptyï¼‰ã€‚ä¼ªç»ˆç«¯æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç»ˆç«¯è®¾å¤‡ï¼Œå®ƒä¸ç›´æ¥è¿æ¥åˆ°ç‰©ç†è®¾å¤‡ï¼Œè€Œæ˜¯é€šè¿‡è½¯ä»¶æ¥æ¨¡æ‹Ÿç»ˆç«¯çš„è¾“å…¥å’Œè¾“å‡ºã€‚ä¼ªç»ˆç«¯å¹¿æ³›åº”ç”¨äºè¿œç¨‹ç™»å½•ï¼ˆå¦‚ SSHï¼‰ã€ç»ˆç«¯æ¨¡æ‹Ÿå™¨ï¼ˆå¦‚ xtermï¼‰å’Œå…¶ä»–éœ€è¦æ¨¡æ‹Ÿç»ˆç«¯è¡Œä¸ºçš„åœºæ™¯ã€‚ ä»¥ä¸‹æ˜¯å…³äºä¼ªç»ˆç«¯å’Œ /dev/ptmx ä»¥åŠ /dev/pts çš„ä¸€äº›è¯¦ç»†ä¿¡æ¯ï¼š ä¸»è®¾å¤‡ï¼ˆ&#x2F;dev&#x2F;ptmxï¼‰ï¼š/dev/ptmx æ˜¯ä¸€ä¸ªå­—ç¬¦è®¾å¤‡æ–‡ä»¶ï¼Œç”¨äºåˆ›å»ºä¼ªç»ˆç«¯çš„ä¸»è®¾å¤‡ã€‚å½“ä¸€ä¸ªè¿›ç¨‹ï¼ˆå¦‚ SSH æœåŠ¡å™¨æˆ–ç»ˆç«¯æ¨¡æ‹Ÿå™¨ï¼‰éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ä¼ªç»ˆç«¯æ—¶ï¼Œå®ƒä¼šæ‰“å¼€ /dev/ptmx è®¾å¤‡æ–‡ä»¶ã€‚å†…æ ¸ä¼šä¸ºè¿™ä¸ªè¿›ç¨‹åˆ†é…ä¸€ä¸ªæœªä½¿ç”¨çš„ä¼ªç»ˆç«¯ï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘ä¼ªç»ˆç«¯ä¸»è®¾å¤‡çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ä¸»è®¾å¤‡ç”¨äºç®¡ç†ä¼ªç»ˆç«¯ï¼Œå¦‚æ¥æ”¶ä»è®¾å¤‡çš„è¾“å…¥æ•°æ®ã€å‘ä»è®¾å¤‡å‘é€è¾“å‡ºæ•°æ®ç­‰ã€‚ ä»è®¾å¤‡ï¼ˆ&#x2F;dev&#x2F;ptsï¼‰ï¼š/dev/pts æ˜¯ä¸€ä¸ªè™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼ˆé€šå¸¸æŒ‚è½½åœ¨ /dev/pts ç›®å½•ä¸‹ï¼‰ï¼Œç”¨äºå­˜å‚¨ä¼ªç»ˆç«¯çš„ä»è®¾å¤‡ã€‚å½“ä¸€ä¸ªä¼ªç»ˆç«¯è¢«åˆ›å»ºæ—¶ï¼Œå†…æ ¸ä¼šåœ¨ /dev/pts ç›®å½•ä¸‹ä¸ºå…¶ä»è®¾å¤‡åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„ç¼–å·ï¼ˆå¦‚ /dev/pts/0ã€/dev/pts/1 ç­‰ï¼‰ã€‚ä»è®¾å¤‡ç”¨äºæ¨¡æ‹Ÿç»ˆç«¯çš„è¾“å…¥å’Œè¾“å‡ºæ“ä½œï¼Œå¦‚è¯»å–ç”¨æˆ·è¾“å…¥ã€æ˜¾ç¤ºæ–‡æœ¬è¾“å‡ºç­‰ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œä»è®¾å¤‡ä¼šè¢«åˆ†é…ç»™å¦ä¸€ä¸ªè¿›ç¨‹ï¼ˆå¦‚ shellï¼‰ï¼Œä»¥ä¾¿å®ƒå¯ä»¥ä¸ä¸»è®¾å¤‡è¿›è¡Œé€šä¿¡ã€‚ é€šè¿‡ä¸»è®¾å¤‡å’Œä»è®¾å¤‡çš„äº¤äº’ï¼Œä¼ªç»ˆç«¯å®ç°äº†ç»ˆç«¯æ¨¡æ‹Ÿå™¨å’Œå…¶ä»–ç±»ä¼¼ç¨‹åºä¸ shellã€è¿œç¨‹ä¼šè¯ç­‰ä¹‹é—´çš„é€šä¿¡ã€‚è¿™ç§æŠ½è±¡ä½¿å¾—ä¼ªç»ˆç«¯å¯ä»¥åœ¨ä¸ä¾èµ–äºç‰¹å®šç¡¬ä»¶çš„æƒ…å†µä¸‹ï¼Œæä¾›ä¸ç‰©ç†ç»ˆç«¯ç±»ä¼¼çš„åŠŸèƒ½ã€‚ FreeBSDå’ŒFuchsiaFreeBSDå’ŒFuchsiaæ˜¯ä¸¤ç§ä¸åŒçš„æ“ä½œç³»ç»Ÿã€‚ä¸‹é¢æˆ‘ä»¬åˆ†åˆ«è¯¦ç»†è§£é‡Šè¿™ä¸¤ä¸ªæ“ä½œç³»ç»Ÿã€‚ FreeBSDFreeBSDæ˜¯ä¸€ä¸ªç±»Unixçš„å¼€æºæ“ä½œç³»ç»Ÿï¼Œå®ƒåŸºäºåˆ›å»ºUnixçš„Berkeley Software Distributionï¼ˆBSDï¼‰çš„æºä»£ç ã€‚FreeBSDæˆç«‹äº1993å¹´ï¼Œæ˜¯BSDå®¶æ—çš„ä¸€ä¸ªæˆå‘˜ï¼Œä¸NetBSDå’ŒOpenBSDç­‰å…¶ä»–BSDæ“ä½œç³»ç»Ÿå¹¶è¡Œå‘å±•ã€‚ FreeBSDçš„ç‰¹ç‚¹ï¼š å¼€æºï¼šFreeBSDçš„æºä»£ç å¯ä»¥å…è´¹è·å–å’Œä¿®æ”¹ï¼Œéµå¾ªBSDè®¸å¯è¯ã€‚è¿™ä½¿å¾—è®¸å¤šå…¬å¸å’Œå¼€å‘è€…å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚å®šåˆ¶æ“ä½œç³»ç»Ÿã€‚ ç¨³å®šæ€§ï¼šFreeBSDä»¥å…¶ç¨³å®šæ€§å’Œå¯é æ€§è€Œé—»åï¼Œä½¿å…¶æˆä¸ºæœåŠ¡å™¨å’Œå…³é”®åŸºç¡€è®¾æ–½çš„ç†æƒ³é€‰æ‹©ã€‚ æ€§èƒ½ï¼šFreeBSDçš„æ€§èƒ½ä¼˜å¼‚ï¼Œè¢«å¹¿æ³›åº”ç”¨äºé«˜æ€§èƒ½è®¡ç®—ã€ç½‘ç»œæœåŠ¡å’Œå­˜å‚¨è§£å†³æ–¹æ¡ˆã€‚ å®‰å…¨æ€§ï¼šFreeBSDæä¾›äº†å¤šç§å®‰å…¨åŠŸèƒ½ï¼Œå¦‚å¼ºåˆ¶è®¿é—®æ§åˆ¶ã€å®‰å…¨çº§åˆ«å’Œé˜²ç«å¢™é›†æˆã€‚ å¯ç§»æ¤æ€§ï¼šFreeBSDæ”¯æŒå¤šç§ç¡¬ä»¶å¹³å°ï¼ŒåŒ…æ‹¬x86ã€x86-64ã€ARMã€MIPSå’ŒPowerPCç­‰ã€‚ FuchsiaFuchsiaæ˜¯ç”±è°·æ­Œï¼ˆGoogleï¼‰å¼€å‘çš„ä¸€ä¸ªå¼€æºæ“ä½œç³»ç»Ÿã€‚ä¸FreeBSDä¸åŒï¼ŒFuchsiaä¸æ˜¯åŸºäºUnixçš„ï¼Œè€Œæ˜¯åŸºäºåä¸ºZirconçš„æ–°å†…æ ¸æ„å»ºçš„ã€‚Fuchsiaçš„å¼€å‘å§‹äº2016å¹´ï¼Œç›®æ ‡æ˜¯åˆ›å»ºä¸€ä¸ªé«˜åº¦æ¨¡å—åŒ–ã€å¯æ‰©å±•ä¸”å¯ç”¨äºå„ç§è®¾å¤‡çš„æ“ä½œç³»ç»Ÿã€‚ Fuchsiaçš„ç‰¹ç‚¹ï¼š å¼€æºï¼šFuchsiaæ˜¯ä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œéµå¾ªBSDã€MITã€Apacheç­‰è®¸å¯è¯ã€‚è¿™æ„å‘³ç€å¼€å‘è€…å’Œå…¬å¸å¯ä»¥å…è´¹è®¿é—®å’Œä¿®æ”¹å®ƒçš„æºä»£ç ã€‚ Zirconå†…æ ¸ï¼šFuchsiaåŸºäºZirconå†…æ ¸ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾®å†…æ ¸è®¾è®¡ï¼Œä½¿å¾—æ“ä½œç³»ç»Ÿæ›´åŠ è½»é‡åŒ–å’Œé«˜åº¦æ¨¡å—åŒ–ã€‚ è·¨å¹³å°ï¼šFuchsiaæ—¨åœ¨æˆä¸ºä¸€ä¸ªç»Ÿä¸€çš„æ“ä½œç³»ç»Ÿï¼Œé€‚ç”¨äºå„ç§è®¾å¤‡ï¼ŒåŒ…æ‹¬æ™ºèƒ½æ‰‹æœºã€å¹³æ¿ç”µè„‘ã€ä¸ªäººç”µè„‘ä»¥åŠç‰©è”ç½‘ï¼ˆIoTï¼‰è®¾å¤‡ã€‚ æ¨¡å—åŒ–å’Œå¯æ‰©å±•æ€§ï¼šFuchsiaçš„è®¾è®¡å…è®¸å¼€å‘è€…è½»æ¾åœ°æ·»åŠ å’Œç§»é™¤ç»„ä»¶ï¼Œä½¿å¾—æ“ä½œç³»ç»Ÿèƒ½å¤Ÿæ ¹æ®éœ€æ±‚è¿›è¡Œå®šåˆ¶åŒ–ã€‚ Flutteræ¡†æ¶ï¼šFuchsiaä½¿ç”¨è°·æ­Œçš„Flutteræ¡†æ¶æ„å»ºç”¨æˆ·ç•Œé¢ï¼ŒFlutteræ”¯æŒè·¨å¹³å°åº”ç”¨å¼€å‘ï¼Œå¯ä»¥ä½¿Fuchsiaåº”ç”¨åœ¨å…¶ä»–æ“ä½œç³»ç»Ÿä¸Šè¿è¡Œã€‚ æ€»ç»“ï¼ŒFreeBSDæ˜¯ä¸€ä¸ªåŸºäºUnixçš„ç¨³å®šã€é«˜æ€§èƒ½çš„å¼€æºæ“ä½œç³»ç»Ÿï¼Œä¸»è¦ç”¨äºæœåŠ¡å™¨å’Œé«˜æ€§èƒ½è®¡ç®—ã€‚è€ŒFuchsiaæ˜¯è°·æ­Œå¼€å‘çš„ä¸€ä¸ªå…¨æ–°çš„ã€åŸºäºZirconå†…æ ¸çš„æ“ä½œç³»ç»Ÿï¼Œæ—¨åœ¨æä¾›ç»Ÿä¸€çš„ã€è·¨è®¾å¤‡çš„ä½“éªŒã€‚ sysctlæ¥å£Linuxå†…æ ¸é€šè¿‡/proc/sysä¸‹çš„sysctlæ¥å£ä¸ºç”¨æˆ·ç©ºé—´ç¨‹åºæä¾›äº†ä¸€ç§æ–¹å¼æ¥æŸ¥è¯¢å’Œä¿®æ”¹å†…æ ¸å‚æ•°ã€‚sysctlå¯ä»¥é€šè¿‡æ–‡ä»¶ç³»ç»Ÿè®¿é—®ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥é€šè¿‡å‘½ä»¤è¡Œå·¥å…·sysctlè¿›è¡Œæ“ä½œã€‚è¿™äº›å‚æ•°æ¶‰åŠåˆ°è®¸å¤šå†…æ ¸å­ç³»ç»Ÿå’Œç»„ä»¶ï¼ŒåŒ…æ‹¬å†…å­˜ç®¡ç†ã€ç½‘ç»œè®¾ç½®ã€å®‰å…¨è®¾ç½®ç­‰ã€‚ åœ¨sysctlé…ç½®ä¸­ï¼Œæœ‰å¾ˆå¤šå‚æ•°æ¶‰åŠåˆ°æŠ½è±¡èµ„æºé™åˆ¶ã€‚è¿™äº›é™åˆ¶é€šå¸¸ç”¨äºçº¦æŸç³»ç»Ÿèµ„æºçš„åˆ†é…ï¼Œä»¥é˜²æ­¢èµ„æºè€—å°½æˆ–è€…ä¿è¯ç³»ç»Ÿçš„ç¨³å®šè¿è¡Œã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„èµ„æºé™åˆ¶ç›¸å…³çš„sysctlå‚æ•°ï¼š vm.max_map_countï¼šè¿™ä¸ªå‚æ•°ç”¨äºé™åˆ¶ä¸€ä¸ªè¿›ç¨‹å¯ä»¥æ‹¥æœ‰çš„æœ€å¤§å†…å­˜æ˜ å°„åŒºåŸŸæ•°é‡ã€‚è¿™ä¸ªé™åˆ¶æœ‰åŠ©äºé˜²æ­¢èµ„æºè€—å°½ï¼Œå°¤å…¶æ˜¯åœ¨å†…å­˜åˆ†é…å¯†é›†å‹çš„åº”ç”¨åœºæ™¯ä¸­ã€‚ kernel.pid_maxï¼šè¿™ä¸ªå‚æ•°ç”¨äºè®¾ç½®ç³»ç»Ÿä¸­åˆ†é…çš„æœ€å¤§è¿›ç¨‹IDã€‚é€šè¿‡é™åˆ¶è¿›ç¨‹IDçš„æ•°é‡ï¼Œå¯ä»¥é˜²æ­¢æ¶æ„è½¯ä»¶æˆ–ç¼–ç¨‹é”™è¯¯å¯¼è‡´çš„å¤§é‡åƒµå°¸è¿›ç¨‹å ç”¨ç³»ç»Ÿèµ„æºã€‚ kernel.threads-maxï¼šè¿™ä¸ªå‚æ•°ç”¨äºé™åˆ¶ç³»ç»Ÿä¸­å¯ä»¥åˆ›å»ºçš„æœ€å¤§çº¿ç¨‹æ•°é‡ã€‚çº¿ç¨‹æ•°é‡çš„é™åˆ¶å¯ä»¥é˜²æ­¢è¿‡å¤šçš„çº¿ç¨‹å¯¼è‡´ç³»ç»Ÿèµ„æºè€—å°½ã€‚ net.core.somaxconnï¼šè¿™ä¸ªå‚æ•°ç”¨äºè®¾ç½®ç³»ç»Ÿä¸­æœ€å¤§çš„å·²å®Œæˆè¿æ¥é˜Ÿåˆ—é•¿åº¦ã€‚è¿™ä¸ªé™åˆ¶å¯ä»¥ä¿éšœåœ¨é«˜å¹¶å‘ç½‘ç»œæœåŠ¡åœºæ™¯ä¸‹ï¼Œç³»ç»Ÿèƒ½å¤Ÿåœ¨èµ„æºæœ‰é™çš„æƒ…å†µä¸‹å¤„ç†è¿æ¥è¯·æ±‚ã€‚ fs.file-maxï¼šè¿™ä¸ªå‚æ•°ç”¨äºé™åˆ¶ç³»ç»Ÿä¸­å¯ä»¥æ‰“å¼€çš„æœ€å¤§æ–‡ä»¶æè¿°ç¬¦æ•°é‡ã€‚è¿™ä¸ªé™åˆ¶å¯ä»¥é˜²æ­¢è¿‡å¤šçš„æ–‡ä»¶æè¿°ç¬¦å¯¼è‡´å†…æ ¸èµ„æºè€—å°½ã€‚ è¿™äº›sysctlå‚æ•°é€šå¸¸å¯ä»¥åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶é€šè¿‡é…ç½®æ–‡ä»¶è®¾ç½®ï¼Œä¹Ÿå¯ä»¥åœ¨è¿è¡Œæ—¶é€šè¿‡å‘½ä»¤è¡Œå·¥å…·sysctlè¿›è¡ŒåŠ¨æ€è°ƒæ•´ã€‚è¿™ä¸ºç®¡ç†å‘˜å’Œå¼€å‘è€…æä¾›äº†ä¸€ç§çµæ´»çš„æ–¹å¼æ¥ä¼˜åŒ–ç³»ç»Ÿæ€§èƒ½å’Œèµ„æºåˆ†é…ã€‚ seccompseccompï¼ˆsecure computing modeï¼Œå®‰å…¨è®¡ç®—æ¨¡å¼ï¼‰æ˜¯ä¸€ç§Linuxå†…æ ¸å®‰å…¨ç‰¹æ€§ï¼Œå…è®¸åœ¨ç”¨æˆ·ç©ºé—´çš„è¿›ç¨‹å°†å…¶å¯ç”¨çš„ç³»ç»Ÿè°ƒç”¨ï¼ˆsyscallsï¼‰é™åˆ¶ä¸ºä¸€ä¸ªæœ€å°çš„é›†åˆã€‚è¿™æ ·åšå¯ä»¥é™ä½è¿›ç¨‹è¢«æ”»å‡»è€…åˆ©ç”¨çš„é£é™©ï¼Œå› ä¸ºæ”»å‡»è€…å¯ä»¥ä½¿ç”¨çš„ç³»ç»Ÿè°ƒç”¨å‡å°‘äº†ã€‚seccompåœ¨å®¹å™¨ã€æ²™ç®±å’Œå…¶ä»–é«˜åº¦å®‰å…¨çš„ç¯å¢ƒä¸­éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå®ƒå¯ä»¥é™åˆ¶æ½œåœ¨çš„æ”»å‡»é¢ã€‚ seccompçš„å·¥ä½œåŸç†æ˜¯å…è®¸è¿›ç¨‹å®šä¹‰ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ç™½åå•ï¼Œåªæœ‰åœ¨è¿™ä¸ªç™½åå•ä¸Šçš„ç³»ç»Ÿè°ƒç”¨æ‰èƒ½è¢«è¿›ç¨‹æ‰§è¡Œã€‚å½“è¿›ç¨‹è¯•å›¾æ‰§è¡Œä¸åœ¨ç™½åå•ä¸Šçš„ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå†…æ ¸ä¼šé˜»æ­¢è¿›ç¨‹ï¼Œå¹¶æ ¹æ®seccompçš„é…ç½®æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚è¿™äº›æ“ä½œå¯èƒ½åŒ…æ‹¬ï¼šç»ˆæ­¢è¿›ç¨‹ã€å‘è¿›ç¨‹å‘é€ä¿¡å·æˆ–è€…è¿”å›ä¸€ä¸ªé”™è¯¯ç ã€‚ ä¸ºäº†ä½¿ç”¨seccompï¼Œè¿›ç¨‹éœ€è¦ä½¿ç”¨prctlç³»ç»Ÿè°ƒç”¨å¯ç”¨seccompæ¨¡å¼ã€‚æ¥ç€ï¼Œè¿›ç¨‹å¯ä»¥é€šè¿‡seccompç³»ç»Ÿè°ƒç”¨å®šä¹‰ä¸€ä¸ªè¿‡æ»¤å™¨ï¼ˆé€šå¸¸æ˜¯ä¸€ä¸ªBPFï¼ˆBerkeley Packet Filterï¼‰ç¨‹åºï¼‰ï¼Œç”¨äºæ£€æŸ¥ç³»ç»Ÿè°ƒç”¨çš„ç¼–å·ï¼Œå¹¶æ ¹æ®ç™½åå•æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„seccompç¤ºä¾‹ï¼Œæ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨seccompé™åˆ¶ä¸€ä¸ªè¿›ç¨‹åªèƒ½è°ƒç”¨readã€writeã€exitå’Œrt_sigreturnç³»ç»Ÿè°ƒç”¨ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/audit.h&gt;#include &lt;sys/syscall.h&gt;#define ALLOW_SYSCALL(syscall_nr) \\ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall_nr, 0, 1), \\ BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)int main() &#123; // å®šä¹‰seccompè¿‡æ»¤å™¨ struct sock_filter filter[] = &#123; // æ£€æŸ¥æ¶æ„æ˜¯å¦æ­£ç¡® BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, arch)), BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, AUDIT_ARCH_X86_64, 1, 0), BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), // åŠ è½½ç³»ç»Ÿè°ƒç”¨ç¼–å· BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, nr)), // å…è®¸ç™½åå•ä¸Šçš„ç³»ç»Ÿè°ƒç”¨ ALLOW_SYSCALL(__NR_read), ALLOW_SYSCALL(__NR_write), ALLOW_SYSCALL(__NR_exit), ALLOW_SYSCALL(__NR_rt_sigreturn), // ä¸å…è®¸çš„ç³»ç»Ÿè°ƒç”¨å°†å¯¼è‡´è¿›ç¨‹è¢«ç»ˆæ­¢ BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), &#125;; // å®šä¹‰seccompè¿‡æ»¤å™¨çš„å…ƒæ•°æ® struct sock_fprog prog = &#123; .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])), .filter = filter, &#125;; // å¯ç”¨seccompæ¨¡å¼ if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) &lt; 0) &#123; perror(&quot;prctl&quot;); return 1; &#125; // åœ¨æ­¤å¤„æ‰§è¡Œæ‚¨çš„ç¨‹åºé€»è¾‘ // å¦‚æœå°è¯•æ‰§è¡Œä¸åœ¨ç™½åå•ä¸Šçš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¿›ç¨‹å°†è¢«ç»ˆæ­¢ return 0;&#125; è¯·æ³¨æ„ï¼Œè¿™ä¸ªç¤ºä¾‹ä½¿ç”¨çš„æ˜¯seccompçš„BPFè¿‡æ»¤å™¨ï¼Œè¯¥è¿‡æ»¤å™¨æä¾›äº†ä¸€ç§çµæ´»çš„æ–¹å¼æ¥æ§åˆ¶ç³»ç»Ÿè°ƒç”¨ã€‚è¿™ç§æ–¹æ³•åœ¨å®¹å™¨å’Œæ²™ç®±ç¯å¢ƒä¸­éå¸¸æœ‰ç”¨ï¼Œå› ä¸ºå®ƒå¯ä»¥é’ˆå¯¹ç‰¹å®šåº”ç”¨ç¨‹åºçš„éœ€æ±‚å®šåˆ¶ç³»ç»Ÿè°ƒç”¨çš„é™åˆ¶ã€‚ç„¶è€Œï¼Œç¼–å†™BPFè¿‡æ»¤å™¨å¯èƒ½ç›¸å¯¹å¤æ‚ï¼Œå› æ­¤åœ¨å®è·µä¸­ï¼Œè®¸å¤šå¼€å‘è€…é€‰æ‹©ä½¿ç”¨åƒlibseccompè¿™æ ·çš„åº“æ¥ç®€ åŒ–seccompè¿‡æ»¤å™¨çš„åˆ›å»ºå’Œç®¡ç†ã€‚ ä»¥ä¸‹æ˜¯ä½¿ç”¨libseccompåº“çš„ç¤ºä¾‹ï¼Œå®ç°ä¸å‰é¢ç›¸åŒçš„åŠŸèƒ½ï¼š 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;int main() &#123; // åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„seccompä¸Šä¸‹æ–‡ scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (!ctx) &#123; perror(&quot;seccomp_init&quot;); return 1; &#125; // å‘è¿‡æ»¤å™¨ä¸­æ·»åŠ å…è®¸çš„ç³»ç»Ÿè°ƒç”¨ if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0) &lt; 0) &#123; perror(&quot;seccomp_rule_add&quot;); seccomp_release(ctx); return 1; &#125; // å°†è¿‡æ»¤å™¨åŠ è½½åˆ°å†…æ ¸ä¸­ if (seccomp_load(ctx) &lt; 0) &#123; perror(&quot;seccomp_load&quot;); seccomp_release(ctx); return 1; &#125; // é‡Šæ”¾èµ„æº seccomp_release(ctx); // åœ¨æ­¤å¤„æ‰§è¡Œæ‚¨çš„ç¨‹åºé€»è¾‘ // å¦‚æœå°è¯•æ‰§è¡Œä¸åœ¨ç™½åå•ä¸Šçš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¿›ç¨‹å°†è¢«ç»ˆæ­¢ return 0;&#125; è¿™ä¸ªç¤ºä¾‹ä½¿ç”¨äº†libseccompåº“æä¾›çš„APIï¼Œä½¿å¾—åˆ›å»ºå’Œç®¡ç†seccompè¿‡æ»¤å™¨æ›´åŠ ç®€å•ã€‚åªéœ€é€šè¿‡seccomp_initåˆå§‹åŒ–ä¸€ä¸ªæ–°çš„ä¸Šä¸‹æ–‡ï¼Œä½¿ç”¨seccomp_rule_addæ·»åŠ å…è®¸çš„ç³»ç»Ÿè°ƒç”¨ï¼Œç„¶åä½¿ç”¨seccomp_loadå°†è¿‡æ»¤å™¨åŠ è½½åˆ°å†…æ ¸ä¸­ã€‚æœ€åï¼Œä½¿ç”¨seccomp_releaseé‡Šæ”¾èµ„æºã€‚ æ€»ä¹‹ï¼Œseccompæ˜¯ä¸€ç§åœ¨Linuxå†…æ ¸ä¸­å®ç°å®‰å…¨è®¡ç®—æ¨¡å¼çš„æœºåˆ¶ï¼Œå®ƒå…è®¸è¿›ç¨‹é™åˆ¶å…¶å¯ç”¨çš„ç³»ç»Ÿè°ƒç”¨é›†ï¼Œä»è€Œé™ä½æ½œåœ¨çš„æ”»å‡»é¢ã€‚åœ¨å®¹å™¨ã€æ²™ç›’å’Œå…¶ä»–é«˜åº¦å®‰å…¨çš„ç¯å¢ƒä¸­ï¼Œseccompéå¸¸æœ‰ç”¨ã€‚ä½¿ç”¨BPFè¿‡æ»¤å™¨æˆ–ç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚libseccompï¼‰å¯ä»¥å¸®åŠ©å¼€å‘è€…æ›´è½»æ¾åœ°åˆ›å»ºå’Œç®¡ç†seccompè¿‡æ»¤å™¨ã€‚ inodeinodeæ˜¯ä»€ä¹ˆåœ¨æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œinodeï¼ˆç´¢å¼•èŠ‚ç‚¹ï¼‰æ˜¯ä¸€ç§æ•°æ®ç»“æ„ï¼Œç”¨äºå­˜å‚¨æœ‰å…³æ–‡ä»¶å’Œç›®å½•çš„å…ƒæ•°æ®ï¼ˆå¦‚æƒé™ã€å¤§å°ã€åˆ›å»ºæ—¶é—´ç­‰ï¼‰ï¼Œä½†ä¸åŒ…æ‹¬æ–‡ä»¶åå’Œå®é™…æ–‡ä»¶æ•°æ®ã€‚æ¯ä¸ªæ–‡ä»¶æˆ–ç›®å½•åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„inodeï¼Œå®ƒä»¬é€šè¿‡inodeå·è¿›è¡Œè¯†åˆ«ã€‚ä¸åŒçš„æ–‡ä»¶ç³»ç»Ÿç±»å‹ï¼ˆå¦‚ext4ã€XFSã€Btrfsç­‰ï¼‰å¯èƒ½ä¼šæœ‰ä¸åŒçš„inodeå®ç°ï¼Œä½†å…¶åŸºæœ¬æ¦‚å¿µæ˜¯ç›¸åŒçš„ã€‚ ä»¥ä¸‹æ˜¯inodeå¯èƒ½åŒ…å«çš„ä¸€äº›å…ƒæ•°æ®ä¿¡æ¯ï¼š æ–‡ä»¶ç±»å‹ï¼ˆæ™®é€šæ–‡ä»¶ã€ç›®å½•ã€ç¬¦å·é“¾æ¥ç­‰ï¼‰ æ–‡ä»¶å¤§å° æ–‡ä»¶çš„æƒé™ï¼ˆè¯»ã€å†™ã€æ‰§è¡Œï¼‰ æ–‡ä»¶çš„æ‰€æœ‰è€…å’Œæ‰€å±ç»„ åˆ›å»ºã€ä¿®æ”¹å’Œè®¿é—®æ—¶é—´æˆ³ æ–‡ä»¶æ•°æ®æ‰€åœ¨çš„ç£ç›˜å—çš„ä½ç½® ç°åœ¨è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„Pythonè„šæœ¬ç¤ºä¾‹æ¥å±•ç¤ºå¦‚ä½•è·å–æ–‡ä»¶çš„inodeä¿¡æ¯ï¼š 1234567891011121314151617import osfile_path = &quot;example.txt&quot;# è·å–æ–‡ä»¶çš„ inode ä¿¡æ¯file_stat = os.stat(file_path)# æ‰“å°è¯¦ç»†çš„ inode ä¿¡æ¯print(f&quot;File path: &#123;file_path&#125;&quot;)print(f&quot;Inode number: &#123;file_stat.st_ino&#125;&quot;)print(f&quot;File size: &#123;file_stat.st_size&#125; bytes&quot;)print(f&quot;File owner: &#123;file_stat.st_uid&#125;&quot;)print(f&quot;File group: &#123;file_stat.st_gid&#125;&quot;)print(f&quot;File permissions: &#123;oct(file_stat.st_mode)[-4:]&#125;&quot;)print(f&quot;File creation time: &#123;file_stat.st_ctime&#125;&quot;)print(f&quot;File modification time: &#123;file_stat.st_mtime&#125;&quot;)print(f&quot;File access time: &#123;file_stat.st_atime&#125;&quot;) åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡os.stat()å‡½æ•°è·å–äº†æŒ‡å®šæ–‡ä»¶è·¯å¾„çš„inodeä¿¡æ¯ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä»è¿”å›çš„os.stat_resultå¯¹è±¡ä¸­è·å–å„ç§inodeå…ƒæ•°æ®ï¼Œå¦‚æ–‡ä»¶å¤§å°ã€æ‰€æœ‰è€…ã€æƒé™ç­‰ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ­¤ç¤ºä¾‹ä»…é€‚ç”¨äºç±»Unixç³»ç»Ÿï¼ˆå¦‚Linuxå’ŒmacOSï¼‰ã€‚åœ¨Windowsç³»ç»Ÿä¸Šï¼Œæ–‡ä»¶å…ƒæ•°æ®çš„ç®¡ç†æ–¹å¼ä¸inodeæœ‰æ‰€ä¸åŒã€‚å¯ä»¥ä½¿ç”¨Pythonçš„osæ¨¡å—çš„å…¶ä»–å‡½æ•°ï¼Œå¦‚os.path.getsize()å’Œos.path.getctime()ç­‰ï¼Œæ¥è·å–Windowsç³»ç»Ÿä¸Šçš„æ–‡ä»¶å…ƒæ•°æ®ã€‚ inodeæ”»å‡»inodeæ”»å‡»æ˜¯ä¸€ç§èµ„æºè€—å°½æ”»å‡»ï¼Œå…¶ç›®æ ‡æ˜¯è€—å°½æ–‡ä»¶ç³»ç»Ÿä¸­å¯ç”¨çš„inodeã€‚åœ¨è¿™ç§æ”»å‡»ä¸­ï¼Œæ”»å‡»è€…ä¼šåœ¨å—å®³è€…å®¹å™¨ä¸­ä¸æ–­åˆ›å»ºæ–°æ–‡ä»¶æˆ–ç›®å½•ï¼Œä»è€Œåˆ†é…å¤§é‡çš„inodeç»“æ„ã€‚ç”±äºLinuxå†…æ ¸æ²¡æœ‰é’ˆå¯¹inodeçš„cgroupéš”ç¦»ï¼Œè¿™ç§æ”»å‡»ä¼šå½±å“æ•´ä¸ªåˆ†åŒºï¼Œå¯¼è‡´åˆ†åŒºä¸Šçš„æ‰€æœ‰inodeéƒ½è¢«è€—å°½ã€‚ å½“inodeè€—å°½æ—¶ï¼Œä»»ä½•è¯•å›¾åˆ›å»ºæ–°æ–‡ä»¶æˆ–ç›®å½•çš„æ“ä½œéƒ½ä¼šå¤±è´¥ï¼Œæ— è®ºè¿™äº›æ“ä½œæ¥è‡ªå—å®³è€…å®¹å™¨è¿˜æ˜¯ä¸»æœºã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå—å®³è€…å®¹å™¨å¯èƒ½ä¼šè¢«é©±é€ï¼Œè€Œä¸»æœºä¹Ÿä¸èƒ½åˆ›å»ºä»»ä½•æ–°æ–‡ä»¶ã€‚é˜¿é‡Œäº‘å®¹å™¨æœåŠ¡å®¹æ˜“å—åˆ°inodeæ”»å‡»çš„å½±å“ã€‚ ä¸ºäº†é˜²å¾¡inodeæ”»å‡»ï¼Œå¯ä»¥è€ƒè™‘ä»¥ä¸‹æ–¹æ³•ï¼š é™åˆ¶å®¹å™¨çš„å­˜å‚¨ä½¿ç”¨ï¼šä¸ºå®¹å™¨è®¾ç½®å­˜å‚¨é…é¢ï¼Œä»¥é™åˆ¶æ¯ä¸ªå®¹å™¨å¯ä»¥ä½¿ç”¨çš„å­˜å‚¨ç©ºé—´ã€‚è¿™å¯ä»¥é˜²æ­¢æ”»å‡»è€…è€—å°½æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿçš„inodeã€‚ ç›‘æ§inodeä½¿ç”¨æƒ…å†µï¼šå®šæœŸæ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿçš„inodeä½¿ç”¨æƒ…å†µï¼Œä»¥ä¾¿åœ¨inodeå¿«é€Ÿè€—å°½æ—¶å‘ç°æ½œåœ¨çš„æ”»å‡»ã€‚ è®¾ç½®è­¦æŠ¥å’Œè‡ªåŠ¨å“åº”ï¼šåœ¨inodeä½¿ç”¨è¾¾åˆ°ä¸´ç•Œå€¼æ—¶è®¾ç½®è­¦æŠ¥ï¼Œå¹¶å®æ–½è‡ªåŠ¨å“åº”æªæ–½ï¼Œä¾‹å¦‚é™åˆ¶æˆ–éš”ç¦»å¯ç–‘å®¹å™¨ã€‚ è¿è¡Œæ—¶éš”ç¦»ï¼šä½¿ç”¨æ›´é«˜çº§åˆ«çš„è¿è¡Œæ—¶éš”ç¦»æŠ€æœ¯ï¼Œå¦‚gVisoræˆ–Kata Containersï¼Œä»¥æä¾›æ›´å¼ºå¤§çš„å®‰å…¨éš”ç¦»ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œé˜²å¾¡inodeæ”»å‡»çš„æ–¹æ³•å¯èƒ½ä¼šå¯¹æ€§èƒ½äº§ç”Ÿå½±å“ï¼Œå› æ­¤åœ¨å®æ–½è¿™äº›æªæ–½æ—¶éœ€è¦æƒè¡¡å®‰å…¨æ€§å’Œæ€§èƒ½ã€‚ netns_ct-&gt;countæ”»å‡»ä¸€ç§é’ˆå¯¹ Linux å†…æ ¸ä¸­çš„è¿æ¥è·Ÿè¸ªåŠŸèƒ½ï¼ˆNetfilterï¼‰çš„æ”»å‡»ï¼Œè¯¥æ”»å‡»æ¶‰åŠåˆ°åˆ©ç”¨ netns_ct-&gt;count è®¡æ•°æ¥æ¶ˆè€—ä¸»æœºå’Œå®¹å™¨çš„ç½‘ç»œèµ„æºã€‚è¿™ç§æ”»å‡»é€šå¸¸è¢«ç§°ä¸ºè¿æ¥æ¶ˆè€—æ”»å‡»ï¼ˆConnection Exhaustion Attackï¼‰æˆ–èµ„æºè€—å°½æ”»å‡»ï¼ˆResource Exhaustion Attackï¼‰ã€‚ æ”»å‡»åŸç†æ¦‚è¿°å¦‚ä¸‹ï¼š æ”»å‡»è€…åœ¨å®¹å™¨å†…äº§ç”Ÿå¤§é‡çš„ TCP è¿æ¥ï¼Œè¿™äº›è¿æ¥ä¼šè¢«è·Ÿè¸ªã€‚ å°½ç®¡è¿™äº›å®¹å™¨ä½äºä¸åŒçš„ç½‘ç»œå‘½åç©ºé—´ï¼ˆnet namespaceï¼‰ä¸­ï¼Œä½†å®ƒä»¬çš„æ‰€æœ‰è¿æ¥éƒ½éœ€è¦ä½¿ç”¨ä¸»æœºçš„ init_net.ct è®¡æ•°ã€‚ å½“æ”»å‡»è€…åœ¨çŸ­æ—¶é—´å†…äº§ç”Ÿå¤§é‡è¿æ¥æ—¶ï¼Œä¼šæ¶ˆè€—æ‰ä¸»æœºçš„ init_net.ct è®¡æ•°é…é¢ã€‚ ä¸€æ—¦é…é¢è€—å°½ï¼ŒNetfilter åŠŸèƒ½å°†å—åˆ°å½±å“ï¼Œå¯èƒ½å¯¼è‡´éšæœºä¸¢åŒ…ç­‰é—®é¢˜ã€‚ è¦é˜²èŒƒè¿™ç§æ”»å‡»ï¼Œå¯ä»¥é‡‡å–ä»¥ä¸‹æªæ–½ï¼š é™åˆ¶å®¹å™¨çš„è¿æ¥æ•°ï¼šä¸ºæ¯ä¸ªå®¹å™¨è®¾ç½®è¿æ¥æ•°é™åˆ¶ï¼Œä»¥é˜²æ­¢å•ä¸ªå®¹å™¨è€—å°½ä¸»æœºçš„è¿æ¥èµ„æºã€‚ é™åˆ¶è¿æ¥é€Ÿç‡ï¼šä½¿ç”¨ Netfilter çš„ iptables å·¥å…·é™åˆ¶å®¹å™¨çš„è¿æ¥é€Ÿç‡ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥è®¾ç½®æ¯ç§’æœ€å¤šå…è®¸çš„æ–°è¿æ¥æ•°ï¼Œä»è€Œé˜²æ­¢æ”»å‡»è€…åœ¨çŸ­æ—¶é—´å†…äº§ç”Ÿå¤§é‡è¿æ¥ã€‚ éš”ç¦»ç½‘ç»œå‘½åç©ºé—´ï¼šåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯ä»¥ä¸ºæ¯ä¸ªå®¹å™¨æä¾›ç‹¬ç«‹çš„ç½‘ç»œå‘½åç©ºé—´ï¼Œä»¥é™ä½èµ„æºäº‰ç”¨çš„å¯èƒ½æ€§ã€‚ç„¶è€Œï¼Œè¿™ç§æ–¹æ³•å¯èƒ½ä¼šå¢åŠ èµ„æºæ¶ˆè€—å’Œç®¡ç†å¤æ‚æ€§ã€‚ ç›‘æ§å’ŒæŠ¥è­¦ï¼šå®æ–½å®æ—¶ç½‘ç»œè¿æ¥ç›‘æ§ï¼Œä»¥ä¾¿åœ¨æ”»å‡»å‘ç”Ÿæ—¶è¿…é€Ÿæ£€æµ‹å¹¶é‡‡å–ç›¸åº”æªæ–½ã€‚ é€šè¿‡å®æ–½è¿™äº›é˜²èŒƒæªæ–½ï¼Œå¯ä»¥é™ä½å®¹å™¨å’Œä¸»æœºå—åˆ° netns_ct-&gt;count æ”»å‡»çš„é£é™©ã€‚ gVisorgVisor æ˜¯ä¸€ä¸ªå¼€æºçš„æ²™ç®±è¿è¡Œæ—¶ï¼Œç”±è°·æ­Œå¼€å‘ï¼Œç”¨äºä¸ºå®¹å™¨æä¾›éš”ç¦»å’Œå®‰å…¨æ€§ã€‚gVisor ä¸»è¦ç›®æ ‡æ˜¯ä¸ºå®¹å™¨æä¾›æ›´é«˜çº§åˆ«çš„å®‰å…¨æ€§ï¼ŒåŒæ—¶ä¿æŒæ¥è¿‘åŸç”Ÿå®¹å™¨çš„æ€§èƒ½ã€‚å®ƒåœ¨å®¹å™¨ä¸å®¿ä¸»æœºä¹‹é—´å¢åŠ äº†ä¸€ä¸ªç”¨æˆ·ç©ºé—´å†…æ ¸ï¼Œä»è€Œé™åˆ¶å®¹å™¨å¯¹å®¿ä¸»æœºå†…æ ¸çš„è®¿é—®ã€‚è¿™ç§æ–¹æ³•é™ä½äº†æ½œåœ¨å®‰å…¨æ¼æ´å¯¹æ•´ä¸ªç³»ç»Ÿçš„å½±å“ã€‚ gVisor çš„æ ¸å¿ƒç»„ä»¶æ˜¯åä¸º â€œSentryâ€ çš„ç”¨æˆ·ç©ºé—´å†…æ ¸ï¼Œå®ƒæ‹¦æˆªå’Œå¤„ç†æ¥è‡ªå®¹å™¨çš„ç³»ç»Ÿè°ƒç”¨ã€‚Sentry ä¸ºæ¯ä¸ªå®¹å™¨æä¾›äº†ä¸€ä¸ªç‹¬ç«‹çš„å†…æ ¸å®ä¾‹ï¼Œä»è€Œé™åˆ¶å®¹å™¨ä¹‹é—´çš„ç›¸äº’å½±å“ã€‚æ­¤å¤–ï¼ŒgVisor è¿˜åŒ…æ‹¬ä¸€ä¸ªåä¸º â€œGoferâ€ çš„æ–‡ä»¶ç³»ç»Ÿä»£ç†ï¼Œç”¨äºå°†å®¹å™¨çš„æ–‡ä»¶ç³»ç»Ÿæ“ä½œè½¬å‘åˆ°å®¿ä¸»æœºã€‚ gVisor ä¸ Docker å’Œ Kubernetes ç­‰å®¹å™¨è¿è¡Œæ—¶ç¯å¢ƒå…¼å®¹ï¼Œå¯ä»¥è½»æ¾é›†æˆåˆ°ç°æœ‰çš„å®¹å™¨éƒ¨ç½²ä¸­ã€‚ä¸ºäº†åœ¨ Docker ä¸­ä½¿ç”¨ gVisorï¼Œæ‚¨éœ€è¦å®‰è£… gVisor å¹¶å°†å…¶é…ç½®ä¸º Docker çš„è¿è¡Œæ—¶ã€‚ä»¥ä¸‹æ˜¯åœ¨ Docker ä¸­ä½¿ç”¨ gVisor çš„ç¤ºä¾‹ï¼š é¦–å…ˆï¼Œå®‰è£… gVisorï¼š 12345wget https://storage.googleapis.com/gvisor/releases/nightly/latest/runscwget https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc.sha512sha512sum -c runsc.sha512chmod a+x runscsudo mv runsc /usr/local/bin é…ç½® Docker ä½¿ç”¨ gVisorï¼š 12345678910sudo mkdir -p /etc/dockerecho &#x27;&#123; &quot;runtimes&quot;: &#123; &quot;runsc&quot;: &#123; &quot;path&quot;: &quot;/usr/local/bin/runsc&quot;, &quot;runtimeArgs&quot;: [&quot;--platform=ptrace&quot;] &#125; &#125;&#125;&#x27; | sudo tee /etc/docker/daemon.jsonsudo systemctl restart docker è¿è¡Œä¸€ä¸ªä½¿ç”¨ gVisor çš„ Docker å®¹å™¨ï¼š 1docker run --runtime=runsc -it alpine sh è¿™å°†å¯åŠ¨ä¸€ä¸ªä½¿ç”¨ gVisor ä½œä¸ºæ²™ç®±è¿è¡Œæ—¶çš„æ–°å®¹å™¨ã€‚é€šè¿‡ä½¿ç”¨ gVisorï¼Œæ‚¨å¯ä»¥æé«˜å®¹å™¨çš„å®‰å…¨æ€§ï¼Œé™ä½æ½œåœ¨å®‰å…¨æ¼æ´å¯¹æ•´ä¸ªç³»ç»Ÿçš„å½±å“ã€‚ç„¶è€Œï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒgVisor å¯èƒ½ä¼šå¸¦æ¥ä¸€å®šçš„æ€§èƒ½æŸå¤±ï¼Œå› æ­¤åœ¨å®é™…åº”ç”¨ä¸­éœ€è¦æƒè¡¡å®‰å…¨æ€§å’Œæ€§èƒ½ã€‚ Per-user quota restrictionsPer-user quota restrictions æ˜¯ä¸€ç§åœ¨æ–‡ä»¶ç³»ç»Ÿå±‚é¢è®¾ç½®çš„èµ„æºé™åˆ¶æ–¹æ³•ï¼Œç”¨äºæ§åˆ¶æ¯ä¸ªç”¨æˆ·æ‰€èƒ½ä½¿ç”¨çš„ç£ç›˜ç©ºé—´å’Œæ–‡ä»¶æ•°é‡ã€‚è¿™ç§é™åˆ¶æ–¹æ³•é€šå¸¸ç”¨äºå¤šç”¨æˆ·å…±äº«åŒä¸€ç³»ç»Ÿèµ„æºçš„ç¯å¢ƒï¼Œå¦‚å…±äº«ä¸»æœºæˆ–æœåŠ¡å™¨ï¼Œä»¥é˜²æ­¢å•ä¸ªç”¨æˆ·å ç”¨è¿‡å¤šçš„ç£ç›˜ç©ºé—´æˆ–æ–‡ä»¶æ•°é‡ï¼Œä»è€Œå¯¼è‡´å…¶ä»–ç”¨æˆ·æ— æ³•æ­£å¸¸ä½¿ç”¨ç³»ç»Ÿèµ„æºã€‚ Per-user quota restrictions ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹ä¸¤ç§ç±»å‹ï¼š ç£ç›˜ç©ºé—´é™åˆ¶ï¼ˆBlock Quotasï¼‰ï¼šè¯¥é™åˆ¶ç”¨äºé™åˆ¶æ¯ä¸ªç”¨æˆ·æ‰€èƒ½ä½¿ç”¨çš„ç£ç›˜ç©ºé—´ã€‚ç³»ç»Ÿç®¡ç†å‘˜å¯ä»¥ä¸ºæ¯ä¸ªç”¨æˆ·åˆ†é…ä¸€å®šé‡çš„ç£ç›˜ç©ºé—´ï¼Œå½“ç”¨æˆ·è¾¾åˆ°åˆ†é…çš„ç£ç›˜ç©ºé—´ä¸Šé™æ—¶ï¼Œå°†æ— æ³•ç»§ç»­å†™å…¥æˆ–åˆ›å»ºæ–°æ–‡ä»¶ã€‚ æ–‡ä»¶æ•°é‡é™åˆ¶ï¼ˆInode Quotasï¼‰ï¼šè¯¥é™åˆ¶ç”¨äºé™åˆ¶æ¯ä¸ªç”¨æˆ·æ‰€èƒ½åˆ›å»ºçš„æ–‡ä»¶æ•°é‡ã€‚ç³»ç»Ÿç®¡ç†å‘˜å¯ä»¥ä¸ºæ¯ä¸ªç”¨æˆ·åˆ†é…ä¸€å®šæ•°é‡çš„æ–‡ä»¶ï¼ˆæˆ–ç›®å½•ï¼‰åˆ›å»ºæƒé™ï¼Œå½“ç”¨æˆ·è¾¾åˆ°åˆ†é…çš„æ–‡ä»¶æ•°é‡ä¸Šé™æ—¶ï¼Œå°†æ— æ³•ç»§ç»­åˆ›å»ºæ–°æ–‡ä»¶æˆ–ç›®å½•ã€‚ åœ¨ Linux ç³»ç»Ÿä¸­ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ­¥éª¤è®¾ç½® per-user quota restrictionsï¼š å®‰è£… quota å·¥å…·ï¼š 1sudo apt-get install quota quotatool åœ¨ /etc/fstab æ–‡ä»¶ä¸­å¯ç”¨ç”¨æˆ·é…é¢ã€‚ä¾‹å¦‚ï¼Œä¸º /home åˆ†åŒºå¯ç”¨ç”¨æˆ·é…é¢ï¼Œå¯ä»¥å°†ä»¥ä¸‹å†…å®¹æ·»åŠ åˆ° /etc/fstab æ–‡ä»¶ï¼š 1/dev/sda1 /home ext4 defaults,usrquota,grpquota 0 0 é‡æ–°æŒ‚è½½åˆ†åŒºä»¥åº”ç”¨æ›´æ”¹ï¼š 1sudo mount -o remount /home åˆå§‹åŒ–é…é¢æ–‡ä»¶ï¼š 1sudo quotacheck -cug /home ä¸ºç‰¹å®šç”¨æˆ·è®¾ç½®é…é¢é™åˆ¶ã€‚ä¾‹å¦‚ï¼Œä¸ºç”¨æˆ· exampleuser è®¾ç½® 100MB çš„ç£ç›˜ç©ºé—´é™åˆ¶å’Œ 1000 ä¸ªæ–‡ä»¶æ•°é‡é™åˆ¶ï¼š 1sudo setquota -u exampleuser 100000 110000 1000 1100 /home ä½¿ç”¨ quota å‘½ä»¤æŸ¥çœ‹ç”¨æˆ·é…é¢æƒ…å†µï¼š 1quota -u exampleuser é€šè¿‡å®æ–½ per-user quota restrictionsï¼Œç³»ç»Ÿç®¡ç†å‘˜å¯ä»¥ç¡®ä¿ç³»ç»Ÿèµ„æºåœ¨ç”¨æˆ·ä¹‹é—´å…¬å¹³åœ°åˆ†é…ï¼Œé˜²æ­¢å•ä¸ªç”¨æˆ·è¿‡åº¦ä½¿ç”¨èµ„æºã€‚","categories":[{"name":"è®ºæ–‡ç²¾è¯»","slug":"è®ºæ–‡ç²¾è¯»","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"å†…æ ¸å®‰å…¨","slug":"è®ºæ–‡ç²¾è¯»/å†…æ ¸å®‰å…¨","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"äº‘å®‰å…¨","slug":"äº‘å®‰å…¨","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"ã€Šç†æƒ³å›½ã€‹æŸæ‹‰å›¾ é˜…è¯»","slug":"ã€Šç†æƒ³å›½ã€‹æŸæ‹‰å›¾ é˜…è¯»","date":"2023-03-29T03:09:42.000Z","updated":"2023-04-09T13:41:12.250Z","comments":true,"path":"2023/03/29/ã€Šç†æƒ³å›½ã€‹æŸæ‹‰å›¾ é˜…è¯»/","link":"","permalink":"http://example.com/2023/03/29/%E3%80%8A%E7%90%86%E6%83%B3%E5%9B%BD%E3%80%8B%E6%9F%8F%E6%8B%89%E5%9B%BE%20%E9%98%85%E8%AF%BB/","excerpt":"å‰è¨€ ã€Šç†æƒ³å›½ã€‹ä½œä¸ºä¸€æœ¬å¿…è¯»çš„å“²å­¦ç»å…¸ï¼Œæ˜¯æŸæ‹‰å›¾åœ¨æ€æƒ³æˆç†Ÿæ—¶æœŸæ‰€è‘—ï¼ŒåŒ…å«äº†å¤å¸Œè…Šå½“æ—¶ä¸ªä¸ªæ–¹é¢çš„é—®é¢˜ï¼ŒåŒ…æ‹¬å“²å­¦ã€æ•™è‚²ã€å†›äº‹ã€æ”¿æ²»ã€ä¼¦ç†ã€æ–‡è‰ºã€è¯—æ­Œç­‰ç­‰ã€‚æŸæ‹‰å›¾ä¸€æ­¥æ­¥æ„å»ºå‡ºç†å¿µä¸–ç•Œï¼Œå¹¶å€Ÿè‹æ ¼æ‹‰åº•ä¹‹å£è®¨è®ºäº†å“²å­¦ä¸­çš„ä¸€äº›é‡è¦é—®é¢˜ï¼Œè‹æ ¼æ‹‰åº•è¿ç”¨â€œè¾©è¯æ³•â€ä¸€æ­¥æ­¥è®©å¯¹æ–¹å‘ç°è‡ªèº«è§‚ç‚¹çš„çŸ›ç›¾ä¹‹å¤„ï¼Œå¯ä»¥è¯´æ˜¯å‹è¿«æ„Ÿæå¼ºï¼Œç”šè‡³è¯´æ˜¯é˜´é˜³æ€ªæ°”ã€‚å†è¯»ã€Šç†æƒ³å›½ã€‹ï¼Œæ„åœ¨è®©è‡ªå·±æµ…è–„çš„æ€æƒ³èƒ½å¾—åˆ°å‡åã€‚æœ¬äººå¸Œæœ›é€šè¿‡é˜…è¯»æ€»ç»“ä¹¦ä¸­çš„æ€æƒ³ï¼Œå¯èƒ½ç”±äºæ—¶ä»£çš„å±€é™æ€§ï¼ŒæŸäº›æ€æƒ³åœ¨ç°åœ¨çœ‹æ¥å¯èƒ½å·²ç»è¿‡æ—¶å¹¶ä¸”ä¸å¤Ÿå®Œå–„ï¼Œä½†æ˜¯æˆ‘ä»¬ä¹Ÿä¾ç„¶å¯ä»¥ä»ä¸­æ±²å–æ™ºæ…§ä¸ºè‡ªå·±çš„æ€æƒ³æ‰€ç”¨ã€‚ è´¢äº§ æ­£ä¹‰ èŠ‚åˆ¶","text":"å‰è¨€ ã€Šç†æƒ³å›½ã€‹ä½œä¸ºä¸€æœ¬å¿…è¯»çš„å“²å­¦ç»å…¸ï¼Œæ˜¯æŸæ‹‰å›¾åœ¨æ€æƒ³æˆç†Ÿæ—¶æœŸæ‰€è‘—ï¼ŒåŒ…å«äº†å¤å¸Œè…Šå½“æ—¶ä¸ªä¸ªæ–¹é¢çš„é—®é¢˜ï¼ŒåŒ…æ‹¬å“²å­¦ã€æ•™è‚²ã€å†›äº‹ã€æ”¿æ²»ã€ä¼¦ç†ã€æ–‡è‰ºã€è¯—æ­Œç­‰ç­‰ã€‚æŸæ‹‰å›¾ä¸€æ­¥æ­¥æ„å»ºå‡ºç†å¿µä¸–ç•Œï¼Œå¹¶å€Ÿè‹æ ¼æ‹‰åº•ä¹‹å£è®¨è®ºäº†å“²å­¦ä¸­çš„ä¸€äº›é‡è¦é—®é¢˜ï¼Œè‹æ ¼æ‹‰åº•è¿ç”¨â€œè¾©è¯æ³•â€ä¸€æ­¥æ­¥è®©å¯¹æ–¹å‘ç°è‡ªèº«è§‚ç‚¹çš„çŸ›ç›¾ä¹‹å¤„ï¼Œå¯ä»¥è¯´æ˜¯å‹è¿«æ„Ÿæå¼ºï¼Œç”šè‡³è¯´æ˜¯é˜´é˜³æ€ªæ°”ã€‚å†è¯»ã€Šç†æƒ³å›½ã€‹ï¼Œæ„åœ¨è®©è‡ªå·±æµ…è–„çš„æ€æƒ³èƒ½å¾—åˆ°å‡åã€‚æœ¬äººå¸Œæœ›é€šè¿‡é˜…è¯»æ€»ç»“ä¹¦ä¸­çš„æ€æƒ³ï¼Œå¯èƒ½ç”±äºæ—¶ä»£çš„å±€é™æ€§ï¼ŒæŸäº›æ€æƒ³åœ¨ç°åœ¨çœ‹æ¥å¯èƒ½å·²ç»è¿‡æ—¶å¹¶ä¸”ä¸å¤Ÿå®Œå–„ï¼Œä½†æ˜¯æˆ‘ä»¬ä¹Ÿä¾ç„¶å¯ä»¥ä»ä¸­æ±²å–æ™ºæ…§ä¸ºè‡ªå·±çš„æ€æƒ³æ‰€ç”¨ã€‚ è´¢äº§ æ­£ä¹‰ èŠ‚åˆ¶å¼€ç¯‡ä»¥è‹æ ¼æ‹‰åº•å’Œèµ›å¼—æ‹‰çš„å¯¹è¯å¼€å§‹ï¼Œè‹æ ¼æ‹‰åº•ä»å¹´é•¿è€…çš„é—®é¢˜å…¥æ‰‹ï¼Œé€æ­¥å¼•å‡ºè´¢äº§ï¼Œæ­£ä¹‰çš„è®¨è®ºï¼Œå¹¶ä¸€æ­¥æ­¥è¿›è¡Œäº†è®ºè¯ï¼Œåé©³äº†å½“æ—¶æµè¡Œçš„è§‚ç‚¹ã€‚ å½“ä¸€ä¸ªäººå¯¹è‚‰ä½“ä¸Šçš„äº«å—è¶Šæ¥è¶Šå°‘æ—¶ï¼Œé‚£ä»–å¯¹ç²¾ç¥ä¸Šçš„ç•…è°ˆä¹Ÿå°±è¦æ±‚è¶Šå¤šã€‚ æˆ‘å‘æ¥è®¤ä¸ºå¹´é•¿çš„äººå°±åƒå·²ç»ç¿»è¶Šåƒå±±ä¸‡æ°´çš„è€æ—…å®¢ï¼Œä½ ä»¬æ›¾ç»é‡åˆ°çš„åå·ä¹Ÿå¯èƒ½æ˜¯æˆ‘ä¹‹åè¦ç»å†çš„ï¼Œæ‰€ä»¥æˆ‘å¯¹äºè¿‡æ¥äººååˆ†æ„¿æ„ä¸ä»–ä»¬æ¢è®¨ä¸€ä¸‹æ—…é€”ä¸­çš„è‰°éš¾é™©é˜»ã€‚ äººåœ¨è€å¹´é˜¶æ®µæ˜¯å¦ä¼šæ›´è‰°éš¾ï¼Ÿå¤§éƒ¨åˆ†äººåœ¨å¹´è€æ—¶å¯¹å¹´è€çš„æŠ±æ€¨ï¼Œåœ¨äºä¸èƒ½åƒä»¥å‰ä¸€æ ·åƒå–ç©ä¹ã€æˆ–æ˜¯ä½“éªŒçˆ±æƒ…çš„å¿«ä¹ã€æˆ–æ˜¯ç¾å¥½çš„äº‹ç‰©å·²æˆè¿‡å¾€ï¼Œæœ‰äººåŸ‹æ€¨è‡³äº²å¥½å‹çš„å¿½è§†ï¼Œæœ‰äººåŸ‹æ€¨å¹´è€æ˜¯ç—›è‹¦çš„æ ¹æºã€‚èµ›å¼—æ‹‰è®²è„±ç¦»æ‰€è°“çš„æƒ…çˆ±æ¯”å–»æˆä»ä¸€ä¸ªæš´å›å¤„è„±ç¦»è‹¦æµ·ï¼Œåˆ°äº†è€å¹´æ—¶ä»£ï¼Œå¯¹äºæƒ…çˆ±ä¸€äº‹æ—©å·²æ²¡äº†å…´è¶£ï¼Œäººå·²ç»æ¸…å¿ƒå¯¡æ¬²ï¼Œæœ‰äº†å¦ä¸€ç§è‡ªç”±å¿«ä¹çš„æ„Ÿå—ã€‚ èµ›å¼—æ‹‰ä»æ­¤å…¥æ‰‹ï¼Œè®ºè¯å¹´è€æ—¶ä¹‹æ‰€ä»¥ä¼šæŠ±æ€¨è¿è¿ï¼Œä¸æ˜¯å› ä¸ºå¹´çºªï¼Œè€Œæ˜¯æ€§æƒ…ã€‚å¦‚æœä¸€ä¸ªäººæ€§æƒ…æ˜¯æ¬é™çš„ã€å¿ƒå¹³æ°”å’Œçš„ï¼Œé‚£ä¹ˆå¹´é¾„å¤§å¹¶ä¸æ˜¯ç—›è‹¦ï¼Œå¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆä¸ç®¡ä»€ä¹ˆå¹´é¾„éƒ½ä¼šæ˜¯ç—›è‹¦çš„ã€‚ è‹æ ¼æ‹‰åº•æ•…æ„æ¿€èµ›å¼—æ‹‰ç»§ç»­å›ç­”ï¼Œè‹æ ¼æ‹‰åº•è¯„ä»·èµ›å¼—æ‹‰æ˜¯å› ä¸ºå®¶è´¢ä¸‡è´¯è€Œä¸æ˜¯å› ä¸ºæ€§æƒ…æ¬é™ï¼Œæ‰€ä»¥è€å¹´æ—¶æ‰ä¼šå¿«ä¹ï¼Œä¹‹åå¼•å‡ºè´¢å¯Œçš„é—®é¢˜ã€‚ ä½ ä»è´¢å¯Œä¸Šå¾—åˆ°äº†ä»€ä¹ˆï¼Ÿ è‡ªå·±èµšé’±çš„äººä¸ä»…å› ä¸ºé’±æœ‰ç”¨æ‰å–œæ¬¢å®ƒï¼Œè€Œæ›´æ˜¯å› ä¸ºè¿™æ˜¯ä»–ä»¬è¾›è‹¦å¾—æ¥çš„ï¼Œå†…å¿ƒç”Ÿå‡ºäº†ä¸€ç§å¼ºçƒˆçš„å æœ‰æ¬²ï¼Œå°±åƒè¯—äººçˆ±è‡ªå·±çš„è¯—ç¯‡ï¼Œçˆ¶æ¯ç–¼çˆ±è‡ªå·±çš„å„¿å¥³ä¸€æ ·ã€‚æˆ‘çœ‹åˆ°è¿™ç§äººï¼Œå°±è§‰å¾—ä»–ä»¬å¾ˆè®¨åŒï¼Œä»–ä»¬è¯´çš„å†…å®¹ä¸å¤–ä¹æ˜¯èµç¾é‡‘é’±ä¹‹ç±»çš„ã€‚ äººä»è´¢å¯Œä¸­è·å¾—çš„æœ€å¤§çš„å¥½å¤„å°±æ˜¯ï¼Œåœ¨èµšå–è´¢å¯Œæ—¶çš„é—®å¿ƒæ— æ„§ï¼Œæ²¡æœ‰ææ…Œå’Œå¿§è™‘ã€‚åœ¨äººå¿«æ­»äº¡çš„æ—¶å€™ï¼Œä¼šæœ‰ä¸€ç§ææ…Œå’Œå¿§è™‘ï¼Œæ‹…å¿ƒæ¥ä¸–å—åˆ°æƒ©ç½šã€‚å¦‚æœä¸€ä¸ªäººçŸ¥é“è‡ªå·±é€ å­½é¢‡æ·±ï¼Œå°±ä¼šè¿‡åº¦æ‚²è§‚ï¼ŒæƒŠæä¸‡åˆ†ï¼Œè€Œé—®å¿ƒæ— æ„§çš„äººï¼Œä¾¿ä¼šå¿ƒä¸­å¦ç„¶ã€‚ æ­£ä¹‰æ˜¯ä»€ä¹ˆï¼Ÿæœ‰è¯å®è¯´ã€æ¬ å€ºè¿˜å€ºæ˜¯å¦æ­£ä¹‰ï¼Ÿä¸æ˜¯æ­£ä¹‰ï¼Œè¿™ä¸ªè§‚ç‚¹æ˜¯æ—¥å¸¸ç”Ÿæ´»ä¸­æŸä¸ªæƒ…å½¢ä¸‹çš„æ­£ä¹‰è¡Œä¸ºï¼Œå¹¶ä¸æ˜¯æ­£ä¹‰çš„å®šä¹‰ã€‚å¦‚æœå¦‚æ­¤å®šä¹‰æ­£ä¹‰ï¼Œä¾¿ä¼šé€ æˆæœ‰æ—¶æ˜¯æ­£ä¹‰çš„ï¼Œæœ‰æ—¶ä¸æ˜¯æ­£ä¹‰çš„æƒ…å½¢ã€‚ æŸæ‹‰å›¾å€Ÿè‹æ ¼æ‹‰åº•ä¹‹å£ä¸¾ä¾‹ï¼š ä½ æœ‰ä¸ªæœ‹å‹åœ¨å¤´è„‘æ¸…æ¥šçš„æ—¶å€™ï¼Œæ›¾ç»æŠŠæ­¦å™¨äº¤ç»™ä½ ï¼Œå‡å¦‚ä»–åæ¥ç–¯äº†ï¼Œå†è¦å›å»ï¼Œä»»ä½•äººéƒ½ä¼šè¯´ä¸èƒ½è¿˜ç»™ä»–ï¼Œå¦‚æœä½ è¿˜ç»™ä»–ï¼Œè¿™æ˜¯ä¸æ­£ä¹‰çš„è¡Œä¸ºã€‚ æŠŠæ•´ä¸ªçœŸå®æƒ…å†µå‘Šè¯‰ç–¯å­ä¸æ˜¯æ­£ä¹‰ã€‚ å¦‚æœå€ºä¸»æ˜¯æ•Œäººï¼Œè¿˜å€ºæ˜¯å¯¹ä»–çš„å¸®åŠ©ï¼Œåˆ™è¿˜å€ºä¸æ˜¯æ­£ä¹‰ã€‚ å³å½“æœ‰è¯å®è¯´æˆ–è€…æ¬ å€ºè¿˜å€ºçš„å¯¹è±¡ä¸åŒæ—¶ï¼Œæ ¹æ®ä¸åŒæƒ…å†µï¼Œè¿™ç§è¡Œä¸ºä¹Ÿæœ‰å¯èƒ½æ˜¯ä¸æ­£ä¹‰çš„ã€‚è‹æ ¼æ‹‰åº•å¸Œæœ›æ‰¾åˆ°ä¸€ç§æ™®éçš„æ­£ä¹‰ï¼Œæˆ‘ä»¬æƒ³è¦çœ‹ä¸€ç§è¡Œä¸ºæ˜¯å¦æ˜¯æ­£ä¹‰çš„ï¼Œä¸èƒ½å…‰ä»è‡ªèº«çš„ç«‹åœºå‡ºå‘ï¼Œè¿˜è¦ä»æˆ‘ä»¬çš„å¯¹è±¡èƒ½å¦æ”¶ç›Šæ¥æ£€éªŒæˆ‘ä»¬çš„è¡Œä¸ºæ˜¯å¦æ˜¯æœ‰åˆ©äºå¯¹æ–¹çš„ï¼Œè¿˜è¦åˆ¤æ–­æ”¶ç›Šçš„å¯¹è±¡ã€‚ æŠŠå–„ç»™äºˆå‹äººï¼ŒæŠŠæ¶ç»™äºˆæ•Œäººæ˜¯å¦æ­£ä¹‰ï¼ŸæŠŠå–„ç»™äºˆå‹äººï¼šåŒ»ç”ŸæŠŠåŒ»æœ¯ç»™äºˆç—…äººï¼Œèˆµæ‰‹åœ¨èˆªæµ·é‡åˆ°é£æ€¥æµªé™©æ—¶ç»´æŠ¤èˆ¹èˆ¶çš„å®‰å…¨ã€‚ æŠŠæ¶ç»™äºˆæ•Œäººï¼šåœ¨æˆ˜äº‰ä¸­ä¸ç›Ÿå‹æ”»æ•Œã€‚ è‹æ ¼æ‹‰åº•è®ºè¯ï¼Œåœ¨ä¸ç”Ÿç—…çš„æ—¶å€™ï¼ŒåŒ»ç”Ÿæ˜¯æ²¡æœ‰ç”¨å¤„çš„ï¼Œåœ¨äººä»¬ä¸èˆªæµ·çš„æ—¶å€™ï¼Œèˆµæ‰‹æ˜¯æ²¡æœ‰ç”¨å¤„çš„ï¼Œåœ¨ä¸æ‰“ä»—çš„æ—¶å€™ï¼Œæ­£ä¹‰è€…æ˜¯æ²¡æœ‰ç”¨å¤„çš„ã€‚è€Œæ­£ä¹‰åœ¨ä¸è®ºä»»ä½•æ—¶å€™éƒ½æ˜¯æœ‰ç”¨å¤„çš„ã€‚å†œååœ¨ç§ç”°æ—¶æœ‰ç”¨å¤„ï¼Œé‹åŒ åœ¨é€ é‹æ—¶æœ‰ç”¨å¤„ï¼Œä½†æ˜¯é‹åŒ å’Œå†œæ°‘ä¸æ˜¯æ­£ä¹‰è€…ã€‚ é‚£ä¹ˆåœ¨å¹³æ—¶ä»€ä¹ˆäº‹æƒ…ä¸Šå¿…é¡»æœ‰æ­£ä¹‰ï¼Ÿå¤šäººåˆä½œå…³ç³»ï¼Œä¾‹å¦‚è®¢åˆåŒã€ç«‹å¥‘çº¦ç­‰ç­‰ã€‚ä¸‹æ£‹èƒ½æ‰‹å’Œæ­£ä¹‰è€…åœ¨ä¸‹æ£‹æ—¶ï¼Œä¸‹æ£‹èƒ½æ‰‹æ›´æœ‰ç”¨å¤„ï¼Œç“¦åŒ å’Œæ­£ä¹‰è€…åœ¨ç Œç –ç›–ç“¦å»ºå±‹æ—¶ï¼Œç“¦åŒ æ›´æœ‰ç”¨å¤„ï¼Œç´å¸ˆå’Œæ­£ä¹‰è€…åœ¨å¥ä¹æ—¶ï¼Œç´å¸ˆæ›´æœ‰ç”¨å¤„ï¼Œå› æ­¤æœ‰ç”¨è€…å¹¶ä¸ç­‰äºæ­£ä¹‰è€…ã€‚è¿™è¯´æ˜è¿™æ ·çš„æ­£ä¹‰å®šä¹‰å¤ªè¿‡ç‹­çª„ã€‚ äº‹å®ä¸Šæ°æ°ç›¸åï¼Œä¸€ä¸ªæ­£ä¹‰çš„äººå’Œæ”¿åºœéƒ½æ˜¯åœ¨å¹³æ—¶å°±èƒ½åšå¾—å¾ˆå¥½æ‰èƒ½ä¿æŒè‡ªå·±å’Œå›½å®¶çš„ä¹…å®‰ã€‚åœ¨æ¶‰åŠåˆ°é‡‘é’±æ—¶ï¼ŒèŠ±é’±ä¸ä¿ç®¡é’±ï¼ŒåŒæ ·éƒ½æœ‰æ¯”æ­£ä¹‰è€…æ›´æœ‰ç”¨å¤„çš„è§’è‰²å­˜åœ¨ã€‚ ä»¥æ­¤ç±»æ¨ï¼Œå¦‚æœä¸€ä»¶äº‹ç‰©æœ‰ç”¨ï¼Œé‚£ä¹ˆæ­£ä¹‰å°±æ²¡ç”¨ï¼Œæ­£ä¹‰æœ‰ç”¨ï¼Œé‚£ä¹ˆè¿™ä»¶äº‹ç‰©å°±æ²¡ç”¨ã€‚æ˜¯åœ¨å¹³æ—¶å°±èƒ½åšå¾—å¾ˆå¥½æ‰èƒ½ä¿æŒè‡ªå·±å’Œå›½å®¶çš„ä¹…å®‰ã€‚å¦‚æœè¯´æ­£ä¹‰å¹³æ—¶ä¹Ÿæœ‰ç”¨æ¯”å¦‚åœ¨æ›¿æœ‹å‹ä¿ç®¡é’±è´¢æ–¹é¢åšåˆ°ä»¥å–„å¾…å‹ï¼Œé‚£ä¹ˆå°±ä¼šå¾—å‡ºé’±è´¢ä¸ç”¨æ—¶æ­£ä¹‰æœ‰ç”¨ï¼Œä¸€æ—¦é’±è´¢è¢«ä½¿ç”¨äº†æ­£ä¹‰åè€Œæ— ç”¨äº†ã€‚æœ€åæ­£ä¹‰è¿˜è¦æ±‚â€œä»¥æ¶å¯¹æ•Œâ€è¿™æ˜¯ä¸æ˜¯æ„è°“ç€è¿˜è¦æ›¿æœ‹å‹å»æ å–æ•Œäººçš„ä¸œè¥¿å‘¢ï¼Ÿè¿™æ ·æ­£ä¹‰ä¹‹ä¸¾ä¸å°±æˆäº†å°å·è¡Œä¸ºäº†å—ï¼Ÿè¿™æ ·çš„é©³éš¾çœ‹ä¼¼è’å”ï¼Œå…¶å®æ­£å¥½æ­éœ²å‡ºäº†è¿™ä¸ªå®šä¹‰æœ¬èº«æ‰€åŒ…å«çš„å†…åœ¨çŸ›ç›¾ã€‚ è€Œæ ¹æ®å‘½é¢˜çš„å®šä¹‰ï¼Œæˆ‘ä»¬æœ‰æ—¶ä¹Ÿä¼šæ··æ·†æœ‹å‹å’Œæ•Œäººï¼Œæ‰€è°“çš„æœ‹å‹æ˜¯é‚£äº›çœ‹ä¸Šå»å¥½çš„äººè¿˜æ˜¯å®é™…ä¸ŠçœŸæ­£å¥½çš„äººå‘¢ï¼Ÿä½ æ‰€è°“çš„æ•Œäººæ˜¯çœ‹ä¸Šå»åçš„äººè¿˜æ˜¯é‚£äº›çœ‹ä¸Šå»ä¸åä½†æ˜¯çœŸçš„åäººå‘¢ã€‚å¦‚æœå¼„é”™äº†ï¼Œä¾¿ä¼šå¯¼è‡´å¸®åŠ©åäººï¼Œå¯¹æŠ—å¥½äººã€‚è¿™ä¸ªä¹Ÿå¼•å‡ºå–„æ¶çš„é—®é¢˜ï¼ŒæŸæ‹‰å›¾åœ¨ä¹‹åä¹Ÿå€Ÿè‹æ ¼æ‹‰åº•ä¹‹å£å¯¹æ­¤è¿›è¡Œäº†è®ºè¯ã€‚ æ ¹æ®è®¨è®ºè¿›ä¸€æ­¥å®Œå–„å®šä¹‰ï¼ŒçœŸæ­£å–„è‰¯çš„æœ‹å‹ï¼ŒæŠ¥ä¹‹ä»¥å–„ï¼ŒçœŸæ­£é‚ªæ¶çš„æ•Œäººï¼ŒæŠ¥ä¹‹ä»¥æ¶ï¼Œæ‰æ˜¯æ­£ä¹‰ã€‚è¿™ä¸ªå®šä¹‰ä¼¼ä¹æ›´æ¥è¿‘çœŸç†ä¸€äº›äº†ã€‚ä½†æ˜¯è€ƒè™‘å¦‚ä¸‹ä¾‹å­ï¼šæ­£ä¹‰çš„äººæ˜¯å¦å¯ä»¥ä¼¤å®³ä»–äººå‘¢ï¼Ÿä¼¤å®³ä»–äººæ˜¯ä¸€ä»¶æ¶äº‹ï¼Œæ­£ä¹‰ä¹‹äººä¸€å®šæ˜¯å–„äººï¼ŒåŸºäºæ­¤ï¼Œå¹¶è€ƒè™‘å¦‚ä¸‹ä¾‹å­ï¼šå–„äºéª‘é©¬çš„äººèƒ½å¤Ÿå‡­å€Ÿå…¶èµ·ç çš„æŠ€èƒ½è®©äººä¸ä¼šéª‘é©¬å—ï¼ŸéŸ³ä¹å®¶èƒ½å¤Ÿå‡­å€Ÿå…¶éŸ³ä¹ä¸Šçš„æŠ€èƒ½ä½¿äººä¸æ‡‚éŸ³ä¹å—ï¼Ÿæ­£ä¹‰è€…èƒ½ä»¥ä»–çš„æ­£ä¹‰ä½¿äººåšä¸æ­£ä¹‰çš„äº‹æƒ…å—ï¼Ÿæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ­£ä¹‰è€…ä½œä¸ºä¸€ä¸ªå–„äººä¸åº”è¯¥åšä¼¤å®³ä»–äººçš„æ¶äº‹ã€‚ æ‰€ä»¥æ ¹æ®ä¸Šè¿°çš„è®¨è®ºï¼Œæ­£ä¹‰å¹¶éæ˜¯æŠŠå–„ç»™äºˆå‹äººï¼ŒæŠŠæ¶ç»™äºˆæ•Œäººã€‚ æ­£ä¹‰å°±æ˜¯å¼ºè€…çš„åˆ©ç›Šæ­£ä¹‰å°±æ˜¯å¼ºè€…çš„åˆ©ç›Šï¼ŒåŒºåˆ«äºä¸Šè¿°åˆ¤æ–­æ”¶ç›Šçš„å¯¹è±¡ä»¥åŠå¯¹äºå‹äººçš„åˆ©ç›Šï¼Œè¿™ä¸ªå‘½é¢˜è®¤ä¸ºæ­£ä¹‰æ˜¯å¼ºè€…çš„åˆ©ç›Šï¼Œæ‰€ä»¥é¦–å…ˆè¦æ˜ç¡®çš„æ˜¯ä½•ä¸ºâ€å¼ºè€…â€œã€‚å¦‚æœåªæ˜¯å› ä¸ºåƒçš„æ¯”åˆ«äººå¥½è€Œæ¯”åˆ«äººå¼ºå£®ï¼Œè¿™å¹¶ä¸æ˜¯å¼ºè€…ï¼Œæˆ‘ä»¬é€šå¸¸æåˆ°å¼ºè€…ï¼Œé¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯ç»Ÿæ²»è€…ï¼Œåˆ¶å®šæ³•å¾‹çš„äººï¼Œè¿åæ³•å¾‹çš„äººå°±æ˜¯ä¸æ­£ä¹‰ä¹‹äººï¼Œè€Œå¯¹äºæ”¿åºœæœ‰åˆ©çš„ç™¾å§“å°±æ˜¯æ­£ä¹‰ã€‚å› æ­¤ï¼Œæœ‰äººè®¤ä¸ºï¼Œæ‰€è°“æ­£ä¹‰å°±æ˜¯å½“æ—¶æ”¿åºœçš„åˆ©ç›Šï¼Œæ­£ä¹‰å°±æ˜¯å¼ºè€…çš„åˆ©ç›Šã€‚ è‹æ ¼æ‹‰åº•å¯¹æ­¤è¿›è¡Œäº†åé©³ã€‚ æ”¿åºœä¸æ˜¯ç»å¯¹ä¸ä¼šå‡ºé”™çš„ï¼Œå¦‚æœæ²»ç†å¾—å½“ï¼Œé‚£ä¹ˆä»–ä»¬æ‰€ç«‹çš„æ³•å°±æ˜¯åŸºäºæ”¿åºœçš„åˆ©ç›Šçš„ï¼Œè€Œæ²»ç†å‡ºç°é—®é¢˜ï¼Œå°±ä¼šä¸æ”¿åºœçš„åˆ©ç›Šè¿èƒŒï¼Œæ­¤æ—¶è¿˜æ˜¯æ­£ä¹‰çš„å—ï¼Ÿå¦‚æœæ˜¯æ­£ä¹‰çš„ä¾¿ä¼šå¾—åˆ°ï¼Œå³ä½¿ä¸æ”¿åºœçš„åˆ©ç›Šè¿èƒŒï¼Œäººæ°‘ä¾æ—§éœ€è¦æœä»ï¼Œè¿™ä»ç„¶æ˜¯æ­£ä¹‰ã€‚ä½†æ˜¯å¦‚æœå¼±è€…æœä»äº†ï¼Œå®é™…ä¸Šæ˜¯æŸå®³äº†å¼ºè€…çš„åˆ©ç›Šï¼Œå› æ­¤ä¸å‘½é¢˜ç›¸è¿èƒŒã€‚ å¦‚æœå¼ºè€…çš„åˆ©ç›ŠæŒ‡çš„æ˜¯å¼ºè€…å®é™…ä¸Šçš„åˆ©ç›Šè€Œä¸æ˜¯å¼ºè€…å¿ƒä¸­è®¤ä¸ºçš„åˆ©ç›Šï¼Œå¹¶ä¸”æ˜¯åŸºäºä¸¥æ ¼æ„ä¹‰ä¸Šçš„å¼ºè€…ï¼Œå³ä¸ä¼šçŠ¯é”™è¯¯çš„å¼ºè€…ã€‚ è‹æ ¼æ‹‰åº•åšå‡ºäº†ä¸€ä¸ªæ¯”å–»ï¼Œå¦‚æœè¯´æŠ€è‰ºæ˜¯å®Œç¾çš„ï¼Œå¦‚æœæŠ€è‰ºæ˜¯ä¸å®Œç¾çš„ï¼Œä¾‹å¦‚äººçš„èº«ä½“ä¸å®Œå¤‡çš„æ—¶å€™ï¼Œéœ€è¦åŒ»æœ¯æ¥å¼¥è¡¥ï¼ŒåŒ»æœ¯ä¸å®Œå¤‡çš„æ—¶å€™ï¼Œéœ€è¦å…¶ä»–çš„æŠ€è‰ºæ¥å¼¥è¡¥ã€‚å‡è®¾æŠ€è‰ºåœ¨ä¸¥æ ¼æ„ä¹‰ä¸Šæ˜¯å®Œç¾çš„ä¸éœ€è¦å…¶ä»–ä»»ä½•æ–¹å¼å¼¥è¡¥çš„è¯ï¼Œé‚£ä¹ˆåŒ»ç”Ÿå°±ä¸ä¼šè€ƒè™‘è‡ªèº«åŒ»æœ¯çš„åˆ©ç›Šï¼Œè€Œä¼šè€ƒè™‘ç—…äººçš„åˆ©ç›Šï¼Œéª‘é©¬è€…ä¸ä¼šè€ƒè™‘éª‘æœ¯çš„åˆ©ç›Šï¼Œè€Œä¼šè€ƒè™‘é©¬çš„åˆ©ç›Šã€‚ä»¥æ­¤ç±»æ¨ï¼ŒæŠ€è‰ºæœ¬èº«æ˜¯æ²¡æœ‰é”™è¯¯çš„ï¼Œå› æ­¤ä»–æ‹…å¿ƒçš„ä¾¿æ˜¯å¯¹è±¡çš„åˆ©ç›Šï¼Œå› ä¸ºä»»ä½•æŠ€è‰ºéƒ½æ˜¯ä¸ºå…¶å¯¹è±¡æœåŠ¡çš„ã€‚é‚£ä¹ˆä¸ä¼šçŠ¯é”™çš„å¼ºè€…å¯ä»¥æ¯”å–»æˆå®Œç¾çš„æŠ€è‰ºï¼Œç™¾å§“å¯ä»¥æ¯”å–»æˆæŠ€è‰ºæ‰€æœåŠ¡çš„å¯¹è±¡ã€‚é‚£ä¹ˆä¸€ä¸ªç»Ÿæ²»è€…æ›´å¤šé¡¾åŠçš„ä¾¿æ˜¯å—ç»Ÿæ²»è€…çš„åˆ©ç›Šè€Œä¸æ˜¯è‡ªèº«çš„åˆ©ç›Šï¼Œå°±åƒå®Œç¾çš„æŠ€è‰ºæ˜¯ä¸ºå®ƒçš„å¯¹è±¡æœåŠ¡çš„ã€‚å³åå®ç›¸ç¬¦çš„ç»Ÿæ²»è€…ä¼šå§‹ç»ˆä»¥äººæ°‘çš„åˆ©ç›Šä¸ºå‰æï¼Œè€Œä¸æ˜¯ä»¥è‡ªå·±çš„åˆ©ç›Šä¸ºå‰æã€‚ ä¸æ­£ä¹‰æ¯”æ­£ä¹‰æ›´æœ‰ç›Šæœ‰äººè®¤ä¸ºæ­£ä¹‰å’Œæ­£ä¹‰è€…ä¼šç™½ç™½ç»™å‡ºåˆ©ç›Šï¼Œæ¢è¨€ä¹‹ï¼Œæ­£ä¹‰æ„å‘³ç€å¼ºè€…å’Œç»Ÿæ²»è€…å¾—åˆ°åˆ©ç›Šï¼Œè€Œå¼±è€…å’Œè¢«ç»Ÿæ²»è€…å¤±å»åˆ©ç›Šã€‚ä¸æ­£ä¹‰ä¸ä¹‹ç›¸åã€‚ä¾‹å¦‚ä¸“åˆ¶å›ä¸»çš„æš´æ”¿ã€‚ æ ¹æ®è‹æ ¼æ‹‰åº•åœ¨ä¸Šæ–‡çš„è¯æ˜ï¼Œä¸€ä¸ªåå®ç›¸ç¬¦çš„ç»Ÿæ²»è€…ï¼Œæ— è®ºä»€ä¹ˆäº‹éƒ½æ˜¯ä»¥è¢«ç»Ÿæ²»è€…çš„åˆ©ç›Šä¸ºç›®çš„ã€‚ æ¯ç§æŠ€è‰ºé™¤äº†æ™®é€šçš„åˆ©ç›Šä¹‹å¤–ï¼Œåº”è¯¥è¦ç»™äººä»¥ç‰¹æ®Šçš„åˆ©ç›Šï¼Œæ¯”å¦‚åŒ»æœ¯ç»™äººä»¥å¥åº·çš„åˆ©ç›Šï¼Œèˆªæµ·ä¹‹æœ¯ç»™äººä»¥å®‰æ¸¡å¤§æµ·çš„åˆ©ç›Šã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒæŠ€è‰ºåº”å½“è¿˜æœ‰ç‰¹æ®Šçš„åŠŸç”¨ï¼Œè€Œè¿™ç§åŠŸç”¨ä¸èƒ½ä¸å…¶ä»–æŠ€è‰ºçš„åŠŸç”¨ç›¸æ··åˆã€‚æ¯ç§æŠ€è‰ºçš„åˆ©ç›Šéƒ½ä¸èƒ½ä¸å…¶ä»–çš„æŠ€è‰ºæ··ä¸ºä¸€è°ˆï¼Œé™¤äº†å®ƒè‡ªèº«çš„ç‰¹æ®ŠåŠŸç”¨å¤–ï¼Œå…·æœ‰åŒä¸€åŠŸç”¨çš„æŠ€è‰ºä¹‹é—´å¿…å®šæœ‰åŒä¸€åˆ©ç›Šåœ¨å…¶ä¸­ï¼Œé‚£ä¹ˆæŠ€è‰ºè€…æ‰€å¾—åˆ°å¾—æŠ¥é…¬ï¼Œåº”è¯¥æ˜¯æŠ€è‰ºæ‰€é™„å¸¦çš„åˆ©ç›Šï¼Œè€Œä¸æ˜¯æŠ€è‰ºæœ¬èº«çš„åˆ©ç›Šã€‚æŠ¥é…¬ä¸å„ç§æŠ€è‰ºæœ‰è¿å¸¦å…³ç³»ï¼Œè€ŒæŒæ¡æŠ€è‰ºé¥¿äººåªè¦å„å°½æ‰€èƒ½ï¼Œä¾¿å¯ä»¥æ–½åˆ©äºäººï¼ŒæŠ¥é…¬è‡ªç„¶åœ¨å…¶ä¸­ã€‚å‡¡æ˜¯çœŸæ­£çš„æŠ€è‰ºå®¶ï¼Œå½“ä»–å·¥ä½œçš„æ—¶å€™æˆ–æŒ‡æŒ¥ä»–äººçš„æ—¶å€™ï¼Œæ˜¯ä»¥ä»–äººçš„åˆ©ç›Šä¸ºä¸­å¿ƒçš„ï¼Œè€Œä¸åº”è¯¥æºæ‚è‡ªå·±çš„ç§æ¬²ã€‚å·¥ä½œæ²¡æœ‰ç›¸å½“çš„æŠ¥é…¬æ˜¯æ²¡æœ‰äººæ„¿æ„å°½åŠ›è€Œä¸ºçš„ã€‚æ‰€ä»¥ï¼Œç»Ÿæ²»è€…æˆ–æ²»ç†è€…çš„å·¥ä½œä¹Ÿå¿…é¡»æœ‰æŠ¥é…¬ï¼Œä»–ä»¬æ‰ä¼šå°½å¿ƒä¸ºäººæ°‘æœåŠ¡ã€‚ä»–ä»¬çš„æŠ¥é…¬æœ‰ä¸‰ç§ï¼šé‡‘é’±ã€è£èª‰ä¸ä¸æ„¿æ‰¿æ‹…è´£ä»»çš„æƒ©ç½šã€‚ é‡‘é’±å’Œè£èª‰å¯ä»¥ç†è§£ï¼Œè€Œæƒ©ç½šæ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿæƒ©ç½šå¦‚ä½•èƒ½ä½œä¸ºæŠ¥é…¬ï¼Ÿ å¯¹äºé«˜å°šçš„äººï¼Œåä¸åˆ©éƒ½ä¸èƒ½ä½¿ä¹‹åŠ¨å¿ƒã€‚ä»–ä»¬ä¸æ„¿æ„ä¸ºæ‹¿æŠ¥é…¬å»åšäº‹ï¼Œè¢«äººå½“ä½£äººçœ‹å¾…ï¼Œæ›´ä¸æ„¿æ„ä»¥é˜´è°‹çš„æ‰‹æ®µï¼Œå‡å…¬æµç§ï¼Œè¢«äººå½“å¼ºç›—çœ‹å¾…ã€‚å› æ­¤ï¼Œåªèƒ½ç”¨æŸæ¯ä»–ä»¬é«˜æ´çš„åèŠ‚æ¥æƒ©ç½šä»–ä»¬ï¼Œè¿«ä½¿ä»–ä»¬ä¸å¾—ä¸å‡ºæ¥åšäº‹ã€‚ä¹Ÿæ­£å› ä¸ºè¿™ä¸ªç¼˜æ•…ï¼Œé‚£äº›æ€¥äºåšå®˜çš„äººå—åˆ°è½»è§†ï¼Œè€Œé‚£äº›è¢«é€¼å‡ºæ¥åšå®˜çš„äººåˆ™æ„Ÿå—åˆ°è«å¤§çš„å°Šè£ã€‚è¿™ç§æƒ©ç½šä¹‹æ‰€ä»¥æœ€æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºå¦‚æœä»–ä»¬ä¸å‡ºæ¥ï¼Œå°±ç”¨ä¸å¦‚ä»–ä»¬çš„äººæ¥ç®¡ç†ä»–ä»¬çš„ç”Ÿæ´»å’Œè¡Œä¸ºã€‚å› æ­¤ï¼Œè¿™äº›äººå‡ºæ¥åšå®˜å¹¶ä¸æ˜¯å› ä¸ºä»–ä»¬æœ‰è¿™ä¸ªå¿—å‘ï¼Œä¹Ÿä¸æ˜¯è¿™é‡Œé¢æœ‰ä»€ä¹ˆå¯è´ªå›¾çš„ï¼Œè€Œæ˜¯å› ä¸ºä¸€æ—¶æ²¡æœ‰æ¯”ä»–ä»¬æ›´å¥½çš„äººæˆ–èƒ½åŠ›ç›¸åŒçš„äººã€‚æ‰€ä»¥ï¼Œå¯¹ä»–ä»¬æ¥è¯´ï¼Œåšå®˜å®åœ¨æ˜¯åˆ€æ¶åœ¨è„–å­ä¸Šï¼Œè¿«ä¸å¾—å·²çš„äº‹ã€‚å‡å¦‚ä¸€ä¸ªå›½å®¶éƒ½æ˜¯é«˜å°šçš„äººï¼Œé‚£ä¹ˆä¸æƒ³åšå®˜çš„è‚¯å®šä¸ä¼šæ¯”ä»Šæ—¥æƒ³è¦åšå®˜çš„å°‘ã€‚å› æ­¤ï¼ŒçœŸæ­£çš„ç»Ÿæ²»æ˜¯è¦ç»™ä»–äººä»¥åˆ©ç›Šï¼Œè€Œä¸æ˜¯ç»™è‡ªå·±ä»¥åˆ©ç›Šã€‚å¦‚æ­¤ï¼Œé‚£ä¹ˆæœ‰è°ä¼šä¸æ„¿æ„è¢«ç»Ÿæ²»ï¼Œæ¥å—ä»–äººçš„åˆ©ç›Šå‘¢ï¼Ÿæœ‰è°ä¼šæ„¿æ„åšç»Ÿæ²»è€…ï¼Œä¸“é—¨ç»™ä»–äººä»¥åˆ©ç›Šå‘¢ï¼Ÿæ‰€ä»¥ï¼Œä¸å¾—ä¸ä»¥æƒ©ç½šçš„æ‰‹æ®µè¿«ä½¿é«˜å°šè€…å‡ºæ¥åšå®˜ã€‚ è¿™è¿›ä¸€æ­¥è¯æ˜äº†æ­£ä¹‰ä¸æ˜¯å¼ºè€…çš„åˆ©ç›Šï¼Œåˆæ­¥è¯æ˜äº†ä¸æ­£ä¹‰ä¸ä¸€å®šæ›´æœ‰ç›Šï¼Œä¸‹é¢è¿›ä¸€æ­¥è¯æ˜ã€‚ å¦‚æœèƒ½å¤Ÿæ²»ç†å›½å®¶å’Œäººæ°‘çš„çº¯ç²¹çš„ä¸æ­£ä¹‰è€…ï¼Œä¼šæ¯”æ­£ä¹‰è€…æœ‰èƒ½åŠ›å¾—å¤šï¼Œé‚£ä¹ˆä¸æ­£ä¹‰è€…å°±ä¼šæ˜¯æ˜æ™ºçš„ä¸”æœ‰ç¾å¾·çš„ï¼Œè€Œæ­£ä¹‰ä¾¿æ˜¯å…¶å¯¹ç«‹é¢ã€‚åŸºäºæ­¤ï¼Œä¸€ä¸ªæ­£ä¹‰è€…ä¸èƒ½å¤Ÿèƒœè¿‡å…¶ä»–çš„æ­£ä¹‰è€…å³æ²¡æœ‰ç«äº‰ï¼Œå› ä¸ºæ­£ä¹‰è€…æ˜¯ä¸æ˜æ™ºçš„ä¸”æ— èƒ½çš„ï¼Œå¹¶ä¸”æ‰€ä½œæ‰€ä¸ºä¸èƒ½æœ‰è¶…è¿‡æ­£ä¹‰äº‹ä¸šä¹‹å¤–çš„äº‹æƒ…ï¼Œå¹¶ä¸”æ­£ä¹‰è€…è·å¾—çš„åˆ©ç›Šä¸èƒ½å¤šäºä¸æ­£ä¹‰è€…ã€‚è€Œä¸æ­£ä¹‰è€…æ„¿æ„è·å¾—æ¯”æ­£ä¹‰è€…æ›´å¤šçš„åˆ©ç›Šï¼Œå¹¶ä¸”æ„¿æ„åšæ­£ä¹‰ä¹‹å¤–çš„äº‹æƒ…ï¼Œæ‰€ä»¥ä¸æ­£ä¹‰è€…åœ¨åˆ©ç›Šçš„ç«äº‰ä¸Šè¦æ¯”æ­£ä¹‰è€…æ¿€çƒˆï¼Œç„¶åæ‰èƒ½è·å–æ›´å¤šçš„åˆ©ç›Šã€‚æ€»ç»“å¦‚ä¸‹ï¼šæ­£ä¹‰è€…ä¸æ„¿æ„è·å¾—æ¯”åŒç±»æ›´å¤šçš„åˆ©ç›Šï¼Œè€Œæ„¿æ„è·å¾—æ¯”å¼‚ç±»æ›´å¤šçš„åˆ©ç›Šï¼›ä¸æ­£ä¹‰è€…å³æ„¿æ„è·å¾—æ¯”åŒç±»æ›´å¤šçš„åˆ©ç›Šï¼Œä¹Ÿæ„¿æ„è·å¾—æ¯”å¼‚ç±»æ›´å¤šçš„åˆ©ç›Šã€‚ä¸æ­£ä¹‰è€…å±äºå–„è€Œæœ‰æ™ºæ…§è€…çš„åŒç±»ï¼Œæ­£ä¹‰è€…å±äºå…¶å¼‚ç±»ã€‚ æˆ‘ä»¬å†æ¥çœ‹æŠ€è‰ºå®¶ï¼Œäººæ‰€æ‹¥æœ‰çš„æŠ€è‰ºæ˜¯ä¸åŒçš„ï¼Œä¾‹å¦‚ä¸€äººä¸ºéŸ³ä¹å®¶ï¼Œä¸€äººä¸ºééŸ³ä¹å®¶ï¼Œé‚£ä¹ˆå°±éŸ³ä¹ä¸Šçš„æ™ºæ…§æ¥è¯´ï¼ŒéŸ³ä¹å®¶æ˜¯èªæ˜çš„ã€‚ä»¥æ­¤ç±»æ¨ï¼ŒåŒ»ç”Ÿä¹Ÿæ˜¯è¿™æ ·çš„ã€‚éŸ³ä¹å®¶åœ¨è°ƒæ•´ç´å¼¦æ—¶ä¸ä¼šæœ‰æ„æƒ³èƒœè¿‡åˆ«çš„éŸ³ä¹å®¶ï¼Œè€Œä¼šæœ‰æ„èƒœè¿‡ééŸ³ä¹å®¶ã€‚åŒ»ç”Ÿåœ¨æ²»ç—…æ—¶ä¸ä¼šåšè¶…å‡ºåŒ»ç”ŸèŒƒå›´ä¹‹å¤–çš„äº‹ã€‚å†ä»¥çŸ¥è¯†ä¸æ„šç¬¨æ¥è¯´ï¼Œæœ‰çŸ¥è¯†è€…çš„è¨€è¡Œå’Œå…¶ä»–æœ‰çŸ¥è¯†è€…çš„è¨€è¡Œå·®ä¸å¤šï¼Œè€Œæ„šç¬¨çš„äººä¼šæƒ³è¦è‡ªå·±çš„è¨€è¡Œè¶…è¿‡æœ‰çŸ¥è¯†å’Œæ— çŸ¥è¯†çš„äººã€‚æœ‰çŸ¥è¯†çš„äººæ˜¯èªæ˜çš„è€Œèªæ˜çš„äººæ˜¯å–„è‰¯çš„ï¼ˆè¿™æ®µæˆ‘æ— æ³•æ¨å‡ºï¼Œå¯èƒ½æ˜¯ç”±äºå½“æ—¶çš„å±€é™æ€§å¯¹äºå–„è‰¯ï¼Œèªæ˜ç­‰çš„å®šä¹‰å¹¶ä¸æ˜ç¡®ï¼Œä¸Šæ–‡ä¹Ÿå‡ºç°äº†ç±»ä¼¼çš„æƒ…å†µï¼‰ï¼Œèªæ˜åˆå–„è‰¯çš„äººä»…ä»…å¸Œæœ›èƒœè¿‡å¼‚ç±»ï¼Œè€Œä¸å¸Œæœ›èƒœè¿‡åŒç±»ï¼Œæˆ‘ä»¬åŸºäºä¸Šæ–‡çš„å‡è®¾å¾—åˆ°è¿™äº›ç»“è®ºã€‚ è€Œä¸Šæ–‡è¯´ä¸æ­£ä¹‰è€…å¸¸å¸¸æƒ³è¦èƒœè¿‡åŒç±»å’Œå¼‚ç±»ï¼Œæ­£ä¹‰è€…åªæƒ³èƒœè¿‡å¼‚ç±»ï¼Œè€Œä¸æƒ³èƒœè¿‡åŒç±»ï¼Œé‚£ä¹ˆæ­£ä¹‰è€…åˆ™ä¸èªæ˜åˆæœ‰å–„å¾·çš„ç›¸ä¼¼ï¼Œä¸æ­£ä¹‰è€…ä¸æ— çŸ¥è€Œåˆæ²¡æœ‰å–„çš„çš„ç›¸ä¼¼ã€‚é‚£ä¹ˆç°åœ¨æ­£ä¹‰è€…å˜æˆäº†èªæ˜åˆæœ‰å–„å¾·çš„äººï¼Œä¸æ­£ä¹‰è€…å˜æˆäº†æ— çŸ¥åˆæ²¡æœ‰å–„å¾·çš„äººï¼Œä¸ä¸Šä¸€æ®µçš„ç»“è®ºçŸ›ç›¾ã€‚ æ­£ä¹‰ä¸ä¸æ­£ä¹‰çš„æ€§è´¨åŸºäºæˆ‘ä»¬å·²ç»è¯æ˜æ­£ä¹‰æ˜¯ç¾å¾·å’Œæ™ºæ…§ï¼Œä¸æ­£ä¹‰æ˜¯æ²¡æœ‰å–„å¾·å’Œæ„šè ¢çš„ã€‚é‚£ä¹ˆæ­£ä¹‰è€…æ¯”ä¸æ­£ä¹‰è€…å¼ºæ˜¯ä¸è¨€è€Œå–»çš„ã€‚ç°åœ¨æˆ‘ä»¬å‡è®¾ï¼Œæœ‰ä¸€ä¸ªå›½å®¶æˆ–ä¸€æ”¯å†›é˜Ÿæˆ–ä¸€ä¼™å¼ºç›—æˆ–ä»»ä½•ä¸€äº›ä½œæ¶çš„å›¢ä¼™ï¼Œå¦‚æœä»–ä»¬æˆå‘˜ä¹‹é—´æ•´å¤©è‡ªç›¸æ®‹æ€ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¢ä¼™ä¸€å®šæ˜¯ä¸èƒ½æˆåŠŸè¿ä½œçš„ï¼Œè€Œå¦‚æœä¸è‡ªç›¸æ®‹æ€ï¼Œé‚£ä¹ˆè¿™äº›å›¢ä¼™çš„è¿ä½œæ‰èƒ½è¿›è¡Œçš„æ›´å¥½ã€‚æ‰€ä»¥ä¸æ­£ä¹‰ä¼šå¼•å‘äº‰ç«¯å’Œä»‡æ¨ï¼Œè€Œæ­£ä¹‰èƒ½è°ƒå’Œå½¼æ­¤ä¹‹é—´çš„çŸ›ç›¾ä»¥è¾¾åˆ°å’Œè°ã€‚ï¼ˆçœ‹åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬åº”è¯¥ä¹Ÿæ˜ç™½äº†ï¼ŒæŸæ‹‰å›¾å¯¹äºæ­£ä¹‰å’Œä¸æ­£ä¹‰çš„å®šä¹‰ä¹Ÿæ˜¯æ¯”è¾ƒæ¨¡ç³Šçš„ï¼Œä¸€äº›è¯æ˜çœ‹ä¼¼æœ‰é“ç†ï¼Œä½†æ˜¯ç»†ç»†æ€è€ƒä¸€ä¸‹ï¼Œå°±ä¼šå‘ç°å…¶ä¸­çš„çº°æ¼ï¼‰ä¸æ­£ä¹‰æ—¢ç„¶æœ‰å¼•å‘äº‰è®ºå’Œä»‡æ¨çš„æ€§è´¨ï¼Œé‚£ä¹ˆå‡¡æ˜¯åœ¨ä¸æ­£ä¹‰çš„åœ°æ–¹ï¼Œä¸è®ºæ˜¯åŠªåŠ›è¿˜æ˜¯è‡ªç”±äººï¼Œä»–ä»¬ä¼šå› æ­¤ç›¸äº’äº‰æ–—ï¼Œæ„è§åˆ†æ­§ï¼Œè€Œä¸èƒ½æœ‰å…±åŒçš„è¡ŒåŠ¨ã€‚é‚£ä¹ˆä¸æ­£ä¹‰åœ¨äºŒäººä¹‹é—´ï¼Œåˆ™å½¼æ­¤ä¼šå‘ç”Ÿäº‰è®ºå’Œæ¿€æˆ˜ï¼ŒåŠ¿å¿…ä¼šç§°ä¸ºä»‡æ•Œï¼Œå¹¶ä¸”è¿˜ä¼šç§°ä¸ºæ­£ä¹‰çš„æ•Œäººã€‚è€Œä¸æ­£ä¹‰åœ¨ä¸€ä¸ªäººèº«ä¸Šï¼Œä¸æ­£ä¹‰ä¼šæ˜¯å…¶è‡ªç›¸çŸ›ç›¾ï¼Œè¨€è¡Œå‰åä¸ä¸€ï¼Œæ‰€ä»¥ä¸æ­£ä¹‰ä¸ä»…ä»…æ˜¯æ­£ä¹‰çš„æ•Œäººï¼Œä¹Ÿæ˜¯è‡ªæˆ‘çš„æ•Œäººã€‚æ‰€ä»¥ä¸æ­£ä¹‰å³ä½¿å¯¹ä¸ªäººä¹Ÿæ˜¯æœ‰å®³çš„ï¼Œä¸€æ˜¯ä¼šä½¿äººçš„è¨€è¡Œä¸ä¸€è‡´ï¼ŒäºŒæ˜¯ä¼šæ˜¯äººä¸‰å¿ƒäºŒæ„ï¼Œä½¿è‡ªå·±ç§°ä¸ºè‡ªå·±çš„æ•Œäººï¼Œå¹¶ä¸”ä¹Ÿæˆä¸ºæ­£ä¹‰çš„æ•Œäººã€‚ å“ªäº›å…±åŒä½œæ¶çš„äººï¼Œä¹‹æ‰€ä»¥èƒ½å¤Ÿè¿›è¡Œä½œæ¶è¡Œä¸ºï¼Œè¿˜ä¸èƒ½ç®—æ˜¯çœŸæ­£çš„ä¸æ­£ä¹‰è€…ï¼Œå‡å¦‚ä»–ä»¬æ˜¯çœŸæ­£çš„ä¸æ­£ä¹‰è€…ï¼Œé‚£ä¹ˆä»–ä»¬å¿…å®šä¼šè‡ªç›¸æ®‹å®³ï¼Œå¦‚æœä»–ä»¬èƒ½å¤Ÿè”åˆåœ¨ä¸€èµ·ä¸ºæ¶ï¼Œé‚£ä¹ˆè¿˜æœ‰ä¸€éƒ¨åˆ†æ­£ä¹‰å­˜åœ¨äºå…¶é—´ï¼Œæ‰€ä»¥æ‰èƒ½è¿›è¡Œé›†ä½“çš„è¡ŒåŠ¨ã€‚ å‡¡ç‰©éƒ½æœ‰å…¶ä¸“é—¨ç‹¬ç‰¹çš„åŠŸèƒ½å’Œäº‹ä¸šï¼Œä¹Ÿä¸€å®šä¼šæœ‰å®ƒçš„ä¸€ä¸ªç‰¹é•¿ï¼Œå°±åƒäººçš„çœ¼ç›æœ‰å®ƒè‡ªèº«ç‹¬ç‰¹çš„åŠŸèƒ½ã€‚å‡å¦‚çœ¼ç›çš„ç‰¹é•¿ä¸å®Œå¤‡è€Œæœ‰ç¼ºé™·ï¼Œé‚£ä¹ˆçœ¼ç›å°±ä¸èƒ½æˆå°±å®ƒçš„äº‹ä¸šã€‚é‚£ä¹ˆæœ‰æ­£ä¹‰ä¹‹å¿ƒçš„äººï¼Œè‡ªç„¶å°±ä¼šç”Ÿæ´»å¾—å¦ç„¶è‡ªè‹¥ï¼Œç»ˆèº«æ„‰å¿«ï¼Œè€Œä¸æ­£ä¹‰çš„äººåˆšå¥½ç›¸åã€‚æ ¹æ®ä»¥ä¸Šæ¨è®ºï¼Œåªæœ‰æ­£ä¹‰è€…æ‰èƒ½ç”Ÿæ´»å¾—å®‰ä¹è€Œå¹¸ç¦ï¼Œä¸æ­£ä¹‰è€…åˆ™ä¸èƒ½ã€‚","categories":[{"name":"è¯»ä¹¦ç¬”è®°","slug":"è¯»ä¹¦ç¬”è®°","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"å“²å­¦","slug":"è¯»ä¹¦ç¬”è®°/å“²å­¦","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%93%B2%E5%AD%A6/"}],"tags":[{"name":"æŸæ‹‰å›¾","slug":"æŸæ‹‰å›¾","permalink":"http://example.com/tags/%E6%9F%8F%E6%8B%89%E5%9B%BE/"},{"name":"ç†æƒ³å›½","slug":"ç†æƒ³å›½","permalink":"http://example.com/tags/%E7%90%86%E6%83%B3%E5%9B%BD/"}]},{"title":"Hello ,my blog","slug":"Hello-my-blog","date":"2022-06-23T06:44:47.000Z","updated":"2023-03-31T04:52:42.333Z","comments":true,"path":"2022/06/23/Hello-my-blog/","link":"","permalink":"http://example.com/2022/06/23/Hello-my-blog/","excerpt":"","text":"Zwei Dinge erfÃ¼llen das Gemuet mit immer neuer und zunehmender Bewunderung und Ehrfurcht, je Ã¶fter und anhaltender sich das Nachdenken damit beschÃ¤ftigt:: der bestirnte Himmel Ã¼ber mir und das moralische Gesetz in mir.","categories":[{"name":"Dairy","slug":"Dairy","permalink":"http://example.com/categories/Dairy/"}],"tags":[{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"}]}],"categories":[{"name":"Linuxå†…æ ¸","slug":"Linuxå†…æ ¸","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"ç¼–ç¨‹è¯­è¨€","slug":"ç¼–ç¨‹è¯­è¨€","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"ç¼–ç¨‹è¯­è¨€/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"ç»ƒä¹ å®è·µ","slug":"ç¼–ç¨‹è¯­è¨€/Rust/ç»ƒä¹ å®è·µ","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"},{"name":"è®ºæ–‡ç²¾è¯»","slug":"è®ºæ–‡ç²¾è¯»","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"å†…æ ¸å®‰å…¨","slug":"è®ºæ–‡ç²¾è¯»/å†…æ ¸å®‰å…¨","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"},{"name":"C++","slug":"ç¼–ç¨‹è¯­è¨€/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"ç½‘ç»œç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/ç½‘ç»œç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"è¯­æ³•","slug":"ç¼–ç¨‹è¯­è¨€/C/è¯­æ³•","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"},{"name":"é¡¹ç›®å®æˆ˜","slug":"ç¼–ç¨‹è¯­è¨€/C/é¡¹ç›®å®æˆ˜","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"Linuxç³»ç»Ÿç¼–ç¨‹","slug":"ç¼–ç¨‹è¯­è¨€/C/Linuxç³»ç»Ÿç¼–ç¨‹","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"æ•°æ®åº“","slug":"ç¼–ç¨‹è¯­è¨€/C/æ•°æ®åº“","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"QT","slug":"ç¼–ç¨‹è¯­è¨€/C/QT","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/QT/"},{"name":"è¯¾ç¨‹å­¦ä¹ ","slug":"è¯¾ç¨‹å­¦ä¹ ","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"è¯¾ç¨‹å­¦ä¹ /MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"},{"name":"è¯»ä¹¦ç¬”è®°","slug":"è¯»ä¹¦ç¬”è®°","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"å“²å­¦","slug":"è¯»ä¹¦ç¬”è®°/å“²å­¦","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%93%B2%E5%AD%A6/"},{"name":"å­¦ä¹ è·¯å¾„","slug":"å­¦ä¹ è·¯å¾„","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"},{"name":"Ubuntuæºç ","slug":"Ubuntuæºç ","permalink":"http://example.com/categories/Ubuntu%E6%BA%90%E7%A0%81/"},{"name":"Dairy","slug":"Dairy","permalink":"http://example.com/categories/Dairy/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"C","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"},{"name":"æ–‡ä»¶ç³»ç»Ÿ","slug":"æ–‡ä»¶ç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"çº¿ç¨‹","slug":"çº¿ç¨‹","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"æ•°æ®åº“","slug":"æ•°æ®åº“","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"},{"name":"è¿›ç¨‹","slug":"è¿›ç¨‹","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"æ“ä½œç³»ç»Ÿ","slug":"æ“ä½œç³»ç»Ÿ","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"cgroup","slug":"cgroup","permalink":"http://example.com/tags/cgroup/"},{"name":"å†…æ ¸å®‰å…¨","slug":"å†…æ ¸å®‰å…¨","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"},{"name":"å“²å­¦","slug":"å“²å­¦","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6/"},{"name":"åº„å­","slug":"åº„å­","permalink":"http://example.com/tags/%E5%BA%84%E5%AD%90/"},{"name":"é“å®¶","slug":"é“å®¶","permalink":"http://example.com/tags/%E9%81%93%E5%AE%B6/"},{"name":"æŒ‡é’ˆ","slug":"æŒ‡é’ˆ","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/tags/Ubuntu/"},{"name":"äº‘å®‰å…¨","slug":"äº‘å®‰å…¨","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"æŸæ‹‰å›¾","slug":"æŸæ‹‰å›¾","permalink":"http://example.com/tags/%E6%9F%8F%E6%8B%89%E5%9B%BE/"},{"name":"ç†æƒ³å›½","slug":"ç†æƒ³å›½","permalink":"http://example.com/tags/%E7%90%86%E6%83%B3%E5%9B%BD/"},{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"}]}