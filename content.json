{"meta":{"title":"Plucky","subtitle":"Comfortably Numb","description":"记录","author":"Plucky","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2022-06-23T08:09:59.000Z","updated":"2023-03-01T09:00:29.431Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"饥饿艺术家"},{"title":"links","date":"2023-03-31T04:34:08.000Z","updated":"2023-05-12T13:02:28.648Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":"Friend Link Solar1s Hammour Placebo"},{"title":"categories","date":"2022-06-23T11:37:54.000Z","updated":"2022-06-23T11:44:50.961Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-06-23T11:37:08.000Z","updated":"2022-06-23T11:42:25.423Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++学习 网络编程 libevent","slug":"C++-学习-网络编程-libevent","date":"2023-07-04T01:58:46.000Z","updated":"2023-07-15T02:35:07.490Z","comments":true,"path":"2023/07/04/C++-学习-网络编程-libevent/","link":"","permalink":"http://example.com/2023/07/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent/","excerpt":"学习目标 描述什么是libevent并掌握如何安装 掌握event_base的作用和使用方法 熟练掌握libevent库中的事件循环 掌握event事件的使用方法 掌握bufferevent的工作方式 掌握使用libevent实现TCP服务端流程 掌握使用libevent实现TCP客户端流程 libevent介绍","text":"学习目标 描述什么是libevent并掌握如何安装 掌握event_base的作用和使用方法 熟练掌握libevent库中的事件循环 掌握event事件的使用方法 掌握bufferevent的工作方式 掌握使用libevent实现TCP服务端流程 掌握使用libevent实现TCP客户端流程 libevent介绍 事件驱动、高性能、轻量级、专注于网络 源代码精炼、易读 跨平台 支持多种I&#x2F;O多路复用技术，如epoll、select、poll等 支持I&#x2F;O和信号等事件 libevent的安装libevent登录官方网站，查看相关信息 libevent源码下载主要分2个大版本： 1.4.x系列，较为早期版本，适合源码学习 2.x系列，较新的版本，代码量比1.4版本多很多，功能也更完善。 libevent的核心实现 在linux上，其实质就是epoll反应堆。 libevent是事件驱动，epoll反应堆也是事件驱动，当要检测的事件发生的时候，就会调用事件对应的回调函数，执行相应的操作。特别提醒：事件回调函数是由用户开发的，但是不是由用户显示去调用的，而是由libevent去调用得到。 从官网下载上下载安装文件之后，将安装文件上传到linux系统上；源码包的安装，以2.1.12版本为例，在官网可以下载到源码包tar -zxvf libevent-2.1.12-stable.tar.gz,安装步骤与第三方库源码包安装方式基本一致。 解压libevent-2.1.12-stable.tar.gz 解压：tar -zxvf libevent-2.1.12-stable.tar.gz cd到libevent-2.1.12-stable目录下，查看README文件，该文件里描述了安装的详细步骤，可参照这个文件进行安装 1234./configuremakemake verify # (optional)sudo make install 进入源码目录 执行配置.&#x2F;configure，检测安装环境。生成makefile 执行.&#x2F;configure的时候也可以指定路径，.&#x2F;configure –prefix&#x3D;&#x2F;usr&#x2F;xxxxx,这样就可以安装到指定的目录下，但是这样在进行源代码编译的时候就可以安装到指定的目录下，但是这样在进行源代码编译的时候需要指定用-l头文件的路径和用-L库文件的路径。若默认安装不指定–prefix，则会安装到系统默认的路径下，编译的时候可以不指定头文件和库文件所在的路径。 执行make命令编译整个项目文件 通过执行make命令，会生成一些库文件（动态库和静态库）和可执行文件 执行sudo make install进行安装 安装需要root用户权限，这一步需要输入当前用户的密码 执行这一步，可以将刚刚编译成的库文件和执行文件以及一些头文件拷贝到&#x2F;usr&#x2F;local目录下： 头文件拷贝到了&#x2F;usr&#x2F;local&#x2F;include目录下； 库文件拷贝到了&#x2F;usr&#x2F;local&#x2F;lib目录下 libevent库的使用进入到libevent-2.1.12-stable&#x2F;sample下，可以查看一些实例源代码文件。使用libevent库编写代码在编译程序的时候需要指定库名：-levent； 安装文件的libevent库文件所在路径：libevent-2.1.12-stable&#x2F;.libs; 编写代码的时候用到event.h头文件，或者直接参考sample目录下的源代码文件也可以。 1#include&lt;event2/event.h&gt; 由于安装的时候已经将头文件和库文件拷贝到了系统头文件所在路径&#x2F;usr&#x2F;local&#x2F;include和系统库文件所在路径&#x2F;usr&#x2F;local&#x2F;lib，所以这里编译的时候可以不指定-l和-L 编译源代码文件（以hello-world.c文件为例） 1gcc hello-world.c -levent 测试，编译之后，在文件夹中运行hello-world程序，在另一个中段窗口进行测试，输入：nc 127.1 9995，然后回车立刻显示Hello，World！字符串。 libevent的使用libevent的地基event_base使用libevent函数之前需要分配一个或者多个event_base结构体，每个event_base结构体持有一个事件集合，可以检测以确定哪个事件是激活的，event_base结构相当于epoll红黑树的树根节点，每个event_base都有一种用于检测某种事件已经就绪的”方法”（回调函数） 通常情况下可以通过event_base_new函数获得event_base结构。 相关函数说明： struct event_base* event_base_new(void) //函数说明：获得event_base结构 //参数说明：无 //返回值： // - 成功返回event_base结构体指针 // - 失败返回NULL 1234- ```cpp void event_base_free(struct event_base*) //函数说明：释放event_base指针 int event_reinit(struct event_base* base) //函数说明：如果有子进程，且子进程也要使用base，则子进程需要对event_base重新初始化，此时需要调用event_base重新初始化，此时需要调用event_reinit函数 //函数参数：由event_base_new返回的执行event_base结构的指针 //返回值：成功返回0，失败返回-1 12345678910对于不同系统而言，event_base就是调用不同的多路IO接口去判断事件是否已经被激活，对于linux系统而言，核心调用的就是epoll，同时支持poll和select。查看libevent支持的后端的方法有哪些：- ```cpp const char** event_get_supported_methods(void) //函数说明：获得当前系统（或者称为平台）支持的方法有哪些 //参数：无 //返回值：返回二维数组，类似与main函数的第二个参数**argv const char** event_base_get_method(const struct event_base* base) //函数说明：获得当前base节点使用的多路io方法 //函数参数：event_base结构的base指针 //返回值：获得当前base节点使用的多路io方法的指针 1234567891011121314151617181920212223242526272829303132```cpp//测试当前系统支持的libevent方法和当前使用的方法#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;event2/event.h&gt;int main()&#123; int i = 0; //获取当前系统支持的方法 const char** p = event_get_supported_methods(); while (p[i] != NULL) &#123; printf(&quot;%s \\t&quot;, p[i++]); &#125; printf(&quot;\\n&quot;); //获取地基节点 struct event_base* base = event_base_new(); if (base == NULL) &#123; printf(&quot;event_base_new error\\n&quot;); return -1; &#125; //读取当前系统使用的方法 const char** pp = event_base_get_method(base); printf(&quot;%s\\n&quot;, pp); //释放地基节点 event_base_free(base); return 0;&#125; 运行结果为： epoll poll selectepoll 等待事件产生-循环等待event_looplibevent在地基打好之后，需要等待事件的产生，也就是等待事件被激活后，所以程序不能退出，对于epoll来说，我们需要自己控制循环，而在libevent中也给我们提供了API接口，类似where(1)的功能。 函数如下： 1234567891011int event_base_loop(struct event_base* ，int flag)//函数说明：进入循环等待事件//参数说明// - base：由event_base_new函数返回的指向event_base结构的指针// - flags的取值：// - #define EVLOOP_ONCE 0x01 只触发一次，如果事件没有被触发，阻塞等待// - #define EVLOOP_NONBLOCK 0x02 非阻塞方式检测事件是否被处罚法，不管事件触发与否，都会立即返回// - base：由event_base_new函数返回的指向event_base结构的指针// - flags的取值：// - #define EVLOOP_ONCE 0x01 只触发一次，如果事件没有被触发，阻塞等待// - #define EVLOOP_NONBLOCK 0x02 非阻塞方式检测事件是否被处罚法，不管事件触发与否，都会立即返回 这个函数一般不用，而大多数都调用libevent给我们提供的另外一个API： 1234int event_base_dispath(struct event_base* base)//函数说明：进入循环等待事件//参数说明：由event_base_new函数返回的指向event_base结构的指针//调用该函数，相当于没有设置标志位的event_base_loop。程序将会一直运行，知道没有需要检测的事件了，或者结束循环的API终止 调用该函数，相当于没有设置标志位的event_base_loop。程序将会一直运行，直到没有需要检测的事件了，或者被结束循环的API终止。 1234567int event_base_loopexit(struct event_base* base, const struct timeval* tv)int event_base_loopbreak(struct event_base* base)struct timeval&#123; long tv_sec; long tv_usec;&#125; 两个函数的区别是如果正在执行激活事件的回调函数，那么event_base_loopexit将在事件回调执行结束后终止循环（如果tv事件非NULL，那么将等待tv设置的时间后立即结束循环），而event_base_loopbreak会立即终止循环。 使用libevent库的步骤 创建根节点–event_base_new 设置监听事件和数据可读可写的事件的回调函数，设置了事件对应的回调函数以后，当事件产生的时候会自动调用回调函数 事件循环–event_base_dispatch，相当于while(1),在循环内部等待事件的发生，若有事件发生则会触发事件对应的回调函数。 释放根节点–event_base_free，释放由event_base_new和event_new创建的资源，分别调用event_base_free和event_free函数。 事件驱动-event事件驱动实际上libevent的核心思想，主要的状态转化 主要的几个状态： 无效的指针：此时仅仅是定义了struct event *ptr 非未决：相当于创建了事件，但是事件还没有处于被监听状态，类似于我们使用epoll的时候定义了struct epoll_event ev并且对ev的两个字段进行了赋值，但是此时尚未调用epoll_ctl对事件上述。 未决：就是对事件开始监听，暂时未有事件产生。相当于调用epoll_ctl对要监听的事件上树，但是没有事件产生。 激活：代表监听的事件已经产生，这时需要处理，相当于调用epoll_wait函数有返回，当事件被激活以后，libevent会调用该事件对应的回调函数。 libevent的事件驱动对应的结构体为struct event，对应的函数在图上也比较清晰。 typedef void(*event_callback_fn)(evutil_socket_t fd, short events, event_callback_fn cb, void* arg) 123456789101112131415- ```cpp struct event* event_new(struct event_base* base, evutil_socket_t fd, short events, event_callback_fn cb, void* arg) //函数说明：event_new负责创建event结构指针，同时指定对应的地基base，还有对应的文件描述符，事件，以及回调函数和回调函数的参数 //参数说明： // - base：对应的根节点--地基 // - fd：要监听的文件描述符 // - events：要监听的事件 // - #define EV_TIMEOUT 0x01 //超时事件 // - #define EV_READ 0x02 //读事件 // - #define EV_WRITE 0x04 //写事件 // - #define EV_SIGNAL 0x08 //信号触发 // - #define EV_PERSIST 0x10 //周期性触发 // - #define EV_ET 0x20 //边缘触发，如果底层模型支持设置则有效，若不支持则无效 // - 若要想设置持续的读事件则：EV_READ|EV_PERSIST cb回调函数，原型如下： typedef void(*event_callback_fn)(evutil_socket_t fd,short events,void *arg) 123456 注意：回调函数的参数就对应于event_new函数的fd，event和arg- ```cpp #define evsignal_new(b,x,cb,arg) event_new((b),(x),EV_SIGNAL|EV_PRESIST,(cb),(arg)) int event_add(struct event* ev, const struct timeval* timeout) //函数说明：将非未决态事件转为未决态，相当于调用epoll_ctl函数（EPOLL_CTL_ADD），开始监听事件是否产生，相当于epoll的上树操作 //参数说明： // - ev：调用event_new创建的事件 // - timeout：限时等待事件的产生，也可以设置为NULL，没有限时。 12345- ```cpp int event_del(struct event* ev) //函数说明：将事件从未决态变为非未决态，相当于epoll的下树（epoll_ctl调用EPOLL_CTL_DEL操作）操作 //参数说明：ev指的是由event_new创建的事件 void event_free(struct event* ev) //函数说明：释放由event_new申请的event节点 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143# 编写一个基于event实现的tcp服务器总体步骤：1. 搭建服务器固定三步，标出的三步： - &lt;mark&gt;创建socket---socket()&lt;/mark&gt; - 设置端口复用---setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(int)) - &lt;mark&gt;绑定bind---bind()&lt;/mark&gt; - &lt;mark&gt;监听listen---listen()&lt;/mark&gt; - 创建地基---struct event_base *base = event_base_new()（下面的第二步） - 创建lfd对应的事件节点---struct event *ev = event_new(base,lfd，EV_READ|EV_PERSIST,conncb,NULL)(下面的第三步) - 上event_base地基---event_add(ev,NULL) - 进入事件循环---event_base_dispatch(base)(下面的第四步) - 释放资源--event_base_free(base),event_free(ev) - 2. 调用event_base_new函数创建event_base节点3. 创建要监听的事件event，主要就是监听事件和读数据的事件 - 设置好监听事件的回调函数，然后event_add上树 - 有新的连接，则调用accept接受新的连接 - 将这个新的连接设置好回调函数（一般是设置读事件），然后继续event_add上述，若有客户端关闭连接则从树上摘除该事件节点4. 调用event_base_dispatch进入循环等待事件的发生# libevent服务端程序的代码实现```cpp#include&lt;unistd.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;netinet/in.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;event2/event.h&gt;struct event* connev = NULL;void readcb(evutil_socket_t fd, short events, void* arg)&#123; int n; char buf[1024]; memset(buf, 0x00, sizeof(buf)); n = read(fd, buf, sizeof(buf)); if (n &lt;= 0) &#123; close(fd); //将通信文件描述符对应的事件从base地基上删除 event_del(connev); return; &#125; else &#123; write(fd, buf, n); &#125; write(fd, buf, n);&#125;void conncb(evutil_socket_t fd, short events, void* arg)&#123; struct event_base* base = (struct event_base*)arg; //接受新的客户端连接 int cfd = accept(fd, NULL, NULL); if (cfd &gt; 0) &#123; //创建通信描述符对应的事件并设置回调函数为readcb struct event* connev = event_new(base, cfd, EV_READ | EV_PERSIST, readcb, NULL); if (connev == NULL) &#123; //退出循环 event_base_loopexit(base, NULL); &#125; //将通信文件描述符对应的事件上event_base地基 event_add(connev, NULL); &#125;&#125;int main()&#123; //创建socket int fd = socket(AF_INET, SOCK_STREAM, 0); //设置端口复用 int opt = 1; setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); //绑定 struct sockaddr_in serv; bzero(&amp;serv, sizeof(serv)); serv.sin_addr.s_addr = htonl(INADDR_ANY); serv.sin_port = htons(8888); serv.sin_family = AF_INET; bind(fd, (struct sockaddr*)&amp;serv, sizeof(serv)); //监听 listen(fd, 120); //创建地基 struct event_base* base = event_base_new(); if (base == NULL) &#123; printf(&quot;event_base_new error\\n&quot;); return -1; &#125; //创建监听文件描述符对应的事件 struct event* ev = event_new(base, fd, EV_READ | EV_PERSIST, conncb, base); if (ev == NULL) &#123; printf(&quot;event_new error\\n&quot;); return -1; &#125; //将新的事件节点上base地基 event_add(ev, NULL); //进入事件循环等待 event_base_dispatch(base); //释放资源 event_base_free(base); event_free(ev); close(fd); return 0; &#125; libevent服务端程序测试和错误分析使用下面命令打开客户端： 1nc 127.1 8888 使用下面命令查看对应的端口状态： 1netstat -anp | grep 8888 分析之后，根据上述代码，只要关闭最后一个客户端时，也会影响到别的客户端。 自带buffer的事件buffereventbufferevent实际上也是一个event，只不过比普通的event高级一些，它的内部有两个缓冲区，以及一个文件描述符（网络套接字）。一个网络套接字有读和写两个缓冲区，bufferevent同样也带有两个缓冲区，还有就是libevent事件驱动的核心回调函数，那么四个缓冲区以及触发回调的关系如下： 从图中可以得知，一个bufferevent对应两个缓冲区，三个回调函数，分别是写回调，读回调和事件回调。 bufferevent有三个回调函数： 读回调 - 当bufferevent将底层读缓冲区的数据读到自身的读缓冲区时触发读事件回调 写回调 - 当bufferevent将自身写缓冲的数据写到底层写缓冲区的时候触发写事件回调，由于数据最终是写入了内核的写缓冲区中，应用程序以及无法控制，这个事件对于应用程序来说基本没什么用，只是通知功能。 事件回调 - 当bufferevent绑定的socket连接，断开或者异常的时候触发事件回调。 bufferevent的读事件触发时机 当数据由内核的读缓冲区到 bufferevent的读缓冲区的时候，会触发bufferevent读事件回调 需要注意的是：数据由内核到bufferevent的过程不是用户程序做的，是由bufferevent内部操作的。 bufferevent的写事件触发时机 当用户程序将数据写到bufferevent的写缓冲区之后，bufferevent会自动将数据写到内核的写缓冲区，最终有内核程序将数据发送出去。 事件回调： 当bufferevent绑定的socket连接，断开或者异常的时候触发事件回调。 主要使用的函数如下： 12345678struct bufferevent *bufferevent_socket_new(struct event_base *base,evutil_socket_t fd,int options);//函数说明：bufferevent_socket_new对已经存在socket创建bufferevent事件，可用于后面讲到的连接监听器的回调函数中//参数说明：// base：对应根节点// fd：文件描述符// options：bufferevent的选项// BEV_OPT_CLOSE_ON_FREE --释放bufferevent自动关闭底层接口（当bufferevent被释放以后，文件描述符也随之被close// BEV_OPT_THREADSAFE --使bufferevent能够在多线程下是安全的 12345678int bufferevent_socket_connect(struct bufferevent *bev,struct sockaddr *serv,int socklen);//函数说明：该函数封装了底层的socket与connect接口，通过调用此函数，可以将bufferevent事件与通信的socket进行绑定//参数说明：// bev -- 需要提前初始化的bufferevent事件// serv -- 对端（一般指服务端）的ip地址，端口，协议的结构指针// socklen -- 描述serv的长度//说明：调用此函数以后，通信的socket与bufferevent缓冲区做了绑定，后面调用了bufferevent_setcb函数以后，//会对bufferevent缓冲区的读写操作的事件设置回调函数，当往缓冲区中写数据的时候会触发写回调函数，当数据从socket的内核缓冲区读到bufferevent读缓冲区中的时候会触发读回调函数 12void bufferevent_free(struct bufferevent *bufev);//函数说明 ：释放bufferevent 1234void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb,void *cbarg);//函数说明：bufferevent_setcb用于设置bufferevent的回调函数，readcb,writecb,eventcb分别对应了读回调，写回调，事件回调，cbarg代表回调函数的参数。 回调函数如下： 1typedef void (*bufferevent_data_cb)(struct bufferevent *bev ,void *ctx); 123456typedef void (*bufferevent_event_cb)(struct bufferevent *bev,short what,void *ctx);//What代表对应的事件//BEV_EVENT_EOF遇到文件结束提示//BEV_EVENT_ERROR发生错误//BEV_EVENT_TIMEOUT发生超时//BEV_EVENT_CONNECTED请求的过程中连接已经完成 123int bufferevent_write(struct bufferevent *bufev,const void *data,size_t size);//bufferevent_write是将data的数据写到bufferevent的写缓冲区 123int bufferevnet_write_buffer(struct bufferevent *bufev,struct evbuffer *buf);//bufferevent_write_buffer 是将数据写到缓冲区另外一个写法，实际上bufferevent的内部的两个缓冲区结构就是struct evbuffer 123size_t bufferevent_read(struct bufferevent *bufev,void *data,size_t size);//bufferevent_read是将bufferevent的读缓冲区数据读到data中，同时将读到的数据从bufferevent的读缓冲清除。 链接监听器-evconnlistener链接监听器封装了底层的socket通信相关函数，比如socket，bind，listen，accept这几个函数。链接监听器创建后实际上相当于调用了socket，bind，listen，此时等待新的客户端链接到来，如果又新的客户端连接，那么内部先进行调用accept处理，然后调用用户指定的回调函数。可以先看看函数原型，了解一下他是怎么运作的： 函数声明所在的头文件：event2&#x2F;listener.h 1234567891011121314struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb,void *ptr,unsigned flags,int backlog, const struct sockaddr *sa,int socklen);//函数说明：// 是在当前没有套接字的情况下对链接监听器进行初始化，看最后2个参数实际上//就是bind使用的关键参数，backlog是listen函数的关键参数（略有不同的是，如果//backlog是-1，那么监听器会自动选择一个合适的值，如果填0，那么监听器会认为//listen函数是已经被调用过了），ptr是回调函数的参数，cb是有新链接之后的回调//函数，但是注意这个回调函数触发的时候，链接器已经处理好新连接了，并将与新连接//通信的描述符交给回调函数。flags需要参考几个值：// LEV_OPT_LEAVE_SOCKETS_BLOCKING 文件描述符为阻塞的// LEV_OPT_CLOSE_ON_FREE 关闭时自动释放// LEV_OPT_REUSEABLE 端口复用// LEV_OPT_THREADSAFE 分配锁，线程安全 12345struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb,void *ptr,unsigned flags,int backlog, evutil_socket_t fd);//evconnlistener_new函数与前一个函数不同的地方在与后两个参数，使用本函数时，//认为socket已经初始化好，并且bind完成，甚至也可以做完listen，所以大多数时候，我们都可以使用第一个函数 两个函数的回调函数： 12typedef void (*evconnlistener_cb)(struct evconnlistener *evl,evutil_socket fd,struct sockaddr *cliaddr,int socklen,void *ptr);//回调函数fd参数是与客户端通信的描述符，并非是等待连接的监听的那个描述符，所以cliaddr对应的也是新连接的对端地址信息，已经是accept处理好的 12void evconnlistener_free(struct evconnlistener *lev);//函数说明：释放连接监听 12int evconnlistener_enable(struct evconnlistener *lev);//函数说明：使链接监听器生效 12int evconnlistener_disable(struct evconnlistener *lev);//函数说明：使链接监听器失效 如果上述函数都较为了解了，可以尝试去看懂hello-world.c的代码，在安装包sample目录下，其中有涉及到信号的函数，看看自己能否找到函数的原型在哪？实际上就是一个宏定义，也是我们之前介绍的event_new函数，只是对应一个信号事件而已，处理机制略有不同。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++学习 异常","slug":"C++-学习-异常","date":"2023-07-01T01:44:22.000Z","updated":"2023-07-03T03:28:46.636Z","comments":true,"path":"2023/07/01/C++-学习-异常/","link":"","permalink":"http://example.com/2023/07/01/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%82%E5%B8%B8/","excerpt":"异常的基本概念提供异常的基本目的就是为了处理上面的问题。基本思想是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接或者间接）调用者能够处理这个问题。将问题检测和问题处理相分离。 一种思想：在所有支持异常处理的编程语言中（例如java)，要认识到的一个思想：在异常处理过程中，由问题检测代码可以抛出一个对象给问题处理代码，通过这个对象的类型和内容，实际上完成了两个部分的通信，通信的内容是：出现了上面错误。当然，各种语言对异常的具体实现有着或多或少的区别，但是这个通信的思想是不变的。","text":"异常的基本概念提供异常的基本目的就是为了处理上面的问题。基本思想是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接或者间接）调用者能够处理这个问题。将问题检测和问题处理相分离。 一种思想：在所有支持异常处理的编程语言中（例如java)，要认识到的一个思想：在异常处理过程中，由问题检测代码可以抛出一个对象给问题处理代码，通过这个对象的类型和内容，实际上完成了两个部分的通信，通信的内容是：出现了上面错误。当然，各种语言对异常的具体实现有着或多或少的区别，但是这个通信的思想是不变的。 一句话：异常处理就是处理程序中的错误。所谓错误是指在程序运行的过程中发生的一些异常事件（如：除0溢出，数组下标越界，所要读取的文件不存在，空指针，内存不足等等）。 我们以前编写的程序是如何处理异常？ 在C语言的世界中，对错误的处理总是围绕着两种方法：一是使用整型的返回值标识错误；二是使用emo宏（可以简单的理解为一个全局整型变量）去记录错误。当然C++仍然是可以用两种方法的。这两种方法最大的缺陷就是会出现不一致的问题。例如有些函数返回1表示成功，返回0表示出错；而有些函数返回0表示成功，返回非0表示出错。 还有一个缺点就是函数的返回值只有一个，你通过函数的返回值表示错误代码，那么函数就不能返回其他的值。当然，你也可以通过指针或者C++的引用来返回另外的值，但是这样可能会令你的程序略微晦涩难懂。 C++异常机制相比C语言异常处理的优势？ 函数的返回值可以忽略，但异常不可忽略。如果程序出现异常，但是没有被捕获，程序就会终止，这多少会促使程序员开发出来的程序更健壮一点。而如果使用C语言的error宏或者函数返回值，调用者都有可能忘记检查，从而没有对错误进行处理，结果造成程序莫名其妙的终止或者出现错误的结果。 整型返回值没有任何寓意信息。而异常缺包含语义信息，有时你从类名就能够体现出来。 整型返回值缺乏相关的上下文信息，异常作为一个类，可以拥有自己的成员，这些成员就可以传递足够的信息。 异常处理可以在调用跳级。这是一个代码编写时的问题：假设在有多个函数的调用栈中出现了某个错误，使用整型返回码要求你在每一级函数中都要进行处理。而使用异常处理的栈展开机制，只需要在一处进行处理就可以了，不需要每级函数都处理。 C++的异常必须要有函数进行处理，如果没有任何处理，程序会中断。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int myDivision(int a,int b)&#123; if (b == 0) &#123; return -1; &#125; return a / b;&#125;void test01() &#123; int a = 10; int b = 0; //a=10,b=-1时，返回也为-1，也会进行异常处理 //C语言处理异常有缺陷，返回值不统一，无法区分时结果还是异常 int ret = myDivision(a, b); if (ret == -1) &#123; cout &lt;&lt; &quot;异常&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;using namespace std;class MyException&#123;public: void printError() &#123; cout &lt;&lt; &quot;我自己的异常&quot; &lt;&lt; endl; &#125;&#125;;int myDivision(int a,int b)&#123; if (b == 0) &#123; //throw &#x27;a&#x27;;//返回int类型的异常 throw MyException();//抛出MyException的匿名对象 &#125; return a / b;&#125;void test01() &#123; int a = 10; int b = 0; try &#123; myDivision(a, b); &#125; catch (int) &#123; cout &lt;&lt; &quot;int类型异常捕获&quot; &lt;&lt; endl; &#125; catch (char) &#123; //捕获到了异常，但是不想处理，继续向上抛出这个异常 //异常必须有函数进行处理，如果没有任何处理，程序自动调用terminate函数，让程序中断 throw; cout &lt;&lt; &quot;char类型异常捕获&quot; &lt;&lt; endl; &#125; catch (double) &#123; cout &lt;&lt; &quot;double类型异常捕获&quot; &lt;&lt; endl; &#125; catch (MyException e) &#123; e.printError(); &#125; catch (...) &#123; cout &lt;&lt; &quot;其他类型异常捕获&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; try &#123; test01(); &#125; catch (double) &#123; cout &lt;&lt; &quot;main函数中double类型异常捕获&quot; &lt;&lt; endl; &#125; catch (char) &#123; cout &lt;&lt; &quot;main函数中char类型异常捕获&quot; &lt;&lt; endl; &#125; catch (...) &#123; cout &lt;&lt; &quot;main函数中其他类型异常捕获&quot; &lt;&lt; endl; &#125;&#125; 运行结果为： 我自己的异常 总结 若有异常则通过throw操作创建一个异常对象并抛出。 将可能抛出异常的程序放到try块之中。 如果在try段执行期间没有引起异常，那么跟在try后面的catch字句就不会执行。 catch子句会根据出现的先后顺序被检查，匹配的catch语句捕获并处理异常（或继续抛出异常）。 如果匹配的处理来找到，则运行函数terminate将自动被调用，其缺省功能调用abort终止程序。 处理不了的异常，可以在catch的最后一个分支，使用throw，向上抛。 C++异常处理使得异常的引发和异常的处理不必在一个函数中，这样底层的函数可以着重解决问题，而不必过多的考虑异常的处理，上层调用者可以在适当的位置设计对不同类型异常的处理。 异常的基本语法 C++异常的处理关键字 try throw catch 可以出现异常的代码，放到try块 利用throw抛出异常 利用catch捕获异常 catch（类型），如果想捕获其他类型 catch（…) 如果捕获到的异常不想处理，而继续向上抛出，利用throw 异常必须有函数进行处理，如果都不去处理，程序自动调用terminate函数，中断掉 异常可以是自定义数据类型 异常是严格类型匹配 栈解旋 从try代码块开始，到throw抛出异常之前，所有栈上的数据都会被释放掉 释放的顺序和创建的顺序相反，这个过程我们称为栈解旋 异常接口声明 为了加强程序的可读性，可以在函数声明中列出可能抛出异常的所有类型，例如：void func() throw(A,B,C)；这个函数func能够且只能够抛出类型A，B，C及其子类型的异常 如果在函数声明中没有包含异常的接口声明，则此函数可以抛任何类型的异常，例如：void func() 一个不抛任何异常的函数可声明为：void func throw() 如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexcepted函数会被调用，该函数默认行为调用terminate 函数中断程序 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;//可以抛出所有类型异常void TestFunction01()&#123; throw 10;&#125;//只能抛int char char*类型异常void TestFunction02() throw(int, char, char)&#123; string exception = &quot;error!&quot;; throw exception;&#125;//不能抛出任何类型异常void TestFunction03()throw()&#123; throw 10;&#125;int main()&#123; try &#123; TestFunction01(); TestFunction02(); TestFunction03(); &#125; catch (...) &#123; cout &lt;&lt; &quot;捕获异常！&quot; &lt;&lt; endl; &#125;&#125; 异常变量的生命周期123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;class MyException&#123;public: MyException() &#123; cout &lt;&lt; &quot;MyException默认构造函数调用&quot; &lt;&lt; endl; &#125; MyException(const MyException &amp;e) &#123; cout &lt;&lt; &quot;MyException拷贝构造函数调用&quot; &lt;&lt; endl; &#125; ~MyException() &#123; cout &lt;&lt; &quot;MyException析构函数调用&quot; &lt;&lt; endl; &#125;&#125;;void doWork()&#123; throw MyException();&#125;void test01()&#123; try &#123; doWork(); &#125; //抛出的是throw MyException;catch(MyException e)调用拷贝构造函数 效率低 //抛出的是throw MyException();catch(MyException &amp;e)只调用默认构造函数 效率高 //抛出的是throw &amp;MyException();catch(MyException *e)对象会提前释放掉，不能在非法操作 //抛出的是new MyException();catch(MyException *e)只调用默认构造函数 自己要管理释放 catch (MyException &amp;e) &#123; cout &lt;&lt; &quot;自定义异常捕获&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 异常的多态使用 提供基类异常类 class BaseException 纯虚函数 virtual void printError() &#x3D; 0 子类空指针异常和越界异常继承BaseException 重写virtual void printError() 测试，利用父类的引用指向子类对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;using namespace std;//异常的基类class BaseException&#123;public: virtual void printError() = 0;&#125;;//空指针异常class NULLPointerException:public BaseException&#123;public: virtual void printError() &#123; cout &lt;&lt; &quot;空指针异常&quot; &lt;&lt; endl; &#125;&#125;;//越界异常class OutofRangeException :public BaseException&#123;public: virtual void printError() &#123; cout &lt;&lt; &quot;越界异常&quot; &lt;&lt; endl; &#125;&#125;;void doWork()&#123; //throw OutofRangeException(); throw NULLPointerException();&#125;void test01()&#123; try &#123; doWork(); &#125; catch (BaseException&amp; e) &#123; e.printError(); &#125;&#125;int main()&#123; test01();&#125; 运行结果为： 空指针异常 C++标准异常库标准库介绍标准库也提供了很多的异常类，它们是通过类继承组织起来的，异常类继承层级结构图如下： 每个类所在的头文件在图下方标识出来。 标准异常类的成员： 在上述继承体系中，每个类都有提供了构造函数、复制构造函数和复制操作符重载。 logic_error类及其子类、runtime_error类，及其子类，它们的构造函数时接受一个string类型的形式参数，用于异常信息的描述。 所有的异常类都有一个what()方法，返回const char*类型（C风格字符串）的值，描述异常信息。 标准异常类的具体描述： 异常名称 描述 exception 所有标准异常类的父类 bad_alloc 当operator new and operator new[]，请求分配内存失败时 bad_exception 这是个特殊的异常，如果函数的异常抛出列表里声明了bad_exception异常，当函数内部抛出了异常抛出列表中没有的异常，这是调用的Unexcepted函数中若抛出异常，不论什么类型，都会被替换为bad_exception类型 bad_typeid 使用typeid操作符，操作一个NULL指针，而该指针是带有虚函数的类，这时抛出bad_typeid异常 bad_cast 使用dynamic_cast转换引用失败的时候 ios_base::failure io操作过程出现错误 logic_error 逻辑错误，可以在运行前检测的错误 runtime_error 运行时错误，仅在运行时才可以检测的错误 logic_error的子类： 异常名称 描述 length_error 试图生成一个超出该类型最大长度的对象时，例如vector的resize操作 domain_error 参数的值域错误，主要用在数学函数中。例如使用一个负值调用只能操作非负数的函数 out_of_range 超出有效范围 invalid_argument 参数不合适。在标准库中，当利用string对象构造bitset时，而string中的字符不是0或1的时候，抛出该异常 runtime_error的子类： 异常名称 描述 range_error 计算结果超过了有意义的值域范围 overflow_error 算术计算上溢 underflow_error 算术计算下溢 invalid_argument 参数不合适。在标准库中，当利用string对象构造bitset，而string中的字符不是0或1的时候，抛出该异常 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;class Person&#123;public: Person(int age) &#123; if (age &lt; 0 || age&gt;150) &#123; throw out_of_range(&quot;年龄必须在0-150之间&quot;); &#125; this-&gt;m_Age = age; &#125; int m_Age;&#125;;void test01()&#123; try &#123; Person p(151); &#125; //catch (out_of_range&amp; e) catch(exception &amp;e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 引入头文件 #include&lt;stdexcept&gt; 抛出越界异常throw out_of_range(&quot;...&quot;) 获取错误信息catch(exception &amp;e) e.what(); 编写自己的异常类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;stdexcept&gt;using namespace std;class MyOutOfRangeException :public exception&#123;public: MyOutOfRangeException(const char* str) &#123; //const char *可以隐式类型转换为string，反之不可以 this-&gt;m_errorInfo = str; &#125; MyOutOfRangeException(string str) &#123; this-&gt;m_errorInfo = str; &#125; virtual const char* what() const &#123; //将string转为const char* return m_errorInfo.c_str(); &#125; string m_errorInfo;&#125;;class Person&#123;public: Person(int age) &#123; if (age &lt; 0 || age&gt;150) &#123; throw MyOutOfRangeException(&quot;年龄必须在0-150之间&quot;); &#125; this-&gt;m_Age = age; &#125; int m_Age;&#125;;void test01()&#123; try &#123; Person p(151); &#125; catch (MyOutOfRangeException&amp; e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 编写MyOutOfRange继承Exception 重写virtual const char * what() const 将string转为const char *","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"C++学习 类型转换","slug":"C++-学习-类型转换","date":"2023-06-30T10:04:47.000Z","updated":"2023-07-01T01:42:54.263Z","comments":true,"path":"2023/06/30/C++-学习-类型转换/","link":"","permalink":"http://example.com/2023/06/30/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"类型转换(cast)是一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。 转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。 应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把他看作其他的类型。","text":"类型转换(cast)是一种数据类型转换成另一种数据类型。例如，如果将一个整型值赋给一个浮点类型的变量，编译器会暗地里将其转换成浮点类型。 转换是非常有用的，但是它也会带来一些问题，比如在转换指针时，我们很可能将其转换成一个比它更大的类型，但这可能会破坏其他的数据。 应该小心类型转换，因为转换也就相当于对编译器说：忘记类型检查，把他看作其他的类型。 一般情况下，尽量少的去使用类型转换，除非用来解决非常特殊的问题。 无论什么原因，任何一个程序如果使用很多类型转换都值得怀疑。 标准C++提供了一个显示的转换的语法，来替代旧的C风格的类型转换。 使用C风格的强制转换可以把想要的任何东西转换成我们需要的类型，那为什么还需要一个新的C++类型的强制转换呢？ 新类型的强制转换可以提供给更好的控制强制转换过程，允许控制各种不同种类的强制转换。C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。 静态转换（static_cast） 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。 进行上行转换（把派生类的指针或引用转换成基类表示)是安全的。 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。 用于基本数据类型之间的转换，如把int转换成char，把char转换成int。这种转换的安全性也要开发人员来保证。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;using namespace std;//1、静态类型转换 static_castvoid test01()&#123; //允许内置的数据类型之间的转换 char a = &#x27;a&#x27;; double d = static_cast&lt;double&gt;(a); cout &lt;&lt; d &lt;&lt; endl;&#125;class Base &#123;&#125;;class Son : public Base&#123;&#125;;class Other&#123;&#125;;void test02()&#123; Base* base = NULL; Son* son = NULL; //语法： static_cast&lt;目标类型&gt;(原对象) // //父子之间的指针或者引用可以转换 //将base转为Son* 父转子 向下类型转换 不安全 Son* son2 = static_cast&lt;Son*&gt;(base); //son转为Base* 子转父 向上类型转换 安全 Base* base2 = static_cast&lt;Base*&gt;(son); //base转为Other* //没有父子关系，转换无效 Other* other = static_cast&lt;Other*&gt;(base);&#125;int main()&#123; test01(); test02();&#125; 动态转换(dynamic_cast) dynamic_cast主要用于类层次的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的 在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全 不允许内置数据类型转换 允许父子之间指针或者引用的转换 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;iostream&gt;using namespace std;//1、静态类型转换 static_castvoid test01()&#123; //允许内置的数据类型之间的转换 char a = &#x27;a&#x27;; double d = static_cast&lt;double&gt;(a); cout &lt;&lt; d &lt;&lt; endl;&#125;class Base &#123; virtual void func() &#123;&#125; &#125;;class Son : public Base &#123; virtual void func() &#123;&#125; &#125;;class Other&#123;&#125;;void test02()&#123; Base* base = NULL; Son* son = NULL; //语法： static_cast&lt;目标类型&gt;(原对象) // //父子之间的指针或者引用可以转换 //将base转为Son* 父转子 向下类型转换 不安全 Son* son2 = static_cast&lt;Son*&gt;(base); //son转为Base* 子转父 向上类型转换 安全 Base* base2 = static_cast&lt;Base*&gt;(son); //base转为Other* //没有父子关系，转换无效 //Other* other = static_cast&lt;Other*&gt;(base);&#125;//2、动态类型转换 dynamic_castvoid test03()&#123; //不允许内置数据类型之间的转换 //char c = &#x27;c&#x27;; //double d = dynamic_cast&lt;double&gt;(c);&#125;void test04()&#123; Base* base = new Son; Son* son = NULL; //将base转为Son * 父转子 不安全 转换无效 如果发生了多态，那么转换总是安全的 Son* son2 = dynamic_cast&lt;Son*&gt;(base); //son转为Base* 子转父 安全 Base* base2 = dynamic_cast&lt;Base*&gt;(son); //base转Other* 转换无效 //Other* other = dynamic_cast&lt;Other*&gt;(base);&#125;int main()&#123; test01(); test02(); test03(); test04();&#125; 常量转换(const_cast)该运算符用来修改类型的const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 不能直接对非指针和非引用的变量使用const_cast操作符去直接移除它的cosnt 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;//常量转换void test()&#123; //不可以将非指针或者非引用做const_cast转换 const int* p = NULL; int *pp = const_cast&lt;int*&gt;(p); const int * ppp = const_cast&lt;const int*&gt;(pp); //const int a = 10; //int b = const_cast&lt;int&gt;(a); int num = 10; int&amp; numRef = num; const int&amp; num2 = const_cast&lt;const int&amp;&gt;(numRef);&#125;int main()&#123; test();&#125; 重新解释转换(reinterpret_cast)这是最不安全的一种转换机制，最有可能出问题。 主要用于将一种数据类型从一种类型转换为另一种类型。它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针。 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;class Base &#123; virtual void func() &#123;&#125; &#125;;class Son : public Base &#123; virtual void func() &#123;&#125; &#125;;class Other &#123;&#125;;//重新解释转换 reinterpret_cast最不安全的一种转换，不建议使用void test()&#123; int a = 10; int* p = reinterpret_cast&lt;int*&gt;(a); Base* base = NULL; //base转Other* Other* other = reinterpret_cast&lt;Other*&gt;(base);&#125;int main()&#123; test();&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[]},{"title":"学习 Linux VFS虚拟文件系统","slug":"学习-Linux-VFS虚拟文件系统","date":"2023-06-17T07:02:34.000Z","updated":"2023-07-12T08:28:22.449Z","comments":true,"path":"2023/06/17/学习-Linux-VFS虚拟文件系统/","link":"","permalink":"http://example.com/2023/06/17/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"简介虚拟文件系统 （VFS） 或虚拟文件系统交换机是更具体的文件系统之上的抽象层。VFS 的目的是允许客户端应用程序以统一的方式访问不同类型的具体文件系统。例如，VFS 可用于透明地访问本地和网络存储设备，而客户端应用程序不会注意到差异。 即对于应用程序透明。它可用于弥Windows，经典Mac OS &#x2F; macOS和Unix文件系统之间的差异，以便应用程序可以访问这些类型的本地文件系统上的文件，而不必知道它们正在访问的文件系统类型。 VFS 指定内核和具体文件系统之间的接口（或“协定”）。因此，只需履行协定即可轻松地向内核添加对新文件系统类型的支持。","text":"简介虚拟文件系统 （VFS） 或虚拟文件系统交换机是更具体的文件系统之上的抽象层。VFS 的目的是允许客户端应用程序以统一的方式访问不同类型的具体文件系统。例如，VFS 可用于透明地访问本地和网络存储设备，而客户端应用程序不会注意到差异。 即对于应用程序透明。它可用于弥Windows，经典Mac OS &#x2F; macOS和Unix文件系统之间的差异，以便应用程序可以访问这些类型的本地文件系统上的文件，而不必知道它们正在访问的文件系统类型。 VFS 指定内核和具体文件系统之间的接口（或“协定”）。因此，只需履行协定即可轻松地向内核添加对新文件系统类型的支持。 为了让添加新的文件系统更加容易，并且提供一个通用（generic）的文件API，VFS，一个虚拟文件系统层被加到了linux内核中。 而对于EXT2这样的真实（real）文件系统，是去调用VFS API的。新的文件系统和新类型的存储介质都能找到进入Linux之路，程序无需重写，甚至无需重新编译。 在同一个目录结构中, 可以挂载着若干种不同的文件系统. VFS隐藏了它们的实现细节, 为使用者提供统一的接口; 目录结构本身并不是绝对的, 每个进程可能会看到不一样的目录结构. 目录结构是由”地址空间(namespace)”来描述的, 不同的进程可能拥有不同的namespace, 不同的namespace可能有着不同的目录结构(因为它们可能挂载了不同的文件系统)。 VFS层次结构操作文件的本质是将磁盘文件数据映射到进程中。在这个过程中，涉及以下几个关键步骤： 进程发出文件操作命令：当一个进程需要操作文件时，它会通过系统调用（如sys_open，sys_read，sys_write等）将请求传递给内核。系统调用是用户态进程与内核态代码之间的接口，用户态进程不能直接访问内核态资源，因此通过系统调用请求内核完成相应的操作。 内核数据结构的创建和维护：当内核收到进程的文件操作请求后，会为进程打开的文件和系统文件创建相应的数据结构。主要的数据结构包括： 文件描述符（file descriptor）：一个非负整数，用于唯一标识进程中打开的文件。 文件对象（file object）：在内核中，文件对象与文件描述符关联，存储文件的元数据（如文件位置、访问权限等）。 inode：表示文件在磁盘上的元数据，包括文件类型、大小、权限、时间戳等。 dentry：缓存目录项的数据结构，用于快速查找文件系统中的文件。 虚拟文件系统（VFS）：虚拟文件系统是一种文件系统抽象层，用于统一不同类型的文件系统和I&#x2F;O设备（如磁盘、管道、进程间通信、网络等）的接口。通过VFS，内核可以在不同的文件系统和设备之间提供统一的文件操作接口。 实现虚拟文件系统和实际文件系统的挂载：在VFS层之下，还有诸如ext4、FAT32等各种具体的文件系统实现。这些文件系统通过实现VFS定义的接口与VFS层进行交互。当一个文件系统被挂载到操作系统时，VFS会将文件系统的相关操作映射到对应的实现。 设备驱动接口和缓存：为了与不同类型的硬件设备进行交互，内核提供了设备驱动接口。设备驱动程序负责将文件系统的操作转换为特定硬件设备可以识别的指令。此外，内核还通过缓存技术来加快文件读写的速度。常见的缓存方式有页缓存（page cache）和缓冲区缓存（buffer cache）。 通用文件模型由对象组成：超级块对象、索引节点对象、目录项对象、文件对象。 VFS实现VFS数据结构 三个不同进程已打开同一个文件，其中两个进程使用同一个硬链接。在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引节点对象，这个索引节点对象标识的是超级块对象以及普通磁盘文件。 VFS除了能为所有文件系统的实现提供一个通用接口外，它还具有另一个重要的作用，即提高系统性能。最近最常使用的目录项对象被放在所谓目录项高速缓存（dentry cache）的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。 inode是内核选择用于表示文件内容和相关元数据的方法。理论上，实现这个概念只需要一个数据结构（尽管很长），其中包含了所有必要的数据。实际上，数据分散到一系列较小的、布局清晰的结构中。 超级块super_block存放系统当中已安装文件系统有关信息。对于基于磁盘的文件系统，这类对象通常对应存放在磁盘上的文件系统控制块（每个文件系统都有一个超级块对象）。 是一个全局的数据结构，不管是什么文件系统都有超级块。VFS也有超级块。 fs.h - include&#x2F;linux&#x2F;fs.h - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134struct super_block &#123;//文件系统的整体信息成员如下： struct list_head s_list; /* Keep this first */ //用来将所有超级块实例连接到全局链表super_blocks,指向超级快链表的指针 dev_t s_dev; /* search index; _not_ kdev_t */ //保存文件系统所在的块设备，s_dev保存设备具体文件系统的块设备标识符：/dev/hda1等 unsigned char s_blocksize_bits; //块大小的值所占用的位数 unsigned long s_blocksize; //文件系统中数据库的大小，以字节为单位 loff_t s_maxbytes; /* Max file size */ //文件最大长度 struct file_system_type *s_type; //指向文件系统类型file_system_type数据结构的指针 const struct super_operations *s_op; //指向特定文件系统用于超级快的函数的集合 const struct dquot_operations *dq_op; //指向特定文件系统用于限额操作的函数集合 const struct quotactl_ops *s_qcop; const struct export_operations *s_export_op; unsigned long s_flags; unsigned long s_iflags; /* internal SB_I_* flags */ unsigned long s_magic; struct dentry *s_root; //指向根目录的结构体dentry，将超级块与全局根目录的dentry项关联起来 struct rw_semaphore s_umount; //对超级快读写时进行同步 int s_count; //对超级快的使用计数 atomic_t s_active;#ifdef CONFIG_SECURITY void *s_security;#endif const struct xattr_handler **s_xattr;#ifdef CONFIG_FS_ENCRYPTION const struct fscrypt_operations *s_cop; struct fscrypt_keyring *s_master_keys; /* master crypto keys in use */#endif#ifdef CONFIG_FS_VERITY const struct fsverity_operations *s_vop;#endif#if IS_ENABLED(CONFIG_UNICODE) struct unicode_map *s_encoding; __u16 s_encoding_flags;#endif struct hlist_bl_head s_roots; /* alternate root dentries for NFS */ struct list_head s_mounts; /* list of mounts; _not_ for fs use */ struct block_device *s_bdev; struct backing_dev_info *s_bdi; struct mtd_info *s_mtd; struct hlist_node s_instances; unsigned int s_quota_types; /* Bitmask of supported quota types */ struct quota_info s_dquot; /* Diskquota specific options */ struct sb_writers s_writers; /* * Keep s_fs_info, s_time_gran, s_fsnotify_mask, and * s_fsnotify_marks together for cache efficiency. They are frequently * accessed and rarely modified. */ void *s_fs_info; /* Filesystem private info */ /* Granularity of c/m/atime in ns (cannot be worse than a second) */ u32 s_time_gran; /* Time limits for c/m/atime in seconds */ time64_t s_time_min; time64_t s_time_max;#ifdef CONFIG_FSNOTIFY __u32 s_fsnotify_mask; struct fsnotify_mark_connector __rcu *s_fsnotify_marks;#endif char s_id[32]; /* Informational name */ uuid_t s_uuid; /* UUID */ unsigned int s_max_links; fmode_t s_mode; /* * The next field is for VFS *only*. No filesystems have any business * even looking at it. You had been warned. */ struct mutex s_vfs_rename_mutex; /* Kludge */ /* * Filesystem subtype. If non-empty the filesystem type field * in /proc/mounts will be &quot;type.subtype&quot; */ const char *s_subtype; const struct dentry_operations *s_d_op; /* default d_op for dentries */ struct shrinker s_shrink; /* per-sb shrinker handle */ /* Number of inodes with nlink == 0 but still referenced */ atomic_long_t s_remove_count; /* * Number of inode/mount/sb objects that are being watched, note that * inodes objects are currently double-accounted. */ atomic_long_t s_fsnotify_connectors; /* Being remounted read-only */ int s_readonly_remount; /* per-sb errseq_t for reporting writeback errors via syncfs */ errseq_t s_wb_err; /* AIO completions deferred from interrupt context */ struct workqueue_struct *s_dio_done_wq; struct hlist_head s_pins; /* * Owning user namespace and default context in which to * interpret filesystem uids, gids, quotas, device nodes, * xattrs and security labels. */ struct user_namespace *s_user_ns; /* * The list_lru structure is essentially just a pointer to a table * of per-node lru lists, each of which has its own spinlock. * There is no need to put them into separate cachelines. */ struct list_lru s_dentry_lru; struct list_lru s_inode_lru; struct rcu_head rcu; struct work_struct destroy_work; struct mutex s_sync_lock; /* sync serialisation lock */ /* * Indicates how deep in a filesystem stack this SB is */ int s_stack_depth; /* s_inode_list_lock protects s_inodes */ spinlock_t s_inode_list_lock ____cacheline_aligned_in_smp; struct list_head s_inodes; /* all inodes */ spinlock_t s_inode_wblist_lock; struct list_head s_inodes_wb; /* writeback inodes */&#125; __randomize_layout; s_root将超级块与全局根目录的dentry项关联起来。只有通常可见的文件系统的超级块，才指向&#x2F;（根）目录的dentry实例。具有特殊功能、不出现在通常的目录层次结构中的文件系统（例如，管道或套接字文件系统），指向专门的项，不能通过普通的文件命令访问。 处理文件系统对象的代码经常需要检查文件系统是否已经装载，而s_root可用于该目的。如果它为NULL，则该文件系统是一个伪文件系统，只在内核内部可见。否则，该文件系统在用户空间中是可见的。 所有超级快对象是以双向环形链表形式进行链接在一起。链表中第一个元素和最后一个元素的地址分别存放在super_blocks变量的s_list/next/prev域中 。 types.h - include&#x2F;linux&#x2F;types.h - Linux source code (v6.3.8) - Bootlin 123struct list_head &#123; struct list_head *next, *prev;&#125;; 具体架构如下： 尽管每个文件系统在file_system_type中只出现一次，但在所有超级块实例的链表中，可能有几个同一文件系统类型的超级块实例，因为在各个块设备&#x2F;分区上可能存储了同一类型的几个文件系统。例如，大多数系统都有root和home分区，二者可能在不同的分区上，但通常使用相同类型的文件系统。在file_system_type中，同一文件系统类型只需定义一次，但这两个装载点的超级块不同，虽然都使用了同样的文件系统。 超级块结构的一个重要成员是一个列表，包括相关文件系统中所有修改过的inode（内核相当不敬地称之为脏inode）。根据该列表很容易标识已经修改过的文件和目录，以便将其写回到存储介质。回写必须经过协调，保证在一定程度上最小化开销，因为这是一个非常费时的操作（硬盘、软盘驱动器及其他介质与系统其余组件相比，速度很慢）。另一方面，如果写回修改数据的间隔太长也可能有严重后果，因为系统崩溃（或者，就Linux的情形而言，更可能的是停电）会导致不能恢复的数据丢失。内核会周期性扫描脏块的列表，并将修改传输到底层硬件。 相关函数 sget sget identifier - Linux source code (v6.3.8) - Bootlin 构造函数，如果没有从已经挂载的文件系统找到需要的super_block 就会调用alloc_super分配一个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 定义 sget 函数struct super_block *sget(struct file_system_type *type, int (*test)(struct super_block *,void *), int (*set)(struct super_block *,void *), int flags, void *data)&#123; struct user_namespace *user_ns = current_user_ns(); // 获取当前用户命名空间 struct super_block *s = NULL; // 初始化超级块指针为空 struct super_block *old; // 定义一个用于存储找到的已存在超级块的指针 int err; // 定义一个错误变量 // 检查是否为子挂载，如果是，则将用户命名空间设置为初始用户命名空间 if (flags &amp; SB_SUBMOUNT) user_ns = &amp;init_user_ns;retry: // 重试标签，用于在需要时从此处重新开始执行 spin_lock(&amp;sb_lock); // 获取超级块锁，以防止并发问题 // 如果有 test 回调，那么遍历文件系统类型对应的超级块列表 if (test) &#123; hlist_for_each_entry(old, &amp;type-&gt;fs_supers, s_instances) &#123; // 如果 test 返回 0，继续遍历 if (!test(old, data)) continue; // 如果用户命名空间不匹配，解锁并销毁新创建的超级块，返回错误 if (user_ns != old-&gt;s_user_ns) &#123; spin_unlock(&amp;sb_lock); destroy_unused_super(s); return ERR_PTR(-EBUSY); &#125; // 如果成功获取已存在的超级块引用，跳转到重试标签 if (!grab_super(old)) goto retry; // 销毁新创建的超级块，并返回找到的已存在超级块 destroy_unused_super(s); return old; &#125; &#125; // 如果没有找到匹配的超级块，分配一个新的超级块 if (!s) &#123; spin_unlock(&amp;sb_lock); s = alloc_super(type, (flags &amp; ~SB_SUBMOUNT), user_ns); if (!s) return ERR_PTR(-ENOMEM); goto retry; &#125; // 使用 set 回调初始化新创建的超级块 err = set(s, data); if (err) &#123; spin_unlock(&amp;sb_lock); destroy_unused_super(s); return ERR_PTR(err); &#125; // 设置超级块的文件系统类型和标识符 s-&gt;s_type = type; strlcpy(s-&gt;s_id, type-&gt;name, sizeof(s-&gt;s_id)); // 将新创建的超级块添加到全局超级块列表和文件系统类型的超级块列表中 list_add_tail(&amp;s-&gt;s_list, &amp;super_blocks); hlist_add_head(&amp;s-&gt;s_instances, &amp;type-&gt;fs_supers); spin_unlock(&amp;sb_lock); // 释放超级块锁 get_filesystem(type); // 增加文件系统类型的引用计数 register_shrinker_prepared(&amp;s-&gt;s_shrink); // 注册超级块的缩减器 return s; // 返回新创建的超级块&#125;EXPORT_SYMBOL(sget); put_super put_super identifier - Linux source code (v6.3.8) - Bootlin 析构函数，当引用计数减少到0时才会调用destroy_super 真正释放 1234567// 定义 put_super 函数void put_super(struct super_block *sb)&#123; spin_lock(&amp;sb_lock); // 获取超级块锁，以防止并发问题 __put_super(sb); // 释放超级块的临时引用 spin_unlock(&amp;sb_lock); // 释放超级块锁&#125; super_operations主要包括对inode数据结构的操作，注意不是对inode的操作，对inode的操作由inode_operations来完成。如：alloc_inode、destroy_inode、dirty_inode等等。 还包括文件系统挂载和卸载等操作，如：sync_fs、statfs、remount_fs等等。 所有的函数由VFS调用，都在进程上下文调用，所有的函数都可能阻塞。 super_operations identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233struct super_operations &#123; struct inode *(*alloc_inode)(struct super_block *sb); void (*destroy_inode)(struct inode *); void (*free_inode)(struct inode *); void (*dirty_inode) (struct inode *, int flags); int (*write_inode) (struct inode *, struct writeback_control *wbc); int (*drop_inode) (struct inode *); void (*evict_inode) (struct inode *); void (*put_super) (struct super_block *); int (*sync_fs)(struct super_block *sb, int wait); int (*freeze_super) (struct super_block *); int (*freeze_fs) (struct super_block *); int (*thaw_super) (struct super_block *); int (*unfreeze_fs) (struct super_block *); int (*statfs) (struct dentry *, struct kstatfs *); int (*remount_fs) (struct super_block *, int *, char *); void (*umount_begin) (struct super_block *); int (*show_options)(struct seq_file *, struct dentry *); int (*show_devname)(struct seq_file *, struct dentry *); int (*show_path)(struct seq_file *, struct dentry *); int (*show_stats)(struct seq_file *, struct dentry *);#ifdef CONFIG_QUOTA ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t); ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t); struct dquot **(*get_dquots)(struct inode *);#endif long (*nr_cached_objects)(struct super_block *, struct shrink_control *); long (*free_cached_objects)(struct super_block *, struct shrink_control *);&#125;; VFS索引节点inode存放关于具体文件的一些信息。对于基于磁盘的文件系统，此类对象通常对应用于存放在磁盘上的文件控制块（PCB）。每一个文件都有一个索引节点对象，每一个索引节点对象都有一个索引节点号，唯一标识文件系统中的一个文件。 具体文件系统的索引节点是存储在磁盘上，是一种静态结构，我们要使用它，必须调入内存，填写VFS的索引节点（VFS索引节点是动态节点）。 inode identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* * Keep mostly read-only and often accessed (especially for * the RCU path lookup and &#x27;stat&#x27; data) fields at the beginning * of the &#x27;struct inode&#x27;*/struct inode &#123; umode_t i_mode; /* 文件类型和访问权限 */ unsigned short i_opflags; /* inode 操作标志 */ kuid_t i_uid; /* 文件拥有者的标识号，用户 ID */ kgid_t i_gid; /* 文件拥有者的所在组的标识号，组 ID */ unsigned int i_flags; /* 文件或目录的标志 */#ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; /* 访问控制列表 (ACL) */ struct posix_acl *i_default_acl; /* 默认访问控制列表 */#endif const struct inode_operations *i_op; /* inode 操作函数集 */ struct super_block *i_sb; /* 指向此文件系统超级块的指针 */ struct address_space *i_mapping; /* 文件内容的内存映射 */#ifdef CONFIG_SECURITY void *i_security; /* 安全模块使用的 inode 信息 */#endif /* Stat data, not accessed from path walking */ unsigned long i_ino; /* inode 编号 */ union &#123;//与该节点建立链接的文件数量 const unsigned int i_nlink; /* 硬链接计数 */ unsigned int __i_nlink; &#125;; dev_t i_rdev; /* 实际设备标识号 */ loff_t i_size; /* 文件大小（字节） */ struct timespec64 i_atime; /* 最后访问时间 */ struct timespec64 i_mtime; /* 最后修改时间 */ struct timespec64 i_ctime; /* 最后元数据更改时间 */ spinlock_t i_lock; /* 保护 i_blocks, i_bytes 和可能的 i_size 的锁 */ unsigned short i_bytes; /* 文件末尾未使用的字节数 */ u8 i_blkbits; /* 文件系统块大小的以 2 为底的对数 */ u8 i_write_hint; /* 写操作的优化提示 */ blkcnt_t i_blocks; /* 文件占用的磁盘块数量 */#ifdef __NEED_I_SIZE_ORDERED seqcount_t i_size_seqcount; /* 有序 i_size 的序列计数器 */#endif /* Misc */ unsigned long i_state; /* inode 状态标志 */ struct rw_semaphore i_rwsem; /* 读写信号量，用于保护 inode 结构 */ unsigned long dirtied_when; /* 第一次被脏的时间，以 jiffies 计 */ unsigned long dirtied_time_when; /* 上次被脏的时间，以 jiffies 计 */ struct hlist_node i_hash; /* 散列链表上的节点 */ struct list_head i_io_list; /* 后备设备的 I/O 列表 */#ifdef CONFIG_CGROUP_WRITEBACK struct bdi_writeback *i_wb; /* 关联的 cgroup 写回控制器 */ int i_wb_frn_winner; /* 外部 inode 检测的赢家 */ u16 i_wb_frn_avg_time; /* 外部 inode 的平均时间 */ u16 i_wb_frn_history; /* 外部 inode 的历史记录 */#endif struct list_head i_lru; /* inode LRU 列表 */ struct list_head i_sb_list; /* 超级块列表 */ struct list_head i_wb_list; /* 后备设备写回列表 */ union &#123; struct hlist_head i_dentry; /* 目录项列表 */ struct rcu_head i_rcu; &#125;; atomic64_t i_version; /* inode 版本 */ atomic64_t i_sequence; /* 用于 futex 的序列值 */ atomic_t i_count; /* inode 引用计数 */ atomic_t i_dio_count; /* 直接 I/O 计数 */ atomic_t i_writecount; /* 写计数 */#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING) atomic_t i_readcount; /* 只读打开的文件计数 */#endif union &#123; const struct file_operations *i_fop; /* 以前的 -&gt;i_op-&gt;default_file_ops */ void (*free_inode)(struct inode *); &#125;; struct file_lock_context *i_flctx; /* 文件锁上下文 */ struct address_space i_data; /* inode 的数据缓冲区 */ struct list_head i_devices; /* 设备列表 */ union &#123; struct pipe_inode_info *i_pipe; /* 管道 inode 信息 */ struct cdev *i_cdev; /* 字符设备 */ char *i_link; /* 符号链接的目标路径 */ unsigned i_dir_seq; /* 目录序列计数器 */ &#125;; __u32 i_generation; /* inode 生成计数器 */#ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* inode 关心的所有事件 */ struct fsnotify_mark_connector __rcu *i_fsnotify_marks; /* 文件系统通知标记连接器 */#endif#ifdef CONFIG_FS_ENCRYPTION struct fscrypt_info *i_crypt_info; /* 文件系统加密信息 */#endif#ifdef CONFIG_FS_VERITY struct fsverity_info *i_verity_info; /* 文件系统完整性信息 */#endif void *i_private; /* 文件系统或设备的私有指针 */&#125; __randomize_layout; 每一个文件都有一个inode，每个inode都有一个索引节点号i_ino。在同一个文件系统时每个索引节点号都是唯一的，内核有时候根据索引节点号的哈希值查找其inode结构。 相关函数 new_inode 构造函数，调用alloc_inode从inode_cachep分配索引节点 new_inode identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324/** * new_inode - obtain an inode * @sb: superblock * * Allocates a new inode for given superblock. The default gfp_mask * for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE. * If HIGHMEM pages are unsuitable or it is known that pages allocated * for the page cache are not reclaimable or migratable, * mapping_set_gfp_mask() must be called with suitable flags on the * newly created inode&#x27;s mapping * */struct inode *new_inode(struct super_block *sb)&#123; struct inode *inode; spin_lock_prefetch(&amp;sb-&gt;s_inode_list_lock); inode = new_inode_pseudo(sb); if (inode) inode_sb_list_add(inode); return inode;&#125;EXPORT_SYMBOL(new_inode); inode_operationsinode_operations identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct inode_operations &#123; struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *); int (*permission) (struct mnt_idmap *, struct inode *, int); struct posix_acl * (*get_inode_acl)(struct inode *, int, bool); int (*readlink) (struct dentry *, char __user *,int); int (*create) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t, bool); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct mnt_idmap *, struct inode *,struct dentry *, const char *); int (*mkdir) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t); int (*rmdir) (struct inode *,struct dentry *); int (*mknod) (struct mnt_idmap *, struct inode *,struct dentry *, umode_t,dev_t); int (*rename) (struct mnt_idmap *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int); int (*setattr) (struct mnt_idmap *, struct dentry *, struct iattr *); int (*getattr) (struct mnt_idmap *, const struct path *, struct kstat *, u32, unsigned int); ssize_t (*listxattr) (struct dentry *, char *, size_t); int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start, u64 len); int (*update_time)(struct inode *, struct timespec64 *, int); int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned open_flag, umode_t create_mode); int (*tmpfile) (struct mnt_idmap *, struct inode *, struct file *, umode_t); struct posix_acl *(*get_acl)(struct mnt_idmap *, struct dentry *, int); int (*set_acl)(struct mnt_idmap *, struct dentry *, struct posix_acl *, int); int (*fileattr_set)(struct mnt_idmap *idmap, struct dentry *dentry, struct fileattr *fa); int (*fileattr_get)(struct dentry *dentry, struct fileattr *fa);&#125; ____cacheline_aligned; 目录项dentry存放目录项与对应文件进行链接的信息，VFS把每个目录看作一个由若干个子目录和文件组成的常规文件。 每个文件除了有一个索引节点inode数据结构之外，还有一个目录项dentry（directory entry）数据结构。 dentry identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* 目录项的标志位，受 d_lock 保护 */ seqcount_spinlock_t d_seq; /* 每个目录项的序列锁 */ struct hlist_bl_node d_hash; /* 目录项形成的用于查找的哈希列表 */ struct dentry *d_parent; /* 父目录的目录项dentry */ struct qstr d_name; /* 目录项的名称（可以快速查找） */ struct inode *d_inode; /* 与文件名称关联的，与目录名关联的 inode 结构指针，NULL 表示负目录项 */ unsigned char d_iname[DNAME_INLINE_LEN]; /* 短文件名称 */ /* Ref lookup also touches following */ struct lockref d_lockref; /* 每个目录项的锁和引用计数 */ const struct dentry_operations *d_op; /* 目录项操作函数集 */ struct super_block *d_sb; /* 目录项树的根节点（即文件的超级块） */ unsigned long d_time; /* 用于 d_revalidate 的时间戳 */ void *d_fsdata; /* 特定文件系统的数据 */ union &#123; struct list_head d_lru; /* LRU（最近最少使用）列表 */ wait_queue_head_t *d_wait; /* 仅用于查找中的目录项 */ &#125;; struct list_head d_child; /* 父目录项的子项列表 */ struct list_head d_subdirs; /* 子目录项列表 */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode 别名列表 */ struct hlist_bl_node d_in_lookup_hash; /* 仅用于查找中的目录项 */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; 各个dentry实例组成了一个网络，与文件系统的结构形成一定的映射关系。与给定目录下的所有文件和子目录相关联的dentry实例，都归入到d_subdirs链表（在目录对应的dentry实例中）。子结点的d_child成员充当链表元素。 dentry结构的主要用途是建立文件名和相关的inode之间的关联。结构中有3个成员用于该目的。 d_inode是指向相关的inode实例的指针。 如果dentry对象是为一个不存在的文件名建立的，则d_inode为NULL指针。这有助于加速查找不存在的文件名，通常情况下，这与查找实际存在的文件名同样耗时。 d_name指定了文件的名称。qstr是一个内核字符串的包装器。它存储了实际的char *字符串以及字符串长度和散列值，这使得更容易处理查找工作。 d_op指向一个结构，其中包含了各种函数指针，提供对dentry对象的各种操作。这些操作必须由底层文件系统实现。 s_sb是一个指针，指向dentry对象所属文件系统超级块的实例。该指针使得各个dentry实例散布到可用的（已装载的）文件系统。由于每个超级块结构都包含了一个指针，指向该文件系统装载点对应目录的dentry实例，因此dentry组成的树可以划分为几个子树。 d_flags可以包含几个标志，标志在include&#x2F;linux&#x2F;dcache.h中定义。但其中只有两个与我们的目的相关：DCACHE_DISCONNECTED指定一个dentry当前没有连接到超级块的dentry树。DCACHE_UNHASHED表明该dentry实例没有包含在任何inode的散列表中。要注意，这两个标志是彼此完全独立的。 d_parent是一个指针，指向当前结点父目录的dentry实例，当前的dentry实例即位于父目录的。 d_subdirs链表中。对于根目录（没有父目录），d_parent指向其自身的dentry实例。当前dentry对象表示一个装载点，那么d_mounted设置为1；否则其值为0。 d_alias用作链表元素，以连接表示相同文件的各个dentry对象。在利用硬链接用两个不同名称表示同一文件时，会发生这种情况。对应于文件的inode的i_dentry成员用作该链表的表头。各个dentry对象通过d_alias连接到该链表中。 但其中并非完全映射文件系统的拓扑结构，因为dentry缓存只包含文件系统结构的一小部分。 最常用文件和目录对应的目录项才保存在内存中。原则上，可以为所有文件系统对象都生成dentry项，但物理内存空间和性能原因都限制了这样做。 dentry数据结构代表的是逻辑意义上的文件，所描述的是文件逻辑上的属性，目录项对象在磁盘上并没有对应的映像，而inode数据结构代表的是物理意义上的文件，记录的是物理上的属性，对于一个具体的文件系统（ex2&#x2F;3&#x2F;4等），ext3_inode结构在磁盘上就有对应的映像。一个索引节点对象可能对应多个目录项对象。 每个目录项对象属于一下四种状态之一 空闲状态（free） 处于该状态的目录项对象不包含有效的信息，还没有被VFS使用。它对应的内存区由slab分配器进行管理。 未使用状态（unused） 处于该状态的目录项对象当前还没有被内核使用。该对象的引用计数器d_count的值为NULL。但其d_inode域仍然指向相关的索引节点。该目录项对象包含有效的信息，但为了在必要时回收内存，它的内容可能被丢弃。 正在使用状态（inuse） 处于该状态的目录项对象当前正在被内核使用，该对象的引用计数器d_count的值为正数，而其d_inode域指向相关的索引节点对象。该目录项对象包含有效的信息，并且不能被丢弃。 负状态（negative） 与目录项相关的索引节点不复存在，那是因为相应的磁盘索引节点已被删除。该目录项对象的d_inode域被置为NULL，但该对象仍然被保存在目录项高速缓存中，以便后续对同一文件目录名的查找操作能够快速完成。 相关函数 d_alloc 构造函数，从dentry_cache分配一个negative目录项 123456789101112131415161718192021222324252627/** * d_alloc - allocate a dcache entry * @parent: parent of entry to allocate * @name: qstr of the name * * Allocates a dentry. It returns %NULL if there is insufficient memory * available. On a success the dentry is returned. The name passed in is * copied and the copy passed in may be reused after this call. */struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)&#123; struct dentry *dentry = __d_alloc(parent-&gt;d_sb, name); if (!dentry) return NULL; spin_lock(&amp;parent-&gt;d_lock); /* * don&#x27;t need child lock because it is not subject * to concurrency here */ __dget_dlock(parent); dentry-&gt;d_parent = parent; list_add(&amp;dentry-&gt;d_child, &amp;parent-&gt;d_subdirs); spin_unlock(&amp;parent-&gt;d_lock); return dentry;&#125;EXPORT_SYMBOL(d_alloc); dput 析够函数，当引用计数为0时调用dentry_kill释放目录项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * This is dput * * This is complicated by the fact that we do not want to put * dentries that are no longer on any hash chain on the unused * list: we&#x27;d much rather just get rid of them immediately. * * However, that implies that we have to traverse the dentry * tree upwards to the parents which might _also_ now be * scheduled for deletion (it may have been only waiting for * its last child to go away). * * This tail recursion is done by hand as we don&#x27;t want to depend * on the compiler to always get this right (gcc generally doesn&#x27;t). * Real recursion would eat up our stack space. *//* * dput - release a dentry * @dentry: dentry to release * * Release a dentry. This will drop the usage count and if appropriate * call the dentry unlink method as well as removing it from the queues and * releasing its resources. If the parent dentries were scheduled for release * they too may now get deleted. */void dput(struct dentry *dentry)&#123; while (dentry) &#123; // 当 dentry 非空时，进入循环 might_sleep(); // 检查是否可以安全地睡眠 rcu_read_lock(); // 获取 RCU 读锁 if (likely(fast_dput(dentry))) &#123; // 如果 fast_dput 返回 true，说明 dentry 的引用计数已减少 rcu_read_unlock(); // 释放 RCU 读锁 return; // 返回，结束函数 &#125; // slow case: 现在持有 dentry 锁 rcu_read_unlock(); // 释放 RCU 读锁 if (likely(retain_dentry(dentry))) &#123; // 如果 retain_dentry 返回 true，说明 dentry 应保留 spin_unlock(&amp;dentry-&gt;d_lock); // 解锁 dentry return; // 返回，结束函数 &#125; dentry = dentry_kill(dentry); // 删除 dentry，返回其父 dentry &#125;&#125;EXPORT_SYMBOL(dput); dentry_operations由于dentry主要供VFS使用，所以操作集中的函数一般情况下也不需要具体文件系统去实现。这里的函数是针对dentry的操作，如d_revalidate、d_hash、d_compare、d_delete、 d_release、d_prune等等。 比较容易混淆的是d_delete和d_prune，前者只是判断是否需要delete，如果要delete就会释放dentry，否则会将dentry加入到LRU，而后者是在unhash前的最后一步动作，当然一般也不需要实现。而d_release只会在最后调用，它负责释放内存。 dentry_operations identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213141516struct dentry_operations &#123; int (*d_revalidate)(struct dentry *, unsigned int); int (*d_weak_revalidate)(struct dentry *, unsigned int); int (*d_hash)(const struct dentry *, struct qstr *); int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *); int (*d_delete)(const struct dentry *); int (*d_init)(struct dentry *); void (*d_release)(struct dentry *); void (*d_prune)(struct dentry *); void (*d_iput)(struct dentry *, struct inode *); char *(*d_dname)(struct dentry *, char *, int); struct vfsmount *(*d_automount)(struct path *); int (*d_manage)(const struct path *, bool); struct dentry *(*d_real)(struct dentry *, const struct inode *);&#125; ____cacheline_aligned; 文件file存放打开文件与进程之间交互的有关信息。这类信息仅仅是在进程访问文件期间存在于内存的。文件对象表示进程已打开的文件，如果我们站在用户角度来看待VFS，文件对象会首先进入我们的视野。进程直接处理的是文件，而不是超级块、索引节点或目录项。文件对象由相应的open（）系统调用创建，由close（）系统调用撤销。file也是files_struct定义时用到的一个结构。 file identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041struct file &#123; union &#123; struct llist_node f_llist; struct rcu_head f_rcuhead; unsigned int f_iocb_flags; &#125;; // 定义一个联合体，用于节省空间。联合体中只有一个成员会被实际使用。 struct path f_path; // 文件路径 包含目录项 struct inode *f_inode; /* 缓存的值 */ const struct file_operations *f_op; // 文件操作函数指针 /* * 保护 f_ep 和 f_flags 的自旋锁。 * 不得在 IRQ 上下文中使用。 */ spinlock_t f_lock; atomic_long_t f_count; // 文件引用计数 unsigned int f_flags; // 文件标志 fmode_t f_mode; // 文件模式 struct mutex f_pos_lock; // 用于保护文件位置的互斥锁 loff_t f_pos; // 文件位置 struct fown_struct f_owner; // 文件所有者 const struct cred *f_cred; // 指向文件凭证的指针 struct file_ra_state f_ra; // 文件读取状态 u64 f_version; // 文件版本#ifdef CONFIG_SECURITY void *f_security; // 指向文件安全结构的指针#endif /* 需要用于 tty 驱动程序，以及其他可能需要的程序 */ void *private_data; // 私有数据指针#ifdef CONFIG_EPOLL /* 由 fs/eventpoll.c 使用，将所有钩子链接到此文件 */ struct hlist_head *f_ep;#endif /* #ifdef CONFIG_EPOLL */ struct address_space *f_mapping; // 文件映射地址空间 errseq_t f_wb_err; // 写回错误序列 errseq_t f_sb_err; // 用于 syncfs 的超级块错误序列&#125; __randomize_layout __attribute__((aligned(4))); /* 以防某些奇怪的设备认为 2 是合适的对齐方式 */ f_path封装了下面两部分信息： 文件名和inode之间的关联（dentry） path identifier - Linux source code (v6.3.8) - Bootlin 1234struct path &#123; struct vfsmount *mnt; struct dentry *dentry;&#125; __randomize_layout; file_operations123456789101112131415161718192021222324252627282930313233343536373839404142434445struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *, unsigned int flags); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); unsigned long mmap_supported_flags; int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, loff_t, loff_t, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **, void **); long (*fallocate)(struct file *file, int mode, loff_t offset, loff_t len); void (*show_fdinfo)(struct seq_file *m, struct file *f);#ifndef CONFIG_MMU unsigned (*mmap_capabilities)(struct file *);#endif ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int); loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, struct file *file_out, loff_t pos_out, loff_t len, unsigned int remap_flags); int (*fadvise)(struct file *, loff_t, loff_t, int); int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags); int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int poll_flags);&#125; __randomize_layout; 索引节点&#x2F;目录&#x2F;块-高速缓存 索引节点inode高速缓存 加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中所有的索引节点（inode），可以避免频繁从磁盘读取索引节点信息） 目录项dentry高速缓存 加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中所有已经打开的目录项，可以避免频繁地从硬盘中读取目录项信息）。例如。我们经常需要编辑文件，随后进行编译或编辑，然后打印或拷贝，再进行编辑，诸如此类的情况中，同一个文件需要被反复访问。 目录项高速缓存由两种类型的数据结构组成： 处于正在使用，未使用或负状态的目录项对象的集合。 一个散列表，从中能够快速获取与给定文件名和目录名对应的目录项对象，如果访问的对象不在目录项高速缓存中，散列函数返回一个空值。 目录项高速缓存的作用也相当于索引节点高速缓存（inode cache）的控制器。内核内存中，与未使用目录项相关的索引节点未被丢弃，这是由于目录项高速缓存仍在使用他们，因此，它们的i_count域不为空。因此，这些索引节点对象保存在RAM中，并能够借助相应的目录项快速引用他们。 所有“未使用unused”的目录项都存放在一个“最近最少使用（LRU：Least Recently Used）”的双向链表中，该链表按照插入的时间排序。换句话说，最后释放的目录项对象放在链表的首部，所以最近最少使用的目录项总是靠近链表的尾部。一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得多数最近经常使用的对象得以保留。LRU链表的首元素和尾元素的地址存放在变量dentry_unused中的next域和prev域。目录项对象的d_lcu域包含的指针指向该链表中相邻目录的对象。 每个“正在使用inuse”的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的i_dentry域所指向（由于每个索引节点可能与若干硬链接关联，所以需要一个链表）。目录项对象的d_alias域存放链表中相邻元素的地址。这两个域的类型都是struct list_head。 当指向相应文件的最后一个硬链接被删除后，一个“正在使用inuse”的目录项对象可能变成“负negative”状态。在这种情况下，该目录项对象被移到“未使用unused”目录项对象组成的LRU链表中。每当内核缩减目录项高速缓存时，“负negative”状态目录项对象就朝着LRU链表的尾部移动。这样一来，这些对象就逐渐被释放。 散列表是由dentry_hashtable数组实现的。数组中每个元素是一个指向链表的指针，这种链表就是把具有相同散列表值得目录项进行散列而形成得。该数组得长度取决于系统已安装RAM的数量。目录项对象的d_hash域包含指向具有相同散列值的链表中的相邻元素。散列函数产生的值是由目录及文件名的目录项对象的地址计算出来的。 块高速缓存 加快文件系统操作速度的缓存机制（内存缓存，保存文件系统中已经读取过的块数据block，有效避免频繁从硬盘读取数据）。块高速缓存只适用于数据进行顺序访问的情况，如果对数据进行随机访问，导致大量无效的缓存命中和未命中反而降低性能。 Ext格式和目录存储以及文件缓存 Ext文件系统：基于磁盘的文件系统，支持多个磁盘分区和超过2TB的大容量磁盘，主要版本：Ex2&#x2F;Ex3&#x2F;Ex4 目录存储：指在文件系统中用于组织和存储文件的一种层次结构。在Linux系统当中，所有的文件都存放在根目录（&#x2F;）下或其子目录下 ，而这些目录则以特定方式组织起来，形成一个层次化的目录结构，Linux文件系统采用树形结构组织文件和目录。 12345/bin 可执行二进制文件/dev 设备文件/etc 配置文件/lib 库文件/tmp 临时文件 文件缓存： 系统将硬盘上的文件暂时存在内存当中以提高访问效率的一种机制。 每一个inode结构与文件相关联所有元数据信息（创建事件，文件大小等)。 比如在实际应用：写操作时，也可以将需要写入硬盘数据暂存到页高速缓存当中，并延迟实际写入硬盘的事件（延迟写），提升性能和减少I&#x2F;O负载，当需要刷新缓存并将数据同步回到硬盘时，直接调用sync&#x2F;fsnc函数来完成。 mount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; // 用于挂载点哈希表的链表节点 struct mount *mnt_parent; // 指向父挂载点的指针 struct dentry *mnt_mountpoint; // 指向挂载点位置的目录入口（dentry） struct vfsmount mnt; // 包含挂载文件系统相关信息的vfsmount结构体 union &#123; struct rcu_head mnt_rcu; // 用于RCU（Read-Copy-Update）同步的链表头 struct llist_node mnt_llist; // 用于延迟列表（llist）的链表节点 &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp; // 指向每个CPU的mnt_pcp结构体的指针（仅在多处理器系统中使用）#else int mnt_count; // 挂载点的引用计数 int mnt_writers; // 写入操作的计数器#endif struct list_head mnt_mounts; // 子挂载点列表的链表头 struct list_head mnt_child; // 与mnt_mounts链表相连的链表节点 struct list_head mnt_instance; // 超级块的s_mounts链表上的挂载实例列表节点 const char *mnt_devname; // 设备名称，如 /dev/dsk/hda1 struct list_head mnt_list; // 全局挂载点列表的链表节点 struct list_head mnt_expire; // 特定文件系统的过期列表的链表节点 struct list_head mnt_share; // 共享挂载点的循环列表链表头 struct list_head mnt_slave_list; // 从属挂载点的链表头 struct list_head mnt_slave; // 与mnt_slave_list链表相连的链表节点 struct mount *mnt_master; // 指向主挂载点的指针，从属挂载点位于master-&gt;mnt_slave_list struct mnt_namespace *mnt_ns; // 包含此挂载点的命名空间 struct mountpoint *mnt_mp; // 指向挂载点位置的mountpoint结构体 union &#123; struct hlist_node mnt_mp_list; // 具有相同挂载点的挂载列表链表节点 struct hlist_node mnt_umount; // 用于卸载操作的链表节点 &#125;; struct list_head mnt_umounting; // 用于卸载传播的链表节点#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; // 指向文件系统通知标记的指针 __u32 mnt_fsnotify_mask; // 文件系统通知的掩码#endif int mnt_id; // 挂载点的唯一标识符 int mnt_group_id; // 同级挂载组的唯一标识符 int mnt_expiry_mark; // 如果已标记为过期，则为true struct hlist_head mnt_pins; // 用于记录挂载点引脚的链表头 struct hlist_head mnt_stuck_children; // 被卡住的子挂载点列表的链表头&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 文件系统数据结构file_system_typefile_system_type identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132struct file_system_type &#123; const char *name; // 文件系统的名称 int fs_flags; // 文件系统的标识位 // 文件系统标识位的定义#define FS_REQUIRES_DEV 1 // 文件系统需要一个设备#define FS_BINARY_MOUNTDATA 2 // 文件系统的挂载数据是二进制格式#define FS_HAS_SUBTYPE 4 // 文件系统具有子类型#define FS_USERNS_MOUNT 8 // 可以由用户命名空间的根目录挂载#define FS_DISALLOW_NOTIFY_PERM 16 // 禁止 fanotify 权限事件#define FS_ALLOW_IDMAP 32 // 文件系统已更新以处理 VFS ID 映射#define FS_RENAME_DOES_D_MOVE 32768 // 在 rename() 期间，文件系统将内部处理 d_move() int (*init_fs_context)(struct fs_context *); // 初始化文件系统上下文的函数指针 const struct fs_parameter_spec *parameters; // 文件系统参数的指针 // 挂载文件系统的函数指针 struct dentry *(*mount) (struct file_system_type *, int, const char *, void *); void (*kill_sb) (struct super_block *); // 销毁超级块的函数指针 struct module *owner; // 指向文件系统所属模块的指针 struct file_system_type * next; // 指向下一个文件系统类型的指针 struct hlist_head fs_supers; // 用于存放文件系统超级块的哈希链表头 // 以下为各种锁的定义 struct lock_class_key s_lock_key; // 超级块锁的键 struct lock_class_key s_umount_key; // 卸载锁的键 struct lock_class_key s_vfs_rename_key; // VFS 重命名锁的键 struct lock_class_key s_writers_key[SB_FREEZE_LEVELS]; // 写入者锁的键数组 struct lock_class_key i_lock_key; // inode 锁的键 struct lock_class_key i_mutex_key; // inode 互斥量的键 struct lock_class_key invalidate_lock_key; // 使 inode 无效的锁的键 struct lock_class_key i_mutex_dir_key; // 目录 inode 互斥量的键&#125;; file_system_type用来描述各种特定文件系统类型。每种文件系统，不管有多少个实例安装到系统中，还是根本没有安装到系统中，都只有一个file_system结构。 name保存了文件系统的名称，是一个字符串（因此包含了例如reiserfs、ext3等类似的值）。fs_flags是使用的标志，例如标明只读装载、禁止setuid&#x2F;setgid操作或进行其他的微调。owner是一个指向module结构的指针，仅当文件系统以模块形式加载时，owner才包含有意义的值（NULL指针表示文件系统已经持久编译到内核中）。各个可用的文件系统通过next成员连接起来，这里无法利用标准的链表功能，因为这是一个单链表。 mountmount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; struct mount *mnt_parent; struct dentry *mnt_mountpoint; struct vfsmount mnt; union &#123; struct rcu_head mnt_rcu; struct llist_node mnt_llist; &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp;#else int mnt_count; int mnt_writers;#endif struct list_head mnt_mounts; /* list of children, anchored here */ struct list_head mnt_child; /* and going through their mnt_child */ struct list_head mnt_instance; /* mount instance on sb-&gt;s_mounts */ const char *mnt_devname; /* Name of device e.g. /dev/dsk/hda1 */ struct list_head mnt_list; struct list_head mnt_expire; /* link in fs-specific expiry list */ struct list_head mnt_share; /* circular list of shared mounts */ struct list_head mnt_slave_list;/* list of slave mounts */ struct list_head mnt_slave; /* slave list entry */ struct mount *mnt_master; /* slave is on master-&gt;mnt_slave_list */ struct mnt_namespace *mnt_ns; /* containing namespace */ struct mountpoint *mnt_mp; /* where is it mounted */ union &#123; struct hlist_node mnt_mp_list; /* list mounts with the same mountpoint */ struct hlist_node mnt_umount; &#125;; struct list_head mnt_umounting; /* list entry for umount propagation */#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; __u32 mnt_fsnotify_mask;#endif int mnt_id; /* mount identifier */ int mnt_group_id; /* peer group identifier */ int mnt_expiry_mark; /* true if marked for expiry */ struct hlist_head mnt_pins; struct hlist_head mnt_stuck_children;&#125; __randomize_layout; vfsmountvfsmount identifier - Linux source code (v6.3.8) - Bootlin 123456struct vfsmount &#123; struct dentry *mnt_root; // 指向已挂载文件系统树的根目录入口（dentry结构体） struct super_block *mnt_sb; // 指向与已挂载文件系统关联的超级块（super_block结构体） int mnt_flags; // 挂载标志，表示挂载时的选项，如只读、异步等 struct mnt_idmap *mnt_idmap; // 指向一个mnt_idmap结构体，用于存储用户和组ID的映射关系（仅在某些文件系统中使用，如NFS）&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 当文件系统被实际安装到系统中，将有一个vfsmount结构体在安装点被创建，该结构体用来代表文件系统的实例-换句话说，代表一个安装点。理清文件系统和所有其他安装点之间的关系，是维护所有安装点链表中最复杂的工作。所以vfsmount结构体中维护的各种链表就是为了能够跟踪这些关联信息。文件系统本身的相对根目录所对应的dentry保存在mnt_root中。mnt_sb指针建立了与相关的超级块之间的关联（对每个装载的文件系统而言，都有且只有一个超级块实例）。在nmt_flags可以设置各种独立于文件系统的标志。 mountpointmountpoint identifier - Linux source code (v6.3.8) - Bootlin 123456struct mountpoint &#123; struct hlist_node m_hash; struct dentry *m_dentry; struct hlist_head m_list; int m_count;&#125;; vfs命名空间VFS命名空间是所有已经装载、构成某个容器目录树的文件系统的集合。 通常调用fork或clone建立的进程会继承其父进程的命名空间。但可以设置CLONE_NEWNS标志，以建立一个新的VFS命名空间（在下文中，我不再区分VFS命名空间和命名空间，当然内核也提供了非VFS的命名空间。如果修改新的命名空间，改变不会传播到属于不同命名空间的进程。对其他命名空间的改变也不会影响新的命名空间。 struct task_struct包含的成员nsproxy，该成员负责命名空间的处理。 nsproxy identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627/* * 一个结构体,包含指向每个进程命名空间的指针 * - fs(挂载),uts,网络,sysvipc 等。 * * pid 命名空间是一个例外 - 它通过 task_active_pid_ns 访问。 * 这里的 pid 命名空间是子进程将使用的命名空间。 * * &#x27;count&#x27; 是持有引用的任务数。 * 因此,每个命名空间的计数将是指向它的 nsproxy 数,而不是任务数。 * * nsproxy 由共享所有命名空间的任务共享。 * 一旦单个命名空间被克隆或取消共享,nsproxy 就会被复制。 */ struct nsproxy &#123; atomic_t count; /*原子计数器*/ struct uts_namespace *uts_ns; /*UTS命名空间结构体指针*/ struct ipc_namespace *ipc_ns; /*IPC命名空间结构体指针*/ struct mnt_namespace *mnt_ns; /*挂载命名空间结构体指针*/ struct pid_namespace *pid_ns_for_children; /*子进程使用的PID命名空间结构体指针*/ struct net *net_ns; /*网络命名空间结构体指针*/ struct time_namespace *time_ns; /*时间命名空间结构体指针*/ struct time_namespace *time_ns_for_children; /*子进程使用的时间命名空间结构体指针*/ struct cgroup_namespace *cgroup_ns; /*cgroup命名空间结构体指针*/&#125;;extern struct nsproxy init_nsproxy; /*外部变量:初始的nsproxy*/ 实现VFS命名空间所需信息的数量相对很少： mnt_namespace identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718struct mnt_namespace &#123; struct ns_common ns; /*命名空间通用结构*/ struct mount * root; /*根挂载点指针*/ /* * 遍历和修改 .list 是通过两种方式保护的: * - 以写方式获取namespace_sem, 或者 * - 以读方式获取namespace_sem AND 获取 .ns_lock. */ struct list_head list; /*链表头*/ spinlock_t ns_lock; /*自旋锁*/ struct user_namespace *user_ns; /*用户命名空间指针*/ struct ucounts *ucounts; /*引用计数器*/ u64 seq; /*序列号,用于防止循环*/ wait_queue_head_t poll; /*等待队列头*/ u64 event; unsigned int mounts; /*命名空间中的挂载数*/ unsigned int pending_mounts; /*待定挂载数*/ &#125; __randomize_layout; /*随机布局*/ 进程相关数据结构系统中的每一个进程都有自己的一组打开的文件，像根文件系统，当前工作目录，安装点等。有三个数据结构将VFS层和系统的进程紧密联系在一起，它们分别是：files_struct、fs_struct、namespace结构体。 文件描述符（就是整数）用于在一个进程内唯一地标识打开的文件。这假定了内核能够在用户进程中的描述符和内核内部使用的结构之间，建立一种关联。每个进程的task_struct中包含了用于完成该工作的成员。 task_structtask_struct identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213struct task_struct &#123;.../* 文件系统信息 */int link_count, total_link_count;.../* 文件系统信息 */struct fs_struct *fs;/* 打开文件信息 */struct files_struct *files;/* 命名空间 */struct nsproxy *nsproxy;...&#125; 文件描述符（就是整数）用于在一个进程内唯一地标识打开的文件。这假定了内核能够在用户进程中的描述符和内核内部使用的结构之间，建立一种关联。每个进程的task_struct中包含了用于完成该工作的成员。 进程的文件系统相关数据保存在fs中。这些数据包含，例如当前工作目录和chroot限制有关的信息。整数成员link_count和total_link_count用于在查找环形链表时防止无限循环。 由于内核允许同时运行多个模仿独立系统的容器，从容器角度看似“全局”的每个资源，都由内核包装起来，分别根据每个容器进行管理。虚拟文件系统也受到影响，因为各个容器可能因装载点的不同导致不同的目录层次结构。对应的信息包含在ns_proxy-&gt;mnt_namespace中。 files_structfiles_struct identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223/* * 打开的文件表结构 */ struct files_struct &#123; /* * 主要读取部分 */ atomic_t count; //原子计数器，共享该表的进程数目 bool resize_in_progress; //重新调整进度 wait_queue_head_t resize_wait; //等待重新调整队列 struct fdtable __rcu *fdt; //文件描述符表 struct fdtable fdtab; /* * SMP上单独的缓存线中的写入部分 */ spinlock_t file_lock ____cacheline_aligned_in_smp; //文件锁 unsigned int next_fd; //下一个文件描述符 unsigned long close_on_exec_init[1]; //执行时关闭的初始化 unsigned long open_fds_init[1]; //打开的文件描述符初始化 unsigned long full_fds_bits_init[1]; //完整文件描述符位的初始化 struct file __rcu * fd_array[NR_OPEN_DEFAULT]; //文件描述符数组 &#125;; next_fd表示下一次打开新文件时使用的文件描述符。close_on_exec_init和open_fds_init是位图。对执行exec时将关闭的所有文件描述符，在close_on_exec中对应的比特位都将置位。open_fds_init是最初的文件描述符集合。 fd_array的每个数组项都是一个指针，指向每个打开文件的struct file实例，稍后我会讨论该结构。默认情况下，内核允许每个进程打开NR_OPEN_DEFAULT个文件。该值定义在NR_OPEN_DEFAULT identifier - Linux source code (v6.3.8) - Bootlin中，默认值为BITS_PER_LONG。因此在32位系统上，允许打开文件的初始数目是32。64位系统可以同时处理64个文件。如果一个进程试图同时打开更多的文件，内核必须对files_struct中用于管理与进程相关的所有文件信息的各个成员，分配更多的内存空间。最重要的信息包含在fdtab中。内核为此定义了另一个数据结构fdtable。 fdtablefdtable identifier - Linux source code (v6.3.8) - Bootlin 12345678struct fdtable &#123; unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu;&#125;; struct files_struct中包含了该结构的一个实例和指向一个实例的指针，因为这里使用了RCU机制以便在无需锁定的情况下读取这些数据结构，这可以加速处理。在讨论具体的做法前，我们需要介绍各个成员的语义。 max_fds指定了进程当前可以处理的文件对象和文件描述符的最大数目。这里没有固有的上限，因为这两个值都可以在必要时增加（只要没有超出由Rlimit指定的值，但这与文件结构无关）。尽管内核使用的文件对象和文件描述符的数目总是相同的，但必须定义不同的最大数目。这归因于管理相关数据结构的方法。我会在下文解释这一点，但首先必须阐明该结构剩余成员的语义。 fd是一个指针数组，每个数组项指向一个file结构的实例，管理一个打开文件的所有信息。用户空间进程的文件描述符充当数组索引。该数组当前的长度由max_fds定义。 open_fds是一个指向位域的指针，该位域管理着当前所有打开文件的描述符。每个可能的文件描述符都对应着一个比特位。如果该比特位置位，则对应的文件描述符处于使用中；否则该描述符未使用。当前比特位置的最大数目由max_fdset指定。 close_on_exec也是一个指向位域的指针，该位域保存了所有在exec系统调用时将要关闭的文件描述符的信息。 fs_structfs_struct identifier - Linux source code (v6.3.8) - Bootlin 主要就是一个file指针数组，我们通常说的文件描述符是一个整数，而这个整数正好可以作为下标，从而从files_struct中获得file结构。具体查找是通过fdt-&gt;fd[fd]来找到对应的file。 12345678struct fs_struct &#123; int users; spinlock_t lock; seqcount_spinlock_t seq; int umask; int in_exec; struct path root, pwd;&#125; __randomize_layout; fdt 默认是指向fdtab的，当打开的文件数目比较多的时候，就需要重新分配一个fdtable，并增大其fd数组和打开位图，然后将这个fdt指向新分配的fdtable。原来fdt所指向的内存会复制到新的fdtable。 至于如何判断fdt是否指向动态fdtable，也就是最后是否需要释放fdt所指向的内存，可以通过判断fdt和fdtab的地址是否相等来确定。 file_lock 保护对file_struct的修改。 从文件描述符转换为file的关键数据结构就是fdtable。 fdtablefdtable identifier - Linux source code (v6.3.8) - Bootlin 12345678struct fdtable &#123; unsigned int max_fds; struct file __rcu **fd; /* current fd array */ unsigned long *close_on_exec; unsigned long *open_fds; unsigned long *full_fds_bits; struct rcu_head rcu;&#125;; fd 如果打开的文件比较少，那么这个fd将指向files_struct的fd_array。如果打开的文件比较多，fdtable本身就是动态分配的，fd也是动态分配。所以是否要释放fd所指空间很好判断，如果要释放fdtable就一定会释放fd。对fd的分配会尝试kmalloc()和vmalloc()两种方法。 另外，close_on_exec与open_fds的行为同fd，如果fdtable是动态分配的，那么他们也必然是动态分配的。 虚拟文件系统机制原理Linux内核当中负责管理和存储文件的模块，即文件系统模块。Linux文件系统的架构视图（用户空间、内核空间、硬件层面） 挂载执行命令：mount -t fstype device dir 卸载执行命令：umount 当我们写文件时，Linux内核系统模块会把数据保存在页缓存当中，不会立刻写到存储设备。使用fsync把文件修改过的属性和数据立即写到存储设备，使用fsync把文件修改过的属性和数据立即写到存储设备，或者使用fdatasync把文件修改过的数据理解写到存储设备。 我们应用程序可以使用glibc库封装的I&#x2F;O来访问文件（提供缓冲区，目的是尽可能减少调用read&#x2F;write的次数，提高性能） 硬件层面：块设备（机械硬盘）、闪存（SSD）、NVDIMM设备。NOR闪存适合存储程序（一般情况下存储引导程序，U-Boot程序）。NAND闪存适合存储数据。 为什么要针对闪存专门设计文件系统？ NAND存在坏块，软件需要识别且跳过坏块。 需要实现损耗均衡，损耗均衡就是使所有擦除块的擦除次数均衡，避免一部分擦除快先损坏。 NAND闪存和机械硬盘的主要区别： 机械硬盘最小读写单位为扇区，扇区大小一般为512字节；NAND闪存最小读写单位是页或子页。 机械硬盘可以直接写入数据；NAND在写入数据之前需要擦除一个擦除块。 机械硬盘的使用寿命比NAND闪存长；机械硬盘的扇区的写入次数没有限制；NAND闪存擦除快的擦除次数有限。 机械硬盘隐藏坏的扇区，软件不需要处理坏的扇区；NAND闪存的坏块对软件可见，软件需要处理坏块。 Linux内核空间层面：Linux内核的目录fs（内核支持多种文件系统类型）。为了不同文件系统实现能够共存，内核实现一个抽象层（称为虚拟文件系统）。文件系统分类：块设备文件系统（ext2&#x2F;3&#x2F;4、btrfs）、闪存文件系统（JFFS2、UBIFS）、内存文件系统（tmpfs）、伪文件系统（sockfs、proc、sysfs、hugetlbfs、cgroup)。 避免每次读写都需要访问块设备，内核实现块缓存，为每个块设备在内存中创建一个块缓存，缓存单位为块，块缓存基于页缓存实现。I&#x2F;O调度器用来决定读写请求的提交顺序，不同场景提供多种调度算法：NOOP（适合闪存类设备）、CFQ，Deadline（后两个适合机械硬盘）。 Linux内核把闪存称为存储技术设备（MTD） 虚拟文件系统（VFS）数据结构：超级块(super_block)、索引节点(inode)(每个文件对应一个索引节点，每个索引节点有一个唯一的编号）、目录项(dentry)。 当进程打开一个文件时，虚拟文件系统就会创建文件的一个打开实例（file数据结构）。文件系统的第一块是超级块（super_block) 挂载描述符：一个文件系统，只有挂载到内存当中目录树的 一个目录下，进程才能够访问这个文件系统。每次挂载文件系统，虚拟文件系统就会创建一个挂载描述符：mount结构体。挂载描述符用来描述文件系统的一个挂载实例，同一个存储设备上的文件系统可以多次挂载，每次挂载到不同的目录下。mount结构体。 基本操作索引节点哈希表哈希表结构 types.h - include&#x2F;linux&#x2F;types.h - Linux source code (v6.3.8) - Bootlin 123456struct hlist_head &#123; struct hlist_node *first;&#125;;struct hlist_node &#123; struct hlist_node *next, **pprev;&#125;; 关于hash值得计算使用的是如下函数,参数hashval实际就是inode的索引号。 inode.c - fs&#x2F;inode.c - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021// 定义一个名为hash的函数，传入一个指向super_block结构体的指针sb和一个无符号长整型hashval，返回一个无符号长整型值static unsigned long hash(struct super_block *sb, unsigned long hashval)&#123; // 定义一个无符号长整型变量tmp，用于存储计算结果 unsigned long tmp; // 计算tmp的值，其中： // 1. 将hashval乘以sb指针的值（将其视为无符号长整型） // 2. 对上述结果进行异或运算，与(GOLDEN_RATIO_PRIME + hashval) / L1_CACHE_BYTES的结果 tmp = (hashval * (unsigned long)sb) ^ (GOLDEN_RATIO_PRIME + hashval) / L1_CACHE_BYTES; // 对tmp进行以下计算： // 1. 将tmp与GOLDEN_RATIO_PRIME进行异或 // 2. 右移i_hash_shift位 // 3. 与原tmp值进行异或 tmp = tmp ^ ((tmp ^ GOLDEN_RATIO_PRIME) &gt;&gt; i_hash_shift); // 返回tmp与i_hash_mask进行按位与运算的结果 return tmp &amp; i_hash_mask;&#125; insert_inode_hash 将inode插入哈希表 insert_inode_hash identifier - Linux source code (v6.3.8) - Bootlin 1234static inline void insert_inode_hash(struct inode *inode)&#123; __insert_inode_hash(inode, inode-&gt;i_ino);&#125; remove_inode_hash 将inode从哈希表删除 remove_inode_hash identifier - Linux source code (v6.3.8) - Bootlin 12345static inline void remove_inode_hash(struct inode *inode)&#123; if (!inode_unhashed(inode) &amp;&amp; !hlist_fake(&amp;inode-&gt;i_hash)) __remove_inode_hash(inode);&#125; 目录项哈希表哈希表结构 list_bl.h - include&#x2F;linux&#x2F;list_bl.h - Linux source code (v6.3.8) - Bootlin 1234567struct hlist_bl_head &#123; struct hlist_bl_node *first;&#125;;struct hlist_bl_node &#123; struct hlist_bl_node *next, **pprev;&#125;; 12345678910111213141516171819/* * 这是与dcache（目录项缓存）最关键的数据结构：用于查找的哈希表。 * 有人应该尝试优化这个数据结构 - 我只是让它能够工作。 * * 这个哈希函数试图避免丢失太多的哈希信息，同时避免使用质数大小的哈希表等类似设计。 */// 定义一个静态无符号整型变量d_hash_shift，使用__read_mostly修饰，表示该变量在大多数情况下是只读的static unsigned int d_hash_shift __read_mostly;// 定义一个指向hlist_bl_head结构体的指针dentry_hashtable，使用__read_mostly修饰，表示该指针在大多数情况下是只读的static struct hlist_bl_head *dentry_hashtable __read_mostly;// 定义一个名为d_hash的内联函数，参数为无符号整型hash，返回一个指向hlist_bl_head结构体的指针static inline struct hlist_bl_head *d_hash(unsigned int hash)&#123; // 计算哈希值：将输入的hash右移d_hash_shift位，然后与dentry_hashtable相加，得到哈希表中对应的指针 return dentry_hashtable + (hash &gt;&gt; d_hash_shift);&#125; dentry_hashtable 在dcache_init()&#x2F;dcache_init_early()时会对其初始化 123456789101112131415161718192021222324252627static void __init dcache_init(void)&#123; /* * A constructor could be added for stable state like the lists, * but it is probably not worth it because of the cache nature * of the dcache. */ dentry_cache = KMEM_CACHE_USERCOPY(dentry, SLAB_RECLAIM_ACCOUNT|SLAB_PANIC|SLAB_MEM_SPREAD|SLAB_ACCOUNT, d_iname); /* Hash may have been set up in dcache_init_early */ if (!hashdist) return; dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; 1234567891011121314151617181920static void __init dcache_init_early(void)&#123; /* If hashes are distributed across NUMA nodes, defer * hash allocation until vmalloc space is available. */ if (hashdist) return; dentry_hashtable = alloc_large_system_hash(&quot;Dentry cache&quot;, sizeof(struct hlist_bl_head), dhash_entries, 13, HASH_EARLY | HASH_ZERO, &amp;d_hash_shift, NULL, 0, 0); d_hash_shift = 32 - d_hash_shift;&#125; d_hash_mask 实际长度位数，即ilog2(dhash_entries) d_hash_shift 最大索引值，即(1 &lt;&lt; d_hash_mask) - 1 对hash值的计算采用的是如下函数，注意d_hash的参数hash是将路径名转换出来的一个数字，具体转换方法比较复杂，请参考full_name_hash。 123456static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent, unsigned int hash)&#123; hash += (unsigned long) parent / L1_CACHE_BYTES; return in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT);&#125; d_add 实例化dentry并加入哈希表，所谓实例化就是和具体的inode关联 12345678910111213141516171819202122232425/** * d_add - 将dentry添加到哈希队列中 * @entry: 要添加的dentry * @inode: 要附加到此dentry的inode * * 将entry添加到哈希队列中并初始化@inode。 * 实际上，在d_alloc()过程中已经填充了entry。 */// 定义一个名为d_add的函数，参数为指向dentry结构体的指针entry和指向inode结构体的指针inodevoid d_add(struct dentry *entry, struct inode *inode)&#123; // 如果inode非空 if (inode) &#123; // 调用security_d_instantiate()函数，将entry与inode关联 security_d_instantiate(entry, inode); // 对inode的i_lock成员进行自旋锁加锁，以保护其关联的dentry链表 spin_lock(&amp;inode-&gt;i_lock); &#125; // 调用__d_add()函数，将entry添加到inode的关联dentry链表中 __d_add(entry, inode);&#125;// 导出d_add函数的符号，使其可以被外部模块使用EXPORT_SYMBOL(d_add); d_lookup 根据路径名查找目录项，在__d_lookup基础上加了一个顺序锁校验 12345678910111213141516171819202122232425/** * d_lookup - search for a dentry * @parent: parent dentry * @name: qstr of name we wish to find * Returns: dentry, or NULL * * d_lookup searches the children of the parent dentry for the name in * question. If the dentry is found its reference count is incremented and the * dentry is returned. The caller must use dput to free the entry when it has * finished using it. %NULL is returned if the dentry does not exist. */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; do &#123; seq = read_seqbegin(&amp;rename_lock); dentry = __d_lookup(parent, name); if (dentry) break; &#125; while (read_seqretry(&amp;rename_lock, seq)); return dentry;&#125;EXPORT_SYMBOL(d_lookup); 文件系统安装在使用一个文件系统之前，必须执行两个操作：注册和安装。 或者在系统启动时，或者在安装某个文件系统的模块时，都需要进行注册。一旦一个文件系统完成注册，那么它具体的函数对内核就是可用的了，因此，这个文件系统就可以安装在系统的目录树上。在文件系统注册到内核时，文件系统是编译为模块，或者持久编译到内核中，都没有差别。如果不考虑注册的时间（持久编译到内核的文件系统在启动时注册，模块化文件系统在相关模块载入内核时注册），在两种情况下所用的技术方法是同样的。 每个文件系统都有它自己的根目录，如果某文件系统的根目录时系统目录树的根，那么该文件系统称为根文件系统。而其他文件系统可以安装到系统的目录树上，把这些文件系统要插入的那些目录就成为安装点（mount point）。 注册文件系统在系统初始化期间，Linux v2.6调用函数filesystem_setup()来注册编译时指定的文件系统，而在最新版本的Linux中这个函数由其他函数替代。通过module_init()和相应的init_xxx_fs()函数来实现文件系统的注册。 对于每个不同类型的文件系统，以指向file_system_type类型的某个对象作为参数来调用register_filesystem()函数，因此，该对象就被插入到文件系统类型的链表中。 当某个文件系统的模块被装入时，也要调用register_filesystem()函数。在这种情况下，当该模块被卸载时，对应的文件系统也可以被注销（调用unregister_filesystem()函数）。 get_fs_type()函数（接受一个文件系统名作为它的参数）扫描已注册的文件系统链表，并返回指向相应的file_system_type对象的指针（如果存在）。 get_fs_type identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021struct file_system_type *get_fs_type(const char *name) &#123; //根据文件系统名称获取文件系统类型 struct file_system_type *fs; const char *dot = strchr(name, &#x27;.&#x27;); //查找点号 int len = dot ? dot - name : strlen(name); //获取文件系统类型名称的长度 fs = __get_fs_type(name, len); //根据名称和长度获取文件系统类型 if (!fs &amp;&amp; (request_module(&quot;fs-%.*s&quot;, len, name) == 0)) &#123; //如果获取不到,加载文件系统模块 fs = __get_fs_type(name, len); //再次获取文件系统类型 if (!fs) pr_warn_once(&quot;request_module fs-%.*s succeeded, but still no fs?\\n&quot;, //如果还是获取不到,打印警告信息 len, name); &#125; if (dot &amp;&amp; fs &amp;&amp; !(fs-&gt;fs_flags &amp; FS_HAS_SUBTYPE)) &#123; //如果文件系统名称包含点号,且文件系统类型不支持子类型 put_filesystem(fs); //释放文件系统类型 fs = NULL; //设置为NULL &#125; return fs; //返回文件系统类型&#125; 加载文件系统模块（如 ext4），并调用文件系统的注册函数。在注册函数中，需要提供一个指向 file_system_type 结构体的指针，该结构体包含文件系统的基本信息和操作指针。 文件系统可以以两种方式存在于操作系统中：内建于内核中或作为可加载模块。内建文件系统直接编译进内核，而作为模块的文件系统可以在运行时动态加载。这种模块化设计可以节省内核空间和提高运行效率，因为只有在需要使用特定文件系统时，对应的模块才会被加载。 内建于内核的文件系统意味着文件系统的实现代码直接编译进内核二进制文件，而不是作为模块动态加载。内建文件系统在内核启动时就已经可用，不需要额外的加载过程。这种方式适用于一些基本或常用的文件系统，如 ext4、proc 、tmpfs等。 使用 register_filesystem() 函数注册新的文件系统，将其添加到 VFS 支持的文件系统列表中。 当需要挂载该文件系统时（例如，通过 mount 命令），VFS 将调用 file_system_type 结构体中的 mount 函数指针。这将触发读取设备的超级块数据并创建一个对应的 VFS super_block 结构体实例。这个实例包含了该文件系统的类型、状态、操作等信息。 以tmpfs文件系统为例 当内核启动时，会执行shmem_init函数（定义在mm/shmem.c文件中）。这个函数会调用register_filesystem注册tmpfs文件系统。 shmem_init identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __init shmem_init(void)&#123;// 初始化 inode 缓存shmem_init_inodecache();// 注册 tmpfs 文件系统int error = register_filesystem(&amp;shmem_fs_type);if (error) &#123; // 若注册失败，打印错误信息 pr_err(&quot;Could not register tmpfs\\n&quot;); // 跳转到 out2，执行清理操作 goto out2;&#125;// 尝试挂载 tmpfs 文件系统shm_mnt = kern_mount(&amp;shmem_fs_type);if (IS_ERR(shm_mnt)) &#123; // 若挂载失败，获取错误代码 error = PTR_ERR(shm_mnt); // 打印错误信息 pr_err(&quot;Could not kern_mount tmpfs\\n&quot;); // 跳转到 out1，执行清理操作 goto out1;&#125;#ifdef CONFIG_TRANSPARENT_HUGEPAGE// 如果支持透明巨页，且巨页设置不为禁用，设置巨页选项if (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY) SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;else // 否则，将巨页设置为永不使用，以防万一 shmem_huge = SHMEM_HUGE_NEVER;#endif// 成功执行，函数返回return;out1:// 清理操作：注销 tmpfs 文件系统unregister_filesystem(&amp;shmem_fs_type);out2:// 清理操作：销毁 inode 缓存shmem_destroy_inodecache();// 设置 shm_mnt 为错误指针，表示初始化失败shm_mnt = ERR_PTR(error);&#125; shmem_fs_type是一个file_system_type结构体，定义了tmpfs文件系统的基本信息。在这个结构体中，init_fs_context成员被设置为shmem_init_fs_context。 shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314static struct file_system_type shmem_fs_type = &#123;.owner = THIS_MODULE, // 指定文件系统模块的所有者.name = &quot;tmpfs&quot;, // 文件系统的名称.init_fs_context = shmem_init_fs_context, // 初始化文件系统上下文的回调函数#ifdef CONFIG_TMPFS.parameters = shmem_fs_parameters, // 指定文件系统的挂载参数解析回调#endif.kill_sb = kill_litter_super, // 用于销毁超级块的回调函数#ifdef CONFIG_SHMEM.fs_flags = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, // 文件系统的标志（支持用户命名空间挂载和ID映射）#else.fs_flags = FS_USERNS_MOUNT, // 文件系统的标志（仅支持用户命名空间挂载）#endif&#125;; 当一个新的文件系统需要被支持时，它需要使用 register_filesystem() 函数将自己注册到 VFS。这样，VFS 就可以识别和处理这个新的文件系统。 register_filesystem identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * register_filesystem - 注册一个新的文件系统 * @fs: 文件系统结构体 * * 将传入的文件系统添加到内核已知的文件系统列表中，供挂载和其他系统调用使用。 * 成功时返回0，出错时返回一个负的errno错误码。 * * 传入的 &amp;struct file_system_type 结构体将链接到内核结构中， * 在文件系统未注销之前，不应该被释放。 */int register_filesystem(struct file_system_type * fs)&#123; int res = 0; // 初始化结果为0，表示成功 struct file_system_type ** p; // 检查文件系统参数是否有效 if (fs-&gt;parameters &amp;&amp; !fs_validate_description(fs-&gt;name, fs-&gt;parameters)) return -EINVAL; // 检查文件系统名称中是否包含非法字符 &#x27;.&#x27; BUG_ON(strchr(fs-&gt;name, &#x27;.&#x27;)); // 检查文件系统是否已经链接到其他文件系统 if (fs-&gt;next) return -EBUSY; // 获取 file_systems_lock 写锁，以保护 file_systems 链表 write_lock(&amp;file_systems_lock); // 查找具有相同名称的文件系统 p = find_filesystem(fs-&gt;name, strlen(fs-&gt;name)); // 如果找到了具有相同名称的文件系统，返回 -EBUSY if (*p) res = -EBUSY; else // 否则，将新的文件系统链接到 file_systems 链表中 *p = fs; // 释放 file_systems_lock 写锁 write_unlock(&amp;file_systems_lock); // 返回结果 return res;&#125;EXPORT_SYMBOL(register_filesystem); // 导出 register_filesystem 符号，供其他模块使用k); return res;&#125; 根文件系统注册文件系统类型 注册rootfs是在init_rootfs中完成的 init_rootfs identifier - Linux source code (v6.3.8) - Bootlin 123456void __init init_rootfs(void)&#123; if (IS_ENABLED(CONFIG_TMPFS) &amp;&amp; !saved_root_name[0] &amp;&amp; (!root_fs_names || strstr(root_fs_names, &quot;tmpfs&quot;))) is_tmpfs = true;&#125; 主要工作就是注册rootfs_fs_type rootfs_fs_type identifier - Linux source code (v6.3.8) - Bootlin 12345struct file_system_type rootfs_fs_type = &#123; .name = &quot;rootfs&quot;, .init_fs_context = rootfs_init_fs_context, .kill_sb = kill_litter_super,&#125;; 挂载根文件系统 init_mount_tree 调用vfs_kern_mount，创建名字空间，设置进程pwd&#x2F;root路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static void __init init_mount_tree(void)&#123; // 声明一个指向 vfsmount 结构体的指针 mnt，用于表示挂载的文件系统 struct vfsmount *mnt; // 声明一个指向 mount 结构体的指针 m，用于表示挂载点 struct mount *m; // 声明一个指向 mnt_namespace 结构体的指针 ns，用于表示挂载命名空间 struct mnt_namespace *ns; // 声明一个 path 结构体变量 root，用于表示根路径 struct path root; // 调用 vfs_kern_mount 函数挂载 root 文件系统，返回挂载对象的指针 mnt = vfs_kern_mount(&amp;rootfs_fs_type, 0, &quot;rootfs&quot;, NULL); // 检查 mnt 是否包含错误指针 if (IS_ERR(mnt)) panic(&quot;Can&#x27;t create rootfs&quot;); // 如果存在错误，输出错误信息并终止内核 // 为新的命名空间分配内存 ns = alloc_mnt_ns(&amp;init_user_ns, false); // 检查 ns 是否包含错误指针 if (IS_ERR(ns)) panic(&quot;Can&#x27;t allocate initial namespace&quot;); // 如果存在错误，输出错误信息并终止内核 // 获取 mnt 对应的真实挂载点 m = real_mount(mnt); // 将新分配的命名空间 ns 赋值给挂载点 m 的命名空间字段 m-&gt;mnt_ns = ns; // 将挂载点 m 设置为命名空间的根挂载点 ns-&gt;root = m; // 初始化命名空间的挂载计数为 1 ns-&gt;mounts = 1; // 将挂载点 m 添加到命名空间的挂载列表中 list_add(&amp;m-&gt;mnt_list, &amp;ns-&gt;list); // 将新分配的命名空间 ns 设置为初始任务的命名空间代理 init_task.nsproxy-&gt;mnt_ns = ns; // 增加命名空间的引用计数 get_mnt_ns(ns); // 设置根路径的挂载对象为 mnt root.mnt = mnt; // 设置根路径的目录项为挂载对象的根目录项 root.dentry = mnt-&gt;mnt_root; // 设置挂载对象的标志位为已锁定 mnt-&gt;mnt_flags |= MNT_LOCKED; // 设置当前任务的文件系统工作目录为新的根路径 set_fs_pwd(current-&gt;fs, &amp;root); // 设置当前任务的文件系统根目录为新的根路径 set_fs_root(current-&gt;fs, &amp;root);&#125; vfs_kern_mount 分配mount，调用mount_fs来执行挂载操作，建立挂载点关系 vfs_kern_mount identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct vfsmount *vfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)&#123; // 声明一个指向 fs_context 结构体的指针 fc，用于表示文件系统上下文 struct fs_context *fc; // 声明一个指向 vfsmount 结构体的指针 mnt，用于表示挂载的文件系统 struct vfsmount *mnt; // 声明一个整型变量 ret，用于存储返回值 int ret = 0; // 检查传入的文件系统类型指针 type 是否为空 if (!type) return ERR_PTR(-EINVAL); // 如果为空，返回错误指针 // 调用 fs_context_for_mount 函数创建一个新的文件系统上下文 fc = fs_context_for_mount(type, flags); // 检查创建的文件系统上下文是否包含错误指针 if (IS_ERR(fc)) return ERR_CAST(fc); // 如果存在错误，返回错误指针 // 检查传入的名称参数 name 是否非空 if (name) // 调用 vfs_parse_fs_string 函数解析文件系统名称 ret = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // 检查 ret 是否为 0（表示无错误） if (!ret) // 调用 parse_monolithic_mount_data 函数解析传入的挂载数据 ret = parse_monolithic_mount_data(fc, data); // 检查 ret 是否为 0（表示无错误） if (!ret) // 调用 fc_mount 函数执行挂载操作，并将结果赋值给 mnt mnt = fc_mount(fc); else // 如果存在错误，将 ret 转换为错误指针并赋值给 mnt mnt = ERR_PTR(ret); // 释放文件系统上下文 put_fs_context(fc); // 返回挂载的文件系统指针 mnt return mnt;&#125;EXPORT_SYMBOL_GPL(vfs_kern_mount); fc_mount 用于挂载一个文件系统 vfs_get_tree identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * vfs_get_tree - Get the mountable root * @fc: The superblock configuration context. * * The filesystem is invoked to get or create a superblock which can then later * be used for mounting. The filesystem places a pointer to the root to be * used for mounting in @fc-&gt;root. */int vfs_get_tree(struct fs_context *fc)&#123; // 声明一个指向 super_block 结构体的指针 sb，用于表示文件系统的超级块 struct super_block *sb; // 声明一个整型变量 error，用于存储返回值 int error; // 检查传入的文件系统上下文 fc 的 root 是否已经设置 if (fc-&gt;root) return -EBUSY; // 如果已经设置，返回错误代码 -EBUSY // 调用文件系统操作（ops）中的 get_tree 函数，获取或创建文件系统树 error = fc-&gt;ops-&gt;get_tree(fc); if (error &lt; 0) return error; // 如果操作失败，返回错误代码 // 检查 fc-&gt;root 是否已经设置 if (!fc-&gt;root) &#123; // 如果没有设置，输出错误信息，并触发 BUG（内核调试宏） pr_err(&quot;Filesystem %s get_tree() didn&#x27;t set fc-&gt;root\\n&quot;, fc-&gt;fs_type-&gt;name); BUG(); &#125; // 获取超级块指针 sb = fc-&gt;root-&gt;d_sb; // 检查超级块的块设备映射 (s_bdi) 是否已经设置 WARN_ON(!sb-&gt;s_bdi); // 将写内存屏障放在设置 SB_BORN 标志位之前，以确保超级块结构已经设置完成 smp_wmb(); // 为超级块设置 SB_BORN 标志位，表示文件系统已经创建 sb-&gt;s_flags |= SB_BORN; // 调用 security_sb_set_mnt_opts 函数设置安全模块的挂载选项 error = security_sb_set_mnt_opts(sb, fc-&gt;security, 0, NULL); if (unlikely(error)) &#123; // 如果设置失败，释放文件系统上下文的引用并返回错误代码 fc_drop_locked(fc); return error; &#125; // 输出警告信息，如果文件系统设置的 s_maxbytes 值小于 0 WARN((sb-&gt;s_maxbytes &lt; 0), &quot;%s set sb-&gt;s_maxbytes to &quot; &quot;negative value (%lld)\\n&quot;, fc-&gt;fs_type-&gt;name, sb-&gt;s_maxbytes); // 返回操作成功（错误代码为 0） return 0;&#125;EXPORT_SYMBOL(vfs_get_tree); 安装根文件系统是系统初始化的关键部分。当系统启动时，就要在变量ROOT_DEV中寻找包含根文件系统的磁盘主码。当编译内核或向最初的启动装入程序传递一个合适的选项时，根文件系统可以被指定为&#x2F;dev目录下的一个设备文件。类似地，根文件系统的安装标志存放在root_mountflags变量中。用户可以指定这些标志，这是通过对已编译的内核映像使用&#x2F;sbin&#x2F;rdev外部程序，或者向最初的启动装入程序传递一个合适的选项来达到的。 在系统初始化期间，mount_root()安装根文件系统。 mount_root identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435void __init mount_root(void) &#123; #ifdef CONFIG_ROOT_NFS // 如果根文件系统位于 NFS 上,尝试挂载 NFS 根文件系统 if (ROOT_DEV == Root_NFS) &#123; if (!mount_nfs_root()) printk(KERN_ERR &quot;VFS: Unable to mount root fs via NFS.\\n&quot;); return; &#125; #endif #ifdef CONFIG_CIFS_ROOT // 如果根文件系统位于 CIFS(SMB) 上,尝试挂载 CIFS 根文件系统 if (ROOT_DEV == Root_CIFS) &#123; if (!mount_cifs_root()) printk(KERN_ERR &quot;VFS: Unable to mount root fs via SMB.\\n&quot;); return; &#125; #endif if (ROOT_DEV == 0 &amp;&amp; root_device_name &amp;&amp; root_fs_names) &#123; // 如果根设备为空(0),并且命令行指定了根设备名和根文件系统类型, // 尝试挂载一个无块设备的根文件系统(如 initramfs)。 if (mount_nodev_root() == 0) return; &#125; #ifdef CONFIG_BLOCK &#123; // 为根块设备创建一个 /dev/root 节点 int err = create_dev(&quot;/dev/root&quot;, ROOT_DEV); if (err &lt; 0) pr_emerg(&quot;Failed to create /dev/root: %d\\n&quot;, err); // 使用 /dev/root 和指定的挂载标志来挂载块设备根文件系统 mount_block_root(&quot;/dev/root&quot;, root_mountflags); &#125; #endif &#125; 安装一个普通的文件系统一旦完成对根文件系统的初始化，就可以安装其他的文件系统。其中的每一个都有自己的安装点，安装点仅仅是系统目录树中现有的一个目录。 打开文件或者创建文件 一个主要操作是根据给定的文件名查找inode，这使得我们首先需要了解有关查找该信息的机制。 nameidata结构体用来查找函数传递参数数，并保存查找结果。 nameidata identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324#define EMBEDDED_LEVELS 2struct nameidata &#123; struct path path; // 路径对象，表示路径 struct qstr last; // 最后的路径组件 struct path root; // 文件系统的根路径 struct inode *inode; // 指向路径中的目录项的节点 (path.dentry.d_inode) unsigned int flags, state; // 标志位和状态 unsigned seq, next_seq, m_seq, r_seq; // 用于序列号的变量 int last_type; // 最后路径组件的类型 unsigned depth; // 链接深度 int total_link_count; // 总的链接数 struct saved &#123; // 保存结构，用于链接跟踪 struct path link; // 链接路径 struct delayed_call done; // 延迟调用 const char *name; // 链接名称 unsigned seq; // 序列号 &#125; *stack, internal[EMBEDDED_LEVELS]; // 保存结构的栈和内部数组 struct filename *name; // 文件名对象 struct nameidata *saved; // 指向保存的nameidata结构 unsigned root_seq; // 根路径序列号 int dfd; // 目录文件描述符 vfsuid_t dir_vfsuid; // 目录的VFS用户ID umode_t dir_mode; // 目录的模式 (权限)&#125; __randomize_layout; // 随机化布局属性 在走一条路的整个过程中，当前状态存储在一个 struct nameidata ，“namei”是将“名称”转换为“inode”的函数的传统名称 - 可以追溯到第一版Unix。 struct nameidata 包含（除其他字段外）： path包含了找到的文件系统项的数据，path结构包含dentry和mnt。 struct path path path identifier - Linux source code (v6.3.8) - Bootlin 1234struct path &#123; struct vfsmount *mnt; struct dentry *dentry;&#125; __randomize_layout; 包含struct vfsmount和struct dentry，这些一起记录了现在walk的状态，他们首先。它们首先引用起点（当前工作目录，根目录或由文件描述符标识的其他目录），并在每一步中更新，即在遍历过程的每一步中，这些结构体都会更新。通过d_lockref和mnt_count始终持有的引用。 struct qstr last 这是一个字符串，长度（即未 nul 终止）是路径名中的“下一个”组件。 qstr identifier - Linux source code (v6.3.8) - Bootlin 12345678910111213141516/* * &quot;quick string&quot; -- eases parameter passing, but more importantly * saves &quot;metadata&quot; about the string (ie length and the hash). * * hash comes first so it snuggles against d_parent in the * dentry. */struct qstr &#123; union &#123; struct &#123; HASH_LEN_DECLARE; &#125;; u64 hash_len; &#125;; const unsigned char *name;&#125;; int last_type 这是LAST_NORM, LAST_ROOT, LAST_DOT 或者 LAST_DOTDOT其中一个。 struct path root 用于在内核中表示文件系统的有效根目录。在路径查找过程中，它可以确保始终有一个有效的根目录参考。这个结构体包含两个主要成员：dentry 和 mnt。dentry 是目录项，用于表示目录结构中的一个节点。mnt 是一个 vfsmount 结构，代表一个挂载点，用于连接不同文件系统。例如查找/home/path/test.txt时，根目录就是/，root表示的就是&#x2F;的信息。 保证路径查找不会超出特定文件系统的边界。当使用像 chroot() 这样的系统调用时，struct path root 可以确保路径查找仅限于指定的文件系统子树。 在处理像 NFSv4、Btrfs 这样的分布式或者层次化文件系统时，struct path root 可以确保正确处理不同子树的根目录，防止路径查找错误地跳转到其他子树或文件系统。 在处理特殊的路径操作，如 LOOKUP_IN_ROOT 和 LOOKUP_BENEATH 时，struct path root 可以确保路径查找以特定目录作为根路径进行。 在处理绝对路径和相对路径时，struct path root 可以作为查找的基准点。例如，当路径名以 / 开头，或者处理 .. 组件时，struct path root 是必需的。 现在，我们可以忽略符号链接的处理，描述 link_path_walk() 函数，该函数处理除最后一个组件之外的所有内容： 给定一个路径（name）和一个 nameidata 结构（nd），检查当前目录是否具有执行权限，然后将 name 逐个推进到一个组件，同时更新 last_type 和 last。如果这是最后一个组件，则返回；否则调用 walk_component() 并从顶部重复。 walk_component() 函数非常简单。如果组件是 LAST_DOTS，它会调用 handle_dots()，该函数会执行已经描述过的必要锁定操作。如果找到 LAST_NORM 组件，它首先调用 lookup_fast()，该函数仅在目录缓存中查找，但如果是需要重新验证结果的文件系统类型，它会要求文件系统重新验证结果。如果没有得到好的结果，它会调用 lookup_slow()，该函数会获取 i_rwsem，重新检查缓存，然后要求文件系统找到确切的答案。 walk_component() 的最后一步是调用 step_into() 函数，它可以直接从 walk_component() 或者 handle_dots() 调用。它会调用 handle_mounts() 函数来检查和处理挂载点，这时会创建一个包含对新 dentry 的计数引用和对新 vfsmount 的引用的新 struct path。只有在新 vfsmount 与之前的 vfsmount 不同时，新 vfsmount 的引用才会被计数。然后，如果有符号链接，step_into() 会调用 pick_link() 函数处理它，否则它会将新的 struct path 安装到 struct nameidata 中，并删除不再需要的引用。 link_path_walk() 函数只会处理路径中的最后一个组件，设置 nd-&gt;last 和 nd-&gt;last_type，但它不会调用 walk_component() 函数。处理最后的组件留给了调用者，这些调用者分别是 path_lookupat()、path_parentat() 和 path_openat()，它们分别处理不同系统调用的需求。 path_parentat()：这个函数相对简单，它在 link_path_walk() 周围添加了一些额外的操作，然后将父目录和最后的组件返回给调用者。调用者可能会试图通过 filename_create() 函数创建一个名称，或者移除或重命名一个名称（这种情况下会使用 user_path_parent() 函数）。在执行操作之前，它们会使用 i_rwsem 来确保没有其他更改。 例如，当用户调用 mkdir() 函数时，它会调用 path_parentat() 函数来找到新目录的父目录。然后，内核可以根据返回的父目录创建新目录。 path_lookupat()：这个函数也相对简单，它用于查找现有对象，比如通过 stat() 或 chmod() 函数。它实际上只是通过调用 lookup_last() 函数在最后的组件上调用 walk_component()。path_lookupat() 只返回最后的 dentry。 例如，当用户调用 stat() 函数时，它会调用 path_lookupat() 函数来找到文件或目录的 dentry。然后，内核可以根据 dentry 提供文件或目录的元数据。 path_openat()：这个函数用于处理 open() 系统调用。通过支持函数（以 “open_last_lookups()” 开头），它包含了处理 O_CREAT（有或无 O_EXCL）、最后的 “&#x2F;” 字符和尾部符号链接等不同细微差别所需的所有复杂性。这个函数在某些情况下会使用 i_rwsem，具体取决于它找到的内容。 例如，当用户调用 open() 函数时，它会调用 path_openat() 函数来处理可能的不同操作，比如创建新文件、打开现有文件或处理尾部符号链接。 这些函数或调用它们的函数需要注意最后一个组件是否是 LAST_NORM。如果查找的目标是创建某个对象，那么 last_type 的任何值（除了 LAST_NORM）都会导致错误。例如，如果 path_parentat() 报告 LAST_DOTDOT，那么调用者将不会尝试创建该名称。它们还会通过测试 last.name[last.len] 来检查尾部斜杠。如果在最后一个组件之后有任何字符，那么这一定是一个尾部斜杠。 调用链下面看到这个调用链 12345678910111213141516171819202122232425262728293031323334open() └── do_sys_open └── do_sys_openat2 ├── get_unused_fd_flags(获取一个未使用的文件描述符) ├── do_filp_open(打开file f) │ ├── set_nameidata(初始化nameidata nd存放查找结果) │ │ └── __set_nameidata │ ├── path_openat(打开file) │ │ ├── alloc_empty_file(初始化一个空的file结构体) │ │ ├── path_init(初始化nameidata结构体nd，不同系统调用nd-&gt;path不同) │ │ ├── link_path_walk(处理符号链接) │ │ │ ├── lookup_fast │ │ │ │ └── __d_lookup_rcu │ │ │ │ └── hlist_bl_for_each_entry_rcu │ │ │ └── lookup_slow │ │ │ └── __lookup_slow │ │ │ └── 具体文件系统的lookup函数 │ │ └── open_last_lookups（创建新文件） │ │ ├── handle_dots(处理..和.) │ │ ├── lookup_fast │ │ │ └── __d_lookup_rcu │ │ │ └── hlist_bl_for_each_entry_rcu │ │ ├── lookup_open │ │ │ └── d_lookup │ │ │ └── __d_lookup │ │ ├── atomic_open(如果支持原子打开操作) │ │ ├── 具体文件的lookup(如果目录项仍在查找中) │ │ └── 具体文件的create(如果目录项的inode为空并且需要创建文件) │ │ │ └── do_open │ └── vfs_open │ └── do_dentry_open │ └── 具体文件系统的open └── fd_install Pathname lookup下面是查找&#x2F;home&#x2F;hust&#x2F;helloworld.txt时，link_path_walk中的循环处理每个组件 路径名 以斜杠开头的路径称为“绝对路径”，它从文件系统的根目录开始。 例如：&#x2F;home&#x2F;user&#x2F;documents&#x2F;report.txt 不以斜杠开头的路径称为“相对路径”，它从当前目录或通过给 “*at()” 系统调用（如 openat()）提供的文件描述符指定的其他位置开始。 例如：documents&#x2F;report.txt 在某些情况下，路径名可能既没有斜杠（slashes）也没有组件（components），换句话说，它可能是空的。虽然在 POSIX 标准中，这种情况通常是禁止的，但在 Linux 中，当给出 AT_EMPTY_PATH 标志时，某些 “*at()” 系统调用允许空路径名。 举例来说，如果你有一个指向可执行文件的打开的文件描述符，你可以通过调用 execveat() 函数，传递文件描述符、空路径和 AT_EMPTY_PATH 标志来执行该文件。在这种情况下，即使路径名为空，也可以完成文件的执行操作。 注意： 路径名可以分为两部分：最后一个组件和其他所有内容。其他所有内容通常是容易处理的，必须标识一个已存在的目录，否则会报告错误。最后一个组件的处理则更复杂。 不同的系统调用可能对最后一个组件有不同的解释（如是否创建它），有时它甚至可能不存在（如空路径名或仅包含斜杠的路径名）。 最后一个组件可能是 “.” 或 “..”，这两个组件的处理方式与其他组件不同。 如果路径名以斜杠结尾，如”&#x2F;tmp&#x2F;foo&#x2F;“，可能会认为最后一个组件为空。在很多情况下，这种处理方式可以得到正确的结果，但并非总是如此。特别是，mkdir() 和 rmdir() 函数会根据最后一个组件创建或删除目录，它们要求处理以斜杠结尾的路径名。 Linux 路径名处理代码（主要在 fs/namei.c）处理了所有这些问题。它会将路径分解为组件，将最后一个组件与其他所有内容分开处理，并检查尾部斜杠是否在不允许的地方使用。它还处理了并发访问的问题。 当一个进程在查找路径名时，另一个进程可能会进行影响查找的更改。例如，如果一个进程正在查找 “a&#x2F;b&#x2F;..”，而另一个进程将 “a&#x2F;b” 重命名为 “a&#x2F;c&#x2F;b”，第一个进程可能会成功地解析为 “a&#x2F;c”。这就是所谓的竞态条件，路径名查找的任务就是要防止它们产生破坏性影响。 大多数竞态条件更加微妙，很多可能的竞态条件可以在 “dcache”（目录缓存）的上下文中更清楚地看到。理解 “dcache” 是理解路径名查找的核心。 dcache dcache 缓存了文件系统中名称的信息，以便快速进行查找。每个 dcache 条目（dentry）包含三个重要字段：组件名称、指向父条目的指针和指向 inode 的指针。inode 包含有关具有给定名称的父项对象的更多信息。 dcache 除了加速查找外，还有其他用途。一个特别相关的用途是它与挂载表紧密集成。挂载表记录了哪个文件系统挂载在哪个位置，实际上存储的是哪个 dentry 安装在哪个其他 dentry 之上。 在处理 dcache 时，需要考虑两种类型的文件系统： 一类文件系统能确保 dcache 中的信息始终完全准确（尽管可能不完整）。这可以让 VFS 在不检查文件系统的情况下确定特定文件是否存在，同时 VFS 可以保护文件系统免受某些竞争和其他问题的影响。这类文件系统通常是本地文件系统，如 ext3、XFS 和 Btrfs。 例如，当你在本地文件系统（如 ext3）中创建一个新文件时，VFS 可以直接通过 dcache 来查找文件是否存在，而无需与底层文件系统进行交互。这样可以提高查找速度。 另一类文件系统无法提供这种保证，因为它们不能。这些通常是跨网络共享的文件系统，例如远程文件系统（如 NFS 和 9P）或集群文件系统（如 ocfs2 或 cephfs）。这些文件系统允许 VFS 重新验证缓存的信息，并必须提供自己的保护，以防止竞争条件。VFS 可以通过在 dentry 中设置的 DCACHE_OP_REVALIDATE 标志来检测这些文件系统。 例如，当你访问一个通过 NFS 共享的文件系统时，虽然 VFS 可以通过 dcache 加速查找，但是该文件系统无法保证 dcache 信息始终准确，因为远程文件可能被其他节点更改。在这种情况下，VFS 需要重新验证缓存的信息，并依赖底层文件系统提供保护，以防止竞态条件。 REF-walk：使用refcount和自旋锁进行简单的并发管理REF-walk 是一种相对重量级的并发管理方法，它使用锁和引用计数来控制并发。接下来是详细解释和示例： REF-walk 是一种并发管理方法，它在处理锁和引用计数时比较严格。尽管它没有像过去的“大内核锁”时代那样严格，但在需要时仍会采用锁。REF-walk 使用了多种不同的并发控制方法。 在探讨 REF-walk 之前，需要对各种基本原语（例如锁和引用计数）有一定了解。 以一个文件系统路径遍历的例子来说明 REF-walk 如何管理并发： 假设有一个文件系统路径 /home/user/documents/file.txt，当多个线程同时访问该路径时，需要确保它们之间的操作不会互相干扰。在这种情况下，REF-walk 方法可以提供一定程度的并发控制。 首先，REF-walk 使用引用计数来跟踪当前有多少线程正在访问某个路径组件（例如目录）。当一个线程开始访问一个组件时，引用计数会增加；当线程结束访问时，引用计数会减少。这样可以确保在一个线程访问组件时，其他线程不会意外地删除或修改它。 其次，REF-walk 使用锁（例如自旋锁）来保护某些关键操作。自旋锁是一种特殊的锁，当一个线程无法获取锁时，它会忙等待（不断尝试获取锁），而不是进入睡眠状态。这有助于在高并发场景下降低上下文切换开销。 例如，当一个线程在遍历路径时，可能需要对某个目录进行修改（例如创建新文件）。为了确保这个操作是原子的，线程可以使用自旋锁来锁定目录，以防止其他线程在此过程中进行干扰。一旦修改完成，线程会释放锁，允许其他线程访问目录。 dentry-&gt;d_lockrefdentry identifier - Linux source code (v6.3.8) - Bootlin 12345struct dentry &#123; ... struct lockref d_lockref; ...&#125; d_lockref使用lockref原语，它结合了自旋锁（spinlock）和引用计数（reference count），提供高效的同步和内存管理。 lockref原语的特点在于可以通过一个原子内存操作来完成”lock; inc_ref; unlock;”这样的序列，使得多线程环境下的同步和引用计数更加高效。 在dentry中持有一个引用可以确保dentry不会突然被释放并用作其他用途，这样各个字段的值会按照预期进行操作。同时，它在一定程度上保护了指向inode的-&gt;d_inode引用。 dentry与其inode之间的关联是相对固定的。例如，当文件被重命名时，dentry和inode会一起移动到新位置。当创建一个文件时，dentry最初是负的（即d_inode为NULL），在创建过程中会被分配到新的inode。 当文件被删除时，可以通过将d_inode设置为NULL或将其从用于在父目录中查找名称的哈希表中删除来在缓存中反映这一点。如果dentry仍在使用（例如打开的文件在删除后仍然被使用），则会使用第二个选项，因为保留dentry在这种情况下是合法的。仅当dentry未被其他方式使用（即d_lockref中的引用计数为1）时，才会将d_inode设置为NULL。这样做在某些常见情况下更加高效。 因此，只要持有一个对dentry的计数引用，非NULL的-&gt;d_inode值将永远不会改变。 举例说明： 假设我们有一个文件系统，其中包含一个名为file.txt的文件。在文件系统内部，dentry数据结构用于表示file.txt。当我们打开这个文件时，一个对应的dentry对象会被创建，并且它的d_inode字段会指向文件的inode。此时，d_lockref字段会确保对dentry对象的访问是同步的，以防止并发问题。 现在，假设我们要删除file.txt，但仍然保留一个打开的文件句柄。在这种情况下，dentry对象不会立即从内存中删除，而是会从哈希表中删除，以反映文件已被删除。这样，我们仍然可以继续使用打开的文件句柄，直到最后一个引用被释放。这时，d_inode字段才会被设置为NULL，dentry对象最终会被释放。 dentry-&gt;d_lockd_lock是上文提到的d_lockref中自旋锁（spinlock）的同义词。在这里，持有d_lock可以保护dentry不被重命名或取消链接。特别地，它的父节点（d_parent）和名称（d_name）不能被更改，且无法从dentry哈希表中删除。 在查找目录中的名称时，REF-walk会对在哈希表中找到的每个候选dentry持有d_lock，然后检查父节点和名称是否正确。因此，在缓存中搜索时，它不会锁定父节点，只会锁定子节点。 在查找给定名称的父节点时（处理“..”），REF-walk可以持有d_lock以获取对d_parent的稳定引用，但首先会尝试更轻量级的方法。如在dget_parent()中所见，如果可以在父节点上声明一个引用，并且随后可以看到d_parent没有发生变化，则实际上无需在子节点上持有锁。 举例说明： 假设我们有一个文件系统，其中包含一个目录dir，dir中有两个文件：file1.txt和file2.txt。在文件系统内部，dentry数据结构用于表示目录和文件。这里，d_lock用于保护dentry对象在查找过程中的一致性。 当我们在dir目录中查找file1.txt时，REF-walk首先会在哈希表中查找候选dentry对象（可能是file1.txt的dentry）。为了确保dentry对象在此过程中不会被重命名或取消链接，REF-walk会在检查父节点（d_parent）和名称（d_name）之前持有d_lock。这样可以确保在查找过程中，我们不会因为并发操作而导致不一致的结果。 同样，在处理“..”时（查找当前目录的父目录），REF-walk会尝试首先通过轻量级的方法获取父节点dentry的引用。只有在无法使用轻量级方法时，REF-walk才会持有d_lock以确保d_parent引用的稳定性。 rename_lockrename_lock是一个顺序锁（seqlock），用于在dentry重命名期间保护查找过程免受不一致状态的影响。 在给定目录中查找特定名称包括根据两个值（名称和目录的dentry）计算哈希值，访问哈希表中的对应槽位，并在那里找到的链表中进行搜索。 当dentry被重命名时，名称和父dentry都可能发生变化，因此哈希值几乎肯定会改变。这会将dentry移动到哈希表中的另一个链中。如果在这种情况下，文件名搜索恰好查找到被移动的dentry，它可能会沿着错误的链继续搜索，从而错过正确链的部分内容。 名称查找过程（d_lookup()）并不试图阻止这种情况发生，而是检测何时发生这种情况。当任何dentry被重命名时，rename_lock会更新。如果d_lookup()在扫描哈希表中的链时发现重命名发生了，它会简单地重试查找。 rename_lock还用于检测和防御针对LOOKUP_BENEATH和LOOKUP_IN_ROOT的潜在攻击，当解析“..”时（父目录被移出根目录，绕过path_equal()检查）。如果在查找过程中rename_lock被更新且路径遇到“..”，则发生了潜在的攻击，handle_dots()会返回错误-EAGAIN。 举例说明： 假设我们有一个文件系统，其中包含一个目录dir1，dir1中有两个文件：file1.txt和file2.txt。现在，我们想要将file1.txt重命名为file3.txt。在文件系统内部，dentry数据结构用于表示目录和文件。这里，rename_lock用于在重命名过程中确保查找操作的一致性。 当我们在dir1目录中查找file1.txt时，如果在查找过程中file1.txt被重命名为file3.txt，查找操作可能会沿着错误的哈希链进行。为了避免这种情况，d_lookup()使用rename_lock来检测重命名操作是否发生。如果发现重命名操作发生，则d_lookup()会重试查找，以确保查找结果的正确性。 此外，在处理“..”时（查找当前目录的父目录），rename_lock会检测并防御潜在的攻击，例如在查找过程中父目录被移出根目录。如果在查找过程中遇到这种情况，handle_dots()会返回错误-EAGAIN，以保护文件系统的完整性。 inode-&gt;i_rwsem12345struct inode &#123; ... struct rw_semaphore i_rwsem; /* 读写信号量，用于保护 inode 结构 */ ...&#125; i_rwsem与d_lock的作用互补：目录上的i_rwsem保护该目录中的所有名称，而目录中名称上的d_lock仅保护一个名称。对dcache的大多数更改会在相关目录的inode上持有i_rwsem，并在更改发生时短暂地在一个或多个dentry上获取d_lock。一个例外是由于内存压力而从dcache中删除空闲dentry，这使用d_lock，但i_rwsem不起作用。 i_rwsem是一个读&#x2F;写信号量，用于对特定目录中的所有更改进行序列化。这可以确保例如unlink()和rename()不能同时发生。在文件系统请求查找当前不在dcache中的名称时或在使用readdir()检索目录中条目列表时，它还可以保持目录的稳定。 信号量以两种不同的方式影响路径名查找。首先，它在目录中查找名称期间阻止更改。walk_component()首先使用lookup_fast()，它依次检查名称是否在缓存中，仅使用d_lock锁定。如果没有找到名称，walk_component()会回退到lookup_slow()，它在i_rwsem上获取共享锁，再次检查名称是否在缓存中，然后调用文件系统以获取确切的答案。无论结果如何，新的dentry都将添加到缓存中。 walk_component identifier - Linux source code (v6.3.8) - Bootlin 123456789101112131415161718192021222324252627282930313233343536// 定义一个名为 walk_component 的函数，参数包括一个指向 nameidata 结构体的指针和一个整数 flagsstatic const char *walk_component(struct nameidata *nd, int flags)&#123; // 定义一个指向 dentry 结构体的指针 struct dentry *dentry; /* * &quot;.&quot; 和 &quot;..&quot; 是特殊的 - 尤其是 &quot;..&quot;，因为它必须知道当前根目录和 * 父目录之间的关系。 */ // 如果 nd-&gt;last_type 不是 LAST_NORM，则执行以下代码 if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 handle_dots 函数处理 &quot;.&quot; 和 &quot;..&quot; return handle_dots(nd, nd-&gt;last_type); &#125; // 调用 lookup_fast 函数进行快速查找 dentry = lookup_fast(nd); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果 dentry 为 NULL，则执行以下代码 if (unlikely(!dentry)) &#123; // 调用 lookup_slow 函数进行慢速查找 dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 step_into 函数进入下一个组件（目录或文件） return step_into(nd, flags, dentry);&#125; 其次，当路径名查找到达最后一个组件时，有时需要在执行最后查找之前在i_rwsem上获取独占锁，以实现所需的排斥。路径查找如何选择获取或不获取i_rwsem是后续部分讨论的问题之一。 举例说明： 假设我们有一个目录，其中包含两个文件：file1.txt和file2.txt。当我们在目录中查找file1.txt时，i_rwsem信号量用于确保在查找过程中不会发生对目录的更改，例如删除或重命名文件。 现在，假设两个线程同时尝试查找同一个名称file3.txt，该名称尚未在dcache中。i_rwsem上的共享锁不会阻止它们都将具有相同名称的新dentry添加到dcache中。为了避免混乱，基于辅助哈希表（in_lookup_hashtable）和每个dentry的标志位（DCACHE_PAR_LOOKUP）使用额外的互锁级别。 在仅持有i_rwsem上的共享锁的情况下，线程必须调用d_alloc_parallel()将新的dentry添加到缓存中。这会分配一个dentry，将所需的名称和父级存储在其中，检查主要或辅助哈希表中是否已经有匹配的dentry，如果没有，则将新分配的dentry存储在辅助哈希表中，并设置DCACHE_PAR_LOOKUP。 如果在主哈希表中找到匹配的dentry，则返回该dentry，调用者可以知道它与添加条目的其他线程发生了竞争。如果在任何缓存中都没有找到匹配的dentry，则返回新分配的dentry，并从DCACHE_PAR_LOOKUP的存在中检测到这一点。在这种情况下，它知道它赢得了任何竞争，现在负责要求文件系统执行查找并找到匹配的inode。当查找完成时，它必须调用d_lookup_done()，该函数会清除标志并执行一些其他清理工作，包括从辅助哈希表中删除dentry - 通常已将其添加到主哈希表中。请注意，必须将struct waitqueue_head传递给d_alloc_parallel()，并且在此waitqueue_head仍在范围内时调用d_lookup_done()。 如果在辅助哈希表中找到匹配的dentry，d_alloc_parallel()需要执行更多的工作。首先，它使用传递给赢得竞赛的d_alloc_parallel()实例的wait_queue等待DCACHE_PAR_LOOKUP被清除，这个wait_queue将由d_lookup_done()调用唤醒。然后，它检查dentry是否已添加到主哈希表中。如果已经添加，则返回dentry，并且调用者只需看到它输掉了任何竞赛。 如果尚未将其添加到主哈希表中，最可能的解释是使用d_splice_alias()添加了其他dentry。无论如何，d_alloc_parallel()会从头开始重复所有查找，通常会从主哈希表中返回某些内容。 mnt-&gt;mnt_countmnt_count在mount结构体中。 mnt_count是一个基于每个CPU的引用计数器，用于跟踪“mount”结构的引用计数。这里的每个CPU意味着递增计数器的操作成本较低，因为它仅使用当前CPU的本地内存。但是，检查计数器是否为零的操作成本较高，因为需要与每个CPU进行检查。 持有一个mnt_count引用可以防止挂载结构因为常规卸载（unmount）操作而消失，但不能防止“懒惰”卸载（lazy unmount）。因此，持有mnt_count并不能确保挂载保持在命名空间中，特别是不能稳定连接到挂载点的dentry。然而，它确保了挂载数据结构的一致性，并提供了对挂载文件系统根dentry的引用。因此，通过mnt_count引用可以提供对挂载dentry的稳定引用，但不能提供对挂载点dentry的稳定引用。 mount_lockmount_lock是一个全局序列锁seqlock，类似于rename_lock。它可以用来检查是否对任何挂载点进行了更改。 在沿着树向下（远离根节点）遍历时，当跨越挂载点时使用此锁来检查跨越操作是否安全。具体来说，先读取序列锁中的值，然后找到当前目录上的挂载（如果有），并递增mnt_count。最后，检查mount_lock中的值是否与旧值相同。如果没有变化，则跨越操作是安全的。如果发生了变化，mnt_count会递减，然后重试整个过程。 当沿着树向上（朝向根节点）遍历时，通过跟踪“..”链接，需要更多的注意。在这种情况下，完全锁定序列锁（包含计数器和自旋锁）以防止在向上步骤时更改任何挂载点。这种锁定是为了稳定挂载点上的dentry连接，而挂载本身的引用计数并不能确保这一点。 mount_lock还用于检测并防御针对LOOKUP_BENEATH和LOOKUP_IN_ROOT的潜在攻击，例如在解析“..”链接时（父目录被移动到根目录之外，绕过path_equal()检查）。如果在查找过程中更新了mount_lock并且路径遇到了“..”，则可能发生了潜在的攻击，此时handle_dots()将返回-EAGAIN错误。 “managed” dentries这些 dentries 有三个可能的特性，对应于 dentry-&gt;d_flags 中可能设置的三个不同标志： DCACHE_MANAGE_TRANSIT：如果设置了此标志，文件系统要求在处理任何可能的挂载点之前调用 d_manage() dentry 操作。这可以执行两个特定的服务： 它可以阻塞以避免竞争。如果正在卸载自动挂载点，则 d_manage() 函数通常会等待该过程完成，然后再让新的查找继续，并可能触发新的自动挂载。 例如，当卸载一个 NFS 共享目录时，该共享目录正在被其他进程访问。在这种情况下，d_manage() 函数将等待卸载过程完成，然后再继续执行新的查找。 它可以有选择地只允许某些进程穿越挂载点。当服务器进程管理自动挂载时，它可能需要访问目录而不触发常规自动挂载处理。该服务器进程可以向 autofs 文件系统标识自己，然后通过返回 -EISDIR 给它一个特殊的通过 d_manage() 的通行证。 举例来说，autofs 守护进程可能需要访问自动挂载点的目录，但在此过程中不希望触发自动挂载。在这种情况下，autofs 守护进程可以通过 d_manage() 函数获得特殊的通行证，以避免自动挂载。 DCACHE_MOUNTED：此标志设置在每个已挂载的 dentry 上。由于 Linux 支持多个文件系统命名空间，因此有可能 dentry 可能不在此命名空间中挂载，而只是在其他命名空间中。因此，此标志被视为提示，而非承诺。 如果设置了此标志，并且 d_manage() 没有返回 -EISDIR，则调用 lookup_mnt() 来检查挂载哈希表（遵循前面描述的 mount_lock），并可能返回一个新的 vfsmount 和一个新的 dentry（都具有计数引用）。 DCACHE_NEED_AUTOMOUNT：如果 d_manage() 允许我们到达这里，并且 lookup_mnt() 没有找到挂载点，则此标志会导致调用 d_automount() dentry 操作。 d_automount() 操作可以任意复杂，可能与服务器进程等进行通信，但最终应报告错误、没有要挂载的内容，或者应提供一个带有新 dentry 和 vfsmount 的更新 struct path。 在后一种情况下，将调用 finish_automount() 以安全地将新挂载点安装到挂载表。 RCU-walk - faster pathname lookup in Linux RCU-walk 是 Linux 中执行路径名查找的另一种算法。 RCU-walk 是一种用于在 Linux 文件系统中查找路径名的方法。路径名查找是在文件系统中根据给定路径名找到对应文件或目录的过程。例如，当您尝试打开一个文件时，操作系统需要找到文件的实际位置。 它与 REF-walk 类似，二者共享相当多的代码。 这意味着 RCU-walk 和 REF-walk 在执行路径名查找时有许多共同之处。它们之间的代码重用意味着它们在处理某些情况时可能具有相似的行为。 RCU-walk 与 REF-walk 的重要区别在于它允许并发访问的可能性。 RCU-walk 的一个显著特点是它支持并发访问，这意味着多个进程可以同时进行路径名查找，而不会互相干扰。这对于提高系统性能和响应时间非常重要，特别是在高负载和多核处理器的环境中。 例如，在一个高负载服务器上，有多个进程需要同时访问文件系统。使用 RCU-walk，这些进程可以并发执行路径名查找，而不会导致锁争用或其他性能问题。 RCU-walk 通过简单地拒绝处理一些情况来降低这种复杂性，而是回退到 REF-walk。 RCU-walk 在遇到特定的复杂情况时，会回退到 REF-walk。这意味着 RCU-walk 没有处理所有可能的路径名查找情况，而是将一些复杂任务留给 REF-walk。这样可以降低 RCU-walk 的复杂性，使其在大多数情况下更高效。 例如，当查找涉及到路径名中的符号链接时，RCU-walk 可能回退到 REF-walk，因为处理符号链接通常需要额外的步骤和锁定。 依赖 RCU 时的锁定规则与传统锁定有很大不同。 RCU（Read-Copy-Update）是一种同步机制，允许读取操作与更新操作并发进行，而无需对读取操作进行锁定。这种方法与传统的锁定机制有很大不同，需要一些时间来理解和适应。 例如，在传统的锁定机制中，读取和写入操作可能需要等待资源上的锁。而在 RCU 机制下，读取操作可以在不等待锁的情况下进行，从而提高性能。 Clear demarcation of roles 强制停止其他线程更改给定线程正在查看的数据结构是管理并发性的最简单方法。 在处理并发时，一种简单的方法是确保一个线程在访问数据结构时，其他线程无法对其进行更改。 示例：假设我们有一个多线程应用程序，其中一个线程正在读取共享数据结构。为了避免其他线程在此期间进行更改，我们可以使用互斥锁来阻止它们。 在没有其他线程想要更改数据且许多不同线程想要同时读取数据的情况下，这可能非常昂贵。 互斥锁等同步机制，尽管可以防止数据竞争，但可能导致性能损失，特别是当多个线程需要同时读取数据时。 示例：假设一个文件系统具有大量读取操作和很少的写入操作。在这种情况下，使用互斥锁可能会导致不必要的性能损失，因为每个读取操作都需要等待锁。 所以，在读取没有其他进程更改的共享数据结构时的目标是完全避免将任何内容写入内存。不采用锁，不增加计数，不留下痕迹。 如果可以确保没有并发写入操作，最佳策略是在读取共享数据结构时完全避免使用锁等同步机制。 示例：在前面的文件系统示例中，一种更好的方法可能是使用 RCU（Read-Copy-Update）等无锁同步机制，以便在不影响性能的情况下同时执行多个读取操作。 REF-walk 机制当然不遵循这一原则，但它实际上是为可能有其他线程修改数据的情况而设计的。 REF-walk 机制在设计上主要用于处理可能存在并发写入操作的情况。 相比之下，RCU-walk 适用于频繁读取和偶尔写入的常见情况。 RCU-walk 机制主要用于处理多个读取操作和少量写入操作的场景。 对于其他部分，RCU-walk 能够快速回退到使用 REF-walk 是很重要的。 在 RCU-walk 无法处理某些情况时，它可以快速切换回 REF-walk 以确保正确处理这些情况。 路径名查找始终以 RCU-walk 模式开始，但只要查找的内容在缓存中且稳定，就会保持在该模式下。 RCU-walk 会尝试优先使用高效的无锁方式进行路径名查找，只要查找的内容在缓存中且未发生更改。 如果注意到某些内容发生了更改或正在更改，或者某些内容不在缓存中，则尝试优雅地停止并切换到 REF-walk。 在 RCU-walk 遇到无法处理的情况时，它会尝试切换回 REF-walk，以确保查找操作可以继续进行。 这种停止需要在当前的 vfsmount 和 dentry 上获取计数引用，并确保它们仍然有效。 在 RCU-walk 尝试切换到 REF-walk 时，它需要确保当前的 vfsmount 和 dentry 仍然有效。这是 RCU-walk 需要保证的一个不变式。换句话说，RCU-walk 需要确保在 REF-walk 下执行的路径查找将找到相同的条目。 如果优雅地停止成功，则其余路径将使用可靠但略显迟钝的 REF-walk 进行处理。 在 RCU-walk 成功切换到 REF-walk 时，路径查找将继续使用 REF-walk，尽管它可能比 RCU-walk 稍慢。 如果 RCU-walk 发现无法优雅地停止，它会放弃并从顶部重新开始 REF-walk。 这意味着在 RCU-walk 无法正确切换到 REF-walk 时，它将重新启动查找操作，并从一开始就使用 REF-walk。 这种“尝试 RCU-walk，如果失败则尝试 REF-walk”的模式可以在诸如 filename_lookup()、filename_parentat()、do_filp_open() 和 do_file_open_root() 等函数中清晰地看到。 在实际代码中，这些函数会先尝试使用 RCU-walk，如果失败，会退回到 REF-walk。在这些函数中，您可以看到它们尝试以不同的模式调用 path_*() 函数，直到找到一个有效的模式。 首先使用 LOOKUP_RCU 设置来请求“RCU-walk”。如果以 ECHILD 错误失败，它们会再次调用没有特殊标志的 path_*() 函数以请求“REF-walk”。 这些函数首先尝试 RCU-walk（通过设置 LOOKUP_RCU 标志），如果遇到 ECHILD 错误，它们将尝试使用 REF-walk（没有特殊标志）。 如果两者中的任何一个报告 ESTALE 错误，最后会尝试使用 LOOKUP_REVAL 设置（没有 LOOKUP_RCU）以确保在缓存中找到的条目被强制重新验证。 在遇到 ESTALE 错误时，这些函数会尝试使用 LOOKUP_REVAL 标志进行最后的尝试。这将确保缓存中的条目得到强制重新验证，以防止使用陈旧的数据。 LOOKUP_RCU 尝试可能会在内部删除该标志并切换到 REF-walk，但永远不会尝试切换回 RCU-walk。 一旦尝试切换到 REF-walk，代码将不再尝试返回到 RCU-walk。这是因为在树的叶子节点附近更容易使 RCU-walk 失败，所以在这种情况下，尝试切换回 RCU-walk 的收益可能微乎其微。 RCU and seqlocks: fast and light RCU（Read-Copy-Update）和 seqlocks 是 Linux 内核中用于同步的两种技术。RCU-walk 和 REF-walk 是两种遍历文件系统路径的方法。RCU-walk 利用 RCU 和 seqlocks 进行同步，而 REF-walk 则使用引用计数和锁。 RCU 提供的保证是，当 RCU 读锁被持有时，关键的数据结构（如 dentries、inodes、super_blocks 和 mounts）不会被释放。这意味着这些数据结构的字段在此期间仍然具有意义。然而，RCU 之外的所有同步工作都通过 seqlocks 完成。 与 REF-walk 不同，RCU-walk 不会增加引用计数或获取锁。相反，RCU-walk 会检查数据结构的状态是否已经发生了变化，如果有变化则会中止或重试。 为了保证 RCU-walk 和 REF-walk 的行为一致性，RCU-walk 需要在与 REF-walk 操作引用计数或锁的相同位置进行状态检查。在这些位置，RCU-walk 使用 read_seqcount_begin() 或类似函数采样 seqlock 的状态。当 REF-walk 减少引用计数或释放锁时，RCU-walk 使用 read_seqcount_retry() 或类似函数检查采样的状态是否仍然有效。 如果 RCU-walk 在受 seqlock 保护的结构中访问两个不同的字段，或者两次访问相同的字段，不能保证这些访问之间的一致性。在需要一致性时，RCU-walk 必须复制这些字段，然后使用 read_seqcount_retry() 验证这些复制是否有效。 read_seqcount_retry() 不仅检查序列号，还强制执行内存屏障，确保在调用之前的内存读取指令不会在调用之后执行。这样可以确保数据的一致性。 mount_lock and nd-&gt;m_seq mount_lock 是一个 seqlock，用于确保在跨越挂载点时的安全性。REF-walk 和 RCU-walk 都会使用它，但 RCU-walk 使用它的目的更广泛。 与 REF-walk 不同，RCU-walk 不会在遍历 vfsmount 树时为每个 vfsmount 增加引用计数。而是在遍历开始时对 mount_lock 的状态进行采样，并将此初始序列号存储在 struct nameidata 的 m_seq 字段中。这个锁和序列号用于验证所有对 vfsmount 的访问和所有挂载点的跨越。由于挂载表的更改相对较少，因此在发生任何“挂载”或“卸载”时，使用 REF-walk 作为回退是合理的。 在 RCU-walk 序列结束时（无论是切换到 REF-walk 还是到达路径的末尾），都会检查 m_seq（使用 read_seqretry()）。在跨越挂载点向下（在 __follow_mount_rcu() 中）或向上（在 follow_dotdot_rcu() 中）时，也会检查 m_seq。如果发现它已经更改，整个 RCU-walk 序列将被中止，然后再次使用 REF-walk 处理路径。 如果 RCU-walk 发现 mount_lock 没有发生变化，那么它可以确信，如果 REF-walk 在每个 vfsmount 上都使用引用计数，结果将是相同的。这样可以确保至少对于 vfsmount 结构来说，不变性是成立的。 dentry-&gt;d_seq and nd-&gt;seq 与采用 d_reflock 的计数或锁定不同，RCU-walk 对每个 dentry 的 d_seq 进行采样，并将序列号存储在 nameidata 结构的 seq 字段中。因此，nd-&gt;seq 始终应该是 nd-&gt;dentry 的当前序列号。在复制并使用 dentry 的名称、父级或 inode 之前，需要重新验证这个序列号。 我们已经查看了名称的处理，父级仅在 follow_dotdot_rcu() 中访问，尽管它针对三种不同的情况，但遵循所需模式相对简单。 存储在 -&gt;d_inode 中的 inode 指针更有趣。inode 至少需要访问两次，一次是确定它是否为 NULL，另一次是验证访问权限。符号链接处理也需要经过验证的 inode 指针。为避免每次访问都进行重新验证，第一次访问时会进行复制，并将其存储在 nameidata 的 inode 字段中，从那里可以在无需进一步验证的情况下安全地访问它。 lookup_fast() 是唯一在 RCU 模式下使用的查找例程，因为 lookup_slow() 速度较慢且需要锁。在 lookup_fast() 中，我们可以找到跟踪当前 dentry 的重要“逐个传递”操作。 lookup_fast() 将当前 dentry 和当前序列号传递给 __d_lookup_rcu()，成功时，它会返回一个新的 dentry 和一个新的序列号。lookup_fast() 随后复制 inode 指针并重新验证新序列号。然后，它使用旧序列号最后一次验证旧 dentry，然后继续。这个过程获取新 dentry 的序列号并检查旧序列号，与我们在 REF-walk 中看到的获取新 dentry 的计数引用并在此之前丢弃旧 dentry 的过程完全一致。 举个例子：假设有如下目录结构： 123456/├─ /dir1│ ├─ /dir1/dir2│ └─ /dir1/dir3└─ /dir4 └─ /dir4/dir5 在遍历路径 /dir1/dir2/file 时，我们会在不同的 dentry 之间移动，例如从 / 到 /dir1，再到 /dir1/dir2。在每个步骤中，我们都需要检查序列号以确保 dentry 结构在遍历期间没有发生变化。 No inode-&gt;i_rwsem or even rename_lock inode-&gt;i_rwsem 是一个信号量，它是一种相对较重的锁，只有在允许睡眠的情况下才能获取。由于 rcu_read_lock() 不允许睡眠，因此 inode-&gt;i_rwsem 在 RCU-walk 中不起作用。如果某个其他线程获取了 i_rwsem 并以 RCU-walk 需要注意的方式修改目录，则结果可能是 RCU-walk 无法找到它正在寻找的 dentry，或者找到一个 read_seqretry() 无法验证的 dentry。在这两种情况下，它都将切换到 REF-walk 模式，该模式可以获取所需的任何锁。 举例说明：假设有两个线程正在并发访问文件系统。一个线程在执行 RCU-walk，而另一个线程获取了 i_rwsem 并修改了目录。这个修改可能导致 RCU-walk 无法找到目标 dentry，这时 RCU-walk 会切换到 REF-walk 模式，以便可以获取所需的锁来确保正确处理目录结构的变化。 尽管 RCU-walk 可以使用不需要任何睡眠的 rename_lock，但 RCU-walk 并不使用它。REF-walk 使用 rename_lock 来防止在搜索 dcache 中的哈希链时发生更改。这可能导致无法找到实际存在的内容。当 RCU-walk 在 dentry 缓存中无法找到某个内容时（无论实际上是否存在），它已经切换到 REF-walk，并在适当的锁定下再次尝试。这种方式可以处理所有情况，因此添加对 rename_lock 的额外检查将没有太大价值。 例如，假设 RCU-walk 在查找 dcache 中的某个 dentry 时，由于目录结构发生了变化而没有找到。这时，RCU-walk 会切换到 REF-walk 模式，使用 rename_lock 等锁来确保目录结构的一致性。这样，无论 dentry 是否存在，REF-walk 都可以正确处理所有情况。 unlazy walk() and complete_walk() “切换到 REF-walk” 通常涉及对 unlazy_walk() 的调用，因为“RCU-walk”有时也被称为“lazy walk”。当沿着路径成功到达当前 vfsmount&#x2F;dentry 对，但下一步存在问题时，调用 unlazy_walk()。 例如，如果在 dcache 中找不到下一个名称，如果在持有 rcu_read_lock()（禁止睡眠）的情况下无法完成权限检查或名称重新验证，如果找到了自动挂载点，或者在涉及符号链接的一些情况下，都可能发生这种情况。 当查找到达最后一个组件或路径的最后时，unlazy_walk() 也会从 complete_walk() 中被调用，具体取决于使用的查找类型。 退出 RCU-walk 的其他原因，不会触发对 unlazy_walk() 的调用，例如：当发现无法立即处理的不一致性，如 mount_lock 或 d_seq 序列锁报告的更改。在这些情况下，相关函数将返回 -ECHILD，这将触发使用 REF-walk 从头开始的新尝试。 对于 unlazy_walk() 是可选的情况，它基本上会在它持有的每个指针（vfsmount、dentry 和可能的一些符号链接）上获取引用，然后验证相关的序列锁是否已更改。如果发生了更改，它也会用 -ECHILD 中止，否则，切换到 REF-walk 将会成功，查找过程将继续。 在这些指针上获取引用并不像简单地增加计数器那样简单。如果您已经有一个引用（通常间接通过另一个对象），这样做可以获取第二个引用，但如果您根本没有计数引用，这是不够的。 对于 dentry-&gt;d_lockref，除非它被明确标记为“dead”（将计数器设置为 -128），否则增加引用计数器以获取引用是安全的。lockref_get_not_dead() 实现了这一点。 对于 mnt-&gt;mnt_count，只要使用 mount_lock 验证引用，就可以安全地获取引用。如果验证失败，以 mnt_put() 的标准方式放弃该引用可能不安全 - 卸载可能已经进行得太远。因此，当 legitimize_mnt() 中的代码发现它获得的引用可能不安全时，它会检查 MNT_SYNC_UMOUNT 标志，以确定应该使用简单的 mnt_put()，还是只减少计数并假装这一切都没有发生过。 Taking care in filesystems RCU-walk 主要依赖缓存信息，通常不会调用文件系统。但是，在 RCU-walk 中，除了前面提到的组件名称比较之外，还有两个地方可能涉及文件系统，文件系统需要小心处理。 如果文件系统有非标准的权限检查要求（如需要与服务器检查的网络文件系统），则在 RCU-walk 期间可能调用 i_op-&gt;permission 接口。在这种情况下，会传递额外的 “MAY_NOT_BLOCK” 标志，以便它知道不要休眠，而是在无法立即完成时返回 -ECHILD。i_op-&gt;permission 接收 inode 指针，而不是 dentry，因此无需担心进一步的一致性检查。然而，如果它访问其他文件系统数据结构，必须确保它们可以在仅持有 rcu_read_lock() 的情况下安全访问。这通常意味着它们必须使用 kfree_rcu() 或类似方法释放。 例如，假设有一个网络文件系统，它需要从服务器检查权限。在 RCU-walk 期间，为了避免阻塞，i_op-&gt;permission 接口会传递 “MAY_NOT_BLOCK” 标志。如果它不能立即完成，就会返回 -ECHILD。 如果文件系统可能需要重新验证 dcache 条目，则在 RCU-walk 中也可能调用 d_op-&gt;d_revalidate。此接口传递 dentry，但无法访问 inode 或 nameidata 中的 seq 数字，因此在访问 dentry 中的字段时需要特别小心。这种“额外的小心”通常涉及使用 READ_ONCE() 访问字段，并在使用结果之前验证结果是否不为 NULL。这种模式可以在 nfs_lookup_revalidate() 中看到。 例如，在 NFS 文件系统中，d_op-&gt;d_revalidate 接口可能会在 RCU-walk 期间被调用。访问 dentry 字段时，它需要使用 READ_ONCE() 函数，并确保结果不为 NULL。 A pair of patterns 第一种模式是“快速尝试并检查，如果失败则慢速尝试”。我们可以在整体方法上看到这种模式，首先尝试 RCU-walk，然后尝试 REF-walk；我们还可以在使用 unlazy_walk() 将剩余路径切换到 REF-walk 的地方看到这种模式。此外，在处理“..”链接时，我们还可以在 dget_parent() 函数中看到这种模式。它首先尝试快速获取引用，如果需要，会回退到加锁操作。 例如，当遍历文件系统时，首先尝试使用 RCU-walk（快速方法）。如果遇到无法立即解决的问题，如需要重新验证条目或权限检查，我们会改用 REF-walk（慢速方法）。 第二种模式是“快速尝试并检查，如果失败，重复尝试”。这种模式在 REF-walk 中使用 rename_lock 和 mount_lock 可以看到。RCU-walk 不使用这种模式，如果出现问题，放弃并尝试更稳定的方法会更安全。 例如，在 REF-walk 中，如果在重命名操作期间遇到锁竞争，我们可以使用这种模式。首先快速尝试获取锁，如果失败，我们会不断尝试，直到成功为止。 A walk among the symlinks 参考资料 A tour of the Linux VFS (tldp.org) The Virtual File System (VFS) — 虚拟文件系统 （VFS） (unitn.it) The Linux kernel: The Linux Virtual File System — Linux 内核：Linux 虚拟文件系统 (tue.nl) 虚拟文件系统_百度百科 (baidu.com) Linux操作系统学习笔记（十二）虚拟文件系统 | Ty-Chen’s Home Virtual file system - Wikipedia — 虚拟文件系统 - 维基百科 [高级操作系统] VFS详解（虚拟文件系统）_宇内虹游的博客-CSDN博客 File system - Wikipedia Yair Amir lectures (jhu.edu) linux虚拟文件系统浅析 - Linux操作系统：Ubuntu_Centos_Debian - 红黑联盟 (2cto.com) Filesystems in the Linux kernel — The Linux Kernel documentation — Linux 内核中的文件系统 — Linux 内核文档","categories":[],"tags":[]},{"title":"学习 Linux 内核操作","slug":"学习-Linux-内核操作","date":"2023-06-13T08:04:01.000Z","updated":"2023-07-14T08:25:27.705Z","comments":true,"path":"2023/06/13/学习-Linux-内核操作/","link":"","permalink":"http://example.com/2023/06/13/%E5%AD%A6%E4%B9%A0-Linux-%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C/","excerpt":"内核基本操作 查看系统存在的内核 1dpkg --list | grep linux-image 更新menu.list 1sudo update-grub 显示当前的内核 升级内核 1sudo apt-get dist-upgrade 删除内核 带有image的文件是需要删除的，一定要写全版本等字符。其他相关文件会自动删除。 1sudo apt-get remove --purge linux-headers-2.6.32-24-generic 系统垃圾清理 清理旧版本的软件缓存 1sudo apt-get autoclean 清理所有软件缓存 1sudo apt-get clean 删除系统不再使用的孤立软件 1sudo apt-get autoremove 编译内核","text":"内核基本操作 查看系统存在的内核 1dpkg --list | grep linux-image 更新menu.list 1sudo update-grub 显示当前的内核 升级内核 1sudo apt-get dist-upgrade 删除内核 带有image的文件是需要删除的，一定要写全版本等字符。其他相关文件会自动删除。 1sudo apt-get remove --purge linux-headers-2.6.32-24-generic 系统垃圾清理 清理旧版本的软件缓存 1sudo apt-get autoclean 清理所有软件缓存 1sudo apt-get clean 删除系统不再使用的孤立软件 1sudo apt-get autoremove 编译内核 安装必备软件 123456sudo apt install makesudo apt install build-essentialsudo apt install libncurses5-devsudo apt install bisonsudo apt install flexsudo apt install libssl-dev 从The Linux Kernel Archives上下载源码，然后解压，并进入文件夹，运行如下命令 123make mrpropermake cleanmake menuconfig 权限不够就在命令前面加上sudo 在执行完make menuconfig后，会产生图形界面。选择下方的save，将内核配置保存在.config文件中，然后选择exit退出。在编译内核之前，可以通过修改.config的内容来修改内核配置。 配置完成后，编译内核并安装。 1sudo make -j$(nproc) 如果下列错误 运行下列命令 1sudo apt-get install libelf-dev 继续进行编译，如果遇到如下错误 1make[2]: *** 没有规则可制作目标“debian/canonical-certs.pem”，由“certs/x509_certificate_list” 需求。 停止。 1make[2]: *** 没有规则可制作目标“debian/canonical-revoked-certs.pem”，由“certs/x509_revocation_list” 需求。 停止。 那么运行如下命令 1scripts/config --disable SYSTEM_TRUSTED_KEYS 1scripts/config --disable SYSTEM_REVOCATION_KEYS 之后继续编译至完成,然后安装内核 12sudo make modules_installsudo make install 切换运行内核 查看当前内核的启动顺序 1cat /boot/grub/grub.cfg |grep menuentry 修改文件在启动时选择内核 1sudo vim /etc/default/grub 更新文件 1sudo update-grub 重启系统 1sudo reboot now 选择Advanced options for Ubuntu 选择要启动的内核 添加输出12345if (strstr(current-&gt;comm, &quot;cat&quot;))//过滤 printk(&quot;%p&quot;,f1);//输出printk(KERN_INFO &quot; %s\\n&quot;, ...); 切换cgroupv1-&gt;cgroupv212345sudo vim /etc/default/grubsystemd.unified_cgroup_hierarchy=1GRUB_CMDLINE_LINUX_DEFAULT=&quot;systemd.unified_cgroup_hierarchy=1&quot;sudo update-grubsudo reboot now","categories":[],"tags":[]},{"title":"学习 Linux tmpfs","slug":"学习-Linux-tmpfs","date":"2023-06-10T12:58:52.000Z","updated":"2023-07-13T09:32:20.529Z","comments":true,"path":"2023/06/10/学习-Linux-tmpfs/","link":"","permalink":"http://example.com/2023/06/10/%E5%AD%A6%E4%B9%A0-Linux-tmpfs/","excerpt":"tmpfs简介tmpfs（英语：temporary file system） 是类Unix系统上暂存档存储空间的常见名称，通常以挂载文件系统方式实现，并将资料存储在易失性存储器而非永久存储设备中。和RAM disk的概念近似，但后者会呈现出具有完整文件系统的虚拟磁盘。 tmpfs的工作原理是，它使用计算机的内存来模拟一个文件系统，就像在硬盘上创建了一个虚拟的文件柜。当你在tmpfs上创建文件或文件夹时，实际上它们是存储在内存中的。这样，访问这些文件会非常快，因为内存的速度比硬盘快得多。但是，需要注意的是，当计算机关闭或重启时，内存中的数据会丢失，所以存储在tmpfs上的文件也会消失。","text":"tmpfs简介tmpfs（英语：temporary file system） 是类Unix系统上暂存档存储空间的常见名称，通常以挂载文件系统方式实现，并将资料存储在易失性存储器而非永久存储设备中。和RAM disk的概念近似，但后者会呈现出具有完整文件系统的虚拟磁盘。 tmpfs的工作原理是，它使用计算机的内存来模拟一个文件系统，就像在硬盘上创建了一个虚拟的文件柜。当你在tmpfs上创建文件或文件夹时，实际上它们是存储在内存中的。这样，访问这些文件会非常快，因为内存的速度比硬盘快得多。但是，需要注意的是，当计算机关闭或重启时，内存中的数据会丢失，所以存储在tmpfs上的文件也会消失。 tmpfs是一种特殊的文件系统，它可以让你把计算机的内存（RAM）当作硬盘来使用。这样做的优点是，因为内存的速度比硬盘快得多，所以访问存储在tmpfs上的文件会非常快。tmpfs通常用于存放临时文件，这些文件在计算机重启后会自动消失。这样可以避免硬盘上堆积很多不必要的临时文件，提高硬盘的使用效率和计算机的性能。 tmpfs文件系统使用创建和挂载tmpfs文件系统首先创建一个文件夹/home/plucky/path 运行mount命令，挂载tmpfs文件系统 1sudo mount -t tmpfs -o size=512M tmpfs 文件夹（/home/plucky/path) -t tmpfs表示我们要挂载的文件系统类型是tmpfs -o size=512M表示tmpfs文件系统的大小为512M字节 tmpfs是文件系统的名称 文件夹是挂载点的文件夹 现在，你已经成功挂载了一个tmpfs文件系统。您可以像使用普通目录一样使用它，例如在其中创建文件和子目录。但请记住，存储在此tmpfs文件系统上的文件和目录将仅保存在内存中，计算机重启后它们将消失。 在已经挂载的tmpfs文件系统中创建并存储一个新文件1$ echo &quot;This is a test file.&quot; &gt; /home/plucky/tmpfs/testfile.txt 假设已经将 tmpfs 文件系统挂载到了 /home/plucky/tmpfs 目录下。这个命令将在 /mnt/tmpfs 文件夹中创建一个名为 testfile.txt 的新文件，并写入文本 “This is a test file.”。 当这个命令执行时，将发生以下事情： 首先，shell 进程通过 open 或 openat 系统调用尝试创建或打开文件 /home/plucky/tmpfs/testfile.txt。系统调用的标志将包括 O_WRONLY（只写）和 O_CREAT（如果文件不存在则创建）。 内核将解析文件路径，并确认 /home/plucky/tmpfs 是一个已挂载的 tmpfs 文件系统。 在 tmpfs 文件系统中，内核将根据需要创建一个新的 inode。这涉及分配内存来存储 inode 本身以及文件的元数据（如权限、所有者等）。 文件创建成功后，shell 进程将获得一个文件描述符，用于写入文件。 然后，shell 进程通过 write 系统调用将文本 “This is a test file.” 写入文件。这将导致内核在 tmpfs 文件系统中分配内存来存储文件数据。 当文本被写入文件后，shell 进程使用 close 系统调用关闭文件描述符。 删除tmpfs文件系统的命令1rm /home/plucky/path/mytmpfs/testfile.txt 当运行此命令时，会发生以下事情： 首先，shell 进程通过 unlink 或 unlinkat 系统调用尝试删除文件 /home/plucky/path/mytmpfs/testfile.txt。 内核将解析文件路径，并确认 /mnt/tmpfs 是一个已挂载的 tmpfs 文件系统。 接下来，内核将通过 tmpfs 文件系统的 inode_operations 结构体中的 unlink 方法来执行删除操作。具体来说，对于 tmpfs，这个方法是 shmem_unlink。 shmem_unlink 函数将处理文件的内存释放。这包括释放文件数据占用的内存和文件元数据（如 inode）占用的内存。 最后，文件从文件系统中删除，不再可访问。 重启机器之后，tmpfs文件夹tmpfs文件系统中的文件被删除，而tmpfs文件系统也被卸载 如果要在系统启动时自动挂载tmpfs命令，需要将挂载信息添加到系统的启动配置文件中。这样每次系统启动时，该文件系统都会自动挂载。例如，要将一个 tmpfs 文件系统挂载到 /home/plucky/mytmpfs 目录，可以在 /etc/fstab 文件中添加以下行： 1tmpfs /home/plucky/mytmpfs tmpfs defaults 0 0 即运行一下命令 1sudo sh -c &#x27;echo &quot;tmpfs /home/plucky/path/mytmpfs tmpfs defaults 0 0&quot; &gt;&gt; /etc/fstab&#x27; sudo 命令用于以管理员权限运行此命令，因为 /etc/fstab 文件需要管理员权限才能修改。 tmpfs的实现函数调用链（Linux v6.3.6，v6.3.7为例） 挂载tmpfs文件系统： 12345678910mount └── do_mount └── path_mount └── do_new_mount ├── vfs_get_tree（基于给定的上下文创建并初始化一个新的文件系统实例） │ └── shmem_get_tree │ └── shmem_fill_super │ └── shmem_get_inode └── do_new_mount_fs └── do_add_mount 存储文件进入tmpfs文件系统： 打开文件或创建新文件： 1234567891011121314151617open() └── do_sys_open └── do_filp_open ├── path_openat │ ├── link_path_walk │ │ ├── lookup_fast │ │ │ └── __d_lookup_rcu │ │ │ └── hlist_bl_for_each_entry_rcu │ │ └── lookup_slow │ │ └── __lookup_slow │ │ └──simple_lookup │ └── open_last_lookups（创建新文件） │ └──shmem_create │ └── shmem_mknod └── do_open └── vfs_open └── do_dentry_open 读文件： 123456read() └── ksys_read └── vfs_read └── new_sync_read └── call_read_iter └── shmem_file_read_iter 写文件： 123456789write() └── ksys_write └── vfs_write └── new_sync_write └── call_write_iter └── generic_file_write_iter └── __generic_file_write_iter ├── generic_file_direct_write直写 └── generic_perform_write回写 删除文件： 1234unlink() └── do_unlinkat └── vfs_unlink └── shmem_unlink 挂载tmpfs文件系统流程当用户运行mount命令时，首先执行mount系统调用 1sudo mount -t tmpfs -o size=512M tmpfs 文件夹 mount系统调用sys_mount identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 系统调用的定义，包括5个参数：dev_name, dir_name, type, flags, data。SYSCALL_DEFINE5(mount, char __user *, dev_name, char __user *, dir_name, char __user *, type, unsigned long, flags, void __user *, data)&#123; int ret; // 用于存储返回值 char *kernel_type; // 从用户空间拷贝的文件系统类型字符串 char *kernel_dev; // 从用户空间拷贝的设备名或源字符串 void *options; // 从用户空间拷贝的挂载选项 // 将文件系统类型从用户空间拷贝到内核空间 kernel_type = copy_mount_string(type); // 检查拷贝操作是否出错 ret = PTR_ERR(kernel_type); if (IS_ERR(kernel_type)) goto out_type; // 将设备名或源从用户空间拷贝到内核空间 kernel_dev = copy_mount_string(dev_name); // 检查拷贝操作是否出错 ret = PTR_ERR(kernel_dev); if (IS_ERR(kernel_dev)) goto out_dev; // 将挂载选项从用户空间拷贝到内核空间 options = copy_mount_options(data); // 检查拷贝操作是否出错 ret = PTR_ERR(options); if (IS_ERR(options)) goto out_data; // 执行挂载操作 ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options); // 释放挂载选项内存 kfree(options);out_data: // 释放设备名或源内存 kfree(kernel_dev);out_dev: // 释放文件系统类型内存 kfree(kernel_type);out_type: return ret; // 返回结果&#125; 首先将dev_name、dir_name、type和data这些从用户空间传入的参数拷贝到内核空间。然后，它调用do_mount函数来执行实际的挂载操作。 do_mount函数do_mount identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819long do_mount(const char *dev_name, const char __user *dir_name, const char *type_page, unsigned long flags, void *data_page)&#123; struct path path; // 用于存储挂载点的路径结构 int ret; // 用于存储返回值 // 获取用户空间传入的挂载点路径，并将其解析为内核空间的路径结构 ret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path); if (ret) // 检查路径解析是否成功 return ret; // 执行实际的挂载操作 ret = path_mount(dev_name, &amp;path, type_page, flags, data_page); // 释放路径结构的引用 path_put(&amp;path); return ret; // 返回结果&#125; 首先通过user_path_at函数将用户空间传入的挂载点路径解析为内核空间的path结构。然后，调用path_mount函数执行实际的挂载操作。完成挂载操作后，释放path结构的引用。 path_mount函数path_mount identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687int path_mount(const char *dev_name, struct path *path, const char *type_page, unsigned long flags, void *data_page)&#123; unsigned int mnt_flags = 0, sb_flags; // 定义挂载标志和超级块标志 int ret; // 用于存储返回值 // 去除挂载标志的幻数（magic number） if ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL) flags &amp;= ~MS_MGC_MSK; // 基本的参数检查 if (data_page) ((char *)data_page)[PAGE_SIZE - 1] = 0; // 检查不允许用户挂载的情况 if (flags &amp; MS_NOUSER) return -EINVAL; // 安全检查 ret = security_sb_mount(dev_name, path, type_page, flags, data_page); if (ret) return ret; if (!may_mount()) return -EPERM; if (flags &amp; SB_MANDLOCK) warn_mandlock(); // 默认设置为relatime，除非显式指定noatime if (!(flags &amp; MS_NOATIME)) mnt_flags |= MNT_RELATIME; // 分离每个挂载点的标志 if (flags &amp; MS_NOSUID) mnt_flags |= MNT_NOSUID; if (flags &amp; MS_NODEV) mnt_flags |= MNT_NODEV; if (flags &amp; MS_NOEXEC) mnt_flags |= MNT_NOEXEC; if (flags &amp; MS_NOATIME) mnt_flags |= MNT_NOATIME; if (flags &amp; MS_NODIRATIME) mnt_flags |= MNT_NODIRATIME; if (flags &amp; MS_STRICTATIME) mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME); if (flags &amp; MS_RDONLY) mnt_flags |= MNT_READONLY; if (flags &amp; MS_NOSYMFOLLOW) mnt_flags |= MNT_NOSYMFOLLOW; // 保留atime的默认值 if ((flags &amp; MS_REMOUNT) &amp;&amp; ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME | MS_STRICTATIME)) == 0)) &#123; mnt_flags &amp;= ~MNT_ATIME_MASK; mnt_flags |= path-&gt;mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK; &#125; // 设置超级块标志 sb_flags = flags &amp; (SB_RDONLY | SB_SYNCHRONOUS | SB_MANDLOCK | SB_DIRSYNC | SB_SILENT | SB_POSIXACL | SB_LAZYTIME | SB_I_VERSION); // 重新配置挂载点 if ((flags &amp; (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND)) return do_reconfigure_mnt(path, mnt_flags); // 重新挂载 if (flags &amp; MS_REMOUNT) return do_remount(path, flags, sb_flags, mnt_flags, data_page); // 绑定挂载 if (flags &amp; MS_BIND) return do_loopback(path, dev_name, flags &amp; MS_REC); // 更改挂载类型 if (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE)) return do_change_type(path, flags); // 移动挂载点 if (flags &amp; MS_MOVE) return do_move_mount_old(path, dev_name); // 执行新的挂载操作 return do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name, data_page);&#125; path_mount函数负责处理不同类型的挂载请求，包括重新挂载、绑定挂载、更改挂载类型和移动挂载点。首先，函数执行基本的参数检查、安全检查和设置挂载标志。接下来，根据不同的挂载标志，调用相应的处理函数。 do_new_mount函数do_new_mount identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static int do_new_mount(struct path *path, const char *fstype, int sb_flags, int mnt_flags, const char *name, void *data)&#123; struct file_system_type *type; // 文件系统类型 struct fs_context *fc; // 文件系统上下文 const char *subtype = NULL; // 子类型 int err = 0; // 错误码 // 验证文件系统类型是否为空 if (!fstype) return -EINVAL; // 获取文件系统类型 type = get_fs_type(fstype); if (!type) return -ENODEV; // 检查文件系统是否有子类型，并获取子类型 if (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &#123; subtype = strchr(fstype, &#x27;.&#x27;); if (subtype) &#123; subtype++; if (!*subtype) &#123; put_filesystem(type); return -EINVAL; &#125; &#125; &#125; // 创建文件系统上下文 fc = fs_context_for_mount(type, sb_flags); put_filesystem(type); // 减少文件系统类型的引用计数 if (IS_ERR(fc)) return PTR_ERR(fc); // 解析文件系统子类型 if (subtype) err = vfs_parse_fs_string(fc, &quot;subtype&quot;, subtype, strlen(subtype)); // 解析文件系统名称 if (!err &amp;&amp; name) err = vfs_parse_fs_string(fc, &quot;source&quot;, name, strlen(name)); // 解析挂载数据 if (!err) err = parse_monolithic_mount_data(fc, data); // 检查挂载权限 if (!err &amp;&amp; !mount_capable(fc)) err = -EPERM; // 获取文件系统树 if (!err) err = vfs_get_tree(fc); // 完成挂载操作 if (!err) err = do_new_mount_fc(fc, path, mnt_flags); // 释放文件系统上下文 put_fs_context(fc); return err;&#125; vfs_get_tree函数vfs_get_tree identifier - Linux source code (v6.3.8) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int vfs_get_tree(struct fs_context *fc)&#123; struct super_block *sb; // 超级块 int error; // 如果文件系统上下文中已经有一个根目录，则返回错误 if (fc-&gt;root) return -EBUSY; // 调用文件系统操作结构中的get_tree函数来获取文件系统树，并将根目录放在fc-&gt;root中 // 同时增加根目录和超级块的引用计数 error = fc-&gt;ops-&gt;get_tree(fc); if (error &lt; 0) return error; // 如果get_tree没有设置fc-&gt;root，则输出错误信息并触发BUG() if (!fc-&gt;root) &#123; pr_err(&quot;Filesystem %s get_tree() didn&#x27;t set fc-&gt;root\\n&quot;, fc-&gt;fs_type-&gt;name); BUG(); &#125; // 获取超级块 sb = fc-&gt;root-&gt;d_sb; // 检查超级块的块设备信息是否存在 WARN_ON(!sb-&gt;s_bdi); // 写内存屏障，确保超级块结构在设置SB_BORN标志位之前完成 smp_wmb(); // 设置超级块的SB_BORN标志位 sb-&gt;s_flags |= SB_BORN; // 设置安全模块的挂载选项 error = security_sb_set_mnt_opts(sb, fc-&gt;security, 0, NULL); if (unlikely(error)) &#123; // 如果设置失败，释放文件系统上下文并返回错误 fc_drop_locked(fc); return error; &#125; // 检查文件系统是否设置了错误的s_maxbytes值 WARN((sb-&gt;s_maxbytes &lt; 0), &quot;%s set sb-&gt;s_maxbytes to &quot; &quot;negative value (%lld)\\n&quot;, fc-&gt;fs_type-&gt;name, sb-&gt;s_maxbytes); return 0;&#125;EXPORT_SYMBOL(vfs_get_tree); get_tree函数是如何被设置为shmem_init函数的 当内核启动时，会执行shmem_init函数（定义在mm/shmem.c文件中）。这个函数会调用register_filesystem注册tmpfs文件系统。 shmem_init identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void __init shmem_init(void)&#123;// 初始化 inode 缓存shmem_init_inodecache();// 注册 tmpfs 文件系统int error = register_filesystem(&amp;shmem_fs_type);if (error) &#123; // 若注册失败，打印错误信息 pr_err(&quot;Could not register tmpfs\\n&quot;); // 跳转到 out2，执行清理操作 goto out2;&#125;// 尝试挂载 tmpfs 文件系统shm_mnt = kern_mount(&amp;shmem_fs_type);if (IS_ERR(shm_mnt)) &#123; // 若挂载失败，获取错误代码 error = PTR_ERR(shm_mnt); // 打印错误信息 pr_err(&quot;Could not kern_mount tmpfs\\n&quot;); // 跳转到 out1，执行清理操作 goto out1;&#125;#ifdef CONFIG_TRANSPARENT_HUGEPAGE// 如果支持透明巨页，且巨页设置不为禁用，设置巨页选项if (has_transparent_hugepage() &amp;&amp; shmem_huge &gt; SHMEM_HUGE_DENY) SHMEM_SB(shm_mnt-&gt;mnt_sb)-&gt;huge = shmem_huge;else // 否则，将巨页设置为永不使用，以防万一 shmem_huge = SHMEM_HUGE_NEVER;#endif// 成功执行，函数返回return;out1:// 清理操作：注销 tmpfs 文件系统unregister_filesystem(&amp;shmem_fs_type);out2:// 清理操作：销毁 inode 缓存shmem_destroy_inodecache();// 设置 shm_mnt 为错误指针，表示初始化失败shm_mnt = ERR_PTR(error);&#125; shmem_fs_type是一个file_system_type结构体，定义了tmpfs文件系统的基本信息。在这个结构体中，init_fs_context成员被设置为shmem_init_fs_context。 shmem_fs_type identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314static struct file_system_type shmem_fs_type = &#123;.owner = THIS_MODULE, // 指定文件系统模块的所有者.name = &quot;tmpfs&quot;, // 文件系统的名称.init_fs_context = shmem_init_fs_context, // 初始化文件系统上下文的回调函数#ifdef CONFIG_TMPFS.parameters = shmem_fs_parameters, // 指定文件系统的挂载参数解析回调#endif.kill_sb = kill_litter_super, // 用于销毁超级块的回调函数#ifdef CONFIG_SHMEM.fs_flags = FS_USERNS_MOUNT | FS_ALLOW_IDMAP, // 文件系统的标志（支持用户命名空间挂载和ID映射）#else.fs_flags = FS_USERNS_MOUNT, // 文件系统的标志（仅支持用户命名空间挂载）#endif&#125;; 当用户发起挂载tmpfs文件系统的请求时，内核会根据shmem_fs_type结构体中的init_fs_context成员调用shmem_init_fs_context函数，以初始化文件系统上下文（fs_context结构体）。 在shmem_init_fs_context函数中，会创建一个shmem_fs_context结构体实例并将其存储在fc-&gt;fs_private成员中。然后，将fs_context结构体的ops成员设置为&amp;shmem_fs_context_ops。 shmem_init_fs_context identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223int shmem_init_fs_context(struct fs_context *fc)&#123;// 定义一个指向 shmem_options 结构体的指针struct shmem_options *ctx;// 为 shmem_options 结构体分配内存ctx = kzalloc(sizeof(struct shmem_options), GFP_KERNEL);if (!ctx) // 如果内存分配失败，返回 ENOMEM 错误 return -ENOMEM;// 设置文件访问权限为 0777（用户、组和其他均有读、写和执行权限），并启用粘滞位ctx-&gt;mode = 0777 | S_ISVTX;// 获取当前进程的文件系统用户 ID，并将其设置为文件系统上下文的用户 IDctx-&gt;uid = current_fsuid();// 获取当前进程的文件系统组 ID，并将其设置为文件系统上下文的组 IDctx-&gt;gid = current_fsgid();// 将初始化后的 shmem_options 结构体赋给 fs_context 结构体的 fs_private 成员fc-&gt;fs_private = ctx;// 设置 fs_context 结构体的操作函数集fc-&gt;ops = &amp;shmem_fs_context_ops;// 返回 0，表示成功初始化文 shmem_fs_context_ops是一个fs_context_operations结构体，其中的get_tree成员被设置为shmem_get_tree。 shmem_fs_context_ops identifier - Linux source code (v6.3.6) - Bootlin 123456789static const struct fs_context_operations shmem_fs_context_ops = &#123;.free = shmem_free_fc,.get_tree = shmem_get_tree,#ifdef CONFIG_TMPFS.parse_monolithic = shmem_parse_options,.parse_param = shmem_parse_one,.reconfigure = shmem_reconfigure,#endif&#125;; 当内核继续执行挂载过程，调用vfs_get_tree函数时，会根据fs_context结构体的ops成员（即&amp;shmem_fs_context_ops）间接调用shmem_get_tree函数。 shmem_get_tree函数shmem_get_tree identifier - Linux source code (v6.3.6) - Bootlin 1234static int shmem_get_tree(struct fs_context *fc)&#123; return get_tree_nodev(fc, shmem_fill_super);&#125; shmem_fill_super函数shmem_fill_super identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128static int shmem_fill_super(struct super_block *sb, struct fs_context *fc)&#123; struct shmem_options *ctx = fc-&gt;fs_private;//ctx指向一个shmem_options结构体，包含了tmpfs实例的选项，如最大块数、最大inode数等。这些选项通常在挂载tmpfs时由用户指定。 struct inode *inode;//inode指向一个inode结构体，用于表示文件系统中的一个文件。这里的inode将用于表示tmpfs实例的根目录。 struct shmem_sb_info *sbinfo;//sbinfo指向一个shmem_sb_info结构体，包含了tmpfs实例的元数据，如最大块数、最大inode数、已使用的块数等。 /* Round up to L1_CACHE_BYTES to resist false sharing *//* 为shmem_sb_info结构体分配内存，考虑缓存对齐 */ sbinfo = kzalloc(max((int)sizeof(struct shmem_sb_info), L1_CACHE_BYTES), GFP_KERNEL); /* 分配内存失败时返回错误 */ if (!sbinfo) return -ENOMEM; /* 将shmem_sb_info结构体指针保存到super_block的s_fs_info字段 */ sb-&gt;s_fs_info = sbinfo;#ifdef CONFIG_TMPFS /* * Per default we only allow half of the physical ram per * tmpfs instance, limiting inodes to one per page of lowmem; * but the internal instance is left unlimited. *//**默认情况下，我们只允许每*tmpfs实例，将inode限制为每页lowmem一个；*但是内部实例是不受限制的。*///对于非内核挂载的tmpfs实例，设置默认的最大块数、最大inode数和是否使用64位inode编号。对于内核挂载的tmpfs实例，设置SB_N#ifdef CONFIG_TMPFS/* 判断是否为内核挂载 */ if (!(sb-&gt;s_flags &amp; SB_KERNMOUNT)) &#123; /* 设置默认的最大块数（如果未指定） */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_BLOCKS)) ctx-&gt;blocks = shmem_default_max_blocks(); /* 设置默认的最大inode数（如果未指定） */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_INODES)) ctx-&gt;inodes = shmem_default_max_inodes(); /* 设置是否使用64位inode编号（如果未指定） */ if (!(ctx-&gt;seen &amp; SHMEM_SEEN_INUMS)) ctx-&gt;full_inums = IS_ENABLED(CONFIG_TMPFS_INODE64); &#125; else &#123; /* 内核挂载的tmpfs实例，设置SB_NOUSER标志 */ sb-&gt;s_flags |= SB_NOUSER; &#125; /* 设置文件系统导出操作 */ sb-&gt;s_export_op = &amp;shmem_export_ops; /* 设置文件系统标志 */ sb-&gt;s_flags |= SB_NOSEC | SB_I_VERSION;#else /* 如果不支持tmpfs，设置SB_NOUSER标志 */ sb-&gt;s_flags |= SB_NOUSER;#endif /* 设置shmem_sb_info的最大块数字段 */ sbinfo-&gt;max_blocks = ctx-&gt;blocks; /* 设置shmem_sb_info的最大inode数量和空闲inode数量 */ sbinfo-&gt;free_inodes = sbinfo-&gt;max_inodes = ctx-&gt;inodes; /* 如果是内核挂载，为每个CPU分配一个ino_t类型的内存 */ if (sb-&gt;s_flags &amp; SB_KERNMOUNT) &#123; sbinfo-&gt;ino_batch = alloc_percpu(ino_t); /* 分配失败时跳转到失败处理 */ if (!sbinfo-&gt;ino_batch) goto failed; &#125; /* 设置uid和gid */ sbinfo-&gt;uid = ctx-&gt;uid; sbinfo-&gt;gid = ctx-&gt;gid; /* 设置是否使用64位inode编号 */ sbinfo-&gt;full_inums = ctx-&gt;full_inums; /* 设置权限模式 */ sbinfo-&gt;mode = ctx-&gt;mode; /* 设置是否使用大页面 */ sbinfo-&gt;huge = ctx-&gt;huge; /* 设置内存分配策略 */ sbinfo-&gt;mpol = ctx-&gt;mpol; /* 清空ctx的mpol指针，避免后续释放 */ ctx-&gt;mpol = NULL; /* 初始化stat_lock自旋锁 */ raw_spin_lock_init(&amp;sbinfo-&gt;stat_lock); /* 初始化used_blocks per-CPU计数器 */ if (percpu_counter_init(&amp;sbinfo-&gt;used_blocks, 0, GFP_KERNEL)) /* 初始化失败时跳转到失败处理 */ goto failed; /* 初始化shrinklist_lock自旋锁 */ spin_lock_init(&amp;sbinfo-&gt;shrinklist_lock); /* 初始化shrinklist链表头 */ INIT_LIST_HEAD(&amp;sbinfo-&gt;shrinklist); /* 设置文件系统的最大文件大小 */ sb-&gt;s_maxbytes = MAX_LFS_FILESIZE; /* 设置文件系统的块大小 */ sb-&gt;s_blocksize = PAGE_SIZE; /* 设置文件系统的块大小位数 */ sb-&gt;s_blocksize_bits = PAGE_SHIFT; /* 设置文件系统的魔数 */ sb-&gt;s_magic = TMPFS_MAGIC; /* 设置文件系统的操作函数集 */ sb-&gt;s_op = &amp;shmem_ops; /* 设置文件系统的时间粒度 */ sb-&gt;s_time_gran = 1;gran = 1;#ifdef CONFIG_TMPFS_XATTR sb-&gt;s_xattr = shmem_xattr_handlers; // 设置super_block的扩展属性处理器#endif#ifdef CONFIG_TMPFS_POSIX_ACL sb-&gt;s_flags |= SB_POSIXACL; // 如果支持POSIX ACL，设置super_block的POSIX ACL标志#endif uuid_gen(&amp;sb-&gt;s_uuid); // 生成一个新的UUID，并设置给super_block // 为根目录分配一个inode，并设置其属性 inode = shmem_get_inode(&amp;nop_mnt_idmap, sb, NULL, S_IFDIR | sbinfo-&gt;mode, 0, VM_NORESERVE); if (!inode) goto failed; // 如果inode分配失败，跳转到failed标签 inode-&gt;i_uid = sbinfo-&gt;uid; // 设置inode的用户ID inode-&gt;i_gid = sbinfo-&gt;gid; // 设置inode的组ID sb-&gt;s_root = d_make_root(inode); // 为根目录分配一个目录项 if (!sb-&gt;s_root) goto failed; // 如果目录项分配失败，跳转到failed标签 return 0; // 初始化成功，返回0failed: // 发生错误时，执行清理操作 shmem_put_super(sb); // 调用shmem_put_super进行清理 return -ENOMEM; // 返回-ENOMEM错误码&#125; shmem_get_inode函数shmem_get_inode identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static struct inode *shmem_get_inode(struct mnt_idmap *idmap, struct super_block *sb, struct inode *dir, umode_t mode, dev_t dev, unsigned long flags)&#123; struct inode *inode; struct shmem_inode_info *info; struct shmem_sb_info *sbinfo = SHMEM_SB(sb); ino_t ino; // 为新的inode预留一个系统内部的编号 if (shmem_reserve_inode(sb, &amp;ino)) return NULL; // 为新的inode分配内存 inode = new_inode(sb); if (inode) &#123; // 设置inode的编号 inode-&gt;i_ino = ino; // 初始化inode的所有者和权限模式 inode_init_owner(idmap, inode, dir, mode); // 设置inode的磁盘块数为0 inode-&gt;i_blocks = 0; // 设置inode的访问、修改和创建时间 inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode); // 设置inode的生成编号（用于NFS） inode-&gt;i_generation = get_random_u32(); // 获得shmem_inode_info结构（tmpfs专用） info = SHMEM_I(inode); // 初始化shmem_inode_info结构 memset(info, 0, (char *)inode - (char *)info); spin_lock_init(&amp;info-&gt;lock); atomic_set(&amp;info-&gt;stop_eviction, 0); info-&gt;seals = F_SEAL_SEAL; info-&gt;flags = flags &amp; VM_NORESERVE; info-&gt;i_crtime = inode-&gt;i_mtime; info-&gt;fsflags = (dir == NULL) ? 0 : SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED; if (info-&gt;fsflags) shmem_set_inode_flags(inode, info-&gt;fsflags); INIT_LIST_HEAD(&amp;info-&gt;shrinklist); INIT_LIST_HEAD(&amp;info-&gt;swaplist); simple_xattrs_init(&amp;info-&gt;xattrs); cache_no_acl(inode); mapping_set_large_folios(inode-&gt;i_mapping); // 根据不同的文件类型，设置相应的操作函数 switch (mode &amp; S_IFMT) &#123; default: inode-&gt;i_op = &amp;shmem_special_inode_operations; init_special_inode(inode, mode, dev); break; case S_IFREG: inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops; inode-&gt;i_op = &amp;shmem_inode_operations; inode-&gt;i_fop = &amp;shmem_file_operations; mpol_shared_policy_init(&amp;info-&gt;policy, shmem_get_sbmpol(sbinfo)); break; case S_IFDIR: inc_nlink(inode); inode-&gt;i_size = 2 * BOGO_DIRENT_SIZE; inode-&gt;i_op = &amp;shmem_dir_inode_operations; inode-&gt;i_fop = &amp;simple_dir_operations; break; case S_IFLNK: mpol_shared_policy_init(&amp;info-&gt;policy, NULL); break; &#125; // 为锁依赖分析系统设置inode互斥锁的标记 lockdep_annotate_inode_mutex_key(inode); &#125; else // 如果inode分配失败，则释放预留的编号 shmem_free_inode(sb); return inode;&#125; do_new_mount_fc函数namespace.c - fs&#x2F;namespace.c - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * 使用超级块配置创建一个新的挂载，并请求将其添加到命名空间树。 */static int do_new_mount_fc(struct fs_context *fc, struct path *mountpoint, unsigned int mnt_flags)&#123; struct vfsmount *mnt; struct mountpoint *mp; struct super_block *sb = fc-&gt;root-&gt;d_sb; int error; // 对超级块进行安全检查 error = security_sb_kern_mount(sb); if (!error &amp;&amp; mount_too_revealing(sb, &amp;mnt_flags)) error = -EPERM; // 如果出现错误，释放fs_context并返回错误 if (unlikely(error)) &#123; fc_drop_locked(fc); return error; &#125; // 释放超级块的umount锁 up_write(&amp;sb-&gt;s_umount); // 根据fs_context创建一个新的struct mount结构，每个挂载的文件系统都对应这样的一个结构 mnt = vfs_create_mount(fc); if (IS_ERR(mnt)) return PTR_ERR(mnt); // 对挂载的时间戳过期发出警告 mnt_warn_timestamp_expiry(mountpoint, mnt); // 锁定挂载点 mp = lock_mount(mountpoint); if (IS_ERR(mp)) &#123; mntput(mnt); return PTR_ERR(mp); &#125; // 将新挂载添加到挂载点并应用挂载标志，do_add_mount完成挂载操作 error = do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags); unlock_mount(mp); if (error &lt; 0) mntput(mnt); return error;&#125; do_add_mount函数do_add_mount identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637/* * 将挂载添加到命名空间的挂载树中 */static int do_add_mount(struct mount *newmnt, struct mountpoint *mp, const struct path *path, int mnt_flags)&#123; // 获取待挂载路径的父挂载实例 struct mount *parent = real_mount(path-&gt;mnt); // 清除内部挂载标志 mnt_flags &amp;= ~MNT_INTERNAL_FLAGS; // 检查父挂载实例是否有效 if (unlikely(!check_mnt(parent))) &#123; // 这只对在私有命名空间中进行的自动挂载是可接受的 if (!(mnt_flags &amp; MNT_SHRINKABLE)) return -EINVAL; // 对于这些情况，我们最好确保挂载点仍然有效 if (!parent-&gt;mnt_ns) return -EINVAL; &#125; // 拒绝在相同挂载点上使用相同的文件系统 if (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp; path-&gt;mnt-&gt;mnt_root == path-&gt;dentry) return -EBUSY; // 如果新挂载的根目录是符号链接，则返回错误 if (d_is_symlink(newmnt-&gt;mnt.mnt_root)) return -EINVAL; // 设置新挂载的挂载标志 newmnt-&gt;mnt.mnt_flags = mnt_flags; // 将新挂载添加到父挂载和挂载点 return graft_tree(newmnt, parent, mp);&#125; 相关结构体struct fs_contextfs_context identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324struct fs_context &#123; const struct fs_context_operations *ops; // 文件系统操作指针，用于设置特定文件系统的操作 struct mutex uapi_mutex; // 用户空间访问互斥锁，用于保护文件系统上下文的并发访问 struct file_system_type *fs_type; // 文件系统类型，指向一个描述文件系统特性的结构体 void *fs_private; // 文件系统私有上下文，用于存储特定文件系统实现的私有数据 void *sget_key; // 用于唯一标识文件系统实例的键，用于共享超级块的查找过程 struct dentry *root; // 文件系统的根目录入口，指向一个dentry结构体 struct user_namespace *user_ns; // 与此挂载关联的用户命名空间 struct net *net_ns; // 与此挂载关联的网络命名空间 const struct cred *cred; // 挂载者的凭据，包含用户/组ID等权限信息 struct p_log log; // 日志缓冲区，用于记录文件系统上下文的日志信息 const char *source; // 源名称（例如设备路径），用于标识挂载来源 void *security; // 用于存储Linux安全模块（LSM）的选项 void *s_fs_info; // 指向建议的s_fs_info数据，之后会存储在超级块的s_fs_info字段中 unsigned int sb_flags; // 建议的超级块标志（SB_*），用于挂载选项控制 unsigned int sb_flags_mask; // 改变的超级块标志的掩码 unsigned int s_iflags; // 与超级块s_iflags字段进行按位或的标志 unsigned int lsm_flags; // 从文件系统到LSM的信息标志 enum fs_context_purpose purpose:8; // 文件系统上下文的目的（例如挂载、重新挂载、移动挂载点等） enum fs_context_phase phase:8; // 文件系统上下文所处的阶段 bool need_free:1; // 标记是否需要调用ops-&gt;free()释放文件系统上下文 bool global:1; // 全局标志，表示是否进入&amp;init_user_ns的全局命名空间 bool oldapi:1; // 标记是否来自旧API（即mount(2)系统调用）&#125;; 该结构体用于保存超级块的信息的root，而超级块本身包含了该实际文件系统的信息，因此通过该结构体，我们可以使该文件系统和mount结构体建立联系。在旧版的Linux源码中，我们需要使用mount_fs()函数去获取对应的root，而新版则可以通过fs_context直接获取。 struct vfsmountvfsmount identifier - Linux source code (v6.3.6) - Bootlin 123456struct vfsmount &#123; struct dentry *mnt_root; // 指向已挂载文件系统树的根目录入口（dentry结构体） struct super_block *mnt_sb; // 指向与已挂载文件系统关联的超级块（super_block结构体） int mnt_flags; // 挂载标志，表示挂载时的选项，如只读、异步等 struct mnt_idmap *mnt_idmap; // 指向一个mnt_idmap结构体，用于存储用户和组ID的映射关系（仅在某些文件系统中使用，如NFS）&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 vfsmount结构体中mnt_root 是当前文件系统根目录的 dentry，mnt_sb 是指向超级块的指针。这里之所以会有mnt_mountpoint和mnt_root，是因为在挂载时该文件系统的根目录同时成为了其父文件系统的一个子目录（挂载点）。 struct mountmount identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142struct mount &#123; struct hlist_node mnt_hash; // 用于挂载点哈希表的链表节点 struct mount *mnt_parent; // 指向父挂载点的指针 struct dentry *mnt_mountpoint; // 指向挂载点位置的目录入口（dentry） struct vfsmount mnt; // 包含挂载文件系统相关信息的vfsmount结构体 union &#123; struct rcu_head mnt_rcu; // 用于RCU（Read-Copy-Update）同步的链表头 struct llist_node mnt_llist; // 用于延迟列表（llist）的链表节点 &#125;;#ifdef CONFIG_SMP struct mnt_pcp __percpu *mnt_pcp; // 指向每个CPU的mnt_pcp结构体的指针（仅在多处理器系统中使用）#else int mnt_count; // 挂载点的引用计数 int mnt_writers; // 写入操作的计数器#endif struct list_head mnt_mounts; // 子挂载点列表的链表头 struct list_head mnt_child; // 与mnt_mounts链表相连的链表节点 struct list_head mnt_instance; // 超级块的s_mounts链表上的挂载实例列表节点 const char *mnt_devname; // 设备名称，如 /dev/dsk/hda1 struct list_head mnt_list; // 全局挂载点列表的链表节点 struct list_head mnt_expire; // 特定文件系统的过期列表的链表节点 struct list_head mnt_share; // 共享挂载点的循环列表链表头 struct list_head mnt_slave_list; // 从属挂载点的链表头 struct list_head mnt_slave; // 与mnt_slave_list链表相连的链表节点 struct mount *mnt_master; // 指向主挂载点的指针，从属挂载点位于master-&gt;mnt_slave_list struct mnt_namespace *mnt_ns; // 包含此挂载点的命名空间 struct mountpoint *mnt_mp; // 指向挂载点位置的mountpoint结构体 union &#123; struct hlist_node mnt_mp_list; // 具有相同挂载点的挂载列表链表节点 struct hlist_node mnt_umount; // 用于卸载操作的链表节点 &#125;; struct list_head mnt_umounting; // 用于卸载传播的链表节点#ifdef CONFIG_FSNOTIFY struct fsnotify_mark_connector __rcu *mnt_fsnotify_marks; // 指向文件系统通知标记的指针 __u32 mnt_fsnotify_mask; // 文件系统通知的掩码#endif int mnt_id; // 挂载点的唯一标识符 int mnt_group_id; // 同级挂载组的唯一标识符 int mnt_expiry_mark; // 如果已标记为过期，则为true struct hlist_head mnt_pins; // 用于记录挂载点引脚的链表头 struct hlist_head mnt_stuck_children; // 被卡住的子挂载点列表的链表头&#125; __randomize_layout; // 使用内核的地址空间布局随机化（KASLR）特性，以增加安全性 struct dentrydentry identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132struct dentry &#123; /* RCU lookup touched fields */ unsigned int d_flags; /* 目录项的标志位，受 d_lock 保护 */ seqcount_spinlock_t d_seq; /* 每个目录项的序列锁 */ struct hlist_bl_node d_hash; /* 用于查找的哈希列表 */ struct dentry *d_parent; /* 父目录 */ struct qstr d_name; /* 目录项的名称 */ struct inode *d_inode; /* 与目录名关联的 inode 结构指针，NULL 表示负目录项 */ unsigned char d_iname[DNAME_INLINE_LEN]; /* 短名称 */ /* Ref lookup also touches following */ struct lockref d_lockref; /* 每个目录项的锁和引用计数 */ const struct dentry_operations *d_op; /* 目录项操作函数集 */ struct super_block *d_sb; /* 目录项树的根节点 */ unsigned long d_time; /* 用于 d_revalidate 的时间戳 */ void *d_fsdata; /* 特定文件系统的数据 */ union &#123; struct list_head d_lru; /* LRU（最近最少使用）列表 */ wait_queue_head_t *d_wait; /* 仅用于查找中的目录项 */ &#125;; struct list_head d_child; /* 父目录项的子项列表 */ struct list_head d_subdirs; /* 子目录项列表 */ /* * d_alias and d_rcu can share memory */ union &#123; struct hlist_node d_alias; /* inode 别名列表 */ struct hlist_bl_node d_in_lookup_hash; /* 仅用于查找中的目录项 */ struct rcu_head d_rcu; &#125; d_u;&#125; __randomize_layout; struct inodeinode identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102struct inode &#123; umode_t i_mode; /* 文件类型和访问权限 */ unsigned short i_opflags; /* inode 操作标志 */ kuid_t i_uid; /* 文件拥有者的用户 ID */ kgid_t i_gid; /* 文件拥有者的组 ID */ unsigned int i_flags; /* 文件或目录的标志 */#ifdef CONFIG_FS_POSIX_ACL struct posix_acl *i_acl; /* 访问控制列表 (ACL) */ struct posix_acl *i_default_acl; /* 默认访问控制列表 */#endif const struct inode_operations *i_op; /* inode 操作函数集 */ struct super_block *i_sb; /* 与 inode 关联的超级块 */ struct address_space *i_mapping; /* 文件内容的内存映射 */#ifdef CONFIG_SECURITY void *i_security; /* 安全模块使用的 inode 信息 */#endif /* Stat data, not accessed from path walking */ unsigned long i_ino; /* inode 编号 */ union &#123; const unsigned int i_nlink; /* 硬链接计数 */ unsigned int __i_nlink; &#125;; dev_t i_rdev; /* 特殊设备的设备号 */ loff_t i_size; /* 文件大小（字节） */ struct timespec64 i_atime; /* 最后访问时间 */ struct timespec64 i_mtime; /* 最后修改时间 */ struct timespec64 i_ctime; /* 最后元数据更改时间 */ spinlock_t i_lock; /* 保护 i_blocks, i_bytes 和可能的 i_size 的锁 */ unsigned short i_bytes; /* 文件末尾未使用的字节数 */ u8 i_blkbits; /* 文件系统块大小的以 2 为底的对数 */ u8 i_write_hint; /* 写操作的优化提示 */ blkcnt_t i_blocks; /* 文件占用的磁盘块数量 */#ifdef __NEED_I_SIZE_ORDERED seqcount_t i_size_seqcount; /* 有序 i_size 的序列计数器 */#endif /* Misc */ unsigned long i_state; /* inode 状态标志 */ struct rw_semaphore i_rwsem; /* 读写信号量，用于保护 inode 结构 */ unsigned long dirtied_when; /* 第一次被脏的时间，以 jiffies 计 */ unsigned long dirtied_time_when; /* 上次被脏的时间，以 jiffies 计 */ struct hlist_node i_hash; /* 散列链表上的节点 */ struct list_head i_io_list; /* 后备设备的 I/O 列表 */#ifdef CONFIG_CGROUP_WRITEBACK struct bdi_writeback *i_wb; /* 关联的 cgroup 写回控制器 */ int i_wb_frn_winner; /* 外部 inode 检测的赢家 */ u16 i_wb_frn_avg_time; /* 外部 inode 的平均时间 */ u16 i_wb_frn_history; /* 外部 inode 的历史记录 */#endif struct list_head i_lru; /* inode LRU 列表 */ struct list_head i_sb_list; /* 超级块列表 */ struct list_head i_wb_list; /* 后备设备写回列表 */ union &#123; struct hlist_head i_dentry; /* 目录项列表 */ struct rcu_head i_rcu; &#125;; atomic64_t i_version; /* inode 版本 */ atomic64_t i_sequence; /* 用于 futex 的序列值 */ atomic_t i_count; /* inode 引用计数 */ atomic_t i_dio_count; /* 直接 I/O 计数 */ atomic_t i_writecount; /* 写计数 */#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING) atomic_t i_readcount; /* 只读打开的文件计数 */#endif union &#123; const struct file_operations *i_fop; /* 以前的 -&gt;i_op-&gt;default_file_ops */ void (*free_inode)(struct inode *); &#125;; struct file_lock_context *i_flctx; /* 文件锁上下文 */ struct address_space i_data; /* inode 的数据缓冲区 */ struct list_head i_devices; /* 设备列表 */ union &#123; struct pipe_inode_info *i_pipe; /* 管道 inode 信息 */ struct cdev *i_cdev; /* 字符设备 */ char *i_link; /* 符号链接的目标路径 */ unsigned i_dir_seq; /* 目录序列计数器 */ &#125;; __u32 i_generation; /* inode 生成计数器 */#ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* inode 关心的所有事件 */ struct fsnotify_mark_connector __rcu *i_fsnotify_marks; /* 文件系统通知标记连接器 */#endif#ifdef CONFIG_FS_ENCRYPTION struct fscrypt_info *i_crypt_info; /* 文件系统加密信息 */#endif#ifdef CONFIG_FS_VERITY struct fsverity_info *i_verity_info; /* 文件系统完整性信息 */#endif void *i_private; /* 文件系统或设备的私有指针 */&#125; __randomize_layout; 打开或者创建新文件open系统调用sys_openat identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122// 定义一个名为 open 的系统调用，该调用接受三个参数：filename（文件名），flags（标志）和 mode（模式）SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)&#123; // 如果需要处理大文件，将 O_LARGEFILE 标志添加到 flags 中 if (force_o_largefile()) flags |= O_LARGEFILE; // 调用 do_sys_open 函数，传入当前工作目录的文件描述符 AT_FDCWD、filename、flags 和 mode 参数 return do_sys_open(AT_FDCWD, filename, flags, mode);&#125;// 定义一个名为 openat 的系统调用，该调用接受四个参数：dfd（目录文件描述符），filename（文件名），flags（标志）和 mode（模式）SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags, umode_t, mode)&#123; // 如果需要处理大文件，将 O_LARGEFILE 标志添加到 flags 中 if (force_o_largefile()) flags |= O_LARGEFILE; // 调用 do_sys_open 函数，传入 dfd（目录文件描述符）、filename、flags 和 mode 参数 return do_sys_open(dfd, filename, flags, mode);&#125; open - 这是一个较早版本的系统调用，它接受三个参数：filename，flags 和 mode。filename 参数是要打开或创建的文件名；flags 参数用于指定文件的打开方式，例如只读、只写或读写，以及其他一些选项，如创建新文件或截断文件；mode 参数用于指定新创建文件的权限。在处理大文件时，如果设置了 O_LARGEFILE 标志，open 会自动处理大文件。 openat - 与 open 类似，但多了一个参数 dfd（目录文件描述符）。这个系统调用支持从一个特定的目录开始解析相对路径。如果 dfd 是一个有效的目录文件描述符，那么 filename 参数将被解析为该目录下的相对路径。如果 dfd 是 AT_FDCWD，则 filename 会被视为当前工作目录下的相对路径。这个系统调用在处理多线程程序和文件系统命名空间时非常有用。 do_sys_open函数do_sys_open identifier - Linux source code (v6.3.7) - Bootlin 123456789// 定义一个名为 do_sys_open 的函数，该函数接受四个参数：dfd（目录文件描述符），filename（文件名），flags（标志）和 mode（模式）long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)&#123; // 使用 build_open_how 函数根据 flags 和 mode 参数构造一个 open_how 结构体 struct open_how how = build_open_how(flags, mode); // 调用 do_sys_openat2 函数，传入 dfd（目录文件描述符）、filename 和 how 结构体的指针 return do_sys_openat2(dfd, filename, &amp;how);&#125; do_sys_openat2函数do_sys_openat2 identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142// 定义一个名为 do_sys_openat2 的静态函数，该函数接受三个参数：dfd（目录文件描述符），filename（文件名）和 how（打开方式结构体指针）static long do_sys_openat2(int dfd, const char __user *filename, struct open_how *how)&#123; struct open_flags op; // 使用 build_open_flags 函数根据 how 结构体构造一个 open_flags 结构体，将结果存储在 op 变量中 int fd = build_open_flags(how, &amp;op); struct filename *tmp; // 如果 fd 不为 0（表示出错），则返回 fd if (fd) return fd; // 使用 getname 函数获取 filename 参数的内核空间副本，并将其存储在 tmp 变量中 tmp = getname(filename); // 如果获取文件名出错，返回错误码 if (IS_ERR(tmp)) return PTR_ERR(tmp); // 根据 how-&gt;flags 获取未使用的文件描述符（fd），并将其存储在 fd 变量中 fd = get_unused_fd_flags(how-&gt;flags); // 如果 fd 大于等于 0（表示未使用的文件描述符可用） if (fd &gt;= 0) &#123; // 使用 do_filp_open 函数打开文件，传入 dfd（目录文件描述符）、tmp（文件名）和 op（打开方式）参数 struct file *f = do_filp_open(dfd, tmp, &amp;op); // 如果打开文件出错，释放未使用的文件描述符并返回错误码 if (IS_ERR(f)) &#123; put_unused_fd(fd); fd = PTR_ERR(f); &#125; else &#123; // 如果打开文件成功，调用 fsnotify_open 函数通知相关子系统 fsnotify_open(f); // 调用 fd_install 函数将文件描述符 fd 与打开的文件结构体 f 关联起来 fd_install(fd, f); &#125; &#125; // 释放 tmp 变量（即 filename 的内核空间副本） putname(tmp); // 返回文件描述符 fd return fd;&#125; do_filp_open函数do_filp_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324// 定义一个名为 do_filp_open 的函数，该函数接受三个参数：dfd（目录文件描述符），pathname（文件名结构体指针）和 op（打开方式结构体指针）struct file *do_filp_open(int dfd, struct filename *pathname, const struct open_flags *op)&#123; struct nameidata nd; // 从 op 结构体中获取查找标志 int flags = op-&gt;lookup_flags; struct file *filp; // 使用 set_nameidata 函数初始化 nd 结构体，传入 dfd（目录文件描述符）、pathname（文件名结构体指针）和 NULL（用于初始化 nd-&gt;intent） set_nameidata(&amp;nd, dfd, pathname, NULL); // 使用 path_openat 函数尝试打开文件，传入 nd（名字数据结构体）、op（打开方式结构体）和 flags（查找标志）；使用 LOOKUP_RCU 标志进行 RCU 优化 filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); // 如果文件打开失败并返回 -ECHILD 错误码，表明 RCU 优化失败，尝试使用非 RCU 优化方式打开文件 if (unlikely(filp == ERR_PTR(-ECHILD))) filp = path_openat(&amp;nd, op, flags); // 如果文件打开失败并返回 -ESTALE 错误码，表明文件系统状态陈旧，尝试使用 LOOKUP_REVAL 标志重新评估文件系统状态并打开文件 if (unlikely(filp == ERR_PTR(-ESTALE))) filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); // 通过调用 restore_nameidata 函数恢复名字数据结构体（nd）的状态 restore_nameidata(); // 返回文件结构体指针 filp return filp;&#125; 12345678910static inline void set_nameidata(struct nameidata *p, int dfd, struct filename *name, const struct path *root)&#123; __set_nameidata(p, dfd, name); p-&gt;state = 0; if (unlikely(root)) &#123; p-&gt;state = ND_ROOT_PRESET; p-&gt;root = *root; &#125;&#125; 12345678910111213static void __set_nameidata(struct nameidata *p, int dfd, struct filename *name)&#123; struct nameidata *old = current-&gt;nameidata; p-&gt;stack = p-&gt;internal; p-&gt;depth = 0; p-&gt;dfd = dfd; p-&gt;name = name; p-&gt;path.mnt = NULL; p-&gt;path.dentry = NULL; p-&gt;total_link_count = old ? old-&gt;total_link_count : 0; p-&gt;saved = old; current-&gt;nameidata = p;&#125; path_openat函数path_openat identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义一个名为 path_openat 的静态函数，该函数接受三个参数：nd（名字数据结构体指针）、op（打开方式结构体指针）和 flags（打开标志）static struct file *path_openat(struct nameidata *nd, const struct open_flags *op, unsigned flags)&#123; struct file *file; int error; // 使用 alloc_empty_file 函数分配一个空的文件结构体，传入打开标志和当前进程的认证信息 file = alloc_empty_file(op-&gt;open_flag, current_cred()); // 如果分配文件结构体失败，返回错误指针 if (IS_ERR(file)) return file; // 如果文件打开标志包含 __O_TMPFILE，调用 do_tmpfile 函数处理临时文件的打开操作 if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123; error = do_tmpfile(nd, flags, op, file); // 如果文件打开标志包含 O_PATH，调用 do_o_path 函数处理 O_PATH 标志的打开操作 &#125; else if (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123; error = do_o_path(nd, flags, file); // 否则，正常处理文件打开操作 &#125; else &#123; // 使用 path_init 函数初始化 nd 结构体，并返回路径名字符串 s const char *s = path_init(nd, flags); // 循环调用 link_path_walk 和 open_last_lookups 函数，直到路径名解析完成 while (!(error = link_path_walk(s, nd)) &amp;&amp; (s = open_last_lookups(nd, file, op)) != NULL) ; // 路径名解析完成后，调用 do_open 函数处理文件打开操作 if (!error) error = do_open(nd, file, op); // 调用 terminate_walk 函数终止路径名解析操作 terminate_walk(nd); &#125; // 如果没有错误发生，返回文件结构体指针 if (likely(!error)) &#123; if (likely(file-&gt;f_mode &amp; FMODE_OPENED)) return file; WARN_ON(1); error = -EINVAL; &#125; // 如果有错误发生，释放文件结构体并返回错误指针 fput(file); // 如果错误码为 -EOPENSTALE，根据 flags 参数设置错误码为 -ECHILD 或 -ESTALE if (error == -EOPENSTALE) &#123; if (flags &amp; LOOKUP_RCU) error = -ECHILD; else error = -ESTALE; &#125; return ERR_PTR(error);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* 必须和 terminate_walk() 配对使用 */static const char *path_init(struct nameidata *nd, unsigned flags)&#123; int error; const char *s = nd-&gt;name-&gt;name; /* LOOKUP_CACHED 需要 RCU，要求调用者重试 */ if ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED) return ERR_PTR(-EAGAIN); if (!*s) flags &amp;= ~LOOKUP_RCU; if (flags &amp; LOOKUP_RCU) rcu_read_lock(); // 如果使用 RCU，则加锁 else nd-&gt;seq = nd-&gt;next_seq = 0; // 否则，将序列号设置为 0 nd-&gt;flags = flags; // 设置 nameidata 结构体的 flags nd-&gt;state |= ND_JUMPED; // 设置 nameidata 结构体的状态 // 读取 mount_lock 和 rename_lock 的序列号 nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount); nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount); smp_rmb(); // 检查是否预先设置了根路径 if (nd-&gt;state &amp; ND_ROOT_PRESET) &#123; struct dentry *root = nd-&gt;root.dentry; struct inode *inode = root-&gt;d_inode; if (*s &amp;&amp; unlikely(!d_can_lookup(root))) return ERR_PTR(-ENOTDIR); nd-&gt;path = nd-&gt;root; // 将预设的根路径设置为当前路径 nd-&gt;inode = inode; // 设置路径的 inode if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;path); &#125; return s; &#125; nd-&gt;root.mnt = NULL; // 绝对路径 - 获取根路径（LOOKUP_IN_ROOT 使用 nd-&gt;dfd） if (*s == &#x27;/&#x27; &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123; error = nd_jump_root(nd); // 从根路径开始查找 if (unlikely(error)) return ERR_PTR(error); return s; &#125; // 相对路径 - 获取相对路径的起始点 if (nd-&gt;dfd == AT_FDCWD) &#123; if (flags &amp; LOOKUP_RCU) &#123; struct fs_struct *fs = current-&gt;fs; unsigned seq; // 根据 fs_struct 获取 pwd（当前工作目录） do &#123; seq = read_seqcount_begin(&amp;fs-&gt;seq); nd-&gt;path = fs-&gt;pwd; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; while (read_seqcount_retry(&amp;fs-&gt;seq, seq)); &#125; else &#123; get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path); // 获取当前进程的工作目录 nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; &#125; else &#123; // 调用者必须检查起始路径组件的执行权限 struct fd f = fdget_raw(nd-&gt;dfd); // 根据文件描述符获取 fd 结构 struct dentry *dentry; if (!f.file) return ERR_PTR(-EBADF); dentry = f.file-&gt;f_path.dentry; if (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123; fdput(f); return ERR_PTR(-ENOTDIR); &#125; nd-&gt;path = f.file-&gt;f_path; // 设置当前路径 if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq); &#125; else &#123; path_get(&amp;nd-&gt;path); nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode; &#125; fdput(f); // 释放文件描述符 &#125; // 对于受限制的查找，我们需要将 dirfd 也设置为根路径 if (flags &amp; LOOKUP_IS_SCOPED) &#123; nd-&gt;root = nd-&gt;path; if (flags &amp; LOOKUP_RCU) &#123; nd-&gt;root_seq = nd-&gt;seq; &#125; else &#123; path_get(&amp;nd-&gt;root); nd-&gt;state |= ND_ROOT_GRABBED; &#125; &#125; return s;&#125; link_path_walk函数link_path_walk identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static int link_path_walk(const char *name, struct nameidata *nd)&#123; int depth = 0; // 初始化深度为 0，用于记录符号链接的嵌套层数 int err; // 初始化 nd-&gt;last_type 和 nd-&gt;flags nd-&gt;last_type = LAST_ROOT; // 设置 nd-&gt;last_type 为 LAST_ROOT nd-&gt;flags |= LOOKUP_PARENT; // 更新 nd-&gt;flags，添加 LOOKUP_PARENT 标志 // 如果路径名是错误的，返回错误值 if (IS_ERR(name)) // 检查路径名是否有效（不是错误指针） return PTR_ERR(name); // 如果无效，返回错误值 // 跳过路径名开头的 &#x27;/&#x27; while (*name == &#x27;/&#x27;) // 当路径名以 &#x27;/&#x27; 开头时，进入循环 name++; // 将 name 指针向后移动一位，跳过 &#x27;/&#x27; // 如果路径名为空，返回 0 if (!*name) &#123; // 检查路径名是否为空（在跳过开头的 &#x27;/&#x27; 之后） nd-&gt;dir_mode = 0; // 将 nd-&gt;dir_mode 设置为 0 return 0; // 返回 0，表示路径查找结束 &#125; // 开始循环处理路径名的每个组件 for (;;) &#123; // 无限循环，直到路径名的所有组件都被处理 struct mnt_idmap *idmap; const char *link; u64 hash_len; int type; // 获取文件系统 ID 映射,文件系统 ID 映射用于将 VFS 中的用户和组 ID 转换为底层文件系统中的用户和组 ID。 idmap = mnt_idmap(nd-&gt;path.mnt); // 获取 nd-&gt;path.mnt 对应的文件系统 ID 映射 // 检查是否有权限执行查找操作 err = may_lookup(idmap, nd); // 检查当前用户是否有权限查找 if (err) // 如果没有权限 return err; // 返回错误值 // 计算当前路径组件的哈希值和长度,这些值将用于在散列查找中快速比较路径名组件。 hash_len = hash_name(nd-&gt;path.dentry, name); // 计算哈希值和长度 // 判断当前路径组件的类型（&#x27;.&#x27;、&#x27;..&#x27; 或普通组件） type = LAST_NORM; // 默认为普通组件 if (name[0] == &#x27;.&#x27;) switch (hashlen_len(hash_len)) &#123; // 如果组件以 &#x27;.&#x27; 开头，检查长度 case 2: if (name[1] == &#x27;.&#x27;) &#123; // 如果组件为 &quot;..&quot; type = LAST_DOTDOT; // 设置类型为 LAST_DOTDOT nd-&gt;state |= ND_JUMPED; // 更新 nd-&gt;state，添。这个标志表示我们正跳转到父目录。 &#125; break; case 1: type = LAST_DOT; // 如果组件为 &quot;.&quot;，设置类型为 LAST_DOT &#125; if (likely(type == LAST_NORM)) &#123; // 如果组件类型为普通组件 struct dentry *parent = nd-&gt;path.dentry; // 获取当前组件的父目录 nd-&gt;state &amp;= ~ND_JUMPED; // 清除 nd-&gt;state 的 ND_JUMPED 标志 // 如果需要，执行自定义哈希操作。某些文件系统可能需要自定义哈希操作以适应其特定的查找机制。 if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; // 检查父目录是否需要自定义哈希操作 struct qstr this = &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; // 初始化 qstr 结构体 err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); // 执行自定义哈希操作 if (err &lt; 0) // 如果操作失败 return err; // 返回错误值 hash_len = this.hash_len; // 更新哈希值和长度 name = this.name; // 更新 name 指针 &#125; &#125; //--------------------------------------------------------------------- // 更新 nd 的 last 和 last_type 成员 nd-&gt;last.hash_len = hash_len; // 设置 nd-&gt;last 的哈希值和长度 nd-&gt;last.name = name; // 设置 nd-&gt;last 的名称 nd-&gt;last_type = type; // 设置 nd-&gt;last_type 为当前组件的类型 // 将 name 指针向后移动到下一个路径组件 name += hashlen_len(hash_len); // 将 name 指针向后移动到下一个路径组件的起始位置 // 如果到达路径名的结尾，处理结束 if (!*name) // 检查是否到达路径名的结尾 goto OK; // 跳转到 OK 标签 // 跳过连续的 &#x27;/&#x27; do &#123; name++; // 将 name 指针向后移动一位 &#125; while (unlikely(*name == &#x27;/&#x27;)); // 当遇到 &#x27;/&#x27; 时，继续循环 // 如果到达路径名的结尾，处理结束 if (unlikely(!*name)) &#123; // 再次检查是否到达路径名的结尾OK: // pathname or trailing symlink, done if (!depth) &#123; // 如果当前处理的路径组件不是符号链接的一部分 nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); // 设置 nd-&gt;dir_vfsuid nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; // 设置 nd-&gt;dir_mode nd-&gt;flags &amp;= ~LOOKUP_PARENT; // 清除 nd-&gt;flags 的 LOOKUP_PARENT 标志 return 0; // 返回 0，表示路径查找结束 &#125; // last component of nested symlink name = nd-&gt;stack[--depth].name; // 获取符号链接栈中下一个组件的名称 link = walk_component(nd, 0); // 处理当前组件 &#125; else &#123; // not the last component link = walk_component(nd, WALK_MORE); // 处理当前组件，传递 WALK_MORE 标志 &#125; // 如果 link 不为空，表示需要处理符号链接 if (unlikely(link)) &#123; // 检查 link 是否为空 if (IS_ERR(link)) // 如果 link 是错误指针 return PTR_ERR(link); // 返回错误值 // a symlink to follow nd-&gt;stack[depth++].name = name; // 将当前组件的名称压入符号链接栈 name = link; // 将 name 指针设置为符号链接的目标路径 continue; // 继续循环处理符号链接的目标路径 &#125; // 检查 dentry 是否可以执行查找操作 if (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; // 如果不能执行查找操作 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果 nd-&gt;flags 中包含 LOOKUP_RCU 标志 if (!try_to_unlazy(nd)) // 尝试取消对 nd 的懒加载 return -ECHILD; // 如果取消失败，返回 -ECHILD 错误值 &#125; return -ENOTDIR; // 返回 -ENOTDIR 错误值，表示不是目录 &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/* * 计算路径组件的长度和哈希值， * 并将 &quot;hash_len&quot; 作为结果返回。 */static inline u64 hash_name(const void *salt, const char *name)&#123; unsigned long a = 0, b, x = 0, y = (unsigned long)salt; unsigned long adata, bdata, mask, len; const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS; // 初始化长度为 0 len = 0; goto inside; do &#123; // 对 a, x, y 进行哈希混合 HASH_MIX(x, y, a); // 更新名称长度 len += sizeof(unsigned long);inside: // 在给定偏移量的名称字符串中加载一个未对齐的值 a = load_unaligned_zeropad(name+len); // 通过 XOR 操作找到与斜线字符不同的部分,循环找到 b = a ^ REPEAT_BYTE(&#x27;/&#x27;); // 检查 a 和 b 中是否有零字节 &#125; while (!(has_zero(a, &amp;adata, &amp;constants) | has_zero(b, &amp;bdata, &amp;constants))); // 为 a 和 b 准备零掩码 adata = prep_zero_mask(a, adata, &amp;constants); bdata = prep_zero_mask(b, bdata, &amp;constants); // 通过组合 a 和 b 的零掩码创建最终的零掩码 mask = create_zero_mask(adata | bdata); // 将 a 的零掩码应用于 x x ^= a &amp; zero_bytemask(mask); // 根据 x, y 和零掩码创建最终的哈希长度值 return hashlen_create(fold_hash(x, y), len + find_zero(mask));&#125; walk_component函数walk_component identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536// 定义一个名为 walk_component 的函数，参数包括一个指向 nameidata 结构体的指针和一个整数 flagsstatic const char *walk_component(struct nameidata *nd, int flags)&#123; // 定义一个指向 dentry 结构体的指针 struct dentry *dentry; /* * &quot;.&quot; 和 &quot;..&quot; 是特殊的 - 尤其是 &quot;..&quot;，因为它必须知道当前根目录和 * 父目录之间的关系。 */ // 如果 nd-&gt;last_type 不是 LAST_NORM，则执行以下代码 if (unlikely(nd-&gt;last_type != LAST_NORM)) &#123; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 handle_dots 函数处理 &quot;.&quot; 和 &quot;..&quot; return handle_dots(nd, nd-&gt;last_type); &#125; // 调用 lookup_fast 函数进行快速查找 dentry = lookup_fast(nd); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果 dentry 为 NULL，则执行以下代码 if (unlikely(!dentry)) &#123; // 调用 lookup_slow 函数进行慢速查找 dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags); // 如果 dentry 是一个错误指针，则返回错误指针 if (IS_ERR(dentry)) return ERR_CAST(dentry); &#125; // 如果 flags 没有设置 WALK_MORE 且 nd-&gt;depth 不为 0，则调用 put_link 函数 if (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth) put_link(nd); // 调用 step_into 函数进入下一个组件（目录或文件） return step_into(nd, flags, dentry);&#125; 1234567static inline void put_link(struct nameidata *nd)&#123; struct saved *last = nd-&gt;stack + --nd-&gt;depth; do_delayed_call(&amp;last-&gt;done); if (!(nd-&gt;flags &amp; LOOKUP_RCU)) path_put(&amp;last-&gt;link);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义一个函数handle_dots，用于处理路径名中的点（.）和点点（..）static const char *handle_dots(struct nameidata *nd, int type) &#123; // 如果当前路径组件是两个点（..） if (type == LAST_DOTDOT) &#123; // 定义错误指针并初始化为NULL const char *error = NULL; // 定义一个dentry结构的父目录指针 struct dentry *parent; // 如果nd（nameidata结构）的root成员为空 if (!nd-&gt;root.mnt) &#123; // 调用set_root函数设置nd的根目录，并检查是否出现错误 error = ERR_PTR(set_root(nd)); if (error) return error; &#125; // 如果nd的flags中包含LOOKUP_RCU标志 if (nd-&gt;flags &amp; LOOKUP_RCU) // 调用follow_dotdot_rcu函数，以RCU方式处理两个点（..） parent = follow_dotdot_rcu(nd); else // 否则，调用follow_dotdot函数处理两个点（..） parent = follow_dotdot(nd); // 如果parent是一个错误指针，返回错误 if (IS_ERR(parent)) return ERR_CAST(parent); // 调用step_into函数进入parent目录，不跟随符号链接 error = step_into(nd, WALK_NOFOLLOW, parent); // 如果出现错误，返回错误 if (unlikely(error)) return error; // 如果nd的flags中包含LOOKUP_IS_SCOPED标志 if (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123; /* * 如果我们的路径在进行重命名或挂载操作期间发生竞争， * 那么我们无法确定&quot;..&quot;是否跳过了nd-&gt;root（因此用户空间应该重试或使用一些回退方法）。 */ // 读取内存屏障，确保正确的内存顺序 smp_rmb(); // 如果mount_lock的序列计数器发生变化，返回错误EAGAIN if (__read_seqcount_retry(&amp;mount_lock.seqcount, nd-&gt;m_seq)) return ERR_PTR(-EAGAIN); // 如果rename_lock的序列计数器发生变化，返回错误EAGAIN if (__read_seqcount_retry(&amp;rename_lock.seqcount, nd-&gt;r_seq)) return ERR_PTR(-EAGAIN); &#125; &#125; // 如果不是两个点（..），返回NULL return NULL;&#125; lookup_fast函数lookup_fast identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct dentry *lookup_fast(struct nameidata *nd)&#123; struct dentry *dentry, *parent = nd-&gt;path.dentry; // 定义dentry指针，将nd中的path的dentry赋值给parent int status = 1; /* * Rename seqlock is not required here because in the off chance * of a false negative due to a concurrent rename, the caller is * going to fall back to non-racy lookup. */ if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; // 如果使用RCU（读-拷贝-更新）查找 dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); // 用RCU方式查找目录项 if (unlikely(!dentry)) &#123; // 如果没有找到dentry if (!try_to_unlazy(nd)) // 尝试将rcu锁升级为非rcu锁 return ERR_PTR(-ECHILD); // 返回错误 return NULL; // 返回空指针 &#125; /* * This sequence count validates that the parent had no * changes while we did the lookup of the dentry above. */ if (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq)) // 验证在查找dentry过程中parent没有发生变化 return ERR_PTR(-ECHILD); // 返回错误 status = d_revalidate(dentry, nd-&gt;flags); // 验证dentry的有效性 if (likely(status &gt; 0)) // 如果验证成功 return dentry; // 返回dentry if (!try_to_unlazy_next(nd, dentry)) // 尝试将rcu锁升级为非rcu锁 return ERR_PTR(-ECHILD); // 返回错误 if (status == -ECHILD) /* we&#x27;d been told to redo it in non-rcu mode */ status = d_revalidate(dentry, nd-&gt;flags); // 在非RCU模式下重新验证dentry的有效性 &#125; else &#123; // 如果使用非RCU查找 dentry = __d_lookup(parent, &amp;nd-&gt;last); // 查找目录项 if (unlikely(!dentry)) // 如果没有找到dentry return NULL; // 返回空指针 status = d_revalidate(dentry, nd-&gt;flags); // 验证dentry的有效性 &#125; if (unlikely(status &lt;= 0)) &#123; // 如果验证失败 if (!status) // 如果status为0 d_invalidate(dentry); // 使dentry无效 dput(dentry); // 释放dentry引用 return ERR_PTR(status); // 返回错误 &#125; return dentry; // 返回dentry&#125; Linux 为了提高目录项对象的处理效率，设计与实现了目录项高速缓存 dentry cache，简称 dcache，在上节中已有详细描述。lookup_fast()会在dcache中去试图找到该对应的dentry，实际最终会调用https://code.woboq.org/linux/linux/include/linux/rculist_bl.h.html#123轮询列表进行查找。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * __d_lookup - 搜索一个 dentry (容易出现竞争) * @parent: 父 dentry * @name: 我们希望找到的名字的 qstr * 返回: dentry，或者 NULL * * __d_lookup 类似于 d_lookup，但是由于与重命名无关的活动，它可能（很少）返回 * 一个错误的负面结果。 * * __d_lookup 通过避免读取 rename_lock seqlock，速度稍快， * 但必须谨慎使用，例如在失败时使用后续的 d_lookup。 * * __d_lookup 调用者必须加注释。 */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; // 计算 name 的哈希值 struct hlist_bl_head *b = d_hash(hash); // 获取哈希值对应的哈希表头 struct hlist_bl_node *node; // 用于遍历哈希链表的节点 struct dentry *found = NULL; // 用于存储找到的 dentry struct dentry *dentry; // 用于遍历哈希链表的临时 dentry /* * 注意：这里与 __d_lookup_rcu 有很大的重复部分，这是为了防止单线程性能 * 回归，特别是在 smp_rmb（在 seqcounts 中）代价高昂的架构上。 * 保持这两个函数同步更新。 */ /* * 哈希列表使用 RCU 保护。 * * 在比较候选 dentry 时，获取 d_lock 以避免与 d_move() 的竞争。 * * 有可能并发的重命名操作会破坏我们这里的列表遍历，导致我们错过 dentry， * 从而产生错误的负面结果。d_lookup() 使用 rename_lock seqlock 来保护 * 并发重命名。 * * 更多细节请参阅 Documentation/filesystems/path-lookup.txt。 */ rcu_read_lock(); // 获取 RCU 读锁 // 遍历哈希链表 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) // 哈希值不匹配，继续下一个 continue; spin_lock(&amp;dentry-&gt;d_lock); // 获取 dentry 的自旋锁 if (dentry-&gt;d_parent != parent) // 父 dentry 不匹配，跳到下一个 goto next; if (d_unhashed(dentry)) // 检查 dentry 是否已从哈希表中移除，如果是则跳到下一个 goto next; if (!d_same_name(dentry, parent, name)) // 名字不匹配，跳到下一个 goto next; dentry-&gt;d_lockref.count++; // 增加 dentry 的引用计数 found = dentry; // 找到匹配的 dentry，赋值给 found spin_unlock(&amp;dentry-&gt;d_lock); // 释放 dentry 的自旋锁 break; // 结束循环 next: spin_unlock(&amp;dentry-&gt;d_lock); // 释放 dentry 的自旋锁 &#125; rcu_read_unlock(); // 释放 RCU 读锁 return found; // 返回找到的 dentry，如果没有找到返回 NULL&#125; __d_lookup_rcu函数__d_lookup_rcu identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869struct dentry *__d_lookup_rcu(const struct dentry *parent, const struct qstr *name, unsigned *seqp)&#123; u64 hashlen = name-&gt;hash_len; // 计算名称的哈希长度 const unsigned char *str = name-&gt;name; // 获取名称字符串 struct hlist_bl_head *b = d_hash(hashlen_hash(hashlen)); // 计算哈希值并获取散列表头 struct hlist_bl_node *node; // 定义哈希表节点指针 struct dentry *dentry; // 定义目录项指针 /* * Note: There is significant duplication with __d_lookup_rcu which is * required to prevent single threaded performance regressions * especially on architectures where smp_rmb (in seqcounts) are costly. * Keep the two functions in sync. */ // 检查父目录项是否包含自定义比较函数，如果有则调用特定的查找函数 if (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE)) return __d_lookup_rcu_op_compare(parent, name, seqp); /* * The hash list is protected using RCU. * * Carefully use d_seq when comparing a candidate dentry, to avoid * races with d_move(). * * It is possible that concurrent renames can mess up our list * walk here and result in missing our dentry, resulting in the * false-negative result. d_lookup() protects against concurrent * renames using rename_lock seqlock. * * See Documentation/filesystems/path-lookup.txt for more details. */ // 使用 RCU 保护的哈希列表来遍历目录项 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; unsigned seq; /* * The dentry sequence count protects us from concurrent * renames, and thus protects parent and name fields. * * The caller must perform a seqcount check in order * to do anything useful with the returned dentry. * * NOTE! We do a &quot;raw&quot; seqcount_begin here. That means that * we don&#x27;t wait for the sequence count to stabilize if it * is in the middle of a sequence change. If we do the slow * dentry compare, we will do seqretries until it is stable, * and if we end up with a successful lookup, we actually * want to exit RCU lookup anyway. * * Note that raw_seqcount_begin still *does* smp_rmb(), so * we are still guaranteed NUL-termination of -&gt;d_name.name. */ seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); // 获取 dentry 的序列计数 if (dentry-&gt;d_parent != parent) // 检查 dentry 的父目录项是否与给定的父目录项相同 continue; if (d_unhashed(dentry)) // 检查 dentry 是否已从散列表中删除 continue; if (dentry-&gt;d_name.hash_len != hashlen) // 检查 dentry 的名称哈希长度是否与给定名称相同 continue; if (dentry_cmp(dentry, str, hashlen_len(hashlen)) != 0) // 比较 dentry 的名称与给定名称是否相同 continue; *seqp = seq; // 将序列计数赋值给 seqp return dentry; // 返回找到的 dentry &#125; return NULL; // 如果没有找到匹配的 dentry，则返回空指针&#125; __d_lookup_rcu 函数在给定的父目录项下查找具有给定名称的目录项（dentry）。它使用 RCU（读-拷贝-更新）机制遍历散列表，以便在遍历过程中保护数据结构。如果找到匹配的目录项，它将返回指向该目录项的指针，否则返回 NULL。 hlist_bl_for_each_entry_rcu1234567891011121314151617/** * hlist_bl_for_each_entry_rcu - iterate over rcu list of given type * @tpos: the type * to use as a loop cursor. * @pos: the &amp;struct hlist_bl_node to use as a loop cursor. * @head: the head for your list. * @member: the name of the hlist_bl_node within the struct. * */#define hlist_bl_for_each_entry_rcu(tpos, pos, head, member) \\ // 初始化 pos 为列表头的第一个元素 for (pos = hlist_bl_first_rcu(head); \\ // 当 pos 不为 NULL 时执行循环体内的代码 pos &amp;&amp; \\ // 使用宏 hlist_bl_entry 获取当前 pos 对应的结构体类型的指针，并赋值给 tpos (&#123; tpos = hlist_bl_entry(pos, typeof(*tpos), member); 1; &#125;); \\ // 更新 pos 为下一个元素，使用 rcu_dereference_raw 进行 RCU 解引用 pos = rcu_dereference_raw(pos-&gt;next)) 这个宏定义了一个 for 循环，用于遍历链表中的每个元素。在循环体内，它使用 hlist_bl_entry 宏获取当前 pos 对应的结构体类型的指针，并将其赋值给 tpos。循环将持续进行，直到遍历完链表。在每次迭代时，它都会使用 rcu_dereference_raw 函数对 pos-&gt;next 进行 RCU 解引用以获取下一个元素。 lookup_slowlookup_slow identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819static struct dentry *lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct inode *inode = dir-&gt;d_inode; // 获取给定目录项（dir）对应的 inode struct dentry *res; // 定义一个目录项指针，用于存储查找结果 // 对 inode 上的共享锁进行加锁，以保护查找过程中的数据结构 inode_lock_shared(inode); // 调用 __lookup_slow 函数在给定目录项（dir）下查找与给定名称（name）匹配的目录项 res = __lookup_slow(name, dir, flags); // 对 inode 上的共享锁进行解锁 inode_unlock_shared(inode); // 返回查找到的目录项（dentry），如果没有找到匹配的项，返回 NULL return res;&#125; __lookup_slow函数__lookup_slow identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Fast lookup failed, do it the slow way */static struct dentry *__lookup_slow(const struct qstr *name, struct dentry *dir, unsigned int flags)&#123; struct dentry *dentry, *old; struct inode *inode = dir-&gt;d_inode; // 获取给定目录项（dir）对应的 inode DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // 定义一个等待队列头变量 // 如果 inode 已经是死亡状态，直接返回错误 if (unlikely(IS_DEADDIR(inode))) return ERR_PTR(-ENOENT);again: // 分配一个新的 dentry，如果需要等待，则使用 wq 等待 dentry = d_alloc_parallel(dir, name, &amp;wq); if (IS_ERR(dentry)) return dentry; // 如果 dentry 不处于查找状态 if (unlikely(!d_in_lookup(dentry))) &#123; // 重新验证 dentry int error = d_revalidate(dentry, flags); if (unlikely(error &lt;= 0)) &#123; // 如果验证失败，使 dentry 无效，释放 dentry，并重新尝试 if (!error) &#123; d_invalidate(dentry); dput(dentry); goto again; &#125; // 释放 dentry，并返回错误 dput(dentry); dentry = ERR_PTR(error); &#125; &#125; else &#123; // 调用文件系统特定的 lookup 函数查找 dentry old = inode-&gt;i_op-&gt;lookup(inode, dentry, flags); d_lookup_done(dentry); // 完成查找操作 if (unlikely(old)) &#123; // 如果找到旧的 dentry，释放新分配的 dentry，并使用旧的 dentry dput(dentry); dentry = old; &#125; &#125; // 返回查找到的 dentry 或新创建的 dentry return dentry;&#125; __lookup_slow 函数在给定的目录项（dir）下查找具有给定名称（name）的目录项（dentry）。此函数在快速查找失败的情况下使用慢速查找方法。首先，它获取给定目录项（dir）对应的 inode，然后分配一个新的 dentry。接着检查 dentry 是否处于查找状态，如果不是，则重新验证 dentry。如果验证失败，则使 dentry 无效并释放它，然后重新尝试。如果 dentry 处于查找状态，则调用文件系统特定的 lookup 函数查找 dentry。完成查找后，如果找到旧的 dentry，则释放新分配的 dentry 并使用旧的 dentry。最后，返回找到的或新创建的 dentry。 当查找成功时，__lookup_slow 函数返回找到的 dentry。如果没有找到匹配的目录项，inode-&gt;i_op-&gt;lookup 函数将创建一个新的目录项并返回它。创建新目录项的过程依赖于具体的文件系统实现，通常涉及分配一个新的 dentry 结构，并将其与给定的 name 和父目录项关联起来。 inode-&gt;i_op-&gt;lookup函数指向 simple_lookup() 函数首先我们参考上文中的get_tree函数是如何被设置为shmem_init函数 可以了解到内核在启动时会初始化tmpfs文件系统 我们根据调用链shmem_get_tree - shmem_fill_super - shmem_get_inode，然后查看shmem_get_inode函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static struct inode *shmem_get_inode(struct mnt_idmap *idmap, struct super_block *sb, struct inode *dir, umode_t mode, dev_t dev, unsigned long flags)&#123; struct inode *inode; struct shmem_inode_info *info; struct shmem_sb_info *sbinfo = SHMEM_SB(sb); ino_t ino; // 为新的inode预留一个系统内部的编号 if (shmem_reserve_inode(sb, &amp;ino)) return NULL; // 为新的inode分配内存 inode = new_inode(sb); if (inode) &#123; // 设置inode的编号 inode-&gt;i_ino = ino; // 初始化inode的所有者和权限模式 inode_init_owner(idmap, inode, dir, mode); // 设置inode的磁盘块数为0 inode-&gt;i_blocks = 0; // 设置inode的访问、修改和创建时间 inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode); // 设置inode的生成编号（用于NFS） inode-&gt;i_generation = get_random_u32(); // 获得shmem_inode_info结构（tmpfs专用） info = SHMEM_I(inode); // 初始化shmem_inode_info结构 memset(info, 0, (char *)inode - (char *)info); spin_lock_init(&amp;info-&gt;lock); atomic_set(&amp;info-&gt;stop_eviction, 0); info-&gt;seals = F_SEAL_SEAL; info-&gt;flags = flags &amp; VM_NORESERVE; info-&gt;i_crtime = inode-&gt;i_mtime; info-&gt;fsflags = (dir == NULL) ? 0 : SHMEM_I(dir)-&gt;fsflags &amp; SHMEM_FL_INHERITED; if (info-&gt;fsflags) shmem_set_inode_flags(inode, info-&gt;fsflags); INIT_LIST_HEAD(&amp;info-&gt;shrinklist); INIT_LIST_HEAD(&amp;info-&gt;swaplist); simple_xattrs_init(&amp;info-&gt;xattrs); cache_no_acl(inode); mapping_set_large_folios(inode-&gt;i_mapping); // 根据不同的文件类型，设置相应的操作函数 switch (mode &amp; S_IFMT) &#123; default: inode-&gt;i_op = &amp;shmem_special_inode_operations; init_special_inode(inode, mode, dev); break; case S_IFREG: inode-&gt;i_mapping-&gt;a_ops = &amp;shmem_aops; inode-&gt;i_op = &amp;shmem_inode_operations; inode-&gt;i_fop = &amp;shmem_file_operations; mpol_shared_policy_init(&amp;info-&gt;policy, shmem_get_sbmpol(sbinfo)); break; case S_IFDIR: inc_nlink(inode); inode-&gt;i_size = 2 * BOGO_DIRENT_SIZE; inode-&gt;i_op = &amp;shmem_dir_inode_operations; inode-&gt;i_fop = &amp;simple_dir_operations; break; case S_IFLNK: mpol_shared_policy_init(&amp;info-&gt;policy, NULL); break; &#125; // 为锁依赖分析系统设置inode互斥锁的标记 lockdep_annotate_inode_mutex_key(inode); &#125; else // 如果inode分配失败，则释放预留的编号 shmem_free_inode(sb); return inode;&#125; 设置文件类型为目录类型 所以inode-&gt;i_op = &amp;shmem_dir_inode_operations; 查看这个变量的定义 shmem_dir_inode_operations identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create, .lookup = simple_lookup,//这里定义了lookup函数 .link = shmem_link, .unlink = shmem_unlink, .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;; lookup函数被设置为了simple_lookup simple_lookup identifier - Linux source code (v6.3.6) - Bootlin 1234567891011121314151617181920212223242526272829/* * 查找数据。这很简单 - 如果 dentry 不存在， * 我们知道它是负的。设置 d_op 以删除负 dentries。 */// 定义 simple_lookup 函数，它接受一个指向 inode 的指针，// 一个指向 dentry 的指针，以及一个无符号整数作为标志作为参数。struct dentry *simple_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)&#123; // 检查 dentry 名称的长度是否大于允许的最大值（NAME_MAX）。 // 如果是，则返回带有 -ENAMETOOLONG 的错误指针。 if (dentry-&gt;d_name.len &gt; NAME_MAX) return ERR_PTR(-ENAMETOOLONG); // 如果 dentry 的超级块 d_op 字段为 NULL， // 将其设置为 simple_dentry_operations。 if (!dentry-&gt;d_sb-&gt;s_d_op) d_set_d_op(dentry, &amp;simple_dentry_operations); // 将 dentry 添加到 dcache 中，使用 NULL inode， // 表示负 dentry（即，文件不存在）。 d_add(dentry, NULL); // 返回 NULL，表示查找已完成。 return NULL;&#125;// 导出 simple_lookup 符号，使其可供其他模块使用。EXPORT_SYMBOL(simple_lookup); 如果没有找到文件，simple_lookup会返回NULL，并且 12if (!dentry-&gt;d_sb-&gt;s_d_op) d_set_d_op(dentry, &amp;simple_dentry_operations); 这段代码将d_op设置为simple_dentry_operations 然后调用d_add添加一个负dentry(NULL inode),表示文件不存在。 open_last_lookups函数open_last_lookups identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586static const char *open_last_lookups(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct dentry *dir = nd-&gt;path.dentry; // 获取路径对应的 dentry int open_flag = op-&gt;open_flag; // 获取文件打开标志 bool got_write = false; // 标记是否获取到写权限 struct dentry *dentry; const char *res; nd-&gt;flags |= op-&gt;intent; // 更新 nd 的标志，将 op-&gt;intent 合并到 nd-&gt;flags 中 // 处理不是普通类型的路径分量（如 &#x27;..&#x27;, &#x27;.&#x27;） if (nd-&gt;last_type != LAST_NORM) &#123; if (nd-&gt;depth) put_link(nd); // 如果 nd-&gt;depth 不为 0，释放符号链接 return handle_dots(nd, nd-&gt;last_type); // 处理 &#x27;.&#x27; 和 &#x27;..&#x27; 路径分量 &#125; // 如果未设置 O_CREAT，尝试在 RCU 模式下快速查找目录项 if (!(open_flag &amp; O_CREAT)) &#123; if (nd-&gt;last.name[nd-&gt;last.len]) nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; dentry = lookup_fast(nd); // 快速查找目录项 if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果出错，返回错误指针 if (likely(dentry)) goto finish_lookup; BUG_ON(nd-&gt;flags &amp; LOOKUP_RCU); &#125; else &#123; // 对于 O_CREAT 标志的处理 // 如果当前处于 RCU 模式，则尝试从 RCU 模式切换到非 RCU 模式 if (nd-&gt;flags &amp; LOOKUP_RCU) &#123; if (!try_to_unlazy(nd)) return ERR_PTR(-ECHILD); &#125; audit_inode(nd-&gt;name, dir, AUDIT_INODE_PARENT); // 审计相关操作 // 检查路径名是否有尾随的 &#x27;/&#x27; if (unlikely(nd-&gt;last.name[nd-&gt;last.len])) return ERR_PTR(-EISDIR); &#125; // 检查是否需要获取写权限 if (open_flag &amp; (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) &#123; got_write = !mnt_want_write(nd-&gt;path.mnt); &#125; // 如果设置了 O_CREAT，对目录 inode 上锁；否则，对目录 inode 加共享锁 if (open_flag &amp; O_CREAT) inode_lock(dir-&gt;d_inode); else inode_lock_shared(dir-&gt;d_inode); // 调用 lookup_open 函数进行打开或创建操作 dentry = lookup_open(nd, file, op, got_write); // 如果成功创建新文件，通知相关子系统 if (!IS_ERR(dentry) &amp;&amp; (file-&gt;f_mode &amp; FMODE_CREATED)) fsnotify_create(dir-&gt;d_inode, dentry); // 解锁目录 inode if (open_flag &amp; O_CREAT) inode_unlock(dir-&gt;d_inode); else inode_unlock_shared(dir-&gt;d_inode); // 如果已获取写权限，释放对挂载点的写权限 if (got_write) mnt_drop_write(nd-&gt;path.mnt); if (IS_ERR(dentry)) return ERR_CAST(dentry); // 如果出错，返回错误指针 // 如果文件已打开或创建，更新 nd-&gt;path if (file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED)) &#123; dput(nd-&gt;path.dentry); nd-&gt;path.dentry = dentry; return NULL; &#125;finish_lookup: // 结束查找，释放符号链接并进入下一个路径分量 if (nd-&gt;depth) put_link(nd); res = step_into(nd, WALK_TRAILING, dentry); if (unlikely(res)) nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL); return res;&#125; lookup_open函数lookup_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148// 定义 lookup_open 函数，参数包括：一个指向 nameidata 结构体的指针、一个指向 file 结构体的指针、一个指向 open_flags 结构体的指针，以及一个表示是否获得写权限的布尔值static struct dentry *lookup_open(struct nameidata *nd, struct file *file, const struct open_flags *op, bool got_write)&#123; // 定义一个指向 mnt_idmap 结构体的指针 struct mnt_idmap *idmap; // 定义一个指向当前目录 dentry 结构体的指针 struct dentry *dir = nd-&gt;path.dentry; // 定义一个指向当前目录 inode 结构体的指针 struct inode *dir_inode = dir-&gt;d_inode; // 定义一个整数变量，存储打开文件的标志 int open_flag = op-&gt;open_flag; // 定义一个指向最终要打开或创建的目录项的 dentry 结构体的指针 struct dentry *dentry; // 定义两个整数变量，分别用于存储错误码和创建错误码 int error, create_error = 0; // 定义一个无符号整数变量，存储文件模式 umode_t mode = op-&gt;mode; // 声明一个等待队列头并初始化为栈上变量 DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); // 如果当前目录已死，返回 -ENOENT 错误 if (unlikely(IS_DEADDIR(dir_inode))) return ERR_PTR(-ENOENT); // 清除文件结构体的创建模式标志 file-&gt;f_mode &amp;= ~FMODE_CREATED; // 查找当前目录是否包含要打开或创建的目录项 dentry = d_lookup(dir, &amp;nd-&gt;last); // 使用一个循环来处理目录项查找和验证 for (;;) &#123; // 如果目录项为空，进行并行分配 if (!dentry) &#123; dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq); // 如果分配失败，返回错误 if (IS_ERR(dentry)) return dentry; &#125; // 如果目录项还在查找中，跳出循环 if (d_in_lookup(dentry)) break; // 验证目录项 error = d_revalidate(dentry, nd-&gt;flags); // 如果验证成功，跳出循环 if (likely(error &gt; 0)) break; // 如果验证失败，处理错误 if (error) goto out_dput; // 使目录项失效 d_invalidate(dentry); // 释放目录项 dput(dentry); // 将目录项置为空 dentry = NULL; &#125; // 如果目录项的 inode 不为空，表示找到了正 dentry，将在 f_op-&gt;open 中打开 if (dentry-&gt;d_inode) &#123; return dentry; &#125; // 检查写权限 if (unlikely(!got_write)) open_flag &amp;= ~O_TRUNC; // 获取文件系统的 ID 映射 idmap = mnt_idmap(nd-&gt;path.mnt); // 如果需要创建文件 if (open_flag &amp; O_CREAT) &#123; // 确保 O_EXCL 和 O_TRUNC 不同时设置 if (open_flag &amp; O_EXCL) open_flag &amp;= ~O_TRUNC; // 准备文件模式 mode = vfs_prepare_mode(idmap, dir-&gt;d_inode, mode, mode, mode); // 检查是否具有创建权限 if (likely(got_write)) create_error = may_o_create(idmap, &amp;nd-&gt;path, dentry, mode); else create_error = -EROFS; &#125; // 如果创建失败，清除 O_CREAT 标志 if (create_error) open_flag &amp;= ~O_CREAT; // 如果支持原子打开操作 if (dir_inode-&gt;i_op-&gt;atomic_open) &#123; // 执行原子打开操作 dentry = atomic_open(nd, dentry, file, open_flag, mode); // 如果创建失败，返回创建错误 if (unlikely(create_error) &amp;&amp; dentry == ERR_PTR(-ENOENT)) dentry = ERR_PTR(create_error); return dentry; &#125; // 如果目录项仍在查找中 if (d_in_lookup(dentry)) &#123; // 执行查找操作3 struct dentry *res = dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry, nd-&gt;flags); // 标记查找完成 d_lookup_done(dentry); // 如果查找结果不为空 if (unlikely(res)) &#123; // 如果查找结果为错误，处理错误 if (IS_ERR(res)) &#123; error = PTR_ERR(res); goto out_dput; &#125; // 释放旧的目录项，将结果赋给目录项 dput(dentry); dentry = res; &#125; &#125; // 如果目录项的 inode 为空并且需要创建文件 if (!dentry-&gt;d_inode &amp;&amp; (open_flag &amp; O_CREAT)) &#123; // 设置文件结构体的创建模式标志 file-&gt;f_mode |= FMODE_CREATED; // 记录创建子节点的审计事件 audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE); // 如果没有创建操作，返回错误 if (!dir_inode-&gt;i_op-&gt;create) &#123; error = -EACCES; goto out_dput; &#125; // 创建新文件的关键代码 error = dir_inode-&gt;i_op-&gt;create(idmap, dir_inode, dentry, mode, open_flag &amp; O_EXCL); // 如果创建失败，处理错误 if (error) goto out_dput; &#125; // 如果创建失败且目录项的 inode 仍为空，返回错误 if (unlikely(create_error) &amp;&amp; !dentry-&gt;d_inode) &#123; error = create_error; goto out_dput; &#125; // 返回目录项 return dentry;// 处理释放目录项的错误情况out_dput: dput(dentry); // 返回错误指针 return ERR_PTR(error);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义 d_alloc_parallel 函数，输入参数包括父目录项 parent、目录项名字 name 和等待队列头 wqstruct dentry *d_alloc_parallel(struct dentry *parent, const struct qstr *name, wait_queue_head_t *wq)&#123; // 计算名字的哈希值 unsigned int hash = name-&gt;hash; // 计算哈希值对应的哈希链表头 struct hlist_bl_head *b = in_lookup_hash(parent, hash); // 声明哈希链表节点 struct hlist_bl_node *node; // 分配一个新的目录项 struct dentry *new = d_alloc(parent, name); // 声明一个目录项变量 struct dentry *dentry; // 声明序列号变量 unsigned seq, r_seq, d_seq; // 如果新分配的目录项为空，返回错误 if (unlikely(!new)) return ERR_PTR(-ENOMEM); // 使用一个循环来处理目录项查找和验证 retry: // 开启 RCU 读锁 rcu_read_lock(); // 获取父目录项的序列号 seq = smp_load_acquire(&amp;parent-&gt;d_inode-&gt;i_dir_seq); // 获取重命名锁的序列号 r_seq = read_seqbegin(&amp;rename_lock); // 在 RCU 保护下查找目录项 dentry = __d_lookup_rcu(parent, name, &amp;d_seq); // 如果目录项存在 if (unlikely(dentry)) &#123; // 尝试获取目录项的引用，如果失败则重试 if (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123; rcu_read_unlock(); goto retry; &#125; // 检查目录项的序列号是否发生变化，如果发生变化则释放目录项并重试 if (read_seqcount_retry(&amp;dentry-&gt;d_seq, d_seq)) &#123; rcu_read_unlock(); dput(dentry); goto retry; 123456789101112131415161718192021222324252627282930/** * d_lookup - 搜索一个dentry * @parent: 父dentry * @name: 我们要查找的名字的qstr * 返回: dentry，或者NULL * * d_lookup在父dentry的子项中搜索指定的名字。 * 如果找到了dentry，它的引用计数会递增，并返回该dentry。 * 调用者在使用完毕后必须使用dput来释放该项。如果dentry不存在，返回%NULL。 */struct dentry *d_lookup(const struct dentry *parent, const struct qstr *name)&#123; struct dentry *dentry; unsigned seq; // 使用循环，知道满足条件退出 do &#123; // 读取重命名锁的序列号 seq = read_seqbegin(&amp;rename_lock); // 在父dentry的子项中查找名字 dentry = __d_lookup(parent, name); // 如果找到了dentry，跳出循环 if (dentry) break; // 如果重命名锁的序列号发生变化，重试 &#125; while (read_seqretry(&amp;rename_lock, seq)); // 返回找到的dentry，如果没有找到则返回NULL return dentry;&#125;EXPORT_SYMBOL(d_lookup); // 导出d_lookup符号，供其他模块使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * __d_lookup - 搜索一个dentry（有竞争风险） * @parent: 父dentry * @name: 我们要查找的名字的qstr * 返回: dentry，或者NULL * * __d_lookup类似于d_lookup，然而由于无关的重命名活动，它可能（较少情况下）返回一个 * 错误的负面结果。 * * __d_lookup通过避免读取rename_lock seqlock而略微更快，但是必须谨慎使用，例如在失败时 * 使用后续的d_lookup。 * * __d_lookup调用者必须进行注释。 */struct dentry *__d_lookup(const struct dentry *parent, const struct qstr *name)&#123; unsigned int hash = name-&gt;hash; struct hlist_bl_head *b = d_hash(hash); struct hlist_bl_node *node; struct dentry *found = NULL; struct dentry *dentry; /* * 注意：与__d_lookup_rcu有很大的重复，这是为了防止单线程性能退化 * 尤其是在smp_rmb（在seqcounts中）代价高昂的体系结构上。 * 保持两个函数同步。 */ /* * 哈希列表使用RCU进行保护。 * * 在比较候选dentry时获取d_lock，以避免与d_move()的竞争。 * * 可能的是，同时发生的重命名可能会破坏我们这里的列表遍历， * 并导致我们的dentry丢失，从而导致错误的负面结果。 * d_lookup()使用rename_lock seqlock保护免受同时进行的重命名影响。 * * 有关详细信息，请参阅Documentation/filesystems/path-lookup.txt。 */ rcu_read_lock(); // 使用RCU遍历哈希列表的每个条目 hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123; if (dentry-&gt;d_name.hash != hash) continue; // 获取dentry的锁，避免竞争 spin_lock(&amp;dentry-&gt;d_lock); if (dentry-&gt;d_parent != parent) goto next; if (d_unhashed(dentry)) goto next; // 检查dentry的名字是否与给定的名字匹配 if (!d_same_name(dentry, parent, name)) goto next; // 增加dentry的引用计数 dentry-&gt;d_lockref.count++; found = dentry; // 解锁dentry的锁 spin_unlock(&amp;dentry-&gt;d_lock); break;next: spin_unlock(&amp;dentry-&gt;d_lock); &#125; rcu_read_unlock(); // 返回找到的dentry，如果没有找到则返回NULL return found;&#125; dir_inode-&gt;i_op-&gt;create指向shmem_create函数参考上文中的inode-&gt;i_op-&gt;lookup函数指向simple_lookup() 12345678910111213141516171819202122232425static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create,//这里定义了create函数 .lookup = simple_lookup,//这里定义了lookup函数 .link = shmem_link, .unlink = shmem_unlink, .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;;_setattr,&#125;; 可以看到这个结构体中.create = shmem_create，我们再细看shmem_create函数 shmem_create identifier - Linux source code (v6.3.6) - Bootlin 12345static int shmem_create(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, bool excl)&#123; return shmem_mknod(idmap, dir, dentry, mode | S_IFREG, 0);&#125; shmem_mknod函数shmem_mknod identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142static intshmem_mknod(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, umode_t mode, dev_t dev)&#123; struct inode *inode; // 用于存储新创建的 inode int error = -ENOSPC; // 初始化错误码为 -ENOSPC（没有空间可用） // 从共享内存文件系统获取新的 inode inode = shmem_get_inode(idmap, dir-&gt;i_sb, dir, mode, dev, VM_NORESERVE); if (inode) &#123; // 如果成功获取 inode // 创建简单 ACL（访问控制列表） error = simple_acl_create(dir, inode); if (error) // 如果创建失败，跳转到 out_iput 标签 goto out_iput; // 初始化 inode 安全属性 error = security_inode_init_security(inode, dir, &amp;dentry-&gt;d_name, shmem_initxattrs, NULL); // 如果初始化失败且错误码不是 -EOPNOTSUPP，跳转到 out_iput 标签 if (error &amp;&amp; error != -EOPNOTSUPP) goto out_iput; // 至此，文件创建成功，将错误码置为 0 error = 0; // 更新目录 inode 大小 dir-&gt;i_size += BOGO_DIRENT_SIZE; // 更新目录 inode 访问和修改时间 dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(dir); // 递增目录 inode 的 i_version inode_inc_iversion(dir); // 将新创建的 inode 与 dentry 关联 d_instantiate(dentry, inode); // 增加 dentry 引用计数 dget(dentry); /* Extra count - pin the dentry in core */ &#125; return error; // 返回错误码out_iput: // 处理创建过程中的错误 iput(inode); // 释放 inode return error; // 返回错误码&#125; do_open函数do_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* * 处理 open() 的最后一步 */static int do_open(struct nameidata *nd, struct file *file, const struct open_flags *op)&#123; struct mnt_idmap *idmap; int open_flag = op-&gt;open_flag; bool do_truncate; int acc_mode; int error; // 如果文件未被打开或创建，完成路径名解析 if (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123; error = complete_walk(nd); if (error) return error; &#125; // 如果文件未被创建，进行审计处理 if (!(file-&gt;f_mode &amp; FMODE_CREATED)) audit_inode(nd-&gt;name, nd-&gt;path.dentry, 0); // 获取文件系统 ID 映射 idmap = mnt_idmap(nd-&gt;path.mnt); // 处理 O_CREAT 标志 if (open_flag &amp; O_CREAT) &#123; // 如果设置了 O_EXCL 标志且文件未被创建，返回错误 if ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED)) return -EEXIST; // 如果目标是目录，返回错误 if (d_is_dir(nd-&gt;path.dentry)) return -EISDIR; // 检查是否有权限在粘滞位目录中创建文件 error = may_create_in_sticky(idmap, nd, d_backing_inode(nd-&gt;path.dentry)); if (unlikely(error)) return error; &#125; // 检查目标是否是目录 if ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry)) return -ENOTDIR; // 初始化 do_truncate 和 acc_mode do_truncate = false; acc_mode = op-&gt;acc_mode; // 如果文件已被创建，跳过写权限检查和截断操作 if (file-&gt;f_mode &amp; FMODE_CREATED) &#123; open_flag &amp;= ~O_TRUNC; acc_mode = 0; &#125; else if (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123; // 如果目标是普通文件且设置了 O_TRUNC 标志，检查写权限 error = mnt_want_write(nd-&gt;path.mnt); if (error) return error; do_truncate = true; &#125; // 检查是否有权限打开文件 error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag); // 如果没有错误且文件未被打开，调用 vfs_open 打开文件 if (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED)) error = vfs_open(&amp;nd-&gt;path, file); // 对文件执行 IMA 审计 if (!error) error = ima_file_check(file, op-&gt;acc_mode); // 如果需要截断，执行截断操作 if (!error &amp;&amp; do_truncate) error = handle_truncate(idmap, file); // 如果错误码大于 0，输出警告并设置错误码为 -EINVAL if (unlikely(error &gt; 0)) &#123; WARN_ON(1); error = -EINVAL; &#125; // 如果进行了截断操作，释放写权限 if (do_truncate) mnt_drop_write(nd-&gt;path.mnt); return error;&#125; vfs_open函数vfs_open identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314/** * vfs_open - 打开给定路径的文件 * @path: 要打开的路径 * @file: 新分配的文件，已初始化 f_flag */int vfs_open(const struct path *path, struct file *file)&#123; // 将文件的路径设置为给定路径 file-&gt;f_path = *path; // 调用 do_dentry_open() 函数打开文件 // 这里传递 NULL 作为 open() 函数的第三个参数，因为在 tmpfs 中，不需要特定的打开操作 return do_dentry_open(file, d_backing_inode(path-&gt;dentry), NULL);&#125; do_dentry_open函数do_dentry_open identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137static int do_dentry_open(struct file *f, struct inode *inode, int (*open)(struct inode *, struct file *))&#123; // 声明一个空的文件操作结构 static const struct file_operations empty_fops = &#123;&#125;; int error; // 增加路径的引用计数 path_get(&amp;f-&gt;f_path); // 设置文件的 inode f-&gt;f_inode = inode; // 设置文件的地址空间（映射） f-&gt;f_mapping = inode-&gt;i_mapping; // 从文件的地址空间中获取写回错误样本 f-&gt;f_wb_err = filemap_sample_wb_err(f-&gt;f_mapping); // 从文件中获取超级块错误样本 f-&gt;f_sb_err = file_sample_sb_err(f); // 检查文件是否以 O_PATH 标志打开，如果是，则设置文件模式和操作 if (unlikely(f-&gt;f_flags &amp; O_PATH)) &#123; f-&gt;f_mode = FMODE_PATH | FMODE_OPENED; f-&gt;f_op = &amp;empty_fops; return 0; &#125; // 如果文件以读模式打开，增加读取计数 if ((f-&gt;f_mode &amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ) &#123; i_readcount_inc(inode); // 如果文件以写模式打开且不是特殊文件，授予写访问权限 &#125; else if (f-&gt;f_mode &amp; FMODE_WRITE &amp;&amp; !special_file(inode-&gt;i_mode)) &#123; error = get_write_access(inode); if (unlikely(error)) goto cleanup_file; error = __mnt_want_write(f-&gt;f_path.mnt); if (unlikely(error)) &#123; put_write_access(inode); goto cleanup_file; &#125; f-&gt;f_mode |= FMODE_WRITER; &#125; // 为常规文件和目录启用原子位置 if (S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)) f-&gt;f_mode |= FMODE_ATOMIC_POS; /* 设置其他f_mode标志,获取shmem_file_operations作为f_op */ f-&gt;f_op = fops_get(inode-&gt;i_fop); if (WARN_ON(!f-&gt;f_op)) &#123; error = -ENODEV; goto cleanup_all; &#125; /* 调用security_file_open()和break_lease() */ error = security_file_open(f); if (error) goto cleanup_all; // 检查文件上是否存在需要中断的活动租约 error = break_lease(file_inode(f), f-&gt;f_flags); if (error) goto cleanup_all; // 为寻找、pread 和 pwrite 设置默认文件模式标志 f-&gt;f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE; // 使用文件操作提供的 open 函数，如果未提供，则使用默认值 if (!open) open = f-&gt;f_op-&gt;open; if (open) &#123; error = open(inode, f); if (error) goto cleanup_all; &#125; // 设置文件模式标志以表示文件已打开 f-&gt;f_mode |= FMODE_OPENED; // 根据相应操作的可用性设置读写能力 if ((f-&gt;f_mode &amp; FMODE_READ) &amp;&amp; likely(f-&gt;f_op-&gt;read || f-&gt;f_op-&gt;read_iter)) f-&gt;f_mode |= FMODE_CAN_READ; if ((f-&gt;f_mode &amp; FMODE_WRITE) &amp;&amp; likely(f-&gt;f_op-&gt;write || f-&gt;f_op-&gt;write_iter)) f-&gt;f_mode |= FMODE_CAN_WRITE; // 如果 llseek 操作不可用，则禁用寻找 if ((f-&gt;f_mode &amp; FMODE_LSEEK) &amp;&amp; !f-&gt;f_op-&gt;llseek) f-&gt;f_mode &amp;= ~FMODE_LSEEK; // 如果地址空间操作支持，则启用直接 I/O if (f-&gt;f_mapping-&gt;a_ops &amp;&amp; f-&gt;f_mapping-&gt;a_ops-&gt;direct_IO) f-&gt;f_mode |= FMODE_CAN_ODIRECT; // 清除不必要的打开标志 f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC); // 为文件设置 iocb 标志 f-&gt;f_iocb_flags = iocb_flags(f); // 初始化文件的预读状态 file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping); // 如果请求 O_DIRECT 但不支持，则返回错误 if ((f-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !(f-&gt;f_mode &amp; FMODE_CAN_ODIRECT)) return -EINVAL; // 如果文件以写模式打开，请确保不使用巨大的页面缓存 if (f-&gt;f_mode &amp; FMODE_WRITE) &#123; smp_mb(); // 为后续操作确保内存排序 // 检查页面缓存中是否有任何巨大的页面 if (filemap_nr_thps(inode-&gt;i_mapping)) &#123; struct address_space *mapping = inode-&gt;i_mapping; // 锁定页面缓存并使其无效 filemap_invalidate_lock(inode-&gt;i_mapping); // 取消映射文件的内存范围 unmap_mapping_range(mapping, 0, 0, 0); // 截断页面缓存中的 inode 页面 truncate_inode_pages(mapping, 0); // 解锁页面缓存 filemap_invalidate_unlock(inode-&gt;i_mapping); &#125; &#125; return 0;cleanup_all: // 检查无效的正错误代码并重置为 -EINVAL if (WARN_ON_ONCE(error &gt; 0)) error = -EINVAL; // 释放文件操作结构 fops_put(f-&gt;f_op); // 释放文件访问 put_file_access(f);cleanup_file: // 减少路径的引用计数并清除文件的路径和 inode path_put(&amp;f-&gt;f_path); f-&gt;f_path.mnt = NULL; f-&gt;f_path.dentry = NULL; f-&gt;f_inode = NULL; return error;&#125; open &#x3D; f-&gt;f_op-&gt;open设置为generic_filp_open函数generic_file_open identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718// 定义一个通用文件打开函数，它在一个inode即将被打开时调用。// 用于在32位系统中禁止打开大文件，除非调用者指定了O_LARGEFILE标志。// 在64位系统中，sys_open函数会强制使用这个标志。int generic_file_open(struct inode *inode, struct file *filp)&#123; // 检查filp-&gt;f_flags是否设置了O_LARGEFILE标志。如果没有设置 // 并且文件大小（通过i_size_read获取）大于MAX_NON_LFS（文件系统的最大文件限制）， // 则禁止打开该文件。 if (!(filp-&gt;f_flags &amp; O_LARGEFILE) &amp;&amp; i_size_read(inode) &gt; MAX_NON_LFS) // 如果条件满足，返回-EOVERFLOW表示文件太大，无法打开。 return -EOVERFLOW; // 如果文件大小在允许的范围内，返回0表示成功打开文件。 return 0;&#125;// 将generic_file_open函数导出为可供其他模块调用的符号。EXPORT_SYMBOL(generic_file_open); 首先这段代码f-&gt;f_op = fops_get(inode-&gt;i_fop);将f-&gt;f_op设置为shmem_file_operations 123456789101112131415// 定义shmem文件系统的文件操作结构体static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // 映射文件到内存的操作 .open = generic_file_open, // 打开文件的通用操作 .get_unmapped_area = shmem_get_unmapped_area, // 获取未映射区域的操作#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // 重定位文件读写指针的操作 .read_iter = shmem_file_read_iter, // 读取文件的操作 .write_iter = generic_file_write_iter, // 写入文件的通用操作 .fsync = noop_fsync, // 同步文件的空操作（因为shmem文件系统不需要同步） .splice_read = generic_file_splice_read, // 从文件中读取并拼接数据的通用操作 .splice_write = iter_file_splice_write, // 向文件中拼接并写入数据的操作 .fallocate = shmem_fallocate, // 预分配文件空间的操作#endif&#125;; 为什么设置为shmem_file_operations呢？根据上文对shmem_get_inode的解析，里面有这一段代码inode-&gt;i_fop = &amp;shmem_file_operations; 读写文件读文件read系统调用sys_read identifier - Linux source code (v6.3.7) - Bootlin 1234SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)&#123; return ksys_read(fd, buf, count);&#125; ksys_read函数ksys_read identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132// 定义 ksys_read 函数，参数包括：文件描述符（fd），用户缓冲区（buf）和要读取的字节数（count）ssize_t ksys_read(unsigned int fd, char __user *buf, size_t count)&#123; // 从给定的文件描述符（fd）获取文件描述符对象（f），并将返回值（ret）初始化为 -EBADF（错误：错误的文件描述符） struct fd f = fdget_pos(fd); ssize_t ret = -EBADF; // 如果文件描述符对象有效（不为 NULL） if (f.file) &#123; // 声明一个变量（pos）来存储文件中的当前位置和指向位置的指针（ppos） loff_t pos, *ppos = file_ppos(f.file); // 如果位置指针（ppos）不为 NULL，则将当前位置存储在变量（pos）中，并更新指针以指向它 if (ppos) &#123; pos = *ppos; ppos = &amp;pos; &#125; // 调用 vfs_read 函数从文件中读取数据到用户缓冲区（buf），并将结果存储在返回值（ret）中 ret = vfs_read(f.file, buf, count, ppos); // 如果读取操作成功（ret &gt;= 0）且位置指针不为 NULL，则更新文件描述符对象中的文件位置 if (ret &gt;= 0 &amp;&amp; ppos) f.file-&gt;f_pos = pos; // 释放文件描述符对象并更新文件位置 fdput_pos(f); &#125; // 返回读取操作的结果（已读取的字节数或错误代码） return ret;&#125; vfs_read函数vfs_read identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义 vfs_read 函数，参数包括：文件指针 (file)，用户缓冲区 (buf)，要读取的字节数 (count)，文件位置指针 (pos)ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)&#123; ssize_t ret; // 检查文件是否可读，如果不可读则返回 -EBADF 错误 if (!(file-&gt;f_mode &amp; FMODE_READ)) return -EBADF; // 检查文件是否支持读操作，如果不支持则返回 -EINVAL 错误 if (!(file-&gt;f_mode &amp; FMODE_CAN_READ)) return -EINVAL; // 检查用户缓冲区是否可以被访问，如果不可访问则返回 -EFAULT 错误 if (unlikely(!access_ok(buf, count))) return -EFAULT; // 验证读取区域是否合法，如果不合法则返回错误 ret = rw_verify_area(READ, file, pos, count); if (ret) return ret; // 如果要读取的字节数超过最大值，则将 count 设置为最大值 if (count &gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // 如果文件操作结构中有 read 函数，则调用它执行读取操作 if (file-&gt;f_op-&gt;read) ret = file-&gt;f_op-&gt;read(file, buf, count, pos); // 如果文件操作结构中有 read_iter 函数，则调用 new_sync_read 函数执行同步读取操作 else if (file-&gt;f_op-&gt;read_iter) ret = new_sync_read(file, buf, count, pos); // 如果没有适当的读取函数，则返回 -EINVAL 错误 else ret = -EINVAL; // 如果读取成功，执行文件访问通知并更新读取的字符数 if (ret &gt; 0) &#123; fsnotify_access(file); add_rchar(current, ret); &#125; // 增加系统调用计数 inc_syscr(current); // 返回读取操作的结果（已读取的字节数或错误代码） return ret;&#125; file-&gt;f_op-&gt;read_iter设置为shmem_file_read_iter参考上文open = f-&gt;f_op-&gt;open设置为generic_filp_open函数，同理，read_iter被设置为shmem_file_read_iter 12345678910111213// 定义shmem文件系统的文件操作结构体static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // 映射文件到内存的操作 .open = generic_file_open, // 打开文件的通用操作 .get_unmapped_area = shmem_get_unmapped_area, // 获取未映射区域的操作#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // 重定位文件读写指针的操作 .read_iter = shmem_file_read_iter, // 读取文件的操作 .write_iter = generic_file_write_iter, // 写入文件的通用操作 .fsync = noop_fsync, // 同步文件的空操作（因为shmem文件系统不需要同步） .splice_read = generic_file_splice_read, // 从文件中读取并拼接数据的通用操作 .splice_write = iter_file_splice_write, // 向文件中拼接并写入数据的操作 .fallocate = shmem_fallocate, // 预分配文件空间的 由于shmem_fille_operations没有定义read 根据如下vfs_read代码 123456789 // 如果文件操作结构中有 read 函数，则调用它执行读取操作if (file-&gt;f_op-&gt;read) ret = file-&gt;f_op-&gt;read(file, buf, count, pos);// 如果文件操作结构中有 read_iter 函数，则调用 new_sync_read 函数执行同步读取操作else if (file-&gt;f_op-&gt;read_iter) ret = new_sync_read(file, buf, count, pos);// 如果没有适当的读取函数，则返回 -EINVAL 错误else ret = -EINVAL; 下面会调用new_sync_read函数 new_sync_read函数new_sync_read identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122// 定义一个同步读取函数，用于从文件中读取数据到用户缓冲区static ssize_t new_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)&#123; struct kiocb kiocb; // 定义一个IO控制块（IOCB）结构体实例 struct iov_iter iter; // 定义一个IO向量迭代器（用于描述用户缓冲区） ssize_t ret; // 用于存储函数返回值（读取的字节数） init_sync_kiocb(&amp;kiocb, filp); // 使用文件指针初始化同步IOCB kiocb.ki_pos = (ppos ? *ppos : 0); // 设置IOCB的文件位置（如果ppos非空，则使用*ppos，否则使用0） // 初始化IO向量迭代器，将其与用户缓冲区关联 iov_iter_ubuf(&amp;iter, ITER_DEST, buf, len); // 调用文件系统的read_iter方法（如果存在），并将结果存储到ret变量中 ret = call_read_iter(filp, &amp;kiocb, &amp;iter); BUG_ON(ret == -EIOCBQUEUED); // 如果返回值为-EIOCBQUEUED，触发内核bug（因为这是一个同步操作） if (ppos) // 如果ppos非空 *ppos = kiocb.ki_pos; // 将IOCB的文件位置更新到ppos变量中 return ret; // 返回读取的字节数&#125; call_read_iter函数call_read_iter identifier - Linux source code (v6.3.7) - Bootlin 12345static inline ssize_t call_read_iter(struct file *file, struct kiocb *kio, struct iov_iter *iter)&#123; return file-&gt;f_op-&gt;read_iter(kio, iter);&#125; shmem_file_read_iter函数由上文可知，file-&gt;f_op-&gt;read_iter设置为shmem_file_read_read shmem_file_read_iter identifier - Linux source code (v6.3.6) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 定义shmem文件系统的文件读取函数static ssize_t shmem_file_read_iter(struct kiocb *iocb, struct iov_iter *to)&#123; // 定义一些局部变量 struct file *file = iocb-&gt;ki_filp; struct inode *inode = file_inode(file); struct address_space *mapping = inode-&gt;i_mapping; pgoff_t index; unsigned long offset; int error = 0; ssize_t retval = 0; loff_t *ppos = &amp;iocb-&gt;ki_pos; // 计算要读取的页索引和页内偏移量 index = *ppos &gt;&gt; PAGE_SHIFT; offset = *ppos &amp; ~PAGE_MASK; // 循环读取数据，直到读完或出错 for (;;) &#123; struct folio *folio = NULL; struct page *page = NULL; pgoff_t end_index; unsigned long nr, ret; loff_t i_size = i_size_read(inode); // 计算文件的最后一个页索引 end_index = i_size &gt;&gt; PAGE_SHIFT; if (index &gt; end_index) break; if (index == end_index) &#123; nr = i_size &amp; ~PAGE_MASK; if (nr &lt;= offset) break; &#125; // 获取所需页的folio error = shmem_get_folio(inode, index, &amp;folio, SGP_READ); if (error) &#123; if (error == -EINVAL) error = 0; break; &#125; if (folio) &#123; folio_unlock(folio); // 获取文件页 page = folio_file_page(folio, index); if (PageHWPoison(page)) &#123; folio_put(folio); error = -EIO; break; &#125; &#125; // 计算要读取的字节数 nr = PAGE_SIZE; i_size = i_size_read(inode); end_index = i_size &gt;&gt; PAGE_SHIFT; if (index == end_index) &#123; nr = i_size &amp; ~PAGE_MASK; if (nr &lt;= offset) &#123; if (folio) folio_put(folio); break; &#125; &#125; nr -= offset; if (folio) &#123; // 如果有写入映射，刷新数据缓存 if (mapping_writably_mapped(mapping)) flush_dcache_page(page); // 如果读取页的开始，标记页为已访问 if (!offset) folio_mark_accessed(folio); // 将页的内容复制到用户空间 ret = copy_page_to_iter(page, offset, nr, to); folio_put(folio); &#125; else if (user_backed_iter(to)) &#123; // 用零页代替清空用户空间，提高效率 ret = copy_page_to_iter(ZERO_PAGE(0), offset, nr, to); &#125; else &#123; // 对于管道等，避免连续两次提交相同的页 ret = iov_iter_zero(nr, to); &#125; // 更新读取计数和偏移量 retval += ret; offset += ret; index += offset &gt;&gt; PAGE_SHIFT; offset &amp;= ~PAGE_MASK; // 检查是否还有数据需要读取 if (!iov_iter_count(to)) break; if (ret &lt; nr) &#123; error = -EFAULT; break; &#125; cond_resched(); &#125; // 更新文件位置 *ppos = ((loff_t) index &lt;&lt; PAGE_SHIFT) + offset; // 标记文件访问 file_accessed(file); // 返回读取的字节数或错误码 return retval ? retval : error;&#125; 写文件write系统调用sys_write identifier - Linux source code (v6.3.7) - Bootlin 12345SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)&#123; return ksys_write(fd, buf, count);&#125; ksys_write函数ksys_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)&#123; // 函数签名，接受三个参数：文件描述符 fd、用户空间缓冲区的指针 buf 和要写入的字节数 count struct fd f = fdget_pos(fd); // 获取与文件描述符 fd 相关联的 struct fd 对象（同时获取文件对象和位置） ssize_t ret = -EBADF; // 初始化返回值为 -EBADF（表示无效的文件描述符） if (f.file) &#123; // 如果文件描述符有效（即 f.file 非 NULL） loff_t pos, *ppos = file_ppos(f.file); // 获取文件的当前写入位置 if (ppos) &#123; // 如果 ppos 非 NULL pos = *ppos; // 保存文件的当前写入位置到 pos ppos = &amp;pos; // ppos 指向 pos 的地址 &#125; ret = vfs_write(f.file, buf, count, ppos); // 调用 vfs_write 函数进行实际的写操作，并将返回值赋给 ret if (ret &gt;= 0 &amp;&amp; ppos) // 如果写操作成功（ret &gt;= 0）且 ppos 非 NULL f.file-&gt;f_pos = pos; // 更新文件对象的写入位置 fdput_pos(f); // 释放 struct fd 对象（减少引用计数） &#125; return ret; // 返回写操作的结果，如果成功则返回写入的字节数，否则返回一个负的错误码&#125; vfs_write函数vfs_write identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)&#123; // 函数签名，接受四个参数：文件对象指针 file、用户空间缓冲区的指针 buf、要写入的字节数 count 和文件写入位置 pos 的指针 ssize_t ret; // 定义返回值变量 if (!(file-&gt;f_mode &amp; FMODE_WRITE)) return -EBADF; // 如果文件不可写，返回 -EBADF（错误的文件描述符） if (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE)) return -EINVAL; // 如果文件模式不允许写入，返回 -EINVAL（无效参数） if (unlikely(!access_ok(buf, count))) return -EFAULT; // 如果用户空间缓冲区不可访问，返回 -EFAULT（错误的地址） ret = rw_verify_area(WRITE, file, pos, count); // 验证写入请求是否合法，将结果赋给 ret if (ret) return ret; // 如果验证结果为非零值（错误），则返回该值 if (count &gt; MAX_RW_COUNT) count = MAX_RW_COUNT; // 如果要写入的字节数大于最大允许值，则限制写入字节数为最大允许值 file_start_write(file); // 准备文件开始写入 if (file-&gt;f_op-&gt;write) ret = file-&gt;f_op-&gt;write(file, buf, count, pos); // 如果定义了 write 函数，调用它进行实际的写操作，并将返回值赋给 ret else if (file-&gt;f_op-&gt;write_iter) ret = new_sync_write(file, buf, count, pos); // 否则，如果定义了 write_iter 函数，调用 new_sync_write 函数进行写操作，并将返回值赋给 ret else ret = -EINVAL; // 如果没有定义 write 或 write_iter 函数，返回 -EINVAL（无效参数） if (ret &gt; 0) &#123; // 如果写操作成功（ret &gt; 0） fsnotify_modify(file); // 通知相关文件系统事件 add_wchar(current, ret); // 更新当前进程的写入字符计数（增加 ret 个字符） &#125; inc_syscw(current); // 增加当前进程的系统调用计数 file_end_write(file); // 结束文件写入 return ret; // 返回写操作的结果，如果成功则返回写入的字节数，否则返回一个负的错误码&#125; file-&gt;f_op-&gt;write_iter设置为generic_file_write_iter参考上文中的file-&gt;f_op-&gt;read_iter设置为shmem_file_read_iter 12345678910111213// 定义shmem文件系统的文件操作结构体static const struct file_operations shmem_file_operations = &#123; .mmap = shmem_mmap, // 映射文件到内存的操作 .open = generic_file_open, // 打开文件的通用操作 .get_unmapped_area = shmem_get_unmapped_area, // 获取未映射区域的操作#ifdef CONFIG_TMPFS .llseek = shmem_file_llseek, // 重定位文件读写指针的操作 .read_iter = shmem_file_read_iter, // 读取文件的操作 .write_iter = generic_file_write_iter, // 写入文件的通用操作 .fsync = noop_fsync, // 同步文件的空操作（因为shmem文件系统不需要同步） .splice_read = generic_file_splice_read, // 从文件中读取并拼接数据的通用操作 .splice_write = iter_file_splice_write, // 向文件中拼接并写入数据的操作 .fallocate = shmem_fallocate, // 预分配文件空间的 可以看到write_iter设置为generic_file_write_iter 根据下面这段vfs_write代码 123456 if (file-&gt;f_op-&gt;write) ret = file-&gt;f_op-&gt;write(file, buf, count, pos); // 如果定义了 write 函数，调用它进行实际的写操作，并将返回值赋给 retelse if (file-&gt;f_op-&gt;write_iter) ret = new_sync_write(file, buf, count, pos); // 否则，如果定义了 write_iter 函数，调用 new_sync_write 函数进行写操作，并将返回值赋给 retelse ret = -EINVAL; // 如果没有定义 write 或 write_i 因为shmem_file_operation没有设置write函数，所以下面进入new_sync_write函数 new_sync_write函数new_sync_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)&#123; struct kiocb kiocb; struct iov_iter iter; ssize_t ret; init_sync_kiocb(&amp;kiocb, filp); kiocb.ki_pos = (ppos ? *ppos : 0); iov_iter_ubuf(&amp;iter, ITER_SOURCE, (void __user *)buf, len); ret = call_write_iter(filp, &amp;kiocb, &amp;iter); BUG_ON(ret == -EIOCBQUEUED); if (ret &gt; 0 &amp;&amp; ppos) *ppos = kiocb.ki_pos; return ret;&#125; call_write_iter函数call_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345static inline ssize_t call_write_iter(struct file *file, struct kiocb *kio, struct iov_iter *iter)&#123; return file-&gt;f_op-&gt;write_iter(kio, iter);&#125; generic_file_write_iter函数 generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728/** * generic_file_write_iter - 将数据写入文件 * @iocb: IO 状态结构 * @from: 带有要写入数据的 iov_iter * * 这是一个用于大多数文件系统的 __generic_file_write_iter() 的封装。 * 它负责在 O_SYNC 文件情况下同步文件，并根据需要获取 i_rwsem。 * 返回： * * 如果没有写入任何数据或 vfs_fsync_range() 在同步写入时失败，则返回负错误代码 * * 写入的字节数，即使是截断写入 */ssize_t generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)&#123; struct file *file = iocb-&gt;ki_filp; // 从 kiocb 获取文件指针 struct inode *inode = file-&gt;f_mapping-&gt;host; // 从文件的映射主机获取 inode ssize_t ret; // 声明结果的返回变量 inode_lock(inode); // 在写入之前锁定 inode ret = generic_write_checks(iocb, from); // 执行通用写入检查 if (ret &gt; 0) // 如果检查通过且允许写入 ret = __generic_file_write_iter(iocb, from); // 调用实际的文件写入函数 inode_unlock(inode); // 写入后解锁 inode if (ret &gt; 0) // 如果写入成功 ret = generic_write_sync(iocb, ret); // 如果需要（例如，设置了 O_SYNC 标志），同步写入的数据 return ret; // 返回结果（写入的字节数或错误代码）&#125;EXPORT_SYMBOL(generic_file_write_iter); __generic_file_write_iter__generic_file_write_iter identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * __generic_file_write_iter - 将数据写入文件 * @iocb: IO 状态结构（文件，偏移等） * @from: 带有要写入数据的 iov_iter * * 此函数完成实际将数据写入文件所需的所有工作。它执行所有基本检查，从文件中删除 SUID， * 更新修改时间，并根据我们执行直接 IO 还是标准缓冲写入来调用适当的子程序。 * * 除非我们在块设备或类似不需要锁定的对象上工作，否则期望已获得 i_rwsem。 * * 此函数*不*负责在 O_SYNC 写入时同步数据。调用者必须处理它。这主要是因为我们要 * 避免在 i_rwsem 下进行同步。 * * 返回： * * 写入的字节数，即使是截断的写入 * * 如果没有写入任何数据，则为负错误代码 */ssize_t __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)&#123; struct file *file = iocb-&gt;ki_filp; // 获取文件指针 struct address_space *mapping = file-&gt;f_mapping; // 获取文件的地址空间映射 struct inode *inode = mapping-&gt;host; // 获取映射主机的 inode ssize_t written = 0; // 初始化已写字节数为 0 ssize_t err; // 错误变量 ssize_t status; // 状态变量 // 我们可以在页面回收中写回此队列 current-&gt;backing_dev_info = inode_to_bdi(inode); err = file_remove_privs(file); // 移除文件的特权 if (err) goto out; err = file_update_time(file); // 更新文件时间 if (err) goto out; if (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123; // 如果使用直接 IO loff_t pos, endbyte; written = generic_file_direct_write(iocb, from); // 执行直写 /* * 如果写入未完成，回退到缓冲写入。例如，某些文件系统对洞的写入就是这样。 * 对于 DAX 文件，缓冲写入将无法成功（即使成功，DAX 也无法正确处理脏的 * 页面缓存页面）。 */ if (written &lt; 0 || !iov_iter_count(from) || IS_DAX(inode)) goto out; pos = iocb-&gt;ki_pos; status = generic_perform_write(iocb, from); // 执行回写 /* * 如果 generic_perform_write() 返回了同步错误，则我们希望返回直接写入 * 的字节数，或者如果为零，则返回错误代码。请注意，这与正常的直接 IO 语义 * 不同，即使写入了一些字节，也会返回 -EFOO。 */ if (unlikely(status &lt; 0)) &#123; err = status; goto out; &#125; /* * 我们需要确保页面缓存页面被写入磁盘并失效，以保留预期的 O_DIRECT 语义。 */ endbyte = pos + status - 1; err = filemap_write_and_wait_range(mapping, pos, endbyte); if (err == 0) &#123; iocb-&gt;ki_pos = endbyte + 1; written += status; invalidate_mapping_pages(mapping, pos &gt;&gt; PAGE_SHIFT, endbyte &gt;&gt; PAGE_SHIFT); &#125; else &#123; /* * 我们不知道写了多少，所以只返回直接写入的字节数 */ &#125; &#125; else &#123; written = generic_perform_write(iocb, from); // 执行回写 if (likely(written &gt; 0)) iocb-&gt;ki_pos += written; &#125;out: current-&gt;backing_dev_info = NULL; return written ? written : err;&#125;EXPORT_SYMBOL(__generic_file_write_iter); generic_file_direct_write函数generic_file_direct_write identifier - Linux source code (v6.3.7) - Bootlin 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182ssize_t generic_file_direct_write(struct kiocb *iocb, struct iov_iter *from) &#123; struct file *file = iocb-&gt;ki_filp; //获取文件对象 struct address_space *mapping = file-&gt;f_mapping; //获取地址空间 struct inode *inode = mapping-&gt;host; //获取索引节点对象 loff_t pos = iocb-&gt;ki_pos; //获取写入位置 ssize_t written; size_t write_len; pgoff_t end; write_len = iov_iter_count(from); //获取要写入的数据长度 end = (pos + write_len - 1) &gt;&gt; PAGE_SHIFT; //计算结束页号 if (iocb-&gt;ki_flags &amp; IOCB_NOWAIT) &#123; //如果是非阻塞IO /* 如果有要写回的页面,返回 */ if (filemap_range_has_page(file-&gt;f_mapping, pos, //判断范围内是否有页面 pos + write_len - 1)) return -EAGAIN; &#125; else &#123; written = filemap_write_and_wait_range(mapping, pos, //同步文件范围内的页面 pos + write_len - 1); if (written) goto out; &#125; /* * 在写入后,我们希望缓冲读取确实去磁盘获取 * 新数据。我们失效要写入区域的干净缓存页面。 * 我们在写入之前这样做,*之前*我们可以不破坏 * -&gt;direct_IO()返回的-EIOCBQUEUED。 */ written = invalidate_inode_pages2_range(mapping, //失效页面范围 pos &gt;&gt; PAGE_SHIFT, end); /* * 如果无法使页面无效,返回0以回退 * 到缓冲写入。 */ if (written) &#123; if (written == -EBUSY) return 0; goto out; &#125; written = mapping-&gt;a_ops-&gt;direct_IO(iocb, from); //执行direct IO写入 /* * 最后,再试一次使干净页面无效,这些页面可能 * 被非直接读前读入高速缓存,或者如果写的源 * 是文件的映射区域,则可能由get_user_pages()引起故障。 * 其中任何一个都是相当疯狂的事情要做, * 所以我们不完全支持它。如果此无效化 * 失败,那还行,写入仍然有效... * * 大多数时候我们不需要这么做,因为dio_complete() * 会为我们做无效化。然而,有一些文件系统 * 最终不会调用dio_complete(),所以不要通过 * 完全删除它来破坏它们。 * * 显著的例子是blkdev_direct_IO()。 * * 跳过异步写入的无效化或如果映射没有页面。 */ if (written &gt; 0 &amp;&amp; mapping-&gt;nrpages &amp;&amp; invalidate_inode_pages2_range(mapping, pos &gt;&gt; PAGE_SHIFT, end)) dio_warn_stale_pagecache(file); if (written &gt; 0) &#123; pos += written; //更新写入位置 write_len -= written; if (pos &gt; i_size_read(inode) &amp;&amp; !S_ISBLK(inode-&gt;i_mode)) &#123; //更新文件大小 i_size_write(inode, pos); mark_inode_dirty(inode); &#125; iocb-&gt;ki_pos = pos; &#125; if (written != -EIOCBQUEUED) iov_iter_revert(from, write_len - iov_iter_count(from)); out: return written; &#125; EXPORT_SYMBOL(generic_file_direct_write); generic_perform_write函数generic_perform_write identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475ssize_t generic_perform_write(struct kiocb *iocb, struct iov_iter *i)&#123; struct file *file = iocb-&gt;ki_filp; //获取文件对象 loff_t pos = iocb-&gt;ki_pos; //获取写入位置 struct address_space *mapping = file-&gt;f_mapping; //获取地址空间 const struct address_space_operations *a_ops = mapping-&gt;a_ops; //获取地址空间操作 long status = 0; ssize_t written = 0; do &#123; struct page *page; unsigned long offset; /* Offset into pagecache page */ unsigned long bytes; /* Bytes to write to page */ size_t copied; /* Bytes copied from user */ void *fsdata = NULL; offset = (pos &amp; (PAGE_SIZE - 1)); bytes = min_t(unsigned long, PAGE_SIZE - offset, //计算本次要写入的字节数 iov_iter_count(i));again: /* * 首先带入用户页面,我们要从中复制。 * 否则,如果未将其标记为最新,则会出现从 * 同一页面复制和写入的可怕死锁。 */ if (unlikely(fault_in_iov_iter_readable(i, bytes) == bytes)) &#123; status = -EFAULT; break; &#125; if (fatal_signal_pending(current)) &#123; status = -EINTR; break; &#125; status = a_ops-&gt;write_begin(file, mapping, pos, bytes, //执行写开始 &amp;page, &amp;fsdata); if (unlikely(status &lt; 0)) break; if (mapping_writably_mapped(mapping)) //刷新页高速缓存 flush_dcache_page(page); copied = copy_page_from_iter_atomic(page, offset, bytes, i); //从迭代器复制数据到页面 flush_dcache_page(page); status = a_ops-&gt;write_end(file, mapping, pos, bytes, copied, //执行写结束 page, fsdata); if (unlikely(status != copied)) &#123; iov_iter_revert(i, copied - max(status, 0L)); if (unlikely(status &lt; 0)) break; &#125; cond_resched(); if (unlikely(status == 0)) &#123; /* * 短复制导致-&gt;write_end()完全拒绝 * 该事物。可能是中途的内存中毒,可能与munmap的竞争, * 可能是严重的内存压力。 */ if (copied) bytes = copied; goto again; &#125; pos += status; //更新写入位置 written += status; balance_dirty_pages_ratelimited(mapping); &#125; while (iov_iter_count(i)); return written ? written : status; &#125; EXPORT_SYMBOL(generic_perform_write); 删除文件unlink系统调用sys_unlink identifier - Linux source code (v6.3.7) - Bootlin 1234 SYSCALL_DEFINE1(unlink, const char __user *, pathname)&#123; return do_unlinkat(AT_FDCWD, getname(pathname));&#125; do_unlinkat函数do_unlinkat identifier - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * 确保文件的实际截断发生在其目录的 i_mutex 外部。 * 如果发生大量写出，截断可能需要很长时间， * 我们不希望在等待 I/O 时阻止对目录的访问。 */int do_unlinkat(int dfd, struct filename *name)&#123; int error; // 错误码 struct dentry *dentry; // 目录项指针 struct path path; // 路径结构体 struct qstr last; // 最后一个路径组件的字符串 int type; // 路径类型 struct inode *inode = NULL; // 文件 inode 指针 struct inode *delegated_inode = NULL; // 委托 inode 指针 unsigned int lookup_flags = 0; // 查找标志retry: // 重试标签 error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); // 获取父目录 if (error) goto exit1; // 如果出错，跳转到 exit1 error = -EISDIR; // 设置错误码为 -EISDIR（是一个目录） if (type != LAST_NORM) // 如果类型不是 LAST_NORM goto exit2; // 跳转到 exit2 error = mnt_want_write(path.mnt); // 检查是否允许写入 if (error) goto exit2; // 如果出错，跳转到 exit2retry_deleg: // 重试委托标签 inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); // 对父目录进行加锁 dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); // 查找目录项 error = PTR_ERR(dentry); // 获取错误码 if (!IS_ERR(dentry)) &#123; // 如果没有错误 // 为什么要放在这里？因为我们需要正确的错误值 if (last.name[last.len]) goto slashes; // 如果 last.name[last.len] 不为 0，跳转到 slashes inode = dentry-&gt;d_inode; // 获取文件的 inode if (d_is_negative(dentry)) goto slashes; // 如果目录项是负的，跳转到 slashes ihold(inode); // 增加 inode 引用计数 error = security_path_unlink(&amp;path, dentry); // 检查安全策略 if (error) goto exit3; // 如果出错，跳转到 exit3 error = vfs_unlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry, &amp;delegated_inode); // 删除文件链接exit3: dput(dentry); // 释放目录项 &#125; inode_unlock(path.dentry-&gt;d_inode); // 解锁父目录 if (inode) iput(inode); // 如果 inode 存在，截断 inode inode = NULL; // 将 inode 置为空 if (delegated_inode) &#123; // 如果委托 inode 存在 error = break_deleg_wait(&amp;delegated_inode); // 等待委托中断 if (!error) goto retry_deleg; // 如果没有错误，跳转到 retry_deleg &#125; mnt_drop_write(path.mnt); // 放弃写权限exit2: path_put(&amp;path); // 释放路径 if (retry_estale(error, lookup_flags)) &#123; // 如果需要重试 lookup_flags |= LOOKUP_REVAL; // 更新查找标志 inode = NULL; // 将 inode 置为空 goto retry; // 跳转到 retry &#125;exit1: putname(name); // 释放文件名 return error; // 返回错误码slashes: // slashes 标签 if (d_is_negative(dentry)) // 如果目录项是负的 error = -ENOENT; // 错误码设置为 -ENOENT（文件不存在） else if (d_is_dir(dentry)) // 如果目录项是目录 error = -EISDIR; // 错误码设置为 -EISDIR（是一个目录） else error = -ENOTDIR; // 错误码设置为 -ENOTDIR（不是一个目录） goto exit3; // 跳转到 exit3&#125; vfs_unlink函数vfs_unlink identifier - Linux source code (v6.3.7) - Bootlin 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * vfs_unlink - 删除文件系统对象的链接 * @idmap: 挂载点的 idmap * @dir: 父目录 * @dentry: 受害者 * @delegated_inode: 如果 inode 被委托，返回受害者 inode。 * * 调用者必须持有 dir-&gt;i_mutex。 * * 如果 vfs_unlink 发现一个委托，它将返回 -EWOULDBLOCK，并 * 在 delegated_inode 中返回对 inode 的引用。调用者 * 应该在那个 inode 上中断委托并重试。因为 * 中断委托可能需要很长时间，调用者在执行此操作之前应放弃 * dir-&gt;i_mutex。 * * 或者，调用者可以为 delegated_inode 传递 NULL。这可能 * 适用于期望底层文件系统不是 NFS 导出的调用者。 * * 如果通过 idmapped 挂载找到了 inode，则必须通过 @idmap 传递 vfsmount 的 idmap。 * 该函数将在检查权限之前根据 @idmap 映射 inode。 * 在非 idmapped 挂载上或者对原始 inode 执行权限检查，只需传递 @nop_mnt_idmap。 */int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)&#123; struct inode *target = dentry-&gt;d_inode; // 目标 inode int error = may_delete(idmap, dir, dentry, 0); // 检查是否可以删除 if (error) // 如果有错误 return error; // 返回错误 if (!dir-&gt;i_op-&gt;unlink) // 如果没有提供 unlink 操作 return -EPERM; // 返回 -EPERM（不允许的操作） inode_lock(target); // 锁定目标 inode if (IS_SWAPFILE(target)) // 如果目标是交换文件 error = -EPERM; // 返回 -EPERM（不允许的操作） else if (is_local_mountpoint(dentry)) // 如果 dentry 是本地挂载点 error = -EBUSY; // 返回 -EBUSY（设备或资源忙） else &#123; error = security_inode_unlink(dir, dentry); // 检查安全策略 if (!error) &#123; // 如果没有错误 error = try_break_deleg(target, delegated_inode); // 尝试中断委托 if (error) // 如果有错误 goto out; // 跳转到 out error = dir-&gt;i_op-&gt;unlink(dir, dentry); // 执行 unlink 操作 if (!error) &#123; // 如果没有错误 dont_mount(dentry); // 不要挂载 dentry detach_mounts(dentry); // 分离挂载点 &#125; &#125; &#125;out: // out 标签 inode_unlock(target); // 解锁目标 inode // 我们不删除 NFS sillyrenamed 文件的 d_delete() - 它们仍然存在。 if (!error &amp;&amp; dentry-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) &#123; fsnotify_unlink(dir, dentry); // 发送文件系统通知 &#125; else if (!error) &#123; fsnotify_link_count(target); // 更新链接计数 d_delete_notify(dir, dentry); // 发送删除通知 &#125; return error; // 返回错误&#125;EXPORT_SYMBOL(vfs_unlink); dir-&gt;i_op-&gt;unlink设置为shmem_unlink函数 参考上文中的inode-&gt;i_op-&gt;lookup函数指向 simple_lookup() 函数 123456789101112131415161718192021222324static const struct inode_operations shmem_dir_inode_operations = &#123;#ifdef CONFIG_TMPFS .getattr = shmem_getattr, .create = shmem_create, .lookup = simple_lookup,//这里定义了lookup函数 .link = shmem_link, .unlink = shmem_unlink,//这里定义了unlink函数 .symlink = shmem_symlink, .mkdir = shmem_mkdir, .rmdir = shmem_rmdir, .mknod = shmem_mknod, .rename = shmem_rename2, .tmpfile = shmem_tmpfile,#endif#ifdef CONFIG_TMPFS_XATTR .listxattr = shmem_listxattr, .fileattr_get = shmem_fileattr_get, .fileattr_set = shmem_fileattr_set,#endif#ifdef CONFIG_TMPFS_POSIX_ACL .setattr = shmem_setattr, .set_acl = simple_set_acl,#endif&#125;; shmem_unlink identifier - Linux source code (v6.3.6) - Bootlin 12345678910111213141516static int shmem_unlink(struct inode *dir, struct dentry *dentry)&#123; struct inode *inode = d_inode(dentry); // 获取 dentry 对应的 inode // 如果 inode 的链接数大于 1 且 inode 不是目录，则释放 inode if (inode-&gt;i_nlink &gt; 1 &amp;&amp; !S_ISDIR(inode-&gt;i_mode)) shmem_free_inode(inode-&gt;i_sb); dir-&gt;i_size -= BOGO_DIRENT_SIZE; // 减小父目录的大小 // 更新 inode 和父目录的 ctime 和 mtime 为当前时间 inode-&gt;i_ctime = dir-&gt;i_ctime = dir-&gt;i_mtime = current_time(inode); inode_inc_iversion(dir); // 增加父目录的 i_version drop_nlink(inode); // 减少 inode 的链接数 dput(dentry); // 撤销 &quot;create&quot; 操作的计数，完成所有工作 return 0; // 返回 0，表示成功&#125; 参考资料 Tmpfs — The Linux Kernel documentation — Tmpfs — Linux 内核文档 tmpfs - 维基百科，自由的百科全书 (wikipedia.org) tmpfs - ArchWiki (archlinux.org) GPT-4 Linux操作系统学习笔记（十二）虚拟文件系统 | Ty-Chen’s Home","categories":[],"tags":[]},{"title":"论文阅读 How to Get More Value From Your File System Directory Cache","slug":"论文阅读-How-to-Get-More-Value-From-Your-File-System-Directory-Cache","date":"2023-06-08T08:21:52.000Z","updated":"2023-06-11T14:34:56.714Z","comments":true,"path":"2023/06/08/论文阅读-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/","link":"","permalink":"http://example.com/2023/06/08/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-How-to-Get-More-Value-From-Your-File-System-Directory-Cache/","excerpt":"Abstract 应用程序经常请求文件系统操作来遍历文件系统目录树,例如打开文件或读取文件元数据。因此,在内存中缓存文件系统目录结构和元数据对操作系统内核的性能优化非常重要。 本文确定了几个设计原则,可以在应用程序和文件系统透明的情况下显著提高命中率并降低命中成本。具体而言,我们的目录缓存设计可以在恒定数量的散列表操作中查找目录,将查找路径与权限检查分离,对访问控制检查的结果进行记忆化,使用签名加速查找,并通过缓存目录完整性降低未命中率。","text":"Abstract 应用程序经常请求文件系统操作来遍历文件系统目录树,例如打开文件或读取文件元数据。因此,在内存中缓存文件系统目录结构和元数据对操作系统内核的性能优化非常重要。 本文确定了几个设计原则,可以在应用程序和文件系统透明的情况下显著提高命中率并降低命中成本。具体而言,我们的目录缓存设计可以在恒定数量的散列表操作中查找目录,将查找路径与权限检查分离,对访问控制检查的结果进行记忆化,使用签名加速查找,并通过缓存目录完整性降低未命中率。 该设计可以满足POSIX、Linux安全模块、命名空间和装入别名等差异性要求的一系列要求。这些优化对实际应用程序是一个重要的净改进,例如可以将Dovecot IMAP服务器的吞吐量提高12%,并将updatedb实用程序的吞吐量提高29%。 文件系统目录缓存是将文件系统的目录结构和元数据信息缓存在内存中的技术。它的主要目的是提高文件系统操作的性能。 文件系统目录缓存的主要思想是:应用程序在访问文件系统时,大部分操作是在已访问过的目录下进行的。如果能将这些目录信息缓存在内存中,那么应用程序访问这些目录时就不需要再去实际的文件系统中加载目录信息,可以直接从缓存中获取,这样可以大大减少对文件系统的访问,提高性能。 文件系统目录缓存会缓存诸如: 目录结构:将整个目录树缓存在内存中,包括子目录,文件等信息。 目录元数据:每个目录的元数据,如inode号,大小,权限,所有者等信息。 文件元数据:每个文件的元数据,如inode号,大小,权限,所有者等信息。 权限信息:已检查过的目录和文件的权限信息,避免重复检查。 签名信息:目录和文件的签名,用于加速查找。 通过缓存这些信息,应用程序可以避免大量的文件系统访问,直接从缓存中获取需要的信息,从而提高性能。这对文件系统的操作密集型应用程序有很大帮助,如邮件服务器,数据库等。 所以,文件系统目录缓存的关键是通过缓存来减少文件系统访问,在应用程序与文件系统之间添加一层缓存,提高整体的目录操作性能。这是操作系统在管理文件系统与提高性能方面常用的一种技术手段。 应用程序经常需要遍历文件系统目录树来进行文件系统操作,如打开文件或读取文件元数据。这需要频繁访问文件系统,对操作系统内核的性能有很大影响。 因此,在内存中缓存文件系统目录结构和元数据信息可以显著优化操作系统内核的性能。这是因为应用程序可以直接从缓存中获取信息,避免访问文件系统。 本文提出了一些目录缓存的设计原则,可以在应用程序和文件系统之间transparently提高命中率和降低未命中成本。transparently意味着应用程序不需要改变代码,缓存的使用对其透明。 目录缓存设计使用散列表在恒定次数的操作中查找目录,可以加速目录查找。散列表是一种高效的数据结构,可以在固定次数内查找到信息。 将查找路径和权限检查分离,意思是首先查找目录,然后再进行权限检查。这避免了在权限检查时重复查找目录,提高性能。 对访问控制检查的结果进行记忆化,意思是缓存文件或目录的权限信息,避免下次再检查,提高性能。 使用签名加速查找,使用目录文件签名(如CRC码)进行查找,避免字符串比对,加速查找。 通过缓存目录完整性降低未命中率,意思是缓存整个目录树信息,使应用程序可以在缓存中完成大部分操作,避免访问文件系统,减少未命中。 该设计可以符合各种要求,如POSIX、Linux安全模块、命名空间和装入别名等,所以可以广泛使用。 该设计对实际应用程序有明显改进,可以提高Dovecot IMAP服务器12%的吞吐量,updatedb工具29%的吞吐量,展示了该方案的优异性能。 Introduction操作系统内核通常在虚拟文件系统(VFS)层中缓存文件系统数据和元数据,该层将底层文件系统抽象为常见API(如POSIX)。 指Linux内核。VFS是Linux内核中的一层,它虚拟化了底层的文件系统,如ext4、xfs等。VFS层会缓存从这些底层文件系统读取的数据和元数据(如文件属性)。VFS层对上层应用程序来说隐藏了底层文件系统的细节,它提供了常用的文件系统API,如POSIX接口。这使得应用程序可以通过VFS层访问底层不同的文件系统,而不需要关心它们的差异。 计算机底层的指令系统是不同的,如x86和ARM架构的指令系统不同。但我们编程时使用的指令是一致的,如加法指令都是+,这是因为编程语言将底层不同的指令系统虚拟化成一致的指令接口。程序员使用这一接口,不需要关心底层指令的差异。 同样,虚拟机将不同的物理计算机虚拟化成同一逻辑计算机,从而运行相同的操作系统和应用程序。虚拟机屏蔽了底层不同的物理机,为最终用户提供了统一的计算机接口。 所以,总结来说,虚拟化通过抽象和隐藏底层的差异与实现细节,提供了更高层的统一逻辑接口。这使得高层用户(如应用程序或最终用户)无需关心底层的异构与复杂性,可以更简单地使用接口所提供的功能。 VFS层虚拟化文件系统,就是采取这样的方式,将不同的文件系统抽象成统一的文件系统接口,屏蔽底层文件系统之间的差异,为应用程序和用户提供简单的文件系统操作方法。这有效地隔离了上层的Linux内核与应用程序与底层具体的文件系统实现。 POSIX定义了一套统一的操作系统接口标准,包括API、系统调用、实用程序等,使得应用程序可以在不同的操作系统上移植和运行。Linux等操作系统都实现了POSIX接口,使得Linux下的应用程序可以很容易在其他POSIX兼容系统中使用。 VFS层提供的POSIX接口,就是遵循POSIX标准,实现了诸如open、read、fork等操作系统调用和API,从而屏蔽了底层文件的系统差异,使应用程序可以直接使用POSIX接口访问各种文件系统。 缓存层已经成为隐藏持久存储技术(如本地磁盘)访问延迟的普遍优化手段。目录缓存不仅仅是性能优化;它还简化了安装多个文件系统、一致的文件句柄行为和高级安全模型(如SELinux)的实现。 缓存层指的是在系统设计中加入的缓存机制,用于暂存数据或计算结果,从而优化性能。在这里,缓存层特指操作系统在虚拟文件系统(VFS)与具体文件系统之间加入的目录缓存机制。目录缓存缓存了文件系统的目录结构、元数据与访问信息,使VFS层可以直接从缓存中获取这些信息,减少对底层文件系统的访问,优化整体的文件系统性能。 目录缓存可以简化在一个系统上安装和使用多个文件系统。因为目录缓存抽象了底层文件系统的差异,使上层可以以同一方式访问不同的文件系统。 文件句柄是应用程序访问文件时使用的一个抽象接口。通过目录缓存,应用程序可以使用相同的文件句柄接口访问不同的文件系统,而不需要关心底层文件系统的差异与实现细节。 文件句柄是应用程序访问文件时使用的一个抽象表示。应用程序可以通过文件名打开一个文件,获取代表该文件的文件句柄,然后使用文件句柄对文件进行各种操作,如读写等,而不再指定文件名。 举个例子,在C语言中,应用程序可以通过fopen()函数使用文件名打开一个文件,获取FILE类型的文件句柄: 1FILE *fp = fopen(&quot;file.txt&quot;, &quot;r&quot;); 然后应用程序可以通过文件句柄fp对文件进行操作: 123fread(buf, 1, 10, fp); // 从文件读取10个字节fwrite(buf, 1, 10, fp); // 向文件写入10个字节fclose(fp); // 关闭文件 在这里,FILE *fp就是文件file.txt的文件句柄,应用程序通过它对文件进行访问,而不再指定文件名。 所以,文件句柄的作用是: 将文件在应用程序中的表示抽象化,屏蔽了底层文件的实现细节与差异。 使应用程序可以通过统一的文件句柄接口访问不同的文件,而不需要关心每种文件对应的实现方法。 方便应用程序通过文件句柄快速访问文件,而不需要反复指定文件名。 返回到这句话,它表达的意思是:通过目录缓存,应用程序可以使用同样的文件句柄接口访问不同种类的文件系统,而不需要关心底层文件系统的差异。这是因为目录缓存抽象了底层文件系统的细节,为应用程序提供了统一的文件访问接口。 目录缓存对良好的应用程序性能至关重要。许多常见的系统调用必须对文件路径进行操作,这需要目录缓存查找。例如,iBench系统调用跟踪中的10-20%的系统调用执行路径查找。 许多系统调用，如：open\\stat\\unlink等都需要使用文件的路径作为参数。这些系统调用在执行时,需要查找目录以定位文件,这需要目录缓存的支持。有10-20%的系统调用会执行路径查找。 图1列出了几种常见的命令行应用程序在执行基于路径的系统调用时花费的总执行时间的百分比(有关这些应用程序和测试机器的更多详细信息,请参阅§6)。我们注意到,这些系统调用包括路径查找以外的工作,这些数字包括一些检测开销;尽管如此,除rm外,系统调用时间和计数以stat和open为主,其中路径查找是执行时间的重要组成部分。对于这些应用程序,基于路径的系统调用占总执行时间的6-54%。这意味着降低路径查找延迟是内核提高这些应用程序执行时间的最大机会之一。 不幸的是,即使目录缓存命中也是昂贵的——我们的测试Linux系统上的stat为 0.3-1.1微秒,相比之下getppid只有0.04微秒,4 KB预读只有0.3微秒。这个问题在Linux内核社区尤其受到重视,该社区对其目录缓存进行了重大修订和越来越复杂的优化,以降低其命中成本,例如从读取路径中删除锁或在重试循环中用死锁避免替换锁定顺序。图2 plotting目录缓存命中延迟与Linux几个版本中更改的目录缓存代码行数,使用测试系统上的路径到inode查找微基准。这些努力已将命中延迟从2011年到2013年提高了47%,但在过去三年中已停滞不前。 问题的根源似乎是POSIX路径权限语义要求与路径组件数量线性相关的工作,并严重限制内核开发人员的实现选项。例如,要打开&#x2F;X&#x2F;Y&#x2F;Z文件,必须对父目录&#x2F;、&#x2F;X和&#x2F;X&#x2F;Y有搜索权限,并且有权访问文件Z。Linux实现简单地从上至下遍历目录树以检查权限。不幸的是,当关键路径以指针为基础的数据结构(在某些体系结构上包含多核一致性的内存屏障)主导时,现代CPU最终由难以预取加载而停滞。此外,由于如此多的Linux功能是建立在此行为之上的,例如Linux 安全模块(LSM)、命名空间和安装别名,所以如果不破坏与其他Linux内核功能的后向兼容性,任何数据结构增强似乎都是不可能的。在理论上,不明显是否有更快的查找算法(如单一散列表查找)可以满足这些API规范和内核内部要求;据我们所知,以前没有人尝试过。 本文提出了目录缓存的一种分解,可以使大多数查找操作用单个散列表查找执行(§3),以及基于缓存中已有但未有效利用的信息优化以减少未命中率的优化(§5)。我们的设计通过几个关键性见解维持兼容性(§4),包括如何将路径索引与检查父权限分离,以及如何有效和安全地记忆访问控制检查的结果。 一种将目录缓存分解的方案,能使用散列表提高大多数查找的性能。 基于目录缓存中未充分利用的信息,提出的一些优化方法,以减少未命中率。 通过保持与Linux内核兼容性的几个关键设计,实现以上提高性能和减少未命中率的方案。这些关键设计包括分离路径索引和父目录权限检查、安全有效地缓存访问控制检查结果等。 作者认为,这种设计可以大幅提高目录缓存性能,解决目前Linux内核目录缓存的性能问题。 我们的优化提高了频繁查找操作的性能,但引入了几个成本,详见§3和§6,我们认为这些成本是可以接受的,并且对应用程序而言是一个净改进。 首先,这些优化会减慢对目录层次结构的不频繁修改,如目录的重命名、chmod和chown。然而,这些较慢的操作在iBench跟踪中占系统调用的不到0.01%。 其次,dcache的内存开销增加。 第三,查找由于签名冲突而有错误的可能性,可以调整为可以忽略不计且处于数据重复数据删除系统广泛使用的可接受阈值内。 在图2的微基准测试中,我们的目录缓存优化提高了lookup延迟26%,超过未修改的Linux。 本文证明这些技术可以提高频繁使用目录缓存的应用程序的性能,而对于不受益的应用程序的危害则很小。这些变化封装在VFS中——单个文件系统不必更改其代码。本文描述了在Linux 3.14中实现这些改进的原型。第2节解释了Mac OS X、FreeBSD和Solaris的目录缓存结构相当相似,这些原理应该具有普遍性。 本文的贡献如下: 对路径查找成本和改进缓存命中延迟机会的性能分析。 目录缓存设计,通过如下技术改进路径查找延迟: 按完整路径索引目录缓存,将平均情况下的查找从路径组件数量的线性减少到常量。 前缀检查缓存(PCC),将权限检查与路径缓存分离。PCC记忆权限检查,与LSM兼容。 使用路径签名减少检查散列桶冲突的成本。 识别利用内核已经拥有的元数据减少未命中率的机会,如跟踪目录是否完全在缓存中。 仔细处理许多微妙的边缘情况,这些情况会阻碍这些技术的机械应用,例如与符号链接和Linux命名空间的集成。 这些优化的全面评估。例如,我们的优化提高了Dovecot IMAP服务器的吞吐量最高达12%,updatedb的延迟最高达29%。 Background本节首先回顾目录缓存必须支持的Unix目录语义;然后解释了目录缓存是如何在现代操作系统中实现的，包括Linux、FreeBSD、Solaris、Mac OS X和Windows。 Unix Directory Hierarchy Semantics目录缓存执行的最常见操作是查找，它将路径字符串映射到内存中的索引节点结构。查找由所有基于路径的系统调用调用，包括open、stat和unlink。查找包括检查用户是否具有从进程的根目录或当前工作目录到文件的适当搜索权限，我们称之为前缀检查(prefix check)。 例如，为了让Alice读取/home/ Alice / x，她必须具有目录/、/home和/home/ Alice的搜索权限，以及文件x的读权限。为了节约起见，目录上的执行权限位编码了搜索权限。**搜索与读权限的不同之处在于，搜索只允许用户查询文件是否存在，但不能枚举文件的内容(暴力破解除外)**。SELinux和其他经过安全加固的Linux变体可以根据执行位之外的许多因素确定搜索权限，例如进程的角色或目录的扩展属性。 Linux Directory CacheLinux目录缓存(dcache)缓存dentry(目录条目)结构，它将路径映射到文件(或目录、设备等)的内存inode(其他Unix系统将索引节点的vfs级表示称为vnode)。inode存储与文件相关的元数据，如大小、权限和所有权，以及指向索引内存文件内容的基数树的指针。每个dentry至少由四个不同的结构跟踪: 分层树结构，其中每个父节点都有一个未排序的、双链的子节点列表。 一个哈希表，以父节点虚拟地址和文件名为键。 别名列表，跟踪与给定索引节点相关联的硬链接。 LRU列表，用于根据需要压缩缓存。 Linux将前缀检查与查找本身集成在一起，一次搜索一个组件的路径和检查权限。lookup不是直接使用树结构，而是使用散列表搜索每个组件。对于较大的目录，哈希表查找将比搜索未排序的子列表快。分层树结构的主要用途是自底向上驱逐条目，以维护隐式不变性，即任何条目的所有父条目也必须在缓存中。尽管所有dentry都存储在按路径键的哈希表中，但权限检查实现在哈希表中查找每个路径组件。 Linux存储负dentry(negative dentries)，它缓存已知文件不存在于磁盘上的事实。负dentries的一个常见示例是在由环境变量指定的多个路径上搜索文件，例如LD LIBRARY PATH。 Current dcache optimizations 图2所示的大部分dcache优化工作都改善了缓存命中延迟，主要是通过减少使用读-复制更新(RCU)的查找函数中的同步成本。 RCU消除了读操作所需要的原子指令。其他Unix系统将索引节点的vfs级表示称为vnode。 锁定和对单个dentry进行引用计数，将一些额外的工作推到不经常修改目录结构的代码上，例如重命名和取消链接。 最新的Linux内核在检查路径权限时也使用乐观同步，使用序列锁(本质上是版本计数器)来检测子树何时可能与遍历同时发生更改。如果乐观快速路径由于并发修改而失败，内核将返回到使用父节点和子节点交替锁定的慢路径。 由于Linux开发人员社区已经在优化其dcache方面投入了大量精力，因此我们在本文中使用Linux作为案例研究。本文中的优化不是特定于linux的，但在某些情况下，构建在其他内核可以采用的优化之上。 Other Operating SystemsFreeBSD, OS X, and Solaris.这些Unix变体都有一个目录缓存，其结构类似于Linux的[25,28,39]。每个系统都使用散列表组织其目录缓存，每次检查一个组件的路径，并存储负条目。在这里，我们使用FreeBSD作为BSD家族的一个代表性例子，根据最近的调查，它是最受欢迎的。OS X内核采用了FreeBSD的文件系统，并没有实质性地改变它们在目录元数据缓存方面的行为。 Linux的独特之处在于，hit路径避免调用低级文件系统，而其他Unix变体总是调用低级文件系统。低级文件系统可以选择退出默认结构，如果它有更专门的结构，比如大型目录，或者它可以直接实现自己的查找函数。直接管理文件系统的缓存部分是有问题的，因为对低级文件系统不可见挂载点。之前的一些研究发现这种限制很麻烦，特别是对于网络文件系统。这些Unix变体也没有在缓存中使用乐观同步，但这不是基本的。 Solaris dcache，称为直接名称查找缓存(DNLC)，具有复杂的缓存管理启发式，例如在替换决策中权衡相关性和时间局域性Solaris也有一个比FreeBSD更简单的缓存路径参考管理系统(更类似于Linux)。 WindowsWindows中的几乎所有的操作系统API抽象都由对象管理器表示。对象管理器是最接近Unix目录缓存的类比,它跟踪层次路径和权限。不幸的是,Windows内部结构的公开文档有限,尤其是对于未被动用的元数据的内部数据结构和缓存策略,所以详细比较困难。尽管如此,我们可以比较一些高级设计选择的影响。 首先,Windows只支持一种根文件系统格式,和非常有限的其他文件系统。因此,对文件系统元数据的一般目的的内存组织没有太大价值,Windows没有vnodes,dentries或其他VFS层面的概括。相反,缓存主要是文件系统的责任,磁盘和内存结构布局可能相同。 与Unix变种不同,当Windows文件系统路径没有缓存在对象管理器中时,底层文件系统负责解析完整路径,而不是一次解析一个组件。为此,Windows NT也将父目录权限传播到每个子目录的磁盘元数据,在创建或修改时间。这种方法可以直接查找,但也会产生一点易管理性问题。假设Alice使她的主目录对所有人可读:这个更改是否应传播到所有子目录?为了回答这个问题,Windows采用一个错误易发生的启发法,不改变手动修改的子权限。本文展示如何在内存中保留直接查找的性能优势,而不存储传播的分层权限在磁盘上产生的管理性问题。 Opportunities for Improvement图3显示了Linux中路径查找的主要组件所花费的时间，其中四个路径的长度不断增加。 对查找时间的第一阶影响是路径本身的长度，它决定了对每个组件进行哈希、在哈希表中查找以及对每个目录的索引节点执行权限检查的次数。这些成本在路径组件的数量上是线性的。 本文中描述的命中延迟优化使大多数这些操作的时间不变，除了散列，它仍然是路径长度的函数。 Minimizing Hit Latency本节描述dcache命中路径的算法改进。在缓存命中情况下,最昂贵的操作之一是检查进程的凭据是否允许进程从上到下搜索dentry路径(称为前缀检查prefix check)。本节展示了如何通过缓存前缀检查结果显着降低命中延迟。本节解释了优化方案,如何将其集成到现有的Linux目录缓存框架中,如何使这些缓存结果与其他文件系统操作保持一致,以及如何使用路径签名进一步加速查找。 Caching Prefix Checks像许多Unix变体一样，Linux在哈希表中存储缓存的路径到索引节点映射(dentry)(§2.2)。这个散列表由父条目的虚拟地址和下一个路径组件字符串的组合作为键值，如图4所示。内核对象的虚拟地址不会随着时间的推移而改变，并且在各个进程之间是相同的。 在实践中，前缀检查具有高度的空间和时间局部性，非常适合缓存，即使这意味着将一些额外的工作推到不经常修改的目录结构上(例如，重命名目录)。RCU已经做了这个权衡(§2.2)。 为了缓存前缀检查结果，我们必须首先将查找dentry与前缀检查解耦。我们添加了第二个系统范围的哈希表，专门用于查找dentry，称为直接查找哈希表(DLHT)。DLHT存储最近访问的按完整的、规范化的路径散列的dentry。dentry通常存在于主哈希表中，也可能存在于DLHT中。DLHT是惰性填充的，为了与目录树修改保持一致，条目可以被删除(§3.2)。 每个进程在与进程凭据(在4.1节中进一步讨论)关联的前缀检查缓存(PCC)中缓存以前前缀检查的结果,可以在具有相同权限的进程之间共享。PCC是一个散列表,缓存dentry虚拟地址和版本号(序列锁),用于检测陈旧条目(3.2节)。当前缀检查通过时,表示凭据被允许访问dentry,则将条目添加到PCC;根据LRU策略替换条目。PCC中的未命中可以表示权限被拒绝或权限检查最近未执行。 因此，给定任何路径，内核都有一个直接查找DLHT中的路径的快速路径。如果快速路径在DLHT中命中，则在进程的PCC中查找该齿列。 如果找到PCC条目并且版本计数器与缓存的计数器匹配，则使用缓存的前缀检查结果。 如果DLHT或PCC中的快速路径查找丢失，或者PCC条目中的版本计数器比dentry更老，则代码将返回到原始的Linux查找算法(慢路径)，只使用主哈希表并一次遍历一个组件。 在相对路径的情况下，例如目录/home/alice下的foo/bar，我们有效地将相对路径和当前工作目录的路径连接起来。为了实现相对路径，Linux已经在每个进程描述符(任务结构)中存储了一个指向当前工作目录条目的指针。我们没有对字符串进行记忆，而是在每个条目中存储哈希函数的中间状态，以便可以从任何前缀恢复哈希。 当前的设计包括两种非常罕见的边缘情况。首先，可以释放dentry并使用陈旧的PCC条目重新分配。我们通过使用单调递增的版本号初始化新分配的dentry来检测这种情况，允许PCC条目在重新分配时检测过时。释放一个牙齿将它从DLHT中移除。其次，版本号可以在新条目或重命名、chmod或非空目录的城镇的每2^32次初始化之后环绕;我们的设计目前通过使所有活动的pcc无效来处理封装。 图5说明了对Linux dentry结构的修改。快速dentry存储签名、标志、序列计数、挂载点、用于管理深度目录条目的列表(第5.2节)，以及用于将快速dentry添加到DLHT bucket的列表(哈希链)。PCC被添加到内核凭据结构(struct cred)中，并存储一个可调数量的由指针和序列号组成的元组;用64kb的PCC对系统进行评估。由于每个dentry指针的最高位和最低位是相同的，PCC只存储唯一的指针位(x86 64 Linux中的8-39位)以节省空间。 Coherence with Permission and Path Changes当目录或目录结构的权限被更改时(例如使用chmod或rename)，任何包含该目录的缓存前缀检查都必须无效。 我们的设计通过在更改层次结构之前使相关的PCC和DLHT条目失效，防止过时的慢路径查找被重新缓存，并利用vfs级同步来确保正确的慢路径行为，从而确保并发查找和更改的安全性。 首先，我们确保在更改目录结构后，快速路径查找不能使用陈旧的数据完成。 在发生突变(如重命名或chmod)之前，操作必须递归遍历dcache中的所有子节点，并增加fast_dentry版本计数器(seq)。 每个进程的PCC使用fast_dentry版本计数器来检测查找时缓存前缀检查的变化;增加此版本计数器将使该条目的所有PCC项无效，而无需直接修改每个PCC。对目录结构的更改(例如，mount和rename)也会从直接查找哈希表(DLHT)中删除新旧路径下的dentry。PCC和DLHT表项在慢路径上缓慢地重新填充。 其次，通过使用原子的全局序列计数器(invalidation)，我们确保不能将过时的慢路径查找的结果重新添加到DLHT或PCC中。在慢路径遍历之前和之后读取序列计数器;只有当计数器没有改变时，结果才被添加到DLHT和PCC中，这意味着没有并发关机。 第三，我们使用vfs级同步来确保慢路径与突变正确同步。例如，rename获取全局重命名锁序列锁，以及新旧父目录上的每个条目锁。当使用重命名锁进行写操作时，慢路径(即当前Linux代码)上的所有查找都必须以一种从根目录(或当前工作目录，对于相对路径)到目标子目录的交替方式锁定每个条目。在重命名完成之前，目标条目上的锁会阻止交替遍历。无效计数器防止缓存在获取dentry锁之前已经通过此点的慢路径查找的结果。我们的实现遵循VFS现有的锁定原则来避免死锁;它添加了版本计数器来检测不一致性，并退回到慢路径。 因此，相关的PCC和DLHT条目在重命名开始之前就已经失效了，阻断了快速路径； 慢速路径的遍历将被阻止，直到重命名完成和每个条目的锁被释放；并且一个序列计数器 序列计数器确保只有观察到新路径的慢速路径遍历可以重新填充DLR的 路径可以重新填充DLHT和PCC。这些递归的遍历将目录权限和结构的变化从恒定的时间转变为与子树的大小成线性关系。子树的大小。作为一个例子，重命名或chmod一个有10,000个子目录，最多深度为4的目录需要大约需要330微秒来完成。在最初的Linux内核中，重命名和chmod几乎是恒定时间操作，只需要4.5和1.1微秒。一些应用程序，如aptitude或rsync，依靠rename来原子化地替换一个目录，但这只占其总工作的一小部分，而且比查找的频率低几个数量级，这使得总体上是一个很好的权衡。 Directory References Unix的语义允许人们cd进入一个目录，并在随后的权限改变后继续在该目录中工作，否则将禁止进一步访问。例如，假设一个进程在工作目录&#x2F;foo&#x2F;bar中，foo的权限发生了变化，使得该进程在未来不能进入bar。只要该进程不离开该目录或退出，该进程就应该能够继续打开bar下的文件。类似的语义也适用于打开的目录柄。在我们的设计中，这样的权限变化最终会导致一个被封锁的PCC条目，而快速路径查询将违反预期行为。我们的设计通过检查 打开的引用在PCC中是否仍然被允许。如果PCC有一个 更多的条目，将阻止重新打开这个句柄、查询将被强制采用慢速路径，并且这个陈旧的结果不会被添加到PCC中。结果不会被添加到PCC中。 Accelerating Lookuos with Signatures我们优化的查找使用240位签名来最小化密钥比较的成本。Linux通过链接在哈希表中查找dentry。当哈希表键是一个相对较短的路径组件时，简单地比较键的成本是可以接受的。但是，Linux上的完整路径最多可以有4,096个字符，即使比较中等长度的字符串也会损害直接查找的算法优势。我们可以通过创建路径的签名来避免这个开销，这样可以最小化键比较的开销。 使用签名会带来冲突的风险，这可能导致系统将路径映射到错误的入口。 我们首先解释签名碰撞如何在我们的设计中导致问题，然后解释所需的抗碰撞属性，最后解释我们如何选择签名大小以使这种风险最小化。 Signature collisions 当用户查找路径时，我们的设计首先计算规范化路径的签名，在全局DLHT中查找散列，如果DLHT中有命中，则在每个凭据PCC中查找dentry和序列号。 如果具有相同签名的另一个文件的dentry已经在DLHT中，并且该dentry在PCC中，则用户可能打开错误的文件。例如，如果Alice打开了带有X签名的文件/home/alice/foo，然后打开了同样带有X签名的文件/home/alice/bar，她的第二次打开实际上会创建一个文件foo的句柄。这就产生了一种担忧，即用户可能会由于自己的过错而损坏自己的文件。可以根据签名大小将此风险配置为非常小(下面将讨论)。 任何不正确的查找结果必须是进程(或具有相同凭据的另一个进程)有权访问的文件。要使快速路径查找返回任何内容，必须在任务的PCC中有匹配的dentry指针，该PCC对于具有相同凭据的任务是私有的。因此，碰撞不会导致Alice意外打开属于Bob的完全不相关的文件，否则她无法访问这些文件。 我们的设计正确地处理了两个用户使用相同签名访问不同文件的情况，因为PCC中的错误将导致两个用户都退回到慢路径。 假设Bob开了foo，它和Alice的酒吧相撞了。当Alice打开bar时，它的签名将在DLHT中匹配，但在PCC中会丢失。这将导致Alice的查找以慢路径重新执行前缀检查，最终打开正确的文件并将此条目添加到她的PCC中。 因此，如果Bob是对抗性的，他就不能通过改变缓存内部状态导致Alice打开错误的文件。 我们在启动时为签名哈希函数选择一个随机密钥，以降低确定性错误或离线冲突生成的风险，因为人们可能会使用这些错误来攻击基于用户输入打开文件的应用程序，例如web服务器。因此，相同的路径不会跨重启或相同内核的实例生成相同的签名。 尽管采取了所有这些措施，但对于以root身份运行的应用程序来说，这种风险仍然是不可接受的，因为它可以打开任何文件，特别是那些接受来自不受信任用户的输入的文件。 例如，假设恶意用户识别了一个与密码数据库具有相同签名的路径。该用户可以将此路径传递给setuid-root实用程序，并欺骗setuid实用程序覆盖密码数据库。通过不允许对特权二进制文件或对安全敏感的路径名进行基于签名的查找加速，可以消除这种风险，尽管这在我们的原型中没有实现。 Collision Resistance Requirement 我们设计的安全性取决于对手只能通过蛮力找到碰撞。我们的设计可以使用2通用哈希函数或伪随机函数族(PRF)来生成路径签名。在抗碰撞方面，2-universal hash散列和PRF之间的区别在于，攻击者可以通过观察2-universal hash函数的输出来学习密钥，但不能从PRF的输出中学习密钥。因为我们的dcache设计不向用户显示签名，只显示两条路径是否有签名冲突，所以任何一个族的散列函数都足够了。 需要注意的是，使用双通用哈希函数时，必须小心计时和其他侧通道不会泄漏签名。例如，不能同时使用签名中的位来索引哈希表，因为可能会通过测量在给定哈希桶上遍历链的时间来了解签名的位。在我们选择的函数中，可以安全地使用256位哈希输出中的较低位，因为在我们的特定算法中，较低位不受较高位值的影响;因此，我们使用16位哈希表索引和240位签名。相反，当使用PRF生成签名时，可以避免从侧通道学习签名的问题。 我们的设计使用了2-universal multilinear hash函数。我们使用基于AES-NI硬件的prf做了几个实验，但没有找到一个足够快的函数来改进基线Linux。使用当前的128位AES硬件，我们可以提高4个或更多路径组件的性能，但是创建256位PRF需要更复杂的构造，这太昂贵了。更谨慎的实现可能更倾向于使用PRF，以避免任何被忽略的侧通道风险，特别是如果在未来几代硬件中可以使用快速的256位PRF。 Probability of a signature collision 我们选择了一个240位的签名，它与重复数据删除系统中使用的签名大小相当，范围从128位到256位。 重复数据删除设计通常选择一个签名大小，该签名大小引入的冲突风险大大小于未检测到的ECC RAM错误的风险。 我们假设对手正在用蛮力寻找碰撞。攻击者必须查找系统上的路径，例如通过打开本地文件或查询web服务器上的路径。因为我们的哈希函数是用一个随机值作为键的，并且输出对用户是隐藏的，所以攻击者只能在目标系统上搜索冲突。因此，攻击者受到系统上的查找速率以及目标系统在缓存中保存多个签名以供比较的能力的限制。 我们计算碰撞风险变得不可忽略(即高于2^-128)的预期时间，并对碰撞风险建模如下。首先，|H(X)| &#x3D; 2^240是可能的签名数。我们将缓存限制为n &#x3D; 2^35个条目(即，假设RAM中的dcache空间为10TB，每个条目为320字节)，并采用LRU替换策略。我们计算碰撞风险大于P &#x3D; 2^−128的查询次数(q)如下: 以每秒1000亿次的查找速度(目前的核每秒可以查找大约300万次)，强力碰撞的概率超过2^-128的预期时间是4.8万年 Generalizing the Fast Path到目前为止，我们已经使用相对简单的规范路径名解释了快速路径优化。 本节解释如何将这些优化与Linux的高级安全模块集成，以及如何处理Unix路径语义中的一些边缘情况，例如挂载选项、挂载别名和符号链接。 Generalizing CredentialsLinux包括一个可扩展的安全模块框架(LSMs)， SELinux、AppArmor等都是在此基础上构建的。LSM可以覆盖搜索权限检查的实现，检查目录层次结构或进程的自定义属性。因此，即使LSM覆盖了默认的访问控制规则，我们的dcache优化也必须能够正常工作。 我们的方法利用了Linux中的credit结构，该结构旨在存储进程(任务结构)的凭据，并具有几个有用的属性。首先，信用结构是全面的，包括影响默认权限的所有变量，并包括LSM存储元数据的不透明安全指针。其次，信用是写时复制(copy-on-write, COW)，因此当进程更改其凭据时，例如通过执行setuid二进制文件或更改SELinux中的角色，信用将被复制。我们手动检查了AppArmor和SELinux对私有元数据的更改是否遵守COW约定。此外，在常见情况下，一个信用可以被进程共享，例如一个shell脚本分支子进程具有相同的信用。 因此，cred结构满足了我们的大部分需求，只有一些变化，我们将在下面解释。 我们在每个信用结构中存储缓存的前缀检查(§3.1)，将前缀检查结果与不可变凭证耦合在一起。使用空PCC初始化新的信用结构。当更多进程共享PCC时，它们可以进一步减少慢路径查找的数量。 一个挑战是，即使凭证没有更改，Linux也经常分配新的信用结构。潜在的问题是，COW行为不是在页表中实现的，而是在可能修改信用的代码中按照约定实现的。在许多情况下，例如在exec中，只需提前分配另一个信用，而不是确定凭据是否将被更改，这要简单得多。这种自由分配新凭据的方式造成了在具有相同凭据的子进程之间重用前缀缓存项的问题。为了缓解这个问题，我们等待，直到一个新的信用被应用到一个进程(提交信用())。如果信用的内容没有改变，旧的信用和PCC被重用和共享。 我们的信用方法记忆了不同lsm的复杂和可能任意的权限评估函数。 Non-Canonical Paths and Symbolic Links我们的优化哈希表是以全路径为键。然而，用户可以指定一个路径的变体，例如/X/Y/./Z代表/X/Y/Z。简单的变化在散列过程中很容易被规范化。一个更复杂的情况是，如果&#x2F;X&#x2F;L是一个符号链接，路径/X/L/.../Y可以映射到&#x2F;X&#x2F;Y以外的路径。同样，如果用户没有搜索/X/Z的权限，即使用户有搜索/X/Y的权限，对/X/Z/.../Y的查询也应该失败。为了保持与Linux的bug-for-bug兼容，我们的原型在每个点上都会发出一个额外的fastpath查询来检查权限。保持Unix的语义会给非经典的 路径的开销。我们发现使用Plan 9的词法路径语义。Plan 9通过预处理，将网络文件 通过对/X/L/.../Y这样的路径进行预处理，将网络文件系统的查询降到最低。到/X/Y。我们注意到，Plan 9在每次查找组件时都会进行 查询，但没有目录缓存。 Symbollic Links 我们在我们的查询中解决符号链接 我们通过为符号链接创建dentry aliases来解决符号链接。例如 例如，如果路径/X/L是/X/Y的别名，我们的内核会 创建dentries，将/X/L/Z重定向到/X/Y/Z。换句话说，符号链接被视为一种特殊的目录类型、 并可以创建子目录，对翻译进行缓存。 符号链接dentries存储240位的签名，代表目标路径。代表目标路径。PCC是单独检查 为目标目录。如果一个符号链接发生变化，我们必须 无效所有的后继别名，类似于目录重命名的无效化。目录重命名(rename)。这种重定向可以无缝地处理 的情况，即在翻译的路径上发生权限变化 路径上的权限变化，或者被引用的目录被删除以回收空间。 Mount Point我们的快速路径处理由挂载点引入的几个微妙的边缘情况。 Mount options 挂载选项(如read-only或nosuid)会影响文件访问权限检查。Linux dcache通常将挂载点作为分层文件系统遍历的一部分，并内联检查与权限相关的挂载标志。一旦消除了这种自上而下的行走，我们需要能够识别任何给定牙齿的当前挂载点。目前我们为每个dentry添加了一个指针，尽管可能有更节省空间的选项。 Mount Aliases 一些伪文件系统，如proc、dev和sysfs，可以在多个位置挂载相同的实例。chroot环境使用该特性，并在引导期间移动这些文件系统。绑定挂载还可以创建挂载别名。 在我们的系统中，一个dentry只存储一个签名，并且一次只能通过一个路径在直接查找哈希表中。我们目前的设计只是选择最近的优化位置。如果慢路径遍历注意到匹配的dentry(按路径)有不同的签名，在别名挂载下，并且已经在DLHT中，那么慢路径将替换签名，增加dentry版本计数，并更新指向该dentry挂载点的指针。 如果别名路径有不同的前缀检查结果，则需要增加版本计数。这种方法确保了所有情况下的正确性，并且对于任何挂载别名的入口，在最近使用的路径上都具有良好的性能。 Mount Namespaces Linux中的挂载namespace允许进程创建私有挂载点，包括chroot环境，这些挂载点仅对进程及其后代可见。当进程创建一个新的挂载namespace时，它还分配一个新的、namespace-private的直接查找哈希表。slowpath总是包含任何挂载重定向，并且任何新的签名到dentry映射在名称空间中都是正确的。因此，名称空间内部的相同路径(和签名)将映射到不同于名称空间外部的dentry。类似地，前缀检查缓存(PCC)在名称空间中始终是私有的。 与挂载别名(Mount Aliases)一样，我们一次只允许一个dentry存在于一个直接查找哈希表上。这有利于局部性，并且当重命名的目录跨多个namespace共享时，使无效任务易于处理。用于目录树修改的无效代码只是将每个子条目从当前存储的DLHT中移除 Network File Systems 我们的原型不支持在网络文件系统上直接查找，例如NFS版本2和3。为了在无状态协议上实现从近到开的一致性，客户端必须在服务器上重新验证所有路径组件——有效地强制缓存丢失，并使命中路径的任何好处无效。我们期望这些优化可以使具有目录修改回调的有状态协议受益，例如AFS或NFS 4.1。 Summary本节演示我们的目录缓存优化如何支持Linux在目录缓存上构建的各种特性，包括名称空间、增强的安全模块和符号链接。我们的原型主要集中在Linux上，可以说Linux的特性与目录缓存交织在一起，但是我们相信这些优化在其他系统上也可以工作，只需要适当的移植工作。 我们的设计有以下要求，我们期望任何posix兼容的目录缓存都能满足这些要求。 首先，POSIX权限语义要求对从当前根目录或工作目录到文件的路径进行目录访问检查(即前缀检查);我们的实现继承了Linux的不变量，即任何缓存目录的父目录都在缓存中，但是任何可以实现前缀检查的设计都应该足够了。其次，我们要求，如果一个目录的权限改变，有一个程序化的方式来找到所有的后代在缓存中(§3.2)。我们的实现集成了Linux dcache中的乐观同步，以获得良好的性能和一致性，但这种设计可以集成任何合理的同步方案，例如FreeBSD的读&#x2F;写锁。最后，我们利用Linux具有不可变凭证结构的事实(§4.1);适应可变的或不太统一的凭证将需要额外的工作。 Improving the Hit Rate前几节解释了dcache结构的变化如何通过算法改进来降低平均命中延迟。本节将介绍几个可以提高命中率的简单更改。在dcache丢失的情况下，低级文件系统被调用来为系统调用提供服务。在最好的情况下，磁盘上的元数据格式仍在页缓存中，但必须转换为通用格式;在最坏的情况下，请求阻塞在磁盘I&#x2F;O上。虽然并不是每个应用程序都以非常低的命中率大量使用这些情况，但评估显示有几个广泛使用的应用程序从这些优化中受益匪浅。 Caching Directory Completeness尽管Linux dcache跟踪目录的层次结构，但它并不知道目录的内容是全部还是部分在缓存中。假设Alice在本地文件系统上创建了一个新目录X;如果她的下一个系统调用试图创建文件X/Y，则dcache将错过此查找，并询问低级文件系统是否存在X/Y。如果VFS跟踪所有目录内容都在缓存中，则可以避免这种开销。 第二个例子是readdir，它列出目录中的文件，以及它们的inode号和类型，比如普通文件、字符设备、目录或符号链接。在当前的VFS readdir操作中，总是调用底层文件系统，即使整个目录都在缓存中。对于大到无法在用户提供的缓冲区中列出的目录，可以多次调用readdir，将偏移量存储到目录中。为了构造这个清单，底层文件系统必须重新解析和转换磁盘上的格式，并且可能需要将元数据块从磁盘读入缓冲区缓存。因此，readdir通常是一个昂贵的文件系统操作，特别是对于大型目录。 我们注意到，重复列出目录是文件系统中的常见行为。例如，用户或shell脚本可以在一个目录中重复运行ls命令。一些应用程序通过目录内容协调状态，需要频繁和重复的目录列表。例如，maildir是一种流行的电子邮件后端存储格式，它比旧的mbox格式产生更好的性能可伸缩性。maildir将每个收件箱或子文件夹存储为一个目录，每个单独的邮件都是该目录中的一个文件。文件名编码属性，包括标志和读&#x2F;未读状态。如果消息改变了状态，例如通过删除或标记为已读，IMAP服务器服务器将重命名或取消该文件的链接，并重新读取目录以同步邮件列表。类似地，作为单独进程运行的邮件传递代理(MDA)可以并发地将新消息写入目录，这要求IMAP服务器监视目录的更改，并定期重新读取目录的内容。 我们的Linux变体将低级文件系统返回的readdir结果缓存在目录缓存中。如果目录的所有子目录都在缓存中，则用新的DIR COMPLETE标志标记dentry。这个标志是在创建新目录(mkdir)时设置的，或者在一系列readdir系统调用完成时，没有在目录句柄上执行lseek()操作，也没有并发清除任何子目录以回收空间。我们注意到，并发文件的创建或删除与一系列readdir交织在一起，仍然会在缓存中，并产生正确的列表结果。在设置了DIR COMPLETE标志之后，后续的读DIR请求将直接从dentry的子列表中得到服务。一旦目录进入完整状态，只有在从缓存中删除子条目以回收空间时，它才会离开此状态。 这种方法需要注意的一点是，readdir返回通常会出现在inode中的部分信息，但不足以创建完整的inode。对于这些文件或子目录，我们添加不带inode的dentry作为目录的子目录。这些dentry在查找时必须与阴性dentry分开，并与适当的索引节点链接。这种方法允许将readdir结果用于后续查找，干净地与现有的dcache机制集成，并从每个磁盘I&#x2F;O中获得最大可能的用途，而不会引起不必要的I&#x2F;O。 我们注意到Solaris包含一个类似的完整目录缓存模式[25]，但它没有与readdir或查找以外的调用集成，是一个单独的缓存(因此相同的dentry可以存储两次，并且在丢失之前必须检查两个散列表)，并且注释表明它仅对大型目录具有性能价值。我们的结果表明，当适当地集成到目录缓存中时，跟踪完整的目录比以前认为的更有价值。 File Creation 目录完整性缓存还可以避免新文件创建时的强制遗漏。尽管负dentry缓存对于不存在的特定文件的重复查询效果很好，但是当应用程序请求不存在的不同文件时，负dentry的效果就不那么好了。 不可预测查找的一个常见示例来自安全临时文件创建实用程序。在我们的原型中，带有DIR_COMPLETED标志的目录下的缺失被视为发现了negative dentry，从而忽略了这种强制缺失。在我们当前的实现中，该标志只会在已读取或新创建的目录中设置，但其他用于检测频繁的negative dentry缺失和加载目录的启发式方法可能也很有用. Aggressive Negative Cachingnegative dentries缓存磁盘上不存在的路径。本小节确定了几个更积极地使用负检索的机会，其中一些与直接查找协同工作 Renaming and Deletion 当文件被重命名或解除链接时，可以将旧路径转换为negative dentry。 虽然Linux会在取消链接时将缓存的但未使用的dentry转换为negative dentry，但对于仍在使用的文件的重命名和取消链接来说，情况并非如此。我们扩展了这些例程，以便在删除文件后保留负记录，以便以后重用该路径，就像创建锁文件或Emacs的备份(“波浪”)文件一样 Pseudo File Systems 伪文件系统，如proc、sys和dev，不会为搜索到的不存在的路径创建negative dentry。这是一种基于以下观察的简化:磁盘I&#x2F;O永远不会涉及到遗漏。因为我们的快速路径仍然比遗漏快得多，negative dentry甚至对内存中的文件系统也是有益的，可以加速查找不存在的频繁搜索文件。 Deep Negative Dentries 最后，我们扩展了直接查找快速路径(§3)，使其能够创建“深度”负输入。考虑这样一种情况:用户试图打开/X/Y/Z/A，而/X/Y/Z不存在。在慢路径中，查找将在找到第一个缺失的组件时失败，只缓存z的负条目就足够了。然而，对该路径的重复查找将永远不会找到快速路径，因为没有完整路径的条目。 为了在这种情况下使用快速路径，我们允许负面dentries创建负面子节点，以及深层子节点。 换句话说，我们允许negative dentry /X/Y/Z创建子节点A和A/B，它们可以服务于对不存在的路径的重复请求。如果为缓存为负的路径创建文件，并且该文件不是目录，则会从缓存中清除任何负的子文件。 我们还在常规文件下创建深度negative dentry，以捕获返回ENOTDIR而不是ENOENT的查找失败。当将文件名当作目录使用时，就会出现这种查找失败，并且搜索其下的路径。例如，如果/X/Y/Z是一个常规文件，并且用户搜索/X/Y/Z/A, Linux内核将返回ENOTDIR，并且永远不会创建negative dentry。我们用一个deep,ENOTDIR优化这个案例。 Evaluation本节评估我们的目录缓存优化，并试图回答以下问题: 每种优化(查找快速路径、全目录缓存和更激进的negative dentries)对应用程序性能的改善有多大? 采用这些更改有多困难，特别是对于单个文件系统? 评估包括微基准测试，用于测量在最佳情况和最坏情况下与文件系统相关的系统调用的延迟，以及选择实际应用程序，以显示我们的解决方案在实践中可能提高的性能。 所有的实验结果都收集在一台Supermicro超级服务器上，该服务器配备了12核2.40GHz的英特尔Core Xeon CPU、 64GB内存，和一个2TB，7200 RPM的ATA磁盘，格式化为日记式的ext4文件系统，配置为4096 字节块大小。操作系统是Ubuntu 14.04服务器，Linux内核 3.14. 所有的测量结果都是至少6次运行的平均值（对于运行时间较长的实验）；大多数测量是数百或数千次的运行，以确保一致的平均数。表格和图表表明95%的置信区间 用 “+&#x2F;-“列或误差条表示。 File Lookup OptimizationMicro-benchmarks我们使用扩展的LMBench 2.5 UNIX微基准套件来评估系统调用级别的路径查找延迟。图6显示了stat和open具有各种特征的示例路径的延迟，这些特征包括不同的长度、符号链接、父目录(dot dot)和未找到的文件。 我们观察到的主要趋势是，当路径有更多的组件时，我们的优化的相对增益就会增加。 对于单个组件文件，stat获得3%的收益，而open与基线Linux相当。对于更长的路径，增益分别增加到26%和12%。 为了评估最坏的情况，我们包括一组标有 “fastpath miss + slowpath “的条形图，它行使了快速路径代码，但是内核被配置为在PCC中总是miss。这模拟了执行优化的快速路径不成功，然后在缓存中走O(n)慢速路径的全部成本。这种情况下，不会一直错过到低级文件系统。开销通常在12-93%之间，除了路径neg-d。在neg-d的情况下，第一个组件是缺失的，一个组件一个时间的行走会比直接查找更快停止。一般来说，neg-d的情况会通过deep negative dentries来缓解。在实践中，这些开销只有在高速缓存中的强制缺失时才会被观察到，或者由一个表现出极度缺乏定位性的应用来观察。 接下来，我们比较默认Linux父级(“dot dot”)语义与Plan 9的词法语义的成本。对带有父引用的路径强制执行Linux语义导致我们的优化性能比未修改的Linux差大约31%，因为这需要对每个父节点进行额外的查找。另一方面，词法路径语义允许我们继续使用单个查找进行优化，从而将性能提高43-52%。词法路径语义有一个独立的好处，可以减少在未修改的Linux中查找时需要遍历的组件数量。尽管这个差异很大，但是我们的测试应用程序并没有大量使用父目录指针，并且对这个差异并不敏感。 缓存符号链接的分辨率可使路径link-f和link-d的性能分别提高44%和48%。这种改进对链接发生在路径中的位置不敏感，因为link-f和link-d都遍历相同数量的组件(link-d将“LLL”映射到“XXX”)。 对于不存在的文件(negative dentries)，我们看到了与现有路径类似的改进。唯一的例外是路径早期目录下不存在的长路径。我们认为这种情况很少见，因为应用程序通常是自顶向下遍历目录树，而不是跳到一个不存在的目录。在这种情况下(path neg-d)，基线Linux停止处理路径的速度比我们的优化散列整个路径的速度要快，即使缓存deep negative dentries也是如此。尽管如此，deep negative dentries是一个重要的优化:没有它们，path neg-d的状态将比未修改的Linux差113%，open将差43%，而deep negative dentries则慢38%和16%。 Linux还包括*at()系统调用变体，它们在工作目录下操作—通常只使用单个组件。与上面的结果相对应，对于单个路径组件，fstatat()从我们的优化中获益12%，openat()比未修改的Linux快4%。一些应用程序将多个组件名称与*at调用结合使用;在这些情况下，优化的好处与路径长度成正比。 为了评估更新目录权限和改变目录结构的开销，我们测量chmod和重命名的延迟。在我们的解决方案中，影响这些开销的主要因素是缓存中的子目录数量（缓存外的目录子目录不会影响性能）。图7显示了不同深度和目录大小的目录上的chmod和重命名的性能。一般来说，重命名或chmod的成本随着子目录数量的增加而急剧增加，而基线Linux和ext4使这些操作的时间不变。即使有10,000个子目录都在缓存中，最坏的情况下的延迟也在330微秒左右。作为一个参考点，Linux 3.19源树包括51,562个文件和目录。几个Linux文件系统维护者的初步反馈表明 这种交易对于提高查询性能是可以接受的。 Space Overhead 我们的原型将dentry的大小从192字节增加到280字节。我们的设计还引入了大小为64 KB的每个凭据的PCC和第二个全局散列表(DLHT)，其中包括2^16个bucket。由于Linux没有对dcache大小施加任何硬限制(除了在内存压力下的极端情况)，因此很难标准化执行时间来考虑空间成本。在一个典型的系统上，dcache是几十到几百MB;将其增加50%可能在系统总内存的可接受范围内。或者，如果要限制总dcache大小，则会在更快的命中和更少的命中之间进行权衡。我们把这些权衡的探索留给未来的工作。 Scalability 图8显示了当系统上执行更多线程时，在同一路径上执行stat/open操作的延迟。在Linux上，查找的读端已经是线性可伸缩的，我们的优化并没有破坏这一趋势——只是提高了延迟。rename系统调用引入了显著的争用，并且在基线Linux中可伸缩性较差。例如，在我们 Caching Directory Completeness 图9显示了不同目录大小的readdir微基准测试的延迟。缓存readdir结果的能力提高了46-74%的性能。随着目录变大，缓存的帮助越来越大。OpenSolaris的注释表明，这个想法只对UFS中至少有1,024个条目的目录有利。我们的结果表明，即使只有10个子目录也有好处。 图9还显示了在不同大小的目录中创建一个安全的、随机命名的文件的延迟。我们对mkstemp库进行了1-8%的改进。尽管大多数应用程序的执行时间并不被安全文件的创建所支配，但它是许多应用程序的一项常见任务，而且边际成本低。 ApplicationsCommand-Line Applications 当然，应用程序从更快的查找中获得的改进与发出基于路径的系统调用所花费的运行时时间比例以及列出目录的时间数量成正比。我们测量一系列常用应用程序的性能。 在大多数情况下，这些应用程序从这些优化中受益匪浅;在最坏的情况下，性能损害是最小的。我们用于基准测试的应用程序包括: find:在Linux源目录中搜索文件名。 tar xzf:解压并解包Linux源代码。 rm -r:删除Linux源树。 make和make -j12:编译Linux内核。 du -s:在Linux源代码中递归列出目录大小。 updatedb:从一个干净的debootstrap中重建&#x2F;usr中常用搜索文件名的规范路径数据库。 git status和git diff:显示克隆的Linux内核git库的状态和未分级的更改 对于我们测试的每个应用程序，我们在热缓存(表1)和冷缓存(表2)两种情况下评估性能。为了热缓存，我们运行一次实验并放弃第一次运行。对于热缓存测试，我们还提供了每个应用程序的路径特征的统计信息。 也许不足为奇的是，元数据密集型工作负载从我们的优化中获益最多，例如find和updatedb，速度可提高29%。注意，find、updatedb和du只使用*at() api，并且所有路径都是单组件;这些收益可归因于查找和目录完整性缓存的改进。 我们注意到目录搜索工作负载的性能对PCC的大小很敏感;当我们在一个比PCC大两倍的目录树上运行updatedb时，增益从29%下降到16.5%。这是因为在新访问的目录中，越来越多的第一次查找将不得不采用慢路径。 我们的原型有一个静态设置的PCC大小，我们用一个足够大的PCC进行评估，以便在温暖的缓存实验中缓存大多数相关的目录。我们希望一个生产系统能够动态地调整PCC的大小，使其达到最大的工作集；我们将研究一个适当的策略来决定何时增加PCC和驱逐条目的问题留待今后的工作中解决。 我们的命中优化主要改进的应用程序是git，它显示了4-9.9%的增益。由其他计算主导的情况，例如Linux编译，显示最小(≤2.3%的减速)。在冷缓存的情况下，所有的增益或损失都大致在实验噪声范围内，这表明这些优化不太可能对在冷系统上运行的应用程序造成损害。总的来说，这些结果肯定了普通的Linux应用程序不会因为我们的优化而受到损害，而且可以从中获得实质性的好处。 表1还显示了未修改Linux上这些工作负载的统计信息。一般来说，每个路径组件大约有8个字符，基于*at的应用程序通常查找单组件路径，而其他应用程序通常查找3-4个组件。我们的统计数据还表明，使用热缓存时，这些应用程序在缓存中应该看到84 - 100%的命中率，因此优化命中路径对性能至关重要。最后，make是唯一具有显著负dentries比例(大约20%)的应用程序，这是意料之中的，因为它正在创建新的二进制文件。 Server Applications 一个经常使用readdir的软件示例是使用MailDir存储格式的IMAP邮件服务器。我们通过为客户机创建10个邮箱来测试Dovecot IMAP服务器。我们使用客户端脚本随机选择不同邮箱中的消息，并将其标记为已读、已标记或未标记。在内部，标记邮件会导致重命名文件，并重新读取目录。为了消除网络延迟，我们在本地主机上运行网络测试;在实际部署中，网络延迟可能会掩盖客户端的这些改进，但服务器的负载仍然会减少。 图10显示了Dovecot邮件服务器在两个内核上的吞吐量。在两个内核上的吞吐量；改进范围为7.8-12.2%。与readdir微基准相呼应，较大的 目录通常会有更大的改善，在10%的收益中趋于平稳。我们同样使用Apache基准测试来锻炼Apache网络服务器生成文件列表的能力（表3）。这些页面没有被Apache缓存，而是为每个请求动态地生成。总的来说，这些结果表明，readdir缓存策略可以减少服务器的负载或提高服务器的吞吐量。 Code Changes为了估计采用的难度，表4列出了Linux原型中更改的代码行。所需的绝大多数更改(大约1,000个LoC)是本地化到dcache本身的钩子(dcache.c和name .c);大多数这些优化都在一组单独的文件中，总计约2,400个LoC。此外，我们测试的低级文件系统不需要任何更改就可以使用修改后的目录缓存。对其他子系统的主要影响实际上是对lsm的影响，这需要一些更改来正确地管理pcc。因此，采用其他内核子系统的负担非常小。 Discussion and Future Work如果愿意牺牲完全向后兼容性来最大化查找性能，那么改进的主要机会实际上可能是为基于路径的调用设计一个更简单的接口。 正如上面的评价所示，在这种设计中，有几个Linux&#x2F;POSIX特性的支持成本过高。例如，实现Plan 9风格的词法路径语义可以显著改善查找带有“dot dot”的路径。类似地，工作目录语义要求慢路径遍历。可以说，在这些点上，特定的实现选择已经“泄露”到接口规范中，并且这些特性限制了支持数据结构的选择。我们建议使用尽可能简单和无状态的接口;这个建议与其他关于可伸缩性的建议一致。 Linux静态地选择哈希表中的buckets数(默认情况下为262,144)。如果没有很好地选择这个数字，或者需求随着时间的推移而变化，则会浪费空间或bucket链变长，从而损害查找性能。 在我们的测试系统中，58%的bucket是空的，34%有一个条目，7%有两个条目，1%有3-10个条目，这表明有机会改进查找时间和空间使用。近年来开发了许多高性能哈希表，它们对搜索时间和浪费的空间施加了恒定的限制。 Related Work大多数提高目录缓存效率的相关工作都是针对两个相互正交的问题:减少丢失延迟和预取条目。最类似于我们记忆前缀检查结果的优化，SQL Server缓存对象最近访问控制检查的结果。 Reducing Miss Latency 减少遗漏延迟的一个相关策略是将所有要查找的组件一次性传递给低级文件系统，本质上是创建一个预取提示。一些网络文件系统已经观察到，组件一次查找会为每个组件生成一条往返消息，而更有效的策略是将一个消息中的挂载点下的所有组件传递给服务器进行查找。类似的论点也适用于本地文件系统，通过知道完整的查找目标，可以更有效地从磁盘获取元数据索引。因此，Windows NT和Solaris采用了这种分工。需要注意的是，如果不将其作为预取“提示”，这可能会将大量VFS功能推入每个低级文件系统，例如处理挂载点的重定向、符号链接和权限检查。Chen等人注意到，将权限检查从VFS层向下推到单个文件系统是Linux中难以防止的内核bug的一个重要来源。相比之下，这个项目缓存先前的前缀检查结果，以减少内存中已经存在的路径的命中延迟，而不是使用完整路径作为预取提示。 另一种普遍存在的延迟减少策略是将元数据持久地存储在散列表中。为了减少网络流量，一些分布式文件系统、集群环境和基于云的应用程序已经使用元数据散列来确定地将元数据映射到节点，从而消除了对目录服务的需求。直接查找文件系统(Direct Lookup File System, DLFS)本质上是将整个磁盘组织成一个哈希表，按照文件系统内的路径进行键控，以便查找只有一个I&#x2F;O的文件。将磁盘组织为散列表会带来一些挑战，例如将目录重命名转换为数据和元数据的深度递归副本。DLFS通过将父权限表示为封闭形式表达式来解决前缀检查问题;这种方法本质上是硬编码传统的Unix自由访问控制，并且不容易扩展到Linux安全模块。我们工作的一个重要见解是，内存中的全路径哈希，而不是磁盘上的，可以实现类似的性能提升，但没有这些可用性问题，例如重命名时的深度目录复制或更新子目录权限时容易出错的启发式方法。 VFS Cache Profetching 一些文件系统优化了readdir后跟stat以访问子目录元数据的情况，例如使用ls -l命令。当请求读取目录时，这些低级文件系统推测性地将文件索引节点(通常位于相对较近的磁盘扇区)读取到私有内存缓存中，随后的查找或stat请求将从该缓存中得到服务。类似地，NFS版本2协议包括一个READDIRPLUS操作，它在一次消息往返中请求所有子节点的目录内容和属性。这些文件系统必须实现它们自己的启发式方法来管理这个缓存。预取与我们的工作是正交的，它更有效地缓存已经从低级文件系统请求的内容。 Conclusion本文提出了一种目录缓存设计，可以有效地将文件路径映射到操作系统内核中的内存数据结构。我们的设计将目录缓存分解为单独的缓存，用于权限检查和路径索引，支持单步路径查找，并促进基于签名和缓存符号链接解析的新优化。对于经常与文件系统目录树交互的应用程序，这些优化最多可以将性能提高29%。我们的优化保持了与一系列应用程序和内核扩展的兼容性，使它们适合实际部署。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++学习 项目实战 webserver","slug":"C++-学习-项目实战-webserver","date":"2023-06-05T04:43:53.000Z","updated":"2023-06-29T09:25:40.323Z","comments":true,"path":"2023/06/05/C++-学习-项目实战-webserver/","link":"","permalink":"http://example.com/2023/06/05/C++-%E5%AD%A6%E4%B9%A0-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98-webserver/","excerpt":"阻塞和非阻塞、同步和异步（网络IO）典型的一次IO的两个阶段是什么？ 数据就绪：根据系统IO操作的就绪 阻塞 - 调用IO方法的线程进入阻塞状态 12ssize_t recv(int sockfd, void* buf, size_t len,int flags);interesting 非阻塞 - 不会改变进程的状态，通过返回值判断 数据读写：根据应用程序和内核的交互方式 同步 异步","text":"阻塞和非阻塞、同步和异步（网络IO）典型的一次IO的两个阶段是什么？ 数据就绪：根据系统IO操作的就绪 阻塞 - 调用IO方法的线程进入阻塞状态 12ssize_t recv(int sockfd, void* buf, size_t len,int flags);interesting 非阻塞 - 不会改变进程的状态，通过返回值判断 数据读写：根据应用程序和内核的交互方式 同步 异步 阻塞和非阻塞都是同步的IO，只有使用了特殊的API才是异步IO 异步一般与非阻塞结合使用 一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。 Unix、Linux上的五种IO模型阻塞blocking调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。 非阻塞non-blocking（NIO）非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I&#x2F;O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。 IO复用（IO multiplexing）Linux 用 select&#x2F;poll&#x2F;epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数据可读或可写时，才真正调用IO操作函数 信号驱动（signal-driven）Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。 内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。 异步（asynchronous）Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序 1234567891011121314151617181920212223/* Asynchronous I/O control block. */struct aiocb&#123;int aio_fildes; /* File desriptor. */int aio_lio_opcode; /* Operation to be performed. */int aio_reqprio; /* Request priority offset. */volatile void *aio_buf; /* Location of buffer. */size_t aio_nbytes; /* Length of transfer. */struct sigevent aio_sigevent; /* Signal number and value. *//* Internal members. */struct aiocb *__next_prio;int __abs_prio;int __policy;int __error_code;__ssize_t __return_value;#ifndef __USE_FILE_OFFSET64__off_t aio_offset; /* File offset. */char __pad[sizeof (__off64_t) - sizeof (__off_t)];#else__off64_t aio_offset; /* File offset. */#endifchar __glibc_reserved[32];&#125;; Webserver简介和HTTP协议Webserver（网页服务器）一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息。 通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。 HTTP协议（应用层协议）简介超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。 概述HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。 尽管 TCP&#x2F;IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP&#x2F;IP 协议族使用 TCP 作为其传输层。通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP&#x2F;1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。 工作原理HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 以下是 HTTP 请求&#x2F;响应的步骤： 客户端连接到 Web 服务器一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，http://www.baidu.com。（URL） 发送 HTTP 请求通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。 服务器接受请求并返回 HTTP 响应Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。 释放连接 TCP 连接若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 客户端浏览器解析 HTML 内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据HTML 的语法对其进行格式化，并在浏览器窗口中显示。 例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接; 浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; 服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器; 释放 TCP 连接; 浏览器将该 HTML 文本并显示内容。 HTTP 协议是基于 TCP&#x2F;IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。 HTTP请求报文与响应报文格式 可以在浏览器界面按F12查看HTTP报文 HTTP请求方法HTTP&#x2F;1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源： GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。 HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。 POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除 Request-URI 所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*’来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。 CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的 HTTP 代理服务器）。 HTTP状态码所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。状态代码的第一个数字代表当前响应的类型： 1xx消息——请求已被服务器接收，继续处理 2xx成功——请求已成功被服务器接收、理解、并接受 3xx重定向——需要后续操作才能完成这一请求 4xx请求错误——请求含有词法错误或者无法被执行 5xx服务器错误——服务器在处理某个正确请求时发生错误 虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 服务器编程基本框架虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。 模块 功能 I&#x2F;O处理单元 处理客户连接，读写网络数据 逻辑单元 业务进程或线程 网络存储单元 数据库、文件或缓存 请求队列 各单元之间的通信方式 I&#x2F;O 处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I&#x2F;O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I&#x2F;O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。网络存储单元可以是数据库、缓存和文件，但不是必须的。请求队列是各单元之间的通信方式的抽象。I&#x2F;O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。 两种高效的事件处理模式服务器程序通常需要处理三类事件：I&#x2F;O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor 和 Proactor，同步 I&#x2F;O 模型通常用于实现 Reactor 模式，异步 I&#x2F;O 模型通常用于实现 Proactor 模式。 Reactor模式使用同步 I&#x2F;O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是： 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket 上有数据可读。 当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll内核事件表中注册该 socket 上的写就绪事件。 当主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。 Reactor 模式的工作流程： Proactor模式Proactor 模式将所有 I&#x2F;O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。使用异步 I&#x2F;O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是： 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。 主线程继续处理其他逻辑。 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。 主线程继续处理其他逻辑。 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。 Proactor 模式的工作流程： 模拟Proactor模式使用同步 I&#x2F;O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。使用同步 I&#x2F;O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下： 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 主线程调用 epoll_wait 等待 socket 上有数据可读。 当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。 主线程调用 epoll_wait 等待 socket 可写。 当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。 同步 I&#x2F;O 模拟 Proactor 模式的工作流程： 线程同步机制类封装及线程池实现线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式： 主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。 主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。 线程池的一般模型为： 线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors&#x2F;cores)的数量N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。 空间换时间，浪费服务器的硬件资源，换取运行效率。 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。 EPOLLONESHOT事件即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。 有限状态机逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机： 12345678910111213STATE_MACHINE( Package _pack )&#123; PackageType _type = _pack.GetType(); switch( _type ) &#123; case type_A: process_package_A( _pack ); break; case type_B: process_package_B( _pack ); break; &#125;&#125; 这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。状态之间的转移是需要状态机内部驱动，如下代码： 12345678910111213141516171819STATE_MACHINE()&#123; State cur_State = type_A; while( cur_State != type_C ) &#123; Package _pack = getNewPackage(); switch( cur_State ) &#123; case type_A: process_package_state_A( _pack ); cur_State = type_B; break; case type_B: process_package_state_B( _pack ); cur_State = type_C; break; &#125; &#125;&#125; 该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"项目实战","slug":"编程语言/C/项目实战","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[]},{"title":"C++学习 网络编程 UDP通信","slug":"C++-学习-网络编程-UDP通信","date":"2023-06-04T01:46:56.000Z","updated":"2023-06-04T08:43:31.772Z","comments":true,"path":"2023/06/04/C++-学习-网络编程-UDP通信/","link":"","permalink":"http://example.com/2023/06/04/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP%E9%80%9A%E4%BF%A1/","excerpt":"UDP 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);- 参数： - sockfd : 通信的fd - buf : 要发送的数据 - len : 发送数据的长度 - flags : 0 - dest_addr : 通信的另外一端的地址信息 - addrlen : 地址的内存大小ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);- 参数： - sockfd : 通信的fd - buf : 接收数据的数组 - len : 数组的大小","text":"UDP 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,const struct sockaddr *dest_addr, socklen_t addrlen);- 参数： - sockfd : 通信的fd - buf : 要发送的数据 - len : 发送数据的长度 - flags : 0 - dest_addr : 通信的另外一端的地址信息 - addrlen : 地址的内存大小ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,struct sockaddr *src_addr, socklen_t *addrlen);- 参数： - sockfd : 通信的fd - buf : 接收数据的数组 - len : 数组的大小 案例 server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; // 2.绑定 int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.通信 while (1) &#123; char recvbuf[128]; char ipbuf[16]; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接收数据 int num = recvfrom(fd, recvbuf, sizeof(recvbuf), 0, (struct sockaddr*)&amp;cliaddr, &amp;len); printf(&quot;client IP : %s, Port : %d\\n&quot;, inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, sizeof(ipbuf)), ntohs(cliaddr.sin_port)); printf(&quot;client say : %s\\n&quot;, recvbuf); // 发送数据 sendto(fd, recvbuf, strlen(recvbuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); &#125; close(fd); return 0;&#125; client 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 服务器的地址信息 struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;saddr.sin_addr.s_addr); int num = 0; // 3.通信 while (1) &#123; // 发送数据 char sendBuf[128]; sprintf(sendBuf, &quot;hello , i am client %d \\n&quot;, num++); sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 接收数据 int num = recvfrom(fd, sendBuf, sizeof(sendBuf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; 广播向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。 只能在局域网中使用。 客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。 123456789// 设置广播属性的函数int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_toptlen);- sockfd : 文件描述符- level : SOL_SOCKET- optname : SO_BROADCAST- optval : int类型的值，为1表示允许广播- optlen : optval的大小 案例 server 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; //2.设置广播属性 int op = 1; setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, sizeof(op)); //3.创建广播地址 struct sockaddr_in cliaddr; cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;192.168.194.255&quot;, &amp;cliaddr.sin_addr.s_addr); // 4.通信 int num = 0; while (1) &#123; char sendBuf[128]; sprintf(sendBuf, &quot;hello , client......%d\\n&quot;, num++); // 发送数据 sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); printf(&quot;广播的数据： %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; client 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.客户端绑定本地的IP和端口 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.通信 while (1) &#123; char buf[128]; // 接收数据 int num = recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 组播（多播）单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。 组播既可以用于局域网，也可以用于广域网 客户端需要加入多播组，才能接收到多播的数据 组播地址 IP地址 说明 224.0.0.0~224.0.0.255 局部链接多播地址：是为路由协议和其它用途保留的地址，路由器并不转发属于此范围的IP包 224.0.1.0~224.0.1.255 预留多播地址：公用组播地址，可用于Internet；使用前需要申请 224.0.2.0~238.255.255.255 预留多播地址：用户可用组播地址(临时组地址)，全网范围内有效 239.0.0.0~239.255.255.255 本地管理组播地址，可供组织内部使用，类似于私有 IP 地址，不 能用于 Internet，可限制多播范围 设置组播 1234567891011121314151617181920212223int setsockopt(int sockfd, int level, int optname,const void *optval,socklen_t optlen);// 服务器设置多播的信息，外出接口- level : IPPROTO_IP- optname : IP_MULTICAST_IF- optval : struct in_addr// 客户端加入到多播组：- level : IPPROTO_IP- optname : IP_ADD_MEMBERSHIP- optval : struct ip_mreqstruct ip_mreq&#123;/* IP multicast address of group. */struct in_addr imr_multiaddr; // 组播的IP地址/* Local IP address of interface. */struct in_addr imr_interface; // 本地的IP地址&#125;;typedef uint32_t in_addr_t;struct in_addr&#123;in_addr_t s_addr;&#125;; 案例 server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; //2.设置多播属性，设置外出接口 struct in_addr imr_multiaddr; //初始化多播地址 inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;imr_multiaddr.s_addr); setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, sizeof(imr_multiaddr)); //3.初始化客户端地址信息 struct sockaddr_in cliaddr; cliaddr.sin_family = AF_INET; cliaddr.sin_port = htons(9999); inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;cliaddr.sin_addr.s_addr); // 4.通信 int num = 0; while (1) &#123; char sendBuf[128]; sprintf(sendBuf, &quot;hello , client......%d\\n&quot;, num++); // 发送数据 sendto(fd, sendBuf, strlen(sendBuf) + 1, 0, (struct sockaddr*)&amp;cliaddr, sizeof(cliaddr)); printf(&quot;组播的数据： %s\\n&quot;, sendBuf); sleep(1); &#125; close(fd); return 0;&#125; client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;arpa/inet.h&gt;int main() &#123; // 1.创建一个通信的socket int fd = socket(PF_INET, SOCK_DGRAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.客户端绑定本地的IP和端口 struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(9999); addr.sin_addr.s_addr = INADDR_ANY; int ret = bind(fd, (struct sockaddr*)&amp;addr, sizeof(addr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; struct ip_mreq op; inet_pton(AF_INET, &quot;239.0.0.10&quot;, &amp;op.imr_multiaddr.s_addr); op.imr_interface.s_addr = INADDR_ANY; //加入到多播组 setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, sizeof(op)); // 3.通信 while (1) &#123; char buf[128]; // 接收数据 int num = recvfrom(fd, buf, sizeof(buf), 0, NULL, NULL); printf(&quot;server say : %s\\n&quot;, buf); &#125; close(fd); return 0;&#125; 本地套接字通信本地套接字的作用：本地的进程间通信 有关系的进程间的通信（父子进程） 没有关系的进程间的通信 本地套接字实现流程和网络套接字类似，一般呢采用TCP的通信流程。 123456789101112131415161718192021222324252627282930313233// 本地套接字通信的流程 - tcp// 服务器端1. 创建监听的套接字int lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);2. 监听的套接字绑定本地的套接字文件 -&gt; server端struct sockaddr_un addr;// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。bind(lfd, addr, len);3. 监听listen(lfd, 100);4. 等待并接受连接请求struct sockaddr_un cliaddr;int cfd = accept(lfd, &amp;cliaddr, len);5. 通信接收数据：read/recv发送数据：write/send6. 关闭连接close();// 客户端的流程1. 创建通信的套接字int fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);2. 监听的套接字绑定本地的IP 端口struct sockaddr_un addr;// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。bind(lfd, addr, len);3. 连接服务器struct sockaddr_un serveraddr;connect(fd, &amp;serveraddr, sizeof(serveraddr));4. 通信接收数据：read/recv发送数据：write/send5. 关闭连接close(); 案例 server 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/un.h&gt;int main() &#123; unlink(&quot;server.sock&quot;); // 1.创建监听的套接字 int lfd = socket(AF_LOCAL, SOCK_STREAM, 0); if(lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.绑定本地套接字文件 struct sockaddr_un addr; addr.sun_family = AF_LOCAL; strcpy(addr.sun_path, &quot;server.sock&quot;); int ret = bind(lfd, (struct sockaddr *)&amp;addr, sizeof(addr)); if(ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.监听 ret = listen(lfd, 100); if(ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.等待客户端连接 struct sockaddr_un cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len); if(cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; printf(&quot;client socket filename: %s\\n&quot;, cliaddr.sun_path); // 5.通信 while(1) &#123; char buf[128]; int len = recv(cfd, buf, sizeof(buf), 0); if(len == -1) &#123; perror(&quot;recv&quot;); exit(-1); &#125; else if(len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; else if(len &gt; 0) &#123; printf(&quot;client say : %s\\n&quot;, buf); send(cfd, buf, len, 0); &#125; &#125; close(cfd); close(lfd); return 0;&#125; client 1","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 学习 网络编程 IO多路复用","slug":"C++-学习-网络编程-IO多路复用","date":"2023-05-25T05:54:32.000Z","updated":"2023-06-03T08:53:51.285Z","comments":true,"path":"2023/05/25/C++-学习-网络编程-IO多路复用/","link":"","permalink":"http://example.com/2023/05/25/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/","excerpt":"I&#x2F;O多路复用（I&#x2F;O多路转接）","text":"I&#x2F;O多路复用（I&#x2F;O多路转接） I&#x2F;O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，Linux 下实现 I&#x2F;O 多路复用的系统调用主要有 select、poll 和 epoll。 select主旨思想 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行了I&#x2F;O操作时，该函数才返回。 这个函数是阻塞 函数对文件描述符的检测的操作是由内核完成的 在返回时，它会告诉进程有多少描述符要进行I&#x2F;O操作。 123456789101112131415161718192021222324252627282930313233343536// sizeof(fd_set) = 128 1024#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);- 参数：- nfds : 委托内核检测的最大文件描述符的值 + 1- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性- 一般检测读操作- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区- 是一个传入传出参数- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）- exceptfds : 检测发生异常的文件描述符的集合- timeout : 设置的超时时间struct timeval &#123;long tv_sec; /* seconds */long tv_usec; /* microseconds */&#125;;- NULL : 永久阻塞，直到检测到了文件描述符有变化- tv_sec = 0 tv_usec = 0， 不阻塞- tv_sec &gt; 0 tv_usec &gt; 0， 阻塞对应的时间- 返回值 :- -1 : 失败- &gt;0(n) : 检测的集合中有n个文件描述符发生了变化// 将参数文件描述符fd对应的标志位设置为0void FD_CLR(int fd, fd_set *set);// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1int FD_ISSET(int fd, fd_set *set);// 将参数文件描述符fd 对应的标志位，设置为1void FD_SET(int fd, fd_set *set);// fd_set一共有1024 bit, 全部初始化为0void FD_ZERO(fd_set *set); 工作过程分析 select代码编写server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); // 创建一个fd_set的集合，存放的是需要检测的文件描述符 fd_set rdset, tmp; FD_ZERO(&amp;rdset); FD_SET(lfd, &amp;rdset); int maxfd = lfd; while (1) &#123; tmp = rdset; // 调用select系统函数，让内核帮检测哪些文件描述符有数据 int ret = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); if (ret == -1) &#123; perror(&quot;select&quot;); exit(-1); &#125; else if (ret == 0) &#123; continue; &#125; else if (ret &gt; 0) &#123; // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变 if (FD_ISSET(lfd, &amp;tmp)) &#123; // 表示有新的客户端连接进来了 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); // 将新的文件描述符加入到集合中 FD_SET(cfd, &amp;rdset); // 更新最大的文件描述符 maxfd = maxfd &gt; cfd ? maxfd : cfd; &#125; for (int i = lfd + 1; i &lt;= maxfd; i++) &#123; if (FD_ISSET(i, &amp;tmp)) &#123; // 说明这个文件描述符对应的客户端发来了数据 char buf[1024] = &#123; 0 &#125;; int len = read(i, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(i); FD_CLR(i, &amp;rdset); &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(i, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 创建socket int fd = socket(PF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in seraddr; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;seraddr.sin_addr.s_addr); seraddr.sin_family = AF_INET; seraddr.sin_port = htons(9999); // 连接服务器 int ret = connect(fd, (struct sockaddr*)&amp;seraddr, sizeof(seraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); return -1; &#125; int num = 0; while (1) &#123; char sendBuf[1024] = &#123; 0 &#125;; sprintf(sendBuf, &quot;send data %d&quot;, num++); write(fd, sendBuf, strlen(sendBuf) + 1); // 接收 int len = read(fd, sendBuf, sizeof(sendBuf)); if (len == -1) &#123; perror(&quot;read&quot;); return -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, sendBuf); &#125; else &#123; printf(&quot;服务器已经断开连接...\\n&quot;); break; &#125; // sleep(1); usleep(1000); &#125; close(fd); return 0;&#125; pollselect的缺点 poll12345678910111213141516171819202122#include &lt;poll.h&gt;struct pollfd &#123; int fd; /* 委托内核检测的文件描述符 */ short events; /* 委托内核检测文件描述符的什么事件 */ short revents; /* 文件描述符实际发生的事件 */&#125;;struct pollfd myfd;myfd.fd = 5;myfd.events = POLLIN | POLLOUT;//既要读也要写int poll(struct pollfd* fds, nfds_t nfds, int timeout);// -参数：// - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合// - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1// - timeout : 阻塞时长// 0 : 不阻塞// - 1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞// &gt; 0 : 阻塞的时长// - 返回值：// - 1 : 失败// &gt; 0（n） : 成功, n表示检测到集合中有n个文件描述符发生变化 案例server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;#include &lt;poll.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); //初始化检测的文件描述符数组 struct pollfd fds[1024]; for (int i = 0;i &lt; 1024;i++) &#123; fds[i].fd = -1; fds[i].events = POLLIN; &#125; fds[0].fd = lfd; int nfds = 0; while (1) &#123; // 调用poll系统函数，让内核帮检测哪些文件描述符有数据 int ret = poll(fds, nfds + 1, -1); if (ret == -1) &#123; perror(&quot;poll&quot;); exit(-1); &#125; else if (ret == 0) &#123; continue; &#125; else if (ret &gt; 0) &#123; // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变 if (fds[0].revents &amp; POLLIN) &#123; // 表示有新的客户端连接进来了 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); // 将新的文件描述符加入到集合中 for (int i = 1;i &lt; 1024;i++) &#123; if (fds[i].fd == -1) &#123; fds[i].fd = cfd; fds[i].events = POLLIN; break; &#125; &#125; // 更新最大的文件描述符 nfds = nfds &gt; cfd ? nfds : cfd; &#125; for (int i = 1; i &lt;= nfds; i++) &#123; if (fds[i].revents &amp; POLLIN) &#123; // 说明这个文件描述符对应的客户端发来了数据 char buf[1024] = &#123; 0 &#125;; int len = read(fds[i].fd, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(i); fds[i].fd = -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(fds[i].fd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; epollepoll()多路复用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;sys/epoll.h&gt;// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检// 测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向// 链表）。int epoll_create(int size);// -参数：// size : 目前没有意义了。随便写一个数，必须大于0// - 返回值：// - 1 : 失败// &gt; 0 : 文件描述符，操作epoll实例的typedef union epoll_data &#123; void* ptr; int fd; uint32_t u32; uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */&#125;;// 常见的Epoll检测事件：// - EPOLLIN// - EPOLLOUT// - EPOLLERR// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);// -参数：// - epfd : epoll实例对应的文件描述符// - op : 要进行什么操作// EPOLL_CTL_ADD : 添加// EPOLL_CTL_MOD : 修改// EPOLL_CTL_DEL : 删除// - fd : 要检测的文件描述符// - event : 检测文件描述符什么事情// 检测函数int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);// -参数：// - epfd : epoll实例对应的文件描述符// - events : 传出参数，保存了发送了变化的文件描述符的信息// - maxevents : 第二个参数结构体数组的大小// - timeout : 阻塞时间// - 0 : 不阻塞// - -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞// - &gt; 0 : 阻塞的时长（毫秒）// - 返回值：// - 成功，返回发送变化的文件描述符的个数 &gt; 0// - 失败 - 1 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); // 调用epoll_create()创建一个epoll实例 int epfd = epoll_create(100); // 将监听的文件描述符相关的检测信息添加到epoll实例中 struct epoll_event epev; epev.events = EPOLLIN; epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); struct epoll_event epevs[1024]; while (1) &#123; int ret = epoll_wait(epfd, epevs, 1024, -1); if (ret == -1) &#123; perror(&quot;epoll_wait&quot;); exit(-1); &#125; printf(&quot;ret = %d\\n&quot;, ret); for (int i = 0; i &lt; ret; i++) &#123; int curfd = epevs[i].data.fd; if (curfd == lfd) &#123; // 监听的文件描述符有数据达到，有客户端连接 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); &#125; else &#123; if (epevs[i].events &amp; EPOLLOUT) &#123; continue; &#125; // 有数据到达，需要通信 char buf[1024] = &#123; 0 &#125;; int len = read(curfd, buf, sizeof(buf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len == 0) &#123; printf(&quot;client closed...\\n&quot;); epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(curfd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; close(lfd); close(epfd); return 0;&#125; epoll的两种工作模式LT模式（水平触发）在水平触发模式下，当文件描述符（例如，socket）的缓冲区有数据可读时，Epoll 会通知用户。如果用户不处理这些数据（不读取），Epoll 会持续通知用户。用户可以选择读取全部数据，部分数据，或者不读取数据，但是只要缓冲区中还有数据，Epoll 就会一直通知用户。 LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。 ET模式（边沿触发）边沿触发模式与水平触发模式的主要区别在于，Epoll 仅在事件发生时通知用户一次。例如，当文件描述符的缓冲区有数据可读时，Epoll 会通知用户。如果用户不读取数据，那么下次 Epoll 检测到还有数据可读时，就不会再通知用户。用户需要在收到通知后尽可能地读取缓冲区中的全部数据，否则可能错过某些事件。 简单来说，边沿触发模式是当条件由不满足变为满足时（例如，从无数据可读变为有数据可读），Epoll 仅通知用户一次。用户需要在收到通知后尽快处理事件，否则可能错过后续的通知。这种模式通常适用于非阻塞的 socket。 总结一下，水平触发模式（LT）会在事件满足条件时持续通知用户，而边沿触发模式（ET）仅在事件发生时通知用户一次。在实际应用中，根据不同的使用场景和需求，可以灵活选择这两种模式。 ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。 1","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++学习 网络编程 socket通信基础","slug":"C++-学习-网络编程-socket通信基础","date":"2023-05-20T07:04:08.000Z","updated":"2023-05-23T14:13:15.220Z","comments":true,"path":"2023/05/20/C++-学习-网络编程-socket通信基础/","link":"","permalink":"http://example.com/2023/05/20/C++-%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/","excerpt":"socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 套接字通信分为两部分","text":"socket介绍 所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。 socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。 socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。 套接字通信分为两部分 服务器端：被动接受连接，一般不会主动发起连接 客户端：主动向服务器发起连接 socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别 字节序简介 现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如果不达成一致的规则，通信双方将无法进行正确的编码&#x2F;译码从而导致通信失败。 字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。 字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。 字节序举例 字节(从高到低)：0x 01 02 03 04 12 34 56 78 小端字节序，增长方向由低到高 大端字节序，增长方向由低到高 案例 123456789101112131415161718192021222324252627282930//字节序：字节在内存中存储的顺序//小端字节序：数据的高位字节存储在内存的高位地址，低位字节存储在内存的低位地址//大端字节序：数据的低位字节存储在内存的高位地址，高位字节存储在内存的低位地址//通过代码检测当前主机的字节序#include&lt;stdio.h&gt;int main()&#123; union &#123; short value; char bytes[sizeof(short)]; // char[2] &#125;test; test.value = 0x0102; if ((test.bytes[0] == 1) &amp;&amp; (test.bytes[1] == 2)) &#123; printf(&quot;大端字节序\\n&quot;); &#125; else if ((test.bytes[0] == 2) &amp;&amp; (test.bytes[1] == 1)) &#123; printf(&quot;小端字节序\\n&quot;); &#125; else &#123; printf(&quot;未知\\n&quot;); &#125;&#125; 编译运行结果为小段字节序 字节序转换 当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。 网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。 12345h - host 主机，主机字节序to - 转换成什么n - network 网络字节序s - short unsigned shortl - long unsigned int 123456789#include &lt;arpa/inet.h&gt;//网络通信时，需要将主机字节序转换成网络字节序（大端）//另外一段获取到数据以后根据情况将网络字节序转换成主机字节序// 转换端口uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序uint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序// 转IPuint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序uint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序 案例 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;arpa/inet.h&gt;int main()&#123; //htons 转换端口 unsigned short a = 0x0102; printf(&quot;%x\\n&quot;, a); unsigned short b = htons(a); printf(&quot;%x\\n&quot;, b); printf(&quot;-------------------------------\\n&quot;); //htonl 转换IP char buf[4] = &#123; 192,168,1,100 &#125;; int num = *(int*)buf; int sum = htonl(num); unsigned char* p = (char*)∑ printf(&quot;%d %d %d %d\\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); printf(&quot;-------------------------------\\n&quot;); //ntohl 转换IP unsigned char buf1[4] = &#123; 1,1,168,192 &#125;; int num1 = *(int*)buf1; int sum1 = ntohl(num1); unsigned char* p1 = (unsigned char*)&amp;sum1; printf(&quot;%d %d %d %d\\n&quot;, *p1, *(p1 + 1), *(p1 + 2), *(p1 + 3)); //ntohs } 编译运行 socket地址 socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。 客户端 -&gt; 服务器（IP, Port） 通用socket地址socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下： 123456#include &lt;bits/socket.h&gt;struct sockaddr &#123;sa_family_t sa_family;char sa_data[14];&#125;;typedef unsigned short int sa_family_t sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示： 协议族 地址族 描述 PF_UNIX AF_UNIX UNIX本地域协议族 PF_INET AF_INET TCP&#x2F;IPv4协议族 PF_INET6 AF_INET6 TCP&#x2F;IPv6协议族 宏 PF_* 和 AF_* 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。 sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示： 协议族 地址值含义和长度 PF_UNIX 文件的路径名，长度可达到108字节 PF_INET 16bit端口号和32bit IPv4地址，共6字节 PF_INET6 16bit端口号，32bit流标识，128bit IPv6地址，32bit 范围ID，共26字节 由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。 12345678#include &lt;bits/socket.h&gt;struct sockaddr_storage&#123;sa_family_t sa_family;unsigned long int __ss_align;char __ss_padding[ 128 - sizeof(__ss_align) ];&#125;;typedef unsigned short int sa_family_t; 专用socket地址很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 UNIX 本地域协议族使用如下专用的 socket 地址结构体： 123456#include &lt;sys/un.h&gt;struct sockaddr_un&#123;sa_family_t sin_family;char sun_path[108];&#125;; TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和IPv6： 123456789101112131415161718192021222324252627#include &lt;netinet/in.h&gt;struct sockaddr_in&#123;sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) *///地址族类型in_port_t sin_port; /* Port number. *///端口号struct in_addr sin_addr; /* Internet address. *///IP地址/* Pad to size of `struct sockaddr&#x27;. *///填充部分unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -sizeof (in_port_t) - sizeof (struct in_addr)];&#125;;struct in_addr&#123;in_addr_t s_addr;&#125;;struct sockaddr_in6&#123;sa_family_t sin6_family;in_port_t sin6_port; /* Transport layer port # */uint32_t sin6_flowinfo; /* IPv6 flow information */struct in6_addr sin6_addr; /* IPv6 address */uint32_t sin6_scope_id; /* IPv6 scope-id */&#125;;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef uint16_t in_port_t;typedef uint32_t in_addr_t;#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int) 所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。 IP地址转换（字符串IP转换成整数、主机网络字节序的转换）通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换： 1234#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *cp);int inet_aton(const char *cp, struct in_addr *inp);char *inet_ntoa(struct in_addr in); 下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址： 12345678910111213#include &lt;arpa/inet.h&gt;// p:点分十进制的IP字符串，n:表示network，网络字节序的整数int inet_pton(int af, const char *src, void *dst);//af:地址族： AF_INET AF_INET6//src:需要转换的点分十进制的IP字符串//dst:转换后的结果保存在这个里面// 将网络字节序的整数，转换成点分十进制的IP地址字符串const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);//af:地址族： AF_INET AF_INET6//src: 要转换的ip的整数的地址//dst: 转换成IP地址字符串保存的地方//size：第三个参数的大小（数组的大小）//返回值：返回转换后的数据的地址（字符串），和 dst 是一样的 案例 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;arpa/inet.h&gt;int main()&#123; //创建一个IP字符串，点分十进制的IP地址字符串 char buf[] = &quot;192.168.1.4&quot;; unsigned int num = 0; inet_pton(AF_INET, buf, &amp;num); unsigned char* p = (unsigned char*)&amp;num; printf(&quot;%d %d %d %d\\n&quot;, *p, *(p + 1), *(p + 2), *(p + 3)); //将网络字节序的IP整数转换成点分十进制的IP字符串 char ip[16] = &quot;&quot;; const char* str = inet_ntop(AF_INET, &amp;num, ip, 16); printf(&quot;%s\\n&quot;, str); printf(&quot;%d\\n&quot;, ip == str);&#125; 编译运行结果如下： TCP通信流程 UDP TCP 是否创建连接 无连接 面向连接 是否可靠 不可靠 可靠 连接的对象个数 一对一、一对多、多对一、多对多 支持一对一 传输的方式 面向数据报 面向字节流 首部开销 8个字节 最少20个字节 适用场景 实时应用（视频会议，直播） 可靠性高的应用（文件传输） TCP通信的流程服务器端 创建一个用于监听的套接字 监听：监听有客户端的连接 套接字：这个套接字其实就是一个文件描述符 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息） 客户端连接服务器的时候使用的就是这个IP和端口 设置监听，监听的fd开始工作 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd） 通信 接收数据 发送数据 通信结束，断开连接 客户端 创建一个用于通信的套接字（fd） 连接服务器，需要指定连接的服务器的 IP 和 端口 连接成功了，客户端可以直接和服务器通信 接收数据 发送数据 通信结束，断开连接 套接字函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略int socket(int domain, int type, int protocol);- 功能：创建一个套接字- 参数：- domain: 协议族AF_INET : ipv4AF_INET6 : ipv6AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）- type: 通信过程中使用的协议类型SOCK_STREAM : 流式协议SOCK_DGRAM : 报式协议- protocol : 具体的一个协议。一般写0- SOCK_STREAM : 流式协议默认使用 TCP- SOCK_DGRAM : 报式协议默认使用 UDP- 返回值：- 成功：返回文件描述符，操作的就是内核缓冲区。- 失败：-1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名- 功能：绑定，将fd 和本地的IP + 端口进行绑定- 参数：- sockfd : 通过socket函数得到的文件描述符- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息- addrlen : 第二个参数结构体占的内存大小int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn- 功能：监听这个socket上的连接- 参数：- sockfd : 通过socket()函数得到的文件描述符- backlog : 未连接的和已经连接的和的最大值， 5int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接- 参数：- sockfd : 用于监听的文件描述符- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）- addrlen : 指定第二个参数的对应的内存大小- 返回值：- 成功 ：用于通信的文件描述符- -1 ： 失败int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);- 功能： 客户端连接服务器- 参数：- sockfd : 用于通信的文件描述符- addr : 客户端要连接的服务器的地址信息- addrlen : 第二个参数的内存大小- 返回值：成功 0， 失败 -1ssize_t write(int fd, const void *buf, size_t count); // 写数据ssize_t read(int fd, void *buf, size_t count); // 读数据 TCP通信实现服务端实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// TCP 通信的服务器端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建socket(用于监听的套接字) int lfd = socket(AF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.绑定 struct sockaddr_in saddr; saddr.sin_family = AF_INET; // inet_pton(AF_INET, &quot;192.168.194.129&quot;, saddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; // 0.0.0.0 saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.监听 ret = listen(lfd, 8); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.接收客户端连接 struct sockaddr_in clientaddr; int len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;clientaddr, &amp;len); if (cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; // 输出客户端的信息 char clientIP[16]; inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(&quot;client ip is %s, port is %d\\n&quot;, clientIP, clientPort); // 5.通信 char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; // 获取客户端的数据 int num = read(cfd, recvBuf, sizeof(recvBuf)); if (num == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (num &gt; 0) &#123; printf(&quot;recv client data : %s\\n&quot;, recvBuf); &#125; else if (num == 0) &#123; // 表示客户端断开连接 printf(&quot;clinet closed...&quot;); break; &#125; char* data = &quot;hello,i am server&quot;; // 给客户端发送数据 write(cfd, data, strlen(data)); &#125; // 关闭文件描述符 close(cfd); close(lfd); return 0;&#125; 客户端实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// TCP通信的客户端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务器端 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.194.129&quot;, &amp;serveraddr.sin_addr.s_addr); serveraddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 3. 通信 char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; char* data = &quot;hello,i am client&quot;; // 给客户端发送数据 write(fd, data, strlen(data)); sleep(1); int len = read(fd, recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv server data : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; // 表示服务器端断开连接 printf(&quot;server closed...&quot;); break; &#125; &#125; // 关闭连接 close(fd); return 0;&#125; 编译运行如下 TCP三次握手TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 四次挥手来关闭一个连接。 三次握手的目的是保证双方互相之间建立了连接 三次握手发生在客户端连接的时候，当调用connect()，底层会通过TCP协议进行三次握手。 16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。 32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从B 到 A）的 TCP 报文段的序号值也具有相同的含义。 32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序号。 4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示15，所以 TCP 头部最长是60 字节。 6 位标志位包含如下几项： URG 标志，表示紧急指针（urgent pointer）是否有效。 ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。 PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。 RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。 SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。 FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文段。 16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。 16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。 16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。 第一次握手： 客户端将SYN标志位置为1 生成一个随机的32位的序号，这个序号后边是可以携带数据（数据的大小 第二次握手： 服务器端接受客户端的连接：ACK &#x3D; 1 服务器端会回发一个确认序号：ack &#x3D; 客户端的序号+数据端的长度+FIN&#x2F;SYN（按一个字节算） 服务器端会像向客户端发起连接请求： SYN &#x3D; 1 服务器会生成一个随机序号： seq &#x3D; K 第三次握手： 客户端应答服务器的连接请求： ACK &#x3D; 1 客户端回复收到了服务器端的数据： ack &#x3D; 服务端的序号 + 数据长度 + SYN&#x2F;FIN（按一个字节算） TCP滑动窗口滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0时，发送方一般不能再发送数据报。 滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。 TCP（传输控制协议）滑动窗口机制是一种流量控制和拥塞控制策略，用于保证数据包在不可靠的网络环境中可靠地传输。滑动窗口机制允许发送方在没有收到接收方确认（ACK）的情况下连续发送多个数据包。同时，接收方可以通过调整窗口大小来控制发送方的发送速率。 滑动窗口的主要组成部分包括： **发送窗口 (Send Window)**：发送方维护的一个缓冲区，用于存储尚未被确认的数据包。发送窗口的大小决定了发送方在等待确认之前可以发送多少数据包。 **接收窗口 (Receive Window)**：接收方维护的一个缓冲区，用于存储尚未被处理的数据包。接收窗口的大小决定了接收方可以一次接收多少数据包。 滑动窗口机制的工作流程如下： 发送方将数据划分为一个个数据包，将这些数据包依次存储在发送窗口中。 发送方将发送窗口中的数据包发送给接收方。发送窗口的大小决定了在等待确认之前可以发送多少数据包。 接收方收到数据包后，将数据包存储在接收窗口中，并向发送方发送确认（ACK）。 发送方收到接收方的确认后，将确认过的数据包从发送窗口中移除，并向前滑动窗口，以便继续发送更多数据包。 如果发送方在指定的超时时间内没有收到确认，将会重新发送未被确认的数据包。 接收方可以通过调整接收窗口的大小来控制发送方的发送速率。例如，当接收方的处理速度较慢时，接收方可以减小接收窗口的大小，从而降低发送方的发送速率。 滑动窗口机制的优点： 可以实现流量控制，防止接收方被发送方的数据包淹没。 可以提高网络传输的效率，因为发送方可以在不等待确认的情况下连续发送多个数据包。 可以实现拥塞控制，当网络出现拥塞时，发送方可以减小发送窗口的大小，降低发送速率。 TCP四次挥手四次挥手，在程序中调用了close()会使用TCP协议进行四次挥手 客户端和服务端都可以主动发起断开连接，谁先调用close()谁就是先发起。 因为在TCP连接的时候，采用三次握手的建立是双向的，在断开的时候也需要双向断开。 TCP四次挥手是指在TCP连接断开过程中，两个通信节点之间进行四次报文交互的过程。 四次挥手的过程如下： 第一次挥手（FIN_WAIT_1）：当主动关闭连接的一方（通常称为客户端）认为不再需要发送数据时，它会设置FIN标志并将此报文发送给另一方（通常称为服务器端）。这表示客户端已经完成了数据传输。 第二次挥手（CLOSE_WAIT）：当服务器端收到带有FIN标志的报文时，它会发送一个确认报文（ACK）给客户端。确认报文的ACK序号等于接收到的FIN报文序号加1。此时，服务器端进入CLOSE_WAIT状态，表示它已经知道客户端不再发送数据。 注意，此时TCP连接仍然是半开放的，因为服务器端仍然可以向客户端发送数据。 第三次挥手（FIN_WAIT_2）：当客户端收到服务器端的确认报文后，它会进入FIN_WAIT_2状态。此时，客户端已经关闭了发送通道，但是仍然可以接收服务器端的数据。 第四次挥手（TIME_WAIT）：当服务器端完成数据发送后，它也会设置FIN标志并发送给客户端。当客户端收到带有FIN标志的报文时，它会发送一个确认报文（ACK）给服务器端。确认报文的ACK序号等于接收到的FIN报文序号加1。此时，客户端进入TIME_WAIT状态，并等待一段时间（通常为2倍的最大报文生命周期）以确保服务器端收到确认报文。在等待期间，如果客户端收到服务器端的FIN重传，它会重新发送确认报文。 当服务器端收到客户端的确认报文后，它会立即关闭连接。当客户端等待时间结束后，它也会关闭连接。 总之，TCP四次挥手过程是一个有序的连接关闭过程。这个过程可以确保双方都完成了数据传输，避免了数据丢失和连接半开放的问题。 TCP通信并发要实现TCP通信服务器处理并发的任务，使用多线程或多线程来解决 思路： 一个父进程，多个子进程 父进程负责等待并接受客户端的连接 子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信 多进程实现服务端实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;signal.h&gt;#include &lt;wait.h&gt;#include &lt;errno.h&gt;void recyleChild(int arg) &#123; while (1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if (ret == -1) &#123; // 所有的子进程都回收了 break; &#125; else if (ret == 0) &#123; // 还有子进程活着 break; &#125; else if (ret &gt; 0) &#123; // 被回收了 printf(&quot;子进程 %d 被回收了\\n&quot;, ret); &#125; &#125;&#125;int main() &#123; struct sigaction act; act.sa_flags = 0; sigemptyset(&amp;act.sa_mask); act.sa_handler = recyleChild; // 注册信号捕捉 sigaction(SIGCHLD, &amp;act, NULL); // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 监听 ret = listen(lfd, 128); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 不断循环等待客户端连接 while (1) &#123; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接受连接 int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); if (cfd == -1) &#123; if (errno == EINTR) &#123; continue; &#125; perror(&quot;accept&quot;); exit(-1); &#125; // 每一个连接进来，创建一个子进程跟客户端通信 pid_t pid = fork(); if (pid == 0) &#123; // 子进程 // 获取客户端的信息 char cliIp[16]; inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(cliaddr.sin_port); printf(&quot;client ip is : %s, prot is %d\\n&quot;, cliIp, cliPort); // 接收客户端发来的数据 char recvBuf[1024]; while (1) &#123; int len = read(cfd, &amp;recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv client : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; write(cfd, recvBuf, strlen(recvBuf) + 1); &#125; close(cfd); exit(0); // 退出当前子进程 &#125; &#125; close(lfd); return 0;&#125; 客户端实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// TCP通信的客户端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务器端 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.194.129&quot;, &amp;serveraddr.sin_addr.s_addr); serveraddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr*)&amp;serveraddr, sizeof(serveraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 3. 通信 char recvBuf[1024]; int i = 0; while (1) &#123; sprintf(recvBuf, &quot;data : %d\\n&quot;, i++); // 给服务器端发送数据 write(fd, recvBuf, strlen(recvBuf) + 1); int len = read(fd, recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv server : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; // 表示服务器端断开连接 printf(&quot;server closed...&quot;); break; &#125; sleep(1); &#125; // 关闭连接 close(fd); return 0;&#125; 编译运行 多线程实现只有服务端的代码需要修改为多线程的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;struct sockInfo &#123; int fd; // 通信的文件描述符 struct sockaddr_in addr; pthread_t tid; // 线程号&#125;;struct sockInfo sockinfos[128];void* working(void* arg) &#123; // 子线程和客户端通信 cfd 客户端的信息 线程号 // 获取客户端的信息 struct sockInfo* pinfo = (struct sockInfo*)arg; char cliIp[16]; inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(pinfo-&gt;addr.sin_port); printf(&quot;client ip is : %s, prot is %d\\n&quot;, cliIp, cliPort); // 接收客户端发来的数据 char recvBuf[1024]; while (1) &#123; int len = read(pinfo-&gt;fd, &amp;recvBuf, sizeof(recvBuf)); if (len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if (len &gt; 0) &#123; printf(&quot;recv client : %s\\n&quot;, recvBuf); &#125; else if (len == 0) &#123; printf(&quot;client closed....\\n&quot;); break; &#125; write(pinfo-&gt;fd, recvBuf, strlen(recvBuf) + 1); &#125; close(pinfo-&gt;fd); return NULL;&#125;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_port = htons(9999); saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 监听 ret = listen(lfd, 128); if (ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 初始化数据 int max = sizeof(sockinfos) / sizeof(sockinfos[0]); for (int i = 0; i &lt; max; i++) &#123; bzero(&amp;sockinfos[i], sizeof(sockinfos[i])); sockinfos[i].fd = -1; sockinfos[i].tid = -1; &#125; // 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信 while (1) &#123; struct sockaddr_in cliaddr; int len = sizeof(cliaddr); // 接受连接 int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); struct sockInfo* pinfo; for (int i = 0; i &lt; max; i++) &#123; // 从这个数组中找到一个可以用的sockInfo元素 if (sockinfos[i].fd == -1) &#123; pinfo = &amp;sockinfos[i]; break; &#125; if (i == max - 1) &#123; sleep(1); i--; &#125; &#125; pinfo-&gt;fd = cfd; memcpy(&amp;pinfo-&gt;addr, &amp;cliaddr, len); // 创建子线程 pthread_create(&amp;pinfo-&gt;tid, NULL, working, pinfo); pthread_detach(pinfo-&gt;tid); &#125; close(lfd); return 0;&#125; 编译运行 TCP状态转换 2MSL（Maximum Segment Lifetime）主动断开连接的一方, 最后进出入一个 TIME_WAIT状态, 这个状态会持续: 2msl msl: 官方建议: 2分钟, 实际是30s当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方必须处于TIME_WAIT 状态并持续 2MSL 时间。这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。 半关闭 当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发送的数据，但是 A 已经不能再向 B 发送数据。 从程序的角度，可以使用API来控制实现半连接状态： 12345678#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how);//sockfd: 需要关闭的socket的描述符//how: 允许为shutdown操作选择以下几种方式://SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。//该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。//SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。//SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。 使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。注意: 如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。 在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。但如果一个进程 close(sfd) 将不会影响到其它进程。 端口复用查看网络相关信息的命令 1netstat 参数： -a 所有的socket -p显示正在使用socket的程序的名称 -n直接使用IP地址，而不通过域名服务器 案例 服务端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char* argv[]) &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); if (lfd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in saddr; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons(9999); //端口复用 //int optval = 1; //setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)); int optval = 1; setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, sizeof(optval)); // 绑定 int ret = bind(lfd, (struct sockaddr*)&amp;saddr, sizeof(saddr)); if (ret == -1) &#123; perror(&quot;bind&quot;); return -1; &#125; // 监听 ret = listen(lfd, 8); if (ret == -1) &#123; perror(&quot;listen&quot;); return -1; &#125; // 接收客户端连接 struct sockaddr_in cliaddr; socklen_t len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len); if (cfd == -1) &#123; perror(&quot;accpet&quot;); return -1; &#125; // 获取客户端信息 char cliIp[16]; inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, sizeof(cliIp)); unsigned short cliPort = ntohs(cliaddr.sin_port); // 输出客户端的信息 printf(&quot;client&#x27;s ip is %s, and port is %d\\n&quot;, cliIp, cliPort); // 接收客户端发来的数据 char recvBuf[1024] = &#123; 0 &#125;; while (1) &#123; int len = recv(cfd, recvBuf, sizeof(recvBuf), 0); if (len == -1) &#123; perror(&quot;recv&quot;); return -1; &#125; else if (len == 0) &#123; printf(&quot;客户端已经断开连接...\\n&quot;); break; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, recvBuf); &#125; // 小写转大写 for (int i = 0; i &lt; len; ++i) &#123; recvBuf[i] = toupper(recvBuf[i]); &#125; printf(&quot;after buf = %s\\n&quot;, recvBuf); // 大写字符串发给客户端 ret = send(cfd, recvBuf, strlen(recvBuf) + 1, 0); if (ret == -1) &#123; perror(&quot;send&quot;); return -1; &#125; &#125; close(cfd); close(lfd); return 0;&#125; 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;int main() &#123; // 创建socket int fd = socket(PF_INET, SOCK_STREAM, 0); if (fd == -1) &#123; perror(&quot;socket&quot;); return -1; &#125; struct sockaddr_in seraddr; inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;seraddr.sin_addr.s_addr); seraddr.sin_family = AF_INET; seraddr.sin_port = htons(9999); // 连接服务器 int ret = connect(fd, (struct sockaddr*)&amp;seraddr, sizeof(seraddr)); if (ret == -1) &#123; perror(&quot;connect&quot;); return -1; &#125; while (1) &#123; char sendBuf[1024] = &#123; 0 &#125;; fgets(sendBuf, sizeof(sendBuf), stdin); write(fd, sendBuf, strlen(sendBuf) + 1); // 接收 int len = read(fd, sendBuf, sizeof(sendBuf)); if (len == -1) &#123; perror(&quot;read&quot;); return -1; &#125; else if (len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, sendBuf); &#125; else &#123; printf(&quot;服务器已经断开连接...\\n&quot;); break; &#125; &#125; close(fd); return 0;&#125; 首先运行server，然后运行命令 1netstat -anp | grep 9999 然后运行client，再次运行netstat命令 之后断开server，再次运行netstat命令 过一段时间之后再次运行netstat命令 如果我们结束server之后立即断开client，再次运行netstat命令 我们在断开server之后的一分钟之内不能再次启动server，因为端口已经被占用了 所以这个时候需要使用端口复用 端口复用最常用的用途是: 防止服务器重启时之前绑定的端口还未释放 程序突然退出而系统没有释放端口 通过一个系统的API实现 1234567891011121314151617#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);//设置套接字的属性（不仅仅能设置端口复用）//参数：//- sockfd：要操作的文件描述符//- level：级别 - SOLSOCKET(端口复用的级别)//- optname：选项的名称// - SO_REUSEADDR// - SO_REUSEPORT//- optval：端口复用的值（整形）// - 1：可以复用// - 0：不可以复用//- optlen：optval参数的大小//端口复用，设置的时机是在服务器绑定端口之前//setsockopt();//bind(); 在开启端口复用之后，断开server，在TIME_WAIT状态可以再次打开一个server","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 Linux系统编程 线程","slug":"C++-学习-Linux系统编程-线程","date":"2023-05-15T05:40:29.000Z","updated":"2023-05-19T13:00:07.188Z","comments":true,"path":"2023/05/15/C++-学习-Linux系统编程-线程/","link":"","permalink":"http://example.com/2023/05/15/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/","excerpt":"线程概述线程 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP （线程）号：ps –Lf pid","text":"线程概述线程 与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程） 进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。 线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。 查看指定进程的 LWP （线程）号：ps –Lf pid 进程和线程区别 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，无需采用写时复制来复制内存，也无需复制页表 线程之间共享和非共享资源 共享资源 进程 ID 和父进程 ID 进程组 ID 和会话 ID 用户 ID 和 用户组 ID 文件描述符表 信号处置 文件系统的相关信息：文件权限掩码（umask）、当前工作目录 虚拟地址空间（除栈、.text） 非共享资源 线程 ID 信号掩码 线程特有数据 error 变量 实时调度策略和优先级 栈，本地变量和函数的调用链接信息 NPTL 当 Linux 最初开发时，在内核中并不能真正支持线程。但是它的确可以通过 clone() 系统调用将进程作为可调度的实体。这个调用创建了调用进程（calling process）的一个拷贝，这个拷贝与调用进程共享相同的地址空间。LinuxThreads 项目使用这个调用来完成在用户空间模拟对线程的支持。不幸的是，这种方法有一些缺点，尤其是在信号处理、调度和进程间同步等方面都存在问题。另外，这个线程模型也不符合 POSIX 的要求。 要改进 LinuxThreads，需要内核的支持，并且重写线程库。有两个相互竞争的项目开始来满足这些要求。一个包括 IBM 的开发人员的团队开展了 NGPT（Next-Generation POSIX Threads）项目。同时，Red Hat 的一些开发人员开展了 NPTL 项目。NGPT 在 2003 年中期被放弃了，把这个领域完全留给了 NPTL。 NPTL，或称为 Native POSIX Thread Library，是 Linux 线程的一个新实现，它克服了 LinuxThreads 的缺点，同时也符合 POSIX 的需求。与 LinuxThreads 相比，它在性能和稳定性方面都提供了重大的改进。 查看当前 pthread 库版本：getconf GNU_LIBPTHREAD_VERSION 线程操作进程创建12345678910111213141516171819// 一般情况下, main函数所在的线程我们称之为主线程（main线程），其余创建的线程// 称之为子线程。// 程序中默认只有一个进程，fork()函数调用，2进行// 程序中默认只有一个线程，pthread_create()函数调用，2个线程。#include &lt;pthread.h&gt;int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine) (void*), void* arg);// -功能：创建一个子线程// - 参数：// - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。// - attr : 设置线程的属性，一般使用默认值，NULL// - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码// - arg : 给第三个参数使用，传参// - 返回值：// 成功：0// 失败：返回错误号。这个错误号和之前errno不太一样。// 获取错误号的信息： char* strerror(int errnum); pthread_create不是标准库定义的调用，所以在编译时需要连接第三方的库 -pthread 案例 12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread . . .\\n&quot;); printf(&quot;arg value = %d\\n&quot;, *(int*)arg);&#125;int main()&#123; //创建一个子线程 pthread_t tid; int num = 10; int ret = pthread_create(&amp;tid, NULL, callback, (void*)&amp;num); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; sleep(1);&#125; 编译运行结果为： 终止线程1234567891011121314#include &lt;pthread.h&gt;void pthread_exit(void* retval);// 功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程// 参数：// retval : 需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。pthread_t pthread_self(void);// 功能：获取当前的线程的线程IDint pthread_equal(pthread_t t1, pthread_t t2);// 功能：比较两个线程ID是否相等// 不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的// 是使用结构体去实现的。//一般跨平台等等必须要使用 案例 12345678910111213141516171819202122232425262728293031#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; //主线程 for (int i = 0;i &lt; 50;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //让主线程退出,当主线程退出时，不会影响其他 pthread_exit(NULL);&#125; 连接已终止的进程123456789101112#include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval); // - 功能：和一个已经终止的线程进行连接 // 回收子线程的资源 // 这个函数是阻塞函数，调用一次只能回收一个子线程 // 一般在主线程中使用 // - 参数： // - thread：需要回收的子线程的ID // - retval: 接收子线程退出时的返回值 // - 返回值： // 0 : 成功 // 非0 : 失败，返回的错误号 案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int value = 10;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); sleep(3); pthread_exit((void*)&amp;value);//return (void *)&amp;value;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; //主线程 for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //主线程调用pthread_join()回收子线程的资源 int* thread_retval; ret = pthread_join(tid, (void**)&amp;thread_retval); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; printf(&quot;exit data : %d\\n&quot;, *thread_retval); printf(&quot;回收子线程资源成功\\n&quot;); //让主线程退出,当主线程退出时，不会影响其他 pthread_exit(NULL);&#125; 编译运行 线程的分离123456789#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread); // - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。 // 1.不能多次分离，会产生不可预料的行为。 // 2.不能去连接一个已经分离的线程，会报错。 // - 参数：需要分离的线程的ID // - 返回值： // 成功：0 // 失败：返回错误号 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //输出主线程和子线程的ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error2 : %s\\n&quot;, errstr); &#125; //设置分离以后，对分离的子线程进行连接 pthread_join() ret = pthread_join(tid, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error3 : %s\\n&quot;, errstr); &#125; pthread_exit(NULL);&#125; 编译运行 线程取消123456#include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread); // - 功能：取消线程（让线程终止） // 取消某个线程，可以终止某个线程的运行， // 但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。 // 取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。 案例 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;child : %d\\n&quot;, i); &#125; return NULL;&#125;int main()&#123; //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //取消线程 pthread_cancel(tid); for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; //输出主线程和子线程的ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); pthread_exit(NULL);&#125; 编译运行 线程属性1234567891011int pthread_attr_init(pthread_attr_t *attr); //- 初始化线程属性变量int pthread_attr_destroy(pthread_attr_t *attr); //- 释放线程属性的资源int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); //- 获取线程分离的状态属性int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); //- 设置线程分离的状态属性 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;pthread.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;void* callback(void* arg)&#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main()&#123; //创建一个线程属性变量 pthread_attr_t attr; //初始化属性变量 pthread_attr_init(&amp;attr); //设置属性 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); //创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if (ret != 0) &#123; char* errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; //输出主线程和子线程的ID printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); //获取线程的栈的大小 size_t size; pthread_attr_getstacksize(&amp;attr, &amp;size); printf(&quot;thread stack size : %ld\\n&quot;, size); //释放线程属性资源 pthread_attr_destroy(&amp;attr); pthread_exit(NULL);&#125; 编译运行 线程同步 线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。 临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应终端该片段的执行。 线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。 互斥量 为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。 互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。 一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，如下图所示： 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//使用多线程实现卖票案例//有3个窗口，一共是100张票#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;int tickets = 100;//全局变量，所有线程都共享这一份资源//创建一个互斥量pthread_mutex_t mutex;void* sellticket(void* arg)&#123; //卖票 while (1) &#123; //加锁 pthread_mutex_lock(&amp;mutex); if (tickets &gt; 0) &#123; printf(&quot;%ld 正在卖第 %d 张门票\\n&quot;, pthread_self(), tickets); tickets--; &#125; else &#123; //解锁 pthread_mutex_unlock(&amp;mutex); break; &#125; //解锁 pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125;int main()&#123; //初始化互斥量 pthread_mutex_init(&amp;mutex, NULL); //创建三个子线程 pthread_t tid1, tid2, tid3; pthread_create(&amp;tid1, NULL, sellticket, NULL); pthread_create(&amp;tid2, NULL, sellticket, NULL); pthread_create(&amp;tid3, NULL, sellticket, NULL); //回收子线程的资源,阻塞的函数 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); //设置线程分离 pthread_detach(tid1); pthread_detach(tid2); pthread_detach(tid3); pthread_exit(NULL);//退出主线程 //释放互斥量资源 pthread_mutex_destroy(&amp;mutex);&#125; 死锁 有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。 两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 死锁的几种场景： 忘记释放锁 重复加锁 多线程多锁，抢占锁资源 读写锁 当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。 在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高 12345678// 读写锁的类型 pthread_rwlock_tint pthread_rwlock_init(pthread_rwlock_t *rstrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//案例：8个线程操作同一个全局变量//3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;unistd.h&gt;//创建一个共享数据int num = 1;pthread_mutex_t mutex;pthread_rwlock_t rwlock;void* writeNum(void* arg)&#123; while (1) &#123; pthread_rwlock_wrlock(&amp;rwlock); num++; printf(&quot;++write, tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); usleep(100); &#125; return NULL;&#125;void* readNum(void* arg)&#123; while (1) &#123; pthread_rwlock_rdlock(&amp;rwlock); printf(&quot;===read,tid : %ld, num : %d\\n&quot;, pthread_self(), num); pthread_rwlock_unlock(&amp;rwlock); usleep(100); &#125; return NULL;&#125;int main()&#123; pthread_rwlock_init(&amp;rwlock, NULL); pthread_t wtids[3], rtids[5];//创建3个写线程，5个读线程 for (int i = 0;i &lt; 3;i++) &#123; pthread_create(&amp;wtids[i], NULL, writeNum, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;rtids[i], NULL, readNum, NULL); &#125; //设置线程分离 for (int i = 0;i &lt; 3;i++) &#123; pthread_detach(wtids[i]); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(rtids[i]); &#125; pthread_exit(NULL); pthread_rwlock_destroy(&amp;rwlock);&#125; 生产者消费者模型12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697//生产者消费者模型(简单版)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;pthread_mutex_t mutex;struct Node&#123; int num; struct Node* next; &#125;//头结点struct Node* head = NULL;void* producer(void* arg)&#123; //不断的创建新的节点，添加到链表中 while (1) &#123; pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); //保存头节点的指针 struct Node* tmp = head; //判断是否有数据 if (head != NULL) &#123; // 有数据 head = head-&gt;next; printf(&quot;delete node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; //没有数据 pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex); //创建5个生产者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, custmer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL);&#125; 这段代码没有处理好一个问题，当有消费者想要消费但是缓冲区已经没有数据的时候，消费者会直接退出，当缓冲区有数据的时候却不会再通知这个消费者，我们需要通过一定手段解决这个问题 条件变量1234567891011// 条件变量的类型 pthread_cond_t int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); int pthread_cond_destroy(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex); // - 等待，调用了该函数，线程会阻塞。 int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime); // - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。 int pthread_cond_signal(pthread_cond_t *cond); // - 唤醒一个或者多个等待的线程 int pthread_cond_broadcast(pthread_cond_t *cond); // - 唤醒所有的等待的线程 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//生产者消费者模型(简单版)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;pthread_mutex_t mutex;//创建条件变量pthread_cond_t cond;struct Node&#123; int num; struct Node* next;&#125;;//头结点struct Node* head = NULL;void* producer(void* arg)&#123; //不断的创建新的节点，添加到链表中 while (1) &#123; pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); //只要生产了一个就通知消费者消费 pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); //保存头节点的指针 struct Node* tmp = head; //判断是否有数据 if (head != NULL) &#123; // 有数据 head = head-&gt;next; printf(&quot;del node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; //没有数据 需要等待 //当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞时，继续向下执行，会重新加锁。 pthread_cond_wait(&amp;cond, &amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond, NULL); //创建5个生产者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); pthread_exit(NULL);&#125; 使用条件变量解决上述生产者和消费者的问题。 信号量123456789101112131415161718192021222324252627282930313233343536// 信号量的类型 sem_tint sem_init(sem_t *sem, int pshared, unsigned int value); // - 初始化信号量 // - 参数： // - sem : 信号量变量的地址 // - pshared : 0 用在线程间 ，非0 用在进程间 // - value : 信号量中的值int sem_destroy(sem_t *sem); // - 释放资源int sem_wait(sem_t *sem); // - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞int sem_trywait(sem_t *sem);int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);int sem_post(sem_t *sem); // - 对信号量解锁，调用一次对信号量的值+1int sem_getvalue(sem_t *sem, int *sval);// sem_t psem;// sem_t csem;// init(psem, 0, 8);// init(csem, 0, 0);// producer() &#123;// sem_wait(&amp;psem);// sem_post(&amp;csem)// &#125;// customer() &#123;// sem_wait(&amp;csem);// sem_post(&amp;psem)// &#125; 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//生产者消费者模型(简单版)#include&lt;stdio.h&gt;#include&lt;pthread.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;semaphore.h&gt;pthread_mutex_t mutex;//创建两个信号量sem_t psem;sem_t csem;struct Node&#123; int num; struct Node* next;&#125;;//头结点struct Node* head = NULL;void* producer(void* arg)&#123; //不断的创建新的节点，添加到链表中 while (1) &#123; sem_wait(&amp;psem); pthread_mutex_lock(&amp;mutex); struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node , num : %d , tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;csem); usleep(100); &#125; return NULL;&#125;void* customer(void* arg)&#123; while (1) &#123; sem_wait(&amp;csem); pthread_mutex_lock(&amp;mutex); //保存头节点的指针 struct Node* tmp = head; // 有数据 head = head-&gt;next; printf(&quot;del node , num : %d , tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); sem_post(&amp;psem); &#125; return NULL;&#125;int main()&#123; pthread_mutex_init(&amp;mutex, NULL); sem_init(&amp;psem, 0, 8); sem_init(&amp;csem, 0, 0); //创建5个生产者线程和5个消费者线程 pthread_t ptids[5], ctids[5]; for (int i = 0;i &lt; 5;i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for (int i = 0;i &lt; 5;i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while (1) &#123; sleep(10); &#125; while (1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL);&#125; 信号量同样解决了上述生产者和消费者的问题","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"C++学习 数据库编程","slug":"C++-学习-数据库编程","date":"2023-05-11T06:10:20.000Z","updated":"2023-05-11T10:33:21.034Z","comments":true,"path":"2023/05/11/C++-学习-数据库编程/","link":"","permalink":"http://example.com/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Oracle Oracle安装连接：Database Software Downloads | Oracle","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"数据库","slug":"编程语言/C/数据库","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"C++学习 QT简介","slug":"C++-学习-QT简介","date":"2023-05-11T05:39:45.000Z","updated":"2023-05-14T13:37:03.146Z","comments":true,"path":"2023/05/11/C++-学习-QT简介/","link":"","permalink":"http://example.com/2023/05/11/C++-%E5%AD%A6%E4%B9%A0-QT%E7%AE%80%E4%BB%8B/","excerpt":"QT的下载和安装Index of &#x2F; (qt.io) Index of &#x2F;qt&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror","text":"QT的下载和安装Index of &#x2F; (qt.io) Index of &#x2F;qt&#x2F; | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 下载在线安装包之后 1.\\qt-unified-windows-x64-4.5.2-online.exe --mirror https://mirror.nju.edu.cn/qt 运行这道命令将源换成国内的镜像之后进行安装 Qt创建项目以及main和pro文件的生成Qt创建项目 创建项目 创建步骤 这里我们选择qmake为例子学习，不然没有pro文件，CMake是一个txt文件 我们以QWidget为例 此时QT项目已经创建完成 main文件和pro文件解析main文件 123456789101112131415#include &quot;mywidget.h&quot;#include &lt;QApplication&gt;//应用程序类//程序入口 argv 命令行变量数量 命令行变量数组int main(int argc, char *argv[])&#123; //a 应用程序对象，在Qt中应用程序对象有且仅有一个 QApplication a(argc, argv); //通过窗口类实例化对象 w MyWidget w; //窗口是不会默认弹出的，需要调用show方法进行显示 w.show(); //a.exec();进入消息循环机制 阻塞功能 return a.exec();&#125; pro文件 123456789101112131415161718192021QT += core gui //Qt包含的模块greaterThan(QT_MAJOR_VERSION, 4): QT += widgets //大于4版本 加入widget模块CONFIG += c++17# You can make your code fail to compile if it uses deprecated APIs.# In order to do so, uncomment the following line.#DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0SOURCES += \\ main.cpp \\ mywidget.cpp //源文件HEADERS += \\ mywidget.h //头文件# Default rules for deployment.qnx: target.path = /tmp/$$&#123;TARGET&#125;/binelse: unix:!android: target.path = /opt/$$&#123;TARGET&#125;/bin!isEmpty(target.path): INSTALLS += target Qt6包含模块 模块 描述 Qt Core 下面其他模块使用的核心基础类（Qt Core是非图形模块） Qt D-Bus 用于通过 D-Bus 协议进行进程间通信的类 Qt GUI 图形用户界面 （GUI） 组件的基类 Qt Network 使网络编程更轻松、更易移植的类 Qt QML QML 和 JavaScript 语言的类 Qt Quick 一个声明性框架，用于构建具有自定义用户界面的高度动态的应用程序。 Qt Quick Controls 提供轻量级 QML 类，用于为桌面、嵌入式和移动设备创建高性能用户界面。这些类型采用简单的样式体系结构，并且非常高效。 Qt Quick Dialogs 用于从 Qt 快速应用程序创建系统对话框并与之交互的类。 Qt Quick Layouts 布局是用于在用户界面中排列基于 Qt Quick 2 的项目的项。 Qt Quick Test QML 应用程序的单元测试框架，其中测试用例编写为 JavaScript 函数。Note: 二进制兼容性保证不适用于Qt快速测试。但是，它将保持源兼容。 Qt Test 用于单元测试 Qt 应用程序和库的类。Note: 二进制兼容性保证不适用于 Qt 测试。但是，它将保持源兼容。 Qt Widgets 使用C++ widget扩展Qt GUI的类。 命名规范和快捷键","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"QT","slug":"编程语言/C/QT","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/QT/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"}]},{"title":"C++学习 Linux系统编程 进程通信","slug":"C++-学习-Linux系统编程-进程通信","date":"2023-05-08T06:24:26.000Z","updated":"2023-05-14T10:58:16.060Z","comments":true,"path":"2023/05/08/C++-学习-Linux系统编程-进程通信/","link":"","permalink":"http://example.com/2023/05/08/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/","excerpt":"进程间通信简介进程间通讯的概念 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。","text":"进程间通信简介进程间通讯的概念 进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程间通信( IPC：Inter Processes Communication )。 进程间通信的目的： 数据传输：一个进程需要将它的数据发送给另一个进程。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 Linux进程间通信方式 匿名管道概述 管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。 统计一个目录中文件的数目命令：ls | wc –l，为了执行该命令，shell 创建了两个进程来分别执行 ls和 wc。 管道的特点 管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据。可以按照操作文件的方式对管道进行操作。 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是半双工的。 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。 匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用。 为什么可以使用管道进行通信 管道的数据结构 pipe函数12345678910#include&lt;unistd.h&gt;int pipe(int pipefd[2]);//功能：创建一个匿名管道，用来进程间通信//参数：//int pipefd[2]这个数组是一个传出参数//pipefd[0]对应的是管道的读端，pipefd[1]对应的是管道的写端//返回值： //成功返回0，失败返回-1//注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）//管道是默认阻塞的，如果管道中没有数据，read阻塞，如果管道满了，write阻塞 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main() &#123; // 在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if (ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if (pid &gt; 0) &#123; // 父进程 printf(&quot;i am prent process, pid : %d\\n&quot;, getpid()); // 关闭写端 close(pipefd[1]); // 从管道的读取端读取数据 char buf[1024] = &#123; 0 &#125;; while (1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;parent recv : %s, pid : %d\\n&quot;, buf, getpid()); // 向管道中写入数据 char * str = &quot;hello,i am parent&quot;; write(pipefd[1], str, strlen(str)); sleep(1); &#125; &#125; else if (pid == 0) &#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); // 关闭读端 close(pipefd[0]); char buf[1024] = &#123; 0 &#125;; while (1) &#123; // 向管道中写入数据 char* str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(1); int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;child recv : %s, pid : %d\\n&quot;, buf, getpid()); // bzero(buf, 1024); &#125; &#125; return 0;&#125; 运行结果如下： 匿名管道的使用 创建匿名管道 12#include&lt;unistd.h&gt;int pipe(int pipefd[2]); 查看管道缓冲大小命令 1ulimit -a 查看管道缓冲大小函数 12#include&lt;unistd.h&gt;long fpathconf(int fd, int name); 123456789101112131415#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123; int pipefd[2]; int ret = pipe(pipefd); long size = fpathconf(pipefd[0], _PC_PIPE_BUF);//获取管道的大小 printf(&quot;pipe size : %ld\\n&quot;, size); return 0;&#125; 编译运行，结果为： 一个案例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 实现ps aux | grep xxx 父子进程之间通信 子进程：ps aux，子进程结束以后，将数据发送给父进程 父进程：获取到数据，过滤 pipe() execlp() 子进程将标准输出stdout_fileno重定向到管道写端。dup2 没有实现过滤功能*/#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;wait.h&gt;int main()&#123; //创建一个管道 int fd[2]; int ret = pipe(fd); if (ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; //创建子进程 pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 //关闭写端 close(fd[1]); //从管道中读取 char buf[1024] = &#123; 0 &#125;; int len = -1; //过滤数据输出 while ((len = read(fd[0], buf, sizeof(buf) - 1)) &gt; 0) &#123; printf(&quot;%s&quot;, buf); memset(buf, 0, 1024); &#125; wait(NULL); &#125; else if (pid == 0) &#123; //子进程 //关闭读端 close(fd[0]); //文件描述符的重定向 stdout_fileno -&gt; fd[1] dup2(fd[1], STDOUT_FILENO); //执行 ps aux execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); perror(&quot;execlp&quot;); exit(0); &#125; else &#123; perror(&quot;fork&quot;); exit(0); &#125; } 运行结果为： 因为管道只有4096bytes，所以运行这个程序只会显示4096bytes，如果要显示所有的信息需要循环往管道中写数据 管道的读写特点和管道设置为非阻塞管道的读写特点： 使用管道时，需要注意以下几种特殊的情况（假设都是阻塞的I&#x2F;O操作） 所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。 如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了，才读取数据并返回。 如果所有指向管道读端的文件描述符都关闭（管道的读端引用计数大于0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE，通常会导致进程异常终止。 如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道在写满时再次write会阻塞，直到管道中有空位置才能写入数据并返回。 总结： 读管道 管道中有数据，read返回实际读到的字节数 管道中无数据： 写端被全部关闭，read返回0，相当于读到文件的末尾 写端没有完全关闭，read阻塞等待 写管道： 管道读端全部关闭，进程异常终止（进程收到SIGPIPE信号） 管道读端没有全部关闭： 管道已满：write阻塞 管道未满：write将数据写入，并返回实际写入的字节数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;/* 设置管道非阻塞 int flags = fcntl(fd[0], F_GETFL); // 获取原来的flag flags |= O_NONBLOCK; // 修改flag的值 fcntl(fd[0], F_SETFL, flags); // 设置新的flag*/int main() &#123; // 在fork之前创建管道 int pipefd[2]; int ret = pipe(pipefd); if(ret == -1) &#123; perror(&quot;pipe&quot;); exit(0); &#125; // 创建子进程 pid_t pid = fork(); if(pid &gt; 0) &#123; // 父进程 printf(&quot;i am parent process, pid : %d\\n&quot;, getpid()); // 关闭写端 close(pipefd[1]); // 从管道的读取端读取数据 char buf[1024] = &#123;0&#125;; int flags = fcntl(pipefd[0], F_GETFL); // 获取原来的flag flags |= O_NONBLOCK; // 修改flag的值 fcntl(pipefd[0], F_SETFL, flags); // 设置新的flag while(1) &#123; int len = read(pipefd[0], buf, sizeof(buf)); printf(&quot;len : %d\\n&quot;, len); printf(&quot;parent recv : %s, pid : %d\\n&quot;, buf, getpid()); memset(buf, 0, 1024); sleep(1); &#125; &#125; else if(pid == 0)&#123; // 子进程 printf(&quot;i am child process, pid : %d\\n&quot;, getpid()); // 关闭读端 close(pipefd[0]); char buf[1024] = &#123;0&#125;; while(1) &#123; // 向管道中写入数据 char * str = &quot;hello,i am child&quot;; write(pipefd[1], str, strlen(str)); sleep(5); &#125; &#125; return 0;&#125; 运行结果为： 匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO），也叫命名管道、FIFO文件。 有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联，以 FIFO 的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与 FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过 FIFO 相互通信，因此，通过 FIFO 不相关的进程也能交换数据。 一旦打开了 FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用了（如read()、write()和close()）。与管道一样，FIFO 也有一个写入端和读取端，并且从管道中读取数据的顺序与写入的顺序是一样的。FIFO 的名称也由此而来：先入先出。 有名管道（FIFO)和匿名管道（pipe）有一些特点是相同的，不一样的地方在于： FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中。 当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用。 FIFO 有名字，不相关的进程可以通过打开有名管道进行通信。 有名管道的使用 通过命令创建有名管道 1mkfifo 名字 通过函数创建有名管道 123#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode); 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可用于fifo。如：close、read、write、unlink等。 FIFO严格遵循先进先出，对管道及FIFO的读总是从开始处返回数据，对它们的写则是把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。 mkfifo命令 mkfifo函数12345678#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;int mkfifo(const char *pathname, mode_t mode);//参数：//- pathname：管道名称路径//- mode：文件的权限，和open的权限是一样的//返回值//成功返回0，失败返回-1，并设置错误号 1234567891011121314#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125;&#125; 有名管道通信案例write.c往管道中写入数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//向管道中写数据#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;string.h&gt;int main()&#123; //1、判断文件是否存在 int ret = access(&quot;test&quot;, F_OK); if (ret == -1) &#123; printf(&quot;管道不存在，创建管道\\n&quot;); //2、创建管道文件 ret = mkfifo(&quot;test&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; //3、以只写的方式打开管道 int fd = open(&quot;test&quot;, O_WRONLY); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //写数据 for (int i = 0;i &lt; 100;i++) &#123; char buf[1024]; sprintf(buf, &quot;hello , %d\\n&quot;, i); printf(&quot;write data : %s\\n&quot;, buf); write(fd, buf, strlen(buf)); sleep(1); &#125; close(fd);&#125; read.c往管道中读数据 123456789101112131415161718192021222324252627282930//向管道中读数据#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //1、打开管道文件 int fd = open(&quot;test&quot;,O_RDONLY); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //读数据 while (1) &#123; char buf[1024] = &#123; 0 &#125;; int len = read(fd, buf, sizeof(buf)); if (len == 0) &#123; printf(&quot;写端断开连接了....\\n&quot;); &#125; printf(&quot;recv buf : %s\\n&quot;, buf); &#125; close(fd);&#125; 运行结果为： 有名管道注意事项 一个为只读而打开的一个管道的进程会阻塞，直到另一个进程为写打开管道 一个为只写而打开一个管道的进程会阻塞，直到另一个进程为只读打开管道 读管道： 管道中有数据，read返回实际读到的字节数 管道中无数据 管道写端被全部关闭，read返回0，（相当于读到文件末尾） 写端没有被全部关闭，read会阻塞等待 写管道： 管道读端被全部关闭，进程会异常终止（收到一个SIGPIPE信号） 管道读端没有全部关闭 管道已经满了，write会阻塞 管道没有满，write将数据写入，并返回实际写入的字节数 有名管道实现简单版聊天功能使用有名管道完成聊天的功能 进程A 以只写的方式打开管道1 以只读的方式打开管道2 循环的写读数据 while(1) { 获取键盘录入fgets 写管道1 读管道2} 进程A 以只写的方式打开管道1 以只读的方式打开管道2 循环的写读数据 while(1) { 读管道1 获取键盘录入fgets} chatA.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.判断有名管道文件是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 2.以只写的方式打开管道fifo1 int fdw = open(&quot;fifo1&quot;, O_WRONLY); if (fdw == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo1成功，等待写入...\\n&quot;); // 3.以只读的方式打开管道fifo2 int fdr = open(&quot;fifo2&quot;, O_RDONLY); if (fdr == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo2成功，等待读取...\\n&quot;); char buf[128]; // 4.循环的写读数据 while (1) &#123; memset(buf, 0, 128); // 获取标准输入的数据 fgets(buf, 128, stdin); // 写数据 ret = write(fdw, buf, strlen(buf)); if (ret == -1) &#123; perror(&quot;write&quot;); exit(0); &#125; // 5.读管道数据 memset(buf, 0, 128); ret = read(fdr, buf, 128); if (ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot;buf: %s\\n&quot;, buf); &#125; // 6.关闭文件描述符 close(fdr); close(fdw); return 0;&#125; chatB.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.判断有名管道文件是否存在 int ret = access(&quot;fifo1&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo1&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; ret = access(&quot;fifo2&quot;, F_OK); if (ret == -1) &#123; // 文件不存在 printf(&quot;管道不存在，创建对应的有名管道\\n&quot;); ret = mkfifo(&quot;fifo2&quot;, 0664); if (ret == -1) &#123; perror(&quot;mkfifo&quot;); exit(0); &#125; &#125; // 2.以只读的方式打开管道fifo1 int fdr = open(&quot;fifo1&quot;, O_RDONLY); if (fdr == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo1成功，等待读取...\\n&quot;); // 3.以只写的方式打开管道fifo2 int fdw = open(&quot;fifo2&quot;, O_WRONLY); if (fdw == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; printf(&quot;打开管道fifo2成功，等待写入...\\n&quot;); char buf[128]; // 4.循环的读写数据 while (1) &#123; // 5.读管道数据 memset(buf, 0, 128); ret = read(fdr, buf, 128); if (ret &lt;= 0) &#123; perror(&quot;read&quot;); break; &#125; printf(&quot;buf: %s\\n&quot;, buf); memset(buf, 0, 128); // 获取标准输入的数据 fgets(buf, 128, stdin); // 写数据 ret = write(fdw, buf, strlen(buf)); if (ret == -1) &#123; perror(&quot;write&quot;); exit(0); &#125; &#125; // 6.关闭文件描述符 close(fdr); close(fdw); return 0;&#125; 运行结果为： 内存映射 内存映射相关系统调用1234567891011121314151617181920212223242526272829#include&lt;sys/mman.h&gt;void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);//功能：//映射或解除映射一个设备到内存中//参数：//- void *addr：NULL，由内核指定//- length：要映射的数据的长度，不能为0，建议使用文件的长度//- int prot：对申请的内存映射区的操作权限// PROT_EXEC：可执行的权限// PROT_WRITE：读权限// PROT_WRITE：写权限// PROT_NONE：没有权限// 要操作映射区内存，必须要有读权限//- flags：// MAP_SHEARED：映射区数据会自动和磁盘文件同步，进程间通信必须要设置这个选项// MAP_PRIVATE：不同步，内存映射区的数据变了，对原来的数据不会修改，会重新创建一个新的文件。（copy on write）//- fd：需要映射的那个文件的文件描述符// 通过open得到，open的是一个磁盘文件// 注意文件大小不能为0，open指定的权限不能和prot参数有冲突// open：只读/读写 prot：PROT_READ// open：读写 prot:PROT_READ | PROT_WRITE//- offset：偏移量，一般不用，必须指定为4K的整数倍，0表示不偏移//- 返回值：返回创建的内存首地址，失败返回MAP_FAILED:(void*)-1 -1int munmap(void *addr, size_t length); int munmap(void *addr, size_t length);//功能：释放内存映射//参数：//- addr：要释放的内存首地址//- length：要释放的内存大小，要和mmap函数中的length参数的值一样 案例：父子进程使用内存映射通信12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//使用内存映射实现进程间通信//1、父子进程// - 还没有子进程的时候// - 通过唯一的父进程创建内存映射区// - 有了内存映射区以后再创建子进程// - 父子进程之间共享创建的内存映射区//2、没有关系的进程间通信// - 准备一个大小不为0的磁盘文件 // - 进程1通过磁盘文件创建内存映射区// - 得到一个操作这块内存的指针// - 进程2通过磁盘文件创建内存映射区// - 得到一个操作这块内存的指针// - 使用内存映射区进行通信//注意内存映射区通信不会阻塞#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;wait.h&gt;int main()&#123; //1、打开一个文件 int fd = open(&quot;test.txt&quot;, O_RDWR); int size = lseek(fd, 0, SEEK_END);//获取文件的大小 //2、创建内存映射区 void* ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //3、创建子进程 pid_t pid = fork(); if (pid &gt; 0) &#123; wait(NULL); //父进程 strcpy((char*)ptr, &quot;hello,child&quot;); &#125; else if (pid == 0) &#123; //子进程 char buf[64]; strcpy(buf, (char*)ptr); printf(&quot;read data : %s\\n&quot;, buf); &#125; //关闭内存映射区 munmap(ptr, size);&#125; 运行结果为： 思考问题 如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功? void* ptr &#x3D; mmap(…); ptr++; 可以对其进行++操作 munmap(ptr,len); 错误 如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样? 错误，会返回MAP_FAILED open()函数中的权限建议prot参数的权限保持一致 如果文件偏移量为1000会怎样? 偏移量必须是4K的整数倍，一般会返回MAP_FAILED mmap什么情况下会调用失败? 第二个参数：length &#x3D; 0 第三个参数： prot - 只指定了写权限 - prot PROT_READ | PROT_WRITE 第五个参数fd通过open函数时指定的O_RDONLY &#x2F; O_WRONLY 可以open的时候O_CREAT一个新文件来创建映射区吗？ 可以，但是如果创建的文件的大小不能为0 可以对新的文件进行拓展 - lseek() - truncate() mmap后关闭文件描述符，对mmap映射有没有影响？ int fd &#x3D; open(“XXX”); mmap(,,,,fd,0); close(fd); 映射区还是存在的，创建映射区的fd被关闭，没有任何影响 对ptr越界操作会怎样？ void* ptr &#x3D; mmap(NULL,100,,,); 4K 越界操作，操作的是非法内存-&gt;段错误 案例：使用内存映射进行文件拷贝1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//使用内存映射实现文件拷贝功能//1、对原始文件进行内存映射//2、创建一个新文件（拓展该文件）//3、把新文件的数据映射到内存中//4、通过内存拷贝将第一个文件的内存数据拷贝到新的文件内存中//5、释放资源#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int main()&#123; //1、对原始文件进行内存映射 int fd = open(&quot;english.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //获取原始文件的大小 int len = lseek(fd, 0, SEEK_END); //2、创建一个新文件 （拓展该文件） int fd1 = open(&quot;cpy.txt&quot;, O_RDWR | O_CREAT,0664); if (fd1 == -1) &#123; perror(&quot;open&quot;); exit(0); &#125; //对新创建的文件进行拓展 truncate(&quot;cpy.txt&quot;, len); write(fd1, &quot; &quot;, 1); //3、分别做内存映射 void* ptr1 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); void* ptr2 = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd1, 0); if (ptr1 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; if (ptr2 == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //内存拷贝 memcpy(ptr2, ptr1, len); //释放资源 munmap(ptr1, len); munmap(ptr2, len); close(fd); close(fd1);&#125; 案例：父子进程使用匿名映射通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//匿名映射：不需要文件实体#include&lt;stdio.h&gt;#include&lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include&lt;unistd.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;wait.h&gt;int main()&#123; //1、创建匿名内存映射区 int len = 4096; void* ptr = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0); if (ptr == MAP_FAILED) &#123; perror(&quot;mmap&quot;); exit(0); &#125; //父子间进程通信 pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 strcpy((char*)ptr, &quot;hello,world&quot;); wait(NULL); &#125; else if (pid == 0) &#123; //子进程 sleep(1); printf(&quot;%s\\n&quot;, (char*)ptr); &#125; //释放内存映射区 int ret = munmap(ptr, len); if (ret == -1) &#123; perror(&quot;munmap&quot;); exit(0); &#125;&#125; 信号概述信号的概念 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下： 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的内存区域。 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU时间超限，或者该进程的某个子进程退出。 运行 kill 命令或调用 kill 函数。 使用信号的两个主要目的是： 让进程知道已经发生了一个特定的事情。 强迫进程执行它自己代码中的信号处理程序。 信号的特点： 简单 不能携带大量信息 满足某个特定条件才发送 优先级比较高 查看系统定义的信号列表：kill -l 前 31 个信号为常规信号，其余为实时信号 重点信号 编号 信号名称 对应事件 默认动作 2 SIGINT 当用户按下了&lt;Ctrl+C&gt;组合键时，用户终端向正 在运行中的由该终端启动的程序发出此信号 终止进程 3 SIGQUIT 用户按下&lt;Ctrl+&gt;组合键时产生该信号，用户终 端向正在运行中的由该终端启动的程序发出些信号 终止进程 9 SIGKILL 无条件终止进程。该信号不能被忽略，处理和阻塞 终止进程，可以杀死任何进程 11 SIGSEGV 指示进程进行了无效内存访问(段错误) 终止进程并产生core文件 13 SIGPIPE Broken pipe向一个没有读端的管道写数据 终止进程 17 SIGCHLD 子进程结束时，父进程会收到这个信号 忽略这个信号 18 SIGCONT 如果进程已停止，则使其继续运行 继续&#x2F;忽略 19 SIGSTOP 停止进程的执行。信号不能被忽略，处理和阻塞 为终止进程 信号的5种默认处理动作 查看信号的详细信息：man 7 signal 信号的5种默认处理动作 Term 终止进程 Ign 当前进程忽略掉这个信号 Core 终止进程，并生成一个Core文件 Stop 暂停当前进程 Cont 继续执行当前被暂停的进程 信号的几种状态：产生、未决、递达 SIGKILL和SIGSTOP信号不能被捕捉、阻塞或者阻塞，只能执行默认动作 Core动作123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char* buf; strcpy(buf, &quot;hello&quot;);&#125; 我们建立一个core.c文件，这个文件肯定是会运行错误的，char* buf是一个野内存，我们访问这个内存是进行了一个非法操作 我们运行 1ulimit -a 查看core文件大小的限制 大小限制为0表示不会生成core文件 运行 1ulimit -c 1024 修改core文件限制，此时我们编译运行core.c文件 发现错误，并且生成了一个core文件，如果没有生成core文件，可能是由于ubuntu预装了apport错误收集系统，运行命令 1sudo service apport stop 再次运行，发现生成了一个core文件 调试一下a.out程序 可以看到core文件中的错误信息 信号相关函数kill函数12345678910111213#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;int kill(pid_t pid,int sig);//功能：给任何进程或进程组，发送任何信号sig//参数：// - pid：需要发送给的进程的pid// &gt;0：将信号发送给指定的进程// =0：将信号发送给当前的进程组// =-1：将信号发送给每一个有权限接受这个信号的进程// &lt;-1：这个pid=某个进程组的id取反// - sig：需要发送的信号或者宏值，0表示不发送任何信号kil(getppid(),9);//给父进程发送一个9号信号kil(getpid(),9);//给自己发送一个9号信号 raise函数1234567int raise(int sig);//功能：给当前的进程发送信号//参数：// - sig：要发送的信号//返回值// - 成功返回0// - 失败返回 abort函数123void abort(void);//功能：发送SIGABRT信号给当前的进程，杀死当前进程kill(getpid,SIGABRT); 案例123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;int main()&#123; pid_t pid = fork(); if (pid == 0) &#123; //子进程 int i = 0; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;chile process\\n&quot;); sleep(1); &#125; &#125; else if (pid &gt; 0) &#123; //父进程 printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); kill(pid, SIGINT); &#125;&#125; 编译运行 12345678910#include&lt;unistd.h&gt;unsigned int alarm(unsigned int seconds);//功能：设置定时器（闹钟），函数调用开始倒计时，当倒计时为0的时候，函数会给当前的进程发送一个信号：SIGALARM//参数：// - seconds：倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发送信号）// 取消一个定时器，通过alarm(0);//返回值：// - 之前没有定时器，返回0// - 之前有定时器，返回之前的定时器剩余的时间//- SIGALARM：默认终止当前的进程，每个进程都有且只有唯一的一个定时器 案例1 123456789101112131415161718192021222324252627#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;int main()&#123; pid_t pid = fork(); if (pid == 0) &#123; //子进程 int i = 0; for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;chile process\\n&quot;); sleep(1); &#125; &#125; else if (pid &gt; 0) &#123; //父进程 printf(&quot;parent process\\n&quot;); sleep(2); printf(&quot;kill child process now\\n&quot;); kill(pid, SIGINT); &#125;&#125; 运行结果为： 案例2 计算一秒钟电脑能数多少个数 123456789101112#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; alarm(1); int i = 0; while (1) &#123; printf(&quot;%d\\n&quot;, i++); &#125;&#125; 运行结果为： 可以运行命令 1./alarm1 &gt;&gt;a.txt 将此文件的输出结果放到a.txt中 实际时间 &#x3D; 内核时间 + 用户时间 +消耗的时间 进行文件IO操作比较浪费时间 定时器与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时 setitimer定时器函数12345678910111213141516171819202122232425#include&lt;sys/time.h&gt;int setitimer(int which, const struct itimerval* new_value, struct itimerval* old_value);//功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，实现周期性定时//参数// - which:定时器以什么时间计时// ITIMER_REAL：真实时间，时间到达，发送SIGALARM信号，常用// ITIMER_VIRTUAL：用户时间，时间到达，发送SIGVTALRM信号// ITIMER_PROF：以该进程在用户态和内核态下所消耗的时间来计算，时间到达发送SIGPROF信号// - new_calue:设置定时器的属性// struct itimerval &#123; //定时器结构体// struct timeval it_interval; /* Interval for periodic timer */ //每个间断的时间// struct timeval it_value; /* Time until next expiration */ //延迟多长时间执行定时器// &#125;;// struct timeval &#123; //时间的结构体// time_t tv_sec; /* seconds */ //秒数// suseconds_t tv_usec; /* microseconds */ //微秒// &#125;;// 过10秒后每个两秒定时一次// - old_value：记录上一次的定时的时间参数，指定NULL//返回值：// - 成功返回0// - 错误返回-1并设置错误号 案例 123456789101112131415161718192021222324#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//过三秒以后每个两秒定时一次int main()&#123; struct itimerval new_value; //设置间隔时间值 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //设置延迟的时间 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL);//非阻塞的 printf(&quot;定时器开始了.....\\n&quot;); if (ret == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; 编译运行 signal信号捕捉函数123456789101112131415161718#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);//一个函数指针sighandler_t signal(int signum, sighandler_t handler);//功能：设置某个信号的捕捉行为//参数：// - signum：要捕捉的信号// - handler：捕捉到信号要如何处理// - SIG_IGN：忽略信号// - SIG_DFL：使用信号默认行为// - 回调函数：这个函数是内核调用，程序员只负责写，捕捉到信号后如何处理信号// - 回调函数需要程序员实现并且提前准备好，函数的类型根据实际需求，一般看函数指针的定义// - 不是程序员调用，而是当信号产生，内核调用// - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置//返回值：// - 成功：返回上一次注册的信号处理函数的地址，第一次调用返回NULL// - 失败：返回SIG_ERR，设置错误号//SIGKILL和SIGSTOP不能被捕捉不能被忽略 案例 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;//过三秒以后每个两秒定时一次void myalarm(int num)&#123; printf(&quot;捕捉到的信号的编号是%d\\n&quot;, num); printf(&quot;---------------------------\\n&quot;);&#125;int main()&#123; //注册信号捕捉 //signal(SIGALRM,SIG_DFL) //signal(SIGALRM, SIG_DFL); __sighandler_t ret = signal(SIGALRM, myalarm); if (ret == SIG_ERR) &#123; perror(&quot;signal&quot;); exit(0); &#125; struct itimerval new_value; //设置间隔时间值 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //设置延迟的时间 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret1 = setitimer(ITIMER_REAL, &amp;new_value, NULL);//非阻塞的 printf(&quot;定时器开始了.....\\n&quot;); if (ret1 == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; 编译运行 信号集及其相关函数 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为信号集的数据结构来表示，其系统数据类型为 sigset_t。 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对 PCB 中的这两个信号集进行修改。 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。 阻塞信号集和未决信号集 1.用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 2.信号产生但是没有被处理 （未决） - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集） - SIGINT信号状态被存储在第二个标志位上 - 这个标志位的值为0， 说明信号不是未决状态 - 这个标志位的值为1， 说明信号处于未决状态 3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较 - 阻塞信号集默认不阻塞任何的信号 - 如果想要阻塞某些信号需要用户调用系统的API 4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了 - 如果没有阻塞，这个信号就被处理 - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理 信号集函数自定义信号集函数123456789101112131415161718192021222324252627282930313233int sigemptyset(sigset_t *set);// - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0// - 参数：set,传出参数，需要操作的信号集// - 返回值：成功返回0， 失败返回-1int sigfillset(sigset_t *set);// - 功能：将信号集中的所有的标志位置为1// - 参数：set,传出参数，需要操作的信号集// - 返回值：成功返回0， 失败返回-1int sigaddset(sigset_t *set, int signum);// - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号// - 参数：// - set：传出参数，需要操作的信号集// - signum：需要设置阻塞的那个信号// - 返回值：成功返回0， 失败返回-1int sigdelset(sigset_t *set, int signum);// - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号// - 参数：// - set：传出参数，需要操作的信号集// - signum：需要设置不阻塞的那个信号// - 返回值：成功返回0， 失败返回-1int sigismember(const sigset_t *set, int signum);// - 功能：判断某个信号是否阻塞// - 参数：// - set：需要操作的信号集// - signum：需要判断的那个信号// - 返回值：// 1 ： signum被阻塞// 0 ： signum不阻塞// -1 ： 失败 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;signal.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个信号集 sigset_t set; //清空信号集的内容 sigemptyset(&amp;set); //判断SIGINT是否在set里面 int ret = sigismember(&amp;set, SIGINT); if (ret == 0) &#123; printf(&quot;SIGINT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGINT阻塞\\n&quot;); &#125; //添加几个信号到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); //判断SIGINT是否在信号集中 ret = sigismember(&amp;set, SIGINT); if (ret == 0) &#123; printf(&quot;SIGINT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGINT阻塞\\n&quot;); &#125; //判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if (ret == 0) &#123; printf(&quot;SIGQUIT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGQUIT阻塞\\n&quot;); &#125; //从信号集中删除一个信号 sigdelset(&amp;set, SIGQUIT); //判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if (ret == 0) &#123; printf(&quot;SIGQUIT不阻塞\\n&quot;); &#125; else if (ret == 1) &#123; printf(&quot;SIGQUIT阻塞\\n&quot;); &#125;&#125; 编译运行 系统信号集函数1234567891011121314151617181920int sigprocmask(int how, const sigset_t* set, sigset_t* oldset);// -功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）// - 参数：// - how : 如何对内核阻塞信号集进行处理// SIG_BLOCK : 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变// 假设内核中默认的阻塞信号集是mask， mask | set// SIG_UNBLOCK : 根据用户设置的数据，对内核中的数据进行解除阻塞// mask &amp;= ~set// SIG_SETMASK : 覆盖内核中原来的值// - set ：已经初始化好的用户自定义的信号集// - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL// - 返回值：// 成功：0// 失败： - 1// 设置错误号：EFAULT、EINVALint sigpending(sigset_t * set);// - 功能：获取内核中的未决信号集// - 参数：set, 传出参数，保存的是内核中的未决信号集中的信息。 案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//编写一个程序，把所有的常规信号（1 - 31）的未决状态打印到屏幕//设置某些信号是阻塞的，通过键盘产生这些信号#include&lt;stdio.h&gt;#include&lt;signal.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;int main()&#123; //设置2、3号信号阻塞 sigset_t set; sigemptyset(&amp;set); //将2号和3号信号添加到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); //修改内核中的阻塞信号集 sigprocmask(SIG_BLOCK, &amp;set, NULL); while (1) &#123; //获取当前的未决信号集的数据 sigset_t pendingset; sigemptyset(&amp;pendingset); sigpending(&amp;pendingset); //遍历前32位 for (int i = 1;i &lt;= 32;i++) &#123; if (sigismember(&amp;pendingset, i) == 1) &#123; printf(&quot;1&quot;); &#125; else if (sigismember(&amp;pendingset, i) == 0) &#123; printf(&quot;0&quot;); &#125; else &#123; perror(&quot;sigismember&quot;); exit(0); &#125; &#125; printf(&quot;\\n&quot;); sleep(1); &#125;&#125; 编译运行 sigaction信号捕捉函数1234567891011121314151617181920212223242526#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction* act, struct sigaction* oldact);// -功能：检查或者改变信号的处理。信号捕捉// - 参数：// - signum : 需要捕捉的信号的编号或者宏值（信号的名称）// - act ：捕捉到信号之后的处理动作// - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL// - 返回值：// 成功 0// 失败 - 1struct sigaction &#123; // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t*, void*); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void);&#125;; 案例 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;sys/time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;signal.h&gt;//过三秒以后每个两秒定时一次void myalarm(int num)&#123; printf(&quot;捕捉到的信号的编号是%d\\n&quot;, num); printf(&quot;---------------------------\\n&quot;);&#125;int main()&#123; struct sigaction act; act.sa_flags = 0; act.sa_handler = myalarm; sigemptyset(&amp;act.sa_mask);//清空临时阻塞信号集 sigaction(SIGALRM, &amp;act, NULL); struct itimerval new_value; //设置间隔时间值 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; //设置延迟的时间 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret1 = setitimer(ITIMER_REAL, &amp;new_value, NULL);//非阻塞的 printf(&quot;定时器开始了.....\\n&quot;); if (ret1 == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar();&#125; 编译运行： 内核信号被捕捉的过程 SIGCHID信号 SIGCHLD信号产生的条件 子进程终止时 子进程接收到 SIGSTOP 信号停止时 子进程处在停止态，接受到SIGCONT后唤醒时 以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;signal.h&gt;#include&lt;wait.h&gt;void myFun(int num)&#123; printf(&quot;捕捉到的信号:%d\\n&quot;, num); //回收子进程PCB的资源 while (1) &#123; int ret = waitpid(-1, NULL, WNOHANG); if (ret &gt; 0) &#123; printf(&quot;child die , pid = %d \\n&quot;, ret); &#125; else if (ret == 0) &#123; //说明还有子进程活着 break; &#125; &#125;&#125;int main()&#123; //提前设置好阻塞信号集，阻塞SIGCHLD，因为可能子进程很快结束，父进程还没有注册完信号捕捉 sigset_t set; sigemptyset(&amp;set); sigaddset(&amp;set, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;set, NULL); pid_t pid; for (int i = 0;i &lt; 20;i++) &#123; pid = fork(); if (pid == 0) &#123; break; &#125; &#125; if (pid &gt; 0) &#123; //父进程 //捕捉子进程死亡时发送的SIGCHLD信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = myFun; sigemptyset(&amp;act.sa_mask); sigaction(SIGCHLD, &amp;act, NULL); //注册完信号捕捉以后，解除阻塞 sigprocmask(SIG_UNBLOCK, &amp;set, NULL); while (1) &#123; printf(&quot;parent process pid : %d\\n&quot;, getpid()); sleep(2); &#125; &#125; else if (pid == 0) &#123; //子进程 printf(&quot;child process pid : %d\\n&quot;, getpid()); &#125;&#125; 编译运行 共享内存 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种 IPC 技术的速度更快。 共享内存使用步骤 调用 shmget() 创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 使用 shmat() 来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。 共享内存相关的函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//共享内存相关的函数#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg); // - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。 // 新创建的内存段中的数据都会被初始化为0 // - 参数： // - key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。 // 一般使用16进制表示，非0值 // - size: 共享内存的大小 // - shmflg: 属性 // - 访问权限 // - 附加属性：创建/判断共享内存是不是存在 // - 创建：IPC_CREAT // - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用 // IPC_CREAT | IPC_EXCL | 0664 // - 返回值： // 失败：-1 并设置错误号 // 成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。void *shmat(int shmid, const void *shmaddr, int shmflg); // - 功能：和当前的进程进行关联 // - 参数： // - shmid : 共享内存的标识（ID）,由shmget返回值获取 // - shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定 // - shmflg : 对共享内存的操作 // - 读 ： SHM_RDONLY, 必须要有读权限 // - 读写： 0 // - 返回值： // 成功：返回共享内存的首（起始）地址。 失败(void *) -1int shmdt(const void *shmaddr); // - 功能：解除当前进程和共享内存的关联 // - 参数： // shmaddr：共享内存的首地址 // - 返回值：成功 0， 失败 -1int shmctl(int shmid, int cmd, struct shmid_ds *buf); // - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。 // - 参数： // - shmid: 共享内存的ID // - cmd : 要做的操作 // - IPC_STAT : 获取共享内存的当前的状态 // - IPC_SET : 设置共享内存的状态 // - IPC_RMID: 标记共享内存被销毁 // - buf：需要设置或者获取的共享内存的属性信息 // - IPC_STAT : buf存储数据 // - IPC_SET : buf中需要初始化数据，设置到内核中 // - IPC_RMID : 没有用，NULLkey_t ftok(const char *pathname, int proj_id); // - 功能：根据指定的路径名，和int值，生成一个共享内存的key // - 参数： // - pathname:指定一个存在的路径 // - proj_id: int类型的值，但是这系统调用只会使用其中的1个字节 // 范围 ： 0-255 一般指定一个字符 &#x27;a&#x27; 案例：使用共享内存进行通信write.c 12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;string.h&gt;int main()&#123; //1、创建一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT | 0664); printf(&quot;shmid : %d\\n&quot;, shmid); //2、和当前进程进行关联 void* ptr = shmat(shmid, NULL, 0); char* str = &quot;hello world&quot;; //3、写数据 memcpy(ptr, str, strlen(str) + 1); printf(&quot;按任意键继续\\n&quot;); getchar(); //4、解除关联 shmdt(ptr); //5、删除共享内存 shmctl(shmid, IPC_RMID, NULL);&#125; read.c 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;sys/ipc.h&gt;#include&lt;sys/shm.h&gt;#include&lt;string.h&gt;int main()&#123; //1、获取一个共享内存 int shmid = shmget(100, 0, IPC_CREAT); printf(&quot;shmid : %d\\n&quot;, shmid); //2、和当前进程进行关联 void* ptr = shmat(shmid, NULL, 0); //3、读数据 printf(&quot;%s\\n&quot;, (char*)ptr); printf(&quot;按任意键继续\\n&quot;); getchar(); //4、解除关联 shmdt(ptr); //5、删除共享内存 shmctl(shmid, IPC_RMID, NULL);&#125; 分别编译运行 思考问题 问题1：操作系统如何知道一块共享内存被多少个进程关联？ - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch - shm_nattach 记录了关联的进程个数 问题2：可不可以对共享内存进行多次删除 shmctl - 可以的 - 因为shmctl 标记删除共享内存，不是直接删除 - 什么时候真正删除呢? 当和共享内存关联的进程数为0的时候，就真正被删除 - 当共享内存的key为0的时候，表示共享内存被标记删除了 如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 共享内存和内存映射的区别 1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 2.共享内存效果更高 3.内存 所有的进程操作的是同一块共享内存。 内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 4.数据安全 - 进程突然退出 共享内存还存在 内存映射区消失 - 运行进程的电脑死机，宕机了 数据存在在共享内存中，没有了 内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 5.生命周期 - 内存映射区：进程退出，内存映射区销毁 - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机 如果一个进程退出，会自动和共享内存进行取消关联。 共享内存操作命令 ipcs 用法 ipcs -a &#x2F;&#x2F; 打印当前系统中所有的进程间通信方式的信息 ipcs -m &#x2F;&#x2F; 打印出使用共享内存进行进程间通信的信息 ipcs -q &#x2F;&#x2F; 打印出使用消息队列进行进程间通信的信息 ipcs -s &#x2F;&#x2F; 打印出使用信号进行进程间通信的信息 ipcrm 用法 ipcrm -M shmkey &#x2F;&#x2F; 移除用shmkey创建的共享内存段 ipcrm -m shmid &#x2F;&#x2F; 移除用shmid标识的共享内存段 ipcrm -Q msgkey &#x2F;&#x2F; 移除用msqkey创建的消息队列 ipcrm -q msqid &#x2F;&#x2F; 移除用msqid标识的消息队列 ipcrm -S semkey &#x2F;&#x2F; 移除用semkey创建的信号 ipcrm -s semid &#x2F;&#x2F; 移除用semid标识的信号 守护进程终端 在 UNIX 系统中，用户通过终端登录系统后得到一个 shell 进程，这个终端成为 shell 进程的控制终端（Controlling Terminal），进程中，控制终端是保存在 PCB 中的信息，而 fork() 会复制 PCB 中的信息，因此由 shell 进程启动的其它进程的控制终端也是这个终端。 可以通过命令 1echo $$ 查看当前shell的进程号 默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。 在控制终端输入一些特殊的控制键可以给前台进程发信号，例如 Ctrl + C 会产生 SIGINT 信号，Ctrl + \\ 会产生 SIGQUIT 信号 进程组 进程组和会话在进程之间形成了一种两级层次关系：进程组是一组相关进程的集合，会话是一组相关进程组的集合。进程组和会话是为支持 shell 作业控制而定义的抽象概念，用户通过 shell 能够交互式地在前台或后台运行命令。 进行组由一个或多个共享同一进程组标识符（PGID）的进程组成。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，新进程会继承其父进程所属的进程组 ID。 进程组拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员。 会话 会话是一组进程组的集合。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。新进程会继承其父进程的会话 ID。 一个会话中的所有进程共享单个控制终端。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。 在任一时刻，会话中的其中一个进程组会成为终端的前台进程组，其他进程组会成为后台进程组。只有前台进程组中的进程才能从控制终端中读取输入。当用户在控制终端中输入终端字符生成信号后，该信号会被发送到前台进程组中的所有成员。 当控制终端的连接建立起来之后，会话首进程会成为该终端的控制进程。 进程组、会话、控制终端之间的关系 运行的命令为： find / 2 &gt; /dev/null | wc -l &amp; sort &lt; longlist | uniq -c 进程组、会话操作函数12345pid_t getpgrp(void); //获取当前进程的进程组IDpid_t getpgid(pid_t pid); //获取指定进程的进程组IDint setpgid(pid_t pid, pid_t pgid); //设置进程组的IDpid_t getsid(pid_t pid); //获取指定进程的会话的IDpid_t setsid(void); //设置进程的会话ID 守护进程 守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），Linux 中的后台服务进程。它是一个生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以 d 结尾的名字。 守护进程具备下列特征： 生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。 它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号（如 SIGINT、SIGQUIT）。 Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等 守护进程创建步骤 执行一个 fork()，之后父进程退出，子进程继续执行。 子进程调用 setsid() 开启一个新会话。 清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限。 修改进程的当前工作目录，通常会改为根目录（&#x2F;）。 关闭守护进程从其父进程继承而来的所有打开着的文件描述符。 在关闭了文件描述符0、1、2之后，守护进程通常会打开&#x2F;dev&#x2F;null 并使用dup2() 使所有这些描述符指向这个设备。 核心业务逻辑 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* 写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。*/#include &lt;stdio.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/time.h&gt;#include &lt;signal.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void work(int num) &#123; // 捕捉到信号之后，获取系统时间，写入磁盘文件 time_t tm = time(NULL); struct tm* loc = localtime(&amp;tm); // char buf[1024]; // sprintf(buf, &quot;%d-%d-%d %d:%d:%d\\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon // ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec); // printf(&quot;%s\\n&quot;, buf); char* str = asctime(loc); int fd = open(&quot;time.txt&quot;, O_RDWR | O_CREAT | O_APPEND, 0664); write(fd, str, strlen(str)); close(fd);&#125;int main() &#123; // 1.创建子进程，退出父进程 pid_t pid = fork(); if (pid &gt; 0) &#123; exit(0); &#125; // 2.将子进程重新创建一个会话 setsid(); // 3.设置掩码 umask(022); // 4.更改工作目录 chdir(&quot;/home/plucky/Linux/lecture27&quot;); // 5. 关闭、重定向文件描述符 int fd = open(&quot;/dev/null&quot;, O_RDWR); dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); // 6.业务逻辑 // 捕捉定时信号 struct sigaction act; act.sa_flags = 0; act.sa_handler = work; sigemptyset(&amp;act.sa_mask); sigaction(SIGALRM, &amp;act, NULL); struct itimerval val; val.it_value.tv_sec = 2; val.it_value.tv_usec = 0; val.it_interval.tv_sec = 2; val.it_interval.tv_usec = 0; // 创建定时器 setitimer(ITIMER_REAL, &amp;val, NULL); // 不让进程结束 while (1) &#123; sleep(10); &#125; return 0;&#125; 编译运行 因为是守护进程，所以会新建一个会话，我们从控制终端上进行的操作不会影响到守护进程的执行，只能通过kill命令杀死守护进程","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"C++学习 模板","slug":"C++-学习-模板","date":"2023-05-07T11:42:34.000Z","updated":"2023-05-09T11:17:37.233Z","comments":true,"path":"2023/05/07/C++-学习-模板/","link":"","permalink":"http://example.com/2023/05/07/C++-%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF/","excerpt":"模板的概念模板就是建立一个通用的模具，大大提高复用性 模板的特点：","text":"模板的概念模板就是建立一个通用的模具，大大提高复用性 模板的特点： 不能直接使用，他只是一个框架 模板的通用并不是万能的 函数模板 C++另一种编程思想称为泛型编程，主要利用的技术就是模板 C++提供两种模板机制：函数模板和类模板 函数模板语法函数模板作用： 建立一个通用函数，其函数返回值类型和形参类型可以不具体指定用一个虚拟的类型来代表 语法 12template&lt;typename T&gt;函数声明或定义 解释 template — 声明创建模板 typename — 表明其后面的符号是一种符号类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//函数模板//两个整形交换函数void swapInt(int&amp; a, int&amp; b)&#123; int temp = a; a = b; b = temp;&#125;//交换两个浮点型函数void swapDouble(double&amp; a, double&amp; b)&#123; double temp = a; a = b; b = temp;&#125;//函数模板template&lt;typename T&gt;//声明一个模板，告诉编译器后面代码中紧跟着的T不要报错，T是一个通用数据类型void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;void test01()&#123; int a = 10; int b = 20; swapInt(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //利用函数模板，两种方式使用 //1、自动类型推导 mySwap(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; //显式指定类型 mySwap&lt;int&gt;(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; double c = 1.1; double d = 2.2; swapDouble(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; mySwap(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl; //显式指定类型 mySwap&lt;double&gt;(c, d); cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;d = &quot; &lt;&lt; d &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 总结 函数模板利用关键字template 使用函数模板有两种方式：自动类型推导，显示指定类型 模板的目的是为了提高复用性，将类型参数化 函数模板注意事项注意事项： 自动类型推导，必须推导出一致的数据类型T才可以使用 模板必须要确定出T的数据类型，才可以使用 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//函数模板注意事项template&lt;typename T&gt;//typename可以替换成classvoid mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;//1、自动类型推导，必须推导出一致的数据类型T才可以使用void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b);//正确； cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; mySwap(a, c);//错误&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//函数模板注意事项template&lt;typename T&gt;//typename可以替换成classvoid mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;//1、自动类型推导，必须推导出一致的数据类型T才可以使用void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; mySwap(a, b);//正确； cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;//2、模板必须要确定出T的数据类型，才可以使用 template&lt;typename T&gt;void func()&#123; cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;&#125;void test02()&#123; func();&#125;int main()&#123; test01(); test02();&#125; 函数模板案例案例描述 利用函数模板封装一个排序的函数，可以对不同数据类型的数组进行排序 排序规则从大到小，排序算法为选择排序 分别利用char数组和int数组进行测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;template&lt;class T&gt;void mySwap(T&amp; a, T&amp; b)&#123; T temp = a; a = b; b = temp;&#125;template&lt;class T&gt;void mySort(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; int max = i; for (int j = i + 1; j &lt; len; j++) &#123; if (arr[max] &lt; arr[j]) &#123; max = j; &#125; &#125; if (max != i) &#123; mySwap(arr[max], arr[i]); &#125; &#125;&#125;template&lt;class T&gt;void printArray(T arr[], int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;void test01()&#123; char charArr[] = &quot;badcfe&quot;; int num = sizeof(charArr) / sizeof(char); mySort(charArr, num); printArray(charArr, num);&#125;void test02()&#123; int intArr[] = &#123; 7,5,1,9,2,4,6,8 &#125;; int num = sizeof(intArr) / sizeof(int); mySort(intArr, num); printArray(intArr, num);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： f e d c b a9 8 7 6 5 4 2 1 普通函数和函数模板的区别 普通函数调用时可以发生自动类型转换（隐式类型转换） 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换 如果利用显示指定类型的方式，可以发生隐式类型转换 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板区别//1、普通函数调用可以发生隐式类型转换//2、函数模板用自动类型推导，不可以发生隐式类型转换//3、函数模板用显示指定类型，可以发生隐式类型转换//普通函数int myAdd01(int a, int b)&#123; return a + b;&#125;//函数模板template&lt;class T&gt;T myAdd02(T a, T b)&#123; return a + b;&#125;void test01()&#123; int a = 10; int b = 20; char c = &#x27;c&#x27;; cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //自动类型推导 不会发生隐式类型转换 //cout &lt;&lt; myAdd02(a, c) &lt;&lt; endl; //显示指定类型 会发生隐式类型转换 cout &lt;&lt; myAdd02&lt;int&gt;(a, c) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： 109109 普通函数与函数模板的调用规则调用规则如下： 如果函数模板和普通函数都可以实现，优先调用普通函数 可以通过空模板参数列表来强制调用函数模板 函数模板也可以发生重载 如果函数模板可以更好的匹配，有限调用函数模板 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; myPrint(a, b);&#125;int main()&#123; test01();&#125; 运行结果为： 调用的普通函数 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b);template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; //通过空模板参数列表，强制调用函数模板 myPrint&lt;&gt;(a, b);&#125;int main()&#123; test01();&#125; 运行结果为： 调用的模板 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b, T c)&#123; cout &lt;&lt; &quot;调用的重载模板&quot; &lt;&lt; endl;&#125;void test01()&#123; int a = 10; int b = 20; myPrint(a, b, 100);&#125;int main()&#123; test01();&#125; 运行的结果为： 调用的重载模板 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//普通函数与函数模板的调用规则//1、如果函数模板和普通函数都可以调用，优先调用普通函数//2、可以通过空模板参数列表强制调用函数模板//3、函数模板可以发生函数重载//4、如果函数模板可以更好的匹配，优先调用函数模板void myPrint(int a, int b)&#123; cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b)&#123; cout &lt;&lt; &quot;调用的模板&quot; &lt;&lt; endl;&#125;template&lt;class T&gt;void myPrint(T a, T b, T c)&#123; cout &lt;&lt; &quot;调用的重载模板&quot; &lt;&lt; endl;&#125;void test01()&#123; //如果函数模板产生更好的匹配，优先调用函数模板 char c1 = &#x27;a&#x27;; char c2 = &#x27;b&#x27;; myPrint(c1, c2);&#125;int main()&#123; test01();&#125; 运行结果为： 调用的模板 模板的局限性模板并不是万能的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//模板的局限性//模板并不是万能的，有些特定数据，需要具体化方式做特殊实现class Person&#123;public: Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;//对比两个数据是否相等函数template&lt;class T&gt;bool myCompare(T&amp; a, T&amp; b)&#123; if (a == b) &#123; return true; &#125; else &#123; return false; &#125;&#125;//利用具体化Person的版本实现代码，具体化优先调用template&lt;&gt; bool myCompare(Person&amp; a, Person&amp; b)&#123; if (a.m_Age == b.m_Age &amp;&amp; a.m_Name == b.m_Name) return true; else return false;&#125;void test01()&#123; int a = 10; int b = 20; bool ret = myCompare(a, b); if (ret) &#123; cout &lt;&lt; &quot;a == b&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;a != b&quot; &lt;&lt; endl; &#125;&#125;void test02()&#123; Person p1(&quot;Tom&quot;, 10); Person p2(&quot;Tom&quot;, 10); bool ret = myCompare(p1, p2); if (ret) &#123; cout &lt;&lt; &quot;p1 == p2&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1 != p2&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： a !&#x3D; bp1 &#x3D;&#x3D; p2 总结： 利用具体化的模板，可以解决自定义类型的通用化 学习模板不是为了写模板，而是在STL能够运用系统提供的模板 类模板类模板语法类模板作用： 建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板template&lt;class NameType,class AgeType&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; NameType m_Name; AgeType m_Age;&#125;;void test01()&#123; Person&lt;string, int&gt; p1(&quot;孙悟空&quot;, 999); p1.showPerson();&#125;int main()&#123; test01();&#125; 运行结果为： name: 孙悟空 age: 999 类模板和函数模板的区别类模板与函数模板区别主要有两点 类模板没有自动类型推导的使用方式 类模板在模板参数列表中可以有默认参数 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板template&lt;class NameType,class AgeType = int&gt;class Person&#123;public: Person(NameType name, AgeType age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; NameType m_Name; AgeType m_Age;&#125;;//1、类模板没有自动类型推导使用方式void test01()&#123; Person&lt;string&gt;p(&quot;孙悟空&quot;, 999); p.showPerson();&#125;int main()&#123; test01();&#125;int main()&#123; test01();&#125; 运行结果为： name: 孙悟空 age: 999 类模板中成员函数创建时机类模板中成员函数和普通类中成员函数创建时机是有区别的： 普通类中的成员一开始就可以创建 类模板中的成员函数在调用时才创建 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;class Person1&#123;public: void showPerson1() &#123; cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl; &#125;&#125;;class Person2&#123;public: void showPerson2() &#123; cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl; &#125;&#125;;template&lt;class T&gt;class Myclass&#123;public: T obj; //类模板中的成员函数 void func1() &#123; obj.showPerson1(); &#125; void func2() &#123; obj.showPerson2(); &#125;&#125;;void test01()&#123; Myclass&lt;Person1&gt;m; m.func1(); //m.func2();&#125;int main()&#123; test01();&#125; 运行结果为： Person1 show 类模板对象做函数参数类模板实例化出的对象，像函数传参的方式 一共有三种传入方式： 指定传入的类型 – 直接显示对象的数据类型（最常用） 参数模板化 – 将对象中的参数变为模板进行传递 整个类模板化 – 将这个对象类型模板化进行传递 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板对象做函数参数template&lt;class T1,class T2&gt;class Person&#123;public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; void showPerson() &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl; &#125; T1 m_Name; T2 m_Age;&#125;;//1、指定传入类型void printPerson1(Person&lt;string,int&gt;&amp;p)&#123; p.showPerson();&#125;void test01()&#123; Person &lt;string, int&gt;p(&quot;孙悟空&quot;, 999); printPerson1(p);&#125;//2、参数模板化template&lt;class T1,class T2&gt;void printPerson2(Person&lt;T1, T2&gt;&amp;p)&#123; p.showPerson(); cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;&#125;void test02()&#123; Person&lt;string, int&gt;p(&quot;猪八戒&quot;, 888); printPerson2(p);&#125;//3、整个类模板化template&lt;class T&gt;void printPerson3(T&amp; p)&#123; p.showPerson(); cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;&#125;void test03()&#123; Person&lt;string, int&gt;p(&quot;唐僧&quot;, 30); printPerson3(p);&#125;int main()&#123; test01(); test02(); test03();&#125; 运行结果为： 姓名： 孙悟空 年龄： 999姓名： 猪八戒 年龄： 888T1的类型为： class std::basic_string&lt;char,struct std::char_traits,class std::allocator &gt;T2的类型为： int姓名： 唐僧 年龄： 30T的类型为： class Person&lt;class std::basic_string&lt;char,struct std::char_traits,class std::allocator &gt;,int&gt; 类模板与继承当类模板碰到继承时，需要注意以下几点： 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型 如果不指定，编译器无法给子类分配内存 如果想灵活指定出父类中T的类型，子类也需变为类模板 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板与继承template&lt;class T&gt;class Base&#123; T m;&#125;;class Son :public Base&lt;int&gt;//必须要指导父类中的类型，才能继承给子类&#123;&#125;;void test01()&#123; Son s1;&#125;//如果想灵活指定父类中T的类型，子类也需要变为类模板template&lt;class T1,class T2&gt;class Son2 :public Base&lt;T2&gt;&#123; public: Son2() &#123; cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl; cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl; &#125; T1 obj;&#125;;void test02()&#123; Son2&lt;int, char&gt;s2;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： T1的类型为： intT2的类型为： char 类模板成员函数类外实现学习目标：能够掌握类模板中的成员函数的类外实现 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//类模板成员函数类外实现template&lt;class T1,class T2&gt;class Person&#123;public: Person(T1 name, T2 age); void showPerson(); T1 m_Name; T2 m_Age;&#125;;//构造函数的类外实现template&lt;class T1,class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;//成员函数的类外实现template&lt;class T1,class T2&gt;void Person&lt;T1, T2&gt;::showPerson()&#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125;void test01()&#123; Person&lt;string, int&gt; P(&quot;Tom&quot;, 20); P.showPerson();&#125;int main()&#123; test01();&#125; 运行结果为： 姓名： Tom 年龄： 20 类模板分文件编写掌握类模板成员函数分文件编写产生的问题以及解决方式 问题： 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到 解决： 解决方式1：直接包含.cpp源文件 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制 person.h 123456789101112#pragma once#include&lt;iostream&gt;using namespace std;template&lt;class T1, class T2&gt;class Person&#123;public: Person(T1 name, T2 age); void showPerson(); T1 m_Name; T2 m_Age;&#125;; test.cpp 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include&lt;string&gt;//第一种解决方式，直接包含源文件#include&quot;person.cpp&quot;//第二种解决方式，将.h和.cpp中的内容写到一起，将文件命名为.hpp文件using namespace std;//类模板份分文件编写问题以及解决//template&lt;class T1,class T2&gt;//class Person//&#123;//public:// Person(T1 name, T2 age);// void showPerson();// T1 m_Name;// T2 m_Age;//&#125;;//template&lt;class T1,class T2&gt;//Person&lt;T1, T2&gt;::Person(T1 name, T2 age)//&#123;// this-&gt;m_Name = name;// this-&gt;m_Age = age;//&#125;//template&lt;class T1,class T2&gt;//void Person&lt;T1,T2&gt;::showPerson()//&#123;// cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;//&#125;void test01()&#123; Person&lt;string, int&gt; p(&quot;Jerry&quot;, 18); p.showPerson();&#125;int main()&#123; test01();&#125; person.cpp 123456789101112131415#include&lt;iostream&gt;#include&quot;person.h&quot;template&lt;class T1, class T2&gt;Person&lt;T1, T2&gt;::Person(T1 name, T2 age)&#123; this-&gt;m_Name = name; this-&gt;m_Age = age;&#125;template&lt;class T1, class T2&gt;void Person&lt;T1, T2&gt;::showPerson()&#123; cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; this-&gt;m_Name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; this-&gt;m_Age &lt;&lt; endl;&#125; 类模板和友元掌握类模板配合友元函数的类内和类外实现 全局函数类内实现 - 直接在类内声明友元即可 全局函数类外实现 - 需要提前让编译器知道全局函数的存在 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;//通过全局函数 打印Person信息//提前让编译器知道Person类存在template&lt;class T1, class T2&gt;class Person;//类外实现template&lt;class T1, class T2&gt;void printPerson2(Person&lt;T1, T2&gt;p)&#123; cout &lt;&lt; &quot;类外实现 -- 姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;&#125;template&lt;class T1,class T2&gt;class Person&#123; //全局函数 类内实现 friend void printPerson1(Person&lt;T1, T2&gt; p) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl; &#125; //全局函数 类外实现 //加空模板参数列表 //如果全局函数是类外实现，需要让编译器提前知道这个函数的存在 friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; p);public: Person(T1 name, T2 age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125;private: T1 m_Name; T2 m_Age;&#125;;//1、全局函数在类内实现void test01()&#123; Person&lt;string, int&gt;p(&quot;Tom&quot;, 20); printPerson1(p);&#125;//2、全局函数在类外实现void test02()&#123; Person&lt;string, int&gt;p(&quot;Tom&quot;, 20); printPerson2(p);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： 姓名： Tom 年龄： 20类外实现 – 姓名： Tom 年龄： 20 类模板案例实现一个通用的数组类，要求如下： 可以对内置的数据类型以及自定义数据类型的数据进行存储 将数组中的数据存储到堆区 构造函数中可以传入数组的容量 提供对应的拷贝构造函数以及operator&#x3D;防止浅拷贝问题 提供尾插法和尾删法对数组中的数据进行增加和删除 可以通过下标的方式访问数组中的元素 可以获取数组中当前元素个数和数组的容量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include&lt;string&gt;#include &quot;MyArray.hpp&quot;using namespace std;void printIntArray(MyArray&lt;int&gt;&amp;arr)&#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;//测试自定义数据类型class Person&#123;public: Person() &#123;&#125;; Person(string name, int age) &#123; this-&gt;m_Name = name; this-&gt;m_Age = age; &#125; string m_Name; int m_Age;&#125;;void printPersonArray(MyArray&lt;Person&gt;&amp; arr)&#123; for (int i = 0; i &lt; arr.getSize(); i++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; arr[i].m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; arr[i].m_Age &lt;&lt; endl; &#125;&#125;void test01()&#123; MyArray&lt;int&gt;arr1(5); for (int i = 0; i &lt; 5; i++) &#123; arr1.push_back(i); &#125; cout &lt;&lt; &quot;arr1的打印输出为： &quot; &lt;&lt; endl; printIntArray(arr1); cout &lt;&lt; &quot;arr1的容量为： &quot; &lt;&lt; arr1.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;arr1的大小为： &quot; &lt;&lt; arr1.getSize() &lt;&lt; endl; MyArray&lt;int&gt;arr2(arr1); cout &lt;&lt; &quot;arr2的打印输出为： &quot; &lt;&lt; endl; printIntArray(arr2); //尾删 arr2.pop_back(); cout &lt;&lt; &quot;arr2尾删后的打印输出为： &quot; &lt;&lt; endl; printIntArray(arr2); MyArray&lt;int&gt;arr3(100); arr3 = arr1;&#125;void test02()&#123; MyArray&lt;Person&gt;arr(10); Person p1(&quot;刘备&quot;, 999); Person p2(&quot;关羽&quot;, 800); Person p3(&quot;张飞&quot;, 700); Person p4(&quot;赵云&quot;, 800); Person p5(&quot;诸葛亮&quot;, 800); //将数据插入到数组中 arr.push_back(p1); arr.push_back(p2); arr.push_back(p3); arr.push_back(p4); arr.push_back(p5); cout &lt;&lt; &quot;arr的打印输出为：&quot; &lt;&lt; endl; printPersonArray(arr); cout &lt;&lt; &quot;arr的容量为： &quot; &lt;&lt; arr.getCapacity() &lt;&lt; endl; cout &lt;&lt; &quot;arr的大小为： &quot; &lt;&lt; arr.getSize() &lt;&lt; endl; arr.pop_back(); cout &lt;&lt; &quot;arr尾删后的打印输出为： &quot; &lt;&lt; endl; printPersonArray(arr);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： MyArray的有参构造调用arr1的打印输出为：01234arr1的容量为： 5arr1的大小为： 5MyArray的拷贝构造调用arr2的打印输出为：01234arr2尾删后的打印输出为：0123MyArray的有参构造调用MyArray的operator&#x3D;调用MyArray的析构函数调用MyArray的析构函数调用MyArray的析构函数调用MyArray的有参构造调用arr的打印输出为：姓名： 刘备 年龄： 999姓名： 关羽 年龄： 800姓名： 张飞 年龄： 700姓名： 赵云 年龄： 800姓名： 诸葛亮 年龄： 800arr的容量为： 10arr的大小为： 5arr尾删后的打印输出为：姓名： 刘备 年龄： 999姓名： 关羽 年龄： 800姓名： 张飞 年龄： 700姓名： 赵云 年龄： 800MyArray的析构函数调用","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 文件操作","slug":"C++-学习-文件操作","date":"2023-05-05T11:24:25.000Z","updated":"2023-05-09T08:11:31.953Z","comments":true,"path":"2023/05/05/C++-学习-文件操作/","link":"","permalink":"http://example.com/2023/05/05/C++-%E5%AD%A6%E4%B9%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件","text":"程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放 通过文件可以将数据持久化 C++中对文件操作需要包含头文件 文件类型分类两种： 文本文件 - 文件以文本的ASCII码形式存储在计算机中 二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们 操作文件的三大类： ofstream - 写操作 ifstream - 读操作 fstream - 读写操作 文本文件写文件写文件步骤 包含头文件 1#include&lt;fstream&gt; 创建流对象 1ofstream ofs; 打开文件 1ofs.open(&quot;文件路径&quot;,打开方式); 写数据 1ofs&lt;&lt;&quot;写入的数据&quot;; 关闭文件 1ofs.close(); 文件打开方式 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 注意：文件打开方式可以配合使用，利用|操作符 例如：用二进制方式写文件 ios::binary | ios::out 案例12345678910111213141516171819202122232425#include &lt;iostream&gt;#include&lt;fstream&gt;using namespace std;//文本文件 写文件void test01()&#123; //1、包含头文件fstream //2、创建流对象 ofstream ofs; //3、指定打开方式 ofs.open(&quot;text.txt&quot;, ios::out); //4、写内容 ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl; ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl; //5、关闭文件 ofs.close();&#125;int main()&#123; test01();&#125; 文件操作必须包含头文件fstream 读文件可以利用ofstream，或者fstream类 打开文件时需要指定操作文件的路径，以及打开方式 利用&lt;&lt;可以向文件中写数据 操作完毕，要关闭文件 读文件读文件步骤 包含头文件 1#include&lt;fstream&gt; 创建流对象 1ifstream ifs; 打开文件并判断文件是否打开成功 1ifs.open(&quot;文件路径&quot;,打开方式); 读数据 四种方式读取 关闭文件 1ifs.close(); 案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//文本文件 读文件void test01()&#123; //1、包含头文件fstream //2、创建流对象 ifstream ifs; //3、打开文件 并且判断是否打开成功 ifs.open(&quot;text.txt&quot;, ios::in); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //4、读数据 cout &lt;&lt; &quot;第一种读数据--------------&quot; &lt;&lt; endl; char buf[1024] = &#123; 0 &#125;; while (ifs &gt;&gt; buf) &#123; cout &lt;&lt; buf &lt;&lt; endl; &#125; cout &lt;&lt; &quot;第二种读数据--------------&quot; &lt;&lt; endl; char buf1[1024] = &#123; 0 &#125;; while (ifs.getline(buf1, sizeof(buf1))) &#123; cout&lt;&lt;buf1&lt;&lt;endl; &#125; cout &lt;&lt; &quot;第三种读数据--------------&quot; &lt;&lt; endl; string buf2; while (getline(ifs, buf2)) &#123; cout &lt;&lt; buf2 &lt;&lt; endl; &#125; cout &lt;&lt; &quot;第四种读数据--------------&quot; &lt;&lt; endl; char c; while ((c = ifs.get()) != EOF) &#123; cout &lt;&lt; c; &#125; //5、关闭文件 ifs.close();&#125;int main()&#123; test01();&#125; 读文件可以利用ifstream，或者fstream类 利用is_open函数可以判断文件是否打开成功 close关闭文件 二进制文件以二进制的方式对文件进行读写操作 打开方式要指定为ios::bianary 写文件二进制方式写文件主要利用流对象调用成员函数write 函数原型：ostream&amp; write(const char* buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//二进制文件 写文件class Person&#123;public: char m_Name[64];//姓名 int m_Age;//年龄&#125;;void test01()&#123; //1、包含头文件 //2、创建流对象 ofstream ofs; //3、打开文件 ofs.open(&quot;person.txt&quot;, ios::out | ios::binary); //4、写文件 Person p = &#123; &quot;张三&quot;,18 &#125;; ofs.write((const char*)&amp;p, sizeof(Person)); //5、关闭文件 ofs.close();&#125;int main()&#123; test01();&#125; 文件输出流对象可以通过write函数，以二进制方式写函数 读文件二进制方式读文件主要利用流对象调用成员函数read 函数原型：istream&amp; read(char* buffer,int len); 参数解释：字符指针buffer指向内存中一段存储空间，len是读写的字节数 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;using namespace std;//二进制文件 读文件class Person&#123;public: char m_Name[64];//姓名 int m_Age;//年龄&#125;;void test01()&#123; //1、包含头文件 //2、创建流对象 ifstream ifs; //3、打开文件 判断文件是否打开成功 ifs.open(&quot;person.txt&quot;, ios::in | ios::binary); if (!ifs.is_open()) &#123; cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl; return; &#125; //4、读文件 Person p; ifs.read((char*)&amp;p, sizeof(Person)); cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl; //5、关闭文件 ifs.close();&#125;int main()&#123; test01();&#125; 运行结果为： 姓名： 张三 年龄： 18","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 Linux系统编程 进程使用","slug":"C++-学习-Linux系统编程-进程使用","date":"2023-05-04T08:37:55.000Z","updated":"2023-05-14T07:18:27.521Z","comments":true,"path":"2023/05/04/C++-学习-Linux系统编程-进程使用/","link":"","permalink":"http://example.com/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8/","excerpt":"进程概述程序和进程程序","text":"进程概述程序和进程程序程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程 进程进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。 程序和进程的关系可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息 单道、多道程序设计 单道程序，即在计算机内存中只允许一个的程序运行。 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 时间片 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复 并行和并发 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行 进程控制块PCB 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。 在 &#x2F;usr&#x2F;src&#x2F;linux-headers-xxx&#x2F;include&#x2F;linux&#x2F;sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可： 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数 进程的状态：有就绪、运行、挂起、停止等状态 进程切换时需要保存和恢复的一些CPU寄存器 描述虚拟地址空间的信息 描述控制终端的信息当前工作目录（Current Working Directory） umask 掩码 文件描述符表，包含很多指向 file 结构体的指针 和信号相关的信息 用户 id 和组 id 会话（Session）和进程组 进程可以使用的资源上限（Resource Limit）运行 1ulimit -a 进程状态转换进程的状态进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。 运行态：进程占有处理器正在运行 就绪态：进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成 新建态：进程刚被创建时的状态，尚未进入就绪队列 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程 进程相关命令 查看进程 1ps aux 1ps ajx a：显示终端上的所有进程，包括其他用户的进程 u：显示进程的详细信息 x：显示没有控制终端的进程 j：列出与作业相关的控制进程 还有其他的命令我们可以运行命令 1man ps STAT参数的意义 参数 意义 D 不可中断 Uninterruptible（usually IO） R 正在运行，或在队列中的进程 S 处于休眠状态 T 停止或被追踪 Z 僵尸进程 W 进入内存交换（从内核2.6开始无效） X 死掉的进程 &lt; 高优先级 N 低优先级 S 包含子进程 + 位于前台的进程组 实时显示进程动态 1top 可以在使用top命令时加上 -d来指定显示信息更新的时间间隔，在top命令执行后，可以按以下按键对显示结果进行排序 M 根据内存使用量排序 P 根据CPU占有率排序 T 根据进程运行时间长短排序 U 根据用户名来筛选进程 K 输入指定的PID杀死进程 杀死进程 klil [-signal] pid kill -l 列出所有信号 kill -SIGKILL 进程ID kill -9 进程ID killall name 根据进程名杀死进程 进程号和相关函数 每个进程都由进程号来标识，其类型为 pid_t（整型），进程号的范围：0～32767。进程号总是唯一的，但可以重用。当一个进程终止后，其进程号就可以再次使用。 任何进程（除 init 进程）都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为父进程号（PPID）。 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进程有一个进程组号（PGID）。默认情况下，当前的进程号会当做当前的进程组号。 进程号和进程相关函数 pid_t getpid(void); pid_t getppid(void); pid_t getpgid(pid_t pid); 进程创建fork函数系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。 123456789#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;pid_t fork(void);//返回值：//成功：子进程中返回0，父进程中返回子进程ID//失败：返回-1//失败的两个主要原因//1、当前系统的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN//2、系统内存不足，这是errno的值被设置为ENOMEM 例子： 123456789101112131415161718192021222324252627#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建子进程 pid_t pid = fork(); //判断是父进程还是子进程 if (pid &gt; 0) &#123; printf(&quot;pid: %d\\n&quot;, pid); //如果大于0，返回的是创建的子进程的进程号 printf(&quot;I am parent process,pid: %d, ppid: %d\\n&quot;, getpid(), getppid()); &#125; else if (pid == 0) &#123; //当前是子进程 printf(&quot;I am child process,pid: %d, ppid: %d\\n&quot;, getpid(), getppid()); &#125; //for循环 for (int i = 0;i &lt; 5;i++) &#123; printf(&quot;i: %d pid: %d\\n&quot;, i,getpid()); sleep(2); &#125;&#125; 运行结果为： 第一个pid：107838是子进程的ID，父进程ID为107837，父进程的父进程的ID：107575 父进程和子进程是交替运行的 父子进程之间的关系： 区别： fork()函数的返回值不同 父进程中：&gt;0 返回子进程的ID 子进程中 &#x3D; 0 PCB中的一些数据有区别 当前进程的id，pid 当前进程的父进程id，ppid 信号集 共同点： 某些状态下：子进程刚创建出来，还没有执行任何的写数据的操作 用户区的数据 文件描述符表 父子进程对变量是不是共享的？ 刚开始的时候是一样的，是共享的，如果修改了数据就不共享了 读时共享（子进程被创建，两个进程没有做任何写的操作），写时拷贝 父子进程虚拟地址空间情况实际上，更准确来说，Linux的fork()使用是通过写时拷贝（copy - on - write）实现的。 写时拷贝是一种可以推迟甚至避免拷贝数据的技术。 内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进程拥有各自的地址空间。 也就是说，资源的复制是在需要写入的时候才会运行，在此之前，只有以只读方式共享。 注意：fork之后父子进程共享文件。fork产生的子进程与父进程相同的文件，文件描述符指向相同的文件表，引用计数增加，共享文偏移指针。 GDB多进程调试使用 GDB 调试的时候，GDB 默认只能跟踪一个进程，可以在 fork 函数调用之前，通过指令设置 GDB 调试工具跟踪父进程或者是跟踪子进程，默认跟踪父进程。 设置调试父进程或者子进程：set follow-fork-mode [parent（默认）| child] 设置调试模式：set detach-on-fork [on | off]默认为 on，表示调试当前进程的时候，其它的进程继续运行，如果为 off，调试当前进程的时候，其它进程被 GDB 挂起。 查看调试的进程：info inferiors 切换当前调试的进程：inferior id 使进程脱离 GDB 调试：detach inferiors id 我们对如下程序进行GDB多进程调试： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main() &#123; printf(&quot;begin\\n&quot;); if(fork() &gt; 0) &#123; printf(&quot;我是父进程: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); int i; for(i = 0; i &lt; 10; i++) &#123; printf(&quot;i = %d\\n&quot;, i); sleep(1); &#125; &#125; else &#123; printf(&quot;我是子进程: pid = %d, ppid = %d\\n&quot;, getpid(), getppid()); int j; for(j = 0; j &lt; 10; j++) &#123; printf(&quot;j = %d\\n&quot;, j); sleep(1); &#125; &#125; return 0;&#125; 对上述程序进行调试：GDB默认调试的是父进程 我们可以通过指令,修改默认跟踪的进程 1set follow-fork-mode child 修改之后我们默认调试的是子进程 使用命令，更改调试模式off将子进程挂起 1set detach-on-fork off 我们重新调试程序 通过运行命令查看当前调试的进程 1info inferiors 我们运行命令切换到子进程继续调试 1inferior 2 我们再次切换到父进程调试，并且将父进程运行结束 此时我们查看进程 我们切换到子进程继续调试并且运行结束 我们运行命令，使父进程脱离调试 1detach inferiors 1 exec函数族exec函数族介绍 exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。 exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样，颇有些神似“三十六计”中的“金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回 -1，从原程序的调用点接着往下执行。 123456789int execl(const char *path, const char *arg, .../* (char *) NULL */);int execlp(const char *file, const char *arg, ... /* (char *) NULL */);int execle(const char *path, const char *arg, .../*, (char *) NULL, char * const envp[] */);int execv(const char *path, char *const argv[])int execvp(const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]);//前六个是标准C库函数，最后一个是Linux系统函数int execve(const char *filename, char *const argv[], char *const envp[]); execl函数1234567891011#include&lt;unistd.h&gt;int execl(const char* path, const char* arg, .../* (char *) NULL */);//参数//- path：需要制定执行的文件的路径或者名称//- arg：是执行可执行文件所需要的参数列表// 第一个参数一般没有什么作用，一般写的是执行的程序的名称// 从第二个参数开始往后，就是程序执行所需要的参数列表// 参数最后需要以NULL结束（哨兵）//返回值//只有当调用失败才会有返回值，并且返回-1，并且设置errno//如果调用成功，没有返回值 例子： 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个子进程，在子进程中执行exec函数族中的程序 __pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //子进程 execl(&quot;hello&quot;, &quot;hello&quot;, &quot;NULL&quot;); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; hello文件是一段输出hello world的代码 代码运行结果如下： 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个子进程，在子进程中执行exec函数族中的程序 __pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //子进程 execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; 这段代码会将子进程替代为运行Linux系统程序ps execlp函数12345#include&lt;unistd.h&gt;int execlp(const char* file, const char* arg, ... /* (char *) NULL */);//参数//- 会到环境变量中寻找可执行文件，如果找到则执行，如果找不到则执行失败//- file：需要可执行文件的文件名 例子: 12345678910111213141516171819202122#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; //创建一个子进程，在子进程中执行exec函数族中的程序 __pid_t pid = fork(); if (pid &gt; 0) &#123; //父进程 printf(&quot;i am parent process,pid : %d\\n&quot;, getpid()); &#125; else if (pid == 0) &#123; //子进程 execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;aux&quot;, NULL); printf(&quot;i am child process,pid : %d\\n&quot;,getpid()); &#125; for (int i = 0;i &lt; 3;i++) &#123; printf(&quot;i = %d,pid = %d\\n&quot;, i, getpid()); &#125;&#125; 与execl不同，execlp不用写入绝对路径就可以执行ps命令 进程控制进程退出 1234567#include&lt;stdlib.h&gt;void exit(int status);#include&lt;unistd.h&gt;void _exit(int status);//status是进程退出时的一个状态信息。父进程回收子进程资源时可以获取到 例子： 12345678910#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); exit(0);&#125; 12345678910#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; printf(&quot;hello\\n&quot;); printf(&quot;world&quot;); _exit(0);&#125; 如果使用_exit(0)则只会打印hello不会打印world 孤儿进程 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进程（Orphan Process）。 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。 因此孤儿进程并不会有什么危害 僵尸进程 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免 进程回收 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 wait()函数1234567891011#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t wait(int* wstatus);//功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收//参数：//进程退出时的状态信息，传入的是一个int类型的地址，传出参数//返回值：//- 成功：返回被回收的子进程的ID//- 失败：返回-1(所有子进程都结束//调用wait函数的进程会被挂起(阻塞)，直到它的一个子进程退出或者收到一个不能忽略的信号（继续被执行)//如果没有子进程，函数会立刻返回-1；如果子进程都已经结束了，也会立即返回-1，并且会回收子进程的资源 案例wait.c程序： 1234567891011121314151617181920212223242526272829#include&lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; //有一个父进程创建五个子进程 pid_t pid; //创建五个子进程 for (int i = 0;i &lt; 5;i++) &#123; pid = fork(); if (pid == 0) break; &#125; if (pid &gt; 0) &#123; //父进程 while (1) &#123; printf(&quot;parent,pid = %d\\n&quot;, getpid()); &#125; &#125; else if (pid == 0) &#123; //子进程 printf(&quot;child,pid = %d\\n&quot;, getpid()); &#125;&#125; 我们编译运行这段程序 运行命令 1ps aux 我们发现wait程序生成的五个子进程变为了僵尸进程 我们重新写一段wait.c程序，通过kill将子程序杀死 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 有一个父进程，创建5个子进程（兄弟） pid_t pid; // 创建5个子进程 for(int i = 0; i &lt; 5; i++) &#123; pid = fork(); if(pid == 0) &#123; break; &#125; &#125; if(pid &gt; 0) &#123; // 父进程 while(1) &#123; printf(&quot;parent, pid = %d\\n&quot;, getpid()); // int ret = wait(NULL); int st; int ret = wait(&amp;st); if(ret == -1) &#123; break; &#125; if(WIFEXITED(st)) &#123; // 是不是正常退出 printf(&quot;退出的状态码：%d\\n&quot;, WEXITSTATUS(st)); &#125; if(WIFSIGNALED(st)) &#123; // 是不是异常终止 printf(&quot;被哪个信号干掉了：%d\\n&quot;, WTERMSIG(st)); &#125; printf(&quot;child die, pid = %d\\n&quot;, ret); sleep(1); &#125; &#125; else if (pid == 0)&#123; // 子进程 while(1) &#123; printf(&quot;child, pid = %d\\n&quot;,getpid()); sleep(1); &#125; exit(0); &#125; return 0; // exit(0)&#125;&quot;, getpid()); &#125; &#125;&#125; 使用kill命令杀死子进程 kill之后的运行结果为： 退出信息相关宏函数1234567WIFEXITED(status) //非0，进程正常退出WEXITSTATUS(status) //如果上宏为真，获取进程退出的状态（exit的参数）WIFSIGNALED(status) //非0，进程异常终止WTERMSIG(status) //如果上宏为真，获取使进程终止的信号编号WIFSTOPPED(status) //非0，进程处于暂停状态WSTOPSIG(status) //如果上宏为真，获取使进程暂停的信号的编号WIFCONTINUED(status) //非0，进程暂停后已经继续运行 waitpid()函数123456789101112131415#include &lt;sys/types.h&gt;#include&lt;sys/wait.h&gt;pid_t waitpid(pid_t pid, int* wstatus, int options);//功能：回收指定进程号的进程，可设置是否阻塞//参数：//- pid// pid&gt;0：某个子进程的pid// pid=0：回收当前进程组的所有子进程// pid=-1：表示回收所有的子进程，相当于wait() 最常用// pid&lt;-1：某个进程组的组id的绝对值，回收指定进程组中的子进程//- options：设置阻塞或者非阻塞，0表示阻塞，WNOHANG表示非阻塞//- 返回值// &gt;0：返回子进程ID// =0：options=WNOHANG，表示还有子进程// =-1：错误，或者没有子进程","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"C++学习 多态","slug":"C++-学习-多态","date":"2023-05-04T01:11:10.000Z","updated":"2023-05-09T08:10:41.368Z","comments":true,"path":"2023/05/04/C++-学习-多态/","link":"","permalink":"http://example.com/2023/05/04/C++-%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%80%81/","excerpt":"多态的基本概念多态是C++面向对象三大特性之一 多态分为两类：","text":"多态的基本概念多态是C++面向对象三大特性之一 多态分为两类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 静态多态和动态多态区别 静态多态的函数地址早绑定-编译阶段确定函数地址 动态多态的函数地址晚绑定-运行阶段确定函数地址 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多态//动物类class Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125; &#125;;//猫类class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;//执行说话的函数//地址早绑定 在编译阶段确定函数地址 //如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定void doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat);&#125;int main()&#123; test01();&#125; 运行结果为： 动物在说话 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多态//动物类class Animal&#123;public: virtual void speak() &#123; cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl; &#125; &#125;;//动态多态满足条件// 1、具有继承关系// 2、子类要重写父类的虚函数// // 动态多态的使用// 父类的指针或引用指向子类的应用// //猫类class Cat :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125;&#125;;class Dog :public Animal&#123;public: void speak() &#123; cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl; &#125;&#125;;//执行说话的函数//地址早绑定 在编译阶段确定函数地址 //如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要在运行阶段进行绑定，地址晚绑定void doSpeak(Animal&amp; animal)&#123; animal.speak();&#125;void test01()&#123; Cat cat; doSpeak(cat); Dog dog; doSpeak(dog);&#125;int main()&#123; test01();&#125; 运行结果为： 小猫在说话小狗在说话 动态多态满足条件 具有继承关系 子类要重写父类的虚函数 动态多态的使用 父类的指针或引用指向子类对象 多态的原理剖析我们观察上述代码的Animal类结构,vfptr指向vftable 我们观察Cat类的结构如下： 当父类指针或者引用指向子类对象的时候发生多态，即 Animal&amp; animal = cat animal.speak() 当传入的对象是cat那么就是从cat的虚函数表里调用虚函数 多态案例一 计算器类案例描述：分别利用普通写法和多态技术，设计两个操作数进行运算的计算器类 多态的优点： 代码组织结构清晰 可读性强 利于前期和后期的拓展以及维护 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分别利用普通写法和多态写法实现计算器//普通写法class Calculator&#123;public: int getResult(string oper) &#123; if (oper == &quot;+&quot;)return m_Num1 + m_Num2; else if(oper == &quot;-&quot;)return m_Num1 - m_Num2; else if (oper == &quot;*&quot;)return m_Num1 * m_Num2; else if (oper == &quot;/&quot;)return m_Num1 / m_Num2; &#125; //如果要拓展新的功能，需要拓展源码 //在真实的开发中提倡开闭原则 //对拓展进行开发，对修改进行关闭 int m_Num1;//操作数1 int m_Num2;//操作数2&#125;;void test01()&#123; Calculator c; c.m_Num1 = 10; c.m_Num2 = 10; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl; cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; / &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; c.getResult(&quot;/&quot;) &lt;&lt; endl;&#125;//利用多态实现计算器//实现计算机抽象类class AbstractCalculator&#123;public: virtual int getResult() &#123; return 0; &#125; int m_Num1; int m_Num2;&#125;;//加法计算器类class AddCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//减法计算器类class SubCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 + m_Num2; &#125;&#125;;//乘法计算器类class MulCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 * m_Num2; &#125;&#125;;//加法计算器类class DivCalculator :public AbstractCalculator&#123;public: int getResult() &#123; return m_Num1 / m_Num2; &#125;&#125;;void test02()&#123; //多态使用条件 //父类指针或者引用指向子类对象 //加法运算 AbstractCalculator* abc = new AddCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //用完后记得销毁 delete abc; //减法运算 abc = new SubCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //乘法运算 abc = new MulCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl; //除法运算 abc = new DivCalculator; abc-&gt;m_Num1 = 100; abc-&gt;m_Num2 = 100; cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; / &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; = &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;&#125;int main()&#123; test01(); test02(); &#125; 运行结果为： 10 + 10 &#x3D; 2010 - 10 &#x3D; 010 * 10 &#x3D; 10010 &#x2F; 10 &#x3D; 1100 + 100 &#x3D; 200100 - 100 &#x3D; 200100 * 100 &#x3D; 10000100 &#x2F; 100 &#x3D; 1 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容 因此可以将虚函数改为纯虚函数 纯虚函数语法：virtual 返回值类型 函数名 (参数列表) = 0; 当类中有了纯虚函数，这个类也成为抽象类 抽象类特点： 无法实例化对象 子类必须重写抽象类中的纯虚函数，否则也属于抽象类 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//纯虚函数和抽象类class Base&#123;public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //无法实例化对象 virtual void func() = 0;&#125;;void test01()&#123; Base b;&#125;int main()&#123; test01();&#125; 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//纯虚函数和抽象类class Base&#123;public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //1、无法实例化对象 //2、抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123;&#125;;void test01()&#123; Son s;&#125;int main()&#123; test01();&#125; 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//纯虚函数和抽象类class Base&#123;public: //纯虚函数 //只要有一个纯虚函数，这个类称为抽象类 //抽象类特点： //1、无法实例化对象 //2、抽象类的子类，必须要重写父类中的纯虚函数，否则也属于抽象类 virtual void func() = 0;&#125;;class Son :public Base&#123; virtual void func() &#123; cout &lt;&lt; &quot;func函数调用&quot; &lt;&lt; endl; &#125;;&#125;;void test01()&#123; Son s;//子类必须重写父类中的纯虚函数，否则不能实例化对象 Base* base = new Son; base-&gt;func();&#125;int main()&#123; test01();&#125; 运行结果为： func函数调用 多态案例二 制作饮品案例描述：制作饮品的大致流程为：煮水-冲泡-倒入杯中-加入辅料 利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多态案例2 制作饮品class AbstractDrinking&#123;public: //煮水 virtual void Boil() = 0; //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() = 0; //加入辅料 virtual void PutSomething() = 0; //制作饮品 void makeDrink() &#123; Boil(); Brew(); PourInCup(); PutSomething(); &#125;&#125;;//制作咖啡class Coffee :public AbstractDrinking&#123;public: //煮水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮农夫山泉&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡咖啡&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入糖和牛奶&quot; &lt;&lt; endl; &#125;&#125;;//制作茶class Tea :public AbstractDrinking&#123;public: //煮水 virtual void Boil() &#123; cout &lt;&lt; &quot;煮矿泉水&quot; &lt;&lt; endl; &#125; //冲泡 virtual void Brew() &#123; cout &lt;&lt; &quot;冲泡茶叶&quot; &lt;&lt; endl; &#125; //倒入杯中 virtual void PourInCup() &#123; cout &lt;&lt; &quot;倒入杯中&quot; &lt;&lt; endl; &#125; //加入辅料 virtual void PutSomething() &#123; cout &lt;&lt; &quot;加入枸杞&quot; &lt;&lt; endl; &#125;&#125;;//制作函数void doWork(AbstractDrinking* abs)&#123; abs-&gt;makeDrink(); delete abs;//释放&#125;void test01()&#123; //制作咖啡 doWork(new Coffee); cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; //制作茶叶 doWork(new Tea);&#125;int main()&#123; test01();&#125; 运行结果为： 煮农夫山泉冲泡咖啡倒入杯中加入糖和牛奶 煮矿泉水冲泡茶叶倒入杯中加入枸杞 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码 解决方式：将父类中的析构函数改为虚析构或者纯虚析构 虚析构和纯虚析构共性： 可以解决父类指针释放子类对象 都需要有具体的函数实现 虚析构和纯虚析构区别 如果是纯虚析构，该类属于抽象类，无法实例化对象 虚析构语法： virtual ~类名()&#123;&#125; 纯虚析构语法： virtual ~类名() = 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//虚析构函数和纯虚析构函数class Animal&#123;public: //纯虚函数 Animal() &#123; cout &lt;&lt; &quot;Animal的构造函数调用&quot; &lt;&lt; endl; &#125; ~Animal() &#123; cout &lt;&lt; &quot;Animal的析构函数调用&quot; &lt;&lt; endl; &#125; virtual void speak() = 0;&#125;;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat的构造函数调用&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Cat的析构函数调用&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 delete animal;&#125;int main()&#123; test01();&#125; 运行结果为： Animal的构造函数调用Cat的构造函数调用Tom小猫在说话Animal的析构函数调用 父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 我们使用虚析构解决这个问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//虚析构函数和纯虚析构函数class Animal&#123;public: //纯虚函数 Animal() &#123; cout &lt;&lt; &quot;Animal的构造函数调用&quot; &lt;&lt; endl; &#125; //可以利用虚析构解决父类指针释放子类对象时不干净的问题 virtual ~Animal() &#123; cout &lt;&lt; &quot;Animal的析构函数调用&quot; &lt;&lt; endl; &#125; virtual void speak() = 0;&#125;;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat的构造函数调用&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Cat的析构函数调用&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 delete animal;&#125;int main()&#123; test01();&#125; 运行结果为： Animal的构造函数调用Cat的构造函数调用Tom小猫在说话Cat的析构函数调用Animal的析构函数调用 我们使用纯虚析构解决这个问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//虚析构函数和纯虚析构函数class Animal&#123;public: //纯虚函数 Animal() &#123; cout &lt;&lt; &quot;Animal的构造函数调用&quot; &lt;&lt; endl; &#125; //可以利用纯虚析构解决父类指针释放子类对象时不干净的问题 //有了纯虚析构之后，这个类也属于抽象类，无法实例化对象 virtual ~Animal() = 0; virtual void speak() = 0;&#125;;Animal::~Animal()&#123; cout &lt;&lt; &quot;Animal的纯虚析构函数调用&quot; &lt;&lt; endl;&#125;class Cat :public Animal&#123;public: Cat(string name) &#123; cout &lt;&lt; &quot;Cat的构造函数调用&quot; &lt;&lt; endl; m_Name = new string(name); &#125; virtual void speak() &#123; cout &lt;&lt; *m_Name &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl; &#125; ~Cat() &#123; if (m_Name != NULL) &#123; cout &lt;&lt; &quot;Cat的析构函数调用&quot; &lt;&lt; endl; delete m_Name; m_Name = NULL; &#125; &#125; string *m_Name;&#125;;void test01()&#123; Animal* animal = new Cat(&quot;Tom&quot;); animal-&gt;speak(); //父类指针在析构时，不会调用子类中的析构函数，导致如果子类有堆区属性，会导致内存泄漏 delete animal;&#125;int main()&#123; test01();&#125; 运行结果为： Animal的构造函数调用Cat的构造函数调用Tom小猫在说话Cat的析构函数调用Animal的纯虚析构函数调用 多态案例三 电脑组装案例描述： 电脑主要组成部件为CPU（用于计算），显卡（用于显示），内存条（用于存储） 将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商喝Lenovo厂商 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口 测试时组装三台不同的电脑进行工作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//抽象不同的类//抽象CPU类class CPU&#123;public: //抽象的计算函数 virtual void calculate() = 0;&#125;;//抽象内存类class Memory&#123;public: //抽象的存储函数 virtual void storage() = 0;&#125;;//抽象显卡类class VideoCard&#123;public: virtual void display() = 0;&#125;;//抽象电脑类class Computer&#123;public: Computer(CPU* cpu, VideoCard* vc, Memory* mem) &#123; m_cpu = cpu; m_vc = vc; m_mem = mem; &#125; //提供工作的函数 void work() &#123; //让零件工作起来，调用接口 m_cpu-&gt;calculate(); m_vc-&gt;display(); m_mem-&gt;storage(); &#125; //提供析构函数 释放三个电脑零件 ~Computer() &#123; if (m_cpu != NULL) &#123; delete m_cpu; m_cpu = NULL; &#125; if (m_vc != NULL) &#123; delete m_vc; m_vc = NULL; &#125; if (m_mem != NULL) &#123; delete m_mem; m_mem = NULL; &#125; &#125;private: CPU* m_cpu;//CPU的零件指针 VideoCard* m_vc;//显卡的零件指针 Memory* m_mem;//内存的零件指针&#125;;//具体厂商//Intel厂商class IntelCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class IntelMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;//AMD厂商class AMDCPU :public CPU&#123;public: virtual void calculate() &#123; cout &lt;&lt; &quot;AMD的CPU开始计算了！&quot; &lt;&lt; endl; &#125;&#125;;class AMDVideoCard :public VideoCard&#123;public: virtual void display() &#123; cout &lt;&lt; &quot;AMD的显卡开始显示了！&quot; &lt;&lt; endl; &#125;&#125;;class AMDMemory :public Memory&#123;public: virtual void storage() &#123; cout &lt;&lt; &quot;AMD的内存条开始存储了！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; //第一台电脑零件 CPU* intelCpu = new IntelCPU; VideoCard* intelCard = new IntelVideoCard; Memory* intelMem = new IntelMemory; //创建第一台电脑 cout &lt;&lt; &quot;第一台电脑开始工作&quot; &lt;&lt; endl; Computer* computer1 = new Computer(intelCpu,intelCard,intelMem); computer1-&gt;work(); delete computer1; //创建第二台电脑 cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl; Computer* computer2 = new Computer(new AMDCPU, new AMDVideoCard, new AMDMemory); computer2-&gt;work(); delete computer2; //创建第三台电脑 cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl; Computer* computer3 = new Computer(new IntelCPU, new AMDVideoCard, new IntelMemory); computer3-&gt;work(); delete computer3;&#125;int main()&#123; test01();&#125; 运行结果为： 第一台电脑开始工作Intel的CPU开始计算了！Intel的显卡开始显示了！Intel的内存条开始存储了！ 第二台电脑开始工作：AMD的CPU开始计算了！AMD的显卡开始显示了！AMD的内存条开始存储了！ 第三台电脑开始工作：Intel的CPU开始计算了！AMD的显卡开始显示了！Intel的内存条开始存储了！","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 继承","slug":"C++-学习-继承","date":"2023-05-02T01:22:05.000Z","updated":"2023-05-09T08:11:01.440Z","comments":true,"path":"2023/05/02/C++-学习-继承/","link":"","permalink":"http://example.com/2023/05/02/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%A7%E6%89%BF/","excerpt":"继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，定义这些类时，下级别的成员除了拥有上一级的共性还有自己的特性，这个时候我们可以考虑利用继承的技术减少重复代码。 继承的基本语法","text":"继承是面向对象三大特性之一 有些类与类之间存在特殊的关系，定义这些类时，下级别的成员除了拥有上一级的共性还有自己的特性，这个时候我们可以考虑利用继承的技术减少重复代码。 继承的基本语法语法： class 子类：继承方式 父类 子类也成为派生类，父类也成为基类 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同，接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处 普通实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//普通实现页面//Java页面class Java&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Java学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class Cpp&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125; void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; cout &lt;&lt; &quot;Java页面如下&quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Python页面如下&quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;C++页面如下&quot; &lt;&lt; endl; Cpp cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content();&#125;int main()&#123; test01();&#125; 运行结果为： Java页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Java学科视频 Python页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Python学科视频 C++页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表C++学科视频 继承实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承实现页面//公共页面类class Basepage&#123;public: void header() &#123; cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl; &#125; void footer() &#123; cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...（公共底部)&quot; &lt;&lt; endl; &#125; void left() &#123; cout &lt;&lt; &quot;Java、Python、C++...（公共分类列表&quot; &lt;&lt; endl; &#125;&#125;;//Java页面class Java : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;Java学科视频&quot; &lt;&lt; endl; &#125;&#125;;//Python页面class Python : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl; &#125;&#125;;//C++页面class Cpp : public Basepage&#123;public: void content() &#123; cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; cout &lt;&lt; &quot;Java页面如下&quot; &lt;&lt; endl; Java ja; ja.header(); ja.footer(); ja.left(); ja.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Python页面如下&quot; &lt;&lt; endl; Python py; py.header(); py.footer(); py.left(); py.content(); cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl; cout &lt;&lt; &quot;C++页面如下&quot; &lt;&lt; endl; Cpp cpp; cpp.header(); cpp.footer(); cpp.left(); cpp.content();&#125;int main()&#123; test01();&#125; 运行结果为： Java页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Java学科视频 Python页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表Python学科视频 C++页面如下首页、公开课、登录、注册…（公共头部）帮助中心、交流合作、站内地图…（公共底部)Java、Python、C++…（公共分类列表C++学科视频 继承方式继承的方式一共有三种 公共继承 保护继承 私有继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承方式class Base&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son1 :public Base&#123;public: void func() &#123; m_A = 10;//父类中的公共权限成员到子类中依然是公共权限 m_B = 10;//父类中的保护权限成员到子类中依然是保护权限 //m_C = 10;//父类中的私有权限成员子类访问不到 &#125;&#125;;void test01()&#123; Son1 s1; s1.m_A = 100; //s1.m_B = 100;//到Son1中m_B是保护权限，类外访问不到&#125;//保护继承class Son2 :protected Base&#123;public: void func() &#123; m_A = 100;//父类中的公共权限成员到子类中变为保护权限 m_B = 100;//父类中的保护权限成员到子类中依然是保护权限 //m_C = 100;//父类中私有权限成员子类访问不到 &#125;&#125;;void test02()&#123; Son2 s1; //s1.m_A = 10;//在Son2中 m_A变为保护权限，因此类外访问不到 //s1.m_B = 10;//在Son2中 m_B变为保护权限，不可以访问&#125;class Son3 :private Base&#123;public: void func() &#123; m_A = 100;//父类中的公共权限成员到子类中变为保护权限 m_B = 100;//父类中的保护权限成员到子类中变为私有权限 //m_C = 100;//父类中的私有成员子类访问不到 &#125;&#125;;void test03()&#123; Son3 s1; //s1.m_A = 10;//到Son3中变为私有成员，类外访问不了 //s1.m_B = 10;//到Son3中变为私有成员，类外访问不了&#125;int main()&#123; test01(); test02(); test03();&#125; 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承中的对象模型class Base&#123;public: int m_A;protected: int m_B;private: int m_C;&#125;;class Son :public Base&#123;public: int m_D;&#125;;void test01()&#123; cout &lt;&lt; &quot;size of Son = &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of Son &#x3D; 16 父类中所有非静态成员属性都会被子类继承下去 父类中私有成员属性是被编译器给隐藏了，因此是访问不到，但是确实是被继承下去了 开发人员命令提示工具查看对象模型打开vs开发人员命令提示工具 转到文件对应的路径 输入命令查看类 1cl /d1 reportSingleClassLayout类名 文件名 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承中的构造和析构顺序class Base&#123;public: Base() &#123; cout &lt;&lt; &quot;Base的构造函数！&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base的析构函数！&quot; &lt;&lt; endl; &#125;&#125;;class Son :public Base&#123;public: Son() &#123; cout &lt;&lt; &quot;Son的构造函数！&quot; &lt;&lt; endl; &#125; ~Son() &#123; cout &lt;&lt; &quot;Son的析构函数！&quot; &lt;&lt; endl; &#125;&#125;;void test01()&#123; Son s;&#125;int main()&#123; test01();&#125; 运行结果为： Base的构造函数！Son的构造函数！Son的析构函数！Base的析构函数！ 先构造父类再构造子类，析构相反 继承同名成员处理方式访问子类同名成员，直接访问即可 访问父类同名成员，需要加作用域 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Base&#123;public: Base() &#123; m_A = 100; &#125; void func() &#123; cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl; &#125; void func(int a) &#123; cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl; &#125; int m_A;&#125;;class Son :public Base&#123;public: Son() &#123; m_A = 200; &#125; void func() &#123; cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl; &#125; int m_A;&#125;;//同名成员属性void test01()&#123; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; //如果通过子类对象，访问到父类中的同名成员，需要加作用域 cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;&#125;//同名成员函数处理void test02()&#123; Son s; s.func();//直接调用的是子类中的同名成员 s.Base::func(); //如果子类中出现和父类同名的成员函数，子类的同名成员会隐藏掉父类中所有的同名成员函数 s.Base::func(100);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： Son下的m_A &#x3D; 200Base下的m_A &#x3D; 100Son - func()调用Base - func()调用Base - func(int a)调用 继承同名静态成员处理方式静态成员和非静态成员同名，处理方式一致 访问子类同名成员，直接访问即可 访问父类同名成员，需要加作用域 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//继承中的同名静态成员的处理方式class Base&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; &quot;Base - static void func()调用&quot; &lt;&lt; endl; &#125; static void func(int a) &#123; cout &lt;&lt; &quot;Base - static void func(int a)调用&quot; &lt;&lt; endl; &#125;&#125;;int Base::m_A = 100;class Son :public Base&#123;public: static int m_A; static void func() &#123; cout &lt;&lt; &quot;Son - static void func()调用&quot; &lt;&lt; endl; &#125;&#125;;int Son::m_A = 200;//同名静态成员属性void test01()&#123; //1、通过对象访问 cout &lt;&lt; &quot;通过对象访问：&quot; &lt;&lt; endl; Son s; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl; //2、通过类名访问 cout &lt;&lt; &quot;通过类名访问：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;//第一个::代表通过类名方式访问，第二个::代表访问父类作用域&#125;//同名静态成员函数void test02()&#123; //1、通过对象访问 cout &lt;&lt; &quot;通过对象访问：&quot; &lt;&lt; endl; Son s; s.func(); s.Base::func(); //2、通过类名访问 cout &lt;&lt; &quot;通过类名访问：&quot; &lt;&lt; endl; Son::func(); Son::Base::func(); //子类出现和父类同名静态成员函数，也会隐藏父类中所有的同名成员函数 //如果想访问父类中被隐藏同名成员，需要加作用域 Son::Base::func(100);&#125;int main()&#123; test01(); test02();&#125; 运行结果为： 通过对象访问：Son下的m_A &#x3D; 200Base下的m_A &#x3D; 100通过类名访问：Son下的m_A &#x3D; 200Base下的m_A &#x3D; 100通过对象访问：Son - static void func()调用Base - static void func()调用通过类名访问：Son - static void func()调用Base - static void func()调用Base - static void func(int a)调用 多继承语法C++允许一个类继承多个类 语法：class 子类：继承方式 父类1，继承方式 父类2 ... 多继承可能会引发父类中有同名成员出现，需要加作用域区分 C++实际开发中不建议使用多继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//多继承语法class Base1&#123;public: Base1() &#123; m_A = 100; &#125; int m_A;&#125;;class Base2&#123;public: Base2() &#123; m_A = 200; &#125; int m_A;&#125;;class Son :public Base1, public Base2&#123;public: Son() &#123; m_C = 300; m_D = 400; &#125; int m_C; int m_D;&#125;;void test01()&#123; Son s; cout &lt;&lt; &quot;size of Son = &quot; &lt;&lt; sizeof(s) &lt;&lt; endl; cout &lt;&lt; &quot;Base1::m_A = &quot; &lt;&lt; s.Base1::m_A &lt;&lt; endl; cout &lt;&lt; &quot;Base2::m_A = &quot; &lt;&lt; s.Base2::m_A &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of Son &#x3D; 16Base1::m_A &#x3D; 100Base2::m_A &#x3D; 200 菱形继承菱形继承概念： 两个派生类继承同一个基类 又有某个类同时继承两个派生类 这种继承被称为菱形继承或钻石继承 不使用虚继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//动物类class Animal&#123;public: int m_Age;&#125;;//利用虚继承解决菱形继承的问题//继承之前加上关键字virtual变为虚继承//Animal类称为虚基类 //羊类class Sheep :virtual public Animal &#123;&#125;;//驼类class Tuo :virtual public Animal&#123;&#125;;//羊驼类class SheepTuo :public Sheep, public Tuo&#123;&#125;;void test01()&#123; SheepTuo st; st.Sheep::m_Age = 18; st.Tuo::m_Age = 28; //当菱形继承，两个父类拥有相同数据，需要加以作用域区分 cout &lt;&lt; &quot;st.Sheep::m_Age = &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl; cout &lt;&lt; &quot;st.Tuo::m_Age = &quot; &lt;&lt; st.Tuo::m_Age &lt;&lt; endl; //这份数据我们知道 只要有一份就可以，菱形继承导致数据有两份，资源浪费&#125;int main()&#123; test01();&#125; 运行结果为： st.Sheep::m_Age &#x3D; 28st.Tuo::m_Age &#x3D; 28","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 运算符重载","slug":"C++-学习-运算符重载","date":"2023-04-30T07:57:41.000Z","updated":"2023-05-14T06:33:48.634Z","comments":true,"path":"2023/04/30/C++-学习-运算符重载/","link":"","permalink":"http://example.com/2023/04/30/C++-%E5%AD%A6%E4%B9%A0-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 加号运算符重载作用：实现两个自定义数据类型相加的运算","text":"运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 加号运算符重载作用：实现两个自定义数据类型相加的运算 成员函数重载123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;//加号运算符重载using namespace std;class Person&#123;public: Person operator+ (Person&amp; p) &#123; Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; &#125; int m_A; int m_B;&#125;;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 20; p2.m_B = 20; Person p3 = p1 + p2; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p3.m_A &#x3D; 30p3.m_B &#x3D; 30 成员函数重载本质调用 1Person p3 = p1.operator+(p2); 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//全局函数重载class Person&#123;public: int m_A; int m_B;&#125;;Person operator+ (Person&amp; p1, Person&amp; p2)&#123; Person temp; temp.m_A = p1.m_A + p2.m_A; temp.m_B = p1.m_B + p2.m_B; return temp;&#125;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 20; p2.m_B = 20; Person p3 = p1 + p2; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p3.m_A &#x3D; 30p3.m_B &#x3D; 30 全局函数重载本质调用 1Person p3 = operator+(p1,p2); 运算符重载也可以函数重载12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//全局函数重载class Person&#123;public: int m_A; int m_B;&#125;;Person operator+ (Person&amp; p1,int num)&#123; Person temp; temp.m_A = p1.m_A + num; temp.m_B = p1.m_B + num; return temp;&#125;void test01()&#123; Person p1; p1.m_A = 10; p1.m_B = 10; Person p3 = p1 + 10; cout &lt;&lt; &quot;p3.m_A = &quot; &lt;&lt; p3.m_A &lt;&lt; endl; cout &lt;&lt; &quot;p3.m_B = &quot; &lt;&lt; p3.m_B &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p3.m_A &#x3D; 20p3.m_B &#x3D; 20 左移运算符重载作用：可以输出自定义的数据类型 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//左移运算符重载class Person&#123;public: //利用成员函数重载左移运算符&lt;&lt; //通常不会利用成员函数重载&lt;&lt;，因为不能实现cout在左侧 int m_A; int m_B;&#125;;ostream &amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p)&#123; cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; &quot; m_B = &quot; &lt;&lt; p.m_B; return cout;&#125;void test01()&#123; Person p; p.m_A = 10; p.m_B = 10; cout &lt;&lt; p &lt;&lt;endl;&#125;int main()&#123; test01();&#125; 运行结果为： m_A &#x3D; 10 m_B &#x3D; 10 递增运算符重载作用：通过重载递增运算符，实现自己的整型数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//重载递增运算符//自定义整型class MyInteger&#123; friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint);public: MyInteger() &#123; m_Num = 0; &#125; //重载前置++运算符 返回引用是为了一直对一个数据操作 MyInteger&amp; operator++() &#123; //先做++运算 m_Num++; //再返回自身 return *this; &#125; //重载后置++运算符 int代表占位参数，可以用于区分前置和后置递增 MyInteger operator++(int) &#123; //先记录结果 MyInteger temp = *this; //后递增 m_Num++; //返回记录的结果 return temp; &#125;private: int m_Num;&#125;;ostream&amp; operator&lt;&lt;(ostream&amp; cout, MyInteger myint)&#123; cout &lt;&lt; myint.m_Num; return cout;&#125;void test01()&#123; MyInteger myint; cout &lt;&lt; ++myint &lt;&lt; endl;&#125;void test02()&#123; MyInteger myint; cout &lt;&lt; myint++ &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： 1 0 赋值运算符重载C++编译器至少给一个类添加四个函数 1、默认构造函数（无参，函数体为空） 2、默认析构函数（无参，函数体为空） 3、默认拷贝构造函数，对属性进行值拷贝 4、赋值运算符operator&#x3D;对属性进行值拷贝 如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//赋值运算符重载class Person&#123;public: Person(int age) &#123; m_Age = new int(age); &#125; int* m_Age; ~Person() &#123; if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; &#125; Person&amp; operator=(Person&amp; p) &#123; //编译器提供浅拷贝 //应该先判断是否有属性在堆区，如果有，先释放干净，然后再深拷贝 if (m_Age != NULL) &#123; delete m_Age; m_Age = NULL; &#125; //深拷贝 m_Age = new int(*p.m_Age); //返回对象本身 return *this; &#125;&#125;;void test01()&#123; Person p1(18); Person p2(20); Person p3(30); p3 = p2 = p1; cout &lt;&lt; &quot;p1的年龄为： &quot; &lt;&lt; *p1.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; *p2.m_Age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为： &quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： p1的年龄为： 18p2的年龄为： 18p3的年龄为： 18 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//重载关系运算符class Person&#123;public: Person(string name, int age) &#123; m_Name = name; m_Age = age; &#125; string m_Name; int m_Age; bool operator==(Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return true; &#125; return false; &#125; bool operator!=(Person&amp; p) &#123; if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) &#123; return false; &#125; return true; &#125;&#125;;void test01()&#123; Person p1(&quot;Tom&quot;, 18); Person p2(&quot;Tom&quot;, 18); if (p1 == p2) &#123; cout &lt;&lt; &quot;p1和p2是相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1和p2是不相等的&quot; &lt;&lt; endl; &#125; if (p1 != p2) &#123; cout &lt;&lt; &quot;p1和p2是不相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;p1和p2是相等的&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; test01();&#125; 运行结果为： p1和p2是相等的p1和p2是相等的 函数调用运算符重载函数调用运算符（）也可以重载 由于重载后使用的方式非常像函数的调用，因此称为仿函数 仿函数没有固定写法，非常灵活 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//函数调用运算符重载class MyPrint&#123;public: //重载函数调用运算符 void operator()(string test) &#123; cout &lt;&lt; test &lt;&lt; endl; &#125;&#125;;void test01()&#123; MyPrint myPrint; myPrint(&quot;hello world&quot;);&#125;//仿函数非常灵活，没有固定的写法//加法类class MyAdd&#123;public: int operator()(int num1, int num2) &#123; return num1 + num2; &#125;&#125;;void test02()&#123; MyAdd myadd; int ret = myadd(100, 100); cout &lt;&lt; &quot;ret = &quot; &lt;&lt; ret &lt;&lt; endl; //匿名函数对象 cout &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： hello worldret &#x3D; 200200","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 友元","slug":"C++-学习-友元","date":"2023-04-29T10:03:06.000Z","updated":"2023-05-09T08:11:48.455Z","comments":true,"path":"2023/04/29/C++-学习-友元/","link":"","permalink":"http://example.com/2023/04/29/C++-%E5%AD%A6%E4%B9%A0-%E5%8F%8B%E5%85%83/","excerpt":"生活中你的家有客厅（public），有你的卧室（private） 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜基友进去","text":"生活中你的家有客厅（public），有你的卧室（private） 客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去 但是呢，你也可以允许你的好闺蜜基友进去 在程序里，有些私有属性也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术 友元的目的就是让一个函数或者类访问另一个类中的私有成员 友元的关键字为friend 友元的三种实现 全局函数做友元 类做友元 成员函数做友元 全局函数做友元123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//建筑物类class Building&#123; //goodGuy全局函数是Building的好朋友，可以访问Building中私有成员 friend void goodGuy(Building* building);public: Building() &#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;; &#125;public: string m_SittingRoom;//客厅private: string m_BedRoom;//卧室&#125;;//全局函数void goodGuy(Building *building)&#123; cout &lt;&lt; &quot;好基友的全局函数 正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友的全局函数 正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom&lt;&lt; endl;&#125;void test01()&#123; Building building; goodGuy(&amp;building);&#125;int main()&#123; test01();&#125; 运行结果为： 好基友的全局函数 正在访问：客厅好基友的全局函数 正在访问：卧室 类做友元123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//建筑物类class Building;class GoodGuy&#123;public: GoodGuy(); void visit();//参观函数 访问Building中的属性 Building* building;&#125;;class Building&#123; //GoodGuy类是本类的好朋友，可以访问本类中的私有成员 friend class GoodGuy;public: Building();public: string m_SittingRoom;//客厅private: string m_BedRoom;//卧室&#125;;//类外写成员函数Building::Building()&#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGuy::GoodGuy()&#123; //创建建筑物对象 building = new Building;&#125;void GoodGuy::visit()&#123; cout &lt;&lt; &quot;好基友类正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友类正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void test01()&#123; GoodGuy gg; gg.visit();&#125;int main()&#123; test01();&#125; 运行结果为： 好基友类正在访问：客厅好基友类正在访问：卧室 成员函数做友元12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Building;class GoodGuy&#123;public: GoodGuy(); void visit();//让visit函数可以访问Building中的私有成员 void visit2();//让visit2函数不可以访问Building中私有成员 Building* building;&#125;;class Building&#123; //告诉编译器 GoodGuy类下的visit成员函数 friend void GoodGuy::visit();public: Building();public: string m_SittingRoom;//客厅private: string m_BedRoom;//卧室&#125;;Building::Building()&#123; m_SittingRoom = &quot;客厅&quot;; m_BedRoom = &quot;卧室&quot;;&#125;GoodGuy::GoodGuy()&#123; building = new Building;&#125;void GoodGuy::visit()&#123; cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;&#125;void GoodGuy::visit2()&#123; cout &lt;&lt; &quot;visit2函数正在访问：&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; //cout &lt;&lt; &quot;visit函数正在访问：&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;访问不了&#125;void test01()&#123; GoodGuy gg; gg.visit(); gg.visit2();&#125;int main()&#123; test01();&#125; 运行结果为： visit函数正在访问：客厅visit函数正在访问：卧室visit2函数正在访问：客厅","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"Linux cgroup入门","slug":"学习-Linux-cgroup入门","date":"2023-04-26T11:46:46.000Z","updated":"2023-06-10T12:46:28.780Z","comments":true,"path":"2023/04/26/学习-Linux-cgroup入门/","link":"","permalink":"http://example.com/2023/04/26/%E5%AD%A6%E4%B9%A0-Linux-cgroup%E5%85%A5%E9%97%A8/","excerpt":"cgroup（控制组）是 Linux 内核中的一个特性，用于限制、隔离和管理进程和系统资源的使用。它是一个层次化的组织结构，允许对进程进行分组，并为这些组分配系统资源，如 CPU、内存、磁盘 I&#x2F;O 和网络带宽。cgroup 主要用于操作系统的资源管理和容器技术，如 Docker 和 Kubernetes 等。 cgroup 的特点和功能包括： 资源限制：您可以为每个 cgroup 分配特定的系统资源，如 CPU 使用率、内存限制等。这有助于防止某个进程或组消耗过多资源，影响其他进程的运行。 资源隔离：cgroup 可以将不同组的进程隔离，这样它们不会互相影响。例如，在一个容器中运行的进程可以被限制在其所分配的资源范围内，不会影响到其他容器或系统进程。 资源监控：通过 cgroup，您可以监控每个组的资源使用情况，从而更好地了解系统的运行状态。这有助于发现性能瓶颈、优化资源分配等。 优先级控制：cgroup 允许您为进程组分配不同的优先级，以确保关键任务始终优先获得资源。","text":"cgroup（控制组）是 Linux 内核中的一个特性，用于限制、隔离和管理进程和系统资源的使用。它是一个层次化的组织结构，允许对进程进行分组，并为这些组分配系统资源，如 CPU、内存、磁盘 I&#x2F;O 和网络带宽。cgroup 主要用于操作系统的资源管理和容器技术，如 Docker 和 Kubernetes 等。 cgroup 的特点和功能包括： 资源限制：您可以为每个 cgroup 分配特定的系统资源，如 CPU 使用率、内存限制等。这有助于防止某个进程或组消耗过多资源，影响其他进程的运行。 资源隔离：cgroup 可以将不同组的进程隔离，这样它们不会互相影响。例如，在一个容器中运行的进程可以被限制在其所分配的资源范围内，不会影响到其他容器或系统进程。 资源监控：通过 cgroup，您可以监控每个组的资源使用情况，从而更好地了解系统的运行状态。这有助于发现性能瓶颈、优化资源分配等。 优先级控制：cgroup 允许您为进程组分配不同的优先级，以确保关键任务始终优先获得资源。 cgroup 分 v1 和 v2 两个版本，v1 实现较早，功能比较多，但是由于它里面的功能都是零零散散的实现的，所以规划的不是很好，导致了一些使用和维护上的不便，v2 的出现就是为了解决 v1 中这方面的问题，在 4.5 内核中，cgroup v2 声称已经可以用于生产环境了，但它所支持的功能还很有限，随着 v2 一起引入内核的还有 cgroup namespace。v1 和 v2 可以混合使用，但是这样会更复杂，所以一般没人会这样用。 为什么需要cgroup在 Linux 里，一直以来就有对进程进行分组的概念和需求，比如 session group， progress group 等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和 IO 使用情况等，于是出现了 cgroup，用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理等。 什么是cgroup术语 cgroup 在不同的上下文中代表不同的意思，可以指整个 Linux 的 cgroup 技术，也可以指一个具体进程组。 cgroup 是 Linux 下的一种将进程按组进行管理的机制，在用户层看来，cgroup 技术就是把系统中的所有进程组织成一颗一颗独立的树，每棵树都包含系统的所有进程，树的每个节点是一个进程组，而每颗树又和一个或者多个 subsystem 关联，树的作用是将进程分组，而 subsystem 的作用就是对这些组进行操作。cgroup 主要包括下面两部分： subsystem : 一个 subsystem 就是一个内核模块，他被关联到一颗 cgroup 树之后，就会在树的每个节点（进程组）上做具体的操作。subsystem 经常被称作 resource controller，因为它主要被用来调度或者限制每个进程组的资源，但是这个说法不完全准确，因为有时我们将进程分组只是为了做一些监控，观察一下他们的状态，比如 perf_event subsystem。到目前为止，Linux 支持 12 种 subsystem，比如限制 CPU 的使用时间，限制使用的内存，统计 CPU 的使用情况，冻结和恢复一组进程等 hierarchy : 一个 hierarchy 可以理解为一棵 cgroup 树，树的每个节点就是一个进程组，每棵树都会与零到多个 subsystem 关联。在一颗树里面，会包含 Linux 系统中的所有进程，但每个进程只能属于一个节点（进程组）。系统中可以有很多颗 cgroup 树，每棵树都和不同的 subsystem 关联，一个进程可以属于多颗树，即一个进程可以属于多个进程组，只是这些进程组和不同的 subsystem 关联。目前 Linux 支持 12 种 subsystem，如果不考虑不与任何 subsystem 关联的情况（systemd 就属于这种情况），Linux 里面最多可以建 12 颗 cgroup 树，每棵树关联一个 subsystem，当然也可以只建一棵树，然后让这棵树关联所有的 subsystem。当一颗 cgroup 树不和任何 subsystem 关联的时候，意味着这棵树只是将进程进行分组，至于要在分组的基础上做些什么，将由应用程序自己决定，systemd 就是一个这样的例子。 查看当前系统支持哪些subsystem可以通过查看&#x2F;proc&#x2F;cgroups（Linux v5.19.0-38-generic），知道当前系统支持哪些subsystem 123456789101112131415#subsys_name hierarchy num_cgroups enabledcpuset 0 149 1cpu 0 149 1cpuacct 0 149 1blkio 0 149 1memory 0 149 1devices 0 149 1freezer 0 149 1net_cls 0 149 1perf_event 0 149 1net_prio 0 149 1hugetlb 0 149 1pids 0 149 1rdma 0 149 1misc 0 149 1 从左到右，字段的含义分别是： subsystem的名字 subsystem所关联到的cgroup树的ID，如果多个subsystem关联到同一颗cgroup树，那么他们的这个字段将一样，比如这里的cpu和cpuacct就一样，表示他们绑定到了同一颗树。如果出现下面的情况，这个字段将为0： 当前subsystem没有和任何cgroup树绑定 当前subsystem已经和cgroup v2的树绑定 当前subsystem没有被内核开启 subsystem所关联的cgroup树中进程组的个数，也即树上节点的个数 1表示开启，0表示没有被开启(可以通过设置内核的启动参数“cgroup_disable”来控制subsystem的开启). systemdsystemd 是一个 Linux 系统和服务管理器，它成为许多主流 Linux 发行版（如 Debian、Ubuntu、Fedora、RHEL 和 CentOS 等）的默认初始化系统（init system）。systemd 负责在系统启动时引导和管理后台进程（称为服务或守护进程），并在运行过程中对这些服务进行监控和管理。 systemd 的主要特点和优点包括： 并行启动服务：systemd 能够并行启动服务，从而加快系统启动速度。 按需启动服务：systemd 支持 socket 激活和 D-Bus 激活，可以根据需要按需启动服务。 服务管理和监控：systemd 提供了在运行时管理和监控服务的功能，如自动重启失败的服务、记录服务状态和日志等。 系统管理功能：除了管理服务，systemd 还提供了一些系统管理功能，如控制电源、管理用户会话和设备等。 systemd 使用名为 unit 的配置文件来管理服务和资源。这些配置文件定义了服务的启动顺序、依赖关系、运行参数等信息。Unit 可以是以下类型之一： 服务（Service）：后台进程（守护进程）。 套接字（Socket）：IPC 和网络套接字，用于按需启动服务。 设备（Device）：设备节点。 挂载点（Mount）：文件系统挂载点。 自动挂载点（Automount）：自动挂载文件系统。 目标（Target）：用于组织其他 Unit 的逻辑分组。 路径（Path）：文件系统路径，用于监视文件系统事件。 时间器（Timer）：定时器，用于定时启动其他 Unit。 快照（Snapshot）：保存当前系统状态的快照。 切片（Slice）：用于组织和管理系统资源的层次结构。 systemd 提供了一些命令行工具，如 systemctl、journalctl 等，用于管理和查询系统和服务状态。例如，你可以使用 systemctl start、systemctl stop、systemctl restart 等命令来控制服务。 所有的subsystems目前Linux支持下面12种subsystem cpu (since Linux 2.6.24; CONFIG_CGROUP_SCHED)用来限制cgroup的CPU使用率。 cpuacct (since Linux 2.6.24; CONFIG_CGROUP_CPUACCT)统计cgroup的CPU的使用率。 cpuset (since Linux 2.6.24; CONFIG_CPUSETS)绑定cgroup到指定CPUs和NUMA节点。 memory (since Linux 2.6.25; CONFIG_MEMCG)统计和限制cgroup的内存的使用率，包括process memory, kernel memory, 和swap。 devices (since Linux 2.6.26; CONFIG_CGROUP_DEVICE)限制cgroup创建(mknod)和访问设备的权限。 freezer (since Linux 2.6.28; CONFIG_CGROUP_FREEZER)suspend和restore一个cgroup中的所有进程。 net_cls (since Linux 2.6.29; CONFIG_CGROUP_NET_CLASSID)将一个cgroup中进程创建的所有网络包加上一个classid标记，用于tc和iptables。 只对发出去的网络包生效，对收到的网络包不起作用。 blkio (since Linux 2.6.33; CONFIG_BLK_CGROUP)限制cgroup访问块设备的IO速度。 perf_event (since Linux 2.6.39; CONFIG_CGROUP_PERF)对cgroup进行性能监控 net_prio (since Linux 3.3; CONFIG_CGROUP_NET_PRIO)针对每个网络接口设置cgroup的访问优先级。 hugetlb (since Linux 3.5; CONFIG_CGROUP_HUGETLB)限制cgroup的huge pages的使用量。 pids (since Linux 4.3; CONFIG_CGROUP_PIDS)限制一个cgroup及其子孙cgroup中的总进程数。 上面这些subsystem，有些需要做资源统计，有些需要做资源控制，有些即不统计也不控制。对于cgroup树来说，有些subsystem严重依赖继承关系，有些subsystem完全用不到继承关系，而有些对继承关系没有严格要求。 不同subsystem的工作方式可能差别较大，对系统性能的影响也不一样，本人不是这方面的专家，后续文章中只会从功能的角度来介绍不同的subsystem，不会涉及到他们内部的实现。 如何使用cgroupcgroup相关的所有操作都是基于内核中的cgroup virtual filesystem，使用cgroup很简单，挂载这个文件系统就可以了。一般情况下都是挂载到&#x2F;sys&#x2F;fs&#x2F;cgroup目录下，当然挂载到其它任何目录都没关系。 这里假设目录&#x2F;sys&#x2F;fs&#x2F;cgroup已经存在，下面用到的xxx为任意字符串，取一个有意义的名字就可以了，当用mount命令查看的时候，xxx会显示在第一列。 挂载一颗和所有subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup 1mount -t cgroup xxx /sys/fs/cgroup 挂载一颗和cpuset subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset 12mkdir /sys/fs/cgroup/cpusetmount -t cgroup -o cpuset 挂载一颗与cpu和cpuacct subsystem关联的cgroup树到&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct 12mkdir /sys/fs/cgroup/cpu,cpuacctmount -t cgroup -o cpu,cpuacct xxx /sys/fs/cgroup/cpu,cpuacct 挂载一棵cgroup树，但不关联任何subsystem，下面就是systemd所用到的方式 12mkdir /sys/fs/cgroup/systemdmount -t cgroup -o none,name=systemd xxx /sys/fs/cgroup/systemd 删除一个挂载 1sudo umount .... 在很多使用systemd的系统中，比如ubuntu 16.04，systemd已经帮我们将各个subsystem和cgroup树关联并挂载好了 运行命令查看： 1mount|grep cgroup 使用cgroup限制一个进程的CPU使用率(cgroup v2)首先安装cgroup工具 1sudo apt-get install cgroup-tools 确认系统正在使用cgroup v2 1cat /proc/self/cgroup 如果输出的第一行以0::开头，那么您的系统正在使用cgroup v2。 现在，我们将创建一个名为my_cgroup的cgroup，并限制其CPU使用率为50%。首先创建一个cgroup目录： 1sudo mkdir /sys/fs/cgroup/my_cgroup 接下来，为这个cgroup设置CPU权重。cgroup v2使用权重值来调整CPU使用率，范围是1-10000。默认值为100。要将CPU使用率限制为50%，我们将权重设置为50： 1echo 50 | sudo tee /sys/fs/cgroup/my_cgroup/cpu.weight 现在，我们将一个进程添加到my_cgroup。例如，假设我们有一个名为my_process的进程，其进程ID为xxxxx。要将此进程添加到my_cgroup，请执行以下命令： 1echo xxxxx | sudo tee -a /sys/fs/cgroup/my_cgroup/cgroup.procs 现在，my_process进程的CPU使用率将受到my_cgroup中的限制。 要查看cgroup的信息，可以运行以下命令： 12cat /proc/xxxxx/cgroupcat /sys/fs/cgroup/my_cgroup/cpu.weight 要删除一个cgroup，请使用以下命令： 1sudo rmdir /sys/fs/cgroup/my_cgroup 在删除cgroup目录之前，需要将所有进程移出这个cgroup。 查找属于cgroup的进程。通常，进程ID存储在cgroup.procs文件中。 1cat /sys/fs/cgroup/my_cgroup/cgroup.procs 将进程移出cgroup。或者将进程移到其他cgroup 1echo xxxxx | sudo tee /sys/fs/cgroup/cgroup.procs 确认my_cgroup中不再有进程。再次查看cgroup.procs文件，确保其中没有进程ID： 1cat /sys/fs/cgroup/my_cgroup/cgroup.procs 再次删除cgroup 1sudo rmdir /sys/fs/cgroup/my_cgroup 参考资料Linux Cgroup 入门教程：基本概念 – 云原生实验室 - Kubernetes|Docker|Istio|Envoy|Hugo|Golang|云原生 (icloudnative.io) Linux Cgroup系列（01）：Cgroup概述 - Linux程序员 - SegmentFault 思否","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"cgroup","slug":"cgroup","permalink":"http://example.com/tags/cgroup/"}]},{"title":"C++ 学习 Linux系统编程 文件IO","slug":"C++-学习-Linux系统编程-文件IO","date":"2023-04-26T08:01:56.000Z","updated":"2023-05-14T07:19:51.804Z","comments":true,"path":"2023/04/26/C++-学习-Linux系统编程-文件IO/","link":"","permalink":"http://example.com/2023/04/26/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6IO/","excerpt":"标准C库IO函数和Linux系统IO函数对比标准C库IO函数","text":"标准C库IO函数和Linux系统IO函数对比标准C库IO函数 标准C库IO函数是跨平台的，第三方库 标准C库函数和Linux系统函数是调用和被调用的关系 Linux函数更加低级更底层一些，效率更高 C函数更高级一些 标准C库IO函数和Linux系统IO的关系 虚拟地址空间 文件描述符 open函数命令man可以查看详细信息 12man 2 (Linux系统IO函数)man 3 (C标准库函数) 具体命令如下： 12345678910111213141516171819#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;//1、第一个open函数：打开一个已经存在的文件int open(const char* pathname, int flags);//不是函数重载，是通过可变参数实现这种效果//参数：//-pathname：要打开的文件路径//- flags：对文件操作权限设置还有其他设置(O_RDONLY,O_WRONLY,O_RDWR这三个设置是互斥的)//返回值：返回一个新的文件描述符，如果调用失败返回-1//errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号void perror(const char* s);//参数s：用户描述，比如hello，最终输出的内容是 hello：xxx// 作用：打印erroro对应的错误描述//2、第二个open函数：创建一个新的文件int open(const char* pathname, int flags, mode_t mode); 举例： 1234567891011121314151617#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; int fd = open(&quot;a.txt&quot;, O_RDONLY); if (fd == -1) &#123; perror(&quot;open&quot;); &#125; //关闭 close(fd); return 0;&#125; 运行结果为： open创建新文件12345678910int open(const char *pathname,int flags,mode_t mode);//参数：//- pathname：要创建文件的路径//- flags：对文件的操作权限和其他的设置// 必选项： O_RDONLY,O_WRONLY,O_RDWR这三个之间是互斥的// 可选项：O_CREAT 文件不存在创建新文件//- mode：八进制的数，表示创建出的新的文件的操作权限，比如：0775// 最终的权限是：mode &amp; ~umask（umask的作用是抹去某些权限）// flags参数是一个int类型的数据，占四个字节，32位// flags 32位，每一位就是一个标志位 12345678910111213141516#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;int main()&#123; //创建一个新的文件 int fd = open(&quot;create.txt&quot;, O_RDWR | O_CREAT, 0777); if (fd == -1) &#123; perror(&quot;open&quot;); &#125; //关闭文件描述符 close(fd);&#125; 编译运行这段代码之后，我们的文件夹中会创建一个create.txt文件 read、write函数12345678910111213141516171819#include&lt;unistd.h&gt;ssize_t read(int fd,void *buf,size_t count);//参数：//-fd：文件描述符，open得到的，通过这个文件描述符操作某个文件//- buf：需要读取数据存放的地方，数组的地址（传出参数）//- count：指定的数组的大小//返回值//- 成功：// - 大于0：返回实际读取到的字节数// - 等于0：文件已经读取完了//- 失败：-1，并且设置errnossize_t write(int fd,const void *buf,size_t count)//参数//- fd：文件描述符，open得到的，通过这个文件描述符操作某个文件//- buf：要往磁盘//- count：要写入的数据的实际的大小//返回值//- 成功：实际写入的字节数//- 失败：返回-1，并写入errno 例子，copyfile.c函数我们运行如下函数，将english.txt复制一份 123456789101112131415161718192021222324252627282930313233343536#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;int main()&#123; //1.通过open打开english.txt文件 int srcfd = open(&quot;english.txt&quot;, O_RDONLY); if (srcfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //2.创建一个新的文件（拷贝文件） int destfd = open(&quot;cpy.txt&quot;, O_WRONLY | O_CREAT, 0664); if (destfd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //3.频繁的读写操作 char buf[1024] = &#123; 0 &#125;; int len = 0; while ((len = read(srcfd, buf, sizeof(buf))) &gt; 0) &#123; write(destfd, buf, len); &#125; len = read(srcfd, buf, sizeof(buf)); //4.关闭文件 close(destfd); close(srcfd);&#125; lseek函数1234567891011121314151617181920//标准C库函数#include&lt;stdio.h&gt;int fseek(FILE* stream, long offset, int whence);//Linux系统函数#include&lt;sys/types.h&gt;#include&lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);//参数//- fd：文件描述符，通过open得到的，通过这个fd操作某个文件//- offset：偏移量//- whence：// SEEK_SET:设置文件指针的偏移量// SEEK_CUR:设置偏移量，从当前位置加上当前参数offset的值// SEEK_END:设置偏移量，文件的大小加第二个参数offset的值//返回值：返回文件指针所在的位置//作用：//1、移动文件指针到文件头 lseek(fd,0,SEEK_SET);//2、获取当前文件指针的位置 lseek(fd,0,SEEK_CUR);//3、获取文件长度 lseek(fd,0,SEEK_END);//4、拓展文件长度，当前文件10b，拓展到110b lseek(fd,100,SEEK_END); 需要写一次数据 例子：拓展hello.txt的文件长度12345678910111213141516171819202122232425#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int main()&#123; int fd = open(&quot;hello.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //扩展文件的长度 int ret = lseek(fd, 100, SEEK_END); if (ret == -1) &#123; perror(&quot;lseek&quot;); return -1; &#125; //写入空数据 write(fd, &quot; &quot;, 1); //关闭文件 close(fd);&#125; 运行结果为： stat、lstat函数stat结构体123456789101112131415struct stat&#123; dev_t st_dev;//文件的设备编号 ino_t st_ino;//节点 mode_t st_mode;//文件的类型和存取的权限 nlink_t st_nlink;//连接该文件的硬链接数目 uid_t st_uid;//用户ID gid_t st_gid;//组ID dev_t st_rev;//设备文件的设备编号 off_t st_size;//文件字节数，文件大小 blksize_t st_blksize;//块大小 blkcnt_t t_blocks;//块数 time_t st_atime;//最后一次访问时间 time_t st_mtime;//最后一次修改时间 time_t st_ctime;//最后一次改变事件，属性&#125; st_mode stat函数123456789101112#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;int stat(const char* pathname, struct stat* statbuf);//作用：获取一个文件相关的信息//参数：//- pathname：操作文件的路径//- statbuf：结构体变量，传出参数，用于保存获取到的文件信息//返回值//- 成功：返回0//- 失败：返回-1，设置errnoint lstat(const char* pathname, struct stat* statbuf);//获取软连接信息 例子：获取文件a.txt的长度12345678910111213141516#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; struct stat statbuf; int ret = stat(&quot;a.txt&quot;, &amp;statbuf); if (ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; printf(&quot;size: %ld\\n&quot;, statbuf.st_size);&#125; 运行结果为： 模拟实现ls-l命令ls -l会列出当前文件的信息 我们实现一个ls-l.c模拟实现ls -l命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;unistd.h&gt;#include&lt;pwd.h&gt;#include&lt;grp.h&gt;#include&lt;time.h&gt;#include&lt;string.h&gt;int main(int argc, char* argv[])&#123; // if (argc &lt; 2) &#123; printf(&quot;%s filename\\n&quot;, argv[0]); return -1; &#125; //通过stat函数获取用户传入的文件的信息 struct stat st; int ret = stat(argv[1], &amp;st); if (ret == -1) &#123; perror(&quot;stat&quot;); return -1; &#125; //获取文件类型和文件权限 char perms[11] = &#123; 0 &#125;;//用于保存文件类型和文件权限的字符串 switch (st.st_mode&amp;__S_IFMT) &#123; case __S_IFLNK: perms[0] = &#x27;1&#x27;; break; case __S_IFDIR: perms[0] = &#x27;d&#x27;; break; case __S_IFREG: perms[0] = &#x27;-&#x27;; break; case __S_IFBLK: perms[0] = &#x27;b&#x27;; break; case __S_IFCHR: perms[0] = &#x27;c&#x27;; break; case __S_IFSOCK: perms[0] = &#x27;s&#x27;; break; case __S_IFIFO: perms[0] = &#x27;p&#x27;; break; default: perms[0] = &#x27;?&#x27;; break; &#125; //判断文件的访问权限 //文件所有者 perms[1] = (st.st_mode &amp; S_IRUSR) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[2] = (st.st_mode &amp; S_IWUSR) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[3] = (st.st_mode &amp; S_IXUSR) ? &#x27;x&#x27; : &#x27;-&#x27;; //文件所在组 perms[4] = (st.st_mode &amp; S_IRGRP) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[5] = (st.st_mode &amp; S_IWGRP) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[6] = (st.st_mode &amp; S_IXGRP) ? &#x27;x&#x27; : &#x27;-&#x27;; //其他人 perms[7] = (st.st_mode &amp; S_IROTH) ? &#x27;r&#x27; : &#x27;-&#x27;; perms[8] = (st.st_mode &amp; S_IWOTH) ? &#x27;w&#x27; : &#x27;-&#x27;; perms[9] = (st.st_mode &amp; S_IXOTH) ? &#x27;x&#x27; : &#x27;-&#x27;; //硬链接数 int LinkNum = st.st_nlink; //文件所有者 char* fileuser = getpwuid(st.st_uid)-&gt;pw_name; //文件所在组 char* filegrp = getgrgid(st.st_gid)-&gt;gr_name; //文件大小 long int filesize = st.st_size; //获取修改的时间 char* time = ctime(&amp;st.st_mtime); char mtime[512] = &#123; 0 &#125;; strncpy(mtime, time, strlen(time) - 1); char buf[1024]; sprintf(buf, &quot;%s %d %s %s %ld %s %s&quot;, perms, LinkNum, fileuser, filegrp, filesize, mtime, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125;Num, fileuser, filegrp, filesize, time, argv[1]); printf(&quot;%s\\n&quot;, buf); return 0;&#125; 运行结果如下： 文件属性操作函数access函数1234567#include&lt;unistd.h&gt;int access(const char* pathname, int mode);//作用：判断某个文件是否有某个权限，或者判断文件是否存在//参数//- pathname：判断文件路径//- mode：R_OK是否有读权限，W_OK是否有写权限，X_OK是否有执行权限，F_OK判断文件是否存在//返回值：成功返回0，失败返回-1 例子：判断文件权限123456789101112#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = access(&quot;a.txt&quot;, F_OK); if (ret == -1) &#123; perror(&quot;access&quot;); &#125; printf(&quot;文件存在\\n&quot;);&#125; 运行结果为： chmod函数1234567#include&lt;sys/stat.h&gt;int chmod(const char* pathname, mode_t mode);//修改文件的权限//参数//- pathname：需要修改的文件的路径//- mode：需要修改的权限值，八进制数//返回值：成功返回0，失败返回-1 例子：修改文件权限123456789101112#include&lt;sys/stat.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = chmod(&quot;a.txt&quot;, 0775); if (ret == -1) &#123; perror(&quot;chmod&quot;); return -1; &#125; return 0;&#125; chown函数1int chown(const char *pathname, uid_t owner, gid_t group); truncate函数12345678#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;int truncate(const char* path, off_t length);//作用：缩减或扩展文件的尺寸至指定的大小//参数：//- path：需要修改的文件路径//- length：需要最终文件变成的大小//返回值：成功返回0，失败返回-1 例子12345678910111213#include&lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = truncate(&quot;a.txt&quot;, 20); if (ret == -1) &#123; perror(&quot;truncate&quot;); return -1; &#125; return 0;&#125; 目录操作函数mkdir函数12345678#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;int mkdir(const char* pathname, mode_t mode);//作用：创建一个目录//参数//- pathname：创建的目录的路径//- mode：权限，八进制的数//返回值：失败返回-1，成功返回0 例子：创建一个名为aaa的目录 12345678910111213#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;stdio.h&gt;int main()&#123; int ret = mkdir(&quot;aaa&quot;, 0777); if (ret == -1) &#123; perror(&quot;mkdir&quot;); return -1; &#125; return 0;&#125; rmdir函数1int rmdir(const char* pathname); rename函数1int rename(const char* oldpath,const char* newpath); 例子：修改目录aaa为bbb 1234567891011#include&lt;stdio.h&gt;int main()&#123; int ret = rename(&quot;aaa&quot;, &quot;bbb&quot;); if (ret == -1) &#123; perror(&quot;rename&quot;); return -1; &#125; return 0;&#125; chdir函数，getcwd函数1234567891011#include&lt;unistd.h&gt;int chdir(const char* path);//作用：修改进程的工作目录//参数：//- path：需要修改的工作目录char* getcwd(char* buf, size_t size);//作用：获取当前工作目录//参数：//- buf：存储的路径，指向的是一个数组//- size：数组的大小//返回值：返回指向的一块内存，这个数据就是第一个参数 例子：修改当前工作目录 12345678910111213141516171819202122232425262728293031323334#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //获取当前的工作目录 char buf[128]; getcwd(buf, sizeof(buf)); printf(&quot;当前的工作目录是：%s\\n&quot;, buf); //修改工作目录 int ret = chdir(&quot;/home/plucky/Linux/lecture14/bbb&quot;); if (ret == -1) &#123; perror(&quot;chdir&quot;); return -1; &#125; //创建一个新的文件 int fd = open(&quot;chdir.txt&quot;, O_CREAT | O_RDWR, 0664); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; close(fd); //获取当前的工作目录 char buf1[128]; getcwd(buf1, sizeof(buf1)); printf(&quot;当前的工作目录是：%s\\n&quot;, buf1); return 0;&#125; 目录遍历函数1234567891011121314#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;DIR* opendir(const char* name);//功能：打开一个目录//参数：//- name：需要打开的目录的名称//返回值：DIR* 类型，理解为目录流，错误返回NULLstruct dirent* readdir(DIR* dirp);//功能：读取目录中的数据//参数：//- dirp：opendir返回的结果//返回值：struct dirent*，代表读取到的文件的信息。读取到了文件末尾或者失败了返回NULLint closedir(DIR* dirp);//功能：关闭目录 例子：计算文件夹中普通文件的个数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;sys/types.h&gt;#include&lt;dirent.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;int getFileNum(const char* path);//读取某个目录下所有普通文件的个数int main(int argc, char* argv[])&#123; if (argc &lt; 2) &#123; printf(&quot;%s path\\n&quot;, argv[0]); return -1; &#125; int num = getFileNum(argv[1]); printf(&quot;普通文件的个数为：%d\\n&quot;, num); return 0;&#125;//用于读取目录下所有普通文件的个数int getFileNum(const char* path)&#123; //1、打开目录 DIR* dir = opendir(path); if (dir == NULL) &#123; perror(&quot;opendir&quot;); exit(0); &#125; //记录普通文件的个数 int total = 0; struct dirent* ptr; while ((ptr = readdir(dir)) != NULL) &#123; //获取名称 char* dname = ptr-&gt;d_name; //忽略掉. 和.. if (strcmp(dname, &quot;.&quot;) == 0 || strcmp(dname, &quot;..&quot;) == 0) &#123; continue; &#125; //判断是否是普通文件还是目录 if (ptr-&gt;d_type == DT_DIR) &#123; //目录，需要继续读取这个目录 char newpath[256]; sprintf(newpath, &quot;%s/%s&quot;, path, dname); total += getFileNum(newpath); &#125; if (ptr-&gt;d_type == DT_REG) &#123; //普通文件 total++; &#125; &#125; //关闭目录 closedir(dir); return total;&#125; 运行结果为： dup、dup2函数dup函数12345#include&lt;unistd.h&gt;int dup(int oldfd);//作用：复制一个新的文件描述符//fd=3，int fd1=dup（fd），两个文件描述符指向同一个文件//从空闲的文件描述符中找一个最小的，作为新的拷贝的文件描述符 例子：创建文件a.txt并且用dup复制的文件描述符修改a.txt 123456789101112131415161718192021222324252627#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;string.h&gt;int main()&#123; int fd = open(&quot;a.txt&quot;, O_RDWR | O_CREAT, 0664); int fd1 = dup(fd); if (fd1 == -1) &#123; perror(&quot;dup&quot;); return -1; &#125; printf(&quot;fd : %d , fd1 : %d\\n&quot;, fd, fd1); close(fd); char* str = &quot;hello,world&quot;; int ret = write(fd1, str, strlen(str)); if (ret == -1) &#123; perror(&quot;write&quot;); return -1; &#125; close(fd1); return 0;&#125; dup2函数1234567#include&lt;unistd.h&gt;int dup2(int oldfd, int newfd);//作用：重定向文件描述符//oldfd指向a.txt,newfd指向b.txt//调用函数成功后：newfd和b.txt做close，newfd指向了a.txt//oldfd必须是一个有效的文件描述符//oldfd和newfd值相同相当于什么都没有做 例子： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;sys/stat.h&gt;#include&lt;sys/types.h&gt;#include&lt;fcntl.h&gt;int main()&#123; int fd = open(&quot;1.txt&quot;, O_RDWR | O_CREAT, 0664); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; int fd1 = open(&quot;2.txt&quot;, O_RDWR | O_CREAT, 0664); if (fd1 == -1) &#123; perror(&quot;open&quot;); return -1; &#125; printf(&quot;fd: %d,fd1: fd1: %d\\n&quot;, fd, fd1); int fd2 = dup2(fd, fd1); if (fd2 == -1) &#123; perror(&quot;dup2&quot;); return -1; &#125; //通过fd1去写数据，实际操作的是1.txt，而不是2.txt char* str = &quot;Hello,dup2&quot;; int len = write(fd1, str, strlen(str)); if (len == -1) &#123; perror(&quot;write&quot;); return -1; &#125; printf(&quot;fd: %d,fd1: %d,fd2: %d\\n&quot;, fd, fd1, fd2);&#125; fcntl函数123456789101112131415161718#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int fcntl(int fd, int cmd, ... /*argv*/);//参数//- fd：表示需要操作的文件描述符//- cmd：表示对文件描述符进行如何操作// F_DUPFD复制文件描述符，复制的是第一个参数fd，得到一个新的文件描述符// int ret = fcntl(fd,F_DUPFD);//// F_GETFL获取指定的文件描述符文件状态flag// 获取的flag和我们通过open函数传递的flag是一个东西//// F_SETFL：设置文件描述符文件状态flag// 必选项：O_RDONLY,O_WRONLY,O_RDWR不可以被修改// 可选项：O_APPEND,NONBLOCK// O_APPEND表示追加数据// NONBLOCK设置成非阻塞// 阻塞和非阻塞：描述的是函数调用的行为。 例子： 12345678910111213141516171819202122232425262728#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; // 复制文件描述符 // int fd = open(&quot;1.txt&quot;, O_RDONLY); // int ret = fcntl(fd, F_DUPFD); //修改或者获取文件状态flag int fd = open(&quot;1.txt&quot;, O_RDWR); if (fd == -1) &#123; perror(&quot;open&quot;); return -1; &#125; //获取文件描述符的状态flag int flag = fcntl(fd, F_GETFL); flag |= O_APPEND; //修改文件描述符状态的flag，给flag加入O_APPEND标记 int ret = fcntl(fd, F_SETFL, flag); char* str = &quot;hi&quot;; write(fd, str, strlen(str)); close(fd);&#125;","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"C++ 学习 Linux系统编程 GDB调试","slug":"C++-学习-Linux系统编程-GDB调试","date":"2023-04-25T00:02:33.000Z","updated":"2023-05-14T07:16:09.632Z","comments":true,"path":"2023/04/25/C++-学习-Linux系统编程-GDB调试/","link":"","permalink":"http://example.com/2023/04/25/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GDB%E8%B0%83%E8%AF%95/","excerpt":"什么是GDBGDB是由GUN软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境 一般来说，GDB主要帮助你完成下面四个方面的功能：","text":"什么是GDBGDB是由GUN软件系统社区提供的调试工具，同GCC配套组成了一套完整的开发环境，GDB是Linux和许多类Unix系统中的标准开发环境 一般来说，GDB主要帮助你完成下面四个方面的功能： 1、启动程序，可以按照自定义的要求随心所欲的运行程序 2、可让被调试的程序在所指定的调置的断点处停住（断点可以是条件表达式） 3、当程序被停住时，可以检查此时程序中所发生的事 4、可以改变程序，将一个BUG产生的影响修正从而测试其他的BUG 准备工作通常在为调试而编译时，我们会关掉编译器的优化选项（-o），并打开调试选项（-g）。另外，-Wall在尽量不影响程序的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的BUG。 1gcc -g -Wall program.c -o program -g选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。 GDB命令 1gcc test.c -o test -g 之后运行如下命令 1gdb test 命令 启动和退出 1gdb 1quit 给程序设置参数&#x2F;获取设置参数 1set args 10 20 1show args GDB使用帮助 1help 查看当前文件代码 从默认位置显示 从指定的行显示 从指定函数显示 123list/llist/l 行号list/l 函数名 查看非当前文件代码 12list/l 文件名：行号list/l 文件名：函数名 设置显示的行数 12show list/listsizeset list/listsize 行数 设置断点 1234b/break 行号b/break 函数名b/break 文件名：行号b/break 文件名：函数 查看断点 1info/i break/b 删除断点 1d/del/delte 断点编号 设置断点无效 1dis/disable 断点编号 设置断点生效 1ena/enable 断点编号 设置断点条件（一般用在循环的位置） 1b/break 10 if i==5 GDB命令-调试命令 运行GDB程序 12start(程序停在第一行)run(遇到断点才停) 继续运行，到下一个断点停 1c/continue 向下执行一行代码 1n/next 变量操作 12p/print 变量名(打印变量值)ptype 变量名(打印变量类型) 向下单步调试（遇到函数进入函数体） 12s/stepfinish(跳出函数体) 自动变量操作 123display num(自动打印指定变量的值)i/info displayundisplay 编号 其他操作 12set var 变量名 = 变量值until (跳出循环) next和step的区别 next是一步步往下运行代码，不会进入函数体中中 自动设置变量例子","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"C++ 学习 Linux系统编程 Makefile","slug":"C++-学习-Linux系统编程-Makefile","date":"2023-04-24T05:30:29.000Z","updated":"2023-05-14T07:19:20.386Z","comments":true,"path":"2023/04/24/C++-学习-Linux系统编程-Makefile/","link":"","permalink":"http://example.com/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/","excerpt":"什么是Makefile一个工程中源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。 Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发效率。make是一个命令工具，是一个工程完全编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，Visual C++的make，Linux下GUN的make","text":"什么是Makefile一个工程中源文件不计其数，其按类型、功能、模块分别放在若干个目录中，Makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile文件就像一个Shell脚本一样，也可以执行操作系统的命令。 Makefile带来的好处就是“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发效率。make是一个命令工具，是一个工程完全编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释Makefile文件中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如Delphi的make，Visual C++的make，Linux下GUN的make Makefile文件命名和规则 文件命名 makefile或者Makefile Makefile规则 一个Makefile文件中可以有一个或多个规则 目标 …: 依赖 … 命令（shell命令） … 目标：最终要生成的文件（伪目标除外） 依赖：生成目标文件所需要的文件或是目标 命令：通过执行命令对依赖操作生成目标（命令前必须Tab缩进） 例子我们现在有文件： 编辑Makefile文件 12app:sub.c add.c mult.c div.c main.c gcc sub.c add.c mult.c div.c main.c -o app 运行结果如下： Makefile的工作原理 命令在执行之前，需要先检查规则中的依赖是否存在 如果存在，执行命令 如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令 检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间 如果依赖的时间比目标的时间晚，需要重新生成目标 如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行 我们修改Makefile文件内容为： 1234567891011121314app:sub.o add.o mult.o div.o main.o gcc sub.o add.o mult.o div.o main.o -o appsub.o:sub.c gcc -c sub.c -o sub.oadd.o:add.c gcc -c add.c -o add.odiv.o:div.c gcc -c div.c -o div.omain.o:main.c gcc -c main.c -o main.o 我们输入命令make 变量 自定义变量 变量名 &#x3D; 变量值 var &#x3D; hello 预定义变量 AR：归档维护程序的名称，默认值为ar CC：C编译器的名称，默认值为cc CXX：C++编译器的名称，默认值为g++ $@：目标的完整名称 $&lt;：第一个依赖文件的名称 $^：所有的依赖文件 获取变量的值 $(变量名) 12app:main.c a.c b.c gcc -c main.c a.c b.c 12app:main.c a.c b.c $(CC) -c $^ -o $@ 上两段代码等价 1%.o:%.o % 为通配符，匹配一个字符串 两个%匹配的是同一个字符串 我们上述的Makefile文件也可改为 1234567src = sub.o add.o mult.o div.o main.otarget = app$(target):$(src) $(CC) &amp;(src) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@ 函数$(wildcard PATTERN …) 功能：获取指定目录下指定类型的文件列表 参数：PATTERN指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔 返回：得到的若干个文件的文件列表，文件名之间使用空格间隔 示例： 1$(wildcard *.c ./sub/*c) 返回值格式：a.c b.c c.c d.c e.c f.c $(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;) 功能：查找中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式,如果匹配的话，则以替换。 可以包括通配符%,表示任意长度的字符串。如果中也包含%，那么，中的这个%将是中的那个%所代表的字符串。（可以用\\来转义，以\\%来表示真实含义的%字符） 返回：函数返回被替换过后的字符串 示例 1$(patsubst %.c, %.o, x.c bar.c) 返回值格式：x.o bar.o 1234567891011src=$(wildcard ./*.c)objs=$(patsubst %.c, %.o, $(src))target=app$(target):$(objs) $(CC) $(objs) -o $(target)%.o:%.c $(CC) -c $&lt; -o $@clean: rm $(objs) -f 之后运行 1make clean 就会自动删除rm指令","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"论文阅读 Making Memory Account Accountable：Analyzing and Detecting Memory Missing account bugs for Container Platforms","slug":"论文阅读-Making-Memory-Account-Accountable：Analyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms","date":"2023-04-23T11:09:13.000Z","updated":"2023-05-03T10:12:16.789Z","comments":true,"path":"2023/04/23/论文阅读-Making-Memory-Account-Accountable：Analyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/","link":"","permalink":"http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/","excerpt":"摘要 Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。 在本文中，我们首次系统地研究了内存记账缺失问题。我们首先对其在容器平台上的可利用性和安全性影响进行了深入分析。然后我们开发了一个名为MANTA(Memory Accounting Analyzer)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。","text":"摘要 Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。 在本文中，我们首次系统地研究了内存记账缺失问题。我们首先对其在容器平台上的可利用性和安全性影响进行了深入分析。然后我们开发了一个名为MANTA(Memory Accounting Analyzer)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。 我们的分析表明，所有的容器运行时，包括runC和Kata容器，都容易受到基于内存记账缺失的攻击。此外，内存记账缺失可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而使单个节点甚至整个集群崩溃。我们的工具报告了53个可利用的内存记账缺失漏洞，其中37个被内核开发者确认，并提交了相应的补丁，还有两个新的CVE被分配。通过深入分析、自动检测、报告的错误和提交的补丁，我们相信我们的研究提高了容器平台内存核算的正确性和安全性。 CCS CONCEPTS Security and privacy → Operating systems security; Virtualization and security KEYWORDS Cloud infrastructure, Linux kernel, memory accounting, missingaccount, DoS attack INTRODUCTION计算和限制内存使用是每个操作系统内核的核心功能。特别是，Linux内核引入了内存控制组(memcg)，它可以在进程级别解释和限制内存使用。因此，与基于虚拟机(VM)的内存分区技术相比，memcg具有更细粒度和轻量级的特点。 由于其灵活性和高效性，memcg已经被容器平台广泛采用。众所周知，容器平台严重依赖资源共享来提高硬件资源的利用率。而memcg为容器在进程级别提供了唯一的内存使用记录和限制方法。因此，诸如Docker 、容器即服务平台（例如，OpenShift）和函数即服务平台（例如，OpenWhisk）等流行的容器平台，都采用memcg来控制其容器的内存使用。此外，基于虚拟机的容器运行时——Kata容器 也使用memcg来限制主机上的容器线程和其他服务线程的内存。此外，开放容器倡议（OCI）认证要求容器运行时必须使用memcg才能获得认证 。因此，memcg已经成为容器平台和云计算的基础技术。 不幸的是，尽管memcg被广泛使用，但由于其复杂性，它容易出错。具体来说，Linux内核选择将内存记账接口插入到内存分配&#x2F;释放路径中以实现记账，这可能由于高度复杂的内存使用和大量与内存使用相关的接口和代码路径，容易引入内存记账丢失错误（分配的内存未计入账户）。此外，即使记账接口位置正确，它们的记账行为也是有条件的，并受到记账标志的控制，我们发现这些标志经常缺失。因此，我们发现内存记账丢失错误很常见。 然而，即使memcg已经被广泛使用，其内存记账丢失漏洞从未得到系统分析。 memcg的现状是由两个原因造成的。首先，从来没有清楚地知道内存记账丢失漏洞会产生什么安全影响或者它们是否可利用。结果，记账丢失错误被内核开发人员忽略，并且没有特别努力消除这些问题。其次，没有自动检测内存记账丢失漏洞。正如之前讨论的那样，内存记帐设计和实现非常复杂，并深度集成到Linux kernel的复杂内存管理子系统中。因此，即使对于有经验的用户来说也很难正确理解记帐设计和策略。例如，我们发现Docker官方网站错误地声称“页面高速缓存的记忆费用在控制组之间分配”，并且“当一个cgroup终止时，它可能会增加另一个cgroup 的内存使用量“。因此，在没有自动检测的情况下手动推断记帐正确性几乎是不可能的更糟糕的是, 内存记账丢失是否可检测以及如何进行检测仍然是开放性问题。 本文首次对Linux内存记账丢失错误进行了系统分析和检测。我们首先进行了深入分析，以了解内存记账丢失错误在容器平台上的可利用性和安全影响。然后我们开发了一个名为MANTA（Memory AccouNTing Analyzer的简称）的工具，它结合了静态和动态分析技术来自动检测内存记账丢失错误。我们的分析显示，不仅普通容器运行时（如runC），而且安全容器运行时（如Kata容器）都容易受到由内存记账丢失错误引起的内存耗尽攻击。更糟糕的是，内存记账丢失错误可以被利用来攻击Docker、CaaS和FaaS平台，导致容器节点甚至整个集群崩溃。 由于memcg的复杂性，内存记账丢失检测面临两个挑战。首先，没有文档或现有研究定义了memcg使用的内存记账接口。现有的工作采用自然语言处理或包装函数分析来识别内存分配接口。然而，由于不匹配的启发式规则，这些技术无法直接应用于记账接口。为解决这个问题，MANTA提出了基于计数器的接口识别方法，自动检测所有与内存记账相关的接口。关键的观察是，所有内存记账接口最终都会在实现中增加&#x2F;减少相应的页面计数器。识别从页面计数器修改开始，迭代整个调用图以精确识别记账接口。 其次，分析内存分配和内存记账之间的映射具有挑战性。这种分析由于从内存分配位置到内存记账位置的深层和嵌套执行路径而变得复杂。它还需要跟踪分配的页面和计入账户的页面之间的数据流，以获得正确的别名集。此外，由于条件标志的控制，记账可能是有条件的。因此，MANTA提出了分配-消耗映射分析和记账标志分析来解决这个挑战。此外，为了验证检测到的内存记账丢失错误，MANTA进一步使用Linux测试项目来检查它们的可触发性和影响。 通过MANTA，我们检测并报告了memcg中的53个可利用错误，其中37个已经被内核开发人员确认并有已合并或待合并的补丁。报告的错误获得了两个新的CVE（一个正在等待）。总之，这项工作进行了深入调查，不仅分析了可利用性和影响，还系统地检测了内存记账丢失错误。我们相信，这些发现将有助于内核memcg开发人员在未来改进内存记账。本文做出了以下贡献。 In-depth analysis of exploitability and impacts 我们设计了新的攻击来利用容器平台上的内存记账问题。我们的攻击表明，内存记账丢失漏洞可以很容易地被利用来攻击正常和安全的容器运行时(即runC和Kata容器)和流行的容器平台(即Docker, OpenShift和OpenWhisk)，导致容器节点甚至整个集群崩溃。 Automated detection with new techniques 我们提出了多种分析技术来有效地检测内存记账丢失错误，集成了静态分析和动态验证。我们实现了基于LLVM的检测，并使用Linux内存记账对其进行评估。我们进一步使用Linux Test Project (LTP)来验证检测到的错误的可触发性。 Community impact 我们在Linux v5.10中检测并报告了53个可利用的内存记账丢失错误，其中37个已被内核开发人员确认。分配了两个新的cve(一个正在等待)。我们的发现提高了内核社区对记账丢失的影响的认识，他们还邀请我们测试他们的下游内核。我们计划开源我们的检测工具，以进一步帮助社区提高内存计费的正确性和安全性。 道德考虑：本文中的所有实验和攻击都是在一台专用的物理机器上进行的，这台机器仅由我们使用。我们负责任地向Linux内核开发人员披露了所有检测到的错误，并为所有经确认的错误提交了补丁。此外，我们还向Docker团队报告了关于内存记账的错误声明。 BACKGROUDLinux Memory Accounting内存记帐是每个现代操作系统内核的核心功能。目前Linux内核采用内存控制组(memory control group, memcg)来实现内存计费。Memcg包含4种类型的内存:user、kernel、swap，and socket。 user 记录所有用户空间内存页 kernel 记录内核空间内存页和对象 swap 记录交换区页面 socket 记录socket内存 Memcg仅对用户空间进程的内存进行记账，并跳过对内核守护程序或内部内存使用的记账。需要注意的是，Linux内核v5.9引入了对象cgroup，它会对子页面内核内存使用（如内核对象）进行记账。对象cgroup可以将对象分配到不同的cgroups中，从而消除每个memcg的slab（内存分配池），节省大量的slab内存。 Accounting：Linux内核针对不同类型的内存使用不同的记账接口。具体来说，Linux内核使用mem_cgroup_charge对用户和交换内存进行记账，使用__memcg_kmem_charge对内核内存进行记账。对于内核内存，Linux内核还要求在内存分配过程中设置__GFP_ACCOUNT标志以对内核页面进行记账。用户可以通过文件接口与memcg进行交互。例如，用户可以从memory.usage_in_bytes检查总内存使用情况。 一个memcg实例可能包含多个内存使用情况在其中进行记账的进程。memcg以树形层次结构组织，因此父节点上的内存限制也会影响所有子节点。memcg有两个版本：v1和v2。它们的主要区别在于层次结构和用户接口，而在记账方面的实现大致相同。目前两者都在使用。本文提到的是cgroups v1，大多数结论也适用于cgroups v2。 数据结构：memcg的核心数据结构是mem_cgroup，它代表一个memcg实例。memcg包含4个页面计数器，对应于之前讨论的4种类型的已记账内存。每个页面计数器使用usage（第14行）来计算分配的页面数量。同时，总内存限制（以页面为单位）设置在max（第16行）。在内存充电时，Linux内核调用消耗接口，依次调用page_counter_try_charge，这是一个计算总使用量（第24行）并将其与最大限制（第25行）进行检查的函数。 Accounting challenges：由于Linux内核中众多的内存分配接口和庞大的分配路径，正确地对Linux内核中的内存使用情况进行记账非常具有挑战性。很难调解所有内存分配路径，因此当前的记账机制容易出错。 12345678910111213141516171819202122232425262728293031struct mem_cgroup&#123; ... struct page_counter memory;/*Both v1 &amp; v2*/ union&#123; struct page_counter swap;/*v2 only */ struct page_counter memsw;/*v1 only*/ &#125;; /*Legacy consumer-oriented counters*/ struct page_counter kmem;/*v1 only*/ struct page_counter tcpmem;/*v1 only*/ ...&#125;struct page_counter&#123; atomic_long_t usage; ... unsigned long max; ...&#125;bool page_counter_try_charge(struct page_counter *counter,unsigned long nr pages,...)&#123; struct page_counter *c; ... new = atomic_long_add_return(nr_pages, &amp;c-&gt;usage);if(new&gt;c-&gt;max)&#123; ... goto failed;&#125;&#125; Container Runtimes and PlatformsMemcg可以记录和限制每个进程级别的内存使用情况。与基于虚拟机(VM)的内存控制技术相比，memcg粒度更细、更轻、更灵活。因此，memcg已经被Docker、CaaS (container -as- service)和FaaS (function -as- service)平台广泛采用。具体来说，CaaS平台为用户提供了已配置的容器实例。CaaS平台上的用户可以使用自定义的容器映像创建&#x2F;启动&#x2F;停止&#x2F;删除容器。另一方面，FaaS平台不向用户提供容器实例，而是允许用户输入函数和触发规则，并自动创建容器实例来执行输入函数。 Docker和CaaS&#x2F;FaaS平台通常为容器实例使用本地容器运行时(即runC)。为了提高容器之间的隔离性，人们提出了安全容器运行时，如gVisor和Kata容器。gVisor是谷歌开发的沙盒容器运行时。它在一个名为Sentry的用户空间内核上运行每个容器。Sentry拦截并处理来自容器的大多数系统调用。因此，Sentry减少了从容器在主机内核上调用的系统调用。除了沙盒运行时，容器社区还建议使用虚拟化来隔离容器实例。其中一个这样的虚拟化容器运行时是Kata容器，其中每个容器实例都在微型虚拟机中运行，以实现强隔离。 我们的实验表明，正常和安全的容器运行时(包括runC和Kata容器)都容易受到由记账丢失错误引起的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致单个节点甚至整个集群崩溃。 A STUDY OF EXPLOITABLITY AND IMPACT生产环境中内存未记录错误的影响从未被系统地研究过。它们通常被视为一个较小的正确性问题，而不是安全问题。在这一部分中，我们展示了内存未记录错误可以被利用来导致容器主机甚至整个云平台的内存耗尽。特别是，我们分析了内存记账问题的可利用性，以了解其对容器平台的实际影响。我们设计了新的攻击方法来利用未记录错误。这些攻击表明，这些错误可用于攻击普通和安全的容器运行时。因此，它们可被利用在热门的CaaS和FaaS容器平台上造成DoS（主机机器崩溃）和财务费用问题。在以下内容中，我们首先讨论威胁模型和假设。接下来，我们详细介绍如何利用内存未记录问题。 Threat Model and Assumptions在我们的实验中，我们研究了三个容器平台 - Docker、容器即服务（CaaS）平台和函数即服务（FaaS）平台。我们使用广泛部署的CaaS平台 - OpenShift作为我们的CaaS平台，以及流行的OpenWhisk作为我们的FaaS平台。这三个平台使用本地运行时（即runC）作为它们的容器运行时。这三个平台上的所有容器都以非特权方式设置为具有默认功能和seccomp配置。对于Docker和CaaS平台，用户可以通过云提供的接口创建和启动带有自定义映像的容器。这是合理的，因为包括AWS、Google Cloud和Azure在内的所有云供应商都为用户提供了一个控制台来管理容器实例。对于FaaS平台，用户可以定义、部署和触发函数，其中每个函数实例都在一个容器中运行。 攻击者是使用Docker、CaaS和FaaS平台的恶意用户。他&#x2F;她可以在非特权容器内执行任意代码。然而，容器的功能受到默认功能的限制。为了进一步限制攻击者，我们假设攻击者无法从容器中逃逸，也无法提升他们的权限。攻击者的目标是破坏内存计算的限制，并耗尽主机上的所有内存，以使其他容器、函数或主机崩溃。 对于攻击环境，我们在本地机器上设置Docker，同时在Google Cloud上设置OpenShift和OpenWhisk集群。出于道德考虑，该集群构建在一个由Google Cloud提供的专用裸金属服务器上，仅供我们使用，因此不会影响其他用户。 Exploit Missing-Account Problem在本节中，我们将设计新的攻击来利用内存记帐中的记账问题，以了解其影响。如前所述，Linux内核中的当前内存记帐将内存记帐接口放在内存分配路径上，将内存取消记帐接口放在内存空闲路径上。然而，Linux内存管理是复杂的，包含数千个内存分配和自由路径。很难用正确的接口来调解所有这些问题。特别是，很容易遗漏一个内存分配路径，从而导致丢失帐户问题。 显示了内核中信号量对象和信号量数组上的记账丢失错误，由MANTA检测并由Linux开发人员确认。函数sem_alloc分配一组信号量，并使用sem_array对它们进行索引。第8行的分配站点调用kvzalloc为sem_array和信号量分配内存。当在kvzalloc的第三个参数中设置了__GFP_ACCOUNT标志时，内核只会考虑分配的内存。然而，在第8行对kvzalloc的调用没有指定__GFP_ACCOUNT标志，导致在分配的信号量和sem_array上丢失帐户。此外，sem_alloc由semget系统调用调用来分配信号量。因此，这个记账丢失的错误很容易从用户空间触发。我们进一步设计了新的攻击，以表明上述漏洞可以被利用来打破容器内存限制并耗尽所有主机内存。 12345678910111213static struct sem_array *sem_alloc(size_t nsems)&#123; struct sem_array *sma; if(nsems &gt; (INT_MAX - sizeof(*sma)) / sizeof(sma-&gt;sems[0])) return NULL; sma = kvzalloc(struct_size(sma, sems, nsems),GFP_KERNEL); if(unlikerly(!sma)) return NULL; return sma;&#125; Attacking Docker我们用默认的功能和seccomp配置来设置Docker。semget系统调用不需要任何功能，也不会被容器seccomp配置文件阻塞。因此，在我们的实验中，攻击程序在非特权容器中可以反复触发semget系统调用，从而打破内存记帐限制，耗尽所有主机内存。主机甚至会因为内存不足错误而崩溃。我们向Linux社区报告了上述错误并提交了补丁。补丁已经被合并到Linux主线上，一个新的CVE已经分配给我们了。 Attacking the CaaS Platform我们在Google Cloud上搭建了一个自管理的OpenShift集群，运行所有的GCP虚拟机实例。该集群允许用户在一个具有15GB内存和Linux内核v5.14.14的节点上创建容器。我们将容器的内存限制设置为128MB，这是公共云中常用的内存大小。 为了发起攻击，恶意用户以普通用户权限创建一个容器，并在容器内分配大量信号量。恶意容器的内存使用量迅速增加，大约在20秒内达到节点的极限。相比之下，攻击者的计费内存使用量非常低，不到1.4MB。结果，恶意容器打破了128MB的内存限制，消耗了主机上的全部15GB内存。同一节点上的受害者容器由于内存不足无法执行任何操作。 Attacking the FaaS Platform我们评估了对OpenWhisk的攻击，OpenWhisk是一个流行的开源FaaS平台，作为IBM Cloud Functions的基础设施。集群节点内存为15GB，运行Linux内核v5.11.0-1021-gcp。每个功能的内存限制设置为128MB。 为了发起攻击，恶意用户创建了一个反复消耗信号量的函数。然后，恶意用户反复触发恶意功能。导致节点上的内存很快耗尽。注意，当一个节点的内存耗尽时，连续的恶意函数将被分派到其他节点。导致集群内所有节点的内存被恶意用户耗尽，导致集群级DoS。 Attacking the Secure Runtime我们进一步设计新的攻击来评估内存记账丢失对安全运行时- Kata容器的影响。我们的实验表明，内存记账丢失漏洞允许攻击者打破Kata容器的隔离并攻击主机和其他容器实例。 Kata容器是一种虚拟容器运行时，其中每个容器实例在微虚拟机中运行，以实现强隔离。但是，Kata micro-VM将文件操作转发给主机，这使得它容易受到基于内存记账丢失的攻击。更具体地说，通过利用内存记账丢失错误，攻击者可以耗尽微型虚拟机中Kata容器的主机内存。如图所示，恶意用户是容器中的普通用户，并发出fcntl系统调用，为一组文件分配大量POSIX锁。但是，客户机内核将请求转发给运行在主机上的virtio-fsd守护进程。 因此，守护进程在主机内核中分配了 POSIX 锁。尽管 virtio-fsd 守护进程的内存使用受到 memcg（内存控制组）的限制，但锁对象所使用的内存没有被纳入统计。因此，恶意容器可以耗尽主机上的所有物理内存。我们向 Kata 容器社区报告了这种攻击。他们确认了这个问题，并为我们申请了一个新的 CVE（公开披露的计算机安全漏洞和漏洞）。 用通俗的语言来说，这段话描述了一个安全问题，其中，虚拟文件系统管理的守护程序在主机操作系统上分配了一种名为 POSIX 锁的资源。虽然这个守护程序的内存使用受到限制，但锁对象占用的内存没有被计算在内。这意味着一个恶意的容器（一种轻量级的虚拟化技术）可以利用这个问题耗尽主机的物理内存。作者报告了这个问题，并且 Kata 容器社区已经确认该问题，并正申请一个新的安全漏洞编号（CVE）。 Discussion正如上述攻击所证明的那样，可以利用记账丢失漏洞攻击正常和安全的容器运行时、Docker和CaaS&#x2F;FaaS平台。攻击者可以利用这些漏洞耗尽所有内存，使容器节点甚至整个集群崩溃。更糟糕的是，攻击只需要普通用户权限，因此很容易启动。虽然内存丢失帐户漏洞可以被利用来攻击容器平台，但目前还没有系统的研究来检测和消除这些漏洞。因此，本文提出了第一个内存记账分析工具MANTA，来系统地检测这些问题。 MISSING-ACCOUNT BUG DETECTION考虑到内存记账丢失错误的严重性，在操作系统内核实际在生产场景中运行之前的早期阶段检测这些问题非常重要。不幸的是，没有一种工具可以同时检测高代码覆盖率和高精度的遗漏帐户错误。因此，我们提出了MANTA(Memory AccouNTing Analyzer的缩写)来自动检测内存记账丢失错误。 Design goals MANTA旨在通过分析记帐接口放置的正确性来自动、系统地检测内存记账丢失错误。具体来说，MANTA需要检测具有高代码覆盖率的内存记账丢失错误。 为了实现这一点，MANTA利用静态分析来遍历Linux内核中的所有内存分配&#x2F;自由路径。此外，MANTA需要高精度地检测漏洞。因此，MANTA使用动态验证来测试检测到的错误的动态触发性。 Challenges 为了实现这两个目标，MANTA需要克服以下挑战。 C1. MANTA需要识别内存记帐接口，这些接口在内核文档中没有描述，以前的工作也没有研究过。现有的用于内存分配的接口识别方法不能应用，因为它们的启发式方法不适用于内存计费接口 C2. MANTA需要决定每个内存分配是否被考虑并且只考虑一次。然而，在Linux内核中，从内存分配站点到内存记帐站点的执行路径往往是深的、嵌套的和交错的。此外，即使存在这样的路径，记帐也可能受到条件标志的影响，因为记帐同时需要记帐接口和记帐标志§2 Analysis techniques and workflow MANTA的体系结构如图所示。以整个内核IR作为输入，MANTA首先生成内核调用图。然后，它使用基于页面计数器的方法来识别所有会计接口以地址C1(§4.1)。基于记帐接口，MANTA建立了内存分配&#x2F;释放和内存记帐之间的映射(§4.2)。 之后，MANTA使用记帐标志分析来进一步分析内核内存记帐(§4.3)。这两种技术处理C2。随着检测到的内存记账错误，MANTA进一步评估每个错误与我们的动态触发性分析基于数千个测试用例从Linux测试项目(§4.4)。MANTA目前是为Linux内存记账实现的。下面，我们将详细介绍每种分析技术。 Counter-based Interface IdentificationMANTA首先需要识别内存记账接口。 这些接口是多种多样的，并且可以自定义。使用自然语言处理(NLP)或包装函数分析的现有技术存在精度问题。我们注意到内存记帐必须维护内存使用计数器(即page_counter)，这些计数器是通过特定的原子函数操作的。使用类型匹配可以很容易地找到内存使用计数器。因此，通过识别用于增加&#x2F;减少这些计数器的基本函数，MANTA可以自动找出对会计计数器执行增加&#x2F;减少操作的所有函数。 具体来说，MANTA遍历每个内核IR指令并检查它是否增加&#x2F;减少page_counter。如果是这样，则MANTA将直接包含该指令的函数标记为基本会计函数。由于在Linux内核中，page_counter仅由memcg使用，因此我们的方法可以达到较高的精度。 然后，MANTA根据基本的记账功能识别会计接口。MANTA使用DFS从基本记账函数向后遍历，并在内核调用图上标记所有访问过的函数。每当它到达memcg子系统之外的函数时，MANTA就会停止遍历，因为它不能是memcg接口。在这些记录内存使用情况的标记函数中，如果一个函数是从memcg子系统外部调用的，即，定义memcg功能的源文件，MANTA将其标记为一个记录接口。这样，MANTA就可以识别所有的计费接口。 让我们使用图中的示例来说明基于计数器的接口标识中的步骤。首先，MANTA遍历所有核函数的所有基本块。在__memcg_kmem_charge中，它标识page_counter函数(第6行)并双重确认第一个参数来自memcg。之后，MANTA进入page_counter_try_charge，发现它增加了page_counter的一个字段。由于__memcg_kmem_charge直接调用page_counter函数并增加page_counter的值，因此MANTA认为__memcg_kmem_charge是一个基本的计费接口。 类似地，对于减少page_counter值的接口，MANTA将其标记为未收费接口。此外，MANTA可以区分不同内存类型的接口，因为memcg对每种内存类型使用不同的page_counters(§2)。在第6行，page_counter_try_charge使用了&amp;memcg-&gt; kmemm，因此MANTA知道__memcg_kmem_charge用于内核内存记帐。 从基本的收费接口开始，MANTA然后沿着调用链逐步识别所有的收费接口包装器。如果一个函数调用基本的计费接口，并且计费量来自于它的参数，MANTA将把它标记为一个计费接口包装器。使用图中的相同示例，__memcg_kmem_charge_page调用基本收费接口__memcg_kmem_charge(第29行)，而收费金额1&lt;&lt;order由__memcg_kmem_charge_page的参数控制。 因此，MANTA认为__memcg_kmem_charge_page是一个收费包装器，因为它只是将收费数量传递给基本收费接口，并且对收费数量没有控制。 MANTA使用相同的方法来检测未充电的包装器。 对于charge&#x2F;uncharge接口，MANTA还需要识别内存分配&#x2F;空闲接口。MANTA采用现有技术来产生初步结果。此外，通过观察内存分配&#x2F;释放接口增加&#x2F;减少struct free_area的nr_free计数器，MANTA使用类似的基于计数器的方法来提高结果的精度。 123456789101112131415161718192021222324252627282930313233343536int __memcg_kmem_charge(struct mem_cgroup *memcg, gfp_t gfp,unsigned int nr_pages)&#123; struct page_counter *counter; ... if(!cgroup_subsys_on_dfl(memory_cgrp_subsys)&amp;&amp;!page_counter_try_charge(&amp;memcg-&gt;kmem,nr_pages,&amp;counter)) &#123;...&#125; ...&#125;bool page_counter_try_charge(struct page_counter *counter,unsigned long nr_pages,struct page_counter **fail)&#123; struct page_counter *c; for(c = counter; c;c = c-&gt;parent)&#123; long new; new = atomic_long_add_return(nr_pages,&amp;c-&gt;usage); ... &#125; ...&#125;int __memcg_kmem_charge_page(struct page *page, gtp_t gtp,int order)&#123; struct mem_cgroup *memcg; int ret = 0; memcg = get_mem_cgroup_from_current(); ... ret = __memcg_kmem_charge(memcg,gfp,1&lt;&lt;order); if(!ret)&#123; page-&gt;mem_cgroup = memcg; ... &#125; ...&#125; Alloc-Charging Mapping Analysis直观地说，每个分配的对象应该只被计算一次。否则，对象可能会被漏记。因此，MANTA 的下一步是建立内存分配&#x2F;释放和计费&#x2F;取消计费之间的关系。基于这种关系，MANTA 可以识别比分配&#x2F;释放的内存少收费或多退费的情况，将其视为漏记错误。简洁起见，我们关注分配和计费。同样的技术可以应用于分析free-uncharging映射。 由于深层次的调用关系和复杂的内存指针传播，从源代码分析分配和计费之间的映射并非易事。为了解决这些问题，我们开发了分配计费(allocation and charging)映射分析。基本思路是首先将函数内的内存分配和计费总结为函数摘要(function summary)，然后基于函数摘要构建内存分配-计费映射，以检测漏记错误。更具体地说，我们使用基于访问路径的分析来生成每个函数的摘要。访问路径的概念首次用于 SATURN 框架，用于表示转义对象的每个函数摘要（即对象指针泄漏到当前函数之外）。 如图左侧算法所示，MANTA 首先为所有函数生成函数摘要（第 2 行）。接下来，对于一个函数𝑓，通过收集其被调用者的函数摘要并分析内存分配位置（IsAlloc），MANTA 可以构建 𝑓 内所有非转义对象的分配-计费映射（第 4-9 行）。具体而言，MANTA 用传递给被调用者的参数替换被调用者摘要中的变量，以计算 𝑓 中分配的页面，这被称为源敏感跟踪。然后，MANTA 通过调用 CheckPage 来分析 𝑓 内的分配-计费映射。在 CheckPage 中，MANTA 能够报告非转义对象的漏记错误（第 19 行）。对于从 𝑓 转义的对象（第 14-18 行），它们最终将在一个函数中（例如 𝑓 的调用者）处理，因为内核中的所有函数都被遍历（第 3-10 行）。此外，IsCharged（第 13 行）和 IsDupCharged 函数（第 21 行）都进行数据流分析，将局部对象连接到被调用函数的返回值或参数。这样，他们可以使用被调用者的函数摘要跟踪内核对象的计费状态。 我们使用图右侧的具体示例来演示算法。MANTA首先为底层内存分配函数__alloc_pages_nodemask生成摘要。 MANTA识别到页面由较低级别的函数get_page_from_freelist返回、充电，并返回。因此，页面既逸出又充电，函数摘要应为（__alloc_pages_nodemask，retval，retval）。当MANTA分析do_anonymous_page时，它会获取alloc_zeroed_user_highpage_movable的函数摘要，该函数是__alloc_pages_nodemask的包装器，具有相同的摘要。根据函数摘要，MANTA确定do_anonymous_page中的页面已经充电。在分析do_anonymous_page内部的分配-计费映射时，MANTA发现内存核算位于第18行可从第14行到达，页面可能在第18行再次被计费。因此，MANTA在这种情况下报告了一个冗余帐户警告。另一方面，如果当前函数中的页面未被计费且不会逸出，MANTA会报告一个未记录错误。 12345678910111213141516171819struct page * __alloc_pages_nodemask(...)&#123; ... page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac); ... if(memcg_kmem_enabled()&amp;&amp;(gtp_mask&amp;__GFP_ACCOUNT)&amp;&amp;page&amp;&amp;unlikely(__memcg_kmem_charge_page(page,gfp_mask,order)!=0)) &#123;...&#125; ... return page;&#125;static vm_fault_t do_anonymous_page(struct vm_fault *vmf)&#123; page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address); if(!page) goto oom; if(mem_cgroup_charge(page, vma-&gt;vm_mm, GFP_KERNEL) ...&#125; Accounting Flag Analysis发现仅依靠分配和记账站点的映射来检测记账丢失错误是不够的，因为内存记账通常是有条件的。特别是在 Linux 内核中，只有当将 __GFP_ACCOUNT标志传递给记账接口时，才会对内核对象内存进行记账。因此，如果没有提供 __GFP_ACCOUNT 标志，记账接口仍然不会对内存进行记账。因此，分析记账标志的值对于检测记账丢失至关重要。因此，MANTA 对记账标志进行分析，以确定是否将记账标志 __GFP_ACCOUNT 传递给记账接口。 Bit-wise and inter-procedural analysis MANTA采用程序间逐位数据流跟踪方法来实现会计标志分析。首先，在计费点，MANTA检查GFP标志本身是否为常数。如果是，MANTA直接检查__GFP_ACCOUNT的位。否则，MANTA将递归地跟踪标志的use-def chain，直到确认其记帐标志位。虽然LLVM提供了一个可以跟踪位值传播的值跟踪分析通道，但该分析仅限于过程内。为了跟踪程序间记帐位，MANTA用两个分析规则扩展了通道。具体来说，当MANTA跟踪函数的参数时，它跟踪所有调用函数以跟踪传递给参数的值;当MANTA跟踪调用站点的返回值时，它也跟踪被调用函数并跟踪所有可能的返回值。如果设置了__GFP_ACCOUNT, MANTA将内核内存标记为在分配点被占用。否则，即使有charging接口，MANTA也会将内存视为not-charged。 对kmem_cache分配的分析略有不同，因为分配也受到kmem_cache的创建标志的影响。 如果kmem_cache是用SLAB_ACCOUNT标志创建的，那么来自kmem_cache的所有分配都会被计算在内。因此，对于与kmem_cache相关的分配，MANTA也会找到kmem_cache的初始化位置，并采用相同的记帐标志分析技术来计算SLAB_ACCOUNT标志。 Dynamic Validation静态分析可能有误报。MANTA检查每个记账丢失分配的系统调用的静态可达性，并过滤掉不可达的。然而，静态可达的bug不一定在运行时触发。因此，MANTA通过动态验证进一步分析静态检测错误的触发性。观察到Linux测试项目(LTP)包含所有300个系统调用的测试用例，我们利用这些测试用例来检查检测到的错误的动态触发性。更具体地说，我们首先检测代码以拦截每个丢失的记账分配，这样我们就可以确认是否确实达到了它。 接下来，我们运行LTP的系统调用和容器测试套件(包含1,469个测试用例)，以检查是否触发了错误。 此外，我们手动运行现有的工具或开发新的测试用例来触发LTP无法触发的错误。其中一些bug与特定的内核特性密切相关，不能被一般的LTP测试用例(例如keexec和selinux)触发。 因此，我们手动运行相关的用户空间工具来触发它们。 其他原因是由于LTP发现的特定系统调用参数，我们手动开发测试用例来传递这些参数。 对于可以动态触发的记账丢失错误，我们进一步开发了内存耗尽概念验证(PoC)来评估它们的安全风险。我们基于触发记账丢失错误的测试用例开发PoCs。特别是，我们反复调用可能触发PoCs中记账丢失错误的系统调用，并记录记账丢失的内存量。此外，一些记账丢失的分配受到某些约束，例如ulimit和sysctl变量。在不损失通用性的情况下，我们对Amazon Fargate等云服务采用了相同的约束设置。这些PoCs的细节将在§5.2中介绍。 Implementation我们用4K行的c++代码将MANTA作为LLVM12的一个通道来实现。所分析的Linux内核是v5.10，具有x86-64的默认配置。MANTA使用wllvm和Clang在默认配置下为整个内核生成IR位码。 vmlinux的位码大小为481MB。MANTA使用PeX方法来解析间接调用并生成调用图。 使用建议的技术，MANTA能够在大约三分钟内完成分析，使其具有足够的可扩展性，可以应用于每个Linux主要版本。 MANTA RESULT在本节中，我们首先给出了MANTA的分析结果。接下来，我们评估了MANTA的查准率和查全率。之后，我们将介绍影响分析以及Linux内核社区报告和修复的错误。最后，我们讨论了MANTA的局限性。 Result OverviewMANTA检测到242个记账丢失的错误，这些错误可以通过60590个不同的路径从273个系统调用中静态地到达。具体来说，用户空间可触发的bug数量为162个，其中LTP触发的bug有134个，现有工具触发的bug有23个，手工开发的测试用例触发的bug有5个。 剩下的80个bug不能被触发，触发失败的原因主要是深度调用路径（80个案例中的72个）。其余的8个分配在内核文档中被明确标记为豁免，或者用于内核内部使用。请注意，这72个没有触发的bug并不都是假阳性，因为我们的测试案例只覆盖了一部分执行路径。保守地说，MANTA的精度大于66.9%（162&#x2F;242）。 我们还通过手动删除会计标志来评估MANTA的召回率。更具体地说，我们首先通过删除kernel&#x2F;子目录下现有的会计标志来生成一个评估集。所有受影响的分配点都被收集在评估集中。特别是，我们删除了11个SLAB_ACCOUNT标志，用GFP_KERNEL替换了5个GFP_KERNEL_ACCOUNT，总共影响了19个内存分配，如表所示。然后我们在修改后的内核代码上运行MANTA，评估结果显示，MANTA可以检测到所有19个缺失的站点。虽然评估的站点有限，但仍表明MANTA有很高的召回率。 此外，MANTA没有发现任何多余的账户漏洞。 Impact Analysis如前所述，为了理解检测到的错误的影响，我们进一步开发基于LTP测试用例的概念验证(PoCs)。更具体地说，我们已经开发了17个PoCs，它们涵盖了47个可以从用户空间重复触发的错误，如表所示。我们在具有16GB RAM的QEMU x86_64机器上开发和测试PoCs。Linux发行版是带有Linux内核v5.10的Debian Buster。所有poc都运行在受memg限制的环境中，并具有Docker运行时应用的默认功能集。 除了PoCs覆盖的bug之外，由于时间和领域知识的限制，我们没有为其他可触发的bug开发PoCs。 然而，这些漏洞也可能被具有相应领域知识的攻击者反复可靠地触发。 Reporting to Linux Community我们已经向Linux内核社区报告了53个bug，包括所有47个可以由17个用户空间poc触发的bug和6个可以由内核操作反复触发的bug。这些bug的完整列表列在附录A的表中。 在所有报告的bug中，有37个已经被内核开发人员确认。所有这37个bug的补丁都提交了，其中18个已经合并，19个待合并。 由于memcg子系统目前没有维护它的git子树，所以修补过程很慢。因此，memcg维护者不跟踪提交的补丁，并期望补丁作者将通过其他子系统维护者向上游推送补丁。这引入了许多额外的讨论和审查，从而显著地减缓了合并过程。 在与内核开发者的交流中，我们发现内核社区对这些bug非常关注。一位内核开发人员强调，memcg“不仅仅是粗略的记账估计”，而且“应该考虑由用户空间触发的未绑定分配”。此外，内核开发人员对MANTA非常感兴趣，并邀请我们使用我们的工具和实验来测试他们的内核。 LimitationsMANTA目前有以下限制。 Static analysis is not sound 由于路径不敏感的函数摘要，MANTA的分析可能会错过记账丢失的错误。当函数在另一条执行路径上对已分配的页进行收费时，它可能不会在其中一条执行路径上对该页收费。在这种情况下，MANTA仍然将功能总结为收费，并在以后的分析中忽略丢失帐户的错误。相反，如果MANTA将功能总结为不收费，则会忽略冗余帐户错误。在未来，我们计划采用像SATURN框架这样的路径敏感摘要来提高稳健性。 Dynamic triggerable test is not complete 目前，MANTA使用LTP测试用例来测试是否可以触发静态检测错误。LTP测试用例是有限的。这些测试用例不可能涵盖内核中所有可能的执行路径。 因此，由于不完整的代码覆盖，MANTA可能会错过一些可触发的错误。因此，我们未来的工作之一是开发更多的测试用例，并采用模糊测试技术来增加代码覆盖率。 RELATED WORKMemory AccountingJRes为JVM实现内存计费接口。内存记帐接口在对象分配期间收取内存使用费用，在垃圾收集期间收取费用。但是，JRes没有为共享对象实现充电机制。 Price等和MzSchem为用户空间运行时环境提出了基于消费者的内存计费方案，以计算子任务的内存使用情况。它们选择向实际用户收取内存使用费用，而不是向内存分配器收取。它们修改运行时垃圾收集器，以便它可以在释放对象之前释放对象，并将其重新充值到保存其引用的实体中。然而，由于在内核中实现足够高效的垃圾收集仍然是一个挑战，因此很难在内核中直接采用它们。基于vm的工作提供了更好的内存隔离，并且可以解决单片内核中的每个进程记帐问题。然而，传统的基于vm的方案过于重量级，并且引入了很高的性能开销。与基于容器的方案相比，基于unikernel的方法实现了更低的启动延迟和更高的吞吐量，但缺乏兼容性。 MANTA的分配-充电映射分析类似于内存泄漏检测中使用的分配-自由映射分析。泄漏检查器使用上下文和路径敏感的分析方法来检测内存泄漏。Saber和FaskCheck使用按需稀疏价值流分析来检测内存泄漏。LeakFix首先尝试定位导致泄漏的空闲内存并修复它。AutoFix通过结合静态分析和运行时检查来检测和修复内存泄漏。PCA使用选择性流敏感算法进一步加快程序间数据流分析的内存泄漏检测。然而，这些工作依赖于手动输入或特定的启发式来决定分配&#x2F;释放接口，这不能应用于识别内存计费接口。 Resource AccountingHoudini的escape利用内核下半部分的工作线程、服务进程和中断来绕过控制组的限制。然而，它没有关注memcg，也没有分析对照组的实施情况。对比胡迪尼的越狱，我们系统地定义了memcg中可能存在的问题，识别并报告了memcg中的53个bug。Yang等提出了抽象资源的概念，并发现在容器内耗尽这些资源会导致对主机的DoS攻击。资源容器提出了一个操作系统级别的抽象来考虑整个系统的资源使用情况。它是描述在每个线程级别计算一般资源的方法的第一本书。与以前的工作相比，资源容器工作在系统内核上，可以解决由用户线程引起的内核资源消耗。Zhang等提出将内核下半进程的cpu时间使用收费给受影响的用户进程，以提高公平性。 Perez等人观察到EVM的气体计量与工作节点上的实际资源消耗，特别是CPU周期不一致。它表明，当页面缓存工作不佳时，实际的不一致性会进一步增加，而支付者则要为相同数量的gas付费。本文还提出了一种能够充分利用不一致性的自动合成有效载荷的方法。Liu发现CPU时间计量在各种真实的云平台上都很脆弱。他们提出了6种可以利用进程启动时或运行时的CPU计量的攻击。 CONCLUSION AND FUTURE WORK本文首次系统地分析和检测了Linux系统中存在的内存记账缺失问题。我们进行了深入的分析，以了解容器平台上内存记账丢失错误的可利用性和安全影响。 我们的分析表明，所有容器运行时(包括正常运行时和安全运行时)都容易受到由记账丢失错误导致的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致节点甚至整个集群崩溃。 然后，我们提出了MANTA，它结合了静态和动态分析技术，以高代码覆盖率和精度自动检测内存记账丢失错误。我们的检测工具报告了53个可利用的内存丢失帐户错误，其中37个已被内核开发人员确认，分配了两个新的cve。结果表明，MANTA可以有效地缓解内存记帐系统中的记账丢失问题。 我们未来的工作是研究如何在不调解所有内存分配&#x2F;自由路径的情况下准确地计算内存使用情况。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"C++ 学习 Linux系统编程 库","slug":"C++-学习-Linux系统编程-库","date":"2023-04-22T02:39:33.000Z","updated":"2023-05-14T07:19:46.476Z","comments":true,"path":"2023/04/22/C++-学习-Linux系统编程-库/","link":"","permalink":"http://example.com/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/","excerpt":"什么是库 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量。 库是一种特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种：静态库和动态库（共享库），区别是：静态库在程序的连接阶段被复制到了程序中；动态库在连接阶段没有被复制到程序，而是程序在运行时由系统动态加载到内存中供程序调用 库的好处：1、代码保密 2、方便部署和分发 命名规则 Linux:libXXX.a lib:前缀（固定） XXX：库的名字，自己起 .a：后缀（固定） Windows：libXXX.lib 静态库的制作 gcc获得.o文件 将.o文件打包，使用ar工具（archive） 1ar rcs libxxx.a xxx.o xxx.o","text":"什么是库 库文件是计算机上的一类文件，可以简单的把库文件看成一种代码仓库，它提供给使用者一些可以直接拿来用的变量。 库是一种特殊的程序，编写库的程序和编写一般的程序区别不大，只是库不能单独运行。 库文件有两种：静态库和动态库（共享库），区别是：静态库在程序的连接阶段被复制到了程序中；动态库在连接阶段没有被复制到程序，而是程序在运行时由系统动态加载到内存中供程序调用 库的好处：1、代码保密 2、方便部署和分发 命名规则 Linux:libXXX.a lib:前缀（固定） XXX：库的名字，自己起 .a：后缀（固定） Windows：libXXX.lib 静态库的制作 gcc获得.o文件 将.o文件打包，使用ar工具（archive） 1ar rcs libxxx.a xxx.o xxx.o r 将文件插入备存文件中 c 建立备存文件 s 索引 静态库的制作我们现在有如下文件： 首先我们将其编译为.o文件，运行如下命令： 1gcc -c add.c div.c mult.c sub.c 结果如下： 输入命令制作静态库： 1ar rcs libcalc.a add.o sub.o mult.o div.o 我们生成静态库文件如下： 静态库的使用如图所示，在文件夹里我们有如下文件： 我们从头编译静态库文件 我们在.&#x2F;library文件夹下依次运行如下命令 1cd src 1gcc -c add.c div.c mult.c sub.c -I ../include/ 1ar rcs libcalc.a add.o div.o mult.o sub.o 1mv libcalc.a ../lib/ 1cd .. 1gcc main,c -o app -I ./include/ -L ./lib/ -l calc 执行完上述所有指令后我们运行： 1tree 如图所示： 我们运行下列命令，运行app文件： 1./app 动态库的制作与使用命名规则： Linux：libxxx.so lib: 前缀（固定） xxx：库的名字，自己起 .so：后缀（固定） 在Linux下是一个可执行文件 Windows：libxxx.dll 动态库的制作： gcc得到.o文件，得到和位置无关的代码 1gcc -c -fpic/-fPIC a.c b.c gcc得到动态库 1gcc -shared a.o b.o -o libcalc.so 制作如图所示我们有如下文件，我们按如下命令依次编译，并生成动态库文件，将库文件复制到lib文件夹内。 1gcc -c -fpic add.c div.c mult.c sub.c 1gcc -shared *.o -o libcalc.so 将libcalc.so文件复制到lib文件夹中，我们有如下文件： 动态库的使用我们编译main.c文件 1gcc main.c -o main -I include/ -L lib/ -l calc 运行main文件 1./main 报错，报错信息如下： 库工作原理静态库：GCC进行连接时，会把静态库中代码打包到可执行程序中 动态库：GCC进行连接时，动态库的代码不会被打包到可执行程序中 程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系 当系统加载可执行代码时，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。对于elf格式的可执行程序，是由ld-linux.so来完成的，它先后搜索elf文件的DT_RPATH段-&gt;环境变量LD _LIBARAY_PATH-&gt;&#x2F;etc&#x2F;ld.so.cache文件列表-&gt;&#x2F;lib&#x2F;,&#x2F;usr&#x2F;lib目录找到库文件后将其载入内存。 动态库加载失败的原因和解决方法我们运行命令 1ldd main 发现我们自己写的libcalc.so动态库找不到 添加环境变量，输入命令： 1export LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib 我们再运行命令： 1ldd main 我们手动设置了动态库的路径，但是这只是临时的，关闭之后再次打开就会失效 我们进入到&#x2F;home目录下运行命令 1vim .bashrc 修改.bashrc文件，在最后一行插入 1LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/home/plucky/Linux/lecture05/library/lib 保存之后退出，运行 1source .bashrc 只要手动设置了动态库的路径，就可以运行.&#x2F;main 还可以通过修改&#x2F;etc&#x2F;ld.so.cache文件，将动态库文件放入&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib&#x2F; 静态库和动态库的对比静态库的优缺点优点 静态库被打包到应用程序中，加载速度快 发布程序无须提供静态库，移植方便 缺点 浪费系统资源，浪费内存 更新、部署、发布麻烦 动态库的优缺点优点 可以实现进程间资源共享（共享库） 更新、部署、发布简单 可以控制何时加载动态库 缺点 加载速度比静态库慢 发布程序时需要依赖的动态库","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"C++ 学习 Linux系统编程 开发环境搭建","slug":"C++-学习-Linux系统编程-开发环境搭建","date":"2023-04-20T08:02:55.000Z","updated":"2023-05-14T07:16:41.987Z","comments":true,"path":"2023/04/20/C++-学习-Linux系统编程-开发环境搭建/","link":"","permalink":"http://example.com/2023/04/20/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"安装相关工具 Windows 虚拟机 | Workstation Pro | VMware | CN Visual Studio Code Xshell和Xftp 清华大学Ubuntu镜像 配置过程","text":"安装相关工具 Windows 虚拟机 | Workstation Pro | VMware | CN Visual Studio Code Xshell和Xftp 清华大学Ubuntu镜像 配置过程首先打开ubuntu，安装ssh服务端，输入指令 1sudo apt install openssh-server 之后打开Xshell 点击新建，如下图: 在名称处填写连接的名称，在主机处填写Ubuntu的ip地址打开Ubuntu，输入命令 1ifconfig 得到ip地址为192.168.194.129 之后我们使用Xshell连接，此时会让我们填写用户名和密码，我们填写Ubuntu的用户名和它的密码即可 然后我们打开VScode，安装拓展 之后会发现vscode多出一个远程资源管理器，我们点击远程资源管理器，然后打开SSH，配置文件，C:\\Users\\zc\\ssh\\config 1234# Read more about SSH config files: https://linux.die.net/man/5/ssh_configHost Ubuntu-plucky 填写主机名，随便起 HostName 192.168.194.129 Ubuntu的IP地址 User plucky Ubuntu的用户名 之后就可以连接主机和打开文件夹 配置SSH公私钥免密登录首先在windows主机输入命令 1ssh-keygen -t rsa 随后所有设置都按回车 我们可以看到用户目录下 id_rsa为私钥，id_rsa.pub为公钥 之后我们打开Ubuntu，输入命令 1ssh-keygen -t rsa 随后所有设置都按回车 之后 1cd ./ssh 1vim authorized_keys 将windows中的id_rsa.pub复制进authorized_keys中。 之后就可以实现无密登录了","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture06 Isolation and system call entry/exit","slug":"MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit","date":"2023-04-20T06:13:04.000Z","updated":"2023-04-20T06:47:00.073Z","comments":true,"path":"2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/","link":"","permalink":"http://example.com/2023/04/20/MIT6-S081-Operating-System-Engineering-Lecture06-Isolation-and-system-call-entry-exit/","excerpt":"Trap机制程序完成用户空间和内核空间切换的时机 程序执行系统调用 程序出现了类似page fault，运算时除以0的错误 一个设备触发了中断使得当前程序运行需要相应内核设备驱动","text":"Trap机制程序完成用户空间和内核空间切换的时机 程序执行系统调用 程序出现了类似page fault，运算时除以0的错误 一个设备触发了中断使得当前程序运行需要相应内核设备驱动 Trap用户空间和内核空间的切换通常被称为trap trap涉及了许多小心的设计和重要的细节，这些细节对于实现安全隔离和性能来说非常重要。因为很多应用程序，要么因为系统调用，要么因为page fault，都会频繁的切换到内核中。所以，trap机制要尽可能的简单，这一点非常重要。 我们有一些用户应用程序，例如Shell，它运行在用户空间，同时我们还有内核空间。Shell可能会执行系统调用，将程序运行切换到内核。比如XV6启动之后Shell输出的一些提示信息，就是通过执行write系统调用来输出的。 寄存器我们需要清楚如何让程序的运行，从只拥有user权限并且位于用户空间的Shell，切换到拥有supervisor权限的内核。在这个过程中，硬件的状态将会非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。 每个 RISC-V CPU都有一组控制寄存器，内核会写入这些寄存器以告诉 CPU 如何处理trap，并且内核可以读取这些寄存器以了解发生的陷阱。RISC-V 文档包含完整的信息。riscv.h（kernel&#x2F;riscv.h:1）包含 xv6 使用的定义。以下是最重要的几个寄存器概述： Program Counter Register:程序计数器 表明当前mode的标志位：这个标志位表明了当前是supervisor mode还是user mode。当我们在运行shell的时候，自然是在user mode。 SATP（Supervisor Address Translation and Protection）：包含了指向page table的物理地址 STVEC（Supervisor Trap Vector Base Address Register）：指向内核中处理trap指令的起始地址 SEPC（Supervisor Exception Program Counter），在trap的过程中保存程序计数器的值 SSRATCH（Supervisor Scratch Register）内核在此处放置一个值，在处理程序开始时非常方便 trap处理过程中的一些操作在trap的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。在trap处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中普通的C程序。接下来我们先来预览一下需要做的操作： 首先，我们需要保存32个用户寄存器。因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。 PC(程序计数器)也需要在某个地方保存，我们需要能够在用户程序运行中断的位置继续执行用户程序 我们需要将mode改为supervisor mode，因为我们想要使用内核中各种各样的指令 SATP寄存器现在正指向user page table，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射，所以在运行内核代码之前，我们需要将SATP指向kernel page table。 我们需要将堆栈寄存器指向位于内核的一个地址，因此我们需要一个堆栈来调用内核的C函数 一旦我们都设置好了，并且所有的硬件状态都适合在内核中使用，我们需要跳入内核的C代码","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++学习 类与对象","slug":"C++-学习-类与对象","date":"2023-04-16T12:31:16.000Z","updated":"2023-05-09T08:11:27.363Z","comments":true,"path":"2023/04/16/C++-学习-类与对象/","link":"","permalink":"http://example.com/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"C++面向对象三大特性：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如：","text":"C++面向对象三大特性：封装、继承、多态 C++认为万事万物都皆为对象，对象上有其属性和行为 例如： 人可以作为对象，属性有姓名、年龄、身高、体重…..，行为有走、跑、跳…… 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类 封装封装的意义封装是C++面向对象三大特性之一 封装的意义： 将属性和行为作为一个整体，表现生活中的事物 将属性和行为加以权限控制 封装的意义一在设计类的时候，属性和行为写在一起，表现事物 语法：class 类名 &#123; 访问权限 : 属性 / 行为 &#125;; 示例一： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const double PI = 3.14;//设计一个圆类，求圆的周长//圆求周长的公式：2*PI*半径//class代表设计一个类，类后面紧跟着的就是类名称class Circle&#123; //访问权限 //公共权限public: //属性 //半径 int m_r; //行为 //获取圆的周长 double calculateZC() &#123; return 2 * PI * m_r; &#125;&#125;;int main()&#123; //通过圆类 创建具体的圆 （对象） Circle c1; //给圆对象的属性进行赋值 c1.m_r = 10; cout &lt;&lt; &quot;圆的周长为：&quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;&#125; 运行结果为： 圆的周长为：62.8 示例二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const double PI = 3.14;//设计一个学生类，属性具有姓名和学号//可以给姓名和学号赋值，可以显示学生的姓名和学号//设计学生类class Student&#123; //访问权限 //公共权限public: //属性 //姓名和学号 string m_Name;//姓名 int m_id;//学号 //行为 //显示姓名和学号 void showStudent() &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; m_Name &lt;&lt; &quot; 学号：&quot; &lt;&lt; m_id &lt;&lt; endl; &#125; //给姓名赋值 void setName(string name) &#123; m_Name = name; &#125; void setId(int id) &#123; m_id = id; &#125;&#125;;int main()&#123; //创建一个具体学生 实例化对象 Student s1; Student s2; //给S1对象 进行属性复制操作 s1.setName(&quot;张三&quot;); s1.setId(1); s2.m_Name = &quot;李四&quot;; s2.m_id = 2; s1.showStudent(); s2.showStudent();&#125; 运行结果为： 姓名： 张三 学号：1姓名： 李四 学号：2 封装的意义二类在设计时，可以把属性和行为放在不同的权限下，加以控制 访问权限有三种： public 公共权限 protected 保护权限 private 私有权限 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//访问权限//三种//公共权限 public 成员 类内可以访问 类外可以访问 //保护权限 protected 成员 类内可以访问 类外不可以访问 儿子也可以访问父亲中的保护内容//私有权限 private 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲中的私有内容class Person&#123; //公共权限public: string m_Name;//姓名protected: //保护权限 string m_Car;//汽车private: //私有权限 int m_Password;//银行卡密码public: void func() &#123; m_Name = &quot;张三&quot;; m_Car = &quot;拖拉机&quot;; m_Password = 123456; &#125;&#125;;int main()&#123; //实例化具体对象 Person p1; p1.m_Name = &quot;李四&quot;; p1.m_Car = &quot;奔驰&quot;; p1.m_Password = 654321;&#125; struct和class的区别在C++中struct和class唯一的区别就在于默认的访问权限不同 区别： struct权限默认为公共 class权限默认为私有 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class C1&#123; int m_A;&#125;;struct C2&#123; int m_A;&#125;;int main()&#123; C1 c1; c1.m_A = 100; C2 c2; c2.m_A = 100;&#125; 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员属性设置为私有//1、可以自己控制读写权限//2、对于写可以检测数据的有效性//设计人类class Person&#123;public: //设置姓名 void setName(string name) &#123; m_Name = name; &#125; //获取姓名 string getName() &#123; return m_Name; &#125; //获取年龄 只读 int getAge() &#123; m_Age = 0; return m_Age; &#125; //设置情人 只写 void setLover(string lover) &#123; m_Lover = lover; &#125;private: //姓名 可读可写 string m_Name; //年龄 只读 int m_Age; //情人 只写 string m_Lover;&#125;;int main() &#123; Person p; p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名为： &quot; &lt;&lt; p.getName() &lt;&lt; endl; cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p.getAge() &lt;&lt; endl; p.setLover(&quot;李四&quot;); //无法访问&#125; 运行结果为： 姓名为： 张三年龄为：0 优点2：对于写权限，我们可以检测数据的有效性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员属性设置为私有//1、可以自己控制读写权限//2、对于写可以检测数据的有效性//设计人类class Person&#123;public: //设置姓名 void setName(string name) &#123; m_Name = name; &#125; //获取姓名 string getName() &#123; return m_Name; &#125; //获取年龄 可读可写 如果想修改（年龄的范围必须是0~150之间） int getAge() &#123; return m_Age; &#125; //设置名字 void setAge(int age) &#123; if (age &lt; 0 || age &gt;150) &#123; cout &lt;&lt; &quot;年龄错误&quot; &lt;&lt; endl; return; &#125; m_Age = age; &#125; //设置情人 只写 void setLover(string lover) &#123; m_Lover = lover; &#125;private: //姓名 可读可写 string m_Name; //年龄 只读 int m_Age; //情人 只写 string m_Lover;&#125;;int main() &#123; Person p; p.setName(&quot;张三&quot;); cout &lt;&lt; &quot;姓名为： &quot; &lt;&lt; p.getName() &lt;&lt; endl; p.setAge(1000); cout &lt;&lt; &quot;年龄为：&quot; &lt;&lt; p.getAge() &lt;&lt; endl; p.setLover(&quot;李四&quot;); //无法访问&#125; 运行结果为： 姓名为： 张三年龄错误年龄为：-858993460 练习案例一设计立方体类（Cube） 求出立方体的面积和体积 分别用全局函数和成员函数判断两个立方体是否相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//立方体类设计//1、创建立方体类//2、创建属性//3、设计行为 获取立方体面积和体积//4、分别利用全局函数和成员函数 判断两个立方体是否相等class Cube&#123;public: //行为 //设置获取长宽高 // 设置长 void setL(int l) &#123; m_L = l; &#125; // 获取长 int getL() &#123; return m_L; &#125; // 设置宽 void setW(int w) &#123; m_W = w; &#125; // 获取宽 int getW() &#123; return m_W; &#125; // 设置高 void setH(int H) &#123; m_H = H; &#125; // 获取高 int getH() &#123; return m_H; &#125; // 获取立方体面积 int calculateS() &#123; return 2 * m_L * m_W + 2 * m_L * m_H + 2 * m_W * m_H; &#125; // 获取立方体体积 int calculateV() &#123; return m_L * m_H * m_W; &#125; //利用成员函数判断两个立方体是否相等 bool isSameByClass(Cube&amp; c) &#123; if (getL() == c.getL() &amp;&amp; getW() == c.getW() &amp;&amp; getH() == c.getH()) &#123; return true; &#125; else &#123; return false; &#125; &#125; //属性private: int m_L;//长 int m_W;//宽 int m_H;//高&#125;;//利用全局函数判断 两个立方体是否相等bool isSame(Cube&amp; c1, Cube&amp; c2)&#123; if (c1.getL() == c2.getL() &amp;&amp; c1.getW() == c2.getW() &amp;&amp; c1.getH() == c2.getH()) return true; return false;&#125;int main()&#123; //创建立方体对象 Cube c1; c1.setL(10); c1.setW(10); c1.setH(10); cout &lt;&lt; &quot;c1的面积为：&quot; &lt;&lt; c1.calculateS() &lt;&lt; endl; cout &lt;&lt; &quot;c1的体积为：&quot; &lt;&lt; c1.calculateV() &lt;&lt; endl; //创建第二个立方体对象 Cube c2; c2.setL(10); c2.setW(10); c2.setH(10); cout &lt;&lt; &quot;c2的面积为：&quot; &lt;&lt; c2.calculateS() &lt;&lt; endl; cout &lt;&lt; &quot;c2的体积为：&quot; &lt;&lt; c2.calculateV() &lt;&lt; endl; //利用全局函数判断 bool ret = isSame(c1, c2); if (ret) &#123; cout &lt;&lt; &quot;c1和c2是相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;c1和c2是不相等的&quot; &lt;&lt; endl; &#125; //利用成原函数判断 ret = c1.isSameByClass(c2); if (ret) &#123; cout &lt;&lt; &quot;c1和c2是相等的&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;c1和c2是不相等的&quot; &lt;&lt; endl; &#125;&#125; 运行结果为： c1的面积为：600c1的体积为：1000c2的面积为：600c2的体积为：1000c1和c2是相等的c1和c2是相等的 练习案例二设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//点与圆的关系案例// 点类class Point &#123;public: //设置x void setX(int x) &#123; m_X = x; &#125; //获取x int getX() &#123; return m_X; &#125; //设置y void setY(int y) &#123; m_Y = y; &#125; //获取y int getY() &#123; return m_Y; &#125;private: int m_X; int m_Y;&#125;;//圆类class Circle&#123;public: //设置半径 void setR(int r) &#123; m_R = r; &#125; //获取半径 int getR() &#123; return m_R; &#125; //设置圆心 void setCenter(Point center) &#123; m_Center = center; &#125; Point getCenter() &#123; return m_Center; &#125;private: int m_R;//半径 Point m_Center;//圆心&#125;;//判断点和圆的关系void isInCircle(Circle&amp; c, Point&amp; p) &#123; //计算两点之间距离的平方 int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) + (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY()); //计算半径的平方 int rDistance = c.getR() * c.getR(); //判断关系 if (distance == rDistance) &#123; cout &lt;&lt; &quot;点在圆上&quot; &lt;&lt; endl; &#125; else if (distance &gt; rDistance) &#123; cout &lt;&lt; &quot;点在圆外&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;点在圆内&quot; &lt;&lt; endl; &#125;&#125;int main()&#123; //创建圆 Circle c; c.setR(10); Point center; center.setX(10); center.setY(0); c.setCenter(center); //创建点 Point p; p.setX(10); p.setY(10); //判断关系 isInCircle(c, p);&#125; 运行结果为： 点在圆上 对象的初始化和清理 生活中我们买的电子产品基本都会有出厂设置，在某一天我们不用的时候也会删除一些自己的信息数据保证安全 C++中的面向对象来自于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题 一个对象或者变量没有初始状态，对其使用后果是未知 同样的使用完一个对象或变量，没有及时清理，也会造成一定的问题 C++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。 对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。 析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作 构造函数语法：类名（）&#123;&#125; 1、构造函数：没有返回值也不写void 2、函数名称与类名相同 3、构造函数可以有参数，因此可以发生重载 4、程序在调用对象时会自动调用构造，无须手动调用，而且只会调用一次 析构函数语法：~类名（）&#123;&#125; 1、析构函数：没有返回值也不写void 2、函数名称与类名相同，在名称前加上符号~ 3、析构函数不可以有参数，因此不可以发生重载 4、程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//对象的初始化和清理class Person&#123; //1 构造函数 //没有返回值 不用写void //函数名与类名相同 //构造函数可以有参数可以发生重载 //创建对象的时候，构造函数会自动调用，而且只调用一次public: Person() &#123; cout &lt;&lt; &quot;Person构造函数的调用&quot; &lt;&lt; endl; &#125; //2 析构函数 //没有返回值 不写void //函数名和类名相同 在名称前加~ //析构函数不可以有参数，不可以发生重载 //对象在销毁前，会自动调用析构函数 ~Person() &#123; cout &lt;&lt; &quot;Person析构函数的调用&quot; &lt;&lt; endl; &#125;&#125;;//构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现的构造和析构void test01()&#123; Person p;//在栈上的数据，test01执行完毕之后，释放这个对象&#125;int main()&#123; test01();&#125; 运行结果为： Person构造函数的调用Person析构函数的调用 构造函数的分类及调用两种分类方式： 按参数分为：有参数构造和无参数构造 按类型分为：普通构造和拷贝构造 三种调用方式： 括号法 显式法 隐式转换法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分类class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的无参构造函数调用&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; //将传入的人的身上的所有属性，拷贝到我身上 age = p.age; cout &lt;&lt; &quot;Person的拷贝函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int age;&#125;;//调用void test01()&#123; //1、括号法 Person p1 ;//默认构造函数的调用 Person p2(10);//有参构造函数 //拷贝构造函数调用 Person p3(p2); //注意事项 //调用默认构造函数的时候，不要加（） cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.age &lt;&lt; endl; cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; p3.age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： Person的无参构造函数调用Person的有参构造函数调用Person的拷贝函数调用p2的年龄为：10p3的年龄为：10Person的析构函数调用Person的析构函数调用Person的析构函数调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分类class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的无参构造函数调用&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; //将传入的人的身上的所有属性，拷贝到我身上 age = p.age; cout &lt;&lt; &quot;Person的拷贝函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int age;&#125;;//调用void test01()&#123; //2、显示法 Person p1; Person p2 = Person(10);//有参构造 Person p3 = Person(p2);//拷贝构造 Person(10);//匿名对象 特点：当前行执行结束后，系统会立即回收掉匿名对象//注意事项：不要利用拷贝构造函数 初始化匿名对象 编译器会认为是对象声明&#125;int main()&#123; test01();&#125; 运行结果为： Person的无参构造函数调用Person的有参构造函数调用Person的拷贝函数调用Person的有参构造函数调用Person的析构函数调用Person的析构函数调用Person的析构函数调用Person的析构函数调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//分类class Person&#123;public: //构造函数 Person() &#123; cout &lt;&lt; &quot;Person的无参构造函数调用&quot; &lt;&lt; endl; &#125; Person(int a) &#123; age = a; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; //拷贝构造函数 Person(const Person&amp; p) &#123; //将传入的人的身上的所有属性，拷贝到我身上 age = p.age; cout &lt;&lt; &quot;Person的拷贝函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int age;&#125;;//调用void test01()&#123; //3、隐式转换法 Person p4 = 10; Person p5 = p4;&#125;int main()&#123; test01();&#125; 运行结果为： Person的有参构造函数调用Person的拷贝函数调用Person的析构函数调用Person的析构函数调用 拷贝构造函数的调用时机C++中拷贝构造函数调用时机通常有三种情况 使用一个以及创建完毕的对象来初始化一个新对象 值传递的方式给函数参数传值 以值方式返回局部对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//拷贝构造函数调用时机//1、使用一个已经创建完毕的对象来初始化一个对象//2、值传递的方式给函数参数传值//3、值方式返回局部对象class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age) &#123; cout &lt;&lt; &quot;Person有参构造函数调用&quot; &lt;&lt; endl; m_Age = age; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Person拷贝构造函数调用&quot; &lt;&lt; endl; m_Age = p.m_Age; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age;&#125;;//1、使用一个已经创建完毕的对象来初始化一个对象void test01()&#123; Person p1(20); Person p2(p1); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; endl;&#125;//2、值传递的方式给函数参数传值void doWork1(Person p)&#123;&#125;void test02()&#123; Person p; doWork1(p);&#125;//3、值方式返回局部对象Person doWork2()&#123; Person p1; return p1;&#125;void test03()&#123; Person p = doWork2();&#125;int main()&#123; cout &lt;&lt; &quot;test01()&quot; &lt;&lt; endl; test01(); cout &lt;&lt; &quot;test02()&quot; &lt;&lt; endl; test02(); cout &lt;&lt; &quot;test03()&quot; &lt;&lt; endl; test03();&#125; 运行结果如下： test01()Person有参构造函数调用Person拷贝构造函数调用p2的年龄为：20Person析构函数调用Person析构函数调用test02()Person默认构造函数调用Person拷贝构造函数调用Person析构函数调用Person析构函数调用test03()Person默认构造函数调用Person拷贝构造函数调用Person析构函数调用Person析构函数调用 构造函数的调用规则 默认情况下，C++编译器至少给一个类添加3个函数 1、默认构造函数（无参，函数体为空） 2、默认析构函数（无参，函数体为空） 3、默认拷贝函数，对属性进行值拷贝 构造函数调用规则如下： 如果用户定义有参构造函数，C++不在提供默认无参构造，但会提供默认拷贝构造 如果用户定义拷贝构造函数，C++不会在提供其他构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//构造函数调用规则//1、创建一个类，C++编译器会给每个类都添加至少3个函数//默认构造（空实现）//析构函数（空实现）//拷贝构造（值拷贝）class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age) &#123; cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; /*Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; m_Age = p.m_Age; &#125;*/ ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person p; p.m_Age = 18; Person p2(p); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果如下： Person的默认构造函数调用p2的年龄为：18Person的析构函数调用Person的析构函数调用 深拷贝与浅拷贝浅拷贝：简单的赋值拷贝操作 深拷贝：在堆区重新申请空间，进行拷贝操作 如果利用编译器提供的拷贝构造函数，会做浅拷贝操作 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//深拷贝与浅拷贝class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age, int height) &#123; m_Age = age; m_Height = new int(height); cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; //析构代码，将堆区开辟的数据做释放操作 if (m_Height != NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age; int* m_Height;&#125;;void test01()&#123; Person p1(18 , 160); cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; p1.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p1.m_Height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行发生错误 浅拷贝会带来堆区的内存重复释放 要自己实现拷贝构造函数，解决浅拷贝带来的问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//深拷贝与浅拷贝class Person&#123;public: Person() &#123; cout &lt;&lt; &quot;Person的默认构造函数调用&quot; &lt;&lt; endl; &#125; Person(int age, int height) &#123; m_Age = age; m_Height = new int(height); cout &lt;&lt; &quot;Person的有参构造函数调用&quot; &lt;&lt; endl; &#125; Person(const Person&amp; p) &#123; cout &lt;&lt; &quot;Person的拷贝构造函数调用&quot; &lt;&lt; endl; m_Age = p.m_Age; //编译器默认实现m_Height = p.m_Height; //深拷贝操作 m_Height = new int(*p.m_Height); &#125; ~Person() &#123; //析构代码，将堆区开辟的数据做释放操作 if (m_Height != NULL) &#123; delete m_Height; m_Height = NULL; &#125; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; int m_Age; int* m_Height;&#125;;void test01()&#123; Person p1(18 , 160); cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; p1.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p1.m_Height &lt;&lt; endl; Person p2(p1); cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; p2.m_Age &lt;&lt; &quot; 身高为：&quot; &lt;&lt; *p2.m_Height &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果如下： Person的有参构造函数调用p1的年龄为：18 身高为：160Person的拷贝构造函数调用p2的年龄为：18 身高为：160Person的析构函数调用Person的析构函数调用 初始化列表作用：C++提供了初始化列表语法，用来初始化属性 语法：构造函数（）：属性1（值1），属性2（值2）…{} 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//初始化列表class Person&#123;public: ////传统初始化操作 //Person(int a, int b, int c) //&#123; // m_A = a; // m_B = b; // m_C = c; //&#125; //初始化列表初始化属性 Person(int a, int b, int c) :m_A(a), m_B(a), m_C(c) &#123; &#125; int m_A; int m_B; int m_C;&#125;;void test01()&#123; Person p(10, 20, 30); cout &lt;&lt; &quot;m_A = &quot; &lt;&lt; p.m_A &lt;&lt; endl; cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; p.m_B &lt;&lt; endl; cout &lt;&lt; &quot;m_C = &quot; &lt;&lt; p.m_C &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： m_A &#x3D; 10m_B &#x3D; 10m_C &#x3D; 30 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为对象成员 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//类对象作为类成员//手机类class Phone&#123;public: Phone(string pName) &#123; m_PName = pName; cout &lt;&lt; &quot;Phone的构造函数调用&quot; &lt;&lt; endl; &#125; ~Phone() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; string m_PName;&#125;;//人类class Person&#123;public: Person(string name, string pName) :m_Name(name), m_Phone(pName) &#123; cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl; &#125; ~Person() &#123; cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl; &#125; //姓名 string m_Name; //手机 Phone m_Phone;&#125;;//当其他类对象作为本类成员，构造事先构造类对象，再构造自身,析构顺序与构造相反void test01()&#123; Person p(&quot;张三&quot;, &quot;iphone&quot;); cout &lt;&lt; p.m_Name &lt;&lt; &quot;的手机是&quot; &lt;&lt; p.m_Phone.m_PName &lt;&lt; endl;&#125;int main()&#123; test01();&#125;endl;&#125;int main()&#123; test01();&#125; 运行结果为： Phone的构造函数调用Person的构造函数调用张三的手机是iphonePerson的析构函数调用Person的析构函数调用 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员 静态成员分为： 静态成员变量 所有对象共享同一份数据 在编译阶段分配内存 类内声明，类外初始化 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person&#123;public: //1、所有对象都共享同一份数据 //2、编译阶段就分配内存 //3、类内声明，类外初始化操作 //4、私有静态成员变量在类外访问不了 static int m_A;private: static int m_B;&#125;;int Person::m_A = 100;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; Person p1; p1.m_A = 200; cout &lt;&lt; p1.m_A &lt;&lt; endl;&#125;void test02()&#123; //静态成员变量 不属于某个对象上，所有对象都共享同一份数据 //因此静态成员变量有两种访问方式 //1、通过对象进行访问 Person p; cout &lt;&lt; p.m_A &lt;&lt; endl; //2、通过类名进行访问 cout &lt;&lt; Person::m_A &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果如下 100200200200 静态成员函数 所有对象共享同一个函数 静态成员函数只能访问静态成员变量 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//静态成员函数//所有对象共享同一个函数//静态成员函数只能访问静态成员变量class Person&#123;public: //静态成员函数 static void func() &#123; m_A = 100; cout &lt;&lt; &quot;static void func调用&quot; &lt;&lt; endl; &#125; static int m_A;//静态成员变量 int m_B;//非静态成员变量private: static void func2()//类外访问不到私有静态成员函数 &#123; &#125;&#125;;int Person::m_A = 100;//有两种访问方式void test01()&#123; //1、通过对象访问 Person p; p.func(); //2、通过类名访问 Person::func();&#125;int main()&#123; test01();&#125; 运行结果为： static void func调用static void func调用 C++对象模型和this指针成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储 只有非静态成员变量才属于类的对象上 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123;&#125;;void test01()&#123; Person p; //空对象占用内存空间为： 1 //C++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置 //每个空对象也应该有一个独一无二的内存地址 cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 1 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123; int m_A;//非静态成员变量&#125;;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 4 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123; int m_A;//非静态成员变量 属于类的对象上 static int m_B;//静态成员变量&#125;;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 4 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//成员变量 和 成员函数 分开存储的class Person&#123; int m_A;//非静态成员变量 属于类的对象上 static int m_B;//静态成员变量 不属于类的对象上 void func()&#123;&#125;//非静态成员函数 不属于类的对象上&#125;;int Person::m_B = 100;void test01()&#123; Person p; cout &lt;&lt; &quot;size of p = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： size of p &#x3D; 4 this指针概念通过上述代码我们知道在C++中成员变量喝成员函数是分开存储的 每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码 那么问题是：这一块代码是如何区分那个对象调用自己的呢? C++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象 this指针是隐含每一个非静态成员函数内的一种指针 this指针不需要定义，直接使用即可 this指针的用途： 当形参和成员变量同名时，可用this指针来区分 在类的非静态成员函数中返回对象本身，可使用return *this 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; age = age; &#125; int age;&#125;;//1 解决名称冲突void test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125;//2 返回对象本身用*thisint main()&#123; test01();&#125; 运行结果为： p1的年龄为-858993460 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; this-&gt;age = age; &#125; int age;&#125;;//1 解决名称冲突void test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125; //2 返回对象本身用*thisint main()&#123; test01();&#125; 运行结果为： p1的年龄为18 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Person &#123;public: Person(int age) &#123; this-&gt;age = age; &#125; Person&amp; PersonAddAge(Person&amp; p) &#123; this-&gt;age += p.age; return *this; &#125; int age;&#125;;//1 解决名称冲突void test01()&#123; Person p1(18); cout &lt;&lt; &quot;p1的年龄为&quot; &lt;&lt; p1.age &lt;&lt; endl;&#125; //2 返回对象本身用*thisvoid test02()&#123; Person p1(10); Person p2(20); //链式编程 p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1); cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;&#125;int main()&#123; test01(); test02();&#125; 运行结果为： p1的年龄为18p2的年龄为： 50 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针 如果用到this指针，需要加以判断保证代码的健壮性 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//空指针调用成员函数class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; //p-&gt;showClassName(); p-&gt;showPersonAge();&#125; 这段代码会运行错误，报错原因是因为传入的指针是NULL 而下述代码不会报错 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//空指针调用成员函数class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; p-&gt;showClassName(); //p-&gt;showPersonAge();&#125;int main()&#123; test01();&#125; 我们将代码修改为： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//空指针调用成员函数class Person&#123;public: void showClassName() &#123; cout &lt;&lt; &quot;this is Person class&quot; &lt;&lt; endl; &#125; void showPersonAge() &#123; if (this == NULL) return; cout &lt;&lt; &quot;age = &quot; &lt;&lt; m_Age &lt;&lt; endl; &#125; int m_Age;&#125;;void test01()&#123; Person* p = NULL; p-&gt;showClassName(); p-&gt;showPersonAge();&#125;int main()&#123; test01();&#125; 代码也不会报错 const修饰成员函数 常函数： 成员函数后加const后我们称这个函数为常函数 常函数内不可以修改成员属性 成员属性声明时加关键字mutable后，在常函数中依然可以修改 常对象： 声明对象前加const称该对象为常对象 常对象只能调用常函数","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++ 学习 Linux系统编程 GCC","slug":"C++-学习-Linux系统编程-GCC","date":"2023-04-16T07:56:51.000Z","updated":"2023-06-16T08:04:49.777Z","comments":true,"path":"2023/04/16/C++-学习-Linux系统编程-GCC/","link":"","permalink":"http://example.com/2023/04/16/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-GCC/","excerpt":"什么是GCC GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数-std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5） 查看版本 gcc/g++ -v/--version GCC工作流程","text":"什么是GCC GCC 原名为 GNU C语言编译器（GNU C Compiler） GCC（GNU Compiler Collection，GNU编译器套件）是由 GNU 开发的编程语言译器。GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等） GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数-std=c99 启动 GCC 时，编译器支持 C99 标准。 安装命令 sudo apt install gcc g++ （版本 &gt; 4.8.5） 查看版本 gcc/g++ -v/--version GCC工作流程 GCC和G++的区别 gcc 和 g++都是GNU(组织)的一个编译器。 误区一：gcc 只能编译 c 代码，g++ 只能编译 c++ 代码。两者都可以，请注意： 后缀为 .c 的，gcc 把它当作是 C 程序，而 g++ 当作是 c++ 程序 后缀为 .cpp 的，两者都会认为是 C++ 程序，C++ 的语法规则更加严谨一些 编译阶段，g++ 会调用 gcc，对于 C++ 代码，两者是等价的，但是因为 gcc命令不能自动和 C++ 程序使用的库联接，所以通常用 g++ 来完成链接，为了统一起见，干脆编译&#x2F;链接统统用 g++ 了，这就给人一种错觉，好像 cpp 程序只能用 g++ 似的 误区二：gcc 不会定义 __cplusplus 宏，而 g++ 会 实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++ 语法来解释 如上所述，如果后缀为 .c，并且采用 gcc 编译器，则该宏就是未定义的，否则，就是已定义 误区三：编译只能用 gcc，链接只能用 g++ 严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以gcc&#x2F;g++，而链接可以用 g++ 或者 gcc -lstdc++。 gcc 命令不能自动和C++程序使用的库联接，所以通常使用 g++ 来完成联接。但在编译阶段，g++ 会自动调用 gcc，二者等价","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[]},{"title":"论文阅读 Houdini’s Escape: Breaking the Resource Rein of Linux Control Groups","slug":"论文阅读-Houdini’s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups","date":"2023-04-15T05:08:53.000Z","updated":"2023-04-22T11:50:35.932Z","comments":true,"path":"2023/04/15/论文阅读-Houdini’s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/","link":"","permalink":"http://example.com/2023/04/15/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Houdini%E2%80%99s-Escape-Breaking-the-Resource-Rein-of-Linux-Control-Groups/","excerpt":"摘要 Linux Control Groups，即cgroups，是启用操作系统级容器化的关键构建块。cgroups机制将进程划分为分层的组，并应用不同的控制器来管理系统资源，包括CPU、内存、块I&#x2F;O等。新生成的子进程自动从父进程中复制cgroups属性以加强资源控制。不幸的是，通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。在本文中，我们设计了一套利用策略，通过将进程与原始进程组解关联来生成out-of-band工作负载。这样的工作负载所消耗的系统资源不会被计算到适当的cgroup中。 为了进一步证明可行性，我们提供了Docker容器中的五个案例研究，以演示如何在现实场景中打破cgroup的资源限制。更糟糕的是，通过利用这些cgroups在多租户容器环境中的不足，攻击容器能够极大地扩大所消耗的资源数量，显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们在本地测试平台和Amazon EC2云专用服务器上进行了大量的实验。实验结果表明，一个容器可以消耗系统资源(例如CPU)高达其极限的200倍，并使其他共存容器中特定工作负载的计算和I&#x2F;O性能降低95%。","text":"摘要 Linux Control Groups，即cgroups，是启用操作系统级容器化的关键构建块。cgroups机制将进程划分为分层的组，并应用不同的控制器来管理系统资源，包括CPU、内存、块I&#x2F;O等。新生成的子进程自动从父进程中复制cgroups属性以加强资源控制。不幸的是，通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。在本文中，我们设计了一套利用策略，通过将进程与原始进程组解关联来生成out-of-band工作负载。这样的工作负载所消耗的系统资源不会被计算到适当的cgroup中。 为了进一步证明可行性，我们提供了Docker容器中的五个案例研究，以演示如何在现实场景中打破cgroup的资源限制。更糟糕的是，通过利用这些cgroups在多租户容器环境中的不足，攻击容器能够极大地扩大所消耗的资源数量，显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们在本地测试平台和Amazon EC2云专用服务器上进行了大量的实验。实验结果表明，一个容器可以消耗系统资源(例如CPU)高达其极限的200倍，并使其他共存容器中特定工作负载的计算和I&#x2F;O性能降低95%。 CCS CONCEPT Security and privacy → Virtualization and security KEYWORDS Container；Control Group；Docker INTRODUCTION容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。 尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。 在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即namespaces)和Linux控制组(即cgroups)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。 容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞。 容器技术已广泛应用于各种计算场景，包括边缘计算、微服务架构、无服务器计算和商业云供应商。与虚拟机相比，消除额外的抽象层可以更好地利用资源并提高效率。因此，容器可以实现接近本机的性能。 尽管容器技术具有性能优势，但最近也引起了一些安全和隐私问题，特别是资源隔离、特权升级、混淆代理攻击和隐蔽通道。 在Linux内核中，启用容器资源隔离和管理的两个关键构建块是Linux命名空间(即命名空间)和Linux控制组(即cgroups1)。此外，还采用或建议了一组安全机制(例如，Capabilities、SELinux、AppArmor、seccomp和安全命名空间)来进一步增强部署中的容器安全性。 容器依赖于cgroup进行资源管理和控制，以防止一个容器耗尽主机的系统资源。cgroups机制将一组进程及其子进程划分为分层的组，并应用不同的控制器来管理和限制各种系统资源，例如CPU时间、计算机内存、块I&#x2F;O等。通过合理的限制策略，cgroups可以缓解许多已知的拒绝服务漏洞 在本文中，我们打算系统地探讨一下来摆脱现有的cgroups机制的资源控制、并了解其对容器的安全影响。新创建的子进程会自动继承其父进程的cgroups属性。这种机制保证了它们将被限制在相同的cgroups策略下。为了打破cgroups的资源约束，我们设计了一套利用策略，通过将进程与其原始cgroups分离，生成了一些带外工作负载。这意味着这些进程不再受到原始cgroups的资源限制，从而可能绕过原本的资源管理策略。这些进程可以从头开始创建，以处理在一个cgroup内发起的系统事件。在其他情况下，这些进程可以是休眠的内核线程或系统服务进程。在整个系统中共享，并将在需要时被激活。因此，相应的消耗的资源将被收取到其他 “受害者 “cgroups中。 为了进一步揭示现有cgroup机制不足的安全风险，我们使用Docker容器进行了五个案例研究，展示了在现实系统设置中逃脱cgroup资源控制的步骤。在这些案例研究中，我们分别利用了异常、文件系统和I&#x2F;O设备、Linux日志系统、容器引擎和softirqs处理的内核处理机制。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行实验。我们的实验表明，即使执行了多个cgroup控制器，一个对抗性去特权容器仍然可以显著耗尽CPU资源或产生大量的I&#x2F;O活动，而不需要任何cgroup控制器。 更糟糕的是，通过在多租户容器环境中利用这些机制，对抗性容器能够极大地扩大所消耗的资源量。由于对抗容器会发动多种攻击(如拒绝服务攻击和资源释放攻击)，可以显著降低同一主机上的其他容器的速度，并在系统资源上获得额外的不公平优势。我们的实验证明，对手仅通过控制少量资源就能显著影响共存容器的性能。例如，一个容器可能会消耗系统资源(例如CPU)，超过其极限200倍，并使其他容器的特定基准的计算和I&#x2F;O性能降低95%。总体而言，本工作的主要贡献总结如下: 我们提出了四种可能导致系统资源错误计算的开发策略，因此我们可以逃避cgroup控制器强制执行的资源约束。 我们在Docker容器环境中进行了五个案例研究，并证明了在现实场景中打破cgroup限制并消耗大量资源是可能的。 我们在两个具有不同配置的试验台上评估了所提出的方法的影响。实验结果表明了安全影响的严重性。 本文的其余部分组织如下。第二节介绍了cgroup的背景。第3节介绍了逃脱cgroups机制控制的策略，并从内核的角度分析了其根本原因。第4节详细介绍了容器的几个案例研究，包括威胁模型、攻击向量以及对多租户容器环境的各种攻击的有效性。第5节从不同方面讨论了潜在的缓解措施。第6节对相关工作进行考察，并在第7节中进行总结。 BACKGROUND在Linux内核中，cgroups是用于管理一组任务及其所有子任务的系统资源(例如CPU、内存、磁盘I&#x2F;O、网络等)的关键特性。它是实现集装箱化的构建块之一。cgroup机制将进程组划分为具有控制行为的分层组。所有的子进程也从它们的父进程继承某些属性(例如，limits)，并由该机制控制。cgroups依赖于不同的资源控制器(或子系统)来限制、解释和隔离各种类型的系统资源，包括CPU时间、系统内存、块I&#x2F;O、网络带宽等。Linux容器利用控制组对每个容器实例应用资源限制，并防止单个容器耗尽主机资源。对于云计算中的计费模型，还可以使用cgroups为每个容器分配相应的资源并测量它们的使用情况。下面我们简要介绍cgroup层次结构的背景知识，现有容器环境中通常应用的四种典型的cgroup控制器，以及新生成进程的cgroup继承过程。 cgroups Hierarchy and Controllers在Linux中，cgroup是按层次结构组织的，其中一组cgroup被排列在树中。每个任务(例如，一个线程)只能与一个层次结构中的一个cgroup相关联，但可以是不同层次结构中的多个cgroup的成员。然后，每个层次结构都有一个或多个附加子系统，以便资源控制器可以对特定的系统资源应用每个cgroup限制。通过分层结构，cgroups机制能够限制一组进程(例如容器)的资源总量。 The cpu controllercpu controller通过利用CFS(完全公平的调度器，在Linux 2.6.23中引入)调度cpu，以两种方式使cpu成为可管理的资源。 第一种方法是保证最少数量的CPU共享:每个组都提供相应的共享，以定义相对权重。该策略在CPU空闲时不限制cgroup的CPU使用率，当多个cgroup竞争相同的CPU资源时，按照权重的比例分配带宽。例如，如果共享为512的一个容器与共享为1024的另一个容器运行在同一个核心上。然后，第一个容器的CPU使用率大致为33.3%，而另一个容器的CPU使用率为66.7%。在Linux 3.2中进一步扩展了cpu控制器，通过指定配额和周期来提供额外的cpu带宽控制。 每个组只能在每个给定的“时间段”(以微秒为单位)内消耗“配额”微秒。如果一个组的CPU带宽消耗(由运行时变量跟踪)超过了限制，控制器将限制该任务，直到下一个时间段，此时容器的运行时被重新充电到其配额。cpu控制器被广泛应用于多租户容器环境，以限制一个容器的cpu使用。如果容器设置的配额为50,000，周期为100,000，则该容器最多可以消耗一个CPU核心总CPU周期的一半。 The cpusets controllercpusets控制器提供了一种机制，用于将一组任务约束到特定的cpu和内存节点。在多租户容器环境中，利用cpusets控制器来限制特定核心上容器的工作负载。容器的每个任务都附加到一个cpuset，其中包含一组允许使用的cpu和内存节点。对于CPU调度，任务的调度(通过系统调用sched_setaffinity)被过滤到任务的cpusset允许的那些CPU。任务的任何进一步的动态迁移也仅限于允许的cpuset。因此，cpusets控制器还可以用于将一个进程固定在特定的核心上。容器用户还可以利用用户空间应用程序(例如，taskset)在cpuset的限制范围内进一步设置亲和性。 The blkio controllerblkio cgroup通过应用I&#x2F;O控制来控制和限制对指定块设备的访问。内核级有两个策略可用。第一个是基于比例权重的基于时间的磁盘策略划分。每个cgroup都被分配了一个blkio。权重值，表示该组占用磁盘时间的比例。第二个是节流策略，它指定I&#x2F;O设备上的上限。 The pid controllerpid cgroup子系统用于对容器的任务数量设置一定的限制。这可以通过在pid.max中设置最大任务数来实现。当前任务数保存在pid .current中。pid cgroup子系统将在达到限制(例如，pid.current&gt; pid .max)停止forking或克隆一个新任务(例如，返回错误信息)。因此，pid控制器可以有效防御多种耗尽攻击，如fork bomb。 cgroups Inheritancecgroups的一个重要特性是子进程从父进程继承cgroups属性。每当一个进程创建一个子进程(例如，fork或clone)时，它都会触发内核中的fork函数来复制初始化进程。当新派生的进程在开始时附加到根cgroup时，在复制寄存器和进程环境的其他适当部分(例如，命名空间)后，调用cgroup复制函数来复制父进程的cgroup。特别是，该函数通过递归遍历所有cgroup子系统，将任务附加到其父cgroup。因此，在复制过程之后，子任务将继承与其父任务完全相同的cgroups成员。 例如，如果cpusets资源控制器将父进程的the CPU affinity设置为第二个核心，那么新派生的子进程也将被固定在第二个核心上。同时，如果cpu子系统将父cgroup上的cpu配额限制为50,000，周期为100,000，那么在第二个核上，cgroup的总cpu利用率(包括新分叉的进程和它的父进程)不能超过50%。 EXPLOITING STRATEGIES在本节中，我们将描述四种逃避cgroups机制的资源控制的策略，并解释现有cgroup无法跟踪所消耗资源的根本原因。如上所述，使用层次结构，cgroups机制可以限制一组进程(例如容器)的资源总量。这是通过附加资源控制器对特定的系统资源应用每cgroup限制来实现的。此外，cgroup中的继承机制确保了同一个cgroup中的所有进程及其子进程都可以被cgroup子系统控制，而不消耗额外的系统资源。 然而，由于Linux内核的复杂性和实现cgroups的难度，我们发现有几个机制没有考虑到，因此可以利用它们来逃避现有cgroups的约束。关键思想是生成工作负载，运行在没有直接从初始化cgroup派生出来的进程上，这导致了cgroup的去关联。特别是，如图所示，用户空间中没有根权限的普通进程可以利用四种策略逃脱cgroups的控制。 Exploiting Upcalls from Kernel在cgroups机制中，所有内核线程都附加到根cgroup，因为内核线程是由内核创建的。因此，内核线程通过fork或clone创建的所有进程也都附加到与其父进程相同的cgroup(根cgroup)中。 因此，一个cgroup中的进程可以利用内核线程作为代理来产生新的进程，从而逃脱cgroup的控制。特别地，如图❶所示，一个进程可以先触发内核来初始化一个内核线程。 这个内核线程充当代理，进一步创建一个新进程。 由于内核线程附加到根cgroup，因此新创建的进程也附加到根cgroup。在新创建的进程上运行的所有工作负载将不受cgroup子系统的限制，从而打破资源控制。 但是，这种机制要求用户空间进程首先调用内核空间中的内核函数，然后从内核空间向上调用用户空间进程。虽然从用户空间调用特定的内核函数(例如系统调用)是很自然的，但相反的方向并不常见。一种可行的方法是通过usermode helper API，该API通过提供可执行变量和环境变量的名称，为在用户空间中创建流程提供了一个简单的接口。这个函数首先调用一个运行在内核线程中的工作队列(例如，kworker)。工作队列的处理函数进一步创建一个内核线程来启动用户进程。最后一步调用内核中的fork函数，将创建的用户进程附加到内核线程的cgroups。 用户模式助手API可用于多种场景，如加载模块、重新启动计算机、生成安全密钥和传递内核事件。虽然在用户空间中触发这些活动通常需要root权限，但仍然可以在用户空间中调用API，这将在4.1节中讨论。 Delegating Workloads to Kernel Threads另一种利用内核线程来打破cgroup约束的方法是将工作负载委托给它们，如图❷所示。同样，由于所有内核线程都附加到根cgroup，因此这些工作负载所消耗的资源量将计入目标内核线程，而不是初始化用户空间进程。 Linux内核运行多个内核线程，处理各种内核函数并在进程上下文中运行内核代码。例如，kthread是内核线程守护进程，用于创建其他内核线程;引入Kworker来处理工作队列任务;Ksoftirqd服务于softirqs;迁移执行迁移作业，将任务从一个核心移动到另一个核心;kswapd管理交换空间。对于这些内核线程，根据它们的功能，内核可能只在系统中运行一个线程(例如kthread)，或者每个内核运行一个线程(例如ksoftirqd)，或者每个内核运行多个线程(例如kworker)。一直有报道称，由于各种bug和问题，内核线程会消耗大量的资源。因此，如果一个进程可以强制内核线程运行委托的工作负载，相应消耗的资源将不受cgroup的限制。 Exploiting Service Processes除了由内核维护的内核线程外，Linux服务器还运行多个系统进程(例如systemd)，用于不同的目的，如进程管理、系统信息日志记录、调试等。这些流程监视其他流程，并在触发特定活动时生成工作负载。同时，许多用户空间进程作为其他进程的依赖关系，同时运行以支持其他进程的正常功能。如果一个用户进程能够在这些进程上生成内核工作负载(图中的策略❸ )，所消耗的资源就不会被分配给初始化进程，从而可以逃脱cgroups机制。 Exploiting Interrupt Context最后一种策略是利用中断上下文中所消耗的资源。cgroup机制只计算在进程上下文中消耗的资源。一旦内核运行在其他上下文(如中断上下文,如图所示的策略❹),所有消耗的资源都不会被计入任何cgroup 特别地，Linux内核服务中断分为两部分:上半部分(即硬件中断)和下半部分(即软件中断)。由于硬件中断可能随时被引发，因此上半部分仅通过响应硬件中断来执行轻量级操作，然后安排(延迟)下半部分的执行。当在下半部分执行中断处理程序时，内核运行在软件中断上下文中，因此它不会为系统资源(例如CPU)收取任何进程的费用。 从内核3.6开始，softirq的处理(硬件中断引发的除外)与生成它们的进程绑定。 这意味着在softirq上下文中所消耗的所有资源都不会消耗所引发进程的任何配额。此外，softirqs的执行将抢占当前进程上的任何工作负载，所有进程将被延迟。 此外，如果处理softirqs的工作负载过重，内核将把它们卸载到内核线程ksoftirqd，这是一个每个CPU(即每个CPU一个线程)的内核线程，并以默认的进程优先级运行。一旦卸载，对softirqs的处理将在ksoftirqd的进程上下文中运行，因此任何资源消耗都将在线程ksoftirqd上计算。在这种情况下，它属于内核线程策略(如图所示的策略❷ )。总之，如果一个进程(称为进程A)能够引发大量的软件中断，内核将不得不在中断上下文或ksoftirqd的进程上下文中花费资源来处理软中断，而不向进程A支付费用。 CASE STUDIES ON CONTAINERS在前一节中，我们讨论了几种可能的策略来逃避cgroups的资源控制。然而，在现实的容器环境中，由于存在其他合作安全策略，开发更具挑战性。在本节中，我们将介绍在Docker容器环境中进行的五个案例研究，以演示利用cgroups弱点的详细步骤。 Threat model 我们考虑一个多租户容器环境，其中属于不同租户的多个Docker容器共享同一台物理机器。目前，边缘和云平台都广泛采用了多租户环境。系统管理员使用cgroups为每个容器设置资源限制。每个容器都是去特权的，设置有有限的CPU时间、系统内存、块I&#x2F;O带宽，并固定到特定的核心。我们假设攻击者控制了一个容器实例，并试图利用cgroups中的不足(1)降低其他容器的性能，(2)获得不公平的优势。 Configuration 我们使用Docker容器通过提供的接口来设置cgroups的配置。此外，Docker还默认确保容器通过namespace隔离。特别是，启用USER namespace后，容器中的根用户将映射到主机上的非特权用户。 因此，容器中的特权操作不会影响主机内核。我们的案例研究就是在这样一个没有特权的容器中进行的。 为了演示每种利用的有效性，我们通过在空闲服务器上设置多个cgroup配置来初始化容器，并测量主机上系统资源的利用率。为了模拟边缘和云环境，我们选择了两个测试平台来进行实验:(1)我们实验室的本地机器;(2) Amazon EC2中的专用主机。特别是，虽然我们的本地测试台配备了7200 rpm的SATA硬盘驱动器，但我们在EC2服务器上选择了更好的I&#x2F;O配置。专用试验台的存储配置了1000iops的SSD(默认为400)，吞吐量比我们本地试验台提高20倍左右。因此，本地测试平台表示可能部署在边缘环境中的性能较低的节点，而强大的专用服务器可以模拟多租户容器云环境。 Ethical hacking concerns 使用cgroup将不可避免地产生主机级的影响，这可能会影响主机服务器上所有容器的性能。因此，对于我们在Amazon EC2上的实验，我们选择使用专用服务器，该服务器仅供我们使用，不与其他租户共享。 此外，它还允许我们模拟多租户容器环境并度量系统范围的影响。 Result summary 表给出了所有案例研究的总体总结、相应的开发策略和影响。第一个案例研究是利用内核中的异常处理机制，这涉及到策略❶。我们发现容器中引发的异常可以调用用户空间进程，其后果是容器可以消耗比cgroups限制多200倍的CPU资源。第二种情况是利用回写机制进行磁盘数据同步，这涉及到策略❷。容器可以不断调用全局数据同步，以降低主机上特定I&#x2F;O工作负载的速度，最高可达95%。第三种情况是利用系统服务日志(通过策略❸)，产生消耗CPU和块设备带宽的工作负载。第四种情况是利用容器引擎在容器引擎进程(策略❸)和内核线程(策略 ❷)上产生额外的未计算的工作负载(大约3倍)。最后一种情况是利用softirq处理机制在内核线程(策略 ❷)和中断上下文(策略❹)上消耗CPU周期。 Case 1:Exception Handling第一种情况是利用内核中的异常处理机制。我们发现可以调用用户模式助手API，并通过异常进一步触发用户空间流程(作为策略❶)。通过反复产生异常，一个容器消耗的CPU资源比限制多约200倍，从而使同一主机(不限于一个核)上其他容器的性能显著降低85% ~ 95%。 Detailed analysis Linux内核为各种异常提供了专用的异常处理程序，包括错误(例如，分割错误)和陷阱(例如，溢出)。内核维护一个中断描述符表(IDT)，其中包含每个中断或异常处理程序的地址。如果CPU在用户模式下引发异常，相应的处理程序将在内核模式下调用。处理器首先在内核堆栈中保存寄存器，然后相应地处理异常，最后返回到用户模式。整个过程在内核空间和触发异常的进程上下文中运行。因此，它将被充电到正确的相应的cgroups。 然而，这些异常将导致初始进程的终止并引发信号。这些信号将进一步触发内核转储功能，生成一个用于调试的内核转储文件。内核中的核心转储代码通过usermode辅助API从内核中调用一个用户空间的应用程序。在Ubuntu中，默认的用户空间核心转储程序是Apport，它将在每个异常情况下被触发。正如上一节所提到的，Apport所消耗的系统资源将不会由容器承担，因为该进程是由内核线程分叉的，而不是由容器化的进程。 新产生的Apport实例将被内核安排到所有的CPU核心，以达到负载平衡的目的，因此打破了cpusets的cgroup。同时，由于Apport进程的运行比轻量级的异常处理（即内核控制路径）消耗更多的资源，如果容器不断引发异常，整个CPU将被Apport进程完全占据。cpu cgroup的逃逸导致分配给容器的系统资源的巨大放大。 Workloads amplification 为了研究这种影响，我们在一个核心上启动并固定一个容器。我们通过调整周期和配额来为容器设置不同的CPU资源限制。 容器进入循环，不断引发异常。我们实现了几种用户空间程序可用的异常类型。由于不同类型的异常的结果是相似的，我们使用div 0异常作为例子。容器是唯一在我们的测试平台中运行的活动程序。我们通过top命令测量测试平台的CPU使用率，通过Docker的统计工具测量容器的CPU使用率。对于主机级别的使用情况，我们将所有内核的CPU使用量汇总在一起（因此12个内核的最大使用量为1200%）。我们将放大系数定义为主机的CPU利用率与容器的CPU利用率的比率。 图演示了用户模式助手API可以触发用户空间程序，从而显著提高容器的CPU使用率。在我们的本地测试平台上，容器使用的一个内核上的CPU利用率只有7.4%，整个12个内核都被占用了。当我们将分配给容器的CPU资源减少到仅10%内核(通过设置period为200,000,quota为20,000)后，这个问题无法缓解。我们进一步将容器的CPU限制降低到20%核心，并最终将12个核心的总利用率限制到1,065%，放大因子为207×。同时，系统内存使用增加了约1GB，而Docker测量的容器内存使用仅为15.58MB。 我们从EC2服务器上获得了类似的结果:容器的22.5%的利用率就可以耗尽36个内核。由于CPU频率不如我们的本地测试平台强大，一旦我们将容器的CPU资源限制为1&#x2F;10内核，它可以在所有36个内核上产生1907%的利用率。放大系数约为192×。 The pid controller 虽然放大要求容器不断抛出异常，但我们进一步使用pid cgroup子系统对容器的任务数量设置一定的限制。同样，如图所示，即使活动进程的数量被限制在50个，pid控制器也不能降低放大结果，这是一个非常小的数字，可能会对容器用户造成巨大的可用性影响。在单核CPU计算能力只有20%的情况下，将pid限制为50，放大系数可以降低到98×。在EC2服务器上，在单核10% CPU计算能力的容器上，通过将pid数量限制在50个，放大系数在144×左右. Denial-of-service(DoS) attacks 当多个容器在同一个核心上运行时，它们将共享和竞争CPU资源。Linux的CFS系统根据每个容器的份额来分配CPU周期。CFS系统确保了完全的公平性，即容器可以完全利用其插槽中的所有资源。然而,如果一个恶意的容器可以在它自己的cgroup之外产生新的工作负载，CFS系统也会将CPU周期分配给这些进程，从而减少其他co-residence容器的使用。同时，CPU使用率的下降也可能影响其他的性能，如内存和I&#x2F;O吞吐量。 在我们的实验中，我们通过利用恶意容器中的异常处理机制来衡量DoS攻击的影响。我们运行两个容器:一个恶意容器和一个受害者。我们将攻击的性能与恶意容器运行正常工作负载(即基线)的情况进行比较。受害容器运行不同的sysbench工作负载来度量性能。 这两个服务器上的结果如表所示。我们首先将两个容器设置在相同的内核上，使用完全相同的CPU共享和配额。我们发现，在我们的本地测试平台上，抛出异常(导致内核转储)可以显著降低95%的CPU和内存性能，并降低17%左右的I&#x2F;O性能。在EC2服务器上，大约85%用于CPU和内存性能，82%用于I&#x2F;O性能。这是合理的，因为引发异常会导致大量用户空间核心转储应用程序与受害容器竞争CPU周期。 通过将容器固定在不同的核心上，我们进一步改变了恶意容器的核心亲缘性。尽管恶意容器不再与受害者竞争同一内核上的CPU资源，但它在受害者的性能上仍然显示出类似的结果。这是因为CPU资源的主要竞争对手不是恶意容器，而是那些触发内核转储的应用程序。 这一结果表明，恶意租户可以很容易地利用容器来显著降低同一主机上所有其他容器的性能，并降低服务供应商的服务质量，从而可能导致巨大的经济损失，而成本很少。 Case 2:Data Synchronization我们的第二个案例是利用磁盘数据同步的回写机制，出于性能考虑，该机制被广泛采用。CPU只会将更新后的数据写入缓存，当缓存被清除时，数据才会写入磁盘。 由于懒惰的磁盘回写机制将启动I&#x2F;O的进程与同步磁盘写入的进程解耦，所以我们的利用可以逃避cgroups。有多种方法可以触发数据同步，包括定期回写和内存不足。它也可以由用户进程通过系统调用故意调用，如sync（将缓存文件数据的所有未决修改写回给底层文件系统）、syncfs（同步开放文件所指的文件系统）和fsync（将文件的所有修改数据传输到其常驻磁盘设备）。这些系统调用对Linux容器是可用的。特别是，我们发现，同步可以被利用来减慢整个系统的I&#x2F;O性能（例如，在序列写入上有超过87%的降级），发起无资源攻击，并建立秘密通道。 Detailed analysis on sync 同步的第一步是启动一个内核线程，它将页缓存中包含的所有脏页刷新到磁盘。它通过扫描所有当前挂载的文件系统来查找要刷新的所有脏索引节点，并刷新相应的脏页。由于同步允许进程将所有脏缓冲区写回磁盘，任何I&#x2F;O操作都必须等待刷新。 更糟糕的是，由其他进程(可能属于另一个容器)生成的脏缓冲区也将被迫写回磁盘。 容器中的进程可以在不执行I&#x2F;O操作的情况下，以少量的工作负载重复调用sync。但是，与此同时，如果在其他共驻留容器上有I&#x2F;O操作，同步将回写所有脏页。在我们的实验中，我们运行了一个不断调用sync的容器。它不会导致超出容器限制的任何额外利用率。然而，一旦我们运行另一个容器，进行一些简单的写操作，同步操作就会导致大量的CPU等待时间，这是同步和写操作的组合所产生的。CPU等待时间用于指示I&#x2F;O等待所消耗的时间，其他工作负载仍然可以使用它。 但是，在其他容器上运行的特定工作负载的性能会受到显著影响。 blkio cgroup 正如2.1节中提到的，blkio cgroup子系统可以对块设备应用I&#x2F;O控制。虽然Docker只支持通过权重来限制相对I&#x2F;O吞吐量，但内核实际上可以为cgroups设置一个上限。我们使用blkio对运行同步的容器应用I&#x2F;O控制。不幸的是，基于Docker的统计工具，容器的I&#x2F;O吞吐量为零。因此，blkio控制器不能减少同步的影响。原因是由sync触发的所有回写工作负载都在内核线程中处理，调用sync的容器没有I&#x2F;O工作负载。 I&#x2F;O-based DoS attacks 不管发出I&#x2F;O操作的进程是否在容器内，在容器内调用系统调用同步将继续调用系统范围的回写。在某些情况下，回写会降低系统性能，因为特定的工作负载需要等待回写完成。为了测试有效性，我们运行两个固定在两个不同核心上的容器。恶意容器所做的唯一任务是调用系统调用sync，因此本身不会招致I&#x2F;O操作。 为了测量受害容器的性能，我们在受害容器内运行FIO基准测试来测量I&#x2F;O性能。特别地，我们进行了四种不同的FIO工作负载，包括序列&#x2F;随机写和序列&#x2F;随机读。我们还运行UnixBenchmark来测试除I&#x2F;O以外对性能的影响。我们通过将结果除以恶意容器中运行空闲循环的基线情况来计算性能下降。结果如图所示。对于UnixBenchmark，我们列出了性能显著下降的工作负载。总的来说，我们可以看到在受害者中运行的FIO基准测试的性能受到了很大的影响。通过在恶意容器中不断调用sync，所有四种类型I&#x2F;O操作的性能都会受到显著影响。对于顺序写入，在我们的本地测试床上性能下降到2%，在EC2服务器上下降到13%。 对于UnixBenchmark，运行shell脚本的性能也严重降低到不到一半。对于其他基准测试，退化约为5%到10%。 Resource-Freeing Attack(RFA) RFA攻击的目标是通过争夺受害者的瓶颈资源来为攻击者的实例释放特定的资源。在容器环境的情况下，两个容器在争夺系统资源，如CPU。恶意容器试图提高其工作负载的性能（被称为beneficiary），以获得更多的系统资源。因此，恶意容器运行另一个轻量级程序（被称为helper）来释放受害者容器使用的资源，以便受益者能够获得更多的资源。帮助者只消耗很少的系统资源（因此它对beneficiary几乎没有影响），但可以显著影响在受害者容器内运行的工作负载。例如，在恶意容器中，受益者程序可以运行CPU密集型的工作负载，并与受害者容器在同一CPU核心上竞争CPU资源。受害者容器运行I&#x2F;O密集型的工作负载，因此CPU活动与I&#x2F;O操作的频率相联系：更多的I&#x2F;O操作使受害者容器消耗更多的CPU周期来处理这些请求。然后，恶意者运行一个辅助程序，定期调用sync，触发回写，并减少受害者的I&#x2F;O活动。这样可以降低受害者容器的CPU使用率，恶意容器可以获得更多的CPU资源。我们通过在同一个核上运行两个容器来模拟实验。在受害容器中，我们模拟了一个网络爬虫的情况，其中容器不断地将一个网页写入一个新文件。 我们使用sysbench来测量恶意容器的CPU和内存性能，其中值越高表示性能越好。恶意容器还会定期调用sync来触发全局回写。对于基线情况，只有攻击者的容器是活动的，因此不存在对所有系统资源的竞争。然后，我们运行这两个容器，并将攻击者容器的性能与基线情况进行比较。如图，在没有RFA攻击的情况下，由于两个容器争夺同一核上的CPU资源，CPU性能(即白条)约为无竞争情况(即黑条)的一半，内存性能约为无竞争情况的1&#x2F;3。然而，通过发起RFA攻击(即灰色条)，恶意容器内的受益人可以在两个测试平台上获得更好的性能。特别是，在我们的本地服务器上，性能几乎与没有竞争的情况相同。 Covert Channels 最后，我们证明了cgroups中的不足也可能被恶意攻击者利用，在不同的核心之间构建基于时间的隐蔽通道。其思想是利用由磁盘数据同步引起的性能差异。我们测量在一个容器中写入10个文件的时间，同时在另一个内核的另一个容器中运行sync。 我们重复实验100次，所需要的时间分布如图所示。我们可以观察到运行同步和不运行同步之间打开文件的明显时间差异。我们通过利用性能差异构建了一个概念验证通道，能够以2bits&#x2F;s的速率传输数据，错误率为2%。 Case 3:System Process - Journald我们的第三个案例是利用system - Journal服务，它提供了一个系统服务来收集系统日志数据，包括内核日志消息、系统日志消息(例如，syslog调用或Journal API)，以及通过审计子系统的审计记录。所有相关的活动都由系统进程日志记录。在我们的案例研究中，我们发现容器中的三类操作可以迫使日志进程记录日志，导致5%到20%的额外CPU利用率和平均2MB&#x2F;s的I&#x2F;O吞吐量，然后可以利用这些影响其他容器的性能。 Detailed analysis 主机的系统进程被附加到不同于容器中的进程的cgroup中，因为它们是由操作系统维护的，以提供全系统的功能。因此，如果容器内的工作负载可以触发这些系统进程的活动，那么这些活动所消耗的资源将不会被计入容器的cgroup，从而逃避资源控制机制。但是，运行在主机上的系统进程会忽略容器内的大部分操作。例如，在主机上运行的用户空间进程的许多活动将由日志记录。但是如果流程在容器内运行，那么这些活动将被忽略。为了记录容器内的事件，主机上的系统管理员需要更改system -journal服务的配置。 特别是，Docker提供了一个选项来启用日志记录。 然而，我们发现，即使没有启用日志记录选项，在某些特定的情况下，容器仍然能够在日志系统进程上生成不可忽略的工作负载。 特别地，我们介绍了导致系统进程负载的三种类型的操作，从而逃脱了cgroup的控制。 Switch user (su) command su命令提供了一种将登录会话的所有权切换到root用户的方法。 切换到root用户的操作将被记录在日志系统进程中。日志包含进程、用户帐户和环境切换的信息。日志服务也会记录用户的退出。使用USER namespace，容器内的根用户映射到主机上的无特权用户。因此，容器中的进程可能在USER名称空间中拥有完全的特权，但实际上在主机上被剥夺了特权。作为容器中的根用户，su命令可以进入另一个用户。不幸的是，在容器内切换帐户所引起的活动将触发system -journal服务来记录相关信息。 Add user&#x2F;group 在USER namespace中，容器用户可以添加新组或在现有组中添加新帐户。这些活动也将由主机上的日志系统进程记录。 Exception 最后，如前所述，内核无法区分所引发异常的上下文(在容器内部或外部)。因此，容器内异常引起的崩溃信息也会触发主机上系统进程的日志记录活动。 所有上述工作负载都将在日志中触发大量事件日志记录。同样，我们将一个容器设置为具有一个CPU核心计算能力，以继续调用上述命令。在我们的本地测试床上，我们观察到journald上的CPU使用率恒定为3.5%，auditd上的CPU使用率恒定为2.5%，kauditd上的CPU使用率恒定为1%。在EC2服务器中，由于其更好的I&#x2F;O性能，这个数字要大得多:我们观察到平均CPU利用率约为20%。我们还发现，journald进程的平均I&#x2F;O吞吐量约为2MB&#x2F;s，而容器的I&#x2F;O吞吐量为零。如果我们为容器分配更多的计算资源，这个数字将会增加。 DoS attacks 日志journald活动将产生不可忽略的I&#x2F;O操作，这将导致与其他容器的资源竞争。为了衡量结果，我们在主机的不同内核上运行两个容器。在恶意容器中，我们不断切换用户(即su)并退出当前用户(即exit)。在受害容器中，运行与case 2中描述的相同的基准测试。 图显示了结果。总的来说，我们看到整个系统的性能下降。在I&#x2F;O性能较差的服务器(例如，我们的本地测试平台)中，滥用journald的攻击将更加有效。如前所述，它在日志进程中可能导致超过2MB&#x2F;s的I&#x2F;O吞吐量。我们观察到它仍然可以使EC2专用服务器上的其他容器在1000iops(吞吐量约为15MB&#x2F;s)时变慢。在一个具有默认配置的专用服务器中(例如，400 IOPS，吞吐量约为6MB&#x2F;s)，我们可以观察到更明显的结果。 Residual effect 在I&#x2F;O性能较差的服务器上，系统进程的写工作负载可能超过服务器的I&#x2F;O能力。结果，大量的日志事件被排队，等待稍后被记录。这将导致一个残留效应:即使容器停止了它的工作负载(例如su)，系统仍将继续在journald中写入，直到队列中的工作负载完成。残留效应在我们的本地测试平台上很明显，并且持续的时间比工作负载的运行时间长得多。即使容器完全空闲，CPU和I&#x2F;O资源也会被消耗。更糟糕的是，这些写入操作将显著影响其他容器和主机的I&#x2F;O性能。 Case 4:Container Engine容器的第四种情况是通过在内核线程(例如kworker)和容器引擎上触发额外的工作负载来利用容器引擎，容器引擎需要在主机上运行以支持和管理容器实例。特别是，容器引擎作为系统上的特权守护进程运行，因此它作为容器实例附加到不同的cgroup上。容器实例上的cgroup限制将不能控制引擎上消耗的资源。总的来说，通过这种方式，我们发现一个容器可以将资源消耗增加到大约3倍。 Detailed analysis 我们首先简要介绍Docker容器引擎及其cgroup层次结构。Docker创建一个包含所有容器实例的Docker cgroup。每个容器由其ID标识，并保存由fork创建的所有进程。从理论上讲，容器内运行的所有工作负载都将被计入容器cgroup。 此外，Docker构建在Docker引擎之上，其中一个守护进程(即dockerd)在后台运行，处理Docker映像的管理。Docker引擎然后与containd(一个守护进程)通信，以进一步使用runC来运行容器。dockerd进程对于每个容器实例都有多个子进程。这些进程被附加到所有系统服务的默认cgroup中。 此外，用户主要通过命令行接口(CLI)客户端(即Docker进程)控制和管理Docker, Docker进程通过Docker REST API与Docker守护进程交互。Docker CLI为用户提供了创建或执行容器的接口。它还提供了多个命令来设置与底层控制组相关的资源限制的配置。与Docker引擎进程类似，Docker CLI也不属于容器的cgroup。 利用容器引擎来打破cgroups的控制是相当容易的。一种简单的方法是利用终端子系统。当容器用户与tty设备交互时，数据首先经过CLI进程和容器守护进程，然后到达tty驱动程序进行进一步处理。具体来说，数据被发送到LDISC, LDISC连接高级通用接口(例如，读、写、ioctl)和终端系统中的低级设备驱动程序。通过在kworker内核线程中执行工作队列将数据刷新到LDISC。因此，内核线程上的所有工作负载和所有容器引擎进程都不会被计算到容器实例中。 我们通过在终端中反复显示主机中所有加载的模块来测量容器引擎中生成的工作负载，并将结果说明在图中。同样，容器的使用仅限于一个核心(如图中的container)。 总的来说，使用一个核心的计算能力(100%的利用率)，容器可以通过滥用docker引擎进程在主机上造成大约300%的工作负载。 为了细分使用情况，docker进程属于主机的用户cgroup；其他docker进程属于一个系统cgroup：docker.service。其余的（大部分是内核线程kworker，由于流媒体工作负载，如第3.2节所解释）属于根cgroup。我们还在case 1中进行了与表类似的实验。通过利用Docker容器引擎，攻击者能够降低CPU和内存的性能大约15%。 Case 5:Softirq Handling最后一种情况是利用Linux内核中的softirq处理机制。当前内核定义了11种类型的softirq。特别是，硬件中断处理程序通常会引发软中断。 虽然大多数硬件中断可能不是由容器直接引发的，但容器用户能够操作网络接口上的工作负载生成NET softirq，或块设备生成block softirq。处理这些softirq会消耗内核线程进程上下文(例如ksoftirqd)或中断上下文上的CPU资源。 NET softtirq 一旦NIC完成数据包传输，就会引发中断，而softirq负责在驱动程序缓冲区和网络堆栈之间移动数据包。但是，在流量带宽有限的情况下，使用softirqs带来的开销可以忽略不计:在之前的工作中，当网络流量超过1gbps时，开销为1%。 我们发现，由于网络流量引起的开销会被服务器上的防火墙系统(如iptables)大大放大。iptables建立在netfilter的基础上，提供了一个管理层，用于包过滤规则的添加和删除。netfilter将数据包挂在网络驱动程序和网络堆栈之间。所有的网络数据包首先通过过滤规则进行检查，然后进行进一步的操作(例如，转发、丢弃、由网络堆栈处理)。因此，iptables下的网络流量处理是在softirq上下文中处理的，因此不会向生成或接收流量的容器收费。 在Linux上，Docker依赖于配置iptables规则来为容器提供网络隔离。特别是，它可能为提供web或网络服务的容器设置多个规则。即使容器停止，规则也存在。更糟糕的是，在某些情况下，如果相关标志设置为true，容器可以对系统iptables规则进行更改。一旦有相当数量的规则，开销将是不可忽略的。 我们测量了softirq在不同数量的iptables规则下处理网络流量所带来的开销，如图所示。特别是，我们测量了所有ksoftirqd内核线程的CPU使用情况，以及花在中断上下文上的时间(来自top命令的hi和si)。在我们本地的测试台上，网卡的容量为100mbit &#x2F;s，网络流量约为20 ~ 30mbit &#x2F;s，明显小于中的Gbps级别。我们可以清楚地看到，处理网络流量会产生巨大的开销，并且与规则数量密切相关。当规则数量达到5000条时，CPU将浪费大量的时间(约16%)处理软tirq，并且不会向发起网络流量的容器收费。一旦服务器中有10,000条规则，开销约为40%，其中大多数集中在一个核心上。 EC2服务器有一个非常强大的网卡，具有10,000 Mbit&#x2F;s的容量，与我们的本地测试平台相比带宽更高。因此，与我们的本地测试平台相比，开销略小。在我们的实验中，当网络流量约为300mbit &#x2F;s时，流量仍然会浪费不可忽略的CPU周期。如3.4节所述，软件中断的处理要么抢占当前工作，要么在内核线程中消耗CPU周期。因此，同一核心上的所有其他工作负载将被延迟。 BLOCK softirq 处理softirq时增加工作负载的另一个例子是块设备上的I&#x2F;O操作。Linux内核使用队列存储块请求I&#x2F;O，并将新的请求添加到队列中。一旦请求处理完成，它将引发在softirq上下文中处理的softirq，以进一步处理队列。然后，利用BLOCK softirq转义cgroups的基本思想类似于利用NET softirq。 在容器上下文中，可以通过持续查询完成队列中的事件并提交写或读操作来生成这样的工作负载。对于I&#x2F;O性能较差的设备，这种影响尤其明显。为了进一步定量度量影响，我们使用固定在一个内核上的容器，运行fio推荐来执行顺序读写。我们选择小块用于写入，大块用于读取。我们测量多个内核线程(如kworker)的CPU利用率。容器中的工作负载能够在我们的本地测试平台上的内核上生成不可忽略的工作量，包括相同内核的kworker上16.7%的工作负载。此外，对于序列I&#x2F;O读取，文件分配过程在jpd2和kswapd上分别产生了3.9%和3.8%的额外利用率。最后，我们还利用kworker来测量退化。我们在同一个内核上的内核线程kworker上创建工作负载，攻击者能够对受害者造成大约10%的性能损失(根据sysbench基准测试测量)。 MITIGATION DISCUSSION在这一节中，我们将介绍我们在以下方面的初步努力应对现有cgroups机制的不足所带来的安全问题。由于大多数问题涉及多个内核子系统，因此很难部署一个单一的解决方案来全面彻底地解决所有问题。另外，解决一些问题可能需要重新设计当前的资源核算系统。在下文中，我们将从不同角度讨论潜在的缓解方法。 直观地说，通过考虑由一组进程(或容器)直接或间接生成的所有工作负载，cgroups应该具有细粒度的计算机制。例如，如果一个容器通过内核线程调用另一个用户空间进程，容器的cgroup应该由内核线程传递，这样它也会被复制到新的用户空间进程。因此，新调用的进程与容器属于同一个cgroup，而不是与内核线程属于根cgroup。虽然这种方法可以应用于新生成的进程，但很难处理系统中已经存在的进程。内核线程(如kworker、ksoftirqd)是由内核创建的，用于处理特定的内核工作负载，这些工作负载可能由附加到不同cgroup的不同进程触发。journald系统进程的情况也类似:它记录所有进程引发的所有相关事件，因此将整个日志进程附加到特定的cgroup是不合理的。因此，综合机制不应该改变这些线程的cgroup，而是应该跟踪特定工作量的系统资源，并将其收费给初始进程。例如，Iron跟踪处理每个网络数据包的CPU周期，并向相关进程收费。然而，这样的方法无疑需要大量的内核开发工作，并且由于将多个内核函数用于细粒度资源跟踪而带来大量的运行时开销。 对于某些工作负载，另一个有争议的问题是cgroup是否应该向容器收取这些系统资源。从隐私的角度考虑，主机服务器不应该记录容器实例中运行的任何敏感信息。journald提供了特定的选项来启用容器内的日志活动。但是，我们展示了，即使没有启用日志记录选项，主机仍然为容器记录多个事件。日志记录是由主机执行的，因此不应该向容器收费。此外，容器用户无法获得容器内引发的异常的核心转储信息。因此，一种可能的方法是通过区分容器上下文禁用所有潜在的日志记录或记录活动。完全解决这个问题的另一种方法是构建一个额外的cgroup子系统，专门用于日志记录。所有日志记录活动都将由新的日志记录cgroup子系统进行记录。 最后，有些问题即使使用细粒度的会计机制也无法解决。例如，虽然当前的cgroups机制清楚地提到回写工作负载不被计算在内，但Linux内核维护者已经开始开发新的cgroup机制(即cgroup v2)，它利用内存和blkio子系统来跟踪回写并为脏页的容器收费。然而，恶意容器可以在不生成任何I&#x2F;O工作负载的情况下继续调用sync。回写工作负载由具有I&#x2F;O操作的容器承担，而不是由恶意容器承担。同时，向调用数据同步的容器收取所有费用是不公平的。由于简单地禁用所有这些功能将不可避免地影响可用性，一个潜在可行的解决方案是对这些敏感操作施加速率限制。 RELATED WORK在本节中，我们调查了一些启发我们工作的研究工作，并强调了我们的工作与以往研究之间的差异。我们主要讨论以下两个方面的研究工作: Virtual Machine and Container虽然VM已经迎来了云计算时代，但尽管进行了大量的研究工作，其性能仍然不能令人满意。容器正变得越来越流行，因为它提供了一种启用轻量级虚拟化的替代方式，并允许在容器中运行的应用程序完全兼容。因此，研究人员对硬件虚拟化和容器之间的性能比较很好奇。Felter等人表明，通过使用一组涵盖CPU、内存、存储和网络资源的基准测试，Docker在所有情况下都可以实现比KVM更高的性能。 Spoiala等还证明了Docker优于KVM，并且可以使用Kurento Media Server来测试WebRTC服务器的性能，从而支持实时应用程序。Morabito et al进一步比较了传统hypervisor(例如KVM)和os级虚拟化(包括Docker和LXC)在计算、存储、内存和网络方面的性能，并观察到磁盘I&#x2F;O仍然是KVM hypervisor的瓶颈。所有这些工作都表明，基于容器的操作系统级虚拟化是比传统的基于vm的硬件虚拟化更有效的解决方案。虽然以前的大多数研究工作都集中在理解容器的性能上，但很少有人试图调查底层内核机制的资源共享的有效性。我们是第一批系统地研究由Cgroup不足引起的容器的性能和资源核算问题的人。 Container security除了性能，容器的安全性也受到了学术界和业界的广泛关注。Gupta首先简要介绍了Docker安全性。Bui从隔离和相应的内核安全机制方面对Docker容器进行了分析。虽然之前的工作声称Docker容器在默认配置下是相当安全的，但Lin等人发现，大多数现有的漏洞都可以通过默认配置成功地从容器内部发起攻击。Grattafiori等人总结了容器的各种潜在漏洞，包括基于内存的伪文件系统中的问题。Gao等人进一步对基于内存的伪文件系统由于namespace问题而产生的潜在安全影响进行了系统研究。Lei等人提出了一种名为SPEAKER的容器安全机制，以减少对应用程序的可用系统调用数量。Sun等人开发了两个安全命名空间，为容器实现自主安全控制，Arnautov等人提出使用Intel SGX保护Linux容器。 错误配置的能力也可以被利用来建立容器中的秘密通道。我们在cgroup方面的工作进一步补充了以前的的研究工作。 Cloud SecurityCo-residence大量的研究工作也致力于理解云的安全问题，特别是不同租户共享相同计算基础设施的多租户云。在多租户云环境中，攻击者可以将恶意虚拟机与目标虚拟机共同驻留在同一台服务器上，然后发起包括侧通道和隐蔽通道攻击在内的各种攻击。同时，侧面攻击和隐蔽通道攻击是验证同一物理服务器上共存的常用方法。例如，基于缓存的隐蔽通道被广泛采用，因为多个实例共享同一个包上的最后一级缓存。Zhang等人进一步论证了在云上发起真实侧通道攻击的可行性。除了基于缓存的通道，其他方法如内存总线、内存重复数据删除、核心温度也可以有效地构建隐蔽通道。 虽然也提出了多种防御机制，但之前的两项工作表明，在现有的主流云服务中实现合住仍然是可行的(而且成本低廉)。Wang等人对三种无服务器计算服务进行了大规模的测量研究，发现了几个资源核算问题，租户可能会滥用这些问题来运行额外的工作负载。 Denial-of-Service attacks由于底层计算资源在不同的租户之间共享，因此争用是不可避免的。Varadarajan等人提出了资源释放攻击来释放受害者使用的资源，这样攻击者的实例就可以获得额外的利用。Zhang等人调查了内存DoS攻击的影响，并表明恶意云客户可以对电子商务网站造成38倍的延迟。对于针对I&#x2F;O性能的DoS攻击，Huang等提出了级联性能攻击，以耗尽hypervisor的I&#x2F;O处理能力。此外，多种攻击试图耗尽共享的基础设施资源，如电力设施，从而迫使数据中心的服务器关闭。与之前的工作不同，我们的工作表明，cgroups中的不足也可以被利用来在多租户容器环境中发起多次攻击。 CONCLUSION在本文中，我们开发了一套策略来打破Linux控制组的资源控制。我们证明了通过进程创建继承的cgroups限制并不总是保证一致和公平的资源核算。我们可以通过与原始cgroup解关联的进程来生成带外工作负载。 我们进一步提出了五个案例研究，表明在Docker容器环境中实现这些攻击是可行的。恶意容器利用多租户容器环境中cgroups的这些不足，可以极大地耗尽主机的资源，并发起多种攻击，包括拒绝服务攻击、资源释放攻击和秘密通道攻击。我们在亚马逊EC2云中的本地测试平台和专用服务器上进行了实验，并证明了一个容器可以将其工作负载放大200倍以上，并将其他容器的性能降低95%。 MyCase 1Linux 内核为各种异常提供了专用的异常处理程序。这些异常处理程序分为两类：错误和陷阱。错误是指程序在运行过程中遇到的问题，如分段错误。陷阱是指程序主动触发的事件，如溢出检测。 在处理这些异常时，内核维护了一个名为中断描述符表（IDT）的数据结构。IDT 包含每个异常处理程序的地址。当 CPU 在用户模式下引发异常时，相应的处理程序将在内核模式下运行。 寄存器保存和上下文切换：当异常发生时，处理器首先将当前的寄存器状态保存到内核堆栈中。这样，在异常处理完成后，处理器可以恢复原始状态并返回到用户模式。 异常处理：在内核模式下，处理器会根据异常类型调用相应的处理程序。异常处理程序通常会执行一些特定的操作，如清理资源、记录错误信息等。在处理异常时，整个过程将在内核空间和触发异常的进程上下文中运行。因此，异常处理期间消耗的资源将被计入相应的 cgroups。 信号处理和内核转储：异常处理程序可能会终止初始进程，并向其发送一个信号。这些信号会触发内核转储功能，生成一个用于调试的内核转储文件。在 Linux 内核中，核心转储代码通过 usermode 辅助 API 调用一个用户空间的应用程序来完成这个任务。 用户空间核心转储程序：在 Ubuntu 中，默认的用户空间核心转储程序是 Apport，它会在每个异常情况下被触发。Apport 的资源消耗不会由容器承担，因为它是由内核线程创建的，而不是由容器化的进程创建的。 负载平衡和资源放大：内核会将新生成的 Apport 实例调度到所有可用的 CPU 核心上，以实现负载平衡。这会导致打破 cpusets cgroup 的约束。同时，由于 Apport 进程比轻量级的异常处理（即内核控制路径）消耗更多资源，如果容器不断触发异常，整个 CPU 可能会被 Apport 进程占满。这种情况导致了分配给容器的系统资源的放大。 总结一下，当用户程序触发异常时，Linux 内核会通过 IDT 找到相应的处理程序，并在内核模式下运行。处理程序可能会终止进程并触发内核转储功能。在 Ubuntu 中，这会调用用户空间的 Apport 程序来生成内核转储文件。Apport 的资源消耗不会由容器承担，但可能导致资源放大和 cpusets cgroup 的约束被打破。 当你在使用电脑时，有时会遇到一些问题，比如程序出错或者意外停止运行。这些问题通常是由于程序中的异常引起的。在 Linux 系统中，有一套专门处理这些异常的机制。 想象一下，当程序遇到异常时，就像一个球员在比赛中受伤了。这时，教练（内核）会派上另一个球员（异常处理程序）来处理这个问题。这个过程发生在球场内（内核空间），并且会记录下这个问题发生的原因。 在处理异常时，教练需要确保其他球员不受影响。因此，教练会将受伤球员的状态保存起来，等问题处理完后再恢复。这个过程就像是在现场给受伤球员做紧急处理。 有时，这个问题严重到需要告知其他人（发送信号）。在这种情况下，教练会通知医疗团队（Apport 程序）来处理。医疗团队会把受伤球员的情况记录下来（生成内核转储文件），以便在之后分析和处理。 需要注意的是，医疗团队（Apport）处理问题时所消耗的资源不会影响球队（容器），但有时他们的处理可能会让整个比赛（系统资源）受到影响，导致其他球员的表现受到一定程度的影响。 总之，当电脑遇到问题时，Linux 系统会通过一套内核机制来处理这些异常。在处理过程中，可能会涉及到一些额外的程序，如 Apport，在确保不影响其他程序运行的前提下，记录和处理异常。 Case 2 磁盘数据同步回写机制：这是一种性能优化策略，使CPU只将更新后的数据写入缓存，而不是直接写入磁盘。当缓存被清除时，数据才会写入磁盘。这种机制通过将启动I&#x2F;O进程与同步磁盘写入进程解耦来提高性能。 同步：同步是将缓存中的数据写回磁盘的过程。这可以通过多种方法触发，例如定期回写、内存不足，或者通过用户进程故意调用系统调用（如sync、syncfs和fsync）。这些系统调用对Linux容器是可用的。 利用同步的攻击：由于同步允许进程将所有脏缓冲区写回磁盘，因此在同步期间，任何I&#x2F;O操作都必须等待。这可以被恶意进程利用，通过重复调用sync，以减慢整个系统的I&#x2F;O性能、发起无资源攻击，甚至建立秘密通道。 绕过cgroup：cgroup是一种用于限制资源使用的机制，但由于同步操作是在内核线程中进行的，并且调用sync的容器没有I&#x2F;O工作负载，因此cgroup无法限制同步操作。在这种情况下，即使使用blkio cgroup子系统对运行同步的容器应用I&#x2F;O控制，仍然无法减少同步的影响。这是因为blkio控制器仅限制相对I&#x2F;O吞吐量，而不是绝对值。此外，Docker的统计工具显示，调用sync的容器的I&#x2F;O吞吐量为零，这意味着blkio限制不起作用。 这个案例讲述了一个关于磁盘数据同步的技术，它叫做懒惰回写（lazy write-back）。这种技术的主要优点是提高电脑的性能。当我们在电脑上做一些改动时，这些改动首先会被保存在缓存中，而不是直接写入磁盘。只有当缓存被清空时，改动才会真正地被保存到磁盘里。这样的操作可以节省时间，因为写入磁盘的速度往往比写入缓存慢。 这种技术可以让一个攻击者绕过cgroups的限制。cgroups是一种用于限制程序在电脑上使用的资源的技术。简单来说，攻击者可以通过触发数据同步，让电脑的整体性能下降。这就像是在公路上开车，突然有人打开了所有的红绿灯，导致所有的车辆都必须停下来等待。 懒惰回写的关键在于同步（sync）。同步是一个过程，它会把缓存里的数据写入磁盘。当一个程序调用同步时，它会让电脑暂停其他操作，等待数据写入磁盘。如果一个攻击者不断地调用同步，那么电脑的性能就会受到影响，因为其他程序需要不断地等待同步完成。 现在我们来谈谈cgroups。cgroups是一种技术，可以用来限制程序使用电脑上的资源，比如CPU、内存和磁盘等。但是，在这个案例中，攻击者利用同步绕过了cgroups的限制。原因是，攻击者调用同步时，并没有直接进行磁盘读写操作，而是让内核（电脑的核心部分）进行了这些操作。因此，cgroups无法检测到攻击者的行为，也就无法限制它。 总之，这个案例向我们展示了一个攻击者可以利用懒惰回写的同步机制来绕过cgroups的限制。这可能会导致电脑的整体性能下降，给其他用户带来麻烦。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"内核安全","slug":"内核安全","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}]},{"title":"C++学习 函数高级","slug":"C++-学习-函数高级","date":"2023-04-15T00:36:52.000Z","updated":"2023-05-09T08:10:51.058Z","comments":true,"path":"2023/04/15/C++-学习-函数高级/","link":"","permalink":"http://example.com/2023/04/15/C++-%E5%AD%A6%E4%B9%A0-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7/","excerpt":"函数默认参数在C++中，函数形参列表中的形参是可以有默认值的 语法：返回值类型 函数名 （参数 = 默认值）","text":"函数默认参数在C++中，函数形参列表中的形参是可以有默认值的 语法：返回值类型 函数名 （参数 = 默认值） 1234567891011#include &lt;iostream&gt;using namespace std;int func(int a, int b = 20, int c = 3)&#123; return a + b + c;&#125;int main()&#123; cout &lt;&lt; func(10) &lt;&lt; endl; cout &lt;&lt; func(10, 30) &lt;&lt; endl;&#125; 运行结果如下： 60 70 注意事项 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值 声明和实现只能有一个有默认参数 12345678910#include &lt;iostream&gt;using namespace std;int func(int a = 10, int b = 10);int func(int a = 10, int b = 10) &#123; return a + b;&#125;int main()&#123; cout &lt;&lt; func() &lt;&lt; endl;&#125; 运行结果为： 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用参数时必须填补该位置 语法：返回值类型 函数名 (数据类型)&#123;&#125; 1234567891011#include &lt;iostream&gt;using namespace std;void func(int a, int)&#123; cout &lt;&lt; 1 &lt;&lt; endl; return;&#125;int main()&#123; func(10, 10);&#125; 或者 1234567891011#include &lt;iostream&gt;using namespace std;void func(int a, int = 10)&#123; cout &lt;&lt; 1 &lt;&lt; endl; return;&#125;int main()&#123; func(10);&#125; 函数重载函数重载概述作用：函数名可以相同，提高复用性 函数重载满足条件： 同一个作用域下 函数名称相同 函数参数类型不同或者个数不同或者顺序不同 注意：函数的返回值不可以作为函数重载的条件 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;void func()&#123; cout &lt;&lt; &quot;func()&quot; &lt;&lt; endl; return;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl; return;&#125;void func(int a,int b)&#123; cout &lt;&lt; &quot;func(int a,int b)&quot; &lt;&lt; endl; return;&#125;void func(int a,double b)&#123; cout &lt;&lt; &quot;func(int a,double b)&quot; &lt;&lt; endl; return;&#125;void func(double a,int b)&#123; cout &lt;&lt; &quot;func(double a,int b)&quot; &lt;&lt; endl; return;&#125;int main()&#123; func(); func(1); func(1, 2); func(1, 3.1); func(3.1, 1);&#125; 运行结果为： func()func(int a)func(int a,int b)func(int a,double b)func(double a,int b) 函数重载注意事项 引用作为函数重载条件 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void func(int &amp;a)&#123; cout &lt;&lt; &quot;func(int &amp;a)&quot; &lt;&lt; endl; return;&#125;void func(const int &amp;a)&#123; cout &lt;&lt; &quot;func(const int &amp;a)&quot; &lt;&lt; endl; return;&#125;int main()&#123; int a = 10; func(a); func(10);&#125; 运行结果为： func(int &amp;a)func(const int &amp;a) 函数重载碰到默认参数 12345678910111213141516#include &lt;iostream&gt;using namespace std;void func(int a, int b = 10)&#123; cout &lt;&lt; &quot;func(int a, int b = 10)&quot; &lt;&lt; endl;&#125;void func(int a)&#123; cout &lt;&lt; &quot;func(int a)&quot; &lt;&lt; endl;&#125;int main()&#123; func(10);&#125; 运行结果为：","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture05 Calling conventions and stack frames RISC-V(TA)","slug":"MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA","date":"2023-04-14T07:14:27.000Z","updated":"2023-04-20T06:13:23.446Z","comments":true,"path":"2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/","link":"","permalink":"http://example.com/2023/04/14/MIT6-S081-Operating-System-Engineering-Lecture05-Calling-conventions-and-stack-frames-RISC-V-TA/","excerpt":"C程序到汇编程序的转换当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。 所以通常来说，要让C语言能够运行在你的处理器之上。我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。","text":"C程序到汇编程序的转换当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。 所以通常来说，要让C语言能够运行在你的处理器之上。我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。 如果你们曾经注意过你们的lab目录，在运行完make qemu之后你会看到一些.o文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些.asm文件，这是由C语言编译生成的。 汇编语言不具备C语言的组织结构，在汇编语言中你只能看到一行行的指令，比如add，mult等等。汇编语言中没有很好的控制流程，没有循环（注，但是有基于lable的跳转），虽然有函数但是与你们知道的C语言函数不太一样，汇编语言中的函数是以label的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如C++，都会编译成汇编语言。运行任何编译型语言之前都需要先生成汇编语言。 以上就是让计算机能够理解我们的C代码的基本流程。 RISC-V vs X86RISC-V和x86并没有它们第一眼看起来那么相似。RISC-V中的RISC是精简指令集（Reduced Instruction Set Computer）的意思，而x86通常被称为CISC，复杂指令集（Complex Instruction Set Computer）。这两者之间有一些关键的区别： 首先是指令的数量。实际上，创造RISC-V的一个非常大的初衷就是因为Intel手册中指令数量太多了。x86-64指令介绍由3个文档组成，并且新的指令以每个月3条的速度在增加。因为x86-64是在1970年代发布的，所以我认为现在有多于15000条指令。RISC-V指令介绍由两个文档组成。在这节课中，不需要你们记住每一个RISC-V指令，但是如果你感兴趣或者你发现你不能理解某个具体的指令的话，在课程网站的参考页面有RISC-V指令的两个文档链接。这两个文档包含了RISC-V的指令集的所有信息，分别是240页和135页，相比x86的指令集文档要小得多的多。这是有关RISC-V比较好的一个方面。所以在RISC-V中，我们有更少的指令数量。 除此之外，RISC-V指令也更加简单。在x86-64中，很多指令都做了不止一件事情。这些指令中的每一条都执行了一系列复杂的操作并返回结果。但是RISC-V不会这样做，RISC-V的指令趋向于完成更简单的工作，相应的也消耗更少的CPU执行时间。这其实是设计人员的在底层设计时的取舍。并没有一些非常确定的原因说RISC比CISC更好。它们各自有各自的使用场景。 相比x86来说，RISC另一件有意思的事情是它是开源的。这是市场上唯一的一款开源指令集，这意味着任何人都可以为RISC-V开发主板。RISC-V是来自于UC-Berkly的一个研究项目，之后被大量的公司选中并做了支持，网上有这些公司的名单，许多大公司对于支持一个开源指令集都感兴趣。 比如说ARM也是一个精简指令集，高通的Snapdragon处理器就是基于ARM。如果你使用一个Android手机，那么大概率你的手机运行在精简指令集上。如果你使用IOS，苹果公司也实现某种版本的ARM处理器，这些处理器运行在iPad，iPhone和大多数苹果移动设备上，甚至对于Mac，苹果公司也在尝试向ARM做迁移（注，刚刚发布的Macbook）。所以精简指令集出现在各种各样的地方。如果你想在现实世界中找到RISC-V处理器，你可以在一些嵌入式设备中找到。所以RISC-V也是有应用的，当然它可能没有x86那么流行。 在最近几年，由于Intel的指令集是在是太大了，精简指令集的使用越来越多。Intel的指令集之所以这么大，是因为Intel对于向后兼容非常看重。所以一个现代的Intel处理器还可以运行30&#x2F;40年前的指令。Intel并没有下线任何指令。而RISC-V提出的更晚，所以不存在历史包袱的问题。我们需要许多指令来实现向后兼容，向后兼容是否重要因人而异。另一方面，我认为这里许多指令都是cmd指令，用来完成一些特殊的操作。我从来没有见过一个Intel的汇编代码使用了所有的15000个指令。大多数这些指令都是为了向后兼容和cmd的需求创建。 如果查看RISC-V的文档，可以发现RISC-V的特殊之处在于：它区分了Base Integer Instruction Set和Standard Extension Instruction Set。Base Integer Instruction Set包含了所有的常用指令，比如add，mult。除此之外，处理器还可以选择性的支持Standard Extension Instruction Set。例如，一个处理器可以选择支持Standard Extension for Single-Precision Float-Point。这种模式使得RISC-V更容易支持向后兼容。 每一个RISC-V处理器可以声明支持了哪些扩展指令集，然后编译器可以根据支持的指令集来编译代码。 gdb和汇编代码执行这部分还不太会操作 RISC-V寄存器 这个表里面是RISC-V寄存器。寄存器是CPU或者处理器上，预先定义的可以用来存储数据的位置。寄存器之所以重要是因为汇编代码并不是在内存上执行，而是在寄存器上执行，也就是说，当我们在做add，sub时，我们是对寄存器进行操作。所以我们通常看到的汇编代码中的模式是，我们通过load将数据存放在寄存器中，这里的数据源可以是来自内存，也可以来自另一个寄存器。之后我们在寄存器上执行一些操作。如果我们对操作的结果关心的话，我们会将操作的结果store在某个地方。这里的目的地可能是内存中的某个地址，也可能是另一个寄存器。这就是通常使用寄存器的方法。 寄存器进行任何运算和数据读取的最快的方式。当调用函数时，我们调用函数时，我们会用ABI名字。 a0到a7寄存器是用来作为函数的参数。如果一个函数有超过8个参数，我们就需要用内存了。从这里也可以看出，当可以使用寄存器的时候，我们不会使用内存，我们只在不得不使用内存的场景才使用它。 表单中的第4列，Saver列，当我们在讨论寄存器的时候也非常重要。它有两个可能的值Caller，Callee。 Caller Saved寄存器在函数调用的时候不会保存 Callee Saved寄存器在函数调用的时候会保存 这里的意思是，一个Caller Saved寄存器可能被其他函数重写。假设我们在函数a中调用函数b，任何被函数a使用的并且是Caller Saved寄存器，调用函数b可能重写这些寄存器。我认为一个比较好的例子就是Return address寄存器（注，保存的是函数返回的地址），你可以看到ra寄存器是Caller Saved，这一点很重要，它导致了当函数a调用函数b的时侯，b会重写Return address。所以基本上来说，任何一个Caller Saved寄存器，作为调用方的函数要小心可能的数据可能的变化；任何一个Callee Saved寄存器，作为被调用方的函数要小心寄存器的值不会相应的变化。 Stack每一次我们调用一个函数，函数都会为自己创建一个Stack Frame，并且只给自己用。函数通过移动Stack Pointer来完成Stack Frame的空间分配。 对于Stack来说，是从高地址开始向低地址使用。所以栈总是向下增长。当我们想要创建一个新的Stack Frame的时候，总是对当前的Stack Pointer做减法。一个函数的Stack Frame包含了保存的寄存器，本地变量，并且，如果函数的参数多于8个，额外的参数会出现在Stack中。所以Stack Frame大小并不总是一样，即使在这个图里面看起来是一样大的。不同的函数有不同数量的本地变量，不同的寄存器，所以Stack Frame的大小是不一样的。但是有关Stack Frame有两件事情是确定的： Return address总是会出现在Stack Frame的第一位 指向前一个Stack Frame的指针也会出现在栈中的固定位置 有关Stack Frame中有两个重要的寄存器，第一个是SP（Stack Pointer），它指向Stack的底部并代表了当前Stack Frame的位置。第二个是FP（Frame Pointer），它指向当前Stack Frame的顶部。因为Return address和指向前一个Stack Frame的的指针都在当前Stack Frame的固定位置，所以可以通过当前的FP寄存器寻址到这两个数据。 我们保存前一个Stack Frame的指针的原因是为了让我们能跳转回去。所以当前函数返回时，我们可以将前一个Frame Pointer存储到FP寄存器中。所以我们使用Frame Pointer来操纵我们的Stack Frames，并确保我们总是指向正确的函数。 Stack Frame必须要被汇编代码创建，所以是编译器生成了汇编代码，进而创建了Stack Frame。所以通常，在汇编代码中，函数的最开始你们可以看到Function prologue，之后是函数的本体，最后是Epollgue。 struct基本上来说，struct在内存中是一段连续的地址，如果我们有一个struct，并且有f1，f2，f3三个字段。当我们创建这样一个struct时，内存中相应的字段会彼此相邻。你可以认为struct像是一个数组，但是里面的不同字段的类型可以不一样。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"C++学习 引用","slug":"C++-学习-引用","date":"2023-04-14T01:25:57.000Z","updated":"2023-05-09T08:11:40.399Z","comments":true,"path":"2023/04/14/C++-学习-引用/","link":"","permalink":"http://example.com/2023/04/14/C++-%E5%AD%A6%E4%B9%A0-%E5%BC%95%E7%94%A8/","excerpt":"引用的基本使用作用：给变量起别名 语法：数据类型 &amp;别名 &#x3D; 原名","text":"引用的基本使用作用：给变量起别名 语法：数据类型 &amp;别名 &#x3D; 原名 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int&amp; b = a; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; b = 100; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; 运行结果为： a &#x3D; 10b &#x3D; 10a &#x3D; 100b &#x3D; 100 引用的注意事项 引用必须初始化 引用在初始化后，不可以改变 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int&amp; b = a; int c = 20; b = c; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;&#125; 运行结果为： a &#x3D; 20b &#x3D; 20c &#x3D; 20 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参 优点：可以简化指针修改实参 123456789101112131415161718#include &lt;iostream&gt;using namespace std;void swap(int&amp; a, int&amp; b)&#123; int temp = a; a = b; b = temp; cout &lt;&lt; &quot;swap a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap b = &quot; &lt;&lt; b &lt;&lt; endl;&#125;int main()&#123; int a = 10; int b = 20; swap(a, b); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;&#125; 运行结果为： swap a &#x3D; 20swap b &#x3D; 10a &#x3D; 20b &#x3D; 10 引用传递，形参会修饰实参 地址传递，形参会修饰实参 值传递，形参不会修饰实参 引用做函数返回值作用：引用是可以作为函数的返回值存在的 注意：不要返回局部变量引用 用法：函数调用作为左值 1234567891011121314#include &lt;iostream&gt;using namespace std;int&amp; test()&#123; static int a = 10; return a;&#125;int main()&#123; int&amp; ref = test(); cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl; test() = 1000; cout &lt;&lt; &quot;ref = &quot; &lt;&lt; ref &lt;&lt; endl;&#125; 运行结果如下： ref &#x3D; 10ref &#x3D; 1000 引用的本质本质：引用的本质是在C++内部实现一个指针常量 int&amp; ref = a;等价于int* const ref = a; ref = 20当编译器发现ref是引用，会自动帮我们解引用转换为*ref = 20 常量引用作用：常量引用主要用来修饰形参，防止误操作。 在函数形参列表中，可以加const 修饰形参，防止形参改变实参","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"《庄子 秋水》 阅读","slug":"《庄子-秋水》-阅读","date":"2023-04-12T11:43:59.000Z","updated":"2023-04-12T14:23:41.820Z","comments":true,"path":"2023/04/12/《庄子-秋水》-阅读/","link":"","permalink":"http://example.com/2023/04/12/%E3%80%8A%E5%BA%84%E5%AD%90-%E7%A7%8B%E6%B0%B4%E3%80%8B-%E9%98%85%E8%AF%BB/","excerpt":"秋水时至，百川灌河。泾流之大，两涘渚崖之间，不辩牛马。于是焉河伯欣然自喜，以天下之美为尽在己。顺流而东行，至于北海，东面而视，不见水端。于是焉河伯始旋其面目，望洋向若而叹曰：“野语有之曰：‘闻道百，以为莫己若者。’我之谓也。且夫我尝闻少仲尼之闻而轻伯夷之义者，始吾弗信。今我睹子之难穷也，吾非至于子之门则殆矣，吾长见笑于大方之家。”北海若曰：“井蛙不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。今尔出于崖涘，观于大海，乃知尔丑，尔将可与语大理矣。天下之水，莫大于海：万川归之，不知何时止而不盈；尾闾泄之，不知何时已而不虚；春秋不变，水旱不知。此其过江河之流， 不可为量数。而吾未尝以此自多者，自以比形于天地，而受气于阴阳， 吾在于天地之间，犹小石小木之在大山也。方存乎见少，又奚以自多！ 计四海之在天地之间也，不似礨空之在大泽乎？计中国之在海内不似稊米之在太仓乎？号物之数谓之万，人处一焉；人卒九州，谷食之所生，舟车之所通，人处一焉。此其比万物也，不似豪末之在于马体乎？ 五帝之所连，三王之所争，仁人之所忧，任士之所劳，尽此矣！伯夷辞之以为名，仲尼语之以为博。此其自多也，不似尔向之自多于水乎？” 秋汛时节，大大小小的河流都灌入黄河之中，河流水势浩大，两岸之间一片苍茫，分不清是牛是马在那里活动。于是河伯沾沾自喜，认为天下美景都掌握在自己手中。但河伯顺着水流往东走，到达了北海，面朝大海，望着无边无际的海面，他收起了得意的神情，他仰着头向北海若感叹道：听闻许多道理，认为谁都不如自己，说的就是我这种人。而且我曾听说有人小看仲尼的见识，轻视伯夷的义气，如今我终于是相信了，今天我看到这无边无际的大海，如果没有到您这来，我大概要永远贻笑大方了。北海若说：井底之蛙不可以跟他谈论大海，因为他受空间的限制；夏天的虫不可以跟他谈论冰雪，因为他受时间的限制；浅陋的书生不可以跟他谈论大道，以为他受礼教的限制。如今你从河边来到大海，见识到了大海的无边无际，明白了自己的浅陋，那我就可以跟你讲讲大道理了。天下的水域，没有比海洋更辽阔的了，千万条江河不停的汇聚到海洋，但是海洋永远不会满，海洋从尾闾泄水，但是不知道何时才能够流尽，不论是春天还是秋天，干旱还是洪涝，海洋都丝毫不受影响。海洋的容量，比江河不知道大了多少，但是我从来不认为自己了不起。我从天地那里获得了形体，从阴阳那里获得了生气，我在天地间，就像一颗小石头在泰山之上，只会自以为小，又怎么会自满呢。想象一下，四海在天地之间，不就像一个蚁穴在大泽之中吗？一个国家在四海之间，不就像一粒米在粮仓中吗？世间物种千千万万，人只是其中一种。人聚集在九州之内，播种谷物粮食，舟车四通八达，一个人只不过是其一小部分而已。拿人和万物相比，不就像拿马身上的一根毫毛和马相比吗？五帝所继承的，三王所争夺的，仁人所忧虑的，以天下为己任的人所操劳的，其实不过如此。伯夷辞让王位来获得名声，仲尼谈论天下大事以显示知识渊博，他们自以为了不起，不就像你一样吗？ 河伯曰：“然则吾大天地而小豪末，可乎？”北海若曰：“否。夫物，量无穷，时无止，分无常，终始无故。是故大知观于远近，故小而不寡，大而不多：知量无穷。证向今故，故遥而不闷，掇而不跂： 知时无止。察乎盈虚，故得而不喜，失而不忧：知分之无常也。明乎坦涂，故生而不说，死而不祸：知终始之不可故也。计人之所知，不若其所不知；其生之时，不若未生之时；以其至小，求穷其至大之域， 是故迷乱而不能自得也。由此观之，又何以知毫末之足以定至细之倪， 又何以知天地之足以穷至大之域！”","text":"秋水时至，百川灌河。泾流之大，两涘渚崖之间，不辩牛马。于是焉河伯欣然自喜，以天下之美为尽在己。顺流而东行，至于北海，东面而视，不见水端。于是焉河伯始旋其面目，望洋向若而叹曰：“野语有之曰：‘闻道百，以为莫己若者。’我之谓也。且夫我尝闻少仲尼之闻而轻伯夷之义者，始吾弗信。今我睹子之难穷也，吾非至于子之门则殆矣，吾长见笑于大方之家。”北海若曰：“井蛙不可以语于海者，拘于虚也；夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。今尔出于崖涘，观于大海，乃知尔丑，尔将可与语大理矣。天下之水，莫大于海：万川归之，不知何时止而不盈；尾闾泄之，不知何时已而不虚；春秋不变，水旱不知。此其过江河之流， 不可为量数。而吾未尝以此自多者，自以比形于天地，而受气于阴阳， 吾在于天地之间，犹小石小木之在大山也。方存乎见少，又奚以自多！ 计四海之在天地之间也，不似礨空之在大泽乎？计中国之在海内不似稊米之在太仓乎？号物之数谓之万，人处一焉；人卒九州，谷食之所生，舟车之所通，人处一焉。此其比万物也，不似豪末之在于马体乎？ 五帝之所连，三王之所争，仁人之所忧，任士之所劳，尽此矣！伯夷辞之以为名，仲尼语之以为博。此其自多也，不似尔向之自多于水乎？” 秋汛时节，大大小小的河流都灌入黄河之中，河流水势浩大，两岸之间一片苍茫，分不清是牛是马在那里活动。于是河伯沾沾自喜，认为天下美景都掌握在自己手中。但河伯顺着水流往东走，到达了北海，面朝大海，望着无边无际的海面，他收起了得意的神情，他仰着头向北海若感叹道：听闻许多道理，认为谁都不如自己，说的就是我这种人。而且我曾听说有人小看仲尼的见识，轻视伯夷的义气，如今我终于是相信了，今天我看到这无边无际的大海，如果没有到您这来，我大概要永远贻笑大方了。北海若说：井底之蛙不可以跟他谈论大海，因为他受空间的限制；夏天的虫不可以跟他谈论冰雪，因为他受时间的限制；浅陋的书生不可以跟他谈论大道，以为他受礼教的限制。如今你从河边来到大海，见识到了大海的无边无际，明白了自己的浅陋，那我就可以跟你讲讲大道理了。天下的水域，没有比海洋更辽阔的了，千万条江河不停的汇聚到海洋，但是海洋永远不会满，海洋从尾闾泄水，但是不知道何时才能够流尽，不论是春天还是秋天，干旱还是洪涝，海洋都丝毫不受影响。海洋的容量，比江河不知道大了多少，但是我从来不认为自己了不起。我从天地那里获得了形体，从阴阳那里获得了生气，我在天地间，就像一颗小石头在泰山之上，只会自以为小，又怎么会自满呢。想象一下，四海在天地之间，不就像一个蚁穴在大泽之中吗？一个国家在四海之间，不就像一粒米在粮仓中吗？世间物种千千万万，人只是其中一种。人聚集在九州之内，播种谷物粮食，舟车四通八达，一个人只不过是其一小部分而已。拿人和万物相比，不就像拿马身上的一根毫毛和马相比吗？五帝所继承的，三王所争夺的，仁人所忧虑的，以天下为己任的人所操劳的，其实不过如此。伯夷辞让王位来获得名声，仲尼谈论天下大事以显示知识渊博，他们自以为了不起，不就像你一样吗？ 河伯曰：“然则吾大天地而小豪末，可乎？”北海若曰：“否。夫物，量无穷，时无止，分无常，终始无故。是故大知观于远近，故小而不寡，大而不多：知量无穷。证向今故，故遥而不闷，掇而不跂： 知时无止。察乎盈虚，故得而不喜，失而不忧：知分之无常也。明乎坦涂，故生而不说，死而不祸：知终始之不可故也。计人之所知，不若其所不知；其生之时，不若未生之时；以其至小，求穷其至大之域， 是故迷乱而不能自得也。由此观之，又何以知毫末之足以定至细之倪， 又何以知天地之足以穷至大之域！” 河伯说：那么我以天地为大，以毫毛为小，这也可以吗？北海若说：不行，世间万物，在空间上是无法穷尽的，在时间上是没有止境的，不存在固定的区分，也不存在真正意义上的开始和结束。所以， 拥有大智慧的人，不以小为小，不以大为大，对于遥远的过去和将来，不会感到苦闷，对于切身体会的当下也不会刻意强求，有所得到也不会欣喜，有所失去也不会感到忧愁，因为变化是无常的。不会因为或者而雀跃，也不会因为死亡而悲恐，因为生死是无法解释的。一个人所知道的东西，远远比不上不知道的东西。一个人存活的时间，远远比不上未存活的时间。由试图用极小的事物来探究极大的范围，人们会变得迷惑不解，无法找到自己。从这个角度来看，我们怎么能知道一粒细微的尘埃足以决定最微妙的差别，又怎么能知道天地足以穷尽最大的范围呢？” 河伯曰：“世之议者皆曰：‘至精无形，至大不可围。’是信情乎 ？”北海若曰：“夫自细视大者不尽，自大视细者不明。夫精，小之微也；郛，大之殷也：故异便。此势之有也。夫精粗者，期于有形者也；无形者，数之所不能分也；不可围者，数之所不能穷也。可以言论者，物之粗也；可以意致者，物之精也；言之所不能论，意之所不能察致者，不期精粗焉。是故大人之行：不出乎害人，不多仁恩；动不为利，不贱门隶；货财弗争，不多辞让；事焉不借人，不多食乎力 ，不贱贪污；行殊乎俗，不多辟异；为在从众，不贱佞谄；世之爵禄 不足以为劝，戮耻不足以为辱；知是非之不可为分，细大之不可为倪 。闻曰：‘道人不闻，至德不得，大人无己。’约分之至也。” 河伯问：世上的人都说，最精细的东西没有形体，最宏大的东西没有外围，这是真的吗？北海若说：以小的视角去看大的东西是看不全面的，以大的视角去看小的东西是看不清楚的，所以各有所偏，精是指小而微妙的事物；郛是指大而深远的事物：所以它们是不同的。这是因为事物的规模和形态是有差异的。所谓精和粗是对于有形的东西来说的，无形的东西就是小到无法分辨了，没有外围的东西就是大到无法计算了。可以用语言表达的是粗大的事物，可以想象的是精微的食物。无法用语言表达也不能想象的，则根本不适用于精粗的概念。因此，大人的行为：不伤害他人，不过分施恩；行动不是为了利益，不轻视门下之人；不争夺财物，不过分言辞谦让；做事不依赖他人，不过分依赖自己的力量，不轻视贪污；行为不同于俗人，不过分追求与众不同；处在大众之中，不轻视奉承谄媚；世俗的荣誉和地位不足以激发他的兴趣，屈辱和耻辱不足以使他感到羞耻；懂得是非无法明确区分，大小无法确定边界。有句话说：‘道之人不可闻，至德不可得，大人无己。’这就是对事物极限的了解。” 河伯曰：“若物之外，若物之内，恶至而倪贵贱？恶至而倪小大？ ”北海若曰：“以道观之，物无贵贱；以物观之，自贵而相贱；以俗观之，贵贱不在己。以差观之，因其所大而大之，则万物莫不大；因其所小而小之，则万物莫不小。知天地之为稊米也，知毫末之为丘山也，则差数睹矣。以功观之，因其所有而有之，则万物莫不有； 因其所无而无之，则万物莫不无。知东西之相反而不可以相无，则功分定矣。以趣观之，因其所然而然之，则万物莫不然；因其所非而非 之，则万物莫不非。知尧、桀之自然而相非，则趣操睹矣。昔者尧、 舜让而帝，之、哙让而绝；汤、武争而王，白公争而灭。由此观之， 争让之礼，尧、桀之行，贵贱有时，未可以为常也。梁丽可以冲城而不可以窒穴，言殊器也；骐骥骅骝一日而驰千里，捕鼠不如狸狌，言殊技也；鸱鸺夜撮蚤，察毫末，昼出瞋目而不见丘山，言殊性也。故曰：盖师是而无非，师治而无乱乎？是未明天地之理，万物之情也。 是犹师天而无地，师阴而无阳，其不可行明矣！然且语而不舍，非愚则诬也！帝王殊禅，三代殊继。差其时，逆其俗者，谓之篡夫；当其时，顺其俗者，谓之义之徒。默默乎河伯，女恶知贵贱之门，小大之家！” 河伯问：在万物之外和万物之内，如何判断一件事物的贵贱和大小呢？北海若说：从大道的角度看，万物本无贵贱，从他物的角度看，都是自以为贵而以他物为贱，以世俗的角度看，贵贱不在自己，而在他人眼中，以差别的角度看，顺着大的一面来判断，则万物都是大的，顺着小的一面来判断，则万物都是小的。天地可以像一粒米一样小，毫毛也可以像一座山那么大。如果从万物的功能的角度看，如果以它们具有的功能来衡量，那么万物都有用，如果以它们没有的功能来衡量，那么万物都没有用。没有东就没有西，有和无相反相成，知道这一点，功能的区分也就明白了。如果从取向的一面去判断，如果顺着对的一面去判断，那么万物都是对的，如果顺着错的一面去判断，那么万物都是错的。就像尧、夏桀都认为自己是对的。尧、舜的禅让成为帝王，而燕王姬哙和燕相子之却因为禅让遭到灭顶之灾。商汤和周武王因为争夺而称王，白公胜却因为争斗而灭亡。从这些例子来看，争斗与禅让，尧和夏桀的行为，不能作为永恒的标准来衡量贵贱。攻城的利器不适用于堵塞小洞，这是因为器用不同。千里马可以一日千里，但捉老鼠不如狸狌，这是因为技能不同。猫头鹰虽然能在夜间捕捉跳蚤，看见秋毫之末，但是一到白天就会眼瞎，连山岳都看不到，这是因为秉性不同。人们总是说为什么不学习对的而抛弃错的，效法治世而抛弃乱世呢？这是不明白天地的道理、万物的实情才会说出的话。就像只接受天而不接受地，只接受阴而不接受阳，这显然是行不通的。帝王禅让还是继承，这是因时事而异。顺应时事和世俗，会被称为仁人义士，违背时事和世俗，会被称为大逆不道。沉默吧河伯，你哪知道怎么区分贵贱和大小。 河伯曰：“然则我何为乎？何不为乎？吾辞受趣舍，吾终奈何？” 北海若曰：“以道观之，何贵何贱，是谓反衍；无拘而志，与道大蹇 。何少何多，是谓谢施；无一而行，与道参差。严乎若国之有君，其无私德；繇繇乎若祭之有社，其无私福；泛泛乎其若四方之无穷，其无所畛域。兼怀万物，其孰承翼？是谓无方。万物一齐，孰短孰长？ 道无终始，物有死生，不恃其成。一虚一满，不位乎其形。年不可举 ，时不可止。消息盈虚，终则有始。是所以语大义之方，论万物之理也。物之生也，若骤若驰。无动而不变，无时而不移。何为乎，何不为乎？夫固将自化。” 河伯说：那么我应该做什么，不应该做什么呢？我应该接受什么，不应该接受什么呢？北海若说：从道的角度看，没有贵贱之分，要回归道的本源。要做到无拘无束，心怀大道，顺应大道。不要计较物质的多少，学会舍弃得失。要做到无私，无所谓长短，与道同在。要像国家有君王一样严肃，但要无私地行德。要像祭祀有社稷一样庄重，但要追求无私的福报。要像四方一样无边无际，没有界限。要包容万物，没有固定的方向，这就是无方。不要计较万物的短长，道是无始无终的，万物则有生有死，不依赖于成就。一切的虚实、盈虚都不受形态所限。时间不可挽留，此虚彼赢，此消彼长，这里结束那里就开始，事物产生后，如快马奔驰般急速变化，一刻也不会停止。所以应该做什么不应该做什么？事物本身就在不断变化着啊。 河伯曰：“然则何贵于道邪？”北海若曰：“知道者必达于理，达 于理者必明于权，明于权者不以物害己。至德者，火弗能热，水弗能溺，寒暑弗能害，禽兽弗能贼。非谓其薄之也，言察乎安危，宁于祸福，谨于去就，莫之能害也。故曰：‘天在内，人在外，德在乎天。 ’知天人之行，本乎天，位乎得，踯躅而屈伸，反要而语极。”曰： “何谓天？何谓人？”北海若曰：“牛马四足，是谓天；落马首，穿牛鼻，是谓人。故曰：‘无以人灭天，无以故灭命，无以得殉名。谨守而勿失，是谓反其真。‘“ 河伯说：那么大道有什么用呢？北海若说：知晓大道，就能通达事物的道理，通达事物的道理，就能懂得随机应变，懂得随机应变，也就不会让外物侵害自己。得到之人，火不能烧，水不能淹，寒暑不能侵扰，禽兽不能伤害。并不是说他能够对抗这些东西，而是说他懂得观察安慰，并能在福祸之中保持安稳的心态，能够谨慎的进退，也就没有什么能够伤害他们了。所以说：天道是内在的根源，人为是外在的表象，真正的德在于遵循天道，明白一切人事，本源是天道。了解天与人的规律，要遵循自然法则，找到恰当的位置，灵活适应各种情况，回归根本，探究极致。河伯问：什么是天？什么是人？北海若说：牛和马长了四条腿，这就是天道，把辔头装在马头，把牛鼻子穿孔，这就是认为。所以说：不能让人为破坏自然法则，不能让造作毁灭性命，不以贪欲追求虚名，守住自然的天性，这就叫做返回最初的本真。 夔怜蚿，蚿怜蛇，蛇怜风，风怜目，目怜心。夔谓蚿曰：“吾以一 足趻踔而不行，予无如矣。今子之使万足，独奈何？”蚿曰：“不然。 子不见夫唾者乎？喷则大者如珠，小者如雾，杂而下者不可胜数也。 今予动吾天机，而不知其所以然。”蚿谓蛇曰：“吾以众足行，而不及子之无足，何也？”蛇曰：“夫天机之所动，何可易邪？吾安用足 哉！”蛇谓风曰：“予动吾脊胁而行，则有似也。今子蓬蓬然起于北海，蓬蓬然入于南海，而似无有，何也？”风曰：“然，予蓬蓬然起于北海而入于南海也，然而指我则胜我，鰌我亦胜我。虽然，夫折大木，蜚大屋者，唯我能也。”故以众小不胜为大胜也。为大胜者，唯圣人能之。 独脚兽羡慕多足虫，多足虫羡慕蛇，蛇羡慕风，风羡慕眼，眼羡慕心。独脚兽跟多足虫说：我用一条腿走路都困难，你是怎么用那么多条腿走路的呢？多足虫说：我也是自然行走，我也不知道为什么这样。多足虫问蛇：我用这么多条腿走路结果还不如你不用腿走路走得快，为什么呢？蛇说：这是天然的机制，改变不了的，我哪用得着脚呢？蛇对风说：我用身体走路还有形迹，你呼呼从北海吹到南海，一点形迹也没有，为什么呢？风说：是的，我能呼呼的从北海吹到南海，但是手指脚踢我做不到啊。但是，吹断大树，吹翻房子只有我能做到。所以，以做不成众多小事为代价，成就大事，只有圣人能做到。 孔子游于匡，宋人围之数币，而弦歌不惙。子路入见，曰：“何夫子之娱也？”孔子曰：“来，吾语女！我讳穷久矣，而不免，命也；求通久矣，而不得，时也。当尧、舜而天下无穷人，非知得也；当桀、纣而天下无通人，非知失也。时势适然。夫水行不避蛟龙者，渔人之勇也。陆行不避兕虎者，猎夫之勇也。白刃交于前，视死若生者，烈士之勇也。知穷之有命，知通之有时，临大难而不惧者，圣人之勇也。由，处矣！吾命有所制矣！” 无几何，将甲者进，辞曰：“以为阳虎也，故围之；今非也，请辞而退。” 孔子周游到匡地，卫国人一层又一层地包围了他，可是孔子仍在不停地弹琴诵读。子路进去见孔子说：“先生如此快乐是为什么呢？”孔子说：“来，我告诉你！我不想让自己困苦已经很久很久了，可是始终不能免除，这是命运啊。我寻求通达也已经很久很久了，可是始终未能达到，这是时运啊。当尧、舜的时代，天下没有一个困顿潦倒的人，并非因为他们都才智超人；当桀、纣的时代，天下没有一个通达的人，并非因为他们都才智低下。这都是时运所造成的。在水里活动而不躲避蛟龙的，乃是渔夫的勇敢；在陆上活动而不躲避犀牛老虎的，乃是猎人的勇敢；刀剑交错地横于眼前，看待死亡犹如生还的，乃是壮烈之士的勇敢。懂得困厄潦倒乃是命中注定，知道顺利通达乃是时运造成，面临大难而不畏惧的，这就是圣人的勇敢。仲由啊，你还是休息去吧！我这是命中注定！” 公孙龙问于魏牟曰：“龙少学先王之道，长而明仁义之行；合同异 ，离坚白；然不然，可不可；困百家之知，穷众口之辩：吾自以为至 达已。今吾闻庄子之言，茫然异之。不知论之不及与？知之弗若与？ 今吾无所开吾喙，敢问其方。”公子牟隐机大息，仰天而笑曰：“子 独不闻夫埳井之蛙乎？谓东海之鳖曰：‘吾乐与！出跳梁乎井干之上， 入休乎缺甃之崖。赴水则接腋持颐，蹶泥则没足灭跗。还虷蟹与科斗， 莫吾能若也。且夫擅一壑之水，而跨跱埳井之乐，此亦至矣。夫子奚不时来入观乎？’东海之鳖左足未入，而右膝已絷矣。于是逡巡而却， 告之海曰：‘夫千里之远，不足以举其大；千仞之高，不足以极其深。 禹之时，十年九潦，而水弗为加益；汤之时，八年七旱，而崖不为加损。夫不为顷久推移，不以多少进退者，此亦东海之大乐也。’于是 埳井之蛙闻之，适适然惊，规规然自失也。且夫知不知是非之竟，而 犹欲观于庄子之言，是犹使蚊负山，商蚷驰河也，必不胜任矣。且夫 知不知论极妙之言，而自适一时之利者，是非埳井之蛙与？且彼方跐 黄泉而登大皇，无南无北，爽然四解，沦于不测；无东无西，始于玄冥，反于大通。子乃规规然而求之以察，索之以辩，是直用管窥天， 用锥指地也，不亦小乎？子往矣！且子独不闻夫寿陵余子之学于邯郸 与？未得国能，又失其故行矣，直匍匐而归耳。今子不去，将忘子之故，失子之业。”公孙龙口呿而不合，舌举而不下，乃逸而走。 公孙龙向魏牟问道：“我年少的时候学习古代圣王的主张，长大以后懂得了仁义的行为；能够把事物的不同与相同合而为一，把一个物体的质地坚硬与颜色洁白分离开来；能够把不对的说成是对的，把不应认可的看作是合宜的；能够使百家智士困惑不解，能够使众多善辩之口理屈辞穷：我自以为是最为通达的了。如今我听了庄子的言谈，感到十分茫然。不知是我的论辩比不上他呢，还是我的知识不如他呢？现在我已经没有办法再开口了，冒昧地向你请教其中的道理。” 魏牟靠着几案深深地叹了口气，然后又仰头朝天笑着说：“你不曾听说过那浅井里的青蛙吗？井蛙对东海里的鳖说：‘我实在快乐啊！我跳跃玩耍于井口栏杆之上，进到井里便在井壁砖块破损之处休息。跳入水中井水漫入腋下并且托起我的下巴，踏入泥里泥水就盖住了我的脚背，回过头来看看水中的那些赤虫、小蟹和蝌蚪，没有谁能像我这样的快乐！再说我独占一坑之水、盘踞一口浅井的快乐，这也是极其称心如意的了。你怎么不随时来井里看看呢？’东海之鳖左脚还未能跨入浅井，右膝就已经被绊住。于是迟疑了一阵子之后又把脚退了出来，把大海的情况告诉给浅井的青蛙，说：‘千里的遥远，不足以称述它的大；千仞的高旷，不足于探究它的深。夏禹时代十年里有九年水涝，而海水不会因此增多；商汤的时代八年里有七年大旱，而岸边的水位不会因此下降。不因为时间的短暂与长久而有所改变，不因为雨量的多少而有所增减，这就是东海最大的快乐。’浅井之蛙听了这一席话，惊惶不安，茫然不知所措。再说你公孙龙的才智还不足以知晓是与非的境界，却还想去察悉庄子的言谈，这就像驱使蚊虫去背负大山，驱使马蚿虫到河水里去奔跑，必定是不能胜任的。而你的才智不足以通晓极其玄妙的言论，竟自去迎合那些一时的胜利，这不就像是浅井里的青蛙吗？况且庄子的思想主张正俯极黄泉登临苍天，不论南北，释然四散通达无阻，深幽沉寂不可探测；不论东西，起于幽深玄妙之境，返归广阔通达之域。你竟拘泥浅陋地用察视的办法去探寻它的奥妙，用论辩的言辞去索求它的真谛，这只不过是用竹管去窥视高远的苍天，用锥子去测量浑厚的大地，不是太渺小了吗！你还是走吧！而且你就不曾听说过那燕国寿陵的小子到赵国的邯郸去学习走步之事吗？未能学会赵国的本事，又丢掉了他原来的本领，最后只得爬着回去了。现在你还不尽快离开我这里，必将忘掉你原有的本领，而且也必将失去你原有的学业。” 公孙龙听了这一番话张大着口而不能合拢，舌头高高抬起而不能放下，于是快速地逃走了。 庄子钓于濮水。楚王使大夫二人往先焉，曰：“愿以境内累矣！” 庄子持竿不顾，曰：“吾闻楚有神龟，死已三千岁矣。王巾笥而藏之庙堂之上。此龟者，宁其死为留骨而贵乎？宁其生而曳尾于涂中乎？ ”二大夫曰：“宁生而曳尾涂中。”庄子曰：“往矣！吾将曳尾于涂中。” 惠子相梁，庄子往见之。或谓惠子曰：“庄子来，欲代子相。”于 是惠子恐，搜于国中三日三夜。庄子往见之，曰：“南方有鸟，其名 为鹓鹐，子知之乎？夫鹓鹐发于南海而飞于北海，非梧桐不止，非练 实不食，非醴泉不饮。于是鸱得腐鼠，鹓鹐过之，仰而视之曰：‘吓！’ 今子欲以子之梁国而吓我邪？” 庄子与惠子游于濠梁之上。庄子曰：“儵鱼出游从容，是鱼之乐也。” 惠子曰∶“子非鱼，安知鱼之乐？”庄子曰：“子非我，安知我不知 鱼之乐？”惠子曰“我非子，固不知子矣；子固非鱼也，子之不知鱼 之乐，全矣！”庄子曰：“请循其本。子曰‘汝安知鱼乐’云者，既 已知吾知之而问我。我知之濠上也。” 庄子在濮水边垂钓，楚王派遣两位大臣先行前往致意，说：“楚王愿将国内政事委托给你而劳累你了。” 庄子手把钓竿头也不回地说：“我听说楚国有一神龟，已经死了三千年了，楚王用竹箱装着它，用巾饰覆盖着它，珍藏在宗庙里。这只神龟，是宁愿死去为了留下骨骸而显示尊贵呢，还是宁愿活着在泥水里拖着尾巴呢？”两位大臣说：“宁愿拖着尾巴活在泥水里。”庄子说：“你们走吧！我仍将拖着尾巴生活在泥水里。” 惠子在梁国做宰相，庄子前往看望他。有人对惠子说：“庄子来梁国，是想取代你做宰相。”于是惠子恐慌起来，在都城内搜寻庄子，整整三天三夜。 庄子前往看望惠子，说：“南方有一种鸟，它的名字叫鹓，你知道吗？鹓从南海出发飞到北海，不是梧桐树它不会停息，不是竹子的果实它不会进食，不是甘美的泉水它不会饮用。正在这时一只鹞鹰寻觅到一只腐烂了的老鼠，鹓刚巧从空中飞过，鹞鹰抬头看着鹓，发出一声怒气：‘嚇’！如今你也想用你的梁国来怒叱我吗？” 庄子和惠子一道在濠水的桥上游玩。庄子说：“儵鱼游得多么悠闲自在，这就是鱼儿的快乐。”惠子说：“你不是鱼，怎么知道鱼的快乐？”庄子说：“你不是我，怎么知道我不知道鱼儿的快乐？”惠子说：“我不是你，固然不知道你；你也不是鱼，你不知道鱼的快乐，也是完全可以肯定的。”庄子说：“还是让我们顺着先前的话来说。你刚才所说的‘你怎么知道鱼的快乐’的话，就是已经知道了我知道鱼儿的快乐而问我，而我则是在濠水的桥上知道鱼儿快乐的。”","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"哲学","slug":"读书笔记/哲学","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%93%B2%E5%AD%A6/"}],"tags":[{"name":"哲学","slug":"哲学","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6/"},{"name":"庄子","slug":"庄子","permalink":"http://example.com/tags/%E5%BA%84%E5%AD%90/"},{"name":"道家","slug":"道家","permalink":"http://example.com/tags/%E9%81%93%E5%AE%B6/"}]},{"title":"C++学习 程序的内存模型","slug":"C++-学习-程序的内存模型","date":"2023-04-11T06:42:45.000Z","updated":"2023-05-09T08:10:31.000Z","comments":true,"path":"2023/04/11/C++-学习-程序的内存模型/","link":"","permalink":"http://example.com/2023/04/11/C++-%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"内存分区模型C++程序在执行时，将内存大方向划分为四个区域 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收","text":"内存分区模型C++程序在执行时，将内存大方向划分为四个区域 代码区：存放函数体的二进制代码，由操作系统进行管理 全局区：存放全局变量和静态变量以及常量 栈区：由编译器自动分配释放，存放函数的参数值，局部变量等 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收 内存四区的意义： 不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程 程序运行前在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 代码区： 存放CPU执行的机器指令 代码区是共享的，共享的目的是对于频繁执行的程序，只要在内存中有一份代码即可 代码区是只读的，使其只读的原因是防止程序意外的修改了它的指令 全局区： 全局变量和静态变量存放在此 该区域的数据在程序结束后由操作系统释放 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int g_a = 10;int g_b = 10;const int c_g_a = 10;const int c_g_b = 10;int main()&#123; int a = 10; int b = 10; static int s_a = 10; static int s_b = 10; const int c_a = 10; const int c_b = 10; cout &lt;&lt; &quot;局部变量a的地址&quot; &lt;&lt; (long long int)&amp;a&lt;&lt;endl; cout &lt;&lt; &quot;局部变量b的地址&quot; &lt;&lt; (long long int)&amp;b&lt;&lt;endl; cout &lt;&lt; &quot;全局变量g_a的地址&quot; &lt;&lt; (long long int)&amp;g_a&lt;&lt;endl; cout &lt;&lt; &quot;全局变量g_b的地址&quot; &lt;&lt; (long long int)&amp;g_b&lt;&lt;endl; cout &lt;&lt; &quot;静态变量s_a的地址&quot; &lt;&lt; (long long int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; &quot;静态变量s_b的地址&quot; &lt;&lt; (long long int)&amp;s_b &lt;&lt; endl; cout &lt;&lt; &quot;字符串常量Hello World的地址&quot; &lt;&lt; (long long int)&amp;&quot;Hello World&quot; &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_a的地址&quot; &lt;&lt; (long long int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; &quot;全局常量c_g_b的地址&quot; &lt;&lt; (long long int)&amp;c_g_b &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_a的地址&quot; &lt;&lt; (long long int) &amp; c_a &lt;&lt; endl; cout &lt;&lt; &quot;局部常量c_b的地址&quot; &lt;&lt; (long long int) &amp; c_b &lt;&lt; endl;&#125; 运行结果为： 局部变量a的地址145921079908局部变量b的地址145921079940全局变量g_a的地址140702441787392全局变量g_b的地址140702441787396静态变量s_a的地址140702441787400静态变量s_b的地址140702441787404字符串常量Hello World的地址140702441778224全局常量c_g_a的地址140702441778272全局常量c_g_b的地址140702441778276局部常量c_a的地址145921079972局部常量c_b的地址145921080004 程序运行后 栈区 由编译器自动分配释放存放函数的参数值（形参），局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 12345678910111213#include &lt;iostream&gt;using namespace std;int* func(int a)&#123; a = 10; return &amp;a;&#125;int main()&#123; int* p = func(1); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; 运行结果为： 10-226279312 堆区 由程序员分配释放，若程序员不释放，程序结束时由操作系统回收 在C++中主要利用new在堆区开辟内存 12345678910111213#include &lt;iostream&gt;using namespace std;int* func(int a)&#123; int* p = new int(10); return p;&#125;int main()&#123; int* p = func(1); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl;&#125; 运行结果为： 1010 new操作符C++中利用new操作符在堆区开辟数据 堆区开辟的数据，由程序员手动释放，释放利用操作符delete 语法：new 数据类型 利用new创建的数据，会返回该数据对应的类型的指针 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int* func()&#123; int* p = new int (10); return p;&#125;void test01()&#123; int* p = func(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; delete(p); cout &lt;&lt; *p &lt;&lt; endl;&#125;int main()&#123; test01();&#125; 运行结果为： 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void test02()&#123; int* arr = new int[10]; for (int i = 0; i &lt; 10; i++) &#123; arr[i] = i + 100; &#125; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125; delete[] arr;&#125;int main()&#123; test02();&#125; 运行结果为： 100101102103104105106107108109 delete之后，不能访问arr指针指向的内存，否则会发生跟上图一样的情况","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 结构体","slug":"C++-学习-结构体","date":"2023-04-10T07:42:49.000Z","updated":"2023-05-09T08:11:09.376Z","comments":true,"path":"2023/04/10/C++-学习-结构体/","link":"","permalink":"http://example.com/2023/04/10/C++-%E5%AD%A6%E4%B9%A0-%E7%BB%93%E6%9E%84%E4%BD%93/","excerpt":"结构体的基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 结构体的定义和使用","text":"结构体的基本概念结构体属于用户自定义的数据类型，允许用户存储不同的数据类型 结构体的定义和使用语法： struct 结构体名（结构体成员列表）； 通过结构体创建变量的方式有三种： struct 结构体名 变量名 struct 结构体名 变量名 &#x3D; {成员1值 ， 成员2值…} 定义结构体时顺便创建变量 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;s3;int main()&#123; struct student s1; s1.name = &quot;张三&quot;; s1.age = 15; s1.score = 100; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; s1.name &lt;&lt; &quot;年龄： &quot; &lt;&lt; s1.age &lt;&lt; &quot;成绩： &quot; &lt;&lt; s1.score &lt;&lt; endl; struct student s2 = &#123; &quot;李四&quot; , 16 , 90 &#125;; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; s2.name &lt;&lt; &quot;年龄： &quot; &lt;&lt; s2.age &lt;&lt; &quot;成绩： &quot; &lt;&lt; s2.score &lt;&lt; endl; s3.name = &quot;王五&quot;; s3.age = 17; s3.score = 85; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; s3.name &lt;&lt; &quot;年龄： &quot; &lt;&lt; s3.age &lt;&lt; &quot;成绩： &quot; &lt;&lt; s3.score &lt;&lt; endl;&#125; 运行结果如下： 姓名： 张三年龄： 15成绩： 100姓名： 李四年龄： 16成绩： 90姓名： 王五年龄： 17成绩： 85 结构体数组作用：将自定义的结构体放入到数组中方便维护 语法：struct 结构体 数组名[元素个数] &#x3D; { {} ， {} ，… ，{} } 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;int main()&#123; struct student stuArray[3] = &#123; &#123;&quot;张三&quot;,18,100&#125;, &#123;&quot;李四&quot;, 19, 90&#125;, &#123;&quot;王五&quot;, 20, 85&#125; &#125;; stuArray[2].name = &quot;赵六&quot;; stuArray[2].age = 15; stuArray[2].score = 95; for (int i = 0; i &lt; 3; i++) &#123; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; stuArray[i].name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; stuArray[i].age &lt;&lt; &quot; 分数： &quot; &lt;&lt; stuArray[i].score &lt;&lt; endl; &#125;&#125; 运行结果如下： 姓名： 张三 年龄： 18 分数： 100姓名： 李四 年龄： 19 分数： 90姓名： 赵六 年龄： 15 分数： 95 结构体指针作用：通过指针访问结构体中的成员 利用操作符 -&gt;可以通过结构体指针访问结构体属性 1234567891011121314#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;int main()&#123; struct student s = &#123; &quot;张三&quot; , 16 , 98 &#125;; struct student * p = &amp;s; cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数： &quot; &lt;&lt; p-&gt;score &lt;&lt; endl;&#125; 运行结果为： 姓名： 张三 年龄： 16 分数： 98 结构体嵌套结构体作用：结构体中的成员可以是另一个结构体 例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;struct teacher&#123; string name; int id; int age; struct student stu;&#125;;int main()&#123; struct teacher t; t.name = &quot;张三&quot;; t.id = 100; t.age = 45; t.stu.name = &quot;李四&quot;; t.stu.age = 16; t.stu.score = 100; cout &lt;&lt; &quot;老师的姓名：&quot; &lt;&lt; t.name &lt;&lt; &quot; 老师的id：&quot; &lt;&lt; t.id &lt;&lt; &quot; 老师的年龄：&quot; &lt;&lt; t.age &lt;&lt; endl; cout &lt;&lt; &quot;老师指导的学生的姓名：&quot; &lt;&lt; t.stu.name &lt;&lt; &quot; 学生的年龄： &quot; &lt;&lt; t.stu.age &lt;&lt; &quot; 学生的成绩：&quot; &lt;&lt; t.stu.score &lt;&lt; endl;&#125; 运行结果为： 老师的姓名：张三 老师的id：100 老师的年龄：45老师指导的学生的姓名：李四 学生的年龄： 16 学生的成绩：100 结构体做函数参数作用：将结构体作为参数向函数中传递 传递方式有两种： 值传递 地址传递 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;void PrintStu1(struct student s)&#123; s.name = &quot;李四&quot;; s.age = 19; s.score = 90; cout &lt;&lt; &quot;子函数1中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl;&#125;void PrintStu2(struct student* p)&#123; p-&gt;name = &quot;李四&quot;; p-&gt;age = 19; p-&gt;score = 90; cout &lt;&lt; &quot;子函数2中学生姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; &quot; 分数：&quot; &lt;&lt; p-&gt;score &lt;&lt; endl;&#125;int main()&#123; struct student s = &#123; &quot;张三&quot; , 16 , 100 &#125;; cout &lt;&lt; &quot;main函数中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl; PrintStu1(s); cout &lt;&lt; &quot;main函数中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl; PrintStu2(&amp;s); cout &lt;&lt; &quot;main函数中学生姓名：&quot; &lt;&lt; s.name &lt;&lt; &quot; 年龄：&quot; &lt;&lt; s.age &lt;&lt; &quot; 分数：&quot; &lt;&lt; s.score &lt;&lt; endl;&#125; 运行结果为： main函数中学生姓名：张三 年龄：16 分数：100子函数1中学生姓名：李四 年龄：19 分数：90main函数中学生姓名：张三 年龄：16 分数：100子函数2中学生姓名：李四 年龄：19 分数：90main函数中学生姓名：李四 年龄：19 分数：90 结构体中const的使用场景作用：用const来防止误操作 12345678910111213141516171819#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string name; int age; int score;&#125;;void PrintStu(const struct student * s)&#123; s-&gt;name = &quot;李四&quot;;&#125;int main()&#123; struct student s = &#123; &quot;张三&quot; , 16 , 100 &#125;; PrintStu(&amp;s);&#125; 结果如下： 程序报错，不能修改 结构体案例一案例描述：学校正在做毕设项目，每名老师带领五个学生，总共有三名老师，需求如下 设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放五名学生的数组作为成员 学生的成员有姓名、考试分数，创建数组存放三名老师，通过函数给每个老师及所带学生的学生数赋值 最终打印出老师数据以及老师所带学生的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct student &#123; string sname; int score;&#125;;struct teacher&#123; string tname; struct student stuArray[5];&#125;;void inAll(struct teacher * s)&#123; printf(&quot;请输入老师的姓名：&quot;); cin &gt;&gt; s-&gt;tname; for (int i = 0; i &lt; 5; i++) &#123; printf(&quot;\\n请输入第%d位同学的姓名和成绩&quot;,i+1); cin&gt;&gt;s-&gt;stuArray[i].sname&gt;&gt;s-&gt;stuArray[i].score; &#125;&#125;void outAll(struct teacher t)&#123; cout &lt;&lt; &quot;老师的姓名&quot; &lt;&lt; t.tname &lt;&lt; endl; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; &quot;学生&quot; &lt;&lt;i+1&lt;&lt;&quot;姓名为：&quot;&lt;&lt; t.stuArray[i].sname &lt;&lt; &quot; 成绩为：&quot; &lt;&lt; t.stuArray[i].score &lt;&lt; endl; &#125;&#125;int main()&#123; struct teacher tArray[3]; for (int i = 0; i &lt; 3; i++) &#123; inAll(&amp;tArray[i]); &#125; for (int i = 0; i &lt; 3; i++) &#123; outAll(tArray[i]); &#125;&#125; 运行结果如下： 请输入老师的姓名：老师1 请输入第1位同学的姓名和成绩学生11 90 请输入第2位同学的姓名和成绩学生12 90 请输入第3位同学的姓名和成绩学生13 80 请输入第4位同学的姓名和成绩学生14 79 请输入第5位同学的姓名和成绩学生15 98请输入老师的姓名：老师2 请输入第1位同学的姓名和成绩学生21 80 请输入第2位同学的姓名和成绩学生22 79 请输入第3位同学的姓名和成绩学生23 80 请输入第4位同学的姓名和成绩学生24 79 请输入第5位同学的姓名和成绩学生25 90请输入老师的姓名：老师3 请输入第1位同学的姓名和成绩学生31 90 请输入第2位同学的姓名和成绩学生32 89 请输入第3位同学的姓名和成绩学生33 79 请输入第4位同学的姓名和成绩学生34 80 请输入第5位同学的姓名和成绩学生35 98老师的姓名老师1学生1姓名为：学生11 成绩为：90学生2姓名为：学生12 成绩为：90学生3姓名为：学生13 成绩为：80学生4姓名为：学生14 成绩为：79学生5姓名为：学生15 成绩为：98老师的姓名老师2学生1姓名为：学生21 成绩为：80学生2姓名为：学生22 成绩为：79学生3姓名为：学生23 成绩为：80学生4姓名为：学生24 成绩为：79学生5姓名为：学生25 成绩为：90老师的姓名老师3学生1姓名为：学生31 成绩为：90学生2姓名为：学生32 成绩为：89学生3姓名为：学生33 成绩为：79学生4姓名为：学生34 成绩为：80学生5姓名为：学生35 成绩为：98 结构体案例二案例描述： 设计一个英雄的结构体，包括成员姓名，年龄，性别：创建结构体数组，数组中存放五名英雄。 通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include&lt;string&gt;using namespace std;struct Hero&#123; string name; int age; string sex;&#125;;int main()&#123; struct Hero heroArray[5] = &#123; &#123;&quot;刘备&quot;, 21, &quot;男&quot;&#125;, &#123; &quot;关羽&quot;,19,&quot;男&quot; &#125;, &#123; &quot;张飞&quot;,23,&quot;男&quot; &#125;, &#123; &quot;赵云&quot;,20,&quot;男&quot; &#125;, &#123; &quot;黄忠&quot;,18,&quot;男&quot; &#125; &#125;; int len = sizeof(heroArray) / sizeof(heroArray[0]); for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len; j++) &#123; if (heroArray[j+1].age &gt; heroArray[j].age) &#123; struct Hero temp = heroArray[j]; heroArray[j] = heroArray[j+1]; heroArray[j+1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; heroArray[i].name &lt;&lt; heroArray[i].age &lt;&lt; heroArray[i].sex &lt;&lt; endl; &#125;&#125; 运行结果如下： 张飞23男刘备21男赵云20男关羽19男黄忠18男","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"}]},{"title":"C++学习 指针","slug":"C++-学习-指针","date":"2023-04-09T05:57:28.000Z","updated":"2023-05-09T08:11:56.207Z","comments":true,"path":"2023/04/09/C++-学习-指针/","link":"","permalink":"http://example.com/2023/04/09/C++-%E5%AD%A6%E4%B9%A0-%E6%8C%87%E9%92%88/","excerpt":"指针基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址","text":"指针基本概念指针的作用： 可以通过指针间接访问内存 内存编号是从0开始记录的，一般用十六进制数字表示 可以利用指针变量保存地址 可以通过一个指针来保存一个地址 指针的定义和使用定义指针指针定义的语法： 数据类型 \\* 指针变量名 12345678910#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p; p = &amp;a; cout &lt;&lt; &quot;a的地址为&quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;指针p为&quot; &lt;&lt; p &lt;&lt; endl;&#125; 运行结果为： a的地址为00000087472FFC84指针p为00000087472FFC84 我们可以得到指针就是地址 使用指针可以通过解引用的方式来找到指针指向的内存 指针前加 *代表解引用 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p; p = &amp;a; cout &lt;&lt; &quot;a的地址为&quot; &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &quot;指针p为&quot; &lt;&lt; p &lt;&lt; endl; *p = 1000; cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;endl; cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;&#125; 运行结果为： a的地址为0000003F9953F7C4指针p为0000003F9953F7C4a &#x3D; 1000*p &#x3D; 1000 通过p找到a的内存，并且可以通过*p修改内存 指针所占内存空间指针也是一种数据类型，那么这种数据类型占用多少内存空间呢？ 在32位操作系统下：占用4个字节空间 在64位操作系统下：占用8个字节空间 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int* p = &amp;a; cout &lt;&lt; &quot;sizeof (p) = &quot; &lt;&lt; sizeof(p) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (int *) = &quot; &lt;&lt; sizeof(int *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (char *) = &quot; &lt;&lt; sizeof(char *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (float *) = &quot; &lt;&lt; sizeof(float *) &lt;&lt; endl; cout &lt;&lt; &quot;sizeof (double *) = &quot; &lt;&lt; sizeof(double *) &lt;&lt; endl;&#125; 运行结果为： sizeof (p) &#x3D; 8sizeof (int *) &#x3D; 8sizeof (char *) &#x3D; 8sizeof (float *) &#x3D; 8sizeof (double *) &#x3D; 8 因为指针是内存，所以不管是什么数据类型下，64位操作系统，指针都是占用8个字节空间大小 空指针和野指针空指针空指针：指针变量指向内存中为0的空间 用途：初始化指针变量 注意：空指针的内存是不可以访问的 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; int* p = NULL; *p = 100;&#125; 程序运行错误 0~255之间的内存编号是系统占用的，因此不可以访问 野指针野指针：指针变量指向一段非法的内存空间 1234567#include &lt;iostream&gt;using namespace std;int main()&#123; int* p = (int *)0x1100; cout &lt;&lt; *p &lt;&lt; endl;&#125; 程序运行错误 在程序中尽量避免野指针 const修饰指针const修饰指针有三种情况 const修饰指针 - 常量指针指针的指向可以修改，指针指向的值不能修改 1const int * p; const修饰常量 - 指针常量指针的指向不可以改，指针指向的值可以改 1int * const p; const既修饰指针，又修饰常量指针的指向不可以改，指针指向的值也不可以改 1const int * const p; 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 10; int b = 10; //1、const 修饰指针 常量指针 const int * p1 = &amp;a; //*p1 = 20 错误 p1 = &amp;b;//正确 //2、const 修饰常量 指针常量 int* const p2 = &amp;a; *p2 = 100;//正确 //p2 = &amp;b; 错误 //3、const 既修饰常量又修饰指针 const int * const p3 = &amp;a; //*p3 = 100 错误 //p3 = &amp;b 错误&#125; 指针和数组利用指针访问数组中的数据元素 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 ,10 &#125;; int* p = arr; cout &lt;&lt; &quot;第一个元素为：&quot; &lt;&lt; arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;指针访问第一个元素：&quot; &lt;&lt; *p &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; *p &lt;&lt; endl; p++; &#125;&#125; 运行结果为： 第一个元素为：1指针访问第一个元素：112345678910 指针和函数利用指针作为函数参数，可以修改实参的值 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;void swap01(int a, int b)&#123; int temp = a; a = b; b = temp; return ;&#125;void swap02(int* p1, int* p2)&#123; int temp = *p1; *p1 = *p2; *p2 = temp;&#125;int main()&#123; int a = 10; int b = 20; //1、值传递 swap01(a, b); cout &lt;&lt; &quot;swap01后a的值为&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap01后b的值为&quot; &lt;&lt; b &lt;&lt; endl; //2、地址传递 swap02(&amp;a, &amp;b); cout &lt;&lt; &quot;swap02后a的值为&quot; &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;swap02后b的值为&quot; &lt;&lt; b &lt;&lt; endl;&#125; 运行结果如下： swap01后a的值为10swap01后b的值为20swap02后a的值为20swap02后b的值为10 指针、数组、函数案例描述：封装一个函数，利用冒泡排序，实现对整型数组的升序排序 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;//冒泡排序函数void bubbleSort(int * arr, int len)&#123; for (int i = 0; i &lt; len - 1; i++) &#123; for (int j = 0; j &lt; len - i - 1; j++) &#123; //如果j&gt;j+1,交换数字 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;//打印数组void printArray(int* arr, int len)&#123; for (int i = 0; i &lt; len; i++) &#123; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;int main()&#123; //1、创建数组 int arr[10] = &#123;4 , 3 , 6 , 9 , 1 , 2 , 10 , 8 , 7 , 5&#125;; //数组长度 int len = sizeof(arr) / sizeof(arr[0]); //2、创建函数，实现冒泡排序 bubbleSort(arr, len); //3、打印排序后的数组 printArray(arr, len);&#125; 运行结果如下： 12345678910","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"指针","slug":"指针","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"}]},{"title":"学习路径","slug":"学习路径","date":"2023-04-08T12:15:26.000Z","updated":"2023-04-29T12:22:35.643Z","comments":true,"path":"2023/04/08/学习路径/","link":"","permalink":"http://example.com/2023/04/08/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/","excerpt":"Rust学习Rust的过程涉及多个阶段。这里提供了一个详细的Rust学习计划，帮助您逐步掌握这门语言： 1. 基础阶段","text":"Rust学习Rust的过程涉及多个阶段。这里提供了一个详细的Rust学习计划，帮助您逐步掌握这门语言： 1. 基础阶段 阅读《Rust编程语言》（The Rust Programming Language，又称”The Book”）：这是学习Rust的官方教材，为初学者提供了全面的入门知识。在线版本可免费访问：The Rust Programming Language - The Rust Programming Language 学习Rust的基本语法、数据类型、控制结构、错误处理等概念。 完成《The Book》中的示例和练习，以巩固所学知识。 参加Rust社区活动，如阅读论坛帖子、加入聊天室和邮件列表，以了解最新动态和获得帮助。 2. 实践阶段 尝试解决一些简单的编程问题，例如LeetCode上的题目，以熟悉Rust的编程范式。 阅读Rust编写的开源项目代码，学习他人如何使用Rust解决实际问题。 参与开源项目，为Rust生态做贡献。这可以帮助您熟悉实际项目中的编程实践、代码审查和协作流程。 开始实现自己的项目，将学到的知识应用于实践。可以从一个简单的命令行工具或Web服务开始。 3. 进阶阶段 深入了解Rust的所有权（Ownership）、借用（Borrowing）和生命周期（Lifetime）系统。这是理解Rust内存安全的关键。 学习Rust的并发和异步编程。掌握如何使用线程、通道、异步I&#x2F;O和async/await编写高性能、可扩展的Rust代码。 阅读Rust的官方文档，例如《Rust异步编程》（Asynchronous Programming in Rust）和《Rust标准库文档》（The Rust Standard Library Documentation），以深入了解各种概念和API。 学习Rust的宏（Macros）系统，了解如何编写DRY（Don’t Repeat Yourself）代码和元编程。 4. 专业阶段 探索Rust在不同领域的应用，例如Web开发、嵌入式系统、游戏开发、区块链等。 阅读有关Rust性能优化、安全性和最佳实践的文章和教程。 参加Rust会议和研讨会，与其他Rust开发者交流经验和技巧。 考虑投入到Rust生态系统的开发中，例如编写库、工具和框架，为社区提供贡献。 C++C++是一门功能强大的编程语言，学习过程可以分为多个阶段。以下是一份详细的C++学习计划，帮助您逐步掌握C++： 1. 基础阶段 阅读C++的经典教材，如《C++ Primer》(by Stanley B. Lippman, Josée Lajoie, and Barbara E. Moo) 或《C++程序设计原理与实践》（Programming: Principles and Practice Using C++, by Bjarne Stroustrup）。 学习C++的基本语法、数据类型、控制结构、函数、类和对象等概念。 练习编写简单的C++程序，巩固所学知识。 参加在线C++社区活动，如Stack Overflow和C++ subreddit，了解最新动态和获得帮助。 2. 实践阶段 学习使用C++标准库（STL），掌握容器、算法和迭代器等重要概念。 尝试解决一些实际编程问题，例如LeetCode上的题目，以熟悉C++编程范式。 阅读开源C++项目的代码，学习他人如何使用C++解决实际问题。 参与开源项目，为C++生态做贡献。这可以帮助您熟悉实际项目中的编程实践、代码审查和协作流程。 开始实现自己的项目，将学到的知识应用于实践。可以从一个简单的命令行工具或图形界面应用开始。 3. 进阶阶段 深入学习C++的高级特性，如模板、异常处理、智能指针、多态等。 学习C++的并发和多线程编程，掌握线程、互斥量、条件变量等概念。 阅读有关C++性能优化、内存管理和最佳实践的文章和教程。 学习C++11、C++14、C++17、C++20等新标准中的新特性，以便编写现代、高效的C++代码。 4. 专业阶段 探索C++在不同领域的应用，例如游戏开发、高性能计算、嵌入式系统等。 学习使用C++编写跨平台应用程序，使用诸如Qt等框架。 参加C++会议和研讨会，与其他C++开发者交流经验和技巧。 考虑投入到C++生态系统的开发中，例如编写库、工具和框架，为社区提供贡献。 云系统内核安全云系统内核安全是一个高度专业化的领域，涉及操作系统、虚拟化技术、硬件安全等多方面知识。以下是一份详细的云系统内核安全学习计划，帮助您逐步掌握相关知识： 1. 基础阶段 学习计算机组成原理和计算机体系结构，了解CPU、内存、IO设备等基本概念。 学习操作系统基础知识，如进程、线程、内存管理、文件系统、设备驱动等。 学习网络基础知识，掌握TCP&#x2F;IP协议栈、网络设备、网络安全等概念。 2. 虚拟化技术阶段 学习虚拟化技术的基本原理，了解全虚拟化和半虚拟化的区别。 学习常见的虚拟化平台，如VMware、KVM、Xen、Hyper-V等，了解它们的架构和特点。 学习容器技术，如Docker和Kubernetes，了解与虚拟机相比的优势和局限。 3. 云安全阶段 学习云计算的基本概念，了解IaaS、PaaS、SaaS等服务模型。 学习主流云服务提供商（如AWS、Azure、Google Cloud、阿里云等）的安全服务和最佳实践。 了解云安全的共享责任模型，学会在云环境中保护数据、网络、应用和用户的安全。 4. 内核安全阶段 深入学习操作系统内核，了解内核态和用户态的区别，学习内核编程。 学习内核漏洞的类型和原理，例如缓冲区溢出、竞争条件、提权漏洞等。 学习内核漏洞的利用技术，如ROP、堆喷射、内核地址泄露等。 学习内核安全防护技术，如内核地址随机化（KASLR）、内核代码只读（RO）、内存保护扩展（MPX）等。 5. 云系统内核安全阶段 学习虚拟化环境下的内核安全挑战，如虚拟机逃逸、共享资源攻击等。 学习容器环境下的内核安全挑战，如容器逃逸、资源隔离不足等。 学习硬件安全技术，如安全引导（Secure Boot）、可信计算（TPM）、英特尔SGX等。 学习云环境下的内核安全加固措施，如安全基线、监控、自动化补丁等。 6. 实践阶段 参与开源内核安全项目，为社区提供贡献。 阅读内核安全相关的研究论文和技术报告，了解最新的研究动态。 参加内核安全和云安全的会议和研讨会，与同行交流经验和技巧。 pwn学习网络安全和 “pwn” 技能需要时间和努力，但通过制定一个合理的计划，你可以逐步掌握所需的知识和技能。以下是一个建议的学习计划： 学习基础知识： 计算机科学基础：了解计算机系统的基本原理，学习编程语言（如 Python, C, Java 或 JavaScript）。 计算机网络：学习网络基本原理，如 OSI 模型、TCP&#x2F;IP 协议、路由和交换等。 操作系统：熟悉 Windows、Linux 和 macOS 等操作系统的原理和使用。 学习网络安全基础： 加密与解密：学习基本的密码学原理，如对称加密、非对称加密、哈希函数等。 系统安全：了解常见的系统漏洞，如缓冲区溢出、SQL 注入、跨站脚本等。 安全工具：熟悉常用的安全工具，如 Wireshark、Nmap、Metasploit 等。 掌握 Pwn 技能： 静态分析：学习使用反汇编和调试工具（如 IDA Pro、Ghidra、OllyDbg 等）分析程序。 动态分析：学习使用调试器（如 GDB、x64dbg 等）调试程序，了解程序运行时的状态。 漏洞挖掘：学习如何发现潜在漏洞，如内存泄漏、整数溢出、格式化字符串等。 漏洞利用：学习编写利用代码，如利用 ROP 技术绕过 DEP、使用堆喷射绕过 ASLR 等。 实践与进阶： 参加 CTF 比赛：参加 Capture The Flag（CTF）比赛，提高实战能力。 研究漏洞案例：分析已知的漏洞案例，了解漏洞发现和利用的具体过程。 学习安全研究论文：阅读网络安全领域的学术论文，跟踪最新技术和研究成果。 参与开源项目：参与网络安全相关的开源项目，如漏洞扫描器、安全框架等。 持续学习： 关注安全领域的新闻和动态：关注网络安全领域的新闻、博客、漏洞报告等。 参加安全会议：参加网络安全会议（如 DEFCON、Black Hat 等），了解最新的安全趋势和技术。 建立个人网络：加入网络安全社区，与同行交流，分享经验和技巧。","categories":[{"name":"学习路径","slug":"学习路径","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"}],"tags":[]},{"title":"Ubuntu源码 /proc/meminfo","slug":"学习 Ubuntu源码-proc-meminfo","date":"2023-04-06T06:56:58.000Z","updated":"2023-04-06T07:26:56.266Z","comments":true,"path":"2023/04/06/学习 Ubuntu源码-proc-meminfo/","link":"","permalink":"http://example.com/2023/04/06/%E5%AD%A6%E4%B9%A0%20Ubuntu%E6%BA%90%E7%A0%81-proc-meminfo/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253MemTotal: 3982192 kB 系统总内存大小MemFree: 333280 kB 系统中未使用的内存大小MemAvailable: 2062852 kB 系统中可供分配的内存大小，包括缓存和缓冲区Buffers: 149848 kB 用于文件I/O的临时存储区域的大小Cached: 1762576 kB 被操作系统缓存的文件大小SwapCached: 356 kB 已被交换且在内存中的数据大小Active: 1183472 kB 正在使用或最近被使用过的内存大小Inactive: 1406216 kB 最近没有被使用的内存大小Active(anon): 2988 kB 活动匿名内存大小，不包括文件Inactive(anon): 723692 kB 非活动匿名内存大小，不包括文件Active(file): 1180484 kB 活动文件内存大小Inactive(file): 682524 kB 非活动文件内存大小Unevictable: 0 kB 无法驱逐的内存大小Mlocked: 0 kB 锁定在内存中的内存大小SwapTotal: 3991548 kB 系统总交换空间大小SwapFree: 3987928 kB 系统交换空间空闲内存Zswap: 0 kB 使用 zswap 的压缩交换缓存大小Zswapped: 0 kB 使用 zswap 的压缩交换缓存大小Dirty: 180 kB 等待写回磁盘的内存大小Writeback: 0 kB 正在写回磁盘的内存大小AnonPages: 676928 kB 未映射到文件的匿名内存大小Mapped: 339472 kB 映射到文件的内存大小Shmem: 55032 kB 共享内存大小KReclaimable: 142032 kB 可回收的内核内存大小Slab: 417952 kB 内核数据结构缓存的大小SReclaimable: 142032 kB 可回收的 Slab 内存大小SUnreclaim: 275920 kB 不可回收的 Slab 内存大小KernelStack: 11180 kB 内核栈使用的内存大小PageTables: 16944 kB 页表使用的内存大小NFS_Unstable: 0 kB NFS 不稳定页缓存的大小Bounce: 0 kB 用于块设备 I/O 的跳跃缓冲区大小WritebackTmp: 0 kB 临时写回内存大小CommitLimit: 5982644 kB 基于内存和交换空间的提交限制Committed_AS: 4906744 kB 已提交的内存大小，包括内存和交换空间VmallocTotal: 34359738367kB 虚拟内存分配的总量，这是系统可以使用的虚拟内存总量VmallocUsed: 251220 kB 已使用的虚拟内存量VmallocChunk: 0 kB 最大连续虚拟内存空闲区域的大小Percpu: 134656 kB 每个 CPU 的内存使用量，这个值是每个 CPU 的 per-CPU 区域的大小之和HardwareCorrupted: 0 kB 由硬件错误导致的损坏内存量AnonHugePages: 4096 kB 用于匿名映射的大内存页的总量，这些映射不会关联到任何文件ShmemHugePages: 0 kB 用于共享内存（shmem）的大内存页的总量ShmemPmdMapped: 0 kB 已映射到共享内存的PMD大小，PMD 是页中间目录的缩写FileHugePages: 0 kB 用于文件映射的大内存页的总量FilePmdMapped: 0 kB 已映射到文件的 PMD 大小HugePages_Total: 0 系统配置的大内存页的总数HugePages_Free: 0 当前可用的大内存页的数量HugePages_Rsvd: 0 已预留（保留）但尚未使用的大内存页的数量HugePages_Surp: 0 超出系统需求的大内存页的数量，这些页可以在需要时立即分配给应用程序Hugepagesize: 2048 kB 系统配置的大内存页的大小Hugetlb: 0 kB 当前使用的 hugetlb 内存池的总大小，hugetlb 是大内存页的缩写DirectMap4k: 202624 kB 使用 4KB 大小的页映射的物理内存大小DirectMap2M: 3991552 kB 使用 2MB 大小的页映射的物理内存大小DirectMap1G: 2097152 kB 使用 1GB 大小的页映射的物理内存大小","categories":[{"name":"Ubuntu源码","slug":"Ubuntu源码","permalink":"http://example.com/categories/Ubuntu%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/tags/Ubuntu/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture04 Page Tables","slug":"MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables","date":"2023-04-05T09:03:11.000Z","updated":"2023-04-14T11:30:30.108Z","comments":true,"path":"2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/","link":"","permalink":"http://example.com/2023/04/05/MIT6-S081-Operating-System-Engineering-Lecture04-Page-Tables/","excerpt":"Topic Address Spaces 支持虚拟内存的硬件 XV中的虚拟内存代码 Address Spaces","text":"Topic Address Spaces 支持虚拟内存的硬件 XV中的虚拟内存代码 Address Spaces为什么需要隔离性创造虚拟内存的一个出发点是你可以通过它实现隔离性。如果你正确的设置了page table，并且通过代码对它进行正确的管理，那么原则上你可以实现强隔离。 我们期望的是，每个用户程序都被装进一个盒子里，这样它们就不会彼此影响了。类似的，我们也想让它们与内核操作系统相互独立，这样如果某个应用程序无意或者故意做了一些坏事，也不会影响到操作系统。 如果我们不做任何工作，默认情况下我们是没有内存隔离性的。 RISC-V主板上，内存是由一些DRAM芯片组成。在这些DRAM芯片中保存了程序的数据和代码。例如内存中的某一个部分是内核，包括了文本，数据，栈等等；如果运行了Shell，内存中的某个部分就是Shell；如果运行了cat程序，内存中的某个部分是cat程序。这里说的都是物理内存，它的地址从0开始到某个大的地址结束。结束地址取决于我们的机器现在究竟有多少物理内存。所有程序都必须存在于物理内存中，否则处理器甚至都不能处理程序的指令。 这里的风险很明显。我们简单化一下场景，假设Shell存在于内存地址1000-2000之间。 如果cat出现了程序错误，将内存地址1000，也就是Shell的起始地址加载到寄存器a0中。之后执行sd $7, (a0)，这里等效于将7写入内存地址1000。 现在cat程序弄乱了Shell程序的内存镜像，所以隔离性被破坏了，这是我们不想看到的现象。所以，我们想要某种机制，能够将不同程序之间的内存隔离开来，这样类似的事情就不会发生。一种实现方式是地址空间（Address Spaces）。 基本概念这里的基本概念也很简单直观，我们给包括内核在内的所有程序专属的地址空间。所以，当我们运行cat时，它的地址空间从0到某个地址结束。当我们运行Shell时，它的地址也从0开始到某个地址结束。内核的地址空间也从0开始到某个地址结束。 如果cat程序想要向地址1000写入数据，那么cat只会向它自己的地址1000，而不是Shell的地址1000写入数据。所以，基本上来说，每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。在这种不同地址空间的概念中，cat程序甚至都不具备引用属于Shell的内存地址的能力。这是我们想要达成的终极目标，因为这种方式为我们提供了强隔离性，cat现在不能引用任何不属于自己的内存。 所以现在我们的问题是如何在一个物理内存上，创建不同的地址空间，因为归根到底，我们使用的还是一堆存放了内存信息的DRAM芯片。 虚拟内存可以比物理内存更大，物理内存也可以比虚拟内存更大 如果太多的进程使用了虚拟内存，有可能使物理内存耗尽 kalloc保存了空余的page的列表，如果这个列表为空或者耗尽了，那么kalloc会返回一个空指针，内核会妥善处理并将结果返回给用户应用程序。并告诉用户应用程序，要么是对这个应用程序没有额外的内存了，要么整个机器都没有内存了。 Page页表流程页表是在硬件中通过处理器和内存管理单元（Memory Management Unit）实现。 CPU正在执行指令，例如sd $7, (a0)。 对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。假设寄存器a0中是地址0x1000，那么这是一个虚拟内存地址。虚拟内存地址会被转到内存管理单元（MMU，Memory Management Unit） 内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。 从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。 为了能够完成虚拟内存地址到物理内存地址的翻译，MMU会有一个表单，表单中，一边是虚拟内存地址，另一边是物理内存地址。举个例子，虚拟内存地址0x1000对应了一个我随口说的物理内存地址0xFFF0。这样的表单可以非常灵活。 通常来说，内存地址对应关系的表单也保存在内存中。所以CPU中需要有一些寄存器用来存放表单在物理内存中的地址。现在，在内存的某个位置保存了地址关系表单，我们假设这个位置的物理内存地址是0x10。那么在RISC-V上一个叫做SATP的寄存器会保存地址0x10。 这样，CPU就可以告诉MMU，可以从哪找到将虚拟内存地址翻译成物理内存地址的表单。 page table存储在内存中，MMU只是会去查看page table。 每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。这样的话，cat程序和Shell程序中相同的虚拟内存地址，就可以翻译到不同的物理内存地址，因为每个应用程序都有属于自己的不同的地址对应表单。 内核会写SATP寄存器，写SATP寄存器是一条特殊权限指令。所以，用户应用程序不能通过更新这个寄存器来更换一个地址对应表单，否则的话就会破坏隔离性。所以，只有运行在kernel mode的代码可以更新这个寄存器。 虚拟地址到物理地址 虚拟内存地址分为两个部分 index：用来查找page offset：对应一个page中的字节 当MMU在做地址翻译的时候，通过读取虚拟内存地址中的index可以知道物理内存中的page号，这个page号对应了物理内存中的4096个字节。之后虚拟内存地址中的offset指向了page中的4096个字节中的某一个，假设offset是12，那么page中的第12个字节被使用了。将offset加上page的起始地址，就可以得到物理内存地址。 RSIC-V处理器RISC-V的寄存器是64bit，但是并不是所有的64bit都被使用了，高25bit未被使用。 这样的结果是限制了虚拟内存地址的数量，虚拟内存地址的数量现在只有2^39个，大概是512GB。 当然如果有必要的话，最新的处理器或许可以支持更大的地址空间，只需要将未使用的25bit拿出来作为虚拟内存地址的一部分即可。 在剩下的39bit中，有27bit被用来当作index，12bit被用来当作offset。offset必须是12bit，因为对应了一个page的4096个字节。 在RISC-V中，物理内存地址是56bit。所以物理内存地址可以大于单个内存地址空间，但是也最多到2^56。大多数主板还不支持2^56这么大的物理内存，但是原则上，如果你能造出这样的主板，那么最多可以支持2^56字节的物理内存。 物理内存地址是56bit，其中44bit是物理page号（PPN,Physical Page Number)，剩下的12bit是offset完全继承自虚拟内存地址（也就是地址转换时，只需要将虚拟内存中的27bit翻译成物理内存中的44bit的page号，剩下的12bitoffset直接拷贝过来即可。 多级page table 我们之前提到的虚拟内存地址中的27bit的index，实际上是由3个9bit的数字组成（L2，L1，L0）。前9个bit被用来索引最高级的page directory（注：通常page directory是用来索引page table或者其他page directory物理地址的表单) 一个directory是4096Bytes，就跟page的大小是一样的。Directory中的一个条目被称为PTE（Page Table Entry）是64bits，就像寄存器的大小一样，也就是8Bytes。所以一个Directory page有512个条目。 所以实际上，SATP寄存器会指向最高一级的page directory的物理内存地址，之后我们用虚拟内存中index的高9bit用来索引最高一级的page directory，这样我们就能得到一个PPN，也就是物理page号。这个PPN指向了中间级的page directory。 当我们在使用中间级的page directory时，我们通过虚拟内存地址中的L1部分完成索引。接下来会走到最低级的page directory，我们通过虚拟内存地址中的L0部分完成索引。在最低级的page directory中，我们可以得到对应于虚拟内存地址的物理内存地址。 优点如果地址空间中大部分地址都没有使用，你不必为每一个index准备一个条目。举个例子，如果你的地址空间只使用了一个page，4096Bytes。除此之外，你没有使用任何其他的地址。现在，你需要多少个page table entry，或者page table directory来映射这一个page？ 在最高级，你需要一个page directory。在这个page directory中，你需要一个数字是0的PTE，指向中间级page directory。所以在中间级，你也需要一个page directory，里面也是一个数字0的PTE，指向最低级page directory。所以这里总共需要3个page directory（也就是3 * 512个条目）。 而在单级page table中，虽然我们只使用了一个page，还是需要2^27个PTE。这个方案中，我们只需要3 * 512个PTE。所需的空间大大减少了。这是实际上硬件采用这种层次化的3级page directory结构的主要原因。 PTE 物理页号（Physical Page Number，PPN）: 与物理地址字段类似，PPN存储与虚拟地址关联的物理内存地址。在RISC-V中，PTE的高位部分存储PPN。 有效位（Valid，V）: 有效位表示此PTE中存储的映射是否有效。如果有效位设置为1，表示此PTE的虚拟地址已映射到物理内存中。如果设置为0，则表示该虚拟地址尚未映射。 读（Read，R）: 读权限位表示允许对该页面进行读访问。 写（Write，W）: 写权限位表示允许对该页面进行写访问。 执行（Execute，X）: 执行权限位表示允许对该页面进行执行访问。 用户（User，U）: 用户权限位表示该页面是否允许在用户模式下访问。如果设置为1，则允许用户模式访问；如果设置为0，则仅允许特权模式访问。 全局（Global，G）: 全局位表示该页面是否对所有地址空间可见。如果设置为1，则表示该页面在地址空间切换时不会从转换查找缓冲器（Translation Lookaside Buffer，TLB）中清除。这对于操作系统内核和共享库等全局数据结构特别有用。 访问（Accessed，A）: 访问位表示自上次清零以来该页面是否被访问过。当发生内存访问时，硬件会自动设置访问位。 脏（Dirty，D）: 脏位表示自上次清零以来该页面是否被修改过。当某个页面的内容被修改时，硬件会自动设置脏位。 软件可用位（Software Use，SW）: 这些位是为操作系统软件保留的，可以在页表遍历过程中用于自定义用途。 页表缓存（Translation Lookaside Buffer）观察page table的结构，可以发现，当处理器从内存加载或者存储数据时，基本上都要做3次内存查找，第一次在最高级的page directory，第二次在中间级的page directory，最后一次在最低级的page directory。所以对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。所以实际中，几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：Translation Lookside Buffer（通常翻译成页表缓存）。你会经常看到它的缩写TLB。基本上来说，这就是Page Table Entry的缓存，也就是PTE的缓存。 当处理器第一次查找一个虚拟地址时，硬件通过3级page table得到最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。这样下一次当你访问同一个虚拟地址时，处理器可以查看TLB，TLB会直接返回物理地址，而不需要通过page table得到结果。 TLB实现的具体细节不是我们要深入讨论的内容。这是处理器中的一些逻辑，对于操作系统来说是不可见的，操作系统也不需要知道TLB是如何工作的。你们需要知道TLB存在的唯一原因是，如果你切换了page table，操作系统需要告诉处理器当前正在切换page table，处理器会清空TLB。因为本质上来说，如果你切换了page table，TLB中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。所以操作系统知道TLB是存在的，但只会时不时的告诉操作系统，现在的TLB不能用了，因为要切换page table了。在RISC-V中，清空TLB的指令是sfence_vma。 整个CPU和MMU都在处理器芯片中，所以在一个RISC-V芯片中，有多个CPU核，MMU和TLB存在于每一个CPU核里面。RISC-V处理器有L1 cache，L2 Cache，有些cache是根据物理地址索引的，有些cache是根据虚拟地址索引的，由虚拟地址索引的cache位于MMU之前，由物理地址索引的cache位于MMU之后。 Kernel Page Table 在XV6中，page table是如何工作的? 当操作系统启动时，会从地址0x80000000开始运行，这个地址其实也是由硬件设计者决定的。 主板的设计人员决定了，在完成了虚拟到物理地址的翻译之后，如果得到的物理地址大于0x80000000会走向DRAM芯片，如果得到的物理地址低于0x80000000会走向不同的I&#x2F;O设备。这是由这个主板的设计人员决定的物理结构。 首先，地址0是保留的，地址0x10090000对应以太网，地址0x80000000对应DDR内存，处理器外的易失存储（Off-Chip Volatile Memory），也就是主板上的DRAM芯片。 所有的事情都是由硬件，即主板决定的，CPU只是主板的一小部分，DRAM芯片位于处理器之外。是主板设计者将处理器，DRAM和许多I&#x2F;O设备汇总在一起。对于一个操作系统来说，CPU只是一个部分，I&#x2F;O设备同样也很重要。所以当你在写一个操作系统时，你需要同时处理CPU和I&#x2F;O设备，比如你需要向互联网发送一个报文，操作系统需要调用网卡驱动和网卡来实际完成这个工作。 地址0x1000是boot ROM的物理地址，当你对主板上电，主板做的第一件事情就是运行存储在boot ROM中的代码，当boot完成之后，会跳转到地址0x80000000，操作系统需要确保那个地址有一些数据能够接着启动操作系统。 物理地址还有一些其他的I&#x2F;O设备 PLIC是中断控制器（Platform-Level Interrupt Controller） CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。 UART0（Universal Asynchronous Receiver&#x2F;Transmitter）负责与Console和显示器交互。 VIRTIO disk，与磁盘进行交互。 高于0x80000000的物理地址对应DRAM芯片，但是对于例如以太网接口，也有一个特定的低于0x80000000的物理地址，我们可以对这个叫做内存映射I&#x2F;O（Memory-mapped I&#x2F;O）的地址执行读写指令，来完成设备的操作。 地址0x02000000对应CLINT，当你向这个地址执行读写指令，你是向实现了CLINT的芯片执行读写。这里你可以认为你直接在与设备交互，而不是读写物理内存。 物理地址总共有2^56那么多，但是你不用在主板上接入那么多的内存。所以不论主板上有多少DRAM芯片，总是会有一部分物理地址没有被用到。实际上在XV6中，我们限制了内存的大小是128MB。 在RISC-V中有一个多路输出选择器（demultiplexer）可以帮助CPU将指令送到正确的I&#x2F;O设备。 两件重要的事情： 有一些page在虚拟内存中的地址很靠后，比如kernel stack在虚拟内存中的地址就很靠后。这是因为在它之下有一个未被映射的Guard page，这个Guard page对应的PTE的Valid 标志位没有设置，这样，如果kernel stack耗尽了，它会溢出到Guard page，但是因为Guard page的PTE中Valid标志位未设置，会导致立即触发page fault，这样的结果好过内存越界之后造成的数据混乱。立即触发一个panic（也就是page fault），你就知道kernel stack出错了。同时我们也又不想浪费物理内存给Guard page，所以Guard page不会映射到任何物理内存，它只是占据了虚拟地址空间的一段靠后的地址。&#96; 同时，kernel stack被映射了两次，在靠后的虚拟地址映射了一次，在PHYSTOP下的Kernel data中又映射了一次，但是实际使用的时候用的是上面的部分，因为有Guard page会更加安全。 权限：例如Kernel text page被标位R-X，意味着你可以读它，也可以在这个地址段执行指令，但是你不能向Kernel text写数据。通过设置权限我们可以尽早的发现Bug从而避免Bug。对于Kernel data需要能被写入，所以它的标志位是RW-，但是你不能在这个地址段运行指令，所以它的X标志位未被设置。（注，所以，kernel text用来存代码，代码可以读，可以运行，但是不能篡改，kernel data用来存数据，数据可以读写，但是不能通过数据伪装代码在kernel中运行） 每一个用户进程都有一个对应的kernel stack。 在kernel page table中，有一段Free Memory，它对应了物理内存中的一段地址。XV6使用这段free memory来存放用户进程的page table，text和data。如果我们运行了非常多的用户进程，某个时间点我们会耗尽这段内存，这个时候fork或者exec会返回错误。 当kernel创建了一个进程，针对这个进程的page table也会从Free memory中分配出来。内核会为用户进程的page table分配几个page，并填入PTE。在某个时间点，当内核运行了这个进程，内核会将进程的根page table的地址加载到SATP中。从那个时间点开始，处理器会使用内核为那个进程构建的虚拟地址空间。 Code:Creating an address space大部分用于操作地址空间和页表的xv6代码位于vm.c（kernel&#x2F;vm.c）中。主要数据结构是pagetable_t，它实际上是指向RISC-V 35根页表页面的指针；pagetable_t可以是内核页表，也可以是每个进程的页表之一。主要函数为walk，该函数查找虚拟地址的PTE，并且mappages安装新映射的PTE。以kvm开头的函数操作内核页表；以uvm开头的函数操作用户页表；其他功能同时用于两者。copyout和copyin将数据复制和从作为系统调用参数提供的用户虚拟地址复制出来；它们在vm.c中因为需要明确翻译这些地址才能找到相应物理存储器。 在引导序列早期，main调用kvminit（kernel&#x2F;vm.c:54）使用kvmmake（kernel&#x2F;vm.c:20）创建内核页面表格。 12345voidkvminit(void)&#123; kernel_pagetable = kvmmake();&#125; 1234567891011121314151617181920212223242526272829303132pagetable_tkvmmake(void)&#123; pagetable_t kpgtbl; kpgtbl = (pagetable_t) kalloc(); memset(kpgtbl, 0, PGSIZE); // uart registers kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W); // virtio mmio disk interface kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W); // PLIC kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W); // map kernel text executable and read-only. kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X); // map kernel data and the physical RAM we&#x27;ll make use of. kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W); // map the trampoline for trap entry/exit to // the highest virtual address in the kernel. kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); // allocate and map a kernel stack for each process. proc_mapstacks(kpgtbl); return kpgtbl;&#125; 此调用发生在xv6启动RISC-V分页之前，因此地址直接引用物理存储器。kvmmake首先分配一个物理存储器页面来保存根页面- 表示页面; 然后它调用kvmmap来安装内核所需的转换。这些转换包括内核指令和数据、PHYSTOP以下 的物理存储器以及实际上是设备的内存范围。 proc_mapstacks（kernel&#x2F;proc.c:33）为每个进程分配一个内核堆栈。它调用kvmmap将每个堆栈映射到由KSTACK生成的虚拟地址，这样可以留出无效的堆栈保护页。 12345678910111213141516// Allocate a page for each process&#x27;s kernel stack.// Map it high in memory, followed by an invalid// guard page.voidproc_mapstacks(pagetable_t kpgtbl)&#123; struct proc *p; for(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; char *pa = kalloc(); if(pa == 0) panic(&quot;kalloc&quot;); uint64 va = KSTACK((int) (p - proc)); kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W); &#125;&#125; kvmmap（kernel&#x2F;vm.c:127）调用mappages（kernel&#x2F;vm.c:138），该函数为一系列虚拟地址范围安装映射到相应物理地址的页面表格中。 123456789// add a mapping to the kernel page table.// only used when booting.// does not flush TLB or enable paging.voidkvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)&#123; if(mappages(kpgtbl, va, sz, pa, perm) != 0) panic(&quot;kvmmap&quot;);&#125; 12345678910111213141516171819202122232425262728// Create PTEs for virtual addresses starting at va that refer to// physical addresses starting at pa. va and size might not// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t// allocate a needed page-table page.intmappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)&#123; uint64 a, last; pte_t *pte; if(size == 0) panic(&quot;mappages: size&quot;); a = PGROUNDDOWN(va); last = PGROUNDDOWN(va + size - 1); for(;;)&#123; if((pte = walk(pagetable, a, 1)) == 0) return -1; if(*pte &amp; PTE_V) panic(&quot;mappages: remap&quot;); *pte = PA2PTE(pa) | perm | PTE_V; if(a == last) break; a += PGSIZE; pa += PGSIZE; &#125; return 0;&#125; 它对于范围中的每个虚拟地址单独执行此操作，在页面间隔处执行此操作。对于要映射的每个虚拟地址，mappages都会调用walk来查找该地址PTE的位置。然后，它初始化PTE以保存相关物理页号、所需权限（PTE_W、PTE_X和&#x2F;或 PTE_R）和标记PTE_V作为有效(kernel&#x2F;vm.c:153)。 12345678910111213141516171819202122232425262728// Create PTEs for virtual addresses starting at va that refer to// physical addresses starting at pa. va and size might not// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t// allocate a needed page-table page.intmappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)&#123; uint64 a, last; pte_t *pte; if(size == 0) panic(&quot;mappages: size&quot;); a = PGROUNDDOWN(va); last = PGROUNDDOWN(va + size - 1); for(;;)&#123; if((pte = walk(pagetable, a, 1)) == 0) return -1; if(*pte &amp; PTE_V) panic(&quot;mappages: remap&quot;); *pte = PA2PTE(pa) | perm | PTE_V; if(a == last) break; a += PGSIZE; pa += PGSIZE; &#125; return 0;&#125; walk（kernel&#x2F;vm.c:81）模仿RISC-V分页硬件，查找虚拟地址的PTE。walk每次下降3级页面表9位。它使用每个级别的9位虚拟地址来查找下一级页面表或最终页面的PTE（kernel&#x2F;vm.c:87）。如果PTE无效，则尚未分配所需页面；如果设置了alloc参数，则walk将分配新的页表页并将其物理地址放入PTE中。 12345678910111213141516171819202122232425262728293031// Return the address of the PTE in page table pagetable// that corresponds to virtual address va. If alloc!=0,// create any required page-table pages.//// The risc-v Sv39 scheme has three levels of page-table// pages. A page-table page contains 512 64-bit PTEs.// A 64-bit virtual address is split into five fields:// 39..63 -- must be zero.// 30..38 -- 9 bits of level-2 index.// 21..29 -- 9 bits of level-1 index.// 12..20 -- 9 bits of level-0 index.// 0..11 -- 12 bits of byte offset within the page.pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)&#123; if(va &gt;= MAXVA) panic(&quot;walk&quot;); for(int level = 2; level &gt; 0; level--) &#123; pte_t *pte = &amp;pagetable[PX(level, va)]; if(*pte &amp; PTE_V) &#123; pagetable = (pagetable_t)PTE2PA(*pte); &#125; else &#123; if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; memset(pagetable, 0, PGSIZE); *pte = PA2PTE(pagetable) | PTE_V; &#125; &#125; return &amp;pagetable[PX(0, va)];&#125; 它返回树中最低层的PTE地址。以上代码依赖于物理内存被直接映射到内核虚拟地址空间中。例如，当walk下降页面表级别时，它从PTE获取下一个向下级别页面表(物理)地址，并使用该地址作为虚拟地址获取下一个向下级别的 PTE 。 12345678910111213/ Switch h/w page table register to the kernel&#x27;s page table,// and enable paging.voidkvminithart()&#123; // wait for any previous writes to the page table memory to finish. sfence_vma(); w_satp(MAKE_SATP(kernel_pagetable)); // flush stale entries from the TLB. sfence_vma();&#125; 主函数调用kvminithart(kernel &#x2F; vm.c：62)安装内核页表。 它将根页表页的物理地址写入satp寄存器。之后CPU将使用内核页表翻译地址。由于内核使用身份映射，现在指令集合上一条指令对应正确的物理内存位置。 每个RISC-V CPU都会在转换前缓存TLB中相应信息，在xv6更改某一页时必须告诉CPU使相应的缓存TLB条目失效。如果没有这样做，那么在以后的某个时候，TLB可能会使用旧的缓存映射，指向此时已分配给另一个进程的物理页面，并且结果是进程可能能够涂写其他进程的内存。RISC-V有一种指令sfence.vma可以刷新当前CPU的TLB。Xv6在重新加载satp寄存器之后，在kvminithart中执行sfence.vma，并在跳板代码(kernel&#x2F;trampoline.S:79)中切换到36用户页表并返回用户空间前执行。 为了避免刷新完整的TLB，RISC-V CPU可以支持地址空间标识符（ASIDs）。然后内核只需清除特定地址空间的TLB条目即可","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT6 S081 Operating System Engineering Lecture03 OS Organization and System Call","slug":"MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call","date":"2023-04-02T06:44:05.000Z","updated":"2023-04-06T08:24:13.187Z","comments":true,"path":"2023/04/02/MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call/","link":"","permalink":"http://example.com/2023/04/02/MIT6-S081-Operating-System-Engineering-Lecture03-OS-Organization-and-System-Call/","excerpt":"Topic Isolation:Isolation是设计操作系统组织结构的驱动力 System Call:System call是你的应用程序能够转换到内核执行的基本方法 Kernel mode&#x2F;user mode Isolation","text":"Topic Isolation:Isolation是设计操作系统组织结构的驱动力 System Call:System call是你的应用程序能够转换到内核执行的基本方法 Kernel mode&#x2F;user mode Isolation应用程序之间有隔离性我们在用户空间有多个应用程序，例如Shell、echo、find等等。但是，如果你通过Shell运行你们的Prime代码（lab1中的一个部分）时，假设你们的代码出现了问题，Shell不应该会影响到其他的应用程序。举个反例，如果Shell出现问题时，杀掉了其他的进程，这将会非常糟糕。所以你需要在不同的应用程序之间有强隔离性。 应用程序与操作系统之间有隔离性操作系统某种程度上为所有的应用程序服务。当你的应用程序出现问题时，你会希望操作系统不会因此而崩溃。比如说你向操作系统传递了一些奇怪的参数，你会希望操作系统仍然能够很好的处理它们（能较好的处理异常情况）。所以，你也需要在应用程序和操作系统之间有强隔离性。 如果没有操作系统如果没有操作系统，或者操作系统只是一些库文件，比如说你在使用Python，通过import os你就可以将整个操作系统加载到你的应用程序中。那么现在，我们有一个Shell，并且我们引用了代表操作系统的库。同时，我们有一些其他的应用程序，例如echo。 通常来说，如果没有操作系统，应用程序会直接与硬件交互。比如，应用程序可以直接看到CPU的多个核，看到磁盘，内存。所以现在应用程序和硬件资源之间没有一个额外的抽象层。 调度及复用隔离问题使用操作系统的一个目的是为了同时运行多个应用程序，所以时不时的，CPU会从一个应用程序切换到另一个应用程序。我们假设硬件资源里只有一个CPU核，并且我们现在在这个CPU核上运行Shell。但是时不时的，也需要让其他的应用程序也可以运行。现在我们没有操作系统来帮我们完成切换，所以Shell就需要时不时的释放CPU资源。 为了不变成一个恶意程序，Shell在发现自己运行了一段时间之后，需要让别的程序也有机会能运行。这种机制有时候称为协同调度（Cooperative Scheduling）。但是这里的场景并没有很好的隔离性，比如说Shell中的某个函数有一个死循环，那么Shell永远也不会释放CPU，进而其他的应用程序也不能够运行，甚至都不能运行一个第三方的程序来停止或者杀死Shell程序。所以这种场景下，我们基本上得不到真正的multiplexing（CPU在多进程同分时复用）。而这个特性是非常有用的，不论应用程序在执行什么操作，multiplexing都会迫使应用程序时不时的释放CPU，这样其他的应用程序才能运行。 内存隔离问题假设现在物理内存中的一部分被Shell使用，另一部分被echo使用。因为两个应用程序的内存之间没有边界，如果echo程序将数据存储在属于Shell的一个内存地址中，那么就echo就会覆盖Shell程序内存中的内容。 使用操作系统的一个原因，甚至可以说是主要原因就是为了实现multiplexing和内存隔离。如果你不使用操作系统，并且应用程序直接与硬件交互，就很难实现这两点。所以，将操作系统设计成一个库，并不是一种常见的设计。你或许可以在一些实时操作系统中看到这样的设计，因为在这些实时操作系统中，应用程序之间彼此相互信任。但是在大部分的其他操作系统中，都会强制实现硬件资源的隔离。 从隔离的角度来看Unix接口如果我们从隔离的角度来稍微看看Unix接口，那么我们可以发现，接口被精心设计以实现资源的强隔离，也就是multiplexing和物理内存的隔离。接口通过抽象硬件资源，从而使得提供强隔离性成为可能。 Example 1之前通过fork创建了进程。进程本身不是CPU，但是它们对应了CPU，它们使得你可以在CPU上运行计算任务。所以你懂的，应用程序不能直接与CPU交互，只能与进程交互。操作系统内核会完成不同进程在CPU上的切换。所以，操作系统不是直接将CPU提供给应用程序，而是向应用程序提供“进程”，进程抽象了CPU，这样操作系统才能在多个应用程序之间复用一个或者多个CPU。 我们在实验中使用的RISC-V处理器实际上是有4个核。所以你可以同时运行4个进程，一个进程占用一个核。但是假设你有8个应用程序，操作系统会分时复用这些CPU核，比如说对于一个进程运行100毫秒，之后内核会停止运行并将那个进程从CPU中卸载，再加载另一个应用程序并再运行100毫秒。通过这种方式使得每一个应用程序都不会连续运行超过100毫秒。这里只是一些基本概念，我们在接下来的几节课中会具体的看这里是如何实现的。 我们可以认为exec抽象了内存。当我们在执行exec系统调用的时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的内存镜像。内存镜像里面包括了程序对应的指令，全局的数据。应用程序可以逐渐扩展自己的内存，但是应用程序并没有直接访问物理内存的权限，例如应用程序不能直接访问物理内存的1000-2000这段地址。不能直接访问的原因是，操作系统会提供内存隔离并控制内存，操作系统会在应用程序和硬件资源之间提供一个中间层。exec是这样一种系统调用，它表明了应用程序不能直接访问物理内存。 Example 2files基本上来说抽象了磁盘。应用程序不会直接读写挂在计算机上的磁盘本身，并且在Unix中这也是不被允许的。在Unix中，与存储系统交互的唯一方式就是通过files。Files提供了非常方便的磁盘抽象，你可以对文件命名，读写文件等等。之后，操作系统会决定如何将文件与磁盘中的块对应，确保一个磁盘块只出现在一个文件中，并且确保用户A不能操作用户B的文件。通过files的抽象，可以实现不同用户之间和同一个用户的不同进程之间的文件强隔离。 Defensive 防御性：当你在做内核开发时，这是一种你需要熟悉的重要思想。操作系统需要确保所有的组件都能工作，所以它需要做好准备抵御来自应用程序的攻击。如果说应用程序无意或者恶意的向系统调用传入一些错误的参数就会导致操作系统崩溃，那就太糟糕了。在这种场景下，操作系统因为崩溃了会拒绝为其他所有的应用程序提供服务。所以操作系统需要以这样一种方式来完成：操作系统需要能够应对恶意的应用程序。 隔离性：另一个需要考虑的是，应用程序不能够打破对它的隔离。应用程序非常有可能是恶意的，它或许是由攻击者写出来的，攻击者或许想要打破对应用程序的隔离，进而控制内核。一旦有了对于内核的控制能力，你可以做任何事情，因为内核控制了所有的硬件资源。 所以操作系统或者说内核需要具备防御性来避免类似的事情发生。实际中，要满足这些要求还有点棘手。在Linux中，时不时的有一些内核的bug使得应用程序可以打破它的隔离域并控制内核。这里需要持续的关注，并尽可能的提供最好的防御性。当你在开发内核时，防御性是你必须掌握的一个思想。实际中的应用程序或许就是恶意的，这意味着我们需要在应用程序和操作系统之间提供强隔离性。如果操作系统需要具备防御性，那么在应用程序和操作系统之间需要有一堵厚墙，并且操作系统可以在这堵墙上执行任何它想执行的策略。 通常来说，需要通过硬件来实现强隔离性。这里的硬件主要包括两部分，一个是user&#x2F;kernel mode，kernel mode在RISC-V中被称为Supervisor mode但是其实是同一种东西；第二部分是page table或者虚拟内存（Virtual Memory） 所以，所有的处理器，如果需要运行能够支持多个应用程序的操作系统，需要同时支持user&#x2F;kernle mode和虚拟内存。具体的实现或许会有细微的差别，但是基本上来说所有的处理器需要能支持这些。 硬件对于强隔离的支持user&#x2F;kernel mode为了支持user&#x2F;kernel mode，处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行特定权限的指令（privileged instructions）；当运行在user mode时，CPU只能运行普通权限的指令（unprivileged instructions）。 普通权限的指令都是一些你们熟悉的指令，例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等等。这些都是普通权限指令，所有的应用程序都允许执行这些指令。 特殊权限指令主要是一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。 举个例子，当一个应用程序尝试执行一条特殊权限指令，因为不允许在user mode执行特殊权限指令，处理器会拒绝执行这条指令。通常来说，这时会将控制权限从user mode切换到kernel mode，当操作系统拿到控制权之后，或许会杀掉进程，因为应用程序执行了不该执行的指令。 在处理器里面有一个flag。在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令，就像在运算时不能除以0一样。设置那个bit位的指令必须是特殊权限指令，因为应用程序不应该能够设置那个bit到kernel mode，否则的话应用程序就可以运行各种特殊权限指令了。所以那个bit是被保护的。 RISC-V还有第三种模式称为machine mode。在大多数场景下，我们会忽略这种模式，所以我们实际上有三级权限user&#x2F;kernel&#x2F;machine。 page table每一个进程都会有自己独立的page table，这样的话，每一个进程只能访问出现在自己page table中的物理内存。操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的page table中。一个进程甚至都不能随意编造一个内存地址，然后通过这个内存地址来访问其他进程的物理内存。这样就给了我们内存的强隔离性。 基本上来说，page table定义了对于内存的视图，而每一个用户进程都有自己对于内存的独立视图。这给了我们非常强的内存隔离性。 User&#x2F;Kernel mode切换我们可以认为user&#x2F;kernel mode是分隔用户空间和内核空间的边界，用户空间运行的程序运行在user mode，内核空间的程序运行在kernel mode。操作系统位于内核空间。 当ls程序运行的时候，会调用read&#x2F;write系统调用；Shell程序会调用fork或者exec系统调用，所以必须要有一种方式可以使得用户的应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供相应的服务。 Ecall在RISC-V中，有一个专门的指令用来实现控制权的转换功能，叫做ECALL。ECALL接收一个数字参数，当一个用户程序想要将程序执行的控制权转移到内核，它只需要执行ECALL指令，并传入一个数字。这里的数字参数代表了应用程序想要调用的System Call。 ECALL会跳转到内核中一个特定，由内核控制的位置。在XV6中存在一个唯一的系统调用接入点，每一次应用程序执行ECALL指令，应用程序都会通过这个接入点进入到内核中。举个例子，不论是Shell还是其他的应用程序，当它在用户空间执行fork时，它并不是直接调用操作系统中对应的函数，而是调用ECALL指令，并将fork对应的数字作为参数传给ECALL。之后再通过ECALL跳转到内核。 在内核侧，有一个位于syscall.c的函数syscall，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的参数，通过这个参数内核可以知道需要调用的是fork。 用户空间和内核空间的界限是一个硬性的界限，用户不能直接调用fork，用户的应用程序执行系统调用的唯一方法就是通过这里的ECALL指令。 假设我现在要执行另一个系统调用write，相应的流程是类似的，write系统调用不能直接调用内核中的write代码，而是由封装好的系统调用函数执行ECALL指令。所以write函数实际上调用的是ECALL指令，指令的参数是代表了write系统调用的数字。之后控制权到了syscall函数，syscall会实际调用write系统调用。 宏内核和微内核（Monolithic Kernel and Micro Kernel）现在，我们有了一种方法，可以通过系统调用或者说ECALL指令，将控制权从应用程序转到操作系统中。之后内核负责实现具体的功能并检查参数以确保不会被一些坏的参数所欺骗。所以内核有时候也被称为可被信任的计算空间（Trusted Computing Base），在一些安全的术语中也被称为TCB。 基本上来说，要被称为TCB，内核首先要是正确且没有Bug的。假设内核中有Bug，攻击者可能会利用那个Bug，并将这个Bug转变成漏洞，这个漏洞使得攻击者可以打破操作系统的隔离性并接管内核。所以内核真的是需要越少的Bug越好。 另一方面，内核必须要将用户应用程序或者进程当做是恶意的。内核的设计人员在编写和实现内核代码时，必须要有安全的思想。这个目标很难实现，因为当你的操作系统变得足够大的时候，很多事情就不是那么直观了。几乎每一个你用过的或者被广泛使用的操作系统，时不时的都有一个安全漏洞。就算被修复了，但是过了一段时间，又会出现一个新的漏洞。我们之后会介绍为什么很难让所有部分都正确工作，但是你要知道是内核需要做一些tricky的工作，需要操纵硬件，需要非常小心做检查，所以很容易就出现一些小的疏漏，进而触发一个Bug。这也是可以理解的。 宏内核（Monolithic Kernel）让整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。比如，XV6中，所有的操作系统服务都在kernel mode中，这种形式被称为Monolithic Kernel Design。 在一个宏内核中，任何一个操作系统的Bug都有可能成为漏洞。因为我们现在在内核中运行了一个巨大的操作系统，出现Bug的可能性更大了。你们可以去查一些统计信息，平均每3000行代码都会有几个Bug，所以如果有许多行代码运行在内核中，那么出现严重Bug的可能性也变得更大。所以从安全的角度来说，在内核中有大量的代码是宏内核的缺点。 如果你去看一个操作系统，它包含了各种各样的组成部分，比如说文件系统，虚拟内存，进程管理，这些都是操作系统内实现了特定功能的子模块。宏内核的优势在于，因为这些子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。例如Linux，它就有很不错的性能。 微内核（Micro Kernel）在这种模式下，希望在kernel mode中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块，例如，内核通常会有一些IPC的实现或者是Message passing；非常少的虚拟内存的支持，可能只支持了page table；以及分时复用CPU的一些支持。 微内核的目的在于将大部分的操作系统运行在内核之外。所以，我们还是会有user mode以及user&#x2F;kernel mode的边界。但是我们现在会将原来在内核中的其他部分，作为普通的用户程序来运行。比如文件系统可能就是个常规的用户空间程序。 某种程度上来说，这是一种好的设计。因为在内核中的代码的数量较小，更少的代码意味着更少的Bug。 但是这种设计也有相应的问题。假设我们需要让Shell能与文件系统交互，比如Shell调用了exec，必须有种方式可以接入到文件系统中。通常来说，这里工作的方式是，Shell会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统。 文件系统会完成它的工作之后会向IPC系统发送回一条消息说，这是你的exec系统调用的结果，之后IPC系统再将这条消息发送给Shell。 所以，这里是典型的通过消息来实现传统的系统调用。现在，对于任何文件系统的交互，都需要分别完成2次用户空间&lt;-&gt;内核空间的跳转。与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间&lt;-&gt;内核空间的跳转，所以微内核的的跳转是宏内核的两倍。通常微内核的挑战在于性能更差，这里有两个方面需要考虑： 在user&#x2F;kernel mode反复跳转带来的性能损耗。 在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。 在实际中，两种内核设计都会出现，出于历史原因大部分的桌面操作系统是宏内核，如果你运行需要大量内核计算的应用程序，例如在数据中心服务器上的操作系统，通常也是使用的宏内核，主要的原因是Linux提供了很好的性能。但是很多嵌入式系统，例如Minix，Cell，这些都是微内核设计。这两种设计都很流行，如果你从头开始写一个操作系统，你可能会从一个微内核设计开始。但是一旦你有了类似于Linux这样的宏内核设计，将它重写到一个微内核设计将会是巨大的工作。并且这样重构的动机也不足，因为人们总是想把时间花在实现新功能上，而不是重构他们的内核。 编译运行Kernel代码结构 kernel：里面包含了基本上所有的内核文件。因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。 user：这基本上是运行在user mode的程序。这也是为什么一个目录称为kernel，另一个目录称为user的原因。 mkfs：它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。 编译过程 Makefile（XV6目录下的文件）会读取一个C文件，例如proc.c；之后调用gcc编译器，生成一个文件叫做proc.s，这是RISC-V 汇编语言文件；之后再走到汇编解释器，生成proc.o，这是汇编语言的二进制格式。 Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。 之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。 这里生成的内核文件就是我们将会在QEMU中运行的文件。同时，为了你们的方便，Makefile还会创建kernel.asm，这里包含了内核的完整汇编语言，你们可以通过查看它来定位究竟是哪个指令导致了Bug。 传给QEMU的几个参数 kernel ：这里传递的是内核文件（kernel目录下的kernel文件），这是将在QEMU中运行的程序文件。 -m ：这里传递的是RISC-V虚拟机将会使用的内存数量。 smp：这里传递的是虚拟机可以使用的CPU核数 -drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件 QEMU直观来看，QEMU是一个大型的开源C程序，你可以下载或者git clone它。但是在内部，在QEMU的主循环中，只在做一件事情： 读取4字节或者8字节的RISC-V指令。 解析RISC-V指令，并找出对应的操作码（op code）。我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。 之后，在软件中执行相应的指令。 这基本上就是QEMU的全部工作了，对于每个CPU核，QEMU都会运行这么一个循环。 XV6的启动过程QEMU 是一个通用的开源处理器模拟器和虚拟化程序，可以用于在物理计算机上模拟设备，并运行各种操作系统，如 xv6。以下是结合 QEMU 源代码和 xv6 源代码说明启动过程的概述： 启动 QEMU：从命令行启动 QEMU，并指定要加载的操作系统映像（在这种情况下为 xv6 操作系统）。命令可能如下所示： 1qemu-system-i386 -nographic -serial mon:stdio -hdb fs.img xv6.img -s -S 在这里，qemu-system-i386 是针对 x86（32 位）系统的 QEMU 模拟器，-nographic 参数表示不使用图形界面，-serial mon:stdio 表示将监视器（QEMU 控制台）连接到标准输入&#x2F;输出，-hdb fs.img 指定要加载的 xv6 文件系统映像，xv6.img 是 xv6 操作系统映像，-s 和 -S 参数用于调试。 QEMU 初始化虚拟硬件：QEMU 将根据所指定的参数和配置，初始化虚拟处理器、内存、硬盘和其他硬件设备。 加载引导程序：QEMU 模拟 BIOS 行为，将 xv6.img 映像中的启动扇区加载到内存中，并将控制权交给这段代码。在 xv6 的情况下，引导程序位于 bootasm.S（汇编代码）和 bootmain.c（C 代码）中。 引导程序运行：接下来的步骤与实际硬件上的启动过程相同。引导程序首先切换到保护模式，然后加载 ELF 格式的 xv6 内核映像到内存中。 进入 xv6 内核：引导程序找到 xv6 内核的入口点（在 kernel/entry.S 中），并将控制权交给内核。内核现在开始运行并执行初始化任务。 内核初始化：在 main.c 中的 main() 函数中，xv6 内核执行诸如设置分页、初始化中断控制器、初始化进程调度器等初始化任务。 创建初始进程：xv6 创建第一个内核进程（initcode.S），它是一个用户程序，负责启动其他用户进程。内核通过 fork() 系统调用创建新进程，并通过 exec() 系统调用加载并执行 initcode.S。 运行 init 进程：initcode.S 调用 init 程序（在 init.c 中），init 是一个用户空间程序，负责启动系统的第一个正常用户进程，通常是一个 shell 程序。在 xv6 中，这个程序是 sh.c。 运行 shell 程序：init 进程通过 fork() 和 exec() 创建并运行 shell 程序。这时，用户可以在 shell 中输入命令并与操作系统进行交互。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"MIT6.S081 Operating System Engineering Lecture01 Intrduction and Examples","slug":"MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples","date":"2023-03-31T06:19:09.000Z","updated":"2023-04-06T07:00:08.730Z","comments":true,"path":"2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/","link":"","permalink":"http://example.com/2023/03/31/MIT6-S081-Operating-System-Engineering-Lecture01-Intrduction-and-Examples/","excerpt":"简介课程目标 理解操作系统的设计和实现。理解整体结构和具体代码。 通过XV6操作系统获得实际动手经验。扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件","text":"简介课程目标 理解操作系统的设计和实现。理解整体结构和具体代码。 通过XV6操作系统获得实际动手经验。扩展操作系统，修改并提升操作系统的相关经验，并且能够通过操作系统接口，编写系统软件 OS的目标 Abstract Hardware Multiplex Isolation Sharing Preformance Access Control&#x2F;Security Range Of Users OS的结构分层思想 Userspace在架构的最上层，运行各种各样的应用程序例如文本编辑器（VI），C编辑器（CC），作为CLI存在的shell。 Kernel区别于userspace，有一个特殊的程序总是会在运行。Kernel是计算机资源的守护者，当打开计算机时，Kernel总是第一个被启动。Kernel程序只有一个，维护数据来管理每一个用户空间进程。Kernel同时还维护了大量数据结构来帮助它管理各种各样的硬件资源，以供用户空间的程序使用。Kernel同时还会有大量内置的服务。例如，Kernel通常会有文件系统实现类似文件名，文件内容，目录的东西，并理解如何将文件存储在磁盘中。所以用户空间的程序会与Kernel中的文件系统交互，文件系统再与磁盘交互。 我们主要关注在Kernel、连接Kernal和用户空间程序的接口、Kernel内软件的架构 。所以我们会关心Kernel内的服务。其中一个是文件系统，另一个就是进程管理系统。 Manage Process：每一个用户空间程序都被称为一个进程，它们有自己的内存和共享的CPU时间。 Allocate Memory：Kernel会管理内存的分配，不同的进程需要不同数量的内存，Kernel会复用内存、划分内存，并为所有的进程分配内存。 File System：文件系统通常有一些逻辑分区。目前而言，我们可以认为文件系统的作用是管理文件内容并找出文件具体在磁盘中的哪个位置。文件系统还维护了一个独立的命名空间，其中每个文件都有文件名，并且命名空间中有一个层级的目录，每个目录包含了一些文件。所有这些都被文件系统所管理。 Security&#x2F;Access Control: 当一个进程想要使用某些资源时，比如读取磁盘中的数据，使用某些内存，Kernel中的Access Control机制会决定是否允许这样的操作。对于一个分时共享的计算机，例如Athena系统，这里可能会变得很复杂。因为在Athena系统中，每一个进程可能属于不同的用户，因此会有不同Access规则来约定哪些资源可以被访问。 在一个真实的完备的操作系统中，会有很多很多其他的服务，比如在不同进程之间通信的进程间通信服务，比如一大票与网络关联的软件（TCP&#x2F;IP协议栈），比如支持声卡的软件，比如支持数百种不同磁盘，不同网卡的驱动。所以在一个完备的系统中，Kernel会包含大量的内容，数百万行代码。 Kernel APIKernel API决定了应用程序如何访问Kernel。通常来说，这里通过系统调用System Call来完成。系统调用与程序中的函数调用看起来是一样的，但区别是系统调用会实际运行到系统内核中，并执行内核中对于系统调用的实现。 Kernel的代码总是有特殊的权限。当机器启动Kernel时，Kernel会有特殊的权限能直接访问各种各样的硬件，例如磁盘。而普通的用户程序是没有办法直接访问这些硬件的。所以，当你执行一个普通的函数调用时，你所调用的函数并没有对于硬件的特殊权限。然而，如果你触发系统调用到内核中，内核中的具体实现会具有这些特殊的权限，这样就能修改敏感的和被保护的硬件资源，比如访问硬件磁盘。 Example 112fd = open(&quot;out&quot;,1);write(fd,&quot;hello\\n&quot;,6); 第一个系统调用open，它会跳到Kernel，Kernel会获取到open的参数，执行一些实现了open的Kernel代码，或许会与磁盘有一些交互，最后返回一个文件描述符对象。上图中的fd全称就是file descriptor。之后应用程序可以使用这个文件描述符作为handle，来表示相应打开的文件。 第二个系统调用write，你需要向write传递一个由open返回的文件描述符作为参数。你还需要向write传递一个指向要写入数据的指针（数据通常是char型序列），在C语言中，可以简单传递一个双引号表示的字符串。第三个参数是你想要写入字符的数量。第二个参数的指针，实际上是内存中的地址。所以这里实际上告诉内核，将内存中这个地址起始的6个字节数据写入到fd对应的文件中。 Example 21pid = fork(); fork是一个系统调用，它创建了一个与调用进程一模一样的新的进程，并返回新进程的Process ID/PID。 这些系统调用看起来跟普通的函数调用一样，但是它最终会跳到系统内核中。 操作系统的难点 内核的编程环境比较困难。当你在编写、修改，扩展内核，或者写一个新的操作系统内核时，你实际上在提供一个基础设施让别人来运行他们的程序。当程序员在写普通的应用程序时，应用程序下面都是操作系统。而当我们在构建操作系统时，在操作系统下面就是硬件了，这些硬件通常会更难处理。 当你在设计一个操作系统时，你需要满足一些列矛盾的需求。 你想要你的操作系统既高效又易用。高效通常意味着操作系统需要在离硬件近的low-level进行操作，而易用则要求操作系统为应用程序提供抽象的high-level可移植接口。所以，提供一个简单可移植，同时又高效的抽象接口需要一定的技巧。 我们想要提供一个非常强大的操作系统服务，这样操作系统才能分担运行应用程序的负担。同时，我们也想要有简单的接口。我们不想程序员看到数量巨多，复杂且难以理解的的内核接口。因为，如果他们不理解这些接口，他们就会很难使用这些接口。 你希望给与应用程序尽可能多的灵活性，你不会想要限制应用程序，所以你需要内核具备灵活的接口。但是另一方面，你的确需要在某种程度上限制应用程序，因为你会想要安全性。我们希望给程序员完全的自由，但是实际上又不能是真正的完全自由，因为我们不想要程序员能直接访问到硬件，干扰到其他的应用程序，或者干扰操作系统的行为。 read，write，exit系统调用12345678910111213#inclued &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main()&#123; char buf[64]; while(1)&#123; int n = read(0,buf,sizeof(buf)); if(n &lt;= 0) break; write(1,buf,n); &#125; exit(0);&#125; read系统调用 第一个参数是文件描述符，实际上是对以前打开文件的引用。Shell会确保默认情况下，当一个程序启动时，文件描述符0为连接到console的输入，文件描述符1为连接到了console的输出。所以我们可以通过这个程序看到console打印我的输入。当然，这里的程序会预期文件描述符已经被Shell打开并设置好。 第二个参数是只想某段内存的指针，程序可以通过指针对应的地址读取内存中的数据，这里的指针就是代码中的buf参数。char buf[64]在栈中申请了64字节的内存，并将指针保存在buf中，这样read可以将数据保存在这64字节中。 第三个参数是代码想读取的最大长度。sizeof(buf)表示，最多读取64字节的数据，所以这里的read最多只能从连接到文件描述符0的设备，也就是console中，读取64字节的数据。 如果第三个参数是65字节，操作系统会拷贝65个字节到你提供的内存中（第二个参数）。但是如果栈中的第65个字节有一些其他数据，那么这些数据会被覆盖，这里是个bug，或许会导致你的代码崩溃，或者一些异常的行为。 read的返回值 可能是读到的字节数 如果从一个文件读数据，如果到达了文件的结尾没有更多的内容了，read会返回0。 如果出现了一些错误，比如文件描述符不存在，read或许会返回-1 。 write系统调用第一个参数为文件描述符，第二个参数是数据的指针，第三个参数是要写入的字节数 数据被写入到了文件描述符对应的文件中 open系统调用12345678#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fcntl.h&quot;int main()&#123; int fd = open(&quot;output.txt&quot;,O_WRONLY | O_CREATE); write(fd, &quot;ooo\\n&quot;,4); exit(0);&#125; 这个程序会创建一个叫做output.txt的新文件，并向它写入一些数据，最后退出。我们看不到任何输出，因为它只是向打开的文件中写入数据，但是我们可以查看output.txt的内容，并看到open程序写入的“ooo”。 所以执行open系统调用，将out.txt作为参数传入，第二个参数是一些标志位，用来告诉open系统调用在内核中的实现，用来告诉open系统调用在内核中的实现：我们将要创建并写入一个文件。open系统调用会返回一个新分配的文件描述符，这里的文件描述符是一个小的数字，可能是2，3，4或者其他的数字。然后将文件描述符传入write中。 文件描述符本质上对应了内核中的一个表单数据。内核维护了每个运行进程的状态，内核会为每一个运行进程保存一个表单，表单的key是文件描述符。这个表单让内核知道，每个文件描述符对应的实际内容是什么。这里比较关键的点是，每个进程都有自己独立的文件描述符空间，所以如果运行了两个不同的程序，对应两个不同的进程，如果它们都打开一个文件，它们或许可以得到相同数字的文件描述符，但是因为内核为每个进程都维护了一个独立的文件描述符空间，这里相同数字的文件描述符可能会对应到不同的文件。 C语言与Python在文件描述符中的区别：Python提供了对与open调用的较好的封装，通常来说，Python提供的是更高级的函数，比如说Python不会使用指向内存的指针，并且Python会为你做更多的错误检查。当我们在Python中打开文件或者写入文件时，你在Python中的调用最终会走到跟我们例子中一样的系统调用。 ShellShell通常也是人们说的命令行接口。如果你还没有用过Shell，Shell是一种对于Unix系统管理来说非常有用的接口，它提供了很多工具来管理文件，编写程序，编写脚本。当你输入内容时，你是在告诉Shell运行相应的程序。 1ls ls的实际工作就是输出当前目录的文件列表 1ls &gt; out Shell允许重定向IO，这里的实际意义是要求Shell允许ls命令，但是将输出重定向到一个叫做out的文件中。这里执行完成之后我们看不到任何的输出，因为输出都送到了out文件。 1cat out 我们可以通过cat指令来读取一个文件，并显示文件的内容，之后我们可以看到ls指令相同的输出。 1grep x 你也可以运行一个名为grep的指令，并将x作为参数传给grep。 1grep x &lt; out grep x会搜索输入中包含x的行，我可以告诉shell将输入重定向到文件out，这样我们就可以查看out中的x。因为out文件包含了ls的输出，所以我们可以看出有3个文件名包含了x。 编译器如何处理系统调用？生成的汇编语言是不是会调用一些由操作系统定义的代码段？ 有一个特殊的RISC-V指令，程序可以调用这个指令，并将控制权交给内核。所以，实际上当你运行C语言并执行例如open或者write的系统调用时，从技术上来说，open是一个C函数，但是这个函数内的指令实际上是机器指令，也就是说我们调用的open函数并不是一个C语言函数，它是由汇编语言实现，组成这个系统调用的汇编语言实际上在RISC-V中被称为ecall。这个特殊的指令将控制权转给内核。之后内核检查进程的内存和寄存器，并确定相应的参数。 fork系统调用123456789101112#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main()&#123; int pid; pid = fork(); printf(&quot;fork() returned %d\\n&quot;,pid); if(pid == 0)&#123; printf(&quot;child\\n&quot;); &#125; else &#123; printf(&quot;parent\\n&quot;); &#125;&#125; fork会拷贝当前进程的内存，并创建一个新的进程，这里的内存包含了进程的指令和数据。之后我们就有了两个完全一样的内存的进程。fork系统调用在两个进程中都会返回，在原始的进程中，fork会返回大于0的整数，这个是新创建进程的ID。而在新创建的进程中，fork系统调用会返回0。所以即使两个进程的内存是完全一样的，我们还是可以通过fork的返回值区分旧进程和新进程。 返回 ffoorrkk(()) rreettuuttnende d 0 lc9h ilpda rent if（pid == 0），你可以看到代码检查pid。如果pid &#x3D; 0，这必然是子进程。在我们的例子中，调用进程通常称为父进程，父进程看到的pid必然大于0.所以父进程会打印“parent”,子进程会打印”child”。之后两个进程都会退出。 输出结果，实际发生二点是，fork系统调用之后，两个进程都在同时运行。它们会同时一个字节一个字节的输出，两个进程的输出交织在一起，所以你可以看到两个f，两个o等等。在第一行最后，你可以看到0，这是子进程的输出。 我猜父进程返回了19，作为子进程的进程ID。通常来说，这意味着这是操作系统启动之后的第19个进程。之后一个进程输出了child，一个进程输出了parent，这两个输出交织在一起。虽然这只是对于fork的一个简单应用，但是我们可以清晰的从输出看到这里创建了两个运行的进程，其中一个进程打印了child，另一个打印了parent。所以，fork（在子父进程中）返回不同的值是比较重要的。 父进程与子进程除了fork的返回值，两个进程是一样的。两个进程的指令是一样的，数据是一样的，栈是一样的，同时，两个进程又有各自独立的地址空间，它们都认为自己的内存从0开始增长，但这里是不同的内存。 在一个更加复杂的操作系统，有一些细节，我们现在并不关心，这些细节偶尔会导致父子进程不一致，但是在XV6中，父子进程除了fork的返回值，其他都是一样的。 除了内存是一样的以外，文件描述符的表单也从父进程拷贝到子进程。所以如果父进程打开了一个文件，子进程可以看到同一个文件描述符，尽管子进程看到的是一个文件描述符的表单的拷贝。除了拷贝内存以外，fork还会拷贝文件描述符表单。 exec，wait系统调用fork创建了一个新的进程。当我们在shell中运行东西的时候，shell实际上会创建一个新的进程来运行你输入的每一个指令。所以，当我输入ls时，我们需要shell通过fork创建一个进程来运行ls，这里需要某种方式来让这个新的进程来运行ls程序中的指令，加载名为ls的文件中的指令，也就是exec系统调用。 12345678910// exec.c:replace a process with an executable file#include &quot;kernel.types.h&quot;#include &quot;user/user.h&quot;int main()&#123; char *argv[] = &#123; &quot;echo&quot;, &quot;this&quot;, &quot;is&quot;, &quot;echo&quot;, 0 &#125;; exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(0);&#125; 代码会执行exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。所以系统调用exec会有这样的效果：操作系统从名为echo的文件中加载指令到当前的进程中，并替换了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec允许你传入一个命令行参数的数组，这里就是一个C语言中的指针数组，在上面代码设置好了一个字符指针的数组，这里的字符指针本质就是一个字符串（string） echo 程序是一个常见的命令行实用程序，用于在 Unix、Linux 和类 Unix 系统（如 macOS）上显示文本。它将传递给它的命令行参数（字符串）输出到标准输出（通常是终端或控制台）。echo 命令通常用于编写脚本或在控制台显示消息。 通过 exec(&quot;echo&quot;, argv); 系统调用执行。在这个例子中，argv 数组包含以下参数： 12345argv[0] = &quot;echo&quot;argv[1] = &quot;this&quot;argv[2] = &quot;is&quot;argv[3] = &quot;echo&quot;argv[4] = NULL (空指针) 通常，argv[0] 是程序名称（在这里是 “echo”），后面是实际要传递的命令行参数（在这里是 “this”, “is”, “echo”）。argv 数组以空指针（NULL）结尾，表示参数列表的结束。 当 echo 程序执行时，它会输出 &quot;this is echo&quot;。 exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。 通常来说exec系统调用不会返回，因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了,在实例代码中，执行错误才会返回。 这就是一个程序如何用文件中的另一个程序来替代自己。实际上，当我们在Shell中运行类似于“echo a b c”的指令，或者ls，或者任何命令，我们不会想要代替Shell进程，所以我们不会希望Shell执行exec系统调用。如果我们这么做了，这里会用echo指令来替代Shell进程，当echo退出了，一切就结束了。所以我们不想要echo替代Shell。实际上，Shell会执行fork，之后fork出的子进程再调用exec系统调用，这是一个非常常见的Unix程序调用风格。对于那些想要运行程序，但是还希望能拿回控制权的场景，可以先执行fork系统调用，然后在子进程中调用exec。 1234567891011121314151617181920// forkexec.c: fork then exec#include &quot;user/user.h&quot;int main()&#123; int pid, status; pid = fork(); if(pid == 0) &#123; char *argv[] = &#123;&quot;echo&quot; ,&quot;THIS&quot; ,&quot;IS&quot; ,&quot;ECHO&quot;, 0 &#125;; exec(&quot;echo&quot;, argv); printf(&quot;exec failed!\\n&quot;); exit(1); &#125;else &#123; printf(&quot;parent waiting\\n&quot;); wait(&amp;status); printf(&quot;the child exited with status %d\\n&quot;,status); &#125; exit(0);&#125; fork系统调用会创建一个新的子进程，是当前进程的一个副本。 如果pid == 0，即进程是子进程，则会调用echo程序，输出&quot;THIS IS ECHO&quot;，如果错误则返回1。并且子进程在echo程序执行结束之后就会退出。，之后继续进行父进程。 父进程会先输出“parent waiting\\n”，之后使用wait系统调用，等待子进程返回，将子进程返回的状态传入status，&amp;status，是将status对应的地址传递给内核，内核会向这个地址写入子进程向exit传入的参数。 如果一个子进程退出成功了，那么exit的参数会是0，如果出现了错误，会向exit传入1。所以父进程读取的wait的参数取决于子进程是否成功的完成了。 I&#x2F;O Redirect1echo hello &gt; out Shell会将echo的输出送到文件out 1cat &lt; out 之后可以运行cat指令，并将out指令作为输入，之后保存在out文件中的内容就是echo指令的输出 Shell首先会先fork然后在子进程中，Shell改变了文件描述符。文件描述符1用来console输出，Shell会将文件描述符1改为output文件，之后再运行你的指令。同时，父进程的文件描述符1并没有改变。所以这里先fork再改变子进程的文件描述符。 123456789101112131415161718//redirect.c: run a command with output redirectedint main()&#123; int pid; pid = fork(); if(pid == 0) &#123; close(1); open(&quot;output.txt, O_WRONLY|O_CREATE&quot;); char *argv[] = &#123;&quot;echo&quot;, &quot;this&quot; ,&quot;is&quot; ,&quot;redirect&quot;, &quot;echo&quot;, 0 &#125;; exec(&quot;echo&quot;,argv); printf(&quot;exec failed!\\n&quot;) &#125; else &#123; wait((int *) 0); &#125;&#125; 在if(pid == 0)中，先检查pid的值，如果pid为0（在子进程中），则首先close(1),close(1)的意义是，我们希望文件描述符1指向一个其他的位置。也就是说，在子进程中我们不想使用原本指向console输出的文件描述符1，即关闭标准输出。 使用 open(&quot;output.txt&quot;, O_WRONLY | O_CREAT, 0666); 打开或创建名为 “output.txt” 的文件，以只写模式（O_WRONLY）打开，并设置创建模式（0666，表示所有用户都可以读写此文件）。这将使得新打开的文件描述符成为子进程的标准输出。 使用 exec(&quot;echo&quot;, argv); 系统调用，替换子进程的映像为 echo 程序，并传递 argv 参数列表。 如果 exec 调用失败，输出 “exec failed!”。 在父进程中，调用 wait((int *)0); 函数，等待子进程结束。 当运行此程序时，它将执行 echo 命令，并将输出 “this is redirect echo” 重定向到 “output.txt” 文件。如果文件已存在，它将覆盖现有内容；如果文件不存在，它将创建一个新文件。","categories":[{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"论文阅读 A Study on the Security Implications of Information Leakages in Container Clouds","slug":"论文阅读 A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds","date":"2023-03-30T14:40:21.000Z","updated":"2023-04-15T05:07:00.036Z","comments":true,"path":"2023/03/30/论文阅读 A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/","link":"","permalink":"http://example.com/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20A-Study-on-the-Security-Implications-of-Information-Leakages-in-Container-Clouds/","excerpt":"摘要Container technology提供了一个轻量级的操作系统虚拟主机环境。Container technology的出现深刻的改变了多层分布式应用的开发和部署范式（paradigms of multi-tier distributed applications）。然而，由于Linux系统内核中的系统资源隔离机制没有完全实现（system resource isolation mechanisms），在一个基于container的多租户云服务（multi-tenancy container-based cloud service）中，一些安全问题仍然存在。在本文，我们首先介绍了可以在containers内访问的信息泄露渠道。这些渠道暴露了一系列的系统范围的主机信息给没有适当资源分区的containers。通过利用泄露的主机信息，作为租户在container cloud中的恶意的攻击者就会更容易的发起可能影响云服务的可靠性的安全攻击。我们证明了信息泄露渠道将会被利用于推断隐私数据，检测和验证co-residence，建立隐蔽通道，发动更高级的基于云的攻击。我们讨论了container中的信息泄露的根本原因，并提出了一个两阶段的防御方法。正如评估中所证明的，我们的防御是有效的，并且性能开销非常小。 Introduction","text":"摘要Container technology提供了一个轻量级的操作系统虚拟主机环境。Container technology的出现深刻的改变了多层分布式应用的开发和部署范式（paradigms of multi-tier distributed applications）。然而，由于Linux系统内核中的系统资源隔离机制没有完全实现（system resource isolation mechanisms），在一个基于container的多租户云服务（multi-tenancy container-based cloud service）中，一些安全问题仍然存在。在本文，我们首先介绍了可以在containers内访问的信息泄露渠道。这些渠道暴露了一系列的系统范围的主机信息给没有适当资源分区的containers。通过利用泄露的主机信息，作为租户在container cloud中的恶意的攻击者就会更容易的发起可能影响云服务的可靠性的安全攻击。我们证明了信息泄露渠道将会被利用于推断隐私数据，检测和验证co-residence，建立隐蔽通道，发动更高级的基于云的攻击。我们讨论了container中的信息泄露的根本原因，并提出了一个两阶段的防御方法。正如评估中所证明的，我们的防御是有效的，并且性能开销非常小。 Introduction云计算已经广泛的运用于整合计算机资源。多租户是云计算的有利特征，允许来自不同租户的计算实例在同一物理服务器上运行。在不同类型的云服务中，多租户容器云最近作为传统的以云基础设施为基础的虚拟机VM的轻量级替代品出现。容器是一种OS级的虚拟化技术，在Linux内核中有多个building blocks，包括资源隔离&#x2F;控制技术（如namespace和cgroup）和安全机制（如Capabilities，SELinux，AppArmor和seccomp）。通过避免additional abstraction layers的开销，容器能够实现接近原生的性能，并且在几乎所有方面都超过了基于虚拟机的系统。除此之外，容器管理和orchestration系统的出现，如Docker和Kubernetes，深刻的改变了在云上构建、运输和部署多层分布式应用的生态系统。 尽管容器服务很成功，但是在同一个操作系统内核上运行多个可能属于不同租户的容器，始终存在安全和隐私问题。为了支持容器云上的多租户，Linux内核正在进行跨容器隔离和取消特权用户级别容器的努力。现有的容器启用内核功能大大缩小了暴露给容器租户的攻击面，并且可以限制大多数现有的恶意攻击。然而，并不是所有的Linux内核的子系统都能够区分容器和主机之间的执行上下文，因此它们可能会向容器化应用程序公开系统范围的信息。一些子系统被认为对容器适应性的优先级较低。其余的子系统面临着将代码库转换成容器形式的实现困难，并且它们的维护者不愿意接受激烈的变化。为了关闭这些漏洞，当前容器运行时软件和容器云提供商通常利用访问控制策略来隐藏这些与容器无关的子系统用户内核接口。然而，这种手动和临时修复只能覆盖一小部分暴露出来的攻击面。 在本文中，我们系统地探索和识别可能意外暴露主机操作系统和co-residence容器信息的容器内泄漏通道。这些信息泄漏包括主机系统状态信息（例如功耗、性能数据、全局内核数据和异步内核事件）以及单个进程执行信息（例如进程调度、cgroups 和进程运行状态）。在特定时间点暴露的区分特征信息可以帮助唯一地识别物理机器。此外，恶意租户可以通过提前获取系统范围的知识来优化攻击策略并最大化攻击效果。我们在 Docker 和 LinuX 容器 (LXC) 上的本地测试平台上发现了这些泄漏通道，并验证了它们在五个公共商业多租户容器云服务上（部分）存在。 我们证明了那些信息泄露渠道存在多个安全隐患。总的来说，尽管被挂载为只读，这些通道仍然会被恶意的容器租户利用来推断同一物理机上其他容器的私有数据，检测和验证共存关系，并建立隐蔽通道以偷偷地传输信息。我们提出了几种技术，攻击者可以通过利用那些信息泄露渠道来推断co-residence。与基于缓存的隐蔽信道等传统方法相比，我们的方法对云环境中的噪声更具韧性。我们根据它们的风险等级对这些通道进行排名。我们发现在容器实例中的活动会影响多个通道的系统范围的内的values。通过对运行在容器中的工作负载进行专门操作，攻击者可以实现可靠和高速的隐蔽通道，以突破云部署中采用的隔离机制。例如，通过故意获取和释放锁而不产生网络活动，从而攻击者可以在容器之间隐蔽的传输比特。这些泄露的信息可以被同一物理机上的所有容器观察到。为了揭示这些泄漏通道的安全风险，我们采用不同技术构建了两个隐蔽通道，并在真实的多租户云环境中测试它们的带宽。 我们进一步设计出了一种先进的攻击，称为synergistic power attack，来利用通过这些通道的看似无害的信息。我们证明这样的信息暴露可以极大地放大攻击效果，降低攻击成本，简化攻击编排。power attacks已被证明对现有的数据中心有事实的威胁。如果没有基础云架构运行状态的信息，现有的power attack只能盲目的启动power-intensive workloads，希望高峰能够触发branch circuit breakers来导致power outages。这样的攻击可能costly并且ineffective。 然而，通过学习系统范围内的状态信息，攻击者可以选择 选择最佳时机发动攻击，也就是，在现有的power峰值下，由benign workloads触发，通过增加power-intensive workload来进行攻击。 通过检测被控制的容器的proximity-residence，同步对同一物理机&#x2F;机架的多次power attacks。我们在一个真实的容器云服务上进行了proof-of-concept实验 ，并定量证明了我们的攻击能够以更低的成本产生更高的power峰值。 我们进一步深入分析了这些泄漏渠道的根本原因，并发现是Linux内核中容器implementation的incomplete coverage所致。我们提出了一个两阶段的防卫机制来解决这个在容器云上的问题。特别是，为了防卫synergistic power attacks，我们设计并实现了一个power-based namespace，在Linux内核中对power进行更细粒度（容器）级别的划分。我们和准确性，安全性和性能开销的角度评估了我们的power-based namespace。我们的实验结果表明，我们的系统可以在很小的系统开销下抵御container-based power attack。 BackgroundLinux Kernel Support for Container Technology容器依赖于多个独立的Linux内核组件来实现用户空间实例之间的隔离。与基于虚拟机的虚拟化方法相比，多个容器共享同一个操作系统内核，从而消除了启动和维护虚拟机所需的额外性能开销。容器在业界受到了广泛关注，并在近年来迅速发展，以提高应用程序性能、增强开发人员效率和促进服务部署。在这里，我们介绍两种关键技术namespace和cgroup，它们使得Linux上的容器化成为可能。 Namespace第一个namespace在Linux内核2.4.19中被引入。namespace的关键思想是为一组进程隔离和虚拟化系统资源，这些形成一个容器。每个进程可以与多个不同类型的namespace联系。内核为每个进程提供了一个基于namespace类型的定制化系统资源视图。对任何namespace系统资源的修改都会被限制在相关联的namespace里面，因此不会造成整个系统范围内的修改。 现有的内核有七种不同的namespace：mount（MNT）namespace，UNIX timesharing system （UTS）namespace，PIDnamespace， network（NET） namespace，interprocess communications（IPC）namespace，USER namespace，and CGOUP namespace MNT namespace：隔离一组文件系统mount point。在不同的MNT namespace中，进程对文件系统层次结构有不同的视图。 UTS namespace：每个容器都有自己的主机名和域名，因此一个容器可以被视为独立节点。 PID namespace：虚拟化进程标识符（pids），每个进程有两个pid：在其namespace中有一个pid，在主机上有一个（全局唯一）pid。 NET namespace：包含独立的虚拟网络设备、IP地址、端口和IP路由表。IPC命名空间隔离了进程间通信资源，包括信号、管道和共享内存。 IPC namespace：隔离进程间通信资源，包括信号、管道和共享内存。 USER namespace：引入了用户和组ID号空间的隔离。它在容器内创建一个根用户到主机上非特权用户之间的映射关系。因此，进程可以在用户命名空间内拥有完全权限，但在主机上则被削弱了权限。 CGROUP namespace：虚拟化cgroup资源，每个进程只能通过cgroupfs挂载和/proc/self/cgroup文件获得容器化的cgroup视图。 Cgroup在Linux内核中，cgroup（control group）提供了一种机制，将进程和所有它们的子进程的group分层为具有可控行为的分层group。容器利用cgroup功能，对每个容器实例应用每个cgroup资源限制，从而防止单个容器耗尽主机资源。这些受控资源包括CPU、内存、块IO、网络等。在云计算的计费模型中，cgroup也可以用于为每个容器分配相应的资源并记录它们的使用情况。每个cgroup子系统提供了一个统一的sysfs接口，以简化用户空间中的cgroup操作。 Container Cloud有了这些可用于资源隔离和管理的内核功能，Linux 内核可以在操作系统级别提供轻量级虚拟化功能。未来预计会将更多的namespace和 cgroup 子系统合并到upstream Linux 内核中，以增强容器安全性。近年来，随着容器运行时软件的成熟，容器化已成为虚拟托管的流行选择。LXC 是第一个完整实现于 2008 年构建的 Linux 容器管理器。Docker 建立在 LXC（现在使用 libcontainer）之上，在最近几年已成为最受欢迎的容器管理工具。Docker 可以将应用程序及其依赖项（例如代码、运行时、系统工具和系统库）打包到镜像中，从而保证应用程序在不同平台上表现一致。许多云服务提供商已经提供了容器云服务，其中包括 Amazon ECS、IBM Bluemix、Microsoft Azure 和 Google Compute Engine 等等。对于多租户容器云服务来说，容器可以运行在裸机物理机或虚拟机上。无论是哪种情况下，不同租户的容器都与主机操作系统共享相同的 Linux 内核。 Covert Channels隐蔽通道利用共享资源来打破隔离机制，从而使孤立的实体之间能够进行通信。具有隐秘性的隐蔽通道可用于检索敏感信息并绕过标准通道上的访问控制。广泛认为，即使在虚拟机和容器强制执行隔离技术的情况下，今天的云环境也容易受到隐蔽通道攻击。已经提出了各种技术来建立多租户云环境中的隐蔽通道。Ristenpart等人报告了在公共云中利用共享L2数据缓存达到0.2bps 的比特率。Xu等人使用VM之间的最后一级缓存，在Amazon EC2 环境中构建带宽为3.2bps 的隐藏信道。Wu等人通过利用内存总线上发生竞争实现110 bps 和误码率为0.75% 的隐藏信道。Masti等人成功地通过获取芯片传感器读数来构建隐藏信道，并以12.5bps 的比特率进行传输；Bartolini等人将基于温度的隐藏信道改进至相邻核心50bps 。在云环境中，除了泄露敏感数据的威胁外，隐蔽通道还可以进一步被滥用来检测和验证共存性，这是大多数基于云的攻击的前提条件。通过成功地通过隐蔽通道传输信息，攻击者可以确认两个实例是否在同一主机服务器上co-residence。因此，为了通过构建强大的防御机制来保护云端安全，发现新技术以构建隐蔽通道是一个重要步骤，并已经得到先前研究的密切关注。 Power Attacks on Data Centerspower attacks已经被证明对现有的云基础设施有事实的威胁。考虑到升级power设施的成本，当前数据中心普遍采用power oversubscription来在现有电力供应能力范围内托管尽可能多的服务器。安全保障是基于这样一个假设：相邻的多个服务器同时达到峰值功耗的概率很低。虽然功率超额订阅允许部署更多服务器而不增加电源容量，但降低了电源冗余性，增加了停电可能性，这可能导致同一机架或同一配电单元（PDU）上的服务器被迫关闭。即使正常工作负载也可能产生引起停电的功率峰值。Facebook最近报告称，在2016年的六个月内预防了18次潜在停电事件。如果恶意对手故意投放“能量病毒”发动攻击，则情况将更为严重。停电带来的后果可能是灾难性的，例如Delta Airlines在2016年8月遭遇数据中心断电事件，导致大规模航班延误和取消。最近研究表明，无论是传统还是备用式数据中心都可以进行 power 攻击。 发起一个成功的power attack 需要三个关键因素： 通过合法订阅服务得到目标数据中心的服务器访问权限 稳定的运行适度的工作负载，以增加服务器功耗至其上限。 突然切换到耗电量大的工作负载以触发功率峰值。通过在短时间窗口内引起功率峰值，断路器可以被跳闸以保护服务器免受过流或过载造成的物理损害。 断路器的跳闸条件取决于power峰值的强度和持续时间。为了最大化攻击效果，攻击者需要在同一机架或者PDU所属的一组服务器上运行恶意工作负载。此外，发动攻击的时机也至关重要。如果数据中心的特定的一组服务器（例如，位于同一机架上）已经运行在其峰值功率状态下，则发动成功的power attack的可能性更高。 power 限制技术旨在防御power attack。在机架和PDU级别上，通过监控power消耗，数据中心可以通过基于功率的反馈环路限制服务器的功耗。在主机级别上，Running Average Power Limit(RAPL)是一种用于监视和限制单个服务器功耗的技术。自Sandy Bridge微体系结构以来，Intel引入了RAPL。它提供微秒级细粒度CPU级能源计量，并可用于限制一个包的功耗。 power限制机制显著缩小了功率攻击面，但它无法解决power oversubscription的问题，这是数据中心停电的根本原因。虽然单个服务器的主机级功率限制可以立即响应power surface，但机架或PDU级别的功率限制机制仍会遭受分钟级延迟。假设攻击者可以将电源病毒部署到物理相邻的服务器中，即使每个服务器消耗的电力低于其功率上限，所控制服务器总体聚合后的能量消耗仍可能超过供电容量并触发断路器。我们在以下章节中证明恶意容器租户可以通过控制其高能耗工作负载的部署和利用背景下良性工作负载来放大他们的power attack。 Information Leakages In Container CloudsLinux内核为容器抽象提供了大量支持以实现资源隔离和控制。这些内核机制是在多租户云上运行容器的启用技术。由于优先级和困难程度，Linux内核的某些组件尚未转化为支持容器化。我们打算系统地探索哪些部分的内核没有覆盖，根本原因是什么以及潜在对手如何利用它们。 Container Information Leakages我们首先在本地安装了Docker和LXC容器，并在Linux机器上进行实验。系统设置为默认配置，所有容器都以用户特权启动，与商业容器云类似。Linux提供了两种从用户空间进程到内核的受控接口：系统调用和基于内存的伪文件系统。系统调用主要设计用于用户进程请求内核服务。这些系统调用具有严格的公共接口定义，并通常向后兼容。然而，基于内存的伪文件系统更灵活，可扩展内核功能（例如ioctl），访问内核数据（例如procfs）并调整内核参数（例如sysctl）。此外，这样的伪文件系统使得通过正常文件I&#x2F;O操作操纵内核数据成为可能。Linux有许多基于内存的伪文件系统（例如，procfs、sysfs、devfs、securityfs、debugfs等），这些文件系统服务于不同的内核操作目的。我们更感兴趣的是procfs和sysfs，默认情况下由容器运行时软件挂载。 如图所示，我们设计了一个交叉验证工具，自动发现这些将主机信息暴露给容器的基于内存的伪文件。关键思想是在两个执行上下文中递归探索procfs和sysfs下所有伪文件，在一个未经特权处理的容器中运行，并在主机上运行另一个。我们根据它们的路径对齐并重新排序这些文件，然后对相同内容之间进行成对差分分析。如果从特定虚拟文件访问到的系统资源没有被Linux内核namespace化，则主机和容器会达到相同片段（如图中❷的情况）。否则，如果正确namespace化，则容器可以检索到自己的私有和定制内核数据（如图中❶的情况）。使用这个交叉验证工具，我们可以快速识别可能将系统范围主机信息暴露给容器的伪文件（及其内部内核数据结构）。 Leakage Channel Analysis我们在表中列出了可能泄露主机信息的所有伪文件。这些泄漏渠道包含主机信息的不同方面。容器用户可以检索内核数据结构（例如，/proc/modules显示加载模块列表），内核事件（例如，/proc/interrupts显示每个IRQ的中断数）和硬件信息（例如，/proc/cpuinfo和/proc/meminfo分别显示CPU和内存规格）。此外，容器用户还可以通过某些通道获取性能统计数据。例如，容器可以通过RAPL sysfs接口获得硬件传感器数据（如果这些传感器在物理机上可用），如每个package、核心和DRAM的功耗，并通过数字温度传感器(DTS)sysfs接口获得每个核心的温度。此外，处理器、内存和磁盘I&#x2F;O的使用情况也暴露给容器。虽然乍一看泄露这样的信息似乎无害，但恶意对手可能利用它来发动攻击。 我们通过检查内核代码（在Linux内核版本4.7中）进一步调查了这些信息泄漏的根本原因。通常，泄漏问题是由于内核中namespace实现不完整引起的。更具体地说，我们总结了两个主要原因如下：（1）对于现有namespace缺少context check，以及（2）某些Linux子系统没有（完全）进行namespace隔离。我们提供了两个案例研究，分别是容器中的net prio.ifpriomap和RAPL，以揭示泄漏源头。 Case study 1 - net_prio.ifpriomap伪文件net prio.ifpriomap（位于/sys/fs/cgroup/net prio下）包含了一个映射，该映射将从cgroup中的进程开始并离开系统的流量分配给不同接口。数据格式为[ifname priority]。我们发现，在net prio.ifpriomap上挂钩的内核处理程序函数不知道NET命名空间，因此它向容器化应用程序披露物理机器上所有网络接口。更具体地说，net prio.ifpriomap的读操作由read_priomap函数处理。从这个函数跟踪，我们发现它调用for_each_netdev_rcu，并将第一个参数设置为init_net地址。它迭代主机的所有网络设备，而不考虑NET命名空间。因此，在容器视图中，可以读取主机所有网络设备名称。 Case study 2 - RAPL in containersRAPL是英特尔最近推出的用于设置单个服务器处理器包和DRAM功率限制的技术，可以在毫秒级别响应。在容器云中，RAPL sysfs接口位于/sys/class/powercap/intel-rapl，容器可以访问该接口。因此，容器租户可以通过这个sysfs接口获取主机的系统范围内电源状态，包括核心、DRAM和package等。例如，容器用户可以从伪文件energy uj中读取当前微焦耳能量计数器值。Intel RAPL Linux驱动程序中energy uj的函数处理程序是get_energy_counter。该函数从RAPL MSR检索原始能量数据。由于尚未实现功率数据名称空间，则energy_raw指针引用主机的能量消耗数据。 我们进一步调查了采用Docker&#x2F;LXC容器引擎的容器云服务中存在的信息泄漏问题。我们选择了五个商业公共多租户容器云服务进行泄漏检测，并在表中呈现结果。在云提供商修补通道之前，我们对这些容器云服务的名称（CCi代表第i个Container Cloud）进行匿名化处理。如果结果与我们的容器实例配置不一致，则确认泄露存在。黑点表示通道不存在于该云中，而白点表示通道存在于该云中。我们发现大多数本地机器上的泄露渠道也可以在容器云服务上使用。其中一些由于缺乏特定硬件支持而无法使用（例如Sandy Bridge之前的英特尔处理器或不支持RAPL技术的AMD处理器）。对于CC5，我们发现某些通道信息与本地测试平台不同，这意味着云供应商已经定制了一些额外限制条件。例如，只有属于租户核心和内存相关信息是可用的。然而，这些渠道部分泄露主机信息仍可能被高级攻击者利用, 我们将它们标记为黑白点。 Inference of Co-resident Container我们进一步深入研究特定案例，以查看它们是否可以被利用来检测共存容器 Co-residence problems in cloud settingsCo-residence是云安全中一个众所周知的研究问题。为了提取受害者的信息，攻击者倾向于将恶意实例移动到与受害者相同的物理主机上。Zhang等人已经证明，攻击者可以使用共存实例劫持用户帐户并提取私钥。 此外，实现Co-residence的成本相当低。由于意图整合服务器资源和降低成本，Co-residence仍然是现有云中存在的问题。验证Co-residence的传统方法基于缓存或基于内存泄漏通道。这些方法的准确性可能会因云环境中高噪声而下降。 Approaches and results of checking co-resident containers由于容器可以通过我们发现的泄漏通道读取主机信息，因此我们倾向于测量某些通道是否可用于检查容器共存。我们定义了三个指标，即唯一性（U）、变化性（V）和操作性（M），以定量评估每个通道推断共存的能力。指标 U 表示该通道是否赋予特征数据，可以唯一地识别主机。这是确定两个容器是否位于同一主机最重要和准确的因素。我们已经发现了 17 个泄漏通道，满足这种度量标准。一般来说，我们可以将这些渠道分类为三组： 包含唯一静态标识符的渠道。例如，在/proc/sys/kernel/random 下的引导 ID 是在启动时生成的随机字符串，并且对于每个运行内核都是唯一的。如果两个容器可以读取相同的引导 ID，则明显表示它们正在运行在同一个主机内核上。此组中渠道数据既是静态又是独特的。 容器租户可以动态植入独特签名到其中的渠道 。例如，在/proc/sched debug中 ，容器用户可以通过此接口检索所有活动进程信息的主机 。租户可以在容器内部启动一个带有独特制作的任务名称的进程。从其他容器中，他们可以通过在自己的 sched debug 中搜索此任务名称来验证共存。类似情况适用于计时器列表和锁。 包含唯一动态标识符的渠道。例如，在/proc/uptime中有两个数据字段：系统运行时间和自引导以来的系统空闲时间（以秒为单位）。它们是累积值，并且对于每台主机都是唯一的。同样，RAPL sysfs 接口中的能量 uj 是微焦耳中累积能量计数器 。从该组通道读取到 的 数据 在实时更改 ，但仍然是独特的代表主机 。我们根据其增长率对该组通道进行排名。较快的增长速度表示重复几率较低。 度量V可以展示数据是否随时间变化。有了这个特性，两个容器可以同时定期地对该伪文件进行快照。然后，它们可以通过检查两个数据快照跟踪是否相互匹配来确定co-residence关系。例如，从同一时刻开始，在一分钟内每秒钟记录/proc/meminfo中的MemFree在两个容器中。如果这两个60点数据跟踪彼此匹配，则我们有信心认为这两个容器运行在同一个主机上。每个通道包含不同的信息推断共存的能力，可以通过联合香农熵自然地测量。我们用公式（1）定义熵H。 每个多重独立数据字段Xi，n表示独立数据字段的数量。每个Xi都有可能的值{xi1，· · · ，xim}。我们根据表中的熵结果对能够揭示co-residence能力的九个通道（其中U&#x3D;False且V&#x3D;True）进行排名。 指标M表示容器租户是否可以操作数据。如果租户可以直接将特制的数据嵌入通道中，我们会对其进行标记为黑色。例如，我们可以在容器内创建一个带有特殊任务名称的计时器程序。该任务名称及其关联的计时器将出现在/proc/timer列表中。另一个容器可以搜索计时器列表中的此特殊任务名称以验证共存性。如果租户只能间接影响此通道中的数据，则我们会标记为黑白色。例如，攻击者可以使用taskset命令将计算密集型工作负载绑定到特定核心，并从另一个容器检查CPU利用率、功耗或温度等信息。这些条目可能被高级攻击者利用作为隐蔽信道来传输信号。 对于那些没有这些 U V M 属性的通道，我们认为它们很难被利用。例如，在云数据中心中，大多数服务器可能安装了相同的操作系统分发版和相同的模块列表。虽然 /proc/modules泄漏了主机上加载模块的信息，但是使用此通道推断co-resident容器是困难的。 Constructing Covert Channels包含manipulation（M）的通道可以进一步利用，以在两个容器之间建立隐蔽通道。我们证明了这些信息泄漏通道中的动态标识符和性能数据都可以被滥用来传输信息。特别地，我们实现了两个通道并测试它们的吞吐量和错误率。 Covert channel based on unique dynamic identifiers我们以/proc/locks为例来演示隐蔽通道可以构建在唯一动态标识符之上。通道/proc/locks显示了操作系统中所有锁信息的概述，包括锁类型、相应的进程以及inode号。 这种泄漏也破坏了 pid命名空间，因为所有锁的全局pid都被泄露了。Linux内核的维护者在4.9版本中部分修复了/proc/locks。内核4.9版本中部分修复了/proc/locks，将当前pid命名空间中的所有pid屏蔽为零。然而，其他信息，如锁的数量和节点信息仍然在容器。 我们构建了一个基于/proc/locks的隐蔽通道。具体来说，发送方可以lock一个文件来表示1，并释放lock来表示0。虽然lock和文件不在容器之间共享，但接收器可以在/proc/locks中检查lock的存在。通过不断检查特定lock的状态，可以传输信息。此外，可以同时设置多个lock以传输多个比特。为了建立可靠的高带宽隐蔽信道，攻击者需要考虑几个因素。我们在算法1中详细介绍了构建基于锁的隐蔽信道的过程。 通道/proc/locks包含内部内核数据，因此它一直在更改。尤其是在存在噪声的云环境中，内容可能会发生巨大的波动。 可靠传输数据块的第一步是握手：接收方需要找出发送方使用的所有lock。特别地，握手过程负责： 设置数据传输的起点. 锚定锁，用于同时传送一个block of bits. 同步发送器和接收器。 我们通过为每个数据锁创建一个特定的模式来实现握手。对于一个简化的情况，发送方在短时间内不断获取和释放锁。然后，接收器检查每个数据锁的切换次数（锁定或解锁文件）。如果切换次数超过特定阈值，则接收器通过跟踪索引节点编号来记录该lock，该索引节点编号对于特定文件上的相同锁定是不变的。同时，我们使用一个额外的锁来表示传输信号，用于通知接收器每一轮传输的开始。 在创建特定模式之后，理论上发送方可以立即开始传输。然而，接收方的处理过程的时间是未知的和不确定的，特别是在多租户云环境中存在大量锁的情况下。如果发送方传输数据过快，则可能会丢失一个比特块。虽然发送方可以在发送下一个数据块之前等待一段时间，但这种方法将极大地影响传输速度。 我们进一步添加了一个ACK锁，用于同步发送方和接收方。在获得所有数据锁定之后，接收器通过设置ACK锁定来进行确认。发送器侧的ACK锁的检测类似于接收器侧的其他数据锁的检测方法。接收器在用ACK锁定进行应答之后进入准备状态，并等待数据传输。 对于数据传输，发送方通过获取或释放数据锁，在每一轮中发送一个数据块。例如，八个锁可以表示一个字节。接收器通过检查数据锁的状态来解码数据。一旦接收到ACK锁定，发送器就开始下一轮数据传输。 Covert channel based on performance data variation通过这些信息的泄露，容器用户可以检索到主机服务器的全系统性能统计数据。例如，容器可以通过/proc/stat获取每个核心的CPU使用率，通过/proc/meminfo或/proc/vmstat获取内存使用率。性能数据的取值受容器运行状态的影响。尽管在云环境中，一个容器只能容纳有限的计算资源，但容器中的恶意用户可以仔细选择在容器中运行的工作负载。通过在性能通道中生成独特的模式，容器可以构建隐蔽通道来传输信息。我们建立了一个隐蔽通道，通过滥用/proc/meminfo中的内存使用信息。 /proc/meminfo报告大量关于系统内存使用情况的有价值的信息，包括可用内存总量、系统未使用的物理RAM总量和脏内存总量。 这里我们利用了系统中未使用的内存量。 在云环境中，这个值可能有很大差异，因为每个容器用户都可能影响它。对于建立可靠的隐蔽数据传输来说，这种显著的变化是不可取的。但是，如果不运行内存密集型工作负载，使用情况可能在可接受的范围内波动。我们首先在服务器上记录一段时间的未使用内存，以获得基线值。如果该值变化不迅速且不显著，则表示可以建立隐蔽通道。然后，发送方容器可以分配不同数量的内存来表示位1和位0(例如，位1为100MB，位0为50MB)，这将导致/proc/meminfo中的MemFree字段dorp immediately。接收端可以通过监视空闲内存的变化来简单地转换数据。MemFree分为三个级别:基线情况、位1和位0。发送方在发送1或0后释放所有分配的内存，以便接收方可以知道上次传输的结束并为下一个比特做准备。 为了确保可靠的传输，握手是发送方和接收方之间的第一个必要步骤。 发送方可以选择发送一个固定的模式，比如8位直比特1，来发起一次传输。接收端获得握手模式后，将进入数据接收模式。具体算法见算法2。为了减少其他容器内存消耗所产生的噪声的影响，一旦MemFree落在预定义的范围内，接收端将标记数据传输。同时，增加内存分配量可以减少噪声的影响。但是，由于分配和释放内存需要消耗时间，因此会影响传输带宽。为了减少来自环境的干扰，用户可以进一步设计更高级别的可靠协议，例如使用校验和，以确保传输数据的完整性。 Experiments on a Multi-tenancy Container Cloud为了测量在有真实噪声的环境下的性能，我们选择了一个商业多租户容器云来测试我们的隐蔽通道。我们反复启动容器，并通过检查惟一的静态标识符来验证共存。我们在同一物理机器上创建两个容器。 Lock-based covert channel: 我们在三种不同大小的数据(5,000字节、10,000字节和20,000字节)下测试了基于锁的隐蔽通道的带宽和错误率。我们还选择了四种不同数量的锁(即8、16、24、32)来衡量性能。我们根据经验为切换次数选择一个阈值，以确保所有锁都能被正确识别。握手过程的花费以秒为单位。然后，所有传输数据都是随机生成的。我们恢复接收端的所有数据，并与原始数据进行比较。 具有8个锁的基于锁的隐蔽通道的带宽约为5150 bps。显然，使用的锁越多，带宽就越高。在通道中使用32个数据锁(每轮传输4个字节)，带宽达到22186 bps。 此外，所有案例的错误率都在2%以下。结果表明，基于锁的隐蔽信道具有较高的可靠性。 Memory-based covert channel: 对于构建在/proc/meminfo上的隐蔽通道，我们首先将位1和位0的内存分配分别设置为100,000KB和50,000KB。我们发送1000位来测试性能。然后我们逐渐减少内存分配，直到构建握手失败。带宽和错误率的结果如表3所示。带宽与内存分配大小成反比。但是，如果分配的内存太小，握手过程就会失败，从而导致传输中出现大量错误。最后，通过将65,000KB分配给bit 1, 35,000KB分配给bit 0，我们能够在真实的云环境中实现13.6 bps的带宽。 基于锁的隐蔽通道提供了非常高的数据传输速率，同时仍然保持低错误率。虽然基于内存的隐蔽信道速度有限，但仍能可靠地传输数据。在基于内存的隐蔽信道中可以添加更多的优化方法。例如，我们可以使用更多的级别来每次传输多个比特。我们把它作为我们今后的工作。 值得注意的是，一旦两个容器共存于同一物理服务器上，无论使用相同的CPU包或核心，构建在信息泄漏通道上的隐蔽通道就可以工作。相反，只有当两个实例共享相同的CPU包时，基于最后一级缓存的通道才有效。另据报道，在真实的云环境中，基于内存总线的方法只能适用于近20%的co-residence情况。热隐蔽通道只能在两个核彼此靠近时起作用。 Synergistic Power Attack由于procfs和sysfs在容器中都是只读挂载的，因此恶意租户只能读取这些信息，但不允许修改。我们认为，通过利用泄漏通道，攻击者可以通过学习主机的运行时状态来做出更好的决策。 我们将介绍潜在的Synergistic Power Attack，可能影响数据中心的可靠性，在power outage threats的范围内。我们证明，对手可以利用我们发现的这些信息泄漏来放大攻击效果，降低攻击成本，并促进攻击编排。所有实验都是在真实的容器云中进行的。 Attack Amplification发动成功的power attack的关键是产生短时间的高power峰值，可以超过电力设施的供应能力。正如我们在2.4节中提到的，电源攻击的根本原因是广泛采用电源oversubscription，这使得电源峰值超过安全阈值成为可能。此外，机架级功率封顶机制只能在分钟级时间粒度内反应，为短时间高功率峰值的发生留下了空间。在最严重的情况下，过度充电可能会跳闸分支断路器，导致停电，最终导致服务器瘫痪。能量峰值的高度主要由攻击者控制的资源决定。现有的电源攻击通过自定义电源密集型工作负载 customizing powerintensive workloads(称为电源病毒)来最大限度地提高功耗。Ganesan等人，利用遗传算法自动生成比正常stress基准消耗更多的power的power viruses。 根据Barroso等的报告，在真实的数据中心中，平均利用率约为20%至30%。在如此低的利用率下，不加区分地发起power attack而跳闸断路器的几率极低。 然而，虽然平均利用率较低，但在峰值需求下，数据中心仍然面临断电威胁。这说明物理服务器的功耗随着工作负载的变化会有很大的波动。 为了确认这一假设，我们进行了一个实验，监测容器云中8个物理服务器的整个系统功耗(通过第3节案例研究II中的RAPL泄漏通道)，持续一周。我们将结果显示在图中。我们首先以30秒为间隔对功率数据进行平均，并在第2天和第5天观察功率的剧烈变化。此外，我们在第2天选择一个高功耗区域，并以一秒(这是产生功率峰值的典型时间窗口)为间隔对数据进行平均。峰值功耗达到1199瓦(W)，在一周的时间内，总功耗相差34.72% (899W ~ 1199w)。 我们预计，如果我们能对其进行更长时间的监控，比如在黑色星期五这样的假日，当托管在云上的在线购物网站可能会产生巨大的电力激增时，功耗差异将会更大。 对于容器云中的synergistic power attack，攻击者可以通过RAPL通道监控整个系统的功耗，实时了解功耗模式的波峰和波谷，而不是不加区分地启动功耗密集型工作负载。因此，他们可以利用后台功耗(由同一主机上其他租户的良性工作负载产生)，并在服务器处于峰值运行时间时叠加他们的电源攻击。 这与金融市场的内幕交易现象类似——掌握更多内幕信息的人总是能在合适的时间交易。对手可以通过通过RAPL通道泄露的“内部”功耗信息，在已经很高的功耗基础上再增加一个更高的功耗峰值。 Reduction of Attack Costs从攻击者的角度来看，他们总是希望以最低的代价获得最大的攻击结果。持续运行功耗高的工作负载绝对可以捕获所有良性功耗的峰值。但是，由于几个原因，它对于真实世界的攻击可能并不实用。首先，它不是隐形的。要发起电源攻击，攻击者需要运行电源密集型工作负载。这种行为具有明显的模式，很容易被云提供商检测到。 其次，基于利用率的计费模式现在变得越来越流行。更多的云服务根据CPU&#x2F;内存利用率和网络流量提供更细粒度的价格。例如，Elastic Container为客户提供了基于CPU计量计费的容器。 IBM Cloud为云中的计算资源提供计费指标。Amazon EC2提供了Burstable性能实例，该实例偶尔会崩溃，但大多数时间不会完全运行。VMware按需定价计算器甚至给出了不同利用率水平的估计值。例如，对于一个拥有16个vcpu且平均利用率为1%的实例，它每月收费2.87美元，对于相同的服务器且利用率为100%的实例，每月收费167.25美元。在这些云计费模式下，持续的power attack可能最终导致昂贵的账单。 对于synergistic power attack，通过RAPL监视功耗几乎没有CPU占用。 为了达到相同的效果(功率峰值的高度)，与连续和周期性攻击相比，协同功率攻击可以显著降低攻击成本。我们比较了synergistic power attack和周期性攻击(每300秒发起一次synergistic power attack)的攻击效果。协同攻击在3000秒内只进行两次试验，就可以达到1359瓦的功率峰值，而周期性攻击则进行了9次试验，最多只能达到1280瓦。 Attack Orchestration与传统的power attack不同，synergistic power attack的另一个独特特征是它的攻击编排。假设攻击者已经控制了一些容器实例。如果这些容器分散在数据中心的不同位置，那么它们在多个物理服务器上增加的power不会对电力设施造成压力。现有的功率封顶机制可以毫无困难地容忍来自不同位置的多个小power surges。发动实际电力攻击的唯一方法是将所有“弹药”聚集到相邻位置，同时攻击单个电源。在这里，我们将深入讨论攻击容器实例的编排。 正如我们在第3节中提到的，通过利用多个泄漏通道，攻击者可以将多个容器实例聚合到一个物理服务器中。具体来说，在CC1上的实验中，我们选择使用计时器列表来验证多个容器的共存。具体验证方法请参见3.3节。我们反复创建不在同一物理服务器上的容器实例和终止实例。通过这样做，我们可以轻松地在同一台服务器上部署三个容器。我们在每个容器中运行四个Prime基准测试副本，以充分利用四个分配的核心。每个容器可以贡献大约40W的功率。使用三个容器，攻击者可以轻松地将功耗提高到近230W，这比单个服务器的平均功耗高出约100W。 我们还发现/proc/uptime是另一个有趣的泄漏通道。正常运行时间包括两个数据项，物理服务器的启动时间和所有核心的空闲时间。 在我们的实验中，我们发现一些服务器的启动时间相似，但空闲时间不同。通常情况下，数据中心的服务器在安装和打开后不会重新启动。不同的空闲时间表明它们不是相同的物理服务器，而相似的引导时间表明它们很可能在同一时间段被安装和打开。这是强有力的证据，表明它们可能离得很近，共用同一个断路器。攻击者可以利用此通道将其攻击容器实例聚合到相邻的物理服务器中。这大大增加了他们跳闸导致停电的机会。 Defense AproachA Two-Stage Defense Mechanism直观地说，解决方案应该消除所有泄漏，这样就不会通过这些渠道检索泄漏的信息。我们将防御机制划分为两个阶段:(1)屏蔽通道和(2)增强容器的资源隔离模型。 在第一阶段，系统管理员可以显式地拒绝对容器内通道的读访问，例如，通过AppArmor中的安全策略或挂载伪文件“不可读”。这不需要对内核代码进行任何更改(合并到上游Linux内核可能需要一些时间)，并且可以立即消除信息泄漏。此解决方案取决于容器中运行的合法应用程序是否使用这些通道。如果这些信息与容器化的应用程序正交，则屏蔽它不会对容器租户产生负面影响。我们已经向Docker和表中列出的所有云供应商报告了我们的结果，并收到了积极的回应。 我们与容器云供应商合作解决此信息泄漏问题，并将对容器中托管的应用程序的影响降至最低。这种屏蔽方法可以快速修复基于内存的伪文件系统中的所有泄漏，但它可能会对容器化应用程序的功能增加限制，这与容器提供通用计算平台的概念相矛盾。 在第二阶段，防御方法涉及修复丢失的namespace上下文检查和虚拟化更多的系统资源(即，实现新的namespace)以增强容器的隔离模型。 我们首先向Linux内核维护者报告了与现有namespace相关的信息披露错误，他们很快发布了针对其中一个问题的新补丁([CVE2017-5967])。对于没有namespace隔离保护的其他通道，我们需要更改内核代码，以强制使用更细粒度的系统资源分区。由于每个通道都需要单独修复，因此这种方法可能涉及大量工作。虚拟化一个特定的内核组件可能会影响多个内核子系统。另外，有些系统资源不容易精确地划分到每个容器中。但是，我们认为这是解决问题的根本办法。特别是，为了防御synergistic power attack，我们在Linux内核中设计并实现了一个proof-of-concept power-based namespace，以向每个容器显示分区的电源使用情况。 Power-based Namespace我们提出了一个power-based namespace，通过未更改的RAPL接口向每个容器显示每个容器的power使用情况。在不泄漏整个系统功耗信息的情况下，攻击者无法推断主机的电源状态，从而消除了在良性电源峰值上叠加功耗密集型工作负载的机会。此外，有了每个容器的功率使用统计数据，我们可以动态地限制超过预定义功率阈值的容器的计算能力(或增加使用费用)。容器云管理员可以基于此基于功能的namespace设计粒度更细的计费模型。 我们的设计有三个目标。 准确性:由于没有硬件支持每个容器的功率分区，我们基于软件的功率建模需要准确反映每个容器的功率使用情况。 透明性:容器内的应用程序不知道该命名空间外的功率变化，功率子系统的接口保持不变。 效率:功率分区不应在容器内或容器外引起重要的性能开销。 我们在图中说明了系统的工作流程。我们基于功率的命名空间由三个主要组件组成:数据收集、功率建模和动态校准。我们在容器中保持相同的Intel RAPL接口，但是改变了处理能源使用的读取操作的实现。一旦检测到能源使用的读取操作，修改后的RAPL驱动程序检索每个容器的性能数据(数据收集)，使用检索到的数据来建模能源使用(功率建模)，最后校准建模的能源使用(动态校准)。 我们将在下面详细讨论每个组件。 Data collection为了对每个容器的功耗进行建模，我们需要获得每个容器的 fine-grained performance data。每个容器都与一个cpuacct cgroup相关联。cpuacct cgroup表示容器的处理器核心上的CPU周期。CPU周期累计。我们只使用CPU周期来计算后面的缓存丢失率和分支丢失率。Linux内核还有一个perf_event子系统，它支持计算不同类型的性能事件。The granularity ofperformance accounting 可以是单个进程或一组进程(视为一个per_event cgroup)。到目前为止，我们只为每个perf_event cgroup检索退役指令、缓存缺失和分支缺失(在下一个电源建模组件中需要)的数据。我们当前的实现是可扩展的，可以收集与未来电源建模的变化相对应的更多性能事件类型。 我们从power-based namespace的初始化监视性能事件，并创建多个perf_events，每个事件都与特定的性能事件类型和特定的CPU核心相关联。然后，我们将该容器的perf_cgroup与这些perf_event连接起来，开始计算。此外，我们需要将所有创建的perf_event的所有者设置为TASK TOMBSTONE，这表明这样的性能核算与任何用户进程都是分离的。 Power modeling要实现power-based namespace，我们需要将功率消耗归因于每个容器。RAPL不是提供瞬态功耗，而是分别为package、核心和DRAM提供累计能耗。power消耗可以通过测量时间单位窗口内的能源消耗来计算。 我们power-based namespace还以与原始RAPL接口相同的格式提供了每个容器的累计能量数据。 我们首先将核心的功耗归为属性。 传统的电源建模利用CPU利用率来确定核心的功耗。然而，Xu等证明，在相同的CPU利用率下，power消耗可能会有很大差异。底层管道和数据依赖可能导致CPU失速和功能单元空转。在相同的CPU利用率下，实际退出指令的数量是不同的。 图显示了退役指令和能量之间的关系。我们在四个不同的基准上进行测试:用C编写的空闲循环，prime, 462.SPECCPU2006中的libquantum，以及不同内存配置的strss。我们在主机上运行基准测试，并使用Perf来收集性能统计数据。我们可以看到，对于每个基准测试，能量消耗几乎严格地与退役指令的数量成线性。但是，随着应用类型的不同，拟合线的梯度也相应变化。为了使我们的模型更加准确，我们进一步加入cache miss rate和branch miss rate，建立一个多次多项式模型来拟合斜率。 对于DRAM，我们使用package失败的数量来分析power。图显示了核心实验中相同基准测试和相同配置的能耗。它清楚地表明cache miss的数量与DRAM能量近似线性。 在此基础上，我们利用的线性回归对DRAM能量进行建模。 对于package的功耗，我们将核心、DRAM和一个额外常数的值相加。具体模型如式所示，其中M为建模能量;CM、BM、C分别表示cache miss次数、branch miss次数和CPU周期;F为通过多次线性回归拟合斜率得到的函数。I是退役指令的数量。α， β， γ， λ是由图实验数据得出的常数。 这里我们讨论浮点指令对功率建模的影响。独立的浮点指令可能比整数操作消耗更多的能量。具有高浮点指令比例的工作负载实际上可能导致整体功耗较低，因为功能单元可能被迫在管道的不同阶段处于空闲状态。为了建立一个更精细的模型，有必要考虑微架构。我们计划在今后的工作中朝着这个方向努力。此外，α、β、γ参数的选择也受结构的影响。这样的问题可以在接下来的校准步骤中得到缓解。 On-the-fly calibration我们的系统还为主机的能量数据建模，并与通过RAPL获得的实际能量数据进行交叉验证。为了尽量减小建模数据的误差，我们使用下式对每个容器的建模能量数据进行校准。Econtainer表示返回给每个容器的能量值。这种实时校准是对RAPL接口的每个读取操作进行的，可以有效地减少前一步的错误数量。 Defense Ecaluation我们从三个方面评估本地机器上基于功能的名称空间:准确性、安全性和性能。我们的测试平台配备了Intel i7-6700 3.40GHz 8核CPU, 16GB RAM，运行Ubuntu Linux 16.04，内核版本为4.7.0。 Accuracy我们使用SPECCPU2006基准来测量power建模的准确性。我们将建模的power使用情况与通过RAPL获得的ground truth进行比较。 功耗等于每秒的能量消耗。由于Docker容器的安全策略的限制，我们选择了SPECCPU2006基准测试的一个子集，这些基准测试可以在容器内运行，并且与用于功率建模的基准测试没有重叠。误差ξ定义如下: 其中ERAPL是从主机上的RAPL读取的功耗，而Mcontainer是在容器中读取的相同工作负载的建模功耗。注意，主机和容器都在空闲状态下消耗电力，差别很小。我们使用常数∆diff作为修饰符，反映主机和容器在空闲状态下的功耗差异。结果如图所示，我们的power模型是准确的，因为所有测试基准的误差值都低于0.05。 Security我们也从安全的角度来评估我们的系统。 启用了power-based namespace后，容器应该只检索容器内消耗的功率，而不知道主机的电源状态。我们在测试平台中启动两个容器进行比较。我们在一个容器中运行SPECCPU2006基准测试，并将另一个容器闲置。我们记录容器和主机的每秒用电量。如图所示401.bzip2的结果。所有其他基准测试都表现出类似的模式。 当两个容器都没有工作负载时，它们的功耗与主机的功耗基本相同，从0到10s。一旦容器1在10s启动工作负载，我们可以发现容器1和主机的功耗同时激增。从10s到60s，容器1和主机的功耗基本一致，而容器2仍然处于较低的功耗水平。容器2不知道整个系统的功率波动，因为基于power-based namespace强制隔离。这表明我们的系统能够有效地隔离和划分多个容器的功耗。如果没有电源相关的信息，攻击者将无法发起synergistic power attack。 Performance我们使用UnixBench来比较启用系统前后的性能开销。表列出了所有结果。 正如结果所示，诸如Dhrystone(测试整数和字符串操作)和Whetstone(测试浮点算术性能)这样的CPU基准测试所产生的开销可以忽略不计。 其他基准测试，如shell脚本、管道吞吐量和系统调用，也会触发很少的开销。 在一个并行副本的情况下，基于管道的上下文切换(pip-based context swtiching)确实会产生61.53%的开销，但在8个并行副本时，它会减少到1.63%。我们预计inter-cgroup context switching涉及启用&#x2F;禁用性能事件监视器，而intra-cgroup context switching不涉及任何此类开销。 这解释为什么在禁用power-based namespace情况下，8个并行副本可以保持相似的性能水平。此外，上下文切换只占整个系统性能开销的很小一部分，因此对正常使用的影响很小。 在我们的系统中，对于每个新创建的容器，内核将在每个内核上创建多个perf_events，以收集与性能相关的数据。此测量过程仅对容器过程进行。因此，测量开销将随着容器数量的增加而线性增加。但是，容器数量的增加对系统的影响很小。使用这种机制，在创建所有进程时，内核会检查该进程是否是容器进程。这个检查进程是Unix基准测试中进程创建开销的主要原因。 如表的最后一行所示，UnixBench的总体性能开销对于一个并行副本是9.66%，对于8个并行副本是7.03%。 我们的系统性能在很大程度上依赖于perf_event cgroup的实现，并且可以随着性能监视子系统的改进而提高。 DiscussionSynnergistic Power Attack without the RAPL Channel我们还注意到，一些容器云中的服务器没有配备RAPL或其他类似的嵌入式power meters。这些服务器仍可能面临power attack。如果没有像RAPL这样的power-capping工具，这些服务器在一台机器上可能容易受到host-level power attacks。 此外，如果power data不能直接获得，高级攻击者会尝试根据资源利用信息(如CPU和内存利用率)来近似电源状态，这些信息在已识别的信息泄漏中仍然可用。最好让容器租户无法使用系统范围的性能统计数据。 Complete Container Implementation造成信息泄漏和synergistic power attack的根本原因是Linux内核中隔离机制的不完整实现。最好引入更多的安全特性，比如实现更多的namespace和cgroup。但是，一些系统资源仍然难以分区，如中断、调度信息、温度等。人们还认为，完整的容器实现与虚拟机没有什么不同，并且失去了容器的所有优点。这是容器之间的权衡。如何在容器云中平衡安全性、性能和可用性的问题需要进一步研究。 Related Work由于容器最近变得流行，研究人员对容器和硬件虚拟化之间的性能比较感到好奇。Felter等人通过使用一套涵盖CPU、内存、存储和网络资源的基准测试来比较Docker和KVM的性能。他们的结果显示，Docker在所有情况下都能达到与KVM相同或更好的性能。Spoiala等人使用Kurento媒体服务器来比较Docker和KVM上的WebRTC服务器的性能。他们还证明了Docker的性能优于KVM，可以支持实时应用。Morabito等人比较了传统管理程序和操作系统级虚拟化在计算、存储、内存和网络方面的性能。他们对Docker、LXC和KVM进行了实验，观察到磁盘I&#x2F;O仍然是KVM管理程序的瓶颈。所有这些工作都表明，基于容器的操作系统级虚拟化可以实现比硬件虚拟化更高的性能。除了性能，容器云的安全性始终是一个重要的研究领域。Gupta简要介绍了Docker的安全性。Bui也对Docker容器进行了分析，包括隔离问题和相应的内核安全机制。他们声称，Docker容器在默认配置下是相当安全的。Grattafiori等人总结了容器的各种潜在漏洞。他们还提到了基于内存的伪文件系统中的几个通道。Luo等人证明了错误配置的能力可以被利用来在Docker中建立隐蔽的通道。之前关于容器的性能和安全性的研究工作鼓励我们更多地研究容器如何能够实现与硬件虚拟化相同的安全保证，但在性能方面的折衷却微不足道。我们是第一批系统地识别容器中的信息泄露问题，并研究建立在这些泄漏渠道的基于容器的潜在的power attcak。 Cloud Security and Side&#x2F;Covert Channel Attacks云安全已经受到学术界和业界的广泛关注。云环境下的co-residence检测是与我们工作最密切相关的研究课题。co-residence检测最早由Ristenpart等人提出。他们证明，攻击者可以将恶意VM与目标VM co-residence 在同一服务器上，然后发起侧通道和隐蔽通道攻击。在现有主流云服务中实现co-residence仍然是可行的。为了验证在同一物理服务器上的co-residence，攻击者通常利用侧通道或隐蔽通道，例如，一种广泛采用的方法是使用cahe-based channel。位于同一个包上的多个实例共享最后一级缓存。通过使用一些专用的操作(如cflush)，攻击者可以通过测量缓存访问时间来检测共驻留。Liu等证明了l3缓存侧通道攻击对于跨核和跨vm攻击是可行的。Zhang等人对云进行了真实的侧通道攻击，并提出了几种防御机制来缓解这些攻击。特别是，他们证明了跨租户侧通道攻击可以成功地在PaaS中使用共存服务器进行。除了基于缓存的通道外，内存总线和内存重复数据删除也已被证明是构造隐蔽通道的有效方法。与现有的侧&#x2F;隐蔽通道研究工作不同，我们在容器云设置中发现了系统范围的信息泄漏，并设计了一种新的方法来定量评估泄漏通道的容量，以用于共居检测。另外，与最小化虚拟机的内核攻击面研究相比，我们提出了一种两级防御机制，以最小化容器云上的信息泄漏和电源攻击空间。 系统状态信息，如核心温度和系统功耗，也被用于构建侧&#x2F;隐蔽通道。Thiele等提出了一种基于每个核心温度的热隐蔽通道，并在局部试验台测试了容量。功耗也可能被滥用来破坏AES。在工作中，我们不使用功耗数据作为传递信息的隐蔽通道。相反，我们证明了对手可以利用主机功耗泄漏来发起更高级的power attack。 Power Modeling在没有hardware-based power meter的情况下，power modeling是逼近功耗的一种方法。 Russell等和Chakrabarti等提出了指令级功率建模。他们的工作表明，分支的数量影响功耗。对虚拟机功耗的近似研究有几种。有工作证明了VM级的功耗可以通过CPU利用率和最后一级缓存失误率来估计。Mobius等将VM的功耗分为CPU、缓存、内存和磁盘。BITWATTS在细粒度流程级别上对功耗进行了建模。Shen等提出了一种power容器来计算多核系统中请求的能量消耗。我们对synergistic的防御主要是受到power modeling approach for VMs的启发。我们提出了一种新的power分区技术来近似每个容器的功耗并重用RAPL接口，从而解决了容器设置中的RAPL数据泄漏问题。 Conlusion容器云服务因提供轻量级操作系统级虚拟主机环境而变得流行起来。容器技术的出现深刻地改变了在云中开发和部署分布式应用程序的生态系统。但是，由于Linux内核中系统资源分区机制的不完全实现，对于共享同一个内核的多个容器租户仍然存在一些安全问题。在本文中，我们首先提出了一种系统的方法来发现可能将主机信息暴露给容器的信息泄漏通道。通过利用这些泄露的主机信息，恶意容器租户可以发起一种新型的power attack，这可能会危及数据中心电源系统的可靠性。此外，我们讨论了这些信息泄漏的根本原因，并提出了一个两阶段的防御机制。我们的评估表明，所提出的解决方案是有效的，并引起微不足道的性能开销。 MyLinux的incomplete coverageLinux内核提供了对各种容器化技术的支持，使用户能够在单个主机上运行多个隔离环境。Linux内核中的容器实现主要利用一组特性，如namespace、cgroup和seccomp。然而，在Linux内核中，容器实现的某些方面可能是不完整或有限制的。以下是一些潜在的incomplete coverage范围： namespace：通过创建系统资源的分离视图来为容器提供隔离。虽然Linux内核支持几种命名空间（mout、PID、NET、IPC、UTS和user），但某些资源类型可能没有相应的命名空间或具有有限的支持，这可能导致不完全隔离。 control groups（cgroups）：Cgroups用于限制、记录和隔离进程组使用资源（CPU、内存、I&#x2F;O等）。虽然存在cgroups v1和v2，但某些功能可能无法在两个版本之间得到充分支持或具有局限性。这会导致容器资源管理不完整或不一致。 安全性：Linux内核提供了诸如seccomp、AppArmor和SELinux之类的安全机制来强制访问控件并限制容器可以进行哪些系统调用。但是，这些机制可能存在漏洞或限制，可能会暴露潜在的安全风险。 兼容性：容器实现的某些功能（如文件系统快照或检查点&#x2F;恢复）可能取决于特定的内核版本、存储驱动程序或文件系统。这可能导致在某些配置上出现兼容性问题和限制。 性能：虽然Linux内核为容器工作负载提供了各种优化，但仍有一些领域可以改进，例如存储I&#x2F;O或网络吞吐量。 内核更新：随着新功能和改进被添加到Linux内核中，容器实现可能需要更新以利用这些增强功能。在某些情况下，这可能会导致容器支持方面存在差距，直到它们与新的内核特性完全集成并进行测试。 值得注意的是，Linux内核正在积极开发中，并且对于容器支持的改进不断被提出和实施。此外，像Docker、Kubernetes和LXC之类的容器化解决方案建立在这些内核特性之上，并提供更完整、无缝的用户体验。 数据中心的oversubscription电力超额订阅是数据中心使用的一种策略，其中分配给服务器、存储系统和网络设备的总电源供应超过实际可用电源供应。这种方法基于一个观察结果：并非所有设备同时消耗其最大额定功率。通过利用这一点，数据中心可以托管比其电力基础设施允许更多的服务器和设备。 Linux子系统Linux子系统是Linux内核中的一部分，负责处理特定功能或设备。例如，文件系统、网络协议栈、进程调度等都可以被认为是Linux子系统。它们通常以模块的形式实现，并在运行时加载到内核中。这些子系统允许Linux内核与硬件和外部资源进行交互，以便为上层应用程序提供所需的功能。 执行上下文执行上下文是操作系统在运行某个任务时的环境，它包括一个任务所需的所有状态信息。这包括程序计数器、堆栈指针、寄存器值、内存分配信息等。执行上下文使得操作系统能够在多个任务之间进行切换，以实现多任务并发执行。 Linux子系统不能区分容器和主机之间的执行上下文，可能泄露系统信息容器是一种轻量级的虚拟化技术，允许在同一主机上运行多个隔离的应用程序。容器与主机共享相同的内核，但每个容器都有其独立的文件系统、进程空间、网络接口等。容器技术的一个关键优势是资源隔离，这意味着每个容器只能访问分配给它的资源，而不能访问其他容器或主机的资源。 然而，某些Linux子系统可能无法区分容器和主机之间的执行上下文。这意味着当容器化应用程序访问这些子系统时，它们可能能够访问不应暴露给它们的系统范围信息。这可能导致安全和隐私问题，因为容器之间和容器与主机之间的隔离可能被破坏。 例如，如果某个Linux子系统负责处理系统范围的统计信息（如CPU使用率、内存使用情况等），那么容器内的应用程序可能能够访问这些信息，从而获取其他容器或主机的资源使用情况。这可能导致容器之间的信息泄露，破坏了它们之间的隔离。 为了解决这个问题，容器运行时和内核开发人员需要确保所有Linux子系统都能够正确地区分容器和主机之间的执行上下文，以实现更强大的隔离和安全性。这可能包括修改子系统的实现，以便它们能够识别和处理来自容器的请求，以及限制容器访问系统范围信息的能力。 Namespace和cgroup以及具体实现Linux中的Namespace和Cgroup是两种操作系统级别的资源管理和隔离技术。它们在容器技术（如Docker）中被广泛应用，用于实现轻量级虚拟化。 Namespace（命名空间） 是Linux内核提供的一种隔离技术，允许创建多个独立的空间，每个空间内可以有自己的进程、文件系统、网络等资源。Namespace有以下几种类型： Mount Namespace：隔离不同命名空间的文件系统挂载点。 PID Namespace：隔离进程ID空间，使每个命名空间有独立的PID。 Network Namespace：隔离网络接口和路由表，使每个命名空间有独立的网络环境。 IPC Namespace：隔离System V IPC对象和POSIX消息队列。 UTS Namespace：隔离主机名和域名。 User Namespace：隔离用户和组ID。 Cgroup（控制组） 是Linux内核提供的一种资源管理技术，允许对一组进程进行资源限制、优先级调整等操作。Cgroup通过将进程组织到层次结构的控制组中来实现资源管理。主要有以下几类资源控制： CPU：限制进程的CPU使用率。 Memory：限制进程的内存使用。 Block I&#x2F;O：限制进程的磁盘I&#x2F;O。 Network：限制进程的网络带宽。 以下是一个简单的Namespace和Cgroup的使用示例： 安装相关工具： 1sudo apt-get install cgroup-tools 创建一个新的Namespace（使用unshare命令）： 1sudo unshare --uts --pid --mount-proc --fork /bin/bash 这个命令创建了一个新的Namespace，并在其中启动了一个新的bash进程。这个新的Namespace具有独立的UTS、PID和挂载的&#x2F;proc文件系统。 创建一个新的Cgroup（使用cgcreate命令）： 1sudo cgcreate -g cpu,memory:/my_cgroup 这个命令创建了一个名为my_cgroup的新Cgroup，用于管理CPU和内存资源。 为Cgroup分配资源限制（使用cgset命令）： 12sudo cgset -r cpu.shares=512 my_cgroupsudo cgset -r memory.limit_in_bytes=100M my_cgroup 这个命令为my_cgroup设置了CPU份额为512（相对权重）和内存限制为100MB。 将进程添加到Cgroup（使用cgclassify命令）： 1sudo cgclassify -g cpu,memory:my_cgroup &lt;PID&gt; 将指定的进程PID添加到my_cgroup中，使其受到Cgroup资源限制的约束。 以上示例展示了如何使用Namespace和Cgroup进行资源隔离和管理。在实际应用中，这些技术通常与容器运行时（如Docker）结合使用，以提供更高级别的抽象和管理工具。 Namespace和Cgroup的具体使用Namespace 和 cgroup 是 Linux 内核提供的两个关键特性，它们在容器技术（如 Docker）中发挥着重要作用。Namespace 负责为容器提供独立的视图，使得容器在网络、进程、文件系统等方面与主机和其他容器隔离。而 cgroup（控制组）则负责限制和管理容器的资源使用（如 CPU、内存、磁盘 I&#x2F;O 等）。 Namespace 例子： 假设我们想要创建一个新的网络 Namespace，使容器具有独立的网络栈。我们可以使用 ip 命令来实现这一目标： 123456789101112131415# 创建一个新的网络 Namespacesudo ip netns add my_namespace# 将网络设备 veth0（容器端）和 veth1（主机端）添加到新的 Namespacesudo ip link add veth0 type veth peer name veth1sudo ip link set veth0 netns my_namespace# 配置容器端网络设备sudo ip netns exec my_namespace ip addr add 192.168.1.2/24 dev veth0sudo ip netns exec my_namespace ip link set veth0 upsudo ip netns exec my_namespace ip route add default via 192.168.1.1# 配置主机端网络设备sudo ip addr add 192.168.1.1/24 dev veth1sudo ip link set veth1 up 在这个例子中，我们创建了一个新的网络 Namespace，并配置了一对虚拟以太网设备（veth0 和 veth1），将容器的网络与主机网络连接起来。这使得容器可以拥有独立的网络栈，与主机和其他容器隔离。 cgroup 例子： 假设我们想要限制容器的 CPU 和内存资源。我们可以使用 cgroup 来实现这一目标： 123456789101112131415# 创建一个新的 cgroupsudo mkdir -p /sys/fs/cgroup/cpu/my_cgroupsudo mkdir -p /sys/fs/cgroup/memory/my_cgroup# 限制容器的 CPU 使用率为 50%echo 50000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_quota_usecho 100000 &gt; /sys/fs/cgroup/cpu/my_cgroup/cpu.cfs_period_us# 限制容器的内存使用为 100MBecho 100000000 &gt; /sys/fs/cgroup/memory/my_cgroup/memory.limit_in_bytes# 启动一个新的容器，并将其添加到我们之前创建的 cgroupdocker run -itd --name=my_container ubuntu:18.04echo $(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; my_container) &gt; /sys/fs/cgroup/cpu/my_cgroup/cgroup.procsecho $(docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; my_container) &gt; /sys/fs/cgroup/memory/my_cgroup/cgroup.procs 在这个例子中，我们创建了一个新的 CPU 和内存 cgroup，并限制了容器的 CPU 使用率和内存使用。然后我们启动了一个新的容器，并将其添加到我们之前创建的 cgroup 中，这样容器的资源使用就受到了限制。 综上所述，Namespace 和 cgroup 在容器技术中发挥着重要作用，使得容器可以在资源使用和隔离方面实现更精细的控制。 Linux中的pseudo file在 Linux 系统中，伪文件（pseudo file）是一种特殊类型的文件，它们提供了与系统内核和设备驱动程序交互的途径。伪文件并不包含实际的文件数据，而是在用户和内核空间之间提供了一个通信接口。这些文件通常位于 /proc 和 /sys 文件系统中。 /proc 文件系统是一个虚拟文件系统，包含了许多伪文件，这些伪文件可以用来监控和调整系统内核的运行状态。例如，/proc/cpuinfo 提供了有关处理器的详细信息，/proc/meminfo 提供了关于系统内存使用情况的数据。这些伪文件可以像普通文件一样使用命令行工具（如 cat、grep 等）进行查看和操作。 /sys 文件系统是另一个虚拟文件系统，用于 Linux 内核的设备管理。它包含了许多伪文件，这些伪文件提供了对系统设备的配置和状态信息的访问。/sys 文件系统的结构更加规范化，按照设备、总线和驱动程序的层次关系进行组织。 总之，伪文件在 Linux 系统中提供了一种简单、统一的方法，使用户能够方便地访问和修改系统内核和设备驱动程序的状态信息。 pseudo file和真实文件的区别伪文件（pseudo file）和真实文件在 Linux 系统中具有不同的特点和用途。以下是它们之间的主要区别： 数据存储：真实文件存储在磁盘上，包含实际的文件数据。而伪文件并不包含实际的文件数据，它们通常不存在于磁盘上，而是由内核动态生成，用于在用户空间和内核空间之间提供通信接口。 用途：真实文件用于存储和读取数据，例如文档、图像或程序。伪文件主要用于提供系统信息、监控和调整内核参数或设备驱动程序的状态。它们可以让用户通过文件系统接口与内核交互，而无需使用特殊的系统调用。 位置：真实文件通常分布在整个文件系统中，根据目录结构进行组织。伪文件主要位于特定的虚拟文件系统中，例如 /proc（用于内核参数和进程信息）和 /sys（用于设备管理）。 访问方式：伪文件和真实文件都可以使用类似的命令行工具（如 cat、grep 等）进行查看和操作。然而，伪文件通常是只读的或仅支持特定操作，它们的内容可能会随着系统状态的变化而动态改变。 总之，伪文件和真实文件在数据存储、用途、位置和访问方式上存在显著差异。伪文件主要用于提供与内核和设备驱动程序的交互途径，而真实文件用于存储和读取实际数据。 伪文件例子/proc/loadavg 伪文件是由内核动态生成的，不在磁盘上存在。它允许用户和程序通过熟悉的文件系统接口访问负载平均值信息，而无需使用特殊的系统调用。 要使用 /proc/loadavg，您可以像读取常规文件一样简单地读取其内容。例如，您可以使用 cat 命令在终端中显示其内容： 1cat /proc/loadavg 输出可能类似于以下内容： 10.51 0.38 0.35 1/1234 5678 这些数字分别表示 1 分钟、5 分钟和 15 分钟的负载平均值，后面的数字表示当前正在运行的进程数&#x2F;系统总进程数，以及最近分配的进程 ID。 总之，/proc/loadavg 是一个伪文件的示例，它为访问 Linux 系统中的负载平均值信息提供了一个接口，无需使用特殊的系统调用。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"论文阅读 Demons in the Shared Kernel: Abstract Resource Attacks Against","slug":"论文阅读 Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against","date":"2023-03-30T14:06:58.000Z","updated":"2023-04-16T12:31:41.581Z","comments":true,"path":"2023/03/30/论文阅读 Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/","link":"","permalink":"http://example.com/2023/03/30/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20Demons-in-the-Shared-Kernel-Abstract-Resource-Attacks-Against/","excerpt":"摘要 由于其更快的启动速度和更好的资源利用效率，OS-level的虚拟化（virtualization）已被广泛采用，并成为云计算的一项基本技术。与硬件虚拟化相比，OS-level的虚拟化利用共享内核（shared-kernel）设计来实现高效率，并在共享内核上运行多个用户空间实例（又称容器） 然而，在本文中，我们揭示了一种新的攻击面，它是操作系统级虚拟化所固有的，会影响Linux、FreeBSD和Fuchsia。根本原因是操作系统级虚拟化中的共享内核设计导致容器直接或间接地共享成千上万的内核变量和数据结构。在不利用任何内核漏洞的情况下，非特权容器可以轻松耗尽共享的内核变量和数据结构实例，从而对其他容器发起DoS攻击。与物理资源相比，这些内核变量或数据结构实例(称为抽象资源)更普遍，但保护不足。","text":"摘要 由于其更快的启动速度和更好的资源利用效率，OS-level的虚拟化（virtualization）已被广泛采用，并成为云计算的一项基本技术。与硬件虚拟化相比，OS-level的虚拟化利用共享内核（shared-kernel）设计来实现高效率，并在共享内核上运行多个用户空间实例（又称容器） 然而，在本文中，我们揭示了一种新的攻击面，它是操作系统级虚拟化所固有的，会影响Linux、FreeBSD和Fuchsia。根本原因是操作系统级虚拟化中的共享内核设计导致容器直接或间接地共享成千上万的内核变量和数据结构。在不利用任何内核漏洞的情况下，非特权容器可以轻松耗尽共享的内核变量和数据结构实例，从而对其他容器发起DoS攻击。与物理资源相比，这些内核变量或数据结构实例(称为抽象资源)更普遍，但保护不足。 为了说明限制抽象资源的重要性，我们针对操作系统内核的不同方面进行了抽象资源攻击。结果表明，攻击抽象的资源是非常实用和关键的。我们进一步进行了系统分析，识别出Linux内核中脆弱的抽象资源，成功检测到1010个抽象资源，其中501个可以动态重复使用。我们还在前四家云供应商的自部署共享内核容器环境中进行了攻击实验。结果表明，所有环境都容易受到抽象资源攻击。我们得出结论，containing抽象资源是困难的，并给出了多种策略来降低风险 CCS CONCEPTS Security and privacy -&gt; Virtualization and security KEYWORDS OS-level Virtualization；Shared Kernel；Abstract Resource Attack IntroductionOS-level虚拟化允许多个包含且隔离的用户空间环境在同一个内核上运行。与硬件虚拟化相比（虚拟机），OS-level虚拟化消除了为每个用户空间实例维护操作系统内核的负担，因此具有更快的启动速度和更好的资源利用效率。因此，OS-level虚拟化在近年来得到了广泛的应用，并成为云计算的基础技术。OS-level虚拟化中的空间实例在FreeBSD中命名为jails，在Solaris命名为Zones，在Linux中命名为containers。 尽管OS-level的虚拟化效率很高，但它也带来了多种安全问题。首先，由于共享内核，操作系统级虚拟化容易受到内核漏洞的攻击。因此，它不能隔离内核错误。一旦共享内核受到威胁，所有用户空间实例(称为容器)都将失去隔离和保护。此外，研究人员最近对容器技术的隔离提出了质疑，例如信息泄漏、隐蔽通道和out-of-band workloads 打破了cgroup。 然而，在本文中，我们揭示了OS-level虚拟化所固有的一种新的攻击面（attack surface）。与硬件虚拟化相比，OS-level虚拟化利用共享内核设计来实现高效率。在典型的OS-level虚拟化环境中，容器运行在相同的操作系统内核上，并通过300多个系统调用请求各种服务。请注意，底层OS内核包含数十万个变量和数据结构实例，用于为容器提供服务。因此，这些容器直接或间接地共享这些内核变量和数据结构实例。 不幸的是，这些共享的内核变量和数据结构实例是OS-level中的新攻击面。在不利用任何漏洞的情况下，非特权容器可以轻松耗尽某些内核变量和数据结构实例，从而在OS-level虚拟化环境中引起DoS攻击。因此，即使其他容器拥有足够的物理资源，但随着内核关键变量或数据结构实例的耗尽，它们仍然不能执行任何有意义的任务。与真实硬件所支持的物理资源相比，我们将这些内核变量或数据结构实例视为抽象资源，将对这些资源的用尽攻击视为抽象资源攻击（abstract resource attack）。 尽管抽象资源可以被用于DoS攻击，但它们往往得不到充分保护。内核和容器开发人员更关注保护物理资源，而不是抽象资源。例如，Linux内核提供了cgroup来限制每个容器实例的资源使用。但在13个cgroup中，有12个是物理资源cgroup，限制CPU、内存、存储、IO等资源的使用。只有pid cgroup是为限制抽象资源pid而设计的。因此，数百种容器共享的抽象资源没有任何限制，例如global dirty ratio、open-file structs和pseudo-terminal structs，这使它们容易受到DoS攻击。 为了展示在OS-level上限制抽象资源的重要性，我们在Linux内核上使用Docker容器进行攻击，针对操作系统服务的不同方面的抽象资源，包括进程管理、内存管理、存储管理和IO管理。 我们的实验证明攻击抽象资源是非常实用和关键的-它很容易地禁用新程序的执行，降低内存写入速度97.3%，使所有文件打开相关地操作崩溃，并拒绝所有新的SSH连接。更糟糕地是，它会影响操作系统服务的所有方面。此外，实验还表明，除了Linux FreeBSD和Fuchsia也容易受到抽象资源攻击。 遗憾的是，尽管抽象资源很重要，但由于几个基本原因，它们本身就很难contain。首先，在操作系统内核中列举所有可能的抽象资源是不切实际的。与很少的物理资源类型不同，内核中的抽象资源类型是多种多样的。第二，很容易形成导致抽象资源枯竭的条件。在内核中实现新特性时，开发人员经常关注物理资源的消耗，而很少关注抽象资源的消耗。此外，OS内核具有复杂的数据和路径依赖关系，导致内核中的抽象资源以各种方式耗尽。 因此，我们设计了一个基于LLVM的工具，系统地识别Linux内核中脆弱的抽象资源。我们提出了识别可共享抽象资源并分析其容器可控性的新技术。我们将我们的工具应用于新的Linux内核，并检测1010个抽象资源。其中501个可以动态地重复使用，从检测到的抽象资源中，我们根据我们的熟悉度挑选了7个影响操作系统各个方面的资源（即，我们知道耗尽该资源的影响）。我们进一步对部署在四大云供应商（包括AWS、MS Azure、谷歌cloud和阿里云）上的共享内核容器环境中的这些选定资源进行攻击实验。试验结果表明，所有环境都容易受到我们的攻击。最后给出了多种降低抽象资源攻击风险的策略。 本文的贡献如下： New Attack Surface：我们揭示了操作系统级虚拟化所固有的新的攻击面。我们提出了一种新的攻击方法，称为抽象资源攻击。我们证明了抽象资源攻击是非常实用的，并且是影响Linux、FreeBSD和Fuchsia的广泛攻击类别。 Systematic Analysis：我们设计并实现了一个基于LLVM的静态分析工具来识别Linux内核中脆弱的抽象资源，包括基于配置的分析和容器可控性分析。我们的工具检测501个可以在Linux内核中动态重复触发的抽象资源。 Practical Evaluation：我们评估了AWS、MS Azure、谷歌Cloud和阿里云上self-deployed共享内核容器环境中的7种抽象资源攻击。（目前的公共云供应商没有直接向不同的用户提供共享内核容器。公共云中的容器通常由虚拟机隔离。）所有环境都容易收到抽象资源攻击。其中有两个环境易受6 attacks，一个环境易受 5 attacks，另一个环境易受 4 attacks。我们负责地向所有云供应商披露了我们的调查结果。所有这些都证实了所确定的问题。 Community Impact：我们计划在GitHub - ZJU-SEC&#x2F;AbstractResourceAttack: This repository is used to analysis the shared resources of different containers中开源我们的工具和识别出的抽象资源，这样它们就可以帮助Linux内核community和容器community识别出OS-level虚拟化中资源隔离的弱点。 BackgroundOS-level虚拟化依赖于底层操作系统内核进行资源隔离和containment。更具体地说，Linux内核为资源隔离提供了namespace，为资源containment提供了cgroup。 Linux NamespacesLinux namespace提供进程级资源隔离。目前，Linux namespace分为8种类型。根据它们的发布时间，如下： Mount：用于文件系统隔离 UTS：用于主机名和域名隔离 IPC：用于消息队列隔离 PID：用于进程ID隔离 Network：用于网络资源隔离 User：用于UID&#x2F;GID隔离 Cgroup：用于cgroup隔离 Time：用于时钟时间隔离 一个进程可以被分配给不同类型的不同namespace。但是对于每种类型，它只能属于一个namespace。默认情况下，进程与其父进程在相同的namespace中。它可以在进程创建期间通过pass specific flags添加到新的namespace，或者在进程运行期间通过调用setns系统调用添加到新的namespace。理想情况下，只有同一namespace中的进程可以共享namespace隔离的资源。因此，资源是跨namespace隔离的。因此，一个namespace中的隔离资源耗尽不会影响其他namespace中的进程。这样的设计本质上要求namespace机制正确且彻底地contain资源。 然而，仍然有数百种抽象资源类型没有包含在namespace中。即使有namespace的保护，大型攻击面仍然存在。有人可能会主张使用namespace隔离所有抽象资源。然而，这是不切实际的:抽象资源的巨大数量和灵活性使得解决方案由于巨大的代码更改和高性能开销而无法接受。 Linux Control Groups另一方面，Linux cgroup用于限制限制资源的实用。cgroup负责控制组内所有进程使用的资源。cgroup被组织成树状结构，其中children的资源也包括parent的资源。对资源使用的限制也在树上递归地强制执行，以便cgroup中的资源使用不应超过其所有祖先的限制。 cgroup主要管理硬件资源，如CPU、内存、存储、IO等。有两个版本的cgroup，v1和v2，主要的区别是，cgroup v1对于每种类型的资源可以有一个树状层次结构，而控制组v2只有一个层次结构。resource account和resource usage limit的实现在v1和v2之间差别不大。目前默认使用cgroup v1，因为它更稳定，并提供更多对资源的控制。它管理13种资源类型，而v2目前只支持9种资源类型。更具体地说，在这13种资源中，有5种用于CPU accouting，包括cpu、cpuacct、cpuset、freeze、pref_event；其中3个是用于内存，包括memory、hugetlb、rdma；blkio用于storage；还有3个用于IO，包括devices、net_cls、net_prio。只有PIDs cgroup为PID的抽象资源。 虽然限制容器进程中共享抽象资源的使用可以减轻DoS攻击，但将cgroup扩展到包括所有抽象资源也是不切实际的。计算资源并对如此多类型的资源实施限制将引入不可接受的开销。 Abstract Resource Attacks Threat model and assumptions：在本文中，由于我们的目标是OS-level虚拟化，所以我们假设容器运行在相同的共享内核上。容器执行最先进的保护，并在部署中遵循最安全的实践。更具体地说，容器以不同的非根用户运行，删除了所有功能。而内核则为容器强制使用尽可能多的namespace和cgroup。此外，内核还使用seccomp来阻止敏感的系统调用。我们进一步假设内核没有bug，所有安全机制都正常工作。 另一方面，攻击者控制一个容器，并试图破坏在同一内核上运行的其他容器。攻击者可以在容器内运行任何代码并调用seccomp允许的系统调用。但是，他&#x2F;她不允许利用内核漏洞。此外，攻击者作为非根用户处于非特权容器中，根本没有任何功能。最后，攻击者不允许升级特权或重新获得任何功能。在下面的文章中，我们展示了由于内核中的共享抽象资源，即使这样的攻击者仍然可以对其他容器发起DoS攻击。 Weaknesses in OS-level Virtualization在OS-level虚拟化中，容器直接或间接地共享成千上万的内核抽象资源，这使它们容易受到资源耗尽攻击。我们利用Linux内核中的一个示例来说明细节。 12345678910111213141516171819202122232425static struct percpu_counter nr_files __cacheline_aligner_in_smp;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, const struct cred *cred)&#123; static long old_max; struct file *f; if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN) &#123; ... goto over; &#125; f = __alloc_file(flags, cred); if (!IS_ERR(f)) percpu_counter_inc(&amp;nr_files); ...over: ... return ERR_PTR(-ENFILE);&#125; 它定义了一个每个CPU计数器nr_files，一个函数get_nr_files()和一个函数alloc_empty_file()。 nr_files：这是一个每个CPU计数器，用于跟踪每个CPU上分配的文件结构的数量。 get_nr_files()：此函数通过读取nr_files计数器的正值，返回所有CPU上分配的文件结构的总数。 alloc_empty_file()：此函数接受两个参数，flags和cred，并尝试分配一个空的文件结构。 如果分配的文件结构的数量（get_nr_files()）大于或等于允许的最大值（files_stat.max_files），并且当前进程没有CAP_SYS_ADMIN能力，它将跳过文件分配并跳转到over标签。 如果满足条件，它将调用__alloc_file()函数来分配一个新的文件结构。 如果分配成功（即返回的指针不是错误），它会增加nr_files计数器。 如果分配失败或达到最大文件数且没有所需的权限，该函数将返回一个带有-ENFILE错误代码的错误指针。 代码显示了Linux内核中的全局变量nr_files和函数alloc_empty_file。alloc_empty_file分配struct文件(f = __alloc_file(flags, cred);)。对于每个分配的结构文件，nr_files通过增加计数器来计算(ercpu_counter_inc(&amp;nr_files);)。在主机Linux内核中，struct文件的总数受files_stat的限制。Max_files(if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN))。如果达到限制，alloc_empty_file返回一个错误(return ERR_PTR(-ENFILE);)。 然而，Linux内核并没有提供任何namespace或cgroup来隔离或限制nr_files。因此，nr_files是可以直接控制所有容器的–任何容器对结构文件的分配都会增加相同的共享全局变量nr_files。 这样的nr_files共享会导致新的攻击。在Linux中，所有东西都是一个文件。如此多的操作，如文件打开、进程创建、管道创建、新的网络连接创建，甚至计时器创建(timerfd_create)和事件生成(eventfd)，都增加了nr_files。恶意容器可以很容易地将nr_files弹出到其上限。实际上，在我们的实验中，nr_files的配额可以在几秒钟内快速耗尽。因此，所有使用struct文件的操作都将失败。 影响是严重的:受害者容器甚至不能运行命令(因为它需要打开命令文件)或执行新的二进制文件，导致程序崩溃。从上面的例子中，我们发现即使容器有足够的物理资源，比如CPU或内存，如果没有nr_files中的配额，它仍然不能运行任何新的程序。 为了证明抽象资源攻击会影响所有内核功能，我们针对Linux内核功能的每个方面(包括进程、内存、存储和IO管理)提出了一个抽象资源攻击。在本节中，我们将展示本地测试环境上的攻击结果.。 对于本地测试环境设置，测试机器具有Intel Core i5 CPU, 8 GB内存和500 GB HDD，运行Ubuntu 18.04和Linux内核v5.3.1。我们将其称为主机。在主机上，我们使用docker 18.06.0-ce建立了两个docker容器，分别作为攻击者容器和受害者容器使用。我们按照docker安全最佳实践设置了这两个容器，即在不同的非根用户中运行它们，删除所有功能，启用namespace和cgroup，并应用seccomp系统调用阻塞，如threat model中所讨论的那样。 Attacks on Process Management为了实现进程管理，Linux内核引入了一系列的抽象资源，如进程控制块struct task_struct、pid、state和各种数据结构来支持派生实体,如用于线程的struct thread_info、struct rq runqueues用于调度,struct shm_info和struct semaphore用于进程间通信（IPC），struct spinlock和struct semaphores来实现同步。事实上，Linux中的进程管理引入了成千上万的抽象资源。在下面，我们介绍针对结构idr的攻击，作为一个的例子。 Attacking idr of PIDLinux内核引入了用于整数ID管理的struct idr。进程管理也使用idr进行pid分配。代码显示了alloc_pid函数，该函数调用idr_alloc_cyclic来获得一个新的pid。Idr_alloc_cyclic在idr分配期间检查pid_max，如果idr增长超过pid_max，则返回一个负错误代码。稍后我们将展示，即使启用了PID namespace和PID cgroup，idr仍然可以被视为所有进程的全局共享资源。类似于fork炸弹，恶意容器进程可以重复fork耗尽所有idr。因此，共享内核上的所有容器都不能创建任何新的进程或线程。 在我们的实验中，攻击者-容器通过调用fork系统调用反复生成进程。结果，在受害容器中，所有与创建新进程相关的操作都失败，并报错“资源临时不可用”。即使是主机上的根用户也会遇到同样的故障。 12345678910111213struct pid *alloc_pid(struct pid_namespace *ns,pid_t *set_tid, size_t set_tid_size)&#123; ... nr = idr_alloc_cyclic(&amp;tmp-&gt;idr, NULL, pid_min, pid_max, GFP_ATOMIC); ... if(nr &lt; 0) &#123; retval = (nr == ENOSPC) ? -EAGAIN : nr; goto out_free; &#125; pid-&gt;numbers[i].nr = nr; ...&#125; 这段C代码片段是Linux内核中的一部分，涉及到进程ID（PID）的分配。它定义了一个名为alloc_pid的函数，用于在给定的namespace ns中分配一个新的PID。 alloc_pid函数接受以下参数： struct pid_namespace *ns：进程ID的命名空间，用于将PID限制在特定的namespace范围内。 pid_t *set_tid：指向一个包含线程ID的数组，这些线程ID与新分配的PID关联。通常用于clone系统调用。 size_t set_tid_size：set_tid数组的大小。 在函数的主体中： idr_alloc_cyclic()函数被调用以在tmp-&gt;idr中分配一个新的ID，范围在pid_min和pid_max之间。GFP_ATOMIC标志表示内存分配应该是原子性的，即在不释放内核锁的情况下进行分配。 如果nr小于0，说明分配失败。根据失败的原因，retval被设置为-EAGAIN（当nr等于ENOSPC）或nr。然后跳转到out_free标签。 如果分配成功，pid-&gt;numbers[i].nr被设置为新分配的ID。 这段代码负责在给定namespace中分配和管理进程ID。 The effectiveness of the PID namespaceLinux v2.6.24引入了PID namespace，它为进程提供了一组独立的PID，这些PID来自其他PID namespace。但是，在PID namespace实现中，Linux内核会在根PID namespace中为其他PID namespace中分配的任何PID分配一个额外的PID，这样其他PID namespace中的所有PID都可以映射到根PID namespace。换句话说，根PID namespace仍然是全局共享的。因此，即使攻击者-容器处于分离的PID namespace中，其PID分配仍然会耗尽根PID namespace中的PID，从而导致victim-container和主机上的new-process-create失败。因此，即使启用了PID namespace，容器仍然容易受到上述idr耗尽攻击的攻击。 The effectiveness of the PIDs control group最近在Linux v4.3中也引入了PIDs cgroup。它的作用是用来限制分配在一个控制组中的PIDs的总数。更具体地说，PIDs控制组在进程分叉过程中检查进程的限制，如果PIDs控制组中的总进程数（pids_cgroup-&gt;counter）达到上限（pids_cgroup -&gt;limit），则返回错误并中止分叉。PIDs控制组在防御直接分叉方面是有效的。然而，它只向当前进程收取pid号。attacker-container可以欺骗内核来分叉大量的内核线程，比如频繁中止导致内核产生中断处理线程。通过这种方式，idr被内核线程耗尽，这就绕过了由 PIDs cgroup。 Attacks on Memory ManagementLinux内核引入了各种内核数据结构，例如mm_struct用于保存进程的所有内存相关信息，vm_area_struct用于表示虚拟内存区域。此外，为了提高读写效率，Linux内核还使用内存作为缓冲区来缓存某些数据。此外，还介绍了回写方案，即只对内存进行写操作。脏内存页稍后将由内核线程写入磁盘。使用write-back方案，调用方只需要写入内存，而不需要等待耗时的磁盘io操作完成(即wirtr-through)，这大大提高了写性能。然而，我们发现内核并没有隔离或限制脏内存区域的使用，这给了攻击者耗尽所有脏内存的机会，这大大减慢了其他容器的速度。接下来，我们讨论对脏内存的攻击。 Attacking dirty_throttle_control memory dirty ratioLinux内核为脏区控制引入了dirty_throttle_control结构体，它使用dirty字段表示整个内核空间的dirty ratio。只要dirty值太高，内核就会唤醒后台线程，将脏内存同步到磁盘。但同时由于dirty比过高，内核会阻塞write_back，将所有写都转换为write_through，写性能大大降低。 不幸的是，内核没有为内存dirty ratio提供任何隔离。任何进程都可能影响全局内存dirty ratio。在我们的攻击中，攻击者-容器使用dd命令生成文件，快速占用所有脏内存，达到内存dirty ratio限制。结果，来自主机或受害者容器的所有写操作都被转换为write_through，这极大地降低了性能。在我们的实验中，由于攻击，受害者容器上的命令dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;mnt&#x2F;test bs&#x3D;1M count&#x3D;1024的性能从1.2 GB&#x2F;s下降到32.6 MB&#x2F;s，导致97.3%的减速。 此外，即使是主机上的特权根用户也有96.1%的性能下降。 请注意，当前Linux内核没有与内存管理相关的namespace，内存cgroup用于限制内存使用，而不是限制内存dirty ratio。因此，无法防御针对内存dirty ratio的攻击。 Attacks on Storage Management操作系统内核将磁盘或其他辅助存储抽象为文件，并引入各种与文件相关的抽象资源。实际上，Linux内核中的存储管理是复杂的，它涉及数千个函数和数据结构。在我们的实验中，我们发现有133个与存储相关的抽象资源可以从容器进程中访问。不幸的是，内核没有提供任何namespace或cgroup来隔离或限制这些抽象资源的使用。因此，攻击者容器可以耗尽这些抽象资源，对共享内核上的其他容器发起DoS攻击。 接下来，我们将说明恶意容器如何利用文件限制变量nr_files进行DoS攻击。 Attacking nr_filesnr_files是Linux内核中的一个全局变量，它计算内核中打开的文件总数。更具体地说，对于每个分配的结构文件，内核将nr_files加1。不幸的是，nr_files是所有进程共享的。它既不受namespace的隔离，也不受任何cgroup的限制。因此，攻击容器可以很容易地耗尽nr_files来实现DoS攻击。 为了验证这种攻击的可行性，我们的攻击容器生成了数百个进程，每个进程打开1024个文件。因此，nr_files达到其极限。结果，在主机和受害者容器上，所有文件打开操作都失败，内核发出“系统中打开的文件太多”的警告。我们的攻击证实，即使只有几百个进程，攻击者也能够耗尽nr_files。而为了可用性，pid cgroup通常允许数千个进程。因此，即使启用了pid cgroup，攻击者-容器仍然可以成功地对nr_files进行dos攻击。更糟糕的是，nr_files在所有进程(包括根进程和非根进程)之间共享。 因此，不仅非特权容器进程受到影响，主机上的根进程也不能执行任何文件打开操作。 12345678910111213141516171819202122232425static struct percpu_counter nr_files __cacheline_aligner_in_smp;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, const struct cred *cred)&#123; static long old_max; struct file *f; if(get_nr_files() &gt;= files_stat.max_files&amp;&amp;!capable(CAP_SYS_ADMIN)) &#123; ... goto over; &#125; f = __alloc_file(flags, cred); if (!IS_ERR(f)) percpu_counter_inc(&amp;nr_files); ...over: ... return ERR_PTR(-ENFILE);&#125; Attacks on IO ManagementIO管理是操作系统的重要组成部分。为了便于管理，Linux内核将IO设备抽象到/dev文件中，并引入抽象资源(如tty_struct)来实现IO设备管理。与前面的情况类似，这些抽象资源不受任何namespace或控cgroup的隔离或限制，因此会导致新的攻击。下面，我们将介绍针对pty_count的攻击，它会导致SSH连接出现DoS。 Attacking pty_countLinux内核将伪终端pseudo-terminal(缩写为pty)抽象为/dev/ptmx和/dev/pts。与此同时，内核还使用一个名为pty_count的全局变量来计算打开的pseudo-terminal的总数，每打开一次/dev/ptmx，pseudo-terminal的总数就增加1，如代码。但是，内核没有提供任何namespace或cgroup来隔离或限制pty_count的使用。因此，攻击者可以很容易地耗尽pty_count。 123456789101112131415161718static atomic_t pty_count = ATOMIC_INIT(0);int devpts_new_index(struct pts_fs_info *fsi)&#123; int index = -ENOSPC; if (atomic_inc_return(&amp;pty_count) &gt;= (pty_limit - (fsi-&gt;mount_ops.reserve ? 0 : pty_reserve))) goto out; return index;&#125;static int ptmx_open(struct inode *inode, struct file *flip)&#123; ... index = devpts_new_index(fsi); ...&#125; 这段C代码片段是Linux内核中的一部分，涉及到伪终端（PTY）的分配和管理。它定义了一个名为devpts_new_index的函数，用于在给定的文件系统信息fsi中分配一个新的伪终端索引。此外，还展示了一个名为ptmx_open的函数，它在打开伪终端主设备（PTMX）时调用devpts_new_index。 一个名为pty_count的原子变量被初始化为0。它表示当前分配的伪终端的数量。 devpts_new_index函数接受一个参数： struct pts_fs_info *fsi：一个指向伪终端文件系统信息的指针。 在devpts_new_index函数中： 初始化index为-ENOSPC，表示没有足够的空间分配新的索引。 增加pty_count的值。如果增加后的值大于等于pty_limit - (fsi-&gt;mount_ops.reserve ? 0 : pty_reserve)，则跳转到out标签。 返回index。 ptmx_open函数是在打开伪终端主设备（PTMX）时调用的。它接受两个参数： struct inode *inode：表示伪终端主设备（PTMX）的inode结构。 struct file *flip：表示伪终端主设备（PTMX）的file结构。 在ptmx_open函数中，调用devpts_new_index(fsi)以获取一个新的伪终端索引。 这段代码负责在给定的伪终端文件系统信息中分配和管理伪终端索引。当打开伪终端主设备（PTMX）时，会调用devpts_new_index函数以获取新的伪终端索引。 在我们的实验中，攻击者不断打开/dev/ptmx在触发ptmx_open，它调用devpts_new_index并增加pty_count。在几秒钟内，pty_count达到极限，所有接下来的ptmx_open操作都会失败。其后果很严重，因为pty设备被各种应用广泛使用，如SSH连接。结果是，由于伪终端打开失败，所有对任何其他容器的SSH连接尝试都会失败。更糟糕的是，主机无法启动任何新的容器，因为新容器的连接由于同样的错误而被拒绝。 Attacking FreeBSD and Fuchsia Kernels抽象资源攻击的根本原因是共享的内核数据(即抽象资源)。接下来，我们将演示共享内核数据还使FreeBSD和Fuchsia容易受到抽象资源攻击。 Attacking FreeBSD 在FreeBSD内核中，在Linux内核中类似的资源之后，我们手动识别了5个共享的全局抽象资源，分别是dp_dirty_total、numvnodes、openfiles、pid和pty。我们的实验进一步证实了前两个可以被DoS攻击，而后三个则受到rctl per-jail的限制。 实验是在FreeBSD 13.0-RELEASE和Ezjail-admin v3.4.2上进行的，运行在具有Intel酷睿i5处理器、8GB内存和40GB硬盘的虚拟机上。Ezjail是一个jail管理框架。ezjail命令提供了一种使用FreeBSD的jail系统创建多个jail的简单方法。这里的jail类似于Linux上的容器。我们根据FreeBSD手册建立了两个jail，并使用rctl来限制每个jail的资源。我们使用这两个jails作为attacker-jail和victim-jail，这类似于§3.1中的容器设置。 对于脏计数器dp_dirty_total, FreeBSD中的ZFS引入了dsl_pool结构体来记录每个ZFS池的数据。dsl_pool结构体使用dp_dirty_total字段表示整个ZFS池脏数据。当dp_dirty_total达到zfs_dirty_data_max的限制时，ZFS将延迟即将进行的写操作，并等待脏数据同步到磁盘。不幸的是，FreeBSD没有为dp_dirty_total提供任何隔离。在attacker-jail中，我们运行命令dd if=/dev/zero of=/mnt/test bs=1M count=1024(与§3.3中的相同)来耗尽dp_dirty_total。因此，victim-jail的IO性能下降了46%。 对于numvnodes, FreeBSD使用vnode结构体来表示文件系统实体，例如文件或目录。FreeBSD还保留了一个全局变量numvnodes来记录整个内核中vnode的总数。极限在maxvnodes。在实验中，通过在attacker-victim中重复创建目录，我们可以很容易地耗尽主机的numvnodes并达到maxvnodes的限制。 Attacking Fushsia Fuchsia使用Zircon内核，他引入了handle的概念，允许用户空间程序引用内核对象。Zircon维护了一个名为gHandleTableArena的全局数据结构，用于分配所有句柄。内核中handle的限制是kMaxHandleCount。handle在Zircon中使用非常频繁。令人惊讶的是，我们发现handle的创建不受限制。我们在Fuchsia模拟器上进一步确认了这个问题。具有基本权限(类似于Linux中的功能)的用户可以重复创建handle，耗尽所有handle，从而导致整个系统崩溃。我们向Fuchsia开发人员报告了这个问题。他们已经确认了这个问题，并计划在确定更多的攻击载体到本地DoS后修复这个问题。 Summary从上面的讨论中，很容易看出抽象的资源攻击是非常实用的，后果是严重的。更糟糕的是，抽象资源在Linux内核中非常常见，影响Linux功能的各个方面。此外，抽象资源攻击是操作系统级虚拟化所固有的。它也适用于FreeBSD和Fuchsia内核。 Static Analysis Of Container-Exhaustible Abstract Resources如前所述，抽象资源对容器至关重要。 另一方面，有成千上万的抽象资源，这使得几乎不可能列举所有这些资源。在本文中，我们迈出了识别容器共享的可耗尽抽象资源的第一步。 Challenges 首先，很难识别有意义的抽象资源，尤其是那些在内核中共享的资源。Linux内核中的抽象资源可以是变量或数据结构实例。然而，并非所有变量或数据结构实例都是有意义的抽象资源。我们需要找到对操作系统功能至关重要的抽象资源。此外，所识别的抽象资源需要在容器之间共享，以便一个容器可以耗尽这些资源来攻击其他容器。不幸的是，没有关于可共享抽象资源的文档。 为了解决这个问题，我们建议使用基于配置的分析configuration-based analysis和基于访问的分析access-based analysis来识别Linux内核中的各种共享抽象资源。 其次，决定容器是否可以用尽特定的抽象资源是一个挑战。与普通的用户空间程序不同，从容器中访问资源面临更多的限制，如namespace、cgroup和seccomp。此外，由于每个容器在一个单独的用户中运行，其资源消耗也受到每个用户的限制。因此，对资源消耗点的简单可达性分析不能说明容器对抽象资源的可控性。例如、对于被namespace隔离的抽象资源，即使容器可以消费这些抽象资源，由于namespace的隔离，它仍然可能不会影响其他容器。因此，为了克服这一挑战，我们提出了容器可控性分析，包括seccomp限制分析、per-user限制分析和namespace隔离分析，以进一步过滤容器可耗费的资源。 图显示了我们的工具的体系结构，它自动识别出容器可耗尽的抽象资源。分析工具以内核源IR作为输入。它首先使用§4.1中基于配置的分析和基于访问的分析来识别所有内核可共享的抽象资源。然后进行§4.2中的系统调用可达性分析和容器限制分析，包括seccomp、per-user和namespace限制分析，分析这些抽象资源上的容器可控性。 此外，我们在§4.3给出了分析结果。 Identification of Kernel Shareable Abstract Resources如前所述，从成千上万的内核变量和数据结构实例中识别有意义的抽象资源具有挑战性。更困难的是，为了确保这些抽象资源在容器之间直接或间接地共享，我们需要将它们缩小到可共享的内核抽象资源。 为了克服这一挑战，我们利用内核编程范例并提出基于配置的分析和基于访问的分析来识别内核可共享资源。 Configuration-based AnalysisLinux内核在/proc/sys下提供sysctl接口，允许用户空间程序配置内核参数。我们的主要观察结果是，这些sysctl配置中的大多数用于抽象的资源限制，例如限制文件数fs.file-nr或内存大页vm.nr_hugepages。因此，所有容器都共享由sysctl配置指定的相同全局限制。这样的sysctl配置提供了关于容器之间可共享的抽象资源的重要线索。 基于上述观察，我们建议使用sysctl配置来识别可共享的内核抽象资源，称为基于配置的分析，它包括三个基本步骤。 首先，它使用特定的sysctl数据类型来识别所有的sysctl相关数据结构。这些数据结构包含可配置的sysctl内核参数。 其次，sysctl数据结构通常包含在/proc/sys/文件夹中显示sysctl值的函数。因此，通过分析该函数，我们能够准确地找出该内核参数的变量。 最后，如果一个内核参数被用于限制资源消耗，它的相应变量应该出现在比较指令中。因此，我们按照使用-定义链来检查所确定的变量的使用情况，如果它在比较指令中被使用，就把它标记为抽象资源。 我们在LLVM中设计并实现了一个过程间分析通道。我们在代码中使用一个示例来说明细节。具体来说，Linux内核使用类型struct ctl_table来配置sysctl内核参数，例如代码中的第1行所示的fs_table中的文件系统配置。 因此，该通道首先遍历所有的内核全局变量，收集所有的结构ctl_table变量，如代码中的fs_table。其次，fs_table使用proc_handler中的函数指针来显示/proc/sys/文件系统中的参数。因此，从遍历所有的内核全局变量来收集所有的结构ctl_table变量，如代码中的fs_table。 第二，fs_table使用proc_handler中的函数指针来显示/proc/sys/文件系统中的参数。因此，从proc_handler字段中，通证遵循其指向，启动程序间分析以获得确切的变量，其值显示在sysctl配置界面中。如代码第19行所示，我们的传递将nr_files标记为关键变量。 第三，我们的传递检查所有已识别的关键变量的使用情况。如果一个关键变量在比较指令中被使用（即LLVM IR中的icmp），我们的传递就会记录这些位置并将这个变量标记为抽象资源。例如，在代码的第25行，nr_files被用于比较。我们的传递进一步检测到，如果比较失败，在第25行和第27行会返回一个错误。因此，我们的传递将nr_files标记为一个抽象资源。通过分析所有的struct ctl_table，我们的传递得到一个抽象资源的集合。 12345678910111213141516171819202122232425262728293031static struct ctl_table fs_table[] = &#123; ... &#123; .procname = &quot;file-nr&quot;, .data = &amp;files_stat, .proc_handler =proc_nr_files, &#125;, ...&#125;int proc_nr_files(...)&#123; files_stat.nr_files = get_nr_files(); ...&#125;static long get_nr_files(void)&#123; return percpu_counter_read_positive(&amp;nr_files);&#125;struct file *alloc_empty_file(int flags, ...)&#123; ... if(get_nr_files() &gt;= files_stat.max_files &amp;&amp; !capable(CAP_SYS_ADMIN)) &#123; ... goto over; &#125; ...&#125; 这个代码片段是一个C代码，用于管理Linux内核模块中的文件资源。它定义了一个名为fs_table的ctl_table结构数组、一个用于设置当前打开文件数量的proc_nr_files函数、一个返回打开文件数量的get_nr_files函数，以及一个在打开文件数量未超过允许的最大值时分配新文件结构的alloc_empty_file函数。 以下是各个组件的详细解释： fs_table是一个ctl_table结构数组，用于定义/proc/sys/fs/目录中的sysctl条目。具有procname为”file-nr”的条目与当前打开文件的数量相关联。 proc_nr_files是一个设置当前打开文件数量的函数。当调用该函数时，它会使用get_nr_files()函数返回的值更新files_stat.nr_files。 get_nr_files是一个返回当前打开文件数量的函数。它通过从名为nr_files的percpu_counter结构中读取一个值来实现这一点。该结构用于以适用于多核系统的高效方式存储文件数量。 alloc_empty_file是一个尝试分配空文件结构的函数。它检查当前打开文件的数量（由get_nr_files()返回）是否大于或等于最大允许的文件数量（存储在files_stat.max_files中）。如果满足此条件且调用者没有CAP_SYS_ADMIN能力，则跳转到标签over，这个标签可能处理文件数量超过最大值的情况。 这个代码片段是Linux内核如何管理文件资源并对同时打开的文件数量施加限制的一个例子。 Access_based Analysis除了sysctl配置外，Linux内核还使用锁或原子机制来保护并发访问的资源。因此，我们建议使用并发访问作为标识来标识一组可共享的抽象资源。 由于（race condition）竞态条件和并发性分析是一个老话题，我们采用现有的lockset检测方法。如果锁在数据结构的某个字段上，我们将该数据结构标记为抽象资源，并将该函数添加到敏感函数集中。具体来说，如果在某个数据结构的字段上使用了锁，那么可以将此数据结构标记为抽象资源，并将涉及该字段的函数添加到敏感函数集合中。这意味着这些函数可能需要特别关注，因为它们可能会受到并发访问的影响。此外，如果一个变量在lock和unlock函数之间被定量地修改，我们也将其标记为抽象资源。例如，多个线程在没有锁保护的情况下访问同一数据结构，那么可以将这组资源标记为抽象资源。如果某个变量在 lock 和 unlock 函数之间被定量地修改（即，在锁保护下发生了修改），那么也可以将其标记为抽象资源。这有助于进一步确定可能受到并发影响的资源。 除了锁定&#x2F;解锁，我们还观察到原子计数器和percpu计数器还用于保护并发访问的数据，例如percpu_counter_inc和atomic_inc_return。因此，我们实现了一个pass来分析所有原子计数器和percpu计数器的使用情况。我们的传递首先分析函数参数，并将所有具有struct atomic_t、struct atomic64_t和struct percpu_counter参数的函数添加到原子/percpu函数集中。其次，遍历所有内核函数中的所有语句，以检查原子/percpu函数的所有使用情况。如果一个变量被传递给一个原子/percpu函数，我们将它标记为一个抽象资源。 识别具有原子/percpu计数器参数的函数. 遍历内核函数中的语句，检查原子/percpu函数的使用情况。 在实现过程中，我们发现LLVM链接器合并了具有相同内存布局的结构类型，例如typedef struct &#123;int counter;&#125; atomic_t和typedef struct &#123;uid_t val;&#125; kuid_t。原因是uid_t的类型是unsigned int，它的大小与int相同。因此，LLVM链接器将它们合并，并错误地使用kuid_t代替atomic_t。为了解决这个问题，我们跟踪LLVM链接器，并发现lib/ linker / irmove .cpp中的get方法将新类型与现有类型进行比较，如果内存布局相同，则合并它们。因此，我们通过注释掉比较和合并代码来禁用合并。 Container-Contorllability Analysis通过识别抽象资源，我们提出了容器可控性分析，以确保容器实际上可以消耗这些抽象资源。我们对容器可控性分析的想法是（two-fold）双重的。 首先，我们需要确保容器进程可以到达§4.1中的抽象资源消耗点。为此，我们基于内核控制流图执行传统的反向控制流分析，其中基于结构类型解析间接调用。如果没有从系统调用项到抽象资源消耗点的路径，我们将该抽象资源标记为容器不可访问的。 其次，注意，单靠可达性分析是不够的，我们需要进一步确保路径上没有额外的特定于容器的限制。换句话说，我们需要检查路径上是否存在任何限制检查，以确保容器可以耗尽这些抽象资源。如前所述，与用户空间程序不同，容器面临更多限制，如seccomp、namespace、cgroup以及每个用户的资源限制。由于我们的可达性分析是标准的，在接下来的文章中，我们将重点关注限制分析。 Seccomp Restriction AnalysisSeccomp是一种用于系统调用过滤的机制。我们对seccomp的限制分析如下。在我们的实现中，我们使用Docker默认的seccomp配置文件，它可以阻止超过50个系统调用。在从系统调用条目到资源消耗站点的所有路径中，我们过滤掉来自任何阻塞的系统调用的路径。 Per-User Restriction Analysis在实际部署中，容器通常以不同的用户运行。因此，每个容器的资源消耗也受到peruser资源配额的限制。例如，Linux提供了user-limits命令ulimit，用于限制用户的资源消耗。而ulimit的底层实现是使用rlimit来设置多个每个用户的资源配额。 除了ulimit, Linux还提供了允许用户利用PAM (Pluggable Authentication Module)部署每个用户配额的接口。PAM使用setup_limits函数来设置每个用户的资源配额，该函数调用setrlimit来配置多个rlimit约束。对于ulimit、rlimit和PAM所限制的资源，攻击者容器不能消耗超过每个用户配额的资源。因此，它无法完全控制这些抽象资源来发起DoS攻击。由于ulimit和PAM都使用rlimit来设置每个用户的资源配额，因此我们需要分析rlimit并过滤出受其限制的抽象资源。 对于rlimit分析，我们的关键观察是rlimit值通常在struct rlimit或struct rlimit64中指定。因此，我们首先遍历内核IR，以识别从struct rlimit或struct rlimit64加载的所有变量。然后，我们执行数据流分析，以跟踪这些变量的所有传播和使用，并在任何比较指令中使用这些函数时标记它们。在这些函数中，检查rlimit以限制某些资源。我们认为这些资源是攻击容器不可耗尽的，因此我们根据这些函数来过滤路径。我们的工具确定了40个检查rlimit的函数。 Namespace Isolation Analysis如前所述，Linux内核为资源隔离引入了namespace。对于namespace隔离的资源，Linux内核在每个namespace下为其创建一个“copy”，以便一个namespace中的修改不会影响其他namespace。因此，为了确认容器的可控性，我们需要确保那些抽象资源不受namespace的保护。这里的挑战是，尽管Linux有关于namespace的文档，但没有关于哪些抽象资源由namespace隔离的规范。 因此，我们提出了namespace隔离分析来系统地识别受namespace保护的抽象资源。 我们的主要观察结果是，对于namespace隔离的资源，对应的数据结构有一个指针字段，指向它所属的namespace。因此，我们的工具首先遍历内核中每种数据结构类型的所有字段。如果该类型具有名称空间指针，则将其标记为隔离资源。其次，对于已识别的隔离资源，我们的工具使用它来过滤§4.1中识别的共享抽象资源。 请注意，由于不同namesapce之间的映射，一些namespace隔离的资源仍然容易受到抽象资源攻击。如§3.2.2所述，idr由pid_namespace-&gt;idr隔离。但是，在非根PID namespace中分配的每个idr都映射到根PID namespace中的一个新的idr，以便根namespace可以管理它。因此，根PID namespace被所有PID namespace中的所有容器全局共享。因此，它仍然容易受到idr耗尽攻击。 在我们的分析中，我们手动过滤掉这些资源。 Analysis Results我们在LLVM 12.0中使用大约2500行c++代码实现了我们的分析工具。Linux内核IR是基于最新的Linux稳定版本v5.10和defconfig生成的。特别是，通过应用基于配置的分析和基于访问的分析，以及来自系统调用的可达性分析和seccomp限制分析，我们的工具确定了1844个容器可达的共享抽象资源。 Resource Filtering 通过每个用户配额限制和namespace隔离分析，我们的工具可以找到342个受rlimit限制或具有指向namespace结构的指针的资源。这些资源要么对路径进行限制检查，要么对其进行namespace。 我们进一步进行手工分析。具体来说，对于已识别的抽象资源中的每个资源𝑅，我们将遍历所有检测到的𝑅或𝑅字段的修改。如果修改不是定量的，比如被赋值为布尔类型、枚举类型或字符串类型，则将此修改标记为非定量的。如果对𝑅和𝑅字段的所有修改都是非定量的，我们将𝑅标记为不可耗尽的。我们的手工分析确定了492种不可耗尽的抽象资源，经过人工分析，仍然有1010个抽象资源。 Dynamic Validation 为了进一步验证这1010个资源的动态耗尽，我们开发了一个资源消耗的动态验证方法。对于每个资源，我们首先从可控性分析中获得其消耗点和触发的系统调用。在此之后，我们对这些消耗站点进行测量，以监控实际的资源消耗。接下来，我们执行相应触发系统调用的测试用例，以重复触发消费并记录结果。我们利用来自Linux测试项目的1156个测试用例，并开发177个新的用例来覆盖更多的用例。我们还开发脚本来自动化上述步骤。 我们应用动态验证方法来测试所有1010个资源的消耗。 对于1010个检测到的资源，其中700个不在驱动程序文件夹中，而其他310个资源在驱动程序文件夹中，在700个非驱动资源中，有389个资源可以动态重复触发，真阳性率为55.6%。驱动程序文件夹中的资源需要特别处理，原因有两个。首先，驱动程序是特定于硬件的。如果没有相应的硬件，就无法动态触发驱动程序代码。我们的主要观察结果是，大多数硬件支持的驱动程序在/dev或/sys/class文件夹下公开特定的接口。基于这种观察，我们删除了硬件不支持的驱动程序中的92个资源。第二，LTP提供的测试用例可能不覆盖特定的驱动程序。 为了解决这个问题，我们修改LTP测试用例并为驱动程序开发新的测试用例。218个驱动资源中，有112个驱动资源可以重复触发，真阳性率为51.4%。 识别容器可耗尽抽象资源是一项非常具有挑战性的任务，因为它需要领域知识来触发抽象资源的耗尽，并且需要评估这些资源耗尽时的影响。在本文中，我们进行了初步分析。请注意，彻底的分析和风险评估需要来自Linux内核和容器社区的帮助。因此，我们计划开源我们的工具和检测到的抽象资源。我们认为这将有助于Linux内核和容器社区识别资源隔离的弱点，并开发健壮的资源遏制方案。 Abstract Resource Attacks On Cloud Platforms在本节中，我们将进一步评估针对公共云供应商容器环境的抽象资源攻击。我们首先介绍环境设置，然后给出结果。 Environment Setup and Ethical Considerations为了评估抽象资源攻击的有效性，我们在本地和云平台上建立了容器环境。 本地测试环境已在§3.1中给出。 Ethical Considerations 对于云平台，我们打算尽可能减少我们的攻击对其他云用户的影响。因此，我们使用专用的虚拟服务器，如AWS EC2、Azure VM、谷歌GCE、阿里巴巴ECS来进行实验。此外，我们确保我们是该服务器的唯一用户。 此外，大多数容器用户利用容器编排系统来部署和管理容器。因此，我们选择了最流行的Kubernetes，并利用云供应商的Kubernetes服务在虚拟服务器上部署两个docker容器(即攻击者容器和受害者容器)。为了实现强隔离，我们为attacker-container和victim-container应用了不同的Kubernetes namespace。如§4.2所述，容器也受到每个用户配额的限制。为了在我们的实验中强制执行每个用户的配额，我们在不同的用户中运行攻attacker-container和victim-container，并强制执行每个用户的配额。我们还在§6中讨论了PAM可以部署的限制。 Amazon AWS 对于容器服务，我们使用Elastic Kubernetes Service (EKS)在EC2实例上部署两个容器实例。EC2实例包含4个cpu、8gb内存和20gb SSD磁盘。在容器部署期间，我们惊奇地发现“Amazon EKS默认pod安全策略”使用了EKS。特权为默认pod安全策略。请注意，此策略允许容器作为特权用户运行，还允许特权升级以及主机网络访问。 为了更好地演示我们提出的攻击的有效性，我们从本地测试环境采用了更强的安全策略，从EKS容器运行在非根用户中，删除所有特权，启用所有namespace和cgroup，并使用docker seccomp配置文件来阻止50多个敏感系统调用，包括ptrace、pivot_root等。我们对attacker-container和victim-container应用相同的安全策略。 MS Azure我们使用Azure Kubernetes服务（AKS），在Azure虚拟机上部署了两个容器实例。Azure虚拟机包含2个CPU、8GB内存和120GB磁盘。为了提高部署的容器的安全性，Azure在AKS中提供了pod安全策略的最佳实践，通过在yaml文件中设置runAsUser:1000，以非root用户的身份运行容器，并通过设置allowPrivilegeEscalation: false，拒绝特权升级。然而，它仍然增加了两种能力，即CAP_NET_ADMIN和CAP_SYS_TIME，并且没有强制执行seccomp。与AWS的设置一样，我们对AKS上的容器采取了更严格的安全策略。除了最佳实践建议（即非root用户和不允许特权升级），我们以非root用户运行AKS容器，放弃所有功能，启用所有的namespace和cgroup，并使用docker seccomp配置文件。来阻止50多个敏感的系统调用。我们对attacker-container和victim-container应用相同的安全策略。 Google Cloud 对于容器服务，我们选择Kubernetes并使用谷歌Kubernetes Engine (GKE)在谷歌计算引擎实例上部署两个容器实例。我们使用的谷歌计算引擎(GCE)实例包含4个cpu、16gb内存和100gb SSD。更具体地说，我们应用一个GCE实例，并基于该GCE实例上的常规运行时部署两个容器(即attacker-container和victim-container)。 对于容器部署，我们遵循GKS容器设置向导。谷歌Cloud提供了操作容器的最佳实践，建议避免使用特权容器。因此，在yaml配置文件的securityContext中，我们不允许特权升级，以非特权用户运行容器，并删除所有功能。GKS设置向导默认启用6个namespace和13个cgroup。此外，我们应用docker默认的seccomp配置文件来过滤敏感的系统调用。 此外，GKE还提供了谷歌的安全容器运行时- gvisor，它利用名为Sentry的用户空间内核为来自应用程序的系统调用提供服务。哨兵调用大约50个主机系统调用，根据需要提供服务。gVisor被认为是容器的安全沙盒运行时。对于基于gVisor的容器部署，其所有安全设置(包括非特权用户、删除功能)都与GKE docker运行时设置相同。 Alibaba Cloud 在容器服务方面，阿里云提供了弹性容器实例、Kubernetes容器服务、容器注册和阿里云服务Mesh。我们使用Kubernetes的容器服务在一个弹性计算服务(ECS)实例上部署两个容器实例。ECS实例包含4个cpu、16gb内存和120gb SSD盘。对于容器安全性，我们遵循容器服务部署的官方指南，该指南通过将runAsUser设置为1000来使用非根用户运行容器。但是，它并不禁止特权升级，也不强制执行seccomp和SELinux。 我们采取了与以往相同的更强有力的安全政策。我们在非根用户中运行容器，删除所有功能，启用所有namespace和cgroup，并使用docker seccomp配置文件来阻止敏感的系统调用。我们对attacker-container和victim-container应用相同的安全策略。 Selection of Abstract Resources为了进行攻击，我们需要选择有意义的抽象资源。为了演示抽象资源攻击的有效性，我们希望选择影响操作系统服务各个方面的抽象资源，包括进程管理、内存管理、存储管理和IO管理。 因此，我们首先根据它们的声明位置将所有标识的资源分为这四类，即用于进程、内存、存储和IO管理的资源。然后，我们根据我们的领域知识从每个类别中选择至少一个资源，即我们知道资源耗尽的影响。 最终，我们选择了涵盖所有四个方面的7个抽象资源，。资源名称列在表的第二列中。在所选的抽象资源中，基于访问分析识别出PID idr、dirty ratio、inode、netns_ct-&gt;count、random entropy个，基于配置分析识别出nr_files、pty_count 2个，如表第三列所示。我们还在表的第四列中列出了资源消耗函数，在表的最后一列中列出了用于触发攻击的系统调用。 Attacking Results on Cloud Platforms如前一节所述，我们为我们提出的攻击设置了5个测试环境，包括本地、AWS、Azure、谷歌云和阿里云。对于每个测试环境，我们设置了两个具有严格安全策略的容器，作为attacker-container和victim-container。attacker-container针对某些抽象资源发起攻击。我们使用上述7个选定的抽象资源来发起攻击。在victim-container和主机上都运行一个基准测试，以测量它们在抽象资源攻击下的性能下降。结果如表所示。 PID idr攻击。PID idr攻击及其根源已在§3.2.1中详细介绍。针对厂商的PID攻击，所有受害容器，甚至在Local、AWS、Azure和谷歌测试环境中的主机都不能fork新的进程。victim-container甚至会被驱逐。阿里云不容易受到PID攻击。 dirty ratio攻击。dirty ratio攻击已经在§3.3.1中讨论过。如果没有攻击，则认为IO性能为100%。在dirty ratio攻击下，受害容器在AWS、Azure和阿里云上的IO性能分别下降到6.3%、1.2%和6.7%。更糟糕的是，主机也容易受到这种攻击，其IO性能在AWS上下降到8.3%，在阿里云上下降到8.6%。这里MS Azure不提供对主机的任何访问，因此我们无法获得Azure主机IO性能。谷歌云不容易受到dirty ratio攻击。 inode攻击。在inode攻击中，受害者容器不断分配inode结构。不幸的是，mount namespace没有隔离inode。Linux内核都不提供任何与inode相关的cgroup。结果，该分区上的所有inode都被耗尽。所有消耗inode的操作都会失败，包括来自victim-container或主机的操作。在我们的实验中，阿里云很容易受到inode攻击。victim-container甚至会被驱逐。此外，主机也不能创建任何新文件。 nr_files攻击。nr_files攻击已经在§3.4.1中讨论过。nr_files由所有容器全局共享。没有namespace或cgroup来限制它的使用。当nr_files配额耗尽时，各种操作都会失败，包括打开文件、执行新程序、创建管道、创建套接字和创建计时器，因为Linux中的所有东西都是文件。我们的实验表明，所有排名前4的供应商都容易受到nr_files攻击。 pty_count攻击。pty_count攻击已经在§3.5.1中讨论过，它会耗尽所有开放的伪终端配额。这将导致所有需要打开新的伪终端的操作失败，如SSH连接等。不幸的是，所有前4个供应商都容易受到pty_count攻击。 netns_ct-&gt;count攻击。Linux内核中的Netfilter提供了连接跟踪功能，可以跟踪所有的逻辑网络连接。而总连接数是有限制的，由struct netns_ct-&gt;count来计数。主机和容器都需要维护连接。尽管容器位于不同的net namespace中，但它们的所有连接都需要使用init_net.ct。主机的init net namespace的计数。因此，如果在短时间内产生大量的TCP连接，就会消耗掉init_net.ct的所有配额。计数，导致Netfilter故障。在我们的实验中，attacker-container可以耗尽init_net.ct。数秒内计数，导致随机丢包。同样，前4个供应商的所有环境都容易受到结构体netns_ct-&gt;count攻击。 random entropy攻击。在Linux内核中，每次读取/dev/random都会消耗random entropy。每当random entropy下降到阈值以下时，Linux内核就会阻塞对/dev/random的读取操作，并等待entropy增加。 由于没有namespace或cgroup来隔离random entropy，attacker-container很容易通过反复读取/dev/random来消耗所有的random entropy，从而导致良性的读取阻塞。最新的Linux内核v5.10通过将/dev/random读重定向到/dev/urandom修复了这个问题。然而，Azure和阿里云都容易受到这种攻击。 Attacking gVisor我们还对gVisor进行了7种资源攻击。为了建立gVisor环境，我们在谷歌Kubernetes Engine (GKE)中选择runsc而不是runc作为容器运行时，如§5.1所述。其中nr_files攻击和netns_ct-&gt;count攻击两种攻击在gVisor环境下仍然有效。在接下来的文章中，我们将分析为什么这两种攻击可以在gVisor上工作。 对于nr_files, gVisor使用Sentry为系统调用服务，而Gofer为Sentry处理不同类型的IO。Sentry拦截来自容器的open syscall并将请求发送给Gofer。在另一边，Gofer通过调用主机操作系统的openat系统调用来处理该请求。最终，主机操作系统上的openat系统调用触发了alloc_empty_file函数，它消耗了nr_files。通过这种方式，gVisor的攻击者能够耗尽主机的nr_files。对于netns_ct-&gt;count，Sentry拦截连接系统调用，并使用自己的网络堆栈将数据包转发到主机中创建的veth-peer网卡。vth -peer连接到主机中的虚拟网桥。当网络帧通过虚拟网桥转发时，主机上的netfilter被触发调用nf_conntrack_alloc函数，该函数消耗netns_ct-&gt;count。因此，gVisor中的攻击者仍然可以耗尽主机的netns_ct-&gt;count。 Summary对于自部署的共享内核容器环境，其中两个易受6次攻击，一个易受5攻击，另一个易受4攻击。令人惊讶的是，gVisor运行时也容易受到两种攻击——nr_files攻击和netns_ct-&gt;count攻击。我们已经向所有四个供应商报告了这些攻击。他们都确认了问题存在于他们的共享内核容器环境中。 尽管顶级供应商使用虚拟机来隔离不同租户的容器，但由于几个原因，抽象资源攻击仍然是可行的。首先，正如在Linux、FreeBSD和Fuchsia上所演示的，抽象资源攻击是操作系统级虚拟化所固有的，因此是一种广泛的攻击类型。其次，没有经验的用户可能不了解共享内核的风险，可能会使用容器进行sand-boxing。我们的论文将有助于提高对风险的认识。第三，即使在同一个租户中，竞争的团队也可能通过利用抽象资源来攻击对方。因此，监控和减轻此类攻击仍然是必要的。 Mitigation Discussions在本文中，我们揭示了除了物理资源，容器还共享底层运行内核的抽象资源。这些抽象资源很容易被攻击，后果很严重。在下面，我们给出了多种策略来降低抽象资源带来的风险。 Using PAM for per-user quota restrictions 正如正如第4.2节中提到的，Linux内核提供了允许用户加载用户定制的PAM的接口。PAM能够限制18种资源，其中5种为抽象资源，包括maxlogin/maxsyslogins、nofile、nproc和sigpending。从我们与云计算供应商的沟通中，我们不知道有任何云计算供应商采用PAM。因此，我们建议对某些抽象资源的限制使用PAM。§4.2节提到的，Linux内核提供了允许用户加载用户定制的PAM的接口。PAM能够限制18种资源，其中5种为抽象资源，包括maxlogin/maxsyslogins、nofile、nproc和sigpending。从我们与云计算供应商的沟通中，我们不知道有任何云计算供应商采用PAM。因此，我们建议对某些抽象资源的限制使用PAM。 Using VM for strong isolation 对于安全关键型应用程序，我们建议不要使用多租户容器环境。更强的隔离方案，例如基于虚拟机的虚拟化，是更可取的。 Using Monitoring Tools 我们建议使用Kubernetes集群的监控工具，如Falco，来监控容器的资源消耗。对于敏感的抽象资源(如nr_files和inode)，用户应该自定义自己的规则来监视系统中特定的资源消耗。 Improving current isolation design 对于现有的namespace，如PID namespace，由于映射到根namespace的设计，无法防御资源耗尽攻击。如§3.2.2所述，Linux内核在根PID namespace中为在其他PID namespace中分配的任何idr分配一个额外的idr。因此，根PID namespace仍然是全局共享的。攻击者仍然可以很容易地耗尽根PID namespace中的PID，从而导致DoS攻击。出于类似的原因，即使被NET namespace隔离，nf-conntrack 数 netns_ct-&gt;count也可能被攻击。因此，Linux社区需要重新审视namespace的设计，消除namespace依赖关系以提高隔离性。 New kernel containment mechanisms Linux内核社区和容器社区需要投入更多精力来保护抽象资源。实际上，我们已经向Docker安全团队报告了这个问题。反馈是“Linux容器只能使用可用的内核隔离机制。如果没有内核机制来控制限制，容器就不能做任何事情来限制它”。因此，我们首先需要对所有容器共享的抽象资源进行彻底的分析，以便我们能够理解，更重要的是，清除它们的数据依赖关系。这需要全面的内核领域知识和大量的内核代码更改。而且，Linux内核最初并不是为支持操作系统级虚拟化而设计的。它的资源隔离和遏制是不完整的。因此，需要新的namespace和cgroup。 More restrictive system call blocking 从容器方面来看，目前，即使执行了seccomp，容器中的应用程序仍然可以访问大约250个系统调用。在我们了解这些系统调用的数据依赖性之前，建议执行更严格的seccomp配置文件来阻止更多不必要的系统调用。容器用户可以使用技术来获得更严格的seccomp配置文件，以减少潜在的抽象资源攻击的可能性 Related WorkVirtualization Techniques在云环境中有两种主流的虚拟化技术，基于vm的虚拟化和OS-level虚拟化。与基于vm的虚拟化相比，OS-level虚拟化越来越流行，因为它可以通过轻量级虚拟化实现完整的应用程序功能。为了充分了解性能优势，研究人员进行了一系列研究。Felter等人表明，通过使用一组涵盖多个资源的基准测试，Docker在所有情况下都可以获得比KVM更好的性能。Joy等人在性能和可伸缩性方面对Linux容器和虚拟机进行了比较。Zhang等人的研究表明，容器在大数据环境中具有比虚拟机更好的性能。 所有这些工作都表明，操作系统级虚拟化比传统的基于虚拟机的虚拟化具有更好的性能。然而，他们都没有注意到底层内核抽象资源的潜在影响。本文揭示了抽象资源引入的新的攻击面。 Resource IsolationLinux使用功能来禁止没有特定功能的进程访问相应类型的资源实例。 研究人员提出了基于Linux功能的方法，如Wedge ， Capsicum和ACES。这些工作执行更细粒度的能力控制，以减轻内存损坏攻击。然而，他们不能防御我们的DoS攻击，耗尽可访问的共享资源。 内存地址空间隔离是一种典型的资源空间隔离方案，避免内存地址资源耗尽。Linux命名空间隔离了§2.1中列出的8种资源。这些方案只能隔离有限类型的资源。资源容器建议扩展单片内核，隔离系统资源，在线程级对资源进行划分，类似于控制组。由于性能开销很大，使用资源容器来保护所有抽象资源是不切实际的。EdgeOS为边缘云部署了强隔离的操作系统。然而，采用没有硬件支持的微内核会比单片内核引入更多的开销。Faasm使用软件故障隔离(SFI)进行内存隔离，而在无服务器计算中使用名称空间隔离网络资源空间。然而，大多数共享资源仍然暴露在DoS攻击的威胁之下。 Container Security除了资源隔离之外，还有对容器安全性的研究。Gao等人发现，可以利用&#x2F;proc或&#x2F;sys的信息泄露，发动电源攻击。而同一研究小组还进行了5次攻击，产生带外工作负载，以打破Linux控制组的资源约束。但它们主要针对信息泄露问题或攻击CPU、IO等物理资源，而不是抽象资源。 Lin等人表明容器不能隔离内核漏洞。另一项工作使用静态分析来分析Docker的代码，以找到漏洞和修补代码之间的差异。然而，这些工作主要针对现有的漏洞和利用。相反，我们的工作引入了针对共享抽象资源的新攻击。 此外，还有加固集装箱的工作。Lei等人提出了一种名为SPEAKER的容器安全机制，以减少应用程序在容器中可用的系统调用。Sun等人开发了为每个容器提供安全策略隔离的安全namespace。另一项工作使用Intel SGX保护容器，它提供了一个低性能开销的小型可信计算基础。Brady等人实现了容器图像的安全评估系统。然而，所有这些作品中的容器仍然依赖于内核提供各种服务，因此仍然容易受到抽象资源攻击。 Conclusion在本文中，我们揭示了共享内核在操作系统级虚拟化中引入的一种新的攻击面。这些容器直接或间接地共享成千上万的抽象资源，这些资源很容易被耗尽，从而导致对其他容器的DoS攻击。 为了显示限制抽象资源的重要性，我们进行了抽象资源攻击，针对操作系统内核的不同方面的抽象资源。结果表明，攻击抽象资源具有很强的实用性和关键性。 抽象资源本身就难以包含。为了了解这些攻击面，我们首先进行了一次系统分析，以识别Linux内核中易受攻击的抽象资源。我们的工具成功检测了501个动态触发的抽象资源，从中选取了7个，并在排名前4的云供应商的自部署共享内核容器环境中进行了攻击实验。结果表明，所有环境都容易受到我们的攻击。为了降低风险，我们为容器用户和开发人员提供了一些建议。 My硬件虚拟化和OS-level虚拟化虚拟化技术通常可以分为两大类：操作系统级虚拟化（OS-level virtualization）和硬件虚拟化（hardware virtualization）。这两者的主要区别在于虚拟化层的位置以及资源分配方式。 操作系统级虚拟化（OS-level virtualization)操作系统级虚拟化是一种轻量级虚拟化技术，它允许在单个操作系统内运行多个独立的、隔离的应用程序或服务。在这种方式下，所有虚拟实例共享相同的操作系统内核，但每个实例拥有自己的文件系统、进程、网络等资源。 详细说明： 资源分配：操作系统级虚拟化使用容器（Container）技术将系统资源（如CPU、内存、磁盘、网络等）划分给各个虚拟实例。容器之间相互隔离，互不干扰。 性能：操作系统级虚拟化具有较低的性能开销，因为所有虚拟实例共享相同的操作系统内核，避免了多个操作系统之间的资源竞争。 灵活性：操作系统级虚拟化支持的操作系统类型受限于宿主机操作系统，因此在跨平台方面的灵活性较差。 实现方式： Linux：LXC（Linux Containers）、Docker FreeBSD：Jails Solaris：Zones&#x2F;Containers 硬件虚拟化（Hardware virtualization）硬件虚拟化是一种全面的虚拟化技术，它允许在单个物理机器上运行多个独立的、完全隔离的操作系统实例。在这种方式下，虚拟化层位于操作系统和硬件之间，为每个虚拟机提供一个虚拟硬件环境。 详细说明： 资源分配：硬件虚拟化使用虚拟机（Virtual Machine）技术将系统资源（如CPU、内存、磁盘、网络等）划分给各个虚拟实例。虚拟机之间相互隔离，互不干扰。 性能：硬件虚拟化具有较高的性能开销，因为每个虚拟机需要运行独立的操作系统内核，导致资源竞争和虚拟化开销。 灵活性：硬件虚拟化支持运行不同类型的操作系统，具有较强的跨平台灵活性。 实现方式： 基于软件的虚拟化：VMware Workstation、VirtualBox 基于硬件的虚拟化：Intel VT-x、AMD-V 虚拟化管理器（Hypervisor）：VMware ESXi、KVM（Kernel-based Virtual Machine）、Microsoft Hyper-V、Xen 总结起来，操作系统级虚拟化和硬件虚拟化的主要区别在于虚拟化层的位置以及资源分配方式。操作系统级虚拟化通过共享相同的操作系统内核实现较低的性能开销，但跨平台灵活性较差；硬件虚拟化允许运行多个独立的操作系统实例，具有较强的跨平台灵活性，但性能开销较高。 LLVMLLVM（Low Level Virtual Machine）是一个编译器基础设施项目，它提供了一系列模块化和可重用的编译器组件和工具链。LLVM的设计目标是为各种编程语言提供一个通用的中间表示（Intermediate Representation，IR），以及一套用于优化、分析和生成机器代码的编译器后端。LLVM项目包括一些子项目，如Clang（C、C++和Objective-C的编译器前端）和LLDB（一个调试器）。 LLVM的核心组件包括： LLVM IR：LLVM中间表示是一种低级别、类型化、平台无关的编程语言，用于表示程序的结构和行为。LLVM IR既可以表示为人类可读的文本，也可以表示为二进制格式。 编译器前端：编译器前端将源代码（如C、C++、Rust等）解析成LLVM IR。Clang是LLVM最著名的编译器前端，用于处理C、C++和Objective-C语言。其他语言也有针对LLVM的编译器前端。 优化器：LLVM提供了一系列通用的代码优化和转换通道，这些通道可以在LLVM IR上进行操作，例如：常量折叠、死代码消除、循环不变式代码移动等。优化器可以根据需要配置和组合，以生成高度优化的代码。 编译器后端：编译器后端将优化后的LLVM IR转换为特定架构的机器代码。LLVM支持多种目标平台，包括x86、ARM、MIPS、WebAssembly等。编译器后端还负责处理调用约定、寄存器分配和指令调度等底层细节。 LLVM的优势在于其模块化、可扩展和可重用的设计。这使得LLVM可以很容易地支持新的编程语言和硬件架构，而不需要重新实现整个编译器。这也使得LLVM成为了许多编程语言（如Rust、Swift和Julia）和平台（如WebAssembly、GPUs和FPGAs）的编译器基础设施的首选。 Linux cgroup的组织和结构cgroup 是一种用于限制和控制进程资源使用的实用工具： 限制资源：Linux cgroup 的主要目的是限制进程使用的资源，如 CPU 使用率、内存、磁盘 I&#x2F;O 等。这有助于确保系统上的各个进程不会过度消耗资源，从而影响其他进程或整个系统的性能。 控制组内进程：cgroup 负责管理和控制组内所有进程的资源使用。这意味着你可以将一组进程组织在一个 cgroup 中，并对整个组施加资源限制，而不是单独设置每个进程的限制。 树状结构：cgroup 的组织方式是树状结构，其中每个节点（cgroup）可以包含若干子节点（子 cgroup）。这种结构允许你对资源使用进行分层管理，通过在不同层次施加不同的限制，可以更灵活地控制进程资源使用。 子节点和父节点的资源关系：在 cgroup 树状结构中，子 cgroup 的资源限制包括其父 cgroup 的资源限制。这意味着子 cgroup 不能单独设置超出其父 cgroup 限制的资源使用。这有助于维护整体资源限制的一致性，并确保子 cgroup 不会因过度消耗资源而影响其父 cgroup 或整个系统。 递归强制执行：cgroup 树结构中的资源限制是递归强制执行的。这意味着一个 cgroup 的资源使用限制将受到其所有祖先（父、祖父等）cgroup 限制的约束。这可以确保在整个 cgroup 树结构中，资源限制得到恰当的执行和遵守。 总之，Linux cgroup 是一种用于限制和管理进程资源使用的实用工具。它采用树状结构来组织进程，允许分层管理资源，并通过递归强制执行来确保资源限制得到遵守。 fork炸弹和idrfork炸弹Fork 炸弹是一种拒绝服务攻击（DoS攻击），其目的是通过创建大量子进程耗尽系统资源，从而导致系统崩溃或无法响应。攻击者可以编写一个简单的程序，使其反复调用 fork() 系统调用，每次调用都会创建一个新的子进程。这些子进程可能会继续创建更多子进程，从而导致进程数量迅速增加。这种攻击方法也被称为“逻辑炸弹”或“蠕虫炸弹”。 在 Linux 系统中，fork() 系统调用用于创建一个新进程，它是当前进程的一个副本。新进程（子进程）继承了父进程的资源（如打开的文件描述符、内存映射等），并从父进程的当前执行点开始执行。子进程拥有自己的独立地址空间和资源，并分配一个唯一的进程 ID。 idr在 Linux 内核中，IDR（ID Radix Tree）是一种用于管理和查找整数类型对象标识符（如进程 ID、文件描述符等）的数据结构。IDR 是一种基于基数树（radix tree）的高效数据结构，可以快速查找、添加和删除 ID。IDR 用于分配唯一的 ID 给内核对象，如进程、线程、文件等，以便在内核中进行跟踪和管理。 fork 炸弹会通过创建大量子进程来耗尽所有可用的进程 ID，从而导致系统无法创建新的进程。这可能会导致系统性能下降、响应缓慢甚至崩溃。为了防止这类攻击，系统管理员可以通过设置进程数资源限制（如使用 ulimit 命令）或在容器中使用cgroup 限制进程数来保护系统。 clone系统调用clone() 系统调用是 Linux 中用于创建进程和线程的一个底层函数。与 fork() 相比，clone() 提供了更多的选项和灵活性，因为它允许程序员指定哪些资源应该在父进程和新创建的子进程之间共享。这使得 clone() 适用于创建轻量级的线程以及新的独立进程。 clone() 系统调用的原型如下： 1int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...); 参数说明： fn：一个函数指针，指向子进程或线程开始执行的函数。子进程或线程运行结束后，这个函数应该返回一个整数值，用于表示退出状态。 child_stack：指向子进程或线程的栈空间的指针。子进程或线程在执行过程中将使用这个栈空间。 flags：用于指定子进程或线程的行为和资源共享的位掩码。这些标志包括 CLONE_VM（共享内存空间）、CLONE_FS（共享文件系统信息）、CLONE_FILES（共享文件描述符表）等。通过组合这些标志，程序员可以精细控制子进程或线程的行为。 arg：传递给 fn 函数的参数。通常，它是一个指向某种结构或数据的指针。 clone() 系统调用的返回值在父进程和子进程中有所不同。在父进程中，clone() 返回新创建的子进程或线程的进程 ID（PID）。在子进程中，clone() 返回 0。如果创建失败，clone() 返回 -1，并设置相应的错误码。 clone() 系统调用的使用相对复杂，通常不直接在应用程序中使用。在实践中，程序员更倾向于使用更高级别的库函数，如 pthread_create()（用于创建线程）或 fork()（用于创建进程）。这些库函数在内部使用 clone() 系统调用来完成进程和线程的创建。 脏内存脏内存（Dirty Memory）是计算机内存管理中的一个概念，指的是已经被修改过但尚未写回到持久存储（如硬盘）的内存数据。在操作系统和应用程序中，内存（RAM）被用作缓存，以加速对数据的访问。与磁盘相比，内存访问速度要快得多，因此将数据缓存在内存中可以提高系统性能。 当一个程序或操作系统修改了内存中的数据，与磁盘上的原始数据不再一致时，这部分内存就被称为 “脏内存”。脏内存中的数据最终需要写回到磁盘，以确保数据的一致性和持久性。以下是脏内存产生的一些常见场景： 文件系统缓存：操作系统通常会将磁盘上的文件数据缓存在内存中，以提高文件访问速度。当一个程序修改了文件内容时，内存中的缓存数据变为脏内存。这些脏内存数据最终需要同步回磁盘，以确保文件在磁盘上的内容与内存中的内容一致。 数据库缓存：数据库系统经常使用内存来缓存数据库表和索引中的数据。当数据库事务修改了表中的数据时，相应的内存缓存数据也会变为脏内存。这些脏内存数据需要在适当的时机写回到磁盘，以确保数据的一致性和持久性。 虚拟内存管理：在虚拟内存管理中，操作系统通过将内存中的数据与磁盘上的交换空间（或页面文件）进行交换，来模拟更大的内存空间。当操作系统需要将内存中的数据交换出去时，如果这部分数据是脏内存，操作系统需要先将其写回到磁盘，然后才能将其交换出去。 操作系统通常会使用一些策略来平衡脏内存的处理和系统性能。例如，Linux 内核通过监控脏内存占比（dirty ratio），在必要时触发后台线程将脏内存同步到磁盘。这样可以在提高系统性能的同时，确保数据的一致性和持久性。 Linux处理脏内存 Linux 内核如何处理脏内存（即已修改但尚未同步到磁盘的内存）的过程。在 Linux 内核中，dirty_throttle_control 结构体用于管理和控制脏内存。结构体中的 dirty 字段表示整个内核空间的脏内存占比（dirty ratio）。 当 dirty 值过高时，内核会唤醒后台线程（例如 pdflush、flusher 或 kswapd），将脏内存同步到磁盘。这有助于确保数据的一致性和持久性，防止意外丢失。 然而，如果 dirty 值太高，内核会阻塞 write_back 操作。这意味着内核将所有写操作都转换为 write_through 操作，从而降低写性能。接下来，我们解释 write_back 和 write_through 之间的区别： write_back：在 write_back 操作中，数据首先写入缓存（例如 CPU 缓存或文件系统缓存）。一旦数据被写入缓存，操作就被认为是完成的，即使数据尚未同步到磁盘。在后台，脏数据会在适当的时机被刷新到磁盘。write_back 的优势在于它可以提供较高的写性能，因为写操作可以立即返回，而不需要等待磁盘同步。 write_through：在 write_through 操作中，数据同时写入缓存和磁盘。写操作在数据被写入磁盘之前不会被认为已完成。虽然这可以确保数据的一致性和持久性，但 write_through 的性能通常低于 write_back，因为它需要等待磁盘同步。 总之，这段话描述了 Linux 内核如何在处理脏内存时在性能和数据一致性之间寻求平衡。当脏内存占比过高时，内核会采取措施降低写性能，以确保数据的一致性和持久性。 Linux伪终端Linux 内核使用 /dev/ptmx（主设备）和 /dev/pts（从设备）来实现伪终端（pseudo-terminal，简称 pty）。伪终端是一种特殊的终端设备，它不直接连接到物理设备，而是通过软件来模拟终端的输入和输出。伪终端广泛应用于远程登录（如 SSH）、终端模拟器（如 xterm）和其他需要模拟终端行为的场景。 以下是关于伪终端和 /dev/ptmx 以及 /dev/pts 的一些详细信息： 主设备（&#x2F;dev&#x2F;ptmx）：/dev/ptmx 是一个字符设备文件，用于创建伪终端的主设备。当一个进程（如 SSH 服务器或终端模拟器）需要创建一个新的伪终端时，它会打开 /dev/ptmx 设备文件。内核会为这个进程分配一个未使用的伪终端，并返回一个指向伪终端主设备的文件描述符。主设备用于管理伪终端，如接收从设备的输入数据、向从设备发送输出数据等。 从设备（&#x2F;dev&#x2F;pts）：/dev/pts 是一个虚拟文件系统（通常挂载在 /dev/pts 目录下），用于存储伪终端的从设备。当一个伪终端被创建时，内核会在 /dev/pts 目录下为其从设备分配一个唯一的编号（如 /dev/pts/0、/dev/pts/1 等）。从设备用于模拟终端的输入和输出操作，如读取用户输入、显示文本输出等。通常情况下，从设备会被分配给另一个进程（如 shell），以便它可以与主设备进行通信。 通过主设备和从设备的交互，伪终端实现了终端模拟器和其他类似程序与 shell、远程会话等之间的通信。这种抽象使得伪终端可以在不依赖于特定硬件的情况下，提供与物理终端类似的功能。 FreeBSD和FuchsiaFreeBSD和Fuchsia是两种不同的操作系统。下面我们分别详细解释这两个操作系统。 FreeBSDFreeBSD是一个类Unix的开源操作系统，它基于创建Unix的Berkeley Software Distribution（BSD）的源代码。FreeBSD成立于1993年，是BSD家族的一个成员，与NetBSD和OpenBSD等其他BSD操作系统并行发展。 FreeBSD的特点： 开源：FreeBSD的源代码可以免费获取和修改，遵循BSD许可证。这使得许多公司和开发者可以根据自己的需求定制操作系统。 稳定性：FreeBSD以其稳定性和可靠性而闻名，使其成为服务器和关键基础设施的理想选择。 性能：FreeBSD的性能优异，被广泛应用于高性能计算、网络服务和存储解决方案。 安全性：FreeBSD提供了多种安全功能，如强制访问控制、安全级别和防火墙集成。 可移植性：FreeBSD支持多种硬件平台，包括x86、x86-64、ARM、MIPS和PowerPC等。 FuchsiaFuchsia是由谷歌（Google）开发的一个开源操作系统。与FreeBSD不同，Fuchsia不是基于Unix的，而是基于名为Zircon的新内核构建的。Fuchsia的开发始于2016年，目标是创建一个高度模块化、可扩展且可用于各种设备的操作系统。 Fuchsia的特点： 开源：Fuchsia是一个开源项目，遵循BSD、MIT、Apache等许可证。这意味着开发者和公司可以免费访问和修改它的源代码。 Zircon内核：Fuchsia基于Zircon内核，这是一个微内核设计，使得操作系统更加轻量化和高度模块化。 跨平台：Fuchsia旨在成为一个统一的操作系统，适用于各种设备，包括智能手机、平板电脑、个人电脑以及物联网（IoT）设备。 模块化和可扩展性：Fuchsia的设计允许开发者轻松地添加和移除组件，使得操作系统能够根据需求进行定制化。 Flutter框架：Fuchsia使用谷歌的Flutter框架构建用户界面，Flutter支持跨平台应用开发，可以使Fuchsia应用在其他操作系统上运行。 总结，FreeBSD是一个基于Unix的稳定、高性能的开源操作系统，主要用于服务器和高性能计算。而Fuchsia是谷歌开发的一个全新的、基于Zircon内核的操作系统，旨在提供统一的、跨设备的体验。 sysctl接口Linux内核通过/proc/sys下的sysctl接口为用户空间程序提供了一种方式来查询和修改内核参数。sysctl可以通过文件系统访问，同时也可以通过命令行工具sysctl进行操作。这些参数涉及到许多内核子系统和组件，包括内存管理、网络设置、安全设置等。 在sysctl配置中，有很多参数涉及到抽象资源限制。这些限制通常用于约束系统资源的分配，以防止资源耗尽或者保证系统的稳定运行。以下是一些常见的资源限制相关的sysctl参数： vm.max_map_count：这个参数用于限制一个进程可以拥有的最大内存映射区域数量。这个限制有助于防止资源耗尽，尤其是在内存分配密集型的应用场景中。 kernel.pid_max：这个参数用于设置系统中分配的最大进程ID。通过限制进程ID的数量，可以防止恶意软件或编程错误导致的大量僵尸进程占用系统资源。 kernel.threads-max：这个参数用于限制系统中可以创建的最大线程数量。线程数量的限制可以防止过多的线程导致系统资源耗尽。 net.core.somaxconn：这个参数用于设置系统中最大的已完成连接队列长度。这个限制可以保障在高并发网络服务场景下，系统能够在资源有限的情况下处理连接请求。 fs.file-max：这个参数用于限制系统中可以打开的最大文件描述符数量。这个限制可以防止过多的文件描述符导致内核资源耗尽。 这些sysctl参数通常可以在系统启动时通过配置文件设置，也可以在运行时通过命令行工具sysctl进行动态调整。这为管理员和开发者提供了一种灵活的方式来优化系统性能和资源分配。 seccompseccomp（secure computing mode，安全计算模式）是一种Linux内核安全特性，允许在用户空间的进程将其可用的系统调用（syscalls）限制为一个最小的集合。这样做可以降低进程被攻击者利用的风险，因为攻击者可以使用的系统调用减少了。seccomp在容器、沙箱和其他高度安全的环境中非常有用，因为它可以限制潜在的攻击面。 seccomp的工作原理是允许进程定义一个系统调用白名单，只有在这个白名单上的系统调用才能被进程执行。当进程试图执行不在白名单上的系统调用时，内核会阻止进程，并根据seccomp的配置执行相应的操作。这些操作可能包括：终止进程、向进程发送信号或者返回一个错误码。 为了使用seccomp，进程需要使用prctl系统调用启用seccomp模式。接着，进程可以通过seccomp系统调用定义一个过滤器（通常是一个BPF（Berkeley Packet Filter）程序），用于检查系统调用的编号，并根据白名单执行相应的操作。 以下是一个简单的seccomp示例，演示了如何使用seccomp限制一个进程只能调用read、write、exit和rt_sigreturn系统调用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;linux/seccomp.h&gt;#include &lt;linux/filter.h&gt;#include &lt;linux/audit.h&gt;#include &lt;sys/syscall.h&gt;#define ALLOW_SYSCALL(syscall_nr) \\ BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, syscall_nr, 0, 1), \\ BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)int main() &#123; // 定义seccomp过滤器 struct sock_filter filter[] = &#123; // 检查架构是否正确 BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, arch)), BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, AUDIT_ARCH_X86_64, 1, 0), BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), // 加载系统调用编号 BPF_STMT(BPF_LD + BPF_W + BPF_ABS, offsetof(struct seccomp_data, nr)), // 允许白名单上的系统调用 ALLOW_SYSCALL(__NR_read), ALLOW_SYSCALL(__NR_write), ALLOW_SYSCALL(__NR_exit), ALLOW_SYSCALL(__NR_rt_sigreturn), // 不允许的系统调用将导致进程被终止 BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL), &#125;; // 定义seccomp过滤器的元数据 struct sock_fprog prog = &#123; .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])), .filter = filter, &#125;; // 启用seccomp模式 if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) &lt; 0) &#123; perror(&quot;prctl&quot;); return 1; &#125; // 在此处执行您的程序逻辑 // 如果尝试执行不在白名单上的系统调用，进程将被终止 return 0;&#125; 请注意，这个示例使用的是seccomp的BPF过滤器，该过滤器提供了一种灵活的方式来控制系统调用。这种方法在容器和沙箱环境中非常有用，因为它可以针对特定应用程序的需求定制系统调用的限制。然而，编写BPF过滤器可能相对复杂，因此在实践中，许多开发者选择使用像libseccomp这样的库来简 化seccomp过滤器的创建和管理。 以下是使用libseccomp库的示例，实现与前面相同的功能： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;seccomp.h&gt;int main() &#123; // 初始化一个新的seccomp上下文 scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (!ctx) &#123; perror(&quot;seccomp_init&quot;); return 1; &#125; // 向过滤器中添加允许的系统调用 if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0) &lt; 0 || seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0) &lt; 0) &#123; perror(&quot;seccomp_rule_add&quot;); seccomp_release(ctx); return 1; &#125; // 将过滤器加载到内核中 if (seccomp_load(ctx) &lt; 0) &#123; perror(&quot;seccomp_load&quot;); seccomp_release(ctx); return 1; &#125; // 释放资源 seccomp_release(ctx); // 在此处执行您的程序逻辑 // 如果尝试执行不在白名单上的系统调用，进程将被终止 return 0;&#125; 这个示例使用了libseccomp库提供的API，使得创建和管理seccomp过滤器更加简单。只需通过seccomp_init初始化一个新的上下文，使用seccomp_rule_add添加允许的系统调用，然后使用seccomp_load将过滤器加载到内核中。最后，使用seccomp_release释放资源。 总之，seccomp是一种在Linux内核中实现安全计算模式的机制，它允许进程限制其可用的系统调用集，从而降低潜在的攻击面。在容器、沙盒和其他高度安全的环境中，seccomp非常有用。使用BPF过滤器或第三方库（如libseccomp）可以帮助开发者更轻松地创建和管理seccomp过滤器。 inodeinode是什么在文件系统中，inode（索引节点）是一种数据结构，用于存储有关文件和目录的元数据（如权限、大小、创建时间等），但不包括文件名和实际文件数据。每个文件或目录在文件系统中都有一个唯一的inode，它们通过inode号进行识别。不同的文件系统类型（如ext4、XFS、Btrfs等）可能会有不同的inode实现，但其基本概念是相同的。 以下是inode可能包含的一些元数据信息： 文件类型（普通文件、目录、符号链接等） 文件大小 文件的权限（读、写、执行） 文件的所有者和所属组 创建、修改和访问时间戳 文件数据所在的磁盘块的位置 现在让我们通过一个简单的Python脚本示例来展示如何获取文件的inode信息： 1234567891011121314151617import osfile_path = &quot;example.txt&quot;# 获取文件的 inode 信息file_stat = os.stat(file_path)# 打印详细的 inode 信息print(f&quot;File path: &#123;file_path&#125;&quot;)print(f&quot;Inode number: &#123;file_stat.st_ino&#125;&quot;)print(f&quot;File size: &#123;file_stat.st_size&#125; bytes&quot;)print(f&quot;File owner: &#123;file_stat.st_uid&#125;&quot;)print(f&quot;File group: &#123;file_stat.st_gid&#125;&quot;)print(f&quot;File permissions: &#123;oct(file_stat.st_mode)[-4:]&#125;&quot;)print(f&quot;File creation time: &#123;file_stat.st_ctime&#125;&quot;)print(f&quot;File modification time: &#123;file_stat.st_mtime&#125;&quot;)print(f&quot;File access time: &#123;file_stat.st_atime&#125;&quot;) 在这个例子中，我们首先通过os.stat()函数获取了指定文件路径的inode信息。然后，我们可以从返回的os.stat_result对象中获取各种inode元数据，如文件大小、所有者、权限等。 需要注意的是，此示例仅适用于类Unix系统（如Linux和macOS）。在Windows系统上，文件元数据的管理方式与inode有所不同。可以使用Python的os模块的其他函数，如os.path.getsize()和os.path.getctime()等，来获取Windows系统上的文件元数据。 inode攻击inode攻击是一种资源耗尽攻击，其目标是耗尽文件系统中可用的inode。在这种攻击中，攻击者会在受害者容器中不断创建新文件或目录，从而分配大量的inode结构。由于Linux内核没有针对inode的cgroup隔离，这种攻击会影响整个分区，导致分区上的所有inode都被耗尽。 当inode耗尽时，任何试图创建新文件或目录的操作都会失败，无论这些操作来自受害者容器还是主机。在这种情况下，受害者容器可能会被驱逐，而主机也不能创建任何新文件。阿里云容器服务容易受到inode攻击的影响。 为了防御inode攻击，可以考虑以下方法： 限制容器的存储使用：为容器设置存储配额，以限制每个容器可以使用的存储空间。这可以防止攻击者耗尽整个文件系统的inode。 监控inode使用情况：定期检查文件系统的inode使用情况，以便在inode快速耗尽时发现潜在的攻击。 设置警报和自动响应：在inode使用达到临界值时设置警报，并实施自动响应措施，例如限制或隔离可疑容器。 运行时隔离：使用更高级别的运行时隔离技术，如gVisor或Kata Containers，以提供更强大的安全隔离。 需要注意的是，防御inode攻击的方法可能会对性能产生影响，因此在实施这些措施时需要权衡安全性和性能。 netns_ct-&gt;count攻击一种针对 Linux 内核中的连接跟踪功能（Netfilter）的攻击，该攻击涉及到利用 netns_ct-&gt;count 计数来消耗主机和容器的网络资源。这种攻击通常被称为连接消耗攻击（Connection Exhaustion Attack）或资源耗尽攻击（Resource Exhaustion Attack）。 攻击原理概述如下： 攻击者在容器内产生大量的 TCP 连接，这些连接会被跟踪。 尽管这些容器位于不同的网络命名空间（net namespace）中，但它们的所有连接都需要使用主机的 init_net.ct 计数。 当攻击者在短时间内产生大量连接时，会消耗掉主机的 init_net.ct 计数配额。 一旦配额耗尽，Netfilter 功能将受到影响，可能导致随机丢包等问题。 要防范这种攻击，可以采取以下措施： 限制容器的连接数：为每个容器设置连接数限制，以防止单个容器耗尽主机的连接资源。 限制连接速率：使用 Netfilter 的 iptables 工具限制容器的连接速率。例如，可以设置每秒最多允许的新连接数，从而防止攻击者在短时间内产生大量连接。 隔离网络命名空间：在某些情况下，可以为每个容器提供独立的网络命名空间，以降低资源争用的可能性。然而，这种方法可能会增加资源消耗和管理复杂性。 监控和报警：实施实时网络连接监控，以便在攻击发生时迅速检测并采取相应措施。 通过实施这些防范措施，可以降低容器和主机受到 netns_ct-&gt;count 攻击的风险。 gVisorgVisor 是一个开源的沙箱运行时，由谷歌开发，用于为容器提供隔离和安全性。gVisor 主要目标是为容器提供更高级别的安全性，同时保持接近原生容器的性能。它在容器与宿主机之间增加了一个用户空间内核，从而限制容器对宿主机内核的访问。这种方法降低了潜在安全漏洞对整个系统的影响。 gVisor 的核心组件是名为 “Sentry” 的用户空间内核，它拦截和处理来自容器的系统调用。Sentry 为每个容器提供了一个独立的内核实例，从而限制容器之间的相互影响。此外，gVisor 还包括一个名为 “Gofer” 的文件系统代理，用于将容器的文件系统操作转发到宿主机。 gVisor 与 Docker 和 Kubernetes 等容器运行时环境兼容，可以轻松集成到现有的容器部署中。为了在 Docker 中使用 gVisor，您需要安装 gVisor 并将其配置为 Docker 的运行时。以下是在 Docker 中使用 gVisor 的示例： 首先，安装 gVisor： 12345wget https://storage.googleapis.com/gvisor/releases/nightly/latest/runscwget https://storage.googleapis.com/gvisor/releases/nightly/latest/runsc.sha512sha512sum -c runsc.sha512chmod a+x runscsudo mv runsc /usr/local/bin 配置 Docker 使用 gVisor： 12345678910sudo mkdir -p /etc/dockerecho &#x27;&#123; &quot;runtimes&quot;: &#123; &quot;runsc&quot;: &#123; &quot;path&quot;: &quot;/usr/local/bin/runsc&quot;, &quot;runtimeArgs&quot;: [&quot;--platform=ptrace&quot;] &#125; &#125;&#125;&#x27; | sudo tee /etc/docker/daemon.jsonsudo systemctl restart docker 运行一个使用 gVisor 的 Docker 容器： 1docker run --runtime=runsc -it alpine sh 这将启动一个使用 gVisor 作为沙箱运行时的新容器。通过使用 gVisor，您可以提高容器的安全性，降低潜在安全漏洞对整个系统的影响。然而，需要注意的是，gVisor 可能会带来一定的性能损失，因此在实际应用中需要权衡安全性和性能。 Per-user quota restrictionsPer-user quota restrictions 是一种在文件系统层面设置的资源限制方法，用于控制每个用户所能使用的磁盘空间和文件数量。这种限制方法通常用于多用户共享同一系统资源的环境，如共享主机或服务器，以防止单个用户占用过多的磁盘空间或文件数量，从而导致其他用户无法正常使用系统资源。 Per-user quota restrictions 主要包括以下两种类型： 磁盘空间限制（Block Quotas）：该限制用于限制每个用户所能使用的磁盘空间。系统管理员可以为每个用户分配一定量的磁盘空间，当用户达到分配的磁盘空间上限时，将无法继续写入或创建新文件。 文件数量限制（Inode Quotas）：该限制用于限制每个用户所能创建的文件数量。系统管理员可以为每个用户分配一定数量的文件（或目录）创建权限，当用户达到分配的文件数量上限时，将无法继续创建新文件或目录。 在 Linux 系统中，可以通过以下步骤设置 per-user quota restrictions： 安装 quota 工具： 1sudo apt-get install quota quotatool 在 /etc/fstab 文件中启用用户配额。例如，为 /home 分区启用用户配额，可以将以下内容添加到 /etc/fstab 文件： 1/dev/sda1 /home ext4 defaults,usrquota,grpquota 0 0 重新挂载分区以应用更改： 1sudo mount -o remount /home 初始化配额文件： 1sudo quotacheck -cug /home 为特定用户设置配额限制。例如，为用户 exampleuser 设置 100MB 的磁盘空间限制和 1000 个文件数量限制： 1sudo setquota -u exampleuser 100000 110000 1000 1100 /home 使用 quota 命令查看用户配额情况： 1quota -u exampleuser 通过实施 per-user quota restrictions，系统管理员可以确保系统资源在用户之间公平地分配，防止单个用户过度使用资源。","categories":[{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"}]},{"title":"《理想国》柏拉图 阅读","slug":"《理想国》柏拉图 阅读","date":"2023-03-29T03:09:42.000Z","updated":"2023-04-09T13:41:12.250Z","comments":true,"path":"2023/03/29/《理想国》柏拉图 阅读/","link":"","permalink":"http://example.com/2023/03/29/%E3%80%8A%E7%90%86%E6%83%B3%E5%9B%BD%E3%80%8B%E6%9F%8F%E6%8B%89%E5%9B%BE%20%E9%98%85%E8%AF%BB/","excerpt":"前言 《理想国》作为一本必读的哲学经典，是柏拉图在思想成熟时期所著，包含了古希腊当时个个方面的问题，包括哲学、教育、军事、政治、伦理、文艺、诗歌等等。柏拉图一步步构建出理念世界，并借苏格拉底之口讨论了哲学中的一些重要问题，苏格拉底运用“辩证法”一步步让对方发现自身观点的矛盾之处，可以说是压迫感极强，甚至说是阴阳怪气。再读《理想国》，意在让自己浅薄的思想能得到升华。本人希望通过阅读总结书中的思想，可能由于时代的局限性，某些思想在现在看来可能已经过时并且不够完善，但是我们也依然可以从中汲取智慧为自己的思想所用。 财产 正义 节制","text":"前言 《理想国》作为一本必读的哲学经典，是柏拉图在思想成熟时期所著，包含了古希腊当时个个方面的问题，包括哲学、教育、军事、政治、伦理、文艺、诗歌等等。柏拉图一步步构建出理念世界，并借苏格拉底之口讨论了哲学中的一些重要问题，苏格拉底运用“辩证法”一步步让对方发现自身观点的矛盾之处，可以说是压迫感极强，甚至说是阴阳怪气。再读《理想国》，意在让自己浅薄的思想能得到升华。本人希望通过阅读总结书中的思想，可能由于时代的局限性，某些思想在现在看来可能已经过时并且不够完善，但是我们也依然可以从中汲取智慧为自己的思想所用。 财产 正义 节制开篇以苏格拉底和赛弗拉的对话开始，苏格拉底从年长者的问题入手，逐步引出财产，正义的讨论，并一步步进行了论证，反驳了当时流行的观点。 当一个人对肉体上的享受越来越少时，那他对精神上的畅谈也就要求越多。 我向来认为年长的人就像已经翻越千山万水的老旅客，你们曾经遇到的坎坷也可能是我之后要经历的，所以我对于过来人十分愿意与他们探讨一下旅途中的艰难险阻。 人在老年阶段是否会更艰难？大部分人在年老时对年老的抱怨，在于不能像以前一样吃喝玩乐、或是体验爱情的快乐、或是美好的事物已成过往，有人埋怨至亲好友的忽视，有人埋怨年老是痛苦的根源。赛弗拉讲脱离所谓的情爱比喻成从一个暴君处脱离苦海，到了老年时代，对于情爱一事早已没了兴趣，人已经清心寡欲，有了另一种自由快乐的感受。 赛弗拉从此入手，论证年老时之所以会抱怨连连，不是因为年纪，而是性情。如果一个人性情是恬静的、心平气和的，那么年龄大并不是痛苦，如果不是，那么不管什么年龄都会是痛苦的。 苏格拉底故意激赛弗拉继续回答，苏格拉底评价赛弗拉是因为家财万贯而不是因为性情恬静，所以老年时才会快乐，之后引出财富的问题。 你从财富上得到了什么？ 自己赚钱的人不仅因为钱有用才喜欢它，而更是因为这是他们辛苦得来的，内心生出了一种强烈的占有欲，就像诗人爱自己的诗篇，父母疼爱自己的儿女一样。我看到这种人，就觉得他们很讨厌，他们说的内容不外乎是赞美金钱之类的。 人从财富中获得的最大的好处就是，在赚取财富时的问心无愧，没有恐慌和忧虑。在人快死亡的时候，会有一种恐慌和忧虑，担心来世受到惩罚。如果一个人知道自己造孽颇深，就会过度悲观，惊恐万分，而问心无愧的人，便会心中坦然。 正义是什么？有话实说、欠债还债是否正义？不是正义，这个观点是日常生活中某个情形下的正义行为，并不是正义的定义。如果如此定义正义，便会造成有时是正义的，有时不是正义的情形。 柏拉图借苏格拉底之口举例： 你有个朋友在头脑清楚的时候，曾经把武器交给你，假如他后来疯了，再要回去，任何人都会说不能还给他，如果你还给他，这是不正义的行为。 把整个真实情况告诉疯子不是正义。 如果债主是敌人，还债是对他的帮助，则还债不是正义。 即当有话实说或者欠债还债的对象不同时，根据不同情况，这种行为也有可能是不正义的。苏格拉底希望找到一种普遍的正义，我们想要看一种行为是否是正义的，不能光从自身的立场出发，还要从我们的对象能否收益来检验我们的行为是否是有利于对方的，还要判断收益的对象。 把善给予友人，把恶给予敌人是否正义？把善给予友人：医生把医术给予病人，舵手在航海遇到风急浪险时维护船舶的安全。 把恶给予敌人：在战争中与盟友攻敌。 苏格拉底论证，在不生病的时候，医生是没有用处的，在人们不航海的时候，舵手是没有用处的，在不打仗的时候，正义者是没有用处的。而正义在不论任何时候都是有用处的。农名在种田时有用处，鞋匠在造鞋时有用处，但是鞋匠和农民不是正义者。 那么在平时什么事情上必须有正义？多人合作关系，例如订合同、立契约等等。下棋能手和正义者在下棋时，下棋能手更有用处，瓦匠和正义者在砌砖盖瓦建屋时，瓦匠更有用处，琴师和正义者在奏乐时，琴师更有用处，因此有用者并不等于正义者。这说明这样的正义定义太过狭窄。 事实上恰恰相反，一个正义的人和政府都是在平时就能做得很好才能保持自己和国家的久安。在涉及到金钱时，花钱与保管钱，同样都有比正义者更有用处的角色存在。 以此类推，如果一件事物有用，那么正义就没用，正义有用，那么这件事物就没用。是在平时就能做得很好才能保持自己和国家的久安。如果说正义平时也有用比如在替朋友保管钱财方面做到以善待友，那么就会得出钱财不用时正义有用，一旦钱财被使用了正义反而无用了。最后正义还要求“以恶对敌”这是不是意谓着还要替朋友去掠取敌人的东西呢？这样正义之举不就成了小偷行为了吗？这样的驳难看似荒唐，其实正好揭露出了这个定义本身所包含的内在矛盾。 而根据命题的定义，我们有时也会混淆朋友和敌人，所谓的朋友是那些看上去好的人还是实际上真正好的人呢？你所谓的敌人是看上去坏的人还是那些看上去不坏但是真的坏人呢。如果弄错了，便会导致帮助坏人，对抗好人。这个也引出善恶的问题，柏拉图在之后也借苏格拉底之口对此进行了论证。 根据讨论进一步完善定义，真正善良的朋友，报之以善，真正邪恶的敌人，报之以恶，才是正义。这个定义似乎更接近真理一些了。但是考虑如下例子：正义的人是否可以伤害他人呢？伤害他人是一件恶事，正义之人一定是善人，基于此，并考虑如下例子：善于骑马的人能够凭借其起码的技能让人不会骑马吗？音乐家能够凭借其音乐上的技能使人不懂音乐吗？正义者能以他的正义使人做不正义的事情吗？我们可以认为正义者作为一个善人不应该做伤害他人的恶事。 所以根据上述的讨论，正义并非是把善给予友人，把恶给予敌人。 正义就是强者的利益正义就是强者的利益，区别于上述判断收益的对象以及对于友人的利益，这个命题认为正义是强者的利益，所以首先要明确的是何为”强者“。如果只是因为吃的比别人好而比别人强壮，这并不是强者，我们通常提到强者，首先想到的就是统治者，制定法律的人，违反法律的人就是不正义之人，而对于政府有利的百姓就是正义。因此，有人认为，所谓正义就是当时政府的利益，正义就是强者的利益。 苏格拉底对此进行了反驳。 政府不是绝对不会出错的，如果治理得当，那么他们所立的法就是基于政府的利益的，而治理出现问题，就会与政府的利益违背，此时还是正义的吗？如果是正义的便会得到，即使与政府的利益违背，人民依旧需要服从，这仍然是正义。但是如果弱者服从了，实际上是损害了强者的利益，因此与命题相违背。 如果强者的利益指的是强者实际上的利益而不是强者心中认为的利益，并且是基于严格意义上的强者，即不会犯错误的强者。 苏格拉底做出了一个比喻，如果说技艺是完美的，如果技艺是不完美的，例如人的身体不完备的时候，需要医术来弥补，医术不完备的时候，需要其他的技艺来弥补。假设技艺在严格意义上是完美的不需要其他任何方式弥补的话，那么医生就不会考虑自身医术的利益，而会考虑病人的利益，骑马者不会考虑骑术的利益，而会考虑马的利益。以此类推，技艺本身是没有错误的，因此他担心的便是对象的利益，因为任何技艺都是为其对象服务的。那么不会犯错的强者可以比喻成完美的技艺，百姓可以比喻成技艺所服务的对象。那么一个统治者更多顾及的便是受统治者的利益而不是自身的利益，就像完美的技艺是为它的对象服务的。即名实相符的统治者会始终以人民的利益为前提，而不是以自己的利益为前提。 不正义比正义更有益有人认为正义和正义者会白白给出利益，换言之，正义意味着强者和统治者得到利益，而弱者和被统治者失去利益。不正义与之相反。例如专制君主的暴政。 根据苏格拉底在上文的证明，一个名实相符的统治者，无论什么事都是以被统治者的利益为目的。 每种技艺除了普通的利益之外，应该要给人以特殊的利益，比如医术给人以健康的利益，航海之术给人以安渡大海的利益。除此之外，技艺应当还有特殊的功用，而这种功用不能与其他技艺的功用相混合。每种技艺的利益都不能与其他的技艺混为一谈，除了它自身的特殊功用外，具有同一功用的技艺之间必定有同一利益在其中，那么技艺者所得到得报酬，应该是技艺所附带的利益，而不是技艺本身的利益。报酬与各种技艺有连带关系，而掌握技艺饿人只要各尽所能，便可以施利于人，报酬自然在其中。凡是真正的技艺家，当他工作的时候或指挥他人的时候，是以他人的利益为中心的，而不应该掺杂自己的私欲。工作没有相当的报酬是没有人愿意尽力而为的。所以，统治者或治理者的工作也必须有报酬，他们才会尽心为人民服务。他们的报酬有三种：金钱、荣誉与不愿承担责任的惩罚。 金钱和荣誉可以理解，而惩罚是什么意思呢？惩罚如何能作为报酬？ 对于高尚的人，名与利都不能使之动心。他们不愿意为拿报酬去做事，被人当佣人看待，更不愿意以阴谋的手段，假公济私，被人当强盗看待。因此，只能用损毁他们高洁的名节来惩罚他们，迫使他们不得不出来做事。也正因为这个缘故，那些急于做官的人受到轻视，而那些被逼出来做官的人则感受到莫大的尊荣。这种惩罚之所以最有效，是因为如果他们不出来，就用不如他们的人来管理他们的生活和行为。因此，这些人出来做官并不是因为他们有这个志向，也不是这里面有什么可贪图的，而是因为一时没有比他们更好的人或能力相同的人。所以，对他们来说，做官实在是刀架在脖子上，迫不得已的事。假如一个国家都是高尚的人，那么不想做官的肯定不会比今日想要做官的少。因此，真正的统治是要给他人以利益，而不是给自己以利益。如此，那么有谁会不愿意被统治，接受他人的利益呢？有谁会愿意做统治者，专门给他人以利益呢？所以，不得不以惩罚的手段迫使高尚者出来做官。 这进一步证明了正义不是强者的利益，初步证明了不正义不一定更有益，下面进一步证明。 如果能够治理国家和人民的纯粹的不正义者，会比正义者有能力得多，那么不正义者就会是明智的且有美德的，而正义便是其对立面。基于此，一个正义者不能够胜过其他的正义者即没有竞争，因为正义者是不明智的且无能的，并且所作所为不能有超过正义事业之外的事情，并且正义者获得的利益不能多于不正义者。而不正义者愿意获得比正义者更多的利益，并且愿意做正义之外的事情，所以不正义者在利益的竞争上要比正义者激烈，然后才能获取更多的利益。总结如下：正义者不愿意获得比同类更多的利益，而愿意获得比异类更多的利益；不正义者即愿意获得比同类更多的利益，也愿意获得比异类更多的利益。不正义者属于善而有智慧者的同类，正义者属于其异类。 我们再来看技艺家，人所拥有的技艺是不同的，例如一人为音乐家，一人为非音乐家，那么就音乐上的智慧来说，音乐家是聪明的。以此类推，医生也是这样的。音乐家在调整琴弦时不会有意想胜过别的音乐家，而会有意胜过非音乐家。医生在治病时不会做超出医生范围之外的事。再以知识与愚笨来说，有知识者的言行和其他有知识者的言行差不多，而愚笨的人会想要自己的言行超过有知识和无知识的人。有知识的人是聪明的而聪明的人是善良的（这段我无法推出，可能是由于当时的局限性对于善良，聪明等的定义并不明确，上文也出现了类似的情况），聪明又善良的人仅仅希望胜过异类，而不希望胜过同类，我们基于上文的假设得到这些结论。 而上文说不正义者常常想要胜过同类和异类，正义者只想胜过异类，而不想胜过同类，那么正义者则与聪明又有善德的相似，不正义者与无知而又没有善的的相似。那么现在正义者变成了聪明又有善德的人，不正义者变成了无知又没有善德的人，与上一段的结论矛盾。 正义与不正义的性质基于我们已经证明正义是美德和智慧，不正义是没有善德和愚蠢的。那么正义者比不正义者强是不言而喻的。现在我们假设，有一个国家或一支军队或一伙强盗或任何一些作恶的团伙，如果他们成员之间整天自相残杀，那么这个团伙一定是不能成功运作的，而如果不自相残杀，那么这些团伙的运作才能进行的更好。所以不正义会引发争端和仇恨，而正义能调和彼此之间的矛盾以达到和谐。（看到这里，我们应该也明白了，柏拉图对于正义和不正义的定义也是比较模糊的，一些证明看似有道理，但是细细思考一下，就会发现其中的纰漏）不正义既然有引发争论和仇恨的性质，那么凡是在不正义的地方，不论是努力还是自由人，他们会因此相互争斗，意见分歧，而不能有共同的行动。那么不正义在二人之间，则彼此会发生争论和激战，势必会称为仇敌，并且还会称为正义的敌人。而不正义在一个人身上，不正义会是其自相矛盾，言行前后不一，所以不正义不仅仅是正义的敌人，也是自我的敌人。所以不正义即使对个人也是有害的，一是会使人的言行不一致，二是会是人三心二意，使自己称为自己的敌人，并且也成为正义的敌人。 哪些共同作恶的人，之所以能够进行作恶行为，还不能算是真正的不正义者，假如他们是真正的不正义者，那么他们必定会自相残害，如果他们能够联合在一起为恶，那么还有一部分正义存在于其间，所以才能进行集体的行动。 凡物都有其专门独特的功能和事业，也一定会有它的一个特长，就像人的眼睛有它自身独特的功能。假如眼睛的特长不完备而有缺陷，那么眼睛就不能成就它的事业。那么有正义之心的人，自然就会生活得坦然自若，终身愉快，而不正义的人刚好相反。根据以上推论，只有正义者才能生活得安乐而幸福，不正义者则不能。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"哲学","slug":"读书笔记/哲学","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%93%B2%E5%AD%A6/"}],"tags":[{"name":"柏拉图","slug":"柏拉图","permalink":"http://example.com/tags/%E6%9F%8F%E6%8B%89%E5%9B%BE/"},{"name":"理想国","slug":"理想国","permalink":"http://example.com/tags/%E7%90%86%E6%83%B3%E5%9B%BD/"}]},{"title":"Hello ,my blog","slug":"Hello-my-blog","date":"2022-06-23T06:44:47.000Z","updated":"2023-03-31T04:52:42.333Z","comments":true,"path":"2022/06/23/Hello-my-blog/","link":"","permalink":"http://example.com/2022/06/23/Hello-my-blog/","excerpt":"","text":"Zwei Dinge erfüllen das Gemuet mit immer neuer und zunehmender Bewunderung und Ehrfurcht, je öfter und anhaltender sich das Nachdenken damit beschäftigt:: der bestirnte Himmel über mir und das moralische Gesetz in mir.","categories":[{"name":"Dairy","slug":"Dairy","permalink":"http://example.com/categories/Dairy/"}],"tags":[{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"}]}],"categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"编程语言/C","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"网络编程","slug":"编程语言/C/网络编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"语法","slug":"编程语言/C/语法","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E6%B3%95/"},{"name":"论文精读","slug":"论文精读","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/"},{"name":"内核安全","slug":"论文精读/内核安全","permalink":"http://example.com/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"},{"name":"项目实战","slug":"编程语言/C/项目实战","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"Linux系统编程","slug":"编程语言/C/Linux系统编程","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"数据库","slug":"编程语言/C/数据库","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"QT","slug":"编程语言/C/QT","permalink":"http://example.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/QT/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"课程学习","slug":"课程学习","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"MIT6.S081 Operating System Engineering","slug":"课程学习/MIT6-S081-Operating-System-Engineering","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/MIT6-S081-Operating-System-Engineering/"},{"name":"读书笔记","slug":"读书笔记","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"哲学","slug":"读书笔记/哲学","permalink":"http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%93%B2%E5%AD%A6/"},{"name":"学习路径","slug":"学习路径","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/"},{"name":"Ubuntu源码","slug":"Ubuntu源码","permalink":"http://example.com/categories/Ubuntu%E6%BA%90%E7%A0%81/"},{"name":"Dairy","slug":"Dairy","permalink":"http://example.com/categories/Dairy/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"线程","slug":"线程","permalink":"http://example.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"QT","slug":"QT","permalink":"http://example.com/tags/QT/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"cgroup","slug":"cgroup","permalink":"http://example.com/tags/cgroup/"},{"name":"内核安全","slug":"内核安全","permalink":"http://example.com/tags/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/"},{"name":"哲学","slug":"哲学","permalink":"http://example.com/tags/%E5%93%B2%E5%AD%A6/"},{"name":"庄子","slug":"庄子","permalink":"http://example.com/tags/%E5%BA%84%E5%AD%90/"},{"name":"道家","slug":"道家","permalink":"http://example.com/tags/%E9%81%93%E5%AE%B6/"},{"name":"指针","slug":"指针","permalink":"http://example.com/tags/%E6%8C%87%E9%92%88/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://example.com/tags/Ubuntu/"},{"name":"云安全","slug":"云安全","permalink":"http://example.com/tags/%E4%BA%91%E5%AE%89%E5%85%A8/"},{"name":"柏拉图","slug":"柏拉图","permalink":"http://example.com/tags/%E6%9F%8F%E6%8B%89%E5%9B%BE/"},{"name":"理想国","slug":"理想国","permalink":"http://example.com/tags/%E7%90%86%E6%83%B3%E5%9B%BD/"},{"name":"new","slug":"new","permalink":"http://example.com/tags/new/"}]}