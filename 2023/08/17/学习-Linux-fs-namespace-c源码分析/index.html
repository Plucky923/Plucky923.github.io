<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; SPDX-License-Identifier: GPL-2.0-only&#x2F;* *  linux&#x2F;fs&#x2F;namespace.c * * (C) Copyright Al Viro 2000, 2001 * * Based on code from fs&#x2F;super">
<meta property="og:type" content="article">
<meta property="og:title" content="学习 Linux fs&#x2F;namespace.c源码分析">
<meta property="og:url" content="http://example.com/2023/08/17/%E5%AD%A6%E4%B9%A0-Linux-fs-namespace-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Plucky">
<meta property="og:description" content="12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F; SPDX-License-Identifier: GPL-2.0-only&#x2F;* *  linux&#x2F;fs&#x2F;namespace.c * * (C) Copyright Al Viro 2000, 2001 * * Based on code from fs&#x2F;super">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-08-17T04:46:51.000Z">
<meta property="article:modified_time" content="2023-08-20T10:36:33.193Z">
<meta property="article:author" content="Plucky">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/08/17/%E5%AD%A6%E4%B9%A0-Linux-fs-namespace-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>学习 Linux fs/namespace.c源码分析 | Plucky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Plucky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Comfortably Numb</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/17/%E5%AD%A6%E4%B9%A0-Linux-fs-namespace-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习 Linux fs/namespace.c源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-17 12:46:51" itemprop="dateCreated datePublished" datetime="2023-08-17T12:46:51+08:00">2023-08-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 18:36:33" itemprop="dateModified" datetime="2023-08-20T18:36:33+08:00">2023-08-20</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>117k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3:33</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  linux/fs/namespace.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (C) Copyright Al Viro 2000, 2001</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Based on code from fs/super.c, copyright Linus Torvalds and others.</span></span><br><span class="line"><span class="comment"> * Heavily rewritten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/export.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capability.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mnt_namespace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/user_namespace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/namei.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/security.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cred.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/idr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span>        <span class="comment">/* init_rootfs */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs_struct.h&gt;</span>    <span class="comment">/* get_fs_root et.al. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fsnotify.h&gt;</span>    <span class="comment">/* fsnotify_vfsmount_delete */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_ns.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/magic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/memblock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/task_work.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;uapi/linux/mount.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs_context.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/shmem_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mnt_idmapping.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pnode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;internal.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of mounts in a mount namespace */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> sysctl_mount_max __read_mostly = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> m_hash_mask __read_mostly;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> m_hash_shift __read_mostly;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> mp_hash_mask __read_mostly;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> mp_hash_shift __read_mostly;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __initdata <span class="type">unsigned</span> <span class="type">long</span> mhash_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置mhash_entries的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">set_mhash_entries</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    mhash_entries = simple_strtoul(str, &amp;str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内核启动时设置mhash_entries的值</span></span><br><span class="line">__setup(<span class="string">&quot;mhash_entries=&quot;</span>, set_mhash_entries);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __initdata <span class="type">unsigned</span> <span class="type">long</span> mphash_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置mphash_entries的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">set_mphash_entries</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    mphash_entries = simple_strtoul(str, &amp;str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内核启动时设置mphash_entries的值</span></span><br><span class="line">__setup(<span class="string">&quot;mphash_entries=&quot;</span>, set_mphash_entries);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u64 event;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_IDA</span><span class="params">(mnt_id_ida)</span>; <span class="comment">// 挂载点ID分配器</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_IDA</span><span class="params">(mnt_group_ida)</span>; <span class="comment">// 挂载组ID分配器</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">mount_hashtable</span> __<span class="title">read_mostly</span>;</span> <span class="comment">// 挂载点哈希表</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">mountpoint_hashtable</span> __<span class="title">read_mostly</span>;</span> <span class="comment">// 挂载目录哈希表</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">mnt_cache</span> __<span class="title">read_mostly</span>;</span> <span class="comment">// 挂载结构体的SLAB缓存</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_RWSEM</span><span class="params">(namespace_sem)</span>; <span class="comment">// 命名空间信号量</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">HLIST_HEAD</span><span class="params">(unmounted)</span>;    <span class="comment">/* 未挂载的挂载点链表，由namespace_sem保护 */</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(ex_mountpoints)</span>; <span class="comment">/* 已存在的挂载目录链表，由namespace_sem保护 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount_kattr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attr_set; <span class="comment">// 挂载属性设置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attr_clr; <span class="comment">// 挂载属性清除</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> propagation; <span class="comment">// 挂载传播标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags; <span class="comment">// 挂载点查找标志</span></span><br><span class="line">    <span class="type">bool</span> recurse; <span class="comment">// 是否递归</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">mnt_userns</span>;</span> <span class="comment">// 挂载的用户命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">mnt_idmap</span>;</span> <span class="comment">// 挂载的ID映射</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* /sys/fs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> *<span class="title">fs_kobj</span>;</span> <span class="comment">// 文件系统的内核对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount锁可能被以读模式获取，以防止对vfsmount哈希表的更改，</span></span><br><span class="line"><span class="comment"> * 例如在挂载点查找或向上遍历树时。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在所有修改vfsmount树或哈希表的情况下，或者在修改vfsmount结构体时，</span></span><br><span class="line"><span class="comment"> * 应以写模式获取该锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__cacheline_aligned_in_smp <span class="title function_">DEFINE_SEQLOCK</span><span class="params">(mount_lock)</span>; <span class="comment">// vfsmount锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取mount_lock写锁的辅助函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_mount_hash</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    write_seqlock(&amp;mount_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放mount_lock写锁的辅助函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">unlock_mount_hash</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    write_sequnlock(&amp;mount_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hlist_head *<span class="title function_">m_hash</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = ((<span class="type">unsigned</span> <span class="type">long</span>)mnt / L1_CACHE_BYTES);</span><br><span class="line">    tmp += ((<span class="type">unsigned</span> <span class="type">long</span>)dentry / L1_CACHE_BYTES);</span><br><span class="line">    tmp = tmp + (tmp &gt;&gt; m_hash_shift);</span><br><span class="line">    <span class="comment">// 返回哈希表中的头节点</span></span><br><span class="line">    <span class="keyword">return</span> &amp;mount_hashtable[tmp &amp; m_hash_mask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hlist_head *<span class="title function_">mp_hash</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp = ((<span class="type">unsigned</span> <span class="type">long</span>)dentry / L1_CACHE_BYTES);</span><br><span class="line">    tmp = tmp + (tmp &gt;&gt; mp_hash_shift);</span><br><span class="line">    <span class="comment">// 返回哈希表中的头节点</span></span><br><span class="line">    <span class="keyword">return</span> &amp;mountpoint_hashtable[tmp &amp; mp_hash_mask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mnt_alloc_id</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 分配一个新的挂载点ID</span></span><br><span class="line">    <span class="type">int</span> res = ida_alloc(&amp;mnt_id_ida, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 将分配的ID赋值给挂载点结构体</span></span><br><span class="line">    mnt-&gt;mnt_id = res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mnt_free_id</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放挂载点ID</span></span><br><span class="line">    ida_free(&amp;mnt_id_ida, mnt-&gt;mnt_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配一个新的对等组ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mnt_alloc_group_id</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 分配一个最小的对等组ID</span></span><br><span class="line">    <span class="type">int</span> res = ida_alloc_min(&amp;mnt_group_ida, <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 将分配的ID赋值给挂载点结构体</span></span><br><span class="line">    mnt-&gt;mnt_group_id = res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mount *<span class="title function_">alloc_vfsmnt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 分配一个新的挂载点结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> kmem_cache_zalloc(mnt_cache, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (mnt) &#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配一个新的挂载点ID</span></span><br><span class="line">        err = mnt_alloc_id(mnt);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out_free_cache;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (name) &#123;</span><br><span class="line">            <span class="comment">// 复制设备名称到mnt_devname</span></span><br><span class="line">            mnt-&gt;mnt_devname = kstrdup_const(name, GFP_KERNEL_ACCOUNT);</span><br><span class="line">            <span class="keyword">if</span> (!mnt-&gt;mnt_devname)</span><br><span class="line">                <span class="keyword">goto</span> out_free_id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        <span class="comment">// 为mnt_pcp分配percpu变量</span></span><br><span class="line">        mnt-&gt;mnt_pcp = alloc_percpu(<span class="keyword">struct</span> mnt_pcp);</span><br><span class="line">        <span class="keyword">if</span> (!mnt-&gt;mnt_pcp)</span><br><span class="line">            <span class="keyword">goto</span> out_free_devname;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在本地CPU变量中增加mnt_count</span></span><br><span class="line">        this_cpu_add(mnt-&gt;mnt_pcp-&gt;mnt_count, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// 设置mnt_count和mnt_writers</span></span><br><span class="line">        mnt-&gt;mnt_count = <span class="number">1</span>;</span><br><span class="line">        mnt-&gt;mnt_writers = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化mnt_hash、mnt_child、mnt_mounts、mnt_list、mnt_expire、mnt_share、mnt_slave_list、mnt_slave、mnt_mp_list、mnt_umounting、mnt_stuck_children</span></span><br><span class="line">        INIT_HLIST_NODE(&amp;mnt-&gt;mnt_hash);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_child);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_mounts);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_list);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_expire);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_share);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_slave_list);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_slave);</span><br><span class="line">        INIT_HLIST_NODE(&amp;mnt-&gt;mnt_mp_list);</span><br><span class="line">        INIT_LIST_HEAD(&amp;mnt-&gt;mnt_umounting);</span><br><span class="line">        INIT_HLIST_HEAD(&amp;mnt-&gt;mnt_stuck_children);</span><br><span class="line">        mnt-&gt;mnt.mnt_idmap = &amp;nop_mnt_idmap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mnt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">out_free_devname:</span><br><span class="line">    <span class="comment">// 释放mnt_devname的内存</span></span><br><span class="line">    kfree_const(mnt-&gt;mnt_devname);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">out_free_id:</span><br><span class="line">    <span class="comment">// 释放挂载点ID</span></span><br><span class="line">    mnt_free_id(mnt);</span><br><span class="line">out_free_cache:</span><br><span class="line">    <span class="comment">// 释放挂载点结构体的内存</span></span><br><span class="line">    kmem_cache_free(mnt_cache, mnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 大多数对文件系统的只读检查是针对需要离散时间的操作，比如write()或unlink()。</span></span><br><span class="line"><span class="comment"> * 我们必须跟踪这些操作的开始时间（用于权限检查）和结束时间，以便确定何时可以对文件系统进行写操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __mnt_is_readonly: 检查挂载点是否为只读</span></span><br><span class="line"><span class="comment"> * @mnt: 要检查其写入状态的挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数不应该直接在VFS之外使用。</span></span><br><span class="line"><span class="comment"> * 它不能保证文件系统将保持读/写状态，只能表示当前状态。不能将其用于替代IS_RDONLY(inode)。</span></span><br><span class="line"><span class="comment"> * mnt_want/drop_write()将保持文件系统的读/写状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> __mnt_is_readonly(<span class="keyword">struct</span> vfsmount *mnt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查挂载点的mnt_flags是否包含MNT_READONLY标志，或者通过sb_rdonly()函数检查mnt_sb是否为只读</span></span><br><span class="line">    <span class="keyword">return</span> (mnt-&gt;mnt_flags &amp; MNT_READONLY) || sb_rdonly(mnt-&gt;mnt_sb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__mnt_is_readonly);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">mnt_inc_writers</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">// 在本地CPU变量中增加mnt_writers</span></span><br><span class="line">    this_cpu_inc(mnt-&gt;mnt_pcp-&gt;mnt_writers);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 增加mnt_writers</span></span><br><span class="line">    mnt-&gt;mnt_writers++;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">mnt_dec_writers</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">// 在本地CPU变量中减少mnt_writers</span></span><br><span class="line">    this_cpu_dec(mnt-&gt;mnt_pcp-&gt;mnt_writers);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 减少mnt_writers</span></span><br><span class="line">    mnt-&gt;mnt_writers--;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">mnt_get_writers</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有可能的CPU，累加mnt_writers</span></span><br><span class="line">    for_each_possible_cpu(cpu) &#123;</span><br><span class="line">        count += per_cpu_ptr(mnt-&gt;mnt_pcp, cpu)-&gt;mnt_writers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 返回mnt_writers</span></span><br><span class="line">    <span class="keyword">return</span> mnt-&gt;mnt_writers;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mnt_is_readonly</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnt-&gt;mnt_sb-&gt;s_readonly_remount)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 在do_remount()中设置s_flags/s_readonly_remount的顺序 */</span></span><br><span class="line">    smp_rmb();</span><br><span class="line">    <span class="comment">// 调用__mnt_is_readonly()函数检查挂载点是否为只读</span></span><br><span class="line">    <span class="keyword">return</span> __mnt_is_readonly(mnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 大多数对文件系统的只读和冻结检查是针对需要离散时间的操作，比如write()或unlink()。</span></span><br><span class="line"><span class="comment"> * 我们必须跟踪这些操作的开始时间（用于权限检查）和结束时间，以便确定何时可以对文件系统进行写操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __mnt_want_write - 在没有冻结保护的情况下获取对挂载点的写访问权限</span></span><br><span class="line"><span class="comment"> * @m: 要进行写操作的挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这告诉底层文件系统将要对其执行写操作，并确保在返回成功之前允许写操作（挂载点为读写状态）。</span></span><br><span class="line"><span class="comment"> * 此操作不保护文件系统的冻结状态。在写操作完成后，必须调用__mnt_drop_write()函数。这实际上是一个引用计数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __mnt_want_write(<span class="keyword">struct</span> vfsmount *m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(m);</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    preempt_disable();</span><br><span class="line">    <span class="comment">// 在本地CPU变量中增加mnt_writers</span></span><br><span class="line">    mnt_inc_writers(mnt);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对mnt_inc_writers的存储必须在我们通过MNT_WRITE_HOLD循环之前可见，</span></span><br><span class="line"><span class="comment">     * 这样慢路径可以在设置MNT_WRITE_HOLD后看到我们增加的计数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();</span><br><span class="line">    might_lock(&amp;mount_lock.lock);</span><br><span class="line">    <span class="keyword">while</span> (READ_ONCE(mnt-&gt;mnt.mnt_flags) &amp; MNT_WRITE_HOLD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!IS_ENABLED(CONFIG_PREEMPT_RT)) &#123;</span><br><span class="line">            <span class="comment">// 在非实时内核中，放松CPU以减少自旋</span></span><br><span class="line">            cpu_relax();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这可以防止优先级倒置，如果设置MNT_WRITE_HOLD的任务在远程CPU上被抢占，</span></span><br><span class="line"><span class="comment">             * 并且它可以防止生活锁定，如果设置MNT_WRITE_HOLD的任务具有较低的优先级并且绑定到与此处自旋的任务相同的CPU。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            preempt_enable();</span><br><span class="line">            lock_mount_hash();</span><br><span class="line">            unlock_mount_hash();</span><br><span class="line">            preempt_disable();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在慢路径清除MNT_WRITE_HOLD之后，mnt_is_readonly将被设置为与其要求匹配的值。</span></span><br><span class="line"><span class="comment">     * 因此，在清除MNT_WRITE_HOLD之前，我们不能加载mnt_is_readonly。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_rmb();</span><br><span class="line">    <span class="keyword">if</span> (mnt_is_readonly(m)) &#123;</span><br><span class="line">        <span class="comment">// 减少mnt_writers</span></span><br><span class="line">        mnt_dec_writers(mnt);</span><br><span class="line">        ret = -EROFS;</span><br><span class="line">    &#125;</span><br><span class="line">    preempt_enable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mnt_want_write - 获取对挂载点的写访问权限</span></span><br><span class="line"><span class="comment"> * @m: 要进行写操作的挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这告诉底层文件系统即将对其进行写操作，并确保在返回成功之前允许写操作（挂载点为读写状态，... ret;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 开始写操作</span></span><br><span class="line"><span class="comment">    sb_start_write(m-&gt;mnt_sb);</span></span><br><span class="line"><span class="comment">    // 调用__mnt_want_write函数获取写访问权限</span></span><br><span class="line"><span class="comment">    ret = __mnt_want_write(m);</span></span><br><span class="line"><span class="comment">    if (ret)</span></span><br><span class="line"><span class="comment">        // 如果获取写访问权限失败，则结束写操作</span></span><br><span class="line"><span class="comment">        sb_end_write(m-&gt;mnt_sb);</span></span><br><span class="line"><span class="comment">    return ret;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">EXPORT_SYMBOL_GPL(mnt_want_write);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __mnt_want_write_file - 获取对文件的写访问权限</span></span><br><span class="line"><span class="comment"> * @file: 要进行写操作的文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这类似于__mnt_want_write，但如果文件已经以写模式打开，则跳过增加mnt_writers的步骤（因为打开的文件已经有一个引用），</span></span><br><span class="line"><span class="comment"> * 而只进行紧急只读重新挂载的检查。这必须与__mnt_drop_write_file配对使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __mnt_want_write_file(<span class="keyword">struct</span> file *file)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_WRITER) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 当仍然存在可写的文件描述符时，超级块可能已变为只读状态，</span></span><br><span class="line"><span class="comment">         * 例如由于具有errors=remount-ro的文件系统错误</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (__mnt_is_readonly(file-&gt;f_path.mnt))</span><br><span class="line">            <span class="keyword">return</span> -EROFS;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用__mnt_want_write函数获取写访问权限</span></span><br><span class="line">    <span class="keyword">return</span> __mnt_want_write(file-&gt;f_path.mnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mnt_want_write_file - 获取对文件的写访问权限</span></span><br><span class="line"><span class="comment"> * @file: 要进行写操作的文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这类似于mnt_want_write，但如果文件已经以写模式打开，则跳过增加mnt_writers的步骤（因为打开的文件已经有一个引用），</span></span><br><span class="line"><span class="comment"> * 而只进行冻结保护和紧急只读重新挂载的检查。这必须与mnt_drop_write_file配对使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mnt_want_write_file</span><span class="params">(<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始写操作</span></span><br><span class="line">    sb_start_write(file_inode(file)-&gt;i_sb);</span><br><span class="line">    <span class="comment">// 调用__mnt_want_write_file函数获取写访问权限</span></span><br><span class="line">    ret = __mnt_want_write_file(file);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="comment">// 如果获取写访问权限失败，则结束写操作</span></span><br><span class="line">        sb_end_write(file_inode(file)-&gt;i_sb);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(mnt_want_write_file);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __mnt_drop_write - 放弃对挂载点的写访问权限</span></span><br><span class="line"><span class="comment"> * @mnt: 要放弃写访问权限的挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 告诉底层文件系统我们已经完成对其的写操作。必须与上面的__mnt_want_write()调用匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __mnt_drop_write(<span class="keyword">struct</span> vfsmount *mnt)</span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    <span class="comment">// 减少mnt_writers</span></span><br><span class="line">    mnt_dec_writers(real_mount(mnt));</span><br><span class="line">    preempt_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mnt_drop_write - 放弃对挂载点的写访问权限</span></span><br><span class="line"><span class="comment"> * @mnt: 要放弃写访问权限的挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ... 告诉底层文件系统我们已经完成对其的写操作，并允许文件系统再次被冻结。</span></span><br><span class="line"><span class="comment"> * 必须与上面的mnt_want_write()调用匹配。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mnt_drop_write</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用__mnt_drop_write函数放弃写访问权限</span></span><br><span class="line">    __mnt_drop_write(mnt);</span><br><span class="line">    <span class="comment">// 结束写操作</span></span><br><span class="line">    sb_end_write(mnt-&gt;mnt_sb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(mnt_drop_write);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __mnt_drop_write_file(<span class="keyword">struct</span> file *file)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_WRITER))</span><br><span class="line">        <span class="comment">// 如果文件不是以写模式打开，则调用__mnt_drop_write函数放弃写访问权限</span></span><br><span class="line">        __mnt_drop_write(file-&gt;f_path.mnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mnt_drop_write_file</span><span class="params">(<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用__mnt_drop_write_file函数放弃写访问权限</span></span><br><span class="line">    __mnt_drop_write_file(file);</span><br><span class="line">    <span class="comment">// 结束写操作</span></span><br><span class="line">    sb_end_write(file_inode(file)-&gt;i_sb);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mnt_drop_write_file);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mnt_make_readonly</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = mnt_hold_writers(mnt);  <span class="comment">// 调用函数 mnt_hold_writers() 来获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        mnt-&gt;mnt.mnt_flags |= MNT_READONLY;  <span class="comment">// 将 MNT_READONLY 标志位设置为 1，表示挂载点只读</span></span><br><span class="line">    mnt_unhold_writers(mnt);  <span class="comment">// 释放写锁</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sb_prepare_remount_readonly</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Racy optimization.  Recheck the counter under MNT_WRITE_HOLD */</span></span><br><span class="line">    <span class="keyword">if</span> (atomic_long_read(&amp;sb-&gt;s_remove_count))  <span class="comment">// 检查 s_remove_count 计数器的值</span></span><br><span class="line">        <span class="keyword">return</span> -EBUSY;  <span class="comment">// 如果计数器的值不为 0，则返回忙碌错误码</span></span><br><span class="line"></span><br><span class="line">    lock_mount_hash();  <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">    list_for_each_entry(mnt, &amp;sb-&gt;s_mounts, mnt_instance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(mnt-&gt;mnt.mnt_flags &amp; MNT_READONLY)) &#123;  <span class="comment">// 检查挂载点是否为只读</span></span><br><span class="line">            err = mnt_hold_writers(mnt);  <span class="comment">// 调用函数 mnt_hold_writers() 来获取写锁</span></span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; atomic_long_read(&amp;sb-&gt;s_remove_count))  <span class="comment">// 再次检查 s_remove_count 计数器的值</span></span><br><span class="line">        err = -EBUSY;  <span class="comment">// 如果计数器的值不为 0，则返回忙碌错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        sb-&gt;s_readonly_remount = <span class="number">1</span>;  <span class="comment">// 将 s_readonly_remount 标志位设置为 1，表示准备进行只读重新挂载</span></span><br><span class="line">        smp_wmb();  <span class="comment">// 内存屏障，确保标志位的修改对其他 CPU 可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    list_for_each_entry(mnt, &amp;sb-&gt;s_mounts, mnt_instance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mnt-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD)  <span class="comment">// 检查挂载点是否持有写锁</span></span><br><span class="line">            mnt-&gt;mnt.mnt_flags &amp;= ~MNT_WRITE_HOLD;  <span class="comment">// 清除 MNT_WRITE_HOLD 标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mount_hash();  <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_vfsmnt</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    mnt_idmap_put(mnt_idmap(&amp;mnt-&gt;mnt));  <span class="comment">// 释放挂载点的 ID 映射</span></span><br><span class="line">    kfree_const(mnt-&gt;mnt_devname);  <span class="comment">// 释放挂载点的设备名称内存</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    free_percpu(mnt-&gt;mnt_pcp);  <span class="comment">// 释放挂载点的 percpu 变量</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    kmem_cache_free(mnt_cache, mnt);  <span class="comment">// 释放挂载点的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * lookup_mnt - 返回挂载在路径上的第一个子挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &quot;第一个&quot; 指的是按时间顺序第一个挂载的。如果你创建了以下挂载点：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mount /dev/sda1 /mnt</span></span><br><span class="line"><span class="comment"> * mount /dev/sda2 /mnt</span></span><br><span class="line"><span class="comment"> * mount /dev/sda3 ... /mnt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 那么在根挂载点上的基础路径 /mnt 上调用 lookup_mnt() 将依次返回 ... /dev/sda1 的根 dentry 和 vfsmount，</span></span><br><span class="line"><span class="comment"> * 然后是 /dev/sda2，然后是 /dev/sda3，然后是 NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ... lookup_mnt() 会引用找到的 vfsmount。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">lookup_mnt</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">child_mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();  <span class="comment">// 读取锁定 RCU</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        seq = m;  <span class="comment">// 读取序列号</span></span><br><span class="line">        child_mnt = m;  <span class="comment">// 获取子挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (child_mnt) &#123;</span><br><span class="line">            m = &amp;child_mnt-&gt;mnt;</span><br><span class="line">            <span class="keyword">if</span> (mnt_is_cursor(child_mnt))  <span class="comment">// 检查挂载点是否为游标挂载点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (m);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();  <span class="comment">// 解锁 RCU</span></span><br><span class="line">    <span class="keyword">return</span> m;  <span class="comment">// 返回找到的 vfsmount</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">lock_ns_list</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;ns-&gt;ns_lock);  <span class="comment">// 锁定命名空间的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">unlock_ns_list</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_unlock(&amp;ns-&gt;ns_lock);  <span class="comment">// 解锁命名空间的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mnt_is_cursor</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mnt-&gt;mnt.mnt_flags &amp; MNT_CURSOR;  <span class="comment">// 检查挂载点是否为游标挂载点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __is_local_mountpoint - 测试dentry是否是当前挂载命名空间中的挂载点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通常情况下，dentry根本不是挂载点，这种情况在内联中处理。</span></span><br><span class="line"><span class="comment"> * 当我们实际处理某种类型的挂载点时，会遍历当前挂载命名空间中的所有挂载，并测试dentry是否是挂载点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在此上下文中，无法使用mount_hashtable，因为我们需要识别可能在当前挂载命名空间中的所有挂载，</span></span><br><span class="line"><span class="comment"> * 而不仅仅是具有某个指定父挂载的挂载。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> __is_local_mountpoint(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span> =</span> current-&gt;nsproxy-&gt;mnt_ns;  <span class="comment">// 获取当前进程的挂载命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="type">bool</span> is_covered = <span class="literal">false</span>;  <span class="comment">// 标记dentry是否是挂载点</span></span><br><span class="line"></span><br><span class="line">    down_read(&amp;namespace_sem);  <span class="comment">// 获取命名空间信号量，防止并发访问</span></span><br><span class="line">    lock_ns_list(ns);  <span class="comment">// 锁定挂载列表，防止并发访问</span></span><br><span class="line">    list_for_each_entry(mnt, &amp;ns-&gt;<span class="built_in">list</span>, mnt_list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mnt_is_cursor(mnt))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        is_covered = (mnt-&gt;mnt_mountpoint == dentry);  <span class="comment">// 判断dentry是否是挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (is_covered)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_ns_list(ns);  <span class="comment">// 解锁挂载列表</span></span><br><span class="line">    up_read(&amp;namespace_sem);  <span class="comment">// 释放命名空间信号量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> is_covered;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * lookup_mountpoint - 查找指定dentry的挂载点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 遍历指定dentry的哈希链表，查找与之匹配的挂载点。</span></span><br><span class="line"><span class="comment"> * 如果找到匹配的挂载点，则增加其引用计数并返回该挂载点。</span></span><br><span class="line"><span class="comment"> * 如果未找到匹配的挂载点，则返回NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mountpoint *<span class="title function_">lookup_mountpoint</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">chain</span> =</span> mp_hash(dentry);  <span class="comment">// 获取指定dentry的哈希链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>;</span></span><br><span class="line"></span><br><span class="line">    hlist_for_each_entry(mp, chain, m_hash) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp-&gt;m_dentry == dentry) &#123;</span><br><span class="line">            mp-&gt;m_count++;  <span class="comment">// 增加挂载点的引用计数</span></span><br><span class="line">            <span class="keyword">return</span> mp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mountpoint *<span class="title function_">get_mountpoint</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>, *<span class="title">new</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_mountpoint(dentry)) &#123;</span><br><span class="line">        <span class="comment">/* 可能值得一个 WARN_ON() */</span></span><br><span class="line">        <span class="keyword">if</span> (d_unlinked(dentry))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">mountpoint:</span><br><span class="line">        read_seqlock_excl(&amp;mount_lock);  <span class="comment">// 获取挂载锁，防止并发访问</span></span><br><span class="line">        mp = lookup_mountpoint(dentry);  <span class="comment">// 查找指定dentry的挂载点</span></span><br><span class="line">        read_sequnlock_excl(&amp;mount_lock);  <span class="comment">// 释放挂载锁</span></span><br><span class="line">        <span class="keyword">if</span> (mp)</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        new = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mountpoint), GFP_KERNEL);  <span class="comment">// 分配新的挂载点结构体</span></span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);  <span class="comment">// 内存分配失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有一个进程可以设置 d_mounted */</span></span><br><span class="line">    ret = d_set_mounted(dentry);  <span class="comment">// 设置dentry的d_mounted标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 有其他进程设置了 d_mounted? */</span></span><br><span class="line">    <span class="keyword">if</span> (ret == -EBUSY)</span><br><span class="line">        <span class="keyword">goto</span> mountpoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dentry不可用作挂载点? */</span></span><br><span class="line">    mp = ERR_PTR(ret);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将新的挂载点添加到哈希表中 */</span></span><br><span class="line">    read_seqlock_excl(&amp;mount_lock);  <span class="comment">// 获取挂载锁，防止并发访问</span></span><br><span class="line">    new-&gt;m_dentry = dget(dentry);  <span class="comment">// 增加dentry的引用计数</span></span><br><span class="line">    new-&gt;m_count = <span class="number">1</span>;  <span class="comment">// 设置挂载点的引用计数</span></span><br><span class="line">    hlist_add_head(&amp;new-&gt;m_hash, mp_hash(dentry));  <span class="comment">// 将挂载点添加到哈希表中</span></span><br><span class="line">    INIT_HLIST_HEAD(&amp;new-&gt;m_list);  <span class="comment">// 初始化挂载点的链表头</span></span><br><span class="line">    read_sequnlock_excl(&amp;mount_lock);  <span class="comment">// 释放挂载锁</span></span><br><span class="line"></span><br><span class="line">    mp = new;</span><br><span class="line">    new = <span class="literal">NULL</span>;</span><br><span class="line">done:</span><br><span class="line">    kfree(new);  <span class="comment">// 释放新的挂载点结构体的内存</span></span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount锁必须被持有。此外，调用者负责对给定的处理列表进行序列化调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __put_mountpoint(<span class="keyword">struct</span> mountpoint *mp, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!--mp-&gt;m_count) &#123;  <span class="comment">// 如果挂载点的引用计数减为0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> mp-&gt;m_dentry;</span><br><span class="line">        BUG_ON(!hlist_empty(&amp;mp-&gt;m_list));  <span class="comment">// 断言挂载点的链表为空</span></span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock);  <span class="comment">// 获取dentry的自旋锁</span></span><br><span class="line">        dentry-&gt;d_flags &amp;= ~DCACHE_MOUNTED;  <span class="comment">// 清除dentry的DCACHE_MOUNTED标志位</span></span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 释放dentry的自旋锁</span></span><br><span class="line">        dput_to_list(dentry, <span class="built_in">list</span>);  <span class="comment">// 将dentry放入指定的列表中</span></span><br><span class="line">        hlist_del(&amp;mp-&gt;m_hash);  <span class="comment">// 从哈希表中删除挂载点</span></span><br><span class="line">        kfree(mp);  <span class="comment">// 释放挂载点的内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在namespace_lock和vfsmount锁的保护下调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_mountpoint</span><span class="params">(<span class="keyword">struct</span> mountpoint *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">    __put_mountpoint(mp, &amp;ex_mountpoints);  <span class="comment">// 调用__put_mountpoint函数，将挂载点放入ex_mountpoints列表中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">check_mnt</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mnt-&gt;mnt_ns == current-&gt;nsproxy-&gt;mnt_ns;  <span class="comment">// 检查给定的挂载是否属于当前进程的挂载命名空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount锁必须被持有（写模式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">touch_mnt_namespace</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ns) &#123;</span><br><span class="line">        ns-&gt;event = ++event;  <span class="comment">// 更新挂载命名空间的事件计数</span></span><br><span class="line">        wake_up_interruptible(&amp;ns-&gt;poll);  <span class="comment">// 唤醒等待挂载命名空间事件的进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount锁必须被持有（写模式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __touch_mnt_namespace(<span class="keyword">struct</span> mnt_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ns &amp;&amp; ns-&gt;event != event) &#123;</span><br><span class="line">        ns-&gt;event = event;  <span class="comment">// 更新挂载命名空间的事件计数</span></span><br><span class="line">        wake_up_interruptible(&amp;ns-&gt;poll);  <span class="comment">// 唤醒等待挂载命名空间事件的进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount lock must be held for write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mountpoint *<span class="title function_">unhash_mnt</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>;</span></span><br><span class="line">    mnt-&gt;mnt_parent = mnt;  <span class="comment">// 将mnt的父挂载设置为自身</span></span><br><span class="line">    mnt-&gt;mnt_mountpoint = ... *mp,  <span class="comment">// 将mnt的挂载点设置为... *mp</span></span><br><span class="line">            <span class="keyword">struct</span> mount *child_mnt)</span><br><span class="line">    &#123;</span><br><span class="line">        mp-&gt;m_count++;  <span class="comment">// 增加mp的引用计数</span></span><br><span class="line">        mnt_add_count(mnt, <span class="number">1</span>);  <span class="comment">// 增加mnt的引用计数</span></span><br><span class="line">        child_mnt-&gt;mnt_mountpoint = mp-&gt;m_dentry;  <span class="comment">// 将child_mnt的挂载点设置为mp的dentry</span></span><br><span class="line">        child_mnt-&gt;mnt_parent = ... mnt;  <span class="comment">// 将child_mnt的父挂载设置为mnt</span></span><br><span class="line">        child_mnt-&gt;mnt_mp = mp;  <span class="comment">// 将child_mnt的mnt_mp设置为mp</span></span><br><span class="line">        hlist_add_head(&amp;child_mnt-&gt;mnt_mp_list, &amp;mp-&gt;m_list);  <span class="comment">// 将child_mnt添加到mp的m_list链表头部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attach_mnt(<span class="keyword">struct</span> mount *mnt, <span class="keyword">struct</span> mount *parent)</span><br><span class="line">&#123;</span><br><span class="line">    hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash,</span><br><span class="line">                       ... m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint));  <span class="comment">// 将mnt添加到parent的mnt_hash链表头部</span></span><br><span class="line">    list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts);  <span class="comment">// 将mnt添加到parent的mnt_mounts链表尾部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount lock must be held for write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">attach_mnt</span><span class="params">(<span class="keyword">struct</span> mount *mnt,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> mount *parent,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> ... mountpoint *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">    mnt_set_mountpoint(parent, mp, mnt);  <span class="comment">// 设置parent的挂载点为mp，将mnt设置为mp的挂载</span></span><br><span class="line">    __attach_mnt(mnt, parent);  <span class="comment">// 将mnt添加到parent的mnt_hash链表头部，将mnt添加到parent的mnt_mounts链表尾部</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mnt_change_mountpoint</span><span class="params">(<span class="keyword">struct</span> mount *parent, <span class="keyword">struct</span> mountpoint *mp, <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保存旧的挂载点和父挂载</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">old_mp</span> =</span> mnt-&gt;mnt_mp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">old_parent</span> =</span> mnt-&gt;mnt_parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从相关链表中删除当前挂载</span></span><br><span class="line">    list_del_init(&amp;mnt-&gt;mnt_child);</span><br><span class="line">    hlist_del_init(&amp;mnt-&gt;mnt_mp_list);</span><br><span class="line">    hlist_del_init_rcu(&amp;mnt-&gt;mnt_hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前挂载点附加到新的父挂载和挂载点上</span></span><br><span class="line">    attach_mnt(mnt, parent, mp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放旧的挂载点</span></span><br><span class="line">    put_mountpoint(old_mp);</span><br><span class="line">    <span class="comment">// 更新旧的父挂载的挂载计数</span></span><br><span class="line">    mnt_add_count(old_parent, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfsmount lock must be held for write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">commit_tree</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取父挂载</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">parent</span> =</span> mnt-&gt;mnt_parent;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line">    LIST_HEAD(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">n</span> =</span> parent-&gt;mnt_ns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查父挂载和当前挂载是否相同</span></span><br><span class="line">    BUG_ON(parent == mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前挂载添加到链表头部</span></span><br><span class="line">    list_add_tail(&amp;head, &amp;mnt-&gt;mnt_list);</span><br><span class="line">    <span class="comment">// 遍历链表中的每个挂载，将它们的命名空间设置为父挂载的命名空间</span></span><br><span class="line">    list_for_each_entry(m, &amp;head, mnt_list)</span><br><span class="line">        m-&gt;mnt_ns = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将链表插入到命名空间的末尾</span></span><br><span class="line">    list_splice(&amp;head, n-&gt;<span class="built_in">list</span>.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新命名空间的挂载计数和待挂载计数</span></span><br><span class="line">    n-&gt;mounts += n-&gt;pending_mounts;</span><br><span class="line">    n-&gt;pending_mounts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前挂载附加到父挂载</span></span><br><span class="line">    __attach_mnt(mnt, parent);</span><br><span class="line">    <span class="comment">// 更新命名空间的访问时间戳</span></span><br><span class="line">    touch_mnt_namespace(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mount *<span class="title function_">next_mnt</span><span class="params">(<span class="keyword">struct</span> mount *p, <span class="keyword">struct</span> mount *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取下一个挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span> =</span> p-&gt;mnt_mounts.next;</span><br><span class="line">    <span class="keyword">if</span> (next == &amp;p-&gt;mnt_mounts) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已经到达根挂载点，则返回空</span></span><br><span class="line">            <span class="keyword">if</span> (p == root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 获取父挂载的下一个挂载点</span></span><br><span class="line">            next = p-&gt;mnt_child.next;</span><br><span class="line">            <span class="comment">// 如果下一个挂载点不是父挂载的链表头，则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (next != &amp;p-&gt;mnt_parent-&gt;mnt_mounts)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 更新父挂载为当前挂载的父挂载</span></span><br><span class="line">            p = p-&gt;mnt_parent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回下一个挂载点</span></span><br><span class="line">    <span class="keyword">return</span> list_entry(next, <span class="keyword">struct</span> mount, mnt_child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mount *<span class="title function_">skip_mnt_tree</span><span class="params">(<span class="keyword">struct</span> mount *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取上一个挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span> =</span> p-&gt;mnt_mounts.prev;</span><br><span class="line">    <span class="keyword">while</span> (prev != &amp;p-&gt;mnt_mounts) &#123;</span><br><span class="line">        <span class="comment">// 将上一个挂载点赋值给当前挂载点，并继续向前遍历</span></span><br><span class="line">        p = list_entry(prev, <span class="keyword">struct</span> mount, mnt_child);</span><br><span class="line">        prev = p-&gt;mnt_mounts.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个挂载点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_create_mount - Create a mount for a configured superblock</span></span><br><span class="line"><span class="comment"> * @fc: The configuration context with the superblock attached</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create a mount to an already configured superblock.  If necessary, the</span></span><br><span class="line"><span class="comment"> * caller should invoke vfs_get_tree() before calling this.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this does not attach the mount to anything.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">vfs_create_mount</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查根目录是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!fc-&gt;root)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个新的挂载结构体</span></span><br><span class="line">    mnt = alloc_vfsmnt(fc-&gt;source ?: <span class="string">&quot;none&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mnt)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是内核挂载，则设置挂载标志为MNT_INTERNAL</span></span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;sb_flags &amp; SB_KERNMOUNT)</span><br><span class="line">        mnt-&gt;mnt.mnt_flags = MNT_INTERNAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加超级块的活跃引用计数</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;fc-&gt;root-&gt;d_sb-&gt;s_active);</span><br><span class="line">    <span class="comment">// 设置挂载的超级块、根目录、挂载点和父挂载</span></span><br><span class="line">    mnt-&gt;mnt.mnt_sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">    mnt-&gt;mnt.mnt_root = dget(fc-&gt;root);</span><br><span class="line">    mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root;</span><br><span class="line">    mnt-&gt;mnt_parent = mnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line">    lock_mount_hash();</span><br><span class="line">    <span class="comment">// 将挂载添加到超级块的挂载链表末尾</span></span><br><span class="line">    list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;mnt-&gt;mnt.mnt_sb-&gt;s_mounts);</span><br><span class="line">    <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回挂载结构体指针</span></span><br><span class="line">    <span class="keyword">return</span> &amp;mnt-&gt;mnt;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_create_mount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">fc_mount</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件系统树</span></span><br><span class="line">    <span class="type">int</span> err = vfs_get_tree(fc);</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="comment">// 释放超级块的卸载信号量</span></span><br><span class="line">        up_write(&amp;fc-&gt;root-&gt;d_sb-&gt;s_umount);</span><br><span class="line">        <span class="comment">// 创建挂载</span></span><br><span class="line">        <span class="keyword">return</span> vfs_create_mount(fc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回错误码</span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(fc_mount);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mount *<span class="title function_">skip_mnt_tree</span><span class="params">(<span class="keyword">struct</span> mount *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取上一个挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span> =</span> p-&gt;mnt_mounts.prev;</span><br><span class="line">    <span class="keyword">while</span> (prev != &amp;p-&gt;mnt_mounts) &#123;</span><br><span class="line">        <span class="comment">// 将上一个挂载点赋值给当前挂载点，并继续向前遍历</span></span><br><span class="line">        p = list_entry(prev, <span class="keyword">struct</span> mount, mnt_child);</span><br><span class="line">        prev = p-&gt;mnt_mounts.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个挂载点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_create_mount - 为已配置的超级块创建一个挂载点</span></span><br><span class="line"><span class="comment"> * @fc: 带有已连接超级块的配置上下文</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 为已配置的超级块创建一个挂载点。如果需要，在调用此函数之前，调用者应该调用vfs_get_tree()。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，这不会将挂载点附加到任何位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">vfs_create_mount</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查根目录是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!fc-&gt;root)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个新的挂载结构体</span></span><br><span class="line">    mnt = alloc_vfsmnt(fc-&gt;source ?: <span class="string">&quot;none&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mnt)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是内核挂载，则设置挂载标志为MNT_INTERNAL</span></span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;sb_flags &amp; SB_KERNMOUNT)</span><br><span class="line">        mnt-&gt;mnt.mnt_flags = MNT_INTERNAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加超级块的活跃引用计数</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;fc-&gt;root-&gt;d_sb-&gt;s_active);</span><br><span class="line">    <span class="comment">// 设置挂载的超级块、根目录、挂载点和父挂载</span></span><br><span class="line">    mnt-&gt;mnt.mnt_sb = fc-&gt;root-&gt;d_sb;</span><br><span class="line">    mnt-&gt;mnt.mnt_root = dget(fc-&gt;root);</span><br><span class="line">    mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root;</span><br><span class="line">    mnt-&gt;mnt_parent = mnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line">    lock_mount_hash();</span><br><span class="line">    <span class="comment">// 将挂载添加到超级块的挂载链表末尾</span></span><br><span class="line">    list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;mnt-&gt;mnt.mnt_sb-&gt;s_mounts);</span><br><span class="line">    <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回挂载结构体指针</span></span><br><span class="line">    <span class="keyword">return</span> &amp;mnt-&gt;mnt;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_create_mount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">fc_mount</span><span class="params">(<span class="keyword">struct</span> fs_context *fc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件系统树</span></span><br><span class="line">    <span class="type">int</span> err = vfs_get_tree(fc);</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="comment">// 释放超级块的卸载信号量</span></span><br><span class="line">        up_write(&amp;fc-&gt;root-&gt;d_sb-&gt;s_umount);</span><br><span class="line">        <span class="comment">// 创建挂载</span></span><br><span class="line">        <span class="keyword">return</span> vfs_create_mount(fc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回错误码</span></span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(fc_mount);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">vfs_kern_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *type,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建文件系统上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line">    <span class="comment">// 挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件系统类型是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!type)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为挂载创建文件系统上下文</span></span><br><span class="line">    fc = fs_context_for_mount(type, flags);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(fc))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(fc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定了挂载名字，则解析挂载源字符串</span></span><br><span class="line">    <span class="keyword">if</span> (name)</span><br><span class="line">        ret = vfs_parse_fs_string(fc, <span class="string">&quot;source&quot;</span>,</span><br><span class="line">                                  name, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="comment">// 如果解析挂载源字符串成功，则解析挂载数据</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        ret = parse_monolithic_mount_data(fc, data);</span><br><span class="line">    <span class="comment">// 如果解析挂载数据成功，则进行挂载</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        mnt = fc_mount(fc);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mnt = ERR_PTR(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放文件系统上下文</span></span><br><span class="line">    put_fs_context(fc);</span><br><span class="line">    <span class="comment">// 返回挂载点</span></span><br><span class="line">    <span class="keyword">return</span> mnt;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(vfs_kern_mount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> vfsmount *</span><br><span class="line"><span class="title function_">vfs_submount</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dentry *mountpoint, <span class="keyword">struct</span> file_system_type *type,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 目前还没有解决如何从父挂载传递用户命名空间到子挂载，</span></span><br><span class="line"><span class="comment">     * 因此不支持带有子挂载的非特权挂载。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mountpoint-&gt;d_sb-&gt;s_user_ns != &amp;init_user_ns)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EPERM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用vfs_kern_mount进行子挂载</span></span><br><span class="line">    <span class="keyword">return</span> vfs_kern_mount(type, SB_SUBMOUNT, name, data);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(vfs_submount);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mount *<span class="title function_">clone_mnt</span><span class="params">(<span class="keyword">struct</span> mount *old, <span class="keyword">struct</span> dentry *root,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 克隆一个挂载点结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> old-&gt;mnt.mnt_sb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个虚拟文件系统挂载点</span></span><br><span class="line">    mnt = alloc_vfsmnt(old-&gt;mnt_devname);</span><br><span class="line">    <span class="keyword">if</span> (!mnt)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置挂载点的组ID</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))</span><br><span class="line">        mnt-&gt;mnt_group_id = <span class="number">0</span>; <span class="comment">/* 不是原始挂载点的对等点 */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mnt-&gt;mnt_group_id = old-&gt;mnt_group_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要创建共享挂载点，并且挂载点没有组ID，则分配一个组ID</span></span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; CL_MAKE_SHARED) &amp;&amp; !mnt-&gt;mnt_group_id) &#123;</span><br><span class="line">        err = mnt_alloc_group_id(mnt);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制挂载点的标志位</span></span><br><span class="line">    mnt-&gt;mnt.mnt_flags = old-&gt;mnt.mnt_flags;</span><br><span class="line">    mnt-&gt;mnt.mnt_flags &amp;= ~(MNT_WRITE_HOLD | MNT_MARKED | MNT_INTERNAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加超级块的活跃引用计数</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;sb-&gt;s_active);</span><br><span class="line">    <span class="comment">// 获取挂载点的ID映射</span></span><br><span class="line">    mnt-&gt;mnt.mnt_idmap = mnt_idmap_get(mnt_idmap(&amp;old-&gt;mnt));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置挂载点的超级块、根目录、挂载点和父挂载点</span></span><br><span class="line">    mnt-&gt;mnt.mnt_sb = sb;</span><br><span class="line">    mnt-&gt;mnt.mnt_root = dget(root);</span><br><span class="line">    mnt-&gt;mnt_mountpoint = mnt-&gt;mnt.mnt_root;</span><br><span class="line">    mnt-&gt;mnt_parent = mnt;</span><br><span class="line">    lock_mount_hash();</span><br><span class="line">    <span class="comment">// 将挂载点添加到超级块的挂载点链表中</span></span><br><span class="line">    list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;sb-&gt;s_mounts);</span><br><span class="line">    unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是从属挂载点或者是共享给从属挂载点的挂载点</span></span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; CL_SLAVE) ||</span><br><span class="line">        ((flag &amp; CL_SHARED_TO_SLAVE) &amp;&amp; IS_MNT_SHARED(old))) &#123;</span><br><span class="line">        <span class="comment">// 将挂载点添加到原始挂载点的从属挂载点链表中</span></span><br><span class="line">        list_add(&amp;mnt-&gt;mnt_slave, &amp;old-&gt;mnt_slave_list);</span><br><span class="line">        mnt-&gt;mnt_master = old;</span><br><span class="line">        CLEAR_MNT_SHARED(mnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是私有挂载点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(flag &amp; CL_PRIVATE)) &#123;</span><br><span class="line">        <span class="comment">// 如果需要创建共享挂载点或者原始挂载点是共享的，则将挂载点添加到原始挂载点的共享挂载点链表中</span></span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; CL_MAKE_SHARED) || IS_MNT_SHARED(old))</span><br><span class="line">            list_add(&amp;mnt-&gt;mnt_share, &amp;old-&gt;mnt_share);</span><br><span class="line">        <span class="comment">// 如果原始挂载点是从属挂载点，则将挂载点添加到原始挂载点的从属挂载点链表中</span></span><br><span class="line">        <span class="keyword">if</span> (IS_MNT_SLAVE(old))</span><br><span class="line">            list_add(&amp;mnt-&gt;mnt_slave, &amp;old-&gt;mnt_slave);</span><br><span class="line">        mnt-&gt;mnt_master = old-&gt;mnt_master;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是私有挂载点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        CLEAR_MNT_SHARED(mnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要创建共享挂载点，则设置挂载点为共享的</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; CL_MAKE_SHARED)</span><br><span class="line">        set_mnt_shared(mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要设置挂载点的过期时间，并且原始挂载点的过期链表不为空，则将挂载点添加到原始挂载点的过期链表中</span></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; CL_EXPIRE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;old-&gt;mnt_expire))</span><br><span class="line">            list_add(&amp;mnt-&gt;mnt_expire, &amp;old-&gt;mnt_expire);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mnt;</span><br><span class="line"></span><br><span class="line"> out_free:</span><br><span class="line">    mnt_free_id(mnt);</span><br><span class="line">    free_vfsmnt(mnt);</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup_mnt</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里的警告可能表示某人搞乱了mnt_want/drop_write()对。如果发生这种情况，</span></span><br><span class="line"><span class="comment">     * 文件系统可能无法进行读写-&gt;只读的转换。在处理mnt_count减少时使用的锁提供了屏障，</span></span><br><span class="line"><span class="comment">     * 所以下面的mnt_get_writers()是安全的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WARN_ON(mnt_get_writers(mnt));</span><br><span class="line">    <span class="comment">// 如果挂载点有引用计数，则杀死引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(mnt-&gt;mnt_pins.first))</span><br><span class="line">        mnt_pin_kill(mnt);</span><br><span class="line">    <span class="comment">// 遍历挂载点的挂起子挂载点链表，删除每个子挂载点并释放引用计数</span></span><br><span class="line">    hlist_for_each_entry_safe(m, p, &amp;mnt-&gt;mnt_stuck_children, mnt_umount) &#123;</span><br><span class="line">        hlist_del(&amp;m-&gt;mnt_umount);</span><br><span class="line">        mntput(&amp;m-&gt;mnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除文件系统通知的虚拟文件系统挂载点</span></span><br><span class="line">    fsnotify_vfsmount_delete(&amp;mnt-&gt;mnt);</span><br><span class="line">    <span class="comment">// 释放根目录的引用计数</span></span><br><span class="line">    dput(mnt-&gt;mnt.mnt_root);</span><br><span class="line">    <span class="comment">// 停用超级块</span></span><br><span class="line">    deactivate_super(mnt-&gt;mnt.mnt_sb);</span><br><span class="line">    <span class="comment">// 释放挂载点的ID</span></span><br><span class="line">    mnt_free_id(mnt);</span><br><span class="line">    <span class="comment">// 调用延迟释放虚拟文件系统挂载点的回调函数</span></span><br><span class="line">    call_rcu(&amp;mnt-&gt;mnt_rcu, delayed_free_vfsmnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __cleanup_mnt(<span class="keyword">struct</span> rcu_head *head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用cleanup_mnt函数进行挂载点的清理</span></span><br><span class="line">    cleanup_mnt(container_of(head, <span class="keyword">struct</span> mount, mnt_rcu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义延迟释放挂载点的工作队列</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">LLIST_HEAD</span><span class="params">(delayed_mntput_list)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delayed_mntput</span><span class="params">(<span class="keyword">struct</span> work_struct *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从延迟挂载点列表中删除所有节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> *<span class="title">node</span> =</span> llist_del_all(&amp;delayed_mntput_list);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>, *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历延迟挂载点列表中的每个挂载点，调用cleanup_mnt函数进行清理</span></span><br><span class="line">    llist_for_each_entry_safe(m, t, node, mnt_llist)</span><br><span class="line">        cleanup_mnt(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明延迟挂载点的工作</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_DELAYED_WORK</span><span class="params">(delayed_mntput_work, delayed_mntput)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mntput_no_expire</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_HEAD(<span class="built_in">list</span>);  <span class="comment">// 定义一个链表头</span></span><br><span class="line">    <span class="type">int</span> count;  <span class="comment">// 定义一个计数器</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();  <span class="comment">// 获取读取RCU锁</span></span><br><span class="line">    <span class="keyword">if</span> (likely(READ_ONCE(mnt-&gt;mnt_ns))) &#123;  <span class="comment">// 如果mnt的mnt_ns字段非空</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 由于我们在这里没有执行lock_mount_hash()，</span></span><br><span class="line"><span class="comment">         * -&gt;mnt_ns 可能在我们的操作期间发生变化。</span></span><br><span class="line"><span class="comment">         * 但是，如果它非空，则存在一个引用，</span></span><br><span class="line"><span class="comment">         * 直到将 -&gt;mnt_ns 变为 NULL 之后的 RCU 延迟之后才会被释放。</span></span><br><span class="line"><span class="comment">         * 因此，如果我们在 rcu_read_lock() 下观察到它非空，</span></span><br><span class="line"><span class="comment">         * 则我们要释放的引用不是最后一个引用。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mnt_add_count(mnt, <span class="number">-1</span>);  <span class="comment">// 减少mnt的引用计数</span></span><br><span class="line">        rcu_read_unlock();  <span class="comment">// 释放RCU锁</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lock_mount_hash();  <span class="comment">// 锁定mount哈希表</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 确保如果 __legitimize_mnt() 在我们获取 mount_lock 之前没有看到我们，</span></span><br><span class="line"><span class="comment">     * 我们将在此处看到他们的引用计数增加。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_mb();  <span class="comment">// 内存屏障</span></span><br><span class="line">    mnt_add_count(mnt, <span class="number">-1</span>);  <span class="comment">// 减少mnt的引用计数</span></span><br><span class="line">    count = mnt_get_count(mnt);  <span class="comment">// 获取mnt的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;  <span class="comment">// 如果引用计数不为0</span></span><br><span class="line">        WARN_ON(count &lt; <span class="number">0</span>);  <span class="comment">// 发出警告</span></span><br><span class="line">        rcu_read_unlock();  <span class="comment">// 释放RCU锁</span></span><br><span class="line">        unlock_mount_hash();  <span class="comment">// 解锁mount哈希表</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(mnt-&gt;mnt.mnt_flags &amp; MNT_DOOMED)) &#123;  <span class="comment">// 如果mnt的mnt_flags字段包含MNT_DOOMED标志</span></span><br><span class="line">        rcu_read_unlock();  <span class="comment">// 释放RCU锁</span></span><br><span class="line">        unlock_mount_hash();  <span class="comment">// 解锁mount哈希表</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mnt-&gt;mnt.mnt_flags |= MNT_DOOMED;  <span class="comment">// 设置mnt的mnt_flags字段的MNT_DOOMED标志</span></span><br><span class="line">    rcu_read_unlock();  <span class="comment">// 释放RCU锁</span></span><br><span class="line"></span><br><span class="line">    list_del(&amp;mnt-&gt;mnt_instance);  <span class="comment">// 从链表中删除mnt节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!list_empty(&amp;mnt-&gt;mnt_mounts))) &#123;  <span class="comment">// 如果mnt的mnt_mounts链表非空</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">        list_for_each_entry_safe(p, tmp, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123;  <span class="comment">// 遍历mnt的mnt_mounts链表</span></span><br><span class="line">            __put_mountpoint(unhash_mnt(p), &amp;<span class="built_in">list</span>);  <span class="comment">// 释放p的挂载点</span></span><br><span class="line">            hlist_add_head(&amp;p-&gt;mnt_umount, &amp;mnt-&gt;mnt_stuck_children);  <span class="comment">// 将p的mnt_umount节点添加到mnt的mnt_stuck_children哈希链表头部</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mount_hash();  <span class="comment">// 解锁mount哈希表</span></span><br><span class="line">    shrink_dentry_list(&amp;<span class="built_in">list</span>);  <span class="comment">// 收缩链表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!(mnt-&gt;mnt.mnt_flags &amp; MNT_INTERNAL))) &#123;  <span class="comment">// 如果mnt的mnt_flags字段不包含MNT_INTERNAL标志</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> =</span> current;  <span class="comment">// 获取当前进程的task_struct结构体指针</span></span><br><span class="line">        <span class="keyword">if</span> (likely(!(task-&gt;flags &amp; PF_KTHREAD))) &#123;  <span class="comment">// 如果当前进程不是内核线程</span></span><br><span class="line">            init_task_work(&amp;mnt-&gt;mnt_rcu, __cleanup_mnt);  <span class="comment">// 初始化mnt的mnt_rcu字段</span></span><br><span class="line">            <span class="keyword">if</span> (!task_work_add(task, &amp;mnt-&gt;mnt_rcu, TWA_RESUME))  <span class="comment">// 将mnt的mnt_rcu字段添加到当前进程的task_struct的工作队列中</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (llist_add(&amp;mnt-&gt;mnt_llist, &amp;delayed_mntput_list))  <span class="comment">// 将mnt的mnt_llist节点添加到delayed_mntput_list链表中</span></span><br><span class="line">            schedule_delayed_work(&amp;delayed_mntput_work, <span class="number">1</span>);  <span class="comment">// 延迟执行delayed_mntput_work函数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cleanup_mnt(mnt);  <span class="comment">// 清理mnt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mntput</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnt) &#123;  <span class="comment">// 如果mnt非空</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span> =</span> real_mount(mnt);  <span class="comment">// 获取mnt对应的mount结构体指针</span></span><br><span class="line">        <span class="comment">/* 避免缓存行来回跳动，希望gcc不会变得“聪明” */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(m-&gt;mnt_expiry_mark))  <span class="comment">// 如果mount的mnt_expiry_mark字段为真</span></span><br><span class="line">            m-&gt;mnt_expiry_mark = <span class="number">0</span>;  <span class="comment">// 将mount的mnt_expiry_mark字段置为0</span></span><br><span class="line">        mntput_no_expire(m);  <span class="comment">// 调用mntput_no_expire函数释放mount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mntput);  <span class="comment">// 导出mntput函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">mntget</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnt)</span><br><span class="line">        mnt_add_count(real_mount(mnt), <span class="number">1</span>);  <span class="comment">// 增加mnt对应的mount的引用计数</span></span><br><span class="line">    <span class="keyword">return</span> mnt;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mntget);  <span class="comment">// 导出mntget函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使挂载点对新的查找不可访问。</span></span><br><span class="line"><span class="comment"> * 因为可能仍然有当前用户，调用者必须在销毁挂载点之前等待RCU宽限期。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mnt_make_shortterm</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mnt)</span><br><span class="line">        real_mount(mnt)-&gt;mnt_ns = <span class="literal">NULL</span>;  <span class="comment">// 将mnt对应的mount的mnt_ns字段置为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * path_is_mountpoint() - 检查路径是否是当前命名空间中的挂载点。</span></span><br><span class="line"><span class="comment"> * @path: 要检查的路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * d_mountpoint() 只能可靠地用于确定一个dentry是否未在任何命名空间中挂载，</span></span><br><span class="line"><span class="comment"> * 并且这种常见情况在内联中处理。</span></span><br><span class="line"><span class="comment"> * d_mountpoint() 不知道可能有多个挂载使用给定dentry的可能性，</span></span><br><span class="line"><span class="comment"> * 而这些挂载位于不同的命名空间中。此函数检查传入的路径是否是挂载点，而不仅仅是dentry本身。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">path_is_mountpoint</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> seq;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!d_mountpoint(path-&gt;dentry))  <span class="comment">// 如果dentry不是挂载点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    rcu_read_lock();  <span class="comment">// 获取读取RCU锁</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        seq = read_seqbegin(&amp;mount_lock);  <span class="comment">// 读取mount_lock的序列号</span></span><br><span class="line">        res = __path_is_mountpoint(path);  <span class="comment">// 调用__path_is_mountpoint函数检查路径是否是挂载点</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (read_seqretry(&amp;mount_lock, seq));  <span class="comment">// 如果mount_lock的序列号发生变化，则重试</span></span><br><span class="line">    rcu_read_unlock();  <span class="comment">// 释放RCU锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(path_is_mountpoint);  <span class="comment">// 导出path_is_mountpoint函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">mnt_clone_internal</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span>  <span class="comment">// 定义一个指向struct mount结构体的指针p</span></span><br><span class="line">    p = clone_mnt(real_mount(path-&gt;mnt), path-&gt;dentry, CL_PRIVATE);  <span class="comment">// 调用clone_mnt函数克隆mount，并将结果赋值给p</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p))  <span class="comment">// 如果p是一个错误指针</span></span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(p);  <span class="comment">// 返回将p转换为错误类型的指针</span></span><br><span class="line">    p-&gt;mnt.mnt_flags |= MNT_INTERNAL;  <span class="comment">// 将mount的mnt_flags字段的MNT_INTERNAL标志置为真</span></span><br><span class="line">    <span class="keyword">return</span> &amp;p-&gt;mnt;  <span class="comment">// 返回指向mount的mnt字段_mounts结构体中的ns成员和prev指向的struct list_head结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PROC_FS</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mount *<span class="title function_">mnt_list_next</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> list_head *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>, *<span class="title">ret</span> =</span> <span class="literal">NULL</span>;  <span class="comment">// 定义两个指向struct mount结构体的指针mnt和ret</span></span><br><span class="line"></span><br><span class="line">    lock_ns_list(ns);  <span class="comment">// 锁定命名空间的列表</span></span><br><span class="line">    list_for_each_continue(p, &amp;ns-&gt;<span class="built_in">list</span>) &#123;  <span class="comment">// 遍历命名空间的列表</span></span><br><span class="line">        mnt = list_entry(p, typeof(*mnt), mnt_list);  <span class="comment">// 将p转换为struct mount结构体指针mnt</span></span><br><span class="line">        <span class="keyword">if</span> (!mnt_is_cursor(mnt)) &#123;  <span class="comment">// 如果mnt不是游标</span></span><br><span class="line">            ret = mnt;  <span class="comment">// 将mnt赋值给ret</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_ns_list(ns);  <span class="comment">// 解锁命名空间的列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回ret</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* iterator; we want it to have access to namespace_sem, thus here... ... */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">m_start</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_mounts</span> *<span class="title">p</span> =</span> m-&gt;private;  <span class="comment">// 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span>  <span class="comment">// 定义一个指向struct list_head结构体的指针prev</span></span><br><span class="line"></span><br><span class="line">    down_read(&amp;namespace_sem);  <span class="comment">// 获取读取锁，保证并发安全性</span></span><br><span class="line">    <span class="keyword">if</span> (!*pos) &#123;  <span class="comment">// 如果pos指向的值为0</span></span><br><span class="line">        prev = &amp;p-&gt;ns-&gt;<span class="built_in">list</span>;  <span class="comment">// prev指向p指向的struct proc_mounts结构体中的ns成员的list成员</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 否则</span></span><br><span class="line">        prev = &amp;p-&gt;cursor.mnt_list;  <span class="comment">// prev指向p指向的struct proc_mounts结构体中的cursor成员的mnt_list成员</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read after we&#x27;d reached the end? */</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(prev))  <span class="comment">// 如果prev指向的链表为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 返回空指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mnt_list_next(p-&gt;ns, prev);  <span class="comment">// 返回调用mnt_list_next函数的结果，传入参数p指向的struct proc_mounts结构体中的ns成员和prev指向的struct list_head结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">m_next</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_mounts</span> *<span class="title">p</span> =</span> m-&gt;private;  <span class="comment">// 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> v;  <span class="comment">// 定义一个指向struct mount结构体的指针mnt，指向参数v</span></span><br><span class="line"></span><br><span class="line">    ++*pos;  <span class="comment">// 增加pos指向的值</span></span><br><span class="line">    <span class="keyword">return</span> mnt_list_next(p-&gt;ns, &amp;mnt-&gt;mnt_list);  <span class="comment">// 返回调用mnt_list_next函数的结果，传入参数p指向的struct proc_mounts结构体中的ns成员和mnt指向的struct mount结构体的mnt_list成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">m_stop</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_mounts</span> *<span class="title">p</span> =</span> m-&gt;private;  <span class="comment">// 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> v;  <span class="comment">// 定义一个指向struct mount结构体的指针mnt，指向参数v</span></span><br><span class="line"></span><br><span class="line">    lock_ns_list(p-&gt;ns);  <span class="comment">// 锁定命名空间的列表</span></span><br><span class="line">    <span class="keyword">if</span> (mnt)</span><br><span class="line">        list_move_tail(&amp;p-&gt;cursor.mnt_list, &amp;mnt-&gt;mnt_list);  <span class="comment">// 将p指向的struct proc_mounts结构体中的cursor成员的mnt_list成员移动到mnt指向的struct mount结构体的mnt_list成员之后</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_del_init(&amp;p-&gt;cursor.mnt_list);  <span class="comment">// 从p指向的struct proc_mounts结构体中的cursor成员的mnt_list成员中删除并初始化</span></span><br><span class="line">    unlock_ns_list(p-&gt;ns);  <span class="comment">// 解锁命名空间的列表</span></span><br><span class="line">    up_read(&amp;namespace_sem);  <span class="comment">// 释放读取锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">m_show</span><span class="params">(<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_mounts</span> *<span class="title">p</span> =</span> m-&gt;private;  <span class="comment">// 定义一个指向struct proc_mounts结构体的指针p，指向seq_file结构体的private成员</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">r</span> =</span> v;  <span class="comment">// 定义一个指向struct mount结构体的指针r，指向参数v</span></span><br><span class="line">    <span class="keyword">return</span> p-&gt;show(m, &amp;r-&gt;mnt);  <span class="comment">// 调用p指向的struct proc_mounts结构体中的show成员函数，传入参数m和r指向的struct mount结构体的mnt成员的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> <span class="title">mounts_op</span> =</span> &#123;</span><br><span class="line">    .start  = m_start,  <span class="comment">// 设置start成员为m_start函数</span></span><br><span class="line">    .next   = m_next,  <span class="comment">// 设置next成员为m_next函数</span></span><br><span class="line">    .stop   = m_stop,  <span class="comment">// 设置stop成员为m_stop函数</span></span><br><span class="line">    .show   = m_show,  <span class="comment">// 设置show成员为m_show函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mnt_cursor_del</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns, <span class="keyword">struct</span> mount *cursor)</span></span><br><span class="line">&#123;</span><br><span class="line">    down_read(&amp;namespace_sem);  <span class="comment">// 获取读取锁，保证并发安全性</span></span><br><span class="line">    lock_ns_list(ns);  <span class="comment">// 锁定命名空间的列表</span></span><br><span class="line">    list_del(&amp;cursor-&gt;mnt_list);  <span class="comment">// 从cursor指向的struct mount结构体的mnt_list成员中删除</span></span><br><span class="line">    unlock_ns_list(ns);  <span class="comment">// 解锁命名空间的列表</span></span><br><span class="line">    up_read(&amp;namespace_sem);  <span class="comment">// 释放读取锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* CONFIG_PROC_FS */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * may_umount_tree - 检查挂载树是否繁忙</span></span><br><span class="line"><span class="comment"> * @m: 挂载树的根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数用于检查挂载树中是否有打开的文件、当前工作目录、chroot或子挂载点处于繁忙状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">may_umount_tree</span><span class="params">(<span class="keyword">struct</span> vfsmount *m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(m); <span class="comment">// 获取实际的挂载点</span></span><br><span class="line">    <span class="type">int</span> actual_refs = <span class="number">0</span>; <span class="comment">// 实际引用计数</span></span><br><span class="line">    <span class="type">int</span> minimum_refs = <span class="number">0</span>; <span class="comment">// 最小引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span> <span class="comment">// 用于遍历挂载点的指针</span></span><br><span class="line">    BUG_ON(!m); <span class="comment">// 断言，如果m为空，则触发BUG</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 需要写锁来获取mnt的引用计数 */</span></span><br><span class="line">    lock_mount_hash(); <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p; p = next_mnt(p, mnt)) &#123;</span><br><span class="line">        actual_refs += mnt_get_count(p); <span class="comment">// 累加实际引用计数</span></span><br><span class="line">        minimum_refs += <span class="number">2</span>; <span class="comment">// 最小引用计数加2</span></span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mount_hash(); <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actual_refs &gt; minimum_refs)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果实际引用计数大于最小引用计数，则返回0，表示繁忙</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 否则返回1，表示未繁忙</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(may_umount_tree); <span class="comment">// 导出符号，使其可被其他模块使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * may_umount - 检查挂载点是否繁忙</span></span><br><span class="line"><span class="comment"> * @mnt: 挂载点的根节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此函数用于检查挂载点中是否有打开的文件、当前工作目录、chroot或子挂载点。如果挂载点有子挂载点，无论子挂载点是否繁忙，都将返回繁忙状态。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不考虑配额等因素。也就是说，在某些情况下，它可能会给出错误的结果。它存在的主要原因是我们需要一种非破坏性的方式来查找可以轻松卸载的文件系统。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">may_umount</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>; <span class="comment">// 返回值，默认为1，表示未繁忙</span></span><br><span class="line">    down_read(&amp;namespace_sem); <span class="comment">// 获取命名空间信号量的读锁</span></span><br><span class="line">    lock_mount_hash(); <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (propagate_mount_busy(real_mount(mnt), <span class="number">2</span>)) <span class="comment">// 如果挂载点或其子挂载点繁忙</span></span><br><span class="line">        ret = <span class="number">0</span>; <span class="comment">// 将返回值设为0，表示繁忙</span></span><br><span class="line">    unlock_mount_hash(); <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line">    up_read(&amp;namespace_sem); <span class="comment">// 释放命名空间信号量的读锁</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(may_umount); <span class="comment">// 导出符号，使其可被其他模块使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">namespace_unlock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">head</span>;</span> <span class="comment">// 哈希表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">p</span>;</span> <span class="comment">// 哈希表节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span> <span class="comment">// 挂载点指针</span></span><br><span class="line">    LIST_HEAD(<span class="built_in">list</span>); <span class="comment">// 链表头</span></span><br><span class="line"></span><br><span class="line">    hlist_move_list(&amp;unmounted, &amp;head); <span class="comment">// 将unmounted链表移动到head哈希表中</span></span><br><span class="line">    list_splice_init(&amp;ex_mountpoints, &amp;<span class="built_in">list</span>); <span class="comment">// 将ex_mountpoints链表合并到list链表中</span></span><br><span class="line"></span><br><span class="line">    up_write(&amp;namespace_sem); <span class="comment">// 释放命名空间信号量的写锁</span></span><br><span class="line"></span><br><span class="line">    shrink_dentry_list(&amp;<span class="built_in">list</span>); <span class="comment">// 收缩dentry列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(hlist_empty(&amp;head)))</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如果head哈希表为空，则直接返回</span></span><br><span class="line"></span><br><span class="line">    synchronize_rcu_expedited(); <span class="comment">// 同步RCU</span></span><br><span class="line"></span><br><span class="line">    hlist_for_each_entry_safe(m, p, &amp;head, mnt_umount) &#123;</span><br><span class="line">        hlist_del(&amp;m-&gt;mnt_umount); <span class="comment">// 从head哈希表中删除挂载点</span></span><br><span class="line">        mntput(&amp;m-&gt;mnt); <span class="comment">// 释放挂载点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">namespace_lock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    down_write(&amp;namespace_sem); <span class="comment">// 获取命名空间信号量的写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">umount_tree_flags</span> &#123;</span></span><br><span class="line">    UMOUNT_SYNC = <span class="number">1</span>, <span class="comment">// 同步卸载标志</span></span><br><span class="line">    UMOUNT_PROPAGATE = <span class="number">2</span>, <span class="comment">// 传播卸载标志</span></span><br><span class="line">    UMOUNT_CONNECTED = <span class="number">4</span>, <span class="comment">// 连接卸载标志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">disconnect_mount</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="keyword">enum</span> umount_tree_flags how)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 只有对于延迟卸载，保持挂载连接才有效 */</span></span><br><span class="line">    <span class="keyword">if</span> (how &amp; UMOUNT_SYNC)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true，表示保持连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 没有父挂载点的挂载点无需连接 */</span></span><br><span class="line">    <span class="keyword">if</span> (!mnt_has_parent(mnt))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true，表示无需连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 因为在挂载点卸载和连接时引用计数规则发生变化，已卸载的挂载点不能连接到已挂载的挂载点 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(mnt-&gt;mnt_parent-&gt;mnt.mnt_flags &amp; MNT_UMOUNT))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true，表示无需连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 是否请求保持挂载连接？ */</span></span><br><span class="line">    <span class="keyword">if</span> (how &amp; UMOUNT_CONNECTED)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示保持连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 挂载点是否被锁定需要保持连接？ */</span></span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_LOCKED(mnt))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，表示保持连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 默认情况下断开挂载连接 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true，表示断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mount_lock must be held</span></span><br><span class="line"><span class="comment"> * namespace_sem must be held for write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">umount_tree</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="keyword">enum</span> umount_tree_flags how)</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_HEAD(tmp_list); <span class="comment">// 定义临时链表tmp_list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span> <span class="comment">// 定义挂载点指针p</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (how &amp; UMOUNT_PROPAGATE)</span><br><span class="line">        propagate_mount_unlock(mnt); <span class="comment">// 如果设置了UMOUNT_PROPAGATE标志，则解锁挂载点的传播</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 收集需要卸载的挂载点 */</span></span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p; p = next_mnt(p, mnt)) &#123;</span><br><span class="line">        p-&gt;mnt.mnt_flags |= MNT_UMOUNT; <span class="comment">// 设置挂载点的卸载标志</span></span><br><span class="line">        list_move(&amp;p-&gt;mnt_list, &amp;tmp_list); <span class="comment">// 将挂载点从mnt_mounts链表移动到tmp_list链表中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从mnt_mounts链表中隐藏挂载点 */</span></span><br><span class="line">    list_for_each_entry(p, &amp;tmp_list, mnt_list) &#123;</span><br><span class="line">        list_del_init(&amp;p-&gt;mnt_child); <span class="comment">// 从挂载点的父挂载点的mnt_mounts链表中删除挂载点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将传播的挂载点添加到tmp_list链表中 */</span></span><br><span class="line">    <span class="keyword">if</span> (how &amp; UMOUNT_PROPAGATE)</span><br><span class="line">        propagate_umount(&amp;tmp_list); <span class="comment">// 将传播的挂载点添加到tmp_list链表中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;tmp_list)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span>;</span> <span class="comment">// 命名空间指针</span></span><br><span class="line">        <span class="type">bool</span> disconnect; <span class="comment">// 是否断开连接的标志</span></span><br><span class="line">        p = list_first_entry(&amp;tmp_list, <span class="keyword">struct</span> mount, mnt_list); <span class="comment">// 获取tmp_list链表的第一个挂载点</span></span><br><span class="line">        list_del_init(&amp;p-&gt;mnt_expire); <span class="comment">// 从tmp_list链表中删除挂载点</span></span><br><span class="line">        list_del_init(&amp;p-&gt;mnt_list); <span class="comment">// 从tmp_list链表中删除挂载点</span></span><br><span class="line">        ns = p-&gt;mnt_ns; <span class="comment">// 获取挂载点所属的命名空间</span></span><br><span class="line">        <span class="keyword">if</span> (ns) &#123;</span><br><span class="line">            ns-&gt;mounts--; <span class="comment">// 命名空间的挂载点数减1</span></span><br><span class="line">            __touch_mnt_namespace(ns); <span class="comment">// 更新命名空间的时间戳</span></span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;mnt_ns = <span class="literal">NULL</span>; <span class="comment">// 将挂载点的命名空间指针置为NULL</span></span><br><span class="line">        <span class="keyword">if</span> (how &amp; UMOUNT_SYNC)</span><br><span class="line">            p-&gt;mnt.mnt_flags |= MNT_SYNC_UMOUNT; <span class="comment">// 如果设置了UMOUNT_SYNC标志，则设置挂载点的同步卸载标志</span></span><br><span class="line"></span><br><span class="line">        disconnect = disconnect_mount(p, how); <span class="comment">// 检查是否需要断开挂载连接</span></span><br><span class="line">        <span class="keyword">if</span> (mnt_has_parent(p)) &#123;</span><br><span class="line">            mnt_add_count(p-&gt;mnt_parent, <span class="number">-1</span>); <span class="comment">// 父挂载点的引用计数减1</span></span><br><span class="line">            <span class="keyword">if</span> (!disconnect) &#123;</span><br><span class="line">                <span class="comment">/* 不要忘记p */</span></span><br><span class="line">                list_add_tail(&amp;p-&gt;mnt_child, &amp;p-&gt;mnt_parent-&gt;mnt_mounts); <span class="comment">// 将挂载点添加到父挂载点的mnt_mounts链表末尾</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                umount_mnt(p); <span class="comment">// 卸载挂载点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        change_mnt_propagation(p, MS_PRIVATE); <span class="comment">// 修改挂载点的传播标志为MS_PRIVATE</span></span><br><span class="line">        <span class="keyword">if</span> (disconnect)</span><br><span class="line">            hlist_add_head(&amp;p-&gt;mnt_umount, &amp;unmounted); <span class="comment">// 将挂载点添加到unmounted哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shrink_submounts</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_umount_root</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取超级块的卸载信号量的写锁</span></span><br><span class="line">    down_write(&amp;sb-&gt;s_umount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查超级块是否为只读</span></span><br><span class="line">    <span class="keyword">if</span> (!sb_rdonly(sb)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新的文件系统上下文，用于将超级块的根目录重新配置为只读</span></span><br><span class="line">        fc = fs_context_for_reconfigure(sb-&gt;s_root, SB_RDONLY, SB_RDONLY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查文件系统上下文的创建是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(fc)) &#123;</span><br><span class="line">            ret = PTR_ERR(fc); <span class="comment">// 将返回值设置为错误代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解析整体挂载数据，并根据解析结果设置返回值</span></span><br><span class="line">            ret = parse_monolithic_mount_data(fc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果解析成功，则重新配置超级块，并根据结果设置返回值</span></span><br><span class="line">            <span class="keyword">if</span> (!ret)</span><br><span class="line">                ret = reconfigure_super(fc);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放文件系统上下文</span></span><br><span class="line">            put_fs_context(fc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放超级块的卸载信号量的写锁</span></span><br><span class="line">    up_write(&amp;sb-&gt;s_umount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回最终的返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_umount</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> mnt-&gt;mnt.mnt_sb;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用安全模块的 sb_umount 函数，检查是否允许卸载操作</span></span><br><span class="line">    retval = security_sb_umount(&amp;mnt-&gt;mnt, flags);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 允许用户空间请求过期挂载点而不是无条件卸载。只有在以下情况下才会执行卸载操作：</span></span><br><span class="line"><span class="comment">     *  (1) 标记已经被设置（标记会在 mntput() 中清除）</span></span><br><span class="line"><span class="comment">     *  (2) 使用计数 == 1（父 vfsmount）+ 1（sys_umount）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MNT_EXPIRE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt ||</span><br><span class="line">            flags &amp; (MNT_FORCE | MNT_DETACH))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果我们检查了所有竞争情况，可能不一定需要在这里加锁，但这是一个慢路径。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        lock_mount_hash();</span><br><span class="line">        <span class="keyword">if</span> (mnt_get_count(mnt) != <span class="number">2</span>) &#123;</span><br><span class="line">            unlock_mount_hash();</span><br><span class="line">            <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!xchg(&amp;mnt-&gt;mnt_expiry_mark, <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果我们可能需要中止操作以退出此挂载点，并且它们本身将持有资源，我们必须允许文件系统执行操作。</span></span><br><span class="line"><span class="comment">     * 在“Unix 以用户空间为中心”的传统中，umount_begin 可能无法在第一次运行时完成，因为其他任务必须返回等等。这是挂载程序目前需要担心的问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MNT_FORCE &amp;&amp; sb-&gt;s_op-&gt;umount_begin) &#123;</span><br><span class="line">        sb-&gt;s_op-&gt;umount_begin(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 没有必要为此测试获取锁，但测试本身看起来有些错误。有更好的替代方案吗？</span></span><br><span class="line"><span class="comment">     * 哦哼...原则上，我们可以将其视为卸载 + 切换到 rootfs。GC 最终会处理旧的 vfsmount。</span></span><br><span class="line"><span class="comment">     * 实际上是有意义的，特别是如果 rootfs 包含一个 /reboot - 静态二进制文件，它会关闭所有描述符并调用 reboot(9)。然后 init(8) 可以卸载 root 并执行 /reboot。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt &amp;&amp; !(flags &amp; MNT_DETACH)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 特殊情况下的“卸载”根目录...</span></span><br><span class="line"><span class="comment">         * 我们只尝试将其重新挂载为只读。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN))</span><br><span class="line">            <span class="keyword">return</span> -EPERM;</span><br><span class="line">        <span class="keyword">return</span> do_umount_root(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    namespace_lock();</span><br><span class="line">    lock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在持有锁的情况下重新检查 MNT_LOCKED */</span></span><br><span class="line">    retval = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    event++;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MNT_DETACH) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;mnt-&gt;mnt_list))</span><br><span class="line">            umount_tree(mnt, UMOUNT_PROPAGATE);</span><br><span class="line">        retval = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shrink_submounts(mnt);</span><br><span class="line">        retval = -EBUSY;</span><br><span class="line">        <span class="keyword">if</span> (!propagate_mount_busy(mnt, <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;mnt-&gt;mnt_list))</span><br><span class="line">                umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span><br><span class="line">            retval = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_mount_hash();</span><br><span class="line">    namespace_unlock();</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_umount</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> mnt-&gt;mnt.mnt_sb;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用安全模块的 sb_umount 函数，检查是否允许卸载操作</span></span><br><span class="line">    retval = security_sb_umount(&amp;mnt-&gt;mnt, flags);</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 允许用户空间请求过期挂载点而不是无条件卸载。只有在以下情况下才会执行卸载操作：</span></span><br><span class="line"><span class="comment">     *  (1) 标记已经被设置（标记会在 mntput() 中清除）</span></span><br><span class="line"><span class="comment">     *  (2) 使用计数 == 1（父 vfsmount）+ 1（sys_umount）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MNT_EXPIRE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt ||</span><br><span class="line">            flags &amp; (MNT_FORCE | MNT_DETACH))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果我们检查了所有竞争情况，可能不一定需要在这里加锁，但这是一个慢路径。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        lock_mount_hash();</span><br><span class="line">        <span class="keyword">if</span> (mnt_get_count(mnt) != <span class="number">2</span>) &#123;</span><br><span class="line">            unlock_mount_hash();</span><br><span class="line">            <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!xchg(&amp;mnt-&gt;mnt_expiry_mark, <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果我们可能需要中止操作以退出此挂载点，并且它们本身将持有资源，我们必须允许文件系统执行操作。</span></span><br><span class="line"><span class="comment">     * 在“Unix 以用户空间为中心”的传统中，umount_begin 可能无法在第一次运行时完成，因为其他任务必须返回等等。这是挂载程序目前需要担心的问题。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MNT_FORCE &amp;&amp; sb-&gt;s_op-&gt;umount_begin) &#123;</span><br><span class="line">        sb-&gt;s_op-&gt;umount_begin(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 没有必要为此测试获取锁，但测试本身看起来有些错误。有更好的替代方案吗？</span></span><br><span class="line"><span class="comment">     * 哦哼...原则上，我们可以将其视为卸载 + 切换到 rootfs。GC 最终会处理旧的 vfsmount。</span></span><br><span class="line"><span class="comment">     * 实际上是有意义的，特别是如果 rootfs 包含一个 /reboot - 静态二进制文件，它会关闭所有描述符并调用 reboot(9)。然后 init(8) 可以卸载 root 并执行 /reboot。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;mnt-&gt;mnt == current-&gt;fs-&gt;root.mnt &amp;&amp; !(flags &amp; MNT_DETACH)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 特殊情况下的“卸载”根目录...</span></span><br><span class="line"><span class="comment">         * 我们只尝试将其重新挂载为只读。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN))</span><br><span class="line">            <span class="keyword">return</span> -EPERM;</span><br><span class="line">        <span class="keyword">return</span> do_umount_root(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    namespace_lock();</span><br><span class="line">    lock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在持有锁的情况下重新检查 MNT_LOCKED */</span></span><br><span class="line">    retval = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    event++;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MNT_DETACH) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;mnt-&gt;mnt_list))</span><br><span class="line">            umount_tree(mnt, UMOUNT_PROPAGATE);</span><br><span class="line">        retval = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shrink_submounts(mnt);</span><br><span class="line">        retval = -EBUSY;</span><br><span class="line">        <span class="keyword">if</span> (!propagate_mount_busy(mnt, <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;mnt-&gt;mnt_list))</span><br><span class="line">                umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);</span><br><span class="line">            retval = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    unlock_mount_hash();</span><br><span class="line">    namespace_unlock();</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __detach_mounts - 懒惰地卸载指定 dentry 上的所有挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在 unlink、rmdir 和 d_drop 过程中，有可能丢失对现有挂载点的路径，</span></span><br><span class="line"><span class="comment"> * 导致挂载点泄漏。detach_mounts 允许懒惰地卸载这些挂载点，而不是泄漏它们。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者可能持有 dentry-&gt;d_inode-&gt;i_mutex。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __detach_mounts(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"></span><br><span class="line">    namespace_lock();  <span class="comment">// 锁定命名空间</span></span><br><span class="line">    lock_mount_hash();  <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line">    mp = lookup_mountpoint(dentry);  <span class="comment">// 查找挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (!mp)</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">    event++;  <span class="comment">// 增加事件计数</span></span><br><span class="line">    <span class="keyword">while</span> (!hlist_empty(&amp;mp-&gt;m_list)) &#123;</span><br><span class="line">        mnt = hlist_entry(mp-&gt;m_list.first, <span class="keyword">struct</span> mount, mnt_mp_list);</span><br><span class="line">        <span class="keyword">if</span> (mnt-&gt;mnt.mnt_flags &amp; MNT_UMOUNT) &#123;</span><br><span class="line">            umount_mnt(mnt);  <span class="comment">// 卸载挂载点</span></span><br><span class="line">            hlist_add_head(&amp;mnt-&gt;mnt_umount, &amp;unmounted);  <span class="comment">// 将挂载点添加到已卸载列表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            umount_tree(mnt, UMOUNT_CONNECTED);  <span class="comment">// 卸载整个挂载树</span></span><br><span class="line">    &#125;</span><br><span class="line">    put_mountpoint(mp);  <span class="comment">// 释放挂载点引用计数</span></span><br><span class="line">out_unlock:</span><br><span class="line">    unlock_mount_hash();  <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用者是否被允许修改其命名空间？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">may_mount</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ns_capable(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN);  <span class="comment">// 检查是否具有 CAP_SYS_ADMIN 权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">warn_mandlock</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pr_warn_once(<span class="string">&quot;=======================================================\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;警告：mand 挂载选项已被弃用，并且在此内核中被忽略。\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;从挂载中删除 mand 选项以消除此警告。\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;=======================================================\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">can_umount</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(path-&gt;mnt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!may_mount())</span><br><span class="line">        <span class="keyword">return</span> -EPERM;  <span class="comment">// 如果调用者没有挂载权限，则返回权限错误</span></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 如果路径的 dentry 不是挂载点的根目录，则返回无效参数错误</span></span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(mnt))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 如果挂载点无效，则返回无效参数错误</span></span><br><span class="line">    <span class="keyword">if</span> (mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) <span class="comment">/* Check optimistically */</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 如果挂载点被锁定，则返回无效参数错误</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MNT_FORCE &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;  <span class="comment">// 如果强制卸载标志被设置且调用者没有 CAP_SYS_ADMIN 权限，则返回权限错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// caller is responsible for flags being sane</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">path_umount</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(path-&gt;mnt);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = can_umount(path, flags);  <span class="comment">// 检查是否可以卸载</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        ret = do_umount(mnt, flags);  <span class="comment">// 执行卸载操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we mustn&#x27;t call path_put() as that would clear mnt_expiry_mark */</span></span><br><span class="line">    dput(path-&gt;dentry);  <span class="comment">// 释放 dentry 引用计数</span></span><br><span class="line">    mntput_no_expire(mnt);  <span class="comment">// 释放挂载点引用计数，不更新过期标记</span></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ksys_umount</span><span class="params">(<span class="type">char</span> __user *name, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lookup_flags = LOOKUP_MOUNTPOINT;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// basic validity checks done first</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 如果标志位中包含未定义的标志，则返回无效参数错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; UMOUNT_NOFOLLOW))</span><br><span class="line">        lookup_flags |= LOOKUP_FOLLOW;  <span class="comment">// 如果没有设置 UMOUNT_NOFOLLOW 标志，则设置 LOOKUP_FOLLOW 标志</span></span><br><span class="line">    ret = user_path_at(AT_FDCWD, name, lookup_flags, &amp;path);  <span class="comment">// 获取路径对应的 path 结构体</span></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;  <span class="comment">// 如果获取路径失败，则返回错误</span></span><br><span class="line">    <span class="keyword">return</span> path_umount(&amp;path, flags);  <span class="comment">// 执行路径卸载操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(umount, <span class="type">char</span> __user *, name, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ksys_umount(name, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARCH_WANT_SYS_OLDUMOUNT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2.0兼容的umount，没有标志位。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE1(oldumount, <span class="type">char</span> __user *, name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ksys_umount(name, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">is_mnt_ns_file</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 这是一个用于挂载命名空间的代理吗？ */</span></span><br><span class="line">    <span class="keyword">return</span> dentry-&gt;d_op == &amp;ns_dentry_operations &amp;&amp;</span><br><span class="line">           dentry-&gt;d_fsdata == &amp;mntns_operations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mnt_namespace *<span class="title function_">to_mnt_ns</span><span class="params">(<span class="keyword">struct</span> ns_common *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> container_of(ns, <span class="keyword">struct</span> mnt_namespace, ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ns_common *<span class="title function_">from_mnt_ns</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;mnt-&gt;ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">mnt_ns_loop</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 绑定挂载挂载命名空间inode是否会导致挂载命名空间循环？ */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!is_mnt_ns_file(dentry))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    mnt_ns = to_mnt_ns(get_proc_ns(dentry-&gt;d_inode));</span><br><span class="line">    <span class="keyword">return</span> current-&gt;nsproxy-&gt;mnt_ns-&gt;seq &gt;= mnt_ns-&gt;seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mount *<span class="title function_">copy_tree</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 复制挂载树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">res</span>, *<span class="title">p</span>, *<span class="title">q</span>, *<span class="title">r</span>, *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果标志位中不包含CL_COPY_UNBINDABLE，并且mnt是不可解绑的，则返回错误码EINVAL</span></span><br><span class="line">    <span class="keyword">if</span> (!(flag &amp; CL_COPY_UNBINDABLE) &amp;&amp; IS_MNT_UNBINDABLE(mnt))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果标志位中不包含CL_COPY_MNT_NS_FILE，并且dentry是挂载命名空间文件，则返回错误码EINVAL</span></span><br><span class="line">    <span class="keyword">if</span> (!(flag &amp; CL_COPY_MNT_NS_FILE) &amp;&amp; is_mnt_ns_file(dentry))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆挂载点</span></span><br><span class="line">    res = q = clone_mnt(mnt, dentry, flag);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(q))</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置克隆的挂载点的挂载点</span></span><br><span class="line">    q-&gt;mnt_mountpoint = mnt-&gt;mnt_mountpoint;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历挂载点的子挂载点</span></span><br><span class="line">    p = mnt;</span><br><span class="line">    list_for_each_entry(r, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">s</span>;</span></span><br><span class="line">        <span class="comment">// 如果r的挂载点不是dentry的子目录，则继续下一个挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (!is_subdir(r-&gt;mnt_mountpoint, dentry))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历r及其子挂载点</span></span><br><span class="line">        <span class="keyword">for</span> (s = r; s; s = next_mnt(s, r)) &#123;</span><br><span class="line">            <span class="comment">// 如果标志位中不包含CL_COPY_UNBINDABLE，并且s是不可解绑的</span></span><br><span class="line">            <span class="keyword">if</span> (!(flag &amp; CL_COPY_UNBINDABLE) &amp;&amp;</span><br><span class="line">                IS_MNT_UNBINDABLE(s)) &#123;</span><br><span class="line">                <span class="comment">// 如果s被锁定，则返回错误码EPERM；否则跳过该挂载点及其子挂载点</span></span><br><span class="line">                <span class="keyword">if</span> (s-&gt;mnt.mnt_flags &amp; MNT_LOCKED) &#123;</span><br><span class="line">                    <span class="comment">/* 同时不可解绑和被锁定。 */</span></span><br><span class="line">                    q = ERR_PTR(-EPERM);</span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    s = skip_mnt_tree(s);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果标志位中不包含CL_COPY_MNT_NS_FILE，并且s是挂载命名空间文件，则跳过该挂载点及其子挂载点</span></span><br><span class="line">            <span class="keyword">if</span> (!(flag &amp; CL_COPY_MNT_NS_FILE) &amp;&amp;</span><br><span class="line">                is_mnt_ns_file(s-&gt;mnt.mnt_root)) &#123;</span><br><span class="line">                s = skip_mnt_tree(s);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将p和q移动到s的父挂载点</span></span><br><span class="line">            <span class="keyword">while</span> (p != s-&gt;mnt_parent) &#123;</span><br><span class="line">                p = p-&gt;mnt_parent;</span><br><span class="line">                q = q-&gt;mnt_parent;</span><br><span class="line">            &#125;</span><br><span class="line">            p = s;</span><br><span class="line">            parent = q;</span><br><span class="line">            <span class="comment">// 克隆挂载点</span></span><br><span class="line">            q = clone_mnt(p, p-&gt;mnt.mnt_root, flag);</span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(q))</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            <span class="comment">// 锁定挂载哈希表，将克隆的挂载点添加到结果挂载点的链表中，并建立挂载关系</span></span><br><span class="line">            lock_mount_hash();</span><br><span class="line">            list_add_tail(&amp;q-&gt;mnt_list, &amp;res-&gt;mnt_list);</span><br><span class="line">            attach_mnt(q, parent, p-&gt;mnt_mp);</span><br><span class="line">            unlock_mount_hash();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 如果出错，则释放已分配的资源</span></span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        lock_mount_hash();</span><br><span class="line">        umount_tree(res, UMOUNT_SYNC);</span><br><span class="line">        unlock_mount_hash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * collect_mounts - 收集挂载点</span></span><br><span class="line"><span class="comment"> * @path: 要收集的路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者应该检查返回的指针是否有错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">collect_mounts</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">tree</span>;</span></span><br><span class="line">    namespace_lock(); <span class="comment">// 获取命名空间锁</span></span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(real_mount(path-&gt;mnt))) <span class="comment">// 检查挂载点是否有效</span></span><br><span class="line">        tree = ERR_PTR(-EINVAL);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree = copy_tree(real_mount(path-&gt;mnt), path-&gt;dentry,</span><br><span class="line">                         CL_COPY_ALL | CL_PRIVATE); <span class="comment">// 复制挂载点树</span></span><br><span class="line">    namespace_unlock(); <span class="comment">// 释放命名空间锁</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(tree)) <span class="comment">// 检查是否出错</span></span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(tree);</span><br><span class="line">    <span class="keyword">return</span> &amp;tree-&gt;mnt; <span class="comment">// 返回挂载点树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_mnt_ns</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mnt_namespace *<span class="title function_">alloc_mnt_ns</span><span class="params">(<span class="keyword">struct</span> user_namespace *, <span class="type">bool</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dissolve_on_fput</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    namespace_lock(); <span class="comment">// 获取命名空间锁</span></span><br><span class="line">    lock_mount_hash(); <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">    ns = real_mount(mnt)-&gt;mnt_ns;</span><br><span class="line">    <span class="keyword">if</span> (ns) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_anon_ns(ns))</span><br><span class="line">            umount_tree(real_mount(mnt), UMOUNT_CONNECTED); <span class="comment">// 解除连接的挂载点树</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ns = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mount_hash(); <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line">    namespace_unlock(); <span class="comment">// 释放命名空间锁</span></span><br><span class="line">    <span class="keyword">if</span> (ns)</span><br><span class="line">        free_mnt_ns(ns); <span class="comment">// 释放挂载命名空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drop_collected_mounts</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    namespace_lock(); <span class="comment">// 获取命名空间锁</span></span><br><span class="line">    lock_mount_hash(); <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">    umount_tree(real_mount(mnt), <span class="number">0</span>); <span class="comment">// 卸载挂载点树</span></span><br><span class="line">    unlock_mount_hash(); <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line">    namespace_unlock(); <span class="comment">// 释放命名空间锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">has_locked_children</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">child</span>;</span></span><br><span class="line">    list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!is_subdir(child-&gt;mnt_mountpoint, dentry)) <span class="comment">// 检查是否为子目录</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (child-&gt;mnt.mnt_flags &amp; MNT_LOCKED) <span class="comment">// 检查是否有被锁定的子挂载点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">lock_mnt_tree</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历挂载点树</span></span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p; p = next_mnt(p, mnt)) &#123;</span><br><span class="line">        <span class="type">int</span> flags = p-&gt;mnt.mnt_flags;</span><br><span class="line">        <span class="comment">/* 不允许非特权用户更改挂载标志 */</span></span><br><span class="line">        flags |= MNT_LOCK_ATIME; <span class="comment">// 将挂载标志中的MNT_LOCK_ATIME设置为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MNT_READONLY) <span class="comment">// 如果挂载标志中包含MNT_READONLY</span></span><br><span class="line">            flags |= MNT_LOCK_READONLY; <span class="comment">// 将挂载标志中的MNT_LOCK_READONLY设置为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MNT_NODEV) <span class="comment">// 如果挂载标志中包含MNT_NODEV</span></span><br><span class="line">            flags |= MNT_LOCK_NODEV; <span class="comment">// 将挂载标志中的MNT_LOCK_NODEV设置为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MNT_NOSUID) <span class="comment">// 如果挂载标志中包含MNT_NOSUID</span></span><br><span class="line">            flags |= MNT_LOCK_NOSUID; <span class="comment">// 将挂载标志中的MNT_LOCK_NOSUID设置为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MNT_NOEXEC) <span class="comment">// 如果挂载标志中包含MNT_NOEXEC</span></span><br><span class="line">            flags |= MNT_LOCK_NOEXEC; <span class="comment">// 将挂载标志中的MNT_LOCK_NOEXEC设置为1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 不允许非特权用户查看挂载点下的内容 */</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;p-&gt;mnt_expire))</span><br><span class="line">            flags |= MNT_LOCKED; <span class="comment">// 将挂载标志中的MNT_LOCKED设置为1</span></span><br><span class="line"></span><br><span class="line">        p-&gt;mnt.mnt_flags = flags; <span class="comment">// 更新挂载点的挂载标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup_group_ids</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="keyword">struct</span> mount *end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理挂载点的组ID</span></span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p != end; p = next_mnt(p, mnt)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;mnt_group_id &amp;&amp; !IS_MNT_SHARED(p))</span><br><span class="line">            mnt_release_group_id(p); <span class="comment">// 释放挂载点的组ID</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">invent_group_ids</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="type">bool</span> recurse)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为挂载点分配组ID</span></span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p; p = recurse ? next_mnt(p, mnt) : <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;mnt_group_id &amp;&amp; !IS_MNT_SHARED(p)) &#123;</span><br><span class="line">            <span class="type">int</span> err = mnt_alloc_group_id(p); <span class="comment">// 分配挂载点的组ID</span></span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                cleanup_group_ids(mnt, p); <span class="comment">// 分配失败时清理之前分配的组ID</span></span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">count_mounts</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns, <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max = READ_ONCE(sysctl_mount_max); <span class="comment">// 读取sysctl_mount_max的值并赋给max</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mounts = <span class="number">0</span>; <span class="comment">// 初始化mounts为0，用于计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ns-&gt;mounts &gt;= max) <span class="comment">// 如果ns的mounts计数超过了max</span></span><br><span class="line">        <span class="keyword">return</span> -ENOSPC; <span class="comment">// 返回&quot;没有空间&quot;的错误码</span></span><br><span class="line">    max -= ns-&gt;mounts; <span class="comment">// 更新max的值，减去已有的mounts计数</span></span><br><span class="line">    <span class="keyword">if</span> (ns-&gt;pending_mounts &gt;= max) <span class="comment">// 如果ns的pending_mounts计数超过了max</span></span><br><span class="line">        <span class="keyword">return</span> -ENOSPC; <span class="comment">// 返回&quot;没有空间&quot;的错误码</span></span><br><span class="line">    max -= ns-&gt;pending_mounts; <span class="comment">// 更新max的值，减去已有的pending_mounts计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p; p = next_mnt(p, mnt)) <span class="comment">// 遍历挂载点链表</span></span><br><span class="line">        mounts++; <span class="comment">// 每遍历一个挂载点，mounts计数加1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mounts &gt; max) <span class="comment">// 如果mounts计数超过了max</span></span><br><span class="line">        <span class="keyword">return</span> -ENOSPC; <span class="comment">// 返回&quot;没有空间&quot;的错误码</span></span><br><span class="line"></span><br><span class="line">    ns-&gt;pending_mounts += mounts; <span class="comment">// 更新ns的pending_mounts计数，加上新的mounts计数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功的状态码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  @source_mnt : 要附加的挂载树</span></span><br><span class="line"><span class="comment"> *  @nd         : 将挂载树 @source_mnt 附加到的位置</span></span><br><span class="line"><span class="comment"> *  @parent_nd  : 如果非空，将 source_mnt 从其父节点分离，并存储父节点挂载和挂载点 dentry。</span></span><br><span class="line"><span class="comment"> *     （当移动 source_mnt 时执行此操作）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  注意：下表解释了给定类型的源挂载附加到给定类型的目标挂载时的语义。</span></span><br><span class="line"><span class="comment"> * ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * |         绑定挂载操作                                                    |</span></span><br><span class="line"><span class="comment"> * |**************************************************************************</span></span><br><span class="line"><span class="comment"> * | source--&gt;| 共享         |       私有     |       从属     | 不可解绑   |</span></span><br><span class="line"><span class="comment"> * | dest     |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |   |      |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |   v      |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |**************************************************************************</span></span><br><span class="line"><span class="comment"> * |  共享    | 共享 (++)    |     共享 (+)  |     共享(+++) |  无效      |</span></span><br><span class="line"><span class="comment"> * |          |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |非共享    | 共享 (+)     |      私有      |      从属 (*) |  无效      |</span></span><br><span class="line"><span class="comment"> * ***************************************************************************</span></span><br><span class="line"><span class="comment"> * 绑定操作克隆源挂载并将克隆挂载到目标挂载上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (++)  克隆的挂载传播到目标挂载的传播树中的所有挂载点，并将克隆的挂载添加到源挂载的对等组中。</span></span><br><span class="line"><span class="comment"> * (+)   克隆的挂载在目标挂载下创建，并标记为共享。克隆的挂载添加到源挂载的对等组中。</span></span><br><span class="line"><span class="comment"> * (+++) 挂载传播到目标挂载的传播树中的所有挂载点，并将克隆的挂载作为源挂载的从属挂载，与源挂载相同的主挂载。克隆的挂载标记为“共享和从属”。</span></span><br><span class="line"><span class="comment"> * (*)   克隆的挂载作为源挂载的从属挂载，与源挂载相同的主挂载。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * |         移动挂载操作                                         |</span></span><br><span class="line"><span class="comment"> * |**************************************************************************</span></span><br><span class="line"><span class="comment"> * | source--&gt;| 共享         |       私有     |       从属     | 不可解绑   |</span></span><br><span class="line"><span class="comment"> * | dest     |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |   |      |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |   v      |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |**************************************************************************</span></span><br><span class="line"><span class="comment"> * |  共享    | 共享 (+)     |     共享 (+)  |    共享(+++)  |  无效      |</span></span><br><span class="line"><span class="comment"> * |          |               |                |                |            |</span></span><br><span class="line"><span class="comment"> * |非共享    | 共享 (+*)    |      私有      |    从属 (*)    | 不可解绑   |</span></span><br><span class="line"><span class="comment"> * ***************************************************************************</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (+)   挂载被移动到目标位置，并传播到目标挂载的传播树中的所有挂载点。</span></span><br><span class="line"><span class="comment"> * (+*)  挂载被移动到目标位置。</span></span><br><span class="line"><span class="comment"> * (+++) 挂载被移动到目标位置，并传播到目标挂载的传播树中的所有挂载点。挂载被标记为“共享和从属”。</span></span><br><span class="line"><span class="comment"> * (*)   挂载在新位置继续作为从属挂载。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果源挂载是一个树，则上述操作将应用于树中的每个挂载。</span></span><br><span class="line"><span class="comment"> * 必须在未持有自旋锁的情况下调用此函数，因为此函数可能会在分配时休眠。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">attach_recursive_mnt</span><span class="params">(<span class="keyword">struct</span> mount *source_mnt,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> mount *dest_mnt,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> mountpoint *dest_mp,</span></span><br><span class="line"><span class="params">                                <span class="type">bool</span> moving)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前进程的用户命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span> =</span> current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns;</span><br><span class="line">    <span class="comment">// 创建一个哈希链表用于存储树状结构的挂载点</span></span><br><span class="line">    HLIST_HEAD(tree_list);</span><br><span class="line">    <span class="comment">// 获取目标挂载点的命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span> =</span> dest_mnt-&gt;mnt_ns;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">smp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">child</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Preallocate a mountpoint in case the new mounts need</span></span><br><span class="line"><span class="comment">     * to be tucked under other mounts.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 预分配一个挂载点，以便将新的挂载点放置在其他挂载点下面</span></span><br><span class="line">    smp = get_mountpoint(source_mnt-&gt;mnt.mnt_root);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(smp))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(smp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is there space to add these mounts to the mount namespace? */</span></span><br><span class="line">    <span class="comment">// 检查是否有足够的空间将这些挂载点添加到挂载命名空间中</span></span><br><span class="line">    <span class="keyword">if</span> (!moving) &#123;</span><br><span class="line">        err = count_mounts(ns, source_mnt);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_SHARED(dest_mnt)) &#123;</span><br><span class="line">        <span class="comment">// 为源挂载点创建组ID</span></span><br><span class="line">        err = invent_group_ids(source_mnt, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">// 将源挂载点传播到目标挂载点下的树状结构中</span></span><br><span class="line">        err = propagate_mnt(dest_mnt, dest_mp, source_mnt, &amp;tree_list);</span><br><span class="line">        lock_mount_hash();</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out_cleanup_ids;</span><br><span class="line">        <span class="comment">// 将源挂载点及其子挂载点设置为共享挂载点</span></span><br><span class="line">        <span class="keyword">for</span> (p = source_mnt; p; p = next_mnt(p, source_mnt))</span><br><span class="line">            set_mnt_shared(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lock_mount_hash();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (moving) &#123;</span><br><span class="line">        <span class="comment">// 从哈希表中移除源挂载点</span></span><br><span class="line">        unhash_mnt(source_mnt);</span><br><span class="line">        <span class="comment">// 将源挂载点附加到目标挂载点下的挂载点</span></span><br><span class="line">        attach_mnt(source_mnt, dest_mnt, dest_mp);</span><br><span class="line">        <span class="comment">// 更新源挂载点所属的挂载命名空间</span></span><br><span class="line">        touch_mnt_namespace(source_mnt-&gt;mnt_ns);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (source_mnt-&gt;mnt_ns) &#123;</span><br><span class="line">            <span class="comment">/* move from anon - the caller will destroy */</span></span><br><span class="line">            <span class="comment">// 从匿名命名空间中移动挂载点，调用者将销毁该挂载点</span></span><br><span class="line">            list_del_init(&amp;source_mnt-&gt;mnt_ns-&gt;<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置源挂载点的挂载点信息</span></span><br><span class="line">        mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);</span><br><span class="line">        <span class="comment">// 提交源挂载点的树状结构</span></span><br><span class="line">        commit_tree(source_mnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历树状结构中的每个子挂载点</span></span><br><span class="line">    hlist_for_each_entry_safe(child, n, &amp;tree_list, mnt_hash) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">q</span>;</span></span><br><span class="line">        <span class="comment">// 从树状结构中移除子挂载点</span></span><br><span class="line">        hlist_del_init(&amp;child-&gt;mnt_hash);</span><br><span class="line">        <span class="comment">// 查找子挂载点的父挂载点</span></span><br><span class="line">        q = __lookup_mnt(&amp;child-&gt;mnt_parent-&gt;mnt,</span><br><span class="line">                         child-&gt;mnt_mountpoint);</span><br><span class="line">        <span class="keyword">if</span> (q)</span><br><span class="line">            <span class="comment">// 更改子挂载点的挂载点信息</span></span><br><span class="line">            mnt_change_mountpoint(child, smp, q);</span><br><span class="line">        <span class="comment">/* Notice when we are propagating across user namespaces */</span></span><br><span class="line">        <span class="comment">// 当在用户命名空间之间传播时，需要锁定挂载树</span></span><br><span class="line">        <span class="keyword">if</span> (child-&gt;mnt_parent-&gt;mnt_ns-&gt;user_ns != user_ns)</span><br><span class="line">            lock_mnt_tree(child);</span><br><span class="line">        <span class="comment">// 清除子挂载点的锁定标志</span></span><br><span class="line">        child-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED;</span><br><span class="line">        <span class="comment">// 提交子挂载点的树状结构</span></span><br><span class="line">        commit_tree(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放挂载点</span></span><br><span class="line">    put_mountpoint(smp);</span><br><span class="line">    <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_cleanup_ids:</span><br><span class="line">    <span class="comment">// 清理组ID</span></span><br><span class="line">    <span class="keyword">while</span> (!hlist_empty(&amp;tree_list)) &#123;</span><br><span class="line">        child = hlist_entry(tree_list.first, <span class="keyword">struct</span> mount, mnt_hash);</span><br><span class="line">        child-&gt;mnt_parent-&gt;mnt_ns-&gt;pending_mounts = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 卸载子挂载点的树状结构</span></span><br><span class="line">        umount_tree(child, UMOUNT_SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mount_hash();</span><br><span class="line">    <span class="comment">// 清理组ID</span></span><br><span class="line">    cleanup_group_ids(source_mnt, <span class="literal">NULL</span>);</span><br><span class="line">out:</span><br><span class="line">    ns-&gt;pending_mounts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    read_seqlock_excl(&amp;mount_lock);</span><br><span class="line">    <span class="comment">// 释放挂载点</span></span><br><span class="line">    put_mountpoint(smp);</span><br><span class="line">    read_sequnlock_excl(&amp;mount_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mountpoint *<span class="title function_">lock_mount</span><span class="params">(<span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> path-&gt;dentry;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 锁定inode</span></span><br><span class="line">    inode_lock(dentry-&gt;d_inode);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(cant_mount(dentry))) &#123;</span><br><span class="line">        <span class="comment">// 如果无法挂载，则解锁inode并返回错误指针</span></span><br><span class="line">        inode_unlock(dentry-&gt;d_inode);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁定命名空间</span></span><br><span class="line">    namespace_lock();</span><br><span class="line">    <span class="comment">// 查找挂载点</span></span><br><span class="line">    mnt = lookup_mnt(path);</span><br><span class="line">    <span class="keyword">if</span> (likely(!mnt)) &#123;</span><br><span class="line">        <span class="comment">// 如果找不到挂载点，则获取挂载点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span> =</span> get_mountpoint(dentry);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(mp)) &#123;</span><br><span class="line">            <span class="comment">// 如果获取挂载点失败，则解锁命名空间和inode，并返回错误指针</span></span><br><span class="line">            namespace_unlock();</span><br><span class="line">            inode_unlock(dentry-&gt;d_inode);</span><br><span class="line">            <span class="keyword">return</span> mp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回挂载点</span></span><br><span class="line">        <span class="keyword">return</span> mp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁命名空间和inode</span></span><br><span class="line">    namespace_unlock();</span><br><span class="line">    inode_unlock(path-&gt;dentry-&gt;d_inode);</span><br><span class="line">    <span class="comment">// 释放路径，并将mnt赋值给路径的mnt成员，将mnt的mnt_root赋值给路径的dentry成员</span></span><br><span class="line">    path_put(path);</span><br><span class="line">    path-&gt;mnt = mnt;</span><br><span class="line">    dentry = path-&gt;dentry = dget(mnt-&gt;mnt_root);</span><br><span class="line">    <span class="comment">// 重新尝试</span></span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">unlock_mount</span><span class="params">(<span class="keyword">struct</span> mountpoint *where)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> where-&gt;m_dentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读写序列锁</span></span><br><span class="line">    read_seqlock_excl(&amp;mount_lock);</span><br><span class="line">    <span class="comment">// 释放挂载点</span></span><br><span class="line">    put_mountpoint(where);</span><br><span class="line">    <span class="comment">// 解锁读写序列锁</span></span><br><span class="line">    read_sequnlock_excl(&amp;mount_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁命名空间和inode</span></span><br><span class="line">    namespace_unlock();</span><br><span class="line">    inode_unlock(dentry-&gt;d_inode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">graft_tree</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="keyword">struct</span> mount *p, <span class="keyword">struct</span> mountpoint *mp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查是否禁止用户挂载</span></span><br><span class="line">    <span class="keyword">if</span> (mnt-&gt;mnt.mnt_sb-&gt;s_flags &amp; SB_NOUSER)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查挂载点和挂载源是否都为目录</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_dir(mp-&gt;m_dentry) !=</span><br><span class="line">          d_is_dir(mnt-&gt;mnt.mnt_root))</span><br><span class="line">        <span class="keyword">return</span> -ENOTDIR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归挂载子树</span></span><br><span class="line">    <span class="keyword">return</span> attach_recursive_mnt(mnt, p, mp, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查更改挂载点传播标志的标志位是否合法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">flags_to_propagation_type</span><span class="params">(<span class="type">int</span> ms_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> type = ms_flags &amp; ~(MS_REC | MS_SILENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果设置了非传播标志，则失败 */</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp; ~(MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 只能设置一个传播标志 */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_power_of_2(type))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 递归地更改挂载点的类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_change_type</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">int</span> ms_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(path-&gt;mnt);</span><br><span class="line">    <span class="type">int</span> recurse = ms_flags &amp; MS_REC;</span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    type = flags_to_propagation_type(ms_flags);</span><br><span class="line">    <span class="keyword">if</span> (!type)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定命名空间</span></span><br><span class="line">    namespace_lock();</span><br><span class="line">    <span class="keyword">if</span> (type == MS_SHARED) &#123;</span><br><span class="line">        <span class="comment">// 为挂载点创建组ID</span></span><br><span class="line">        err = invent_group_ids(mnt, recurse);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">    lock_mount_hash();</span><br><span class="line">    <span class="keyword">for</span> (m = mnt; m; m = (recurse ? next_mnt(m, mnt) : <span class="literal">NULL</span>))</span><br><span class="line">        <span class="comment">// 更改挂载点的传播类型</span></span><br><span class="line">        change_mnt_propagation(m, type);</span><br><span class="line">    <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line">    unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    <span class="comment">// 解锁命名空间</span></span><br><span class="line">    namespace_unlock();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *__<span class="title">do_loopback</span>(<span class="keyword">struct</span> <span class="title">path</span> *<span class="title">old_path</span>, <span class="title">int</span> <span class="title">recurse</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> ERR_PTR(-EINVAL), *old = real_mount(old_path-&gt;mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果挂载点不可解绑，则返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_UNBINDABLE(old))</span><br><span class="line">        <span class="keyword">return</span> mnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果挂载点无效且dentry操作不是ns_dentry_operations，则返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(old) &amp;&amp; old_path-&gt;dentry-&gt;d_op != &amp;ns_dentry_operations)</span><br><span class="line">        <span class="keyword">return</span> mnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不递归且挂载点有锁定的子节点，则返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (!recurse &amp;&amp; has_locked_children(old, old_path-&gt;dentry))</span><br><span class="line">        <span class="keyword">return</span> mnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (recurse)</span><br><span class="line">        <span class="comment">// 复制树结构</span></span><br><span class="line">        mnt = copy_tree(old, old_path-&gt;dentry, CL_COPY_MNT_NS_FILE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 克隆挂载点</span></span><br><span class="line">        mnt = clone_mnt(old, old_path-&gt;dentry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(mnt))</span><br><span class="line">        <span class="comment">// 清除MNT_LOCKED标志</span></span><br><span class="line">        mnt-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 执行回环挂载。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_loopback</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">const</span> <span class="type">char</span> *old_name, <span class="type">int</span> recurse)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> <span class="literal">NULL</span>, *parent;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="keyword">if</span> (!old_name || !*old_name)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">// 获取旧路径</span></span><br><span class="line">    err = kern_path(old_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &amp;old_path);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="comment">// 如果旧路径的dentry属于mnt命名空间，则跳转到out</span></span><br><span class="line">    <span class="keyword">if</span> (mnt_ns_loop(old_path.dentry))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定挂载点</span></span><br><span class="line">    mp = lock_mount(path);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mp)) &#123;</span><br><span class="line">        err = PTR_ERR(mp);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取挂载点的真实挂载</span></span><br><span class="line">    parent = real_mount(path-&gt;mnt);</span><br><span class="line">    <span class="comment">// 如果挂载点无效，则跳转到out2</span></span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(parent))</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行回环挂载</span></span><br><span class="line">    mnt = __do_loopback(&amp;old_path, recurse);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mnt)) &#123;</span><br><span class="line">        err = PTR_ERR(mnt);</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将回环挂载的子树接入到父挂载点下</span></span><br><span class="line">    err = graft_tree(mnt, parent, mp);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">        lock_mount_hash();</span><br><span class="line">        <span class="comment">// 卸载回环挂载的子树</span></span><br><span class="line">        umount_tree(mnt, UMOUNT_SYNC);</span><br><span class="line">        <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line">        unlock_mount_hash();</span><br><span class="line">    &#125;</span><br><span class="line">out2:</span><br><span class="line">    <span class="comment">// 解锁挂载点</span></span><br><span class="line">    unlock_mount(mp);</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 释放旧路径</span></span><br><span class="line">    path_put(&amp;old_path);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file *<span class="title function_">open_detached_copy</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">bool</span> recursive)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span> =</span> current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span> =</span> alloc_mnt_ns(user_ns, <span class="literal">true</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ns))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(ns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定命名空间</span></span><br><span class="line">    namespace_lock();</span><br><span class="line">    <span class="comment">// 执行回环挂载</span></span><br><span class="line">    mnt = __do_loopback(path, recursive);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mnt)) &#123;</span><br><span class="line">        namespace_unlock();</span><br><span class="line">        free_mnt_ns(ns);</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(mnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定挂载点哈希表</span></span><br><span class="line">    lock_mount_hash();</span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p; p = next_mnt(p, mnt)) &#123;</span><br><span class="line">        <span class="comment">// 设置挂载点的命名空间</span></span><br><span class="line">        p-&gt;mnt_ns = ns;</span><br><span class="line">        ns-&gt;mounts++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置命名空间的根挂载点</span></span><br><span class="line">    ns-&gt;root = mnt;</span><br><span class="line">    <span class="comment">// 将命名空间添加到挂载点的链表中</span></span><br><span class="line">    list_add_tail(&amp;ns-&gt;<span class="built_in">list</span>, &amp;mnt-&gt;mnt_list);</span><br><span class="line">    mntget(&amp;mnt-&gt;mnt);</span><br><span class="line">    <span class="comment">// 解锁挂载点哈希表</span></span><br><span class="line">    unlock_mount_hash();</span><br><span class="line">    <span class="comment">// 解锁命名空间</span></span><br><span class="line">    namespace_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放原路径的挂载点</span></span><br><span class="line">    mntput(path-&gt;mnt);</span><br><span class="line">    <span class="comment">// 将新的挂载点赋值给路径的mnt成员</span></span><br><span class="line">    path-&gt;mnt = &amp;mnt-&gt;mnt;</span><br><span class="line">    <span class="comment">// 打开路径对应的文件</span></span><br><span class="line">    file = dentry_open(path, O_PATH, current_cred());</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">        <span class="comment">// 如果打开文件失败，则解散挂载点</span></span><br><span class="line">        dissolve_on_fput(path-&gt;mnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果成功打开文件，则设置文件的f_mode标志</span></span><br><span class="line">        file-&gt;f_mode |= FMODE_NEED_UNMOUNT;</span><br><span class="line">    <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(open_tree, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">unsigned</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>  <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span>  <span class="comment">// 路径结构体</span></span><br><span class="line">    <span class="type">int</span> lookup_flags = LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW;  <span class="comment">// 查找标志</span></span><br><span class="line">    <span class="type">bool</span> detached = flags &amp; OPEN_TREE_CLONE;  <span class="comment">// 是否分离</span></span><br><span class="line">    <span class="type">int</span> error;  <span class="comment">// 错误码</span></span><br><span class="line">    <span class="type">int</span> fd;  <span class="comment">// 文件描述符</span></span><br><span class="line"></span><br><span class="line">    BUILD_BUG_ON(OPEN_TREE_CLOEXEC != O_CLOEXEC);  <span class="comment">// 编译时检查</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(AT_EMPTY_PATH | AT_NO_AUTOMOUNT | AT_RECURSIVE |</span><br><span class="line">                  AT_SYMLINK_NOFOLLOW | OPEN_TREE_CLONE |</span><br><span class="line">                  OPEN_TREE_CLOEXEC))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 参数错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; (AT_RECURSIVE | OPEN_TREE_CLONE)) == AT_RECURSIVE)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 参数错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AT_NO_AUTOMOUNT)</span><br><span class="line">        lookup_flags &amp;= ~LOOKUP_AUTOMOUNT;  <span class="comment">// 不自动挂载</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AT_SYMLINK_NOFOLLOW)</span><br><span class="line">        lookup_flags &amp;= ~LOOKUP_FOLLOW;  <span class="comment">// 不跟随符号链接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AT_EMPTY_PATH)</span><br><span class="line">        lookup_flags |= LOOKUP_EMPTY;  <span class="comment">// 空路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (detached &amp;&amp; !may_mount())</span><br><span class="line">        <span class="keyword">return</span> -EPERM;  <span class="comment">// 没有权限</span></span><br><span class="line"></span><br><span class="line">    fd = get_unused_fd_flags(flags &amp; O_CLOEXEC);  <span class="comment">// 获取未使用的文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> fd;  <span class="comment">// 获取失败</span></span><br><span class="line"></span><br><span class="line">    error = user_path_at(dfd, filename, lookup_flags, &amp;path);  <span class="comment">// 获取用户路径</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">        file = ERR_PTR(error);  <span class="comment">// 错误处理</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (detached)</span><br><span class="line">            file = open_detached_copy(&amp;path, flags &amp; AT_RECURSIVE);  <span class="comment">// 分离复制</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            file = dentry_open(&amp;path, O_PATH, current_cred());  <span class="comment">// 打开目录项</span></span><br><span class="line">        path_put(&amp;path);  <span class="comment">// 释放路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        put_unused_fd(fd);  <span class="comment">// 释放文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(file);  <span class="comment">// 返回错误码</span></span><br><span class="line">    &#125;</span><br><span class="line">    fd_install(fd, file);  <span class="comment">// 安装文件描述符</span></span><br><span class="line">    <span class="keyword">return</span> fd;  <span class="comment">// 返回文件描述符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 不允许清除已锁定的挂载标志。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在测试各种MNT_LOCK标志时，此处不需要持有任何锁定，因为一旦设置了这些标志，它们就不能被清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">can_change_locked_flags</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="type">unsigned</span> <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fl = mnt-&gt;mnt.mnt_flags;  <span class="comment">// 获取挂载标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fl &amp; MNT_LOCK_READONLY) &amp;&amp; !(mnt_flags &amp; MNT_READONLY))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果已锁定只读标志且请求不是只读，则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fl &amp; MNT_LOCK_NODEV) &amp;&amp; !(mnt_flags &amp; MNT_NODEV))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果已锁定无设备标志且请求不是无设备，则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fl &amp; MNT_LOCK_NOSUID) &amp;&amp; !(mnt_flags &amp; MNT_NOSUID))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果已锁定无SUID标志且请求不是无SUID，则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fl &amp; MNT_LOCK_NOEXEC) &amp;&amp; !(mnt_flags &amp; MNT_NOEXEC))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果已锁定无执行标志且请求不是无执行，则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fl &amp; MNT_LOCK_ATIME) &amp;&amp; ((fl &amp; MNT_ATIME_MASK) != (mnt_flags &amp; MNT_ATIME_MASK)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果已锁定访问时间标志且请求的访问时间标志与已有标志不匹配，则返回false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 其他情况返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">change_mount_ro_state</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="type">unsigned</span> <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> readonly_request = (mnt_flags &amp; MNT_READONLY);  <span class="comment">// 是否请求只读</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readonly_request == __mnt_is_readonly(&amp;mnt-&gt;mnt))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 如果请求只读状态与当前状态相同，则返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (readonly_request)</span><br><span class="line">        <span class="keyword">return</span> mnt_make_readonly(mnt);  <span class="comment">// 设置为只读</span></span><br><span class="line"></span><br><span class="line">    mnt-&gt;mnt.mnt_flags &amp;= ~MNT_READONLY;  <span class="comment">// 清除只读标志</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_mount_attributes</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="type">unsigned</span> <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    mnt_flags |= mnt-&gt;mnt.mnt_flags &amp; ~MNT_USER_SETTABLE_MASK;  <span class="comment">// 设置挂载标志</span></span><br><span class="line">    mnt-&gt;mnt.mnt_flags = mnt_flags;  <span class="comment">// 更新挂载标志</span></span><br><span class="line">    touch_mnt_namespace(mnt-&gt;mnt_ns);  <span class="comment">// 更新挂载命名空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mnt_warn_timestamp_expiry</span><span class="params">(<span class="keyword">struct</span> path *mountpoint, <span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> mnt-&gt;mnt_sb;  <span class="comment">// 获取超级块</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!__mnt_is_readonly(mnt) &amp;&amp;  <span class="comment">// 如果挂载点不是只读</span></span><br><span class="line">        (!(sb-&gt;s_iflags &amp; SB_I_TS_EXPIRY_WARNED)) &amp;&amp;  <span class="comment">// 如果超级块的时间戳过期警告标志未设置</span></span><br><span class="line">        (ktime_get_real_seconds() + TIME_UPTIME_SEC_MAX &gt; sb-&gt;s_time_max)) &#123;  <span class="comment">// 如果当前时间加上最大运行时间小于超级块的最大时间戳</span></span><br><span class="line">        <span class="type">char</span> *buf = (<span class="type">char</span> *)__get_free_page(GFP_KERNEL);  <span class="comment">// 分配内存页</span></span><br><span class="line">        <span class="type">char</span> *mntpath = buf ? d_path(mountpoint, buf, PAGE_SIZE) : ERR_PTR(-ENOMEM);  <span class="comment">// 获取挂载路径</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tm</span>;</span></span><br><span class="line"></span><br><span class="line">        time64_to_tm(sb-&gt;s_time_max, <span class="number">0</span>, &amp;tm);  <span class="comment">// 将时间戳转换为tm结构体</span></span><br><span class="line"></span><br><span class="line">        pr_warn(<span class="string">&quot;%s filesystem being %s at %s supports timestamps until %04ld (0x%llx)\n&quot;</span>,</span><br><span class="line">                sb-&gt;s_type-&gt;name,</span><br><span class="line">                is_mounted(mnt) ? <span class="string">&quot;remounted&quot;</span> : <span class="string">&quot;mounted&quot;</span>,</span><br><span class="line">                mntpath,</span><br><span class="line">                tm.tm_year+<span class="number">1900</span>, (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)sb-&gt;s_time_max);  <span class="comment">// 打印警告信息</span></span><br><span class="line"></span><br><span class="line">        free_page((<span class="type">unsigned</span> <span class="type">long</span>)buf);  <span class="comment">// 释放内存页</span></span><br><span class="line">        sb-&gt;s_iflags |= SB_I_TS_EXPIRY_WARNED;  <span class="comment">// 设置超级块的时间戳过期警告标志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 仅处理挂载点的重新配置，而不修改它所引用的超级块。这是通过在mount(2)中指定MS_REMOUNT|MS_BIND来触发的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_reconfigure_mnt</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">unsigned</span> <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> path-&gt;mnt-&gt;mnt_sb;  <span class="comment">// 获取超级块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(path-&gt;mnt);  <span class="comment">// 获取挂载结构体</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(mnt))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 检查挂载结构体是否有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;dentry != mnt-&gt;mnt.mnt_root)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;  <span class="comment">// 检查挂载点是否为根目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!can_change_locked_flags(mnt, mnt_flags))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;  <span class="comment">// 检查是否可以更改已锁定的挂载标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 我们只检查超级块是否为只读，而不修改它，因此只使用down_read(&amp;sb-&gt;s_umount)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    down_read(&amp;sb-&gt;s_umount);  <span class="comment">// 读取锁定超级块</span></span><br><span class="line">    lock_mount_hash();  <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line">    ret = change_mount_ro_state(mnt, mnt_flags);  <span class="comment">// 更改挂载的只读状态</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        set_mount_attributes(mnt, mnt_flags);  <span class="comment">// 设置挂载属性</span></span><br><span class="line">    unlock_mount_hash();  <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    up_read(&amp;sb-&gt;s_umount);  <span class="comment">// 解锁超级块</span></span><br><span class="line"></span><br><span class="line">    mnt_warn_timestamp_expiry(path, &amp;mnt-&gt;mnt);  <span class="comment">// 检查时间戳过期警告</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 更改文件系统标志。dir应该是文件系统的物理根目录。</span></span><br><span class="line"><span class="comment"> * 如果你在某个地方挂载了一个非根目录，并且想对其进行重新挂载 - 很遗憾。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_remount</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">int</span> ms_flags, <span class="type">int</span> sb_flags,</span></span><br><span class="line"><span class="params">                      <span class="type">int</span> mnt_flags, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> path-&gt;mnt-&gt;mnt_sb;  <span class="comment">// 获取超级块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(path-&gt;mnt);  <span class="comment">// 获取挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(mnt))  <span class="comment">// 检查挂载点是否有效</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;dentry != path-&gt;mnt-&gt;mnt_root)  <span class="comment">// 检查路径是否为根目录</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!can_change_locked_flags(mnt, mnt_flags))  <span class="comment">// 检查是否可以更改锁定的标志</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    fc = fs_context_for_reconfigure(path-&gt;dentry, sb_flags, MS_RMT_MASK);  <span class="comment">// 为重新配置获取文件系统上下文</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(fc))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(fc);</span><br><span class="line"></span><br><span class="line">    fc-&gt;oldapi = <span class="literal">true</span>;</span><br><span class="line">    err = parse_monolithic_mount_data(fc, data);  <span class="comment">// 解析挂载数据</span></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        down_write(&amp;sb-&gt;s_umount);  <span class="comment">// 获取超级块的写锁</span></span><br><span class="line">        err = -EPERM;</span><br><span class="line">        <span class="keyword">if</span> (ns_capable(sb-&gt;s_user_ns, CAP_SYS_ADMIN)) &#123;  <span class="comment">// 检查是否具有管理员权限</span></span><br><span class="line">            err = reconfigure_super(fc);  <span class="comment">// 重新配置超级块</span></span><br><span class="line">            <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">                lock_mount_hash();  <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line">                set_mount_attributes(mnt, mnt_flags);  <span class="comment">// 设置挂载点的属性</span></span><br><span class="line">                unlock_mount_hash();  <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        up_write(&amp;sb-&gt;s_umount);  <span class="comment">// 释放超级块的写锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mnt_warn_timestamp_expiry(path, &amp;mnt-&gt;mnt);  <span class="comment">// 警告挂载点的时间戳过期</span></span><br><span class="line"></span><br><span class="line">    put_fs_context(fc);  <span class="comment">// 释放文件系统上下文</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">tree_contains_unbindable</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (p = mnt; p; p = next_mnt(p, mnt)) &#123;  <span class="comment">// 遍历挂载点及其子挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (IS_MNT_UNBINDABLE(p))  <span class="comment">// 检查挂载点是否不可解绑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查指定子树中是否存在对先前/相同挂载命名空间的引用。</span></span><br><span class="line"><span class="comment"> * 这样的引用可以作为挂载命名空间的锚点，而不会被挂载循环检查代码检查到，从而允许形成循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">check_for_nsfs_mounts</span><span class="params">(<span class="keyword">struct</span> mount *subtree)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    lock_mount_hash();  <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line">    <span class="keyword">for</span> (p = subtree; p; p = next_mnt(p, subtree))  <span class="comment">// 遍历子树中的挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (mnt_ns_loop(p-&gt;mnt.mnt_root))  <span class="comment">// 检查是否存在挂载命名空间循环引用</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    ret = <span class="literal">true</span>;</span><br><span class="line">out:</span><br><span class="line">    unlock_mount_hash();  <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_set_group</span><span class="params">(<span class="keyword">struct</span> path *from_path, <span class="keyword">struct</span> path *to_path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">from</span>, *<span class="title">to</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    from = real_mount(from_path-&gt;mnt);  <span class="comment">// 获取源挂载点</span></span><br><span class="line">    to = real_mount(to_path-&gt;mnt);  <span class="comment">// 获取目标挂载点</span></span><br><span class="line"></span><br><span class="line">    namespace_lock();  <span class="comment">// 锁定命名空间</span></span><br><span class="line"></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="comment">/* 源和目标都必须已挂载 */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_mounted(&amp;from-&gt;mnt))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!is_mounted(&amp;to-&gt;mnt))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = -EPERM;</span><br><span class="line">    <span class="comment">/* 我们应该被允许修改源和目标挂载点的挂载命名空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (!ns_capable(from-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (!ns_capable(to-&gt;mnt_ns-&gt;user_ns, CAP_SYS_ADMIN))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="comment">/* 源和目标路径应该是挂载的根目录 */</span></span><br><span class="line">    <span class="keyword">if</span> (from_path-&gt;dentry != from_path-&gt;mnt-&gt;mnt_root)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (to_path-&gt;dentry != to_path-&gt;mnt-&gt;mnt_root)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置共享组只允许在相同的超级块上进行 */</span></span><br><span class="line">    <span class="keyword">if</span> (from-&gt;mnt.mnt_sb != to-&gt;mnt.mnt_sb)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 源挂载点的根目录应该比目标挂载点的根目录更宽 */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_subdir(to-&gt;mnt.mnt_root, from-&gt;mnt.mnt_root))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 源挂载点的子挂载点不应该锁定目标挂载点的根目录 */</span></span><br><span class="line">    <span class="keyword">if</span> (has_locked_children(from, to-&gt;mnt.mnt_root))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置共享组只允许在私有挂载点上进行 */</span></span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_SHARED(to) || IS_MNT_SLAVE(to))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 源挂载点不应该是私有的 */</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_MNT_SHARED(from) &amp;&amp; !IS_MNT_SLAVE(from))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_SLAVE(from)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span> =</span> from-&gt;mnt_master;</span><br><span class="line"></span><br><span class="line">        list_add(&amp;to-&gt;mnt_slave, &amp;m-&gt;mnt_slave_list);</span><br><span class="line">        to-&gt;mnt_master = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_SHARED(from)) &#123;</span><br><span class="line">        to-&gt;mnt_group_id = from-&gt;mnt_group_id;</span><br><span class="line">        list_add(&amp;to-&gt;mnt_share, &amp;from-&gt;mnt_share);</span><br><span class="line">        lock_mount_hash();  <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line">        set_mnt_shared(to);  <span class="comment">// 设置挂载点为共享</span></span><br><span class="line">        unlock_mount_hash();  <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_move_mount</span><span class="params">(<span class="keyword">struct</span> path *old_path, <span class="keyword">struct</span> path *new_path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span>;</span>  <span class="comment">// 命名空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span>  <span class="comment">// 新挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">old</span>;</span>  <span class="comment">// 旧挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">parent</span>;</span>  <span class="comment">// 旧挂载点的父挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>, *<span class="title">old_mp</span>;</span>  <span class="comment">// 挂载点和旧挂载点的挂载点</span></span><br><span class="line">    <span class="type">int</span> err;  <span class="comment">// 错误码</span></span><br><span class="line">    <span class="type">bool</span> attached;  <span class="comment">// 是否已挂载</span></span><br><span class="line"></span><br><span class="line">    mp = lock_mount(new_path);  <span class="comment">// 锁定新挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mp))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mp);</span><br><span class="line"></span><br><span class="line">    old = real_mount(old_path-&gt;mnt);  <span class="comment">// 获取真实的旧挂载点</span></span><br><span class="line">    p = real_mount(new_path-&gt;mnt);  <span class="comment">// 获取真实的新挂载点</span></span><br><span class="line">    parent = old-&gt;mnt_parent;  <span class="comment">// 获取旧挂载点的父挂载点</span></span><br><span class="line">    attached = mnt_has_parent(old);  <span class="comment">// 检查旧挂载点是否已挂载</span></span><br><span class="line">    old_mp = old-&gt;mnt_mp;  <span class="comment">// 获取旧挂载点的挂载点</span></span><br><span class="line">    ns = old-&gt;mnt_ns;  <span class="comment">// 获取旧挂载点的命名空间</span></span><br><span class="line"></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    <span class="comment">/* 挂载点必须在我们的命名空间中 */</span></span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(p))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 被移动的对象必须已挂载... */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_mounted(&amp;old-&gt;mnt))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... 并且要么是我们的挂载点，要么是匿名命名空间的根挂载点 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(attached ? check_mnt(old) : is_anon_ns(ns)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old-&gt;mnt.mnt_flags &amp; MNT_LOCKED)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_path-&gt;dentry != old_path-&gt;mnt-&gt;mnt_root)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_is_dir(new_path-&gt;dentry) !=</span><br><span class="line">        d_is_dir(old_path-&gt;dentry))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 不要移动位于共享父挂载点中的挂载点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (attached &amp;&amp; IS_MNT_SHARED(parent))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 不要将包含不可解绑挂载点的挂载树移动到共享的目标挂载点。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_SHARED(p) &amp;&amp; tree_contains_unbindable(old))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    err = -ELOOP;</span><br><span class="line">    <span class="keyword">if</span> (!check_for_nsfs_mounts(old))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">for</span> (; mnt_has_parent(p); p = p-&gt;mnt_parent)</span><br><span class="line">        <span class="keyword">if</span> (p == old)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    err = attach_recursive_mnt(old, real_mount(new_path-&gt;mnt), mp,</span><br><span class="line">                               attached);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果挂载点被移动，它不应再自动过期 */</span></span><br><span class="line">    list_del_init(&amp;old-&gt;mnt_expire);</span><br><span class="line">    <span class="keyword">if</span> (attached)</span><br><span class="line">        put_mountpoint(old_mp);</span><br><span class="line">out:</span><br><span class="line">    unlock_mount(mp);</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attached)</span><br><span class="line">            mntput_no_expire(parent);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            free_mnt_ns(ns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_move_mount_old</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">const</span> <span class="type">char</span> *old_name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_path</span>;</span>  <span class="comment">// 旧路径</span></span><br><span class="line">    <span class="type">int</span> err;  <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!old_name || !*old_name)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    err = kern_path(old_name, LOOKUP_FOLLOW, &amp;old_path);  <span class="comment">// 获取旧路径</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    err = do_move_mount(&amp;old_path, path);  <span class="comment">// 移动挂载点</span></span><br><span class="line">    path_put(&amp;old_path);  <span class="comment">// 释放旧路径</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将挂载点添加到命名空间的挂载树中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_add_mount</span><span class="params">(<span class="keyword">struct</span> mount *newmnt, <span class="keyword">struct</span> mountpoint *mp,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">parent</span> =</span> real_mount(path-&gt;mnt);  <span class="comment">// 获取父挂载点</span></span><br><span class="line"></span><br><span class="line">    mnt_flags &amp;= ~MNT_INTERNAL_FLAGS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!check_mnt(parent))) &#123;</span><br><span class="line">        <span class="comment">/* 只有在私有命名空间中进行的自动挂载才是可接受的 */</span></span><br><span class="line">        <span class="keyword">if</span> (!(mnt_flags &amp; MNT_SHRINKABLE))</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        <span class="comment">/* ... 并且对于这些情况，最好挂载点仍然存在 */</span></span><br><span class="line">        <span class="keyword">if</span> (!parent-&gt;mnt_ns)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拒绝在相同挂载点上挂载相同的文件系统 */</span></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;mnt-&gt;mnt_sb == newmnt-&gt;mnt.mnt_sb &amp;&amp;</span><br><span class="line">        path-&gt;mnt-&gt;mnt_root == path-&gt;dentry)</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_is_symlink(newmnt-&gt;mnt.mnt_root))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    newmnt-&gt;mnt.mnt_flags = mnt_flags;</span><br><span class="line">    <span class="keyword">return</span> graft_tree(newmnt, parent, mp);  <span class="comment">// 将挂载点添加到挂载树中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">mount_too_revealing</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> super_block *sb, <span class="type">int</span> *new_mnt_flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用超级块配置创建一个新的挂载点，并请求将其添加到命名空间树中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_new_mount_fc</span><span class="params">(<span class="keyword">struct</span> fs_context *fc, <span class="keyword">struct</span> path *mountpoint,</span></span><br><span class="line"><span class="params">                           <span class="type">unsigned</span> <span class="type">int</span> mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span>  <span class="comment">// 虚拟文件系统挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>;</span>  <span class="comment">// 挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> fc-&gt;root-&gt;d_sb;  <span class="comment">// 超级块</span></span><br><span class="line">    <span class="type">int</span> error;  <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line">    error = security_sb_kern_mount(sb);  <span class="comment">// 安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; mount_too_revealing(sb, &amp;mnt_flags))  <span class="comment">// 检查是否过于暴露</span></span><br><span class="line">        error = -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">        fc_drop_locked(fc);</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    up_write(&amp;sb-&gt;s_umount);  <span class="comment">// 解锁超级块的卸载信号量</span></span><br><span class="line"></span><br><span class="line">    mnt = vfs_create_mount(fc);  <span class="comment">// 创建挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mnt);</span><br><span class="line"></span><br><span class="line">    mnt_warn_timestamp_expiry(mountpoint, mnt);  <span class="comment">// 检查挂载点的过期时间</span></span><br><span class="line"></span><br><span class="line">    mp = lock_mount(mountpoint);  <span class="comment">// 锁定挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mp)) &#123;</span><br><span class="line">        mntput(mnt);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(mp);</span><br><span class="line">    &#125;</span><br><span class="line">    error = do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags);  <span class="comment">// 将挂载点添加到挂载树中</span></span><br><span class="line">    unlock_mount(mp);  <span class="comment">// 解锁挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">        mntput(mnt);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为用户空间创建一个新的挂载点，并请求将其添加到命名空间的树中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_new_mount</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">const</span> <span class="type">char</span> *fstype, <span class="type">int</span> sb_flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> mnt_flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">type</span>;</span>  <span class="comment">// 文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span>  <span class="comment">// 文件系统上下文</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *subtype = <span class="literal">NULL</span>;  <span class="comment">// 子类型</span></span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;  <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fstype)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    type = get_fs_type(fstype);  <span class="comment">// 获取文件系统类型</span></span><br><span class="line">    <span class="keyword">if</span> (!type)</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;fs_flags &amp; FS_HAS_SUBTYPE) &#123;</span><br><span class="line">        subtype = <span class="built_in">strchr</span>(fstype, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (subtype) &#123;</span><br><span class="line">            subtype++;</span><br><span class="line">            <span class="keyword">if</span> (!*subtype) &#123;</span><br><span class="line">                put_filesystem(type);</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fc = fs_context_for_mount(type, sb_flags);  <span class="comment">// 创建文件系统上下文</span></span><br><span class="line">    put_filesystem(type);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(fc))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(fc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (subtype)</span><br><span class="line">        err = vfs_parse_fs_string(fc, <span class="string">&quot;subtype&quot;</span>,</span><br><span class="line">                                  subtype, <span class="built_in">strlen</span>(subtype));</span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; name)</span><br><span class="line">        err = vfs_parse_fs_string(fc, <span class="string">&quot;source&quot;</span>, name, <span class="built_in">strlen</span>(name));</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        err = parse_monolithic_mount_data(fc, data);</span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; !mount_capable(fc))</span><br><span class="line">        err = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        err = vfs_get_tree(fc);</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        err = do_new_mount_fc(fc, path, mnt_flags);  <span class="comment">// 创建新的挂载点</span></span><br><span class="line"></span><br><span class="line">    put_fs_context(fc);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">finish_automount</span><span class="params">(<span class="keyword">struct</span> vfsmount *m, <span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> path-&gt;dentry;  <span class="comment">// 获取路径的目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mp</span>;</span>  <span class="comment">// 挂载点结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span>  <span class="comment">// 挂载结构体指针</span></span><br><span class="line">    <span class="type">int</span> err;  <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m)  <span class="comment">// 如果挂载结构体为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(m))  <span class="comment">// 如果挂载结构体是错误指针</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(m);  <span class="comment">// 返回错误码</span></span><br><span class="line"></span><br><span class="line">    mnt = real_mount(m);  <span class="comment">// 获取真实的挂载结构体</span></span><br><span class="line">    <span class="comment">/* 新的挂载记录应该至少有2个引用，以防止在我们添加之前过期 */</span></span><br><span class="line">    BUG_ON(mnt_get_count(mnt) &lt; <span class="number">2</span>);  <span class="comment">// 如果挂载结构体的引用计数小于2，触发BUG</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;mnt_sb == path-&gt;mnt-&gt;mnt_sb &amp;&amp;  <span class="comment">// 如果挂载的超级块和路径的超级块相同</span></span><br><span class="line">        m-&gt;mnt_root == dentry) &#123;  <span class="comment">// 并且挂载的根目录和路径的目录项相同</span></span><br><span class="line">        err = -ELOOP;  <span class="comment">// 设置错误码为-ELOOP（循环链接）</span></span><br><span class="line">        <span class="keyword">goto</span> discard;  <span class="comment">// 跳转到discard标签处</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 我们不想使用lock_mount() - 在这种情况下，找到覆盖我们挂载点的东西意味着“静默地丢弃我们已经有的”，而不是“尝试在其上挂载”。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    inode_lock(dentry-&gt;d_inode);  <span class="comment">// 锁定目录项的索引节点</span></span><br><span class="line">    namespace_lock();  <span class="comment">// 锁定命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(cant_mount(dentry))) &#123;  <span class="comment">// 如果无法挂载目录项</span></span><br><span class="line">        err = -ENOENT;  <span class="comment">// 设置错误码为-ENOENT（找不到文件或目录）</span></span><br><span class="line">        <span class="keyword">goto</span> discard_locked;  <span class="comment">// 跳转到discard_locked标签处</span></span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_lock();  <span class="comment">// 读取RCU锁</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(__lookup_mnt(path-&gt;mnt, dentry))) &#123;  <span class="comment">// 如果在路径的挂载点中查找到目录项</span></span><br><span class="line">        rcu_read_unlock();  <span class="comment">// 解锁RCU锁</span></span><br><span class="line">        err = <span class="number">0</span>;  <span class="comment">// 设置错误码为0</span></span><br><span class="line">        <span class="keyword">goto</span> discard_locked;  <span class="comment">// 跳转到discard_locked标签处</span></span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();  <span class="comment">// 解锁RCU锁</span></span><br><span class="line">    mp = get_mountpoint(dentry);  <span class="comment">// 获取目录项的挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mp)) &#123;  <span class="comment">// 如果挂载点是错误指针</span></span><br><span class="line">        err = PTR_ERR(mp);  <span class="comment">// 获取错误码</span></span><br><span class="line">        <span class="keyword">goto</span> discard_locked;  <span class="comment">// 跳转到discard_locked标签处</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = do_add_mount(mnt, mp, path, path-&gt;mnt-&gt;mnt_flags | MNT_SHRINKABLE);  <span class="comment">// 添加挂载</span></span><br><span class="line">    unlock_mount(mp);  <span class="comment">// 解锁挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(err))  <span class="comment">// 如果发生错误</span></span><br><span class="line">        <span class="keyword">goto</span> discard;  <span class="comment">// 跳转到discard标签处</span></span><br><span class="line">    mntput(m);  <span class="comment">// 释放挂载结构体引用计数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line"></span><br><span class="line">discard_locked:</span><br><span class="line">    namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line">    inode_unlock(dentry-&gt;d_inode);  <span class="comment">// 解锁目录项的索引节点</span></span><br><span class="line">discard:</span><br><span class="line">    <span class="comment">/* 从任何可能的过期列表中删除m */</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;mnt-&gt;mnt_expire)) &#123;  <span class="comment">// 如果挂载结构体的过期列表不为空</span></span><br><span class="line">        namespace_lock();  <span class="comment">// 锁定命名空间</span></span><br><span class="line">        list_del_init(&amp;mnt-&gt;mnt_expire);  <span class="comment">// 从过期列表中删除挂载结构体</span></span><br><span class="line">        namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    mntput(m);  <span class="comment">// 释放挂载结构体引用计数</span></span><br><span class="line">    mntput(m);  <span class="comment">// 释放挂载结构体引用计数</span></span><br><span class="line">    <span class="keyword">return</span> err;  <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mnt_set_expiry - 将挂载点放入过期列表</span></span><br><span class="line"><span class="comment"> * @mnt: 要放入列表的挂载点</span></span><br><span class="line"><span class="comment"> * @expiry_list: 要添加挂载点的列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mnt_set_expiry</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> list_head *expiry_list)</span></span><br><span class="line">&#123;</span><br><span class="line">    namespace_lock();  <span class="comment">// 锁定命名空间</span></span><br><span class="line"></span><br><span class="line">    list_add_tail(&amp;real_mount(mnt)-&gt;mnt_expire, expiry_list);  <span class="comment">// 将挂载点添加到过期列表的尾部</span></span><br><span class="line"></span><br><span class="line">    namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(mnt_set_expiry);  <span class="comment">// 导出mnt_set_expiry符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理一个可过期的挂载点列表，目的是丢弃任何未使用且自上次访问以来未被触碰的挂载点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mark_mounts_for_expiry</span><span class="params">(<span class="keyword">struct</span> list_head *mounts)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>, *<span class="title">next</span>;</span></span><br><span class="line">    LIST_HEAD(graveyard);  <span class="comment">// 创建一个临时列表用于存放要丢弃的挂载点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (list_empty(mounts))  <span class="comment">// 如果挂载点列表为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    namespace_lock();  <span class="comment">// 锁定命名空间</span></span><br><span class="line">    lock_mount_hash();  <span class="comment">// 锁定挂载哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从过期列表中提取每个满足以下条件的vfsmount：</span></span><br><span class="line"><span class="comment">     * - 只被其父vfsmount引用</span></span><br><span class="line"><span class="comment">     * - 仍然标记为过期（在上次调用此函数时标记的；标记会在mntput()中清除）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    list_for_each_entry_safe(mnt, next, mounts, mnt_expire) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!xchg(&amp;mnt-&gt;mnt_expiry_mark, <span class="number">1</span>) ||  <span class="comment">// 如果挂载点的过期标记已经被清除或者</span></span><br><span class="line">            propagate_mount_busy(mnt, <span class="number">1</span>))  <span class="comment">// 挂载点正在被使用</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list_move(&amp;mnt-&gt;mnt_expire, &amp;graveyard);  <span class="comment">// 将挂载点从过期列表中移动到临时列表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;graveyard)) &#123;  <span class="comment">// 当临时列表不为空时</span></span><br><span class="line">        mnt = list_first_entry(&amp;graveyard, <span class="keyword">struct</span> mount, mnt_expire);  <span class="comment">// 获取临时列表中的第一个挂载点</span></span><br><span class="line">        touch_mnt_namespace(mnt-&gt;mnt_ns);  <span class="comment">// 更新挂载点所属的命名空间</span></span><br><span class="line">        umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC);  <span class="comment">// 卸载挂载点及其子挂载点</span></span><br><span class="line">    &#125;</span><br><span class="line">    unlock_mount_hash();  <span class="comment">// 解锁挂载哈希表</span></span><br><span class="line">    namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL_GPL(mark_mounts_for_expiry);  <span class="comment">// 导出mark_mounts_for_expiry符号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * select_submounts()的剽窃版本</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在子挂载点列表中搜索给定的挂载点，并将任何可收缩的子挂载点移动到“graveyard”列表中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">select_submounts</span><span class="params">(<span class="keyword">struct</span> mount *parent, <span class="keyword">struct</span> list_head *graveyard)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">this_parent</span> =</span> parent;  <span class="comment">// 当前父挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个挂载点</span></span><br><span class="line">    <span class="type">int</span> found = <span class="number">0</span>;  <span class="comment">// 找到的子挂载点数量</span></span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">    next = this_parent-&gt;mnt_mounts.next;  <span class="comment">// 获取下一个挂载点</span></span><br><span class="line">resume:</span><br><span class="line">    <span class="keyword">while</span> (next != &amp;this_parent-&gt;mnt_mounts) &#123;  <span class="comment">// 当下一个挂载点不是父挂载点的子挂载点列表的末尾时</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">tmp</span> =</span> next;  <span class="comment">// 临时指针指向下一个挂载点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> list_entry(tmp, <span class="keyword">struct</span> mount, mnt_child);  <span class="comment">// 获取挂载结构体</span></span><br><span class="line"></span><br><span class="line">        next = tmp-&gt;next;  <span class="comment">// 更新下一个挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (!(mnt-&gt;mnt.mnt_flags &amp; MNT_SHRINKABLE))  <span class="comment">// 如果挂载点不可收缩</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果d_mounts列表非空，则下降一级。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;mnt-&gt;mnt_mounts)) &#123;</span><br><span class="line">            this_parent = mnt;  <span class="comment">// 更新当前父挂载点</span></span><br><span class="line">            <span class="keyword">goto</span> repeat;  <span class="comment">// 跳转到repeat标签处</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!propagate_mount_busy(mnt, <span class="number">1</span>)) &#123;  <span class="comment">// 如果挂载点未被使用</span></span><br><span class="line">            list_move_tail(&amp;mnt-&gt;mnt_expire, graveyard);  <span class="comment">// 将挂载点移动到graveyard列表的末尾</span></span><br><span class="line">            found++;  <span class="comment">// 增加找到的子挂载点数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在此级别完成...上升并恢复搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (this_parent != parent) &#123;  <span class="comment">// 如果当前父挂载点不是初始父挂载点</span></span><br><span class="line">        next = this_parent-&gt;mnt_child.next;  <span class="comment">// 获取下一个挂载点</span></span><br><span class="line">        this_parent = this_parent-&gt;mnt_parent;  <span class="comment">// 更新当前父挂载点为上一级父挂载点</span></span><br><span class="line">        <span class="keyword">goto</span> resume;  <span class="comment">// 跳转到resume标签处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;  <span class="comment">// 返回找到的子挂载点数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理一个可过期的挂载点列表，目的是丢弃特定父挂载点的任何子挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 必须持有mount_lock的写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shrink_submounts</span><span class="params">(<span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_HEAD(graveyard);  <span class="comment">// 创建一个临时列表用于存放要丢弃的子挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从过期列表中提取&#x27;mountpoint&#x27;的子挂载点 */</span></span><br><span class="line">    <span class="keyword">while</span> (select_submounts(mnt, &amp;graveyard)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!list_empty(&amp;graveyard)) &#123;</span><br><span class="line">            m = list_first_entry(&amp;graveyard, <span class="keyword">struct</span> mount, mnt_expire);  <span class="comment">// 获取临时列表中的第一个子挂载点</span></span><br><span class="line">            touch_mnt_namespace(m-&gt;mnt_ns);  <span class="comment">// 更新子挂载点所属的命名空间</span></span><br><span class="line">            umount_tree(m, UMOUNT_PROPAGATE|UMOUNT_SYNC);  <span class="comment">// 卸载子挂载点及其子挂载点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">copy_mount_options</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *copy;  <span class="comment">// 用于存储拷贝后的数据的指针</span></span><br><span class="line">    <span class="type">unsigned</span> left, offset;  <span class="comment">// 用于记录剩余的数据长度和偏移量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data)  <span class="comment">// 如果输入数据为空，则返回空指针</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    copy = kmalloc(PAGE_SIZE, GFP_KERNEL);  <span class="comment">// 分配内存空间，大小为PAGE_SIZE，使用GFP_KERNEL标志</span></span><br><span class="line">    <span class="keyword">if</span> (!copy)  <span class="comment">// 如果内存分配失败，则返回错误指针</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    left = copy_from_user(copy, data, ... offset))  <span class="comment">// 从用户空间拷贝数据到内核空间，返回剩余的未拷贝的数据长度</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    copy[offset] = c;  <span class="comment">// 将拷贝的数据存储到指定偏移量的位置</span></span><br><span class="line">    left--;  <span class="comment">// 剩余数据长度减一</span></span><br><span class="line">    offset++;  <span class="comment">// 偏移量增加一</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == PAGE_SIZE) &#123;  <span class="comment">// 如果剩余数据长度等于PAGE_SIZE，则表示拷贝失败，释放内存并返回错误指针</span></span><br><span class="line">        kfree(copy);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> copy;  <span class="comment">// 返回拷贝后的数据指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">copy_mount_string</span><span class="params">(<span class="type">const</span> <span class="type">void</span> __user *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> data ? strndup_user(data, PATH_MAX) : <span class="literal">NULL</span>;  <span class="comment">// 如果输入数据不为空，则使用strndup_user函数拷贝数据并返回拷贝后的字符串指针，否则返回空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Flags是一个32位的值，允许在mount()调用中传递最多31个与文件系统无关的标志（例如：只读、无设备、无SUID等）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * data是一个(void *)，可以指向任何大小不超过PAGE_SIZE-1字节的结构，其中可以包含任意与文件系统相关的信息（或为NULL）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在0.97版本之前的mount()函数中没有flags参数。</span></span><br><span class="line"><span class="comment"> * 当引入flags参数时，要求其高半部分必须具有魔术值0xC0ED，直到2.4.0-test9版本为止。</span></span><br><span class="line"><span class="comment"> * 因此，如果存在这个魔术数，它不携带任何信息，必须被丢弃。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">path_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dev_name, <span class="keyword">struct</span> path *path,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *type_page, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> *data_page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mnt_flags = <span class="number">0</span>, sb_flags;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 丢弃魔术数 */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; MS_MGC_MSK) == MS_MGC_VAL)</span><br><span class="line">        flags &amp;= ~MS_MGC_MSK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 基本的合法性检查 */</span></span><br><span class="line">    <span class="keyword">if</span> (data_page)</span><br><span class="line">        ((<span class="type">char</span> *)data_page)[PAGE_SIZE - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOUSER)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    ret = security_sb_mount(dev_name, path, type_page, flags, data_page);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (!may_mount())</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; SB_MANDLOCK)</span><br><span class="line">        warn_mandlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 默认使用relatime，除非被覆盖 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MS_NOATIME))</span><br><span class="line">        mnt_flags |= MNT_RELATIME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分离每个挂载点的标志 */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOSUID)</span><br><span class="line">        mnt_flags |= MNT_NOSUID;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NODEV)</span><br><span class="line">        mnt_flags |= MNT_NODEV;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOEXEC)</span><br><span class="line">        mnt_flags |= MNT_NOEXEC;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOATIME)</span><br><span class="line">        mnt_flags |= MNT_NOATIME;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NODIRATIME)</span><br><span class="line">        mnt_flags |= MNT_NODIRATIME;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_STRICTATIME)</span><br><span class="line">        mnt_flags &amp;= ~(MNT_RELATIME | MNT_NOATIME);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_RDONLY)</span><br><span class="line">        mnt_flags |= MNT_READONLY;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_NOSYMFOLLOW)</span><br><span class="line">        mnt_flags |= MNT_NOSYMFOLLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remount的默认atime是保留的 */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; MS_REMOUNT) &amp;&amp;</span><br><span class="line">        ((flags &amp; (MS_NOATIME | MS_NODIRATIME | MS_RELATIME |</span><br><span class="line">                   MS_STRICTATIME)) == <span class="number">0</span>)) &#123;</span><br><span class="line">        mnt_flags &amp;= ~MNT_ATIME_MASK;</span><br><span class="line">        mnt_flags |= path-&gt;mnt-&gt;mnt_flags &amp; MNT_ATIME_MASK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sb_flags = flags &amp; (SB_RDONLY |</span><br><span class="line">                        SB_SYNCHRONOUS |</span><br><span class="line">                        SB_MANDLOCK |</span><br><span class="line">                        SB_DIRSYNC |</span><br><span class="line">                        SB_SILENT |</span><br><span class="line">                        SB_POSIXACL |</span><br><span class="line">                        SB_LAZYTIME |</span><br><span class="line">                        SB_I_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; (MS_REMOUNT | MS_BIND)) == (MS_REMOUNT | MS_BIND))</span><br><span class="line">        <span class="keyword">return</span> do_reconfigure_mnt(path, mnt_flags);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_REMOUNT)</span><br><span class="line">        <span class="keyword">return</span> do_remount(path, flags, sb_flags, mnt_flags, data_page);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_BIND)</span><br><span class="line">        <span class="keyword">return</span> do_loopback(path, dev_name, flags &amp; MS_REC);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; (MS_SHARED | MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))</span><br><span class="line">        <span class="keyword">return</span> do_change_type(path, flags);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MS_MOVE)</span><br><span class="line">        <span class="keyword">return</span> do_move_mount_old(path, dev_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> do_new_mount(path, type_page, sb_flags, mnt_flags, dev_name,</span><br><span class="line">                        data_page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">do_mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">const</span> <span class="type">char</span> __user *dir_name,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *type_page, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">void</span> *data_page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = path_mount(dev_name, &amp;path, type_page, flags, data_page);</span><br><span class="line">    path_put(&amp;path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ucounts *<span class="title function_">inc_mnt_namespaces</span><span class="params">(<span class="keyword">struct</span> user_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 增加挂载命名空间的引用计数</span></span><br><span class="line">    <span class="keyword">return</span> inc_ucount(ns, current_euid(), UCOUNT_MNT_NAMESPACES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加挂载命名空间的引用计数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dec_mnt_namespaces</span><span class="params">(<span class="keyword">struct</span> ucounts *ucounts)</span></span><br><span class="line">&#123;</span><br><span class="line">    dec_ucount(ucounts, UCOUNT_MNT_NAMESPACES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放挂载命名空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">free_mnt_ns</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果不是匿名命名空间，则释放命名空间的inode</span></span><br><span class="line">    <span class="keyword">if</span> (!is_anon_ns(ns))</span><br><span class="line">        ns_free_inum(&amp;ns-&gt;ns);</span><br><span class="line">    <span class="comment">// 减少挂载命名空间的引用计数</span></span><br><span class="line">    dec_mnt_namespaces(ns-&gt;ucounts);</span><br><span class="line">    <span class="comment">// 释放用户命名空间</span></span><br><span class="line">    put_user_ns(ns-&gt;user_ns);</span><br><span class="line">    <span class="comment">// 释放命名空间结构体内存</span></span><br><span class="line">    kfree(ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 分配一个挂载命名空间，并分配一个序列号，用于检测是否尝试将旧的挂载命名空间绑定到当前挂载命名空间，</span></span><br><span class="line"><span class="comment"> * 以防止引用计数循环。一个以10Ghz递增的64位数字需要12427年才能循环，所以可以忽略这种可能性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">atomic64_t</span> mnt_ns_seq = ATOMIC64_INIT(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配一个挂载命名空间</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mnt_namespace *<span class="title function_">alloc_mnt_ns</span><span class="params">(<span class="keyword">struct</span> user_namespace *user_ns, <span class="type">bool</span> anon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">new_ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucounts</span> *<span class="title">ucounts</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加挂载命名空间的引用计数</span></span><br><span class="line">    ucounts = inc_mnt_namespaces(user_ns);</span><br><span class="line">    <span class="keyword">if</span> (!ucounts)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOSPC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配挂载命名空间结构体内存</span></span><br><span class="line">    new_ns = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mnt_namespace), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="keyword">if</span> (!new_ns) &#123;</span><br><span class="line">        <span class="comment">// 分配失败，减少挂载命名空间的引用计数</span></span><br><span class="line">        dec_mnt_namespaces(ucounts);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!anon) &#123;</span><br><span class="line">        <span class="comment">// 如果不是匿名命名空间，则分配命名空间的inode</span></span><br><span class="line">        ret = ns_alloc_inum(&amp;new_ns-&gt;ns);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            kfree(new_ns);</span><br><span class="line">            dec_mnt_namespaces(ucounts);</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    new_ns-&gt;ns.ops = &amp;mntns_operations;</span><br><span class="line">    <span class="keyword">if</span> (!anon)</span><br><span class="line">        <span class="comment">// 分配一个序列号给新的挂载命名空间</span></span><br><span class="line">        new_ns-&gt;seq = atomic64_add_return(<span class="number">1</span>, &amp;mnt_ns_seq);</span><br><span class="line">    refcount_set(&amp;new_ns-&gt;ns.count, <span class="number">1</span>);</span><br><span class="line">    INIT_LIST_HEAD(&amp;new_ns-&gt;<span class="built_in">list</span>);</span><br><span class="line">    init_waitqueue_head(&amp;new_ns-&gt;poll);</span><br><span class="line">    spin_lock_init(&amp;new_ns-&gt;ns_lock);</span><br><span class="line">    new_ns-&gt;user_ns = get_user_ns(user_ns);</span><br><span class="line">    new_ns-&gt;ucounts = ucounts;</span><br><span class="line">    <span class="keyword">return</span> new_ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">__latent_entropy</span><br><span class="line"><span class="keyword">struct</span> mnt_namespace *<span class="title function_">copy_mnt_ns</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> flags, <span class="keyword">struct</span> mnt_namespace *ns,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> user_namespace *user_ns, <span class="keyword">struct</span> fs_struct *new_fs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">new_ns</span>;</span>  <span class="comment">// 定义一个新的mnt_namespace结构体指针new_ns</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">rootmnt</span> =</span> <span class="literal">NULL</span>, *pwdmnt = <span class="literal">NULL</span>;  <span class="comment">// 定义vfsmount结构体指针rootmnt和pwdmnt，并初始化为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>, *<span class="title">q</span>;</span>  <span class="comment">// 定义mount结构体指针p和q</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">old</span>;</span>  <span class="comment">// 定义mount结构体指针old</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">new</span>;</span>  <span class="comment">// 定义mount结构体指针new</span></span><br><span class="line">    <span class="type">int</span> copy_flags;  <span class="comment">// 定义整型变量copy_flags</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(!ns);  <span class="comment">// 检查ns是否为空，如果为空则触发BUG_ON宏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!(flags &amp; CLONE_NEWNS))) &#123;  <span class="comment">// 如果flags中不包含CLONE_NEWNS标志位</span></span><br><span class="line">        get_mnt_ns(ns);  <span class="comment">// 增加mnt_namespace的引用计数</span></span><br><span class="line">        <span class="keyword">return</span> ns;  <span class="comment">// 返回ns指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    old = ns-&gt;root;  <span class="comment">// 将ns的root成员赋值给old</span></span><br><span class="line"></span><br><span class="line">    new_ns = alloc_mnt_ns(user_ns, <span class="literal">false</span>);  <span class="comment">// 分配一个新的mnt_namespace结构体new_ns，并将user_ns赋值给它的user_ns成员</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(new_ns))  <span class="comment">// 如果new_ns是一个错误指针</span></span><br><span class="line">        <span class="keyword">return</span> new_ns;  <span class="comment">// 返回new_ns指针</span></span><br><span class="line"></span><br><span class="line">    namespace_lock();  <span class="comment">// 锁定命名空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 第一遍循环：复制树的拓扑结构 */</span></span><br><span class="line">    copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;  <span class="comment">// 设置copy_flags为CL_COPY_UNBINDABLE和CL_EXPIRE的按位或结果</span></span><br><span class="line">    <span class="keyword">if</span> (user_ns != ns-&gt;user_ns)  <span class="comment">// 如果user_ns不等于ns的user_ns</span></span><br><span class="line">        copy_flags |= CL_SHARED_TO_SLAVE;  <span class="comment">// 将CL_SHARED_TO_SLAVE标志位加入copy_flags</span></span><br><span class="line">    new = copy_tree(old, old-&gt;mnt.mnt_root, copy_flags);  <span class="comment">// 复制old的树拓扑结构到new，并根据copy_flags进行相应的处理</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(new)) &#123;  <span class="comment">// 如果new是一个错误指针</span></span><br><span class="line">        namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line">        free_mnt_ns(new_ns);  <span class="comment">// 释放new_ns</span></span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(new);  <span class="comment">// 返回new指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (user_ns != ns-&gt;user_ns) &#123;  <span class="comment">// 如果user_ns不等于ns的user_ns</span></span><br><span class="line">        lock_mount_hash();  <span class="comment">// 锁定mount哈希表</span></span><br><span class="line">        lock_mnt_tree(new);  <span class="comment">// 锁定new的mnt_tree</span></span><br><span class="line">        unlock_mount_hash();  <span class="comment">// 解锁mount哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line">    new_ns-&gt;root = new;  <span class="comment">// 将new赋值给new_ns的root成员</span></span><br><span class="line">    list_add_tail(&amp;new_ns-&gt;<span class="built_in">list</span>, &amp;new-&gt;mnt_list);  <span class="comment">// 将new_ns添加到new的mnt_list的尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 第二遍循环：切换tsk-&gt;fs-&gt;*元素并标记新的vfsmount属于新的命名空间。</span></span><br><span class="line"><span class="comment">     * 我们已经获取了一个私有的fs_struct，所以不需要tsk-&gt;fs-&gt;lock。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    p = old;  <span class="comment">// 将old赋值给p</span></span><br><span class="line">    q = new;  <span class="comment">// 将new赋值给q</span></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;  <span class="comment">// 循环直到p为空指针</span></span><br><span class="line">        q-&gt;mnt_ns = new_ns;  <span class="comment">// 将new_ns赋值给q的mnt_ns成员</span></span><br><span class="line">        new_ns-&gt;mounts++;  <span class="comment">// 增加new_ns的mounts计数</span></span><br><span class="line">        <span class="keyword">if</span> (new_fs) &#123;  <span class="comment">// 如果new_fs不为空</span></span><br><span class="line">            <span class="keyword">if</span> (&amp;p-&gt;mnt == new_fs-&gt;root.mnt) &#123;  <span class="comment">// 如果p的mnt等于new_fs的root.mnt</span></span><br><span class="line">                new_fs-&gt;root.mnt = mntget(&amp;q-&gt;mnt);  <span class="comment">// 将q的mnt增加引用计数并赋值给new_fs的root.mnt</span></span><br><span class="line">                rootmnt = &amp;p-&gt;mnt;  <span class="comment">// 将p的mnt赋值给rootmnt</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (&amp;p-&gt;mnt == new_fs-&gt;pwd.mnt) &#123;  <span class="comment">// 如果p的mnt等于new_fs的pwd.mnt</span></span><br><span class="line">                new_fs-&gt;pwd.mnt = mntget(&amp;q-&gt;mnt);  <span class="comment">// 将q的mnt增加引用计数并赋值给new_fs的pwd.mnt</span></span><br><span class="line">                pwdmnt = &amp;p-&gt;mnt;  <span class="comment">// 将p的mnt赋值给pwdmnt</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p = next_mnt(p, old);  <span class="comment">// 获取old中p的下一个mount结构体指针，并赋值给p</span></span><br><span class="line">        q = next_mnt(q, new);  <span class="comment">// 获取new中q的下一个mount结构体指针，并赋值给q</span></span><br><span class="line">        <span class="keyword">if</span> (!q)  <span class="comment">// 如果q为空指针</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 跳出循环</span></span><br><span class="line">        <span class="comment">// 跳过我们跳过的mntns绑定？</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;mnt.mnt_root != q-&gt;mnt.mnt_root)  <span class="comment">// 当p的mnt_root不等于q的mnt_root时</span></span><br><span class="line">            p = next_mnt(skip_mnt_tree(p), old);  <span class="comment">// 获取old中p的下一个mount结构体指针，并赋值给p</span></span><br><span class="line">    &#125;</span><br><span class="line">    namespace_unlock();  <span class="comment">// 解锁命名空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rootmnt)  <span class="comment">// 如果rootmnt不为空指针</span></span><br><span class="line">        mntput(rootmnt);  <span class="comment">// 减少rootmnt的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (pwdmnt)  <span class="comment">// 如果pwdmnt不为空指针</span></span><br><span class="line">        mntput(pwdmnt);  <span class="comment">// 减少pwdmnt的引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_ns;  <span class="comment">// 返回new_ns指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">mount_subtree</span><span class="params">(<span class="keyword">struct</span> vfsmount *m, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(m);  <span class="comment">// 获取vfsmount对应的mount结构体指针mnt</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span>;</span>  <span class="comment">// 定义mnt_namespace结构体指针ns</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">s</span>;</span>  <span class="comment">// 定义super_block结构体指针s</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span>  <span class="comment">// 定义path结构体path</span></span><br><span class="line">    <span class="type">int</span> err;  <span class="comment">// 定义整型变量err</span></span><br><span class="line"></span><br><span class="line">    ns = alloc_mnt_ns(&amp;init_user_ns, <span class="literal">true</span>);  <span class="comment">// 分配一个新的mnt_namespace结构体ns，并将init_user_ns赋值给它的user_ns成员</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ns)) &#123;  <span class="comment">// 如果ns是一个错误指针</span></span><br><span class="line">        mntput(m);  <span class="comment">// 减少m的引用计数</span></span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(ns);  <span class="comment">// 返回ns指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    mnt-&gt;mnt_ns = ns;  <span class="comment">// 将ns赋值给mnt的mnt_ns成员</span></span><br><span class="line">    ns-&gt;root = mnt;  <span class="comment">// 将mnt赋值给ns的root成员</span></span><br><span class="line">    ns-&gt;mounts++;  <span class="comment">// 增加ns的mounts计数</span></span><br><span class="line">    list_add(&amp;mnt-&gt;mnt_list, &amp;ns-&gt;<span class="built_in">list</span>);  <span class="comment">// 将mnt添加到ns的list中</span></span><br><span class="line"></span><br><span class="line">    err = vfs_path_lookup(m-&gt;mnt_root, m, name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &amp;path);  <span class="comment">// 在m的mnt_root下查找name对应的路径，并将结果保存在path中</span></span><br><span class="line"></span><br><span class="line">    put_mnt_ns(ns);  <span class="comment">// 减少ns的引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err)  <span class="comment">// 如果err不为0</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);  <span class="comment">// 返回错误指针err</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换一个vfsmount引用以获得活动的super_block引用 */</span></span><br><span class="line">    s = path.mnt-&gt;mnt_sb;  <span class="comment">// 获取path对应的super_block结构体指针s</span></span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;s-&gt;s_active);  <span class="comment">// 增加s的s_active计数</span></span><br><span class="line">    mntput(path.mnt);  <span class="comment">// 减少path.mnt的引用计数</span></span><br><span class="line">    <span class="comment">/* 锁定super_block */</span></span><br><span class="line">    down_write(&amp;s-&gt;s_umount);  <span class="comment">// 写锁定s的s_umount信号量</span></span><br><span class="line">    <span class="comment">/* 返回(sub)tree的根节点 */</span></span><br><span class="line">    <span class="keyword">return</span> *kernel_dev;  <span class="comment">// 返回kernel_dev指针</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *options;</span><br><span class="line"></span><br><span class="line">    kernel_type = copy_mount_string(type);  <span class="comment">// 复制type字符串到kernel_type</span></span><br><span class="line">    ret = PTR_ERR(kernel_type);  <span class="comment">// 将kernel_type转换为错误码并赋值给ret</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kernel_type))  <span class="comment">// 如果kernel_type是一个错误指针</span></span><br><span class="line">        <span class="keyword">goto</span> out_type;  <span class="comment">// 跳转到out_type标签处</span></span><br><span class="line"></span><br><span class="line">    kernel_dev = copy_mount_string(dev_name);  <span class="comment">// 复制dev_name字符串到kernel_dev</span></span><br><span class="line">    ret = PTR_ERR(kernel_dev);  <span class="comment">// 将kernel_dev转换为错误码并赋值给ret</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(kernel_dev))  <span class="comment">// 如果kernel_dev是一个错误指针</span></span><br><span class="line">        <span class="keyword">goto</span> out_dev;  <span class="comment">// 跳转到out_dev标签处</span></span><br><span class="line"></span><br><span class="line">    options = copy_mount_options(data);  <span class="comment">// 复制data字符串到options</span></span><br><span class="line">    ret = PTR_ERR(options);  <span class="comment">// 将options转换为错误码并赋值给ret</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(options))  <span class="comment">// 如果options是一个错误指针</span></span><br><span class="line">        <span class="keyword">goto</span> out_data;  <span class="comment">// 跳转到out_data标签处</span></span><br><span class="line"></span><br><span class="line">    ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);  <span class="comment">// 执行挂载操作</span></span><br><span class="line"></span><br><span class="line">    kfree(options);  <span class="comment">// 释放options的内存</span></span><br><span class="line">out_data:</span><br><span class="line">    kfree(kernel_dev);  <span class="comment">// 释放kernel_dev的内存</span></span><br><span class="line">out_dev:</span><br><span class="line">    kfree(kernel_type);  <span class="comment">// 释放kernel_type的内存</span></span><br><span class="line">out_type:</span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回ret</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSMOUNT_VALID_FLAGS                                                    \</span></span><br><span class="line"><span class="meta">    (MOUNT_ATTR_RDONLY | MOUNT_ATTR_NOSUID | MOUNT_ATTR_NODEV |            \</span></span><br><span class="line"><span class="meta">     MOUNT_ATTR_NOEXEC | MOUNT_ATTR__ATIME | MOUNT_ATTR_NODIRATIME |       \</span></span><br><span class="line"><span class="meta">     MOUNT_ATTR_NOSYMFOLLOW)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOUNT_SETATTR_VALID_FLAGS (FSMOUNT_VALID_FLAGS | MOUNT_ATTR_IDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOUNT_SETATTR_PROPAGATION_FLAGS \</span></span><br><span class="line"><span class="meta">    (MS_UNBINDABLE | MS_PRIVATE | MS_SLAVE | MS_SHARED)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">attr_flags_to_mnt_flags</span><span class="params">(u64 attr_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mnt_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr_flags &amp; MOUNT_ATTR_RDONLY)</span><br><span class="line">        mnt_flags |= MNT_READONLY;  <span class="comment">// 如果attr_flags中包含MOUNT_ATTR_RDONLY标志位，则将MNT_READONLY标志位加入mnt_flags</span></span><br><span class="line">    <span class="keyword">if</span> (attr_flags &amp; MOUNT_ATTR_NOSUID)</span><br><span class="line">        mnt_flags |= MNT_NOSUID;  <span class="comment">// 如果attr_flags中包含MOUNT_ATTR_NOSUID标志位，则将MNT_NOSUID标志位加入mnt_flags</span></span><br><span class="line">    <span class="keyword">if</span> (attr_flags &amp; MOUNT_ATTR_NODEV)</span><br><span class="line">        mnt_flags |= MNT_NODEV;  <span class="comment">// 如果attr_flags中包含MOUNT_ATTR_NODEV标志位，则将MNT_NODEV标志位加入mnt_flags</span></span><br><span class="line">    <span class="keyword">if</span> (attr_flags &amp; MOUNT_ATTR_NOEXEC)</span><br><span class="line">        mnt_flags |= MNT_NOEXEC;  <span class="comment">// 如果attr_flags中包含MOUNT_ATTR_NOEXEC标志位，则将MNT_NOEXEC标志位加入mnt_flags</span></span><br><span class="line">    <span class="keyword">if</span> (attr_flags &amp; MOUNT_ATTR_NODIRATIME)</span><br><span class="line">        mnt_flags |= MNT_NODIRATIME;  <span class="comment">// 如果attr_flags中包含MOUNT_ATTR_NODIRATIME标志位，则将MNT_NODIRATIME标志位加入mnt_flags</span></span><br><span class="line">    <span class="keyword">if</span> (attr_flags &amp; MOUNT_ATTR_NOSYMFOLLOW)</span><br><span class="line">        mnt_flags |= MNT_NOSYMFOLLOW;  <span class="comment">// 如果attr_flags中包含MOUNT_ATTR_NOSYMFOLLOW标志位，则将MNT_NOSYMFOLLOW标志位加入mnt_flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mnt_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为一个新的、准备好的超级块（由fs_fd指定）创建一个内核挂载表示，并附加到类似于open_tree的文件描述符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE3(fsmount, <span class="type">int</span>, fs_fd, <span class="type">unsigned</span> <span class="type">int</span>, flags,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span>, attr_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span>;</span>  <span class="comment">// 指向mnt_namespace结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>;</span>  <span class="comment">// 指向fs_context结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>  <span class="comment">// 指向file结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">newmount</span>;</span>  <span class="comment">// 指向path结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span>  <span class="comment">// 指向mount结构体的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span>;</span>  <span class="comment">// fd结构体</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mnt_flags = <span class="number">0</span>;  <span class="comment">// 挂载标志</span></span><br><span class="line">    <span class="type">long</span> ret;  <span class="comment">// 返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!may_mount())  <span class="comment">// 检查是否有挂载权限</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; ~(FSMOUNT_CLOEXEC)) != <span class="number">0</span>)  <span class="comment">// 检查flags是否合法</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attr_flags &amp; ~FSMOUNT_VALID_FLAGS)  <span class="comment">// 检查attr_flags是否合法</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    mnt_flags = attr_flags_to_mnt_flags(attr_flags);  <span class="comment">// 将attr_flags转换为mnt_flags</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (attr_flags &amp; MOUNT_ATTR__ATIME) &#123;  <span class="comment">// 根据attr_flags的ATIME位进行判断</span></span><br><span class="line">        <span class="keyword">case</span> MOUNT_ATTR_STRICTATIME:  <span class="comment">// 如果是STRICTATIME</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MOUNT_ATTR_NOATIME:  <span class="comment">// 如果是NOATIME</span></span><br><span class="line">            mnt_flags |= MNT_NOATIME;  <span class="comment">// 设置mnt_flags的MNT_NOATIME位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MOUNT_ATTR_RELATIME:  <span class="comment">// 如果是RELATIME</span></span><br><span class="line">            mnt_flags |= MNT_RELATIME;  <span class="comment">// 设置mnt_flags的MNT_RELATIME位</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;  <span class="comment">// 其他情况返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f = fdget(fs_fd);  <span class="comment">// 获取文件描述符对应的文件</span></span><br><span class="line">    <span class="keyword">if</span> (!f.file)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;  <span class="comment">// 如果文件不存在，返回错误</span></span><br><span class="line"></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (f.file-&gt;f_op != &amp;fscontext_fops)  <span class="comment">// 检查文件操作是否正确</span></span><br><span class="line">        <span class="keyword">goto</span> err_fsfd;</span><br><span class="line"></span><br><span class="line">    fc = f.file-&gt;private_data;  <span class="comment">// 获取文件的私有数据</span></span><br><span class="line"></span><br><span class="line">    ret = mutex_lock_interruptible(&amp;fc-&gt;uapi_mutex);  <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err_fsfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 必须有一个有效的超级块才能进行挂载 */</span></span><br><span class="line">    ret = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!fc-&gt;root)</span><br><span class="line">        <span class="keyword">goto</span> err_unlock;</span><br><span class="line"></span><br><span class="line">    ret = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (mount_too_revealing(fc-&gt;root-&gt;d_sb, &amp;mnt_flags)) &#123;  <span class="comment">// 检查挂载是否过于暴露</span></span><br><span class="line">        pr_warn(<span class="string">&quot;VFS: Mount too revealing\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = -EBUSY;</span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;phase != FS_CONTEXT_AWAITING_MOUNT)  <span class="comment">// 检查挂载阶段是否正确</span></span><br><span class="line">        <span class="keyword">goto</span> err_unlock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fc-&gt;sb_flags &amp; SB_MANDLOCK)  <span class="comment">// 检查超级块标志是否包含SB_MANDLOCK</span></span><br><span class="line">        warn_mandlock();  <span class="comment">// 发出警告</span></span><br><span class="line"></span><br><span class="line">    newmount.mnt = vfs_create_mount(fc);  <span class="comment">// 创建挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(newmount.mnt)) &#123;</span><br><span class="line">        ret = PTR_ERR(newmount.mnt);</span><br><span class="line">        <span class="keyword">goto</span> err_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    newmount.dentry = dget(fc-&gt;root);  <span class="comment">// 获取根目录的dentry</span></span><br><span class="line">    newmount.mnt-&gt;mnt_flags = mnt_flags;  <span class="comment">// 设置挂载点的mnt_flags</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 完成挂载操作后，将文件上下文设置为类似于fspick()的状态。</span></span><br><span class="line"><span class="comment">     * 此时不希望进行任何内存分配等操作，因为不希望处理任何可能发生的错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vfs_clean_context(fc);</span><br><span class="line"></span><br><span class="line">    ns = alloc_mnt_ns(current-&gt;nsproxy-&gt;mnt_ns-&gt;user_ns, <span class="literal">true</span>);  <span class="comment">// 分配mnt_namespace结构体</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ns)) &#123;</span><br><span class="line">        ret = PTR_ERR(ns);</span><br><span class="line">        <span class="keyword">goto</span> err_path;</span><br><span class="line">    &#125;</span><br><span class="line">    mnt = real_mount(newmount.mnt);  <span class="comment">// 获取实际的mount结构体</span></span><br><span class="line">    mnt-&gt;mnt_ns = ns;  <span class="comment">// 设置mnt_namespace</span></span><br><span class="line">    ns-&gt;root = mnt;</span><br><span class="line">    ns-&gt;mounts = <span class="number">1</span>;</span><br><span class="line">    list_add(&amp;mnt-&gt;mnt_list, &amp;ns-&gt;<span class="built_in">list</span>);</span><br><span class="line">    mntget(newmount.mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用O_PATH标志打开一个表面上的文件描述符，并标记需要卸载而不仅仅是释放 */</span></span><br><span class="line">    file = dentry_open(&amp;newmount, O_PATH, fc-&gt;cred);  <span class="comment">// 打开文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file)) &#123;</span><br><span class="line">        dissolve_on_fput(newmount.mnt);</span><br><span class="line">        ret = PTR_ERR(file);</span><br><span class="line">        <span class="keyword">goto</span> err_path;</span><br><span class="line">    &#125;</span><br><span class="line">    file-&gt;f_mode |= FMODE_NEED_UNMOUNT;  <span class="comment">// 设置文件模式的FMODE_NEED_UNMOUNT位</span></span><br><span class="line"></span><br><span class="line">    ret = get_unused_fd_flags((flags &amp; FSMOUNT_CLOEXEC) ? O_CLOEXEC : <span class="number">0</span>);  <span class="comment">// 获取未使用的文件描述符</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>)</span><br><span class="line">        fd_install(ret, file);  <span class="comment">// 安装文件描述符</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fput(file);</span><br><span class="line"></span><br><span class="line">err_path:</span><br><span class="line">    path_put(&amp;newmount);</span><br><span class="line">err_unlock:</span><br><span class="line">    mutex_unlock(&amp;fc-&gt;uapi_mutex);</span><br><span class="line">err_fsfd:</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将一个挂载点从一个位置移动到另一个位置。与fsopen()/fsmount()结合使用，用于安装新的挂载点，</span></span><br><span class="line"><span class="comment"> * 与open_tree(OPEN_TREE_CLONE [| AT_RECURSIVE])结合使用，可以用于复制挂载子树。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，flags值是MOVE_MOUNT_*标志的组合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE5(move_mount, <span class="comment">// 定义名为move_mount的系统调用，接受5个参数</span></span><br><span class="line">        <span class="type">int</span>, from_dfd, <span class="type">const</span> <span class="type">char</span> __user *, from_pathname, <span class="comment">// 源文件描述符和路径名</span></span><br><span class="line">        <span class="type">int</span>, to_dfd, <span class="type">const</span> <span class="type">char</span> __user *, to_pathname, <span class="comment">// 目标文件描述符和路径名</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>, flags) <span class="comment">// 移动挂载点的标志</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">from_path</span>, <span class="title">to_path</span>;</span> <span class="comment">// 定义源路径和目标路径的结构体</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lflags; <span class="comment">// 查找标志</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>; <span class="comment">// 返回值，默认为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!may_mount()) <span class="comment">// 检查是否具有挂载权限</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM; <span class="comment">// 没有权限则返回EPERM错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~MOVE_MOUNT__MASK) <span class="comment">// 检查flags是否包含无效的标志位</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL; <span class="comment">// 包含无效标志位则返回EINVAL错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果有人提供了路径名，则不允许从需要卸载的文件描述符移动，</span></span><br><span class="line"><span class="comment">     * 因为我们无法访问标志以在之后清除它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lflags = <span class="number">0</span>; <span class="comment">// 初始化查找标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOVE_MOUNT_F_SYMLINKS)    lflags |= LOOKUP_FOLLOW; <span class="comment">// 如果flags包含MOVE_MOUNT_F_SYMLINKS标志，则设置查找标志为LOOKUP_FOLLOW</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOVE_MOUNT_F_AUTOMOUNTS)    lflags |= LOOKUP_AUTOMOUNT; <span class="comment">// 如果flags包含MOVE_MOUNT_F_AUTOMOUNTS标志，则设置查找标志为LOOKUP_AUTOMOUNT</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOVE_MOUNT_F_EMPTY_PATH)    lflags |= LOOKUP_EMPTY; <span class="comment">// 如果flags包含MOVE_MOUNT_F_EMPTY_PATH标志，则设置查找标志为LOOKUP_EMPTY</span></span><br><span class="line"></span><br><span class="line">    ret = user_path_at(from_dfd, from_pathname, lflags, &amp;from_path); <span class="comment">// 获取源路径的struct path结构</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret; <span class="comment">// 获取失败则返回错误码</span></span><br><span class="line"></span><br><span class="line">    lflags = <span class="number">0</span>; <span class="comment">// 初始化查找标志</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOVE_MOUNT_T_SYMLINKS)    lflags |= LOOKUP_FOLLOW; <span class="comment">// 如果flags包含MOVE_MOUNT_T_SYMLINKS标志，则设置查找标志为LOOKUP_FOLLOW</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOVE_MOUNT_T_AUTOMOUNTS)    lflags |= LOOKUP_AUTOMOUNT; <span class="comment">// 如果flags包含MOVE_MOUNT_T_AUTOMOUNTS标志，则设置查找标志为LOOKUP_AUTOMOUNT</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOVE_MOUNT_T_EMPTY_PATH)    lflags |= LOOKUP_EMPTY; <span class="comment">// 如果flags包含MOVE_MOUNT_T_EMPTY_PATH标志，则设置查找标志为LOOKUP_EMPTY</span></span><br><span class="line"></span><br><span class="line">    ret = user_path_at(to_dfd, to_pathname, lflags, &amp;to_path); <span class="comment">// 获取目标路径的struct path结构</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_from; <span class="comment">// 获取失败则跳转到out_from标签处进行清理操作</span></span><br><span class="line"></span><br><span class="line">    ret = security_move_mount(&amp;from_path, &amp;to_path); <span class="comment">// 进行安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out_to; <span class="comment">// 安全检查失败则跳转到out_to标签处进行清理操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MOVE_MOUNT_SET_GROUP)</span><br><span class="line">        ret = do_set_group(&amp;from_path, &amp;to_path); <span class="comment">// 如果flags包含MOVE_MOUNT_SET_GROUP标志，则设置源路径和目标路径的组</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = do_move_mount(&amp;from_path, &amp;to_path); <span class="comment">// 否则进行挂载点的移动操作</span></span><br><span class="line"></span><br><span class="line">out_to:</span><br><span class="line">    path_put(&amp;to_path); <span class="comment">// 释放目标路径结构的引用计数</span></span><br><span class="line">out_from:</span><br><span class="line">    path_put(&amp;from_path); <span class="comment">// 释放源路径结构的引用计数</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回操作结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果路径从根目录可达，则返回true</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * namespace_sem或mount_lock被持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_path_reachable</span><span class="params">(<span class="keyword">struct</span> mount *mnt, <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="keyword">struct</span> path *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (&amp;mnt-&gt;mnt != root-&gt;mnt &amp;&amp; mnt_has_parent(mnt)) &#123;</span><br><span class="line">        dentry = mnt-&gt;mnt_mountpoint;  <span class="comment">// 更新dentry为当前挂载点的dentry</span></span><br><span class="line">        mnt = mnt-&gt;mnt_parent;  <span class="comment">// 更新mnt为当前挂载点的父挂载点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mnt-&gt;mnt == root-&gt;mnt &amp;&amp; is_subdir(dentry, root-&gt;dentry);  <span class="comment">// 判断是否可达根目录并且是子目录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 判断path1是否在path2下面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">path_is_under</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path1, <span class="type">const</span> <span class="keyword">struct</span> path *path2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> res;</span><br><span class="line">    read_seqlock_excl(&amp;mount_lock);  <span class="comment">// 获取mount_lock的读锁</span></span><br><span class="line">    res = is_path_reachable(real_mount(path1-&gt;mnt), path1-&gt;dentry, path2);  <span class="comment">// 调用is_path_reachable函数判断路径是否可达</span></span><br><span class="line">    read_sequnlock_excl(&amp;mount_lock);  <span class="comment">// 释放mount_lock的读锁</span></span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">// 返回判断结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(path_is_under);  <span class="comment">// 导出path_is_under函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pivot_root Semantics:</span></span><br><span class="line"><span class="comment"> * Moves the root file system of the current process to the directory put_old,</span></span><br><span class="line"><span class="comment"> * makes new_root as the new root file system of the current process, and sets</span></span><br><span class="line"><span class="comment"> * root/cwd of all processes which had them on the current root to new_root.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Restrictions:</span></span><br><span class="line"><span class="comment"> * The new_root and put_old must be directories, and  must not be on the</span></span><br><span class="line"><span class="comment"> * same file  system as the current process root. The put_old  must  be</span></span><br><span class="line"><span class="comment"> * underneath new_root,  i.e. adding a non-zero number of /.. to the string</span></span><br><span class="line"><span class="comment"> * pointed to by put_old must yield the same directory as new_root. No other</span></span><br><span class="line"><span class="comment"> * file system may be mounted on put_old. After all, new_root is a mountpoint.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also, the current root cannot be on the &#x27;rootfs&#x27; (initial ramfs) filesystem.</span></span><br><span class="line"><span class="comment"> * See Documentation/filesystems/ramfs-rootfs-initramfs.rst for alternatives</span></span><br><span class="line"><span class="comment"> * in this situation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notes:</span></span><br><span class="line"><span class="comment"> *  - we don&#x27;t move root/cwd if they are not at the root (reason: if something</span></span><br><span class="line"><span class="comment"> *    cared enough to change them, it&#x27;s probably wrong to force them elsewhere)</span></span><br><span class="line"><span class="comment"> *  - it&#x27;s okay to pick a root that isn&#x27;t the root of a file system, e.g.</span></span><br><span class="line"><span class="comment"> *    /nfs/my_root where /nfs is the mount point. It must be a mountpoint,</span></span><br><span class="line"><span class="comment"> *    though, so you may need to say mount --bind /nfs/my_root /nfs/my_root</span></span><br><span class="line"><span class="comment"> *    first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(pivot_root, <span class="type">const</span> <span class="type">char</span> __user *, new_root,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> __user *, put_old)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">new</span>, <span class="title">old</span>, <span class="title">root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">new_mnt</span>, *<span class="title">root_mnt</span>, *<span class="title">old_mnt</span>, *<span class="title">root_parent</span>, *<span class="title">ex_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">old_mp</span>, *<span class="title">root_mp</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!may_mount())</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    error = user_path_at(AT_FDCWD, new_root,</span><br><span class="line">                 LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &amp;new);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out0;</span><br><span class="line"></span><br><span class="line">    error = user_path_at(AT_FDCWD, put_old,</span><br><span class="line">                 LOOKUP_FOLLOW | LOOKUP_DIRECTORY, &amp;old);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line"></span><br><span class="line">    error = security_sb_pivotroot(&amp;old, &amp;new);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line"></span><br><span class="line">    get_fs_root(current-&gt;fs, &amp;root);</span><br><span class="line">    old_mp = lock_mount(&amp;old);</span><br><span class="line">    error = PTR_ERR(old_mp);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(old_mp))</span><br><span class="line">        <span class="keyword">goto</span> out3;</span><br><span class="line"></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    new_mnt = real_mount(new.mnt);</span><br><span class="line">    root_mnt = real_mount(root.mnt);</span><br><span class="line">    old_mnt = real_mount(old.mnt);</span><br><span class="line">    ex_parent = new_mnt-&gt;mnt_parent;</span><br><span class="line">    root_parent = root_mnt-&gt;mnt_parent;</span><br><span class="line">    <span class="keyword">if</span> (IS_MNT_SHARED(old_mnt) ||</span><br><span class="line">        IS_MNT_SHARED(ex_parent) ||</span><br><span class="line">        IS_MNT_SHARED(root_parent))</span><br><span class="line">        <span class="keyword">goto</span> out4;</span><br><span class="line">    <span class="keyword">if</span> (!check_mnt(root_mnt) || !check_mnt(new_mnt))</span><br><span class="line">        <span class="keyword">goto</span> out4;</span><br><span class="line">    <span class="keyword">if</span> (new_mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED)</span><br><span class="line">        <span class="keyword">goto</span> out4;</span><br><span class="line">    error = -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (d_unlinked(new.dentry))</span><br><span class="line">        <span class="keyword">goto</span> out4;</span><br><span class="line">    error = -EBUSY;</span><br><span class="line">    <span class="keyword">if</span> (new_mnt == root_mnt || old_mnt == root_mnt)</span><br><span class="line">        <span class="keyword">goto</span> out4; <span class="comment">/* loop, on the same file system  */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (root.mnt-&gt;mnt_root != root.dentry)</span><br><span class="line">        <span class="keyword">goto</span> out4; <span class="comment">/* not a mountpoint */</span></span><br><span class="line">    <span class="keyword">if</span> (!mnt_has_parent(root_mnt))</span><br><span class="line">        <span class="keyword">goto</span> out4; <span class="comment">/* not attached */</span></span><br><span class="line">    <span class="keyword">if</span> (new.mnt-&gt;mnt_root != new.dentry)</span><br><span class="line">        <span class="keyword">goto</span> out4; <span class="comment">/* not a mountpoint */</span></span><br><span class="line">    <span class="keyword">if</span> (!mnt_has_parent(new_mnt))</span><br><span class="line">        <span class="keyword">goto</span> out4; <span class="comment">/* not attached */</span></span><br><span class="line">    <span class="comment">/* make sure we can reach put_old from new_root */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_path_reachable(old_mnt, old.dentry, &amp;new))</span><br><span class="line">        <span class="keyword">goto</span> out4;</span><br><span class="line">    <span class="comment">/* make certain new is below the root */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_path_reachable(new_mnt, new.dentry, &amp;root))</span><br><span class="line">        <span class="keyword">goto</span> out4;</span><br><span class="line">    lock_mount_hash();</span><br><span class="line">    umount_mnt(new_mnt);</span><br><span class="line">    root_mp = unhash_mnt(root_mnt);  <span class="comment">/* we&#x27;ll need its mountpoint */</span></span><br><span class="line">    <span class="keyword">if</span> (root_mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED) &#123;</span><br><span class="line">        new_mnt-&gt;mnt.mnt_flags |= MNT_LOCKED;</span><br><span class="line">        root_mnt-&gt;mnt.mnt_flags &amp;= ~MNT_LOCKED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* mount old root on put_old */</span></span><br><span class="line">    attach_mnt(root_mnt, old_mnt, old_mp);</span><br><span class="line">    <span class="comment">/* mount new_root on / */</span></span><br><span class="line">    attach_mnt(new_mnt, root_parent, root_mp);</span><br><span class="line">    mnt_add_count(root_parent, <span class="number">-1</span>);</span><br><span class="line">    touch_mnt_namespace(current-&gt;nsproxy-&gt;mnt_ns);</span><br><span class="line">    <span class="comment">/* A moved mount should not expire automatically */</span></span><br><span class="line">    list_del_init(&amp;new_mnt-&gt;mnt_expire);</span><br><span class="line">    put_mountpoint(root_mp);</span><br><span class="line">    unlock_mount_hash();</span><br><span class="line">    chroot_fs_refs(&amp;root, &amp;new);</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line">out4:</span><br><span class="line">    unlock_mount(old_mp);</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        mntput_no_expire(ex_parent);</span><br><span class="line">out3:</span><br><span class="line">    path_put(&amp;root);</span><br><span class="line">out2:</span><br><span class="line">    path_put(&amp;old);</span><br><span class="line">out1:</span><br><span class="line">    path_put(&amp;new);</span><br><span class="line">out0:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">recalc_flags</span><span class="params">(<span class="keyword">struct</span> mount_kattr *kattr, <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags = mnt-&gt;mnt.mnt_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 要清除的标志位 */</span></span><br><span class="line">    flags &amp;= ~kattr-&gt;attr_clr;</span><br><span class="line">    <span class="comment">/* 要设置的标志位 */</span></span><br><span class="line">    flags |= kattr-&gt;attr_set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">can_idmap_mount</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mount_kattr *kattr, <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">m</span> =</span> &amp;mnt-&gt;mnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">fs_userns</span> =</span> m-&gt;mnt_sb-&gt;s_user_ns;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kattr-&gt;mnt_idmap)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 使用文件系统范围的id映射创建id映射的挂载点没有意义，因此阻止该操作。</span></span><br><span class="line"><span class="comment">     * 我们不允许模糊的语义。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!check_fsmapping(kattr-&gt;mnt_idmap, m-&gt;mnt_sb))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 一旦挂载点进行了id映射，就不允许更改其映射关系。</span></span><br><span class="line"><span class="comment">     * 这样可以简化事情，调用者可以创建另一个绑定挂载点来进行id映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (is_idmapped_mnt(m))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 底层文件系统尚不支持id映射的挂载点。 */</span></span><br><span class="line">    <span class="keyword">if</span> (!(m-&gt;mnt_sb-&gt;s_type-&gt;fs_flags &amp; FS_ALLOW_IDMAP))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们没有控制超级块的权限。 */</span></span><br><span class="line">    <span class="keyword">if</span> (!ns_capable(fs_userns, CAP_SYS_ADMIN))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 挂载点已经在文件系统层次结构中可见。 */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_anon_ns(mnt-&gt;mnt_ns))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mnt_allow_writers() - 检查属性更改是否允许写入操作</span></span><br><span class="line"><span class="comment"> * @kattr: 新的挂载属性</span></span><br><span class="line"><span class="comment"> * @mnt: 将应用@kattr的挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 检查@kattr中的新挂载属性是否允许并发写入操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：如果需要保持写入操作，则返回true；否则返回false。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mnt_allow_writers</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mount_kattr *kattr,</span></span><br><span class="line"><span class="params">                                     <span class="type">const</span> <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (!(kattr-&gt;attr_set &amp; MNT_READONLY) ||</span><br><span class="line">            (mnt-&gt;mnt.mnt_flags &amp; MNT_READONLY)) &amp;&amp;</span><br><span class="line">           !kattr-&gt;mnt_idmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mount_setattr_prepare</span><span class="params">(<span class="keyword">struct</span> mount_kattr *kattr, <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历挂载点链表</span></span><br><span class="line">    <span class="keyword">for</span> (m = mnt; m; m = next_mnt(m, mnt)) &#123;</span><br><span class="line">        <span class="comment">// 检查是否可以更改挂载点的标志位</span></span><br><span class="line">        <span class="keyword">if</span> (!can_change_locked_flags(m, recalc_flags(kattr, m))) &#123;</span><br><span class="line">            err = -EPERM;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否可以进行id映射</span></span><br><span class="line">        err = can_idmap_mount(kattr, m);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否允许写入操作</span></span><br><span class="line">        <span class="keyword">if</span> (!mnt_allow_writers(kattr, m)) &#123;</span><br><span class="line">            err = mnt_hold_writers(m);</span><br><span class="line">            <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不需要递归处理，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!kattr-&gt;recurse)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果调用了mnt_hold_writers()，则在mnt_flags中设置了MNT_WRITE_HOLD标志位。</span></span><br><span class="line"><span class="comment">         * 循环将所有挂载点的MNT_WRITE_HOLD标志位取消，并且需要包括第一个挂载点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (p = mnt; p; p = next_mnt(p, mnt)) &#123;</span><br><span class="line">            <span class="comment">// 如果之前调用了mnt_hold_writers()，则解除阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD)</span><br><span class="line">                mnt_unhold_writers(p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 当第一个被更改的挂载点的MNT_WRITE_HOLD标志位被取消后，循环结束。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (p == m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_idmap_mount</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mount_kattr *kattr, <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果没有设置mnt_idmap，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!kattr-&gt;mnt_idmap)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 与mnt_idmap()中的smp_load_acquire()配对使用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 由于我们只允许一个挂载点更改id映射，并且在can_idmap_mount()中进行了验证，</span></span><br><span class="line"><span class="comment">     * 我们知道该挂载点已经附加了@nop_mnt_idmap。因此，不需要释放任何引用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_store_release(&amp;mnt-&gt;mnt.mnt_idmap, mnt_idmap_get(kattr-&gt;mnt_idmap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mount_setattr_commit</span><span class="params">(<span class="keyword">struct</span> mount_kattr *kattr, <span class="keyword">struct</span> mount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历挂载点链表</span></span><br><span class="line">    <span class="keyword">for</span> (m = mnt; m; m = next_mnt(m, mnt)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行id映射操作</span></span><br><span class="line">        do_idmap_mount(kattr, m);</span><br><span class="line">        <span class="comment">// 重新计算标志位</span></span><br><span class="line">        flags = recalc_flags(kattr, m);</span><br><span class="line">        <span class="comment">// 使用WRITE_ONCE原子操作设置mnt_flags</span></span><br><span class="line">        WRITE_ONCE(m-&gt;mnt.mnt_flags, flags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前调用了mnt_hold_writers()，则解除阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;mnt.mnt_flags &amp; MNT_WRITE_HOLD)</span><br><span class="line">            mnt_unhold_writers(m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了propagation，则更改挂载点的传播属性</span></span><br><span class="line">        <span class="keyword">if</span> (kattr-&gt;propagation)</span><br><span class="line">            change_mnt_propagation(m, kattr-&gt;propagation);</span><br><span class="line">        <span class="comment">// 如果不需要递归处理，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!kattr-&gt;recurse)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新挂载点命名空间的时间戳</span></span><br><span class="line">    touch_mnt_namespace(mnt-&gt;mnt_ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_mount_setattr</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="keyword">struct</span> mount_kattr *kattr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(path-&gt;mnt);</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果path的dentry不是mnt的根节点，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;dentry != mnt-&gt;mnt.mnt_root)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了mnt_userns，则分配mnt_idmap</span></span><br><span class="line">    <span class="keyword">if</span> (kattr-&gt;mnt_userns) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">mnt_idmap</span>;</span></span><br><span class="line"></span><br><span class="line">        mnt_idmap = alloc_mnt_idmap(kattr-&gt;mnt_userns);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(mnt_idmap))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(mnt_idmap);</span><br><span class="line">        kattr-&gt;mnt_idmap = mnt_idmap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了propagation，则获取namespace_lock</span></span><br><span class="line">    <span class="keyword">if</span> (kattr-&gt;propagation) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 只有在实际更改传播属性时才获取namespace_lock。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        namespace_lock();</span><br><span class="line">        <span class="keyword">if</span> (kattr-&gt;propagation == MS_SHARED) &#123;</span><br><span class="line">            err = invent_group_ids(mnt, kattr-&gt;recurse);</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                namespace_unlock();</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = -EINVAL;</span><br><span class="line">    lock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确保这不是纯粹的VFS内部操作。 */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_mounted(&amp;mnt-&gt;mnt))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果这是一个已附加的挂载点，则确保它位于调用者的挂载命名空间中。</span></span><br><span class="line"><span class="comment">     * 如果不是，则不允许调用者与之交互。</span></span><br><span class="line"><span class="comment">     * 如果这是一个已分离的挂载点，则确保它附加了一个匿名挂载命名空间，即通过OPEN_TREE_CLONE创建。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(mnt_has_parent(mnt) ? check_mnt(mnt) : is_anon_ns(mnt-&gt;mnt_ns)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 首先，我们将挂载树调整为可以无故障更改挂载属性的状态。</span></span><br><span class="line"><span class="comment">     * 如果成功，则提交所有更改；如果失败，则进行清理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    err = mount_setattr_prepare(kattr, mnt);</span><br><span class="line">    <span class="keyword">if</span> (!err)</span><br><span class="line">        mount_setattr_commit(kattr, mnt);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    unlock_mount_hash();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kattr-&gt;propagation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            cleanup_group_ids(mnt, <span class="literal">NULL</span>);</span><br><span class="line">        namespace_unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_mount_idmapped</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mount_attr *attr, <span class="type">size_t</span> usize,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> mount_kattr *kattr, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">mnt_userns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果attr中没有设置MOUNT_ATTR_IDMAP，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!((attr-&gt;attr_set | attr-&gt;attr_clr) &amp; MOUNT_ATTR_IDMAP))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 目前我们不支持清除id映射的挂载点。如果有这样的需求，我们可以重新考虑，</span></span><br><span class="line"><span class="comment">     * 但目前让我们保持简单，不允许清除id映射。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;attr_clr &amp; MOUNT_ATTR_IDMAP)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果userns_fd超过INT_MAX，则返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;userns_fd &gt; INT_MAX)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    file = fget(attr-&gt;userns_fd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否为proc文件系统的命名空间文件</span></span><br><span class="line">    <span class="keyword">if</span> (!proc_ns_file(file)) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out_fput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件对应的命名空间</span></span><br><span class="line">    ns = get_proc_ns(file_inode(file));</span><br><span class="line">    <span class="keyword">if</span> (ns-&gt;ops-&gt;type != CLONE_NEWUSER) &#123;</span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> out_fput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 初始id映射不能用于创建id映射的挂载点。</span></span><br><span class="line"><span class="comment">     * 我们使用初始id映射作为非id映射挂载点的指示器。</span></span><br><span class="line"><span class="comment">     * 它可以作为一个方便的快捷方式传递给了解id映射挂载点的辅助函数。</span></span><br><span class="line"><span class="comment">     * 用户可以创建一个专用的身份映射来实现相同的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mnt_userns = container_of(ns, <span class="keyword">struct</span> user_namespace, ns);</span><br><span class="line">    <span class="keyword">if</span> (mnt_userns == &amp;init_user_ns) &#123;</span><br><span class="line">        err = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> out_fput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们不控制目标命名空间。 */</span></span><br><span class="line">    <span class="keyword">if</span> (!ns_capable(mnt_userns, CAP_SYS_ADMIN)) &#123;</span><br><span class="line">        err = -EPERM;</span><br><span class="line">        <span class="keyword">goto</span> out_fput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取mnt_userns的引用</span></span><br><span class="line">    kattr-&gt;mnt_userns = get_user_ns(mnt_userns);</span><br><span class="line"></span><br><span class="line">out_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_mount_kattr</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> mount_attr *attr, <span class="type">size_t</span> usize,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> mount_kattr *kattr, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置lookup_flags，默认为LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = LOOKUP_AUTOMOUNT | LOOKUP_FOLLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据flags的值修改lookup_flags</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AT_NO_AUTOMOUNT)</span><br><span class="line">        lookup_flags &amp;= ~LOOKUP_AUTOMOUNT;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AT_SYMLINK_NOFOLLOW)</span><br><span class="line">        lookup_flags &amp;= ~LOOKUP_FOLLOW;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AT_EMPTY_PATH)</span><br><span class="line">        lookup_flags |= LOOKUP_EMPTY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将lookup_flags赋值给kattr的lookup_flags成员</span></span><br><span class="line">    *kattr = (<span class="keyword">struct</span> mount_kattr) &#123;</span><br><span class="line">        .lookup_flags = lookup_flags,</span><br><span class="line">        .recurse = !!(flags &amp; AT_RECURSIVE),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查attr的propagation字段是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;propagation &amp; ~MOUNT_SETATTR_PROPAGATION_FLAGS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">// 检查attr的propagation字段是否只有一个标志位被设置</span></span><br><span class="line">    <span class="keyword">if</span> (hweight32(attr-&gt;propagation &amp; MOUNT_SETATTR_PROPAGATION_FLAGS) &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    <span class="comment">// 将attr的propagation字段赋值给kattr的propagation成员</span></span><br><span class="line">    kattr-&gt;propagation = attr-&gt;propagation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查attr的attr_set和attr_clr字段是否合法</span></span><br><span class="line">    <span class="keyword">if</span> ((attr-&gt;attr_set | attr-&gt;attr_clr) &amp; ~MOUNT_SETATTR_VALID_FLAGS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将attr的attr_set字段转换为mnt_flags，并赋值给kattr的attr_set成员</span></span><br><span class="line">    kattr-&gt;attr_set = attr_flags_to_mnt_flags(attr-&gt;attr_set);</span><br><span class="line">    <span class="comment">// 将attr的attr_clr字段转换为mnt_flags，并赋值给kattr的attr_clr成员</span></span><br><span class="line">    kattr-&gt;attr_clr = attr_flags_to_mnt_flags(attr-&gt;attr_clr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 由于MOUNT_ATTR_&lt;atime&gt;的值是一个枚举类型，而不是位图，</span></span><br><span class="line"><span class="comment">     * 所以想要切换到不同的atime设置的用户不能仅在attr_set中指定atime设置，</span></span><br><span class="line"><span class="comment">     * 还必须在attr_clr字段中指定MOUNT_ATTR__ATIME。</span></span><br><span class="line"><span class="comment">     * 因此，确保MOUNT_ATTR__ATIME不能在attr_clr中部分设置，</span></span><br><span class="line"><span class="comment">     * 并且如果attr_clr中没有设置MOUNT_ATTR__ATIME，则attr_set中不能设置任何atime位。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;attr_clr &amp; MOUNT_ATTR__ATIME) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((attr-&gt;attr_clr &amp; MOUNT_ATTR__ATIME) != MOUNT_ATTR__ATIME)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 清除所有先前的时间设置，因为它们是互斥的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kattr-&gt;attr_clr |= MNT_RELATIME | MNT_NOATIME;</span><br><span class="line">        <span class="keyword">switch</span> (attr-&gt;attr_set &amp; MOUNT_ATTR__ATIME) &#123;</span><br><span class="line">        <span class="keyword">case</span> MOUNT_ATTR_RELATIME:</span><br><span class="line">            kattr-&gt;attr_set |= MNT_RELATIME;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MOUNT_ATTR_NOATIME:</span><br><span class="line">            kattr-&gt;attr_set |= MNT_NOATIME;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MOUNT_ATTR_STRICTATIME:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (attr-&gt;attr_set &amp; MOUNT_ATTR__ATIME)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用build_mount_idmapped函数进行进一步处理</span></span><br><span class="line">    <span class="keyword">return</span> build_mount_idmapped(attr, usize, kattr, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">finish_mount_kattr</span><span class="params">(<span class="keyword">struct</span> mount_kattr *kattr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放kattr的mnt_userns成员</span></span><br><span class="line">    put_user_ns(kattr-&gt;mnt_userns);</span><br><span class="line">    kattr-&gt;mnt_userns = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放kattr的mnt_idmap成员</span></span><br><span class="line">    <span class="keyword">if</span> (kattr-&gt;mnt_idmap)</span><br><span class="line">        mnt_idmap_put(kattr-&gt;mnt_idmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mount_setattr, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, path,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span>, flags, <span class="keyword">struct</span> mount_attr __user *, uattr,</span><br><span class="line">                <span class="type">size_t</span>, usize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">target</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount_kattr</span> <span class="title">kattr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查struct mount_attr的大小是否正确</span></span><br><span class="line">    BUILD_BUG_ON(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mount_attr) != MOUNT_ATTR_SIZE_VER0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查flags是否包含非法标志位</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(AT_EMPTY_PATH |</span><br><span class="line">                  AT_RECURSIVE |</span><br><span class="line">                  AT_SYMLINK_NOFOLLOW |</span><br><span class="line">                  AT_NO_AUTOMOUNT))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查usize是否超过页大小</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(usize &gt; PAGE_SIZE))</span><br><span class="line">        <span class="keyword">return</span> -E2BIG;</span><br><span class="line">    <span class="comment">// 检查usize是否小于MOUNT_ATTR_SIZE_VER0</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(usize &lt; MOUNT_ATTR_SIZE_VER0))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有权限进行挂载操作</span></span><br><span class="line">    <span class="keyword">if</span> (!may_mount())</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从用户空间复制struct mount_attr到内核空间的attr变量</span></span><br><span class="line">    err = copy_struct_from_user(&amp;attr, <span class="keyword">sizeof</span>(attr), uattr, usize);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果attr的attr_set、attr_clr和propagation字段都为0，则不需要遍历挂载点。 */</span></span><br><span class="line">    <span class="keyword">if</span> (attr.attr_set == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        attr.attr_clr == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        attr.propagation == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建mount_kattr结构体</span></span><br><span class="line">    err = build_mount_kattr(&amp;attr, usize, &amp;kattr, flags);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标路径的struct path</span></span><br><span class="line">    err = user_path_at(dfd, path, kattr.lookup_flags, &amp;target);</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="comment">// 执行挂载属性设置操作</span></span><br><span class="line">        err = do_mount_setattr(&amp;target, &amp;kattr);</span><br><span class="line">        path_put(&amp;target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完成mount_kattr结构体的处理</span></span><br><span class="line">    finish_mount_kattr(&amp;kattr);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">init_mount_tree</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用rootfs_fs_type挂载根文件系统</span></span><br><span class="line">    mnt = vfs_kern_mount(&amp;rootfs_fs_type, <span class="number">0</span>, <span class="string">&quot;rootfs&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(mnt))</span><br><span class="line">        panic(<span class="string">&quot;Can&#x27;t create rootfs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配初始命名空间</span></span><br><span class="line">    ns = alloc_mnt_ns(&amp;init_user_ns, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(ns))</span><br><span class="line">        panic(<span class="string">&quot;Can&#x27;t allocate initial namespace&quot;</span>);</span><br><span class="line">    m = real_mount(mnt);</span><br><span class="line">    m-&gt;mnt_ns = ns;</span><br><span class="line">    ns-&gt;root = m;</span><br><span class="line">    ns-&gt;mounts = <span class="number">1</span>;</span><br><span class="line">    list_add(&amp;m-&gt;mnt_list, &amp;ns-&gt;<span class="built_in">list</span>);</span><br><span class="line">    init_task.nsproxy-&gt;mnt_ns = ns;</span><br><span class="line">    get_mnt_ns(ns);</span><br><span class="line"></span><br><span class="line">    root.mnt = mnt;</span><br><span class="line">    root.dentry = mnt-&gt;mnt_root;</span><br><span class="line">    mnt-&gt;mnt_flags |= MNT_LOCKED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前进程的文件系统根目录和当前工作目录</span></span><br><span class="line">    set_fs_pwd(current-&gt;fs, &amp;root);</span><br><span class="line">    set_fs_root(current-&gt;fs, &amp;root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">mnt_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建mnt_cache内存缓存</span></span><br><span class="line">    mnt_cache = kmem_cache_create(<span class="string">&quot;mnt_cache&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mount),</span><br><span class="line">                                  <span class="number">0</span>, SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配mount_hashtable和mountpoint_hashtable哈希表</span></span><br><span class="line">    mount_hashtable = alloc_large_system_hash(<span class="string">&quot;Mount-cache&quot;</span>,</span><br><span class="line">                                              <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hlist_head),</span><br><span class="line">                                              mhash_entries, <span class="number">19</span>,</span><br><span class="line">                                              HASH_ZERO,</span><br><span class="line">                                              &amp;m_hash_shift, &amp;m_hash_mask, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mountpoint_hashtable = alloc_large_system_hash(<span class="string">&quot;Mountpoint-cache&quot;</span>,</span><br><span class="line">                                                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hlist_head),</span><br><span class="line">                                                   mphash_entries, <span class="number">19</span>,</span><br><span class="line">                                                   HASH_ZERO,</span><br><span class="line">                                                   &amp;mp_hash_shift, &amp;mp_hash_mask, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否成功分配哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (!mount_hashtable || !mountpoint_hashtable)</span><br><span class="line">        panic(<span class="string">&quot;Failed to allocate mount hash table\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化kernfs文件系统</span></span><br><span class="line">    kernfs_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化sysfs文件系统</span></span><br><span class="line">    err = sysfs_init();</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;%s: sysfs_init error: %d\n&quot;</span>,</span><br><span class="line">               __func__, err);</span><br><span class="line">    fs_kobj = kobject_create_and_add(<span class="string">&quot;fs&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fs_kobj)</span><br><span class="line">        printk(KERN_WARNING <span class="string">&quot;%s: kobj create error\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化shmem文件系统</span></span><br><span class="line">    shmem_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化rootfs</span></span><br><span class="line">    init_rootfs();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化挂载树</span></span><br><span class="line">    init_mount_tree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">put_mnt_ns</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果引用计数不为0，则减少引用计数并返回</span></span><br><span class="line">    <span class="keyword">if</span> (!refcount_dec_and_test(&amp;ns-&gt;ns.count))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放挂载点和命名空间</span></span><br><span class="line">    drop_collected_mounts(&amp;ns-&gt;root-&gt;mnt);</span><br><span class="line">    free_mnt_ns(ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载文件系统</span></span><br><span class="line"><span class="keyword">struct</span> vfsmount *<span class="title function_">kern_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用vfs_kern_mount函数挂载文件系统</span></span><br><span class="line">    mnt = vfs_kern_mount(type, SB_KERNMOUNT, type-&gt;name, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果挂载成功</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(mnt)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这是一个长期挂载，直到文件系统注销之前不要释放mnt</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        real_mount(mnt)-&gt;mnt_ns = MNT_NS_INTERNAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mnt;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(kern_mount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载挂载点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kern_unmount</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 释放长期挂载，以便可以释放挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(mnt)) &#123;</span><br><span class="line">        mnt_make_shortterm(mnt);</span><br><span class="line">        synchronize_rcu();<span class="comment">// 同步RCU</span></span><br><span class="line">        mntput(mnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kern_unmount);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量卸载挂载点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kern_unmount_array</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt[], <span class="type">unsigned</span> <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将挂载点设置为短期挂载</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        mnt_make_shortterm(mnt[i]);</span><br><span class="line"></span><br><span class="line">    synchronize_rcu_expedited(); <span class="comment">// 快速同步RCU</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放挂载点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        mntput(mnt[i]);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kern_unmount_array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查挂载点是否属于我们的命名空间</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">our_mnt</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> check_mnt(real_mount(mnt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">current_chrooted</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 当前进程是否具有非标准根目录 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">ns_root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">fs_root</span>;</span></span><br><span class="line">    <span class="type">bool</span> chrooted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查找命名空间的根目录 */</span></span><br><span class="line">    ns_root.mnt = &amp;current-&gt;nsproxy-&gt;mnt_ns-&gt;root-&gt;mnt;</span><br><span class="line">    ns_root.dentry = ns_root.mnt-&gt;mnt_root;</span><br><span class="line">    path_get(&amp;ns_root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环向下遍历，直到找到非挂载点的目录</span></span><br><span class="line">    <span class="keyword">while</span> (d_mountpoint(ns_root.dentry) &amp;&amp; follow_down_one(&amp;ns_root))</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件系统的根目录</span></span><br><span class="line">    get_fs_root(current-&gt;fs, &amp;fs_root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为chroot环境</span></span><br><span class="line">    chrooted = !path_equal(&amp;fs_root, &amp;ns_root);</span><br><span class="line"></span><br><span class="line">    path_put(&amp;fs_root);</span><br><span class="line">    path_put(&amp;ns_root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chrooted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">mnt_already_visible</span><span class="params">(<span class="keyword">struct</span> mnt_namespace *ns,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="keyword">struct</span> super_block *sb,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> *new_mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> new_flags = *new_mnt_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="type">bool</span> visible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    down_read(&amp;namespace_sem);</span><br><span class="line">    lock_ns_list(ns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历命名空间中的挂载点列表</span></span><br><span class="line">    list_for_each_entry(mnt, &amp;ns-&gt;<span class="built_in">list</span>, mnt_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">child</span>;</span></span><br><span class="line">        <span class="type">int</span> mnt_flags;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mnt_is_cursor(mnt))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果挂载的文件系统类型不匹配，则继续下一个挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (mnt-&gt;mnt.mnt_sb-&gt;s_type != sb-&gt;s_type)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果挂载点的根目录不是文件系统的根目录，则该挂载点不是完全可见的 */</span></span><br><span class="line">        <span class="keyword">if</span> (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 获取挂载点的挂载标志 */</span></span><br><span class="line">        mnt_flags = mnt-&gt;mnt.mnt_flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果文件系统的超级块标志中包含只读标志，则在挂载标志中添加只读锁定标志 */</span></span><br><span class="line">        <span class="keyword">if</span> (sb_rdonly(mnt-&gt;mnt.mnt_sb))</span><br><span class="line">            mnt_flags |= MNT_LOCK_READONLY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 验证挂载标志是否与新挂载的标志相等或更加宽松 */</span></span><br><span class="line">        <span class="keyword">if</span> ((mnt_flags &amp; MNT_LOCK_READONLY) &amp;&amp;</span><br><span class="line">            !(new_flags &amp; MNT_READONLY))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> ((mnt_flags &amp; MNT_LOCK_ATIME) &amp;&amp;</span><br><span class="line">            ((mnt_flags &amp; MNT_ATIME_MASK) != (new_flags &amp; MNT_ATIME_MASK)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果存在任何被锁定的子挂载点覆盖除空目录以外的内容，则该挂载点不是完全可见的 */</span></span><br><span class="line">        list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> child-&gt;mnt_mountpoint-&gt;d_inode;</span><br><span class="line">            <span class="comment">/* 只关注被锁定的挂载点 */</span></span><br><span class="line">            <span class="keyword">if</span> (!(child-&gt;mnt.mnt_flags &amp; MNT_LOCKED))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">/* 目录是否永久为空？ */</span></span><br><span class="line">            <span class="keyword">if</span> (!is_empty_dir_inode(inode))</span><br><span class="line">                <span class="keyword">goto</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 保留被锁定的属性 */</span></span><br><span class="line">        *new_mnt_flags |= mnt_flags &amp; (MNT_LOCK_READONLY | \</span><br><span class="line">                                       MNT_LOCK_ATIME);</span><br><span class="line">        visible = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">goto</span> found;</span><br><span class="line">    next:;</span><br><span class="line">    &#125;</span><br><span class="line">found:</span><br><span class="line">    unlock_ns_list(ns);</span><br><span class="line">    up_read(&amp;namespace_sem);</span><br><span class="line">    <span class="keyword">return</span> visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">mount_too_revealing</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> super_block *sb, <span class="type">int</span> *new_mnt_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> required_iflags = SB_I_NOEXEC | SB_I_NODEV;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">ns</span> =</span> current-&gt;nsproxy-&gt;mnt_ns;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s_iflags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果命名空间的用户命名空间是初始用户命名空间，则不会过度暴露</span></span><br><span class="line">    <span class="keyword">if</span> (ns-&gt;user_ns == &amp;init_user_ns)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 文件系统是否可能过度暴露？ */</span></span><br><span class="line">    s_iflags = sb-&gt;s_iflags;</span><br><span class="line">    <span class="keyword">if</span> (!(s_iflags &amp; SB_I_USERNS_VISIBLE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查s_iflags是否包含所需的标志位</span></span><br><span class="line">    <span class="keyword">if</span> ((s_iflags &amp; required_iflags) != required_iflags) &#123;</span><br><span class="line">        WARN_ONCE(<span class="number">1</span>, <span class="string">&quot;Expected s_iflags to contain 0x%lx\n&quot;</span>,</span><br><span class="line">                  required_iflags);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !mnt_already_visible(ns, sb, new_mnt_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">mnt_may_suid</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 外部挂载点（通过fchdir或通过/proc符号链接访问）始终被视为nosuid。</span></span><br><span class="line"><span class="comment">     * 这样可以防止命名空间信任可能不安全的suid/sgid位、文件能力或安全标签，</span></span><br><span class="line"><span class="comment">     * 这些都来自其他命名空间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> !(mnt-&gt;mnt_flags &amp; MNT_NOSUID) &amp;&amp; check_mnt(real_mount(mnt)) &amp;&amp;</span><br><span class="line">           current_in_userns(mnt-&gt;mnt_sb-&gt;s_user_ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> ns_common *<span class="title function_">mntns_get</span><span class="params">(<span class="keyword">struct</span> task_struct *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ns_common</span> *<span class="title">ns</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nsproxy</span> *<span class="title">nsproxy</span>;</span></span><br><span class="line"></span><br><span class="line">    task_lock(task);</span><br><span class="line">    nsproxy = task-&gt;nsproxy;</span><br><span class="line">    <span class="keyword">if</span> (nsproxy) &#123;</span><br><span class="line">        ns = &amp;nsproxy-&gt;mnt_ns-&gt;ns;</span><br><span class="line">        get_mnt_ns(to_mnt_ns(ns));</span><br><span class="line">    &#125;</span><br><span class="line">    task_unlock(task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ns;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/08/13/%E5%AD%A6%E4%B9%A0-Linux-fs-dcache-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="学习 Linux /fs/dcache.c源码分析">
      <i class="fa fa-chevron-left"></i> 学习 Linux /fs/dcache.c源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/23/Rust%E5%AD%A6%E4%B9%A0-%E7%BB%83%E4%B9%A01-%E5%8F%98%E9%87%8F%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%A7%A3%E6%9E%84/" rel="next" title="Rust学习 练习1 变量绑定与解构">
      Rust学习 练习1 变量绑定与解构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plucky</p>
  <div class="site-description" itemprop="description">记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Plucky923" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Plucky923" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:p1ucky@163.com" title="E-Mail → mailto:p1ucky@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plucky</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">39:23</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '3420f2814bb4c3c82f84',
      clientSecret: '9d285617447c550188bd893fc3aad7c9b00f2d00',
      repo        : 'Blog-talk',
      owner       : 'Plucky923',
      admin       : ['Plucky923'],
      id          : 'a0223caaa6ae1e28910d04bae24b1edb',
        language: 'zh-CH',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
