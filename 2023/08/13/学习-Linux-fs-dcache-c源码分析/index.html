<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071">
<meta property="og:type" content="article">
<meta property="og:title" content="学习 Linux &#x2F;fs&#x2F;dcache.c源码分析">
<meta property="og:url" content="http://example.com/2023/08/13/%E5%AD%A6%E4%B9%A0-Linux-fs-dcache-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Plucky">
<meta property="og:description" content="dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.7) - Bootlin 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-08-13T07:04:17.000Z">
<meta property="article:modified_time" content="2023-08-17T04:04:27.441Z">
<meta property="article:author" content="Plucky">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/08/13/%E5%AD%A6%E4%B9%A0-Linux-fs-dcache-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>学习 Linux /fs/dcache.c源码分析 | Plucky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Plucky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Comfortably Numb</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/13/%E5%AD%A6%E4%B9%A0-Linux-fs-dcache-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习 Linux /fs/dcache.c源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-13 15:04:17" itemprop="dateCreated datePublished" datetime="2023-08-13T15:04:17+08:00">2023-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-17 12:04:27" itemprop="dateModified" datetime="2023-08-17T12:04:27+08:00">2023-08-17</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>88k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2:40</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.3.7/source/fs/dcache.c">dcache.c - fs&#x2F;dcache.c - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPDX-License-Identifier: GPL-2.0-only</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- fs/dcache.c</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 完全重新实现</span></span><br><span class="line"><span class="comment">- (C) 1997 Thomas Schoebel-Theuer,</span></span><br><span class="line"><span class="comment">- Linus Torvalds做了大量改动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 分配策略注释:</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- dcache是icache的主人 - 当一个dcache条目存在时,</span></span><br><span class="line"><span class="comment">- inode总是会存在。当dcache条目被删除或垃圾回收时会调用&quot;iput()&quot;。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ratelimit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fscrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fsnotify.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/hash.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cache.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/export.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/security.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seqlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/memblock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/bit_spinlock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rculist_bl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list_lru.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;internal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mount.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 使用方法:</span></span><br><span class="line"><span class="comment">- dcache-&gt;d_inode-&gt;i_lock 保护:</span></span><br><span class="line"><span class="comment">- - i_dentry, d_u.d_alias, 别名的d_inode</span></span><br><span class="line"><span class="comment">- dcache_hash_bucket锁保护:</span></span><br><span class="line"><span class="comment">- - dcache哈希表</span></span><br><span class="line"><span class="comment">- s_roots bl链表自旋锁保护:</span></span><br><span class="line"><span class="comment">- - s_roots列表(__d_drop)</span></span><br><span class="line"><span class="comment">- dentry-&gt;d_sb-&gt;s_dentry_lru_lock保护:</span></span><br><span class="line"><span class="comment">- - dcache LRU列表和计数器</span></span><br><span class="line"><span class="comment">- d_lock保护:</span></span><br><span class="line"><span class="comment">- - d_flags</span></span><br><span class="line"><span class="comment">- - d_name</span></span><br><span class="line"><span class="comment">- - d_lru</span></span><br><span class="line"><span class="comment">- - d_count</span></span><br><span class="line"><span class="comment">- - d_unhashed()</span></span><br><span class="line"><span class="comment">- - d_parent和d_subdirs</span></span><br><span class="line"><span class="comment">- - 子节点的d_child和d_parent</span></span><br><span class="line"><span class="comment">- - d_u.d_alias, d_inode</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 顺序:</span></span><br><span class="line"><span class="comment">- dentry-&gt;d_inode-&gt;i_lock</span></span><br><span class="line"><span class="comment">- dentry-&gt;d_lock</span></span><br><span class="line"><span class="comment">  dentry-&gt;d_sb-&gt;s_dentry_lru_lock</span></span><br><span class="line"><span class="comment">  dcache_hash_bucket锁</span></span><br><span class="line"><span class="comment">  s_roots锁</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 如果存在祖先关系:</span></span><br><span class="line"><span class="comment">- dentry-&gt;d_parent-&gt;...-&gt;d_parent-&gt;d_lock</span></span><br><span class="line"><span class="comment">- ...</span></span><br><span class="line"><span class="comment">  dentry-&gt;d_parent-&gt;d_lock</span></span><br><span class="line"><span class="comment">  dentry-&gt;d_lock</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 如果没有祖先关系:</span></span><br><span class="line"><span class="comment">- 任意顺序,因为它在rename_lock上序列化</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sysctl_vfs_cache_pressure __read_mostly = <span class="number">100</span>;</span><br><span class="line">EXPORT_SYMBOL_GPL(sysctl_vfs_cache_pressure); <span class="comment">//导出只读变量sysctl_vfs_cache_pressure给GPL模块</span></span><br><span class="line"></span><br><span class="line">__cacheline_aligned_in_smp <span class="title function_">DEFINE_SEQLOCK</span><span class="params">(rename_lock)</span>; <span class="comment">//定义一个序列锁rename_lock,在SMP系统中缓存对齐</span></span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(rename_lock); <span class="comment">//导出rename_lock变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">dentry_cache</span> __<span class="title">read_mostly</span>;</span> <span class="comment">//定义一个静态的dentry缓存指针,只读</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">empty_name</span> =</span> QSTR_INIT(<span class="string">&quot;&quot;</span>, <span class="number">0</span>); <span class="comment">//定义一个空名的静态const结构体qstr</span></span><br><span class="line">EXPORT_SYMBOL(empty_name); <span class="comment">//导出empty_name</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">slash_name</span> =</span> QSTR_INIT(<span class="string">&quot;/&quot;</span>, <span class="number">1</span>); <span class="comment">//定义一个&quot;/&quot;名的静态const结构体qstr</span></span><br><span class="line">EXPORT_SYMBOL(slash_name); <span class="comment">//导出slash_name </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">dotdot_name</span> =</span> QSTR_INIT(<span class="string">&quot;..&quot;</span>, <span class="number">2</span>); <span class="comment">//定义一个&quot;..&quot;名的静态const结构体qstr</span></span><br><span class="line">EXPORT_SYMBOL(dotdot_name); <span class="comment">//导出dotdot_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这是关于dcache最关键的数据结构:用于查找的哈希表。</span></span><br><span class="line"><span class="comment">* 有人应该试着使这个变好 - 我只是使它可用。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这个散列函数试图避免损失过多的散列信息</span></span><br><span class="line"><span class="comment">* 又避免使用素数散列大小或类似的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> d_hash_shift __read_mostly; <span class="comment">//定义一个静态的散列偏移量,只读</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">dentry_hashtable</span> __<span class="title">read_mostly</span>;</span> <span class="comment">//定义一个静态的dentry哈希表指针,只读</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hlist_bl_head *<span class="title function_">d_hash</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> dentry_hashtable + (hash &gt;&gt; d_hash_shift); <span class="comment">//计算并返回散列桶的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN_LOOKUP_SHIFT 10</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> <span class="title">in_lookup_hashtable</span>[1 &lt;</span>&lt; IN_LOOKUP_SHIFT]; <span class="comment">//定义一个在查找时使用的哈希表</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hlist_bl_head *<span class="title function_">in_lookup_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dentry *parent,</span></span><br><span class="line"><span class="params">                   <span class="type">unsigned</span> <span class="type">int</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line"> hash += (<span class="type">unsigned</span> <span class="type">long</span>) parent / L1_CACHE_BYTES; <span class="comment">//增加父目录的影响</span></span><br><span class="line"> <span class="keyword">return</span> in_lookup_hashtable + hash_32(hash, IN_LOOKUP_SHIFT); <span class="comment">//计算并返回散列桶的地址  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_stat_t</span> &#123;</span> <span class="comment">//定义一个dentry统计结构体</span></span><br><span class="line"> <span class="type">long</span> nr_dentry; </span><br><span class="line"> <span class="type">long</span> nr_unused;</span><br><span class="line"> <span class="type">long</span> age_limit;        <span class="comment">/* age in seconds */</span></span><br><span class="line"> <span class="type">long</span> want_pages;        <span class="comment">/* pages requested by system */</span></span><br><span class="line"> <span class="type">long</span> nr_negative;        <span class="comment">/* # of unused negative dentries */</span></span><br><span class="line"> <span class="type">long</span> dummy;            <span class="comment">/* Reserved for future use */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="type">long</span>, nr_dentry)</span>; <span class="comment">//定义一个每个CPU一个的dentry计数器</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="type">long</span>, nr_dentry_unused)</span>; <span class="comment">//定义一个每个CPU一个的未使用dentry计数器</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="type">long</span>, nr_dentry_negative)</span>; <span class="comment">//定义一个每个CPU一个的负dentry计数器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SYSCTL) &amp;&amp; defined(CONFIG_PROC_FS)</span></span><br><span class="line"><span class="comment">/* 统计收集。*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_stat_t</span> <span class="title">dentry_stat</span> =</span> &#123; </span><br><span class="line"> .age_limit = <span class="number">45</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 这里我们采用自己的计数器而不是使用通用的每个CPU计数器</span></span><br><span class="line"><span class="comment">* 以保持与vfs inode代码所做的一致。通过拥有自己的专用计数器,我们期望</span></span><br><span class="line"><span class="comment">* 收获更好的代码和性能。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 请注意,循环是在所有可能的CPU上完成的,而不是在所有在线CPU上。</span></span><br><span class="line"><span class="comment">* 做这个的原因是我们不想玩CPU开关的游戏。如果其中一个关闭了,我们</span></span><br><span class="line"><span class="comment">* 将只保留它们的计数器。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* glommer:有关详细信息,请参见cffbc8a,如果您打算对此进行更改,</span></span><br><span class="line"><span class="comment">* 请更新所有与之匹配的vfs计数器。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">get_nr_dentry</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">   for_each_possible_cpu(i) <span class="comment">//循环每个可能的CPU</span></span><br><span class="line">       sum += per_cpu(nr_dentry, i); <span class="comment">//累加各个CPU上的dentry计数</span></span><br><span class="line">   <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? <span class="number">0</span> : sum; <span class="comment">//返回总和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">get_nr_dentry_unused</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">   for_each_possible_cpu(i) <span class="comment">//循环每个可能的CPU</span></span><br><span class="line">       sum += per_cpu(nr_dentry_unused, i); <span class="comment">//累加各个CPU上的未使用dentry计数</span></span><br><span class="line">   <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? <span class="number">0</span> : sum; <span class="comment">//返回总和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">get_nr_dentry_negative</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   for_each_possible_cpu(i) <span class="comment">//循环每个可能的CPU</span></span><br><span class="line">       sum += per_cpu(nr_dentry_negative, i); <span class="comment">//累加各个CPU上的负dentry计数</span></span><br><span class="line">   <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? <span class="number">0</span> : sum; <span class="comment">//返回总和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">proc_nr_dentry</span><span class="params">(<span class="keyword">struct</span> ctl_table *table, <span class="type">int</span> write, <span class="type">void</span> *buffer,</span></span><br><span class="line"><span class="params">             <span class="type">size_t</span> *lenp, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">   dentry_stat.nr_dentry = get_nr_dentry(); <span class="comment">//获得dentry总数</span></span><br><span class="line">   dentry_stat.nr_unused = get_nr_dentry_unused(); <span class="comment">//获得未使用dentry数</span></span><br><span class="line">   dentry_stat.nr_negative = get_nr_dentry_negative(); <span class="comment">//获得负dentry数</span></span><br><span class="line">   <span class="keyword">return</span> proc_doulongvec_minmax(table, write, buffer, lenp, ppos); <span class="comment">//写入proc文件系统</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">fs_dcache_sysctls</span>[] =</span> &#123; <span class="comment">//定义dcache的sysctl表</span></span><br><span class="line">   &#123;</span><br><span class="line">       .procname    = <span class="string">&quot;dentry-state&quot;</span>, <span class="comment">//表项名</span></span><br><span class="line">       .data        = &amp;dentry_stat, <span class="comment">//表项数据</span></span><br><span class="line">       .maxlen        = <span class="number">6</span>*<span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="comment">//表项数据最大长度</span></span><br><span class="line">       .mode        = <span class="number">0444</span>, <span class="comment">//表项权限</span></span><br><span class="line">       .proc_handler    = proc_nr_dentry, <span class="comment">//表项处理函数</span></span><br><span class="line">   &#125;,</span><br><span class="line">   &#123; &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_fs_dcache_sysctls</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">   register_sysctl_init(<span class="string">&quot;fs&quot;</span>, fs_dcache_sysctls); <span class="comment">//注册dcache的sysctl表</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(init_fs_dcache_sysctls); <span class="comment">//模块初始化t++;</span></span><br><span class="line">       tcount--;</span><br><span class="line">   &#125; <span class="keyword">while</span> (tcount);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 比较两个名字字符串,如果匹配返回0,否则非0。</span></span><br><span class="line"><span class="comment">* 两个字符串长度都是count字节,count非0。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DCACHE_WORD_ACCESS </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/word-at-a-time.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注意!&#x27;cs&#x27;和&#x27;scount&#x27;来自一个dentry,所以它有对齐的分配</span></span><br><span class="line"><span class="comment">* 对于这个特定的组件。我们不严格需要load_unaligned_zeropad()</span></span><br><span class="line"><span class="comment">* 的安全性,但它也不会有害。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 相比之下,&#x27;ct&#x27;和&#x27;tcount&#x27;可能来自一个路径名,并需要</span></span><br><span class="line"><span class="comment">* 小心的非对齐处理。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dentry_string_cmp</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cs, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *ct, <span class="type">unsigned</span> tcount)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> a,b,mask;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">       a = read_word_at_a_time(cs); <span class="comment">// 一次读一个机器字</span></span><br><span class="line">       b = load_unaligned_zeropad(ct); <span class="comment">//小心地读一个机器字 </span></span><br><span class="line">       <span class="keyword">if</span> (tcount &lt; <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) <span class="comment">//若剩余比较字节数不足一个机器字,则退出循环</span></span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">if</span> (unlikely(a != b)) <span class="comment">//若两个机器字不相等,返回不匹配</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       cs += <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>); </span><br><span class="line">       ct += <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">       tcount -= <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">       <span class="keyword">if</span> (!tcount) <span class="comment">//若已经比较完,返回匹配</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   mask = bytemask_from_count(tcount); <span class="comment">//获得剩余字节掩码</span></span><br><span class="line">   <span class="keyword">return</span> unlikely(!!((a ^ b) &amp; mask)); <span class="comment">//按掩码比较剩余字节</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dentry_string_cmp</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cs, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *ct, <span class="type">unsigned</span> tcount)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (*cs != *ct) <span class="comment">//逐字节比较</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">       cs++;</span><br><span class="line">       ct++;</span><br><span class="line">       tcount--;</span><br><span class="line">   &#125; <span class="keyword">while</span> (tcount);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个内联函数，用于比较目录项的名称</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dentry_cmp</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dentry *dentry, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *ct, <span class="type">unsigned</span> tcount)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在RCU（Read-Copy-Update）遍历过程中，要小心重命名操作的竞态条件；</span></span><br><span class="line"><span class="comment">     * 使用&#x27;READ_ONCE&#x27;来获取名称指针。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 注意！即使由于重命名导致长度不能原子性地加载，我们也不在乎。因为RCU遍历</span></span><br><span class="line"><span class="comment">     * 最终会检查序列计数，并抓住它。并且我们不会超过缓冲区，因为我们以原子方式读取</span></span><br><span class="line"><span class="comment">     * 名称指针，而且目录项名称保证以NUL字节正确终止。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 最终结果：即使&#x27;len&#x27;是错的，我们也会提前退出，因为数据不能匹配（在ct/tcount数据中</span></span><br><span class="line"><span class="comment">     * 不能有NUL）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取目录项的名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cs = READ_ONCE(dentry-&gt;d_name.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用dentry_string_cmp函数比较两个字符串</span></span><br><span class="line">    <span class="keyword">return</span> dentry_string_cmp(cs, ct, tcount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个外部名称结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">external_name</span> &#123;</span></span><br><span class="line">    <span class="comment">// 定义一个联合体，包含一个原子类型的计数器和一个RCU头部</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">atomic_t</span> count;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">head</span>;</span></span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="comment">// 定义一个无符号字符数组来存储名称</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> name[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个内联函数，用于获取目录项的外部名称</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> external_name *<span class="title function_">external_name</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过名称获取外部名称的结构体</span></span><br><span class="line">    <span class="keyword">return</span> container_of(dentry-&gt;d_name.name, <span class="keyword">struct</span> external_name, name[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，用于在RCU回调中释放dentry</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __d_free(<span class="keyword">struct</span> rcu_head *head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取RCU头部所在的dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> container_of(head, <span class="keyword">struct</span> dentry, d_u.d_rcu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用kmem_cache_free函数释放dentry的缓存</span></span><br><span class="line">    kmem_cache_free(dentry_cache, dentry); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，用于在RCU回调中释放含有外部名称的dentry</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __d_free_external(<span class="keyword">struct</span> rcu_head *head)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取RCU头部所在的dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> container_of(head, <span class="keyword">struct</span> dentry, d_u.d_rcu);</span><br><span class="line">    <span class="comment">// 释放外部名称</span></span><br><span class="line">    kfree(external_name(dentry));</span><br><span class="line">    <span class="comment">// 释放dentry的缓存</span></span><br><span class="line">    kmem_cache_free(dentry_cache, dentry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个内联函数，用于判断dentry的名称是否为外部名称</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dname_external</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果dentry的名称不等于内部名称，则返回真（即，名称是外部的）</span></span><br><span class="line">    <span class="keyword">return</span> dentry-&gt;d_name.name != dentry-&gt;d_iname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，用于获取dentry的名称快照</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">take_dentry_name_snapshot</span><span class="params">(<span class="keyword">struct</span> name_snapshot *name, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 锁定dentry</span></span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    <span class="comment">// 将dentry的名称赋值给快照</span></span><br><span class="line">    name-&gt;name = dentry-&gt;d_name;</span><br><span class="line">    <span class="comment">// 如果dentry的名称是外部的</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dname_external(dentry))) &#123;</span><br><span class="line">        <span class="comment">// 增加外部名称的引用计数</span></span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;external_name(dentry)-&gt;u.count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果dentry的名称是内部的，将名称复制到快照的内联名称中</span></span><br><span class="line">        <span class="built_in">memcpy</span>(name-&gt;inline_name, dentry-&gt;d_iname,</span><br><span class="line">               <span class="comment">// 复制dentry的内部名称到快照的内联名称中，长度为dentry名称的长度加1（加上结束符）</span></span><br><span class="line">               dentry-&gt;d_name.len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置快照的名称为快照的内联名称</span></span><br><span class="line">        name-&gt;name.name = name-&gt;inline_name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解锁dentry</span></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出take_dentry_name_snapshot函数，使其可以在内核的其他模块中使用</span></span><br><span class="line">EXPORT_SYMBOL(take_dentry_name_snapshot);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">release_dentry_name_snapshot</span><span class="params">(<span class="keyword">struct</span> name_snapshot *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(name-&gt;name.name != name-&gt;inline_name)) &#123;</span><br><span class="line">        <span class="comment">// 如果name-&gt;name.name不等于name-&gt;inline_name，说明name使用了external_name结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">external_name</span> *<span class="title">p</span>;</span></span><br><span class="line">        p = container_of(name-&gt;name.name, <span class="keyword">struct</span> external_name, name[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 通过name-&gt;name.name获取external_name结构的指针p</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(atomic_dec_and_test(&amp;p-&gt;u.count)))</span><br><span class="line">            <span class="comment">// 递减p-&gt;u.count的值，并检查是否为0</span></span><br><span class="line">            kfree_rcu(p, u.head);</span><br><span class="line">            <span class="comment">// 如果p-&gt;u.count为0，则释放p所指向的external_name结构</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(release_dentry_name_snapshot);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __d_set_inode_and_type(<span class="keyword">struct</span> dentry *dentry,</span><br><span class="line">                      <span class="keyword">struct</span> inode *inode,</span><br><span class="line">                      <span class="type">unsigned</span> type_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> flags;</span><br><span class="line"></span><br><span class="line">    dentry-&gt;d_inode = inode;</span><br><span class="line">    flags = READ_ONCE(dentry-&gt;d_flags);</span><br><span class="line">    flags &amp;= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);</span><br><span class="line">    flags |= type_flags;</span><br><span class="line">    smp_store_release(&amp;dentry-&gt;d_flags, flags);</span><br><span class="line">    <span class="comment">// 设置dentry的inode和类型标志</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __d_clear_type_and_inode(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> flags = READ_ONCE(dentry-&gt;d_flags);</span><br><span class="line"></span><br><span class="line">    flags &amp;= ~(DCACHE_ENTRY_TYPE | DCACHE_FALLTHRU);</span><br><span class="line">    WRITE_ONCE(dentry-&gt;d_flags, flags);</span><br><span class="line">    dentry-&gt;d_inode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST)</span><br><span class="line">        this_cpu_inc(nr_dentry_negative);</span><br><span class="line">    <span class="comment">// 清除dentry的类型标志和inode，并根据需要更新计数器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dentry_free</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(!hlist_unhashed(&amp;dentry-&gt;d_u.d_alias));</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dname_external(dentry))) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">external_name</span> *<span class="title">p</span> =</span> external_name(dentry);</span><br><span class="line">        <span class="keyword">if</span> (likely(atomic_dec_and_test(&amp;p-&gt;u.count))) &#123;</span><br><span class="line">            call_rcu(&amp;dentry-&gt;d_u.d_rcu, __d_free_external);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查dentry是否使用了external_name结构，如果是则递减引用计数</span></span><br><span class="line">    <span class="comment">// 如果引用计数为0，则释放external_name结构</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_NORCU)</span><br><span class="line">        __d_free(&amp;dentry-&gt;d_u.d_rcu);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        call_rcu(&amp;dentry-&gt;d_u.d_rcu, __d_free);</span><br><span class="line">    <span class="comment">// 根据dentry的RCU标志，选择立即释放或通过RCU机制释放dentry</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放dentry的inode，如果定义了文件系统的d_iput()操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dentry_unlink_inode</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">    __<span class="title function_">releases</span><span class="params">(dentry-&gt;d_lock)</span></span><br><span class="line">    __<span class="title function_">releases</span><span class="params">(dentry-&gt;d_inode-&gt;i_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">    raw_write_seqcount_begin(&amp;dentry-&gt;d_seq);</span><br><span class="line">    __d_clear_type_and_inode(dentry);</span><br><span class="line">    hlist_del_init(&amp;dentry-&gt;d_u.d_alias);</span><br><span class="line">    raw_write_seqcount_end(&amp;dentry-&gt;d_seq);</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    <span class="keyword">if</span> (!inode-&gt;i_nlink)</span><br><span class="line">        fsnotify_inoderemove(inode);</span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_iput)</span><br><span class="line">        dentry-&gt;d_op-&gt;d_iput(dentry, inode);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iput(inode);</span><br><span class="line">    <span class="comment">// 释放dentry的inode并执行相应的操作（如通知文件系统或释放inode）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当&#x27;d_lru&#x27;条目正在使用时，DCACHE_LRU_LIST位设置为1，</span></span><br><span class="line"><span class="comment"> * 这包括&quot;真正&quot;的每个超级块LRU列表和DCACHE_SHRINK_LIST的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D_FLAG_VERIFY(dentry,x) WARN_ON_ONCE(((dentry)-&gt;d_flags &amp; (DCACHE_LRU_LIST | DCACHE_SHRINK_LIST)) != (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dentry添加到LRU列表中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_lru_add</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将DCACHE_LRU_LIST位设置为1，表示dentry在使用中</span></span><br><span class="line">    dentry-&gt;d_flags |= DCACHE_LRU_LIST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_inc(nr_dentry_unused);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dentry是负的（表示不存在的文件或目录），增加当前CPU的nr_dentry_negative计数器的值</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">        this_cpu_inc(nr_dentry_negative);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向dentry所属的超级块的s_dentry_lru列表添加dentry的d_lru节点</span></span><br><span class="line">    <span class="comment">// 将dentry添加到超级块的LRU列表中</span></span><br><span class="line">    WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从LRU列表中删除dentry</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_lru_del</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为DCACHE_LRU_LIST，表示dentry在LRU列表中</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除DCACHE_LRU_LIST位，表示dentry不再在LRU列表中</span></span><br><span class="line">    dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_dec(nr_dentry_unused);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dentry是负的（表示不存在的文件或目录），减少当前CPU的nr_dentry_negative计数器的值</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">        this_cpu_dec(nr_dentry_negative);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从dentry所属的超级块的s_dentry_lru列表中删除dentry的d_lru节点</span></span><br><span class="line">    <span class="comment">// 从超级块的LRU列表中删除dentry</span></span><br><span class="line">    WARN_ON_ONCE(!list_lru_del(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从收缩列表中删除dentry</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_shrink_del</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为DCACHE_SHRINK_LIST和DCACHE_LRU_LIST，表示dentry在收缩列表中</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从dentry的d_lru节点所在的链表中删除dentry</span></span><br><span class="line">    <span class="comment">// 清除DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry不再在收缩列表和LRU列表中</span></span><br><span class="line">    list_del_init(&amp;dentry-&gt;d_lru);</span><br><span class="line">    dentry-&gt;d_flags &amp;= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_dec(nr_dentry_unused);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dentry添加到收缩列表中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_shrink_add</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将dentry的d_lru节点添加到指定的链表中</span></span><br><span class="line">    list_add(&amp;dentry-&gt;d_lru, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry在收缩列表和LRU列表中</span></span><br><span class="line">    dentry-&gt;d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_inc(nr_dentry_unused);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这些函数只能在全局LR谢谢指正，以下是对每一行代码的注释：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当&#x27;d_lru&#x27;条目正在使用时，DCACHE_LRU_LIST位设置为1，</span></span><br><span class="line"><span class="comment"> * 这包括&quot;真正&quot;的每个超级块LRU列表和DCACHE_SHRINK_LIST的使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> D_FLAG_VERIFY(dentry,x) WARN_ON_ONCE(((dentry)-&gt;d_flags &amp; (DCACHE_LRU_LIST | DCACHE_SHRINK_LIST)) != (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dentry添加到LRU列表中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_lru_add</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将DCACHE_LRU_LIST位设置为1，表示dentry在使用中</span></span><br><span class="line">    dentry-&gt;d_flags |= DCACHE_LRU_LIST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_inc(nr_dentry_unused);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dentry是负的（表示不存在的文件或目录），增加当前CPU的nr_dentry_negative计数器的值</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">        this_cpu_inc(nr_dentry_negative);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向dentry所属的超级块的s_dentry_lru列表添加dentry的d_lru节点</span></span><br><span class="line">    <span class="comment">// 将dentry添加到超级块的LRU列表中</span></span><br><span class="line">    WARN_ON_ONCE(!list_lru_add(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从LRU列表中删除dentry</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_lru_del</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为DCACHE_LRU_LIST，表示dentry在LRU列表中</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除DCACHE_LRU_LIST位，表示dentry不再在LRU列表中</span></span><br><span class="line">    dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_dec(nr_dentry_unused);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dentry是负的（表示不存在的文件或目录），减少当前CPU的nr_dentry_negative计数器的值</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">        this_cpu_dec(nr_dentry_negative);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从dentry所属的超级块的s_dentry_lru列表中删除dentry的d_lru节点</span></span><br><span class="line">    <span class="comment">// 从超级块的LRU列表中删除dentry</span></span><br><span class="line">    WARN_ON_ONCE(!list_lru_del(&amp;dentry-&gt;d_sb-&gt;s_dentry_lru, &amp;dentry-&gt;d_lru));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从收缩列表中删除dentry</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_shrink_del</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为DCACHE_SHRINK_LIST和DCACHE_LRU_LIST，表示dentry在收缩列表中</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从dentry的d_lru节点所在的链表中删除dentry</span></span><br><span class="line">    <span class="comment">// 清除DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry不再在收缩列表和LRU列表中</span></span><br><span class="line">    list_del_init(&amp;dentry-&gt;d_lru);</span><br><span class="line">    dentry-&gt;d_flags &amp;= ~(DCACHE_SHRINK_LIST | DCACHE_LRU_LIST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_dec(nr_dentry_unused);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将dentry添加到收缩列表中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_shrink_add</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保d_flags的值为0，即未设置DCACHE_LRU_LIST和DCACHE_SHRINK_LIST位</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将dentry的d_lru节点添加到指定的链表中</span></span><br><span class="line">    list_add(&amp;dentry-&gt;d_lru, <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置DCACHE_SHRINK_LIST和DCACHE_LRU_LIST位，表示dentry在收缩列表和LRU列表中</span></span><br><span class="line">    dentry-&gt;d_flags |= DCACHE_SHRINK_LIST | DCACHE_LRU_LIST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加当前CPU的nr_dentry_unused计数器的值</span></span><br><span class="line">    this_cpu_inc(nr_dentry_unused);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这些函数只能在全局 LRU 锁定期间调用，即在释放 LRU 列表的回调函数中。</span></span><br><span class="line"><span class="comment"> * 函数 `d_lru_isolate` 将给定的 dentry 从 LRU 列表中移除，而函数 `d_lru_shrink_move` 则将其移动到指定的私有列表中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_lru_isolate</span><span class="params">(<span class="keyword">struct</span> list_lru_one *lru, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保 dentry 的标志位中包含 DCACHE_LRU_LIST</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);</span><br><span class="line">    <span class="comment">// 清除 dentry 的标志位 DCACHE_LRU_LIST</span></span><br><span class="line">    dentry-&gt;d_flags &amp;= ~DCACHE_LRU_LIST;</span><br><span class="line">    <span class="comment">// 减少未使用的 dentry 的计数器</span></span><br><span class="line">    this_cpu_dec(nr_dentry_unused);</span><br><span class="line">    <span class="comment">// 如果 dentry 是负面的（不存在的），则减少负面 dentry 的计数器</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">        this_cpu_dec(nr_dentry_negative);</span><br><span class="line">    <span class="comment">// 将 dentry 从 LRU 列表中隔离出来</span></span><br><span class="line">    list_lru_isolate(lru, &amp;dentry-&gt;d_lru);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_lru_shrink_move</span><span class="params">(<span class="keyword">struct</span> list_lru_one *lru, <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确保 dentry 的标志位中包含 DCACHE_LRU_LIST</span></span><br><span class="line">    D_FLAG_VERIFY(dentry, DCACHE_LRU_LIST);</span><br><span class="line">    <span class="comment">// 将 dentry 的标志位设置为 DCACHE_SHRINK_LIST</span></span><br><span class="line">    dentry-&gt;d_flags |= DCACHE_SHRINK_LIST;</span><br><span class="line">    <span class="comment">// 如果 dentry 是负面的（不存在的），则减少负面 dentry 的计数器</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">        this_cpu_dec(nr_dentry_negative);</span><br><span class="line">    <span class="comment">// 将 dentry 从 LRU 列表中移动到指定的列表中</span></span><br><span class="line">    list_lru_isolate_move(lru, &amp;dentry-&gt;d_lru, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> ___d_drop(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 哈希的 dentry 通常位于 dentry 哈希表中，</span></span><br><span class="line"><span class="comment">     * 但是通过 d_obtain_root 新分配的 dentry 例外，</span></span><br><span class="line"><span class="comment">     * 它们总是 IS_ROOT 的：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(IS_ROOT(dentry)))</span><br><span class="line">        <span class="comment">// 如果 dentry 是根节点，则使用 s_roots 作为哈希表头部</span></span><br><span class="line">        b = &amp;dentry-&gt;d_sb-&gt;s_roots;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，根据 dentry 的哈希值确定哈希表头部</span></span><br><span class="line">        b = d_hash(dentry-&gt;d_name.hash);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对哈希表头部进行加锁</span></span><br><span class="line">    hlist_bl_lock(b);</span><br><span class="line">    <span class="comment">// 从哈希表中删除 dentry</span></span><br><span class="line">    __hlist_bl_del(&amp;dentry-&gt;d_hash);</span><br><span class="line">    <span class="comment">// 解锁哈希表头部</span></span><br><span class="line">    hlist_bl_unlock(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __d_drop(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 dentry 不是未哈希的（已经在哈希表中）</span></span><br><span class="line">    <span class="keyword">if</span> (!d_unhashed(dentry)) &#123;</span><br><span class="line">        <span class="comment">// 执行真正的删除操作</span></span><br><span class="line">        ___d_drop(dentry);</span><br><span class="line">        <span class="comment">// 将 dentry 的 d_hash.pprev 设置为 NULL</span></span><br><span class="line">        dentry-&gt;d_hash.pprev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 使 dentry 的 d_seq 失效</span></span><br><span class="line">        write_seqcount_invalidate(&amp;dentry-&gt;d_seq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__d_drop);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_drop - 删除一个 dentry</span></span><br><span class="line"><span class="comment"> * @dentry: 要删除的 dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * d_drop() 从父级 dentry 的哈希表中取消哈希，这样就无法通过 VFS 查找找到它了。</span></span><br><span class="line"><span class="comment"> * 注意，这与删除 dentry 不同 - d_delete() 会尝试标记 dentry 为负面（negative），</span></span><br><span class="line"><span class="comment"> * 从而进行一次成功的负面查找，而 d_drop() 只会使缓存查找失败。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * d_drop() 主要用于希望出于某种原因使 dentry 失效的操作（如 NFS 超时或 autofs 删除）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_drop 需要 dentry-&gt;d_lock 锁定。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ___d_drop 不标记 dentry 为 &quot;unhashed&quot;</span></span><br><span class="line"><span class="comment"> * （dentry-&gt;d_hash.pprev 将是 LIST_POISON2，而不是 NULL）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_drop</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    __d_drop(dentry);</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_drop);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dentry_unlist</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> dentry *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通知 d_walk() 和 shrink_dentry_list()，我们不再附加到 dentry 树上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dentry-&gt;d_flags |= DCACHE_DENTRY_KILLED;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(list_empty(&amp;dentry-&gt;d_child)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    __list_del_entry(&amp;dentry-&gt;d_child);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 游标可能在子列表中移动。当我们是一个普通的列表成员时，这没关系 -</span></span><br><span class="line"><span class="comment">     * -&gt;d_child.next 将会被更新。然而，从现在开始，它不会被更新，</span></span><br><span class="line"><span class="comment">     * 对于像 d_walk() 这样的函数来说，这可能会导致一个不好的结果。</span></span><br><span class="line"><span class="comment">     * 通常情况下，d_walk() 不关心游标的移动 - 父级的 -&gt;d_lock 会阻止移动，</span></span><br><span class="line"><span class="comment">     * 并且由于游标本身没有子节点，我们可以在不解锁父级的情况下完成遍历。</span></span><br><span class="line"><span class="comment">     * 但是有一个例外 - 如果我们从一个在解锁后立即被删除的子节点上升，</span></span><br><span class="line"><span class="comment">     * 下一个兄弟节点是使用其 -&gt;d_child.next 中的值找到的。</span></span><br><span class="line"><span class="comment">     * 如果 _那个_ 指向一个游标，并且在 d_walk() 重新获得 parent-&gt;d_lock 之前，</span></span><br><span class="line"><span class="comment">     * 游标被移动了（例如通过 lseek()），我们会跳过游标已经移过的所有内容。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 解决方案：确保在 -&gt;d_child.next 中留下的指针指向一个不会移动的东西。</span></span><br><span class="line"><span class="comment">     * 即跳过游标。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (dentry-&gt;d_child.next != &amp;parent-&gt;d_subdirs) &#123;</span><br><span class="line">        next = list_entry(dentry-&gt;d_child.next, <span class="keyword">struct</span> dentry, d_child);</span><br><span class="line">        <span class="keyword">if</span> (likely(!(next-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        dentry-&gt;d_child.next = next-&gt;d_child.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __dentry_kill(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;  <span class="comment">// 初始化父级 dentry 为 NULL</span></span><br><span class="line">    <span class="type">bool</span> can_free = <span class="literal">true</span>;  <span class="comment">// 初始化可以释放标志为 true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ROOT(dentry))</span><br><span class="line">        parent = dentry-&gt;d_parent;  <span class="comment">// 如果不是根节点，则获取父级 dentry</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 现在，dentry 对于系统来说已经是无法恢复的死亡状态。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lockref_mark_dead(&amp;dentry-&gt;d_lockref);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 通过 d_prune 通知文件系统，此 dentry 即将被取消哈希和销毁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_OP_PRUNE)</span><br><span class="line">        dentry-&gt;d_op-&gt;d_prune(dentry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST))</span><br><span class="line">            d_lru_del(dentry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果它在哈希表中，则将其移除 */</span></span><br><span class="line">    __d_drop(dentry);</span><br><span class="line">    dentry_unlist(dentry, parent);</span><br><span class="line">    <span class="keyword">if</span> (parent)</span><br><span class="line">        spin_unlock(&amp;parent-&gt;d_lock);</span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_inode)</span><br><span class="line">        dentry_unlink_inode(dentry);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    this_cpu_dec(nr_dentry);</span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_op &amp;&amp; dentry-&gt;d_op-&gt;d_release)</span><br><span class="line">        dentry-&gt;d_op-&gt;d_release(dentry);</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123;</span><br><span class="line">        dentry-&gt;d_flags |= DCACHE_MAY_FREE;</span><br><span class="line">        can_free = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    <span class="keyword">if</span> (likely(can_free))</span><br><span class="line">        dentry_free(dentry);</span><br><span class="line">    cond_resched();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">lock_parent</span>(<span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    parent = READ_ONCE(dentry-&gt;d_parent);</span><br><span class="line">    spin_lock(&amp;parent-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 我们不能盲目地锁定 dentry，直到确定不会违反锁定顺序。</span></span><br><span class="line"><span class="comment">     * 任何对 dentry-&gt;d_parent 的更改必须在 parent-&gt;d_lock 锁定的情况下完成，</span></span><br><span class="line"><span class="comment">     * 所以上面的 spin_lock() 对于检查它是否仍然是我们的子节点足够了.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(parent != dentry-&gt;d_parent)) &#123;</span><br><span class="line">        spin_unlock(&amp;parent-&gt;d_lock);</span><br><span class="line">        <span class="keyword">goto</span> again;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent != dentry)</span><br><span class="line">        spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> dentry *<span class="title function_">lock_parent</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> dentry-&gt;d_parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ROOT(dentry))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(spin_trylock(&amp;parent-&gt;d_lock)))</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __lock_parent(dentry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">retain_dentry</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查是否在查找过程中</span></span><br><span class="line">    WARN_ON(d_in_lookup(dentry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unreachable? Get rid of it */</span></span><br><span class="line">    <span class="comment">// 如果 dentry 不在哈希表中</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(d_unhashed(dentry)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 dentry 被断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_DISCONNECTED))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果标记为需要执行删除操作</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE)) &#123;</span><br><span class="line">        <span class="comment">// 调用文件系统特定的删除函数</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_op-&gt;d_delete(dentry))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果标记为不缓存</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_DONTCACHE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* retain; LRU fodder */</span></span><br><span class="line">    <span class="comment">// 引用计数减一</span></span><br><span class="line">    dentry-&gt;d_lockref.count--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不在 LRU 列表中</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!(dentry-&gt;d_flags &amp; DCACHE_LRU_LIST)))</span><br><span class="line">        <span class="comment">// 添加到 LRU 列表</span></span><br><span class="line">        d_lru_add(dentry);</span><br><span class="line">    <span class="comment">// 如果没有被引用</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(!(dentry-&gt;d_flags &amp; DCACHE_REFERENCED)))</span><br><span class="line">        <span class="comment">// 标记为已引用</span></span><br><span class="line">        dentry-&gt;d_flags |= DCACHE_REFERENCED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_mark_dontcache</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 inode 的 dentry 链表</span></span><br><span class="line">    hlist_for_each_entry(de, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123;</span><br><span class="line">        spin_lock(&amp;de-&gt;d_lock);</span><br><span class="line">        <span class="comment">// 标记为不缓存</span></span><br><span class="line">        de-&gt;d_flags |= DCACHE_DONTCACHE;</span><br><span class="line">        spin_unlock(&amp;de-&gt;d_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// inode 标记为不缓存</span></span><br><span class="line">    inode-&gt;i_state |= I_DONTCACHE;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_mark_dontcache);  <span class="comment">// 导出符号，供其他模块使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Finish off a dentry we&#x27;ve decided to kill.</span></span><br><span class="line"><span class="comment"> * dentry-&gt;d_lock must be held, returns with it unlocked.</span></span><br><span class="line"><span class="comment"> * Returns dentry requiring refcount drop, or NULL if we&#x27;re done.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">dentry_kill</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">    __<span class="title function_">releases</span><span class="params">(dentry-&gt;d_lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 inode 存在且无法获取锁，则跳转到 slow_positive 标签处</span></span><br><span class="line">    <span class="keyword">if</span> (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock)))</span><br><span class="line">        <span class="keyword">goto</span> slow_positive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ROOT(dentry)) &#123;</span><br><span class="line">        parent = dentry-&gt;d_parent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果无法获取父级 dentry 的锁</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!spin_trylock(&amp;parent-&gt;d_lock))) &#123;</span><br><span class="line">            <span class="comment">// 获取父级 dentry 的锁</span></span><br><span class="line">            parent = __lock_parent(dentry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 inode 存在或者 dentry-&gt;d_inode 为空</span></span><br><span class="line">            <span class="keyword">if</span> (likely(inode || !dentry-&gt;d_inode))</span><br><span class="line">                <span class="keyword">goto</span> got_locks;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// negative that became positive</span></span><br><span class="line">            <span class="keyword">if</span> (parent)</span><br><span class="line">                spin_unlock(&amp;parent-&gt;d_lock);</span><br><span class="line">            inode = dentry-&gt;d_inode;</span><br><span class="line">            <span class="keyword">goto</span> slow_positive;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行真正的 dentry 销毁操作</span></span><br><span class="line">    __dentry_kill(dentry);</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line"></span><br><span class="line">slow_positive:</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取父级 dentry 的锁</span></span><br><span class="line">    parent = lock_parent(dentry);</span><br><span class="line"></span><br><span class="line">got_locks:</span><br><span class="line">    <span class="comment">// 如果 dentry 引用计数不为1</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dentry-&gt;d_lockref.count != <span class="number">1</span>)) &#123;</span><br><span class="line">        dentry-&gt;d_lockref.count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不保留该 dentry</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (likely(!retain_dentry(dentry))) &#123;</span><br><span class="line">        <span class="comment">// 执行真正的 dentry 销毁操作</span></span><br><span class="line">        __dentry_kill(dentry);</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we are keeping it, after all</span></span><br><span class="line">    <span class="keyword">if</span> (inode)</span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    <span class="keyword">if</span> (parent)</span><br><span class="line">        spin_unlock(&amp;parent-&gt;d_lock);</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试无锁的 dput() 操作，并返回是否成功。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不成功，我们返回 false，并已经获取了 dentry 锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者需要持有 RCU 读锁，以确保即使引用计数降至零，dentry 仍然存在！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">fast_dput</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果存在 d_op-&gt;d_delete() 操作，我们不应该让 dentry 计数降至零，因此使用 &quot;put_or_lock&quot;。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_DELETE))</span><br><span class="line">        <span class="keyword">return</span> lockref_put_or_lock(&amp;dentry-&gt;d_lockref);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * .. 否则，我们可以尝试仅仅减少 lockref。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = lockref_put_return(&amp;dentry-&gt;d_lockref);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 lockref_put_return() 由于其他人持有锁而失败，</span></span><br><span class="line"><span class="comment">     * 快速路径失败。我们需要获取锁，然后再次检查计数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ret &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_lockref.count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            dentry-&gt;d_lockref.count--;</span><br><span class="line">            spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果我们不是最后一个引用，我们完成了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 小心，小心。引用计数降至零，但我们没有持有 dentry 锁，</span></span><br><span class="line"><span class="comment">     * 因此其他人可能再次获取它，并进行另一个 dput()，</span></span><br><span class="line"><span class="comment">     * 我们不能与之竞争。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 然而，有一种非常特殊且常见的情况，我们不关心，</span></span><br><span class="line"><span class="comment">     * 因为没有任何操作要执行：dentry 仍然在哈希表中，</span></span><br><span class="line"><span class="comment">     * 没有 &#x27;delete&#x27; 操作，它已经被引用并且已经在 LRU 列表中。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 注意！由于我们没有加锁，这些值不是 &quot;稳定的&quot;。</span></span><br><span class="line"><span class="comment">     * 但是，只要在我们释放引用之后的某个时刻，</span></span><br><span class="line"><span class="comment">     * dentry 被哈希并且标志具有正确的值就足够了。</span></span><br><span class="line"><span class="comment">     * 其他的 dentry 使用者可能重新获取对 dentry 的引用并更改它，</span></span><br><span class="line"><span class="comment">     * 但是我们的工作已经完成 - 我们可以保留具有零引用计数的 dentry。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 然而，有两种情况下我们应该销毁 dentry。</span></span><br><span class="line"><span class="comment">     * 1. 当断开连接的 dentry 的引用计数达到零时，立即释放。</span></span><br><span class="line"><span class="comment">     * 2. 如果不应缓存 dentry，则释放它们。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    smp_rmb();</span><br><span class="line">    d_flags = READ_ONCE(dentry-&gt;d_flags);</span><br><span class="line">    d_flags &amp;= DCACHE_REFERENCED | DCACHE_LRU_LIST |</span><br><span class="line">            DCACHE_DISCONNECTED | DCACHE_DONTCACHE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 没有要执行的操作？释放引用计数就是我们所需要的？ */</span></span><br><span class="line">    <span class="keyword">if</span> (d_flags == (DCACHE_REFERENCED | DCACHE_LRU_LIST) &amp;&amp; !d_unhashed(dentry))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 不是快速常规情况？获取锁。我们已经减少了引用计数，</span></span><br><span class="line"><span class="comment">     * 但在获取锁之后，我们需要重新检查情况。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 是否有其他人在此期间获取了对它的引用，我们不再是最后一个用户？</span></span><br><span class="line"><span class="comment">     * 或者，其他人可能已经销毁它并标记为无效。无论哪种情况，我们都不需要做其他操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_lockref.count) &#123;</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 重新获取我们乐观地释放的引用。我们持有锁，并且刚刚测试过计数为零，因此我们可以将其设置为1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dentry-&gt;d_lockref.count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dput - 释放一个dentry</span></span><br><span class="line"><span class="comment">// @dentry: 要释放的dentry</span></span><br><span class="line"><span class="comment">// 释放一个dentry。这将会降低使用计数，如果适当的话，</span></span><br><span class="line"><span class="comment">// 会调用dentry的unlink方法，同时将其从队列中移除，并释放其资源。</span></span><br><span class="line"><span class="comment">// 如果父dentry也被安排释放，它们也可能现在被删除。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dput</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (dentry) &#123;</span><br><span class="line">        might_sleep();  <span class="comment">// 可能会使当前任务进入睡眠状态</span></span><br><span class="line"></span><br><span class="line">        rcu_read_lock();  <span class="comment">// 读取RCU锁</span></span><br><span class="line">        <span class="keyword">if</span> (likely(fast_dput(dentry))) &#123;  <span class="comment">// 如果能快速释放dentry</span></span><br><span class="line">            rcu_read_unlock();  <span class="comment">// 解锁RCU</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 慢速情况：此时已经持有dentry锁</span></span><br><span class="line">        rcu_read_unlock();  <span class="comment">// 解锁RCU</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(retain_dentry(dentry))) &#123;  <span class="comment">// 如果能保留dentry</span></span><br><span class="line">            spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 解锁dentry</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dentry = dentry_kill(dentry);  <span class="comment">// 杀死dentry</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(dput);  <span class="comment">// 导出dput符号</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __dput_to_list(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> list_head <span class="built_in">list</span>)</span><br><span class="line">__must_hold(&amp;dentry-&gt;d_lock)   <span class="comment">// 必须持有dentry锁</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123;  <span class="comment">// 如果dentry在收缩列表中</span></span><br><span class="line">        --dentry-&gt;d_lockref.count;  <span class="comment">// 减少dentry的锁引用计数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST)  <span class="comment">// 如果dentry在LRU列表中</span></span><br><span class="line">            d_lru_del(dentry);  <span class="comment">// 从LRU列表中删除dentry</span></span><br><span class="line">        <span class="keyword">if</span> (!--dentry-&gt;d_lockref.count)  <span class="comment">// 如果dentry的锁引用计数降为0</span></span><br><span class="line">            d_shrink_add(dentry, <span class="built_in">list</span>);  <span class="comment">// 将dentry添加到收缩列表中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dput_to_list</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_read_lock();  <span class="comment">// 读取RCU锁</span></span><br><span class="line">    <span class="keyword">if</span> (likely(fast_dput(dentry))) &#123;  <span class="comment">// 如果能快速释放dentry</span></span><br><span class="line">        rcu_read_unlock();  <span class="comment">// 解锁RCU</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();  <span class="comment">// 解锁RCU</span></span><br><span class="line">    <span class="keyword">if</span> (!retain_dentry(dentry))  <span class="comment">// 如果不能保留dentry</span></span><br><span class="line">        __dput_to_list(dentry, <span class="built_in">list</span>);  <span class="comment">// 将dentry添加到列表中</span></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 解锁dentry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This must be called with d_lock held */</span></span><br><span class="line"><span class="comment">/* 必须在持有 d_lock 锁的情况下调用 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __dget_dlock(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    dentry-&gt;d_lockref.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __dget(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    lockref_get(&amp;dentry-&gt;d_lockref);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取父目录的 dentry 结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">dget_parent</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> gotref;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">ret</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do optimistic parent lookup without any</span></span><br><span class="line"><span class="comment">     * locking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq); <span class="comment">/* 开始读取序列计数器 */</span></span><br><span class="line">    ret = READ_ONCE(dentry-&gt;d_parent); <span class="comment">/* 读取父目录的 dentry */</span></span><br><span class="line">    gotref = lockref_get_not_zero(&amp;ret-&gt;d_lockref); <span class="comment">/* 获取父目录的引用计数 */</span></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">if</span> (likely(gotref)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) <span class="comment">/* 检查序列计数器是否正确，如果不正确则重试 */</span></span><br><span class="line">            <span class="keyword">return</span> ret; <span class="comment">/* 返回父目录的 dentry */</span></span><br><span class="line">        dput(ret); <span class="comment">/* 减少父目录的引用计数 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Don&#x27;t need rcu_dereference because we re-check it was correct under</span></span><br><span class="line"><span class="comment">     * the lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    ret = dentry-&gt;d_parent; <span class="comment">/* 重新读取父目录的 dentry */</span></span><br><span class="line">    spin_lock(&amp;ret-&gt;d_lock); <span class="comment">/* 获取父目录的锁 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ret != dentry-&gt;d_parent)) &#123; <span class="comment">/* 检查父目录的 dentry 是否发生变化 */</span></span><br><span class="line">        spin_unlock(&amp;ret-&gt;d_lock);</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">goto</span> repeat; <span class="comment">/* 如果发生变化，则重试 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    BUG_ON(!ret-&gt;d_lockref.count); <span class="comment">/* 检查父目录的引用计数是否为零 */</span></span><br><span class="line">    ret-&gt;d_lockref.count++; <span class="comment">/* 增加父目录的引用计数 */</span></span><br><span class="line">    spin_unlock(&amp;ret-&gt;d_lock); <span class="comment">/* 释放父目录的锁 */</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">/* 返回父目录的 dentry */</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(dget_parent); <span class="comment">/* 导出 dget_parent 函数，使其可被其他模块使用 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * __<span class="title">d_find_any_alias</span>(<span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">alias</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hlist_empty(&amp;inode-&gt;i_dentry))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    alias = hlist_entry(inode-&gt;i_dentry.first, <span class="keyword">struct</span> dentry, d_u.d_alias);</span><br><span class="line">    __dget(alias); <span class="comment">/* 增加别名的引用计数 */</span></span><br><span class="line">    <span class="keyword">return</span> alias; <span class="comment">/* 返回别名的 dentry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_find_any_alias - find any alias for a given inode</span></span><br><span class="line"><span class="comment"> * @inode: inode to find an alias for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If any aliases exist for the given inode, take and return a</span></span><br><span class="line"><span class="comment"> * reference for one of them. If no aliases exist, return %NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 查找给定 inode 的任何别名 */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_find_any_alias</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock); <span class="comment">/* 获取 inode 的锁 */</span></span><br><span class="line">    de = __d_find_any_alias(inode); <span class="comment">/* 查找任何别名的 dentry */</span></span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock); <span class="comment">/* 释放 inode 的锁 */</span></span><br><span class="line">    <span class="keyword">return</span> de; <span class="comment">/* 返回找到的别名的 dentry */</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_find_any_alias); <span class="comment">/* 导出 d_find_any_alias 函数，使其可被其他模块使用 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_find_alias</span>(<span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">alias</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">        <span class="keyword">return</span> __d_find_any_alias(inode); <span class="comment">/* 对于目录类型的 inode，查找任何别名的 dentry */</span></span><br><span class="line"></span><br><span class="line">    hlist_for_each_entry(alias, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123;</span><br><span class="line">        spin_lock(&amp;alias-&gt;d_lock); <span class="comment">/* 获取别名的锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (!d_unhashed(alias)) &#123; <span class="comment">/* 检查别名是否已从哈希表中移除 */</span></span><br><span class="line">            __dget_dlock(alias); <span class="comment">/* 增加别名的引用计数 */</span></span><br><span class="line">            spin_unlock(&amp;alias-&gt;d_lock); <span class="comment">/* 释放别名的锁 */</span></span><br><span class="line">            <span class="keyword">return</span> alias; <span class="comment">/* 返回找到的别名的 dentry */</span></span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;alias-&gt;d_lock); <span class="comment">/* 释放别名的锁 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* 如果没有找到任何别名，则返回 NULL */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_find_alias - 获取 inode 的哈希别名</span></span><br><span class="line"><span class="comment"> * @inode: 目标 inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 inode 有一个哈希别名，或者是一个目录并且有任何别名，</span></span><br><span class="line"><span class="comment"> * 获取并返回别名的引用。否则返回 NULL。</span></span><br><span class="line"><span class="comment"> * 注意，如果 inode 是一个目录，它只能有一个别名，</span></span><br><span class="line"><span class="comment"> * 只有当它没有子目录，或者是文件系统的根目录，或者是目录被重命名且 d_revalidate 是第一个 vfs 操作来注意到时，它才能没有哈希别名。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果 inode 有 IS_ROOT、DCACHE_DISCONNECTED 别名，则优先选择其他哈希别名。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_find_alias</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">de</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hlist_empty(&amp;inode-&gt;i_dentry)) &#123;</span><br><span class="line">        spin_lock(&amp;inode-&gt;i_lock); <span class="comment">/* 获取 inode 的锁 */</span></span><br><span class="line">        de = __d_find_alias(inode); <span class="comment">/* 查找 inode 的别名 */</span></span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock); <span class="comment">/* 释放 inode 的锁 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> de; <span class="comment">/* 返回找到的别名的 dentry */</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_find_alias); <span class="comment">/* 导出 d_find_alias 函数，使其可被其他模块使用 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  调用者必须持有 rcu_read_lock()，并确保在 rcu_read_unlock() 之前 inode 不会被释放。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_find_alias_rcu</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> *<span class="title">l</span> =</span> &amp;inode-&gt;i_dentry;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">de</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock); <span class="comment">/* 获取 inode 的锁 */</span></span><br><span class="line">    <span class="comment">// -&gt;i_dentry 和 -&gt;i_rcu 是放在一起的，但只有在设置了 I_FREEING 时才会使用后者，这意味着没有剩余的别名</span></span><br><span class="line">    <span class="keyword">if</span> (likely(!(inode-&gt;i_state &amp; I_FREEING) &amp;&amp; !hlist_empty(l))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">            de = hlist_entry(l-&gt;first, <span class="keyword">struct</span> dentry, d_u.d_alias);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hlist_for_each_entry(de, l, d_u.d_alias)</span><br><span class="line">                <span class="keyword">if</span> (!d_unhashed(de))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock); <span class="comment">/* 释放 inode 的锁 */</span></span><br><span class="line">    <span class="keyword">return</span> de; <span class="comment">/* 返回找到的别名的 dentry */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试清除与该 inode 关联的 dentry。</span></span><br><span class="line"><span class="comment"> * 警告：您必须拥有对 inode 的引用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_prune_aliases</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">restart:</span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock); <span class="comment">/* 获取 inode 的锁 */</span></span><br><span class="line">    hlist_for_each_entry(dentry, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123;</span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock); <span class="comment">/* 获取 dentry 的锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (!dentry-&gt;d_lockref.count) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> lock_parent(dentry); <span class="comment">/* 获取父目录的 dentry */</span></span><br><span class="line">            <span class="keyword">if</span> (likely(!dentry-&gt;d_lockref.count)) &#123;</span><br><span class="line">                __dentry_kill(dentry); <span class="comment">/* 清除 dentry */</span></span><br><span class="line">                dput(parent);</span><br><span class="line">                <span class="keyword">goto</span> restart;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parent)</span><br><span class="line">                spin_unlock(&amp;parent-&gt;d_lock); <span class="comment">/* 释放父目录的锁 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock); <span class="comment">/* 释放 dentry 的锁 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock); <span class="comment">/* 释放 inode 的锁 */</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_prune_aliases); <span class="comment">/* 导出 d_prune_aliases 函数，使其可被其他模块使用 */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a dentry from shrink list.</span></span><br><span class="line"><span class="comment"> * Called under rcu_read_lock() and dentry-&gt;d_lock; the former</span></span><br><span class="line"><span class="comment"> * guarantees that nothing we access will be freed under us.</span></span><br><span class="line"><span class="comment"> * Note that dentry is *not* protected from concurrent dentry_kill(),</span></span><br><span class="line"><span class="comment"> * d_delete(), etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return false if dentry has been disrupted or grabbed, leaving</span></span><br><span class="line"><span class="comment"> * the caller to kick it off-list.  Otherwise, return true and have</span></span><br><span class="line"><span class="comment"> * that dentry&#x27;s inode and parent both locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">shrink_lock_dentry</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查dentry的引用计数是否非零，如果是，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_lockref.count)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    inode = dentry-&gt;d_inode;</span><br><span class="line">    <span class="comment">// 如果dentry的inode存在，并且无法获取inode的自旋锁，则释放dentry的自旋锁，</span></span><br><span class="line">    <span class="comment">// 获取inode的自旋锁，再获取dentry的自旋锁，然后检查dentry的引用计数是否非零，</span></span><br><span class="line">    <span class="comment">// 如果是，则跳转到out标签处，否则检查inode是否发生变化，如果是，则跳转到out标签处</span></span><br><span class="line">    <span class="keyword">if</span> (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock))) &#123;</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dentry-&gt;d_lockref.count))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">/* changed inode means that somebody had grabbed it */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(inode != dentry-&gt;d_inode))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parent = dentry-&gt;d_parent;</span><br><span class="line">    <span class="comment">// 如果dentry是根节点，或者可以获取到父节点的自旋锁，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ROOT(dentry) || likely(spin_trylock(&amp;parent-&gt;d_lock)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    spin_lock(&amp;parent-&gt;d_lock);</span><br><span class="line">    <span class="comment">// 检查父节点是否发生变化，如果是，则释放父节点的自旋锁，获取dentry的自旋锁，然后跳转到out标签处</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(parent != dentry-&gt;d_parent)) &#123;</span><br><span class="line">        spin_unlock(&amp;parent-&gt;d_lock);</span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span><br><span class="line">    <span class="comment">// 检查dentry的引用计数是否非零，如果是，则返回true</span></span><br><span class="line">    <span class="keyword">if</span> (likely(!dentry-&gt;d_lockref.count))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    spin_unlock(&amp;parent-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (inode)</span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shrink_dentry_list</span><span class="params">(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从列表中获取最后一个dentry，并获取其自旋锁</span></span><br><span class="line">        dentry = list_entry(<span class="built_in">list</span>-&gt;prev, <span class="keyword">struct</span> dentry, d_lru);</span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        <span class="comment">// 尝试锁定dentry的inode和父节点，并检查是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (!shrink_lock_dentry(dentry)) &#123;</span><br><span class="line">            <span class="type">bool</span> can_free = <span class="literal">false</span>;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="comment">// 从收缩列表中删除dentry</span></span><br><span class="line">            d_shrink_del(dentry);</span><br><span class="line">            <span class="comment">// 检查dentry的引用计数是否小于0，以及是否可以释放</span></span><br><span class="line">            <span class="keyword">if</span> (dentry-&gt;d_lockref.count &lt; <span class="number">0</span>)</span><br><span class="line">                can_free = dentry-&gt;d_flags &amp; DCACHE_MAY_FREE;</span><br><span class="line">            spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">            <span class="comment">// 如果可以释放，则释放dentry</span></span><br><span class="line">            <span class="keyword">if</span> (can_free)</span><br><span class="line">                dentry_free(dentry);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="comment">// 从收缩列表中删除dentry</span></span><br><span class="line">        d_shrink_del(dentry);</span><br><span class="line">        parent = dentry-&gt;d_parent;</span><br><span class="line">        <span class="comment">// 如果dentry的父节点不是它自己，则将父节点添加回列表中</span></span><br><span class="line">        <span class="keyword">if</span> (parent != dentry)</span><br><span class="line">            __dput_to_list(parent, <span class="built_in">list</span>);</span><br><span class="line">        <span class="comment">// 销毁dentry</span></span><br><span class="line">        __dentry_kill(dentry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">enum</span> lru_status <span class="title function_">dentry_lru_isolate</span><span class="params">(<span class="keyword">struct</span> list_head *item,</span></span><br><span class="line"><span class="params">                                          <span class="keyword">struct</span> list_lru_one *lru, <span class="type">spinlock_t</span> *lru_lock, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">freeable</span> =</span> arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>    *<span class="title">dentry</span> =</span> container_of(item, <span class="keyword">struct</span> dentry, d_lru);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取dentry的锁，如果获取失败则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!spin_trylock(&amp;dentry-&gt;d_lock))</span><br><span class="line">        <span class="keyword">return</span> LRU_SKIP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dentry有引用计数，表示仍在使用中，从LRU中移除</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_lockref.count) &#123;</span><br><span class="line">        d_lru_isolate(lru, dentry);</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        <span class="keyword">return</span> LRU_REMOVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dentry被标记为已引用，则清除标记并进行LRU旋转</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_REFERENCED) &#123;</span><br><span class="line">        dentry-&gt;d_flags &amp;= ~DCACHE_REFERENCED;</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 列表的移动由通用的LRU代码完成。此时，我们已经释放了dentry-&gt;d_lock，</span></span><br><span class="line"><span class="comment">         * 但保持了lru锁。这样做是安全的，因为即使同时持有两个锁，所有的列表移动</span></span><br><span class="line"><span class="comment">         * 都受到lru锁的保护。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这是因为所有的LRU管理函数都通过LRU API调用（如list_lru_add和list_lru_del）</span></span><br><span class="line"><span class="comment">         * 进行中介。此文件中的列表移动只会通过这些函数或通过从LRU API调用的回调函数</span></span><br><span class="line"><span class="comment">         * （如此处的回调函数）进行。 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 唯一的例外是像shrink_dentry_list这样的函数，以及首先检查DCACHE_SHRINK_LIST</span></span><br><span class="line"><span class="comment">         * 标志的代码。这些函数保证只在正确从主列表中隔离后，仅与提供的堆栈列表进行操作。</span></span><br><span class="line"><span class="comment">         * 因此，它始终是局部访问。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> LRU_ROTATE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将dentry移动到可释放列表中</span></span><br><span class="line">    d_lru_shrink_move(lru, dentry, freeable);</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LRU_REMOVED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prune_dcache_sb - 收缩dcache</span></span><br><span class="line"><span class="comment"> * @sb: 超级块</span></span><br><span class="line"><span class="comment"> * @sc: 收缩控制参数，传递给list_lru_shrink_walk()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尝试通过@sc-&gt;nr_to_scan个条目来收缩超级块dcache的LRU。当我们需要更多内存时，</span></span><br><span class="line"><span class="comment"> * 从超级块收缩器函数调用此函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果所有的dentry都在使用中，此函数可能无法释放任何资源。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">prune_dcache_sb</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">    LIST_HEAD(dispose);</span><br><span class="line">    <span class="type">long</span> freed;</span><br><span class="line"></span><br><span class="line">    freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc,</span><br><span class="line">                                 dentry_lru_isolate, &amp;dispose);</span><br><span class="line">    shrink_dentry_list(&amp;dispose);</span><br><span class="line">    <span class="keyword">return</span> freed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> lru_status <span class="title function_">dentry_lru_isolate_shrink</span><span class="params">(<span class="keyword">struct</span> list_head *item,</span></span><br><span class="line"><span class="params">                                                 <span class="keyword">struct</span> list_lru_one *lru, <span class="type">spinlock_t</span> *lru_lock, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">freeable</span> =</span> arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>    *<span class="title">dentry</span> =</span> container_of(item, <span class="keyword">struct</span> dentry, d_lru);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取dentry的锁，如果获取失败则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!spin_trylock(&amp;dentry-&gt;d_lock))</span><br><span class="line">        <span class="keyword">return</span> LRU_SKIP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将dentry移动到可释放列表中</span></span><br><span class="line">    d_lru_shrink_move(lru, dentry, freeable);</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LRU_REMOVED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prune_dcache_sb - 收缩dcache</span></span><br><span class="line"><span class="comment"> * @sb: 超级块</span></span><br><span class="line"><span class="comment"> * @sc: 收缩控制参数，传递给list_lru_shrink_walk()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 尝试通过@sc-&gt;nr_to_scan个条目来收缩超级块dcache的LRU。当我们需要更多内存时，</span></span><br><span class="line"><span class="comment"> * 从超级块收缩器函数调用此函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果所有的dentry都在使用中，此函数可能无法释放任何资源。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">prune_dcache_sb</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个链表头用于存储待释放的dentry</span></span><br><span class="line">    LIST_HEAD(dispose);</span><br><span class="line">    <span class="type">long</span> freed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用list_lru_shrink_walk函数来遍历超级块的dentry LRU列表，并将满足条件的dentry添加到dispose链表中</span></span><br><span class="line">    freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc,</span><br><span class="line">                                 dentry_lru_isolate, &amp;dispose);</span><br><span class="line">    <span class="comment">// 调用shrink_dentry_list函数来释放dispose链表中的dentry资源</span></span><br><span class="line">    shrink_dentry_list(&amp;dispose);</span><br><span class="line">    <span class="keyword">return</span> freed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> lru_status <span class="title function_">dentry_lru_isolate_shrink</span><span class="params">(<span class="keyword">struct</span> list_head *item,</span></span><br><span class="line"><span class="params">                                                 <span class="keyword">struct</span> list_lru_one *lru, <span class="type">spinlock_t</span> *lru_lock, <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将传入的参数转换为对应的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">freeable</span> =</span> arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>    *<span class="title">dentry</span> =</span> container_of(item, <span class="keyword">struct</span> dentry, d_lru);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取dentry的锁，如果获取失败则跳过</span></span><br><span class="line">    <span class="keyword">if</span> (!spin_trylock(&amp;dentry-&gt;d_lock))</span><br><span class="line">        <span class="keyword">return</span> LRU_SKIP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将dentry移动到可释放列表中</span></span><br><span class="line">    d_lru_shrink_move(lru, dentry, freeable);</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LRU_REMOVED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shrink_dcache_sb - 收缩指定超级块的dcache</span></span><br><span class="line"><span class="comment"> * @sb: 超级块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 收缩指定超级块的dcache。在卸载文件系统之前，用于释放dcache。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shrink_dcache_sb</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环执行，直到满足退出条件</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        LIST_HEAD(dispose);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查超级块的dentry LRU列表是否还有剩余的dentry</span></span><br><span class="line">        <span class="keyword">if</span> (list_lru_count(&amp;sb-&gt;s_dentry_lru) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用list_lru_shrink_walk函数来收缩超级块的dcache</span></span><br><span class="line">            <span class="comment">// 将满足条件的dentry添加到dispose链表中</span></span><br><span class="line">            freed = list_lru_shrink_walk(&amp;sb-&gt;s_dentry_lru, sc,</span><br><span class="line">                                         dentry_lru_isolate, &amp;dispose);</span><br><span class="line">            <span class="comment">// 调用shrink_dentry_list函数来释放dispose链表中的dentry资源</span></span><br><span class="line">            shrink_dentry_list(&amp;dispose);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (list_lru_count(&amp;sb-&gt;s_dentry_lru) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出shrink_dcache_sb函数的符号</span></span><br><span class="line">    EXPORT_SYMBOL(shrink_dcache_sb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum d_walk_ret - 树遍历期间的操作</span></span><br><span class="line"><span class="comment"> * @D_WALK_CONTINUE: 继续遍历</span></span><br><span class="line"><span class="comment"> * @D_WALK_QUIT: 终止遍历</span></span><br><span class="line"><span class="comment"> * @D_WALK_NORETRY: 需要重试时终止遍历</span></span><br><span class="line"><span class="comment"> * @D_WALK_SKIP: 跳过当前dentry及其子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">d_walk_ret</span> &#123;</span></span><br><span class="line">    D_WALK_CONTINUE,</span><br><span class="line">    D_WALK_QUIT,</span><br><span class="line">    D_WALK_NORETRY,</span><br><span class="line">    D_WALK_SKIP,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_walk - 遍历dentry树</span></span><br><span class="line"><span class="comment"> * @parent: 遍历的起始dentry</span></span><br><span class="line"><span class="comment"> * @data: 传递给enter()和finish()的数据</span></span><br><span class="line"><span class="comment"> * @enter: 进入dentry时的回调函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在调用enter()回调函数时，会持有d_lock锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_walk</span><span class="params">(<span class="keyword">struct</span> dentry *parent, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                   <span class="keyword">enum</span> d_walk_ret (*enter)(<span class="type">void</span> *, <span class="keyword">struct</span> dentry *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">this_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> seq = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">d_walk_ret</span> <span class="title">ret</span>;</span></span><br><span class="line">    <span class="type">bool</span> retry = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    read_seqbegin_or_lock(&amp;rename_lock, &amp;seq);</span><br><span class="line">    this_parent = parent;</span><br><span class="line">    spin_lock(&amp;this_parent-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    ret = enter(data, this_parent);</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> D_WALK_CONTINUE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> D_WALK_QUIT:</span><br><span class="line">    <span class="keyword">case</span> D_WALK_SKIP:</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    <span class="keyword">case</span> D_WALK_NORETRY:</span><br><span class="line">        retry = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">    next = this_parent-&gt;d_subdirs.next;</span><br><span class="line"></span><br><span class="line">resume:</span><br><span class="line">    <span class="keyword">while</span> (next != &amp;this_parent-&gt;d_subdirs) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">tmp</span> =</span> next;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> list_entry(tmp, <span class="keyword">struct</span> dentry, d_child);</span><br><span class="line">        next = tmp-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_DENTRY_CURSOR))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span><br><span class="line"></span><br><span class="line">        ret = enter(data, dentry);</span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">case</span> D_WALK_CONTINUE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> D_WALK_QUIT:</span><br><span class="line">            spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">            <span class="keyword">goto</span> out_unlock;</span><br><span class="line">        <span class="keyword">case</span> D_WALK_NORETRY:</span><br><span class="line">            retry = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> D_WALK_SKIP:</span><br><span class="line">            spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;dentry-&gt;d_subdirs)) &#123;</span><br><span class="line">            spin_unlock(&amp;this_parent-&gt;d_lock);</span><br><span class="line">            spin_release(&amp;dentry-&gt;d_lock.dep_map, _RET_IP_);</span><br><span class="line">            this_parent = dentry;</span><br><span class="line">            spin_acquire(&amp;this_parent-&gt;d_lock.dep_map, <span class="number">0</span>, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">            <span class="keyword">goto</span> repeat;</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 当前层级遍历完成，向上回溯并继续搜索。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">ascend:</span><br><span class="line">    <span class="keyword">if</span> (this_parent != parent) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">child</span> =</span> this_parent;</span><br><span class="line">        this_parent = child-&gt;d_parent;</span><br><span class="line"></span><br><span class="line">        spin_unlock(&amp;child-&gt;d_lock);</span><br><span class="line">        spin_lock(&amp;this_parent-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果存在重命名操作，可能会回到错误的父节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (need_seqretry(&amp;rename_lock, seq))</span><br><span class="line">            <span class="keyword">goto</span> rename_retry;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 进入下一个仍然存在的兄弟节点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next = child-&gt;d_child.next;</span><br><span class="line">            <span class="keyword">if</span> (next == &amp;this_parent-&gt;d_subdirs)</span><br><span class="line">                <span class="keyword">goto</span> ascend;</span><br><span class="line">            child = list_entry(next, <span class="keyword">struct</span> dentry, d_child);</span><br><span class="line">        &#125; <span class="keyword">while</span> (unlikely(child-&gt;d_flags &amp; DCACHE_DENTRY_KILLED));</span><br><span class="line"></span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">goto</span> resume;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (need_seqretry(&amp;rename_lock, seq))</span><br><span class="line">        <span class="keyword">goto</span> rename_retry;</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock(&amp;this_parent-&gt;d_lock);</span><br><span class="line">    done_seqretry(&amp;rename_lock, seq);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">rename_retry:</span><br><span class="line">    spin_unlock(&amp;this_parent-&gt;d_lock);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    BUG_ON(seq &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!retry)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    seq = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">check_mount</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span>  <span class="comment">// 文件系统挂载点的指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mounted;  <span class="comment">// 表示文件系统是否已挂载的标志位</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> d_walk_ret <span class="title function_">path_check_mount</span><span class="params">(<span class="type">void</span> *data, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">check_mount</span> *<span class="title">info</span> =</span> data;  <span class="comment">// 将传入的data参数转换为check_mount结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span> =</span> &#123; .mnt = info-&gt;mnt, .dentry = dentry &#125;;  <span class="comment">// 创建path结构体，表示文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!d_mountpoint(dentry)))  <span class="comment">// 检查给定的dentry是否为挂载点</span></span><br><span class="line">        <span class="keyword">return</span> D_WALK_CONTINUE;  <span class="comment">// 如果不是挂载点，则继续遍历</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__path_is_mountpoint(&amp;path)) &#123;  <span class="comment">// 检查给定的路径是否为挂载点</span></span><br><span class="line">        info-&gt;mounted = <span class="number">1</span>;  <span class="comment">// 如果是挂载点，则将mounted标志位设置为1</span></span><br><span class="line">        <span class="keyword">return</span> D_WALK_QUIT;  <span class="comment">// 并停止遍历</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> D_WALK_CONTINUE;  <span class="comment">// 如果不是挂载点，则继续遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * path_has_submounts - 检查当前命名空间中的父路径或其子目录是否包含挂载点。</span></span><br><span class="line"><span class="comment"> * @parent: 要检查的路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果父路径或其子目录中包含当前命名空间中的挂载点，则返回true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">path_has_submounts</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">check_mount</span> <span class="title">data</span> =</span> &#123; .mnt = parent-&gt;mnt, .mounted = <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    read_seqlock_excl(&amp;mount_lock);  <span class="comment">// 获取mount_lock的读取锁</span></span><br><span class="line">    d_walk(parent-&gt;dentry, &amp;data, path_check_mount);  <span class="comment">// 遍历父路径的dentry，并检查是否包含挂载点</span></span><br><span class="line">    read_sequnlock_excl(&amp;mount_lock);  <span class="comment">// 释放mount_lock的读取锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data.mounted;  <span class="comment">// 返回是否存在挂载点的标志位</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(path_has_submounts);  <span class="comment">// 导出path_has_submounts符号，使其可在其他模块中使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called by mount code to set a mountpoint and check if the mountpoint is</span></span><br><span class="line"><span class="comment"> * reachable (e.g. NFS can unhash a directory dentry and then the complete</span></span><br><span class="line"><span class="comment"> * subtree can become unreachable).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Only one of d_invalidate() and d_set_mounted() must succeed.  For</span></span><br><span class="line"><span class="comment"> * this reason take rename_lock and d_lock on dentry and ancestors.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">d_set_mounted</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = -ENOENT;</span><br><span class="line">    write_seqlock(&amp;rename_lock);  <span class="comment">// 获取rename_lock的写入锁</span></span><br><span class="line">    <span class="keyword">for</span> (p = dentry-&gt;d_parent; !IS_ROOT(p); p = p-&gt;d_parent) &#123;</span><br><span class="line">        <span class="comment">/* Need exclusion wrt. d_invalidate() */</span></span><br><span class="line">        spin_lock(&amp;p-&gt;d_lock);  <span class="comment">// 获取父dentry的自旋锁</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(d_unhashed(p))) &#123;  <span class="comment">// 检查父dentry是否未哈希</span></span><br><span class="line">            spin_unlock(&amp;p-&gt;d_lock);  <span class="comment">// 如果未哈希，则释放自旋锁</span></span><br><span class="line">            <span class="keyword">goto</span> out;  <span class="comment">// 跳转到out标签处</span></span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;p-&gt;d_lock);  <span class="comment">// 释放父dentry的自旋锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);  <span class="comment">// 获取当前dentry的自旋锁</span></span><br><span class="line">    <span class="keyword">if</span> (!d_unlinked(dentry)) &#123;</span><br><span class="line">        ret = -EBUSY;</span><br><span class="line">        <span class="keyword">if</span> (!d_mountpoint(dentry)) &#123;  <span class="comment">// 检查当前dentry是否为挂载点</span></span><br><span class="line">            dentry-&gt;d_flags |= DCACHE_MOUNTED;  <span class="comment">// 设置当前dentry的挂载标志位</span></span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 释放当前dentry的自旋锁</span></span><br><span class="line">out:</span><br><span class="line">    write_sequnlock(&amp;rename_lock);  <span class="comment">// 释放rename_lock的写入锁</span></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回操作结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Search the dentry child list of the specified parent,</span></span><br><span class="line"><span class="comment"> * and move any unused dentries to the end of the unused</span></span><br><span class="line"><span class="comment"> * list for prune_dcache(). We descend to the next level</span></span><br><span class="line"><span class="comment"> * whenever the d_subdirs list is non-empty and continue</span></span><br><span class="line"><span class="comment"> * searching.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It returns zero iff there are no unused children,</span></span><br><span class="line"><span class="comment"> * otherwise  it returns the number of children moved to</span></span><br><span class="line"><span class="comment"> * the end of the unused list. This may not be the total</span></span><br><span class="line"><span class="comment"> * number of unused children, because select_parent can</span></span><br><span class="line"><span class="comment"> * drop the lock and return early due to latency</span></span><br><span class="line"><span class="comment"> * constraints.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">select_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">start</span>;</span>  <span class="comment">// 起始dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">long</span> found;  <span class="comment">// 找到的未使用的dentry数量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">victim</span>;</span>  <span class="comment">// 待处理的dentry</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dispose</span>;</span>  <span class="comment">// 待处理的dentry链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> d_walk_ret <span class="title function_">select_collect</span><span class="params">(<span class="type">void</span> *_data, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">select_data</span> *<span class="title">data</span> =</span> _data;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">d_walk_ret</span> <span class="title">ret</span> =</span> D_WALK_CONTINUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;start == dentry)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123;  <span class="comment">// 检查dentry是否在收缩列表中</span></span><br><span class="line">        data-&gt;found++;  <span class="comment">// 增加找到的未使用的dentry数量</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST)</span><br><span class="line">            d_lru_del(dentry);  <span class="comment">// 从LRU列表中删除dentry</span></span><br><span class="line">        <span class="keyword">if</span> (!dentry-&gt;d_lockref.count) &#123;  <span class="comment">// 检查dentry的锁引用计数是否为0</span></span><br><span class="line">            d_shrink_add(dentry, &amp;data-&gt;dispose);  <span class="comment">// 将dentry添加到待处理链表中</span></span><br><span class="line">            data-&gt;found++;  <span class="comment">// 增加找到的未使用的dentry数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果我们找到了一些未使用的dentry，我们可以返回给调用者（这确保了前进）。</span></span><br><span class="line"><span class="comment">     * 我们将会回来找到剩下的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;data-&gt;dispose))</span><br><span class="line">        ret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">enum</span> d_walk_ret <span class="title function_">select_collect2</span><span class="params">(<span class="type">void</span> *_data, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个指向 select_data 结构体的指针，并将 _data 强制转换为 select_data 类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">select_data</span> *<span class="title">data</span> =</span> _data;</span><br><span class="line">    <span class="comment">// 定义一个枚举类型的变量 ret，并初始化为 D_WALK_CONTINUE</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">d_walk_ret</span> <span class="title">ret</span> =</span> D_WALK_CONTINUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 data-&gt;start 等于当前遍历到的 dentry，则跳转到 out 标签处</span></span><br><span class="line">    <span class="keyword">if</span> (data-&gt;start == dentry)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 dentry 的 d_flags 中包含 DCACHE_SHRINK_LIST 标志位</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_SHRINK_LIST) &#123;</span><br><span class="line">        <span class="comment">// 如果 dentry 的 d_lockref.count 为 0</span></span><br><span class="line">        <span class="keyword">if</span> (!dentry-&gt;d_lockref.count) &#123;</span><br><span class="line">            <span class="comment">// 获取 RCU 读锁</span></span><br><span class="line">            rcu_read_lock();</span><br><span class="line">            <span class="comment">// 将当前的 dentry 赋值给 data-&gt;victim</span></span><br><span class="line">            data-&gt;victim = dentry;</span><br><span class="line">            <span class="comment">// 返回 D_WALK_QUIT，表示遍历结束</span></span><br><span class="line">            <span class="keyword">return</span> D_WALK_QUIT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 dentry 的 d_flags 中包含 DCACHE_LRU_LIST 标志位</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_flags &amp; DCACHE_LRU_LIST)</span><br><span class="line">            <span class="comment">// 从 LRU 列表中删除当前的 dentry</span></span><br><span class="line">            d_lru_del(dentry);</span><br><span class="line">        <span class="comment">// 如果 dentry 的 d_lockref.count 为 0</span></span><br><span class="line">        <span class="keyword">if</span> (!dentry-&gt;d_lockref.count)</span><br><span class="line">            <span class="comment">// 将当前的 dentry 添加到 dispose 列表中</span></span><br><span class="line">            d_shrink_add(dentry, &amp;data-&gt;dispose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果 dispose 列表不为空，则设置 ret 为 D_WALK_NORETRY，</span></span><br><span class="line"><span class="comment">     * 如果需要调度，则设置 ret 为 D_WALK_QUIT，以确保向调用者返回。</span></span><br><span class="line"><span class="comment">     * 我们将会继续遍历剩余的 dentry。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;data-&gt;dispose))</span><br><span class="line">        ret = need_resched() ? D_WALK_QUIT : D_WALK_NORETRY;</span><br><span class="line">out:</span><br><span class="line">    <span class="comment">// 返回 ret</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shrink_dcache_parent - prune dcache</span></span><br><span class="line"><span class="comment"> * @parent: parent of entries to prune</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Prune the dcache to remove unused children of the parent dentry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shrink_dcache_parent</span><span class="params">(<span class="keyword">struct</span> dentry *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 定义一个 select_data 结构体，并初始化 start 字段为 parent</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">select_data</span> <span class="title">data</span> =</span> &#123;.start = parent&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 dispose 列表的头节点</span></span><br><span class="line">        INIT_LIST_HEAD(&amp;data.dispose);</span><br><span class="line">        <span class="comment">// 遍历 parent 的子节点，并将不需要的子节点添加到 dispose 列表中</span></span><br><span class="line">        d_walk(parent, &amp;data, select_collect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 dispose 列表不为空，则释放 dispose 列表中的 dentry，并继续下一轮循环</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;data.dispose)) &#123;</span><br><span class="line">            shrink_dentry_list(&amp;data.dispose);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度当前进程，以便其他任务有机会执行</span></span><br><span class="line">        cond_resched();</span><br><span class="line">        <span class="comment">// 如果没有找到需要释放的子节点，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!data.found)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 将 victim 字段置为空</span></span><br><span class="line">        data.victim = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 再次遍历 parent 的子节点，并将不需要的子节点添加到 dispose 列表中</span></span><br><span class="line">        d_walk(parent, &amp;data, select_collect2);</span><br><span class="line">        <span class="comment">// 如果找到了需要释放的子节点</span></span><br><span class="line">        <span class="keyword">if</span> (data.victim) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>;</span></span><br><span class="line">            <span class="comment">// 获取 victim 的 d_lock 自旋锁</span></span><br><span class="line">            spin_lock(&amp;data.victim-&gt;d_lock);</span><br><span class="line">            <span class="comment">// 如果成功获取到了 shrink_lock_dentry 锁</span></span><br><span class="line">            <span class="keyword">if</span> (!shrink_lock_dentry(data.victim)) &#123;</span><br><span class="line">                <span class="comment">// 释放 victim 的 d_lock 自旋锁，并解锁 RCU 读锁</span></span><br><span class="line">                spin_unlock(&amp;data.victim-&gt;d_lock);</span><br><span class="line">                rcu_read_unlock();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 解锁 RCU 读锁</span></span><br><span class="line">                rcu_read_unlock();</span><br><span class="line">                <span class="comment">// 获取 victim 的父节点</span></span><br><span class="line">                parent = data.victim-&gt;d_parent;</span><br><span class="line">                <span class="comment">// 如果 parent 不是 victim 本身，则将 parent 添加到 dispose 列表中</span></span><br><span class="line">                <span class="keyword">if</span> (parent != data.victim)</span><br><span class="line">                    __dput_to_list(parent, &amp;data.dispose);</span><br><span class="line">                <span class="comment">// 释放 victim 的资源</span></span><br><span class="line">                __dentry_kill(data.victim);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 dispose 列表不为空，则释放 dispose 列表中的 dentry</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;data.dispose))</span><br><span class="line">            shrink_dentry_list(&amp;data.dispose);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(shrink_dcache_parent);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">enum</span> d_walk_ret <span class="title function_">umount_check</span><span class="params">(<span class="type">void</span> *_data, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 如果存在繁忙的子目录，则忽略当前的 dentry */</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;dentry-&gt;d_subdirs))</span><br><span class="line">        <span class="keyword">return</span> D_WALK_CONTINUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是根目录且引用计数为1，则忽略当前的 dentry */</span></span><br><span class="line">    <span class="keyword">if</span> (dentry == _data &amp;&amp; dentry-&gt;d_lockref.count == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> D_WALK_CONTINUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印错误信息，指示当前的 dentry 仍在使用中 */</span></span><br><span class="line">    printk(KERN_ERR <span class="string">&quot;BUG: Dentry %p&#123;i=%lx,n=%pd&#125; &quot;</span></span><br><span class="line">           <span class="string">&quot; still in use (%d) [unmount of %s %s]\n&quot;</span>,</span><br><span class="line">           dentry,</span><br><span class="line">           dentry-&gt;d_inode ?</span><br><span class="line">           dentry-&gt;d_inode-&gt;i_ino : <span class="number">0UL</span>,</span><br><span class="line">           dentry,</span><br><span class="line">           dentry-&gt;d_lockref.count,</span><br><span class="line">           dentry-&gt;d_sb-&gt;s_type-&gt;name,</span><br><span class="line">           dentry-&gt;d_sb-&gt;s_id);</span><br><span class="line">    <span class="comment">/* 触发警告，表示发现了一个错误 */</span></span><br><span class="line">    WARN_ON(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> D_WALK_CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_one_tree</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 收缩 dcache，移除父目录 dentry 的未使用子节点</span></span><br><span class="line">    shrink_dcache_parent(dentry);</span><br><span class="line">    <span class="comment">// 遍历 dentry 的子节点，并检查是否有仍在使用的 dentry</span></span><br><span class="line">    d_walk(dentry, dentry, umount_check);</span><br><span class="line">    <span class="comment">// 丢弃 dentry 的引用计数</span></span><br><span class="line">    d_drop(dentry);</span><br><span class="line">    <span class="comment">// 释放 dentry</span></span><br><span class="line">    dput(dentry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在卸载时销毁与超级块关联的 dentry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shrink_dcache_for_umount</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 s_umount 是否已经被锁定</span></span><br><span class="line">    WARN(down_read_trylock(&amp;sb-&gt;s_umount), <span class="string">&quot;s_umount should&#x27;ve been locked&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理根目录的 dentry</span></span><br><span class="line">    dentry = sb-&gt;s_root;</span><br><span class="line">    sb-&gt;s_root = <span class="literal">NULL</span>;</span><br><span class="line">    do_one_tree(dentry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 s_roots 链表中的所有 dentry</span></span><br><span class="line">    <span class="keyword">while</span> (!hlist_bl_empty(&amp;sb-&gt;s_roots)) &#123;</span><br><span class="line">        dentry = dget(hlist_bl_entry(hlist_bl_first(&amp;sb-&gt;s_roots), <span class="keyword">struct</span> dentry, d_hash));</span><br><span class="line">        do_one_tree(dentry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> d_walk_ret <span class="title function_">find_submount</span><span class="params">(<span class="type">void</span> *_data, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> **<span class="title">victim</span> =</span> _data;</span><br><span class="line">    <span class="comment">// 如果 dentry 是挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (d_mountpoint(dentry)) &#123;</span><br><span class="line">        <span class="comment">// 获取 dentry 的 d_lock 自旋锁</span></span><br><span class="line">        __dget_dlock(dentry);</span><br><span class="line">        <span class="comment">// 将 dentry 赋值给 victim</span></span><br><span class="line">        *victim = dentry;</span><br><span class="line">        <span class="comment">// 返回 D_WALK_QUIT，表示遍历结束</span></span><br><span class="line">        <span class="keyword">return</span> D_WALK_QUIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 D_WALK_CONTINUE，继续遍历</span></span><br><span class="line">    <span class="keyword">return</span> D_WALK_CONTINUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_invalidate - 分离子挂载点，修剪 dcache，并丢弃</span></span><br><span class="line"><span class="comment"> * @dentry: 需要使无效的 dentry（即分离、修剪和丢弃的 dentry）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_invalidate</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> had_submounts = <span class="literal">true</span>; <span class="comment">// 是否存在子挂载点的标志</span></span><br><span class="line">    <span class="keyword">if</span> (!dentry-&gt;d_inode)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分离子挂载点并修剪 dcache</span></span><br><span class="line">    shrink_dcache_parent(dentry);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">victim</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 遍历 dentry 及其子节点，查找子挂载点</span></span><br><span class="line">        d_walk(dentry, &amp;victim, find_submount);</span><br><span class="line">        <span class="keyword">if</span> (!victim) &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到子挂载点</span></span><br><span class="line">            <span class="keyword">if</span> (had_submounts) &#123;</span><br><span class="line">                <span class="comment">// 如果之前存在子挂载点，则再次修剪 dcache</span></span><br><span class="line">                shrink_dcache_parent(dentry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分离挂载点并丢弃</span></span><br><span class="line">        detach_mounts(victim);</span><br><span class="line">        dput(victim);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_invalidate);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这段代码应该等同于 d_instantiate() + unlock_new_inode()，</span></span><br><span class="line"><span class="comment"> * 但在执行其他操作之前，先执行 unlock_new_inode() 中与 lockdep 相关的部分。</span></span><br><span class="line"><span class="comment"> * 使用这个函数替代手动编写的 d_instantiate() 和 unlock_new_inode() 的组合。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_instantiate_new</span><span class="params">(<span class="keyword">struct</span> dentry *entry, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 检查 entry 是否已经在别的哈希表中</span></span><br><span class="line">    BUG_ON(!hlist_unhashed(&amp;entry-&gt;d_u.d_alias));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 inode 是否为空</span></span><br><span class="line">    BUG_ON(!inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 inode 的互斥锁添加 lockdep 注解</span></span><br><span class="line">    lockdep_annotate_inode_mutex_key(inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用安全模块的 d_instantiate() 函数</span></span><br><span class="line">    security_d_instantiate(entry, inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 inode 的自旋锁</span></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内部函数 __d_instantiate() 来实例化 dentry 和 inode</span></span><br><span class="line">    __d_instantiate(entry, inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 inode 的状态是否为 I_NEW</span></span><br><span class="line">    WARN_ON(!(inode-&gt;i_state &amp; I_NEW));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除 inode 的状态标志 I_NEW 和 I_CREATING</span></span><br><span class="line">    inode-&gt;i_state &amp;= ~I_NEW &amp; ~I_CREATING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保在修改 inode 状态后的内存屏障</span></span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒等待 inode 状态变为 __I_NEW 的进程</span></span><br><span class="line">    wake_up_bit(&amp;inode-&gt;i_state, __I_NEW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 inode 的自旋锁</span></span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 d_instantiate_new() 函数供其他模块使用</span></span><br><span class="line">EXPORT_SYMBOL(d_instantiate_new);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_make_root</span><span class="params">(<span class="keyword">struct</span> inode *root_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 root_inode 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (root_inode) &#123;</span><br><span class="line">        <span class="comment">// 为 root_inode 分配一个匿名的 dentry</span></span><br><span class="line">        res = d_alloc_anon(root_inode-&gt;i_sb);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            <span class="comment">// 将 root_inode 和 dentry 关联起来</span></span><br><span class="line">            d_instantiate(res, root_inode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果无法分配 dentry，则释放 root_inode</span></span><br><span class="line">            iput(root_inode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_make_root);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_instantiate_anon</span>(<span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>,</span></span><br><span class="line"><span class="class">                                           <span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>,</span></span><br><span class="line"><span class="class">                                           <span class="title">bool</span> <span class="title">disconnected</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> add_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用安全模块的 d_instantiate() 函数</span></span><br><span class="line">    security_d_instantiate(dentry, inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 inode 的自旋锁</span></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否已经存在与 inode 关联的 dentry</span></span><br><span class="line">    res = __d_find_any_alias(inode);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        <span class="comment">// 如果已经存在，则释放当前的 dentry，并返回已存在的 dentry</span></span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">        dput(dentry);</span><br><span class="line">        <span class="keyword">goto</span> out_iput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 inode 设置标志位</span></span><br><span class="line">    add_flags = d_flags_for_inode(inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是断开的 dentry，则设置 DCACHE_DISCONNECTED 标志位</span></span><br><span class="line">    <span class="keyword">if</span> (disconnected)</span><br><span class="line">        add_flags |= DCACHE_DISCONNECTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 dentry 的自旋锁</span></span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 inode 和类型信息设置到 dentry 中</span></span><br><span class="line">    __d_set_inode_and_type(dentry, inode, add_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 dentry 添加到 inode 的别名链表中</span></span><br><span class="line">    hlist_add_head(&amp;dentry-&gt;d_u.d_alias, &amp;inode-&gt;i_dentry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是断开的 dentry，则将 dentry 添加到超级块的根目录链表中</span></span><br><span class="line">    <span class="keyword">if</span> (!disconnected) &#123;</span><br><span class="line">        hlist_bl_lock(&amp;dentry-&gt;d_sb-&gt;s_roots);</span><br><span class="line">        hlist_bl_add_head(&amp;dentry-&gt;d_hash, &amp;dentry-&gt;d_sb-&gt;s_roots);</span><br><span class="line">        hlist_bl_unlock(&amp;dentry-&gt;d_sb-&gt;s_roots);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放 dentry 的自旋锁和 inode 的自旋锁</span></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line"></span><br><span class="line">out_iput:</span><br><span class="line">    <span class="comment">// 释放 inode</span></span><br><span class="line">    iput(inode);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_instantiate_anon</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用内部函数 __d_instantiate_anon() 来实例化匿名的 dentry 和 inode</span></span><br><span class="line">    <span class="keyword">return</span> __d_instantiate_anon(dentry, inode, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_instantiate_anon);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_obtain_alias</span>(<span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">bool</span> <span class="title">disconnected</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 inode 为空，则返回错误码 -ESTALE</span></span><br><span class="line">    <span class="keyword">if</span> (!inode)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ESTALE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 inode 是一个错误指针，则将其转换为错误类型并返回</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找与 inode 关联的任意别名的 dentry</span></span><br><span class="line">    res = d_find_any_alias(inode);</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">        <span class="keyword">goto</span> out_iput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 inode 分配一个匿名的 dentry</span></span><br><span class="line">    tmp = d_alloc_anon(inode-&gt;i_sb);</span><br><span class="line">    <span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">        <span class="comment">// 如果无法分配 dentry，则返回错误码 -ENOMEM</span></span><br><span class="line">        res = ERR_PTR(-ENOMEM);</span><br><span class="line">        <span class="keyword">goto</span> out_iput;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用内部函数 __d_instantiate_anon() 来实例化匿名的 dentry 和 inode</span></span><br><span class="line">    <span class="keyword">return</span> __d_instantiate_anon(tmp, inode, disconnected);</span><br><span class="line"></span><br><span class="line">out_iput:</span><br><span class="line">    <span class="comment">// 释放 inode</span></span><br><span class="line">    iput(inode);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_obtain_alias - find or allocate a DISCONNECTED dentry for a given inode</span></span><br><span class="line"><span class="comment"> * @inode: inode to allocate the dentry for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取给定 inode 的一个 dentry，用于 NFS 文件句柄转换或类似的通过句柄打开操作。</span></span><br><span class="line"><span class="comment"> * 返回的 dentry 可能是匿名的，也可能具有完整的名称（如果 inode 已经在缓存中）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当在目录 inode 上调用时，我们必须确保 inode 只有一个 dentry。</span></span><br><span class="line"><span class="comment"> * 如果找到了一个 dentry，则返回该 dentry 而不是分配一个新的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在成功返回时，inode 的引用已经转移到了 dentry 上。</span></span><br><span class="line"><span class="comment"> * 在出现错误的情况下，释放了 inode 的引用。</span></span><br><span class="line"><span class="comment"> * 为了在导出操作中更容易使用，可以传入一个 %NULL 或 IS_ERR 的 inode，</span></span><br><span class="line"><span class="comment"> * 错误将传播到返回值，将 %NULL 的 inode 替换为 ERR_PTR(-ESTALE)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_obtain_alias</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用内部函数 __d_obtain_alias() 来获取一个 DISCONNECTED 的 dentry</span></span><br><span class="line">    <span class="keyword">return</span> __d_obtain_alias(inode, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_obtain_alias);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_obtain_root - find or allocate a dentry for a given inode</span></span><br><span class="line"><span class="comment"> * @inode: inode to allocate the dentry for</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取给定 inode 的一个 IS_ROOT dentry，用于文件系统的根目录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 我们必须确保目录 inode 只有一个 dentry。</span></span><br><span class="line"><span class="comment"> * 如果找到了一个 dentry，则返回该 dentry 而不是分配一个新的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在成功返回时，inode 的引用已经转移到了 dentry 上。</span></span><br><span class="line"><span class="comment"> * 在出现错误的情况下，释放了 inode 的引用。</span></span><br><span class="line"><span class="comment"> * 可以传入一个 %NULL 或 IS_ERR 的 inode，并将错误传播到返回值，</span></span><br><span class="line"><span class="comment"> * 将 %NULL 的 inode 替换为 ERR_PTR(-ESTALE)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_obtain_root</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用内部函数 __d_obtain_alias() 来获取一个根目录的 dentry</span></span><br><span class="line">    <span class="keyword">return</span> __d_obtain_alias(inode, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_obtain_root);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_add_ci - 查找或分配具有大小写精确名称的新的dentry</span></span><br><span class="line"><span class="comment"> * @inode: 已找到的不区分大小写的查找的inode</span></span><br><span class="line"><span class="comment"> * @dentry: 传递给父级查找函数的负面dentry</span></span><br><span class="line"><span class="comment"> * @name: 要与返回的dentry关联的大小写精确名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是为了避免在dcache中填充具有不区分大小写的名称到相同的inode，</span></span><br><span class="line"><span class="comment"> * 只有实际的正确大小写存储在dcache中，用于不区分大小写的文件系统。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于不区分大小写的查找匹配，如果dcache中已经存在大小写精确的dentry，</span></span><br><span class="line"><span class="comment"> * 则使用它并返回它。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不存在具有精确大小写名称的条目，则分配具有精确大小写的新的dentry，并返回拼接的条目。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_add_ci</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> qstr *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">found</span>, *<span class="title">res</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 首先检查是否已经存在与名称匹配的dentry，如果不存在，则立即创建它。 */</span></span><br><span class="line">    found = d_hash_and_lookup(dentry-&gt;d_parent, name);</span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        iput(inode);</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_in_lookup(dentry)) &#123;</span><br><span class="line">        <span class="comment">/* 如果dentry正在进行查找，则并行分配新的dentry */</span></span><br><span class="line">        found = d_alloc_parallel(dentry-&gt;d_parent, name,</span><br><span class="line">                                 dentry-&gt;d_wait);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(found) || !d_in_lookup(found)) &#123;</span><br><span class="line">            iput(inode);</span><br><span class="line">            <span class="keyword">return</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 否则，分配新的dentry */</span></span><br><span class="line">        found = d_alloc(dentry-&gt;d_parent, name);</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            iput(inode);</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将inode与新的dentry进行关联 */</span></span><br><span class="line">    res = d_splice_alias(inode, found);</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">        d_lookup_done(found);</span><br><span class="line">        dput(found);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_add_ci);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_same_name - 比较dentry的名称与大小写精确名称</span></span><br><span class="line"><span class="comment"> * @parent: 父级dentry</span></span><br><span class="line"><span class="comment"> * @dentry: 传递给父级查找函数的负面dentry</span></span><br><span class="line"><span class="comment"> * @name: 要与返回的dentry关联的大小写精确名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：如果名称相同则返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">d_same_name</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dentry *dentry, <span class="type">const</span> <span class="keyword">struct</span> dentry *parent,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="keyword">struct</span> qstr *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (likely(!(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))) &#123;</span><br><span class="line">        <span class="comment">/* 如果父级dentry没有DCACHE_OP_COMPARE标志，则直接比较名称 */</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.len != name-&gt;len)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dentry_cmp(dentry, name-&gt;name, name-&gt;len) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 否则，调用父级dentry的d_compare函数进行比较 */</span></span><br><span class="line">    <span class="keyword">return</span> parent-&gt;d_op-&gt;d_compare(dentry,</span><br><span class="line">                                   dentry-&gt;d_name.len, dentry-&gt;d_name.name,</span><br><span class="line">                                   name) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(d_same_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当父级dentry具有DCACHE_OP_COMPARE标志时，这是__d_lookup_rcu()的实现，这会使事情变得更加复杂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> noinline <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_lookup_rcu_op_compare</span>(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">    <span class="title">unsigned</span> *<span class="title">seqp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u64 hashlen = name-&gt;hash_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> d_hash(hashlen_hash(hashlen));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"></span><br><span class="line">    hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123;</span><br><span class="line">        <span class="type">int</span> tlen;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tname;</span><br><span class="line">        <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">    seqretry:</span><br><span class="line">        seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq);</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_parent != parent)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (d_unhashed(dentry))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.hash != hashlen_hash(hashlen))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        tlen = dentry-&gt;d_name.len;</span><br><span class="line">        tname = dentry-&gt;d_name.name;</span><br><span class="line">        <span class="comment">/* 我们希望得到一对一致的（name,len） */</span></span><br><span class="line">        <span class="keyword">if</span> (read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) &#123;</span><br><span class="line">            cpu_relax();</span><br><span class="line">            <span class="keyword">goto</span> seqretry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;d_op-&gt;d_compare(dentry, tlen, tname, name) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        *seqp = seq;</span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_same_name - 比较dentry的名称与大小写精确名称</span></span><br><span class="line"><span class="comment"> * @parent: 父级dentry</span></span><br><span class="line"><span class="comment"> * @dentry: 传递给父级查找函数的负面dentry</span></span><br><span class="line"><span class="comment"> * @name: 要与返回的dentry关联的大小写精确名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值：如果名称相同则返回true，否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">d_same_name</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dentry *dentry, <span class="type">const</span> <span class="keyword">struct</span> dentry *parent,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="keyword">struct</span> qstr *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (likely(!(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))) &#123;</span><br><span class="line">        <span class="comment">// 如果父级dentry没有DCACHE_OP_COMPARE标志，则直接比较名称</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.len != name-&gt;len)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dentry_cmp(dentry, name-&gt;name, name-&gt;len) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，调用父级dentry的d_compare函数进行比较</span></span><br><span class="line">    <span class="keyword">return</span> parent-&gt;d_op-&gt;d_compare(dentry,</span><br><span class="line">                                   dentry-&gt;d_name.len, dentry-&gt;d_name.name,</span><br><span class="line">                                   name) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(d_same_name);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当父级dentry具有DCACHE_OP_COMPARE标志时，这是__d_lookup_rcu()的实现，这会使事情变得更加复杂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> noinline <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_lookup_rcu_op_compare</span>(</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">    <span class="title">unsigned</span> *<span class="title">seqp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u64 hashlen = name-&gt;hash_len;  <span class="comment">// 获取name的哈希长度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> d_hash(hashlen_hash(hashlen));  <span class="comment">// 获取哈希表的头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表中的每个节点</span></span><br><span class="line">    hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123;</span><br><span class="line">        <span class="type">int</span> tlen;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *tname;</span><br><span class="line">        <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">    seqretry:</span><br><span class="line">        seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq);  <span class="comment">// 开始读取序列计数器</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_parent != parent)  <span class="comment">// 如果dentry的父级不是指定的parent</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (d_unhashed(dentry))  <span class="comment">// 如果dentry未哈希</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.hash != hashlen_hash(hashlen))  <span class="comment">// 如果dentry的哈希值与指定的哈希值不匹配</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        tlen = dentry-&gt;d_name.len;  <span class="comment">// 获取dentry的名称长度</span></span><br><span class="line">        tname = dentry-&gt;d_name.name;  <span class="comment">// 获取dentry的名称</span></span><br><span class="line">        <span class="comment">// 我们希望得到一对一致的（name,len）</span></span><br><span class="line">        <span class="keyword">if</span> (read_seqcount_retry(&amp;dentry-&gt;d_seq, seq)) &#123;  <span class="comment">// 如果序列计数器发生变化</span></span><br><span class="line">            cpu_relax();  <span class="comment">// 让出CPU时间片</span></span><br><span class="line">            <span class="keyword">goto</span> seqretry;  <span class="comment">// 重新尝试读取序列计数器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (parent-&gt;d_op-&gt;d_compare(dentry, tlen, tname, name) != <span class="number">0</span>)  <span class="comment">// 如果父级dentry的d_compare函数返回非零值</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        *seqp = seq;  <span class="comment">// 将序列计数器的值赋给seqp指针指向的变量</span></span><br><span class="line">        <span class="keyword">return</span> dentry;  <span class="comment">// 返回找到的dentry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未找到匹配的dentry，返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __d_lookup_rcu - 搜索dentry（有竞争，无存储）</span></span><br><span class="line"><span class="comment"> * @parent: 父级dentry</span></span><br><span class="line"><span class="comment"> * @name: 要查找的名称的qstr</span></span><br><span class="line"><span class="comment"> * @seqp: 返回找到dentry时的d_seq值</span></span><br><span class="line"><span class="comment"> * 返回值: dentry，或者NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup_rcu是rcu-walk名称解析（无存储路径遍历）设计中的dcache查找函数，</span></span><br><span class="line"><span class="comment"> * 其设计在Documentation/filesystems/path-lookup.txt中有描述。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数只能在核心vfs中使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup_rcu只能在rcu-walk模式下使用，即在持有vfsmount锁和rcu_read_lock的情况下。</span></span><br><span class="line"><span class="comment"> * 返回的dentry不能在没有获取d_lock并检查d_seq序列计数与这里返回的@seq相比较之前存储。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可以使用d_rcu_to_refcount函数对找到的dentry进行引用计数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者，可以再次调用__d_lookup_rcu来查找返回的dentry的子节点，只要在查找子节点之后检查其父节点的序列锁。</span></span><br><span class="line"><span class="comment"> * 因此，形成了一个交错的序列锁检查，保证了路径遍历的完整性。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意！调用者在使用返回的dentry状态之前必须检查结果dentry与我们返回的序列号是否匹配！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_lookup_rcu</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">unsigned</span> *<span class="title">seqp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u64 hashlen = name-&gt;hash_len;  <span class="comment">// 获取name的哈希长度</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *str = name-&gt;name;  <span class="comment">// 获取name的名称字符串</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> d_hash(hashlen_hash(hashlen));  <span class="comment">// 获取哈希表的头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注意：这里与__d_lookup_rcu存在重复，这是为了防止单线程性能退化，</span></span><br><span class="line"><span class="comment">     * 特别是在smp_rmb（在序列计数器中）开销较大的体系结构上。</span></span><br><span class="line"><span class="comment">     * 保持这两个函数同步。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_COMPARE))</span><br><span class="line">        <span class="keyword">return</span> __d_lookup_rcu_op_compare(parent, name, seqp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 哈希列表受RCU保护。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在比较候选dentry时，小心使用d_seq，以避免与d_move()竞争。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 并发重命名可能会在这里破坏我们的列表遍历，导致找不到我们的dentry，从而导致错误的负结果。</span></span><br><span class="line"><span class="comment">     * d_lookup()使用rename_lock序列锁来保护免受并发重命名的影响。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 更多细节请参见Documentation/filesystems/path-lookup.txt。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123;</span><br><span class="line">        <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * dentry序列计数器保护我们免受并发重命名的影响，因此保护了父级和名称字段。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 调用者必须执行序列计数器检查，以便对返回的dentry执行有用的操作。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 注意！这里使用的是“raw” seqcount_begin。这意味着，如果序列计数器处于序列更改的中间状态，</span></span><br><span class="line"><span class="comment">         * 我们不会等待序列计数器稳定。如果我们执行了慢速的dentry比较，我们将进行序列重试，直到它稳定下来，</span></span><br><span class="line"><span class="comment">         * 如果我们最终找到了一个成功的查找，我们实际上希望退出RCU查找。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 请注意，raw_seqcount_begin仍然会执行smp_rmb()，因此我们仍然保证-&gt;d_name.name的NUL终止。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        seq = raw_seqcount_begin(&amp;dentry-&gt;d_seq);  <span class="comment">// 开始读取序列计数器</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_parent != parent)  <span class="comment">// 如果dentry的父级不是指定的parent</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (d_unhashed(dentry))  <span class="comment">// 如果dentry未哈希</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.hash_len != hashlen)  <span class="comment">// 如果dentry的哈希长度与指定的哈希长度不匹配</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (dentry_cmp(dentry, str, hashlen_len(hashlen)) != <span class="number">0</span>)  <span class="comment">// 如果dentry与指定的名称不匹配</span></span><br><span class="line">            <span class="keyword">continue</span>;  <span class="comment">// 继续下一个节点</span></span><br><span class="line">        *seqp = seq;  <span class="comment">// 将序列计数器的值赋给seqp指针指向的变量</span></span><br><span class="line">        <span class="keyword">return</span> dentry;  <span class="comment">// 返回找到的dentry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未找到匹配的dentry，返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_lookup - 搜索dentry</span></span><br><span class="line"><span class="comment"> * @parent: 父级dentry</span></span><br><span class="line"><span class="comment"> * @name: 要查找的名称的qstr</span></span><br><span class="line"><span class="comment"> * 返回值: dentry，或者NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * d_lookup搜索父级dentry的子节点，查找指定的名称。如果找到dentry，它的引用计数将增加，并返回该dentry。</span></span><br><span class="line"><span class="comment"> * 调用者必须使用dput释放使用完毕的dentry。如果dentry不存在，则返回NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_lookup</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> dentry *parent, <span class="type">const</span> <span class="keyword">struct</span> qstr *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        seq = read_seqbegin(&amp;rename_lock);  <span class="comment">// 开始读取序列计数器</span></span><br><span class="line">        dentry = __d_lookup(parent, name);  <span class="comment">// 调用__d_lookup函数查找dentry</span></span><br><span class="line">        <span class="keyword">if</span> (dentry)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (read_seqretry(&amp;rename_lock, seq));  <span class="comment">// 如果序列计数器发生变化，则重试</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dentry;  <span class="comment">// 返回找到的dentry</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_lookup);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __d_lookup - search for a dentry (racy)</span></span><br><span class="line"><span class="comment"> * @parent: parent dentry</span></span><br><span class="line"><span class="comment"> * @name: qstr of name we wish to find</span></span><br><span class="line"><span class="comment"> * Returns: dentry, or NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup is like d_lookup, however it may (rarely) return a</span></span><br><span class="line"><span class="comment"> * false-negative result due to unrelated rename activity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup is slightly faster by avoiding rename_lock read seqlock,</span></span><br><span class="line"><span class="comment"> * however it must be used carefully, eg. with a following d_lookup in</span></span><br><span class="line"><span class="comment"> * the case of failure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * __d_lookup callers must be commented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">d_lookup</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = name-&gt;hash;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> d_hash(hash);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">found</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note: There is significant duplication with __d_lookup_rcu which is</span></span><br><span class="line"><span class="comment">     * required to prevent single threaded performance regressions</span></span><br><span class="line"><span class="comment">     * especially on architectures where smp_rmb (in seqcounts) are costly.</span></span><br><span class="line"><span class="comment">     * Keep the two functions in sync.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The hash list is protected using RCU.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Take d_lock when comparing a candidate dentry, to avoid races</span></span><br><span class="line"><span class="comment">     * with d_move().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is possible that concurrent renames can mess up our list</span></span><br><span class="line"><span class="comment">     * walk here and result in missing our dentry, resulting in the</span></span><br><span class="line"><span class="comment">     * false-negative result. d_lookup() protects against concurrent</span></span><br><span class="line"><span class="comment">     * renames using rename_lock seqlock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * See Documentation/filesystems/path-lookup.txt for more details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line"></span><br><span class="line">    hlist_bl_for_each_entry_rcu(dentry, node, b, d_hash) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.hash != hash)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_parent != parent)</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line">        <span class="keyword">if</span> (d_unhashed(dentry))</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!d_same_name(dentry, parent, name))</span><br><span class="line">            <span class="keyword">goto</span> next;</span><br><span class="line"></span><br><span class="line">        dentry-&gt;d_lockref.count++;</span><br><span class="line">        found = dentry;</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">next:</span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">     &#125;</span><br><span class="line">     rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_hash_and_lookup - 对qstr进行哈希然后搜索dentry</span></span><br><span class="line"><span class="comment"> * @dir: 要搜索的目录</span></span><br><span class="line"><span class="comment"> * @name: 要查找的名称的qstr</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在查找失败时返回NULL；在名称错误时返回ERR_PTR(-error)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_hash_and_lookup</span><span class="params">(<span class="keyword">struct</span> dentry *dir, <span class="keyword">struct</span> qstr *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查是否有文件系统特定的哈希函数。注意，我们必须先计算标准哈希值，</span></span><br><span class="line"><span class="comment">     * 因为d_op-&gt;d_hash()函数可能选择保持哈希值不变。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    name-&gt;hash = full_name_hash(dir, name-&gt;name, name-&gt;len);  <span class="comment">// 计算标准哈希值</span></span><br><span class="line">    <span class="keyword">if</span> (dir-&gt;d_flags &amp; DCACHE_OP_HASH) &#123;  <span class="comment">// 检查是否有文件系统特定的哈希函数</span></span><br><span class="line">        <span class="type">int</span> err = dir-&gt;d_op-&gt;d_hash(dir, name);  <span class="comment">// 调用文件系统特定的哈希函数</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(err &lt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(err);  <span class="comment">// 返回错误指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d_lookup(dir, name);  <span class="comment">// 调用d_lookup函数进行查找</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_hash_and_lookup);  <span class="comment">// 导出d_hash_and_lookup函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当一个文件被删除时，我们有两个选项：</span></span><br><span class="line"><span class="comment"> * - 将这个dentry转换为一个负的dentry</span></span><br><span class="line"><span class="comment"> * - 取消哈希这个dentry并释放它</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 通常情况下，我们只想将其转换为负的dentry，但如果有其他人正在使用该dentry或者inode，</span></span><br><span class="line"><span class="comment"> * 我们就无法这样做，只能将其从哈希队列中移除，并等待它在没有用户时被删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_delete - 删除一个dentry</span></span><br><span class="line"><span class="comment"> * @dentry: 要删除的dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果可能，将dentry转换为负的dentry，否则从哈希队列中移除它，以便稍后删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_delete</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock);  <span class="comment">// 获取inode的自旋锁</span></span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);  <span class="comment">// 获取dentry的自旋锁</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 我们是唯一的用户吗？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_lockref.count == <span class="number">1</span>) &#123;</span><br><span class="line">        dentry-&gt;d_flags &amp;= ~DCACHE_CANT_MOUNT;  <span class="comment">// 清除dentry的DCACHE_CANT_MOUNT标志位</span></span><br><span class="line">        dentry_unlink_inode(dentry);  <span class="comment">// 解除dentry与inode的关联</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __d_drop(dentry);  <span class="comment">// 从哈希队列中移除dentry</span></span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 释放dentry的自旋锁</span></span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);  <span class="comment">// 释放inode的自旋锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_delete);  <span class="comment">// 导出d_delete函数，使其可被其他模块使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __d_rehash(<span class="keyword">struct</span> dentry *entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> d_hash(entry-&gt;d_name.hash);  <span class="comment">// 获取哈希桶</span></span><br><span class="line"></span><br><span class="line">    hlist_bl_lock(b);  <span class="comment">// 锁定哈希桶</span></span><br><span class="line">    hlist_bl_add_head_rcu(&amp;entry-&gt;d_hash, b);  <span class="comment">// 将dentry添加到哈希桶中</span></span><br><span class="line">    hlist_bl_unlock(b);  <span class="comment">// 解锁哈希桶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_rehash - 将一个条目重新添加到哈希表中</span></span><br><span class="line"><span class="comment"> * @entry: 要添加到哈希表的dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 根据dentry的名称将其添加到哈希表中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_rehash</span><span class="params">(<span class="keyword">struct</span> dentry *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;entry-&gt;d_lock);  <span class="comment">// 获取dentry的自旋锁</span></span><br><span class="line">    __d_rehash(entry);  <span class="comment">// 调用内部函数将dentry重新添加到哈希表中</span></span><br><span class="line">    spin_unlock(&amp;entry-&gt;d_lock);  <span class="comment">// 释放dentry的自旋锁</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_rehash);  <span class="comment">// 导出d_rehash函数，使其可被其他模块使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="title function_">start_dir_add</span><span class="params">(<span class="keyword">struct</span> inode *dir)</span></span><br><span class="line">&#123;</span><br><span class="line">    preempt_disable_nested();  <span class="comment">// 禁用抢占，并进入嵌套模式</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">unsigned</span> n = dir-&gt;i_dir_seq;</span><br><span class="line">        <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>) &amp;&amp; cmpxchg(&amp;dir-&gt;i_dir_seq, n, n + <span class="number">1</span>) == n)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        cpu_relax();  <span class="comment">// CPU自旋等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">end_dir_add</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="type">unsigned</span> <span class="type">int</span> n,</span></span><br><span class="line"><span class="params">                               <span class="type">wait_queue_head_t</span> *d_wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    smp_store_release(&amp;dir-&gt;i_dir_seq, n + <span class="number">2</span>);  <span class="comment">// 存储并释放内存屏障，更新i_dir_seq的值</span></span><br><span class="line">    preempt_enable_nested();  <span class="comment">// 启用抢占，并退出嵌套模式</span></span><br><span class="line">    wake_up_all(d_wait);  <span class="comment">// 唤醒等待队列中的所有进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">d_wait_lookup</span><span class="params">(<span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (d_in_lookup(dentry)) &#123;</span><br><span class="line">        DECLARE_WAITQUEUE(wait, current);  <span class="comment">// 声明一个等待队列项</span></span><br><span class="line">        add_wait_queue(dentry-&gt;d_wait, &amp;wait);  <span class="comment">// 将等待队列项添加到dentry的等待队列中</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            set_current_state(TASK_UNINTERRUPTIBLE);  <span class="comment">// 设置当前进程的状态为不可中断</span></span><br><span class="line">            spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 释放dentry的自旋锁</span></span><br><span class="line">            schedule();  <span class="comment">// 进程调度，切换到其他可运行的进程</span></span><br><span class="line">            spin_lock(&amp;dentry-&gt;d_lock);  <span class="comment">// 获取dentry的自旋锁</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (d_in_lookup(dentry));  <span class="comment">// 当dentry处于查找状态时循环执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_alloc_parallel</span><span class="params">(<span class="keyword">struct</span> dentry *parent,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> qstr *name,</span></span><br><span class="line"><span class="params">                <span class="type">wait_queue_head_t</span> *wq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = name-&gt;hash;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span> =</span> in_lookup_hash(parent, hash);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">new</span> =</span> d_alloc(parent, name);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> seq, r_seq, d_seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!new))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    seq = smp_load_acquire(&amp;parent-&gt;d_inode-&gt;i_dir_seq);</span><br><span class="line">    r_seq = read_seqbegin(&amp;rename_lock);</span><br><span class="line">    dentry = __d_lookup_rcu(parent, name, &amp;d_seq);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dentry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (read_seqcount_retry(&amp;dentry-&gt;d_seq, d_seq)) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            dput(dentry);</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        dput(new);</span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(read_seqretry(&amp;rename_lock, r_seq))) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(seq &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hlist_bl_lock(b);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(READ_ONCE(parent-&gt;d_inode-&gt;i_dir_seq) != seq)) &#123;</span><br><span class="line">        hlist_bl_unlock(b);</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No changes for the parent since the beginning of d_lookup().</span></span><br><span class="line"><span class="comment">     * Since all removals from the chain happen with hlist_bl_lock(),</span></span><br><span class="line"><span class="comment">     * any potential in-lookup matches are going to stay here until</span></span><br><span class="line"><span class="comment">     * we unlock the chain.  All fields are stable in everything</span></span><br><span class="line"><span class="comment">     * we encounter.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    hlist_bl_for_each_entry(dentry, node, b, d_u.d_in_lookup_hash) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_name.hash != hash)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dentry-&gt;d_parent != parent)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!d_same_name(dentry, parent, name))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        hlist_bl_unlock(b);</span><br><span class="line">        <span class="comment">/* now we can try to grab a reference */</span></span><br><span class="line">        <span class="keyword">if</span> (!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)) &#123;</span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * somebody is likely to be still doing lookup for it;</span></span><br><span class="line"><span class="comment">         * wait for them to finish</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        spin_lock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        d_wait_lookup(dentry);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * it&#x27;s not in-lookup anymore; in principle we should repeat</span></span><br><span class="line"><span class="comment">         * everything from dcache lookup, but it&#x27;s likely to be what</span></span><br><span class="line"><span class="comment">         * d_lookup() would&#x27;ve found anyway.  If it is, just return it;</span></span><br><span class="line"><span class="comment">         * otherwise we really have to repeat the whole thing.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(dentry-&gt;d_name.hash != hash))</span><br><span class="line">            <span class="keyword">goto</span> mismatch;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dentry-&gt;d_parent != parent))</span><br><span class="line">            <span class="keyword">goto</span> mismatch;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(d_unhashed(dentry)))</span><br><span class="line">            <span class="keyword">goto</span> mismatch;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!d_same_name(dentry, parent, name)))</span><br><span class="line">            <span class="keyword">goto</span> mismatch;</span><br><span class="line">        <span class="comment">/* OK, it *is* a hashed match; return it */</span></span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">        dput(new);</span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line">    &#125;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">/* we can&#x27;t take -&gt;d_lock here; it&#x27;s OK, though. */</span></span><br><span class="line">    new-&gt;d_flags |= DCACHE_PAR_LOOKUP;</span><br><span class="line">    new-&gt;d_wait = wq;</span><br><span class="line">    hlist_bl_add_head_rcu(&amp;new-&gt;d_u.d_in_lookup_hash, b);</span><br><span class="line">    hlist_bl_unlock(b);</span><br><span class="line">    <span class="keyword">return</span> new;</span><br><span class="line">mismatch:</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    dput(dentry);</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_alloc_parallel);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * - 取消哈希化的dentry</span></span><br><span class="line"><span class="comment"> * - 检索并清除dentry中的等待队列头</span></span><br><span class="line"><span class="comment"> * - 返回等待队列头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">wait_queue_head_t</span> *__d_lookup_unhash(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> *d_wait;  <span class="comment">// 等待队列头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_head</span> *<span class="title">b</span>;</span>  <span class="comment">// 哈希表头指针</span></span><br><span class="line"></span><br><span class="line">    lockdep_assert_held(&amp;dentry-&gt;d_lock);  <span class="comment">// 断言dentry的锁已经被持有</span></span><br><span class="line"></span><br><span class="line">    b = in_lookup_hash(dentry-&gt;d_parent, dentry-&gt;d_name.hash);  <span class="comment">// 在哈希表中查找dentry的父目录和哈希值对应的表头</span></span><br><span class="line">    hlist_bl_lock(b);  <span class="comment">// 锁定哈希表</span></span><br><span class="line">    dentry-&gt;d_flags &amp;= ~DCACHE_PAR_LOOKUP;  <span class="comment">// 清除dentry的标志位</span></span><br><span class="line">    __hlist_bl_del(&amp;dentry-&gt;d_u.d_in_lookup_hash);  <span class="comment">// 从哈希表中删除dentry</span></span><br><span class="line">    d_wait = dentry-&gt;d_wait;  <span class="comment">// 获取等待队列头</span></span><br><span class="line">    dentry-&gt;d_wait = <span class="literal">NULL</span>;  <span class="comment">// 清空等待队列头</span></span><br><span class="line">    hlist_bl_unlock(b);  <span class="comment">// 解锁哈希表</span></span><br><span class="line">    INIT_HLIST_NODE(&amp;dentry-&gt;d_u.d_alias);  <span class="comment">// 初始化dentry的别名哈希链表节点</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;dentry-&gt;d_lru);  <span class="comment">// 初始化dentry的LRU链表头</span></span><br><span class="line">    <span class="keyword">return</span> d_wait;  <span class="comment">// 返回等待队列头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __d_lookup_unhash_wake(<span class="keyword">struct</span> dentry *dentry)</span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);  <span class="comment">// 自旋锁住dentry的锁</span></span><br><span class="line">    wake_up_all(__d_lookup_unhash(dentry));  <span class="comment">// 唤醒等待队列中的所有进程</span></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 解锁dentry的锁</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__d_lookup_unhash_wake);  <span class="comment">// 导出符号__d_lookup_unhash_wake</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果inode非空，则持有inode-&gt;i_lock */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __d_add(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> *d_wait;  <span class="comment">// 等待队列头指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> <span class="literal">NULL</span>;  <span class="comment">// 目录inode指针</span></span><br><span class="line">    <span class="type">unsigned</span> n;  <span class="comment">// 目录添加计数器</span></span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_lock);  <span class="comment">// 自旋锁住dentry的锁</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(d_in_lookup(dentry))) &#123;  <span class="comment">// 如果dentry正在进行查找操作</span></span><br><span class="line">        dir = dentry-&gt;d_parent-&gt;d_inode;  <span class="comment">// 获取dentry的父目录inode</span></span><br><span class="line">        n = start_dir_add(dir);  <span class="comment">// 开始目录添加操作，返回目录添加计数器</span></span><br><span class="line">        d_wait = __d_lookup_unhash(dentry);  <span class="comment">// 取消哈希化dentry并获取等待队列头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inode) &#123;</span><br><span class="line">        <span class="type">unsigned</span> add_flags = d_flags_for_inode(inode);  <span class="comment">// 获取inode的标志位</span></span><br><span class="line">        hlist_add_head(&amp;dentry-&gt;d_u.d_alias, &amp;inode-&gt;i_dentry);  <span class="comment">// 将dentry添加到inode的别名哈希链表头</span></span><br><span class="line">        raw_write_seqcount_begin(&amp;dentry-&gt;d_seq);  <span class="comment">// 开始写序列计数器</span></span><br><span class="line">        __d_set_inode_and_type(dentry, inode, add_flags);  <span class="comment">// 设置dentry的inode和类型</span></span><br><span class="line">        raw_write_seqcount_end(&amp;dentry-&gt;d_seq);  <span class="comment">// 结束写序列计数器</span></span><br><span class="line">        fsnotify_update_flags(dentry);  <span class="comment">// 更新dentry的标志位</span></span><br><span class="line">    &#125;</span><br><span class="line">    __d_rehash(dentry);  <span class="comment">// 重新哈希化dentry</span></span><br><span class="line">    <span class="keyword">if</span> (dir)</span><br><span class="line">        end_dir_add(dir, n, d_wait);  <span class="comment">// 结束目录添加操作，传入目录inode、目录添加计数器和等待队列头</span></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);  <span class="comment">// 解锁dentry的锁</span></span><br><span class="line">    <span class="keyword">if</span> (inode)</span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);  <span class="comment">// 解锁inode的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_add - 将dentry添加到哈希队列</span></span><br><span class="line"><span class="comment"> * @entry: 要添加的dentry</span></span><br><span class="line"><span class="comment"> * @inode: 要附加到此dentry的inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这将entry添加到哈希队列并初始化inode。</span></span><br><span class="line"><span class="comment"> * entry实际上是在d_alloc()期间填充的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_add</span><span class="params">(<span class="keyword">struct</span> dentry *entry, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (inode) &#123;</span><br><span class="line">        security_d_instantiate(entry, inode); <span class="comment">// 调用安全函数security_d_instantiate，将entry和inode关联起来</span></span><br><span class="line">        spin_lock(&amp;inode-&gt;i_lock); <span class="comment">// 获取inode的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    __d_add(entry, inode); <span class="comment">// 调用内部函数__d_add，将entry添加到哈希队列中</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_add); <span class="comment">// 导出d_add符号，使其可在其他模块中使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_exact_alias - 查找并哈希一个确切的未哈希别名</span></span><br><span class="line"><span class="comment"> * @entry: 要添加的dentry</span></span><br><span class="line"><span class="comment"> * @inode: 与此dentry关联的inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果具有相同名称/父目录和所需inode的未哈希dentry已经存在，则哈希并返回它。否则，返回NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 父目录应该被锁定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_exact_alias</span><span class="params">(<span class="keyword">struct</span> dentry *entry, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">alias</span>;</span> <span class="comment">// 定义一个别名dentry指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> hash = entry-&gt;d_name.hash; <span class="comment">// 获取entry的名称哈希值</span></span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock); <span class="comment">// 获取inode的锁</span></span><br><span class="line">    hlist_for_each_entry(alias, &amp;inode-&gt;i_dentry, d_u.d_alias) &#123; <span class="comment">// 遍历inode的dentry链表</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 这里不需要alias-&gt;d_lock，因为具有d_parent == entry-&gt;d_parent的别名不受名称或父目录更改的影响，因为持有父目录inode i_mutex。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (alias-&gt;d_name.hash != hash) <span class="comment">// 如果别名的名称哈希值与entry的不相等，则继续下一次循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (alias-&gt;d_parent != entry-&gt;d_parent) <span class="comment">// 如果别名的父目录与entry的父目录不相等，则继续下一次循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!d_same_name(alias, entry-&gt;d_parent, &amp;entry-&gt;d_name)) <span class="comment">// 如果别名与entry的名称不相同，则继续下一次循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        spin_lock(&amp;alias-&gt;d_lock); <span class="comment">// 获取别名的锁</span></span><br><span class="line">        <span class="keyword">if</span> (!d_unhashed(alias)) &#123; <span class="comment">// 如果别名已经被哈希，则解锁并将别名置为NULL</span></span><br><span class="line">            spin_unlock(&amp;alias-&gt;d_lock);</span><br><span class="line">            alias = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            __dget_dlock(alias); <span class="comment">// 获取别名的引用计数</span></span><br><span class="line">            __d_rehash(alias); <span class="comment">// 将别名重新哈希</span></span><br><span class="line">            spin_unlock(&amp;alias-&gt;d_lock); <span class="comment">// 解锁别名</span></span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock); <span class="comment">// 解锁inode</span></span><br><span class="line">        <span class="keyword">return</span> alias; <span class="comment">// 返回找到的别名</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;inode-&gt;i_lock); <span class="comment">// 解锁inode</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没有找到匹配的别名，返回NULL</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_exact_alias); <span class="comment">// 导出d_exact_alias符号，使其可在其他模块中使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">swap_names</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> dentry *target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dname_external(target))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dname_external(dentry))) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Both external: swap the pointers</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            swap(target-&gt;d_name.name, dentry-&gt;d_name.name);  <span class="comment">// 交换两个外部名称的指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * dentry:internal, target:external.  Steal target&#x27;s</span></span><br><span class="line"><span class="comment">             * storage and make target internal.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(target-&gt;d_iname, dentry-&gt;d_name.name,</span><br><span class="line">                   dentry-&gt;d_name.len + <span class="number">1</span>);  <span class="comment">// 将dentry的名称复制到target的内部存储中</span></span><br><span class="line">            dentry-&gt;d_name.name = target-&gt;d_name.name;  <span class="comment">// 将target的名称指针赋值给dentry</span></span><br><span class="line">            target-&gt;d_name.name = target-&gt;d_iname;  <span class="comment">// 将target的内部存储指针赋值给target的名称指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(dname_external(dentry))) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * dentry:external, target:internal.  Give dentry&#x27;s</span></span><br><span class="line"><span class="comment">             * storage to target and make dentry internal</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(dentry-&gt;d_iname, target-&gt;d_name.name,</span><br><span class="line">                   target-&gt;d_name.len + <span class="number">1</span>);  <span class="comment">// 将target的名称复制到dentry的内部存储中</span></span><br><span class="line">            target-&gt;d_name.name = dentry-&gt;d_name.name;  <span class="comment">// 将dentry的名称指针赋值给target</span></span><br><span class="line">            dentry-&gt;d_name.name = dentry-&gt;d_iname;  <span class="comment">// 将dentry的内部存储指针赋值给dentry的名称指针</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Both are internal.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">            BUILD_BUG_ON(!IS_ALIGNED(DNAME_INLINE_LEN, <span class="keyword">sizeof</span>(<span class="type">long</span>)));</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DNAME_INLINE_LEN / <span class="keyword">sizeof</span>(<span class="type">long</span>); i++) &#123;</span><br><span class="line">                swap(((<span class="type">long</span> *) &amp;dentry-&gt;d_iname)[i],</span><br><span class="line">                     ((<span class="type">long</span> *) &amp;target-&gt;d_iname)[i]);  <span class="comment">// 交换两个内部名称的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(dentry-&gt;d_name.hash_len, target-&gt;d_name.hash_len);  <span class="comment">// 交换两个名称的哈希长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">copy_name</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> dentry *target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">external_name</span> *<span class="title">old_name</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(dname_external(dentry)))</span><br><span class="line">        old_name = external_name(dentry);  <span class="comment">// 获取dentry的外部名称指针</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dname_external(target))) &#123;</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;external_name(target)-&gt;u.count);  <span class="comment">// 增加target的外部名称引用计数</span></span><br><span class="line">        dentry-&gt;d_name = target-&gt;d_name;  <span class="comment">// 将target的名称赋值给dentry的名称</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(dentry-&gt;d_iname, target-&gt;d_name.name,</span><br><span class="line">               target-&gt;d_name.len + <span class="number">1</span>);  <span class="comment">// 将target的名称复制到dentry的内部存储中</span></span><br><span class="line">        dentry-&gt;d_name.name = dentry-&gt;d_iname;  <span class="comment">// 将dentry的内部存储指针赋值给dentry的名称指针</span></span><br><span class="line">        dentry-&gt;d_name.hash_len = target-&gt;d_name.hash_len;  <span class="comment">// 将target的名称哈希长度赋值给dentry的名称哈希长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old_name &amp;&amp; likely(atomic_dec_and_test(&amp;old_name-&gt;u.count)))</span><br><span class="line">        kfree_rcu(old_name, u.head);  <span class="comment">// 减少旧的外部名称的引用计数，并在引用计数为0时释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __d_move - 移动一个dentry</span></span><br><span class="line"><span class="comment"> * @dentry: 要移动的dentry</span></span><br><span class="line"><span class="comment"> * @target: 新的dentry</span></span><br><span class="line"><span class="comment"> * @exchange: 交换这两个dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更新dcache以反映文件名的移动。负的dcache条目不应以这种方式移动。调用者必须持有rename_lock、源目录和目标目录的i_mutex，以及如果它们不同，则持有sb-&gt;s_vfs_rename_mutex。参见lock_rename()。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __d_move(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> dentry *target,</span><br><span class="line">                     <span class="type">bool</span> exchange)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">old_parent</span>, *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> *d_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查dentry是否有关联的inode</span></span><br><span class="line">    WARN_ON(!dentry-&gt;d_inode);</span><br><span class="line">    <span class="comment">// 检查dentry和target是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(dentry == target))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查target是否是dentry的祖先</span></span><br><span class="line">    BUG_ON(d_ancestor(target, dentry));</span><br><span class="line">    <span class="comment">// 保存dentry的旧父目录</span></span><br><span class="line">    old_parent = dentry-&gt;d_parent;</span><br><span class="line">    <span class="comment">// 检查target是否是dentry的祖先或者dentry是否是target的祖先</span></span><br><span class="line">    p = d_ancestor(old_parent, target);</span><br><span class="line">    <span class="comment">// 如果dentry是根目录</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ROOT(dentry)) &#123;</span><br><span class="line">        BUG_ON(p);</span><br><span class="line">        <span class="comment">// 锁定target的父目录</span></span><br><span class="line">        spin_lock(&amp;target-&gt;d_parent-&gt;d_lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">        <span class="comment">/* target不是dentry-&gt;d_parent的后代 */</span></span><br><span class="line">        <span class="comment">// 锁定target的父目录</span></span><br><span class="line">        spin_lock(&amp;target-&gt;d_parent-&gt;d_lock);</span><br><span class="line">        <span class="comment">// 锁定旧父目录</span></span><br><span class="line">        spin_lock_nested(&amp;old_parent-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        BUG_ON(p == dentry);</span><br><span class="line">        <span class="comment">// 锁定旧父目录</span></span><br><span class="line">        spin_lock(&amp;old_parent-&gt;d_lock);</span><br><span class="line">        <span class="comment">// 如果p不等于target，则锁定target的父目录</span></span><br><span class="line">        <span class="keyword">if</span> (p != target)</span><br><span class="line">            spin_lock_nested(&amp;target-&gt;d_parent-&gt;d_lock,</span><br><span class="line">                             DENTRY_D_LOCK_NESTED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁定dentry</span></span><br><span class="line">    spin_lock_nested(&amp;dentry-&gt;d_lock, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 锁定target</span></span><br><span class="line">    spin_lock_nested(&amp;target-&gt;d_lock, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果target正在进行查找操作</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(d_in_lookup(target))) &#123;</span><br><span class="line">        <span class="comment">// 获取target的父目录的inode</span></span><br><span class="line">        dir = target-&gt;d_parent-&gt;d_inode;</span><br><span class="line">        <span class="comment">// 开始目录添加操作</span></span><br><span class="line">        n = start_dir_add(dir);</span><br><span class="line">        <span class="comment">// 获取等待队列头</span></span><br><span class="line">        d_wait = __d_lookup_unhash(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始写序列计数</span></span><br><span class="line">    write_seqcount_begin(&amp;dentry-&gt;d_seq);</span><br><span class="line">    <span class="comment">// 开始嵌套写序列计数</span></span><br><span class="line">    write_seqcount_begin_nested(&amp;target-&gt;d_seq, DENTRY_D_LOCK_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 取消哈希两个dentry */</span></span><br><span class="line">    <span class="comment">// 如果dentry没有被取消哈希</span></span><br><span class="line">    <span class="keyword">if</span> (!d_unhashed(dentry))</span><br><span class="line">        ___d_drop(dentry);</span><br><span class="line">    <span class="comment">// 如果target没有被取消哈希</span></span><br><span class="line">    <span class="keyword">if</span> (!d_unhashed(target))</span><br><span class="line">        ___d_drop(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... 并在树中交换它们 */</span></span><br><span class="line">    <span class="comment">// 设置dentry的父目录为target的父目录</span></span><br><span class="line">    dentry-&gt;d_parent = target-&gt;d_parent;</span><br><span class="line">    <span class="comment">// 如果不是交换操作</span></span><br><span class="line">    <span class="keyword">if</span> (!exchange) &#123;</span><br><span class="line">        <span class="comment">// 复制名称</span></span><br><span class="line">        copy_name(dentry, target);</span><br><span class="line">        <span class="comment">// 设置target的哈希前驱为NULL</span></span><br><span class="line">        target-&gt;d_hash.pprev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 增加dentry的父目录的锁引用计数</span></span><br><span class="line">        dentry-&gt;d_parent-&gt;d_lockref.count++;</span><br><span class="line">        <span class="comment">// 如果dentry不是旧父目录</span></span><br><span class="line">        <span class="keyword">if</span> (dentry != old_parent) <span class="comment">/* 不是IS_ROOT */</span></span><br><span class="line">            <span class="comment">// 减少旧父目录的锁引用计数</span></span><br><span class="line">            WARN_ON(!--old_parent-&gt;d_lockref.count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置target的父目录为旧父目录</span></span><br><span class="line">        target-&gt;d_parent = old_parent;</span><br><span class="line">        <span class="comment">// 交换名称</span></span><br><span class="line">        swap_names(dentry, target);</span><br><span class="line">        <span class="comment">// 将target从target的父目录的子目录列表中移动到dentry的父目录的子目录列表中</span></span><br><span class="line">        list_move(&amp;target-&gt;d_child, &amp;target-&gt;d_parent-&gt;d_subdirs);</span><br><span class="line">        <span class="comment">// 重新哈希target</span></span><br><span class="line">        __d_rehash(target);</span><br><span class="line">        <span class="comment">// 更新target的标志位</span></span><br><span class="line">        fsnotify_update_flags(target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将dentry从dentry的父目录的子目录列表中移动到target的父目录的子目录列表中</span></span><br><span class="line">    list_move(&amp;dentry-&gt;d_child, &amp;dentry-&gt;d_parent-&gt;d_subdirs);</span><br><span class="line">    <span class="comment">// 重新哈希dentry</span></span><br><span class="line">    __d_rehash(dentry);</span><br><span class="line">    <span class="comment">// 更新dentry的标志位</span></span><br><span class="line">    fsnotify_update_flags(dentry);</span><br><span class="line">    <span class="comment">// 处理dentry的移动操作</span></span><br><span class="line">    fscrypt_handle_d_move(dentry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束写序列计数</span></span><br><span class="line">    write_seqcount_end(&amp;target-&gt;d_seq);</span><br><span class="line">    <span class="comment">// 结束写序列计数</span></span><br><span class="line">    write_seqcount_end(&amp;dentry-&gt;d_seq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dir不为空</span></span><br><span class="line">    <span class="keyword">if</span> (dir)</span><br><span class="line">        <span class="comment">// 结束目录添加操作</span></span><br><span class="line">        end_dir_add(dir, n, d_wait);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dentry的父目录不等于旧父目录</span></span><br><span class="line">    <span class="keyword">if</span> (dentry-&gt;d_parent != old_parent)</span><br><span class="line">        <span class="comment">// 解锁dentry的父目录</span></span><br><span class="line">        spin_unlock(&amp;dentry-&gt;d_parent-&gt;d_lock);</span><br><span class="line">    <span class="comment">// 如果dentry不等于旧父目录</span></span><br><span class="line">    <span class="keyword">if</span> (dentry != old_parent)</span><br><span class="line">        <span class="comment">// 解锁旧父目录</span></span><br><span class="line">        spin_unlock(&amp;old_parent-&gt;d_lock);</span><br><span class="line">    <span class="comment">// 解锁target</span></span><br><span class="line">    spin_unlock(&amp;target-&gt;d_lock);</span><br><span class="line">    <span class="comment">// 解锁dentry</span></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * d_move - 移动一个dentry</span></span><br><span class="line"><span class="comment"> * @dentry: 要移动的dentry</span></span><br><span class="line"><span class="comment"> * @target: 新的dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 更新dcache以反映文件名的移动。负的dcache条目不应以这种方式移动。请参阅__d_move的锁定要求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_move</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> dentry *target)</span></span><br><span class="line">&#123;</span><br><span class="line">    write_seqlock(&amp;rename_lock); <span class="comment">// 获取重命名锁</span></span><br><span class="line">    __d_move(dentry, target, <span class="literal">false</span>); <span class="comment">// 调用内部函数__d_move进行移动</span></span><br><span class="line">    write_sequnlock(&amp;rename_lock); <span class="comment">// 释放重命名锁</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_move); <span class="comment">// 导出d_move函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * d_exchange - 交换两个dentry</span></span><br><span class="line"><span class="comment"> * @dentry1: 第一个dentry</span></span><br><span class="line"><span class="comment"> * @dentry2: 第二个dentry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_exchange</span><span class="params">(<span class="keyword">struct</span> dentry *dentry1, <span class="keyword">struct</span> dentry *dentry2)</span></span><br><span class="line">&#123;</span><br><span class="line">    write_seqlock(&amp;rename_lock); <span class="comment">// 获取重命名锁</span></span><br><span class="line"></span><br><span class="line">    WARN_ON(!dentry1-&gt;d_inode); <span class="comment">// 如果dentry1的d_inode为空，则发出警告</span></span><br><span class="line">    WARN_ON(!dentry2-&gt;d_inode); <span class="comment">// 如果dentry2的d_inode为空，则发出警告</span></span><br><span class="line">    WARN_ON(IS_ROOT(dentry1)); <span class="comment">// 如果dentry1是根目录，则发出警告</span></span><br><span class="line">    WARN_ON(IS_ROOT(dentry2)); <span class="comment">// 如果dentry2是根目录，则发出警告</span></span><br><span class="line"></span><br><span class="line">    __d_move(dentry1, dentry2, <span class="literal">true</span>); <span class="comment">// 调用内部函数__d_move进行交换</span></span><br><span class="line"></span><br><span class="line">    write_sequnlock(&amp;rename_lock); <span class="comment">// 释放重命名锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_ancestor - 搜索祖先</span></span><br><span class="line"><span class="comment"> * @p1: 祖先dentry</span></span><br><span class="line"><span class="comment"> * @p2: 子dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果p1是p2的祖先，则返回p2的祖先dentry，否则返回NULL。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_ancestor</span><span class="params">(<span class="keyword">struct</span> dentry *p1, <span class="keyword">struct</span> dentry *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = p2; !IS_ROOT(p); p = p-&gt;d_parent) &#123; <span class="comment">// 从p2开始向上遍历dentry的父节点，直到根节点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;d_parent == p1) <span class="comment">// 如果找到p1作为p2的父节点，则返回p2的祖先dentry</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果p1不是p2的祖先，则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This helper attempts to cope with remotely renamed directories</span></span><br><span class="line"><span class="comment"> * 这个辅助函数试图处理远程重命名的目录</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It assumes that the caller is already holding</span></span><br><span class="line"><span class="comment"> * dentry-&gt;d_parent-&gt;d_inode-&gt;i_mutex, and rename_lock</span></span><br><span class="line"><span class="comment"> * 它假设调用者已经持有dentry-&gt;d_parent-&gt;d_inode-&gt;i_mutex和rename_lock</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: If ever the locking in lock_rename() changes, then please</span></span><br><span class="line"><span class="comment"> * remember to update this too...</span></span><br><span class="line"><span class="comment"> * 注意：如果lock_rename()中的锁定发生变化，请记得更新此处...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __d_unalias(<span class="keyword">struct</span> inode *inode,</span><br><span class="line">                      <span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> dentry *alias)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">m1</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 互斥锁m1</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> *<span class="title">m2</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 读写信号量m2</span></span><br><span class="line">    <span class="type">int</span> ret = -ESTALE; <span class="comment">// 返回值，默认为ESTALE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If alias and dentry share a parent, then no extra locks required */</span></span><br><span class="line">    <span class="comment">/* 如果alias和dentry共享一个父节点，则不需要额外的锁 */</span></span><br><span class="line">    <span class="keyword">if</span> (alias-&gt;d_parent == dentry-&gt;d_parent)</span><br><span class="line">        <span class="keyword">goto</span> out_unalias; <span class="comment">// 跳转到out_unalias标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See lock_rename() */</span></span><br><span class="line">    <span class="comment">/* 参见lock_rename() */</span></span><br><span class="line">    <span class="keyword">if</span> (!mutex_trylock(&amp;dentry-&gt;d_sb-&gt;s_vfs_rename_mutex))</span><br><span class="line">        <span class="keyword">goto</span> out_err; <span class="comment">// 如果无法获取vfs_rename_mutex锁，则跳转到out_err标签</span></span><br><span class="line">    m1 = &amp;dentry-&gt;d_sb-&gt;s_vfs_rename_mutex; <span class="comment">// 将vfs_rename_mutex锁赋值给m1</span></span><br><span class="line">    <span class="keyword">if</span> (!inode_trylock_shared(alias-&gt;d_parent-&gt;d_inode))</span><br><span class="line">        <span class="keyword">goto</span> out_err; <span class="comment">// 如果无法获取alias的父节点的inode的共享锁，则跳转到out_err标签</span></span><br><span class="line">    m2 = &amp;alias-&gt;d_parent-&gt;d_inode-&gt;i_rwsem; <span class="comment">// 将alias的父节点的inode的读写信号量赋值给m2</span></span><br><span class="line"></span><br><span class="line">out_unalias:</span><br><span class="line">    __d_move(alias, dentry, <span class="literal">false</span>); <span class="comment">// 调用内部函数__d_move进行移动</span></span><br><span class="line">    ret = <span class="number">0</span>; <span class="comment">// 设置返回值为0，表示成功</span></span><br><span class="line"></span><br><span class="line">out_err:</span><br><span class="line">    <span class="keyword">if</span> (m2)</span><br><span class="line">        up_read(m2); <span class="comment">// 释放读取锁m2</span></span><br><span class="line">    <span class="keyword">if</span> (m1)</span><br><span class="line">        mutex_unlock(m1); <span class="comment">// 释放互斥锁m1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * d_splice_alias - 将一个断开的dentry拼接到树中（如果存在）</span></span><br><span class="line"><span class="comment"> * @inode: 可能有一个断开的dentry的inode</span></span><br><span class="line"><span class="comment"> * @dentry: 我们想要指向该inode的一个负的dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果inode是一个目录并且有一个IS_ROOT别名，则将其d_move到给定的dentry的位置并返回它，否则只是将inode添加到dentry中并返回NULL。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果找到一个非IS_ROOT的目录，则文件系统已损坏，我们应该报错：目录不能有多个别名。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这在任何可导出的文件系统（通过knfsd）的查找例程中是必需的，以便我们可以有效地构建到目录的dcache路径。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果找到并移动了一个dentry，则返回它。否则返回NULL。</span></span><br><span class="line"><span class="comment"> * ... 检查dentry是否已经被哈希，仅在最后一种情况下进行检查。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">d_splice_alias</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(inode))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(inode);</span><br><span class="line"></span><br><span class="line">    BUG_ON(!d_unhashed(dentry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inode-&gt;i_mode &amp; S_IFDIR) &#123; <span class="comment">// 如果inode是一个目录</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">alias</span> =</span> d_find_alias(inode); <span class="comment">// 查找inode的别名</span></span><br><span class="line">        <span class="keyword">if</span> (alias) &#123; <span class="comment">// 如果找到别名</span></span><br><span class="line">            <span class="keyword">if</span> (IS_ROOT(alias)) &#123; <span class="comment">// 如果别名是根目录</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">moved</span> =</span> d_move(alias, dentry); <span class="comment">// 将别名移动到给定的dentry的位置</span></span><br><span class="line">                <span class="keyword">if</span> (moved)</span><br><span class="line">                    <span class="keyword">return</span> moved; <span class="comment">// 返回移动后的dentry</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                WARN_ON(<span class="number">1</span>); <span class="comment">// 文件系统已损坏，目录不能有多个别名</span></span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-EIO); <span class="comment">// 返回错误指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d_add(dentry, inode); <span class="comment">// 将inode添加到dentry中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 返回NULL，表示没有移动dentry</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(d_splice_alias);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Test whether new_dentry is a subdirectory of old_dentry.</span></span><br><span class="line"><span class="comment"> * 测试new_dentry是否是old_dentry的子目录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Trivially implemented using the dcache structure</span></span><br><span class="line"><span class="comment"> * 使用dcache结构简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is_subdir - is new dentry a subdirectory of old_dentry</span></span><br><span class="line"><span class="comment"> * is_subdir - 判断new_dentry是否是old_dentry的子目录</span></span><br><span class="line"><span class="comment"> * @new_dentry: new dentry</span></span><br><span class="line"><span class="comment"> * @old_dentry: old dentry</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns true if new_dentry is a subdirectory of the parent (at any depth).</span></span><br><span class="line"><span class="comment"> * 返回true，如果new_dentry是父目录的子目录（在任何深度）。</span></span><br><span class="line"><span class="comment"> * Returns false otherwise.</span></span><br><span class="line"><span class="comment"> * 否则返回false。</span></span><br><span class="line"><span class="comment"> * Caller must ensure that &quot;new_dentry&quot; is pinned before calling is_subdir()</span></span><br><span class="line"><span class="comment"> * 调用者必须确保在调用is_subdir()之前&quot;new_dentry&quot;已经被固定。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_subdir</span><span class="params">(<span class="keyword">struct</span> dentry *new_dentry, <span class="keyword">struct</span> dentry *old_dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> result;</span><br><span class="line">    <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_dentry == old_dentry)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果new_dentry和old_dentry相等，则返回true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* for restarting inner loop in case of seq retry */</span></span><br><span class="line">        seq = read_seqbegin(&amp;rename_lock); <span class="comment">// 读取序列号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Need rcu_readlock ... to protect against the d_parent trashing</span></span><br><span class="line"><span class="comment">         * due to d_move</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rcu_read_lock(); <span class="comment">// 获取RCU读锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d_ancestor(old_dentry, new_dentry))</span><br><span class="line">            result = <span class="literal">true</span>; <span class="comment">// 如果new_dentry是old_dentry的祖先目录，则设置result为true</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = <span class="literal">false</span>; <span class="comment">// 否则设置result为false</span></span><br><span class="line"></span><br><span class="line">        rcu_read_unlock(); <span class="comment">// 释放RCU读锁</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (read_seqretry(&amp;rename_lock, seq)); <span class="comment">// 如果序列号重试，则重新执行循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(is_subdir); <span class="comment">// 导出is_subdir符号</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">enum</span> d_walk_ret <span class="title function_">d_genocide_kill</span><span class="params">(<span class="type">void</span> *data, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root</span> =</span> data; <span class="comment">// 获取根节点</span></span><br><span class="line">    <span class="keyword">if</span> (dentry != root) &#123; <span class="comment">// 如果dentry不是根节点</span></span><br><span class="line">        <span class="keyword">if</span> (d_unhashed(dentry) || !dentry-&gt;d_inode) <span class="comment">// 如果dentry未哈希或者没有关联的inode</span></span><br><span class="line">            <span class="keyword">return</span> D_WALK_SKIP; <span class="comment">// 跳过该dentry</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(dentry-&gt;d_flags &amp; DCACHE_GENOCIDE)) &#123; <span class="comment">// 如果dentry的标志位中没有DCACHE_GENOCIDE标志</span></span><br><span class="line">            dentry-&gt;d_flags |= DCACHE_GENOCIDE; <span class="comment">// 设置dentry的标志位为DCACHE_GENOCIDE</span></span><br><span class="line">            dentry-&gt;d_lockref.count--; <span class="comment">// 减少dentry的锁引用计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> D_WALK_CONTINUE; <span class="comment">// 返回D_WALK_CONTINUE，表示继续遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">d_genocide</span><span class="params">(<span class="keyword">struct</span> dentry *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遍历父目录下的所有目录项，并调用d_genocide_kill函数</span></span><br><span class="line">    d_walk(parent, parent, d_genocide_kill);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(d_genocide);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">d_tmpfile</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件的目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> file-&gt;f_path.dentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减少inode的链接计数</span></span><br><span class="line">    inode_dec_link_count(inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查目录项的名称是否等于目录项的内部名称</span></span><br><span class="line">    <span class="comment">// 检查目录项是否未在别名哈希表中</span></span><br><span class="line">    <span class="comment">// 检查目录项是否已被删除</span></span><br><span class="line">    BUG_ON(dentry-&gt;d_name.name != dentry-&gt;d_iname ||</span><br><span class="line">           !hlist_unhashed(&amp;dentry-&gt;d_u.d_alias) ||</span><br><span class="line">           !d_unlinked(dentry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目录项的父目录锁和目录项锁</span></span><br><span class="line">    spin_lock(&amp;dentry-&gt;d_parent-&gt;d_lock);</span><br><span class="line">    spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将inode的编号转换为字符串，并更新目录项的名称和内部名称</span></span><br><span class="line">    dentry-&gt;d_name.len = <span class="built_in">sprintf</span>(dentry-&gt;d_iname, <span class="string">&quot;#%llu&quot;</span>,</span><br><span class="line">                                 (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)inode-&gt;i_ino);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放目录项锁和父目录锁</span></span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_lock);</span><br><span class="line">    spin_unlock(&amp;dentry-&gt;d_parent-&gt;d_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目录项中实例化inode</span></span><br><span class="line">    d_instantiate(dentry, inode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(d_tmpfile);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __initdata <span class="type">unsigned</span> <span class="type">long</span> dhash_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置dhash_entries的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">set_dhash_entries</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dhash_entries = simple_strtoul(str, &amp;str, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在内核启动时设置dhash_entries的值</span></span><br><span class="line">__setup(<span class="string">&quot;dhash_entries=&quot;</span>, set_dhash_entries);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">dcache_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果哈希分布在NUMA节点上，则延迟哈希分配直到vmalloc空间可用</span></span><br><span class="line">    <span class="keyword">if</span> (hashdist)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配dentry哈希表</span></span><br><span class="line">    dentry_hashtable =</span><br><span class="line">        alloc_large_system_hash(<span class="string">&quot;Dentry cache&quot;</span>,</span><br><span class="line">                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hlist_bl_head),</span><br><span class="line">                                dhash_entries,</span><br><span class="line">                                <span class="number">13</span>,</span><br><span class="line">                                HASH_EARLY | HASH_ZERO,</span><br><span class="line">                                &amp;d_hash_shift,</span><br><span class="line">                                <span class="literal">NULL</span>,</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                <span class="number">0</span>);</span><br><span class="line">    d_hash_shift = <span class="number">32</span> - d_hash_shift;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">dcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 可以为稳定状态（如列表）添加构造函数，但由于dcache的缓存特性，可能不值得这样做。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建dentry缓存</span></span><br><span class="line">    dentry_cache = KMEM_CACHE_USERCOPY(dentry,</span><br><span class="line">                                       SLAB_RECLAIM_ACCOUNT | SLAB_PANIC | SLAB_MEM_SPREAD | SLAB_ACCOUNT,</span><br><span class="line">                                       d_iname);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果在dcache_init_early中设置了哈希表，则直接返回 */</span></span><br><span class="line">    <span class="keyword">if</span> (!hashdist)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配dentry哈希表</span></span><br><span class="line">    dentry_hashtable =</span><br><span class="line">        alloc_large_system_hash(<span class="string">&quot;Dentry cache&quot;</span>,</span><br><span class="line">                                <span class="keyword">sizeof</span>(<span class="keyword">struct</span> hlist_bl_head),</span><br><span class="line">                                dhash_entries,</span><br><span class="line">                                <span class="number">13</span>,</span><br><span class="line">                                HASH_ZERO,</span><br><span class="line">                                &amp;d_hash_shift,</span><br><span class="line">                                <span class="literal">NULL</span>,</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                <span class="number">0</span>);</span><br><span class="line">    d_hash_shift = <span class="number">32</span> - d_hash_shift;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用于__getname()函数的SLAB缓存 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">names_cachep</span> __<span class="title">read_mostly</span>;</span></span><br><span class="line">EXPORT_SYMBOL(names_cachep);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">vfs_caches_init_early</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化in_lookup_hashtable数组中的每个哈希表头</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(in_lookup_hashtable); i++)</span><br><span class="line">        INIT_HLIST_BL_HEAD(&amp;in_lookup_hashtable[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化dcache</span></span><br><span class="line">    dcache_init_early();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化inode</span></span><br><span class="line">    inode_init_early();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">vfs_caches_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建names_cachep缓存</span></span><br><span class="line">    names_cachep = kmem_cache_create_usercopy(<span class="string">&quot;names_cache&quot;</span>, PATH_MAX, <span class="number">0</span>,</span><br><span class="line">                                              SLAB_HWCACHE_ALIGN | SLAB_PANIC, <span class="number">0</span>, PATH_MAX, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化dcache</span></span><br><span class="line">    dcache_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化inode</span></span><br><span class="line">    inode_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化files</span></span><br><span class="line">    files_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化files_maxfiles</span></span><br><span class="line">    files_maxfiles_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化mnt</span></span><br><span class="line">    mnt_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化bdev缓存</span></span><br><span class="line">    bdev_cache_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化chrdev</span></span><br><span class="line">    chrdev_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/29/%E5%AD%A6%E4%B9%A0-Linux-fs-namei-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="prev" title="学习 Linux /fs/namei.c源码分析">
      <i class="fa fa-chevron-left"></i> 学习 Linux /fs/namei.c源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/17/%E5%AD%A6%E4%B9%A0-Linux-fs-namespace-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="学习 Linux fs/namespace.c源码分析">
      学习 Linux fs/namespace.c源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plucky</p>
  <div class="site-description" itemprop="description">记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Plucky923" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Plucky923" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:p1ucky@163.com" title="E-Mail → mailto:p1ucky@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plucky</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">31:13</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '3420f2814bb4c3c82f84',
      clientSecret: '9d285617447c550188bd893fc3aad7c9b00f2d00',
      repo        : 'Blog-talk',
      owner       : 'Plucky923',
      admin       : ['Plucky923'],
      id          : '49df9203d6ec4facc38fc05d30e123c6',
        language: 'zh-CH',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
