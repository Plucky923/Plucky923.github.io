<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="namei.c - fs&#x2F;namei.c - Linux source code (v6.3.7) - Bootlin 12#define EMBEDDED_NAME_MAX    (PATH_MAX - offsetof(struct filename, iname))&#x2F;&#x2F; 定义 EMBEDDED_NAME_MAX，这是嵌入式文件名的最大长度。长度等于 PATH_MAX（一个路径的最大">
<meta property="og:type" content="article">
<meta property="og:title" content="学习 Linux &#x2F;fs&#x2F;namei.c源码分析">
<meta property="og:url" content="http://example.com/2023/07/29/%E5%AD%A6%E4%B9%A0-Linux-fs-namei-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Plucky">
<meta property="og:description" content="namei.c - fs&#x2F;namei.c - Linux source code (v6.3.7) - Bootlin 12#define EMBEDDED_NAME_MAX    (PATH_MAX - offsetof(struct filename, iname))&#x2F;&#x2F; 定义 EMBEDDED_NAME_MAX，这是嵌入式文件名的最大长度。长度等于 PATH_MAX（一个路径的最大">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-07-29T01:11:29.000Z">
<meta property="article:modified_time" content="2023-08-20T10:35:57.890Z">
<meta property="article:author" content="Plucky">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/07/29/%E5%AD%A6%E4%B9%A0-Linux-fs-namei-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>学习 Linux /fs/namei.c源码分析 | Plucky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Plucky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Comfortably Numb</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/29/%E5%AD%A6%E4%B9%A0-Linux-fs-namei-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习 Linux /fs/namei.c源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-29 09:11:29" itemprop="dateCreated datePublished" datetime="2023-07-29T09:11:29+08:00">2023-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-20 18:35:57" itemprop="dateModified" datetime="2023-08-20T18:35:57+08:00">2023-08-20</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>143k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4:20</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v6.3.7/source/fs/namei.c">namei.c - fs&#x2F;namei.c - Linux source code (v6.3.7) - Bootlin</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EMBEDDED_NAME_MAX    (PATH_MAX - offsetof(struct filename, iname))</span></span><br><span class="line"><span class="comment">// 定义 EMBEDDED_NAME_MAX，这是嵌入式文件名的最大长度。长度等于 PATH_MAX（一个路径的最大长度）减去 struct filename 中 iname 字段的偏移量。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> filename *</span><br><span class="line"><span class="title function_">getname_flags</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> flags, <span class="type">int</span> *empty)</span></span><br><span class="line"><span class="comment">// 这个函数是从用户空间获取文件名，并将其复制到内核空间。函数接受三个参数：用户提供的文件名，一组标志，以及一个指向整数的指针，用于指示路径是否为空。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="type">char</span> *kname;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 定义三个变量：一个指向 struct filename 的指针，一个字符指针，以及一个整数。</span></span><br><span class="line"></span><br><span class="line">    result = audit_reusename(filename);</span><br><span class="line">    <span class="comment">// 尝试重用给定的文件名。如果成功，返回指向重用的文件名的指针。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 如果重用成功，返回结果。</span></span><br><span class="line"></span><br><span class="line">    result = __getname();</span><br><span class="line">    <span class="comment">// 尝试从名字缓存中获取一个新的文件名。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!result))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    <span class="comment">// 如果无法获取新的文件名（可能是因为内存不足），则返回错误。</span></span><br><span class="line"></span><br><span class="line">    kname = (<span class="type">char</span> *)result-&gt;iname;</span><br><span class="line">    <span class="comment">// 获取新文件名的 iname 字段，这是一个内部的名字。</span></span><br><span class="line"></span><br><span class="line">    result-&gt;name = kname;</span><br><span class="line">    <span class="comment">// 将内部名字赋给外部名字。</span></span><br><span class="line"></span><br><span class="line">    len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);</span><br><span class="line">    <span class="comment">// 尝试从用户空间复制文件名到内核空间。最多复制 EMBEDDED_NAME_MAX 个字符。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(len &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        __putname(result);</span><br><span class="line">        <span class="comment">// 如果复制失败，释放之前获取的文件名。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(len);</span><br><span class="line">        <span class="comment">// 返回错误。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(len == EMBEDDED_NAME_MAX)) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> size = offsetof(<span class="keyword">struct</span> filename, iname[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 如果复制的长度等于 EMBEDDED_NAME_MAX，需要重新分配内存。计算新的大小。</span></span><br><span class="line"></span><br><span class="line">        kname = (<span class="type">char</span> *)result;</span><br><span class="line">        <span class="comment">// 保存当前的结果。</span></span><br><span class="line"></span><br><span class="line">        result = kzalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="comment">// 为新的文件名分配内存。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!result)) &#123;</span><br><span class="line">            __putname(kname);</span><br><span class="line">            <span class="comment">// 如果分配失败，释放之前的结果。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">            <span class="comment">// 返回错误。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result-&gt;name = kname;</span><br><span class="line">        <span class="comment">// 将名字赋给新的结果。</span></span><br><span class="line"></span><br><span class="line">        len = strncpy_from_user(kname, filename, PATH_MAX);</span><br><span class="line">        <span class="comment">// 从用户空间复制文件名到内核空间。这次复制的最大长度是 PATH_MAX。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(len &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            __putname(kname);</span><br><span class="line">            <span class="comment">// 如果复制失败，释放之前的结果。</span></span><br><span class="line"></span><br><span class="line">            kfree(result);</span><br><span class="line">            <span class="comment">// 释放新的结果。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(len);</span><br><span class="line">            <span class="comment">// 返回错误。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(len == PATH_MAX)) &#123;</span><br><span class="line">            __putname(kname);</span><br><span class="line">            <span class="comment">// 如果复制的长度等于 PATH_MAX，释放之前的结果。</span></span><br><span class="line"></span><br><span class="line">            kfree(result);</span><br><span class="line">            <span class="comment">// 释放新的结果。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENAMETOOLONG);</span><br><span class="line">            <span class="comment">// 返回错误，表示名字过长。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置新的结果的引用计数为 1。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (empty)</span><br><span class="line">            *empty = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果文件名的长度为 0（即文件名为空），设置 *empty 为 1。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; LOOKUP_EMPTY)) &#123;</span><br><span class="line">            putname(result);</span><br><span class="line">            <span class="comment">// 如果不允许查找空的文件名，释放结果。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">            <span class="comment">// 返回错误，表示没有这个文件或目录。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result-&gt;uptr = filename;</span><br><span class="line">    result-&gt;uptr = filename;</span><br><span class="line">    <span class="comment">// 设置新的结果的用户空间指针为传入的 filename。</span></span><br><span class="line"></span><br><span class="line">    result-&gt;aname = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置新的结果的审计名字为 NULL。</span></span><br><span class="line"></span><br><span class="line">    audit_getname(result);</span><br><span class="line">    <span class="comment">// 获取新的结果的审计名字。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 返回新的结果。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> filename *</span><br><span class="line"><span class="title function_">getname_uflags</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> uflags)</span></span><br><span class="line"><span class="comment">// 这个函数用于根据用户空间的标志获取文件名。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flags = (uflags &amp; AT_EMPTY_PATH) ? LOOKUP_EMPTY : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果用户空间的标志包含 AT_EMPTY_PATH，则设置内核空间的标志为 LOOKUP_EMPTY；否则设置为 0。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getname_flags(filename, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 调用 getname_flags 函数获取文件名，并传入上面计算出的标志。这个函数不处理 &quot;empty&quot; 参数，所以直接传入 NULL。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> filename *</span><br><span class="line"><span class="title function_">getname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user * filename)</span></span><br><span class="line"><span class="comment">// 这个函数用于获取文件名，不接受任何标志。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getname_flags(filename, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 调用 getname_flags 函数获取文件名，标志设置为 0，不处理 &quot;empty&quot; 参数，所以直接传入 NULL。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> filename *</span><br><span class="line"><span class="title function_">getname_kernel</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * filename)</span></span><br><span class="line"><span class="comment">// 这个函数用于获取内核空间的文件名。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">result</span>;</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(filename) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 定义一个指向 struct filename 的指针，并计算文件名的长度（包括结束符）。</span></span><br><span class="line"></span><br><span class="line">    result = __getname();</span><br><span class="line">    <span class="comment">// 从名字缓存中获取一个新的文件名。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!result))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    <span class="comment">// 如果无法获取新的文件名（可能是因为内存不足），则返回错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= EMBEDDED_NAME_MAX) &#123;</span><br><span class="line">        result-&gt;name = (<span class="type">char</span> *)result-&gt;iname;</span><br><span class="line">        <span class="comment">// 如果文件名的长度小于等于 EMBEDDED_NAME_MAX，则将文件名存储在 iname 字段中。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &lt;= PATH_MAX) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> size = offsetof(<span class="keyword">struct</span> filename, iname[<span class="number">1</span>]);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">tmp</span>;</span></span><br><span class="line">        <span class="comment">// 如果文件名的长度大于 EMBEDDED_NAME_MAX 但小于等于 PATH_MAX，则需要重新分配内存。计算新的大小。</span></span><br><span class="line"></span><br><span class="line">        tmp = kmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="comment">// 为新的文件名分配内存。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!tmp)) &#123;</span><br><span class="line">            __putname(result);</span><br><span class="line">            <span class="comment">// 如果分配失败，释放之前获取的文件名。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">            <span class="comment">// 返回错误。</span></span><br><span class="line">        &#125;</span><br><span class="line">        tmp-&gt;name = (<span class="type">char</span> *)result;</span><br><span class="line">        <span class="comment">// 将之前获取的文件名赋给新的文件名。</span></span><br><span class="line"></span><br><span class="line">        result = tmp;</span><br><span class="line">        <span class="comment">// 更新结果。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __putname(result);</span><br><span class="line">        <span class="comment">// 如果文件名的长度大于 PATH_MAX，释放之前获取的文件名。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENAMETOOLONG);</span><br><span class="line">        <span class="comment">// 返回错误，表示名字过长。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">char</span> *)result-&gt;name, filename, len);</span><br><span class="line">    <span class="comment">// 复制文件名到结果。</span></span><br><span class="line"></span><br><span class="line">    result-&gt;uptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置用户空间指针为 NULL，因为这个函数接受的是内核空间的文件名。</span></span><br><span class="line"></span><br><span class="line">    result-&gt;aname = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置审计名字为 NULL。</span></span><br><span class="line"></span><br><span class="line">    result-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置引用计数为 1。</span></span><br><span class="line"></span><br><span class="line">    audit_getname(result);</span><br><span class="line">    <span class="comment">// 获取审计名字。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// 返回结果。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">putname</span><span class="params">(<span class="keyword">struct</span> filename *name)</span></span><br><span class="line"><span class="comment">// 这个函数用于减少文件名的引用计数，当引用计数为 0 时释放文件名。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(name))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果文件名是一个错误指针，直接返回。</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(name-&gt;refcnt &lt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果文件名的引用计数小于等于 0，触发 BUG。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (--name-&gt;refcnt &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 减少文件名的引用计数，如果引用计数大于 0，直接返回。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name-&gt;name != name-&gt;iname) &#123;</span><br><span class="line">        __putname(name-&gt;name);</span><br><span class="line">        kfree(name);</span><br><span class="line">        <span class="comment">// 如果文件名不是存储在 iname 字段中的，调用 __putname 释放文件名，并释放整个 filename 结构。</span></span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        __putname(name);</span><br><span class="line">        <span class="comment">// 否则，直接调用 __putname 释放整个 filename 结构。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check_acl - perform ACL permission checking</span></span><br><span class="line"><span class="comment"> * @idmap:    idmap of the mount the inode was found from</span></span><br><span class="line"><span class="comment"> * @inode:    inode to check permissions on</span></span><br><span class="line"><span class="comment"> * @mask:     right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function performs the ACL permission checking. Since this function</span></span><br><span class="line"><span class="comment"> * retrieve POSIX acls it needs to know whether it is called from a blocking or</span></span><br><span class="line"><span class="comment"> * non-blocking context and thus cares about the MAY_NOT_BLOCK bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the inode has been found through an idmapped mount the idmap of</span></span><br><span class="line"><span class="comment"> * the vfsmount must be passed through @idmap. This function will then take</span></span><br><span class="line"><span class="comment"> * care to map the inode according to @idmap before checking permissions.</span></span><br><span class="line"><span class="comment"> * On non-idmapped mounts or if permission checking is to be performed on the</span></span><br><span class="line"><span class="comment"> * raw inode simply pass @nop_mnt_idmap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">check_acl</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> inode *inode, <span class="type">int</span> mask)</span></span><br><span class="line"><span class="comment">// 这个函数用于检查 ACL 访问权限。如果文件节点是通过 idmapped 挂载找到的，需要传入 idmap 参数，这个函数会在检查权限之前先映射文件节点。</span></span><br><span class="line"><span class="comment">// 对于非 idmapped 挂载，或者要检查原始文件节点的权限，直接传入 nop_mnt_idmap。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="comment">// 如果启用了 POSIX ACL，执行以下代码。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> *<span class="title">acl</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; MAY_NOT_BLOCK) &#123;</span><br><span class="line">        acl = get_cached_acl_rcu(inode, ACL_TYPE_ACCESS);</span><br><span class="line">            <span class="keyword">if</span> (!acl)</span><br><span class="line">                    <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        <span class="comment">// 如果 mask 包含 MAY_NOT_BLOCK，从 RCU 缓存中获取 ACL，如果获取不到，返回 -EAGAIN。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* no -&gt;get_inode_acl() calls in RCU mode... */</span></span><br><span class="line">        <span class="keyword">if</span> (is_uncached_acl(acl))</span><br><span class="line">            <span class="keyword">return</span> -ECHILD;</span><br><span class="line">        <span class="comment">// 在 RCU 模式下不调用 get_inode_acl()，如果 ACL 不在缓存中，返回 -ECHILD。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> posix_acl_permission(idmap, inode, acl, mask);</span><br><span class="line">        <span class="comment">// 返回 posix_acl_permission 的调用结果，此函数用于检查权限。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acl = get_inode_acl(inode, ACL_TYPE_ACCESS);</span><br><span class="line">    <span class="comment">// 获取 inode 的 ACL。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(acl))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(acl);</span><br><span class="line">    <span class="comment">// 如果 ACL 是一个错误指针，返回错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (acl) &#123;</span><br><span class="line">            <span class="type">int</span> error = posix_acl_permission(idmap, inode, acl, mask);</span><br><span class="line">            posix_acl_release(acl);</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        <span class="comment">// 如果 ACL 存在，检查权限，然后释放 ACL，返回检查结果。</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">    <span class="comment">// 如果未启用 POSIX ACL，或者 ACL 不存在，返回 -EAGAIN。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * acl_permission_check - perform basic UNIX permission checking</span></span><br><span class="line"><span class="comment"> * @idmap:    idmap of the mount the inode was found from</span></span><br><span class="line"><span class="comment"> * @inode:    inode to check permissions on</span></span><br><span class="line"><span class="comment"> * @mask:    right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC ...)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function performs the basic UNIX permission checking. Since this</span></span><br><span class="line"><span class="comment"> * function may retrieve POSIX acls it needs to know whether it is called from a</span></span><br><span class="line"><span class="comment"> * blocking or non-blocking context and thus cares about the MAY_NOT_BLOCK bit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the inode has been found through an idmapped mount the idmap of</span></span><br><span class="line"><span class="comment"> * the vfsmount must be passed through @idmap. This function will then take</span></span><br><span class="line"><span class="comment"> * care to map the inode according to @idmap before checking permissions.</span></span><br><span class="line"><span class="comment"> * On non-idmapped mounts or if permission checking is to be performed on the</span></span><br><span class="line"><span class="comment"> * raw inode simply passs @nop_mnt_idmap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">acl_permission_check</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> inode *inode, <span class="type">int</span> mask)</span></span><br><span class="line"><span class="comment">// 这个函数执行基本的UNIX权限检查。如果文件节点是通过 idmapped 挂载找到的，需要传入 idmap 参数，这个函数会在检查权限之前先映射文件节点。</span></span><br><span class="line"><span class="comment">// 对于非 idmapped 挂载，或者要检查原始文件节点的权限，直接传入 nop_mnt_idmap。</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mode = inode-&gt;i_mode;</span><br><span class="line">    <span class="comment">// 获取 inode 的模式。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">vfsuid_t</span> vfsuid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Are we the owner? If so, ACL&#x27;s don&#x27;t matter */</span></span><br><span class="line">    vfsuid = i_uid_into_vfsuid(idmap, inode);</span><br><span class="line">    <span class="keyword">if</span> (likely(vfsuid_eq_kuid(vfsuid, current_fsuid()))) &#123;</span><br><span class="line">        mask &amp;= <span class="number">7</span>;</span><br><span class="line">        mode &gt;&gt;= <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">return</span> (mask &amp; ~mode) ? -EACCES : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我们是所有者，ACL无关紧要。我们只需检查用户的权限。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do we have ACL&#x27;s? */</span></span><br><span class="line">    <span class="keyword">if</span> (IS_POSIXACL(inode) &amp;&amp; (mode &amp; S_IRWXG)) &#123;</span><br><span class="line">        <span class="type">int</span> error = check_acl(idmap, inode, mask);</span><br><span class="line">        <span class="keyword">if</span> (error != -EAGAIN)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果我们有ACL，并且设置了组权限，我们需要检查ACL。如果没有错误发生，返回检查的结果。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only RWX matters for group/other mode bits */</span></span><br><span class="line">    mask &amp;= <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// 仅保留RWX（读/写/执行）权限位。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Are the group permissions different from</span></span><br><span class="line"><span class="comment">     * the other permissions in the bits we care</span></span><br><span class="line"><span class="comment">     * about? Need to check group ownership if so.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; (mode ^ (mode &gt;&gt; <span class="number">3</span>))) &#123;</span><br><span class="line">        <span class="type">vfsgid_t</span> vfsgid = i_gid_into_vfsgid(idmap, inode);</span><br><span class="line">        <span class="keyword">if</span> (vfsgid_in_group_p(vfsgid))</span><br><span class="line">            mode &gt;&gt;= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果组权限与其他权限在我们关心的位上不同，我们需要检查组所有权。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bits in &#x27;mode&#x27; clear that we require? */</span></span><br><span class="line">    <span class="keyword">return</span> (mask &amp; ~mode) ? -EACCES : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果我们需要的权限位在&#x27;mode&#x27;中被清除了，返回 -EACCES，否则返回 0。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generic_permission -  check for access rights on a Posix-like filesystem</span></span><br><span class="line"><span class="comment"> * @idmap:    idmap of the mount the inode was found from</span></span><br><span class="line"><span class="comment"> * @inode:    inode to check access rights for</span></span><br><span class="line"><span class="comment"> * @mask:    right to check for (%MAY_READ, %MAY_WRITE, %MAY_EXEC,</span></span><br><span class="line"><span class="comment"> *        %MAY_NOT_BLOCK ...)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Used to check for read/write/execute permissions on a file.</span></span><br><span class="line"><span class="comment"> * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions</span></span><br><span class="line"><span class="comment"> * for filesystem access without changing the &quot;normal&quot; uids which</span></span><br><span class="line"><span class="comment"> * are used for other things.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * generic_permission is rcu-walk aware. It returns -ECHILD in case an rcu-walk</span></span><br><span class="line"><span class="comment"> * request cannot be satisfied (eg. requires blocking or too much complexity).</span></span><br><span class="line"><span class="comment"> * It would then be called again in ref-walk mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the inode has been found through an idmapped mount the idmap of</span></span><br><span class="line"><span class="comment"> * the vfsmount must be passed through @idmap. This function will then take</span></span><br><span class="line"><span class="comment"> * care to map the inode according to @idmap before checking permissions.</span></span><br><span class="line"><span class="comment"> * On non-idmapped mounts or if permission checking is to be performed on the</span></span><br><span class="line"><span class="comment"> * raw inode simply passs @nop_mnt_idmap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">generic_permission</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do the basic permission checks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = acl_permission_check(idmap, inode, mask);</span><br><span class="line">    <span class="keyword">if</span> (ret != -EACCES)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// 首先进行基本权限检查，如果返回值不是 -EACCES，则直接返回结果。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123;</span><br><span class="line">        <span class="comment">/* DACs are overridable for directories */</span></span><br><span class="line">        <span class="keyword">if</span> (!(mask &amp; MAY_WRITE))</span><br><span class="line">            <span class="keyword">if</span> (capable_wrt_inode_uidgid(idmap, inode,</span><br><span class="line">                             CAP_DAC_READ_SEARCH))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (capable_wrt_inode_uidgid(idmap, inode,</span><br><span class="line">                         CAP_DAC_OVERRIDE))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 inode 是目录，特权用户可以覆盖 DAC 权限。如果没有写权限，但用户有 CAP_DAC_READ_SEARCH 能力，则返回0。</span></span><br><span class="line">    <span class="comment">// 如果用户有 CAP_DAC_OVERRIDE 能力，则返回0。否则返回 -EACCES。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Searching includes executable on directories, else just read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mask &amp;= MAY_READ | MAY_WRITE | MAY_EXEC;</span><br><span class="line">    <span class="keyword">if</span> (mask == MAY_READ)</span><br><span class="line">        <span class="keyword">if</span> (capable_wrt_inode_uidgid(idmap, inode,</span><br><span class="line">                         CAP_DAC_READ_SEARCH))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果权限掩码仅包含读权限，而用户具有 CAP_DAC_READ_SEARCH 能力，则返回 0。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Read/write DACs are always overridable.</span></span><br><span class="line"><span class="comment">     * Executable DACs are overridable when there is</span></span><br><span class="line"><span class="comment">     * at least one exec bit set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(mask &amp; MAY_EXEC) || (inode-&gt;i_mode &amp; S_IXUGO))</span><br><span class="line">        <span class="keyword">if</span> (capable_wrt_inode_uidgid(idmap, inode,</span><br><span class="line">                         CAP_DAC_OVERRIDE))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读/写 DAC 总是可以被覆盖。如果权限掩码中没有执行权限，或者 inode 的模式中至少有一个执行位，而用户具有 CAP_DAC_OVERRIDE 能力，则返回 0。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">    <span class="comment">// 如果上述所有条件都不满足，返回 -EACCES。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(generic_permission);</span><br><span class="line"><span class="comment">// 将函数 generic_permission 导出，使其可以被其他模块使用。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">do_inode_permission</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *inode, <span class="type">int</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果inode的操作标记与IOP_FASTPERM做AND运算的结果不为真（也就是说，inode没有设置使用快速权限检查的标记）</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!(inode-&gt;i_opflags &amp; IOP_FASTPERM))) &#123;</span><br><span class="line">        <span class="comment">// 如果inode的操作对象有权限检查函数</span></span><br><span class="line">        <span class="keyword">if</span> (likely(inode-&gt;i_op-&gt;permission))</span><br><span class="line">            <span class="comment">// 则调用该函数进行权限检查</span></span><br><span class="line">            <span class="keyword">return</span> inode-&gt;i_op-&gt;permission(idmap, inode, mask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果inode的操作对象没有权限检查函数，则获取inode的锁</span></span><br><span class="line">        spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">        <span class="comment">// 并设置使用快速权限检查的标记</span></span><br><span class="line">        inode-&gt;i_opflags |= IOP_FASTPERM;</span><br><span class="line">        <span class="comment">// 释放inode的锁</span></span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果inode设置了使用快速权限检查的标记，或者inode的操作对象没有权限检查函数，则直接调用通用权限检查函数</span></span><br><span class="line">    <span class="keyword">return</span> generic_permission(idmap, inode, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sb_permission</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="keyword">struct</span> inode *inode, <span class="type">int</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果请求的权限包含写权限</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(mask &amp; MAY_WRITE)) &#123;</span><br><span class="line">        <span class="comment">// 获取inode的模式</span></span><br><span class="line">        <span class="type">umode_t</span> mode = inode-&gt;i_mode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果文件系统是只读的，并且inode是常规文件、目录或者符号链接</span></span><br><span class="line">        <span class="keyword">if</span> (sb_rdonly(sb) &amp;&amp; (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))</span><br><span class="line">            <span class="comment">// 则返回错误，因为没有人能够获取只读文件系统的写权限</span></span><br><span class="line">            <span class="keyword">return</span> -EROFS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求的权限不包含写权限，或者文件系统不是只读的，或者inode不是常规文件、目录或者符号链接，则返回成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inode_permission</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *inode, <span class="type">int</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先进行超级块级别的权限检查</span></span><br><span class="line">    retval = sb_permission(inode-&gt;i_sb, inode, mask);</span><br><span class="line">    <span class="comment">// 如果返回错误，则直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求的权限包含写权限</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(mask &amp; MAY_WRITE)) &#123;</span><br><span class="line">        <span class="comment">// 如果inode是不可变的</span></span><br><span class="line">        <span class="keyword">if</span> (IS_IMMUTABLE(inode))</span><br><span class="line">            <span class="comment">// 则返回错误，因为没有人能够获取不可变文件的写权限</span></span><br><span class="line">            <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果更新mtime可能导致i_uid和i_gid被错误地写回，例如它们的真实值对vfs来说是未知的</span></span><br><span class="line">        <span class="keyword">if</span> (HAS_UNMAPPED_ID(idmap, inode))</span><br><span class="line">            <span class="comment">// 则返回错误</span></span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后进行inode级别的权限检查</span></span><br><span class="line">    retval = do_inode_permission(idmap, inode, mask);</span><br><span class="line">    <span class="comment">// 如果返回错误，则直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后进行设备控制组级别的权限检查</span></span><br><span class="line">    retval = devcgroup_inode_permission(inode, mask);</span><br><span class="line">    <span class="comment">// 如果返回错误，则直接返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后进行安全模块级别的权限检查</span></span><br><span class="line">    <span class="keyword">return</span> security_inode_permission(inode, mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出inode_permission符号，使得其他模块可以使用该函数</span></span><br><span class="line">EXPORT_SYMBOL(inode_permission);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * path_get - 增加路径的引用计数</span></span><br><span class="line"><span class="comment"> * @path: 要增加引用计数的路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个路径，增加其目录项（dentry）和虚拟文件系统挂载点（vfsmount）的引用计数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">path_get</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 增加虚拟文件系统挂载点的引用计数</span></span><br><span class="line">    mntget(path-&gt;mnt);</span><br><span class="line">    <span class="comment">// 增加目录项的引用计数</span></span><br><span class="line">    dget(path-&gt;dentry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出path_get符号，使得其他模块可以使用该函数</span></span><br><span class="line">EXPORT_SYMBOL(path_get);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * path_put - 减少路径的引用计数</span></span><br><span class="line"><span class="comment"> * @path: 要减少引用计数的路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个路径，减少其目录项（dentry）和虚拟文件系统挂载点（vfsmount）的引用计数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">path_put</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 减少目录项的引用计数</span></span><br><span class="line">    dput(path-&gt;dentry);</span><br><span class="line">    <span class="comment">// 减少虚拟文件系统挂载点的引用计数</span></span><br><span class="line">    mntput(path-&gt;mnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出path_put符号，使得其他模块可以使用该函数</span></span><br><span class="line">EXPORT_SYMBOL(path_put);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义嵌套层级为2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EMBEDDED_LEVELS 2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nameidata 结构体，用于处理文件名查找时的路径名解析</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> &#123;</span></span><br><span class="line">    <span class="comment">// 保存被查找对象的路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>    <span class="title">path</span>;</span></span><br><span class="line">    <span class="comment">// 保存最后一个被解析的路径组件名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span>    <span class="title">last</span>;</span></span><br><span class="line">    <span class="comment">// 保存查找的根路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>    <span class="title">root</span>;</span></span><br><span class="line">    <span class="comment">// 指向路径中目录项的inode节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>    *<span class="title">inode</span>;</span> <span class="comment">/* path.dentry.d_inode */</span></span><br><span class="line">    <span class="comment">// 查找标记</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    flags, state;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="type">unsigned</span>    seq, next_seq, m_seq, r_seq;</span><br><span class="line">    <span class="comment">// 上一次解析的路径组件类型</span></span><br><span class="line">    <span class="type">int</span>        last_type;</span><br><span class="line">    <span class="comment">// 嵌套深度</span></span><br><span class="line">    <span class="type">unsigned</span>    depth;</span><br><span class="line">    <span class="comment">// 符号链接的总数</span></span><br><span class="line">    <span class="type">int</span>        total_link_count;</span><br><span class="line">    <span class="comment">// 保存之前的状态，用于在处理符号链接时回溯</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> &#123;</span></span><br><span class="line">        <span class="comment">// 符号链接的路径</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">link</span>;</span></span><br><span class="line">        <span class="comment">// 延迟调用的函数</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">delayed_call</span> <span class="title">done</span>;</span></span><br><span class="line">        <span class="comment">// 符号链接的名称</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">        <span class="comment">// 序列号</span></span><br><span class="line">        <span class="type">unsigned</span> seq;</span><br><span class="line">    &#125; *<span class="built_in">stack</span>, internal[EMBEDDED_LEVELS];</span><br><span class="line">    <span class="comment">// 所查找的文件名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span>    *<span class="title">name</span>;</span></span><br><span class="line">    <span class="comment">// 保存的nameidata结构体，用于恢复之前的状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">saved</span>;</span></span><br><span class="line">    <span class="comment">// 根路径的序列号</span></span><br><span class="line">    <span class="type">unsigned</span>    root_seq;</span><br><span class="line">    <span class="comment">// 目录文件描述符</span></span><br><span class="line">    <span class="type">int</span>        dfd;</span><br><span class="line">    <span class="comment">// 目录的vfs用户ID</span></span><br><span class="line">    <span class="type">vfsuid_t</span>    dir_vfsuid;</span><br><span class="line">    <span class="comment">// 目录的模式</span></span><br><span class="line">    <span class="type">umode_t</span>        dir_mode;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义标记值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ND_ROOT_PRESET 1  <span class="comment">// 根路径已预设</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ND_ROOT_GRABBED 2 <span class="comment">// 根路径已获取</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ND_JUMPED 4       <span class="comment">// 已经跳转</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 nameidata 结构体的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __set_nameidata(<span class="keyword">struct</span> nameidata *p, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的 nameidata</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">old</span> =</span> current-&gt;nameidata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 nameidata 结构体</span></span><br><span class="line">    p-&gt;<span class="built_in">stack</span> = p-&gt;internal;</span><br><span class="line">    p-&gt;depth = <span class="number">0</span>;</span><br><span class="line">    p-&gt;dfd = dfd;</span><br><span class="line">    p-&gt;name = name;</span><br><span class="line">    p-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;total_link_count = old ? old-&gt;total_link_count : <span class="number">0</span>;</span><br><span class="line">    p-&gt;saved = old;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前线程的 nameidata</span></span><br><span class="line">    current-&gt;nameidata = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 nameidata 结构体的值，并初始化状态</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_nameidata</span><span class="params">(<span class="keyword">struct</span> nameidata *p, <span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> path *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    __set_nameidata(p, dfd, name);</span><br><span class="line">    p-&gt;state = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 root 不为 NULL，则将 state 设置为 ND_ROOT_PRESET，同时设置 root 路径</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(root)) &#123;</span><br><span class="line">        p-&gt;state = ND_ROOT_PRESET;</span><br><span class="line">        p-&gt;root = *root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 恢复 nameidata 结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">restore_nameidata</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前和之前的 nameidata</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">now</span> =</span> current-&gt;nameidata, *old = now-&gt;saved;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复当前线程的 nameidata</span></span><br><span class="line">    current-&gt;nameidata = old;</span><br><span class="line">    <span class="comment">// 如果 old 存在，则更新 total_link_count</span></span><br><span class="line">    <span class="keyword">if</span> (old)</span><br><span class="line">        old-&gt;total_link_count = now-&gt;total_link_count;</span><br><span class="line">    <span class="comment">// 如果 stack 指向的不是内部数组，则释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (now-&gt;<span class="built_in">stack</span> != now-&gt;internal)</span><br><span class="line">        kfree(now-&gt;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为 nameidata 结构体分配内存</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">nd_alloc_stack</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配内存</span></span><br><span class="line">    p= kmalloc_array(MAXSYMLINKS, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> saved),</span><br><span class="line">             nd-&gt;flags &amp; LOOKUP_RCU ? GFP_ATOMIC : GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!p))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 复制内部数组到新分配的内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p, nd-&gt;internal, <span class="keyword">sizeof</span>(nd-&gt;internal));</span><br><span class="line">    nd-&gt;<span class="built_in">stack</span> = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * path_connected - 验证 dentry 是否在 mnt.mnt_root 下面</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重命名操作有时会将文件或目录移出绑定挂载，</span></span><br><span class="line"><span class="comment"> * path_connected 允许检测这些情况。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">path_connected</span><span class="params">(<span class="keyword">struct</span> vfsmount *mnt, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span> =</span> mnt-&gt;mnt_sb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定挂载可以有断开的路径</span></span><br><span class="line">    <span class="keyword">if</span> (mnt-&gt;mnt_root == sb-&gt;s_root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 dentry 是否是 mnt.mnt_root 的子目录</span></span><br><span class="line">    <span class="keyword">return</span> is_subdir(dentry, mnt-&gt;mnt_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除链接</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">drop_links</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = nd-&gt;depth;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> *<span class="title">last</span> =</span> nd-&gt;<span class="built_in">stack</span> + i;</span><br><span class="line">        <span class="comment">// 执行延迟调用</span></span><br><span class="line">        do_delayed_call(&amp;last-&gt;done);</span><br><span class="line">        <span class="comment">// 清除延迟调用</span></span><br><span class="line">        clear_delayed_call(&amp;last-&gt;done);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 离开 RCU 读取区域</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">leave_rcu</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    nd-&gt;flags &amp;= ~LOOKUP_RCU;</span><br><span class="line">    nd-&gt;seq = nd-&gt;next_seq = <span class="number">0</span>;</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止路径解析</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">terminate_walk</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 清除链接</span></span><br><span class="line">    drop_links(nd);</span><br><span class="line">    <span class="keyword">if</span> (!(nd-&gt;flags &amp; LOOKUP_RCU)) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="comment">// 释放 path 引用</span></span><br><span class="line">        path_put(&amp;nd-&gt;path);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nd-&gt;depth; i++)</span><br><span class="line">            <span class="comment">// 释放 stack 中的所有 link 引用</span></span><br><span class="line">            path_put(&amp;nd-&gt;<span class="built_in">stack</span>[i].link);</span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;state &amp; ND_ROOT_GRABBED) &#123;</span><br><span class="line">            <span class="comment">// 如果 root 被抓取，则释放 root 引用并清除 ND_ROOT_GRABBED 标志</span></span><br><span class="line">            path_put(&amp;nd-&gt;root);</span><br><span class="line">            nd-&gt;state &amp;= ~ND_ROOT_GRABBED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在 RCU 读取区域，则离开 RCU 读取区域</span></span><br><span class="line">        leave_rcu(nd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重置 depth 和 path</span></span><br><span class="line">    nd-&gt;depth = <span class="number">0</span>;</span><br><span class="line">    nd-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">    nd-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无论成功或失败，之后都需要 path_put</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __legitimize_path(<span class="keyword">struct</span> path *path, <span class="type">unsigned</span> seq, <span class="type">unsigned</span> mseq)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 验证mnt结构体是否合法</span></span><br><span class="line">    <span class="type">int</span> res = __legitimize_mnt(path-&gt;mnt, mseq);</span><br><span class="line">    <span class="comment">// 如果不合法，则将mnt和dentry设为NULL并返回false</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(res)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>)</span><br><span class="line">            path-&gt;mnt = <span class="literal">NULL</span>;</span><br><span class="line">        path-&gt;dentry = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果dentry的d_lockref是死的，则将dentry设为NULL并返回false</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!lockref_get_not_dead(&amp;path-&gt;dentry-&gt;d_lockref))) &#123;</span><br><span class="line">        path-&gt;dentry = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果读取序列号失败，则返回false</span></span><br><span class="line">    <span class="keyword">return</span> !read_seqcount_retry(&amp;path-&gt;dentry-&gt;d_seq, seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证路径是否合法</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">legitimize_path</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> path *path, <span class="type">unsigned</span> seq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __legitimize_path(path, seq, nd-&gt;m_seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证链接是否合法</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">legitimize_links</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 如果有LOOKUP_CACHED标志，那么清除链接并将depth设为0，然后返回false</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_CACHED)) &#123;</span><br><span class="line">        drop_links(nd);</span><br><span class="line">        nd-&gt;depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历stack中的所有元素，验证每个链接是否合法</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nd-&gt;depth; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> *<span class="title">last</span> =</span> nd-&gt;<span class="built_in">stack</span> + i;</span><br><span class="line">        <span class="comment">// 如果链接不合法，那么清除链接并将depth设为i+1，然后返回false</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!legitimize_path(nd, &amp;last-&gt;link, last-&gt;seq))) &#123;</span><br><span class="line">            drop_links(nd);</span><br><span class="line">            nd-&gt;depth = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有链接都合法，返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证root是否合法</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">legitimize_root</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果nd-&gt;root是0或者被VFS用户管理，那么不需要做任何事情，直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (!nd-&gt;root.mnt || (nd-&gt;state &amp; ND_ROOT_PRESET))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 设置ND_ROOT_GRABBED标志</span></span><br><span class="line">    nd-&gt;state |= ND_ROOT_GRABBED;</span><br><span class="line">    <span class="comment">// 验证root路径是否合法</span></span><br><span class="line">    <span class="keyword">return</span> legitimize_path(nd, &amp;nd-&gt;root, nd-&gt;root_seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Path walking has 2 modes, rcu-walk and ref-walk (see</span></span><br><span class="line"><span class="comment"> * Documentation/filesystems/path-lookup.txt).  In situations when we can&#x27;t</span></span><br><span class="line"><span class="comment"> * continue in RCU mode, we attempt to drop out of rcu-walk mode and grab</span></span><br><span class="line"><span class="comment"> * normal reference counts on dentries and vfsmounts to transition to ref-walk</span></span><br><span class="line"><span class="comment"> * mode.  Refcounts are grabbed at the last known good point before rcu-walk</span></span><br><span class="line"><span class="comment"> * got stuck, so ref-walk may continue from there. If this is not successful</span></span><br><span class="line"><span class="comment"> * (eg. a seqcount has changed), then failure is returned and it&#x27;s up to caller</span></span><br><span class="line"><span class="comment"> * to restart the path walk from the beginning in ref-walk mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_to_unlazy - 尝试切换到引用遍历模式。</span></span><br><span class="line"><span class="comment"> * @nd: nameidata路径遍历数据</span></span><br><span class="line"><span class="comment"> * 返回: 成功返回true，失败返回false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * try_to_unlazy 尝试将当前的nd-&gt;path和nd-&gt;root合法化为引用遍历模式。</span></span><br><span class="line"><span class="comment"> * 必须在rcu-walk上下文中调用。</span></span><br><span class="line"><span class="comment"> * 在try_to_unlazy()失败和terminate_walk()之间，不应触及nameidata。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">try_to_unlazy</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> nd-&gt;path.dentry;</span><br><span class="line"></span><br><span class="line">    BUG_ON(!(nd-&gt;flags &amp; LOOKUP_RCU));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!legitimize_links(nd)))</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!legitimize_path(nd, &amp;nd-&gt;path, nd-&gt;seq)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!legitimize_root(nd)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    leave_rcu(nd);</span><br><span class="line">    BUG_ON(nd-&gt;inode != parent-&gt;d_inode);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">out1:</span><br><span class="line">    nd-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">    nd-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">out:</span><br><span class="line">    leave_rcu(nd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * try_to_unlazy_next - 尝试切换到引用遍历模式。</span></span><br><span class="line"><span class="comment"> * @nd: nameidata路径遍历数据</span></span><br><span class="line"><span class="comment"> * @dentry: 需要步入的下一个dentry</span></span><br><span class="line"><span class="comment"> * 返回: 成功返回true，失败返回false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 类似于try_to_unlazy()，但在这里我们已经通过rcu-walk选择了下一个dentry，</span></span><br><span class="line"><span class="comment"> * 并希望除了当前的nd-&gt;path和nd-&gt;root外，还要将其合法化为引用遍历模式。</span></span><br><span class="line"><span class="comment"> * 必须在rcu-walk上下文中调用。</span></span><br><span class="line"><span class="comment"> * 在try_to_unlazy_next()失败和terminate_walk()之间，不应触及nameidata。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">try_to_unlazy_next</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    BUG_ON(!(nd-&gt;flags &amp; LOOKUP_RCU));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!legitimize_links(nd)))</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    res = __legitimize_mnt(nd-&gt;path.mnt, nd-&gt;m_seq);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(res)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out2;</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!lockref_get_not_dead(&amp;nd-&gt;path.dentry-&gt;d_lockref)))</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 我们需要将父节点和dentry从RCU领域移动到适当的引用计数。</span></span><br><span class="line"><span class="comment">     * 并且dentry中的序列号验证了*两个* dentry计数器，因为我们在获取子序列号后检查了父序列号。</span></span><br><span class="line"><span class="comment">     * 所以我们知道如果子序列号是有效的，那么父节点必须仍然是有效的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!lockref_get_not_dead(&amp;dentry-&gt;d_lockref)))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (read_seqcount_retry(&amp;dentry-&gt;d_seq, nd-&gt;next_seq))</span><br><span class="line">        <span class="keyword">goto</span> out_dput;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 序列计数匹配。现在确保root仍然有效，并在需要时获取它。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!legitimize_root(nd)))</span><br><span class="line">        <span class="keyword">goto</span> out_dput;</span><br><span class="line">    leave_rcu(nd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">out2:</span><br><span class="line">    nd-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">out1:</span><br><span class="line">    nd-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">out:</span><br><span class="line">    leave_rcu(nd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">out_dput:</span><br><span class="line">    leave_rcu(nd);</span><br><span class="line">    dput(dentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查dentry是否需要进一步验证</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">d_revalidate</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果dentry设置了DCACHE_OP_REVALIDATE标志，则调用d_revalidate进行验证</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(dentry-&gt;d_flags &amp; DCACHE_OP_REVALIDATE))</span><br><span class="line">        <span class="keyword">return</span> dentry-&gt;d_op-&gt;d_revalidate(dentry, flags);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则直接返回1表示验证成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * complete_walk - 完成路径遍历</span></span><br><span class="line"><span class="comment"> * @nd:  nameidata指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果我们处于RCU模式，退出它并合法化nd-&gt;path。</span></span><br><span class="line"><span class="comment"> * 除非我们在路径遍历过程中已经完成了验证，或者文件系统不需要验证，否则重新验证最后的结果。</span></span><br><span class="line"><span class="comment"> * 成功返回0，失败返回-error。在失败的情况下，调用者无需丢弃nd-&gt;path。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">complete_walk</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> nd-&gt;path.dentry;  <span class="comment">// 获取路径的dentry</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;  <span class="comment">// 如果在RCU模式下</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于scoped-lookups或外部管理的nd-&gt;root，我们不想将nd-&gt;root置为0。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!(nd-&gt;state &amp; ND_ROOT_PRESET))  <span class="comment">// 如果nd-&gt;state没有设置ND_ROOT_PRESET</span></span><br><span class="line">            <span class="keyword">if</span> (!(nd-&gt;flags &amp; LOOKUP_IS_SCOPED))  <span class="comment">// 如果没有设置LOOKUP_IS_SCOPED</span></span><br><span class="line">                nd-&gt;root.mnt = <span class="literal">NULL</span>;  <span class="comment">// 将nd-&gt;root.mnt置为NULL</span></span><br><span class="line">        nd-&gt;flags &amp;= ~LOOKUP_CACHED;  <span class="comment">// 清除LOOKUP_CACHED标志</span></span><br><span class="line">        <span class="keyword">if</span> (!try_to_unlazy(nd))  <span class="comment">// 尝试退出lazy模式</span></span><br><span class="line">            <span class="keyword">return</span> -ECHILD;  <span class="comment">// 如果失败，返回-ECHILD</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123;  <span class="comment">// 如果设置了LOOKUP_IS_SCOPED</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 尽管LOOKUP_IS_SCOPED的保证大概是&quot;在查找过程中不要走出root&quot;，这应该已经被namei的其余部分保证了，</span></span><br><span class="line"><span class="comment">         * 但我们希望避免namei的BUG导致用户空间得到一个在查找过程中某个时点不在root内的路径。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 因此，进行最后的健全性检查，确保在最坏的情况下（完全绕过LOOKUP_IS_SCOPED）我们不会无声无息地</span></span><br><span class="line"><span class="comment">         * 将一个完全在请求的root外的fd返回给用户空间。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 用户空间可能会在这个检查之后将路径移出root，但是如其他地方所讨论的，这不是问题（解析的文件曾经在root内）。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!path_is_under(&amp;nd-&gt;path, &amp;nd-&gt;root))  <span class="comment">// 判断nd-&gt;path是否在nd-&gt;root下</span></span><br><span class="line">            <span class="keyword">return</span> -EXDEV;  <span class="comment">// 如果不在，返回-EXDEV</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!(nd-&gt;state &amp; ND_JUMPED)))  <span class="comment">// 如果nd-&gt;state没有设置ND_JUMPED</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!(dentry-&gt;d_flags &amp; DCACHE_OP_WEAK_REVALIDATE)))  <span class="comment">// 如果dentry的d_flags没有设置DCACHE_OP_WEAK_REVALIDATE</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line"></span><br><span class="line">    status = dentry-&gt;d_op-&gt;d_weak_revalidate(dentry, nd-&gt;flags);  <span class="comment">// 执行弱验证</span></span><br><span class="line">    <span class="keyword">if</span> (status &gt; <span class="number">0</span>)  <span class="comment">// 如果验证成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!status)  <span class="comment">// 如果验证失败</span></span><br><span class="line">        status = -ESTALE;  <span class="comment">// 设置status为-ESTALE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;  <span class="comment">// 返回status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">set_root</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span> =</span> current-&gt;fs;  <span class="comment">// 获取当前的文件系统结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在scoped-lookup中跳转到实际的root是namei的BUG，但我们仍然必须确保它不会发生，</span></span><br><span class="line"><span class="comment">     * 因为它会导致从dirfd中跳出。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON(nd-&gt;flags &amp; LOOKUP_IS_SCOPED))  <span class="comment">// 如果设置了LOOKUP_IS_SCOPED，发出警告</span></span><br><span class="line">        <span class="keyword">return</span> -ENOTRECOVERABLE;  <span class="comment">// 返回-ENOTRECOVERABLE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;  <span class="comment">// 如果在RCU模式下</span></span><br><span class="line">        <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            seq = read_seqcount_begin(&amp;fs-&gt;seq);  <span class="comment">// 读取fs的seq</span></span><br><span class="line">            nd-&gt;root = fs-&gt;root;            </span><br><span class="line">            nd-&gt;root_seq = __read_seqcount_begin(&amp;nd-&gt;root.dentry-&gt;d_seq);  <span class="comment">// 读取nd-&gt;root的dentry的d_seq</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;fs-&gt;seq, seq));  <span class="comment">// 如果fs的seq有变动，重试</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        get_fs_root(fs, &amp;nd-&gt;root);  <span class="comment">// 获取fs的root，设置到nd-&gt;root</span></span><br><span class="line">        nd-&gt;state |= ND_ROOT_GRABBED;  <span class="comment">// 设置nd-&gt;state的ND_ROOT_GRABBED</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">nd_jump_root</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果设置了LOOKUP_BENEATH标志，返回-EXDEV</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))</span><br><span class="line">        <span class="keyword">return</span> -EXDEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了LOOKUP_NO_XDEV标志</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) &#123;</span><br><span class="line">        <span class="comment">/* Absolute path arguments to path_init() are allowed. */</span></span><br><span class="line">        <span class="comment">// 如果nd-&gt;path.mnt不为空，并且nd-&gt;path.mnt不等于nd-&gt;root.mnt，返回-EXDEV</span></span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;path.mnt != <span class="literal">NULL</span> &amp;&amp; nd-&gt;path.mnt != nd-&gt;root.mnt)</span><br><span class="line">            <span class="keyword">return</span> -EXDEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果nd-&gt;root.mnt为空</span></span><br><span class="line">    <span class="keyword">if</span> (!nd-&gt;root.mnt) &#123;</span><br><span class="line">        <span class="comment">// 调用set_root设置root，并检查返回值</span></span><br><span class="line">        <span class="type">int</span> error = set_root(nd);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了LOOKUP_RCU标志</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d</span>;</span></span><br><span class="line">        nd-&gt;path = nd-&gt;root;  <span class="comment">// 将nd-&gt;root赋值给nd-&gt;path</span></span><br><span class="line">        d = nd-&gt;path.dentry;  <span class="comment">// 获取nd-&gt;path的dentry</span></span><br><span class="line">        nd-&gt;inode = d-&gt;d_inode;  <span class="comment">// 获取dentry的inode赋值给nd-&gt;inode</span></span><br><span class="line">        nd-&gt;seq = nd-&gt;root_seq;  <span class="comment">// 将nd-&gt;root_seq赋值给nd-&gt;seq</span></span><br><span class="line">        <span class="comment">// 如果d-&gt;d_seq和nd-&gt;seq不匹配，返回-ECHILD</span></span><br><span class="line">        <span class="keyword">if</span> (read_seqcount_retry(&amp;d-&gt;d_seq, nd-&gt;seq))</span><br><span class="line">            <span class="keyword">return</span> -ECHILD;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有设置LOOKUP_RCU标志</span></span><br><span class="line">        path_put(&amp;nd-&gt;path);  <span class="comment">// 递减nd-&gt;path的引用计数</span></span><br><span class="line">        nd-&gt;path = nd-&gt;root;  <span class="comment">// 将nd-&gt;root赋值给nd-&gt;path</span></span><br><span class="line">        path_get(&amp;nd-&gt;path);  <span class="comment">// 递增nd-&gt;path的引用计数</span></span><br><span class="line">        nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;  <span class="comment">// 获取nd-&gt;path的dentry的inode赋值给nd-&gt;inode</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ND_JUMPED标志</span></span><br><span class="line">    nd-&gt;state |= ND_JUMPED;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper to directly jump to a known parsed path from -&gt;get_link,</span></span><br><span class="line"><span class="comment"> * caller must have taken a reference to path beforehand.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nd_jump_link</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = -ELOOP;  <span class="comment">// 初始化error为-ELOOP</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> *<span class="title">nd</span> =</span> current-&gt;nameidata;  <span class="comment">// 获取当前的nameidata</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了LOOKUP_NO_MAGICLINKS标志</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_MAGICLINKS))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    error = -EXDEV;  <span class="comment">// 将error设置为-EXDEV</span></span><br><span class="line">    <span class="comment">// 如果设置了LOOKUP_NO_XDEV标志</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;path.mnt != path-&gt;mnt)  <span class="comment">// 如果nd-&gt;path.mnt不等于path-&gt;mnt</span></span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了LOOKUP_IS_SCOPED标志</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED))</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    path_put(&amp;nd-&gt;path);  <span class="comment">// 递减nd-&gt;path的引用计数</span></span><br><span class="line">    nd-&gt;path = *path;  <span class="comment">// 将*path赋值给nd-&gt;path</span></span><br><span class="line">    nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;  <span class="comment">// 获取nd-&gt;path的dentry的inode赋值给nd-&gt;inode</span></span><br><span class="line">    nd-&gt;state |= ND_JUMPED;  <span class="comment">// 设置ND_JUMPED标志</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0</span></span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    path_put(path);  <span class="comment">// 递减path的引用计数</span></span><br><span class="line">    <span class="keyword">return</span> error;  <span class="comment">// 返回error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">put_link</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取nd-&gt;stack中的最后一个元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> *<span class="title">last</span> =</span> nd-&gt;<span class="built_in">stack</span> + --nd-&gt;depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟调用</span></span><br><span class="line">    do_delayed_call(&amp;last-&gt;done);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没设置LOOKUP_RCU标志，则递减last-&gt;link的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (!(nd-&gt;flags &amp; LOOKUP_RCU))</span><br><span class="line">        path_put(&amp;last-&gt;link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义四个静态整型变量，用于存储系统配置信息，__read_mostly指示这些数据主要是被读取</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_protected_symlinks __read_mostly;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_protected_hardlinks __read_mostly;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_protected_fifos __read_mostly;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_protected_regular __read_mostly;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SYSCTL</span></span><br><span class="line"><span class="comment">// 定义一个包含四个元素的ctl_table数组，</span></span><br><span class="line"><span class="comment">// 用于存储四个不同的系统配置项的信息</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ctl_table</span> <span class="title">namei_sysctls</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 系统配置项的名称</span></span><br><span class="line">        .procname    = <span class="string">&quot;protected_symlinks&quot;</span>,</span><br><span class="line">        <span class="comment">// 指向存储配置项值的变量的指针</span></span><br><span class="line">        .data        = &amp;sysctl_protected_symlinks,</span><br><span class="line">        <span class="comment">// 存储配置项值的变量的大小</span></span><br><span class="line">        .maxlen        = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        <span class="comment">// 配置项的权限</span></span><br><span class="line">        .mode        = <span class="number">0644</span>,</span><br><span class="line">        <span class="comment">// 处理配置项值的函数</span></span><br><span class="line">        .proc_handler    = proc_dointvec_minmax,</span><br><span class="line">        <span class="comment">// 配置项值的最小值</span></span><br><span class="line">        .extra1        = SYSCTL_ZERO,</span><br><span class="line">        <span class="comment">// 配置项值的最大值</span></span><br><span class="line">        .extra2        = SYSCTL_ONE,</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="comment">// 以下三个元素与第一个类似，不再赘述</span></span><br><span class="line">    &#123;</span><br><span class="line">        .procname    = <span class="string">&quot;protected_hardlinks&quot;</span>,</span><br><span class="line">        .data        = &amp;sysctl_protected_hardlinks,</span><br><span class="line">        .maxlen        = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode        = <span class="number">0644</span>,</span><br><span class="line">        .proc_handler    = proc_dointvec_minmax,</span><br><span class="line">        .extra1        = SYSCTL_ZERO,</span><br><span class="line">        .extra2        = SYSCTL_ONE,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .procname    = <span class="string">&quot;protected_fifos&quot;</span>,</span><br><span class="line">        .data        = &amp;sysctl_protected_fifos,</span><br><span class="line">        .maxlen        = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode        = <span class="number">0644</span>,</span><br><span class="line">        .proc_handler    = proc_dointvec_minmax,</span><br><span class="line">        .extra1        = SYSCTL_ZERO,</span><br><span class="line">        .extra2        = SYSCTL_TWO,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .procname    = <span class="string">&quot;protected_regular&quot;</span>,</span><br><span class="line">        .data        = &amp;sysctl_protected_regular,</span><br><span class="line">        .maxlen        = <span class="keyword">sizeof</span>(<span class="type">int</span>),</span><br><span class="line">        .mode        = <span class="number">0644</span>,</span><br><span class="line">        .proc_handler    = proc_dointvec_minmax,</span><br><span class="line">        .extra1        = SYSCTL_ZERO,</span><br><span class="line">        .extra2        = SYSCTL_TWO,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 结束标志</span></span><br><span class="line">    &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_fs_namei_sysctls</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册系统配置项</span></span><br><span class="line">    register_sysctl_init(<span class="string">&quot;fs&quot;</span>, namei_sysctls);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将初始化函数添加到fs_initcall列表中，</span></span><br><span class="line"><span class="comment">// 这样在系统启动时，init_fs_namei_sysctls会被自动调用</span></span><br><span class="line">fs_initcall(init_fs_namei_sysctls);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SYSCTL */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * may_follow_link - 检查符号链接的跟踪是否存在不安全情况</span></span><br><span class="line"><span class="comment"> * @nd: nameidata路径遍历数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在启用sysctl_protected_symlinks系统配置项的情况下，</span></span><br><span class="line"><span class="comment"> * 如果符号链接位于粘性全局可写目录中，需要特别忽略CAP_DAC_OVERRIDE。</span></span><br><span class="line"><span class="comment"> * 这是为了保护特权进程不受路径名可能因其他用户创建恶意符号链接而改变的竞态条件的影响。</span></span><br><span class="line"><span class="comment"> * 它将只允许在粘性全局可写目录外部，或者符号链接的uid与跟随者匹配，</span></span><br><span class="line"><span class="comment"> * 或者目录所有者与符号链接的所有者匹配时跟踪符号链接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果允许跟踪符号链接，则返回0，如果出错，则返回-ve。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">may_follow_link</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">const</span> <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span></span><br><span class="line">    <span class="type">vfsuid_t</span> vfsuid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未启用sysctl_protected_symlinks系统配置项，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!sysctl_protected_symlinks)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取nd-&gt;path.mnt的mnt_idmap</span></span><br><span class="line">    idmap = mnt_idmap(nd-&gt;path.mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将inode的i_uid转换为vfsuid</span></span><br><span class="line">    vfsuid = i_uid_into_vfsuid(idmap, inode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有者和跟随者匹配，则允许</span></span><br><span class="line">    <span class="keyword">if</span> (vfsuid_eq_kuid(vfsuid, current_fsuid()))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父目录不是粘性的和全局可写的，则允许</span></span><br><span class="line">    <span class="keyword">if</span> ((nd-&gt;dir_mode &amp; (S_ISVTX|S_IWOTH)) != (S_ISVTX|S_IWOTH))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果父目录和链接所有者匹配，则允许</span></span><br><span class="line">    <span class="keyword">if</span> (vfsuid_valid(nd-&gt;dir_vfsuid) &amp;&amp; vfsuid_eq(nd-&gt;dir_vfsuid, vfsuid))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了LOOKUP_RCU标志，返回-ECHILD</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU)</span><br><span class="line">        <span class="keyword">return</span> -ECHILD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 审计inode</span></span><br><span class="line">    audit_inode(nd-&gt;name, nd-&gt;<span class="built_in">stack</span>[<span class="number">0</span>].link.dentry, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录被拒绝的路径</span></span><br><span class="line">    audit_log_path_denied(AUDIT_ANOM_LINK, <span class="string">&quot;follow_link&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回-EACCES</span></span><br><span class="line">    <span class="keyword">return</span> -EACCES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * safe_hardlink_source - 检查安全的硬链接条件</span></span><br><span class="line"><span class="comment"> * @idmap: inode所在挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @inode: 要从中创建硬链接的源inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果满足以下任一条件，返回false：</span></span><br><span class="line"><span class="comment"> *    - inode不是一个普通文件</span></span><br><span class="line"><span class="comment"> *    - inode是setuid</span></span><br><span class="line"><span class="comment"> *    - inode是setgid并且是组可执行的</span></span><br><span class="line"><span class="comment"> *    - 读写访问失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则返回true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">safe_hardlink_source</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取inode的模式</span></span><br><span class="line">    <span class="type">umode_t</span> mode = inode-&gt;i_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果inode不是一个普通文件，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!S_ISREG(mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果inode是setuid，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_ISUID)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果inode是可执行的setgid文件，返回false</span></span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果无法读取或写入源文件，则创建硬链接是危险的，返回false</span></span><br><span class="line">    <span class="keyword">if</span> (inode_permission(idmap, inode, MAY_READ | MAY_WRITE))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * may_linkat - 检查创建硬链接的权限</span></span><br><span class="line"><span class="comment"> * @idmap: inode 所在挂载点的 idmap</span></span><br><span class="line"><span class="comment"> * @link: 要从哪里创建硬链接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 阻止以下情况的硬链接创建：</span></span><br><span class="line"><span class="comment"> *  - 启用了 sysctl_protected_hardlinks</span></span><br><span class="line"><span class="comment"> *  - fsuid 与 inode 不匹配</span></span><br><span class="line"><span class="comment"> *  - 硬链接源不安全（参见上述 safe_hardlink_source()）</span></span><br><span class="line"><span class="comment"> *  - 在 inode 所有者 uid 映射的命名空间中，不是 CAP_FOWNER</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过 idmapped 挂载找到 inode，则必须通过 @idmap 传递 vfsmount 的 idmap。</span></span><br><span class="line"><span class="comment"> * 此函数将会根据 @idmap 映射 inode，然后进行权限检查。</span></span><br><span class="line"><span class="comment"> * 在非 idmapped 挂载上或者如果要对原始 inode 进行权限检查，只需传递 @nop_mnt_idmap 即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果成功，则返回 0；如果出错，则返回负值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">may_linkat</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="type">const</span> <span class="keyword">struct</span> path *link)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从链接路径中获取 inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> link-&gt;dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 uid 或 gid 无效，则 inode 写回不安全</span></span><br><span class="line">    <span class="keyword">if</span> (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||</span><br><span class="line">        !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))</span><br><span class="line">        <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有启用 sysctl_protected_hardlinks，则函数可以成功返回</span></span><br><span class="line">    <span class="keyword">if</span> (!sysctl_protected_hardlinks)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是安全的硬链接源，或者是源 inode 的所有者（或者是 CAP_FOWNER），则可以成功返回</span></span><br><span class="line">    <span class="keyword">if</span> (safe_hardlink_source(idmap, inode) ||</span><br><span class="line">        inode_owner_or_capable(idmap, inode))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果到达这里，说明链接被拒绝，因此记录它并返回权限错误</span></span><br><span class="line">    audit_log_path_denied(AUDIT_ANOM_LINK, <span class="string">&quot;linkat&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * may_create_in_sticky - 检查在粘性目录中是否应允许 O_CREAT 打开已存在的文件</span></span><br><span class="line"><span class="comment"> * @idmap: inode 所在挂载点的 idmap</span></span><br><span class="line"><span class="comment"> * @nd: 路径遍历数据</span></span><br><span class="line"><span class="comment"> * @inode: 要打开的文件的 inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当以下条件满足时，阻止 O_CREAT 打开 FIFO（或常规文件）：</span></span><br><span class="line"><span class="comment"> *   - 启用了 sysctl_protected_fifos（或 sysctl_protected_regular）</span></span><br><span class="line"><span class="comment"> *   - 文件已经存在</span></span><br><span class="line"><span class="comment"> *   - 我们在粘性目录内</span></span><br><span class="line"><span class="comment"> *   - 我们不拥有文件</span></span><br><span class="line"><span class="comment"> *   - 目录的所有者不拥有文件</span></span><br><span class="line"><span class="comment"> *   - 目录是全世界可写的</span></span><br><span class="line"><span class="comment"> * 如果将 sysctl_protected_fifos（或 sysctl_protected_regular）设置为 2，</span></span><br><span class="line"><span class="comment"> * 那么目录不必是全世界可写的：只需要是组可写就足够了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过 idmapped 挂载找到 inode，则必须通过 @idmap 传递 vfsmount 的 idmap。</span></span><br><span class="line"><span class="comment"> * 此函数将会根据 @idmap 映射 inode，然后进行权限检查。</span></span><br><span class="line"><span class="comment"> * 在非 idmapped 挂载上或者如果要对原始 inode 进行权限检查，只需传递 @nop_mnt_idmap 即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果允许打开，则返回 0；如果出错，则返回负值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">may_create_in_sticky</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> inode *<span class="type">const</span> inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取目录模式和 uid</span></span><br><span class="line">    <span class="type">umode_t</span> dir_mode = nd-&gt;dir_mode;</span><br><span class="line">    <span class="type">vfsuid_t</span> dir_vfsuid = nd-&gt;dir_vfsuid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有启用 sysctl_protected_fifos，或者没有启用 sysctl_protected_regular，或者目录不是粘性的，或者 inode 的 uid 与目录的 uid 或当前的 fsuid 匹配，则成功返回</span></span><br><span class="line">    <span class="keyword">if</span> ((!sysctl_protected_fifos &amp;&amp;S_ISFIFO(inode-&gt;i_mode)) ||</span><br><span class="line">        (!sysctl_protected_regular &amp;&amp; S_ISREG(inode-&gt;i_mode)) ||</span><br><span class="line">        likely(!(dir_mode &amp; S_ISVTX)) ||</span><br><span class="line">        vfsuid_eq(i_uid_into_vfsuid(idmap, inode), dir_vfsuid) ||</span><br><span class="line">        vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), current_fsuid()))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果目录是全世界可写的，或者当 sysctl_protected_fifos（或 sysctl_protected_regular）设置为 2 时，目录是组可写的，那么记录并返回权限错误</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dir_mode &amp; <span class="number">0002</span>) ||</span><br><span class="line">        (dir_mode &amp; <span class="number">0020</span> &amp;&amp;</span><br><span class="line">         ((sysctl_protected_fifos &gt;= <span class="number">2</span> &amp;&amp; S_ISFIFO(inode-&gt;i_mode)) ||</span><br><span class="line">          (sysctl_protected_regular &gt;= <span class="number">2</span> &amp;&amp; S_ISREG(inode-&gt;i_mode))))) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *operation = S_ISFIFO(inode-&gt;i_mode) ?</span><br><span class="line">                    <span class="string">&quot;sticky_create_fifo&quot;</span> :</span><br><span class="line">                    <span class="string">&quot;sticky_create_regular&quot;</span>;</span><br><span class="line">        audit_log_path_denied(AUDIT_ANOM_CREAT, operation);</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * follow_up - 找到路径的 vfsmount 的挂载点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给定一个路径，找到其源文件系统的挂载点。</span></span><br><span class="line"><span class="comment"> * 将 @path 替换为父挂载点中的挂载点路径。</span></span><br><span class="line"><span class="comment"> * Up 是指向 / 的方向。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果我们上升了一级，则返回 1；如果我们已经在根目录，则返回 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">follow_up</span><span class="params">(<span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取路径的挂载点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt</span> =</span> real_mount(path-&gt;mnt);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mountpoint</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取挂载锁</span></span><br><span class="line">    read_seqlock_excl(&amp;mount_lock);</span><br><span class="line">    <span class="comment">// 获取父挂载点</span></span><br><span class="line">    parent = mnt-&gt;mnt_parent;</span><br><span class="line">    <span class="comment">// 如果父挂载点就是当前挂载点，表示已经到达根目录，此时释放锁并返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (parent == mnt) &#123;</span><br><span class="line">        read_sequnlock_excl(&amp;mount_lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不然，增加父挂载点的引用计数</span></span><br><span class="line">    mntget(&amp;parent-&gt;mnt);</span><br><span class="line">    <span class="comment">// 获取挂载点的 dentry</span></span><br><span class="line">    mountpoint = dget(mnt-&gt;mnt_mountpoint);</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    read_sequnlock_excl(&amp;mount_lock);</span><br><span class="line">    <span class="comment">// 释放原来路径的 dentry</span></span><br><span class="line">    dput(path-&gt;dentry);</span><br><span class="line">    <span class="comment">// 将路径的 dentry 替换为挂载点的 dentry</span></span><br><span class="line">    path-&gt;dentry = mountpoint;</span><br><span class="line">    <span class="comment">// 释放原来路径的挂载点</span></span><br><span class="line">    mntput(path-&gt;mnt);</span><br><span class="line">    <span class="comment">// 将路径的挂载点替换为父挂载点</span></span><br><span class="line">    path-&gt;mnt = &amp;parent-&gt;mnt;</span><br><span class="line">    <span class="comment">// 返回 1，表示我们上升了一级</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(follow_up);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choose_mountpoint_rcu 函数</span></span><br><span class="line"><span class="comment">// 该函数通过 RCU（Read-Copy-Update）机制选择挂载点</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">choose_mountpoint_rcu</span><span class="params">(<span class="keyword">struct</span> mount *m, <span class="type">const</span> <span class="keyword">struct</span> path *root,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> path *path, <span class="type">unsigned</span> *seqp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当挂载点 m 有父挂载点时，执行循环体</span></span><br><span class="line">    <span class="keyword">while</span> (mnt_has_parent(m)) &#123;</span><br><span class="line">        <span class="comment">// 获取挂载点 m 的挂载点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mountpoint</span> =</span> m-&gt;mnt_mountpoint;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 m 更新为其父挂载点</span></span><br><span class="line">        m = m-&gt;mnt_parent;</span><br><span class="line">        <span class="comment">// 如果 root 的 dentry 与 mountpoint 相同，并且 root 的 mnt 与 m 的 mnt 相同，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(root-&gt;dentry == mountpoint &amp;&amp;</span><br><span class="line">                 root-&gt;mnt == &amp;m-&gt;mnt))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果 mountpoint 不等于 m 的 mnt_root</span></span><br><span class="line">        <span class="keyword">if</span> (mountpoint != m-&gt;mnt.mnt_root) &#123;</span><br><span class="line">            <span class="comment">// 更新 path 的 mnt 和 dentry</span></span><br><span class="line">            path-&gt;mnt = &amp;m-&gt;mnt;</span><br><span class="line">            path-&gt;dentry = mountpoint;</span><br><span class="line">            <span class="comment">// 读取 mountpoint 的序列号到 seqp</span></span><br><span class="line">            *seqp = read_seqcount_begin(&amp;mountpoint-&gt;d_seq);</span><br><span class="line">            <span class="comment">// 返回 true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果循环结束还没有返回，那么返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choose_mountpoint 函数</span></span><br><span class="line"><span class="comment">// 选择挂载点</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">choose_mountpoint</span><span class="params">(<span class="keyword">struct</span> mount *m, <span class="type">const</span> <span class="keyword">struct</span> path *root,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> found;  <span class="comment">// 用于存储查找结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 RCU 读锁</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">// 无限循环，直到满足一定条件跳出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">unsigned</span> seq, mseq = read_seqbegin(&amp;mount_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 choose_mountpoint_rcu 函数</span></span><br><span class="line">        found = choose_mountpoint_rcu(m, root, path, &amp;seq);</span><br><span class="line">        <span class="comment">// 如果没有找到</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!found)) &#123;</span><br><span class="line">            <span class="comment">// 如果 seq 没有改变，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (!read_seqretry(&amp;mount_lock, mseq))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果路径合法，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (likely(__legitimize_path(path, seq, mseq)))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 其他情况，释放 RCU 读锁</span></span><br><span class="line">            rcu_read_unlock();</span><br><span class="line">            <span class="comment">// 释放路径</span></span><br><span class="line">            path_put(path);</span><br><span class="line">            <span class="comment">// 重新获取 RCU 读锁</span></span><br><span class="line">            rcu_read_lock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放 RCU 读锁</span></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">// 返回查找结果</span></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// follow_automount 函数</span></span><br><span class="line"><span class="comment">// 执行自动挂载</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">follow_automount</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">int</span> *count, <span class="type">unsigned</span> lookup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取路径的 dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> path-&gt;dentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果只是进行状态查询，不执行挂载，除非查询的是一个目录并且在名称后面加上了 &#x27;/&#x27;</span></span><br><span class="line">    <span class="comment">// 如果希望在挂载点下面打开或创建任何类型的文件，或者希望穿越挂载点，或者希望打开已经挂载的目录，</span></span><br><span class="line">    <span class="comment">// 或者 autofs 将负的 dentry 标记为自动挂载点，那么执行挂载</span></span><br><span class="line">    <span class="keyword">if</span> (!(lookup_flags &amp; (LOOKUP_PARENT | LOOKUP_DIRECTORY |</span><br><span class="line">               LOOKUP_OPEN | LOOKUP_CREATE | LOOKUP_AUTOMOUNT)) &amp;&amp;</span><br><span class="line">        dentry-&gt;d_inode)</span><br><span class="line">        <span class="comment">// 返回 -EISDIR，表示是一个目录</span></span><br><span class="line">        <span class="keyword">return</span> -EISDIR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果符号链接的数量大于等于 MAXSYMLINKS</span></span><br><span class="line">    <span class="keyword">if</span> (count &amp;&amp; (*count)++ &gt;= MAXSYMLINKS)</span><br><span class="line">        <span class="comment">// 返回 -ELOOP，表示有过多的符号链接</span></span><br><span class="line">        <span class="keyword">return</span> -ELOOP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 finish_automount 函数完成自动挂载</span></span><br><span class="line">    <span class="keyword">return</span> finish_automount(dentry-&gt;d_op-&gt;d_automount(path), path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __traverse_mounts 函数</span></span><br><span class="line"><span class="comment">// 该函数用于在挂载点之间进行遍历</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __traverse_mounts(<span class="keyword">struct</span> path *path, <span class="type">unsigned</span> flags, <span class="type">bool</span> *jumped,</span><br><span class="line">                 <span class="type">int</span> *count, <span class="type">unsigned</span> lookup_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span> =</span> path-&gt;mnt;  <span class="comment">// 获取路径的挂载点</span></span><br><span class="line">    <span class="type">bool</span> need_mntput = <span class="literal">false</span>;  <span class="comment">// 初始化一个标志，表示是否需要释放挂载点</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;  <span class="comment">// 初始化返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 dentry 是由文件系统管理的时候，执行循环</span></span><br><span class="line">    <span class="keyword">while</span> (flags &amp; DCACHE_MANAGED_DENTRY) &#123;</span><br><span class="line">        <span class="comment">// 如果文件系统管理了 transit</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; DCACHE_MANAGE_TRANSIT) &#123;</span><br><span class="line">            <span class="comment">// 让文件系统管理 transit</span></span><br><span class="line">            ret = path-&gt;dentry-&gt;d_op-&gt;d_manage(path, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 获取新的 flags</span></span><br><span class="line">            flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags);</span><br><span class="line">            <span class="comment">// 如果返回值小于0，跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在 dentry 上挂载了东西</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; DCACHE_MOUNTED) &#123;</span><br><span class="line">            <span class="comment">// 查找挂载点</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mounted</span> =</span> lookup_mnt(path);</span><br><span class="line">            <span class="comment">// 如果在我们的命名空间中找到了挂载点</span></span><br><span class="line">            <span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">                <span class="comment">// 释放旧的 dentry，更新路径的挂载点和 dentry</span></span><br><span class="line">                dput(path-&gt;dentry);</span><br><span class="line">                <span class="keyword">if</span> (need_mntput)</span><br><span class="line">                    mntput(path-&gt;mnt);</span><br><span class="line">                path-&gt;mnt = mounted;</span><br><span class="line">                path-&gt;dentry = dget(mounted-&gt;mnt_root);</span><br><span class="line">                <span class="comment">// 在这里，我们知道它是 positive 的</span></span><br><span class="line">                flags = path-&gt;dentry-&gt;d_flags;</span><br><span class="line">                need_mntput = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不需要自动挂载，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; DCACHE_NEED_AUTOMOUNT))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果发现 uncovered 的自动挂载点，执行自动挂载</span></span><br><span class="line">        ret = follow_automount(path, count, lookup_flags);</span><br><span class="line">        flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果返回值是 -EISDIR，将其设置为 0</span></span><br><span class="line">    <span class="keyword">if</span> (ret == -EISDIR)</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果你与多个 mount --move 竞争，这是可能的</span></span><br><span class="line">    <span class="keyword">if</span> (need_mntput &amp;&amp; path-&gt;mnt == mnt)</span><br><span class="line">        mntput(path-&gt;mnt);</span><br><span class="line">    <span class="comment">// 如果没有错误，但是 flags 是 negative 的，返回 -ENOENT</span></span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; unlikely(d_flags_negative(flags)))</span><br><span class="line">        ret = -ENOENT;</span><br><span class="line">    *jumped = need_mntput;  <span class="comment">// 更新 jumped 的值</span></span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traverse_mounts 函数</span></span><br><span class="line"><span class="comment">// 这是一个内联函数，用于遍历挂载点</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">traverse_mounts</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">bool</span> *jumped,</span></span><br><span class="line"><span class="params">                  <span class="type">int</span> *count, <span class="type">unsigned</span> lookup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 dentry 的 flags</span></span><br><span class="line">    <span class="type">unsigned</span> flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速路径：如果 dentry 不是由文件系统管理的，设置 jumped 为 false 并返回</span></span><br><span class="line">    <span class="keyword">if</span> (likely(!(flags &amp; DCACHE_MANAGED_DENTRY))) &#123;</span><br><span class="line">        *jumped = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(d_flags_negative(flags)))</span><br><span class="line">            <span class="keyword">return</span> -ENOENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，调用 __traverse_mounts 函数进行遍历</span></span><br><span class="line">    <span class="keyword">return</span> __traverse_mounts(path, flags, jumped, count, lookup_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// follow_down_one 函数</span></span><br><span class="line"><span class="comment">// 这个函数会查找并返回当前路径下的挂载点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">follow_down_one</span><span class="params">(<span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mounted</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找当前路径的挂载点</span></span><br><span class="line">    mounted = lookup_mnt(path);</span><br><span class="line">    <span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">        <span class="comment">// 如果找到挂载点，释放当前路径的 dentry 和 mnt</span></span><br><span class="line">        dput(path-&gt;dentry);</span><br><span class="line">        mntput(path-&gt;mnt);</span><br><span class="line">        <span class="comment">// 并更新路径的 mnt 和 dentry 为新找到的挂载点</span></span><br><span class="line">        path-&gt;mnt = mounted;</span><br><span class="line">        path-&gt;dentry = dget(mounted-&gt;mnt_root);</span><br><span class="line">        <span class="comment">// 返回 1 表示成功找到挂载点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 0 表示没有找到    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(follow_down_one);  <span class="comment">// 把函数 follow_down_one 导出，使得其他模块也能够调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * follow_down 函数</span></span><br><span class="line"><span class="comment"> * 这个函数会遍历并找到当前用户可见的覆盖挂载点</span></span><br><span class="line"><span class="comment"> * 在每个点，都会查询拥有该 dentry 的文件系统是否允许调用者进行下一步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">follow_down</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span> =</span> path-&gt;mnt;  <span class="comment">// 获取当前路径的挂载点</span></span><br><span class="line">    <span class="type">bool</span> jumped;</span><br><span class="line">    <span class="comment">// 调用 traverse_mounts 函数进行挂载点的遍历</span></span><br><span class="line">    <span class="type">int</span> ret = traverse_mounts(path, &amp;jumped, <span class="literal">NULL</span>, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径的挂载点发生了改变，释放原来的挂载点</span></span><br><span class="line">    <span class="keyword">if</span> (path-&gt;mnt != mnt)</span><br><span class="line">        mntput(mnt);</span><br><span class="line">    <span class="comment">// 返回遍历结果</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(follow_down);  <span class="comment">// 把函数 follow_down 导出，使得其他模块也能够调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __follow_mount_rcu 函数</span></span><br><span class="line"><span class="comment"> * 这个函数尝试在 rcuwalk 模式下跳到挂载点堆的顶部</span></span><br><span class="line"><span class="comment"> * 如果遇到需要阻塞的管理 dentry，操作失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> __follow_mount_rcu(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> path *path)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> path-&gt;dentry;  <span class="comment">// 获取当前路径的 dentry</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags = dentry-&gt;d_flags;  <span class="comment">// 获取 dentry 的 flags</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 dentry 不是由文件系统管理的，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (likely(!(flags &amp; DCACHE_MANAGED_DENTRY)))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不允许跨设备查找，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果 dentry 希望阻塞 transit，那么它可能不是挂载点的管理 dentry</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(flags &amp; DCACHE_MANAGE_TRANSIT)) &#123;</span><br><span class="line">            <span class="comment">// 查询文件系统是否允许进行下一步</span></span><br><span class="line">            <span class="type">int</span> res = dentry-&gt;d_op-&gt;d_manage(path, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 如果返回结果不为 0，返回结果是否为 -EISDIR</span></span><br><span class="line">            <span class="keyword">if</span> (res)</span><br><span class="line">                <span class="keyword">return</span> res == -EISDIR;</span><br><span class="line">            <span class="comment">// 更新 flags</span></span><br><span class="line">            flags = dentry-&gt;d_flags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 dentry 是挂载点，查找挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; DCACHE_MOUNTED) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mounted</span> =</span> __lookup_mnt(path-&gt;mnt, dentry);</span><br><span class="line">            <span class="comment">// 如果找到了挂载点，更新路径的 mnt 和 dentry</span></span><br><span class="line">            <span class="keyword">if</span> (mounted) &#123;</span><br><span class="line">                path-&gt;mnt = &amp;mounted-&gt;mnt;</span><br><span class="line">                dentry = path-&gt;dentry = mounted-&gt;mnt.mnt_root;</span><br><span class="line">                <span class="comment">// 更新 nd 的状态</span></span><br><span class="line">                nd-&gt;state |= ND_JUMPED;</span><br><span class="line">                nd-&gt;next_seq = read_seqcount_begin(&amp;dentry-&gt;d_seq);</span><br><span class="line">                <span class="comment">// 更新 flags</span></span><br><span class="line">                flags = dentry-&gt;d_flags;</span><br><span class="line">                <span class="comment">// 确保非 RCU 路径遍历可以达到这个状态</span></span><br><span class="line">                <span class="keyword">if</span> (read_seqretry(&amp;mount_lock, nd-&gt;m_seq))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果读取序列号失败，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (read_seqretry(&amp;mount_lock, nd-&gt;m_seq))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不需要自动挂载，返回 true</span></span><br><span class="line">        <span class="keyword">return</span> !(flags &amp; DCACHE_NEED_AUTOMOUNT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * handle_mounts 函数</span></span><br><span class="line"><span class="comment"> * 用于处理挂载点，包括 RCU 模式下的挂载点跟踪，以及挂载点的遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">handle_mounts</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> jumped;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    path-&gt;mnt = nd-&gt;path.mnt;  <span class="comment">// 获取当前路径的挂载点</span></span><br><span class="line">    path-&gt;dentry = dentry;  <span class="comment">// 获取当前路径的 dentry</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;  <span class="comment">// 如果启用了 RCU 查找</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> seq = nd-&gt;next_seq;</span><br><span class="line">        <span class="comment">// 调用 __follow_mount_rcu 函数进行 RCU 模式下的挂载点跟踪</span></span><br><span class="line">        <span class="keyword">if</span> (likely(__follow_mount_rcu(nd, path)))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// *path 和 nd-&gt;next_seq 可能已经被修改</span></span><br><span class="line">        path-&gt;mnt = nd-&gt;path.mnt;</span><br><span class="line">        path-&gt;dentry = dentry;</span><br><span class="line">        nd-&gt;next_seq = seq;</span><br><span class="line">        <span class="keyword">if</span> (!try_to_unlazy_next(nd, dentry))</span><br><span class="line">            <span class="keyword">return</span> -ECHILD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 traverse_mounts 函数进行挂载点的遍历</span></span><br><span class="line">    ret = traverse_mounts(path, &amp;jumped, &amp;nd-&gt;total_link_count, nd-&gt;flags);</span><br><span class="line">    <span class="keyword">if</span> (jumped) &#123;  <span class="comment">// 如果成功跳转到了新的挂载点</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV))</span><br><span class="line">            ret = -EXDEV;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nd-&gt;state |= ND_JUMPED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(ret)) &#123;  <span class="comment">// 如果遍历过程中出现错误</span></span><br><span class="line">        dput(path-&gt;dentry);  <span class="comment">// 释放 dentry</span></span><br><span class="line">        <span class="keyword">if</span> (path-&gt;mnt != nd-&gt;path.mnt)  <span class="comment">// 如果挂载点已经改变</span></span><br><span class="line">            mntput(path-&gt;mnt);  <span class="comment">// 释放旧的挂载点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * lookup_dcache 函数</span></span><br><span class="line"><span class="comment"> * 这个函数在 dcache 中查找名称，并可能对找到的 dentry 进行重新验证</span></span><br><span class="line"><span class="comment"> * 如果在缓存中不存在 dentry，则返回 NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">lookup_dcache</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> qstr *name,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> dentry *dir,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> d_lookup(dir, name);  <span class="comment">// 在目录中查找 dentry</span></span><br><span class="line">    <span class="keyword">if</span> (dentry) &#123;  <span class="comment">// 如果找到了 dentry</span></span><br><span class="line">        <span class="type">int</span> error = d_revalidate(dentry, flags);  <span class="comment">// 对 dentry 进行重新验证</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(error &lt;= <span class="number">0</span>)) &#123;  <span class="comment">// 如果验证失败</span></span><br><span class="line">            <span class="keyword">if</span> (!error)</span><br><span class="line">                d_invalidate(dentry);  <span class="comment">// 使 dentry 无效</span></span><br><span class="line">            dput(dentry);  <span class="comment">// 释放 dentry</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(error);  <span class="comment">// 错误处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __lookup_hash 函数</span></span><br><span class="line"><span class="comment"> * 在父目录的 inode 被独占锁定的情况下进行查找</span></span><br><span class="line"><span class="comment"> * 这是唯一一个在非 in-lookup dentries 上调用 -&gt;lookup() 的情况</span></span><br><span class="line"><span class="comment"> * 事实上，这只在目录保证没有 in-lookup 子项的情况下被调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">lookup_hash</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">        <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">base</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> lookup_dcache(name, base, flags);  <span class="comment">// 在 dcache 中查找 dentry</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> base-&gt;d_inode;  <span class="comment">// 获取基础 dentry 的 inode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dentry)  <span class="comment">// 如果找到了 dentry</span></span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于死目录，不创建子 dentry</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(IS_DEADDIR(dir)))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为基础 dentry 和名称分配一个新的 dentry</span></span><br><span class="line">    dentry = d_alloc(base, name);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dentry))  <span class="comment">// 如果分配失败</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 -&gt;lookup() 函数进行查找</span></span><br><span class="line">    old = dir-&gt;i_op-&gt;lookup(dir, dentry, flags);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(old)) &#123;  <span class="comment">// 如果查找结果存在</span></span><br><span class="line">        dput(dentry);  <span class="comment">// 释放新分配的 dentry</span></span><br><span class="line">        dentry = old;  <span class="comment">// 使用查找到的老的 dentry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">lookup_fast</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123; <span class="comment">// 定义一个名为lookup_fast的函数，参数为名为nd的nameidata类型的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, *<span class="title">parent</span> =</span> nd-&gt;path.dentry; </span><br><span class="line">    <span class="comment">// 定义两个dentry类型的指针，一个名为dentry，另一个名为parent，并将nd的path的dentry赋值给parent</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 定义一个整型变量status，并初始化为1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Rename seqlock is not required here because in the off chance</span></span><br><span class="line"><span class="comment">     * of a false negative due to a concurrent rename, the caller is</span></span><br><span class="line"><span class="comment">     * going to fall back to non-racy lookup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123; </span><br><span class="line">    <span class="comment">// 如果nd的flags与LOOKUP_RCU做按位与操作结果为真</span></span><br><span class="line">        dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;nd-&gt;next_seq); </span><br><span class="line">        <span class="comment">// 调用__d_lookup_rcu函数，将结果赋值给dentry</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dentry)) &#123; </span><br><span class="line">        <span class="comment">// 如果dentry为NULL</span></span><br><span class="line">            <span class="keyword">if</span> (!try_to_unlazy(nd))</span><br><span class="line">                <span class="comment">// 如果try_to_unlazy函数返回值为0</span></span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line">                <span class="comment">// 返回错误指针ERR_PTR，错误码为-ECHILD</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 返回NULL</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This sequence count validates that the parent had no</span></span><br><span class="line"><span class="comment">         * changes while we did the lookup of the dentry above.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (read_seqcount_retry(&amp;parent-&gt;d_seq, nd-&gt;seq))</span><br><span class="line">            <span class="comment">// 如果read_seqcount_retry函数返回值为真</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line">            <span class="comment">// 返回错误指针ERR_PTR，错误码为-ECHILD</span></span><br><span class="line"></span><br><span class="line">        status = d_revalidate(dentry, nd-&gt;flags);</span><br><span class="line">        <span class="comment">// 调用d_revalidate函数，将获得的状态赋值给status</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(status &gt; <span class="number">0</span>))</span><br><span class="line">            <span class="comment">// 如果status的值大于0</span></span><br><span class="line">            <span class="keyword">return</span> dentry;</span><br><span class="line">            <span class="comment">// 返回dentry</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!try_to_unlazy_next(nd, dentry))</span><br><span class="line">            <span class="comment">// 如果try_to_unlazy_next函数返回值为0</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line">            <span class="comment">// 返回错误指针ERR_PTR，错误码为-ECHILD</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status == -ECHILD)</span><br><span class="line">            <span class="comment">// 如果status的值为-ECHILD</span></span><br><span class="line">            <span class="comment">/* we&#x27;d been told to redo it in non-rcu mode */</span></span><br><span class="line">            status = d_revalidate(dentry, nd-&gt;flags);</span><br><span class="line">            <span class="comment">// 重新调用d_revalidate函数，将获得的状态赋值给status</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dentry = __d_lookup(parent, &amp;nd-&gt;last);</span><br><span class="line">        <span class="comment">// 调用__d_lookup函数，将结果赋值给dentry</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!dentry))</span><br><span class="line">            <span class="comment">// 如果dentry为NULL</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 返回NULL</span></span><br><span class="line"></span><br><span class="line">        status = d_revalidate(dentry, nd-&gt;flags);</span><br><span class="line">        <span class="comment">// 调用d_revalidate函数，将获得的状态赋值给status</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(status &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果status的值小于等于0</span></span><br><span class="line">        <span class="keyword">if</span> (!status)</span><br><span class="line">            <span class="comment">// 如果status的值为0</span></span><br><span class="line">            d_invalidate(dentry);</span><br><span class="line">            <span class="comment">// 调用d_invalidate函数，使dentry无效</span></span><br><span class="line"></span><br><span class="line">        dput(dentry);</span><br><span class="line">        <span class="comment">// 调用dput函数，减少dentry的使用计数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(status);</span><br><span class="line">        <span class="comment">// 返回错误指针ERR_PTR，错误码为status</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line">    <span class="comment">// 返回dentry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fast lookup failed, do it the slow way */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">lookup_slow</span>(<span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">                    <span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dir</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 定义一个慢速查找函数，输入参数为要查找的文件名，父目录的dentry和查找标志</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dir-&gt;d_inode;</span><br><span class="line">    DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);</span><br><span class="line">    <span class="comment">// 定义等待队列头wq</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t go there if it&#x27;s already dead */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(IS_DEADDIR(inode)))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">    <span class="comment">// 如果inode已经死亡（被删除或无效），直接返回错误码ENOENT</span></span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    dentry = d_alloc_parallel(dir, name, &amp;wq);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">return</span> dentry;</span><br><span class="line">    <span class="comment">// 并行分配一个新的dentry，如果返回值是错误指针，直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!d_in_lookup(dentry))) &#123;</span><br><span class="line">        <span class="type">int</span> error = d_revalidate(dentry, flags);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                d_invalidate(dentry);</span><br><span class="line">                dput(dentry);</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果dentry不在查找状态，进行重验证，如果验证失败，使dentry无效，减少其引用计数，然后重新进行查找</span></span><br><span class="line">            dput(dentry);</span><br><span class="line">            dentry = ERR_PTR(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        old = inode-&gt;i_op-&gt;lookup(inode, dentry, flags);</span><br><span class="line">        d_lookup_done(dentry);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(old)) &#123;</span><br><span class="line">            dput(dentry);</span><br><span class="line">            dentry = old;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果dentry在查找状态，调用查找函数，结束查找，如果有旧的dentry，减少新dentry的引用计数，然后使用旧的dentry</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line">    <span class="comment">// 返回查找结果dentry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">lookup_slow</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> qstr *name,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> dentry *dir,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个慢速查找的包装函数，输入参数为要查找的文件名，父目录的dentry和查找标志</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> dir-&gt;d_inode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span>;</span></span><br><span class="line">    inode_lock_shared(inode);</span><br><span class="line">    res = __lookup_slow(name, dir, flags);</span><br><span class="line">    inode_unlock_shared(inode);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 对inode进行共享锁定，然后进行慢速查找，查找结束后解锁，然后返回查找结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">may_lookup</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个内联函数，用于判断是否可以进行查找，参数为idmap和nd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">        <span class="type">int</span> err = inode_permission(idmap, nd-&gt;inode, MAY_EXEC|MAY_NOT_BLOCK);</span><br><span class="line">        <span class="comment">// 如果nd的flags与LOOKUP_RCU按位与的结果为真，则调用inode_permission函数以检查权限，并将结果存储到err中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != -ECHILD || !try_to_unlazy(nd))</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        <span class="comment">// 如果err的值不等于-ECHILD，或者try_to_unlazy函数的返回值为0，则返回err</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inode_permission(idmap, nd-&gt;inode, MAY_EXEC);</span><br><span class="line">    <span class="comment">// 返回inode_permission函数的返回值，用于检查是否有执行权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">reserve_stack</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> path *link)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数，用于预留堆栈，参数为nd和link</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;total_link_count++ &gt;= MAXSYMLINKS))</span><br><span class="line">        <span class="keyword">return</span> -ELOOP;</span><br><span class="line">    <span class="comment">// 如果nd的total_link_count增加后大于等于MAXSYMLINKS，则返回-ELOOP</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(nd-&gt;depth != EMBEDDED_LEVELS))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果nd的depth不等于EMBEDDED_LEVELS，则返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(nd-&gt;<span class="built_in">stack</span> != nd-&gt;internal))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果nd的stack不等于nd的internal，则返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(nd_alloc_stack(nd)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果调用nd_alloc_stack函数后返回非0，那么返回0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">        <span class="comment">// we need to grab link before we do unlazy.  And we can&#x27;t skip</span></span><br><span class="line">        <span class="comment">// unlazy even if we fail to grab the link - cleanup needs it</span></span><br><span class="line">        <span class="type">bool</span> grabbed_link = legitimize_path(nd, link, nd-&gt;next_seq);</span><br><span class="line">        <span class="comment">// 如果nd的flags与LOOKUP_RCU按位与的结果为真，则在调用unlazy之前需要获取link</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!try_to_unlazy(nd) || !grabbed_link)</span><br><span class="line">            <span class="keyword">return</span> -ECHILD;</span><br><span class="line">        <span class="comment">// 如果try_to_unlazy函数的返回值为0，或者grabbed_link为false，则返回-ECHILD</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nd_alloc_stack(nd))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果调用nd_alloc_stack函数后返回非0，那么返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="comment">// 返回-ENOMEM，表示内存不足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span>WALK_TRAILING = <span class="number">1</span>, WALK_MORE = <span class="number">2</span>, WALK_NOFOLLOW = <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 定义一个枚举，枚举值为WALK_TRAILING，WALK_MORE，WALK_NOFOLLOW，值分别为1，2，4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">pick_link</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> path *link,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> inode *inode, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个函数，用于选择链接，参数为nd，link，inode和flags</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saved</span> *<span class="title">last</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *res;</span><br><span class="line">    <span class="type">int</span> error = reserve_stack(nd, link);</span><br><span class="line">    <span class="comment">// 预留堆栈，并将结果存储到error中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(nd-&gt;flags &amp; LOOKUP_RCU))</span><br><span class="line">            path_put(link);</span><br><span class="line">        <span class="comment">// 如果error非0，且nd的flags与LOOKUP_RCU按位与的结果为false，释放路径</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">        <span class="comment">// 返回错误指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    last = nd-&gt;<span class="built_in">stack</span> + nd-&gt;depth++;</span><br><span class="line">    <span class="comment">// 更新last为nd的stack与nd的depth的和，nd的depth自增</span></span><br><span class="line"></span><br><span class="line">    last-&gt;link = *link;</span><br><span class="line">    <span class="comment">// 更新last的link为*link</span></span><br><span class="line"></span><br><span class="line">    clear_delayed_call(&amp;last-&gt;done);</span><br><span class="line">    <span class="comment">// 清除last的done中的延迟调用</span></span><br><span class="line"></span><br><span class="line">    last-&gt;seq = nd-&gt;next_seq;</span><br><span class="line">    <span class="comment">// 更新last的seq为nd的next_seq</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; WALK_TRAILING) &#123;</span><br><span class="line">        error = may_follow_link(nd, inode);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">        <span class="comment">// 如果flags与WALK_TRAILING按位与的结果为真，调用may_follow_link函数，并将结果存储到error中，如果error非0，返回错误指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_SYMLINKS) ||</span><br><span class="line">            unlikely(link-&gt;mnt-&gt;mnt_flags &amp; MNT_NOSYMFOLLOW))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ELOOP);</span><br><span class="line">    <span class="comment">// 如果nd的flags与LOOKUP_NO_SYMLINKS按位与的结果为真，或者link的mnt的mnt_flags与MNT_NOSYMFOLLOW按位与的结果为真，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(nd-&gt;flags &amp; LOOKUP_RCU)) &#123;</span><br><span class="line">        touch_atime(&amp;last-&gt;link);</span><br><span class="line">        cond_resched();</span><br><span class="line">        <span class="comment">// 如果nd的flags与LOOKUP_RCU按位与的结果为false，更新last的link的访问时间，并尝试进行调度</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (atime_needs_update(&amp;last-&gt;link, inode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!try_to_unlazy(nd))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line">        touch_atime(&amp;last-&gt;link);</span><br><span class="line">        <span class="comment">// 否则，如果last的link的访问时间需要更新，尝试调用try_to_unlazy函数，如果返回值为0，返回错误指针，否则，更新last的link的访问时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = security_inode_follow_link(link-&gt;dentry, inode,</span><br><span class="line">                       nd-&gt;flags &amp; LOOKUP_RCU);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">    <span class="comment">// 调用security_inode_follow_link函数，并将结果存储到error中，如果error非0，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    res = READ_ONCE(inode-&gt;i_link);</span><br><span class="line">    <span class="comment">// 读取一次inode的i_link，将结果存储到res中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!res) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> * (*get)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> inode *,</span><br><span class="line">                <span class="keyword">struct</span> delayed_call *);</span><br><span class="line">        get = inode-&gt;i_op-&gt;get_link;</span><br><span class="line">        <span class="comment">// 如果res为NULL，定义一个函数指针get，并将其指向inode的i_op的get_link函数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">            res = get(<span class="literal">NULL</span>, inode, &amp;last-&gt;done);</span><br><span class="line">            <span class="keyword">if</span> (res == ERR_PTR(-ECHILD) &amp;&amp; try_to_unlazy(nd))</span><br><span class="line">                res = get(link-&gt;dentry, inode, &amp;last-&gt;done);</span><br><span class="line">            <span class="comment">// 如果nd的flags与LOOKUP_RCU按位与的结果为真，调用get函数，并将结果存储到res中，如果res为错误指针且try_to_unlazy函数的返回值为非0，再次调用get函数，并将结果存储到res中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = get(link-&gt;dentry, inode, &amp;last-&gt;done);</span><br><span class="line">            <span class="comment">// 否则，调用get函数，并将结果存储到res中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">goto</span> all_done;</span><br><span class="line">        <span class="comment">// 如果res为NULL，跳转到all_done标签</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(res))</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 如果res为错误指针，返回res</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*res == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        error = nd_jump_root(nd);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">        <span class="comment">// 如果res的第一个字符为&#x27;/&#x27;，调用nd_jump_root函数，并将```c</span></span><br><span class="line">    <span class="keyword">if</span> (*res == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        error = nd_jump_root(nd);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">        <span class="comment">// 如果res的第一个字符为&#x27;/&#x27;，调用nd_jump_root函数，并将结果存储到error中，如果error非0，返回错误指针</span></span><br><span class="line">        <span class="keyword">while</span> (unlikely(*++res == <span class="string">&#x27;/&#x27;</span>))</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">// 如果res的下一个字符为&#x27;/&#x27;，将res向后移动一位，直到res的当前字符不为&#x27;/&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*res)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 如果res的第一个字符非空，返回res</span></span><br><span class="line"></span><br><span class="line">all_done: <span class="comment">// pure jump</span></span><br><span class="line">    put_link(nd);</span><br><span class="line">    <span class="comment">// 调用put_link函数，输入参数为nd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们是否需要跟踪链接？我们_真的_希望能够在不必查看inode-&gt;i_op的情况下进行此检查，</span></span><br><span class="line"><span class="comment"> * 因此，对于常见情况，我们保留一个&quot;不，这不需要follow_link&quot;的缓存。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：dentry必须是nd-&gt;next_seq已采样的内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">step_into</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="type">int</span> err = handle_mounts(nd, dentry, &amp;path);  <span class="comment">// 处理挂载情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);    <span class="comment">// 如果处理出错，返回错误指针</span></span><br><span class="line">    inode = path.dentry-&gt;d_inode;</span><br><span class="line">    <span class="keyword">if</span> (likely(!d_is_symlink(path.dentry)) ||   <span class="comment">// 如果dentry不是符号链接</span></span><br><span class="line">       ((flags &amp; WALK_TRAILING) &amp;&amp; !(nd-&gt;flags &amp; LOOKUP_FOLLOW)) || <span class="comment">// 或者我们不需要跟踪链接</span></span><br><span class="line">       (flags &amp; WALK_NOFOLLOW)) &#123;  <span class="comment">// 或者明确指定不需要跟踪链接</span></span><br><span class="line">        <span class="comment">/* not a symlink or should not follow */</span></span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">            <span class="keyword">if</span> (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq))</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ECHILD);  <span class="comment">// 如果序列号不匹配，返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(!inode))</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-ENOENT);  <span class="comment">// 如果inode不存在，返回错误</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dput(nd-&gt;path.dentry);</span><br><span class="line">            <span class="keyword">if</span> (nd-&gt;path.mnt != path.mnt)</span><br><span class="line">                mntput(nd-&gt;path.mnt);</span><br><span class="line">        &#125;</span><br><span class="line">        nd-&gt;path = path;</span><br><span class="line">        nd-&gt;inode = inode;</span><br><span class="line">        nd-&gt;seq = nd-&gt;next_seq;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">        <span class="comment">/* 确保上面的d_is_symlink匹配inode */</span></span><br><span class="line">        <span class="keyword">if</span> (read_seqcount_retry(&amp;path.dentry-&gt;d_seq, nd-&gt;next_seq))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD);  <span class="comment">// 如果序列号不匹配，返回错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.mnt == nd-&gt;path.mnt)</span><br><span class="line">            mntget(path.mnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pick_link(nd, &amp;path, inode, flags);  <span class="comment">// 选择链接进行处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">follow_dotdot_rcu</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span> <span class="comment">// 定义一个函数follow_dotdot_rcu，接收一个参数，返回一个struct dentry指针。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>, *<span class="title">old</span>;</span> <span class="comment">// 定义两个struct dentry指针，parent和old</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root)) <span class="comment">// 如果nd-&gt;path等于nd-&gt;root</span></span><br><span class="line">        <span class="keyword">goto</span> in_root; <span class="comment">// 跳转到in_root标签</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;path.dentry == nd-&gt;path.mnt-&gt;mnt_root)) &#123; <span class="comment">// 如果nd-&gt;path.dentry等于nd-&gt;path.mnt-&gt;mnt_root</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 定义一个struct```c</span></span><br><span class="line">        <span class="type">unsigned</span> seq; <span class="comment">// 定义一个无符号整型变量seq</span></span><br><span class="line">        <span class="keyword">if</span> (!choose_mountpoint_rcu(real_mount(nd-&gt;path.mnt),</span><br><span class="line">                       &amp;nd-&gt;root, &amp;path, &amp;seq)) <span class="comment">// 如果没有选择RCU挂载点</span></span><br><span class="line">            <span class="keyword">goto</span> in_root; <span class="comment">// 跳转到in_root标签</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV)) <span class="comment">// 如果nd-&gt;flags包含LOOKUP_NO_XDEV</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误指针</span></span><br><span class="line">        nd-&gt;path = path; <span class="comment">// 将path赋值给nd-&gt;path</span></span><br><span class="line">        nd-&gt;inode = path.dentry-&gt;d_inode; <span class="comment">// 将path.dentry-&gt;d_inode赋值给nd-&gt;inode</span></span><br><span class="line">        nd-&gt;seq = seq; <span class="comment">// 将seq赋值给nd-&gt;seq</span></span><br><span class="line">        <span class="comment">// 确保非RCU路径步进可以到达这个状态</span></span><br><span class="line">        <span class="keyword">if</span> (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) <span class="comment">// 如果读取序列重试</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误指针</span></span><br><span class="line">        <span class="comment">/* 我们知道挂载点被固定 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    old = nd-&gt;path.dentry; <span class="comment">// 将nd-&gt;path.dentry赋值给old</span></span><br><span class="line">    parent = old-&gt;d_parent; <span class="comment">// 将old-&gt;d_parent赋值给parent</span></span><br><span class="line">    nd-&gt;next_seq = read_seqcount_begin(&amp;parent-&gt;d_seq); <span class="comment">// 读取parent-&gt;d_seq的序列计数开始，并赋值给nd-&gt;next_seq</span></span><br><span class="line">    <span class="comment">// 确保非RCU路径步进可以到达这个状态</span></span><br><span class="line">    <span class="keyword">if</span> (read_seqcount_retry(&amp;old-&gt;d_seq, nd-&gt;seq)) <span class="comment">// 如果读取old-&gt;d_seq的序列计数重试</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!path_connected(nd-&gt;path.mnt, parent))) <span class="comment">// 如果nd-&gt;path.mnt和parent没有连接</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误指针</span></span><br><span class="line">    <span class="keyword">return</span> parent; <span class="comment">// 返回parent</span></span><br><span class="line">in_root: <span class="comment">// in_root标签</span></span><br><span class="line">    <span class="keyword">if</span> (read_seqretry(&amp;mount_lock, nd-&gt;m_seq)) <span class="comment">// 如果读取序列重试</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH)) <span class="comment">// 如果nd-&gt;flags包含LOOKUP_BENEATH</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误指针</span></span><br><span class="line">    nd-&gt;next_seq = nd-&gt;seq; <span class="comment">// 将nd-&gt;seq赋值给nd-&gt;next_seq</span></span><br><span class="line">    <span class="keyword">return</span> nd-&gt;path.dentry; <span class="comment">// 返回nd-&gt;path.dentry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">follow_dotdot</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path_equal(&amp;nd-&gt;path, &amp;nd-&gt;root))  <span class="comment">// 如果当前路径已经是根路径</span></span><br><span class="line">        <span class="keyword">goto</span> in_root;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;path.dentry == nd-&gt;path.mnt-&gt;mnt_root)) &#123;  <span class="comment">// 如果当前的dentry是挂载点的根</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!choose_mountpoint(real_mount(nd-&gt;path.mnt),  <span class="comment">// 选择一个新的挂载点</span></span><br><span class="line">                       &amp;nd-&gt;root, &amp;path))</span><br><span class="line">            <span class="keyword">goto</span> in_root;</span><br><span class="line">        path_put(&amp;nd-&gt;path);  <span class="comment">// 释放旧的路径</span></span><br><span class="line">        nd-&gt;path = path;  <span class="comment">// 更新新的路径</span></span><br><span class="line">        nd-&gt;inode = path.dentry-&gt;d_inode;  <span class="comment">// 更新inode</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_NO_XDEV))  <span class="comment">// 如果不允许跨设备</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-EXDEV);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* rare case of legitimate dget_parent()... */</span></span><br><span class="line">    parent = dget_parent(nd-&gt;path.dentry);  <span class="comment">// 获取父目录</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!path_connected(nd-&gt;path.mnt, parent))) &#123;  <span class="comment">// 如果路径没有连接</span></span><br><span class="line">        dput(parent);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;  <span class="comment">// 返回父目录</span></span><br><span class="line"></span><br><span class="line">in_root:</span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_BENEATH))  <span class="comment">// 如果标志设置了LOOKUP_BENEATH</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EXDEV);</span><br><span class="line">    <span class="keyword">return</span> dget(nd-&gt;path.dentry);  <span class="comment">// 返回当前路径的dentry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">handle_dots</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (type == LAST_DOTDOT) &#123;  <span class="comment">// 如果是&quot;..&quot;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *error = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!nd-&gt;root.mnt) &#123;  <span class="comment">// 如果没有设置根挂载点</span></span><br><span class="line">            error = ERR_PTR(set_root(nd));  <span class="comment">// 设置根路径</span></span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU)  <span class="comment">// 如果是RCU方式</span></span><br><span class="line">            parent = follow_dotdot_rcu(nd);  <span class="comment">// 使用RCU方式获取父目录</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent = follow_dotdot(nd);  <span class="comment">// 否则直接获取父目录</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(parent))  <span class="comment">// 如果出错</span></span><br><span class="line">            <span class="keyword">return</span> ERR_CAST(parent);</span><br><span class="line">        error = step_into(nd, WALK_NOFOLLOW, parent);  <span class="comment">// 进入父目录</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))  <span class="comment">// 如果出错</span></span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(nd-&gt;flags &amp; LOOKUP_IS_SCOPED)) &#123;  <span class="comment">// 如果是受限制的查找</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If there was a racing rename or mount along our</span></span><br><span class="line"><span class="comment">             * path, then we can&#x27;t be sure that &quot;..&quot; hasn&#x27;t jumped</span></span><br><span class="line"><span class="comment">             * above nd-&gt;root (and so userspace should retry or use</span></span><br><span class="line"><span class="comment">             * some fallback).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            smp_rmb();</span><br><span class="line">            <span class="keyword">if</span> (__read_seqcount_retry(&amp;mount_lock.seqcount, nd-&gt;m_seq))  <span class="comment">// 如果有并发的挂载操作</span></span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line">            <span class="keyword">if</span> (__read_seqcount_retry(&amp;rename_lock.seqcount, nd-&gt;r_seq))  <span class="comment">// 如果有并发的重命名操作</span></span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">walk_component</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span>  <span class="comment">// 定义一个目录项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has</span></span><br><span class="line"><span class="comment">     * to be able to know about the current root directory and</span></span><br><span class="line"><span class="comment">     * parent relationships.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// &quot;.&quot; 和 &quot;..&quot; 是特殊的，特别是 &quot;..&quot;，因为它需要知道当前的根目录和父目录关系</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;last_type != LAST_NORM)) &#123;  <span class="comment">// 如果最后一个类型不是常规的</span></span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth)  <span class="comment">// 如果没有更多的路径并且深度不为0</span></span><br><span class="line">            put_link(nd);  <span class="comment">// 释放链接</span></span><br><span class="line">        <span class="keyword">return</span> handle_dots(nd, nd-&gt;last_type);  <span class="comment">// 处理 &quot;..&quot; 和 &quot;.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    dentry = lookup_fast(nd);  <span class="comment">// 快速查找</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))  <span class="comment">// 如果出错</span></span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(dentry);  <span class="comment">// 返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!dentry)) &#123;  <span class="comment">// 如果目录项为空</span></span><br><span class="line">        dentry = lookup_slow(&amp;nd-&gt;last, nd-&gt;path.dentry, nd-&gt;flags);  <span class="comment">// 慢速查找</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(dentry))  <span class="comment">// 如果出错</span></span><br><span class="line">            <span class="keyword">return</span> ERR_CAST(dentry);  <span class="comment">// 返回错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; WALK_MORE) &amp;&amp; nd-&gt;depth)  <span class="comment">// 如果没有更多的路径并且深度不为0</span></span><br><span class="line">        put_link(nd);  <span class="comment">// 释放链接</span></span><br><span class="line">    <span class="keyword">return</span> step_into(nd, flags, dentry); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们可以一次一个单词地进行关键的 dentry 名称比较和散列操作，但我们只限于：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 支持快速无对齐字访问的架构。如果这有助于提高速度，我们可以使用 &quot;get_unaligned()&quot;。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 非 CONFIG_DEBUG_PAGEALLOC 配置（这样我们就不会在跨页操作的（极少见的）情况下陷入陷阱）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 此外，我们需要一个高效的 64 位编译来生成 &quot;最终掩码中的字节数&quot;。再次，这可以用高效的人口统计计数指令或类似的东西替换。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DCACHE_WORD_ACCESS  <span class="comment">// 如果定义了 CONFIG_DCACHE_WORD_ACCESS</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/word-at-a-time.h&gt;</span>  <span class="comment">// 包含头文件 &lt;asm/word-at-a-time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HASH_MIX  <span class="comment">// 如果定义了 HASH_MIX</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 架构在 &lt;asm/hash.h&gt; 中提供了 HASH_MIX 和 fold_hash() */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_64BIT)  <span class="comment">// 否则，如果定义了 CONFIG_64BIT</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 混合函数中的寄存器压力是一个问题，尤其是在 32 位的 x86 上，但几乎任何函数都需要一个状态值和一个临时值。</span></span><br><span class="line"><span class="comment"> * 取而代之的是，使用一个为两个状态值和零临时值设计的函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数不能在只有两次迭代的情况下创建一个冲突，所以我们有两次迭代去实现雪崩效应。在这两次迭代中，</span></span><br><span class="line"><span class="comment"> * 我们有六层混合，这足以将一个比特的影响扩散到 2^6 = 64 的状态比特。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 旋转常数是通过考虑64个一比特输入差或2016个两比特输入差，并找到该差导致每个128个输出比特改变的概率，</span></span><br><span class="line"><span class="comment"> * 使用随机初始状态的样本，得出的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 然后将计算的概率的 Shannon 熵求和，得出一个分数。理想情况下，任何输入变化都有 50% 的几率切换任何给定的输出比特。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 混合分数（以位为单位）对于（12,45）：</span></span><br><span class="line"><span class="comment"> * 输入差：1比特      2比特</span></span><br><span class="line"><span class="comment"> * 1轮：     713.3     42542.6</span></span><br><span class="line"><span class="comment"> * 2轮：    2753.7    140389.8</span></span><br><span class="line"><span class="comment"> * 3轮：    5954.1    233458.2</span></span><br><span class="line"><span class="comment"> * 4轮：    7862.6    256672.2</span></span><br><span class="line"><span class="comment"> * 完美的：  8192      258048</span></span><br><span class="line"><span class="comment"> *           (64*128) (64*63/2 * 128)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_MIX(x, y, a)    \</span></span><br><span class="line"><span class="meta">    (    x ^= (a),    \</span></span><br><span class="line"><span class="meta">    y ^= x,    x = rol64(x,12),\</span></span><br><span class="line"><span class="meta">    x += y,    y = rol64(y,45),\</span></span><br><span class="line"><span class="meta">    y *= 9            )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将两个 longs 折叠成一个 32 位的哈希值。这必须很快，但</span></span><br><span class="line"><span class="comment"> * 延迟并不那么关键，因为在哈希值被使用之前还有相当多的额外</span></span><br><span class="line"><span class="comment"> * 工作要做。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">fold_hash</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x, <span class="type">unsigned</span> <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    y ^= x * GOLDEN_RATIO_64;</span><br><span class="line">    y *= GOLDEN_RATIO_64;</span><br><span class="line">    <span class="keyword">return</span> y &gt;&gt; <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>    <span class="comment">/* 32-bit case */</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 混合分数（以位为单位）对于（7,20）：</span></span><br><span class="line"><span class="comment"> * 输入差：1比特      2-bit</span></span><br><span class="line"><span class="comment"> * 1轮：     330.3     9201.6</span></span><br><span class="line"><span class="comment"> * 2轮：    1246.4    25475.4</span></span><br><span class="line"><span class="comment"> * 3轮：    1907.1    31295.1</span></span><br><span class="line"><span class="comment"> * 4轮：    2042.3    31718.6</span></span><br><span class="line"><span class="comment"> * 完美：    2048      31744</span></span><br><span class="line"><span class="comment"> *           (32*64)   (32*31/2 * 64)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这部分注释描述了一种哈希混合方法的性能。对于一个和两个比特的输入差，分别进行1轮、2轮、3轮和4轮的混合操作后，得出的混合分数与理想情况下的分数进行比较。</span></span><br><span class="line"><span class="comment"> * 混合分数越接近理想分数（完美），说明这种混合方法的性能越好。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_MIX(x, y, a)    \</span></span><br><span class="line"><span class="meta">    (    x ^= (a),    \</span></span><br><span class="line"><span class="meta">    y ^= x,    x = rol32(x, 7),\</span></span><br><span class="line"><span class="meta">    x += y,    y = rol32(y,20),\</span></span><br><span class="line"><span class="meta">    y *= 9            )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了一个名为 HASH_MIX 的宏，它接受三个参数：x，y和a。</span></span><br><span class="line"><span class="comment"> * 宏的主体是一个表达式序列，其中包括几个位操作和算术操作，</span></span><br><span class="line"><span class="comment"> * 这些操作可以混合和扩散输入值的比特，以改善哈希函数的性能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">fold_hash</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> x, <span class="type">unsigned</span> <span class="type">long</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Use arch-optimized multiply if one exists */</span></span><br><span class="line">    <span class="keyword">return</span> __hash_32(y ^ __hash_32(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 定义了一个名为 fold_hash 的内联函数，它接受两个 unsigned long 参数：x 和 y。</span></span><br><span class="line"><span class="comment"> * 函数首先执行 XOR 操作，然后调用 __hash_32 函数将结果折叠为一个32位的哈希值。</span></span><br><span class="line"><span class="comment"> * 这个函数也考虑了系统架构的优化，如果存在针对特定架构优化的乘法操作，它会使用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &#x27;#endif&#x27; 是预处理器指令的结束标志，表示前面的条件编译块结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回已知长度字符串的哈希值。这个函数被精心设计来匹配 hash_name() 函数，后者是更重要的函数。</span></span><br><span class="line"><span class="comment"> * 特别是，我们必须通过哈希一个最终的包含0..7个有效字节的词来结束，</span></span><br><span class="line"><span class="comment"> * 以匹配 hash_name() 函数迭代直到找到名字后的分隔符的方式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">full_name_hash</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *salt, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> a, x = <span class="number">0</span>, y = (<span class="type">unsigned</span> <span class="type">long</span>)salt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">            <span class="keyword">goto</span> done;  <span class="comment">// 如果长度为0，直接跳到done</span></span><br><span class="line">        a = load_unaligned_zeropad(name);  <span class="comment">// 从name加载一个未对齐的值，并补0</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>))</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 如果长度小于unsigned long的字节长度，跳出循环</span></span><br><span class="line">        HASH_MIX(x, y, a);  <span class="comment">// 执行哈希混合操作</span></span><br><span class="line">        name += <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);  <span class="comment">// 移动name的指针</span></span><br><span class="line">        len -= <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);  <span class="comment">// 减少len的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    x ^= a &amp; bytemask_from_count(len);  <span class="comment">// 执行XOR操作</span></span><br><span class="line">done:</span><br><span class="line">    <span class="keyword">return</span> fold_hash(x, y);  <span class="comment">// 返回折叠后的哈希值</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(full_name_hash);  <span class="comment">// 导出full_name_hash符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回一个以空字符结束的字符串的&quot;hash_len&quot;（哈希值和长度） */</span></span><br><span class="line">u64 <span class="title function_">hashlen_string</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *salt, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> a = <span class="number">0</span>, x = <span class="number">0</span>, y = (<span class="type">unsigned</span> <span class="type">long</span>)salt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> adata, mask, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">word_at_a_time</span> <span class="title">constants</span> =</span> WORD_AT_A_TIME_CONSTANTS;</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> inside;  <span class="comment">// 直接跳到inside标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HASH_MIX(x, y, a);  <span class="comment">// 执行哈希混合操作</span></span><br><span class="line">        len += <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);  <span class="comment">// 增加len的值</span></span><br><span class="line">inside:</span><br><span class="line">        a = load_unaligned_zeropad(name+len);  <span class="comment">// 从name+len加载一个未对齐的值，并补0</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!has_zero(a, &amp;adata, &amp;constants));  <span class="comment">// 循环直到a中有0</span></span><br><span class="line"></span><br><span class="line">    adata = prep_zero_mask(a, adata, &amp;constants);  <span class="comment">// 准备零掩码</span></span><br><span class="line">    mask = create_zero_mask(adata);  <span class="comment">// 创建零掩码</span></span><br><span class="line">    x ^= a &amp; zero_bytemask(mask);  <span class="comment">// 执行XOR操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashlen_create(fold_hash(x, y), len + find_zero(mask));  <span class="comment">// 创建hashlen</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(hashlen_string);  <span class="comment">// 导出hashlen_string符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算路径组件的长度和哈希值，并返回&quot;hash_len&quot;作为结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title function_">hash_name</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *salt, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> a = <span class="number">0</span>, b, x = <span class="number">0</span>, y = (<span class="type">unsigned</span> <span class="type">long</span>)salt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> adata, bdata, mask, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">word_at_a_time</span> <span class="title">constants</span> =</span> WORD_AT_A_TIME_CONSTANTS;</span><br><span class="line"></span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> inside;  <span class="comment">// 直接跳到inside标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HASH_MIX(x, y, a);  <span class="comment">// 执行哈希混合操作</span></span><br><span class="line">        len += <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);  <span class="comment">// 增加len的值</span></span><br><span class="line">inside:</span><br><span class="line">        a = load_unaligned_zeropad(name+len);  <span class="comment">// 从name+len加载一个未对齐的值，并补0</span></span><br><span class="line">        b = a ^ REPEAT_BYTE(<span class="string">&#x27;/&#x27;</span>);  <span class="comment">// 执行XOR操作</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!(has_zero(a, &amp;adata, &amp;constants) | has_zero(b, &amp;bdata, &amp;constants)));  <span class="comment">// 循环直到a或b中有0</span></span><br><span class="line"></span><br><span class="line">    adata = prep_zero_mask(a, adata, &amp;constants);  <span class="comment">// 准备零掩码</span></span><br><span class="line">    bdata = prep_zero_mask(b, bdata, &amp;constants);  <span class="comment">// 准备零掩码</span></span><br><span class="line">    mask = create_zero_mask(adata | bdata);  <span class="comment">// 创建零掩码</span></span><br><span class="line">    x ^= a &amp; zero_bytemask(mask);  <span class="comment">// 执行XOR操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hashlen_create(fold_hash(x, y), len + find_zero(mask));  <span class="comment">// 创建hash```c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>    <span class="comment">/* !CONFIG_DCACHE_WORD_ACCESS: 慢速，逐字节版本 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回已知长度字符串的哈希值 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">full_name_hash</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *salt, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hash = init_name_hash(salt);  <span class="comment">// 初始化名字哈希值</span></span><br><span class="line">    <span class="keyword">while</span> (len--)</span><br><span class="line">        hash = partial_name_hash((<span class="type">unsigned</span> <span class="type">char</span>)*name++, hash);  <span class="comment">// 对每一个字节进行哈希</span></span><br><span class="line">    <span class="keyword">return</span> end_name_hash(hash);  <span class="comment">// 结束名字哈希</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(full_name_hash);  <span class="comment">// 导出full_name_hash符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回一个以空字符结束的字符串的&quot;hash_len&quot;（哈希值和长度） */</span></span><br><span class="line">u64 <span class="title function_">hashlen_string</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *salt, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hash = init_name_hash(salt);  <span class="comment">// 初始化名字哈希值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len = <span class="number">0</span>, c;</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">unsigned</span> <span class="type">char</span>)*name;</span><br><span class="line">    <span class="keyword">while</span> (c) &#123;</span><br><span class="line">        len++;</span><br><span class="line">        hash = partial_name_hash(c, hash);  <span class="comment">// 对每一个字节进行哈希</span></span><br><span class="line">        c = (<span class="type">unsigned</span> <span class="type">char</span>)name[len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashlen_create(end_name_hash(hash), len);  <span class="comment">// 创建hashlen</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(hashlen_string);  <span class="comment">// 导出hashlen_string符号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 我们知道这里至少有一个真实的路径组件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u64 <span class="title function_">hash_name</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *salt, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hash = init_name_hash(salt);  <span class="comment">// 初始化名字哈希值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len = <span class="number">0</span>, c;</span><br><span class="line"></span><br><span class="line">    c = (<span class="type">unsigned</span> <span class="type">char</span>)*name;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len++;</span><br><span class="line">        hash = partial_name_hash(c, hash);  <span class="comment">// 对每一个字节进行哈希</span></span><br><span class="line">        c = (<span class="type">unsigned</span> <span class="type">char</span>)name[len];</span><br><span class="line">    &#125; <span class="keyword">while</span> (c &amp;&amp; c != <span class="string">&#x27;/&#x27;</span>);  <span class="comment">// 循环直到遇到空字符或者&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> hashlen_create(end_name_hash(hash), len);  <span class="comment">// 创建hashlen</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">link_path_walk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 初始化深度为 0，用于记录符号链接的嵌套层数</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 nd-&gt;last_type 和 nd-&gt;flags</span></span><br><span class="line">    nd-&gt;last_type = LAST_ROOT; <span class="comment">// 设置 nd-&gt;last_type 为 LAST_ROOT</span></span><br><span class="line">    nd-&gt;flags |= LOOKUP_PARENT; <span class="comment">// 更新 nd-&gt;flags，添加 LOOKUP_PARENT 标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径名是错误的，返回错误值</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(name)) <span class="comment">// 检查路径名是否有效（不是错误指针）</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(name); <span class="comment">// 如果无效，返回错误值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过路径名开头的 &#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (*name == <span class="string">&#x27;/&#x27;</span>) <span class="comment">// 当路径名以 &#x27;/&#x27; 开头时，进入循环</span></span><br><span class="line">        name++; <span class="comment">// 将 name 指针向后移动一位，跳过 &#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果路径名为空，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (!*name) &#123; <span class="comment">// 检查路径名是否为空（在跳过开头的 &#x27;/&#x27; 之后）</span></span><br><span class="line">        nd-&gt;dir_mode = <span class="number">0</span>; <span class="comment">// 将 nd-&gt;dir_mode 设置为 0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0，表示路径查找结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始循环处理路径名的每个组件</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，直到路径名的所有组件都被处理</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *link;</span><br><span class="line">        u64 hash_len;</span><br><span class="line">        <span class="type">int</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件系统 ID 映射,文件系统 ID 映射用于将 VFS 中的用户和组 ID 转换为底层文件系统中的用户和组 ID。</span></span><br><span class="line">        idmap = mnt_idmap(nd-&gt;path.mnt); <span class="comment">// 获取 nd-&gt;path.mnt 对应的文件系统 ID 映射</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否有权限执行查找操作</span></span><br><span class="line">        err = may_lookup(idmap, nd); <span class="comment">// 检查当前用户是否有权限查找</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="comment">// 如果没有权限</span></span><br><span class="line">            <span class="keyword">return</span> err; <span class="comment">// 返回错误值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算当前路径组件的哈希值和长度,这些值将用于在散列查找中快速比较路径名组件。</span></span><br><span class="line">        hash_len = hash_name(nd-&gt;path.dentry, name); <span class="comment">// 计算哈希值和长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前路径组件的类型（&#x27;.&#x27;、&#x27;..&#x27; 或普通组件）</span></span><br><span class="line">        type = LAST_NORM; <span class="comment">// 默认为普通组件</span></span><br><span class="line">        <span class="keyword">if</span> (name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">switch</span> (hashlen_len(hash_len)) &#123; <span class="comment">// 如果组件以 &#x27;.&#x27; 开头，检查长度</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (name[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 如果组件为 &quot;..&quot;</span></span><br><span class="line">                    type = LAST_DOTDOT; <span class="comment">// 设置类型为 LAST_DOTDOT</span></span><br><span class="line">                    nd-&gt;state |= ND_JUMPED; <span class="comment">// 更新 nd-&gt;state，添。这个标志表示我们正跳转到父目录。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                type = LAST_DOT; <span class="comment">// 如果组件为 &quot;.&quot;，设置类型为 LAST_DOT</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (likely(type == LAST_NORM)) &#123; <span class="comment">// 如果组件类型为普通组件</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> nd-&gt;path.dentry; <span class="comment">// 获取当前组件的父目录</span></span><br><span class="line">            nd-&gt;state &amp;= ~ND_JUMPED; <span class="comment">// 清除 nd-&gt;state 的 ND_JUMPED 标志</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果需要，执行自定义哈希操作。某些文件系统可能需要自定义哈希操作以适应其特定的查找机制。</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(parent-&gt;d_flags &amp; DCACHE_OP_HASH)) &#123; <span class="comment">// 检查父目录是否需要自定义哈希操作</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span> =</span> &#123; &#123; .hash_len = hash_len &#125;, .name = name &#125;; <span class="comment">// 初始化 qstr 结构体</span></span><br><span class="line">                err = parent-&gt;d_op-&gt;d_hash(parent, &amp;this); <span class="comment">// 执行自定义哈希操作</span></span><br><span class="line">                <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="comment">// 如果操作失败</span></span><br><span class="line">                    <span class="keyword">return</span> err; <span class="comment">// 返回错误值</span></span><br><span class="line">                hash_len = this.hash_len; <span class="comment">// 更新哈希值和长度</span></span><br><span class="line">                name = this.name; <span class="comment">// 更新 name 指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">//---------------------------------------------------------------------</span></span><br><span class="line">        <span class="comment">// 更新 nd 的 last 和 last_type 成员</span></span><br><span class="line">        nd-&gt;last.hash_len = hash_len; <span class="comment">// 设置 nd-&gt;last 的哈希值和长度</span></span><br><span class="line">        nd-&gt;last.name = name; <span class="comment">// 设置 nd-&gt;last 的名称</span></span><br><span class="line">        nd-&gt;last_type = type; <span class="comment">// 设置 nd-&gt;last_type 为当前组件的类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 name 指针向后移动到下一个路径组件</span></span><br><span class="line">        name += hashlen_len(hash_len); <span class="comment">// 将 name 指针向后移动到下一个路径组件的起始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到达路径名的结尾，处理结束</span></span><br><span class="line">        <span class="keyword">if</span> (!*name) <span class="comment">// 检查是否到达路径名的结尾</span></span><br><span class="line">            <span class="keyword">goto</span> OK; <span class="comment">// 跳转到 OK 标签</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过连续的 &#x27;/&#x27;</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            name++; <span class="comment">// 将 name 指针向后移动一位</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (unlikely(*name == <span class="string">&#x27;/&#x27;</span>)); <span class="comment">// 当遇到 &#x27;/&#x27; 时，继续循环</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到达路径名的结尾，处理结束</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!*name)) &#123; <span class="comment">// 再次检查是否到达路径名的结尾</span></span><br><span class="line">OK:</span><br><span class="line">            <span class="comment">// pathname or trailing symlink, done</span></span><br><span class="line">            <span class="keyword">if</span> (!depth) &#123; <span class="comment">// 如果当前处理的路径组件不是符号链接的一部分</span></span><br><span class="line">                nd-&gt;dir_vfsuid = i_uid_into_vfsuid(idmap, nd-&gt;inode); <span class="comment">// 设置 nd-&gt;dir_vfsuid</span></span><br><span class="line">                nd-&gt;dir_mode = nd-&gt;inode-&gt;i_mode; <span class="comment">// 设置 nd-&gt;dir_mode</span></span><br><span class="line">                nd-&gt;flags &amp;= ~LOOKUP_PARENT; <span class="comment">// 清除 nd-&gt;flags 的 LOOKUP_PARENT 标志</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0，表示路径查找结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// last component of nested symlink</span></span><br><span class="line">            name = nd-&gt;<span class="built_in">stack</span>[--depth].name; <span class="comment">// 获取符号链接栈中下一个组件的名称</span></span><br><span class="line">            link = walk_component(nd, <span class="number">0</span>); <span class="comment">// 处理当前组件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// not the last component</span></span><br><span class="line">            link = walk_component(nd, WALK_MORE); <span class="comment">// 处理当前组件，传递 WALK_MORE 标志</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 link 不为空，表示需要处理符号链接</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(link)) &#123; <span class="comment">// 检查 link 是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(link)) <span class="comment">// 如果 link 是错误指针</span></span><br><span class="line">                <span class="keyword">return</span> PTR_ERR(link); <span class="comment">// 返回错误值</span></span><br><span class="line">            <span class="comment">// a symlink to follow</span></span><br><span class="line">            nd-&gt;<span class="built_in">stack</span>[depth++].name = name; <span class="comment">// 将当前组件的名称压入符号链接栈</span></span><br><span class="line">            name = link; <span class="comment">// 将 name 指针设置为符号链接的目标路径</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 继续循环处理符号链接的目标路径</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 dentry 是否可以执行查找操作</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!d_can_lookup(nd-&gt;path.dentry))) &#123; <span class="comment">// 如果不能执行查找操作</span></span><br><span class="line">            <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123; <span class="comment">// 如果 nd-&gt;flags 中包含 LOOKUP_RCU 标志</span></span><br><span class="line">                <span class="keyword">if</span> (!try_to_unlazy(nd)) <span class="comment">// 尝试取消对 nd 的懒加载</span></span><br><span class="line">                    <span class="keyword">return</span> -ECHILD; <span class="comment">// 如果取消失败，返回 -ECHILD 错误值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -ENOTDIR; <span class="comment">// 返回 -ENOTDIR 错误值，表示不是目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 此函数初始化路径查找。返回的字符串指针是路径名的剩余部分。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">path_init</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = nd-&gt;name-&gt;name;  <span class="comment">// 获取路径名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果只设置了 LOOKUP_CACHED 而未设置 LOOKUP_RCU，则要求调用方重试 */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; (LOOKUP_RCU | LOOKUP_CACHED)) == LOOKUP_CACHED)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EAGAIN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!*s)  <span class="comment">// 如果路径名为空，则关闭 LOOKUP_RCU</span></span><br><span class="line">        flags &amp;= ~LOOKUP_RCU;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; LOOKUP_RCU)  <span class="comment">// 如果设置了 LOOKUP_RCU，则进行 RCU 读锁定</span></span><br><span class="line">        rcu_read_lock();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nd-&gt;seq = nd-&gt;next_seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    nd-&gt;flags = flags;  <span class="comment">// 设置标志位</span></span><br><span class="line">    nd-&gt;state |= ND_JUMPED;  <span class="comment">// 设置状态为已跳转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始读取挂载锁和重命名锁的序列计数</span></span><br><span class="line">    nd-&gt;m_seq = __read_seqcount_begin(&amp;mount_lock.seqcount);</span><br><span class="line">    nd-&gt;r_seq = __read_seqcount_begin(&amp;rename_lock.seqcount);</span><br><span class="line">    smp_rmb();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;state &amp; ND_ROOT_PRESET) &#123;  <span class="comment">// 如果设置了 ND_ROOT_PRESET</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">root</span> =</span> nd-&gt;root.dentry;  <span class="comment">// 获取根目录项</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> root-&gt;d_inode;  <span class="comment">// 获取根目录项的索引节点</span></span><br><span class="line">        <span class="keyword">if</span> (*s &amp;&amp; unlikely(!d_can_lookup(root)))  <span class="comment">// 如果路径名不为空且根目录项无法查找，则返回错误</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOTDIR);</span><br><span class="line">        nd-&gt;path = nd-&gt;root;  <span class="comment">// 设置路径为根路径</span></span><br><span class="line">        nd-&gt;inode = inode;  <span class="comment">// 设置索引节点</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;  <span class="comment">// 如果设置了 LOOKUP_RCU</span></span><br><span class="line">            nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);  <span class="comment">// 开始读取路径的目录项的序列计数</span></span><br><span class="line">            nd-&gt;root_seq = nd-&gt;seq;  <span class="comment">// 设置根序列计数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path_get(&amp;nd-&gt;path);  <span class="comment">// 获取路径</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;  <span class="comment">// 返回路径名的剩余部分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nd-&gt;root.mnt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是绝对路径名，则获取根目录 */</span></span><br><span class="line">    <span class="keyword">if</span> (*s == <span class="string">&#x27;/&#x27;</span> &amp;&amp; !(flags &amp; LOOKUP_IN_ROOT)) &#123;</span><br><span class="line">        error = nd_jump_root(nd);  <span class="comment">// 跳转到根目录</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(error))  <span class="comment">// 如果返回错误，则返回错误</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">        <span class="keyword">return</span> s;  <span class="comment">// 返回路径名的剩余部分</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是相对路径名，则获取它相对的起始点 */</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;dfd == AT_FDCWD) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;  <span class="comment">// 如果设置了 LOOKUP_RCU</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span> =</span> current-&gt;fs;</span><br><span class="line">            <span class="type">unsigned</span> seq;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                seq = read_seqcount_begin(&amp;fs-&gt;seq);  <span class="comment">// 开始读取文件系统的序列计数</span></span><br><span class="line">                nd-&gt;path = fs-&gt;pwd;  <span class="comment">// 设置路径为当前工作目录</span></span><br><span class="line">                nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;  <span class="comment">// 设置索引节点</span></span><br><span class="line">                nd-&gt;seq = __read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);  <span class="comment">// 开始读取路径的目录项的序列计数</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (read_seqcount_retry(&amp;fs-&gt;seq, seq));  <span class="comment">// 如果文件系统的序列计数有变，则重试</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            get_fs_pwd(current-&gt;fs, &amp;nd-&gt;path);  <span class="comment">// 获取当前工作目录</span></span><br><span class="line">            nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;  <span class="comment">// 设置索引节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 调用方必须检查起始路径组件的执行权限 */</span></span><br><span class="line">        <span class="keyword">struct</span> fd f = fdget_raw(nd-&gt;dfd);  <span class="comment">// 获取文件描述符</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!f.file)  <span class="comment">// 如果文件不存在，则返回错误</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-EBADF);</span><br><span class="line"></span><br><span class="line">        dentry = f.file-&gt;f_path.dentry;  <span class="comment">// 获取文件的目录```c</span></span><br><span class="line">        <span class="keyword">if</span> (*s &amp;&amp; unlikely(!d_can_lookup(dentry))) &#123;  <span class="comment">// 如果路径名不为空且目录项无法查找，则返回错误</span></span><br><span class="line">            fdput(f);  <span class="comment">// 释放文件描述符</span></span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ENOTDIR);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nd-&gt;path = f.file-&gt;f_path;  <span class="comment">// 设置路径为文件的路径</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;  <span class="comment">// 如果设置了 LOOKUP_RCU</span></span><br><span class="line">            nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;  <span class="comment">// 设置索引节点</span></span><br><span class="line">            nd-&gt;seq = read_seqcount_begin(&amp;nd-&gt;path.dentry-&gt;d_seq);  <span class="comment">// 开始读取路径的目录项的序列计数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path_get(&amp;nd-&gt;path);  <span class="comment">// 获取路径</span></span><br><span class="line">            nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;  <span class="comment">// 设置索引节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        fdput(f);  <span class="comment">// 释放文件描述符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对于限定范围的查找，我们需要将根设置为 dirfd */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; LOOKUP_IS_SCOPED) &#123;</span><br><span class="line">        nd-&gt;root = nd-&gt;path;  <span class="comment">// 设置根为路径</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU) &#123;  <span class="comment">// 如果设置了 LOOKUP_RCU</span></span><br><span class="line">            nd-&gt;root_seq = nd-&gt;seq;  <span class="comment">// 设置根序列计数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            path_get(&amp;nd-&gt;root);  <span class="comment">// 获取根路径</span></span><br><span class="line">            nd-&gt;state |= ND_ROOT_GRABBED;  <span class="comment">// 设置状态为已获取根</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;  <span class="comment">// 返回路径名的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数负责查找路径的最后一个组件，如果最后一个组件是普通类型且后面还有字符，则设置查找标志为 FOLLOW 和 DIRECTORY，并走向下一个组件 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">lookup_last</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;last_type == LAST_NORM &amp;&amp; nd-&gt;last.name[nd-&gt;last.len])</span><br><span class="line">        nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> walk_component(nd, WALK_TRAILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数处理路径下降的情况，如果不在 RCU 模式下，则获取目录项的引用，然后进入下一步 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_lookup_down</span><span class="params">(<span class="keyword">struct</span> nameidata *nd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(nd-&gt;flags &amp; LOOKUP_RCU))</span><br><span class="line">        dget(nd-&gt;path.dentry);</span><br><span class="line">    nd-&gt;next_seq = nd-&gt;seq;</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(step_into(nd, WALK_NOFOLLOW, nd-&gt;path.dentry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数进行路径查找，初始化路径后，如果设置了 LOOKUP_DOWN，则处理路径下降的情况，然后进行链接路径的遍历，完成路径的遍历后，检查是否设置了 LOOKUP_MOUNTPOINT，如果是，则再次处理路径下降的情况，最后如果设置了 LOOKUP_DIRECTORY，则检查是否可以进行目录查找，如果不能则返回错误，否则设置路径并终止路径遍历 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">path_lookupat</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">unsigned</span> flags, <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = path_init(nd, flags);  <span class="comment">// 初始化路径</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(flags &amp; LOOKUP_DOWN) &amp;&amp; !IS_ERR(s)) &#123;  <span class="comment">// 如果设置了 LOOKUP_DOWN，则处理路径下降的情况</span></span><br><span class="line">        err = handle_lookup_down(nd);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(err &lt; <span class="number">0</span>))</span><br><span class="line">            s = ERR_PTR(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!(err = link_path_walk(s, nd)) &amp;&amp;  <span class="comment">// 遍历链接路径</span></span><br><span class="line">           (s = lookup_last(nd)) != <span class="literal">NULL</span>)  <span class="comment">// 查找路径的最后一个组件</span></span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; unlikely(nd-&gt;flags &amp; LOOKUP_MOUNTPOINT)) &#123;  <span class="comment">// 如果没有错误且设置了 LOOKUP_MOUNTPOINT，则处理路径下降的情况</span></span><br><span class="line">        err = handle_lookup_down(nd);</span><br><span class="line">        nd-&gt;state &amp;= ~ND_JUMPED; <span class="comment">// no d_weak_revalidate(), please...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err)  <span class="comment">// 如果没有错误，则完成路径遍历</span></span><br><span class="line">        err = complete_walk(nd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err &amp;&amp; nd-&gt;flags &amp; LOOKUP_DIRECTORY)  <span class="comment">// 如果没有错误且设置了 LOOKUP_DIRECTORY，则检查是否可以进行目录查找</span></span><br><span class="line">        <span class="keyword">if</span> (!d_can_lookup(nd-&gt;path.dentry))</span><br><span class="line">            err = -ENOTDIR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;  <span class="comment">// 如果没有错误，则设置路径</span></span><br><span class="line">        *path = nd-&gt;path;</span><br><span class="line">        nd-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">        nd-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    terminate_walk(nd);  <span class="comment">// 终止路径遍历</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数负责查找文件名对应的路径，首先设置名称数据，然后进行路径查找。如果返回值是 -ECHILD 或者 -ESTALE，就会再次进行路径查找，最后如果没有错误，就会审计节点并恢复名称数据 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">filename_lookup</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> path *path, <span class="keyword">struct</span> path *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(name))  <span class="comment">// 如果文件名出错，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(name);</span><br><span class="line">    set_nameidata(&amp;nd, dfd, name, root);  <span class="comment">// 设置名称数据</span></span><br><span class="line">    retval = path_lookupat(&amp;nd, flags | LOOKUP_RCU, path);  <span class="comment">// 进行路径查找</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(retval == -ECHILD))  <span class="comment">// 如果返回值是 -ECHILD，再次进行路径查找</span></span><br><span class="line">        retval = path_lookupat(&amp;nd, flags, path);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(retval == -ESTALE))  <span class="comment">// 如果返回值是 -ESTALE，再次进行路径查找</span></span><br><span class="line">        retval = path_lookupat(&amp;nd, flags | LOOKUP_REVAL, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!retval))  <span class="comment">// 如果没有错误，审计节点</span></span><br><span class="line">        audit_inode(name, path-&gt;dentry,</span><br><span class="line">                flags &amp; LOOKUP_MOUNTPOINT ? AUDIT_INODE_NOEVAL : <span class="number">0</span>);</span><br><span class="line">    restore_nameidata();  <span class="comment">// 恢复名称数据</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数负责获取路径的父路径，首先初始化路径，然后进行链接路径遍历，最后完成路径遍历并设置父路径 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">path_parentat</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> path *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *s = path_init(nd, flags);  <span class="comment">// 初始化路径</span></span><br><span class="line">    <span class="type">int</span> err = link_path_walk(s, nd);  <span class="comment">// 遍历链接路径</span></span><br><span class="line">    <span class="keyword">if</span> (!err)  <span class="comment">// 如果没有错误，完成路径遍历</span></span><br><span class="line">        err = complete_walk(nd);</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;  <span class="comment">// 如果没有错误，设置父路径</span></span><br><span class="line">        *parent = nd-&gt;path;</span><br><span class="line">        nd-&gt;path.mnt = <span class="literal">NULL</span>;</span><br><span class="line">        nd-&gt;path.dentry = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    terminate_walk(nd);  <span class="comment">// 终止路径遍历</span></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数获取文件名的父路径，首先设置名称数据，然后获取父路径。如果返回值是 -ECHILD 或者 -ESTALE，就会再次获取父路径，最后如果没有错误，就会设置最后一个组件的名称和类型，并审计节点 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">filename_parentat</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name,</span></span><br><span class="line"><span class="params">                 <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> path *parent,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> qstr *last, <span class="type">int</span> *type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(name))  <span class="comment">// 如果文件名出错，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(name);</span><br><span class="line">    set_nameidata(&amp;nd, dfd, name, <span class="literal">NULL</span>);  <span class="comment">// 设置名称数据</span></span><br><span class="line">    retval = path_parentat(&amp;nd, flags | LOOKUP_RCU, parent);  <span class="comment">// 获取父路径</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(retval == -ECHILD))  <span class="comment">// 如果返回值是 -ECHILD，再次获取父路径</span></span><br><span class="line">        retval = path_parentat(&amp;nd, flags, parent);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(retval == -ESTALE))  <span class="comment">// 如果返回值是 -ESTALE，再次获取父路径</span></span><br><span class="line">        retval = path_parentat(&amp;nd, flags | LOOKUP_REVAL, parent);</span><br><span class="line">    <span class="keyword">if</span> (likely(!retval)) &#123;  <span class="comment">// 如果没有错误，设置最后一个组件的名称和类型，并审计节点</span></span><br><span class="line">        *last = nd.last;</span><br><span class="line">        *type = nd.last_type;</span><br><span class="line">        audit_inode(name, parent-&gt;dentry, AUDIT_INODE_PARENT);</span><br><span class="line">    &#125;</span><br><span class="line">    restore_nameidata();  <span class="comment">// 恢复名称数据</span></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数首先获取文件名的父路径，然后如果类型不是 LAST_NORM，就会释放路径并返回错误。然后锁定父节点并进行查找。如果查找失败，就会解锁并释放路径。 */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *__<span class="title">kern_path_locked</span>(<span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">name</span>, <span class="keyword">struct</span> <span class="title">path</span> *<span class="title">path</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span></span><br><span class="line">    <span class="type">int</span> type, error;</span><br><span class="line"></span><br><span class="line">    error = filename_parentat(AT_FDCWD, name, <span class="number">0</span>, path, &amp;last, &amp;type);  <span class="comment">// 获取文件名的父路径</span></span><br><span class="line">    <span class="keyword">if</span> (error)  <span class="comment">// 如果出错，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(type != LAST_NORM)) &#123;  <span class="comment">// 如果类型不是 LAST_NORM，释放路径并返回错误</span></span><br><span class="line">        path_put(path);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    inode_lock_nested(path-&gt;dentry-&gt;d_inode, I_MUTEX_PARENT);  <span class="comment">// 锁定父节点</span></span><br><span class="line">    d = __lookup_hash(&amp;last, path-&gt;dentry, <span class="number">0</span>);  <span class="comment">// 进行查找</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(d)) &#123;  <span class="comment">// 如果查找失败，解锁并释放路径</span></span><br><span class="line">        inode_unlock(path-&gt;dentry-&gt;d_inode);</span><br><span class="line">        path_put(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数获取文件名，并进行路径查找，最后释放文件名 */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">kern_path_locked</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">filename</span> =</span> getname_kernel(name);  <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span> =</span> __kern_path_locked(filename, path);  <span class="comment">// 进行路径查找</span></span><br><span class="line"></span><br><span class="line">    putname(filename);  <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个函数获取文件名，并进行文件名查找，最后释放文件名 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kern_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">filename</span> =</span> getname_kernel(name);  <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="type">int</span> ret = filename_lookup(AT_FDCWD, filename, flags, path, <span class="literal">NULL</span>);  <span class="comment">// 进行文件名查找</span></span><br><span class="line"></span><br><span class="line">    putname(filename);  <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kern_path);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_path_lookup - lookup a file path relative to a dentry-vfsmount pair</span></span><br><span class="line"><span class="comment"> * @dentry:  pointer to dentry of the base directory</span></span><br><span class="line"><span class="comment"> * @mnt: pointer to vfs mount of the base directory</span></span><br><span class="line"><span class="comment"> * @name: pointer to file name</span></span><br><span class="line"><span class="comment"> * @flags: lookup flags</span></span><br><span class="line"><span class="comment"> * @path: pointer to struct path to fill</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数首先获取文件名，然后进行文件名查找，最后释放文件名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_path_lookup</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> vfsmount *mnt,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="type">char</span> *name, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">filename</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">root</span> =</span> &#123;.mnt = mnt, .dentry = dentry&#125;;  <span class="comment">// 设置根路径</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    filename = getname_kernel(name);  <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="comment">/* the first argument of filename_lookup() is ignored with root */</span></span><br><span class="line">    ret = filename_lookup(AT_FDCWD, filename, flags, path, &amp;root);  <span class="comment">// 进行文件名查找</span></span><br><span class="line">    putname(filename);  <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_path_lookup);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">定义一个函数 lookup_one_common，该函数用于在基础目录中查找指定名称的目录项。</span></span><br><span class="line"><span class="comment">idmap: 用户和组的身份映射；</span></span><br><span class="line"><span class="comment">name: 需要查找的目录项名称；</span></span><br><span class="line"><span class="comment">base: 基础目录；</span></span><br><span class="line"><span class="comment">len: 名称的长度；</span></span><br><span class="line"><span class="comment">this: qstr（quick string）结构的指针，用于存储查找的结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lookup_one_common</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> qstr *this)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化 this 结构 */</span></span><br><span class="line">    this-&gt;name = name;</span><br><span class="line">    this-&gt;len = len;</span><br><span class="line">    <span class="comment">/* 计算并设置哈希值 */</span></span><br><span class="line">    this-&gt;hash = full_name_hash(base, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果名称长度为0，返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (!len)</span><br><span class="line">        <span class="keyword">return</span> -EACCES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果名称以&#x27;.&#x27;开始，且长度小于2或者长度等于2且第二个字符也为&#x27;.&#x27;，返回错误 */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(name[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span> || (len == <span class="number">2</span> &amp;&amp; name[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果名称中包含&#x27;/&#x27;或者&#x27;\0&#x27;，返回错误 */</span></span><br><span class="line">    <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> c = *(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)name++;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;/&#x27;</span> || c == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果基础目录的标志位包含 DCACHE_OP_HASH，尝试使用底层文件系统的哈希函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (base-&gt;d_flags &amp; DCACHE_OP_HASH) &#123;</span><br><span class="line">        <span class="type">int</span> err = base-&gt;d_op-&gt;d_hash(base, this);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查权限 */</span></span><br><span class="line">    <span class="keyword">return</span> inode_permission(idmap, base-&gt;d_inode, MAY_EXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个函数 try_lookup_one_len，该函数用于在基础目录中查找并返回指定名称的目录项，如果该目录项不存在，则返回 NULL。</span></span><br><span class="line"><span class="comment">name: 需要查找的目录项名称；</span></span><br><span class="line"><span class="comment">base: 基础目录；</span></span><br><span class="line"><span class="comment">len: 名称的长度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">try_lookup_one_len</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查基础目录的 inode 是否被锁定，如果没有被锁定，发出警告 */</span></span><br><span class="line">    WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用 lookup_one_common 函数进行查找 */</span></span><br><span class="line">    err = lookup_one_common(&amp;nop_mnt_idmap, name, base, len, &amp;this);</span><br><span class="line">    <span class="comment">/* 如果查找过程中发生错误，返回一个包含错误码的指针 */</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在 dcache 中查找并返回目录项 */</span></span><br><span class="line">    <span class="keyword">return</span> lookup_dcache(&amp;this, base, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出 try_lookup_one_len 符号，使得其他模块可以使用这个函数 */</span></span><br><span class="line">EXPORT_SYMBOL(try_lookup_one_len);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个函数 lookup_one_len，该函数用于在基础目录中查找并返回指定名称的目录项。</span></span><br><span class="line"><span class="comment">如果在目录项缓存中找不到，则会调用__lookup_slow进行慢速查找。</span></span><br><span class="line"><span class="comment">name: 需要查找的目录项名称；</span></span><br><span class="line"><span class="comment">base: 基础目录；</span></span><br><span class="line"><span class="comment">len: 名称的长度。</span></span><br><span class="line"><span class="comment">注意：这个函数是文件系统的帮助函数，不应被通用代码调用。</span></span><br><span class="line"><span class="comment">调用者必须持有 base-&gt;i_mutex。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_one_len</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查基础目录的 inode 是否被锁定，如果没有被锁定，发出警告 */</span></span><br><span class="line">    WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用 lookup_one_common 函数进行查找 */</span></span><br><span class="line">    err = lookup_one_common(&amp;nop_mnt_idmap, name, base, len, &amp;this);</span><br><span class="line">    <span class="comment">/* 如果查找过程中发生错误，返回一个包含错误码的指针 */</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在 dcache 中查找并返回目录项，如果找不到，则进行慢速查找 */</span></span><br><span class="line">    dentry = lookup_dcache(&amp;this, base, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> dentry ? dentry : __lookup_slow(&amp;this, base, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出 lookup_one_len 符号，使得其他模块可以使用这个函数 */</span></span><br><span class="line">EXPORT_SYMBOL(lookup_one_len);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个函数 lookup_one，该函数用于在基础目录中查找并返回指定名称的目录项。</span></span><br><span class="line"><span class="comment">如果在目录项缓存中找不到，则会调用__lookup_slow进行慢速查找。</span></span><br><span class="line"><span class="comment">idmap: 用户和组的身份映射；</span></span><br><span class="line"><span class="comment">name: 需要查找的目录项名称；</span></span><br><span class="line"><span class="comment">base: 基础目录；</span></span><br><span class="line"><span class="comment">len: 名称的长度。</span></span><br><span class="line"><span class="comment">注意：这个函数是文件系统的帮助函数，不应被通用代码调用。</span></span><br><span class="line"><span class="comment">调用者必须持有 base-&gt;i_mutex。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_one</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 检查基础目录的 inode 是否被锁定，如果没有被锁定，发出警告 */</span></span><br><span class="line">    WARN_ON_ONCE(!inode_is_locked(base-&gt;d_inode));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用 lookup_one_common 函数进行查找 */</span></span><br><span class="line">    err = lookup_one_common(idmap, name, base, len, &amp;this);</span><br><span class="line">    <span class="comment">/* 如果查找过程中发生错误，返回一个包含错误码的指针 */</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在 dcache 中查找并返回目录项，如果找不到，则进行慢速查找 */</span></span><br><span class="line">    dentry = lookup_dcache(&amp;this, base, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> dentry ? dentry : __lookup_slow(&amp;this, base, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导出 lookup_one 符号，使得其他模块可以使用这个函数 */</span></span><br><span class="line">EXPORT_SYMBOL(lookup_one);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lookup_one_unlocked - 文件系统助手函数，用于查找单个路径名组件</span></span><br><span class="line"><span class="comment"> * @idmap:    执行查找的挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @name:    要查找的路径名组件</span></span><br><span class="line"><span class="comment"> * @base:    要从中查找的基础目录</span></span><br><span class="line"><span class="comment"> * @len:    应解释为最大长度@len</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与lookup_one_len不同，这个函数应在没有占用父目录i_mutex的情况下调用，</span></span><br><span class="line"><span class="comment"> * 并且如果需要，它会自己获取i_mutex。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_one_unlocked</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> dentry *base,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">ret</span>;</span> <span class="comment">//定义返回值</span></span><br><span class="line"></span><br><span class="line">    err = lookup_one_common(idmap, name, base, len, &amp;this); <span class="comment">//调用lookup_one_common函数查找</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err); <span class="comment">//如果出错，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    ret = lookup_dcache(&amp;this, base, <span class="number">0</span>); <span class="comment">//在目录缓存中查找</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        ret = lookup_slow(&amp;this, base, <span class="number">0</span>); <span class="comment">//如果在目录缓存中找不到，执行慢查询</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回查找结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(lookup_one_unlocked); <span class="comment">//导出符号，供其他模块调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lookup_one_positive_unlocked - 文件系统助手函数，用于查找单个路径名组件</span></span><br><span class="line"><span class="comment"> * @idmap:    执行查找的挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @name:    要查找的路径名组件</span></span><br><span class="line"><span class="comment"> * @base:    要从中查找的基础目录</span></span><br><span class="line"><span class="comment"> * @len:    应解释为最大长度@len</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果找到的是负向项，此助手函数将返回ERR_PTR(-ENOENT)。助手返回已知的正向项或ERR_PTR()。这是大多数用户想要的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，固定的负向项可以在任何时候变成正向项，所以调用lookup_one_unlocked()的函数需要非常小心；</span></span><br><span class="line"><span class="comment"> * 固定的正向项&gt;d_inode是稳定的，所以这个函数避免了这样的问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在调用这个助手函数时，不应该持有i_mutex。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_one_positive_unlocked</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">ret</span> =</span> lookup_one_unlocked(idmap, name, base, len); <span class="comment">//调用lookup_one_unlocked函数查找</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(ret) &amp;&amp; d_flags_negative(smp_load_acquire(&amp;ret-&gt;d_flags))) &#123; <span class="comment">//如果找到的是负向项</span></span><br><span class="line">        dput(ret); <span class="comment">//减少目录项的引用计数</span></span><br><span class="line">        ret = ERR_PTR(-ENOENT); <span class="comment">//返回文件未找到的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回查找结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(lookup_one_positive_unlocked); <span class="comment">//导出符号，供其他模块调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lookup_one_unlocked - 文件系统助手函数，用于查找单个路径名组件</span></span><br><span class="line"><span class="comment"> * @idmap:    执行查找的挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @name:    要查找的路径名组件</span></span><br><span class="line"><span class="comment"> * @base:    要从中查找的基础目录</span></span><br><span class="line"><span class="comment"> * @len:    应解释为最大长度@len</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与lookup_one_len不同，这个函数应在没有占用父目录i_mutex的情况下调用，</span></span><br><span class="line"><span class="comment"> * 并且如果需要，它会自己获取i_mutex。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_one_unlocked</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> dentry *base,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">ret</span>;</span> <span class="comment">//定义返回值</span></span><br><span class="line"></span><br><span class="line">    err = lookup_one_common(idmap, name, base, len, &amp;this); <span class="comment">//调用lookup_one_common函数查找</span></span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err); <span class="comment">//如果出错，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    ret = lookup_dcache(&amp;this, base, <span class="number">0</span>); <span class="comment">//在目录缓存中查找</span></span><br><span class="line">    <span class="keyword">if</span> (!ret)</span><br><span class="line">        ret = lookup_slow(&amp;this, base, <span class="number">0</span>); <span class="comment">//如果在目录缓存中找不到，执行慢查询</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回查找结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(lookup_one_unlocked); <span class="comment">//导出符号，供其他模块调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lookup_one_positive_unlocked - 文件系统助手函数，用于查找单个路径名组件</span></span><br><span class="line"><span class="comment"> * @idmap:    执行查找的挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @name:    要查找的路径名组件</span></span><br><span class="line"><span class="comment"> * @base:    要从中查找的基础目录</span></span><br><span class="line"><span class="comment"> * @len:    应解释为最大长度@len</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果找到的是负向项，此助手函数将返回ERR_PTR(-ENOENT)。助手返回已知的正向项或ERR_PTR()。这是大多数用户想要的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，固定的负向项可以在任何时候变成正向项，所以调用lookup_one_unlocked()的函数需要非常小心；</span></span><br><span class="line"><span class="comment"> * 固定的正向项&gt;d_inode是稳定的，所以这个函数避免了这样的问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在调用这个助手函数时，不应该持有i_mutex。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_one_positive_unlocked</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">ret</span> =</span> lookup_one_unlocked(idmap, name, base, len); <span class="comment">//调用lookup_one_unlocked函数查找</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(ret) &amp;&amp; d_flags_negative(smp_load_acquire(&amp;ret-&gt;d_flags))) &#123; <span class="comment">//如果找到的是负向项</span></span><br><span class="line">        dput(ret); <span class="comment">//减少目录项的引用计数</span></span><br><span class="line">        ret = ERR_PTR(-ENOENT); <span class="comment">//返回文件未找到的错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回查找结果</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(lookup_one_positive_unlocked); <span class="comment">//导出符号，供其他模块调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lookup_one_len_unlocked - 文件系统助手函数，用于查找单个路径名组件</span></span><br><span class="line"><span class="comment"> * @name:    要查找的路径名组件</span></span><br><span class="line"><span class="comment"> * @base:    要从中查找的基础目录</span></span><br><span class="line"><span class="comment"> * @len:    应解释为最大长度@len</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意，这个函数只是文件系统使用的助手，并不应由通用代码调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 与lookup_one_len不同，这个函数应在没有占用父目录i_mutex的情况下调用，</span></span><br><span class="line"><span class="comment"> * 并且如果需要，它会自己获取i_mutex。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_one_len_unlocked</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookup_one_unlocked(&amp;nop_mnt_idmap, name, base, len); <span class="comment">//调用lookup_one_unlocked函数查找</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(lookup_one_len_unlocked); <span class="comment">//导出符号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 与lookup_one_len_unlocked()类似，只是在否定的情况下返回ERR_PTR(-ENOENT)。</span></span><br><span class="line"><span class="comment"> * 返回已知的正数或ERR_PTR()；这是大多数用户想要的。注意，带有解锁父项的固定负数</span></span><br><span class="line"><span class="comment"> * 可以在任何时候变为正数，所以lookup_one_len_unlocked()的调用者需要非常小心；</span></span><br><span class="line"><span class="comment"> * 固定正数的-&gt;d_inode是稳定的，所以这个函数避免了这样的问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lookup_positive_unlocked</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                       <span class="keyword">struct</span> dentry *base, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行查找操作，返回目录项或错误指针。</span></span><br><span class="line">    <span class="keyword">return</span> lookup_one_positive_unlocked(&amp;nop_mnt_idmap, name, base, len);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(lookup_positive_unlocked);  <span class="comment">// 导出符号，使其他模块可以使用此函数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_UNIX98_PTYS</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">path_pts</span><span class="params">(<span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 在与输入路径相同的目录中找到挂载在&quot;pts&quot;上的东西。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">parent</span> =</span> dget_parent(path-&gt;dentry);  <span class="comment">// 获取父目录项。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span> =</span> QSTR_INIT(<span class="string">&quot;pts&quot;</span>, <span class="number">3</span>);  <span class="comment">// 初始化名为&quot;pts&quot;的qstr结构体。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!path_connected(path-&gt;mnt, parent))) &#123;  <span class="comment">// 如果路径未连接。</span></span><br><span class="line">        dput(parent);  <span class="comment">// 释放目录项。</span></span><br><span class="line">        <span class="keyword">return</span> -ENOENT;  <span class="comment">// 返回错误。</span></span><br><span class="line">    &#125;</span><br><span class="line">    dput(path-&gt;dentry);  <span class="comment">// 释放目录项。</span></span><br><span class="line">    path-&gt;dentry = parent;  <span class="comment">// 将父目录项赋给路径的dentry。</span></span><br><span class="line">    child = d_hash_and_lookup(parent, &amp;this);  <span class="comment">// 在父目录项中查找并返回子目录项。</span></span><br><span class="line">    <span class="keyword">if</span> (!child)  <span class="comment">// 如果找不到子目录项。</span></span><br><span class="line">        <span class="keyword">return</span> -ENOENT;  <span class="comment">// 返回错误。</span></span><br><span class="line"></span><br><span class="line">    path-&gt;dentry = child;  <span class="comment">// 将查找到的子目录项赋给路径的dentry。</span></span><br><span class="line">    dput(parent);  <span class="comment">// 释放父目录项。</span></span><br><span class="line">    follow_down(path, <span class="number">0</span>);  <span class="comment">// 跟踪路径。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">user_path_at_empty</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> path *path, <span class="type">int</span> *empty)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取用户空间的文件名。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">filename</span> =</span> getname_flags(name, flags, empty);</span><br><span class="line">    <span class="comment">// 查找文件名，并将结果存储在path中。</span></span><br><span class="line">    <span class="type">int</span> ret = filename_lookup(dfd, filename, flags, path, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放filename的内存。</span></span><br><span class="line">    putname(filename);</span><br><span class="line">    <span class="keyword">return</span> ret;  <span class="comment">// 返回结果。</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(user_path_at_empty);  <span class="comment">// 导出符号，使其他模块可以使用此函数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __check_sticky(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span><br><span class="line">           <span class="keyword">struct</span> inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前的文件系统用户ID。</span></span><br><span class="line">    <span class="type">kuid_t</span> fsuid = current_fsuid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查inode的用户ID是否与当前的文件系统用户ID相等。</span></span><br><span class="line">    <span class="keyword">if</span> (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, inode), fsuid))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查dir的用户ID是否与当前的文件系统用户ID相等。</span></span><br><span class="line">    <span class="keyword">if</span> (vfsuid_eq_kuid(i_uid_into_vfsuid(idmap, dir), fsuid))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查是否具有对inode进行操作的权限。</span></span><br><span class="line">    <span class="keyword">return</span> !capable_wrt_inode_uidgid(idmap, inode, CAP_FOWNER);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__check_sticky);  <span class="comment">// 导出符号，使其他模块可以使用此函数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查我们是否可以从目录dir删除链接victim，检查victim的类型是否正确。</span></span><br><span class="line"><span class="comment"> * 1. 如果dir是只读的，我们不能做这个（在permission()中已经完成）</span></span><br><span class="line"><span class="comment"> * 2. 我们应该对dir有写和执行权限</span></span><br><span class="line"><span class="comment"> * 3. 我们不能从只追加的dir中删除任何东西</span></span><br><span class="line"><span class="comment"> * 4. 我们不能对不可改变的dir做任何事情（在permission()中已经完成）</span></span><br><span class="line"><span class="comment"> * 5. 如果dir的粘滞位被设置，我们应该</span></span><br><span class="line"><span class="comment"> *  a. 是dir的所有者，或</span></span><br><span class="line"><span class="comment"> *  b. 是victim的所有者，或</span></span><br><span class="line"><span class="comment"> *  c. 有CAP_FOWNER能力</span></span><br><span class="line"><span class="comment"> * 6. 如果victim是只追加的或不可变的，我们不能做任何关于指向它的链接的事情</span></span><br><span class="line"><span class="comment"> * 7. 如果victim有未知的uid或gid，我们不能更改inode。</span></span><br><span class="line"><span class="comment"> * 8. 如果我们被要求删除一个目录，victim不是一个 - ENOTDIR。</span></span><br><span class="line"><span class="comment"> * 9. 如果我们被要求删除一个非目录，victim是一个 - EISDIR。</span></span><br><span class="line"><span class="comment"> * 10. 我们不能删除根目录或挂载点。</span></span><br><span class="line"><span class="comment"> * 11. 我们不允许删除NFS sillyrenamed文件；这是由nfs_async_unlink()处理的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">may_delete</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> dentry *victim, <span class="type">bool</span> isdir)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> d_backing_inode(victim);  <span class="comment">// 获取victim的inode。</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(victim))  <span class="comment">// 如果victim是负的。</span></span><br><span class="line">        <span class="keyword">return</span> -ENOENT;  <span class="comment">// 返回错误。</span></span><br><span class="line">    BUG_ON(!inode);  <span class="comment">// 如果inode不存在，报错。</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(victim-&gt;d_parent-&gt;d_inode != dir);  <span class="comment">// 如果victim的父inode不是dir，报错。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当uid或gid无效时，Inode回写不是安全的。</span></span><br><span class="line">    <span class="keyword">if</span> (!vfsuid_valid(i_uid_into_vfsuid(idmap, inode)) ||</span><br><span class="line">        !vfsgid_valid(i_gid_into_vfsgid(idmap, inode)))</span><br><span class="line">        <span class="keyword">return</span> -EOVERFLOW;  <span class="comment">// 返回错误。</span></span><br><span class="line"></span><br><span class="line">    audit_inode_child(dir, victim, AUDIT_TYPE_CHILD_DELETE);  <span class="comment">// 审计日志。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查对dir的权限。</span></span><br><span class="line">    error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);</span><br><span class="line">    <span class="keyword">if</span> (error)  <span class="comment">// 如果有错误。</span></span><br><span class="line">        <span class="keyword">return</span> error;  <span class="comment">// 返回错误。</span></span><br><span class="line">    <span class="keyword">if</span> (IS_APPEND(dir))  <span class="comment">// 如果dir是只追加的。</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;  <span class="comment">// 返回错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否满足删除的条件。</span></span><br><span class="line">    <span class="keyword">if</span> (check_sticky(idmap, dir, inode) || IS_APPEND(inode) ||</span><br><span class="line">        IS_IMMUTABLE(inode) || IS_SWAPFILE(inode) ||</span><br><span class="line">        HAS_UNMAPPED_ID(idmap, inode))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;  <span class="comment">// 返回错误。</span></span><br><span class="line">    <span class="keyword">if</span> (isdir) &#123;  <span class="comment">// 如果是目录。</span></span><br><span class="line">        <span class="keyword">if</span> (!d_is_dir(victim))  <span class="comment">// 如果victim不是目录。</span></span><br><span class="line">            <span class="keyword">return</span> -ENOTDIR;  <span class="comment">// 返回错误。</span></span><br><span class="line">        <span class="keyword">if</span> (IS_ROOT(victim))  <span class="comment">// 如果victim是根目录。</span></span><br><span class="line">            <span class="keyword">return</span> -EBUSY;  <span class="comment">// 返回错误。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d_is_dir(victim))  <span class="comment">// 如果victim是目录。</span></span><br><span class="line">        <span class="keyword">return</span> -EISDIR;  <span class="comment">// 返回错误。</span></span><br><span class="line">    <span class="keyword">if</span> (IS_DEADDIR(dir))  <span class="comment">// 如果dir是死目录。</span></span><br><span class="line">        <span class="keyword">return</span> -ENOENT;  <span class="comment">// 返回错误。</span></span><br><span class="line">    <span class="keyword">if</span> (victim-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED)  <span class="comment">// 如果victim是NFS重命名的文件。</span></span><br><span class="line">        <span class="keyword">return</span> -EBUSY;  <span class="comment">// 返回错误。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回成功。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检查我们是否可以在目录dir中创建一个带有dentry子项的对象。</span></span><br><span class="line"><span class="comment"> * 1. 如果child已经存在，我们不能做这个（open对这种情况有特殊处理，</span></span><br><span class="line"><span class="comment"> *    但因为我们是内联的，所以没关系）</span></span><br><span class="line"><span class="comment"> * 2. 如果dir是只读的，我们不能做这个（在permission()中已经完成）</span></span><br><span class="line"><span class="comment"> * 3. 如果文件系统不能表示fsuid或fsgid，我们不能做这个。</span></span><br><span class="line"><span class="comment"> * 4. 我们应该对dir有写和执行权限</span></span><br><span class="line"><span class="comment"> * 5. 如果dir是不可改变的我们不能做这个（在permission()中已经完成）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">may_create</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *child)</span></span><br><span class="line">&#123;</span><br><span class="line">    audit_inode_child(dir, child, AUDIT_TYPE_CHILD_CREATE);  <span class="comment">// 审计日志。</span></span><br><span class="line">    <span class="keyword">if</span> (child-&gt;d_inode)  <span class="comment">// 如果child已经存在。</span></span><br><span class="line">        <span class="keyword">return</span> -EEXIST;  <span class="comment">// 返回错误。</span></span><br><span class="line">    <span class="keyword">if</span> (IS_DEADDIR(dir))  <span class="comment">// 如果dir是死目录。</span></span><br><span class="line">        <span class="keyword">return</span> -ENOENT;  <span class="comment">// 返回错误。</span></span><br><span class="line">    <span class="keyword">if</span> (!fsuidgid_has_mapping(dir-&gt;i_sb, idmap))  <span class="comment">// 如果文件系统不能表示fsuid或fsgid。</span></span><br><span class="line">        <span class="keyword">return</span> -EOVERFLOW;  <span class="comment">// 返回错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查对dir的权限。</span></span><br><span class="line">    <span class="keyword">return</span> inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * p1和p2应当是同一文件系统上的目录。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">lock_rename</span><span class="params">(<span class="keyword">struct</span> dentry *p1, <span class="keyword">struct</span> dentry *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p1和p2是同一个目录，只需要锁定该目录即可。</span></span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">        inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对文件系统的重命名操作进行互斥锁保护，防止并发的重命名操作。</span></span><br><span class="line">    mutex_lock(&amp;p1-&gt;d_sb-&gt;s_vfs_rename_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p2是p1的祖先目录，先锁定p2，再锁定p1。</span></span><br><span class="line">    p = d_ancestor(p2, p1);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        inode_lock_nested(p2-&gt;d_inode, I_MUTEX_PARENT);</span><br><span class="line">        inode_lock_nested(p1-&gt;d_inode, I_MUTEX_CHILD);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p1是p2的祖先目录，先锁定p1，再锁定p2。</span></span><br><span class="line">    p = d_ancestor(p1, p2);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT);</span><br><span class="line">        inode_lock_nested(p2-&gt;d_inode, I_MUTEX_CHILD);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果p1和p2都不是对方的祖先目录，分别锁定p1和p2。</span></span><br><span class="line">    inode_lock_nested(p1-&gt;d_inode, I_MUTEX_PARENT);</span><br><span class="line">    inode_lock_nested(p2-&gt;d_inode, I_MUTEX_PARENT2);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(lock_rename);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解锁重命名操作的函数，与lock_rename配对使用。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock_rename</span><span class="params">(<span class="keyword">struct</span> dentry *p1, <span class="keyword">struct</span> dentry *p2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 解锁p1的inode</span></span><br><span class="line">    inode_unlock(p1-&gt;d_inode);</span><br><span class="line">    <span class="comment">// 如果p1和p2不是同一个目录，解锁p2的inode，并解锁重命名操作的互斥锁。</span></span><br><span class="line">    <span class="keyword">if</span> (p1 != p2) &#123;</span><br><span class="line">        inode_unlock(p2-&gt;d_inode);</span><br><span class="line">        mutex_unlock(&amp;p1-&gt;d_sb-&gt;s_vfs_rename_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(unlock_rename);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mode_strip_umask - 处理vfs中的umask剥离</span></span><br><span class="line"><span class="comment"> * @dir:    新inode的父目录</span></span><br><span class="line"><span class="comment"> * @mode:    在@dir中创建的新inode的模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Umask剥离依赖于文件系统是否支持POSIX ACLs。如果文件系统不支持，umask剥离直接在这里进行。</span></span><br><span class="line"><span class="comment"> * 如果文件系统支持POSIX ACLs，umask剥离会推迟到文件系统调用posix_acl_create()时进行。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回: mode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">umode_t</span> <span class="title function_">mode_strip_umask</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> inode *dir, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果目录不支持POSIX ACLs，直接将当前的umask与mode进行位与运算，获取剥离umask后的mode。</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_POSIXACL(dir))</span><br><span class="line">        mode &amp;= ~current_umask();</span><br><span class="line">    <span class="keyword">return</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- vfs_prepare_mode - 准备用于新索引节点的模式</span></span><br><span class="line"><span class="comment">- @idmap: 索引节点所属的挂载点的idmap</span></span><br><span class="line"><span class="comment">- @dir: 新索引节点的父目录</span></span><br><span class="line"><span class="comment">- @mode: 新索引节点的模式</span></span><br><span class="line"><span class="comment">- @mask_perms: vfs 允许的权限掩码</span></span><br><span class="line"><span class="comment">- @type: 要创建的文件类型</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 此辅助函数对将要创建的新对象的 @mode 进行了整合并强制执行 vfs 的限制。</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- Umask 的剥离取决于文件系统是否支持 POSIX ACL（参见内核文档中的 mode_strip_umask()）。</span></span><br><span class="line"><span class="comment">- 在 setgid 剥离之后进行 umask 剥离允许在非 POSIX ACL 和支持 POSIX ACL 的文件系统上采用相同的顺序。</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 需要注意的是，如果创建的是目录，则 @type 目前可以为0。文件系统单独引发该标志，</span></span><br><span class="line"><span class="comment">- 我们需要在强制执行非零类型之前检查每个文件系统是否可以接收来自 vfs 的 S_IFDIR。</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 返回：将传递给文件系统的模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">inline</span> <span class="type">umode_t</span> <span class="title function_">vfs_prepare_mode</span><span class="params">(<span class="keyword">struct</span> mnt_idmap idmap,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> inode dir, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">  <span class="type">umode_t</span> mask_perms, <span class="type">umode_t</span> type)</span></span><br><span class="line">  &#123;</span><br><span class="line">  mode = mode_strip_sgid(idmap, dir, mode);  <span class="comment">// 剥离 SGID 位</span></span><br><span class="line">  mode = mode_strip_umask(dir, mode);  <span class="comment">// 根据 umask 剥离权限位</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  - 在调用文件系统之前，应用 vfs 规定的允许的权限掩码，并设置要创建的文件类型。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    mode &amp;= (mask_perms &amp; ~S_IFMT);</span><br><span class="line">    mode |= (type &amp; S_IFMT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mode;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">vfs_create - 创建新文件</span></span><br><span class="line"><span class="comment">@idmap: 挂载点上找到的索引节点的idmap</span></span><br><span class="line"><span class="comment">@dir: @dentry的索引节点</span></span><br><span class="line"><span class="comment">@dentry: 基本目录的dentry指针</span></span><br><span class="line"><span class="comment">@mode: 新文件的模式</span></span><br><span class="line"><span class="comment">@want_excl: 文件是否必须不存在</span></span><br><span class="line"><span class="comment">创建一个新文件。</span></span><br><span class="line"><span class="comment">如果通过id映射的挂载点找到了索引节点，则必须通过@idmap传递vfsmount的idmap。</span></span><br><span class="line"><span class="comment">此函数将在检查权限之前根据@idmap映射索引节点。</span></span><br><span class="line"><span class="comment">如果是非id映射的挂载点，或者需要对原始索引节点执行权限检查，只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_create</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">bool</span> want_excl)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查创建文件的权限</span></span><br><span class="line">error = may_create(idmap, dir, dentry);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!dir-&gt;i_op-&gt;create)</span><br><span class="line"><span class="keyword">return</span> -EACCES; <span class="comment">/* 应该是ENOSYS吗？ */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备文件的模式</span></span><br><span class="line">mode = vfs_prepare_mode(idmap, dir, mode, S_IALLUGO, S_IFREG);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用安全模块的inode_create函数进行安全检查</span></span><br><span class="line">error = security_inode_create(dir, dentry, mode);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用inode操作的create函数创建新文件</span></span><br><span class="line">error = dir-&gt;i_op-&gt;create(idmap, dir, dentry, mode, want_excl);</span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line">fsnotify_create(dir, dentry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_create);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vfs_mkobj - 创建新对象</span></span><br><span class="line"><span class="comment">@dentry: dentry指针</span></span><br><span class="line"><span class="comment">@mode: 新对象的模式</span></span><br><span class="line"><span class="comment">@f: 回调函数指针，用于创建新对象</span></span><br><span class="line"><span class="comment">@arg: 回调函数的参数</span></span><br><span class="line"><span class="comment">创建一个新对象。</span></span><br><span class="line"><span class="comment">检查权限并调用回调函数创建新对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mkobj</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="type">int</span> (*f)(<span class="keyword">struct</span> dentry *, <span class="type">umode_t</span>, <span class="type">void</span> *),</span></span><br><span class="line"><span class="params"><span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> dentry-&gt;d_parent-&gt;d_inode;</span><br><span class="line"><span class="type">int</span> error = may_create(&amp;nop_mnt_idmap, dir, dentry);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">mode &amp;= S_IALLUGO;</span><br><span class="line">mode |= S_IFREG;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用安全模块的inode_create函数进行安全检查</span></span><br><span class="line">error = security_inode_create(dir, dentry, mode);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用回调函数创建新对象</span></span><br><span class="line">error = f(dentry, mode, arg);</span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line">fsnotify_create(dir, dentry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_mkobj);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">may_open_dev - 检查是否可以打开设备文件</span></span><br><span class="line"><span class="comment">@path: 文件路径</span></span><br><span class="line"><span class="comment">检查路径是否允许打开设备文件。</span></span><br><span class="line"><span class="comment">返回值为true表示可以打开，否则为false。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">may_open_dev</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> !(path-&gt;mnt-&gt;mnt_flags &amp; MNT_NODEV) &amp;&amp;</span><br><span class="line">!(path-&gt;mnt-&gt;mnt_sb-&gt;s_iflags &amp; SB_I_NODEV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">may_open</span><span class="params">(<span class="keyword">struct</span> mnt_idmap \*idmap, <span class="type">const</span> <span class="keyword">struct</span> path \*path,</span></span><br><span class="line"><span class="params"><span class="type">int</span> acc_mode, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> \*<span class="title">dentry</span> =</span> path-&gt;dentry;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> \*<span class="title">inode</span> =</span> dentry-&gt;d_inode;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"> <span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查索引节点的类型</span></span><br><span class="line"><span class="keyword">switch</span> (inode-&gt;i_mode &amp; S_IFMT) &#123;</span><br><span class="line"><span class="keyword">case</span> S_IFLNK:</span><br><span class="line"> <span class="keyword">return</span> -ELOOP; <span class="comment">// 符号链接文件无法打开</span></span><br><span class="line"><span class="keyword">case</span> S_IFDIR:</span><br><span class="line"> <span class="keyword">if</span> (acc_mode &amp; MAY_WRITE)</span><br><span class="line"> <span class="keyword">return</span> -EISDIR; <span class="comment">// 目录不可写</span></span><br><span class="line"> <span class="keyword">if</span> (acc_mode &amp; MAY_EXEC)</span><br><span class="line"> <span class="keyword">return</span> -EACCES; <span class="comment">// 目录不可执行</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> S_IFBLK:</span><br><span class="line"><span class="keyword">case</span> S_IFCHR:</span><br><span class="line"> <span class="keyword">if</span> (!may_open_dev(path))</span><br><span class="line"> <span class="keyword">return</span> -EACCES; <span class="comment">// 无权限打开设备文件</span></span><br><span class="line"> fallthrough;</span><br><span class="line"><span class="keyword">case</span> S_IFIFO:</span><br><span class="line"><span class="keyword">case</span> S_IFSOCK:</span><br><span class="line"> <span class="keyword">if</span> (acc_mode &amp; MAY_EXEC)</span><br><span class="line"> <span class="keyword">return</span> -EACCES; <span class="comment">// 文件不可执行</span></span><br><span class="line"> flag &amp;= ~O_TRUNC; <span class="comment">// 清除 O_TRUNC 标志位</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> S_IFREG:</span><br><span class="line"> <span class="keyword">if</span> ((acc_mode &amp; MAY_EXEC) &amp;&amp; path_noexec(path))</span><br><span class="line"> <span class="keyword">return</span> -EACCES; <span class="comment">// 文件不可执行</span></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查索引节点的权限</span></span><br><span class="line">error = inode_permission(idmap, inode, MAY_OPEN | acc_mode);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"> <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- An append-only file must be opened in append mode for writing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 附加模式只能用于写入附加模式的文件。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (IS_APPEND(inode)) &#123;</span><br><span class="line">   <span class="keyword">if</span> ((flag &amp; O_ACCMODE) != O_RDONLY &amp;&amp; !(flag &amp; O_APPEND))</span><br><span class="line">  <span class="keyword">return</span> -EPERM;  <span class="comment">// 无权限打开附加模式的文件  </span></span><br><span class="line">  <span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">  <span class="keyword">return</span> -EPERM;  <span class="comment">// 无权限截断文件</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* O_NOATIME can only be set by the owner or superuser */</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; O_NOATIME &amp;&amp; !inode_owner_or_capable(idmap, inode))</span><br><span class="line"> <span class="keyword">return</span> -EPERM; <span class="comment">// 无权限设置 O_NOATIME 标志位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_truncate</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取文件路径</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">path</span> *<span class="title">path</span> =</span> &amp;filp-&gt;f_path;</span><br><span class="line">    <span class="comment">// 获取索引节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> path-&gt;dentry-&gt;d_inode;</span><br><span class="line">    <span class="comment">// 获取写入访问权限</span></span><br><span class="line">    <span class="type">int</span> error = get_write_access(inode);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用安全模块的文件截断函数进行安全检查</span></span><br><span class="line">    error = security_file_truncate(filp);</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="comment">// 执行截断操作</span></span><br><span class="line">        error = do_truncate(idmap, path-&gt;dentry, <span class="number">0</span>,</span><br><span class="line">                            ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,</span><br><span class="line">                            filp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放写入访问权限</span></span><br><span class="line">    put_write_access(inode);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">open_to_namei_flags</span><span class="params">(<span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 O_ACCMODE 为 3 的情况转换为 2</span></span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; O_ACCMODE) == <span class="number">3</span>)</span><br><span class="line">        flag--;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">may_o_create</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> path *dir, <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params">                        <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用安全模块的路径创建节点函数进行安全检查</span></span><br><span class="line">    <span class="type">int</span> error = security_path_mknod(dir, dentry, mode, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查目录所在的超级块是否具有用户和组ID的映射</span></span><br><span class="line">    <span class="keyword">if</span> (!fsuidgid_has_mapping(dir-&gt;dentry-&gt;d_sb, idmap))</span><br><span class="line">        <span class="keyword">return</span> -EOVERFLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查目录索引节点的权限</span></span><br><span class="line">    error = inode_permission(idmap, dir-&gt;dentry-&gt;d_inode,</span><br><span class="line">                             MAY_WRITE | MAY_EXEC);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用安全模块的索引节点创建函数进行安全检查</span></span><br><span class="line">    <span class="keyword">return</span> security_inode_create(dir-&gt;dentry-&gt;d_inode, dentry, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 尝试原子性地查找、创建并打开一个负的dentry（目录项）对应的文件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果成功，返回0。文件将被创建并通过文件系统的finish_open()函数附加到@file上。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果只查找了文件或者不需要创建文件，FMODE_OPENED标志位将不会被设置。</span></span><br><span class="line"><span class="comment"> * 调用者需要自行执行打开操作。@path将会更新为指向新的dentry，可能是负值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则返回错误代码。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">atomic_open</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> dentry *dentry,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">                                  <span class="type">int</span> open_flag, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">const</span> <span class="title">DENTRY_NOT_SET</span> =</span> (<span class="type">void</span> *) <span class="number">-1UL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> nd-&gt;path.dentry-&gt;d_inode;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果标志位中包含LOOKUP_DIRECTORY，则将open_flag中的O_DIRECTORY标志位置位</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_DIRECTORY)</span><br><span class="line">        open_flag |= O_DIRECTORY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件的路径信息为DENTRY_NOT_SET</span></span><br><span class="line">    file-&gt;f_path.dentry = DENTRY_NOT_SET;</span><br><span class="line">    file-&gt;f_path.mnt = nd-&gt;path.mnt;</span><br><span class="line">    <span class="comment">// 调用目录索引节点的原子打开函数进行操作</span></span><br><span class="line">    error = dir-&gt;i_op-&gt;<span class="type">atomic_open</span>(dir, dentry, file,</span><br><span class="line">                                   open_to_namei_flags(open_flag), mode);</span><br><span class="line">    d_lookup_done(dentry);</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_OPENED) &#123;</span><br><span class="line">            <span class="comment">// 如果文件已经打开且dentry与file中的路径不一致，则释放旧的dentry并获取新的dentry</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(dentry != file-&gt;f_path.dentry)) &#123;</span><br><span class="line">                dput(dentry);</span><br><span class="line">                dentry = dget(file-&gt;f_path.dentry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (WARN_ON(file-&gt;f_path.dentry == DENTRY_NOT_SET)) &#123;</span><br><span class="line">            error = -EIO;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果文件未打开且dentry已经设置，则释放旧的dentry并获取新的dentry</span></span><br><span class="line">            <span class="keyword">if</span> (file-&gt;f_path.dentry) &#123;</span><br><span class="line">                dput(dentry);</span><br><span class="line">                dentry = file-&gt;f_path.dentry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果新的dentry是负值，则表示文件不存在</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(d_is_negative(dentry)))</span><br><span class="line">                error = -ENOENT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 如果出现错误，则释放dentry并返回错误指针</span></span><br><span class="line">        dput(dentry);</span><br><span class="line">        dentry = ERR_PTR(error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 查找并可能创建并打开最后一个组件。</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 必须在父目录被锁定的情况下调用（在O_CREAT情况下是互斥的）。</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 成功时返回0，即如果文件成功地原子性地创建（如有必要）并打开，或者</span></span><br><span class="line"><span class="comment">- 文件此时尚未完全打开，尽管进行了查找和创建。</span></span><br><span class="line"><span class="comment">- 这些情况通过file-&gt;f_mode上存在FMODE_OPENED来区分。</span></span><br><span class="line"><span class="comment">- 在后一种情况下，如果没有指定O_CREAT，则@path中的dentry可能为负。</span></span><br><span class="line"><span class="comment">-</span></span><br><span class="line"><span class="comment">- 失败时返回错误代码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">struct</span> dentry <span class="title function_">lookup_open</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> open_flags *op,</span></span><br><span class="line"><span class="params">  <span class="type">bool</span> got_write)</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dir</span> =</span> nd-&gt;path.dentry; <span class="comment">// 获取目录的dentry</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir_inode</span> =</span> dir-&gt;d_inode; <span class="comment">// 获取目录的inode</span></span><br><span class="line">  <span class="type">int</span> open_flag = op-&gt;open_flag; <span class="comment">// 获取打开标志</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">  <span class="type">int</span> error, create_error = <span class="number">0</span>;</span><br><span class="line">  <span class="type">umode_t</span> mode = op-&gt;mode; <span class="comment">// 获取模式</span></span><br><span class="line">  DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); <span class="comment">// 声明并初始化等待队列头</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(IS_DEADDIR(dir_inode))) <span class="comment">// 如果目录的inode已经无效</span></span><br><span class="line">  <span class="keyword">return</span> ERR_PTR(-ENOENT);</span><br><span class="line"></span><br><span class="line">  file-&gt;f_mode &amp;= ~FMODE_CREATED; <span class="comment">// 清除FMODE_CREATED标志</span></span><br><span class="line">  dentry = d_lookup(dir, &amp;nd-&gt;last); <span class="comment">// 在目录中查找最后一个组件的dentry</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!dentry) &#123;</span><br><span class="line">  dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq); <span class="comment">// 并行分配dentry</span></span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">  <span class="keyword">return</span> dentry;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (d_in_lookup(dentry)) <span class="comment">// 如果dentry处于查找状态</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">   error = d_revalidate(dentry, nd-&gt;flags); <span class="comment">// 重新验证dentry</span></span><br><span class="line">   <span class="keyword">if</span> (likely(error &gt; <span class="number">0</span>)) <span class="comment">// 如果验证成功</span></span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">if</span> (error) <span class="comment">// 如果出现错误</span></span><br><span class="line">       <span class="keyword">goto</span> out_dput;</span><br><span class="line">   d_invalidate(dentry); <span class="comment">// 使dentry无效</span></span><br><span class="line">   dput(dentry);</span><br><span class="line">   dentry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (dentry-&gt;d_inode) &#123;</span><br><span class="line">  <span class="comment">/* 缓存的正向dentry：将在f_op-&gt;open中打开 */</span></span><br><span class="line">  <span class="keyword">return</span> dentry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  - 检查写权限是棘手的，因为我们不知道是否实际需要它：只要文件存在，O_CREAT打开就可以工作。</span></span><br><span class="line"><span class="comment">  - 但是检查存在会破坏原子性。技巧是检查访问权限，如果未授予，则从标志中清除O_CREAT。</span></span><br><span class="line"><span class="comment">  -</span></span><br><span class="line"><span class="comment">  - 另一个问题是返回“正确”的错误值（例如，对于O_EXCL打开，我们希望返回EEXIST而不是EROFS）。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!got_write))</span><br><span class="line">    open_flag &amp;= ~O_TRUNC;</span><br><span class="line">    idmap = mnt_idmap(nd-&gt;path.mnt);</span><br><span class="line">    <span class="keyword">if</span> (open_flag &amp; O_CREAT) &#123;</span><br><span class="line">    <span class="keyword">if</span> (open_flag &amp; O_EXCL)</span><br><span class="line">    open_flag &amp;= ~O_TRUNC;</span><br><span class="line">    mode = vfs_prepare_mode(idmap, dir-&gt;d_inode, mode, mode, mode); <span class="comment">// 准备模式</span></span><br><span class="line">    <span class="keyword">if</span> (likely(got_write))</span><br><span class="line">    create_error = may_o_create(idmap, &amp;nd-&gt;path,</span><br><span class="line">    dentry, mode); <span class="comment">// 检查是否可以创建文件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    create_error = -EROFS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (create_error)</span><br><span class="line">    open_flag &amp;= ~O_CREAT;</span><br><span class="line">    <span class="keyword">if</span> (dir_inode-&gt;i_op-&gt;<span class="type">atomic_open</span>) &#123;</span><br><span class="line">    dentry = <span class="type">atomic_open</span>(nd, dentry, file, open_flag, mode); <span class="comment">// 原子打开操作</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(create_error) &amp;&amp; dentry == ERR_PTR(-ENOENT))</span><br><span class="line">    dentry = ERR_PTR(create_error);</span><br><span class="line">    <span class="keyword">return</span> dentry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (d_in_lookup(dentry)) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span> =</span> dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry,</span><br><span class="line">  nd-&gt;flags); <span class="comment">// 在目录inode上执行lookup操作</span></span><br><span class="line">  d_lookup_done(dentry);</span><br><span class="line">  <span class="keyword">if</span> (unlikely(res)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (IS_ERR(res)) &#123;</span><br><span class="line">  error = PTR_ERR(res);</span><br><span class="line">  <span class="keyword">goto</span> out_dput;</span><br><span class="line">  &#125;</span><br><span class="line">  dput(dentry);</span><br><span class="line">  dentry = res;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 负向dentry，只需创建文件 */</span></span><br><span class="line">  <span class="keyword">if</span> (!dentry-&gt;d_inode &amp;&amp; (open_flag &amp; O_CREAT)) &#123;</span><br><span class="line">  file-&gt;f_mode |= FMODE_CREATED; <span class="comment">// 设置FMODE_CREATED标志</span></span><br><span class="line">  audit_inode_child(dir_inode, dentry, AUDIT_TYPE_CHILD_CREATE); <span class="comment">// 对子节点进行审计</span></span><br><span class="line">  <span class="keyword">if</span> (!dir_inode-&gt;i_op-&gt;create) &#123;</span><br><span class="line">  error = -EACCES;</span><br><span class="line">  <span class="keyword">goto</span> out_dput;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   error = dir_inode-&gt;i_op-&gt;create(idmap, dir_inode, dentry,</span><br><span class="line">                   mode, open_flag &amp; O_EXCL); <span class="comment">// 创建文件</span></span><br><span class="line">   <span class="keyword">if</span> (error)</span><br><span class="line">       <span class="keyword">goto</span> out_dput;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unlikely(create_error) &amp;&amp; !dentry-&gt;d_inode) &#123;</span><br><span class="line">  error = create_error;</span><br><span class="line">  <span class="keyword">goto</span> out_dput;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dentry;</span><br><span class="line"></span><br><span class="line">out_dput:</span><br><span class="line">dput(dentry);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于打开最后一个组件的查找过程以及相关操作的函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">open_last_lookups</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dir</span> =</span> nd-&gt;path.dentry; <span class="comment">// 获取目录的dentry</span></span><br><span class="line"><span class="type">int</span> open_flag = op-&gt;open_flag; <span class="comment">// 获取打开标志</span></span><br><span class="line"><span class="type">bool</span> got_write = <span class="literal">false</span>; <span class="comment">// 标记是否获取了写权限</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 用于存储查找到的dentry</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *res; <span class="comment">// 用于返回结果的指针</span></span><br><span class="line"></span><br><span class="line">nd-&gt;flags |= op-&gt;intent; <span class="comment">// 设置nd的标志位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nd-&gt;last_type != LAST_NORM) &#123; <span class="comment">// 如果最后一个组件不是普通组件（如.或..）</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;depth)</span><br><span class="line">        put_link(nd); <span class="comment">// 清理链接</span></span><br><span class="line">    <span class="keyword">return</span> handle_dots(nd, nd-&gt;last_type); <span class="comment">// 处理.和..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(open_flag &amp; O_CREAT)) &#123; <span class="comment">// 如果不是创建文件的操作</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;last.name[nd-&gt;last.len]) <span class="comment">// 如果最后一个组件后面还有字符（可能是斜杠）</span></span><br><span class="line">        nd-&gt;flags |= LOOKUP_FOLLOW | LOOKUP_DIRECTORY; <span class="comment">// 设置标志位</span></span><br><span class="line">    <span class="comment">/* 我们可以在这里处于RCU模式 */</span></span><br><span class="line">    dentry = lookup_fast(nd); <span class="comment">// 快速查找dentry</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(dentry); <span class="comment">// 返回错误指针</span></span><br><span class="line">    <span class="keyword">if</span> (likely(dentry))</span><br><span class="line">        <span class="keyword">goto</span> finish_lookup; <span class="comment">// 跳转到查找完成的部分</span></span><br><span class="line"></span><br><span class="line">    BUG_ON(nd-&gt;flags &amp; LOOKUP_RCU); <span class="comment">// 如果标志位有LOOKUP_RCU标志，触发BUG</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 创建文件的操作 */</span></span><br><span class="line">    <span class="keyword">if</span> (nd-&gt;flags &amp; LOOKUP_RCU) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!try_to_unlazy(nd))</span><br><span class="line">            <span class="keyword">return</span> ERR_PTR(-ECHILD); <span class="comment">// 返回错误指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    audit_inode(nd-&gt;name, dir, AUDIT_INODE_PARENT); <span class="comment">// 对父节点进行审计</span></span><br><span class="line">    <span class="comment">/* 是否存在尾部斜杠？ */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(nd-&gt;last.name[nd-&gt;last.len]))</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EISDIR); <span class="comment">// 返回错误指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (open_flag &amp; (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR)) &#123;</span><br><span class="line">    got_write = !mnt_want_write(nd-&gt;path.mnt); <span class="comment">// 获取写权限</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 暂时不要失败 - 我们可能不需要它，或者以不同的错误失败；</span></span><br><span class="line"><span class="comment">     * 让lookup_open()决定；我们将很快丢弃这一个。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (open_flag &amp; O_CREAT)</span><br><span class="line">    inode_lock(dir-&gt;d_inode); <span class="comment">// 锁定目录的inode</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    inode_lock_shared(dir-&gt;d_inode); <span class="comment">// 共享锁定目录的inode</span></span><br><span class="line">dentry = lookup_open(nd, file, op, got_write); <span class="comment">// 执行查找和创建操作</span></span><br><span class="line"><span class="keyword">if</span> (!IS_ERR(dentry) &amp;&amp; (file-&gt;f_mode &amp; FMODE_CREATED))</span><br><span class="line">    fsnotify_create(dir-&gt;d_inode, dentry); <span class="comment">// 发送文件创建事件通知</span></span><br><span class="line"><span class="keyword">if</span> (open_flag &amp; O_CREAT)</span><br><span class="line">    inode_unlock(dir-&gt;d_inode); <span class="comment">// 解锁目录的inode</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    inode_unlock_shared(dir-&gt;d_inode); <span class="comment">// 解锁目录的inode</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (got_write)</span><br><span class="line">    mnt_drop_write(nd-&gt;path.mnt); <span class="comment">// 释放写权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">    <span class="keyword">return</span> ERR_CAST(dentry); <span class="comment">// 返回错误指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED)) &#123;</span><br><span class="line">    dput(nd-&gt;path.dentry);</span><br><span class="line">    nd-&gt;path.dentry = dentry; <span class="comment">// 更新nd的dentry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">finish_lookup:</span><br><span class="line"><span class="keyword">if</span> (nd-&gt;depth)</span><br><span class="line">put_link(nd); <span class="comment">// 清理链接</span></span><br><span class="line">res = step_into(nd, WALK_TRAILING, dentry); <span class="comment">// 进入下一步查找</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(res))</span><br><span class="line">nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);</span><br><span class="line"><span class="keyword">return</span> res; <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 处理open()的最后一步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_open</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span> <span class="comment">// ID映射结构体指针</span></span><br><span class="line">    <span class="type">int</span> open_flag = op-&gt;open_flag; <span class="comment">// 打开标志</span></span><br><span class="line">    <span class="type">bool</span> do_truncate; <span class="comment">// 是否进行截断操作</span></span><br><span class="line">    <span class="type">int</span> acc_mode; <span class="comment">// 访问模式</span></span><br><span class="line">    <span class="type">int</span> error; <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; (FMODE_OPENED | FMODE_CREATED))) &#123;</span><br><span class="line">    error = complete_walk(nd); <span class="comment">// 完成路径的遍历</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(file-&gt;f_mode &amp; FMODE_CREATED))</span><br><span class="line">    audit_inode(nd-&gt;name, nd-&gt;path.dentry, <span class="number">0</span>); <span class="comment">// 对目录进行审计</span></span><br><span class="line">idmap = mnt_idmap(nd-&gt;path.mnt); <span class="comment">// 获取ID映射结构体指针</span></span><br><span class="line"><span class="keyword">if</span> (open_flag &amp; O_CREAT) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((open_flag &amp; O_EXCL) &amp;&amp; !(file-&gt;f_mode &amp; FMODE_CREATED))</span><br><span class="line">        <span class="keyword">return</span> -EEXIST; <span class="comment">// 如果O_EXCL标志被设置，并且文件未被创建，返回文件已存在的错误</span></span><br><span class="line">    <span class="keyword">if</span> (d_is_dir(nd-&gt;path.dentry))</span><br><span class="line">        <span class="keyword">return</span> -EISDIR; <span class="comment">// 如果是目录，返回是目录的错误</span></span><br><span class="line">    error = may_create_in_sticky(idmap, nd,</span><br><span class="line">                     d_backing_inode(nd-&gt;path.dentry)); <span class="comment">// 检查是否可以在粘滞位目录中创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((nd-&gt;flags &amp; LOOKUP_DIRECTORY) &amp;&amp; !d_can_lookup(nd-&gt;path.dentry))</span><br><span class="line">    <span class="keyword">return</span> -ENOTDIR; <span class="comment">// 如果标志位有LOOKUP_DIRECTORY标志，并且无法进行查找，返回不是目录的错误</span></span><br><span class="line"></span><br><span class="line">do_truncate = <span class="literal">false</span>; <span class="comment">// 初始化截断标志</span></span><br><span class="line">acc_mode = op-&gt;acc_mode; <span class="comment">// 获取访问模式</span></span><br><span class="line"><span class="keyword">if</span> (file-&gt;f_mode &amp; FMODE_CREATED) &#123;</span><br><span class="line">    <span class="comment">/* 不检查写权限，不进行截断 */</span></span><br><span class="line">    open_flag &amp;= ~O_TRUNC; <span class="comment">// 清除O_TRUNC标志</span></span><br><span class="line">    acc_mode = <span class="number">0</span>; <span class="comment">// 设置访问模式为0</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (d_is_reg(nd-&gt;path.dentry) &amp;&amp; open_flag &amp; O_TRUNC) &#123;</span><br><span class="line">    error = mnt_want_write(nd-&gt;path.mnt); <span class="comment">// 获取写权限</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    do_truncate = <span class="literal">true</span>; <span class="comment">// 设置截断标志为true</span></span><br><span class="line">&#125;</span><br><span class="line">error = may_open(idmap, &amp;nd-&gt;path, acc_mode, open_flag); <span class="comment">// 检查是否可以打开文件</span></span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; !(file-&gt;f_mode &amp; FMODE_OPENED))</span><br><span class="line">    error = vfs_open(&amp;nd-&gt;path, file); <span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line">    error = ima_file_check(file, op-&gt;acc_mode); <span class="comment">// 检查文件的完整性和安全性</span></span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; do_truncate)</span><br><span class="line">    error = handle_truncate(idmap, file); <span class="comment">// 处理截断操作</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(error &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    WARN_ON(<span class="number">1</span>);</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (do_truncate)</span><br><span class="line">    mnt_drop_write(nd-&gt;path.mnt); <span class="comment">// 释放写权限</span></span><br><span class="line"><span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_tmpfile - 创建临时文件</span></span><br><span class="line"><span class="comment"> * @idmap: 挂载点的ID映射</span></span><br><span class="line"><span class="comment"> * @dentry: 基础目录的dentry指针</span></span><br><span class="line"><span class="comment"> * @mode: 新临时文件的模式</span></span><br><span class="line"><span class="comment"> * @open_flag: 标志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建一个临时文件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过ID映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的ID映射。</span></span><br><span class="line"><span class="comment"> * 此函数将根据@idmap映射inode，然后检查权限。</span></span><br><span class="line"><span class="comment"> * 在非ID映射的挂载点上，或者如果要对原始inode执行权限检查，则只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">vfs_tmpfile</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> path *parentpath,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> file *file, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">child</span>;</span> <span class="comment">// 子目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span> =</span> d_inode(parentpath-&gt;dentry); <span class="comment">// 父目录的inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">int</span> open_flag = file-&gt;f_flags; <span class="comment">// 文件标志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 我们希望目录可写 */</span></span><br><span class="line">    error = inode_permission(idmap, dir, MAY_WRITE | MAY_EXEC); <span class="comment">// 检查目录的写和执行权限</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;tmpfile)</span><br><span class="line">        <span class="keyword">return</span> -EOPNOTSUPP; <span class="comment">// 如果目录不支持tmpfile操作，则返回不支持的错误</span></span><br><span class="line">    child = d_alloc(parentpath-&gt;dentry, &amp;slash_name); <span class="comment">// 分配子目录项</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!child))</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM; <span class="comment">// 如果分配失败，则返回内存不足的错误</span></span><br><span class="line">    file-&gt;f_path.mnt = parentpath-&gt;mnt;</span><br><span class="line">    file-&gt;f_path.dentry = child; <span class="comment">// 设置文件的挂载点和目录项</span></span><br><span class="line">    mode = vfs_prepare_mode(idmap, dir, mode, mode, mode); <span class="comment">// 准备文件的模式</span></span><br><span class="line">    error = dir-&gt;i_op-&gt;tmpfile(idmap, dir, file, mode); <span class="comment">// 调用目录的tmpfile操作</span></span><br><span class="line">    dput(child);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error; <span class="comment">// 如果出错，则返回错误码</span></span><br><span class="line">    <span class="comment">/* 不检查其他权限，因为刚刚创建了inode */</span></span><br><span class="line">    error = may_open(idmap, &amp;file-&gt;f_path, <span class="number">0</span>, file-&gt;f_flags); <span class="comment">// 检查是否可以打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error; <span class="comment">// 如果出错，则返回错误码</span></span><br><span class="line">    inode = file_inode(file);</span><br><span class="line">    <span class="keyword">if</span> (!(open_flag &amp; O_EXCL)) &#123;</span><br><span class="line">        spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">        inode-&gt;i_state |= I_LINKABLE; <span class="comment">// 设置inode的状态为可链接</span></span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    ima_post_create_tmpfile(idmap, inode); <span class="comment">// 进行临时文件的完整性和安全性检查</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_tmpfile_open - 为内核内部使用打开一个临时文件</span></span><br><span class="line"><span class="comment"> * @idmap: 通过该挂载点找到的inode的idmap</span></span><br><span class="line"><span class="comment"> * @parentpath: 基本目录的路径</span></span><br><span class="line"><span class="comment"> * @mode: 新临时文件的模式</span></span><br><span class="line"><span class="comment"> * @open_flag: 标志</span></span><br><span class="line"><span class="comment"> * @cred: 打开的凭证</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建并打开一个临时文件。该文件不会计入nr_files中，因此只适用于内核内部使用，</span></span><br><span class="line"><span class="comment"> * 不得安装到文件表或其他地方。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> file *<span class="title function_">vfs_tmpfile_open</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">              <span class="type">const</span> <span class="keyword">struct</span> path *parentpath,</span></span><br><span class="line"><span class="params">              <span class="type">umode_t</span> mode, <span class="type">int</span> open_flag, <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="type">int</span> error; <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line">    file = alloc_empty_file_noaccount(open_flag, cred); <span class="comment">// 分配一个空的文件结构（不计入文件计数）</span></span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(file)) &#123;</span><br><span class="line">        error = vfs_tmpfile(idmap, parentpath, file, mode); <span class="comment">// 创建临时文件</span></span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            fput(file); <span class="comment">// 如果出错，释放文件</span></span><br><span class="line">            file = ERR_PTR(error); <span class="comment">// 返回错误指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> file; <span class="comment">// 返回文件指针</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_tmpfile_open); <span class="comment">// 导出符号供其他模块使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_tmpfile</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> open_flags *op,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 路径结构</span></span><br><span class="line">    <span class="type">int</span> error = path_lookupat(nd, flags | LOOKUP_DIRECTORY, &amp;path); <span class="comment">// 查找目录路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">        <span class="keyword">return</span> error; <span class="comment">// 如果查找失败，返回错误码</span></span><br><span class="line">    error = mnt_want_write(path.mnt); <span class="comment">// 增加挂载点的写引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(error))</span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">// 如果增加失败，跳转到出错处理</span></span><br><span class="line">    error = vfs_tmpfile(mnt_idmap(path.mnt), &amp;path, file, op-&gt;mode); <span class="comment">// 创建临时文件</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out2; <span class="comment">// 如果创建失败，跳转到出错处理</span></span><br><span class="line">    audit_inode(nd-&gt;name, file-&gt;f_path.dentry, <span class="number">0</span>); <span class="comment">// 审计新创建的临时文件</span></span><br><span class="line">out2:</span><br><span class="line">    mnt_drop_write(path.mnt); <span class="comment">// 减少挂载点的写引用计数</span></span><br><span class="line">out:</span><br><span class="line">    path_put(&amp;path); <span class="comment">// 释放路径结构</span></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_o_path</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="type">unsigned</span> flags, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 路径结构</span></span><br><span class="line">    <span class="type">int</span> error = path_lookupat(nd, flags, &amp;path); <span class="comment">// 查找路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        audit_inode(nd-&gt;name, path.dentry, <span class="number">0</span>); <span class="comment">// 审计找到的目录项</span></span><br><span class="line">        error = vfs_open(&amp;path, file); <span class="comment">// 打开文件</span></span><br><span class="line">        path_put(&amp;path); <span class="comment">// 释放路径结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file *<span class="title function_">path_openat</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> open_flags *op, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    file = alloc_empty_file(op-&gt;open_flag, current_cred()); <span class="comment">// 分配一个空的文件结构</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">        <span class="keyword">return</span> file; <span class="comment">// 如果分配失败，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) &#123;</span><br><span class="line">        error = do_tmpfile(nd, flags, op, file); <span class="comment">// 如果是临时文件，调用临时文件处理函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (unlikely(file-&gt;f_flags &amp; O_PATH)) &#123;</span><br><span class="line">        error = do_o_path(nd, flags, file); <span class="comment">// 如果是O_PATH标志，调用O_PATH处理函数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s = path_init(nd, flags); <span class="comment">// 初始化路径</span></span><br><span class="line">        <span class="keyword">while</span> (!(error = link_path_walk(s, nd)) &amp;&amp;</span><br><span class="line">               (s = open_last_lookups(nd, file, op)) != <span class="literal">NULL</span>)</span><br><span class="line">            ; <span class="comment">// 遍历路径中的目录项并打开文件</span></span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            error = do_open(nd, file, op); <span class="comment">// 执行打开文件操作</span></span><br><span class="line">        terminate_walk(nd); <span class="comment">// 终止路径遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (likely(!error)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (likely(file-&gt;f_mode &amp; FMODE_OPENED))</span><br><span class="line">            <span class="keyword">return</span> file; <span class="comment">// 如果文件已成功打开，返回文件指针</span></span><br><span class="line">        WARN_ON(<span class="number">1</span>); <span class="comment">// 打印警告信息</span></span><br><span class="line">        error = -EINVAL; <span class="comment">// 设置错误码为无效参数</span></span><br><span class="line">    &#125;</span><br><span class="line">    fput(file); <span class="comment">// 释放文件</span></span><br><span class="line">    <span class="keyword">if</span> (error == -EOPENSTALE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; LOOKUP_RCU)</span><br><span class="line">            error = -ECHILD; <span class="comment">// 如果是RCU查找标志，设置错误码为子进程不存在</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = -ESTALE; <span class="comment">// 否则设置错误码为文件已过期</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERR_PTR(error); <span class="comment">// 返回错误指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *<span class="title function_">do_filp_open</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *pathname,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span> <span class="comment">// 名称数据结构</span></span><br><span class="line">    <span class="type">int</span> flags = op-&gt;lookup_flags; <span class="comment">// 查找标志</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span> <span class="comment">// 文件指针</span></span><br><span class="line"></span><br><span class="line">    set_nameidata(&amp;nd, dfd, pathname, <span class="literal">NULL</span>); <span class="comment">// 设置名称数据结构</span></span><br><span class="line">    filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU); <span class="comment">// 打开路径对应的文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(filp == ERR_PTR(-ECHILD))) <span class="comment">// 如果打开失败且错误码为ECHILD</span></span><br><span class="line">        filp = path_openat(&amp;nd, op, flags); <span class="comment">// 再次尝试打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(filp == ERR_PTR(-ESTALE))) <span class="comment">// 如果打开失败且错误码为ESTALE</span></span><br><span class="line">        filp = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); <span class="comment">// 再次尝试打开文件（重新验证）</span></span><br><span class="line">    restore_nameidata(); <span class="comment">// 恢复名称数据结构</span></span><br><span class="line">    <span class="keyword">return</span> filp; <span class="comment">// 返回文件指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *<span class="title function_">do_file_open_root</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *root,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span> <span class="comment">// 名称数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span> <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">filename</span>;</span> <span class="comment">// 文件名</span></span><br><span class="line">    <span class="type">int</span> flags = op-&gt;lookup_flags; <span class="comment">// 查找标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d_is_symlink(root-&gt;dentry) &amp;&amp; op-&gt;intent &amp; LOOKUP_OPEN)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ELOOP); <span class="comment">// 如果根目录是符号链接且打开标志为LOOKUP_OPEN，返回ELOOP错误</span></span><br><span class="line"></span><br><span class="line">    filename = getname_kernel(name); <span class="comment">// 获取文件名</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(filename))</span><br><span class="line">        <span class="keyword">return</span> ERR_CAST(filename); <span class="comment">// 如果获取失败，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    set_nameidata(&amp;nd, <span class="number">-1</span>, filename, root); <span class="comment">// 设置名称数据结构</span></span><br><span class="line">    file = path_openat(&amp;nd, op, flags | LOOKUP_RCU); <span class="comment">// 打开路径对应的文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(file == ERR_PTR(-ECHILD))) <span class="comment">// 如果打开失败且错误码为ECHILD</span></span><br><span class="line">        file = path_openat(&amp;nd, op, flags); <span class="comment">// 再次尝试打开文件</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(file == ERR_PTR(-ESTALE))) <span class="comment">// 如果打开失败且错误码为ESTALE</span></span><br><span class="line">        file = path_openat(&amp;nd, op, flags | LOOKUP_REVAL); <span class="comment">// 再次尝试打开文件（重新验证）</span></span><br><span class="line">    restore_nameidata(); <span class="comment">// 恢复名称数据结构</span></span><br><span class="line">    putname(filename); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> file; <span class="comment">// 返回文件指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">filename_create</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name,</span></span><br><span class="line"><span class="params">                      <span class="keyword">struct</span> path *path, <span class="type">unsigned</span> <span class="type">int</span> lookup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> ERR_PTR(-EEXIST); <span class="comment">// 目录项指针，默认为已存在的错误指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span> <span class="comment">// 最后一个组件的名称</span></span><br><span class="line">    <span class="type">bool</span> want_dir = lookup_flags &amp; LOOKUP_DIRECTORY; <span class="comment">// 是否请求目录</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> reval_flag = lookup_flags &amp; LOOKUP_REVAL; <span class="comment">// 重新验证标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> create_flags = LOOKUP_CREATE | LOOKUP_EXCL; <span class="comment">// 创建标志</span></span><br><span class="line">    <span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> err2;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = filename_parentat(dfd, name, reval_flag, path, &amp;last, &amp;type); <span class="comment">// 查找父目录路径和最后一个组件</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(error); <span class="comment">// 如果查找失败，返回错误指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 糟糕的最后一个组件或根本没有最后一个组件？</span></span><br><span class="line"><span class="comment">     * (foo/., foo/.., /////)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(type != LAST_NORM))</span><br><span class="line">        <span class="keyword">goto</span> out; <span class="comment">// 如果最后一个组件异常，跳转到结束处</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是只读的，先不立即失败，至少尝试报告其他错误 */</span></span><br><span class="line">    err2 = mnt_want_write(path-&gt;mnt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进行最终的查找。如果有尾部&#x27;/&#x27;，且不需要目录，则不进行创建。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (last.name[last.len] &amp;&amp; !want_dir)</span><br><span class="line">        create_flags = <span class="number">0</span>; <span class="comment">// 如果尾部有&#x27;/&#x27;且不需要目录，不进行创建操作</span></span><br><span class="line">    inode_lock_nested(path-&gt;dentry-&gt;d_inode, I_MUTEX_PARENT); <span class="comment">// 锁住父目录的inode</span></span><br><span class="line"></span><br><span class="line">    dentry = __lookup_hash(&amp;last, path-&gt;dentry, reval_flag | create_flags); <span class="comment">// 查找目录项</span></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">goto</span> unlock; <span class="comment">// 如果查找失败，跳转到解锁处</span></span><br><span class="line"></span><br><span class="line">    error = -EEXIST;</span><br><span class="line">    <span class="keyword">if</span> (d_is_positive(dentry))</span><br><span class="line">        <span class="keyword">goto</span> fail; <span class="comment">// 如果目录项已存在，跳转到失败处</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 特殊情况 - 查找返回负值，但是...最后一个组件是 foo/bar/</span></span><br><span class="line"><span class="comment">     * 从 vfs_mknod() 的角度来看，我们只有一个负的目录项 -</span></span><br><span class="line"><span class="comment">     * 一切正常。但是我们可以采取一些恶意行为 - 你在末尾加了&#x27;/&#x27;，你要求的是（不存在的）目录。给你一个 -ENOENT。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!create_flags)) &#123;</span><br><span class="line">        error = -ENOENT;</span><br><span class="line">        <span class="keyword">goto</span> fail; <span class="comment">// 如果没有进行创建操作，跳转到失败处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(err2)) &#123;</span><br><span class="line">        error = err2;</span><br><span class="line">        <span class="keyword">goto</span> fail; <span class="comment">// 如果有其他错误，跳转到失败处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dentry; <span class="comment">// 返回目录项指针</span></span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    dput(dentry); <span class="comment">// 释放目录项</span></span><br><span class="line">    dentry = ERR_PTR(error); <span class="comment">// 设置为错误指针</span></span><br><span class="line">unlock:</span><br><span class="line">    inode_unlock(path-&gt;dentry-&gt;d_inode); <span class="comment">// 解锁父目录的inode</span></span><br><span class="line">    <span class="keyword">if</span> (!err2)</span><br><span class="line">        mnt_drop_write(path-&gt;mnt); <span class="comment">// 放弃写锁</span></span><br><span class="line">out:</span><br><span class="line">    path_put(path); <span class="comment">// 释放路径</span></span><br><span class="line">    <span class="keyword">return</span> dentry; <span class="comment">// 返回目录项指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从内核空间创建路径</span></span><br><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">kern_path_create</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> *pathname,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> path *path, <span class="type">unsigned</span> <span class="type">int</span> lookup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">filename</span> =</span> getname_kernel(pathname); <span class="comment">// 获取内核空间的文件名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span> =</span> filename_create(dfd, filename, path, lookup_flags); <span class="comment">// 创建路径</span></span><br><span class="line"></span><br><span class="line">    putname(filename); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 返回目录项指针</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kern_path_create); <span class="comment">// 导出kern_path_create符号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成路径创建操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">done_path_create</span><span class="params">(<span class="keyword">struct</span> path *path, <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    dput(dentry); <span class="comment">// 释放目录项</span></span><br><span class="line">    inode_unlock(path-&gt;dentry-&gt;d_inode); <span class="comment">// 解锁父目录的inode</span></span><br><span class="line">    mnt_drop_write(path-&gt;mnt); <span class="comment">// 放弃写锁</span></span><br><span class="line">    path_put(path); <span class="comment">// 释放路径</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(done_path_create); <span class="comment">// 导出done_path_create符号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从用户空间创建路径</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">struct</span> dentry *<span class="title function_">user_path_create</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *pathname,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> path *path, <span class="type">unsigned</span> <span class="type">int</span> lookup_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">filename</span> =</span> getname(pathname); <span class="comment">// 获取用户空间的文件名</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span> =</span> filename_create(dfd, filename, path, lookup_flags); <span class="comment">// 创建路径</span></span><br><span class="line"></span><br><span class="line">    putname(filename); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 返回目录项指针</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(user_path_create); <span class="comment">// 导出user_path_create符号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_mknod - 创建设备节点或文件</span></span><br><span class="line"><span class="comment"> * @idmap:    挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @dir:    目录的inode</span></span><br><span class="line"><span class="comment"> * @dentry:    指向基础目录的dentry指针</span></span><br><span class="line"><span class="comment"> * @mode:    新设备节点或文件的权限</span></span><br><span class="line"><span class="comment"> * @dev:    要创建的设备的设备号</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建设备节点或文件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过id映射的挂载点找到了inode，必须通过@idmap传递vfsmount的idmap。此函数将负责根据@idmap映射inode，然后检查权限。</span></span><br><span class="line"><span class="comment"> * 对于非id映射的挂载点，或者如果要对原始inode执行权限检查，则只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mknod</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> is_whiteout = S_ISCHR(mode) &amp;&amp; dev == WHITEOUT_DEV; <span class="comment">// 是否是白出节点</span></span><br><span class="line">    <span class="type">int</span> error = may_create(idmap, dir, dentry); <span class="comment">// 检查是否可以创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error; <span class="comment">// 如果不允许创建，返回错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((S_ISCHR(mode) || S_ISBLK(mode)) &amp;&amp; !is_whiteout &amp;&amp;</span><br><span class="line">        !capable(CAP_MKNOD))</span><br><span class="line">        <span class="keyword">return</span> -EPERM; <span class="comment">// 如果是字符设备或块设备但不是白出节点且没有CAP_MKNOD权限，返回EPERM</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;mknod)</span><br><span class="line">        <span class="keyword">return</span> -EPERM; <span class="comment">// 如果目录的i_op中没有mknod操作，返回EPERM</span></span><br><span class="line"></span><br><span class="line">    mode = vfs_prepare_mode(idmap, dir, mode, mode, mode); <span class="comment">// 准备权限模式</span></span><br><span class="line">    error = devcgroup_inode_mknod(mode, dev); <span class="comment">// 在devcgroup中进行inode_mknod操作</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error; <span class="comment">// 如果devcgroup_inode_mknod操作失败，返回错误</span></span><br><span class="line"></span><br><span class="line">    error = security_inode_mknod(dir, dentry, mode, dev); <span class="comment">// 进行安全性检查</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error; <span class="comment">// 如果安全性检查失败，返回错误</span></span><br><span class="line"></span><br><span class="line">    error = dir-&gt;i_op-&gt;mknod(idmap, dir, dentry, mode, dev); <span class="comment">// 调用目录的mknod操作</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        fsnotify_create(dir, dentry); <span class="comment">// 发送文件系统通知，表示创建成功</span></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_mknod); <span class="comment">// 导出vfs_mknod符号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">may_mknod</span><span class="params">(<span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mode &amp; S_IFMT) &#123;</span><br><span class="line">    <span class="keyword">case</span> S_IFREG:</span><br><span class="line">    <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">    <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">    <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">    <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 零模式转换为S_IFREG */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 检查是否可以创建设备节点或文件的辅助函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_mknodat</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span> <span class="comment">// 挂载点idmap指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 目录项指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 路径结构体</span></span><br><span class="line">    <span class="type">int</span> error; <span class="comment">// 错误码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = <span class="number">0</span>; <span class="comment">// 查找标志</span></span><br><span class="line"></span><br><span class="line">    error = may_mknod(mode); <span class="comment">// 检查是否可以创建设备节点或文件</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    dentry = filename_create(dfd, name, &amp;path, lookup_flags); <span class="comment">// 创建目录项</span></span><br><span class="line">    error = PTR_ERR(dentry);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">goto</span> out1;</span><br><span class="line"></span><br><span class="line">    error = security_path_mknod(&amp;path, dentry,</span><br><span class="line">            mode_strip_umask(path.dentry-&gt;d_inode, mode), dev); <span class="comment">// 进行路径的安全性检查</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line"></span><br><span class="line">    idmap = mnt_idmap(path.mnt); <span class="comment">// 获取挂载点的idmap</span></span><br><span class="line">    <span class="keyword">switch</span> (mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            error = vfs_create(idmap, path.dentry-&gt;d_inode,</span><br><span class="line">                       dentry, mode, <span class="literal">true</span>); <span class="comment">// 创建普通文件</span></span><br><span class="line">            <span class="keyword">if</span> (!error)</span><br><span class="line">                ima_post_path_mknod(idmap, dentry); <span class="comment">// 在IMA中记录创建设备节点或文件的路径</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR: <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            error = vfs_mknod(idmap, path.dentry-&gt;d_inode,</span><br><span class="line">                      dentry, mode, new_decode_dev(dev)); <span class="comment">// 创建字符设备或块设备节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO: <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">            error = vfs_mknod(idmap, path.dentry-&gt;d_inode,</span><br><span class="line">                      dentry, mode, <span class="number">0</span>); <span class="comment">// 创建FIFO管道或套接字节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">out2:</span><br><span class="line">    done_path_create(&amp;path, dentry); <span class="comment">// 完成路径创建操作</span></span><br><span class="line">    <span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123; <span class="comment">// 如果错误码指示需要重试（可能是由于NFS导致的错误）</span></span><br><span class="line">        lookup_flags |= LOOKUP_REVAL; <span class="comment">// 设置重试标志</span></span><br><span class="line">        <span class="keyword">goto</span> retry; <span class="comment">// 重试</span></span><br><span class="line">    &#125;</span><br><span class="line">out1:</span><br><span class="line">    putname(name); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(mknodat, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">umode_t</span>, mode,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>, dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_mknodat(dfd, getname(filename), mode, dev); <span class="comment">// 执行do_mknodat系统调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(mknod, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">umode_t</span>, mode, <span class="type">unsigned</span>, dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_mknodat(AT_FDCWD, getname(filename), mode, dev); <span class="comment">// 执行do_mknodat系统调用，使用当前工作目录作为dfd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_mkdir - 创建目录</span></span><br><span class="line"><span class="comment"> * @idmap: 挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @dir: 目录的inode</span></span><br><span class="line"><span class="comment"> * @dentry: 基础目录的dentry指针</span></span><br><span class="line"><span class="comment"> * @mode: 新目录的权限模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建一个目录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。</span></span><br><span class="line"><span class="comment"> * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。</span></span><br><span class="line"><span class="comment"> * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mkdir</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">unsigned</span> max_links = dir-&gt;i_sb-&gt;s_max_links; <span class="comment">// 目录的最大链接数</span></span><br><span class="line"></span><br><span class="line">    error = may_create(idmap, dir, dentry); <span class="comment">// 检查是否可以创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;mkdir) <span class="comment">// 检查是否支持mkdir操作</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    mode = vfs_prepare_mode(idmap, dir, mode, S_IRWXUGO | S_ISVTX, <span class="number">0</span>); <span class="comment">// 准备目录的权限模式</span></span><br><span class="line">    error = security_inode_mkdir(dir, dentry, mode); <span class="comment">// 检查目录的安全性</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max_links &amp;&amp; dir-&gt;i_nlink &gt;= max_links) <span class="comment">// 检查目录的链接数是否超过最大限制</span></span><br><span class="line">        <span class="keyword">return</span> -EMLINK;</span><br><span class="line"></span><br><span class="line">    error = dir-&gt;i_op-&gt;mkdir(idmap, dir, dentry, mode); <span class="comment">// 调用文件系统特定的mkdir操作</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        fsnotify_mkdir(dir, dentry); <span class="comment">// 发送目录创建通知</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_mkdir);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_mkdirat</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 目录项指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 路径结构体</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = LOOKUP_DIRECTORY; <span class="comment">// 查找标志，指示查找的是目录</span></span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    dentry = filename_create(dfd, name, &amp;path, lookup_flags); <span class="comment">// 创建目录项</span></span><br><span class="line">    error = PTR_ERR(dentry);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">goto</span> out_putname;</span><br><span class="line"></span><br><span class="line">    error = security_path_mkdir(&amp;path, dentry,</span><br><span class="line">            mode_strip_umask(path.dentry-&gt;d_inode, mode)); <span class="comment">// 检查路径的安全性</span></span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        error = vfs_mkdir(mnt_idmap(path.mnt), path.dentry-&gt;d_inode,</span><br><span class="line">                  dentry, mode); <span class="comment">// 调用vfs_mkdir创建目录</span></span><br><span class="line">    &#125;</span><br><span class="line">    done_path_create(&amp;path, dentry); <span class="comment">// 完成路径创建操作</span></span><br><span class="line">    <span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123; <span class="comment">// 如果错误码指示需要重试（可能是由于NFS导致的错误）</span></span><br><span class="line">        lookup_flags |= LOOKUP_REVAL; <span class="comment">// 设置重试标志</span></span><br><span class="line">        <span class="keyword">goto</span> retry; <span class="comment">// 重试</span></span><br><span class="line">    &#125;</span><br><span class="line">out_putname:</span><br><span class="line">    putname(name); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(mkdirat, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, pathname, <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_mkdirat(dfd, getname(pathname), mode); <span class="comment">// 执行do_mkdirat系统调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(mkdir, <span class="type">const</span> <span class="type">char</span> __user *, pathname, <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_mkdirat(AT_FDCWD, getname(pathname), mode); <span class="comment">// 执行do_mkdirat系统调用，使用当前工作目录作为dfd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_rmdir - 删除目录</span></span><br><span class="line"><span class="comment"> * @idmap: 挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @dir: 目录的inode</span></span><br><span class="line"><span class="comment"> * @dentry: 基础目录的dentry指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 删除一个目录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。</span></span><br><span class="line"><span class="comment"> * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。</span></span><br><span class="line"><span class="comment"> * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_rmdir</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = may_delete(idmap, dir, dentry, <span class="number">1</span>); <span class="comment">// 检查是否可以删除目录，同时标记为rmdir操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;rmdir) <span class="comment">// 检查是否支持rmdir操作</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    dget(dentry); <span class="comment">// 获取dentry的引用</span></span><br><span class="line">    inode_lock(dentry-&gt;d_inode); <span class="comment">// 锁定dentry的inode</span></span><br><span class="line"></span><br><span class="line">    error = -EBUSY;</span><br><span class="line">    <span class="keyword">if</span> (is_local_mountpoint(dentry) ||</span><br><span class="line">        (dentry-&gt;d_inode-&gt;i_flags &amp; S_KERNEL_FILE))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = security_inode_rmdir(dir, dentry); <span class="comment">// 检查目录的安全性</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = dir-&gt;i_op-&gt;rmdir(dir, dentry); <span class="comment">// 调用文件系统特定的rmdir操作</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    shrink_dcache_parent(dentry); <span class="comment">// 清理dentry的父目录的dentry缓存</span></span><br><span class="line">    dentry-&gt;d_inode-&gt;i_flags |= S_DEAD; <span class="comment">// 标记目录的inode为已删除</span></span><br><span class="line">    dont_mount(dentry); <span class="comment">// 取消挂载</span></span><br><span class="line">    detach_mounts(dentry); <span class="comment">// 分离挂载点</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    inode_unlock(dentry-&gt;d_inode); <span class="comment">// 解锁dentry的inode</span></span><br><span class="line">    dput(dentry); <span class="comment">// 释放dentry的引用</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        d_delete_notify(dir, dentry); <span class="comment">// 发送目录删除通知</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_rmdir); <span class="comment">// 导出vfs_rmdir符号，供其他模块使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_rmdir - 删除目录</span></span><br><span class="line"><span class="comment"> * @idmap: 挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @dir: 目录的inode</span></span><br><span class="line"><span class="comment"> * @dentry: 基础目录的dentry指针</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 删除一个目录。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。</span></span><br><span class="line"><span class="comment"> * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。</span></span><br><span class="line"><span class="comment"> * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_rmdir</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> dentry *dentry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = may_delete(idmap, dir, dentry, <span class="number">1</span>); <span class="comment">// 检查是否可以删除目录，同时标记为rmdir操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;rmdir) <span class="comment">// 检查是否支持rmdir操作</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    dget(dentry); <span class="comment">// 获取dentry的引用</span></span><br><span class="line">    inode_lock(dentry-&gt;d_inode); <span class="comment">// 锁定dentry的inode</span></span><br><span class="line"></span><br><span class="line">    error = -EBUSY;</span><br><span class="line">    <span class="keyword">if</span> (is_local_mountpoint(dentry) ||</span><br><span class="line">        (dentry-&gt;d_inode-&gt;i_flags &amp; S_KERNEL_FILE))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = security_inode_rmdir(dir, dentry); <span class="comment">// 检查目录的安全性</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    error = dir-&gt;i_op-&gt;rmdir(dir, dentry); <span class="comment">// 调用文件系统特定的rmdir操作</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    shrink_dcache_parent(dentry); <span class="comment">// 清理dentry的父目录的dentry缓存</span></span><br><span class="line">    dentry-&gt;d_inode-&gt;i_flags |= S_DEAD; <span class="comment">// 标记目录的inode为已删除</span></span><br><span class="line">    dont_mount(dentry); <span class="comment">// 取消挂载</span></span><br><span class="line">    detach_mounts(dentry); <span class="comment">// 分离挂载点</span></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    inode_unlock(dentry-&gt;d_inode); <span class="comment">// 解锁dentry的inode</span></span><br><span class="line">    dput(dentry); <span class="comment">// 释放dentry的引用</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        d_delete_notify(dir, dentry); <span class="comment">// 发送目录删除通知</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_rmdir); <span class="comment">// 导出vfs_rmdir符号，供其他模块使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_rmdir</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 目录项指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 路径结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span> <span class="comment">// 最后一个组件的qstr结构体</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 最后一个组件的类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = <span class="number">0</span>; <span class="comment">// 查找标志</span></span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); <span class="comment">// 获取父目录的路径和最后一个组件</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> exit1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> LAST_DOTDOT: <span class="comment">// 如果最后一个组件是&quot;..&quot;</span></span><br><span class="line">        error = -ENOTEMPTY; <span class="comment">// 目录非空，无法删除</span></span><br><span class="line">        <span class="keyword">goto</span> exit2;</span><br><span class="line">    <span class="keyword">case</span> LAST_DOT: <span class="comment">// 如果最后一个组件是&quot;.&quot;</span></span><br><span class="line">        error = -EINVAL; <span class="comment">// 无效的参数</span></span><br><span class="line">        <span class="keyword">goto</span> exit2;</span><br><span class="line">    <span class="keyword">case</span> LAST_ROOT: <span class="comment">// 如果最后一个组件是根目录</span></span><br><span class="line">        error = -EBUSY; <span class="comment">// 根目录无法删除</span></span><br><span class="line">        <span class="keyword">goto</span> exit2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error = mnt_want_write(path.mnt); <span class="comment">// 获取vfsmount的写访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> exit2;</span><br><span class="line"></span><br><span class="line">    inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); <span class="comment">// 锁定父目录的inode</span></span><br><span class="line">    dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); <span class="comment">// 查找目录项</span></span><br><span class="line">    error = PTR_ERR(dentry);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">goto</span> exit3;</span><br><span class="line">    <span class="keyword">if</span> (!dentry-&gt;d_inode) &#123;</span><br><span class="line">        error = -ENOENT; <span class="comment">// 目录项不存在</span></span><br><span class="line">        <span class="keyword">goto</span> exit4;</span><br><span class="line">    &#125;</span><br><span class="line">    error = security_path_rmdir(&amp;path, dentry); <span class="comment">// 检查路径的安全性</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> exit4;</span><br><span class="line">    error = vfs_rmdir(mnt_idmap(path.mnt), path.dentry-&gt;d_inode, dentry); <span class="comment">// 调用vfs_rmdir删除目录</span></span><br><span class="line">exit4:</span><br><span class="line">    dput(dentry); <span class="comment">// 释放目录项的引用</span></span><br><span class="line">exit3:</span><br><span class="line">    inode_unlock(path.dentry-&gt;d_inode); <span class="comment">// 解锁父目录的inode</span></span><br><span class="line">    mnt_drop_write(path.mnt); <span class="comment">// 释放vfsmount的写访问权限</span></span><br><span class="line">exit2:</span><br><span class="line">    path_put(&amp;path); <span class="comment">// 释放路径</span></span><br><span class="line">    <span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123; <span class="comment">// 如果错误码指示需要重试（可能是由于NFS导致的错误）</span></span><br><span class="line">        lookup_flags |= LOOKUP_REVAL; <span class="comment">// 设置重试标志</span></span><br><span class="line">        <span class="keyword">goto</span> retry; <span class="comment">// 重试</span></span><br><span class="line">    &#125;</span><br><span class="line">exit1:</span><br><span class="line">    putname(name); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE1(rmdir, <span class="type">const</span> <span class="type">char</span> __user *, pathname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_rmdir(AT_FDCWD, getname(pathname)); <span class="comment">// 执行do_rmdir系统调用，使用当前工作目录作为dfd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_unlink - 解除文件系统对象的链接</span></span><br><span class="line"><span class="comment"> * @idmap: 挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @dir: 父目录的inode</span></span><br><span class="line"><span class="comment"> * @dentry: 目标目录项</span></span><br><span class="line"><span class="comment"> * @delegated_inode: 如果inode已委派，则返回目标inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者必须持有dir-&gt;i_mutex。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果vfs_unlink发现了委派关系，则返回-EWOULDBLOCK，并在delegated_inode中返回对inode的引用。</span></span><br><span class="line"><span class="comment"> * 调用者应该在此inode上解除委派并重试。由于解除委派可能需要很长时间，调用者应在这样做之前释放dir-&gt;i_mutex。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者，调用者可以将delegated_inode传递为NULL。这可能适用于预期底层文件系统未导出为NFS的调用者。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过id映射的挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。</span></span><br><span class="line"><span class="comment"> * 此函数将根据@idmap映射inode，并在检查权限之前处理映射。</span></span><br><span class="line"><span class="comment"> * 如果是非id映射的挂载点，或者需要在原始inode上执行权限检查，只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_unlink</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode **delegated_inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">target</span> =</span> dentry-&gt;d_inode; <span class="comment">// 目标inode</span></span><br><span class="line">    <span class="type">int</span> error = may_delete(idmap, dir, dentry, <span class="number">0</span>); <span class="comment">// 检查是否可以删除文件，同时标记为unlink操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;unlink) <span class="comment">// 检查是否支持unlink操作</span></span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    inode_lock(target); <span class="comment">// 锁定目标inode</span></span><br><span class="line">    <span class="keyword">if</span> (IS_SWAPFILE(target))</span><br><span class="line">        error = -EPERM;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_local_mountpoint(dentry))</span><br><span class="line">        error = -EBUSY;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        error = security_inode_unlink(dir, dentry); <span class="comment">// 检查目录项的安全性</span></span><br><span class="line">        <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            error = try_break_deleg(target, delegated_inode); <span class="comment">// 尝试解除委派关系</span></span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            error = dir-&gt;i_op-&gt;unlink(dir, dentry); <span class="comment">// 调用文件系统特定的unlink操作</span></span><br><span class="line">            <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">                dont_mount(dentry); <span class="comment">// 取消挂载</span></span><br><span class="line">                detach_mounts(dentry); <span class="comment">// 分离挂载点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    inode_unlock(target); <span class="comment">// 解锁目标inode</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We don&#x27;t d_delete() NFS sillyrenamed files--they still exist. */</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; dentry-&gt;d_flags &amp; DCACHE_NFSFS_RENAMED) &#123;</span><br><span class="line">        fsnotify_unlink(dir, dentry); <span class="comment">// 发送文件解除链接通知</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        fsnotify_link_count(target); <span class="comment">// 更新链接计数器</span></span><br><span class="line">        d_delete_notify(dir, dentry); <span class="comment">// 发送目录项删除通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_unlink); <span class="comment">// 导出vfs_unlink符号，供其他模块使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 确保文件的实际截断发生在其目录的i_mutex之外。</span></span><br><span class="line"><span class="comment"> * 如果有大量的写出操作，截断可能需要很长时间，我们不希望在等待I/O时阻止对目录的访问。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_unlinkat</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span> <span class="comment">// 目标目录项</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span> <span class="comment">// 目标路径</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">last</span>;</span> <span class="comment">// 目标名称</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 目标类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 目标inode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 委派的inode</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    error = filename_parentat(dfd, name, lookup_flags, &amp;path, &amp;last, &amp;type); <span class="comment">// 获取目标路径的父目录和名称</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> exit1;</span><br><span class="line"></span><br><span class="line">    error = -EISDIR;</span><br><span class="line">    <span class="keyword">if</span> (type != LAST_NORM) <span class="comment">// 目标不是正常的目录项</span></span><br><span class="line">        <span class="keyword">goto</span> exit2;</span><br><span class="line"></span><br><span class="line">    error = mnt_want_write(path.mnt); <span class="comment">// 获取挂载点写入权限</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">goto</span> exit2;</span><br><span class="line"></span><br><span class="line">retry_deleg:</span><br><span class="line">    inode_lock_nested(path.dentry-&gt;d_inode, I_MUTEX_PARENT); <span class="comment">// 锁定目录的父目录</span></span><br><span class="line">    dentry = __lookup_hash(&amp;last, path.dentry, lookup_flags); <span class="comment">// 查找目标目录项</span></span><br><span class="line">    error = PTR_ERR(dentry);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(dentry)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为什么不在此之前？因为我们希望得到正确的错误值 */</span></span><br><span class="line">        <span class="keyword">if</span> (last.name[last.len])</span><br><span class="line">            <span class="keyword">goto</span> slashes;</span><br><span class="line">        inode = dentry-&gt;d_inode; <span class="comment">// 目标inode</span></span><br><span class="line">        <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">            <span class="keyword">goto</span> slashes;</span><br><span class="line">        ihold(inode); <span class="comment">// 增加inode的引用计数</span></span><br><span class="line">        error = security_path_unlink(&amp;path, dentry); <span class="comment">// 检查路径的安全性</span></span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">goto</span> exit3;</span><br><span class="line">        error = vfs_unlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode,</span><br><span class="line">                   dentry, &amp;delegated_inode); <span class="comment">// 调用vfs_unlink解除链接操作</span></span><br><span class="line">exit3:</span><br><span class="line">        dput(dentry); <span class="comment">// 释放目标目录项</span></span><br><span class="line">    &#125;</span><br><span class="line">    inode_unlock(path.dentry-&gt;d_inode); <span class="comment">// 解锁目录的父目录</span></span><br><span class="line">    <span class="keyword">if</span> (inode)</span><br><span class="line">        iput(inode);    <span class="comment">/* 在此处截断inode */</span></span><br><span class="line">    inode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (delegated_inode) &#123;</span><br><span class="line">        error = break_deleg_wait(&amp;delegated_inode); <span class="comment">// 等待解除委派</span></span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            <span class="keyword">goto</span> retry_deleg;</span><br><span class="line">    &#125;</span><br><span class="line">    mnt_drop_write(path.mnt); <span class="comment">// 释放挂载点写入权限</span></span><br><span class="line">exit2:</span><br><span class="line">    path_put(&amp;path); <span class="comment">// 释放路径</span></span><br><span class="line">    <span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123; <span class="comment">// 检查错误码是否表示需要重新验证</span></span><br><span class="line">        lookup_flags |= LOOKUP_REVAL;</span><br><span class="line">        inode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">exit1:</span><br><span class="line">    putname(name); <span class="comment">// 释放文件名</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">slashes:</span><br><span class="line">    <span class="keyword">if</span> (d_is_negative(dentry))</span><br><span class="line">        error = -ENOENT;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d_is_dir(dentry))</span><br><span class="line">        error = -EISDIR;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        error = -ENOTDIR;</span><br><span class="line">    <span class="keyword">goto</span> exit3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(unlinkat, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, pathname, <span class="type">int</span>, flag)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; ~AT_REMOVEDIR) != <span class="number">0</span>) <span class="comment">// 检查标志位是否有效</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag &amp; AT_REMOVEDIR) <span class="comment">// 如果标志位指示移除目录</span></span><br><span class="line">        <span class="keyword">return</span> do_rmdir(dfd, getname(pathname)); <span class="comment">// 调用do_rmdir函数移除目录</span></span><br><span class="line">    <span class="keyword">return</span> do_unlinkat(dfd, getname(pathname)); <span class="comment">// 否则调用do_unlinkat函数解除链接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE1(unlink, <span class="type">const</span> <span class="type">char</span> __user *, pathname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> do_unlinkat(AT_FDCWD, getname(pathname)); <span class="comment">// 调用do_unlinkat函数解除链接，并使用AT_FDCWD作为dfd参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_symlink - 创建符号链接</span></span><br><span class="line"><span class="comment"> * @idmap: 指向inode所在挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @dir: 目录的inode</span></span><br><span class="line"><span class="comment"> * @dentry: 基础目录的dentry指针</span></span><br><span class="line"><span class="comment"> * @oldname: 要链接的文件的名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 创建一个符号链接。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过idmapped挂载点找到了inode，则必须通过@idmap传递vfsmount的idmap。</span></span><br><span class="line"><span class="comment"> * 此函数将负责根据@idmap将inode映射，然后检查权限。</span></span><br><span class="line"><span class="comment"> * 如果是非idmapped挂载点，或者需要对原始inode进行权限检查，则只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_symlink</span><span class="params">(<span class="keyword">struct</span> mnt_idmap *idmap, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> dentry *dentry, <span class="type">const</span> <span class="type">char</span> *oldname)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = may_create(idmap, dir, dentry); <span class="comment">// 检查是否允许创建</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dir-&gt;i_op-&gt;symlink)</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">    error = security_inode_symlink(dir, dentry, oldname); <span class="comment">// 检查安全性</span></span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    error = dir-&gt;i_op-&gt;symlink(idmap, dir, dentry, oldname); <span class="comment">// 调用inode的symlink操作</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        fsnotify_create(dir, dentry); <span class="comment">// 发送文件创建通知</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_symlink);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_symlinkat</span><span class="params">(<span class="keyword">struct</span> filename *from, <span class="type">int</span> newdfd, <span class="keyword">struct</span> filename *to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(from)) &#123;</span><br><span class="line">        error = PTR_ERR(from);</span><br><span class="line">        <span class="keyword">goto</span> out_putnames;</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">    dentry = filename_create(newdfd, to, &amp;path, lookup_flags); <span class="comment">// 创建dentry和path</span></span><br><span class="line">    error = PTR_ERR(dentry);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">        <span class="keyword">goto</span> out_putnames;</span><br><span class="line"></span><br><span class="line">    error = security_path_symlink(&amp;path, dentry, from-&gt;name); <span class="comment">// 检查路径的安全性</span></span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        error = vfs_symlink(mnt_idmap(path.mnt), path.dentry-&gt;d_inode,</span><br><span class="line">                    dentry, from-&gt;name); <span class="comment">// 调用vfs_symlink创建符号链接</span></span><br><span class="line">    done_path_create(&amp;path, dentry); <span class="comment">// 完成路径和dentry的创建</span></span><br><span class="line">    <span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123;</span><br><span class="line">        lookup_flags |= LOOKUP_REVAL;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">out_putnames:</span><br><span class="line">    putname(to); <span class="comment">// 释放to的名称</span></span><br><span class="line">    putname(from); <span class="comment">// 释放from的名称</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(symlinkat, <span class="type">const</span> <span class="type">char</span> __user *, oldname,</span><br><span class="line"><span class="type">int</span>, newdfd, <span class="type">const</span> <span class="type">char</span> __user *, newname)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_symlinkat(getname(oldname), newdfd, getname(newname));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个名为symlinkat的系统调用函数定义。它接受三个参数：oldname（指向旧文件名的用户空间指针）、newdfd（新文件描述符）和newname（指向新文件名的用户空间指针）。该函数的作用是在指定的目录中创建一个符号链接。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(symlink, <span class="type">const</span> <span class="type">char</span> __user *, oldname, <span class="type">const</span> <span class="type">char</span> __user *, newname)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_symlinkat(getname(oldname), AT_FDCWD, getname(newname));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是一个名为symlink的系统调用函数定义。它接受两个参数：oldname（指向旧文件名的用户空间指针）和newname（指向新文件名的用户空间指针）。该函数的作用是在当前工作目录中创建一个符号链接。它调用了do_symlinkat函数，将AT_FDCWD作为新文件描述符传递给它，表示当前工作目录。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vfs_link - 创建一个新的硬链接</span></span><br><span class="line"><span class="comment"> * @old_dentry:要链接的对象</span></span><br><span class="line"><span class="comment"> * @idmap:挂载点的idmap</span></span><br><span class="line"><span class="comment"> * @dir:新的父目录</span></span><br><span class="line"><span class="comment"> * @new_dentry:新链接的位置</span></span><br><span class="line"><span class="comment"> * @delegated_inode: 需要中断委托的inode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者必须持有dir-&gt;i_mutex</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果vfs_link发现需要中断的待链接文件上存在委托，它将返回-EWOULDBLOCK，并返回对委托inode的引用。</span></span><br><span class="line"><span class="comment"> * 调用者应该在中断委托之前释放i_mutex并重试。因为中断委托可能需要很长时间，所以调用者应该在这样做之前释放i_mutex。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 或者，调用者可以将delegated_inode传递为NULL。这对于预期底层文件系统不是NFS导出的调用者可能是合适的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果通过idmapped挂载找到了inode，则必须通过@idmap传递vfsmount的idmap。此函数将负责根据@idmap映射inode，然后检查权限。</span></span><br><span class="line"><span class="comment"> * 对于非idmapped挂载或者如果要对原始inode执行权限检查，只需传递@nop_mnt_idmap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_link</span><span class="params">(<span class="keyword">struct</span> dentry *old_dentry, <span class="keyword">struct</span> mnt_idmap *idmap,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *new_dentry,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> inode **delegated_inode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> old_dentry-&gt;d_inode;</span><br><span class="line"><span class="type">unsigned</span> max_links = dir-&gt;i_sb-&gt;s_max_links;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inode)</span><br><span class="line"><span class="keyword">return</span> -ENOENT;</span><br><span class="line"></span><br><span class="line">error = may_create(idmap, dir, new_dentry);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dir-&gt;i_sb != inode-&gt;i_sb)</span><br><span class="line"><span class="keyword">return</span> -EXDEV;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 不能创建指向只追加或只读的文件的链接。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (IS_APPEND(inode) || IS_IMMUTABLE(inode))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果真实值对于vfs未知，更新链接计数可能会导致i_uid和i_gid被错误地写回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (HAS_UNMAPPED_ID(idmap, inode))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"><span class="keyword">if</span> (!dir-&gt;i_op-&gt;link)</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">error = security_inode_link(old_dentry, dir, new_dentry);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">inode_lock(inode);</span><br><span class="line"><span class="comment">/* 确保我们不允许创建指向未链接文件的硬链接 */</span></span><br><span class="line"><span class="keyword">if</span> (inode-&gt;i_nlink == <span class="number">0</span> &amp;&amp; !(inode-&gt;i_state &amp; I_LINKABLE))</span><br><span class="line">error =  -ENOENT;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (max_links &amp;&amp; inode-&gt;i_nlink &gt;= max_links)</span><br><span class="line">error = -EMLINK;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">error = try_break_deleg(inode, delegated_inode);</span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line">error = dir-&gt;i_op-&gt;link(old_dentry, dir, new_dentry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!error &amp;&amp; (inode-&gt;i_state &amp; I_LINKABLE)) &#123;</span><br><span class="line">spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">inode-&gt;i_state &amp;= ~I_LINKABLE;</span><br><span class="line">spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">&#125;</span><br><span class="line">inode_unlock(inode);</span><br><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line">fsnotify_link(dir, inode, new_dentry);</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_link);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Hardlinks are often used in delicate situations.  We avoid</span></span><br><span class="line"><span class="comment"> * security-related surprises by not following symlinks on the</span></span><br><span class="line"><span class="comment"> * newname.  --KAB</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We don&#x27;t follow them on the oldname either to be compatible</span></span><br><span class="line"><span class="comment"> * with linux 2.0, and to avoid hard-linking to directories</span></span><br><span class="line"><span class="comment"> * and other special files.  --ADM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_linkat</span><span class="params">(<span class="type">int</span> olddfd, <span class="keyword">struct</span> filename *old, <span class="type">int</span> newdfd,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> filename *new, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mnt_idmap</span> *<span class="title">idmap</span>;</span> <span class="comment">// 挂载ID映射</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">new_dentry</span>;</span> <span class="comment">// 新文件的目录项</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_path</span>, <span class="title">new_path</span>;</span> <span class="comment">// 旧文件和新文件的路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 委派的inode</span></span><br><span class="line"><span class="type">int</span> how = <span class="number">0</span>; <span class="comment">// 查找标志</span></span><br><span class="line"><span class="type">int</span> error; <span class="comment">// 错误码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((flags &amp; ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != <span class="number">0</span>) &#123;</span><br><span class="line">error = -EINVAL; <span class="comment">// 无效的标志</span></span><br><span class="line"><span class="keyword">goto</span> out_putnames;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To use null names we require CAP_DAC_READ_SEARCH</span></span><br><span class="line"><span class="comment"> * This ensures that not everyone will be able to create</span></span><br><span class="line"><span class="comment"> * handlink using the passed filedescriptor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; AT_EMPTY_PATH &amp;&amp; !capable(CAP_DAC_READ_SEARCH)) &#123;</span><br><span class="line">error = -ENOENT; <span class="comment">// 无法使用空名称创建硬链接</span></span><br><span class="line"><span class="keyword">goto</span> out_putnames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags &amp; AT_SYMLINK_FOLLOW)</span><br><span class="line">how |= LOOKUP_FOLLOW; <span class="comment">// 启用跟随符号链接</span></span><br><span class="line">retry:</span><br><span class="line">error = filename_lookup(olddfd, old, how, &amp;old_path, <span class="literal">NULL</span>); <span class="comment">// 查找旧文件</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out_putnames;</span><br><span class="line"></span><br><span class="line">new_dentry = filename_create(newdfd, new, &amp;new_path,</span><br><span class="line">(how &amp; LOOKUP_REVAL)); <span class="comment">// 创建新文件的目录项</span></span><br><span class="line">error = PTR_ERR(new_dentry);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(new_dentry))</span><br><span class="line"><span class="keyword">goto</span> out_putpath;</span><br><span class="line"></span><br><span class="line">error = -EXDEV; <span class="comment">// 不允许跨设备硬链接</span></span><br><span class="line"><span class="keyword">if</span> (old_path.mnt != new_path.mnt)</span><br><span class="line"><span class="keyword">goto</span> out_dput;</span><br><span class="line">idmap = mnt_idmap(new_path.mnt); <span class="comment">// 获取挂载ID映射</span></span><br><span class="line">error = may_linkat(idmap, &amp;old_path); <span class="comment">// 检查是否有权限创建硬链接</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(error))</span><br><span class="line"><span class="keyword">goto</span> out_dput;</span><br><span class="line">error = security_path_link(old_path.dentry, &amp;new_path, new_dentry); <span class="comment">// 安全检查</span></span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> out_dput;</span><br><span class="line">error = vfs_link(old_path.dentry, idmap, new_path.dentry-&gt;d_inode,</span><br><span class="line"> new_dentry, &amp;delegated_inode); <span class="comment">// 创建硬链接</span></span><br><span class="line">out_dput:</span><br><span class="line">done_path_create(&amp;new_path, new_dentry); <span class="comment">// 释放新文件的路径和目录项</span></span><br><span class="line"><span class="keyword">if</span> (delegated_inode) &#123;</span><br><span class="line">error = break_deleg_wait(&amp;delegated_inode); <span class="comment">// 中断委派并重试链接操作</span></span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">path_put(&amp;old_path);</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (retry_estale(error, how)) &#123;</span><br><span class="line">path_put(&amp;old_path);</span><br><span class="line">how |= LOOKUP_REVAL; <span class="comment">// 重新验证文件句柄</span></span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">out_putpath:</span><br><span class="line">path_put(&amp;old_path); <span class="comment">// 释放旧文件的路径</span></span><br><span class="line">out_putnames:</span><br><span class="line">putname(old); <span class="comment">// 释放旧文件的文件名</span></span><br><span class="line">putname(new); <span class="comment">// 释放新文件的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> error; <span class="comment">// 返回错误码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(linkat, <span class="type">int</span>, olddfd, <span class="type">const</span> <span class="type">char</span> __user *, oldname,</span><br><span class="line"><span class="type">int</span>, newdfd, <span class="type">const</span> <span class="type">char</span> __user *, newname, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_linkat(olddfd, getname_uflags(oldname, flags),</span><br><span class="line">newdfd, getname(newname), flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义系统调用函数linkat，接受五个参数：olddfd表示旧目录文件描述符，oldname表示旧文件路径名，</span></span><br><span class="line"><span class="comment">// newdfd表示新目录文件描述符，newname表示新文件路径名，flags表示链接选项</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(link, <span class="type">const</span> <span class="type">char</span> __user \*, oldname, <span class="type">const</span> <span class="type">char</span> __user *, newname)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_linkat(AT_FDCWD, getname(oldname), AT_FDCWD, getname(newname), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义系统调用函数link，接受两个参数：oldname表示旧文件路径名，newname表示新文件路径名。</span></span><br><span class="line"><span class="comment">// 在函数内部调用linkat系统调用函数，使用AT_FDCWD作为旧目录文件描述符和新目录文件描述符，</span></span><br><span class="line"><span class="comment">// 通过getname函数获取旧文件路径名和新文件路径名，并将链接选项设置为0。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* vfs_rename - 重命名一个文件系统对象 </span></span><br><span class="line"><span class="comment">* @rd: 指向重命名信息的renamedata结构体指针</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 调用者必须持有多个互斥锁 - 参见lock_rename()。</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* 如果vfs_rename在源目录或目标目录发现需要破坏的委托,</span></span><br><span class="line"><span class="comment">* 它将返回-EWOULDBLOCK并返回delegated_inode中的一个inode引用。</span></span><br><span class="line"><span class="comment">* 调用者应该断开委托并重试。由于断开委托可能需要很长时间,</span></span><br><span class="line"><span class="comment">* 调用者应该在此之前释放所有锁。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 或者,调用者可以为delegated_inode传入NULL。</span></span><br><span class="line"><span class="comment">* 这可能适合预期底层文件系统没有NFS导出的调用者。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 命名空间操作中最糟糕的是重命名目录。“不正当”甚至无法开始描述它。</span></span><br><span class="line"><span class="comment">* 加州大学伯克利分校的某人trip了一场......问题:</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*  a) 我们可能进入循环创建。</span></span><br><span class="line"><span class="comment">*  b) 竞争风险 - 两个无辜的重命名可以一起创建一个循环。</span></span><br><span class="line"><span class="comment">*     这就是4.4出错的地方。 当前修复: 在sb-&gt;s_vfs_rename_mutex上序列化。</span></span><br><span class="line"><span class="comment">*     我们可能会更准确,但那是另一个故事。</span></span><br><span class="line"><span class="comment">*  c) 我们必须锁定四个对象 – 父目录和受害者(如果存在),</span></span><br><span class="line"><span class="comment">*     以及源(如果它不是一个目录)。</span></span><br><span class="line"><span class="comment">*     而且 - 在我们对父目录获取-&gt;i_mutex之后(直到然后我们不知道目标是否存在)。</span></span><br><span class="line"><span class="comment">*     解决方案: 尝试通过锁定顺序来智能锁定节点。 我们依赖这样的事实:</span></span><br><span class="line"><span class="comment">*     仅在-&gt;s_vfs_rename_mutex下才能改变树拓扑,_and_ 对象的父目录我们移动将被锁定。</span></span><br><span class="line"><span class="comment">*     这样,我们可以通过树(先祖先)对目录进行排名,并在它们之后排名所有非目录。</span></span><br><span class="line"><span class="comment">*     这有效,因为除了重命名之外的所有对象都“锁定父目录,查找,锁定子目录”,</span></span><br><span class="line"><span class="comment">*     而重命名在-&gt;s_vfs_rename_mutex下。</span></span><br><span class="line"><span class="comment">*     然而,它依赖于这样的假设:任何具有-&gt;lookup()的对象都不会有多个dentry。</span></span><br><span class="line"><span class="comment">*     如果“混合”对象出现,我们最好确保它们没有链接(2)。</span></span><br><span class="line"><span class="comment">*  d) 从fhandle转换为dentry可能在错误的时刻到来 - 当我们删除目标时。</span></span><br><span class="line"><span class="comment">*     解决方案:我们将不得不在fhandle_to_dentry代码中获取-&gt;i_mutex。</span></span><br><span class="line"><span class="comment">*     [FIXME - 当前的nfsfh.c依赖于父-&gt;i_mutex,这有效但导致一些非常过度的锁定]。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vfs_rename</span><span class="params">(<span class="keyword">struct</span> renamedata *rd)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 声明错误码</span></span><br><span class="line">   <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明老目录和新目录的inode指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">old_dir</span> =</span> rd-&gt;old_dir, *new_dir = rd-&gt;new_dir;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 声明老目录项和新目录项的dentry指针 </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">old_dentry</span> =</span> rd-&gt;old_dentry;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">new_dentry</span> =</span> rd-&gt;new_dentry;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 委托inode指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> **<span class="title">delegated_inode</span> =</span> rd-&gt;delegated_inode;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标志</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> flags = rd-&gt;flags;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 老目录项是否是目录</span></span><br><span class="line">   <span class="type">bool</span> is_dir = d_is_dir(old_dentry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 老目录项对应的inode</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">source</span> =</span> old_dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 新目录项对应的inode  </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">target</span> =</span> new_dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 新目录项是否是目录</span></span><br><span class="line"></span><br><span class="line">   <span class="type">bool</span> new_is_dir = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最大链接数</span></span><br><span class="line">   <span class="type">unsigned</span> max_links = new_dir-&gt;i_sb-&gt;s_max_links;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 老目录项名称快照</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">name_snapshot</span> <span class="title">old_name</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果源和目标是同一个inode,返回0</span></span><br><span class="line">   <span class="keyword">if</span> (source == target)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查删除老目录项的权限</span></span><br><span class="line">   error = may_delete(rd-&gt;old_mnt_idmap, old_dir, old_dentry, is_dir);</span><br><span class="line">   <span class="keyword">if</span> (error)</span><br><span class="line">       <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果目标目录项不存在,检查新建目录项的权限</span></span><br><span class="line">   <span class="keyword">if</span> (!target) &#123;</span><br><span class="line">       error = may_create(rd-&gt;new_mnt_idmap, new_dir, new_dentry);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 目标目录项是否是目录</span></span><br><span class="line">       new_is_dir = d_is_dir(new_dentry);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果不是交换重命名,检查删除目标目录项的权限</span></span><br><span class="line">       <span class="keyword">if</span> (!(flags &amp; RENAME_EXCHANGE))</span><br><span class="line">           error = may_delete(rd-&gt;new_mnt_idmap, new_dir,</span><br><span class="line">                      new_dentry, is_dir);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">// 如果是交换重命名,检查删除新目录项的权限</span></span><br><span class="line">           error = may_delete(rd-&gt;new_mnt_idmap, new_dir,</span><br><span class="line">                      new_dentry, new_is_dir);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (error)</span><br><span class="line">       <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查老目录inode是否支持重命名操作</span></span><br><span class="line">   <span class="keyword">if</span> (!old_dir-&gt;i_op-&gt;rename)</span><br><span class="line">       <span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果更改父目录,检查写权限,需要翻转“..”</span></span><br><span class="line">   <span class="keyword">if</span> (new_dir != old_dir) &#123;</span><br><span class="line">       <span class="keyword">if</span> (is_dir) &#123;</span><br><span class="line">           <span class="comment">// 如果源是目录,检查写权限</span></span><br><span class="line">           error = inode_permission(rd-&gt;old_mnt_idmap, source,</span><br><span class="line">                        MAY_WRITE);</span><br><span class="line">           <span class="keyword">if</span> (error)</span><br><span class="line">               <span class="keyword">return</span> error;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((flags &amp; RENAME_EXCHANGE) &amp;&amp; new_is_dir) &#123;</span><br><span class="line">           <span class="comment">// 如果交换重命名且新目录项是目录,检查目标写权限</span></span><br><span class="line">           error = inode_permission(rd-&gt;new_mnt_idmap, target,</span><br><span class="line">                        MAY_WRITE);</span><br><span class="line">           <span class="keyword">if</span> (error)</span><br><span class="line">               <span class="keyword">return</span> error;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 安全检查</span></span><br><span class="line">   error = security_inode_rename(...);</span><br><span class="line">   <span class="keyword">if</span> (error)</span><br><span class="line">       <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取老目录项名称快照</span></span><br><span class="line">   take_dentry_name_snapshot(&amp;old_name, old_dentry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 增加新目录项引用计数</span></span><br><span class="line">   dget(new_dentry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 加锁</span></span><br><span class="line">   <span class="keyword">if</span> (!is_dir || (flags &amp; RENAME_EXCHANGE))</span><br><span class="line">       lock_two_nondirectories(source, target);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (target)</span><br><span class="line">       inode_lock(target);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 权限检查</span></span><br><span class="line">   error = -EPERM;</span><br><span class="line">   <span class="keyword">if</span> (IS_SWAPFILE(source) || (target &amp;&amp; IS_SWAPFILE(target)))</span><br><span class="line">       <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查挂载点</span></span><br><span class="line">   error = -EBUSY;</span><br><span class="line">   <span class="keyword">if</span> (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))</span><br><span class="line">       <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查最大链接数</span></span><br><span class="line">   <span class="keyword">if</span> (max_links &amp;&amp; new_dir != old_dir) &#123;</span><br><span class="line">       error = -EMLINK;</span><br><span class="line">       <span class="keyword">if</span> (is_dir &amp;&amp; !new_is_dir &amp;&amp; new_dir-&gt;i_nlink &gt;= max_links)</span><br><span class="line">           <span class="keyword">goto</span> out;</span><br><span class="line">       <span class="keyword">if</span> ((flags &amp; RENAME_EXCHANGE) &amp;&amp; !is_dir &amp;&amp; new_is_dir &amp;&amp;</span><br><span class="line">           old_dir-&gt;i_nlink &gt;= max_links)</span><br><span class="line">           <span class="keyword">goto</span> out;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 尝试中断委托</span></span><br><span class="line">   <span class="keyword">if</span> (!is_dir) &#123;</span><br><span class="line">       error = try_break_deleg(source, delegated_inode);</span><br><span class="line">       <span class="keyword">if</span> (error)</span><br><span class="line">           <span class="keyword">goto</span> out;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (target &amp;&amp; !new_is_dir) &#123;</span><br><span class="line">       error = try_break_deleg(target, delegated_inode);</span><br><span class="line">       <span class="keyword">if</span> (error)</span><br><span class="line">           <span class="keyword">goto</span> out;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用目录inode的重命名方法</span></span><br><span class="line">   error = old_dir-&gt;i_op-&gt;rename(rd-&gt;new_mnt_idmap, old_dir, old_dentry,</span><br><span class="line">                 new_dir, new_dentry, flags);</span><br><span class="line">   <span class="keyword">if</span> (error)</span><br><span class="line">       <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是交换重命名且目标目录项存在</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; RENAME_EXCHANGE) &amp;&amp; target) &#123;</span><br><span class="line">    <span class="comment">// 如果源是目录</span></span><br><span class="line">    <span class="keyword">if</span> (is_dir) &#123;</span><br><span class="line">       <span class="comment">// 缩小新目录项的dcache</span></span><br><span class="line">    shrink_dcache_parent(new_dentry);</span><br><span class="line">       <span class="comment">// 标记目标inode已死</span></span><br><span class="line">       target-&gt;i_flags |= S_DEAD;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 禁止在新目录项挂载</span></span><br><span class="line">   dont_mount(new_dentry);</span><br><span class="line">   <span class="comment">// 分离新目录项的挂载</span></span><br><span class="line">   detach_mounts(new_dentry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果文件系统不支持d_move</span></span><br><span class="line"><span class="keyword">if</span> (!(old_dir-&gt;i_sb-&gt;s_type-&gt;fs_flags &amp; FS_RENAME_DOES_D_MOVE)) &#123;</span><br><span class="line">   <span class="comment">// 如果不是交换重命名</span></span><br><span class="line">   <span class="keyword">if</span> (!(flags &amp; RENAME_EXCHANGE))</span><br><span class="line">       <span class="comment">// 移动老目录项到新目录项</span></span><br><span class="line">       d_move(old_dentry, new_dentry);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       <span class="comment">// 交换两个目录项</span></span><br><span class="line">       d_exchange(old_dentry, new_dentry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (!is_dir || (flags &amp; RENAME_EXCHANGE))</span><br><span class="line">   unlock_two_nondirectories(source, target);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (target)</span><br><span class="line">   inode_unlock(target);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少新目录项的引用计数    </span></span><br><span class="line">dput(new_dentry);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">   <span class="comment">// 发送目录项移动事件通知</span></span><br><span class="line">   fsnotify_move(old_dir, new_dir, &amp;old_name.name, is_dir,</span><br><span class="line">            !(flags &amp; RENAME_EXCHANGE) ? target : <span class="literal">NULL</span>, old_dentry);</span><br><span class="line">   <span class="keyword">if</span> (flags &amp; RENAME_EXCHANGE) &#123;</span><br><span class="line">       <span class="comment">// 如果是交换重命名,交换事件通知参数</span></span><br><span class="line">       fsnotify_move(new_dir, old_dir, &amp;old_dentry-&gt;d_name,</span><br><span class="line">                new_is_dir, <span class="literal">NULL</span>, new_dentry);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放老目录项名称快照</span></span><br><span class="line">release_dentry_name_snapshot(&amp;old_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回错误码</span></span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* do_renameat2 - 实现重命名系统调用renameat2</span></span><br><span class="line"><span class="comment">* @olddfd: 源文件目录文件描述符</span></span><br><span class="line"><span class="comment">* @from: 源文件名</span></span><br><span class="line"><span class="comment">* @newdfd: 目标文件目录文件描述符 </span></span><br><span class="line"><span class="comment">* @to: 目标文件名</span></span><br><span class="line"><span class="comment">* @flags: 标志位</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 返回值:</span></span><br><span class="line"><span class="comment">*   0 - 成功</span></span><br><span class="line"><span class="comment">*   负值 - 错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_renameat2</span><span class="params">(<span class="type">int</span> olddfd, <span class="keyword">struct</span> filename *from, <span class="type">int</span> newdfd,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> filename *to, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 重命名数据</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">renamedata</span> <span class="title">rd</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 源目录项和目标目录项</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">old_dentry</span>, *<span class="title">new_dentry</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 锁定时用于检测环的中间目录项</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">trap</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 源路径和目标路径</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_path</span>, <span class="title">new_path</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 源目录项和目标目录项最后一个component</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">old_last</span>, <span class="title">new_last</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 目录项类型</span></span><br><span class="line"> <span class="type">int</span> old_type, new_type;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 委托的inode</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 查找标志 </span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> lookup_flags = <span class="number">0</span>, target_flags = LOOKUP_RENAME_TARGET;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 是否需要重试标志</span></span><br><span class="line"> <span class="type">bool</span> should_retry = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> error = -EINVAL;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 参数检查</span></span><br><span class="line"> <span class="keyword">if</span> (flags &amp; ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))</span><br><span class="line">   <span class="keyword">goto</span> put_names;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> ((flags &amp; (RENAME_NOREPLACE | RENAME_WHITEOUT)) &amp;&amp;</span><br><span class="line">     (flags &amp; RENAME_EXCHANGE))</span><br><span class="line">   <span class="keyword">goto</span> put_names;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (flags &amp; RENAME_EXCHANGE)</span><br><span class="line">   target_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取源文件路径</span></span><br><span class="line"> error = filename_parentat(olddfd, from, lookup_flags, &amp;old_path,</span><br><span class="line">               &amp;old_last, &amp;old_type);</span><br><span class="line"> <span class="keyword">if</span> (error)  </span><br><span class="line">   <span class="keyword">goto</span> put_names;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取目标文件路径  </span></span><br><span class="line"> error = filename_parentat(newdfd, to, lookup_flags, &amp;new_path, &amp;new_last,</span><br><span class="line">               &amp;new_type);</span><br><span class="line"> <span class="keyword">if</span> (error)</span><br><span class="line">   <span class="keyword">goto</span> exit1;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 不同文件系统  </span></span><br><span class="line"> error = -EXDEV;</span><br><span class="line"> <span class="keyword">if</span> (old_path.mnt != new_path.mnt)</span><br><span class="line">   <span class="keyword">goto</span> exit2;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 源文件类型错误</span></span><br><span class="line"> error = -EBUSY;</span><br><span class="line"> <span class="keyword">if</span> (old_type != LAST_NORM)  </span><br><span class="line">   <span class="keyword">goto</span> exit2;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 目标已存在,不能覆盖</span></span><br><span class="line"> <span class="keyword">if</span> (flags &amp; RENAME_NOREPLACE)</span><br><span class="line">   error = -EEXIST;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (new_type != LAST_NORM)</span><br><span class="line">   <span class="keyword">goto</span> exit2;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 获取写权限</span></span><br><span class="line"> error = mnt_want_write(old_path.mnt);</span><br><span class="line"> <span class="keyword">if</span> (error)</span><br><span class="line">   <span class="keyword">goto</span> exit2;</span><br><span class="line"></span><br><span class="line">retry_deleg:</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加锁</span></span><br><span class="line"> trap = lock_rename(new_path.dentry, old_path.dentry);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 查找源目录项</span></span><br><span class="line"> old_dentry = __lookup_hash(&amp;old_last, old_path.dentry, lookup_flags);</span><br><span class="line"> error = PTR_ERR(old_dentry);</span><br><span class="line"> <span class="keyword">if</span> (IS_ERR(old_dentry))</span><br><span class="line">   <span class="keyword">goto</span> exit3;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 源目录项必须存在</span></span><br><span class="line"> error = -ENOENT;</span><br><span class="line"> <span class="keyword">if</span> (d_is_negative(old_dentry))  </span><br><span class="line">   <span class="keyword">goto</span> exit4;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 查找目标目录项</span></span><br><span class="line"> new_dentry = __lookup_hash(&amp;new_last, new_path.dentry, lookup_flags | target_flags);</span><br><span class="line"> error = PTR_ERR(new_dentry);</span><br><span class="line"> <span class="keyword">if</span> (IS_ERR(new_dentry))</span><br><span class="line">   <span class="keyword">goto</span> exit4;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 目标已存在,不能覆盖</span></span><br><span class="line"> error = -EEXIST;</span><br><span class="line"> <span class="keyword">if</span> ((flags &amp; RENAME_NOREPLACE) &amp;&amp; d_is_positive(new_dentry))</span><br><span class="line">   <span class="keyword">goto</span> exit5;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 类型检查</span></span><br><span class="line"> <span class="keyword">if</span> (flags &amp; RENAME_EXCHANGE) &#123;</span><br><span class="line">   error = -ENOENT;</span><br><span class="line">   <span class="keyword">if</span> (d_is_negative(new_dentry))</span><br><span class="line">     <span class="keyword">goto</span> exit5;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!d_is_dir(new_dentry)) &#123;</span><br><span class="line">     error = -ENOTDIR;</span><br><span class="line">     <span class="keyword">if</span> (new_last.name[new_last.len])  </span><br><span class="line">   <span class="keyword">goto</span> exit5;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 安全检查</span></span><br><span class="line"> error = security_path_rename(&amp;old_path, old_dentry,</span><br><span class="line">                  &amp;new_path, new_dentry, flags);</span><br><span class="line"> <span class="keyword">if</span> (error)  </span><br><span class="line">   <span class="keyword">goto</span> exit5;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 准备重命名数据</span></span><br><span class="line"> rd.old_dir     = old_path.dentry-&gt;d_inode;</span><br><span class="line"> rd.old_dentry    = old_dentry;</span><br><span class="line"> rd.old_mnt_idmap = mnt_idmap(old_path.mnt);</span><br><span class="line"> rd.new_dir     = new_path.dentry-&gt;d_inode;</span><br><span class="line"> rd.new_dentry    = new_dentry;</span><br><span class="line"> rd.new_mnt_idmap = mnt_idmap(new_path.mnt);</span><br><span class="line"> rd.delegated_inode = &amp;delegated_inode; </span><br><span class="line"> rd.flags       = flags;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 执行重命名  </span></span><br><span class="line"> error = vfs_rename(&amp;rd);</span><br><span class="line"></span><br><span class="line">exit5:</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 释放资源</span></span><br><span class="line">exit5:</span><br><span class="line">    dput(new_dentry);</span><br><span class="line">exit4:</span><br><span class="line">    dput(old_dentry);</span><br><span class="line">exit3:</span><br><span class="line">    unlock_rename(new_path.dentry, old_path.dentry);</span><br><span class="line">    <span class="keyword">if</span> (delegated_inode) &#123;</span><br><span class="line">        error = break_deleg_wait(&amp;delegated_inode);</span><br><span class="line">        <span class="keyword">if</span> (!error)</span><br><span class="line">            <span class="keyword">goto</span> retry_deleg;</span><br><span class="line">    &#125;</span><br><span class="line">    mnt_drop_write(old_path.mnt);</span><br><span class="line">exit2:</span><br><span class="line">    <span class="keyword">if</span> (retry_estale(error, lookup_flags))</span><br><span class="line">        should_retry = <span class="literal">true</span>;</span><br><span class="line">    path_put(&amp;new_path);</span><br><span class="line">exit1:</span><br><span class="line">    path_put(&amp;old_path);</span><br><span class="line">    <span class="keyword">if</span> (should_retry) &#123;</span><br><span class="line">        should_retry = <span class="literal">false</span>;</span><br><span class="line">        lookup_flags |= LOOKUP_REVAL;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">put_names:</span><br><span class="line">    putname(from);</span><br><span class="line">    putname(to);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// renameat2系统调用实现</span></span><br><span class="line">SYSCALL_DEFINE5(renameat2, <span class="type">int</span>, olddfd, <span class="type">const</span> <span class="type">char</span> __user *, oldname,</span><br><span class="line">   <span class="type">int</span>, newdfd, <span class="type">const</span> <span class="type">char</span> __user *, newname, <span class="type">unsigned</span> <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 调用do_renameat2实现重命名并返回结果</span></span><br><span class="line"> <span class="keyword">return</span> do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),</span><br><span class="line">           flags); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// renameat系统调用实现</span></span><br><span class="line">SYSCALL_DEFINE4(renameat, <span class="type">int</span>, olddfd, <span class="type">const</span> <span class="type">char</span> __user *, oldname,</span><br><span class="line">   <span class="type">int</span>, newdfd, <span class="type">const</span> <span class="type">char</span> __user *, newname)  </span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 调用do_renameat2实现重命名, flags为0</span></span><br><span class="line"> <span class="keyword">return</span> do_renameat2(olddfd, getname(oldname), newdfd, getname(newname),</span><br><span class="line">              <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rename系统调用实现</span></span><br><span class="line">SYSCALL_DEFINE2(rename, <span class="type">const</span> <span class="type">char</span> __user *, oldname, </span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> __user *, newname)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 调用do_renameat2实现重命名, dfd为默认目录,flags为0 </span></span><br><span class="line"> <span class="keyword">return</span> do_renameat2(AT_FDCWD, getname(oldname), AT_FDCWD,</span><br><span class="line">          getname(newname), <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">renameat2/renameat/rename系统调用都是利用do_renameat2函数实现文件重命名功能,主要区别在于:</span><br><span class="line"></span><br><span class="line">- renameat2可以指定标志位来控制重命名行为</span><br><span class="line">- renameat可以指定源目录文件描述符和目标目录文件描述符</span><br><span class="line">- rename使用当前工作目录和默认标志</span><br><span class="line"></span><br><span class="line">它们最终都通过do_renameat2统一实现了重命名文件的核心逻辑。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* readlink_copy - 将符号链接目标复制到用户空间缓冲区</span></span><br><span class="line"><span class="comment">* @buffer: 用户空间缓冲区指针</span></span><br><span class="line"><span class="comment">* @buflen: 缓冲区大小  </span></span><br><span class="line"><span class="comment">* @link: 符号链接目标字符串</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 返回值:</span></span><br><span class="line"><span class="comment">*   &gt;0 - 复制的字节数</span></span><br><span class="line"><span class="comment">*   负值 - 错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readlink_copy</span><span class="params">(<span class="type">char</span> __user *buffer, <span class="type">int</span> buflen, <span class="type">const</span> <span class="type">char</span> *link)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 获取符号链接目标字符串长度</span></span><br><span class="line">   <span class="type">int</span> len = PTR_ERR(link);</span><br><span class="line">   <span class="keyword">if</span> (IS_ERR(link))</span><br><span class="line">       <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 计算字符串长度 </span></span><br><span class="line">   len = <span class="built_in">strlen</span>(link);</span><br><span class="line">   <span class="keyword">if</span> (len &gt; (<span class="type">unsigned</span>) buflen)</span><br><span class="line">       len = buflen;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 复制到用户空间    </span></span><br><span class="line">   <span class="keyword">if</span> (copy_to_user(buffer, link, len))</span><br><span class="line">       len = -EFAULT;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">   <span class="comment">// 返回复制的字节数</span></span><br><span class="line">   <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* vfs_readlink - 将符号链接目标复制到用户空间缓冲区</span></span><br><span class="line"><span class="comment">* @dentry: 符号链接dentry</span></span><br><span class="line"><span class="comment">* @buffer: 用户空间缓冲区指针</span></span><br><span class="line"><span class="comment">* @buflen: 缓冲区大小</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 不更新访问时间。调用者如果需要的话可以更新。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 不调用安全钩子。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_readlink</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="type">char</span> __user *buffer, <span class="type">int</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 获取符号链接对应的inode</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> d_inode(dentry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 延迟调用结构体</span></span><br><span class="line">   DEFINE_DELAYED_CALL(done);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 符号链接目标字符串    </span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *link;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查inode操作</span></span><br><span class="line">   <span class="keyword">if</span> (unlikely(!(inode-&gt;i_opflags &amp; IOP_DEFAULT_READLINK))) &#123;</span><br><span class="line">       <span class="comment">// 自定义readlink回调</span></span><br><span class="line">       <span class="keyword">if</span> (unlikely(inode-&gt;i_op-&gt;readlink))</span><br><span class="line">           <span class="keyword">return</span> inode-&gt;i_op-&gt;readlink(dentry, buffer, buflen);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 不是符号链接</span></span><br><span class="line">       <span class="keyword">if</span> (!d_is_symlink(dentry))</span><br><span class="line">           <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置默认readlink标志</span></span><br><span class="line">       spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">       inode-&gt;i_opflags |= IOP_DEFAULT_READLINK;</span><br><span class="line">       spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取符号链接目标字符串</span></span><br><span class="line">   link = READ_ONCE(inode-&gt;i_link);</span><br><span class="line">   <span class="keyword">if</span> (!link) &#123;</span><br><span class="line">       link = inode-&gt;i_op-&gt;get_link(dentry, inode, &amp;done);</span><br><span class="line">       <span class="keyword">if</span> (IS_ERR(link))</span><br><span class="line">           <span class="keyword">return</span> PTR_ERR(link);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 复制到用户空间</span></span><br><span class="line">   res = readlink_copy(buffer, buflen, link);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 延迟调用</span></span><br><span class="line">   do_delayed_call(&amp;done);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_readlink);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* vfs_get_link - 获取符号链接目标字符串 </span></span><br><span class="line"><span class="comment">* @dentry: 符号链接dentry</span></span><br><span class="line"><span class="comment">* @done: 调用者需要用此释放返回的数据</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 调用安全钩子和i_op-&gt;get_link()。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 不更新访问时间。调用者如果需要可以更新。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 不适用于特殊符号链接,如/proc/$$/fd/N。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">vfs_get_link</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> delayed_call *done)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 默认为错误</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *res = ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取符号链接对应inode</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> d_inode(dentry);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果是符号链接</span></span><br><span class="line">   <span class="keyword">if</span> (d_is_symlink(dentry)) &#123;</span><br><span class="line">       <span class="comment">// 调用安全钩子</span></span><br><span class="line">       res = ERR_PTR(security_inode_readlink(dentry));</span><br><span class="line">       <span class="keyword">if</span> (!res)</span><br><span class="line">           <span class="comment">// 调用get_link回调获取目标字符串</span></span><br><span class="line">           res = inode-&gt;i_op-&gt;get_link(dentry, inode, done); </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(vfs_get_link);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* page_get_link - 将符号链接内容读入页面缓存</span></span><br><span class="line"><span class="comment">* @dentry: 符号链接对应的dentry</span></span><br><span class="line"><span class="comment">* @inode:  符号链接对应的inode</span></span><br><span class="line"><span class="comment">* @callback: 延迟调用回调函数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 返回值: 符号链接内容的内核空间地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">page_get_link</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> delayed_call *callback)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> *kaddr;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> inode-&gt;i_mapping;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!dentry) &#123;</span><br><span class="line">       <span class="comment">// 没有dentry,则分配新页</span></span><br><span class="line">       page = find_get_page(mapping, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (!page)</span><br><span class="line">           <span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line">       <span class="keyword">if</span> (!PageUptodate(page)) &#123;</span><br><span class="line">           put_page(page);</span><br><span class="line">           <span class="keyword">return</span> ERR_PTR(-ECHILD);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 有dentry,则直接读取第一页</span></span><br><span class="line">       page = read_mapping_page(mapping, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">       <span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">           <span class="keyword">return</span> (<span class="type">char</span>*)page;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置页面释放的延迟调用</span></span><br><span class="line">   set_delayed_call(callback, page_put_link, page);</span><br><span class="line">   BUG_ON(mapping_gfp_mask(mapping) &amp; __GFP_HIGHMEM);</span><br><span class="line">   <span class="comment">// 获取页面对应的内核虚拟地址</span></span><br><span class="line">   kaddr = page_address(page);</span><br><span class="line">   <span class="comment">// 处理符号链接内容</span></span><br><span class="line">   nd_terminate_link(kaddr, inode-&gt;i_size, PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> kaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(page_get_link);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* page_put_link - 释放页面</span></span><br><span class="line"><span class="comment">* @arg: 要释放的页面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_put_link</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">   put_page(arg);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(page_put_link);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* page_readlink - 使用页面缓存读取符号链接内容</span></span><br><span class="line"><span class="comment">* @dentry: 符号链接对应的dentry</span></span><br><span class="line"><span class="comment">* @buffer: 用户空间缓冲区</span></span><br><span class="line"><span class="comment">* @buflen: 缓冲区长度</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 返回值:复制的字节数或错误码</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="type">int</span> <span class="title function_">page_readlink</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="type">char</span> __user *buffer, <span class="type">int</span> buflen)</span></span><br><span class="line">&#123;</span><br><span class="line">   DEFINE_DELAYED_CALL(done);</span><br><span class="line">   <span class="type">int</span> res = readlink_copy(buffer, buflen,</span><br><span class="line">               page_get_link(dentry, d_inode(dentry),</span><br><span class="line">                         &amp;done));</span><br><span class="line">   do_delayed_call(&amp;done);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(page_readlink);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* page_symlink - 用页面缓存创建符号链接</span></span><br><span class="line"><span class="comment">* @inode: 符号链接对应的inode</span></span><br><span class="line"><span class="comment">* @symname: 符号链接内容</span></span><br><span class="line"><span class="comment">* @len: 内容长度</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 返回值:0 或 错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">page_symlink</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">const</span> <span class="type">char</span> *symname, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 获得地址空间</span></span><br><span class="line">   <span class="comment">// 写入符号链接内容</span></span><br><span class="line">   <span class="comment">// 写入结束</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 标记inode已脏</span></span><br><span class="line">   mark_inode_dirty(inode);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(page_symlink);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* page_symlink_inode_operations - 使用页面缓存的符号链接inode操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">page_symlink_inode_operations</span> =</span> &#123;</span><br><span class="line">   .get_link    = page_get_link,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(page_symlink_inode_operations);</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/18/%E5%AD%A6%E4%B9%A0-Linux-VFS%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%20dentry%E8%AF%A6%E8%A7%A3%E5%92%8Cdcache%E5%AE%9E%E7%8E%B0/" rel="prev" title="学习 Linux VFS虚拟文件系统 dentry详解和dcache实现">
      <i class="fa fa-chevron-left"></i> 学习 Linux VFS虚拟文件系统 dentry详解和dcache实现
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/13/%E5%AD%A6%E4%B9%A0-Linux-fs-dcache-c%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="next" title="学习 Linux /fs/dcache.c源码分析">
      学习 Linux /fs/dcache.c源码分析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plucky</p>
  <div class="site-description" itemprop="description">记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Plucky923" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Plucky923" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:p1ucky@163.com" title="E-Mail → mailto:p1ucky@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plucky</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.5m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">44:31</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '3420f2814bb4c3c82f84',
      clientSecret: '9d285617447c550188bd893fc3aad7c9b00f2d00',
      repo        : 'Blog-talk',
      owner       : 'Plucky923',
      admin       : ['Plucky923'],
      id          : '2eacce60d46fe0991828fd358f10575f',
        language: 'zh-CH',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
