<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="摘要 Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。 在本文中，我们首次系统地">
<meta property="og:type" content="article">
<meta property="og:title" content="论文阅读 Making Memory Account Accountable：Analyzing and Detecting Memory Missing account bugs for Container Platforms">
<meta property="og:url" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/index.html">
<meta property="og:site_name" content="Plucky">
<meta property="og:description" content="摘要 Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。 在本文中，我们首次系统地">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/attackKatacontainers.png">
<meta property="og:image" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/challenge.png">
<meta property="og:image" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/algorithm.png">
<meta property="og:image" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/recall.png">
<meta property="og:image" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bug.png">
<meta property="og:image" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bugs.png">
<meta property="article:published_time" content="2023-04-23T11:09:13.000Z">
<meta property="article:modified_time" content="2023-05-03T10:12:16.789Z">
<meta property="article:author" content="Plucky">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/attackKatacontainers.png">

<link rel="canonical" href="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>论文阅读 Making Memory Account Accountable：Analyzing and Detecting Memory Missing account bugs for Container Platforms | Plucky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Plucky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Comfortably Numb</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          论文阅读 Making Memory Account Accountable：Analyzing and Detecting Memory Missing account bugs for Container Platforms
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-23 19:09:13" itemprop="dateCreated datePublished" datetime="2023-04-23T19:09:13+08:00">2023-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-05-03 18:12:16" itemprop="dateModified" datetime="2023-05-03T18:12:16+08:00">2023-05-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文精读</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">内核安全</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>35 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>摘要</strong></p>
<p>Linux内核引入了memory control group(memcg)，用于在进程级对内存的使用进行记录和限制。memcg由于其灵活性和高效性，被容器平台广泛采用，成为一种基础技术。虽然内存记帐很重要，但由于内存记帐接口的多样性和大量的分配&#x2F;空闲路径，它很容易出现记账的错误。据我们所知，目前还没有针对内存帐户丢失问题的系统分析，包括其安全影响、检测等。</p>
<p>在本文中，我们首次系统地研究了内存记账缺失问题。我们首先对其在容器平台上的可利用性和安全性影响进行了深入分析。然后我们开发了一个名为MANTA(Memory Accounting Analyzer)的工具，它结合了静态和动态分析技术来自动检测和验证内存丢失帐户错误。</p>
<p>我们的分析表明，所有的容器运行时，包括runC和Kata容器，都容易受到基于内存记账缺失的攻击。此外，内存记账缺失可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而使单个节点甚至整个集群崩溃。我们的工具报告了53个可利用的内存记账缺失漏洞，其中37个被内核开发者确认，并提交了相应的补丁，还有两个新的CVE被分配。通过深入分析、自动检测、报告的错误和提交的补丁，我们相信我们的研究提高了容器平台内存核算的正确性和安全性。</p>
<p><strong>CCS CONCEPTS</strong></p>
<ul>
<li>Security and privacy → Operating systems security; Virtualization and security</li>
</ul>
<p><strong>KEYWORDS</strong></p>
<p>Cloud infrastructure, Linux kernel, memory accounting, missingaccount, DoS attack</p>
<h1 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h1><p>计算和限制内存使用是每个操作系统内核的核心功能。特别是，Linux内核引入了内存控制组(memcg)，它可以在进程级别解释和限制内存使用。因此，与基于虚拟机(VM)的内存分区技术相比，memcg具有更细粒度和轻量级的特点。</p>
<p>由于其灵活性和高效性，memcg已经被容器平台广泛采用。众所周知，容器平台严重依赖资源共享来提高硬件资源的利用率。而memcg为容器在进程级别提供了唯一的内存使用记录和限制方法。因此，诸如Docker 、容器即服务平台（例如，OpenShift）和函数即服务平台（例如，OpenWhisk）等流行的容器平台，都采用memcg来控制其容器的内存使用。此外，基于虚拟机的容器运行时——Kata容器  也使用memcg来限制主机上的容器线程和其他服务线程的内存。此外，开放容器倡议（OCI）认证要求容器运行时必须使用memcg才能获得认证 。因此，memcg已经成为容器平台和云计算的基础技术。</p>
<p>不幸的是，尽管memcg被广泛使用，但由于其复杂性，它容易出错。具体来说，Linux内核选择将内存记账接口插入到内存分配&#x2F;释放路径中以实现记账，这可能由于高度复杂的内存使用和大量与内存使用相关的接口和代码路径，容易引入内存记账丢失错误（分配的内存未计入账户）。此外，即使记账接口位置正确，它们的记账行为也是有条件的，并受到记账标志的控制，我们发现这些标志经常缺失。因此，我们发现内存记账丢失错误很常见。</p>
<p>然而，即使memcg已经被广泛使用，其内存记账丢失漏洞从未得到系统分析。 memcg的现状是由两个原因造成的。首先，从来没有清楚地知道内存记账丢失漏洞会产生什么安全影响或者它们是否可利用。结果，记账丢失错误被内核开发人员忽略，并且没有特别努力消除这些问题。其次，没有自动检测内存记账丢失漏洞。正如之前讨论的那样，内存记帐设计和实现非常复杂，并深度集成到Linux kernel的复杂内存管理子系统中。因此，即使对于有经验的用户来说也很难正确理解记帐设计和策略。例如，我们发现Docker官方网站错误地声称“页面高速缓存的记忆费用在控制组之间分配”，并且“当一个cgroup终止时，它可能会增加另一个cgroup 的内存使用量“。因此，在没有自动检测的情况下手动推断记帐正确性几乎是不可能的更糟糕的是, 内存记账丢失是否可检测以及如何进行检测仍然是开放性问题。</p>
<p>本文首次对Linux内存记账丢失错误进行了系统分析和检测。我们首先进行了深入分析，以了解内存记账丢失错误在容器平台上的可利用性和安全影响。然后我们开发了一个名为MANTA（Memory AccouNTing Analyzer的简称）的工具，它结合了静态和动态分析技术来自动检测内存记账丢失错误。我们的分析显示，不仅普通容器运行时（如runC），而且安全容器运行时（如Kata容器）都容易受到由内存记账丢失错误引起的内存耗尽攻击。更糟糕的是，内存记账丢失错误可以被利用来攻击Docker、CaaS和FaaS平台，导致容器节点甚至整个集群崩溃。</p>
<p>由于memcg的复杂性，内存记账丢失检测面临两个挑战。首先，没有文档或现有研究定义了memcg使用的内存记账接口。现有的工作采用自然语言处理或包装函数分析来识别内存分配接口。然而，由于不匹配的启发式规则，这些技术无法直接应用于记账接口。为解决这个问题，MANTA提出了基于计数器的接口识别方法，自动检测所有与内存记账相关的接口。关键的观察是，所有内存记账接口最终都会在实现中增加&#x2F;减少相应的页面计数器。识别从页面计数器修改开始，迭代整个调用图以精确识别记账接口。</p>
<p>其次，分析内存分配和内存记账之间的映射具有挑战性。这种分析由于从内存分配位置到内存记账位置的深层和嵌套执行路径而变得复杂。它还需要跟踪分配的页面和计入账户的页面之间的数据流，以获得正确的别名集。此外，由于条件标志的控制，记账可能是有条件的。因此，MANTA提出了分配-消耗映射分析和记账标志分析来解决这个挑战。此外，为了验证检测到的内存记账丢失错误，MANTA进一步使用Linux测试项目来检查它们的可触发性和影响。</p>
<p>通过MANTA，我们检测并报告了memcg中的53个可利用错误，其中37个已经被内核开发人员确认并有已合并或待合并的补丁。报告的错误获得了两个新的CVE（一个正在等待）。总之，这项工作进行了深入调查，不仅分析了可利用性和影响，还系统地检测了内存记账丢失错误。我们相信，这些发现将有助于内核memcg开发人员在未来改进内存记账。本文做出了以下贡献。</p>
<ul>
<li><p>In-depth analysis of exploitability and impacts</p>
<p>我们设计了新的攻击来利用容器平台上的内存记账问题。我们的攻击表明，内存记账丢失漏洞可以很容易地被利用来攻击正常和安全的容器运行时(即runC和Kata容器)和流行的容器平台(即Docker, OpenShift和OpenWhisk)，导致容器节点甚至整个集群崩溃。</p>
</li>
<li><p>Automated detection with new techniques</p>
<p>我们提出了多种分析技术来有效地检测内存记账丢失错误，集成了静态分析和动态验证。我们实现了基于LLVM的检测，并使用Linux内存记账对其进行评估。我们进一步使用Linux Test Project (LTP)来验证检测到的错误的可触发性。</p>
</li>
<li><p>Community impact</p>
<p>我们在Linux v5.10中检测并报告了53个可利用的内存记账丢失错误，其中37个已被内核开发人员确认。分配了两个新的cve(一个正在等待)。我们的发现提高了内核社区对记账丢失的影响的认识，他们还邀请我们测试他们的下游内核。我们计划开源我们的检测工具，以进一步帮助社区提高内存计费的正确性和安全性。</p>
</li>
</ul>
<p>道德考虑：本文中的所有实验和攻击都是在一台专用的物理机器上进行的，这台机器仅由我们使用。我们负责任地向Linux内核开发人员披露了所有检测到的错误，并为所有经确认的错误提交了补丁。此外，我们还向Docker团队报告了关于内存记账的错误声明。</p>
<h1 id="BACKGROUD"><a href="#BACKGROUD" class="headerlink" title="BACKGROUD"></a>BACKGROUD</h1><h2 id="Linux-Memory-Accounting"><a href="#Linux-Memory-Accounting" class="headerlink" title="Linux Memory Accounting"></a>Linux Memory Accounting</h2><p>内存记帐是每个现代操作系统内核的核心功能。目前Linux内核采用内存控制组(memory control group, memcg)来实现内存计费。Memcg包含4种类型的内存:user、kernel、swap，and socket。</p>
<ul>
<li><p>user 记录所有用户空间内存页</p>
</li>
<li><p>kernel 记录内核空间内存页和对象</p>
</li>
<li><p>swap 记录交换区页面</p>
</li>
<li><p>socket 记录socket内存</p>
</li>
</ul>
<p>Memcg仅对用户空间进程的内存进行记账，并跳过对内核守护程序或内部内存使用的记账。需要注意的是，Linux内核v5.9引入了对象cgroup，它会对子页面内核内存使用（如内核对象）进行记账。对象cgroup可以将对象分配到不同的cgroups中，从而消除每个memcg的slab（内存分配池），节省大量的slab内存。</p>
<ul>
<li><p>Accounting：Linux内核针对不同类型的内存使用不同的记账接口。具体来说，Linux内核使用<code>mem_cgroup_charge</code>对用户和交换内存进行记账，使用<code>__memcg_kmem_charge</code>对内核内存进行记账。对于内核内存，Linux内核还要求在内存分配过程中设置<code>__GFP_ACCOUNT</code>标志以对内核页面进行记账。用户可以通过文件接口与memcg进行交互。例如，用户可以从<code>memory.usage_in_bytes</code>检查总内存使用情况。</p>
<p>一个memcg实例可能包含多个内存使用情况在其中进行记账的进程。memcg以树形层次结构组织，因此父节点上的内存限制也会影响所有子节点。memcg有两个版本：v1和v2。它们的主要区别在于层次结构和用户接口，而在记账方面的实现大致相同。目前两者都在使用。本文提到的是cgroups v1，大多数结论也适用于cgroups v2。</p>
</li>
<li><p>数据结构：memcg的核心数据结构是<code>mem_cgroup</code>，它代表一个memcg实例。memcg包含4个页面计数器，对应于之前讨论的4种类型的已记账内存。每个页面计数器使用<code>usage</code>（第14行）来计算分配的页面数量。同时，总内存限制（以页面为单位）设置在<code>max</code>（第16行）。在内存充电时，Linux内核调用消耗接口，依次调用<code>page_counter_try_charge</code>，这是一个计算总使用量（第24行）并将其与最大限制（第25行）进行检查的函数。</p>
</li>
<li><p>Accounting challenges：由于Linux内核中众多的内存分配接口和庞大的分配路径，正确地对Linux内核中的内存使用情况进行记账非常具有挑战性。很难调解所有内存分配路径，因此当前的记账机制容易出错。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">memory</span>;</span><span class="comment">/*Both v1 &amp; v2*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">swap</span>;</span><span class="comment">/*v2 only */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">memsw</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/*Legacy consumer-oriented counters*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">kmem</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> <span class="title">tcpmem</span>;</span><span class="comment">/*v1 only*/</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span>&#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> usage;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> max;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">page_counter_try_charge</span><span class="params">(<span class="keyword">struct</span> page_counter *counter,<span class="type">unsigned</span> <span class="type">long</span> nr pages,...)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">c</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    new = atomic_long_add_return(nr_pages, &amp;c-&gt;usage);</span><br><span class="line"><span class="keyword">if</span>(new&gt;c-&gt;max)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">goto</span> failed;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Container-Runtimes-and-Platforms"><a href="#Container-Runtimes-and-Platforms" class="headerlink" title="Container Runtimes and Platforms"></a>Container Runtimes and Platforms</h2><p>Memcg可以记录和限制每个进程级别的内存使用情况。与基于虚拟机(VM)的内存控制技术相比，memcg粒度更细、更轻、更灵活。因此，memcg已经被Docker、CaaS (container -as- service)和FaaS (function -as- service)平台广泛采用。具体来说，CaaS平台为用户提供了已配置的容器实例。CaaS平台上的用户可以使用自定义的容器映像创建&#x2F;启动&#x2F;停止&#x2F;删除容器。另一方面，FaaS平台不向用户提供容器实例，而是允许用户输入函数和触发规则，并自动创建容器实例来执行输入函数。</p>
<p>Docker和CaaS&#x2F;FaaS平台通常为容器实例使用本地容器运行时(即runC)。为了提高容器之间的隔离性，人们提出了安全容器运行时，如gVisor和Kata容器。gVisor是谷歌开发的沙盒容器运行时。它在一个名为Sentry的用户空间内核上运行每个容器。Sentry拦截并处理来自容器的大多数系统调用。因此，Sentry减少了从容器在主机内核上调用的系统调用。除了沙盒运行时，容器社区还建议使用虚拟化来隔离容器实例。其中一个这样的虚拟化容器运行时是Kata容器，其中每个容器实例都在微型虚拟机中运行，以实现强隔离。</p>
<p>我们的实验表明，正常和安全的容器运行时(包括runC和Kata容器)都容易受到由记账丢失错误引起的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致单个节点甚至整个集群崩溃。</p>
<h1 id="A-STUDY-OF-EXPLOITABLITY-AND-IMPACT"><a href="#A-STUDY-OF-EXPLOITABLITY-AND-IMPACT" class="headerlink" title="A STUDY OF EXPLOITABLITY AND IMPACT"></a>A STUDY OF EXPLOITABLITY AND IMPACT</h1><p>生产环境中内存未记录错误的影响从未被系统地研究过。它们通常被视为一个较小的正确性问题，而不是安全问题。在这一部分中，我们展示了内存未记录错误可以被利用来导致容器主机甚至整个云平台的内存耗尽。特别是，我们分析了内存记账问题的可利用性，以了解其对容器平台的实际影响。我们设计了新的攻击方法来利用未记录错误。这些攻击表明，这些错误可用于攻击普通和安全的容器运行时。因此，它们可被利用在热门的CaaS和FaaS容器平台上造成DoS（主机机器崩溃）和财务费用问题。在以下内容中，我们首先讨论威胁模型和假设。接下来，我们详细介绍如何利用内存未记录问题。</p>
<h2 id="Threat-Model-and-Assumptions"><a href="#Threat-Model-and-Assumptions" class="headerlink" title="Threat Model and Assumptions"></a>Threat Model and Assumptions</h2><p>在我们的实验中，我们研究了三个容器平台 - Docker、容器即服务（CaaS）平台和函数即服务（FaaS）平台。我们使用广泛部署的CaaS平台 - OpenShift作为我们的CaaS平台，以及流行的OpenWhisk作为我们的FaaS平台。这三个平台使用本地运行时（即runC）作为它们的容器运行时。这三个平台上的所有容器都以非特权方式设置为具有默认功能和seccomp配置。对于Docker和CaaS平台，用户可以通过云提供的接口创建和启动带有自定义映像的容器。这是合理的，因为包括AWS、Google Cloud和Azure在内的所有云供应商都为用户提供了一个控制台来管理容器实例。对于FaaS平台，用户可以定义、部署和触发函数，其中每个函数实例都在一个容器中运行。</p>
<p>攻击者是使用Docker、CaaS和FaaS平台的恶意用户。他&#x2F;她可以在非特权容器内执行任意代码。然而，容器的功能受到默认功能的限制。为了进一步限制攻击者，我们假设攻击者无法从容器中逃逸，也无法提升他们的权限。攻击者的目标是破坏内存计算的限制，并耗尽主机上的所有内存，以使其他容器、函数或主机崩溃。</p>
<p>对于攻击环境，我们在本地机器上设置Docker，同时在Google Cloud上设置OpenShift和OpenWhisk集群。出于道德考虑，该集群构建在一个由Google Cloud提供的专用裸金属服务器上，仅供我们使用，因此不会影响其他用户。</p>
<h2 id="Exploit-Missing-Account-Problem"><a href="#Exploit-Missing-Account-Problem" class="headerlink" title="Exploit Missing-Account Problem"></a>Exploit Missing-Account Problem</h2><p>在本节中，我们将设计新的攻击来利用内存记帐中的记账问题，以了解其影响。如前所述，Linux内核中的当前内存记帐将内存记帐接口放在内存分配路径上，将内存取消记帐接口放在内存空闲路径上。然而，Linux内存管理是复杂的，包含数千个内存分配和自由路径。很难用正确的接口来调解所有这些问题。特别是，很容易遗漏一个内存分配路径，从而导致丢失帐户问题。</p>
<p>显示了内核中信号量对象和信号量数组上的记账丢失错误，由MANTA检测并由Linux开发人员确认。函数<code>sem_alloc</code>分配一组信号量，并使用<code>sem_array</code>对它们进行索引。第8行的分配站点调用<code>kvzalloc</code>为<code>sem_array</code>和信号量分配内存。当在<code>kvzalloc</code>的第三个参数中设置了<code>__GFP_ACCOUNT</code>标志时，内核只会考虑分配的内存。然而，在第8行对<code>kvzalloc</code>的调用没有指定<code>__GFP_ACCOUNT</code>标志，导致在分配的信号量和<code>sem_array</code>上丢失帐户。此外，<code>sem_alloc</code>由<code>semget</code>系统调用调用来分配信号量。因此，这个记账丢失的错误很容易从用户空间触发。我们进一步设计了新的攻击，以表明上述漏洞可以被利用来打破容器内存限制并耗尽所有主机内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sem_array *<span class="title function_">sem_alloc</span><span class="params">(<span class="type">size_t</span> nsems)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nsems &gt; (INT_MAX - <span class="keyword">sizeof</span>(*sma)) / <span class="keyword">sizeof</span>(sma-&gt;sems[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    sma = kvzalloc(struct_size(sma, sems, nsems),GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(unlikerly(!sma))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Attacking-Docker"><a href="#Attacking-Docker" class="headerlink" title="Attacking Docker"></a>Attacking Docker</h3><p>我们用默认的功能和seccomp配置来设置Docker。semget系统调用不需要任何功能，也不会被容器seccomp配置文件阻塞。因此，在我们的实验中，攻击程序在非特权容器中可以反复触发semget系统调用，从而打破内存记帐限制，耗尽所有主机内存。主机甚至会因为内存不足错误而崩溃。我们向Linux社区报告了上述错误并提交了补丁。补丁已经被合并到Linux主线上，一个新的CVE已经分配给我们了。</p>
<h3 id="Attacking-the-CaaS-Platform"><a href="#Attacking-the-CaaS-Platform" class="headerlink" title="Attacking the CaaS Platform"></a>Attacking the CaaS Platform</h3><p>我们在Google Cloud上搭建了一个自管理的OpenShift集群，运行所有的GCP虚拟机实例。该集群允许用户在一个具有15GB内存和Linux内核v5.14.14的节点上创建容器。我们将容器的内存限制设置为128MB，这是公共云中常用的内存大小。</p>
<p>为了发起攻击，恶意用户以普通用户权限创建一个容器，并在容器内分配大量信号量。恶意容器的内存使用量迅速增加，大约在20秒内达到节点的极限。相比之下，攻击者的计费内存使用量非常低，不到1.4MB。结果，恶意容器打破了128MB的内存限制，消耗了主机上的全部15GB内存。同一节点上的受害者容器由于内存不足无法执行任何操作。</p>
<h3 id="Attacking-the-FaaS-Platform"><a href="#Attacking-the-FaaS-Platform" class="headerlink" title="Attacking the FaaS Platform"></a>Attacking the FaaS Platform</h3><p>我们评估了对OpenWhisk的攻击，OpenWhisk是一个流行的开源FaaS平台，作为IBM Cloud Functions的基础设施。集群节点内存为15GB，运行Linux内核v5.11.0-1021-gcp。每个功能的内存限制设置为128MB。</p>
<p>为了发起攻击，恶意用户创建了一个反复消耗信号量的函数。然后，恶意用户反复触发恶意功能。导致节点上的内存很快耗尽。注意，当一个节点的内存耗尽时，连续的恶意函数将被分派到其他节点。导致集群内所有节点的内存被恶意用户耗尽，导致集群级DoS。</p>
<h3 id="Attacking-the-Secure-Runtime"><a href="#Attacking-the-Secure-Runtime" class="headerlink" title="Attacking the Secure Runtime"></a>Attacking the Secure Runtime</h3><p>我们进一步设计新的攻击来评估内存记账丢失对安全运行时- Kata容器的影响。我们的实验表明，内存记账丢失漏洞允许攻击者打破Kata容器的隔离并攻击主机和其他容器实例。</p>
<p>Kata容器是一种虚拟容器运行时，其中每个容器实例在微虚拟机中运行，以实现强隔离。但是，Kata micro-VM将文件操作转发给主机，这使得它容易受到基于内存记账丢失的攻击。更具体地说，通过利用内存记账丢失错误，攻击者可以耗尽微型虚拟机中Kata容器的主机内存。如图所示，恶意用户是容器中的普通用户，并发出fcntl系统调用，为一组文件分配大量POSIX锁。但是，客户机内核将请求转发给运行在主机上的virtio-fsd守护进程。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/attackKatacontainers.png" title alt data-align="center">

<p>因此，守护进程在主机内核中分配了 POSIX 锁。尽管 virtio-fsd 守护进程的内存使用受到 memcg（内存控制组）的限制，但锁对象所使用的内存没有被纳入统计。因此，恶意容器可以耗尽主机上的所有物理内存。我们向 Kata 容器社区报告了这种攻击。他们确认了这个问题，并为我们申请了一个新的 CVE（公开披露的计算机安全漏洞和漏洞）。</p>
<p>用通俗的语言来说，这段话描述了一个安全问题，其中，虚拟文件系统管理的守护程序在主机操作系统上分配了一种名为 POSIX 锁的资源。虽然这个守护程序的内存使用受到限制，但锁对象占用的内存没有被计算在内。这意味着一个恶意的容器（一种轻量级的虚拟化技术）可以利用这个问题耗尽主机的物理内存。作者报告了这个问题，并且 Kata 容器社区已经确认该问题，并正申请一个新的安全漏洞编号（CVE）。</p>
<h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>正如上述攻击所证明的那样，可以利用记账丢失漏洞攻击正常和安全的容器运行时、Docker和CaaS&#x2F;FaaS平台。攻击者可以利用这些漏洞耗尽所有内存，使容器节点甚至整个集群崩溃。更糟糕的是，攻击只需要普通用户权限，因此很容易启动。虽然内存丢失帐户漏洞可以被利用来攻击容器平台，但目前还没有系统的研究来检测和消除这些漏洞。因此，本文提出了第一个内存记账分析工具MANTA，来系统地检测这些问题。</p>
<h1 id="MISSING-ACCOUNT-BUG-DETECTION"><a href="#MISSING-ACCOUNT-BUG-DETECTION" class="headerlink" title="MISSING-ACCOUNT BUG DETECTION"></a>MISSING-ACCOUNT BUG DETECTION</h1><p>考虑到内存记账丢失错误的严重性，在操作系统内核实际在生产场景中运行之前的早期阶段检测这些问题非常重要。不幸的是，没有一种工具可以同时检测高代码覆盖率和高精度的遗漏帐户错误。因此，我们提出了MANTA(Memory AccouNTing Analyzer的缩写)来自动检测内存记账丢失错误。</p>
<ul>
<li><p>Design goals</p>
<p>MANTA旨在通过分析记帐接口放置的正确性来自动、系统地检测内存记账丢失错误。具体来说，MANTA需要检测具有高代码覆盖率的内存记账丢失错误。</p>
<p>为了实现这一点，MANTA利用静态分析来遍历Linux内核中的所有内存分配&#x2F;自由路径。此外，MANTA需要高精度地检测漏洞。因此，MANTA使用动态验证来测试检测到的错误的动态触发性。</p>
</li>
<li><p>Challenges</p>
<p>为了实现这两个目标，MANTA需要克服以下挑战。</p>
<ul>
<li><p>C1. MANTA需要识别内存记帐接口，这些接口在内核文档中没有描述，以前的工作也没有研究过。现有的用于内存分配的接口识别方法不能应用，因为它们的启发式方法不适用于内存计费接口</p>
</li>
<li><p>C2. MANTA需要决定每个内存分配是否被考虑并且只考虑一次。然而，在Linux内核中，从内存分配站点到内存记帐站点的执行路径往往是深的、嵌套的和交错的。此外，即使存在这样的路径，记帐也可能受到条件标志的影响，因为记帐同时需要记帐接口和记帐标志§2</p>
</li>
</ul>
</li>
<li><p>Analysis techniques and workflow</p>
<p>MANTA的体系结构如图所示。以整个内核IR作为输入，MANTA首先生成内核调用图。然后，它使用基于页面计数器的方法来识别所有会计接口以地址C1(§4.1)。基于记帐接口，MANTA建立了内存分配&#x2F;释放和内存记帐之间的映射(§4.2)。</p>
<p>之后，MANTA使用记帐标志分析来进一步分析内核内存记帐(§4.3)。这两种技术处理C2。随着检测到的内存记账错误，MANTA进一步评估每个错误与我们的动态触发性分析基于数千个测试用例从Linux测试项目(§4.4)。MANTA目前是为Linux内存记账实现的。下面，我们将详细介绍每种分析技术。</p>
</li>
</ul>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/challenge.png" title alt data-align="center">

<h2 id="Counter-based-Interface-Identification"><a href="#Counter-based-Interface-Identification" class="headerlink" title="Counter-based Interface Identification"></a>Counter-based Interface Identification</h2><p>MANTA首先需要识别内存记账接口。</p>
<p>这些接口是多种多样的，并且可以自定义。使用自然语言处理(NLP)或包装函数分析的现有技术存在精度问题。我们注意到内存记帐必须维护内存使用计数器(即<code>page_counter</code>)，这些计数器是通过特定的原子函数操作的。使用类型匹配可以很容易地找到内存使用计数器。因此，通过识别用于增加&#x2F;减少这些计数器的基本函数，MANTA可以自动找出对会计计数器执行增加&#x2F;减少操作的所有函数。</p>
<p>具体来说，MANTA遍历每个内核IR指令并检查它是否增加&#x2F;减少<code>page_counter</code>。如果是这样，则MANTA将直接包含该指令的函数标记为基本会计函数。由于在Linux内核中，<code>page_counter</code>仅由<code>memcg</code>使用，因此我们的方法可以达到较高的精度。</p>
<p>然后，MANTA根据基本的记账功能识别会计接口。MANTA使用DFS从基本记账函数向后遍历，并在内核调用图上标记所有访问过的函数。每当它到达<code>memcg</code>子系统之外的函数时，MANTA就会停止遍历，因为它不能是<code>memcg</code>接口。在这些记录内存使用情况的标记函数中，如果一个函数是从<code>memcg</code>子系统外部调用的，即，定义<code>memcg</code>功能的源文件，MANTA将其标记为一个记录接口。这样，MANTA就可以识别所有的计费接口。</p>
<p>让我们使用图中的示例来说明基于计数器的接口标识中的步骤。首先，MANTA遍历所有核函数的所有基本块。在<code>__memcg_kmem_charge</code>中，它标识<code>page_counter</code>函数(第6行)并双重确认第一个参数来自<code>memcg</code>。之后，MANTA进入<code>page_counter_try_charge</code>，发现它增加了<code>page_counter</code>的一个字段。由于<code>__memcg_kmem_charge</code>直接调用<code>page_counter</code>函数并增加<code>page_counter</code>的值，因此MANTA认为<code>__memcg_kmem_charge</code>是一个基本的计费接口。</p>
<p>类似地，对于减少<code>page_counter</code>值的接口，MANTA将其标记为未收费接口。此外，MANTA可以区分不同内存类型的接口，因为<code>memcg</code>对每种内存类型使用不同的<code>page_counters(§2)</code>。在第6行，<code>page_counter_try_charge</code>使用了<code>&amp;memcg-&gt; kmemm</code>，因此MANTA知道<code>__memcg_kmem_charge</code>用于内核内存记帐。</p>
<p>从基本的收费接口开始，MANTA然后沿着调用链逐步识别所有的收费接口包装器。如果一个函数调用基本的计费接口，并且计费量来自于它的参数，MANTA将把它标记为一个计费接口包装器。使用图中的相同示例，<code>__memcg_kmem_charge_page</code>调用基本收费接口<code>__memcg_kmem_charge</code>(第29行)，而收费金额<code>1&lt;&lt;order</code>由<code>__memcg_kmem_charge_page</code>的参数控制。</p>
<p>因此，MANTA认为<code>__memcg_kmem_charge_page</code>是一个收费包装器，因为它只是将收费数量传递给基本收费接口，并且对收费数量没有控制。</p>
<p>MANTA使用相同的方法来检测未充电的包装器。</p>
<p>对于charge&#x2F;uncharge接口，MANTA还需要识别内存分配&#x2F;空闲接口。MANTA采用现有技术来产生初步结果。此外，通过观察内存分配&#x2F;释放接口增加&#x2F;减少<code>struct free_area</code>的<code>nr_free</code>计数器，MANTA使用类似的基于计数器的方法来提高结果的精度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __memcg_kmem_charge(<span class="keyword">struct</span> mem_cgroup *memcg, <span class="type">gfp_t</span> gfp,<span class="type">unsigned</span> <span class="type">int</span> nr_pages)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">counter</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(!cgroup_subsys_on_dfl(memory_cgrp_subsys)&amp;&amp;!page_counter_try_charge(&amp;memcg-&gt;kmem,nr_pages,&amp;counter))</span><br><span class="line"></span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">page_counter_try_charge</span><span class="params">(<span class="keyword">struct</span> page_counter *counter,<span class="type">unsigned</span> <span class="type">long</span> nr_pages,<span class="keyword">struct</span> page_counter **fail)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_counter</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(c = counter; c;c = c-&gt;parent)&#123;</span><br><span class="line">        <span class="type">long</span> new;</span><br><span class="line">        new = atomic_long_add_return(nr_pages,&amp;c-&gt;usage);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __memcg_kmem_charge_page(<span class="keyword">struct</span> page *page, <span class="type">gtp_t</span> gtp,<span class="type">int</span> order)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    memcg = get_mem_cgroup_from_current();</span><br><span class="line">    ...</span><br><span class="line">    ret = __memcg_kmem_charge(memcg,gfp,<span class="number">1</span>&lt;&lt;order);</span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">        page-&gt;mem_cgroup = memcg;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alloc-Charging-Mapping-Analysis"><a href="#Alloc-Charging-Mapping-Analysis" class="headerlink" title="Alloc-Charging Mapping Analysis"></a>Alloc-Charging Mapping Analysis</h2><p>直观地说，每个分配的对象应该只被计算一次。否则，对象可能会被漏记。因此，MANTA 的下一步是建立内存分配&#x2F;释放和计费&#x2F;取消计费之间的关系。基于这种关系，MANTA 可以识别比分配&#x2F;释放的内存少收费或多退费的情况，将其视为漏记错误。简洁起见，我们关注分配和计费。同样的技术可以应用于分析free-uncharging映射。</p>
<p>由于深层次的调用关系和复杂的内存指针传播，从源代码分析分配和计费之间的映射并非易事。为了解决这些问题，我们开发了分配计费(allocation and charging)映射分析。基本思路是首先将函数内的内存分配和计费总结为函数摘要(function summary)，然后基于函数摘要构建内存分配-计费映射，以检测漏记错误。更具体地说，我们使用基于访问路径的分析来生成每个函数的摘要。访问路径的概念首次用于 SATURN 框架，用于表示转义对象的每个函数摘要（即对象指针泄漏到当前函数之外）。</p>
<p>如图左侧算法所示，MANTA 首先为所有函数生成函数摘要（第 2 行）。接下来，对于一个函数𝑓，通过收集其被调用者的函数摘要并分析内存分配位置（IsAlloc），MANTA 可以构建 𝑓 内所有非转义对象的分配-计费映射（第 4-9 行）。具体而言，MANTA 用传递给被调用者的参数替换被调用者摘要中的变量，以计算 𝑓 中分配的页面，这被称为源敏感跟踪。然后，MANTA 通过调用 <code>CheckPage</code> 来分析 𝑓 内的分配-计费映射。在 <code>CheckPage</code> 中，MANTA 能够报告非转义对象的漏记错误（第 19 行）。对于从 𝑓 转义的对象（第 14-18 行），它们最终将在一个函数中（例如 𝑓 的调用者）处理，因为内核中的所有函数都被遍历（第 3-10 行）。此外，<code>IsCharged</code>（第 13 行）和 <code>IsDupCharged</code> 函数（第 21 行）都进行数据流分析，将局部对象连接到被调用函数的返回值或参数。这样，他们可以使用被调用者的函数摘要跟踪内核对象的计费状态。</p>
<p>我们使用图右侧的具体示例来演示算法。MANTA首先为底层内存分配函数<code>__alloc_pages_nodemask</code>生成摘要。 MANTA识别到页面由较低级别的函数<code>get_page_from_freelist</code>返回、充电，并返回。因此，页面既逸出又充电，函数摘要应为（<code>__alloc_pages_nodemask，retval，retval</code>）。当MANTA分析<code>do_anonymous_page</code>时，它会获取<code>alloc_zeroed_user_highpage_movable</code>的函数摘要，该函数是<code>__alloc_pages_nodemask</code>的包装器，具有相同的摘要。根据函数摘要，MANTA确定<code>do_anonymous_page</code>中的页面已经充电。在分析<code>do_anonymous_page</code>内部的分配-计费映射时，MANTA发现内存核算位于第18行可从第14行到达，页面可能在第18行再次被计费。因此，MANTA在这种情况下报告了一个冗余帐户警告。另一方面，如果当前函数中的页面未被计费且不会逸出，MANTA会报告一个未记录错误。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/algorithm.png" title alt data-align="center">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span> * __alloc_pages_nodemask(...)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    page = <span class="built_in">get_page_from_freelist</span>(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">memcg_kmem_enabled</span>()&amp;&amp;(gtp_mask&amp;__GFP_ACCOUNT)&amp;&amp;page&amp;&amp;<span class="built_in">unlikely</span>(__memcg_kmem_charge_page(page,gfp_mask,order)!=<span class="number">0</span>))</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title">do_anonymous_page</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    page = <span class="built_in">alloc_zeroed_user_highpage_movable</span>(vma, vmf-&gt;address);</span><br><span class="line">    <span class="keyword">if</span>(!page)</span><br><span class="line">        <span class="keyword">goto</span> oom;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mem_cgroup_charge</span>(page, vma-&gt;vm_mm, GFP_KERNEL)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Accounting-Flag-Analysis"><a href="#Accounting-Flag-Analysis" class="headerlink" title="Accounting Flag Analysis"></a>Accounting Flag Analysis</h2><p>发现仅依靠分配和记账站点的映射来检测记账丢失错误是不够的，因为内存记账通常是有条件的。特别是在 Linux 内核中，只有当将 <code>__GFP_ACCOUNT</code>标志传递给记账接口时，才会对内核对象内存进行记账。因此，如果没有提供<code> __GFP_ACCOUNT</code> 标志，记账接口仍然不会对内存进行记账。因此，分析记账标志的值对于检测记账丢失至关重要。因此，MANTA 对记账标志进行分析，以确定是否将记账标志 <code>__GFP_ACCOUNT</code> 传递给记账接口。</p>
<p><strong>Bit-wise and inter-procedural analysis</strong></p>
<p>MANTA采用程序间逐位数据流跟踪方法来实现会计标志分析。首先，在计费点，MANTA检查<code>GFP</code>标志本身是否为常数。如果是，MANTA直接检查<code>__GFP_ACCOUNT</code>的位。否则，MANTA将递归地跟踪标志的use-def chain，直到确认其记帐标志位。虽然LLVM提供了一个可以跟踪位值传播的值跟踪分析通道，但该分析仅限于过程内。为了跟踪程序间记帐位，MANTA用两个分析规则扩展了通道。具体来说，当MANTA跟踪函数的参数时，它跟踪所有调用函数以跟踪传递给参数的值;当MANTA跟踪调用站点的返回值时，它也跟踪被调用函数并跟踪所有可能的返回值。如果设置了<code>__GFP_ACCOUNT</code>, MANTA将内核内存标记为在分配点被占用。否则，即使有charging接口，MANTA也会将内存视为not-charged。</p>
<p>对<code>kmem_cache</code>分配的分析略有不同，因为分配也受到<code>kmem_cache</code>的创建标志的影响。</p>
<p>如果<code>kmem_cache</code>是用<code>SLAB_ACCOUNT</code>标志创建的，那么来自<code>kmem_cache</code>的所有分配都会被计算在内。因此，对于与<code>kmem_cache</code>相关的分配，MANTA也会找到<code>kmem_cache</code>的初始化位置，并采用相同的记帐标志分析技术来计算<code>SLAB_ACCOUNT</code>标志。</p>
<h2 id="Dynamic-Validation"><a href="#Dynamic-Validation" class="headerlink" title="Dynamic Validation"></a>Dynamic Validation</h2><p>静态分析可能有误报。MANTA检查每个记账丢失分配的系统调用的静态可达性，并过滤掉不可达的。然而，静态可达的bug不一定在运行时触发。因此，MANTA通过动态验证进一步分析静态检测错误的触发性。观察到Linux测试项目(LTP)包含所有300个系统调用的测试用例，我们利用这些测试用例来检查检测到的错误的动态触发性。更具体地说，我们首先检测代码以拦截每个丢失的记账分配，这样我们就可以确认是否确实达到了它。</p>
<p>接下来，我们运行LTP的系统调用和容器测试套件(包含1,469个测试用例)，以检查是否触发了错误。</p>
<p>此外，我们手动运行现有的工具或开发新的测试用例来触发LTP无法触发的错误。其中一些bug与特定的内核特性密切相关，不能被一般的LTP测试用例(例如keexec和selinux)触发。</p>
<p>因此，我们手动运行相关的用户空间工具来触发它们。</p>
<p>其他原因是由于LTP发现的特定系统调用参数，我们手动开发测试用例来传递这些参数。</p>
<p>对于可以动态触发的记账丢失错误，我们进一步开发了内存耗尽概念验证(PoC)来评估它们的安全风险。我们基于触发记账丢失错误的测试用例开发PoCs。特别是，我们反复调用可能触发PoCs中记账丢失错误的系统调用，并记录记账丢失的内存量。此外，一些记账丢失的分配受到某些约束，例如ulimit和sysctl变量。在不损失通用性的情况下，我们对Amazon Fargate等云服务采用了相同的约束设置。这些PoCs的细节将在§5.2中介绍。</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>我们用4K行的c++代码将MANTA作为LLVM12的一个通道来实现。所分析的Linux内核是v5.10，具有x86-64的默认配置。MANTA使用wllvm和Clang在默认配置下为整个内核生成IR位码。</p>
<p>vmlinux的位码大小为481MB。MANTA使用PeX方法来解析间接调用并生成调用图。</p>
<p>使用建议的技术，MANTA能够在大约三分钟内完成分析，使其具有足够的可扩展性，可以应用于每个Linux主要版本。</p>
<h1 id="MANTA-RESULT"><a href="#MANTA-RESULT" class="headerlink" title="MANTA RESULT"></a>MANTA RESULT</h1><p>在本节中，我们首先给出了MANTA的分析结果。接下来，我们评估了MANTA的查准率和查全率。之后，我们将介绍影响分析以及Linux内核社区报告和修复的错误。最后，我们讨论了MANTA的局限性。</p>
<h2 id="Result-Overview"><a href="#Result-Overview" class="headerlink" title="Result Overview"></a>Result Overview</h2><p>MANTA检测到242个记账丢失的错误，这些错误可以通过60590个不同的路径从273个系统调用中静态地到达。具体来说，用户空间可触发的bug数量为162个，其中LTP触发的bug有134个，现有工具触发的bug有23个，手工开发的测试用例触发的bug有5个。</p>
<p>剩下的80个bug不能被触发，触发失败的原因主要是深度调用路径（80个案例中的72个）。其余的8个分配在内核文档中被明确标记为豁免，或者用于内核内部使用。请注意，这72个没有触发的bug并不都是假阳性，因为我们的测试案例只覆盖了一部分执行路径。保守地说，MANTA的精度大于66.9%（162&#x2F;242）。</p>
<p>我们还通过手动删除会计标志来评估MANTA的召回率。更具体地说，我们首先通过删除kernel&#x2F;子目录下现有的会计标志来生成一个评估集。所有受影响的分配点都被收集在评估集中。特别是，我们删除了11个SLAB_ACCOUNT标志，用GFP_KERNEL替换了5个GFP_KERNEL_ACCOUNT，总共影响了19个内存分配，如表所示。然后我们在修改后的内核代码上运行MANTA，评估结果显示，MANTA可以检测到所有19个缺失的站点。虽然评估的站点有限，但仍表明MANTA有很高的召回率。</p>
<p>此外，MANTA没有发现任何多余的账户漏洞。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/recall.png" title alt data-align="center">

<h2 id="Impact-Analysis"><a href="#Impact-Analysis" class="headerlink" title="Impact Analysis"></a>Impact Analysis</h2><p>如前所述，为了理解检测到的错误的影响，我们进一步开发基于LTP测试用例的概念验证(PoCs)。更具体地说，我们已经开发了17个PoCs，它们涵盖了47个可以从用户空间重复触发的错误，如表所示。我们在具有16GB RAM的QEMU x86_64机器上开发和测试PoCs。Linux发行版是带有Linux内核v5.10的Debian Buster。所有poc都运行在受memg限制的环境中，并具有Docker运行时应用的默认功能集。</p>
<p>除了PoCs覆盖的bug之外，由于时间和领域知识的限制，我们没有为其他可触发的bug开发PoCs。</p>
<p>然而，这些漏洞也可能被具有相应领域知识的攻击者反复可靠地触发。</p>
<img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bug.png" title alt data-align="center">

<h2 id="Reporting-to-Linux-Community"><a href="#Reporting-to-Linux-Community" class="headerlink" title="Reporting to Linux Community"></a>Reporting to Linux Community</h2><p>我们已经向Linux内核社区报告了53个bug，包括所有47个可以由17个用户空间poc触发的bug和6个可以由内核操作反复触发的bug。这些bug的完整列表列在附录A的表中。</p>
<p>在所有报告的bug中，有37个已经被内核开发人员确认。所有这37个bug的补丁都提交了，其中18个已经合并，19个待合并。</p>
<p>由于memcg子系统目前没有维护它的git子树，所以修补过程很慢。因此，memcg维护者不跟踪提交的补丁，并期望补丁作者将通过其他子系统维护者向上游推送补丁。这引入了许多额外的讨论和审查，从而显著地减缓了合并过程。</p>
<p>在与内核开发者的交流中，我们发现内核社区对这些bug非常关注。一位内核开发人员强调，memcg“不仅仅是粗略的记账估计”，而且“应该考虑由用户空间触发的未绑定分配”。此外，内核开发人员对MANTA非常感兴趣，并邀请我们使用我们的工具和实验来测试他们的内核。</p>
<p><img src="/2023/04/23/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-Making-Memory-Account-Accountable%EF%BC%9AAnalyzing-and-Detecting-Memory-Missing-account-bugs-for-Container-Platforms/bugs.png"></p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>MANTA目前有以下限制。</p>
<ul>
<li><p>Static analysis is not sound</p>
<p>由于路径不敏感的函数摘要，MANTA的分析可能会错过记账丢失的错误。当函数在另一条执行路径上对已分配的页进行收费时，它可能不会在其中一条执行路径上对该页收费。在这种情况下，MANTA仍然将功能总结为收费，并在以后的分析中忽略丢失帐户的错误。相反，如果MANTA将功能总结为不收费，则会忽略冗余帐户错误。在未来，我们计划采用像SATURN框架这样的路径敏感摘要来提高稳健性。</p>
</li>
<li><p>Dynamic triggerable test is not complete</p>
<p>目前，MANTA使用LTP测试用例来测试是否可以触发静态检测错误。LTP测试用例是有限的。这些测试用例不可能涵盖内核中所有可能的执行路径。</p>
<p>因此，由于不完整的代码覆盖，MANTA可能会错过一些可触发的错误。因此，我们未来的工作之一是开发更多的测试用例，并采用模糊测试技术来增加代码覆盖率。</p>
</li>
</ul>
<h1 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h1><h2 id="Memory-Accounting"><a href="#Memory-Accounting" class="headerlink" title="Memory Accounting"></a>Memory Accounting</h2><p>JRes为JVM实现内存计费接口。内存记帐接口在对象分配期间收取内存使用费用，在垃圾收集期间收取费用。但是，JRes没有为共享对象实现充电机制。</p>
<p>Price等和MzSchem为用户空间运行时环境提出了基于消费者的内存计费方案，以计算子任务的内存使用情况。它们选择向实际用户收取内存使用费用，而不是向内存分配器收取。它们修改运行时垃圾收集器，以便它可以在释放对象之前释放对象，并将其重新充值到保存其引用的实体中。然而，由于在内核中实现足够高效的垃圾收集仍然是一个挑战，因此很难在内核中直接采用它们。基于vm的工作提供了更好的内存隔离，并且可以解决单片内核中的每个进程记帐问题。然而，传统的基于vm的方案过于重量级，并且引入了很高的性能开销。与基于容器的方案相比，基于unikernel的方法实现了更低的启动延迟和更高的吞吐量，但缺乏兼容性。</p>
<p>MANTA的分配-充电映射分析类似于内存泄漏检测中使用的分配-自由映射分析。泄漏检查器使用上下文和路径敏感的分析方法来检测内存泄漏。Saber和FaskCheck使用按需稀疏价值流分析来检测内存泄漏。LeakFix首先尝试定位导致泄漏的空闲内存并修复它。AutoFix通过结合静态分析和运行时检查来检测和修复内存泄漏。PCA使用选择性流敏感算法进一步加快程序间数据流分析的内存泄漏检测。然而，这些工作依赖于手动输入或特定的启发式来决定分配&#x2F;释放接口，这不能应用于识别内存计费接口。</p>
<h2 id="Resource-Accounting"><a href="#Resource-Accounting" class="headerlink" title="Resource Accounting"></a>Resource Accounting</h2><p>Houdini的escape利用内核下半部分的工作线程、服务进程和中断来绕过控制组的限制。然而，它没有关注memcg，也没有分析对照组的实施情况。对比胡迪尼的越狱，我们系统地定义了memcg中可能存在的问题，识别并报告了memcg中的53个bug。Yang等提出了抽象资源的概念，并发现在容器内耗尽这些资源会导致对主机的DoS攻击。资源容器提出了一个操作系统级别的抽象来考虑整个系统的资源使用情况。它是描述在每个线程级别计算一般资源的方法的第一本书。与以前的工作相比，资源容器工作在系统内核上，可以解决由用户线程引起的内核资源消耗。Zhang等提出将内核下半进程的cpu时间使用收费给受影响的用户进程，以提高公平性。</p>
<p>Perez等人观察到EVM的气体计量与工作节点上的实际资源消耗，特别是CPU周期不一致。它表明，当页面缓存工作不佳时，实际的不一致性会进一步增加，而支付者则要为相同数量的gas付费。本文还提出了一种能够充分利用不一致性的自动合成有效载荷的方法。Liu发现CPU时间计量在各种真实的云平台上都很脆弱。他们提出了6种可以利用进程启动时或运行时的CPU计量的攻击。</p>
<h1 id="CONCLUSION-AND-FUTURE-WORK"><a href="#CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="CONCLUSION AND FUTURE WORK"></a>CONCLUSION AND FUTURE WORK</h1><p>本文首次系统地分析和检测了Linux系统中存在的内存记账缺失问题。我们进行了深入的分析，以了解容器平台上内存记账丢失错误的可利用性和安全影响。</p>
<p>我们的分析表明，所有容器运行时(包括正常运行时和安全运行时)都容易受到由记账丢失错误导致的内存耗尽攻击。此外，内存记账丢失漏洞可以被利用来攻击Docker、CaaS和FaaS平台，导致内存耗尽，从而导致节点甚至整个集群崩溃。</p>
<p>然后，我们提出了MANTA，它结合了静态和动态分析技术，以高代码覆盖率和精度自动检测内存记账丢失错误。我们的检测工具报告了53个可利用的内存丢失帐户错误，其中37个已被内核开发人员确认，分配了两个新的cve。结果表明，MANTA可以有效地缓解内存记帐系统中的记账丢失问题。</p>
<p>我们未来的工作是研究如何在不调解所有内存分配&#x2F;自由路径的情况下准确地计算内存使用情况。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/04/22/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%BA%93/" rel="prev" title="C++ 学习 Linux系统编程 库">
      <i class="fa fa-chevron-left"></i> C++ 学习 Linux系统编程 库
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/24/C++-%E5%AD%A6%E4%B9%A0-Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-Makefile/" rel="next" title="C++ 学习 Linux系统编程 Makefile">
      C++ 学习 Linux系统编程 Makefile <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#INTRODUCTION"><span class="nav-number">1.</span> <span class="nav-text">INTRODUCTION</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BACKGROUD"><span class="nav-number">2.</span> <span class="nav-text">BACKGROUD</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-Memory-Accounting"><span class="nav-number">2.1.</span> <span class="nav-text">Linux Memory Accounting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-Runtimes-and-Platforms"><span class="nav-number">2.2.</span> <span class="nav-text">Container Runtimes and Platforms</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#A-STUDY-OF-EXPLOITABLITY-AND-IMPACT"><span class="nav-number">3.</span> <span class="nav-text">A STUDY OF EXPLOITABLITY AND IMPACT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Threat-Model-and-Assumptions"><span class="nav-number">3.1.</span> <span class="nav-text">Threat Model and Assumptions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exploit-Missing-Account-Problem"><span class="nav-number">3.2.</span> <span class="nav-text">Exploit Missing-Account Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Attacking-Docker"><span class="nav-number">3.2.1.</span> <span class="nav-text">Attacking Docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attacking-the-CaaS-Platform"><span class="nav-number">3.2.2.</span> <span class="nav-text">Attacking the CaaS Platform</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attacking-the-FaaS-Platform"><span class="nav-number">3.2.3.</span> <span class="nav-text">Attacking the FaaS Platform</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attacking-the-Secure-Runtime"><span class="nav-number">3.2.4.</span> <span class="nav-text">Attacking the Secure Runtime</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Discussion"><span class="nav-number">3.3.</span> <span class="nav-text">Discussion</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MISSING-ACCOUNT-BUG-DETECTION"><span class="nav-number">4.</span> <span class="nav-text">MISSING-ACCOUNT BUG DETECTION</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Counter-based-Interface-Identification"><span class="nav-number">4.1.</span> <span class="nav-text">Counter-based Interface Identification</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alloc-Charging-Mapping-Analysis"><span class="nav-number">4.2.</span> <span class="nav-text">Alloc-Charging Mapping Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Accounting-Flag-Analysis"><span class="nav-number">4.3.</span> <span class="nav-text">Accounting Flag Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dynamic-Validation"><span class="nav-number">4.4.</span> <span class="nav-text">Dynamic Validation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation"><span class="nav-number">4.5.</span> <span class="nav-text">Implementation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MANTA-RESULT"><span class="nav-number">5.</span> <span class="nav-text">MANTA RESULT</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Result-Overview"><span class="nav-number">5.1.</span> <span class="nav-text">Result Overview</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Impact-Analysis"><span class="nav-number">5.2.</span> <span class="nav-text">Impact Analysis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reporting-to-Linux-Community"><span class="nav-number">5.3.</span> <span class="nav-text">Reporting to Linux Community</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Limitations"><span class="nav-number">5.4.</span> <span class="nav-text">Limitations</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RELATED-WORK"><span class="nav-number">6.</span> <span class="nav-text">RELATED WORK</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Accounting"><span class="nav-number">6.1.</span> <span class="nav-text">Memory Accounting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resource-Accounting"><span class="nav-number">6.2.</span> <span class="nav-text">Resource Accounting</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CONCLUSION-AND-FUTURE-WORK"><span class="nav-number">7.</span> <span class="nav-text">CONCLUSION AND FUTURE WORK</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plucky</p>
  <div class="site-description" itemprop="description">记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Plucky923" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Plucky923" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:p1ucky@163.com" title="E-Mail → mailto:p1ucky@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plucky</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">41:01</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '3420f2814bb4c3c82f84',
      clientSecret: '9d285617447c550188bd893fc3aad7c9b00f2d00',
      repo        : 'Blog-talk',
      owner       : 'Plucky923',
      admin       : ['Plucky923'],
      id          : 'd87605ef5853be4186f53899d3200b0b',
        language: 'zh-CH',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
